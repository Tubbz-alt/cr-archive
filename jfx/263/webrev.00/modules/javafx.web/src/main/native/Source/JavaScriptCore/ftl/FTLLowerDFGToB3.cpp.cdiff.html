<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLLowerDFGToB3.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FTLLocation.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLOSREntry.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLLowerDFGToB3.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 37,10 ***</span>
<span class="line-new-header">--- 37,11 ---</span>
  #include &quot;B3FenceValue.h&quot;
  #include &quot;B3PatchpointValue.h&quot;
  #include &quot;B3SlotBaseValue.h&quot;
  #include &quot;B3StackmapGenerationParams.h&quot;
  #include &quot;B3ValueInlines.h&quot;
<span class="line-added">+ #include &quot;ButterflyInlines.h&quot;</span>
  #include &quot;CallFrameShuffler.h&quot;
  #include &quot;CodeBlockWithJITType.h&quot;
  #include &quot;DFGAbstractInterpreterInlines.h&quot;
  #include &quot;DFGCapabilities.h&quot;
  #include &quot;DFGDoesGC.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 73,13 ***</span>
<span class="line-new-header">--- 74,16 ---</span>
  #include &quot;JITLeftShiftGenerator.h&quot;
  #include &quot;JITMathIC.h&quot;
  #include &quot;JITMulGenerator.h&quot;
  #include &quot;JITRightShiftGenerator.h&quot;
  #include &quot;JITSubGenerator.h&quot;
<span class="line-added">+ #include &quot;JSArrayIterator.h&quot;</span>
  #include &quot;JSAsyncFunction.h&quot;
<span class="line-added">+ #include &quot;JSAsyncGenerator.h&quot;</span>
  #include &quot;JSAsyncGeneratorFunction.h&quot;
  #include &quot;JSCInlines.h&quot;
<span class="line-added">+ #include &quot;JSGenerator.h&quot;</span>
  #include &quot;JSGeneratorFunction.h&quot;
  #include &quot;JSImmutableButterfly.h&quot;
  #include &quot;JSLexicalEnvironment.h&quot;
  #include &quot;JSMap.h&quot;
  #include &quot;OperandsInlines.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 116,21 ***</span>
  
  namespace {
  
  std::atomic&lt;int&gt; compileCounter;
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
  NO_RETURN_DUE_TO_CRASH static void ftlUnreachable(
      CodeBlock* codeBlock, BlockIndex blockIndex, unsigned nodeIndex)
  {
      dataLog(&quot;Crashing in thought-to-be-unreachable FTL-generated code for &quot;, pointerDump(codeBlock), &quot; at basic block #&quot;, blockIndex);
      if (nodeIndex != UINT_MAX)
          dataLog(&quot;, node @&quot;, nodeIndex);
      dataLog(&quot;.\n&quot;);
      CRASH();
  }
<span class="line-modified">! #endif</span>
  
  // Using this instead of typeCheck() helps to reduce the load on B3, by creating
  // significantly less dead code.
  #define FTL_TYPE_CHECK_WITH_EXIT_KIND(exitKind, lowValue, highValue, typesPassedThrough, failCondition) do { \
          FormattedValue _ftc_lowValue = (lowValue);                      \
<span class="line-new-header">--- 120,21 ---</span>
  
  namespace {
  
  std::atomic&lt;int&gt; compileCounter;
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
  NO_RETURN_DUE_TO_CRASH static void ftlUnreachable(
      CodeBlock* codeBlock, BlockIndex blockIndex, unsigned nodeIndex)
  {
      dataLog(&quot;Crashing in thought-to-be-unreachable FTL-generated code for &quot;, pointerDump(codeBlock), &quot; at basic block #&quot;, blockIndex);
      if (nodeIndex != UINT_MAX)
          dataLog(&quot;, node @&quot;, nodeIndex);
      dataLog(&quot;.\n&quot;);
      CRASH();
  }
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
  
  // Using this instead of typeCheck() helps to reduce the load on B3, by creating
  // significantly less dead code.
  #define FTL_TYPE_CHECK_WITH_EXIT_KIND(exitKind, lowValue, highValue, typesPassedThrough, failCondition) do { \
          FormattedValue _ftc_lowValue = (lowValue);                      \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 153,11 ***</span>
          , m_out(state)
          , m_proc(*state.proc)
          , m_availabilityCalculator(m_graph)
          , m_state(state.graph)
          , m_interpreter(state.graph, m_state)
<span class="line-removed">-         , m_indexMaskingMode(Options::enableSpectreMitigations() ?  IndexMaskingEnabled : IndexMaskingDisabled)</span>
      {
          if (Options::validateAbstractInterpreterState()) {
              performLivenessAnalysis(m_graph);
  
              // We only use node liveness here, not combined liveness, as we only track
<span class="line-new-header">--- 157,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 200,18 ***</span>
  
              Ref&lt;B3::Air::PrologueGenerator&gt; catchPrologueGenerator = createSharedTask&lt;B3::Air::PrologueGeneratorFunction&gt;(
                  [codeBlock] (CCallHelpers&amp; jit, B3::Air::Code&amp; code) {
                      AllowMacroScratchRegisterUsage allowScratch(jit);
                      jit.addPtr(CCallHelpers::TrustedImm32(-code.frameSize()), GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
<span class="line-removed">-                     if (Options::zeroStackFrame())</span>
<span class="line-removed">-                         jit.clearStackFrame(GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister, GPRInfo::regT0, code.frameSize());</span>
  
                      jit.emitSave(code.calleeSaveRegisterAtOffsetList());
<span class="line-modified">!                     jit.emitPutToCallFrameHeader(codeBlock, CallFrameSlot::codeBlock);</span>
                  });
  
<span class="line-modified">!             for (unsigned catchEntrypointIndex : m_graph.m_entrypointIndexToCatchBytecodeOffset.keys()) {</span>
                  RELEASE_ASSERT(catchEntrypointIndex != 0);
                  m_proc.code().setPrologueForEntrypoint(catchEntrypointIndex, catchPrologueGenerator.copyRef());
              }
  
              if (m_graph.m_maxLocalsForCatchOSREntry) {
<span class="line-new-header">--- 203,16 ---</span>
  
              Ref&lt;B3::Air::PrologueGenerator&gt; catchPrologueGenerator = createSharedTask&lt;B3::Air::PrologueGeneratorFunction&gt;(
                  [codeBlock] (CCallHelpers&amp; jit, B3::Air::Code&amp; code) {
                      AllowMacroScratchRegisterUsage allowScratch(jit);
                      jit.addPtr(CCallHelpers::TrustedImm32(-code.frameSize()), GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
  
                      jit.emitSave(code.calleeSaveRegisterAtOffsetList());
<span class="line-modified">!                     jit.emitPutToCallFrameHeader(codeBlock, VirtualRegister(CallFrameSlot::codeBlock));</span>
                  });
  
<span class="line-modified">!             for (unsigned catchEntrypointIndex : m_graph.m_entrypointIndexToCatchBytecodeIndex.keys()) {</span>
                  RELEASE_ASSERT(catchEntrypointIndex != 0);
                  m_proc.code().setPrologueForEntrypoint(catchEntrypointIndex, catchPrologueGenerator.copyRef());
              }
  
              if (m_graph.m_maxLocalsForCatchOSREntry) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 256,30 ***</span>
          m_captured = m_out.add(capturedBase, m_out.constIntPtr(sizeOfCaptured));
          state-&gt;capturedValue = capturedBase-&gt;slot();
  
          auto preOrder = m_graph.blocksInPreOrder();
  
          m_callFrame = m_out.framePointer();
<span class="line-modified">!         m_tagTypeNumber = m_out.constInt64(TagTypeNumber);</span>
<span class="line-modified">!         m_tagMask = m_out.constInt64(TagMask);</span>
  
          // Make sure that B3 knows that we really care about the mask registers. This forces the
          // constants to be materialized in registers.
<span class="line-modified">!         m_proc.addFastConstant(m_tagTypeNumber-&gt;key());</span>
<span class="line-modified">!         m_proc.addFastConstant(m_tagMask-&gt;key());</span>
  
          // We don&#39;t want the CodeBlock to have a weak pointer to itself because
          // that would cause it to always get collected.
<span class="line-modified">!         m_out.storePtr(m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(codeBlock())), addressFor(CallFrameSlot::codeBlock));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         VM* vm = &amp;this-&gt;vm();</span>
  
          // Stack Overflow Check.
          unsigned exitFrameSize = m_graph.requiredRegisterCountForExit() * sizeof(Register);
          MacroAssembler::AbsoluteAddress addressOfStackLimit(vm-&gt;addressOfSoftStackLimit());
          PatchpointValue* stackOverflowHandler = m_out.patchpoint(Void);
<span class="line-modified">!         CallSiteIndex callSiteIndex = callSiteIndexForCodeOrigin(m_ftlState, CodeOrigin(0));</span>
          stackOverflowHandler-&gt;appendSomeRegister(m_callFrame);
          stackOverflowHandler-&gt;clobber(RegisterSet::macroScratchRegisters());
          stackOverflowHandler-&gt;numGPScratchRegisters = 1;
          stackOverflowHandler-&gt;setGenerator(
              [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
<span class="line-new-header">--- 257,31 ---</span>
          m_captured = m_out.add(capturedBase, m_out.constIntPtr(sizeOfCaptured));
          state-&gt;capturedValue = capturedBase-&gt;slot();
  
          auto preOrder = m_graph.blocksInPreOrder();
  
<span class="line-added">+         VM* vm = &amp;this-&gt;vm();</span>
<span class="line-added">+ </span>
          m_callFrame = m_out.framePointer();
<span class="line-modified">!         m_vmValue = m_out.constIntPtr(vm);</span>
<span class="line-modified">!         m_numberTag = m_out.constInt64(JSValue::NumberTag);</span>
<span class="line-added">+         m_notCellMask = m_out.constInt64(JSValue::NotCellMask);</span>
  
          // Make sure that B3 knows that we really care about the mask registers. This forces the
          // constants to be materialized in registers.
<span class="line-modified">!         m_proc.addFastConstant(m_numberTag-&gt;key());</span>
<span class="line-modified">!         m_proc.addFastConstant(m_notCellMask-&gt;key());</span>
  
          // We don&#39;t want the CodeBlock to have a weak pointer to itself because
          // that would cause it to always get collected.
<span class="line-modified">!         m_out.storePtr(m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(codeBlock())), addressFor(VirtualRegister(CallFrameSlot::codeBlock)));</span>
  
          // Stack Overflow Check.
          unsigned exitFrameSize = m_graph.requiredRegisterCountForExit() * sizeof(Register);
          MacroAssembler::AbsoluteAddress addressOfStackLimit(vm-&gt;addressOfSoftStackLimit());
          PatchpointValue* stackOverflowHandler = m_out.patchpoint(Void);
<span class="line-modified">!         CallSiteIndex callSiteIndex = callSiteIndexForCodeOrigin(m_ftlState, CodeOrigin(BytecodeIndex(0)));</span>
          stackOverflowHandler-&gt;appendSomeRegister(m_callFrame);
          stackOverflowHandler-&gt;clobber(RegisterSet::macroScratchRegisters());
          stackOverflowHandler-&gt;numGPScratchRegisters = 1;
          stackOverflowHandler-&gt;setGenerator(
              [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 307,26 ***</span>
                      // https://bugs.webkit.org/show_bug.cgi?id=172456
                      jit.emitRestore(params.proc().calleeSaveRegisterAtOffsetList());
  
                      jit.store32(
                          MacroAssembler::TrustedImm32(callSiteIndex.bits()),
<span class="line-modified">!                         CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));</span>
                      jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm-&gt;topEntryFrame);
  
<span class="line-modified">!                     jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);</span>
<span class="line-modified">!                     jit.move(CCallHelpers::TrustedImmPtr(jit.codeBlock()), GPRInfo::argumentGPR1);</span>
                      CCallHelpers::Call throwCall = jit.call(OperationPtrTag);
  
                      jit.move(CCallHelpers::TrustedImmPtr(vm), GPRInfo::argumentGPR0);
<span class="line-modified">!                     jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR1);</span>
                      CCallHelpers::Call lookupExceptionHandlerCall = jit.call(OperationPtrTag);
                      jit.jumpToExceptionHandler(*vm);
  
                      jit.addLinkTask(
                          [=] (LinkBuffer&amp; linkBuffer) {
                              linkBuffer.link(throwCall, FunctionPtr&lt;OperationPtrTag&gt;(operationThrowStackOverflowError));
<span class="line-modified">!                             linkBuffer.link(lookupExceptionHandlerCall, FunctionPtr&lt;OperationPtrTag&gt;(lookupExceptionHandlerFromCallerFrame));</span>
                      });
                  });
              });
  
          LBasicBlock firstDFGBasicBlock = lowBlock(m_graph.block(0));
<span class="line-new-header">--- 309,26 ---</span>
                      // https://bugs.webkit.org/show_bug.cgi?id=172456
                      jit.emitRestore(params.proc().calleeSaveRegisterAtOffsetList());
  
                      jit.store32(
                          MacroAssembler::TrustedImm32(callSiteIndex.bits()),
<span class="line-modified">!                         CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
                      jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm-&gt;topEntryFrame);
  
<span class="line-modified">!                     jit.move(CCallHelpers::TrustedImmPtr(jit.codeBlock()), GPRInfo::argumentGPR0);</span>
<span class="line-modified">!                     jit.prepareCallOperation(*vm);</span>
                      CCallHelpers::Call throwCall = jit.call(OperationPtrTag);
  
                      jit.move(CCallHelpers::TrustedImmPtr(vm), GPRInfo::argumentGPR0);
<span class="line-modified">!                     jit.prepareCallOperation(*vm);</span>
                      CCallHelpers::Call lookupExceptionHandlerCall = jit.call(OperationPtrTag);
                      jit.jumpToExceptionHandler(*vm);
  
                      jit.addLinkTask(
                          [=] (LinkBuffer&amp; linkBuffer) {
                              linkBuffer.link(throwCall, FunctionPtr&lt;OperationPtrTag&gt;(operationThrowStackOverflowError));
<span class="line-modified">!                             linkBuffer.link(lookupExceptionHandlerCall, FunctionPtr&lt;OperationPtrTag&gt;(operationLookupExceptionHandlerFromCallerFrame));</span>
                      });
                  });
              });
  
          LBasicBlock firstDFGBasicBlock = lowBlock(m_graph.block(0));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 346,23 ***</span>
                  m_out.entrySwitch(successors);
                  m_out.appendTo(callEntrypointArgumentSpeculations, m_handleExceptions);
              }
  
              m_node = nullptr;
<span class="line-modified">!             m_origin = NodeOrigin(CodeOrigin(0), CodeOrigin(0), true);</span>
  
              // Check Arguments.
              availabilityMap().clear();
<span class="line-modified">!             availabilityMap().m_locals = Operands&lt;Availability&gt;(codeBlock()-&gt;numParameters(), 0);</span>
              for (unsigned i = codeBlock()-&gt;numParameters(); i--;) {
                  availabilityMap().m_locals.argument(i) =
<span class="line-modified">!                     Availability(FlushedAt(FlushedJSValue, virtualRegisterForArgument(i)));</span>
              }
  
              for (unsigned i = codeBlock()-&gt;numParameters(); i--;) {
                  MethodOfGettingAValueProfile profile(&amp;m_graph.m_profiledBlock-&gt;valueProfileForArgument(i));
<span class="line-modified">!                 VirtualRegister operand = virtualRegisterForArgument(i);</span>
                  LValue jsValue = m_out.load64(addressFor(operand));
  
                  switch (m_graph.m_argumentFormats[0][i]) {
                  case FlushedInt32:
                      speculate(BadType, jsValueValue(jsValue), profile, isNotInt32(jsValue));
<span class="line-new-header">--- 348,23 ---</span>
                  m_out.entrySwitch(successors);
                  m_out.appendTo(callEntrypointArgumentSpeculations, m_handleExceptions);
              }
  
              m_node = nullptr;
<span class="line-modified">!             m_origin = NodeOrigin(CodeOrigin(BytecodeIndex(0)), CodeOrigin(BytecodeIndex(0)), true);</span>
  
              // Check Arguments.
              availabilityMap().clear();
<span class="line-modified">!             availabilityMap().m_locals = Operands&lt;Availability&gt;(codeBlock()-&gt;numParameters(), 0, 0);</span>
              for (unsigned i = codeBlock()-&gt;numParameters(); i--;) {
                  availabilityMap().m_locals.argument(i) =
<span class="line-modified">!                     Availability(FlushedAt(FlushedJSValue, virtualRegisterForArgumentIncludingThis(i)));</span>
              }
  
              for (unsigned i = codeBlock()-&gt;numParameters(); i--;) {
                  MethodOfGettingAValueProfile profile(&amp;m_graph.m_profiledBlock-&gt;valueProfileForArgument(i));
<span class="line-modified">!                 VirtualRegister operand = virtualRegisterForArgumentIncludingThis(i);</span>
                  LValue jsValue = m_out.load64(addressFor(operand));
  
                  switch (m_graph.m_argumentFormats[0][i]) {
                  case FlushedInt32:
                      speculate(BadType, jsValueValue(jsValue), profile, isNotInt32(jsValue));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 747,10 ***</span>
<span class="line-new-header">--- 749,14 ---</span>
              compileToObjectOrCallObjectConstructor();
              break;
          case ToThis:
              compileToThis();
              break;
<span class="line-added">+         case Inc:</span>
<span class="line-added">+         case Dec:</span>
<span class="line-added">+             compileIncOrDec();</span>
<span class="line-added">+             break;</span>
          case ValueNegate:
              compileValueNegate();
              break;
          case ValueAdd:
              compileValueAdd();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 848,12 ***</span>
              compileArithBitXor();
              break;
          case ValueBitXor:
              compileValueBitXor();
              break;
<span class="line-modified">!         case BitRShift:</span>
<span class="line-modified">!             compileBitRShift();</span>
              break;
          case ArithBitLShift:
              compileArithBitLShift();
              break;
          case ValueBitLShift:
<span class="line-new-header">--- 854,15 ---</span>
              compileArithBitXor();
              break;
          case ValueBitXor:
              compileValueBitXor();
              break;
<span class="line-modified">!         case ValueBitRShift:</span>
<span class="line-modified">!             compileValueBitRShift();</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case ArithBitRShift:</span>
<span class="line-added">+             compileArithBitRShift();</span>
              break;
          case ArithBitLShift:
              compileArithBitLShift();
              break;
          case ValueBitLShift:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 881,12 ***</span>
              compileAssertNotEmpty();
              break;
          case CheckBadCell:
              compileCheckBadCell();
              break;
<span class="line-modified">!         case CheckStringIdent:</span>
<span class="line-modified">!             compileCheckStringIdent();</span>
              break;
          case GetExecutable:
              compileGetExecutable();
              break;
          case Arrayify:
<span class="line-new-header">--- 890,12 ---</span>
              compileAssertNotEmpty();
              break;
          case CheckBadCell:
              compileCheckBadCell();
              break;
<span class="line-modified">!         case CheckIdent:</span>
<span class="line-modified">!             compileCheckIdent();</span>
              break;
          case GetExecutable:
              compileGetExecutable();
              break;
          case Arrayify:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 895,22 ***</span>
              break;
          case PutStructure:
              compilePutStructure();
              break;
          case TryGetById:
<span class="line-modified">!             compileGetById(AccessType::TryGet);</span>
              break;
          case GetById:
          case GetByIdFlush:
<span class="line-modified">!             compileGetById(AccessType::Get);</span>
              break;
          case GetByIdWithThis:
              compileGetByIdWithThis();
              break;
          case GetByIdDirect:
          case GetByIdDirectFlush:
<span class="line-modified">!             compileGetById(AccessType::GetDirect);</span>
              break;
          case InById:
              compileInById();
              break;
          case InByVal:
<span class="line-new-header">--- 904,22 ---</span>
              break;
          case PutStructure:
              compilePutStructure();
              break;
          case TryGetById:
<span class="line-modified">!             compileGetById(AccessType::TryGetById);</span>
              break;
          case GetById:
          case GetByIdFlush:
<span class="line-modified">!             compileGetById(AccessType::GetById);</span>
              break;
          case GetByIdWithThis:
              compileGetByIdWithThis();
              break;
          case GetByIdDirect:
          case GetByIdDirectFlush:
<span class="line-modified">!             compileGetById(AccessType::GetByIdDirect);</span>
              break;
          case InById:
              compileInById();
              break;
          case InByVal:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 954,10 ***</span>
<span class="line-new-header">--- 963,16 ---</span>
              compileGetIndexedPropertyStorage();
              break;
          case CheckArray:
              compileCheckArray();
              break;
<span class="line-added">+         case CheckArrayOrEmpty:</span>
<span class="line-added">+             compileCheckArrayOrEmpty();</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case CheckNeutered:</span>
<span class="line-added">+             compileCheckNeutered();</span>
<span class="line-added">+             break;</span>
          case GetArrayLength:
              compileGetArrayLength();
              break;
          case GetVectorLength:
              compileGetVectorLength();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1034,19 ***</span>
<span class="line-new-header">--- 1049,34 ---</span>
              compileCreateScopedArguments();
              break;
          case CreateClonedArguments:
              compileCreateClonedArguments();
              break;
<span class="line-added">+         case CreateArgumentsButterfly:</span>
<span class="line-added">+             compileCreateArgumentsButterfly();</span>
<span class="line-added">+             break;</span>
          case ObjectCreate:
              compileObjectCreate();
              break;
          case ObjectKeys:
              compileObjectKeys();
              break;
          case NewObject:
              compileNewObject();
              break;
<span class="line-added">+         case NewPromise:</span>
<span class="line-added">+             compileNewPromise();</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case NewGenerator:</span>
<span class="line-added">+             compileNewGenerator();</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case NewAsyncGenerator:</span>
<span class="line-added">+             compileNewAsyncGenerator();</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case NewArrayIterator:</span>
<span class="line-added">+             compileNewArrayIterator();</span>
<span class="line-added">+             break;</span>
          case NewStringObject:
              compileNewStringObject();
              break;
          case NewSymbol:
              compileNewSymbol();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1058,10 ***</span>
<span class="line-new-header">--- 1088,19 ---</span>
              compileNewArrayWithSpread();
              break;
          case CreateThis:
              compileCreateThis();
              break;
<span class="line-added">+         case CreatePromise:</span>
<span class="line-added">+             compileCreatePromise();</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case CreateGenerator:</span>
<span class="line-added">+             compileCreateGenerator();</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case CreateAsyncGenerator:</span>
<span class="line-added">+             compileCreateAsyncGenerator();</span>
<span class="line-added">+             break;</span>
          case Spread:
              compileSpread();
              break;
          case NewArrayBuffer:
              compileNewArrayBuffer();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1088,27 ***</span>
<span class="line-new-header">--- 1127,36 ---</span>
              compileNukeStructureAndSetButterfly();
              break;
          case ToNumber:
              compileToNumber();
              break;
<span class="line-added">+         case ToNumeric:</span>
<span class="line-added">+             compileToNumeric();</span>
<span class="line-added">+             break;</span>
          case ToString:
          case CallStringConstructor:
          case StringValueOf:
              compileToStringOrCallStringConstructorOrStringValueOf();
              break;
          case ToPrimitive:
              compileToPrimitive();
              break;
<span class="line-added">+         case ToPropertyKey:</span>
<span class="line-added">+             compileToPropertyKey();</span>
<span class="line-added">+             break;</span>
          case MakeRope:
              compileMakeRope();
              break;
          case StringCharAt:
              compileStringCharAt();
              break;
          case StringCharCodeAt:
              compileStringCharCodeAt();
              break;
<span class="line-added">+         case StringCodePointAt:</span>
<span class="line-added">+             compileStringCodePointAt();</span>
<span class="line-added">+             break;</span>
          case StringFromCharCode:
              compileStringFromCharCode();
              break;
          case GetByOffset:
          case GetGetterSetterByOffset:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1170,10 ***</span>
<span class="line-new-header">--- 1218,16 ---</span>
              compileGetClosureVar();
              break;
          case PutClosureVar:
              compilePutClosureVar();
              break;
<span class="line-added">+         case GetInternalField:</span>
<span class="line-added">+             compileGetInternalField();</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case PutInternalField:</span>
<span class="line-added">+             compilePutInternalField();</span>
<span class="line-added">+             break;</span>
          case GetFromArguments:
              compileGetFromArguments();
              break;
          case PutToArguments:
              compilePutToArguments();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1239,10 ***</span>
<span class="line-new-header">--- 1293,13 ---</span>
              compileCallOrConstructVarargs();
              break;
          case CallEval:
              compileCallEval();
              break;
<span class="line-added">+         case VarargsLength:</span>
<span class="line-added">+             compileVarargsLength();</span>
<span class="line-added">+             break;</span>
          case LoadVarargs:
              compileLoadVarargs();
              break;
          case ForwardVarargs:
              compileForwardVarargs();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1418,10 ***</span>
<span class="line-new-header">--- 1475,13 ---</span>
              compileMaterializeNewObject();
              break;
          case MaterializeCreateActivation:
              compileMaterializeCreateActivation();
              break;
<span class="line-added">+         case MaterializeNewInternalFieldObject:</span>
<span class="line-added">+             compileMaterializeNewInternalFieldObject();</span>
<span class="line-added">+             break;</span>
          case CheckTraps:
              compileCheckTraps();
              break;
          case CreateRest:
              compileCreateRest();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1504,15 ***</span>
              break;
          case CallDOMGetter:
              compileCallDOMGetter();
              break;
          case FilterCallLinkStatus:
<span class="line-modified">!         case FilterGetByIdStatus:</span>
          case FilterPutByIdStatus:
          case FilterInByIdStatus:
              compileFilterICStatus();
              break;
          case DataViewGetInt:
          case DataViewGetFloat:
              compileDataViewGet();
              break;
          case DataViewSet:
<span class="line-new-header">--- 1564,19 ---</span>
              break;
          case CallDOMGetter:
              compileCallDOMGetter();
              break;
          case FilterCallLinkStatus:
<span class="line-modified">!         case FilterGetByStatus:</span>
          case FilterPutByIdStatus:
          case FilterInByIdStatus:
              compileFilterICStatus();
              break;
<span class="line-added">+         case DateGetInt32OrNaN:</span>
<span class="line-added">+         case DateGetTime:</span>
<span class="line-added">+             compileDateGet();</span>
<span class="line-added">+             break;</span>
          case DataViewGetInt:
          case DataViewGetFloat:
              compileDataViewGet();
              break;
          case DataViewSet:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1527,10 ***</span>
<span class="line-new-header">--- 1591,11 ---</span>
          case PhantomNewObject:
          case PhantomNewFunction:
          case PhantomNewGeneratorFunction:
          case PhantomNewAsyncGeneratorFunction:
          case PhantomNewAsyncFunction:
<span class="line-added">+         case PhantomNewArrayIterator:</span>
          case PhantomCreateActivation:
          case PhantomDirectArguments:
          case PhantomCreateRest:
          case PhantomSpread:
          case PhantomNewArrayWithSpread:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1714,36 ***</span>
                  LBasicBlock testBooleanTrueCase = m_out.newBlock();
                  LBasicBlock convertBooleanTrueCase = m_out.newBlock();
                  LBasicBlock convertBooleanFalseCase = m_out.newBlock();
  
                  m_out.appendTo(nonDoubleCase, undefinedCase);
<span class="line-modified">!                 LValue valueIsUndefined = m_out.equal(value, m_out.constInt64(ValueUndefined));</span>
                  m_out.branch(valueIsUndefined, unsure(undefinedCase), unsure(testNullCase));
  
                  m_out.appendTo(undefinedCase, testNullCase);
                  ValueFromBlock convertedUndefined = m_out.anchor(m_out.constDouble(PNaN));
                  m_out.jump(continuation);
  
                  m_out.appendTo(testNullCase, nullCase);
<span class="line-modified">!                 LValue valueIsNull = m_out.equal(value, m_out.constInt64(ValueNull));</span>
                  m_out.branch(valueIsNull, unsure(nullCase), unsure(testBooleanTrueCase));
  
                  m_out.appendTo(nullCase, testBooleanTrueCase);
                  ValueFromBlock convertedNull = m_out.anchor(m_out.constDouble(0));
                  m_out.jump(continuation);
  
                  m_out.appendTo(testBooleanTrueCase, convertBooleanTrueCase);
<span class="line-modified">!                 LValue valueIsBooleanTrue = m_out.equal(value, m_out.constInt64(ValueTrue));</span>
                  m_out.branch(valueIsBooleanTrue, unsure(convertBooleanTrueCase), unsure(convertBooleanFalseCase));
  
                  m_out.appendTo(convertBooleanTrueCase, convertBooleanFalseCase);
                  ValueFromBlock convertedTrue = m_out.anchor(m_out.constDouble(1));
                  m_out.jump(continuation);
  
                  m_out.appendTo(convertBooleanFalseCase, continuation);
  
<span class="line-modified">!                 LValue valueIsNotBooleanFalse = m_out.notEqual(value, m_out.constInt64(ValueFalse));</span>
                  FTL_TYPE_CHECK(jsValueValue(value), m_node-&gt;child1(), ~SpecCellCheck, valueIsNotBooleanFalse);
                  ValueFromBlock convertedFalse = m_out.anchor(m_out.constDouble(0));
                  m_out.jump(continuation);
  
                  m_out.appendTo(continuation, lastNext);
<span class="line-new-header">--- 1779,36 ---</span>
                  LBasicBlock testBooleanTrueCase = m_out.newBlock();
                  LBasicBlock convertBooleanTrueCase = m_out.newBlock();
                  LBasicBlock convertBooleanFalseCase = m_out.newBlock();
  
                  m_out.appendTo(nonDoubleCase, undefinedCase);
<span class="line-modified">!                 LValue valueIsUndefined = m_out.equal(value, m_out.constInt64(JSValue::ValueUndefined));</span>
                  m_out.branch(valueIsUndefined, unsure(undefinedCase), unsure(testNullCase));
  
                  m_out.appendTo(undefinedCase, testNullCase);
                  ValueFromBlock convertedUndefined = m_out.anchor(m_out.constDouble(PNaN));
                  m_out.jump(continuation);
  
                  m_out.appendTo(testNullCase, nullCase);
<span class="line-modified">!                 LValue valueIsNull = m_out.equal(value, m_out.constInt64(JSValue::ValueNull));</span>
                  m_out.branch(valueIsNull, unsure(nullCase), unsure(testBooleanTrueCase));
  
                  m_out.appendTo(nullCase, testBooleanTrueCase);
                  ValueFromBlock convertedNull = m_out.anchor(m_out.constDouble(0));
                  m_out.jump(continuation);
  
                  m_out.appendTo(testBooleanTrueCase, convertBooleanTrueCase);
<span class="line-modified">!                 LValue valueIsBooleanTrue = m_out.equal(value, m_out.constInt64(JSValue::ValueTrue));</span>
                  m_out.branch(valueIsBooleanTrue, unsure(convertBooleanTrueCase), unsure(convertBooleanFalseCase));
  
                  m_out.appendTo(convertBooleanTrueCase, convertBooleanFalseCase);
                  ValueFromBlock convertedTrue = m_out.anchor(m_out.constDouble(1));
                  m_out.jump(continuation);
  
                  m_out.appendTo(convertBooleanFalseCase, continuation);
  
<span class="line-modified">!                 LValue valueIsNotBooleanFalse = m_out.notEqual(value, m_out.constInt64(JSValue::ValueFalse));</span>
                  FTL_TYPE_CHECK(jsValueValue(value), m_node-&gt;child1(), ~SpecCellCheck, valueIsNotBooleanFalse);
                  ValueFromBlock convertedFalse = m_out.anchor(m_out.constDouble(0));
                  m_out.jump(continuation);
  
                  m_out.appendTo(continuation, lastNext);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1889,11 ***</span>
                  isBoolean(value, provenType(m_node-&gt;child1())),
                  unsure(booleanCase), unsure(continuation));
  
              LBasicBlock lastNext = m_out.appendTo(booleanCase, continuation);
              ValueFromBlock booleanResult = m_out.anchor(m_out.bitOr(
<span class="line-modified">!                 m_out.zeroExt(unboxBoolean(value), Int64), m_tagTypeNumber));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, booleanResult, notBooleanResult));
              return;
<span class="line-new-header">--- 1954,11 ---</span>
                  isBoolean(value, provenType(m_node-&gt;child1())),
                  unsure(booleanCase), unsure(continuation));
  
              LBasicBlock lastNext = m_out.appendTo(booleanCase, continuation);
              ValueFromBlock booleanResult = m_out.anchor(m_out.bitOr(
<span class="line-modified">!                 m_out.zeroExt(unboxBoolean(value), Int64), m_numberTag));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, booleanResult, notBooleanResult));
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1907,11 ***</span>
  
      void compileExtractOSREntryLocal()
      {
          EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(
              m_ftlState.jitCode-&gt;ftlForOSREntry()-&gt;entryBuffer()-&gt;dataBuffer());
<span class="line-modified">!         setJSValue(m_out.load64(m_out.absolute(buffer + m_node-&gt;unlinkedLocal().toLocal())));</span>
      }
  
      void compileExtractCatchLocal()
      {
          EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(m_ftlState.jitCode-&gt;common.catchOSREntryBuffer-&gt;dataBuffer());
<span class="line-new-header">--- 1972,11 ---</span>
  
      void compileExtractOSREntryLocal()
      {
          EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(
              m_ftlState.jitCode-&gt;ftlForOSREntry()-&gt;entryBuffer()-&gt;dataBuffer());
<span class="line-modified">!         setJSValue(m_out.load64(m_out.absolute(buffer + m_node-&gt;unlinkedOperand().virtualRegister().toLocal())));</span>
      }
  
      void compileExtractCatchLocal()
      {
          EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(m_ftlState.jitCode-&gt;common.catchOSREntryBuffer-&gt;dataBuffer());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1926,11 ***</span>
      }
  
      void compileGetStack()
      {
          StackAccessData* data = m_node-&gt;stackAccessData();
<span class="line-modified">!         AbstractValue&amp; value = m_state.operand(data-&gt;local);</span>
  
          DFG_ASSERT(m_graph, m_node, isConcrete(data-&gt;format), data-&gt;format);
  
          switch (data-&gt;format) {
          case FlushedDouble:
<span class="line-new-header">--- 1991,11 ---</span>
      }
  
      void compileGetStack()
      {
          StackAccessData* data = m_node-&gt;stackAccessData();
<span class="line-modified">!         AbstractValue&amp; value = m_state.operand(data-&gt;operand);</span>
  
          DFG_ASSERT(m_graph, m_node, isConcrete(data-&gt;format), data-&gt;format);
  
          switch (data-&gt;format) {
          case FlushedDouble:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2017,22 ***</span>
  
          m_out.appendTo(slowCase, continuation);
  
          ValueFromBlock slowResult;
          if (m_node-&gt;op() == ToObject) {
              auto* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
<span class="line-modified">!             slowResult = m_out.anchor(vmCall(Int64, m_out.operation(operationToObject), m_callFrame, weakPointer(globalObject), value, m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;identifierNumber()])));</span>
          } else
<span class="line-modified">!             slowResult = m_out.anchor(vmCall(Int64, m_out.operation(operationCallObjectConstructor), m_callFrame, frozenPointer(m_node-&gt;cellOperand()), value));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setJSValue(m_out.phi(Int64, fastResult, slowResult));
      }
  
      void compileToThis()
      {
          LValue value = lowJSValue(m_node-&gt;child1());
  
          LBasicBlock isCellCase = m_out.newBlock();
          LBasicBlock slowCase = m_out.newBlock();
          LBasicBlock continuation = m_out.newBlock();
<span class="line-new-header">--- 2082,27 ---</span>
  
          m_out.appendTo(slowCase, continuation);
  
          ValueFromBlock slowResult;
          if (m_node-&gt;op() == ToObject) {
<span class="line-added">+             UniquedStringImpl* errorMessage = nullptr;</span>
<span class="line-added">+             if (m_node-&gt;identifierNumber() != UINT32_MAX)</span>
<span class="line-added">+                 errorMessage = m_graph.identifiers()[m_node-&gt;identifierNumber()];</span>
              auto* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
<span class="line-modified">!             slowResult = m_out.anchor(vmCall(Int64, operationToObject, weakPointer(globalObject), value, m_out.constIntPtr(errorMessage)));</span>
          } else
<span class="line-modified">!             slowResult = m_out.anchor(vmCall(Int64, operationCallObjectConstructor, frozenPointer(m_node-&gt;cellOperand()), value));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setJSValue(m_out.phi(Int64, fastResult, slowResult));
      }
  
      void compileToThis()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added">+ </span>
          LValue value = lowJSValue(m_node-&gt;child1());
  
          LBasicBlock isCellCase = m_out.newBlock();
          LBasicBlock slowCase = m_out.newBlock();
          LBasicBlock continuation = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2047,92 ***</span>
                  m_out.load8ZeroExt32(value, m_heaps.JSCell_typeInfoFlags),
                  m_out.constInt32(OverridesToThis)),
              usually(continuation), rarely(slowCase));
  
          m_out.appendTo(slowCase, continuation);
<span class="line-modified">!         J_JITOperation_EJ function;</span>
          if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
              function = operationToThisStrict;
          else
              function = operationToThis;
<span class="line-modified">!         ValueFromBlock slowResult = m_out.anchor(</span>
<span class="line-removed">-             vmCall(Int64, m_out.operation(function), m_callFrame, value));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setJSValue(m_out.phi(Int64, fastResult, slowResult));
      }
  
      void compileValueAdd()
      {
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
              LValue left = lowBigInt(m_node-&gt;child1());
              LValue right = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(pointerType(), m_out.operation(operationAddBigInt), m_callFrame, left, right);</span>
              setJSValue(result);
              return;
          }
  
          CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!         unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified">!         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
          auto repatchingFunction = operationValueAddOptimize;
          auto nonRepatchingFunction = operationValueAdd;
          compileBinaryMathIC&lt;JITAddGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
      }
  
      void compileValueSub()
      {
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
              LValue left = lowBigInt(m_node-&gt;child1());
              LValue right = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(pointerType(), m_out.operation(operationSubBigInt), m_callFrame, left, right);</span>
              setJSValue(result);
              return;
          }
  
          CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!         unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified">!         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
          auto repatchingFunction = operationValueSubOptimize;
          auto nonRepatchingFunction = operationValueSub;
          compileBinaryMathIC&lt;JITSubGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
      }
  
      void compileValueMul()
      {
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
              LValue left = lowBigInt(m_node-&gt;child1());
              LValue right = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(Int64, m_out.operation(operationMulBigInt), m_callFrame, left, right);</span>
              setJSValue(result);
              return;
          }
  
          CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!         unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified">!         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
          auto repatchingFunction = operationValueMulOptimize;
          auto nonRepatchingFunction = operationValueMul;
          compileBinaryMathIC&lt;JITMulGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
      }
  
      template &lt;typename Generator, typename Func1, typename Func2,
          typename = std::enable_if_t&lt;std::is_function&lt;typename std::remove_pointer&lt;Func1&gt;::type&gt;::value &amp;&amp; std::is_function&lt;typename std::remove_pointer&lt;Func2&gt;::type&gt;::value&gt;&gt;
<span class="line-modified">!     void compileUnaryMathIC(ArithProfile* arithProfile, Func1 repatchingFunction, Func2 nonRepatchingFunction)</span>
      {
          Node* node = m_node;
  
          LValue operand = lowJSValue(node-&gt;child1());
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(operand);
<span class="line-modified">!         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));</span>
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
          patchpoint-&gt;numGPScratchRegisters = 1;
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          State* state = &amp;m_ftlState;
          patchpoint-&gt;setGenerator(
<span class="line-new-header">--- 2117,97 ---</span>
                  m_out.load8ZeroExt32(value, m_heaps.JSCell_typeInfoFlags),
                  m_out.constInt32(OverridesToThis)),
              usually(continuation), rarely(slowCase));
  
          m_out.appendTo(slowCase, continuation);
<span class="line-modified">!         J_JITOperation_GJ function;</span>
          if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
              function = operationToThisStrict;
          else
              function = operationToThis;
<span class="line-modified">!         ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, function, weakPointer(globalObject), value));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setJSValue(m_out.phi(Int64, fastResult, slowResult));
      }
  
      void compileValueAdd()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added">+ </span>
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
              LValue left = lowBigInt(m_node-&gt;child1());
              LValue right = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(pointerType(), operationAddBigInt, weakPointer(globalObject), left, right);</span>
              setJSValue(result);
              return;
          }
  
          CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!         BytecodeIndex bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified">!         BinaryArithProfile* arithProfile = baselineCodeBlock-&gt;binaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
          auto repatchingFunction = operationValueAddOptimize;
          auto nonRepatchingFunction = operationValueAdd;
          compileBinaryMathIC&lt;JITAddGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
      }
  
      void compileValueSub()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added">+ </span>
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
              LValue left = lowBigInt(m_node-&gt;child1());
              LValue right = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(pointerType(), operationSubBigInt, weakPointer(globalObject), left, right);</span>
              setJSValue(result);
              return;
          }
  
          CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!         BytecodeIndex bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified">!         BinaryArithProfile* arithProfile = baselineCodeBlock-&gt;binaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
          auto repatchingFunction = operationValueSubOptimize;
          auto nonRepatchingFunction = operationValueSub;
          compileBinaryMathIC&lt;JITSubGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
      }
  
      void compileValueMul()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added">+ </span>
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
              LValue left = lowBigInt(m_node-&gt;child1());
              LValue right = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(Int64, operationMulBigInt, weakPointer(globalObject), left, right);</span>
              setJSValue(result);
              return;
          }
  
          CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!         BytecodeIndex bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified">!         BinaryArithProfile* arithProfile = baselineCodeBlock-&gt;binaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
          auto repatchingFunction = operationValueMulOptimize;
          auto nonRepatchingFunction = operationValueMul;
          compileBinaryMathIC&lt;JITMulGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
      }
  
      template &lt;typename Generator, typename Func1, typename Func2,
          typename = std::enable_if_t&lt;std::is_function&lt;typename std::remove_pointer&lt;Func1&gt;::type&gt;::value &amp;&amp; std::is_function&lt;typename std::remove_pointer&lt;Func2&gt;::type&gt;::value&gt;&gt;
<span class="line-modified">!     void compileUnaryMathIC(UnaryArithProfile* arithProfile, Func1 repatchingFunction, Func2 nonRepatchingFunction)</span>
      {
          Node* node = m_node;
  
          LValue operand = lowJSValue(node-&gt;child1());
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(operand);
<span class="line-modified">!         patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
          patchpoint-&gt;numGPScratchRegisters = 1;
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          State* state = &amp;m_ftlState;
          patchpoint-&gt;setGenerator(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2164,15 ***</span>
                          auto slowPathStart = jit.label();
  #endif
  
                          if (mathICGenerationState-&gt;shouldSlowPathRepatch) {
                              SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
<span class="line-modified">!                                 repatchingFunction, params[0].gpr(), params[1].gpr(), CCallHelpers::TrustedImmPtr(mathIC));</span>
                              mathICGenerationState-&gt;slowPathCall = call.call();
                          } else {
                              SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
<span class="line-modified">!                                 exceptions.get(), nonRepatchingFunction, params[0].gpr(), params[1].gpr());</span>
                              mathICGenerationState-&gt;slowPathCall = call.call();
                          }
                          jit.jump().linkTo(done, &amp;jit);
  
                          jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
<span class="line-new-header">--- 2239,15 ---</span>
                          auto slowPathStart = jit.label();
  #endif
  
                          if (mathICGenerationState-&gt;shouldSlowPathRepatch) {
                              SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
<span class="line-modified">!                                 repatchingFunction, params[0].gpr(), jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic), params[1].gpr(), CCallHelpers::TrustedImmPtr(mathIC));</span>
                              mathICGenerationState-&gt;slowPathCall = call.call();
                          } else {
                              SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
<span class="line-modified">!                                 exceptions.get(), nonRepatchingFunction, params[0].gpr(), jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic), params[1].gpr());</span>
                              mathICGenerationState-&gt;slowPathCall = call.call();
                          }
                          jit.jump().linkTo(done, &amp;jit);
  
                          jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2188,11 ***</span>
  #endif
                      });
                  } else {
                      callOperation(
                          *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
<span class="line-modified">!                         nonRepatchingFunction, params[0].gpr(), params[1].gpr());</span>
                  }
  
  #if ENABLE(MATH_IC_STATS)
                  auto inlineEnd = jit.label();
                  jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
<span class="line-new-header">--- 2263,11 ---</span>
  #endif
                      });
                  } else {
                      callOperation(
                          *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
<span class="line-modified">!                         nonRepatchingFunction, params[0].gpr(), jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic), params[1].gpr());</span>
                  }
  
  #if ENABLE(MATH_IC_STATS)
                  auto inlineEnd = jit.label();
                  jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2205,11 ***</span>
          setJSValue(patchpoint);
      }
  
      template &lt;typename Generator, typename Func1, typename Func2,
          typename = std::enable_if_t&lt;std::is_function&lt;typename std::remove_pointer&lt;Func1&gt;::type&gt;::value &amp;&amp; std::is_function&lt;typename std::remove_pointer&lt;Func2&gt;::type&gt;::value&gt;&gt;
<span class="line-modified">!     void compileBinaryMathIC(ArithProfile* arithProfile, Func1 repatchingFunction, Func2 nonRepatchingFunction)</span>
      {
          Node* node = m_node;
  
          LValue left = lowJSValue(node-&gt;child1());
          LValue right = lowJSValue(node-&gt;child2());
<span class="line-new-header">--- 2280,11 ---</span>
          setJSValue(patchpoint);
      }
  
      template &lt;typename Generator, typename Func1, typename Func2,
          typename = std::enable_if_t&lt;std::is_function&lt;typename std::remove_pointer&lt;Func1&gt;::type&gt;::value &amp;&amp; std::is_function&lt;typename std::remove_pointer&lt;Func2&gt;::type&gt;::value&gt;&gt;
<span class="line-modified">!     void compileBinaryMathIC(BinaryArithProfile* arithProfile, Func1 repatchingFunction, Func2 nonRepatchingFunction)</span>
      {
          Node* node = m_node;
  
          LValue left = lowJSValue(node-&gt;child1());
          LValue right = lowJSValue(node-&gt;child2());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2218,12 ***</span>
          SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(left);
          patchpoint-&gt;appendSomeRegister(right);
<span class="line-modified">!         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));</span>
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
          patchpoint-&gt;numGPScratchRegisters = 1;
          patchpoint-&gt;numFPScratchRegisters = 2;
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<span class="line-new-header">--- 2293,12 ---</span>
          SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(left);
          patchpoint-&gt;appendSomeRegister(right);
<span class="line-modified">!         patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
          patchpoint-&gt;numGPScratchRegisters = 1;
          patchpoint-&gt;numFPScratchRegisters = 2;
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2260,15 ***</span>
                          auto slowPathStart = jit.label();
  #endif
  
                          if (mathICGenerationState-&gt;shouldSlowPathRepatch) {
                              SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
<span class="line-modified">!                                 repatchingFunction, params[0].gpr(), params[1].gpr(), params[2].gpr(), CCallHelpers::TrustedImmPtr(mathIC));</span>
                              mathICGenerationState-&gt;slowPathCall = call.call();
                          } else {
                              SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
<span class="line-modified">!                                 exceptions.get(), nonRepatchingFunction, params[0].gpr(), params[1].gpr(), params[2].gpr());</span>
                              mathICGenerationState-&gt;slowPathCall = call.call();
                          }
                          jit.jump().linkTo(done, &amp;jit);
  
                          jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
<span class="line-new-header">--- 2335,15 ---</span>
                          auto slowPathStart = jit.label();
  #endif
  
                          if (mathICGenerationState-&gt;shouldSlowPathRepatch) {
                              SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
<span class="line-modified">!                                 repatchingFunction, params[0].gpr(), jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic), params[1].gpr(), params[2].gpr(), CCallHelpers::TrustedImmPtr(mathIC));</span>
                              mathICGenerationState-&gt;slowPathCall = call.call();
                          } else {
                              SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
<span class="line-modified">!                                 exceptions.get(), nonRepatchingFunction, params[0].gpr(), jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic), params[1].gpr(), params[2].gpr());</span>
                              mathICGenerationState-&gt;slowPathCall = call.call();
                          }
                          jit.jump().linkTo(done, &amp;jit);
  
                          jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2284,11 ***</span>
  #endif
                      });
                  } else {
                      callOperation(
                          *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
<span class="line-modified">!                         nonRepatchingFunction, params[0].gpr(), params[1].gpr(), params[2].gpr());</span>
                  }
  
  #if ENABLE(MATH_IC_STATS)
                  auto inlineEnd = jit.label();
                  jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
<span class="line-new-header">--- 2359,11 ---</span>
  #endif
                      });
                  } else {
                      callOperation(
                          *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
<span class="line-modified">!                         nonRepatchingFunction, params[0].gpr(), jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic), params[1].gpr(), params[2].gpr());</span>
                  }
  
  #if ENABLE(MATH_IC_STATS)
                  auto inlineEnd = jit.label();
                  jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2301,20 ***</span>
          setJSValue(patchpoint);
      }
  
      void compileStrCat()
      {
          LValue result;
          if (m_node-&gt;child3()) {
              result = vmCall(
<span class="line-modified">!                 Int64, m_out.operation(operationStrCat3), m_callFrame,</span>
                  lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation),
                  lowJSValue(m_node-&gt;child2(), ManualOperandSpeculation),
                  lowJSValue(m_node-&gt;child3(), ManualOperandSpeculation));
          } else {
              result = vmCall(
<span class="line-modified">!                 Int64, m_out.operation(operationStrCat2), m_callFrame,</span>
                  lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation),
                  lowJSValue(m_node-&gt;child2(), ManualOperandSpeculation));
          }
          setJSValue(result);
      }
<span class="line-new-header">--- 2376,22 ---</span>
          setJSValue(patchpoint);
      }
  
      void compileStrCat()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added">+ </span>
          LValue result;
          if (m_node-&gt;child3()) {
              result = vmCall(
<span class="line-modified">!                 Int64, operationStrCat3, weakPointer(globalObject),</span>
                  lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation),
                  lowJSValue(m_node-&gt;child2(), ManualOperandSpeculation),
                  lowJSValue(m_node-&gt;child3(), ManualOperandSpeculation));
          } else {
              result = vmCall(
<span class="line-modified">!                 Int64, operationStrCat2, weakPointer(globalObject),</span>
                  lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation),
                  lowJSValue(m_node-&gt;child2(), ManualOperandSpeculation));
          }
          setJSValue(result);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2371,12 ***</span>
                  DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
                  break;
              }
  
              CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!             unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified">!             ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
              auto repatchingFunction = operationValueSubOptimize;
              auto nonRepatchingFunction = operationValueSub;
              compileBinaryMathIC&lt;JITSubGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
              break;
          }
<span class="line-new-header">--- 2448,12 ---</span>
                  DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
                  break;
              }
  
              CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!             BytecodeIndex bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified">!             BinaryArithProfile* arithProfile = baselineCodeBlock-&gt;binaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
              auto repatchingFunction = operationValueSubOptimize;
              auto nonRepatchingFunction = operationValueSub;
              compileBinaryMathIC&lt;JITSubGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
              break;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2387,18 ***</span>
          }
      }
  
      void compileArithClz32()
      {
          if (m_node-&gt;child1().useKind() == Int32Use || m_node-&gt;child1().useKind() == KnownInt32Use) {
              LValue operand = lowInt32(m_node-&gt;child1());
              setInt32(m_out.ctlz32(operand));
              return;
          }
          DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
          LValue argument = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         LValue result = vmCall(Int32, m_out.operation(operationArithClz32), m_callFrame, argument);</span>
          setInt32(result);
      }
  
      void compileArithMul()
      {
<span class="line-new-header">--- 2464,19 ---</span>
          }
      }
  
      void compileArithClz32()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;child1().useKind() == Int32Use || m_node-&gt;child1().useKind() == KnownInt32Use) {
              LValue operand = lowInt32(m_node-&gt;child1());
              setInt32(m_out.ctlz32(operand));
              return;
          }
          DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
          LValue argument = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         LValue result = vmCall(Int32, operationArithClz32, weakPointer(globalObject), argument);</span>
          setInt32(result);
      }
  
      void compileArithMul()
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2473,15 ***</span>
          }
      }
  
      void compileValueDiv()
      {
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
              LValue left = lowBigInt(m_node-&gt;child1());
              LValue right = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(pointerType(), m_out.operation(operationDivBigInt), m_callFrame, left, right);</span>
              setJSValue(result);
              return;
          }
  
          emitBinarySnippet&lt;JITDivGenerator, NeedScratchFPR&gt;(operationValueDiv);
<span class="line-new-header">--- 2551,16 ---</span>
          }
      }
  
      void compileValueDiv()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
              LValue left = lowBigInt(m_node-&gt;child1());
              LValue right = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(pointerType(), operationDivBigInt, weakPointer(globalObject), left, right);</span>
              setJSValue(result);
              return;
          }
  
          emitBinarySnippet&lt;JITDivGenerator, NeedScratchFPR&gt;(operationValueDiv);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2551,23 ***</span>
          }
      }
  
      void compileValueMod()
      {
          if (m_node-&gt;binaryUseKind() == BigIntUse) {
              LValue left = lowBigInt(m_node-&gt;child1());
              LValue right = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(pointerType(), m_out.operation(operationModBigInt), m_callFrame, left, right);</span>
              setJSValue(result);
              return;
          }
  
          DFG_ASSERT(m_graph, m_node, m_node-&gt;binaryUseKind() == UntypedUse, m_node-&gt;binaryUseKind());
          LValue left = lowJSValue(m_node-&gt;child1());
          LValue right = lowJSValue(m_node-&gt;child2());
<span class="line-modified">!         LValue result = vmCall(Int64, m_out.operation(operationValueMod), m_callFrame, left, right);</span>
          setJSValue(result);
      }
  
      void compileArithMod()
      {
<span class="line-new-header">--- 2630,24 ---</span>
          }
      }
  
      void compileValueMod()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;binaryUseKind() == BigIntUse) {
              LValue left = lowBigInt(m_node-&gt;child1());
              LValue right = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(pointerType(), operationModBigInt, weakPointer(globalObject), left, right);</span>
              setJSValue(result);
              return;
          }
  
          DFG_ASSERT(m_graph, m_node, m_node-&gt;binaryUseKind() == UntypedUse, m_node-&gt;binaryUseKind());
          LValue left = lowJSValue(m_node-&gt;child1());
          LValue right = lowJSValue(m_node-&gt;child2());
<span class="line-modified">!         LValue result = vmCall(Int64, operationValueMod, weakPointer(globalObject), left, right);</span>
          setJSValue(result);
      }
  
      void compileArithMod()
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2682,10 ***</span>
<span class="line-new-header">--- 2762,11 ---</span>
          }
      }
  
      void compileArithAbs()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          switch (m_node-&gt;child1().useKind()) {
          case Int32Use: {
              LValue value = lowInt32(m_node-&gt;child1());
  
              LValue mask = m_out.aShr(value, m_out.constInt32(31));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2704,42 ***</span>
          }
  
          default: {
              DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
              LValue argument = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!             LValue result = vmCall(Double, m_out.operation(operationArithAbs), m_callFrame, argument);</span>
              setDouble(result);
              break;
          }
          }
      }
  
      void compileArithUnary()
      {
          if (m_node-&gt;child1().useKind() == DoubleRepUse) {
              setDouble(m_out.doubleUnary(m_node-&gt;arithUnaryType(), lowDouble(m_node-&gt;child1())));
              return;
          }
          LValue argument = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         LValue result = vmCall(Double, m_out.operation(DFG::arithUnaryOperation(m_node-&gt;arithUnaryType())), m_callFrame, argument);</span>
          setDouble(result);
      }
  
      void compileValuePow()
      {
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
              LValue base = lowBigInt(m_node-&gt;child1());
              LValue exponent = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(pointerType(), m_out.operation(operationPowBigInt), m_callFrame, base, exponent);</span>
              setJSValue(result);
              return;
          }
  
          LValue base = lowJSValue(m_node-&gt;child1());
          LValue exponent = lowJSValue(m_node-&gt;child2());
<span class="line-modified">!         LValue result = vmCall(Int64, m_out.operation(operationValuePow), m_callFrame, base, exponent);</span>
          setJSValue(result);
      }
  
      void compileArithPow()
      {
<span class="line-new-header">--- 2785,44 ---</span>
          }
  
          default: {
              DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
              LValue argument = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!             LValue result = vmCall(Double, operationArithAbs, weakPointer(globalObject), argument);</span>
              setDouble(result);
              break;
          }
          }
      }
  
      void compileArithUnary()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;child1().useKind() == DoubleRepUse) {
              setDouble(m_out.doubleUnary(m_node-&gt;arithUnaryType(), lowDouble(m_node-&gt;child1())));
              return;
          }
          LValue argument = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         LValue result = vmCall(Double, DFG::arithUnaryOperation(m_node-&gt;arithUnaryType()), weakPointer(globalObject), argument);</span>
          setDouble(result);
      }
  
      void compileValuePow()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
              LValue base = lowBigInt(m_node-&gt;child1());
              LValue exponent = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(pointerType(), operationPowBigInt, weakPointer(globalObject), base, exponent);</span>
              setJSValue(result);
              return;
          }
  
          LValue base = lowJSValue(m_node-&gt;child1());
          LValue exponent = lowJSValue(m_node-&gt;child2());
<span class="line-modified">!         LValue result = vmCall(Int64, operationValuePow, weakPointer(globalObject), base, exponent);</span>
          setJSValue(result);
      }
  
      void compileArithPow()
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2912,11 ***</span>
  
          LValue double53Integer = m_out.intToDouble(random53);
  
          // Convert `(53bit double integer value) / (1 &lt;&lt; 53)` to `(53bit double integer value) * (1.0 / (1 &lt;&lt; 53))`.
          // In latter case, `1.0 / (1 &lt;&lt; 53)` will become a double value represented as (mantissa = 0 &amp; exp = 970, it means 1e-(2**54)).
<span class="line-modified">!         static const double scale = 1.0 / (1ULL &lt;&lt; 53);</span>
  
          // Multiplying 1e-(2**54) with the double integer does not change anything of the mantissa part of the double integer.
          // It just reduces the exp part of the given 53bit double integer.
          // (Except for 0.0. This is specially handled and in this case, exp just becomes 0.)
          // Now we get 53bit precision random double value in [0, 1).
<span class="line-new-header">--- 2995,11 ---</span>
  
          LValue double53Integer = m_out.intToDouble(random53);
  
          // Convert `(53bit double integer value) / (1 &lt;&lt; 53)` to `(53bit double integer value) * (1.0 / (1 &lt;&lt; 53))`.
          // In latter case, `1.0 / (1 &lt;&lt; 53)` will become a double value represented as (mantissa = 0 &amp; exp = 970, it means 1e-(2**54)).
<span class="line-modified">!         static constexpr double scale = 1.0 / (1ULL &lt;&lt; 53);</span>
  
          // Multiplying 1e-(2**54) with the double integer does not change anything of the mantissa part of the double integer.
          // It just reduces the exp part of the given 53bit double integer.
          // (Except for 0.0. This is specially handled and in this case, exp just becomes 0.)
          // Now we get 53bit precision random double value in [0, 1).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2925,28 ***</span>
          setDouble(result);
      }
  
      void compileArithRound()
      {
          if (m_node-&gt;child1().useKind() == DoubleRepUse) {
              LValue result = nullptr;
              if (producesInteger(m_node-&gt;arithRoundingMode()) &amp;&amp; !shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())) {
                  LValue value = lowDouble(m_node-&gt;child1());
                  result = m_out.doubleFloor(m_out.doubleAdd(value, m_out.constDouble(0.5)));
              } else {
<span class="line-modified">!                 LBasicBlock realPartIsMoreThanHalf = m_out.newBlock();</span>
                  LBasicBlock continuation = m_out.newBlock();
  
                  LValue value = lowDouble(m_node-&gt;child1());
                  LValue integerValue = m_out.doubleCeil(value);
                  ValueFromBlock integerValueResult = m_out.anchor(integerValue);
  
<span class="line-modified">!                 LValue realPart = m_out.doubleSub(integerValue, value);</span>
  
<span class="line-modified">!                 m_out.branch(m_out.doubleGreaterThanOrUnordered(realPart, m_out.constDouble(0.5)), unsure(realPartIsMoreThanHalf), unsure(continuation));</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 LBasicBlock lastNext = m_out.appendTo(realPartIsMoreThanHalf, continuation);</span>
                  LValue integerValueRoundedDown = m_out.doubleSub(integerValue, m_out.constDouble(1));
                  ValueFromBlock integerValueRoundedDownResult = m_out.anchor(integerValueRoundedDown);
                  m_out.jump(continuation);
                  m_out.appendTo(continuation, lastNext);
  
<span class="line-new-header">--- 3008,28 ---</span>
          setDouble(result);
      }
  
      void compileArithRound()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;child1().useKind() == DoubleRepUse) {
              LValue result = nullptr;
              if (producesInteger(m_node-&gt;arithRoundingMode()) &amp;&amp; !shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())) {
                  LValue value = lowDouble(m_node-&gt;child1());
                  result = m_out.doubleFloor(m_out.doubleAdd(value, m_out.constDouble(0.5)));
              } else {
<span class="line-modified">!                 LBasicBlock shouldRoundDown = m_out.newBlock();</span>
                  LBasicBlock continuation = m_out.newBlock();
  
                  LValue value = lowDouble(m_node-&gt;child1());
                  LValue integerValue = m_out.doubleCeil(value);
                  ValueFromBlock integerValueResult = m_out.anchor(integerValue);
  
<span class="line-modified">!                 LValue ceilMinusHalf = m_out.doubleSub(integerValue, m_out.constDouble(0.5));</span>
<span class="line-added">+                 m_out.branch(m_out.doubleGreaterThanOrUnordered(ceilMinusHalf, value), unsure(shouldRoundDown), unsure(continuation));</span>
  
<span class="line-modified">!                 LBasicBlock lastNext = m_out.appendTo(shouldRoundDown, continuation);</span>
                  LValue integerValueRoundedDown = m_out.doubleSub(integerValue, m_out.constDouble(1));
                  ValueFromBlock integerValueRoundedDownResult = m_out.anchor(integerValueRoundedDown);
                  m_out.jump(continuation);
                  m_out.appendTo(continuation, lastNext);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2961,15 ***</span>
              return;
          }
  
          DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
          LValue argument = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         setJSValue(vmCall(Int64, m_out.operation(operationArithRound), m_callFrame, argument));</span>
      }
  
      void compileArithFloor()
      {
          if (m_node-&gt;child1().useKind() == DoubleRepUse) {
              LValue value = lowDouble(m_node-&gt;child1());
              LValue integerValue = m_out.doubleFloor(value);
              if (producesInteger(m_node-&gt;arithRoundingMode()))
                  setInt32(convertDoubleToInt32(integerValue, shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())));
<span class="line-new-header">--- 3044,16 ---</span>
              return;
          }
  
          DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
          LValue argument = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         setJSValue(vmCall(Int64, operationArithRound, weakPointer(globalObject), argument));</span>
      }
  
      void compileArithFloor()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;child1().useKind() == DoubleRepUse) {
              LValue value = lowDouble(m_node-&gt;child1());
              LValue integerValue = m_out.doubleFloor(value);
              if (producesInteger(m_node-&gt;arithRoundingMode()))
                  setInt32(convertDoubleToInt32(integerValue, shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2977,15 ***</span>
                  setDouble(integerValue);
              return;
          }
          DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
          LValue argument = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         setJSValue(vmCall(Int64, m_out.operation(operationArithFloor), m_callFrame, argument));</span>
      }
  
      void compileArithCeil()
      {
          if (m_node-&gt;child1().useKind() == DoubleRepUse) {
              LValue value = lowDouble(m_node-&gt;child1());
              LValue integerValue = m_out.doubleCeil(value);
              if (producesInteger(m_node-&gt;arithRoundingMode()))
                  setInt32(convertDoubleToInt32(integerValue, shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())));
<span class="line-new-header">--- 3061,16 ---</span>
                  setDouble(integerValue);
              return;
          }
          DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
          LValue argument = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         setJSValue(vmCall(Int64, operationArithFloor, weakPointer(globalObject), argument));</span>
      }
  
      void compileArithCeil()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;child1().useKind() == DoubleRepUse) {
              LValue value = lowDouble(m_node-&gt;child1());
              LValue integerValue = m_out.doubleCeil(value);
              if (producesInteger(m_node-&gt;arithRoundingMode()))
                  setInt32(convertDoubleToInt32(integerValue, shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2993,15 ***</span>
                  setDouble(integerValue);
              return;
          }
          DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
          LValue argument = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         setJSValue(vmCall(Int64, m_out.operation(operationArithCeil), m_callFrame, argument));</span>
      }
  
      void compileArithTrunc()
      {
          if (m_node-&gt;child1().useKind() == DoubleRepUse) {
              LValue value = lowDouble(m_node-&gt;child1());
              LValue result = m_out.doubleTrunc(value);
              if (producesInteger(m_node-&gt;arithRoundingMode()))
                  setInt32(convertDoubleToInt32(result, shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())));
<span class="line-new-header">--- 3078,16 ---</span>
                  setDouble(integerValue);
              return;
          }
          DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
          LValue argument = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         setJSValue(vmCall(Int64, operationArithCeil, weakPointer(globalObject), argument));</span>
      }
  
      void compileArithTrunc()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;child1().useKind() == DoubleRepUse) {
              LValue value = lowDouble(m_node-&gt;child1());
              LValue result = m_out.doubleTrunc(value);
              if (producesInteger(m_node-&gt;arithRoundingMode()))
                  setInt32(convertDoubleToInt32(result, shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3009,41 ***</span>
                  setDouble(result);
              return;
          }
          DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
          LValue argument = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         setJSValue(vmCall(Int64, m_out.operation(operationArithTrunc), m_callFrame, argument));</span>
      }
  
      void compileArithSqrt()
      {
          if (m_node-&gt;child1().useKind() == DoubleRepUse) {
              setDouble(m_out.doubleSqrt(lowDouble(m_node-&gt;child1())));
              return;
          }
          LValue argument = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         LValue result = vmCall(Double, m_out.operation(operationArithSqrt), m_callFrame, argument);</span>
          setDouble(result);
      }
  
      void compileArithFRound()
      {
          if (m_node-&gt;child1().useKind() == DoubleRepUse) {
              setDouble(m_out.fround(lowDouble(m_node-&gt;child1())));
              return;
          }
          LValue argument = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         LValue result = vmCall(Double, m_out.operation(operationArithFRound), m_callFrame, argument);</span>
          setDouble(result);
      }
  
      void compileValueNegate()
      {
          DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse);
          CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!         unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified">!         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
          auto repatchingFunction = operationArithNegateOptimize;
          auto nonRepatchingFunction = operationArithNegate;
          compileUnaryMathIC&lt;JITNegGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
      }
  
<span class="line-new-header">--- 3095,52 ---</span>
                  setDouble(result);
              return;
          }
          DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
          LValue argument = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         setJSValue(vmCall(Int64, operationArithTrunc, weakPointer(globalObject), argument));</span>
      }
  
      void compileArithSqrt()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;child1().useKind() == DoubleRepUse) {
              setDouble(m_out.doubleSqrt(lowDouble(m_node-&gt;child1())));
              return;
          }
          LValue argument = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         LValue result = vmCall(Double, operationArithSqrt, weakPointer(globalObject), argument);</span>
          setDouble(result);
      }
  
      void compileArithFRound()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;child1().useKind() == DoubleRepUse) {
              setDouble(m_out.fround(lowDouble(m_node-&gt;child1())));
              return;
          }
          LValue argument = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         LValue result = vmCall(Double, operationArithFRound, weakPointer(globalObject), argument);</span>
          setDouble(result);
      }
  
<span class="line-added">+     void compileIncOrDec()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse);</span>
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added">+         LValue operand = lowJSValue(m_node-&gt;child1());</span>
<span class="line-added">+         LValue result = vmCall(Int64, m_node-&gt;op() == Inc ? operationInc : operationDec, weakPointer(globalObject), operand);</span>
<span class="line-added">+         setJSValue(result);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void compileValueNegate()
      {
          DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse);
          CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<span class="line-modified">!         BytecodeIndex bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified">!         UnaryArithProfile* arithProfile = baselineCodeBlock-&gt;unaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
          auto repatchingFunction = operationArithNegateOptimize;
          auto nonRepatchingFunction = operationArithNegate;
          compileUnaryMathIC&lt;JITNegGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3100,34 ***</span>
          }
      }
  
      void compileValueBitNot()
      {
          if (m_node-&gt;child1().useKind() == BigIntUse) {
              LValue operand = lowBigInt(m_node-&gt;child1());
<span class="line-modified">!             LValue result = vmCall(pointerType(), m_out.operation(operationBitNotBigInt), m_callFrame, operand);</span>
              setJSValue(result);
              return;
          }
  
          LValue operand = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         LValue result = vmCall(Int64, m_out.operation(operationValueBitNot), m_callFrame, operand);</span>
          setJSValue(result);
      }
  
      void compileArithBitNot()
      {
          setInt32(m_out.bitNot(lowInt32(m_node-&gt;child1())));
      }
  
      void compileValueBitAnd()
      {
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
              LValue left = lowBigInt(m_node-&gt;child1());
              LValue right = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(pointerType(), m_out.operation(operationBitAndBigInt), m_callFrame, left, right);</span>
              setJSValue(result);
              return;
          }
  
          emitBinaryBitOpSnippet&lt;JITBitAndGenerator&gt;(operationValueBitAnd);
<span class="line-new-header">--- 3197,36 ---</span>
          }
      }
  
      void compileValueBitNot()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;child1().useKind() == BigIntUse) {
              LValue operand = lowBigInt(m_node-&gt;child1());
<span class="line-modified">!             LValue result = vmCall(pointerType(), operationBitNotBigInt, weakPointer(globalObject), operand);</span>
              setJSValue(result);
              return;
          }
  
          LValue operand = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         LValue result = vmCall(Int64, operationValueBitNot, weakPointer(globalObject), operand);</span>
          setJSValue(result);
      }
  
      void compileArithBitNot()
      {
          setInt32(m_out.bitNot(lowInt32(m_node-&gt;child1())));
      }
  
      void compileValueBitAnd()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
              LValue left = lowBigInt(m_node-&gt;child1());
              LValue right = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(pointerType(), operationBitAndBigInt, weakPointer(globalObject), left, right);</span>
              setJSValue(result);
              return;
          }
  
          emitBinaryBitOpSnippet&lt;JITBitAndGenerator&gt;(operationValueBitAnd);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3138,15 ***</span>
          setInt32(m_out.bitAnd(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
      }
  
      void compileValueBitOr()
      {
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
              LValue left = lowBigInt(m_node-&gt;child1());
              LValue right = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(pointerType(), m_out.operation(operationBitOrBigInt), m_callFrame, left, right);</span>
              setJSValue(result);
              return;
          }
  
          emitBinaryBitOpSnippet&lt;JITBitOrGenerator&gt;(operationValueBitOr);
<span class="line-new-header">--- 3237,16 ---</span>
          setInt32(m_out.bitAnd(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
      }
  
      void compileValueBitOr()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
              LValue left = lowBigInt(m_node-&gt;child1());
              LValue right = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(pointerType(), operationBitOrBigInt, weakPointer(globalObject), left, right);</span>
              setJSValue(result);
              return;
          }
  
          emitBinaryBitOpSnippet&lt;JITBitOrGenerator&gt;(operationValueBitOr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3157,15 ***</span>
          setInt32(m_out.bitOr(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
      }
  
      void compileValueBitXor()
      {
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
              LValue left = lowBigInt(m_node-&gt;child1());
              LValue right = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(pointerType(), m_out.operation(operationBitXorBigInt), m_callFrame, left, right);</span>
              setJSValue(result);
              return;
          }
  
          emitBinaryBitOpSnippet&lt;JITBitXorGenerator&gt;(operationValueBitXor);
<span class="line-new-header">--- 3257,16 ---</span>
          setInt32(m_out.bitOr(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
      }
  
      void compileValueBitXor()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
              LValue left = lowBigInt(m_node-&gt;child1());
              LValue right = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(pointerType(), operationBitXorBigInt, weakPointer(globalObject), left, right);</span>
              setJSValue(result);
              return;
          }
  
          emitBinaryBitOpSnippet&lt;JITBitXorGenerator&gt;(operationValueBitXor);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3174,16 ***</span>
      void compileArithBitXor()
      {
          setInt32(m_out.bitXor(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
      }
  
<span class="line-modified">!     void compileBitRShift()</span>
      {
<span class="line-modified">!         if (m_node-&gt;isBinaryUseKind(UntypedUse)) {</span>
<span class="line-modified">!             emitRightShiftSnippet(JITRightShiftGenerator::SignedShift);</span>
              return;
          }
          setInt32(m_out.aShr(
              lowInt32(m_node-&gt;child1()),
              m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
      }
  
<span class="line-new-header">--- 3275,27 ---</span>
      void compileArithBitXor()
      {
          setInt32(m_out.bitXor(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
      }
  
<span class="line-modified">!     void compileValueBitRShift()</span>
      {
<span class="line-modified">!         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-modified">!         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {</span>
<span class="line-added">+             LValue left = lowBigInt(m_node-&gt;child1());</span>
<span class="line-added">+             LValue right = lowBigInt(m_node-&gt;child2());</span>
<span class="line-added">+ </span>
<span class="line-added">+             LValue result = vmCall(pointerType(), operationBitRShiftBigInt, weakPointer(globalObject), left, right);</span>
<span class="line-added">+             setJSValue(result);</span>
              return;
          }
<span class="line-added">+ </span>
<span class="line-added">+         emitRightShiftSnippet(JITRightShiftGenerator::SignedShift);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void compileArithBitRShift()</span>
<span class="line-added">+     {</span>
          setInt32(m_out.aShr(
              lowInt32(m_node-&gt;child1()),
              m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3194,15 ***</span>
              m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
      }
  
      void compileValueBitLShift()
      {
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
              LValue left = lowBigInt(m_node-&gt;child1());
              LValue right = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(pointerType(), m_out.operation(operationBitLShiftBigInt), m_callFrame, left, right);</span>
              setJSValue(result);
              return;
          }
  
          ASSERT(m_node-&gt;isBinaryUseKind(UntypedUse));
<span class="line-new-header">--- 3306,16 ---</span>
              m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
      }
  
      void compileValueBitLShift()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
              LValue left = lowBigInt(m_node-&gt;child1());
              LValue right = lowBigInt(m_node-&gt;child2());
  
<span class="line-modified">!             LValue result = vmCall(pointerType(), operationBitLShiftBigInt, weakPointer(globalObject), left, right);</span>
              setJSValue(result);
              return;
          }
  
          ASSERT(m_node-&gt;isBinaryUseKind(UntypedUse));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3296,15 ***</span>
          else
              exitKind = BadCache;
  
          LValue cell = lowCell(m_node-&gt;child1());
          bool maySeeEmptyValue = m_interpreter.forNode(m_node-&gt;child1()).m_type &amp; SpecEmpty;
<span class="line-modified">!         LBasicBlock notEmpty;</span>
<span class="line-modified">!         LBasicBlock continuation;</span>
<span class="line-removed">-         LBasicBlock lastNext;</span>
          if (maySeeEmptyValue) {
<span class="line-modified">!             notEmpty = m_out.newBlock();</span>
              continuation = m_out.newBlock();
              m_out.branch(m_out.isZero64(cell), unsure(continuation), unsure(notEmpty));
              lastNext = m_out.appendTo(notEmpty, continuation);
          }
  
<span class="line-new-header">--- 3409,14 ---</span>
          else
              exitKind = BadCache;
  
          LValue cell = lowCell(m_node-&gt;child1());
          bool maySeeEmptyValue = m_interpreter.forNode(m_node-&gt;child1()).m_type &amp; SpecEmpty;
<span class="line-modified">!         LBasicBlock continuation = nullptr;</span>
<span class="line-modified">!         LBasicBlock lastNext = nullptr;</span>
          if (maySeeEmptyValue) {
<span class="line-modified">!             LBasicBlock notEmpty = m_out.newBlock();</span>
              continuation = m_out.newBlock();
              m_out.branch(m_out.isZero64(cell), unsure(continuation), unsure(notEmpty));
              lastNext = m_out.appendTo(notEmpty, continuation);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3356,22 ***</span>
                  jit.breakpoint();
                  done.link(&amp;jit);
              });
      }
  
<span class="line-modified">!     void compileCheckStringIdent()</span>
      {
          UniquedStringImpl* uid = m_node-&gt;uidOperand();
<span class="line-modified">!         LValue stringImpl = lowStringIdent(m_node-&gt;child1());</span>
          speculate(BadIdent, noValue(), nullptr, m_out.notEqual(stringImpl, m_out.constIntPtr(uid)));
      }
  
      void compileGetExecutable()
      {
          LValue cell = lowCell(m_node-&gt;child1());
          speculateFunction(m_node-&gt;child1(), cell);
<span class="line-modified">!         setJSValue(m_out.loadPtr(cell, m_heaps.JSFunction_executable));</span>
      }
  
      void compileArrayify()
      {
          LValue cell = lowCell(m_node-&gt;child1());
<span class="line-new-header">--- 3468,41 ---</span>
                  jit.breakpoint();
                  done.link(&amp;jit);
              });
      }
  
<span class="line-modified">!     void compileCheckIdent()</span>
      {
          UniquedStringImpl* uid = m_node-&gt;uidOperand();
<span class="line-modified">!         LValue stringImpl;</span>
<span class="line-added">+         if (m_node-&gt;child1().useKind() == StringIdentUse)</span>
<span class="line-added">+             stringImpl = lowStringIdent(m_node-&gt;child1());</span>
<span class="line-added">+         else {</span>
<span class="line-added">+             ASSERT(m_node-&gt;child1().useKind() == SymbolUse);</span>
<span class="line-added">+             stringImpl = m_out.loadPtr(lowSymbol(m_node-&gt;child1()), m_heaps.Symbol_symbolImpl);</span>
<span class="line-added">+         }</span>
          speculate(BadIdent, noValue(), nullptr, m_out.notEqual(stringImpl, m_out.constIntPtr(uid)));
      }
  
      void compileGetExecutable()
      {
<span class="line-added">+         LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock hasRareData = m_out.newBlock();</span>
          LValue cell = lowCell(m_node-&gt;child1());
          speculateFunction(m_node-&gt;child1(), cell);
<span class="line-modified">! </span>
<span class="line-added">+         LValue rareDataTags = m_out.loadPtr(cell, m_heaps.JSFunction_executableOrRareData);</span>
<span class="line-added">+         ValueFromBlock fastExecutable = m_out.anchor(rareDataTags);</span>
<span class="line-added">+         m_out.branch(m_out.testIsZeroPtr(rareDataTags, m_out.constIntPtr(JSFunction::rareDataTag)), unsure(continuation), unsure(hasRareData));</span>
<span class="line-added">+ </span>
<span class="line-added">+         LBasicBlock lastNext = m_out.appendTo(hasRareData, continuation);</span>
<span class="line-added">+         LValue rareData = m_out.sub(rareDataTags, m_out.constIntPtr(JSFunction::rareDataTag));</span>
<span class="line-added">+         ValueFromBlock slowExecutable = m_out.anchor(m_out.loadPtr(rareData, m_heaps.FunctionRareData_executable));</span>
<span class="line-added">+         m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(continuation, lastNext);</span>
<span class="line-added">+         setJSValue(m_out.phi(pointerType(), fastExecutable, slowExecutable));</span>
      }
  
      void compileArrayify()
      {
          LValue cell = lowCell(m_node-&gt;child1());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3406,21 ***</span>
              }
          }
  
          switch (m_node-&gt;arrayMode().type()) {
          case Array::Int32:
<span class="line-modified">!             vmCall(Void, m_out.operation(operationEnsureInt32), m_callFrame, cell);</span>
              break;
          case Array::Double:
<span class="line-modified">!             vmCall(Void, m_out.operation(operationEnsureDouble), m_callFrame, cell);</span>
              break;
          case Array::Contiguous:
<span class="line-modified">!             vmCall(Void, m_out.operation(operationEnsureContiguous), m_callFrame, cell);</span>
              break;
          case Array::ArrayStorage:
          case Array::SlowPutArrayStorage:
<span class="line-modified">!             vmCall(Void, m_out.operation(operationEnsureArrayStorage), m_callFrame, cell);</span>
              break;
          default:
              DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
              break;
          }
<span class="line-new-header">--- 3537,21 ---</span>
              }
          }
  
          switch (m_node-&gt;arrayMode().type()) {
          case Array::Int32:
<span class="line-modified">!             vmCall(Void, operationEnsureInt32, m_vmValue, cell);</span>
              break;
          case Array::Double:
<span class="line-modified">!             vmCall(Void, operationEnsureDouble, m_vmValue, cell);</span>
              break;
          case Array::Contiguous:
<span class="line-modified">!             vmCall(Void, operationEnsureContiguous, m_vmValue, cell);</span>
              break;
          case Array::ArrayStorage:
          case Array::SlowPutArrayStorage:
<span class="line-modified">!             vmCall(Void, operationEnsureArrayStorage, m_vmValue, cell);</span>
              break;
          default:
              DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
              break;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3447,11 ***</span>
              cell, m_heaps.JSCell_structureID);
      }
  
      void compileGetById(AccessType type)
      {
<span class="line-modified">!         ASSERT(type == AccessType::Get || type == AccessType::TryGet || type == AccessType::GetDirect);</span>
          switch (m_node-&gt;child1().useKind()) {
          case CellUse: {
              setJSValue(getById(lowCell(m_node-&gt;child1()), type));
              return;
          }
<span class="line-new-header">--- 3578,12 ---</span>
              cell, m_heaps.JSCell_structureID);
      }
  
      void compileGetById(AccessType type)
      {
<span class="line-modified">!         ASSERT(type == AccessType::GetById || type == AccessType::TryGetById || type == AccessType::GetByIdDirect);</span>
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          switch (m_node-&gt;child1().useKind()) {
          case CellUse: {
              setJSValue(getById(lowCell(m_node-&gt;child1()), type));
              return;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3471,16 ***</span>
  
              LBasicBlock lastNext = m_out.appendTo(cellCase, notCellCase);
              ValueFromBlock cellResult = m_out.anchor(getById(value, type));
              m_out.jump(continuation);
  
<span class="line-modified">!             J_JITOperation_EJI getByIdFunction = appropriateGenericGetByIdFunction(type);</span>
  
              m_out.appendTo(notCellCase, continuation);
              ValueFromBlock notCellResult = m_out.anchor(vmCall(
<span class="line-modified">!                 Int64, m_out.operation(getByIdFunction),</span>
<span class="line-modified">!                 m_callFrame, value,</span>
                  m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;identifierNumber()])));
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, cellResult, notCellResult));
<span class="line-new-header">--- 3603,16 ---</span>
  
              LBasicBlock lastNext = m_out.appendTo(cellCase, notCellCase);
              ValueFromBlock cellResult = m_out.anchor(getById(value, type));
              m_out.jump(continuation);
  
<span class="line-modified">!             J_JITOperation_GJI getByIdFunction = appropriateGenericGetByIdFunction(type);</span>
  
              m_out.appendTo(notCellCase, continuation);
              ValueFromBlock notCellResult = m_out.anchor(vmCall(
<span class="line-modified">!                 Int64, getByIdFunction,</span>
<span class="line-modified">!                 weakPointer(globalObject), value,</span>
                  m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;identifierNumber()])));
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, cellResult, notCellResult));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3493,10 ***</span>
<span class="line-new-header">--- 3625,11 ---</span>
          }
      }
  
      void compileGetByIdWithThis()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;child1().useKind() == CellUse &amp;&amp; m_node-&gt;child2().useKind() == CellUse)
              setJSValue(getByIdWithThis(lowCell(m_node-&gt;child1()), lowCell(m_node-&gt;child2())));
          else {
              LValue base = lowJSValue(m_node-&gt;child1());
              LValue thisValue = lowJSValue(m_node-&gt;child2());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3518,12 ***</span>
              ValueFromBlock cellResult = m_out.anchor(getByIdWithThis(base, thisValue));
              m_out.jump(continuation);
  
              m_out.appendTo(notCellCase, continuation);
              ValueFromBlock notCellResult = m_out.anchor(vmCall(
<span class="line-modified">!                 Int64, m_out.operation(operationGetByIdWithThisGeneric),</span>
<span class="line-modified">!                 m_callFrame, base, thisValue,</span>
                  m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;identifierNumber()])));
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, cellResult, notCellResult));
<span class="line-new-header">--- 3651,12 ---</span>
              ValueFromBlock cellResult = m_out.anchor(getByIdWithThis(base, thisValue));
              m_out.jump(continuation);
  
              m_out.appendTo(notCellCase, continuation);
              ValueFromBlock notCellResult = m_out.anchor(vmCall(
<span class="line-modified">!                 Int64, operationGetByIdWithThisGeneric,</span>
<span class="line-modified">!                 weakPointer(globalObject), base, thisValue,</span>
                  m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;identifierNumber()])));
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, cellResult, notCellResult));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3531,84 ***</span>
  
      }
  
      void compileGetByValWithThis()
      {
          LValue base = lowJSValue(m_node-&gt;child1());
          LValue thisValue = lowJSValue(m_node-&gt;child2());
          LValue subscript = lowJSValue(m_node-&gt;child3());
  
<span class="line-modified">!         LValue result = vmCall(Int64, m_out.operation(operationGetByValWithThis), m_callFrame, base, thisValue, subscript);</span>
          setJSValue(result);
      }
  
      void compilePutByIdWithThis()
      {
          LValue base = lowJSValue(m_node-&gt;child1());
          LValue thisValue = lowJSValue(m_node-&gt;child2());
          LValue value = lowJSValue(m_node-&gt;child3());
  
<span class="line-modified">!         vmCall(Void, m_out.operation(m_graph.isStrictModeFor(m_node-&gt;origin.semantic) ? operationPutByIdWithThisStrict : operationPutByIdWithThis),</span>
<span class="line-modified">!             m_callFrame, base, thisValue, value, m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;identifierNumber()]));</span>
      }
  
      void compilePutByValWithThis()
      {
          LValue base = lowJSValue(m_graph.varArgChild(m_node, 0));
          LValue thisValue = lowJSValue(m_graph.varArgChild(m_node, 1));
          LValue property = lowJSValue(m_graph.varArgChild(m_node, 2));
          LValue value = lowJSValue(m_graph.varArgChild(m_node, 3));
  
<span class="line-modified">!         vmCall(Void, m_out.operation(m_graph.isStrictModeFor(m_node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis),</span>
<span class="line-modified">!             m_callFrame, base, thisValue, property, value);</span>
      }
  
      void compileAtomicsReadModifyWrite()
      {
          TypedArrayType type = m_node-&gt;arrayMode().typedArrayType();
          unsigned numExtraArgs = numExtraAtomicsArgs(m_node-&gt;op());
          Edge baseEdge = m_graph.child(m_node, 0);
          Edge indexEdge = m_graph.child(m_node, 1);
          Edge argEdges[maxNumExtraAtomicsArgs];
          for (unsigned i = numExtraArgs; i--;)
              argEdges[i] = m_graph.child(m_node, 2 + i);
          Edge storageEdge = m_graph.child(m_node, 2 + numExtraArgs);
  
<span class="line-modified">!         auto operation = [&amp;] () -&gt; LValue {</span>
              switch (m_node-&gt;op()) {
              case AtomicsAdd:
<span class="line-modified">!                 return m_out.operation(operationAtomicsAdd);</span>
              case AtomicsAnd:
<span class="line-modified">!                 return m_out.operation(operationAtomicsAnd);</span>
              case AtomicsCompareExchange:
<span class="line-modified">!                 return m_out.operation(operationAtomicsCompareExchange);</span>
              case AtomicsExchange:
<span class="line-modified">!                 return m_out.operation(operationAtomicsExchange);</span>
              case AtomicsLoad:
<span class="line-modified">!                 return m_out.operation(operationAtomicsLoad);</span>
              case AtomicsOr:
<span class="line-modified">!                 return m_out.operation(operationAtomicsOr);</span>
              case AtomicsStore:
<span class="line-modified">!                 return m_out.operation(operationAtomicsStore);</span>
              case AtomicsSub:
<span class="line-modified">!                 return m_out.operation(operationAtomicsSub);</span>
              case AtomicsXor:
<span class="line-modified">!                 return m_out.operation(operationAtomicsXor);</span>
              default:
                  RELEASE_ASSERT_NOT_REACHED();
<span class="line-removed">-                 break;</span>
              }
<span class="line-removed">-         };</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (!storageEdge) {</span>
<span class="line-removed">-             Vector&lt;LValue&gt; args;</span>
<span class="line-removed">-             args.append(m_callFrame);</span>
<span class="line-removed">-             args.append(lowJSValue(baseEdge));</span>
<span class="line-removed">-             args.append(lowJSValue(indexEdge));</span>
<span class="line-removed">-             for (unsigned i = 0; i &lt; numExtraArgs; ++i)</span>
<span class="line-removed">-                 args.append(lowJSValue(argEdges[i]));</span>
<span class="line-removed">-             LValue result = vmCall(Int64, operation(), args);</span>
              setJSValue(result);
              return;
          }
  
          LValue index = lowInt32(indexEdge);
<span class="line-new-header">--- 3664,102 ---</span>
  
      }
  
      void compileGetByValWithThis()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue base = lowJSValue(m_node-&gt;child1());
          LValue thisValue = lowJSValue(m_node-&gt;child2());
          LValue subscript = lowJSValue(m_node-&gt;child3());
  
<span class="line-modified">!         LValue result = vmCall(Int64, operationGetByValWithThis, weakPointer(globalObject), base, thisValue, subscript);</span>
          setJSValue(result);
      }
  
      void compilePutByIdWithThis()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue base = lowJSValue(m_node-&gt;child1());
          LValue thisValue = lowJSValue(m_node-&gt;child2());
          LValue value = lowJSValue(m_node-&gt;child3());
  
<span class="line-modified">!         vmCall(Void, m_graph.isStrictModeFor(m_node-&gt;origin.semantic) ? operationPutByIdWithThisStrict : operationPutByIdWithThis,</span>
<span class="line-modified">!             weakPointer(globalObject), base, thisValue, value, m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;identifierNumber()]));</span>
      }
  
      void compilePutByValWithThis()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue base = lowJSValue(m_graph.varArgChild(m_node, 0));
          LValue thisValue = lowJSValue(m_graph.varArgChild(m_node, 1));
          LValue property = lowJSValue(m_graph.varArgChild(m_node, 2));
          LValue value = lowJSValue(m_graph.varArgChild(m_node, 3));
  
<span class="line-modified">!         vmCall(Void, m_graph.isStrictModeFor(m_node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis,</span>
<span class="line-modified">!             weakPointer(globalObject), base, thisValue, property, value);</span>
      }
  
      void compileAtomicsReadModifyWrite()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          TypedArrayType type = m_node-&gt;arrayMode().typedArrayType();
          unsigned numExtraArgs = numExtraAtomicsArgs(m_node-&gt;op());
          Edge baseEdge = m_graph.child(m_node, 0);
          Edge indexEdge = m_graph.child(m_node, 1);
          Edge argEdges[maxNumExtraAtomicsArgs];
          for (unsigned i = numExtraArgs; i--;)
              argEdges[i] = m_graph.child(m_node, 2 + i);
          Edge storageEdge = m_graph.child(m_node, 2 + numExtraArgs);
  
<span class="line-modified">!         if (!storageEdge) {</span>
<span class="line-added">+             auto callWith0 = [&amp;] (auto* operation) {</span>
<span class="line-added">+                 ASSERT(numExtraArgs == 0);</span>
<span class="line-added">+                 return vmCall(Int64, operation, weakPointer(globalObject), lowJSValue(baseEdge), lowJSValue(indexEdge));</span>
<span class="line-added">+             };</span>
<span class="line-added">+ </span>
<span class="line-added">+             auto callWith1 = [&amp;] (auto* operation) {</span>
<span class="line-added">+                 ASSERT(numExtraArgs == 1);</span>
<span class="line-added">+                 return vmCall(Int64, operation, weakPointer(globalObject), lowJSValue(baseEdge), lowJSValue(indexEdge), lowJSValue(argEdges[0]));</span>
<span class="line-added">+             };</span>
<span class="line-added">+ </span>
<span class="line-added">+             auto callWith2 = [&amp;] (auto* operation) {</span>
<span class="line-added">+                 ASSERT(numExtraArgs == 2);</span>
<span class="line-added">+                 return vmCall(Int64, operation, weakPointer(globalObject), lowJSValue(baseEdge), lowJSValue(indexEdge), lowJSValue(argEdges[0]), lowJSValue(argEdges[1]));</span>
<span class="line-added">+             };</span>
<span class="line-added">+ </span>
<span class="line-added">+             LValue result;</span>
              switch (m_node-&gt;op()) {
              case AtomicsAdd:
<span class="line-modified">!                 result = callWith1(operationAtomicsAdd);</span>
<span class="line-added">+                 break;</span>
              case AtomicsAnd:
<span class="line-modified">!                 result = callWith1(operationAtomicsAnd);</span>
<span class="line-added">+                 break;</span>
              case AtomicsCompareExchange:
<span class="line-modified">!                 result = callWith2(operationAtomicsCompareExchange);</span>
<span class="line-added">+                 break;</span>
              case AtomicsExchange:
<span class="line-modified">!                 result = callWith1(operationAtomicsExchange);</span>
<span class="line-added">+                 break;</span>
              case AtomicsLoad:
<span class="line-modified">!                 result = callWith0(operationAtomicsLoad);</span>
<span class="line-added">+                 break;</span>
              case AtomicsOr:
<span class="line-modified">!                 result = callWith1(operationAtomicsOr);</span>
<span class="line-added">+                 break;</span>
              case AtomicsStore:
<span class="line-modified">!                 result = callWith1(operationAtomicsStore);</span>
<span class="line-added">+                 break;</span>
              case AtomicsSub:
<span class="line-modified">!                 result = callWith1(operationAtomicsSub);</span>
<span class="line-added">+                 break;</span>
              case AtomicsXor:
<span class="line-modified">!                 result = callWith1(operationAtomicsXor);</span>
<span class="line-added">+                 break;</span>
              default:
                  RELEASE_ASSERT_NOT_REACHED();
              }
              setJSValue(result);
              return;
          }
  
          LValue index = lowInt32(indexEdge);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3691,12 ***</span>
          setIntTypedArrayLoadResult(result, type);
      }
  
      void compileAtomicsIsLockFree()
      {
          if (m_node-&gt;child1().useKind() != Int32Use) {
<span class="line-modified">!             setJSValue(vmCall(Int64, m_out.operation(operationAtomicsIsLockFree), m_callFrame, lowJSValue(m_node-&gt;child1())));</span>
              return;
          }
  
          LValue bytes = lowInt32(m_node-&gt;child1());
  
<span class="line-new-header">--- 3842,13 ---</span>
          setIntTypedArrayLoadResult(result, type);
      }
  
      void compileAtomicsIsLockFree()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;child1().useKind() != Int32Use) {
<span class="line-modified">!             setJSValue(vmCall(Int64, operationAtomicsIsLockFree, weakPointer(globalObject), lowJSValue(m_node-&gt;child1())));</span>
              return;
          }
  
          LValue bytes = lowInt32(m_node-&gt;child1());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3723,66 ***</span>
          setBoolean(m_out.phi(Int32, trueValue, falseValue));
      }
  
      void compileDefineDataProperty()
      {
          LValue base = lowCell(m_graph.varArgChild(m_node, 0));
          LValue value  = lowJSValue(m_graph.varArgChild(m_node, 2));
          LValue attributes = lowInt32(m_graph.varArgChild(m_node, 3));
          Edge&amp; propertyEdge = m_graph.varArgChild(m_node, 1);
          switch (propertyEdge.useKind()) {
          case StringUse: {
              LValue property = lowString(propertyEdge);
<span class="line-modified">!             vmCall(Void, m_out.operation(operationDefineDataPropertyString), m_callFrame, base, property, value, attributes);</span>
              break;
          }
          case StringIdentUse: {
              LValue property = lowStringIdent(propertyEdge);
<span class="line-modified">!             vmCall(Void, m_out.operation(operationDefineDataPropertyStringIdent), m_callFrame, base, property, value, attributes);</span>
              break;
          }
          case SymbolUse: {
              LValue property = lowSymbol(propertyEdge);
<span class="line-modified">!             vmCall(Void, m_out.operation(operationDefineDataPropertySymbol), m_callFrame, base, property, value, attributes);</span>
              break;
          }
          case UntypedUse: {
              LValue property = lowJSValue(propertyEdge);
<span class="line-modified">!             vmCall(Void, m_out.operation(operationDefineDataProperty), m_callFrame, base, property, value, attributes);</span>
              break;
          }
          default:
              RELEASE_ASSERT_NOT_REACHED();
          }
      }
  
      void compileDefineAccessorProperty()
      {
          LValue base = lowCell(m_graph.varArgChild(m_node, 0));
          LValue getter = lowCell(m_graph.varArgChild(m_node, 2));
          LValue setter = lowCell(m_graph.varArgChild(m_node, 3));
          LValue attributes = lowInt32(m_graph.varArgChild(m_node, 4));
          Edge&amp; propertyEdge = m_graph.varArgChild(m_node, 1);
          switch (propertyEdge.useKind()) {
          case StringUse: {
              LValue property = lowString(propertyEdge);
<span class="line-modified">!             vmCall(Void, m_out.operation(operationDefineAccessorPropertyString), m_callFrame, base, property, getter, setter, attributes);</span>
              break;
          }
          case StringIdentUse: {
              LValue property = lowStringIdent(propertyEdge);
<span class="line-modified">!             vmCall(Void, m_out.operation(operationDefineAccessorPropertyStringIdent), m_callFrame, base, property, getter, setter, attributes);</span>
              break;
          }
          case SymbolUse: {
              LValue property = lowSymbol(propertyEdge);
<span class="line-modified">!             vmCall(Void, m_out.operation(operationDefineAccessorPropertySymbol), m_callFrame, base, property, getter, setter, attributes);</span>
              break;
          }
          case UntypedUse: {
              LValue property = lowJSValue(propertyEdge);
<span class="line-modified">!             vmCall(Void, m_out.operation(operationDefineAccessorProperty), m_callFrame, base, property, getter, setter, attributes);</span>
              break;
          }
          default:
              RELEASE_ASSERT_NOT_REACHED();
          }
<span class="line-new-header">--- 3875,68 ---</span>
          setBoolean(m_out.phi(Int32, trueValue, falseValue));
      }
  
      void compileDefineDataProperty()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue base = lowCell(m_graph.varArgChild(m_node, 0));
          LValue value  = lowJSValue(m_graph.varArgChild(m_node, 2));
          LValue attributes = lowInt32(m_graph.varArgChild(m_node, 3));
          Edge&amp; propertyEdge = m_graph.varArgChild(m_node, 1);
          switch (propertyEdge.useKind()) {
          case StringUse: {
              LValue property = lowString(propertyEdge);
<span class="line-modified">!             vmCall(Void, operationDefineDataPropertyString, weakPointer(globalObject), base, property, value, attributes);</span>
              break;
          }
          case StringIdentUse: {
              LValue property = lowStringIdent(propertyEdge);
<span class="line-modified">!             vmCall(Void, operationDefineDataPropertyStringIdent, weakPointer(globalObject), base, property, value, attributes);</span>
              break;
          }
          case SymbolUse: {
              LValue property = lowSymbol(propertyEdge);
<span class="line-modified">!             vmCall(Void, operationDefineDataPropertySymbol, weakPointer(globalObject), base, property, value, attributes);</span>
              break;
          }
          case UntypedUse: {
              LValue property = lowJSValue(propertyEdge);
<span class="line-modified">!             vmCall(Void, operationDefineDataProperty, weakPointer(globalObject), base, property, value, attributes);</span>
              break;
          }
          default:
              RELEASE_ASSERT_NOT_REACHED();
          }
      }
  
      void compileDefineAccessorProperty()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue base = lowCell(m_graph.varArgChild(m_node, 0));
          LValue getter = lowCell(m_graph.varArgChild(m_node, 2));
          LValue setter = lowCell(m_graph.varArgChild(m_node, 3));
          LValue attributes = lowInt32(m_graph.varArgChild(m_node, 4));
          Edge&amp; propertyEdge = m_graph.varArgChild(m_node, 1);
          switch (propertyEdge.useKind()) {
          case StringUse: {
              LValue property = lowString(propertyEdge);
<span class="line-modified">!             vmCall(Void, operationDefineAccessorPropertyString, weakPointer(globalObject), base, property, getter, setter, attributes);</span>
              break;
          }
          case StringIdentUse: {
              LValue property = lowStringIdent(propertyEdge);
<span class="line-modified">!             vmCall(Void, operationDefineAccessorPropertyStringIdent, weakPointer(globalObject), base, property, getter, setter, attributes);</span>
              break;
          }
          case SymbolUse: {
              LValue property = lowSymbol(propertyEdge);
<span class="line-modified">!             vmCall(Void, operationDefineAccessorPropertySymbol, weakPointer(globalObject), base, property, getter, setter, attributes);</span>
              break;
          }
          case UntypedUse: {
              LValue property = lowJSValue(propertyEdge);
<span class="line-modified">!             vmCall(Void, operationDefineAccessorProperty, weakPointer(globalObject), base, property, getter, setter, attributes);</span>
              break;
          }
          default:
              RELEASE_ASSERT_NOT_REACHED();
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3798,12 ***</span>
          auto uid = m_graph.identifiers()[node-&gt;identifierNumber()];
  
          PatchpointValue* patchpoint = m_out.patchpoint(Void);
          patchpoint-&gt;appendSomeRegister(base);
          patchpoint-&gt;appendSomeRegister(value);
<span class="line-modified">!         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));</span>
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
  
          // FIXME: If this is a PutByIdFlush, we might want to late-clobber volatile registers.
          // https://bugs.webkit.org/show_bug.cgi?id=152848
  
<span class="line-new-header">--- 3952,12 ---</span>
          auto uid = m_graph.identifiers()[node-&gt;identifierNumber()];
  
          PatchpointValue* patchpoint = m_out.patchpoint(Void);
          patchpoint-&gt;appendSomeRegister(base);
          patchpoint-&gt;appendSomeRegister(value);
<span class="line-modified">!         patchpoint-&gt;append(m_notCellMask, ValueRep::reg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_numberTag, ValueRep::reg(GPRInfo::numberTagRegister));</span>
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
  
          // FIXME: If this is a PutByIdFlush, we might want to late-clobber volatile registers.
          // https://bugs.webkit.org/show_bug.cgi?id=152848
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3842,10 ***</span>
<span class="line-new-header">--- 3996,11 ---</span>
                          generator-&gt;slowPathJump().link(&amp;jit);
                          CCallHelpers::Label slowPathBegin = jit.label();
                          CCallHelpers::Call slowPathCall = callOperation(
                              *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
                              exceptions.get(), generator-&gt;slowPathFunction(), InvalidGPRReg,
<span class="line-added">+                             jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic),</span>
                              CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), params[1].gpr(),
                              params[0].gpr(), CCallHelpers::TrustedImmPtr(uid)).call();
                          jit.jump().linkTo(done, &amp;jit);
  
                          generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3869,10 ***</span>
<span class="line-new-header">--- 4024,11 ---</span>
          setStorage(m_out.constIntPtr(m_node-&gt;storagePointer()));
      }
  
      void compileGetIndexedPropertyStorage()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue cell = lowCell(m_node-&gt;child1());
  
          if (m_node-&gt;arrayMode().type() == Array::String) {
              LBasicBlock slowPath = m_out.newBlock();
              LBasicBlock continuation = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3882,12 ***</span>
  
              m_out.branch(isRopeString(cell, m_node-&gt;child1()), rarely(slowPath), usually(continuation));
  
              LBasicBlock lastNext = m_out.appendTo(slowPath, continuation);
  
<span class="line-modified">!             ValueFromBlock slowResult = m_out.anchor(</span>
<span class="line-removed">-                 vmCall(pointerType(), m_out.operation(operationResolveRope), m_callFrame, cell));</span>
  
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
  
<span class="line-new-header">--- 4038,11 ---</span>
  
              m_out.branch(isRopeString(cell, m_node-&gt;child1()), rarely(slowPath), usually(continuation));
  
              LBasicBlock lastNext = m_out.appendTo(slowPath, continuation);
  
<span class="line-modified">!             ValueFromBlock slowResult = m_out.anchor(vmCall(pointerType(), operationResolveRope, weakPointer(globalObject), cell));</span>
  
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3911,10 ***</span>
<span class="line-new-header">--- 4066,51 ---</span>
          speculate(
              BadIndexingType, jsValueValue(cell), 0,
              m_out.logicalNot(isArrayTypeForCheckArray(cell, m_node-&gt;arrayMode())));
      }
  
<span class="line-added">+     void compileCheckArrayOrEmpty()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         Edge edge = m_node-&gt;child1();</span>
<span class="line-added">+         LValue cell = lowCell(edge);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (m_node-&gt;arrayMode().alreadyChecked(m_graph, m_node, abstractValue(edge))) {</span>
<span class="line-added">+             // We can purge Empty check of CheckArrayOrEmpty completely in this case since CellUse only accepts SpecCell | SpecEmpty.</span>
<span class="line-added">+             ASSERT(typeFilterFor(m_node-&gt;child1().useKind()) &amp; SpecEmpty);</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         bool maySeeEmptyValue = m_interpreter.forNode(m_node-&gt;child1()).m_type &amp; SpecEmpty;</span>
<span class="line-added">+         LBasicBlock continuation = nullptr;</span>
<span class="line-added">+         LBasicBlock lastNext = nullptr;</span>
<span class="line-added">+         if (maySeeEmptyValue) {</span>
<span class="line-added">+             LBasicBlock notEmpty = m_out.newBlock();</span>
<span class="line-added">+             continuation = m_out.newBlock();</span>
<span class="line-added">+             m_out.branch(m_out.isZero64(cell), unsure(continuation), unsure(notEmpty));</span>
<span class="line-added">+             lastNext = m_out.appendTo(notEmpty, continuation);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         speculate(</span>
<span class="line-added">+             BadIndexingType, jsValueValue(cell), 0,</span>
<span class="line-added">+             m_out.logicalNot(isArrayTypeForCheckArray(cell, m_node-&gt;arrayMode())));</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (maySeeEmptyValue) {</span>
<span class="line-added">+             m_out.jump(continuation);</span>
<span class="line-added">+             m_out.appendTo(continuation, lastNext);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void compileCheckNeutered()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         Edge edge = m_node-&gt;child1();</span>
<span class="line-added">+         LValue cell = lowCell(edge);</span>
<span class="line-added">+ </span>
<span class="line-added">+         speculate(</span>
<span class="line-added">+             BadIndexingType, jsValueValue(cell), edge.node(),</span>
<span class="line-added">+             m_out.isNull(m_out.loadPtr(cell, m_heaps.JSArrayBufferView_vector)));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void compileGetTypedArrayByteOffset()
      {
          LValue basePtr = lowCell(m_node-&gt;child1());
  
          LBasicBlock simpleCase = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3959,10 ***</span>
<span class="line-new-header">--- 4155,11 ---</span>
          setInt32(m_out.castToInt32(m_out.phi(pointerType(), simpleOut, nullVectorOut, wastefulOut)));
      }
  
      void compileGetPrototypeOf()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          switch (m_node-&gt;child1().useKind()) {
          case ArrayUse:
          case FunctionUse:
          case FinalObjectUse: {
              LValue object = lowCell(m_node-&gt;child1());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4020,15 ***</span>
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, directPrototype, polyProto));
              return;
          }
          case ObjectUse: {
<span class="line-modified">!             setJSValue(vmCall(Int64, m_out.operation(operationGetPrototypeOfObject), m_callFrame, lowObject(m_node-&gt;child1())));</span>
              return;
          }
          default: {
<span class="line-modified">!             setJSValue(vmCall(Int64, m_out.operation(operationGetPrototypeOf), m_callFrame, lowJSValue(m_node-&gt;child1())));</span>
              return;
          }
          }
      }
  
<span class="line-new-header">--- 4217,15 ---</span>
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, directPrototype, polyProto));
              return;
          }
          case ObjectUse: {
<span class="line-modified">!             setJSValue(vmCall(Int64, operationGetPrototypeOfObject, weakPointer(globalObject), lowObject(m_node-&gt;child1())));</span>
              return;
          }
          default: {
<span class="line-modified">!             setJSValue(vmCall(Int64, operationGetPrototypeOf, weakPointer(globalObject), lowJSValue(m_node-&gt;child1())));</span>
              return;
          }
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4082,15 ***</span>
              return;
          }
  
          case Array::ScopedArguments: {
              LValue arguments = lowCell(m_node-&gt;child1());
<span class="line-removed">-             LValue storage = m_out.loadPtr(arguments, m_heaps.ScopedArguments_storage);</span>
              speculate(
                  ExoticObjectMode, noValue(), nullptr,
<span class="line-modified">!                 m_out.notZero32(m_out.load8ZeroExt32(storage, m_heaps.ScopedArguments_Storage_overrodeThings)));</span>
<span class="line-modified">!             setInt32(m_out.load32NonNegative(storage, m_heaps.ScopedArguments_Storage_totalLength));</span>
              return;
          }
  
          default:
              if (m_node-&gt;arrayMode().isSomeTypedArrayView()) {
<span class="line-new-header">--- 4279,14 ---</span>
              return;
          }
  
          case Array::ScopedArguments: {
              LValue arguments = lowCell(m_node-&gt;child1());
              speculate(
                  ExoticObjectMode, noValue(), nullptr,
<span class="line-modified">!                 m_out.notZero32(m_out.load8ZeroExt32(arguments, m_heaps.ScopedArguments_overrodeThings)));</span>
<span class="line-modified">!             setInt32(m_out.load32NonNegative(arguments, m_heaps.ScopedArguments_totalLength));</span>
              return;
          }
  
          default:
              if (m_node-&gt;arrayMode().isSomeTypedArrayView()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4127,10 ***</span>
<span class="line-new-header">--- 4323,11 ---</span>
          // we dominate them.
      }
  
      void compileGetByVal()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          switch (m_node-&gt;arrayMode().type()) {
          case Array::Int32:
          case Array::Contiguous: {
              LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
              LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4169,12 ***</span>
              ValueFromBlock fastResult = m_out.anchor(fastResultValue);
              m_out.branch(
                  m_out.isZero64(fastResultValue), rarely(slowCase), usually(continuation));
  
              m_out.appendTo(slowCase, continuation);
<span class="line-modified">!             ValueFromBlock slowResult = m_out.anchor(</span>
<span class="line-removed">-                 vmCall(Int64, m_out.operation(operationGetByValObjectInt), m_callFrame, base, index));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, fastResult, slowResult));
              return;
<span class="line-new-header">--- 4366,11 ---</span>
              ValueFromBlock fastResult = m_out.anchor(fastResultValue);
              m_out.branch(
                  m_out.isZero64(fastResultValue), rarely(slowCase), usually(continuation));
  
              m_out.appendTo(slowCase, continuation);
<span class="line-modified">!             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operationGetByValObjectInt, weakPointer(globalObject), base, index));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, fastResult, slowResult));
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4220,12 ***</span>
              m_out.appendTo(boxPath, slowCase);
              ValueFromBlock fastResult = m_out.anchor(boxDouble(doubleValue));
              m_out.jump(continuation);
  
              m_out.appendTo(slowCase, continuation);
<span class="line-modified">!             ValueFromBlock slowResult = m_out.anchor(</span>
<span class="line-removed">-                 vmCall(Int64, m_out.operation(operationGetByValObjectInt), m_callFrame, base, index));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, fastResult, slowResult));
              return;
<span class="line-new-header">--- 4416,11 ---</span>
              m_out.appendTo(boxPath, slowCase);
              ValueFromBlock fastResult = m_out.anchor(boxDouble(doubleValue));
              m_out.jump(continuation);
  
              m_out.appendTo(slowCase, continuation);
<span class="line-modified">!             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operationGetByValObjectInt, weakPointer(globalObject), base, index));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, fastResult, slowResult));
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4233,11 ***</span>
  
          case Array::Undecided: {
              LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
  
              speculate(OutOfBounds, noValue(), m_node, m_out.lessThan(index, m_out.int32Zero));
<span class="line-modified">!             setJSValue(m_out.constInt64(ValueUndefined));</span>
              return;
          }
  
          case Array::DirectArguments: {
              LValue base = lowCell(m_graph.varArgChild(m_node, 0));
<span class="line-new-header">--- 4428,11 ---</span>
  
          case Array::Undecided: {
              LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
  
              speculate(OutOfBounds, noValue(), m_node, m_out.lessThan(index, m_out.int32Zero));
<span class="line-modified">!             setJSValue(m_out.constInt64(JSValue::ValueUndefined));</span>
              return;
          }
  
          case Array::DirectArguments: {
              LValue base = lowCell(m_graph.varArgChild(m_node, 0));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4270,12 ***</span>
                  m_out.zeroExt(index, pointerType()));
              ValueFromBlock fastResult = m_out.anchor(m_out.load64(address));
              m_out.jump(continuation);
  
              m_out.appendTo(slowCase, continuation);
<span class="line-modified">!             ValueFromBlock slowResult = m_out.anchor(</span>
<span class="line-removed">-                 vmCall(Int64, m_out.operation(operationGetByValObjectInt), m_callFrame, base, index));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, fastResult, slowResult));
              return;
<span class="line-new-header">--- 4465,11 ---</span>
                  m_out.zeroExt(index, pointerType()));
              ValueFromBlock fastResult = m_out.anchor(m_out.load64(address));
              m_out.jump(continuation);
  
              m_out.appendTo(slowCase, continuation);
<span class="line-modified">!             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operationGetByValObjectInt, weakPointer(globalObject), base, index));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, fastResult, slowResult));
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4283,16 ***</span>
  
          case Array::ScopedArguments: {
              LValue base = lowCell(m_graph.varArgChild(m_node, 0));
              LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
  
<span class="line-removed">-             LValue storage = m_out.loadPtr(base, m_heaps.ScopedArguments_storage);</span>
<span class="line-removed">-             LValue totalLength = m_out.load32NonNegative(</span>
<span class="line-removed">-                 storage, m_heaps.ScopedArguments_Storage_totalLength);</span>
              speculate(
                  ExoticObjectMode, noValue(), nullptr,
<span class="line-modified">!                 m_out.aboveOrEqual(index, totalLength));</span>
  
              LValue table = m_out.loadPtr(base, m_heaps.ScopedArguments_table);
              LValue namedLength = m_out.load32(table, m_heaps.ScopedArgumentsTable_length);
  
              LBasicBlock namedCase = m_out.newBlock();
<span class="line-new-header">--- 4477,15 ---</span>
  
          case Array::ScopedArguments: {
              LValue base = lowCell(m_graph.varArgChild(m_node, 0));
              LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
  
              speculate(
                  ExoticObjectMode, noValue(), nullptr,
<span class="line-modified">!                 m_out.aboveOrEqual(</span>
<span class="line-added">+                     index,</span>
<span class="line-added">+                     m_out.load32NonNegative(base, m_heaps.ScopedArguments_totalLength)));</span>
  
              LValue table = m_out.loadPtr(base, m_heaps.ScopedArguments_table);
              LValue namedLength = m_out.load32(table, m_heaps.ScopedArgumentsTable_length);
  
              LBasicBlock namedCase = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4320,46 ***</span>
              ValueFromBlock namedResult = m_out.anchor(m_out.load64(address));
              m_out.jump(continuation);
  
              m_out.appendTo(overflowCase, continuation);
  
              address = m_out.baseIndex(
                  m_heaps.ScopedArguments_Storage_storage, storage,
                  m_out.zeroExtPtr(m_out.sub(index, namedLength)));
              LValue overflowValue = m_out.load64(address);
              speculate(ExoticObjectMode, noValue(), nullptr, m_out.isZero64(overflowValue));
              ValueFromBlock overflowResult = m_out.anchor(overflowValue);
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
<span class="line-modified">! </span>
<span class="line-removed">-             LValue result = m_out.phi(Int64, namedResult, overflowResult);</span>
<span class="line-removed">-             result = preciseIndexMask32(result, index, totalLength);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             setJSValue(result);</span>
              return;
          }
  
          case Array::Generic: {
<span class="line-modified">!             if (m_graph.varArgChild(m_node, 0).useKind() == ObjectUse) {</span>
<span class="line-modified">!                 if (m_graph.varArgChild(m_node, 1).useKind() == StringUse) {</span>
<span class="line-modified">!                     setJSValue(vmCall(</span>
<span class="line-modified">!                         Int64, m_out.operation(operationGetByValObjectString), m_callFrame,</span>
<span class="line-modified">!                         lowObject(m_graph.varArgChild(m_node, 0)), lowString(m_graph.varArgChild(m_node, 1))));</span>
<span class="line-modified">!                     return;</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 if (m_graph.varArgChild(m_node, 1).useKind() == SymbolUse) {</span>
<span class="line-modified">!                     setJSValue(vmCall(</span>
<span class="line-modified">!                         Int64, m_out.operation(operationGetByValObjectSymbol), m_callFrame,</span>
<span class="line-modified">!                         lowObject(m_graph.varArgChild(m_node, 0)), lowSymbol(m_graph.varArgChild(m_node, 1))));</span>
<span class="line-modified">!                     return;</span>
                  }
              }
<span class="line-modified">!             setJSValue(vmCall(</span>
<span class="line-modified">!                 Int64, m_out.operation(operationGetByVal), m_callFrame,</span>
<span class="line-modified">!                 lowJSValue(m_graph.varArgChild(m_node, 0)), lowJSValue(m_graph.varArgChild(m_node, 1))));</span>
              return;
          }
  
          case Array::ArrayStorage:
          case Array::SlowPutArrayStorage: {
<span class="line-new-header">--- 4513,131 ---</span>
              ValueFromBlock namedResult = m_out.anchor(m_out.load64(address));
              m_out.jump(continuation);
  
              m_out.appendTo(overflowCase, continuation);
  
<span class="line-added">+             LValue storage = m_out.loadPtr(base, m_heaps.ScopedArguments_storage);</span>
              address = m_out.baseIndex(
                  m_heaps.ScopedArguments_Storage_storage, storage,
                  m_out.zeroExtPtr(m_out.sub(index, namedLength)));
              LValue overflowValue = m_out.load64(address);
              speculate(ExoticObjectMode, noValue(), nullptr, m_out.isZero64(overflowValue));
              ValueFromBlock overflowResult = m_out.anchor(overflowValue);
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
<span class="line-modified">!             setJSValue(m_out.phi(Int64, namedResult, overflowResult));</span>
              return;
          }
  
          case Array::Generic: {
<span class="line-modified">!             if (m_graph.m_slowGetByVal.contains(m_node)) {</span>
<span class="line-modified">!                 if (m_graph.varArgChild(m_node, 0).useKind() == ObjectUse) {</span>
<span class="line-modified">!                     if (m_graph.varArgChild(m_node, 1).useKind() == StringUse) {</span>
<span class="line-modified">!                         setJSValue(vmCall(</span>
<span class="line-modified">!                             Int64, operationGetByValObjectString, weakPointer(globalObject),</span>
<span class="line-modified">!                             lowObject(m_graph.varArgChild(m_node, 0)), lowString(m_graph.varArgChild(m_node, 1))));</span>
<span class="line-modified">!                         return;</span>
<span class="line-added">+                     }</span>
  
<span class="line-modified">!                     if (m_graph.varArgChild(m_node, 1).useKind() == SymbolUse) {</span>
<span class="line-modified">!                         setJSValue(vmCall(</span>
<span class="line-modified">!                             Int64, operationGetByValObjectSymbol, weakPointer(globalObject),</span>
<span class="line-modified">!                             lowObject(m_graph.varArgChild(m_node, 0)), lowSymbol(m_graph.varArgChild(m_node, 1))));</span>
<span class="line-modified">!                         return;</span>
<span class="line-added">+                     }</span>
                  }
<span class="line-added">+ </span>
<span class="line-added">+                 setJSValue(vmCall(</span>
<span class="line-added">+                     Int64, operationGetByVal, weakPointer(globalObject),</span>
<span class="line-added">+                     lowJSValue(m_graph.varArgChild(m_node, 0)), lowJSValue(m_graph.varArgChild(m_node, 1))));</span>
<span class="line-added">+                 return;</span>
              }
<span class="line-modified">! </span>
<span class="line-modified">!             Node* node = m_node;</span>
<span class="line-modified">! </span>
<span class="line-added">+             LValue base = lowJSValue(m_graph.varArgChild(node, 0), ManualOperandSpeculation);</span>
<span class="line-added">+             LValue property = lowJSValue(m_graph.varArgChild(node, 1), ManualOperandSpeculation);</span>
<span class="line-added">+ </span>
<span class="line-added">+             speculate(m_graph.varArgChild(node, 0));</span>
<span class="line-added">+             speculate(m_graph.varArgChild(node, 1));</span>
<span class="line-added">+             bool baseIsCell = abstractValue(m_graph.varArgChild(node, 0)).isType(SpecCell);</span>
<span class="line-added">+             bool propertyIsString = false;</span>
<span class="line-added">+             bool propertyIsInt32 = false;</span>
<span class="line-added">+             bool propertyIsSymbol = false;</span>
<span class="line-added">+             if (abstractValue(m_graph.varArgChild(node, 1)).isType(SpecString))</span>
<span class="line-added">+                 propertyIsString = true;</span>
<span class="line-added">+             else if (abstractValue(m_graph.varArgChild(node, 1)).isType(SpecInt32Only))</span>
<span class="line-added">+                 propertyIsInt32 = true;</span>
<span class="line-added">+             else if (abstractValue(m_graph.varArgChild(node, 1)).isType(SpecSymbol))</span>
<span class="line-added">+                 propertyIsSymbol = true;</span>
<span class="line-added">+ </span>
<span class="line-added">+             PatchpointValue* patchpoint = m_out.patchpoint(Int64);</span>
<span class="line-added">+             patchpoint-&gt;appendSomeRegister(base);</span>
<span class="line-added">+             patchpoint-&gt;appendSomeRegister(property);</span>
<span class="line-added">+             patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-added">+             patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
<span class="line-added">+             patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());</span>
<span class="line-added">+ </span>
<span class="line-added">+             RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);</span>
<span class="line-added">+ </span>
<span class="line-added">+             State* state = &amp;m_ftlState;</span>
<span class="line-added">+             patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {</span>
<span class="line-added">+                 AllowMacroScratchRegisterUsage allowScratch(jit);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(node-&gt;origin.semantic);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // This is the direct exit target for operation calls.</span>
<span class="line-added">+                 Box&lt;CCallHelpers::JumpList&gt; exceptions = exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // This is the exit for call IC&#39;s created by the IC for getters. We don&#39;t have</span>
<span class="line-added">+                 // to do anything weird other than call this, since it will associate the exit with</span>
<span class="line-added">+                 // the callsite index.</span>
<span class="line-added">+                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 GPRReg resultGPR = params[0].gpr();</span>
<span class="line-added">+                 GPRReg baseGPR = params[1].gpr();</span>
<span class="line-added">+                 GPRReg propertyGPR = params[2].gpr();</span>
<span class="line-added">+ </span>
<span class="line-added">+                 auto generator = Box&lt;JITGetByValGenerator&gt;::create(</span>
<span class="line-added">+                     jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex, params.unavailableRegisters(),</span>
<span class="line-added">+                     JSValueRegs(baseGPR), JSValueRegs(propertyGPR), JSValueRegs(resultGPR));</span>
<span class="line-added">+ </span>
<span class="line-added">+                 generator-&gt;stubInfo()-&gt;propertyIsString = propertyIsString;</span>
<span class="line-added">+                 generator-&gt;stubInfo()-&gt;propertyIsInt32 = propertyIsInt32;</span>
<span class="line-added">+                 generator-&gt;stubInfo()-&gt;propertyIsSymbol = propertyIsSymbol;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 CCallHelpers::Jump notCell;</span>
<span class="line-added">+                 if (!baseIsCell)</span>
<span class="line-added">+                     notCell = jit.branchIfNotCell(baseGPR);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 generator-&gt;generateFastPath(jit);</span>
<span class="line-added">+                 CCallHelpers::Label done = jit.label();</span>
<span class="line-added">+ </span>
<span class="line-added">+                 params.addLatePath([=] (CCallHelpers&amp; jit) {</span>
<span class="line-added">+                     AllowMacroScratchRegisterUsage allowScratch(jit);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if (notCell.isSet())</span>
<span class="line-added">+                         notCell.link(&amp;jit);</span>
<span class="line-added">+                     generator-&gt;slowPathJump().link(&amp;jit);</span>
<span class="line-added">+                     CCallHelpers::Label slowPathBegin = jit.label();</span>
<span class="line-added">+                     CCallHelpers::Call slowPathCall = callOperation(</span>
<span class="line-added">+                         *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,</span>
<span class="line-added">+                         exceptions.get(), operationGetByValOptimize, resultGPR,</span>
<span class="line-added">+                         jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic),</span>
<span class="line-added">+                         CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), CCallHelpers::TrustedImmPtr(nullptr), baseGPR, propertyGPR).call();</span>
<span class="line-added">+                     jit.jump().linkTo(done, &amp;jit);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {</span>
<span class="line-added">+                         generator-&gt;finalize(linkBuffer, linkBuffer);</span>
<span class="line-added">+                     });</span>
<span class="line-added">+                 });</span>
<span class="line-added">+             });</span>
<span class="line-added">+ </span>
<span class="line-added">+             setJSValue(patchpoint);</span>
              return;
          }
  
          case Array::ArrayStorage:
          case Array::SlowPutArrayStorage: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4391,11 ***</span>
                  m_out.isZero64(result),
                  rarely(slowCase), usually(continuation));
  
              m_out.appendTo(slowCase, continuation);
              ValueFromBlock slowResult = m_out.anchor(
<span class="line-modified">!                 vmCall(Int64, m_out.operation(operationGetByValObjectInt), m_callFrame, base, index));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, fastResult, slowResult));
              return;
<span class="line-new-header">--- 4669,11 ---</span>
                  m_out.isZero64(result),
                  rarely(slowCase), usually(continuation));
  
              m_out.appendTo(slowCase, continuation);
              ValueFromBlock slowResult = m_out.anchor(
<span class="line-modified">!                 vmCall(Int64, operationGetByValObjectInt, weakPointer(globalObject), base, index));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, fastResult, slowResult));
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4503,18 ***</span>
          TypedPointer base;
          if (inlineCallFrame) {
              if (inlineCallFrame-&gt;argumentCountIncludingThis &gt; 1)
                  base = addressFor(inlineCallFrame-&gt;argumentsWithFixup[0].virtualRegister());
          } else
<span class="line-modified">!             base = addressFor(virtualRegisterForArgument(0));</span>
  
          LValue result;
          if (base) {
              LValue pointer = m_out.baseIndex(
                  base.value(), m_out.zeroExt(index, pointerType()), ScaleEight);
              result = m_out.load64(TypedPointer(m_heaps.variables.atAnyIndex(), pointer));
<span class="line-removed">-             result = preciseIndexMask32(result, indexToCheck, numberOfArgs);</span>
          } else
              result = m_out.constInt64(JSValue::encode(jsUndefined()));
  
          if (m_node-&gt;op() == GetMyArgumentByValOutOfBounds) {
              ValueFromBlock normalResult = m_out.anchor(result);
<span class="line-new-header">--- 4781,17 ---</span>
          TypedPointer base;
          if (inlineCallFrame) {
              if (inlineCallFrame-&gt;argumentCountIncludingThis &gt; 1)
                  base = addressFor(inlineCallFrame-&gt;argumentsWithFixup[0].virtualRegister());
          } else
<span class="line-modified">!             base = addressFor(virtualRegisterForArgumentIncludingThis(0));</span>
  
          LValue result;
          if (base) {
              LValue pointer = m_out.baseIndex(
                  base.value(), m_out.zeroExt(index, pointerType()), ScaleEight);
              result = m_out.load64(TypedPointer(m_heaps.variables.atAnyIndex(), pointer));
          } else
              result = m_out.constInt64(JSValue::encode(jsUndefined()));
  
          if (m_node-&gt;op() == GetMyArgumentByValOutOfBounds) {
              ValueFromBlock normalResult = m_out.anchor(result);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4527,21 ***</span>
          setJSValue(result);
      }
  
      void compilePutByVal()
      {
          Edge child1 = m_graph.varArgChild(m_node, 0);
          Edge child2 = m_graph.varArgChild(m_node, 1);
          Edge child3 = m_graph.varArgChild(m_node, 2);
          Edge child4 = m_graph.varArgChild(m_node, 3);
          Edge child5 = m_graph.varArgChild(m_node, 4);
  
          ArrayMode arrayMode = m_node-&gt;arrayMode().modeForPut();
          switch (arrayMode.type()) {
          case Array::Generic: {
              if (child1.useKind() == CellUse) {
<span class="line-modified">!                 V_JITOperation_ECCJ operation = nullptr;</span>
                  if (child2.useKind() == StringUse) {
                      if (m_node-&gt;op() == PutByValDirect) {
                          if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
                              operation = operationPutByValDirectCellStringStrict;
                          else
<span class="line-new-header">--- 4804,22 ---</span>
          setJSValue(result);
      }
  
      void compilePutByVal()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          Edge child1 = m_graph.varArgChild(m_node, 0);
          Edge child2 = m_graph.varArgChild(m_node, 1);
          Edge child3 = m_graph.varArgChild(m_node, 2);
          Edge child4 = m_graph.varArgChild(m_node, 3);
          Edge child5 = m_graph.varArgChild(m_node, 4);
  
          ArrayMode arrayMode = m_node-&gt;arrayMode().modeForPut();
          switch (arrayMode.type()) {
          case Array::Generic: {
              if (child1.useKind() == CellUse) {
<span class="line-modified">!                 V_JITOperation_GCCJ operation = nullptr;</span>
                  if (child2.useKind() == StringUse) {
                      if (m_node-&gt;op() == PutByValDirect) {
                          if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
                              operation = operationPutByValDirectCellStringStrict;
                          else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4550,11 ***</span>
                          if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
                              operation = operationPutByValCellStringStrict;
                          else
                              operation = operationPutByValCellStringNonStrict;
                      }
<span class="line-modified">!                     vmCall(Void, m_out.operation(operation), m_callFrame, lowCell(child1), lowString(child2), lowJSValue(child3));</span>
                      return;
                  }
  
                  if (child2.useKind() == SymbolUse) {
                      if (m_node-&gt;op() == PutByValDirect) {
<span class="line-new-header">--- 4828,11 ---</span>
                          if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
                              operation = operationPutByValCellStringStrict;
                          else
                              operation = operationPutByValCellStringNonStrict;
                      }
<span class="line-modified">!                     vmCall(Void, operation, weakPointer(globalObject), lowCell(child1), lowString(child2), lowJSValue(child3));</span>
                      return;
                  }
  
                  if (child2.useKind() == SymbolUse) {
                      if (m_node-&gt;op() == PutByValDirect) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4566,16 ***</span>
                          if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
                              operation = operationPutByValCellSymbolStrict;
                          else
                              operation = operationPutByValCellSymbolNonStrict;
                      }
<span class="line-modified">!                     vmCall(Void, m_out.operation(operation), m_callFrame, lowCell(child1), lowSymbol(child2), lowJSValue(child3));</span>
                      return;
                  }
              }
  
<span class="line-modified">!             V_JITOperation_EJJJ operation;</span>
              if (m_node-&gt;op() == PutByValDirect) {
                  if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
                      operation = operationPutByValDirectStrict;
                  else
                      operation = operationPutByValDirectNonStrict;
<span class="line-new-header">--- 4844,16 ---</span>
                          if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
                              operation = operationPutByValCellSymbolStrict;
                          else
                              operation = operationPutByValCellSymbolNonStrict;
                      }
<span class="line-modified">!                     vmCall(Void, operation, weakPointer(globalObject), lowCell(child1), lowSymbol(child2), lowJSValue(child3));</span>
                      return;
                  }
              }
  
<span class="line-modified">!             V_JITOperation_GJJJ operation;</span>
              if (m_node-&gt;op() == PutByValDirect) {
                  if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
                      operation = operationPutByValDirectStrict;
                  else
                      operation = operationPutByValDirectNonStrict;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4585,11 ***</span>
                  else
                      operation = operationPutByValNonStrict;
              }
  
              vmCall(
<span class="line-modified">!                 Void, m_out.operation(operation), m_callFrame,</span>
                  lowJSValue(child1), lowJSValue(child2), lowJSValue(child3));
              return;
          }
  
          default:
<span class="line-new-header">--- 4863,11 ---</span>
                  else
                      operation = operationPutByValNonStrict;
              }
  
              vmCall(
<span class="line-modified">!                 Void, operation, weakPointer(globalObject),</span>
                  lowJSValue(child1), lowJSValue(child2), lowJSValue(child3));
              return;
          }
  
          default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4709,12 ***</span>
  
              m_out.branch(isOutOfBounds, rarely(slowCase), usually(inBoundCase));
  
              LBasicBlock lastNext = m_out.appendTo(slowCase, inBoundCase);
              vmCall(
<span class="line-modified">!                 Void, m_out.operation(slowPathFunction),</span>
<span class="line-modified">!                 m_callFrame, base, index, value);</span>
              m_out.jump(continuation);
  
  
              if (arrayMode.isSlowPut()) {
                  m_out.appendTo(inBoundCase, doStoreCase);
<span class="line-new-header">--- 4987,12 ---</span>
  
              m_out.branch(isOutOfBounds, rarely(slowCase), usually(inBoundCase));
  
              LBasicBlock lastNext = m_out.appendTo(slowCase, inBoundCase);
              vmCall(
<span class="line-modified">!                 Void, slowPathFunction,</span>
<span class="line-modified">!                 weakPointer(globalObject), base, index, value);</span>
              m_out.jump(continuation);
  
  
              if (arrayMode.isSlowPut()) {
                  m_out.appendTo(inBoundCase, doStoreCase);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4829,58 ***</span>
          }
      }
  
      void compilePutAccessorById()
      {
          LValue base = lowCell(m_node-&gt;child1());
          LValue accessor = lowCell(m_node-&gt;child2());
          auto uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
          vmCall(
              Void,
<span class="line-modified">!             m_out.operation(m_node-&gt;op() == PutGetterById ? operationPutGetterById : operationPutSetterById),</span>
<span class="line-modified">!             m_callFrame, base, m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;accessorAttributes()), accessor);</span>
      }
  
      void compilePutGetterSetterById()
      {
          LValue base = lowCell(m_node-&gt;child1());
          LValue getter = lowJSValue(m_node-&gt;child2());
          LValue setter = lowJSValue(m_node-&gt;child3());
          auto uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
          vmCall(
<span class="line-modified">!             Void, m_out.operation(operationPutGetterSetter),</span>
<span class="line-modified">!             m_callFrame, base, m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;accessorAttributes()), getter, setter);</span>
  
      }
  
      void compilePutAccessorByVal()
      {
          LValue base = lowCell(m_node-&gt;child1());
          LValue subscript = lowJSValue(m_node-&gt;child2());
          LValue accessor = lowCell(m_node-&gt;child3());
          vmCall(
              Void,
<span class="line-modified">!             m_out.operation(m_node-&gt;op() == PutGetterByVal ? operationPutGetterByVal : operationPutSetterByVal),</span>
<span class="line-modified">!             m_callFrame, base, subscript, m_out.constInt32(m_node-&gt;accessorAttributes()), accessor);</span>
      }
  
      void compileDeleteById()
      {
          LValue base = lowJSValue(m_node-&gt;child1());
          auto uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<span class="line-modified">!         setBoolean(m_out.notZero64(vmCall(Int64, m_out.operation(operationDeleteById), m_callFrame, base, m_out.constIntPtr(uid))));</span>
      }
  
      void compileDeleteByVal()
      {
          LValue base = lowJSValue(m_node-&gt;child1());
          LValue subscript = lowJSValue(m_node-&gt;child2());
<span class="line-modified">!         setBoolean(m_out.notZero64(vmCall(Int64, m_out.operation(operationDeleteByVal), m_callFrame, base, subscript)));</span>
      }
  
      void compileArrayPush()
      {
          LValue base = lowCell(m_graph.varArgChild(m_node, 1));
          LValue storage = lowStorage(m_graph.varArgChild(m_node, 0));
          unsigned elementOffset = 2;
          unsigned elementCount = m_node-&gt;numChildren() - elementOffset;
  
<span class="line-new-header">--- 5107,64 ---</span>
          }
      }
  
      void compilePutAccessorById()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue base = lowCell(m_node-&gt;child1());
          LValue accessor = lowCell(m_node-&gt;child2());
          auto uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
          vmCall(
              Void,
<span class="line-modified">!             m_node-&gt;op() == PutGetterById ? operationPutGetterById : operationPutSetterById,</span>
<span class="line-modified">!             weakPointer(globalObject), base, m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;accessorAttributes()), accessor);</span>
      }
  
      void compilePutGetterSetterById()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue base = lowCell(m_node-&gt;child1());
          LValue getter = lowJSValue(m_node-&gt;child2());
          LValue setter = lowJSValue(m_node-&gt;child3());
          auto uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
          vmCall(
<span class="line-modified">!             Void, operationPutGetterSetter,</span>
<span class="line-modified">!             weakPointer(globalObject), base, m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;accessorAttributes()), getter, setter);</span>
  
      }
  
      void compilePutAccessorByVal()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue base = lowCell(m_node-&gt;child1());
          LValue subscript = lowJSValue(m_node-&gt;child2());
          LValue accessor = lowCell(m_node-&gt;child3());
          vmCall(
              Void,
<span class="line-modified">!             m_node-&gt;op() == PutGetterByVal ? operationPutGetterByVal : operationPutSetterByVal,</span>
<span class="line-modified">!             weakPointer(globalObject), base, subscript, m_out.constInt32(m_node-&gt;accessorAttributes()), accessor);</span>
      }
  
      void compileDeleteById()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue base = lowJSValue(m_node-&gt;child1());
          auto uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<span class="line-modified">!         setBoolean(m_out.notZero64(vmCall(Int64, operationDeleteById, weakPointer(globalObject), base, m_out.constIntPtr(uid))));</span>
      }
  
      void compileDeleteByVal()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue base = lowJSValue(m_node-&gt;child1());
          LValue subscript = lowJSValue(m_node-&gt;child2());
<span class="line-modified">!         setBoolean(m_out.notZero64(vmCall(Int64, operationDeleteByVal, weakPointer(globalObject), base, subscript)));</span>
      }
  
      void compileArrayPush()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue base = lowCell(m_graph.varArgChild(m_node, 1));
          LValue storage = lowStorage(m_graph.varArgChild(m_node, 0));
          unsigned elementOffset = 2;
          unsigned elementCount = m_node-&gt;numChildren() - elementOffset;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4923,17 ***</span>
  
                  ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
                  m_out.jump(continuation);
  
                  m_out.appendTo(slowPath, continuation);
<span class="line-modified">!                 LValue operation;</span>
                  if (m_node-&gt;arrayMode().type() != Array::Double)
<span class="line-modified">!                     operation = m_out.operation(operationArrayPush);</span>
                  else
<span class="line-modified">!                     operation = m_out.operation(operationArrayPushDouble);</span>
<span class="line-modified">!                 ValueFromBlock slowResult = m_out.anchor(</span>
<span class="line-removed">-                     vmCall(Int64, operation, m_callFrame, value, base));</span>
                  m_out.jump(continuation);
  
                  m_out.appendTo(continuation, lastNext);
                  setJSValue(m_out.phi(Int64, fastResult, slowResult));
                  return;
<span class="line-new-header">--- 5207,16 ---</span>
  
                  ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
                  m_out.jump(continuation);
  
                  m_out.appendTo(slowPath, continuation);
<span class="line-modified">!                 LValue result;</span>
                  if (m_node-&gt;arrayMode().type() != Array::Double)
<span class="line-modified">!                     result = vmCall(Int64, operationArrayPush, weakPointer(globalObject), value, base);</span>
                  else
<span class="line-modified">!                     result = vmCall(Int64, operationArrayPushDouble, weakPointer(globalObject), value, base);</span>
<span class="line-modified">!                 ValueFromBlock slowResult = m_out.anchor(result);</span>
                  m_out.jump(continuation);
  
                  m_out.appendTo(continuation, lastNext);
                  setJSValue(m_out.phi(Int64, fastResult, slowResult));
                  return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4991,16 ***</span>
              ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
  
              m_out.branch(beyondVectorLength, unsure(slowCallPath), unsure(continuation));
  
              m_out.appendTo(slowCallPath, continuation);
<span class="line-modified">!             LValue operation;</span>
<span class="line-modified">!             if (m_node-&gt;arrayMode().type() != Array::Double)</span>
<span class="line-modified">!                 operation = m_out.operation(operationArrayPushMultiple);</span>
<span class="line-modified">!             else</span>
<span class="line-removed">-                 operation = m_out.operation(operationArrayPushDoubleMultiple);</span>
<span class="line-removed">-             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operation, m_callFrame, base, buffer, m_out.constInt32(elementCount)));</span>
              m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, fastResult, slowResult));
<span class="line-new-header">--- 5274,14 ---</span>
              ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
  
              m_out.branch(beyondVectorLength, unsure(slowCallPath), unsure(continuation));
  
              m_out.appendTo(slowCallPath, continuation);
<span class="line-modified">!             auto* operation = &amp;operationArrayPushMultiple;</span>
<span class="line-modified">!             if (m_node-&gt;arrayMode().type() == Array::Double)</span>
<span class="line-modified">!                 operation = &amp;operationArrayPushDoubleMultiple;</span>
<span class="line-modified">!             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operation, weakPointer(globalObject), base, buffer, m_out.constInt32(elementCount)));</span>
              m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, fastResult, slowResult));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5041,11 ***</span>
                  ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
                  m_out.jump(continuation);
  
                  m_out.appendTo(slowPath, continuation);
                  ValueFromBlock slowResult = m_out.anchor(
<span class="line-modified">!                     vmCall(Int64, m_out.operation(operationArrayPush), m_callFrame, value, base));</span>
                  m_out.jump(continuation);
  
                  m_out.appendTo(continuation, lastNext);
                  setJSValue(m_out.phi(Int64, fastResult, slowResult));
                  return;
<span class="line-new-header">--- 5322,11 ---</span>
                  ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
                  m_out.jump(continuation);
  
                  m_out.appendTo(slowPath, continuation);
                  ValueFromBlock slowResult = m_out.anchor(
<span class="line-modified">!                     vmCall(Int64, operationArrayPush, weakPointer(globalObject), value, base));</span>
                  m_out.jump(continuation);
  
                  m_out.appendTo(continuation, lastNext);
                  setJSValue(m_out.phi(Int64, fastResult, slowResult));
                  return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5090,11 ***</span>
              ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
  
              m_out.branch(beyondVectorLength, rarely(slowCallPath), usually(continuation));
  
              m_out.appendTo(slowCallPath, continuation);
<span class="line-modified">!             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, m_out.operation(operationArrayPushMultiple), m_callFrame, base, buffer, m_out.constInt32(elementCount)));</span>
              m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, fastResult, slowResult));
<span class="line-new-header">--- 5371,11 ---</span>
              ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
  
              m_out.branch(beyondVectorLength, rarely(slowCallPath), usually(continuation));
  
              m_out.appendTo(slowCallPath, continuation);
<span class="line-modified">!             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operationArrayPushMultiple, weakPointer(globalObject), base, buffer, m_out.constInt32(elementCount)));</span>
              m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, fastResult, slowResult));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5201,10 ***</span>
<span class="line-new-header">--- 5482,11 ---</span>
          setJSValue(arrayResult.array);
      }
  
      void compileArrayIndexOf()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue storage = lowStorage(m_node-&gt;numChildren() == 3 ? m_graph.varArgChild(m_node, 2) : m_graph.varArgChild(m_node, 3));
          LValue length = m_out.load32(storage, m_heaps.Butterfly_publicLength);
  
          LValue startIndex;
          if (m_node-&gt;numChildren() == 4) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5269,11 ***</span>
  
              m_out.appendTo(loopBody, loopNext);
              ValueFromBlock foundResult = m_out.anchor(index);
              switch (searchElementEdge.useKind()) {
              case Int32Use: {
<span class="line-modified">!                 // Empty value is ignored because of TagTypeNumber.</span>
                  LValue value = m_out.load64(m_out.baseIndex(m_heaps.indexedInt32Properties, storage, index));
                  m_out.branch(m_out.equal(value, searchElement), unsure(continuation), unsure(loopNext));
                  break;
              }
              case ObjectUse:
<span class="line-new-header">--- 5551,11 ---</span>
  
              m_out.appendTo(loopBody, loopNext);
              ValueFromBlock foundResult = m_out.anchor(index);
              switch (searchElementEdge.useKind()) {
              case Int32Use: {
<span class="line-modified">!                 // Empty value is ignored because of JSValue::NumberTag.</span>
                  LValue value = m_out.load64(m_out.baseIndex(m_heaps.indexedInt32Properties, storage, index));
                  m_out.branch(m_out.equal(value, searchElement), unsure(continuation), unsure(loopNext));
                  break;
              }
              case ObjectUse:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5309,21 ***</span>
              break;
          }
  
          case StringUse:
              ASSERT(m_node-&gt;arrayMode().type() == Array::Contiguous);
<span class="line-modified">!             setInt32(vmCall(Int32, m_out.operation(operationArrayIndexOfString), m_callFrame, storage, lowString(searchElementEdge), startIndex));</span>
              break;
  
          case UntypedUse:
              switch (m_node-&gt;arrayMode().type()) {
              case Array::Double:
<span class="line-modified">!                 setInt32(vmCall(Int32, m_out.operation(operationArrayIndexOfValueDouble), m_callFrame, storage, lowJSValue(searchElementEdge), startIndex));</span>
                  break;
              case Array::Int32:
              case Array::Contiguous:
<span class="line-modified">!                 setInt32(vmCall(Int32, m_out.operation(operationArrayIndexOfValueInt32OrContiguous), m_callFrame, storage, lowJSValue(searchElementEdge), startIndex));</span>
                  break;
              default:
                  RELEASE_ASSERT_NOT_REACHED();
                  break;
              }
<span class="line-new-header">--- 5591,21 ---</span>
              break;
          }
  
          case StringUse:
              ASSERT(m_node-&gt;arrayMode().type() == Array::Contiguous);
<span class="line-modified">!             setInt32(vmCall(Int32, operationArrayIndexOfString, weakPointer(globalObject), storage, lowString(searchElementEdge), startIndex));</span>
              break;
  
          case UntypedUse:
              switch (m_node-&gt;arrayMode().type()) {
              case Array::Double:
<span class="line-modified">!                 setInt32(vmCall(Int32, operationArrayIndexOfValueDouble, weakPointer(globalObject), storage, lowJSValue(searchElementEdge), startIndex));</span>
                  break;
              case Array::Int32:
              case Array::Contiguous:
<span class="line-modified">!                 setInt32(vmCall(Int32, operationArrayIndexOfValueInt32OrContiguous, weakPointer(globalObject), storage, lowJSValue(searchElementEdge), startIndex));</span>
                  break;
              default:
                  RELEASE_ASSERT_NOT_REACHED();
                  break;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5336,10 ***</span>
<span class="line-new-header">--- 5618,11 ---</span>
      }
  
  
      void compileArrayPop()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue base = lowCell(m_node-&gt;child1());
          LValue storage = lowStorage(m_node-&gt;child2());
  
          switch (m_node-&gt;arrayMode().type()) {
          case Array::Int32:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5377,11 ***</span>
                      usually(continuation), rarely(slowCase));
              }
  
              m_out.appendTo(slowCase, continuation);
              results.append(m_out.anchor(vmCall(
<span class="line-modified">!                 Int64, m_out.operation(operationArrayPopAndRecoverLength), m_callFrame, base)));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, results));
              return;
<span class="line-new-header">--- 5660,11 ---</span>
                      usually(continuation), rarely(slowCase));
              }
  
              m_out.appendTo(slowCase, continuation);
              results.append(m_out.anchor(vmCall(
<span class="line-modified">!                 Int64, operationArrayPopAndRecoverLength, weakPointer(globalObject), base)));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, results));
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5419,12 ***</span>
                  storage, m_heaps.ArrayStorage_numValuesInVector);
              results.append(m_out.anchor(result));
              m_out.jump(continuation);
  
              m_out.appendTo(slowCase, continuation);
<span class="line-modified">!             results.append(m_out.anchor(vmCall(</span>
<span class="line-removed">-                 Int64, m_out.operation(operationArrayPop), m_callFrame, base)));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, results));
              return;
<span class="line-new-header">--- 5702,11 ---</span>
                  storage, m_heaps.ArrayStorage_numValuesInVector);
              results.append(m_out.anchor(result));
              m_out.jump(continuation);
  
              m_out.appendTo(slowCase, continuation);
<span class="line-modified">!             results.append(m_out.anchor(vmCall(Int64, operationArrayPop, weakPointer(globalObject), base)));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, results));
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5436,20 ***</span>
          }
      }
  
      void compilePushWithScope()
      {
          LValue parentScope = lowCell(m_node-&gt;child1());
          auto objectEdge = m_node-&gt;child2();
          if (objectEdge.useKind() == ObjectUse) {
              LValue object = lowNonNullObject(objectEdge);
<span class="line-modified">!             LValue result = vmCall(Int64, m_out.operation(operationPushWithScopeObject), m_callFrame, parentScope, object);</span>
              setJSValue(result);
          } else {
              ASSERT(objectEdge.useKind() == UntypedUse);
              LValue object = lowJSValue(m_node-&gt;child2());
<span class="line-modified">!             LValue result = vmCall(Int64, m_out.operation(operationPushWithScope), m_callFrame, parentScope, object);</span>
              setJSValue(result);
          }
      }
  
      void compileCreateActivation()
<span class="line-new-header">--- 5718,21 ---</span>
          }
      }
  
      void compilePushWithScope()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue parentScope = lowCell(m_node-&gt;child1());
          auto objectEdge = m_node-&gt;child2();
          if (objectEdge.useKind() == ObjectUse) {
              LValue object = lowNonNullObject(objectEdge);
<span class="line-modified">!             LValue result = vmCall(Int64, operationPushWithScopeObject, weakPointer(globalObject), parentScope, object);</span>
              setJSValue(result);
          } else {
              ASSERT(objectEdge.useKind() == UntypedUse);
              LValue object = lowJSValue(m_node-&gt;child2());
<span class="line-modified">!             LValue result = vmCall(Int64, operationPushWithScope, weakPointer(globalObject), parentScope, object);</span>
              setJSValue(result);
          }
      }
  
      void compileCreateActivation()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5460,11 ***</span>
          JSValue initializationValue = m_node-&gt;initializationValueForActivation();
          ASSERT(initializationValue.isUndefined() || initializationValue == jsTDZValue());
          if (table-&gt;singleton().isStillValid()) {
              LValue callResult = vmCall(
                  Int64,
<span class="line-modified">!                 m_out.operation(operationCreateActivationDirect), m_callFrame, weakStructure(structure),</span>
                  scope, weakPointer(table), m_out.constInt64(JSValue::encode(initializationValue)));
              setJSValue(callResult);
              return;
          }
  
<span class="line-new-header">--- 5743,11 ---</span>
          JSValue initializationValue = m_node-&gt;initializationValueForActivation();
          ASSERT(initializationValue.isUndefined() || initializationValue == jsTDZValue());
          if (table-&gt;singleton().isStillValid()) {
              LValue callResult = vmCall(
                  Int64,
<span class="line-modified">!                 operationCreateActivationDirect, m_vmValue, weakStructure(structure),</span>
                  scope, weakPointer(table), m_out.constInt64(JSValue::encode(initializationValue)));
              setJSValue(callResult);
              return;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5495,11 ***</span>
          m_out.appendTo(slowPath, continuation);
          VM&amp; vm = this-&gt;vm();
          LValue callResult = lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                  return createLazyCallGenerator(vm,
<span class="line-modified">!                     operationCreateActivationDirect, locations[0].directGPR(),</span>
                      CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
                      CCallHelpers::TrustedImmPtr(table),
                      CCallHelpers::TrustedImm64(JSValue::encode(initializationValue)));
              },
              scope);
<span class="line-new-header">--- 5778,11 ---</span>
          m_out.appendTo(slowPath, continuation);
          VM&amp; vm = this-&gt;vm();
          LValue callResult = lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                  return createLazyCallGenerator(vm,
<span class="line-modified">!                     operationCreateActivationDirect, locations[0].directGPR(), &amp;vm,</span>
                      CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
                      CCallHelpers::TrustedImmPtr(table),
                      CCallHelpers::TrustedImm64(JSValue::encode(initializationValue)));
              },
              scope);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5520,14 ***</span>
          LValue scope = lowCell(m_node-&gt;child1());
  
          FunctionExecutable* executable = m_node-&gt;castOperand&lt;FunctionExecutable*&gt;();
          if (executable-&gt;singleton().isStillValid()) {
              LValue callResult =
<span class="line-modified">!                 isGeneratorFunction ? vmCall(Int64, m_out.operation(operationNewGeneratorFunction), m_callFrame, scope, weakPointer(executable)) :</span>
<span class="line-modified">!                 isAsyncFunction ? vmCall(Int64, m_out.operation(operationNewAsyncFunction), m_callFrame, scope, weakPointer(executable)) :</span>
<span class="line-modified">!                 isAsyncGeneratorFunction ? vmCall(Int64, m_out.operation(operationNewAsyncGeneratorFunction), m_callFrame, scope, weakPointer(executable)) :</span>
<span class="line-modified">!                 vmCall(Int64, m_out.operation(operationNewFunction), m_callFrame, scope, weakPointer(executable));</span>
              setJSValue(callResult);
              return;
          }
  
          RegisteredStructure structure = m_graph.registerStructure(
<span class="line-new-header">--- 5803,14 ---</span>
          LValue scope = lowCell(m_node-&gt;child1());
  
          FunctionExecutable* executable = m_node-&gt;castOperand&lt;FunctionExecutable*&gt;();
          if (executable-&gt;singleton().isStillValid()) {
              LValue callResult =
<span class="line-modified">!                 isGeneratorFunction ? vmCall(Int64, operationNewGeneratorFunction, m_vmValue, scope, weakPointer(executable)) :</span>
<span class="line-modified">!                 isAsyncFunction ? vmCall(Int64, operationNewAsyncFunction, m_vmValue, scope, weakPointer(executable)) :</span>
<span class="line-modified">!                 isAsyncGeneratorFunction ? vmCall(Int64, operationNewAsyncGeneratorFunction, m_vmValue, scope, weakPointer(executable)) :</span>
<span class="line-modified">!                 vmCall(Int64, operationNewFunction, m_vmValue, scope, weakPointer(executable));</span>
              setJSValue(callResult);
              return;
          }
  
          RegisteredStructure structure = m_graph.registerStructure(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5560,39 ***</span>
  
  
          // We don&#39;t need memory barriers since we just fast-created the function, so it
          // must be young.
          m_out.storePtr(scope, fastObject, m_heaps.JSFunction_scope);
<span class="line-modified">!         m_out.storePtr(weakPointer(executable), fastObject, m_heaps.JSFunction_executable);</span>
<span class="line-modified">!         m_out.storePtr(m_out.intPtrZero, fastObject, m_heaps.JSFunction_rareData);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         VM&amp; vm = this-&gt;vm();</span>
<span class="line-removed">-         if (executable-&gt;isAnonymousBuiltinFunction()) {</span>
<span class="line-removed">-             mutatorFence();</span>
<span class="line-removed">-             Allocator allocator = allocatorForNonVirtualConcurrently&lt;FunctionRareData&gt;(vm, sizeof(FunctionRareData), AllocatorForMode::AllocatorIfExists);</span>
<span class="line-removed">-             LValue rareData = allocateCell(m_out.constIntPtr(allocator.localAllocator()), vm.functionRareDataStructure.get(), slowPath);</span>
<span class="line-removed">-             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_allocator);</span>
<span class="line-removed">-             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_structure);</span>
<span class="line-removed">-             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_prototype);</span>
<span class="line-removed">-             m_out.storePtr(m_out.intPtrOne, rareData, m_heaps.FunctionRareData_objectAllocationProfileWatchpoint);</span>
<span class="line-removed">-             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_internalFunctionAllocationProfile_structure);</span>
<span class="line-removed">-             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_boundFunctionStructure);</span>
<span class="line-removed">-             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_allocationProfileClearingWatchpoint);</span>
<span class="line-removed">-             m_out.store32As8(m_out.int32One, rareData, m_heaps.FunctionRareData_hasReifiedName);</span>
<span class="line-removed">-             m_out.store32As8(m_out.int32Zero, rareData, m_heaps.FunctionRareData_hasReifiedLength);</span>
<span class="line-removed">-             mutatorFence();</span>
<span class="line-removed">-             m_out.storePtr(rareData, fastObject, m_heaps.JSFunction_rareData);</span>
<span class="line-removed">-         } else</span>
<span class="line-removed">-             mutatorFence();</span>
  
          ValueFromBlock fastResult = m_out.anchor(fastObject);
          m_out.jump(continuation);
  
          m_out.appendTo(slowPath, continuation);
  
          Vector&lt;LValue&gt; slowPathArguments;
          slowPathArguments.append(scope);
          LValue callResult = lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                  auto* operation = operationNewFunctionWithInvalidatedReallocationWatchpoint;
                  if (isGeneratorFunction)
                      operation = operationNewGeneratorFunctionWithInvalidatedReallocationWatchpoint;
<span class="line-new-header">--- 5843,21 ---</span>
  
  
          // We don&#39;t need memory barriers since we just fast-created the function, so it
          // must be young.
          m_out.storePtr(scope, fastObject, m_heaps.JSFunction_scope);
<span class="line-modified">!         m_out.storePtr(weakPointer(executable), fastObject, m_heaps.JSFunction_executableOrRareData);</span>
<span class="line-modified">!         mutatorFence();</span>
  
          ValueFromBlock fastResult = m_out.anchor(fastObject);
          m_out.jump(continuation);
  
          m_out.appendTo(slowPath, continuation);
  
          Vector&lt;LValue&gt; slowPathArguments;
          slowPathArguments.append(scope);
<span class="line-added">+         VM&amp; vm = this-&gt;vm();</span>
          LValue callResult = lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                  auto* operation = operationNewFunctionWithInvalidatedReallocationWatchpoint;
                  if (isGeneratorFunction)
                      operation = operationNewGeneratorFunctionWithInvalidatedReallocationWatchpoint;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5600,11 ***</span>
                      operation = operationNewAsyncFunctionWithInvalidatedReallocationWatchpoint;
                  else if (isAsyncGeneratorFunction)
                      operation = operationNewAsyncGeneratorFunctionWithInvalidatedReallocationWatchpoint;
  
                  return createLazyCallGenerator(vm, operation,
<span class="line-modified">!                     locations[0].directGPR(), locations[1].directGPR(),</span>
                      CCallHelpers::TrustedImmPtr(executable));
              },
              slowPathArguments);
          ValueFromBlock slowResult = m_out.anchor(callResult);
          m_out.jump(continuation);
<span class="line-new-header">--- 5865,11 ---</span>
                      operation = operationNewAsyncFunctionWithInvalidatedReallocationWatchpoint;
                  else if (isAsyncGeneratorFunction)
                      operation = operationNewAsyncGeneratorFunctionWithInvalidatedReallocationWatchpoint;
  
                  return createLazyCallGenerator(vm, operation,
<span class="line-modified">!                     locations[0].directGPR(), &amp;vm, locations[1].directGPR(),</span>
                      CCallHelpers::TrustedImmPtr(executable));
              },
              slowPathArguments);
          ValueFromBlock slowResult = m_out.anchor(callResult);
          m_out.jump(continuation);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5660,11 ***</span>
          m_out.appendTo(slowPath, continuation);
          VM&amp; vm = this-&gt;vm();
          LValue callResult = lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                  return createLazyCallGenerator(vm,
<span class="line-modified">!                     operationCreateDirectArguments, locations[0].directGPR(),</span>
                      CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
                      CCallHelpers::TrustedImm32(minCapacity));
              }, length.value);
          ValueFromBlock slowResult = m_out.anchor(callResult);
          m_out.jump(continuation);
<span class="line-new-header">--- 5925,11 ---</span>
          m_out.appendTo(slowPath, continuation);
          VM&amp; vm = this-&gt;vm();
          LValue callResult = lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                  return createLazyCallGenerator(vm,
<span class="line-modified">!                     operationCreateDirectArguments, locations[0].directGPR(), &amp;vm,</span>
                      CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
                      CCallHelpers::TrustedImm32(minCapacity));
              }, length.value);
          ValueFromBlock slowResult = m_out.anchor(callResult);
          m_out.jump(continuation);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5720,39 ***</span>
          setJSValue(result);
      }
  
      void compileCreateScopedArguments()
      {
          LValue scope = lowCell(m_node-&gt;child1());
  
          LValue result = vmCall(
<span class="line-modified">!             Int64, m_out.operation(operationCreateScopedArguments), m_callFrame,</span>
              weakPointer(
                  m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;scopedArgumentsStructure()),
              getArgumentsStart(), getArgumentsLength().value, getCurrentCallee(), scope);
  
          setJSValue(result);
      }
  
      void compileCreateClonedArguments()
      {
          LValue result = vmCall(
<span class="line-modified">!             Int64, m_out.operation(operationCreateClonedArguments), m_callFrame,</span>
              weakPointer(
                  m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;clonedArgumentsStructure()),
              getArgumentsStart(), getArgumentsLength().value, getCurrentCallee());
  
          setJSValue(result);
      }
  
      void compileCreateRest()
      {
          if (m_graph.isWatchingHavingABadTimeWatchpoint(m_node)) {
              LBasicBlock continuation = m_out.newBlock();
              LValue arrayLength = lowInt32(m_node-&gt;child1());
              LBasicBlock loopStart = m_out.newBlock();
<span class="line-removed">-             JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
              RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;originalRestParameterStructure());
              ArrayValues arrayValues = allocateUninitializedContiguousJSArray(arrayLength, structure);
              LValue array = arrayValues.array;
              LValue butterfly = arrayValues.butterfly;
              ValueFromBlock startLength = m_out.anchor(arrayLength);
<span class="line-new-header">--- 5985,48 ---</span>
          setJSValue(result);
      }
  
      void compileCreateScopedArguments()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue scope = lowCell(m_node-&gt;child1());
  
          LValue result = vmCall(
<span class="line-modified">!             Int64, operationCreateScopedArguments, weakPointer(globalObject),</span>
              weakPointer(
                  m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;scopedArgumentsStructure()),
              getArgumentsStart(), getArgumentsLength().value, getCurrentCallee(), scope);
  
          setJSValue(result);
      }
  
      void compileCreateClonedArguments()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue result = vmCall(
<span class="line-modified">!             Int64, operationCreateClonedArguments, weakPointer(globalObject),</span>
              weakPointer(
                  m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;clonedArgumentsStructure()),
              getArgumentsStart(), getArgumentsLength().value, getCurrentCallee());
  
          setJSValue(result);
      }
  
<span class="line-added">+     void compileCreateArgumentsButterfly()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added">+         LValue result = vmCall(Int64, operationCreateArgumentsButterfly, weakPointer(globalObject), getArgumentsStart(), getArgumentsLength().value);</span>
<span class="line-added">+         setJSValue(result);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void compileCreateRest()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_graph.isWatchingHavingABadTimeWatchpoint(m_node)) {
              LBasicBlock continuation = m_out.newBlock();
              LValue arrayLength = lowInt32(m_node-&gt;child1());
              LBasicBlock loopStart = m_out.newBlock();
              RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;originalRestParameterStructure());
              ArrayValues arrayValues = allocateUninitializedContiguousJSArray(arrayLength, structure);
              LValue array = arrayValues.array;
              LValue butterfly = arrayValues.butterfly;
              ValueFromBlock startLength = m_out.anchor(arrayLength);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5777,11 ***</span>
  
          LValue arrayLength = lowInt32(m_node-&gt;child1());
          LValue argumentStart = getArgumentsStart();
          LValue numberOfArgumentsToSkip = m_out.constInt32(m_node-&gt;numberOfArgumentsToSkip());
          setJSValue(vmCall(
<span class="line-modified">!             Int64, m_out.operation(operationCreateRest), m_callFrame, argumentStart, numberOfArgumentsToSkip, arrayLength));</span>
      }
  
      void compileGetRestLength()
      {
          LBasicBlock nonZeroLength = m_out.newBlock();
<span class="line-new-header">--- 6051,11 ---</span>
  
          LValue arrayLength = lowInt32(m_node-&gt;child1());
          LValue argumentStart = getArgumentsStart();
          LValue numberOfArgumentsToSkip = m_out.constInt32(m_node-&gt;numberOfArgumentsToSkip());
          setJSValue(vmCall(
<span class="line-modified">!             Int64, operationCreateRest, weakPointer(globalObject), argumentStart, numberOfArgumentsToSkip, arrayLength));</span>
      }
  
      void compileGetRestLength()
      {
          LBasicBlock nonZeroLength = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5802,10 ***</span>
<span class="line-new-header">--- 6076,11 ---</span>
          setInt32(m_out.phi(Int32, zeroLengthResult, nonZeroLengthResult));
      }
  
      void compileObjectKeys()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          switch (m_node-&gt;child1().useKind()) {
          case ObjectUse: {
              if (m_graph.isWatchingHavingABadTimeWatchpoint(m_node)) {
                  LBasicBlock notNullCase = m_out.newBlock();
                  LBasicBlock rareDataCase = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5828,56 ***</span>
                  ASSERT(bitwise_cast&lt;uintptr_t&gt;(StructureRareData::cachedOwnKeysSentinel()) == 1);
                  LValue cachedOwnKeys = m_out.loadPtr(previousOrRareData, m_heaps.StructureRareData_cachedOwnKeys);
                  m_out.branch(m_out.belowOrEqual(cachedOwnKeys, m_out.constIntPtr(bitwise_cast&lt;void*&gt;(StructureRareData::cachedOwnKeysSentinel()))), unsure(slowCase), unsure(useCacheCase));
  
                  m_out.appendTo(useCacheCase, slowButArrayBufferCase);
<span class="line-removed">-                 JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
                  RegisteredStructure arrayStructure = m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(CopyOnWriteArrayWithContiguous));
                  LValue fastArray = allocateObject&lt;JSArray&gt;(arrayStructure, m_out.addPtr(cachedOwnKeys, JSImmutableButterfly::offsetOfData()), slowButArrayBufferCase);
                  ValueFromBlock fastResult = m_out.anchor(fastArray);
                  m_out.jump(continuation);
  
                  m_out.appendTo(slowButArrayBufferCase, slowCase);
<span class="line-modified">!                 LValue slowArray = vmCall(Int64, m_out.operation(operationNewArrayBuffer), m_callFrame, weakStructure(arrayStructure), cachedOwnKeys);</span>
                  ValueFromBlock slowButArrayBufferResult = m_out.anchor(slowArray);
                  m_out.jump(continuation);
  
                  m_out.appendTo(slowCase, continuation);
                  VM&amp; vm = this-&gt;vm();
                  LValue slowResultValue = lazySlowPath(
                      [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                          return createLazyCallGenerator(vm,
<span class="line-modified">!                             operationObjectKeysObject, locations[0].directGPR(), locations[1].directGPR());</span>
                      },
                      object);
                  ValueFromBlock slowResult = m_out.anchor(slowResultValue);
                  m_out.jump(continuation);
  
                  m_out.appendTo(continuation, lastNext);
                  setJSValue(m_out.phi(pointerType(), fastResult, slowButArrayBufferResult, slowResult));
                  break;
              }
<span class="line-modified">!             setJSValue(vmCall(Int64, m_out.operation(operationObjectKeysObject), m_callFrame, lowObject(m_node-&gt;child1())));</span>
              break;
          }
          case UntypedUse:
<span class="line-modified">!             setJSValue(vmCall(Int64, m_out.operation(operationObjectKeys), m_callFrame, lowJSValue(m_node-&gt;child1())));</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
          }
      }
  
      void compileObjectCreate()
      {
          switch (m_node-&gt;child1().useKind()) {
          case ObjectUse:
<span class="line-modified">!             setJSValue(vmCall(Int64, m_out.operation(operationObjectCreateObject), m_callFrame, lowObject(m_node-&gt;child1())));</span>
              break;
          case UntypedUse:
<span class="line-modified">!             setJSValue(vmCall(Int64, m_out.operation(operationObjectCreate), m_callFrame, lowJSValue(m_node-&gt;child1())));</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
          }
<span class="line-new-header">--- 6103,56 ---</span>
                  ASSERT(bitwise_cast&lt;uintptr_t&gt;(StructureRareData::cachedOwnKeysSentinel()) == 1);
                  LValue cachedOwnKeys = m_out.loadPtr(previousOrRareData, m_heaps.StructureRareData_cachedOwnKeys);
                  m_out.branch(m_out.belowOrEqual(cachedOwnKeys, m_out.constIntPtr(bitwise_cast&lt;void*&gt;(StructureRareData::cachedOwnKeysSentinel()))), unsure(slowCase), unsure(useCacheCase));
  
                  m_out.appendTo(useCacheCase, slowButArrayBufferCase);
                  RegisteredStructure arrayStructure = m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(CopyOnWriteArrayWithContiguous));
                  LValue fastArray = allocateObject&lt;JSArray&gt;(arrayStructure, m_out.addPtr(cachedOwnKeys, JSImmutableButterfly::offsetOfData()), slowButArrayBufferCase);
                  ValueFromBlock fastResult = m_out.anchor(fastArray);
                  m_out.jump(continuation);
  
                  m_out.appendTo(slowButArrayBufferCase, slowCase);
<span class="line-modified">!                 LValue slowArray = vmCall(Int64, operationNewArrayBuffer, m_vmValue, weakStructure(arrayStructure), cachedOwnKeys);</span>
                  ValueFromBlock slowButArrayBufferResult = m_out.anchor(slowArray);
                  m_out.jump(continuation);
  
                  m_out.appendTo(slowCase, continuation);
                  VM&amp; vm = this-&gt;vm();
                  LValue slowResultValue = lazySlowPath(
                      [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                          return createLazyCallGenerator(vm,
<span class="line-modified">!                             operationObjectKeysObject, locations[0].directGPR(), globalObject, locations[1].directGPR());</span>
                      },
                      object);
                  ValueFromBlock slowResult = m_out.anchor(slowResultValue);
                  m_out.jump(continuation);
  
                  m_out.appendTo(continuation, lastNext);
                  setJSValue(m_out.phi(pointerType(), fastResult, slowButArrayBufferResult, slowResult));
                  break;
              }
<span class="line-modified">!             setJSValue(vmCall(Int64, operationObjectKeysObject, weakPointer(globalObject), lowObject(m_node-&gt;child1())));</span>
              break;
          }
          case UntypedUse:
<span class="line-modified">!             setJSValue(vmCall(Int64, operationObjectKeys, weakPointer(globalObject), lowJSValue(m_node-&gt;child1())));</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
          }
      }
  
      void compileObjectCreate()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          switch (m_node-&gt;child1().useKind()) {
          case ObjectUse:
<span class="line-modified">!             setJSValue(vmCall(Int64, operationObjectCreateObject, weakPointer(globalObject), lowObject(m_node-&gt;child1())));</span>
              break;
          case UntypedUse:
<span class="line-modified">!             setJSValue(vmCall(Int64, operationObjectCreate, weakPointer(globalObject), lowJSValue(m_node-&gt;child1())));</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5887,10 ***</span>
<span class="line-new-header">--- 6162,76 ---</span>
      {
          setJSValue(allocateObject(m_node-&gt;structure()));
          mutatorFence();
      }
  
<span class="line-added">+     void compileNewPromise()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         LBasicBlock slowCase = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added">+ </span>
<span class="line-added">+         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowCase);</span>
<span class="line-added">+ </span>
<span class="line-added">+         LValue promise;</span>
<span class="line-added">+         if (m_node-&gt;isInternalPromise())</span>
<span class="line-added">+             promise = allocateObject&lt;JSInternalPromise&gt;(m_node-&gt;structure(), m_out.intPtrZero, slowCase);</span>
<span class="line-added">+         else</span>
<span class="line-added">+             promise = allocateObject&lt;JSPromise&gt;(m_node-&gt;structure(), m_out.intPtrZero, slowCase);</span>
<span class="line-added">+         m_out.store64(m_out.constInt64(JSValue::encode(jsNumber(static_cast&lt;unsigned&gt;(JSPromise::Status::Pending)))), promise, m_heaps.JSInternalFieldObjectImpl_internalFields[static_cast&lt;unsigned&gt;(JSPromise::Field::Flags)]);</span>
<span class="line-added">+         m_out.store64(m_out.constInt64(JSValue::encode(jsUndefined())), promise, m_heaps.JSInternalFieldObjectImpl_internalFields[static_cast&lt;unsigned&gt;(JSPromise::Field::ReactionsOrResult)]);</span>
<span class="line-added">+         mutatorFence();</span>
<span class="line-added">+         ValueFromBlock fastResult = m_out.anchor(promise);</span>
<span class="line-added">+         m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(slowCase, continuation);</span>
<span class="line-added">+         ValueFromBlock slowResult = m_out.anchor(vmCall(pointerType(), m_node-&gt;isInternalPromise() ? operationNewInternalPromise : operationNewPromise, m_vmValue, frozenPointer(m_graph.freezeStrong(m_node-&gt;structure().get()))));</span>
<span class="line-added">+         m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(continuation, lastNext);</span>
<span class="line-added">+         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     template&lt;typename JSClass, typename Operation&gt;</span>
<span class="line-added">+     void compileNewInternalFieldObject(Operation operation)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         LBasicBlock slowCase = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added">+ </span>
<span class="line-added">+         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowCase);</span>
<span class="line-added">+ </span>
<span class="line-added">+         LValue object = allocateObject&lt;JSClass&gt;(m_node-&gt;structure(), m_out.intPtrZero, slowCase);</span>
<span class="line-added">+         auto initialValues = JSClass::initialValues();</span>
<span class="line-added">+         static_assert(initialValues.size() == JSClass::numberOfInternalFields);</span>
<span class="line-added">+         for (unsigned index = 0; index &lt; initialValues.size(); ++index)</span>
<span class="line-added">+             m_out.store64(m_out.constInt64(JSValue::encode(initialValues[index])), object, m_heaps.JSInternalFieldObjectImpl_internalFields[index]);</span>
<span class="line-added">+         mutatorFence();</span>
<span class="line-added">+         ValueFromBlock fastResult = m_out.anchor(object);</span>
<span class="line-added">+         m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(slowCase, continuation);</span>
<span class="line-added">+         ValueFromBlock slowResult = m_out.anchor(vmCall(pointerType(), operation, m_vmValue, frozenPointer(m_graph.freezeStrong(m_node-&gt;structure().get()))));</span>
<span class="line-added">+         m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(continuation, lastNext);</span>
<span class="line-added">+         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void compileNewGenerator()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         compileNewInternalFieldObject&lt;JSGenerator&gt;(operationNewGenerator);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void compileNewAsyncGenerator()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         compileNewInternalFieldObject&lt;JSAsyncGenerator&gt;(operationNewAsyncGenerator);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void compileNewArrayIterator()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         compileNewInternalFieldObject&lt;JSArrayIterator&gt;(operationNewArrayIterator);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void compileNewStringObject()
      {
          RegisteredStructure structure = m_node-&gt;structure();
          LValue string = lowString(m_node-&gt;child1());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5909,11 ***</span>
          m_out.appendTo(slowCase, continuation);
          VM&amp; vm = this-&gt;vm();
          LValue slowResultValue = lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                  return createLazyCallGenerator(vm,
<span class="line-modified">!                     operationNewStringObject, locations[0].directGPR(), locations[1].directGPR(),</span>
                      CCallHelpers::TrustedImmPtr(structure.get()));
              },
              string);
          ValueFromBlock slowResult = m_out.anchor(slowResultValue);
          m_out.jump(continuation);
<span class="line-new-header">--- 6250,11 ---</span>
          m_out.appendTo(slowCase, continuation);
          VM&amp; vm = this-&gt;vm();
          LValue slowResultValue = lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                  return createLazyCallGenerator(vm,
<span class="line-modified">!                     operationNewStringObject, locations[0].directGPR(), &amp;vm, locations[1].directGPR(),</span>
                      CCallHelpers::TrustedImmPtr(structure.get()));
              },
              string);
          ValueFromBlock slowResult = m_out.anchor(slowResultValue);
          m_out.jump(continuation);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5922,16 ***</span>
          setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
      }
  
      void compileNewSymbol()
      {
          if (!m_node-&gt;child1()) {
<span class="line-modified">!             setJSValue(vmCall(pointerType(), m_out.operation(operationNewSymbol), m_callFrame));</span>
              return;
          }
          ASSERT(m_node-&gt;child1().useKind() == KnownStringUse);
<span class="line-modified">!         setJSValue(vmCall(pointerType(), m_out.operation(operationNewSymbolWithDescription), m_callFrame, lowString(m_node-&gt;child1())));</span>
      }
  
      void compileNewArray()
      {
          // First speculate appropriately on all of the children. Do this unconditionally up here
<span class="line-new-header">--- 6263,17 ---</span>
          setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
      }
  
      void compileNewSymbol()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (!m_node-&gt;child1()) {
<span class="line-modified">!             setJSValue(vmCall(pointerType(), operationNewSymbol, m_vmValue));</span>
              return;
          }
          ASSERT(m_node-&gt;child1().useKind() == KnownStringUse);
<span class="line-modified">!         setJSValue(vmCall(pointerType(), operationNewSymbolWithDescription, weakPointer(globalObject), lowString(m_node-&gt;child1())));</span>
      }
  
      void compileNewArray()
      {
          // First speculate appropriately on all of the children. Do this unconditionally up here
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5988,11 ***</span>
              return;
          }
  
          if (!m_node-&gt;numChildren()) {
              setJSValue(vmCall(
<span class="line-modified">!                 Int64, m_out.operation(operationNewEmptyArray), m_callFrame,</span>
                  weakStructure(structure)));
              return;
          }
  
          size_t scratchSize = sizeof(EncodedJSValue) * m_node-&gt;numChildren();
<span class="line-new-header">--- 6330,11 ---</span>
              return;
          }
  
          if (!m_node-&gt;numChildren()) {
              setJSValue(vmCall(
<span class="line-modified">!                 Int64, operationNewEmptyArray, m_vmValue,</span>
                  weakStructure(structure)));
              return;
          }
  
          size_t scratchSize = sizeof(EncodedJSValue) * m_node-&gt;numChildren();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6016,26 ***</span>
  
          m_out.storePtr(
              m_out.constIntPtr(scratchSize), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
  
          LValue result = vmCall(
<span class="line-modified">!             Int64, m_out.operation(operationNewArray), m_callFrame,</span>
              weakStructure(structure), m_out.constIntPtr(buffer),
              m_out.constIntPtr(m_node-&gt;numChildren()));
  
          m_out.storePtr(m_out.intPtrZero, m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
  
          setJSValue(result);
      }
  
      void compileNewArrayWithSpread()
      {
          if (m_graph.isWatchingHavingABadTimeWatchpoint(m_node)) {
              CheckedInt32 startLength = 0;
              BitVector* bitVector = m_node-&gt;bitVector();
              HashMap&lt;InlineCallFrame*, LValue, WTF::DefaultHash&lt;InlineCallFrame*&gt;::Hash, WTF::NullableHashTraits&lt;InlineCallFrame*&gt;&gt; cachedSpreadLengths;
  
              for (unsigned i = 0; i &lt; m_node-&gt;numChildren(); ++i) {
                  if (!bitVector-&gt;get(i))
                      ++startLength;
                  else {
                      Edge&amp; child = m_graph.varArgChild(m_node, i);
<span class="line-new-header">--- 6358,78 ---</span>
  
          m_out.storePtr(
              m_out.constIntPtr(scratchSize), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
  
          LValue result = vmCall(
<span class="line-modified">!             Int64, operationNewArray, weakPointer(globalObject),</span>
              weakStructure(structure), m_out.constIntPtr(buffer),
              m_out.constIntPtr(m_node-&gt;numChildren()));
  
          m_out.storePtr(m_out.intPtrZero, m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
  
          setJSValue(result);
      }
  
      void compileNewArrayWithSpread()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_graph.isWatchingHavingABadTimeWatchpoint(m_node)) {
              CheckedInt32 startLength = 0;
              BitVector* bitVector = m_node-&gt;bitVector();
              HashMap&lt;InlineCallFrame*, LValue, WTF::DefaultHash&lt;InlineCallFrame*&gt;::Hash, WTF::NullableHashTraits&lt;InlineCallFrame*&gt;&gt; cachedSpreadLengths;
  
<span class="line-added">+             if (m_node-&gt;numChildren() == 1 &amp;&amp; bitVector-&gt;get(0)) {</span>
<span class="line-added">+                 Edge use = m_graph.varArgChild(m_node, 0);</span>
<span class="line-added">+                 if (use-&gt;op() == PhantomSpread) {</span>
<span class="line-added">+                     if (use-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {</span>
<span class="line-added">+                         auto* immutableButterfly = use-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;();</span>
<span class="line-added">+                         if (hasContiguous(immutableButterfly-&gt;indexingType())) {</span>
<span class="line-added">+                             RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;originalArrayStructureForIndexingType(CopyOnWriteArrayWithContiguous));</span>
<span class="line-added">+                             LBasicBlock slowPath = m_out.newBlock();</span>
<span class="line-added">+                             LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added">+ </span>
<span class="line-added">+                             LValue fastArray = allocateObject&lt;JSArray&gt;(structure, m_out.constIntPtr(immutableButterfly-&gt;toButterfly()), slowPath);</span>
<span class="line-added">+                             ValueFromBlock fastResult = m_out.anchor(fastArray);</span>
<span class="line-added">+                             m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+                             m_out.appendTo(slowPath, continuation);</span>
<span class="line-added">+                             LValue slowArray = vmCall(Int64, operationNewArrayBuffer, m_vmValue, weakStructure(structure), frozenPointer(use-&gt;child1()-&gt;cellOperand()));</span>
<span class="line-added">+                             ValueFromBlock slowResult = m_out.anchor(slowArray);</span>
<span class="line-added">+                             m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+                             m_out.appendTo(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+                             mutatorFence();</span>
<span class="line-added">+                             setJSValue(m_out.phi(pointerType(), slowResult, fastResult));</span>
<span class="line-added">+                             return;</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     // If a node is producing JSImmutableButterfly, it must be contiguous.</span>
<span class="line-added">+                     LValue immutableButterfly = lowCell(use);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(CopyOnWriteArrayWithContiguous));</span>
<span class="line-added">+                     LBasicBlock slowPath = m_out.newBlock();</span>
<span class="line-added">+                     LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added">+ </span>
<span class="line-added">+                     LValue fastArray = allocateObject&lt;JSArray&gt;(structure, toButterfly(immutableButterfly), slowPath);</span>
<span class="line-added">+                     ValueFromBlock fastResult = m_out.anchor(fastArray);</span>
<span class="line-added">+                     m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     m_out.appendTo(slowPath, continuation);</span>
<span class="line-added">+                     LValue slowArray = vmCall(Int64, operationNewArrayBuffer, m_vmValue, weakStructure(structure), immutableButterfly);</span>
<span class="line-added">+                     ValueFromBlock slowResult = m_out.anchor(slowArray);</span>
<span class="line-added">+                     m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     m_out.appendTo(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     mutatorFence();</span>
<span class="line-added">+                     setJSValue(m_out.phi(pointerType(), slowResult, fastResult));</span>
<span class="line-added">+                     return;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              for (unsigned i = 0; i &lt; m_node-&gt;numChildren(); ++i) {
                  if (!bitVector-&gt;get(i))
                      ++startLength;
                  else {
                      Edge&amp; child = m_graph.varArgChild(m_node, i);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6063,12 ***</span>
                                  return getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
                              }).iterator-&gt;value;
                              lengthCheck = m_out.speculateAdd(length, spreadLength);
                          }
                      } else {
<span class="line-modified">!                         LValue fixedArray = lowCell(use);</span>
<span class="line-modified">!                         lengthCheck = m_out.speculateAdd(length, m_out.load32(fixedArray, m_heaps.JSFixedArray_size));</span>
                      }
  
                      if (lengthCheck) {
                          blessSpeculation(lengthCheck, Overflow, noValue(), nullptr, m_origin);
                          length = lengthCheck;
<span class="line-new-header">--- 6457,12 ---</span>
                                  return getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
                              }).iterator-&gt;value;
                              lengthCheck = m_out.speculateAdd(length, spreadLength);
                          }
                      } else {
<span class="line-modified">!                         LValue immutableButterfly = lowCell(use);</span>
<span class="line-modified">!                         lengthCheck = m_out.speculateAdd(length, m_out.load32(toButterfly(immutableButterfly), m_heaps.Butterfly_publicLength));</span>
                      }
  
                      if (lengthCheck) {
                          blessSpeculation(lengthCheck, Overflow, noValue(), nullptr, m_origin);
                          length = lengthCheck;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6142,39 ***</span>
                          }
                      } else {
                          LBasicBlock loopStart = m_out.newBlock();
                          LBasicBlock continuation = m_out.newBlock();
  
<span class="line-modified">!                         LValue fixedArray = lowCell(use);</span>
  
<span class="line-modified">!                         ValueFromBlock fixedIndexStart = m_out.anchor(m_out.constIntPtr(0));</span>
                          ValueFromBlock arrayIndexStart = m_out.anchor(index);
                          ValueFromBlock arrayIndexStartForFinish = m_out.anchor(index);
  
<span class="line-modified">!                         LValue fixedArraySize = m_out.zeroExtPtr(m_out.load32(fixedArray, m_heaps.JSFixedArray_size));</span>
  
                          m_out.branch(
<span class="line-modified">!                             m_out.isZero64(fixedArraySize),</span>
                              unsure(continuation), unsure(loopStart));
  
                          LBasicBlock lastNext = m_out.appendTo(loopStart, continuation);
  
                          LValue arrayIndex = m_out.phi(pointerType(), arrayIndexStart);
<span class="line-modified">!                         LValue fixedArrayIndex = m_out.phi(pointerType(), fixedIndexStart);</span>
  
<span class="line-modified">!                         LValue item = m_out.load64(m_out.baseIndex(m_heaps.JSFixedArray_buffer, fixedArray, fixedArrayIndex));</span>
                          m_out.store64(item, m_out.baseIndex(m_heaps.indexedContiguousProperties, storage, arrayIndex));
  
                          LValue nextArrayIndex = m_out.add(arrayIndex, m_out.constIntPtr(1));
<span class="line-modified">!                         LValue nextFixedArrayIndex = m_out.add(fixedArrayIndex, m_out.constIntPtr(1));</span>
                          ValueFromBlock arrayIndexLoopForFinish = m_out.anchor(nextArrayIndex);
  
<span class="line-modified">!                         m_out.addIncomingToPhi(fixedArrayIndex, m_out.anchor(nextFixedArrayIndex));</span>
                          m_out.addIncomingToPhi(arrayIndex, m_out.anchor(nextArrayIndex));
  
                          m_out.branch(
<span class="line-modified">!                             m_out.below(nextFixedArrayIndex, fixedArraySize),</span>
                              unsure(loopStart), unsure(continuation));
  
                          m_out.appendTo(continuation, lastNext);
                          index = m_out.phi(pointerType(), arrayIndexStartForFinish, arrayIndexLoopForFinish);
                      }
<span class="line-new-header">--- 6536,40 ---</span>
                          }
                      } else {
                          LBasicBlock loopStart = m_out.newBlock();
                          LBasicBlock continuation = m_out.newBlock();
  
<span class="line-modified">!                         LValue immutableButterfly = lowCell(use);</span>
<span class="line-added">+                         LValue immutableButterflyStorage = toButterfly(immutableButterfly);</span>
  
<span class="line-modified">!                         ValueFromBlock immutableButterflyIndexStart = m_out.anchor(m_out.constIntPtr(0));</span>
                          ValueFromBlock arrayIndexStart = m_out.anchor(index);
                          ValueFromBlock arrayIndexStartForFinish = m_out.anchor(index);
  
<span class="line-modified">!                         LValue immutableButterflySize = m_out.zeroExtPtr(m_out.load32(immutableButterflyStorage, m_heaps.Butterfly_publicLength));</span>
  
                          m_out.branch(
<span class="line-modified">!                             m_out.isZero64(immutableButterflySize),</span>
                              unsure(continuation), unsure(loopStart));
  
                          LBasicBlock lastNext = m_out.appendTo(loopStart, continuation);
  
                          LValue arrayIndex = m_out.phi(pointerType(), arrayIndexStart);
<span class="line-modified">!                         LValue immutableButterflyIndex = m_out.phi(pointerType(), immutableButterflyIndexStart);</span>
  
<span class="line-modified">!                         LValue item = m_out.load64(m_out.baseIndex(m_heaps.indexedContiguousProperties, immutableButterflyStorage, immutableButterflyIndex));</span>
                          m_out.store64(item, m_out.baseIndex(m_heaps.indexedContiguousProperties, storage, arrayIndex));
  
                          LValue nextArrayIndex = m_out.add(arrayIndex, m_out.constIntPtr(1));
<span class="line-modified">!                         LValue nextImmutableButterflyIndex = m_out.add(immutableButterflyIndex, m_out.constIntPtr(1));</span>
                          ValueFromBlock arrayIndexLoopForFinish = m_out.anchor(nextArrayIndex);
  
<span class="line-modified">!                         m_out.addIncomingToPhi(immutableButterflyIndex, m_out.anchor(nextImmutableButterflyIndex));</span>
                          m_out.addIncomingToPhi(arrayIndex, m_out.anchor(nextArrayIndex));
  
                          m_out.branch(
<span class="line-modified">!                             m_out.below(nextImmutableButterflyIndex, immutableButterflySize),</span>
                              unsure(loopStart), unsure(continuation));
  
                          m_out.appendTo(continuation, lastNext);
                          index = m_out.phi(pointerType(), arrayIndexStartForFinish, arrayIndexLoopForFinish);
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6205,131 ***</span>
                  value = lowJSValue(use);
              m_out.store64(value, m_out.absolute(&amp;buffer[i]));
          }
  
          m_out.storePtr(m_out.constIntPtr(scratchSize), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
<span class="line-modified">!         LValue result = vmCall(Int64, m_out.operation(operationNewArrayWithSpreadSlow), m_callFrame, m_out.constIntPtr(buffer), m_out.constInt32(m_node-&gt;numChildren()));</span>
          m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
  
          setJSValue(result);
      }
  
      void compileCreateThis()
      {
          LValue callee = lowCell(m_node-&gt;child1());
  
          LBasicBlock isFunctionBlock = m_out.newBlock();
          LBasicBlock hasRareData = m_out.newBlock();
          LBasicBlock slowPath = m_out.newBlock();
          LBasicBlock continuation = m_out.newBlock();
  
          m_out.branch(isFunction(callee, provenType(m_node-&gt;child1())), usually(isFunctionBlock), rarely(slowPath));
  
          LBasicBlock lastNext = m_out.appendTo(isFunctionBlock, hasRareData);
<span class="line-modified">!         LValue rareData = m_out.loadPtr(callee, m_heaps.JSFunction_rareData);</span>
<span class="line-modified">!         m_out.branch(m_out.isZero64(rareData), rarely(slowPath), usually(hasRareData));</span>
  
          m_out.appendTo(hasRareData, slowPath);
          LValue allocator = m_out.loadPtr(rareData, m_heaps.FunctionRareData_allocator);
          LValue structure = m_out.loadPtr(rareData, m_heaps.FunctionRareData_structure);
          LValue butterfly = m_out.constIntPtr(0);
          ValueFromBlock fastResult = m_out.anchor(allocateObject(allocator, structure, butterfly, slowPath));
          m_out.jump(continuation);
  
          m_out.appendTo(slowPath, continuation);
          ValueFromBlock slowResult = m_out.anchor(vmCall(
<span class="line-modified">!             Int64, m_out.operation(operationCreateThis), m_callFrame, callee, m_out.constInt32(m_node-&gt;inlineCapacity())));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          LValue result = m_out.phi(Int64, fastResult, slowResult);
  
          mutatorFence();
          setJSValue(result);
      }
  
      void compileSpread()
      {
          if (m_node-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {
              LBasicBlock slowAllocation = m_out.newBlock();
              LBasicBlock continuation = m_out.newBlock();
  
<span class="line-modified">!             auto* immutableButterfly = m_node-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;();</span>
  
<span class="line-modified">!             LValue fastFixedArrayValue = allocateVariableSizedCell&lt;JSFixedArray&gt;(</span>
<span class="line-modified">!                 m_out.constIntPtr(JSFixedArray::allocationSize(immutableButterfly-&gt;length()).unsafeGet()),</span>
<span class="line-modified">!                 m_graph.m_vm.fixedArrayStructure.get(), slowAllocation);</span>
<span class="line-modified">!             m_out.store32(m_out.constInt32(immutableButterfly-&gt;length()), fastFixedArrayValue, m_heaps.JSFixedArray_size);</span>
<span class="line-modified">!             ValueFromBlock fastFixedArray = m_out.anchor(fastFixedArrayValue);</span>
              m_out.jump(continuation);
  
              LBasicBlock lastNext = m_out.appendTo(slowAllocation, continuation);
<span class="line-modified">!             ValueFromBlock slowFixedArray = m_out.anchor(vmCall(pointerType(), m_out.operation(operationCreateFixedArray), m_callFrame, m_out.constInt32(immutableButterfly-&gt;length())));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
<span class="line-modified">!             LValue fixedArray = m_out.phi(pointerType(), fastFixedArray, slowFixedArray);</span>
              for (unsigned i = 0; i &lt; immutableButterfly-&gt;length(); i++) {
                  // Because forwarded values are drained as JSValue, we should not generate value
                  // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
                  int64_t value = JSValue::encode(immutableButterfly-&gt;get(i));
                  m_out.store64(
                      m_out.constInt64(value),
<span class="line-modified">!                     m_out.baseIndex(m_heaps.JSFixedArray_buffer, fixedArray, m_out.constIntPtr(i), jsNumber(i)));</span>
              }
              mutatorFence();
<span class="line-modified">!             setJSValue(fixedArray);</span>
              return;
          }
  
          if (m_node-&gt;child1()-&gt;op() == PhantomCreateRest) {
              // This IR is rare to generate since it requires escaping the Spread
              // but not the CreateRest. In bytecode, we have only few operations that
              // accept Spread&#39;s result as input. This usually leads to the Spread node not
              // escaping. However, this can happen if for example we generate a PutStack on
              // the Spread but nothing escapes the CreateRest.
              LBasicBlock loopHeader = m_out.newBlock();
              LBasicBlock loopBody = m_out.newBlock();
              LBasicBlock slowAllocation = m_out.newBlock();
              LBasicBlock continuation = m_out.newBlock();
<span class="line-removed">-             LBasicBlock lastNext = m_out.insertNewBlocksBefore(loopHeader);</span>
  
              InlineCallFrame* inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();
              unsigned numberOfArgumentsToSkip = m_node-&gt;child1()-&gt;numberOfArgumentsToSkip();
              LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
              LValue length = getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
              static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;Assumed in the code below.&quot;);
              LValue size = m_out.add(
                  m_out.shl(m_out.zeroExtPtr(length), m_out.constInt32(3)),
<span class="line-modified">!                 m_out.constIntPtr(JSFixedArray::offsetOfData()));</span>
<span class="line-modified">! </span>
<span class="line-modified">!             LValue fastArrayValue = allocateVariableSizedCell&lt;JSFixedArray&gt;(size, m_graph.m_vm.fixedArrayStructure.get(), slowAllocation);</span>
<span class="line-modified">!             m_out.store32(length, fastArrayValue, m_heaps.JSFixedArray_size);</span>
              ValueFromBlock fastArray = m_out.anchor(fastArrayValue);
              m_out.jump(loopHeader);
  
              m_out.appendTo(slowAllocation, loopHeader);
<span class="line-modified">!             ValueFromBlock slowArray = m_out.anchor(vmCall(pointerType(), m_out.operation(operationCreateFixedArray), m_callFrame, length));</span>
              m_out.jump(loopHeader);
  
              m_out.appendTo(loopHeader, loopBody);
<span class="line-modified">!             LValue fixedArray = m_out.phi(pointerType(), fastArray, slowArray);</span>
              ValueFromBlock startIndex = m_out.anchor(m_out.constIntPtr(0));
              m_out.branch(m_out.isZero32(length), unsure(continuation), unsure(loopBody));
  
              m_out.appendTo(loopBody, continuation);
              LValue index = m_out.phi(pointerType(), startIndex);
              LValue value = m_out.load64(
                  m_out.baseIndex(m_heaps.variables, sourceStart, index));
<span class="line-modified">!             m_out.store64(value, m_out.baseIndex(m_heaps.JSFixedArray_buffer, fixedArray, index));</span>
              LValue nextIndex = m_out.add(m_out.constIntPtr(1), index);
              m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
              m_out.branch(m_out.below(nextIndex, m_out.zeroExtPtr(length)), unsure(loopBody), unsure(continuation));
  
              m_out.appendTo(continuation, lastNext);
              mutatorFence();
<span class="line-modified">!             setJSValue(fixedArray);</span>
              return;
          }
  
          LValue argument = lowCell(m_node-&gt;child1());
  
<span class="line-new-header">--- 6600,275 ---</span>
                  value = lowJSValue(use);
              m_out.store64(value, m_out.absolute(&amp;buffer[i]));
          }
  
          m_out.storePtr(m_out.constIntPtr(scratchSize), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
<span class="line-modified">!         LValue result = vmCall(Int64, operationNewArrayWithSpreadSlow, weakPointer(globalObject), m_out.constIntPtr(buffer), m_out.constInt32(m_node-&gt;numChildren()));</span>
          m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
  
          setJSValue(result);
      }
  
      void compileCreateThis()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue callee = lowCell(m_node-&gt;child1());
  
          LBasicBlock isFunctionBlock = m_out.newBlock();
          LBasicBlock hasRareData = m_out.newBlock();
          LBasicBlock slowPath = m_out.newBlock();
          LBasicBlock continuation = m_out.newBlock();
  
          m_out.branch(isFunction(callee, provenType(m_node-&gt;child1())), usually(isFunctionBlock), rarely(slowPath));
  
          LBasicBlock lastNext = m_out.appendTo(isFunctionBlock, hasRareData);
<span class="line-modified">!         LValue rareDataTags = m_out.loadPtr(callee, m_heaps.JSFunction_executableOrRareData);</span>
<span class="line-modified">!         m_out.branch(m_out.testIsZeroPtr(rareDataTags, m_out.constIntPtr(JSFunction::rareDataTag)), rarely(slowPath), usually(hasRareData));</span>
  
          m_out.appendTo(hasRareData, slowPath);
<span class="line-added">+         LValue rareData = m_out.sub(rareDataTags, m_out.constIntPtr(JSFunction::rareDataTag));</span>
          LValue allocator = m_out.loadPtr(rareData, m_heaps.FunctionRareData_allocator);
          LValue structure = m_out.loadPtr(rareData, m_heaps.FunctionRareData_structure);
          LValue butterfly = m_out.constIntPtr(0);
          ValueFromBlock fastResult = m_out.anchor(allocateObject(allocator, structure, butterfly, slowPath));
          m_out.jump(continuation);
  
          m_out.appendTo(slowPath, continuation);
          ValueFromBlock slowResult = m_out.anchor(vmCall(
<span class="line-modified">!             Int64, operationCreateThis, weakPointer(globalObject), callee, m_out.constInt32(m_node-&gt;inlineCapacity())));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          LValue result = m_out.phi(Int64, fastResult, slowResult);
  
          mutatorFence();
          setJSValue(result);
      }
  
<span class="line-added">+     void compileCreatePromise()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added">+ </span>
<span class="line-added">+         LValue callee = lowCell(m_node-&gt;child1());</span>
<span class="line-added">+ </span>
<span class="line-added">+         LBasicBlock derivedCase = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock isFunctionBlock = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock hasRareData = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock hasStructure = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock checkGlobalObjectCase = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock fastAllocationCase = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock slowCase = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added">+ </span>
<span class="line-added">+         ValueFromBlock promiseStructure = m_out.anchor(weakStructure(m_graph.registerStructure(m_node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseStructure() : globalObject-&gt;promiseStructure())));</span>
<span class="line-added">+         m_out.branch(m_out.equal(callee, weakPointer(m_node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseConstructor() : globalObject-&gt;promiseConstructor())), unsure(fastAllocationCase), unsure(derivedCase));</span>
<span class="line-added">+ </span>
<span class="line-added">+         LBasicBlock lastNext = m_out.appendTo(derivedCase, isFunctionBlock);</span>
<span class="line-added">+         m_out.branch(isFunction(callee, provenType(m_node-&gt;child1())), usually(isFunctionBlock), rarely(slowCase));</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(isFunctionBlock, hasRareData);</span>
<span class="line-added">+         LValue rareDataTags = m_out.loadPtr(callee, m_heaps.JSFunction_executableOrRareData);</span>
<span class="line-added">+         m_out.branch(m_out.testIsZeroPtr(rareDataTags, m_out.constIntPtr(JSFunction::rareDataTag)), rarely(slowCase), usually(hasRareData));</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(hasRareData, hasStructure);</span>
<span class="line-added">+         LValue rareData = m_out.sub(rareDataTags, m_out.constIntPtr(JSFunction::rareDataTag));</span>
<span class="line-added">+         LValue structure = m_out.loadPtr(rareData, m_heaps.FunctionRareData_internalFunctionAllocationProfile_structure);</span>
<span class="line-added">+         m_out.branch(m_out.isZero64(structure), rarely(slowCase), usually(hasStructure));</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(hasStructure, checkGlobalObjectCase);</span>
<span class="line-added">+         m_out.branch(m_out.equal(m_out.loadPtr(structure, m_heaps.Structure_classInfo), m_out.constIntPtr(m_node-&gt;isInternalPromise() ? JSInternalPromise::info() : JSPromise::info())), usually(checkGlobalObjectCase), rarely(slowCase));</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(checkGlobalObjectCase, fastAllocationCase);</span>
<span class="line-added">+         ValueFromBlock derivedStructure = m_out.anchor(structure);</span>
<span class="line-added">+         m_out.branch(m_out.equal(m_out.loadPtr(structure, m_heaps.Structure_globalObject), weakPointer(globalObject)), usually(fastAllocationCase), rarely(slowCase));</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(fastAllocationCase, slowCase);</span>
<span class="line-added">+         LValue promise;</span>
<span class="line-added">+         if (m_node-&gt;isInternalPromise())</span>
<span class="line-added">+             promise = allocateObject&lt;JSInternalPromise&gt;(m_out.phi(pointerType(), promiseStructure, derivedStructure), m_out.intPtrZero, slowCase);</span>
<span class="line-added">+         else</span>
<span class="line-added">+             promise = allocateObject&lt;JSPromise&gt;(m_out.phi(pointerType(), promiseStructure, derivedStructure), m_out.intPtrZero, slowCase);</span>
<span class="line-added">+         m_out.store64(m_out.constInt64(JSValue::encode(jsNumber(static_cast&lt;unsigned&gt;(JSPromise::Status::Pending)))), promise, m_heaps.JSInternalFieldObjectImpl_internalFields[static_cast&lt;unsigned&gt;(JSPromise::Field::Flags)]);</span>
<span class="line-added">+         m_out.store64(m_out.constInt64(JSValue::encode(jsUndefined())), promise, m_heaps.JSInternalFieldObjectImpl_internalFields[static_cast&lt;unsigned&gt;(JSPromise::Field::ReactionsOrResult)]);</span>
<span class="line-added">+         mutatorFence();</span>
<span class="line-added">+         ValueFromBlock fastResult = m_out.anchor(promise);</span>
<span class="line-added">+         m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(slowCase, continuation);</span>
<span class="line-added">+         ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, m_node-&gt;isInternalPromise() ? operationCreateInternalPromise : operationCreatePromise, weakPointer(globalObject), callee));</span>
<span class="line-added">+         m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(continuation, lastNext);</span>
<span class="line-added">+         LValue result = m_out.phi(Int64, fastResult, slowResult);</span>
<span class="line-added">+ </span>
<span class="line-added">+         setJSValue(result);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     template&lt;typename JSClass, typename Operation&gt;</span>
<span class="line-added">+     void compileCreateInternalFieldObject(Operation operation)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added">+ </span>
<span class="line-added">+         LValue callee = lowCell(m_node-&gt;child1());</span>
<span class="line-added">+ </span>
<span class="line-added">+         LBasicBlock isFunctionBlock = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock hasRareData = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock hasStructure = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock checkGlobalObjectCase = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock fastAllocationCase = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock slowCase = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.branch(isFunction(callee, provenType(m_node-&gt;child1())), usually(isFunctionBlock), rarely(slowCase));</span>
<span class="line-added">+ </span>
<span class="line-added">+         LBasicBlock lastNext = m_out.appendTo(isFunctionBlock, hasRareData);</span>
<span class="line-added">+         LValue rareDataTags = m_out.loadPtr(callee, m_heaps.JSFunction_executableOrRareData);</span>
<span class="line-added">+         m_out.branch(m_out.testIsZeroPtr(rareDataTags, m_out.constIntPtr(JSFunction::rareDataTag)), rarely(slowCase), usually(hasRareData));</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(hasRareData, hasStructure);</span>
<span class="line-added">+         LValue rareData = m_out.sub(rareDataTags, m_out.constIntPtr(JSFunction::rareDataTag));</span>
<span class="line-added">+         LValue structure = m_out.loadPtr(rareData, m_heaps.FunctionRareData_internalFunctionAllocationProfile_structure);</span>
<span class="line-added">+         m_out.branch(m_out.isZero64(structure), rarely(slowCase), usually(hasStructure));</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(hasStructure, checkGlobalObjectCase);</span>
<span class="line-added">+         m_out.branch(m_out.equal(m_out.loadPtr(structure, m_heaps.Structure_classInfo), m_out.constIntPtr(JSClass::info())), usually(checkGlobalObjectCase), rarely(slowCase));</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(checkGlobalObjectCase, fastAllocationCase);</span>
<span class="line-added">+         m_out.branch(m_out.equal(m_out.loadPtr(structure, m_heaps.Structure_globalObject), weakPointer(globalObject)), usually(fastAllocationCase), rarely(slowCase));</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(fastAllocationCase, slowCase);</span>
<span class="line-added">+         LValue object = allocateObject&lt;JSClass&gt;(structure, m_out.intPtrZero, slowCase);</span>
<span class="line-added">+         auto initialValues = JSClass::initialValues();</span>
<span class="line-added">+         static_assert(initialValues.size() == JSClass::numberOfInternalFields, &quot;We don&#39;t support non-constant fields in create yet.&quot;);</span>
<span class="line-added">+         for (unsigned index = 0; index &lt; initialValues.size(); ++index)</span>
<span class="line-added">+             m_out.store64(m_out.constInt64(JSValue::encode(initialValues[index])), object, m_heaps.JSInternalFieldObjectImpl_internalFields[index]);</span>
<span class="line-added">+         mutatorFence();</span>
<span class="line-added">+         ValueFromBlock fastResult = m_out.anchor(object);</span>
<span class="line-added">+         m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(slowCase, continuation);</span>
<span class="line-added">+         ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operation, weakPointer(globalObject), callee));</span>
<span class="line-added">+         m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(continuation, lastNext);</span>
<span class="line-added">+         LValue result = m_out.phi(Int64, fastResult, slowResult);</span>
<span class="line-added">+ </span>
<span class="line-added">+         setJSValue(result);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void compileCreateGenerator()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         compileCreateInternalFieldObject&lt;JSGenerator&gt;(operationCreateGenerator);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void compileCreateAsyncGenerator()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         compileCreateInternalFieldObject&lt;JSAsyncGenerator&gt;(operationCreateAsyncGenerator);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void compileSpread()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {
<span class="line-added">+             ASSERT(m_graph.isWatchingHavingABadTimeWatchpoint(m_node-&gt;child1().node()));</span>
<span class="line-added">+ </span>
<span class="line-added">+             // FIXME: JSImmutableButterfly::createFromArray should support re-using non contiguous indexing types as well.</span>
<span class="line-added">+             auto* immutableButterfly = m_node-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;();</span>
<span class="line-added">+             if (hasContiguous(immutableButterfly-&gt;indexingType())) {</span>
<span class="line-added">+                 setJSValue(frozenPointer(m_node-&gt;child1()-&gt;cellOperand()));</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              LBasicBlock slowAllocation = m_out.newBlock();
              LBasicBlock continuation = m_out.newBlock();
  
<span class="line-modified">!             ASSERT(immutableButterfly-&gt;length() &lt;= MAX_STORAGE_VECTOR_LENGTH);</span>
  
<span class="line-modified">!             LValue fastImmutableButterflyValue = allocateVariableSizedCell&lt;JSImmutableButterfly&gt;(</span>
<span class="line-modified">!                 m_out.constIntPtr(JSImmutableButterfly::allocationSize(immutableButterfly-&gt;length()).unsafeGet()),</span>
<span class="line-modified">!                 m_graph.m_vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get(), slowAllocation);</span>
<span class="line-modified">!             LValue fastImmutableButterflyStorage = toButterfly(fastImmutableButterflyValue);</span>
<span class="line-modified">!             m_out.store32(m_out.constInt32(immutableButterfly-&gt;length()), fastImmutableButterflyStorage, m_heaps.Butterfly_publicLength);</span>
<span class="line-added">+             m_out.store32(m_out.constInt32(immutableButterfly-&gt;length()), fastImmutableButterflyStorage, m_heaps.Butterfly_vectorLength);</span>
<span class="line-added">+             ValueFromBlock fastImmutableButterfly = m_out.anchor(fastImmutableButterflyValue);</span>
              m_out.jump(continuation);
  
              LBasicBlock lastNext = m_out.appendTo(slowAllocation, continuation);
<span class="line-modified">!             ValueFromBlock slowImmutableButterfly = m_out.anchor(vmCall(pointerType(), operationCreateImmutableButterfly, weakPointer(globalObject), m_out.constInt32(immutableButterfly-&gt;length())));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
<span class="line-modified">!             LValue immutableButterflyValue = m_out.phi(pointerType(), fastImmutableButterfly, slowImmutableButterfly);</span>
<span class="line-added">+             LValue immutableButterflyStorage = toButterfly(immutableButterflyValue);</span>
              for (unsigned i = 0; i &lt; immutableButterfly-&gt;length(); i++) {
                  // Because forwarded values are drained as JSValue, we should not generate value
                  // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
                  int64_t value = JSValue::encode(immutableButterfly-&gt;get(i));
                  m_out.store64(
                      m_out.constInt64(value),
<span class="line-modified">!                     m_out.baseIndex(m_heaps.indexedContiguousProperties, immutableButterflyStorage, m_out.constIntPtr(i), jsNumber(i)));</span>
              }
              mutatorFence();
<span class="line-modified">!             setJSValue(immutableButterflyValue);</span>
              return;
          }
  
          if (m_node-&gt;child1()-&gt;op() == PhantomCreateRest) {
              // This IR is rare to generate since it requires escaping the Spread
              // but not the CreateRest. In bytecode, we have only few operations that
              // accept Spread&#39;s result as input. This usually leads to the Spread node not
              // escaping. However, this can happen if for example we generate a PutStack on
              // the Spread but nothing escapes the CreateRest.
<span class="line-added">+ </span>
<span class="line-added">+             ASSERT(m_graph.isWatchingHavingABadTimeWatchpoint(m_node-&gt;child1().node()));</span>
<span class="line-added">+ </span>
<span class="line-added">+             LBasicBlock fastAllocation = m_out.newBlock();</span>
              LBasicBlock loopHeader = m_out.newBlock();
              LBasicBlock loopBody = m_out.newBlock();
              LBasicBlock slowAllocation = m_out.newBlock();
              LBasicBlock continuation = m_out.newBlock();
  
              InlineCallFrame* inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();
              unsigned numberOfArgumentsToSkip = m_node-&gt;child1()-&gt;numberOfArgumentsToSkip();
              LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
              LValue length = getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
              static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;Assumed in the code below.&quot;);
              LValue size = m_out.add(
                  m_out.shl(m_out.zeroExtPtr(length), m_out.constInt32(3)),
<span class="line-modified">!                 m_out.constIntPtr(JSImmutableButterfly::offsetOfData()));</span>
<span class="line-modified">!             m_out.branch(m_out.above(length, m_out.constInt32(MAX_STORAGE_VECTOR_LENGTH)), rarely(slowAllocation), usually(fastAllocation));</span>
<span class="line-modified">! </span>
<span class="line-modified">!             LBasicBlock lastNext = m_out.appendTo(fastAllocation, slowAllocation);</span>
<span class="line-added">+             LValue fastArrayValue = allocateVariableSizedCell&lt;JSImmutableButterfly&gt;(size, m_graph.m_vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get(), slowAllocation);</span>
<span class="line-added">+             LValue fastArrayStorage = toButterfly(fastArrayValue);</span>
<span class="line-added">+             m_out.store32(length, fastArrayStorage, m_heaps.Butterfly_vectorLength);</span>
<span class="line-added">+             m_out.store32(length, fastArrayStorage, m_heaps.Butterfly_publicLength);</span>
              ValueFromBlock fastArray = m_out.anchor(fastArrayValue);
              m_out.jump(loopHeader);
  
              m_out.appendTo(slowAllocation, loopHeader);
<span class="line-modified">!             ValueFromBlock slowArray = m_out.anchor(vmCall(pointerType(), operationCreateImmutableButterfly, weakPointer(globalObject), length));</span>
              m_out.jump(loopHeader);
  
              m_out.appendTo(loopHeader, loopBody);
<span class="line-modified">!             LValue immutableButterfly = m_out.phi(pointerType(), fastArray, slowArray);</span>
<span class="line-added">+             LValue immutableButterflyStorage = toButterfly(immutableButterfly);</span>
              ValueFromBlock startIndex = m_out.anchor(m_out.constIntPtr(0));
              m_out.branch(m_out.isZero32(length), unsure(continuation), unsure(loopBody));
  
              m_out.appendTo(loopBody, continuation);
              LValue index = m_out.phi(pointerType(), startIndex);
              LValue value = m_out.load64(
                  m_out.baseIndex(m_heaps.variables, sourceStart, index));
<span class="line-modified">!             m_out.store64(value, m_out.baseIndex(m_heaps.indexedContiguousProperties, immutableButterflyStorage, index));</span>
              LValue nextIndex = m_out.add(m_out.constIntPtr(1), index);
              m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
              m_out.branch(m_out.below(nextIndex, m_out.zeroExtPtr(length)), unsure(loopBody), unsure(continuation));
  
              m_out.appendTo(continuation, lastNext);
              mutatorFence();
<span class="line-modified">!             setJSValue(immutableButterfly);</span>
              return;
          }
  
          LValue argument = lowCell(m_node-&gt;child1());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6337,36 ***</span>
  
          if (m_node-&gt;child1().useKind() == ArrayUse)
              speculateArray(m_node-&gt;child1());
  
          if (m_graph.canDoFastSpread(m_node, m_state.forNode(m_node-&gt;child1()))) {
              LBasicBlock preLoop = m_out.newBlock();
              LBasicBlock loopSelection = m_out.newBlock();
              LBasicBlock contiguousLoopStart = m_out.newBlock();
              LBasicBlock doubleLoopStart = m_out.newBlock();
              LBasicBlock slowPath = m_out.newBlock();
              LBasicBlock continuation = m_out.newBlock();
  
<span class="line-modified">!             LValue indexingShape = m_out.load8ZeroExt32(argument, m_heaps.JSCell_indexingTypeAndMisc);</span>
<span class="line-modified">!             indexingShape = m_out.bitAnd(indexingShape, m_out.constInt32(IndexingShapeMask));</span>
              LValue isOKIndexingType = m_out.belowOrEqual(
                  m_out.sub(indexingShape, m_out.constInt32(Int32Shape)),
                  m_out.constInt32(ContiguousShape - Int32Shape));
  
<span class="line-modified">!             m_out.branch(isOKIndexingType, unsure(preLoop), unsure(slowPath));</span>
<span class="line-modified">!             LBasicBlock lastNext = m_out.appendTo(preLoop, loopSelection);</span>
<span class="line-removed">- </span>
              LValue butterfly = m_out.loadPtr(argument, m_heaps.JSObject_butterfly);
              LValue length = m_out.load32NonNegative(butterfly, m_heaps.Butterfly_publicLength);
              static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;Assumed in the code below.&quot;);
              LValue size = m_out.add(
                  m_out.shl(m_out.zeroExtPtr(length), m_out.constInt32(3)),
<span class="line-modified">!                 m_out.constIntPtr(JSFixedArray::offsetOfData()));</span>
<span class="line-modified">! </span>
<span class="line-modified">!             LValue fastAllocation = allocateVariableSizedCell&lt;JSFixedArray&gt;(size, m_graph.m_vm.fixedArrayStructure.get(), slowPath);</span>
              ValueFromBlock fastResult = m_out.anchor(fastAllocation);
<span class="line-removed">-             m_out.store32(length, fastAllocation, m_heaps.JSFixedArray_size);</span>
  
              ValueFromBlock startIndexForContiguous = m_out.anchor(m_out.constIntPtr(0));
              ValueFromBlock startIndexForDouble = m_out.anchor(m_out.constIntPtr(0));
  
              m_out.branch(m_out.isZero32(length), unsure(continuation), unsure(loopSelection));
<span class="line-new-header">--- 6876,49 ---</span>
  
          if (m_node-&gt;child1().useKind() == ArrayUse)
              speculateArray(m_node-&gt;child1());
  
          if (m_graph.canDoFastSpread(m_node, m_state.forNode(m_node-&gt;child1()))) {
<span class="line-added">+             LBasicBlock copyOnWriteContiguousCheck = m_out.newBlock();</span>
<span class="line-added">+             LBasicBlock copyOnWritePropagation = m_out.newBlock();</span>
              LBasicBlock preLoop = m_out.newBlock();
              LBasicBlock loopSelection = m_out.newBlock();
              LBasicBlock contiguousLoopStart = m_out.newBlock();
              LBasicBlock doubleLoopStart = m_out.newBlock();
<span class="line-added">+             LBasicBlock fastPath = m_out.newBlock();</span>
              LBasicBlock slowPath = m_out.newBlock();
              LBasicBlock continuation = m_out.newBlock();
  
<span class="line-modified">!             LValue indexingMode = m_out.load8ZeroExt32(argument, m_heaps.JSCell_indexingTypeAndMisc);</span>
<span class="line-modified">!             LValue indexingShape = m_out.bitAnd(indexingMode, m_out.constInt32(IndexingShapeMask));</span>
              LValue isOKIndexingType = m_out.belowOrEqual(
                  m_out.sub(indexingShape, m_out.constInt32(Int32Shape)),
                  m_out.constInt32(ContiguousShape - Int32Shape));
  
<span class="line-modified">!             m_out.branch(isOKIndexingType, unsure(copyOnWriteContiguousCheck), unsure(slowPath));</span>
<span class="line-modified">!             LBasicBlock lastNext = m_out.appendTo(copyOnWriteContiguousCheck, copyOnWritePropagation);</span>
              LValue butterfly = m_out.loadPtr(argument, m_heaps.JSObject_butterfly);
<span class="line-added">+             m_out.branch(m_out.equal(m_out.bitAnd(indexingMode, m_out.constInt32(IndexingModeMask)), m_out.constInt32(CopyOnWriteArrayWithContiguous)), unsure(copyOnWritePropagation), unsure(preLoop));</span>
<span class="line-added">+ </span>
<span class="line-added">+             m_out.appendTo(copyOnWritePropagation, preLoop);</span>
<span class="line-added">+             ValueFromBlock sharedResult = m_out.anchor(m_out.add(butterfly, m_out.constIntPtr(-JSImmutableButterfly::offsetOfData())));</span>
<span class="line-added">+             m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+             m_out.appendTo(preLoop, fastPath);</span>
              LValue length = m_out.load32NonNegative(butterfly, m_heaps.Butterfly_publicLength);
              static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;Assumed in the code below.&quot;);
              LValue size = m_out.add(
                  m_out.shl(m_out.zeroExtPtr(length), m_out.constInt32(3)),
<span class="line-modified">!                 m_out.constIntPtr(JSImmutableButterfly::offsetOfData()));</span>
<span class="line-modified">!             m_out.branch(m_out.above(length, m_out.constInt32(MAX_STORAGE_VECTOR_LENGTH)), rarely(slowPath), usually(fastPath));</span>
<span class="line-modified">! </span>
<span class="line-added">+             m_out.appendTo(fastPath, loopSelection);</span>
<span class="line-added">+             LValue fastAllocation = allocateVariableSizedCell&lt;JSImmutableButterfly&gt;(size, m_graph.m_vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get(), slowPath);</span>
<span class="line-added">+             LValue fastStorage = toButterfly(fastAllocation);</span>
<span class="line-added">+             m_out.store32(length, fastStorage, m_heaps.Butterfly_vectorLength);</span>
<span class="line-added">+             m_out.store32(length, fastStorage, m_heaps.Butterfly_publicLength);</span>
              ValueFromBlock fastResult = m_out.anchor(fastAllocation);
  
              ValueFromBlock startIndexForContiguous = m_out.anchor(m_out.constIntPtr(0));
              ValueFromBlock startIndexForDouble = m_out.anchor(m_out.constIntPtr(0));
  
              m_out.branch(m_out.isZero32(length), unsure(continuation), unsure(loopSelection));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6380,11 ***</span>
                  LValue index = m_out.phi(pointerType(), startIndexForContiguous);
  
                  TypedPointer loadSite = m_out.baseIndex(m_heaps.root, butterfly, index, ScaleEight); // We read TOP here since we can be reading either int32 or contiguous properties.
                  LValue value = m_out.load64(loadSite);
                  value = m_out.select(m_out.isZero64(value), m_out.constInt64(JSValue::encode(jsUndefined())), value);
<span class="line-modified">!                 m_out.store64(value, m_out.baseIndex(m_heaps.JSFixedArray_buffer, fastAllocation, index));</span>
  
                  LValue nextIndex = m_out.add(index, m_out.constIntPtr(1));
                  m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
  
                  m_out.branch(m_out.below(nextIndex, m_out.zeroExtPtr(length)),
<span class="line-new-header">--- 6932,11 ---</span>
                  LValue index = m_out.phi(pointerType(), startIndexForContiguous);
  
                  TypedPointer loadSite = m_out.baseIndex(m_heaps.root, butterfly, index, ScaleEight); // We read TOP here since we can be reading either int32 or contiguous properties.
                  LValue value = m_out.load64(loadSite);
                  value = m_out.select(m_out.isZero64(value), m_out.constInt64(JSValue::encode(jsUndefined())), value);
<span class="line-modified">!                 m_out.store64(value, m_out.baseIndex(m_heaps.indexedContiguousProperties, fastStorage, index));</span>
  
                  LValue nextIndex = m_out.add(index, m_out.constIntPtr(1));
                  m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
  
                  m_out.branch(m_out.below(nextIndex, m_out.zeroExtPtr(length)),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6398,28 ***</span>
                  LValue value = m_out.loadDouble(m_out.baseIndex(m_heaps.indexedDoubleProperties, butterfly, index));
                  LValue isNaN = m_out.doubleNotEqualOrUnordered(value, value);
                  LValue holeResult = m_out.constInt64(JSValue::encode(jsUndefined()));
                  LValue normalResult = boxDouble(value);
                  value = m_out.select(isNaN, holeResult, normalResult);
<span class="line-modified">!                 m_out.store64(value, m_out.baseIndex(m_heaps.JSFixedArray_buffer, fastAllocation, index));</span>
  
                  LValue nextIndex = m_out.add(index, m_out.constIntPtr(1));
                  m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
  
                  m_out.branch(m_out.below(nextIndex, m_out.zeroExtPtr(length)),
                      unsure(doubleLoopStart), unsure(continuation));
              }
  
              m_out.appendTo(slowPath, continuation);
<span class="line-modified">!             ValueFromBlock slowResult = m_out.anchor(vmCall(pointerType(), m_out.operation(operationSpreadFastArray), m_callFrame, argument));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
<span class="line-modified">!             result = m_out.phi(pointerType(), fastResult, slowResult);</span>
              mutatorFence();
          } else
<span class="line-modified">!             result = vmCall(pointerType(), m_out.operation(operationSpreadGeneric), m_callFrame, argument);</span>
  
          setJSValue(result);
      }
  
      void compileNewArrayBuffer()
<span class="line-new-header">--- 6950,28 ---</span>
                  LValue value = m_out.loadDouble(m_out.baseIndex(m_heaps.indexedDoubleProperties, butterfly, index));
                  LValue isNaN = m_out.doubleNotEqualOrUnordered(value, value);
                  LValue holeResult = m_out.constInt64(JSValue::encode(jsUndefined()));
                  LValue normalResult = boxDouble(value);
                  value = m_out.select(isNaN, holeResult, normalResult);
<span class="line-modified">!                 m_out.store64(value, m_out.baseIndex(m_heaps.indexedContiguousProperties, fastStorage, index));</span>
  
                  LValue nextIndex = m_out.add(index, m_out.constIntPtr(1));
                  m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
  
                  m_out.branch(m_out.below(nextIndex, m_out.zeroExtPtr(length)),
                      unsure(doubleLoopStart), unsure(continuation));
              }
  
              m_out.appendTo(slowPath, continuation);
<span class="line-modified">!             ValueFromBlock slowResult = m_out.anchor(vmCall(pointerType(), operationSpreadFastArray, weakPointer(globalObject), argument));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
<span class="line-modified">!             result = m_out.phi(pointerType(), sharedResult, fastResult, slowResult);</span>
              mutatorFence();
          } else
<span class="line-modified">!             result = vmCall(pointerType(), operationSpreadGeneric, weakPointer(globalObject), argument);</span>
  
          setJSValue(result);
      }
  
      void compileNewArrayBuffer()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6436,11 ***</span>
              LValue fastArray = allocateObject&lt;JSArray&gt;(structure, m_out.constIntPtr(immutableButterfly-&gt;toButterfly()), slowPath);
              ValueFromBlock fastResult = m_out.anchor(fastArray);
              m_out.jump(continuation);
  
              m_out.appendTo(slowPath, continuation);
<span class="line-modified">!             LValue slowArray = vmCall(Int64, m_out.operation(operationNewArrayBuffer), m_callFrame, weakStructure(structure), m_out.weakPointer(m_node-&gt;cellOperand()));</span>
              ValueFromBlock slowResult = m_out.anchor(slowArray);
              m_out.jump(continuation);
  
              m_out.appendTo(continuation);
  
<span class="line-new-header">--- 6988,11 ---</span>
              LValue fastArray = allocateObject&lt;JSArray&gt;(structure, m_out.constIntPtr(immutableButterfly-&gt;toButterfly()), slowPath);
              ValueFromBlock fastResult = m_out.anchor(fastArray);
              m_out.jump(continuation);
  
              m_out.appendTo(slowPath, continuation);
<span class="line-modified">!             LValue slowArray = vmCall(Int64, operationNewArrayBuffer, m_vmValue, weakStructure(structure), frozenPointer(m_node-&gt;cellOperand()));</span>
              ValueFromBlock slowResult = m_out.anchor(slowArray);
              m_out.jump(continuation);
  
              m_out.appendTo(continuation);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6448,12 ***</span>
              setJSValue(m_out.phi(pointerType(), slowResult, fastResult));
              return;
          }
  
          setJSValue(vmCall(
<span class="line-modified">!             Int64, m_out.operation(operationNewArrayBuffer), m_callFrame,</span>
<span class="line-modified">!             weakStructure(structure), m_out.weakPointer(m_node-&gt;cellOperand())));</span>
      }
  
      void compileNewArrayWithSize()
      {
          LValue publicLength = lowInt32(m_node-&gt;child1());
<span class="line-new-header">--- 7000,12 ---</span>
              setJSValue(m_out.phi(pointerType(), slowResult, fastResult));
              return;
          }
  
          setJSValue(vmCall(
<span class="line-modified">!             Int64, operationNewArrayBuffer, m_vmValue,</span>
<span class="line-modified">!             weakStructure(structure), frozenPointer(m_node-&gt;cellOperand())));</span>
      }
  
      void compileNewArrayWithSize()
      {
          LValue publicLength = lowInt32(m_node-&gt;child1());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6473,11 ***</span>
  
          LValue structureValue = m_out.select(
              m_out.aboveOrEqual(publicLength, m_out.constInt32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)),
              weakStructure(m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage))),
              weakStructure(structure));
<span class="line-modified">!         setJSValue(vmCall(Int64, m_out.operation(operationNewArrayWithSize), m_callFrame, structureValue, publicLength, m_out.intPtrZero));</span>
      }
  
      void compileNewTypedArray()
      {
          TypedArrayType typedArrayType = m_node-&gt;typedArrayType();
<span class="line-new-header">--- 7025,11 ---</span>
  
          LValue structureValue = m_out.select(
              m_out.aboveOrEqual(publicLength, m_out.constInt32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)),
              weakStructure(m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage))),
              weakStructure(structure));
<span class="line-modified">!         setJSValue(vmCall(Int64, operationNewArrayWithSize, weakPointer(globalObject), structureValue, publicLength, m_out.intPtrZero));</span>
      }
  
      void compileNewTypedArray()
      {
          TypedArrayType typedArrayType = m_node-&gt;typedArrayType();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6533,12 ***</span>
              }
  #endif
  
              ValueFromBlock haveStorage = m_out.anchor(storage);
  
<span class="line-modified">!             LValue fastResultValue =</span>
<span class="line-modified">!                 allocateObject&lt;JSArrayBufferView&gt;(structure, m_out.intPtrZero, slowCase);</span>
  
              m_out.storePtr(storage, fastResultValue, m_heaps.JSArrayBufferView_vector);
              m_out.store32(size, fastResultValue, m_heaps.JSArrayBufferView_length);
              m_out.store32(m_out.constInt32(FastTypedArray), fastResultValue, m_heaps.JSArrayBufferView_mode);
  
<span class="line-new-header">--- 7085,25 ---</span>
              }
  #endif
  
              ValueFromBlock haveStorage = m_out.anchor(storage);
  
<span class="line-modified">!             LValue fastResultValue = nullptr;</span>
<span class="line-modified">!             switch (typedArrayType) {</span>
<span class="line-added">+ #define TYPED_ARRAY_TYPE_CASE(name) \</span>
<span class="line-added">+             case Type ## name: \</span>
<span class="line-added">+                 fastResultValue = allocateObject&lt;JS##name##Array&gt;(structure, m_out.intPtrZero, slowCase); \</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             FOR_EACH_TYPED_ARRAY_TYPE_EXCLUDING_DATA_VIEW(TYPED_ARRAY_TYPE_CASE)</span>
<span class="line-added">+ #undef TYPED_ARRAY_TYPE_CASE</span>
<span class="line-added">+             case TypeDataView:</span>
<span class="line-added">+                 fastResultValue = allocateObject&lt;JSDataView&gt;(structure, m_out.intPtrZero, slowCase);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
  
              m_out.storePtr(storage, fastResultValue, m_heaps.JSArrayBufferView_vector);
              m_out.store32(size, fastResultValue, m_heaps.JSArrayBufferView_length);
              m_out.store32(m_out.constInt32(FastTypedArray), fastResultValue, m_heaps.JSArrayBufferView_mode);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6551,11 ***</span>
  
              VM&amp; vm = this-&gt;vm();
              LValue slowResultValue = lazySlowPath(
                  [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                      return createLazyCallGenerator(vm,
<span class="line-modified">!                         operationNewTypedArrayWithSizeForType(typedArrayType), locations[0].directGPR(),</span>
                          CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
                          locations[2].directGPR());
                  },
                  size, storageValue);
              ValueFromBlock slowResult = m_out.anchor(slowResultValue);
<span class="line-new-header">--- 7116,11 ---</span>
  
              VM&amp; vm = this-&gt;vm();
              LValue slowResultValue = lazySlowPath(
                  [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                      return createLazyCallGenerator(vm,
<span class="line-modified">!                         operationNewTypedArrayWithSizeForType(typedArrayType), locations[0].directGPR(), globalObject,</span>
                          CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
                          locations[2].directGPR());
                  },
                  size, storageValue);
              ValueFromBlock slowResult = m_out.anchor(slowResultValue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6568,12 ***</span>
  
          case UntypedUse: {
              LValue argument = lowJSValue(m_node-&gt;child1());
  
              LValue result = vmCall(
<span class="line-modified">!                 pointerType(), m_out.operation(operationNewTypedArrayWithOneArgumentForType(typedArrayType)),</span>
<span class="line-modified">!                 m_callFrame, weakPointer(globalObject-&gt;typedArrayStructureConcurrently(typedArrayType)), argument);</span>
  
              setJSValue(result);
              return;
          }
  
<span class="line-new-header">--- 7133,12 ---</span>
  
          case UntypedUse: {
              LValue argument = lowJSValue(m_node-&gt;child1());
  
              LValue result = vmCall(
<span class="line-modified">!                 pointerType(), operationNewTypedArrayWithOneArgumentForType(typedArrayType),</span>
<span class="line-modified">!                 weakPointer(globalObject), weakPointer(globalObject-&gt;typedArrayStructureConcurrently(typedArrayType)), argument);</span>
  
              setJSValue(result);
              return;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6605,14 ***</span>
          nukeStructureAndSetButterfly(lowStorage(m_node-&gt;child2()), lowCell(m_node-&gt;child1()));
      }
  
      void compileToNumber()
      {
          LValue value = lowJSValue(m_node-&gt;child1());
  
          if (!(abstractValue(m_node-&gt;child1()).m_type &amp; SpecBytecodeNumber))
<span class="line-modified">!             setJSValue(vmCall(Int64, m_out.operation(operationToNumber), m_callFrame, value));</span>
          else {
              LBasicBlock notNumber = m_out.newBlock();
              LBasicBlock continuation = m_out.newBlock();
  
              ValueFromBlock fastResult = m_out.anchor(value);
<span class="line-new-header">--- 7170,15 ---</span>
          nukeStructureAndSetButterfly(lowStorage(m_node-&gt;child2()), lowCell(m_node-&gt;child1()));
      }
  
      void compileToNumber()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue value = lowJSValue(m_node-&gt;child1());
  
          if (!(abstractValue(m_node-&gt;child1()).m_type &amp; SpecBytecodeNumber))
<span class="line-modified">!             setJSValue(vmCall(Int64, operationToNumber, weakPointer(globalObject), value));</span>
          else {
              LBasicBlock notNumber = m_out.newBlock();
              LBasicBlock continuation = m_out.newBlock();
  
              ValueFromBlock fastResult = m_out.anchor(value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6621,22 ***</span>
              // notNumber case.
              LBasicBlock lastNext = m_out.appendTo(notNumber, continuation);
              // We have several attempts to remove ToNumber. But ToNumber still exists.
              // It means that converting non-numbers to numbers by this ToNumber is not rare.
              // Instead of the lazy slow path generator, we call the operation here.
<span class="line-modified">!             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, m_out.operation(operationToNumber), m_callFrame, value));</span>
              m_out.jump(continuation);
  
              // continuation case.
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, fastResult, slowResult));
          }
      }
  
      void compileToStringOrCallStringConstructorOrStringValueOf()
      {
          ASSERT(m_node-&gt;op() != StringValueOf || m_node-&gt;child1().useKind() == UntypedUse);
          switch (m_node-&gt;child1().useKind()) {
          case StringObjectUse: {
              LValue cell = lowCell(m_node-&gt;child1());
              speculateStringObjectForCell(m_node-&gt;child1(), cell);
              setJSValue(m_out.loadPtr(cell, m_heaps.JSWrapperObject_internalValue));
<span class="line-new-header">--- 7187,58 ---</span>
              // notNumber case.
              LBasicBlock lastNext = m_out.appendTo(notNumber, continuation);
              // We have several attempts to remove ToNumber. But ToNumber still exists.
              // It means that converting non-numbers to numbers by this ToNumber is not rare.
              // Instead of the lazy slow path generator, we call the operation here.
<span class="line-modified">!             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operationToNumber, weakPointer(globalObject), value));</span>
              m_out.jump(continuation);
  
              // continuation case.
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, fastResult, slowResult));
          }
      }
  
<span class="line-added">+     void compileToNumeric()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added">+         LValue value = lowJSValue(m_node-&gt;child1());</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (abstractValue(m_node-&gt;child1()).m_type &amp; (SpecBytecodeNumber | SpecBigInt)) {</span>
<span class="line-added">+             LBasicBlock notNumber = m_out.newBlock();</span>
<span class="line-added">+             LBasicBlock isCellPath = m_out.newBlock();</span>
<span class="line-added">+             LBasicBlock slowPath = m_out.newBlock();</span>
<span class="line-added">+             LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added">+ </span>
<span class="line-added">+             ValueFromBlock fastResult = m_out.anchor(value);</span>
<span class="line-added">+             m_out.branch(isNumber(value, provenType(m_node-&gt;child1())), unsure(continuation), unsure(notNumber));</span>
<span class="line-added">+ </span>
<span class="line-added">+             // notNumber case.</span>
<span class="line-added">+             LBasicBlock lastNext = m_out.appendTo(notNumber, continuation);</span>
<span class="line-added">+             m_out.branch(isCell(value, provenType(m_node-&gt;child1())), unsure(isCellPath), unsure(slowPath));</span>
<span class="line-added">+ </span>
<span class="line-added">+             m_out.appendTo(isCellPath);</span>
<span class="line-added">+             m_out.branch(isBigInt(value, provenType(m_node-&gt;child1())), unsure(continuation), unsure(slowPath));</span>
<span class="line-added">+ </span>
<span class="line-added">+             m_out.appendTo(slowPath);</span>
<span class="line-added">+             // We have several attempts to remove ToNumeric. But ToNumeric still exists.</span>
<span class="line-added">+             // It means that the slow path is not rare.</span>
<span class="line-added">+             // Instead of the lazy slow path generator, we call the operation here.</span>
<span class="line-added">+             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operationToNumeric, weakPointer(globalObject), value));</span>
<span class="line-added">+             m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+             // continuation case.</span>
<span class="line-added">+             m_out.appendTo(continuation, lastNext);</span>
<span class="line-added">+             setJSValue(m_out.phi(Int64, fastResult, slowResult));</span>
<span class="line-added">+         } else</span>
<span class="line-added">+             setJSValue(vmCall(Int64, operationToNumeric, weakPointer(globalObject), value));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void compileToStringOrCallStringConstructorOrStringValueOf()
      {
          ASSERT(m_node-&gt;op() != StringValueOf || m_node-&gt;child1().useKind() == UntypedUse);
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          switch (m_node-&gt;child1().useKind()) {
          case StringObjectUse: {
              LValue cell = lowCell(m_node-&gt;child1());
              speculateStringObjectForCell(m_node-&gt;child1(), cell);
              setJSValue(m_out.loadPtr(cell, m_heaps.JSWrapperObject_internalValue));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6702,47 ***</span>
              } else
                  isStringPredicate = m_out.booleanFalse;
              m_out.branch(isStringPredicate, unsure(continuation), unsure(notString));
  
              m_out.appendTo(notString, continuation);
<span class="line-modified">!             LValue operation;</span>
              if (m_node-&gt;child1().useKind() == CellUse) {
                  ASSERT(m_node-&gt;op() != StringValueOf);
<span class="line-modified">!                 operation = m_out.operation(m_node-&gt;op() == ToString ? operationToStringOnCell : operationCallStringConstructorOnCell);</span>
              } else {
<span class="line-modified">!                 operation = m_out.operation(m_node-&gt;op() == ToString</span>
                      ? operationToString : m_node-&gt;op() == StringValueOf
<span class="line-modified">!                     ? operationStringValueOf : operationCallStringConstructor);</span>
              }
<span class="line-modified">!             ValueFromBlock convertedResult = m_out.anchor(vmCall(Int64, operation, m_callFrame, value));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, simpleResult, convertedResult));
              return;
          }
  
          case Int32Use:
<span class="line-modified">!             setJSValue(vmCall(Int64, m_out.operation(operationInt32ToStringWithValidRadix), m_callFrame, lowInt32(m_node-&gt;child1()), m_out.constInt32(10)));</span>
              return;
  
          case Int52RepUse:
<span class="line-modified">!             setJSValue(vmCall(Int64, m_out.operation(operationInt52ToStringWithValidRadix), m_callFrame, lowStrictInt52(m_node-&gt;child1()), m_out.constInt32(10)));</span>
              return;
  
          case DoubleRepUse:
<span class="line-modified">!             setJSValue(vmCall(Int64, m_out.operation(operationDoubleToStringWithValidRadix), m_callFrame, lowDouble(m_node-&gt;child1()), m_out.constInt32(10)));</span>
              return;
  
          default:
              DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
              break;
          }
      }
  
      void compileToPrimitive()
      {
          LValue value = lowJSValue(m_node-&gt;child1());
  
          LBasicBlock isCellCase = m_out.newBlock();
          LBasicBlock isObjectCase = m_out.newBlock();
          LBasicBlock continuation = m_out.newBlock();
<span class="line-new-header">--- 7304,49 ---</span>
              } else
                  isStringPredicate = m_out.booleanFalse;
              m_out.branch(isStringPredicate, unsure(continuation), unsure(notString));
  
              m_out.appendTo(notString, continuation);
<span class="line-modified">!             LValue result;</span>
              if (m_node-&gt;child1().useKind() == CellUse) {
                  ASSERT(m_node-&gt;op() != StringValueOf);
<span class="line-modified">!                 result = vmCall(Int64, m_node-&gt;op() == ToString ? operationToStringOnCell : operationCallStringConstructorOnCell, weakPointer(globalObject), value);</span>
              } else {
<span class="line-modified">!                 auto* operation = m_node-&gt;op() == ToString</span>
                      ? operationToString : m_node-&gt;op() == StringValueOf
<span class="line-modified">!                     ? operationStringValueOf : operationCallStringConstructor;</span>
<span class="line-added">+                 result = vmCall(Int64, operation, weakPointer(globalObject), value);</span>
              }
<span class="line-modified">!             ValueFromBlock convertedResult = m_out.anchor(result);</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setJSValue(m_out.phi(Int64, simpleResult, convertedResult));
              return;
          }
  
          case Int32Use:
<span class="line-modified">!             setJSValue(vmCall(Int64, operationInt32ToStringWithValidRadix, weakPointer(globalObject), lowInt32(m_node-&gt;child1()), m_out.constInt32(10)));</span>
              return;
  
          case Int52RepUse:
<span class="line-modified">!             setJSValue(vmCall(Int64, operationInt52ToStringWithValidRadix, weakPointer(globalObject), lowStrictInt52(m_node-&gt;child1()), m_out.constInt32(10)));</span>
              return;
  
          case DoubleRepUse:
<span class="line-modified">!             setJSValue(vmCall(Int64, operationDoubleToStringWithValidRadix, weakPointer(globalObject), lowDouble(m_node-&gt;child1()), m_out.constInt32(10)));</span>
              return;
  
          default:
              DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
              break;
          }
      }
  
      void compileToPrimitive()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue value = lowJSValue(m_node-&gt;child1());
  
          LBasicBlock isCellCase = m_out.newBlock();
          LBasicBlock isObjectCase = m_out.newBlock();
          LBasicBlock continuation = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6759,19 ***</span>
              isObject(value, provenType(m_node-&gt;child1())),
              unsure(isObjectCase), unsure(continuation));
  
          m_out.appendTo(isObjectCase, continuation);
          results.append(m_out.anchor(vmCall(
<span class="line-modified">!             Int64, m_out.operation(operationToPrimitive), m_callFrame, value)));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setJSValue(m_out.phi(Int64, results));
      }
  
      void compileMakeRope()
      {
          struct FlagsAndLength {
              LValue flags;
              LValue length;
          };
  
<span class="line-new-header">--- 7363,53 ---</span>
              isObject(value, provenType(m_node-&gt;child1())),
              unsure(isObjectCase), unsure(continuation));
  
          m_out.appendTo(isObjectCase, continuation);
          results.append(m_out.anchor(vmCall(
<span class="line-modified">!             Int64, operationToPrimitive, weakPointer(globalObject), value)));</span>
<span class="line-added">+         m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(continuation, lastNext);</span>
<span class="line-added">+         setJSValue(m_out.phi(Int64, results));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void compileToPropertyKey()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         ASSERT(m_node-&gt;child1().useKind() == UntypedUse);</span>
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added">+         LValue value = lowJSValue(m_node-&gt;child1());</span>
<span class="line-added">+ </span>
<span class="line-added">+         LBasicBlock isCellCase = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock notStringCase = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock slowPathCase = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added">+ </span>
<span class="line-added">+         Vector&lt;ValueFromBlock, 3&gt; results;</span>
<span class="line-added">+         m_out.branch(</span>
<span class="line-added">+             isCell(value, provenType(m_node-&gt;child1())), unsure(isCellCase), unsure(slowPathCase));</span>
<span class="line-added">+ </span>
<span class="line-added">+         LBasicBlock lastNext = m_out.appendTo(isCellCase, notStringCase);</span>
<span class="line-added">+         results.append(m_out.anchor(value));</span>
<span class="line-added">+         m_out.branch(isString(value, provenType(m_node-&gt;child1())), unsure(continuation), unsure(notStringCase));</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(notStringCase, slowPathCase);</span>
<span class="line-added">+         results.append(m_out.anchor(value));</span>
<span class="line-added">+         m_out.branch(isSymbol(value, provenType(m_node-&gt;child1())), unsure(continuation), unsure(slowPathCase));</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(slowPathCase, continuation);</span>
<span class="line-added">+         results.append(m_out.anchor(vmCall(</span>
<span class="line-added">+             Int64, operationToPropertyKey, weakPointer(globalObject), value)));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setJSValue(m_out.phi(Int64, results));
      }
  
      void compileMakeRope()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added">+ </span>
          struct FlagsAndLength {
              LValue flags;
              LValue length;
          };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6878,19 ***</span>
          switch (numKids) {
          case 2:
              slowResultValue = lazySlowPath(
                  [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                      return createLazyCallGenerator(vm,
<span class="line-modified">!                         operationMakeRope2, locations[0].directGPR(), locations[1].directGPR(),</span>
                          locations[2].directGPR());
                  }, kids[0], kids[1]);
              break;
          case 3:
              slowResultValue = lazySlowPath(
                  [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                      return createLazyCallGenerator(vm,
<span class="line-modified">!                         operationMakeRope3, locations[0].directGPR(), locations[1].directGPR(),</span>
                          locations[2].directGPR(), locations[3].directGPR());
                  }, kids[0], kids[1], kids[2]);
              break;
          default:
              DFG_CRASH(m_graph, m_node, &quot;Bad number of children&quot;);
<span class="line-new-header">--- 7516,19 ---</span>
          switch (numKids) {
          case 2:
              slowResultValue = lazySlowPath(
                  [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                      return createLazyCallGenerator(vm,
<span class="line-modified">!                         operationMakeRope2, locations[0].directGPR(), globalObject, locations[1].directGPR(),</span>
                          locations[2].directGPR());
                  }, kids[0], kids[1]);
              break;
          case 3:
              slowResultValue = lazySlowPath(
                  [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                      return createLazyCallGenerator(vm,
<span class="line-modified">!                         operationMakeRope3, locations[0].directGPR(), globalObject, locations[1].directGPR(),</span>
                          locations[2].directGPR(), locations[3].directGPR());
                  }, kids[0], kids[1], kids[2]);
              break;
          default:
              DFG_CRASH(m_graph, m_node, &quot;Bad number of children&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6955,12 ***</span>
  
          m_out.appendTo(bigCharacter, bitsContinuation);
  
          Vector&lt;ValueFromBlock, 4&gt; results;
          results.append(m_out.anchor(vmCall(
<span class="line-modified">!             Int64, m_out.operation(operationSingleCharacterString),</span>
<span class="line-modified">!             m_callFrame, char16BitValue)));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(bitsContinuation, slowPath);
  
          LValue character = m_out.phi(Int32, char8Bit, char16Bit);
<span class="line-new-header">--- 7593,12 ---</span>
  
          m_out.appendTo(bigCharacter, bitsContinuation);
  
          Vector&lt;ValueFromBlock, 4&gt; results;
          results.append(m_out.anchor(vmCall(
<span class="line-modified">!             Int64, operationSingleCharacterString,</span>
<span class="line-modified">!             m_vmValue, char16BitValue)));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(bitsContinuation, slowPath);
  
          LValue character = m_out.phi(Int32, char8Bit, char16Bit);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6975,10 ***</span>
<span class="line-new-header">--- 7613,12 ---</span>
  
          if (m_node-&gt;arrayMode().isInBounds()) {
              speculate(OutOfBounds, noValue(), 0, m_out.booleanTrue);
              results.append(m_out.anchor(m_out.intPtrZero));
          } else {
<span class="line-added">+             // FIXME: Revisit JSGlobalObject.</span>
<span class="line-added">+             // https://bugs.webkit.org/show_bug.cgi?id=203204</span>
              JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
              Structure* stringPrototypeStructure = globalObject-&gt;stringPrototype()-&gt;structure(vm());
              Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(vm());
              WTF::loadLoadFence();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6999,12 ***</span>
                      rarely(negativeIndex), usually(continuation));
  
                  m_out.appendTo(negativeIndex, continuation);
              }
  
<span class="line-modified">!             results.append(m_out.anchor(vmCall(</span>
<span class="line-removed">-                 Int64, m_out.operation(operationGetByValStringInt), m_callFrame, base, index)));</span>
          }
  
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
<span class="line-new-header">--- 7639,11 ---</span>
                      rarely(negativeIndex), usually(continuation));
  
                  m_out.appendTo(negativeIndex, continuation);
              }
  
<span class="line-modified">!             results.append(m_out.anchor(vmCall(Int64, operationGetByValStringInt, weakPointer(globalObject), base, index)));</span>
          }
  
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7055,17 ***</span>
          m_out.appendTo(continuation, lastNext);
  
          setInt32(m_out.phi(Int32, char8Bit, char16Bit));
      }
  
      void compileStringFromCharCode()
      {
          Edge childEdge = m_node-&gt;child1();
  
          if (childEdge.useKind() == UntypedUse) {
              LValue result = vmCall(
<span class="line-modified">!                 Int64, m_out.operation(operationStringFromCharCodeUntyped), m_callFrame,</span>
                  lowJSValue(childEdge));
              setJSValue(result);
              return;
          }
  
<span class="line-new-header">--- 7694,76 ---</span>
          m_out.appendTo(continuation, lastNext);
  
          setInt32(m_out.phi(Int32, char8Bit, char16Bit));
      }
  
<span class="line-added">+     void compileStringCodePointAt()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         LBasicBlock is8Bit = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock is16Bit = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock isLeadSurrogate = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock mayHaveTrailSurrogate = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock hasTrailSurrogate = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added">+ </span>
<span class="line-added">+         LValue base = lowString(m_node-&gt;child1());</span>
<span class="line-added">+         LValue index = lowInt32(m_node-&gt;child2());</span>
<span class="line-added">+         LValue storage = lowStorage(m_node-&gt;child3());</span>
<span class="line-added">+ </span>
<span class="line-added">+         LValue stringImpl = m_out.loadPtr(base, m_heaps.JSString_value);</span>
<span class="line-added">+         LValue length = m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length);</span>
<span class="line-added">+ </span>
<span class="line-added">+         speculate(Uncountable, noValue(), 0, m_out.aboveOrEqual(index, length));</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.branch(</span>
<span class="line-added">+             m_out.testIsZero32(</span>
<span class="line-added">+                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),</span>
<span class="line-added">+                 m_out.constInt32(StringImpl::flagIs8Bit())),</span>
<span class="line-added">+             unsure(is16Bit), unsure(is8Bit));</span>
<span class="line-added">+ </span>
<span class="line-added">+         LBasicBlock lastNext = m_out.appendTo(is8Bit, is16Bit);</span>
<span class="line-added">+         // FIXME: Need to cage strings!</span>
<span class="line-added">+         // https://bugs.webkit.org/show_bug.cgi?id=174924</span>
<span class="line-added">+         ValueFromBlock char8Bit = m_out.anchor(</span>
<span class="line-added">+             m_out.load8ZeroExt32(m_out.baseIndex(</span>
<span class="line-added">+                 m_heaps.characters8, storage, m_out.zeroExtPtr(index),</span>
<span class="line-added">+                 provenValue(m_node-&gt;child2()))));</span>
<span class="line-added">+         m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(is16Bit, isLeadSurrogate);</span>
<span class="line-added">+         LValue leadCharacter = m_out.load16ZeroExt32(m_out.baseIndex(m_heaps.characters16, storage, m_out.zeroExtPtr(index), provenValue(m_node-&gt;child2())));</span>
<span class="line-added">+         ValueFromBlock char16Bit = m_out.anchor(leadCharacter);</span>
<span class="line-added">+         LValue nextIndex = m_out.add(index, m_out.int32One);</span>
<span class="line-added">+         m_out.branch(m_out.aboveOrEqual(nextIndex, length), unsure(continuation), unsure(isLeadSurrogate));</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(isLeadSurrogate, mayHaveTrailSurrogate);</span>
<span class="line-added">+         m_out.branch(m_out.notEqual(m_out.bitAnd(leadCharacter, m_out.constInt32(0xfffffc00)), m_out.constInt32(0xd800)), unsure(continuation), unsure(mayHaveTrailSurrogate));</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(mayHaveTrailSurrogate, hasTrailSurrogate);</span>
<span class="line-added">+         JSValue indexValue = provenValue(m_node-&gt;child2());</span>
<span class="line-added">+         JSValue nextIndexValue;</span>
<span class="line-added">+         if (indexValue &amp;&amp; indexValue.isInt32() &amp;&amp; indexValue.asInt32() != INT32_MAX)</span>
<span class="line-added">+             nextIndexValue = jsNumber(indexValue.asInt32() + 1);</span>
<span class="line-added">+         LValue trailCharacter = m_out.load16ZeroExt32(m_out.baseIndex(m_heaps.characters16, storage, m_out.zeroExtPtr(nextIndex), nextIndexValue));</span>
<span class="line-added">+         m_out.branch(m_out.notEqual(m_out.bitAnd(trailCharacter, m_out.constInt32(0xfffffc00)), m_out.constInt32(0xdc00)), unsure(continuation), unsure(hasTrailSurrogate));</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(hasTrailSurrogate, continuation);</span>
<span class="line-added">+         ValueFromBlock charSurrogatePair = m_out.anchor(m_out.sub(m_out.add(m_out.shl(leadCharacter, m_out.constInt32(10)), trailCharacter), m_out.constInt32(U16_SURROGATE_OFFSET)));</span>
<span class="line-added">+         m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(continuation, lastNext);</span>
<span class="line-added">+         setInt32(m_out.phi(Int32, char8Bit, char16Bit, charSurrogatePair));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void compileStringFromCharCode()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          Edge childEdge = m_node-&gt;child1();
  
          if (childEdge.useKind() == UntypedUse) {
              LValue result = vmCall(
<span class="line-modified">!                 Int64, operationStringFromCharCodeUntyped, weakPointer(globalObject),</span>
                  lowJSValue(childEdge));
              setJSValue(result);
              return;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7090,11 ***</span>
          m_out.jump(continuation);
  
          m_out.appendTo(slowCase, continuation);
  
          LValue slowResultValue = vmCall(
<span class="line-modified">!             pointerType(), m_out.operation(operationStringFromCharCode), m_callFrame, value);</span>
          ValueFromBlock slowResult = m_out.anchor(slowResultValue);
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
  
<span class="line-new-header">--- 7788,11 ---</span>
          m_out.jump(continuation);
  
          m_out.appendTo(slowCase, continuation);
  
          LValue slowResultValue = vmCall(
<span class="line-modified">!             pointerType(), operationStringFromCharCode, weakPointer(globalObject), value);</span>
          ValueFromBlock slowResult = m_out.anchor(slowResultValue);
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7339,41 ***</span>
  
          VM&amp; vm = this-&gt;vm();
          lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp;) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                  return createLazyCallGenerator(vm,
<span class="line-modified">!                     operationNotifyWrite, InvalidGPRReg, CCallHelpers::TrustedImmPtr(set));</span>
              });
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
      }
  
      void compileGetCallee()
      {
<span class="line-modified">!         setJSValue(m_out.loadPtr(addressFor(CallFrameSlot::callee)));</span>
      }
  
      void compileSetCallee()
      {
          auto callee = lowCell(m_node-&gt;child1());
<span class="line-modified">!         m_out.storePtr(callee, payloadFor(CallFrameSlot::callee));</span>
      }
  
      void compileGetArgumentCountIncludingThis()
      {
          VirtualRegister argumentCountRegister;
          if (InlineCallFrame* inlineCallFrame = m_node-&gt;argumentsInlineCallFrame())
              argumentCountRegister = inlineCallFrame-&gt;argumentCountRegister;
          else
<span class="line-modified">!             argumentCountRegister = VirtualRegister(CallFrameSlot::argumentCount);</span>
          setInt32(m_out.load32(payloadFor(argumentCountRegister)));
      }
  
      void compileSetArgumentCountIncludingThis()
      {
<span class="line-modified">!         m_out.store32(m_out.constInt32(m_node-&gt;argumentCountIncludingThis()), payloadFor(CallFrameSlot::argumentCount));</span>
      }
  
      void compileGetScope()
      {
          setJSValue(m_out.loadPtr(lowCell(m_node-&gt;child1()), m_heaps.JSFunction_scope));
<span class="line-new-header">--- 8037,41 ---</span>
  
          VM&amp; vm = this-&gt;vm();
          lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp;) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                  return createLazyCallGenerator(vm,
<span class="line-modified">!                     operationNotifyWrite, InvalidGPRReg, &amp;vm, CCallHelpers::TrustedImmPtr(set));</span>
              });
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
      }
  
      void compileGetCallee()
      {
<span class="line-modified">!         setJSValue(m_out.loadPtr(addressFor(VirtualRegister(CallFrameSlot::callee))));</span>
      }
  
      void compileSetCallee()
      {
          auto callee = lowCell(m_node-&gt;child1());
<span class="line-modified">!         m_out.storePtr(callee, payloadFor(VirtualRegister(CallFrameSlot::callee)));</span>
      }
  
      void compileGetArgumentCountIncludingThis()
      {
          VirtualRegister argumentCountRegister;
          if (InlineCallFrame* inlineCallFrame = m_node-&gt;argumentsInlineCallFrame())
              argumentCountRegister = inlineCallFrame-&gt;argumentCountRegister;
          else
<span class="line-modified">!             argumentCountRegister = VirtualRegister(CallFrameSlot::argumentCountIncludingThis);</span>
          setInt32(m_out.load32(payloadFor(argumentCountRegister)));
      }
  
      void compileSetArgumentCountIncludingThis()
      {
<span class="line-modified">!         m_out.store32(m_out.constInt32(m_node-&gt;argumentCountIncludingThis()), payloadFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
      }
  
      void compileGetScope()
      {
          setJSValue(m_out.loadPtr(lowCell(m_node-&gt;child1()), m_heaps.JSFunction_scope));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7410,10 ***</span>
<span class="line-new-header">--- 8108,26 ---</span>
              lowJSValue(m_node-&gt;child2()),
              lowCell(m_node-&gt;child1()),
              m_heaps.JSLexicalEnvironment_variables[m_node-&gt;scopeOffset().offset()]);
      }
  
<span class="line-added">+     void compileGetInternalField()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         setJSValue(</span>
<span class="line-added">+             m_out.load64(</span>
<span class="line-added">+                 lowCell(m_node-&gt;child1()),</span>
<span class="line-added">+                 m_heaps.JSInternalFieldObjectImpl_internalFields[m_node-&gt;internalFieldIndex()]));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void compilePutInternalField()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         m_out.store64(</span>
<span class="line-added">+             lowJSValue(m_node-&gt;child2()),</span>
<span class="line-added">+             lowCell(m_node-&gt;child1()),</span>
<span class="line-added">+             m_heaps.JSInternalFieldObjectImpl_internalFields[m_node-&gt;internalFieldIndex()]);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void compileGetFromArguments()
      {
          setJSValue(
              m_out.load64(
                  lowCell(m_node-&gt;child1()),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7442,11 ***</span>
          VirtualRegister arg = AssemblyHelpers::argumentsStart(m_node-&gt;origin.semantic) + m_node-&gt;argumentIndex() - 1;
          ValueFromBlock inBoundsResult = m_out.anchor(m_out.load64(addressFor(arg)));
          m_out.jump(continuation);
  
          m_out.appendTo(outOfBounds, continuation);
<span class="line-modified">!         ValueFromBlock outOfBoundsResult = m_out.anchor(m_out.constInt64(ValueUndefined));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setJSValue(m_out.phi(Int64, inBoundsResult, outOfBoundsResult));
      }
<span class="line-new-header">--- 8156,11 ---</span>
          VirtualRegister arg = AssemblyHelpers::argumentsStart(m_node-&gt;origin.semantic) + m_node-&gt;argumentIndex() - 1;
          ValueFromBlock inBoundsResult = m_out.anchor(m_out.load64(addressFor(arg)));
          m_out.jump(continuation);
  
          m_out.appendTo(outOfBounds, continuation);
<span class="line-modified">!         ValueFromBlock outOfBoundsResult = m_out.anchor(m_out.constInt64(JSValue::ValueUndefined));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setJSValue(m_out.phi(Int64, inBoundsResult, outOfBoundsResult));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7495,10 ***</span>
<span class="line-new-header">--- 8209,11 ---</span>
              operationCompareEq);
      }
  
      void compileCompareStrictEq()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;isBinaryUseKind(Int32Use)) {
              setBoolean(
                  m_out.equal(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
              return;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7598,11 ***</span>
              m_out.branch(m_out.equal(left, right), rarely(continuation), usually(notTriviallyEqualCase));
  
              LBasicBlock lastNext = m_out.appendTo(notTriviallyEqualCase, continuation);
  
              ValueFromBlock slowResult = m_out.anchor(m_out.notNull(vmCall(
<span class="line-modified">!                 pointerType(), m_out.operation(operationCompareStrictEq), m_callFrame, left, right)));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setBoolean(m_out.phi(Int32, fastResult, slowResult));
              return;
<span class="line-new-header">--- 8313,11 ---</span>
              m_out.branch(m_out.equal(left, right), rarely(continuation), usually(notTriviallyEqualCase));
  
              LBasicBlock lastNext = m_out.appendTo(notTriviallyEqualCase, continuation);
  
              ValueFromBlock slowResult = m_out.anchor(m_out.notNull(vmCall(
<span class="line-modified">!                 pointerType(), operationCompareStrictEq, weakPointer(globalObject), left, right)));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setBoolean(m_out.phi(Int32, fastResult, slowResult));
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7796,10 ***</span>
<span class="line-new-header">--- 8511,11 ---</span>
          setBoolean(m_out.belowOrEqual(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
      }
  
      void compileSameValue()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;isBinaryUseKind(DoubleRepUse)) {
              LValue arg1 = lowDouble(m_node-&gt;child1());
              LValue arg2 = lowDouble(m_node-&gt;child2());
  
              LBasicBlock numberCase = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7830,11 ***</span>
              setBoolean(m_out.phi(Int32, compareResult, nanResult));
              return;
          }
  
          ASSERT(m_node-&gt;isBinaryUseKind(UntypedUse));
<span class="line-modified">!         setBoolean(vmCall(Int32, m_out.operation(operationSameValue), m_callFrame, lowJSValue(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2())));</span>
      }
  
      void compileLogicalNot()
      {
          setBoolean(m_out.logicalNot(boolify(m_node-&gt;child1())));
<span class="line-new-header">--- 8546,11 ---</span>
              setBoolean(m_out.phi(Int32, compareResult, nanResult));
              return;
          }
  
          ASSERT(m_node-&gt;isBinaryUseKind(UntypedUse));
<span class="line-modified">!         setBoolean(vmCall(Int32, operationSameValue, weakPointer(globalObject), lowJSValue(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2())));</span>
      }
  
      void compileLogicalNot()
      {
          setBoolean(m_out.logicalNot(boolify(m_node-&gt;child1())));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7873,22 ***</span>
                  (reg.offset() - CallerFrameAndPC::sizeInRegisters) * sizeof(EncodedJSValue) + offset;
              arguments.append(ConstrainedValue(value, ValueRep::stackArgument(offsetFromSP)));
          };
  
          addArgument(jsCallee, VirtualRegister(CallFrameSlot::callee), 0);
<span class="line-modified">!         addArgument(m_out.constInt32(numArgs), VirtualRegister(CallFrameSlot::argumentCount), PayloadOffset);</span>
          for (unsigned i = 0; i &lt; numArgs; ++i)
<span class="line-modified">!             addArgument(lowJSValue(m_graph.varArgChild(node, 1 + i)), virtualRegisterForArgument(i), 0);</span>
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendVector(arguments);
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
  
<span class="line-modified">!         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));</span>
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
          patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };
  
          CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
<span class="line-new-header">--- 8589,22 ---</span>
                  (reg.offset() - CallerFrameAndPC::sizeInRegisters) * sizeof(EncodedJSValue) + offset;
              arguments.append(ConstrainedValue(value, ValueRep::stackArgument(offsetFromSP)));
          };
  
          addArgument(jsCallee, VirtualRegister(CallFrameSlot::callee), 0);
<span class="line-modified">!         addArgument(m_out.constInt32(numArgs), VirtualRegister(CallFrameSlot::argumentCountIncludingThis), PayloadOffset);</span>
          for (unsigned i = 0; i &lt; numArgs; ++i)
<span class="line-modified">!             addArgument(lowJSValue(m_graph.varArgChild(node, 1 + i)), virtualRegisterForArgumentIncludingThis(i), 0);</span>
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendVector(arguments);
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
  
<span class="line-modified">!         patchpoint-&gt;append(m_notCellMask, ValueRep::reg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_numberTag, ValueRep::reg(GPRInfo::numberTagRegister));</span>
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
          patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };
  
          CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7901,11 ***</span>
  
                  exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
  
                  jit.store32(
                      CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<span class="line-modified">!                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));</span>
  
                  CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
  
                  CCallHelpers::DataLabelPtr targetToCheck;
                  CCallHelpers::Jump slowPath = jit.branchPtrWithPatch(
<span class="line-new-header">--- 8617,11 ---</span>
  
                  exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
  
                  jit.store32(
                      CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<span class="line-modified">!                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
  
                  CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
  
                  CCallHelpers::DataLabelPtr targetToCheck;
                  CCallHelpers::Jump slowPath = jit.branchPtrWithPatch(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7916,10 ***</span>
<span class="line-new-header">--- 8632,11 ---</span>
                  CCallHelpers::Jump done = jit.jump();
  
                  slowPath.link(&amp;jit);
  
                  jit.move(CCallHelpers::TrustedImmPtr(callLinkInfo), GPRInfo::regT2);
<span class="line-added">+                 jit.move(CCallHelpers::TrustedImmPtr(jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic)), GPRInfo::regT3);</span>
                  CCallHelpers::Call slowCall = jit.nearCall();
                  done.link(&amp;jit);
  
                  callLinkInfo-&gt;setUpCall(
                      node-&gt;op() == Construct ? CallLinkInfo::Construct : CallLinkInfo::Call,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7982,15 ***</span>
                      (reg.offset() - CallerFrameAndPC::sizeInRegisters) * sizeof(EncodedJSValue) + offset;
                  arguments.append(ConstrainedValue(value, ValueRep::stackArgument(offsetFromSP)));
              };
  
              addArgument(jsCallee, VirtualRegister(CallFrameSlot::callee), 0);
<span class="line-modified">!             addArgument(m_out.constInt32(numPassedArgs), VirtualRegister(CallFrameSlot::argumentCount), PayloadOffset);</span>
              for (unsigned i = 0; i &lt; numPassedArgs; ++i)
<span class="line-modified">!                 addArgument(lowJSValue(m_graph.varArgChild(node, 1 + i)), virtualRegisterForArgument(i), 0);</span>
              for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
<span class="line-modified">!                 addArgument(m_out.constInt64(JSValue::encode(jsUndefined())), virtualRegisterForArgument(i), 0);</span>
          } else {
              for (unsigned i = 0; i &lt; numPassedArgs; ++i)
                  arguments.append(ConstrainedValue(lowJSValue(m_graph.varArgChild(node, 1 + i)), ValueRep::WarmAny));
          }
  
<span class="line-new-header">--- 8699,15 ---</span>
                      (reg.offset() - CallerFrameAndPC::sizeInRegisters) * sizeof(EncodedJSValue) + offset;
                  arguments.append(ConstrainedValue(value, ValueRep::stackArgument(offsetFromSP)));
              };
  
              addArgument(jsCallee, VirtualRegister(CallFrameSlot::callee), 0);
<span class="line-modified">!             addArgument(m_out.constInt32(numPassedArgs), VirtualRegister(CallFrameSlot::argumentCountIncludingThis), PayloadOffset);</span>
              for (unsigned i = 0; i &lt; numPassedArgs; ++i)
<span class="line-modified">!                 addArgument(lowJSValue(m_graph.varArgChild(node, 1 + i)), virtualRegisterForArgumentIncludingThis(i), 0);</span>
              for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
<span class="line-modified">!                 addArgument(m_out.constInt64(JSValue::encode(jsUndefined())), virtualRegisterForArgumentIncludingThis(i), 0);</span>
          } else {
              for (unsigned i = 0; i &lt; numPassedArgs; ++i)
                  arguments.append(ConstrainedValue(lowJSValue(m_graph.varArgChild(node, 1 + i)), ValueRep::WarmAny));
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7999,12 ***</span>
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
  
          if (isTail) {
              // The shuffler needs tags.
<span class="line-modified">!             patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));</span>
<span class="line-modified">!             patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));</span>
          }
  
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          if (!isTail) {
              patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
<span class="line-new-header">--- 8716,12 ---</span>
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
  
          if (isTail) {
              // The shuffler needs tags.
<span class="line-modified">!             patchpoint-&gt;append(m_notCellMask, ValueRep::reg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">!             patchpoint-&gt;append(m_numberTag, ValueRep::reg(GPRInfo::numberTagRegister));</span>
          }
  
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          if (!isTail) {
              patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8050,11 ***</span>
                      CCallHelpers::PatchableJump patchableJump = jit.patchableJump();
                      CCallHelpers::Label mainPath = jit.label();
  
                      jit.store32(
                          CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<span class="line-modified">!                         CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));</span>
  
                      callLinkInfo-&gt;setFrameShuffleData(shuffleData);
                      CallFrameShuffler(jit, shuffleData).prepareForTailCall();
  
                      CCallHelpers::Call call = jit.nearTailCall();
<span class="line-new-header">--- 8767,11 ---</span>
                      CCallHelpers::PatchableJump patchableJump = jit.patchableJump();
                      CCallHelpers::Label mainPath = jit.label();
  
                      jit.store32(
                          CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<span class="line-modified">!                         CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
  
                      callLinkInfo-&gt;setFrameShuffleData(shuffleData);
                      CallFrameShuffler(jit, shuffleData).prepareForTailCall();
  
                      CCallHelpers::Call call = jit.nearTailCall();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8071,11 ***</span>
  
                      callLinkInfo-&gt;setUpCall(
                          CallLinkInfo::DirectTailCall, node-&gt;origin.semantic, InvalidGPRReg);
                      callLinkInfo-&gt;setExecutableDuringCompilation(executable);
                      if (numAllocatedArgs &gt; numPassedArgs)
<span class="line-modified">!                         callLinkInfo-&gt;setMaxNumArguments(numAllocatedArgs);</span>
  
                      jit.addLinkTask(
                          [=] (LinkBuffer&amp; linkBuffer) {
                              CodeLocationLabel&lt;JSInternalPtrTag&gt; patchableJumpLocation = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(patchableJump);
                              CodeLocationNearCall&lt;JSInternalPtrTag&gt; callLocation = linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(call);
<span class="line-new-header">--- 8788,11 ---</span>
  
                      callLinkInfo-&gt;setUpCall(
                          CallLinkInfo::DirectTailCall, node-&gt;origin.semantic, InvalidGPRReg);
                      callLinkInfo-&gt;setExecutableDuringCompilation(executable);
                      if (numAllocatedArgs &gt; numPassedArgs)
<span class="line-modified">!                         callLinkInfo-&gt;setMaxArgumentCountIncludingThis(numAllocatedArgs);</span>
  
                      jit.addLinkTask(
                          [=] (LinkBuffer&amp; linkBuffer) {
                              CodeLocationLabel&lt;JSInternalPtrTag&gt; patchableJumpLocation = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(patchableJump);
                              CodeLocationNearCall&lt;JSInternalPtrTag&gt; callLocation = linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(call);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8093,11 ***</span>
  
                  CCallHelpers::Label mainPath = jit.label();
  
                  jit.store32(
                      CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<span class="line-modified">!                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));</span>
  
                  CCallHelpers::Call call = jit.nearCall();
                  jit.addPtr(
                      CCallHelpers::TrustedImm32(-params.proc().frameSize()),
                      GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
<span class="line-new-header">--- 8810,11 ---</span>
  
                  CCallHelpers::Label mainPath = jit.label();
  
                  jit.store32(
                      CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<span class="line-modified">!                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
  
                  CCallHelpers::Call call = jit.nearCall();
                  jit.addPtr(
                      CCallHelpers::TrustedImm32(-params.proc().frameSize()),
                      GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8105,11 ***</span>
                  callLinkInfo-&gt;setUpCall(
                      isConstruct ? CallLinkInfo::DirectConstruct : CallLinkInfo::DirectCall,
                      node-&gt;origin.semantic, InvalidGPRReg);
                  callLinkInfo-&gt;setExecutableDuringCompilation(executable);
                  if (numAllocatedArgs &gt; numPassedArgs)
<span class="line-modified">!                     callLinkInfo-&gt;setMaxNumArguments(numAllocatedArgs);</span>
  
                  params.addLatePath(
                      [=] (CCallHelpers&amp; jit) {
                          AllowMacroScratchRegisterUsage allowScratch(jit);
  
<span class="line-new-header">--- 8822,11 ---</span>
                  callLinkInfo-&gt;setUpCall(
                      isConstruct ? CallLinkInfo::DirectConstruct : CallLinkInfo::DirectCall,
                      node-&gt;origin.semantic, InvalidGPRReg);
                  callLinkInfo-&gt;setExecutableDuringCompilation(executable);
                  if (numAllocatedArgs &gt; numPassedArgs)
<span class="line-modified">!                     callLinkInfo-&gt;setMaxArgumentCountIncludingThis(numAllocatedArgs);</span>
  
                  params.addLatePath(
                      [=] (CCallHelpers&amp; jit) {
                          AllowMacroScratchRegisterUsage allowScratch(jit);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8185,12 ***</span>
          }
  
          PatchpointValue* patchpoint = m_out.patchpoint(Void);
          patchpoint-&gt;appendVector(arguments);
  
<span class="line-modified">!         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));</span>
  
          // Prevent any of the arguments from using the scratch register.
          patchpoint-&gt;clobberEarly(RegisterSet::macroScratchRegisters());
  
          patchpoint-&gt;effects.terminal = true;
<span class="line-new-header">--- 8902,12 ---</span>
          }
  
          PatchpointValue* patchpoint = m_out.patchpoint(Void);
          patchpoint-&gt;appendVector(arguments);
  
<span class="line-modified">!         patchpoint-&gt;append(m_notCellMask, ValueRep::reg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_numberTag, ValueRep::reg(GPRInfo::numberTagRegister));</span>
  
          // Prevent any of the arguments from using the scratch register.
          patchpoint-&gt;clobberEarly(RegisterSet::macroScratchRegisters());
  
          patchpoint-&gt;effects.terminal = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8205,15 ***</span>
              [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
                  AllowMacroScratchRegisterUsage allowScratch(jit);
                  CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
  
                  // Yes, this is really necessary. You could throw an exception in a host call on the
<span class="line-modified">!                 // slow path. That&#39;ll route us to lookupExceptionHandler(), which unwinds starting</span>
                  // with the call site index of our frame. Bad things happen if it&#39;s not set.
                  jit.store32(
                      CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<span class="line-modified">!                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));</span>
  
                  CallFrameShuffleData shuffleData;
                  shuffleData.numLocals = state-&gt;jitCode-&gt;common.frameRegisterCount;
                  shuffleData.callee = ValueRecovery::inGPR(GPRInfo::regT0, DataFormatJS);
  
<span class="line-new-header">--- 8922,15 ---</span>
              [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
                  AllowMacroScratchRegisterUsage allowScratch(jit);
                  CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
  
                  // Yes, this is really necessary. You could throw an exception in a host call on the
<span class="line-modified">!                 // slow path. That&#39;ll route us to operationLookupExceptionHandler(), which unwinds starting</span>
                  // with the call site index of our frame. Bad things happen if it&#39;s not set.
                  jit.store32(
                      CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<span class="line-modified">!                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
  
                  CallFrameShuffleData shuffleData;
                  shuffleData.numLocals = state-&gt;jitCode-&gt;common.frameRegisterCount;
                  shuffleData.callee = ValueRecovery::inGPR(GPRInfo::regT0, DataFormatJS);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8241,10 ***</span>
<span class="line-new-header">--- 8958,11 ---</span>
                  CallFrameShuffler slowPathShuffler(jit, shuffleData);
                  slowPathShuffler.setCalleeJSValueRegs(JSValueRegs(GPRInfo::regT0));
                  slowPathShuffler.prepareForSlowPath();
  
                  jit.move(CCallHelpers::TrustedImmPtr(callLinkInfo), GPRInfo::regT2);
<span class="line-added">+                 jit.move(CCallHelpers::TrustedImmPtr(jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic)), GPRInfo::regT3);</span>
                  CCallHelpers::Call slowCall = jit.nearCall();
  
                  jit.abortWithReason(JITDidReturnFromTailCall);
  
                  callLinkInfo-&gt;setUpCall(CallLinkInfo::TailCall, codeOrigin, GPRInfo::regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8320,12 ***</span>
  
          patchpoint-&gt;append(jsCallee, ValueRep::reg(GPRInfo::regT0));
          patchpoint-&gt;append(thisArg, ValueRep::WarmAny);
          patchpoint-&gt;append(argumentCountIncludingThis, ValueRep::WarmAny);
          patchpoint-&gt;appendVectorWithRep(patchpointArguments, ValueRep::WarmAny);
<span class="line-modified">!         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));</span>
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
  
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;clobber(RegisterSet::volatileRegistersForJSCall()); // No inputs will be in a volatile register.
<span class="line-new-header">--- 9038,12 ---</span>
  
          patchpoint-&gt;append(jsCallee, ValueRep::reg(GPRInfo::regT0));
          patchpoint-&gt;append(thisArg, ValueRep::WarmAny);
          patchpoint-&gt;append(argumentCountIncludingThis, ValueRep::WarmAny);
          patchpoint-&gt;appendVectorWithRep(patchpointArguments, ValueRep::WarmAny);
<span class="line-modified">!         patchpoint-&gt;append(m_notCellMask, ValueRep::reg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_numberTag, ValueRep::reg(GPRInfo::numberTagRegister));</span>
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
  
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;clobber(RegisterSet::volatileRegistersForJSCall()); // No inputs will be in a volatile register.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8354,11 ***</span>
  
                  exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
  
                  jit.store32(
                      CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<span class="line-modified">!                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));</span>
  
                  CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
  
                  RegisterSet usedRegisters = RegisterSet::allRegisters();
                  usedRegisters.exclude(RegisterSet::volatileRegistersForJSCall());
<span class="line-new-header">--- 9072,11 ---</span>
  
                  exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
  
                  jit.store32(
                      CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<span class="line-modified">!                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
  
                  CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
  
                  RegisterSet usedRegisters = RegisterSet::allRegisters();
                  usedRegisters.exclude(RegisterSet::volatileRegistersForJSCall());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8418,11 ***</span>
                      jit.getEffectiveAddress(CCallHelpers::BaseIndex(GPRInfo::callFrameRegister, scratchGPR1, CCallHelpers::TimesEight), scratchGPR1);
  
                      // Before touching stack values, we should update the stack pointer to protect them from signal stack.
                      jit.addPtr(CCallHelpers::TrustedImm32(sizeof(CallerFrameAndPC)), scratchGPR1, CCallHelpers::stackPointerRegister);
  
<span class="line-modified">!                     jit.store32(scratchGPR2, CCallHelpers::Address(scratchGPR1, CallFrameSlot::argumentCount * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset));</span>
  
                      int storeOffset = CallFrame::thisArgumentOffset() * static_cast&lt;int&gt;(sizeof(Register));
  
                      unsigned paramsOffset = 4;
                      unsigned index = 0;
<span class="line-new-header">--- 9136,11 ---</span>
                      jit.getEffectiveAddress(CCallHelpers::BaseIndex(GPRInfo::callFrameRegister, scratchGPR1, CCallHelpers::TimesEight), scratchGPR1);
  
                      // Before touching stack values, we should update the stack pointer to protect them from signal stack.
                      jit.addPtr(CCallHelpers::TrustedImm32(sizeof(CallerFrameAndPC)), scratchGPR1, CCallHelpers::stackPointerRegister);
  
<span class="line-modified">!                     jit.store32(scratchGPR2, CCallHelpers::Address(scratchGPR1, CallFrameSlot::argumentCountIncludingThis * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset));</span>
  
                      int storeOffset = CallFrame::thisArgumentOffset() * static_cast&lt;int&gt;(sizeof(Register));
  
                      unsigned paramsOffset = 4;
                      unsigned index = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8487,11 ***</span>
                  }
  
                  {
                      CCallHelpers::Jump dontThrow = jit.jump();
                      slowCase.link(&amp;jit);
<span class="line-modified">!                     jit.setupArguments&lt;decltype(operationThrowStackOverflowForVarargs)&gt;();</span>
                      callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationThrowStackOverflowForVarargs));
                      jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
  
                      dontThrow.link(&amp;jit);
                  }
<span class="line-new-header">--- 9205,12 ---</span>
                  }
  
                  {
                      CCallHelpers::Jump dontThrow = jit.jump();
                      slowCase.link(&amp;jit);
<span class="line-modified">!                     jit.setupArguments&lt;decltype(operationThrowStackOverflowForVarargs)&gt;(jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic));</span>
<span class="line-added">+                     jit.prepareCallOperation(jit.vm());</span>
                      callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationThrowStackOverflowForVarargs));
                      jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
  
                      dontThrow.link(&amp;jit);
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8532,10 ***</span>
<span class="line-new-header">--- 9251,11 ---</span>
  
                  if (isTailCall)
                      jit.emitRestoreCalleeSaves();
                  ASSERT(!usedRegisters.get(GPRInfo::regT2));
                  jit.move(CCallHelpers::TrustedImmPtr(callLinkInfo), GPRInfo::regT2);
<span class="line-added">+                 jit.move(CCallHelpers::TrustedImmPtr(jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic)), GPRInfo::regT3);</span>
                  CCallHelpers::Call slowCall = jit.nearCall();
  
                  if (isTailCall)
                      jit.abortWithReason(JITDidReturnFromTailCall);
                  else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8624,12 ***</span>
          }
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
  
<span class="line-modified">!         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));</span>
  
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
          patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };
  
<span class="line-new-header">--- 9344,12 ---</span>
          }
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
  
<span class="line-modified">!         patchpoint-&gt;append(m_notCellMask, ValueRep::reg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_numberTag, ValueRep::reg(GPRInfo::numberTagRegister));</span>
  
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
          patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8654,11 ***</span>
  
                  exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
  
                  jit.store32(
                      CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<span class="line-modified">!                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));</span>
  
                  CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
                  CallVarargsData* data = node-&gt;callVarargsData();
  
                  unsigned argIndex = 1;
<span class="line-new-header">--- 9374,11 ---</span>
  
                  exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
  
                  jit.store32(
                      CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<span class="line-modified">!                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
  
                  CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
                  CallVarargsData* data = node-&gt;callVarargsData();
  
                  unsigned argIndex = 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8752,26 ***</span>
                      // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
                      emitSetupVarargsFrameFastCase(*vm, jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);
  
                      CCallHelpers::Jump done = jit.jump();
                      slowCase.link(&amp;jit);
<span class="line-modified">!                     jit.setupArguments&lt;decltype(operationThrowStackOverflowForVarargs)&gt;();</span>
                      callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationThrowStackOverflowForVarargs));
                      jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
  
                      done.link(&amp;jit);
                  } else {
                      jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR1);
<span class="line-modified">!                     jit.setupArguments&lt;decltype(operationSizeFrameForVarargs)&gt;(argumentsGPR, scratchGPR1, CCallHelpers::TrustedImm32(data-&gt;firstVarArgOffset));</span>
                      callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationSizeFrameForVarargs));
  
                      jit.move(GPRInfo::returnValueGPR, scratchGPR1);
                      jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR2);
                      argumentsLateRep.emitRestore(jit, argumentsGPR);
                      emitSetVarargsFrame(jit, scratchGPR1, false, scratchGPR2, scratchGPR2);
                      jit.addPtr(CCallHelpers::TrustedImm32(-minimumJSCallAreaSize), scratchGPR2, CCallHelpers::stackPointerRegister);
<span class="line-modified">!                     jit.setupArguments&lt;decltype(operationSetupVarargsFrame)&gt;(scratchGPR2, argumentsGPR, CCallHelpers::TrustedImm32(data-&gt;firstVarArgOffset), scratchGPR1);</span>
                      callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationSetupVarargsFrame));
  
                      jit.addPtr(CCallHelpers::TrustedImm32(sizeof(CallerFrameAndPC)), GPRInfo::returnValueGPR, CCallHelpers::stackPointerRegister);
  
                      calleeLateRep.emitRestore(jit, GPRInfo::regT0);
<span class="line-new-header">--- 9472,29 ---</span>
                      // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
                      emitSetupVarargsFrameFastCase(*vm, jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);
  
                      CCallHelpers::Jump done = jit.jump();
                      slowCase.link(&amp;jit);
<span class="line-modified">!                     jit.setupArguments&lt;decltype(operationThrowStackOverflowForVarargs)&gt;(jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic));</span>
<span class="line-added">+                     jit.prepareCallOperation(jit.vm());</span>
                      callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationThrowStackOverflowForVarargs));
                      jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
  
                      done.link(&amp;jit);
                  } else {
                      jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR1);
<span class="line-modified">!                     jit.setupArguments&lt;decltype(operationSizeFrameForVarargs)&gt;(jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic), argumentsGPR, scratchGPR1, CCallHelpers::TrustedImm32(data-&gt;firstVarArgOffset));</span>
<span class="line-added">+                     jit.prepareCallOperation(jit.vm());</span>
                      callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationSizeFrameForVarargs));
  
                      jit.move(GPRInfo::returnValueGPR, scratchGPR1);
                      jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR2);
                      argumentsLateRep.emitRestore(jit, argumentsGPR);
                      emitSetVarargsFrame(jit, scratchGPR1, false, scratchGPR2, scratchGPR2);
                      jit.addPtr(CCallHelpers::TrustedImm32(-minimumJSCallAreaSize), scratchGPR2, CCallHelpers::stackPointerRegister);
<span class="line-modified">!                     jit.setupArguments&lt;decltype(operationSetupVarargsFrame)&gt;(jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic), scratchGPR2, argumentsGPR, CCallHelpers::TrustedImm32(data-&gt;firstVarArgOffset), scratchGPR1);</span>
<span class="line-added">+                     jit.prepareCallOperation(jit.vm());</span>
                      callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationSetupVarargsFrame));
  
                      jit.addPtr(CCallHelpers::TrustedImm32(sizeof(CallerFrameAndPC)), GPRInfo::returnValueGPR, CCallHelpers::stackPointerRegister);
  
                      calleeLateRep.emitRestore(jit, GPRInfo::regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8814,10 ***</span>
<span class="line-new-header">--- 9537,11 ---</span>
                  slowPath.link(&amp;jit);
  
                  if (isTailCall)
                      jit.emitRestoreCalleeSaves();
                  jit.move(CCallHelpers::TrustedImmPtr(callLinkInfo), GPRInfo::regT2);
<span class="line-added">+                 jit.move(CCallHelpers::TrustedImmPtr(jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic)), GPRInfo::regT3);</span>
                  CCallHelpers::Call slowCall = jit.nearCall();
  
                  if (isTailCall)
                      jit.abortWithReason(JITDidReturnFromTailCall);
                  else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8873,28 ***</span>
                  (reg.offset() - CallerFrameAndPC::sizeInRegisters) * sizeof(EncodedJSValue) + offset;
              arguments.append(ConstrainedValue(value, ValueRep::stackArgument(offsetFromSP)));
          };
  
          addArgument(jsCallee, VirtualRegister(CallFrameSlot::callee), 0);
<span class="line-modified">!         addArgument(m_out.constInt32(numArgs), VirtualRegister(CallFrameSlot::argumentCount), PayloadOffset);</span>
          for (unsigned i = 0; i &lt; numArgs; ++i)
<span class="line-modified">!             addArgument(lowJSValue(m_graph.varArgChild(node, 1 + i)), virtualRegisterForArgument(i), 0);</span>
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendVector(arguments);
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
  
<span class="line-modified">!         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));</span>
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
          patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };
  
          CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
          State* state = &amp;m_ftlState;
          VM&amp; vm = this-&gt;vm();
          patchpoint-&gt;setGenerator(
              [=, &amp;vm] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
                  AllowMacroScratchRegisterUsage allowScratch(jit);
                  CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
  
<span class="line-new-header">--- 9597,29 ---</span>
                  (reg.offset() - CallerFrameAndPC::sizeInRegisters) * sizeof(EncodedJSValue) + offset;
              arguments.append(ConstrainedValue(value, ValueRep::stackArgument(offsetFromSP)));
          };
  
          addArgument(jsCallee, VirtualRegister(CallFrameSlot::callee), 0);
<span class="line-modified">!         addArgument(m_out.constInt32(numArgs), VirtualRegister(CallFrameSlot::argumentCountIncludingThis), PayloadOffset);</span>
          for (unsigned i = 0; i &lt; numArgs; ++i)
<span class="line-modified">!             addArgument(lowJSValue(m_graph.varArgChild(node, 1 + i)), virtualRegisterForArgumentIncludingThis(i), 0);</span>
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendVector(arguments);
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
  
<span class="line-modified">!         patchpoint-&gt;append(m_notCellMask, ValueRep::reg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_numberTag, ValueRep::reg(GPRInfo::numberTagRegister));</span>
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
          patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };
  
          CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
          State* state = &amp;m_ftlState;
          VM&amp; vm = this-&gt;vm();
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          patchpoint-&gt;setGenerator(
              [=, &amp;vm] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
                  AllowMacroScratchRegisterUsage allowScratch(jit);
                  CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8902,140 ***</span>
  
                  exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
  
                  jit.store32(
                      CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<span class="line-modified">!                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));</span>
  
                  CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
                  callLinkInfo-&gt;setUpCall(CallLinkInfo::Call, node-&gt;origin.semantic, GPRInfo::regT0);
  
                  jit.addPtr(CCallHelpers::TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), CCallHelpers::stackPointerRegister, GPRInfo::regT1);
                  jit.storePtr(GPRInfo::callFrameRegister, CCallHelpers::Address(GPRInfo::regT1, CallFrame::callerFrameOffset()));
  
                  // Now we need to make room for:
                  // - The caller frame and PC for a call to operationCallEval.
                  // - Potentially two arguments on the stack.
<span class="line-modified">!                 unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(ExecState*) * 2;</span>
                  requiredBytes = WTF::roundUpToMultipleOf(stackAlignmentBytes(), requiredBytes);
                  jit.subPtr(CCallHelpers::TrustedImm32(requiredBytes), CCallHelpers::stackPointerRegister);
<span class="line-modified">!                 jit.setupArguments&lt;decltype(operationCallEval)&gt;(GPRInfo::regT1);</span>
                  jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(operationCallEval)), GPRInfo::nonPreservedNonArgumentGPR0);
                  jit.call(GPRInfo::nonPreservedNonArgumentGPR0, OperationPtrTag);
                  exceptions-&gt;append(jit.emitExceptionCheck(state-&gt;vm(), AssemblyHelpers::NormalExceptionCheck, AssemblyHelpers::FarJumpWidth));
  
                  CCallHelpers::Jump done = jit.branchTest64(CCallHelpers::NonZero, GPRInfo::returnValueGPR);
  
                  jit.addPtr(CCallHelpers::TrustedImm32(requiredBytes), CCallHelpers::stackPointerRegister);
                  jit.load64(CCallHelpers::calleeFrameSlot(CallFrameSlot::callee), GPRInfo::regT0);
<span class="line-modified">!                 jit.emitDumbVirtualCall(vm, callLinkInfo);</span>
  
                  done.link(&amp;jit);
                  jit.addPtr(
                      CCallHelpers::TrustedImm32(-params.proc().frameSize()),
                      GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
              });
  
          setJSValue(patchpoint);
      }
  
<span class="line-modified">!     void compileLoadVarargs()</span>
      {
          LoadVarargsData* data = m_node-&gt;loadVarargsData();
<span class="line-modified">!         LValue jsArguments = lowJSValue(m_node-&gt;child1());</span>
  
          LValue length = vmCall(
<span class="line-modified">!             Int32, m_out.operation(operationSizeOfVarargs), m_callFrame, jsArguments,</span>
              m_out.constInt32(data-&gt;offset));
  
<span class="line-removed">-         // FIXME: There is a chance that we will call an effectful length property twice. This is safe</span>
<span class="line-removed">-         // from the standpoint of the VM&#39;s integrity, but it&#39;s subtly wrong from a spec compliance</span>
<span class="line-removed">-         // standpoint. The best solution would be one where we can exit *into* the op_call_varargs right</span>
<span class="line-removed">-         // past the sizing.</span>
<span class="line-removed">-         // https://bugs.webkit.org/show_bug.cgi?id=141448</span>
<span class="line-removed">- </span>
          LValue lengthIncludingThis = m_out.add(length, m_out.int32One);
  
<span class="line-modified">!         speculate(</span>
<span class="line-modified">!             VarargsOverflow, noValue(), nullptr,</span>
<span class="line-modified">!             m_out.above(length, lengthIncludingThis));</span>
  
          speculate(
              VarargsOverflow, noValue(), nullptr,
<span class="line-modified">!             m_out.above(lengthIncludingThis, m_out.constInt32(data-&gt;limit)));</span>
  
          m_out.store32(lengthIncludingThis, payloadFor(data-&gt;machineCount));
  
<span class="line-modified">!         // FIXME: This computation is rather silly. If operationLaodVarargs just took a pointer instead</span>
          // of a VirtualRegister, we wouldn&#39;t have to do this.
          // https://bugs.webkit.org/show_bug.cgi?id=141660
          LValue machineStart = m_out.lShr(
<span class="line-modified">!             m_out.sub(addressFor(data-&gt;machineStart.offset()).value(), m_callFrame),</span>
              m_out.constIntPtr(3));
  
          vmCall(
<span class="line-modified">!             Void, m_out.operation(operationLoadVarargs), m_callFrame,</span>
              m_out.castToInt32(machineStart), jsArguments, m_out.constInt32(data-&gt;offset),
<span class="line-modified">!             length, m_out.constInt32(data-&gt;mandatoryMinimum));</span>
      }
  
      void compileForwardVarargs()
      {
<span class="line-modified">!         if (m_node-&gt;child1()) {</span>
<span class="line-modified">!             Node* arguments = m_node-&gt;child1().node();</span>
              if (arguments-&gt;op() == PhantomNewArrayWithSpread || arguments-&gt;op() == PhantomNewArrayBuffer || arguments-&gt;op() == PhantomSpread) {
                  compileForwardVarargsWithSpread();
                  return;
              }
          }
  
          LoadVarargsData* data = m_node-&gt;loadVarargsData();
          InlineCallFrame* inlineCallFrame;
<span class="line-modified">!         if (m_node-&gt;child1())</span>
<span class="line-modified">!             inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();</span>
          else
              inlineCallFrame = m_node-&gt;origin.semantic.inlineCallFrame();
  
<span class="line-modified">!         LValue length = nullptr;</span>
<span class="line-modified">!         LValue lengthIncludingThis = nullptr;</span>
<span class="line-removed">-         ArgumentsLength argumentsLength = getArgumentsLength(inlineCallFrame);</span>
<span class="line-removed">-         if (argumentsLength.isKnown) {</span>
<span class="line-removed">-             unsigned knownLength = argumentsLength.known;</span>
<span class="line-removed">-             if (knownLength &gt;= data-&gt;offset)</span>
<span class="line-removed">-                 knownLength = knownLength - data-&gt;offset;</span>
<span class="line-removed">-             else</span>
<span class="line-removed">-                 knownLength = 0;</span>
<span class="line-removed">-             length = m_out.constInt32(knownLength);</span>
<span class="line-removed">-             lengthIncludingThis = m_out.constInt32(knownLength + 1);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             // We need to perform the same logical operation as the code above, but through dynamic operations.</span>
<span class="line-removed">-             if (!data-&gt;offset)</span>
<span class="line-removed">-                 length = argumentsLength.value;</span>
<span class="line-removed">-             else {</span>
<span class="line-removed">-                 LBasicBlock isLarger = m_out.newBlock();</span>
<span class="line-removed">-                 LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 ValueFromBlock smallerOrEqualLengthResult = m_out.anchor(m_out.constInt32(0));</span>
<span class="line-removed">-                 m_out.branch(</span>
<span class="line-removed">-                     m_out.above(argumentsLength.value, m_out.constInt32(data-&gt;offset)), unsure(isLarger), unsure(continuation));</span>
<span class="line-removed">-                 LBasicBlock lastNext = m_out.appendTo(isLarger, continuation);</span>
<span class="line-removed">-                 ValueFromBlock largerLengthResult = m_out.anchor(m_out.sub(argumentsLength.value, m_out.constInt32(data-&gt;offset)));</span>
<span class="line-removed">-                 m_out.jump(continuation);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 m_out.appendTo(continuation, lastNext);</span>
<span class="line-removed">-                 length = m_out.phi(Int32, smallerOrEqualLengthResult, largerLengthResult);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             lengthIncludingThis = m_out.add(length, m_out.constInt32(1));</span>
<span class="line-removed">-         }</span>
  
          speculate(
              VarargsOverflow, noValue(), nullptr,
              m_out.above(lengthIncludingThis, m_out.constInt32(data-&gt;limit)));
  
          m_out.store32(lengthIncludingThis, payloadFor(data-&gt;machineCount));
  
<span class="line-removed">-         unsigned numberOfArgumentsToSkip = data-&gt;offset;</span>
          LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
          LValue targetStart = addressFor(data-&gt;machineStart).value();
  
          LBasicBlock undefinedLoop = m_out.newBlock();
          LBasicBlock mainLoopEntry = m_out.newBlock();
<span class="line-new-header">--- 9627,113 ---</span>
  
                  exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
  
                  jit.store32(
                      CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<span class="line-modified">!                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
  
                  CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
                  callLinkInfo-&gt;setUpCall(CallLinkInfo::Call, node-&gt;origin.semantic, GPRInfo::regT0);
  
                  jit.addPtr(CCallHelpers::TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), CCallHelpers::stackPointerRegister, GPRInfo::regT1);
                  jit.storePtr(GPRInfo::callFrameRegister, CCallHelpers::Address(GPRInfo::regT1, CallFrame::callerFrameOffset()));
  
                  // Now we need to make room for:
                  // - The caller frame and PC for a call to operationCallEval.
                  // - Potentially two arguments on the stack.
<span class="line-modified">!                 unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(CallFrame*) * 2;</span>
                  requiredBytes = WTF::roundUpToMultipleOf(stackAlignmentBytes(), requiredBytes);
                  jit.subPtr(CCallHelpers::TrustedImm32(requiredBytes), CCallHelpers::stackPointerRegister);
<span class="line-modified">!                 jit.setupArguments&lt;decltype(operationCallEval)&gt;(globalObject, GPRInfo::regT1);</span>
<span class="line-added">+                 jit.prepareCallOperation(vm);</span>
                  jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(operationCallEval)), GPRInfo::nonPreservedNonArgumentGPR0);
                  jit.call(GPRInfo::nonPreservedNonArgumentGPR0, OperationPtrTag);
                  exceptions-&gt;append(jit.emitExceptionCheck(state-&gt;vm(), AssemblyHelpers::NormalExceptionCheck, AssemblyHelpers::FarJumpWidth));
  
                  CCallHelpers::Jump done = jit.branchTest64(CCallHelpers::NonZero, GPRInfo::returnValueGPR);
  
                  jit.addPtr(CCallHelpers::TrustedImm32(requiredBytes), CCallHelpers::stackPointerRegister);
                  jit.load64(CCallHelpers::calleeFrameSlot(CallFrameSlot::callee), GPRInfo::regT0);
<span class="line-modified">!                 jit.emitDumbVirtualCall(vm, globalObject, callLinkInfo);</span>
  
                  done.link(&amp;jit);
                  jit.addPtr(
                      CCallHelpers::TrustedImm32(-params.proc().frameSize()),
                      GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
              });
  
          setJSValue(patchpoint);
      }
  
<span class="line-modified">!     void compileVarargsLength()</span>
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LoadVarargsData* data = m_node-&gt;loadVarargsData();
<span class="line-modified">!         LValue jsArguments = lowJSValue(m_node-&gt;argumentsChild());</span>
  
          LValue length = vmCall(
<span class="line-modified">!             Int32, operationSizeOfVarargs, weakPointer(globalObject), jsArguments,</span>
              m_out.constInt32(data-&gt;offset));
  
          LValue lengthIncludingThis = m_out.add(length, m_out.int32One);
  
<span class="line-modified">!         setInt32(lengthIncludingThis);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-added">+     void compileLoadVarargs()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added">+         LoadVarargsData* data = m_node-&gt;loadVarargsData();</span>
<span class="line-added">+         LValue jsArguments = lowJSValue(m_node-&gt;argumentsChild());</span>
<span class="line-added">+         LValue lengthIncludingThis = lowInt32(m_node-&gt;child1());</span>
  
          speculate(
              VarargsOverflow, noValue(), nullptr,
<span class="line-modified">!             m_out.bitOr(m_out.isZero32(lengthIncludingThis), m_out.above(lengthIncludingThis, m_out.constInt32(data-&gt;limit))));</span>
  
          m_out.store32(lengthIncludingThis, payloadFor(data-&gt;machineCount));
  
<span class="line-modified">!         // FIXME: This computation is rather silly. If operationLoadVarargs just took a pointer instead</span>
          // of a VirtualRegister, we wouldn&#39;t have to do this.
          // https://bugs.webkit.org/show_bug.cgi?id=141660
          LValue machineStart = m_out.lShr(
<span class="line-modified">!             m_out.sub(addressFor(data-&gt;machineStart).value(), m_callFrame),</span>
              m_out.constIntPtr(3));
  
          vmCall(
<span class="line-modified">!             Void, operationLoadVarargs, weakPointer(globalObject),</span>
              m_out.castToInt32(machineStart), jsArguments, m_out.constInt32(data-&gt;offset),
<span class="line-modified">!             lengthIncludingThis, m_out.constInt32(data-&gt;mandatoryMinimum));</span>
      }
  
      void compileForwardVarargs()
      {
<span class="line-modified">!         if (m_node-&gt;argumentsChild()) {</span>
<span class="line-modified">!             Node* arguments = m_node-&gt;argumentsChild().node();</span>
              if (arguments-&gt;op() == PhantomNewArrayWithSpread || arguments-&gt;op() == PhantomNewArrayBuffer || arguments-&gt;op() == PhantomSpread) {
                  compileForwardVarargsWithSpread();
                  return;
              }
          }
  
          LoadVarargsData* data = m_node-&gt;loadVarargsData();
          InlineCallFrame* inlineCallFrame;
<span class="line-modified">!         if (m_node-&gt;argumentsChild())</span>
<span class="line-modified">!             inlineCallFrame = m_node-&gt;argumentsChild()-&gt;origin.semantic.inlineCallFrame();</span>
          else
              inlineCallFrame = m_node-&gt;origin.semantic.inlineCallFrame();
  
<span class="line-modified">!         unsigned numberOfArgumentsToSkip = data-&gt;offset;</span>
<span class="line-modified">!         LValue lengthIncludingThis = lowInt32(m_node-&gt;child1());</span>
  
<span class="line-added">+         LValue length = m_out.sub(lengthIncludingThis, m_out.int32One);</span>
          speculate(
              VarargsOverflow, noValue(), nullptr,
              m_out.above(lengthIncludingThis, m_out.constInt32(data-&gt;limit)));
  
          m_out.store32(lengthIncludingThis, payloadFor(data-&gt;machineCount));
  
          LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
          LValue targetStart = addressFor(data-&gt;machineStart).value();
  
          LBasicBlock undefinedLoop = m_out.newBlock();
          LBasicBlock mainLoopEntry = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9091,79 ***</span>
  
          // We need to perform the same logical operation as the code above, but through dynamic operations.
          if (!numberOfArgumentsToSkip)
              return argumentsLength.value;
  
<span class="line-modified">!         LBasicBlock isLarger = m_out.newBlock();</span>
<span class="line-removed">-         LBasicBlock continuation = m_out.newBlock();</span>
  
<span class="line-modified">!         ValueFromBlock smallerOrEqualLengthResult = m_out.anchor(m_out.constInt32(0));</span>
<span class="line-removed">-         m_out.branch(</span>
<span class="line-removed">-             m_out.above(argumentsLength.value, m_out.constInt32(numberOfArgumentsToSkip)), unsure(isLarger), unsure(continuation));</span>
<span class="line-removed">-         LBasicBlock lastNext = m_out.appendTo(isLarger, continuation);</span>
<span class="line-removed">-         ValueFromBlock largerLengthResult = m_out.anchor(m_out.sub(argumentsLength.value, m_out.constInt32(numberOfArgumentsToSkip)));</span>
<span class="line-removed">-         m_out.jump(continuation);</span>
  
<span class="line-modified">!         m_out.appendTo(continuation, lastNext);</span>
<span class="line-removed">-         return m_out.phi(Int32, smallerOrEqualLengthResult, largerLengthResult);</span>
      }
  
      void compileForwardVarargsWithSpread()
      {
<span class="line-modified">!         HashMap&lt;InlineCallFrame*, LValue, WTF::DefaultHash&lt;InlineCallFrame*&gt;::Hash, WTF::NullableHashTraits&lt;InlineCallFrame*&gt;&gt; cachedSpreadLengths;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         Node* arguments = m_node-&gt;child1().node();</span>
          RELEASE_ASSERT(arguments-&gt;op() == PhantomNewArrayWithSpread || arguments-&gt;op() == PhantomNewArrayBuffer || arguments-&gt;op() == PhantomSpread);
  
<span class="line-modified">!         unsigned numberOfStaticArguments = 0;</span>
<span class="line-removed">-         Vector&lt;LValue, 2&gt; spreadLengths;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto collectArgumentCount = recursableLambda([&amp;](auto self, Node* target) -&gt; void {</span>
<span class="line-removed">-             if (target-&gt;op() == PhantomSpread) {</span>
<span class="line-removed">-                 self(target-&gt;child1().node());</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (target-&gt;op() == PhantomNewArrayWithSpread) {</span>
<span class="line-removed">-                 BitVector* bitVector = target-&gt;bitVector();</span>
<span class="line-removed">-                 for (unsigned i = 0; i &lt; target-&gt;numChildren(); i++) {</span>
<span class="line-removed">-                     if (bitVector-&gt;get(i))</span>
<span class="line-removed">-                         self(m_graph.varArgChild(target, i).node());</span>
<span class="line-removed">-                     else</span>
<span class="line-removed">-                         ++numberOfStaticArguments;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (target-&gt;op() == PhantomNewArrayBuffer) {</span>
<span class="line-removed">-                 numberOfStaticArguments += target-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             ASSERT(target-&gt;op() == PhantomCreateRest);</span>
<span class="line-removed">-             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame();</span>
<span class="line-removed">-             unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();</span>
<span class="line-removed">-             spreadLengths.append(cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {</span>
<span class="line-removed">-                 return this-&gt;getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);</span>
<span class="line-removed">-             }).iterator-&gt;value);</span>
<span class="line-removed">-         });</span>
<span class="line-removed">- </span>
<span class="line-removed">-         collectArgumentCount(arguments);</span>
<span class="line-removed">-         LValue lengthIncludingThis = m_out.constInt32(1 + numberOfStaticArguments);</span>
<span class="line-removed">-         for (LValue length : spreadLengths)</span>
<span class="line-removed">-             lengthIncludingThis = m_out.add(lengthIncludingThis, length);</span>
  
          LoadVarargsData* data = m_node-&gt;loadVarargsData();
          speculate(
              VarargsOverflow, noValue(), nullptr,
              m_out.above(lengthIncludingThis, m_out.constInt32(data-&gt;limit)));
  
          m_out.store32(lengthIncludingThis, payloadFor(data-&gt;machineCount));
  
          LValue targetStart = addressFor(data-&gt;machineStart).value();
  
<span class="line-modified">!         auto forwardSpread = recursableLambda([this, &amp;cachedSpreadLengths, &amp;targetStart](auto self, Node* target, LValue storeIndex) -&gt; LValue {</span>
              if (target-&gt;op() == PhantomSpread)
                  return self(target-&gt;child1().node(), storeIndex);
  
              if (target-&gt;op() == PhantomNewArrayWithSpread) {
                  BitVector* bitVector = target-&gt;bitVector();
<span class="line-new-header">--- 9789,34 ---</span>
  
          // We need to perform the same logical operation as the code above, but through dynamic operations.
          if (!numberOfArgumentsToSkip)
              return argumentsLength.value;
  
<span class="line-modified">!         RELEASE_ASSERT(numberOfArgumentsToSkip &lt; static_cast&lt;unsigned&gt;(INT32_MIN));</span>
  
<span class="line-modified">!         LValue fixedLength = m_out.sub(argumentsLength.value, m_out.constInt32(numberOfArgumentsToSkip));</span>
  
<span class="line-modified">!         return m_out.select(m_out.greaterThanOrEqual(fixedLength, m_out.int32Zero), fixedLength, m_out.int32Zero, SelectPredictability::Predictable);</span>
      }
  
      void compileForwardVarargsWithSpread()
      {
<span class="line-modified">!         Node* arguments = m_node-&gt;argumentsChild().node();</span>
          RELEASE_ASSERT(arguments-&gt;op() == PhantomNewArrayWithSpread || arguments-&gt;op() == PhantomNewArrayBuffer || arguments-&gt;op() == PhantomSpread);
  
<span class="line-modified">!         LValue lengthIncludingThis = lowInt32(m_node-&gt;child1());</span>
  
          LoadVarargsData* data = m_node-&gt;loadVarargsData();
          speculate(
              VarargsOverflow, noValue(), nullptr,
              m_out.above(lengthIncludingThis, m_out.constInt32(data-&gt;limit)));
  
          m_out.store32(lengthIncludingThis, payloadFor(data-&gt;machineCount));
  
          LValue targetStart = addressFor(data-&gt;machineStart).value();
  
<span class="line-modified">!         auto forwardSpread = recursableLambda([this, &amp;targetStart](auto self, Node* target, LValue storeIndex) -&gt; LValue {</span>
              if (target-&gt;op() == PhantomSpread)
                  return self(target-&gt;child1().node(), storeIndex);
  
              if (target-&gt;op() == PhantomNewArrayWithSpread) {
                  BitVector* bitVector = target-&gt;bitVector();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9191,12 ***</span>
              }
  
              RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
              InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame();
  
<span class="line-modified">!             LValue sourceStart = this-&gt;getArgumentsStart(inlineCallFrame, target-&gt;numberOfArgumentsToSkip());</span>
<span class="line-modified">!             LValue spreadLength = m_out.zeroExtPtr(cachedSpreadLengths.get(inlineCallFrame));</span>
  
              LBasicBlock loop = m_out.newBlock();
              LBasicBlock continuation = m_out.newBlock();
              ValueFromBlock startLoadIndex = m_out.anchor(m_out.constIntPtr(0));
              ValueFromBlock startStoreIndex = m_out.anchor(storeIndex);
<span class="line-new-header">--- 9844,13 ---</span>
              }
  
              RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
              InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame();
  
<span class="line-modified">!             auto numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();</span>
<span class="line-modified">!             LValue sourceStart = this-&gt;getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);</span>
<span class="line-added">+             LValue spreadLength = m_out.zeroExtPtr(getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip));</span>
  
              LBasicBlock loop = m_out.newBlock();
              LBasicBlock continuation = m_out.newBlock();
              ValueFromBlock startLoadIndex = m_out.anchor(m_out.constIntPtr(0));
              ValueFromBlock startStoreIndex = m_out.anchor(storeIndex);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9261,10 ***</span>
<span class="line-new-header">--- 9915,11 ---</span>
                  m_node-&gt;branchData()-&gt;notTaken.count));
      }
  
      void compileSwitch()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          SwitchData* data = m_node-&gt;switchData();
          switch (data-&gt;kind) {
          case SwitchImm: {
              Vector&lt;ValueFromBlock, 2&gt; intValues;
              LBasicBlock switchOnInts = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9369,11 ***</span>
                  isRopeString(stringValue, m_node-&gt;child1()),
                  rarely(needResolution), usually(resolved));
  
              LBasicBlock lastNext = m_out.appendTo(needResolution, resolved);
              ValueFromBlock slowValue = m_out.anchor(
<span class="line-modified">!                 vmCall(pointerType(), m_out.operation(operationResolveRope), m_callFrame, stringValue));</span>
              m_out.jump(resolved);
  
              m_out.appendTo(resolved, lengthIs1);
              LValue value = m_out.phi(pointerType(), fastValue, slowValue);
              m_out.branch(
<span class="line-new-header">--- 10024,11 ---</span>
                  isRopeString(stringValue, m_node-&gt;child1()),
                  rarely(needResolution), usually(resolved));
  
              LBasicBlock lastNext = m_out.appendTo(needResolution, resolved);
              ValueFromBlock slowValue = m_out.anchor(
<span class="line-modified">!                 vmCall(pointerType(), operationResolveRope, weakPointer(globalObject), stringValue));</span>
              m_out.jump(resolved);
  
              m_out.appendTo(resolved, lengthIs1);
              LValue value = m_out.phi(pointerType(), fastValue, slowValue);
              m_out.branch(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9556,21 ***</span>
  #endif
      }
  
      void compileThrow()
      {
          LValue error = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         vmCall(Void, m_out.operation(operationThrowDFG), m_callFrame, error);</span>
          // vmCall() does an exception check so we should never reach this.
          m_out.unreachable();
      }
  
      void compileThrowStaticError()
      {
          LValue errorMessage = lowString(m_node-&gt;child1());
          LValue errorType = m_out.constInt32(m_node-&gt;errorType());
<span class="line-modified">!         vmCall(Void, m_out.operation(operationThrowStaticError), m_callFrame, errorMessage, errorType);</span>
          // vmCall() does an exception check so we should never reach this.
          m_out.unreachable();
      }
  
      void compileInvalidationPoint()
<span class="line-new-header">--- 10211,23 ---</span>
  #endif
      }
  
      void compileThrow()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue error = lowJSValue(m_node-&gt;child1());
<span class="line-modified">!         vmCall(Void, operationThrowDFG, weakPointer(globalObject), error);</span>
          // vmCall() does an exception check so we should never reach this.
          m_out.unreachable();
      }
  
      void compileThrowStaticError()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue errorMessage = lowString(m_node-&gt;child1());
          LValue errorType = m_out.constInt32(m_node-&gt;errorType());
<span class="line-modified">!         vmCall(Void, operationThrowStaticError, weakPointer(globalObject), errorMessage, errorType);</span>
          // vmCall() does an exception check so we should never reach this.
          m_out.unreachable();
      }
  
      void compileInvalidationPoint()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9784,10 ***</span>
<span class="line-new-header">--- 10441,11 ---</span>
          return key;
      }
  
      LValue mapHashString(LValue string, Edge&amp; edge)
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LBasicBlock nonEmptyStringCase = m_out.newBlock();
          LBasicBlock slowCase = m_out.newBlock();
          LBasicBlock continuation = m_out.newBlock();
  
          m_out.branch(isRopeString(string, edge), rarely(slowCase), usually(nonEmptyStringCase));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9799,19 ***</span>
          m_out.branch(m_out.equal(hash, m_out.constInt32(0)),
              unsure(slowCase), unsure(continuation));
  
          m_out.appendTo(slowCase, continuation);
          ValueFromBlock slowResult = m_out.anchor(
<span class="line-modified">!             vmCall(Int32, m_out.operation(operationMapHash), m_callFrame, string));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          return m_out.phi(Int32, slowResult, nonEmptyStringHashResult);
      }
  
      void compileMapHash()
      {
          switch (m_node-&gt;child1().useKind()) {
          case BooleanUse:
          case Int32Use:
          case SymbolUse:
          case ObjectUse: {
<span class="line-new-header">--- 10457,20 ---</span>
          m_out.branch(m_out.equal(hash, m_out.constInt32(0)),
              unsure(slowCase), unsure(continuation));
  
          m_out.appendTo(slowCase, continuation);
          ValueFromBlock slowResult = m_out.anchor(
<span class="line-modified">!             vmCall(Int32, operationMapHash, weakPointer(globalObject), string));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          return m_out.phi(Int32, slowResult, nonEmptyStringHashResult);
      }
  
      void compileMapHash()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          switch (m_node-&gt;child1().useKind()) {
          case BooleanUse:
          case Int32Use:
          case SymbolUse:
          case ObjectUse: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9886,11 ***</span>
          ValueFromBlock fastResult = m_out.anchor(wangsInt64Hash(value));
          m_out.jump(continuation);
  
          m_out.appendTo(slowCase, continuation);
          ValueFromBlock slowResult = m_out.anchor(
<span class="line-modified">!             vmCall(Int32, m_out.operation(operationMapHash), m_callFrame, value));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setInt32(m_out.phi(Int32, fastResult, slowResult, nonEmptyStringHashResult));
      }
<span class="line-new-header">--- 10545,11 ---</span>
          ValueFromBlock fastResult = m_out.anchor(wangsInt64Hash(value));
          m_out.jump(continuation);
  
          m_out.appendTo(slowCase, continuation);
          ValueFromBlock slowResult = m_out.anchor(
<span class="line-modified">!             vmCall(Int32, operationMapHash, weakPointer(globalObject), value));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setInt32(m_out.phi(Int32, fastResult, slowResult, nonEmptyStringHashResult));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9933,10 ***</span>
<span class="line-new-header">--- 10592,11 ---</span>
          setJSValue(m_out.phi(Int64, fastResult, normalizedNaNResult, doubleResult, boxedIntResult));
      }
  
      void compileGetMapBucket()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LBasicBlock loopStart = m_out.newBlock();
          LBasicBlock loopAround = m_out.newBlock();
          LBasicBlock slowPath = m_out.newBlock();
          LBasicBlock notPresentInTable = m_out.newBlock();
          LBasicBlock notEmptyValue = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10063,11 ***</span>
          m_out.addIncomingToPhi(unmaskedIndex, m_out.anchor(m_out.add(index, m_out.int32One)));
          m_out.jump(loopStart);
  
          m_out.appendTo(slowPath, notPresentInTable);
          ValueFromBlock slowPathResult = m_out.anchor(vmCall(pointerType(),
<span class="line-modified">!             m_out.operation(m_node-&gt;child1().useKind() == MapObjectUse ? operationJSMapFindBucket : operationJSSetFindBucket), m_callFrame, map, key, hash));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(notPresentInTable, continuation);
          ValueFromBlock notPresentResult;
          if (m_node-&gt;child1().useKind() == MapObjectUse)
<span class="line-new-header">--- 10723,11 ---</span>
          m_out.addIncomingToPhi(unmaskedIndex, m_out.anchor(m_out.add(index, m_out.int32One)));
          m_out.jump(loopStart);
  
          m_out.appendTo(slowPath, notPresentInTable);
          ValueFromBlock slowPathResult = m_out.anchor(vmCall(pointerType(),
<span class="line-modified">!             m_node-&gt;child1().useKind() == MapObjectUse ? operationJSMapFindBucket : operationJSSetFindBucket, weakPointer(globalObject), map, key, hash));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(notPresentInTable, continuation);
          ValueFromBlock notPresentResult;
          if (m_node-&gt;child1().useKind() == MapObjectUse)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10158,25 ***</span>
          setJSValue(m_out.load64(mapBucket, m_heaps.HashMapBucket_key));
      }
  
      void compileSetAdd()
      {
          LValue set = lowSetObject(m_node-&gt;child1());
          LValue key = lowJSValue(m_node-&gt;child2());
          LValue hash = lowInt32(m_node-&gt;child3());
  
<span class="line-modified">!         setJSValue(vmCall(pointerType(), m_out.operation(operationSetAdd), m_callFrame, set, key, hash));</span>
      }
  
      void compileMapSet()
      {
          LValue map = lowMapObject(m_graph.varArgChild(m_node, 0));
          LValue key = lowJSValue(m_graph.varArgChild(m_node, 1));
          LValue value = lowJSValue(m_graph.varArgChild(m_node, 2));
          LValue hash = lowInt32(m_graph.varArgChild(m_node, 3));
  
<span class="line-modified">!         setJSValue(vmCall(pointerType(), m_out.operation(operationMapSet), m_callFrame, map, key, value, hash));</span>
      }
  
      void compileWeakMapGet()
      {
          LBasicBlock loopStart = m_out.newBlock();
<span class="line-new-header">--- 10818,27 ---</span>
          setJSValue(m_out.load64(mapBucket, m_heaps.HashMapBucket_key));
      }
  
      void compileSetAdd()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue set = lowSetObject(m_node-&gt;child1());
          LValue key = lowJSValue(m_node-&gt;child2());
          LValue hash = lowInt32(m_node-&gt;child3());
  
<span class="line-modified">!         setJSValue(vmCall(pointerType(), operationSetAdd, weakPointer(globalObject), set, key, hash));</span>
      }
  
      void compileMapSet()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue map = lowMapObject(m_graph.varArgChild(m_node, 0));
          LValue key = lowJSValue(m_graph.varArgChild(m_node, 1));
          LValue value = lowJSValue(m_graph.varArgChild(m_node, 2));
          LValue hash = lowInt32(m_graph.varArgChild(m_node, 3));
  
<span class="line-modified">!         setJSValue(vmCall(pointerType(), operationMapSet, weakPointer(globalObject), map, key, value, hash));</span>
      }
  
      void compileWeakMapGet()
      {
          LBasicBlock loopStart = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10239,21 ***</span>
      {
          LValue set = lowWeakSetObject(m_node-&gt;child1());
          LValue key = lowObject(m_node-&gt;child2());
          LValue hash = lowInt32(m_node-&gt;child3());
  
<span class="line-modified">!         vmCall(Void, m_out.operation(operationWeakSetAdd), m_callFrame, set, key, hash);</span>
      }
  
      void compileWeakMapSet()
      {
          LValue map = lowWeakMapObject(m_graph.varArgChild(m_node, 0));
          LValue key = lowObject(m_graph.varArgChild(m_node, 1));
          LValue value = lowJSValue(m_graph.varArgChild(m_node, 2));
          LValue hash = lowInt32(m_graph.varArgChild(m_node, 3));
  
<span class="line-modified">!         vmCall(Void, m_out.operation(operationWeakMapSet), m_callFrame, map, key, value, hash);</span>
      }
  
      void compileIsObjectOrNull()
      {
          JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
<span class="line-new-header">--- 10901,21 ---</span>
      {
          LValue set = lowWeakSetObject(m_node-&gt;child1());
          LValue key = lowObject(m_node-&gt;child2());
          LValue hash = lowInt32(m_node-&gt;child3());
  
<span class="line-modified">!         vmCall(Void, operationWeakSetAdd, m_vmValue, set, key, hash);</span>
      }
  
      void compileWeakMapSet()
      {
          LValue map = lowWeakMapObject(m_graph.varArgChild(m_node, 0));
          LValue key = lowObject(m_graph.varArgChild(m_node, 1));
          LValue value = lowJSValue(m_graph.varArgChild(m_node, 2));
          LValue hash = lowInt32(m_graph.varArgChild(m_node, 3));
  
<span class="line-modified">!         vmCall(Void, operationWeakMapSet, m_vmValue, map, key, value, hash);</span>
      }
  
      void compileIsObjectOrNull()
      {
          JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10395,23 ***</span>
          setJSValue(m_out.phi(Int64, results));
      }
  
      void compileInByVal()
      {
<span class="line-modified">!         setJSValue(vmCall(Int64, m_out.operation(operationInByVal), m_callFrame, lowCell(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2())));</span>
      }
  
      void compileInById()
      {
          Node* node = m_node;
          UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
          LValue base = lowCell(m_node-&gt;child1());
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(base);
<span class="line-modified">!         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));</span>
  
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
<span class="line-new-header">--- 11057,24 ---</span>
          setJSValue(m_out.phi(Int64, results));
      }
  
      void compileInByVal()
      {
<span class="line-modified">!         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added">+         setJSValue(vmCall(Int64, operationInByVal, weakPointer(globalObject), lowCell(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2())));</span>
      }
  
      void compileInById()
      {
          Node* node = m_node;
          UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
          LValue base = lowCell(m_node-&gt;child1());
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(base);
<span class="line-modified">!         patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
  
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10443,10 ***</span>
<span class="line-new-header">--- 11106,11 ---</span>
                          generator-&gt;slowPathJump().link(&amp;jit);
                          CCallHelpers::Label slowPathBegin = jit.label();
                          CCallHelpers::Call slowPathCall = callOperation(
                              *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
                              exceptions.get(), operationInByIdOptimize, params[0].gpr(),
<span class="line-added">+                             jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic),</span>
                              CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), params[1].gpr(),
                              CCallHelpers::TrustedImmPtr(uid)).call();
                          jit.jump().linkTo(done, &amp;jit);
  
                          generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10461,10 ***</span>
<span class="line-new-header">--- 11125,11 ---</span>
          setJSValue(patchpoint);
      }
  
      void compileHasOwnProperty()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LBasicBlock slowCase = m_out.newBlock();
          LBasicBlock continuation = m_out.newBlock();
          LBasicBlock lastNext = nullptr;
  
          LValue object = lowObject(m_node-&gt;child1());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10554,32 ***</span>
  
          m_out.branch(m_out.notZero32(cacheHit), usually(continuation), rarely(slowCase));
  
          m_out.appendTo(slowCase, continuation);
          ValueFromBlock slowResult;
<span class="line-modified">!         slowResult = m_out.anchor(vmCall(Int32, m_out.operation(operationHasOwnProperty), m_callFrame, object, keyAsValue));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setBoolean(m_out.phi(Int32, fastResult, slowResult));
      }
  
      void compileParseInt()
      {
          RELEASE_ASSERT(m_node-&gt;child1().useKind() == UntypedUse || m_node-&gt;child1().useKind() == StringUse);
          LValue result;
          if (m_node-&gt;child2()) {
              LValue radix = lowInt32(m_node-&gt;child2());
              if (m_node-&gt;child1().useKind() == UntypedUse)
<span class="line-modified">!                 result = vmCall(Int64, m_out.operation(operationParseIntGeneric), m_callFrame, lowJSValue(m_node-&gt;child1()), radix);</span>
              else
<span class="line-modified">!                 result = vmCall(Int64, m_out.operation(operationParseIntString), m_callFrame, lowString(m_node-&gt;child1()), radix);</span>
          } else {
              if (m_node-&gt;child1().useKind() == UntypedUse)
<span class="line-modified">!                 result = vmCall(Int64, m_out.operation(operationParseIntNoRadixGeneric), m_callFrame, lowJSValue(m_node-&gt;child1()));</span>
              else
<span class="line-modified">!                 result = vmCall(Int64, m_out.operation(operationParseIntStringNoRadix), m_callFrame, lowString(m_node-&gt;child1()));</span>
          }
          setJSValue(result);
      }
  
      void compileOverridesHasInstance()
<span class="line-new-header">--- 11219,33 ---</span>
  
          m_out.branch(m_out.notZero32(cacheHit), usually(continuation), rarely(slowCase));
  
          m_out.appendTo(slowCase, continuation);
          ValueFromBlock slowResult;
<span class="line-modified">!         slowResult = m_out.anchor(vmCall(Int32, operationHasOwnProperty, weakPointer(globalObject), object, keyAsValue));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setBoolean(m_out.phi(Int32, fastResult, slowResult));
      }
  
      void compileParseInt()
      {
          RELEASE_ASSERT(m_node-&gt;child1().useKind() == UntypedUse || m_node-&gt;child1().useKind() == StringUse);
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue result;
          if (m_node-&gt;child2()) {
              LValue radix = lowInt32(m_node-&gt;child2());
              if (m_node-&gt;child1().useKind() == UntypedUse)
<span class="line-modified">!                 result = vmCall(Int64, operationParseIntGeneric, weakPointer(globalObject), lowJSValue(m_node-&gt;child1()), radix);</span>
              else
<span class="line-modified">!                 result = vmCall(Int64, operationParseIntString, weakPointer(globalObject), lowString(m_node-&gt;child1()), radix);</span>
          } else {
              if (m_node-&gt;child1().useKind() == UntypedUse)
<span class="line-modified">!                 result = vmCall(Int64, operationParseIntNoRadixGeneric, weakPointer(globalObject), lowJSValue(m_node-&gt;child1()));</span>
              else
<span class="line-modified">!                 result = vmCall(Int64, operationParseIntStringNoRadix, weakPointer(globalObject), lowString(m_node-&gt;child1()));</span>
          }
          setJSValue(result);
      }
  
      void compileOverridesHasInstance()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10647,12 ***</span>
          bool prototypeIsObject = abstractValue(m_node-&gt;child2()).isType(SpecObject | ~SpecCell);
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(value);
          patchpoint-&gt;appendSomeRegister(prototype);
<span class="line-modified">!         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));</span>
          patchpoint-&gt;numGPScratchRegisters = 2;
          patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
<span class="line-new-header">--- 11313,12 ---</span>
          bool prototypeIsObject = abstractValue(m_node-&gt;child2()).isType(SpecObject | ~SpecCell);
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(value);
          patchpoint-&gt;appendSomeRegister(prototype);
<span class="line-modified">!         patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
          patchpoint-&gt;numGPScratchRegisters = 2;
          patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10696,17 ***</span>
  
                  params.addLatePath(
                      [=] (CCallHelpers&amp; jit) {
                          AllowMacroScratchRegisterUsage allowScratch(jit);
  
<span class="line-modified">!                         J_JITOperation_ESsiJJ optimizationFunction = operationInstanceOfOptimize;</span>
  
                          slowCases.link(&amp;jit);
                          CCallHelpers::Label slowPathBegin = jit.label();
                          CCallHelpers::Call slowPathCall = callOperation(
                              *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
                              exceptions.get(), optimizationFunction, resultGPR,
                              CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), valueGPR,
                              prototypeGPR).call();
                          jit.jump().linkTo(done, &amp;jit);
  
                          generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
<span class="line-new-header">--- 11362,18 ---</span>
  
                  params.addLatePath(
                      [=] (CCallHelpers&amp; jit) {
                          AllowMacroScratchRegisterUsage allowScratch(jit);
  
<span class="line-modified">!                         J_JITOperation_GSsiJJ optimizationFunction = operationInstanceOfOptimize;</span>
  
                          slowCases.link(&amp;jit);
                          CCallHelpers::Label slowPathBegin = jit.label();
                          CCallHelpers::Call slowPathCall = callOperation(
                              *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
                              exceptions.get(), optimizationFunction, resultGPR,
<span class="line-added">+                             jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic),</span>
                              CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), valueGPR,
                              prototypeGPR).call();
                          jit.jump().linkTo(done, &amp;jit);
  
                          generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10725,15 ***</span>
          setJSValue(patchpoint);
      }
  
      void compileInstanceOfCustom()
      {
          LValue value = lowJSValue(m_node-&gt;child1());
          LValue constructor = lowCell(m_node-&gt;child2());
          LValue hasInstance = lowJSValue(m_node-&gt;child3());
  
<span class="line-modified">!         setBoolean(m_out.logicalNot(m_out.equal(m_out.constInt32(0), vmCall(Int32, m_out.operation(operationInstanceOfCustom), m_callFrame, value, constructor, hasInstance))));</span>
      }
  
      void compileCountExecution()
      {
          TypedPointer counter = m_out.absolute(m_node-&gt;executionCounter()-&gt;address());
<span class="line-new-header">--- 11392,16 ---</span>
          setJSValue(patchpoint);
      }
  
      void compileInstanceOfCustom()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue value = lowJSValue(m_node-&gt;child1());
          LValue constructor = lowCell(m_node-&gt;child2());
          LValue hasInstance = lowJSValue(m_node-&gt;child3());
  
<span class="line-modified">!         setBoolean(m_out.logicalNot(m_out.equal(m_out.constInt32(0), vmCall(Int32, operationInstanceOfCustom, weakPointer(globalObject), value, constructor, hasInstance))));</span>
      }
  
      void compileCountExecution()
      {
          TypedPointer counter = m_out.absolute(m_node-&gt;executionCounter()-&gt;address());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10757,10 ***</span>
<span class="line-new-header">--- 11425,11 ---</span>
          emitStoreBarrier(lowCell(m_node-&gt;child1()), m_node-&gt;op() == FencedStoreBarrier);
      }
  
      void compileHasIndexedProperty()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue base = lowCell(m_graph.varArgChild(m_node, 0));
          LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
  
          switch (m_node-&gt;arrayMode().type()) {
          case Array::Int32:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10790,11 ***</span>
              ValueFromBlock checkHoleResult = m_out.anchor(checkHoleResultValue);
              m_out.branch(checkHoleResultValue, usually(continuation), rarely(slowCase));
  
              m_out.appendTo(slowCase, continuation);
              ValueFromBlock slowResult = m_out.anchor(
<span class="line-modified">!                 m_out.notZero64(vmCall(Int64, m_out.operation(operationHasIndexedPropertyByInt), m_callFrame, base, index, internalMethodType)));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setBoolean(m_out.phi(Int32, checkHoleResult, slowResult));
              return;
<span class="line-new-header">--- 11459,11 ---</span>
              ValueFromBlock checkHoleResult = m_out.anchor(checkHoleResultValue);
              m_out.branch(checkHoleResultValue, usually(continuation), rarely(slowCase));
  
              m_out.appendTo(slowCase, continuation);
              ValueFromBlock slowResult = m_out.anchor(
<span class="line-modified">!                 m_out.notZero64(vmCall(Int64, operationHasIndexedPropertyByInt, weakPointer(globalObject), base, index, internalMethodType)));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setBoolean(m_out.phi(Int32, checkHoleResult, slowResult));
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10824,11 ***</span>
              ValueFromBlock checkHoleResult = m_out.anchor(checkHoleResultValue);
              m_out.branch(checkHoleResultValue, usually(continuation), rarely(slowCase));
  
              m_out.appendTo(slowCase, continuation);
              ValueFromBlock slowResult = m_out.anchor(
<span class="line-modified">!                 m_out.notZero64(vmCall(Int64, m_out.operation(operationHasIndexedPropertyByInt), m_callFrame, base, index, internalMethodType)));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setBoolean(m_out.phi(Int32, checkHoleResult, slowResult));
              return;
<span class="line-new-header">--- 11493,11 ---</span>
              ValueFromBlock checkHoleResult = m_out.anchor(checkHoleResultValue);
              m_out.branch(checkHoleResultValue, usually(continuation), rarely(slowCase));
  
              m_out.appendTo(slowCase, continuation);
              ValueFromBlock slowResult = m_out.anchor(
<span class="line-modified">!                 m_out.notZero64(vmCall(Int64, operationHasIndexedPropertyByInt, weakPointer(globalObject), base, index, internalMethodType)));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setBoolean(m_out.phi(Int32, checkHoleResult, slowResult));
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10857,35 ***</span>
              ValueFromBlock checkHoleResult = m_out.anchor(checkHoleResultValue);
              m_out.branch(checkHoleResultValue, usually(continuation), rarely(slowCase));
  
              m_out.appendTo(slowCase, continuation);
              ValueFromBlock slowResult = m_out.anchor(
<span class="line-modified">!                 m_out.notZero64(vmCall(Int64, m_out.operation(operationHasIndexedPropertyByInt), m_callFrame, base, index, internalMethodType)));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setBoolean(m_out.phi(Int32, checkHoleResult, slowResult));
              break;
          }
  
          default: {
              LValue internalMethodType = m_out.constInt32(static_cast&lt;int32_t&gt;(m_node-&gt;internalMethodType()));
<span class="line-modified">!             setBoolean(m_out.notZero64(vmCall(Int64, m_out.operation(operationHasIndexedPropertyByInt), m_callFrame, base, index, internalMethodType)));</span>
              break;
          }
          }
      }
  
      void compileHasGenericProperty()
      {
          LValue base = lowJSValue(m_node-&gt;child1());
          LValue property = lowCell(m_node-&gt;child2());
<span class="line-modified">!         setJSValue(vmCall(Int64, m_out.operation(operationHasGenericProperty), m_callFrame, base, property));</span>
      }
  
      void compileHasStructureProperty()
      {
          LValue base = lowJSValue(m_node-&gt;child1());
          LValue property = lowString(m_node-&gt;child2());
          LValue enumerator = lowCell(m_node-&gt;child3());
  
          LBasicBlock correctStructure = m_out.newBlock();
<span class="line-new-header">--- 11526,37 ---</span>
              ValueFromBlock checkHoleResult = m_out.anchor(checkHoleResultValue);
              m_out.branch(checkHoleResultValue, usually(continuation), rarely(slowCase));
  
              m_out.appendTo(slowCase, continuation);
              ValueFromBlock slowResult = m_out.anchor(
<span class="line-modified">!                 m_out.notZero64(vmCall(Int64, operationHasIndexedPropertyByInt, weakPointer(globalObject), base, index, internalMethodType)));</span>
              m_out.jump(continuation);
  
              m_out.appendTo(continuation, lastNext);
              setBoolean(m_out.phi(Int32, checkHoleResult, slowResult));
              break;
          }
  
          default: {
              LValue internalMethodType = m_out.constInt32(static_cast&lt;int32_t&gt;(m_node-&gt;internalMethodType()));
<span class="line-modified">!             setBoolean(m_out.notZero64(vmCall(Int64, operationHasIndexedPropertyByInt, weakPointer(globalObject), base, index, internalMethodType)));</span>
              break;
          }
          }
      }
  
      void compileHasGenericProperty()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue base = lowJSValue(m_node-&gt;child1());
          LValue property = lowCell(m_node-&gt;child2());
<span class="line-modified">!         setJSValue(vmCall(Int64, operationHasGenericProperty, weakPointer(globalObject), base, property));</span>
      }
  
      void compileHasStructureProperty()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue base = lowJSValue(m_node-&gt;child1());
          LValue property = lowString(m_node-&gt;child2());
          LValue enumerator = lowCell(m_node-&gt;child3());
  
          LBasicBlock correctStructure = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10903,19 ***</span>
  
          m_out.appendTo(wrongStructure, continuation);
          ValueFromBlock wrongStructureResult = m_out.anchor(
              m_out.equal(
                  m_out.constInt64(JSValue::encode(jsBoolean(true))),
<span class="line-modified">!                 vmCall(Int64, m_out.operation(operationHasGenericProperty), m_callFrame, base, property)));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setBoolean(m_out.phi(Int32, correctStructureResult, wrongStructureResult));
      }
  
      void compileGetDirectPname()
      {
          LValue base = lowCell(m_graph.varArgChild(m_node, 0));
          LValue property = lowCell(m_graph.varArgChild(m_node, 1));
          LValue index = lowInt32(m_graph.varArgChild(m_node, 2));
          LValue enumerator = lowCell(m_graph.varArgChild(m_node, 3));
  
<span class="line-new-header">--- 11574,20 ---</span>
  
          m_out.appendTo(wrongStructure, continuation);
          ValueFromBlock wrongStructureResult = m_out.anchor(
              m_out.equal(
                  m_out.constInt64(JSValue::encode(jsBoolean(true))),
<span class="line-modified">!                 vmCall(Int64, operationHasGenericProperty, weakPointer(globalObject), base, property)));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setBoolean(m_out.phi(Int32, correctStructureResult, wrongStructureResult));
      }
  
      void compileGetDirectPname()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue base = lowCell(m_graph.varArgChild(m_node, 0));
          LValue property = lowCell(m_graph.varArgChild(m_node, 1));
          LValue index = lowInt32(m_graph.varArgChild(m_node, 2));
          LValue enumerator = lowCell(m_graph.varArgChild(m_node, 3));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10949,11 ***</span>
              m_out.load64(m_out.baseIndex(m_heaps.properties.atAnyNumber(), storage, realIndex, ScaleEight, offsetOfFirstProperty)));
          m_out.jump(continuation);
  
          m_out.appendTo(slowCase, continuation);
          ValueFromBlock slowCaseResult = m_out.anchor(
<span class="line-modified">!             vmCall(Int64, m_out.operation(operationGetByVal), m_callFrame, base, property));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setJSValue(m_out.phi(Int64, inlineResult, outOfLineResult, slowCaseResult));
      }
<span class="line-new-header">--- 11621,11 ---</span>
              m_out.load64(m_out.baseIndex(m_heaps.properties.atAnyNumber(), storage, realIndex, ScaleEight, offsetOfFirstProperty)));
          m_out.jump(continuation);
  
          m_out.appendTo(slowCase, continuation);
          ValueFromBlock slowCaseResult = m_out.anchor(
<span class="line-modified">!             vmCall(Int64, operationGetByVal, weakPointer(globalObject), base, property));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setJSValue(m_out.phi(Int64, inlineResult, outOfLineResult, slowCaseResult));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10964,14 ***</span>
          setInt32(m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_indexLength));
      }
  
      void compileGetPropertyEnumerator()
      {
          if (m_node-&gt;child1().useKind() == CellUse)
<span class="line-modified">!             setJSValue(vmCall(Int64, m_out.operation(operationGetPropertyEnumeratorCell), m_callFrame, lowCell(m_node-&gt;child1())));</span>
          else
<span class="line-modified">!             setJSValue(vmCall(Int64, m_out.operation(operationGetPropertyEnumerator), m_callFrame, lowJSValue(m_node-&gt;child1())));</span>
      }
  
      void compileGetEnumeratorStructurePname()
      {
          LValue enumerator = lowCell(m_node-&gt;child1());
<span class="line-new-header">--- 11636,15 ---</span>
          setInt32(m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_indexLength));
      }
  
      void compileGetPropertyEnumerator()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;child1().useKind() == CellUse)
<span class="line-modified">!             setJSValue(vmCall(Int64, operationGetPropertyEnumeratorCell, weakPointer(globalObject), lowCell(m_node-&gt;child1())));</span>
          else
<span class="line-modified">!             setJSValue(vmCall(Int64, operationGetPropertyEnumerator, weakPointer(globalObject), lowJSValue(m_node-&gt;child1())));</span>
      }
  
      void compileGetEnumeratorStructurePname()
      {
          LValue enumerator = lowCell(m_node-&gt;child1());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10989,11 ***</span>
          ValueFromBlock inBoundsResult = m_out.anchor(
              m_out.loadPtr(m_out.baseIndex(m_heaps.JSPropertyNameEnumerator_cachedPropertyNamesVectorContents, storage, m_out.zeroExtPtr(index))));
          m_out.jump(continuation);
  
          m_out.appendTo(outOfBounds, continuation);
<span class="line-modified">!         ValueFromBlock outOfBoundsResult = m_out.anchor(m_out.constInt64(ValueNull));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setJSValue(m_out.phi(Int64, inBoundsResult, outOfBoundsResult));
      }
<span class="line-new-header">--- 11662,11 ---</span>
          ValueFromBlock inBoundsResult = m_out.anchor(
              m_out.loadPtr(m_out.baseIndex(m_heaps.JSPropertyNameEnumerator_cachedPropertyNamesVectorContents, storage, m_out.zeroExtPtr(index))));
          m_out.jump(continuation);
  
          m_out.appendTo(outOfBounds, continuation);
<span class="line-modified">!         ValueFromBlock outOfBoundsResult = m_out.anchor(m_out.constInt64(JSValue::ValueNull));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setJSValue(m_out.phi(Int64, inBoundsResult, outOfBoundsResult));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11015,21 ***</span>
          ValueFromBlock inBoundsResult = m_out.anchor(
              m_out.loadPtr(m_out.baseIndex(m_heaps.JSPropertyNameEnumerator_cachedPropertyNamesVectorContents, storage, m_out.zeroExtPtr(index))));
          m_out.jump(continuation);
  
          m_out.appendTo(outOfBounds, continuation);
<span class="line-modified">!         ValueFromBlock outOfBoundsResult = m_out.anchor(m_out.constInt64(ValueNull));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setJSValue(m_out.phi(Int64, inBoundsResult, outOfBoundsResult));
      }
  
      void compileToIndexString()
      {
          LValue index = lowInt32(m_node-&gt;child1());
<span class="line-modified">!         setJSValue(vmCall(Int64, m_out.operation(operationToIndexString), m_callFrame, index));</span>
      }
  
      void compileCheckStructureImmediate()
      {
          LValue structure = lowCell(m_node-&gt;child1());
<span class="line-new-header">--- 11688,22 ---</span>
          ValueFromBlock inBoundsResult = m_out.anchor(
              m_out.loadPtr(m_out.baseIndex(m_heaps.JSPropertyNameEnumerator_cachedPropertyNamesVectorContents, storage, m_out.zeroExtPtr(index))));
          m_out.jump(continuation);
  
          m_out.appendTo(outOfBounds, continuation);
<span class="line-modified">!         ValueFromBlock outOfBoundsResult = m_out.anchor(m_out.constInt64(JSValue::ValueNull));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setJSValue(m_out.phi(Int64, inBoundsResult, outOfBoundsResult));
      }
  
      void compileToIndexString()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue index = lowInt32(m_node-&gt;child1());
<span class="line-modified">!         setJSValue(vmCall(Int64, operationToIndexString, weakPointer(globalObject), index));</span>
      }
  
      void compileCheckStructureImmediate()
      {
          LValue structure = lowCell(m_node-&gt;child1());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11162,19 ***</span>
                  if (hasIndexingHeader) {
                      slowObjectValue = lazySlowPath(
                          [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                              return createLazyCallGenerator(vm,
                                  operationNewObjectWithButterflyWithIndexingHeaderAndVectorLength,
<span class="line-modified">!                                 locations[0].directGPR(), CCallHelpers::TrustedImmPtr(structure.get()),</span>
                                  locations[1].directGPR(), locations[2].directGPR());
                          },
                          vectorLength, butterflyValue);
                  } else {
                      slowObjectValue = lazySlowPath(
                          [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                              return createLazyCallGenerator(vm,
<span class="line-modified">!                                 operationNewObjectWithButterfly, locations[0].directGPR(),</span>
                                  CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR());
                          },
                          butterflyValue);
                  }
                  ValueFromBlock slowObject = m_out.anchor(slowObjectValue);
<span class="line-new-header">--- 11836,19 ---</span>
                  if (hasIndexingHeader) {
                      slowObjectValue = lazySlowPath(
                          [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                              return createLazyCallGenerator(vm,
                                  operationNewObjectWithButterflyWithIndexingHeaderAndVectorLength,
<span class="line-modified">!                                 locations[0].directGPR(), &amp;vm, CCallHelpers::TrustedImmPtr(structure.get()),</span>
                                  locations[1].directGPR(), locations[2].directGPR());
                          },
                          vectorLength, butterflyValue);
                  } else {
                      slowObjectValue = lazySlowPath(
                          [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                              return createLazyCallGenerator(vm,
<span class="line-modified">!                                 operationNewObjectWithButterfly, locations[0].directGPR(), &amp;vm,</span>
                                  CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR());
                          },
                          butterflyValue);
                  }
                  ValueFromBlock slowObject = m_out.anchor(slowObjectValue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11370,11 ***</span>
          // doesn&#39;t initialize every slot because we are guaranteed to do that here.
          VM&amp; vm = this-&gt;vm();
          LValue callResult = lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                  return createLazyCallGenerator(vm,
<span class="line-modified">!                     operationCreateActivationDirect, locations[0].directGPR(),</span>
                      CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
                      CCallHelpers::TrustedImmPtr(table),
                      CCallHelpers::TrustedImm64(JSValue::encode(jsUndefined())));
              }, scope);
          ValueFromBlock slowResult =  m_out.anchor(callResult);
<span class="line-new-header">--- 12044,11 ---</span>
          // doesn&#39;t initialize every slot because we are guaranteed to do that here.
          VM&amp; vm = this-&gt;vm();
          LValue callResult = lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                  return createLazyCallGenerator(vm,
<span class="line-modified">!                     operationCreateActivationDirect, locations[0].directGPR(), &amp;vm,</span>
                      CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
                      CCallHelpers::TrustedImmPtr(table),
                      CCallHelpers::TrustedImm64(JSValue::encode(jsUndefined())));
              }, scope);
          ValueFromBlock slowResult =  m_out.anchor(callResult);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11410,10 ***</span>
<span class="line-new-header">--- 12084,67 ---</span>
  
          mutatorFence();
          setJSValue(activation);
      }
  
<span class="line-added">+     template&lt;typename JSClass, typename Operation&gt;</span>
<span class="line-added">+     void compileMaterializeNewInternalFieldObjectImpl(Operation operation)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         ObjectMaterializationData&amp; data = m_node-&gt;objectMaterializationData();</span>
<span class="line-added">+ </span>
<span class="line-added">+         Vector&lt;LValue, JSClass::numberOfInternalFields&gt; values;</span>
<span class="line-added">+         ASSERT(data.m_properties.size() == JSClass::numberOfInternalFields);</span>
<span class="line-added">+         for (unsigned i = 0; i &lt; data.m_properties.size(); ++i)</span>
<span class="line-added">+             values.append(lowJSValue(m_graph.varArgChild(m_node, 1 + i)));</span>
<span class="line-added">+ </span>
<span class="line-added">+         RegisteredStructure structure = m_node-&gt;structure();</span>
<span class="line-added">+ </span>
<span class="line-added">+         LBasicBlock slowPath = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added">+ </span>
<span class="line-added">+         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);</span>
<span class="line-added">+ </span>
<span class="line-added">+         RELEASE_ASSERT(data.m_properties.size() == JSClass::numberOfInternalFields);</span>
<span class="line-added">+         LValue fastObject = allocateObject&lt;JSClass&gt;(structure, m_out.intPtrZero, slowPath);</span>
<span class="line-added">+         ValueFromBlock fastResult = m_out.anchor(fastObject);</span>
<span class="line-added">+         m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(slowPath, continuation);</span>
<span class="line-added">+         VM&amp; vm = this-&gt;vm();</span>
<span class="line-added">+         LValue callResult = lazySlowPath(</span>
<span class="line-added">+             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {</span>
<span class="line-added">+                 return createLazyCallGenerator(vm,</span>
<span class="line-added">+                     operation, locations[0].directGPR(), &amp;vm,</span>
<span class="line-added">+                     CCallHelpers::TrustedImmPtr(structure.get()));</span>
<span class="line-added">+             });</span>
<span class="line-added">+         ValueFromBlock slowResult = m_out.anchor(callResult);</span>
<span class="line-added">+         m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(continuation, lastNext);</span>
<span class="line-added">+         LValue object = m_out.phi(pointerType(), fastResult, slowResult);</span>
<span class="line-added">+         for (unsigned i = 0; i &lt; data.m_properties.size(); ++i) {</span>
<span class="line-added">+             PromotedLocationDescriptor descriptor = data.m_properties[i];</span>
<span class="line-added">+             ASSERT(descriptor.kind() == InternalFieldObjectPLoc);</span>
<span class="line-added">+             RELEASE_ASSERT(descriptor.info() &lt; JSClass::numberOfInternalFields);</span>
<span class="line-added">+             m_out.store64(values[i], object, m_heaps.JSInternalFieldObjectImpl_internalFields[descriptor.info()]);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         mutatorFence();</span>
<span class="line-added">+         setJSValue(object);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void compileMaterializeNewInternalFieldObject()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         switch (m_node-&gt;structure()-&gt;typeInfo().type()) {</span>
<span class="line-added">+         case JSArrayIteratorType:</span>
<span class="line-added">+             compileMaterializeNewInternalFieldObjectImpl&lt;JSArrayIterator&gt;(operationNewArrayIterator);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             DFG_CRASH(m_graph, m_node, &quot;Bad structure&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void compileCheckTraps()
      {
          ASSERT(Options::usePollingTraps());
          LBasicBlock needTrapHandling = m_out.newBlock();
          LBasicBlock continuation = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11423,13 ***</span>
              usually(continuation), rarely(needTrapHandling));
  
          LBasicBlock lastNext = m_out.appendTo(needTrapHandling, continuation);
  
          VM&amp; vm = this-&gt;vm();
          lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp;) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
<span class="line-modified">!                 return createLazyCallGenerator(vm, operationHandleTraps, InvalidGPRReg);</span>
              });
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
      }
<span class="line-new-header">--- 12154,14 ---</span>
              usually(continuation), rarely(needTrapHandling));
  
          LBasicBlock lastNext = m_out.appendTo(needTrapHandling, continuation);
  
          VM&amp; vm = this-&gt;vm();
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp;) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
<span class="line-modified">!                 return createLazyCallGenerator(vm, operationHandleTraps, InvalidGPRReg, globalObject);</span>
              });
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11441,48 ***</span>
          if (m_node-&gt;child2().useKind() == RegExpObjectUse) {
              LValue base = lowRegExpObject(m_node-&gt;child2());
  
              if (m_node-&gt;child3().useKind() == StringUse) {
                  LValue argument = lowString(m_node-&gt;child3());
<span class="line-modified">!                 LValue result = vmCall(</span>
<span class="line-removed">-                     Int64, m_out.operation(operationRegExpExecString), m_callFrame, globalObject,</span>
<span class="line-removed">-                     base, argument);</span>
                  setJSValue(result);
                  return;
              }
  
              LValue argument = lowJSValue(m_node-&gt;child3());
<span class="line-modified">!             LValue result = vmCall(</span>
<span class="line-removed">-                 Int64, m_out.operation(operationRegExpExec), m_callFrame, globalObject, base,</span>
<span class="line-removed">-                 argument);</span>
              setJSValue(result);
              return;
          }
  
          LValue base = lowJSValue(m_node-&gt;child2());
          LValue argument = lowJSValue(m_node-&gt;child3());
<span class="line-modified">!         LValue result = vmCall(</span>
<span class="line-removed">-             Int64, m_out.operation(operationRegExpExecGeneric), m_callFrame, globalObject, base,</span>
<span class="line-removed">-             argument);</span>
          setJSValue(result);
      }
  
      void compileRegExpExecNonGlobalOrSticky()
      {
          LValue globalObject = lowCell(m_node-&gt;child1());
          LValue argument = lowString(m_node-&gt;child2());
<span class="line-modified">!         LValue result = vmCall(</span>
<span class="line-removed">-             Int64, m_out.operation(operationRegExpExecNonGlobalOrSticky), m_callFrame, globalObject, frozenPointer(m_node-&gt;cellOperand()), argument);</span>
          setJSValue(result);
      }
  
      void compileRegExpMatchFastGlobal()
      {
          LValue globalObject = lowCell(m_node-&gt;child1());
          LValue argument = lowString(m_node-&gt;child2());
<span class="line-modified">!         LValue result = vmCall(</span>
<span class="line-removed">-             Int64, m_out.operation(operationRegExpMatchFastGlobalString), m_callFrame, globalObject, frozenPointer(m_node-&gt;cellOperand()), argument);</span>
          setJSValue(result);
      }
  
      void compileRegExpTest()
      {
<span class="line-new-header">--- 12173,40 ---</span>
          if (m_node-&gt;child2().useKind() == RegExpObjectUse) {
              LValue base = lowRegExpObject(m_node-&gt;child2());
  
              if (m_node-&gt;child3().useKind() == StringUse) {
                  LValue argument = lowString(m_node-&gt;child3());
<span class="line-modified">!                 LValue result = vmCall(Int64, operationRegExpExecString, globalObject, base, argument);</span>
                  setJSValue(result);
                  return;
              }
  
              LValue argument = lowJSValue(m_node-&gt;child3());
<span class="line-modified">!             LValue result = vmCall(Int64, operationRegExpExec, globalObject, base, argument);</span>
              setJSValue(result);
              return;
          }
  
          LValue base = lowJSValue(m_node-&gt;child2());
          LValue argument = lowJSValue(m_node-&gt;child3());
<span class="line-modified">!         LValue result = vmCall(Int64, operationRegExpExecGeneric, globalObject, base, argument);</span>
          setJSValue(result);
      }
  
      void compileRegExpExecNonGlobalOrSticky()
      {
          LValue globalObject = lowCell(m_node-&gt;child1());
          LValue argument = lowString(m_node-&gt;child2());
<span class="line-modified">!         LValue result = vmCall(Int64, operationRegExpExecNonGlobalOrSticky, globalObject, frozenPointer(m_node-&gt;cellOperand()), argument);</span>
          setJSValue(result);
      }
  
      void compileRegExpMatchFastGlobal()
      {
          LValue globalObject = lowCell(m_node-&gt;child1());
          LValue argument = lowString(m_node-&gt;child2());
<span class="line-modified">!         LValue result = vmCall(Int64, operationRegExpMatchFastGlobalString, globalObject, frozenPointer(m_node-&gt;cellOperand()), argument);</span>
          setJSValue(result);
      }
  
      void compileRegExpTest()
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11491,56 ***</span>
          if (m_node-&gt;child2().useKind() == RegExpObjectUse) {
              LValue base = lowRegExpObject(m_node-&gt;child2());
  
              if (m_node-&gt;child3().useKind() == StringUse) {
                  LValue argument = lowString(m_node-&gt;child3());
<span class="line-modified">!                 LValue result = vmCall(</span>
<span class="line-removed">-                     Int32, m_out.operation(operationRegExpTestString), m_callFrame, globalObject,</span>
<span class="line-removed">-                     base, argument);</span>
                  setBoolean(result);
                  return;
              }
  
              LValue argument = lowJSValue(m_node-&gt;child3());
<span class="line-modified">!             LValue result = vmCall(</span>
<span class="line-removed">-                 Int32, m_out.operation(operationRegExpTest), m_callFrame, globalObject, base,</span>
<span class="line-removed">-                 argument);</span>
              setBoolean(result);
              return;
          }
  
          LValue base = lowJSValue(m_node-&gt;child2());
          LValue argument = lowJSValue(m_node-&gt;child3());
<span class="line-modified">!         LValue result = vmCall(</span>
<span class="line-removed">-             Int32, m_out.operation(operationRegExpTestGeneric), m_callFrame, globalObject, base,</span>
<span class="line-removed">-             argument);</span>
          setBoolean(result);
      }
  
      void compileRegExpMatchFast()
      {
          LValue globalObject = lowCell(m_node-&gt;child1());
          LValue base = lowRegExpObject(m_node-&gt;child2());
          LValue argument = lowString(m_node-&gt;child3());
<span class="line-modified">!         LValue result = vmCall(</span>
<span class="line-removed">-             Int64, m_out.operation(operationRegExpMatchFastString), m_callFrame, globalObject,</span>
<span class="line-removed">-             base, argument);</span>
          setJSValue(result);
      }
  
      void compileNewRegexp()
      {
          FrozenValue* regexp = m_node-&gt;cellOperand();
          LValue lastIndex = lowJSValue(m_node-&gt;child1());
          ASSERT(regexp-&gt;cell()-&gt;inherits&lt;RegExp&gt;(vm()));
  
          LBasicBlock slowCase = m_out.newBlock();
          LBasicBlock continuation = m_out.newBlock();
  
          LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowCase);
  
<span class="line-modified">!         auto structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;regExpStructure());</span>
          LValue fastResultValue = allocateObject&lt;RegExpObject&gt;(structure, m_out.intPtrZero, slowCase);
          m_out.storePtr(frozenPointer(regexp), fastResultValue, m_heaps.RegExpObject_regExpAndLastIndexIsNotWritableFlag);
          m_out.store64(lastIndex, fastResultValue, m_heaps.RegExpObject_lastIndex);
          mutatorFence();
          ValueFromBlock fastResult = m_out.anchor(fastResultValue);
<span class="line-new-header">--- 12215,49 ---</span>
          if (m_node-&gt;child2().useKind() == RegExpObjectUse) {
              LValue base = lowRegExpObject(m_node-&gt;child2());
  
              if (m_node-&gt;child3().useKind() == StringUse) {
                  LValue argument = lowString(m_node-&gt;child3());
<span class="line-modified">!                 LValue result = vmCall(Int32, operationRegExpTestString, globalObject, base, argument);</span>
                  setBoolean(result);
                  return;
              }
  
              LValue argument = lowJSValue(m_node-&gt;child3());
<span class="line-modified">!             LValue result = vmCall(Int32, operationRegExpTest, globalObject, base, argument);</span>
              setBoolean(result);
              return;
          }
  
          LValue base = lowJSValue(m_node-&gt;child2());
          LValue argument = lowJSValue(m_node-&gt;child3());
<span class="line-modified">!         LValue result = vmCall(Int32, operationRegExpTestGeneric, globalObject, base, argument);</span>
          setBoolean(result);
      }
  
      void compileRegExpMatchFast()
      {
          LValue globalObject = lowCell(m_node-&gt;child1());
          LValue base = lowRegExpObject(m_node-&gt;child2());
          LValue argument = lowString(m_node-&gt;child3());
<span class="line-modified">!         LValue result = vmCall(Int64, operationRegExpMatchFastString, globalObject, base, argument);</span>
          setJSValue(result);
      }
  
      void compileNewRegexp()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          FrozenValue* regexp = m_node-&gt;cellOperand();
          LValue lastIndex = lowJSValue(m_node-&gt;child1());
          ASSERT(regexp-&gt;cell()-&gt;inherits&lt;RegExp&gt;(vm()));
  
          LBasicBlock slowCase = m_out.newBlock();
          LBasicBlock continuation = m_out.newBlock();
  
          LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowCase);
  
<span class="line-modified">!         auto structure = m_graph.registerStructure(globalObject-&gt;regExpStructure());</span>
          LValue fastResultValue = allocateObject&lt;RegExpObject&gt;(structure, m_out.intPtrZero, slowCase);
          m_out.storePtr(frozenPointer(regexp), fastResultValue, m_heaps.RegExpObject_regExpAndLastIndexIsNotWritableFlag);
          m_out.store64(lastIndex, fastResultValue, m_heaps.RegExpObject_lastIndex);
          mutatorFence();
          ValueFromBlock fastResult = m_out.anchor(fastResultValue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11550,11 ***</span>
          VM&amp; vm = this-&gt;vm();
          RegExp* regexpCell = regexp-&gt;cast&lt;RegExp*&gt;();
          LValue slowResultValue = lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                  return createLazyCallGenerator(vm,
<span class="line-modified">!                     operationNewRegexpWithLastIndex, locations[0].directGPR(),</span>
                      CCallHelpers::TrustedImmPtr(regexpCell), locations[1].directGPR());
              }, lastIndex);
          ValueFromBlock slowResult = m_out.anchor(slowResultValue);
          m_out.jump(continuation);
  
<span class="line-new-header">--- 12267,11 ---</span>
          VM&amp; vm = this-&gt;vm();
          RegExp* regexpCell = regexp-&gt;cast&lt;RegExp*&gt;();
          LValue slowResultValue = lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                  return createLazyCallGenerator(vm,
<span class="line-modified">!                     operationNewRegexpWithLastIndex, locations[0].directGPR(), globalObject,</span>
                      CCallHelpers::TrustedImmPtr(regexpCell), locations[1].directGPR());
              }, lastIndex);
          ValueFromBlock slowResult = m_out.anchor(slowResultValue);
          m_out.jump(continuation);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11562,41 ***</span>
          setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
      }
  
      void compileSetFunctionName()
      {
<span class="line-modified">!         vmCall(Void, m_out.operation(operationSetFunctionName), m_callFrame,</span>
              lowCell(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2()));
      }
  
      void compileStringReplace()
      {
          if (m_node-&gt;child1().useKind() == StringUse
              &amp;&amp; m_node-&gt;child2().useKind() == RegExpObjectUse
              &amp;&amp; m_node-&gt;child3().useKind() == StringUse) {
  
              if (JSString* replace = m_node-&gt;child3()-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {
                  if (!replace-&gt;length()) {
                      LValue string = lowString(m_node-&gt;child1());
                      LValue regExp = lowRegExpObject(m_node-&gt;child2());
  
<span class="line-modified">!                     LValue result = vmCall(</span>
<span class="line-removed">-                         pointerType(), m_out.operation(operationStringProtoFuncReplaceRegExpEmptyStr),</span>
<span class="line-removed">-                         m_callFrame, string, regExp);</span>
  
                      setJSValue(result);
                      return;
                  }
              }
  
              LValue string = lowString(m_node-&gt;child1());
              LValue regExp = lowRegExpObject(m_node-&gt;child2());
              LValue replace = lowString(m_node-&gt;child3());
  
<span class="line-modified">!             LValue result = vmCall(</span>
<span class="line-removed">-                 pointerType(), m_out.operation(operationStringProtoFuncReplaceRegExpString),</span>
<span class="line-removed">-                 m_callFrame, string, regExp, replace);</span>
  
              setJSValue(result);
              return;
          }
  
<span class="line-new-header">--- 12279,39 ---</span>
          setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
      }
  
      void compileSetFunctionName()
      {
<span class="line-modified">!         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added">+         vmCall(Void, operationSetFunctionName, weakPointer(globalObject),</span>
              lowCell(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2()));
      }
  
      void compileStringReplace()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;child1().useKind() == StringUse
              &amp;&amp; m_node-&gt;child2().useKind() == RegExpObjectUse
              &amp;&amp; m_node-&gt;child3().useKind() == StringUse) {
  
              if (JSString* replace = m_node-&gt;child3()-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {
                  if (!replace-&gt;length()) {
                      LValue string = lowString(m_node-&gt;child1());
                      LValue regExp = lowRegExpObject(m_node-&gt;child2());
  
<span class="line-modified">!                     LValue result = vmCall(pointerType(), operationStringProtoFuncReplaceRegExpEmptyStr, weakPointer(globalObject), string, regExp);</span>
  
                      setJSValue(result);
                      return;
                  }
              }
  
              LValue string = lowString(m_node-&gt;child1());
              LValue regExp = lowRegExpObject(m_node-&gt;child2());
              LValue replace = lowString(m_node-&gt;child3());
  
<span class="line-modified">!             LValue result = vmCall(pointerType(), operationStringProtoFuncReplaceRegExpString, weakPointer(globalObject), string, regExp, replace);</span>
  
              setJSValue(result);
              return;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11605,11 ***</span>
              search = lowString(m_node-&gt;child2());
          else
              search = lowJSValue(m_node-&gt;child2());
  
          LValue result = vmCall(
<span class="line-modified">!             pointerType(), m_out.operation(operationStringProtoFuncReplaceGeneric), m_callFrame,</span>
              lowJSValue(m_node-&gt;child1()), search,
              lowJSValue(m_node-&gt;child3()));
  
          setJSValue(result);
      }
<span class="line-new-header">--- 12320,12 ---</span>
              search = lowString(m_node-&gt;child2());
          else
              search = lowJSValue(m_node-&gt;child2());
  
          LValue result = vmCall(
<span class="line-modified">!             pointerType(), operationStringProtoFuncReplaceGeneric,</span>
<span class="line-added">+             weakPointer(globalObject),</span>
              lowJSValue(m_node-&gt;child1()), search,
              lowJSValue(m_node-&gt;child3()));
  
          setJSValue(result);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11642,12 ***</span>
      {
          LValue packet = ensureShadowChickenPacket();
          LValue scope = lowCell(m_node-&gt;child1());
  
          m_out.storePtr(m_callFrame, packet, m_heaps.ShadowChicken_Packet_frame);
<span class="line-modified">!         m_out.storePtr(m_out.loadPtr(addressFor(0)), packet, m_heaps.ShadowChicken_Packet_callerFrame);</span>
<span class="line-modified">!         m_out.storePtr(m_out.loadPtr(payloadFor(CallFrameSlot::callee)), packet, m_heaps.ShadowChicken_Packet_callee);</span>
          m_out.storePtr(scope, packet, m_heaps.ShadowChicken_Packet_scope);
      }
  
      void compileLogShadowChickenTail()
      {
<span class="line-new-header">--- 12358,12 ---</span>
      {
          LValue packet = ensureShadowChickenPacket();
          LValue scope = lowCell(m_node-&gt;child1());
  
          m_out.storePtr(m_callFrame, packet, m_heaps.ShadowChicken_Packet_frame);
<span class="line-modified">!         m_out.storePtr(m_out.loadPtr(addressFor(VirtualRegister(0))), packet, m_heaps.ShadowChicken_Packet_callerFrame);</span>
<span class="line-modified">!         m_out.storePtr(m_out.loadPtr(payloadFor(VirtualRegister(CallFrameSlot::callee))), packet, m_heaps.ShadowChicken_Packet_callee);</span>
          m_out.storePtr(scope, packet, m_heaps.ShadowChicken_Packet_scope);
      }
  
      void compileLogShadowChickenTail()
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11704,20 ***</span>
      ArgumentsLength getArgumentsLength(InlineCallFrame* inlineCallFrame)
      {
          ArgumentsLength length;
  
          if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
<span class="line-modified">!             length.known = inlineCallFrame-&gt;argumentCountIncludingThis - 1;</span>
              length.isKnown = true;
              length.value = m_out.constInt32(length.known);
          } else {
              length.known = UINT_MAX;
              length.isKnown = false;
  
              VirtualRegister argumentCountRegister;
              if (!inlineCallFrame)
<span class="line-modified">!                 argumentCountRegister = VirtualRegister(CallFrameSlot::argumentCount);</span>
              else
                  argumentCountRegister = inlineCallFrame-&gt;argumentCountRegister;
              length.value = m_out.sub(m_out.load32(payloadFor(argumentCountRegister)), m_out.int32One);
          }
  
<span class="line-new-header">--- 12420,20 ---</span>
      ArgumentsLength getArgumentsLength(InlineCallFrame* inlineCallFrame)
      {
          ArgumentsLength length;
  
          if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
<span class="line-modified">!             length.known = static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1);</span>
              length.isKnown = true;
              length.value = m_out.constInt32(length.known);
          } else {
              length.known = UINT_MAX;
              length.isKnown = false;
  
              VirtualRegister argumentCountRegister;
              if (!inlineCallFrame)
<span class="line-modified">!                 argumentCountRegister = VirtualRegister(CallFrameSlot::argumentCountIncludingThis);</span>
              else
                  argumentCountRegister = inlineCallFrame-&gt;argumentCountRegister;
              length.value = m_out.sub(m_out.load32(payloadFor(argumentCountRegister)), m_out.int32One);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11734,11 ***</span>
          if (InlineCallFrame* frame = m_node-&gt;origin.semantic.inlineCallFrame()) {
              if (frame-&gt;isClosureCall)
                  return m_out.loadPtr(addressFor(frame-&gt;calleeRecovery.virtualRegister()));
              return weakPointer(frame-&gt;calleeRecovery.constant().asCell());
          }
<span class="line-modified">!         return m_out.loadPtr(addressFor(CallFrameSlot::callee));</span>
      }
  
      LValue getArgumentsStart(InlineCallFrame* inlineCallFrame, unsigned offset = 0)
      {
          VirtualRegister start = AssemblyHelpers::argumentsStart(inlineCallFrame) + offset;
<span class="line-new-header">--- 12450,11 ---</span>
          if (InlineCallFrame* frame = m_node-&gt;origin.semantic.inlineCallFrame()) {
              if (frame-&gt;isClosureCall)
                  return m_out.loadPtr(addressFor(frame-&gt;calleeRecovery.virtualRegister()));
              return weakPointer(frame-&gt;calleeRecovery.constant().asCell());
          }
<span class="line-modified">!         return m_out.loadPtr(addressFor(VirtualRegister(CallFrameSlot::callee)));</span>
      }
  
      LValue getArgumentsStart(InlineCallFrame* inlineCallFrame, unsigned offset = 0)
      {
          VirtualRegister start = AssemblyHelpers::argumentsStart(inlineCallFrame) + offset;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11949,12 ***</span>
      LValue allocatePropertyStorage(LValue object, Structure* previousStructure)
      {
          if (previousStructure-&gt;couldHaveIndexingHeader()) {
              return vmCall(
                  pointerType(),
<span class="line-modified">!                 m_out.operation(operationAllocateComplexPropertyStorageWithInitialCapacity),</span>
<span class="line-modified">!                 m_callFrame, object);</span>
          }
  
          LValue result = allocatePropertyStorageWithSizeImpl(initialOutOfLineCapacity);
  
          splatWords(
<span class="line-new-header">--- 12665,12 ---</span>
      LValue allocatePropertyStorage(LValue object, Structure* previousStructure)
      {
          if (previousStructure-&gt;couldHaveIndexingHeader()) {
              return vmCall(
                  pointerType(),
<span class="line-modified">!                 operationAllocateComplexPropertyStorageWithInitialCapacity,</span>
<span class="line-modified">!                 m_vmValue, object);</span>
          }
  
          LValue result = allocatePropertyStorageWithSizeImpl(initialOutOfLineCapacity);
  
          splatWords(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11973,11 ***</span>
  
          ASSERT_UNUSED(next, newSize == next-&gt;outOfLineCapacity());
  
          if (previous-&gt;couldHaveIndexingHeader()) {
              LValue newAllocSize = m_out.constIntPtr(newSize);
<span class="line-modified">!             return vmCall(pointerType(), m_out.operation(operationAllocateComplexPropertyStorage), m_callFrame, object, newAllocSize);</span>
          }
  
          LValue result = allocatePropertyStorageWithSizeImpl(newSize);
  
          ptrdiff_t headerSize = -sizeof(IndexingHeader) - sizeof(void*);
<span class="line-new-header">--- 12689,11 ---</span>
  
          ASSERT_UNUSED(next, newSize == next-&gt;outOfLineCapacity());
  
          if (previous-&gt;couldHaveIndexingHeader()) {
              LValue newAllocSize = m_out.constIntPtr(newSize);
<span class="line-modified">!             return vmCall(pointerType(), operationAllocateComplexPropertyStorage, m_vmValue, object, newAllocSize);</span>
          }
  
          LValue result = allocatePropertyStorageWithSizeImpl(newSize);
  
          ptrdiff_t headerSize = -sizeof(IndexingHeader) - sizeof(void*);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12019,17 ***</span>
          if (sizeInValues == initialOutOfLineCapacity) {
              slowButterflyValue = lazySlowPath(
                  [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                      return createLazyCallGenerator(vm,
                          operationAllocateSimplePropertyStorageWithInitialCapacity,
<span class="line-modified">!                         locations[0].directGPR());</span>
                  });
          } else {
              slowButterflyValue = lazySlowPath(
                  [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                      return createLazyCallGenerator(vm,
<span class="line-modified">!                         operationAllocateSimplePropertyStorage, locations[0].directGPR(),</span>
                          CCallHelpers::TrustedImmPtr(sizeInValues));
                  });
          }
          ValueFromBlock slowButterfly = m_out.anchor(slowButterflyValue);
  
<span class="line-new-header">--- 12735,17 ---</span>
          if (sizeInValues == initialOutOfLineCapacity) {
              slowButterflyValue = lazySlowPath(
                  [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                      return createLazyCallGenerator(vm,
                          operationAllocateSimplePropertyStorageWithInitialCapacity,
<span class="line-modified">!                         locations[0].directGPR(), &amp;vm);</span>
                  });
          } else {
              slowButterflyValue = lazySlowPath(
                  [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                      return createLazyCallGenerator(vm,
<span class="line-modified">!                         operationAllocateSimplePropertyStorage, locations[0].directGPR(), &amp;vm,</span>
                          CCallHelpers::TrustedImmPtr(sizeInValues));
                  });
          }
          ValueFromBlock slowButterfly = m_out.anchor(slowButterflyValue);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12045,12 ***</span>
          Node* node = m_node;
          UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(base);
<span class="line-modified">!         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));</span>
  
          // FIXME: If this is a GetByIdFlush/GetByIdDirectFlush, we might get some performance boost if we claim that it
          // clobbers volatile registers late. It&#39;s not necessary for correctness, though, since the
          // IC code is super smart about saving registers.
          // https://bugs.webkit.org/show_bug.cgi?id=152848
<span class="line-new-header">--- 12761,12 ---</span>
          Node* node = m_node;
          UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(base);
<span class="line-modified">!         patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
  
          // FIXME: If this is a GetByIdFlush/GetByIdDirectFlush, we might get some performance boost if we claim that it
          // clobbers volatile registers late. It&#39;s not necessary for correctness, though, since the
          // IC code is super smart about saving registers.
          // https://bugs.webkit.org/show_bug.cgi?id=152848
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12087,17 ***</span>
  
                  params.addLatePath(
                      [=] (CCallHelpers&amp; jit) {
                          AllowMacroScratchRegisterUsage allowScratch(jit);
  
<span class="line-modified">!                         J_JITOperation_ESsiJI optimizationFunction = appropriateOptimizingGetByIdFunction(type);</span>
  
                          generator-&gt;slowPathJump().link(&amp;jit);
                          CCallHelpers::Label slowPathBegin = jit.label();
                          CCallHelpers::Call slowPathCall = callOperation(
                              *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
                              exceptions.get(), optimizationFunction, params[0].gpr(),
                              CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), params[1].gpr(),
                              CCallHelpers::TrustedImmPtr(uid)).call();
                          jit.jump().linkTo(done, &amp;jit);
  
                          generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
<span class="line-new-header">--- 12803,18 ---</span>
  
                  params.addLatePath(
                      [=] (CCallHelpers&amp; jit) {
                          AllowMacroScratchRegisterUsage allowScratch(jit);
  
<span class="line-modified">!                         J_JITOperation_GSsiJI optimizationFunction = appropriateOptimizingGetByIdFunction(type);</span>
  
                          generator-&gt;slowPathJump().link(&amp;jit);
                          CCallHelpers::Label slowPathBegin = jit.label();
                          CCallHelpers::Call slowPathCall = callOperation(
                              *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
                              exceptions.get(), optimizationFunction, params[0].gpr(),
<span class="line-added">+                             jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic),</span>
                              CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), params[1].gpr(),
                              CCallHelpers::TrustedImmPtr(uid)).call();
                          jit.jump().linkTo(done, &amp;jit);
  
                          generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12118,12 ***</span>
          UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(base);
          patchpoint-&gt;appendSomeRegister(thisValue);
<span class="line-modified">!         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));</span>
  
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
<span class="line-new-header">--- 12835,12 ---</span>
          UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(base);
          patchpoint-&gt;appendSomeRegister(thisValue);
<span class="line-modified">!         patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
  
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
  
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12146,26 ***</span>
                  exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
  
                  auto generator = Box&lt;JITGetByIdWithThisGenerator&gt;::create(
                      jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex,
                      params.unavailableRegisters(), uid, JSValueRegs(params[0].gpr()),
<span class="line-modified">!                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()), AccessType::GetWithThis);</span>
  
                  generator-&gt;generateFastPath(jit);
                  CCallHelpers::Label done = jit.label();
  
                  params.addLatePath(
                      [=] (CCallHelpers&amp; jit) {
                          AllowMacroScratchRegisterUsage allowScratch(jit);
  
<span class="line-modified">!                         J_JITOperation_ESsiJJI optimizationFunction = operationGetByIdWithThisOptimize;</span>
  
                          generator-&gt;slowPathJump().link(&amp;jit);
                          CCallHelpers::Label slowPathBegin = jit.label();
                          CCallHelpers::Call slowPathCall = callOperation(
                              *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
                              exceptions.get(), optimizationFunction, params[0].gpr(),
                              CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), params[1].gpr(),
                              params[2].gpr(), CCallHelpers::TrustedImmPtr(uid)).call();
                          jit.jump().linkTo(done, &amp;jit);
  
                          generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
<span class="line-new-header">--- 12863,27 ---</span>
                  exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
  
                  auto generator = Box&lt;JITGetByIdWithThisGenerator&gt;::create(
                      jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex,
                      params.unavailableRegisters(), uid, JSValueRegs(params[0].gpr()),
<span class="line-modified">!                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()));</span>
  
                  generator-&gt;generateFastPath(jit);
                  CCallHelpers::Label done = jit.label();
  
                  params.addLatePath(
                      [=] (CCallHelpers&amp; jit) {
                          AllowMacroScratchRegisterUsage allowScratch(jit);
  
<span class="line-modified">!                         J_JITOperation_GSsiJJI optimizationFunction = operationGetByIdWithThisOptimize;</span>
  
                          generator-&gt;slowPathJump().link(&amp;jit);
                          CCallHelpers::Label slowPathBegin = jit.label();
                          CCallHelpers::Call slowPathCall = callOperation(
                              *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
                              exceptions.get(), optimizationFunction, params[0].gpr(),
<span class="line-added">+                             jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic),</span>
                              CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), params[1].gpr(),
                              params[2].gpr(), CCallHelpers::TrustedImmPtr(uid)).call();
                          jit.jump().linkTo(done, &amp;jit);
  
                          generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12195,13 ***</span>
  
      template&lt;typename IntFunctor, typename DoubleFunctor&gt;
      void compare(
          const IntFunctor&amp; intFunctor, const DoubleFunctor&amp; doubleFunctor,
          C_JITOperation_TT stringIdentFunction,
<span class="line-modified">!         C_JITOperation_B_EJssJss stringFunction,</span>
<span class="line-modified">!         S_JITOperation_EJJ fallbackFunction)</span>
      {
          if (m_node-&gt;isBinaryUseKind(Int32Use)) {
              LValue left = lowInt32(m_node-&gt;child1());
              LValue right = lowInt32(m_node-&gt;child2());
              setBoolean(intFunctor(left, right));
              return;
<span class="line-new-header">--- 12913,14 ---</span>
  
      template&lt;typename IntFunctor, typename DoubleFunctor&gt;
      void compare(
          const IntFunctor&amp; intFunctor, const DoubleFunctor&amp; doubleFunctor,
          C_JITOperation_TT stringIdentFunction,
<span class="line-modified">!         C_JITOperation_B_GJssJss stringFunction,</span>
<span class="line-modified">!         S_JITOperation_GJJ fallbackFunction)</span>
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (m_node-&gt;isBinaryUseKind(Int32Use)) {
              LValue left = lowInt32(m_node-&gt;child1());
              LValue right = lowInt32(m_node-&gt;child2());
              setBoolean(intFunctor(left, right));
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12234,22 ***</span>
              LValue right = lowCell(m_node-&gt;child2());
              speculateString(m_node-&gt;child1(), left);
              speculateString(m_node-&gt;child2(), right);
  
              LValue result = vmCall(
<span class="line-modified">!                 Int32, m_out.operation(stringFunction),</span>
<span class="line-modified">!                 m_callFrame, left, right);</span>
              setBoolean(result);
              return;
          }
  
          DFG_ASSERT(m_graph, m_node, m_node-&gt;isBinaryUseKind(UntypedUse), m_node-&gt;child1().useKind(), m_node-&gt;child2().useKind());
          nonSpeculativeCompare(intFunctor, fallbackFunction);
      }
  
      void compileStringSlice()
      {
          LBasicBlock lengthCheckCase = m_out.newBlock();
          LBasicBlock emptyCase = m_out.newBlock();
          LBasicBlock notEmptyCase = m_out.newBlock();
          LBasicBlock oneCharCase = m_out.newBlock();
          LBasicBlock is8Bit = m_out.newBlock();
<span class="line-new-header">--- 12953,23 ---</span>
              LValue right = lowCell(m_node-&gt;child2());
              speculateString(m_node-&gt;child1(), left);
              speculateString(m_node-&gt;child2(), right);
  
              LValue result = vmCall(
<span class="line-modified">!                 Int32, stringFunction,</span>
<span class="line-modified">!                 weakPointer(globalObject), left, right);</span>
              setBoolean(result);
              return;
          }
  
          DFG_ASSERT(m_graph, m_node, m_node-&gt;isBinaryUseKind(UntypedUse), m_node-&gt;child1().useKind(), m_node-&gt;child2().useKind());
          nonSpeculativeCompare(intFunctor, fallbackFunction);
      }
  
      void compileStringSlice()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LBasicBlock lengthCheckCase = m_out.newBlock();
          LBasicBlock emptyCase = m_out.newBlock();
          LBasicBlock notEmptyCase = m_out.newBlock();
          LBasicBlock oneCharCase = m_out.newBlock();
          LBasicBlock is8Bit = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12306,35 ***</span>
              m_out.above(char16BitValue, m_out.constInt32(maxSingleCharacterString)),
              rarely(bigCharacter), usually(bitsContinuation));
  
          m_out.appendTo(bigCharacter, bitsContinuation);
          results.append(m_out.anchor(vmCall(
<span class="line-modified">!             Int64, m_out.operation(operationSingleCharacterString),</span>
<span class="line-modified">!             m_callFrame, char16BitValue)));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(bitsContinuation, slowCase);
          LValue character = m_out.phi(Int32, char8Bit, char16Bit);
          LValue smallStrings = m_out.constIntPtr(vm().smallStrings.singleCharacterStrings());
          results.append(m_out.anchor(m_out.loadPtr(m_out.baseIndex(
              m_heaps.singleCharacterStrings, smallStrings, m_out.zeroExtPtr(character)))));
          m_out.jump(continuation);
  
          m_out.appendTo(slowCase, ropeSlowCase);
<span class="line-modified">!         results.append(m_out.anchor(vmCall(pointerType(), m_out.operation(operationStringSubstr), m_callFrame, string, from, span)));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(ropeSlowCase, continuation);
<span class="line-modified">!         results.append(m_out.anchor(vmCall(pointerType(), m_out.operation(operationStringSlice), m_callFrame, string, start, end)));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setJSValue(m_out.phi(pointerType(), results));
      }
  
      void compileToLowerCase()
      {
          LBasicBlock notRope = m_out.newBlock();
          LBasicBlock is8Bit = m_out.newBlock();
          LBasicBlock loopTop = m_out.newBlock();
          LBasicBlock loopBody = m_out.newBlock();
          LBasicBlock slowPath = m_out.newBlock();
<span class="line-new-header">--- 13026,36 ---</span>
              m_out.above(char16BitValue, m_out.constInt32(maxSingleCharacterString)),
              rarely(bigCharacter), usually(bitsContinuation));
  
          m_out.appendTo(bigCharacter, bitsContinuation);
          results.append(m_out.anchor(vmCall(
<span class="line-modified">!             Int64, operationSingleCharacterString,</span>
<span class="line-modified">!             m_vmValue, char16BitValue)));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(bitsContinuation, slowCase);
          LValue character = m_out.phi(Int32, char8Bit, char16Bit);
          LValue smallStrings = m_out.constIntPtr(vm().smallStrings.singleCharacterStrings());
          results.append(m_out.anchor(m_out.loadPtr(m_out.baseIndex(
              m_heaps.singleCharacterStrings, smallStrings, m_out.zeroExtPtr(character)))));
          m_out.jump(continuation);
  
          m_out.appendTo(slowCase, ropeSlowCase);
<span class="line-modified">!         results.append(m_out.anchor(vmCall(pointerType(), operationStringSubstr, weakPointer(globalObject), string, from, span)));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(ropeSlowCase, continuation);
<span class="line-modified">!         results.append(m_out.anchor(vmCall(pointerType(), operationStringSlice, weakPointer(globalObject), string, start, end)));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setJSValue(m_out.phi(pointerType(), results));
      }
  
      void compileToLowerCase()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LBasicBlock notRope = m_out.newBlock();
          LBasicBlock is8Bit = m_out.newBlock();
          LBasicBlock loopTop = m_out.newBlock();
          LBasicBlock loopBody = m_out.newBlock();
          LBasicBlock slowPath = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12377,11 ***</span>
          m_out.addIncomingToPhi(index, m_out.anchor(m_out.add(index, m_out.int32One)));
          m_out.branch(isBadCharacter, unsure(slowPath), unsure(loopTop));
  
          m_out.appendTo(slowPath, continuation);
          LValue slowPathIndex = m_out.phi(Int32, startIndexForCall, indexFromBlock);
<span class="line-modified">!         ValueFromBlock slowResult = m_out.anchor(vmCall(pointerType(), m_out.operation(operationToLowerCase), m_callFrame, string, slowPathIndex));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
      }
<span class="line-new-header">--- 13098,11 ---</span>
          m_out.addIncomingToPhi(index, m_out.anchor(m_out.add(index, m_out.int32One)));
          m_out.branch(isBadCharacter, unsure(slowPath), unsure(loopTop));
  
          m_out.appendTo(slowPath, continuation);
          LValue slowPathIndex = m_out.phi(Int32, startIndexForCall, indexFromBlock);
<span class="line-modified">!         ValueFromBlock slowResult = m_out.anchor(vmCall(pointerType(), operationToLowerCase, weakPointer(globalObject), string, slowPathIndex));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12393,67 ***</span>
              int32_t radix = m_node-&gt;child2()-&gt;asInt32();
              if (radix &gt;= 2 &amp;&amp; radix &lt;= 36)
                  validRadixIsGuaranteed = true;
          }
  
          switch (m_node-&gt;child1().useKind()) {
          case Int32Use:
<span class="line-modified">!             setJSValue(vmCall(pointerType(), m_out.operation(validRadixIsGuaranteed ? operationInt32ToStringWithValidRadix : operationInt32ToString), m_callFrame, lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));</span>
              break;
          case Int52RepUse:
<span class="line-modified">!             setJSValue(vmCall(pointerType(), m_out.operation(validRadixIsGuaranteed ? operationInt52ToStringWithValidRadix : operationInt52ToString), m_callFrame, lowStrictInt52(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));</span>
              break;
          case DoubleRepUse:
<span class="line-modified">!             setJSValue(vmCall(pointerType(), m_out.operation(validRadixIsGuaranteed ? operationDoubleToStringWithValidRadix : operationDoubleToString), m_callFrame, lowDouble(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
          }
      }
  
      void compileNumberToStringWithValidRadixConstant()
      {
          switch (m_node-&gt;child1().useKind()) {
          case Int32Use:
<span class="line-modified">!             setJSValue(vmCall(pointerType(), m_out.operation(operationInt32ToStringWithValidRadix), m_callFrame, lowInt32(m_node-&gt;child1()), m_out.constInt32(m_node-&gt;validRadixConstant())));</span>
              break;
          case Int52RepUse:
<span class="line-modified">!             setJSValue(vmCall(pointerType(), m_out.operation(operationInt52ToStringWithValidRadix), m_callFrame, lowStrictInt52(m_node-&gt;child1()), m_out.constInt32(m_node-&gt;validRadixConstant())));</span>
              break;
          case DoubleRepUse:
<span class="line-modified">!             setJSValue(vmCall(pointerType(), m_out.operation(operationDoubleToStringWithValidRadix), m_callFrame, lowDouble(m_node-&gt;child1()), m_out.constInt32(m_node-&gt;validRadixConstant())));</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
          }
      }
  
      void compileResolveScopeForHoistingFuncDeclInEval()
      {
          UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<span class="line-modified">!         setJSValue(vmCall(pointerType(), m_out.operation(operationResolveScopeForHoistingFuncDeclInEval), m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid)));</span>
      }
  
      void compileResolveScope()
      {
          UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<span class="line-modified">!         setJSValue(vmCall(pointerType(), m_out.operation(operationResolveScope),</span>
<span class="line-modified">!             m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid)));</span>
      }
  
      void compileGetDynamicVar()
      {
          UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<span class="line-modified">!         setJSValue(vmCall(Int64, m_out.operation(operationGetDynamicVar),</span>
<span class="line-modified">!             m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;getPutInfo())));</span>
      }
  
      void compilePutDynamicVar()
      {
          UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<span class="line-modified">!         setJSValue(vmCall(Void, m_out.operation(m_graph.isStrictModeFor(m_node-&gt;origin.semantic) ? operationPutDynamicVarStrict : operationPutDynamicVarNonStrict),</span>
<span class="line-modified">!             m_callFrame, lowCell(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2()), m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;getPutInfo())));</span>
      }
  
      void compileUnreachable()
      {
          // It&#39;s so tempting to assert that AI has proved that this is unreachable. But that&#39;s
<span class="line-new-header">--- 13114,73 ---</span>
              int32_t radix = m_node-&gt;child2()-&gt;asInt32();
              if (radix &gt;= 2 &amp;&amp; radix &lt;= 36)
                  validRadixIsGuaranteed = true;
          }
  
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          switch (m_node-&gt;child1().useKind()) {
          case Int32Use:
<span class="line-modified">!             setJSValue(vmCall(pointerType(), validRadixIsGuaranteed ? operationInt32ToStringWithValidRadix : operationInt32ToString, weakPointer(globalObject), lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));</span>
              break;
          case Int52RepUse:
<span class="line-modified">!             setJSValue(vmCall(pointerType(), validRadixIsGuaranteed ? operationInt52ToStringWithValidRadix : operationInt52ToString, weakPointer(globalObject), lowStrictInt52(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));</span>
              break;
          case DoubleRepUse:
<span class="line-modified">!             setJSValue(vmCall(pointerType(), validRadixIsGuaranteed ? operationDoubleToStringWithValidRadix : operationDoubleToString, weakPointer(globalObject), lowDouble(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
          }
      }
  
      void compileNumberToStringWithValidRadixConstant()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          switch (m_node-&gt;child1().useKind()) {
          case Int32Use:
<span class="line-modified">!             setJSValue(vmCall(pointerType(), operationInt32ToStringWithValidRadix, weakPointer(globalObject), lowInt32(m_node-&gt;child1()), m_out.constInt32(m_node-&gt;validRadixConstant())));</span>
              break;
          case Int52RepUse:
<span class="line-modified">!             setJSValue(vmCall(pointerType(), operationInt52ToStringWithValidRadix, weakPointer(globalObject), lowStrictInt52(m_node-&gt;child1()), m_out.constInt32(m_node-&gt;validRadixConstant())));</span>
              break;
          case DoubleRepUse:
<span class="line-modified">!             setJSValue(vmCall(pointerType(), operationDoubleToStringWithValidRadix, weakPointer(globalObject), lowDouble(m_node-&gt;child1()), m_out.constInt32(m_node-&gt;validRadixConstant())));</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
          }
      }
  
      void compileResolveScopeForHoistingFuncDeclInEval()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<span class="line-modified">!         setJSValue(vmCall(pointerType(), operationResolveScopeForHoistingFuncDeclInEval, weakPointer(globalObject), lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid)));</span>
      }
  
      void compileResolveScope()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<span class="line-modified">!         setJSValue(vmCall(pointerType(), operationResolveScope,</span>
<span class="line-modified">!             weakPointer(globalObject), lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid)));</span>
      }
  
      void compileGetDynamicVar()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<span class="line-modified">!         setJSValue(vmCall(Int64, operationGetDynamicVar,</span>
<span class="line-modified">!             weakPointer(globalObject), lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;getPutInfo())));</span>
      }
  
      void compilePutDynamicVar()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<span class="line-modified">!         setJSValue(vmCall(Void, m_graph.isStrictModeFor(m_node-&gt;origin.semantic) ? operationPutDynamicVarStrict : operationPutDynamicVarNonStrict,</span>
<span class="line-modified">!             weakPointer(globalObject), lowCell(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2()), m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;getPutInfo())));</span>
      }
  
      void compileUnreachable()
      {
          // It&#39;s so tempting to assert that AI has proved that this is unreachable. But that&#39;s
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12500,12 ***</span>
          }
  
          RefPtr&lt;Snippet&gt; domJIT = classInfo-&gt;checkSubClassSnippet();
          PatchpointValue* patchpoint = m_out.patchpoint(Void);
          patchpoint-&gt;appendSomeRegister(cell);
<span class="line-modified">!         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));</span>
  
          NodeOrigin origin = m_origin;
          unsigned osrExitArgumentOffset = patchpoint-&gt;numChildren();
          OSRExitDescriptor* exitDescriptor = appendOSRExitDescriptor(jsValueValue(cell), m_node-&gt;child1().node());
          patchpoint-&gt;appendColdAnys(buildExitArguments(exitDescriptor, origin.forExit, jsValueValue(cell)));
<span class="line-new-header">--- 13227,12 ---</span>
          }
  
          RefPtr&lt;Snippet&gt; domJIT = classInfo-&gt;checkSubClassSnippet();
          PatchpointValue* patchpoint = m_out.patchpoint(Void);
          patchpoint-&gt;appendSomeRegister(cell);
<span class="line-modified">!         patchpoint-&gt;append(m_notCellMask, ValueRep::reg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_numberTag, ValueRep::reg(GPRInfo::numberTagRegister));</span>
  
          NodeOrigin origin = m_origin;
          unsigned osrExitArgumentOffset = patchpoint-&gt;numChildren();
          OSRExitDescriptor* exitDescriptor = appendOSRExitDescriptor(jsValueValue(cell), m_node-&gt;child1().node());
          patchpoint-&gt;appendColdAnys(buildExitArguments(exitDescriptor, origin.forExit, jsValueValue(cell)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12546,10 ***</span>
<span class="line-new-header">--- 13273,11 ---</span>
          patchpoint-&gt;effects = Effects::forCheck();
      }
  
      void compileCallDOM()
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          const DOMJIT::Signature* signature = m_node-&gt;signature();
  
          // FIXME: We should have a way to call functions with the vector of registers.
          // https://bugs.webkit.org/show_bug.cgi?id=163099
          Vector&lt;LValue, JSC_DOMJIT_SIGNATURE_MAX_ARGUMENTS_INCLUDING_THIS&gt; operands;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12577,20 ***</span>
              ++index;
          });
  
          unsigned argumentCountIncludingThis = signature-&gt;argumentCount + 1;
          LValue result;
          auto function = CFunctionPtr(signature-&gt;functionWithoutTypeCheck);
          switch (argumentCountIncludingThis) {
          case 1:
<span class="line-modified">!             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EP&gt;(function.get())), m_callFrame, operands[0]);</span>
              break;
          case 2:
<span class="line-modified">!             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EPP&gt;(function.get())), m_callFrame, operands[0], operands[1]);</span>
              break;
          case 3:
<span class="line-modified">!             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EPPP&gt;(function.get())), m_callFrame, operands[0], operands[1], operands[2]);</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
          }
<span class="line-new-header">--- 13305,22 ---</span>
              ++index;
          });
  
          unsigned argumentCountIncludingThis = signature-&gt;argumentCount + 1;
          LValue result;
<span class="line-added">+         // FIXME: Revisit JSGlobalObject.</span>
<span class="line-added">+         // https://bugs.webkit.org/show_bug.cgi?id=203204</span>
          auto function = CFunctionPtr(signature-&gt;functionWithoutTypeCheck);
          switch (argumentCountIncludingThis) {
          case 1:
<span class="line-modified">!             result = vmCall(Int64, reinterpret_cast&lt;J_JITOperation_GP&gt;(function.get()), weakPointer(globalObject), operands[0]);</span>
              break;
          case 2:
<span class="line-modified">!             result = vmCall(Int64, reinterpret_cast&lt;J_JITOperation_GPP&gt;(function.get()), weakPointer(globalObject), operands[0], operands[1]);</span>
              break;
          case 3:
<span class="line-modified">!             result = vmCall(Int64, reinterpret_cast&lt;J_JITOperation_GPPP&gt;(function.get()), weakPointer(globalObject), operands[0], operands[1], operands[2]);</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12602,22 ***</span>
      {
          DOMJIT::CallDOMGetterSnippet* domJIT = m_node-&gt;callDOMGetterData()-&gt;snippet;
          if (!domJIT) {
              // The following function is not an operation: we directly call a custom accessor getter.
              // Since the getter does not have code setting topCallFrame, As is the same to IC, we should set topCallFrame in caller side.
              m_out.storePtr(m_callFrame, m_out.absolute(&amp;vm().topCallFrame));
              setJSValue(
<span class="line-modified">!                 vmCall(Int64, m_out.operation(m_node-&gt;callDOMGetterData()-&gt;customAccessorGetter.retaggedExecutableAddress&lt;CFunctionPtrTag&gt;()),</span>
<span class="line-modified">!                     m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;callDOMGetterData()-&gt;identifierNumber])));</span>
              return;
          }
  
          Edge&amp; baseEdge = m_node-&gt;child1();
          LValue base = lowCell(baseEdge);
          JSValue baseConstant = m_state.forNode(baseEdge).value();
  
<span class="line-modified">!         LValue globalObject;</span>
          JSValue globalObjectConstant;
          if (domJIT-&gt;requireGlobalObject) {
              Edge&amp; globalObjectEdge = m_node-&gt;child2();
              globalObject = lowCell(globalObjectEdge);
              globalObjectConstant = m_state.forNode(globalObjectEdge).value();
<span class="line-new-header">--- 13332,25 ---</span>
      {
          DOMJIT::CallDOMGetterSnippet* domJIT = m_node-&gt;callDOMGetterData()-&gt;snippet;
          if (!domJIT) {
              // The following function is not an operation: we directly call a custom accessor getter.
              // Since the getter does not have code setting topCallFrame, As is the same to IC, we should set topCallFrame in caller side.
<span class="line-added">+             // FIXME: Revisit JSGlobalObject.</span>
<span class="line-added">+             // https://bugs.webkit.org/show_bug.cgi?id=203204</span>
<span class="line-added">+             JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
              m_out.storePtr(m_callFrame, m_out.absolute(&amp;vm().topCallFrame));
              setJSValue(
<span class="line-modified">!                 vmCall(Int64, bitwise_cast&lt;CustomGetterSetter::CustomGetter&gt;(m_node-&gt;callDOMGetterData()-&gt;customAccessorGetter.retaggedExecutableAddress&lt;CFunctionPtrTag&gt;()),</span>
<span class="line-modified">!                     weakPointer(globalObject), lowCell(m_node-&gt;child1()), m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;callDOMGetterData()-&gt;identifierNumber])));</span>
              return;
          }
  
          Edge&amp; baseEdge = m_node-&gt;child1();
          LValue base = lowCell(baseEdge);
          JSValue baseConstant = m_state.forNode(baseEdge).value();
  
<span class="line-modified">!         LValue globalObject = nullptr;</span>
          JSValue globalObjectConstant;
          if (domJIT-&gt;requireGlobalObject) {
              Edge&amp; globalObjectEdge = m_node-&gt;child2();
              globalObject = lowCell(globalObjectEdge);
              globalObjectConstant = m_state.forNode(globalObjectEdge).value();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12625,12 ***</span>
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(base);
          if (domJIT-&gt;requireGlobalObject)
              patchpoint-&gt;appendSomeRegister(globalObject);
<span class="line-modified">!         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));</span>
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;numGPScratchRegisters = domJIT-&gt;numGPScratchRegisters;
          patchpoint-&gt;numFPScratchRegisters = domJIT-&gt;numFPScratchRegisters;
          patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };
<span class="line-new-header">--- 13358,12 ---</span>
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(base);
          if (domJIT-&gt;requireGlobalObject)
              patchpoint-&gt;appendSomeRegister(globalObject);
<span class="line-modified">!         patchpoint-&gt;append(m_notCellMask, ValueRep::reg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_numberTag, ValueRep::reg(GPRInfo::numberTagRegister));</span>
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;numGPScratchRegisters = domJIT-&gt;numGPScratchRegisters;
          patchpoint-&gt;numFPScratchRegisters = domJIT-&gt;numFPScratchRegisters;
          patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13019,10 ***</span>
<span class="line-new-header">--- 13752,119 ---</span>
                  RELEASE_ASSERT_NOT_REACHED();
              }
          }
      }
  
<span class="line-added">+     void compileDateGet()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         LValue base = lowDateObject(m_node-&gt;child1());</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto emitGetCodeWithCallback = [&amp;] (const AbstractHeap&amp; cachedDoubleOffset, const AbstractHeap&amp; cachedDataOffset, auto* operation, auto callback) {</span>
<span class="line-added">+             LBasicBlock dataExistsCase = m_out.newBlock();</span>
<span class="line-added">+             LBasicBlock fastCase = m_out.newBlock();</span>
<span class="line-added">+             LBasicBlock slowCase = m_out.newBlock();</span>
<span class="line-added">+             LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added">+ </span>
<span class="line-added">+             LValue data = m_out.loadPtr(base, m_heaps.DateInstance_data);</span>
<span class="line-added">+             m_out.branch(m_out.notZero64(data), unsure(dataExistsCase), unsure(slowCase));</span>
<span class="line-added">+ </span>
<span class="line-added">+             LBasicBlock lastNext = m_out.appendTo(dataExistsCase, fastCase);</span>
<span class="line-added">+             LValue milliseconds = m_out.loadDouble(base, m_heaps.DateInstance_internalNumber);</span>
<span class="line-added">+             LValue cachedMilliseconds = m_out.loadDouble(data, cachedDoubleOffset);</span>
<span class="line-added">+             m_out.branch(m_out.doubleNotEqualOrUnordered(milliseconds, cachedMilliseconds), unsure(slowCase), unsure(fastCase));</span>
<span class="line-added">+ </span>
<span class="line-added">+             m_out.appendTo(fastCase, slowCase);</span>
<span class="line-added">+             ValueFromBlock fastResult = m_out.anchor(boxInt32(callback(m_out.load32(data, cachedDataOffset))));</span>
<span class="line-added">+             m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+             m_out.appendTo(slowCase, continuation);</span>
<span class="line-added">+             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operation, m_vmValue, base));</span>
<span class="line-added">+             m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+             m_out.appendTo(continuation, lastNext);</span>
<span class="line-added">+             setJSValue(m_out.phi(Int64, fastResult, slowResult));</span>
<span class="line-added">+         };</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto emitGetCode = [&amp;] (const AbstractHeap&amp; cachedDoubleOffset, const AbstractHeap&amp; cachedDataOffset, auto* operation) {</span>
<span class="line-added">+             emitGetCodeWithCallback(cachedDoubleOffset, cachedDataOffset, operation, [] (LValue value) { return value; });</span>
<span class="line-added">+         };</span>
<span class="line-added">+ </span>
<span class="line-added">+         switch (m_node-&gt;intrinsic()) {</span>
<span class="line-added">+         case DatePrototypeGetTimeIntrinsic:</span>
<span class="line-added">+             setDouble(m_out.loadDouble(base, m_heaps.DateInstance_internalNumber));</span>
<span class="line-added">+             break;</span>
<span class="line-added">+ </span>
<span class="line-added">+         case DatePrototypeGetMillisecondsIntrinsic:</span>
<span class="line-added">+         case DatePrototypeGetUTCMillisecondsIntrinsic: {</span>
<span class="line-added">+             LValue milliseconds = m_out.loadDouble(base, m_heaps.DateInstance_internalNumber);</span>
<span class="line-added">+             LValue msPerSecondConstant = m_out.constDouble(msPerSecond);</span>
<span class="line-added">+             LValue seconds = m_out.doubleFloor(m_out.doubleDiv(milliseconds, msPerSecondConstant));</span>
<span class="line-added">+             LValue result = m_out.doubleToInt(m_out.doubleSub(milliseconds, m_out.doubleMul(seconds, msPerSecondConstant)));</span>
<span class="line-added">+             setJSValue(m_out.select(m_out.doubleNotEqualOrUnordered(milliseconds, milliseconds), m_out.constInt64(JSValue::encode(jsNaN())), boxInt32(result)));</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         case DatePrototypeGetFullYearIntrinsic:</span>
<span class="line-added">+             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTime_year, operationDateGetFullYear);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case DatePrototypeGetUTCFullYearIntrinsic:</span>
<span class="line-added">+             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeUTCCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTimeUTC_year, operationDateGetUTCFullYear);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case DatePrototypeGetMonthIntrinsic:</span>
<span class="line-added">+             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTime_month, operationDateGetMonth);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case DatePrototypeGetUTCMonthIntrinsic:</span>
<span class="line-added">+             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeUTCCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTimeUTC_month, operationDateGetUTCMonth);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case DatePrototypeGetDateIntrinsic:</span>
<span class="line-added">+             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTime_monthDay, operationDateGetDate);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case DatePrototypeGetUTCDateIntrinsic:</span>
<span class="line-added">+             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeUTCCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTimeUTC_monthDay, operationDateGetUTCDate);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case DatePrototypeGetDayIntrinsic:</span>
<span class="line-added">+             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTime_weekDay, operationDateGetDay);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case DatePrototypeGetUTCDayIntrinsic:</span>
<span class="line-added">+             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeUTCCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTimeUTC_weekDay, operationDateGetUTCDay);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case DatePrototypeGetHoursIntrinsic:</span>
<span class="line-added">+             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTime_hour, operationDateGetHours);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case DatePrototypeGetUTCHoursIntrinsic:</span>
<span class="line-added">+             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeUTCCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTimeUTC_hour, operationDateGetUTCHours);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case DatePrototypeGetMinutesIntrinsic:</span>
<span class="line-added">+             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTime_minute, operationDateGetMinutes);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case DatePrototypeGetUTCMinutesIntrinsic:</span>
<span class="line-added">+             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeUTCCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTimeUTC_minute, operationDateGetUTCMinutes);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case DatePrototypeGetSecondsIntrinsic:</span>
<span class="line-added">+             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTime_second, operationDateGetSeconds);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case DatePrototypeGetUTCSecondsIntrinsic:</span>
<span class="line-added">+             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeUTCCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTimeUTC_second, operationDateGetUTCSeconds);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+ </span>
<span class="line-added">+         case DatePrototypeGetTimezoneOffsetIntrinsic:</span>
<span class="line-added">+             emitGetCodeWithCallback(m_heaps.DateInstanceData_gregorianDateTimeCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTime_utcOffsetInMinute, operationDateGetTimezoneOffset, [&amp;] (LValue offset) {</span>
<span class="line-added">+                 return m_out.neg(offset);</span>
<span class="line-added">+             });</span>
<span class="line-added">+             break;</span>
<span class="line-added">+ </span>
<span class="line-added">+         case DatePrototypeGetYearIntrinsic:</span>
<span class="line-added">+             emitGetCodeWithCallback(m_heaps.DateInstanceData_gregorianDateTimeCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTime_year, operationDateGetYear, [&amp;] (LValue year) {</span>
<span class="line-added">+                 return m_out.sub(year, m_out.constInt32(1900));</span>
<span class="line-added">+             });</span>
<span class="line-added">+             break;</span>
<span class="line-added">+ </span>
<span class="line-added">+         default:</span>
<span class="line-added">+             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void emitSwitchForMultiByOffset(LValue base, bool structuresChecked, Vector&lt;SwitchCase, 2&gt;&amp; cases, LBasicBlock exit)
      {
          if (cases.isEmpty()) {
              m_out.jump(exit);
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13088,12 ***</span>
                  m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoFlags),
                  m_out.constInt32(MasqueradesAsUndefined)));
      }
  
      template&lt;typename IntFunctor&gt;
<span class="line-modified">!     void nonSpeculativeCompare(const IntFunctor&amp; intFunctor, S_JITOperation_EJJ helperFunction)</span>
      {
          LValue left = lowJSValue(m_node-&gt;child1());
          LValue right = lowJSValue(m_node-&gt;child2());
  
          LBasicBlock leftIsInt = m_out.newBlock();
          LBasicBlock fastPath = m_out.newBlock();
<span class="line-new-header">--- 13930,13 ---</span>
                  m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoFlags),
                  m_out.constInt32(MasqueradesAsUndefined)));
      }
  
      template&lt;typename IntFunctor&gt;
<span class="line-modified">!     void nonSpeculativeCompare(const IntFunctor&amp; intFunctor, S_JITOperation_GJJ helperFunction)</span>
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LValue left = lowJSValue(m_node-&gt;child1());
          LValue right = lowJSValue(m_node-&gt;child2());
  
          LBasicBlock leftIsInt = m_out.newBlock();
          LBasicBlock fastPath = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13109,19 ***</span>
          ValueFromBlock fastResult = m_out.anchor(intFunctor(unboxInt32(left), unboxInt32(right)));
          m_out.jump(continuation);
  
          m_out.appendTo(slowPath, continuation);
          ValueFromBlock slowResult = m_out.anchor(m_out.notNull(vmCall(
<span class="line-modified">!             pointerType(), m_out.operation(helperFunction), m_callFrame, left, right)));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setBoolean(m_out.phi(Int32, fastResult, slowResult));
      }
  
      LValue stringsEqual(LValue leftJSString, LValue rightJSString, Edge leftJSStringEdge = Edge(), Edge rightJSStringEdge = Edge())
      {
          LBasicBlock notTriviallyUnequalCase = m_out.newBlock();
          LBasicBlock notEmptyCase = m_out.newBlock();
          LBasicBlock leftReadyCase = m_out.newBlock();
          LBasicBlock rightReadyCase = m_out.newBlock();
          LBasicBlock left8BitCase = m_out.newBlock();
<span class="line-new-header">--- 13952,20 ---</span>
          ValueFromBlock fastResult = m_out.anchor(intFunctor(unboxInt32(left), unboxInt32(right)));
          m_out.jump(continuation);
  
          m_out.appendTo(slowPath, continuation);
          ValueFromBlock slowResult = m_out.anchor(m_out.notNull(vmCall(
<span class="line-modified">!             pointerType(), helperFunction, weakPointer(globalObject), left, right)));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          setBoolean(m_out.phi(Int32, fastResult, slowResult));
      }
  
      LValue stringsEqual(LValue leftJSString, LValue rightJSString, Edge leftJSStringEdge = Edge(), Edge rightJSStringEdge = Edge())
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          LBasicBlock notTriviallyUnequalCase = m_out.newBlock();
          LBasicBlock notEmptyCase = m_out.newBlock();
          LBasicBlock leftReadyCase = m_out.newBlock();
          LBasicBlock rightReadyCase = m_out.newBlock();
          LBasicBlock left8BitCase = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13201,11 ***</span>
          m_out.jump(continuation);
  
          m_out.appendTo(slowCase, continuation);
  
          LValue slowResultValue = vmCall(
<span class="line-modified">!             Int64, m_out.operation(operationCompareStringEq), m_callFrame,</span>
              leftJSString, rightJSString);
          ValueFromBlock slowResult = m_out.anchor(unboxBoolean(slowResultValue));
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
<span class="line-new-header">--- 14045,11 ---</span>
          m_out.jump(continuation);
  
          m_out.appendTo(slowCase, continuation);
  
          LValue slowResultValue = vmCall(
<span class="line-modified">!             Int64, operationCompareStringEq, weakPointer(globalObject),</span>
              leftJSString, rightJSString);
          ValueFromBlock slowResult = m_out.anchor(unboxBoolean(slowResultValue));
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13215,11 ***</span>
      enum ScratchFPRUsage {
          DontNeedScratchFPR,
          NeedScratchFPR
      };
      template&lt;typename BinaryArithOpGenerator, ScratchFPRUsage scratchFPRUsage = DontNeedScratchFPR&gt;
<span class="line-modified">!     void emitBinarySnippet(J_JITOperation_EJJ slowPathFunction)</span>
      {
          Node* node = m_node;
  
          LValue left = lowJSValue(node-&gt;child1());
          LValue right = lowJSValue(node-&gt;child2());
<span class="line-new-header">--- 14059,11 ---</span>
      enum ScratchFPRUsage {
          DontNeedScratchFPR,
          NeedScratchFPR
      };
      template&lt;typename BinaryArithOpGenerator, ScratchFPRUsage scratchFPRUsage = DontNeedScratchFPR&gt;
<span class="line-modified">!     void emitBinarySnippet(J_JITOperation_GJJ slowPathFunction)</span>
      {
          Node* node = m_node;
  
          LValue left = lowJSValue(node-&gt;child1());
          LValue right = lowJSValue(node-&gt;child2());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13228,12 ***</span>
          SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(left);
          patchpoint-&gt;appendSomeRegister(right);
<span class="line-modified">!         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));</span>
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
          patchpoint-&gt;numGPScratchRegisters = 1;
          patchpoint-&gt;numFPScratchRegisters = 2;
          if (scratchFPRUsage == NeedScratchFPR)
<span class="line-new-header">--- 14072,12 ---</span>
          SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(left);
          patchpoint-&gt;appendSomeRegister(right);
<span class="line-modified">!         patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
          patchpoint-&gt;numGPScratchRegisters = 1;
          patchpoint-&gt;numFPScratchRegisters = 2;
          if (scratchFPRUsage == NeedScratchFPR)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13266,26 ***</span>
  
                              generator-&gt;slowPathJumpList().link(&amp;jit);
                              callOperation(
                                  *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
                                  exceptions.get(), slowPathFunction, params[0].gpr(),
                                  params[1].gpr(), params[2].gpr());
                              jit.jump().linkTo(done, &amp;jit);
                          });
                  } else {
                      callOperation(
                          *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
<span class="line-modified">!                         exceptions.get(), slowPathFunction, params[0].gpr(), params[1].gpr(),</span>
                          params[2].gpr());
                  }
              });
  
          setJSValue(patchpoint);
      }
  
      template&lt;typename BinaryBitOpGenerator&gt;
<span class="line-modified">!     void emitBinaryBitOpSnippet(J_JITOperation_EJJ slowPathFunction)</span>
      {
          Node* node = m_node;
  
          LValue left = lowJSValue(node-&gt;child1());
          LValue right = lowJSValue(node-&gt;child2());
<span class="line-new-header">--- 14110,27 ---</span>
  
                              generator-&gt;slowPathJumpList().link(&amp;jit);
                              callOperation(
                                  *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
                                  exceptions.get(), slowPathFunction, params[0].gpr(),
<span class="line-added">+                                 jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic),</span>
                                  params[1].gpr(), params[2].gpr());
                              jit.jump().linkTo(done, &amp;jit);
                          });
                  } else {
                      callOperation(
                          *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
<span class="line-modified">!                         exceptions.get(), slowPathFunction, params[0].gpr(), jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic), params[1].gpr(),</span>
                          params[2].gpr());
                  }
              });
  
          setJSValue(patchpoint);
      }
  
      template&lt;typename BinaryBitOpGenerator&gt;
<span class="line-modified">!     void emitBinaryBitOpSnippet(J_JITOperation_GJJ slowPathFunction)</span>
      {
          Node* node = m_node;
  
          LValue left = lowJSValue(node-&gt;child1());
          LValue right = lowJSValue(node-&gt;child2());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13294,12 ***</span>
          SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(left);
          patchpoint-&gt;appendSomeRegister(right);
<span class="line-modified">!         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));</span>
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
          patchpoint-&gt;numGPScratchRegisters = 1;
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };
<span class="line-new-header">--- 14139,12 ---</span>
          SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(left);
          patchpoint-&gt;appendSomeRegister(right);
<span class="line-modified">!         patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
          patchpoint-&gt;numGPScratchRegisters = 1;
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13325,10 ***</span>
<span class="line-new-header">--- 14170,11 ---</span>
  
                          generator-&gt;slowPathJumpList().link(&amp;jit);
                          callOperation(
                              *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
                              exceptions.get(), slowPathFunction, params[0].gpr(),
<span class="line-added">+                             jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic),</span>
                              params[1].gpr(), params[2].gpr());
                          jit.jump().linkTo(done, &amp;jit);
                      });
              });
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13349,12 ***</span>
          SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(left);
          patchpoint-&gt;appendSomeRegister(right);
<span class="line-modified">!         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));</span>
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
          patchpoint-&gt;numGPScratchRegisters = 1;
          patchpoint-&gt;numFPScratchRegisters = 1;
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
<span class="line-new-header">--- 14195,12 ---</span>
          SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
  
          PatchpointValue* patchpoint = m_out.patchpoint(Int64);
          patchpoint-&gt;appendSomeRegister(left);
          patchpoint-&gt;appendSomeRegister(right);
<span class="line-modified">!         patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">!         patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
          RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
              preparePatchpointForExceptions(patchpoint);
          patchpoint-&gt;numGPScratchRegisters = 1;
          patchpoint-&gt;numFPScratchRegisters = 1;
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13380,17 ***</span>
                      [=] (CCallHelpers&amp; jit) {
                          AllowMacroScratchRegisterUsage allowScratch(jit);
  
                          generator-&gt;slowPathJumpList().link(&amp;jit);
  
<span class="line-modified">!                         J_JITOperation_EJJ slowPathFunction =</span>
                              shiftType == JITRightShiftGenerator::SignedShift
                              ? operationValueBitRShift : operationValueBitURShift;
  
                          callOperation(
                              *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
                              exceptions.get(), slowPathFunction, params[0].gpr(),
                              params[1].gpr(), params[2].gpr());
                          jit.jump().linkTo(done, &amp;jit);
                      });
              });
  
<span class="line-new-header">--- 14226,18 ---</span>
                      [=] (CCallHelpers&amp; jit) {
                          AllowMacroScratchRegisterUsage allowScratch(jit);
  
                          generator-&gt;slowPathJumpList().link(&amp;jit);
  
<span class="line-modified">!                         J_JITOperation_GJJ slowPathFunction =</span>
                              shiftType == JITRightShiftGenerator::SignedShift
                              ? operationValueBitRShift : operationValueBitURShift;
  
                          callOperation(
                              *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
                              exceptions.get(), slowPathFunction, params[0].gpr(),
<span class="line-added">+                             jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic),</span>
                              params[1].gpr(), params[2].gpr());
                          jit.jump().linkTo(done, &amp;jit);
                      });
              });
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13651,11 ***</span>
  
          VM&amp; vm = this-&gt;vm();
          LValue slowResultValue = lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                  return createLazyCallGenerator(vm,
<span class="line-modified">!                     operationNewObject, locations[0].directGPR(),</span>
                      CCallHelpers::TrustedImmPtr(structure.get()));
              });
          ValueFromBlock slowResult = m_out.anchor(slowResultValue);
          m_out.jump(continuation);
  
<span class="line-new-header">--- 14498,11 ---</span>
  
          VM&amp; vm = this-&gt;vm();
          LValue slowResultValue = lazySlowPath(
              [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                  return createLazyCallGenerator(vm,
<span class="line-modified">!                     operationNewObject, locations[0].directGPR(), &amp;vm,</span>
                      CCallHelpers::TrustedImmPtr(structure.get()));
              });
          ValueFromBlock slowResult = m_out.anchor(slowResultValue);
          m_out.jump(continuation);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13681,19 ***</span>
      };
  
      ArrayValues allocateJSArray(LValue publicLength, LValue vectorLength, LValue structure, LValue indexingType, bool shouldInitializeElements = true, bool shouldLargeArraySizeCreateArrayStorage = true)
      {
          JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
<span class="line-removed">-         if (indexingType-&gt;hasInt32()) {</span>
<span class="line-removed">-             IndexingType type = static_cast&lt;IndexingType&gt;(indexingType-&gt;asInt32());</span>
<span class="line-removed">-             ASSERT_UNUSED(type,</span>
<span class="line-removed">-                 hasUndecided(type)</span>
<span class="line-removed">-                 || hasInt32(type)</span>
<span class="line-removed">-                 || hasDouble(type)</span>
<span class="line-removed">-                 || hasContiguous(type));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
          LBasicBlock fastCase = m_out.newBlock();
          LBasicBlock largeCase = m_out.newBlock();
          LBasicBlock failCase = m_out.newBlock();
          LBasicBlock continuation = m_out.newBlock();
          LBasicBlock slowCase = m_out.newBlock();
<span class="line-new-header">--- 14528,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13783,19 ***</span>
          if (vectorLength == publicLength
              || (staticVectorLengthFromPublicLength &amp;&amp; staticVectorLength &amp;&amp; staticVectorLength.value() == staticVectorLengthFromPublicLength.value())) {
              slowResultValue = lazySlowPath(
                  [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                      return createLazyCallGenerator(vm,
<span class="line-modified">!                         operationNewArrayWithSize, locations[0].directGPR(),</span>
                          locations[1].directGPR(), locations[2].directGPR(), locations[3].directGPR());
                  },
                  structureValue, publicLength, butterflyValue);
          } else {
              slowResultValue = lazySlowPath(
                  [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                      return createLazyCallGenerator(vm,
<span class="line-modified">!                         operationNewArrayWithSizeAndHint, locations[0].directGPR(),</span>
                          locations[1].directGPR(), locations[2].directGPR(), locations[3].directGPR(), locations[4].directGPR());
                  },
                  structureValue, publicLength, vectorLength, butterflyValue);
          }
  
<span class="line-new-header">--- 14621,19 ---</span>
          if (vectorLength == publicLength
              || (staticVectorLengthFromPublicLength &amp;&amp; staticVectorLength &amp;&amp; staticVectorLength.value() == staticVectorLengthFromPublicLength.value())) {
              slowResultValue = lazySlowPath(
                  [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                      return createLazyCallGenerator(vm,
<span class="line-modified">!                         operationNewArrayWithSize, locations[0].directGPR(), globalObject,</span>
                          locations[1].directGPR(), locations[2].directGPR(), locations[3].directGPR());
                  },
                  structureValue, publicLength, butterflyValue);
          } else {
              slowResultValue = lazySlowPath(
                  [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
                      return createLazyCallGenerator(vm,
<span class="line-modified">!                         operationNewArrayWithSizeAndHint, locations[0].directGPR(), globalObject,</span>
                          locations[1].directGPR(), locations[2].directGPR(), locations[3].directGPR(), locations[4].directGPR());
                  },
                  structureValue, publicLength, vectorLength, butterflyValue);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13846,11 ***</span>
              m_out.below(logCursor, m_out.constIntPtr(shadowChicken-&gt;logEnd())),
              usually(continuation), rarely(slowCase));
  
          LBasicBlock lastNext = m_out.appendTo(slowCase, continuation);
  
<span class="line-modified">!         vmCall(Void, m_out.operation(operationProcessShadowChickenLog), m_callFrame);</span>
  
          ValueFromBlock slowResult = m_out.anchor(m_out.loadPtr(addressOfLogCursor));
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
<span class="line-new-header">--- 14684,11 ---</span>
              m_out.below(logCursor, m_out.constIntPtr(shadowChicken-&gt;logEnd())),
              usually(continuation), rarely(slowCase));
  
          LBasicBlock lastNext = m_out.appendTo(slowCase, continuation);
  
<span class="line-modified">!         vmCall(Void, operationProcessShadowChickenLog, m_vmValue);</span>
  
          ValueFromBlock slowResult = m_out.anchor(m_out.loadPtr(addressOfLogCursor));
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14082,14 ***</span>
          m_out.appendTo(primitiveCase, continuation);
  
          LValue primitiveResult;
          switch (primitiveMode) {
          case EqualNull:
<span class="line-modified">!             primitiveResult = m_out.equal(value, m_out.constInt64(ValueNull));</span>
              break;
          case EqualUndefined:
<span class="line-modified">!             primitiveResult = m_out.equal(value, m_out.constInt64(ValueUndefined));</span>
              break;
          case EqualNullOrUndefined:
              primitiveResult = isOther(value, provenType(edge));
              break;
          case SpeculateNullOrUndefined:
<span class="line-new-header">--- 14920,14 ---</span>
          m_out.appendTo(primitiveCase, continuation);
  
          LValue primitiveResult;
          switch (primitiveMode) {
          case EqualNull:
<span class="line-modified">!             primitiveResult = m_out.equal(value, m_out.constInt64(JSValue::ValueNull));</span>
              break;
          case EqualUndefined:
<span class="line-modified">!             primitiveResult = m_out.equal(value, m_out.constInt64(JSValue::ValueUndefined));</span>
              break;
          case EqualNullOrUndefined:
              primitiveResult = isOther(value, provenType(edge));
              break;
          case SpeculateNullOrUndefined:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14109,10 ***</span>
<span class="line-new-header">--- 14947,11 ---</span>
      template&lt;typename FunctionType&gt;
      void contiguousPutByValOutOfBounds(
          FunctionType slowPathFunction, LValue base, LValue storage, LValue index, LValue value,
          LBasicBlock continuation)
      {
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
          if (!m_node-&gt;arrayMode().isInBounds()) {
              LBasicBlock notInBoundsCase =
                  m_out.newBlock();
              LBasicBlock performStore =
                  m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14137,12 ***</span>
                  m_out.branch(isOutOfBounds, rarely(outOfBoundsCase), usually(holeCase));
  
                  LBasicBlock innerLastNext = m_out.appendTo(outOfBoundsCase, holeCase);
  
                  vmCall(
<span class="line-modified">!                     Void, m_out.operation(slowPathFunction),</span>
<span class="line-modified">!                     m_callFrame, base, index, value);</span>
  
                  m_out.jump(continuation);
  
                  m_out.appendTo(holeCase, innerLastNext);
              }
<span class="line-new-header">--- 14976,12 ---</span>
                  m_out.branch(isOutOfBounds, rarely(outOfBoundsCase), usually(holeCase));
  
                  LBasicBlock innerLastNext = m_out.appendTo(outOfBoundsCase, holeCase);
  
                  vmCall(
<span class="line-modified">!                     Void, slowPathFunction,</span>
<span class="line-modified">!                     weakPointer(globalObject), base, index, value);</span>
  
                  m_out.jump(continuation);
  
                  m_out.appendTo(holeCase, innerLastNext);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14508,13 ***</span>
      {
          // FIXME: We ought to be able to use computed gotos here. We would save the labels of the
          // blocks we want to jump to, and then request their addresses after compilation completes.
          // https://bugs.webkit.org/show_bug.cgi?id=144369
  
          LValue branchOffset = vmCall(
<span class="line-modified">!             Int32, m_out.operation(operationSwitchStringAndGetBranchOffset),</span>
<span class="line-modified">!             m_callFrame, m_out.constIntPtr(data-&gt;switchTableIndex), string);</span>
  
          StringJumpTable&amp; table = codeBlock()-&gt;stringSwitchJumpTable(data-&gt;switchTableIndex);
  
          Vector&lt;SwitchCase&gt; cases;
          // These may be negative, or zero, or probably other stuff, too. We don&#39;t want to mess with HashSet&#39;s corner cases and we don&#39;t really care about throughput here.
<span class="line-new-header">--- 15347,15 ---</span>
      {
          // FIXME: We ought to be able to use computed gotos here. We would save the labels of the
          // blocks we want to jump to, and then request their addresses after compilation completes.
          // https://bugs.webkit.org/show_bug.cgi?id=144369
  
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added">+ </span>
          LValue branchOffset = vmCall(
<span class="line-modified">!             Int32, operationSwitchStringAndGetBranchOffset,</span>
<span class="line-modified">!             weakPointer(globalObject), m_out.constIntPtr(data-&gt;switchTableIndex), string);</span>
  
          StringJumpTable&amp; table = codeBlock()-&gt;stringSwitchJumpTable(data-&gt;switchTableIndex);
  
          Vector&lt;SwitchCase&gt; cases;
          // These may be negative, or zero, or probably other stuff, too. We don&#39;t want to mess with HashSet&#39;s corner cases and we don&#39;t really care about throughput here.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14707,11 ***</span>
          functor(TypeofType::Number);
  
          m_out.appendTo(notNumberCase, notNullCase);
          LValue isNull;
          if (provenType(child) &amp; SpecOther)
<span class="line-modified">!             isNull = m_out.equal(value, m_out.constInt64(ValueNull));</span>
          else
              isNull = m_out.booleanFalse;
          m_out.branch(isNull, unsure(reallyObjectCase), unsure(notNullCase));
  
          m_out.appendTo(notNullCase, booleanCase);
<span class="line-new-header">--- 15548,11 ---</span>
          functor(TypeofType::Number);
  
          m_out.appendTo(notNumberCase, notNullCase);
          LValue isNull;
          if (provenType(child) &amp; SpecOther)
<span class="line-modified">!             isNull = m_out.equal(value, m_out.constInt64(JSValue::ValueNull));</span>
          else
              isNull = m_out.booleanFalse;
          m_out.branch(isNull, unsure(reallyObjectCase), unsure(notNullCase));
  
          m_out.appendTo(notNullCase, booleanCase);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14898,11 ***</span>
              fastResult = m_out.doubleToUInt(doubleValue);
          results.append(m_out.anchor(fastResult));
          m_out.jump(continuation);
  
          m_out.appendTo(slowPath, continuation);
<span class="line-modified">!         results.append(m_out.anchor(m_out.call(Int32, m_out.operation(operationToInt32), doubleValue)));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          return m_out.phi(Int32, results);
      }
<span class="line-new-header">--- 15739,11 ---</span>
              fastResult = m_out.doubleToUInt(doubleValue);
          results.append(m_out.anchor(fastResult));
          m_out.jump(continuation);
  
          m_out.appendTo(slowPath, continuation);
<span class="line-modified">!         results.append(m_out.anchor(m_out.callWithoutSideEffects(Int32, operationToInt32, doubleValue)));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          return m_out.phi(Int32, results);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14938,12 ***</span>
          m_out.branch(
              m_out.equal(fastResultValue, m_out.constInt32(0x80000000)),
              rarely(slowPath), usually(continuation));
  
          LBasicBlock lastNext = m_out.appendTo(slowPath, continuation);
<span class="line-modified">!         ValueFromBlock slowResult = m_out.anchor(</span>
<span class="line-removed">-             m_out.call(Int32, m_out.operation(operationToInt32SensibleSlow), doubleValue));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          return m_out.phi(Int32, fastResult, slowResult);
      }
<span class="line-new-header">--- 15779,11 ---</span>
          m_out.branch(
              m_out.equal(fastResultValue, m_out.constInt32(0x80000000)),
              rarely(slowPath), usually(continuation));
  
          LBasicBlock lastNext = m_out.appendTo(slowPath, continuation);
<span class="line-modified">!         ValueFromBlock slowResult = m_out.anchor(m_out.callWithoutSideEffects(Int32, operationToInt32SensibleSlow, doubleValue));</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
          return m_out.phi(Int32, fastResult, slowResult);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 15361,10 ***</span>
<span class="line-new-header">--- 16201,17 ---</span>
          LValue result = lowCell(edge);
          speculateDataViewObject(edge, result);
          return result;
      }
  
<span class="line-added">+     LValue lowDateObject(Edge edge)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         LValue result = lowCell(edge);</span>
<span class="line-added">+         speculateDateObject(edge, result);</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      LValue lowString(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
      {
          ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == StringUse || edge.useKind() == KnownStringUse || edge.useKind() == StringIdentUse);
  
          LValue result = lowCell(edge, mode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 15567,50 ***</span>
  
      LValue isInt32(LValue jsValue, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, SpecInt32Only))
              return proven;
<span class="line-modified">!         return m_out.aboveOrEqual(jsValue, m_tagTypeNumber);</span>
      }
      LValue isNotInt32(LValue jsValue, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, ~SpecInt32Only))
              return proven;
<span class="line-modified">!         return m_out.below(jsValue, m_tagTypeNumber);</span>
      }
      LValue unboxInt32(LValue jsValue)
      {
          return m_out.castToInt32(jsValue);
      }
      LValue boxInt32(LValue value)
      {
<span class="line-modified">!         return m_out.add(m_out.zeroExt(value, Int64), m_tagTypeNumber);</span>
      }
  
      LValue isCellOrMisc(LValue jsValue, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, SpecCellCheck | SpecMisc))
              return proven;
<span class="line-modified">!         return m_out.testIsZero64(jsValue, m_tagTypeNumber);</span>
      }
      LValue isNotCellOrMisc(LValue jsValue, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, ~(SpecCellCheck | SpecMisc)))
              return proven;
<span class="line-modified">!         return m_out.testNonZero64(jsValue, m_tagTypeNumber);</span>
      }
  
      LValue unboxDouble(LValue jsValue, LValue* unboxedAsInt = nullptr)
      {
<span class="line-modified">!         LValue asInt = m_out.add(jsValue, m_tagTypeNumber);</span>
          if (unboxedAsInt)
              *unboxedAsInt = asInt;
          return m_out.bitCast(asInt, Double);
      }
      LValue boxDouble(LValue doubleValue)
      {
<span class="line-modified">!         return m_out.sub(m_out.bitCast(doubleValue, Int64), m_tagTypeNumber);</span>
      }
  
      LValue jsValueToStrictInt52(Edge edge, LValue boxedValue)
      {
          LBasicBlock intCase = m_out.newBlock();
<span class="line-new-header">--- 16414,50 ---</span>
  
      LValue isInt32(LValue jsValue, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, SpecInt32Only))
              return proven;
<span class="line-modified">!         return m_out.aboveOrEqual(jsValue, m_numberTag);</span>
      }
      LValue isNotInt32(LValue jsValue, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, ~SpecInt32Only))
              return proven;
<span class="line-modified">!         return m_out.below(jsValue, m_numberTag);</span>
      }
      LValue unboxInt32(LValue jsValue)
      {
          return m_out.castToInt32(jsValue);
      }
      LValue boxInt32(LValue value)
      {
<span class="line-modified">!         return m_out.add(m_out.zeroExt(value, Int64), m_numberTag);</span>
      }
  
      LValue isCellOrMisc(LValue jsValue, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, SpecCellCheck | SpecMisc))
              return proven;
<span class="line-modified">!         return m_out.testIsZero64(jsValue, m_numberTag);</span>
      }
      LValue isNotCellOrMisc(LValue jsValue, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, ~(SpecCellCheck | SpecMisc)))
              return proven;
<span class="line-modified">!         return m_out.testNonZero64(jsValue, m_numberTag);</span>
      }
  
      LValue unboxDouble(LValue jsValue, LValue* unboxedAsInt = nullptr)
      {
<span class="line-modified">!         LValue asInt = m_out.add(jsValue, m_numberTag);</span>
          if (unboxedAsInt)
              *unboxedAsInt = asInt;
          return m_out.bitCast(asInt, Double);
      }
      LValue boxDouble(LValue doubleValue)
      {
<span class="line-modified">!         return m_out.sub(m_out.bitCast(doubleValue, Int64), m_numberTag);</span>
      }
  
      LValue jsValueToStrictInt52(Edge edge, LValue boxedValue)
      {
          LBasicBlock intCase = m_out.newBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 15632,12 ***</span>
              m_out.signExt32To64(unboxInt32(boxedValue)));
          m_out.jump(continuation);
  
          m_out.appendTo(doubleCase, continuation);
  
<span class="line-modified">!         LValue possibleResult = m_out.call(</span>
<span class="line-removed">-             Int64, m_out.operation(operationConvertBoxedDoubleToInt52), boxedValue);</span>
          FTL_TYPE_CHECK(
              jsValueValue(boxedValue), edge, SpecInt32Only | SpecAnyIntAsDouble,
              m_out.equal(possibleResult, m_out.constInt64(JSValue::notInt52)));
  
          ValueFromBlock doubleToInt52 = m_out.anchor(possibleResult);
<span class="line-new-header">--- 16479,11 ---</span>
              m_out.signExt32To64(unboxInt32(boxedValue)));
          m_out.jump(continuation);
  
          m_out.appendTo(doubleCase, continuation);
  
<span class="line-modified">!         LValue possibleResult = m_out.callWithoutSideEffects(Int64, operationConvertBoxedDoubleToInt52, boxedValue);</span>
          FTL_TYPE_CHECK(
              jsValueValue(boxedValue), edge, SpecInt32Only | SpecAnyIntAsDouble,
              m_out.equal(possibleResult, m_out.constInt64(JSValue::notInt52)));
  
          ValueFromBlock doubleToInt52 = m_out.anchor(possibleResult);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 15648,17 ***</span>
          return m_out.phi(Int64, intToInt52, doubleToInt52);
      }
  
      LValue doubleToStrictInt52(Edge edge, LValue value)
      {
<span class="line-modified">!         LValue possibleResult = m_out.call(</span>
<span class="line-modified">!             Int64, m_out.operation(operationConvertDoubleToInt52), value);</span>
<span class="line-modified">!         FTL_TYPE_CHECK_WITH_EXIT_KIND(Int52Overflow,</span>
<span class="line-modified">!             doubleValue(value), edge, SpecAnyIntAsDouble,</span>
<span class="line-modified">!             m_out.equal(possibleResult, m_out.constInt64(JSValue::notInt52)));</span>
  
<span class="line-modified">!         return possibleResult;</span>
      }
  
      LValue convertDoubleToInt32(LValue value, bool shouldCheckNegativeZero)
      {
          LValue integerValue = m_out.doubleToInt(value);
<span class="line-new-header">--- 16494,34 ---</span>
          return m_out.phi(Int64, intToInt52, doubleToInt52);
      }
  
      LValue doubleToStrictInt52(Edge edge, LValue value)
      {
<span class="line-modified">!         LValue integerValue = m_out.doubleToInt64(value);</span>
<span class="line-modified">!         LValue integerValueConvertedToDouble = m_out.intToDouble(integerValue);</span>
<span class="line-modified">!         LValue valueNotConvertibleToInteger = m_out.doubleNotEqualOrUnordered(value, integerValueConvertedToDouble);</span>
<span class="line-modified">!         speculate(Int52Overflow, doubleValue(value), edge.node(), valueNotConvertibleToInteger);</span>
<span class="line-modified">! </span>
<span class="line-added">+         LBasicBlock valueIsZero = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock valueIsNotZero = m_out.newBlock();</span>
<span class="line-added">+         LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added">+         m_out.branch(m_out.isZero64(integerValue), unsure(valueIsZero), unsure(valueIsNotZero));</span>
<span class="line-added">+ </span>
<span class="line-added">+         LBasicBlock lastNext = m_out.appendTo(valueIsZero, valueIsNotZero);</span>
<span class="line-added">+         LValue doubleBitcastToInt64 = m_out.bitCast(value, Int64);</span>
<span class="line-added">+         LValue signBitSet = m_out.lessThan(doubleBitcastToInt64, m_out.constInt64(0));</span>
<span class="line-added">+         speculate(Int52Overflow, doubleValue(value), edge.node(), signBitSet);</span>
<span class="line-added">+         m_out.jump(continuation);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_out.appendTo(valueIsNotZero, continuation);</span>
<span class="line-added">+         speculate(Int52Overflow, doubleValue(value), edge.node(), m_out.greaterThanOrEqual(integerValue, m_out.constInt64(static_cast&lt;int64_t&gt;(1) &lt;&lt; (JSValue::numberOfInt52Bits - 1))));</span>
<span class="line-added">+         speculate(Int52Overflow, doubleValue(value), edge.node(), m_out.lessThan(integerValue, m_out.constInt64(-(static_cast&lt;int64_t&gt;(1) &lt;&lt; (JSValue::numberOfInt52Bits - 1)))));</span>
<span class="line-added">+         m_out.jump(continuation);</span>
  
<span class="line-modified">!         m_out.appendTo(continuation, lastNext);</span>
<span class="line-added">+         m_interpreter.filter(edge, SpecAnyIntAsDouble);</span>
<span class="line-added">+         return integerValue;</span>
      }
  
      LValue convertDoubleToInt32(LValue value, bool shouldCheckNegativeZero)
      {
          LValue integerValue = m_out.doubleToInt(value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 15698,25 ***</span>
  
      LValue isNotCell(LValue jsValue, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, ~SpecCellCheck))
              return proven;
<span class="line-modified">!         return m_out.testNonZero64(jsValue, m_tagMask);</span>
      }
  
      LValue isCell(LValue jsValue, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, SpecCellCheck))
              return proven;
<span class="line-modified">!         return m_out.testIsZero64(jsValue, m_tagMask);</span>
      }
  
      LValue isNotMisc(LValue value, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, ~SpecMisc))
              return proven;
<span class="line-modified">!         return m_out.above(value, m_out.constInt64(TagBitTypeOther | TagBitBool | TagBitUndefined));</span>
      }
  
      LValue isMisc(LValue value, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, SpecMisc))
<span class="line-new-header">--- 16561,25 ---</span>
  
      LValue isNotCell(LValue jsValue, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, ~SpecCellCheck))
              return proven;
<span class="line-modified">!         return m_out.testNonZero64(jsValue, m_notCellMask);</span>
      }
  
      LValue isCell(LValue jsValue, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, SpecCellCheck))
              return proven;
<span class="line-modified">!         return m_out.testIsZero64(jsValue, m_notCellMask);</span>
      }
  
      LValue isNotMisc(LValue value, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, ~SpecMisc))
              return proven;
<span class="line-modified">!         return m_out.above(value, m_out.constInt64(JSValue::MiscTag));</span>
      }
  
      LValue isMisc(LValue value, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, SpecMisc))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 15727,11 ***</span>
      LValue isNotBoolean(LValue jsValue, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, ~SpecBoolean))
              return proven;
          return m_out.testNonZero64(
<span class="line-modified">!             m_out.bitXor(jsValue, m_out.constInt64(ValueFalse)),</span>
              m_out.constInt64(~1));
      }
      LValue isBoolean(LValue jsValue, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, SpecBoolean))
<span class="line-new-header">--- 16590,11 ---</span>
      LValue isNotBoolean(LValue jsValue, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, ~SpecBoolean))
              return proven;
          return m_out.testNonZero64(
<span class="line-modified">!             m_out.bitXor(jsValue, m_out.constInt64(JSValue::ValueFalse)),</span>
              m_out.constInt64(~1));
      }
      LValue isBoolean(LValue jsValue, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, SpecBoolean))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 15745,28 ***</span>
          return m_out.notZero64(m_out.bitAnd(jsValue, m_out.constInt64(1)));
      }
      LValue boxBoolean(LValue value)
      {
          return m_out.select(
<span class="line-modified">!             value, m_out.constInt64(ValueTrue), m_out.constInt64(ValueFalse));</span>
      }
  
      LValue isNotOther(LValue value, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, ~SpecOther))
              return proven;
          return m_out.notEqual(
<span class="line-modified">!             m_out.bitAnd(value, m_out.constInt64(~TagBitUndefined)),</span>
<span class="line-modified">!             m_out.constInt64(ValueNull));</span>
      }
      LValue isOther(LValue value, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, SpecOther))
              return proven;
          return m_out.equal(
<span class="line-modified">!             m_out.bitAnd(value, m_out.constInt64(~TagBitUndefined)),</span>
<span class="line-modified">!             m_out.constInt64(ValueNull));</span>
      }
  
      LValue isProvenValue(SpeculatedType provenType, SpeculatedType wantedType)
      {
          if (!(provenType &amp; ~wantedType))
<span class="line-new-header">--- 16608,28 ---</span>
          return m_out.notZero64(m_out.bitAnd(jsValue, m_out.constInt64(1)));
      }
      LValue boxBoolean(LValue value)
      {
          return m_out.select(
<span class="line-modified">!             value, m_out.constInt64(JSValue::ValueTrue), m_out.constInt64(JSValue::ValueFalse));</span>
      }
  
      LValue isNotOther(LValue value, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, ~SpecOther))
              return proven;
          return m_out.notEqual(
<span class="line-modified">!             m_out.bitAnd(value, m_out.constInt64(~JSValue::UndefinedTag)),</span>
<span class="line-modified">!             m_out.constInt64(JSValue::ValueNull));</span>
      }
      LValue isOther(LValue value, SpeculatedType type = SpecFullTop)
      {
          if (LValue proven = isProvenValue(type, SpecOther))
              return proven;
          return m_out.equal(
<span class="line-modified">!             m_out.bitAnd(value, m_out.constInt64(~JSValue::UndefinedTag)),</span>
<span class="line-modified">!             m_out.constInt64(JSValue::ValueNull));</span>
      }
  
      LValue isProvenValue(SpeculatedType provenType, SpeculatedType wantedType)
      {
          if (!(provenType &amp; ~wantedType))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 15819,16 ***</span>
<span class="line-new-header">--- 16682,22 ---</span>
              speculateFinalObject(edge);
              break;
          case RegExpObjectUse:
              speculateRegExpObject(edge);
              break;
<span class="line-added">+         case PromiseObjectUse:</span>
<span class="line-added">+             speculatePromiseObject(edge);</span>
<span class="line-added">+             break;</span>
          case ProxyObjectUse:
              speculateProxyObject(edge);
              break;
          case DerivedArrayUse:
              speculateDerivedArray(edge);
              break;
<span class="line-added">+         case DateObjectUse:</span>
<span class="line-added">+             speculateDateObject(edge);</span>
<span class="line-added">+             break;</span>
          case MapObjectUse:
              speculateMapObject(edge);
              break;
          case SetObjectUse:
              speculateSetObject(edge);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 15945,14 ***</span>
              return;
  
          jsValueToStrictInt52(edge, lowJSValue(edge, ManualOperandSpeculation));
      }
  
<span class="line-modified">!     LValue isCellWithType(LValue cell, JSType queriedType, SpeculatedType speculatedTypeForQuery, SpeculatedType type = SpecFullTop)</span>
      {
<span class="line-modified">!         if (LValue proven = isProvenValue(type &amp; SpecCell, speculatedTypeForQuery))</span>
<span class="line-modified">!             return proven;</span>
          return m_out.equal(
              m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
              m_out.constInt32(queriedType));
      }
  
<span class="line-new-header">--- 16814,16 ---</span>
              return;
  
          jsValueToStrictInt52(edge, lowJSValue(edge, ManualOperandSpeculation));
      }
  
<span class="line-modified">!     LValue isCellWithType(LValue cell, JSType queriedType, Optional&lt;SpeculatedType&gt; speculatedTypeForQuery, SpeculatedType type = SpecFullTop)</span>
      {
<span class="line-modified">!         if (speculatedTypeForQuery) {</span>
<span class="line-modified">!             if (LValue proven = isProvenValue(type &amp; SpecCell, speculatedTypeForQuery.value()))</span>
<span class="line-added">+                 return proven;</span>
<span class="line-added">+         }</span>
          return m_out.equal(
              m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
              m_out.constInt32(queriedType));
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16338,10 ***</span>
<span class="line-new-header">--- 17209,32 ---</span>
      void speculateDerivedArray(Edge edge)
      {
          speculateDerivedArray(edge, lowCell(edge));
      }
  
<span class="line-added">+     void speculatePromiseObject(Edge edge, LValue cell)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         FTL_TYPE_CHECK(</span>
<span class="line-added">+             jsValueValue(cell), edge, SpecPromiseObject, isNotType(cell, JSPromiseType));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void speculatePromiseObject(Edge edge)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         speculatePromiseObject(edge, lowCell(edge));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void speculateDateObject(Edge edge, LValue cell)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         FTL_TYPE_CHECK(</span>
<span class="line-added">+             jsValueValue(cell), edge, SpecDateObject, isNotType(cell, JSDateType));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void speculateDateObject(Edge edge)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         speculateDateObject(edge, lowCell(edge));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void speculateMapObject(Edge edge, LValue cell)
      {
          FTL_TYPE_CHECK(
              jsValueValue(cell), edge, SpecMapObject, isNotType(cell, JSMapType));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16710,11 ***</span>
                  usually(continuation), rarely(slowPath));
          }
  
          m_out.appendTo(slowPath, continuation);
  
<span class="line-modified">!         LValue call = vmCall(Void, m_out.operation(operationWriteBarrierSlowPath), m_callFrame, base);</span>
          m_heaps.decorateCCallRead(&amp;m_heaps.root, call);
          m_heaps.decorateCCallWrite(&amp;m_heaps.JSCell_cellState, call);
  
          m_out.jump(continuation);
  
<span class="line-new-header">--- 17603,11 ---</span>
                  usually(continuation), rarely(slowPath));
          }
  
          m_out.appendTo(slowPath, continuation);
  
<span class="line-modified">!         LValue call = vmCall(Void, operationWriteBarrierSlowPath, m_vmValue, base);</span>
          m_heaps.decorateCCallRead(&amp;m_heaps.root, call);
          m_heaps.decorateCCallWrite(&amp;m_heaps.JSCell_cellState, call);
  
          m_out.jump(continuation);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16787,31 ***</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
      }
  
<span class="line-modified">!     LValue preciseIndexMask64(LValue value, LValue index, LValue limit)</span>
<span class="line-modified">!     {</span>
<span class="line-removed">-         return m_out.bitAnd(</span>
<span class="line-removed">-             value,</span>
<span class="line-removed">-             m_out.aShr(</span>
<span class="line-removed">-                 m_out.sub(</span>
<span class="line-removed">-                     index,</span>
<span class="line-removed">-                     m_out.opaque(limit)),</span>
<span class="line-removed">-                 m_out.constInt32(63)));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     LValue preciseIndexMask32(LValue value, LValue index, LValue limit)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         return preciseIndexMask64(value, m_out.zeroExt(index, Int64), m_out.zeroExt(limit, Int64));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     template&lt;typename... Args&gt;</span>
<span class="line-removed">-     LValue vmCall(LType type, LValue function, Args&amp;&amp;... args)</span>
      {
          callPreflight();
<span class="line-modified">!         LValue result = m_out.call(type, function, std::forward&lt;Args&gt;(args)...);</span>
          if (mayExit(m_graph, m_node))
              callCheck();
          else {
              // We can&#39;t exit due to an exception, so we also can&#39;t throw an exception.
  #ifndef NDEBUG
<span class="line-new-header">--- 17680,17 ---</span>
          m_out.jump(continuation);
  
          m_out.appendTo(continuation, lastNext);
      }
  
<span class="line-modified">!     template&lt;typename OperationType, typename... Args&gt;</span>
<span class="line-modified">!     LValue vmCall(LType type, OperationType function, Args&amp;&amp;... args)</span>
      {
<span class="line-added">+         static_assert(!std::is_same&lt;OperationType, LValue&gt;::value);</span>
<span class="line-added">+         static_assert(FunctionTraits&lt;OperationType&gt;::cCallArity() == sizeof...(Args), &quot;Sanity check&quot;);</span>
          callPreflight();
<span class="line-modified">!         LValue result = m_out.call(type, m_out.operation(function), std::forward&lt;Args&gt;(args)...);</span>
          if (mayExit(m_graph, m_node))
              callCheck();
          else {
              // We can&#39;t exit due to an exception, so we also can&#39;t throw an exception.
  #ifndef NDEBUG
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16836,11 ***</span>
      void callPreflight(CodeOrigin codeOrigin)
      {
          CallSiteIndex callSiteIndex = m_ftlState.jitCode-&gt;common.addCodeOrigin(codeOrigin);
          m_out.store32(
              m_out.constInt32(callSiteIndex.bits()),
<span class="line-modified">!             tagFor(CallFrameSlot::argumentCount));</span>
      }
  
      void callPreflight()
      {
          callPreflight(codeOriginDescriptionOfCallSite());
<span class="line-new-header">--- 17715,14 ---</span>
      void callPreflight(CodeOrigin codeOrigin)
      {
          CallSiteIndex callSiteIndex = m_ftlState.jitCode-&gt;common.addCodeOrigin(codeOrigin);
          m_out.store32(
              m_out.constInt32(callSiteIndex.bits()),
<span class="line-modified">!             tagFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
<span class="line-added">+ #if !USE(BUILTIN_FRAME_ADDRESS) || ASSERT_ENABLED</span>
<span class="line-added">+         m_out.storePtr(m_callFrame, m_out.absolute(&amp;vm().topCallFrame));</span>
<span class="line-added">+ #endif</span>
      }
  
      void callPreflight()
      {
          callPreflight(codeOriginDescriptionOfCallSite());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16864,12 ***</span>
          return codeOrigin;
      }
  
      void callCheck()
      {
<span class="line-modified">!         if (Options::useExceptionFuzz())</span>
<span class="line-modified">!             m_out.call(Void, m_out.operation(operationExceptionFuzz), m_callFrame);</span>
  
          LValue exception = m_out.load64(m_out.absolute(vm().addressOfException()));
          LValue hadException = m_out.notZero64(exception);
  
          CodeOrigin opCatchOrigin;
<span class="line-new-header">--- 17746,17 ---</span>
          return codeOrigin;
      }
  
      void callCheck()
      {
<span class="line-modified">!         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-modified">!         if (Options::useExceptionFuzz()) {</span>
<span class="line-added">+ #if !USE(BUILTIN_FRAME_ADDRESS) || ASSERT_ENABLED</span>
<span class="line-added">+             m_out.storePtr(m_callFrame, m_out.absolute(&amp;vm().topCallFrame));</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+             m_out.call(Void, m_out.operation(operationExceptionFuzz), weakPointer(globalObject));</span>
<span class="line-added">+         }</span>
  
          LValue exception = m_out.load64(m_out.absolute(vm().addressOfException()));
          LValue hadException = m_out.notZero64(exception);
  
          CodeOrigin opCatchOrigin;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16936,11 ***</span>
      OSRExitDescriptor* appendOSRExitDescriptor(FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile)
      {
          return &amp;m_ftlState.jitCode-&gt;osrExitDescriptors.alloc(
              lowValue.format(), profile,
              availabilityMap().m_locals.numberOfArguments(),
<span class="line-modified">!             availabilityMap().m_locals.numberOfLocals());</span>
      }
  
      void appendOSRExit(
          ExitKind kind, FormattedValue lowValue, Node* highValue, LValue failCondition,
          NodeOrigin origin, bool isExceptionHandler = false)
<span class="line-new-header">--- 17823,12 ---</span>
      OSRExitDescriptor* appendOSRExitDescriptor(FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile)
      {
          return &amp;m_ftlState.jitCode-&gt;osrExitDescriptors.alloc(
              lowValue.format(), profile,
              availabilityMap().m_locals.numberOfArguments(),
<span class="line-modified">!             availabilityMap().m_locals.numberOfLocals(),</span>
<span class="line-added">+             availabilityMap().m_locals.numberOfTmps());</span>
      }
  
      void appendOSRExit(
          ExitKind kind, FormattedValue lowValue, Node* highValue, LValue failCondition,
          NodeOrigin origin, bool isExceptionHandler = false)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 17041,19 ***</span>
                          exitDescriptor-&gt;m_materializations.add(node-&gt;op(), node-&gt;origin.semantic);
                  }
              });
  
          for (unsigned i = 0; i &lt; exitDescriptor-&gt;m_values.size(); ++i) {
<span class="line-modified">!             int operand = exitDescriptor-&gt;m_values.operandForIndex(i);</span>
  
              Availability availability = availabilityMap.m_locals[i];
  
              if (Options::validateFTLOSRExitLiveness()
                  &amp;&amp; m_graph.m_plan.mode() != FTLForOSREntryMode) {
  
<span class="line-modified">!                 if (availability.isDead() &amp;&amp; m_graph.isLiveInBytecode(VirtualRegister(operand), exitOrigin))</span>
<span class="line-modified">!                     DFG_CRASH(m_graph, m_node, toCString(&quot;Live bytecode local not available: operand = &quot;, VirtualRegister(operand), &quot;, availability = &quot;, availability, &quot;, origin = &quot;, exitOrigin).data());</span>
              }
              ExitValue exitValue = exitValueForAvailability(arguments, map, availability);
              if (exitValue.hasIndexInStackmapLocations())
                  exitValue.adjustStackmapLocationsIndexByOffset(offsetOfExitArgumentsInStackmapLocations);
              exitDescriptor-&gt;m_values[i] = exitValue;
<span class="line-new-header">--- 17929,19 ---</span>
                          exitDescriptor-&gt;m_materializations.add(node-&gt;op(), node-&gt;origin.semantic);
                  }
              });
  
          for (unsigned i = 0; i &lt; exitDescriptor-&gt;m_values.size(); ++i) {
<span class="line-modified">!             Operand operand = exitDescriptor-&gt;m_values.operandForIndex(i);</span>
  
              Availability availability = availabilityMap.m_locals[i];
  
              if (Options::validateFTLOSRExitLiveness()
                  &amp;&amp; m_graph.m_plan.mode() != FTLForOSREntryMode) {
  
<span class="line-modified">!                 if (availability.isDead() &amp;&amp; m_graph.isLiveInBytecode(operand, exitOrigin))</span>
<span class="line-modified">!                     DFG_CRASH(m_graph, m_node, toCString(&quot;Live bytecode local not available: operand = &quot;, operand, &quot;, availability = &quot;, availability, &quot;, origin = &quot;, exitOrigin).data());</span>
              }
              ExitValue exitValue = exitValueForAvailability(arguments, map, availability);
              if (exitValue.hasIndexInStackmapLocations())
                  exitValue.adjustStackmapLocationsIndexByOffset(offsetOfExitArgumentsInStackmapLocations);
              exitDescriptor-&gt;m_values[i] = exitValue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 17306,10 ***</span>
<span class="line-new-header">--- 18194,15 ---</span>
          patchpoint-&gt;effects.reads = HeapRange::top();
          patchpoint-&gt;append(value, ValueRep::ColdAny);
          patchpoint-&gt;setGenerator([=] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
      }
  
<span class="line-added">+     LValue toButterfly(LValue immutableButterfly)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return m_out.addPtr(immutableButterfly, JSImmutableButterfly::offsetOfData());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void addWeakReference(JSCell* target)
      {
          m_graph.m_plan.weakReferences().addLazily(target);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 17325,62 ***</span>
      }
  
      LValue weakPointer(JSCell* pointer)
      {
          addWeakReference(pointer);
<span class="line-modified">!         return m_out.weakPointer(m_graph, pointer);</span>
      }
  
      LValue frozenPointer(FrozenValue* value)
      {
<span class="line-modified">!         return m_out.weakPointer(value);</span>
      }
  
      LValue weakStructureID(RegisteredStructure structure)
      {
          return m_out.constInt32(structure-&gt;id());
      }
  
      LValue weakStructure(RegisteredStructure structure)
      {
          ASSERT(!!structure.get());
<span class="line-modified">!         return m_out.weakPointer(m_graph, structure.get());</span>
      }
  
<span class="line-modified">!     TypedPointer addressFor(LValue base, int operand, ptrdiff_t offset = 0)</span>
      {
<span class="line-modified">!         return m_out.address(base, m_heaps.variables[operand], offset);</span>
      }
<span class="line-modified">!     TypedPointer payloadFor(LValue base, int operand)</span>
      {
          return addressFor(base, operand, PayloadOffset);
      }
<span class="line-modified">!     TypedPointer tagFor(LValue base, int operand)</span>
      {
          return addressFor(base, operand, TagOffset);
      }
<span class="line-modified">!     TypedPointer addressFor(int operand, ptrdiff_t offset = 0)</span>
      {
<span class="line-modified">!         return addressFor(VirtualRegister(operand), offset);</span>
      }
      TypedPointer addressFor(VirtualRegister operand, ptrdiff_t offset = 0)
      {
          if (operand.isLocal())
<span class="line-modified">!             return addressFor(m_captured, operand.offset(), offset);</span>
<span class="line-modified">!         return addressFor(m_callFrame, operand.offset(), offset);</span>
      }
<span class="line-modified">!     TypedPointer payloadFor(int operand)</span>
      {
<span class="line-modified">!         return payloadFor(VirtualRegister(operand));</span>
      }
      TypedPointer payloadFor(VirtualRegister operand)
      {
          return addressFor(operand, PayloadOffset);
      }
<span class="line-modified">!     TypedPointer tagFor(int operand)</span>
      {
<span class="line-modified">!         return tagFor(VirtualRegister(operand));</span>
      }
      TypedPointer tagFor(VirtualRegister operand)
      {
          return addressFor(operand, TagOffset);
      }
<span class="line-new-header">--- 18218,62 ---</span>
      }
  
      LValue weakPointer(JSCell* pointer)
      {
          addWeakReference(pointer);
<span class="line-modified">!         return m_out.alreadyRegisteredWeakPointer(m_graph, pointer);</span>
      }
  
      LValue frozenPointer(FrozenValue* value)
      {
<span class="line-modified">!         return m_out.alreadyRegisteredFrozenPointer(value);</span>
      }
  
      LValue weakStructureID(RegisteredStructure structure)
      {
          return m_out.constInt32(structure-&gt;id());
      }
  
      LValue weakStructure(RegisteredStructure structure)
      {
          ASSERT(!!structure.get());
<span class="line-modified">!         return m_out.alreadyRegisteredWeakPointer(m_graph, structure.get());</span>
      }
  
<span class="line-modified">!     TypedPointer addressFor(LValue base, Operand operand, ptrdiff_t offset = 0)</span>
      {
<span class="line-modified">!         return m_out.address(base, m_heaps.variables[operand.virtualRegister().offset()], offset);</span>
      }
<span class="line-modified">!     TypedPointer payloadFor(LValue base, Operand operand)</span>
      {
          return addressFor(base, operand, PayloadOffset);
      }
<span class="line-modified">!     TypedPointer tagFor(LValue base, Operand operand)</span>
      {
          return addressFor(base, operand, TagOffset);
      }
<span class="line-modified">!     TypedPointer addressFor(Operand operand, ptrdiff_t offset = 0)</span>
      {
<span class="line-modified">!         return addressFor(operand.virtualRegister(), offset);</span>
      }
      TypedPointer addressFor(VirtualRegister operand, ptrdiff_t offset = 0)
      {
          if (operand.isLocal())
<span class="line-modified">!             return addressFor(m_captured, operand, offset);</span>
<span class="line-modified">!         return addressFor(m_callFrame, operand, offset);</span>
      }
<span class="line-modified">!     TypedPointer payloadFor(Operand operand)</span>
      {
<span class="line-modified">!         return payloadFor(operand.virtualRegister());</span>
      }
      TypedPointer payloadFor(VirtualRegister operand)
      {
          return addressFor(operand, PayloadOffset);
      }
<span class="line-modified">!     TypedPointer tagFor(Operand operand)</span>
      {
<span class="line-modified">!         return tagFor(operand.virtualRegister());</span>
      }
      TypedPointer tagFor(VirtualRegister operand)
      {
          return addressFor(operand, TagOffset);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 17427,30 ***</span>
      }
      void crash(DFG::BasicBlock* block, Node* node)
      {
          BlockIndex blockIndex = block-&gt;index;
          unsigned nodeIndex = node ? node-&gt;index() : UINT_MAX;
<span class="line-modified">! #if ASSERT_DISABLED</span>
          m_out.patchpoint(Void)-&gt;setGenerator(
              [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
                  AllowMacroScratchRegisterUsage allowScratch(jit);
  
                  jit.move(CCallHelpers::TrustedImm32(blockIndex), GPRInfo::regT0);
                  jit.move(CCallHelpers::TrustedImm32(nodeIndex), GPRInfo::regT1);
                  if (node)
                      jit.move(CCallHelpers::TrustedImm32(node-&gt;op()), GPRInfo::regT2);
                  jit.abortWithReason(FTLCrash);
              });
<span class="line-modified">! #else</span>
          m_out.call(
              Void,
              m_out.constIntPtr(ftlUnreachable),
              // We don&#39;t want the CodeBlock to have a weak pointer to itself because
              // that would cause it to always get collected.
              m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(codeBlock())), m_out.constInt32(blockIndex),
              m_out.constInt32(nodeIndex));
<span class="line-modified">! #endif</span>
          m_out.unreachable();
      }
  
      AvailabilityMap&amp; availabilityMap() { return m_availabilityCalculator.m_availability; }
  
<span class="line-new-header">--- 18320,30 ---</span>
      }
      void crash(DFG::BasicBlock* block, Node* node)
      {
          BlockIndex blockIndex = block-&gt;index;
          unsigned nodeIndex = node ? node-&gt;index() : UINT_MAX;
<span class="line-modified">! #if !ASSERT_ENABLED</span>
          m_out.patchpoint(Void)-&gt;setGenerator(
              [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
                  AllowMacroScratchRegisterUsage allowScratch(jit);
  
                  jit.move(CCallHelpers::TrustedImm32(blockIndex), GPRInfo::regT0);
                  jit.move(CCallHelpers::TrustedImm32(nodeIndex), GPRInfo::regT1);
                  if (node)
                      jit.move(CCallHelpers::TrustedImm32(node-&gt;op()), GPRInfo::regT2);
                  jit.abortWithReason(FTLCrash);
              });
<span class="line-modified">! #else // ASSERT_ENABLED</span>
          m_out.call(
              Void,
              m_out.constIntPtr(ftlUnreachable),
              // We don&#39;t want the CodeBlock to have a weak pointer to itself because
              // that would cause it to always get collected.
              m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(codeBlock())), m_out.constInt32(blockIndex),
              m_out.constInt32(nodeIndex));
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
          m_out.unreachable();
      }
  
      AvailabilityMap&amp; availabilityMap() { return m_availabilityCalculator.m_availability; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 17465,13 ***</span>
  
      LBasicBlock m_handleExceptions;
      HashMap&lt;DFG::BasicBlock*, LBasicBlock&gt; m_blocks;
  
      LValue m_callFrame;
      LValue m_captured;
<span class="line-modified">!     LValue m_tagTypeNumber;</span>
<span class="line-modified">!     LValue m_tagMask;</span>
  
      HashMap&lt;Node*, LoweredNodeValue&gt; m_int32Values;
      HashMap&lt;Node*, LoweredNodeValue&gt; m_strictInt52Values;
      HashMap&lt;Node*, LoweredNodeValue&gt; m_int52Values;
      HashMap&lt;Node*, LoweredNodeValue&gt; m_jsValueValues;
<span class="line-new-header">--- 18358,14 ---</span>
  
      LBasicBlock m_handleExceptions;
      HashMap&lt;DFG::BasicBlock*, LBasicBlock&gt; m_blocks;
  
      LValue m_callFrame;
<span class="line-added">+     LValue m_vmValue;</span>
      LValue m_captured;
<span class="line-modified">!     LValue m_numberTag;</span>
<span class="line-modified">!     LValue m_notCellMask;</span>
  
      HashMap&lt;Node*, LoweredNodeValue&gt; m_int32Values;
      HashMap&lt;Node*, LoweredNodeValue&gt; m_strictInt52Values;
      HashMap&lt;Node*, LoweredNodeValue&gt; m_int52Values;
      HashMap&lt;Node*, LoweredNodeValue&gt; m_jsValueValues;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 17487,14 ***</span>
      AbstractInterpreter&lt;InPlaceAbstractState&gt; m_interpreter;
      DFG::BasicBlock* m_highBlock;
      DFG::BasicBlock* m_nextHighBlock;
      LBasicBlock m_nextLowBlock;
  
<span class="line-removed">-     enum IndexMaskingMode { IndexMaskingDisabled, IndexMaskingEnabled };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     IndexMaskingMode m_indexMaskingMode;</span>
<span class="line-removed">- </span>
      NodeOrigin m_origin;
      unsigned m_nodeIndex;
      Node* m_node;
  
      // These are used for validating AI state.
<span class="line-new-header">--- 18381,10 ---</span>
</pre>
<center><a href="FTLLocation.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLOSREntry.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/animation/WebAnimation.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebAnimation.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WebAnimation.idl.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/animation/WebAnimation.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,46 ***</span>
   */
  
  #pragma once
  
  #include &quot;ActiveDOMObject.h&quot;
<span class="line-modified">! #include &quot;DOMPromiseProxy.h&quot;</span>
  #include &quot;EventTarget.h&quot;
  #include &quot;ExceptionOr.h&quot;
  #include &quot;WebAnimationUtilities.h&quot;
  #include &lt;wtf/Markable.h&gt;
  #include &lt;wtf/RefCounted.h&gt;
  #include &lt;wtf/Seconds.h&gt;
  #include &lt;wtf/UniqueRef.h&gt;
  #include &lt;wtf/WeakPtr.h&gt;
  
  namespace WebCore {
  
  class AnimationEffect;
<span class="line-modified">! class AnimationPlaybackEvent;</span>
  class AnimationTimeline;
  class Document;
  class Element;
  class RenderStyle;
  
  class WebAnimation : public RefCounted&lt;WebAnimation&gt;, public CanMakeWeakPtr&lt;WebAnimation&gt;, public EventTargetWithInlineData, public ActiveDOMObject {
      WTF_MAKE_ISO_ALLOCATED(WebAnimation);
  public:
      static Ref&lt;WebAnimation&gt; create(Document&amp;, AnimationEffect*);
      static Ref&lt;WebAnimation&gt; create(Document&amp;, AnimationEffect*, AnimationTimeline*);
      ~WebAnimation();
  
      virtual bool isDeclarativeAnimation() const { return false; }
      virtual bool isCSSAnimation() const { return false; }
      virtual bool isCSSTransition() const { return false; }
  
      const String&amp; id() const { return m_id; }
      void setId(const String&amp; id) { m_id = id; }
  
      AnimationEffect* effect() const { return m_effect.get(); }
      void setEffect(RefPtr&lt;AnimationEffect&gt;&amp;&amp;);
<span class="line-modified">!     AnimationTimeline* timeline() const { return m_timeline.get(); }</span>
      virtual void setTimeline(RefPtr&lt;AnimationTimeline&gt;&amp;&amp;);
  
      Optional&lt;Seconds&gt; currentTime() const;
      ExceptionOr&lt;void&gt; setCurrentTime(Optional&lt;Seconds&gt;);
  
<span class="line-new-header">--- 24,54 ---</span>
   */
  
  #pragma once
  
  #include &quot;ActiveDOMObject.h&quot;
<span class="line-modified">! #include &quot;ComputedEffectTiming.h&quot;</span>
  #include &quot;EventTarget.h&quot;
  #include &quot;ExceptionOr.h&quot;
<span class="line-added">+ #include &quot;IDLTypes.h&quot;</span>
  #include &quot;WebAnimationUtilities.h&quot;
<span class="line-added">+ #include &lt;wtf/Forward.h&gt;</span>
  #include &lt;wtf/Markable.h&gt;
<span class="line-added">+ #include &lt;wtf/Optional.h&gt;</span>
  #include &lt;wtf/RefCounted.h&gt;
  #include &lt;wtf/Seconds.h&gt;
  #include &lt;wtf/UniqueRef.h&gt;
  #include &lt;wtf/WeakPtr.h&gt;
  
  namespace WebCore {
  
  class AnimationEffect;
<span class="line-modified">! class AnimationEventBase;</span>
  class AnimationTimeline;
  class Document;
  class Element;
  class RenderStyle;
  
<span class="line-added">+ template&lt;typename IDLType&gt; class DOMPromiseProxyWithResolveCallback;</span>
<span class="line-added">+ </span>
  class WebAnimation : public RefCounted&lt;WebAnimation&gt;, public CanMakeWeakPtr&lt;WebAnimation&gt;, public EventTargetWithInlineData, public ActiveDOMObject {
      WTF_MAKE_ISO_ALLOCATED(WebAnimation);
  public:
      static Ref&lt;WebAnimation&gt; create(Document&amp;, AnimationEffect*);
      static Ref&lt;WebAnimation&gt; create(Document&amp;, AnimationEffect*, AnimationTimeline*);
      ~WebAnimation();
  
<span class="line-added">+     static HashSet&lt;WebAnimation*&gt;&amp; instances(const LockHolder&amp;);</span>
<span class="line-added">+     static Lock&amp; instancesMutex();</span>
<span class="line-added">+ </span>
      virtual bool isDeclarativeAnimation() const { return false; }
      virtual bool isCSSAnimation() const { return false; }
      virtual bool isCSSTransition() const { return false; }
  
      const String&amp; id() const { return m_id; }
      void setId(const String&amp; id) { m_id = id; }
  
      AnimationEffect* effect() const { return m_effect.get(); }
      void setEffect(RefPtr&lt;AnimationEffect&gt;&amp;&amp;);
<span class="line-modified">!     AnimationTimeline* timeline() const;</span>
      virtual void setTimeline(RefPtr&lt;AnimationTimeline&gt;&amp;&amp;);
  
      Optional&lt;Seconds&gt; currentTime() const;
      ExceptionOr&lt;void&gt; setCurrentTime(Optional&lt;Seconds&gt;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 72,10 ***</span>
<span class="line-new-header">--- 80,14 ---</span>
      void setPlaybackRate(double);
  
      enum class PlayState : uint8_t { Idle, Running, Paused, Finished };
      PlayState playState() const;
  
<span class="line-added">+     enum class ReplaceState : uint8_t { Active, Removed, Persisted };</span>
<span class="line-added">+     ReplaceState replaceState() const { return m_replaceState; }</span>
<span class="line-added">+     void setReplaceState(ReplaceState replaceState) { m_replaceState = replaceState; }</span>
<span class="line-added">+ </span>
      bool pending() const { return hasPendingPauseTask() || hasPendingPlayTask(); }
  
      using ReadyPromise = DOMPromiseProxyWithResolveCallback&lt;IDLInterface&lt;WebAnimation&gt;&gt;;
      ReadyPromise&amp; ready() { return m_readyPromise.get(); }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 87,59 ***</span>
      ExceptionOr&lt;void&gt; finish();
      ExceptionOr&lt;void&gt; play();
      void updatePlaybackRate(double);
      ExceptionOr&lt;void&gt; pause();
      ExceptionOr&lt;void&gt; reverse();
  
      virtual Optional&lt;double&gt; startTime() const;
      virtual void setStartTime(Optional&lt;double&gt;);
      virtual Optional&lt;double&gt; bindingsCurrentTime() const;
      virtual ExceptionOr&lt;void&gt; setBindingsCurrentTime(Optional&lt;double&gt;);
      virtual PlayState bindingsPlayState() const { return playState(); }
      virtual bool bindingsPending() const { return pending(); }
      virtual ReadyPromise&amp; bindingsReady() { return ready(); }
      virtual FinishedPromise&amp; bindingsFinished() { return finished(); }
      virtual ExceptionOr&lt;void&gt; bindingsPlay() { return play(); }
      virtual ExceptionOr&lt;void&gt; bindingsPause() { return pause(); }
  
<span class="line-modified">!     virtual bool needsTick() const;</span>
      virtual void tick();
      Seconds timeToNextTick() const;
      virtual void resolve(RenderStyle&amp;);
      void effectTargetDidChange(Element* previousTarget, Element* newTarget);
      void acceleratedStateDidChange();
      void applyPendingAcceleratedActions();
  
      bool isRunningAccelerated() const;
      bool isRelevant() const { return m_isRelevant; }
<span class="line-modified">!     void effectTimingDidChange();</span>
      void suspendEffectInvalidation();
      void unsuspendEffectInvalidation();
      void setSuspended(bool);
      bool isSuspended() const { return m_isSuspended; }
<span class="line-modified">!     virtual void remove();</span>
  
      bool hasPendingActivity() const final;
  
      using RefCounted::ref;
      using RefCounted::deref;
  
  protected:
      explicit WebAnimation(Document&amp;);
  
<span class="line-modified">!     void stop() override;</span>
  
  private:
      enum class DidSeek : uint8_t { Yes, No };
      enum class SynchronouslyNotify : uint8_t { Yes, No };
      enum class RespectHoldTime : uint8_t { Yes, No };
      enum class AutoRewind : uint8_t { Yes, No };
      enum class TimeToRunPendingTask : uint8_t { NotScheduled, ASAP, WhenReady };
  
<span class="line-modified">!     void timingDidChange(DidSeek, SynchronouslyNotify);</span>
      void updateFinishedState(DidSeek, SynchronouslyNotify);
<span class="line-removed">-     void enqueueAnimationPlaybackEvent(const AtomString&amp;, Optional&lt;Seconds&gt;, Optional&lt;Seconds&gt;);</span>
      Seconds effectEndTime() const;
      WebAnimation&amp; readyPromiseResolve();
      WebAnimation&amp; finishedPromiseResolve();
      Optional&lt;Seconds&gt; currentTime(RespectHoldTime) const;
      ExceptionOr&lt;void&gt; silentlySetCurrentTime(Optional&lt;Seconds&gt;);
<span class="line-new-header">--- 99,75 ---</span>
      ExceptionOr&lt;void&gt; finish();
      ExceptionOr&lt;void&gt; play();
      void updatePlaybackRate(double);
      ExceptionOr&lt;void&gt; pause();
      ExceptionOr&lt;void&gt; reverse();
<span class="line-added">+     void persist();</span>
<span class="line-added">+     ExceptionOr&lt;void&gt; commitStyles();</span>
  
      virtual Optional&lt;double&gt; startTime() const;
      virtual void setStartTime(Optional&lt;double&gt;);
      virtual Optional&lt;double&gt; bindingsCurrentTime() const;
      virtual ExceptionOr&lt;void&gt; setBindingsCurrentTime(Optional&lt;double&gt;);
      virtual PlayState bindingsPlayState() const { return playState(); }
<span class="line-added">+     virtual ReplaceState bindingsReplaceState() const { return replaceState(); }</span>
      virtual bool bindingsPending() const { return pending(); }
      virtual ReadyPromise&amp; bindingsReady() { return ready(); }
      virtual FinishedPromise&amp; bindingsFinished() { return finished(); }
      virtual ExceptionOr&lt;void&gt; bindingsPlay() { return play(); }
      virtual ExceptionOr&lt;void&gt; bindingsPause() { return pause(); }
  
<span class="line-modified">!     bool needsTick() const;</span>
      virtual void tick();
      Seconds timeToNextTick() const;
      virtual void resolve(RenderStyle&amp;);
      void effectTargetDidChange(Element* previousTarget, Element* newTarget);
      void acceleratedStateDidChange();
      void applyPendingAcceleratedActions();
<span class="line-added">+     void willChangeRenderer();</span>
  
      bool isRunningAccelerated() const;
<span class="line-added">+     bool isCompletelyAccelerated() const;</span>
      bool isRelevant() const { return m_isRelevant; }
<span class="line-modified">!     void updateRelevance();</span>
<span class="line-added">+     void effectTimingDidChange(Optional&lt;ComputedEffectTiming&gt; = WTF::nullopt);</span>
      void suspendEffectInvalidation();
      void unsuspendEffectInvalidation();
      void setSuspended(bool);
      bool isSuspended() const { return m_isSuspended; }
<span class="line-modified">!     bool isReplaceable() const;</span>
<span class="line-added">+     void remove();</span>
<span class="line-added">+     void enqueueAnimationPlaybackEvent(const AtomString&amp;, Optional&lt;Seconds&gt;, Optional&lt;Seconds&gt;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     uint64_t globalPosition() const { return m_globalPosition; }</span>
<span class="line-added">+     void setGlobalPosition(uint64_t globalPosition) { m_globalPosition = globalPosition; }</span>
  
      bool hasPendingActivity() const final;
  
<span class="line-added">+     virtual bool canHaveGlobalPosition() { return true; }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // ContextDestructionObserver.</span>
<span class="line-added">+     ScriptExecutionContext* scriptExecutionContext() const final { return ActiveDOMObject::scriptExecutionContext(); }</span>
<span class="line-added">+     void contextDestroyed() final;</span>
<span class="line-added">+ </span>
      using RefCounted::ref;
      using RefCounted::deref;
  
  protected:
      explicit WebAnimation(Document&amp;);
  
<span class="line-modified">!     void enqueueAnimationEvent(Ref&lt;AnimationEventBase&gt;&amp;&amp;);</span>
  
  private:
      enum class DidSeek : uint8_t { Yes, No };
      enum class SynchronouslyNotify : uint8_t { Yes, No };
      enum class RespectHoldTime : uint8_t { Yes, No };
      enum class AutoRewind : uint8_t { Yes, No };
      enum class TimeToRunPendingTask : uint8_t { NotScheduled, ASAP, WhenReady };
  
<span class="line-modified">!     void timingDidChange(DidSeek, SynchronouslyNotify, Silently = Silently::No);</span>
      void updateFinishedState(DidSeek, SynchronouslyNotify);
      Seconds effectEndTime() const;
      WebAnimation&amp; readyPromiseResolve();
      WebAnimation&amp; finishedPromiseResolve();
      Optional&lt;Seconds&gt; currentTime(RespectHoldTime) const;
      ExceptionOr&lt;void&gt; silentlySetCurrentTime(Optional&lt;Seconds&gt;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 152,17 ***</span>
      void resetPendingTasks(Silently = Silently::No);
      void setEffectInternal(RefPtr&lt;AnimationEffect&gt;&amp;&amp;, bool = false);
      void setTimelineInternal(RefPtr&lt;AnimationTimeline&gt;&amp;&amp;);
      bool isEffectInvalidationSuspended() { return m_suspendCount; }
      bool computeRelevance();
<span class="line-removed">-     void updateRelevance();</span>
      void invalidateEffect();
      double effectivePlaybackRate() const;
      void applyPendingPlaybackRate();
  
      RefPtr&lt;AnimationEffect&gt; m_effect;
<span class="line-modified">!     RefPtr&lt;AnimationTimeline&gt; m_timeline;</span>
      UniqueRef&lt;ReadyPromise&gt; m_readyPromise;
      UniqueRef&lt;FinishedPromise&gt; m_finishedPromise;
      Markable&lt;Seconds, Seconds::MarkableTraits&gt; m_previousCurrentTime;
      Markable&lt;Seconds, Seconds::MarkableTraits&gt; m_startTime;
      Markable&lt;Seconds, Seconds::MarkableTraits&gt; m_holdTime;
<span class="line-new-header">--- 180,16 ---</span>
      void resetPendingTasks(Silently = Silently::No);
      void setEffectInternal(RefPtr&lt;AnimationEffect&gt;&amp;&amp;, bool = false);
      void setTimelineInternal(RefPtr&lt;AnimationTimeline&gt;&amp;&amp;);
      bool isEffectInvalidationSuspended() { return m_suspendCount; }
      bool computeRelevance();
      void invalidateEffect();
      double effectivePlaybackRate() const;
      void applyPendingPlaybackRate();
  
      RefPtr&lt;AnimationEffect&gt; m_effect;
<span class="line-modified">!     WeakPtr&lt;AnimationTimeline&gt; m_timeline;</span>
      UniqueRef&lt;ReadyPromise&gt; m_readyPromise;
      UniqueRef&lt;FinishedPromise&gt; m_finishedPromise;
      Markable&lt;Seconds, Seconds::MarkableTraits&gt; m_previousCurrentTime;
      Markable&lt;Seconds, Seconds::MarkableTraits&gt; m_startTime;
      Markable&lt;Seconds, Seconds::MarkableTraits&gt; m_holdTime;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 170,27 ***</span>
      double m_playbackRate { 1 };
      String m_id;
  
      int m_suspendCount { 0 };
  
<span class="line-removed">-     bool m_isStopped { false };</span>
      bool m_isSuspended { false };
      bool m_finishNotificationStepsMicrotaskPending;
      bool m_isRelevant;
      bool m_shouldSkipUpdatingFinishedStateWhenResolving;
      TimeToRunPendingTask m_timeToRunPendingPlayTask { TimeToRunPendingTask::NotScheduled };
      TimeToRunPendingTask m_timeToRunPendingPauseTask { TimeToRunPendingTask::NotScheduled };
  
      // ActiveDOMObject.
      const char* activeDOMObjectName() const final;
<span class="line-modified">!     bool canSuspendForDocumentSuspension() const final;</span>
  
      // EventTarget
      EventTargetInterface eventTargetInterface() const final { return WebAnimationEventTargetInterfaceType; }
      void refEventTarget() final { ref(); }
      void derefEventTarget() final { deref(); }
<span class="line-removed">-     ScriptExecutionContext* scriptExecutionContext() const final { return ActiveDOMObject::scriptExecutionContext(); }</span>
  };
  
  } // namespace WebCore
  
  #define SPECIALIZE_TYPE_TRAITS_WEB_ANIMATION(ToValueTypeName, predicate) \
<span class="line-new-header">--- 197,30 ---</span>
      double m_playbackRate { 1 };
      String m_id;
  
      int m_suspendCount { 0 };
  
      bool m_isSuspended { false };
      bool m_finishNotificationStepsMicrotaskPending;
      bool m_isRelevant;
      bool m_shouldSkipUpdatingFinishedStateWhenResolving;
<span class="line-added">+     bool m_hasScheduledEventsDuringTick { false };</span>
      TimeToRunPendingTask m_timeToRunPendingPlayTask { TimeToRunPendingTask::NotScheduled };
      TimeToRunPendingTask m_timeToRunPendingPauseTask { TimeToRunPendingTask::NotScheduled };
<span class="line-added">+     ReplaceState m_replaceState { ReplaceState::Active };</span>
<span class="line-added">+     uint64_t m_globalPosition { 0 };</span>
  
      // ActiveDOMObject.
      const char* activeDOMObjectName() const final;
<span class="line-modified">!     void suspend(ReasonForSuspension) final;</span>
<span class="line-added">+     void resume() final;</span>
<span class="line-added">+     void stop() final;</span>
  
      // EventTarget
      EventTargetInterface eventTargetInterface() const final { return WebAnimationEventTargetInterfaceType; }
      void refEventTarget() final { ref(); }
      void derefEventTarget() final { deref(); }
  };
  
  } // namespace WebCore
  
  #define SPECIALIZE_TYPE_TRAITS_WEB_ANIMATION(ToValueTypeName, predicate) \
</pre>
<center><a href="WebAnimation.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WebAnimation.idl.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/SelectorQuery.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011-2018 Apple Inc. All rights reserved.
  3  * Copyright (C) 2014 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 17  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 18  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 19  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 20  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 21  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 22  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 24  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;SelectorQuery.h&quot;
 29 
 30 #include &quot;CSSParser.h&quot;
 31 #include &quot;ElementDescendantIterator.h&quot;
 32 #include &quot;HTMLNames.h&quot;
 33 #include &quot;SelectorChecker.h&quot;
 34 #include &quot;StaticNodeList.h&quot;
 35 #include &quot;StyledElement.h&quot;
 36 
 37 namespace WebCore {
 38 
<a name="1" id="anc1"></a><span class="line-modified"> 39 #if ASSERT_ENABLED</span>
 40 static bool isSingleTagNameSelector(const CSSSelector&amp; selector)
 41 {
 42     return selector.isLastInTagHistory() &amp;&amp; selector.match() == CSSSelector::Tag;
 43 }
 44 
 45 static bool isSingleClassNameSelector(const CSSSelector&amp; selector)
 46 {
 47     return selector.isLastInTagHistory() &amp;&amp; selector.match() == CSSSelector::Class;
 48 }
<a name="2" id="anc2"></a><span class="line-modified"> 49 #endif // ASSERT_ENABLED</span>
 50 
 51 enum class IdMatchingType : uint8_t {
 52     None,
 53     Rightmost,
 54     Filter
 55 };
 56 
 57 static bool canBeUsedForIdFastPath(const CSSSelector&amp; selector)
 58 {
 59     return selector.match() == CSSSelector::Id
 60         || (selector.match() == CSSSelector::Exact &amp;&amp; selector.attribute() == HTMLNames::idAttr &amp;&amp; !selector.attributeValueMatchingIsCaseInsensitive());
 61 }
 62 
 63 static IdMatchingType findIdMatchingType(const CSSSelector&amp; firstSelector)
 64 {
 65     bool inRightmost = true;
 66     for (const CSSSelector* selector = &amp;firstSelector; selector; selector = selector-&gt;tagHistory()) {
 67         if (canBeUsedForIdFastPath(*selector)) {
 68             if (inRightmost)
 69                 return IdMatchingType::Rightmost;
 70             return IdMatchingType::Filter;
 71         }
 72         if (selector-&gt;relation() != CSSSelector::Subselector)
 73             inRightmost = false;
 74     }
 75     return IdMatchingType::None;
 76 }
 77 
 78 SelectorDataList::SelectorDataList(const CSSSelectorList&amp; selectorList)
 79 {
 80     unsigned selectorCount = 0;
 81     for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector))
 82         selectorCount++;
 83 
 84     m_selectors.reserveInitialCapacity(selectorCount);
 85     for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector))
<a name="3" id="anc3"></a><span class="line-modified"> 86         m_selectors.uncheckedAppend({ selector });</span>
 87 
 88     if (selectorCount == 1) {
 89         const CSSSelector&amp; selector = *m_selectors.first().selector;
 90         if (selector.isLastInTagHistory()) {
 91             switch (selector.match()) {
 92             case CSSSelector::Tag:
 93                 m_matchType = TagNameMatch;
 94                 break;
 95             case CSSSelector::Class:
 96                 m_matchType = ClassNameMatch;
 97                 break;
 98             default:
 99                 if (canBeUsedForIdFastPath(selector))
100                     m_matchType = RightMostWithIdMatch;
101                 else
102                     m_matchType = CompilableSingle;
103                 break;
104             }
105         } else {
106             switch (findIdMatchingType(selector)) {
107             case IdMatchingType::None:
108                 m_matchType = CompilableSingle;
109                 break;
110             case IdMatchingType::Rightmost:
111                 m_matchType = RightMostWithIdMatch;
112                 break;
113             case IdMatchingType::Filter:
114                 m_matchType = CompilableSingleWithRootFilter;
115                 break;
116             }
117         }
118     } else
119         m_matchType = CompilableMultipleSelectorMatch;
120 }
121 
122 inline bool SelectorDataList::selectorMatches(const SelectorData&amp; selectorData, Element&amp; element, const ContainerNode&amp; rootNode) const
123 {
124     SelectorChecker selectorChecker(element.document());
125     SelectorChecker::CheckingContext selectorCheckingContext(SelectorChecker::Mode::QueryingRules);
126     selectorCheckingContext.scope = rootNode.isDocumentNode() ? nullptr : &amp;rootNode;
127     unsigned ignoredSpecificity;
128     return selectorChecker.match(*selectorData.selector, element, selectorCheckingContext, ignoredSpecificity);
129 }
130 
131 inline Element* SelectorDataList::selectorClosest(const SelectorData&amp; selectorData, Element&amp; element, const ContainerNode&amp; rootNode) const
132 {
133     SelectorChecker selectorChecker(element.document());
134     SelectorChecker::CheckingContext selectorCheckingContext(SelectorChecker::Mode::QueryingRules);
135     selectorCheckingContext.scope = rootNode.isDocumentNode() ? nullptr : &amp;rootNode;
136     unsigned ignoredSpecificity;
137     if (!selectorChecker.match(*selectorData.selector, element, selectorCheckingContext, ignoredSpecificity))
138         return nullptr;
139     return &amp;element;
140 }
141 
142 bool SelectorDataList::matches(Element&amp; targetElement) const
143 {
144     for (auto&amp; selctor : m_selectors) {
145         if (selectorMatches(selctor, targetElement, targetElement))
146             return true;
147     }
148     return false;
149 }
150 
151 Element* SelectorDataList::closest(Element&amp; targetElement) const
152 {
153     Element* currentNode = &amp;targetElement;
154     do {
155         for (auto&amp; selector : m_selectors) {
156             Element* candidateElement = selectorClosest(selector, *currentNode, targetElement);
157             if (candidateElement)
158                 return candidateElement;
159         }
160         currentNode = currentNode-&gt;parentElement();
161     } while (currentNode);
162     return nullptr;
163 }
164 
165 struct AllElementExtractorSelectorQueryTrait {
166     typedef Vector&lt;Ref&lt;Element&gt;&gt; OutputType;
167     static const bool shouldOnlyMatchFirstElement = false;
168     ALWAYS_INLINE static void appendOutputForElement(OutputType&amp; output, Element* element) { ASSERT(element); output.append(*element); }
169 };
170 
171 Ref&lt;NodeList&gt; SelectorDataList::queryAll(ContainerNode&amp; rootNode) const
172 {
173     Vector&lt;Ref&lt;Element&gt;&gt; result;
174     execute&lt;AllElementExtractorSelectorQueryTrait&gt;(rootNode, result);
175     return StaticElementList::create(WTFMove(result));
176 }
177 
178 struct SingleElementExtractorSelectorQueryTrait {
179     typedef Element* OutputType;
180     static const bool shouldOnlyMatchFirstElement = true;
181     ALWAYS_INLINE static void appendOutputForElement(OutputType&amp; output, Element* element)
182     {
183         ASSERT(element);
184         ASSERT(!output);
185         output = element;
186     }
187 };
188 
189 Element* SelectorDataList::queryFirst(ContainerNode&amp; rootNode) const
190 {
191     Element* result = nullptr;
192     execute&lt;SingleElementExtractorSelectorQueryTrait&gt;(rootNode, result);
193     return result;
194 }
195 
196 static const CSSSelector* selectorForIdLookup(const ContainerNode&amp; rootNode, const CSSSelector&amp; firstSelector)
197 {
198     if (!rootNode.isConnected())
199         return nullptr;
200     if (rootNode.document().inQuirksMode())
201         return nullptr;
202 
203     for (const CSSSelector* selector = &amp;firstSelector; selector; selector = selector-&gt;tagHistory()) {
204         if (canBeUsedForIdFastPath(*selector))
205             return selector;
206         if (selector-&gt;relation() != CSSSelector::Subselector)
207             break;
208     }
209 
210     return nullptr;
211 }
212 
213 static inline bool isTreeScopeRoot(const ContainerNode&amp; node)
214 {
215     return node.isDocumentNode() || node.isShadowRoot();
216 }
217 
218 template &lt;typename SelectorQueryTrait&gt;
219 ALWAYS_INLINE void SelectorDataList::executeFastPathForIdSelector(const ContainerNode&amp; rootNode, const SelectorData&amp; selectorData, const CSSSelector* idSelector, typename SelectorQueryTrait::OutputType&amp; output) const
220 {
221     ASSERT(m_selectors.size() == 1);
222     ASSERT(idSelector);
223 
224     const AtomString&amp; idToMatch = idSelector-&gt;value();
225     if (UNLIKELY(rootNode.treeScope().containsMultipleElementsWithId(idToMatch))) {
226         const Vector&lt;Element*&gt;* elements = rootNode.treeScope().getAllElementsById(idToMatch);
227         ASSERT(elements);
228         bool rootNodeIsTreeScopeRoot = isTreeScopeRoot(rootNode);
229         for (auto&amp; element : *elements) {
230             if ((rootNodeIsTreeScopeRoot || element-&gt;isDescendantOf(rootNode)) &amp;&amp; selectorMatches(selectorData, *element, rootNode)) {
231                 SelectorQueryTrait::appendOutputForElement(output, element);
232                 if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
233                     return;
234             }
235         }
236         return;
237     }
238 
239     Element* element = rootNode.treeScope().getElementById(idToMatch);
240     if (!element || !(isTreeScopeRoot(rootNode) || element-&gt;isDescendantOf(rootNode)))
241         return;
242     if (selectorMatches(selectorData, *element, rootNode))
243         SelectorQueryTrait::appendOutputForElement(output, element);
244 }
245 
246 static ContainerNode&amp; filterRootById(ContainerNode&amp; rootNode, const CSSSelector&amp; firstSelector)
247 {
248     if (!rootNode.isConnected())
249         return rootNode;
250     if (rootNode.document().inQuirksMode())
251         return rootNode;
252 
253     // If there was an Id match in the rightmost Simple Selector, we should be in a RightMostWithIdMatch, not in filter.
254     // Thus we can skip the rightmost match.
255     const CSSSelector* selector = &amp;firstSelector;
256     do {
257         ASSERT(!canBeUsedForIdFastPath(*selector));
258         if (selector-&gt;relation() != CSSSelector::Subselector)
259             break;
260         selector = selector-&gt;tagHistory();
261     } while (selector);
262 
263     bool inAdjacentChain = false;
264     for (; selector; selector = selector-&gt;tagHistory()) {
265         if (canBeUsedForIdFastPath(*selector)) {
266             const AtomString&amp; idToMatch = selector-&gt;value();
267             if (ContainerNode* searchRoot = rootNode.treeScope().getElementById(idToMatch)) {
268                 if (LIKELY(!rootNode.treeScope().containsMultipleElementsWithId(idToMatch))) {
269                     if (inAdjacentChain)
270                         searchRoot = searchRoot-&gt;parentNode();
271                     if (searchRoot &amp;&amp; (isTreeScopeRoot(rootNode) || searchRoot == &amp;rootNode || searchRoot-&gt;isDescendantOf(rootNode)))
272                         return *searchRoot;
273                 }
274             }
275         }
276         if (selector-&gt;relation() == CSSSelector::Subselector)
277             continue;
278         if (selector-&gt;relation() == CSSSelector::DirectAdjacent || selector-&gt;relation() == CSSSelector::IndirectAdjacent)
279             inAdjacentChain = true;
280         else
281             inAdjacentChain = false;
282     }
283     return rootNode;
284 }
285 
286 static ALWAYS_INLINE bool localNameMatches(const Element&amp; element, const AtomString&amp; localName, const AtomString&amp; lowercaseLocalName)
287 {
288     if (element.isHTMLElement() &amp;&amp; element.document().isHTMLDocument())
289         return element.localName() == lowercaseLocalName;
290     return element.localName() == localName;
291 
292 }
293 
294 template &lt;typename SelectorQueryTrait&gt;
295 static inline void elementsForLocalName(const ContainerNode&amp; rootNode, const AtomString&amp; localName, const AtomString&amp; lowercaseLocalName, typename SelectorQueryTrait::OutputType&amp; output)
296 {
297     if (localName == lowercaseLocalName) {
298         for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(rootNode))) {
299             if (element.tagQName().localName() == localName) {
300                 SelectorQueryTrait::appendOutputForElement(output, &amp;element);
301                 if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
302                 return;
303             }
304         }
305     } else {
306         for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(rootNode))) {
307             if (localNameMatches(element, localName, lowercaseLocalName)) {
308                 SelectorQueryTrait::appendOutputForElement(output, &amp;element);
309                 if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
310                 return;
311             }
312         }
313     }
314 }
315 
316 template &lt;typename SelectorQueryTrait&gt;
317 static inline void anyElement(const ContainerNode&amp; rootNode, typename SelectorQueryTrait::OutputType&amp; output)
318 {
319     for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(rootNode))) {
320         SelectorQueryTrait::appendOutputForElement(output, &amp;element);
321         if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
322             return;
323     }
324 }
325 
326 
327 template &lt;typename SelectorQueryTrait&gt;
328 ALWAYS_INLINE void SelectorDataList::executeSingleTagNameSelectorData(const ContainerNode&amp; rootNode, const SelectorData&amp; selectorData, typename SelectorQueryTrait::OutputType&amp; output) const
329 {
330     ASSERT(m_selectors.size() == 1);
331     ASSERT(isSingleTagNameSelector(*selectorData.selector));
332 
333     const QualifiedName&amp; tagQualifiedName = selectorData.selector-&gt;tagQName();
334     const AtomString&amp; selectorLocalName = tagQualifiedName.localName();
335     const AtomString&amp; selectorLowercaseLocalName = selectorData.selector-&gt;tagLowercaseLocalName();
336     const AtomString&amp; selectorNamespaceURI = tagQualifiedName.namespaceURI();
337 
338     if (selectorNamespaceURI == starAtom()) {
339         if (selectorLocalName != starAtom()) {
340             // Common case: name defined, selectorNamespaceURI is a wildcard.
341             elementsForLocalName&lt;SelectorQueryTrait&gt;(rootNode, selectorLocalName, selectorLowercaseLocalName, output);
342         } else {
343             // Other fairly common case: both are wildcards.
344             anyElement&lt;SelectorQueryTrait&gt;(rootNode, output);
345         }
346     } else {
347         // Fallback: NamespaceURI is set, selectorLocalName may be starAtom().
348         for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(rootNode))) {
349             if (element.namespaceURI() == selectorNamespaceURI &amp;&amp; localNameMatches(element, selectorLocalName, selectorLowercaseLocalName)) {
350                 SelectorQueryTrait::appendOutputForElement(output, &amp;element);
351                 if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
352                     return;
353             }
354         }
355     }
356 }
357 
358 template &lt;typename SelectorQueryTrait&gt;
359 ALWAYS_INLINE void SelectorDataList::executeSingleClassNameSelectorData(const ContainerNode&amp; rootNode, const SelectorData&amp; selectorData, typename SelectorQueryTrait::OutputType&amp; output) const
360 {
361     ASSERT(m_selectors.size() == 1);
362     ASSERT(isSingleClassNameSelector(*selectorData.selector));
363 
364     const AtomString&amp; className = selectorData.selector-&gt;value();
365     for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(rootNode))) {
366         if (element.hasClass() &amp;&amp; element.classNames().contains(className)) {
367             SelectorQueryTrait::appendOutputForElement(output, &amp;element);
368             if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
369                 return;
370         }
371     }
372 }
373 
374 template &lt;typename SelectorQueryTrait&gt;
375 ALWAYS_INLINE void SelectorDataList::executeSingleSelectorData(const ContainerNode&amp; rootNode, const ContainerNode&amp; searchRootNode, const SelectorData&amp; selectorData, typename SelectorQueryTrait::OutputType&amp; output) const
376 {
377     ASSERT(m_selectors.size() == 1);
378 
379     for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(searchRootNode))) {
380         if (selectorMatches(selectorData, element, rootNode)) {
381             SelectorQueryTrait::appendOutputForElement(output, &amp;element);
382             if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
383                 return;
384         }
385     }
386 }
387 
388 template &lt;typename SelectorQueryTrait&gt;
389 ALWAYS_INLINE void SelectorDataList::executeSingleMultiSelectorData(const ContainerNode&amp; rootNode, typename SelectorQueryTrait::OutputType&amp; output) const
390 {
391     for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(rootNode))) {
392         for (auto&amp; selector : m_selectors) {
393             if (selectorMatches(selector, element, rootNode)) {
394                 SelectorQueryTrait::appendOutputForElement(output, &amp;element);
395                 if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
396                     return;
397                 break;
398             }
399         }
400     }
401 }
402 
403 #if ENABLE(CSS_SELECTOR_JIT)
404 template &lt;typename SelectorQueryTrait&gt;
405 ALWAYS_INLINE void SelectorDataList::executeCompiledSimpleSelectorChecker(const ContainerNode&amp; searchRootNode, SelectorCompiler::QuerySelectorSimpleSelectorChecker selectorChecker, typename SelectorQueryTrait::OutputType&amp; output, const SelectorData&amp; selectorData) const
406 {
407     for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(searchRootNode))) {
<a name="4" id="anc4"></a><span class="line-modified">408         selectorData.compiledSelector.wasUsed();</span>
<span class="line-modified">409 </span>



410         if (selectorChecker(&amp;element)) {
411             SelectorQueryTrait::appendOutputForElement(output, &amp;element);
412             if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
413                 return;
414         }
415     }
416 }
417 
418 template &lt;typename SelectorQueryTrait&gt;
419 ALWAYS_INLINE void SelectorDataList::executeCompiledSelectorCheckerWithCheckingContext(const ContainerNode&amp; rootNode, const ContainerNode&amp; searchRootNode, SelectorCompiler::QuerySelectorSelectorCheckerWithCheckingContext selectorChecker, typename SelectorQueryTrait::OutputType&amp; output, const SelectorData&amp; selectorData) const
420 {
421     SelectorChecker::CheckingContext checkingContext(SelectorChecker::Mode::QueryingRules);
422     checkingContext.scope = rootNode.isDocumentNode() ? nullptr : &amp;rootNode;
423 
424     for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(searchRootNode))) {
<a name="5" id="anc5"></a><span class="line-modified">425         selectorData.compiledSelector.wasUsed();</span>
<span class="line-modified">426 </span>



427         if (selectorChecker(&amp;element, &amp;checkingContext)) {
428             SelectorQueryTrait::appendOutputForElement(output, &amp;element);
429             if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
430                 return;
431         }
432     }
433 }
434 
435 template &lt;typename SelectorQueryTrait&gt;
436 ALWAYS_INLINE void SelectorDataList::executeCompiledSingleMultiSelectorData(const ContainerNode&amp; rootNode, typename SelectorQueryTrait::OutputType&amp; output) const
437 {
438     SelectorChecker::CheckingContext checkingContext(SelectorChecker::Mode::QueryingRules);
439     checkingContext.scope = rootNode.isDocumentNode() ? nullptr : &amp;rootNode;
440     for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(rootNode))) {
441         for (auto&amp; selector : m_selectors) {
<a name="6" id="anc6"></a><span class="line-modified">442             selector.compiledSelector.wasUsed();</span>
<span class="line-modified">443 </span>

444             bool matched = false;
<a name="7" id="anc7"></a><span class="line-modified">445             if (selector.compiledSelector.status == SelectorCompilationStatus::SimpleSelectorChecker) {</span>
<span class="line-modified">446                 auto selectorChecker = SelectorCompiler::querySelectorSimpleSelectorCheckerFunction(selector.compiledSelector);</span>

447                 matched = selectorChecker(&amp;element);
448             } else {
<a name="8" id="anc8"></a><span class="line-modified">449                 ASSERT(selector.compiledSelector.status == SelectorCompilationStatus::SelectorCheckerWithCheckingContext);</span>
<span class="line-modified">450                 auto selectorChecker = SelectorCompiler::querySelectorSelectorCheckerFunctionWithCheckingContext(selector.compiledSelector);</span>
451                 matched = selectorChecker(&amp;element, &amp;checkingContext);
452             }
453             if (matched) {
454                 SelectorQueryTrait::appendOutputForElement(output, &amp;element);
455                 if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
456                     return;
457                 break;
458             }
459         }
460     }
461 }
462 
<a name="9" id="anc9"></a>




463 bool SelectorDataList::compileSelector(const SelectorData&amp; selectorData)
464 {
<a name="10" id="anc10"></a><span class="line-modified">465     auto&amp; compiledSelector = selectorData.compiledSelector;</span>

466 
<a name="11" id="anc11"></a><span class="line-modified">467     if (compiledSelector.status == SelectorCompilationStatus::NotCompiled)</span>
<span class="line-modified">468         SelectorCompiler::compileSelector(compiledSelector, selectorData.selector, SelectorCompiler::SelectorContext::QuerySelector);</span>

469 
<a name="12" id="anc12"></a><span class="line-added">470     return compiledSelector.status != SelectorCompilationStatus::CannotCompile;</span>
<span class="line-added">471 }</span>
472 
473 #endif // ENABLE(CSS_SELECTOR_JIT)
474 
475 template &lt;typename SelectorQueryTrait&gt;
476 ALWAYS_INLINE void SelectorDataList::execute(ContainerNode&amp; rootNode, typename SelectorQueryTrait::OutputType&amp; output) const
477 {
478     ContainerNode* searchRootNode = &amp;rootNode;
479     switch (m_matchType) {
480     case RightMostWithIdMatch:
481         {
482         const SelectorData&amp; selectorData = m_selectors.first();
483         if (const CSSSelector* idSelector = selectorForIdLookup(*searchRootNode, *selectorData.selector)) {
484             executeFastPathForIdSelector&lt;SelectorQueryTrait&gt;(*searchRootNode, m_selectors.first(), idSelector, output);
485             break;
486         }
487 #if ENABLE(CSS_SELECTOR_JIT)
488         if (compileSelector(selectorData))
489             goto CompiledSingleCase;
490 #endif // ENABLE(CSS_SELECTOR_JIT)
491         goto SingleSelectorCase;
492         ASSERT_NOT_REACHED();
493         }
494 
495     case CompilableSingleWithRootFilter:
496     case CompilableSingle:
497         {
498 #if ENABLE(CSS_SELECTOR_JIT)
499         const SelectorData&amp; selectorData = m_selectors.first();
<a name="13" id="anc13"></a><span class="line-modified">500         ASSERT(selectorData.compiledSelector.status == SelectorCompilationStatus::NotCompiled);</span>
501         ASSERT(m_matchType == CompilableSingle || m_matchType == CompilableSingleWithRootFilter);
502         if (compileSelector(selectorData)) {
503             if (m_matchType == CompilableSingle) {
504                 m_matchType = CompiledSingle;
505                 goto CompiledSingleCase;
506             }
507             ASSERT(m_matchType == CompilableSingleWithRootFilter);
508             m_matchType = CompiledSingleWithRootFilter;
509             goto CompiledSingleWithRootFilterCase;
510         }
511 #endif // ENABLE(CSS_SELECTOR_JIT)
512         if (m_matchType == CompilableSingle) {
513             m_matchType = SingleSelector;
514             goto SingleSelectorCase;
515         }
516         ASSERT(m_matchType == CompilableSingleWithRootFilter);
517         m_matchType = SingleSelectorWithRootFilter;
518         goto SingleSelectorWithRootFilterCase;
519         ASSERT_NOT_REACHED();
520         }
521 
522 #if ENABLE(CSS_SELECTOR_JIT)
523     case CompiledSingleWithRootFilter:
524         CompiledSingleWithRootFilterCase:
525         searchRootNode = &amp;filterRootById(*searchRootNode, *m_selectors.first().selector);
526         FALLTHROUGH;
527     case CompiledSingle:
528         {
529         CompiledSingleCase:
530         const SelectorData&amp; selectorData = m_selectors.first();
<a name="14" id="anc14"></a><span class="line-modified">531         if (selectorData.compiledSelector.status == SelectorCompilationStatus::SimpleSelectorChecker) {</span>
<span class="line-modified">532             auto selectorChecker = SelectorCompiler::querySelectorSimpleSelectorCheckerFunction(selectorData.compiledSelector);</span>

533             executeCompiledSimpleSelectorChecker&lt;SelectorQueryTrait&gt;(*searchRootNode, selectorChecker, output, selectorData);
534         } else {
<a name="15" id="anc15"></a><span class="line-modified">535             ASSERT(selectorData.compiledSelector.status == SelectorCompilationStatus::SelectorCheckerWithCheckingContext);</span>
<span class="line-modified">536             auto selectorChecker = SelectorCompiler::querySelectorSelectorCheckerFunctionWithCheckingContext(selectorData.compiledSelector);</span>
537             executeCompiledSelectorCheckerWithCheckingContext&lt;SelectorQueryTrait&gt;(rootNode, *searchRootNode, selectorChecker, output, selectorData);
538         }
539         break;
540         }
541 #else
542     case CompiledSingleWithRootFilter:
543     case CompiledSingle:
544         ASSERT_NOT_REACHED();
<a name="16" id="anc16"></a><span class="line-modified">545 #if !ASSERT_ENABLED</span>
546         FALLTHROUGH;
547 #endif
548 #endif // ENABLE(CSS_SELECTOR_JIT)
549 
550     case SingleSelectorWithRootFilter:
551         SingleSelectorWithRootFilterCase:
552         searchRootNode = &amp;filterRootById(*searchRootNode, *m_selectors.first().selector);
553         FALLTHROUGH;
554     case SingleSelector:
555         SingleSelectorCase:
556         executeSingleSelectorData&lt;SelectorQueryTrait&gt;(rootNode, *searchRootNode, m_selectors.first(), output);
557         break;
558 
559     case TagNameMatch:
560         executeSingleTagNameSelectorData&lt;SelectorQueryTrait&gt;(*searchRootNode, m_selectors.first(), output);
561         break;
562     case ClassNameMatch:
563         executeSingleClassNameSelectorData&lt;SelectorQueryTrait&gt;(*searchRootNode, m_selectors.first(), output);
564         break;
565     case CompilableMultipleSelectorMatch:
566 #if ENABLE(CSS_SELECTOR_JIT)
567         {
568         for (auto&amp; selector : m_selectors) {
569             if (!compileSelector(selector)) {
570                 m_matchType = MultipleSelectorMatch;
571                 goto MultipleSelectorMatch;
572             }
573         }
574         m_matchType = CompiledMultipleSelectorMatch;
575         goto CompiledMultipleSelectorMatch;
576         }
577 #else
578         FALLTHROUGH;
579 #endif // ENABLE(CSS_SELECTOR_JIT)
580     case CompiledMultipleSelectorMatch:
581 #if ENABLE(CSS_SELECTOR_JIT)
582         CompiledMultipleSelectorMatch:
583         executeCompiledSingleMultiSelectorData&lt;SelectorQueryTrait&gt;(*searchRootNode, output);
584         break;
585 #else
586         FALLTHROUGH;
587 #endif // ENABLE(CSS_SELECTOR_JIT)
588     case MultipleSelectorMatch:
589 #if ENABLE(CSS_SELECTOR_JIT)
590         MultipleSelectorMatch:
591 #endif
592         executeSingleMultiSelectorData&lt;SelectorQueryTrait&gt;(*searchRootNode, output);
593         break;
594     }
595 }
596 
597 SelectorQuery::SelectorQuery(CSSSelectorList&amp;&amp; selectorList)
598     : m_selectorList(WTFMove(selectorList))
599     , m_selectors(m_selectorList)
600 {
601 }
602 
603 ExceptionOr&lt;SelectorQuery&amp;&gt; SelectorQueryCache::add(const String&amp; selectors, Document&amp; document)
604 {
605     if (auto* entry = m_entries.get(selectors))
606         return *entry;
607 
608     CSSParser parser(document);
609     CSSSelectorList selectorList;
610     parser.parseSelector(selectors, selectorList);
611 
612     if (!selectorList.first() || selectorList.hasInvalidSelector())
613         return Exception { SyntaxError };
614 
615     if (selectorList.selectorsNeedNamespaceResolution())
616         return Exception { SyntaxError };
617 
618     const int maximumSelectorQueryCacheSize = 256;
619     if (m_entries.size() == maximumSelectorQueryCacheSize)
620         m_entries.remove(m_entries.random());
621 
622     return *m_entries.add(selectors, makeUnique&lt;SelectorQuery&gt;(WTFMove(selectorList))).iterator-&gt;value;
623 }
624 
625 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
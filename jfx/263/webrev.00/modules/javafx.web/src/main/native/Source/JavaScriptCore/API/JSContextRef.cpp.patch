diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSContextRef.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSContextRef.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSContextRef.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSContextRef.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2006, 2007, 2013, 2016 Apple Inc. All rights reserved.
+ * Copyright (C) 2006-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -54,11 +54,11 @@
 #endif
 
 #if OS(DARWIN)
 #include <mach-o/dyld.h>
 
-static const int32_t webkitFirstVersionWithConcurrentGlobalContexts = 0x2100500; // 528.5.0
+static constexpr int32_t webkitFirstVersionWithConcurrentGlobalContexts = 0x2100500; // 528.5.0
 #endif
 
 using namespace JSC;
 
 // From the API's perspective, a context group remains alive iff
@@ -66,11 +66,10 @@
 //     OR
 //     (b) one of its contexts has been JSContextRetained
 
 JSContextGroupRef JSContextGroupCreate()
 {
-    WTF::initializeMainThread();
     initializeThreading();
     return toRef(&VM::createContextGroup().leakRef());
 }
 
 JSContextGroupRef JSContextGroupRetain(JSContextGroupRef group)
@@ -85,14 +84,14 @@
 
     JSLockHolder locker(&vm);
     vm.deref();
 }
 
-static bool internalScriptTimeoutCallback(ExecState* exec, void* callbackPtr, void* callbackData)
+static bool internalScriptTimeoutCallback(JSGlobalObject* globalObject, void* callbackPtr, void* callbackData)
 {
     JSShouldTerminateCallback callback = reinterpret_cast<JSShouldTerminateCallback>(callbackPtr);
-    JSContextRef contextRef = toRef(exec);
+    JSContextRef contextRef = toRef(globalObject);
     ASSERT(callback);
     return callback(contextRef, callbackData);
 }
 
 void JSContextGroupSetExecutionTimeLimit(JSContextGroupRef group, double limit, JSShouldTerminateCallback callback, void* callbackData)
@@ -117,11 +116,10 @@
 
 // From the API's perspective, a global context remains alive iff it has been JSGlobalContextRetained.
 
 JSGlobalContextRef JSGlobalContextCreate(JSClassRef globalObjectClass)
 {
-    WTF::initializeMainThread();
     initializeThreading();
 
 #if OS(DARWIN)
     // If the application was linked before JSGlobalContextCreate was changed to use a unique VM,
     // we use a shared one for backwards compatibility.
@@ -133,11 +131,10 @@
     return JSGlobalContextCreateInGroup(0, globalObjectClass);
 }
 
 JSGlobalContextRef JSGlobalContextCreateInGroup(JSContextGroupRef group, JSClassRef globalObjectClass)
 {
-    WTF::initializeMainThread();
     initializeThreading();
 
     Ref<VM> vm = group ? Ref<VM>(*toJS(group)) : VM::createContextGroup();
 
     JSLockHolder locker(vm.ptr());
@@ -146,44 +143,43 @@
         JSGlobalObject* globalObject = JSAPIGlobalObject::create(vm.get(), JSAPIGlobalObject::createStructure(vm.get(), jsNull()));
 #if ENABLE(REMOTE_INSPECTOR)
         if (JSRemoteInspectorGetInspectionEnabledByDefault())
             globalObject->setRemoteDebuggingEnabled(true);
 #endif
-        return JSGlobalContextRetain(toGlobalRef(globalObject->globalExec()));
+        return JSGlobalContextRetain(toGlobalRef(globalObject));
     }
 
     JSGlobalObject* globalObject = JSCallbackObject<JSGlobalObject>::create(vm.get(), globalObjectClass, JSCallbackObject<JSGlobalObject>::createStructure(vm.get(), 0, jsNull()));
-    ExecState* exec = globalObject->globalExec();
-    JSValue prototype = globalObjectClass->prototype(exec);
+    JSValue prototype = globalObjectClass->prototype(globalObject);
     if (!prototype)
         prototype = jsNull();
     globalObject->resetPrototype(vm.get(), prototype);
 #if ENABLE(REMOTE_INSPECTOR)
     if (JSRemoteInspectorGetInspectionEnabledByDefault())
         globalObject->setRemoteDebuggingEnabled(true);
 #endif
-    return JSGlobalContextRetain(toGlobalRef(exec));
+    return JSGlobalContextRetain(toGlobalRef(globalObject));
 }
 
 JSGlobalContextRef JSGlobalContextRetain(JSGlobalContextRef ctx)
 {
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder locker(vm);
 
-    gcProtect(vm.vmEntryGlobalObject(exec));
+    gcProtect(globalObject);
     vm.ref();
     return ctx;
 }
 
 void JSGlobalContextRelease(JSGlobalContextRef ctx)
 {
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder locker(vm);
 
-    bool protectCountIsZero = vm.heap.unprotect(vm.vmEntryGlobalObject(exec));
+    bool protectCountIsZero = vm.heap.unprotect(globalObject);
     if (protectCountIsZero)
         vm.heap.reportAbandonedObjectGraph();
     vm.deref();
 }
 
@@ -191,51 +187,51 @@
 {
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return 0;
     }
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder locker(vm);
 
-    return toRef(jsCast<JSObject*>(exec->lexicalGlobalObject()->methodTable(vm)->toThis(exec->lexicalGlobalObject(), exec, NotStrictMode)));
+    return toRef(jsCast<JSObject*>(globalObject->methodTable(vm)->toThis(globalObject, globalObject, NotStrictMode)));
 }
 
 JSContextGroupRef JSContextGetGroup(JSContextRef ctx)
 {
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return 0;
     }
-    ExecState* exec = toJS(ctx);
-    return toRef(&exec->vm());
+    JSGlobalObject* globalObject = toJS(ctx);
+    return toRef(&globalObject->vm());
 }
 
 JSGlobalContextRef JSContextGetGlobalContext(JSContextRef ctx)
 {
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return 0;
     }
-    ExecState* exec = toJS(ctx);
-    JSLockHolder locker(exec);
+    JSGlobalObject* globalObject = toJS(ctx);
+    JSLockHolder locker(globalObject);
 
-    return toGlobalRef(exec->lexicalGlobalObject()->globalExec());
+    return toGlobalRef(globalObject);
 }
 
 JSStringRef JSGlobalContextCopyName(JSGlobalContextRef ctx)
 {
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return 0;
     }
 
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder locker(vm);
 
-    String name = vm.vmEntryGlobalObject(exec)->name();
+    String name = globalObject->name();
     if (name.isNull())
         return 0;
 
     return OpaqueJSString::tryCreate(name).leakRef();
 }
@@ -245,35 +241,35 @@
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return;
     }
 
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder locker(vm);
 
-    vm.vmEntryGlobalObject(exec)->setName(name ? name->string() : String());
+    globalObject->setName(name ? name->string() : String());
 }
 
 void JSGlobalContextSetUnhandledRejectionCallback(JSGlobalContextRef ctx, JSObjectRef function, JSValueRef* exception)
 {
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return;
     }
 
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder locker(vm);
 
     JSObject* object = toJS(function);
     if (!object->isFunction(vm)) {
-        *exception = toRef(createTypeError(exec));
+        *exception = toRef(createTypeError(globalObject));
         return;
     }
 
-    vm.vmEntryGlobalObject(exec)->setUnhandledRejectionCallback(vm, object);
+    globalObject->setUnhandledRejectionCallback(vm, object);
 }
 
 class BacktraceFunctor {
 public:
     BacktraceFunctor(StringBuilder& builder, unsigned remainingCapacityForFrameCapture)
@@ -328,19 +324,19 @@
 {
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return 0;
     }
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder lock(vm);
     StringBuilder builder;
     CallFrame* frame = vm.topCallFrame;
 
     ASSERT(maxStackSize);
     BacktraceFunctor functor(builder, maxStackSize);
-    frame->iterate(functor);
+    frame->iterate(vm, functor);
 
     return OpaqueJSString::tryCreate(builder.toString()).leakRef();
 }
 
 bool JSGlobalContextGetRemoteInspectionEnabled(JSGlobalContextRef ctx)
@@ -348,44 +344,43 @@
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return false;
     }
 
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder lock(vm);
 
-    return vm.vmEntryGlobalObject(exec)->remoteDebuggingEnabled();
+    return globalObject->remoteDebuggingEnabled();
 }
 
 void JSGlobalContextSetRemoteInspectionEnabled(JSGlobalContextRef ctx, bool enabled)
 {
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return;
     }
 
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder lock(vm);
 
-    vm.vmEntryGlobalObject(exec)->setRemoteDebuggingEnabled(enabled);
+    globalObject->setRemoteDebuggingEnabled(enabled);
 }
 
 bool JSGlobalContextGetIncludesNativeCallStackWhenReportingExceptions(JSGlobalContextRef ctx)
 {
 #if ENABLE(REMOTE_INSPECTOR)
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return false;
     }
 
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder lock(vm);
 
-    JSGlobalObject* globalObject = vm.vmEntryGlobalObject(exec);
     return globalObject->inspectorController().includesNativeCallStackWhenReportingExceptions();
 #else
     UNUSED_PARAM(ctx);
     return false;
 #endif
@@ -397,15 +392,14 @@
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return;
     }
 
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder lock(vm);
 
-    JSGlobalObject* globalObject = vm.vmEntryGlobalObject(exec);
     globalObject->inspectorController().setIncludesNativeCallStackWhenReportingExceptions(includesNativeCallStack);
 #else
     UNUSED_PARAM(ctx);
     UNUSED_PARAM(includesNativeCallStack);
 #endif
@@ -418,15 +412,15 @@
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return nullptr;
     }
 
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder lock(vm);
 
-    return vm.vmEntryGlobalObject(exec)->inspectorDebuggable().targetRunLoop();
+    return globalObject->inspectorDebuggable().targetRunLoop();
 #else
     UNUSED_PARAM(ctx);
     return nullptr;
 #endif
 }
@@ -437,15 +431,15 @@
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return;
     }
 
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder lock(vm);
 
-    vm.vmEntryGlobalObject(exec)->inspectorDebuggable().setTargetRunLoop(runLoop);
+    globalObject->inspectorDebuggable().setTargetRunLoop(runLoop);
 #else
     UNUSED_PARAM(ctx);
     UNUSED_PARAM(runLoop);
 #endif
 }
@@ -457,12 +451,12 @@
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return nullptr;
     }
 
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder lock(vm);
 
-    return &vm.vmEntryGlobalObject(exec)->inspectorController();
+    return &globalObject->inspectorController();
 }
 #endif

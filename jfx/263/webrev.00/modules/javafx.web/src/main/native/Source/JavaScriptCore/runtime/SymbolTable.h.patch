diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SymbolTable.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SymbolTable.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SymbolTable.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SymbolTable.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2007, 2008, 2012-2015 Apple Inc. All rights reserved.
+ * Copyright (C) 2007-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
@@ -42,10 +42,12 @@
 
 namespace JSC {
 
 class SymbolTable;
 
+DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(SymbolTableEntryFatEntry);
+
 static ALWAYS_INLINE int missingSymbolMarker() { return std::numeric_limits<int>::max(); }
 
 // The bit twiddling in this class assumes that every register index is a
 // reasonably small positive or negative number, and therefore has its high
 // four bits all set or all unset.
@@ -330,11 +332,11 @@
     static const intptr_t StackKindBits = 0x20;
     static const intptr_t DirectArgumentKindBits = 0x30;
     static const intptr_t FlagBits = 6;
 
     class FatEntry {
-        WTF_MAKE_FAST_ALLOCATED;
+        WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(SymbolTableEntryFatEntry);
     public:
         FatEntry(intptr_t bits)
             : m_bits(bits & ~SlimFlag)
         {
         }
@@ -431,19 +433,19 @@
 
     intptr_t m_bits;
 };
 
 struct SymbolTableIndexHashTraits : HashTraits<SymbolTableEntry> {
-    static const bool needsDestruction = true;
+    static constexpr bool needsDestruction = true;
 };
 
 class SymbolTable final : public JSCell {
     friend class CachedSymbolTable;
 
 public:
     typedef JSCell Base;
-    static const unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;
+    static constexpr unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;
 
     typedef HashMap<RefPtr<UniquedStringImpl>, SymbolTableEntry, IdentifierRepHash, HashTraits<RefPtr<UniquedStringImpl>>, SymbolTableIndexHashTraits> Map;
     typedef HashMap<RefPtr<UniquedStringImpl>, GlobalVariableID, IdentifierRepHash> UniqueIDMap;
     typedef HashMap<RefPtr<UniquedStringImpl>, RefPtr<TypeSet>, IdentifierRepHash> UniqueTypeSetMap;
     typedef HashMap<VarOffset, RefPtr<UniquedStringImpl>> OffsetToVariableMap;
@@ -460,11 +462,11 @@
         SymbolTable* symbolTable = new (NotNull, allocateCell<SymbolTable>(vm.heap)) SymbolTable(vm);
         symbolTable->finishCreation(vm);
         return symbolTable;
     }
 
-    static const bool needsDestruction = true;
+    static constexpr bool needsDestruction = true;
     static void destroy(JSCell*);
 
     static Structure* createStructure(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
     {
         return Structure::create(vm, globalObject, prototype, TypeInfo(CellType, StructureFlags), info());

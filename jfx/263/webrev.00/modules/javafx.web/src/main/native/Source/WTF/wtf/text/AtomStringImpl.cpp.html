<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/text/AtomStringImpl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2004-2008, 2013-2014 Apple Inc. All rights reserved.
  3  * Copyright (C) 2010 Patrick Gansterer &lt;paroga@paroga.com&gt;
  4  * Copyright (C) 2012 Google Inc. All rights reserved.
  5  * Copyright (C) 2015 Yusuke Suzuki&lt;utatane.tea@gmail.com&gt;. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  *
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &lt;wtf/text/AtomStringImpl.h&gt;
 26 
 27 #include &lt;wtf/CommaPrinter.h&gt;
 28 #include &lt;wtf/DataLog.h&gt;
 29 #include &lt;wtf/HashSet.h&gt;
 30 #include &lt;wtf/StringPrintStream.h&gt;
 31 #include &lt;wtf/Threading.h&gt;
 32 #include &lt;wtf/text/AtomStringTable.h&gt;
 33 #include &lt;wtf/text/IntegerToStringConversion.h&gt;
 34 #include &lt;wtf/text/StringHash.h&gt;
 35 #include &lt;wtf/unicode/UTF8Conversion.h&gt;
 36 
 37 #if USE(WEB_THREAD)
 38 #include &lt;wtf/Lock.h&gt;
 39 #endif
 40 
 41 namespace WTF {
 42 
 43 using namespace Unicode;
 44 
 45 #if USE(WEB_THREAD)
 46 
 47 class AtomStringTableLocker : public LockHolder {
 48     WTF_MAKE_NONCOPYABLE(AtomStringTableLocker);
 49 
 50     static Lock s_stringTableLock;
 51 public:
 52     AtomStringTableLocker()
 53         : LockHolder(&amp;s_stringTableLock)
 54     {
 55     }
 56 };
 57 
 58 Lock AtomStringTableLocker::s_stringTableLock;
 59 
 60 #else
 61 
 62 class AtomStringTableLocker {
 63     WTF_MAKE_NONCOPYABLE(AtomStringTableLocker);
 64 public:
 65     AtomStringTableLocker() { }
 66 };
 67 
 68 #endif // USE(WEB_THREAD)
 69 
 70 using StringTableImpl = HashSet&lt;PackedPtr&lt;StringImpl&gt;&gt;;
 71 
 72 static ALWAYS_INLINE StringTableImpl&amp; stringTable()
 73 {
 74     return Thread::current().atomStringTable()-&gt;table();
 75 }
 76 
 77 template&lt;typename T, typename HashTranslator&gt;
 78 static inline Ref&lt;AtomStringImpl&gt; addToStringTable(AtomStringTableLocker&amp;, StringTableImpl&amp; atomStringTable, const T&amp; value)
 79 {
 80     auto addResult = atomStringTable.add&lt;HashTranslator&gt;(value);
 81 
 82     // If the string is newly-translated, then we need to adopt it.
 83     // The boolean in the pair tells us if that is so.
 84     if (addResult.isNewEntry)
 85         return adoptRef(static_cast&lt;AtomStringImpl&amp;&gt;(*addResult.iterator-&gt;get()));
 86     return *static_cast&lt;AtomStringImpl*&gt;(addResult.iterator-&gt;get());
 87 }
 88 
 89 template&lt;typename T, typename HashTranslator&gt;
 90 static inline Ref&lt;AtomStringImpl&gt; addToStringTable(const T&amp; value)
 91 {
 92     AtomStringTableLocker locker;
 93     return addToStringTable&lt;T, HashTranslator&gt;(locker, stringTable(), value);
 94 }
 95 
 96 struct CStringTranslator {
 97     static unsigned hash(const LChar* characters)
 98     {
 99         return StringHasher::computeHashAndMaskTop8Bits(characters);
100     }
101 
102     static inline bool equal(PackedPtr&lt;StringImpl&gt; str, const LChar* characters)
103     {
104         return WTF::equal(str.get(), characters);
105     }
106 
107     static void translate(PackedPtr&lt;StringImpl&gt;&amp; location, const LChar* const&amp; characters, unsigned hash)
108     {
109         auto* pointer = &amp;StringImpl::create(characters).leakRef();
110         pointer-&gt;setHash(hash);
111         pointer-&gt;setIsAtom(true);
112         location = pointer;
113     }
114 };
115 
116 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::add(const LChar* characters)
117 {
118     if (!characters)
119         return nullptr;
120     if (!*characters)
121         return static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
122 
123     return addToStringTable&lt;const LChar*, CStringTranslator&gt;(characters);
124 }
125 
126 template&lt;typename CharacterType&gt;
127 struct HashTranslatorCharBuffer {
128     const CharacterType* characters;
129     unsigned length;
130     unsigned hash;
131 
132     HashTranslatorCharBuffer(const CharacterType* characters, unsigned length)
133         : characters(characters)
134         , length(length)
135         , hash(StringHasher::computeHashAndMaskTop8Bits(characters, length))
136     {
137     }
138 
139     HashTranslatorCharBuffer(const CharacterType* characters, unsigned length, unsigned hash)
140         : characters(characters)
141         , length(length)
142         , hash(hash)
143     {
144     }
145 };
146 
147 using UCharBuffer = HashTranslatorCharBuffer&lt;UChar&gt;;
148 struct UCharBufferTranslator {
149     static unsigned hash(const UCharBuffer&amp; buf)
150     {
151         return buf.hash;
152     }
153 
154     static bool equal(PackedPtr&lt;StringImpl&gt; const&amp; str, const UCharBuffer&amp; buf)
155     {
156         return WTF::equal(str.get(), buf.characters, buf.length);
157     }
158 
159     static void translate(PackedPtr&lt;StringImpl&gt;&amp; location, const UCharBuffer&amp; buf, unsigned hash)
160     {
161         auto* pointer = &amp;StringImpl::create8BitIfPossible(buf.characters, buf.length).leakRef();
162         pointer-&gt;setHash(hash);
163         pointer-&gt;setIsAtom(true);
164         location = pointer;
165     }
166 };
167 
168 struct HashAndUTF8Characters {
169     unsigned hash;
170     const char* characters;
171     unsigned length;
172     unsigned utf16Length;
173 };
174 
175 struct HashAndUTF8CharactersTranslator {
176     static unsigned hash(const HashAndUTF8Characters&amp; buffer)
177     {
178         return buffer.hash;
179     }
180 
181     static bool equal(PackedPtr&lt;StringImpl&gt; const&amp; passedString, const HashAndUTF8Characters&amp; buffer)
182     {
183         auto* string = passedString.get();
184         if (buffer.utf16Length != string-&gt;length())
185             return false;
186 
187         // If buffer contains only ASCII characters UTF-8 and UTF16 length are the same.
188         if (buffer.utf16Length != buffer.length) {
189             if (string-&gt;is8Bit())
190                 return equalLatin1WithUTF8(string-&gt;characters8(), buffer.characters, buffer.characters + buffer.length);
191 
192             return equalUTF16WithUTF8(string-&gt;characters16(), buffer.characters, buffer.characters + buffer.length);
193         }
194 
195         if (string-&gt;is8Bit()) {
196             const LChar* stringCharacters = string-&gt;characters8();
197 
198             for (unsigned i = 0; i &lt; buffer.length; ++i) {
199                 ASSERT(isASCII(buffer.characters[i]));
200                 if (stringCharacters[i] != buffer.characters[i])
201                     return false;
202             }
203 
204             return true;
205         }
206 
207         const UChar* stringCharacters = string-&gt;characters16();
208 
209         for (unsigned i = 0; i &lt; buffer.length; ++i) {
210             ASSERT(isASCII(buffer.characters[i]));
211             if (stringCharacters[i] != buffer.characters[i])
212                 return false;
213         }
214 
215         return true;
216     }
217 
218     static void translate(PackedPtr&lt;StringImpl&gt;&amp; location, const HashAndUTF8Characters&amp; buffer, unsigned hash)
219     {
220         UChar* target;
221         auto newString = StringImpl::createUninitialized(buffer.utf16Length, target);
222 
223         bool isAllASCII;
224         const char* source = buffer.characters;
225         if (!convertUTF8ToUTF16(source, source + buffer.length, &amp;target, target + buffer.utf16Length, &amp;isAllASCII))
226             ASSERT_NOT_REACHED();
227 
228         if (isAllASCII)
229             newString = StringImpl::create(buffer.characters, buffer.length);
230 
231         auto* pointer = &amp;newString.leakRef();
232         pointer-&gt;setHash(hash);
233         pointer-&gt;setIsAtom(true);
234         location = pointer;
235     }
236 };
237 
238 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::add(const UChar* characters, unsigned length)
239 {
240     if (!characters)
241         return nullptr;
242 
243     if (!length)
244         return static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
245 
246     UCharBuffer buffer { characters, length };
247     return addToStringTable&lt;UCharBuffer, UCharBufferTranslator&gt;(buffer);
248 }
249 
250 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::add(const UChar* characters)
251 {
252     if (!characters)
253         return nullptr;
254 
255     unsigned length = 0;
256     while (characters[length] != UChar(0))
257         ++length;
258 
259     if (!length)
260         return static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
261 
262     UCharBuffer buffer { characters, length };
263     return addToStringTable&lt;UCharBuffer, UCharBufferTranslator&gt;(buffer);
264 }
265 
266 struct SubstringLocation {
267     StringImpl* baseString;
268     unsigned start;
269     unsigned length;
270 };
271 
272 struct SubstringTranslator {
273     static void translate(PackedPtr&lt;StringImpl&gt;&amp; location, const SubstringLocation&amp; buffer, unsigned hash)
274     {
275         auto* pointer = &amp;StringImpl::createSubstringSharingImpl(*buffer.baseString, buffer.start, buffer.length).leakRef();
276         pointer-&gt;setHash(hash);
277         pointer-&gt;setIsAtom(true);
278         location = pointer;
279     }
280 };
281 
282 struct SubstringTranslator8 : SubstringTranslator {
283     static unsigned hash(const SubstringLocation&amp; buffer)
284     {
285         return StringHasher::computeHashAndMaskTop8Bits(buffer.baseString-&gt;characters8() + buffer.start, buffer.length);
286     }
287 
288     static bool equal(PackedPtr&lt;StringImpl&gt; const&amp; string, const SubstringLocation&amp; buffer)
289     {
290         return WTF::equal(string.get(), buffer.baseString-&gt;characters8() + buffer.start, buffer.length);
291     }
292 };
293 
294 struct SubstringTranslator16 : SubstringTranslator {
295     static unsigned hash(const SubstringLocation&amp; buffer)
296     {
297         return StringHasher::computeHashAndMaskTop8Bits(buffer.baseString-&gt;characters16() + buffer.start, buffer.length);
298     }
299 
300     static bool equal(PackedPtr&lt;StringImpl&gt; const&amp; string, const SubstringLocation&amp; buffer)
301     {
302         return WTF::equal(string.get(), buffer.baseString-&gt;characters16() + buffer.start, buffer.length);
303     }
304 };
305 
306 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::add(StringImpl* baseString, unsigned start, unsigned length)
307 {
308     if (!baseString)
309         return nullptr;
310 
311     if (!length || start &gt;= baseString-&gt;length())
312         return static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
313 
314     unsigned maxLength = baseString-&gt;length() - start;
315     if (length &gt;= maxLength) {
316         if (!start)
317             return add(baseString);
318         length = maxLength;
319     }
320 
321     SubstringLocation buffer = { baseString, start, length };
322     if (baseString-&gt;is8Bit())
323         return addToStringTable&lt;SubstringLocation, SubstringTranslator8&gt;(buffer);
324     return addToStringTable&lt;SubstringLocation, SubstringTranslator16&gt;(buffer);
325 }
326 
327 using LCharBuffer = HashTranslatorCharBuffer&lt;LChar&gt;;
328 struct LCharBufferTranslator {
329     static unsigned hash(const LCharBuffer&amp; buf)
330     {
331         return buf.hash;
332     }
333 
334     static bool equal(PackedPtr&lt;StringImpl&gt; const&amp; str, const LCharBuffer&amp; buf)
335     {
336         return WTF::equal(str.get(), buf.characters, buf.length);
337     }
338 
339     static void translate(PackedPtr&lt;StringImpl&gt;&amp; location, const LCharBuffer&amp; buf, unsigned hash)
340     {
341         auto* pointer = &amp;StringImpl::create(buf.characters, buf.length).leakRef();
342         pointer-&gt;setHash(hash);
343         pointer-&gt;setIsAtom(true);
344         location = pointer;
345     }
346 };
347 
348 template&lt;typename CharType&gt;
349 struct BufferFromStaticDataTranslator {
350     using Buffer = HashTranslatorCharBuffer&lt;CharType&gt;;
351     static unsigned hash(const Buffer&amp; buf)
352     {
353         return buf.hash;
354     }
355 
356     static bool equal(PackedPtr&lt;StringImpl&gt; const&amp; str, const Buffer&amp; buf)
357     {
358         return WTF::equal(str.get(), buf.characters, buf.length);
359     }
360 
361     static void translate(PackedPtr&lt;StringImpl&gt;&amp; location, const Buffer&amp; buf, unsigned hash)
362     {
363         auto* pointer = &amp;StringImpl::createWithoutCopying(buf.characters, buf.length).leakRef();
364         pointer-&gt;setHash(hash);
365         pointer-&gt;setIsAtom(true);
366         location = pointer;
367     }
368 };
369 
370 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::add(const LChar* characters, unsigned length)
371 {
372     if (!characters)
373         return nullptr;
374 
375     if (!length)
376         return static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
377 
378     LCharBuffer buffer { characters, length };
379     return addToStringTable&lt;LCharBuffer, LCharBufferTranslator&gt;(buffer);
380 }
381 
382 Ref&lt;AtomStringImpl&gt; AtomStringImpl::addLiteral(const char* characters, unsigned length)
383 {
384     ASSERT(characters);
385     ASSERT(length);
386 
387     LCharBuffer buffer { reinterpret_cast&lt;const LChar*&gt;(characters), length };
388     return addToStringTable&lt;LCharBuffer, BufferFromStaticDataTranslator&lt;LChar&gt;&gt;(buffer);
389 }
390 
391 static Ref&lt;AtomStringImpl&gt; addSymbol(AtomStringTableLocker&amp; locker, StringTableImpl&amp; atomStringTable, StringImpl&amp; base)
392 {
393     ASSERT(base.length());
394     ASSERT(base.isSymbol());
395 
396     SubstringLocation buffer = { &amp;base, 0, base.length() };
397     if (base.is8Bit())
398         return addToStringTable&lt;SubstringLocation, SubstringTranslator8&gt;(locker, atomStringTable, buffer);
399     return addToStringTable&lt;SubstringLocation, SubstringTranslator16&gt;(locker, atomStringTable, buffer);
400 }
401 
402 static inline Ref&lt;AtomStringImpl&gt; addSymbol(StringImpl&amp; base)
403 {
404     AtomStringTableLocker locker;
405     return addSymbol(locker, stringTable(), base);
406 }
407 
408 static Ref&lt;AtomStringImpl&gt; addStatic(AtomStringTableLocker&amp; locker, StringTableImpl&amp; atomStringTable, const StringImpl&amp; base)
409 {
410     ASSERT(base.length());
411     ASSERT(base.isStatic());
412 
413     if (base.is8Bit()) {
414         LCharBuffer buffer { base.characters8(), base.length(), base.hash() };
415         return addToStringTable&lt;LCharBuffer, BufferFromStaticDataTranslator&lt;LChar&gt;&gt;(locker, atomStringTable, buffer);
416     }
417     UCharBuffer buffer { base.characters16(), base.length(), base.hash() };
418     return addToStringTable&lt;UCharBuffer, BufferFromStaticDataTranslator&lt;UChar&gt;&gt;(locker, atomStringTable, buffer);
419 }
420 
421 static inline Ref&lt;AtomStringImpl&gt; addStatic(const StringImpl&amp; base)
422 {
423     AtomStringTableLocker locker;
424     return addStatic(locker, stringTable(), base);
425 }
426 
427 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::add(const StaticStringImpl* string)
428 {
429     auto s = reinterpret_cast&lt;const StringImpl*&gt;(string);
430     ASSERT(s-&gt;isStatic());
431     return addStatic(*s);
432 }
433 
434 Ref&lt;AtomStringImpl&gt; AtomStringImpl::addSlowCase(StringImpl&amp; string)
435 {
436     // This check is necessary for null symbols.
437     // Their length is zero, but they are not AtomStringImpl.
438     if (!string.length())
439         return *static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
440 
441     if (string.isStatic())
442         return addStatic(string);
443 
444     if (string.isSymbol())
445         return addSymbol(string);
446 
447     ASSERT_WITH_MESSAGE(!string.isAtom(), &quot;AtomStringImpl should not hit the slow case if the string is already an atom.&quot;);
448 
449     AtomStringTableLocker locker;
450     auto addResult = stringTable().add(&amp;string);
451 
452     if (addResult.isNewEntry) {
453         ASSERT(addResult.iterator-&gt;get() == &amp;string);
454         string.setIsAtom(true);
455     }
456 
457     return *static_cast&lt;AtomStringImpl*&gt;(addResult.iterator-&gt;get());
458 }
459 
460 Ref&lt;AtomStringImpl&gt; AtomStringImpl::addSlowCase(AtomStringTable&amp; stringTable, StringImpl&amp; string)
461 {
462     // This check is necessary for null symbols.
463     // Their length is zero, but they are not AtomStringImpl.
464     if (!string.length())
465         return *static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
466 
467     if (string.isStatic()) {
468         AtomStringTableLocker locker;
469         return addStatic(locker, stringTable.table(), string);
470     }
471 
472     if (string.isSymbol()) {
473         AtomStringTableLocker locker;
474         return addSymbol(locker, stringTable.table(), string);
475     }
476 
477     ASSERT_WITH_MESSAGE(!string.isAtom(), &quot;AtomStringImpl should not hit the slow case if the string is already an atom.&quot;);
478 
479     AtomStringTableLocker locker;
480     auto addResult = stringTable.table().add(&amp;string);
481 
482     if (addResult.isNewEntry) {
483         ASSERT(addResult.iterator-&gt;get() == &amp;string);
484         string.setIsAtom(true);
485     }
486 
487     return *static_cast&lt;AtomStringImpl*&gt;(addResult.iterator-&gt;get());
488 }
489 
490 void AtomStringImpl::remove(AtomStringImpl* string)
491 {
492     ASSERT(string-&gt;isAtom());
493     AtomStringTableLocker locker;
494     auto&amp; atomStringTable = stringTable();
495     auto iterator = atomStringTable.find(string);
496     ASSERT_WITH_MESSAGE(iterator != atomStringTable.end(), &quot;The string being removed is an atom in the string table of an other thread!&quot;);
497     ASSERT(string == iterator-&gt;get());
498     atomStringTable.remove(iterator);
499 }
500 
501 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::lookUpSlowCase(StringImpl&amp; string)
502 {
503     ASSERT_WITH_MESSAGE(!string.isAtom(), &quot;AtomStringImpl objects should return from the fast case.&quot;);
504 
505     if (!string.length())
506         return static_cast&lt;AtomStringImpl*&gt;(StringImpl::empty());
507 
508     AtomStringTableLocker locker;
509     auto&amp; atomStringTable = stringTable();
510     auto iterator = atomStringTable.find(&amp;string);
511     if (iterator != atomStringTable.end())
512         return static_cast&lt;AtomStringImpl*&gt;(iterator-&gt;get());
513     return nullptr;
514 }
515 
516 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::addUTF8(const char* charactersStart, const char* charactersEnd)
517 {
518     HashAndUTF8Characters buffer;
519     buffer.characters = charactersStart;
520     buffer.hash = calculateStringHashAndLengthFromUTF8MaskingTop8Bits(charactersStart, charactersEnd, buffer.length, buffer.utf16Length);
521 
522     if (!buffer.hash)
523         return nullptr;
524 
525     return addToStringTable&lt;HashAndUTF8Characters, HashAndUTF8CharactersTranslator&gt;(buffer);
526 }
527 
528 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::lookUp(const LChar* characters, unsigned length)
529 {
530     AtomStringTableLocker locker;
531     auto&amp; table = stringTable();
532 
533     LCharBuffer buffer = { characters, length };
534     auto iterator = table.find&lt;LCharBufferTranslator&gt;(buffer);
535     if (iterator != table.end())
536         return static_cast&lt;AtomStringImpl*&gt;(iterator-&gt;get());
537     return nullptr;
538 }
539 
540 RefPtr&lt;AtomStringImpl&gt; AtomStringImpl::lookUp(const UChar* characters, unsigned length)
541 {
542     AtomStringTableLocker locker;
543     auto&amp; table = stringTable();
544 
545     UCharBuffer buffer { characters, length };
546     auto iterator = table.find&lt;UCharBufferTranslator&gt;(buffer);
547     if (iterator != table.end())
548         return static_cast&lt;AtomStringImpl*&gt;(iterator-&gt;get());
549     return nullptr;
550 }
551 
552 #if ASSERT_ENABLED
553 bool AtomStringImpl::isInAtomStringTable(StringImpl* string)
554 {
555     AtomStringTableLocker locker;
556     return stringTable().contains(string);
557 }
558 #endif
559 
560 } // namespace WTF
    </pre>
  </body>
</html>
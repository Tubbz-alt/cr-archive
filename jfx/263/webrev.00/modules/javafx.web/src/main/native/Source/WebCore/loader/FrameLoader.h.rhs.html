<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/loader/FrameLoader.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2006-2016 Apple Inc. All rights reserved.
  3  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  4  * Copyright (C) Research In Motion Limited 2009. All rights reserved.
  5  * Copyright (C) 2011 Google Inc. All rights reserved.
  6  *
  7  * Redistribution and use in source and binary forms, with or without
  8  * modification, are permitted provided that the following conditions
  9  * are met:
 10  *
 11  * 1.  Redistributions of source code must retain the above copyright
 12  *     notice, this list of conditions and the following disclaimer.
 13  * 2.  Redistributions in binary form must reproduce the above copyright
 14  *     notice, this list of conditions and the following disclaimer in the
 15  *     documentation and/or other materials provided with the distribution.
 16  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 17  *     its contributors may be used to endorse or promote products derived
 18  *     from this software without specific prior written permission.
 19  *
 20  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 21  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 22  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 23  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 24  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 25  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 26  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 27  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 29  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #pragma once
 33 
 34 #include &quot;AdClickAttribution.h&quot;
 35 #include &quot;CachePolicy.h&quot;
 36 #include &quot;FrameLoaderStateMachine.h&quot;
 37 #include &quot;FrameLoaderTypes.h&quot;
 38 #include &quot;LayoutMilestone.h&quot;
 39 #include &quot;MixedContentChecker.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 40 #include &quot;PolicyChecker.h&quot;</span>
 41 #include &quot;ReferrerPolicy.h&quot;
 42 #include &quot;ResourceLoadNotifier.h&quot;
 43 #include &quot;ResourceLoaderOptions.h&quot;
 44 #include &quot;ResourceRequestBase.h&quot;
 45 #include &quot;SecurityContext.h&quot;
 46 #include &quot;StoredCredentialsPolicy.h&quot;
 47 #include &quot;Timer.h&quot;
 48 #include &lt;wtf/CompletionHandler.h&gt;
 49 #include &lt;wtf/Forward.h&gt;
 50 #include &lt;wtf/HashSet.h&gt;
 51 #include &lt;wtf/OptionSet.h&gt;
 52 #include &lt;wtf/Optional.h&gt;
 53 #include &lt;wtf/WallTime.h&gt;
 54 
 55 namespace WebCore {
 56 
 57 class Archive;
 58 class CachedFrame;
 59 class CachedFrameBase;
 60 class CachedPage;
 61 class CachedResource;
 62 class Chrome;
 63 class DOMWrapperWorld;
 64 class Document;
 65 class DocumentLoader;
 66 class Event;
 67 class FormState;
 68 class FormSubmission;
 69 class FrameLoadRequest;
 70 class FrameLoaderClient;
 71 class FrameNetworkingContext;
 72 class HistoryController;
 73 class HistoryItem;
 74 class NavigationAction;
 75 class NetworkingContext;
 76 class Node;
 77 class Page;
 78 class PolicyChecker;
 79 class ResourceError;
 80 class ResourceRequest;
 81 class ResourceResponse;
 82 class SerializedScriptValue;
 83 class SharedBuffer;
 84 class SubframeLoader;
 85 class SubstituteData;
 86 
 87 enum class NewLoadInProgress : bool;
<a name="2" id="anc2"></a>
 88 enum class NavigationPolicyDecision : uint8_t;
 89 enum class ShouldTreatAsContinuingLoad : bool;
 90 
 91 struct WindowFeatures;
 92 
 93 WEBCORE_EXPORT bool isBackForwardLoadType(FrameLoadType);
 94 WEBCORE_EXPORT bool isReload(FrameLoadType);
 95 
 96 using ContentPolicyDecisionFunction = WTF::Function&lt;void(PolicyAction, PolicyCheckIdentifier)&gt;;
 97 
 98 class FrameLoader final {
 99     WTF_MAKE_FAST_ALLOCATED;
100     WTF_MAKE_NONCOPYABLE(FrameLoader);
101 public:
102     FrameLoader(Frame&amp;, FrameLoaderClient&amp;);
103     ~FrameLoader();
104 
105     WEBCORE_EXPORT void init();
106     void initForSynthesizedDocument(const URL&amp;);
107 
108     Frame&amp; frame() const { return m_frame; }
109 
110     PolicyChecker&amp; policyChecker() const { return *m_policyChecker; }
111     HistoryController&amp; history() const { return *m_history; }
112     ResourceLoadNotifier&amp; notifier() const { return m_notifier; }
113     SubframeLoader&amp; subframeLoader() const { return *m_subframeLoader; }
114     MixedContentChecker&amp; mixedContentChecker() const { return m_mixedContentChecker; }
115 
116     void setupForReplace();
117 
118     // FIXME: These are all functions which start loads. We have too many.
119     WEBCORE_EXPORT void loadURLIntoChildFrame(const URL&amp;, const String&amp; referer, Frame*);
120     WEBCORE_EXPORT void loadFrameRequest(FrameLoadRequest&amp;&amp;, Event*, RefPtr&lt;FormState&gt;&amp;&amp;, Optional&lt;AdClickAttribution&gt;&amp;&amp; = WTF::nullopt); // Called by submitForm, calls loadPostRequest and loadURL.
121 
122     WEBCORE_EXPORT void load(FrameLoadRequest&amp;&amp;);
123 
124 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
125     WEBCORE_EXPORT void loadArchive(Ref&lt;Archive&gt;&amp;&amp;);
126 #endif
127     unsigned long loadResourceSynchronously(const ResourceRequest&amp;, ClientCredentialPolicy, const FetchOptions&amp;, const HTTPHeaderMap&amp;, ResourceError&amp;, ResourceResponse&amp;, RefPtr&lt;SharedBuffer&gt;&amp; data);
128 
129     void changeLocation(FrameLoadRequest&amp;&amp;);
130     WEBCORE_EXPORT void urlSelected(const URL&amp;, const String&amp; target, Event*, LockHistory, LockBackForwardList, ShouldSendReferrer, ShouldOpenExternalURLsPolicy, Optional&lt;NewFrameOpenerPolicy&gt; = WTF::nullopt, const AtomString&amp; downloadAttribute = nullAtom(), const SystemPreviewInfo&amp; = { }, Optional&lt;AdClickAttribution&gt;&amp;&amp; = WTF::nullopt);
131     void submitForm(Ref&lt;FormSubmission&gt;&amp;&amp;);
132 
133     WEBCORE_EXPORT void reload(OptionSet&lt;ReloadOption&gt; = { });
134     WEBCORE_EXPORT void reloadWithOverrideEncoding(const String&amp; overrideEncoding);
135 
136     void open(CachedFrameBase&amp;);
137     void loadItem(HistoryItem&amp;, HistoryItem* fromItem, FrameLoadType, ShouldTreatAsContinuingLoad);
138     HistoryItem* requestedHistoryItem() const { return m_requestedHistoryItem.get(); }
139 
140     void retryAfterFailedCacheOnlyMainResourceLoad();
141 
142     static void reportLocalLoadFailed(Frame*, const String&amp; url);
143     static void reportBlockedPortFailed(Frame*, const String&amp; url);
144     static void reportAuthenticationChallengeBlocked(Frame*, const URL&amp;, const String&amp; reason);
145 
146     // FIXME: These are all functions which stop loads. We have too many.
147     void stopAllLoadersAndCheckCompleteness();
148     WEBCORE_EXPORT void stopAllLoaders(ClearProvisionalItemPolicy = ShouldClearProvisionalItem, StopLoadingPolicy = StopLoadingPolicy::PreventDuringUnloadEvents);
149     WEBCORE_EXPORT void stopForUserCancel(bool deferCheckLoadComplete = false);
<a name="3" id="anc3"></a><span class="line-added">150     void stopForBackForwardCache();</span>
151     void stop();
152     void stopLoading(UnloadEventPolicy);
153     bool closeURL();
154     void cancelAndClear();
155     void clearProvisionalLoadForPolicyCheck();
156     // FIXME: clear() is trying to do too many things. We should break it down into smaller functions (ideally with fewer raw Boolean parameters).
157     void clear(Document* newDocument, bool clearWindowProperties = true, bool clearScriptObjects = true, bool clearFrameView = true, WTF::Function&lt;void()&gt;&amp;&amp; handleDOMWindowCreation = nullptr);
158 
159     bool isLoading() const;
160     WEBCORE_EXPORT bool frameHasLoaded() const;
161 
162     WEBCORE_EXPORT int numPendingOrLoadingRequests(bool recurse) const;
163 
164     ReferrerPolicy effectiveReferrerPolicy() const;
165     String referrer() const;
166     WEBCORE_EXPORT String outgoingReferrer() const;
167     String outgoingOrigin() const;
168 
169     WEBCORE_EXPORT DocumentLoader* activeDocumentLoader() const;
170     DocumentLoader* documentLoader() const { return m_documentLoader.get(); }
171     DocumentLoader* policyDocumentLoader() const { return m_policyDocumentLoader.get(); }
172     DocumentLoader* provisionalDocumentLoader() const { return m_provisionalDocumentLoader.get(); }
173     FrameState state() const { return m_state; }
174 
175     bool shouldReportResourceTimingToParentFrame() const { return m_shouldReportResourceTimingToParentFrame; };
176 
177 #if PLATFORM(IOS_FAMILY)
178     RetainPtr&lt;CFDictionaryRef&gt; connectionProperties(ResourceLoader*);
179 #endif
180     const ResourceRequest&amp; originalRequest() const;
181     const ResourceRequest&amp; initialRequest() const;
182     void receivedMainResourceError(const ResourceError&amp;);
183 
184     bool willLoadMediaElementURL(URL&amp;, Node&amp;);
185 
186     void handleFallbackContent();
187 
188     WEBCORE_EXPORT ResourceError cancelledError(const ResourceRequest&amp;) const;
189     WEBCORE_EXPORT ResourceError blockedByContentBlockerError(const ResourceRequest&amp;) const;
190     ResourceError blockedError(const ResourceRequest&amp;) const;
191 #if ENABLE(CONTENT_FILTERING)
192     ResourceError blockedByContentFilterError(const ResourceRequest&amp;) const;
193 #endif
194 
195     bool isHostedByObjectElement() const;
196 
197     bool isReplacing() const;
198     void setReplacing();
199     bool subframeIsLoading() const;
200     void willChangeTitle(DocumentLoader*);
201     void didChangeTitle(DocumentLoader*);
202 
203     bool shouldTreatURLAsSrcdocDocument(const URL&amp;) const;
204 
205     WEBCORE_EXPORT FrameLoadType loadType() const;
206 
207     CachePolicy subresourceCachePolicy(const URL&amp;) const;
208 
209     void didReachLayoutMilestone(OptionSet&lt;LayoutMilestone&gt;);
210     void didFirstLayout();
211 
212     void loadedResourceFromMemoryCache(CachedResource&amp;, ResourceRequest&amp; newRequest, ResourceError&amp;);
213     void tellClientAboutPastMemoryCacheLoads();
214 
215     void checkLoadComplete();
216     WEBCORE_EXPORT void detachFromParent();
217     void detachViewsAndDocumentLoader();
218 
219     void addExtraFieldsToSubresourceRequest(ResourceRequest&amp;);
220     void addExtraFieldsToMainResourceRequest(ResourceRequest&amp;);
221 
222     static void addHTTPOriginIfNeeded(ResourceRequest&amp;, const String&amp; origin);
223     static void addHTTPUpgradeInsecureRequestsIfNeeded(ResourceRequest&amp;);
224     static void addSameSiteInfoToRequestIfNeeded(ResourceRequest&amp;, const Document* initiator = nullptr);
225 
226     FrameLoaderClient&amp; client() const { return m_client; }
227 
228     void setDefersLoading(bool);
229 
230     void checkContentPolicy(const ResourceResponse&amp;, PolicyCheckIdentifier, ContentPolicyDecisionFunction&amp;&amp;);
231 
232     void didExplicitOpen();
233 
234     // Callbacks from DocumentWriter
<a name="4" id="anc4"></a><span class="line-modified">235     void didBeginDocument(bool dispatchWindowObjectAvailable);</span>
236 
237     void receivedFirstData();
238 
239     void dispatchOnloadEvents();
240     String userAgent(const URL&amp;) const;
<a name="5" id="anc5"></a>
241     String navigatorPlatform() const;
242 
243     void dispatchDidClearWindowObjectInWorld(DOMWrapperWorld&amp;);
244     void dispatchDidClearWindowObjectsInAllWorlds();
245 
246     // The following sandbox flags will be forced, regardless of changes to
247     // the sandbox attribute of any parent frames.
248     void forceSandboxFlags(SandboxFlags flags) { m_forcedSandboxFlags |= flags; }
249     SandboxFlags effectiveSandboxFlags() const;
250 
251     bool checkIfFormActionAllowedByCSP(const URL&amp;, bool didReceiveRedirectResponse) const;
252 
253     WEBCORE_EXPORT Frame* opener();
254     WEBCORE_EXPORT void setOpener(Frame*);
<a name="6" id="anc6"></a><span class="line-added">255     WEBCORE_EXPORT void detachFromAllOpenedFrames();</span>
256     bool hasOpenedFrames() const { return !m_openedFrames.isEmpty(); }
257 
258     void resetMultipleFormSubmissionProtection();
259 
260     void checkCallImplicitClose();
261 
262     void frameDetached();
263 
264     void setOutgoingReferrer(const URL&amp;);
265 
266     void loadDone(LoadCompletionType);
267     void subresourceLoadDone(LoadCompletionType);
268     void finishedParsing();
269     void checkCompleted();
270 
271     WEBCORE_EXPORT bool isComplete() const;
272 
273     void commitProvisionalLoad();
274 
275     void setLoadsSynchronously(bool loadsSynchronously) { m_loadsSynchronously = loadsSynchronously; }
276     bool loadsSynchronously() const { return m_loadsSynchronously; }
277 
278     FrameLoaderStateMachine&amp; stateMachine() { return m_stateMachine; }
279 
280     WEBCORE_EXPORT Frame* findFrameForNavigation(const AtomString&amp; name, Document* activeDocument = nullptr);
281 
282     void applyUserAgentIfNeeded(ResourceRequest&amp;);
283 
284     bool shouldInterruptLoadForXFrameOptions(const String&amp;, const URL&amp;, unsigned long requestIdentifier);
285 
286     void completed();
287     bool allAncestorsAreComplete() const; // including this
288     void clientRedirected(const URL&amp;, double delay, WallTime fireDate, LockBackForwardList);
289     void clientRedirectCancelledOrFinished(NewLoadInProgress);
290 
291     WEBCORE_EXPORT void setOriginalURLForDownloadRequest(ResourceRequest&amp;);
292 
293     bool quickRedirectComing() const { return m_quickRedirectComing; }
294 
295     WEBCORE_EXPORT bool shouldClose();
296 
297     void started();
298 
299     enum class PageDismissalType { None, BeforeUnload, PageHide, Unload };
300     PageDismissalType pageDismissalEventBeingDispatched() const { return m_pageDismissalEventBeingDispatched; }
301 
302     WEBCORE_EXPORT NetworkingContext* networkingContext() const;
303 
304     void loadProgressingStatusChanged();
305 
306     const URL&amp; previousURL() const { return m_previousURL; }
307 
308     void forcePageTransitionIfNeeded();
309 
310     void setOverrideCachePolicyForTesting(ResourceRequestCachePolicy policy) { m_overrideCachePolicyForTesting = policy; }
311     void setOverrideResourceLoadPriorityForTesting(ResourceLoadPriority priority) { m_overrideResourceLoadPriorityForTesting = priority; }
312     void setStrictRawResourceValidationPolicyDisabledForTesting(bool disabled) { m_isStrictRawResourceValidationPolicyDisabledForTesting = disabled; }
313     bool isStrictRawResourceValidationPolicyDisabledForTesting() { return m_isStrictRawResourceValidationPolicyDisabledForTesting; }
314 
315     WEBCORE_EXPORT void clearTestingOverrides();
316 
317     const URL&amp; provisionalLoadErrorBeingHandledURL() const { return m_provisionalLoadErrorBeingHandledURL; }
318     void setProvisionalLoadErrorBeingHandledURL(const URL&amp; url) { m_provisionalLoadErrorBeingHandledURL = url; }
319 
320     bool isAlwaysOnLoggingAllowed() const;
321     bool shouldSuppressTextInputFromEditing() const;
322     bool isReloadingFromOrigin() const { return m_loadType == FrameLoadType::ReloadFromOrigin; }
323 
324     // Used in webarchive loading tests.
325     void setAlwaysAllowLocalWebarchive(bool alwaysAllowLocalWebarchive) { m_alwaysAllowLocalWebarchive = alwaysAllowLocalWebarchive; }
326     bool alwaysAllowLocalWebarchive() const { return m_alwaysAllowLocalWebarchive; }
327 
328 private:
329     enum FormSubmissionCacheLoadPolicy {
330         MayAttemptCacheOnlyLoadForFormSubmissionItem,
331         MayNotAttemptCacheOnlyLoadForFormSubmissionItem
332     };
333 
334     bool allChildrenAreComplete() const; // immediate children, not all descendants
335 
336     void checkTimerFired();
337     void checkCompletenessNow();
338 
339     void loadSameDocumentItem(HistoryItem&amp;);
340     void loadDifferentDocumentItem(HistoryItem&amp;, HistoryItem* fromItem, FrameLoadType, FormSubmissionCacheLoadPolicy, ShouldTreatAsContinuingLoad);
341 
342     void loadProvisionalItemFromCachedPage();
343 
344     void updateFirstPartyForCookies();
345     void setFirstPartyForCookies(const URL&amp;);
346 
347     void addExtraFieldsToRequest(ResourceRequest&amp;, FrameLoadType, bool isMainResource);
348     ResourceRequestCachePolicy defaultRequestCachingPolicy(const ResourceRequest&amp;, FrameLoadType, bool isMainResource);
349 
350     void clearProvisionalLoad();
351     void transitionToCommitted(CachedPage*);
352     void frameLoadCompleted();
353 
354     SubstituteData defaultSubstituteDataForURL(const URL&amp;);
355 
356     bool dispatchBeforeUnloadEvent(Chrome&amp;, FrameLoader* frameLoaderBeingNavigated);
357     void dispatchUnloadEvents(UnloadEventPolicy);
358 
359     void continueLoadAfterNavigationPolicy(const ResourceRequest&amp;, FormState*, NavigationPolicyDecision, AllowNavigationToInvalidURL);
<a name="7" id="anc7"></a><span class="line-modified">360     void continueLoadAfterNewWindowPolicy(const ResourceRequest&amp;, FormState*, const String&amp; frameName, const NavigationAction&amp;, PolicyChecker::ShouldContinue, AllowNavigationToInvalidURL, NewFrameOpenerPolicy);</span>
361     void continueFragmentScrollAfterNavigationPolicy(const ResourceRequest&amp;, bool shouldContinue);
362 
363     bool shouldPerformFragmentNavigation(bool isFormSubmission, const String&amp; httpMethod, FrameLoadType, const URL&amp;);
364     void scrollToFragmentWithParentBoundary(const URL&amp;, bool isNewNavigation = true);
365 
366     void dispatchDidFailProvisionalLoad(DocumentLoader&amp; provisionalDocumentLoader, const ResourceError&amp;);
367     void checkLoadCompleteForThisFrame();
368 
369     void setDocumentLoader(DocumentLoader*);
370     void setPolicyDocumentLoader(DocumentLoader*);
371     void setProvisionalDocumentLoader(DocumentLoader*);
372 
373     void setState(FrameState);
374 
375     void closeOldDataSources();
376     void willRestoreFromCachedPage();
377 
378     bool shouldReloadToHandleUnreachableURL(DocumentLoader&amp;);
379 
380     void dispatchDidCommitLoad(Optional&lt;HasInsecureContent&gt; initialHasInsecureContent);
381 
382     void urlSelected(FrameLoadRequest&amp;&amp;, Event*, Optional&lt;AdClickAttribution&gt;&amp;&amp; = WTF::nullopt);
383 
384     void loadWithDocumentLoader(DocumentLoader*, FrameLoadType, RefPtr&lt;FormState&gt;&amp;&amp;, AllowNavigationToInvalidURL, ShouldTreatAsContinuingLoad, CompletionHandler&lt;void()&gt;&amp;&amp; = [] { }); // Calls continueLoadAfterNavigationPolicy
385     void load(DocumentLoader&amp;); // Calls loadWithDocumentLoader
386 
387     void loadWithNavigationAction(const ResourceRequest&amp;, NavigationAction&amp;&amp;, LockHistory, FrameLoadType, RefPtr&lt;FormState&gt;&amp;&amp;, AllowNavigationToInvalidURL, const String&amp; downloadAttribute = { }, CompletionHandler&lt;void()&gt;&amp;&amp; = [] { }); // Calls loadWithDocumentLoader
388 
389     void loadPostRequest(FrameLoadRequest&amp;&amp;, const String&amp; referrer, FrameLoadType, Event*, RefPtr&lt;FormState&gt;&amp;&amp;, CompletionHandler&lt;void()&gt;&amp;&amp;);
390     void loadURL(FrameLoadRequest&amp;&amp;, const String&amp; referrer, FrameLoadType, Event*, RefPtr&lt;FormState&gt;&amp;&amp;, Optional&lt;AdClickAttribution&gt;&amp;&amp;, CompletionHandler&lt;void()&gt;&amp;&amp;);
391 
392     bool shouldReload(const URL&amp; currentURL, const URL&amp; destinationURL);
393 
394     void requestFromDelegate(ResourceRequest&amp;, unsigned long&amp; identifier, ResourceError&amp;);
395 
396     WEBCORE_EXPORT void detachChildren();
397     void closeAndRemoveChild(Frame&amp;);
398 
399     void loadInSameDocument(const URL&amp;, SerializedScriptValue* stateObject, bool isNewNavigation);
400 
401     void prepareForLoadStart();
402     void provisionalLoadStarted();
403 
404     void willTransitionToCommitted();
405     bool didOpenURL();
406 
407     void scheduleCheckCompleted();
408     void scheduleCheckLoadComplete();
409     void startCheckCompleteTimer();
410 
411     bool shouldTreatURLAsSameAsCurrent(const URL&amp;) const;
412 
413     void dispatchGlobalObjectAvailableInAllWorlds();
414 
415     bool isNavigationAllowed() const;
416     bool isStopLoadingAllowed() const;
417 
418     enum class LoadContinuingState : uint8_t { NotContinuing, ContinuingWithRequest, ContinuingWithHistoryItem };
419     bool shouldTreatCurrentLoadAsContinuingLoad() const { return m_currentLoadContinuingState != LoadContinuingState::NotContinuing; }
420 
421     Frame&amp; m_frame;
422     FrameLoaderClient&amp; m_client;
423 
424     const std::unique_ptr&lt;PolicyChecker&gt; m_policyChecker;
425     const std::unique_ptr&lt;HistoryController&gt; m_history;
426     mutable ResourceLoadNotifier m_notifier;
427     const std::unique_ptr&lt;SubframeLoader&gt; m_subframeLoader;
428     mutable FrameLoaderStateMachine m_stateMachine;
429     mutable MixedContentChecker m_mixedContentChecker;
430 
431     class FrameProgressTracker;
432     std::unique_ptr&lt;FrameProgressTracker&gt; m_progressTracker;
433 
434     FrameState m_state;
435     FrameLoadType m_loadType;
436 
437     // Document loaders for the three phases of frame loading. Note that while
438     // a new request is being loaded, the old document loader may still be referenced.
439     // E.g. while a new request is in the &quot;policy&quot; state, the old document loader may
440     // be consulted in particular as it makes sense to imply certain settings on the new loader.
441     RefPtr&lt;DocumentLoader&gt; m_documentLoader;
442     RefPtr&lt;DocumentLoader&gt; m_provisionalDocumentLoader;
443     RefPtr&lt;DocumentLoader&gt; m_policyDocumentLoader;
444 
445     URL m_provisionalLoadErrorBeingHandledURL;
446 
447     bool m_quickRedirectComing;
448     bool m_sentRedirectNotification;
449     bool m_inStopAllLoaders;
450     bool m_inClearProvisionalLoadForPolicyCheck { false };
451     bool m_shouldReportResourceTimingToParentFrame { true };
452 
453     String m_outgoingReferrer;
454 
455     bool m_isExecutingJavaScriptFormAction;
456 
457     bool m_didCallImplicitClose;
458     bool m_wasUnloadEventEmitted;
459 
460     PageDismissalType m_pageDismissalEventBeingDispatched { PageDismissalType::None };
461     bool m_isComplete;
462 
463     RefPtr&lt;SerializedScriptValue&gt; m_pendingStateObject;
464 
465     bool m_needsClear;
466 
467     URL m_submittedFormURL;
468 
469     Timer m_checkTimer;
470     bool m_shouldCallCheckCompleted;
471     bool m_shouldCallCheckLoadComplete;
472 
473     Frame* m_opener;
474     HashSet&lt;Frame*&gt; m_openedFrames;
475 
476     bool m_loadingFromCachedPage;
477 
478     bool m_currentNavigationHasShownBeforeUnloadConfirmPanel;
479 
480     bool m_loadsSynchronously;
481 
482     SandboxFlags m_forcedSandboxFlags;
483 
484     RefPtr&lt;FrameNetworkingContext&gt; m_networkingContext;
485 
486     Optional&lt;ResourceRequestCachePolicy&gt; m_overrideCachePolicyForTesting;
487     Optional&lt;ResourceLoadPriority&gt; m_overrideResourceLoadPriorityForTesting;
488     bool m_isStrictRawResourceValidationPolicyDisabledForTesting { false };
489 
490     LoadContinuingState m_currentLoadContinuingState { LoadContinuingState::NotContinuing };
491 
492     bool m_checkingLoadCompleteForDetachment { false };
493 
494     URL m_previousURL;
495     RefPtr&lt;HistoryItem&gt; m_requestedHistoryItem;
496 
497     bool m_alwaysAllowLocalWebarchive { false };
498 };
499 
500 // This function is called by createWindow() in JSDOMWindowBase.cpp, for example, for
501 // modal dialog creation.  The lookupFrame is for looking up the frame name in case
502 // the frame name references a frame different from the openerFrame, e.g. when it is
503 // &quot;_self&quot; or &quot;_parent&quot;.
504 //
505 // FIXME: Consider making this function part of an appropriate class (not FrameLoader)
506 // and moving it to a more appropriate location.
507 RefPtr&lt;Frame&gt; createWindow(Frame&amp; openerFrame, Frame&amp; lookupFrame, FrameLoadRequest&amp;&amp;, const WindowFeatures&amp;, bool&amp; created);
508 
509 } // namespace WebCore
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
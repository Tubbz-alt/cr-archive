diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StructureInlines.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StructureInlines.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StructureInlines.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StructureInlines.h
@@ -30,10 +30,11 @@
 #include "JSGlobalObject.h"
 #include "PropertyMapHashTable.h"
 #include "Structure.h"
 #include "StructureChain.h"
 #include "StructureRareDataInlines.h"
+#include <wtf/Threading.h>
 
 namespace JSC {
 
 inline Structure* Structure::create(VM& vm, JSGlobalObject* globalObject, JSValue prototype, const TypeInfo& typeInfo, const ClassInfo* classInfo, IndexingType indexingType, unsigned inlineCapacity)
 {
@@ -106,19 +107,19 @@
     return object->structure();
 }
 
 ALWAYS_INLINE JSValue Structure::storedPrototype(const JSObject* object) const
 {
-    ASSERT(!isMainThread() || object->structure() == this);
+    ASSERT(isCompilationThread() || Thread::mayBeGCThread() || object->structure() == this);
     if (hasMonoProto())
         return storedPrototype();
     return object->getDirect(knownPolyProtoOffset);
 }
 
 ALWAYS_INLINE JSObject* Structure::storedPrototypeObject(const JSObject* object) const
 {
-    ASSERT(!isMainThread() || object->structure() == this);
+    ASSERT(isCompilationThread() || Thread::mayBeGCThread() || object->structure() == this);
     if (hasMonoProto())
         return storedPrototypeObject();
     JSValue proto = object->getDirect(knownPolyProtoOffset);
     if (proto.isNull())
         return nullptr;
@@ -141,10 +142,13 @@
 ALWAYS_INLINE PropertyOffset Structure::get(VM& vm, PropertyName propertyName, unsigned& attributes)
 {
     ASSERT(!isCompilationThread());
     ASSERT(structure(vm)->classInfo() == info());
 
+    if (m_seenProperties.ruleOut(bitwise_cast<uintptr_t>(propertyName.uid())))
+        return invalidOffset;
+
     PropertyTable* propertyTable = ensurePropertyTableIfNotEmpty(vm);
     if (!propertyTable)
         return invalidOffset;
 
     PropertyMapEntry* entry = propertyTable->get(propertyName.uid());
@@ -157,32 +161,44 @@
 
 template<typename Functor>
 void Structure::forEachPropertyConcurrently(const Functor& functor)
 {
     Vector<Structure*, 8> structures;
-    Structure* structure;
+    Structure* tableStructure;
     PropertyTable* table;
 
-    findStructuresAndMapForMaterialization(structures, structure, table);
+    findStructuresAndMapForMaterialization(structures, tableStructure, table);
+
+    HashSet<UniquedStringImpl*> seenProperties;
+
+    for (auto* structure : structures) {
+        if (!structure->m_transitionPropertyName || seenProperties.contains(structure->m_transitionPropertyName.get()))
+            continue;
+
+        seenProperties.add(structure->m_transitionPropertyName.get());
+
+        if (structure->isPropertyDeletionTransition())
+            continue;
+
+        if (!functor(PropertyMapEntry(structure->m_transitionPropertyName.get(), structure->transitionOffset(), structure->transitionPropertyAttributes()))) {
+            if (table)
+                tableStructure->m_lock.unlock();
+            return;
+        }
+    }
 
     if (table) {
         for (auto& entry : *table) {
+            if (seenProperties.contains(entry.key))
+                continue;
+
             if (!functor(entry)) {
-                structure->m_lock.unlock();
+                tableStructure->m_lock.unlock();
                 return;
             }
         }
-        structure->m_lock.unlock();
-    }
-
-    for (unsigned i = structures.size(); i--;) {
-        structure = structures[i];
-        if (!structure->m_nameInPrevious)
-            continue;
-
-        if (!functor(PropertyMapEntry(structure->m_nameInPrevious.get(), structure->m_offset, structure->attributesInPrevious())))
-            return;
+        tableStructure->m_lock.unlock();
     }
 }
 
 template<typename Functor>
 void Structure::forEachProperty(VM& vm, const Functor& functor)
@@ -295,25 +311,25 @@
         m_cachedPrototypeChain.set(vm, this, StructureChain::create(vm, prototype.isNull() ? nullptr : asObject(prototype)));
     }
     return m_cachedPrototypeChain.get();
 }
 
-inline StructureChain* Structure::prototypeChain(ExecState* exec, JSObject* base) const
+inline StructureChain* Structure::prototypeChain(JSGlobalObject* globalObject, JSObject* base) const
 {
-    return prototypeChain(exec->vm(), exec->lexicalGlobalObject(), base);
+    return prototypeChain(globalObject->vm(), globalObject, base);
 }
 
 inline bool Structure::isValid(JSGlobalObject* globalObject, StructureChain* cachedPrototypeChain, JSObject* base) const
 {
     if (!cachedPrototypeChain)
         return false;
 
     VM& vm = globalObject->vm();
     JSValue prototype = prototypeForLookup(globalObject, base);
-    WriteBarrier<Structure>* cachedStructure = cachedPrototypeChain->head();
+    StructureID* cachedStructure = cachedPrototypeChain->head();
     while (*cachedStructure && !prototype.isNull()) {
-        if (asObject(prototype)->structure(vm) != cachedStructure->get())
+        if (asObject(prototype)->structureID() != *cachedStructure)
             return false;
         ++cachedStructure;
         prototype = asObject(prototype)->getPrototypeDirect(vm);
     }
     return prototype.isNull() && !*cachedStructure;
@@ -358,25 +374,26 @@
     unsigned inlineOverflowAccordingToTotalSize = totalSize < m_inlineCapacity ? 0 : totalSize - m_inlineCapacity;
 
     auto fail = [&] (const char* description) {
         dataLog("Detected offset inconsistency: ", description, "!\n");
         dataLog("this = ", RawPointer(this), "\n");
-        dataLog("m_offset = ", m_offset, "\n");
+        dataLog("transitionOffset = ", transitionOffset(), "\n");
+        dataLog("maxOffset = ", maxOffset(), "\n");
         dataLog("m_inlineCapacity = ", m_inlineCapacity, "\n");
         dataLog("propertyTable = ", RawPointer(propertyTable), "\n");
-        dataLog("numberOfSlotsForLastOffset = ", numberOfSlotsForLastOffset(m_offset, m_inlineCapacity), "\n");
+        dataLog("numberOfSlotsForMaxOffset = ", numberOfSlotsForMaxOffset(maxOffset(), m_inlineCapacity), "\n");
         dataLog("totalSize = ", totalSize, "\n");
         dataLog("inlineOverflowAccordingToTotalSize = ", inlineOverflowAccordingToTotalSize, "\n");
-        dataLog("numberOfOutOfLineSlotsForLastOffset = ", numberOfOutOfLineSlotsForLastOffset(m_offset), "\n");
+        dataLog("numberOfOutOfLineSlotsForMaxOffset = ", numberOfOutOfLineSlotsForMaxOffset(maxOffset()), "\n");
         detailsFunc();
         UNREACHABLE_FOR_PLATFORM();
     };
 
-    if (numberOfSlotsForLastOffset(m_offset, m_inlineCapacity) != totalSize)
-        fail("numberOfSlotsForLastOffset doesn't match totalSize");
-    if (inlineOverflowAccordingToTotalSize != numberOfOutOfLineSlotsForLastOffset(m_offset))
-        fail("inlineOverflowAccordingToTotalSize doesn't match numberOfOutOfLineSlotsForLastOffset");
+    if (numberOfSlotsForMaxOffset(maxOffset(), m_inlineCapacity) != totalSize)
+        fail("numberOfSlotsForMaxOffset doesn't match totalSize");
+    if (inlineOverflowAccordingToTotalSize != numberOfOutOfLineSlotsForMaxOffset(maxOffset()))
+        fail("inlineOverflowAccordingToTotalSize doesn't match numberOfOutOfLineSlotsForMaxOffset");
 
     return true;
 }
 
 ALWAYS_INLINE bool Structure::checkOffsetConsistency() const
@@ -408,15 +425,15 @@
     if (!currentCapacity)
         return initialOutOfLineCapacity;
     return currentCapacity * outOfLineGrowthFactor;
 }
 
-inline void Structure::setObjectToStringValue(ExecState* exec, VM& vm, JSString* value, PropertySlot toStringTagSymbolSlot)
+inline void Structure::setObjectToStringValue(JSGlobalObject* globalObject, VM& vm, JSString* value, PropertySlot toStringTagSymbolSlot)
 {
     if (!hasRareData())
         allocateRareData(vm);
-    rareData()->setObjectToStringValue(exec, vm, this, value, toStringTagSymbolSlot);
+    rareData()->setObjectToStringValue(globalObject, vm, this, value, toStringTagSymbolSlot);
 }
 
 template<Structure::ShouldPin shouldPin, typename Func>
 inline PropertyOffset Structure::add(VM& vm, PropertyName propertyName, unsigned attributes, const Func& func)
 {
@@ -444,67 +461,82 @@
     auto rep = propertyName.uid();
 
     PropertyOffset newOffset = table->nextOffset(m_inlineCapacity);
 
     m_propertyHash = m_propertyHash ^ rep->existingSymbolAwareHash();
+    m_seenProperties.add(bitwise_cast<uintptr_t>(rep));
 
-    PropertyOffset newLastOffset = m_offset;
-    table->add(PropertyMapEntry(rep, newOffset, attributes), newLastOffset, PropertyTable::PropertyOffsetMayChange);
+    auto result = table->add(PropertyMapEntry(rep, newOffset, attributes));
+    ASSERT_UNUSED(result, result.second);
+    ASSERT_UNUSED(result, result.first.first->offset == newOffset);
+    auto newMaxOffset = std::max(newOffset, maxOffset());
 
-    func(locker, newOffset, newLastOffset);
+    func(locker, newOffset, newMaxOffset);
 
-    ASSERT(m_offset == newLastOffset);
+    ASSERT(maxOffset() == newMaxOffset);
 
     checkConsistency();
     return newOffset;
 }
 
-template<typename Func>
-inline PropertyOffset Structure::remove(PropertyName propertyName, const Func& func)
+template<Structure::ShouldPin shouldPin, typename Func>
+inline PropertyOffset Structure::remove(VM& vm, PropertyName propertyName, const Func& func)
 {
-    ConcurrentJSLocker locker(m_lock);
+    PropertyTable* table = ensurePropertyTable(vm);
+    GCSafeConcurrentJSLocker locker(m_lock, vm.heap);
 
-    checkConsistency();
+    switch (shouldPin) {
+    case ShouldPin::Yes:
+        pin(locker, vm, table);
+        break;
+    case ShouldPin::No:
+        setPropertyTable(vm, table);
+        break;
+    }
 
-    auto rep = propertyName.uid();
+    ASSERT(JSC::isValidOffset(get(vm, propertyName)));
 
-    // We ONLY remove from uncacheable dictionaries, which will have a pinned property table.
-    // The only way for them not to have a table is if they are empty.
-    PropertyTable* table = propertyTableOrNull();
+    checkConsistency();
 
-    if (!table)
-        return invalidOffset;
+    auto rep = propertyName.uid();
 
     PropertyTable::find_iterator position = table->find(rep);
     if (!position.first)
         return invalidOffset;
 
+    setIsQuickPropertyAccessAllowedForEnumeration(false);
+
     PropertyOffset offset = position.first->offset;
 
     table->remove(position);
     table->addDeletedOffset(offset);
 
-    checkConsistency();
+    PropertyOffset newMaxOffset = maxOffset();
+
+    func(locker, offset, newMaxOffset);
 
-    func(locker, offset);
+    ASSERT(maxOffset() == newMaxOffset);
+    ASSERT(!JSC::isValidOffset(get(vm, propertyName)));
+
+    checkConsistency();
     return offset;
 }
 
 template<typename Func>
 inline PropertyOffset Structure::addPropertyWithoutTransition(VM& vm, PropertyName propertyName, unsigned attributes, const Func& func)
 {
     return add<ShouldPin::Yes>(vm, propertyName, attributes, func);
 }
 
 template<typename Func>
-inline PropertyOffset Structure::removePropertyWithoutTransition(VM&, PropertyName propertyName, const Func& func)
+inline PropertyOffset Structure::removePropertyWithoutTransition(VM& vm, PropertyName propertyName, const Func& func)
 {
     ASSERT(isUncacheableDictionary());
     ASSERT(isPinnedPropertyTable());
     ASSERT(propertyTableOrNull());
 
-    return remove(propertyName, func);
+    return remove<ShouldPin::Yes>(vm, propertyName, func);
 }
 
 ALWAYS_INLINE void Structure::setPrototypeWithoutTransition(VM& vm, JSValue prototype)
 {
     ASSERT(isValidPrototype(prototype));

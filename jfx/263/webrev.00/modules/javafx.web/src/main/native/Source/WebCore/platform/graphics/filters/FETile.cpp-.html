<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/filters/FETile.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008 Alex Mathews &lt;possessedpenguinbob@gmail.com&gt;
  3  * Copyright (C) 2009 Dirk Schulze &lt;krit@webkit.org&gt;
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;FETile.h&quot;
 23 
 24 #include &quot;AffineTransform.h&quot;
 25 #include &quot;Filter.h&quot;
 26 #include &quot;GraphicsContext.h&quot;
 27 #include &quot;Pattern.h&quot;
 28 #include &quot;RenderTreeAsText.h&quot;
 29 #include &quot;SVGRenderingContext.h&quot;
 30 #include &lt;wtf/text/TextStream.h&gt;
 31 
 32 namespace WebCore {
 33 
 34 FETile::FETile(Filter&amp; filter)
 35     : FilterEffect(filter)
 36 {
 37 }
 38 
 39 Ref&lt;FETile&gt; FETile::create(Filter&amp; filter)
 40 {
 41     return adoptRef(*new FETile(filter));
 42 }
 43 
 44 void FETile::platformApplySoftware()
 45 {
 46 // FIXME: See bug 47315. This is a hack to work around a compile failure, but is incorrect behavior otherwise.
 47     FilterEffect* in = inputEffect(0);
 48 
 49     ImageBuffer* resultImage = createImageBufferResult();
 50     ImageBuffer* inBuffer = in-&gt;imageBufferResult();
 51     if (!resultImage || !inBuffer)
 52         return;
 53 
 54     setIsAlphaImage(in-&gt;isAlphaImage());
 55 
 56     // Source input needs more attention. It has the size of the filterRegion but gives the
 57     // size of the cutted sourceImage back. This is part of the specification and optimization.
 58     FloatRect tileRect = in-&gt;maxEffectRect();
 59     FloatPoint inMaxEffectLocation = tileRect.location();
 60     FloatPoint maxEffectLocation = maxEffectRect().location();
 61     if (in-&gt;filterEffectType() == FilterEffectTypeSourceInput) {
 62         Filter&amp; filter = this-&gt;filter();
 63         tileRect = filter.filterRegion();
 64         tileRect.scale(filter.filterResolution().width(), filter.filterResolution().height());
 65     }
 66 
 67     auto tileImage = SVGRenderingContext::createImageBuffer(tileRect, tileRect, ColorSpaceSRGB, filter().renderingMode());
 68     if (!tileImage)
 69         return;
 70 
 71     GraphicsContext&amp; tileImageContext = tileImage-&gt;context();
 72     tileImageContext.translate(-inMaxEffectLocation.x(), -inMaxEffectLocation.y());
 73     tileImageContext.drawImageBuffer(*inBuffer, in-&gt;absolutePaintRect().location());
 74 
 75     auto tileImageCopy = ImageBuffer::sinkIntoImage(WTFMove(tileImage));
 76     if (!tileImageCopy)
 77         return;
 78 
 79     auto pattern = Pattern::create(tileImageCopy.releaseNonNull(), true, true);
 80 
 81     AffineTransform patternTransform;
 82     patternTransform.translate(inMaxEffectLocation - maxEffectLocation);
 83     pattern.get().setPatternSpaceTransform(patternTransform);
 84     GraphicsContext&amp; filterContext = resultImage-&gt;context();
 85     filterContext.setFillPattern(WTFMove(pattern));
 86     filterContext.fillRect(FloatRect(FloatPoint(), absolutePaintRect().size()));
 87 }
 88 
 89 TextStream&amp; FETile::externalRepresentation(TextStream&amp; ts, RepresentationType representation) const
 90 {
 91     ts &lt;&lt; indent &lt;&lt; &quot;[feTile&quot;;
 92     FilterEffect::externalRepresentation(ts, representation);
 93     ts &lt;&lt; &quot;]\n&quot;;
 94 
 95     TextStream::IndentScope indentScope(ts);
 96     inputEffect(0)-&gt;externalRepresentation(ts, representation);
 97 
 98     return ts;
 99 }
100 
101 } // namespace WebCore
    </pre>
  </body>
</html>
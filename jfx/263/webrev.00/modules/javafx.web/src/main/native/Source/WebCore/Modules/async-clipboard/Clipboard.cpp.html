<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/async-clipboard/Clipboard.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;Clipboard.h&quot;
 28 
 29 #include &quot;ClipboardItem.h&quot;
 30 #include &quot;Document.h&quot;
 31 #include &quot;Frame.h&quot;
 32 #include &quot;JSBlob.h&quot;
 33 #include &quot;JSClipboardItem.h&quot;
 34 #include &quot;JSDOMPromiseDeferred.h&quot;
 35 #include &quot;Navigator.h&quot;
 36 #include &quot;Pasteboard.h&quot;
 37 #include &quot;Settings.h&quot;
 38 #include &quot;SharedBuffer.h&quot;
 39 #include &quot;UserGestureIndicator.h&quot;
 40 #include &quot;WebContentReader.h&quot;
 41 #include &lt;wtf/CompletionHandler.h&gt;
 42 #include &lt;wtf/IsoMallocInlines.h&gt;
 43 
 44 namespace WebCore {
 45 
 46 WTF_MAKE_ISO_ALLOCATED_IMPL(Clipboard);
 47 
 48 static bool shouldProceedWithClipboardWrite(const Frame&amp; frame)
 49 {
 50     auto&amp; settings = frame.settings();
 51     if (settings.javaScriptCanAccessClipboard())
 52         return true;
 53 
 54     switch (settings.clipboardAccessPolicy()) {
 55     case ClipboardAccessPolicy::Allow:
 56         return true;
 57     case ClipboardAccessPolicy::RequiresUserGesture:
 58         return UserGestureIndicator::processingUserGesture();
 59     case ClipboardAccessPolicy::Deny:
 60         return false;
 61     }
 62 
 63     ASSERT_NOT_REACHED();
 64     return false;
 65 }
 66 
 67 Ref&lt;Clipboard&gt; Clipboard::create(Navigator&amp; navigator)
 68 {
 69     return adoptRef(*new Clipboard(navigator));
 70 }
 71 
 72 Clipboard::Clipboard(Navigator&amp; navigator)
 73     : m_navigator(makeWeakPtr(navigator))
 74 {
 75 }
 76 
 77 Clipboard::~Clipboard()
 78 {
 79     if (auto writer = WTFMove(m_activeItemWriter))
 80         writer-&gt;invalidate();
 81 }
 82 
 83 Navigator* Clipboard::navigator()
 84 {
 85     return m_navigator.get();
 86 }
 87 
 88 EventTargetInterface Clipboard::eventTargetInterface() const
 89 {
 90     return ClipboardEventTargetInterfaceType;
 91 }
 92 
 93 ScriptExecutionContext* Clipboard::scriptExecutionContext() const
 94 {
 95     return m_navigator ? m_navigator-&gt;scriptExecutionContext() : nullptr;
 96 }
 97 
 98 void Clipboard::readText(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
 99 {
100     auto frame = makeRefPtr(this-&gt;frame());
101     if (!frame) {
102         promise-&gt;reject(NotAllowedError);
103         return;
104     }
105 
106     auto pasteboard = Pasteboard::createForCopyAndPaste();
107     auto changeCountAtStart = pasteboard-&gt;changeCount();
108     if (!frame-&gt;requestDOMPasteAccess()) {
109         promise-&gt;reject(NotAllowedError);
110         return;
111     }
112 
113     auto allInfo = pasteboard-&gt;allPasteboardItemInfo();
114     if (!allInfo) {
115         promise-&gt;reject(NotAllowedError);
116         return;
117     }
118 
119     String text;
120     for (size_t index = 0; index &lt; allInfo-&gt;size(); ++index) {
121         if (allInfo-&gt;at(index).webSafeTypesByFidelity.contains(&quot;text/plain&quot;_s)) {
122             PasteboardPlainText plainTextReader;
123             pasteboard-&gt;read(plainTextReader, PlainTextURLReadingPolicy::IgnoreURL, index);
124             text = WTFMove(plainTextReader.text);
125             break;
126         }
127     }
128 
129     if (changeCountAtStart == pasteboard-&gt;changeCount())
130         promise-&gt;resolve&lt;IDLDOMString&gt;(WTFMove(text));
131     else
132         promise-&gt;reject(NotAllowedError);
133 }
134 
135 void Clipboard::writeText(const String&amp; data, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
136 {
137     auto frame = makeRefPtr(this-&gt;frame());
138     auto document = makeRefPtr(frame ? frame-&gt;document() : nullptr);
139     if (!document || !shouldProceedWithClipboardWrite(*frame)) {
140         promise-&gt;reject(NotAllowedError);
141         return;
142     }
143 
144     PasteboardCustomData customData;
145     customData.writeString(&quot;text/plain&quot;_s, data);
146     customData.setOrigin(document-&gt;originIdentifierForPasteboard());
147     Pasteboard::createForCopyAndPaste()-&gt;writeCustomData({ WTFMove(customData) });
148     promise-&gt;resolve();
149 }
150 
151 void Clipboard::read(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
152 {
153     auto rejectPromiseAndClearActiveSession = [&amp;] {
154         m_activeSession = WTF::nullopt;
155         promise-&gt;reject(NotAllowedError);
156     };
157 
158     auto frame = makeRefPtr(this-&gt;frame());
159     if (!frame) {
160         rejectPromiseAndClearActiveSession();
161         return;
162     }
163 
164     auto pasteboard = Pasteboard::createForCopyAndPaste();
165     auto changeCountAtStart = pasteboard-&gt;changeCount();
166 
167     if (!frame-&gt;requestDOMPasteAccess()) {
168         rejectPromiseAndClearActiveSession();
169         return;
170     }
171 
172     if (!m_activeSession || m_activeSession-&gt;changeCount != changeCountAtStart) {
173         auto allInfo = pasteboard-&gt;allPasteboardItemInfo();
174         if (!allInfo) {
175             rejectPromiseAndClearActiveSession();
176             return;
177         }
178 
179         Vector&lt;Ref&lt;ClipboardItem&gt;&gt; clipboardItems;
180         clipboardItems.reserveInitialCapacity(allInfo-&gt;size());
181         for (auto&amp; itemInfo : *allInfo)
182             clipboardItems.uncheckedAppend(ClipboardItem::create(*this, itemInfo));
183         m_activeSession = {{ WTFMove(pasteboard), WTFMove(clipboardItems), changeCountAtStart }};
184     }
185 
186     promise-&gt;resolve&lt;IDLSequence&lt;IDLInterface&lt;ClipboardItem&gt;&gt;&gt;(m_activeSession-&gt;items);
187 }
188 
189 void Clipboard::getType(ClipboardItem&amp; item, const String&amp; type, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
190 {
191     if (!m_activeSession) {
192         promise-&gt;reject(NotAllowedError);
193         return;
194     }
195 
196     auto frame = makeRefPtr(this-&gt;frame());
197     if (!frame) {
198         m_activeSession = WTF::nullopt;
199         promise-&gt;reject(NotAllowedError);
200         return;
201     }
202 
203     auto itemIndex = m_activeSession-&gt;items.findMatching([&amp;] (auto&amp; activeItem) {
204         return activeItem.ptr() == &amp;item;
205     });
206 
207     if (itemIndex == notFound) {
208         promise-&gt;reject(NotAllowedError);
209         return;
210     }
211 
212     if (!item.types().contains(type)) {
213         promise-&gt;reject(NotAllowedError);
214         return;
215     }
216 
217     String resultAsString;
218 
219     if (type == &quot;text/uri-list&quot;_s) {
220         String title;
221         resultAsString = activePasteboard().readURL(itemIndex, title).string();
222     }
223 
224     if (type == &quot;text/plain&quot;_s) {
225         PasteboardPlainText plainTextReader;
226         activePasteboard().read(plainTextReader, PlainTextURLReadingPolicy::IgnoreURL, itemIndex);
227         resultAsString = WTFMove(plainTextReader.text);
228     }
229 
230     if (type == &quot;text/html&quot;_s) {
231         WebContentMarkupReader markupReader { *frame };
232         activePasteboard().read(markupReader, WebContentReadingPolicy::OnlyRichTextTypes, itemIndex);
233         resultAsString = WTFMove(markupReader.markup);
234     }
235 
236     // FIXME: Support reading &quot;image/png&quot; as well as custom data.
237     // FIXME: Instead of checking changeCount here, we should send the changeCount over to the UI process to be vetted
238     // when attempting to read the data in the first place.
239     if (m_activeSession-&gt;changeCount != activePasteboard().changeCount()) {
240         m_activeSession = WTF::nullopt;
241         promise-&gt;reject(NotAllowedError);
242         return;
243     }
244 
245     if (!resultAsString.isNull())
246         promise-&gt;resolve&lt;IDLInterface&lt;Blob&gt;&gt;(ClipboardItem::blobFromString(resultAsString, type));
247     else
248         promise-&gt;reject(NotAllowedError);
249 }
250 
251 void Clipboard::write(const Vector&lt;RefPtr&lt;ClipboardItem&gt;&gt;&amp; items, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
252 {
253     auto frame = makeRefPtr(this-&gt;frame());
254     if (!frame || !shouldProceedWithClipboardWrite(*frame)) {
255         promise-&gt;reject(NotAllowedError);
256         return;
257     }
258 
259     if (auto existingWriter = std::exchange(m_activeItemWriter, ItemWriter::create(*this, WTFMove(promise))))
260         existingWriter-&gt;invalidate();
261 
262     m_activeItemWriter-&gt;write(items);
263 }
264 
265 void Clipboard::didResolveOrReject(Clipboard::ItemWriter&amp; writer)
266 {
267     if (m_activeItemWriter == &amp;writer)
268         m_activeItemWriter = nullptr;
269 }
270 
271 Frame* Clipboard::frame() const
272 {
273     return m_navigator ? m_navigator-&gt;frame() : nullptr;
274 }
275 
276 Pasteboard&amp; Clipboard::activePasteboard()
277 {
278     ASSERT(m_activeSession);
279     ASSERT(m_activeSession-&gt;pasteboard);
280     return *m_activeSession-&gt;pasteboard;
281 }
282 
283 Clipboard::ItemWriter::ItemWriter(Clipboard&amp; clipboard, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
284     : m_clipboard(makeWeakPtr(clipboard))
285     , m_promise(WTFMove(promise))
286     , m_pasteboard(Pasteboard::createForCopyAndPaste())
287 {
288 }
289 
290 Clipboard::ItemWriter::~ItemWriter() = default;
291 
292 void Clipboard::ItemWriter::write(const Vector&lt;RefPtr&lt;ClipboardItem&gt;&gt;&amp; items)
293 {
294     ASSERT(m_promise);
295     ASSERT(m_clipboard);
296 #if PLATFORM(COCOA)
297     m_changeCountAtStart = m_pasteboard-&gt;changeCount();
298 #endif
299     m_dataToWrite.fill(WTF::nullopt, items.size());
300     m_pendingItemCount = items.size();
301     for (size_t index = 0; index &lt; items.size(); ++index) {
302         items[index]-&gt;collectDataForWriting(*m_clipboard, [this, protectedThis = makeRef(*this), index] (auto data) {
303             protectedThis-&gt;setData(WTFMove(data), index);
304             if (!--m_pendingItemCount)
305                 didSetAllData();
306         });
307     }
308     if (items.isEmpty())
309         didSetAllData();
310 }
311 
312 void Clipboard::ItemWriter::invalidate()
313 {
314     if (m_promise)
315         reject();
316 }
317 
318 void Clipboard::ItemWriter::setData(Optional&lt;PasteboardCustomData&gt;&amp;&amp; data, size_t index)
319 {
320     if (index &gt;= m_dataToWrite.size()) {
321         ASSERT_NOT_REACHED();
322         return;
323     }
324 
325     m_dataToWrite[index] = WTFMove(data);
326 }
327 
328 void Clipboard::ItemWriter::didSetAllData()
329 {
330     if (!m_promise)
331         return;
332 
333 #if PLATFORM(COCOA)
334     auto newChangeCount = m_pasteboard-&gt;changeCount();
335     if (m_changeCountAtStart != newChangeCount) {
336         // FIXME: Instead of checking the changeCount here, send it over to the client (e.g. the UI process
337         // in WebKit2) and perform it there.
338         reject();
339         return;
340     }
341 #endif // PLATFORM(COCOA)
342     auto dataToWrite = std::exchange(m_dataToWrite, { });
343     Vector&lt;PasteboardCustomData&gt; customData;
344     customData.reserveInitialCapacity(dataToWrite.size());
345     for (auto data : dataToWrite) {
346         if (!data) {
347             reject();
348             return;
349         }
350         customData.append(*data);
351     }
352 
353     m_pasteboard-&gt;writeCustomData(WTFMove(customData));
354     m_promise-&gt;resolve();
355     m_promise = nullptr;
356 
357     if (auto clipboard = std::exchange(m_clipboard, nullptr))
358         clipboard-&gt;didResolveOrReject(*this);
359 }
360 
361 void Clipboard::ItemWriter::reject()
362 {
363     if (auto promise = std::exchange(m_promise, nullptr))
364         promise-&gt;reject(NotAllowedError);
365 
366     if (auto clipboard = std::exchange(m_clipboard, nullptr))
367         clipboard-&gt;didResolveOrReject(*this);
368 }
369 
370 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/webauthn/fido/Pin.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Copyright 2019 The Chromium Authors. All rights reserved.
  2 // Copyright (C) 2019 Apple Inc. All rights reserved.
  3 //
  4 // Redistribution and use in source and binary forms, with or without
  5 // modification, are permitted provided that the following conditions are
  6 // met:
  7 //
  8 //    * Redistributions of source code must retain the above copyright
  9 // notice, this list of conditions and the following disclaimer.
 10 //    * Redistributions in binary form must reproduce the above
 11 // copyright notice, this list of conditions and the following disclaimer
 12 // in the documentation and/or other materials provided with the
 13 // distribution.
 14 //    * Neither the name of Google Inc. nor the names of its
 15 // contributors may be used to endorse or promote products derived from
 16 // this software without specific prior written permission.
 17 //
 18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;Pin.h&quot;
 32 
 33 #if ENABLE(WEB_AUTHN)
 34 
 35 #include &quot;CBORReader.h&quot;
 36 #include &quot;CBORWriter.h&quot;
 37 #include &quot;CryptoAlgorithmAES_CBC.h&quot;
 38 #include &quot;CryptoAlgorithmAesCbcCfbParams.h&quot;
 39 #include &quot;CryptoAlgorithmECDH.h&quot;
 40 #include &quot;CryptoAlgorithmHMAC.h&quot;
 41 #include &quot;CryptoKeyAES.h&quot;
 42 #include &quot;CryptoKeyEC.h&quot;
 43 #include &quot;CryptoKeyHMAC.h&quot;
 44 #include &quot;DeviceResponseConverter.h&quot;
 45 #include &quot;WebAuthenticationConstants.h&quot;
 46 #include &lt;pal/crypto/CryptoDigest.h&gt;
 47 
 48 namespace fido {
 49 using namespace WebCore;
 50 using CBOR = cbor::CBORValue;
 51 
 52 namespace pin {
 53 using namespace cbor;
 54 
 55 // hasAtLeastFourCodepoints returns true if |pin| contains
 56 // four or more code points. This reflects the &quot;4 Unicode characters&quot;
 57 // requirement in CTAP2.
 58 static bool hasAtLeastFourCodepoints(const String&amp; pin)
 59 {
 60     return pin.length() &gt;= 4;
 61 }
 62 
 63 // makePinAuth returns `LEFT(HMAC-SHA-256(secret, data), 16)`.
 64 static Vector&lt;uint8_t&gt; makePinAuth(const CryptoKeyHMAC&amp; key, const Vector&lt;uint8_t&gt;&amp; data)
 65 {
 66     auto result = CryptoAlgorithmHMAC::platformSign(key, data);
 67     ASSERT(!result.hasException());
 68     auto pinAuth = result.releaseReturnValue();
 69     pinAuth.shrink(16);
 70     return pinAuth;
 71 }
 72 
 73 Vector&lt;uint8_t&gt; encodeRawPublicKey(const Vector&lt;uint8_t&gt;&amp; x, const Vector&lt;uint8_t&gt;&amp; y)
 74 {
 75     Vector&lt;uint8_t&gt; rawKey;
 76     rawKey.reserveCapacity(1 + x.size() + y.size());
 77     rawKey.append(0x04);
 78     rawKey.appendVector(x);
 79     rawKey.appendVector(y);
 80     return rawKey;
 81 }
 82 
 83 Optional&lt;CString&gt; validateAndConvertToUTF8(const String&amp; pin)
 84 {
 85     if (!hasAtLeastFourCodepoints(pin))
 86         return WTF::nullopt;
 87     auto result = pin.utf8();
 88     if (result.length() &lt; kMinBytes || result.length() &gt; kMaxBytes)
 89         return WTF::nullopt;
 90     return result;
 91 }
 92 
 93 // encodePINCommand returns a CTAP2 PIN command for the operation |subcommand|.
 94 // Additional elements of the top-level CBOR map can be added with the optional
 95 // |addAdditional| callback.
 96 static Vector&lt;uint8_t&gt; encodePinCommand(Subcommand subcommand, Function&lt;void(CBORValue::MapValue*)&gt; addAdditional = nullptr)
 97 {
 98     CBORValue::MapValue map;
 99     map.emplace(static_cast&lt;int64_t&gt;(RequestKey::kProtocol), kProtocolVersion);
100     map.emplace(static_cast&lt;int64_t&gt;(RequestKey::kSubcommand), static_cast&lt;int64_t&gt;(subcommand));
101 
102     if (addAdditional)
103         addAdditional(&amp;map);
104 
105     // FIXME(205375)
106     auto serializedParam = CBORWriter::write(CBORValue(WTFMove(map)));
107     ASSERT(serializedParam);
108 
109     Vector&lt;uint8_t&gt; cborRequest({ static_cast&lt;uint8_t&gt;(CtapRequestCommand::kAuthenticatorClientPin) });
110     cborRequest.appendVector(*serializedParam);
111     return cborRequest;
112 }
113 
114 RetriesResponse::RetriesResponse() = default;
115 
116 Optional&lt;RetriesResponse&gt; RetriesResponse::parse(const Vector&lt;uint8_t&gt;&amp; inBuffer)
117 {
118     // FIXME(205375)
119     if (inBuffer.size() &lt;= kResponseCodeLength || getResponseCode(inBuffer) != CtapDeviceResponseCode::kSuccess)
120         return WTF::nullopt;
121 
122     Vector&lt;uint8_t&gt; buffer;
123     buffer.append(inBuffer.data() + 1, inBuffer.size() - 1);
124     Optional&lt;CBOR&gt; decodedResponse = cbor::CBORReader::read(buffer);
125     if (!decodedResponse || !decodedResponse-&gt;isMap())
126         return WTF::nullopt;
127     const auto&amp; responseMap = decodedResponse-&gt;getMap();
128 
129     auto it = responseMap.find(CBORValue(static_cast&lt;int64_t&gt;(ResponseKey::kRetries)));
130     if (it == responseMap.end() || !it-&gt;second.isUnsigned())
131         return WTF::nullopt;
132 
133     RetriesResponse ret;
134     ret.retries = static_cast&lt;uint64_t&gt;(it-&gt;second.getUnsigned());
135     return ret;
136 }
137 
138 KeyAgreementResponse::KeyAgreementResponse(Ref&lt;CryptoKeyEC&gt;&amp;&amp; peerKey)
139     : peerKey(WTFMove(peerKey))
140 {
141 }
142 
143 Optional&lt;KeyAgreementResponse&gt; KeyAgreementResponse::parse(const Vector&lt;uint8_t&gt;&amp; inBuffer)
144 {
145     // FIXME(205375)
146     if (inBuffer.size() &lt;= kResponseCodeLength || getResponseCode(inBuffer) != CtapDeviceResponseCode::kSuccess)
147         return WTF::nullopt;
148 
149     Vector&lt;uint8_t&gt; buffer;
150     buffer.append(inBuffer.data() + 1, inBuffer.size() - 1);
151     auto decodedResponse = cbor::CBORReader::read(buffer);
152     if (!decodedResponse || !decodedResponse-&gt;isMap())
153         return WTF::nullopt;
154     const auto&amp; responseMap = decodedResponse-&gt;getMap();
155 
156     // The ephemeral key is encoded as a COSE structure.
157     auto it = responseMap.find(CBORValue(static_cast&lt;int64_t&gt;(ResponseKey::kKeyAgreement)));
158     if (it == responseMap.end() || !it-&gt;second.isMap())
159         return WTF::nullopt;
160     const auto&amp; coseKey = it-&gt;second.getMap();
161 
162     return parseFromCOSE(coseKey);
163 }
164 
165 Optional&lt;KeyAgreementResponse&gt; KeyAgreementResponse::parseFromCOSE(const CBORValue::MapValue&amp; coseKey)
166 {
167     // The COSE key must be a P-256 point. See
168     // https://tools.ietf.org/html/rfc8152#section-7.1
169     for (const auto&amp; pair : Vector&lt;std::pair&lt;int64_t, int64_t&gt;&gt;({
170         { static_cast&lt;int64_t&gt;(COSE::kty), static_cast&lt;int64_t&gt;(COSE::EC2) },
171         { static_cast&lt;int64_t&gt;(COSE::alg), static_cast&lt;int64_t&gt;(COSE::ECDH256) },
172         { static_cast&lt;int64_t&gt;(COSE::crv), static_cast&lt;int64_t&gt;(COSE::P_256) },
173     })) {
174         auto it = coseKey.find(CBORValue(pair.first));
175         if (it == coseKey.end() || !it-&gt;second.isInteger() || it-&gt;second.getInteger() != pair.second)
176             return WTF::nullopt;
177     }
178 
179     // See https://tools.ietf.org/html/rfc8152#section-13.1.1
180     const auto&amp; xIt = coseKey.find(CBORValue(static_cast&lt;int64_t&gt;(COSE::x)));
181     const auto&amp; yIt = coseKey.find(CBORValue(static_cast&lt;int64_t&gt;(COSE::y)));
182     if (xIt == coseKey.end() || yIt == coseKey.end() || !xIt-&gt;second.isByteString() || !yIt-&gt;second.isByteString())
183         return WTF::nullopt;
184 
185     const auto&amp; x = xIt-&gt;second.getByteString();
186     const auto&amp; y = yIt-&gt;second.getByteString();
187     auto peerKey = CryptoKeyEC::importRaw(CryptoAlgorithmIdentifier::ECDH, &quot;P-256&quot;, encodeRawPublicKey(x, y), true, CryptoKeyUsageDeriveBits);
188     if (!peerKey)
189         return WTF::nullopt;
190 
191     return KeyAgreementResponse(peerKey.releaseNonNull());
192 }
193 
194 cbor::CBORValue::MapValue encodeCOSEPublicKey(const Vector&lt;uint8_t&gt;&amp; rawPublicKey)
195 {
196     ASSERT(rawPublicKey.size() == 65);
197     Vector&lt;uint8_t&gt; x;
198     x.append(rawPublicKey.data() + 1, ES256FieldElementLength);
199     Vector&lt;uint8_t&gt; y;
200     y.append(rawPublicKey.data() + 1 + ES256FieldElementLength, ES256FieldElementLength);
201 
202     cbor::CBORValue::MapValue publicKeyMap;
203     publicKeyMap[cbor::CBORValue(COSE::kty)] = cbor::CBORValue(COSE::EC2);
204     publicKeyMap[cbor::CBORValue(COSE::alg)] = cbor::CBORValue(COSE::ECDH256);
205     publicKeyMap[cbor::CBORValue(COSE::crv)] = cbor::CBORValue(COSE::P_256);
206     publicKeyMap[cbor::CBORValue(COSE::x)] = cbor::CBORValue(WTFMove(x));
207     publicKeyMap[cbor::CBORValue(COSE::y)] = cbor::CBORValue(WTFMove(y));
208 
209     return publicKeyMap;
210 }
211 
212 TokenResponse::TokenResponse(Ref&lt;WebCore::CryptoKeyHMAC&gt;&amp;&amp; token)
213     : m_token(WTFMove(token))
214 {
215 }
216 
217 Optional&lt;TokenResponse&gt; TokenResponse::parse(const WebCore::CryptoKeyAES&amp; sharedKey, const Vector&lt;uint8_t&gt;&amp; inBuffer)
218 {
219     // FIXME(205375)
220     if (inBuffer.size() &lt;= kResponseCodeLength || getResponseCode(inBuffer) != CtapDeviceResponseCode::kSuccess)
221         return WTF::nullopt;
222 
223     Vector&lt;uint8_t&gt; buffer;
224     buffer.append(inBuffer.data() + 1, inBuffer.size() - 1);
225     auto decodedResponse = cbor::CBORReader::read(buffer);
226     if (!decodedResponse || !decodedResponse-&gt;isMap())
227         return WTF::nullopt;
228     const auto&amp; responseMap = decodedResponse-&gt;getMap();
229 
230     auto it = responseMap.find(CBORValue(static_cast&lt;int64_t&gt;(ResponseKey::kPinToken)));
231     if (it == responseMap.end() || !it-&gt;second.isByteString())
232         return WTF::nullopt;
233     const auto&amp; encryptedToken = it-&gt;second.getByteString();
234 
235     auto tokenResult = CryptoAlgorithmAES_CBC::platformDecrypt({ }, sharedKey, encryptedToken, CryptoAlgorithmAES_CBC::Padding::No);
236     if (tokenResult.hasException())
237         return WTF::nullopt;
238     auto token = tokenResult.releaseReturnValue();
239 
240     auto tokenKey = CryptoKeyHMAC::importRaw(token.size() * 8, CryptoAlgorithmIdentifier::SHA_256, WTFMove(token), true, CryptoKeyUsageSign);
241     ASSERT(tokenKey);
242 
243     return TokenResponse(tokenKey.releaseNonNull());
244 }
245 
246 Vector&lt;uint8_t&gt; TokenResponse::pinAuth(const Vector&lt;uint8_t&gt;&amp; clientDataHash) const
247 {
248     return makePinAuth(m_token, clientDataHash);
249 }
250 
251 const Vector&lt;uint8_t&gt;&amp; TokenResponse::token() const
252 {
253     return m_token-&gt;key();
254 }
255 
256 Vector&lt;uint8_t&gt; encodeAsCBOR(const RetriesRequest&amp;)
257 {
258     return encodePinCommand(Subcommand::kGetRetries);
259 }
260 
261 Vector&lt;uint8_t&gt; encodeAsCBOR(const KeyAgreementRequest&amp;)
262 {
263     return encodePinCommand(Subcommand::kGetKeyAgreement);
264 }
265 
266 Optional&lt;TokenRequest&gt; TokenRequest::tryCreate(const CString&amp; pin, const CryptoKeyEC&amp; peerKey)
267 {
268     // The following implements Section 5.5.4 Getting sharedSecret from Authenticator.
269     // https://fidoalliance.org/specs/fido-v2.0-ps-20190130/fido-client-to-authenticator-protocol-v2.0-ps-20190130.html#gettingSharedSecret
270     // 1. Generate a P256 key pair.
271     auto keyPairResult = CryptoKeyEC::generatePair(CryptoAlgorithmIdentifier::ECDH, &quot;P-256&quot;, true, CryptoKeyUsageDeriveBits);
272     ASSERT(!keyPairResult.hasException());
273     auto keyPair = keyPairResult.releaseReturnValue();
274 
275     // 2. Use ECDH and SHA-256 to compute the shared AES-CBC key.
276     auto sharedKeyResult = CryptoAlgorithmECDH::platformDeriveBits(downcast&lt;CryptoKeyEC&gt;(*keyPair.privateKey), peerKey);
277     if (!sharedKeyResult)
278         return WTF::nullopt;
279 
280     auto crypto = PAL::CryptoDigest::create(PAL::CryptoDigest::Algorithm::SHA_256);
281     crypto-&gt;addBytes(sharedKeyResult-&gt;data(), sharedKeyResult-&gt;size());
282     auto sharedKeyHash = crypto-&gt;computeHash();
283 
284     auto sharedKey = CryptoKeyAES::importRaw(CryptoAlgorithmIdentifier::AES_CBC, WTFMove(sharedKeyHash), true, CryptoKeyUsageEncrypt | CryptoKeyUsageDecrypt);
285     ASSERT(sharedKey);
286 
287     // The following encodes the public key of the above key pair into COSE format.
288     auto rawPublicKeyResult = downcast&lt;CryptoKeyEC&gt;(*keyPair.publicKey).exportRaw();
289     ASSERT(!rawPublicKeyResult.hasException());
290     auto coseKey = encodeCOSEPublicKey(rawPublicKeyResult.returnValue());
291 
292     // The following calculates a SHA-256 digest of the PIN, and shrink to the left 16 bytes.
293     crypto = PAL::CryptoDigest::create(PAL::CryptoDigest::Algorithm::SHA_256);
294     crypto-&gt;addBytes(pin.data(), pin.length());
295     auto pinHash = crypto-&gt;computeHash();
296     pinHash.shrink(16);
297 
298     return TokenRequest(sharedKey.releaseNonNull(), WTFMove(coseKey), WTFMove(pinHash));
299 }
300 
301 TokenRequest::TokenRequest(Ref&lt;WebCore::CryptoKeyAES&gt;&amp;&amp; sharedKey, cbor::CBORValue::MapValue&amp;&amp; coseKey, Vector&lt;uint8_t&gt;&amp;&amp; pinHash)
302     : m_sharedKey(WTFMove(sharedKey))
303     , m_coseKey(WTFMove(coseKey))
304     , m_pinHash(WTFMove(pinHash))
305 {
306 }
307 
308 const CryptoKeyAES&amp; TokenRequest::sharedKey() const
309 {
310     return m_sharedKey;
311 }
312 
313 Vector&lt;uint8_t&gt; encodeAsCBOR(const TokenRequest&amp; request)
314 {
315     auto result = CryptoAlgorithmAES_CBC::platformEncrypt({ }, request.sharedKey(), request.m_pinHash, CryptoAlgorithmAES_CBC::Padding::No);
316     ASSERT(!result.hasException());
317 
318     return encodePinCommand(Subcommand::kGetPinToken, [coseKey = WTFMove(request.m_coseKey), encryptedPin = result.releaseReturnValue()] (CBORValue::MapValue* map) mutable {
319         map-&gt;emplace(static_cast&lt;int64_t&gt;(RequestKey::kKeyAgreement), WTFMove(coseKey));
320         map-&gt;emplace(static_cast&lt;int64_t&gt;(RequestKey::kPinHashEnc), WTFMove(encryptedPin));
321     });
322 }
323 
324 } // namespace pin
325 } // namespace fido
326 
327 #endif // ENABLE(WEB_AUTHN)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/CanvasBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CanvasBase.h&quot;
 28 
 29 #include &quot;CSSCanvasValue.h&quot;
 30 #include &quot;CanvasRenderingContext.h&quot;
 31 #include &quot;Element.h&quot;
 32 #include &quot;FloatRect.h&quot;
 33 #include &quot;InspectorInstrumentation.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 34 #include &lt;JavaScriptCore/JSCInlines.h&gt;</span>
<span class="line-added"> 35 #include &lt;JavaScriptCore/JSLock.h&gt;</span>
<span class="line-added"> 36 #include &lt;atomic&gt;</span>
 37 #include &lt;wtf/Vector.h&gt;
 38 
<a name="2" id="anc2"></a><span class="line-added"> 39 static std::atomic&lt;size_t&gt; s_activePixelMemory { 0 };</span>
<span class="line-added"> 40 </span>
 41 namespace WebCore {
 42 
<a name="3" id="anc3"></a><span class="line-modified"> 43 #if USE(CG)</span>
<span class="line-added"> 44 // FIXME: It seems strange that the default quality is not the one that is literally named &quot;default&quot;.</span>
<span class="line-added"> 45 // Should fix names to make this easier to understand, or write an excellent comment here explaining why not.</span>
<span class="line-added"> 46 const InterpolationQuality defaultInterpolationQuality = InterpolationQuality::Low;</span>
<span class="line-added"> 47 #else</span>
<span class="line-added"> 48 const InterpolationQuality defaultInterpolationQuality = InterpolationQuality::Default;</span>
<span class="line-added"> 49 #endif</span>
<span class="line-added"> 50 </span>
<span class="line-added"> 51 CanvasBase::CanvasBase(IntSize size)</span>
<span class="line-added"> 52     : m_size(size)</span>
 53 {
 54 }
 55 
 56 CanvasBase::~CanvasBase()
 57 {
<a name="4" id="anc4"></a>
 58     ASSERT(m_didNotifyObserversCanvasDestroyed);
 59     ASSERT(m_observers.isEmpty());
<a name="5" id="anc5"></a><span class="line-added"> 60     ASSERT(!m_imageBuffer);</span>
<span class="line-added"> 61 }</span>
<span class="line-added"> 62 </span>
<span class="line-added"> 63 GraphicsContext* CanvasBase::drawingContext() const</span>
<span class="line-added"> 64 {</span>
<span class="line-added"> 65     auto* context = renderingContext();</span>
<span class="line-added"> 66     if (context &amp;&amp; !context-&gt;is2d() &amp;&amp; !context-&gt;isOffscreen2d())</span>
<span class="line-added"> 67         return nullptr;</span>
<span class="line-added"> 68 </span>
<span class="line-added"> 69     return buffer() ? &amp;m_imageBuffer-&gt;context() : nullptr;</span>
<span class="line-added"> 70 }</span>
<span class="line-added"> 71 </span>
<span class="line-added"> 72 GraphicsContext* CanvasBase::existingDrawingContext() const</span>
<span class="line-added"> 73 {</span>
<span class="line-added"> 74     if (!hasCreatedImageBuffer())</span>
<span class="line-added"> 75         return nullptr;</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77     return drawingContext();</span>
 78 }
 79 
<a name="6" id="anc6"></a><span class="line-modified"> 80 ImageBuffer* CanvasBase::buffer() const</span>
 81 {
<a name="7" id="anc7"></a><span class="line-modified"> 82     if (!hasCreatedImageBuffer())</span>
<span class="line-added"> 83         createImageBuffer();</span>
<span class="line-added"> 84     return m_imageBuffer.get();</span>
<span class="line-added"> 85 }</span>
<span class="line-added"> 86 </span>
<span class="line-added"> 87 AffineTransform CanvasBase::baseTransform() const</span>
<span class="line-added"> 88 {</span>
<span class="line-added"> 89     ASSERT(hasCreatedImageBuffer());</span>
<span class="line-added"> 90     return m_imageBuffer-&gt;baseTransform();</span>
<span class="line-added"> 91 }</span>
<span class="line-added"> 92 </span>
<span class="line-added"> 93 void CanvasBase::makeRenderingResultsAvailable()</span>
<span class="line-added"> 94 {</span>
<span class="line-added"> 95     if (auto* context = renderingContext())</span>
<span class="line-added"> 96         context-&gt;paintRenderingResultsToCanvas();</span>
<span class="line-added"> 97 }</span>
<span class="line-added"> 98 </span>
<span class="line-added"> 99 size_t CanvasBase::memoryCost() const</span>
<span class="line-added">100 {</span>
<span class="line-added">101     // memoryCost() may be invoked concurrently from a GC thread, and we need to be careful</span>
<span class="line-added">102     // about what data we access here and how. We need to hold a lock to prevent m_imageBuffer</span>
<span class="line-added">103     // from being changed while we access it.</span>
<span class="line-added">104     auto locker = holdLock(m_imageBufferAssignmentLock);</span>
<span class="line-added">105     if (!m_imageBuffer)</span>
<span class="line-added">106         return 0;</span>
<span class="line-added">107     return m_imageBuffer-&gt;memoryCost();</span>
<span class="line-added">108 }</span>
<span class="line-added">109 </span>
<span class="line-added">110 size_t CanvasBase::externalMemoryCost() const</span>
<span class="line-added">111 {</span>
<span class="line-added">112     // externalMemoryCost() may be invoked concurrently from a GC thread, and we need to be careful</span>
<span class="line-added">113     // about what data we access here and how. We need to hold a lock to prevent m_imageBuffer</span>
<span class="line-added">114     // from being changed while we access it.</span>
<span class="line-added">115     auto locker = holdLock(m_imageBufferAssignmentLock);</span>
<span class="line-added">116     if (!m_imageBuffer)</span>
<span class="line-added">117         return 0;</span>
<span class="line-added">118     return m_imageBuffer-&gt;externalMemoryCost();</span>
119 }
120 
121 void CanvasBase::addObserver(CanvasObserver&amp; observer)
122 {
123     m_observers.add(&amp;observer);
124 
125     if (is&lt;CSSCanvasValue::CanvasObserverProxy&gt;(observer))
126         InspectorInstrumentation::didChangeCSSCanvasClientNodes(*this);
127 }
128 
129 void CanvasBase::removeObserver(CanvasObserver&amp; observer)
130 {
131     m_observers.remove(&amp;observer);
132 
133     if (is&lt;CSSCanvasValue::CanvasObserverProxy&gt;(observer))
134         InspectorInstrumentation::didChangeCSSCanvasClientNodes(*this);
135 }
136 
137 void CanvasBase::notifyObserversCanvasChanged(const FloatRect&amp; rect)
138 {
139     for (auto&amp; observer : copyToVector(m_observers))
140         observer-&gt;canvasChanged(*this, rect);
141 }
142 
143 void CanvasBase::notifyObserversCanvasResized()
144 {
145     for (auto&amp; observer : copyToVector(m_observers))
146         observer-&gt;canvasResized(*this);
147 }
148 
149 void CanvasBase::notifyObserversCanvasDestroyed()
150 {
151     ASSERT(!m_didNotifyObserversCanvasDestroyed);
152 
153     for (auto&amp; observer : copyToVector(m_observers))
154         observer-&gt;canvasDestroyed(*this);
155 
156     m_observers.clear();
157 
<a name="8" id="anc8"></a><span class="line-modified">158 #if ASSERT_ENABLED</span>
159     m_didNotifyObserversCanvasDestroyed = true;
160 #endif
161 }
162 
163 HashSet&lt;Element*&gt; CanvasBase::cssCanvasClients() const
164 {
165     HashSet&lt;Element*&gt; cssCanvasClients;
166     for (auto&amp; observer : m_observers) {
167         if (!is&lt;CSSCanvasValue::CanvasObserverProxy&gt;(observer))
168             continue;
169 
170         auto clients = downcast&lt;CSSCanvasValue::CanvasObserverProxy&gt;(observer)-&gt;ownerValue().clients();
171         for (auto&amp; entry : clients) {
172             if (RefPtr&lt;Element&gt; element = entry.key-&gt;element())
173                 cssCanvasClients.add(element.get());
174         }
175     }
176     return cssCanvasClients;
177 }
178 
179 bool CanvasBase::callTracingActive() const
180 {
<a name="9" id="anc9"></a><span class="line-modified">181     auto* context = renderingContext();</span>
<span class="line-added">182     return context &amp;&amp; context-&gt;callTracingActive();</span>
<span class="line-added">183 }</span>
<span class="line-added">184 </span>
<span class="line-added">185 std::unique_ptr&lt;ImageBuffer&gt; CanvasBase::setImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer) const</span>
<span class="line-added">186 {</span>
<span class="line-added">187     std::unique_ptr&lt;ImageBuffer&gt; returnBuffer;</span>
<span class="line-added">188     {</span>
<span class="line-added">189         auto locker = holdLock(m_imageBufferAssignmentLock);</span>
<span class="line-added">190         m_contextStateSaver = nullptr;</span>
<span class="line-added">191         returnBuffer = std::exchange(m_imageBuffer, WTFMove(buffer));</span>
<span class="line-added">192     }</span>
<span class="line-added">193 </span>
<span class="line-added">194     if (m_imageBuffer &amp;&amp; m_size != m_imageBuffer-&gt;internalSize())</span>
<span class="line-added">195         m_size = m_imageBuffer-&gt;internalSize();</span>
<span class="line-added">196 </span>
<span class="line-added">197     size_t previousMemoryCost = m_imageBufferCost;</span>
<span class="line-added">198     m_imageBufferCost = memoryCost();</span>
<span class="line-added">199     s_activePixelMemory += m_imageBufferCost - previousMemoryCost;</span>
<span class="line-added">200 </span>
<span class="line-added">201     auto* context = renderingContext();</span>
<span class="line-added">202     if (context &amp;&amp; m_imageBuffer &amp;&amp; previousMemoryCost != m_imageBufferCost)</span>
<span class="line-added">203         InspectorInstrumentation::didChangeCanvasMemory(*context);</span>
<span class="line-added">204 </span>
<span class="line-added">205     if (m_imageBuffer) {</span>
<span class="line-added">206         m_imageBuffer-&gt;context().setShadowsIgnoreTransforms(true);</span>
<span class="line-added">207         m_imageBuffer-&gt;context().setImageInterpolationQuality(defaultInterpolationQuality);</span>
<span class="line-added">208         m_imageBuffer-&gt;context().setStrokeThickness(1);</span>
<span class="line-added">209         m_contextStateSaver = makeUnique&lt;GraphicsContextStateSaver&gt;(m_imageBuffer-&gt;context());</span>
<span class="line-added">210 </span>
<span class="line-added">211         JSC::JSLockHolder lock(scriptExecutionContext()-&gt;vm());</span>
<span class="line-added">212         scriptExecutionContext()-&gt;vm().heap.reportExtraMemoryAllocated(memoryCost());</span>
<span class="line-added">213     }</span>
<span class="line-added">214 </span>
<span class="line-added">215     return returnBuffer;</span>
<span class="line-added">216 }</span>
<span class="line-added">217 </span>
<span class="line-added">218 size_t CanvasBase::activePixelMemory()</span>
<span class="line-added">219 {</span>
<span class="line-added">220     return s_activePixelMemory.load();</span>
<span class="line-added">221 }</span>
<span class="line-added">222 </span>
<span class="line-added">223 void CanvasBase::resetGraphicsContextState() const</span>
<span class="line-added">224 {</span>
<span class="line-added">225     if (m_contextStateSaver) {</span>
<span class="line-added">226         // Reset to the initial graphics context state.</span>
<span class="line-added">227         m_contextStateSaver-&gt;restore();</span>
<span class="line-added">228         m_contextStateSaver-&gt;save();</span>
<span class="line-added">229     }</span>
230 }
231 
232 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
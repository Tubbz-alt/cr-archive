diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBCursor.h b/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBCursor.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBCursor.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBCursor.h
@@ -42,12 +42,10 @@
 class IDBCursorInfo;
 class IDBGetResult;
 
 namespace IDBServer {
 
-enum class ShouldFetchForSameKey : bool { No, Yes };
-
 class SQLiteIDBTransaction;
 
 class SQLiteIDBCursor {
     WTF_MAKE_FAST_ALLOCATED;
     WTF_MAKE_NONCOPYABLE(SQLiteIDBCursor);
@@ -66,37 +64,40 @@
     int64_t objectStoreID() const { return m_objectStoreID; }
     int64_t currentRecordRowID() const;
 
     const IDBKeyData& currentKey() const;
     const IDBKeyData& currentPrimaryKey() const;
-    IDBValue* currentValue() const;
+    const IDBValue& currentValue() const;
 
     bool advance(uint64_t count);
     bool iterate(const IDBKeyData& targetKey, const IDBKeyData& targetPrimaryKey);
+    bool prefetchOneRecord();
     bool prefetch();
 
     bool didComplete() const;
     bool didError() const;
 
     void objectStoreRecordsChanged();
 
-    void currentData(IDBGetResult&, const Optional<IDBKeyPath>&);
+    enum class ShouldIncludePrefetchedRecords { No, Yes };
+    void currentData(IDBGetResult&, const Optional<IDBKeyPath>&, ShouldIncludePrefetchedRecords = ShouldIncludePrefetchedRecords::No);
 
 private:
     bool establishStatement();
     bool createSQLiteStatement(const String& sql);
     bool bindArguments();
 
+    bool resetAndRebindPreIndexStatementIfNecessary();
     void resetAndRebindStatement();
 
     enum class FetchResult {
         Success,
         Failure,
         ShouldFetchAgain
     };
 
-    bool fetch(ShouldFetchForSameKey = ShouldFetchForSameKey::No);
+    bool fetch();
 
     struct SQLiteCursorRecord {
         IDBCursorRecord record;
         bool completed { false };
         bool errored { false };
@@ -106,29 +107,40 @@
     bool fetchNextRecord(SQLiteCursorRecord&);
     FetchResult internalFetchNextRecord(SQLiteCursorRecord&);
 
     void markAsErrored(SQLiteCursorRecord&);
 
+    bool isDirectionNext() const { return m_cursorDirection == IndexedDB::CursorDirection::Next || m_cursorDirection == IndexedDB::CursorDirection::Nextunique; }
+
+    void increaseCountToPrefetch();
+
     SQLiteIDBTransaction* m_transaction;
     IDBResourceIdentifier m_cursorIdentifier;
     int64_t m_objectStoreID;
     int64_t m_indexID { IDBIndexInfo::InvalidId };
     IndexedDB::CursorDirection m_cursorDirection { IndexedDB::CursorDirection::Next };
     IndexedDB::CursorType m_cursorType;
     IDBKeyRangeData m_keyRange;
 
     IDBKeyData m_currentLowerKey;
     IDBKeyData m_currentUpperKey;
+    IDBKeyData m_currentIndexRecordValue;
 
     Deque<SQLiteCursorRecord> m_fetchedRecords;
+    uint64_t m_fetchedRecordsSize { 0 };
     IDBKeyData m_currentKeyForUniqueness;
 
+    std::unique_ptr<SQLiteStatement> m_preIndexStatement;
     std::unique_ptr<SQLiteStatement> m_statement;
+    std::unique_ptr<SQLiteStatement> m_cachedObjectStoreStatement;
+
     bool m_statementNeedsReset { true };
     int64_t m_boundID { 0 };
 
     bool m_backingStoreCursor { false };
+
+    unsigned m_prefetchCount { 0 };
 };
 
 } // namespace IDBServer
 } // namespace WebCore
 

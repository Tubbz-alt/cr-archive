diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArrayInlines.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArrayInlines.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArrayInlines.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArrayInlines.h
@@ -1,7 +1,7 @@
 /*
- *  Copyright (C) 2016 Apple Inc. All rights reserved.
+ *  Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  *
  *  This library is free software; you can redistribute it and/or
  *  modify it under the terms of the GNU Lesser General Public
  *  License as published by the Free Software Foundation; either
  *  version 2 of the License, or (at your option) any later version.
@@ -18,10 +18,11 @@
  */
 
 #pragma once
 
 #include "ArrayPrototype.h"
+#include "ButterflyInlines.h"
 #include "Error.h"
 #include "JSArray.h"
 #include "JSCellInlines.h"
 #include "Structure.h"
 
@@ -89,25 +90,25 @@
         return false;
 
     return true;
 }
 
-ALWAYS_INLINE double toLength(ExecState* exec, JSObject* obj)
+ALWAYS_INLINE double toLength(JSGlobalObject* globalObject, JSObject* obj)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     if (LIKELY(isJSArray(obj)))
         return jsCast<JSArray*>(obj)->length();
 
-    JSValue lengthValue = obj->get(exec, vm.propertyNames->length);
+    JSValue lengthValue = obj->get(globalObject, vm.propertyNames->length);
     RETURN_IF_EXCEPTION(scope, PNaN);
-    RELEASE_AND_RETURN(scope, lengthValue.toLength(exec));
+    RELEASE_AND_RETURN(scope, lengthValue.toLength(globalObject));
 }
 
-ALWAYS_INLINE void JSArray::pushInline(ExecState* exec, JSValue value)
+ALWAYS_INLINE void JSArray::pushInline(JSGlobalObject* globalObject, JSValue value)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     ensureWritable(vm);
 
     Butterfly* butterfly = this->butterfly();
@@ -119,19 +120,19 @@
     }
 
     case ArrayWithUndecided: {
         convertUndecidedForValue(vm, value);
         scope.release();
-        push(exec, value);
+        push(globalObject, value);
         return;
     }
 
     case ArrayWithInt32: {
         if (!value.isInt32()) {
             convertInt32ForValue(vm, value);
             scope.release();
-            push(exec, value);
+            push(globalObject, value);
             return;
         }
 
         unsigned length = butterfly->publicLength();
         ASSERT(length <= butterfly->vectorLength());
@@ -140,54 +141,55 @@
             butterfly->setPublicLength(length + 1);
             return;
         }
 
         if (UNLIKELY(length > MAX_ARRAY_INDEX)) {
-            methodTable(vm)->putByIndex(this, exec, length, value, true);
+            methodTable(vm)->putByIndex(this, globalObject, length, value, true);
             if (!scope.exception())
-                throwException(exec, scope, createRangeError(exec, LengthExceededTheMaximumArrayLengthError));
+                throwException(globalObject, scope, createRangeError(globalObject, LengthExceededTheMaximumArrayLengthError));
             return;
         }
 
         scope.release();
-        putByIndexBeyondVectorLengthWithoutAttributes<Int32Shape>(exec, length, value);
+        putByIndexBeyondVectorLengthWithoutAttributes<Int32Shape>(globalObject, length, value);
         return;
     }
 
     case ArrayWithContiguous: {
         unsigned length = butterfly->publicLength();
         ASSERT(length <= butterfly->vectorLength());
         if (length < butterfly->vectorLength()) {
-            butterfly->contiguous().at(this, length).set(vm, this, value);
+            butterfly->contiguous().at(this, length).setWithoutWriteBarrier(value);
             butterfly->setPublicLength(length + 1);
+            vm.heap.writeBarrier(this, value);
             return;
         }
 
         if (UNLIKELY(length > MAX_ARRAY_INDEX)) {
-            methodTable(vm)->putByIndex(this, exec, length, value, true);
+            methodTable(vm)->putByIndex(this, globalObject, length, value, true);
             if (!scope.exception())
-                throwException(exec, scope, createRangeError(exec, LengthExceededTheMaximumArrayLengthError));
+                throwException(globalObject, scope, createRangeError(globalObject, LengthExceededTheMaximumArrayLengthError));
             return;
         }
 
         scope.release();
-        putByIndexBeyondVectorLengthWithoutAttributes<ContiguousShape>(exec, length, value);
+        putByIndexBeyondVectorLengthWithoutAttributes<ContiguousShape>(globalObject, length, value);
         return;
     }
 
     case ArrayWithDouble: {
         if (!value.isNumber()) {
             convertDoubleToContiguous(vm);
             scope.release();
-            push(exec, value);
+            push(globalObject, value);
             return;
         }
         double valueAsDouble = value.asNumber();
         if (valueAsDouble != valueAsDouble) {
             convertDoubleToContiguous(vm);
             scope.release();
-            push(exec, value);
+            push(globalObject, value);
             return;
         }
 
         unsigned length = butterfly->publicLength();
         ASSERT(length <= butterfly->vectorLength());
@@ -196,30 +198,30 @@
             butterfly->setPublicLength(length + 1);
             return;
         }
 
         if (UNLIKELY(length > MAX_ARRAY_INDEX)) {
-            methodTable(vm)->putByIndex(this, exec, length, value, true);
+            methodTable(vm)->putByIndex(this, globalObject, length, value, true);
             if (!scope.exception())
-                throwException(exec, scope, createRangeError(exec, LengthExceededTheMaximumArrayLengthError));
+                throwException(globalObject, scope, createRangeError(globalObject, LengthExceededTheMaximumArrayLengthError));
             return;
         }
 
         scope.release();
-        putByIndexBeyondVectorLengthWithoutAttributes<DoubleShape>(exec, length, value);
+        putByIndexBeyondVectorLengthWithoutAttributes<DoubleShape>(globalObject, length, value);
         return;
     }
 
     case ArrayWithSlowPutArrayStorage: {
         unsigned oldLength = length();
         bool putResult = false;
-        bool result = attemptToInterceptPutByIndexOnHole(exec, oldLength, value, true, putResult);
+        bool result = attemptToInterceptPutByIndexOnHole(globalObject, oldLength, value, true, putResult);
         RETURN_IF_EXCEPTION(scope, void());
         if (result) {
             if (oldLength < 0xFFFFFFFFu) {
                 scope.release();
-                setLength(exec, oldLength + 1, true);
+                setLength(globalObject, oldLength + 1, true);
             }
             return;
         }
         FALLTHROUGH;
     }
@@ -236,20 +238,20 @@
             return;
         }
 
         // Pushing to an array of invalid length (2^31-1) stores the property, but throws a range error.
         if (UNLIKELY(storage->length() > MAX_ARRAY_INDEX)) {
-            methodTable(vm)->putByIndex(this, exec, storage->length(), value, true);
+            methodTable(vm)->putByIndex(this, globalObject, storage->length(), value, true);
             // Per ES5.1 15.4.4.7 step 6 & 15.4.5.1 step 3.d.
             if (!scope.exception())
-                throwException(exec, scope, createRangeError(exec, LengthExceededTheMaximumArrayLengthError));
+                throwException(globalObject, scope, createRangeError(globalObject, LengthExceededTheMaximumArrayLengthError));
             return;
         }
 
         // Handled the same as putIndex.
         scope.release();
-        putByIndexBeyondVectorLengthWithArrayStorage(exec, storage->length(), value, true, storage);
+        putByIndexBeyondVectorLengthWithArrayStorage(globalObject, storage->length(), value, true, storage);
         return;
     }
 
     default:
         RELEASE_ASSERT_NOT_REACHED();

diff a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/SmallPage.h b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/SmallPage.h
--- a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/SmallPage.h
+++ b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/SmallPage.h
@@ -36,36 +36,40 @@
 
 class SmallLine;
 
 class SmallPage : public ListNode<SmallPage> {
 public:
-    void ref(std::unique_lock<Mutex>&);
-    bool deref(std::unique_lock<Mutex>&);
-    unsigned refCount(std::unique_lock<Mutex>&) { return m_refCount; }
+    void ref(UniqueLockHolder&);
+    bool deref(UniqueLockHolder&);
+    unsigned refCount(UniqueLockHolder&) { return m_refCount; }
 
     size_t sizeClass() { return m_sizeClass; }
     void setSizeClass(size_t sizeClass) { m_sizeClass = sizeClass; }
 
-    bool hasFreeLines(std::unique_lock<Mutex>&) const { return m_hasFreeLines; }
-    void setHasFreeLines(std::unique_lock<Mutex>&, bool hasFreeLines) { m_hasFreeLines = hasFreeLines; }
+    bool hasFreeLines(UniqueLockHolder&) const { return m_hasFreeLines; }
+    void setHasFreeLines(UniqueLockHolder&, bool hasFreeLines) { m_hasFreeLines = hasFreeLines; }
 
     bool hasPhysicalPages() { return m_hasPhysicalPages; }
     void setHasPhysicalPages(bool hasPhysicalPages) { m_hasPhysicalPages = hasPhysicalPages; }
 
+#if !BUSE(PARTIAL_SCAVENGE)
     bool usedSinceLastScavenge() { return m_usedSinceLastScavenge; }
     void clearUsedSinceLastScavenge() { m_usedSinceLastScavenge = false; }
     void setUsedSinceLastScavenge() { m_usedSinceLastScavenge = true; }
+#endif
 
     SmallLine* begin();
 
     unsigned char slide() const { return m_slide; }
     void setSlide(unsigned char slide) { m_slide = slide; }
 
 private:
     unsigned char m_hasFreeLines: 1;
     unsigned char m_hasPhysicalPages: 1;
+#if !BUSE(PARTIAL_SCAVENGE)
     unsigned char m_usedSinceLastScavenge: 1;
+#endif
     unsigned char m_refCount: 7;
     unsigned char m_sizeClass;
     unsigned char m_slide;
 
 static_assert(
@@ -73,18 +77,18 @@
     "Largest size class must fit in SmallPage metadata");
 };
 
 using LineCache = std::array<List<SmallPage>, sizeClassCount>;
 
-inline void SmallPage::ref(std::unique_lock<Mutex>&)
+inline void SmallPage::ref(UniqueLockHolder&)
 {
     BASSERT(!m_slide);
     ++m_refCount;
     BASSERT(m_refCount);
 }
 
-inline bool SmallPage::deref(std::unique_lock<Mutex>&)
+inline bool SmallPage::deref(UniqueLockHolder&)
 {
     BASSERT(!m_slide);
     BASSERT(m_refCount);
     --m_refCount;
     return !m_refCount;

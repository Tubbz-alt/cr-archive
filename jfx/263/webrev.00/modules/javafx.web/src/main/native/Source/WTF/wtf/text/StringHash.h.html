<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringHash.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006-2019 Apple Inc. All rights reserved
  3  * Copyright (C) Research In Motion Limited 2009. All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &lt;wtf/HashTraits.h&gt;
 25 #include &lt;wtf/text/AtomString.h&gt;
 26 #include &lt;wtf/text/StringHasher.h&gt;
 27 
 28 namespace WTF {
 29 
 30     inline bool HashTraits&lt;String&gt;::isEmptyValue(const String&amp; value)
 31     {
 32         return value.isNull();
 33     }
 34 
 35     inline void HashTraits&lt;String&gt;::customDeleteBucket(String&amp; value)
 36     {
 37         // See unique_ptr&#39;s customDeleteBucket() for an explanation.
 38         ASSERT(!isDeletedValue(value));
 39         String valueToBeDestroyed = WTFMove(value);
 40         constructDeletedValue(value);
 41     }
 42 
 43     // The hash() functions on StringHash and ASCIICaseInsensitiveHash do not support
 44     // null strings. get(), contains(), and add() on HashMap&lt;String,..., StringHash&gt;
 45     // cause a null-pointer dereference when passed null strings.
 46 
 47     // FIXME: We should really figure out a way to put the computeHash function that&#39;s
 48     // currently a member function of StringImpl into this file so we can be a little
 49     // closer to having all the nearly-identical hash functions in one place.
 50 
 51     struct StringHash {
 52         static unsigned hash(StringImpl* key) { return key-&gt;hash(); }
 53         static inline bool equal(const StringImpl* a, const StringImpl* b)
 54         {
 55             return WTF::equal(*a, *b);
 56         }
 57 
 58         static unsigned hash(const RefPtr&lt;StringImpl&gt;&amp; key) { return key-&gt;hash(); }
 59         static unsigned hash(const PackedPtr&lt;StringImpl&gt;&amp; key) { return key-&gt;hash(); }
 60         static bool equal(const RefPtr&lt;StringImpl&gt;&amp; a, const RefPtr&lt;StringImpl&gt;&amp; b)
 61         {
 62             return equal(a.get(), b.get());
 63         }
 64         static bool equal(const RefPtr&lt;StringImpl&gt;&amp; a, const StringImpl* b)
 65         {
 66             return equal(a.get(), b);
 67         }
 68         static bool equal(const StringImpl* a, const RefPtr&lt;StringImpl&gt;&amp; b)
 69         {
 70             return equal(a, b.get());
 71         }
 72 
 73         static bool equal(const PackedPtr&lt;StringImpl&gt;&amp; a, const PackedPtr&lt;StringImpl&gt;&amp; b)
 74         {
 75             return equal(a.get(), b.get());
 76         }
 77         static bool equal(const PackedPtr&lt;StringImpl&gt;&amp; a, const StringImpl* b)
 78         {
 79             return equal(a.get(), b);
 80         }
 81         static bool equal(const StringImpl* a, const PackedPtr&lt;StringImpl&gt;&amp; b)
 82         {
 83             return equal(a, b.get());
 84         }
 85 
 86         static unsigned hash(const String&amp; key) { return key.impl()-&gt;hash(); }
 87         static bool equal(const String&amp; a, const String&amp; b)
 88         {
 89             return equal(a.impl(), b.impl());
 90         }
 91 
 92         static constexpr bool safeToCompareToEmptyOrDeleted = false;
 93     };
 94 
 95     struct ASCIICaseInsensitiveHash {
 96         template&lt;typename T&gt;
 97         struct FoldCase {
 98             static inline UChar convert(T character)
 99             {
100                 return toASCIILower(character);
101             }
102         };
103 
104         static unsigned hash(const UChar* data, unsigned length)
105         {
106             return StringHasher::computeHashAndMaskTop8Bits&lt;UChar, FoldCase&lt;UChar&gt;&gt;(data, length);
107         }
108 
109         static unsigned hash(StringImpl&amp; string)
110         {
111             if (string.is8Bit())
112                 return hash(string.characters8(), string.length());
113             return hash(string.characters16(), string.length());
114         }
115         static unsigned hash(StringImpl* string)
116         {
117             ASSERT(string);
118             return hash(*string);
119         }
120 
121         static unsigned hash(const LChar* data, unsigned length)
122         {
123             return StringHasher::computeHashAndMaskTop8Bits&lt;LChar, FoldCase&lt;LChar&gt;&gt;(data, length);
124         }
125 
126         static inline unsigned hash(const char* data, unsigned length)
127         {
128             return hash(reinterpret_cast&lt;const LChar*&gt;(data), length);
129         }
130 
131         static inline bool equal(const StringImpl&amp; a, const StringImpl&amp; b)
132         {
133             return equalIgnoringASCIICase(a, b);
134         }
135         static inline bool equal(const StringImpl* a, const StringImpl* b)
136         {
137             ASSERT(a);
138             ASSERT(b);
139             return equal(*a, *b);
140         }
141 
142         static unsigned hash(const RefPtr&lt;StringImpl&gt;&amp; key)
143         {
144             return hash(key.get());
145         }
146 
147         static bool equal(const RefPtr&lt;StringImpl&gt;&amp; a, const RefPtr&lt;StringImpl&gt;&amp; b)
148         {
149             return equal(a.get(), b.get());
150         }
151 
152         static unsigned hash(const PackedPtr&lt;StringImpl&gt;&amp; key)
153         {
154             return hash(key.get());
155         }
156 
157         static bool equal(const PackedPtr&lt;StringImpl&gt;&amp; a, const PackedPtr&lt;StringImpl&gt;&amp; b)
158         {
159             return equal(a.get(), b.get());
160         }
161 
162         static unsigned hash(const String&amp; key)
163         {
164             return hash(key.impl());
165         }
166         static unsigned hash(const AtomString&amp; key)
167         {
168             return hash(key.impl());
169         }
170         static bool equal(const String&amp; a, const String&amp; b)
171         {
172             return equal(a.impl(), b.impl());
173         }
174         static bool equal(const AtomString&amp; a, const AtomString&amp; b)
175         {
176             // FIXME: Is the &quot;a == b&quot; here a helpful optimization?
177             // It makes all cases where the strings are not identical slightly slower.
178             return a == b || equal(a.impl(), b.impl());
179         }
180 
181         static constexpr bool safeToCompareToEmptyOrDeleted = false;
182     };
183 
184     // This hash can be used in cases where the key is a hash of a string, but we don&#39;t
185     // want to store the string. It&#39;s not really specific to string hashing, but all our
186     // current uses of it are for strings.
187     struct AlreadyHashed : IntHash&lt;unsigned&gt; {
188         static unsigned hash(unsigned key) { return key; }
189 
190         // To use a hash value as a key for a hash table, we need to eliminate the
191         // &quot;deleted&quot; value, which is negative one. That could be done by changing
192         // the string hash function to never generate negative one, but this works
193         // and is still relatively efficient.
194         static unsigned avoidDeletedValue(unsigned hash)
195         {
196             ASSERT(hash);
197             unsigned newHash = hash | (!(hash + 1) &lt;&lt; 31);
198             ASSERT(newHash);
199             ASSERT(newHash != 0xFFFFFFFF);
200             return newHash;
201         }
202     };
203 
204     // FIXME: Find a way to incorporate this functionality into ASCIICaseInsensitiveHash and allow
205     // a HashMap whose keys are type String to perform operations when given a key of type StringView.
206     struct ASCIICaseInsensitiveStringViewHashTranslator {
207         static unsigned hash(StringView key)
208         {
209             if (key.is8Bit())
210                 return ASCIICaseInsensitiveHash::hash(key.characters8(), key.length());
211             return ASCIICaseInsensitiveHash::hash(key.characters16(), key.length());
212         }
213 
214         static bool equal(const String&amp; a, StringView b)
215         {
216             return equalIgnoringASCIICaseCommon(a, b);
217         }
218     };
219 
220 }
221 
222 using WTF::ASCIICaseInsensitiveHash;
223 using WTF::ASCIICaseInsensitiveStringViewHashTranslator;
224 using WTF::AlreadyHashed;
225 using WTF::StringHash;
    </pre>
  </body>
</html>
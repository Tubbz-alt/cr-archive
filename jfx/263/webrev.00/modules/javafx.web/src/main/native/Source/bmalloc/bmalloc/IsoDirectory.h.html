<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoDirectory.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;Bits.h&quot;
 29 #include &quot;EligibilityResult.h&quot;
 30 #include &quot;IsoPage.h&quot;
 31 #include &quot;Packed.h&quot;
 32 #include &quot;Vector.h&quot;
 33 
 34 namespace bmalloc {
 35 
 36 template&lt;typename Config&gt; class IsoHeapImpl;
 37 
 38 class IsoDirectoryBaseBase {
 39 public:
 40     IsoDirectoryBaseBase() { }
 41     virtual ~IsoDirectoryBaseBase() { }
 42 
 43     virtual void didDecommit(unsigned index) = 0;
 44 };
 45 
 46 template&lt;typename Config&gt;
 47 class IsoDirectoryBase : public IsoDirectoryBaseBase {
 48 public:
 49     IsoDirectoryBase(IsoHeapImpl&lt;Config&gt;&amp;);
 50 
 51     IsoHeapImpl&lt;Config&gt;&amp; heap() { return m_heap; }
 52 
 53     virtual void didBecome(const LockHolder&amp;, IsoPage&lt;Config&gt;*, IsoPageTrigger) = 0;
 54 
 55 protected:
 56     IsoHeapImpl&lt;Config&gt;&amp; m_heap;
 57 };
 58 
 59 template&lt;typename Config, unsigned passedNumPages&gt;
 60 class IsoDirectory : public IsoDirectoryBase&lt;Config&gt; {
 61 public:
 62     static constexpr unsigned numPages = passedNumPages;
 63 
 64     IsoDirectory(IsoHeapImpl&lt;Config&gt;&amp;);
 65 
 66     // Find the first page that is eligible for allocation and return it. May return null if there is no
 67     // such thing. May allocate a new page if we have an uncommitted page.
 68     EligibilityResult&lt;Config&gt; takeFirstEligible(const LockHolder&amp;);
 69 
 70     void didBecome(const LockHolder&amp;, IsoPage&lt;Config&gt;*, IsoPageTrigger) override;
 71 
 72     // This gets called from a bulk decommit function in the Scavenger, so no locks are held. This function
 73     // needs to get the heap lock.
 74     void didDecommit(unsigned index) override;
 75 
 76     // Iterate over all empty and committed pages, and put them into the vector. This also records the
 77     // pages as being decommitted. It&#39;s the caller&#39;s job to do the actual decommitting.
 78     void scavenge(const LockHolder&amp;, Vector&lt;DeferredDecommit&gt;&amp;);
 79 #if BUSE(PARTIAL_SCAVENGE)
 80     void scavengeToHighWatermark(const LockHolder&amp;, Vector&lt;DeferredDecommit&gt;&amp;);
 81 #endif
 82 
 83     template&lt;typename Func&gt;
 84     void forEachCommittedPage(const LockHolder&amp;, const Func&amp;);
 85 
 86 private:
 87     void scavengePage(const LockHolder&amp;, size_t, Vector&lt;DeferredDecommit&gt;&amp;);
 88 
 89     std::array&lt;PackedAlignedPtr&lt;IsoPage&lt;Config&gt;, IsoPage&lt;Config&gt;::pageSize&gt;, numPages&gt; m_pages { };
 90     // NOTE: I suppose that this could be two bitvectors. But from working on the GC, I found that the
 91     // number of bitvectors does not matter as much as whether or not they make intuitive sense.
 92     Bits&lt;numPages&gt; m_eligible;
 93     Bits&lt;numPages&gt; m_empty;
 94     Bits&lt;numPages&gt; m_committed;
 95     unsigned m_firstEligibleOrDecommitted { 0 };
 96 #if BUSE(PARTIAL_SCAVENGE)
 97     unsigned m_highWatermark { 0 };
 98 #endif
 99 };
100 
101 } // namespace bmalloc
102 
    </pre>
  </body>
</html>
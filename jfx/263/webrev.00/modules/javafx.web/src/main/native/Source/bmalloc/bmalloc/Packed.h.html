<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Packed.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019-2020 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;Algorithm.h&quot;
 29 #include &quot;StdLibExtras.h&quot;
 30 #include &lt;array&gt;
 31 
 32 namespace bmalloc {
 33 
 34 template&lt;typename T&gt;
 35 class Packed {
 36 public:
 37     static_assert(std::is_trivial&lt;T&gt;::value);
 38     static constexpr bool isPackedType = true;
 39 
 40     Packed()
 41         : Packed(T { })
 42     {
 43     }
 44 
 45     Packed(const T&amp; value)
 46     {
 47         memcpy(m_storage.data(), &amp;value, sizeof(T));
 48     }
 49 
 50     T get() const
 51     {
 52         T value { };
 53         memcpy(&amp;value, m_storage.data(), sizeof(T));
 54         return value;
 55     }
 56 
 57     void set(const T&amp; value)
 58     {
 59         memcpy(m_storage.data(), &amp;value, sizeof(T));
 60     }
 61 
 62     Packed&lt;T&gt;&amp; operator=(const T&amp; value)
 63     {
 64         set(value);
 65         return *this;
 66     }
 67 
 68     template&lt;class U&gt;
 69     T exchange(U&amp;&amp; newValue)
 70     {
 71         T oldValue = get();
 72         set(std::forward&lt;U&gt;(newValue));
 73         return oldValue;
 74     }
 75 
 76     void swap(Packed&amp; other)
 77     {
 78         m_storage.swap(other.m_storage);
 79     }
 80 
 81     template&lt;typename Other, typename = std::enable_if_t&lt;Other::isPackedType&gt;&gt;
 82     void swap(Other&amp; other)
 83     {
 84         T t1 = get();
 85         T t2 = other.get();
 86         set(t2);
 87         other.set(t1);
 88     }
 89 
 90     void swap(T&amp; t2)
 91     {
 92         T t1 = get();
 93         std::swap(t1, t2);
 94         set(t1);
 95     }
 96 
 97 private:
 98     std::array&lt;uint8_t, sizeof(T)&gt; m_storage;
 99 };
100 
101 // PackedAlignedPtr can take alignment parameter too. PackedAlignedPtr only uses this alignment information if it is profitable: we use
102 // alignment information only when we can reduce the size of the storage. Since the pointer width is 36 bits and JSCells are aligned to 16 bytes,
103 // we can use 4 bits in Darwin ARM64, we can compact cell pointer into 4 bytes (32 bits).
104 template&lt;typename T, size_t alignment = alignof(T)&gt;
105 class PackedAlignedPtr {
106 public:
107     static_assert(isPowerOfTwo(alignment), &quot;Alignment needs to be power-of-two&quot;);
108     static constexpr bool isPackedType = true;
109     static constexpr unsigned alignmentShiftSizeIfProfitable = getLSBSetNonZeroConstexpr(alignment);
110     static constexpr unsigned storageSizeWithoutAlignmentShift = roundUpToMultipleOf&lt;8, uintptr_t&gt;(BOS_EFFECTIVE_ADDRESS_WIDTH) / 8;
111     static constexpr unsigned storageSizeWithAlignmentShift = roundUpToMultipleOf&lt;8, uintptr_t&gt;(BOS_EFFECTIVE_ADDRESS_WIDTH - alignmentShiftSizeIfProfitable) / 8;
112     static constexpr bool isAlignmentShiftProfitable = storageSizeWithoutAlignmentShift &gt; storageSizeWithAlignmentShift;
113     static constexpr unsigned alignmentShiftSize = isAlignmentShiftProfitable ? alignmentShiftSizeIfProfitable : 0;
114     static constexpr unsigned storageSize = storageSizeWithAlignmentShift;
115 
116     constexpr PackedAlignedPtr()
117         : m_storage()
118     {
119     }
120 
121     constexpr PackedAlignedPtr(std::nullptr_t)
122         : m_storage()
123     {
124     }
125 
126     PackedAlignedPtr(T* value)
127     {
128         set(value);
129     }
130 
131     T* get() const
132     {
133         // FIXME: PackedPtr&lt;&gt; can load memory with one mov by checking page boundary.
134         // https://bugs.webkit.org/show_bug.cgi?id=197754
135         uintptr_t value = 0;
136 #if BCPU(LITTLE_ENDIAN)
137         memcpy(&amp;value, m_storage.data(), storageSize);
138 #else
139         memcpy(bitwise_cast&lt;uint8_t*&gt;(&amp;value) + (sizeof(void*) - storageSize), m_storage.data(), storageSize);
140 #endif
141         if (isAlignmentShiftProfitable)
142             value &lt;&lt;= alignmentShiftSize;
143         return bitwise_cast&lt;T*&gt;(value);
144     }
145 
146     void set(T* passedValue)
147     {
148         uintptr_t value = bitwise_cast&lt;uintptr_t&gt;(passedValue);
149         if (isAlignmentShiftProfitable)
150             value &gt;&gt;= alignmentShiftSize;
151 #if BCPU(LITTLE_ENDIAN)
152         memcpy(m_storage.data(), &amp;value, storageSize);
153 #else
154         memcpy(m_storage.data(), bitwise_cast&lt;uint8_t*&gt;(&amp;value) + (sizeof(void*) - storageSize), storageSize);
155 #endif
156     }
157 
158     void clear()
159     {
160         set(nullptr);
161     }
162 
163     T* operator-&gt;() const { return get(); }
164     T&amp; operator*() const { return *get(); }
165     bool operator!() const { return !get(); }
166 
167     // This conversion operator allows implicit conversion to bool but not to other integer types.
168     typedef T* (PackedAlignedPtr::*UnspecifiedBoolType);
169     operator UnspecifiedBoolType() const { return get() ? &amp;PackedAlignedPtr::m_storage : nullptr; }
170     explicit operator bool() const { return get(); }
171 
172     PackedAlignedPtr&amp; operator=(T* value)
173     {
174         set(value);
175         return *this;
176     }
177 
178     template&lt;class U&gt;
179     T* exchange(U&amp;&amp; newValue)
180     {
181         T* oldValue = get();
182         set(std::forward&lt;U&gt;(newValue));
183         return oldValue;
184     }
185 
186     void swap(std::nullptr_t) { clear(); }
187 
188     void swap(PackedAlignedPtr&amp; other)
189     {
190         m_storage.swap(other.m_storage);
191     }
192 
193     template&lt;typename Other, typename = std::enable_if_t&lt;Other::isPackedType&gt;&gt;
194     void swap(Other&amp; other)
195     {
196         T* t1 = get();
197         T* t2 = other.get();
198         set(t2);
199         other.set(t1);
200     }
201 
202     void swap(T* t2)
203     {
204         T* t1 = get();
205         std::swap(t1, t2);
206         set(t1);
207     }
208 
209 private:
210     std::array&lt;uint8_t, storageSize&gt; m_storage;
211 };
212 
213 template&lt;typename T&gt;
214 class Packed&lt;T*&gt; : public PackedAlignedPtr&lt;T, 1&gt; {
215 public:
216     using Base = PackedAlignedPtr&lt;T, 1&gt;;
217     using Base::Base;
218 };
219 
220 template&lt;typename T&gt;
221 using PackedPtr = Packed&lt;T*&gt;;
222 
223 template&lt;typename T&gt;
224 struct PackedPtrTraits {
225     template&lt;typename U&gt; using RebindTraits = PackedPtrTraits&lt;U&gt;;
226 
227     using StorageType = PackedPtr&lt;T&gt;;
228 
229     template&lt;class U&gt; static T* exchange(StorageType&amp; ptr, U&amp;&amp; newValue) { return ptr.exchange(newValue); }
230 
231     template&lt;typename Other&gt; static void swap(PackedPtr&lt;T&gt;&amp; a, Other&amp; b) { a.swap(b); }
232 
233     static T* unwrap(const StorageType&amp; ptr) { return ptr.get(); }
234 };
235 
236 } // namespace bmalloc
    </pre>
  </body>
</html>
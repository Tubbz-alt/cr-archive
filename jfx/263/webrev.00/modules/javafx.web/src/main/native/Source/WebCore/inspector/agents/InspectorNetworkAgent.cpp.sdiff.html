<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorNetworkAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorMemoryAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorNetworkAgent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorNetworkAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 2011 Google Inc. All rights reserved.
<span class="line-modified">   3  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.</span>
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions are
   7  * met:
   8  *
   9  *     * Redistributions of source code must retain the above copyright
  10  * notice, this list of conditions and the following disclaimer.
  11  *     * Redistributions in binary form must reproduce the above
  12  * copyright notice, this list of conditions and the following disclaimer
  13  * in the documentation and/or other materials provided with the
  14  * distribution.
  15  *     * Neither the name of Google Inc. nor the names of its
  16  * contributors may be used to endorse or promote products derived from
  17  * this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</pre>
<hr />
<pre>
  46 #include &quot;Frame.h&quot;
  47 #include &quot;FrameLoader.h&quot;
  48 #include &quot;HTTPHeaderMap.h&quot;
  49 #include &quot;HTTPHeaderNames.h&quot;
  50 #include &quot;InspectorDOMAgent.h&quot;
  51 #include &quot;InspectorTimelineAgent.h&quot;
  52 #include &quot;InstrumentingAgents.h&quot;
  53 #include &quot;JSExecState.h&quot;
  54 #include &quot;JSWebSocket.h&quot;
  55 #include &quot;LoaderStrategy.h&quot;
  56 #include &quot;MIMETypeRegistry.h&quot;
  57 #include &quot;MemoryCache.h&quot;
  58 #include &quot;NetworkResourcesData.h&quot;
  59 #include &quot;Page.h&quot;
  60 #include &quot;PlatformStrategies.h&quot;
  61 #include &quot;ProgressTracker.h&quot;
  62 #include &quot;ResourceError.h&quot;
  63 #include &quot;ResourceLoader.h&quot;
  64 #include &quot;ResourceRequest.h&quot;
  65 #include &quot;ResourceResponse.h&quot;
<span class="line-removed">  66 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
  67 #include &quot;ScriptState.h&quot;
  68 #include &quot;ScriptableDocumentParser.h&quot;
  69 #include &quot;SubresourceLoader.h&quot;
  70 #include &quot;TextResourceDecoder.h&quot;
  71 #include &quot;ThreadableLoaderClient.h&quot;
  72 #include &lt;wtf/URL.h&gt;
  73 #include &quot;WebSocket.h&quot;
  74 #include &quot;WebSocketChannel.h&quot;
  75 #include &quot;WebSocketFrame.h&quot;
  76 #include &lt;JavaScriptCore/ContentSearchUtilities.h&gt;
  77 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
  78 #include &lt;JavaScriptCore/InjectedScript.h&gt;
  79 #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;

  80 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  81 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
  82 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;


  83 #include &lt;wtf/JSONValues.h&gt;
  84 #include &lt;wtf/Lock.h&gt;
  85 #include &lt;wtf/RefPtr.h&gt;
  86 #include &lt;wtf/Stopwatch.h&gt;
  87 #include &lt;wtf/persistence/PersistentEncoder.h&gt;
  88 #include &lt;wtf/text/Base64.h&gt;
  89 #include &lt;wtf/text/StringBuilder.h&gt;

  90 
  91 typedef Inspector::NetworkBackendDispatcherHandler::LoadResourceCallback LoadResourceCallback;
  92 
  93 namespace WebCore {
  94 
  95 using namespace Inspector;
  96 
  97 namespace {
  98 
  99 class InspectorThreadableLoaderClient final : public ThreadableLoaderClient {
 100     WTF_MAKE_NONCOPYABLE(InspectorThreadableLoaderClient);
 101 public:
 102     InspectorThreadableLoaderClient(RefPtr&lt;LoadResourceCallback&gt;&amp;&amp; callback)
 103         : m_callback(WTFMove(callback))
 104     {
 105     }
 106 
<span class="line-modified"> 107     virtual ~InspectorThreadableLoaderClient() = default;</span>
 108 
 109     void didReceiveResponse(unsigned long, const ResourceResponse&amp; response) override
 110     {
 111         m_mimeType = response.mimeType();
 112         m_statusCode = response.httpStatusCode();
 113 
 114         // FIXME: This assumes text only responses. We should support non-text responses as well.
 115         TextEncoding textEncoding(response.textEncodingName());
 116         bool useDetector = false;
 117         if (!textEncoding.isValid()) {
 118             textEncoding = UTF8Encoding();
 119             useDetector = true;
 120         }
 121 
 122         m_decoder = TextResourceDecoder::create(&quot;text/plain&quot;_s, textEncoding, useDetector);
 123     }
 124 
 125     void didReceiveData(const char* data, int dataLength) override
 126     {
 127         if (!dataLength)
</pre>
<hr />
<pre>
 281     return metrics;
 282 }
 283 
 284 static Ref&lt;Inspector::Protocol::Network::Request&gt; buildObjectForResourceRequest(const ResourceRequest&amp; request)
 285 {
 286     auto requestObject = Inspector::Protocol::Network::Request::create()
 287         .setUrl(request.url().string())
 288         .setMethod(request.httpMethod())
 289         .setHeaders(buildObjectForHeaders(request.httpHeaderFields()))
 290         .release();
 291     if (request.httpBody() &amp;&amp; !request.httpBody()-&gt;isEmpty()) {
 292         auto bytes = request.httpBody()-&gt;flatten();
 293         requestObject-&gt;setPostData(String::fromUTF8WithLatin1Fallback(bytes.data(), bytes.size()));
 294     }
 295     return requestObject;
 296 }
 297 
 298 static Inspector::Protocol::Network::Response::Source responseSource(ResourceResponse::Source source)
 299 {
 300     switch (source) {

 301     case ResourceResponse::Source::ApplicationCache:
 302         // FIXME: Add support for ApplicationCache in inspector.
 303     case ResourceResponse::Source::Unknown:
 304         return Inspector::Protocol::Network::Response::Source::Unknown;
 305     case ResourceResponse::Source::Network:
 306         return Inspector::Protocol::Network::Response::Source::Network;
 307     case ResourceResponse::Source::MemoryCache:
 308     case ResourceResponse::Source::MemoryCacheAfterValidation:
 309         return Inspector::Protocol::Network::Response::Source::MemoryCache;
 310     case ResourceResponse::Source::DiskCache:
 311     case ResourceResponse::Source::DiskCacheAfterValidation:
 312         return Inspector::Protocol::Network::Response::Source::DiskCache;
 313     case ResourceResponse::Source::ServiceWorker:
 314         return Inspector::Protocol::Network::Response::Source::ServiceWorker;


 315     }
 316 
 317     ASSERT_NOT_REACHED();
 318     return Inspector::Protocol::Network::Response::Source::Unknown;
 319 }
 320 
 321 RefPtr&lt;Inspector::Protocol::Network::Response&gt; InspectorNetworkAgent::buildObjectForResourceResponse(const ResourceResponse&amp; response, ResourceLoader* resourceLoader)
 322 {
 323     if (response.isNull())
 324         return nullptr;
 325 
 326     Ref&lt;JSON::Object&gt; headers = buildObjectForHeaders(response.httpHeaderFields());
 327 
 328     auto responseObject = Inspector::Protocol::Network::Response::create()
 329         .setUrl(response.url().string())
 330         .setStatus(response.httpStatusCode())
 331         .setStatusText(response.httpStatusText())
 332         .setHeaders(WTFMove(headers))
 333         .setMimeType(response.mimeType())
 334         .setSource(responseSource(response.source()))
</pre>
<hr />
<pre>
 810             didCreateWebSocket(identifier, webSocket-&gt;url());
 811             auto cookieRequestHeaderFieldValue = [document = makeWeakPtr(channel-&gt;document())] (const URL&amp; url) -&gt; String {
 812                 if (!document || !document-&gt;page())
 813                     return { };
 814                 return document-&gt;page()-&gt;cookieJar().cookieRequestHeaderFieldValue(*document, url);
 815             };
 816             willSendWebSocketHandshakeRequest(identifier, channel-&gt;clientHandshakeRequest(WTFMove(cookieRequestHeaderFieldValue)));
 817 
 818             if (channel-&gt;handshakeMode() == WebSocketHandshake::Connected)
 819                 didReceiveWebSocketHandshakeResponse(identifier, channel-&gt;serverHandshakeResponse());
 820 
 821             if (webSocket-&gt;readyState() == WebSocket::CLOSED)
 822                 didCloseWebSocket(identifier);
 823         }
 824     }
 825 }
 826 
 827 void InspectorNetworkAgent::disable(ErrorString&amp;)
 828 {
 829     m_enabled = false;


 830     m_instrumentingAgents.setInspectorNetworkAgent(nullptr);
 831     m_resourcesData-&gt;clear();
 832     m_extraRequestHeaders.clear();
 833 


 834     setResourceCachingDisabled(false);
 835 }
 836 

























 837 void InspectorNetworkAgent::setExtraHTTPHeaders(ErrorString&amp;, const JSON::Object&amp; headers)
 838 {
 839     for (auto&amp; entry : headers) {
 840         String stringValue;
 841         if (entry.value-&gt;asString(stringValue))
 842             m_extraRequestHeaders.set(entry.key, stringValue);
 843     }
 844 }
 845 
 846 void InspectorNetworkAgent::getResponseBody(ErrorString&amp; errorString, const String&amp; requestId, String* content, bool* base64Encoded)
 847 {
 848     NetworkResourcesData::ResourceData const* resourceData = m_resourcesData-&gt;data(requestId);
 849     if (!resourceData) {
 850         errorString = &quot;Missing resource for given requestId&quot;_s;
 851         return;
 852     }
 853 
 854     if (resourceData-&gt;hasContent()) {
 855         *base64Encoded = resourceData-&gt;base64Encoded();
 856         *content = resourceData-&gt;content();
</pre>
<hr />
<pre>
 933 
 934     WTF::Persistence::Encoder encoder;
 935     encoder &lt;&lt; certificate.value();
 936     *serializedCertificate = base64Encode(encoder.buffer(), encoder.bufferSize());
 937 }
 938 
 939 WebSocket* InspectorNetworkAgent::webSocketForRequestId(const String&amp; requestId)
 940 {
 941     LockHolder lock(WebSocket::allActiveWebSocketsMutex());
 942 
 943     for (WebSocket* webSocket : activeWebSockets(lock)) {
 944         ASSERT(is&lt;WebSocketChannel&gt;(webSocket-&gt;channel().get()));
 945         WebSocketChannel* channel = downcast&lt;WebSocketChannel&gt;(webSocket-&gt;channel().get());
 946         if (IdentifiersFactory::requestId(channel-&gt;identifier()) == requestId)
 947             return webSocket;
 948     }
 949 
 950     return nullptr;
 951 }
 952 
<span class="line-modified"> 953 static JSC::JSValue webSocketAsScriptValue(JSC::ExecState&amp; state, WebSocket* webSocket)</span>
 954 {
 955     JSC::JSLockHolder lock(&amp;state);
 956     return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), webSocket);
 957 }
 958 
 959 void InspectorNetworkAgent::resolveWebSocket(ErrorString&amp; errorString, const String&amp; requestId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
 960 {
 961     WebSocket* webSocket = webSocketForRequestId(requestId);
 962     if (!webSocket) {
 963         errorString = &quot;Missing web socket for given requestId&quot;_s;
 964         return;
 965     }
 966 
 967     // FIXME: &lt;https://webkit.org/b/168475&gt; Web Inspector: Correctly display iframe&#39;s and worker&#39;s WebSockets
 968     if (!is&lt;Document&gt;(webSocket-&gt;scriptExecutionContext()))
 969         return;
 970 
 971     auto* document = downcast&lt;Document&gt;(webSocket-&gt;scriptExecutionContext());
 972     auto* frame = document-&gt;frame();
 973     if (!frame) {
 974         errorString = &quot;Missing frame of web socket for given requestId&quot;_s;
 975         return;
 976     }
 977 
 978     auto&amp; state = *mainWorldExecState(frame);
 979     auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);
 980     ASSERT(!injectedScript.hasNoValue());
 981 
 982     String objectGroupName = objectGroup ? *objectGroup : String();
 983     result = injectedScript.wrapObject(webSocketAsScriptValue(state, webSocket), objectGroupName);
 984 }
 985 


















































































































































 986 bool InspectorNetworkAgent::shouldTreatAsText(const String&amp; mimeType)
 987 {
 988     return startsWithLettersIgnoringASCIICase(mimeType, &quot;text/&quot;)
 989         || MIMETypeRegistry::isSupportedJavaScriptMIMEType(mimeType)
 990         || MIMETypeRegistry::isSupportedJSONMIMEType(mimeType)
 991         || MIMETypeRegistry::isXMLMIMEType(mimeType)
 992         || MIMETypeRegistry::isTextMediaPlaylistMIMEType(mimeType);
 993 }
 994 
 995 Ref&lt;TextResourceDecoder&gt; InspectorNetworkAgent::createTextDecoder(const String&amp; mimeType, const String&amp; textEncodingName)
 996 {
 997     if (!textEncodingName.isEmpty())
 998         return TextResourceDecoder::create(&quot;text/plain&quot;_s, textEncodingName);
 999 
1000     if (MIMETypeRegistry::isTextMIMEType(mimeType))
1001         return TextResourceDecoder::create(mimeType, &quot;UTF-8&quot;);
1002     if (MIMETypeRegistry::isXMLMIMEType(mimeType)) {
1003         auto decoder = TextResourceDecoder::create(&quot;application/xml&quot;_s);
1004         decoder-&gt;useLenientXMLDecoding();
1005         return decoder;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 2011 Google Inc. All rights reserved.
<span class="line-modified">   3  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions are
   7  * met:
   8  *
   9  *     * Redistributions of source code must retain the above copyright
  10  * notice, this list of conditions and the following disclaimer.
  11  *     * Redistributions in binary form must reproduce the above
  12  * copyright notice, this list of conditions and the following disclaimer
  13  * in the documentation and/or other materials provided with the
  14  * distribution.
  15  *     * Neither the name of Google Inc. nor the names of its
  16  * contributors may be used to endorse or promote products derived from
  17  * this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</pre>
<hr />
<pre>
  46 #include &quot;Frame.h&quot;
  47 #include &quot;FrameLoader.h&quot;
  48 #include &quot;HTTPHeaderMap.h&quot;
  49 #include &quot;HTTPHeaderNames.h&quot;
  50 #include &quot;InspectorDOMAgent.h&quot;
  51 #include &quot;InspectorTimelineAgent.h&quot;
  52 #include &quot;InstrumentingAgents.h&quot;
  53 #include &quot;JSExecState.h&quot;
  54 #include &quot;JSWebSocket.h&quot;
  55 #include &quot;LoaderStrategy.h&quot;
  56 #include &quot;MIMETypeRegistry.h&quot;
  57 #include &quot;MemoryCache.h&quot;
  58 #include &quot;NetworkResourcesData.h&quot;
  59 #include &quot;Page.h&quot;
  60 #include &quot;PlatformStrategies.h&quot;
  61 #include &quot;ProgressTracker.h&quot;
  62 #include &quot;ResourceError.h&quot;
  63 #include &quot;ResourceLoader.h&quot;
  64 #include &quot;ResourceRequest.h&quot;
  65 #include &quot;ResourceResponse.h&quot;

  66 #include &quot;ScriptState.h&quot;
  67 #include &quot;ScriptableDocumentParser.h&quot;
  68 #include &quot;SubresourceLoader.h&quot;
  69 #include &quot;TextResourceDecoder.h&quot;
  70 #include &quot;ThreadableLoaderClient.h&quot;
  71 #include &lt;wtf/URL.h&gt;
  72 #include &quot;WebSocket.h&quot;
  73 #include &quot;WebSocketChannel.h&quot;
  74 #include &quot;WebSocketFrame.h&quot;
  75 #include &lt;JavaScriptCore/ContentSearchUtilities.h&gt;
  76 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
  77 #include &lt;JavaScriptCore/InjectedScript.h&gt;
  78 #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
<span class="line-added">  79 #include &lt;JavaScriptCore/InspectorProtocolObjects.h&gt;</span>
  80 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  81 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
  82 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
<span class="line-added">  83 #include &lt;wtf/HashMap.h&gt;</span>
<span class="line-added">  84 #include &lt;wtf/HashSet.h&gt;</span>
  85 #include &lt;wtf/JSONValues.h&gt;
  86 #include &lt;wtf/Lock.h&gt;
  87 #include &lt;wtf/RefPtr.h&gt;
  88 #include &lt;wtf/Stopwatch.h&gt;
  89 #include &lt;wtf/persistence/PersistentEncoder.h&gt;
  90 #include &lt;wtf/text/Base64.h&gt;
  91 #include &lt;wtf/text/StringBuilder.h&gt;
<span class="line-added">  92 #include &lt;wtf/text/WTFString.h&gt;</span>
  93 
  94 typedef Inspector::NetworkBackendDispatcherHandler::LoadResourceCallback LoadResourceCallback;
  95 
  96 namespace WebCore {
  97 
  98 using namespace Inspector;
  99 
 100 namespace {
 101 
 102 class InspectorThreadableLoaderClient final : public ThreadableLoaderClient {
 103     WTF_MAKE_NONCOPYABLE(InspectorThreadableLoaderClient);
 104 public:
 105     InspectorThreadableLoaderClient(RefPtr&lt;LoadResourceCallback&gt;&amp;&amp; callback)
 106         : m_callback(WTFMove(callback))
 107     {
 108     }
 109 
<span class="line-modified"> 110     ~InspectorThreadableLoaderClient() override = default;</span>
 111 
 112     void didReceiveResponse(unsigned long, const ResourceResponse&amp; response) override
 113     {
 114         m_mimeType = response.mimeType();
 115         m_statusCode = response.httpStatusCode();
 116 
 117         // FIXME: This assumes text only responses. We should support non-text responses as well.
 118         TextEncoding textEncoding(response.textEncodingName());
 119         bool useDetector = false;
 120         if (!textEncoding.isValid()) {
 121             textEncoding = UTF8Encoding();
 122             useDetector = true;
 123         }
 124 
 125         m_decoder = TextResourceDecoder::create(&quot;text/plain&quot;_s, textEncoding, useDetector);
 126     }
 127 
 128     void didReceiveData(const char* data, int dataLength) override
 129     {
 130         if (!dataLength)
</pre>
<hr />
<pre>
 284     return metrics;
 285 }
 286 
 287 static Ref&lt;Inspector::Protocol::Network::Request&gt; buildObjectForResourceRequest(const ResourceRequest&amp; request)
 288 {
 289     auto requestObject = Inspector::Protocol::Network::Request::create()
 290         .setUrl(request.url().string())
 291         .setMethod(request.httpMethod())
 292         .setHeaders(buildObjectForHeaders(request.httpHeaderFields()))
 293         .release();
 294     if (request.httpBody() &amp;&amp; !request.httpBody()-&gt;isEmpty()) {
 295         auto bytes = request.httpBody()-&gt;flatten();
 296         requestObject-&gt;setPostData(String::fromUTF8WithLatin1Fallback(bytes.data(), bytes.size()));
 297     }
 298     return requestObject;
 299 }
 300 
 301 static Inspector::Protocol::Network::Response::Source responseSource(ResourceResponse::Source source)
 302 {
 303     switch (source) {
<span class="line-added"> 304     case ResourceResponse::Source::DOMCache:</span>
 305     case ResourceResponse::Source::ApplicationCache:
 306         // FIXME: Add support for ApplicationCache in inspector.
 307     case ResourceResponse::Source::Unknown:
 308         return Inspector::Protocol::Network::Response::Source::Unknown;
 309     case ResourceResponse::Source::Network:
 310         return Inspector::Protocol::Network::Response::Source::Network;
 311     case ResourceResponse::Source::MemoryCache:
 312     case ResourceResponse::Source::MemoryCacheAfterValidation:
 313         return Inspector::Protocol::Network::Response::Source::MemoryCache;
 314     case ResourceResponse::Source::DiskCache:
 315     case ResourceResponse::Source::DiskCacheAfterValidation:
 316         return Inspector::Protocol::Network::Response::Source::DiskCache;
 317     case ResourceResponse::Source::ServiceWorker:
 318         return Inspector::Protocol::Network::Response::Source::ServiceWorker;
<span class="line-added"> 319     case ResourceResponse::Source::InspectorOverride:</span>
<span class="line-added"> 320         return Inspector::Protocol::Network::Response::Source::InspectorOverride;</span>
 321     }
 322 
 323     ASSERT_NOT_REACHED();
 324     return Inspector::Protocol::Network::Response::Source::Unknown;
 325 }
 326 
 327 RefPtr&lt;Inspector::Protocol::Network::Response&gt; InspectorNetworkAgent::buildObjectForResourceResponse(const ResourceResponse&amp; response, ResourceLoader* resourceLoader)
 328 {
 329     if (response.isNull())
 330         return nullptr;
 331 
 332     Ref&lt;JSON::Object&gt; headers = buildObjectForHeaders(response.httpHeaderFields());
 333 
 334     auto responseObject = Inspector::Protocol::Network::Response::create()
 335         .setUrl(response.url().string())
 336         .setStatus(response.httpStatusCode())
 337         .setStatusText(response.httpStatusText())
 338         .setHeaders(WTFMove(headers))
 339         .setMimeType(response.mimeType())
 340         .setSource(responseSource(response.source()))
</pre>
<hr />
<pre>
 816             didCreateWebSocket(identifier, webSocket-&gt;url());
 817             auto cookieRequestHeaderFieldValue = [document = makeWeakPtr(channel-&gt;document())] (const URL&amp; url) -&gt; String {
 818                 if (!document || !document-&gt;page())
 819                     return { };
 820                 return document-&gt;page()-&gt;cookieJar().cookieRequestHeaderFieldValue(*document, url);
 821             };
 822             willSendWebSocketHandshakeRequest(identifier, channel-&gt;clientHandshakeRequest(WTFMove(cookieRequestHeaderFieldValue)));
 823 
 824             if (channel-&gt;handshakeMode() == WebSocketHandshake::Connected)
 825                 didReceiveWebSocketHandshakeResponse(identifier, channel-&gt;serverHandshakeResponse());
 826 
 827             if (webSocket-&gt;readyState() == WebSocket::CLOSED)
 828                 didCloseWebSocket(identifier);
 829         }
 830     }
 831 }
 832 
 833 void InspectorNetworkAgent::disable(ErrorString&amp;)
 834 {
 835     m_enabled = false;
<span class="line-added"> 836     m_interceptionEnabled = false;</span>
<span class="line-added"> 837     m_intercepts.clear();</span>
 838     m_instrumentingAgents.setInspectorNetworkAgent(nullptr);
 839     m_resourcesData-&gt;clear();
 840     m_extraRequestHeaders.clear();
 841 
<span class="line-added"> 842     continuePendingResponses();</span>
<span class="line-added"> 843 </span>
 844     setResourceCachingDisabled(false);
 845 }
 846 
<span class="line-added"> 847 bool InspectorNetworkAgent::shouldIntercept(URL url)</span>
<span class="line-added"> 848 {</span>
<span class="line-added"> 849     url.removeFragmentIdentifier();</span>
<span class="line-added"> 850 </span>
<span class="line-added"> 851     String urlString = url.string();</span>
<span class="line-added"> 852     if (urlString.isEmpty())</span>
<span class="line-added"> 853         return false;</span>
<span class="line-added"> 854 </span>
<span class="line-added"> 855     for (auto&amp; intercept : m_intercepts) {</span>
<span class="line-added"> 856         auto searchStringType = intercept.isRegex ? ContentSearchUtilities::SearchStringType::Regex : ContentSearchUtilities::SearchStringType::ExactString;</span>
<span class="line-added"> 857         auto regex = ContentSearchUtilities::createRegularExpressionForSearchString(intercept.url, intercept.caseSensitive, searchStringType);</span>
<span class="line-added"> 858         if (regex.match(urlString) != -1)</span>
<span class="line-added"> 859             return true;</span>
<span class="line-added"> 860     }</span>
<span class="line-added"> 861 </span>
<span class="line-added"> 862     return false;</span>
<span class="line-added"> 863 }</span>
<span class="line-added"> 864 </span>
<span class="line-added"> 865 void InspectorNetworkAgent::continuePendingResponses()</span>
<span class="line-added"> 866 {</span>
<span class="line-added"> 867     for (auto&amp; pendingInterceptResponse : m_pendingInterceptResponses.values())</span>
<span class="line-added"> 868         pendingInterceptResponse-&gt;respondWithOriginalResponse();</span>
<span class="line-added"> 869     m_pendingInterceptResponses.clear();</span>
<span class="line-added"> 870 }</span>
<span class="line-added"> 871 </span>
 872 void InspectorNetworkAgent::setExtraHTTPHeaders(ErrorString&amp;, const JSON::Object&amp; headers)
 873 {
 874     for (auto&amp; entry : headers) {
 875         String stringValue;
 876         if (entry.value-&gt;asString(stringValue))
 877             m_extraRequestHeaders.set(entry.key, stringValue);
 878     }
 879 }
 880 
 881 void InspectorNetworkAgent::getResponseBody(ErrorString&amp; errorString, const String&amp; requestId, String* content, bool* base64Encoded)
 882 {
 883     NetworkResourcesData::ResourceData const* resourceData = m_resourcesData-&gt;data(requestId);
 884     if (!resourceData) {
 885         errorString = &quot;Missing resource for given requestId&quot;_s;
 886         return;
 887     }
 888 
 889     if (resourceData-&gt;hasContent()) {
 890         *base64Encoded = resourceData-&gt;base64Encoded();
 891         *content = resourceData-&gt;content();
</pre>
<hr />
<pre>
 968 
 969     WTF::Persistence::Encoder encoder;
 970     encoder &lt;&lt; certificate.value();
 971     *serializedCertificate = base64Encode(encoder.buffer(), encoder.bufferSize());
 972 }
 973 
 974 WebSocket* InspectorNetworkAgent::webSocketForRequestId(const String&amp; requestId)
 975 {
 976     LockHolder lock(WebSocket::allActiveWebSocketsMutex());
 977 
 978     for (WebSocket* webSocket : activeWebSockets(lock)) {
 979         ASSERT(is&lt;WebSocketChannel&gt;(webSocket-&gt;channel().get()));
 980         WebSocketChannel* channel = downcast&lt;WebSocketChannel&gt;(webSocket-&gt;channel().get());
 981         if (IdentifiersFactory::requestId(channel-&gt;identifier()) == requestId)
 982             return webSocket;
 983     }
 984 
 985     return nullptr;
 986 }
 987 
<span class="line-modified"> 988 static JSC::JSValue webSocketAsScriptValue(JSC::JSGlobalObject&amp; state, WebSocket* webSocket)</span>
 989 {
 990     JSC::JSLockHolder lock(&amp;state);
 991     return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), webSocket);
 992 }
 993 
 994 void InspectorNetworkAgent::resolveWebSocket(ErrorString&amp; errorString, const String&amp; requestId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
 995 {
 996     WebSocket* webSocket = webSocketForRequestId(requestId);
 997     if (!webSocket) {
 998         errorString = &quot;Missing web socket for given requestId&quot;_s;
 999         return;
1000     }
1001 
1002     // FIXME: &lt;https://webkit.org/b/168475&gt; Web Inspector: Correctly display iframe&#39;s and worker&#39;s WebSockets
1003     if (!is&lt;Document&gt;(webSocket-&gt;scriptExecutionContext()))
1004         return;
1005 
1006     auto* document = downcast&lt;Document&gt;(webSocket-&gt;scriptExecutionContext());
1007     auto* frame = document-&gt;frame();
1008     if (!frame) {
1009         errorString = &quot;Missing frame of web socket for given requestId&quot;_s;
1010         return;
1011     }
1012 
1013     auto&amp; state = *mainWorldExecState(frame);
1014     auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);
1015     ASSERT(!injectedScript.hasNoValue());
1016 
1017     String objectGroupName = objectGroup ? *objectGroup : String();
1018     result = injectedScript.wrapObject(webSocketAsScriptValue(state, webSocket), objectGroupName);
1019 }
1020 
<span class="line-added">1021 void InspectorNetworkAgent::setInterceptionEnabled(ErrorString&amp; errorString, bool enabled)</span>
<span class="line-added">1022 {</span>
<span class="line-added">1023     if (m_interceptionEnabled == enabled) {</span>
<span class="line-added">1024         errorString = m_interceptionEnabled ? &quot;Interception already enabled&quot;_s : &quot;Interception already disabled&quot;_s;</span>
<span class="line-added">1025         return;</span>
<span class="line-added">1026     }</span>
<span class="line-added">1027 </span>
<span class="line-added">1028     m_interceptionEnabled = enabled;</span>
<span class="line-added">1029 </span>
<span class="line-added">1030     if (!m_interceptionEnabled)</span>
<span class="line-added">1031         continuePendingResponses();</span>
<span class="line-added">1032 }</span>
<span class="line-added">1033 </span>
<span class="line-added">1034 void InspectorNetworkAgent::addInterception(ErrorString&amp; errorString, const String&amp; url, const bool* optionalCaseSensitive, const bool* optionalIsRegex, const String* networkStageString)</span>
<span class="line-added">1035 {</span>
<span class="line-added">1036     if (networkStageString) {</span>
<span class="line-added">1037         auto networkStage = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::Network::NetworkStage&gt;(*networkStageString);</span>
<span class="line-added">1038         if (!networkStage) {</span>
<span class="line-added">1039             errorString = makeString(&quot;Unknown networkStage: &quot;_s, *networkStageString);</span>
<span class="line-added">1040             return;</span>
<span class="line-added">1041         }</span>
<span class="line-added">1042     }</span>
<span class="line-added">1043 </span>
<span class="line-added">1044     Intercept intercept;</span>
<span class="line-added">1045     intercept.url = url;</span>
<span class="line-added">1046     if (optionalCaseSensitive)</span>
<span class="line-added">1047         intercept.caseSensitive = *optionalCaseSensitive;</span>
<span class="line-added">1048     if (optionalIsRegex)</span>
<span class="line-added">1049         intercept.isRegex = *optionalIsRegex;</span>
<span class="line-added">1050 </span>
<span class="line-added">1051     // FIXME: Support intercepting requests.</span>
<span class="line-added">1052 </span>
<span class="line-added">1053     if (!m_intercepts.appendIfNotContains(intercept))</span>
<span class="line-added">1054         errorString = &quot;Intercept for given url and given isRegex already exists&quot;_s;</span>
<span class="line-added">1055 }</span>
<span class="line-added">1056 </span>
<span class="line-added">1057 void InspectorNetworkAgent::removeInterception(ErrorString&amp; errorString, const String&amp; url, const bool* optionalCaseSensitive, const bool* optionalIsRegex, const String* networkStageString)</span>
<span class="line-added">1058 {</span>
<span class="line-added">1059     if (networkStageString) {</span>
<span class="line-added">1060         auto networkStage = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::Network::NetworkStage&gt;(*networkStageString);</span>
<span class="line-added">1061         if (!networkStage) {</span>
<span class="line-added">1062             errorString = makeString(&quot;Unknown networkStage: &quot;_s, *networkStageString);</span>
<span class="line-added">1063             return;</span>
<span class="line-added">1064         }</span>
<span class="line-added">1065     }</span>
<span class="line-added">1066 </span>
<span class="line-added">1067     Intercept intercept;</span>
<span class="line-added">1068     intercept.url = url;</span>
<span class="line-added">1069     if (optionalCaseSensitive)</span>
<span class="line-added">1070         intercept.caseSensitive = *optionalCaseSensitive;</span>
<span class="line-added">1071     if (optionalIsRegex)</span>
<span class="line-added">1072         intercept.isRegex = *optionalIsRegex;</span>
<span class="line-added">1073 </span>
<span class="line-added">1074     // FIXME: Support intercepting requests.</span>
<span class="line-added">1075 </span>
<span class="line-added">1076     if (!m_intercepts.removeAll(intercept))</span>
<span class="line-added">1077         errorString = &quot;Missing intercept for given url and given isRegex&quot;_s;</span>
<span class="line-added">1078 }</span>
<span class="line-added">1079 </span>
<span class="line-added">1080 bool InspectorNetworkAgent::willInterceptRequest(const ResourceRequest&amp; request)</span>
<span class="line-added">1081 {</span>
<span class="line-added">1082     if (!m_interceptionEnabled)</span>
<span class="line-added">1083         return false;</span>
<span class="line-added">1084 </span>
<span class="line-added">1085     return shouldIntercept(request.url());</span>
<span class="line-added">1086 }</span>
<span class="line-added">1087 </span>
<span class="line-added">1088 bool InspectorNetworkAgent::shouldInterceptResponse(const ResourceResponse&amp; response)</span>
<span class="line-added">1089 {</span>
<span class="line-added">1090     if (!m_interceptionEnabled)</span>
<span class="line-added">1091         return false;</span>
<span class="line-added">1092 </span>
<span class="line-added">1093     return shouldIntercept(response.url());</span>
<span class="line-added">1094 }</span>
<span class="line-added">1095 </span>
<span class="line-added">1096 void InspectorNetworkAgent::interceptResponse(const ResourceResponse&amp; response, unsigned long identifier, CompletionHandler&lt;void(const ResourceResponse&amp;, RefPtr&lt;SharedBuffer&gt;)&gt;&amp;&amp; handler)</span>
<span class="line-added">1097 {</span>
<span class="line-added">1098     ASSERT(m_enabled);</span>
<span class="line-added">1099     ASSERT(m_interceptionEnabled);</span>
<span class="line-added">1100 </span>
<span class="line-added">1101     String requestId = IdentifiersFactory::requestId(identifier);</span>
<span class="line-added">1102     if (m_pendingInterceptResponses.contains(requestId)) {</span>
<span class="line-added">1103         ASSERT_NOT_REACHED();</span>
<span class="line-added">1104         handler(response, nullptr);</span>
<span class="line-added">1105         return;</span>
<span class="line-added">1106     }</span>
<span class="line-added">1107 </span>
<span class="line-added">1108     m_pendingInterceptResponses.set(requestId, makeUnique&lt;PendingInterceptResponse&gt;(response, WTFMove(handler)));</span>
<span class="line-added">1109 </span>
<span class="line-added">1110     m_frontendDispatcher-&gt;responseIntercepted(requestId, buildObjectForResourceResponse(response, nullptr));</span>
<span class="line-added">1111 }</span>
<span class="line-added">1112 </span>
<span class="line-added">1113 void InspectorNetworkAgent::interceptContinue(ErrorString&amp; errorString, const String&amp; requestId)</span>
<span class="line-added">1114 {</span>
<span class="line-added">1115     auto pendingInterceptResponse = m_pendingInterceptResponses.take(requestId);</span>
<span class="line-added">1116     if (!pendingInterceptResponse) {</span>
<span class="line-added">1117         errorString = &quot;Missing pending intercept response for given requestId&quot;_s;</span>
<span class="line-added">1118         return;</span>
<span class="line-added">1119     }</span>
<span class="line-added">1120 </span>
<span class="line-added">1121     pendingInterceptResponse-&gt;respondWithOriginalResponse();</span>
<span class="line-added">1122 }</span>
<span class="line-added">1123 </span>
<span class="line-added">1124 void InspectorNetworkAgent::interceptWithResponse(ErrorString&amp; errorString, const String&amp; requestId, const String&amp; content, bool base64Encoded, const String* mimeType, const int* status, const String* statusText, const JSON::Object* headers)</span>
<span class="line-added">1125 {</span>
<span class="line-added">1126     auto pendingInterceptResponse = m_pendingInterceptResponses.take(requestId);</span>
<span class="line-added">1127     if (!pendingInterceptResponse) {</span>
<span class="line-added">1128         errorString = &quot;Missing pending intercept response for given requestId&quot;_s;</span>
<span class="line-added">1129         return;</span>
<span class="line-added">1130     }</span>
<span class="line-added">1131 </span>
<span class="line-added">1132     ResourceResponse overrideResponse(pendingInterceptResponse-&gt;originalResponse());</span>
<span class="line-added">1133     overrideResponse.setSource(ResourceResponse::Source::InspectorOverride);</span>
<span class="line-added">1134 </span>
<span class="line-added">1135     if (status)</span>
<span class="line-added">1136         overrideResponse.setHTTPStatusCode(*status);</span>
<span class="line-added">1137     if (statusText)</span>
<span class="line-added">1138         overrideResponse.setHTTPStatusText(*statusText);</span>
<span class="line-added">1139     if (mimeType)</span>
<span class="line-added">1140         overrideResponse.setMimeType(*mimeType);</span>
<span class="line-added">1141     if (headers) {</span>
<span class="line-added">1142         HTTPHeaderMap explicitHeaders;</span>
<span class="line-added">1143         for (auto&amp; header : *headers) {</span>
<span class="line-added">1144             String headerValue;</span>
<span class="line-added">1145             if (header.value-&gt;asString(headerValue))</span>
<span class="line-added">1146                 explicitHeaders.add(header.key, headerValue);</span>
<span class="line-added">1147         }</span>
<span class="line-added">1148         overrideResponse.setHTTPHeaderFields(WTFMove(explicitHeaders));</span>
<span class="line-added">1149         overrideResponse.setHTTPHeaderField(HTTPHeaderName::ContentType, overrideResponse.mimeType());</span>
<span class="line-added">1150     }</span>
<span class="line-added">1151 </span>
<span class="line-added">1152     RefPtr&lt;SharedBuffer&gt; overrideData;</span>
<span class="line-added">1153     if (base64Encoded) {</span>
<span class="line-added">1154         Vector&lt;uint8_t&gt; buffer;</span>
<span class="line-added">1155         if (!base64Decode(content, buffer)) {</span>
<span class="line-added">1156             errorString = &quot;Unable to decode given content&quot;_s;</span>
<span class="line-added">1157             pendingInterceptResponse-&gt;respondWithOriginalResponse();</span>
<span class="line-added">1158             return;</span>
<span class="line-added">1159         }</span>
<span class="line-added">1160         overrideData = SharedBuffer::create(WTFMove(buffer));</span>
<span class="line-added">1161     } else</span>
<span class="line-added">1162         overrideData = SharedBuffer::create(content.utf8().data(), content.utf8().length());</span>
<span class="line-added">1163 </span>
<span class="line-added">1164     pendingInterceptResponse-&gt;respond(overrideResponse, overrideData);</span>
<span class="line-added">1165 }</span>
<span class="line-added">1166 </span>
1167 bool InspectorNetworkAgent::shouldTreatAsText(const String&amp; mimeType)
1168 {
1169     return startsWithLettersIgnoringASCIICase(mimeType, &quot;text/&quot;)
1170         || MIMETypeRegistry::isSupportedJavaScriptMIMEType(mimeType)
1171         || MIMETypeRegistry::isSupportedJSONMIMEType(mimeType)
1172         || MIMETypeRegistry::isXMLMIMEType(mimeType)
1173         || MIMETypeRegistry::isTextMediaPlaylistMIMEType(mimeType);
1174 }
1175 
1176 Ref&lt;TextResourceDecoder&gt; InspectorNetworkAgent::createTextDecoder(const String&amp; mimeType, const String&amp; textEncodingName)
1177 {
1178     if (!textEncodingName.isEmpty())
1179         return TextResourceDecoder::create(&quot;text/plain&quot;_s, textEncodingName);
1180 
1181     if (MIMETypeRegistry::isTextMIMEType(mimeType))
1182         return TextResourceDecoder::create(mimeType, &quot;UTF-8&quot;);
1183     if (MIMETypeRegistry::isXMLMIMEType(mimeType)) {
1184         auto decoder = TextResourceDecoder::create(&quot;application/xml&quot;_s);
1185         decoder-&gt;useLenientXMLDecoding();
1186         return decoder;
</pre>
</td>
</tr>
</table>
<center><a href="InspectorMemoryAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorNetworkAgent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
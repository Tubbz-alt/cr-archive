<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMDebuggerAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  * Copyright (C) 2015 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;InspectorDOMDebuggerAgent.h&quot;
 34 
 35 #include &quot;Event.h&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 36 #include &quot;Frame.h&quot;</span>
<span class="line-removed"> 37 #include &quot;HTMLElement.h&quot;</span>
 38 #include &quot;InspectorDOMAgent.h&quot;
 39 #include &quot;InstrumentingAgents.h&quot;
 40 #include &quot;JSEvent.h&quot;
 41 #include &quot;RegisteredEventListener.h&quot;
<a name="2" id="anc2"></a>
 42 #include &lt;JavaScriptCore/ContentSearchUtilities.h&gt;
 43 #include &lt;JavaScriptCore/InjectedScript.h&gt;
 44 #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
 45 #include &lt;JavaScriptCore/InspectorFrontendDispatchers.h&gt;
 46 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 47 #include &lt;wtf/JSONValues.h&gt;
 48 
<a name="3" id="anc3"></a><span class="line-removed"> 49 namespace {</span>
<span class="line-removed"> 50 </span>
<span class="line-removed"> 51 enum DOMBreakpointType {</span>
<span class="line-removed"> 52     SubtreeModified,</span>
<span class="line-removed"> 53     AttributeModified,</span>
<span class="line-removed"> 54     NodeRemoved,</span>
<span class="line-removed"> 55     DOMBreakpointTypesCount</span>
<span class="line-removed"> 56 };</span>
<span class="line-removed"> 57 </span>
<span class="line-removed"> 58 const uint32_t inheritableDOMBreakpointTypesMask = (1 &lt;&lt; SubtreeModified);</span>
<span class="line-removed"> 59 const int domBreakpointDerivedTypeShift = 16;</span>
<span class="line-removed"> 60 </span>
<span class="line-removed"> 61 }</span>
<span class="line-removed"> 62 </span>
<span class="line-removed"> 63 </span>
 64 namespace WebCore {
 65 
 66 using namespace Inspector;
 67 
 68 InspectorDOMDebuggerAgent::InspectorDOMDebuggerAgent(WebAgentContext&amp; context, InspectorDebuggerAgent* debuggerAgent)
 69     : InspectorAgentBase(&quot;DOMDebugger&quot;_s, context)
<a name="4" id="anc4"></a>
 70     , m_backendDispatcher(Inspector::DOMDebuggerBackendDispatcher::create(context.backendDispatcher, this))
 71     , m_injectedScriptManager(context.injectedScriptManager)
<a name="5" id="anc5"></a><span class="line-removed"> 72     , m_debuggerAgent(debuggerAgent)</span>
 73 {
 74     m_debuggerAgent-&gt;addListener(*this);
 75 }
 76 
 77 InspectorDOMDebuggerAgent::~InspectorDOMDebuggerAgent() = default;
 78 
<a name="6" id="anc6"></a><span class="line-modified"> 79 // Browser debugger agent enabled only when JS debugger is enabled.</span>
<span class="line-removed"> 80 void InspectorDOMDebuggerAgent::debuggerWasEnabled()</span>
 81 {
<a name="7" id="anc7"></a><span class="line-modified"> 82     m_instrumentingAgents.setInspectorDOMDebuggerAgent(this);</span>
 83 }
 84 
<a name="8" id="anc8"></a><span class="line-modified"> 85 void InspectorDOMDebuggerAgent::debuggerWasDisabled()</span>
 86 {
<a name="9" id="anc9"></a><span class="line-modified"> 87     disable();</span>
 88 }
 89 
 90 void InspectorDOMDebuggerAgent::disable()
 91 {
 92     m_instrumentingAgents.setInspectorDOMDebuggerAgent(nullptr);
<a name="10" id="anc10"></a><span class="line-modified"> 93     m_domBreakpoints.clear();</span>
 94     m_listenerBreakpoints.clear();
 95     m_urlBreakpoints.clear();
<a name="11" id="anc11"></a><span class="line-removed"> 96     m_pauseOnAllAnimationFramesEnabled = false;</span>
 97     m_pauseOnAllIntervalsEnabled = false;
 98     m_pauseOnAllListenersEnabled = false;
 99     m_pauseOnAllTimeoutsEnabled = false;
100     m_pauseOnAllURLsEnabled = false;
101 }
102 
<a name="12" id="anc12"></a>












103 void InspectorDOMDebuggerAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
104 {
105 }
106 
107 void InspectorDOMDebuggerAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
108 {
109     disable();
110 }
111 
112 void InspectorDOMDebuggerAgent::discardAgent()
113 {
114     m_debuggerAgent-&gt;removeListener(*this);
115     m_debuggerAgent = nullptr;
116 }
117 
<a name="13" id="anc13"></a><span class="line-removed">118 void InspectorDOMDebuggerAgent::frameDocumentUpdated(Frame&amp; frame)</span>
<span class="line-removed">119 {</span>
<span class="line-removed">120     if (!frame.isMainFrame())</span>
<span class="line-removed">121         return;</span>
<span class="line-removed">122 </span>
<span class="line-removed">123     m_domBreakpoints.clear();</span>
<span class="line-removed">124 }</span>
<span class="line-removed">125 </span>
126 void InspectorDOMDebuggerAgent::setEventBreakpoint(ErrorString&amp; errorString, const String&amp; breakpointTypeString, const String* eventName)
127 {
128     if (breakpointTypeString.isEmpty()) {
129         errorString = &quot;breakpointType is empty&quot;_s;
130         return;
131     }
132 
133     auto breakpointType = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::DOMDebugger::EventBreakpointType&gt;(breakpointTypeString);
134     if (!breakpointType) {
135         errorString = makeString(&quot;Unknown breakpointType: &quot;_s, breakpointTypeString);
136         return;
137     }
138 
139     if (eventName &amp;&amp; !eventName-&gt;isEmpty()) {
140         if (breakpointType.value() == Inspector::Protocol::DOMDebugger::EventBreakpointType::Listener) {
141             if (!m_listenerBreakpoints.add(*eventName))
142                 errorString = &quot;Breakpoint with eventName already exists&quot;_s;
143             return;
144         }
145 
146         errorString = &quot;Unexpected eventName&quot;_s;
147         return;
148     }
149 
150     switch (breakpointType.value()) {
151     case Inspector::Protocol::DOMDebugger::EventBreakpointType::AnimationFrame:
<a name="14" id="anc14"></a><span class="line-modified">152         if (m_pauseOnAllAnimationFramesEnabled)</span>
<span class="line-removed">153             errorString = &quot;Breakpoint for AnimationFrame already exists&quot;_s;</span>
<span class="line-removed">154         m_pauseOnAllAnimationFramesEnabled = true;</span>
155         break;
156 
157     case Inspector::Protocol::DOMDebugger::EventBreakpointType::Interval:
158         if (m_pauseOnAllIntervalsEnabled)
159             errorString = &quot;Breakpoint for Interval already exists&quot;_s;
160         m_pauseOnAllIntervalsEnabled = true;
161         break;
162 
163     case Inspector::Protocol::DOMDebugger::EventBreakpointType::Listener:
164         if (m_pauseOnAllListenersEnabled)
165             errorString = &quot;Breakpoint for Listener already exists&quot;_s;
166         m_pauseOnAllListenersEnabled = true;
167         break;
168 
169     case Inspector::Protocol::DOMDebugger::EventBreakpointType::Timeout:
170         if (m_pauseOnAllTimeoutsEnabled)
171             errorString = &quot;Breakpoint for Timeout already exists&quot;_s;
172         m_pauseOnAllTimeoutsEnabled = true;
173         break;
174     }
175 }
176 
177 void InspectorDOMDebuggerAgent::removeEventBreakpoint(ErrorString&amp; errorString, const String&amp; breakpointTypeString, const String* eventName)
178 {
179     if (breakpointTypeString.isEmpty()) {
180         errorString = &quot;breakpointType is empty&quot;_s;
181         return;
182     }
183 
184     auto breakpointType = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::DOMDebugger::EventBreakpointType&gt;(breakpointTypeString);
185     if (!breakpointType) {
186         errorString = makeString(&quot;Unknown breakpointType: &quot;_s, breakpointTypeString);
187         return;
188     }
189 
190     if (eventName &amp;&amp; !eventName-&gt;isEmpty()) {
191         if (breakpointType.value() == Inspector::Protocol::DOMDebugger::EventBreakpointType::Listener) {
192             if (!m_listenerBreakpoints.remove(*eventName))
193                 errorString = &quot;Breakpoint for given eventName missing&quot;_s;
194             return;
195         }
196 
197         errorString = &quot;Unexpected eventName&quot;_s;
198         return;
199     }
200 
201     switch (breakpointType.value()) {
202     case Inspector::Protocol::DOMDebugger::EventBreakpointType::AnimationFrame:
<a name="15" id="anc15"></a><span class="line-modified">203         if (!m_pauseOnAllAnimationFramesEnabled)</span>
<span class="line-removed">204             errorString = &quot;Breakpoint for AnimationFrame missing&quot;_s;</span>
<span class="line-removed">205         m_pauseOnAllAnimationFramesEnabled = false;</span>
206         break;
207 
208     case Inspector::Protocol::DOMDebugger::EventBreakpointType::Interval:
209         if (!m_pauseOnAllIntervalsEnabled)
210             errorString = &quot;Breakpoint for Intervals missing&quot;_s;
211         m_pauseOnAllIntervalsEnabled = false;
212         break;
213 
214     case Inspector::Protocol::DOMDebugger::EventBreakpointType::Listener:
215         if (!m_pauseOnAllListenersEnabled)
216             errorString = &quot;Breakpoint for Listeners missing&quot;_s;
217         m_pauseOnAllListenersEnabled = false;
218         break;
219 
220     case Inspector::Protocol::DOMDebugger::EventBreakpointType::Timeout:
221         if (!m_pauseOnAllTimeoutsEnabled)
222             errorString = &quot;Breakpoint for Timeouts missing&quot;_s;
223         m_pauseOnAllTimeoutsEnabled = false;
224         break;
225     }
226 }
227 
<a name="16" id="anc16"></a><span class="line-removed">228 void InspectorDOMDebuggerAgent::willInvalidateStyleAttr(Element&amp; element)</span>
<span class="line-removed">229 {</span>
<span class="line-removed">230     if (!m_debuggerAgent-&gt;breakpointsActive())</span>
<span class="line-removed">231         return;</span>
<span class="line-removed">232 </span>
<span class="line-removed">233     if (hasBreakpoint(&amp;element, AttributeModified)) {</span>
<span class="line-removed">234         Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();</span>
<span class="line-removed">235         descriptionForDOMEvent(element, AttributeModified, false, eventData.get());</span>
<span class="line-removed">236         m_debuggerAgent-&gt;breakProgram(Inspector::DebuggerFrontendDispatcher::Reason::DOM, WTFMove(eventData));</span>
<span class="line-removed">237     }</span>
<span class="line-removed">238 }</span>
<span class="line-removed">239 </span>
<span class="line-removed">240 void InspectorDOMDebuggerAgent::didInsertDOMNode(Node&amp; node)</span>
<span class="line-removed">241 {</span>
<span class="line-removed">242     if (m_domBreakpoints.size()) {</span>
<span class="line-removed">243         uint32_t mask = m_domBreakpoints.get(InspectorDOMAgent::innerParentNode(&amp;node));</span>
<span class="line-removed">244         uint32_t inheritableTypesMask = (mask | (mask &gt;&gt; domBreakpointDerivedTypeShift)) &amp; inheritableDOMBreakpointTypesMask;</span>
<span class="line-removed">245         if (inheritableTypesMask)</span>
<span class="line-removed">246             updateSubtreeBreakpoints(&amp;node, inheritableTypesMask, true);</span>
<span class="line-removed">247     }</span>
<span class="line-removed">248 }</span>
<span class="line-removed">249 </span>
<span class="line-removed">250 void InspectorDOMDebuggerAgent::didRemoveDOMNode(Node&amp; node)</span>
<span class="line-removed">251 {</span>
<span class="line-removed">252     if (m_domBreakpoints.size()) {</span>
<span class="line-removed">253         // Remove subtree breakpoints.</span>
<span class="line-removed">254         m_domBreakpoints.remove(&amp;node);</span>
<span class="line-removed">255         Vector&lt;Node*&gt; stack(1, InspectorDOMAgent::innerFirstChild(&amp;node));</span>
<span class="line-removed">256         do {</span>
<span class="line-removed">257             Node* node = stack.last();</span>
<span class="line-removed">258             stack.removeLast();</span>
<span class="line-removed">259             if (!node)</span>
<span class="line-removed">260                 continue;</span>
<span class="line-removed">261             m_domBreakpoints.remove(node);</span>
<span class="line-removed">262             stack.append(InspectorDOMAgent::innerFirstChild(node));</span>
<span class="line-removed">263             stack.append(InspectorDOMAgent::innerNextSibling(node));</span>
<span class="line-removed">264         } while (!stack.isEmpty());</span>
<span class="line-removed">265     }</span>
<span class="line-removed">266 }</span>
<span class="line-removed">267 </span>
<span class="line-removed">268 static int domTypeForName(ErrorString&amp; errorString, const String&amp; typeString)</span>
<span class="line-removed">269 {</span>
<span class="line-removed">270     if (typeString == &quot;subtree-modified&quot;)</span>
<span class="line-removed">271         return SubtreeModified;</span>
<span class="line-removed">272     if (typeString == &quot;attribute-modified&quot;)</span>
<span class="line-removed">273         return AttributeModified;</span>
<span class="line-removed">274     if (typeString == &quot;node-removed&quot;)</span>
<span class="line-removed">275         return NodeRemoved;</span>
<span class="line-removed">276     errorString = makeString(&quot;Unknown type: &quot;, typeString);</span>
<span class="line-removed">277     return -1;</span>
<span class="line-removed">278 }</span>
<span class="line-removed">279 </span>
<span class="line-removed">280 static String domTypeName(int type)</span>
<span class="line-removed">281 {</span>
<span class="line-removed">282     switch (type) {</span>
<span class="line-removed">283     case SubtreeModified: return &quot;subtree-modified&quot;_s;</span>
<span class="line-removed">284     case AttributeModified: return &quot;attribute-modified&quot;_s;</span>
<span class="line-removed">285     case NodeRemoved: return &quot;node-removed&quot;_s;</span>
<span class="line-removed">286     default: break;</span>
<span class="line-removed">287     }</span>
<span class="line-removed">288     return emptyString();</span>
<span class="line-removed">289 }</span>
<span class="line-removed">290 </span>
<span class="line-removed">291 void InspectorDOMDebuggerAgent::setDOMBreakpoint(ErrorString&amp; errorString, int nodeId, const String&amp; typeString)</span>
<span class="line-removed">292 {</span>
<span class="line-removed">293     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();</span>
<span class="line-removed">294     if (!domAgent) {</span>
<span class="line-removed">295         errorString = &quot;DOM domain must be enabled&quot;_s;</span>
<span class="line-removed">296         return;</span>
<span class="line-removed">297     }</span>
<span class="line-removed">298 </span>
<span class="line-removed">299     Node* node = domAgent-&gt;assertNode(errorString, nodeId);</span>
<span class="line-removed">300     if (!node)</span>
<span class="line-removed">301         return;</span>
<span class="line-removed">302 </span>
<span class="line-removed">303     int type = domTypeForName(errorString, typeString);</span>
<span class="line-removed">304     if (type == -1)</span>
<span class="line-removed">305         return;</span>
<span class="line-removed">306 </span>
<span class="line-removed">307     uint32_t rootBit = 1 &lt;&lt; type;</span>
<span class="line-removed">308     m_domBreakpoints.set(node, m_domBreakpoints.get(node) | rootBit);</span>
<span class="line-removed">309     if (rootBit &amp; inheritableDOMBreakpointTypesMask) {</span>
<span class="line-removed">310         for (Node* child = InspectorDOMAgent::innerFirstChild(node); child; child = InspectorDOMAgent::innerNextSibling(child))</span>
<span class="line-removed">311             updateSubtreeBreakpoints(child, rootBit, true);</span>
<span class="line-removed">312     }</span>
<span class="line-removed">313 }</span>
<span class="line-removed">314 </span>
<span class="line-removed">315 void InspectorDOMDebuggerAgent::removeDOMBreakpoint(ErrorString&amp; errorString, int nodeId, const String&amp; typeString)</span>
<span class="line-removed">316 {</span>
<span class="line-removed">317     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();</span>
<span class="line-removed">318     if (!domAgent) {</span>
<span class="line-removed">319         errorString = &quot;DOM domain must be enabled&quot;_s;</span>
<span class="line-removed">320         return;</span>
<span class="line-removed">321     }</span>
<span class="line-removed">322 </span>
<span class="line-removed">323     Node* node = domAgent-&gt;assertNode(errorString, nodeId);</span>
<span class="line-removed">324     if (!node)</span>
<span class="line-removed">325         return;</span>
<span class="line-removed">326 </span>
<span class="line-removed">327     int type = domTypeForName(errorString, typeString);</span>
<span class="line-removed">328     if (type == -1)</span>
<span class="line-removed">329         return;</span>
<span class="line-removed">330 </span>
<span class="line-removed">331     uint32_t rootBit = 1 &lt;&lt; type;</span>
<span class="line-removed">332     uint32_t mask = m_domBreakpoints.get(node) &amp; ~rootBit;</span>
<span class="line-removed">333     if (mask)</span>
<span class="line-removed">334         m_domBreakpoints.set(node, mask);</span>
<span class="line-removed">335     else</span>
<span class="line-removed">336         m_domBreakpoints.remove(node);</span>
<span class="line-removed">337 </span>
<span class="line-removed">338     if ((rootBit &amp; inheritableDOMBreakpointTypesMask) &amp;&amp; !(mask &amp; (rootBit &lt;&lt; domBreakpointDerivedTypeShift))) {</span>
<span class="line-removed">339         for (Node* child = InspectorDOMAgent::innerFirstChild(node); child; child = InspectorDOMAgent::innerNextSibling(child))</span>
<span class="line-removed">340             updateSubtreeBreakpoints(child, rootBit, false);</span>
<span class="line-removed">341     }</span>
<span class="line-removed">342 }</span>
<span class="line-removed">343 </span>
<span class="line-removed">344 void InspectorDOMDebuggerAgent::willInsertDOMNode(Node&amp; parent)</span>
<span class="line-removed">345 {</span>
<span class="line-removed">346     if (!m_debuggerAgent-&gt;breakpointsActive())</span>
<span class="line-removed">347         return;</span>
<span class="line-removed">348 </span>
<span class="line-removed">349     if (hasBreakpoint(&amp;parent, SubtreeModified)) {</span>
<span class="line-removed">350         Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();</span>
<span class="line-removed">351         descriptionForDOMEvent(parent, SubtreeModified, true, eventData.get());</span>
<span class="line-removed">352         m_debuggerAgent-&gt;breakProgram(Inspector::DebuggerFrontendDispatcher::Reason::DOM, WTFMove(eventData));</span>
<span class="line-removed">353     }</span>
<span class="line-removed">354 }</span>
<span class="line-removed">355 </span>
<span class="line-removed">356 void InspectorDOMDebuggerAgent::willRemoveDOMNode(Node&amp; node)</span>
<span class="line-removed">357 {</span>
<span class="line-removed">358     if (!m_debuggerAgent-&gt;breakpointsActive())</span>
<span class="line-removed">359         return;</span>
<span class="line-removed">360 </span>
<span class="line-removed">361     Node* parentNode = InspectorDOMAgent::innerParentNode(&amp;node);</span>
<span class="line-removed">362     if (hasBreakpoint(&amp;node, NodeRemoved)) {</span>
<span class="line-removed">363         Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();</span>
<span class="line-removed">364         descriptionForDOMEvent(node, NodeRemoved, false, eventData.get());</span>
<span class="line-removed">365         m_debuggerAgent-&gt;breakProgram(Inspector::DebuggerFrontendDispatcher::Reason::DOM, WTFMove(eventData));</span>
<span class="line-removed">366     } else if (parentNode &amp;&amp; hasBreakpoint(parentNode, SubtreeModified)) {</span>
<span class="line-removed">367         Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();</span>
<span class="line-removed">368         descriptionForDOMEvent(node, SubtreeModified, false, eventData.get());</span>
<span class="line-removed">369         m_debuggerAgent-&gt;breakProgram(Inspector::DebuggerFrontendDispatcher::Reason::DOM, WTFMove(eventData));</span>
<span class="line-removed">370     }</span>
<span class="line-removed">371 }</span>
<span class="line-removed">372 </span>
<span class="line-removed">373 void InspectorDOMDebuggerAgent::willModifyDOMAttr(Element&amp; element)</span>
<span class="line-removed">374 {</span>
<span class="line-removed">375     if (!m_debuggerAgent-&gt;breakpointsActive())</span>
<span class="line-removed">376         return;</span>
<span class="line-removed">377 </span>
<span class="line-removed">378     if (hasBreakpoint(&amp;element, AttributeModified)) {</span>
<span class="line-removed">379         Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();</span>
<span class="line-removed">380         descriptionForDOMEvent(element, AttributeModified, false, eventData.get());</span>
<span class="line-removed">381         m_debuggerAgent-&gt;breakProgram(Inspector::DebuggerFrontendDispatcher::Reason::DOM, WTFMove(eventData));</span>
<span class="line-removed">382     }</span>
<span class="line-removed">383 }</span>
<span class="line-removed">384 </span>
<span class="line-removed">385 void InspectorDOMDebuggerAgent::descriptionForDOMEvent(Node&amp; target, int breakpointType, bool insertion, JSON::Object&amp; description)</span>
<span class="line-removed">386 {</span>
<span class="line-removed">387     ASSERT(m_debuggerAgent-&gt;breakpointsActive());</span>
<span class="line-removed">388     ASSERT(hasBreakpoint(&amp;target, breakpointType));</span>
<span class="line-removed">389 </span>
<span class="line-removed">390     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();</span>
<span class="line-removed">391 </span>
<span class="line-removed">392     Node* breakpointOwner = &amp;target;</span>
<span class="line-removed">393     if ((1 &lt;&lt; breakpointType) &amp; inheritableDOMBreakpointTypesMask) {</span>
<span class="line-removed">394         if (domAgent) {</span>
<span class="line-removed">395             // For inheritable breakpoint types, target node isn&#39;t always the same as the node that owns a breakpoint.</span>
<span class="line-removed">396             // Target node may be unknown to frontend, so we need to push it first.</span>
<span class="line-removed">397             RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; targetNodeObject = domAgent-&gt;resolveNode(&amp;target, InspectorDebuggerAgent::backtraceObjectGroup);</span>
<span class="line-removed">398             description.setValue(&quot;targetNode&quot;, targetNodeObject);</span>
<span class="line-removed">399         }</span>
<span class="line-removed">400 </span>
<span class="line-removed">401         // Find breakpoint owner node.</span>
<span class="line-removed">402         if (!insertion)</span>
<span class="line-removed">403             breakpointOwner = InspectorDOMAgent::innerParentNode(&amp;target);</span>
<span class="line-removed">404         ASSERT(breakpointOwner);</span>
<span class="line-removed">405         while (!(m_domBreakpoints.get(breakpointOwner) &amp; (1 &lt;&lt; breakpointType))) {</span>
<span class="line-removed">406             Node* parentNode = InspectorDOMAgent::innerParentNode(breakpointOwner);</span>
<span class="line-removed">407             if (!parentNode)</span>
<span class="line-removed">408                 break;</span>
<span class="line-removed">409             breakpointOwner = parentNode;</span>
<span class="line-removed">410         }</span>
<span class="line-removed">411 </span>
<span class="line-removed">412         if (breakpointType == SubtreeModified)</span>
<span class="line-removed">413             description.setBoolean(&quot;insertion&quot;, insertion);</span>
<span class="line-removed">414     }</span>
<span class="line-removed">415 </span>
<span class="line-removed">416     if (domAgent) {</span>
<span class="line-removed">417         int breakpointOwnerNodeId = domAgent-&gt;boundNodeId(breakpointOwner);</span>
<span class="line-removed">418         ASSERT(breakpointOwnerNodeId);</span>
<span class="line-removed">419         description.setInteger(&quot;nodeId&quot;, breakpointOwnerNodeId);</span>
<span class="line-removed">420     }</span>
<span class="line-removed">421 </span>
<span class="line-removed">422     description.setString(&quot;type&quot;, domTypeName(breakpointType));</span>
<span class="line-removed">423 }</span>
<span class="line-removed">424 </span>
<span class="line-removed">425 bool InspectorDOMDebuggerAgent::hasBreakpoint(Node* node, int type)</span>
<span class="line-removed">426 {</span>
<span class="line-removed">427     uint32_t rootBit = 1 &lt;&lt; type;</span>
<span class="line-removed">428     uint32_t derivedBit = rootBit &lt;&lt; domBreakpointDerivedTypeShift;</span>
<span class="line-removed">429     return m_domBreakpoints.get(node) &amp; (rootBit | derivedBit);</span>
<span class="line-removed">430 }</span>
<span class="line-removed">431 </span>
<span class="line-removed">432 void InspectorDOMDebuggerAgent::updateSubtreeBreakpoints(Node* node, uint32_t rootMask, bool set)</span>
<span class="line-removed">433 {</span>
<span class="line-removed">434     uint32_t oldMask = m_domBreakpoints.get(node);</span>
<span class="line-removed">435     uint32_t derivedMask = rootMask &lt;&lt; domBreakpointDerivedTypeShift;</span>
<span class="line-removed">436     uint32_t newMask = set ? oldMask | derivedMask : oldMask &amp; ~derivedMask;</span>
<span class="line-removed">437     if (newMask)</span>
<span class="line-removed">438         m_domBreakpoints.set(node, newMask);</span>
<span class="line-removed">439     else</span>
<span class="line-removed">440         m_domBreakpoints.remove(node);</span>
<span class="line-removed">441 </span>
<span class="line-removed">442     uint32_t newRootMask = rootMask &amp; ~newMask;</span>
<span class="line-removed">443     if (!newRootMask)</span>
<span class="line-removed">444         return;</span>
<span class="line-removed">445 </span>
<span class="line-removed">446     for (Node* child = InspectorDOMAgent::innerFirstChild(node); child; child = InspectorDOMAgent::innerNextSibling(child))</span>
<span class="line-removed">447         updateSubtreeBreakpoints(child, newRootMask, set);</span>
<span class="line-removed">448 }</span>
<span class="line-removed">449 </span>
450 void InspectorDOMDebuggerAgent::willHandleEvent(Event&amp; event, const RegisteredEventListener&amp; registeredEventListener)
451 {
452     if (!m_debuggerAgent-&gt;breakpointsActive())
453         return;
454 
455     auto state = event.target()-&gt;scriptExecutionContext()-&gt;execState();
456     auto injectedScript = m_injectedScriptManager.injectedScriptFor(state);
457     ASSERT(!injectedScript.hasNoValue());
458     {
459         JSC::JSLockHolder lock(state);
460 
461         injectedScript.setEventValue(toJS(state, deprecatedGlobalObjectForPrototype(state), event));
462     }
463 
464     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();
465 
466     bool shouldPause = m_debuggerAgent-&gt;pauseOnNextStatementEnabled() || m_pauseOnAllListenersEnabled || m_listenerBreakpoints.contains(event.type());
467     if (!shouldPause &amp;&amp; domAgent)
468         shouldPause = domAgent-&gt;hasBreakpointForEventListener(*event.currentTarget(), event.type(), registeredEventListener.callback(), registeredEventListener.useCapture());
469     if (!shouldPause)
470         return;
471 
472     Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();
473     eventData-&gt;setString(&quot;eventName&quot;_s, event.type());
474     if (domAgent) {
475         int eventListenerId = domAgent-&gt;idForEventListener(*event.currentTarget(), event.type(), registeredEventListener.callback(), registeredEventListener.useCapture());
476         if (eventListenerId)
477             eventData-&gt;setInteger(&quot;eventListenerId&quot;_s, eventListenerId);
478     }
479 
480     m_debuggerAgent-&gt;schedulePauseOnNextStatement(Inspector::DebuggerFrontendDispatcher::Reason::Listener, WTFMove(eventData));
481 }
482 
483 void InspectorDOMDebuggerAgent::didHandleEvent()
484 {
485     m_injectedScriptManager.clearEventValue();
486 }
487 
488 void InspectorDOMDebuggerAgent::willFireTimer(bool oneShot)
489 {
490     if (!m_debuggerAgent-&gt;breakpointsActive())
491         return;
492 
493     bool shouldPause = m_debuggerAgent-&gt;pauseOnNextStatementEnabled() || (oneShot ? m_pauseOnAllTimeoutsEnabled : m_pauseOnAllIntervalsEnabled);
494     if (!shouldPause)
495         return;
496 
497     auto breakReason = oneShot ? Inspector::DebuggerFrontendDispatcher::Reason::Timeout : Inspector::DebuggerFrontendDispatcher::Reason::Interval;
498     m_debuggerAgent-&gt;schedulePauseOnNextStatement(breakReason, nullptr);
499 }
500 
<a name="17" id="anc17"></a><span class="line-removed">501 void InspectorDOMDebuggerAgent::willFireAnimationFrame()</span>
<span class="line-removed">502 {</span>
<span class="line-removed">503     if (!m_debuggerAgent-&gt;breakpointsActive())</span>
<span class="line-removed">504         return;</span>
<span class="line-removed">505 </span>
<span class="line-removed">506     bool shouldPause = m_debuggerAgent-&gt;pauseOnNextStatementEnabled() || m_pauseOnAllAnimationFramesEnabled;</span>
<span class="line-removed">507     if (!shouldPause)</span>
<span class="line-removed">508         return;</span>
<span class="line-removed">509 </span>
<span class="line-removed">510     m_debuggerAgent-&gt;schedulePauseOnNextStatement(Inspector::DebuggerFrontendDispatcher::Reason::AnimationFrame, nullptr);</span>
<span class="line-removed">511 }</span>
<span class="line-removed">512 </span>
513 void InspectorDOMDebuggerAgent::setURLBreakpoint(ErrorString&amp; errorString, const String&amp; url, const bool* optionalIsRegex)
514 {
515     if (url.isEmpty()) {
516         if (m_pauseOnAllURLsEnabled)
517             errorString = &quot;Breakpoint for all URLs already exists&quot;_s;
518         m_pauseOnAllURLsEnabled = true;
519         return;
520     }
521 
522     bool isRegex = optionalIsRegex ? *optionalIsRegex : false;
523     auto result = m_urlBreakpoints.set(url, isRegex ? URLBreakpointType::RegularExpression : URLBreakpointType::Text);
524     if (!result.isNewEntry)
525         errorString = &quot;Breakpoint for given url already exists&quot;_s;
526 }
527 
528 void InspectorDOMDebuggerAgent::removeURLBreakpoint(ErrorString&amp; errorString, const String&amp; url)
529 {
530     if (url.isEmpty()) {
531         if (!m_pauseOnAllURLsEnabled)
532             errorString = &quot;Breakpoint for all URLs missing&quot;_s;
533         m_pauseOnAllURLsEnabled = false;
534         return;
535     }
536 
537     auto result = m_urlBreakpoints.remove(url);
538     if (!result)
539         errorString = &quot;Breakpoint for given url missing&quot;_s;
540 }
541 
542 void InspectorDOMDebuggerAgent::breakOnURLIfNeeded(const String&amp; url, URLBreakpointSource source)
543 {
544     if (!m_debuggerAgent-&gt;breakpointsActive())
545         return;
546 
547     String breakpointURL;
548     if (m_pauseOnAllURLsEnabled)
549         breakpointURL = emptyString();
550     else {
<a name="18" id="anc18"></a><span class="line-modified">551         for (auto&amp; entry : m_urlBreakpoints) {</span>
<span class="line-modified">552             const auto&amp; query = entry.key;</span>
<span class="line-modified">553             bool isRegex = entry.value == URLBreakpointType::RegularExpression;</span>
<span class="line-modified">554             auto regex = ContentSearchUtilities::createSearchRegex(query, false, isRegex);</span>
555             if (regex.match(url) != -1) {
556                 breakpointURL = query;
557                 break;
558             }
559         }
560     }
561 
562     if (breakpointURL.isNull())
563         return;
564 
565     Inspector::DebuggerFrontendDispatcher::Reason breakReason;
566     if (source == URLBreakpointSource::Fetch)
567         breakReason = Inspector::DebuggerFrontendDispatcher::Reason::Fetch;
568     else if (source == URLBreakpointSource::XHR)
569         breakReason = Inspector::DebuggerFrontendDispatcher::Reason::XHR;
570     else {
571         ASSERT_NOT_REACHED();
572         breakReason = Inspector::DebuggerFrontendDispatcher::Reason::Other;
573     }
574 
575     Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();
576     eventData-&gt;setString(&quot;breakpointURL&quot;, breakpointURL);
577     eventData-&gt;setString(&quot;url&quot;, url);
578     m_debuggerAgent-&gt;breakProgram(breakReason, WTFMove(eventData));
579 }
580 
581 void InspectorDOMDebuggerAgent::willSendXMLHttpRequest(const String&amp; url)
582 {
583     breakOnURLIfNeeded(url, URLBreakpointSource::XHR);
584 }
585 
586 void InspectorDOMDebuggerAgent::willFetch(const String&amp; url)
587 {
588     breakOnURLIfNeeded(url, URLBreakpointSource::Fetch);
589 }
590 
591 } // namespace WebCore
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
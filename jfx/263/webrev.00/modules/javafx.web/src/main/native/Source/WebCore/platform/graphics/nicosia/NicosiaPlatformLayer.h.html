<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/nicosia/NicosiaPlatformLayer.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018 Metrological Group B.V.
  3  * Copyright (C) 2018 Igalia S.L.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above
 12  *    copyright notice, this list of conditions and the following
 13  *    disclaimer in the documentation and/or other materials provided
 14  *    with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 17  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 18  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 19  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 20  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 21  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 22  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 23  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #pragma once
 30 
 31 #include &quot;Color.h&quot;
 32 #include &quot;FilterOperations.h&quot;
 33 #include &quot;FloatPoint.h&quot;
 34 #include &quot;FloatPoint3D.h&quot;
 35 #include &quot;FloatRect.h&quot;
 36 #include &quot;FloatSize.h&quot;
 37 #include &quot;NicosiaAnimatedBackingStoreClient.h&quot;
 38 #include &quot;NicosiaAnimation.h&quot;
 39 #include &quot;NicosiaSceneIntegration.h&quot;
 40 #include &quot;TransformationMatrix.h&quot;
 41 #include &lt;wtf/Function.h&gt;
 42 #include &lt;wtf/Lock.h&gt;
 43 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
 44 #include &lt;wtf/TypeCasts.h&gt;
 45 
 46 namespace Nicosia {
 47 
 48 class PlatformLayer : public ThreadSafeRefCounted&lt;PlatformLayer&gt; {
 49 public:
 50     virtual ~PlatformLayer();
 51 
 52     virtual bool isCompositionLayer() const { return false; }
 53     virtual bool isContentLayer() const { return false; }
 54 
 55     using LayerID = uint64_t;
 56     LayerID id() const { return m_id; }
 57 
 58     void setSceneIntegration(RefPtr&lt;SceneIntegration&gt;&amp;&amp; sceneIntegration)
 59     {
 60         LockHolder locker(m_state.lock);
 61         m_state.sceneIntegration = WTFMove(sceneIntegration);
 62     }
 63 
 64     std::unique_ptr&lt;SceneIntegration::UpdateScope&gt; createUpdateScope()
 65     {
 66         LockHolder locker(m_state.lock);
 67         if (m_state.sceneIntegration)
 68             return m_state.sceneIntegration-&gt;createUpdateScope();
 69         return nullptr;
 70     }
 71 
 72 protected:
 73     explicit PlatformLayer(uint64_t);
 74 
 75     uint64_t m_id;
 76 
 77     struct {
 78         Lock lock;
 79         RefPtr&lt;SceneIntegration&gt; sceneIntegration;
 80     } m_state;
 81 };
 82 
 83 class ContentLayer;
 84 class BackingStore;
 85 class ImageBacking;
 86 
 87 class CompositionLayer : public PlatformLayer {
 88 public:
 89     class Impl {
 90     public:
 91         using Factory = WTF::Function&lt;std::unique_ptr&lt;Impl&gt;(uint64_t, CompositionLayer&amp;)&gt;;
 92 
 93         virtual ~Impl();
 94         virtual bool isTextureMapperImpl() const { return false; }
 95     };
 96 
 97     static Ref&lt;CompositionLayer&gt; create(uint64_t id, const Impl::Factory&amp; factory)
 98     {
 99         return adoptRef(*new CompositionLayer(id, factory));
100     }
101     virtual ~CompositionLayer();
102     bool isCompositionLayer() const override { return true; }
103 
104     Impl&amp; impl() const { return *m_impl; }
105 
106     struct LayerState {
107         struct Delta {
108             Delta() = default;
109 
110             union {
111                 struct {
112                     bool positionChanged : 1;
113                     bool anchorPointChanged : 1;
114                     bool sizeChanged : 1;
115                     bool boundsOriginChanged : 1;
116                     bool transformChanged : 1;
117                     bool childrenTransformChanged : 1;
118                     bool contentsRectChanged : 1;
119                     bool contentsTilingChanged : 1;
120                     bool opacityChanged : 1;
121                     bool solidColorChanged : 1;
122                     bool filtersChanged : 1;
123                     bool animationsChanged : 1;
124                     bool childrenChanged : 1;
125                     bool maskChanged : 1;
126                     bool replicaChanged : 1;
127                     bool flagsChanged : 1;
128                     bool contentLayerChanged : 1;
129                     bool backingStoreChanged : 1;
130                     bool imageBackingChanged : 1;
131                     bool animatedBackingStoreClientChanged : 1;
132                     bool repaintCounterChanged : 1;
133                     bool debugBorderChanged : 1;
134                 };
135                 uint32_t value { 0 };
136             };
137         } delta;
138 
139         struct Flags {
140             Flags()
141                 : contentsVisible(true)
142                 , backfaceVisible(true)
143             { }
144 
145             union {
146                 struct {
147                     bool contentsOpaque : 1;
148                     bool drawsContent : 1;
149                     bool contentsVisible : 1;
150                     bool backfaceVisible : 1;
151                     bool masksToBounds : 1;
152                     bool preserves3D : 1;
153                 };
154                 uint32_t value { 0 };
155             };
156         } flags;
157 
158         WebCore::FloatPoint position;
159         WebCore::FloatPoint3D anchorPoint;
160         WebCore::FloatSize size;
161         WebCore::FloatPoint boundsOrigin;
162 
163         WebCore::TransformationMatrix transform;
164         WebCore::TransformationMatrix childrenTransform;
165 
166         WebCore::FloatRect contentsRect;
167         WebCore::FloatSize contentsTilePhase;
168         WebCore::FloatSize contentsTileSize;
169 
170         float opacity { 0 };
171         WebCore::Color solidColor;
172 
173         WebCore::FilterOperations filters;
174         // FIXME: Despite the name, this implementation is not
175         // TextureMapper-specific. Should be renamed when necessary.
176         Animations animations;
177 
178         Vector&lt;RefPtr&lt;CompositionLayer&gt;&gt; children;
179         RefPtr&lt;CompositionLayer&gt; replica;
180         RefPtr&lt;CompositionLayer&gt; mask;
181 
182         RefPtr&lt;ContentLayer&gt; contentLayer;
183         RefPtr&lt;BackingStore&gt; backingStore;
184         RefPtr&lt;ImageBacking&gt; imageBacking;
185         RefPtr&lt;AnimatedBackingStoreClient&gt; animatedBackingStoreClient;
186 
187         struct RepaintCounter {
188             unsigned count { 0 };
189             bool visible { false };
190         } repaintCounter;
191         struct DebugBorder {
192             WebCore::Color color;
193             float width { 0 };
194             bool visible { false };
195         } debugBorder;
196     };
197 
198     template&lt;typename T&gt;
199     void updateState(const T&amp; functor)
200     {
201         LockHolder locker(PlatformLayer::m_state.lock);
202         functor(m_state.pending);
203     }
204 
205     template&lt;typename T&gt;
206     void flushState(const T&amp; functor)
207     {
208         LockHolder locker(PlatformLayer::m_state.lock);
209         auto&amp; pending = m_state.pending;
210         auto&amp; staging = m_state.staging;
211 
212         staging.delta.value |= pending.delta.value;
213 
214         if (pending.delta.positionChanged)
215             staging.position = pending.position;
216         if (pending.delta.anchorPointChanged)
217             staging.anchorPoint = pending.anchorPoint;
218         if (pending.delta.sizeChanged)
219             staging.size = pending.size;
220         if (pending.delta.boundsOriginChanged)
221             staging.boundsOrigin = pending.boundsOrigin;
222 
223         if (pending.delta.transformChanged)
224             staging.transform = pending.transform;
225         if (pending.delta.childrenTransformChanged)
226             staging.childrenTransform = pending.childrenTransform;
227 
228         if (pending.delta.contentsRectChanged)
229             staging.contentsRect = pending.contentsRect;
230         if (pending.delta.contentsTilingChanged) {
231             staging.contentsTilePhase = pending.contentsTilePhase;
232             staging.contentsTileSize = pending.contentsTileSize;
233         }
234 
235         if (pending.delta.opacityChanged)
236             staging.opacity = pending.opacity;
237         if (pending.delta.solidColorChanged)
238             staging.solidColor = pending.solidColor;
239 
240         if (pending.delta.filtersChanged)
241             staging.filters = pending.filters;
242         if (pending.delta.animationsChanged)
243             staging.animations = pending.animations;
244 
245         if (pending.delta.childrenChanged)
246             staging.children = pending.children;
247         if (pending.delta.maskChanged)
248             staging.mask = pending.mask;
249         if (pending.delta.replicaChanged)
250             staging.replica = pending.replica;
251 
252         if (pending.delta.flagsChanged)
253             staging.flags.value = pending.flags.value;
254 
255         if (pending.delta.repaintCounterChanged)
256             staging.repaintCounter = pending.repaintCounter;
257         if (pending.delta.debugBorderChanged)
258             staging.debugBorder = pending.debugBorder;
259 
260         if (pending.delta.backingStoreChanged)
261             staging.backingStore = pending.backingStore;
262         if (pending.delta.contentLayerChanged)
263             staging.contentLayer = pending.contentLayer;
264         if (pending.delta.imageBackingChanged)
265             staging.imageBacking = pending.imageBacking;
266         if (pending.delta.animatedBackingStoreClientChanged)
267             staging.animatedBackingStoreClient = pending.animatedBackingStoreClient;
268 
269         pending.delta = { };
270 
271         functor(staging);
272     }
273 
274     template&lt;typename T&gt;
275     void commitState(const T&amp; functor)
276     {
277         LockHolder locker(PlatformLayer::m_state.lock);
278         m_state.committed = m_state.staging;
279         m_state.staging.delta = { };
280 
281         functor(m_state.committed);
282     }
283 
284     template&lt;typename T&gt;
285     void accessCommitted(const T&amp; functor)
286     {
287         LockHolder locker(PlatformLayer::m_state.lock);
288         functor(m_state.committed);
289     }
290 
291 private:
292     CompositionLayer(uint64_t, const Impl::Factory&amp;);
293 
294     std::unique_ptr&lt;Impl&gt; m_impl;
295 
296     struct {
297         LayerState pending;
298         LayerState staging;
299         LayerState committed;
300     } m_state;
301 };
302 
303 class ContentLayer : public PlatformLayer {
304 public:
305     class Impl {
306     public:
307         using Factory = WTF::Function&lt;std::unique_ptr&lt;Impl&gt;(ContentLayer&amp;)&gt;;
308 
309         virtual ~Impl();
310         virtual bool isTextureMapperImpl() const { return false; }
311     };
312 
313     static Ref&lt;ContentLayer&gt; create(const Impl::Factory&amp; factory)
314     {
315         return adoptRef(*new ContentLayer(factory));
316     }
317     virtual ~ContentLayer();
318     bool isContentLayer() const override { return true; }
319 
320     Impl&amp; impl() const { return *m_impl; }
321 
322 private:
323     ContentLayer(const Impl::Factory&amp;);
324 
325     std::unique_ptr&lt;Impl&gt; m_impl;
326 };
327 
328 class BackingStore : public ThreadSafeRefCounted&lt;BackingStore&gt; {
329 public:
330     class Impl {
331     public:
332         using Factory = WTF::Function&lt;std::unique_ptr&lt;Impl&gt;(BackingStore&amp;)&gt;;
333 
334         virtual ~Impl();
335         virtual bool isTextureMapperImpl() const { return false; }
336     };
337 
338     static Ref&lt;BackingStore&gt; create(const Impl::Factory&amp; factory)
339     {
340         return adoptRef(*new BackingStore(factory));
341     }
342     virtual ~BackingStore();
343 
344     Impl&amp; impl() const { return *m_impl; }
345 
346 private:
347     BackingStore(const Impl::Factory&amp;);
348 
349     std::unique_ptr&lt;Impl&gt; m_impl;
350 };
351 
352 class ImageBacking : public ThreadSafeRefCounted&lt;ImageBacking&gt; {
353 public:
354     class Impl {
355     public:
356         using Factory = WTF::Function&lt;std::unique_ptr&lt;Impl&gt;(ImageBacking&amp;)&gt;;
357 
358         virtual ~Impl();
359         virtual bool isTextureMapperImpl() const { return false; }
360     };
361 
362     static Ref&lt;ImageBacking&gt; create(const Impl::Factory&amp; factory)
363     {
364         return adoptRef(*new ImageBacking(factory));
365     }
366     virtual ~ImageBacking();
367 
368     Impl&amp; impl() const { return *m_impl; }
369 
370 private:
371     ImageBacking(const Impl::Factory&amp;);
372 
373     std::unique_ptr&lt;Impl&gt; m_impl;
374 };
375 
376 } // namespace Nicosia
377 
378 #define SPECIALIZE_TYPE_TRAITS_NICOSIA_PLATFORMLAYER(ToClassName, predicate) \
379     SPECIALIZE_TYPE_TRAITS_BEGIN(Nicosia::ToClassName) \
380     static bool isType(const Nicosia::PlatformLayer&amp; layer) { return layer.predicate; } \
381     SPECIALIZE_TYPE_TRAITS_END()
382 
383 SPECIALIZE_TYPE_TRAITS_NICOSIA_PLATFORMLAYER(CompositionLayer, isCompositionLayer());
384 SPECIALIZE_TYPE_TRAITS_NICOSIA_PLATFORMLAYER(ContentLayer, isContentLayer());
385 
386 #define SPECIALIZE_TYPE_TRAITS_NICOSIA_COMPOSITIONLAYER_IMPL(ToClassName, predicate) \
387     SPECIALIZE_TYPE_TRAITS_BEGIN(Nicosia::ToClassName) \
388     static bool isType(const Nicosia::CompositionLayer::Impl&amp; impl) { return impl.predicate; } \
389     SPECIALIZE_TYPE_TRAITS_END()
390 
391 #define SPECIALIZE_TYPE_TRAITS_NICOSIA_CONTENTLAYER_IMPL(ToClassName, predicate) \
392     SPECIALIZE_TYPE_TRAITS_BEGIN(Nicosia::ToClassName) \
393     static bool isType(const Nicosia::ContentLayer::Impl&amp; impl) { return impl.predicate; } \
394     SPECIALIZE_TYPE_TRAITS_END()
395 
396 #define SPECIALIZE_TYPE_TRAITS_NICOSIA_BACKINGSTORE_IMPL(ToClassName, predicate) \
397     SPECIALIZE_TYPE_TRAITS_BEGIN(Nicosia::ToClassName) \
398     static bool isType(const Nicosia::BackingStore::Impl&amp; impl) { return impl.predicate; } \
399     SPECIALIZE_TYPE_TRAITS_END()
400 
401 #define SPECIALIZE_TYPE_TRAITS_NICOSIA_IMAGEBACKING_IMPL(ToClassName, predicate) \
402     SPECIALIZE_TYPE_TRAITS_BEGIN(Nicosia::ToClassName) \
403     static bool isType(const Nicosia::ImageBacking::Impl&amp; impl) { return impl.predicate; } \
404     SPECIALIZE_TYPE_TRAITS_END()
    </pre>
  </body>
</html>
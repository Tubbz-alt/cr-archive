<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/ServiceWorkerThreadProxy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ServiceWorkerThread.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerThreadProxy.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/ServiceWorkerThreadProxy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ServiceWorkerThreadProxy.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;CacheStorageProvider.h&quot;

 32 #include &quot;EventNames.h&quot;
 33 #include &quot;FetchLoader.h&quot;
 34 #include &quot;Frame.h&quot;
 35 #include &quot;FrameLoader.h&quot;
 36 #include &quot;LoaderStrategy.h&quot;

 37 #include &quot;PlatformStrategies.h&quot;

 38 #include &quot;ServiceWorkerClientIdentifier.h&quot;
 39 #include &quot;Settings.h&quot;
 40 #include &quot;WorkerGlobalScope.h&quot;
<span class="line-removed"> 41 #include &lt;pal/SessionID.h&gt;</span>
 42 #include &lt;wtf/MainThread.h&gt;
 43 #include &lt;wtf/RunLoop.h&gt;
 44 
 45 namespace WebCore {
 46 
 47 URL static inline topOriginURL(const SecurityOrigin&amp; origin)
 48 {
 49     URL url;
 50     url.setProtocol(origin.protocol());
 51     url.setHost(origin.host());
 52     if (origin.port())
 53         url.setPort(*origin.port());
 54     return url;
 55 }
 56 
<span class="line-modified"> 57 static inline UniqueRef&lt;Page&gt; createPageForServiceWorker(PageConfiguration&amp;&amp; configuration, const ServiceWorkerContextData&amp; data, SecurityOrigin::StorageBlockingPolicy storageBlockingPolicy, PAL::SessionID sessionID)</span>
 58 {
 59     auto page = makeUniqueRef&lt;Page&gt;(WTFMove(configuration));
<span class="line-removed"> 60     page-&gt;setSessionID(sessionID);</span>
 61 
 62     auto&amp; mainFrame = page-&gt;mainFrame();
 63     mainFrame.loader().initForSynthesizedDocument({ });
 64     auto document = Document::createNonRenderedPlaceholder(mainFrame, data.scriptURL);
 65     document-&gt;createDOMWindow();
 66 
 67     document-&gt;mutableSettings().setStorageBlockingPolicy(storageBlockingPolicy);
 68     document-&gt;storageBlockingStateDidChange();
 69 
 70     auto origin = data.registration.key.topOrigin().securityOrigin();
 71     origin-&gt;setStorageBlockingPolicy(storageBlockingPolicy);
 72 
 73     document-&gt;setSiteForCookies(topOriginURL(origin));
<span class="line-modified"> 74     document-&gt;setFirstPartyForCookies(data.scriptURL);</span>
 75     document-&gt;setDomainForCachePartition(origin-&gt;domainForCachePartition());
 76 
 77     if (auto policy = parseReferrerPolicy(data.referrerPolicy, ReferrerPolicySource::HTTPHeader))
 78         document-&gt;setReferrerPolicy(*policy);
 79 
 80     mainFrame.setDocument(WTFMove(document));
 81     return page;
 82 }
 83 
 84 static inline IDBClient::IDBConnectionProxy* idbConnectionProxy(Document&amp; document)
 85 {
 86 #if ENABLE(INDEXED_DATABASE)
 87     return document.idbConnectionProxy();
 88 #else
 89     return nullptr;
 90 #endif
 91 }
 92 
 93 static HashSet&lt;ServiceWorkerThreadProxy*&gt;&amp; allServiceWorkerThreadProxies()
 94 {
 95     static NeverDestroyed&lt;HashSet&lt;ServiceWorkerThreadProxy*&gt;&gt; set;
 96     return set;
 97 }
 98 
<span class="line-modified"> 99 ServiceWorkerThreadProxy::ServiceWorkerThreadProxy(PageConfiguration&amp;&amp; pageConfiguration, const ServiceWorkerContextData&amp; data, PAL::SessionID sessionID, String&amp;&amp; userAgent, CacheStorageProvider&amp; cacheStorageProvider, SecurityOrigin::StorageBlockingPolicy storageBlockingPolicy)</span>
<span class="line-modified">100     : m_page(createPageForServiceWorker(WTFMove(pageConfiguration), data, storageBlockingPolicy, data.sessionID))</span>
101     , m_document(*m_page-&gt;mainFrame().document())
<span class="line-modified">102     , m_serviceWorkerThread(ServiceWorkerThread::create(data, sessionID, WTFMove(userAgent), *this, *this, idbConnectionProxy(m_document), m_document-&gt;socketProvider()))</span>
103     , m_cacheStorageProvider(cacheStorageProvider)
<span class="line-removed">104     , m_sessionID(sessionID)</span>
105     , m_inspectorProxy(*this)
106 {
107     static bool addedListener;
108     if (!addedListener) {
109         platformStrategies()-&gt;loaderStrategy()-&gt;addOnlineStateChangeListener(&amp;networkStateChanged);
110         addedListener = true;
111     }
112 
113     ASSERT(!allServiceWorkerThreadProxies().contains(this));
114     allServiceWorkerThreadProxies().add(this);
115 
116 #if ENABLE(REMOTE_INSPECTOR)
117     m_remoteDebuggable = makeUnique&lt;ServiceWorkerDebuggable&gt;(*this, data);
118     m_remoteDebuggable-&gt;setRemoteDebuggingAllowed(true);
119     m_remoteDebuggable-&gt;init();
120 #endif
121 }
122 
123 ServiceWorkerThreadProxy::~ServiceWorkerThreadProxy()
124 {
</pre>
<hr />
<pre>
133 
134     m_serviceWorkerThread-&gt;runLoop().postTaskForMode(WTFMove(task), mode);
135     return true;
136 }
137 
138 void ServiceWorkerThreadProxy::postTaskToLoader(ScriptExecutionContext::Task&amp;&amp; task)
139 {
140     callOnMainThread([task = WTFMove(task), this, protectedThis = makeRef(*this)] () mutable {
141         task.performTask(m_document.get());
142     });
143 }
144 
145 void ServiceWorkerThreadProxy::postMessageToDebugger(const String&amp; message)
146 {
147     RunLoop::main().dispatch([this, protectedThis = makeRef(*this), message = message.isolatedCopy()] {
148         // FIXME: Handle terminated case.
149         m_inspectorProxy.sendMessageFromWorkerToFrontend(message);
150     });
151 }
152 
<span class="line-modified">153 void ServiceWorkerThreadProxy::setResourceCachingDisabled(bool disabled)</span>
154 {
155     postTaskToLoader([this, protectedThis = makeRef(*this), disabled] (ScriptExecutionContext&amp;) {
156         ASSERT(isMainThread());
<span class="line-modified">157         m_page-&gt;setResourceCachingDisabled(disabled);</span>
158     });
159 }
160 
161 Ref&lt;CacheStorageConnection&gt; ServiceWorkerThreadProxy::createCacheStorageConnection()
162 {
163     ASSERT(isMainThread());
164     if (!m_cacheStorageConnection)
<span class="line-modified">165         m_cacheStorageConnection = m_cacheStorageProvider.createCacheStorageConnection(m_sessionID);</span>
166     return *m_cacheStorageConnection;
167 }
168 
169 std::unique_ptr&lt;FetchLoader&gt; ServiceWorkerThreadProxy::createBlobLoader(FetchLoaderClient&amp; client, const URL&amp; blobURL)
170 {
171     auto loader = makeUnique&lt;FetchLoader&gt;(client, nullptr);
172     loader-&gt;startLoadingBlobURL(m_document, blobURL);
173     if (!loader-&gt;isStarted())
174         return nullptr;
175     return loader;
176 }
177 
178 void ServiceWorkerThreadProxy::networkStateChanged(bool isOnLine)
179 {
180     for (auto* proxy : allServiceWorkerThreadProxies())
181         proxy-&gt;notifyNetworkStateChange(isOnLine);
182 }
183 
184 void ServiceWorkerThreadProxy::notifyNetworkStateChange(bool isOnline)
185 {
186     if (m_isTerminatingOrTerminated)
187         return;
188 
189     postTaskForModeToWorkerGlobalScope([isOnline] (ScriptExecutionContext&amp; context) {
190         auto&amp; globalScope = downcast&lt;WorkerGlobalScope&gt;(context);
191         globalScope.setIsOnline(isOnline);
<span class="line-modified">192         globalScope.dispatchEvent(Event::create(isOnline ? eventNames().onlineEvent : eventNames().offlineEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>


193     }, WorkerRunLoop::defaultMode());
194 }
195 
196 void ServiceWorkerThreadProxy::startFetch(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier, Ref&lt;ServiceWorkerFetch::Client&gt;&amp;&amp; client, Optional&lt;ServiceWorkerClientIdentifier&gt;&amp;&amp; clientId, ResourceRequest&amp;&amp; request, String&amp;&amp; referrer, FetchOptions&amp;&amp; options)
197 {
198     auto key = std::make_pair(connectionIdentifier, fetchIdentifier);
199 



200     ASSERT(!m_ongoingFetchTasks.contains(key));
201     m_ongoingFetchTasks.add(key, client.copyRef());
<span class="line-modified">202     thread().postFetchTask(WTFMove(client), WTFMove(clientId), WTFMove(request), WTFMove(referrer), WTFMove(options));</span>


203 }
204 
205 void ServiceWorkerThreadProxy::cancelFetch(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier)
206 {
207     auto client = m_ongoingFetchTasks.take(std::make_pair(connectionIdentifier, fetchIdentifier));
208     if (!client)
209         return;
210 



211     postTaskForModeToWorkerGlobalScope([client = WTFMove(client.value())] (ScriptExecutionContext&amp;) {
212         client-&gt;cancel();
213     }, WorkerRunLoop::defaultMode());
214 }
215 
216 void ServiceWorkerThreadProxy::continueDidReceiveFetchResponse(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier)
217 {
218     auto client = m_ongoingFetchTasks.get(std::make_pair(connectionIdentifier, fetchIdentifier));
219     if (!client)
220         return;
221 
222     postTaskForModeToWorkerGlobalScope([client = makeRef(*client)] (ScriptExecutionContext&amp;) {
223         client-&gt;continueDidReceiveResponse();
224     }, WorkerRunLoop::defaultMode());
225 }
226 
227 void ServiceWorkerThreadProxy::removeFetch(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier)
228 {
229     m_ongoingFetchTasks.remove(std::make_pair(connectionIdentifier, fetchIdentifier));



























230 }
231 
232 } // namespace WebCore
233 
234 #endif // ENABLE(SERVICE_WORKER)
</pre>
</td>
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ServiceWorkerThreadProxy.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;CacheStorageProvider.h&quot;
<span class="line-added"> 32 #include &quot;EventLoop.h&quot;</span>
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;FetchLoader.h&quot;
 35 #include &quot;Frame.h&quot;
 36 #include &quot;FrameLoader.h&quot;
 37 #include &quot;LoaderStrategy.h&quot;
<span class="line-added"> 38 #include &quot;MessageWithMessagePorts.h&quot;</span>
 39 #include &quot;PlatformStrategies.h&quot;
<span class="line-added"> 40 #include &quot;ServiceWorkerClientData.h&quot;</span>
 41 #include &quot;ServiceWorkerClientIdentifier.h&quot;
 42 #include &quot;Settings.h&quot;
 43 #include &quot;WorkerGlobalScope.h&quot;

 44 #include &lt;wtf/MainThread.h&gt;
 45 #include &lt;wtf/RunLoop.h&gt;
 46 
 47 namespace WebCore {
 48 
 49 URL static inline topOriginURL(const SecurityOrigin&amp; origin)
 50 {
 51     URL url;
 52     url.setProtocol(origin.protocol());
 53     url.setHost(origin.host());
 54     if (origin.port())
 55         url.setPort(*origin.port());
 56     return url;
 57 }
 58 
<span class="line-modified"> 59 static inline UniqueRef&lt;Page&gt; createPageForServiceWorker(PageConfiguration&amp;&amp; configuration, const ServiceWorkerContextData&amp; data, SecurityOrigin::StorageBlockingPolicy storageBlockingPolicy)</span>
 60 {
 61     auto page = makeUniqueRef&lt;Page&gt;(WTFMove(configuration));

 62 
 63     auto&amp; mainFrame = page-&gt;mainFrame();
 64     mainFrame.loader().initForSynthesizedDocument({ });
 65     auto document = Document::createNonRenderedPlaceholder(mainFrame, data.scriptURL);
 66     document-&gt;createDOMWindow();
 67 
 68     document-&gt;mutableSettings().setStorageBlockingPolicy(storageBlockingPolicy);
 69     document-&gt;storageBlockingStateDidChange();
 70 
 71     auto origin = data.registration.key.topOrigin().securityOrigin();
 72     origin-&gt;setStorageBlockingPolicy(storageBlockingPolicy);
 73 
 74     document-&gt;setSiteForCookies(topOriginURL(origin));
<span class="line-modified"> 75     document-&gt;setFirstPartyForCookies(topOriginURL(origin));</span>
 76     document-&gt;setDomainForCachePartition(origin-&gt;domainForCachePartition());
 77 
 78     if (auto policy = parseReferrerPolicy(data.referrerPolicy, ReferrerPolicySource::HTTPHeader))
 79         document-&gt;setReferrerPolicy(*policy);
 80 
 81     mainFrame.setDocument(WTFMove(document));
 82     return page;
 83 }
 84 
 85 static inline IDBClient::IDBConnectionProxy* idbConnectionProxy(Document&amp; document)
 86 {
 87 #if ENABLE(INDEXED_DATABASE)
 88     return document.idbConnectionProxy();
 89 #else
 90     return nullptr;
 91 #endif
 92 }
 93 
 94 static HashSet&lt;ServiceWorkerThreadProxy*&gt;&amp; allServiceWorkerThreadProxies()
 95 {
 96     static NeverDestroyed&lt;HashSet&lt;ServiceWorkerThreadProxy*&gt;&gt; set;
 97     return set;
 98 }
 99 
<span class="line-modified">100 ServiceWorkerThreadProxy::ServiceWorkerThreadProxy(PageConfiguration&amp;&amp; pageConfiguration, const ServiceWorkerContextData&amp; data, String&amp;&amp; userAgent, CacheStorageProvider&amp; cacheStorageProvider, SecurityOrigin::StorageBlockingPolicy storageBlockingPolicy)</span>
<span class="line-modified">101     : m_page(createPageForServiceWorker(WTFMove(pageConfiguration), data, storageBlockingPolicy))</span>
102     , m_document(*m_page-&gt;mainFrame().document())
<span class="line-modified">103     , m_serviceWorkerThread(ServiceWorkerThread::create(data, WTFMove(userAgent), *this, *this, idbConnectionProxy(m_document), m_document-&gt;socketProvider()))</span>
104     , m_cacheStorageProvider(cacheStorageProvider)

105     , m_inspectorProxy(*this)
106 {
107     static bool addedListener;
108     if (!addedListener) {
109         platformStrategies()-&gt;loaderStrategy()-&gt;addOnlineStateChangeListener(&amp;networkStateChanged);
110         addedListener = true;
111     }
112 
113     ASSERT(!allServiceWorkerThreadProxies().contains(this));
114     allServiceWorkerThreadProxies().add(this);
115 
116 #if ENABLE(REMOTE_INSPECTOR)
117     m_remoteDebuggable = makeUnique&lt;ServiceWorkerDebuggable&gt;(*this, data);
118     m_remoteDebuggable-&gt;setRemoteDebuggingAllowed(true);
119     m_remoteDebuggable-&gt;init();
120 #endif
121 }
122 
123 ServiceWorkerThreadProxy::~ServiceWorkerThreadProxy()
124 {
</pre>
<hr />
<pre>
133 
134     m_serviceWorkerThread-&gt;runLoop().postTaskForMode(WTFMove(task), mode);
135     return true;
136 }
137 
138 void ServiceWorkerThreadProxy::postTaskToLoader(ScriptExecutionContext::Task&amp;&amp; task)
139 {
140     callOnMainThread([task = WTFMove(task), this, protectedThis = makeRef(*this)] () mutable {
141         task.performTask(m_document.get());
142     });
143 }
144 
145 void ServiceWorkerThreadProxy::postMessageToDebugger(const String&amp; message)
146 {
147     RunLoop::main().dispatch([this, protectedThis = makeRef(*this), message = message.isolatedCopy()] {
148         // FIXME: Handle terminated case.
149         m_inspectorProxy.sendMessageFromWorkerToFrontend(message);
150     });
151 }
152 
<span class="line-modified">153 void ServiceWorkerThreadProxy::setResourceCachingDisabledByWebInspector(bool disabled)</span>
154 {
155     postTaskToLoader([this, protectedThis = makeRef(*this), disabled] (ScriptExecutionContext&amp;) {
156         ASSERT(isMainThread());
<span class="line-modified">157         m_page-&gt;setResourceCachingDisabledByWebInspector(disabled);</span>
158     });
159 }
160 
161 Ref&lt;CacheStorageConnection&gt; ServiceWorkerThreadProxy::createCacheStorageConnection()
162 {
163     ASSERT(isMainThread());
164     if (!m_cacheStorageConnection)
<span class="line-modified">165         m_cacheStorageConnection = m_cacheStorageProvider.createCacheStorageConnection();</span>
166     return *m_cacheStorageConnection;
167 }
168 
169 std::unique_ptr&lt;FetchLoader&gt; ServiceWorkerThreadProxy::createBlobLoader(FetchLoaderClient&amp; client, const URL&amp; blobURL)
170 {
171     auto loader = makeUnique&lt;FetchLoader&gt;(client, nullptr);
172     loader-&gt;startLoadingBlobURL(m_document, blobURL);
173     if (!loader-&gt;isStarted())
174         return nullptr;
175     return loader;
176 }
177 
178 void ServiceWorkerThreadProxy::networkStateChanged(bool isOnLine)
179 {
180     for (auto* proxy : allServiceWorkerThreadProxies())
181         proxy-&gt;notifyNetworkStateChange(isOnLine);
182 }
183 
184 void ServiceWorkerThreadProxy::notifyNetworkStateChange(bool isOnline)
185 {
186     if (m_isTerminatingOrTerminated)
187         return;
188 
189     postTaskForModeToWorkerGlobalScope([isOnline] (ScriptExecutionContext&amp; context) {
190         auto&amp; globalScope = downcast&lt;WorkerGlobalScope&gt;(context);
191         globalScope.setIsOnline(isOnline);
<span class="line-modified">192         globalScope.eventLoop().queueTask(TaskSource::DOMManipulation, [globalScope = makeRef(globalScope), isOnline] {</span>
<span class="line-added">193             globalScope-&gt;dispatchEvent(Event::create(isOnline ? eventNames().onlineEvent : eventNames().offlineEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
<span class="line-added">194         });</span>
195     }, WorkerRunLoop::defaultMode());
196 }
197 
198 void ServiceWorkerThreadProxy::startFetch(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier, Ref&lt;ServiceWorkerFetch::Client&gt;&amp;&amp; client, Optional&lt;ServiceWorkerClientIdentifier&gt;&amp;&amp; clientId, ResourceRequest&amp;&amp; request, String&amp;&amp; referrer, FetchOptions&amp;&amp; options)
199 {
200     auto key = std::make_pair(connectionIdentifier, fetchIdentifier);
201 
<span class="line-added">202     if (m_ongoingFetchTasks.isEmpty())</span>
<span class="line-added">203         thread().startFetchEventMonitoring();</span>
<span class="line-added">204 </span>
205     ASSERT(!m_ongoingFetchTasks.contains(key));
206     m_ongoingFetchTasks.add(key, client.copyRef());
<span class="line-modified">207     postTaskForModeToWorkerGlobalScope([this, protectedThis = makeRef(*this), client = WTFMove(client), clientId, request = request.isolatedCopy(), referrer = referrer.isolatedCopy(), options = options.isolatedCopy()](auto&amp;) mutable {</span>
<span class="line-added">208         thread().queueTaskToFireFetchEvent(WTFMove(client), WTFMove(clientId), WTFMove(request), WTFMove(referrer), WTFMove(options));</span>
<span class="line-added">209     }, WorkerRunLoop::defaultMode());</span>
210 }
211 
212 void ServiceWorkerThreadProxy::cancelFetch(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier)
213 {
214     auto client = m_ongoingFetchTasks.take(std::make_pair(connectionIdentifier, fetchIdentifier));
215     if (!client)
216         return;
217 
<span class="line-added">218     if (m_ongoingFetchTasks.isEmpty())</span>
<span class="line-added">219         thread().stopFetchEventMonitoring();</span>
<span class="line-added">220 </span>
221     postTaskForModeToWorkerGlobalScope([client = WTFMove(client.value())] (ScriptExecutionContext&amp;) {
222         client-&gt;cancel();
223     }, WorkerRunLoop::defaultMode());
224 }
225 
226 void ServiceWorkerThreadProxy::continueDidReceiveFetchResponse(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier)
227 {
228     auto client = m_ongoingFetchTasks.get(std::make_pair(connectionIdentifier, fetchIdentifier));
229     if (!client)
230         return;
231 
232     postTaskForModeToWorkerGlobalScope([client = makeRef(*client)] (ScriptExecutionContext&amp;) {
233         client-&gt;continueDidReceiveResponse();
234     }, WorkerRunLoop::defaultMode());
235 }
236 
237 void ServiceWorkerThreadProxy::removeFetch(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier)
238 {
239     m_ongoingFetchTasks.remove(std::make_pair(connectionIdentifier, fetchIdentifier));
<span class="line-added">240 </span>
<span class="line-added">241     if (m_ongoingFetchTasks.isEmpty())</span>
<span class="line-added">242         thread().stopFetchEventMonitoring();</span>
<span class="line-added">243 }</span>
<span class="line-added">244 </span>
<span class="line-added">245 void ServiceWorkerThreadProxy::postMessageToServiceWorker(MessageWithMessagePorts&amp;&amp; message, ServiceWorkerOrClientData&amp;&amp; sourceData)</span>
<span class="line-added">246 {</span>
<span class="line-added">247     thread().willPostTaskToFireMessageEvent();</span>
<span class="line-added">248     thread().runLoop().postTask([this, protectedThis = makeRef(*this), message = WTFMove(message), sourceData = WTFMove(sourceData)](auto&amp;) mutable {</span>
<span class="line-added">249         thread().queueTaskToPostMessage(WTFMove(message), WTFMove(sourceData));</span>
<span class="line-added">250     });</span>
<span class="line-added">251 }</span>
<span class="line-added">252 </span>
<span class="line-added">253 void ServiceWorkerThreadProxy::fireInstallEvent()</span>
<span class="line-added">254 {</span>
<span class="line-added">255     thread().willPostTaskToFireInstallEvent();</span>
<span class="line-added">256     thread().runLoop().postTask([this, protectedThis = makeRef(*this)](auto&amp;) mutable {</span>
<span class="line-added">257         thread().queueTaskToFireInstallEvent();</span>
<span class="line-added">258     });</span>
<span class="line-added">259 }</span>
<span class="line-added">260 </span>
<span class="line-added">261 void ServiceWorkerThreadProxy::fireActivateEvent()</span>
<span class="line-added">262 {</span>
<span class="line-added">263     thread().willPostTaskToFireActivateEvent();</span>
<span class="line-added">264     thread().runLoop().postTask([this, protectedThis = makeRef(*this)](auto&amp;) mutable {</span>
<span class="line-added">265         thread().queueTaskToFireActivateEvent();</span>
<span class="line-added">266     });</span>
267 }
268 
269 } // namespace WebCore
270 
271 #endif // ENABLE(SERVICE_WORKER)
</pre>
</td>
</tr>
</table>
<center><a href="ServiceWorkerThread.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerThreadProxy.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLImageElement.h b/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLImageElement.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLImageElement.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLImageElement.h
@@ -26,27 +26,31 @@
 #include "DecodingOptions.h"
 #include "FormNamedItem.h"
 #include "GraphicsLayer.h"
 #include "GraphicsTypes.h"
 #include "HTMLElement.h"
-#include "HTMLImageLoader.h"
+#include "MediaQueryEvaluator.h"
+#include <wtf/WeakPtr.h>
 
 namespace WebCore {
 
+class CachedImage;
+class DeferredPromise;
 class EditableImageReference;
 class HTMLAttachmentElement;
 class HTMLFormElement;
+class HTMLImageLoader;
 class HTMLMapElement;
 
 struct ImageCandidate;
 
 class HTMLImageElement : public HTMLElement, public FormNamedItem {
     WTF_MAKE_ISO_ALLOCATED(HTMLImageElement);
     friend class HTMLFormElement;
 public:
     static Ref<HTMLImageElement> create(Document&);
-    static Ref<HTMLImageElement> create(const QualifiedName&, Document&, HTMLFormElement*);
+    static Ref<HTMLImageElement> create(const QualifiedName&, Document&, HTMLFormElement* = nullptr, bool createdByParser = false);
     static Ref<HTMLImageElement> createForJSConstructor(Document&, Optional<unsigned> width, Optional<unsigned> height);
 
     virtual ~HTMLImageElement();
 
     WEBCORE_EXPORT unsigned width(bool ignorePendingStylesheets = false);
@@ -63,13 +67,13 @@
 
     const AtomString& altText() const;
 
     CompositeOperator compositeOperator() const { return m_compositeOperator; }
 
-    CachedImage* cachedImage() const { return m_imageLoader.image(); }
+    WEBCORE_EXPORT CachedImage* cachedImage() const;
 
-    void setLoadManually(bool loadManually) { m_imageLoader.setLoadManually(loadManually); }
+    void setLoadManually(bool);
 
     bool matchesUsemap(const AtomStringImpl&) const;
     HTMLMapElement* associatedMapElement() const;
 
     WEBCORE_EXPORT const AtomString& alt() const;
@@ -101,12 +105,12 @@
     void setAttachmentElement(Ref<HTMLAttachmentElement>&&);
     RefPtr<HTMLAttachmentElement> attachmentElement() const;
     const String& attachmentIdentifier() const;
 #endif
 
-    bool hasPendingActivity() const { return m_imageLoader.hasPendingActivity(); }
-    size_t pendingDecodePromisesCountForTesting() const { return m_imageLoader.pendingDecodePromisesCountForTesting(); }
+    bool hasPendingActivity() const;
+    WEBCORE_EXPORT size_t pendingDecodePromisesCountForTesting() const;
 
     bool canContainRangeEndPoint() const override { return false; }
 
     const AtomString& imageSourceURL() const override;
 
@@ -122,12 +126,19 @@
     WEBCORE_EXPORT GraphicsLayer::EmbeddedViewID editableImageViewID() const;
     WEBCORE_EXPORT bool hasEditableImageAttribute() const;
 
     void defaultEventHandler(Event&) final;
 
+    bool createdByParser() const { return m_createdByParser; }
+
+    bool isDroppedImagePlaceholder() const { return m_isDroppedImagePlaceholder; }
+    void setIsDroppedImagePlaceholder() { m_isDroppedImagePlaceholder = true; }
+
+    void evaluateDynamicMediaQueryDependencies();
+
 protected:
-    HTMLImageElement(const QualifiedName&, Document&, HTMLFormElement* = 0);
+    HTMLImageElement(const QualifiedName&, Document&, HTMLFormElement* = nullptr, bool createdByParser = false);
 
     void didMoveToNewDocument(Document& oldDocument, Document& newDocument) override;
 
 private:
     void parseAttribute(const QualifiedName&, const AtomString&) override;
@@ -165,32 +176,37 @@
 
     void updateEditableImage();
 
     void copyNonAttributePropertiesFromElement(const Element&) final;
 
+    float effectiveImageDevicePixelRatio() const;
+
 #if ENABLE(SERVICE_CONTROLS)
     void updateImageControls();
     void tryCreateImageControls();
     void destroyImageControls();
     bool hasImageControls() const;
     bool childShouldCreateRenderer(const Node&) const override;
 #endif
 
-    HTMLImageLoader m_imageLoader;
+    std::unique_ptr<HTMLImageLoader> m_imageLoader;
     WeakPtr<HTMLFormElement> m_form;
     WeakPtr<HTMLFormElement> m_formSetByParser;
 
     CompositeOperator m_compositeOperator;
     AtomString m_bestFitImageURL;
     AtomString m_currentSrc;
     AtomString m_parsedUsemap;
     float m_imageDevicePixelRatio;
     bool m_experimentalImageMenuEnabled;
     bool m_hadNameBeforeAttributeChanged { false }; // FIXME: We only need this because parseAttribute() can't see the old value.
+    bool m_createdByParser { false };
+    bool m_isDroppedImagePlaceholder { false };
 
     RefPtr<EditableImageReference> m_editableImage;
     WeakPtr<HTMLPictureElement> m_pictureElement;
+    MediaQueryDynamicResults m_mediaQueryDynamicResults;
 
 #if ENABLE(ATTACHMENT_ELEMENT)
     String m_pendingClonedAttachmentID;
 #endif
 

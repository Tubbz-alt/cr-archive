diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderRuby.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderRuby.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderRuby.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderRuby.cpp
@@ -46,11 +46,13 @@
 {
     ASSERT(!object
         || !isRuby(object->parent())
         || is<RenderRubyRun>(*object)
         || (object->isInline() && (object->isBeforeContent() || object->isAfterContent()))
-        || (object->isAnonymous() && is<RenderBlock>(*object) && object->style().display() == DisplayType::InlineBlock));
+        || (object->isAnonymous() && is<RenderBlock>(*object) && object->style().display() == DisplayType::InlineBlock)
+        || object->isRenderMultiColumnFlow()
+        || object->isRenderMultiColumnSet());
 
     return object
         && isRuby(object->parent())
         && is<RenderBlock>(*object)
         && !is<RenderRubyRun>(*object);
@@ -70,21 +72,21 @@
         && !object->nextSibling()
         && downcast<RenderBlock>(*object).firstChild()
         && downcast<RenderBlock>(*object).firstChild()->style().styleType() == PseudoId::After;
 }
 
-#ifndef ASSERT_DISABLED
+#if ASSERT_ENABLED
 static inline bool isRubyChildForNormalRemoval(const RenderObject& object)
 {
     return object.isRubyRun()
     || object.isBeforeContent()
     || object.isAfterContent()
     || object.isRenderMultiColumnFlow()
     || object.isRenderMultiColumnSet()
     || isAnonymousRubyInlineBlock(&object);
 }
-#endif
+#endif // ASSERT_ENABLED
 
 static inline RenderBlock* rubyBeforeBlock(const RenderElement* ruby)
 {
     RenderObject* child = ruby->firstChild();
     return isRubyBeforeBlock(child) ? downcast<RenderBlock>(child) : nullptr;
@@ -107,11 +109,11 @@
 {
     RenderObject* child = ruby->lastChild();
     if (child && !is<RenderRubyRun>(*child))
         child = child->previousSibling();
     if (!is<RenderRubyRun>(child)) {
-        ASSERT(!child || child->isBeforeContent() || child == rubyBeforeBlock(ruby));
+        ASSERT(!child || child->isBeforeContent() || child == rubyBeforeBlock(ruby) || child->isRenderMultiColumnFlow() || child->isRenderMultiColumnSet());
         return nullptr;
     }
     return downcast<RenderRubyRun>(child);
 }
 
@@ -211,19 +213,20 @@
             // the old text goes into a new run that is inserted as next sibling.
             ASSERT(beforeChild->parent() == &parent);
             RenderElement* ruby = parent.parent();
             ASSERT(isRuby(ruby));
             auto newRun = RenderRubyRun::staticCreateRubyRun(ruby);
+            auto& run = *newRun;
             m_builder.attach(*ruby, WTFMove(newRun), parent.nextSibling());
             // Add the new ruby text and move the old one to the new run
             // Note: Doing it in this order and not using RenderRubyRun's methods,
             // in order to avoid automatic removal of the ruby run in case there is no
             // other child besides the old ruby text.
             m_builder.blockFlowBuilder().attach(parent, WTFMove(child), beforeChild);
             auto takenBeforeChild = m_builder.blockBuilder().detach(parent, *beforeChild);
 
-            m_builder.attach(*newRun, WTFMove(takenBeforeChild));
+            m_builder.attach(run, WTFMove(takenBeforeChild));
             return;
         }
         if (parent.hasRubyBase()) {
             // Insertion before a ruby base object.
             // In this case we need insert a new run before the current one and split the base.
@@ -381,13 +384,11 @@
 RenderPtr<RenderObject> RenderTreeBuilder::Ruby::detach(RenderRubyAsInline& parent, RenderObject& child)
 {
     // If the child's parent is *this (must be a ruby run or generated content or anonymous block),
     // just use the normal remove method.
     if (child.parent() == &parent) {
-#ifndef ASSERT_DISABLED
         ASSERT(isRubyChildForNormalRemoval(child));
-#endif
         return m_builder.detachFromRenderElement(parent, child);
     }
     // If the child's parent is an anoymous block (must be generated :before/:after content)
     // just use the block's remove method.
     if (isAnonymousRubyInlineBlock(child.parent())) {
@@ -405,13 +406,11 @@
 RenderPtr<RenderObject> RenderTreeBuilder::Ruby::detach(RenderRubyAsBlock& parent, RenderObject& child)
 {
     // If the child's parent is *this (must be a ruby run or generated content or anonymous block),
     // just use the normal remove method.
     if (child.parent() == &parent) {
-#ifndef ASSERT_DISABLED
         ASSERT(isRubyChildForNormalRemoval(child));
-#endif
         return m_builder.blockBuilder().detach(parent, child);
     }
     // If the child's parent is an anoymous block (must be generated :before/:after content)
     // just use the block's remove method.
     if (isAnonymousRubyInlineBlock(child.parent())) {

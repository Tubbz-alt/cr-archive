<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/testb3.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="air/testair.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="testb3_1.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/testb3.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 


  26 #include &quot;AirCode.h&quot;
  27 #include &quot;AirInstInlines.h&quot;
  28 #include &quot;AirValidate.h&quot;
  29 #include &quot;AllowMacroScratchRegisterUsage.h&quot;
  30 #include &quot;B3ArgumentRegValue.h&quot;
  31 #include &quot;B3AtomicValue.h&quot;
  32 #include &quot;B3BasicBlockInlines.h&quot;
  33 #include &quot;B3BreakCriticalEdges.h&quot;
  34 #include &quot;B3CCallValue.h&quot;
  35 #include &quot;B3Compilation.h&quot;
  36 #include &quot;B3Compile.h&quot;
  37 #include &quot;B3ComputeDivisionMagic.h&quot;
  38 #include &quot;B3Const32Value.h&quot;
  39 #include &quot;B3Const64Value.h&quot;
  40 #include &quot;B3ConstPtrValue.h&quot;
  41 #include &quot;B3Effects.h&quot;
  42 #include &quot;B3FenceValue.h&quot;
  43 #include &quot;B3FixSSA.h&quot;
  44 #include &quot;B3Generate.h&quot;
  45 #include &quot;B3LowerToAir.h&quot;
</pre>
<hr />
<pre>
 246 {
 247     checkDisassembly(
 248         compilation,
 249         [&amp;] (const char* disassembly) -&gt; bool {
 250             return strstr(disassembly, text);
 251         },
 252         toCString(&quot;Expected to find &quot;, text, &quot; but didnt!&quot;));
 253 }
 254 
 255 inline void checkDoesNotUseInstruction(Compilation&amp; compilation, const char* text)
 256 {
 257     checkDisassembly(
 258         compilation,
 259         [&amp;] (const char* disassembly) -&gt; bool {
 260             return !strstr(disassembly, text);
 261         },
 262         toCString(&quot;Did not expected to find &quot;, text, &quot; but it&#39;s there!&quot;));
 263 }
 264 
 265 template&lt;typename Type&gt;
<span class="line-modified"> 266 struct Operand {</span>
 267     const char* name;
 268     Type value;
 269 };
 270 
<span class="line-modified"> 271 typedef Operand&lt;int64_t&gt; Int64Operand;</span>
<span class="line-modified"> 272 typedef Operand&lt;int32_t&gt; Int32Operand;</span>


 273 
<span class="line-modified"> 274 #define MAKE_OPERAND(value) Operand&lt;decltype(value)&gt; { #value, value }</span>
 275 
 276 template&lt;typename FloatType&gt;
<span class="line-modified"> 277 void populateWithInterestingValues(Vector&lt;Operand&lt;FloatType&gt;&gt;&amp; operands)</span>
 278 {
 279     operands.append({ &quot;0.&quot;, static_cast&lt;FloatType&gt;(0.) });
 280     operands.append({ &quot;-0.&quot;, static_cast&lt;FloatType&gt;(-0.) });
 281     operands.append({ &quot;0.4&quot;, static_cast&lt;FloatType&gt;(0.5) });
 282     operands.append({ &quot;-0.4&quot;, static_cast&lt;FloatType&gt;(-0.5) });
 283     operands.append({ &quot;0.5&quot;, static_cast&lt;FloatType&gt;(0.5) });
 284     operands.append({ &quot;-0.5&quot;, static_cast&lt;FloatType&gt;(-0.5) });
 285     operands.append({ &quot;0.6&quot;, static_cast&lt;FloatType&gt;(0.6) });
 286     operands.append({ &quot;-0.6&quot;, static_cast&lt;FloatType&gt;(-0.6) });
 287     operands.append({ &quot;1.&quot;, static_cast&lt;FloatType&gt;(1.) });
 288     operands.append({ &quot;-1.&quot;, static_cast&lt;FloatType&gt;(-1.) });
 289     operands.append({ &quot;2.&quot;, static_cast&lt;FloatType&gt;(2.) });
 290     operands.append({ &quot;-2.&quot;, static_cast&lt;FloatType&gt;(-2.) });
 291     operands.append({ &quot;M_PI&quot;, static_cast&lt;FloatType&gt;(M_PI) });
 292     operands.append({ &quot;-M_PI&quot;, static_cast&lt;FloatType&gt;(-M_PI) });
 293     operands.append({ &quot;min&quot;, std::numeric_limits&lt;FloatType&gt;::min() });
 294     operands.append({ &quot;max&quot;, std::numeric_limits&lt;FloatType&gt;::max() });
 295     operands.append({ &quot;lowest&quot;, std::numeric_limits&lt;FloatType&gt;::lowest() });
 296     operands.append({ &quot;epsilon&quot;, std::numeric_limits&lt;FloatType&gt;::epsilon() });
 297     operands.append({ &quot;infiniti&quot;, std::numeric_limits&lt;FloatType&gt;::infinity() });
 298     operands.append({ &quot;-infiniti&quot;, - std::numeric_limits&lt;FloatType&gt;::infinity() });
 299     operands.append({ &quot;PNaN&quot;, static_cast&lt;FloatType&gt;(PNaN) });
 300 }
 301 
 302 template&lt;typename FloatType&gt;
<span class="line-modified"> 303 Vector&lt;Operand&lt;FloatType&gt;&gt; floatingPointOperands()</span>
 304 {
<span class="line-modified"> 305     Vector&lt;Operand&lt;FloatType&gt;&gt; operands;</span>
 306     populateWithInterestingValues(operands);
 307     return operands;
 308 };
 309 
 310 inline Vector&lt;Int64Operand&gt; int64Operands()
 311 {
 312     Vector&lt;Int64Operand&gt; operands;
 313     operands.append({ &quot;0&quot;, 0 });
 314     operands.append({ &quot;1&quot;, 1 });
 315     operands.append({ &quot;-1&quot;, -1 });
 316     operands.append({ &quot;42&quot;, 42 });
 317     operands.append({ &quot;-42&quot;, -42 });
 318     operands.append({ &quot;int64-max&quot;, std::numeric_limits&lt;int64_t&gt;::max() });
 319     operands.append({ &quot;int64-min&quot;, std::numeric_limits&lt;int64_t&gt;::min() });
 320     operands.append({ &quot;int32-max&quot;, std::numeric_limits&lt;int32_t&gt;::max() });
 321     operands.append({ &quot;int32-min&quot;, std::numeric_limits&lt;int32_t&gt;::min() });
 322     operands.append({ &quot;uint64-max&quot;, static_cast&lt;int64_t&gt;(std::numeric_limits&lt;uint64_t&gt;::max()) });
 323     operands.append({ &quot;uint64-min&quot;, static_cast&lt;int64_t&gt;(std::numeric_limits&lt;uint64_t&gt;::min()) });
 324     operands.append({ &quot;uint32-max&quot;, static_cast&lt;int64_t&gt;(std::numeric_limits&lt;uint32_t&gt;::max()) });
 325     operands.append({ &quot;uint32-min&quot;, static_cast&lt;int64_t&gt;(std::numeric_limits&lt;uint32_t&gt;::min()) });
 326 
 327     return operands;
 328 }
 329 
 330 inline Vector&lt;Int32Operand&gt; int32Operands()
 331 {
 332     Vector&lt;Int32Operand&gt; operands({
 333         { &quot;0&quot;, 0 },
 334         { &quot;1&quot;, 1 },
 335         { &quot;-1&quot;, -1 },
 336         { &quot;42&quot;, 42 },
 337         { &quot;-42&quot;, -42 },
 338         { &quot;int32-max&quot;, std::numeric_limits&lt;int32_t&gt;::max() },
 339         { &quot;int32-min&quot;, std::numeric_limits&lt;int32_t&gt;::min() },
 340         { &quot;uint32-max&quot;, static_cast&lt;int32_t&gt;(std::numeric_limits&lt;uint32_t&gt;::max()) },
 341         { &quot;uint32-min&quot;, static_cast&lt;int32_t&gt;(std::numeric_limits&lt;uint32_t&gt;::min()) }
 342     });
 343     return operands;
 344 }
 345 
































 346 inline void add32(CCallHelpers&amp; jit, GPRReg src1, GPRReg src2, GPRReg dest)
 347 {
 348     if (src2 == dest)
 349         jit.add32(src1, dest);
 350     else {
 351         jit.move(src1, dest);
 352         jit.add32(src2, dest);
 353     }
 354 }
 355 
 356 template&lt;typename LoadedType, typename EffectiveType&gt;
 357 EffectiveType modelLoad(EffectiveType value);
 358 
 359 template&lt;typename LoadedType, typename EffectiveType&gt;
 360 EffectiveType modelLoad(EffectiveType value)
 361 {
 362     union {
 363         EffectiveType original;
 364         LoadedType loaded;
 365     } u;
</pre>
<hr />
<pre>
 442 void testTrappingLoadDCE();
 443 void testTrappingStoreElimination();
 444 void testMoveConstants();
 445 void testPCOriginMapDoesntInsertNops();
 446 void testBitOrBitOrArgImmImm32(int, int, int c);
 447 void testBitOrImmBitOrArgImm32(int, int, int c);
 448 double bitOrDouble(double, double);
 449 void testBitOrArgDouble(double);
 450 void testBitOrArgsDouble(double, double);
 451 void testBitOrArgImmDouble(double, double);
 452 void testBitOrImmsDouble(double, double);
 453 float bitOrFloat(float, float);
 454 void testBitOrArgFloat(float);
 455 void testBitOrArgsFloat(float, float);
 456 void testBitOrArgImmFloat(float, float);
 457 void testBitOrImmsFloat(float, float);
 458 void testBitOrArgsFloatWithUselessDoubleConversion(float, float);
 459 void testBitXorArgs(int64_t, int64_t);
 460 void testBitXorSameArg(int64_t);
 461 void testBitXorAndAndArgs(int64_t, int64_t, int64_t c);

 462 void testBitXorAndSameArgs(int64_t, int64_t);

 463 void testBitXorImms(int64_t, int64_t);
 464 void testBitXorArgImm(int64_t, int64_t);
 465 void testBitXorImmArg(int64_t, int64_t);
 466 void testBitXorBitXorArgImmImm(int64_t, int64_t, int64_t c);
 467 void testBitXorImmBitXorArgImm(int64_t, int64_t, int64_t c);
 468 void testBitXorArgs32(int, int);
 469 void testBitXorSameArg32(int);
 470 void testBitXorImms32(int, int);
 471 void testBitXorArgImm32(int, int);
 472 void testBitXorImmArg32(int, int);
 473 void testBitXorBitXorArgImmImm32(int, int, int c);
 474 void testBitXorImmBitXorArgImm32(int, int, int c);
 475 void testBitNotArg(int64_t);
 476 void testBitNotImm(int64_t);
 477 void testBitNotMem(int64_t);
 478 void testBitNotArg32(int32_t);
 479 void testBitNotImm32(int32_t);
 480 void testBitNotMem32(int32_t);
 481 void testNotOnBooleanAndBranch32(int64_t, int64_t);
 482 void testBitNotOnBooleanAndBranch32(int64_t, int64_t);
</pre>
<hr />
<pre>
 742 void testAddArgs(int, int);
 743 void testAddArgImm(int, int);
 744 void testAddImmArg(int, int);
 745 void testAddArgMem(int64_t, int64_t);
 746 void testAddMemArg(int64_t, int64_t);
 747 void testAddImmMem(int64_t, int64_t);
 748 void testAddArg32(int);
 749 void testAddArgs32(int, int);
 750 void testAddArgMem32(int32_t, int32_t);
 751 void testAddMemArg32(int32_t, int32_t);
 752 void testAddImmMem32(int32_t, int32_t);
 753 void testAddNeg1(int, int);
 754 void testAddNeg2(int, int);
 755 void testAddArgZeroImmZDef();
 756 void testAddLoadTwice();
 757 void testAddArgDouble(double);
 758 void testCheckAddArgumentAliasing64();
 759 void testCheckAddArgumentAliasing32();
 760 void testCheckAddSelfOverflow64();
 761 void testCheckAddSelfOverflow32();




 762 void testCheckSubImm();
 763 void testCheckSubBadImm();
 764 void testCheckSub();
 765 double doubleSub(double, double);
 766 void testCheckSub64();
 767 void testCheckSubFold(int, int);
 768 void testCheckSubFoldFail(int, int);
 769 void testCheckNeg();
 770 void testCheckNeg64();
 771 void testCheckMul();
 772 void testCheckMulMemory();
 773 void testCheckMul2();
 774 void testCheckMul64();
 775 void testCheckMulFold(int, int);
 776 void testCheckMulFoldFail(int, int);
 777 void testAddArgsDouble(double, double);
 778 void testAddArgImmDouble(double, double);
 779 void testAddImmArgDouble(double, double);
 780 void testAddImmsDouble(double, double);
 781 void testAddArgFloat(float);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2019-2020 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
<span class="line-added">  26 #pragma once</span>
<span class="line-added">  27 </span>
  28 #include &quot;AirCode.h&quot;
  29 #include &quot;AirInstInlines.h&quot;
  30 #include &quot;AirValidate.h&quot;
  31 #include &quot;AllowMacroScratchRegisterUsage.h&quot;
  32 #include &quot;B3ArgumentRegValue.h&quot;
  33 #include &quot;B3AtomicValue.h&quot;
  34 #include &quot;B3BasicBlockInlines.h&quot;
  35 #include &quot;B3BreakCriticalEdges.h&quot;
  36 #include &quot;B3CCallValue.h&quot;
  37 #include &quot;B3Compilation.h&quot;
  38 #include &quot;B3Compile.h&quot;
  39 #include &quot;B3ComputeDivisionMagic.h&quot;
  40 #include &quot;B3Const32Value.h&quot;
  41 #include &quot;B3Const64Value.h&quot;
  42 #include &quot;B3ConstPtrValue.h&quot;
  43 #include &quot;B3Effects.h&quot;
  44 #include &quot;B3FenceValue.h&quot;
  45 #include &quot;B3FixSSA.h&quot;
  46 #include &quot;B3Generate.h&quot;
  47 #include &quot;B3LowerToAir.h&quot;
</pre>
<hr />
<pre>
 248 {
 249     checkDisassembly(
 250         compilation,
 251         [&amp;] (const char* disassembly) -&gt; bool {
 252             return strstr(disassembly, text);
 253         },
 254         toCString(&quot;Expected to find &quot;, text, &quot; but didnt!&quot;));
 255 }
 256 
 257 inline void checkDoesNotUseInstruction(Compilation&amp; compilation, const char* text)
 258 {
 259     checkDisassembly(
 260         compilation,
 261         [&amp;] (const char* disassembly) -&gt; bool {
 262             return !strstr(disassembly, text);
 263         },
 264         toCString(&quot;Did not expected to find &quot;, text, &quot; but it&#39;s there!&quot;));
 265 }
 266 
 267 template&lt;typename Type&gt;
<span class="line-modified"> 268 struct B3Operand {</span>
 269     const char* name;
 270     Type value;
 271 };
 272 
<span class="line-modified"> 273 typedef B3Operand&lt;int64_t&gt; Int64Operand;</span>
<span class="line-modified"> 274 typedef B3Operand&lt;int32_t&gt; Int32Operand;</span>
<span class="line-added"> 275 typedef B3Operand&lt;int16_t&gt; Int16Operand;</span>
<span class="line-added"> 276 typedef B3Operand&lt;int8_t&gt; Int8Operand;</span>
 277 
<span class="line-modified"> 278 #define MAKE_OPERAND(value) B3Operand&lt;decltype(value)&gt; { #value, value }</span>
 279 
 280 template&lt;typename FloatType&gt;
<span class="line-modified"> 281 void populateWithInterestingValues(Vector&lt;B3Operand&lt;FloatType&gt;&gt;&amp; operands)</span>
 282 {
 283     operands.append({ &quot;0.&quot;, static_cast&lt;FloatType&gt;(0.) });
 284     operands.append({ &quot;-0.&quot;, static_cast&lt;FloatType&gt;(-0.) });
 285     operands.append({ &quot;0.4&quot;, static_cast&lt;FloatType&gt;(0.5) });
 286     operands.append({ &quot;-0.4&quot;, static_cast&lt;FloatType&gt;(-0.5) });
 287     operands.append({ &quot;0.5&quot;, static_cast&lt;FloatType&gt;(0.5) });
 288     operands.append({ &quot;-0.5&quot;, static_cast&lt;FloatType&gt;(-0.5) });
 289     operands.append({ &quot;0.6&quot;, static_cast&lt;FloatType&gt;(0.6) });
 290     operands.append({ &quot;-0.6&quot;, static_cast&lt;FloatType&gt;(-0.6) });
 291     operands.append({ &quot;1.&quot;, static_cast&lt;FloatType&gt;(1.) });
 292     operands.append({ &quot;-1.&quot;, static_cast&lt;FloatType&gt;(-1.) });
 293     operands.append({ &quot;2.&quot;, static_cast&lt;FloatType&gt;(2.) });
 294     operands.append({ &quot;-2.&quot;, static_cast&lt;FloatType&gt;(-2.) });
 295     operands.append({ &quot;M_PI&quot;, static_cast&lt;FloatType&gt;(M_PI) });
 296     operands.append({ &quot;-M_PI&quot;, static_cast&lt;FloatType&gt;(-M_PI) });
 297     operands.append({ &quot;min&quot;, std::numeric_limits&lt;FloatType&gt;::min() });
 298     operands.append({ &quot;max&quot;, std::numeric_limits&lt;FloatType&gt;::max() });
 299     operands.append({ &quot;lowest&quot;, std::numeric_limits&lt;FloatType&gt;::lowest() });
 300     operands.append({ &quot;epsilon&quot;, std::numeric_limits&lt;FloatType&gt;::epsilon() });
 301     operands.append({ &quot;infiniti&quot;, std::numeric_limits&lt;FloatType&gt;::infinity() });
 302     operands.append({ &quot;-infiniti&quot;, - std::numeric_limits&lt;FloatType&gt;::infinity() });
 303     operands.append({ &quot;PNaN&quot;, static_cast&lt;FloatType&gt;(PNaN) });
 304 }
 305 
 306 template&lt;typename FloatType&gt;
<span class="line-modified"> 307 Vector&lt;B3Operand&lt;FloatType&gt;&gt; floatingPointOperands()</span>
 308 {
<span class="line-modified"> 309     Vector&lt;B3Operand&lt;FloatType&gt;&gt; operands;</span>
 310     populateWithInterestingValues(operands);
 311     return operands;
 312 };
 313 
 314 inline Vector&lt;Int64Operand&gt; int64Operands()
 315 {
 316     Vector&lt;Int64Operand&gt; operands;
 317     operands.append({ &quot;0&quot;, 0 });
 318     operands.append({ &quot;1&quot;, 1 });
 319     operands.append({ &quot;-1&quot;, -1 });
 320     operands.append({ &quot;42&quot;, 42 });
 321     operands.append({ &quot;-42&quot;, -42 });
 322     operands.append({ &quot;int64-max&quot;, std::numeric_limits&lt;int64_t&gt;::max() });
 323     operands.append({ &quot;int64-min&quot;, std::numeric_limits&lt;int64_t&gt;::min() });
 324     operands.append({ &quot;int32-max&quot;, std::numeric_limits&lt;int32_t&gt;::max() });
 325     operands.append({ &quot;int32-min&quot;, std::numeric_limits&lt;int32_t&gt;::min() });
 326     operands.append({ &quot;uint64-max&quot;, static_cast&lt;int64_t&gt;(std::numeric_limits&lt;uint64_t&gt;::max()) });
 327     operands.append({ &quot;uint64-min&quot;, static_cast&lt;int64_t&gt;(std::numeric_limits&lt;uint64_t&gt;::min()) });
 328     operands.append({ &quot;uint32-max&quot;, static_cast&lt;int64_t&gt;(std::numeric_limits&lt;uint32_t&gt;::max()) });
 329     operands.append({ &quot;uint32-min&quot;, static_cast&lt;int64_t&gt;(std::numeric_limits&lt;uint32_t&gt;::min()) });
 330 
 331     return operands;
 332 }
 333 
 334 inline Vector&lt;Int32Operand&gt; int32Operands()
 335 {
 336     Vector&lt;Int32Operand&gt; operands({
 337         { &quot;0&quot;, 0 },
 338         { &quot;1&quot;, 1 },
 339         { &quot;-1&quot;, -1 },
 340         { &quot;42&quot;, 42 },
 341         { &quot;-42&quot;, -42 },
 342         { &quot;int32-max&quot;, std::numeric_limits&lt;int32_t&gt;::max() },
 343         { &quot;int32-min&quot;, std::numeric_limits&lt;int32_t&gt;::min() },
 344         { &quot;uint32-max&quot;, static_cast&lt;int32_t&gt;(std::numeric_limits&lt;uint32_t&gt;::max()) },
 345         { &quot;uint32-min&quot;, static_cast&lt;int32_t&gt;(std::numeric_limits&lt;uint32_t&gt;::min()) }
 346     });
 347     return operands;
 348 }
 349 
<span class="line-added"> 350 inline Vector&lt;Int16Operand&gt; int16Operands()</span>
<span class="line-added"> 351 {</span>
<span class="line-added"> 352     Vector&lt;Int16Operand&gt; operands({</span>
<span class="line-added"> 353         { &quot;0&quot;, 0 },</span>
<span class="line-added"> 354         { &quot;1&quot;, 1 },</span>
<span class="line-added"> 355         { &quot;-1&quot;, -1 },</span>
<span class="line-added"> 356         { &quot;42&quot;, 42 },</span>
<span class="line-added"> 357         { &quot;-42&quot;, -42 },</span>
<span class="line-added"> 358         { &quot;int16-max&quot;, std::numeric_limits&lt;int16_t&gt;::max() },</span>
<span class="line-added"> 359         { &quot;int16-min&quot;, std::numeric_limits&lt;int16_t&gt;::min() },</span>
<span class="line-added"> 360         { &quot;uint16-max&quot;, static_cast&lt;int16_t&gt;(std::numeric_limits&lt;uint16_t&gt;::max()) },</span>
<span class="line-added"> 361         { &quot;uint16-min&quot;, static_cast&lt;int16_t&gt;(std::numeric_limits&lt;uint16_t&gt;::min()) }</span>
<span class="line-added"> 362     });</span>
<span class="line-added"> 363     return operands;</span>
<span class="line-added"> 364 }</span>
<span class="line-added"> 365 </span>
<span class="line-added"> 366 inline Vector&lt;Int8Operand&gt; int8Operands()</span>
<span class="line-added"> 367 {</span>
<span class="line-added"> 368     Vector&lt;Int8Operand&gt; operands({</span>
<span class="line-added"> 369         { &quot;0&quot;, 0 },</span>
<span class="line-added"> 370         { &quot;1&quot;, 1 },</span>
<span class="line-added"> 371         { &quot;-1&quot;, -1 },</span>
<span class="line-added"> 372         { &quot;42&quot;, 42 },</span>
<span class="line-added"> 373         { &quot;-42&quot;, -42 },</span>
<span class="line-added"> 374         { &quot;int8-max&quot;, std::numeric_limits&lt;int8_t&gt;::max() },</span>
<span class="line-added"> 375         { &quot;int8-min&quot;, std::numeric_limits&lt;int8_t&gt;::min() },</span>
<span class="line-added"> 376         { &quot;uint8-max&quot;, static_cast&lt;int8_t&gt;(std::numeric_limits&lt;uint8_t&gt;::max()) },</span>
<span class="line-added"> 377         { &quot;uint8-min&quot;, static_cast&lt;int8_t&gt;(std::numeric_limits&lt;uint8_t&gt;::min()) }</span>
<span class="line-added"> 378     });</span>
<span class="line-added"> 379     return operands;</span>
<span class="line-added"> 380 }</span>
<span class="line-added"> 381 </span>
 382 inline void add32(CCallHelpers&amp; jit, GPRReg src1, GPRReg src2, GPRReg dest)
 383 {
 384     if (src2 == dest)
 385         jit.add32(src1, dest);
 386     else {
 387         jit.move(src1, dest);
 388         jit.add32(src2, dest);
 389     }
 390 }
 391 
 392 template&lt;typename LoadedType, typename EffectiveType&gt;
 393 EffectiveType modelLoad(EffectiveType value);
 394 
 395 template&lt;typename LoadedType, typename EffectiveType&gt;
 396 EffectiveType modelLoad(EffectiveType value)
 397 {
 398     union {
 399         EffectiveType original;
 400         LoadedType loaded;
 401     } u;
</pre>
<hr />
<pre>
 478 void testTrappingLoadDCE();
 479 void testTrappingStoreElimination();
 480 void testMoveConstants();
 481 void testPCOriginMapDoesntInsertNops();
 482 void testBitOrBitOrArgImmImm32(int, int, int c);
 483 void testBitOrImmBitOrArgImm32(int, int, int c);
 484 double bitOrDouble(double, double);
 485 void testBitOrArgDouble(double);
 486 void testBitOrArgsDouble(double, double);
 487 void testBitOrArgImmDouble(double, double);
 488 void testBitOrImmsDouble(double, double);
 489 float bitOrFloat(float, float);
 490 void testBitOrArgFloat(float);
 491 void testBitOrArgsFloat(float, float);
 492 void testBitOrArgImmFloat(float, float);
 493 void testBitOrImmsFloat(float, float);
 494 void testBitOrArgsFloatWithUselessDoubleConversion(float, float);
 495 void testBitXorArgs(int64_t, int64_t);
 496 void testBitXorSameArg(int64_t);
 497 void testBitXorAndAndArgs(int64_t, int64_t, int64_t c);
<span class="line-added"> 498 void testBitXorAndAndArgs32(int32_t, int32_t, int32_t c);</span>
 499 void testBitXorAndSameArgs(int64_t, int64_t);
<span class="line-added"> 500 void testBitXorAndSameArgs32(int32_t, int32_t);</span>
 501 void testBitXorImms(int64_t, int64_t);
 502 void testBitXorArgImm(int64_t, int64_t);
 503 void testBitXorImmArg(int64_t, int64_t);
 504 void testBitXorBitXorArgImmImm(int64_t, int64_t, int64_t c);
 505 void testBitXorImmBitXorArgImm(int64_t, int64_t, int64_t c);
 506 void testBitXorArgs32(int, int);
 507 void testBitXorSameArg32(int);
 508 void testBitXorImms32(int, int);
 509 void testBitXorArgImm32(int, int);
 510 void testBitXorImmArg32(int, int);
 511 void testBitXorBitXorArgImmImm32(int, int, int c);
 512 void testBitXorImmBitXorArgImm32(int, int, int c);
 513 void testBitNotArg(int64_t);
 514 void testBitNotImm(int64_t);
 515 void testBitNotMem(int64_t);
 516 void testBitNotArg32(int32_t);
 517 void testBitNotImm32(int32_t);
 518 void testBitNotMem32(int32_t);
 519 void testNotOnBooleanAndBranch32(int64_t, int64_t);
 520 void testBitNotOnBooleanAndBranch32(int64_t, int64_t);
</pre>
<hr />
<pre>
 780 void testAddArgs(int, int);
 781 void testAddArgImm(int, int);
 782 void testAddImmArg(int, int);
 783 void testAddArgMem(int64_t, int64_t);
 784 void testAddMemArg(int64_t, int64_t);
 785 void testAddImmMem(int64_t, int64_t);
 786 void testAddArg32(int);
 787 void testAddArgs32(int, int);
 788 void testAddArgMem32(int32_t, int32_t);
 789 void testAddMemArg32(int32_t, int32_t);
 790 void testAddImmMem32(int32_t, int32_t);
 791 void testAddNeg1(int, int);
 792 void testAddNeg2(int, int);
 793 void testAddArgZeroImmZDef();
 794 void testAddLoadTwice();
 795 void testAddArgDouble(double);
 796 void testCheckAddArgumentAliasing64();
 797 void testCheckAddArgumentAliasing32();
 798 void testCheckAddSelfOverflow64();
 799 void testCheckAddSelfOverflow32();
<span class="line-added"> 800 void testCheckAddRemoveCheckWithSExt8(int8_t);</span>
<span class="line-added"> 801 void testCheckAddRemoveCheckWithSExt16(int16_t);</span>
<span class="line-added"> 802 void testCheckAddRemoveCheckWithSExt32(int32_t);</span>
<span class="line-added"> 803 void testCheckAddRemoveCheckWithZExt32(int32_t);</span>
 804 void testCheckSubImm();
 805 void testCheckSubBadImm();
 806 void testCheckSub();
 807 double doubleSub(double, double);
 808 void testCheckSub64();
 809 void testCheckSubFold(int, int);
 810 void testCheckSubFoldFail(int, int);
 811 void testCheckNeg();
 812 void testCheckNeg64();
 813 void testCheckMul();
 814 void testCheckMulMemory();
 815 void testCheckMul2();
 816 void testCheckMul64();
 817 void testCheckMulFold(int, int);
 818 void testCheckMulFoldFail(int, int);
 819 void testAddArgsDouble(double, double);
 820 void testAddArgImmDouble(double, double);
 821 void testAddImmArgDouble(double, double);
 822 void testAddImmsDouble(double, double);
 823 void testAddArgFloat(float);
</pre>
</td>
</tr>
</table>
<center><a href="air/testair.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="testb3_1.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
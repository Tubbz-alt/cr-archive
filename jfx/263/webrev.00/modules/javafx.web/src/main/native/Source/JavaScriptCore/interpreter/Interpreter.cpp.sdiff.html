<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/Interpreter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FrameTracers.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Interpreter.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/Interpreter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;Interpreter.h&quot;
  32 
  33 #include &quot;BatchedTransitionOptimizer.h&quot;
  34 #include &quot;Bytecodes.h&quot;
  35 #include &quot;CallFrameClosure.h&quot;
  36 #include &quot;CatchScope.h&quot;

  37 #include &quot;CodeBlock.h&quot;
  38 #include &quot;CodeCache.h&quot;
  39 #include &quot;DirectArguments.h&quot;
  40 #include &quot;ExecutableBaseInlines.h&quot;
  41 #include &quot;Heap.h&quot;
  42 #include &quot;Debugger.h&quot;
  43 #include &quot;DebuggerCallFrame.h&quot;
  44 #include &quot;DirectEvalCodeCache.h&quot;
  45 #include &quot;ErrorInstance.h&quot;
  46 #include &quot;EvalCodeBlock.h&quot;
  47 #include &quot;Exception.h&quot;
  48 #include &quot;ExceptionHelpers.h&quot;
  49 #include &quot;FrameTracers.h&quot;
  50 #include &quot;FunctionCodeBlock.h&quot;
  51 #include &quot;InterpreterInlines.h&quot;
  52 #include &quot;JITCodeInlines.h&quot;
  53 #include &quot;JSArrayInlines.h&quot;
  54 #include &quot;JSBoundFunction.h&quot;
  55 #include &quot;JSCInlines.h&quot;
<span class="line-removed">  56 #include &quot;JSFixedArray.h&quot;</span>
  57 #include &quot;JSImmutableButterfly.h&quot;
  58 #include &quot;JSLexicalEnvironment.h&quot;
  59 #include &quot;JSModuleEnvironment.h&quot;
  60 #include &quot;JSString.h&quot;
  61 #include &quot;JSWithScope.h&quot;
  62 #include &quot;LLIntCLoop.h&quot;
  63 #include &quot;LLIntThunks.h&quot;
  64 #include &quot;LiteralParser.h&quot;
  65 #include &quot;ModuleProgramCodeBlock.h&quot;
  66 #include &quot;ObjectPrototype.h&quot;
  67 #include &quot;Parser.h&quot;
  68 #include &quot;ProgramCodeBlock.h&quot;
<span class="line-modified">  69 #include &quot;ProtoCallFrame.h&quot;</span>
  70 #include &quot;RegExpObject.h&quot;
  71 #include &quot;Register.h&quot;
  72 #include &quot;RegisterAtOffsetList.h&quot;
  73 #include &quot;ScopedArguments.h&quot;
  74 #include &quot;StackAlignment.h&quot;
  75 #include &quot;StackFrame.h&quot;
  76 #include &quot;StackVisitor.h&quot;
  77 #include &quot;StrictEvalActivation.h&quot;
  78 #include &quot;StrongInlines.h&quot;
  79 #include &quot;Symbol.h&quot;
  80 #include &quot;VMEntryScope.h&quot;
  81 #include &quot;VMInlines.h&quot;
  82 #include &quot;VMInspector.h&quot;
  83 #include &quot;VirtualRegister.h&quot;
  84 #include &lt;limits.h&gt;
  85 #include &lt;stdio.h&gt;
  86 #include &lt;wtf/NeverDestroyed.h&gt;
  87 #include &lt;wtf/StackStats.h&gt;
  88 #include &lt;wtf/StdLibExtras.h&gt;
  89 #include &lt;wtf/StringPrintStream.h&gt;
  90 #include &lt;wtf/Threading.h&gt;
  91 #include &lt;wtf/text/StringBuilder.h&gt;
  92 
  93 #if ENABLE(JIT)
  94 #include &quot;JIT.h&quot;
  95 #endif
  96 
  97 #if ENABLE(WEBASSEMBLY)
  98 #include &quot;WasmContextInlines.h&quot;
  99 #include &quot;WebAssemblyFunction.h&quot;
 100 #endif
 101 
 102 namespace JSC {
 103 
<span class="line-modified"> 104 JSValue eval(CallFrame* callFrame)</span>
 105 {
<span class="line-modified"> 106     VM&amp; vm = callFrame-&gt;vm();</span>
 107     auto scope = DECLARE_THROW_SCOPE(vm);
 108 
 109     if (!callFrame-&gt;argumentCount())
 110         return jsUndefined();
 111 
 112     JSValue program = callFrame-&gt;argument(0);
 113     if (!program.isString())
 114         return program;
 115 
 116     TopCallFrameSetter topCallFrame(vm, callFrame);
<span class="line-removed"> 117     JSGlobalObject* globalObject = callFrame-&gt;lexicalGlobalObject();</span>
 118     if (!globalObject-&gt;evalEnabled()) {
<span class="line-modified"> 119         throwException(callFrame, scope, createEvalError(callFrame, globalObject-&gt;evalDisabledErrorMessage()));</span>
 120         return jsUndefined();
 121     }
<span class="line-modified"> 122     String programSource = asString(program)-&gt;value(callFrame);</span>
 123     RETURN_IF_EXCEPTION(scope, JSValue());
 124 
 125     CallFrame* callerFrame = callFrame-&gt;callerFrame();
 126     CallSiteIndex callerCallSiteIndex = callerFrame-&gt;callSiteIndex();
 127     CodeBlock* callerCodeBlock = callerFrame-&gt;codeBlock();
<span class="line-modified"> 128     JSScope* callerScopeChain = callerFrame-&gt;uncheckedR(callerCodeBlock-&gt;scopeRegister().offset()).Register::scope();</span>
 129     UnlinkedCodeBlock* callerUnlinkedCodeBlock = callerCodeBlock-&gt;unlinkedCodeBlock();
 130 
 131     bool isArrowFunctionContext = callerUnlinkedCodeBlock-&gt;isArrowFunction() || callerUnlinkedCodeBlock-&gt;isArrowFunctionContext();
 132 
 133     DerivedContextType derivedContextType = callerUnlinkedCodeBlock-&gt;derivedContextType();
 134     if (!isArrowFunctionContext &amp;&amp; callerUnlinkedCodeBlock-&gt;isClassContext()) {
 135         derivedContextType = callerUnlinkedCodeBlock-&gt;isConstructor()
 136             ? DerivedContextType::DerivedConstructorContext
 137             : DerivedContextType::DerivedMethodContext;
 138     }
 139 
 140     EvalContextType evalContextType;
<span class="line-modified"> 141     if (isFunctionParseMode(callerUnlinkedCodeBlock-&gt;parseMode()))</span>


 142         evalContextType = EvalContextType::FunctionEvalContext;
 143     else if (callerUnlinkedCodeBlock-&gt;codeType() == EvalCode)
 144         evalContextType = callerUnlinkedCodeBlock-&gt;evalContextType();
 145     else
 146         evalContextType = EvalContextType::None;
 147 
 148     DirectEvalExecutable* eval = callerCodeBlock-&gt;directEvalCodeCache().tryGet(programSource, callerCallSiteIndex);
 149     if (!eval) {
 150         if (!callerCodeBlock-&gt;isStrictMode()) {
 151             if (programSource.is8Bit()) {
<span class="line-modified"> 152                 LiteralParser&lt;LChar&gt; preparser(callFrame, programSource.characters8(), programSource.length(), NonStrictJSON);</span>
 153                 if (JSValue parsedObject = preparser.tryLiteralParse())
 154                     RELEASE_AND_RETURN(scope, parsedObject);
 155 
 156             } else {
<span class="line-modified"> 157                 LiteralParser&lt;UChar&gt; preparser(callFrame, programSource.characters16(), programSource.length(), NonStrictJSON);</span>
 158                 if (JSValue parsedObject = preparser.tryLiteralParse())
 159                     RELEASE_AND_RETURN(scope, parsedObject);
 160 
 161             }
 162             RETURN_IF_EXCEPTION(scope, JSValue());
 163         }
 164 
 165         VariableEnvironment variablesUnderTDZ;
 166         JSScope::collectClosureVariablesUnderTDZ(callerScopeChain, variablesUnderTDZ);
<span class="line-modified"> 167         eval = DirectEvalExecutable::create(callFrame, makeSource(programSource, callerCodeBlock-&gt;source().provider()-&gt;sourceOrigin()), callerCodeBlock-&gt;isStrictMode(), derivedContextType, isArrowFunctionContext, evalContextType, &amp;variablesUnderTDZ);</span>
 168         EXCEPTION_ASSERT(!!scope.exception() == !eval);
 169         if (!eval)
 170             return jsUndefined();
 171 
<span class="line-modified"> 172         callerCodeBlock-&gt;directEvalCodeCache().set(callFrame, callerCodeBlock, programSource, callerCallSiteIndex, eval);</span>
 173     }
 174 
 175     JSValue thisValue = callerFrame-&gt;thisValue();
 176     Interpreter* interpreter = vm.interpreter;
<span class="line-modified"> 177     RELEASE_AND_RETURN(scope, interpreter-&gt;execute(eval, callFrame, thisValue, callerScopeChain));</span>
 178 }
 179 
<span class="line-modified"> 180 unsigned sizeOfVarargs(CallFrame* callFrame, JSValue arguments, uint32_t firstVarArgOffset)</span>
 181 {
<span class="line-modified"> 182     VM&amp; vm = callFrame-&gt;vm();</span>
 183     auto scope = DECLARE_THROW_SCOPE(vm);
 184 
 185     if (UNLIKELY(!arguments.isCell())) {
 186         if (arguments.isUndefinedOrNull())
 187             return 0;
 188 
<span class="line-modified"> 189         throwException(callFrame, scope, createInvalidFunctionApplyParameterError(callFrame, arguments));</span>
 190         return 0;
 191     }
 192 
 193     JSCell* cell = arguments.asCell();
 194     unsigned length;
 195     switch (cell-&gt;type()) {
 196     case DirectArgumentsType:
<span class="line-modified"> 197         length = jsCast&lt;DirectArguments*&gt;(cell)-&gt;length(callFrame);</span>
 198         break;
 199     case ScopedArgumentsType:
<span class="line-modified"> 200         length = jsCast&lt;ScopedArguments*&gt;(cell)-&gt;length(callFrame);</span>
<span class="line-removed"> 201         break;</span>
<span class="line-removed"> 202     case JSFixedArrayType:</span>
<span class="line-removed"> 203         length = jsCast&lt;JSFixedArray*&gt;(cell)-&gt;size();</span>
 204         break;
 205     case JSImmutableButterflyType:
 206         length = jsCast&lt;JSImmutableButterfly*&gt;(cell)-&gt;length();
 207         break;
 208     case StringType:
 209     case SymbolType:
 210     case BigIntType:
<span class="line-modified"> 211         throwException(callFrame, scope, createInvalidFunctionApplyParameterError(callFrame,  arguments));</span>
 212         return 0;
 213 
 214     default:
 215         RELEASE_ASSERT(arguments.isObject());
<span class="line-modified"> 216         length = clampToUnsigned(toLength(callFrame, jsCast&lt;JSObject*&gt;(cell)));</span>
 217         break;
 218     }
 219     RETURN_IF_EXCEPTION(scope, 0);
 220 



 221     if (length &gt;= firstVarArgOffset)
 222         length -= firstVarArgOffset;
 223     else
 224         length = 0;
 225 
 226     return length;
 227 }
 228 
<span class="line-modified"> 229 unsigned sizeFrameForForwardArguments(CallFrame* callFrame, VM&amp; vm, unsigned numUsedStackSlots)</span>
 230 {
 231     auto scope = DECLARE_THROW_SCOPE(vm);
 232 
 233     unsigned length = callFrame-&gt;argumentCount();
 234     CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, length + 1);
 235     if (UNLIKELY(!vm.ensureStackCapacityFor(calleeFrame-&gt;registers())))
<span class="line-modified"> 236         throwStackOverflowError(callFrame, scope);</span>
 237 
 238     return length;
 239 }
 240 
<span class="line-modified"> 241 unsigned sizeFrameForVarargs(CallFrame* callFrame, VM&amp; vm, JSValue arguments, unsigned numUsedStackSlots, uint32_t firstVarArgOffset)</span>
 242 {
 243     auto scope = DECLARE_THROW_SCOPE(vm);
 244 
<span class="line-modified"> 245     unsigned length = sizeOfVarargs(callFrame, arguments, firstVarArgOffset);</span>
 246     RETURN_IF_EXCEPTION(scope, 0);
 247 
 248     CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, length + 1);
 249     if (UNLIKELY(length &gt; maxArguments || !vm.ensureStackCapacityFor(calleeFrame-&gt;registers()))) {
<span class="line-modified"> 250         throwStackOverflowError(callFrame, scope);</span>
 251         return 0;
 252     }
 253 
 254     return length;
 255 }
 256 
<span class="line-modified"> 257 void loadVarargs(CallFrame* callFrame, VirtualRegister firstElementDest, JSValue arguments, uint32_t offset, uint32_t length)</span>
 258 {
 259     if (UNLIKELY(!arguments.isCell()) || !length)
 260         return;
 261 
<span class="line-modified"> 262     VM&amp; vm = callFrame-&gt;vm();</span>
 263     auto scope = DECLARE_THROW_SCOPE(vm);
 264     JSCell* cell = arguments.asCell();
 265 
 266     switch (cell-&gt;type()) {
 267     case DirectArgumentsType:
 268         scope.release();
<span class="line-modified"> 269         jsCast&lt;DirectArguments*&gt;(cell)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);</span>
 270         return;
 271     case ScopedArgumentsType:
 272         scope.release();
<span class="line-modified"> 273         jsCast&lt;ScopedArguments*&gt;(cell)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);</span>
<span class="line-removed"> 274         return;</span>
<span class="line-removed"> 275     case JSFixedArrayType:</span>
<span class="line-removed"> 276         scope.release();</span>
<span class="line-removed"> 277         jsCast&lt;JSFixedArray*&gt;(cell)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);</span>
 278         return;
 279     case JSImmutableButterflyType:
 280         scope.release();
<span class="line-modified"> 281         jsCast&lt;JSImmutableButterfly*&gt;(cell)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);</span>
 282         return;
 283     default: {
 284         ASSERT(arguments.isObject());
 285         JSObject* object = jsCast&lt;JSObject*&gt;(cell);
 286         if (isJSArray(object)) {
 287             scope.release();
<span class="line-modified"> 288             jsCast&lt;JSArray*&gt;(object)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);</span>
 289             return;
 290         }
 291         unsigned i;
 292         for (i = 0; i &lt; length &amp;&amp; object-&gt;canGetIndexQuickly(i + offset); ++i)
<span class="line-modified"> 293             callFrame-&gt;r(firstElementDest + i) = object-&gt;getIndexQuickly(i + offset);</span>
 294         for (; i &lt; length; ++i) {
<span class="line-modified"> 295             JSValue value = object-&gt;get(callFrame, i + offset);</span>
 296             RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified"> 297             callFrame-&gt;r(firstElementDest + i) = value;</span>
 298         }
 299         return;
 300     } }
 301 }
 302 
<span class="line-modified"> 303 void setupVarargsFrame(CallFrame* callFrame, CallFrame* newCallFrame, JSValue arguments, uint32_t offset, uint32_t length)</span>
 304 {
 305     VirtualRegister calleeFrameOffset(newCallFrame - callFrame);
 306 
 307     loadVarargs(
<span class="line-modified"> 308         callFrame,</span>
<span class="line-modified"> 309         calleeFrameOffset + CallFrame::argumentOffset(0),</span>
 310         arguments, offset, length);
 311 
 312     newCallFrame-&gt;setArgumentCountIncludingThis(length + 1);
 313 }
 314 
<span class="line-modified"> 315 void setupVarargsFrameAndSetThis(CallFrame* callFrame, CallFrame* newCallFrame, JSValue thisValue, JSValue arguments, uint32_t firstVarArgOffset, uint32_t length)</span>
 316 {
<span class="line-modified"> 317     setupVarargsFrame(callFrame, newCallFrame, arguments, firstVarArgOffset, length);</span>
 318     newCallFrame-&gt;setThisValue(thisValue);
 319 }
 320 
<span class="line-modified"> 321 void setupForwardArgumentsFrame(CallFrame* execCaller, CallFrame* execCallee, uint32_t length)</span>
 322 {
 323     ASSERT(length == execCaller-&gt;argumentCount());
 324     unsigned offset = execCaller-&gt;argumentOffset(0) * sizeof(Register);
 325     memcpy(reinterpret_cast&lt;char*&gt;(execCallee) + offset, reinterpret_cast&lt;char*&gt;(execCaller) + offset, length * sizeof(Register));
 326     execCallee-&gt;setArgumentCountIncludingThis(length + 1);
 327 }
 328 
<span class="line-modified"> 329 void setupForwardArgumentsFrameAndSetThis(CallFrame* execCaller, CallFrame* execCallee, JSValue thisValue, uint32_t length)</span>
 330 {
<span class="line-modified"> 331     setupForwardArgumentsFrame(execCaller, execCallee, length);</span>
 332     execCallee-&gt;setThisValue(thisValue);
 333 }
 334 
 335 
 336 
 337 Interpreter::Interpreter(VM&amp; vm)
 338     : m_vm(vm)
 339 #if ENABLE(C_LOOP)
 340     , m_cloopStack(vm)
 341 #endif
 342 {
<span class="line-modified"> 343 #if !ASSERT_DISABLED</span>
 344     static std::once_flag assertOnceKey;
 345     std::call_once(assertOnceKey, [] {
 346         for (unsigned i = 0; i &lt; NUMBER_OF_BYTECODE_IDS; ++i) {
 347             OpcodeID opcodeID = static_cast&lt;OpcodeID&gt;(i);
 348             RELEASE_ASSERT(getOpcodeID(getOpcode(opcodeID)) == opcodeID);
 349         }
 350     });
<span class="line-modified"> 351 #endif // USE(LLINT_EMBEDDED_OPCODE_ID)</span>
 352 }
 353 
 354 Interpreter::~Interpreter()
 355 {
 356 }
 357 
 358 #if ENABLE(COMPUTED_GOTO_OPCODES)
<span class="line-modified"> 359 #if !USE(LLINT_EMBEDDED_OPCODE_ID) || !ASSERT_DISABLED</span>
 360 HashMap&lt;Opcode, OpcodeID&gt;&amp; Interpreter::opcodeIDTable()
 361 {
 362     static NeverDestroyed&lt;HashMap&lt;Opcode, OpcodeID&gt;&gt; opcodeIDTable;
 363 
 364     static std::once_flag initializeKey;
 365     std::call_once(initializeKey, [&amp;] {
 366         const Opcode* opcodeTable = LLInt::opcodeMap();
 367         for (unsigned i = 0; i &lt; NUMBER_OF_BYTECODE_IDS; ++i)
 368             opcodeIDTable.get().add(opcodeTable[i], static_cast&lt;OpcodeID&gt;(i));
 369     });
 370 
 371     return opcodeIDTable;
 372 }
<span class="line-modified"> 373 #endif // !USE(LLINT_EMBEDDED_OPCODE_ID) || !ASSERT_DISABLED</span>
 374 #endif // ENABLE(COMPUTED_GOTO_OPCODES)
 375 
<span class="line-modified"> 376 #if !ASSERT_DISABLED</span>
 377 bool Interpreter::isOpcode(Opcode opcode)
 378 {
 379 #if ENABLE(COMPUTED_GOTO_OPCODES)
 380     return opcode != HashTraits&lt;Opcode&gt;::emptyValue()
 381         &amp;&amp; !HashTraits&lt;Opcode&gt;::isDeletedValue(opcode)
 382         &amp;&amp; opcodeIDTable().contains(opcode);
 383 #else
 384     return opcode &gt;= 0 &amp;&amp; opcode &lt;= op_end;
 385 #endif
 386 }
<span class="line-modified"> 387 #endif // !ASSERT_DISABLED</span>
 388 
 389 class GetStackTraceFunctor {
 390 public:
 391     GetStackTraceFunctor(VM&amp; vm, JSCell* owner, Vector&lt;StackFrame&gt;&amp; results, size_t framesToSkip, size_t capacity)
 392         : m_vm(vm)
 393         , m_owner(owner)
 394         , m_results(results)
 395         , m_framesToSkip(framesToSkip)
 396         , m_remainingCapacityForFrameCapture(capacity)
 397     {
 398         m_results.reserveInitialCapacity(capacity);
 399     }
 400 
 401     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 402     {
 403         if (m_framesToSkip &gt; 0) {
 404             m_framesToSkip--;
 405             return StackVisitor::Continue;
 406         }
 407 
 408         if (m_remainingCapacityForFrameCapture) {
 409             if (visitor-&gt;isWasmFrame()) {
 410                 m_results.append(StackFrame(visitor-&gt;wasmFunctionIndexOrName()));
 411             } else if (!!visitor-&gt;codeBlock() &amp;&amp; !visitor-&gt;codeBlock()-&gt;unlinkedCodeBlock()-&gt;isBuiltinFunction()) {
 412                 m_results.append(
<span class="line-modified"> 413                     StackFrame(m_vm, m_owner, visitor-&gt;callee().asCell(), visitor-&gt;codeBlock(), visitor-&gt;bytecodeOffset()));</span>
 414             } else {
 415                 m_results.append(
 416                     StackFrame(m_vm, m_owner, visitor-&gt;callee().asCell()));
 417             }
 418 
 419             m_remainingCapacityForFrameCapture--;
 420             return StackVisitor::Continue;
 421         }
 422         return StackVisitor::Done;
 423     }
 424 
 425 private:
 426     VM&amp; m_vm;
 427     JSCell* m_owner;
 428     Vector&lt;StackFrame&gt;&amp; m_results;
 429     mutable size_t m_framesToSkip;
 430     mutable size_t m_remainingCapacityForFrameCapture;
 431 };
 432 
 433 void Interpreter::getStackTrace(JSCell* owner, Vector&lt;StackFrame&gt;&amp; results, size_t framesToSkip, size_t maxStackSize)
 434 {
 435     DisallowGC disallowGC;
 436     VM&amp; vm = m_vm;
 437     CallFrame* callFrame = vm.topCallFrame;
 438     if (!callFrame || !maxStackSize)
 439         return;
 440 
 441     size_t framesCount = 0;
 442     size_t maxFramesCountNeeded = maxStackSize + framesToSkip;
<span class="line-modified"> 443     StackVisitor::visit(callFrame, &amp;vm, [&amp;] (StackVisitor&amp;) -&gt; StackVisitor::Status {</span>
 444         if (++framesCount &lt; maxFramesCountNeeded)
 445             return StackVisitor::Continue;
 446         return StackVisitor::Done;
 447     });
 448     if (framesCount &lt;= framesToSkip)
 449         return;
 450 
 451     framesCount -= framesToSkip;
 452     framesCount = std::min(maxStackSize, framesCount);
 453 
 454     GetStackTraceFunctor functor(vm, owner, results, framesToSkip, framesCount);
<span class="line-modified"> 455     StackVisitor::visit(callFrame, &amp;vm, functor);</span>
 456     ASSERT(results.size() == results.capacity());
 457 }
 458 
 459 String Interpreter::stackTraceAsString(VM&amp; vm, const Vector&lt;StackFrame&gt;&amp; stackTrace)
 460 {
 461     // FIXME: JSStringJoiner could be more efficient than StringBuilder here.
 462     StringBuilder builder;
 463     for (unsigned i = 0; i &lt; stackTrace.size(); i++) {
 464         builder.append(String(stackTrace[i].toString(vm)));
 465         if (i != stackTrace.size() - 1)
 466             builder.append(&#39;\n&#39;);
 467     }
 468     return builder.toString();
 469 }
 470 
 471 ALWAYS_INLINE static HandlerInfo* findExceptionHandler(StackVisitor&amp; visitor, CodeBlock* codeBlock, RequiredHandler requiredHandler)
 472 {
 473     ASSERT(codeBlock);
 474 #if ENABLE(DFG_JIT)
 475     ASSERT(!visitor-&gt;isInlinedFrame());
 476 #endif
 477 
 478     CallFrame* callFrame = visitor-&gt;callFrame();
 479     unsigned exceptionHandlerIndex;
 480     if (JITCode::isOptimizingJIT(codeBlock-&gt;jitType()))
 481         exceptionHandlerIndex = callFrame-&gt;callSiteIndex().bits();
 482     else
<span class="line-modified"> 483         exceptionHandlerIndex = callFrame-&gt;bytecodeOffset();</span>
 484 
 485     return codeBlock-&gt;handlerForIndex(exceptionHandlerIndex, requiredHandler);
 486 }
 487 
 488 class GetCatchHandlerFunctor {
 489 public:
 490     GetCatchHandlerFunctor()
 491         : m_handler(0)
 492     {
 493     }
 494 
 495     HandlerInfo* handler() { return m_handler; }
 496 
 497     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 498     {
 499         visitor.unwindToMachineCodeBlockFrame();
 500 
 501         CodeBlock* codeBlock = visitor-&gt;codeBlock();
 502         if (!codeBlock)
 503             return StackVisitor::Continue;
 504 
 505         m_handler = findExceptionHandler(visitor, codeBlock, RequiredHandler::CatchHandler);
 506         if (m_handler)
 507             return StackVisitor::Done;
 508 
 509         return StackVisitor::Continue;
 510     }
 511 
 512 private:
 513     mutable HandlerInfo* m_handler;
 514 };
 515 
 516 ALWAYS_INLINE static void notifyDebuggerOfUnwinding(VM&amp; vm, CallFrame* callFrame)
 517 {

 518     auto catchScope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified"> 519     if (Debugger* debugger = vm.vmEntryGlobalObject(callFrame)-&gt;debugger()) {</span>
 520         SuspendExceptionScope scope(&amp;vm);
 521         if (callFrame-&gt;isAnyWasmCallee()
 522             || (callFrame-&gt;callee().isCell() &amp;&amp; callFrame-&gt;callee().asCell()-&gt;inherits&lt;JSFunction&gt;(vm)))
 523             debugger-&gt;unwindEvent(callFrame);
 524         else
 525             debugger-&gt;didExecuteProgram(callFrame);
 526         catchScope.assertNoException();
 527     }
 528 }
 529 
 530 class UnwindFunctor {
 531 public:
 532     UnwindFunctor(VM&amp; vm, CallFrame*&amp; callFrame, bool isTermination, CodeBlock*&amp; codeBlock, HandlerInfo*&amp; handler)
 533         : m_vm(vm)
 534         , m_callFrame(callFrame)
 535         , m_isTermination(isTermination)
 536         , m_codeBlock(codeBlock)
 537         , m_handler(handler)
 538     {
 539     }
 540 
 541     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 542     {
 543         visitor.unwindToMachineCodeBlockFrame();
 544         m_callFrame = visitor-&gt;callFrame();
 545         m_codeBlock = visitor-&gt;codeBlock();
 546 
 547         m_handler = nullptr;
<span class="line-modified"> 548         if (!m_isTermination) {</span>
<span class="line-modified"> 549             if (m_codeBlock) {</span>





 550                 m_handler = findExceptionHandler(visitor, m_codeBlock, RequiredHandler::AnyHandler);
 551                 if (m_handler)
 552                     return StackVisitor::Done;
 553             }
 554         }
 555 
 556 #if ENABLE(WEBASSEMBLY)
 557         if (visitor-&gt;callee().isCell()) {
 558             if (auto* jsToWasmICCallee = jsDynamicCast&lt;JSToWasmICCallee*&gt;(m_vm, visitor-&gt;callee().asCell()))
 559                 m_vm.wasmContext.store(jsToWasmICCallee-&gt;function()-&gt;previousInstance(m_callFrame), m_vm.softStackLimit());
 560         }
 561 #endif
 562 
 563         notifyDebuggerOfUnwinding(m_vm, m_callFrame);
 564 
 565         copyCalleeSavesToEntryFrameCalleeSavesBuffer(visitor);
 566 
 567         bool shouldStopUnwinding = visitor-&gt;callerIsEntryFrame();
 568         if (shouldStopUnwinding)
 569             return StackVisitor::Done;
 570 

 571         return StackVisitor::Continue;
 572     }
 573 
 574 private:
 575     void copyCalleeSavesToEntryFrameCalleeSavesBuffer(StackVisitor&amp; visitor) const
 576     {
 577 #if ENABLE(ASSEMBLER)
 578         Optional&lt;RegisterAtOffsetList&gt; currentCalleeSaves = visitor-&gt;calleeSaveRegistersForUnwinding();
 579 
 580         if (!currentCalleeSaves)
 581             return;
 582 
 583         RegisterAtOffsetList* allCalleeSaves = RegisterSet::vmCalleeSaveRegisterOffsets();
 584         RegisterSet dontCopyRegisters = RegisterSet::stackRegisters();
 585         CPURegister* frame = reinterpret_cast&lt;CPURegister*&gt;(m_callFrame-&gt;registers());
 586 
 587         unsigned registerCount = currentCalleeSaves-&gt;size();
 588         VMEntryRecord* record = vmEntryRecord(m_vm.topEntryFrame);
 589         for (unsigned i = 0; i &lt; registerCount; i++) {
 590             RegisterAtOffset currentEntry = currentCalleeSaves-&gt;at(i);
 591             if (dontCopyRegisters.get(currentEntry.reg()))
 592                 continue;
 593             RegisterAtOffset* calleeSavesEntry = allCalleeSaves-&gt;find(currentEntry.reg());
 594 
 595             record-&gt;calleeSaveRegistersBuffer[calleeSavesEntry-&gt;offsetAsIndex()] = *(frame + currentEntry.offsetAsIndex());
 596         }
 597 #else
 598         UNUSED_PARAM(visitor);
 599 #endif
 600     }
 601 
 602     VM&amp; m_vm;
 603     CallFrame*&amp; m_callFrame;
 604     bool m_isTermination;
 605     CodeBlock*&amp; m_codeBlock;
 606     HandlerInfo*&amp; m_handler;

 607 };
 608 
 609 NEVER_INLINE HandlerInfo* Interpreter::unwind(VM&amp; vm, CallFrame*&amp; callFrame, Exception* exception)
 610 {
 611     auto scope = DECLARE_CATCH_SCOPE(vm);
 612 
 613     ASSERT(reinterpret_cast&lt;void*&gt;(callFrame) != vm.topEntryFrame);
 614     CodeBlock* codeBlock = callFrame-&gt;codeBlock();
 615 
 616     JSValue exceptionValue = exception-&gt;value();
 617     ASSERT(!exceptionValue.isEmpty());
 618     ASSERT(!exceptionValue.isCell() || exceptionValue.asCell());
 619     // This shouldn&#39;t be possible (hence the assertions), but we&#39;re already in the slowest of
 620     // slow cases, so let&#39;s harden against it anyway to be safe.
 621     if (exceptionValue.isEmpty() || (exceptionValue.isCell() &amp;&amp; !exceptionValue.asCell()))
 622         exceptionValue = jsNull();
 623 
 624     EXCEPTION_ASSERT_UNUSED(scope, scope.exception());
 625 
 626     // Calculate an exception handler vPC, unwinding call frames as necessary.
 627     HandlerInfo* handler = nullptr;
 628     UnwindFunctor functor(vm, callFrame, isTerminatedExecutionException(vm, exception), codeBlock, handler);
<span class="line-modified"> 629     StackVisitor::visit&lt;StackVisitor::TerminateIfTopEntryFrameIsEmpty&gt;(callFrame, &amp;vm, functor);</span>
 630     if (!handler)
 631         return nullptr;
 632 
 633     return handler;
 634 }
 635 
<span class="line-modified"> 636 void Interpreter::notifyDebuggerOfExceptionToBeThrown(VM&amp; vm, CallFrame* callFrame, Exception* exception)</span>
 637 {
<span class="line-modified"> 638     Debugger* debugger = vm.vmEntryGlobalObject(callFrame)-&gt;debugger();</span>
 639     if (debugger &amp;&amp; debugger-&gt;needsExceptionCallbacks() &amp;&amp; !exception-&gt;didNotifyInspectorOfThrow()) {
 640         // This code assumes that if the debugger is enabled then there is no inlining.
 641         // If that assumption turns out to be false then we&#39;ll ignore the inlined call
 642         // frames.
 643         // https://bugs.webkit.org/show_bug.cgi?id=121754
 644 
 645         bool hasCatchHandler;
 646         bool isTermination = isTerminatedExecutionException(vm, exception);
 647         if (isTermination)
 648             hasCatchHandler = false;
 649         else {
 650             GetCatchHandlerFunctor functor;
<span class="line-modified"> 651             StackVisitor::visit(callFrame, &amp;vm, functor);</span>
 652             HandlerInfo* handler = functor.handler();
 653             ASSERT(!handler || handler-&gt;isCatchHandler());
 654             hasCatchHandler = !!handler;
 655         }
 656 
<span class="line-modified"> 657         debugger-&gt;exception(callFrame, exception-&gt;value(), hasCatchHandler);</span>
 658     }
 659     exception-&gt;setDidNotifyInspectorOfThrow();
 660 }
 661 
<span class="line-modified"> 662 JSValue Interpreter::executeProgram(const SourceCode&amp; source, CallFrame* callFrame, JSObject* thisObj)</span>
 663 {
 664     JSScope* scope = thisObj-&gt;globalObject()-&gt;globalScope();
 665     VM&amp; vm = scope-&gt;vm();
 666     auto throwScope = DECLARE_THROW_SCOPE(vm);


 667 
<span class="line-modified"> 668     ProgramExecutable* program = ProgramExecutable::create(callFrame, source);</span>
 669     EXCEPTION_ASSERT(throwScope.exception() || program);
 670     RETURN_IF_EXCEPTION(throwScope, { });
 671 
 672     throwScope.assertNoException();
 673     ASSERT(!vm.isCollectorBusyOnCurrentThread());
 674     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
 675     if (vm.isCollectorBusyOnCurrentThread())
 676         return jsNull();
 677 
 678     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
<span class="line-modified"> 679         return checkedReturn(throwStackOverflowError(callFrame, throwScope));</span>
 680 
 681     // First check if the &quot;program&quot; is actually just a JSON object. If so,
 682     // we&#39;ll handle the JSON object here. Else, we&#39;ll handle real JS code
 683     // below at failedJSONP.
 684 
<span class="line-removed"> 685     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);</span>
 686     Vector&lt;JSONPData&gt; JSONPData;
 687     bool parseResult;
 688     StringView programSource = program-&gt;source().view();
 689     if (programSource.isNull())
 690         return jsUndefined();
 691     if (programSource.is8Bit()) {
<span class="line-modified"> 692         LiteralParser&lt;LChar&gt; literalParser(callFrame, programSource.characters8(), programSource.length(), JSONP);</span>
 693         parseResult = literalParser.tryJSONPParse(JSONPData, globalObject-&gt;globalObjectMethodTable()-&gt;supportsRichSourceInfo(globalObject));
 694     } else {
<span class="line-modified"> 695         LiteralParser&lt;UChar&gt; literalParser(callFrame, programSource.characters16(), programSource.length(), JSONP);</span>
 696         parseResult = literalParser.tryJSONPParse(JSONPData, globalObject-&gt;globalObjectMethodTable()-&gt;supportsRichSourceInfo(globalObject));
 697     }
 698 
 699     RETURN_IF_EXCEPTION(throwScope, { });
 700     if (parseResult) {
 701         JSValue result;
 702         for (unsigned entry = 0; entry &lt; JSONPData.size(); entry++) {
 703             Vector&lt;JSONPPathEntry&gt; JSONPPath;
 704             JSONPPath.swap(JSONPData[entry].m_path);
 705             JSValue JSONPValue = JSONPData[entry].m_value.get();
 706             if (JSONPPath.size() == 1 &amp;&amp; JSONPPath[0].m_type == JSONPPathEntryTypeDeclareVar) {
<span class="line-modified"> 707                 globalObject-&gt;addVar(callFrame, JSONPPath[0].m_pathEntryName);</span>
 708                 RETURN_IF_EXCEPTION(throwScope, { });
 709                 PutPropertySlot slot(globalObject);
<span class="line-modified"> 710                 globalObject-&gt;methodTable(vm)-&gt;put(globalObject, callFrame, JSONPPath[0].m_pathEntryName, JSONPValue, slot);</span>
 711                 RETURN_IF_EXCEPTION(throwScope, { });
 712                 result = jsUndefined();
 713                 continue;
 714             }
 715             JSValue baseObject(globalObject);
 716             for (unsigned i = 0; i &lt; JSONPPath.size() - 1; i++) {
 717                 ASSERT(JSONPPath[i].m_type != JSONPPathEntryTypeDeclareVar);
 718                 switch (JSONPPath[i].m_type) {
 719                 case JSONPPathEntryTypeDot: {
 720                     if (i == 0) {
 721                         RELEASE_ASSERT(baseObject == globalObject);
 722 
 723                         auto doGet = [&amp;] (JSSegmentedVariableObject* scope) {
 724                             PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
<span class="line-modified"> 725                             if (scope-&gt;getPropertySlot(callFrame, JSONPPath[i].m_pathEntryName, slot))</span>
<span class="line-modified"> 726                                 return slot.getValue(callFrame, JSONPPath[i].m_pathEntryName);</span>
 727                             return JSValue();
 728                         };
 729 
 730                         JSValue result = doGet(globalObject-&gt;globalLexicalEnvironment());
 731                         RETURN_IF_EXCEPTION(throwScope, JSValue());
 732                         if (result) {
 733                             baseObject = result;
 734                             continue;
 735                         }
 736 
 737                         result = doGet(globalObject);
 738                         RETURN_IF_EXCEPTION(throwScope, JSValue());
 739                         if (result) {
 740                             baseObject = result;
 741                             continue;
 742                         }
 743 
 744                         if (entry)
<span class="line-modified"> 745                             return throwException(callFrame, throwScope, createUndefinedVariableError(callFrame, JSONPPath[i].m_pathEntryName));</span>
 746                         goto failedJSONP;
 747                     }
 748 
<span class="line-modified"> 749                     baseObject = baseObject.get(callFrame, JSONPPath[i].m_pathEntryName);</span>
 750                     RETURN_IF_EXCEPTION(throwScope, JSValue());
 751                     continue;
 752                 }
 753                 case JSONPPathEntryTypeLookup: {
<span class="line-modified"> 754                     baseObject = baseObject.get(callFrame, static_cast&lt;unsigned&gt;(JSONPPath[i].m_pathIndex));</span>
 755                     RETURN_IF_EXCEPTION(throwScope, JSValue());
 756                     continue;
 757                 }
 758                 default:
 759                     RELEASE_ASSERT_NOT_REACHED();
 760                     return jsUndefined();
 761                 }
 762             }
 763 
 764             if (JSONPPath.size() == 1 &amp;&amp; JSONPPath.last().m_type != JSONPPathEntryTypeLookup) {
 765                 RELEASE_ASSERT(baseObject == globalObject);
 766                 JSGlobalLexicalEnvironment* scope = globalObject-&gt;globalLexicalEnvironment();
<span class="line-modified"> 767                 if (scope-&gt;hasProperty(callFrame, JSONPPath.last().m_pathEntryName))</span>
 768                     baseObject = scope;
 769                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 770             }
 771 
 772             PutPropertySlot slot(baseObject);
 773             switch (JSONPPath.last().m_type) {
 774             case JSONPPathEntryTypeCall: {
<span class="line-modified"> 775                 JSValue function = baseObject.get(callFrame, JSONPPath.last().m_pathEntryName);</span>
 776                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 777                 CallData callData;
 778                 CallType callType = getCallData(vm, function, callData);
 779                 if (callType == CallType::None)
<span class="line-modified"> 780                     return throwException(callFrame, throwScope, createNotAFunctionError(callFrame, function));</span>
 781                 MarkedArgumentBuffer jsonArg;
 782                 jsonArg.append(JSONPValue);
 783                 ASSERT(!jsonArg.hasOverflowed());
 784                 JSValue thisValue = JSONPPath.size() == 1 ? jsUndefined() : baseObject;
<span class="line-modified"> 785                 JSONPValue = JSC::call(callFrame, function, callType, callData, thisValue, jsonArg);</span>
 786                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 787                 break;
 788             }
 789             case JSONPPathEntryTypeDot: {
<span class="line-modified"> 790                 baseObject.put(callFrame, JSONPPath.last().m_pathEntryName, JSONPValue, slot);</span>
 791                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 792                 break;
 793             }
 794             case JSONPPathEntryTypeLookup: {
<span class="line-modified"> 795                 baseObject.putByIndex(callFrame, JSONPPath.last().m_pathIndex, JSONPValue, slot.isStrictMode());</span>
 796                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 797                 break;
 798             }
 799             default:
 800                 RELEASE_ASSERT_NOT_REACHED();
 801                 return jsUndefined();
 802             }
 803             result = JSONPValue;
 804         }
 805         return result;
 806     }
 807 failedJSONP:
 808     // If we get here, then we have already proven that the script is not a JSON
 809     // object.
 810 
 811     VMEntryScope entryScope(vm, globalObject);
 812 
 813     // Compile source to bytecode if necessary:
<span class="line-modified"> 814     JSObject* error = program-&gt;initializeGlobalProperties(vm, callFrame, scope);</span>
 815     EXCEPTION_ASSERT(!throwScope.exception() || !error);
 816     if (UNLIKELY(error))
<span class="line-modified"> 817         return checkedReturn(throwException(callFrame, throwScope, error));</span>
 818 
 819     ProgramCodeBlock* codeBlock;
 820     {
 821         CodeBlock* tempCodeBlock;
 822         Exception* error = program-&gt;prepareForExecution&lt;ProgramExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);
 823         EXCEPTION_ASSERT(throwScope.exception() == error);
 824         if (UNLIKELY(error))
 825             return checkedReturn(error);
 826         codeBlock = jsCast&lt;ProgramCodeBlock*&gt;(tempCodeBlock);
 827     }
 828 
<span class="line-modified"> 829     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);</span>
<span class="line-modified"> 830     if (UNLIKELY(vm.needTrapHandling(mask))) {</span>
<span class="line-modified"> 831         vm.handleTraps(callFrame, mask);</span>
 832         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
 833     }
 834 
 835     if (scope-&gt;structure(vm)-&gt;isUncacheableDictionary())
 836         scope-&gt;flattenDictionaryObject(vm);
 837 
 838     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
 839 
 840     ProtoCallFrame protoCallFrame;
<span class="line-modified"> 841     protoCallFrame.init(codeBlock, JSCallee::create(vm, globalObject, scope), thisObj, 1);</span>
 842 
 843     // Execute the code:
 844     throwScope.release();
 845     JSValue result = program-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
 846     return checkedReturn(result);
 847 }
 848 
<span class="line-modified"> 849 JSValue Interpreter::executeCall(CallFrame* callFrame, JSObject* function, CallType callType, const CallData&amp; callData, JSValue thisValue, const ArgList&amp; args)</span>
 850 {
<span class="line-modified"> 851     VM&amp; vm = callFrame-&gt;vm();</span>
 852     auto throwScope = DECLARE_THROW_SCOPE(vm);
 853 
 854     throwScope.assertNoException();
 855     ASSERT(!vm.isCollectorBusyOnCurrentThread());
 856     if (vm.isCollectorBusyOnCurrentThread())
 857         return jsNull();
 858 
 859     bool isJSCall = (callType == CallType::JS);
 860     JSScope* scope = nullptr;
 861     CodeBlock* newCodeBlock;
 862     size_t argsCount = 1 + args.size(); // implicit &quot;this&quot; parameter
 863 
 864     JSGlobalObject* globalObject;
 865 
 866     if (isJSCall) {
 867         scope = callData.js.scope;
 868         globalObject = scope-&gt;globalObject(vm);
 869     } else {
 870         ASSERT(callType == CallType::Host);
 871         globalObject = function-&gt;globalObject(vm);
 872     }
 873 
 874     VMEntryScope entryScope(vm, globalObject);
<span class="line-modified"> 875     if (UNLIKELY(!vm.isSafeToRecurseSoft()))</span>
<span class="line-modified"> 876         return checkedReturn(throwStackOverflowError(callFrame, throwScope));</span>
 877 
 878     if (isJSCall) {
 879         // Compile the callee:
 880         Exception* compileError = callData.js.functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, jsCast&lt;JSFunction*&gt;(function), scope, CodeForCall, newCodeBlock);
 881         EXCEPTION_ASSERT(throwScope.exception() == compileError);
 882         if (UNLIKELY(!!compileError))
 883             return checkedReturn(compileError);
 884 
 885         ASSERT(!!newCodeBlock);
 886         newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
 887     } else
 888         newCodeBlock = 0;
 889 
<span class="line-modified"> 890     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);</span>
<span class="line-modified"> 891     if (UNLIKELY(vm.needTrapHandling(mask))) {</span>
<span class="line-modified"> 892         vm.handleTraps(callFrame, mask);</span>
 893         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
 894     }
 895 
 896     ProtoCallFrame protoCallFrame;
<span class="line-modified"> 897     protoCallFrame.init(newCodeBlock, function, thisValue, argsCount, args.data());</span>
 898 
 899     JSValue result;
 900     {
 901         // Execute the code:
 902         if (isJSCall) {
 903             throwScope.release();
 904             result = callData.js.functionExecutable-&gt;generatedJITCodeForCall()-&gt;execute(&amp;vm, &amp;protoCallFrame);
 905         } else {
 906             result = JSValue::decode(vmEntryToNative(callData.native.function.rawPointer(), &amp;vm, &amp;protoCallFrame));
 907             RETURN_IF_EXCEPTION(throwScope, JSValue());
 908         }
 909     }
 910 
 911     return checkedReturn(result);
 912 }
 913 
<span class="line-modified"> 914 JSObject* Interpreter::executeConstruct(CallFrame* callFrame, JSObject* constructor, ConstructType constructType, const ConstructData&amp; constructData, const ArgList&amp; args, JSValue newTarget)</span>
 915 {
<span class="line-modified"> 916     VM&amp; vm = callFrame-&gt;vm();</span>
 917     auto throwScope = DECLARE_THROW_SCOPE(vm);
 918 
 919     throwScope.assertNoException();
 920     ASSERT(!vm.isCollectorBusyOnCurrentThread());
 921     // We throw in this case because we have to return something &quot;valid&quot; but we&#39;re
 922     // already in an invalid state.
 923     if (UNLIKELY(vm.isCollectorBusyOnCurrentThread())) {
<span class="line-modified"> 924         throwStackOverflowError(callFrame, throwScope);</span>
 925         return nullptr;
 926     }
 927 
 928     bool isJSConstruct = (constructType == ConstructType::JS);
 929     JSScope* scope = nullptr;
 930     CodeBlock* newCodeBlock;
 931     size_t argsCount = 1 + args.size(); // implicit &quot;this&quot; parameter
 932 
 933     JSGlobalObject* globalObject;
 934 
 935     if (isJSConstruct) {
 936         scope = constructData.js.scope;
 937         globalObject = scope-&gt;globalObject(vm);
 938     } else {
 939         ASSERT(constructType == ConstructType::Host);
 940         globalObject = constructor-&gt;globalObject(vm);
 941     }
 942 
 943     VMEntryScope entryScope(vm, globalObject);
<span class="line-modified"> 944     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {</span>
<span class="line-modified"> 945         throwStackOverflowError(callFrame, throwScope);</span>
 946         return nullptr;
 947     }
 948 
 949     if (isJSConstruct) {
 950         // Compile the callee:
 951         Exception* compileError = constructData.js.functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, jsCast&lt;JSFunction*&gt;(constructor), scope, CodeForConstruct, newCodeBlock);
 952         EXCEPTION_ASSERT(throwScope.exception() == compileError);
 953         if (UNLIKELY(!!compileError))
 954             return nullptr;
 955 
 956         ASSERT(!!newCodeBlock);
 957         newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
 958     } else
 959         newCodeBlock = 0;
 960 
<span class="line-modified"> 961     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);</span>
<span class="line-modified"> 962     if (UNLIKELY(vm.needTrapHandling(mask))) {</span>
<span class="line-modified"> 963         vm.handleTraps(callFrame, mask);</span>
 964         RETURN_IF_EXCEPTION(throwScope, nullptr);
 965     }
 966 
 967     ProtoCallFrame protoCallFrame;
<span class="line-modified"> 968     protoCallFrame.init(newCodeBlock, constructor, newTarget, argsCount, args.data());</span>
 969 
 970     JSValue result;
 971     {
 972         // Execute the code.
 973         if (isJSConstruct)
 974             result = constructData.js.functionExecutable-&gt;generatedJITCodeForConstruct()-&gt;execute(&amp;vm, &amp;protoCallFrame);
 975         else {
 976             result = JSValue::decode(vmEntryToNative(constructData.native.function.rawPointer(), &amp;vm, &amp;protoCallFrame));
 977 
 978             if (LIKELY(!throwScope.exception()))
 979                 RELEASE_ASSERT(result.isObject());
 980         }
 981     }
 982 
 983     RETURN_IF_EXCEPTION(throwScope, 0);
 984     ASSERT(result.isObject());
 985     return checkedReturn(asObject(result));
 986 }
 987 
 988 CallFrameClosure Interpreter::prepareForRepeatCall(FunctionExecutable* functionExecutable, CallFrame* callFrame, ProtoCallFrame* protoCallFrame, JSFunction* function, int argumentCountIncludingThis, JSScope* scope, const ArgList&amp; args)
 989 {
 990     VM&amp; vm = scope-&gt;vm();
 991     auto throwScope = DECLARE_THROW_SCOPE(vm);
 992     throwScope.assertNoException();
 993 
 994     if (vm.isCollectorBusyOnCurrentThread())
 995         return CallFrameClosure();
 996 
 997     // Compile the callee:
 998     CodeBlock* newCodeBlock;
 999     Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, function, scope, CodeForCall, newCodeBlock);
1000     EXCEPTION_ASSERT(throwScope.exception() == error);
1001     if (UNLIKELY(error))
1002         return CallFrameClosure();
1003     newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
1004 
1005     size_t argsCount = argumentCountIncludingThis;
1006 
<span class="line-modified">1007     protoCallFrame-&gt;init(newCodeBlock, function, jsUndefined(), argsCount, args.data());</span>
1008     // Return the successful closure:
1009     CallFrameClosure result = { callFrame, protoCallFrame, function, functionExecutable, &amp;vm, scope, newCodeBlock-&gt;numParameters(), argumentCountIncludingThis };
1010     return result;
1011 }
1012 
<span class="line-modified">1013 JSValue Interpreter::execute(EvalExecutable* eval, CallFrame* callFrame, JSValue thisValue, JSScope* scope)</span>
1014 {
1015     VM&amp; vm = scope-&gt;vm();
1016     auto throwScope = DECLARE_THROW_SCOPE(vm);
1017 
<span class="line-modified">1018     ASSERT(&amp;vm == &amp;callFrame-&gt;vm());</span>
1019     throwScope.assertNoException();
1020     ASSERT(!vm.isCollectorBusyOnCurrentThread());
1021     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
1022     if (vm.isCollectorBusyOnCurrentThread())
1023         return jsNull();
1024 
<span class="line-modified">1025     VMEntryScope entryScope(vm, scope-&gt;globalObject(vm));</span>

1026     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
<span class="line-modified">1027         return checkedReturn(throwStackOverflowError(callFrame, throwScope));</span>
1028 
1029     unsigned numVariables = eval-&gt;numVariables();
1030     unsigned numTopLevelFunctionDecls = eval-&gt;numTopLevelFunctionDecls();
1031     unsigned numFunctionHoistingCandidates = eval-&gt;numFunctionHoistingCandidates();
1032 
1033     JSScope* variableObject;
1034     if ((numVariables || numTopLevelFunctionDecls) &amp;&amp; eval-&gt;isStrictMode()) {
<span class="line-modified">1035         scope = StrictEvalActivation::create(vm, callFrame-&gt;lexicalGlobalObject()-&gt;strictEvalActivationStructure(), scope);</span>
1036         variableObject = scope;
1037     } else {
1038         for (JSScope* node = scope; ; node = node-&gt;next()) {
1039             RELEASE_ASSERT(node);
1040             if (node-&gt;isGlobalObject()) {
1041                 variableObject = node;
1042                 break;
1043             }
1044             if (node-&gt;isJSLexicalEnvironment()) {
1045                 JSLexicalEnvironment* lexicalEnvironment = jsCast&lt;JSLexicalEnvironment*&gt;(node);
1046                 if (lexicalEnvironment-&gt;symbolTable()-&gt;scopeType() == SymbolTable::ScopeType::VarScope) {
1047                     variableObject = node;
1048                     break;
1049                 }
1050             }
1051         }
1052     }
1053 
1054     EvalCodeBlock* codeBlock;
1055     {
1056         CodeBlock* tempCodeBlock;
1057         Exception* compileError = eval-&gt;prepareForExecution&lt;EvalExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);
1058         EXCEPTION_ASSERT(throwScope.exception() == compileError);
1059         if (UNLIKELY(!!compileError))
1060             return checkedReturn(compileError);
1061         codeBlock = jsCast&lt;EvalCodeBlock*&gt;(tempCodeBlock);
1062     }
1063     UnlinkedEvalCodeBlock* unlinkedCodeBlock = codeBlock-&gt;unlinkedEvalCodeBlock();
1064 
1065     // We can&#39;t declare a &quot;var&quot;/&quot;function&quot; that overwrites a global &quot;let&quot;/&quot;const&quot;/&quot;class&quot; in a sloppy-mode eval.
1066     if (variableObject-&gt;isGlobalObject() &amp;&amp; !eval-&gt;isStrictMode() &amp;&amp; (numVariables || numTopLevelFunctionDecls)) {
1067         JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalObject*&gt;(variableObject)-&gt;globalLexicalEnvironment();
1068         for (unsigned i = 0; i &lt; numVariables; ++i) {
1069             const Identifier&amp; ident = unlinkedCodeBlock-&gt;variable(i);
1070             PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">1071             if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, callFrame, ident, slot)) {</span>
<span class="line-modified">1072                 return checkedReturn(throwTypeError(callFrame, throwScope, makeString(&quot;Can&#39;t create duplicate global variable in eval: &#39;&quot;, String(ident.impl()), &quot;&#39;&quot;)));</span>
1073             }
1074         }
1075 
1076         for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
1077             FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
1078             PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">1079             if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, callFrame, function-&gt;name(), slot)) {</span>
<span class="line-modified">1080                 return checkedReturn(throwTypeError(callFrame, throwScope, makeString(&quot;Can&#39;t create duplicate global variable in eval: &#39;&quot;, String(function-&gt;name().impl()), &quot;&#39;&quot;)));</span>
1081             }
1082         }
1083     }
1084 
1085     if (variableObject-&gt;structure(vm)-&gt;isUncacheableDictionary())
1086         variableObject-&gt;flattenDictionaryObject(vm);
1087 
1088     if (numVariables || numTopLevelFunctionDecls || numFunctionHoistingCandidates) {
1089         BatchedTransitionOptimizer optimizer(vm, variableObject);
1090         if (variableObject-&gt;next() &amp;&amp; !eval-&gt;isStrictMode())
1091             variableObject-&gt;globalObject(vm)-&gt;varInjectionWatchpoint()-&gt;fireAll(vm, &quot;Executed eval, fired VarInjection watchpoint&quot;);
1092 
1093         for (unsigned i = 0; i &lt; numVariables; ++i) {
1094             const Identifier&amp; ident = unlinkedCodeBlock-&gt;variable(i);
<span class="line-modified">1095             bool hasProperty = variableObject-&gt;hasProperty(callFrame, ident);</span>
1096             RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1097             if (!hasProperty) {
1098                 PutPropertySlot slot(variableObject);
<span class="line-modified">1099                 if (!variableObject-&gt;isExtensible(callFrame))</span>
<span class="line-modified">1100                     return checkedReturn(throwTypeError(callFrame, throwScope, NonExtensibleObjectPropertyDefineError));</span>
<span class="line-modified">1101                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, callFrame, ident, jsUndefined(), slot);</span>
1102                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1103             }
1104         }
1105 
1106         if (eval-&gt;isStrictMode()) {
1107             for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
1108                 FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
1109                 PutPropertySlot slot(variableObject);
1110                 // We need create this variables because it will be used to emits code by bytecode generator
<span class="line-modified">1111                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, callFrame, function-&gt;name(), jsUndefined(), slot);</span>
1112                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1113             }
1114         } else {
1115             for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
1116                 FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
<span class="line-modified">1117                 JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(callFrame, scope, function-&gt;name());</span>
1118                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1119                 if (resolvedScope.isUndefined())
<span class="line-modified">1120                     return checkedReturn(throwSyntaxError(callFrame, throwScope, makeString(&quot;Can&#39;t create duplicate variable in eval: &#39;&quot;, String(function-&gt;name().impl()), &quot;&#39;&quot;)));</span>
1121                 PutPropertySlot slot(variableObject);
1122                 // We need create this variables because it will be used to emits code by bytecode generator
<span class="line-modified">1123                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, callFrame, function-&gt;name(), jsUndefined(), slot);</span>
1124                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1125             }
1126 
1127             for (unsigned i = 0; i &lt; numFunctionHoistingCandidates; ++i) {
1128                 const Identifier&amp; ident = unlinkedCodeBlock-&gt;functionHoistingCandidate(i);
<span class="line-modified">1129                 JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(callFrame, scope, ident);</span>
1130                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1131                 if (!resolvedScope.isUndefined()) {
<span class="line-modified">1132                     bool hasProperty = variableObject-&gt;hasProperty(callFrame, ident);</span>
1133                     RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1134                     if (!hasProperty) {
1135                         PutPropertySlot slot(variableObject);
<span class="line-modified">1136                         variableObject-&gt;methodTable(vm)-&gt;put(variableObject, callFrame, ident, jsUndefined(), slot);</span>
1137                         RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1138                     }
1139                 }
1140             }
1141         }
1142     }
1143 
<span class="line-modified">1144     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);</span>
<span class="line-modified">1145     if (UNLIKELY(vm.needTrapHandling(mask))) {</span>
<span class="line-modified">1146         vm.handleTraps(callFrame, mask);</span>
1147         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
1148     }
1149 
1150     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
1151 





1152     ProtoCallFrame protoCallFrame;
<span class="line-modified">1153     protoCallFrame.init(codeBlock, JSCallee::create(vm, scope-&gt;globalObject(vm), scope), thisValue, 1);</span>
1154 
1155     // Execute the code:
1156     throwScope.release();
1157     JSValue result = eval-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
1158 
1159     return checkedReturn(result);
1160 }
1161 
<span class="line-modified">1162 JSValue Interpreter::executeModuleProgram(ModuleProgramExecutable* executable, CallFrame* callFrame, JSModuleEnvironment* scope)</span>
1163 {
1164     VM&amp; vm = scope-&gt;vm();
1165     auto throwScope = DECLARE_THROW_SCOPE(vm);
1166 
<span class="line-modified">1167     ASSERT(&amp;vm == &amp;callFrame-&gt;vm());</span>
1168     throwScope.assertNoException();
1169     ASSERT(!vm.isCollectorBusyOnCurrentThread());
1170     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
1171     if (vm.isCollectorBusyOnCurrentThread())
1172         return jsNull();
1173 

1174     VMEntryScope entryScope(vm, scope-&gt;globalObject(vm));
1175     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
<span class="line-modified">1176         return checkedReturn(throwStackOverflowError(callFrame, throwScope));</span>
1177 
1178     ModuleProgramCodeBlock* codeBlock;
1179     {
1180         CodeBlock* tempCodeBlock;
1181         Exception* compileError = executable-&gt;prepareForExecution&lt;ModuleProgramExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);
1182         EXCEPTION_ASSERT(throwScope.exception() == compileError);
1183         if (UNLIKELY(!!compileError))
1184             return checkedReturn(compileError);
1185         codeBlock = jsCast&lt;ModuleProgramCodeBlock*&gt;(tempCodeBlock);
1186     }
1187 
<span class="line-modified">1188     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);</span>
<span class="line-modified">1189     if (UNLIKELY(vm.needTrapHandling(mask))) {</span>
<span class="line-modified">1190         vm.handleTraps(callFrame, mask);</span>
1191         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
1192     }
1193 
1194     if (scope-&gt;structure(vm)-&gt;isUncacheableDictionary())
1195         scope-&gt;flattenDictionaryObject(vm);
1196 
1197     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
1198 
1199     // The |this| of the module is always `undefined`.
1200     // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-hasthisbinding
1201     // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-getthisbinding
1202     ProtoCallFrame protoCallFrame;
<span class="line-modified">1203     protoCallFrame.init(codeBlock, JSCallee::create(vm, scope-&gt;globalObject(vm), scope), jsUndefined(), 1);</span>
1204 
1205     // Execute the code:
1206     throwScope.release();
1207     JSValue result = executable-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
1208 
1209     return checkedReturn(result);
1210 }
1211 
1212 NEVER_INLINE void Interpreter::debug(CallFrame* callFrame, DebugHookType debugHookType)
1213 {
<span class="line-modified">1214     VM&amp; vm = callFrame-&gt;vm();</span>
1215     auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">1216     Debugger* debugger = vm.vmEntryGlobalObject(callFrame)-&gt;debugger();</span>
1217     if (!debugger)
1218         return;
1219 
1220     ASSERT(callFrame-&gt;codeBlock()-&gt;hasDebuggerRequests());
1221     scope.assertNoException();
1222 
1223     switch (debugHookType) {
1224         case DidEnterCallFrame:
1225             debugger-&gt;callEvent(callFrame);
1226             break;
1227         case WillLeaveCallFrame:
1228             debugger-&gt;returnEvent(callFrame);
1229             break;
1230         case WillExecuteStatement:
1231             debugger-&gt;atStatement(callFrame);
1232             break;
1233         case WillExecuteExpression:
1234             debugger-&gt;atExpression(callFrame);
1235             break;
1236         case WillExecuteProgram:
1237             debugger-&gt;willExecuteProgram(callFrame);
1238             break;
1239         case DidExecuteProgram:
1240             debugger-&gt;didExecuteProgram(callFrame);
1241             break;
<span class="line-modified">1242         case DidReachBreakpoint:</span>
<span class="line-modified">1243             debugger-&gt;didReachBreakpoint(callFrame);</span>
1244             break;
1245     }
1246     scope.assertNoException();
1247 }
1248 
1249 } // namespace JSC
1250 
1251 namespace WTF {
1252 
1253 void printInternal(PrintStream&amp; out, JSC::DebugHookType type)
1254 {
1255     switch (type) {
1256     case JSC::WillExecuteProgram:
1257         out.print(&quot;WillExecuteProgram&quot;);
1258         return;
1259     case JSC::DidExecuteProgram:
1260         out.print(&quot;DidExecuteProgram&quot;);
1261         return;
1262     case JSC::DidEnterCallFrame:
1263         out.print(&quot;DidEnterCallFrame&quot;);
1264         return;
<span class="line-modified">1265     case JSC::DidReachBreakpoint:</span>
<span class="line-modified">1266         out.print(&quot;DidReachBreakpoint&quot;);</span>
1267         return;
1268     case JSC::WillLeaveCallFrame:
1269         out.print(&quot;WillLeaveCallFrame&quot;);
1270         return;
1271     case JSC::WillExecuteStatement:
1272         out.print(&quot;WillExecuteStatement&quot;);
1273         return;
1274     case JSC::WillExecuteExpression:
1275         out.print(&quot;WillExecuteExpression&quot;);
1276         return;
1277     }
1278 }
1279 
1280 } // namespace WTF
</pre>
</td>
<td>
<hr />
<pre>
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;Interpreter.h&quot;
  32 
  33 #include &quot;BatchedTransitionOptimizer.h&quot;
  34 #include &quot;Bytecodes.h&quot;
  35 #include &quot;CallFrameClosure.h&quot;
  36 #include &quot;CatchScope.h&quot;
<span class="line-added">  37 #include &quot;CheckpointOSRExitSideState.h&quot;</span>
  38 #include &quot;CodeBlock.h&quot;
  39 #include &quot;CodeCache.h&quot;
  40 #include &quot;DirectArguments.h&quot;
  41 #include &quot;ExecutableBaseInlines.h&quot;
  42 #include &quot;Heap.h&quot;
  43 #include &quot;Debugger.h&quot;
  44 #include &quot;DebuggerCallFrame.h&quot;
  45 #include &quot;DirectEvalCodeCache.h&quot;
  46 #include &quot;ErrorInstance.h&quot;
  47 #include &quot;EvalCodeBlock.h&quot;
  48 #include &quot;Exception.h&quot;
  49 #include &quot;ExceptionHelpers.h&quot;
  50 #include &quot;FrameTracers.h&quot;
  51 #include &quot;FunctionCodeBlock.h&quot;
  52 #include &quot;InterpreterInlines.h&quot;
  53 #include &quot;JITCodeInlines.h&quot;
  54 #include &quot;JSArrayInlines.h&quot;
  55 #include &quot;JSBoundFunction.h&quot;
  56 #include &quot;JSCInlines.h&quot;

  57 #include &quot;JSImmutableButterfly.h&quot;
  58 #include &quot;JSLexicalEnvironment.h&quot;
  59 #include &quot;JSModuleEnvironment.h&quot;
  60 #include &quot;JSString.h&quot;
  61 #include &quot;JSWithScope.h&quot;
  62 #include &quot;LLIntCLoop.h&quot;
  63 #include &quot;LLIntThunks.h&quot;
  64 #include &quot;LiteralParser.h&quot;
  65 #include &quot;ModuleProgramCodeBlock.h&quot;
  66 #include &quot;ObjectPrototype.h&quot;
  67 #include &quot;Parser.h&quot;
  68 #include &quot;ProgramCodeBlock.h&quot;
<span class="line-modified">  69 #include &quot;ProtoCallFrameInlines.h&quot;</span>
  70 #include &quot;RegExpObject.h&quot;
  71 #include &quot;Register.h&quot;
  72 #include &quot;RegisterAtOffsetList.h&quot;
  73 #include &quot;ScopedArguments.h&quot;
  74 #include &quot;StackAlignment.h&quot;
  75 #include &quot;StackFrame.h&quot;
  76 #include &quot;StackVisitor.h&quot;
  77 #include &quot;StrictEvalActivation.h&quot;
  78 #include &quot;StrongInlines.h&quot;
  79 #include &quot;Symbol.h&quot;
  80 #include &quot;VMEntryScope.h&quot;
  81 #include &quot;VMInlines.h&quot;
  82 #include &quot;VMInspector.h&quot;
  83 #include &quot;VirtualRegister.h&quot;
  84 #include &lt;limits.h&gt;
  85 #include &lt;stdio.h&gt;
  86 #include &lt;wtf/NeverDestroyed.h&gt;
  87 #include &lt;wtf/StackStats.h&gt;
  88 #include &lt;wtf/StdLibExtras.h&gt;
  89 #include &lt;wtf/StringPrintStream.h&gt;
  90 #include &lt;wtf/Threading.h&gt;
  91 #include &lt;wtf/text/StringBuilder.h&gt;
  92 
  93 #if ENABLE(JIT)
  94 #include &quot;JIT.h&quot;
  95 #endif
  96 
  97 #if ENABLE(WEBASSEMBLY)
  98 #include &quot;WasmContextInlines.h&quot;
  99 #include &quot;WebAssemblyFunction.h&quot;
 100 #endif
 101 
 102 namespace JSC {
 103 
<span class="line-modified"> 104 JSValue eval(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 105 {
<span class="line-modified"> 106     VM&amp; vm = globalObject-&gt;vm();</span>
 107     auto scope = DECLARE_THROW_SCOPE(vm);
 108 
 109     if (!callFrame-&gt;argumentCount())
 110         return jsUndefined();
 111 
 112     JSValue program = callFrame-&gt;argument(0);
 113     if (!program.isString())
 114         return program;
 115 
 116     TopCallFrameSetter topCallFrame(vm, callFrame);

 117     if (!globalObject-&gt;evalEnabled()) {
<span class="line-modified"> 118         throwException(globalObject, scope, createEvalError(globalObject, globalObject-&gt;evalDisabledErrorMessage()));</span>
 119         return jsUndefined();
 120     }
<span class="line-modified"> 121     String programSource = asString(program)-&gt;value(globalObject);</span>
 122     RETURN_IF_EXCEPTION(scope, JSValue());
 123 
 124     CallFrame* callerFrame = callFrame-&gt;callerFrame();
 125     CallSiteIndex callerCallSiteIndex = callerFrame-&gt;callSiteIndex();
 126     CodeBlock* callerCodeBlock = callerFrame-&gt;codeBlock();
<span class="line-modified"> 127     JSScope* callerScopeChain = callerFrame-&gt;uncheckedR(callerCodeBlock-&gt;scopeRegister()).Register::scope();</span>
 128     UnlinkedCodeBlock* callerUnlinkedCodeBlock = callerCodeBlock-&gt;unlinkedCodeBlock();
 129 
 130     bool isArrowFunctionContext = callerUnlinkedCodeBlock-&gt;isArrowFunction() || callerUnlinkedCodeBlock-&gt;isArrowFunctionContext();
 131 
 132     DerivedContextType derivedContextType = callerUnlinkedCodeBlock-&gt;derivedContextType();
 133     if (!isArrowFunctionContext &amp;&amp; callerUnlinkedCodeBlock-&gt;isClassContext()) {
 134         derivedContextType = callerUnlinkedCodeBlock-&gt;isConstructor()
 135             ? DerivedContextType::DerivedConstructorContext
 136             : DerivedContextType::DerivedMethodContext;
 137     }
 138 
 139     EvalContextType evalContextType;
<span class="line-modified"> 140     if (callerUnlinkedCodeBlock-&gt;parseMode() == SourceParseMode::InstanceFieldInitializerMode)</span>
<span class="line-added"> 141         evalContextType = EvalContextType::InstanceFieldEvalContext;</span>
<span class="line-added"> 142     else if (isFunctionParseMode(callerUnlinkedCodeBlock-&gt;parseMode()))</span>
 143         evalContextType = EvalContextType::FunctionEvalContext;
 144     else if (callerUnlinkedCodeBlock-&gt;codeType() == EvalCode)
 145         evalContextType = callerUnlinkedCodeBlock-&gt;evalContextType();
 146     else
 147         evalContextType = EvalContextType::None;
 148 
 149     DirectEvalExecutable* eval = callerCodeBlock-&gt;directEvalCodeCache().tryGet(programSource, callerCallSiteIndex);
 150     if (!eval) {
 151         if (!callerCodeBlock-&gt;isStrictMode()) {
 152             if (programSource.is8Bit()) {
<span class="line-modified"> 153                 LiteralParser&lt;LChar&gt; preparser(globalObject, programSource.characters8(), programSource.length(), NonStrictJSON, callerCodeBlock);</span>
 154                 if (JSValue parsedObject = preparser.tryLiteralParse())
 155                     RELEASE_AND_RETURN(scope, parsedObject);
 156 
 157             } else {
<span class="line-modified"> 158                 LiteralParser&lt;UChar&gt; preparser(globalObject, programSource.characters16(), programSource.length(), NonStrictJSON, callerCodeBlock);</span>
 159                 if (JSValue parsedObject = preparser.tryLiteralParse())
 160                     RELEASE_AND_RETURN(scope, parsedObject);
 161 
 162             }
 163             RETURN_IF_EXCEPTION(scope, JSValue());
 164         }
 165 
 166         VariableEnvironment variablesUnderTDZ;
 167         JSScope::collectClosureVariablesUnderTDZ(callerScopeChain, variablesUnderTDZ);
<span class="line-modified"> 168         eval = DirectEvalExecutable::create(globalObject, makeSource(programSource, callerCodeBlock-&gt;source().provider()-&gt;sourceOrigin()), callerCodeBlock-&gt;isStrictMode(), derivedContextType, callerUnlinkedCodeBlock-&gt;needsClassFieldInitializer(), isArrowFunctionContext, evalContextType, &amp;variablesUnderTDZ);</span>
 169         EXCEPTION_ASSERT(!!scope.exception() == !eval);
 170         if (!eval)
 171             return jsUndefined();
 172 
<span class="line-modified"> 173         callerCodeBlock-&gt;directEvalCodeCache().set(globalObject, callerCodeBlock, programSource, callerCallSiteIndex, eval);</span>
 174     }
 175 
 176     JSValue thisValue = callerFrame-&gt;thisValue();
 177     Interpreter* interpreter = vm.interpreter;
<span class="line-modified"> 178     RELEASE_AND_RETURN(scope, interpreter-&gt;execute(eval, globalObject, thisValue, callerScopeChain));</span>
 179 }
 180 
<span class="line-modified"> 181 unsigned sizeOfVarargs(JSGlobalObject* globalObject, JSValue arguments, uint32_t firstVarArgOffset)</span>
 182 {
<span class="line-modified"> 183     VM&amp; vm = globalObject-&gt;vm();</span>
 184     auto scope = DECLARE_THROW_SCOPE(vm);
 185 
 186     if (UNLIKELY(!arguments.isCell())) {
 187         if (arguments.isUndefinedOrNull())
 188             return 0;
 189 
<span class="line-modified"> 190         throwException(globalObject, scope, createInvalidFunctionApplyParameterError(globalObject, arguments));</span>
 191         return 0;
 192     }
 193 
 194     JSCell* cell = arguments.asCell();
 195     unsigned length;
 196     switch (cell-&gt;type()) {
 197     case DirectArgumentsType:
<span class="line-modified"> 198         length = jsCast&lt;DirectArguments*&gt;(cell)-&gt;length(globalObject);</span>
 199         break;
 200     case ScopedArgumentsType:
<span class="line-modified"> 201         length = jsCast&lt;ScopedArguments*&gt;(cell)-&gt;length(globalObject);</span>



 202         break;
 203     case JSImmutableButterflyType:
 204         length = jsCast&lt;JSImmutableButterfly*&gt;(cell)-&gt;length();
 205         break;
 206     case StringType:
 207     case SymbolType:
 208     case BigIntType:
<span class="line-modified"> 209         throwException(globalObject, scope, createInvalidFunctionApplyParameterError(globalObject,  arguments));</span>
 210         return 0;
 211 
 212     default:
 213         RELEASE_ASSERT(arguments.isObject());
<span class="line-modified"> 214         length = clampToUnsigned(toLength(globalObject, jsCast&lt;JSObject*&gt;(cell)));</span>
 215         break;
 216     }
 217     RETURN_IF_EXCEPTION(scope, 0);
 218 
<span class="line-added"> 219     if (length &gt; maxArguments)</span>
<span class="line-added"> 220         throwStackOverflowError(globalObject, scope);</span>
<span class="line-added"> 221 </span>
 222     if (length &gt;= firstVarArgOffset)
 223         length -= firstVarArgOffset;
 224     else
 225         length = 0;
 226 
 227     return length;
 228 }
 229 
<span class="line-modified"> 230 unsigned sizeFrameForForwardArguments(JSGlobalObject* globalObject, CallFrame* callFrame, VM&amp; vm, unsigned numUsedStackSlots)</span>
 231 {
 232     auto scope = DECLARE_THROW_SCOPE(vm);
 233 
 234     unsigned length = callFrame-&gt;argumentCount();
 235     CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, length + 1);
 236     if (UNLIKELY(!vm.ensureStackCapacityFor(calleeFrame-&gt;registers())))
<span class="line-modified"> 237         throwStackOverflowError(globalObject, scope);</span>
 238 
 239     return length;
 240 }
 241 
<span class="line-modified"> 242 unsigned sizeFrameForVarargs(JSGlobalObject* globalObject, CallFrame* callFrame, VM&amp; vm, JSValue arguments, unsigned numUsedStackSlots, uint32_t firstVarArgOffset)</span>
 243 {
 244     auto scope = DECLARE_THROW_SCOPE(vm);
 245 
<span class="line-modified"> 246     unsigned length = sizeOfVarargs(globalObject, arguments, firstVarArgOffset);</span>
 247     RETURN_IF_EXCEPTION(scope, 0);
 248 
 249     CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, length + 1);
 250     if (UNLIKELY(length &gt; maxArguments || !vm.ensureStackCapacityFor(calleeFrame-&gt;registers()))) {
<span class="line-modified"> 251         throwStackOverflowError(globalObject, scope);</span>
 252         return 0;
 253     }
 254 
 255     return length;
 256 }
 257 
<span class="line-modified"> 258 void loadVarargs(JSGlobalObject* globalObject, JSValue* firstElementDest, JSValue arguments, uint32_t offset, uint32_t length)</span>
 259 {
 260     if (UNLIKELY(!arguments.isCell()) || !length)
 261         return;
 262 
<span class="line-modified"> 263     VM&amp; vm = globalObject-&gt;vm();</span>
 264     auto scope = DECLARE_THROW_SCOPE(vm);
 265     JSCell* cell = arguments.asCell();
 266 
 267     switch (cell-&gt;type()) {
 268     case DirectArgumentsType:
 269         scope.release();
<span class="line-modified"> 270         jsCast&lt;DirectArguments*&gt;(cell)-&gt;copyToArguments(globalObject, firstElementDest, offset, length);</span>
 271         return;
 272     case ScopedArgumentsType:
 273         scope.release();
<span class="line-modified"> 274         jsCast&lt;ScopedArguments*&gt;(cell)-&gt;copyToArguments(globalObject, firstElementDest, offset, length);</span>




 275         return;
 276     case JSImmutableButterflyType:
 277         scope.release();
<span class="line-modified"> 278         jsCast&lt;JSImmutableButterfly*&gt;(cell)-&gt;copyToArguments(globalObject, firstElementDest, offset, length);</span>
 279         return;
 280     default: {
 281         ASSERT(arguments.isObject());
 282         JSObject* object = jsCast&lt;JSObject*&gt;(cell);
 283         if (isJSArray(object)) {
 284             scope.release();
<span class="line-modified"> 285             jsCast&lt;JSArray*&gt;(object)-&gt;copyToArguments(globalObject, firstElementDest, offset, length);</span>
 286             return;
 287         }
 288         unsigned i;
 289         for (i = 0; i &lt; length &amp;&amp; object-&gt;canGetIndexQuickly(i + offset); ++i)
<span class="line-modified"> 290             firstElementDest[i] = object-&gt;getIndexQuickly(i + offset);</span>
 291         for (; i &lt; length; ++i) {
<span class="line-modified"> 292             JSValue value = object-&gt;get(globalObject, i + offset);</span>
 293             RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified"> 294             firstElementDest[i] = value;</span>
 295         }
 296         return;
 297     } }
 298 }
 299 
<span class="line-modified"> 300 void setupVarargsFrame(JSGlobalObject* globalObject, CallFrame* callFrame, CallFrame* newCallFrame, JSValue arguments, uint32_t offset, uint32_t length)</span>
 301 {
 302     VirtualRegister calleeFrameOffset(newCallFrame - callFrame);
 303 
 304     loadVarargs(
<span class="line-modified"> 305         globalObject,</span>
<span class="line-modified"> 306         bitwise_cast&lt;JSValue*&gt;(&amp;callFrame-&gt;r(calleeFrameOffset + CallFrame::argumentOffset(0))),</span>
 307         arguments, offset, length);
 308 
 309     newCallFrame-&gt;setArgumentCountIncludingThis(length + 1);
 310 }
 311 
<span class="line-modified"> 312 void setupVarargsFrameAndSetThis(JSGlobalObject* globalObject, CallFrame* callFrame, CallFrame* newCallFrame, JSValue thisValue, JSValue arguments, uint32_t firstVarArgOffset, uint32_t length)</span>
 313 {
<span class="line-modified"> 314     setupVarargsFrame(globalObject, callFrame, newCallFrame, arguments, firstVarArgOffset, length);</span>
 315     newCallFrame-&gt;setThisValue(thisValue);
 316 }
 317 
<span class="line-modified"> 318 void setupForwardArgumentsFrame(JSGlobalObject*, CallFrame* execCaller, CallFrame* execCallee, uint32_t length)</span>
 319 {
 320     ASSERT(length == execCaller-&gt;argumentCount());
 321     unsigned offset = execCaller-&gt;argumentOffset(0) * sizeof(Register);
 322     memcpy(reinterpret_cast&lt;char*&gt;(execCallee) + offset, reinterpret_cast&lt;char*&gt;(execCaller) + offset, length * sizeof(Register));
 323     execCallee-&gt;setArgumentCountIncludingThis(length + 1);
 324 }
 325 
<span class="line-modified"> 326 void setupForwardArgumentsFrameAndSetThis(JSGlobalObject* globalObject, CallFrame* execCaller, CallFrame* execCallee, JSValue thisValue, uint32_t length)</span>
 327 {
<span class="line-modified"> 328     setupForwardArgumentsFrame(globalObject, execCaller, execCallee, length);</span>
 329     execCallee-&gt;setThisValue(thisValue);
 330 }
 331 
 332 
 333 
 334 Interpreter::Interpreter(VM&amp; vm)
 335     : m_vm(vm)
 336 #if ENABLE(C_LOOP)
 337     , m_cloopStack(vm)
 338 #endif
 339 {
<span class="line-modified"> 340 #if ASSERT_ENABLED</span>
 341     static std::once_flag assertOnceKey;
 342     std::call_once(assertOnceKey, [] {
 343         for (unsigned i = 0; i &lt; NUMBER_OF_BYTECODE_IDS; ++i) {
 344             OpcodeID opcodeID = static_cast&lt;OpcodeID&gt;(i);
 345             RELEASE_ASSERT(getOpcodeID(getOpcode(opcodeID)) == opcodeID);
 346         }
 347     });
<span class="line-modified"> 348 #endif // ASSERT_ENABLED</span>
 349 }
 350 
 351 Interpreter::~Interpreter()
 352 {
 353 }
 354 
 355 #if ENABLE(COMPUTED_GOTO_OPCODES)
<span class="line-modified"> 356 #if !ENABLE(LLINT_EMBEDDED_OPCODE_ID) || ASSERT_ENABLED</span>
 357 HashMap&lt;Opcode, OpcodeID&gt;&amp; Interpreter::opcodeIDTable()
 358 {
 359     static NeverDestroyed&lt;HashMap&lt;Opcode, OpcodeID&gt;&gt; opcodeIDTable;
 360 
 361     static std::once_flag initializeKey;
 362     std::call_once(initializeKey, [&amp;] {
 363         const Opcode* opcodeTable = LLInt::opcodeMap();
 364         for (unsigned i = 0; i &lt; NUMBER_OF_BYTECODE_IDS; ++i)
 365             opcodeIDTable.get().add(opcodeTable[i], static_cast&lt;OpcodeID&gt;(i));
 366     });
 367 
 368     return opcodeIDTable;
 369 }
<span class="line-modified"> 370 #endif // !ENABLE(LLINT_EMBEDDED_OPCODE_ID) || ASSERT_ENABLED</span>
 371 #endif // ENABLE(COMPUTED_GOTO_OPCODES)
 372 
<span class="line-modified"> 373 #if ASSERT_ENABLED</span>
 374 bool Interpreter::isOpcode(Opcode opcode)
 375 {
 376 #if ENABLE(COMPUTED_GOTO_OPCODES)
 377     return opcode != HashTraits&lt;Opcode&gt;::emptyValue()
 378         &amp;&amp; !HashTraits&lt;Opcode&gt;::isDeletedValue(opcode)
 379         &amp;&amp; opcodeIDTable().contains(opcode);
 380 #else
 381     return opcode &gt;= 0 &amp;&amp; opcode &lt;= op_end;
 382 #endif
 383 }
<span class="line-modified"> 384 #endif // ASSERT_ENABLED</span>
 385 
 386 class GetStackTraceFunctor {
 387 public:
 388     GetStackTraceFunctor(VM&amp; vm, JSCell* owner, Vector&lt;StackFrame&gt;&amp; results, size_t framesToSkip, size_t capacity)
 389         : m_vm(vm)
 390         , m_owner(owner)
 391         , m_results(results)
 392         , m_framesToSkip(framesToSkip)
 393         , m_remainingCapacityForFrameCapture(capacity)
 394     {
 395         m_results.reserveInitialCapacity(capacity);
 396     }
 397 
 398     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 399     {
 400         if (m_framesToSkip &gt; 0) {
 401             m_framesToSkip--;
 402             return StackVisitor::Continue;
 403         }
 404 
 405         if (m_remainingCapacityForFrameCapture) {
 406             if (visitor-&gt;isWasmFrame()) {
 407                 m_results.append(StackFrame(visitor-&gt;wasmFunctionIndexOrName()));
 408             } else if (!!visitor-&gt;codeBlock() &amp;&amp; !visitor-&gt;codeBlock()-&gt;unlinkedCodeBlock()-&gt;isBuiltinFunction()) {
 409                 m_results.append(
<span class="line-modified"> 410                     StackFrame(m_vm, m_owner, visitor-&gt;callee().asCell(), visitor-&gt;codeBlock(), visitor-&gt;bytecodeIndex()));</span>
 411             } else {
 412                 m_results.append(
 413                     StackFrame(m_vm, m_owner, visitor-&gt;callee().asCell()));
 414             }
 415 
 416             m_remainingCapacityForFrameCapture--;
 417             return StackVisitor::Continue;
 418         }
 419         return StackVisitor::Done;
 420     }
 421 
 422 private:
 423     VM&amp; m_vm;
 424     JSCell* m_owner;
 425     Vector&lt;StackFrame&gt;&amp; m_results;
 426     mutable size_t m_framesToSkip;
 427     mutable size_t m_remainingCapacityForFrameCapture;
 428 };
 429 
 430 void Interpreter::getStackTrace(JSCell* owner, Vector&lt;StackFrame&gt;&amp; results, size_t framesToSkip, size_t maxStackSize)
 431 {
 432     DisallowGC disallowGC;
 433     VM&amp; vm = m_vm;
 434     CallFrame* callFrame = vm.topCallFrame;
 435     if (!callFrame || !maxStackSize)
 436         return;
 437 
 438     size_t framesCount = 0;
 439     size_t maxFramesCountNeeded = maxStackSize + framesToSkip;
<span class="line-modified"> 440     StackVisitor::visit(callFrame, vm, [&amp;] (StackVisitor&amp;) -&gt; StackVisitor::Status {</span>
 441         if (++framesCount &lt; maxFramesCountNeeded)
 442             return StackVisitor::Continue;
 443         return StackVisitor::Done;
 444     });
 445     if (framesCount &lt;= framesToSkip)
 446         return;
 447 
 448     framesCount -= framesToSkip;
 449     framesCount = std::min(maxStackSize, framesCount);
 450 
 451     GetStackTraceFunctor functor(vm, owner, results, framesToSkip, framesCount);
<span class="line-modified"> 452     StackVisitor::visit(callFrame, vm, functor);</span>
 453     ASSERT(results.size() == results.capacity());
 454 }
 455 
 456 String Interpreter::stackTraceAsString(VM&amp; vm, const Vector&lt;StackFrame&gt;&amp; stackTrace)
 457 {
 458     // FIXME: JSStringJoiner could be more efficient than StringBuilder here.
 459     StringBuilder builder;
 460     for (unsigned i = 0; i &lt; stackTrace.size(); i++) {
 461         builder.append(String(stackTrace[i].toString(vm)));
 462         if (i != stackTrace.size() - 1)
 463             builder.append(&#39;\n&#39;);
 464     }
 465     return builder.toString();
 466 }
 467 
 468 ALWAYS_INLINE static HandlerInfo* findExceptionHandler(StackVisitor&amp; visitor, CodeBlock* codeBlock, RequiredHandler requiredHandler)
 469 {
 470     ASSERT(codeBlock);
 471 #if ENABLE(DFG_JIT)
 472     ASSERT(!visitor-&gt;isInlinedFrame());
 473 #endif
 474 
 475     CallFrame* callFrame = visitor-&gt;callFrame();
 476     unsigned exceptionHandlerIndex;
 477     if (JITCode::isOptimizingJIT(codeBlock-&gt;jitType()))
 478         exceptionHandlerIndex = callFrame-&gt;callSiteIndex().bits();
 479     else
<span class="line-modified"> 480         exceptionHandlerIndex = callFrame-&gt;bytecodeIndex().offset();</span>
 481 
 482     return codeBlock-&gt;handlerForIndex(exceptionHandlerIndex, requiredHandler);
 483 }
 484 
 485 class GetCatchHandlerFunctor {
 486 public:
 487     GetCatchHandlerFunctor()
 488         : m_handler(0)
 489     {
 490     }
 491 
 492     HandlerInfo* handler() { return m_handler; }
 493 
 494     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 495     {
 496         visitor.unwindToMachineCodeBlockFrame();
 497 
 498         CodeBlock* codeBlock = visitor-&gt;codeBlock();
 499         if (!codeBlock)
 500             return StackVisitor::Continue;
 501 
 502         m_handler = findExceptionHandler(visitor, codeBlock, RequiredHandler::CatchHandler);
 503         if (m_handler)
 504             return StackVisitor::Done;
 505 
 506         return StackVisitor::Continue;
 507     }
 508 
 509 private:
 510     mutable HandlerInfo* m_handler;
 511 };
 512 
 513 ALWAYS_INLINE static void notifyDebuggerOfUnwinding(VM&amp; vm, CallFrame* callFrame)
 514 {
<span class="line-added"> 515     JSGlobalObject* globalObject = callFrame-&gt;lexicalGlobalObject(vm);</span>
 516     auto catchScope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified"> 517     if (Debugger* debugger = globalObject-&gt;debugger()) {</span>
 518         SuspendExceptionScope scope(&amp;vm);
 519         if (callFrame-&gt;isAnyWasmCallee()
 520             || (callFrame-&gt;callee().isCell() &amp;&amp; callFrame-&gt;callee().asCell()-&gt;inherits&lt;JSFunction&gt;(vm)))
 521             debugger-&gt;unwindEvent(callFrame);
 522         else
 523             debugger-&gt;didExecuteProgram(callFrame);
 524         catchScope.assertNoException();
 525     }
 526 }
 527 
 528 class UnwindFunctor {
 529 public:
 530     UnwindFunctor(VM&amp; vm, CallFrame*&amp; callFrame, bool isTermination, CodeBlock*&amp; codeBlock, HandlerInfo*&amp; handler)
 531         : m_vm(vm)
 532         , m_callFrame(callFrame)
 533         , m_isTermination(isTermination)
 534         , m_codeBlock(codeBlock)
 535         , m_handler(handler)
 536     {
 537     }
 538 
 539     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 540     {
 541         visitor.unwindToMachineCodeBlockFrame();
 542         m_callFrame = visitor-&gt;callFrame();
 543         m_codeBlock = visitor-&gt;codeBlock();
 544 
 545         m_handler = nullptr;
<span class="line-modified"> 546         if (m_codeBlock) {</span>
<span class="line-modified"> 547             // FIXME: We should support exception handling in checkpoints.</span>
<span class="line-added"> 548 #if ENABLE(DFG_JIT)</span>
<span class="line-added"> 549             if (removeCodePtrTag(m_returnPC) == LLInt::getCodePtr&lt;NoPtrTag&gt;(checkpoint_osr_exit_from_inlined_call_trampoline).executableAddress())</span>
<span class="line-added"> 550                 m_codeBlock-&gt;vm().findCheckpointOSRSideState(m_callFrame);</span>
<span class="line-added"> 551 #endif</span>
<span class="line-added"> 552             if (!m_isTermination) {</span>
 553                 m_handler = findExceptionHandler(visitor, m_codeBlock, RequiredHandler::AnyHandler);
 554                 if (m_handler)
 555                     return StackVisitor::Done;
 556             }
 557         }
 558 
 559 #if ENABLE(WEBASSEMBLY)
 560         if (visitor-&gt;callee().isCell()) {
 561             if (auto* jsToWasmICCallee = jsDynamicCast&lt;JSToWasmICCallee*&gt;(m_vm, visitor-&gt;callee().asCell()))
 562                 m_vm.wasmContext.store(jsToWasmICCallee-&gt;function()-&gt;previousInstance(m_callFrame), m_vm.softStackLimit());
 563         }
 564 #endif
 565 
 566         notifyDebuggerOfUnwinding(m_vm, m_callFrame);
 567 
 568         copyCalleeSavesToEntryFrameCalleeSavesBuffer(visitor);
 569 
 570         bool shouldStopUnwinding = visitor-&gt;callerIsEntryFrame();
 571         if (shouldStopUnwinding)
 572             return StackVisitor::Done;
 573 
<span class="line-added"> 574         m_returnPC = m_callFrame-&gt;returnPC().value();</span>
 575         return StackVisitor::Continue;
 576     }
 577 
 578 private:
 579     void copyCalleeSavesToEntryFrameCalleeSavesBuffer(StackVisitor&amp; visitor) const
 580     {
 581 #if ENABLE(ASSEMBLER)
 582         Optional&lt;RegisterAtOffsetList&gt; currentCalleeSaves = visitor-&gt;calleeSaveRegistersForUnwinding();
 583 
 584         if (!currentCalleeSaves)
 585             return;
 586 
 587         RegisterAtOffsetList* allCalleeSaves = RegisterSet::vmCalleeSaveRegisterOffsets();
 588         RegisterSet dontCopyRegisters = RegisterSet::stackRegisters();
 589         CPURegister* frame = reinterpret_cast&lt;CPURegister*&gt;(m_callFrame-&gt;registers());
 590 
 591         unsigned registerCount = currentCalleeSaves-&gt;size();
 592         VMEntryRecord* record = vmEntryRecord(m_vm.topEntryFrame);
 593         for (unsigned i = 0; i &lt; registerCount; i++) {
 594             RegisterAtOffset currentEntry = currentCalleeSaves-&gt;at(i);
 595             if (dontCopyRegisters.get(currentEntry.reg()))
 596                 continue;
 597             RegisterAtOffset* calleeSavesEntry = allCalleeSaves-&gt;find(currentEntry.reg());
 598 
 599             record-&gt;calleeSaveRegistersBuffer[calleeSavesEntry-&gt;offsetAsIndex()] = *(frame + currentEntry.offsetAsIndex());
 600         }
 601 #else
 602         UNUSED_PARAM(visitor);
 603 #endif
 604     }
 605 
 606     VM&amp; m_vm;
 607     CallFrame*&amp; m_callFrame;
 608     bool m_isTermination;
 609     CodeBlock*&amp; m_codeBlock;
 610     HandlerInfo*&amp; m_handler;
<span class="line-added"> 611     mutable const void* m_returnPC { nullptr };</span>
 612 };
 613 
 614 NEVER_INLINE HandlerInfo* Interpreter::unwind(VM&amp; vm, CallFrame*&amp; callFrame, Exception* exception)
 615 {
 616     auto scope = DECLARE_CATCH_SCOPE(vm);
 617 
 618     ASSERT(reinterpret_cast&lt;void*&gt;(callFrame) != vm.topEntryFrame);
 619     CodeBlock* codeBlock = callFrame-&gt;codeBlock();
 620 
 621     JSValue exceptionValue = exception-&gt;value();
 622     ASSERT(!exceptionValue.isEmpty());
 623     ASSERT(!exceptionValue.isCell() || exceptionValue.asCell());
 624     // This shouldn&#39;t be possible (hence the assertions), but we&#39;re already in the slowest of
 625     // slow cases, so let&#39;s harden against it anyway to be safe.
 626     if (exceptionValue.isEmpty() || (exceptionValue.isCell() &amp;&amp; !exceptionValue.asCell()))
 627         exceptionValue = jsNull();
 628 
 629     EXCEPTION_ASSERT_UNUSED(scope, scope.exception());
 630 
 631     // Calculate an exception handler vPC, unwinding call frames as necessary.
 632     HandlerInfo* handler = nullptr;
 633     UnwindFunctor functor(vm, callFrame, isTerminatedExecutionException(vm, exception), codeBlock, handler);
<span class="line-modified"> 634     StackVisitor::visit&lt;StackVisitor::TerminateIfTopEntryFrameIsEmpty&gt;(callFrame, vm, functor);</span>
 635     if (!handler)
 636         return nullptr;
 637 
 638     return handler;
 639 }
 640 
<span class="line-modified"> 641 void Interpreter::notifyDebuggerOfExceptionToBeThrown(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame, Exception* exception)</span>
 642 {
<span class="line-modified"> 643     Debugger* debugger = globalObject-&gt;debugger();</span>
 644     if (debugger &amp;&amp; debugger-&gt;needsExceptionCallbacks() &amp;&amp; !exception-&gt;didNotifyInspectorOfThrow()) {
 645         // This code assumes that if the debugger is enabled then there is no inlining.
 646         // If that assumption turns out to be false then we&#39;ll ignore the inlined call
 647         // frames.
 648         // https://bugs.webkit.org/show_bug.cgi?id=121754
 649 
 650         bool hasCatchHandler;
 651         bool isTermination = isTerminatedExecutionException(vm, exception);
 652         if (isTermination)
 653             hasCatchHandler = false;
 654         else {
 655             GetCatchHandlerFunctor functor;
<span class="line-modified"> 656             StackVisitor::visit(callFrame, vm, functor);</span>
 657             HandlerInfo* handler = functor.handler();
 658             ASSERT(!handler || handler-&gt;isCatchHandler());
 659             hasCatchHandler = !!handler;
 660         }
 661 
<span class="line-modified"> 662         debugger-&gt;exception(globalObject, callFrame, exception-&gt;value(), hasCatchHandler);</span>
 663     }
 664     exception-&gt;setDidNotifyInspectorOfThrow();
 665 }
 666 
<span class="line-modified"> 667 JSValue Interpreter::executeProgram(const SourceCode&amp; source, JSGlobalObject*, JSObject* thisObj)</span>
 668 {
 669     JSScope* scope = thisObj-&gt;globalObject()-&gt;globalScope();
 670     VM&amp; vm = scope-&gt;vm();
 671     auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-added"> 672     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);</span>
<span class="line-added"> 673     JSCallee* globalCallee = globalObject-&gt;globalCallee();</span>
 674 
<span class="line-modified"> 675     ProgramExecutable* program = ProgramExecutable::create(globalObject, source);</span>
 676     EXCEPTION_ASSERT(throwScope.exception() || program);
 677     RETURN_IF_EXCEPTION(throwScope, { });
 678 
 679     throwScope.assertNoException();
 680     ASSERT(!vm.isCollectorBusyOnCurrentThread());
 681     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
 682     if (vm.isCollectorBusyOnCurrentThread())
 683         return jsNull();
 684 
 685     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
<span class="line-modified"> 686         return checkedReturn(throwStackOverflowError(globalObject, throwScope));</span>
 687 
 688     // First check if the &quot;program&quot; is actually just a JSON object. If so,
 689     // we&#39;ll handle the JSON object here. Else, we&#39;ll handle real JS code
 690     // below at failedJSONP.
 691 

 692     Vector&lt;JSONPData&gt; JSONPData;
 693     bool parseResult;
 694     StringView programSource = program-&gt;source().view();
 695     if (programSource.isNull())
 696         return jsUndefined();
 697     if (programSource.is8Bit()) {
<span class="line-modified"> 698         LiteralParser&lt;LChar&gt; literalParser(globalObject, programSource.characters8(), programSource.length(), JSONP);</span>
 699         parseResult = literalParser.tryJSONPParse(JSONPData, globalObject-&gt;globalObjectMethodTable()-&gt;supportsRichSourceInfo(globalObject));
 700     } else {
<span class="line-modified"> 701         LiteralParser&lt;UChar&gt; literalParser(globalObject, programSource.characters16(), programSource.length(), JSONP);</span>
 702         parseResult = literalParser.tryJSONPParse(JSONPData, globalObject-&gt;globalObjectMethodTable()-&gt;supportsRichSourceInfo(globalObject));
 703     }
 704 
 705     RETURN_IF_EXCEPTION(throwScope, { });
 706     if (parseResult) {
 707         JSValue result;
 708         for (unsigned entry = 0; entry &lt; JSONPData.size(); entry++) {
 709             Vector&lt;JSONPPathEntry&gt; JSONPPath;
 710             JSONPPath.swap(JSONPData[entry].m_path);
 711             JSValue JSONPValue = JSONPData[entry].m_value.get();
 712             if (JSONPPath.size() == 1 &amp;&amp; JSONPPath[0].m_type == JSONPPathEntryTypeDeclareVar) {
<span class="line-modified"> 713                 globalObject-&gt;addVar(globalObject, JSONPPath[0].m_pathEntryName);</span>
 714                 RETURN_IF_EXCEPTION(throwScope, { });
 715                 PutPropertySlot slot(globalObject);
<span class="line-modified"> 716                 globalObject-&gt;methodTable(vm)-&gt;put(globalObject, globalObject, JSONPPath[0].m_pathEntryName, JSONPValue, slot);</span>
 717                 RETURN_IF_EXCEPTION(throwScope, { });
 718                 result = jsUndefined();
 719                 continue;
 720             }
 721             JSValue baseObject(globalObject);
 722             for (unsigned i = 0; i &lt; JSONPPath.size() - 1; i++) {
 723                 ASSERT(JSONPPath[i].m_type != JSONPPathEntryTypeDeclareVar);
 724                 switch (JSONPPath[i].m_type) {
 725                 case JSONPPathEntryTypeDot: {
 726                     if (i == 0) {
 727                         RELEASE_ASSERT(baseObject == globalObject);
 728 
 729                         auto doGet = [&amp;] (JSSegmentedVariableObject* scope) {
 730                             PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
<span class="line-modified"> 731                             if (scope-&gt;getPropertySlot(globalObject, JSONPPath[i].m_pathEntryName, slot))</span>
<span class="line-modified"> 732                                 return slot.getValue(globalObject, JSONPPath[i].m_pathEntryName);</span>
 733                             return JSValue();
 734                         };
 735 
 736                         JSValue result = doGet(globalObject-&gt;globalLexicalEnvironment());
 737                         RETURN_IF_EXCEPTION(throwScope, JSValue());
 738                         if (result) {
 739                             baseObject = result;
 740                             continue;
 741                         }
 742 
 743                         result = doGet(globalObject);
 744                         RETURN_IF_EXCEPTION(throwScope, JSValue());
 745                         if (result) {
 746                             baseObject = result;
 747                             continue;
 748                         }
 749 
 750                         if (entry)
<span class="line-modified"> 751                             return throwException(globalObject, throwScope, createUndefinedVariableError(globalObject, JSONPPath[i].m_pathEntryName));</span>
 752                         goto failedJSONP;
 753                     }
 754 
<span class="line-modified"> 755                     baseObject = baseObject.get(globalObject, JSONPPath[i].m_pathEntryName);</span>
 756                     RETURN_IF_EXCEPTION(throwScope, JSValue());
 757                     continue;
 758                 }
 759                 case JSONPPathEntryTypeLookup: {
<span class="line-modified"> 760                     baseObject = baseObject.get(globalObject, static_cast&lt;unsigned&gt;(JSONPPath[i].m_pathIndex));</span>
 761                     RETURN_IF_EXCEPTION(throwScope, JSValue());
 762                     continue;
 763                 }
 764                 default:
 765                     RELEASE_ASSERT_NOT_REACHED();
 766                     return jsUndefined();
 767                 }
 768             }
 769 
 770             if (JSONPPath.size() == 1 &amp;&amp; JSONPPath.last().m_type != JSONPPathEntryTypeLookup) {
 771                 RELEASE_ASSERT(baseObject == globalObject);
 772                 JSGlobalLexicalEnvironment* scope = globalObject-&gt;globalLexicalEnvironment();
<span class="line-modified"> 773                 if (scope-&gt;hasProperty(globalObject, JSONPPath.last().m_pathEntryName))</span>
 774                     baseObject = scope;
 775                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 776             }
 777 
 778             PutPropertySlot slot(baseObject);
 779             switch (JSONPPath.last().m_type) {
 780             case JSONPPathEntryTypeCall: {
<span class="line-modified"> 781                 JSValue function = baseObject.get(globalObject, JSONPPath.last().m_pathEntryName);</span>
 782                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 783                 CallData callData;
 784                 CallType callType = getCallData(vm, function, callData);
 785                 if (callType == CallType::None)
<span class="line-modified"> 786                     return throwException(globalObject, throwScope, createNotAFunctionError(globalObject, function));</span>
 787                 MarkedArgumentBuffer jsonArg;
 788                 jsonArg.append(JSONPValue);
 789                 ASSERT(!jsonArg.hasOverflowed());
 790                 JSValue thisValue = JSONPPath.size() == 1 ? jsUndefined() : baseObject;
<span class="line-modified"> 791                 JSONPValue = JSC::call(globalObject, function, callType, callData, thisValue, jsonArg);</span>
 792                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 793                 break;
 794             }
 795             case JSONPPathEntryTypeDot: {
<span class="line-modified"> 796                 baseObject.put(globalObject, JSONPPath.last().m_pathEntryName, JSONPValue, slot);</span>
 797                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 798                 break;
 799             }
 800             case JSONPPathEntryTypeLookup: {
<span class="line-modified"> 801                 baseObject.putByIndex(globalObject, JSONPPath.last().m_pathIndex, JSONPValue, slot.isStrictMode());</span>
 802                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 803                 break;
 804             }
 805             default:
 806                 RELEASE_ASSERT_NOT_REACHED();
 807                 return jsUndefined();
 808             }
 809             result = JSONPValue;
 810         }
 811         return result;
 812     }
 813 failedJSONP:
 814     // If we get here, then we have already proven that the script is not a JSON
 815     // object.
 816 
 817     VMEntryScope entryScope(vm, globalObject);
 818 
 819     // Compile source to bytecode if necessary:
<span class="line-modified"> 820     JSObject* error = program-&gt;initializeGlobalProperties(vm, globalObject, scope);</span>
 821     EXCEPTION_ASSERT(!throwScope.exception() || !error);
 822     if (UNLIKELY(error))
<span class="line-modified"> 823         return checkedReturn(throwException(globalObject, throwScope, error));</span>
 824 
 825     ProgramCodeBlock* codeBlock;
 826     {
 827         CodeBlock* tempCodeBlock;
 828         Exception* error = program-&gt;prepareForExecution&lt;ProgramExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);
 829         EXCEPTION_ASSERT(throwScope.exception() == error);
 830         if (UNLIKELY(error))
 831             return checkedReturn(error);
 832         codeBlock = jsCast&lt;ProgramCodeBlock*&gt;(tempCodeBlock);
 833     }
 834 
<span class="line-modified"> 835     constexpr auto trapsMask = VMTraps::interruptingTraps();</span>
<span class="line-modified"> 836     if (UNLIKELY(vm.needTrapHandling(trapsMask))) {</span>
<span class="line-modified"> 837         vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);</span>
 838         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
 839     }
 840 
 841     if (scope-&gt;structure(vm)-&gt;isUncacheableDictionary())
 842         scope-&gt;flattenDictionaryObject(vm);
 843 
 844     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
 845 
 846     ProtoCallFrame protoCallFrame;
<span class="line-modified"> 847     protoCallFrame.init(codeBlock, globalObject, globalCallee, thisObj, 1);</span>
 848 
 849     // Execute the code:
 850     throwScope.release();
 851     JSValue result = program-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
 852     return checkedReturn(result);
 853 }
 854 
<span class="line-modified"> 855 JSValue Interpreter::executeCall(JSGlobalObject* lexicalGlobalObject, JSObject* function, CallType callType, const CallData&amp; callData, JSValue thisValue, const ArgList&amp; args)</span>
 856 {
<span class="line-modified"> 857     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
 858     auto throwScope = DECLARE_THROW_SCOPE(vm);
 859 
 860     throwScope.assertNoException();
 861     ASSERT(!vm.isCollectorBusyOnCurrentThread());
 862     if (vm.isCollectorBusyOnCurrentThread())
 863         return jsNull();
 864 
 865     bool isJSCall = (callType == CallType::JS);
 866     JSScope* scope = nullptr;
 867     CodeBlock* newCodeBlock;
 868     size_t argsCount = 1 + args.size(); // implicit &quot;this&quot; parameter
 869 
 870     JSGlobalObject* globalObject;
 871 
 872     if (isJSCall) {
 873         scope = callData.js.scope;
 874         globalObject = scope-&gt;globalObject(vm);
 875     } else {
 876         ASSERT(callType == CallType::Host);
 877         globalObject = function-&gt;globalObject(vm);
 878     }
 879 
 880     VMEntryScope entryScope(vm, globalObject);
<span class="line-modified"> 881     if (UNLIKELY(!vm.isSafeToRecurseSoft() || args.size() &gt; maxArguments))</span>
<span class="line-modified"> 882         return checkedReturn(throwStackOverflowError(globalObject, throwScope));</span>
 883 
 884     if (isJSCall) {
 885         // Compile the callee:
 886         Exception* compileError = callData.js.functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, jsCast&lt;JSFunction*&gt;(function), scope, CodeForCall, newCodeBlock);
 887         EXCEPTION_ASSERT(throwScope.exception() == compileError);
 888         if (UNLIKELY(!!compileError))
 889             return checkedReturn(compileError);
 890 
 891         ASSERT(!!newCodeBlock);
 892         newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
 893     } else
 894         newCodeBlock = 0;
 895 
<span class="line-modified"> 896     constexpr auto trapsMask = VMTraps::interruptingTraps();</span>
<span class="line-modified"> 897     if (UNLIKELY(vm.needTrapHandling(trapsMask))) {</span>
<span class="line-modified"> 898         vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);</span>
 899         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
 900     }
 901 
 902     ProtoCallFrame protoCallFrame;
<span class="line-modified"> 903     protoCallFrame.init(newCodeBlock, globalObject, function, thisValue, argsCount, args.data());</span>
 904 
 905     JSValue result;
 906     {
 907         // Execute the code:
 908         if (isJSCall) {
 909             throwScope.release();
 910             result = callData.js.functionExecutable-&gt;generatedJITCodeForCall()-&gt;execute(&amp;vm, &amp;protoCallFrame);
 911         } else {
 912             result = JSValue::decode(vmEntryToNative(callData.native.function.rawPointer(), &amp;vm, &amp;protoCallFrame));
 913             RETURN_IF_EXCEPTION(throwScope, JSValue());
 914         }
 915     }
 916 
 917     return checkedReturn(result);
 918 }
 919 
<span class="line-modified"> 920 JSObject* Interpreter::executeConstruct(JSGlobalObject* lexicalGlobalObject, JSObject* constructor, ConstructType constructType, const ConstructData&amp; constructData, const ArgList&amp; args, JSValue newTarget)</span>
 921 {
<span class="line-modified"> 922     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
 923     auto throwScope = DECLARE_THROW_SCOPE(vm);
 924 
 925     throwScope.assertNoException();
 926     ASSERT(!vm.isCollectorBusyOnCurrentThread());
 927     // We throw in this case because we have to return something &quot;valid&quot; but we&#39;re
 928     // already in an invalid state.
 929     if (UNLIKELY(vm.isCollectorBusyOnCurrentThread())) {
<span class="line-modified"> 930         throwStackOverflowError(lexicalGlobalObject, throwScope);</span>
 931         return nullptr;
 932     }
 933 
 934     bool isJSConstruct = (constructType == ConstructType::JS);
 935     JSScope* scope = nullptr;
 936     CodeBlock* newCodeBlock;
 937     size_t argsCount = 1 + args.size(); // implicit &quot;this&quot; parameter
 938 
 939     JSGlobalObject* globalObject;
 940 
 941     if (isJSConstruct) {
 942         scope = constructData.js.scope;
 943         globalObject = scope-&gt;globalObject(vm);
 944     } else {
 945         ASSERT(constructType == ConstructType::Host);
 946         globalObject = constructor-&gt;globalObject(vm);
 947     }
 948 
 949     VMEntryScope entryScope(vm, globalObject);
<span class="line-modified"> 950     if (UNLIKELY(!vm.isSafeToRecurseSoft() || args.size() &gt; maxArguments)) {</span>
<span class="line-modified"> 951         throwStackOverflowError(globalObject, throwScope);</span>
 952         return nullptr;
 953     }
 954 
 955     if (isJSConstruct) {
 956         // Compile the callee:
 957         Exception* compileError = constructData.js.functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, jsCast&lt;JSFunction*&gt;(constructor), scope, CodeForConstruct, newCodeBlock);
 958         EXCEPTION_ASSERT(throwScope.exception() == compileError);
 959         if (UNLIKELY(!!compileError))
 960             return nullptr;
 961 
 962         ASSERT(!!newCodeBlock);
 963         newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
 964     } else
 965         newCodeBlock = 0;
 966 
<span class="line-modified"> 967     constexpr auto trapsMask = VMTraps::interruptingTraps();</span>
<span class="line-modified"> 968     if (UNLIKELY(vm.needTrapHandling(trapsMask))) {</span>
<span class="line-modified"> 969         vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);</span>
 970         RETURN_IF_EXCEPTION(throwScope, nullptr);
 971     }
 972 
 973     ProtoCallFrame protoCallFrame;
<span class="line-modified"> 974     protoCallFrame.init(newCodeBlock, globalObject, constructor, newTarget, argsCount, args.data());</span>
 975 
 976     JSValue result;
 977     {
 978         // Execute the code.
 979         if (isJSConstruct)
 980             result = constructData.js.functionExecutable-&gt;generatedJITCodeForConstruct()-&gt;execute(&amp;vm, &amp;protoCallFrame);
 981         else {
 982             result = JSValue::decode(vmEntryToNative(constructData.native.function.rawPointer(), &amp;vm, &amp;protoCallFrame));
 983 
 984             if (LIKELY(!throwScope.exception()))
 985                 RELEASE_ASSERT(result.isObject());
 986         }
 987     }
 988 
 989     RETURN_IF_EXCEPTION(throwScope, 0);
 990     ASSERT(result.isObject());
 991     return checkedReturn(asObject(result));
 992 }
 993 
 994 CallFrameClosure Interpreter::prepareForRepeatCall(FunctionExecutable* functionExecutable, CallFrame* callFrame, ProtoCallFrame* protoCallFrame, JSFunction* function, int argumentCountIncludingThis, JSScope* scope, const ArgList&amp; args)
 995 {
 996     VM&amp; vm = scope-&gt;vm();
 997     auto throwScope = DECLARE_THROW_SCOPE(vm);
 998     throwScope.assertNoException();
 999 
1000     if (vm.isCollectorBusyOnCurrentThread())
1001         return CallFrameClosure();
1002 
1003     // Compile the callee:
1004     CodeBlock* newCodeBlock;
1005     Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, function, scope, CodeForCall, newCodeBlock);
1006     EXCEPTION_ASSERT(throwScope.exception() == error);
1007     if (UNLIKELY(error))
1008         return CallFrameClosure();
1009     newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
1010 
1011     size_t argsCount = argumentCountIncludingThis;
1012 
<span class="line-modified">1013     protoCallFrame-&gt;init(newCodeBlock, function-&gt;globalObject(), function, jsUndefined(), argsCount, args.data());</span>
1014     // Return the successful closure:
1015     CallFrameClosure result = { callFrame, protoCallFrame, function, functionExecutable, &amp;vm, scope, newCodeBlock-&gt;numParameters(), argumentCountIncludingThis };
1016     return result;
1017 }
1018 
<span class="line-modified">1019 JSValue Interpreter::execute(EvalExecutable* eval, JSGlobalObject* lexicalGlobalObject, JSValue thisValue, JSScope* scope)</span>
1020 {
1021     VM&amp; vm = scope-&gt;vm();
1022     auto throwScope = DECLARE_THROW_SCOPE(vm);
1023 
<span class="line-modified">1024     ASSERT_UNUSED(lexicalGlobalObject, &amp;vm == &amp;lexicalGlobalObject-&gt;vm());</span>
1025     throwScope.assertNoException();
1026     ASSERT(!vm.isCollectorBusyOnCurrentThread());
1027     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
1028     if (vm.isCollectorBusyOnCurrentThread())
1029         return jsNull();
1030 
<span class="line-modified">1031     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);</span>
<span class="line-added">1032     VMEntryScope entryScope(vm, globalObject);</span>
1033     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
<span class="line-modified">1034         return checkedReturn(throwStackOverflowError(globalObject, throwScope));</span>
1035 
1036     unsigned numVariables = eval-&gt;numVariables();
1037     unsigned numTopLevelFunctionDecls = eval-&gt;numTopLevelFunctionDecls();
1038     unsigned numFunctionHoistingCandidates = eval-&gt;numFunctionHoistingCandidates();
1039 
1040     JSScope* variableObject;
1041     if ((numVariables || numTopLevelFunctionDecls) &amp;&amp; eval-&gt;isStrictMode()) {
<span class="line-modified">1042         scope = StrictEvalActivation::create(vm, globalObject-&gt;strictEvalActivationStructure(), scope);</span>
1043         variableObject = scope;
1044     } else {
1045         for (JSScope* node = scope; ; node = node-&gt;next()) {
1046             RELEASE_ASSERT(node);
1047             if (node-&gt;isGlobalObject()) {
1048                 variableObject = node;
1049                 break;
1050             }
1051             if (node-&gt;isJSLexicalEnvironment()) {
1052                 JSLexicalEnvironment* lexicalEnvironment = jsCast&lt;JSLexicalEnvironment*&gt;(node);
1053                 if (lexicalEnvironment-&gt;symbolTable()-&gt;scopeType() == SymbolTable::ScopeType::VarScope) {
1054                     variableObject = node;
1055                     break;
1056                 }
1057             }
1058         }
1059     }
1060 
1061     EvalCodeBlock* codeBlock;
1062     {
1063         CodeBlock* tempCodeBlock;
1064         Exception* compileError = eval-&gt;prepareForExecution&lt;EvalExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);
1065         EXCEPTION_ASSERT(throwScope.exception() == compileError);
1066         if (UNLIKELY(!!compileError))
1067             return checkedReturn(compileError);
1068         codeBlock = jsCast&lt;EvalCodeBlock*&gt;(tempCodeBlock);
1069     }
1070     UnlinkedEvalCodeBlock* unlinkedCodeBlock = codeBlock-&gt;unlinkedEvalCodeBlock();
1071 
1072     // We can&#39;t declare a &quot;var&quot;/&quot;function&quot; that overwrites a global &quot;let&quot;/&quot;const&quot;/&quot;class&quot; in a sloppy-mode eval.
1073     if (variableObject-&gt;isGlobalObject() &amp;&amp; !eval-&gt;isStrictMode() &amp;&amp; (numVariables || numTopLevelFunctionDecls)) {
1074         JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalObject*&gt;(variableObject)-&gt;globalLexicalEnvironment();
1075         for (unsigned i = 0; i &lt; numVariables; ++i) {
1076             const Identifier&amp; ident = unlinkedCodeBlock-&gt;variable(i);
1077             PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">1078             if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, globalObject, ident, slot)) {</span>
<span class="line-modified">1079                 return checkedReturn(throwTypeError(globalObject, throwScope, makeString(&quot;Can&#39;t create duplicate global variable in eval: &#39;&quot;, String(ident.impl()), &quot;&#39;&quot;)));</span>
1080             }
1081         }
1082 
1083         for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
1084             FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
1085             PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">1086             if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, globalObject, function-&gt;name(), slot)) {</span>
<span class="line-modified">1087                 return checkedReturn(throwTypeError(globalObject, throwScope, makeString(&quot;Can&#39;t create duplicate global variable in eval: &#39;&quot;, String(function-&gt;name().impl()), &quot;&#39;&quot;)));</span>
1088             }
1089         }
1090     }
1091 
1092     if (variableObject-&gt;structure(vm)-&gt;isUncacheableDictionary())
1093         variableObject-&gt;flattenDictionaryObject(vm);
1094 
1095     if (numVariables || numTopLevelFunctionDecls || numFunctionHoistingCandidates) {
1096         BatchedTransitionOptimizer optimizer(vm, variableObject);
1097         if (variableObject-&gt;next() &amp;&amp; !eval-&gt;isStrictMode())
1098             variableObject-&gt;globalObject(vm)-&gt;varInjectionWatchpoint()-&gt;fireAll(vm, &quot;Executed eval, fired VarInjection watchpoint&quot;);
1099 
1100         for (unsigned i = 0; i &lt; numVariables; ++i) {
1101             const Identifier&amp; ident = unlinkedCodeBlock-&gt;variable(i);
<span class="line-modified">1102             bool hasProperty = variableObject-&gt;hasProperty(globalObject, ident);</span>
1103             RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1104             if (!hasProperty) {
1105                 PutPropertySlot slot(variableObject);
<span class="line-modified">1106                 if (!variableObject-&gt;isExtensible(globalObject))</span>
<span class="line-modified">1107                     return checkedReturn(throwTypeError(globalObject, throwScope, NonExtensibleObjectPropertyDefineError));</span>
<span class="line-modified">1108                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, globalObject, ident, jsUndefined(), slot);</span>
1109                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1110             }
1111         }
1112 
1113         if (eval-&gt;isStrictMode()) {
1114             for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
1115                 FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
1116                 PutPropertySlot slot(variableObject);
1117                 // We need create this variables because it will be used to emits code by bytecode generator
<span class="line-modified">1118                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, globalObject, function-&gt;name(), jsUndefined(), slot);</span>
1119                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1120             }
1121         } else {
1122             for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
1123                 FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
<span class="line-modified">1124                 JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(globalObject, scope, function-&gt;name());</span>
1125                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1126                 if (resolvedScope.isUndefined())
<span class="line-modified">1127                     return checkedReturn(throwSyntaxError(globalObject, throwScope, makeString(&quot;Can&#39;t create duplicate variable in eval: &#39;&quot;, String(function-&gt;name().impl()), &quot;&#39;&quot;)));</span>
1128                 PutPropertySlot slot(variableObject);
1129                 // We need create this variables because it will be used to emits code by bytecode generator
<span class="line-modified">1130                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, globalObject, function-&gt;name(), jsUndefined(), slot);</span>
1131                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1132             }
1133 
1134             for (unsigned i = 0; i &lt; numFunctionHoistingCandidates; ++i) {
1135                 const Identifier&amp; ident = unlinkedCodeBlock-&gt;functionHoistingCandidate(i);
<span class="line-modified">1136                 JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(globalObject, scope, ident);</span>
1137                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1138                 if (!resolvedScope.isUndefined()) {
<span class="line-modified">1139                     bool hasProperty = variableObject-&gt;hasProperty(globalObject, ident);</span>
1140                     RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1141                     if (!hasProperty) {
1142                         PutPropertySlot slot(variableObject);
<span class="line-modified">1143                         variableObject-&gt;methodTable(vm)-&gt;put(variableObject, globalObject, ident, jsUndefined(), slot);</span>
1144                         RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1145                     }
1146                 }
1147             }
1148         }
1149     }
1150 
<span class="line-modified">1151     constexpr auto trapsMask = VMTraps::interruptingTraps();</span>
<span class="line-modified">1152     if (UNLIKELY(vm.needTrapHandling(trapsMask))) {</span>
<span class="line-modified">1153         vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);</span>
1154         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
1155     }
1156 
1157     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
1158 
<span class="line-added">1159     JSCallee* callee = nullptr;</span>
<span class="line-added">1160     if (scope == globalObject-&gt;globalScope())</span>
<span class="line-added">1161         callee = globalObject-&gt;globalCallee();</span>
<span class="line-added">1162     else</span>
<span class="line-added">1163         callee = JSCallee::create(vm, globalObject, scope);</span>
1164     ProtoCallFrame protoCallFrame;
<span class="line-modified">1165     protoCallFrame.init(codeBlock, globalObject, callee, thisValue, 1);</span>
1166 
1167     // Execute the code:
1168     throwScope.release();
1169     JSValue result = eval-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
1170 
1171     return checkedReturn(result);
1172 }
1173 
<span class="line-modified">1174 JSValue Interpreter::executeModuleProgram(ModuleProgramExecutable* executable, JSGlobalObject* lexicalGlobalObject, JSModuleEnvironment* scope)</span>
1175 {
1176     VM&amp; vm = scope-&gt;vm();
1177     auto throwScope = DECLARE_THROW_SCOPE(vm);
1178 
<span class="line-modified">1179     ASSERT_UNUSED(lexicalGlobalObject, &amp;vm == &amp;lexicalGlobalObject-&gt;vm());</span>
1180     throwScope.assertNoException();
1181     ASSERT(!vm.isCollectorBusyOnCurrentThread());
1182     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
1183     if (vm.isCollectorBusyOnCurrentThread())
1184         return jsNull();
1185 
<span class="line-added">1186     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);</span>
1187     VMEntryScope entryScope(vm, scope-&gt;globalObject(vm));
1188     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
<span class="line-modified">1189         return checkedReturn(throwStackOverflowError(globalObject, throwScope));</span>
1190 
1191     ModuleProgramCodeBlock* codeBlock;
1192     {
1193         CodeBlock* tempCodeBlock;
1194         Exception* compileError = executable-&gt;prepareForExecution&lt;ModuleProgramExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);
1195         EXCEPTION_ASSERT(throwScope.exception() == compileError);
1196         if (UNLIKELY(!!compileError))
1197             return checkedReturn(compileError);
1198         codeBlock = jsCast&lt;ModuleProgramCodeBlock*&gt;(tempCodeBlock);
1199     }
1200 
<span class="line-modified">1201     constexpr auto trapsMask = VMTraps::interruptingTraps();</span>
<span class="line-modified">1202     if (UNLIKELY(vm.needTrapHandling(trapsMask))) {</span>
<span class="line-modified">1203         vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);</span>
1204         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
1205     }
1206 
1207     if (scope-&gt;structure(vm)-&gt;isUncacheableDictionary())
1208         scope-&gt;flattenDictionaryObject(vm);
1209 
1210     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
1211 
1212     // The |this| of the module is always `undefined`.
1213     // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-hasthisbinding
1214     // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-getthisbinding
1215     ProtoCallFrame protoCallFrame;
<span class="line-modified">1216     protoCallFrame.init(codeBlock, globalObject, JSCallee::create(vm, globalObject, scope), jsUndefined(), 1);</span>
1217 
1218     // Execute the code:
1219     throwScope.release();
1220     JSValue result = executable-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
1221 
1222     return checkedReturn(result);
1223 }
1224 
1225 NEVER_INLINE void Interpreter::debug(CallFrame* callFrame, DebugHookType debugHookType)
1226 {
<span class="line-modified">1227     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
1228     auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">1229     Debugger* debugger = callFrame-&gt;lexicalGlobalObject(vm)-&gt;debugger();</span>
1230     if (!debugger)
1231         return;
1232 
1233     ASSERT(callFrame-&gt;codeBlock()-&gt;hasDebuggerRequests());
1234     scope.assertNoException();
1235 
1236     switch (debugHookType) {
1237         case DidEnterCallFrame:
1238             debugger-&gt;callEvent(callFrame);
1239             break;
1240         case WillLeaveCallFrame:
1241             debugger-&gt;returnEvent(callFrame);
1242             break;
1243         case WillExecuteStatement:
1244             debugger-&gt;atStatement(callFrame);
1245             break;
1246         case WillExecuteExpression:
1247             debugger-&gt;atExpression(callFrame);
1248             break;
1249         case WillExecuteProgram:
1250             debugger-&gt;willExecuteProgram(callFrame);
1251             break;
1252         case DidExecuteProgram:
1253             debugger-&gt;didExecuteProgram(callFrame);
1254             break;
<span class="line-modified">1255         case DidReachDebuggerStatement:</span>
<span class="line-modified">1256             debugger-&gt;didReachDebuggerStatement(callFrame);</span>
1257             break;
1258     }
1259     scope.assertNoException();
1260 }
1261 
1262 } // namespace JSC
1263 
1264 namespace WTF {
1265 
1266 void printInternal(PrintStream&amp; out, JSC::DebugHookType type)
1267 {
1268     switch (type) {
1269     case JSC::WillExecuteProgram:
1270         out.print(&quot;WillExecuteProgram&quot;);
1271         return;
1272     case JSC::DidExecuteProgram:
1273         out.print(&quot;DidExecuteProgram&quot;);
1274         return;
1275     case JSC::DidEnterCallFrame:
1276         out.print(&quot;DidEnterCallFrame&quot;);
1277         return;
<span class="line-modified">1278     case JSC::DidReachDebuggerStatement:</span>
<span class="line-modified">1279         out.print(&quot;DidReachDebuggerStatement&quot;);</span>
1280         return;
1281     case JSC::WillLeaveCallFrame:
1282         out.print(&quot;WillLeaveCallFrame&quot;);
1283         return;
1284     case JSC::WillExecuteStatement:
1285         out.print(&quot;WillExecuteStatement&quot;);
1286         return;
1287     case JSC::WillExecuteExpression:
1288         out.print(&quot;WillExecuteExpression&quot;);
1289         return;
1290     }
1291 }
1292 
1293 } // namespace WTF
</pre>
</td>
</tr>
</table>
<center><a href="FrameTracers.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Interpreter.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
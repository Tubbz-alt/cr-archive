<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSToStyleMap.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSTimingFunctionValue.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSToStyleMap.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSToStyleMap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 43,33 ***</span>
  #include &quot;StyleBuilderConverter.h&quot;
  #include &quot;StyleResolver.h&quot;
  
  namespace WebCore {
  
<span class="line-modified">! CSSToStyleMap::CSSToStyleMap(StyleResolver* resolver)</span>
<span class="line-modified">!     : m_resolver(resolver)</span>
  {
  }
  
  RenderStyle* CSSToStyleMap::style() const
  {
<span class="line-modified">!     return m_resolver-&gt;style();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- const RenderStyle* CSSToStyleMap::rootElementStyle() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return m_resolver-&gt;rootElementStyle();</span>
  }
  
  bool CSSToStyleMap::useSVGZoomRules() const
  {
<span class="line-modified">!     return m_resolver-&gt;useSVGZoomRules();</span>
  }
  
  RefPtr&lt;StyleImage&gt; CSSToStyleMap::styleImage(CSSValue&amp; value)
  {
<span class="line-modified">!     return m_resolver-&gt;styleImage(value);</span>
  }
  
  void CSSToStyleMap::mapFillAttachment(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
  {
      if (value.treatAsInitialValue(propertyID)) {
<span class="line-new-header">--- 43,28 ---</span>
  #include &quot;StyleBuilderConverter.h&quot;
  #include &quot;StyleResolver.h&quot;
  
  namespace WebCore {
  
<span class="line-modified">! CSSToStyleMap::CSSToStyleMap(Style::BuilderState&amp; builderState)</span>
<span class="line-modified">!     : m_builderState(builderState)</span>
  {
  }
  
  RenderStyle* CSSToStyleMap::style() const
  {
<span class="line-modified">!     return &amp;m_builderState.style();</span>
  }
  
  bool CSSToStyleMap::useSVGZoomRules() const
  {
<span class="line-modified">!     return m_builderState.useSVGZoomRules();</span>
  }
  
  RefPtr&lt;StyleImage&gt; CSSToStyleMap::styleImage(CSSValue&amp; value)
  {
<span class="line-modified">!     return m_builderState.createStyleImage(value);</span>
  }
  
  void CSSToStyleMap::mapFillAttachment(CSSPropertyID propertyID, FillLayer&amp; layer, const CSSValue&amp; value)
  {
      if (value.treatAsInitialValue(propertyID)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 212,11 ***</span>
      case CSSValueCover:
          fillSize.type = FillSizeType::Cover;
          break;
      default:
          ASSERT(fillSize.type == FillSizeType::Size);
<span class="line-modified">!         if (!convertToLengthSize(primitiveValue, m_resolver-&gt;state().cssToLengthConversionData(), fillSize.size))</span>
              return;
          break;
      }
      layer.setSize(fillSize);
  }
<span class="line-new-header">--- 207,11 ---</span>
      case CSSValueCover:
          fillSize.type = FillSizeType::Cover;
          break;
      default:
          ASSERT(fillSize.type == FillSizeType::Size);
<span class="line-modified">!         if (!convertToLengthSize(primitiveValue, m_builderState.cssToLengthConversionData(), fillSize.size))</span>
              return;
          break;
      }
      layer.setSize(fillSize);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 234,13 ***</span>
      auto* primitiveValue = &amp;downcast&lt;CSSPrimitiveValue&gt;(value);
      Pair* pair = primitiveValue-&gt;pairValue();
      Length length;
      if (pair) {
          ASSERT_UNUSED(propertyID, propertyID == CSSPropertyBackgroundPositionX || propertyID == CSSPropertyWebkitMaskPositionX);
<span class="line-modified">!         length = StyleBuilderConverter::convertLength(*m_resolver, *pair-&gt;second());</span>
      } else
<span class="line-modified">!         length = StyleBuilderConverter::convertPositionComponentX(*m_resolver, value);</span>
  
      layer.setXPosition(length);
      if (pair)
          layer.setBackgroundXOrigin(*pair-&gt;first());
  }
<span class="line-new-header">--- 229,13 ---</span>
      auto* primitiveValue = &amp;downcast&lt;CSSPrimitiveValue&gt;(value);
      Pair* pair = primitiveValue-&gt;pairValue();
      Length length;
      if (pair) {
          ASSERT_UNUSED(propertyID, propertyID == CSSPropertyBackgroundPositionX || propertyID == CSSPropertyWebkitMaskPositionX);
<span class="line-modified">!         length = Style::BuilderConverter::convertLength(m_builderState, *pair-&gt;second());</span>
      } else
<span class="line-modified">!         length = Style::BuilderConverter::convertPositionComponentX(m_builderState, value);</span>
  
      layer.setXPosition(length);
      if (pair)
          layer.setBackgroundXOrigin(*pair-&gt;first());
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 258,13 ***</span>
      auto* primitiveValue = &amp;downcast&lt;CSSPrimitiveValue&gt;(value);
      Pair* pair = primitiveValue-&gt;pairValue();
      Length length;
      if (pair) {
          ASSERT_UNUSED(propertyID, propertyID == CSSPropertyBackgroundPositionY || propertyID == CSSPropertyWebkitMaskPositionY);
<span class="line-modified">!         length = StyleBuilderConverter::convertLength(*m_resolver, *pair-&gt;second());</span>
      } else
<span class="line-modified">!         length = StyleBuilderConverter::convertPositionComponentY(*m_resolver, value);</span>
  
      layer.setYPosition(length);
      if (pair)
          layer.setBackgroundYOrigin(*pair-&gt;first());
  }
<span class="line-new-header">--- 253,13 ---</span>
      auto* primitiveValue = &amp;downcast&lt;CSSPrimitiveValue&gt;(value);
      Pair* pair = primitiveValue-&gt;pairValue();
      Length length;
      if (pair) {
          ASSERT_UNUSED(propertyID, propertyID == CSSPropertyBackgroundPositionY || propertyID == CSSPropertyWebkitMaskPositionY);
<span class="line-modified">!         length = Style::BuilderConverter::convertLength(m_builderState, *pair-&gt;second());</span>
      } else
<span class="line-modified">!         length = Style::BuilderConverter::convertPositionComponentY(m_builderState, value);</span>
  
      layer.setYPosition(length);
      if (pair)
          layer.setBackgroundYOrigin(*pair-&gt;first());
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 407,11 ***</span>
  
      auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
      if (primitiveValue.valueID() == CSSValueNone)
          layer.setIsNoneAnimation(true);
      else
<span class="line-modified">!         layer.setName(primitiveValue.stringValue(), m_resolver-&gt;state().styleScopeOrdinal());</span>
  }
  
  void CSSToStyleMap::mapAnimationPlayState(Animation&amp; layer, const CSSValue&amp; value)
  {
      if (value.treatAsInitialValue(CSSPropertyAnimationPlayState)) {
<span class="line-new-header">--- 402,11 ---</span>
  
      auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
      if (primitiveValue.valueID() == CSSValueNone)
          layer.setIsNoneAnimation(true);
      else
<span class="line-modified">!         layer.setName(primitiveValue.stringValue(), m_builderState.styleScopeOrdinal());</span>
  }
  
  void CSSToStyleMap::mapAnimationPlayState(Animation&amp; layer, const CSSValue&amp; value)
  {
      if (value.treatAsInitialValue(CSSPropertyAnimationPlayState)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 566,23 ***</span>
      LengthBox box;
      Quad* slices = borderImageSlice.slices();
      if (slices-&gt;top()-&gt;isPercentage())
          box.top() = Length(slices-&gt;top()-&gt;doubleValue(), Percent);
      else
<span class="line-modified">!         box.top() = Length(slices-&gt;top()-&gt;intValue(CSSPrimitiveValue::CSS_NUMBER), Fixed);</span>
      if (slices-&gt;bottom()-&gt;isPercentage())
          box.bottom() = Length(slices-&gt;bottom()-&gt;doubleValue(), Percent);
      else
<span class="line-modified">!         box.bottom() = Length((int)slices-&gt;bottom()-&gt;floatValue(CSSPrimitiveValue::CSS_NUMBER), Fixed);</span>
      if (slices-&gt;left()-&gt;isPercentage())
          box.left() = Length(slices-&gt;left()-&gt;doubleValue(), Percent);
      else
<span class="line-modified">!         box.left() = Length(slices-&gt;left()-&gt;intValue(CSSPrimitiveValue::CSS_NUMBER), Fixed);</span>
      if (slices-&gt;right()-&gt;isPercentage())
          box.right() = Length(slices-&gt;right()-&gt;doubleValue(), Percent);
      else
<span class="line-modified">!         box.right() = Length(slices-&gt;right()-&gt;intValue(CSSPrimitiveValue::CSS_NUMBER), Fixed);</span>
      image.setImageSlices(box);
  
      // Set our fill mode.
      image.setFill(borderImageSlice.m_fill);
  }
<span class="line-new-header">--- 561,23 ---</span>
      LengthBox box;
      Quad* slices = borderImageSlice.slices();
      if (slices-&gt;top()-&gt;isPercentage())
          box.top() = Length(slices-&gt;top()-&gt;doubleValue(), Percent);
      else
<span class="line-modified">!         box.top() = Length(slices-&gt;top()-&gt;intValue(CSSUnitType::CSS_NUMBER), Fixed);</span>
      if (slices-&gt;bottom()-&gt;isPercentage())
          box.bottom() = Length(slices-&gt;bottom()-&gt;doubleValue(), Percent);
      else
<span class="line-modified">!         box.bottom() = Length((int)slices-&gt;bottom()-&gt;floatValue(CSSUnitType::CSS_NUMBER), Fixed);</span>
      if (slices-&gt;left()-&gt;isPercentage())
          box.left() = Length(slices-&gt;left()-&gt;doubleValue(), Percent);
      else
<span class="line-modified">!         box.left() = Length(slices-&gt;left()-&gt;intValue(CSSUnitType::CSS_NUMBER), Fixed);</span>
      if (slices-&gt;right()-&gt;isPercentage())
          box.right() = Length(slices-&gt;right()-&gt;doubleValue(), Percent);
      else
<span class="line-modified">!         box.right() = Length(slices-&gt;right()-&gt;intValue(CSSUnitType::CSS_NUMBER), Fixed);</span>
      image.setImageSlices(box);
  
      // Set our fill mode.
      image.setFill(borderImageSlice.m_fill);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 591,43 ***</span>
  {
      if (!is&lt;CSSPrimitiveValue&gt;(value))
          return LengthBox();
  
      // Get our zoom value.
<span class="line-modified">!     CSSToLengthConversionData conversionData = useSVGZoomRules() ? m_resolver-&gt;state().cssToLengthConversionData().copyWithAdjustedZoom(1.0f) : m_resolver-&gt;state().cssToLengthConversionData();</span>
  
      // Retrieve the primitive value.
      auto&amp; borderWidths = downcast&lt;CSSPrimitiveValue&gt;(value);
  
      // Set up a length box to represent our image slices.
      LengthBox box; // Defaults to &#39;auto&#39; so we don&#39;t have to handle that explicitly below.
      Quad* slices = borderWidths.quadValue();
      if (slices-&gt;top()-&gt;isNumber())
          box.top() = Length(slices-&gt;top()-&gt;intValue(), Relative);
      else if (slices-&gt;top()-&gt;isPercentage())
<span class="line-modified">!         box.top() = Length(slices-&gt;top()-&gt;doubleValue(CSSPrimitiveValue::CSS_PERCENTAGE), Percent);</span>
      else if (slices-&gt;top()-&gt;valueID() != CSSValueAuto)
          box.top() = slices-&gt;top()-&gt;computeLength&lt;Length&gt;(conversionData);
  
      if (slices-&gt;right()-&gt;isNumber())
          box.right() = Length(slices-&gt;right()-&gt;intValue(), Relative);
      else if (slices-&gt;right()-&gt;isPercentage())
<span class="line-modified">!         box.right() = Length(slices-&gt;right()-&gt;doubleValue(CSSPrimitiveValue::CSS_PERCENTAGE), Percent);</span>
      else if (slices-&gt;right()-&gt;valueID() != CSSValueAuto)
          box.right() = slices-&gt;right()-&gt;computeLength&lt;Length&gt;(conversionData);
  
      if (slices-&gt;bottom()-&gt;isNumber())
          box.bottom() = Length(slices-&gt;bottom()-&gt;intValue(), Relative);
      else if (slices-&gt;bottom()-&gt;isPercentage())
<span class="line-modified">!         box.bottom() = Length(slices-&gt;bottom()-&gt;doubleValue(CSSPrimitiveValue::CSS_PERCENTAGE), Percent);</span>
      else if (slices-&gt;bottom()-&gt;valueID() != CSSValueAuto)
          box.bottom() = slices-&gt;bottom()-&gt;computeLength&lt;Length&gt;(conversionData);
  
      if (slices-&gt;left()-&gt;isNumber())
          box.left() = Length(slices-&gt;left()-&gt;intValue(), Relative);
      else if (slices-&gt;left()-&gt;isPercentage())
<span class="line-modified">!         box.left() = Length(slices-&gt;left()-&gt;doubleValue(CSSPrimitiveValue::CSS_PERCENTAGE), Percent);</span>
      else if (slices-&gt;left()-&gt;valueID() != CSSValueAuto)
          box.left() = slices-&gt;left()-&gt;computeLength&lt;Length&gt;(conversionData);
  
      return box;
  }
<span class="line-new-header">--- 586,43 ---</span>
  {
      if (!is&lt;CSSPrimitiveValue&gt;(value))
          return LengthBox();
  
      // Get our zoom value.
<span class="line-modified">!     CSSToLengthConversionData conversionData = useSVGZoomRules() ? m_builderState.cssToLengthConversionData().copyWithAdjustedZoom(1.0f) : m_builderState.cssToLengthConversionData();</span>
  
      // Retrieve the primitive value.
      auto&amp; borderWidths = downcast&lt;CSSPrimitiveValue&gt;(value);
  
      // Set up a length box to represent our image slices.
      LengthBox box; // Defaults to &#39;auto&#39; so we don&#39;t have to handle that explicitly below.
      Quad* slices = borderWidths.quadValue();
      if (slices-&gt;top()-&gt;isNumber())
          box.top() = Length(slices-&gt;top()-&gt;intValue(), Relative);
      else if (slices-&gt;top()-&gt;isPercentage())
<span class="line-modified">!         box.top() = Length(slices-&gt;top()-&gt;doubleValue(CSSUnitType::CSS_PERCENTAGE), Percent);</span>
      else if (slices-&gt;top()-&gt;valueID() != CSSValueAuto)
          box.top() = slices-&gt;top()-&gt;computeLength&lt;Length&gt;(conversionData);
  
      if (slices-&gt;right()-&gt;isNumber())
          box.right() = Length(slices-&gt;right()-&gt;intValue(), Relative);
      else if (slices-&gt;right()-&gt;isPercentage())
<span class="line-modified">!         box.right() = Length(slices-&gt;right()-&gt;doubleValue(CSSUnitType::CSS_PERCENTAGE), Percent);</span>
      else if (slices-&gt;right()-&gt;valueID() != CSSValueAuto)
          box.right() = slices-&gt;right()-&gt;computeLength&lt;Length&gt;(conversionData);
  
      if (slices-&gt;bottom()-&gt;isNumber())
          box.bottom() = Length(slices-&gt;bottom()-&gt;intValue(), Relative);
      else if (slices-&gt;bottom()-&gt;isPercentage())
<span class="line-modified">!         box.bottom() = Length(slices-&gt;bottom()-&gt;doubleValue(CSSUnitType::CSS_PERCENTAGE), Percent);</span>
      else if (slices-&gt;bottom()-&gt;valueID() != CSSValueAuto)
          box.bottom() = slices-&gt;bottom()-&gt;computeLength&lt;Length&gt;(conversionData);
  
      if (slices-&gt;left()-&gt;isNumber())
          box.left() = Length(slices-&gt;left()-&gt;intValue(), Relative);
      else if (slices-&gt;left()-&gt;isPercentage())
<span class="line-modified">!         box.left() = Length(slices-&gt;left()-&gt;doubleValue(CSSUnitType::CSS_PERCENTAGE), Percent);</span>
      else if (slices-&gt;left()-&gt;valueID() != CSSValueAuto)
          box.left() = slices-&gt;left()-&gt;computeLength&lt;Length&gt;(conversionData);
  
      return box;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 643,40 ***</span>
          return;
  
      CSSValueID firstIdentifier = pair-&gt;first()-&gt;valueID();
      CSSValueID secondIdentifier = pair-&gt;second()-&gt;valueID();
  
<span class="line-modified">!     ENinePieceImageRule horizontalRule;</span>
      switch (firstIdentifier) {
      case CSSValueStretch:
<span class="line-modified">!         horizontalRule = StretchImageRule;</span>
          break;
      case CSSValueRound:
<span class="line-modified">!         horizontalRule = RoundImageRule;</span>
          break;
      case CSSValueSpace:
<span class="line-modified">!         horizontalRule = SpaceImageRule;</span>
          break;
      default: // CSSValueRepeat
<span class="line-modified">!         horizontalRule = RepeatImageRule;</span>
          break;
      }
      image.setHorizontalRule(horizontalRule);
  
<span class="line-modified">!     ENinePieceImageRule verticalRule;</span>
      switch (secondIdentifier) {
      case CSSValueStretch:
<span class="line-modified">!         verticalRule = StretchImageRule;</span>
          break;
      case CSSValueRound:
<span class="line-modified">!         verticalRule = RoundImageRule;</span>
          break;
      case CSSValueSpace:
<span class="line-modified">!         verticalRule = SpaceImageRule;</span>
          break;
      default: // CSSValueRepeat
<span class="line-modified">!         verticalRule = RepeatImageRule;</span>
          break;
      }
      image.setVerticalRule(verticalRule);
  }
  
<span class="line-new-header">--- 638,40 ---</span>
          return;
  
      CSSValueID firstIdentifier = pair-&gt;first()-&gt;valueID();
      CSSValueID secondIdentifier = pair-&gt;second()-&gt;valueID();
  
<span class="line-modified">!     NinePieceImageRule horizontalRule;</span>
      switch (firstIdentifier) {
      case CSSValueStretch:
<span class="line-modified">!         horizontalRule = NinePieceImageRule::Stretch;</span>
          break;
      case CSSValueRound:
<span class="line-modified">!         horizontalRule = NinePieceImageRule::Round;</span>
          break;
      case CSSValueSpace:
<span class="line-modified">!         horizontalRule = NinePieceImageRule::Space;</span>
          break;
      default: // CSSValueRepeat
<span class="line-modified">!         horizontalRule = NinePieceImageRule::Repeat;</span>
          break;
      }
      image.setHorizontalRule(horizontalRule);
  
<span class="line-modified">!     NinePieceImageRule verticalRule;</span>
      switch (secondIdentifier) {
      case CSSValueStretch:
<span class="line-modified">!         verticalRule = NinePieceImageRule::Stretch;</span>
          break;
      case CSSValueRound:
<span class="line-modified">!         verticalRule = NinePieceImageRule::Round;</span>
          break;
      case CSSValueSpace:
<span class="line-modified">!         verticalRule = NinePieceImageRule::Space;</span>
          break;
      default: // CSSValueRepeat
<span class="line-modified">!         verticalRule = NinePieceImageRule::Repeat;</span>
          break;
      }
      image.setVerticalRule(verticalRule);
  }
  
</pre>
<center><a href="CSSTimingFunctionValue.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSToStyleMap.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/FunctionRareData.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/FunctionRareData.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/FunctionRareData.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/FunctionRareData.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
+ * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -31,10 +31,11 @@
 #include "PackedCellPtr.h"
 #include "Watchpoint.h"
 
 namespace JSC {
 
+class ExecutableBase;
 class JSGlobalObject;
 class LLIntOffsetsExtractor;
 namespace DFG {
 class SpeculativeJIT;
 class JITCompiler;
@@ -46,30 +47,36 @@
     friend class DFG::JITCompiler;
     friend class VM;
 
 public:
     typedef JSCell Base;
-    static const unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;
+    static constexpr unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;
 
-    static FunctionRareData* create(VM&);
+    static FunctionRareData* create(VM&, ExecutableBase*);
+
+    static constexpr bool needsDestruction = true;
+
+    template<typename CellType, SubspaceAccess mode>
+    static IsoSubspace* subspaceFor(VM& vm)
+    {
+        return vm.functionRareDataSpace<mode>();
+    }
 
-    static const bool needsDestruction = true;
     static void destroy(JSCell*);
 
     static Structure* createStructure(VM&, JSGlobalObject*, JSValue prototype);
 
     static void visitChildren(JSCell*, SlotVisitor&);
 
     DECLARE_INFO;
 
     static inline ptrdiff_t offsetOfObjectAllocationProfile() { return OBJECT_OFFSETOF(FunctionRareData, m_objectAllocationProfile); }
-    static inline ptrdiff_t offsetOfObjectAllocationProfileWatchpoint() { return OBJECT_OFFSETOF(FunctionRareData, m_objectAllocationProfileWatchpoint); }
+    static inline ptrdiff_t offsetOfAllocationProfileWatchpointSet() { return OBJECT_OFFSETOF(FunctionRareData, m_allocationProfileWatchpointSet); }
     static inline ptrdiff_t offsetOfInternalFunctionAllocationProfile() { return OBJECT_OFFSETOF(FunctionRareData, m_internalFunctionAllocationProfile); }
     static inline ptrdiff_t offsetOfBoundFunctionStructure() { return OBJECT_OFFSETOF(FunctionRareData, m_boundFunctionStructure); }
+    static inline ptrdiff_t offsetOfExecutable() { return OBJECT_OFFSETOF(FunctionRareData, m_executable); }
     static inline ptrdiff_t offsetOfAllocationProfileClearingWatchpoint() { return OBJECT_OFFSETOF(FunctionRareData, m_allocationProfileClearingWatchpoint); }
-    static inline ptrdiff_t offsetOfHasReifiedLength() { return OBJECT_OFFSETOF(FunctionRareData, m_hasReifiedLength); }
-    static inline ptrdiff_t offsetOfHasReifiedName() { return OBJECT_OFFSETOF(FunctionRareData, m_hasReifiedName); }
 
     ObjectAllocationProfileWithPrototype* objectAllocationProfile()
     {
         return &m_objectAllocationProfile;
     }
@@ -77,43 +84,64 @@
     Structure* objectAllocationStructure() { return m_objectAllocationProfile.structure(); }
     JSObject* objectAllocationPrototype() { return m_objectAllocationProfile.prototype(); }
 
     InlineWatchpointSet& allocationProfileWatchpointSet()
     {
-        return m_objectAllocationProfileWatchpoint;
+        return m_allocationProfileWatchpointSet;
     }
 
     void clear(const char* reason);
 
     void initializeObjectAllocationProfile(VM&, JSGlobalObject*, JSObject* prototype, size_t inlineCapacity, JSFunction* constructor);
 
     bool isObjectAllocationProfileInitialized() { return !m_objectAllocationProfile.isNull(); }
 
     Structure* internalFunctionAllocationStructure() { return m_internalFunctionAllocationProfile.structure(); }
-    Structure* createInternalFunctionAllocationStructureFromBase(VM& vm, JSGlobalObject* globalObject, JSObject* prototype, Structure* baseStructure)
+    Structure* createInternalFunctionAllocationStructureFromBase(VM& vm, JSGlobalObject* baseGlobalObject, JSObject* prototype, Structure* baseStructure)
     {
-        return m_internalFunctionAllocationProfile.createAllocationStructureFromBase(vm, globalObject, this, prototype, baseStructure);
+        initializeAllocationProfileWatchpointSet();
+        return m_internalFunctionAllocationProfile.createAllocationStructureFromBase(vm, baseGlobalObject, this, prototype, baseStructure);
     }
-    void clearInternalFunctionAllocationProfile()
+    void clearInternalFunctionAllocationProfile(const char* reason)
     {
         m_internalFunctionAllocationProfile.clear();
+        m_allocationProfileWatchpointSet.fireAll(vm(), reason);
+    }
+
+    void initializeAllocationProfileWatchpointSet()
+    {
+        if (m_allocationProfileWatchpointSet.isStillValid())
+            m_allocationProfileWatchpointSet.startWatching();
     }
 
     Structure* getBoundFunctionStructure() { return m_boundFunctionStructure.get(); }
     void setBoundFunctionStructure(VM& vm, Structure* structure) { m_boundFunctionStructure.set(vm, this, structure); }
 
+    ExecutableBase* executable() const { return m_executable.get(); }
+
     bool hasReifiedLength() const { return m_hasReifiedLength; }
     void setHasReifiedLength() { m_hasReifiedLength = true; }
     bool hasReifiedName() const { return m_hasReifiedName; }
     void setHasReifiedName() { m_hasReifiedName = true; }
 
+    bool hasModifiedLength() const { return m_hasModifiedLength; }
+    void setHasModifiedLength()
+    {
+        m_hasModifiedLength = true;
+    }
+    bool hasModifiedName() const { return m_hasModifiedName; }
+    void setHasModifiedName()
+    {
+        m_hasModifiedName = true;
+    }
+
     bool hasAllocationProfileClearingWatchpoint() const { return !!m_allocationProfileClearingWatchpoint; }
     Watchpoint* createAllocationProfileClearingWatchpoint();
     class AllocationProfileClearingWatchpoint;
 
 protected:
-    FunctionRareData(VM&);
+    explicit FunctionRareData(VM&, ExecutableBase*);
     ~FunctionRareData();
 
 private:
     friend class LLIntOffsetsExtractor;
 
@@ -129,16 +157,19 @@
     //      the Array constructor will set the allocation profile of myConstructor to hold an Array structure
     //
     // We don't really care about 1) since this memory is rare and small in total. 2) is unfortunate but is
     // probably outweighed by the cost of 3).
     ObjectAllocationProfileWithPrototype m_objectAllocationProfile;
-    InlineWatchpointSet m_objectAllocationProfileWatchpoint;
+    InlineWatchpointSet m_allocationProfileWatchpointSet;
     InternalFunctionAllocationProfile m_internalFunctionAllocationProfile;
     WriteBarrier<Structure> m_boundFunctionStructure;
+    WriteBarrier<ExecutableBase> m_executable;
     std::unique_ptr<AllocationProfileClearingWatchpoint> m_allocationProfileClearingWatchpoint;
-    bool m_hasReifiedLength { false };
-    bool m_hasReifiedName { false };
+    bool m_hasReifiedLength : 1;
+    bool m_hasReifiedName : 1;
+    bool m_hasModifiedLength : 1;
+    bool m_hasModifiedName : 1;
 };
 
 class FunctionRareData::AllocationProfileClearingWatchpoint final : public Watchpoint {
 public:
     AllocationProfileClearingWatchpoint(FunctionRareData* rareData)

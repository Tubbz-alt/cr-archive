<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/Fits.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ExitKind.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FullBytecodeLiveness.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/Fits.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;GetPutInfo.h&quot;
 29 #include &quot;Interpreter.h&quot;
 30 #include &quot;Label.h&quot;
 31 #include &quot;OpcodeSize.h&quot;
 32 #include &quot;ProfileTypeBytecodeFlag.h&quot;
 33 #include &quot;PutByIdFlags.h&quot;
 34 #include &quot;ResultType.h&quot;
<span class="line-removed"> 35 #include &quot;SpecialPointer.h&quot;</span>
 36 #include &quot;SymbolTableOrScopeDepth.h&quot;
 37 #include &quot;VirtualRegister.h&quot;
 38 #include &lt;type_traits&gt;
 39 
 40 namespace JSC {
 41 
 42 enum FitsAssertion {
 43     Assert,
 44     NoAssert
 45 };
 46 
 47 // Fits template
 48 template&lt;typename, OpcodeSize, typename = std::true_type&gt;
 49 struct Fits;
 50 
 51 // Implicit conversion for types of the same size
 52 template&lt;typename T, OpcodeSize size&gt;
 53 struct Fits&lt;T, size, std::enable_if_t&lt;sizeof(T) == size, std::true_type&gt;&gt; {
 54     using TargetType = typename TypeBySize&lt;size&gt;::unsignedType;
 55 
</pre>
<hr />
<pre>
219     }
220 };
221 
222 template&lt;typename E, OpcodeSize size&gt;
223 struct Fits&lt;E, size, std::enable_if_t&lt;sizeof(E) != size &amp;&amp; std::is_enum&lt;E&gt;::value, std::true_type&gt;&gt; : public Fits&lt;std::underlying_type_t&lt;E&gt;, size&gt; {
224     using Base = Fits&lt;std::underlying_type_t&lt;E&gt;, size&gt;;
225 
226     static bool check(E e) { return Base::check(static_cast&lt;std::underlying_type_t&lt;E&gt;&gt;(e)); }
227 
228     static typename Base::TargetType convert(E e)
229     {
230         return Base::convert(static_cast&lt;std::underlying_type_t&lt;E&gt;&gt;(e));
231     }
232 
233     static E convert(typename Base::TargetType e)
234     {
235         return static_cast&lt;E&gt;(Base::convert(e));
236     }
237 };
238 












239 template&lt;OpcodeSize size&gt;
240 struct Fits&lt;OperandTypes, size, std::enable_if_t&lt;sizeof(OperandTypes) != size, std::true_type&gt;&gt; {
241     static_assert(sizeof(OperandTypes) == sizeof(uint16_t));
242     using TargetType = typename TypeBySize&lt;size&gt;::unsignedType;
243 
244     // a pair of (ResultType::Type, ResultType::Type) - try to fit each type into 4 bits
245     // additionally, encode unknown types as 0 rather than the | of all types
246     static constexpr unsigned typeWidth = 4;
247     static constexpr unsigned maxType = (1 &lt;&lt; typeWidth) - 1;
248 
249     static bool check(OperandTypes types)
250     {
251         if (size == OpcodeSize::Narrow) {
252             auto first = types.first().bits();
253             auto second = types.second().bits();
254             if (first == ResultType::unknownType().bits())
255                 first = 0;
256             if (second == ResultType::unknownType().bits())
257                 second = 0;
258             return first &lt;= maxType &amp;&amp; second &lt;= maxType;
</pre>
<hr />
<pre>
273             return (first &lt;&lt; typeWidth) | second;
274         }
275         return static_cast&lt;TargetType&gt;(types.bits());
276     }
277 
278     static OperandTypes convert(TargetType types)
279     {
280         if (size == OpcodeSize::Narrow) {
281             auto first = types &gt;&gt; typeWidth;
282             auto second = types &amp; maxType;
283             if (!first)
284                 first = ResultType::unknownType().bits();
285             if (!second)
286                 second = ResultType::unknownType().bits();
287             return OperandTypes(ResultType(first), ResultType(second));
288         }
289         return OperandTypes::fromBits(static_cast&lt;uint16_t&gt;(types));
290     }
291 };
292 
<span class="line-modified">293 template&lt;OpcodeSize size&gt;</span>
<span class="line-modified">294 struct Fits&lt;BoundLabel, size&gt; : public Fits&lt;int, size&gt; {</span>
295     // This is a bit hacky: we need to delay computing jump targets, since we
296     // might have to emit `nop`s to align the instructions stream. Additionally,
297     // we have to compute the target before we start writing to the instruction
298     // stream, since the offset is computed from the start of the bytecode. We
299     // achieve this by computing the target when we `check` and saving it, then
300     // later we use the saved target when we call convert.
301 
302     using Base = Fits&lt;int, size&gt;;
<span class="line-modified">303     static bool check(BoundLabel&amp; label)</span>
304     {
305         return Base::check(label.saveTarget());
306     }
307 
<span class="line-modified">308     static typename Base::TargetType convert(BoundLabel&amp; label)</span>
309     {
310         return Base::convert(label.commitTarget());
311     }
312 
<span class="line-modified">313     static BoundLabel convert(typename Base::TargetType target)</span>
314     {
<span class="line-modified">315         return BoundLabel(Base::convert(target));</span>
316     }
317 };
318 
319 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;GetPutInfo.h&quot;
 29 #include &quot;Interpreter.h&quot;
 30 #include &quot;Label.h&quot;
 31 #include &quot;OpcodeSize.h&quot;
 32 #include &quot;ProfileTypeBytecodeFlag.h&quot;
 33 #include &quot;PutByIdFlags.h&quot;
 34 #include &quot;ResultType.h&quot;

 35 #include &quot;SymbolTableOrScopeDepth.h&quot;
 36 #include &quot;VirtualRegister.h&quot;
 37 #include &lt;type_traits&gt;
 38 
 39 namespace JSC {
 40 
 41 enum FitsAssertion {
 42     Assert,
 43     NoAssert
 44 };
 45 
 46 // Fits template
 47 template&lt;typename, OpcodeSize, typename = std::true_type&gt;
 48 struct Fits;
 49 
 50 // Implicit conversion for types of the same size
 51 template&lt;typename T, OpcodeSize size&gt;
 52 struct Fits&lt;T, size, std::enable_if_t&lt;sizeof(T) == size, std::true_type&gt;&gt; {
 53     using TargetType = typename TypeBySize&lt;size&gt;::unsignedType;
 54 
</pre>
<hr />
<pre>
218     }
219 };
220 
221 template&lt;typename E, OpcodeSize size&gt;
222 struct Fits&lt;E, size, std::enable_if_t&lt;sizeof(E) != size &amp;&amp; std::is_enum&lt;E&gt;::value, std::true_type&gt;&gt; : public Fits&lt;std::underlying_type_t&lt;E&gt;, size&gt; {
223     using Base = Fits&lt;std::underlying_type_t&lt;E&gt;, size&gt;;
224 
225     static bool check(E e) { return Base::check(static_cast&lt;std::underlying_type_t&lt;E&gt;&gt;(e)); }
226 
227     static typename Base::TargetType convert(E e)
228     {
229         return Base::convert(static_cast&lt;std::underlying_type_t&lt;E&gt;&gt;(e));
230     }
231 
232     static E convert(typename Base::TargetType e)
233     {
234         return static_cast&lt;E&gt;(Base::convert(e));
235     }
236 };
237 
<span class="line-added">238 template&lt;OpcodeSize size&gt;</span>
<span class="line-added">239 struct Fits&lt;ResultType, size, std::enable_if_t&lt;sizeof(ResultType) != size, std::true_type&gt;&gt; : public Fits&lt;uint8_t, size&gt; {</span>
<span class="line-added">240     static_assert(sizeof(ResultType) == sizeof(uint8_t));</span>
<span class="line-added">241     using Base = Fits&lt;uint8_t, size&gt;;</span>
<span class="line-added">242 </span>
<span class="line-added">243     static bool check(ResultType type) { return Base::check(type.bits()); }</span>
<span class="line-added">244 </span>
<span class="line-added">245     static typename Base::TargetType convert(ResultType type) { return Base::convert(type.bits()); }</span>
<span class="line-added">246 </span>
<span class="line-added">247     static ResultType convert(typename Base::TargetType type) { return ResultType(Base::convert(type)); }</span>
<span class="line-added">248 };</span>
<span class="line-added">249 </span>
250 template&lt;OpcodeSize size&gt;
251 struct Fits&lt;OperandTypes, size, std::enable_if_t&lt;sizeof(OperandTypes) != size, std::true_type&gt;&gt; {
252     static_assert(sizeof(OperandTypes) == sizeof(uint16_t));
253     using TargetType = typename TypeBySize&lt;size&gt;::unsignedType;
254 
255     // a pair of (ResultType::Type, ResultType::Type) - try to fit each type into 4 bits
256     // additionally, encode unknown types as 0 rather than the | of all types
257     static constexpr unsigned typeWidth = 4;
258     static constexpr unsigned maxType = (1 &lt;&lt; typeWidth) - 1;
259 
260     static bool check(OperandTypes types)
261     {
262         if (size == OpcodeSize::Narrow) {
263             auto first = types.first().bits();
264             auto second = types.second().bits();
265             if (first == ResultType::unknownType().bits())
266                 first = 0;
267             if (second == ResultType::unknownType().bits())
268                 second = 0;
269             return first &lt;= maxType &amp;&amp; second &lt;= maxType;
</pre>
<hr />
<pre>
284             return (first &lt;&lt; typeWidth) | second;
285         }
286         return static_cast&lt;TargetType&gt;(types.bits());
287     }
288 
289     static OperandTypes convert(TargetType types)
290     {
291         if (size == OpcodeSize::Narrow) {
292             auto first = types &gt;&gt; typeWidth;
293             auto second = types &amp; maxType;
294             if (!first)
295                 first = ResultType::unknownType().bits();
296             if (!second)
297                 second = ResultType::unknownType().bits();
298             return OperandTypes(ResultType(first), ResultType(second));
299         }
300         return OperandTypes::fromBits(static_cast&lt;uint16_t&gt;(types));
301     }
302 };
303 
<span class="line-modified">304 template&lt;OpcodeSize size, typename GeneratorTraits&gt;</span>
<span class="line-modified">305 struct Fits&lt;GenericBoundLabel&lt;GeneratorTraits&gt;, size&gt; : public Fits&lt;int, size&gt; {</span>
306     // This is a bit hacky: we need to delay computing jump targets, since we
307     // might have to emit `nop`s to align the instructions stream. Additionally,
308     // we have to compute the target before we start writing to the instruction
309     // stream, since the offset is computed from the start of the bytecode. We
310     // achieve this by computing the target when we `check` and saving it, then
311     // later we use the saved target when we call convert.
312 
313     using Base = Fits&lt;int, size&gt;;
<span class="line-modified">314     static bool check(GenericBoundLabel&lt;GeneratorTraits&gt;&amp; label)</span>
315     {
316         return Base::check(label.saveTarget());
317     }
318 
<span class="line-modified">319     static typename Base::TargetType convert(GenericBoundLabel&lt;GeneratorTraits&gt;&amp; label)</span>
320     {
321         return Base::convert(label.commitTarget());
322     }
323 
<span class="line-modified">324     static GenericBoundLabel&lt;GeneratorTraits&gt; convert(typename Base::TargetType target)</span>
325     {
<span class="line-modified">326         return GenericBoundLabel&lt;GeneratorTraits&gt;(Base::convert(target));</span>
327     }
328 };
329 
330 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="ExitKind.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FullBytecodeLiveness.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/MediaList.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * (C) 1999-2003 Lars Knoll (knoll@kde.org)
  3  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;MediaList.h&quot;
 23 
 24 #include &quot;CSSImportRule.h&quot;
 25 #include &quot;CSSStyleSheet.h&quot;
 26 #include &quot;DOMWindow.h&quot;
 27 #include &quot;Document.h&quot;
 28 #include &quot;MediaFeatureNames.h&quot;
 29 #include &quot;MediaQuery.h&quot;
 30 #include &quot;MediaQueryParser.h&quot;
 31 #include &lt;wtf/NeverDestroyed.h&gt;
 32 #include &lt;wtf/text/StringBuilder.h&gt;
 33 #include &lt;wtf/text/TextStream.h&gt;
 34 
 35 namespace WebCore {
 36 
 37 /* MediaList is used to store 3 types of media related entities which mean the same:
 38  * Media Queries, Media Types and Media Descriptors.
 39  * Currently MediaList always tries to parse media queries and if parsing fails,
 40  * tries to fallback to Media Descriptors if m_fallbackToDescriptor flag is set.
 41  * Slight problem with syntax error handling:
 42  * CSS 2.1 Spec (http://www.w3.org/TR/CSS21/media.html)
 43  * specifies that failing media type parsing is a syntax error
 44  * CSS 3 Media Queries Spec (http://www.w3.org/TR/css3-mediaqueries/)
 45  * specifies that failing media query is a syntax error
 46  * HTML 4.01 spec (http://www.w3.org/TR/REC-html40/present/styles.html#adef-media)
 47  * specifies that Media Descriptors should be parsed with forward-compatible syntax
 48  * DOM Level 2 Style Sheet spec (http://www.w3.org/TR/DOM-Level-2-Style/)
 49  * talks about MediaList.mediaText and refers
 50  *   -  to Media Descriptors of HTML 4.0 in context of StyleSheet
 51  *   -  to Media Types of CSS 2.0 in context of CSSMediaRule and CSSImportRule
 52  *
 53  * These facts create situation where same (illegal) media specification may result in
 54  * different parses depending on whether it is media attr of style element or part of
 55  * css @media rule.
 56  * &lt;style media=&quot;screen and resolution &gt; 40dpi&quot;&gt; ..&lt;/style&gt; will be enabled on screen devices where as
 57  * @media screen and resolution &gt; 40dpi {..} will not.
 58  * This gets more counter-intuitive in JavaScript:
 59  * document.styleSheets[0].media.mediaText = &quot;screen and resolution &gt; 40dpi&quot; will be ok and
 60  * enabled, while
 61  * document.styleSheets[0].cssRules[0].media.mediaText = &quot;screen and resolution &gt; 40dpi&quot; will
 62  * throw SyntaxError exception.
 63  */
 64 
 65 Ref&lt;MediaQuerySet&gt; MediaQuerySet::create(const String&amp; mediaString, MediaQueryParserContext context)
 66 {
 67     if (mediaString.isEmpty())
 68         return MediaQuerySet::create();
 69 
 70     return MediaQueryParser::parseMediaQuerySet(mediaString, context).releaseNonNull();
 71 }
 72 
 73 MediaQuerySet::MediaQuerySet() = default;
 74 
 75 MediaQuerySet::MediaQuerySet(const MediaQuerySet&amp; o)
 76     : RefCounted()
 77     , m_queries(o.m_queries)
 78 {
 79 }
 80 
 81 MediaQuerySet::~MediaQuerySet() = default;
 82 
 83 bool MediaQuerySet::set(const String&amp; mediaString)
 84 {
 85     auto result = create(mediaString);
 86     m_queries.swap(result-&gt;m_queries);
 87     return true;
 88 }
 89 
 90 bool MediaQuerySet::add(const String&amp; queryString)
 91 {
 92     // To &quot;parse a media query&quot; for a given string means to follow &quot;the parse
 93     // a media query list&quot; steps and return &quot;null&quot; if more than one media query
 94     // is returned, or else the returned media query.
 95     auto result = create(queryString);
 96 
 97     // Only continue if exactly one media query is found, as described above.
 98     if (result-&gt;m_queries.size() != 1)
 99         return false;
100 
101     // If comparing with any of the media queries in the collection of media
102     // queries returns true terminate these steps.
103     for (size_t i = 0; i &lt; m_queries.size(); ++i) {
104         if (m_queries[i] == result-&gt;m_queries[0])
105             return false;
106     }
107 
108     m_queries.append(result-&gt;m_queries[0]);
109     return true;
110 }
111 
112 bool MediaQuerySet::remove(const String&amp; queryStringToRemove)
113 {
114     // To &quot;parse a media query&quot; for a given string means to follow &quot;the parse
115     // a media query list&quot; steps and return &quot;null&quot; if more than one media query
116     // is returned, or else the returned media query.
117     auto result = create(queryStringToRemove);
118 
119     // Only continue if exactly one media query is found, as described above.
120     if (result-&gt;m_queries.size() != 1)
121         return true;
122 
123     // Remove any media query from the collection of media queries for which
124     // comparing with the media query returns true.
125     bool found = false;
126 
127     // Using signed int here, since for the first value, --i will result in -1.
128     for (int i = 0; i &lt; (int)m_queries.size(); ++i) {
129         if (m_queries[i] == result-&gt;m_queries[0]) {
130             m_queries.remove(i);
131             --i;
132             found = true;
133         }
134     }
135 
136     return found;
137 }
138 
139 void MediaQuerySet::addMediaQuery(MediaQuery&amp;&amp; mediaQuery)
140 {
141     m_queries.append(WTFMove(mediaQuery));
142 }
143 
144 String MediaQuerySet::mediaText() const
145 {
146     StringBuilder text;
147     bool needComma = false;
148     for (auto&amp; query : m_queries) {
149         if (needComma)
150             text.appendLiteral(&quot;, &quot;);
151         text.append(query.cssText());
152         needComma = true;
153     }
154     return text.toString();
155 }
156 
157 void MediaQuerySet::shrinkToFit()
158 {
159     m_queries.shrinkToFit();
160     for (auto&amp; query : m_queries)
161         query.shrinkToFit();
162 }
163 
164 MediaList::MediaList(MediaQuerySet* mediaQueries, CSSStyleSheet* parentSheet)
165     : m_mediaQueries(mediaQueries)
166     , m_parentStyleSheet(parentSheet)
167 {
168 }
169 
170 MediaList::MediaList(MediaQuerySet* mediaQueries, CSSRule* parentRule)
171     : m_mediaQueries(mediaQueries)
172     , m_parentRule(parentRule)
173 {
174 }
175 
176 MediaList::~MediaList() = default;
177 
178 ExceptionOr&lt;void&gt; MediaList::setMediaText(const String&amp; value)
179 {
180     CSSStyleSheet::RuleMutationScope mutationScope(m_parentRule);
181     m_mediaQueries-&gt;set(value);
182     if (m_parentStyleSheet)
183         m_parentStyleSheet-&gt;didMutate();
184     return { };
185 }
186 
187 String MediaList::item(unsigned index) const
188 {
189     auto&amp; queries = m_mediaQueries-&gt;queryVector();
190     if (index &lt; queries.size())
191         return queries[index].cssText();
192     return String();
193 }
194 
195 ExceptionOr&lt;void&gt; MediaList::deleteMedium(const String&amp; medium)
196 {
197     CSSStyleSheet::RuleMutationScope mutationScope(m_parentRule);
198 
199     bool success = m_mediaQueries-&gt;remove(medium);
200     if (!success)
201         return Exception { NotFoundError };
202     if (m_parentStyleSheet)
203         m_parentStyleSheet-&gt;didMutate();
204     return { };
205 }
206 
207 void MediaList::appendMedium(const String&amp; medium)
208 {
209     CSSStyleSheet::RuleMutationScope mutationScope(m_parentRule);
210 
211     if (!m_mediaQueries-&gt;add(medium))
212         return;
213     if (m_parentStyleSheet)
214         m_parentStyleSheet-&gt;didMutate();
215 }
216 
217 void MediaList::reattach(MediaQuerySet* mediaQueries)
218 {
219     ASSERT(mediaQueries);
220     m_mediaQueries = mediaQueries;
221 }
222 
223 #if ENABLE(RESOLUTION_MEDIA_QUERY)
224 
225 static void addResolutionWarningMessageToConsole(Document&amp; document, const String&amp; serializedExpression, const CSSPrimitiveValue&amp; value)
226 {
227     static NeverDestroyed&lt;String&gt; mediaQueryMessage(MAKE_STATIC_STRING_IMPL(&quot;Consider using &#39;dppx&#39; units instead of &#39;%replacementUnits%&#39;, as in CSS &#39;%replacementUnits%&#39; means dots-per-CSS-%lengthUnit%, not dots-per-physical-%lengthUnit%, so does not correspond to the actual &#39;%replacementUnits%&#39; of a screen. In media query expression: &quot;));
228     static NeverDestroyed&lt;String&gt; mediaValueDPI(MAKE_STATIC_STRING_IMPL(&quot;dpi&quot;));
229     static NeverDestroyed&lt;String&gt; mediaValueDPCM(MAKE_STATIC_STRING_IMPL(&quot;dpcm&quot;));
230     static NeverDestroyed&lt;String&gt; lengthUnitInch(MAKE_STATIC_STRING_IMPL(&quot;inch&quot;));
231     static NeverDestroyed&lt;String&gt; lengthUnitCentimeter(MAKE_STATIC_STRING_IMPL(&quot;centimeter&quot;));
232 
233     String message;
234     if (value.isDotsPerInch())
235         message = mediaQueryMessage.get().replace(&quot;%replacementUnits%&quot;, mediaValueDPI).replace(&quot;%lengthUnit%&quot;, lengthUnitInch);
236     else if (value.isDotsPerCentimeter())
237         message = mediaQueryMessage.get().replace(&quot;%replacementUnits%&quot;, mediaValueDPCM).replace(&quot;%lengthUnit%&quot;, lengthUnitCentimeter);
238     else
239         ASSERT_NOT_REACHED();
240 
241     message.append(serializedExpression);
242 
243     document.addConsoleMessage(MessageSource::CSS, MessageLevel::Debug, message);
244 }
245 
246 void reportMediaQueryWarningIfNeeded(Document* document, const MediaQuerySet* mediaQuerySet)
247 {
248     if (!mediaQuerySet || !document)
249         return;
250 
251     for (auto&amp; query : mediaQuerySet-&gt;queryVector()) {
252         if (!query.ignored() &amp;&amp; !equalLettersIgnoringASCIICase(query.mediaType(), &quot;print&quot;)) {
253             auto&amp; expressions = query.expressions();
254             for (auto&amp; expression : expressions) {
255                 if (expression.mediaFeature() == MediaFeatureNames::resolution || expression.mediaFeature() == MediaFeatureNames::maxResolution || expression.mediaFeature() == MediaFeatureNames::minResolution) {
256                     auto* value = expression.value();
257                     if (is&lt;CSSPrimitiveValue&gt;(value)) {
258                         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
259                         if (primitiveValue.isDotsPerInch() || primitiveValue.isDotsPerCentimeter())
260                             addResolutionWarningMessageToConsole(*document, mediaQuerySet-&gt;mediaText(), primitiveValue);
261                     }
262                 }
263             }
264         }
265     }
266 }
267 
268 #endif
269 
270 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const MediaQuerySet&amp; querySet)
271 {
272     ts &lt;&lt; querySet.mediaText();
273     return ts;
274 }
275 
276 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const MediaList&amp; mediaList)
277 {
278     ts &lt;&lt; mediaList.mediaText();
279     return ts;
280 }
281 
282 } // namespace WebCore
283 
    </pre>
  </body>
</html>
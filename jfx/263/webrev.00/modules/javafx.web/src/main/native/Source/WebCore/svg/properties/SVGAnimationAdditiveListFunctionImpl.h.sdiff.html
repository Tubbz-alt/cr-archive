<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/svg/properties/SVGAnimationAdditiveListFunctionImpl.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGAnimatedPropertyPairAccessorImpl.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGAnimationAdditiveValueFunctionImpl.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/properties/SVGAnimationAdditiveListFunctionImpl.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 52     }
 53 
 54     void setToAtEndOfDurationValue(const String&amp; toAtEndOfDuration) override
 55     {
 56         m_toAtEndOfDuration-&gt;parse(toAtEndOfDuration);
 57     }
 58 
 59     void animate(SVGElement* targetElement, float progress, unsigned repeatCount, RefPtr&lt;SVGLengthList&gt;&amp; animated)
 60     {
 61         if (!adjustAnimatedList(m_animationMode, progress, animated))
 62             return;
 63 
 64         const Vector&lt;Ref&lt;SVGLength&gt;&gt;&amp; fromItems = m_animationMode == AnimationMode::To ? animated-&gt;items() : m_from-&gt;items();
 65         const Vector&lt;Ref&lt;SVGLength&gt;&gt;&amp; toItems = m_to-&gt;items();
 66         const Vector&lt;Ref&lt;SVGLength&gt;&gt;&amp; toAtEndOfDurationItems = toAtEndOfDuration()-&gt;items();
 67         Vector&lt;Ref&lt;SVGLength&gt;&gt;&amp; animatedItems = animated-&gt;items();
 68         SVGLengthMode lengthMode = animated-&gt;lengthMode();
 69 
 70         SVGLengthContext lengthContext(targetElement);
 71         for (unsigned i = 0; i &lt; toItems.size(); ++i) {
<span class="line-modified"> 72             SVGLengthType unitType = (i &lt; fromItems.size() &amp;&amp; progress &lt; 0.5 ? fromItems : toItems)[i]-&gt;value().unitType();</span>
 73 
 74             float from = i &lt; fromItems.size() ? fromItems[i]-&gt;value().value(lengthContext) : 0;
 75             float to = toItems[i]-&gt;value().value(lengthContext);
 76             float toAtEndOfDuration = i &lt; toAtEndOfDurationItems.size() ? toAtEndOfDurationItems[i]-&gt;value().value(lengthContext) : 0;
 77             float value = animatedItems[i]-&gt;value().value(lengthContext);
 78 
 79             value = Base::animate(progress, repeatCount, from, to, toAtEndOfDuration, value);
<span class="line-modified"> 80             animatedItems[i]-&gt;value().setValue(lengthContext, value, lengthMode, unitType);</span>
 81         }
 82     }
 83 
 84 private:
 85     void addFromAndToValues(SVGElement* targetElement) override
 86     {
 87         const Vector&lt;Ref&lt;SVGLength&gt;&gt;&amp; fromItems = m_from-&gt;items();
 88         const Vector&lt;Ref&lt;SVGLength&gt;&gt;&amp; toItems = m_to-&gt;items();
 89 
 90         if (!fromItems.size() || fromItems.size() != toItems.size())
 91             return;
 92 
 93         SVGLengthContext lengthContext(targetElement);
 94         for (unsigned i = 0; i &lt; fromItems.size(); ++i) {
 95             const SVGLengthValue&amp; fromValue = fromItems[i]-&gt;value();
 96             SVGLengthValue&amp; toValue = toItems[i]-&gt;value();
<span class="line-modified"> 97             toValue.setValue(toValue.value(lengthContext) + fromValue.value(lengthContext), lengthContext);</span>
 98         }
 99     }
100 };
101 
102 class SVGAnimationNumberListFunction : public SVGAnimationAdditiveListFunction&lt;SVGNumberList&gt; {
103 public:
104     using Base = SVGAnimationAdditiveListFunction&lt;SVGNumberList&gt;;
105     using Base::Base;
106 
107     void setFromAndToValues(SVGElement*, const String&amp; from, const String&amp; to) override
108     {
109         m_from-&gt;parse(from);
110         m_to-&gt;parse(to);
111     }
112 
113     void setToAtEndOfDurationValue(const String&amp; toAtEndOfDuration) override
114     {
115         m_toAtEndOfDuration-&gt;parse(toAtEndOfDuration);
116     }
117 
</pre>
</td>
<td>
<hr />
<pre>
 52     }
 53 
 54     void setToAtEndOfDurationValue(const String&amp; toAtEndOfDuration) override
 55     {
 56         m_toAtEndOfDuration-&gt;parse(toAtEndOfDuration);
 57     }
 58 
 59     void animate(SVGElement* targetElement, float progress, unsigned repeatCount, RefPtr&lt;SVGLengthList&gt;&amp; animated)
 60     {
 61         if (!adjustAnimatedList(m_animationMode, progress, animated))
 62             return;
 63 
 64         const Vector&lt;Ref&lt;SVGLength&gt;&gt;&amp; fromItems = m_animationMode == AnimationMode::To ? animated-&gt;items() : m_from-&gt;items();
 65         const Vector&lt;Ref&lt;SVGLength&gt;&gt;&amp; toItems = m_to-&gt;items();
 66         const Vector&lt;Ref&lt;SVGLength&gt;&gt;&amp; toAtEndOfDurationItems = toAtEndOfDuration()-&gt;items();
 67         Vector&lt;Ref&lt;SVGLength&gt;&gt;&amp; animatedItems = animated-&gt;items();
 68         SVGLengthMode lengthMode = animated-&gt;lengthMode();
 69 
 70         SVGLengthContext lengthContext(targetElement);
 71         for (unsigned i = 0; i &lt; toItems.size(); ++i) {
<span class="line-modified"> 72             SVGLengthType lengthType = (i &lt; fromItems.size() &amp;&amp; progress &lt; 0.5 ? fromItems : toItems)[i]-&gt;value().lengthType();</span>
 73 
 74             float from = i &lt; fromItems.size() ? fromItems[i]-&gt;value().value(lengthContext) : 0;
 75             float to = toItems[i]-&gt;value().value(lengthContext);
 76             float toAtEndOfDuration = i &lt; toAtEndOfDurationItems.size() ? toAtEndOfDurationItems[i]-&gt;value().value(lengthContext) : 0;
 77             float value = animatedItems[i]-&gt;value().value(lengthContext);
 78 
 79             value = Base::animate(progress, repeatCount, from, to, toAtEndOfDuration, value);
<span class="line-modified"> 80             animatedItems[i]-&gt;value().setValue(lengthContext, value, lengthType, lengthMode);</span>
 81         }
 82     }
 83 
 84 private:
 85     void addFromAndToValues(SVGElement* targetElement) override
 86     {
 87         const Vector&lt;Ref&lt;SVGLength&gt;&gt;&amp; fromItems = m_from-&gt;items();
 88         const Vector&lt;Ref&lt;SVGLength&gt;&gt;&amp; toItems = m_to-&gt;items();
 89 
 90         if (!fromItems.size() || fromItems.size() != toItems.size())
 91             return;
 92 
 93         SVGLengthContext lengthContext(targetElement);
 94         for (unsigned i = 0; i &lt; fromItems.size(); ++i) {
 95             const SVGLengthValue&amp; fromValue = fromItems[i]-&gt;value();
 96             SVGLengthValue&amp; toValue = toItems[i]-&gt;value();
<span class="line-modified"> 97             toValue.setValue(lengthContext, toValue.value(lengthContext) + fromValue.value(lengthContext));</span>
 98         }
 99     }
100 };
101 
102 class SVGAnimationNumberListFunction : public SVGAnimationAdditiveListFunction&lt;SVGNumberList&gt; {
103 public:
104     using Base = SVGAnimationAdditiveListFunction&lt;SVGNumberList&gt;;
105     using Base::Base;
106 
107     void setFromAndToValues(SVGElement*, const String&amp; from, const String&amp; to) override
108     {
109         m_from-&gt;parse(from);
110         m_to-&gt;parse(to);
111     }
112 
113     void setToAtEndOfDurationValue(const String&amp; toAtEndOfDuration) override
114     {
115         m_toAtEndOfDuration-&gt;parse(toAtEndOfDuration);
116     }
117 
</pre>
</td>
</tr>
</table>
<center><a href="SVGAnimatedPropertyPairAccessorImpl.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGAnimationAdditiveValueFunctionImpl.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
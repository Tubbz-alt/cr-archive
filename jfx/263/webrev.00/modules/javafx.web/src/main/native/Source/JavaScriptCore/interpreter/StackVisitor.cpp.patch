diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/StackVisitor.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/StackVisitor.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/StackVisitor.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/StackVisitor.cpp
@@ -24,39 +24,38 @@
  */
 
 #include "config.h"
 #include "StackVisitor.h"
 
-#include "CallFrameInlines.h"
 #include "ClonedArguments.h"
 #include "DebuggerPrimitives.h"
 #include "InlineCallFrame.h"
 #include "Interpreter.h"
 #include "JSCInlines.h"
+#include "RegisterAtOffsetList.h"
 #include "WasmCallee.h"
 #include "WasmIndexOrName.h"
 #include "WebAssemblyFunction.h"
 #include <wtf/text/StringBuilder.h>
 
 namespace JSC {
 
-StackVisitor::StackVisitor(CallFrame* startFrame, VM* vm)
+StackVisitor::StackVisitor(CallFrame* startFrame, VM& vm)
 {
     m_frame.m_index = 0;
     m_frame.m_isWasmFrame = false;
     CallFrame* topFrame;
     if (startFrame) {
-        ASSERT(vm);
-        ASSERT(!vm->topCallFrame || reinterpret_cast<void*>(vm->topCallFrame) != vm->topEntryFrame);
+        ASSERT(!vm.topCallFrame || reinterpret_cast<void*>(vm.topCallFrame) != vm.topEntryFrame);
 
-        m_frame.m_entryFrame = vm->topEntryFrame;
-        topFrame = vm->topCallFrame;
+        m_frame.m_entryFrame = vm.topEntryFrame;
+        topFrame = vm.topCallFrame;
 
         if (topFrame && topFrame->isStackOverflowFrame()) {
             topFrame = topFrame->callerFrame(m_frame.m_entryFrame);
-            m_topEntryFrameIsEmpty = (m_frame.m_entryFrame != vm->topEntryFrame);
-            if (startFrame == vm->topCallFrame)
+            m_topEntryFrameIsEmpty = (m_frame.m_entryFrame != vm.topEntryFrame);
+            if (startFrame == vm.topCallFrame)
                 startFrame = topFrame;
         }
 
     } else {
         m_frame.m_entryFrame = 0;
@@ -168,21 +167,21 @@
     m_frame.m_callee = callee;
 
     if (callFrame->isAnyWasmCallee()) {
         m_frame.m_isWasmFrame = true;
         m_frame.m_codeBlock = nullptr;
-        m_frame.m_bytecodeOffset = 0;
+        m_frame.m_bytecodeIndex = BytecodeIndex();
 #if ENABLE(WEBASSEMBLY)
         CalleeBits bits = callFrame->callee();
         if (bits.isWasm())
             m_frame.m_wasmFunctionIndexOrName = bits.asWasmCallee()->indexOrName();
 #endif
     } else {
         m_frame.m_codeBlock = callFrame->codeBlock();
-        m_frame.m_bytecodeOffset = !m_frame.codeBlock() ? 0
+        m_frame.m_bytecodeIndex = !m_frame.codeBlock() ? BytecodeIndex(0)
             : codeOrigin ? codeOrigin->bytecodeIndex()
-            : callFrame->bytecodeOffset();
+            : callFrame->bytecodeIndex();
 
     }
 
 #if ENABLE(DFG_JIT)
     m_frame.m_inlineCallFrame = 0;
@@ -208,15 +207,15 @@
         InlineCallFrame* inlineCallFrame = codeOrigin->inlineCallFrame();
 
         m_frame.m_callFrame = callFrame;
         m_frame.m_inlineCallFrame = inlineCallFrame;
         if (inlineCallFrame->argumentCountRegister.isValid())
-            m_frame.m_argumentCountIncludingThis = callFrame->r(inlineCallFrame->argumentCountRegister.offset()).unboxedInt32();
+            m_frame.m_argumentCountIncludingThis = callFrame->r(inlineCallFrame->argumentCountRegister).unboxedInt32();
         else
             m_frame.m_argumentCountIncludingThis = inlineCallFrame->argumentCountIncludingThis;
         m_frame.m_codeBlock = inlineCallFrame->baselineCodeBlock.get();
-        m_frame.m_bytecodeOffset = codeOrigin->bytecodeIndex();
+        m_frame.m_bytecodeIndex = codeOrigin->bytecodeIndex();
 
         JSFunction* callee = inlineCallFrame->calleeForCallFrame(callFrame);
         m_frame.m_callee = callee;
         ASSERT(!!m_frame.callee().rawPtr());
 
@@ -264,11 +263,11 @@
         return WTF::nullopt;
 
 #if ENABLE(WEBASSEMBLY)
     if (isWasmFrame()) {
         if (callee().isCell()) {
-            RELEASE_ASSERT(isWebAssemblyToJSCallee(callee().asCell()));
+            RELEASE_ASSERT(isWebAssemblyModule(callee().asCell()));
             return WTF::nullopt;
         }
         Wasm::Callee* wasmCallee = callee().asWasmCallee();
         return *wasmCallee->calleeSaveRegisters();
     }
@@ -301,15 +300,15 @@
         traceLine = "module code"_s;
         break;
     case CodeType::Native: {
         JSCell* callee = this->callee().asCell();
         if (callee)
-            traceLine = getCalculatedDisplayName(callFrame()->vm(), jsCast<JSObject*>(callee)).impl();
+            traceLine = getCalculatedDisplayName(callFrame()->deprecatedVM(), jsCast<JSObject*>(callee)).impl();
         break;
     }
     case CodeType::Function:
-        traceLine = getCalculatedDisplayName(callFrame()->vm(), jsCast<JSObject*>(this->callee().asCell())).impl();
+        traceLine = getCalculatedDisplayName(callFrame()->deprecatedVM(), jsCast<JSObject*>(this->callee().asCell())).impl();
         break;
     case CodeType::Global:
         traceLine = "global code"_s;
         break;
     }
@@ -368,27 +367,30 @@
     if (CodeBlock* codeBlock = this->codeBlock())
         return codeBlock->ownerExecutable()->sourceID();
     return noSourceID;
 }
 
-ClonedArguments* StackVisitor::Frame::createArguments()
+ClonedArguments* StackVisitor::Frame::createArguments(VM& vm)
 {
     ASSERT(m_callFrame);
     CallFrame* physicalFrame = m_callFrame;
+    // FIXME: Revisit JSGlobalObject.
+    // https://bugs.webkit.org/show_bug.cgi?id=203204
+    JSGlobalObject* globalObject = physicalFrame->lexicalGlobalObject(vm);
     ClonedArguments* arguments;
     ArgumentsMode mode;
     if (Options::useFunctionDotArguments())
         mode = ArgumentsMode::Cloned;
     else
         mode = ArgumentsMode::FakeValues;
 #if ENABLE(DFG_JIT)
     if (isInlinedFrame()) {
         ASSERT(m_inlineCallFrame);
-        arguments = ClonedArguments::createWithInlineFrame(physicalFrame, physicalFrame, m_inlineCallFrame, mode);
+        arguments = ClonedArguments::createWithInlineFrame(globalObject, physicalFrame, m_inlineCallFrame, mode);
     } else
 #endif
-        arguments = ClonedArguments::createWithMachineFrame(physicalFrame, physicalFrame, mode);
+        arguments = ClonedArguments::createWithMachineFrame(globalObject, physicalFrame, mode);
     return arguments;
 }
 
 bool StackVisitor::Frame::hasLineAndColumnInfo() const
 {
@@ -419,11 +421,11 @@
 }
 
 void StackVisitor::Frame::retrieveExpressionInfo(int& divot, int& startOffset, int& endOffset, unsigned& line, unsigned& column) const
 {
     CodeBlock* codeBlock = this->codeBlock();
-    codeBlock->unlinkedCodeBlock()->expressionRangeForBytecodeOffset(bytecodeOffset(), divot, startOffset, endOffset, line, column);
+    codeBlock->unlinkedCodeBlock()->expressionRangeForBytecodeIndex(bytecodeIndex(), divot, startOffset, endOffset, line, column);
     divot += codeBlock->sourceOffset();
 }
 
 void StackVisitor::Frame::setToEnd()
 {
@@ -481,12 +483,12 @@
         out.print("\n");
         if (codeBlock && !isInlined) {
             indent++;
 
             if (callFrame->callSiteBitsAreBytecodeOffset()) {
-                unsigned bytecodeOffset = callFrame->bytecodeOffset();
-                out.print(indent, "bytecodeOffset: ", bytecodeOffset, " of ", codeBlock->instructions().size(), "\n");
+                BytecodeIndex bytecodeIndex = callFrame->bytecodeIndex();
+                out.print(indent, bytecodeIndex, " of ", codeBlock->instructions().size(), "\n");
 #if ENABLE(DFG_JIT)
             } else {
                 out.print(indent, "hasCodeOrigins: ", codeBlock->hasCodeOrigins(), "\n");
                 if (codeBlock->hasCodeOrigins()) {
                     CallSiteIndex callSiteIndex = callFrame->callSiteIndex();

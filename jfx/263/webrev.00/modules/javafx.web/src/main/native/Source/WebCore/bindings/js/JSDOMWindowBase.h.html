<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWindowBase.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (C) 2000 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2003-2017 Apple Inc. All rights reseved.
  4  *
  5  *  This library is free software; you can redistribute it and/or
  6  *  modify it under the terms of the GNU Lesser General Public
  7  *  License as published by the Free Software Foundation; either
  8  *  version 2 of the License, or (at your option) any later version.
  9  *
 10  *  This library is distributed in the hope that it will be useful,
 11  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  *  Lesser General Public License for more details.
 14  *
 15  *  You should have received a copy of the GNU Lesser General Public
 16  *  License along with this library; if not, write to the Free Software
 17  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 18  */
 19 
 20 #pragma once
 21 
 22 #include &quot;DOMWindow.h&quot;
 23 #include &quot;JSDOMGlobalObject.h&quot;
 24 #include &quot;JSDOMWrapperCache.h&quot;
 25 #include &lt;JavaScriptCore/AuxiliaryBarrierInlines.h&gt;
 26 #include &lt;JavaScriptCore/HeapInlines.h&gt;
 27 #include &lt;JavaScriptCore/JSArray.h&gt;
 28 #include &lt;JavaScriptCore/JSCJSValueInlines.h&gt;
 29 #include &lt;JavaScriptCore/JSCellInlines.h&gt;
 30 #include &lt;JavaScriptCore/JSObjectInlines.h&gt;
 31 #include &lt;JavaScriptCore/Lookup.h&gt;
 32 #include &lt;JavaScriptCore/ObjectConstructor.h&gt;
 33 #include &lt;JavaScriptCore/SlotVisitorInlines.h&gt;
 34 #include &lt;JavaScriptCore/StructureInlines.h&gt;
 35 #include &lt;JavaScriptCore/WriteBarrier.h&gt;
 36 #include &lt;cstddef&gt;
 37 #include &lt;wtf/Forward.h&gt;
 38 #include &lt;wtf/GetPtr.h&gt;
 39 #include &lt;wtf/Vector.h&gt;
 40 
 41 namespace WebCore {
 42 
 43 class DOMWrapperWorld;
 44 class Frame;
 45 class FetchResponse;
 46 class JSDOMWindow;
 47 class JSDOMWindowBasePrivate;
 48 class JSWindowProxy;
 49 
 50 class WEBCORE_EXPORT JSDOMWindowBase : public JSDOMGlobalObject {
 51 public:
 52     using Base = JSDOMGlobalObject;
 53 
 54     static void destroy(JSCell*);
 55 
 56     template&lt;typename, JSC::SubspaceAccess&gt;
 57     static void subspaceFor(JSC::VM&amp;) { RELEASE_ASSERT_NOT_REACHED(); }
 58 
 59     void updateDocument();
 60 
 61     DOMWindow&amp; wrapped() const { return *m_wrapped; }
 62     ScriptExecutionContext* scriptExecutionContext() const;
 63 
 64     // Called just before removing this window from the JSWindowProxy.
 65     void willRemoveFromWindowProxy();
 66 
 67     DECLARE_INFO;
 68 
 69     static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSValue prototype)
 70     {
 71         return JSC::Structure::create(vm, 0, prototype, JSC::TypeInfo(JSC::GlobalObjectType, StructureFlags), info());
 72     }
 73 
 74     static const JSC::GlobalObjectMethodTable s_globalObjectMethodTable;
 75 
 76     static bool supportsRichSourceInfo(const JSC::JSGlobalObject*);
 77     static bool shouldInterruptScript(const JSC::JSGlobalObject*);
 78     static bool shouldInterruptScriptBeforeTimeout(const JSC::JSGlobalObject*);
 79     static JSC::RuntimeFlags javaScriptRuntimeFlags(const JSC::JSGlobalObject*);
 80     static void queueMicrotaskToEventLoop(JSC::JSGlobalObject&amp;, Ref&lt;JSC::Microtask&gt;&amp;&amp;);
 81 
 82     void printErrorMessage(const String&amp;) const;
 83 
 84     JSWindowProxy* proxy() const;
 85 
 86     static void fireFrameClearedWatchpointsForWindow(DOMWindow*);
 87 
 88 protected:
 89     JSDOMWindowBase(JSC::VM&amp;, JSC::Structure*, RefPtr&lt;DOMWindow&gt;&amp;&amp;, JSWindowProxy*);
 90     void finishCreation(JSC::VM&amp;, JSWindowProxy*);
 91 
 92     JSC::WatchpointSet m_windowCloseWatchpoints;
 93 
 94 private:
 95     using ResponseCallback = WTF::Function&lt;void(const char*, size_t)&gt;;
 96 
 97     static JSC::Identifier moduleLoaderResolve(JSC::JSGlobalObject*, JSC::JSModuleLoader*, JSC::JSValue, JSC::JSValue, JSC::JSValue);
 98     static JSC::JSInternalPromise* moduleLoaderFetch(JSC::JSGlobalObject*, JSC::JSModuleLoader*, JSC::JSValue, JSC::JSValue, JSC::JSValue);
 99     static JSC::JSValue moduleLoaderEvaluate(JSC::JSGlobalObject*, JSC::JSModuleLoader*, JSC::JSValue, JSC::JSValue, JSC::JSValue);
100     static JSC::JSInternalPromise* moduleLoaderImportModule(JSC::JSGlobalObject*, JSC::JSModuleLoader*, JSC::JSString*, JSC::JSValue, const JSC::SourceOrigin&amp;);
101     static JSC::JSObject* moduleLoaderCreateImportMetaProperties(JSC::JSGlobalObject*, JSC::JSModuleLoader*, JSC::JSValue, JSC::JSModuleRecord*, JSC::JSValue);
102 
103 #if ENABLE(WEBASSEMBLY)
104     static void compileStreaming(JSC::JSGlobalObject*, JSC::JSPromise*, JSC::JSValue);
105     static void instantiateStreaming(JSC::JSGlobalObject*, JSC::JSPromise*, JSC::JSValue, JSC::JSObject*);
106 #endif
107 
108     RefPtr&lt;DOMWindow&gt; m_wrapped;
109     JSWindowProxy* m_proxy;
110 };
111 
112 WEBCORE_EXPORT JSC::JSValue toJS(JSC::JSGlobalObject*, DOMWindow&amp;);
113 // The following return a JSWindowProxy or jsNull()
114 // JSDOMGlobalObject* is ignored, accessing a window in any context will use that DOMWindow&#39;s prototype chain.
115 inline JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject*, DOMWindow&amp; window) { return toJS(lexicalGlobalObject, window); }
116 inline JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, DOMWindow* window) { return window ? toJS(lexicalGlobalObject, globalObject, *window) : JSC::jsNull(); }
117 inline JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, DOMWindow* window) { return window ? toJS(lexicalGlobalObject, *window) : JSC::jsNull(); }
118 
119 // The following return a JSDOMWindow or nullptr.
120 JSDOMWindow* toJSDOMWindow(Frame&amp;, DOMWrapperWorld&amp;);
121 inline JSDOMWindow* toJSDOMWindow(Frame* frame, DOMWrapperWorld&amp; world) { return frame ? toJSDOMWindow(*frame, world) : nullptr; }
122 WEBCORE_EXPORT JSDOMWindow* toJSDOMWindow(JSC::VM&amp;, JSC::JSValue);
123 
124 // DOMWindow associated with global object of the &quot;most-recently-entered author function or script
125 // on the stack, or the author function or script that originally scheduled the currently-running callback.&quot;
126 // (&lt;https://html.spec.whatwg.org/multipage/webappapis.html#concept-incumbent-everything&gt;, 27 April 2017)
127 // FIXME: Make this work for an &quot;author function or script that originally scheduled the currently-running callback.&quot;
128 // See &lt;https://bugs.webkit.org/show_bug.cgi?id=163412&gt;.
129 DOMWindow&amp; incumbentDOMWindow(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;);
130 
131 DOMWindow&amp; activeDOMWindow(JSC::JSGlobalObject&amp;);
132 DOMWindow&amp; firstDOMWindow(JSC::JSGlobalObject&amp;);
133 
134 // FIXME: This should probably be removed in favor of one of the other DOMWindow accessors. It is intended
135 //        to provide the document specfied as the &#39;responsible document&#39; in the algorithm for document.open()
136 //        (https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#document-open-steps steps 4
137 //        and 23 and https://html.spec.whatwg.org/multipage/webappapis.html#responsible-document). It is only
138 //        used by JSDocument.
139 Document* responsibleDocument(JSC::VM&amp;, JSC::CallFrame&amp;);
140 
141 } // namespace WebCore
    </pre>
  </body>
</html>
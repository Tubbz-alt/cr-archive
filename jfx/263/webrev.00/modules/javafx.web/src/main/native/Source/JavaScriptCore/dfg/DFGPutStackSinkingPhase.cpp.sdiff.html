<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPutStackSinkingPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGPureValue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGRegisterBank.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPutStackSinkingPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2014-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGPutStackSinkingPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;DFGBlockMapInlines.h&quot;
 32 #include &quot;DFGGraph.h&quot;
 33 #include &quot;DFGInsertionSet.h&quot;
 34 #include &quot;DFGPhase.h&quot;
 35 #include &quot;DFGPreciseLocalClobberize.h&quot;
 36 #include &quot;DFGSSACalculator.h&quot;
 37 #include &quot;DFGValidate.h&quot;
 38 #include &quot;JSCInlines.h&quot;
 39 #include &quot;OperandsInlines.h&quot;
 40 
 41 namespace JSC { namespace DFG {
 42 
 43 namespace {
 44 
<span class="line-removed"> 45 namespace DFGPutStackSinkingPhaseInternal {</span>
<span class="line-removed"> 46 static const bool verbose = false;</span>
<span class="line-removed"> 47 }</span>
<span class="line-removed"> 48 </span>
 49 class PutStackSinkingPhase : public Phase {

 50 public:
 51     PutStackSinkingPhase(Graph&amp; graph)
 52         : Phase(graph, &quot;PutStack sinking&quot;)
 53     {
 54     }
 55 
 56     bool run()
 57     {
 58         // FIXME: One of the problems of this approach is that it will create a duplicate Phi graph
 59         // for sunken PutStacks in the presence of interesting control flow merges, and where the
 60         // value being PutStack&#39;d is also otherwise live in the DFG code. We could work around this
 61         // by doing the sinking over CPS, or maybe just by doing really smart hoisting. It&#39;s also
 62         // possible that the duplicate Phi graph can be deduplicated by B3. It would be best if we
 63         // could observe that there is already a Phi graph in place that does what we want. In
 64         // principle if we have a request to place a Phi at a particular place, we could just check
 65         // if there is already a Phi that does what we want. Because PutStackSinkingPhase runs just
 66         // after SSA conversion, we have almost a guarantee that the Phi graph we produce here would
 67         // be trivially redundant to the one we already have.
 68 
 69         // FIXME: This phase doesn&#39;t adequately use KillStacks. KillStack can be viewed as a def.
 70         // This is mostly inconsequential; it would be a bug to have a local live at a KillStack.
 71         // More important is that KillStack should swallow any deferral. After a KillStack, the
 72         // local should behave like a TOP deferral because it would be invalid for anyone to trust
 73         // the stack. It&#39;s not clear to me if this is important or not.
 74         // https://bugs.webkit.org/show_bug.cgi?id=145296
 75 
<span class="line-modified"> 76         if (DFGPutStackSinkingPhaseInternal::verbose) {</span>
 77             dataLog(&quot;Graph before PutStack sinking:\n&quot;);
 78             m_graph.dump();
 79         }
 80 
 81         m_graph.ensureSSADominators();
 82 
 83         SSACalculator ssaCalculator(m_graph);
 84         InsertionSet insertionSet(m_graph);
 85 
 86         // First figure out where various locals are live.
 87         BlockMap&lt;Operands&lt;bool&gt;&gt; liveAtHead(m_graph);
 88         BlockMap&lt;Operands&lt;bool&gt;&gt; liveAtTail(m_graph);
 89 
 90         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
<span class="line-modified"> 91             liveAtHead[block] = Operands&lt;bool&gt;(OperandsLike, block-&gt;variablesAtHead);</span>
<span class="line-modified"> 92             liveAtTail[block] = Operands&lt;bool&gt;(OperandsLike, block-&gt;variablesAtHead);</span>
<span class="line-removed"> 93 </span>
<span class="line-removed"> 94             liveAtHead[block].fill(false);</span>
<span class="line-removed"> 95             liveAtTail[block].fill(false);</span>
 96         }
 97 
 98         bool changed;
 99         do {
100             changed = false;
101 
102             for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
103                 BasicBlock* block = m_graph.block(blockIndex);
104                 if (!block)
105                     continue;
106 
107                 Operands&lt;bool&gt; live = liveAtTail[block];
108                 for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
109                     Node* node = block-&gt;at(nodeIndex);
<span class="line-modified">110                     if (DFGPutStackSinkingPhaseInternal::verbose)</span>
111                         dataLog(&quot;Live at &quot;, node, &quot;: &quot;, live, &quot;\n&quot;);
112 
<span class="line-modified">113                     Vector&lt;VirtualRegister, 4&gt; reads;</span>
<span class="line-modified">114                     Vector&lt;VirtualRegister, 4&gt; writes;</span>
<span class="line-modified">115                     auto escapeHandler = [&amp;] (VirtualRegister operand) {</span>
116                         if (operand.isHeader())
117                             return;
<span class="line-modified">118                         if (DFGPutStackSinkingPhaseInternal::verbose)</span>
119                             dataLog(&quot;    &quot;, operand, &quot; is live at &quot;, node, &quot;\n&quot;);
120                         reads.append(operand);
121                     };
122 
<span class="line-modified">123                     auto writeHandler = [&amp;] (VirtualRegister operand) {</span>
124                         if (operand.isHeader())
125                             return;
<span class="line-modified">126                         RELEASE_ASSERT(node-&gt;op() == PutStack || node-&gt;op() == LoadVarargs || node-&gt;op() == ForwardVarargs || node-&gt;op() == KillStack);</span>

127                         writes.append(operand);
128                     };
129 
130                     preciseLocalClobberize(
131                         m_graph, node, escapeHandler, writeHandler,
<span class="line-modified">132                         [&amp;] (VirtualRegister, LazyNode) { });</span>
133 
<span class="line-modified">134                     for (VirtualRegister operand : writes)</span>
135                         live.operand(operand) = false;
<span class="line-modified">136                     for (VirtualRegister operand : reads)</span>
137                         live.operand(operand) = true;
138                 }
139 
140                 if (live == liveAtHead[block])
141                     continue;
142 
143                 liveAtHead[block] = live;
144                 changed = true;
145 
146                 for (BasicBlock* predecessor : block-&gt;predecessors) {
147                     for (size_t i = live.size(); i--;)
148                         liveAtTail[predecessor][i] |= live[i];
149                 }
150             }
151 
152         } while (changed);
153 
154         // All of the arguments should be live at head of root. Note that we may find that some
155         // locals are live at head of root. This seems wrong but isn&#39;t. This will happen for example
156         // if the function accesses closure variable #42 for some other function and we either don&#39;t
</pre>
<hr />
<pre>
217         BlockMap&lt;Operands&lt;FlushFormat&gt;&gt; deferredAtHead(m_graph);
218         BlockMap&lt;Operands&lt;FlushFormat&gt;&gt; deferredAtTail(m_graph);
219 
220         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
221             deferredAtHead[block] =
222                 Operands&lt;FlushFormat&gt;(OperandsLike, block-&gt;variablesAtHead);
223             deferredAtTail[block] =
224                 Operands&lt;FlushFormat&gt;(OperandsLike, block-&gt;variablesAtHead);
225         }
226 
227         for (unsigned local = deferredAtHead.atIndex(0).numberOfLocals(); local--;)
228             deferredAtHead.atIndex(0).local(local) = ConflictingFlush;
229 
230         do {
231             changed = false;
232 
233             for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
234                 Operands&lt;FlushFormat&gt; deferred = deferredAtHead[block];
235 
236                 for (Node* node : *block) {
<span class="line-modified">237                     if (DFGPutStackSinkingPhaseInternal::verbose)</span>
238                         dataLog(&quot;Deferred at &quot;, node, &quot;:&quot;, deferred, &quot;\n&quot;);
239 
240                     if (node-&gt;op() == GetStack) {
241                         // Handle the case that the input doesn&#39;t match our requirements. This is
242                         // really a bug, but it&#39;s a benign one if we simply don&#39;t run this phase.
243                         // It usually arises because of patterns like:
244                         //
245                         // if (thing)
246                         //     PutStack()
247                         // ...
248                         // if (thing)
249                         //     GetStack()
250                         //
251                         // Or:
252                         //
253                         // if (never happens)
254                         //     GetStack()
255                         //
256                         // Because this phase runs early in SSA, it should be sensible to enforce
257                         // that no such code pattern has arisen yet. So, when validation is
258                         // enabled, we assert that we aren&#39;t seeing this. But with validation
259                         // disabled we silently let this fly and we just abort this phase.
260                         // FIXME: Get rid of all remaining cases of conflicting GetStacks.
261                         // https://bugs.webkit.org/show_bug.cgi?id=150398
262 
263                         bool isConflicting =
<span class="line-modified">264                             deferred.operand(node-&gt;stackAccessData()-&gt;local) == ConflictingFlush;</span>
265 
266                         if (validationEnabled())
267                             DFG_ASSERT(m_graph, node, !isConflicting);
268 
269                         if (isConflicting) {
270                             // Oh noes! Abort!!
271                             return false;
272                         }
273 
274                         // A GetStack doesn&#39;t affect anything, since we know which local we are reading
275                         // from.
276                         continue;
277                     } else if (node-&gt;op() == PutStack) {
<span class="line-modified">278                         VirtualRegister operand = node-&gt;stackAccessData()-&gt;local;</span>

279                         deferred.operand(operand) = node-&gt;stackAccessData()-&gt;format;
280                         continue;
281                     } else if (node-&gt;op() == KillStack) {
282                         // We don&#39;t want to sink a PutStack past a KillStack.
<span class="line-modified">283                         deferred.operand(node-&gt;unlinkedLocal()) = ConflictingFlush;</span>


284                         continue;
285                     }
286 
<span class="line-modified">287                     auto escapeHandler = [&amp;] (VirtualRegister operand) {</span>
<span class="line-modified">288                         if (DFGPutStackSinkingPhaseInternal::verbose)</span>
289                             dataLog(&quot;For &quot;, node, &quot; escaping &quot;, operand, &quot;\n&quot;);
290                         if (operand.isHeader())
291                             return;
292                         // We will materialize just before any reads.
293                         deferred.operand(operand) = DeadFlush;
294                     };
295 
<span class="line-modified">296                     auto writeHandler = [&amp;] (VirtualRegister operand) {</span>

297                         if (operand.isHeader())
298                             return;
<span class="line-modified">299                         RELEASE_ASSERT(node-&gt;op() == LoadVarargs || node-&gt;op() == ForwardVarargs);</span>

300                         deferred.operand(operand) = DeadFlush;
301                     };
302 
303                     preciseLocalClobberize(
304                         m_graph, node, escapeHandler, writeHandler,
<span class="line-modified">305                         [&amp;] (VirtualRegister, LazyNode) { });</span>
306                 }
307 
308                 if (deferred == deferredAtTail[block])
309                     continue;
310 
311                 deferredAtTail[block] = deferred;
312                 changed = true;
313 
314                 for (BasicBlock* successor : block-&gt;successors()) {
315                     for (size_t i = deferred.size(); i--;) {
<span class="line-modified">316                         if (DFGPutStackSinkingPhaseInternal::verbose)</span>
<span class="line-modified">317                             dataLog(&quot;Considering &quot;, VirtualRegister(deferred.operandForIndex(i)), &quot; at &quot;, pointerDump(block), &quot;-&gt;&quot;, pointerDump(successor), &quot;: &quot;, deferred[i], &quot; and &quot;, deferredAtHead[successor][i], &quot; merges to &quot;);</span>
318 
319                         deferredAtHead[successor][i] =
320                             merge(deferredAtHead[successor][i], deferred[i]);
321 
<span class="line-modified">322                         if (DFGPutStackSinkingPhaseInternal::verbose)</span>
323                             dataLog(deferredAtHead[successor][i], &quot;\n&quot;);
324                     }
325                 }
326             }
327 
328         } while (changed);
329 
330         // We wish to insert PutStacks at all of the materialization points, which are defined
331         // implicitly as the places where we set deferred to Dead while it was previously not Dead.
332         // To do this, we may need to build some Phi functions to handle stuff like this:
333         //
334         // Before:
335         //
336         //     if (p)
337         //         PutStack(r42, @x)
338         //     else
339         //         PutStack(r42, @y)
340         //
341         // After:
342         //
343         //     if (p)
344         //         Upsilon(@x, ^z)
345         //     else
346         //         Upsilon(@y, ^z)
347         //     z: Phi()
348         //     PutStack(r42, @z)
349         //
350         // This means that we have an SSACalculator::Variable for each local, and a Def is any
351         // PutStack in the original program. The original PutStacks will simply vanish.
352 
353         Operands&lt;SSACalculator::Variable*&gt; operandToVariable(
354             OperandsLike, m_graph.block(0)-&gt;variablesAtHead);
<span class="line-modified">355         Vector&lt;VirtualRegister&gt; indexToOperand;</span>
356         for (size_t i = m_graph.block(0)-&gt;variablesAtHead.size(); i--;) {
<span class="line-modified">357             VirtualRegister operand(m_graph.block(0)-&gt;variablesAtHead.operandForIndex(i));</span>
358 
359             SSACalculator::Variable* variable = ssaCalculator.newVariable();
360             operandToVariable.operand(operand) = variable;
361             ASSERT(indexToOperand.size() == variable-&gt;index());
362             indexToOperand.append(operand);
363         }
364 
365         HashSet&lt;Node*&gt; putStacksToSink;
366 
367         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
368             for (Node* node : *block) {
369                 switch (node-&gt;op()) {
370                 case PutStack:
371                     putStacksToSink.add(node);
372                     ssaCalculator.newDef(
<span class="line-modified">373                         operandToVariable.operand(node-&gt;stackAccessData()-&gt;local),</span>
374                         block, node-&gt;child1().node());
375                     break;
376                 case GetStack:
377                     ssaCalculator.newDef(
<span class="line-modified">378                         operandToVariable.operand(node-&gt;stackAccessData()-&gt;local),</span>
379                         block, node);
380                     break;
381                 default:
382                     break;
383                 }
384             }
385         }
386 
387         ssaCalculator.computePhis(
388             [&amp;] (SSACalculator::Variable* variable, BasicBlock* block) -&gt; Node* {
<span class="line-modified">389                 VirtualRegister operand = indexToOperand[variable-&gt;index()];</span>
390 
391                 if (!liveAtHead[block].operand(operand))
392                     return nullptr;
393 
394                 FlushFormat format = deferredAtHead[block].operand(operand);
395 
396                 // We could have an invalid deferral because liveness is imprecise.
397                 if (!isConcrete(format))
398                     return nullptr;
399 
<span class="line-modified">400                 if (DFGPutStackSinkingPhaseInternal::verbose)</span>
401                     dataLog(&quot;Adding Phi for &quot;, operand, &quot; at &quot;, pointerDump(block), &quot;\n&quot;);
402 
403                 Node* phiNode = m_graph.addNode(SpecHeapTop, Phi, block-&gt;at(0)-&gt;origin.withInvalidExit());
404                 phiNode-&gt;mergeFlags(resultFor(format));
405                 return phiNode;
406             });
407 
408         Operands&lt;Node*&gt; mapping(OperandsLike, m_graph.block(0)-&gt;variablesAtHead);
409         Operands&lt;FlushFormat&gt; deferred;
410         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
411             mapping.fill(nullptr);
412 
413             for (size_t i = mapping.size(); i--;) {
<span class="line-modified">414                 VirtualRegister operand(mapping.operandForIndex(i));</span>
415 
416                 SSACalculator::Variable* variable = operandToVariable.operand(operand);
417                 SSACalculator::Def* def = ssaCalculator.reachingDefAtHead(block, variable);
418                 if (!def)
419                     continue;
420 
421                 mapping.operand(operand) = def-&gt;value();
422             }
423 
<span class="line-modified">424             if (DFGPutStackSinkingPhaseInternal::verbose)</span>
425                 dataLog(&quot;Mapping at top of &quot;, pointerDump(block), &quot;: &quot;, mapping, &quot;\n&quot;);
426 
427             for (SSACalculator::Def* phiDef : ssaCalculator.phisForBlock(block)) {
<span class="line-modified">428                 VirtualRegister operand = indexToOperand[phiDef-&gt;variable()-&gt;index()];</span>
429 
430                 insertionSet.insert(0, phiDef-&gt;value());
431 
<span class="line-modified">432                 if (DFGPutStackSinkingPhaseInternal::verbose)</span>
433                     dataLog(&quot;   Mapping &quot;, operand, &quot; to &quot;, phiDef-&gt;value(), &quot;\n&quot;);
434                 mapping.operand(operand) = phiDef-&gt;value();
435             }
436 
437             deferred = deferredAtHead[block];
438             for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
439                 Node* node = block-&gt;at(nodeIndex);
<span class="line-modified">440                 if (DFGPutStackSinkingPhaseInternal::verbose)</span>
441                     dataLog(&quot;Deferred at &quot;, node, &quot;:&quot;, deferred, &quot;\n&quot;);
442 
443                 switch (node-&gt;op()) {
444                 case PutStack: {
445                     StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">446                     VirtualRegister operand = data-&gt;local;</span>
447                     deferred.operand(operand) = data-&gt;format;
<span class="line-modified">448                     if (DFGPutStackSinkingPhaseInternal::verbose)</span>
449                         dataLog(&quot;   Mapping &quot;, operand, &quot; to &quot;, node-&gt;child1().node(), &quot; at &quot;, node, &quot;\n&quot;);
450                     mapping.operand(operand) = node-&gt;child1().node();
451                     break;
452                 }
453 
454                 case GetStack: {
455                     StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">456                     FlushFormat format = deferred.operand(data-&gt;local);</span>
457                     if (!isConcrete(format)) {
458                         DFG_ASSERT(
459                             m_graph, node,
<span class="line-modified">460                             deferred.operand(data-&gt;local) != ConflictingFlush, deferred.operand(data-&gt;local));</span>
461 
462                         // This means there is no deferral. No deferral means that the most
463                         // authoritative value for this stack slot is what is stored in the stack. So,
464                         // keep the GetStack.
<span class="line-modified">465                         mapping.operand(data-&gt;local) = node;</span>
466                         break;
467                     }
468 
469                     // We have a concrete deferral, which means a PutStack that hasn&#39;t executed yet. It
470                     // would have stored a value with a certain format. That format must match our
471                     // format. But more importantly, we can simply use the value that the PutStack would
472                     // have stored and get rid of the GetStack.
473                     DFG_ASSERT(m_graph, node, format == data-&gt;format, format, data-&gt;format);
474 
<span class="line-modified">475                     Node* incoming = mapping.operand(data-&gt;local);</span>
476                     node-&gt;child1() = incoming-&gt;defaultEdge();
477                     node-&gt;convertToIdentity();
478                     break;
479                 }
480 
481                 case KillStack: {
<span class="line-modified">482                     deferred.operand(node-&gt;unlinkedLocal()) = ConflictingFlush;</span>
483                     break;
484                 }
485 
486                 default: {
<span class="line-modified">487                     auto escapeHandler = [&amp;] (VirtualRegister operand) {</span>
<span class="line-modified">488                         if (DFGPutStackSinkingPhaseInternal::verbose)</span>
489                             dataLog(&quot;For &quot;, node, &quot; escaping &quot;, operand, &quot;\n&quot;);
490 
491                         if (operand.isHeader())
492                             return;
493 
494                         FlushFormat format = deferred.operand(operand);
495                         if (!isConcrete(format)) {
496                             // It&#39;s dead now, rather than conflicting.
497                             deferred.operand(operand) = DeadFlush;
498                             return;
499                         }
500 
501                         // Gotta insert a PutStack.
<span class="line-modified">502                         if (DFGPutStackSinkingPhaseInternal::verbose)</span>
503                             dataLog(&quot;Inserting a PutStack for &quot;, operand, &quot; at &quot;, node, &quot;\n&quot;);
504 
505                         Node* incoming = mapping.operand(operand);
506                         DFG_ASSERT(m_graph, node, incoming);
507 
508                         insertionSet.insertNode(
509                             nodeIndex, SpecNone, PutStack, node-&gt;origin,
510                             OpInfo(m_graph.m_stackAccessData.add(operand, format)),
511                             Edge(incoming, uncheckedUseKindFor(format)));
512 
513                         deferred.operand(operand) = DeadFlush;
514                     };
515 
<span class="line-modified">516                     auto writeHandler = [&amp;] (VirtualRegister operand) {</span>
517                         if (operand.isHeader())
518                             return;
519                         // LoadVarargs and ForwardVarargs are unconditional writes to the stack
520                         // locations they claim to write to. They do not read from the stack
521                         // locations they write to. This makes those stack locations dead right
522                         // before a LoadVarargs/ForwardVarargs. This means we should never sink
523                         // PutStacks right to this point.
<span class="line-modified">524                         RELEASE_ASSERT(node-&gt;op() == LoadVarargs || node-&gt;op() == ForwardVarargs);</span>
525                         deferred.operand(operand) = DeadFlush;
526                     };
527 
528                     preciseLocalClobberize(
529                         m_graph, node, escapeHandler, writeHandler,
<span class="line-modified">530                         [&amp;] (VirtualRegister, LazyNode) { });</span>
531                     break;
532                 } }
533             }
534 
535             NodeAndIndex terminal = block-&gt;findTerminal();
536             size_t upsilonInsertionPoint = terminal.index;
537             NodeOrigin upsilonOrigin = terminal.node-&gt;origin;
538             for (BasicBlock* successorBlock : block-&gt;successors()) {
539                 for (SSACalculator::Def* phiDef : ssaCalculator.phisForBlock(successorBlock)) {
540                     Node* phiNode = phiDef-&gt;value();
541                     SSACalculator::Variable* variable = phiDef-&gt;variable();
<span class="line-modified">542                     VirtualRegister operand = indexToOperand[variable-&gt;index()];</span>
<span class="line-modified">543                     if (DFGPutStackSinkingPhaseInternal::verbose)</span>
544                         dataLog(&quot;Creating Upsilon for &quot;, operand, &quot; at &quot;, pointerDump(block), &quot;-&gt;&quot;, pointerDump(successorBlock), &quot;\n&quot;);
545                     FlushFormat format = deferredAtHead[successorBlock].operand(operand);
546                     DFG_ASSERT(m_graph, nullptr, isConcrete(format), format);
547                     UseKind useKind = uncheckedUseKindFor(format);
548 
549                     // We need to get a value for the stack slot. This phase doesn&#39;t really have a
550                     // good way of determining if a stack location got clobbered. It just knows if
551                     // there is a deferral. The lack of a deferral might mean that a PutStack or
552                     // GetStack had never happened, or it might mean that the value was read, or
553                     // that it was written. It&#39;s OK for us to make some bad decisions here, since
554                     // GCSE will clean it up anyway.
555                     Node* incoming;
556                     if (isConcrete(deferred.operand(operand))) {
557                         incoming = mapping.operand(operand);
558                         DFG_ASSERT(m_graph, phiNode, incoming);
559                     } else {
560                         // Issue a GetStack to get the value. This might introduce some redundancy
561                         // into the code, but if it&#39;s bad enough, GCSE will clean it up.
562                         incoming = insertionSet.insertNode(
563                             upsilonInsertionPoint, SpecNone, GetStack, upsilonOrigin,
</pre>
<hr />
<pre>
568                     insertionSet.insertNode(
569                         upsilonInsertionPoint, SpecNone, Upsilon, upsilonOrigin,
570                         OpInfo(phiNode), Edge(incoming, useKind));
571                 }
572             }
573 
574             insertionSet.execute(block);
575         }
576 
577         // Finally eliminate the sunken PutStacks by turning them into Checks. This keeps whatever
578         // type check they were doing.
579         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
580             for (auto* node : *block) {
581                 if (!putStacksToSink.contains(node))
582                     continue;
583 
584                 node-&gt;remove(m_graph);
585             }
586         }
587 
<span class="line-modified">588         if (DFGPutStackSinkingPhaseInternal::verbose) {</span>
589             dataLog(&quot;Graph after PutStack sinking:\n&quot;);
590             m_graph.dump();
591         }
592 
593         return true;
594     }
595 };
596 
597 } // anonymous namespace
598 
599 bool performPutStackSinking(Graph&amp; graph)
600 {
601     return runPhase&lt;PutStackSinkingPhase&gt;(graph);
602 }
603 
604 } } // namespace JSC::DFG
605 
606 #endif // ENABLE(DFG_JIT)
607 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2014-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGPutStackSinkingPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;DFGBlockMapInlines.h&quot;
 32 #include &quot;DFGGraph.h&quot;
 33 #include &quot;DFGInsertionSet.h&quot;
 34 #include &quot;DFGPhase.h&quot;
 35 #include &quot;DFGPreciseLocalClobberize.h&quot;
 36 #include &quot;DFGSSACalculator.h&quot;
 37 #include &quot;DFGValidate.h&quot;
 38 #include &quot;JSCInlines.h&quot;
 39 #include &quot;OperandsInlines.h&quot;
 40 
 41 namespace JSC { namespace DFG {
 42 
 43 namespace {
 44 




 45 class PutStackSinkingPhase : public Phase {
<span class="line-added"> 46     static constexpr bool verbose = false;</span>
 47 public:
 48     PutStackSinkingPhase(Graph&amp; graph)
 49         : Phase(graph, &quot;PutStack sinking&quot;)
 50     {
 51     }
 52 
 53     bool run()
 54     {
 55         // FIXME: One of the problems of this approach is that it will create a duplicate Phi graph
 56         // for sunken PutStacks in the presence of interesting control flow merges, and where the
 57         // value being PutStack&#39;d is also otherwise live in the DFG code. We could work around this
 58         // by doing the sinking over CPS, or maybe just by doing really smart hoisting. It&#39;s also
 59         // possible that the duplicate Phi graph can be deduplicated by B3. It would be best if we
 60         // could observe that there is already a Phi graph in place that does what we want. In
 61         // principle if we have a request to place a Phi at a particular place, we could just check
 62         // if there is already a Phi that does what we want. Because PutStackSinkingPhase runs just
 63         // after SSA conversion, we have almost a guarantee that the Phi graph we produce here would
 64         // be trivially redundant to the one we already have.
 65 
 66         // FIXME: This phase doesn&#39;t adequately use KillStacks. KillStack can be viewed as a def.
 67         // This is mostly inconsequential; it would be a bug to have a local live at a KillStack.
 68         // More important is that KillStack should swallow any deferral. After a KillStack, the
 69         // local should behave like a TOP deferral because it would be invalid for anyone to trust
 70         // the stack. It&#39;s not clear to me if this is important or not.
 71         // https://bugs.webkit.org/show_bug.cgi?id=145296
 72 
<span class="line-modified"> 73         if (verbose) {</span>
 74             dataLog(&quot;Graph before PutStack sinking:\n&quot;);
 75             m_graph.dump();
 76         }
 77 
 78         m_graph.ensureSSADominators();
 79 
 80         SSACalculator ssaCalculator(m_graph);
 81         InsertionSet insertionSet(m_graph);
 82 
 83         // First figure out where various locals are live.
 84         BlockMap&lt;Operands&lt;bool&gt;&gt; liveAtHead(m_graph);
 85         BlockMap&lt;Operands&lt;bool&gt;&gt; liveAtTail(m_graph);
 86 
 87         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
<span class="line-modified"> 88             liveAtHead[block] = Operands&lt;bool&gt;(OperandsLike, block-&gt;variablesAtHead, false);</span>
<span class="line-modified"> 89             liveAtTail[block] = Operands&lt;bool&gt;(OperandsLike, block-&gt;variablesAtHead, false);</span>



 90         }
 91 
 92         bool changed;
 93         do {
 94             changed = false;
 95 
 96             for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
 97                 BasicBlock* block = m_graph.block(blockIndex);
 98                 if (!block)
 99                     continue;
100 
101                 Operands&lt;bool&gt; live = liveAtTail[block];
102                 for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
103                     Node* node = block-&gt;at(nodeIndex);
<span class="line-modified">104                     if (verbose)</span>
105                         dataLog(&quot;Live at &quot;, node, &quot;: &quot;, live, &quot;\n&quot;);
106 
<span class="line-modified">107                     Vector&lt;Operand, 4&gt; reads;</span>
<span class="line-modified">108                     Vector&lt;Operand, 4&gt; writes;</span>
<span class="line-modified">109                     auto escapeHandler = [&amp;] (Operand operand) {</span>
110                         if (operand.isHeader())
111                             return;
<span class="line-modified">112                         if (verbose)</span>
113                             dataLog(&quot;    &quot;, operand, &quot; is live at &quot;, node, &quot;\n&quot;);
114                         reads.append(operand);
115                     };
116 
<span class="line-modified">117                     auto writeHandler = [&amp;] (Operand operand) {</span>
118                         if (operand.isHeader())
119                             return;
<span class="line-modified">120                         auto op = node-&gt;op();</span>
<span class="line-added">121                         RELEASE_ASSERT(op == PutStack || op == LoadVarargs || op == ForwardVarargs || op == KillStack);</span>
122                         writes.append(operand);
123                     };
124 
125                     preciseLocalClobberize(
126                         m_graph, node, escapeHandler, writeHandler,
<span class="line-modified">127                         [&amp;] (Operand, LazyNode) { });</span>
128 
<span class="line-modified">129                     for (Operand operand : writes)</span>
130                         live.operand(operand) = false;
<span class="line-modified">131                     for (Operand operand : reads)</span>
132                         live.operand(operand) = true;
133                 }
134 
135                 if (live == liveAtHead[block])
136                     continue;
137 
138                 liveAtHead[block] = live;
139                 changed = true;
140 
141                 for (BasicBlock* predecessor : block-&gt;predecessors) {
142                     for (size_t i = live.size(); i--;)
143                         liveAtTail[predecessor][i] |= live[i];
144                 }
145             }
146 
147         } while (changed);
148 
149         // All of the arguments should be live at head of root. Note that we may find that some
150         // locals are live at head of root. This seems wrong but isn&#39;t. This will happen for example
151         // if the function accesses closure variable #42 for some other function and we either don&#39;t
</pre>
<hr />
<pre>
212         BlockMap&lt;Operands&lt;FlushFormat&gt;&gt; deferredAtHead(m_graph);
213         BlockMap&lt;Operands&lt;FlushFormat&gt;&gt; deferredAtTail(m_graph);
214 
215         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
216             deferredAtHead[block] =
217                 Operands&lt;FlushFormat&gt;(OperandsLike, block-&gt;variablesAtHead);
218             deferredAtTail[block] =
219                 Operands&lt;FlushFormat&gt;(OperandsLike, block-&gt;variablesAtHead);
220         }
221 
222         for (unsigned local = deferredAtHead.atIndex(0).numberOfLocals(); local--;)
223             deferredAtHead.atIndex(0).local(local) = ConflictingFlush;
224 
225         do {
226             changed = false;
227 
228             for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
229                 Operands&lt;FlushFormat&gt; deferred = deferredAtHead[block];
230 
231                 for (Node* node : *block) {
<span class="line-modified">232                     if (verbose)</span>
233                         dataLog(&quot;Deferred at &quot;, node, &quot;:&quot;, deferred, &quot;\n&quot;);
234 
235                     if (node-&gt;op() == GetStack) {
236                         // Handle the case that the input doesn&#39;t match our requirements. This is
237                         // really a bug, but it&#39;s a benign one if we simply don&#39;t run this phase.
238                         // It usually arises because of patterns like:
239                         //
240                         // if (thing)
241                         //     PutStack()
242                         // ...
243                         // if (thing)
244                         //     GetStack()
245                         //
246                         // Or:
247                         //
248                         // if (never happens)
249                         //     GetStack()
250                         //
251                         // Because this phase runs early in SSA, it should be sensible to enforce
252                         // that no such code pattern has arisen yet. So, when validation is
253                         // enabled, we assert that we aren&#39;t seeing this. But with validation
254                         // disabled we silently let this fly and we just abort this phase.
255                         // FIXME: Get rid of all remaining cases of conflicting GetStacks.
256                         // https://bugs.webkit.org/show_bug.cgi?id=150398
257 
258                         bool isConflicting =
<span class="line-modified">259                             deferred.operand(node-&gt;stackAccessData()-&gt;operand) == ConflictingFlush;</span>
260 
261                         if (validationEnabled())
262                             DFG_ASSERT(m_graph, node, !isConflicting);
263 
264                         if (isConflicting) {
265                             // Oh noes! Abort!!
266                             return false;
267                         }
268 
269                         // A GetStack doesn&#39;t affect anything, since we know which local we are reading
270                         // from.
271                         continue;
272                     } else if (node-&gt;op() == PutStack) {
<span class="line-modified">273                         Operand operand = node-&gt;stackAccessData()-&gt;operand;</span>
<span class="line-added">274                         dataLogLnIf(verbose, &quot;Setting flush format for &quot;, node, &quot; at operand &quot;, operand);</span>
275                         deferred.operand(operand) = node-&gt;stackAccessData()-&gt;format;
276                         continue;
277                     } else if (node-&gt;op() == KillStack) {
278                         // We don&#39;t want to sink a PutStack past a KillStack.
<span class="line-modified">279                         if (verbose)</span>
<span class="line-added">280                             dataLogLn(&quot;Killing stack for &quot;, node-&gt;unlinkedOperand());</span>
<span class="line-added">281                         deferred.operand(node-&gt;unlinkedOperand()) = ConflictingFlush;</span>
282                         continue;
283                     }
284 
<span class="line-modified">285                     auto escapeHandler = [&amp;] (Operand operand) {</span>
<span class="line-modified">286                         if (verbose)</span>
287                             dataLog(&quot;For &quot;, node, &quot; escaping &quot;, operand, &quot;\n&quot;);
288                         if (operand.isHeader())
289                             return;
290                         // We will materialize just before any reads.
291                         deferred.operand(operand) = DeadFlush;
292                     };
293 
<span class="line-modified">294                     auto writeHandler = [&amp;] (Operand operand) {</span>
<span class="line-added">295                         ASSERT(!operand.isTmp());</span>
296                         if (operand.isHeader())
297                             return;
<span class="line-modified">298                         RELEASE_ASSERT(node-&gt;op() == VarargsLength || node-&gt;op() == LoadVarargs || node-&gt;op() == ForwardVarargs);</span>
<span class="line-added">299                         dataLogLnIf(verbose, &quot;Writing dead flush for &quot;, node, &quot; at operand &quot;, operand);</span>
300                         deferred.operand(operand) = DeadFlush;
301                     };
302 
303                     preciseLocalClobberize(
304                         m_graph, node, escapeHandler, writeHandler,
<span class="line-modified">305                         [&amp;] (Operand, LazyNode) { });</span>
306                 }
307 
308                 if (deferred == deferredAtTail[block])
309                     continue;
310 
311                 deferredAtTail[block] = deferred;
312                 changed = true;
313 
314                 for (BasicBlock* successor : block-&gt;successors()) {
315                     for (size_t i = deferred.size(); i--;) {
<span class="line-modified">316                         if (verbose)</span>
<span class="line-modified">317                             dataLog(&quot;Considering &quot;, deferred.operandForIndex(i), &quot; at &quot;, pointerDump(block), &quot;-&gt;&quot;, pointerDump(successor), &quot;: &quot;, deferred[i], &quot; and &quot;, deferredAtHead[successor][i], &quot; merges to &quot;);</span>
318 
319                         deferredAtHead[successor][i] =
320                             merge(deferredAtHead[successor][i], deferred[i]);
321 
<span class="line-modified">322                         if (verbose)</span>
323                             dataLog(deferredAtHead[successor][i], &quot;\n&quot;);
324                     }
325                 }
326             }
327 
328         } while (changed);
329 
330         // We wish to insert PutStacks at all of the materialization points, which are defined
331         // implicitly as the places where we set deferred to Dead while it was previously not Dead.
332         // To do this, we may need to build some Phi functions to handle stuff like this:
333         //
334         // Before:
335         //
336         //     if (p)
337         //         PutStack(r42, @x)
338         //     else
339         //         PutStack(r42, @y)
340         //
341         // After:
342         //
343         //     if (p)
344         //         Upsilon(@x, ^z)
345         //     else
346         //         Upsilon(@y, ^z)
347         //     z: Phi()
348         //     PutStack(r42, @z)
349         //
350         // This means that we have an SSACalculator::Variable for each local, and a Def is any
351         // PutStack in the original program. The original PutStacks will simply vanish.
352 
353         Operands&lt;SSACalculator::Variable*&gt; operandToVariable(
354             OperandsLike, m_graph.block(0)-&gt;variablesAtHead);
<span class="line-modified">355         Vector&lt;Operand&gt; indexToOperand;</span>
356         for (size_t i = m_graph.block(0)-&gt;variablesAtHead.size(); i--;) {
<span class="line-modified">357             Operand operand = m_graph.block(0)-&gt;variablesAtHead.operandForIndex(i);</span>
358 
359             SSACalculator::Variable* variable = ssaCalculator.newVariable();
360             operandToVariable.operand(operand) = variable;
361             ASSERT(indexToOperand.size() == variable-&gt;index());
362             indexToOperand.append(operand);
363         }
364 
365         HashSet&lt;Node*&gt; putStacksToSink;
366 
367         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
368             for (Node* node : *block) {
369                 switch (node-&gt;op()) {
370                 case PutStack:
371                     putStacksToSink.add(node);
372                     ssaCalculator.newDef(
<span class="line-modified">373                         operandToVariable.operand(node-&gt;stackAccessData()-&gt;operand),</span>
374                         block, node-&gt;child1().node());
375                     break;
376                 case GetStack:
377                     ssaCalculator.newDef(
<span class="line-modified">378                         operandToVariable.operand(node-&gt;stackAccessData()-&gt;operand),</span>
379                         block, node);
380                     break;
381                 default:
382                     break;
383                 }
384             }
385         }
386 
387         ssaCalculator.computePhis(
388             [&amp;] (SSACalculator::Variable* variable, BasicBlock* block) -&gt; Node* {
<span class="line-modified">389                 Operand operand = indexToOperand[variable-&gt;index()];</span>
390 
391                 if (!liveAtHead[block].operand(operand))
392                     return nullptr;
393 
394                 FlushFormat format = deferredAtHead[block].operand(operand);
395 
396                 // We could have an invalid deferral because liveness is imprecise.
397                 if (!isConcrete(format))
398                     return nullptr;
399 
<span class="line-modified">400                 if (verbose)</span>
401                     dataLog(&quot;Adding Phi for &quot;, operand, &quot; at &quot;, pointerDump(block), &quot;\n&quot;);
402 
403                 Node* phiNode = m_graph.addNode(SpecHeapTop, Phi, block-&gt;at(0)-&gt;origin.withInvalidExit());
404                 phiNode-&gt;mergeFlags(resultFor(format));
405                 return phiNode;
406             });
407 
408         Operands&lt;Node*&gt; mapping(OperandsLike, m_graph.block(0)-&gt;variablesAtHead);
409         Operands&lt;FlushFormat&gt; deferred;
410         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
411             mapping.fill(nullptr);
412 
413             for (size_t i = mapping.size(); i--;) {
<span class="line-modified">414                 Operand operand(mapping.operandForIndex(i));</span>
415 
416                 SSACalculator::Variable* variable = operandToVariable.operand(operand);
417                 SSACalculator::Def* def = ssaCalculator.reachingDefAtHead(block, variable);
418                 if (!def)
419                     continue;
420 
421                 mapping.operand(operand) = def-&gt;value();
422             }
423 
<span class="line-modified">424             if (verbose)</span>
425                 dataLog(&quot;Mapping at top of &quot;, pointerDump(block), &quot;: &quot;, mapping, &quot;\n&quot;);
426 
427             for (SSACalculator::Def* phiDef : ssaCalculator.phisForBlock(block)) {
<span class="line-modified">428                 Operand operand = indexToOperand[phiDef-&gt;variable()-&gt;index()];</span>
429 
430                 insertionSet.insert(0, phiDef-&gt;value());
431 
<span class="line-modified">432                 if (verbose)</span>
433                     dataLog(&quot;   Mapping &quot;, operand, &quot; to &quot;, phiDef-&gt;value(), &quot;\n&quot;);
434                 mapping.operand(operand) = phiDef-&gt;value();
435             }
436 
437             deferred = deferredAtHead[block];
438             for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
439                 Node* node = block-&gt;at(nodeIndex);
<span class="line-modified">440                 if (verbose)</span>
441                     dataLog(&quot;Deferred at &quot;, node, &quot;:&quot;, deferred, &quot;\n&quot;);
442 
443                 switch (node-&gt;op()) {
444                 case PutStack: {
445                     StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">446                     Operand operand = data-&gt;operand;</span>
447                     deferred.operand(operand) = data-&gt;format;
<span class="line-modified">448                     if (verbose)</span>
449                         dataLog(&quot;   Mapping &quot;, operand, &quot; to &quot;, node-&gt;child1().node(), &quot; at &quot;, node, &quot;\n&quot;);
450                     mapping.operand(operand) = node-&gt;child1().node();
451                     break;
452                 }
453 
454                 case GetStack: {
455                     StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">456                     FlushFormat format = deferred.operand(data-&gt;operand);</span>
457                     if (!isConcrete(format)) {
458                         DFG_ASSERT(
459                             m_graph, node,
<span class="line-modified">460                             deferred.operand(data-&gt;operand) != ConflictingFlush, deferred.operand(data-&gt;operand));</span>
461 
462                         // This means there is no deferral. No deferral means that the most
463                         // authoritative value for this stack slot is what is stored in the stack. So,
464                         // keep the GetStack.
<span class="line-modified">465                         mapping.operand(data-&gt;operand) = node;</span>
466                         break;
467                     }
468 
469                     // We have a concrete deferral, which means a PutStack that hasn&#39;t executed yet. It
470                     // would have stored a value with a certain format. That format must match our
471                     // format. But more importantly, we can simply use the value that the PutStack would
472                     // have stored and get rid of the GetStack.
473                     DFG_ASSERT(m_graph, node, format == data-&gt;format, format, data-&gt;format);
474 
<span class="line-modified">475                     Node* incoming = mapping.operand(data-&gt;operand);</span>
476                     node-&gt;child1() = incoming-&gt;defaultEdge();
477                     node-&gt;convertToIdentity();
478                     break;
479                 }
480 
481                 case KillStack: {
<span class="line-modified">482                     deferred.operand(node-&gt;unlinkedOperand()) = ConflictingFlush;</span>
483                     break;
484                 }
485 
486                 default: {
<span class="line-modified">487                     auto escapeHandler = [&amp;] (Operand operand) {</span>
<span class="line-modified">488                         if (verbose)</span>
489                             dataLog(&quot;For &quot;, node, &quot; escaping &quot;, operand, &quot;\n&quot;);
490 
491                         if (operand.isHeader())
492                             return;
493 
494                         FlushFormat format = deferred.operand(operand);
495                         if (!isConcrete(format)) {
496                             // It&#39;s dead now, rather than conflicting.
497                             deferred.operand(operand) = DeadFlush;
498                             return;
499                         }
500 
501                         // Gotta insert a PutStack.
<span class="line-modified">502                         if (verbose)</span>
503                             dataLog(&quot;Inserting a PutStack for &quot;, operand, &quot; at &quot;, node, &quot;\n&quot;);
504 
505                         Node* incoming = mapping.operand(operand);
506                         DFG_ASSERT(m_graph, node, incoming);
507 
508                         insertionSet.insertNode(
509                             nodeIndex, SpecNone, PutStack, node-&gt;origin,
510                             OpInfo(m_graph.m_stackAccessData.add(operand, format)),
511                             Edge(incoming, uncheckedUseKindFor(format)));
512 
513                         deferred.operand(operand) = DeadFlush;
514                     };
515 
<span class="line-modified">516                     auto writeHandler = [&amp;] (Operand operand) {</span>
517                         if (operand.isHeader())
518                             return;
519                         // LoadVarargs and ForwardVarargs are unconditional writes to the stack
520                         // locations they claim to write to. They do not read from the stack
521                         // locations they write to. This makes those stack locations dead right
522                         // before a LoadVarargs/ForwardVarargs. This means we should never sink
523                         // PutStacks right to this point.
<span class="line-modified">524                         RELEASE_ASSERT(node-&gt;op() == VarargsLength || node-&gt;op() == LoadVarargs || node-&gt;op() == ForwardVarargs);</span>
525                         deferred.operand(operand) = DeadFlush;
526                     };
527 
528                     preciseLocalClobberize(
529                         m_graph, node, escapeHandler, writeHandler,
<span class="line-modified">530                         [&amp;] (Operand, LazyNode) { });</span>
531                     break;
532                 } }
533             }
534 
535             NodeAndIndex terminal = block-&gt;findTerminal();
536             size_t upsilonInsertionPoint = terminal.index;
537             NodeOrigin upsilonOrigin = terminal.node-&gt;origin;
538             for (BasicBlock* successorBlock : block-&gt;successors()) {
539                 for (SSACalculator::Def* phiDef : ssaCalculator.phisForBlock(successorBlock)) {
540                     Node* phiNode = phiDef-&gt;value();
541                     SSACalculator::Variable* variable = phiDef-&gt;variable();
<span class="line-modified">542                     Operand operand = indexToOperand[variable-&gt;index()];</span>
<span class="line-modified">543                     if (verbose)</span>
544                         dataLog(&quot;Creating Upsilon for &quot;, operand, &quot; at &quot;, pointerDump(block), &quot;-&gt;&quot;, pointerDump(successorBlock), &quot;\n&quot;);
545                     FlushFormat format = deferredAtHead[successorBlock].operand(operand);
546                     DFG_ASSERT(m_graph, nullptr, isConcrete(format), format);
547                     UseKind useKind = uncheckedUseKindFor(format);
548 
549                     // We need to get a value for the stack slot. This phase doesn&#39;t really have a
550                     // good way of determining if a stack location got clobbered. It just knows if
551                     // there is a deferral. The lack of a deferral might mean that a PutStack or
552                     // GetStack had never happened, or it might mean that the value was read, or
553                     // that it was written. It&#39;s OK for us to make some bad decisions here, since
554                     // GCSE will clean it up anyway.
555                     Node* incoming;
556                     if (isConcrete(deferred.operand(operand))) {
557                         incoming = mapping.operand(operand);
558                         DFG_ASSERT(m_graph, phiNode, incoming);
559                     } else {
560                         // Issue a GetStack to get the value. This might introduce some redundancy
561                         // into the code, but if it&#39;s bad enough, GCSE will clean it up.
562                         incoming = insertionSet.insertNode(
563                             upsilonInsertionPoint, SpecNone, GetStack, upsilonOrigin,
</pre>
<hr />
<pre>
568                     insertionSet.insertNode(
569                         upsilonInsertionPoint, SpecNone, Upsilon, upsilonOrigin,
570                         OpInfo(phiNode), Edge(incoming, useKind));
571                 }
572             }
573 
574             insertionSet.execute(block);
575         }
576 
577         // Finally eliminate the sunken PutStacks by turning them into Checks. This keeps whatever
578         // type check they were doing.
579         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
580             for (auto* node : *block) {
581                 if (!putStacksToSink.contains(node))
582                     continue;
583 
584                 node-&gt;remove(m_graph);
585             }
586         }
587 
<span class="line-modified">588         if (verbose) {</span>
589             dataLog(&quot;Graph after PutStack sinking:\n&quot;);
590             m_graph.dump();
591         }
592 
593         return true;
594     }
595 };
596 
597 } // anonymous namespace
598 
599 bool performPutStackSinking(Graph&amp; graph)
600 {
601     return runPhase&lt;PutStackSinkingPhase&gt;(graph);
602 }
603 
604 } } // namespace JSC::DFG
605 
606 #endif // ENABLE(DFG_JIT)
607 
</pre>
</td>
</tr>
</table>
<center><a href="DFGPureValue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGRegisterBank.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
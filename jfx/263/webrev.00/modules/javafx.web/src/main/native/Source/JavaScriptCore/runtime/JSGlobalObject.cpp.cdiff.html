<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGlobalObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSGlobalLexicalEnvironment.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGlobalObject.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGlobalObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 77,11 ***</span>
<span class="line-new-header">--- 77,13 ---</span>
  #include &quot;IteratorPrototype.h&quot;
  #include &quot;JSAPIWrapperObject.h&quot;
  #include &quot;JSArrayBuffer.h&quot;
  #include &quot;JSArrayBufferConstructor.h&quot;
  #include &quot;JSArrayBufferPrototype.h&quot;
<span class="line-added">+ #include &quot;JSArrayIterator.h&quot;</span>
  #include &quot;JSAsyncFunction.h&quot;
<span class="line-added">+ #include &quot;JSAsyncGenerator.h&quot;</span>
  #include &quot;JSAsyncGeneratorFunction.h&quot;
  #include &quot;JSBigInt.h&quot;
  #include &quot;JSBoundFunction.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSCallbackConstructor.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 90,10 ***</span>
<span class="line-new-header">--- 92,11 ---</span>
  #include &quot;JSCustomGetterSetterFunction.h&quot;
  #include &quot;JSDataView.h&quot;
  #include &quot;JSDataViewPrototype.h&quot;
  #include &quot;JSDollarVM.h&quot;
  #include &quot;JSFunction.h&quot;
<span class="line-added">+ #include &quot;JSGenerator.h&quot;</span>
  #include &quot;JSGeneratorFunction.h&quot;
  #include &quot;JSGenericTypedArrayViewConstructorInlines.h&quot;
  #include &quot;JSGenericTypedArrayViewInlines.h&quot;
  #include &quot;JSGenericTypedArrayViewPrototypeInlines.h&quot;
  #include &quot;JSGlobalObjectFunctions.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 107,11 ***</span>
  #include &quot;JSModuleEnvironment.h&quot;
  #include &quot;JSModuleLoader.h&quot;
  #include &quot;JSModuleNamespaceObject.h&quot;
  #include &quot;JSModuleRecord.h&quot;
  #include &quot;JSNativeStdFunction.h&quot;
<span class="line-removed">- #include &quot;JSNonDestructibleProxy.h&quot;</span>
  #include &quot;JSONObject.h&quot;
  #include &quot;JSPromise.h&quot;
  #include &quot;JSPromiseConstructor.h&quot;
  #include &quot;JSPromisePrototype.h&quot;
  #include &quot;JSSet.h&quot;
<span class="line-new-header">--- 110,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 124,19 ***</span>
<span class="line-new-header">--- 126,21 ---</span>
  #include &quot;JSWeakMap.h&quot;
  #include &quot;JSWeakObjectRef.h&quot;
  #include &quot;JSWeakSet.h&quot;
  #include &quot;JSWebAssembly.h&quot;
  #include &quot;JSWebAssemblyCompileError.h&quot;
<span class="line-added">+ #include &quot;JSWebAssemblyGlobal.h&quot;</span>
  #include &quot;JSWebAssemblyInstance.h&quot;
  #include &quot;JSWebAssemblyLinkError.h&quot;
  #include &quot;JSWebAssemblyMemory.h&quot;
  #include &quot;JSWebAssemblyModule.h&quot;
  #include &quot;JSWebAssemblyRuntimeError.h&quot;
  #include &quot;JSWebAssemblyTable.h&quot;
  #include &quot;JSWithScope.h&quot;
  #include &quot;LazyClassStructureInlines.h&quot;
  #include &quot;LazyPropertyInlines.h&quot;
<span class="line-added">+ #include &quot;LinkTimeConstant.h&quot;</span>
  #include &quot;Lookup.h&quot;
  #include &quot;MapConstructor.h&quot;
  #include &quot;MapIteratorPrototype.h&quot;
  #include &quot;MapPrototype.h&quot;
  #include &quot;MarkedSpaceInlines.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 186,10 ***</span>
<span class="line-new-header">--- 190,12 ---</span>
  #include &quot;WeakSetConstructor.h&quot;
  #include &quot;WeakSetPrototype.h&quot;
  #include &quot;WebAssemblyCompileErrorConstructor.h&quot;
  #include &quot;WebAssemblyCompileErrorPrototype.h&quot;
  #include &quot;WebAssemblyFunction.h&quot;
<span class="line-added">+ #include &quot;WebAssemblyGlobalConstructor.h&quot;</span>
<span class="line-added">+ #include &quot;WebAssemblyGlobalPrototype.h&quot;</span>
  #include &quot;WebAssemblyInstanceConstructor.h&quot;
  #include &quot;WebAssemblyInstancePrototype.h&quot;
  #include &quot;WebAssemblyLinkErrorConstructor.h&quot;
  #include &quot;WebAssemblyLinkErrorPrototype.h&quot;
  #include &quot;WebAssemblyMemoryConstructor.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 199,11 ***</span>
  #include &quot;WebAssemblyModuleRecord.h&quot;
  #include &quot;WebAssemblyRuntimeErrorConstructor.h&quot;
  #include &quot;WebAssemblyRuntimeErrorPrototype.h&quot;
  #include &quot;WebAssemblyTableConstructor.h&quot;
  #include &quot;WebAssemblyTablePrototype.h&quot;
<span class="line-removed">- #include &quot;WebAssemblyToJSCallee.h&quot;</span>
  #include &lt;wtf/RandomNumber.h&gt;
  
  #if ENABLE(INTL)
  #include &quot;IntlCollator.h&quot;
  #include &quot;IntlCollatorPrototype.h&quot;
<span class="line-new-header">--- 205,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 212,13 ***</span>
  #include &quot;IntlNumberFormat.h&quot;
  #include &quot;IntlNumberFormatPrototype.h&quot;
  #include &quot;IntlObject.h&quot;
  #include &quot;IntlPluralRules.h&quot;
  #include &quot;IntlPluralRulesPrototype.h&quot;
<span class="line-removed">- #include &lt;unicode/ucol.h&gt;</span>
<span class="line-removed">- #include &lt;unicode/udat.h&gt;</span>
<span class="line-removed">- #include &lt;unicode/unum.h&gt;</span>
  #endif // ENABLE(INTL)
  
  #if ENABLE(REMOTE_INSPECTOR)
  #include &quot;JSGlobalObjectDebuggable.h&quot;
  #include &quot;JSGlobalObjectInspectorController.h&quot;
<span class="line-new-header">--- 217,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 263,53 ***</span>
  }
  
  static JSValue createConsoleProperty(VM&amp; vm, JSObject* object)
  {
      JSGlobalObject* global = jsCast&lt;JSGlobalObject*&gt;(object);
<span class="line-modified">!     return ConsoleObject::create(vm, global, ConsoleObject::createStructure(vm, global, constructEmptyObject(global-&gt;globalExec())));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL makeBoundFunction(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     JSObject* target = asObject(exec-&gt;uncheckedArgument(0));</span>
<span class="line-modified">!     JSValue boundThis = exec-&gt;uncheckedArgument(1);</span>
<span class="line-modified">!     JSValue boundArgs = exec-&gt;uncheckedArgument(2);</span>
<span class="line-removed">-     JSValue lengthValue = exec-&gt;uncheckedArgument(3);</span>
<span class="line-removed">-     JSString* nameString = asString(exec-&gt;uncheckedArgument(4));</span>
  
      ASSERT(lengthValue.isInt32AsAnyInt());
      int32_t length = lengthValue.asInt32AsAnyInt();
  
<span class="line-modified">!     String name = nameString-&gt;value(exec);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-removed">- </span>
<span class="line-removed">-     RELEASE_AND_RETURN(scope, JSValue::encode(JSBoundFunction::create(vm, exec, globalObject, target, boundThis, boundArgs.isCell() ? jsCast&lt;JSArray*&gt;(boundArgs) : nullptr, length, WTFMove(name))));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL hasOwnLengthProperty(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSObject* target = asObject(exec-&gt;uncheckedArgument(0));</span>
<span class="line-modified">!     return JSValue::encode(jsBoolean(target-&gt;hasOwnProperty(exec, vm.propertyNames-&gt;length)));</span>
  }
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL assertCall(ExecState* exec)</span>
  {
<span class="line-modified">!     RELEASE_ASSERT(exec-&gt;argument(0).isBoolean());</span>
<span class="line-modified">!     if (exec-&gt;argument(0).asBoolean())</span>
          return JSValue::encode(jsUndefined());
  
      bool iteratedOnce = false;
      CodeBlock* codeBlock = nullptr;
      unsigned line;
<span class="line-modified">!     exec-&gt;iterate([&amp;] (StackVisitor&amp; visitor) {</span>
          if (!iteratedOnce) {
              iteratedOnce = true;
              return StackVisitor::Continue;
          }
  
<span class="line-new-header">--- 265,52 ---</span>
  }
  
  static JSValue createConsoleProperty(VM&amp; vm, JSObject* object)
  {
      JSGlobalObject* global = jsCast&lt;JSGlobalObject*&gt;(object);
<span class="line-modified">!     return ConsoleObject::create(vm, global, ConsoleObject::createStructure(vm, global, constructEmptyObject(global)));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL makeBoundFunction(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* target = asObject(callFrame-&gt;uncheckedArgument(0));</span>
<span class="line-modified">!     JSValue boundThis = callFrame-&gt;uncheckedArgument(1);</span>
<span class="line-modified">!     JSValue boundArgs = callFrame-&gt;uncheckedArgument(2);</span>
<span class="line-modified">!     JSValue lengthValue = callFrame-&gt;uncheckedArgument(3);</span>
<span class="line-modified">!     JSString* nameString = asString(callFrame-&gt;uncheckedArgument(4));</span>
  
      ASSERT(lengthValue.isInt32AsAnyInt());
      int32_t length = lengthValue.asInt32AsAnyInt();
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(JSBoundFunction::create(vm, globalObject, target, boundThis, boundArgs.isCell() ? jsCast&lt;JSImmutableButterfly*&gt;(boundArgs) : nullptr, length, nameString)));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL hasOwnLengthProperty(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     JSObject* target = asObject(callFrame-&gt;uncheckedArgument(0));</span>
<span class="line-added">+     JSFunction* function = jsDynamicCast&lt;JSFunction*&gt;(vm, target);</span>
<span class="line-added">+     if (function)</span>
<span class="line-added">+         return JSValue::encode(jsBoolean(function-&gt;areNameAndLengthOriginal(vm)));</span>
<span class="line-added">+     return JSValue::encode(jsBoolean(target-&gt;hasOwnProperty(globalObject, vm.propertyNames-&gt;length)));</span>
  }
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL assertCall(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     RELEASE_ASSERT(callFrame-&gt;argument(0).isBoolean());</span>
<span class="line-modified">!     if (callFrame-&gt;argument(0).asBoolean())</span>
          return JSValue::encode(jsUndefined());
  
      bool iteratedOnce = false;
      CodeBlock* codeBlock = nullptr;
      unsigned line;
<span class="line-modified">!     callFrame-&gt;iterate(globalObject-&gt;vm(), [&amp;] (StackVisitor&amp; visitor) {</span>
          if (!iteratedOnce) {
              iteratedOnce = true;
              return StackVisitor::Continue;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 321,11 ***</span>
      });
      RELEASE_ASSERT(!!codeBlock);
      RELEASE_ASSERT_WITH_MESSAGE(false, &quot;JS assertion failed at line %u in:\n%s\n&quot;, line, codeBlock-&gt;sourceCodeForTools().data());
      return JSValue::encode(jsUndefined());
  }
<span class="line-modified">! #endif</span>
  
  } // namespace JSC
  
  #include &quot;JSGlobalObject.lut.h&quot;
  
<span class="line-new-header">--- 322,11 ---</span>
      });
      RELEASE_ASSERT(!!codeBlock);
      RELEASE_ASSERT_WITH_MESSAGE(false, &quot;JS assertion failed at line %u in:\n%s\n&quot;, line, codeBlock-&gt;sourceCodeForTools().data());
      return JSValue::encode(jsUndefined());
  }
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
  
  } // namespace JSC
  
  #include &quot;JSGlobalObject.lut.h&quot;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 387,34 ***</span>
    Float64Array          JSGlobalObject::m_typedArrayFloat64          DontEnum|ClassStructure
    DataView              JSGlobalObject::m_typedArrayDataView         DontEnum|ClassStructure
    Date                  JSGlobalObject::m_dateStructure              DontEnum|ClassStructure
    Error                 JSGlobalObject::m_errorStructure             DontEnum|ClassStructure
    Boolean               JSGlobalObject::m_booleanObjectStructure     DontEnum|ClassStructure
    Number                JSGlobalObject::m_numberObjectStructure      DontEnum|ClassStructure
    Symbol                JSGlobalObject::m_symbolObjectStructure      DontEnum|ClassStructure
    WeakMap               JSGlobalObject::m_weakMapStructure           DontEnum|ClassStructure
    WeakSet               JSGlobalObject::m_weakSetStructure           DontEnum|ClassStructure
  @end
  */
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL enqueueJob(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
  
<span class="line-modified">!     JSValue job = exec-&gt;argument(0);</span>
<span class="line-modified">!     JSValue arguments = exec-&gt;argument(1);</span>
<span class="line-modified">!     ASSERT(arguments.inherits&lt;JSArray&gt;(vm));</span>
  
<span class="line-modified">!     globalObject-&gt;queueMicrotask(createJSMicrotask(vm, job, jsCast&lt;JSArray*&gt;(arguments)));</span>
  
      return JSValue::encode(jsUndefined());
  }
  
  JSGlobalObject::JSGlobalObject(VM&amp; vm, Structure* structure, const GlobalObjectMethodTable* globalObjectMethodTable)
      : Base(vm, structure, 0)
<span class="line-modified">!     , m_vm(vm)</span>
      , m_masqueradesAsUndefinedWatchpoint(adoptRef(new WatchpointSet(IsWatched)))
      , m_havingABadTimeWatchpoint(adoptRef(new WatchpointSet(IsWatched)))
      , m_varInjectionWatchpoint(adoptRef(new WatchpointSet(IsWatched)))
      , m_weakRandom(Options::forceWeakRandomSeed() ? Options::forcedWeakRandomSeed() : static_cast&lt;unsigned&gt;(randomNumber() * (std::numeric_limits&lt;unsigned&gt;::max() + 1.0)))
      , m_arrayIteratorProtocolWatchpointSet(IsWatched)
<span class="line-new-header">--- 388,37 ---</span>
    Float64Array          JSGlobalObject::m_typedArrayFloat64          DontEnum|ClassStructure
    DataView              JSGlobalObject::m_typedArrayDataView         DontEnum|ClassStructure
    Date                  JSGlobalObject::m_dateStructure              DontEnum|ClassStructure
    Error                 JSGlobalObject::m_errorStructure             DontEnum|ClassStructure
    Boolean               JSGlobalObject::m_booleanObjectStructure     DontEnum|ClassStructure
<span class="line-added">+   Map                   JSGlobalObject::m_mapStructure               DontEnum|ClassStructure</span>
    Number                JSGlobalObject::m_numberObjectStructure      DontEnum|ClassStructure
<span class="line-added">+   Set                   JSGlobalObject::m_setStructure               DontEnum|ClassStructure</span>
    Symbol                JSGlobalObject::m_symbolObjectStructure      DontEnum|ClassStructure
    WeakMap               JSGlobalObject::m_weakMapStructure           DontEnum|ClassStructure
    WeakSet               JSGlobalObject::m_weakSetStructure           DontEnum|ClassStructure
  @end
  */
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL enqueueJob(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
<span class="line-modified">!     JSValue job = callFrame-&gt;argument(0);</span>
<span class="line-modified">!     JSValue argument0 = callFrame-&gt;argument(1);</span>
<span class="line-modified">!     JSValue argument1 = callFrame-&gt;argument(2);</span>
<span class="line-added">+     JSValue argument2 = callFrame-&gt;argument(3);</span>
  
<span class="line-modified">!     globalObject-&gt;queueMicrotask(createJSMicrotask(vm, job, argument0, argument1, argument2));</span>
  
      return JSValue::encode(jsUndefined());
  }
  
  JSGlobalObject::JSGlobalObject(VM&amp; vm, Structure* structure, const GlobalObjectMethodTable* globalObjectMethodTable)
      : Base(vm, structure, 0)
<span class="line-modified">!     , m_vm(&amp;vm)</span>
<span class="line-added">+     , m_linkTimeConstants(numberOfLinkTimeConstants)</span>
      , m_masqueradesAsUndefinedWatchpoint(adoptRef(new WatchpointSet(IsWatched)))
      , m_havingABadTimeWatchpoint(adoptRef(new WatchpointSet(IsWatched)))
      , m_varInjectionWatchpoint(adoptRef(new WatchpointSet(IsWatched)))
      , m_weakRandom(Options::forceWeakRandomSeed() ? Options::forcedWeakRandomSeed() : static_cast&lt;unsigned&gt;(randomNumber() * (std::numeric_limits&lt;unsigned&gt;::max() + 1.0)))
      , m_arrayIteratorProtocolWatchpointSet(IsWatched)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 450,16 ***</span>
  void JSGlobalObject::setGlobalThis(VM&amp; vm, JSObject* globalThis)
  {
      m_globalThis.set(vm, this, globalThis);
  }
  
<span class="line-modified">! static JSObject* getGetterById(ExecState* exec, JSObject* base, const Identifier&amp; ident)</span>
  {
      JSValue baseValue = JSValue(base);
      PropertySlot slot(baseValue, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!     baseValue.getPropertySlot(exec, ident, slot);</span>
<span class="line-modified">!     return slot.getPureResult().toObject(exec);</span>
  }
  
  template&lt;ErrorType errorType&gt;
  void JSGlobalObject::initializeErrorConstructor(LazyClassStructure::Initializer&amp; init)
  {
<span class="line-new-header">--- 454,39 ---</span>
  void JSGlobalObject::setGlobalThis(VM&amp; vm, JSObject* globalThis)
  {
      m_globalThis.set(vm, this, globalThis);
  }
  
<span class="line-modified">! static GetterSetter* getGetterById(JSGlobalObject* globalObject, JSObject* base, const Identifier&amp; ident)</span>
  {
      JSValue baseValue = JSValue(base);
      PropertySlot slot(baseValue, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!     baseValue.getPropertySlot(globalObject, ident, slot);</span>
<span class="line-modified">!     return jsCast&lt;GetterSetter*&gt;(slot.getPureResult());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static ObjectPropertyCondition setupAdaptiveWatchpoint(JSGlobalObject* globalObject, JSObject* base, const Identifier&amp; ident)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // Performing these gets should not throw.</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     auto catchScope = DECLARE_CATCH_SCOPE(vm);</span>
<span class="line-added">+     PropertySlot slot(base, PropertySlot::InternalMethodType::Get);</span>
<span class="line-added">+     bool result = base-&gt;getOwnPropertySlot(base, globalObject, ident, slot);</span>
<span class="line-added">+     ASSERT_UNUSED(result, result);</span>
<span class="line-added">+     catchScope.assertNoException();</span>
<span class="line-added">+     RELEASE_ASSERT(slot.isCacheableValue());</span>
<span class="line-added">+     JSValue functionValue = slot.getValue(globalObject, ident);</span>
<span class="line-added">+     catchScope.assertNoException();</span>
<span class="line-added">+     ASSERT(jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue));</span>
<span class="line-added">+ </span>
<span class="line-added">+     ObjectPropertyCondition condition = generateConditionForSelfEquivalence(vm, nullptr, base, ident.impl());</span>
<span class="line-added">+     RELEASE_ASSERT(condition.requiredValue() == functionValue);</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool isWatchable = condition.isWatchable(PropertyCondition::EnsureWatchability);</span>
<span class="line-added">+     RELEASE_ASSERT(isWatchable); // We allow this to install the necessary watchpoints.</span>
<span class="line-added">+ </span>
<span class="line-added">+     return condition;</span>
  }
  
  template&lt;ErrorType errorType&gt;
  void JSGlobalObject::initializeErrorConstructor(LazyClassStructure::Initializer&amp; init)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 486,16 ***</span>
  
      m_functionPrototype.set(vm, this, FunctionPrototype::create(vm, FunctionPrototype::createStructure(vm, this, jsNull()))); // The real prototype will be set once ObjectPrototype is created.
      m_calleeStructure.set(vm, this, JSCallee::createStructure(vm, this, jsNull()));
  
      m_globalLexicalEnvironment.set(vm, this, JSGlobalLexicalEnvironment::create(vm, JSGlobalLexicalEnvironment::createStructure(vm, this), this));
      // Need to create the callee structure (above) before creating the callee.
      JSCallee* globalCallee = JSCallee::create(vm, this, globalScope());
      m_globalCallee.set(vm, this, globalCallee);
  
<span class="line-modified">!     ExecState::initGlobalExec(JSGlobalObject::globalExec(), globalCallee);</span>
<span class="line-removed">-     ExecState* exec = JSGlobalObject::globalExec();</span>
  
      JSCallee* stackOverflowFrameCallee = JSCallee::create(vm, this, globalScope());
      m_stackOverflowFrameCallee.set(vm, this, stackOverflowFrameCallee);
  
      m_hostFunctionStructure.set(vm, this, JSFunction::createStructure(vm, this, m_functionPrototype.get()));
<span class="line-new-header">--- 513,16 ---</span>
  
      m_functionPrototype.set(vm, this, FunctionPrototype::create(vm, FunctionPrototype::createStructure(vm, this, jsNull()))); // The real prototype will be set once ObjectPrototype is created.
      m_calleeStructure.set(vm, this, JSCallee::createStructure(vm, this, jsNull()));
  
      m_globalLexicalEnvironment.set(vm, this, JSGlobalLexicalEnvironment::create(vm, JSGlobalLexicalEnvironment::createStructure(vm, this), this));
<span class="line-added">+ </span>
      // Need to create the callee structure (above) before creating the callee.
      JSCallee* globalCallee = JSCallee::create(vm, this, globalScope());
      m_globalCallee.set(vm, this, globalCallee);
  
<span class="line-modified">!     CallFrame::initDeprecatedCallFrameForDebugger(JSGlobalObject::deprecatedCallFrameForDebugger(), globalCallee);</span>
  
      JSCallee* stackOverflowFrameCallee = JSCallee::create(vm, this, globalScope());
      m_stackOverflowFrameCallee.set(vm, this, stackOverflowFrameCallee);
  
      m_hostFunctionStructure.set(vm, this, JSFunction::createStructure(vm, this, m_functionPrototype.get()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 514,32 ***</span>
          });
      m_boundFunctionStructure.initLater(
          [] (const Initializer&lt;Structure&gt;&amp; init) {
              init.set(JSBoundFunction::createStructure(init.vm, init.owner, init.owner-&gt;m_functionPrototype.get()));
          });
<span class="line-removed">-     m_getterSetterStructure.set(vm, this, GetterSetter::createStructure(vm, this, jsNull()));</span>
      m_nativeStdFunctionStructure.initLater(
          [] (const Initializer&lt;Structure&gt;&amp; init) {
              init.set(JSNativeStdFunction::createStructure(init.vm, init.owner, init.owner-&gt;m_functionPrototype.get()));
          });
      JSFunction* callFunction = nullptr;
      JSFunction* applyFunction = nullptr;
      JSFunction* hasInstanceSymbolFunction = nullptr;
      m_functionPrototype-&gt;addFunctionProperties(vm, this, &amp;callFunction, &amp;applyFunction, &amp;hasInstanceSymbolFunction);
<span class="line-removed">-     m_callFunction.set(vm, this, callFunction);</span>
<span class="line-removed">-     m_applyFunction.set(vm, this, applyFunction);</span>
      m_arrayProtoToStringFunction.initLater(
          [] (const Initializer&lt;JSFunction&gt;&amp; init) {
              init.set(JSFunction::create(init.vm, init.owner, 0, init.vm.propertyNames-&gt;toString.string(), arrayProtoFuncToString, NoIntrinsic));
          });
      m_arrayProtoValuesFunction.initLater(
          [] (const Initializer&lt;JSFunction&gt;&amp; init) {
<span class="line-modified">!             init.set(JSFunction::create(init.vm, arrayPrototypeValuesCodeGenerator(init.vm), init.owner));</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-     m_initializePromiseFunction.initLater(</span>
<span class="line-removed">-         [] (const Initializer&lt;JSFunction&gt;&amp; init) {</span>
<span class="line-removed">-             init.set(JSFunction::create(init.vm, promiseOperationsInitializePromiseCodeGenerator(init.vm), init.owner));</span>
          });
  
      m_iteratorProtocolFunction.initLater(
          [] (const Initializer&lt;JSFunction&gt;&amp; init) {
              init.set(JSFunction::create(init.vm, iteratorHelpersPerformIterationCodeGenerator(init.vm), init.owner));
<span class="line-new-header">--- 541,25 ---</span>
          });
      m_boundFunctionStructure.initLater(
          [] (const Initializer&lt;Structure&gt;&amp; init) {
              init.set(JSBoundFunction::createStructure(init.vm, init.owner, init.owner-&gt;m_functionPrototype.get()));
          });
      m_nativeStdFunctionStructure.initLater(
          [] (const Initializer&lt;Structure&gt;&amp; init) {
              init.set(JSNativeStdFunction::createStructure(init.vm, init.owner, init.owner-&gt;m_functionPrototype.get()));
          });
      JSFunction* callFunction = nullptr;
      JSFunction* applyFunction = nullptr;
      JSFunction* hasInstanceSymbolFunction = nullptr;
      m_functionPrototype-&gt;addFunctionProperties(vm, this, &amp;callFunction, &amp;applyFunction, &amp;hasInstanceSymbolFunction);
      m_arrayProtoToStringFunction.initLater(
          [] (const Initializer&lt;JSFunction&gt;&amp; init) {
              init.set(JSFunction::create(init.vm, init.owner, 0, init.vm.propertyNames-&gt;toString.string(), arrayProtoFuncToString, NoIntrinsic));
          });
      m_arrayProtoValuesFunction.initLater(
          [] (const Initializer&lt;JSFunction&gt;&amp; init) {
<span class="line-modified">!             init.set(JSFunction::create(init.vm, init.owner, 0, init.vm.propertyNames-&gt;values.string(), arrayProtoFuncValues, ArrayValuesIntrinsic));</span>
          });
  
      m_iteratorProtocolFunction.initLater(
          [] (const Initializer&lt;JSFunction&gt;&amp; init) {
              init.set(JSFunction::create(init.vm, iteratorHelpersPerformIterationCodeGenerator(init.vm), init.owner));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 548,11 ***</span>
      m_promiseResolveFunction.initLater(
          [] (const Initializer&lt;JSFunction&gt;&amp; init) {
              init.set(JSFunction::create(init.vm, promiseConstructorResolveCodeGenerator(init.vm), init.owner));
          });
  
<span class="line-modified">!     m_newPromiseCapabilityFunction.set(vm, this, JSFunction::create(vm, promiseOperationsNewPromiseCapabilityCodeGenerator(vm), this));</span>
      m_functionProtoHasInstanceSymbolFunction.set(vm, this, hasInstanceSymbolFunction);
      m_throwTypeErrorGetterSetter.initLater(
          [] (const Initializer&lt;GetterSetter&gt;&amp; init) {
              JSFunction* thrower = init.owner-&gt;throwTypeErrorFunction();
              GetterSetter* getterSetter = GetterSetter::create(init.vm, init.owner, thrower, thrower);
<span class="line-new-header">--- 568,15 ---</span>
      m_promiseResolveFunction.initLater(
          [] (const Initializer&lt;JSFunction&gt;&amp; init) {
              init.set(JSFunction::create(init.vm, promiseConstructorResolveCodeGenerator(init.vm), init.owner));
          });
  
<span class="line-modified">!     m_numberProtoToStringFunction.initLater(</span>
<span class="line-added">+         [] (const Initializer&lt;JSFunction&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 1, init.vm.propertyNames-&gt;toString.string(), numberProtoFuncToString, NumberPrototypeToStringIntrinsic));</span>
<span class="line-added">+         });</span>
<span class="line-added">+ </span>
      m_functionProtoHasInstanceSymbolFunction.set(vm, this, hasInstanceSymbolFunction);
      m_throwTypeErrorGetterSetter.initLater(
          [] (const Initializer&lt;GetterSetter&gt;&amp; init) {
              JSFunction* thrower = init.owner-&gt;throwTypeErrorFunction();
              GetterSetter* getterSetter = GetterSetter::create(init.vm, init.owner, thrower, thrower);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 599,11 ***</span>
      m_typedArray ## type.initLater( \
          [] (LazyClassStructure::Initializer&amp; init) { \
              init.setPrototype(JS ## type ## ArrayPrototype::create(init.vm, init.global, JS ## type ## ArrayPrototype::createStructure(init.vm, init.global, init.global-&gt;m_typedArrayProto.get(init.global)))); \
              init.setStructure(JS ## type ## Array::createStructure(init.vm, init.global, init.prototype)); \
              init.setConstructor(JS ## type ## ArrayConstructor::create(init.vm, init.global, JS ## type ## ArrayConstructor::createStructure(init.vm, init.global, init.global-&gt;m_typedArraySuperConstructor.get(init.global)), init.prototype, #type &quot;Array&quot;_s, typedArrayConstructorAllocate ## type ## ArrayCodeGenerator(init.vm))); \
<span class="line-modified">!             init.global-&gt;putDirectWithoutTransition(init.vm, init.vm.propertyNames-&gt;builtinNames().type ## ArrayPrivateName(), init.constructor, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum)); \</span>
          });
      FOR_EACH_TYPED_ARRAY_TYPE_EXCLUDING_DATA_VIEW(INIT_TYPED_ARRAY_LATER)
  #undef INIT_TYPED_ARRAY_LATER
  
      m_typedArrayDataView.initLater(
<span class="line-new-header">--- 623,11 ---</span>
      m_typedArray ## type.initLater( \
          [] (LazyClassStructure::Initializer&amp; init) { \
              init.setPrototype(JS ## type ## ArrayPrototype::create(init.vm, init.global, JS ## type ## ArrayPrototype::createStructure(init.vm, init.global, init.global-&gt;m_typedArrayProto.get(init.global)))); \
              init.setStructure(JS ## type ## Array::createStructure(init.vm, init.global, init.prototype)); \
              init.setConstructor(JS ## type ## ArrayConstructor::create(init.vm, init.global, JS ## type ## ArrayConstructor::createStructure(init.vm, init.global, init.global-&gt;m_typedArraySuperConstructor.get(init.global)), init.prototype, #type &quot;Array&quot;_s, typedArrayConstructorAllocate ## type ## ArrayCodeGenerator(init.vm))); \
<span class="line-modified">!             init.global-&gt;putDirect(init.vm, init.vm.propertyNames-&gt;builtinNames().type ## ArrayPrivateName(), init.constructor, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum)); \</span>
          });
      FOR_EACH_TYPED_ARRAY_TYPE_EXCLUDING_DATA_VIEW(INIT_TYPED_ARRAY_LATER)
  #undef INIT_TYPED_ARRAY_LATER
  
      m_typedArrayDataView.initLater(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 644,11 ***</span>
          [] (const Initializer&lt;Structure&gt;&amp; init) {
              init.set(JSCallbackConstructor::createStructure(init.vm, init.owner, init.owner-&gt;m_objectPrototype.get()));
          });
      m_callbackObjectStructure.initLater(
          [] (const Initializer&lt;Structure&gt;&amp; init) {
<span class="line-modified">!             init.set(JSCallbackObject&lt;JSDestructibleObject&gt;::createStructure(init.vm, init.owner, init.owner-&gt;m_objectPrototype.get()));</span>
          });
  
  #if JSC_OBJC_API_ENABLED
      m_objcCallbackFunctionStructure.initLater(
          [] (const Initializer&lt;Structure&gt;&amp; init) {
<span class="line-new-header">--- 668,11 ---</span>
          [] (const Initializer&lt;Structure&gt;&amp; init) {
              init.set(JSCallbackConstructor::createStructure(init.vm, init.owner, init.owner-&gt;m_objectPrototype.get()));
          });
      m_callbackObjectStructure.initLater(
          [] (const Initializer&lt;Structure&gt;&amp; init) {
<span class="line-modified">!             init.set(JSCallbackObject&lt;JSNonFinalObject&gt;::createStructure(init.vm, init.owner, init.owner-&gt;m_objectPrototype.get()));</span>
          });
  
  #if JSC_OBJC_API_ENABLED
      m_objcCallbackFunctionStructure.initLater(
          [] (const Initializer&lt;Structure&gt;&amp; init) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 684,11 ***</span>
          m_arrayStructureForIndexingShapeDuringAllocation[i] = m_originalArrayStructureForIndexingShape[i];
  
      m_regExpPrototype.set(vm, this, RegExpPrototype::create(vm, this, RegExpPrototype::createStructure(vm, this, m_objectPrototype.get())));
      m_regExpStructure.set(vm, this, RegExpObject::createStructure(vm, this, m_regExpPrototype.get()));
      m_regExpMatchesArrayStructure.set(vm, this, createRegExpMatchesArrayStructure(vm, this));
<span class="line-removed">-     m_regExpMatchesArrayWithGroupsStructure.set(vm, this, createRegExpMatchesArrayWithGroupsStructure(vm, this));</span>
  
      m_moduleRecordStructure.initLater(
          [] (const Initializer&lt;Structure&gt;&amp; init) {
              init.set(JSModuleRecord::createStructure(init.vm, init.owner, jsNull()));
          });
<span class="line-new-header">--- 708,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 729,10 ***</span>
<span class="line-new-header">--- 752,17 ---</span>
      m_asyncIteratorPrototype.set(vm, this, AsyncIteratorPrototype::create(vm, this, AsyncIteratorPrototype::createStructure(vm, this, m_objectPrototype.get())));
  
      m_generatorPrototype.set(vm, this, GeneratorPrototype::create(vm, this, GeneratorPrototype::createStructure(vm, this, m_iteratorPrototype.get())));
      m_asyncGeneratorPrototype.set(vm, this, AsyncGeneratorPrototype::create(vm, this, AsyncGeneratorPrototype::createStructure(vm, this, m_asyncIteratorPrototype.get())));
  
<span class="line-added">+     auto* arrayIteratorPrototype = ArrayIteratorPrototype::create(vm, this, ArrayIteratorPrototype::createStructure(vm, this, m_iteratorPrototype.get()));</span>
<span class="line-added">+     m_arrayIteratorPrototype.set(vm, this, arrayIteratorPrototype);</span>
<span class="line-added">+     m_arrayIteratorStructure.set(vm, this, JSArrayIterator::createStructure(vm, this, arrayIteratorPrototype));</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSFunction* defaultPromiseThen = JSFunction::create(vm, promisePrototypeThenCodeGenerator(vm), this);</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::defaultPromiseThen)].set(vm, this, defaultPromiseThen);</span>
<span class="line-added">+ </span>
  #define CREATE_PROTOTYPE_FOR_SIMPLE_TYPE(capitalName, lowerName, properName, instanceType, jsName, prototypeBase, featureFlag) if (featureFlag) { \
          m_ ## lowerName ## Prototype.set(vm, this, capitalName##Prototype::create(vm, this, capitalName##Prototype::createStructure(vm, this, m_ ## prototypeBase ## Prototype.get()))); \
          m_ ## properName ## Structure.set(vm, this, instanceType::createStructure(vm, this, m_ ## lowerName ## Prototype.get())); \
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 754,20 ***</span>
  
      // Constructors
  
      ObjectConstructor* objectConstructor = ObjectConstructor::create(vm, this, ObjectConstructor::createStructure(vm, this, m_functionPrototype.get()), m_objectPrototype.get());
      m_objectConstructor.set(vm, this, objectConstructor);
  
      JSFunction* throwTypeErrorFunction = JSFunction::create(vm, this, 0, String(), globalFuncThrowTypeError);
<span class="line-modified">!     m_throwTypeErrorFunction.set(vm, this, throwTypeErrorFunction);</span>
  
<span class="line-modified">!     JSCell* functionConstructor = FunctionConstructor::create(vm, FunctionConstructor::createStructure(vm, this, m_functionPrototype.get()), m_functionPrototype.get());</span>
  
      ArrayConstructor* arrayConstructor = ArrayConstructor::create(vm, this, ArrayConstructor::createStructure(vm, this, m_functionPrototype.get()), m_arrayPrototype.get(), m_speciesGetterSetter.get());
      m_arrayConstructor.set(vm, this, arrayConstructor);
  
      RegExpConstructor* regExpConstructor = RegExpConstructor::create(vm, RegExpConstructor::createStructure(vm, this, m_functionPrototype.get()), m_regExpPrototype.get(), m_speciesGetterSetter.get());
      m_regExpGlobalData.cachedResult().record(vm, this, nullptr, jsEmptyString(vm), MatchResult(0, 0));
  
  #if ENABLE(SHARED_ARRAY_BUFFER)
      JSSharedArrayBufferConstructor* sharedArrayBufferConstructor = nullptr;
      sharedArrayBufferConstructor = JSSharedArrayBufferConstructor::create(vm, JSSharedArrayBufferConstructor::createStructure(vm, this, m_functionPrototype.get()), m_sharedArrayBufferPrototype.get(), m_speciesGetterSetter.get());
<span class="line-new-header">--- 784,25 ---</span>
  
      // Constructors
  
      ObjectConstructor* objectConstructor = ObjectConstructor::create(vm, this, ObjectConstructor::createStructure(vm, this, m_functionPrototype.get()), m_objectPrototype.get());
      m_objectConstructor.set(vm, this, objectConstructor);
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::Object)].set(vm, this, objectConstructor);</span>
  
      JSFunction* throwTypeErrorFunction = JSFunction::create(vm, this, 0, String(), globalFuncThrowTypeError);
<span class="line-modified">!     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::throwTypeErrorFunction)].set(vm, this, throwTypeErrorFunction);</span>
  
<span class="line-modified">!     FunctionConstructor* functionConstructor = FunctionConstructor::create(vm, FunctionConstructor::createStructure(vm, this, m_functionPrototype.get()), m_functionPrototype.get());</span>
<span class="line-added">+     m_functionConstructor.set(vm, this, functionConstructor);</span>
  
      ArrayConstructor* arrayConstructor = ArrayConstructor::create(vm, this, ArrayConstructor::createStructure(vm, this, m_functionPrototype.get()), m_arrayPrototype.get(), m_speciesGetterSetter.get());
      m_arrayConstructor.set(vm, this, arrayConstructor);
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::Array)].set(vm, this, arrayConstructor);</span>
  
      RegExpConstructor* regExpConstructor = RegExpConstructor::create(vm, RegExpConstructor::createStructure(vm, this, m_functionPrototype.get()), m_regExpPrototype.get(), m_speciesGetterSetter.get());
<span class="line-added">+     m_regExpConstructor.set(vm, this, regExpConstructor);</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::RegExp)].set(vm, this, regExpConstructor);</span>
      m_regExpGlobalData.cachedResult().record(vm, this, nullptr, jsEmptyString(vm), MatchResult(0, 0));
  
  #if ENABLE(SHARED_ARRAY_BUFFER)
      JSSharedArrayBufferConstructor* sharedArrayBufferConstructor = nullptr;
      sharedArrayBufferConstructor = JSSharedArrayBufferConstructor::create(vm, JSSharedArrayBufferConstructor::createStructure(vm, this, m_functionPrototype.get()), m_sharedArrayBufferPrototype.get(), m_speciesGetterSetter.get());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 785,10 ***</span>
<span class="line-new-header">--- 820,12 ---</span>
  
  #undef CREATE_CONSTRUCTOR_FOR_SIMPLE_TYPE
  
      m_promiseConstructor.set(vm, this, promiseConstructor);
      m_internalPromiseConstructor.set(vm, this, internalPromiseConstructor);
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::Promise)].set(vm, this, promiseConstructor);</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::InternalPromise)].set(vm, this, internalPromiseConstructor);</span>
  
      m_evalErrorStructure.initLater(
          [] (LazyClassStructure::Initializer&amp; init) {
              init.global-&gt;initializeErrorConstructor&lt;ErrorType::EvalError&gt;(init);
          });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 818,10 ***</span>
<span class="line-new-header">--- 855,11 ---</span>
      m_generatorFunctionPrototype-&gt;putDirectWithoutTransition(vm, vm.propertyNames-&gt;constructor, generatorFunctionConstructor, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
      m_generatorFunctionStructure.set(vm, this, JSGeneratorFunction::createStructure(vm, this, m_generatorFunctionPrototype.get()));
  
      m_generatorPrototype-&gt;putDirectWithoutTransition(vm, vm.propertyNames-&gt;constructor, m_generatorFunctionPrototype.get(), PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
      m_generatorFunctionPrototype-&gt;putDirectWithoutTransition(vm, vm.propertyNames-&gt;prototype, m_generatorPrototype.get(), PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
<span class="line-added">+     m_generatorStructure.set(vm, this, JSGenerator::createStructure(vm, this, m_generatorPrototype.get()));</span>
  
      m_asyncFunctionPrototype.set(vm, this, AsyncFunctionPrototype::create(vm, AsyncFunctionPrototype::createStructure(vm, this, m_functionPrototype.get())));
      AsyncFunctionConstructor* asyncFunctionConstructor = AsyncFunctionConstructor::create(vm, AsyncFunctionConstructor::createStructure(vm, this, functionConstructor), m_asyncFunctionPrototype.get());
      m_asyncFunctionPrototype-&gt;putDirectWithoutTransition(vm, vm.propertyNames-&gt;constructor, asyncFunctionConstructor, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
      m_asyncFunctionStructure.set(vm, this, JSAsyncFunction::createStructure(vm, this, m_asyncFunctionPrototype.get()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 831,10 ***</span>
<span class="line-new-header">--- 869,11 ---</span>
      m_asyncGeneratorFunctionPrototype-&gt;putDirectWithoutTransition(vm, vm.propertyNames-&gt;constructor, asyncGeneratorFunctionConstructor, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
      m_asyncGeneratorFunctionStructure.set(vm, this, JSAsyncGeneratorFunction::createStructure(vm, this, m_asyncGeneratorFunctionPrototype.get()));
  
      m_asyncGeneratorPrototype-&gt;putDirectWithoutTransition(vm, vm.propertyNames-&gt;constructor, m_asyncGeneratorFunctionPrototype.get(), PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
      m_asyncGeneratorFunctionPrototype-&gt;putDirectWithoutTransition(vm, vm.propertyNames-&gt;prototype, m_asyncGeneratorPrototype.get(), PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
<span class="line-added">+     m_asyncGeneratorStructure.set(vm, this, JSAsyncGenerator::createStructure(vm, this, m_asyncGeneratorPrototype.get()));</span>
  
      m_objectPrototype-&gt;putDirectWithoutTransition(vm, vm.propertyNames-&gt;constructor, objectConstructor, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      m_functionPrototype-&gt;putDirectWithoutTransition(vm, vm.propertyNames-&gt;constructor, functionConstructor, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      m_arrayPrototype-&gt;putDirectWithoutTransition(vm, vm.propertyNames-&gt;constructor, arrayConstructor, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      m_regExpPrototype-&gt;putDirectWithoutTransition(vm, vm.propertyNames-&gt;constructor, regExpConstructor, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 842,13 ***</span>
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;Object, objectConstructor, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;Function, functionConstructor, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;Array, arrayConstructor, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;RegExp, regExpConstructor, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  
<span class="line-removed">-     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().ObjectPrivateName(), objectConstructor, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);</span>
<span class="line-removed">-     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().ArrayPrivateName(), arrayConstructor, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);</span>
<span class="line-removed">- </span>
  #if ENABLE(SHARED_ARRAY_BUFFER)
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;SharedArrayBuffer, sharedArrayBufferConstructor, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;Atomics&quot;), atomicsObject, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  #endif
  
<span class="line-new-header">--- 881,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 893,192 ***</span>
          [] (const Initializer&lt;Structure&gt;&amp; init) {
              JSGlobalObject* globalObject = jsCast&lt;JSGlobalObject*&gt;(init.owner);
              IntlPluralRulesPrototype* pluralRulesPrototype = IntlPluralRulesPrototype::create(init.vm, globalObject, IntlPluralRulesPrototype::createStructure(init.vm, globalObject, globalObject-&gt;objectPrototype()));
              init.set(IntlPluralRules::createStructure(init.vm, globalObject, pluralRulesPrototype));
          });
  
      IntlObject* intl = IntlObject::create(vm, IntlObject::createStructure(vm, this, m_objectPrototype.get()));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;Intl, intl, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  #endif // ENABLE(INTL)
  
      m_moduleLoader.initLater(
          [] (const Initializer&lt;JSModuleLoader&gt;&amp; init) {
              auto catchScope = DECLARE_CATCH_SCOPE(init.vm);
<span class="line-modified">!             init.set(JSModuleLoader::create(init.owner-&gt;globalExec(), init.vm, init.owner, JSModuleLoader::createStructure(init.vm, init.owner, jsNull())));</span>
              catchScope.releaseAssertNoException();
          });
      if (Options::exposeInternalModuleLoader())
          putDirectWithoutTransition(vm, vm.propertyNames-&gt;Loader, moduleLoader(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  
<span class="line-modified">!     JSFunction* builtinLog = JSFunction::create(vm, this, 1, vm.propertyNames-&gt;emptyIdentifier.string(), globalFuncBuiltinLog);</span>
<span class="line-removed">-     JSFunction* builtinDescribe = JSFunction::create(vm, this, 1, vm.propertyNames-&gt;emptyIdentifier.string(), globalFuncBuiltinDescribe);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JSFunction* privateFuncTrunc = JSFunction::create(vm, this, 0, String(), mathProtoFuncTrunc, TruncIntrinsic);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JSFunction* privateFuncPropertyIsEnumerable = JSFunction::create(vm, this, 0, String(), globalFuncPropertyIsEnumerable);</span>
<span class="line-removed">-     JSFunction* privateFuncOwnKeys = JSFunction::create(vm, this, 0, String(), globalFuncOwnKeys);</span>
<span class="line-removed">-     JSFunction* privateFuncImportModule = JSFunction::create(vm, this, 0, String(), globalFuncImportModule);</span>
<span class="line-removed">-     JSFunction* privateFuncMakeTypeError = JSFunction::create(vm, this, 0, String(), globalFuncMakeTypeError);</span>
<span class="line-removed">-     JSFunction* privateFuncTypedArrayLength = JSFunction::create(vm, this, 0, String(), typedArrayViewPrivateFuncLength);</span>
<span class="line-removed">-     JSFunction* privateFuncTypedArrayGetOriginalConstructor = JSFunction::create(vm, this, 0, String(), typedArrayViewPrivateFuncGetOriginalConstructor);</span>
<span class="line-removed">-     JSFunction* privateFuncTypedArraySort = JSFunction::create(vm, this, 0, String(), typedArrayViewPrivateFuncSort);</span>
<span class="line-removed">-     JSFunction* privateFuncIsTypedArrayView = JSFunction::create(vm, this, 0, String(), typedArrayViewPrivateFuncIsTypedArrayView, IsTypedArrayViewIntrinsic);</span>
<span class="line-removed">-     JSFunction* privateFuncTypedArraySubarrayCreate = JSFunction::create(vm, this, 0, String(), typedArrayViewPrivateFuncSubarrayCreate);</span>
<span class="line-removed">-     JSFunction* privateFuncIsBoundFunction = JSFunction::create(vm, this, 0, String(), isBoundFunction);</span>
<span class="line-removed">-     JSFunction* privateFuncHasInstanceBoundFunction = JSFunction::create(vm, this, 0, String(), hasInstanceBoundFunction);</span>
<span class="line-removed">-     JSFunction* privateFuncInstanceOf = JSFunction::create(vm, this, 0, String(), objectPrivateFuncInstanceOf);</span>
<span class="line-removed">-     JSFunction* privateFuncThisTimeValue = JSFunction::create(vm, this, 0, String(), dateProtoFuncGetTime);</span>
<span class="line-removed">- #if ENABLE(INTL)</span>
<span class="line-removed">-     JSFunction* privateFuncDateTimeFormat = JSFunction::create(vm, this, 0, String(), globalFuncDateTimeFormat);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     JSFunction* privateFuncIsArraySlow = JSFunction::create(vm, this, 0, String(), arrayConstructorPrivateFuncIsArraySlow);</span>
<span class="line-removed">-     JSFunction* privateFuncConcatMemcpy = JSFunction::create(vm, this, 0, String(), arrayProtoPrivateFuncConcatMemcpy);</span>
<span class="line-removed">-     JSFunction* privateFuncAppendMemcpy = JSFunction::create(vm, this, 0, String(), arrayProtoPrivateFuncAppendMemcpy);</span>
<span class="line-removed">-     JSFunction* privateFuncMapBucketHead = JSFunction::create(vm, this, 0, String(), mapPrivateFuncMapBucketHead, JSMapBucketHeadIntrinsic);</span>
<span class="line-removed">-     JSFunction* privateFuncMapBucketNext = JSFunction::create(vm, this, 0, String(), mapPrivateFuncMapBucketNext, JSMapBucketNextIntrinsic);</span>
<span class="line-removed">-     JSFunction* privateFuncMapBucketKey = JSFunction::create(vm, this, 0, String(), mapPrivateFuncMapBucketKey, JSMapBucketKeyIntrinsic);</span>
<span class="line-removed">-     JSFunction* privateFuncMapBucketValue = JSFunction::create(vm, this, 0, String(), mapPrivateFuncMapBucketValue, JSMapBucketValueIntrinsic);</span>
<span class="line-removed">-     JSFunction* privateFuncSetBucketHead = JSFunction::create(vm, this, 0, String(), setPrivateFuncSetBucketHead, JSSetBucketHeadIntrinsic);</span>
<span class="line-removed">-     JSFunction* privateFuncSetBucketNext = JSFunction::create(vm, this, 0, String(), setPrivateFuncSetBucketNext, JSSetBucketNextIntrinsic);</span>
<span class="line-removed">-     JSFunction* privateFuncSetBucketKey = JSFunction::create(vm, this, 0, String(), setPrivateFuncSetBucketKey, JSSetBucketKeyIntrinsic);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JSObject* regExpProtoFlagsGetterObject = getGetterById(exec, m_regExpPrototype.get(), vm.propertyNames-&gt;flags);</span>
      catchScope.assertNoException();
<span class="line-modified">!     JSObject* regExpProtoGlobalGetterObject = getGetterById(exec, m_regExpPrototype.get(), vm.propertyNames-&gt;global);</span>
      catchScope.assertNoException();
<span class="line-modified">!     m_regExpProtoGlobalGetter.set(vm, this, regExpProtoGlobalGetterObject);</span>
<span class="line-modified">!     JSObject* regExpProtoIgnoreCaseGetterObject = getGetterById(exec, m_regExpPrototype.get(), vm.propertyNames-&gt;ignoreCase);</span>
      catchScope.assertNoException();
<span class="line-modified">!     JSObject* regExpProtoMultilineGetterObject = getGetterById(exec, m_regExpPrototype.get(), vm.propertyNames-&gt;multiline);</span>
      catchScope.assertNoException();
<span class="line-modified">!     JSObject* regExpProtoSourceGetterObject = getGetterById(exec, m_regExpPrototype.get(), vm.propertyNames-&gt;source);</span>
      catchScope.assertNoException();
<span class="line-modified">!     JSObject* regExpProtoStickyGetterObject = getGetterById(exec, m_regExpPrototype.get(), vm.propertyNames-&gt;sticky);</span>
      catchScope.assertNoException();
<span class="line-modified">!     JSObject* regExpProtoUnicodeGetterObject = getGetterById(exec, m_regExpPrototype.get(), vm.propertyNames-&gt;unicode);</span>
      catchScope.assertNoException();
<span class="line-modified">!     m_regExpProtoUnicodeGetter.set(vm, this, regExpProtoUnicodeGetterObject);</span>
<span class="line-modified">!     JSObject* builtinRegExpExec = asObject(m_regExpPrototype-&gt;getDirect(vm, vm.propertyNames-&gt;exec).asCell());</span>
<span class="line-removed">-     m_regExpProtoExec.set(vm, this, builtinRegExpExec);</span>
<span class="line-removed">-     JSObject* regExpSymbolReplace = asObject(m_regExpPrototype-&gt;getDirect(vm, vm.propertyNames-&gt;replaceSymbol).asCell());</span>
      m_regExpProtoSymbolReplace.set(vm, this, regExpSymbolReplace);
  
<span class="line-modified">! #define CREATE_PRIVATE_GLOBAL_FUNCTION(varName, funcName, code) JSFunction* varName ## PrivateFunction = JSFunction::create(vm, code ## CodeGenerator(vm), this);</span>
<span class="line-modified">!     JSC_FOREACH_BUILTIN_FUNCTION_PRIVATE_GLOBAL_NAME(CREATE_PRIVATE_GLOBAL_FUNCTION)</span>
<span class="line-modified">! #undef CREATE_PRIVATE_GLOBAL_FUNCTION</span>
  
<span class="line-modified">!     JSObject* arrayIteratorPrototype = ArrayIteratorPrototype::create(vm, this, ArrayIteratorPrototype::createStructure(vm, this, m_iteratorPrototype.get()));</span>
<span class="line-modified">!     arrayIteratorConstructorPrivateFunction-&gt;putDirect(vm, vm.propertyNames-&gt;prototype, arrayIteratorPrototype);</span>
  
      JSObject* asyncFromSyncIteratorPrototype = AsyncFromSyncIteratorPrototype::create(vm, this, AsyncFromSyncIteratorPrototype::createStructure(vm, this, m_iteratorPrototype.get()));
<span class="line-modified">!     asyncFromSyncIteratorConstructorPrivateFunction-&gt;putDirect(vm, vm.propertyNames-&gt;prototype, asyncFromSyncIteratorPrototype);</span>
  
      JSObject* mapIteratorPrototype = MapIteratorPrototype::create(vm, this, MapIteratorPrototype::createStructure(vm, this, m_iteratorPrototype.get()));
<span class="line-modified">!     mapIteratorConstructorPrivateFunction-&gt;putDirect(vm, vm.propertyNames-&gt;prototype, mapIteratorPrototype);</span>
  
      JSObject* regExpStringIteratorPrototype = RegExpStringIteratorPrototype::create(vm, this, RegExpStringIteratorPrototype::createStructure(vm, this, m_iteratorPrototype.get()));
<span class="line-modified">!     regExpStringIteratorConstructorPrivateFunction-&gt;putDirect(vm, vm.propertyNames-&gt;prototype, regExpStringIteratorPrototype);</span>
  
      JSObject* setIteratorPrototype = SetIteratorPrototype::create(vm, this, SetIteratorPrototype::createStructure(vm, this, m_iteratorPrototype.get()));
<span class="line-modified">!     setIteratorConstructorPrivateFunction-&gt;putDirect(vm, vm.propertyNames-&gt;prototype, setIteratorPrototype);</span>
  
<span class="line-removed">-     GlobalPropertyInfo staticGlobals[] = {</span>
<span class="line-removed">- #define INIT_PRIVATE_GLOBAL(varName, funcName, code) GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().funcName ## PrivateName(), varName ## PrivateFunction, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         JSC_FOREACH_BUILTIN_FUNCTION_PRIVATE_GLOBAL_NAME(INIT_PRIVATE_GLOBAL)</span>
<span class="line-removed">- #undef INIT_PRIVATE_GLOBAL</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;NaN, jsNaN(), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;Infinity, jsNumber(std::numeric_limits&lt;double&gt;::infinity()), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;undefinedKeyword, jsUndefined(), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().propertyIsEnumerablePrivateName(), privateFuncPropertyIsEnumerable, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().ownKeysPrivateName(), privateFuncOwnKeys, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().importModulePrivateName(), privateFuncImportModule, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().enqueueJobPrivateName(), JSFunction::create(vm, this, 0, String(), enqueueJob), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().makeTypeErrorPrivateName(), privateFuncMakeTypeError, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().typedArrayLengthPrivateName(), privateFuncTypedArrayLength, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().typedArrayGetOriginalConstructorPrivateName(), privateFuncTypedArrayGetOriginalConstructor, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().typedArraySortPrivateName(), privateFuncTypedArraySort, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().isTypedArrayViewPrivateName(), privateFuncIsTypedArrayView, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().typedArraySubarrayCreatePrivateName(), privateFuncTypedArraySubarrayCreate, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().isBoundFunctionPrivateName(), privateFuncIsBoundFunction, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().hasInstanceBoundFunctionPrivateName(), privateFuncHasInstanceBoundFunction, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().instanceOfPrivateName(), privateFuncInstanceOf, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().BuiltinLogPrivateName(), builtinLog, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().BuiltinDescribePrivateName(), builtinDescribe, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().RegExpPrivateName(), regExpConstructor, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().truncPrivateName(), privateFuncTrunc, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().PromisePrivateName(), promiseConstructor, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().InternalPromisePrivateName(), internalPromiseConstructor, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">- </span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().repeatCharacterPrivateName(), JSFunction::create(vm, this, 2, String(), stringProtoFuncRepeatCharacter), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().arraySpeciesCreatePrivateName(), JSFunction::create(vm, this, 2, String(), arrayProtoFuncSpeciesCreate), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().isArrayPrivateName(), arrayConstructor-&gt;getDirect(vm, vm.propertyNames-&gt;isArray), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().isArraySlowPrivateName(), privateFuncIsArraySlow, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().concatMemcpyPrivateName(), privateFuncConcatMemcpy, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().appendMemcpyPrivateName(), privateFuncAppendMemcpy, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">- </span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().hostPromiseRejectionTrackerPrivateName(), JSFunction::create(vm, this, 2, String(), globalFuncHostPromiseRejectionTracker), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().InspectorInstrumentationPrivateName(), InspectorInstrumentationObject::create(vm, this, InspectorInstrumentationObject::createStructure(vm, this, m_objectPrototype.get())), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().SetPrivateName(), setConstructor, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().thisTimeValuePrivateName(), privateFuncThisTimeValue, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
  #if ENABLE(INTL)
<span class="line-modified">!         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().dateTimeFormatPrivateName(), privateFuncDateTimeFormat, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
  #endif // ENABLE(INTL)
<span class="line-removed">- </span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().isConstructorPrivateName(), JSFunction::create(vm, this, 1, String(), esSpecIsConstructor, NoIntrinsic), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">- </span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().regExpProtoFlagsGetterPrivateName(), regExpProtoFlagsGetterObject, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().regExpProtoGlobalGetterPrivateName(), regExpProtoGlobalGetterObject, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().regExpProtoIgnoreCaseGetterPrivateName(), regExpProtoIgnoreCaseGetterObject, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().regExpProtoMultilineGetterPrivateName(), regExpProtoMultilineGetterObject, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().regExpProtoSourceGetterPrivateName(), regExpProtoSourceGetterObject, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().regExpProtoStickyGetterPrivateName(), regExpProtoStickyGetterObject, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().regExpProtoUnicodeGetterPrivateName(), regExpProtoUnicodeGetterObject, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // RegExp.prototype helpers.</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().regExpBuiltinExecPrivateName(), builtinRegExpExec, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().regExpCreatePrivateName(), JSFunction::create(vm, this, 2, String(), esSpecRegExpCreate, NoIntrinsic), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().regExpMatchFastPrivateName(), JSFunction::create(vm, this, 1, String(), regExpProtoFuncMatchFast, RegExpMatchFastIntrinsic), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().regExpSearchFastPrivateName(), JSFunction::create(vm, this, 1, String(), regExpProtoFuncSearchFast), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().regExpSplitFastPrivateName(), JSFunction::create(vm, this, 2, String(), regExpProtoFuncSplitFast), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().regExpPrototypeSymbolReplacePrivateName(), m_regExpPrototype-&gt;getDirect(vm, vm.propertyNames-&gt;replaceSymbol), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().regExpTestFastPrivateName(), JSFunction::create(vm, this, 1, String(), regExpProtoFuncTestFast, RegExpTestFastIntrinsic), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // String.prototype helpers.</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().stringIncludesInternalPrivateName(), JSFunction::create(vm, this, 1, String(), builtinStringIncludesInternal), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().stringSplitFastPrivateName(), JSFunction::create(vm, this, 2, String(), stringProtoFuncSplitFast), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().stringSubstrInternalPrivateName(), JSFunction::create(vm, this, 2, String(), builtinStringSubstrInternal), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Function prototype helpers.</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().makeBoundFunctionPrivateName(), JSFunction::create(vm, this, 5, String(), makeBoundFunction), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().hasOwnLengthPropertyPrivateName(), JSFunction::create(vm, this, 1, String(), hasOwnLengthProperty), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Map and Set helpers.</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().mapBucketHeadPrivateName(), privateFuncMapBucketHead, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().mapBucketNextPrivateName(), privateFuncMapBucketNext, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().mapBucketKeyPrivateName(), privateFuncMapBucketKey, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().mapBucketValuePrivateName(), privateFuncMapBucketValue, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().setBucketHeadPrivateName(), privateFuncSetBucketHead, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().setBucketNextPrivateName(), privateFuncSetBucketNext, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-removed">-         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().setBucketKeyPrivateName(), privateFuncSetBucketKey, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
  #if ENABLE(WEBASSEMBLY) &amp;&amp; ENABLE(WEBASSEMBLY_STREAMING_API)
<span class="line-modified">!         // WebAssembly Streaming API</span>
<span class="line-modified">!         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().webAssemblyCompileStreamingInternalPrivateName(), JSFunction::create(vm, this, 1, String(), webAssemblyCompileStreamingInternal), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-modified">!         GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().webAssemblyInstantiateStreamingInternalPrivateName(), JSFunction::create(vm, this, 1, String(), webAssemblyInstantiateStreamingInternal), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
  #endif
<span class="line-modified">! #if !ASSERT_DISABLED</span>
          GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().assertPrivateName(), JSFunction::create(vm, this, 1, String(), assertCall), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),
  #endif
      };
      addStaticGlobals(staticGlobals, WTF_ARRAY_LENGTH(staticGlobals));
  
<span class="line-removed">-     m_specialPointers[Special::CallFunction] = m_callFunction.get();</span>
<span class="line-removed">-     m_specialPointers[Special::ApplyFunction] = m_applyFunction.get();</span>
<span class="line-removed">-     m_specialPointers[Special::ObjectConstructor] = objectConstructor;</span>
<span class="line-removed">-     m_specialPointers[Special::ArrayConstructor] = arrayConstructor;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::ThrowTypeErrorFunction)] = m_throwTypeErrorFunction.get();</span>
<span class="line-removed">- </span>
      if (UNLIKELY(Options::useDollarVM()))
          exposeDollarVM(vm);
  
  #if ENABLE(WEBASSEMBLY)
      if (Wasm::isSupported()) {
<span class="line-new-header">--- 929,253 ---</span>
          [] (const Initializer&lt;Structure&gt;&amp; init) {
              JSGlobalObject* globalObject = jsCast&lt;JSGlobalObject*&gt;(init.owner);
              IntlPluralRulesPrototype* pluralRulesPrototype = IntlPluralRulesPrototype::create(init.vm, globalObject, IntlPluralRulesPrototype::createStructure(init.vm, globalObject, globalObject-&gt;objectPrototype()));
              init.set(IntlPluralRules::createStructure(init.vm, globalObject, pluralRulesPrototype));
          });
<span class="line-added">+     m_defaultCollator.initLater(</span>
<span class="line-added">+         [] (const Initializer&lt;IntlCollator&gt;&amp; init) {</span>
<span class="line-added">+             JSGlobalObject* globalObject = jsCast&lt;JSGlobalObject*&gt;(init.owner);</span>
<span class="line-added">+             VM&amp; vm = init.vm;</span>
<span class="line-added">+             auto scope = DECLARE_CATCH_SCOPE(vm);</span>
<span class="line-added">+             IntlCollator* collator = IntlCollator::create(vm, globalObject-&gt;collatorStructure());</span>
<span class="line-added">+             collator-&gt;initializeCollator(globalObject, jsUndefined(), jsUndefined());</span>
<span class="line-added">+             scope.releaseAssertNoException();</span>
<span class="line-added">+             init.set(collator);</span>
<span class="line-added">+         });</span>
  
      IntlObject* intl = IntlObject::create(vm, IntlObject::createStructure(vm, this, m_objectPrototype.get()));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;Intl, intl, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  #endif // ENABLE(INTL)
  
      m_moduleLoader.initLater(
          [] (const Initializer&lt;JSModuleLoader&gt;&amp; init) {
              auto catchScope = DECLARE_CATCH_SCOPE(init.vm);
<span class="line-modified">!             init.set(JSModuleLoader::create(init.owner, init.vm, JSModuleLoader::createStructure(init.vm, init.owner, jsNull())));</span>
              catchScope.releaseAssertNoException();
          });
      if (Options::exposeInternalModuleLoader())
          putDirectWithoutTransition(vm, vm.propertyNames-&gt;Loader, moduleLoader(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  
<span class="line-modified">!     GetterSetter* regExpProtoFlagsGetter = getGetterById(this, m_regExpPrototype.get(), vm.propertyNames-&gt;flags);</span>
      catchScope.assertNoException();
<span class="line-modified">!     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::regExpProtoFlagsGetter)].set(vm, this, regExpProtoFlagsGetter);</span>
<span class="line-added">+     GetterSetter* regExpProtoGlobalGetter = getGetterById(this, m_regExpPrototype.get(), vm.propertyNames-&gt;global);</span>
      catchScope.assertNoException();
<span class="line-modified">!     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::regExpProtoGlobalGetter)].set(vm, this, regExpProtoGlobalGetter);</span>
<span class="line-modified">!     GetterSetter* regExpProtoIgnoreCaseGetter = getGetterById(this, m_regExpPrototype.get(), vm.propertyNames-&gt;ignoreCase);</span>
      catchScope.assertNoException();
<span class="line-modified">!     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::regExpProtoIgnoreCaseGetter)].set(vm, this, regExpProtoIgnoreCaseGetter);</span>
<span class="line-added">+     GetterSetter* regExpProtoMultilineGetter = getGetterById(this, m_regExpPrototype.get(), vm.propertyNames-&gt;multiline);</span>
      catchScope.assertNoException();
<span class="line-modified">!     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::regExpProtoMultilineGetter)].set(vm, this, regExpProtoMultilineGetter);</span>
<span class="line-added">+     GetterSetter* regExpProtoSourceGetter = getGetterById(this, m_regExpPrototype.get(), vm.propertyNames-&gt;source);</span>
      catchScope.assertNoException();
<span class="line-modified">!     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::regExpProtoSourceGetter)].set(vm, this, regExpProtoSourceGetter);</span>
<span class="line-added">+     GetterSetter* regExpProtoStickyGetter = getGetterById(this, m_regExpPrototype.get(), vm.propertyNames-&gt;sticky);</span>
      catchScope.assertNoException();
<span class="line-modified">!     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::regExpProtoStickyGetter)].set(vm, this, regExpProtoStickyGetter);</span>
<span class="line-added">+     GetterSetter* regExpProtoUnicodeGetter = getGetterById(this, m_regExpPrototype.get(), vm.propertyNames-&gt;unicode);</span>
      catchScope.assertNoException();
<span class="line-modified">!     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::regExpProtoUnicodeGetter)].set(vm, this, regExpProtoUnicodeGetter);</span>
<span class="line-modified">!     JSFunction* regExpSymbolReplace = jsCast&lt;JSFunction*&gt;(m_regExpPrototype-&gt;getDirect(vm, vm.propertyNames-&gt;replaceSymbol));</span>
      m_regExpProtoSymbolReplace.set(vm, this, regExpSymbolReplace);
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::regExpBuiltinExec)].set(vm, this, jsCast&lt;JSFunction*&gt;(m_regExpPrototype-&gt;getDirect(vm, vm.propertyNames-&gt;exec)));</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::regExpPrototypeSymbolReplace)].set(vm, this, m_regExpPrototype-&gt;getDirect(vm, vm.propertyNames-&gt;replaceSymbol).asCell());</span>
  
<span class="line-modified">!     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::isArray)].set(vm, this, arrayConstructor-&gt;getDirect(vm, vm.propertyNames-&gt;isArray).asCell());</span>
<span class="line-modified">!     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::callFunction)].set(vm, this, callFunction);</span>
<span class="line-modified">!     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::applyFunction)].set(vm, this, applyFunction);</span>
  
<span class="line-modified">! #define INIT_PRIVATE_GLOBAL(funcName, code) \</span>
<span class="line-modified">!     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::funcName)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) { \</span>
<span class="line-added">+             JSGlobalObject* globalObject = jsCast&lt;JSGlobalObject*&gt;(init.owner); \</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, code ## CodeGenerator(init.vm), globalObject)); \</span>
<span class="line-added">+         });</span>
<span class="line-added">+     JSC_FOREACH_BUILTIN_FUNCTION_PRIVATE_GLOBAL_NAME(INIT_PRIVATE_GLOBAL)</span>
<span class="line-added">+ #undef INIT_PRIVATE_GLOBAL</span>
  
<span class="line-added">+     // FIXME: Initializing them lazily.</span>
<span class="line-added">+     // https://bugs.webkit.org/show_bug.cgi?id=203795</span>
      JSObject* asyncFromSyncIteratorPrototype = AsyncFromSyncIteratorPrototype::create(vm, this, AsyncFromSyncIteratorPrototype::createStructure(vm, this, m_iteratorPrototype.get()));
<span class="line-modified">!     jsCast&lt;JSObject*&gt;(linkTimeConstant(LinkTimeConstant::AsyncFromSyncIterator))-&gt;putDirect(vm, vm.propertyNames-&gt;prototype, asyncFromSyncIteratorPrototype);</span>
  
      JSObject* mapIteratorPrototype = MapIteratorPrototype::create(vm, this, MapIteratorPrototype::createStructure(vm, this, m_iteratorPrototype.get()));
<span class="line-modified">!     jsCast&lt;JSObject*&gt;(linkTimeConstant(LinkTimeConstant::MapIterator))-&gt;putDirect(vm, vm.propertyNames-&gt;prototype, mapIteratorPrototype);</span>
  
      JSObject* regExpStringIteratorPrototype = RegExpStringIteratorPrototype::create(vm, this, RegExpStringIteratorPrototype::createStructure(vm, this, m_iteratorPrototype.get()));
<span class="line-modified">!     jsCast&lt;JSObject*&gt;(linkTimeConstant(LinkTimeConstant::RegExpStringIterator))-&gt;putDirect(vm, vm.propertyNames-&gt;prototype, regExpStringIteratorPrototype);</span>
  
      JSObject* setIteratorPrototype = SetIteratorPrototype::create(vm, this, SetIteratorPrototype::createStructure(vm, this, m_iteratorPrototype.get()));
<span class="line-modified">!     jsCast&lt;JSObject*&gt;(linkTimeConstant(LinkTimeConstant::SetIterator))-&gt;putDirect(vm, vm.propertyNames-&gt;prototype, setIteratorPrototype);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Map and Set helpers.</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::Set)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(jsCast&lt;JSGlobalObject*&gt;(init.owner)-&gt;setConstructor());</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::mapBucketHead)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), mapPrivateFuncMapBucketHead, JSMapBucketHeadIntrinsic));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::mapBucketNext)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), mapPrivateFuncMapBucketNext, JSMapBucketNextIntrinsic));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::mapBucketKey)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), mapPrivateFuncMapBucketKey, JSMapBucketKeyIntrinsic));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::mapBucketValue)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), mapPrivateFuncMapBucketValue, JSMapBucketValueIntrinsic));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::setBucketHead)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), setPrivateFuncSetBucketHead, JSSetBucketHeadIntrinsic));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::setBucketNext)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), setPrivateFuncSetBucketNext, JSSetBucketNextIntrinsic));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::setBucketKey)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), setPrivateFuncSetBucketKey, JSSetBucketKeyIntrinsic));</span>
<span class="line-added">+         });</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::importModule)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), globalFuncImportModule));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::propertyIsEnumerable)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), globalFuncPropertyIsEnumerable));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::ownKeys)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), globalFuncOwnKeys));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::enqueueJob)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, &quot;enqueueJob&quot;_s, enqueueJob));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::makeTypeError)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), globalFuncMakeTypeError));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::typedArrayLength)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), typedArrayViewPrivateFuncLength));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::typedArrayGetOriginalConstructor)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), typedArrayViewPrivateFuncGetOriginalConstructor));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::typedArraySort)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), typedArrayViewPrivateFuncSort));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::isTypedArrayView)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), typedArrayViewPrivateFuncIsTypedArrayView, IsTypedArrayViewIntrinsic));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::typedArraySubarrayCreate)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), typedArrayViewPrivateFuncSubarrayCreate));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::isBoundFunction)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), isBoundFunction));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::hasInstanceBoundFunction)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), hasInstanceBoundFunction));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::instanceOf)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), objectPrivateFuncInstanceOf));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::BuiltinLog)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 1, String(), globalFuncBuiltinLog));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::BuiltinDescribe)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 1, String(), globalFuncBuiltinDescribe));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::trunc)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), mathProtoFuncTrunc, TruncIntrinsic));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::repeatCharacter)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 2, String(), stringProtoFuncRepeatCharacter));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::arraySpeciesCreate)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 2, String(), arrayProtoFuncSpeciesCreate));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::isArraySlow)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), arrayConstructorPrivateFuncIsArraySlow));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::concatMemcpy)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), arrayProtoPrivateFuncConcatMemcpy));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::appendMemcpy)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), arrayProtoPrivateFuncAppendMemcpy));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::hostPromiseRejectionTracker)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 2, String(), globalFuncHostPromiseRejectionTracker));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::InspectorInstrumentation)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             JSGlobalObject* globalObject = jsCast&lt;JSGlobalObject*&gt;(init.owner);</span>
<span class="line-added">+             init.set(InspectorInstrumentationObject::create(init.vm, globalObject, InspectorInstrumentationObject::createStructure(init.vm, globalObject, globalObject-&gt;m_objectPrototype.get())));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::thisTimeValue)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), dateProtoFuncGetTime, DatePrototypeGetTimeIntrinsic));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::isConstructor)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 1, String(), esSpecIsConstructor, NoIntrinsic));</span>
<span class="line-added">+         });</span>
<span class="line-added">+ </span>
<span class="line-added">+     // RegExp.prototype helpers.</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::regExpCreate)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 2, String(), esSpecRegExpCreate, NoIntrinsic));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::isRegExp)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 1, String(), esSpecIsRegExp, NoIntrinsic));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::regExpMatchFast)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 1, String(), regExpProtoFuncMatchFast, RegExpMatchFastIntrinsic));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::regExpSearchFast)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 1, String(), regExpProtoFuncSearchFast));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::regExpSplitFast)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 2, String(), regExpProtoFuncSplitFast));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::regExpTestFast)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 1, String(), regExpProtoFuncTestFast, RegExpTestFastIntrinsic));</span>
<span class="line-added">+         });</span>
<span class="line-added">+ </span>
<span class="line-added">+     // String.prototype helpers.</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::stringIncludesInternal)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 1, String(), builtinStringIncludesInternal));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::stringSplitFast)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 2, String(), stringProtoFuncSplitFast));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::stringSubstrInternal)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 2, String(), builtinStringSubstrInternal));</span>
<span class="line-added">+         });</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Function prototype helpers.</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::makeBoundFunction)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 5, String(), makeBoundFunction));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::hasOwnLengthProperty)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 1, String(), hasOwnLengthProperty));</span>
<span class="line-added">+         });</span>
  
  #if ENABLE(INTL)
<span class="line-modified">!     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::dateTimeFormat)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 0, String(), globalFuncDateTimeFormat));</span>
<span class="line-added">+         });</span>
  #endif // ENABLE(INTL)
  #if ENABLE(WEBASSEMBLY) &amp;&amp; ENABLE(WEBASSEMBLY_STREAMING_API)
<span class="line-modified">!     // WebAssembly Streaming API</span>
<span class="line-modified">!     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::webAssemblyCompileStreamingInternal)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-modified">!             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 1, String(), webAssemblyCompileStreamingInternal));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     m_linkTimeConstants[static_cast&lt;unsigned&gt;(LinkTimeConstant::webAssemblyInstantiateStreamingInternal)].initLater([] (const Initializer&lt;JSCell&gt;&amp; init) {</span>
<span class="line-added">+             init.set(JSFunction::create(init.vm, jsCast&lt;JSGlobalObject*&gt;(init.owner), 1, String(), webAssemblyInstantiateStreamingInternal));</span>
<span class="line-added">+         });</span>
  #endif
<span class="line-modified">! </span>
<span class="line-added">+     GlobalPropertyInfo staticGlobals[] = {</span>
<span class="line-added">+         GlobalPropertyInfo(vm.propertyNames-&gt;NaN, jsNaN(), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-added">+         GlobalPropertyInfo(vm.propertyNames-&gt;Infinity, jsNumber(std::numeric_limits&lt;double&gt;::infinity()), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-added">+         GlobalPropertyInfo(vm.propertyNames-&gt;undefinedKeyword, jsUndefined(), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),</span>
<span class="line-added">+ #if ASSERT_ENABLED</span>
          GlobalPropertyInfo(vm.propertyNames-&gt;builtinNames().assertPrivateName(), JSFunction::create(vm, this, 1, String(), assertCall), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),
  #endif
      };
      addStaticGlobals(staticGlobals, WTF_ARRAY_LENGTH(staticGlobals));
  
      if (UNLIKELY(Options::useDollarVM()))
          exposeDollarVM(vm);
  
  #if ENABLE(WEBASSEMBLY)
      if (Wasm::isSupported()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1096,14 ***</span>
              });
          m_webAssemblyWrapperFunctionStructure.initLater(
              [] (const Initializer&lt;Structure&gt;&amp; init) {
                  init.set(WebAssemblyWrapperFunction::createStructure(init.vm, init.owner, init.owner-&gt;m_functionPrototype.get()));
              });
<span class="line-removed">-         m_webAssemblyToJSCalleeStructure.initLater(</span>
<span class="line-removed">-             [] (const Initializer&lt;Structure&gt;&amp; init) {</span>
<span class="line-removed">-                 init.set(WebAssemblyToJSCallee::createStructure(init.vm, init.owner, jsNull()));</span>
<span class="line-removed">-             });</span>
          auto* webAssembly = JSWebAssembly::create(vm, this, JSWebAssembly::createStructure(vm, this, m_objectPrototype.get()));
          putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;WebAssembly&quot;), webAssembly, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  
  #define CREATE_WEBASSEMBLY_PROTOTYPE(capitalName, lowerName, properName, instanceType, jsName, prototypeBase, featureFlag) \
      if (featureFlag) {\
<span class="line-new-header">--- 1193,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1121,135 ***</span>
      }
  #endif // ENABLE(WEBASSEMBLY)
  
  #undef CREATE_PROTOTYPE_FOR_LAZY_TYPE
  
<span class="line-removed">-     auto setupAdaptiveWatchpoint = [&amp;] (JSObject* base, const Identifier&amp; ident) -&gt; ObjectPropertyCondition {</span>
<span class="line-removed">-         // Performing these gets should not throw.</span>
<span class="line-removed">-         ExecState* exec = globalExec();</span>
<span class="line-removed">-         PropertySlot slot(base, PropertySlot::InternalMethodType::Get);</span>
<span class="line-removed">-         bool result = base-&gt;getOwnPropertySlot(base, exec, ident, slot);</span>
<span class="line-removed">-         ASSERT_UNUSED(result, result);</span>
<span class="line-removed">-         catchScope.assertNoException();</span>
<span class="line-removed">-         RELEASE_ASSERT(slot.isCacheableValue());</span>
<span class="line-removed">-         JSValue functionValue = slot.getValue(exec, ident);</span>
<span class="line-removed">-         catchScope.assertNoException();</span>
<span class="line-removed">-         ASSERT(jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ObjectPropertyCondition condition = generateConditionForSelfEquivalence(m_vm, nullptr, base, ident.impl());</span>
<span class="line-removed">-         RELEASE_ASSERT(condition.requiredValue() == functionValue);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         bool isWatchable = condition.isWatchable(PropertyCondition::EnsureWatchability);</span>
<span class="line-removed">-         RELEASE_ASSERT(isWatchable); // We allow this to install the necessary watchpoints.</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return condition;</span>
<span class="line-removed">-     };</span>
  
      {
<span class="line-modified">!         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(arrayIteratorPrototype, m_vm.propertyNames-&gt;next);</span>
          m_arrayIteratorPrototypeNext = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_arrayIteratorProtocolWatchpointSet);
          m_arrayIteratorPrototypeNext-&gt;install(vm);
      }
      {
<span class="line-modified">!         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(this-&gt;arrayPrototype(), m_vm.propertyNames-&gt;iteratorSymbol);</span>
          m_arrayPrototypeSymbolIteratorWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_arrayIteratorProtocolWatchpointSet);
          m_arrayPrototypeSymbolIteratorWatchpoint-&gt;install(vm);
      }
      {
<span class="line-modified">!         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(this-&gt;arrayPrototype(), m_vm.propertyNames-&gt;join);</span>
          m_arrayPrototypeJoinWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_arrayJoinWatchpointSet);
          m_arrayPrototypeJoinWatchpoint-&gt;install(vm);
      }
  
      {
<span class="line-modified">!         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(mapIteratorPrototype, m_vm.propertyNames-&gt;next);</span>
          m_mapIteratorPrototypeNextWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_mapIteratorProtocolWatchpointSet);
          m_mapIteratorPrototypeNextWatchpoint-&gt;install(vm);
      }
      {
<span class="line-modified">!         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(m_mapPrototype.get(), m_vm.propertyNames-&gt;iteratorSymbol);</span>
<span class="line-removed">-         m_mapPrototypeSymbolIteratorWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_mapIteratorProtocolWatchpointSet);</span>
<span class="line-removed">-         m_mapPrototypeSymbolIteratorWatchpoint-&gt;install(vm);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(setIteratorPrototype, m_vm.propertyNames-&gt;next);</span>
          m_setIteratorPrototypeNextWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_setIteratorProtocolWatchpointSet);
          m_setIteratorPrototypeNextWatchpoint-&gt;install(vm);
      }
      {
<span class="line-modified">!         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(m_setPrototype.get(), m_vm.propertyNames-&gt;iteratorSymbol);</span>
<span class="line-removed">-         m_setPrototypeSymbolIteratorWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_setIteratorProtocolWatchpointSet);</span>
<span class="line-removed">-         m_setPrototypeSymbolIteratorWatchpoint-&gt;install(vm);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(m_stringIteratorPrototype.get(), m_vm.propertyNames-&gt;next);</span>
          m_stringIteratorPrototypeNextWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_stringIteratorProtocolWatchpointSet);
          m_stringIteratorPrototypeNextWatchpoint-&gt;install(vm);
      }
      {
<span class="line-modified">!         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(m_stringPrototype.get(), m_vm.propertyNames-&gt;iteratorSymbol);</span>
          m_stringPrototypeSymbolIteratorWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_stringIteratorProtocolWatchpointSet);
          m_stringPrototypeSymbolIteratorWatchpoint-&gt;install(vm);
      }
  
<span class="line-removed">-     {</span>
<span class="line-removed">-         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(m_mapPrototype.get(), m_vm.propertyNames-&gt;set);</span>
<span class="line-removed">-         m_mapPrototypeSetWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_mapSetWatchpointSet);</span>
<span class="line-removed">-         m_mapPrototypeSetWatchpoint-&gt;install(vm);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(m_setPrototype.get(), m_vm.propertyNames-&gt;add);</span>
<span class="line-removed">-         m_setPrototypeAddWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_setAddWatchpointSet);</span>
<span class="line-removed">-         m_setPrototypeAddWatchpoint-&gt;install(vm);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      // Unfortunately, the prototype objects of the builtin objects can be touched from concurrent compilers. So eagerly initialize them only if we use JIT.
      if (VM::canUseJIT()) {
          this-&gt;booleanPrototype();
<span class="line-modified">!         auto* numberPrototype = this-&gt;numberPrototype();</span>
          this-&gt;symbolPrototype();
<span class="line-removed">- </span>
<span class="line-removed">-         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(numberPrototype, m_vm.propertyNames-&gt;toString);</span>
<span class="line-removed">-         m_numberPrototypeToStringWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_numberToStringWatchpointSet);</span>
<span class="line-removed">-         m_numberPrototypeToStringWatchpoint-&gt;install(vm);</span>
<span class="line-removed">-         m_numberProtoToStringFunction.set(vm, this, jsCast&lt;JSFunction*&gt;(numberPrototype-&gt;getDirect(vm, vm.propertyNames-&gt;toString)));</span>
      }
  
      fixupPrototypeChainWithObjectPrototype(vm);
  }
  
<span class="line-modified">! bool JSGlobalObject::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSGlobalObject* thisObject = jsCast&lt;JSGlobalObject*&gt;(cell);
      ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(thisObject));
  
      if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, ordinarySetSlow(exec, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));</span>
  
      bool shouldThrowReadOnlyError = slot.isStrictMode();
      bool ignoreReadOnlyErrors = false;
      bool putResult = false;
<span class="line-modified">!     bool done = symbolTablePutTouchWatchpointSet(thisObject, exec, propertyName, value, shouldThrowReadOnlyError, ignoreReadOnlyErrors, putResult);</span>
      EXCEPTION_ASSERT((!!scope.exception() == (done &amp;&amp; !putResult)) || !shouldThrowReadOnlyError);
      if (done)
          return putResult;
<span class="line-modified">!     RELEASE_AND_RETURN(scope, Base::put(thisObject, exec, propertyName, value, slot));</span>
  }
  
<span class="line-modified">! bool JSGlobalObject::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
  {
      JSGlobalObject* thisObject = jsCast&lt;JSGlobalObject*&gt;(object);
      PropertySlot slot(thisObject, PropertySlot::InternalMethodType::VMInquiry);
      // silently ignore attempts to add accessors aliasing vars.
      if (descriptor.isAccessorDescriptor() &amp;&amp; symbolTableGet(thisObject, propertyName, slot))
          return false;
<span class="line-modified">!     return Base::defineOwnProperty(thisObject, exec, propertyName, descriptor, shouldThrow);</span>
  }
  
  void JSGlobalObject::addGlobalVar(const Identifier&amp; ident)
  {
      ConcurrentJSLocker locker(symbolTable()-&gt;m_lock);
<span class="line-new-header">--- 1214,86 ---</span>
      }
  #endif // ENABLE(WEBASSEMBLY)
  
  #undef CREATE_PROTOTYPE_FOR_LAZY_TYPE
  
  
      {
<span class="line-modified">!         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(this, arrayIteratorPrototype, vm.propertyNames-&gt;next);</span>
          m_arrayIteratorPrototypeNext = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_arrayIteratorProtocolWatchpointSet);
          m_arrayIteratorPrototypeNext-&gt;install(vm);
      }
      {
<span class="line-modified">!         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(this, this-&gt;arrayPrototype(), vm.propertyNames-&gt;iteratorSymbol);</span>
          m_arrayPrototypeSymbolIteratorWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_arrayIteratorProtocolWatchpointSet);
          m_arrayPrototypeSymbolIteratorWatchpoint-&gt;install(vm);
      }
      {
<span class="line-modified">!         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(this, this-&gt;arrayPrototype(), vm.propertyNames-&gt;join);</span>
          m_arrayPrototypeJoinWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_arrayJoinWatchpointSet);
          m_arrayPrototypeJoinWatchpoint-&gt;install(vm);
      }
  
      {
<span class="line-modified">!         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(this, mapIteratorPrototype, vm.propertyNames-&gt;next);</span>
          m_mapIteratorPrototypeNextWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_mapIteratorProtocolWatchpointSet);
          m_mapIteratorPrototypeNextWatchpoint-&gt;install(vm);
      }
      {
<span class="line-modified">!         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(this, setIteratorPrototype, vm.propertyNames-&gt;next);</span>
          m_setIteratorPrototypeNextWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_setIteratorProtocolWatchpointSet);
          m_setIteratorPrototypeNextWatchpoint-&gt;install(vm);
      }
      {
<span class="line-modified">!         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(this, m_stringIteratorPrototype.get(), vm.propertyNames-&gt;next);</span>
          m_stringIteratorPrototypeNextWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_stringIteratorProtocolWatchpointSet);
          m_stringIteratorPrototypeNextWatchpoint-&gt;install(vm);
      }
      {
<span class="line-modified">!         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(this, m_stringPrototype.get(), vm.propertyNames-&gt;iteratorSymbol);</span>
          m_stringPrototypeSymbolIteratorWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_stringIteratorProtocolWatchpointSet);
          m_stringPrototypeSymbolIteratorWatchpoint-&gt;install(vm);
      }
  
      // Unfortunately, the prototype objects of the builtin objects can be touched from concurrent compilers. So eagerly initialize them only if we use JIT.
      if (VM::canUseJIT()) {
          this-&gt;booleanPrototype();
<span class="line-modified">!         this-&gt;numberPrototype();</span>
          this-&gt;symbolPrototype();
      }
  
      fixupPrototypeChainWithObjectPrototype(vm);
  }
  
<span class="line-modified">! bool JSGlobalObject::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSGlobalObject* thisObject = jsCast&lt;JSGlobalObject*&gt;(cell);
      ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(thisObject));
  
      if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, ordinarySetSlow(globalObject, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));</span>
  
      bool shouldThrowReadOnlyError = slot.isStrictMode();
      bool ignoreReadOnlyErrors = false;
      bool putResult = false;
<span class="line-modified">!     bool done = symbolTablePutTouchWatchpointSet(thisObject, globalObject, propertyName, value, shouldThrowReadOnlyError, ignoreReadOnlyErrors, putResult);</span>
      EXCEPTION_ASSERT((!!scope.exception() == (done &amp;&amp; !putResult)) || !shouldThrowReadOnlyError);
      if (done)
          return putResult;
<span class="line-modified">!     RELEASE_AND_RETURN(scope, Base::put(thisObject, globalObject, propertyName, value, slot));</span>
  }
  
<span class="line-modified">! bool JSGlobalObject::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
  {
      JSGlobalObject* thisObject = jsCast&lt;JSGlobalObject*&gt;(object);
      PropertySlot slot(thisObject, PropertySlot::InternalMethodType::VMInquiry);
      // silently ignore attempts to add accessors aliasing vars.
      if (descriptor.isAccessorDescriptor() &amp;&amp; symbolTableGet(thisObject, propertyName, slot))
          return false;
<span class="line-modified">!     return Base::defineOwnProperty(thisObject, globalObject, propertyName, descriptor, shouldThrow);</span>
  }
  
  void JSGlobalObject::addGlobalVar(const Identifier&amp; ident)
  {
      ConcurrentJSLocker locker(symbolTable()-&gt;m_lock);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1264,15 ***</span>
  
      ScopeOffset offsetForAssert = addVariables(1, jsUndefined());
      RELEASE_ASSERT(offsetForAssert == offset);
  }
  
<span class="line-modified">! void JSGlobalObject::addFunction(ExecState* exec, const Identifier&amp; propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
<span class="line-modified">!     methodTable(vm)-&gt;deleteProperty(this, exec, propertyName);</span>
      addGlobalVar(propertyName);
  }
  
  void JSGlobalObject::setGlobalScopeExtension(JSScope* scope)
  {
<span class="line-new-header">--- 1308,15 ---</span>
  
      ScopeOffset offsetForAssert = addVariables(1, jsUndefined());
      RELEASE_ASSERT(offsetForAssert == offset);
  }
  
<span class="line-modified">! void JSGlobalObject::addFunction(JSGlobalObject* globalObject, const Identifier&amp; propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
<span class="line-modified">!     methodTable(vm)-&gt;deleteProperty(this, globalObject, propertyName);</span>
      addGlobalVar(propertyName);
  }
  
  void JSGlobalObject::setGlobalScopeExtension(JSScope* scope)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1464,11 ***</span>
                              : m_globalObjects-&gt;contains(structure-&gt;globalObject()))
                          || (structure-&gt;hasMonoProto() &amp;&amp; !structure-&gt;storedPrototype().isNull() &amp;&amp; isInAffectedGlobalObject(asObject(structure-&gt;storedPrototype())));
                      if (mode == BadTimeFinderMode::SingleGlobal &amp;&amp; m_needsMultiGlobalsScan)
                          return IterationStatus::Done; // Bailing early and let the MultipleGlobals path handle everything.
                      if (isRelevantGlobalObject)
<span class="line-modified">!                         rareData-&gt;clearInternalFunctionAllocationProfile();</span>
                  }
              }
          }
      }
  
<span class="line-new-header">--- 1508,11 ---</span>
                              : m_globalObjects-&gt;contains(structure-&gt;globalObject()))
                          || (structure-&gt;hasMonoProto() &amp;&amp; !structure-&gt;storedPrototype().isNull() &amp;&amp; isInAffectedGlobalObject(asObject(structure-&gt;storedPrototype())));
                      if (mode == BadTimeFinderMode::SingleGlobal &amp;&amp; m_needsMultiGlobalsScan)
                          return IterationStatus::Done; // Bailing early and let the MultipleGlobals path handle everything.
                      if (isRelevantGlobalObject)
<span class="line-modified">!                         rareData-&gt;clearInternalFunctionAllocationProfile(&quot;have a bad time breaking internal function allocation&quot;);</span>
                  }
              }
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1501,29 ***</span>
  void JSGlobalObject::fireWatchpointAndMakeAllArrayStructuresSlowPut(VM&amp; vm)
  {
      if (isHavingABadTime())
          return;
  
<span class="line-removed">-     // Make sure that all allocations or indexed storage transitions that are inlining</span>
<span class="line-removed">-     // the assumption that it&#39;s safe to transition to a non-SlowPut array storage don&#39;t</span>
<span class="line-removed">-     // do so anymore.</span>
<span class="line-removed">-     m_havingABadTimeWatchpoint-&gt;fireAll(vm, &quot;Having a bad time&quot;);</span>
<span class="line-removed">-     ASSERT(isHavingABadTime()); // The watchpoint is what tells us that we&#39;re having a bad time.</span>
<span class="line-removed">- </span>
      // Make sure that all JSArray allocations that load the appropriate structure from
      // this object now load a structure that uses SlowPut.
      for (unsigned i = 0; i &lt; NumberOfArrayIndexingModes; ++i)
          m_arrayStructureForIndexingShapeDuringAllocation[i].set(vm, this, originalArrayStructureForIndexingType(ArrayWithSlowPutArrayStorage));
  
      // Same for any special array structures.
      Structure* slowPutStructure;
      slowPutStructure = createRegExpMatchesArraySlowPutStructure(vm, this);
      m_regExpMatchesArrayStructure.set(vm, this, slowPutStructure);
<span class="line-removed">-     slowPutStructure = createRegExpMatchesArrayWithGroupsSlowPutStructure(vm, this);</span>
<span class="line-removed">-     m_regExpMatchesArrayWithGroupsStructure.set(vm, this, slowPutStructure);</span>
      slowPutStructure = ClonedArguments::createSlowPutStructure(vm, this, m_objectPrototype.get());
      m_clonedArgumentsStructure.set(vm, this, slowPutStructure);
  };
  
  void JSGlobalObject::haveABadTime(VM&amp; vm)
  {
      ASSERT(&amp;vm == &amp;this-&gt;vm());
<span class="line-new-header">--- 1545,31 ---</span>
  void JSGlobalObject::fireWatchpointAndMakeAllArrayStructuresSlowPut(VM&amp; vm)
  {
      if (isHavingABadTime())
          return;
  
      // Make sure that all JSArray allocations that load the appropriate structure from
      // this object now load a structure that uses SlowPut.
      for (unsigned i = 0; i &lt; NumberOfArrayIndexingModes; ++i)
          m_arrayStructureForIndexingShapeDuringAllocation[i].set(vm, this, originalArrayStructureForIndexingType(ArrayWithSlowPutArrayStorage));
  
      // Same for any special array structures.
      Structure* slowPutStructure;
      slowPutStructure = createRegExpMatchesArraySlowPutStructure(vm, this);
      m_regExpMatchesArrayStructure.set(vm, this, slowPutStructure);
      slowPutStructure = ClonedArguments::createSlowPutStructure(vm, this, m_objectPrototype.get());
      m_clonedArgumentsStructure.set(vm, this, slowPutStructure);
<span class="line-added">+ </span>
<span class="line-added">+     // Make sure that all allocations or indexed storage transitions that are inlining</span>
<span class="line-added">+     // the assumption that it&#39;s safe to transition to a non-SlowPut array storage don&#39;t</span>
<span class="line-added">+     // do so anymore.</span>
<span class="line-added">+     // Note: we are deliberately firing the watchpoint here at the end only after</span>
<span class="line-added">+     // making all the array structures SlowPut. This ensures that the concurrent</span>
<span class="line-added">+     // JIT threads will always get the SlowPut versions of the structures if</span>
<span class="line-added">+     // isHavingABadTime() returns true. The concurrent JIT relies on this.</span>
<span class="line-added">+     m_havingABadTimeWatchpoint-&gt;fireAll(vm, &quot;Having a bad time&quot;);</span>
<span class="line-added">+     ASSERT(isHavingABadTime()); // The watchpoint is what tells us that we&#39;re having a bad time.</span>
  };
  
  void JSGlobalObject::haveABadTime(VM&amp; vm)
  {
      ASSERT(&amp;vm == &amp;this-&gt;vm());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1656,11 ***</span>
      if (getPrototypeDirect(vm) == prototype)
          return;
      setPrototypeDirect(vm, prototype);
      fixupPrototypeChainWithObjectPrototype(vm);
      // Whenever we change the prototype of the global object, we need to create a new JSProxy with the correct prototype.
<span class="line-modified">!     setGlobalThis(vm, JSNonDestructibleProxy::create(vm, JSNonDestructibleProxy::createStructure(vm, this, prototype, PureForwardingProxyType), this));</span>
  }
  
  void JSGlobalObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
  {
      JSGlobalObject* thisObject = jsCast&lt;JSGlobalObject*&gt;(cell);
<span class="line-new-header">--- 1702,11 ---</span>
      if (getPrototypeDirect(vm) == prototype)
          return;
      setPrototypeDirect(vm, prototype);
      fixupPrototypeChainWithObjectPrototype(vm);
      // Whenever we change the prototype of the global object, we need to create a new JSProxy with the correct prototype.
<span class="line-modified">!     setGlobalThis(vm, JSProxy::create(vm, JSProxy::createStructure(vm, this, prototype, PureForwardingProxyType), this));</span>
  }
  
  void JSGlobalObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
  {
      JSGlobalObject* thisObject = jsCast&lt;JSGlobalObject*&gt;(cell);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1677,48 ***</span>
      thisObject-&gt;m_rangeErrorStructure.visit(visitor);
      thisObject-&gt;m_referenceErrorStructure.visit(visitor);
      thisObject-&gt;m_syntaxErrorStructure.visit(visitor);
      thisObject-&gt;m_typeErrorStructure.visit(visitor);
      thisObject-&gt;m_URIErrorStructure.visit(visitor);
      visitor.append(thisObject-&gt;m_objectConstructor);
      visitor.append(thisObject-&gt;m_promiseConstructor);
  
  #if ENABLE(INTL)
<span class="line-modified">!     visitor.append(thisObject-&gt;m_defaultCollator);</span>
      thisObject-&gt;m_collatorStructure.visit(visitor);
      thisObject-&gt;m_numberFormatStructure.visit(visitor);
      thisObject-&gt;m_dateTimeFormatStructure.visit(visitor);
      thisObject-&gt;m_pluralRulesStructure.visit(visitor);
  #endif
      visitor.append(thisObject-&gt;m_nullGetterFunction);
      visitor.append(thisObject-&gt;m_nullSetterFunction);
  
      thisObject-&gt;m_parseIntFunction.visit(visitor);
      thisObject-&gt;m_parseFloatFunction.visit(visitor);
<span class="line-removed">-     visitor.append(thisObject-&gt;m_callFunction);</span>
<span class="line-removed">-     visitor.append(thisObject-&gt;m_applyFunction);</span>
<span class="line-removed">-     visitor.append(thisObject-&gt;m_throwTypeErrorFunction);</span>
      thisObject-&gt;m_arrayProtoToStringFunction.visit(visitor);
      thisObject-&gt;m_arrayProtoValuesFunction.visit(visitor);
      thisObject-&gt;m_evalFunction.visit(visitor);
<span class="line-removed">-     thisObject-&gt;m_initializePromiseFunction.visit(visitor);</span>
      thisObject-&gt;m_iteratorProtocolFunction.visit(visitor);
      thisObject-&gt;m_promiseResolveFunction.visit(visitor);
      visitor.append(thisObject-&gt;m_objectProtoValueOfFunction);
<span class="line-modified">!     visitor.append(thisObject-&gt;m_numberProtoToStringFunction);</span>
<span class="line-removed">-     visitor.append(thisObject-&gt;m_newPromiseCapabilityFunction);</span>
      visitor.append(thisObject-&gt;m_functionProtoHasInstanceSymbolFunction);
      thisObject-&gt;m_throwTypeErrorGetterSetter.visit(visitor);
      visitor.append(thisObject-&gt;m_throwTypeErrorArgumentsCalleeAndCallerGetterSetter);
      thisObject-&gt;m_moduleLoader.visit(visitor);
  
      visitor.append(thisObject-&gt;m_objectPrototype);
      visitor.append(thisObject-&gt;m_functionPrototype);
      visitor.append(thisObject-&gt;m_arrayPrototype);
      visitor.append(thisObject-&gt;m_iteratorPrototype);
      visitor.append(thisObject-&gt;m_generatorFunctionPrototype);
      visitor.append(thisObject-&gt;m_generatorPrototype);
      visitor.append(thisObject-&gt;m_asyncFunctionPrototype);
      visitor.append(thisObject-&gt;m_asyncGeneratorPrototype);
      visitor.append(thisObject-&gt;m_asyncIteratorPrototype);
      visitor.append(thisObject-&gt;m_asyncGeneratorFunctionPrototype);
  
<span class="line-new-header">--- 1723,49 ---</span>
      thisObject-&gt;m_rangeErrorStructure.visit(visitor);
      thisObject-&gt;m_referenceErrorStructure.visit(visitor);
      thisObject-&gt;m_syntaxErrorStructure.visit(visitor);
      thisObject-&gt;m_typeErrorStructure.visit(visitor);
      thisObject-&gt;m_URIErrorStructure.visit(visitor);
<span class="line-added">+     visitor.append(thisObject-&gt;m_arrayConstructor);</span>
<span class="line-added">+     visitor.append(thisObject-&gt;m_regExpConstructor);</span>
      visitor.append(thisObject-&gt;m_objectConstructor);
<span class="line-added">+     visitor.append(thisObject-&gt;m_functionConstructor);</span>
      visitor.append(thisObject-&gt;m_promiseConstructor);
<span class="line-added">+     visitor.append(thisObject-&gt;m_internalPromiseConstructor);</span>
  
  #if ENABLE(INTL)
<span class="line-modified">!     thisObject-&gt;m_defaultCollator.visit(visitor);</span>
      thisObject-&gt;m_collatorStructure.visit(visitor);
      thisObject-&gt;m_numberFormatStructure.visit(visitor);
      thisObject-&gt;m_dateTimeFormatStructure.visit(visitor);
      thisObject-&gt;m_pluralRulesStructure.visit(visitor);
  #endif
      visitor.append(thisObject-&gt;m_nullGetterFunction);
      visitor.append(thisObject-&gt;m_nullSetterFunction);
  
      thisObject-&gt;m_parseIntFunction.visit(visitor);
      thisObject-&gt;m_parseFloatFunction.visit(visitor);
      thisObject-&gt;m_arrayProtoToStringFunction.visit(visitor);
      thisObject-&gt;m_arrayProtoValuesFunction.visit(visitor);
      thisObject-&gt;m_evalFunction.visit(visitor);
      thisObject-&gt;m_iteratorProtocolFunction.visit(visitor);
      thisObject-&gt;m_promiseResolveFunction.visit(visitor);
      visitor.append(thisObject-&gt;m_objectProtoValueOfFunction);
<span class="line-modified">!     thisObject-&gt;m_numberProtoToStringFunction.visit(visitor);</span>
      visitor.append(thisObject-&gt;m_functionProtoHasInstanceSymbolFunction);
      thisObject-&gt;m_throwTypeErrorGetterSetter.visit(visitor);
<span class="line-added">+     visitor.append(thisObject-&gt;m_regExpProtoSymbolReplace);</span>
      visitor.append(thisObject-&gt;m_throwTypeErrorArgumentsCalleeAndCallerGetterSetter);
      thisObject-&gt;m_moduleLoader.visit(visitor);
  
      visitor.append(thisObject-&gt;m_objectPrototype);
      visitor.append(thisObject-&gt;m_functionPrototype);
      visitor.append(thisObject-&gt;m_arrayPrototype);
      visitor.append(thisObject-&gt;m_iteratorPrototype);
      visitor.append(thisObject-&gt;m_generatorFunctionPrototype);
      visitor.append(thisObject-&gt;m_generatorPrototype);
<span class="line-added">+     visitor.append(thisObject-&gt;m_arrayIteratorPrototype);</span>
      visitor.append(thisObject-&gt;m_asyncFunctionPrototype);
      visitor.append(thisObject-&gt;m_asyncGeneratorPrototype);
      visitor.append(thisObject-&gt;m_asyncIteratorPrototype);
      visitor.append(thisObject-&gt;m_asyncGeneratorFunctionPrototype);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1758,25 ***</span>
      visitFunctionStructures(thisObject-&gt;m_builtinFunctions);
      visitFunctionStructures(thisObject-&gt;m_ordinaryFunctions);
  
      thisObject-&gt;m_customGetterSetterFunctionStructure.visit(visitor);
      thisObject-&gt;m_boundFunctionStructure.visit(visitor);
<span class="line-removed">-     visitor.append(thisObject-&gt;m_getterSetterStructure);</span>
      thisObject-&gt;m_nativeStdFunctionStructure.visit(visitor);
      visitor.append(thisObject-&gt;m_regExpStructure);
      visitor.append(thisObject-&gt;m_generatorFunctionStructure);
      visitor.append(thisObject-&gt;m_asyncFunctionStructure);
      visitor.append(thisObject-&gt;m_asyncGeneratorFunctionStructure);
      thisObject-&gt;m_iteratorResultObjectStructure.visit(visitor);
      visitor.append(thisObject-&gt;m_regExpMatchesArrayStructure);
<span class="line-removed">-     visitor.append(thisObject-&gt;m_regExpMatchesArrayWithGroupsStructure);</span>
      thisObject-&gt;m_moduleRecordStructure.visit(visitor);
      thisObject-&gt;m_moduleNamespaceObjectStructure.visit(visitor);
      thisObject-&gt;m_proxyObjectStructure.visit(visitor);
      thisObject-&gt;m_callableProxyObjectStructure.visit(visitor);
      thisObject-&gt;m_proxyRevokeStructure.visit(visitor);
  
  #if ENABLE(SHARED_ARRAY_BUFFER)
      visitor.append(thisObject-&gt;m_sharedArrayBufferPrototype);
      visitor.append(thisObject-&gt;m_sharedArrayBufferStructure);
  #endif
  
<span class="line-new-header">--- 1805,29 ---</span>
      visitFunctionStructures(thisObject-&gt;m_builtinFunctions);
      visitFunctionStructures(thisObject-&gt;m_ordinaryFunctions);
  
      thisObject-&gt;m_customGetterSetterFunctionStructure.visit(visitor);
      thisObject-&gt;m_boundFunctionStructure.visit(visitor);
      thisObject-&gt;m_nativeStdFunctionStructure.visit(visitor);
      visitor.append(thisObject-&gt;m_regExpStructure);
      visitor.append(thisObject-&gt;m_generatorFunctionStructure);
      visitor.append(thisObject-&gt;m_asyncFunctionStructure);
      visitor.append(thisObject-&gt;m_asyncGeneratorFunctionStructure);
<span class="line-added">+     visitor.append(thisObject-&gt;m_generatorStructure);</span>
<span class="line-added">+     visitor.append(thisObject-&gt;m_asyncGeneratorStructure);</span>
<span class="line-added">+     visitor.append(thisObject-&gt;m_arrayIteratorStructure);</span>
      thisObject-&gt;m_iteratorResultObjectStructure.visit(visitor);
      visitor.append(thisObject-&gt;m_regExpMatchesArrayStructure);
      thisObject-&gt;m_moduleRecordStructure.visit(visitor);
      thisObject-&gt;m_moduleNamespaceObjectStructure.visit(visitor);
      thisObject-&gt;m_proxyObjectStructure.visit(visitor);
      thisObject-&gt;m_callableProxyObjectStructure.visit(visitor);
      thisObject-&gt;m_proxyRevokeStructure.visit(visitor);
  
<span class="line-added">+     for (auto&amp; property : thisObject-&gt;m_linkTimeConstants)</span>
<span class="line-added">+         property.visit(visitor);</span>
<span class="line-added">+ </span>
  #if ENABLE(SHARED_ARRAY_BUFFER)
      visitor.append(thisObject-&gt;m_sharedArrayBufferPrototype);
      visitor.append(thisObject-&gt;m_sharedArrayBufferStructure);
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1796,11 ***</span>
  #if ENABLE(WEBASSEMBLY)
      thisObject-&gt;m_webAssemblyModuleRecordStructure.visit(visitor);
      thisObject-&gt;m_webAssemblyFunctionStructure.visit(visitor);
      thisObject-&gt;m_jsToWasmICCalleeStructure.visit(visitor);
      thisObject-&gt;m_webAssemblyWrapperFunctionStructure.visit(visitor);
<span class="line-removed">-     thisObject-&gt;m_webAssemblyToJSCalleeStructure.visit(visitor);</span>
      FOR_EACH_WEBASSEMBLY_CONSTRUCTOR_TYPE(VISIT_LAZY_TYPE)
  #endif // ENABLE(WEBASSEMBLY)
  
  #undef VISIT_SIMPLE_TYPE
  #undef VISIT_LAZY_TYPE
<span class="line-new-header">--- 1847,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1812,18 ***</span>
      thisObject-&gt;m_typedArrayProto.visit(visitor);
      thisObject-&gt;m_typedArraySuperConstructor.visit(visitor);
      thisObject-&gt;m_regExpGlobalData.visitAggregate(visitor);
  }
  
<span class="line-modified">! ExecState* JSGlobalObject::globalExec()</span>
  {
<span class="line-modified">!     return CallFrame::create(m_globalCallFrame);</span>
  }
  
  void JSGlobalObject::exposeDollarVM(VM&amp; vm)
  {
<span class="line-modified">!     if (hasOwnProperty(globalExec(), vm.propertyNames-&gt;builtinNames().dollarVMPrivateName()))</span>
          return;
  
      JSDollarVM* dollarVM = JSDollarVM::create(vm, JSDollarVM::createStructure(vm, this, m_objectPrototype.get()));
  
      GlobalPropertyInfo extraStaticGlobals[] = {
<span class="line-new-header">--- 1862,19 ---</span>
      thisObject-&gt;m_typedArrayProto.visit(visitor);
      thisObject-&gt;m_typedArraySuperConstructor.visit(visitor);
      thisObject-&gt;m_regExpGlobalData.visitAggregate(visitor);
  }
  
<span class="line-modified">! CallFrame* JSGlobalObject::deprecatedCallFrameForDebugger()</span>
  {
<span class="line-modified">!     return CallFrame::create(m_deprecatedCallFrameForDebugger);</span>
  }
  
  void JSGlobalObject::exposeDollarVM(VM&amp; vm)
  {
<span class="line-modified">!     RELEASE_ASSERT(g_jscConfig.restrictedOptionsEnabled &amp;&amp; Options::useDollarVM());</span>
<span class="line-added">+     if (hasOwnProperty(this, vm.propertyNames-&gt;builtinNames().dollarVMPrivateName()))</span>
          return;
  
      JSDollarVM* dollarVM = JSDollarVM::create(vm, JSDollarVM::createStructure(vm, this, m_objectPrototype.get()));
  
      GlobalPropertyInfo extraStaticGlobals[] = {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1860,28 ***</span>
          }
          symbolTablePutTouchWatchpointSet(vm(), this, global.identifier, global.value, variable, watchpointSet);
      }
  }
  
<span class="line-modified">! bool JSGlobalObject::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     if (Base::getOwnPropertySlot(object, exec, propertyName, slot))</span>
          return true;
      return symbolTableGet(jsCast&lt;JSGlobalObject*&gt;(object), propertyName, slot);
  }
  
  void JSGlobalObject::clearRareData(JSCell* cell)
  {
      jsCast&lt;JSGlobalObject*&gt;(cell)-&gt;m_rareData = nullptr;
  }
  
<span class="line-modified">! void JSGlobalObject::tryInstallArraySpeciesWatchpoint(ExecState* exec)</span>
  {
      RELEASE_ASSERT(!m_arrayPrototypeConstructorWatchpoint);
      RELEASE_ASSERT(!m_arrayConstructorSpeciesWatchpoint);
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // First we need to make sure that the Array.prototype.constructor property points to Array
      // and that Array[Symbol.species] is the primordial GetterSetter.
      ArrayPrototype* arrayPrototype = this-&gt;arrayPrototype();
<span class="line-new-header">--- 1911,28 ---</span>
          }
          symbolTablePutTouchWatchpointSet(vm(), this, global.identifier, global.value, variable, watchpointSet);
      }
  }
  
<span class="line-modified">! bool JSGlobalObject::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     if (Base::getOwnPropertySlot(object, globalObject, propertyName, slot))</span>
          return true;
      return symbolTableGet(jsCast&lt;JSGlobalObject*&gt;(object), propertyName, slot);
  }
  
  void JSGlobalObject::clearRareData(JSCell* cell)
  {
      jsCast&lt;JSGlobalObject*&gt;(cell)-&gt;m_rareData = nullptr;
  }
  
<span class="line-modified">! void JSGlobalObject::tryInstallArraySpeciesWatchpoint()</span>
  {
      RELEASE_ASSERT(!m_arrayPrototypeConstructorWatchpoint);
      RELEASE_ASSERT(!m_arrayConstructorSpeciesWatchpoint);
  
<span class="line-modified">!     VM&amp; vm = this-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // First we need to make sure that the Array.prototype.constructor property points to Array
      // and that Array[Symbol.species] is the primordial GetterSetter.
      ArrayPrototype* arrayPrototype = this-&gt;arrayPrototype();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1897,25 ***</span>
      auto invalidateWatchpoint = [&amp;] {
          m_arraySpeciesWatchpointSet.invalidate(vm, StringFireDetail(&quot;Was not able to set up array species watchpoint.&quot;));
      };
  
      PropertySlot constructorSlot(arrayPrototype, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!     arrayPrototype-&gt;getOwnPropertySlot(arrayPrototype, exec, vm.propertyNames-&gt;constructor, constructorSlot);</span>
      scope.assertNoException();
      if (constructorSlot.slotBase() != arrayPrototype
          || !constructorSlot.isCacheableValue()
<span class="line-modified">!         || constructorSlot.getValue(exec, vm.propertyNames-&gt;constructor) != arrayConstructor) {</span>
          invalidateWatchpoint();
          return;
      }
  
      Structure* constructorStructure = arrayConstructor-&gt;structure(vm);
      if (constructorStructure-&gt;isDictionary())
          constructorStructure = constructorStructure-&gt;flattenDictionaryStructure(vm, arrayConstructor);
  
      PropertySlot speciesSlot(arrayConstructor, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!     arrayConstructor-&gt;getOwnPropertySlot(arrayConstructor, exec, vm.propertyNames-&gt;speciesSymbol, speciesSlot);</span>
      scope.assertNoException();
      if (speciesSlot.slotBase() != arrayConstructor
          || !speciesSlot.isCacheableGetter()
          || speciesSlot.getterSetter() != speciesGetterSetter()) {
          invalidateWatchpoint();
<span class="line-new-header">--- 1948,25 ---</span>
      auto invalidateWatchpoint = [&amp;] {
          m_arraySpeciesWatchpointSet.invalidate(vm, StringFireDetail(&quot;Was not able to set up array species watchpoint.&quot;));
      };
  
      PropertySlot constructorSlot(arrayPrototype, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!     arrayPrototype-&gt;getOwnPropertySlot(arrayPrototype, this, vm.propertyNames-&gt;constructor, constructorSlot);</span>
      scope.assertNoException();
      if (constructorSlot.slotBase() != arrayPrototype
          || !constructorSlot.isCacheableValue()
<span class="line-modified">!         || constructorSlot.getValue(this, vm.propertyNames-&gt;constructor) != arrayConstructor) {</span>
          invalidateWatchpoint();
          return;
      }
  
      Structure* constructorStructure = arrayConstructor-&gt;structure(vm);
      if (constructorStructure-&gt;isDictionary())
          constructorStructure = constructorStructure-&gt;flattenDictionaryStructure(vm, arrayConstructor);
  
      PropertySlot speciesSlot(arrayConstructor, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!     arrayConstructor-&gt;getOwnPropertySlot(arrayConstructor, this, vm.propertyNames-&gt;speciesSymbol, speciesSlot);</span>
      scope.assertNoException();
      if (speciesSlot.slotBase() != arrayConstructor
          || !speciesSlot.isCacheableGetter()
          || speciesSlot.getterSetter() != speciesGetterSetter()) {
          invalidateWatchpoint();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1943,10 ***</span>
<span class="line-new-header">--- 1994,47 ---</span>
  
      m_arrayConstructorSpeciesWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, speciesCondition, m_arraySpeciesWatchpointSet);
      m_arrayConstructorSpeciesWatchpoint-&gt;install(vm);
  }
  
<span class="line-added">+ void JSGlobalObject::installNumberPrototypeWatchpoint(NumberPrototype* numberPrototype)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = this-&gt;vm();</span>
<span class="line-added">+     ASSERT(m_numberToStringWatchpointSet.isStillValid());</span>
<span class="line-added">+     ObjectPropertyCondition condition = setupAdaptiveWatchpoint(this, numberPrototype, vm.propertyNames-&gt;toString);</span>
<span class="line-added">+     m_numberPrototypeToStringWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_numberToStringWatchpointSet);</span>
<span class="line-added">+     m_numberPrototypeToStringWatchpoint-&gt;install(vm);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JSGlobalObject::installMapPrototypeWatchpoint(MapPrototype* mapPrototype)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = this-&gt;vm();</span>
<span class="line-added">+     if (m_mapIteratorProtocolWatchpointSet.isStillValid()) {</span>
<span class="line-added">+         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(this, mapPrototype, vm.propertyNames-&gt;iteratorSymbol);</span>
<span class="line-added">+         m_mapPrototypeSymbolIteratorWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_mapIteratorProtocolWatchpointSet);</span>
<span class="line-added">+         m_mapPrototypeSymbolIteratorWatchpoint-&gt;install(vm);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     ASSERT(m_mapSetWatchpointSet.isStillValid());</span>
<span class="line-added">+     ObjectPropertyCondition condition = setupAdaptiveWatchpoint(this, mapPrototype, vm.propertyNames-&gt;set);</span>
<span class="line-added">+     m_mapPrototypeSetWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_mapSetWatchpointSet);</span>
<span class="line-added">+     m_mapPrototypeSetWatchpoint-&gt;install(vm);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JSGlobalObject::installSetPrototypeWatchpoint(SetPrototype* setPrototype)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = this-&gt;vm();</span>
<span class="line-added">+     if (m_setIteratorProtocolWatchpointSet.isStillValid()) {</span>
<span class="line-added">+         ObjectPropertyCondition condition = setupAdaptiveWatchpoint(this, setPrototype, vm.propertyNames-&gt;iteratorSymbol);</span>
<span class="line-added">+         m_setPrototypeSymbolIteratorWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_setIteratorProtocolWatchpointSet);</span>
<span class="line-added">+         m_setPrototypeSymbolIteratorWatchpoint-&gt;install(vm);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     ASSERT(m_setAddWatchpointSet.isStillValid());</span>
<span class="line-added">+     ObjectPropertyCondition condition = setupAdaptiveWatchpoint(this, setPrototype, vm.propertyNames-&gt;add);</span>
<span class="line-added">+     m_setPrototypeAddWatchpoint = makeUnique&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt;(this, condition, m_setAddWatchpointSet);</span>
<span class="line-added">+     m_setPrototypeAddWatchpoint-&gt;install(vm);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void slowValidateCell(JSGlobalObject* globalObject)
  {
      RELEASE_ASSERT(globalObject-&gt;isGlobalObject());
      ASSERT_GC_OBJECT_INHERITS(globalObject, JSGlobalObject::info());
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1976,98 ***</span>
  #if ENABLE(REMOTE_INSPECTOR)
      m_inspectorDebuggable-&gt;update();
  #endif
  }
  
<span class="line-removed">- # if ENABLE(INTL)</span>
<span class="line-removed">- static void addMissingScriptLocales(HashSet&lt;String&gt;&amp; availableLocales)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (availableLocales.contains(&quot;pa-Arab-PK&quot;))</span>
<span class="line-removed">-         availableLocales.add(&quot;pa-PK&quot;_s);</span>
<span class="line-removed">-     if (availableLocales.contains(&quot;zh-Hans-CN&quot;))</span>
<span class="line-removed">-         availableLocales.add(&quot;zh-CN&quot;_s);</span>
<span class="line-removed">-     if (availableLocales.contains(&quot;zh-Hant-HK&quot;))</span>
<span class="line-removed">-         availableLocales.add(&quot;zh-HK&quot;_s);</span>
<span class="line-removed">-     if (availableLocales.contains(&quot;zh-Hans-SG&quot;))</span>
<span class="line-removed">-         availableLocales.add(&quot;zh-SG&quot;_s);</span>
<span class="line-removed">-     if (availableLocales.contains(&quot;zh-Hant-TW&quot;))</span>
<span class="line-removed">-         availableLocales.add(&quot;zh-TW&quot;_s);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- const HashSet&lt;String&gt;&amp; JSGlobalObject::intlCollatorAvailableLocales()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_intlCollatorAvailableLocales.isEmpty()) {</span>
<span class="line-removed">-         int32_t count = ucol_countAvailable();</span>
<span class="line-removed">-         for (int32_t i = 0; i &lt; count; ++i) {</span>
<span class="line-removed">-             String locale = convertICULocaleToBCP47LanguageTag(ucol_getAvailable(i));</span>
<span class="line-removed">-             if (!locale.isEmpty())</span>
<span class="line-removed">-                 m_intlCollatorAvailableLocales.add(locale);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         addMissingScriptLocales(m_intlCollatorAvailableLocales);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return m_intlCollatorAvailableLocales;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- const HashSet&lt;String&gt;&amp; JSGlobalObject::intlDateTimeFormatAvailableLocales()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_intlDateTimeFormatAvailableLocales.isEmpty()) {</span>
<span class="line-removed">-         int32_t count = udat_countAvailable();</span>
<span class="line-removed">-         for (int32_t i = 0; i &lt; count; ++i) {</span>
<span class="line-removed">-             String locale = convertICULocaleToBCP47LanguageTag(udat_getAvailable(i));</span>
<span class="line-removed">-             if (!locale.isEmpty())</span>
<span class="line-removed">-                 m_intlDateTimeFormatAvailableLocales.add(locale);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         addMissingScriptLocales(m_intlDateTimeFormatAvailableLocales);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return m_intlDateTimeFormatAvailableLocales;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- const HashSet&lt;String&gt;&amp; JSGlobalObject::intlNumberFormatAvailableLocales()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_intlNumberFormatAvailableLocales.isEmpty()) {</span>
<span class="line-removed">-         int32_t count = unum_countAvailable();</span>
<span class="line-removed">-         for (int32_t i = 0; i &lt; count; ++i) {</span>
<span class="line-removed">-             String locale = convertICULocaleToBCP47LanguageTag(unum_getAvailable(i));</span>
<span class="line-removed">-             if (!locale.isEmpty())</span>
<span class="line-removed">-                 m_intlNumberFormatAvailableLocales.add(locale);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         addMissingScriptLocales(m_intlNumberFormatAvailableLocales);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return m_intlNumberFormatAvailableLocales;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- const HashSet&lt;String&gt;&amp; JSGlobalObject::intlPluralRulesAvailableLocales()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_intlPluralRulesAvailableLocales.isEmpty()) {</span>
<span class="line-removed">-         int32_t count = uloc_countAvailable();</span>
<span class="line-removed">-         for (int32_t i = 0; i &lt; count; ++i) {</span>
<span class="line-removed">-             String locale = convertICULocaleToBCP47LanguageTag(uloc_getAvailable(i));</span>
<span class="line-removed">-             if (!locale.isEmpty())</span>
<span class="line-removed">-                 m_intlPluralRulesAvailableLocales.add(locale);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         addMissingScriptLocales(m_intlPluralRulesAvailableLocales);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return m_intlPluralRulesAvailableLocales;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- IntlCollator* JSGlobalObject::defaultCollator(ExecState* exec)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_defaultCollator)</span>
<span class="line-removed">-         return m_defaultCollator.get();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     IntlCollator* collator = IntlCollator::create(vm, collatorStructure());</span>
<span class="line-removed">-     collator-&gt;initializeCollator(*exec, jsUndefined(), jsUndefined());</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-removed">-     m_defaultCollator.set(vm, this, collator);</span>
<span class="line-removed">-     return collator;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #endif // ENABLE(INTL)</span>
<span class="line-removed">- </span>
  void JSGlobalObject::bumpGlobalLexicalBindingEpoch(VM&amp; vm)
  {
      if (++m_globalLexicalBindingEpoch == Options::thresholdForGlobalLexicalBindingEpoch()) {
          // Since the epoch overflows, we should rewrite all the CodeBlock to adjust to the newly started generation.
          m_globalLexicalBindingEpoch = 1;
<span class="line-new-header">--- 2064,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2133,11 ***</span>
  {
      Base::finishCreation(vm);
      structure(vm)-&gt;setGlobalObject(vm, this);
      m_runtimeFlags = m_globalObjectMethodTable-&gt;javaScriptRuntimeFlags(this);
      init(vm);
<span class="line-modified">!     setGlobalThis(vm, JSNonDestructibleProxy::create(vm, JSNonDestructibleProxy::createStructure(vm, this, getPrototypeDirect(vm), PureForwardingProxyType), this));</span>
      ASSERT(type() == GlobalObjectType);
  }
  
  void JSGlobalObject::finishCreation(VM&amp; vm, JSObject* thisValue)
  {
<span class="line-new-header">--- 2133,11 ---</span>
  {
      Base::finishCreation(vm);
      structure(vm)-&gt;setGlobalObject(vm, this);
      m_runtimeFlags = m_globalObjectMethodTable-&gt;javaScriptRuntimeFlags(this);
      init(vm);
<span class="line-modified">!     setGlobalThis(vm, JSProxy::create(vm, JSProxy::createStructure(vm, this, getPrototypeDirect(vm), PureForwardingProxyType), this));</span>
      ASSERT(type() == GlobalObjectType);
  }
  
  void JSGlobalObject::finishCreation(VM&amp; vm, JSObject* thisValue)
  {
</pre>
<center><a href="JSGlobalLexicalEnvironment.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGlobalObject.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrPattern.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="YarrParser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="generateYarrCanonicalizeUnicode.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrPattern.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1105                 for (termIndex = terms.size() - 1; termIndex &gt;= endIndex; --termIndex)
1106                     terms.remove(termIndex);
1107 
1108                 for (termIndex = firstExpressionTerm; termIndex &gt; 0; --termIndex)
1109                     terms.remove(termIndex - 1);
1110 
1111                 terms.append(PatternTerm(startsWithBOL, endsWithEOL));
1112 
1113                 m_pattern.m_containsBOL = false;
1114             }
1115         }
1116     }
1117 
1118     ErrorCode error() { return m_error; }
1119 
1120 private:
1121     bool isSafeToRecurse() const
1122     {
1123         if (!m_stackLimit)
1124             return true;
<span class="line-removed">1125         ASSERT(Thread::current().stack().isGrowingDownward());</span>
1126         int8_t* curr = reinterpret_cast&lt;int8_t*&gt;(currentStackPointer());
1127         int8_t* limit = reinterpret_cast&lt;int8_t*&gt;(m_stackLimit);
1128         return curr &gt;= limit;
1129     }
1130 
1131     YarrPattern&amp; m_pattern;
1132     PatternAlternative* m_alternative;
1133     CharacterClassConstructor m_characterClassConstructor;
1134     Vector&lt;String&gt; m_unmatchedNamedForwardReferences;
1135     void* m_stackLimit;
1136     ErrorCode m_error { ErrorCode::NoError };
1137     bool m_invertCharacterClass;
1138     bool m_invertParentheticalAssertion { false };
1139 };
1140 
1141 ErrorCode YarrPattern::compile(const String&amp; patternString, void* stackLimit)
1142 {
1143     YarrPatternConstructor constructor(*this, stackLimit);
1144 
1145     {
</pre>
<hr />
<pre>
1161         constructor.saveUnmatchedNamedForwardReferences();
1162         constructor.resetForReparsing();
1163         ErrorCode error = parse(constructor, patternString, unicode(), numSubpatterns);
1164         ASSERT_UNUSED(error, !hasError(error));
1165         ASSERT(numSubpatterns == m_numSubpatterns);
1166     }
1167 
1168     constructor.checkForTerminalParentheses();
1169     constructor.optimizeDotStarWrappedExpressions();
1170     constructor.optimizeBOL();
1171 
1172     if (hasError(constructor.error()))
1173         return constructor.error();
1174 
1175     {
1176         ErrorCode error = constructor.setupOffsets();
1177         if (hasError(error))
1178             return error;
1179     }
1180 
<span class="line-modified">1181     if (Options::dumpCompiledRegExpPatterns())</span>
1182         dumpPattern(patternString);
1183 
1184     return ErrorCode::NoError;
1185 }
1186 
1187 YarrPattern::YarrPattern(const String&amp; pattern, OptionSet&lt;Flags&gt; flags, ErrorCode&amp; error, void* stackLimit)
1188     : m_containsBackreferences(false)
1189     , m_containsBOL(false)
1190     , m_containsUnsignedLengthPattern(false)
1191     , m_hasCopiedParenSubexpressions(false)
1192     , m_saveInitialStartValue(false)
1193     , m_flags(flags)
1194 {
1195     ASSERT(m_flags != Flags::DeletedValue);
1196     error = compile(pattern, stackLimit);
1197 }
1198 
1199 void indentForNestingLevel(PrintStream&amp; out, unsigned nestingDepth)
1200 {
1201     out.print(&quot;    &quot;);
</pre>
</td>
<td>
<hr />
<pre>
1105                 for (termIndex = terms.size() - 1; termIndex &gt;= endIndex; --termIndex)
1106                     terms.remove(termIndex);
1107 
1108                 for (termIndex = firstExpressionTerm; termIndex &gt; 0; --termIndex)
1109                     terms.remove(termIndex - 1);
1110 
1111                 terms.append(PatternTerm(startsWithBOL, endsWithEOL));
1112 
1113                 m_pattern.m_containsBOL = false;
1114             }
1115         }
1116     }
1117 
1118     ErrorCode error() { return m_error; }
1119 
1120 private:
1121     bool isSafeToRecurse() const
1122     {
1123         if (!m_stackLimit)
1124             return true;

1125         int8_t* curr = reinterpret_cast&lt;int8_t*&gt;(currentStackPointer());
1126         int8_t* limit = reinterpret_cast&lt;int8_t*&gt;(m_stackLimit);
1127         return curr &gt;= limit;
1128     }
1129 
1130     YarrPattern&amp; m_pattern;
1131     PatternAlternative* m_alternative;
1132     CharacterClassConstructor m_characterClassConstructor;
1133     Vector&lt;String&gt; m_unmatchedNamedForwardReferences;
1134     void* m_stackLimit;
1135     ErrorCode m_error { ErrorCode::NoError };
1136     bool m_invertCharacterClass;
1137     bool m_invertParentheticalAssertion { false };
1138 };
1139 
1140 ErrorCode YarrPattern::compile(const String&amp; patternString, void* stackLimit)
1141 {
1142     YarrPatternConstructor constructor(*this, stackLimit);
1143 
1144     {
</pre>
<hr />
<pre>
1160         constructor.saveUnmatchedNamedForwardReferences();
1161         constructor.resetForReparsing();
1162         ErrorCode error = parse(constructor, patternString, unicode(), numSubpatterns);
1163         ASSERT_UNUSED(error, !hasError(error));
1164         ASSERT(numSubpatterns == m_numSubpatterns);
1165     }
1166 
1167     constructor.checkForTerminalParentheses();
1168     constructor.optimizeDotStarWrappedExpressions();
1169     constructor.optimizeBOL();
1170 
1171     if (hasError(constructor.error()))
1172         return constructor.error();
1173 
1174     {
1175         ErrorCode error = constructor.setupOffsets();
1176         if (hasError(error))
1177             return error;
1178     }
1179 
<span class="line-modified">1180     if (UNLIKELY(Options::dumpCompiledRegExpPatterns()))</span>
1181         dumpPattern(patternString);
1182 
1183     return ErrorCode::NoError;
1184 }
1185 
1186 YarrPattern::YarrPattern(const String&amp; pattern, OptionSet&lt;Flags&gt; flags, ErrorCode&amp; error, void* stackLimit)
1187     : m_containsBackreferences(false)
1188     , m_containsBOL(false)
1189     , m_containsUnsignedLengthPattern(false)
1190     , m_hasCopiedParenSubexpressions(false)
1191     , m_saveInitialStartValue(false)
1192     , m_flags(flags)
1193 {
1194     ASSERT(m_flags != Flags::DeletedValue);
1195     error = compile(pattern, stackLimit);
1196 }
1197 
1198 void indentForNestingLevel(PrintStream&amp; out, unsigned nestingDepth)
1199 {
1200     out.print(&quot;    &quot;);
</pre>
</td>
</tr>
</table>
<center><a href="YarrParser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="generateYarrCanonicalizeUnicode.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
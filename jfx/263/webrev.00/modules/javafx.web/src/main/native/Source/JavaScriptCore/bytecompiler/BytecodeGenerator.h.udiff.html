<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/BytecodeGenerator.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BytecodeGenerator.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Label.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/BytecodeGenerator.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -28,26 +28,29 @@</span>
   * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  #pragma once
  
<span class="udiff-line-added">+ #include &quot;BytecodeGeneratorBase.h&quot;</span>
<span class="udiff-line-added">+ #include &quot;BytecodeStructs.h&quot;</span>
  #include &quot;CodeBlock.h&quot;
  #include &quot;Instruction.h&quot;
  #include &quot;Interpreter.h&quot;
<span class="udiff-line-modified-removed">- #include &quot;JSAsyncGeneratorFunction.h&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;JSAsyncGenerator.h&quot;</span>
  #include &quot;JSBigInt.h&quot;
<span class="udiff-line-modified-removed">- #include &quot;JSGeneratorFunction.h&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;JSGenerator.h&quot;</span>
  #include &quot;JSTemplateObjectDescriptor.h&quot;
  #include &quot;Label.h&quot;
  #include &quot;LabelScope.h&quot;
  #include &quot;Nodes.h&quot;
  #include &quot;ParserError.h&quot;
  #include &quot;ProfileTypeBytecodeFlag.h&quot;
  #include &quot;RegisterID.h&quot;
  #include &quot;StaticPropertyAnalyzer.h&quot;
  #include &quot;SymbolTable.h&quot;
  #include &quot;UnlinkedCodeBlock.h&quot;
<span class="udiff-line-added">+ #include &quot;UnlinkedCodeBlockGenerator.h&quot;</span>
  #include &lt;functional&gt;
  #include &lt;wtf/CheckedArithmetic.h&gt;
  #include &lt;wtf/HashFunctions.h&gt;
  #include &lt;wtf/Optional.h&gt;
  #include &lt;wtf/SegmentedVector.h&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -69,10 +72,11 @@</span>
  
      enum class EmitAwait { Yes, No };
  
      enum class DebuggableCall { Yes, No };
      enum class ThisResolutionType { Local, Scoped };
<span class="udiff-line-added">+     enum class LinkTimeConstant : int32_t;</span>
  
      class CallArguments {
      public:
          CallArguments(BytecodeGenerator&amp;, ArgumentsNode*, unsigned additionalArguments = 0);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -219,11 +223,11 @@</span>
              , m_bodyBytecodeStartOffset(bodyBytecodeStartOffset)
          { }
  
          unsigned bodyBytecodeStartOffset() const { return m_bodyBytecodeStartOffset; }
  
<span class="udiff-line-modified-removed">-         void finalize(BytecodeGenerator&amp;, UnlinkedCodeBlock*, unsigned bodyBytecodeEndOffset);</span>
<span class="udiff-line-modified-added">+         void finalize(BytecodeGenerator&amp;, UnlinkedCodeBlockGenerator*, unsigned bodyBytecodeEndOffset);</span>
  
      private:
          RefPtr&lt;RegisterID&gt; m_localRegister;
          bool m_isValid { true };
          Type m_type;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -250,11 +254,11 @@</span>
          void addGetInst(unsigned instIndex, int propertyRegIndex)
          {
              m_getInsts.append(GetInst { instIndex, propertyRegIndex });
          }
  
<span class="udiff-line-modified-removed">-         void finalize(BytecodeGenerator&amp;, UnlinkedCodeBlock*, unsigned bodyBytecodeEndOffset);</span>
<span class="udiff-line-modified-added">+         void finalize(BytecodeGenerator&amp;, UnlinkedCodeBlockGenerator*, unsigned bodyBytecodeEndOffset);</span>
  
      private:
          RefPtr&lt;RegisterID&gt; m_indexRegister;
          RefPtr&lt;RegisterID&gt; m_propertyRegister;
          RefPtr&lt;RegisterID&gt; m_enumeratorRegister;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -270,11 +274,11 @@</span>
          {
          }
  
          RegisterID* index() const { return m_indexRegister.get(); }
  
<span class="udiff-line-modified-removed">-         void finalize(BytecodeGenerator&amp;, UnlinkedCodeBlock*, unsigned bodyBytecodeEndOffset);</span>
<span class="udiff-line-modified-added">+         void finalize(BytecodeGenerator&amp;, UnlinkedCodeBlockGenerator*, unsigned bodyBytecodeEndOffset);</span>
          void addGetInst(unsigned instIndex, int propertyIndex) { m_getInsts.append({ instIndex, propertyIndex }); }
  
      private:
          RefPtr&lt;RegisterID&gt; m_indexRegister;
          Vector&lt;std::pair&lt;unsigned, int&gt;&gt; m_getInsts;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -358,17 +362,24 @@</span>
          Ref&lt;Label&gt; start;
          Ref&lt;Label&gt; end;
          TryData* tryData;
      };
  
<span class="udiff-line-modified-removed">-     class BytecodeGenerator {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     struct JSGeneratorTraits {</span>
<span class="udiff-line-added">+         using OpcodeTraits = JSOpcodeTraits;</span>
<span class="udiff-line-added">+         using OpcodeID = ::JSC::OpcodeID;</span>
<span class="udiff-line-added">+         using OpNop = ::JSC::OpNop;</span>
<span class="udiff-line-added">+         using CodeBlock = std::unique_ptr&lt;UnlinkedCodeBlockGenerator&gt;;</span>
<span class="udiff-line-added">+         static constexpr OpcodeID opcodeForDisablingOptimizations = op_end;</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     class BytecodeGenerator : public BytecodeGeneratorBase&lt;JSGeneratorTraits&gt; {</span>
          WTF_MAKE_FAST_ALLOCATED;
          WTF_MAKE_NONCOPYABLE(BytecodeGenerator);
  
<span class="udiff-line-removed">-         friend class BoundLabel;</span>
          friend class FinallyContext;
<span class="udiff-line-removed">-         friend class Label;</span>
          friend class IndexedForInContext;
          friend class StructureForInContext;
      public:
          typedef DeclarationStacks::FunctionStack FunctionStack;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -390,10 +401,11 @@</span>
          bool usesEval() const { return m_scopeNode-&gt;usesEval(); }
          bool usesThis() const { return m_scopeNode-&gt;usesThis(); }
          ConstructorKind constructorKind() const { return m_codeBlock-&gt;constructorKind(); }
          SuperBinding superBinding() const { return m_codeBlock-&gt;superBinding(); }
          JSParserScriptMode scriptMode() const { return m_codeBlock-&gt;scriptMode(); }
<span class="udiff-line-added">+         NeedsClassFieldInitializer needsClassFieldInitializer() const { return m_codeBlock-&gt;needsClassFieldInitializer(); }</span>
  
          template&lt;typename Node, typename UnlinkedCodeBlock&gt;
          static ParserError generate(VM&amp; vm, Node* node, const SourceCode&amp; sourceCode, UnlinkedCodeBlock* unlinkedCodeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* environment)
          {
              MonotonicTime before;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -429,17 +441,11 @@</span>
  
          RegisterID* scopeRegister() { return m_scopeRegister; }
  
          RegisterID* generatorRegister() { return m_generatorRegister; }
  
<span class="udiff-line-modified-removed">-         RegisterID* promiseCapabilityRegister() { return m_promiseCapabilityRegister; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Returns the next available temporary register. Registers returned by</span>
<span class="udiff-line-removed">-         // newTemporary require a modified form of reference counting: any</span>
<span class="udiff-line-removed">-         // register with a refcount of 0 is considered &quot;available&quot;, meaning that</span>
<span class="udiff-line-removed">-         // the next instruction may overwrite it.</span>
<span class="udiff-line-removed">-         RegisterID* newTemporary();</span>
<span class="udiff-line-modified-added">+         RegisterID* promiseRegister() { return m_promiseRegister; }</span>
  
          // The same as newTemporary(), but this function returns &quot;suggestion&quot; if
          // &quot;suggestion&quot; is a temporary. This function is helpful in situations
          // where you&#39;ve put &quot;suggestion&quot; in a RefPtr, but you&#39;d like to allow
          // the next instruction to overwrite it anyway.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -486,12 +492,10 @@</span>
          {
              return dst == ignoredResult() ? nullptr : (dst &amp;&amp; dst != src) ? emitMove(dst, src) : src;
          }
  
          Ref&lt;LabelScope&gt; newLabelScope(LabelScope::Type, const Identifier* = 0);
<span class="udiff-line-removed">-         Ref&lt;Label&gt; newLabel();</span>
<span class="udiff-line-removed">-         Ref&lt;Label&gt; newEmittedLabel();</span>
  
          void emitNode(RegisterID* dst, StatementNode* n)
          {
              SetForScope&lt;bool&gt; tailPositionPoisoner(m_inTailPosition, false);
              return emitNodeInTailPosition(dst, n);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -508,12 +512,10 @@</span>
              if (UNLIKELY(n-&gt;needsDebugHook()))
                  emitDebugHook(n);
              n-&gt;emitBytecode(*this, dst);
          }
  
<span class="udiff-line-removed">-         void recordOpcode(OpcodeID);</span>
<span class="udiff-line-removed">- </span>
          ALWAYS_INLINE unsigned addMetadataFor(OpcodeID opcodeID)
          {
              return m_codeBlock-&gt;metadata().addEntry(opcodeID);
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -552,18 +554,18 @@</span>
          RegisterID* emitNodeInTailPosition(ExpressionNode* n)
          {
              return emitNodeInTailPosition(nullptr, n);
          }
  
<span class="udiff-line-modified-removed">-         RegisterID* emitDefineClassElements(PropertyListNode* n, RegisterID* constructor, RegisterID* prototype)</span>
<span class="udiff-line-modified-added">+         RegisterID* emitDefineClassElements(PropertyListNode* n, RegisterID* constructor, RegisterID* prototype, Vector&lt;JSTextPosition&gt;&amp; instanceFieldLocations)</span>
          {
              ASSERT(constructor-&gt;refCount() &amp;&amp; prototype-&gt;refCount());
              if (UNLIKELY(!m_vm.isSafeToRecurse()))
                  return emitThrowExpressionTooDeepException();
              if (UNLIKELY(n-&gt;needsDebugHook()))
                  emitDebugHook(n);
<span class="udiff-line-modified-removed">-             return n-&gt;emitBytecode(*this, constructor, prototype);</span>
<span class="udiff-line-modified-added">+             return n-&gt;emitBytecode(*this, constructor, prototype, &amp;instanceFieldLocations);</span>
          }
  
          RegisterID* emitNodeForProperty(RegisterID* dst, ExpressionNode* node)
          {
              if (node-&gt;isString()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -590,10 +592,13 @@</span>
          void emitExpressionInfo(const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)
          {
              ASSERT(divot.offset &gt;= divotStart.offset);
              ASSERT(divotEnd.offset &gt;= divot.offset);
  
<span class="udiff-line-added">+             if (m_isBuiltinFunction)</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+ </span>
              int sourceOffset = m_scopeNode-&gt;source().startOffset();
              unsigned firstLine = m_scopeNode-&gt;source().firstLine().oneBasedInt();
  
              int divotOffset = divot.offset - sourceOffset;
              int startOffset = divot.offset - divotStart.offset;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -613,12 +618,11 @@</span>
                  return;
  
              unsigned column = divotOffset - lineStart;
  
              unsigned instructionOffset = instructions().size();
<span class="udiff-line-modified-removed">-             if (!m_isBuiltinFunction)</span>
<span class="udiff-line-removed">-                 m_codeBlock-&gt;addExpressionInfo(instructionOffset, divotOffset, startOffset, endOffset, line, column);</span>
<span class="udiff-line-modified-added">+             m_codeBlock-&gt;addExpressionInfo(instructionOffset, divotOffset, startOffset, endOffset, line, column);</span>
          }
  
  
          ALWAYS_INLINE bool leftHandSideNeedsCopy(bool rightHasAssignments, bool rightIsPure)
          {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -680,11 +684,11 @@</span>
          {
              UnaryOp::emit(this, dst, src);
              return dst;
          }
  
<span class="udiff-line-modified-removed">-         RegisterID* emitUnaryOp(OpcodeID, RegisterID* dst, RegisterID* src, OperandTypes);</span>
<span class="udiff-line-modified-added">+         RegisterID* emitUnaryOp(OpcodeID, RegisterID* dst, RegisterID* src, ResultType);</span>
  
          template&lt;typename BinaryOp&gt;
          std::enable_if_t&lt;
              BinaryOp::opcodeID != op_add
              &amp;&amp; BinaryOp::opcodeID != op_mul
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -721,34 +725,44 @@</span>
          }
  
          bool emitEqualityOpImpl(RegisterID* dst, RegisterID* src1, RegisterID* src2);
  
          RegisterID* emitCreateThis(RegisterID* dst);
<span class="udiff-line-added">+         RegisterID* emitCreatePromise(RegisterID* dst, RegisterID* newTarget, bool isInternalPromise);</span>
<span class="udiff-line-added">+         RegisterID* emitCreateGenerator(RegisterID* dst, RegisterID* newTarget);</span>
<span class="udiff-line-added">+         RegisterID* emitCreateAsyncGenerator(RegisterID* dst, RegisterID* newTarget);</span>
<span class="udiff-line-added">+         RegisterID* emitCreateArgumentsButterfly(RegisterID* dst);</span>
<span class="udiff-line-added">+         RegisterID* emitInstanceFieldInitializationIfNeeded(RegisterID* dst, RegisterID* constructor, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);</span>
          void emitTDZCheck(RegisterID* target);
          bool needsTDZCheck(const Variable&amp;);
          void emitTDZCheckIfNecessary(const Variable&amp;, RegisterID* target, RegisterID* scope);
          void liftTDZCheckIfPossible(const Variable&amp;);
          RegisterID* emitNewObject(RegisterID* dst);
<span class="udiff-line-added">+         RegisterID* emitNewPromise(RegisterID* dst, bool isInternalPromise);</span>
<span class="udiff-line-added">+         RegisterID* emitNewGenerator(RegisterID* dst);</span>
          RegisterID* emitNewArray(RegisterID* dst, ElementNode*, unsigned length, IndexingType recommendedIndexingType); // stops at first elision
          RegisterID* emitNewArrayBuffer(RegisterID* dst, JSImmutableButterfly*, IndexingType recommendedIndexingType);
          // FIXME: new_array_with_spread should use an array allocation profile and take a recommendedIndexingType
          RegisterID* emitNewArrayWithSpread(RegisterID* dst, ElementNode*);
          RegisterID* emitNewArrayWithSize(RegisterID* dst, RegisterID* length);
  
          RegisterID* emitNewFunction(RegisterID* dst, FunctionMetadataNode*);
          RegisterID* emitNewFunctionExpression(RegisterID* dst, FuncExprNode*);
<span class="udiff-line-modified-removed">-         RegisterID* emitNewDefaultConstructor(RegisterID* dst, ConstructorKind, const Identifier&amp; name, const Identifier&amp; ecmaName, const SourceCode&amp; classSource);</span>
<span class="udiff-line-modified-added">+         RegisterID* emitNewDefaultConstructor(RegisterID* dst, ConstructorKind, const Identifier&amp; name, const Identifier&amp; ecmaName, const SourceCode&amp; classSource, NeedsClassFieldInitializer);</span>
<span class="udiff-line-added">+         RegisterID* emitNewInstanceFieldInitializerFunction(RegisterID* dst, Vector&lt;JSTextPosition&gt;&amp;&amp; instanceFieldLocations, bool isDerived);</span>
          RegisterID* emitNewArrowFunctionExpression(RegisterID*, ArrowFuncExprNode*);
          RegisterID* emitNewMethodDefinition(RegisterID* dst, MethodDefinitionNode*);
          RegisterID* emitNewRegExp(RegisterID* dst, RegExp*);
  
          void emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, RegisterID* name);
<span class="udiff-line-added">+         void emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, const Identifier&amp;);</span>
  
          RegisterID* moveLinkTimeConstant(RegisterID* dst, LinkTimeConstant);
          RegisterID* moveEmptyValue(RegisterID* dst);
  
          RegisterID* emitToNumber(RegisterID* dst, RegisterID* src);
<span class="udiff-line-added">+         RegisterID* emitToNumeric(RegisterID* dst, RegisterID* src);</span>
          RegisterID* emitToString(RegisterID* dst, RegisterID* src);
          RegisterID* emitToObject(RegisterID* dst, RegisterID* src, const Identifier&amp; message);
          RegisterID* emitInc(RegisterID* srcDst);
          RegisterID* emitDec(RegisterID* srcDst);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -772,10 +786,13 @@</span>
          RegisterID* emitPutByVal(RegisterID* base, RegisterID* property, RegisterID* value);
          RegisterID* emitPutByVal(RegisterID* base, RegisterID* thisValue, RegisterID* property, RegisterID* value);
          RegisterID* emitDirectPutByVal(RegisterID* base, RegisterID* property, RegisterID* value);
          RegisterID* emitDeleteByVal(RegisterID* dst, RegisterID* base, RegisterID* property);
  
<span class="udiff-line-added">+         RegisterID* emitGetInternalField(RegisterID* dst, RegisterID* base, unsigned index);</span>
<span class="udiff-line-added">+         RegisterID* emitPutInternalField(RegisterID* base, unsigned index, RegisterID* value);</span>
<span class="udiff-line-added">+ </span>
          void emitSuperSamplerBegin();
          void emitSuperSamplerEnd();
  
          RegisterID* emitIdWithProfile(RegisterID* src, SpeculatedType profile);
          void emitUnreachable();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -819,10 +836,11 @@</span>
          RegisterID* emitEnd(RegisterID* src);
  
          RegisterID* emitConstruct(RegisterID* dst, RegisterID* func, RegisterID* lazyThis, ExpectedFunction, CallArguments&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
          RegisterID* emitStrcat(RegisterID* dst, RegisterID* src, int count);
          void emitToPrimitive(RegisterID* dst, RegisterID* src);
<span class="udiff-line-added">+         RegisterID* emitToPropertyKey(RegisterID* dst, RegisterID* src);</span>
  
          ResolveType resolveType();
          RegisterID* emitResolveConstantLocal(RegisterID* dst, const Variable&amp;);
          RegisterID* emitResolveScope(RegisterID* dst, const Variable&amp;);
          RegisterID* emitGetFromScope(RegisterID* dst, RegisterID* scope, const Variable&amp;, ResolveMode);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -830,11 +848,10 @@</span>
  
          RegisterID* emitResolveScopeForHoistingFuncDeclInEval(RegisterID* dst, const Identifier&amp;);
  
          RegisterID* initializeVariable(const Variable&amp;, RegisterID* value);
  
<span class="udiff-line-removed">-         void emitLabel(Label&amp;);</span>
          void emitLoopHint();
          void emitJump(Label&amp; target);
          void emitJumpIfTrue(RegisterID* cond, Label&amp; target);
          void emitJumpIfFalse(RegisterID* cond, Label&amp; target);
          void emitJumpIfNotFunctionCall(RegisterID* cond, Label&amp; target);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -845,10 +862,11 @@</span>
  
          template&lt;typename UnaryOp, typename JmpOp&gt;
          bool fuseTestAndJmp(RegisterID* cond, Label&amp; target);
  
          void emitEnter();
<span class="udiff-line-added">+         void emitCheckTraps();</span>
  
          RegisterID* emitHasIndexedProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName);
          RegisterID* emitHasStructureProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName, RegisterID* enumerator);
          RegisterID* emitHasGenericProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName);
          RegisterID* emitGetPropertyEnumerator(RegisterID* dst, RegisterID* base);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -858,15 +876,20 @@</span>
          RegisterID* emitEnumeratorStructurePropertyName(RegisterID* dst, RegisterID* enumerator, RegisterID* index);
          RegisterID* emitEnumeratorGenericPropertyName(RegisterID* dst, RegisterID* enumerator, RegisterID* index);
          RegisterID* emitToIndexString(RegisterID* dst, RegisterID* index);
  
          RegisterID* emitIsCellWithType(RegisterID* dst, RegisterID* src, JSType);
<span class="udiff-line-added">+         RegisterID* emitIsGenerator(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSGeneratorType); }</span>
<span class="udiff-line-added">+         RegisterID* emitIsAsyncGenerator(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSAsyncGeneratorType); }</span>
          RegisterID* emitIsJSArray(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, ArrayType); }
<span class="udiff-line-added">+         RegisterID* emitIsPromise(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSPromiseType); }</span>
          RegisterID* emitIsProxyObject(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, ProxyObjectType); }
          RegisterID* emitIsRegExpObject(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, RegExpObjectType); }
          RegisterID* emitIsMap(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSMapType); }
          RegisterID* emitIsSet(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSSetType); }
<span class="udiff-line-added">+         RegisterID* emitIsStringIterator(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSStringIteratorType); }</span>
<span class="udiff-line-added">+         RegisterID* emitIsArrayIterator(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSArrayIteratorType); }</span>
          RegisterID* emitIsObject(RegisterID* dst, RegisterID* src);
          RegisterID* emitIsNumber(RegisterID* dst, RegisterID* src);
          RegisterID* emitIsUndefined(RegisterID* dst, RegisterID* src);
          RegisterID* emitIsUndefinedOrNull(RegisterID* dst, RegisterID* src);
          RegisterID* emitIsEmpty(RegisterID* dst, RegisterID* src);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -888,12 +911,12 @@</span>
  
          void emitOutOfLineCatchHandler(RegisterID* thrownValueRegister, RegisterID* completionTypeRegister, TryData*);
          void emitOutOfLineFinallyHandler(RegisterID* exceptionRegister, RegisterID* completionTypeRegister, TryData*);
  
      private:
<span class="udiff-line-modified-removed">-         static const int CurrentLexicalScopeIndex = -2;</span>
<span class="udiff-line-modified-removed">-         static const int OutermostLexicalScopeIndex = -1;</span>
<span class="udiff-line-modified-added">+         static constexpr int CurrentLexicalScopeIndex = -2;</span>
<span class="udiff-line-modified-added">+         static constexpr int OutermostLexicalScopeIndex = -1;</span>
  
          int currentLexicalScopeIndex() const
          {
              int size = static_cast&lt;int&gt;(m_lexicalScopeStack.size());
              ASSERT(static_cast&lt;size_t&gt;(size) == m_lexicalScopeStack.size());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -934,10 +957,11 @@</span>
          void emitPopWithScope();
          void emitPutThisToArrowFunctionContextScope();
          void emitPutNewTargetToArrowFunctionContextScope();
          void emitPutDerivedConstructorToArrowFunctionContextScope();
          RegisterID* emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment();
<span class="udiff-line-added">+         RegisterID* emitLoadDerivedConstructor();</span>
  
          void emitDebugHook(DebugHookType, const JSTextPosition&amp;);
          void emitDebugHook(DebugHookType, unsigned line, unsigned charOffset, unsigned lineStart);
          void emitDebugHook(StatementNode*);
          void emitDebugHook(ExpressionNode*);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -953,10 +977,13 @@</span>
  
          bool emitJumpViaFinallyIfNeeded(int targetLabelScopeDepth, Label&amp; jumpTarget);
          bool emitReturnViaFinallyIfNeeded(RegisterID* returnRegister);
          void emitFinallyCompletion(FinallyContext&amp;, Label&amp; normalCompletionLabel);
  
<span class="udiff-line-added">+         template&lt;typename LazyNameRegisterFn&gt;</span>
<span class="udiff-line-added">+         void emitSetFunctionNameIfNeededImpl(ExpressionNode*, RegisterID*, const LazyNameRegisterFn&amp;);</span>
<span class="udiff-line-added">+ </span>
      public:
          void pushFinallyControlFlowScope(FinallyContext&amp;);
          void popFinallyControlFlowScope();
  
          void pushOptionalChainTarget();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -973,30 +1000,31 @@</span>
          LabelScope* continueTarget(const Identifier&amp;);
  
          void beginSwitch(RegisterID*, SwitchInfo::SwitchType);
          void endSwitch(uint32_t clauseCount, const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp;, ExpressionNode**, Label&amp; defaultLabel, int32_t min, int32_t range);
  
<span class="udiff-line-modified-removed">-         void emitYieldPoint(RegisterID*, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason);</span>
<span class="udiff-line-modified-added">+         void emitYieldPoint(RegisterID*, JSAsyncGenerator::AsyncGeneratorSuspendReason);</span>
  
          void emitGeneratorStateLabel();
          void emitGeneratorStateChange(int32_t state);
<span class="udiff-line-modified-removed">-         RegisterID* emitYield(RegisterID* argument, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason = JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Yield);</span>
<span class="udiff-line-modified-added">+         RegisterID* emitYield(RegisterID* argument, JSAsyncGenerator::AsyncGeneratorSuspendReason = JSAsyncGenerator::AsyncGeneratorSuspendReason::Yield);</span>
          RegisterID* emitDelegateYield(RegisterID* argument, ThrowableExpressionData*);
<span class="udiff-line-modified-removed">-         RegisterID* generatorStateRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::State)]; }</span>
<span class="udiff-line-modified-removed">-         RegisterID* generatorValueRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::Value)]; }</span>
<span class="udiff-line-modified-removed">-         RegisterID* generatorResumeModeRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::ResumeMode)]; }</span>
<span class="udiff-line-modified-removed">-         RegisterID* generatorFrameRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::Frame)]; }</span>
<span class="udiff-line-modified-added">+         RegisterID* generatorStateRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGenerator::GeneratorArgument::State)]; }</span>
<span class="udiff-line-modified-added">+         RegisterID* generatorValueRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGenerator::GeneratorArgument::Value)]; }</span>
<span class="udiff-line-modified-added">+         RegisterID* generatorResumeModeRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGenerator::GeneratorArgument::ResumeMode)]; }</span>
<span class="udiff-line-modified-added">+         RegisterID* generatorFrameRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGenerator::GeneratorArgument::Frame)]; }</span>
  
          CodeType codeType() const { return m_codeType; }
  
          bool shouldBeConcernedWithCompletionValue() const { return m_codeType != FunctionCode; }
  
          bool shouldEmitDebugHooks() const { return m_codeGenerationMode.contains(CodeGenerationMode::Debugger) &amp;&amp; !m_isBuiltinFunction; }
          bool shouldEmitTypeProfilerHooks() const { return m_codeGenerationMode.contains(CodeGenerationMode::TypeProfiler); }
          bool shouldEmitControlFlowProfilerHooks() const { return m_codeGenerationMode.contains(CodeGenerationMode::ControlFlowProfiler); }
  
          bool isStrictMode() const { return m_codeBlock-&gt;isStrictMode(); }
<span class="udiff-line-added">+         void setUsesCheckpoints() { m_codeBlock-&gt;setHasCheckpoints(); }</span>
  
          SourceParseMode parseMode() const { return m_codeBlock-&gt;parseMode(); }
  
          bool isBuiltinFunction() const { return m_isBuiltinFunction; }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1016,11 +1044,10 @@</span>
          void initializeBlockScopedFunctions(VariableEnvironment&amp;, FunctionStack&amp;, RegisterID* constantSymbolTable);
          void popLexicalScopeInternal(VariableEnvironment&amp;);
          template&lt;typename LookUpVarKindFunctor&gt;
          bool instantiateLexicalVariables(const VariableEnvironment&amp;, SymbolTable*, ScopeRegisterType, LookUpVarKindFunctor);
          void emitPrefillStackTDZVariables(const VariableEnvironment&amp;, SymbolTable*);
<span class="udiff-line-removed">-         void emitPopScope(RegisterID* dst, RegisterID* scope);</span>
          RegisterID* emitGetParentScope(RegisterID* dst, RegisterID* scope);
          void emitPushFunctionNameScope(const Identifier&amp; property, RegisterID* value, bool isCaptured);
          void emitNewFunctionExpressionCommon(RegisterID*, FunctionMetadataNode*);
  
          bool isNewTargetUsedInInnerArrowFunction();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1042,11 +1069,10 @@</span>
          int labelScopeDepth() const;
          UnlinkedArrayProfile newArrayProfile();
  
      private:
          ParserError generate();
<span class="udiff-line-removed">-         void reclaimFreeRegisters();</span>
          Variable variableForLocalEntry(const Identifier&amp;, const SymbolTableEntry&amp;, int symbolTableConstantIndex, bool isLexicallyScoped);
  
          RegisterID* kill(RegisterID* dst)
          {
              m_staticPropertyAnalyzer.kill(dst);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1054,11 +1080,10 @@</span>
          }
  
          void retrieveLastUnaryOp(int&amp; dstIndex, int&amp; srcIndex);
          ALWAYS_INLINE void rewind();
  
<span class="udiff-line-removed">-         void allocateCalleeSaveSpace();</span>
          void allocateAndEmitScope();
  
          template&lt;typename JumpOp&gt;
          void setTargetForJumpInstruction(InstructionStream::MutableRef&amp;, int target);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1077,21 +1102,10 @@</span>
  
          template&lt;typename CallOp&gt;
          RegisterID* emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction, CallArguments&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
  
          RegisterID* emitCallIterator(RegisterID* iterator, RegisterID* argument, ThrowableExpressionData*);
<span class="udiff-line-removed">-         RegisterID* newRegister();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Adds an anonymous local var slot. To give this slot a name, add it to symbolTable().</span>
<span class="udiff-line-removed">-         RegisterID* addVar()</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-             ++m_codeBlock-&gt;m_numVars;</span>
<span class="udiff-line-removed">-             RegisterID* result = newRegister();</span>
<span class="udiff-line-removed">-             ASSERT(VirtualRegister(result-&gt;index()).toLocal() == m_codeBlock-&gt;m_numVars - 1);</span>
<span class="udiff-line-removed">-             result-&gt;ref(); // We should never free this slot.</span>
<span class="udiff-line-removed">-             return result;</span>
<span class="udiff-line-removed">-         }</span>
  
          // Initializes the stack form the parameter; does nothing for the symbol table.
          RegisterID* initializeNextParameter();
          UniquedStringImpl* visibleNameForParameter(DestructuringPatternNode*);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1114,13 +1128,16 @@</span>
  
          UnlinkedFunctionExecutable* makeFunction(FunctionMetadataNode* metadata)
          {
              DerivedContextType newDerivedContextType = DerivedContextType::None;
  
<span class="udiff-line-added">+             NeedsClassFieldInitializer needsClassFieldInitializer = metadata-&gt;isConstructorAndNeedsClassFieldInitializer() ? NeedsClassFieldInitializer::Yes : NeedsClassFieldInitializer::No;</span>
              if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode, SourceParseMode::AsyncArrowFunctionBodyMode).contains(metadata-&gt;parseMode())) {
<span class="udiff-line-modified-removed">-                 if (constructorKind() == ConstructorKind::Extends || isDerivedConstructorContext())</span>
<span class="udiff-line-modified-added">+                 if (constructorKind() == ConstructorKind::Extends || isDerivedConstructorContext()) {</span>
                      newDerivedContextType = DerivedContextType::DerivedConstructorContext;
<span class="udiff-line-added">+                     needsClassFieldInitializer = m_codeBlock-&gt;needsClassFieldInitializer();</span>
<span class="udiff-line-added">+                 }</span>
                  else if (m_codeBlock-&gt;isClassContext() || isDerivedClassContext())
                      newDerivedContextType = DerivedContextType::DerivedMethodContext;
              }
  
              Optional&lt;CompactVariableMap::Handle&gt; optionalVariablesUnderTDZ = getVariablesUnderTDZ();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1130,11 +1147,11 @@</span>
              SourceParseMode parseMode = metadata-&gt;parseMode();
              ConstructAbility constructAbility = constructAbilityForParseMode(parseMode);
              if (parseMode == SourceParseMode::MethodMode &amp;&amp; metadata-&gt;constructorKind() != ConstructorKind::None)
                  constructAbility = ConstructAbility::CanConstruct;
  
<span class="udiff-line-modified-removed">-             return UnlinkedFunctionExecutable::create(m_vm, m_scopeNode-&gt;source(), metadata, isBuiltinFunction() ? UnlinkedBuiltinFunction : UnlinkedNormalFunction, constructAbility, scriptMode(), WTFMove(optionalVariablesUnderTDZ), newDerivedContextType);</span>
<span class="udiff-line-modified-added">+             return UnlinkedFunctionExecutable::create(m_vm, m_scopeNode-&gt;source(), metadata, isBuiltinFunction() ? UnlinkedBuiltinFunction : UnlinkedNormalFunction, constructAbility, scriptMode(), WTFMove(optionalVariablesUnderTDZ), newDerivedContextType, needsClassFieldInitializer);</span>
          }
  
          Optional&lt;CompactVariableMap::Handle&gt; getVariablesUnderTDZ();
  
          RegisterID* emitConstructVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1164,19 +1181,10 @@</span>
  
          const InstructionStream&amp; instructions() const { return m_writer; }
  
          RegisterID* emitThrowExpressionTooDeepException();
  
<span class="udiff-line-removed">-         void write(uint8_t byte) { m_writer.write(byte); }</span>
<span class="udiff-line-removed">-         void write(uint16_t h) { m_writer.write(h); }</span>
<span class="udiff-line-removed">-         void write(uint32_t i) { m_writer.write(i); }</span>
<span class="udiff-line-removed">-         void write(int8_t byte) { m_writer.write(static_cast&lt;uint8_t&gt;(byte)); }</span>
<span class="udiff-line-removed">-         void write(int16_t h) { m_writer.write(static_cast&lt;uint16_t&gt;(h)); }</span>
<span class="udiff-line-removed">-         void write(int32_t i) { m_writer.write(static_cast&lt;uint32_t&gt;(i)); }</span>
<span class="udiff-line-removed">-         void alignWideOpcode16();</span>
<span class="udiff-line-removed">-         void alignWideOpcode32();</span>
<span class="udiff-line-removed">- </span>
          class PreservedTDZStack {
          private:
              Vector&lt;TDZMap&gt; m_preservedTDZStack;
              friend class BytecodeGenerator;
          };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1197,12 +1205,10 @@</span>
              m_lastOpcodeID = prevLastOpcodeID;
              m_lastInstruction = prevLastInstruction;
          }
  
      private:
<span class="udiff-line-removed">-         InstructionStreamWriter m_writer;</span>
<span class="udiff-line-removed">- </span>
          OptionSet&lt;CodeGenerationMode&gt; m_codeGenerationMode;
  
          struct LexicalScopeStackEntry {
              SymbolTable* m_symbolTable;
              RegisterID* m_scope;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1214,11 +1220,10 @@</span>
          Vector&lt;TDZMap&gt; m_TDZStack;
          Optional&lt;size_t&gt; m_varScopeLexicalScopeStackIndex;
          void pushTDZVariables(const VariableEnvironment&amp;, TDZCheckOptimization, TDZRequirement);
  
          ScopeNode* const m_scopeNode;
<span class="udiff-line-removed">-         Strong&lt;UnlinkedCodeBlock&gt; m_codeBlock;</span>
  
          // Some of these objects keep pointers to one another. They are arranged
          // to ensure a sane destruction order that avoids references to freed memory.
          HashSet&lt;RefPtr&lt;UniquedStringImpl&gt;, IdentifierRepHash&gt; m_functions;
          RegisterID m_ignoredResultRegister;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1230,22 +1235,19 @@</span>
          RegisterID* m_lexicalEnvironmentRegister { nullptr };
          RegisterID* m_generatorRegister { nullptr };
          RegisterID* m_emptyValueRegister { nullptr };
          RegisterID* m_newTargetRegister { nullptr };
          RegisterID* m_isDerivedConstuctor { nullptr };
<span class="udiff-line-modified-removed">-         RegisterID* m_linkTimeConstantRegisters[LinkTimeConstantCount];</span>
<span class="udiff-line-modified-added">+         HashMap&lt;LinkTimeConstant, RegisterID*, WTF::IntHash&lt;LinkTimeConstant&gt;, WTF::StrongEnumHashTraits&lt;LinkTimeConstant&gt;&gt; m_linkTimeConstantRegisters;</span>
          RegisterID* m_arrowFunctionContextLexicalEnvironmentRegister { nullptr };
<span class="udiff-line-modified-removed">-         RegisterID* m_promiseCapabilityRegister { nullptr };</span>
<span class="udiff-line-modified-added">+         RegisterID* m_promiseRegister { nullptr };</span>
  
          FinallyContext* m_currentFinallyContext { nullptr };
  
<span class="udiff-line-removed">-         SegmentedVector&lt;RegisterID*, 16&gt; m_localRegistersForCalleeSaveRegisters;</span>
<span class="udiff-line-removed">-         SegmentedVector&lt;RegisterID, 32&gt; m_constantPoolRegisters;</span>
<span class="udiff-line-removed">-         SegmentedVector&lt;RegisterID, 32&gt; m_calleeLocals;</span>
          SegmentedVector&lt;RegisterID, 32&gt; m_parameters;
<span class="udiff-line-removed">-         SegmentedVector&lt;Label, 32&gt; m_labels;</span>
          SegmentedVector&lt;LabelScope, 32&gt; m_labelScopes;
<span class="udiff-line-added">+         SegmentedVector&lt;RegisterID, 32&gt; m_constantPoolRegisters;</span>
          unsigned m_finallyDepth { 0 };
          unsigned m_localScopeDepth { 0 };
          const CodeType m_codeType;
  
          unsigned localScopeDepth() const;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1290,13 +1292,10 @@</span>
  
          StaticPropertyAnalyzer m_staticPropertyAnalyzer;
  
          VM&amp; m_vm;
  
<span class="udiff-line-removed">-         OpcodeID m_lastOpcodeID = op_end;</span>
<span class="udiff-line-removed">-         InstructionStream::MutableRef m_lastInstruction { m_writer.ref() };</span>
<span class="udiff-line-removed">- </span>
          bool m_usesExceptions { false };
          bool m_expressionTooDeep { false };
          bool m_isBuiltinFunction { false };
          bool m_usesNonStrictEval { false };
          bool m_inTailPosition { false };
</pre>
<center><a href="BytecodeGenerator.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Label.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
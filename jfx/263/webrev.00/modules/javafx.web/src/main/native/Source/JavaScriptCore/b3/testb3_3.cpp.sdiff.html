<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/testb3_3.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="testb3_2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="testb3_4.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/testb3_3.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 242         Procedure proc;
 243         BasicBlock* root = proc.addBlock();
 244         Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 245         Value* argB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 246         Value* argC = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
 247         Value* andAB = i &amp; 2 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argB)
 248             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argB, argA);
 249         Value* andAC = i &amp; 1 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argC)
 250             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argC, argA);
 251         root-&gt;appendNewControlValue(
 252             proc, Return, Origin(),
 253             root-&gt;appendNew&lt;Value&gt;(
 254                 proc, BitXor, Origin(),
 255                 andAB,
 256                 andAC));
 257 
 258         CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b, c), ((a &amp; b) ^ (a &amp; c)));
 259     }
 260 }
 261 




























 262 void testBitXorAndSameArgs(int64_t a, int64_t b)
 263 {
 264     // We want to check every possible ordering of arguments (to properly check every path in B3ReduceStrength):
 265     // ((a &amp; b) ^ a)
 266     // ((b &amp; a) ^ a)
 267     // (a ^ (a &amp; b))
 268     // (a ^ (b &amp; a))
 269     for (int i = 0; i &lt; 4; ++i) {
 270         Procedure proc;
 271         BasicBlock* root = proc.addBlock();
 272         Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 273         Value* argB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 274         Value* andAB = i &amp; 1 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argB)
 275             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argB, argA);
 276         Value* result = i &amp; 2 ? root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), andAB, argA)
 277             : root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, andAB);
 278         root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 279 
 280         CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b), ((a &amp; b) ^ a));
 281     }
 282 }
 283 






















 284 void testBitXorImms(int64_t a, int64_t b)
 285 {
 286     Procedure proc;
 287     BasicBlock* root = proc.addBlock();
 288     root-&gt;appendNewControlValue(
 289         proc, Return, Origin(),
 290         root-&gt;appendNew&lt;Value&gt;(
 291             proc, BitXor, Origin(),
 292             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
 293             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b)));
 294 
 295     CHECK(compileAndRun&lt;int64_t&gt;(proc) == (a ^ b));
 296 }
 297 
 298 void testBitXorArgImm(int64_t a, int64_t b)
 299 {
 300     Procedure proc;
 301     BasicBlock* root = proc.addBlock();
 302     root-&gt;appendNewControlValue(
 303         proc, Return, Origin(),
</pre>
</td>
<td>
<hr />
<pre>
 242         Procedure proc;
 243         BasicBlock* root = proc.addBlock();
 244         Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 245         Value* argB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 246         Value* argC = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
 247         Value* andAB = i &amp; 2 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argB)
 248             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argB, argA);
 249         Value* andAC = i &amp; 1 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argC)
 250             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argC, argA);
 251         root-&gt;appendNewControlValue(
 252             proc, Return, Origin(),
 253             root-&gt;appendNew&lt;Value&gt;(
 254                 proc, BitXor, Origin(),
 255                 andAB,
 256                 andAC));
 257 
 258         CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b, c), ((a &amp; b) ^ (a &amp; c)));
 259     }
 260 }
 261 
<span class="line-added"> 262 void testBitXorAndAndArgs32(int32_t a, int32_t b, int32_t c)</span>
<span class="line-added"> 263 {</span>
<span class="line-added"> 264     // We want to check every possible ordering of arguments (to properly check every path in B3ReduceStrength):</span>
<span class="line-added"> 265     // ((a &amp; b) ^ (a &amp; c))</span>
<span class="line-added"> 266     // ((a &amp; b) ^ (c &amp; a))</span>
<span class="line-added"> 267     // ((b &amp; a) ^ (a &amp; c))</span>
<span class="line-added"> 268     // ((b &amp; a) ^ (c &amp; a))</span>
<span class="line-added"> 269     for (int i = 0; i &lt; 4; ++i) {</span>
<span class="line-added"> 270         Procedure proc;</span>
<span class="line-added"> 271         BasicBlock* root = proc.addBlock();</span>
<span class="line-added"> 272         Value* argA = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));</span>
<span class="line-added"> 273         Value* argB = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));</span>
<span class="line-added"> 274         Value* argC = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2));</span>
<span class="line-added"> 275         Value* andAB = i &amp; 2 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argB)</span>
<span class="line-added"> 276             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argB, argA);</span>
<span class="line-added"> 277         Value* andAC = i &amp; 1 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argC)</span>
<span class="line-added"> 278             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argC, argA);</span>
<span class="line-added"> 279         root-&gt;appendNewControlValue(</span>
<span class="line-added"> 280             proc, Return, Origin(),</span>
<span class="line-added"> 281             root-&gt;appendNew&lt;Value&gt;(</span>
<span class="line-added"> 282                 proc, BitXor, Origin(),</span>
<span class="line-added"> 283                 andAB,</span>
<span class="line-added"> 284                 andAC));</span>
<span class="line-added"> 285 </span>
<span class="line-added"> 286         CHECK_EQ(compileAndRun&lt;int32_t&gt;(proc, a, b, c), ((a &amp; b) ^ (a &amp; c)));</span>
<span class="line-added"> 287     }</span>
<span class="line-added"> 288 }</span>
<span class="line-added"> 289 </span>
 290 void testBitXorAndSameArgs(int64_t a, int64_t b)
 291 {
 292     // We want to check every possible ordering of arguments (to properly check every path in B3ReduceStrength):
 293     // ((a &amp; b) ^ a)
 294     // ((b &amp; a) ^ a)
 295     // (a ^ (a &amp; b))
 296     // (a ^ (b &amp; a))
 297     for (int i = 0; i &lt; 4; ++i) {
 298         Procedure proc;
 299         BasicBlock* root = proc.addBlock();
 300         Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 301         Value* argB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 302         Value* andAB = i &amp; 1 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argB)
 303             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argB, argA);
 304         Value* result = i &amp; 2 ? root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), andAB, argA)
 305             : root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, andAB);
 306         root-&gt;appendNewControlValue(proc, Return, Origin(), result);
 307 
 308         CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b), ((a &amp; b) ^ a));
 309     }
 310 }
 311 
<span class="line-added"> 312 void testBitXorAndSameArgs32(int32_t a, int32_t b)</span>
<span class="line-added"> 313 {</span>
<span class="line-added"> 314     // We want to check every possible ordering of arguments (to properly check every path in B3ReduceStrength):</span>
<span class="line-added"> 315     // ((a &amp; b) ^ a)</span>
<span class="line-added"> 316     // ((b &amp; a) ^ a)</span>
<span class="line-added"> 317     // (a ^ (a &amp; b))</span>
<span class="line-added"> 318     // (a ^ (b &amp; a))</span>
<span class="line-added"> 319     for (int i = 0; i &lt; 4; ++i) {</span>
<span class="line-added"> 320         Procedure proc;</span>
<span class="line-added"> 321         BasicBlock* root = proc.addBlock();</span>
<span class="line-added"> 322         Value* argA = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));</span>
<span class="line-added"> 323         Value* argB = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));</span>
<span class="line-added"> 324         Value* andAB = i &amp; 1 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argB)</span>
<span class="line-added"> 325             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argB, argA);</span>
<span class="line-added"> 326         Value* result = i &amp; 2 ? root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), andAB, argA)</span>
<span class="line-added"> 327             : root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, andAB);</span>
<span class="line-added"> 328         root-&gt;appendNewControlValue(proc, Return, Origin(), result);</span>
<span class="line-added"> 329 </span>
<span class="line-added"> 330         CHECK_EQ(compileAndRun&lt;int32_t&gt;(proc, a, b), ((a &amp; b) ^ a));</span>
<span class="line-added"> 331     }</span>
<span class="line-added"> 332 }</span>
<span class="line-added"> 333 </span>
 334 void testBitXorImms(int64_t a, int64_t b)
 335 {
 336     Procedure proc;
 337     BasicBlock* root = proc.addBlock();
 338     root-&gt;appendNewControlValue(
 339         proc, Return, Origin(),
 340         root-&gt;appendNew&lt;Value&gt;(
 341             proc, BitXor, Origin(),
 342             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
 343             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b)));
 344 
 345     CHECK(compileAndRun&lt;int64_t&gt;(proc) == (a ^ b));
 346 }
 347 
 348 void testBitXorArgImm(int64_t a, int64_t b)
 349 {
 350     Procedure proc;
 351     BasicBlock* root = proc.addBlock();
 352     root-&gt;appendNewControlValue(
 353         proc, Return, Origin(),
</pre>
</td>
</tr>
</table>
<center><a href="testb3_2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="testb3_4.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
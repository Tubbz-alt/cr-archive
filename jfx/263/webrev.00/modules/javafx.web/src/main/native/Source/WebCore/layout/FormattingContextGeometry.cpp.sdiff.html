<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/layout/FormattingContextGeometry.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FormattingContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FormattingContextQuirks.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/FormattingContextGeometry.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;FormattingContext.h&quot;
  28 
  29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  30 
  31 #include &quot;FloatingState.h&quot;
<span class="line-removed">  32 #include &quot;FormattingState.h&quot;</span>
  33 #include &quot;InlineFormattingState.h&quot;


  34 #include &quot;TableFormattingState.h&quot;
<span class="line-removed">  35 #include &quot;TableGrid.h&quot;</span>
  36 
  37 namespace WebCore {
  38 namespace Layout {
  39 
  40 static inline bool isHeightAuto(const Box&amp; layoutBox)
  41 {
  42     // 10.5 Content height: the &#39;height&#39; property
  43     //
  44     // The percentage is calculated with respect to the height of the generated box&#39;s containing block.
  45     // If the height of the containing block is not specified explicitly (i.e., it depends on content height),
  46     // and this element is not absolutely positioned, the used height is calculated as if &#39;auto&#39; was specified.
  47 
  48     auto height = layoutBox.style().logicalHeight();
  49     if (height.isAuto())
  50         return true;
  51 
  52     if (height.isPercent()) {
  53         if (layoutBox.isOutOfFlowPositioned())
  54             return false;
  55 
  56         return !layoutBox.containingBlock()-&gt;style().logicalHeight().isFixed();
  57     }
  58 
  59     return false;
  60 }
  61 
<span class="line-modified">  62 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedHeightValue(const LayoutState&amp; layoutState, const Box&amp; layoutBox, HeightType heightType)</span>
  63 {
  64     auto&amp; style = layoutBox.style();
  65     auto height = heightType == HeightType::Normal ? style.logicalHeight() : heightType == HeightType::Min ? style.logicalMinHeight() : style.logicalMaxHeight();
  66     if (height.isUndefined() || height.isAuto())
  67         return { };
  68 
  69     if (height.isFixed())
<span class="line-modified">  70         return LayoutUnit(height.value());</span>
  71 
<span class="line-modified">  72     Optional&lt;LayoutUnit&gt; containingBlockHeightValue;</span>
<span class="line-removed">  73     if (layoutBox.isOutOfFlowPositioned()) {</span>
  74         // Containing block&#39;s height is already computed since we layout the out-of-flow boxes as the last step.
<span class="line-modified">  75         containingBlockHeightValue = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).height();</span>
<span class="line-modified">  76     } else {</span>
<span class="line-modified">  77         if (layoutState.inQuirksMode())</span>
<span class="line-removed">  78             containingBlockHeightValue = FormattingContext::Quirks::heightValueOfNearestContainingBlockWithFixedHeight(layoutState, layoutBox);</span>
  79         else {
<span class="line-modified">  80             auto containingBlockHeight = layoutBox.containingBlock()-&gt;style().logicalHeight();</span>
<span class="line-modified">  81             if (containingBlockHeight.isFixed())</span>
<span class="line-modified">  82                 containingBlockHeightValue = LayoutUnit(containingBlockHeight.value());</span>
  83         }
  84     }
  85 
<span class="line-modified">  86     if (!containingBlockHeightValue)</span>
  87         return { };
  88 
<span class="line-modified">  89     return valueForLength(height, *containingBlockHeightValue);</span>






















  90 }
  91 
<span class="line-modified">  92 LayoutUnit FormattingContext::Geometry::contentHeightForFormattingContextRoot(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
  93 {
  94     ASSERT(isHeightAuto(layoutBox) &amp;&amp; (layoutBox.establishesFormattingContext() || layoutBox.isDocumentBox()));
  95 
  96     // 10.6.7 &#39;Auto&#39; heights for block formatting context roots
  97 
  98     // If it only has inline-level children, the height is the distance between the top of the topmost line box and the bottom of the bottommost line box.
  99     // If it has block-level children, the height is the distance between the top margin-edge of the topmost block-level
 100     // child box and the bottom margin-edge of the bottommost block-level child box.
 101 
 102     // In addition, if the element has any floating descendants whose bottom margin edge is below the element&#39;s bottom content edge,
 103     // then the height is increased to include those edges. Only floats that participate in this block formatting context are taken
 104     // into account, e.g., floats inside absolutely positioned descendants or other floats are not.
 105     if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild())
 106         return { };
 107 
<span class="line-modified"> 108     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified"> 109     auto borderAndPaddingTop = displayBox.borderTop() + displayBox.paddingTop().valueOr(0);</span>


 110     auto top = borderAndPaddingTop;
 111     auto bottom = borderAndPaddingTop;
 112     auto&amp; formattingRootContainer = downcast&lt;Container&gt;(layoutBox);
 113     if (formattingRootContainer.establishesInlineFormattingContext()) {
<span class="line-modified"> 114         auto&amp; lineBoxes = downcast&lt;InlineFormattingState&gt;(layoutState.establishedFormattingState(layoutBox)).lineBoxes();</span>
 115         // Even empty containers generate one line.
 116         ASSERT(!lineBoxes.isEmpty());
<span class="line-modified"> 117         top = lineBoxes.first().logicalTop();</span>
<span class="line-modified"> 118         bottom = lineBoxes.last().logicalBottom();</span>
<span class="line-modified"> 119     } else if (formattingRootContainer.establishesBlockFormattingContext() || layoutBox.isDocumentBox()) {</span>
 120         if (formattingRootContainer.hasInFlowChild()) {
<span class="line-modified"> 121             auto&amp; firstDisplayBox = layoutState.displayBoxForLayoutBox(*formattingRootContainer.firstInFlowChild());</span>
<span class="line-modified"> 122             auto&amp; lastDisplayBox = layoutState.displayBoxForLayoutBox(*formattingRootContainer.lastInFlowChild());</span>
<span class="line-modified"> 123             top = firstDisplayBox.rectWithMargin().top();</span>
<span class="line-modified"> 124             bottom = lastDisplayBox.rectWithMargin().bottom();</span>
 125         }
<span class="line-removed"> 126     } else if (formattingRootContainer.establishesTableFormattingContext()) {</span>
<span class="line-removed"> 127         auto&amp; rowList = downcast&lt;TableFormattingState&gt;(layoutState.establishedFormattingState(formattingRootContainer)).tableGrid().rows();</span>
<span class="line-removed"> 128         ASSERT(!rowList.isEmpty());</span>
<span class="line-removed"> 129         top += rowList.first().logicalTop();</span>
<span class="line-removed"> 130         auto&amp; lastRow = rowList.last();</span>
<span class="line-removed"> 131         bottom += lastRow.logicalBottom();</span>
 132     } else
 133         ASSERT_NOT_REACHED();
 134 
<span class="line-modified"> 135     auto* formattingContextRoot = &amp;layoutBox;</span>
 136     // TODO: The document renderer is not a formatting context root by default at all. Need to find out what it is.
 137     if (!layoutBox.establishesFormattingContext()) {
 138         ASSERT(layoutBox.isDocumentBox());
 139         formattingContextRoot = &amp;layoutBox.formattingContextRoot();
 140     }
 141 
 142     auto&amp; floatingState = layoutState.establishedFormattingState(*formattingContextRoot).floatingState();
 143     auto floatBottom = floatingState.bottom(*formattingContextRoot);
 144     if (floatBottom) {
 145         bottom = std::max&lt;LayoutUnit&gt;(*floatBottom, bottom);
 146         auto floatTop = floatingState.top(*formattingContextRoot);
 147         ASSERT(floatTop);
 148         top = std::min&lt;LayoutUnit&gt;(*floatTop, top);
 149     }
 150 
 151     auto computedHeight = bottom - top;
 152     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height] -&gt; content height for formatting context root -&gt; height(&quot; &lt;&lt; computedHeight &lt;&lt; &quot;px) layoutBox(&quot;&lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 153     return computedHeight;
 154 }
 155 
<span class="line-modified"> 156 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedValueIfNotAuto(const Length&amp; geometryProperty, LayoutUnit containingBlockWidth)</span>
 157 {
 158     if (geometryProperty.isUndefined())
 159         return WTF::nullopt;
 160 
 161     if (geometryProperty.isAuto())
 162         return WTF::nullopt;
 163 
 164     return valueForLength(geometryProperty, containingBlockWidth);
 165 }
 166 
<span class="line-modified"> 167 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::fixedValue(const Length&amp; geometryProperty)</span>
 168 {
 169     if (!geometryProperty.isFixed())
 170         return WTF::nullopt;
 171     return LayoutUnit(geometryProperty.value());
 172 }
 173 
 174 // https://www.w3.org/TR/CSS22/visudet.html#min-max-heights
 175 // Specifies a percentage for determining the used value. The percentage is calculated with respect to the height of the generated box&#39;s containing block.
 176 // If the height of the containing block is not specified explicitly (i.e., it depends on content height), and this element is not absolutely positioned,
 177 // the percentage value is treated as &#39;0&#39; (for &#39;min-height&#39;) or &#39;none&#39; (for &#39;max-height&#39;).
<span class="line-modified"> 178 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMaxHeight(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
 179 {
<span class="line-modified"> 180     return computedHeightValue(layoutState, layoutBox, HeightType::Max);</span>
 181 }
 182 
<span class="line-modified"> 183 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMinHeight(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
 184 {
<span class="line-modified"> 185     if (auto minHeightValue = computedHeightValue(layoutState, layoutBox, HeightType::Min))</span>
 186         return minHeightValue;
 187 
<span class="line-modified"> 188     return { 0 };</span>










 189 }
 190 
<span class="line-modified"> 191 static LayoutUnit staticVerticalPositionForOutOfFlowPositioned(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
 192 {
 193     ASSERT(layoutBox.isOutOfFlowPositioned());
 194 
 195     // For the purposes of this section and the next, the term &quot;static position&quot; (of an element) refers, roughly, to the position an element would have
 196     // had in the normal flow. More precisely, the static position for &#39;top&#39; is the distance from the top edge of the containing block to the top margin
 197     // edge of a hypothetical box that would have been the first box of the element if its specified &#39;position&#39; value had been &#39;static&#39; and its specified
 198     // &#39;float&#39; had been &#39;none&#39; and its specified &#39;clear&#39; had been &#39;none&#39;. (Note that due to the rules in section 9.7 this might require also assuming a different
 199     // computed value for &#39;display&#39;.) The value is negative if the hypothetical box is above the containing block.
 200 
 201     // Start with this box&#39;s border box offset from the parent&#39;s border box.

 202     LayoutUnit top;
 203     if (auto* previousInFlowSibling = layoutBox.previousInFlowSibling()) {
 204         // Add sibling offset
<span class="line-modified"> 205         auto&amp; previousInFlowDisplayBox = layoutState.displayBoxForLayoutBox(*previousInFlowSibling);</span>
<span class="line-modified"> 206         top += previousInFlowDisplayBox.bottom() + previousInFlowDisplayBox.nonCollapsedMarginAfter();</span>
 207     } else {
 208         ASSERT(layoutBox.parent());
<span class="line-modified"> 209         top = layoutState.displayBoxForLayoutBox(*layoutBox.parent()).contentBoxTop();</span>
 210     }
 211 
 212     // Resolve top all the way up to the containing block.
 213     auto&amp; containingBlock = *layoutBox.containingBlock();
 214     // Start with the parent since we pretend that this box is normal flow.
 215     for (auto* container = layoutBox.parent(); container != &amp;containingBlock; container = container-&gt;containingBlock()) {
<span class="line-modified"> 216         auto&amp; displayBox = layoutState.displayBoxForLayoutBox(*container);</span>
 217         // Display::Box::top is the border box top position in its containing block&#39;s coordinate system.
<span class="line-modified"> 218         top += displayBox.top();</span>
 219         ASSERT(!container-&gt;isPositioned() || layoutBox.isFixedPositioned());
 220     }
 221     // Move the static position relative to the padding box. This is very specific to abolutely positioned boxes.
<span class="line-modified"> 222     auto paddingBoxTop = layoutState.displayBoxForLayoutBox(containingBlock).paddingBoxTop();</span>
<span class="line-removed"> 223     return top - paddingBoxTop;</span>
 224 }
 225 
<span class="line-modified"> 226 static LayoutUnit staticHorizontalPositionForOutOfFlowPositioned(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
 227 {
 228     ASSERT(layoutBox.isOutOfFlowPositioned());
 229     // See staticVerticalPositionForOutOfFlowPositioned for the definition of the static position.
 230 
 231     // Start with this box&#39;s border box offset from the parent&#39;s border box.

 232     ASSERT(layoutBox.parent());
<span class="line-modified"> 233     auto left = layoutState.displayBoxForLayoutBox(*layoutBox.parent()).contentBoxLeft();</span>
 234 
 235     // Resolve left all the way up to the containing block.
 236     auto&amp; containingBlock = *layoutBox.containingBlock();
 237     // Start with the parent since we pretend that this box is normal flow.
 238     for (auto* container = layoutBox.parent(); container != &amp;containingBlock; container = container-&gt;containingBlock()) {
<span class="line-modified"> 239         auto&amp; displayBox = layoutState.displayBoxForLayoutBox(*container);</span>
 240         // Display::Box::left is the border box left position in its containing block&#39;s coordinate system.
<span class="line-modified"> 241         left += displayBox.left();</span>
 242         ASSERT(!container-&gt;isPositioned() || layoutBox.isFixedPositioned());
 243     }
 244     // Move the static position relative to the padding box. This is very specific to abolutely positioned boxes.
<span class="line-modified"> 245     auto paddingBoxLeft = layoutState.displayBoxForLayoutBox(containingBlock).paddingBoxLeft();</span>
<span class="line-removed"> 246     return left - paddingBoxLeft;</span>
 247 }
 248 
<span class="line-modified"> 249 LayoutUnit FormattingContext::Geometry::shrinkToFitWidth(LayoutState&amp; layoutState, const Box&amp; formattingRoot, UsedHorizontalValues usedValues)</span>
 250 {
 251     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width] -&gt; shrink to fit -&gt; unsupported -&gt; width(&quot; &lt;&lt; LayoutUnit { } &lt;&lt; &quot;px) layoutBox: &quot; &lt;&lt; &amp;formattingRoot &lt;&lt; &quot;)&quot;);
 252     ASSERT(formattingRoot.establishesFormattingContext());
<span class="line-removed"> 253     ASSERT(usedValues.containingBlockWidth.hasValue());</span>
 254 
 255     // Calculation of the shrink-to-fit width is similar to calculating the width of a table cell using the automatic table layout algorithm.
 256     // Roughly: calculate the preferred width by formatting the content without breaking lines other than where explicit line breaks occur,
 257     // and also calculate the preferred minimum width, e.g., by trying all possible line breaks. CSS 2.2 does not define the exact algorithm.
 258     // Thirdly, find the available width: in this case, this is the width of the containing block minus the used values of &#39;margin-left&#39;, &#39;border-left-width&#39;,
 259     // &#39;padding-left&#39;, &#39;padding-right&#39;, &#39;border-right-width&#39;, &#39;margin-right&#39;, and the widths of any relevant scroll bars.
 260 
 261     // Then the shrink-to-fit width is: min(max(preferred minimum width, available width), preferred width).
<span class="line-modified"> 262     auto&amp; formattingStateForRoot = layoutState.createFormattingStateForFormattingRootIfNeeded(formattingRoot);</span>
<span class="line-modified"> 263     auto intrinsicWidthConstraints = formattingStateForRoot.intrinsicWidthConstraints();</span>
<span class="line-modified"> 264     if (!intrinsicWidthConstraints)</span>
<span class="line-modified"> 265         intrinsicWidthConstraints = layoutState.createFormattingContext(formattingRoot)-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-modified"> 266     auto availableWidth = *usedValues.containingBlockWidth;</span>
<span class="line-modified"> 267     return std::min(std::max(intrinsicWidthConstraints-&gt;minimum, availableWidth), intrinsicWidthConstraints-&gt;maximum);</span>





 268 }
 269 
<span class="line-modified"> 270 VerticalGeometry FormattingContext::Geometry::outOfFlowNonReplacedVerticalGeometry(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)</span>
 271 {
 272     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; !layoutBox.replaced());

 273 
 274     // 10.6.4 Absolutely positioned, non-replaced elements
 275     //
 276     // For absolutely positioned elements, the used values of the vertical dimensions must satisfy this constraint:
 277     // &#39;top&#39; + &#39;margin-top&#39; + &#39;border-top-width&#39; + &#39;padding-top&#39; + &#39;height&#39; + &#39;padding-bottom&#39; + &#39;border-bottom-width&#39; + &#39;margin-bottom&#39; + &#39;bottom&#39;
 278     // = height of containing block
 279 
 280     // If all three of &#39;top&#39;, &#39;height&#39;, and &#39;bottom&#39; are auto, set &#39;top&#39; to the static position and apply rule number three below.
 281 
 282     // If none of the three are &#39;auto&#39;: If both &#39;margin-top&#39; and &#39;margin-bottom&#39; are &#39;auto&#39;, solve the equation under the extra
 283     // constraint that the two margins get equal values. If one of &#39;margin-top&#39; or &#39;margin-bottom&#39; is &#39;auto&#39;, solve the equation for that value.
 284     // If the values are over-constrained, ignore the value for &#39;bottom&#39; and solve for that value.
 285 
 286     // Otherwise, pick the one of the following six rules that applies.
 287 
 288     // 1. &#39;top&#39; and &#39;height&#39; are &#39;auto&#39; and &#39;bottom&#39; is not &#39;auto&#39;, then the height is based on the content per 10.6.7,
 289     //     set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;top&#39;
 290     // 2. &#39;top&#39; and &#39;bottom&#39; are &#39;auto&#39; and &#39;height&#39; is not &#39;auto&#39;, then set &#39;top&#39; to the static position, set &#39;auto&#39; values for
 291     //    &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;bottom&#39;
 292     // 3. &#39;height&#39; and &#39;bottom&#39; are &#39;auto&#39; and &#39;top&#39; is not &#39;auto&#39;, then the height is based on the content per 10.6.7, set &#39;auto&#39;
 293     //     values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;bottom&#39;
 294     // 4. &#39;top&#39; is &#39;auto&#39;, &#39;height&#39; and &#39;bottom&#39; are not &#39;auto&#39;, then set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;top&#39;
 295     // 5. &#39;height&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;bottom&#39; are not &#39;auto&#39;, then &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; are set to 0 and solve for &#39;height&#39;
 296     // 6. &#39;bottom&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;height&#39; are not &#39;auto&#39;, then set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0 and solve for &#39;bottom&#39;
 297 

 298     auto&amp; style = layoutBox.style();
<span class="line-modified"> 299     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified"> 300     auto&amp; containingBlockDisplayBox = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock());</span>
<span class="line-modified"> 301     auto containingBlockHeight = containingBlockDisplayBox.paddingBoxHeight();</span>
<span class="line-removed"> 302     auto containingBlockWidth = containingBlockDisplayBox.paddingBoxWidth();</span>
 303 
 304     auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
 305     auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
<span class="line-modified"> 306     auto height = usedValues.height ? usedValues.height.value() : computedHeightValue(layoutState, layoutBox, HeightType::Normal);</span>
<span class="line-modified"> 307     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, UsedHorizontalValues { containingBlockWidth });</span>
 308     UsedVerticalMargin::NonCollapsedValues usedVerticalMargin;
<span class="line-modified"> 309     auto paddingTop = displayBox.paddingTop().valueOr(0);</span>
<span class="line-modified"> 310     auto paddingBottom = displayBox.paddingBottom().valueOr(0);</span>
<span class="line-modified"> 311     auto borderTop = displayBox.borderTop();</span>
<span class="line-modified"> 312     auto borderBottom = displayBox.borderBottom();</span>
<span class="line-removed"> 313     auto contentHeight = [&amp;] {</span>
<span class="line-removed"> 314         ASSERT(height);</span>
<span class="line-removed"> 315         return style.boxSizing() == BoxSizing::ContentBox ? *height : *height - (borderTop + paddingTop + paddingBottom + borderBottom);</span>
<span class="line-removed"> 316     };</span>
 317 
 318     if (!top &amp;&amp; !height &amp;&amp; !bottom)
<span class="line-modified"> 319         top = staticVerticalPositionForOutOfFlowPositioned(layoutState, layoutBox);</span>
 320 
 321     if (top &amp;&amp; height &amp;&amp; bottom) {
 322         if (!computedVerticalMargin.before &amp;&amp; !computedVerticalMargin.after) {
<span class="line-modified"> 323             auto marginBeforeAndAfter = containingBlockHeight - (*top + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + *bottom);</span>
 324             usedVerticalMargin = { marginBeforeAndAfter / 2, marginBeforeAndAfter / 2 };
 325         } else if (!computedVerticalMargin.before) {
 326             usedVerticalMargin.after = *computedVerticalMargin.after;
<span class="line-modified"> 327             usedVerticalMargin.before = containingBlockHeight - (*top + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);</span>
 328         } else if (!computedVerticalMargin.after) {
 329             usedVerticalMargin.before = *computedVerticalMargin.before;
<span class="line-modified"> 330             usedVerticalMargin.after = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + *bottom);</span>
 331         } else
 332             usedVerticalMargin = { *computedVerticalMargin.before, *computedVerticalMargin.after };
 333         // Over-constrained?
<span class="line-modified"> 334         auto boxHeight = *top + usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom;</span>
 335         if (boxHeight != containingBlockHeight)
<span class="line-modified"> 336             bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after);</span>
 337     }
 338 
 339     if (!top &amp;&amp; !height &amp;&amp; bottom) {
 340         // #1
<span class="line-modified"> 341         height = contentHeightForFormattingContextRoot(layoutState, layoutBox);</span>
 342         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 343         top = containingBlockHeight - (usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);
 344     }
 345 
 346     if (!top &amp;&amp; !bottom &amp;&amp; height) {
 347         // #2
<span class="line-modified"> 348         top = staticVerticalPositionForOutOfFlowPositioned(layoutState, layoutBox);</span>
 349         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<span class="line-modified"> 350         bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after);</span>
 351     }
 352 
 353     if (!height &amp;&amp; !bottom &amp;&amp; top) {
 354         // #3
<span class="line-modified"> 355         height = contentHeightForFormattingContextRoot(layoutState, layoutBox);</span>
 356         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 357         bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after);
 358     }
 359 
 360     if (!top &amp;&amp; height &amp;&amp; bottom) {
 361         // #4
 362         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<span class="line-modified"> 363         top = containingBlockHeight - (usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);</span>
 364     }
 365 
 366     if (!height &amp;&amp; top &amp;&amp; bottom) {
 367         // #5
 368         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 369         height = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);
 370     }
 371 
 372     if (!bottom &amp;&amp; top &amp;&amp; height) {
 373         // #6
 374         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<span class="line-modified"> 375         bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + contentHeight() + paddingBottom + borderBottom + usedVerticalMargin.after);</span>
 376     }
 377 
 378     ASSERT(top);
 379     ASSERT(bottom);
 380     ASSERT(height);
 381 
 382     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
 383     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<span class="line-modified"> 384     auto containingBlockPaddingVerticalEdge = containingBlockDisplayBox.paddingBoxTop();</span>
 385     *top += containingBlockPaddingVerticalEdge;
 386     *bottom += containingBlockPaddingVerticalEdge;
 387 
 388     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Height][Margin] -&gt; out-of-flow non-replaced -&gt; top(&quot; &lt;&lt; *top &lt;&lt; &quot;px) bottom(&quot;  &lt;&lt; *bottom &lt;&lt; &quot;px) height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot;  &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<span class="line-modified"> 389     return { *top, *bottom, { contentHeight(), usedVerticalMargin } };</span>
 390 }
 391 
<span class="line-modified"> 392 HorizontalGeometry FormattingContext::Geometry::outOfFlowNonReplacedHorizontalGeometry(LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
 393 {
 394     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; !layoutBox.replaced());
 395 
 396     // 10.3.7 Absolutely positioned, non-replaced elements
 397     //
 398     // &#39;left&#39; + &#39;margin-left&#39; + &#39;border-left-width&#39; + &#39;padding-left&#39; + &#39;width&#39; + &#39;padding-right&#39; + &#39;border-right-width&#39; + &#39;margin-right&#39; + &#39;right&#39;
 399     // = width of containing block
 400 
 401     // If all three of &#39;left&#39;, &#39;width&#39;, and &#39;right&#39; are &#39;auto&#39;: First set any &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0.
 402     // Then, if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39; set &#39;left&#39; to the static
 403     // position and apply rule number three below; otherwise, set &#39;right&#39; to the static position and apply rule number one below.
 404     //
 405     // If none of the three is &#39;auto&#39;: If both &#39;margin-left&#39; and &#39;margin-right&#39; are &#39;auto&#39;, solve the equation under the extra constraint that the two margins get equal values,
 406     // unless this would make them negative, in which case when direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
 407     // solve for &#39;margin-right&#39; (&#39;margin-left&#39;). If one of &#39;margin-left&#39; or &#39;margin-right&#39; is &#39;auto&#39;, solve the equation for that value.
 408     // If the values are over-constrained, ignore the value for &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or &#39;right&#39;
 409     // (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
 410     //
 411     // Otherwise, set &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0, and pick the one of the following six rules that applies.
 412     //
 413     // 1. &#39;left&#39; and &#39;width&#39; are &#39;auto&#39; and &#39;right&#39; is not &#39;auto&#39;, then the width is shrink-to-fit. Then solve for &#39;left&#39;
 414     // 2. &#39;left&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;width&#39; is not &#39;auto&#39;, then if the &#39;direction&#39; property of the element establishing the static-position
 415     //    containing block is &#39;ltr&#39; set &#39;left&#39; to the static position, otherwise set &#39;right&#39; to the static position.
 416     //    Then solve for &#39;left&#39; (if &#39;direction is &#39;rtl&#39;) or &#39;right&#39; (if &#39;direction&#39; is &#39;ltr&#39;).
 417     // 3. &#39;width&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;left&#39; is not &#39;auto&#39;, then the width is shrink-to-fit . Then solve for &#39;right&#39;
 418     // 4. &#39;left&#39; is &#39;auto&#39;, &#39;width&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve for &#39;left&#39;
 419     // 5. &#39;width&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve for &#39;width&#39;
 420     // 6. &#39;right&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;width&#39; are not &#39;auto&#39;, then solve for &#39;right&#39;
 421 

 422     auto&amp; style = layoutBox.style();
<span class="line-modified"> 423     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified"> 424     auto&amp; containingBlock = *layoutBox.containingBlock();</span>
<span class="line-modified"> 425     auto&amp; containingBlockDisplayBox = layoutState.displayBoxForLayoutBox(containingBlock);</span>
<span class="line-removed"> 426     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);</span>
<span class="line-removed"> 427     auto isLeftToRightDirection = containingBlock.style().isLeftToRightDirection();</span>
 428 
 429     auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
 430     auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);
<span class="line-modified"> 431     auto width = computedValueIfNotAuto(usedValues.width ? Length { usedValues.width.value(), Fixed } : style.logicalWidth(), containingBlockWidth);</span>
<span class="line-modified"> 432     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);</span>
 433     UsedHorizontalMargin usedHorizontalMargin;
<span class="line-modified"> 434     auto paddingLeft = displayBox.paddingLeft().valueOr(0);</span>
<span class="line-modified"> 435     auto paddingRight = displayBox.paddingRight().valueOr(0);</span>
<span class="line-modified"> 436     auto borderLeft = displayBox.borderLeft();</span>
<span class="line-modified"> 437     auto borderRight = displayBox.borderRight();</span>
<span class="line-removed"> 438     auto contentWidth = [&amp;] {</span>
<span class="line-removed"> 439         ASSERT(width);</span>
<span class="line-removed"> 440         return style.boxSizing() == BoxSizing::ContentBox ? *width : *width - (borderLeft + paddingLeft + paddingRight + borderRight);</span>
<span class="line-removed"> 441     };</span>
<span class="line-removed"> 442 </span>
 443     if (!left &amp;&amp; !width &amp;&amp; !right) {
 444         // If all three of &#39;left&#39;, &#39;width&#39;, and &#39;right&#39; are &#39;auto&#39;: First set any &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0.
 445         // Then, if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39; set &#39;left&#39; to the static
 446         // position and apply rule number three below; otherwise, set &#39;right&#39; to the static position and apply rule number one below.
 447         usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
 448 
<span class="line-modified"> 449         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutState, layoutBox);</span>
 450         if (isLeftToRightDirection)
 451             left = staticHorizontalPosition;
 452         else
 453             right = staticHorizontalPosition;
 454     } else if (left &amp;&amp; width &amp;&amp; right) {
 455         // If none of the three is &#39;auto&#39;: If both &#39;margin-left&#39; and &#39;margin-right&#39; are &#39;auto&#39;, solve the equation under the extra constraint that the two margins get equal values,
 456         // unless this would make them negative, in which case when direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
 457         // solve for &#39;margin-right&#39; (&#39;margin-left&#39;). If one of &#39;margin-left&#39; or &#39;margin-right&#39; is &#39;auto&#39;, solve the equation for that value.
 458         // If the values are over-constrained, ignore the value for &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or &#39;right&#39;
 459         // (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
 460         if (!computedHorizontalMargin.start &amp;&amp; !computedHorizontalMargin.end) {
<span class="line-modified"> 461             auto marginStartAndEnd = containingBlockWidth - (*left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + *right);</span>
 462             if (marginStartAndEnd &gt;= 0)
 463                 usedHorizontalMargin = { marginStartAndEnd / 2, marginStartAndEnd / 2 };
 464             else {
 465                 if (isLeftToRightDirection) {
 466                     usedHorizontalMargin.start = 0_lu;
<span class="line-modified"> 467                     usedHorizontalMargin.end = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + *right);</span>
 468                 } else {
 469                     usedHorizontalMargin.end = 0_lu;
<span class="line-modified"> 470                     usedHorizontalMargin.start = containingBlockWidth - (*left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
 471                 }
 472             }
 473         } else if (!computedHorizontalMargin.start) {
 474             usedHorizontalMargin.end = *computedHorizontalMargin.end;
<span class="line-modified"> 475             usedHorizontalMargin.start = containingBlockWidth - (*left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
 476         } else if (!computedHorizontalMargin.end) {
 477             usedHorizontalMargin.start = *computedHorizontalMargin.start;
<span class="line-modified"> 478             usedHorizontalMargin.end = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + *right);</span>
 479         } else {
 480             usedHorizontalMargin = { *computedHorizontalMargin.start, *computedHorizontalMargin.end };
 481             // Overconstrained? Ignore right (left).
 482             if (isLeftToRightDirection)
<span class="line-modified"> 483                 right = containingBlockWidth - (usedHorizontalMargin.start + *left + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end);</span>
 484             else
<span class="line-modified"> 485                 left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
 486         }
 487     } else {
 488         // Otherwise, set &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0, and pick the one of the following six rules that applies.
 489         usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
 490     }
 491 
 492     if (!left &amp;&amp; !width &amp;&amp; right) {
 493         // #1
 494         // Calculate the available width by solving for &#39;width&#39; after setting &#39;left&#39; (in case 1) to 0
 495         left = LayoutUnit { 0 };
 496         auto availableWidth = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);
<span class="line-modified"> 497         width = shrinkToFitWidth(layoutState, layoutBox, UsedHorizontalValues { availableWidth, usedValues.width, usedValues.margin });</span>
 498         left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight  + borderRight + usedHorizontalMargin.end + *right);
 499     } else if (!left &amp;&amp; !right &amp;&amp; width) {
 500         // #2
<span class="line-modified"> 501         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutState, layoutBox);</span>
 502         if (isLeftToRightDirection) {
 503             left = staticHorizontalPosition;
<span class="line-modified"> 504             right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end);</span>
 505         } else {
 506             right = staticHorizontalPosition;
<span class="line-modified"> 507             left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
 508         }
 509     } else if (!width &amp;&amp; !right &amp;&amp; left) {
 510         // #3
 511         // Calculate the available width by solving for &#39;width&#39; after setting &#39;right&#39; (in case 3) to 0
 512         right = LayoutUnit { 0 };
 513         auto availableWidth = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);
<span class="line-modified"> 514         width = shrinkToFitWidth(layoutState, layoutBox, UsedHorizontalValues { availableWidth, usedValues.width, usedValues.margin });</span>
 515         right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end);
 516     } else if (!left &amp;&amp; width &amp;&amp; right) {
 517         // #4
<span class="line-modified"> 518         left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
 519     } else if (!width &amp;&amp; left &amp;&amp; right) {
 520         // #5
 521         width = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);
 522     } else if (!right &amp;&amp; left &amp;&amp; width) {
 523         // #6
<span class="line-modified"> 524         right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end);</span>
 525     }
 526 
 527     ASSERT(left);
 528     ASSERT(right);
 529     ASSERT(width);
 530 
 531     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
 532     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<span class="line-modified"> 533     auto containingBlockPaddingVerticalEdge = containingBlockDisplayBox.paddingBoxLeft();</span>
 534     *left += containingBlockPaddingVerticalEdge;
 535     *right += containingBlockPaddingVerticalEdge;
 536 
 537     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Width][Margin] -&gt; out-of-flow non-replaced -&gt; left(&quot; &lt;&lt; *left &lt;&lt; &quot;px) right(&quot;  &lt;&lt; *right &lt;&lt; &quot;px) width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedHorizontalMargin.start &lt;&lt; &quot;px, &quot;  &lt;&lt; usedHorizontalMargin.end &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<span class="line-modified"> 538     return { *left, *right, { contentWidth(), usedHorizontalMargin, computedHorizontalMargin } };</span>
 539 }
 540 
<span class="line-modified"> 541 VerticalGeometry FormattingContext::Geometry::outOfFlowReplacedVerticalGeometry(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)</span>
 542 {
 543     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; layoutBox.replaced());

 544 
 545     // 10.6.5 Absolutely positioned, replaced elements
 546     //
 547     // The used value of &#39;height&#39; is determined as for inline replaced elements.
 548     // If &#39;margin-top&#39; or &#39;margin-bottom&#39; is specified as &#39;auto&#39; its used value is determined by the rules below.
 549     // 1. If both &#39;top&#39; and &#39;bottom&#39; have the value &#39;auto&#39;, replace &#39;top&#39; with the element&#39;s static position.
 550     // 2. If &#39;bottom&#39; is &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-top&#39; or &#39;margin-bottom&#39; with &#39;0&#39;.
 551     // 3. If at this point both &#39;margin-top&#39; and &#39;margin-bottom&#39; are still &#39;auto&#39;, solve the equation under the extra constraint that the two margins must get equal values.
 552     // 4. If at this point there is only one &#39;auto&#39; left, solve the equation for that value.
 553     // 5. If at this point the values are over-constrained, ignore the value for &#39;bottom&#39; and solve for that value.
 554 

 555     auto&amp; style = layoutBox.style();
<span class="line-modified"> 556     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified"> 557     auto&amp; containingBlockDisplayBox = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock());</span>
<span class="line-modified"> 558     auto containingBlockHeight = containingBlockDisplayBox.paddingBoxHeight();</span>
<span class="line-removed"> 559     auto containingBlockWidth = containingBlockDisplayBox.paddingBoxWidth();</span>
 560 
 561     auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
 562     auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
<span class="line-modified"> 563     auto height = inlineReplacedHeightAndMargin(layoutState, layoutBox, usedValues).height;</span>
<span class="line-modified"> 564     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, UsedHorizontalValues { containingBlockWidth });</span>
 565     Optional&lt;LayoutUnit&gt; usedMarginBefore = computedVerticalMargin.before;
 566     Optional&lt;LayoutUnit&gt; usedMarginAfter = computedVerticalMargin.after;
<span class="line-modified"> 567     auto paddingTop = displayBox.paddingTop().valueOr(0);</span>
<span class="line-modified"> 568     auto paddingBottom = displayBox.paddingBottom().valueOr(0);</span>
<span class="line-modified"> 569     auto borderTop = displayBox.borderTop();</span>
<span class="line-modified"> 570     auto borderBottom = displayBox.borderBottom();</span>
 571 
 572     if (!top &amp;&amp; !bottom) {
 573         // #1
<span class="line-modified"> 574         top = staticVerticalPositionForOutOfFlowPositioned(layoutState, layoutBox);</span>
 575     }
 576 
 577     if (!bottom) {
 578         // #2
 579         usedMarginBefore = computedVerticalMargin.before.valueOr(0);
 580         usedMarginAfter = usedMarginBefore;
 581     }
 582 
 583     if (!usedMarginBefore &amp;&amp; !usedMarginAfter) {
 584         // #3
 585         auto marginBeforeAndAfter = containingBlockHeight - (*top + borderTop + paddingTop + height + paddingBottom + borderBottom + *bottom);
 586         usedMarginBefore = marginBeforeAndAfter / 2;
 587         usedMarginAfter = usedMarginBefore;
 588     }
 589 
 590     // #4
 591     if (!top)
 592         top = containingBlockHeight - (*usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter + *bottom);
 593 
 594     if (!bottom)
 595         bottom = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter);
 596 
 597     if (!usedMarginBefore)
 598         usedMarginBefore = containingBlockHeight - (*top + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter + *bottom);
 599 
 600     if (!usedMarginAfter)
 601         usedMarginAfter = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *bottom);
 602 
 603     // #5
 604     auto boxHeight = *top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter + *bottom;
 605     if (boxHeight &gt; containingBlockHeight)
 606         bottom = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter);
 607 
 608     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
 609     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<span class="line-modified"> 610     auto containingBlockPaddingVerticalEdge = containingBlockDisplayBox.paddingBoxTop();</span>
 611     *top += containingBlockPaddingVerticalEdge;
 612     *bottom += containingBlockPaddingVerticalEdge;
 613 
 614     ASSERT(top);
 615     ASSERT(bottom);
 616     ASSERT(usedMarginBefore);
 617     ASSERT(usedMarginAfter);
 618     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Height][Margin] -&gt; out-of-flow replaced -&gt; top(&quot; &lt;&lt; *top &lt;&lt; &quot;px) bottom(&quot;  &lt;&lt; *bottom &lt;&lt; &quot;px) height(&quot; &lt;&lt; height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; *usedMarginBefore &lt;&lt; &quot;px, &quot;  &lt;&lt; *usedMarginAfter &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 619     return { *top, *bottom, { height, { *usedMarginBefore, *usedMarginAfter } } };
 620 }
 621 
<span class="line-modified"> 622 HorizontalGeometry FormattingContext::Geometry::outOfFlowReplacedHorizontalGeometry(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
 623 {
 624     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; layoutBox.replaced());
 625 
 626     // 10.3.8 Absolutely positioned, replaced elements
 627     // In this case, section 10.3.7 applies up through and including the constraint equation, but the rest of section 10.3.7 is replaced by the following rules:
 628     //
 629     // The used value of &#39;width&#39; is determined as for inline replaced elements. If &#39;margin-left&#39; or &#39;margin-right&#39; is specified as &#39;auto&#39; its used value is determined by the rules below.
 630     // 1. If both &#39;left&#39; and &#39;right&#39; have the value &#39;auto&#39;, then if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39;,
 631     //   set &#39;left&#39; to the static position; else if &#39;direction&#39; is &#39;rtl&#39;, set &#39;right&#39; to the static position.
 632     // 2. If &#39;left&#39; or &#39;right&#39; are &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-left&#39; or &#39;margin-right&#39; with &#39;0&#39;.
 633     // 3. If at this point both &#39;margin-left&#39; and &#39;margin-right&#39; are still &#39;auto&#39;, solve the equation under the extra constraint that the two margins must get equal values,
 634     //   unless this would make them negative, in which case when the direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
 635     //   solve for &#39;margin-right&#39; (&#39;margin-left&#39;).
 636     // 4. If at this point there is an &#39;auto&#39; left, solve the equation for that value.
 637     // 5. If at this point the values are over-constrained, ignore the value for either &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or
 638     //   &#39;right&#39; (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
 639 

 640     auto&amp; style = layoutBox.style();
<span class="line-modified"> 641     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified"> 642     auto&amp; containingBlock = *layoutBox.containingBlock();</span>
<span class="line-modified"> 643     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);</span>
<span class="line-removed"> 644     auto isLeftToRightDirection = containingBlock.style().isLeftToRightDirection();</span>
 645 
 646     auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
 647     auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);
<span class="line-modified"> 648     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);</span>
 649     Optional&lt;LayoutUnit&gt; usedMarginStart = computedHorizontalMargin.start;
 650     Optional&lt;LayoutUnit&gt; usedMarginEnd = computedHorizontalMargin.end;
<span class="line-modified"> 651     auto width = inlineReplacedWidthAndMargin(layoutState, layoutBox, usedValues).width;</span>
<span class="line-modified"> 652     auto paddingLeft = displayBox.paddingLeft().valueOr(0);</span>
<span class="line-modified"> 653     auto paddingRight = displayBox.paddingRight().valueOr(0);</span>
<span class="line-modified"> 654     auto borderLeft = displayBox.borderLeft();</span>
<span class="line-modified"> 655     auto borderRight = displayBox.borderRight();</span>
 656 
 657     if (!left &amp;&amp; !right) {
 658         // #1
<span class="line-modified"> 659         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutState, layoutBox);</span>
 660         if (isLeftToRightDirection)
 661             left = staticHorizontalPosition;
 662         else
 663             right = staticHorizontalPosition;
 664     }
 665 
 666     if (!left || !right) {
 667         // #2
 668         usedMarginStart = computedHorizontalMargin.start.valueOr(0);
 669         usedMarginEnd = computedHorizontalMargin.end.valueOr(0);
 670     }
 671 
 672     if (!usedMarginStart &amp;&amp; !usedMarginEnd) {
 673         // #3
 674         auto marginStartAndEnd = containingBlockWidth - (*left + borderLeft + paddingLeft + width + paddingRight + borderRight + *right);
 675         if (marginStartAndEnd &gt;= 0) {
 676             usedMarginStart = marginStartAndEnd / 2;
 677             usedMarginEnd = usedMarginStart;
 678         } else {
 679             if (isLeftToRightDirection) {
</pre>
<hr />
<pre>
 698 
 699     if (!usedMarginEnd)
 700         usedMarginEnd = containingBlockWidth - (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *right);
 701 
 702     auto boxWidth = (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 703     if (boxWidth &gt; containingBlockWidth) {
 704         // #5 Over-constrained?
 705         if (isLeftToRightDirection)
 706             right = containingBlockWidth - (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd);
 707         else
 708             left = containingBlockWidth - (*usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 709     }
 710 
 711     ASSERT(left);
 712     ASSERT(right);
 713     ASSERT(usedMarginStart);
 714     ASSERT(usedMarginEnd);
 715 
 716     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
 717     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<span class="line-modified"> 718     auto containingBlockPaddingVerticalEdge = layoutState.displayBoxForLayoutBox(containingBlock).paddingBoxLeft();</span>
 719     *left += containingBlockPaddingVerticalEdge;
 720     *right += containingBlockPaddingVerticalEdge;
 721 
 722     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Width][Margin] -&gt; out-of-flow replaced -&gt; left(&quot; &lt;&lt; *left &lt;&lt; &quot;px) right(&quot;  &lt;&lt; *right &lt;&lt; &quot;px) width(&quot; &lt;&lt; width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; *usedMarginStart &lt;&lt; &quot;px, &quot;  &lt;&lt; *usedMarginEnd &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 723     return { *left, *right, { width, { *usedMarginStart, *usedMarginEnd }, computedHorizontalMargin } };
 724 }
 725 
<span class="line-modified"> 726 HeightAndMargin FormattingContext::Geometry::complicatedCases(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues, UsedHorizontalValues usedHorizontalValues)</span>
 727 {
 728     ASSERT(!layoutBox.replaced());
 729     // TODO: Use complicated-case for document renderer for now (see BlockFormattingContext::Geometry::inFlowHeightAndMargin).
<span class="line-modified"> 730     ASSERT((layoutBox.isBlockLevelBox() &amp;&amp; layoutBox.isInFlow() &amp;&amp; !layoutBox.isOverflowVisible()) || layoutBox.isInlineBlockBox() || layoutBox.isFloatingPositioned() || layoutBox.isDocumentBox());</span>
 731 
 732     // 10.6.6 Complicated cases
 733     //
 734     // Block-level, non-replaced elements in normal flow when &#39;overflow&#39; does not compute to &#39;visible&#39; (except if the &#39;overflow&#39; property&#39;s value has been propagated to the viewport).
 735     // &#39;Inline-block&#39;, non-replaced elements.
 736     // Floating, non-replaced elements.
 737     //
 738     // 1. If &#39;margin-top&#39;, or &#39;margin-bottom&#39; are &#39;auto&#39;, their used value is 0.
 739     // 2. If &#39;height&#39; is &#39;auto&#39;, the height depends on the element&#39;s descendants per 10.6.7.
 740 
<span class="line-modified"> 741     auto height = usedValues.height ? usedValues.height.value() : computedHeightValue(layoutState, layoutBox, HeightType::Normal);</span>
<span class="line-modified"> 742     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, usedHorizontalValues);</span>
 743     // #1
 744     auto usedVerticalMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 745     // #2
 746     if (!height) {
 747         ASSERT(isHeightAuto(layoutBox));
<span class="line-modified"> 748         height = contentHeightForFormattingContextRoot(layoutState, layoutBox);</span>
 749     }
 750 
 751     ASSERT(height);
 752 
 753     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; floating non-replaced -&gt; height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot; &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<span class="line-modified"> 754     return HeightAndMargin { *height, usedVerticalMargin };</span>
 755 }
 756 
<span class="line-modified"> 757 WidthAndMargin FormattingContext::Geometry::floatingNonReplacedWidthAndMargin(LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
 758 {
 759     ASSERT(layoutBox.isFloatingPositioned() &amp;&amp; !layoutBox.replaced());
 760 
 761     // 10.3.5 Floating, non-replaced elements
 762     //
 763     // 1. If &#39;margin-left&#39;, or &#39;margin-right&#39; are computed as &#39;auto&#39;, their used value is &#39;0&#39;.
 764     // 2. If &#39;width&#39; is computed as &#39;auto&#39;, the used value is the &quot;shrink-to-fit&quot; width.
 765 
<span class="line-modified"> 766     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);</span>
 767 
 768     // #1
 769     auto usedHorizontallMargin = UsedHorizontalMargin { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
 770     // #2
<span class="line-modified"> 771     auto width = computedValueIfNotAuto(usedValues.width ? Length { usedValues.width.value(), Fixed } : layoutBox.style().logicalWidth(), usedValues.containingBlockWidth.valueOr(0));</span>
 772     if (!width)
<span class="line-modified"> 773         width = shrinkToFitWidth(layoutState, layoutBox, usedValues);</span>
 774 
 775     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; floating non-replaced -&gt; width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedHorizontallMargin.start &lt;&lt; &quot;px, &quot; &lt;&lt; usedHorizontallMargin.end &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<span class="line-modified"> 776     return WidthAndMargin { *width, usedHorizontallMargin, computedHorizontalMargin };</span>
 777 }
 778 
<span class="line-modified"> 779 HeightAndMargin FormattingContext::Geometry::floatingReplacedHeightAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)</span>
 780 {
 781     ASSERT(layoutBox.isFloatingPositioned() &amp;&amp; layoutBox.replaced());
 782 
 783     // 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, &#39;inline-block&#39;
 784     // replaced elements in normal flow and floating replaced elements
 785     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; floating replaced -&gt; redirected to inline replaced&quot;);
<span class="line-modified"> 786     return inlineReplacedHeightAndMargin(layoutState, layoutBox, usedValues);</span>
 787 }
 788 
<span class="line-modified"> 789 WidthAndMargin FormattingContext::Geometry::floatingReplacedWidthAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
 790 {
 791     ASSERT(layoutBox.isFloatingPositioned() &amp;&amp; layoutBox.replaced());
 792 
 793     // 10.3.6 Floating, replaced elements
 794     //
 795     // 1. If &#39;margin-left&#39; or &#39;margin-right&#39; are computed as &#39;auto&#39;, their used value is &#39;0&#39;.
 796     // 2. The used value of &#39;width&#39; is determined as for inline replaced elements.
<span class="line-modified"> 797     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);</span>
 798 
 799     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; floating replaced -&gt; redirected to inline replaced&quot;);
<span class="line-modified"> 800     return inlineReplacedWidthAndMargin(layoutState, layoutBox, UsedHorizontalValues { usedValues.containingBlockWidth.valueOr(0),</span>
<span class="line-modified"> 801         usedValues.width, UsedHorizontalMargin { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) } });</span>
 802 }
 803 
<span class="line-modified"> 804 VerticalGeometry FormattingContext::Geometry::outOfFlowVerticalGeometry(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)</span>
 805 {
 806     ASSERT(layoutBox.isOutOfFlowPositioned());
 807 
 808     if (!layoutBox.replaced())
<span class="line-modified"> 809         return outOfFlowNonReplacedVerticalGeometry(layoutState, layoutBox, usedValues);</span>
<span class="line-modified"> 810     return outOfFlowReplacedVerticalGeometry(layoutState, layoutBox, usedValues);</span>
 811 }
 812 
<span class="line-modified"> 813 HorizontalGeometry FormattingContext::Geometry::outOfFlowHorizontalGeometry(LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
 814 {
 815     ASSERT(layoutBox.isOutOfFlowPositioned());
 816 
 817     if (!layoutBox.replaced())
<span class="line-modified"> 818         return outOfFlowNonReplacedHorizontalGeometry(layoutState, layoutBox, usedValues);</span>
<span class="line-modified"> 819     return outOfFlowReplacedHorizontalGeometry(layoutState, layoutBox, usedValues);</span>
 820 }
 821 
<span class="line-modified"> 822 HeightAndMargin FormattingContext::Geometry::floatingHeightAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedVerticalValues, UsedHorizontalValues usedHorizontalValues)</span>
 823 {
 824     ASSERT(layoutBox.isFloatingPositioned());
 825 
 826     if (!layoutBox.replaced())
<span class="line-modified"> 827         return complicatedCases(layoutState, layoutBox, usedVerticalValues, usedHorizontalValues);</span>
<span class="line-modified"> 828     return floatingReplacedHeightAndMargin(layoutState, layoutBox, usedVerticalValues);</span>
 829 }
 830 
<span class="line-modified"> 831 WidthAndMargin FormattingContext::Geometry::floatingWidthAndMargin(LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
 832 {
 833     ASSERT(layoutBox.isFloatingPositioned());
 834 
 835     if (!layoutBox.replaced())
<span class="line-modified"> 836         return floatingNonReplacedWidthAndMargin(layoutState, layoutBox, usedValues);</span>
<span class="line-modified"> 837     return floatingReplacedWidthAndMargin(layoutState, layoutBox, usedValues);</span>
 838 }
 839 
<span class="line-modified"> 840 HeightAndMargin FormattingContext::Geometry::inlineReplacedHeightAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)</span>
 841 {
 842     ASSERT((layoutBox.isOutOfFlowPositioned() || layoutBox.isFloatingPositioned() || layoutBox.isInFlow()) &amp;&amp; layoutBox.replaced());
 843 
 844     // 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, &#39;inline-block&#39; replaced elements in normal flow and floating replaced elements
 845     //
 846     // 1. If &#39;margin-top&#39;, or &#39;margin-bottom&#39; are &#39;auto&#39;, their used value is 0.
 847     // 2. If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element also has an intrinsic height, then that intrinsic height is the used value of &#39;height&#39;.
 848     // 3. Otherwise, if &#39;height&#39; has a computed value of &#39;auto&#39;, and the element has an intrinsic ratio then the used value of &#39;height&#39; is:
 849     //    (used width) / (intrinsic ratio)
 850     // 4. Otherwise, if &#39;height&#39; has a computed value of &#39;auto&#39;, and the element has an intrinsic height, then that intrinsic height is the used value of &#39;height&#39;.
 851     // 5. Otherwise, if &#39;height&#39; has a computed value of &#39;auto&#39;, but none of the conditions above are met, then the used value of &#39;height&#39; must be set to
 852     //    the height of the largest rectangle that has a 2:1 ratio, has a height not greater than 150px, and has a width not greater than the device width.
 853 
 854     // #1
<span class="line-modified"> 855     auto containingBlockWidth = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth();</span>
<span class="line-modified"> 856     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, UsedHorizontalValues { containingBlockWidth });</span>
 857     auto usedVerticalMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 858     auto&amp; style = layoutBox.style();
 859     auto replaced = layoutBox.replaced();
 860 
<span class="line-modified"> 861     auto height = usedValues.height ? usedValues.height.value() : computedHeightValue(layoutState, layoutBox, HeightType::Normal);</span>
<span class="line-modified"> 862     auto heightIsAuto = !usedValues.height &amp;&amp; isHeightAuto(layoutBox);</span>
 863     auto widthIsAuto = style.logicalWidth().isAuto();
 864 
 865     if (heightIsAuto &amp;&amp; widthIsAuto &amp;&amp; replaced-&gt;hasIntrinsicHeight()) {
 866         // #2
 867         height = replaced-&gt;intrinsicHeight();
 868     } else if (heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicRatio()) {
 869         // #3
<span class="line-modified"> 870         auto usedWidth = layoutState.displayBoxForLayoutBox(layoutBox).width();</span>
 871         height = usedWidth / replaced-&gt;intrinsicRatio();
 872     } else if (heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicHeight()) {
 873         // #4
 874         height = replaced-&gt;intrinsicHeight();
 875     } else if (heightIsAuto) {
 876         // #5
 877         height = { 150 };
 878     }
 879 
 880     ASSERT(height);
 881 
 882     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; inflow replaced -&gt; height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot; &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 883     return { *height, usedVerticalMargin };
 884 }
 885 
<span class="line-modified"> 886 WidthAndMargin FormattingContext::Geometry::inlineReplacedWidthAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
 887 {
 888     ASSERT((layoutBox.isOutOfFlowPositioned() || layoutBox.isFloatingPositioned() || layoutBox.isInFlow()) &amp;&amp; layoutBox.replaced());
 889 
 890     // 10.3.2 Inline, replaced elements
 891     //
 892     // A computed value of &#39;auto&#39; for &#39;margin-left&#39; or &#39;margin-right&#39; becomes a used value of &#39;0&#39;.
 893     //
 894     // 1. If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element also has an intrinsic width, then that intrinsic width is the used value of &#39;width&#39;.
 895     //
 896     // 2. If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element has no intrinsic width, but does have an intrinsic height and intrinsic ratio;
 897     //    or if &#39;width&#39; has a computed value of &#39;auto&#39;, &#39;height&#39; has some other computed value, and the element does have an intrinsic ratio;
 898     //    then the used value of &#39;width&#39; is: (used height) * (intrinsic ratio)
 899     //
 900     // 3. If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element has an intrinsic ratio but no intrinsic height or width,
 901     //    then the used value of &#39;width&#39; is undefined in CSS 2.2. However, it is suggested that, if the containing block&#39;s width does not itself depend on the replaced
 902     //    element&#39;s width, then the used value of &#39;width&#39; is calculated from the constraint equation used for block-level, non-replaced elements in normal flow.
 903     //
 904     // 4. Otherwise, if &#39;width&#39; has a computed value of &#39;auto&#39;, and the element has an intrinsic width, then that intrinsic width is the used value of &#39;width&#39;.
 905     //
 906     // 5. Otherwise, if &#39;width&#39; has a computed value of &#39;auto&#39;, but none of the conditions above are met, then the used value of &#39;width&#39; becomes 300px.
 907     //    If 300px is too wide to fit the device, UAs should use the width of the largest rectangle that has a 2:1 ratio and fits the device instead.
 908 
<span class="line-modified"> 909     auto&amp; style = layoutBox.style();</span>
<span class="line-removed"> 910     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);</span>
<span class="line-removed"> 911     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);</span>
 912 
 913     auto usedMarginStart = [&amp;] {
<span class="line-modified"> 914         if (usedValues.margin)</span>
<span class="line-modified"> 915             return usedValues.margin-&gt;start;</span>
 916         return computedHorizontalMargin.start.valueOr(0_lu);
 917     };
 918 
 919     auto usedMarginEnd = [&amp;] {
<span class="line-modified"> 920         if (usedValues.margin)</span>
<span class="line-modified"> 921             return usedValues.margin-&gt;end;</span>
 922         return computedHorizontalMargin.end.valueOr(0_lu);
 923     };
 924 
 925     auto replaced = layoutBox.replaced();
 926     ASSERT(replaced);
 927 
<span class="line-modified"> 928     auto width = computedValueIfNotAuto(usedValues.width ? Length { usedValues.width.value(), Fixed } : style.logicalWidth(), containingBlockWidth);</span>
 929     auto heightIsAuto = isHeightAuto(layoutBox);
<span class="line-modified"> 930     auto height = computedHeightValue(layoutState, layoutBox, HeightType::Normal);</span>
 931 
 932     if (!width &amp;&amp; heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicWidth()) {
 933         // #1
 934         width = replaced-&gt;intrinsicWidth();
 935     } else if ((!width &amp;&amp; heightIsAuto &amp;&amp; !replaced-&gt;hasIntrinsicWidth() &amp;&amp; replaced-&gt;hasIntrinsicHeight() &amp;&amp; replaced-&gt;hasIntrinsicRatio())
 936         || (!width &amp;&amp; height &amp;&amp; replaced-&gt;hasIntrinsicRatio())) {
 937         // #2
 938         width = height.valueOr(replaced-&gt;hasIntrinsicHeight()) * replaced-&gt;intrinsicRatio();
 939     } else if (!width &amp;&amp; heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicRatio() &amp;&amp; !replaced-&gt;hasIntrinsicWidth() &amp;&amp; !replaced-&gt;hasIntrinsicHeight()) {
 940         // #3
 941         // FIXME: undefined but surely doable.
 942         ASSERT_NOT_IMPLEMENTED_YET();
 943     } else if (!width &amp;&amp; replaced-&gt;hasIntrinsicWidth()) {
 944         // #4
 945         width = replaced-&gt;intrinsicWidth();
 946     } else if (!width) {
 947         // #5
 948         width = { 300 };
 949     }
 950 
 951     ASSERT(width);
 952 
 953     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; inflow replaced -&gt; width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedMarginStart() &lt;&lt; &quot;px, &quot; &lt;&lt; usedMarginEnd() &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 954     return { *width, { usedMarginStart(), usedMarginEnd() }, computedHorizontalMargin };
 955 }
 956 
<span class="line-modified"> 957 LayoutSize FormattingContext::Geometry::inFlowPositionedPositionOffset(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
 958 {
 959     ASSERT(layoutBox.isInFlowPositioned());
 960 
 961     // 9.4.3 Relative positioning
 962     //
 963     // The &#39;top&#39; and &#39;bottom&#39; properties move relatively positioned element(s) up or down without changing their size.
 964     // Top&#39; moves the boxes down, and &#39;bottom&#39; moves them up. Since boxes are not split or stretched as a result of &#39;top&#39; or &#39;bottom&#39;, the used values are always: top = -bottom.
 965     //
 966     // 1. If both are &#39;auto&#39;, their used values are both &#39;0&#39;.
 967     // 2. If one of them is &#39;auto&#39;, it becomes the negative of the other.
 968     // 3. If neither is &#39;auto&#39;, &#39;bottom&#39; is ignored (i.e., the used value of &#39;bottom&#39; will be minus the value of &#39;top&#39;).
 969 
 970     auto&amp; style = layoutBox.style();
<span class="line-modified"> 971     auto&amp; containingBlock = *layoutBox.containingBlock();</span>
<span class="line-removed"> 972     auto containingBlockWidth = layoutState.displayBoxForLayoutBox(containingBlock).contentBoxWidth();</span>
 973 
 974     auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
 975     auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
 976 
 977     if (!top &amp;&amp; !bottom) {
 978         // #1
 979         top = bottom = { 0 };
 980     } else if (!top) {
 981         // #2
 982         top = -*bottom;
 983     } else if (!bottom) {
 984         // #3
 985         bottom = -*top;
 986     } else {
 987         // #4
 988         bottom = WTF::nullopt;
 989     }
 990 
 991     // For relatively positioned elements, &#39;left&#39; and &#39;right&#39; move the box(es) horizontally, without changing their size.
 992     // &#39;Left&#39; moves the boxes to the right, and &#39;right&#39; moves them to the left.
</pre>
<hr />
<pre>
 996     // 2. If &#39;left&#39; is &#39;auto&#39;, its used value is minus the value of &#39;right&#39; (i.e., the boxes move to the left by the value of &#39;right&#39;).
 997     // 3. If &#39;right&#39; is specified as &#39;auto&#39;, its used value is minus the value of &#39;left&#39;.
 998     // 4. If neither &#39;left&#39; nor &#39;right&#39; is &#39;auto&#39;, the position is over-constrained, and one of them has to be ignored.
 999     //    If the &#39;direction&#39; property of the containing block is &#39;ltr&#39;, the value of &#39;left&#39; wins and &#39;right&#39; becomes -&#39;left&#39;.
1000     //    If &#39;direction&#39; of the containing block is &#39;rtl&#39;, &#39;right&#39; wins and &#39;left&#39; is ignored.
1001 
1002     auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
1003     auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);
1004 
1005     if (!left &amp;&amp; !right) {
1006         // #1
1007         left = right = { 0 };
1008     } else if (!left) {
1009         // #2
1010         left = -*right;
1011     } else if (!right) {
1012         // #3
1013         right = -*left;
1014     } else {
1015         // #4
<span class="line-modified">1016         auto isLeftToRightDirection = containingBlock.style().isLeftToRightDirection();</span>
1017         if (isLeftToRightDirection)
1018             right = -*left;
1019         else
1020             left = WTF::nullopt;
1021     }
1022 
1023     ASSERT(!bottom || *top == -*bottom);
1024     ASSERT(!left || *left == -*right);
1025 
1026     auto topPositionOffset = *top;
1027     auto leftPositionOffset = left.valueOr(-*right);
1028 
1029     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position] -&gt; positioned inflow -&gt; top offset(&quot; &lt;&lt; topPositionOffset &lt;&lt; &quot;px) left offset(&quot; &lt;&lt; leftPositionOffset &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
1030     return { leftPositionOffset, topPositionOffset };
1031 }
1032 
<span class="line-modified">1033 Edges FormattingContext::Geometry::computedBorder(const Box&amp; layoutBox)</span>
1034 {
1035     auto&amp; style = layoutBox.style();
1036     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Border] -&gt; layoutBox: &quot; &lt;&lt; &amp;layoutBox);
1037     return {
1038         { LayoutUnit(style.borderLeft().boxModelWidth()), LayoutUnit(style.borderRight().boxModelWidth()) },
1039         { LayoutUnit(style.borderTop().boxModelWidth()), LayoutUnit(style.borderBottom().boxModelWidth()) }
1040     };
1041 }
1042 
<span class="line-modified">1043 Optional&lt;Edges&gt; FormattingContext::Geometry::computedPadding(const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
1044 {
1045     if (!layoutBox.isPaddingApplicable())
1046         return WTF::nullopt;
1047 
1048     auto&amp; style = layoutBox.style();
<span class="line-modified">1049     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);</span>
1050     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Padding] -&gt; layoutBox: &quot; &lt;&lt; &amp;layoutBox);
1051     return Edges {
1052         { valueForLength(style.paddingLeft(), containingBlockWidth), valueForLength(style.paddingRight(), containingBlockWidth) },
1053         { valueForLength(style.paddingTop(), containingBlockWidth), valueForLength(style.paddingBottom(), containingBlockWidth) }
1054     };
1055 }
1056 
<span class="line-modified">1057 ComputedHorizontalMargin FormattingContext::Geometry::computedHorizontalMargin(const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
1058 {
1059     auto&amp; style = layoutBox.style();
<span class="line-modified">1060     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);</span>
1061     return { computedValueIfNotAuto(style.marginStart(), containingBlockWidth), computedValueIfNotAuto(style.marginEnd(), containingBlockWidth) };
1062 }
1063 
<span class="line-modified">1064 ComputedVerticalMargin FormattingContext::Geometry::computedVerticalMargin(const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
1065 {
1066     auto&amp; style = layoutBox.style();
<span class="line-modified">1067     auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);</span>
1068     return { computedValueIfNotAuto(style.marginBefore(), containingBlockWidth), computedValueIfNotAuto(style.marginAfter(), containingBlockWidth) };
1069 }
1070 
<span class="line-modified">1071 FormattingContext::IntrinsicWidthConstraints FormattingContext::Geometry::constrainByMinMaxWidth(const Box&amp; layoutBox, IntrinsicWidthConstraints intrinsicWidth)</span>
1072 {
1073     auto&amp; style = layoutBox.style();
1074     auto minWidth = fixedValue(style.logicalMinWidth());
1075     auto maxWidth = fixedValue(style.logicalMaxWidth());
1076     if (!minWidth &amp;&amp; !maxWidth)
1077         return intrinsicWidth;
1078 
1079     if (maxWidth) {
1080         intrinsicWidth.minimum = std::min(*maxWidth, intrinsicWidth.minimum);
1081         intrinsicWidth.maximum = std::min(*maxWidth, intrinsicWidth.maximum);
1082     }
1083 
1084     if (minWidth) {
1085         intrinsicWidth.minimum = std::max(*minWidth, intrinsicWidth.minimum);
1086         intrinsicWidth.maximum = std::max(*minWidth, intrinsicWidth.maximum);
1087     }
1088 
1089     ASSERT(intrinsicWidth.minimum &lt;= intrinsicWidth.maximum);
1090     return intrinsicWidth;
1091 }
1092 




















1093 }
1094 }
1095 #endif
</pre>
</td>
<td>
<hr />
<pre>
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;FormattingContext.h&quot;
  28 
  29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  30 
  31 #include &quot;FloatingState.h&quot;

  32 #include &quot;InlineFormattingState.h&quot;
<span class="line-added">  33 #include &quot;LayoutContext.h&quot;</span>
<span class="line-added">  34 #include &quot;Logging.h&quot;</span>
  35 #include &quot;TableFormattingState.h&quot;

  36 
  37 namespace WebCore {
  38 namespace Layout {
  39 
  40 static inline bool isHeightAuto(const Box&amp; layoutBox)
  41 {
  42     // 10.5 Content height: the &#39;height&#39; property
  43     //
  44     // The percentage is calculated with respect to the height of the generated box&#39;s containing block.
  45     // If the height of the containing block is not specified explicitly (i.e., it depends on content height),
  46     // and this element is not absolutely positioned, the used height is calculated as if &#39;auto&#39; was specified.
  47 
  48     auto height = layoutBox.style().logicalHeight();
  49     if (height.isAuto())
  50         return true;
  51 
  52     if (height.isPercent()) {
  53         if (layoutBox.isOutOfFlowPositioned())
  54             return false;
  55 
  56         return !layoutBox.containingBlock()-&gt;style().logicalHeight().isFixed();
  57     }
  58 
  59     return false;
  60 }
  61 
<span class="line-modified">  62 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedHeightValue(const Box&amp; layoutBox, HeightType heightType, Optional&lt;LayoutUnit&gt; containingBlockHeight) const</span>
  63 {
  64     auto&amp; style = layoutBox.style();
  65     auto height = heightType == HeightType::Normal ? style.logicalHeight() : heightType == HeightType::Min ? style.logicalMinHeight() : style.logicalMaxHeight();
  66     if (height.isUndefined() || height.isAuto())
  67         return { };
  68 
  69     if (height.isFixed())
<span class="line-modified">  70         return LayoutUnit { height.value() };</span>
  71 
<span class="line-modified">  72     if (!containingBlockHeight) {</span>

  73         // Containing block&#39;s height is already computed since we layout the out-of-flow boxes as the last step.
<span class="line-modified">  74         ASSERT(!layoutBox.isOutOfFlowPositioned());</span>
<span class="line-modified">  75         if (layoutState().inQuirksMode())</span>
<span class="line-modified">  76             containingBlockHeight = formattingContext().quirks().heightValueOfNearestContainingBlockWithFixedHeight(layoutBox);</span>

  77         else {
<span class="line-modified">  78             auto containingBlockHeightFromStyle = layoutBox.containingBlock()-&gt;style().logicalHeight();</span>
<span class="line-modified">  79             if (containingBlockHeightFromStyle.isFixed())</span>
<span class="line-modified">  80                 containingBlockHeight = LayoutUnit { containingBlockHeightFromStyle.value() };</span>
  81         }
  82     }
  83 
<span class="line-modified">  84     if (!containingBlockHeight)</span>
  85         return { };
  86 
<span class="line-modified">  87     return valueForLength(height, *containingBlockHeight);</span>
<span class="line-added">  88 }</span>
<span class="line-added">  89 </span>
<span class="line-added">  90 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedContentHeight(const Box&amp; layoutBox, Optional&lt;LayoutUnit&gt; containingBlockHeight) const</span>
<span class="line-added">  91 {</span>
<span class="line-added">  92     if (auto height = computedHeightValue(layoutBox, HeightType::Normal, containingBlockHeight)) {</span>
<span class="line-added">  93         if (layoutBox.style().boxSizing() == BoxSizing::ContentBox)</span>
<span class="line-added">  94             return height;</span>
<span class="line-added">  95         auto&amp; boxGeometry = formattingContext().geometryForBox(layoutBox);</span>
<span class="line-added">  96         return *height - (boxGeometry.verticalBorder() + boxGeometry.verticalPadding().valueOr(0));</span>
<span class="line-added">  97     }</span>
<span class="line-added">  98     return { };</span>
<span class="line-added">  99 }</span>
<span class="line-added"> 100 </span>
<span class="line-added"> 101 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedContentWidth(const Box&amp; layoutBox, LayoutUnit containingBlockWidth) const</span>
<span class="line-added"> 102 {</span>
<span class="line-added"> 103     if (auto width = computedValueIfNotAuto(layoutBox.style().logicalWidth(), containingBlockWidth)) {</span>
<span class="line-added"> 104         if (layoutBox.style().boxSizing() == BoxSizing::ContentBox)</span>
<span class="line-added"> 105             return width;</span>
<span class="line-added"> 106         auto&amp; boxGeometry = formattingContext().geometryForBox(layoutBox);</span>
<span class="line-added"> 107         return *width - (boxGeometry.horizontalBorder() + boxGeometry.horizontalPadding().valueOr(0));</span>
<span class="line-added"> 108     }</span>
<span class="line-added"> 109     return { };</span>
 110 }
 111 
<span class="line-modified"> 112 LayoutUnit FormattingContext::Geometry::contentHeightForFormattingContextRoot(const Box&amp; layoutBox) const</span>
 113 {
 114     ASSERT(isHeightAuto(layoutBox) &amp;&amp; (layoutBox.establishesFormattingContext() || layoutBox.isDocumentBox()));
 115 
 116     // 10.6.7 &#39;Auto&#39; heights for block formatting context roots
 117 
 118     // If it only has inline-level children, the height is the distance between the top of the topmost line box and the bottom of the bottommost line box.
 119     // If it has block-level children, the height is the distance between the top margin-edge of the topmost block-level
 120     // child box and the bottom margin-edge of the bottommost block-level child box.
 121 
 122     // In addition, if the element has any floating descendants whose bottom margin edge is below the element&#39;s bottom content edge,
 123     // then the height is increased to include those edges. Only floats that participate in this block formatting context are taken
 124     // into account, e.g., floats inside absolutely positioned descendants or other floats are not.
 125     if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild())
 126         return { };
 127 
<span class="line-modified"> 128     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-modified"> 129     auto&amp; formattingContext = this-&gt;formattingContext();</span>
<span class="line-added"> 130     auto&amp; boxGeometry = formattingContext.geometryForBox(layoutBox);</span>
<span class="line-added"> 131     auto borderAndPaddingTop = boxGeometry.borderTop() + boxGeometry.paddingTop().valueOr(0);</span>
 132     auto top = borderAndPaddingTop;
 133     auto bottom = borderAndPaddingTop;
 134     auto&amp; formattingRootContainer = downcast&lt;Container&gt;(layoutBox);
 135     if (formattingRootContainer.establishesInlineFormattingContext()) {
<span class="line-modified"> 136         auto&amp; lineBoxes = layoutState.establishedInlineFormattingState(formattingRootContainer).displayInlineContent()-&gt;lineBoxes;</span>
 137         // Even empty containers generate one line.
 138         ASSERT(!lineBoxes.isEmpty());
<span class="line-modified"> 139         top = lineBoxes.first().top();</span>
<span class="line-modified"> 140         bottom = lineBoxes.last().bottom();</span>
<span class="line-modified"> 141     } else if (formattingRootContainer.establishesBlockFormattingContext() || formattingRootContainer.establishesTableFormattingContext() || formattingRootContainer.isDocumentBox()) {</span>
 142         if (formattingRootContainer.hasInFlowChild()) {
<span class="line-modified"> 143             auto&amp; firstBoxGeometry = formattingContext.geometryForBox(*formattingRootContainer.firstInFlowChild(), EscapeReason::NeedsGeometryFromEstablishedFormattingContext);</span>
<span class="line-modified"> 144             auto&amp; lastBoxGeometry = formattingContext.geometryForBox(*formattingRootContainer.lastInFlowChild(), EscapeReason::NeedsGeometryFromEstablishedFormattingContext);</span>
<span class="line-modified"> 145             top = firstBoxGeometry.rectWithMargin().top();</span>
<span class="line-modified"> 146             bottom = lastBoxGeometry.rectWithMargin().bottom();</span>
 147         }






 148     } else
 149         ASSERT_NOT_REACHED();
 150 
<span class="line-modified"> 151     auto* formattingContextRoot = &amp;formattingRootContainer;</span>
 152     // TODO: The document renderer is not a formatting context root by default at all. Need to find out what it is.
 153     if (!layoutBox.establishesFormattingContext()) {
 154         ASSERT(layoutBox.isDocumentBox());
 155         formattingContextRoot = &amp;layoutBox.formattingContextRoot();
 156     }
 157 
 158     auto&amp; floatingState = layoutState.establishedFormattingState(*formattingContextRoot).floatingState();
 159     auto floatBottom = floatingState.bottom(*formattingContextRoot);
 160     if (floatBottom) {
 161         bottom = std::max&lt;LayoutUnit&gt;(*floatBottom, bottom);
 162         auto floatTop = floatingState.top(*formattingContextRoot);
 163         ASSERT(floatTop);
 164         top = std::min&lt;LayoutUnit&gt;(*floatTop, top);
 165     }
 166 
 167     auto computedHeight = bottom - top;
 168     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height] -&gt; content height for formatting context root -&gt; height(&quot; &lt;&lt; computedHeight &lt;&lt; &quot;px) layoutBox(&quot;&lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 169     return computedHeight;
 170 }
 171 
<span class="line-modified"> 172 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedValueIfNotAuto(const Length&amp; geometryProperty, LayoutUnit containingBlockWidth) const</span>
 173 {
 174     if (geometryProperty.isUndefined())
 175         return WTF::nullopt;
 176 
 177     if (geometryProperty.isAuto())
 178         return WTF::nullopt;
 179 
 180     return valueForLength(geometryProperty, containingBlockWidth);
 181 }
 182 
<span class="line-modified"> 183 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::fixedValue(const Length&amp; geometryProperty) const</span>
 184 {
 185     if (!geometryProperty.isFixed())
 186         return WTF::nullopt;
 187     return LayoutUnit(geometryProperty.value());
 188 }
 189 
 190 // https://www.w3.org/TR/CSS22/visudet.html#min-max-heights
 191 // Specifies a percentage for determining the used value. The percentage is calculated with respect to the height of the generated box&#39;s containing block.
 192 // If the height of the containing block is not specified explicitly (i.e., it depends on content height), and this element is not absolutely positioned,
 193 // the percentage value is treated as &#39;0&#39; (for &#39;min-height&#39;) or &#39;none&#39; (for &#39;max-height&#39;).
<span class="line-modified"> 194 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMaxHeight(const Box&amp; layoutBox, Optional&lt;LayoutUnit&gt; containingBlockHeight) const</span>
 195 {
<span class="line-modified"> 196     return computedHeightValue(layoutBox, HeightType::Max, containingBlockHeight);</span>
 197 }
 198 
<span class="line-modified"> 199 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMinHeight(const Box&amp; layoutBox, Optional&lt;LayoutUnit&gt; containingBlockHeight) const</span>
 200 {
<span class="line-modified"> 201     if (auto minHeightValue = computedHeightValue(layoutBox, HeightType::Min, containingBlockHeight))</span>
 202         return minHeightValue;
 203 
<span class="line-modified"> 204     return { LayoutUnit { } };</span>
<span class="line-added"> 205 }</span>
<span class="line-added"> 206 </span>
<span class="line-added"> 207 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMinWidth(const Box&amp; layoutBox, LayoutUnit containingBlockWidth) const</span>
<span class="line-added"> 208 {</span>
<span class="line-added"> 209     return computedValueIfNotAuto(layoutBox.style().logicalMinWidth(), containingBlockWidth);</span>
<span class="line-added"> 210 }</span>
<span class="line-added"> 211 </span>
<span class="line-added"> 212 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMaxWidth(const Box&amp; layoutBox, LayoutUnit containingBlockWidth) const</span>
<span class="line-added"> 213 {</span>
<span class="line-added"> 214     return computedValueIfNotAuto(layoutBox.style().logicalMaxWidth(), containingBlockWidth);</span>
 215 }
 216 
<span class="line-modified"> 217 LayoutUnit FormattingContext::Geometry::staticVerticalPositionForOutOfFlowPositioned(const Box&amp; layoutBox, const VerticalConstraints&amp; verticalConstraints) const</span>
 218 {
 219     ASSERT(layoutBox.isOutOfFlowPositioned());
 220 
 221     // For the purposes of this section and the next, the term &quot;static position&quot; (of an element) refers, roughly, to the position an element would have
 222     // had in the normal flow. More precisely, the static position for &#39;top&#39; is the distance from the top edge of the containing block to the top margin
 223     // edge of a hypothetical box that would have been the first box of the element if its specified &#39;position&#39; value had been &#39;static&#39; and its specified
 224     // &#39;float&#39; had been &#39;none&#39; and its specified &#39;clear&#39; had been &#39;none&#39;. (Note that due to the rules in section 9.7 this might require also assuming a different
 225     // computed value for &#39;display&#39;.) The value is negative if the hypothetical box is above the containing block.
 226 
 227     // Start with this box&#39;s border box offset from the parent&#39;s border box.
<span class="line-added"> 228     auto&amp; formattingContext = this-&gt;formattingContext();</span>
 229     LayoutUnit top;
 230     if (auto* previousInFlowSibling = layoutBox.previousInFlowSibling()) {
 231         // Add sibling offset
<span class="line-modified"> 232         auto&amp; previousInFlowBoxGeometry = formattingContext.geometryForBox(*previousInFlowSibling, EscapeReason::OutOfFlowBoxNeedsInFlowGeometry);</span>
<span class="line-modified"> 233         top += previousInFlowBoxGeometry.bottom() + previousInFlowBoxGeometry.nonCollapsedMarginAfter();</span>
 234     } else {
 235         ASSERT(layoutBox.parent());
<span class="line-modified"> 236         top = formattingContext.geometryForBox(*layoutBox.parent(), EscapeReason::OutOfFlowBoxNeedsInFlowGeometry).contentBoxTop();</span>
 237     }
 238 
 239     // Resolve top all the way up to the containing block.
 240     auto&amp; containingBlock = *layoutBox.containingBlock();
 241     // Start with the parent since we pretend that this box is normal flow.
 242     for (auto* container = layoutBox.parent(); container != &amp;containingBlock; container = container-&gt;containingBlock()) {
<span class="line-modified"> 243         auto&amp; boxGeometry = formattingContext.geometryForBox(*container, EscapeReason::OutOfFlowBoxNeedsInFlowGeometry);</span>
 244         // Display::Box::top is the border box top position in its containing block&#39;s coordinate system.
<span class="line-modified"> 245         top += boxGeometry.top();</span>
 246         ASSERT(!container-&gt;isPositioned() || layoutBox.isFixedPositioned());
 247     }
 248     // Move the static position relative to the padding box. This is very specific to abolutely positioned boxes.
<span class="line-modified"> 249     return top - verticalConstraints.logicalTop;</span>

 250 }
 251 
<span class="line-modified"> 252 LayoutUnit FormattingContext::Geometry::staticHorizontalPositionForOutOfFlowPositioned(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints) const</span>
 253 {
 254     ASSERT(layoutBox.isOutOfFlowPositioned());
 255     // See staticVerticalPositionForOutOfFlowPositioned for the definition of the static position.
 256 
 257     // Start with this box&#39;s border box offset from the parent&#39;s border box.
<span class="line-added"> 258     auto&amp; formattingContext = this-&gt;formattingContext();</span>
 259     ASSERT(layoutBox.parent());
<span class="line-modified"> 260     auto left = formattingContext.geometryForBox(*layoutBox.parent(), EscapeReason::OutOfFlowBoxNeedsInFlowGeometry).contentBoxLeft();</span>
 261 
 262     // Resolve left all the way up to the containing block.
 263     auto&amp; containingBlock = *layoutBox.containingBlock();
 264     // Start with the parent since we pretend that this box is normal flow.
 265     for (auto* container = layoutBox.parent(); container != &amp;containingBlock; container = container-&gt;containingBlock()) {
<span class="line-modified"> 266         auto&amp; boxGeometry = formattingContext.geometryForBox(*container, EscapeReason::OutOfFlowBoxNeedsInFlowGeometry);</span>
 267         // Display::Box::left is the border box left position in its containing block&#39;s coordinate system.
<span class="line-modified"> 268         left += boxGeometry.left();</span>
 269         ASSERT(!container-&gt;isPositioned() || layoutBox.isFixedPositioned());
 270     }
 271     // Move the static position relative to the padding box. This is very specific to abolutely positioned boxes.
<span class="line-modified"> 272     return left - horizontalConstraints.logicalLeft;</span>

 273 }
 274 
<span class="line-modified"> 275 LayoutUnit FormattingContext::Geometry::shrinkToFitWidth(const Box&amp; formattingRoot, LayoutUnit availableWidth)</span>
 276 {
 277     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width] -&gt; shrink to fit -&gt; unsupported -&gt; width(&quot; &lt;&lt; LayoutUnit { } &lt;&lt; &quot;px) layoutBox: &quot; &lt;&lt; &amp;formattingRoot &lt;&lt; &quot;)&quot;);
 278     ASSERT(formattingRoot.establishesFormattingContext());

 279 
 280     // Calculation of the shrink-to-fit width is similar to calculating the width of a table cell using the automatic table layout algorithm.
 281     // Roughly: calculate the preferred width by formatting the content without breaking lines other than where explicit line breaks occur,
 282     // and also calculate the preferred minimum width, e.g., by trying all possible line breaks. CSS 2.2 does not define the exact algorithm.
 283     // Thirdly, find the available width: in this case, this is the width of the containing block minus the used values of &#39;margin-left&#39;, &#39;border-left-width&#39;,
 284     // &#39;padding-left&#39;, &#39;padding-right&#39;, &#39;border-right-width&#39;, &#39;margin-right&#39;, and the widths of any relevant scroll bars.
 285 
 286     // Then the shrink-to-fit width is: min(max(preferred minimum width, available width), preferred width).
<span class="line-modified"> 287     auto intrinsicWidthConstraints = IntrinsicWidthConstraints { };</span>
<span class="line-modified"> 288     if (is&lt;Container&gt;(formattingRoot) &amp;&amp; downcast&lt;Container&gt;(formattingRoot).hasInFlowOrFloatingChild()) {</span>
<span class="line-modified"> 289         auto&amp; root = downcast&lt;Container&gt;(formattingRoot);</span>
<span class="line-modified"> 290         auto&amp; formattingStateForRoot = layoutState().ensureFormattingState(root);</span>
<span class="line-modified"> 291         auto precomputedIntrinsicWidthConstraints = formattingStateForRoot.intrinsicWidthConstraints();</span>
<span class="line-modified"> 292         if (!precomputedIntrinsicWidthConstraints)</span>
<span class="line-added"> 293             intrinsicWidthConstraints = LayoutContext::createFormattingContext(root, layoutState())-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-added"> 294         else</span>
<span class="line-added"> 295             intrinsicWidthConstraints = *precomputedIntrinsicWidthConstraints;</span>
<span class="line-added"> 296     }</span>
<span class="line-added"> 297     return std::min(std::max(intrinsicWidthConstraints.minimum, availableWidth), intrinsicWidthConstraints.maximum);</span>
 298 }
 299 
<span class="line-modified"> 300 VerticalGeometry FormattingContext::Geometry::outOfFlowNonReplacedVerticalGeometry(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp; verticalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
 301 {
 302     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; !layoutBox.replaced());
<span class="line-added"> 303     ASSERT(verticalConstraints.logicalHeight);</span>
 304 
 305     // 10.6.4 Absolutely positioned, non-replaced elements
 306     //
 307     // For absolutely positioned elements, the used values of the vertical dimensions must satisfy this constraint:
 308     // &#39;top&#39; + &#39;margin-top&#39; + &#39;border-top-width&#39; + &#39;padding-top&#39; + &#39;height&#39; + &#39;padding-bottom&#39; + &#39;border-bottom-width&#39; + &#39;margin-bottom&#39; + &#39;bottom&#39;
 309     // = height of containing block
 310 
 311     // If all three of &#39;top&#39;, &#39;height&#39;, and &#39;bottom&#39; are auto, set &#39;top&#39; to the static position and apply rule number three below.
 312 
 313     // If none of the three are &#39;auto&#39;: If both &#39;margin-top&#39; and &#39;margin-bottom&#39; are &#39;auto&#39;, solve the equation under the extra
 314     // constraint that the two margins get equal values. If one of &#39;margin-top&#39; or &#39;margin-bottom&#39; is &#39;auto&#39;, solve the equation for that value.
 315     // If the values are over-constrained, ignore the value for &#39;bottom&#39; and solve for that value.
 316 
 317     // Otherwise, pick the one of the following six rules that applies.
 318 
 319     // 1. &#39;top&#39; and &#39;height&#39; are &#39;auto&#39; and &#39;bottom&#39; is not &#39;auto&#39;, then the height is based on the content per 10.6.7,
 320     //     set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;top&#39;
 321     // 2. &#39;top&#39; and &#39;bottom&#39; are &#39;auto&#39; and &#39;height&#39; is not &#39;auto&#39;, then set &#39;top&#39; to the static position, set &#39;auto&#39; values for
 322     //    &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;bottom&#39;
 323     // 3. &#39;height&#39; and &#39;bottom&#39; are &#39;auto&#39; and &#39;top&#39; is not &#39;auto&#39;, then the height is based on the content per 10.6.7, set &#39;auto&#39;
 324     //     values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;bottom&#39;
 325     // 4. &#39;top&#39; is &#39;auto&#39;, &#39;height&#39; and &#39;bottom&#39; are not &#39;auto&#39;, then set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;top&#39;
 326     // 5. &#39;height&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;bottom&#39; are not &#39;auto&#39;, then &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; are set to 0 and solve for &#39;height&#39;
 327     // 6. &#39;bottom&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;height&#39; are not &#39;auto&#39;, then set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0 and solve for &#39;bottom&#39;
 328 
<span class="line-added"> 329     auto&amp; formattingContext = this-&gt;formattingContext();</span>
 330     auto&amp; style = layoutBox.style();
<span class="line-modified"> 331     auto&amp; boxGeometry = formattingContext.geometryForBox(layoutBox);</span>
<span class="line-modified"> 332     auto containingBlockHeight = *verticalConstraints.logicalHeight;</span>
<span class="line-modified"> 333     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>

 334 
 335     auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
 336     auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
<span class="line-modified"> 337     auto height = overrideVerticalValues.height ? overrideVerticalValues.height.value() : computedContentHeight(layoutBox, containingBlockHeight);</span>
<span class="line-modified"> 338     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, horizontalConstraints);</span>
 339     UsedVerticalMargin::NonCollapsedValues usedVerticalMargin;
<span class="line-modified"> 340     auto paddingTop = boxGeometry.paddingTop().valueOr(0);</span>
<span class="line-modified"> 341     auto paddingBottom = boxGeometry.paddingBottom().valueOr(0);</span>
<span class="line-modified"> 342     auto borderTop = boxGeometry.borderTop();</span>
<span class="line-modified"> 343     auto borderBottom = boxGeometry.borderBottom();</span>




 344 
 345     if (!top &amp;&amp; !height &amp;&amp; !bottom)
<span class="line-modified"> 346         top = staticVerticalPositionForOutOfFlowPositioned(layoutBox, verticalConstraints);</span>
 347 
 348     if (top &amp;&amp; height &amp;&amp; bottom) {
 349         if (!computedVerticalMargin.before &amp;&amp; !computedVerticalMargin.after) {
<span class="line-modified"> 350             auto marginBeforeAndAfter = containingBlockHeight - (*top + borderTop + paddingTop + *height + paddingBottom + borderBottom + *bottom);</span>
 351             usedVerticalMargin = { marginBeforeAndAfter / 2, marginBeforeAndAfter / 2 };
 352         } else if (!computedVerticalMargin.before) {
 353             usedVerticalMargin.after = *computedVerticalMargin.after;
<span class="line-modified"> 354             usedVerticalMargin.before = containingBlockHeight - (*top + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);</span>
 355         } else if (!computedVerticalMargin.after) {
 356             usedVerticalMargin.before = *computedVerticalMargin.before;
<span class="line-modified"> 357             usedVerticalMargin.after = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + *bottom);</span>
 358         } else
 359             usedVerticalMargin = { *computedVerticalMargin.before, *computedVerticalMargin.after };
 360         // Over-constrained?
<span class="line-modified"> 361         auto boxHeight = *top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom;</span>
 362         if (boxHeight != containingBlockHeight)
<span class="line-modified"> 363             bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after);</span>
 364     }
 365 
 366     if (!top &amp;&amp; !height &amp;&amp; bottom) {
 367         // #1
<span class="line-modified"> 368         height = contentHeightForFormattingContextRoot(layoutBox);</span>
 369         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 370         top = containingBlockHeight - (usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);
 371     }
 372 
 373     if (!top &amp;&amp; !bottom &amp;&amp; height) {
 374         // #2
<span class="line-modified"> 375         top = staticVerticalPositionForOutOfFlowPositioned(layoutBox, verticalConstraints);</span>
 376         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<span class="line-modified"> 377         bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after);</span>
 378     }
 379 
 380     if (!height &amp;&amp; !bottom &amp;&amp; top) {
 381         // #3
<span class="line-modified"> 382         height = contentHeightForFormattingContextRoot(layoutBox);</span>
 383         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 384         bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after);
 385     }
 386 
 387     if (!top &amp;&amp; height &amp;&amp; bottom) {
 388         // #4
 389         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<span class="line-modified"> 390         top = containingBlockHeight - (usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);</span>
 391     }
 392 
 393     if (!height &amp;&amp; top &amp;&amp; bottom) {
 394         // #5
 395         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 396         height = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);
 397     }
 398 
 399     if (!bottom &amp;&amp; top &amp;&amp; height) {
 400         // #6
 401         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<span class="line-modified"> 402         bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after);</span>
 403     }
 404 
 405     ASSERT(top);
 406     ASSERT(bottom);
 407     ASSERT(height);
 408 
 409     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
 410     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<span class="line-modified"> 411     auto containingBlockPaddingVerticalEdge = verticalConstraints.logicalTop;</span>
 412     *top += containingBlockPaddingVerticalEdge;
 413     *bottom += containingBlockPaddingVerticalEdge;
 414 
 415     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Height][Margin] -&gt; out-of-flow non-replaced -&gt; top(&quot; &lt;&lt; *top &lt;&lt; &quot;px) bottom(&quot;  &lt;&lt; *bottom &lt;&lt; &quot;px) height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot;  &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<span class="line-modified"> 416     return { *top, *bottom, { *height, usedVerticalMargin } };</span>
 417 }
 418 
<span class="line-modified"> 419 HorizontalGeometry FormattingContext::Geometry::outOfFlowNonReplacedHorizontalGeometry(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues)</span>
 420 {
 421     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; !layoutBox.replaced());
 422 
 423     // 10.3.7 Absolutely positioned, non-replaced elements
 424     //
 425     // &#39;left&#39; + &#39;margin-left&#39; + &#39;border-left-width&#39; + &#39;padding-left&#39; + &#39;width&#39; + &#39;padding-right&#39; + &#39;border-right-width&#39; + &#39;margin-right&#39; + &#39;right&#39;
 426     // = width of containing block
 427 
 428     // If all three of &#39;left&#39;, &#39;width&#39;, and &#39;right&#39; are &#39;auto&#39;: First set any &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0.
 429     // Then, if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39; set &#39;left&#39; to the static
 430     // position and apply rule number three below; otherwise, set &#39;right&#39; to the static position and apply rule number one below.
 431     //
 432     // If none of the three is &#39;auto&#39;: If both &#39;margin-left&#39; and &#39;margin-right&#39; are &#39;auto&#39;, solve the equation under the extra constraint that the two margins get equal values,
 433     // unless this would make them negative, in which case when direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
 434     // solve for &#39;margin-right&#39; (&#39;margin-left&#39;). If one of &#39;margin-left&#39; or &#39;margin-right&#39; is &#39;auto&#39;, solve the equation for that value.
 435     // If the values are over-constrained, ignore the value for &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or &#39;right&#39;
 436     // (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
 437     //
 438     // Otherwise, set &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0, and pick the one of the following six rules that applies.
 439     //
 440     // 1. &#39;left&#39; and &#39;width&#39; are &#39;auto&#39; and &#39;right&#39; is not &#39;auto&#39;, then the width is shrink-to-fit. Then solve for &#39;left&#39;
 441     // 2. &#39;left&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;width&#39; is not &#39;auto&#39;, then if the &#39;direction&#39; property of the element establishing the static-position
 442     //    containing block is &#39;ltr&#39; set &#39;left&#39; to the static position, otherwise set &#39;right&#39; to the static position.
 443     //    Then solve for &#39;left&#39; (if &#39;direction is &#39;rtl&#39;) or &#39;right&#39; (if &#39;direction&#39; is &#39;ltr&#39;).
 444     // 3. &#39;width&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;left&#39; is not &#39;auto&#39;, then the width is shrink-to-fit . Then solve for &#39;right&#39;
 445     // 4. &#39;left&#39; is &#39;auto&#39;, &#39;width&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve for &#39;left&#39;
 446     // 5. &#39;width&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve for &#39;width&#39;
 447     // 6. &#39;right&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;width&#39; are not &#39;auto&#39;, then solve for &#39;right&#39;
 448 
<span class="line-added"> 449     auto&amp; formattingContext = this-&gt;formattingContext();</span>
 450     auto&amp; style = layoutBox.style();
<span class="line-modified"> 451     auto&amp; boxGeometry = formattingContext.geometryForBox(layoutBox);</span>
<span class="line-modified"> 452     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
<span class="line-modified"> 453     auto isLeftToRightDirection = layoutBox.containingBlock()-&gt;style().isLeftToRightDirection();</span>


 454 
 455     auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
 456     auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);
<span class="line-modified"> 457     auto width = overrideHorizontalValues.width ? overrideHorizontalValues.width : computedContentWidth(layoutBox, containingBlockWidth);</span>
<span class="line-modified"> 458     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, horizontalConstraints);</span>
 459     UsedHorizontalMargin usedHorizontalMargin;
<span class="line-modified"> 460     auto paddingLeft = boxGeometry.paddingLeft().valueOr(0);</span>
<span class="line-modified"> 461     auto paddingRight = boxGeometry.paddingRight().valueOr(0);</span>
<span class="line-modified"> 462     auto borderLeft = boxGeometry.borderLeft();</span>
<span class="line-modified"> 463     auto borderRight = boxGeometry.borderRight();</span>





 464     if (!left &amp;&amp; !width &amp;&amp; !right) {
 465         // If all three of &#39;left&#39;, &#39;width&#39;, and &#39;right&#39; are &#39;auto&#39;: First set any &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0.
 466         // Then, if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39; set &#39;left&#39; to the static
 467         // position and apply rule number three below; otherwise, set &#39;right&#39; to the static position and apply rule number one below.
 468         usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
 469 
<span class="line-modified"> 470         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutBox, horizontalConstraints);</span>
 471         if (isLeftToRightDirection)
 472             left = staticHorizontalPosition;
 473         else
 474             right = staticHorizontalPosition;
 475     } else if (left &amp;&amp; width &amp;&amp; right) {
 476         // If none of the three is &#39;auto&#39;: If both &#39;margin-left&#39; and &#39;margin-right&#39; are &#39;auto&#39;, solve the equation under the extra constraint that the two margins get equal values,
 477         // unless this would make them negative, in which case when direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
 478         // solve for &#39;margin-right&#39; (&#39;margin-left&#39;). If one of &#39;margin-left&#39; or &#39;margin-right&#39; is &#39;auto&#39;, solve the equation for that value.
 479         // If the values are over-constrained, ignore the value for &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or &#39;right&#39;
 480         // (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
 481         if (!computedHorizontalMargin.start &amp;&amp; !computedHorizontalMargin.end) {
<span class="line-modified"> 482             auto marginStartAndEnd = containingBlockWidth - (*left + borderLeft + paddingLeft + *width + paddingRight + borderRight + *right);</span>
 483             if (marginStartAndEnd &gt;= 0)
 484                 usedHorizontalMargin = { marginStartAndEnd / 2, marginStartAndEnd / 2 };
 485             else {
 486                 if (isLeftToRightDirection) {
 487                     usedHorizontalMargin.start = 0_lu;
<span class="line-modified"> 488                     usedHorizontalMargin.end = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + *right);</span>
 489                 } else {
 490                     usedHorizontalMargin.end = 0_lu;
<span class="line-modified"> 491                     usedHorizontalMargin.start = containingBlockWidth - (*left + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
 492                 }
 493             }
 494         } else if (!computedHorizontalMargin.start) {
 495             usedHorizontalMargin.end = *computedHorizontalMargin.end;
<span class="line-modified"> 496             usedHorizontalMargin.start = containingBlockWidth - (*left + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
 497         } else if (!computedHorizontalMargin.end) {
 498             usedHorizontalMargin.start = *computedHorizontalMargin.start;
<span class="line-modified"> 499             usedHorizontalMargin.end = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + *right);</span>
 500         } else {
 501             usedHorizontalMargin = { *computedHorizontalMargin.start, *computedHorizontalMargin.end };
 502             // Overconstrained? Ignore right (left).
 503             if (isLeftToRightDirection)
<span class="line-modified"> 504                 right = containingBlockWidth - (usedHorizontalMargin.start + *left + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end);</span>
 505             else
<span class="line-modified"> 506                 left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
 507         }
 508     } else {
 509         // Otherwise, set &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0, and pick the one of the following six rules that applies.
 510         usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
 511     }
 512 
 513     if (!left &amp;&amp; !width &amp;&amp; right) {
 514         // #1
 515         // Calculate the available width by solving for &#39;width&#39; after setting &#39;left&#39; (in case 1) to 0
 516         left = LayoutUnit { 0 };
 517         auto availableWidth = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);
<span class="line-modified"> 518         width = shrinkToFitWidth(layoutBox, availableWidth);</span>
 519         left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight  + borderRight + usedHorizontalMargin.end + *right);
 520     } else if (!left &amp;&amp; !right &amp;&amp; width) {
 521         // #2
<span class="line-modified"> 522         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutBox, horizontalConstraints);</span>
 523         if (isLeftToRightDirection) {
 524             left = staticHorizontalPosition;
<span class="line-modified"> 525             right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end);</span>
 526         } else {
 527             right = staticHorizontalPosition;
<span class="line-modified"> 528             left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
 529         }
 530     } else if (!width &amp;&amp; !right &amp;&amp; left) {
 531         // #3
 532         // Calculate the available width by solving for &#39;width&#39; after setting &#39;right&#39; (in case 3) to 0
 533         right = LayoutUnit { 0 };
 534         auto availableWidth = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);
<span class="line-modified"> 535         width = shrinkToFitWidth(layoutBox, availableWidth);</span>
 536         right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end);
 537     } else if (!left &amp;&amp; width &amp;&amp; right) {
 538         // #4
<span class="line-modified"> 539         left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
 540     } else if (!width &amp;&amp; left &amp;&amp; right) {
 541         // #5
 542         width = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);
 543     } else if (!right &amp;&amp; left &amp;&amp; width) {
 544         // #6
<span class="line-modified"> 545         right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end);</span>
 546     }
 547 
 548     ASSERT(left);
 549     ASSERT(right);
 550     ASSERT(width);
 551 
 552     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
 553     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<span class="line-modified"> 554     auto containingBlockPaddingVerticalEdge = horizontalConstraints.logicalLeft;</span>
 555     *left += containingBlockPaddingVerticalEdge;
 556     *right += containingBlockPaddingVerticalEdge;
 557 
 558     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Width][Margin] -&gt; out-of-flow non-replaced -&gt; left(&quot; &lt;&lt; *left &lt;&lt; &quot;px) right(&quot;  &lt;&lt; *right &lt;&lt; &quot;px) width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedHorizontalMargin.start &lt;&lt; &quot;px, &quot;  &lt;&lt; usedHorizontalMargin.end &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<span class="line-modified"> 559     return { *left, *right, { *width, usedHorizontalMargin, computedHorizontalMargin } };</span>
 560 }
 561 
<span class="line-modified"> 562 VerticalGeometry FormattingContext::Geometry::outOfFlowReplacedVerticalGeometry(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp; verticalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
 563 {
 564     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; layoutBox.replaced());
<span class="line-added"> 565     ASSERT(verticalConstraints.logicalHeight);</span>
 566 
 567     // 10.6.5 Absolutely positioned, replaced elements
 568     //
 569     // The used value of &#39;height&#39; is determined as for inline replaced elements.
 570     // If &#39;margin-top&#39; or &#39;margin-bottom&#39; is specified as &#39;auto&#39; its used value is determined by the rules below.
 571     // 1. If both &#39;top&#39; and &#39;bottom&#39; have the value &#39;auto&#39;, replace &#39;top&#39; with the element&#39;s static position.
 572     // 2. If &#39;bottom&#39; is &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-top&#39; or &#39;margin-bottom&#39; with &#39;0&#39;.
 573     // 3. If at this point both &#39;margin-top&#39; and &#39;margin-bottom&#39; are still &#39;auto&#39;, solve the equation under the extra constraint that the two margins must get equal values.
 574     // 4. If at this point there is only one &#39;auto&#39; left, solve the equation for that value.
 575     // 5. If at this point the values are over-constrained, ignore the value for &#39;bottom&#39; and solve for that value.
 576 
<span class="line-added"> 577     auto&amp; formattingContext = this-&gt;formattingContext();</span>
 578     auto&amp; style = layoutBox.style();
<span class="line-modified"> 579     auto&amp; boxGeometry = formattingContext.geometryForBox(layoutBox);</span>
<span class="line-modified"> 580     auto containingBlockHeight = *verticalConstraints.logicalHeight;</span>
<span class="line-modified"> 581     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>

 582 
 583     auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
 584     auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
<span class="line-modified"> 585     auto height = inlineReplacedHeightAndMargin(layoutBox, horizontalConstraints, verticalConstraints, overrideVerticalValues).contentHeight;</span>
<span class="line-modified"> 586     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, horizontalConstraints);</span>
 587     Optional&lt;LayoutUnit&gt; usedMarginBefore = computedVerticalMargin.before;
 588     Optional&lt;LayoutUnit&gt; usedMarginAfter = computedVerticalMargin.after;
<span class="line-modified"> 589     auto paddingTop = boxGeometry.paddingTop().valueOr(0);</span>
<span class="line-modified"> 590     auto paddingBottom = boxGeometry.paddingBottom().valueOr(0);</span>
<span class="line-modified"> 591     auto borderTop = boxGeometry.borderTop();</span>
<span class="line-modified"> 592     auto borderBottom = boxGeometry.borderBottom();</span>
 593 
 594     if (!top &amp;&amp; !bottom) {
 595         // #1
<span class="line-modified"> 596         top = staticVerticalPositionForOutOfFlowPositioned(layoutBox, verticalConstraints);</span>
 597     }
 598 
 599     if (!bottom) {
 600         // #2
 601         usedMarginBefore = computedVerticalMargin.before.valueOr(0);
 602         usedMarginAfter = usedMarginBefore;
 603     }
 604 
 605     if (!usedMarginBefore &amp;&amp; !usedMarginAfter) {
 606         // #3
 607         auto marginBeforeAndAfter = containingBlockHeight - (*top + borderTop + paddingTop + height + paddingBottom + borderBottom + *bottom);
 608         usedMarginBefore = marginBeforeAndAfter / 2;
 609         usedMarginAfter = usedMarginBefore;
 610     }
 611 
 612     // #4
 613     if (!top)
 614         top = containingBlockHeight - (*usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter + *bottom);
 615 
 616     if (!bottom)
 617         bottom = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter);
 618 
 619     if (!usedMarginBefore)
 620         usedMarginBefore = containingBlockHeight - (*top + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter + *bottom);
 621 
 622     if (!usedMarginAfter)
 623         usedMarginAfter = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *bottom);
 624 
 625     // #5
 626     auto boxHeight = *top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter + *bottom;
 627     if (boxHeight &gt; containingBlockHeight)
 628         bottom = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter);
 629 
 630     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
 631     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<span class="line-modified"> 632     auto containingBlockPaddingVerticalEdge = verticalConstraints.logicalTop;</span>
 633     *top += containingBlockPaddingVerticalEdge;
 634     *bottom += containingBlockPaddingVerticalEdge;
 635 
 636     ASSERT(top);
 637     ASSERT(bottom);
 638     ASSERT(usedMarginBefore);
 639     ASSERT(usedMarginAfter);
 640     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Height][Margin] -&gt; out-of-flow replaced -&gt; top(&quot; &lt;&lt; *top &lt;&lt; &quot;px) bottom(&quot;  &lt;&lt; *bottom &lt;&lt; &quot;px) height(&quot; &lt;&lt; height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; *usedMarginBefore &lt;&lt; &quot;px, &quot;  &lt;&lt; *usedMarginAfter &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 641     return { *top, *bottom, { height, { *usedMarginBefore, *usedMarginAfter } } };
 642 }
 643 
<span class="line-modified"> 644 HorizontalGeometry FormattingContext::Geometry::outOfFlowReplacedHorizontalGeometry(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues) const</span>
 645 {
 646     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; layoutBox.replaced());
 647 
 648     // 10.3.8 Absolutely positioned, replaced elements
 649     // In this case, section 10.3.7 applies up through and including the constraint equation, but the rest of section 10.3.7 is replaced by the following rules:
 650     //
 651     // The used value of &#39;width&#39; is determined as for inline replaced elements. If &#39;margin-left&#39; or &#39;margin-right&#39; is specified as &#39;auto&#39; its used value is determined by the rules below.
 652     // 1. If both &#39;left&#39; and &#39;right&#39; have the value &#39;auto&#39;, then if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39;,
 653     //   set &#39;left&#39; to the static position; else if &#39;direction&#39; is &#39;rtl&#39;, set &#39;right&#39; to the static position.
 654     // 2. If &#39;left&#39; or &#39;right&#39; are &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-left&#39; or &#39;margin-right&#39; with &#39;0&#39;.
 655     // 3. If at this point both &#39;margin-left&#39; and &#39;margin-right&#39; are still &#39;auto&#39;, solve the equation under the extra constraint that the two margins must get equal values,
 656     //   unless this would make them negative, in which case when the direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
 657     //   solve for &#39;margin-right&#39; (&#39;margin-left&#39;).
 658     // 4. If at this point there is an &#39;auto&#39; left, solve the equation for that value.
 659     // 5. If at this point the values are over-constrained, ignore the value for either &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or
 660     //   &#39;right&#39; (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
 661 
<span class="line-added"> 662     auto&amp; formattingContext = this-&gt;formattingContext();</span>
 663     auto&amp; style = layoutBox.style();
<span class="line-modified"> 664     auto&amp; boxGeometry = formattingContext.geometryForBox(layoutBox);</span>
<span class="line-modified"> 665     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
<span class="line-modified"> 666     auto isLeftToRightDirection = layoutBox.containingBlock()-&gt;style().isLeftToRightDirection();</span>

 667 
 668     auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
 669     auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);
<span class="line-modified"> 670     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, horizontalConstraints);</span>
 671     Optional&lt;LayoutUnit&gt; usedMarginStart = computedHorizontalMargin.start;
 672     Optional&lt;LayoutUnit&gt; usedMarginEnd = computedHorizontalMargin.end;
<span class="line-modified"> 673     auto width = inlineReplacedWidthAndMargin(layoutBox, horizontalConstraints, overrideHorizontalValues).contentWidth;</span>
<span class="line-modified"> 674     auto paddingLeft = boxGeometry.paddingLeft().valueOr(0);</span>
<span class="line-modified"> 675     auto paddingRight = boxGeometry.paddingRight().valueOr(0);</span>
<span class="line-modified"> 676     auto borderLeft = boxGeometry.borderLeft();</span>
<span class="line-modified"> 677     auto borderRight = boxGeometry.borderRight();</span>
 678 
 679     if (!left &amp;&amp; !right) {
 680         // #1
<span class="line-modified"> 681         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutBox, horizontalConstraints);</span>
 682         if (isLeftToRightDirection)
 683             left = staticHorizontalPosition;
 684         else
 685             right = staticHorizontalPosition;
 686     }
 687 
 688     if (!left || !right) {
 689         // #2
 690         usedMarginStart = computedHorizontalMargin.start.valueOr(0);
 691         usedMarginEnd = computedHorizontalMargin.end.valueOr(0);
 692     }
 693 
 694     if (!usedMarginStart &amp;&amp; !usedMarginEnd) {
 695         // #3
 696         auto marginStartAndEnd = containingBlockWidth - (*left + borderLeft + paddingLeft + width + paddingRight + borderRight + *right);
 697         if (marginStartAndEnd &gt;= 0) {
 698             usedMarginStart = marginStartAndEnd / 2;
 699             usedMarginEnd = usedMarginStart;
 700         } else {
 701             if (isLeftToRightDirection) {
</pre>
<hr />
<pre>
 720 
 721     if (!usedMarginEnd)
 722         usedMarginEnd = containingBlockWidth - (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *right);
 723 
 724     auto boxWidth = (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 725     if (boxWidth &gt; containingBlockWidth) {
 726         // #5 Over-constrained?
 727         if (isLeftToRightDirection)
 728             right = containingBlockWidth - (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd);
 729         else
 730             left = containingBlockWidth - (*usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 731     }
 732 
 733     ASSERT(left);
 734     ASSERT(right);
 735     ASSERT(usedMarginStart);
 736     ASSERT(usedMarginEnd);
 737 
 738     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
 739     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<span class="line-modified"> 740     auto containingBlockPaddingVerticalEdge = horizontalConstraints.logicalLeft;</span>
 741     *left += containingBlockPaddingVerticalEdge;
 742     *right += containingBlockPaddingVerticalEdge;
 743 
 744     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Width][Margin] -&gt; out-of-flow replaced -&gt; left(&quot; &lt;&lt; *left &lt;&lt; &quot;px) right(&quot;  &lt;&lt; *right &lt;&lt; &quot;px) width(&quot; &lt;&lt; width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; *usedMarginStart &lt;&lt; &quot;px, &quot;  &lt;&lt; *usedMarginEnd &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 745     return { *left, *right, { width, { *usedMarginStart, *usedMarginEnd }, computedHorizontalMargin } };
 746 }
 747 
<span class="line-modified"> 748 ContentHeightAndMargin FormattingContext::Geometry::complicatedCases(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
 749 {
 750     ASSERT(!layoutBox.replaced());
 751     // TODO: Use complicated-case for document renderer for now (see BlockFormattingContext::Geometry::inFlowHeightAndMargin).
<span class="line-modified"> 752     ASSERT((layoutBox.isBlockLevelBox() &amp;&amp; layoutBox.isInFlow() &amp;&amp; !layoutBox.isOverflowVisible()) || layoutBox.isInlineBlockBox() || layoutBox.isFloatingPositioned() || layoutBox.isDocumentBox() || layoutBox.isTableBox());</span>
 753 
 754     // 10.6.6 Complicated cases
 755     //
 756     // Block-level, non-replaced elements in normal flow when &#39;overflow&#39; does not compute to &#39;visible&#39; (except if the &#39;overflow&#39; property&#39;s value has been propagated to the viewport).
 757     // &#39;Inline-block&#39;, non-replaced elements.
 758     // Floating, non-replaced elements.
 759     //
 760     // 1. If &#39;margin-top&#39;, or &#39;margin-bottom&#39; are &#39;auto&#39;, their used value is 0.
 761     // 2. If &#39;height&#39; is &#39;auto&#39;, the height depends on the element&#39;s descendants per 10.6.7.
 762 
<span class="line-modified"> 763     auto height = overrideVerticalValues.height ? overrideVerticalValues.height.value() : computedContentHeight(layoutBox);</span>
<span class="line-modified"> 764     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, horizontalConstraints);</span>
 765     // #1
 766     auto usedVerticalMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 767     // #2
 768     if (!height) {
 769         ASSERT(isHeightAuto(layoutBox));
<span class="line-modified"> 770         height = contentHeightForFormattingContextRoot(layoutBox);</span>
 771     }
 772 
 773     ASSERT(height);
 774 
 775     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; floating non-replaced -&gt; height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot; &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<span class="line-modified"> 776     return ContentHeightAndMargin { *height, usedVerticalMargin };</span>
 777 }
 778 
<span class="line-modified"> 779 ContentWidthAndMargin FormattingContext::Geometry::floatingNonReplacedWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues)</span>
 780 {
 781     ASSERT(layoutBox.isFloatingPositioned() &amp;&amp; !layoutBox.replaced());
 782 
 783     // 10.3.5 Floating, non-replaced elements
 784     //
 785     // 1. If &#39;margin-left&#39;, or &#39;margin-right&#39; are computed as &#39;auto&#39;, their used value is &#39;0&#39;.
 786     // 2. If &#39;width&#39; is computed as &#39;auto&#39;, the used value is the &quot;shrink-to-fit&quot; width.
 787 
<span class="line-modified"> 788     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, horizontalConstraints);</span>
 789 
 790     // #1
 791     auto usedHorizontallMargin = UsedHorizontalMargin { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
 792     // #2
<span class="line-modified"> 793     auto width = overrideHorizontalValues.width ? overrideHorizontalValues.width : computedContentWidth(layoutBox, horizontalConstraints.logicalWidth);</span>
 794     if (!width)
<span class="line-modified"> 795         width = shrinkToFitWidth(layoutBox, horizontalConstraints.logicalWidth);</span>
 796 
 797     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; floating non-replaced -&gt; width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedHorizontallMargin.start &lt;&lt; &quot;px, &quot; &lt;&lt; usedHorizontallMargin.end &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<span class="line-modified"> 798     return ContentWidthAndMargin { *width, usedHorizontallMargin, computedHorizontalMargin };</span>
 799 }
 800 
<span class="line-modified"> 801 ContentHeightAndMargin FormattingContext::Geometry::floatingReplacedHeightAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
 802 {
 803     ASSERT(layoutBox.isFloatingPositioned() &amp;&amp; layoutBox.replaced());
 804 
 805     // 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, &#39;inline-block&#39;
 806     // replaced elements in normal flow and floating replaced elements
 807     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; floating replaced -&gt; redirected to inline replaced&quot;);
<span class="line-modified"> 808     return inlineReplacedHeightAndMargin(layoutBox, horizontalConstraints, { }, overrideVerticalValues);</span>
 809 }
 810 
<span class="line-modified"> 811 ContentWidthAndMargin FormattingContext::Geometry::floatingReplacedWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues) const</span>
 812 {
 813     ASSERT(layoutBox.isFloatingPositioned() &amp;&amp; layoutBox.replaced());
 814 
 815     // 10.3.6 Floating, replaced elements
 816     //
 817     // 1. If &#39;margin-left&#39; or &#39;margin-right&#39; are computed as &#39;auto&#39;, their used value is &#39;0&#39;.
 818     // 2. The used value of &#39;width&#39; is determined as for inline replaced elements.
<span class="line-modified"> 819     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, horizontalConstraints);</span>
 820 
 821     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; floating replaced -&gt; redirected to inline replaced&quot;);
<span class="line-modified"> 822     auto usedMargin = UsedHorizontalMargin { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };</span>
<span class="line-modified"> 823     return inlineReplacedWidthAndMargin(layoutBox, horizontalConstraints, { overrideHorizontalValues.width, usedMargin });</span>
 824 }
 825 
<span class="line-modified"> 826 VerticalGeometry FormattingContext::Geometry::outOfFlowVerticalGeometry(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp; verticalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
 827 {
 828     ASSERT(layoutBox.isOutOfFlowPositioned());
 829 
 830     if (!layoutBox.replaced())
<span class="line-modified"> 831         return outOfFlowNonReplacedVerticalGeometry(layoutBox, horizontalConstraints, verticalConstraints, overrideVerticalValues);</span>
<span class="line-modified"> 832     return outOfFlowReplacedVerticalGeometry(layoutBox, horizontalConstraints, verticalConstraints, overrideVerticalValues);</span>
 833 }
 834 
<span class="line-modified"> 835 HorizontalGeometry FormattingContext::Geometry::outOfFlowHorizontalGeometry(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues)</span>
 836 {
 837     ASSERT(layoutBox.isOutOfFlowPositioned());
 838 
 839     if (!layoutBox.replaced())
<span class="line-modified"> 840         return outOfFlowNonReplacedHorizontalGeometry(layoutBox, horizontalConstraints, overrideHorizontalValues);</span>
<span class="line-modified"> 841     return outOfFlowReplacedHorizontalGeometry(layoutBox, horizontalConstraints, overrideHorizontalValues);</span>
 842 }
 843 
<span class="line-modified"> 844 ContentHeightAndMargin FormattingContext::Geometry::floatingHeightAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
 845 {
 846     ASSERT(layoutBox.isFloatingPositioned());
 847 
 848     if (!layoutBox.replaced())
<span class="line-modified"> 849         return complicatedCases(layoutBox, horizontalConstraints, overrideVerticalValues);</span>
<span class="line-modified"> 850     return floatingReplacedHeightAndMargin(layoutBox, horizontalConstraints, overrideVerticalValues);</span>
 851 }
 852 
<span class="line-modified"> 853 ContentWidthAndMargin FormattingContext::Geometry::floatingWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues)</span>
 854 {
 855     ASSERT(layoutBox.isFloatingPositioned());
 856 
 857     if (!layoutBox.replaced())
<span class="line-modified"> 858         return floatingNonReplacedWidthAndMargin(layoutBox, horizontalConstraints, overrideHorizontalValues);</span>
<span class="line-modified"> 859     return floatingReplacedWidthAndMargin(layoutBox, horizontalConstraints, overrideHorizontalValues);</span>
 860 }
 861 
<span class="line-modified"> 862 ContentHeightAndMargin FormattingContext::Geometry::inlineReplacedHeightAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, Optional&lt;VerticalConstraints&gt; verticalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
 863 {
 864     ASSERT((layoutBox.isOutOfFlowPositioned() || layoutBox.isFloatingPositioned() || layoutBox.isInFlow()) &amp;&amp; layoutBox.replaced());
 865 
 866     // 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, &#39;inline-block&#39; replaced elements in normal flow and floating replaced elements
 867     //
 868     // 1. If &#39;margin-top&#39;, or &#39;margin-bottom&#39; are &#39;auto&#39;, their used value is 0.
 869     // 2. If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element also has an intrinsic height, then that intrinsic height is the used value of &#39;height&#39;.
 870     // 3. Otherwise, if &#39;height&#39; has a computed value of &#39;auto&#39;, and the element has an intrinsic ratio then the used value of &#39;height&#39; is:
 871     //    (used width) / (intrinsic ratio)
 872     // 4. Otherwise, if &#39;height&#39; has a computed value of &#39;auto&#39;, and the element has an intrinsic height, then that intrinsic height is the used value of &#39;height&#39;.
 873     // 5. Otherwise, if &#39;height&#39; has a computed value of &#39;auto&#39;, but none of the conditions above are met, then the used value of &#39;height&#39; must be set to
 874     //    the height of the largest rectangle that has a 2:1 ratio, has a height not greater than 150px, and has a width not greater than the device width.
 875 
 876     // #1
<span class="line-modified"> 877     auto&amp; formattingContext = this-&gt;formattingContext();</span>
<span class="line-modified"> 878     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, horizontalConstraints);</span>
 879     auto usedVerticalMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 880     auto&amp; style = layoutBox.style();
 881     auto replaced = layoutBox.replaced();
 882 
<span class="line-modified"> 883     auto height = overrideVerticalValues.height ? overrideVerticalValues.height.value() : computedContentHeight(layoutBox, verticalConstraints ? verticalConstraints-&gt;logicalHeight : WTF::nullopt);</span>
<span class="line-modified"> 884     auto heightIsAuto = !overrideVerticalValues.height &amp;&amp; isHeightAuto(layoutBox);</span>
 885     auto widthIsAuto = style.logicalWidth().isAuto();
 886 
 887     if (heightIsAuto &amp;&amp; widthIsAuto &amp;&amp; replaced-&gt;hasIntrinsicHeight()) {
 888         // #2
 889         height = replaced-&gt;intrinsicHeight();
 890     } else if (heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicRatio()) {
 891         // #3
<span class="line-modified"> 892         auto usedWidth = formattingContext.geometryForBox(layoutBox).width();</span>
 893         height = usedWidth / replaced-&gt;intrinsicRatio();
 894     } else if (heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicHeight()) {
 895         // #4
 896         height = replaced-&gt;intrinsicHeight();
 897     } else if (heightIsAuto) {
 898         // #5
 899         height = { 150 };
 900     }
 901 
 902     ASSERT(height);
 903 
 904     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; inflow replaced -&gt; height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot; &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 905     return { *height, usedVerticalMargin };
 906 }
 907 
<span class="line-modified"> 908 ContentWidthAndMargin FormattingContext::Geometry::inlineReplacedWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues) const</span>
 909 {
 910     ASSERT((layoutBox.isOutOfFlowPositioned() || layoutBox.isFloatingPositioned() || layoutBox.isInFlow()) &amp;&amp; layoutBox.replaced());
 911 
 912     // 10.3.2 Inline, replaced elements
 913     //
 914     // A computed value of &#39;auto&#39; for &#39;margin-left&#39; or &#39;margin-right&#39; becomes a used value of &#39;0&#39;.
 915     //
 916     // 1. If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element also has an intrinsic width, then that intrinsic width is the used value of &#39;width&#39;.
 917     //
 918     // 2. If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element has no intrinsic width, but does have an intrinsic height and intrinsic ratio;
 919     //    or if &#39;width&#39; has a computed value of &#39;auto&#39;, &#39;height&#39; has some other computed value, and the element does have an intrinsic ratio;
 920     //    then the used value of &#39;width&#39; is: (used height) * (intrinsic ratio)
 921     //
 922     // 3. If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element has an intrinsic ratio but no intrinsic height or width,
 923     //    then the used value of &#39;width&#39; is undefined in CSS 2.2. However, it is suggested that, if the containing block&#39;s width does not itself depend on the replaced
 924     //    element&#39;s width, then the used value of &#39;width&#39; is calculated from the constraint equation used for block-level, non-replaced elements in normal flow.
 925     //
 926     // 4. Otherwise, if &#39;width&#39; has a computed value of &#39;auto&#39;, and the element has an intrinsic width, then that intrinsic width is the used value of &#39;width&#39;.
 927     //
 928     // 5. Otherwise, if &#39;width&#39; has a computed value of &#39;auto&#39;, but none of the conditions above are met, then the used value of &#39;width&#39; becomes 300px.
 929     //    If 300px is too wide to fit the device, UAs should use the width of the largest rectangle that has a 2:1 ratio and fits the device instead.
 930 
<span class="line-modified"> 931     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, horizontalConstraints);</span>


 932 
 933     auto usedMarginStart = [&amp;] {
<span class="line-modified"> 934         if (overrideHorizontalValues.margin)</span>
<span class="line-modified"> 935             return overrideHorizontalValues.margin-&gt;start;</span>
 936         return computedHorizontalMargin.start.valueOr(0_lu);
 937     };
 938 
 939     auto usedMarginEnd = [&amp;] {
<span class="line-modified"> 940         if (overrideHorizontalValues.margin)</span>
<span class="line-modified"> 941             return overrideHorizontalValues.margin-&gt;end;</span>
 942         return computedHorizontalMargin.end.valueOr(0_lu);
 943     };
 944 
 945     auto replaced = layoutBox.replaced();
 946     ASSERT(replaced);
 947 
<span class="line-modified"> 948     auto width = overrideHorizontalValues.width ? overrideHorizontalValues.width : computedContentWidth(layoutBox, horizontalConstraints.logicalWidth);</span>
 949     auto heightIsAuto = isHeightAuto(layoutBox);
<span class="line-modified"> 950     auto height = computedContentHeight(layoutBox);</span>
 951 
 952     if (!width &amp;&amp; heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicWidth()) {
 953         // #1
 954         width = replaced-&gt;intrinsicWidth();
 955     } else if ((!width &amp;&amp; heightIsAuto &amp;&amp; !replaced-&gt;hasIntrinsicWidth() &amp;&amp; replaced-&gt;hasIntrinsicHeight() &amp;&amp; replaced-&gt;hasIntrinsicRatio())
 956         || (!width &amp;&amp; height &amp;&amp; replaced-&gt;hasIntrinsicRatio())) {
 957         // #2
 958         width = height.valueOr(replaced-&gt;hasIntrinsicHeight()) * replaced-&gt;intrinsicRatio();
 959     } else if (!width &amp;&amp; heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicRatio() &amp;&amp; !replaced-&gt;hasIntrinsicWidth() &amp;&amp; !replaced-&gt;hasIntrinsicHeight()) {
 960         // #3
 961         // FIXME: undefined but surely doable.
 962         ASSERT_NOT_IMPLEMENTED_YET();
 963     } else if (!width &amp;&amp; replaced-&gt;hasIntrinsicWidth()) {
 964         // #4
 965         width = replaced-&gt;intrinsicWidth();
 966     } else if (!width) {
 967         // #5
 968         width = { 300 };
 969     }
 970 
 971     ASSERT(width);
 972 
 973     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; inflow replaced -&gt; width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedMarginStart() &lt;&lt; &quot;px, &quot; &lt;&lt; usedMarginEnd() &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 974     return { *width, { usedMarginStart(), usedMarginEnd() }, computedHorizontalMargin };
 975 }
 976 
<span class="line-modified"> 977 LayoutSize FormattingContext::Geometry::inFlowPositionedPositionOffset(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints) const</span>
 978 {
 979     ASSERT(layoutBox.isInFlowPositioned());
 980 
 981     // 9.4.3 Relative positioning
 982     //
 983     // The &#39;top&#39; and &#39;bottom&#39; properties move relatively positioned element(s) up or down without changing their size.
 984     // Top&#39; moves the boxes down, and &#39;bottom&#39; moves them up. Since boxes are not split or stretched as a result of &#39;top&#39; or &#39;bottom&#39;, the used values are always: top = -bottom.
 985     //
 986     // 1. If both are &#39;auto&#39;, their used values are both &#39;0&#39;.
 987     // 2. If one of them is &#39;auto&#39;, it becomes the negative of the other.
 988     // 3. If neither is &#39;auto&#39;, &#39;bottom&#39; is ignored (i.e., the used value of &#39;bottom&#39; will be minus the value of &#39;top&#39;).
 989 
 990     auto&amp; style = layoutBox.style();
<span class="line-modified"> 991     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>

 992 
 993     auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
 994     auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
 995 
 996     if (!top &amp;&amp; !bottom) {
 997         // #1
 998         top = bottom = { 0 };
 999     } else if (!top) {
1000         // #2
1001         top = -*bottom;
1002     } else if (!bottom) {
1003         // #3
1004         bottom = -*top;
1005     } else {
1006         // #4
1007         bottom = WTF::nullopt;
1008     }
1009 
1010     // For relatively positioned elements, &#39;left&#39; and &#39;right&#39; move the box(es) horizontally, without changing their size.
1011     // &#39;Left&#39; moves the boxes to the right, and &#39;right&#39; moves them to the left.
</pre>
<hr />
<pre>
1015     // 2. If &#39;left&#39; is &#39;auto&#39;, its used value is minus the value of &#39;right&#39; (i.e., the boxes move to the left by the value of &#39;right&#39;).
1016     // 3. If &#39;right&#39; is specified as &#39;auto&#39;, its used value is minus the value of &#39;left&#39;.
1017     // 4. If neither &#39;left&#39; nor &#39;right&#39; is &#39;auto&#39;, the position is over-constrained, and one of them has to be ignored.
1018     //    If the &#39;direction&#39; property of the containing block is &#39;ltr&#39;, the value of &#39;left&#39; wins and &#39;right&#39; becomes -&#39;left&#39;.
1019     //    If &#39;direction&#39; of the containing block is &#39;rtl&#39;, &#39;right&#39; wins and &#39;left&#39; is ignored.
1020 
1021     auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
1022     auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);
1023 
1024     if (!left &amp;&amp; !right) {
1025         // #1
1026         left = right = { 0 };
1027     } else if (!left) {
1028         // #2
1029         left = -*right;
1030     } else if (!right) {
1031         // #3
1032         right = -*left;
1033     } else {
1034         // #4
<span class="line-modified">1035         auto isLeftToRightDirection = layoutBox.containingBlock()-&gt;style().isLeftToRightDirection();</span>
1036         if (isLeftToRightDirection)
1037             right = -*left;
1038         else
1039             left = WTF::nullopt;
1040     }
1041 
1042     ASSERT(!bottom || *top == -*bottom);
1043     ASSERT(!left || *left == -*right);
1044 
1045     auto topPositionOffset = *top;
1046     auto leftPositionOffset = left.valueOr(-*right);
1047 
1048     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position] -&gt; positioned inflow -&gt; top offset(&quot; &lt;&lt; topPositionOffset &lt;&lt; &quot;px) left offset(&quot; &lt;&lt; leftPositionOffset &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
1049     return { leftPositionOffset, topPositionOffset };
1050 }
1051 
<span class="line-modified">1052 Edges FormattingContext::Geometry::computedBorder(const Box&amp; layoutBox) const</span>
1053 {
1054     auto&amp; style = layoutBox.style();
1055     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Border] -&gt; layoutBox: &quot; &lt;&lt; &amp;layoutBox);
1056     return {
1057         { LayoutUnit(style.borderLeft().boxModelWidth()), LayoutUnit(style.borderRight().boxModelWidth()) },
1058         { LayoutUnit(style.borderTop().boxModelWidth()), LayoutUnit(style.borderBottom().boxModelWidth()) }
1059     };
1060 }
1061 
<span class="line-modified">1062 Optional&lt;Edges&gt; FormattingContext::Geometry::computedPadding(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints) const</span>
1063 {
1064     if (!layoutBox.isPaddingApplicable())
1065         return WTF::nullopt;
1066 
1067     auto&amp; style = layoutBox.style();
<span class="line-modified">1068     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
1069     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Padding] -&gt; layoutBox: &quot; &lt;&lt; &amp;layoutBox);
1070     return Edges {
1071         { valueForLength(style.paddingLeft(), containingBlockWidth), valueForLength(style.paddingRight(), containingBlockWidth) },
1072         { valueForLength(style.paddingTop(), containingBlockWidth), valueForLength(style.paddingBottom(), containingBlockWidth) }
1073     };
1074 }
1075 
<span class="line-modified">1076 ComputedHorizontalMargin FormattingContext::Geometry::computedHorizontalMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints) const</span>
1077 {
1078     auto&amp; style = layoutBox.style();
<span class="line-modified">1079     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
1080     return { computedValueIfNotAuto(style.marginStart(), containingBlockWidth), computedValueIfNotAuto(style.marginEnd(), containingBlockWidth) };
1081 }
1082 
<span class="line-modified">1083 ComputedVerticalMargin FormattingContext::Geometry::computedVerticalMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints) const</span>
1084 {
1085     auto&amp; style = layoutBox.style();
<span class="line-modified">1086     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
1087     return { computedValueIfNotAuto(style.marginBefore(), containingBlockWidth), computedValueIfNotAuto(style.marginAfter(), containingBlockWidth) };
1088 }
1089 
<span class="line-modified">1090 FormattingContext::IntrinsicWidthConstraints FormattingContext::Geometry::constrainByMinMaxWidth(const Box&amp; layoutBox, IntrinsicWidthConstraints intrinsicWidth) const</span>
1091 {
1092     auto&amp; style = layoutBox.style();
1093     auto minWidth = fixedValue(style.logicalMinWidth());
1094     auto maxWidth = fixedValue(style.logicalMaxWidth());
1095     if (!minWidth &amp;&amp; !maxWidth)
1096         return intrinsicWidth;
1097 
1098     if (maxWidth) {
1099         intrinsicWidth.minimum = std::min(*maxWidth, intrinsicWidth.minimum);
1100         intrinsicWidth.maximum = std::min(*maxWidth, intrinsicWidth.maximum);
1101     }
1102 
1103     if (minWidth) {
1104         intrinsicWidth.minimum = std::max(*minWidth, intrinsicWidth.minimum);
1105         intrinsicWidth.maximum = std::max(*minWidth, intrinsicWidth.maximum);
1106     }
1107 
1108     ASSERT(intrinsicWidth.minimum &lt;= intrinsicWidth.maximum);
1109     return intrinsicWidth;
1110 }
1111 
<span class="line-added">1112 HorizontalConstraints FormattingContext::Geometry::horizontalConstraintsForOutOfFlow(const Display::Box&amp; containingBlockGeometry)</span>
<span class="line-added">1113 {</span>
<span class="line-added">1114     return HorizontalConstraints { containingBlockGeometry.paddingBoxLeft(), containingBlockGeometry.paddingBoxWidth() };</span>
<span class="line-added">1115 }</span>
<span class="line-added">1116 </span>
<span class="line-added">1117 VerticalConstraints FormattingContext::Geometry::verticalConstraintsForOutOfFlow(const Display::Box&amp; containingBlockGeometry)</span>
<span class="line-added">1118 {</span>
<span class="line-added">1119     return VerticalConstraints { containingBlockGeometry.paddingBoxTop(), containingBlockGeometry.paddingBoxHeight() };</span>
<span class="line-added">1120 }</span>
<span class="line-added">1121 </span>
<span class="line-added">1122 HorizontalConstraints FormattingContext::Geometry::horizontalConstraintsForInFlow(const Display::Box&amp; containingBlockGeometry)</span>
<span class="line-added">1123 {</span>
<span class="line-added">1124     return HorizontalConstraints { containingBlockGeometry.contentBoxLeft(), containingBlockGeometry.contentBoxWidth() };</span>
<span class="line-added">1125 }</span>
<span class="line-added">1126 </span>
<span class="line-added">1127 VerticalConstraints FormattingContext::Geometry::verticalConstraintsForInFlow(const Display::Box&amp; containingBlockGeometry)</span>
<span class="line-added">1128 {</span>
<span class="line-added">1129     return VerticalConstraints { containingBlockGeometry.contentBoxTop(), { } };</span>
<span class="line-added">1130 }</span>
<span class="line-added">1131 </span>
1132 }
1133 }
1134 #endif
</pre>
</td>
</tr>
</table>
<center><a href="FormattingContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FormattingContextQuirks.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
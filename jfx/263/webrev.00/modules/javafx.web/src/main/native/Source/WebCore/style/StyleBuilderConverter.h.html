<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/StyleBuilderConverter.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2013 Google Inc. All rights reserved.
   3  * Copyright (C) 2014 Apple Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  15  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  16  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  24  * THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #pragma once
  28 
  29 #include &quot;BasicShapeFunctions.h&quot;
  30 #include &quot;CSSCalculationValue.h&quot;
  31 #include &quot;CSSContentDistributionValue.h&quot;
  32 #include &quot;CSSFontFeatureValue.h&quot;
  33 #include &quot;CSSFontStyleValue.h&quot;
  34 #include &quot;CSSFontVariationValue.h&quot;
  35 #include &quot;CSSFunctionValue.h&quot;
  36 #include &quot;CSSGridAutoRepeatValue.h&quot;
  37 #include &quot;CSSGridIntegerRepeatValue.h&quot;
  38 #include &quot;CSSGridLineNamesValue.h&quot;
  39 #include &quot;CSSImageGeneratorValue.h&quot;
  40 #include &quot;CSSImageSetValue.h&quot;
  41 #include &quot;CSSImageValue.h&quot;
  42 #include &quot;CSSPrimitiveValue.h&quot;
  43 #include &quot;CSSPrimitiveValueMappings.h&quot;
  44 #include &quot;CSSReflectValue.h&quot;
  45 #include &quot;FontSelectionValueInlines.h&quot;
  46 #include &quot;Frame.h&quot;
  47 #include &quot;GridPositionsResolver.h&quot;
  48 #include &quot;Length.h&quot;
  49 #include &quot;Pair.h&quot;
  50 #include &quot;QuotesData.h&quot;
  51 #include &quot;RuntimeEnabledFeatures.h&quot;
  52 #include &quot;SVGURIReference.h&quot;
  53 #include &quot;Settings.h&quot;
  54 #include &quot;StyleBuilderState.h&quot;
  55 #include &quot;StyleScrollSnapPoints.h&quot;
  56 #include &quot;TabSize.h&quot;
  57 #include &quot;TouchAction.h&quot;
  58 #include &quot;TransformFunctions.h&quot;
  59 #include &lt;wtf/Optional.h&gt;
  60 
  61 namespace WebCore {
  62 namespace Style {
  63 
  64 // Note that we assume the CSS parser only allows valid CSSValue types.
  65 class BuilderConverter {
  66 public:
  67     static Length convertLength(const BuilderState&amp;, const CSSValue&amp;);
  68     static Length convertLengthOrAuto(const BuilderState&amp;, const CSSValue&amp;);
  69     static Length convertLengthSizing(const BuilderState&amp;, const CSSValue&amp;);
  70     static Length convertLengthMaxSizing(const BuilderState&amp;, const CSSValue&amp;);
  71     static TabSize convertTabSize(const BuilderState&amp;, const CSSValue&amp;);
  72     template&lt;typename T&gt; static T convertComputedLength(BuilderState&amp;, const CSSValue&amp;);
  73     template&lt;typename T&gt; static T convertLineWidth(BuilderState&amp;, const CSSValue&amp;);
  74     static float convertSpacing(BuilderState&amp;, const CSSValue&amp;);
  75     static LengthSize convertRadius(BuilderState&amp;, const CSSValue&amp;);
  76     static LengthPoint convertObjectPosition(BuilderState&amp;, const CSSValue&amp;);
  77     static OptionSet&lt;TextDecoration&gt; convertTextDecoration(BuilderState&amp;, const CSSValue&amp;);
  78     template&lt;typename T&gt; static T convertNumber(BuilderState&amp;, const CSSValue&amp;);
  79     template&lt;typename T&gt; static T convertNumberOrAuto(BuilderState&amp;, const CSSValue&amp;);
  80     static short convertWebkitHyphenateLimitLines(BuilderState&amp;, const CSSValue&amp;);
  81     template&lt;CSSPropertyID&gt; static NinePieceImage convertBorderImage(BuilderState&amp;, CSSValue&amp;);
  82     template&lt;CSSPropertyID&gt; static NinePieceImage convertBorderMask(BuilderState&amp;, CSSValue&amp;);
  83     template&lt;CSSPropertyID&gt; static RefPtr&lt;StyleImage&gt; convertStyleImage(BuilderState&amp;, CSSValue&amp;);
  84     static ImageOrientation convertImageOrientation(BuilderState&amp;, const CSSValue&amp;);
  85     static TransformOperations convertTransform(BuilderState&amp;, const CSSValue&amp;);
  86 #if ENABLE(DARK_MODE_CSS)
  87     static StyleColorScheme convertColorScheme(BuilderState&amp;, const CSSValue&amp;);
  88 #endif
  89     static String convertString(BuilderState&amp;, const CSSValue&amp;);
  90     static String convertStringOrAuto(BuilderState&amp;, const CSSValue&amp;);
  91     static String convertStringOrNone(BuilderState&amp;, const CSSValue&amp;);
  92     static OptionSet&lt;TextEmphasisPosition&gt; convertTextEmphasisPosition(BuilderState&amp;, const CSSValue&amp;);
  93     static TextAlignMode convertTextAlign(BuilderState&amp;, const CSSValue&amp;);
  94     static RefPtr&lt;ClipPathOperation&gt; convertClipPath(BuilderState&amp;, const CSSValue&amp;);
  95     static Resize convertResize(BuilderState&amp;, const CSSValue&amp;);
  96     static int convertMarqueeRepetition(BuilderState&amp;, const CSSValue&amp;);
  97     static int convertMarqueeSpeed(BuilderState&amp;, const CSSValue&amp;);
  98     static Ref&lt;QuotesData&gt; convertQuotes(BuilderState&amp;, const CSSValue&amp;);
  99     static TextUnderlinePosition convertTextUnderlinePosition(BuilderState&amp;, const CSSValue&amp;);
 100     static TextUnderlineOffset convertTextUnderlineOffset(BuilderState&amp;, const CSSValue&amp;);
 101     static TextDecorationThickness convertTextDecorationThickness(BuilderState&amp;, const CSSValue&amp;);
 102     static RefPtr&lt;StyleReflection&gt; convertReflection(BuilderState&amp;, const CSSValue&amp;);
 103     static IntSize convertInitialLetter(BuilderState&amp;, const CSSValue&amp;);
 104     static float convertTextStrokeWidth(BuilderState&amp;, const CSSValue&amp;);
 105     static OptionSet&lt;LineBoxContain&gt; convertLineBoxContain(BuilderState&amp;, const CSSValue&amp;);
 106     static OptionSet&lt;TextDecorationSkip&gt; convertTextDecorationSkip(BuilderState&amp;, const CSSValue&amp;);
 107     static RefPtr&lt;ShapeValue&gt; convertShapeValue(BuilderState&amp;, CSSValue&amp;);
 108 #if ENABLE(CSS_SCROLL_SNAP)
 109     static ScrollSnapType convertScrollSnapType(BuilderState&amp;, const CSSValue&amp;);
 110     static ScrollSnapAlign convertScrollSnapAlign(BuilderState&amp;, const CSSValue&amp;);
 111 #endif
 112     static GridTrackSize convertGridTrackSize(BuilderState&amp;, const CSSValue&amp;);
 113     static Vector&lt;GridTrackSize&gt; convertGridTrackSizeList(BuilderState&amp;, const CSSValue&amp;);
 114     static Optional&lt;GridPosition&gt; convertGridPosition(BuilderState&amp;, const CSSValue&amp;);
 115     static GridAutoFlow convertGridAutoFlow(BuilderState&amp;, const CSSValue&amp;);
 116     static Optional&lt;Length&gt; convertWordSpacing(BuilderState&amp;, const CSSValue&amp;);
 117     static Optional&lt;float&gt; convertPerspective(BuilderState&amp;, const CSSValue&amp;);
 118     static Optional&lt;Length&gt; convertMarqueeIncrement(BuilderState&amp;, const CSSValue&amp;);
 119     static Optional&lt;FilterOperations&gt; convertFilterOperations(BuilderState&amp;, const CSSValue&amp;);
 120 #if PLATFORM(IOS_FAMILY)
 121     static bool convertTouchCallout(BuilderState&amp;, const CSSValue&amp;);
 122 #endif
 123 #if ENABLE(TOUCH_EVENTS)
 124     static Color convertTapHighlightColor(BuilderState&amp;, const CSSValue&amp;);
 125 #endif
 126 #if ENABLE(POINTER_EVENTS)
 127     static OptionSet&lt;TouchAction&gt; convertTouchAction(BuilderState&amp;, const CSSValue&amp;);
 128 #endif
 129 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
 130     static bool convertOverflowScrolling(BuilderState&amp;, const CSSValue&amp;);
 131 #endif
 132     static FontFeatureSettings convertFontFeatureSettings(BuilderState&amp;, const CSSValue&amp;);
 133     static bool convertSmoothScrolling(BuilderState&amp;, const CSSValue&amp;);
 134     static FontSelectionValue convertFontWeightFromValue(const CSSValue&amp;);
 135     static FontSelectionValue convertFontStretchFromValue(const CSSValue&amp;);
 136     static Optional&lt;FontSelectionValue&gt; convertFontStyleFromValue(const CSSValue&amp;);
 137     static FontSelectionValue convertFontWeight(BuilderState&amp;, const CSSValue&amp;);
 138     static FontSelectionValue convertFontStretch(BuilderState&amp;, const CSSValue&amp;);
 139     static FontSelectionValue convertFontStyle(BuilderState&amp;, const CSSValue&amp;);
 140 #if ENABLE(VARIATION_FONTS)
 141     static FontVariationSettings convertFontVariationSettings(BuilderState&amp;, const CSSValue&amp;);
 142 #endif
 143     static SVGLengthValue convertSVGLengthValue(BuilderState&amp;, const CSSValue&amp;);
 144     static Vector&lt;SVGLengthValue&gt; convertSVGLengthVector(BuilderState&amp;, const CSSValue&amp;);
 145     static Vector&lt;SVGLengthValue&gt; convertStrokeDashArray(BuilderState&amp;, const CSSValue&amp;);
 146     static PaintOrder convertPaintOrder(BuilderState&amp;, const CSSValue&amp;);
 147     static float convertOpacity(BuilderState&amp;, const CSSValue&amp;);
 148     static String convertSVGURIReference(BuilderState&amp;, const CSSValue&amp;);
 149     static Color convertSVGColor(BuilderState&amp;, const CSSValue&amp;);
 150     static StyleSelfAlignmentData convertSelfOrDefaultAlignmentData(BuilderState&amp;, const CSSValue&amp;);
 151     static StyleContentAlignmentData convertContentAlignmentData(BuilderState&amp;, const CSSValue&amp;);
 152     static GlyphOrientation convertGlyphOrientation(BuilderState&amp;, const CSSValue&amp;);
 153     static GlyphOrientation convertGlyphOrientationOrAuto(BuilderState&amp;, const CSSValue&amp;);
 154     static Optional&lt;Length&gt; convertLineHeight(BuilderState&amp;, const CSSValue&amp;, float multiplier = 1.f);
 155     static FontSynthesis convertFontSynthesis(BuilderState&amp;, const CSSValue&amp;);
 156 
 157     static BreakBetween convertPageBreakBetween(BuilderState&amp;, const CSSValue&amp;);
 158     static BreakInside convertPageBreakInside(BuilderState&amp;, const CSSValue&amp;);
 159     static BreakBetween convertColumnBreakBetween(BuilderState&amp;, const CSSValue&amp;);
 160     static BreakInside convertColumnBreakInside(BuilderState&amp;, const CSSValue&amp;);
 161 
 162     static OptionSet&lt;HangingPunctuation&gt; convertHangingPunctuation(BuilderState&amp;, const CSSValue&amp;);
 163 
 164     static OptionSet&lt;SpeakAs&gt; convertSpeakAs(BuilderState&amp;, const CSSValue&amp;);
 165 
 166     static Length convertPositionComponentX(BuilderState&amp;, const CSSValue&amp;);
 167     static Length convertPositionComponentY(BuilderState&amp;, const CSSValue&amp;);
 168 
 169     static GapLength convertGapLength(BuilderState&amp;, const CSSValue&amp;);
 170 
 171 private:
 172     friend class BuilderCustom;
 173 
 174     static Length convertToRadiusLength(CSSToLengthConversionData&amp;, const CSSPrimitiveValue&amp;);
 175     static OptionSet&lt;TextEmphasisPosition&gt; valueToEmphasisPosition(const CSSPrimitiveValue&amp;);
 176     static OptionSet&lt;TextDecorationSkip&gt; valueToDecorationSkip(const CSSPrimitiveValue&amp;);
 177 #if ENABLE(CSS_SCROLL_SNAP)
 178     static Length parseSnapCoordinate(BuilderState&amp;, const CSSValue&amp;);
 179 #endif
 180 
 181 #if ENABLE(DARK_MODE_CSS)
 182     static void updateColorScheme(const CSSPrimitiveValue&amp;, StyleColorScheme&amp;);
 183 #endif
 184 
 185     static Length convertTo100PercentMinusLength(const Length&amp;);
 186     template&lt;CSSValueID, CSSValueID&gt; static Length convertPositionComponent(BuilderState&amp;, const CSSPrimitiveValue&amp;);
 187 
 188     static GridLength createGridTrackBreadth(const CSSPrimitiveValue&amp;, BuilderState&amp;);
 189     static GridTrackSize createGridTrackSize(const CSSValue&amp;, BuilderState&amp;);
 190     struct TracksData;
 191     static bool createGridTrackList(const CSSValue&amp;, TracksData&amp;, BuilderState&amp;);
 192     static bool createGridPosition(const CSSValue&amp;, GridPosition&amp;);
 193     static void createImplicitNamedGridLinesFromGridArea(const NamedGridAreaMap&amp;, NamedGridLinesMap&amp;, GridTrackSizingDirection);
 194     static CSSToLengthConversionData csstoLengthConversionDataWithTextZoomFactor(BuilderState&amp;);
 195 };
 196 
 197 inline Length BuilderConverter::convertLength(const BuilderState&amp; builderState, const CSSValue&amp; value)
 198 {
 199     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 200     CSSToLengthConversionData conversionData = builderState.useSVGZoomRulesForLength() ?
 201         builderState.cssToLengthConversionData().copyWithAdjustedZoom(1.0f)
 202         : builderState.cssToLengthConversionData();
 203 
 204     if (primitiveValue.isLength()) {
 205         Length length = primitiveValue.computeLength&lt;Length&gt;(conversionData);
 206         length.setHasQuirk(primitiveValue.isQuirkValue());
 207         return length;
 208     }
 209 
 210     if (primitiveValue.isPercentage())
 211         return Length(primitiveValue.doubleValue(), Percent);
 212 
 213     if (primitiveValue.isCalculatedPercentageWithLength())
 214         return Length(primitiveValue.cssCalcValue()-&gt;createCalculationValue(conversionData));
 215 
 216     ASSERT_NOT_REACHED();
 217     return Length(0, Fixed);
 218 }
 219 
 220 inline Length BuilderConverter::convertLengthOrAuto(const BuilderState&amp; builderState, const CSSValue&amp; value)
 221 {
 222     if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueAuto)
 223         return Length(Auto);
 224     return convertLength(builderState, value);
 225 }
 226 
 227 inline Length BuilderConverter::convertLengthSizing(const BuilderState&amp; builderState, const CSSValue&amp; value)
 228 {
 229     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 230     switch (primitiveValue.valueID()) {
 231     case CSSValueInvalid:
 232         return convertLength(builderState, value);
 233     case CSSValueIntrinsic:
 234         return Length(Intrinsic);
 235     case CSSValueMinIntrinsic:
 236         return Length(MinIntrinsic);
 237     case CSSValueMinContent:
 238     case CSSValueWebkitMinContent:
 239         return Length(MinContent);
 240     case CSSValueMaxContent:
 241     case CSSValueWebkitMaxContent:
 242         return Length(MaxContent);
 243     case CSSValueWebkitFillAvailable:
 244         return Length(FillAvailable);
 245     case CSSValueFitContent:
 246     case CSSValueWebkitFitContent:
 247         return Length(FitContent);
 248     case CSSValueAuto:
 249         return Length(Auto);
 250     default:
 251         ASSERT_NOT_REACHED();
 252         return Length();
 253     }
 254 }
 255 
 256 inline Length BuilderConverter::convertLengthMaxSizing(const BuilderState&amp; builderState, const CSSValue&amp; value)
 257 {
 258     if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone)
 259         return Length(Undefined);
 260     return convertLengthSizing(builderState, value);
 261 }
 262 
 263 inline TabSize BuilderConverter::convertTabSize(const BuilderState&amp; builderState, const CSSValue&amp; value)
 264 {
 265     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 266     if (primitiveValue.isNumber())
 267         return TabSize(primitiveValue.floatValue(), SpaceValueType);
 268     return TabSize(primitiveValue.computeLength&lt;float&gt;(builderState.cssToLengthConversionData()), LengthValueType);
 269 }
 270 
 271 template&lt;typename T&gt;
 272 inline T BuilderConverter::convertComputedLength(BuilderState&amp; builderState, const CSSValue&amp; value)
 273 {
 274     return downcast&lt;CSSPrimitiveValue&gt;(value).computeLength&lt;T&gt;(builderState.cssToLengthConversionData());
 275 }
 276 
 277 template&lt;typename T&gt;
 278 inline T BuilderConverter::convertLineWidth(BuilderState&amp; builderState, const CSSValue&amp; value)
 279 {
 280     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 281     switch (primitiveValue.valueID()) {
 282     case CSSValueThin:
 283         return 1;
 284     case CSSValueMedium:
 285         return 3;
 286     case CSSValueThick:
 287         return 5;
 288     case CSSValueInvalid: {
 289         // Any original result that was &gt;= 1 should not be allowed to fall below 1.
 290         // This keeps border lines from vanishing.
 291         T result = convertComputedLength&lt;T&gt;(builderState, value);
 292         if (builderState.style().effectiveZoom() &lt; 1.0f &amp;&amp; result &lt; 1.0) {
 293             T originalLength = primitiveValue.computeLength&lt;T&gt;(builderState.cssToLengthConversionData().copyWithAdjustedZoom(1.0));
 294             if (originalLength &gt;= 1.0)
 295                 return 1;
 296         }
 297         float minimumLineWidth = 1 / builderState.document().deviceScaleFactor();
 298         if (result &gt; 0 &amp;&amp; result &lt; minimumLineWidth)
 299             return minimumLineWidth;
 300         return floorToDevicePixel(result, builderState.document().deviceScaleFactor());
 301     }
 302     default:
 303         ASSERT_NOT_REACHED();
 304         return 0;
 305     }
 306 }
 307 
 308 inline float BuilderConverter::convertSpacing(BuilderState&amp; builderState, const CSSValue&amp; value)
 309 {
 310     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 311     if (primitiveValue.valueID() == CSSValueNormal)
 312         return 0.f;
 313 
 314     CSSToLengthConversionData conversionData = builderState.useSVGZoomRulesForLength() ?
 315         builderState.cssToLengthConversionData().copyWithAdjustedZoom(1.0f)
 316         : builderState.cssToLengthConversionData();
 317     return primitiveValue.computeLength&lt;float&gt;(conversionData);
 318 }
 319 
 320 inline Length BuilderConverter::convertToRadiusLength(CSSToLengthConversionData&amp; conversionData, const CSSPrimitiveValue&amp; value)
 321 {
 322     if (value.isPercentage())
 323         return Length(value.doubleValue(), Percent);
 324     if (value.isCalculatedPercentageWithLength())
 325         return Length(value.cssCalcValue()-&gt;createCalculationValue(conversionData));
 326     return value.computeLength&lt;Length&gt;(conversionData);
 327 }
 328 
 329 inline LengthSize BuilderConverter::convertRadius(BuilderState&amp; builderState, const CSSValue&amp; value)
 330 {
 331     auto* pair = downcast&lt;CSSPrimitiveValue&gt;(value).pairValue();
 332     if (!pair || !pair-&gt;first() || !pair-&gt;second())
 333         return { { 0, Fixed }, { 0, Fixed } };
 334 
 335     CSSToLengthConversionData conversionData = builderState.cssToLengthConversionData();
 336     LengthSize radius { convertToRadiusLength(conversionData, *pair-&gt;first()), convertToRadiusLength(conversionData, *pair-&gt;second()) };
 337 
 338     ASSERT(!radius.width.isNegative());
 339     ASSERT(!radius.height.isNegative());
 340     if (radius.width.isZero() || radius.height.isZero())
 341         return { { 0, Fixed }, { 0, Fixed } };
 342 
 343     return radius;
 344 }
 345 
 346 inline Length BuilderConverter::convertTo100PercentMinusLength(const Length&amp; length)
 347 {
 348     if (length.isPercent())
 349         return Length(100 - length.value(), Percent);
 350 
 351     // Turn this into a calc expression: calc(100% - length)
 352     Vector&lt;std::unique_ptr&lt;CalcExpressionNode&gt;&gt; lengths;
 353     lengths.reserveInitialCapacity(2);
 354     lengths.uncheckedAppend(makeUnique&lt;CalcExpressionLength&gt;(Length(100, Percent)));
 355     lengths.uncheckedAppend(makeUnique&lt;CalcExpressionLength&gt;(length));
 356     auto op = makeUnique&lt;CalcExpressionOperation&gt;(WTFMove(lengths), CalcOperator::Subtract);
 357     return Length(CalculationValue::create(WTFMove(op), ValueRangeAll));
 358 }
 359 
 360 inline Length BuilderConverter::convertPositionComponentX(BuilderState&amp; builderState, const CSSValue&amp; value)
 361 {
 362     return convertPositionComponent&lt;CSSValueLeft, CSSValueRight&gt;(builderState, downcast&lt;CSSPrimitiveValue&gt;(value));
 363 }
 364 
 365 inline Length BuilderConverter::convertPositionComponentY(BuilderState&amp; builderState, const CSSValue&amp; value)
 366 {
 367     return convertPositionComponent&lt;CSSValueTop, CSSValueBottom&gt;(builderState, downcast&lt;CSSPrimitiveValue&gt;(value));
 368 }
 369 
 370 template&lt;CSSValueID cssValueFor0, CSSValueID cssValueFor100&gt;
 371 inline Length BuilderConverter::convertPositionComponent(BuilderState&amp; builderState, const CSSPrimitiveValue&amp; value)
 372 {
 373     Length length;
 374 
 375     auto* lengthValue = &amp;value;
 376     bool relativeToTrailingEdge = false;
 377 
 378     if (value.isPair()) {
 379         auto&amp; first = *value.pairValue()-&gt;first();
 380         if (first.valueID() == CSSValueRight || first.valueID() == CSSValueBottom)
 381             relativeToTrailingEdge = true;
 382         lengthValue = value.pairValue()-&gt;second();
 383     }
 384 
 385     if (value.isValueID()) {
 386         switch (value.valueID()) {
 387         case cssValueFor0:
 388             return Length(0, Percent);
 389         case cssValueFor100:
 390             return Length(100, Percent);
 391         case CSSValueCenter:
 392             return Length(50, Percent);
 393         default:
 394             ASSERT_NOT_REACHED();
 395         }
 396     }
 397 
 398     length = convertLength(builderState, *lengthValue);
 399 
 400     if (relativeToTrailingEdge)
 401         length = convertTo100PercentMinusLength(length);
 402 
 403     return length;
 404 }
 405 
 406 inline LengthPoint BuilderConverter::convertObjectPosition(BuilderState&amp; builderState, const CSSValue&amp; value)
 407 {
 408     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 409     Pair* pair = primitiveValue.pairValue();
 410     if (!pair || !pair-&gt;first() || !pair-&gt;second())
 411         return RenderStyle::initialObjectPosition();
 412 
 413     Length lengthX = convertPositionComponent&lt;CSSValueLeft, CSSValueRight&gt;(builderState, *pair-&gt;first());
 414     Length lengthY = convertPositionComponent&lt;CSSValueTop, CSSValueBottom&gt;(builderState, *pair-&gt;second());
 415 
 416     return LengthPoint(lengthX, lengthY);
 417 }
 418 
 419 inline OptionSet&lt;TextDecoration&gt; BuilderConverter::convertTextDecoration(BuilderState&amp;, const CSSValue&amp; value)
 420 {
 421     auto result = RenderStyle::initialTextDecoration();
 422     if (is&lt;CSSValueList&gt;(value)) {
 423         for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value))
 424             result.add(downcast&lt;CSSPrimitiveValue&gt;(currentValue.get()));
 425     }
 426     return result;
 427 }
 428 
 429 template&lt;typename T&gt;
 430 inline T BuilderConverter::convertNumber(BuilderState&amp;, const CSSValue&amp; value)
 431 {
 432     return downcast&lt;CSSPrimitiveValue&gt;(value).value&lt;T&gt;(CSSUnitType::CSS_NUMBER);
 433 }
 434 
 435 template&lt;typename T&gt;
 436 inline T BuilderConverter::convertNumberOrAuto(BuilderState&amp; builderState, const CSSValue&amp; value)
 437 {
 438     if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueAuto)
 439         return -1;
 440     return convertNumber&lt;T&gt;(builderState, value);
 441 }
 442 
 443 inline short BuilderConverter::convertWebkitHyphenateLimitLines(BuilderState&amp;, const CSSValue&amp; value)
 444 {
 445     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 446     if (primitiveValue.valueID() == CSSValueNoLimit)
 447         return -1;
 448     return primitiveValue.value&lt;short&gt;(CSSUnitType::CSS_NUMBER);
 449 }
 450 
 451 template&lt;CSSPropertyID property&gt;
 452 inline NinePieceImage BuilderConverter::convertBorderImage(BuilderState&amp; builderState, CSSValue&amp; value)
 453 {
 454     NinePieceImage image;
 455     builderState.styleMap().mapNinePieceImage(property, &amp;value, image);
 456     return image;
 457 }
 458 
 459 template&lt;CSSPropertyID property&gt;
 460 inline NinePieceImage BuilderConverter::convertBorderMask(BuilderState&amp; builderState, CSSValue&amp; value)
 461 {
 462     NinePieceImage image(NinePieceImage::Type::Mask);
 463     builderState.styleMap().mapNinePieceImage(property, &amp;value, image);
 464     return image;
 465 }
 466 
 467 template&lt;CSSPropertyID&gt;
 468 inline RefPtr&lt;StyleImage&gt; BuilderConverter::convertStyleImage(BuilderState&amp; builderState, CSSValue&amp; value)
 469 {
 470     return builderState.createStyleImage(value);
 471 }
 472 
 473 inline ImageOrientation BuilderConverter::convertImageOrientation(BuilderState&amp;, const CSSValue&amp; value)
 474 {
 475     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 476     if (primitiveValue.valueID() == CSSValueFromImage)
 477         return ImageOrientation::FromImage;
 478     return ImageOrientation::None;
 479 }
 480 
 481 inline TransformOperations BuilderConverter::convertTransform(BuilderState&amp; builderState, const CSSValue&amp; value)
 482 {
 483     TransformOperations operations;
 484     transformsForValue(value, builderState.cssToLengthConversionData(), operations);
 485     return operations;
 486 }
 487 
 488 #if ENABLE(DARK_MODE_CSS)
 489 inline void BuilderConverter::updateColorScheme(const CSSPrimitiveValue&amp; primitiveValue, StyleColorScheme&amp; colorScheme)
 490 {
 491     ASSERT(primitiveValue.isValueID());
 492 
 493     switch (primitiveValue.valueID()) {
 494     case CSSValueAuto:
 495         colorScheme = StyleColorScheme();
 496         break;
 497     case CSSValueOnly:
 498         colorScheme.setAllowsTransformations(false);
 499         break;
 500     case CSSValueLight:
 501         colorScheme.add(ColorScheme::Light);
 502         break;
 503     case CSSValueDark:
 504         colorScheme.add(ColorScheme::Dark);
 505         break;
 506     default:
 507         // Unknown identifiers are allowed and ignored.
 508         break;
 509     }
 510 }
 511 
 512 inline StyleColorScheme BuilderConverter::convertColorScheme(BuilderState&amp;, const CSSValue&amp; value)
 513 {
 514     StyleColorScheme colorScheme;
 515 
 516     if (is&lt;CSSValueList&gt;(value)) {
 517         for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value))
 518             updateColorScheme(downcast&lt;CSSPrimitiveValue&gt;(currentValue.get()), colorScheme);
 519     } else if (is&lt;CSSPrimitiveValue&gt;(value))
 520         updateColorScheme(downcast&lt;CSSPrimitiveValue&gt;(value), colorScheme);
 521 
 522     // If the value was just &quot;only&quot;, that is synonymous for &quot;only light&quot;.
 523     if (colorScheme.isOnly())
 524         colorScheme.add(ColorScheme::Light);
 525 
 526     return colorScheme;
 527 }
 528 #endif
 529 
 530 inline String BuilderConverter::convertString(BuilderState&amp;, const CSSValue&amp; value)
 531 {
 532     return downcast&lt;CSSPrimitiveValue&gt;(value).stringValue();
 533 }
 534 
 535 inline String BuilderConverter::convertStringOrAuto(BuilderState&amp; builderState, const CSSValue&amp; value)
 536 {
 537     if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueAuto)
 538         return nullAtom();
 539     return convertString(builderState, value);
 540 }
 541 
 542 inline String BuilderConverter::convertStringOrNone(BuilderState&amp; builderState, const CSSValue&amp; value)
 543 {
 544     if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone)
 545         return nullAtom();
 546     return convertString(builderState, value);
 547 }
 548 
 549 inline OptionSet&lt;TextEmphasisPosition&gt; BuilderConverter::valueToEmphasisPosition(const CSSPrimitiveValue&amp; primitiveValue)
 550 {
 551     ASSERT(primitiveValue.isValueID());
 552 
 553     switch (primitiveValue.valueID()) {
 554     case CSSValueOver:
 555         return TextEmphasisPosition::Over;
 556     case CSSValueUnder:
 557         return TextEmphasisPosition::Under;
 558     case CSSValueLeft:
 559         return TextEmphasisPosition::Left;
 560     case CSSValueRight:
 561         return TextEmphasisPosition::Right;
 562     default:
 563         break;
 564     }
 565 
 566     ASSERT_NOT_REACHED();
 567     return RenderStyle::initialTextEmphasisPosition();
 568 }
 569 
 570 inline OptionSet&lt;TextEmphasisPosition&gt; BuilderConverter::convertTextEmphasisPosition(BuilderState&amp;, const CSSValue&amp; value)
 571 {
 572     if (is&lt;CSSPrimitiveValue&gt;(value))
 573         return valueToEmphasisPosition(downcast&lt;CSSPrimitiveValue&gt;(value));
 574 
 575     OptionSet&lt;TextEmphasisPosition&gt; position;
 576     for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value))
 577         position.add(valueToEmphasisPosition(downcast&lt;CSSPrimitiveValue&gt;(currentValue.get())));
 578     return position;
 579 }
 580 
 581 inline TextAlignMode BuilderConverter::convertTextAlign(BuilderState&amp; builderState, const CSSValue&amp; value)
 582 {
 583     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 584     ASSERT(primitiveValue.isValueID());
 585 
 586     if (primitiveValue.valueID() != CSSValueWebkitMatchParent)
 587         return primitiveValue;
 588 
 589     auto&amp; parentStyle = builderState.parentStyle();
 590     if (parentStyle.textAlign() == TextAlignMode::Start)
 591         return parentStyle.isLeftToRightDirection() ? TextAlignMode::Left : TextAlignMode::Right;
 592     if (parentStyle.textAlign() == TextAlignMode::End)
 593         return parentStyle.isLeftToRightDirection() ? TextAlignMode::Right : TextAlignMode::Left;
 594     return parentStyle.textAlign();
 595 }
 596 
 597 inline RefPtr&lt;ClipPathOperation&gt; BuilderConverter::convertClipPath(BuilderState&amp; builderState, const CSSValue&amp; value)
 598 {
 599     if (is&lt;CSSPrimitiveValue&gt;(value)) {
 600         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 601         if (primitiveValue.primitiveType() == CSSUnitType::CSS_URI) {
 602             String cssURLValue = primitiveValue.stringValue();
 603             String fragment = SVGURIReference::fragmentIdentifierFromIRIString(cssURLValue, builderState.document());
 604             // FIXME: It doesn&#39;t work with external SVG references (see https://bugs.webkit.org/show_bug.cgi?id=126133)
 605             return ReferenceClipPathOperation::create(cssURLValue, fragment);
 606         }
 607         ASSERT(primitiveValue.valueID() == CSSValueNone);
 608         return nullptr;
 609     }
 610 
 611     CSSBoxType referenceBox = CSSBoxType::BoxMissing;
 612     RefPtr&lt;ClipPathOperation&gt; operation;
 613 
 614     for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value)) {
 615         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(currentValue.get());
 616         if (primitiveValue.isShape()) {
 617             ASSERT(!operation);
 618             operation = ShapeClipPathOperation::create(basicShapeForValue(builderState.cssToLengthConversionData(), *primitiveValue.shapeValue()));
 619         } else {
 620             ASSERT(primitiveValue.valueID() == CSSValueContentBox
 621                 || primitiveValue.valueID() == CSSValueBorderBox
 622                 || primitiveValue.valueID() == CSSValuePaddingBox
 623                 || primitiveValue.valueID() == CSSValueMarginBox
 624                 || primitiveValue.valueID() == CSSValueFillBox
 625                 || primitiveValue.valueID() == CSSValueStrokeBox
 626                 || primitiveValue.valueID() == CSSValueViewBox);
 627             ASSERT(referenceBox == CSSBoxType::BoxMissing);
 628             referenceBox = primitiveValue;
 629         }
 630     }
 631     if (operation)
 632         downcast&lt;ShapeClipPathOperation&gt;(*operation).setReferenceBox(referenceBox);
 633     else {
 634         ASSERT(referenceBox != CSSBoxType::BoxMissing);
 635         operation = BoxClipPathOperation::create(referenceBox);
 636     }
 637 
 638     return operation;
 639 }
 640 
 641 inline Resize BuilderConverter::convertResize(BuilderState&amp; builderState, const CSSValue&amp; value)
 642 {
 643     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 644 
 645     Resize resize = Resize::None;
 646     if (primitiveValue.valueID() == CSSValueAuto)
 647         resize = builderState.document().settings().textAreasAreResizable() ? Resize::Both : Resize::None;
 648     else
 649         resize = primitiveValue;
 650 
 651     return resize;
 652 }
 653 
 654 inline int BuilderConverter::convertMarqueeRepetition(BuilderState&amp;, const CSSValue&amp; value)
 655 {
 656     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 657     if (primitiveValue.valueID() == CSSValueInfinite)
 658         return -1; // -1 means repeat forever.
 659 
 660     ASSERT(primitiveValue.isNumber());
 661     return primitiveValue.intValue();
 662 }
 663 
 664 inline int BuilderConverter::convertMarqueeSpeed(BuilderState&amp;, const CSSValue&amp; value)
 665 {
 666     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 667     if (primitiveValue.isTime())
 668         return primitiveValue.computeTime&lt;int, CSSPrimitiveValue::Milliseconds&gt;();
 669     // For scrollamount support.
 670     ASSERT(primitiveValue.isNumber());
 671     return primitiveValue.intValue();
 672 }
 673 
 674 inline Ref&lt;QuotesData&gt; BuilderConverter::convertQuotes(BuilderState&amp;, const CSSValue&amp; value)
 675 {
 676     if (is&lt;CSSPrimitiveValue&gt;(value)) {
 677         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
 678         return QuotesData::create(Vector&lt;std::pair&lt;String, String&gt;&gt;());
 679     }
 680 
 681     auto&amp; list = downcast&lt;CSSValueList&gt;(value);
 682     Vector&lt;std::pair&lt;String, String&gt;&gt; quotes;
 683     quotes.reserveInitialCapacity(list.length() / 2);
 684     for (unsigned i = 0; i &lt; list.length(); i += 2) {
 685         const CSSValue* first = list.itemWithoutBoundsCheck(i);
 686         // item() returns null if out of bounds so this is safe.
 687         const CSSValue* second = list.item(i + 1);
 688         if (!second)
 689             break;
 690         String startQuote = downcast&lt;CSSPrimitiveValue&gt;(*first).stringValue();
 691         String endQuote = downcast&lt;CSSPrimitiveValue&gt;(*second).stringValue();
 692         quotes.append(std::make_pair(startQuote, endQuote));
 693     }
 694     return QuotesData::create(quotes);
 695 }
 696 
 697 inline TextUnderlinePosition BuilderConverter::convertTextUnderlinePosition(BuilderState&amp;, const CSSValue&amp; value)
 698 {
 699     ASSERT(is&lt;CSSPrimitiveValue&gt;(value));
 700     return downcast&lt;CSSPrimitiveValue&gt;(value);
 701 }
 702 
 703 inline TextUnderlineOffset BuilderConverter::convertTextUnderlineOffset(BuilderState&amp; builderState, const CSSValue&amp; value)
 704 {
 705     ASSERT(is&lt;CSSPrimitiveValue&gt;(value));
 706     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 707     switch (primitiveValue.valueID()) {
 708     case CSSValueAuto:
 709         return TextUnderlineOffset::createWithAuto();
 710     default:
 711         ASSERT(primitiveValue.isLength());
 712         auto computedLength = convertComputedLength&lt;float&gt;(builderState, primitiveValue);
 713         return TextUnderlineOffset::createWithLength(computedLength);
 714     }
 715 }
 716 
 717 inline TextDecorationThickness BuilderConverter::convertTextDecorationThickness(BuilderState&amp; builderState, const CSSValue&amp; value)
 718 {
 719     ASSERT(is&lt;CSSPrimitiveValue&gt;(value));
 720     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 721     switch (primitiveValue.valueID()) {
 722     case CSSValueAuto:
 723         return TextDecorationThickness::createWithAuto();
 724     case CSSValueFromFont:
 725         return TextDecorationThickness::createFromFont();
 726     default:
 727         ASSERT(primitiveValue.isLength());
 728         auto computedLength = convertComputedLength&lt;float&gt;(builderState, primitiveValue);
 729         return TextDecorationThickness::createWithLength(computedLength);
 730     }
 731 }
 732 
 733 inline RefPtr&lt;StyleReflection&gt; BuilderConverter::convertReflection(BuilderState&amp; builderState, const CSSValue&amp; value)
 734 {
 735     if (is&lt;CSSPrimitiveValue&gt;(value)) {
 736         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
 737         return nullptr;
 738     }
 739 
 740     auto&amp; reflectValue = downcast&lt;CSSReflectValue&gt;(value);
 741 
 742     auto reflection = StyleReflection::create();
 743     reflection-&gt;setDirection(reflectValue.direction());
 744     reflection-&gt;setOffset(reflectValue.offset().convertToLength&lt;FixedIntegerConversion | PercentConversion | CalculatedConversion&gt;(builderState.cssToLengthConversionData()));
 745 
 746     NinePieceImage mask(NinePieceImage::Type::Mask);
 747     builderState.styleMap().mapNinePieceImage(CSSPropertyWebkitBoxReflect, reflectValue.mask(), mask);
 748     reflection-&gt;setMask(mask);
 749 
 750     return reflection;
 751 }
 752 
 753 inline IntSize BuilderConverter::convertInitialLetter(BuilderState&amp;, const CSSValue&amp; value)
 754 {
 755     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 756 
 757     if (primitiveValue.valueID() == CSSValueNormal)
 758         return IntSize();
 759 
 760     Pair* pair = primitiveValue.pairValue();
 761     ASSERT(pair);
 762     ASSERT(pair-&gt;first());
 763     ASSERT(pair-&gt;second());
 764 
 765     return IntSize(pair-&gt;first()-&gt;intValue(), pair-&gt;second()-&gt;intValue());
 766 }
 767 
 768 inline float BuilderConverter::convertTextStrokeWidth(BuilderState&amp; builderState, const CSSValue&amp; value)
 769 {
 770     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 771 
 772     float width = 0;
 773     switch (primitiveValue.valueID()) {
 774     case CSSValueThin:
 775     case CSSValueMedium:
 776     case CSSValueThick: {
 777         double result = 1.0 / 48;
 778         if (primitiveValue.valueID() == CSSValueMedium)
 779             result *= 3;
 780         else if (primitiveValue.valueID() == CSSValueThick)
 781             result *= 5;
 782         Ref&lt;CSSPrimitiveValue&gt; emsValue(CSSPrimitiveValue::create(result, CSSUnitType::CSS_EMS));
 783         width = convertComputedLength&lt;float&gt;(builderState, emsValue);
 784         break;
 785     }
 786     case CSSValueInvalid: {
 787         width = convertComputedLength&lt;float&gt;(builderState, primitiveValue);
 788         break;
 789     }
 790     default:
 791         ASSERT_NOT_REACHED();
 792         return 0;
 793     }
 794 
 795     return width;
 796 }
 797 
 798 inline OptionSet&lt;LineBoxContain&gt; BuilderConverter::convertLineBoxContain(BuilderState&amp;, const CSSValue&amp; value)
 799 {
 800     if (is&lt;CSSPrimitiveValue&gt;(value)) {
 801         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
 802         return { };
 803     }
 804 
 805     return downcast&lt;CSSLineBoxContainValue&gt;(value).value();
 806 }
 807 
 808 inline OptionSet&lt;TextDecorationSkip&gt; BuilderConverter::valueToDecorationSkip(const CSSPrimitiveValue&amp; primitiveValue)
 809 {
 810     ASSERT(primitiveValue.isValueID());
 811 
 812     switch (primitiveValue.valueID()) {
 813     case CSSValueAuto:
 814         return TextDecorationSkip::Auto;
 815     case CSSValueNone:
 816         return OptionSet&lt;TextDecorationSkip&gt; { };
 817     case CSSValueInk:
 818         return TextDecorationSkip::Ink;
 819     case CSSValueObjects:
 820         return TextDecorationSkip::Objects;
 821     default:
 822         break;
 823     }
 824 
 825     ASSERT_NOT_REACHED();
 826     return OptionSet&lt;TextDecorationSkip&gt; { };
 827 }
 828 
 829 inline OptionSet&lt;TextDecorationSkip&gt; BuilderConverter::convertTextDecorationSkip(BuilderState&amp;, const CSSValue&amp; value)
 830 {
 831     if (is&lt;CSSPrimitiveValue&gt;(value))
 832         return valueToDecorationSkip(downcast&lt;CSSPrimitiveValue&gt;(value));
 833 
 834     OptionSet&lt;TextDecorationSkip&gt; skip;
 835     for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value))
 836         skip.add(valueToDecorationSkip(downcast&lt;CSSPrimitiveValue&gt;(currentValue.get())));
 837     return skip;
 838 }
 839 
 840 static inline bool isImageShape(const CSSValue&amp; value)
 841 {
 842     return is&lt;CSSImageValue&gt;(value) || is&lt;CSSImageSetValue&gt;(value) || is&lt;CSSImageGeneratorValue&gt;(value);
 843 }
 844 
 845 inline RefPtr&lt;ShapeValue&gt; BuilderConverter::convertShapeValue(BuilderState&amp; builderState, CSSValue&amp; value)
 846 {
 847     if (is&lt;CSSPrimitiveValue&gt;(value)) {
 848         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
 849         return nullptr;
 850     }
 851 
 852     if (isImageShape(value))
 853         return ShapeValue::create(builderState.createStyleImage(value).releaseNonNull());
 854 
 855     RefPtr&lt;BasicShape&gt; shape;
 856     CSSBoxType referenceBox = CSSBoxType::BoxMissing;
 857     for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value)) {
 858         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(currentValue.get());
 859         if (primitiveValue.isShape())
 860             shape = basicShapeForValue(builderState.cssToLengthConversionData(), *primitiveValue.shapeValue());
 861         else if (primitiveValue.valueID() == CSSValueContentBox
 862             || primitiveValue.valueID() == CSSValueBorderBox
 863             || primitiveValue.valueID() == CSSValuePaddingBox
 864             || primitiveValue.valueID() == CSSValueMarginBox)
 865             referenceBox = primitiveValue;
 866         else {
 867             ASSERT_NOT_REACHED();
 868             return nullptr;
 869         }
 870     }
 871 
 872     if (shape)
 873         return ShapeValue::create(shape.releaseNonNull(), referenceBox);
 874 
 875     if (referenceBox != CSSBoxType::BoxMissing)
 876         return ShapeValue::create(referenceBox);
 877 
 878     ASSERT_NOT_REACHED();
 879     return nullptr;
 880 }
 881 
 882 #if ENABLE(CSS_SCROLL_SNAP)
 883 
 884 inline ScrollSnapType BuilderConverter::convertScrollSnapType(BuilderState&amp;, const CSSValue&amp; value)
 885 {
 886     ScrollSnapType type;
 887     auto&amp; values = downcast&lt;CSSValueList&gt;(value);
 888     auto&amp; firstValue = downcast&lt;CSSPrimitiveValue&gt;(*values.item(0));
 889     if (values.length() == 2) {
 890         type.axis = firstValue;
 891         type.strictness = downcast&lt;CSSPrimitiveValue&gt;(*values.item(1));
 892         return type;
 893     }
 894 
 895     switch (firstValue.valueID()) {
 896     case CSSValueNone:
 897     case CSSValueMandatory:
 898     case CSSValueProximity:
 899         type.strictness = firstValue;
 900         break;
 901     default:
 902         type.axis = firstValue;
 903         type.strictness = ScrollSnapStrictness::Proximity;
 904         break;
 905     }
 906     return type;
 907 }
 908 
 909 inline ScrollSnapAlign BuilderConverter::convertScrollSnapAlign(BuilderState&amp;, const CSSValue&amp; value)
 910 {
 911     auto&amp; values = downcast&lt;CSSValueList&gt;(value);
 912     ScrollSnapAlign alignment;
 913     alignment.x = downcast&lt;CSSPrimitiveValue&gt;(*values.item(0));
 914     if (values.length() == 1)
 915         alignment.y = alignment.x;
 916     else
 917         alignment.y = downcast&lt;CSSPrimitiveValue&gt;(*values.item(1));
 918     return alignment;
 919 }
 920 
 921 #endif
 922 
 923 inline GridLength BuilderConverter::createGridTrackBreadth(const CSSPrimitiveValue&amp; primitiveValue, BuilderState&amp; builderState)
 924 {
 925     if (primitiveValue.valueID() == CSSValueMinContent || primitiveValue.valueID() == CSSValueWebkitMinContent)
 926         return Length(MinContent);
 927 
 928     if (primitiveValue.valueID() == CSSValueMaxContent || primitiveValue.valueID() == CSSValueWebkitMaxContent)
 929         return Length(MaxContent);
 930 
 931     // Fractional unit.
 932     if (primitiveValue.isFlex())
 933         return GridLength(primitiveValue.doubleValue());
 934 
 935     return primitiveValue.convertToLength&lt;FixedIntegerConversion | PercentConversion | CalculatedConversion | AutoConversion&gt;(builderState.cssToLengthConversionData());
 936 }
 937 
 938 inline GridTrackSize BuilderConverter::createGridTrackSize(const CSSValue&amp; value, BuilderState&amp; builderState)
 939 {
 940     if (is&lt;CSSPrimitiveValue&gt;(value))
 941         return GridTrackSize(createGridTrackBreadth(downcast&lt;CSSPrimitiveValue&gt;(value), builderState));
 942 
 943     ASSERT(is&lt;CSSFunctionValue&gt;(value));
 944     const auto&amp; function = downcast&lt;CSSFunctionValue&gt;(value);
 945 
 946     if (function.length() == 1)
 947         return GridTrackSize(createGridTrackBreadth(downcast&lt;CSSPrimitiveValue&gt;(*function.itemWithoutBoundsCheck(0)), builderState), FitContentTrackSizing);
 948 
 949     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(function.length() == 2);
 950     GridLength minTrackBreadth(createGridTrackBreadth(downcast&lt;CSSPrimitiveValue&gt;(*function.itemWithoutBoundsCheck(0)), builderState));
 951     GridLength maxTrackBreadth(createGridTrackBreadth(downcast&lt;CSSPrimitiveValue&gt;(*function.itemWithoutBoundsCheck(1)), builderState));
 952     return GridTrackSize(minTrackBreadth, maxTrackBreadth);
 953 }
 954 
 955 static void createGridLineNamesList(const CSSValue&amp; value, unsigned currentNamedGridLine, NamedGridLinesMap&amp; namedGridLines, OrderedNamedGridLinesMap&amp; orderedNamedGridLines)
 956 {
 957     ASSERT(value.isGridLineNamesValue());
 958 
 959     for (auto&amp; namedGridLineValue : downcast&lt;CSSGridLineNamesValue&gt;(value)) {
 960         String namedGridLine = downcast&lt;CSSPrimitiveValue&gt;(namedGridLineValue.get()).stringValue();
 961         auto result = namedGridLines.add(namedGridLine, Vector&lt;unsigned&gt;());
 962         result.iterator-&gt;value.append(currentNamedGridLine);
 963         auto orderedResult = orderedNamedGridLines.add(currentNamedGridLine, Vector&lt;String&gt;());
 964         orderedResult.iterator-&gt;value.append(namedGridLine);
 965     }
 966 }
 967 
 968 struct BuilderConverter::TracksData {
 969     WTF_MAKE_NONCOPYABLE(TracksData); WTF_MAKE_FAST_ALLOCATED;
 970 public:
 971     TracksData() = default;
 972 
 973     Vector&lt;GridTrackSize&gt; m_trackSizes;
 974     NamedGridLinesMap m_namedGridLines;
 975     OrderedNamedGridLinesMap m_orderedNamedGridLines;
 976     Vector&lt;GridTrackSize&gt; m_autoRepeatTrackSizes;
 977     NamedGridLinesMap m_autoRepeatNamedGridLines;
 978     OrderedNamedGridLinesMap m_autoRepeatOrderedNamedGridLines;
 979     unsigned m_autoRepeatInsertionPoint { RenderStyle::initialGridAutoRepeatInsertionPoint() };
 980     AutoRepeatType m_autoRepeatType { RenderStyle::initialGridAutoRepeatType() };
 981 };
 982 
 983 inline bool BuilderConverter::createGridTrackList(const CSSValue&amp; value, TracksData&amp; tracksData, BuilderState&amp; builderState)
 984 {
 985     // Handle &#39;none&#39;.
 986     if (is&lt;CSSPrimitiveValue&gt;(value))
 987         return downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone;
 988 
 989     if (!is&lt;CSSValueList&gt;(value))
 990         return false;
 991 
 992     unsigned currentNamedGridLine = 0;
 993     auto handleLineNameOrTrackSize = [&amp;](const CSSValue&amp; currentValue) {
 994         if (is&lt;CSSGridLineNamesValue&gt;(currentValue))
 995             createGridLineNamesList(currentValue, currentNamedGridLine, tracksData.m_namedGridLines, tracksData.m_orderedNamedGridLines);
 996         else {
 997             ++currentNamedGridLine;
 998             tracksData.m_trackSizes.append(createGridTrackSize(currentValue, builderState));
 999         }
1000     };
1001 
1002     for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value)) {
1003         if (is&lt;CSSGridAutoRepeatValue&gt;(currentValue)) {
1004             ASSERT(tracksData.m_autoRepeatTrackSizes.isEmpty());
1005             unsigned autoRepeatIndex = 0;
1006             CSSValueID autoRepeatID = downcast&lt;CSSGridAutoRepeatValue&gt;(currentValue.get()).autoRepeatID();
1007             ASSERT(autoRepeatID == CSSValueAutoFill || autoRepeatID == CSSValueAutoFit);
1008             tracksData.m_autoRepeatType = autoRepeatID == CSSValueAutoFill ? AutoRepeatType::Fill : AutoRepeatType::Fit;
1009             for (auto&amp; autoRepeatValue : downcast&lt;CSSValueList&gt;(currentValue.get())) {
1010                 if (is&lt;CSSGridLineNamesValue&gt;(autoRepeatValue)) {
1011                     createGridLineNamesList(autoRepeatValue.get(), autoRepeatIndex, tracksData.m_autoRepeatNamedGridLines, tracksData.m_autoRepeatOrderedNamedGridLines);
1012                     continue;
1013                 }
1014                 ++autoRepeatIndex;
1015                 tracksData.m_autoRepeatTrackSizes.append(createGridTrackSize(autoRepeatValue.get(), builderState));
1016             }
1017             tracksData.m_autoRepeatInsertionPoint = currentNamedGridLine++;
1018             continue;
1019         }
1020 
1021         if (is&lt;CSSGridIntegerRepeatValue&gt;(currentValue)) {
1022             size_t repetitions = downcast&lt;CSSGridIntegerRepeatValue&gt;(currentValue.get()).repetitions();
1023             for (size_t i = 0; i &lt; repetitions; ++i) {
1024                 for (auto&amp; integerRepeatValue : downcast&lt;CSSValueList&gt;(currentValue.get()))
1025                     handleLineNameOrTrackSize(integerRepeatValue);
1026             }
1027             continue;
1028         }
1029 
1030         handleLineNameOrTrackSize(currentValue);
1031     }
1032 
1033     // The parser should have rejected any &lt;track-list&gt; without any &lt;track-size&gt; as
1034     // this is not conformant to the syntax.
1035     ASSERT(!tracksData.m_trackSizes.isEmpty() || !tracksData.m_autoRepeatTrackSizes.isEmpty());
1036     return true;
1037 }
1038 
1039 inline bool BuilderConverter::createGridPosition(const CSSValue&amp; value, GridPosition&amp; position)
1040 {
1041     // We accept the specification&#39;s grammar:
1042     // auto | &lt;custom-ident&gt; | [ &lt;integer&gt; &amp;&amp; &lt;custom-ident&gt;? ] | [ span &amp;&amp; [ &lt;integer&gt; || &lt;custom-ident&gt; ] ]
1043     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1044         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1045         // We translate &lt;ident&gt; to &lt;string&gt; during parsing as it makes handling it simpler.
1046         if (primitiveValue.isString()) {
1047             position.setNamedGridArea(primitiveValue.stringValue());
1048             return true;
1049         }
1050 
1051         ASSERT(primitiveValue.valueID() == CSSValueAuto);
1052         return true;
1053     }
1054 
1055     auto&amp; values = downcast&lt;CSSValueList&gt;(value);
1056     ASSERT(values.length());
1057 
1058     auto it = values.begin();
1059     const CSSPrimitiveValue* currentValue = &amp;downcast&lt;CSSPrimitiveValue&gt;(it-&gt;get());
1060     bool isSpanPosition = false;
1061     if (currentValue-&gt;valueID() == CSSValueSpan) {
1062         isSpanPosition = true;
1063         ++it;
1064         currentValue = it != values.end() ? &amp;downcast&lt;CSSPrimitiveValue&gt;(it-&gt;get()) : nullptr;
1065     }
1066 
1067     int gridLineNumber = 0;
1068     if (currentValue &amp;&amp; currentValue-&gt;isNumber()) {
1069         gridLineNumber = currentValue-&gt;intValue();
1070         ++it;
1071         currentValue = it != values.end() ? &amp;downcast&lt;CSSPrimitiveValue&gt;(it-&gt;get()) : nullptr;
1072     }
1073 
1074     String gridLineName;
1075     if (currentValue &amp;&amp; currentValue-&gt;isString()) {
1076         gridLineName = currentValue-&gt;stringValue();
1077         ++it;
1078     }
1079 
1080     ASSERT(it == values.end());
1081     if (isSpanPosition)
1082         position.setSpanPosition(gridLineNumber ? gridLineNumber : 1, gridLineName);
1083     else
1084         position.setExplicitPosition(gridLineNumber, gridLineName);
1085 
1086     return true;
1087 }
1088 
1089 inline void BuilderConverter::createImplicitNamedGridLinesFromGridArea(const NamedGridAreaMap&amp; namedGridAreas, NamedGridLinesMap&amp; namedGridLines, GridTrackSizingDirection direction)
1090 {
1091     for (auto&amp; area : namedGridAreas) {
1092         GridSpan areaSpan = direction == ForRows ? area.value.rows : area.value.columns;
1093         {
1094             auto&amp; startVector = namedGridLines.add(area.key + &quot;-start&quot;, Vector&lt;unsigned&gt;()).iterator-&gt;value;
1095             startVector.append(areaSpan.startLine());
1096             std::sort(startVector.begin(), startVector.end());
1097         }
1098         {
1099             auto&amp; endVector = namedGridLines.add(area.key + &quot;-end&quot;, Vector&lt;unsigned&gt;()).iterator-&gt;value;
1100             endVector.append(areaSpan.endLine());
1101             std::sort(endVector.begin(), endVector.end());
1102         }
1103     }
1104 }
1105 
1106 inline Vector&lt;GridTrackSize&gt; BuilderConverter::convertGridTrackSizeList(BuilderState&amp; builderState, const CSSValue&amp; value)
1107 {
1108     ASSERT(value.isValueList());
1109     auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
1110     Vector&lt;GridTrackSize&gt; trackSizes;
1111     trackSizes.reserveInitialCapacity(valueList.length());
1112     for (auto&amp; currValue : valueList) {
1113         ASSERT(!currValue-&gt;isGridLineNamesValue());
1114         ASSERT(!currValue-&gt;isGridAutoRepeatValue());
1115         ASSERT(!currValue-&gt;isGridIntegerRepeatValue());
1116         trackSizes.uncheckedAppend(convertGridTrackSize(builderState, currValue));
1117     }
1118     return trackSizes;
1119 }
1120 
1121 inline GridTrackSize BuilderConverter::convertGridTrackSize(BuilderState&amp; builderState, const CSSValue&amp; value)
1122 {
1123     return createGridTrackSize(value, builderState);
1124 }
1125 
1126 inline Optional&lt;GridPosition&gt; BuilderConverter::convertGridPosition(BuilderState&amp;, const CSSValue&amp; value)
1127 {
1128     GridPosition gridPosition;
1129     if (createGridPosition(value, gridPosition))
1130         return gridPosition;
1131     return WTF::nullopt;
1132 }
1133 
1134 inline GridAutoFlow BuilderConverter::convertGridAutoFlow(BuilderState&amp;, const CSSValue&amp; value)
1135 {
1136     auto&amp; list = downcast&lt;CSSValueList&gt;(value);
1137     if (!list.length())
1138         return RenderStyle::initialGridAutoFlow();
1139 
1140     auto&amp; first = downcast&lt;CSSPrimitiveValue&gt;(*list.item(0));
1141     auto* second = downcast&lt;CSSPrimitiveValue&gt;(list.item(1));
1142 
1143     GridAutoFlow autoFlow;
1144     switch (first.valueID()) {
1145     case CSSValueRow:
1146         if (second &amp;&amp; second-&gt;valueID() == CSSValueDense)
1147             autoFlow = AutoFlowRowDense;
1148         else
1149             autoFlow = AutoFlowRow;
1150         break;
1151     case CSSValueColumn:
1152         if (second &amp;&amp; second-&gt;valueID() == CSSValueDense)
1153             autoFlow = AutoFlowColumnDense;
1154         else
1155             autoFlow = AutoFlowColumn;
1156         break;
1157     case CSSValueDense:
1158         if (second &amp;&amp; second-&gt;valueID() == CSSValueColumn)
1159             autoFlow = AutoFlowColumnDense;
1160         else
1161             autoFlow = AutoFlowRowDense;
1162         break;
1163     default:
1164         ASSERT_NOT_REACHED();
1165         autoFlow = RenderStyle::initialGridAutoFlow();
1166         break;
1167     }
1168 
1169     return autoFlow;
1170 }
1171 
1172 inline CSSToLengthConversionData BuilderConverter::csstoLengthConversionDataWithTextZoomFactor(BuilderState&amp; builderState)
1173 {
1174     if (auto* frame = builderState.document().frame()) {
1175         float textZoomFactor = builderState.style().textZoom() != TextZoom::Reset ? frame-&gt;textZoomFactor() : 1.0f;
1176         return builderState.cssToLengthConversionData().copyWithAdjustedZoom(builderState.style().effectiveZoom() * textZoomFactor);
1177     }
1178     return builderState.cssToLengthConversionData();
1179 }
1180 
1181 inline Optional&lt;Length&gt; BuilderConverter::convertWordSpacing(BuilderState&amp; builderState, const CSSValue&amp; value)
1182 {
1183     Optional&lt;Length&gt; wordSpacing;
1184     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1185     if (primitiveValue.valueID() == CSSValueNormal)
1186         wordSpacing = RenderStyle::initialWordSpacing();
1187     else if (primitiveValue.isLength())
1188         wordSpacing = primitiveValue.computeLength&lt;Length&gt;(csstoLengthConversionDataWithTextZoomFactor(builderState));
1189     else if (primitiveValue.isPercentage())
1190         wordSpacing = Length(clampTo&lt;float&gt;(primitiveValue.doubleValue(), minValueForCssLength, maxValueForCssLength), Percent);
1191     else if (primitiveValue.isNumber())
1192         wordSpacing = Length(primitiveValue.doubleValue(), Fixed);
1193 
1194     return wordSpacing;
1195 }
1196 
1197 inline Optional&lt;float&gt; BuilderConverter::convertPerspective(BuilderState&amp; builderState, const CSSValue&amp; value)
1198 {
1199     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1200     if (primitiveValue.valueID() == CSSValueNone)
1201         return 0.f;
1202 
1203     float perspective = -1;
1204     if (primitiveValue.isLength())
1205         perspective = primitiveValue.computeLength&lt;float&gt;(builderState.cssToLengthConversionData());
1206     else if (primitiveValue.isNumber())
1207         perspective = primitiveValue.doubleValue() * builderState.cssToLengthConversionData().zoom();
1208     else
1209         ASSERT_NOT_REACHED();
1210 
1211     return perspective &lt; 0 ? Optional&lt;float&gt;(WTF::nullopt) : Optional&lt;float&gt;(perspective);
1212 }
1213 
1214 inline Optional&lt;Length&gt; BuilderConverter::convertMarqueeIncrement(BuilderState&amp; builderState, const CSSValue&amp; value)
1215 {
1216     Length length = downcast&lt;CSSPrimitiveValue&gt;(value).convertToLength&lt;FixedIntegerConversion | PercentConversion | CalculatedConversion&gt;(builderState.cssToLengthConversionData().copyWithAdjustedZoom(1.0f));
1217     if (length.isUndefined())
1218         return WTF::nullopt;
1219     return length;
1220 }
1221 
1222 inline Optional&lt;FilterOperations&gt; BuilderConverter::convertFilterOperations(BuilderState&amp; builderState, const CSSValue&amp; value)
1223 {
1224     FilterOperations operations;
1225     if (builderState.createFilterOperations(value, operations))
1226         return operations;
1227     return WTF::nullopt;
1228 }
1229 
1230 inline FontFeatureSettings BuilderConverter::convertFontFeatureSettings(BuilderState&amp;, const CSSValue&amp; value)
1231 {
1232     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1233         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNormal);
1234         return { };
1235     }
1236 
1237     FontFeatureSettings settings;
1238     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
1239         auto&amp; feature = downcast&lt;CSSFontFeatureValue&gt;(item.get());
1240         settings.insert(FontFeature(feature.tag(), feature.value()));
1241     }
1242     return settings;
1243 }
1244 
1245 inline FontSelectionValue BuilderConverter::convertFontWeightFromValue(const CSSValue&amp; value)
1246 {
1247     ASSERT(is&lt;CSSPrimitiveValue&gt;(value));
1248     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1249 
1250     if (primitiveValue.isNumber())
1251         return FontSelectionValue::clampFloat(primitiveValue.floatValue());
1252 
1253     ASSERT(primitiveValue.isValueID());
1254     switch (primitiveValue.valueID()) {
1255     case CSSValueNormal:
1256         return normalWeightValue();
1257     case CSSValueBold:
1258     case CSSValueBolder:
1259         return boldWeightValue();
1260     case CSSValueLighter:
1261         return lightWeightValue();
1262     default:
1263         ASSERT_NOT_REACHED();
1264         return normalWeightValue();
1265     }
1266 }
1267 
1268 inline FontSelectionValue BuilderConverter::convertFontStretchFromValue(const CSSValue&amp; value)
1269 {
1270     ASSERT(is&lt;CSSPrimitiveValue&gt;(value));
1271     const auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1272 
1273     if (primitiveValue.isPercentage())
1274         return FontSelectionValue::clampFloat(primitiveValue.floatValue());
1275 
1276     ASSERT(primitiveValue.isValueID());
1277     if (auto value = fontStretchValue(primitiveValue.valueID()))
1278         return value.value();
1279     ASSERT_NOT_REACHED();
1280     return normalStretchValue();
1281 }
1282 
1283 // The input value needs to parsed and valid, this function returns WTF::nullopt if the input was &quot;normal&quot;.
1284 inline Optional&lt;FontSelectionValue&gt; BuilderConverter::convertFontStyleFromValue(const CSSValue&amp; value)
1285 {
1286     ASSERT(is&lt;CSSFontStyleValue&gt;(value));
1287     const auto&amp; fontStyleValue = downcast&lt;CSSFontStyleValue&gt;(value);
1288 
1289     auto valueID = fontStyleValue.fontStyleValue-&gt;valueID();
1290     if (valueID == CSSValueNormal)
1291         return WTF::nullopt;
1292     if (valueID == CSSValueItalic)
1293         return italicValue();
1294     ASSERT(valueID == CSSValueOblique);
1295     if (auto* obliqueValue = fontStyleValue.obliqueValue.get())
1296         return FontSelectionValue(obliqueValue-&gt;value&lt;float&gt;(CSSUnitType::CSS_DEG));
1297     return italicValue();
1298 }
1299 
1300 inline FontSelectionValue BuilderConverter::convertFontWeight(BuilderState&amp; builderState, const CSSValue&amp; value)
1301 {
1302     ASSERT(is&lt;CSSPrimitiveValue&gt;(value));
1303     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1304     if (primitiveValue.isValueID()) {
1305         auto valueID = primitiveValue.valueID();
1306         if (valueID == CSSValueBolder)
1307             return FontCascadeDescription::bolderWeight(builderState.parentStyle().fontDescription().weight());
1308         if (valueID == CSSValueLighter)
1309             return FontCascadeDescription::lighterWeight(builderState.parentStyle().fontDescription().weight());
1310     }
1311     return convertFontWeightFromValue(value);
1312 }
1313 
1314 inline FontSelectionValue BuilderConverter::convertFontStretch(BuilderState&amp;, const CSSValue&amp; value)
1315 {
1316     return convertFontStretchFromValue(value);
1317 }
1318 
1319 #if ENABLE(VARIATION_FONTS)
1320 inline FontVariationSettings BuilderConverter::convertFontVariationSettings(BuilderState&amp;, const CSSValue&amp; value)
1321 {
1322     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1323         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNormal);
1324         return { };
1325     }
1326 
1327     FontVariationSettings settings;
1328     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
1329         auto&amp; feature = downcast&lt;CSSFontVariationValue&gt;(item.get());
1330         settings.insert({ feature.tag(), feature.value() });
1331     }
1332     return settings;
1333 }
1334 #endif
1335 
1336 #if PLATFORM(IOS_FAMILY)
1337 inline bool BuilderConverter::convertTouchCallout(BuilderState&amp;, const CSSValue&amp; value)
1338 {
1339     return !equalLettersIgnoringASCIICase(downcast&lt;CSSPrimitiveValue&gt;(value).stringValue(), &quot;none&quot;);
1340 }
1341 #endif
1342 
1343 #if ENABLE(TOUCH_EVENTS)
1344 inline Color BuilderConverter::convertTapHighlightColor(BuilderState&amp; builderState, const CSSValue&amp; value)
1345 {
1346     return builderState.colorFromPrimitiveValue(downcast&lt;CSSPrimitiveValue&gt;(value));
1347 }
1348 #endif
1349 
1350 #if ENABLE(POINTER_EVENTS)
1351 inline OptionSet&lt;TouchAction&gt; BuilderConverter::convertTouchAction(BuilderState&amp;, const CSSValue&amp; value)
1352 {
1353     if (is&lt;CSSPrimitiveValue&gt;(value))
1354         return downcast&lt;CSSPrimitiveValue&gt;(value);
1355 
1356     if (is&lt;CSSValueList&gt;(value)) {
1357         OptionSet&lt;TouchAction&gt; touchActions;
1358         for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value)) {
1359             auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(currentValue.get());
1360             auto primitiveValueID = primitiveValue.valueID();
1361             if (primitiveValueID != CSSValuePanX &amp;&amp; primitiveValueID != CSSValuePanY &amp;&amp; primitiveValueID != CSSValuePinchZoom)
1362                 return RenderStyle::initialTouchActions();
1363             touchActions.add(primitiveValue);
1364         }
1365         return touchActions;
1366     }
1367 
1368     return RenderStyle::initialTouchActions();
1369 }
1370 #endif
1371 
1372 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
1373 inline bool BuilderConverter::convertOverflowScrolling(BuilderState&amp;, const CSSValue&amp; value)
1374 {
1375     return downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueTouch;
1376 }
1377 #endif
1378 
1379 inline bool BuilderConverter::convertSmoothScrolling(BuilderState&amp;, const CSSValue&amp; value)
1380 {
1381     return downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueSmooth;
1382 }
1383 
1384 inline SVGLengthValue BuilderConverter::convertSVGLengthValue(BuilderState&amp;, const CSSValue&amp; value)
1385 {
1386     return SVGLengthValue::fromCSSPrimitiveValue(downcast&lt;CSSPrimitiveValue&gt;(value));
1387 }
1388 
1389 inline Vector&lt;SVGLengthValue&gt; BuilderConverter::convertSVGLengthVector(BuilderState&amp; builderState, const CSSValue&amp; value)
1390 {
1391     auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
1392 
1393     Vector&lt;SVGLengthValue&gt; svgLengths;
1394     svgLengths.reserveInitialCapacity(valueList.length());
1395     for (auto&amp; item : valueList)
1396         svgLengths.uncheckedAppend(convertSVGLengthValue(builderState, item));
1397 
1398     return svgLengths;
1399 }
1400 
1401 inline Vector&lt;SVGLengthValue&gt; BuilderConverter::convertStrokeDashArray(BuilderState&amp; builderState, const CSSValue&amp; value)
1402 {
1403     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1404         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
1405         return SVGRenderStyle::initialStrokeDashArray();
1406     }
1407 
1408     return convertSVGLengthVector(builderState, value);
1409 }
1410 
1411 inline PaintOrder BuilderConverter::convertPaintOrder(BuilderState&amp;, const CSSValue&amp; value)
1412 {
1413     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1414         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNormal);
1415         return PaintOrder::Normal;
1416     }
1417 
1418     auto&amp; orderTypeList = downcast&lt;CSSValueList&gt;(value);
1419     switch (downcast&lt;CSSPrimitiveValue&gt;(*orderTypeList.itemWithoutBoundsCheck(0)).valueID()) {
1420     case CSSValueFill:
1421         return orderTypeList.length() &gt; 1 ? PaintOrder::FillMarkers : PaintOrder::Fill;
1422     case CSSValueStroke:
1423         return orderTypeList.length() &gt; 1 ? PaintOrder::StrokeMarkers : PaintOrder::Stroke;
1424     case CSSValueMarkers:
1425         return orderTypeList.length() &gt; 1 ? PaintOrder::MarkersStroke : PaintOrder::Markers;
1426     default:
1427         ASSERT_NOT_REACHED();
1428         return PaintOrder::Normal;
1429     }
1430 }
1431 
1432 inline float BuilderConverter::convertOpacity(BuilderState&amp;, const CSSValue&amp; value)
1433 {
1434     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1435     float opacity = primitiveValue.floatValue();
1436     if (primitiveValue.isPercentage())
1437         opacity /= 100.0f;
1438     return std::max(0.0f, std::min(1.0f, opacity));
1439 }
1440 
1441 inline String BuilderConverter::convertSVGURIReference(BuilderState&amp; builderState, const CSSValue&amp; value)
1442 {
1443     String s;
1444     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1445     if (primitiveValue.isURI())
1446         s = primitiveValue.stringValue();
1447 
1448     return SVGURIReference::fragmentIdentifierFromIRIString(s, builderState.document());
1449 }
1450 
1451 inline Color BuilderConverter::convertSVGColor(BuilderState&amp; builderState, const CSSValue&amp; value)
1452 {
1453     return builderState.colorFromPrimitiveValue(downcast&lt;CSSPrimitiveValue&gt;(value));
1454 }
1455 
1456 inline StyleSelfAlignmentData BuilderConverter::convertSelfOrDefaultAlignmentData(BuilderState&amp;, const CSSValue&amp; value)
1457 {
1458     StyleSelfAlignmentData alignmentData = RenderStyle::initialSelfAlignment();
1459     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1460     if (Pair* pairValue = primitiveValue.pairValue()) {
1461         if (pairValue-&gt;first()-&gt;valueID() == CSSValueLegacy) {
1462             alignmentData.setPositionType(ItemPositionType::Legacy);
1463             alignmentData.setPosition(*pairValue-&gt;second());
1464         } else if (pairValue-&gt;first()-&gt;valueID() == CSSValueFirst)
1465             alignmentData.setPosition(ItemPosition::Baseline);
1466         else if (pairValue-&gt;first()-&gt;valueID() == CSSValueLast)
1467             alignmentData.setPosition(ItemPosition::LastBaseline);
1468         else {
1469             alignmentData.setOverflow(*pairValue-&gt;first());
1470             alignmentData.setPosition(*pairValue-&gt;second());
1471         }
1472     } else
1473         alignmentData.setPosition(primitiveValue);
1474     return alignmentData;
1475 }
1476 
1477 inline StyleContentAlignmentData BuilderConverter::convertContentAlignmentData(BuilderState&amp;, const CSSValue&amp; value)
1478 {
1479     StyleContentAlignmentData alignmentData = RenderStyle::initialContentAlignment();
1480     if (!is&lt;CSSContentDistributionValue&gt;(value))
1481         return alignmentData;
1482     auto&amp; contentValue = downcast&lt;CSSContentDistributionValue&gt;(value);
1483     if (contentValue.distribution()-&gt;valueID() != CSSValueInvalid)
1484         alignmentData.setDistribution(contentValue.distribution().get());
1485     if (contentValue.position()-&gt;valueID() != CSSValueInvalid)
1486         alignmentData.setPosition(contentValue.position().get());
1487     if (contentValue.overflow()-&gt;valueID() != CSSValueInvalid)
1488         alignmentData.setOverflow(contentValue.overflow().get());
1489     return alignmentData;
1490 }
1491 
1492 inline GlyphOrientation BuilderConverter::convertGlyphOrientation(BuilderState&amp;, const CSSValue&amp; value)
1493 {
1494     float angle = fabsf(fmodf(downcast&lt;CSSPrimitiveValue&gt;(value).floatValue(), 360.0f));
1495     if (angle &lt;= 45.0f || angle &gt; 315.0f)
1496         return GlyphOrientation::Degrees0;
1497     if (angle &gt; 45.0f &amp;&amp; angle &lt;= 135.0f)
1498         return GlyphOrientation::Degrees90;
1499     if (angle &gt; 135.0f &amp;&amp; angle &lt;= 225.0f)
1500         return GlyphOrientation::Degrees180;
1501     return GlyphOrientation::Degrees270;
1502 }
1503 
1504 inline GlyphOrientation BuilderConverter::convertGlyphOrientationOrAuto(BuilderState&amp; builderState, const CSSValue&amp; value)
1505 {
1506     if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueAuto)
1507         return GlyphOrientation::Auto;
1508     return convertGlyphOrientation(builderState, value);
1509 }
1510 
1511 inline Optional&lt;Length&gt; BuilderConverter::convertLineHeight(BuilderState&amp; builderState, const CSSValue&amp; value, float multiplier)
1512 {
1513     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1514     if (primitiveValue.valueID() == CSSValueNormal)
1515         return RenderStyle::initialLineHeight();
1516 
1517     if (primitiveValue.isLength()) {
1518         Length length = primitiveValue.computeLength&lt;Length&gt;(BuilderConverter::csstoLengthConversionDataWithTextZoomFactor(builderState));
1519         if (multiplier != 1.f)
1520             length = Length(length.value() * multiplier, Fixed);
1521         return length;
1522     }
1523 
1524     // Line-height percentages need to inherit as if they were Fixed pixel values. In the example:
1525     // &lt;div style=&quot;font-size: 10px; line-height: 150%;&quot;&gt;&lt;div style=&quot;font-size: 100px;&quot;&gt;&lt;/div&gt;&lt;/div&gt;
1526     // the inner element should have line-height of 15px. However, in this example:
1527     // &lt;div style=&quot;font-size: 10px; line-height: 1.5;&quot;&gt;&lt;div style=&quot;font-size: 100px;&quot;&gt;&lt;/div&gt;&lt;/div&gt;
1528     // the inner element should have a line-height of 150px. Therefore, we map percentages to Fixed
1529     // values and raw numbers to percentages.
1530     if (primitiveValue.isPercentage()) {
1531         // FIXME: percentage should not be restricted to an integer here.
1532         return Length((builderState.style().computedFontSize() * primitiveValue.intValue()) / 100, Fixed);
1533     }
1534     if (primitiveValue.isNumber())
1535         return Length(primitiveValue.doubleValue() * 100.0, Percent);
1536 
1537     // FIXME: The parser should only emit the above types, so this should never be reached. We should change the
1538     // type of this function to return just a Length (and not an Optional).
1539     return WTF::nullopt;
1540 }
1541 
1542 inline FontSynthesis BuilderConverter::convertFontSynthesis(BuilderState&amp;, const CSSValue&amp; value)
1543 {
1544     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1545         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
1546         return FontSynthesisNone;
1547     }
1548 
1549     FontSynthesis result = FontSynthesisNone;
1550     ASSERT(is&lt;CSSValueList&gt;(value));
1551     for (const CSSValue&amp; v : downcast&lt;CSSValueList&gt;(value)) {
1552         switch (downcast&lt;CSSPrimitiveValue&gt;(v).valueID()) {
1553         case CSSValueWeight:
1554             result |= FontSynthesisWeight;
1555             break;
1556         case CSSValueStyle:
1557             result |= FontSynthesisStyle;
1558             break;
1559         case CSSValueSmallCaps:
1560             result |= FontSynthesisSmallCaps;
1561             break;
1562         default:
1563             ASSERT_NOT_REACHED();
1564             break;
1565         }
1566     }
1567 
1568     return result;
1569 }
1570 
1571 inline OptionSet&lt;SpeakAs&gt; BuilderConverter::convertSpeakAs(BuilderState&amp;, const CSSValue&amp; value)
1572 {
1573     auto result = RenderStyle::initialSpeakAs();
1574     if (is&lt;CSSValueList&gt;(value)) {
1575         for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value))
1576             result.add(downcast&lt;CSSPrimitiveValue&gt;(currentValue.get()));
1577     }
1578     return result;
1579 }
1580 
1581 inline OptionSet&lt;HangingPunctuation&gt; BuilderConverter::convertHangingPunctuation(BuilderState&amp;, const CSSValue&amp; value)
1582 {
1583     auto result = RenderStyle::initialHangingPunctuation();
1584     if (is&lt;CSSValueList&gt;(value)) {
1585         for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value))
1586             result.add(downcast&lt;CSSPrimitiveValue&gt;(currentValue.get()));
1587     }
1588     return result;
1589 }
1590 
1591 inline GapLength BuilderConverter::convertGapLength(BuilderState&amp; builderState, const CSSValue&amp; value)
1592 {
1593     return (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNormal) ? GapLength() : GapLength(convertLength(builderState, value));
1594 }
1595 
1596 }
1597 }
    </pre>
  </body>
</html>
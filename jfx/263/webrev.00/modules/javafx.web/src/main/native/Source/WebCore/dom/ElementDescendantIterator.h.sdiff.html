<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/ElementDescendantIterator.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ElementData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ElementIterator.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/ElementDescendantIterator.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 35 class ElementDescendantIterator {
 36 public:
 37     ElementDescendantIterator();
 38     explicit ElementDescendantIterator(Element* current);
 39 
 40     ElementDescendantIterator&amp; operator++();
 41     ElementDescendantIterator&amp; operator--();
 42 
 43     Element&amp; operator*();
 44     Element* operator-&gt;();
 45 
 46     bool operator==(const ElementDescendantIterator&amp; other) const;
 47     bool operator!=(const ElementDescendantIterator&amp; other) const;
 48 
 49     void dropAssertions();
 50 
 51 private:
 52     Element* m_current;
 53     Vector&lt;Element*, 16&gt; m_ancestorSiblingStack;
 54 
<span class="line-modified"> 55 #if !ASSERT_DISABLED</span>
 56     ElementIteratorAssertions m_assertions;
 57 #endif
 58 };
 59 
 60 class ElementDescendantConstIterator {
 61 public:
 62     ElementDescendantConstIterator();
 63     explicit ElementDescendantConstIterator(const Element*);
 64 
 65     ElementDescendantConstIterator&amp; operator++();
 66 
 67     const Element&amp; operator*() const;
 68     const Element* operator-&gt;() const;
 69 
 70     bool operator==(const ElementDescendantConstIterator&amp; other) const;
 71     bool operator!=(const ElementDescendantConstIterator&amp; other) const;
 72 
 73     void dropAssertions();
 74 
 75 private:
 76     const Element* m_current;
 77     Vector&lt;Element*, 16&gt; m_ancestorSiblingStack;
 78 
<span class="line-modified"> 79 #if !ASSERT_DISABLED</span>
 80     ElementIteratorAssertions m_assertions;
 81 #endif
 82 };
 83 
 84 class ElementDescendantIteratorAdapter {
 85 public:
 86     ElementDescendantIteratorAdapter(ContainerNode&amp; root);
 87     ElementDescendantIterator begin();
 88     ElementDescendantIterator end();
 89     ElementDescendantIterator last();
 90 
 91 private:
 92     ContainerNode&amp; m_root;
 93 };
 94 
 95 class ElementDescendantConstIteratorAdapter {
 96 public:
 97     ElementDescendantConstIteratorAdapter(const ContainerNode&amp; root);
 98     ElementDescendantConstIterator begin() const;
 99     ElementDescendantConstIterator end() const;
100     ElementDescendantConstIterator last() const;
101 
102 private:
103     const ContainerNode&amp; m_root;
104 };
105 
106 ElementDescendantIteratorAdapter elementDescendants(ContainerNode&amp;);
107 ElementDescendantConstIteratorAdapter elementDescendants(const ContainerNode&amp;);
108 
109 // ElementDescendantIterator
110 
111 inline ElementDescendantIterator::ElementDescendantIterator()
112     : m_current(nullptr)
113 {
114 }
115 
116 inline ElementDescendantIterator::ElementDescendantIterator(Element* current)
117     : m_current(current)
<span class="line-modified">118 #if !ASSERT_DISABLED</span>
119     , m_assertions(current)
120 #endif
121 {
122     m_ancestorSiblingStack.uncheckedAppend(nullptr);
123 }
124 
125 inline void ElementDescendantIterator::dropAssertions()
126 {
<span class="line-modified">127 #if !ASSERT_DISABLED</span>
128     m_assertions.clear();
129 #endif
130 }
131 
132 ALWAYS_INLINE ElementDescendantIterator&amp; ElementDescendantIterator::operator++()
133 {
134     ASSERT(m_current);
135     ASSERT(!m_assertions.domTreeHasMutated());
136 
137     Element* firstChild = ElementTraversal::firstChild(*m_current);
138     Element* nextSibling = ElementTraversal::nextSibling(*m_current);
139 
140     if (firstChild) {
141         if (nextSibling)
142             m_ancestorSiblingStack.append(nextSibling);
143         m_current = firstChild;
144         return *this;
145     }
146 
147     if (nextSibling) {
148         m_current = nextSibling;
149         return *this;
150     }
151 
152     m_current = m_ancestorSiblingStack.takeLast();
153 
<span class="line-modified">154 #if !ASSERT_DISABLED</span>
155     // Drop the assertion when the iterator reaches the end.
156     if (!m_current)
157         m_assertions.dropEventDispatchAssertion();
158 #endif
159 
160     return *this;
161 }
162 
163 ALWAYS_INLINE ElementDescendantIterator&amp; ElementDescendantIterator::operator--()
164 {
165     ASSERT(m_current);
166     ASSERT(!m_assertions.domTreeHasMutated());
167 
168     Element* previousSibling = ElementTraversal::previousSibling(*m_current);
169 
170     if (!previousSibling) {
171         m_current = m_current-&gt;parentElement();
172         // The stack optimizes for forward traversal only, this just maintains consistency.
173         if (m_current-&gt;nextSibling() &amp;&amp; m_current-&gt;nextSibling() == m_ancestorSiblingStack.last())
174             m_ancestorSiblingStack.removeLast();
175         return *this;
176     }
177 
178     Element* deepestSibling = previousSibling;
179     while (Element* lastChild = ElementTraversal::lastChild(*deepestSibling))
180         deepestSibling = lastChild;
181     ASSERT(deepestSibling);
182 
183     if (deepestSibling != previousSibling)
184         m_ancestorSiblingStack.append(m_current);
185 
186     m_current = deepestSibling;
187 
<span class="line-modified">188 #if !ASSERT_DISABLED</span>
189     // Drop the assertion when the iterator reaches the end.
190     if (!m_current)
191         m_assertions.dropEventDispatchAssertion();
192 #endif
193 
194     return *this;
195 }
196 
197 inline Element&amp; ElementDescendantIterator::operator*()
198 {
199     ASSERT(m_current);
200     ASSERT(!m_assertions.domTreeHasMutated());
201     return *m_current;
202 }
203 
204 inline Element* ElementDescendantIterator::operator-&gt;()
205 {
206     ASSERT(m_current);
207     ASSERT(!m_assertions.domTreeHasMutated());
208     return m_current;
</pre>
<hr />
<pre>
211 inline bool ElementDescendantIterator::operator==(const ElementDescendantIterator&amp; other) const
212 {
213     ASSERT(!m_assertions.domTreeHasMutated());
214     return m_current == other.m_current;
215 }
216 
217 inline bool ElementDescendantIterator::operator!=(const ElementDescendantIterator&amp; other) const
218 {
219     return !(*this == other);
220 }
221 
222 // ElementDescendantConstIterator
223 
224 inline ElementDescendantConstIterator::ElementDescendantConstIterator()
225     : m_current(nullptr)
226 {
227 }
228 
229 inline ElementDescendantConstIterator::ElementDescendantConstIterator(const Element* current)
230     : m_current(current)
<span class="line-modified">231 #if !ASSERT_DISABLED</span>
232     , m_assertions(current)
233 #endif
234 {
235     m_ancestorSiblingStack.uncheckedAppend(nullptr);
236 }
237 
238 inline void ElementDescendantConstIterator::dropAssertions()
239 {
<span class="line-modified">240 #if !ASSERT_DISABLED</span>
241     m_assertions.clear();
242 #endif
243 }
244 
245 ALWAYS_INLINE ElementDescendantConstIterator&amp; ElementDescendantConstIterator::operator++()
246 {
247     ASSERT(m_current);
248     ASSERT(!m_assertions.domTreeHasMutated());
249 
250     Element* firstChild = ElementTraversal::firstChild(*m_current);
251     Element* nextSibling = ElementTraversal::nextSibling(*m_current);
252 
253     if (firstChild) {
254         if (nextSibling)
255             m_ancestorSiblingStack.append(nextSibling);
256         m_current = firstChild;
257         return *this;
258     }
259 
260     if (nextSibling) {
261         m_current = nextSibling;
262         return *this;
263     }
264 
265     m_current = m_ancestorSiblingStack.takeLast();
266 
<span class="line-modified">267 #if !ASSERT_DISABLED</span>
268     // Drop the assertion when the iterator reaches the end.
269     if (!m_current)
270         m_assertions.dropEventDispatchAssertion();
271 #endif
272 
273     return *this;
274 }
275 
276 inline const Element&amp; ElementDescendantConstIterator::operator*() const
277 {
278     ASSERT(m_current);
279     ASSERT(!m_assertions.domTreeHasMutated());
280     return *m_current;
281 }
282 
283 inline const Element* ElementDescendantConstIterator::operator-&gt;() const
284 {
285     ASSERT(m_current);
286     ASSERT(!m_assertions.domTreeHasMutated());
287     return m_current;
</pre>
</td>
<td>
<hr />
<pre>
 35 class ElementDescendantIterator {
 36 public:
 37     ElementDescendantIterator();
 38     explicit ElementDescendantIterator(Element* current);
 39 
 40     ElementDescendantIterator&amp; operator++();
 41     ElementDescendantIterator&amp; operator--();
 42 
 43     Element&amp; operator*();
 44     Element* operator-&gt;();
 45 
 46     bool operator==(const ElementDescendantIterator&amp; other) const;
 47     bool operator!=(const ElementDescendantIterator&amp; other) const;
 48 
 49     void dropAssertions();
 50 
 51 private:
 52     Element* m_current;
 53     Vector&lt;Element*, 16&gt; m_ancestorSiblingStack;
 54 
<span class="line-modified"> 55 #if ASSERT_ENABLED</span>
 56     ElementIteratorAssertions m_assertions;
 57 #endif
 58 };
 59 
 60 class ElementDescendantConstIterator {
 61 public:
 62     ElementDescendantConstIterator();
 63     explicit ElementDescendantConstIterator(const Element*);
 64 
 65     ElementDescendantConstIterator&amp; operator++();
 66 
 67     const Element&amp; operator*() const;
 68     const Element* operator-&gt;() const;
 69 
 70     bool operator==(const ElementDescendantConstIterator&amp; other) const;
 71     bool operator!=(const ElementDescendantConstIterator&amp; other) const;
 72 
 73     void dropAssertions();
 74 
 75 private:
 76     const Element* m_current;
 77     Vector&lt;Element*, 16&gt; m_ancestorSiblingStack;
 78 
<span class="line-modified"> 79 #if ASSERT_ENABLED</span>
 80     ElementIteratorAssertions m_assertions;
 81 #endif
 82 };
 83 
 84 class ElementDescendantIteratorAdapter {
 85 public:
 86     ElementDescendantIteratorAdapter(ContainerNode&amp; root);
 87     ElementDescendantIterator begin();
 88     ElementDescendantIterator end();
 89     ElementDescendantIterator last();
 90 
 91 private:
 92     ContainerNode&amp; m_root;
 93 };
 94 
 95 class ElementDescendantConstIteratorAdapter {
 96 public:
 97     ElementDescendantConstIteratorAdapter(const ContainerNode&amp; root);
 98     ElementDescendantConstIterator begin() const;
 99     ElementDescendantConstIterator end() const;
100     ElementDescendantConstIterator last() const;
101 
102 private:
103     const ContainerNode&amp; m_root;
104 };
105 
106 ElementDescendantIteratorAdapter elementDescendants(ContainerNode&amp;);
107 ElementDescendantConstIteratorAdapter elementDescendants(const ContainerNode&amp;);
108 
109 // ElementDescendantIterator
110 
111 inline ElementDescendantIterator::ElementDescendantIterator()
112     : m_current(nullptr)
113 {
114 }
115 
116 inline ElementDescendantIterator::ElementDescendantIterator(Element* current)
117     : m_current(current)
<span class="line-modified">118 #if ASSERT_ENABLED</span>
119     , m_assertions(current)
120 #endif
121 {
122     m_ancestorSiblingStack.uncheckedAppend(nullptr);
123 }
124 
125 inline void ElementDescendantIterator::dropAssertions()
126 {
<span class="line-modified">127 #if ASSERT_ENABLED</span>
128     m_assertions.clear();
129 #endif
130 }
131 
132 ALWAYS_INLINE ElementDescendantIterator&amp; ElementDescendantIterator::operator++()
133 {
134     ASSERT(m_current);
135     ASSERT(!m_assertions.domTreeHasMutated());
136 
137     Element* firstChild = ElementTraversal::firstChild(*m_current);
138     Element* nextSibling = ElementTraversal::nextSibling(*m_current);
139 
140     if (firstChild) {
141         if (nextSibling)
142             m_ancestorSiblingStack.append(nextSibling);
143         m_current = firstChild;
144         return *this;
145     }
146 
147     if (nextSibling) {
148         m_current = nextSibling;
149         return *this;
150     }
151 
152     m_current = m_ancestorSiblingStack.takeLast();
153 
<span class="line-modified">154 #if ASSERT_ENABLED</span>
155     // Drop the assertion when the iterator reaches the end.
156     if (!m_current)
157         m_assertions.dropEventDispatchAssertion();
158 #endif
159 
160     return *this;
161 }
162 
163 ALWAYS_INLINE ElementDescendantIterator&amp; ElementDescendantIterator::operator--()
164 {
165     ASSERT(m_current);
166     ASSERT(!m_assertions.domTreeHasMutated());
167 
168     Element* previousSibling = ElementTraversal::previousSibling(*m_current);
169 
170     if (!previousSibling) {
171         m_current = m_current-&gt;parentElement();
172         // The stack optimizes for forward traversal only, this just maintains consistency.
173         if (m_current-&gt;nextSibling() &amp;&amp; m_current-&gt;nextSibling() == m_ancestorSiblingStack.last())
174             m_ancestorSiblingStack.removeLast();
175         return *this;
176     }
177 
178     Element* deepestSibling = previousSibling;
179     while (Element* lastChild = ElementTraversal::lastChild(*deepestSibling))
180         deepestSibling = lastChild;
181     ASSERT(deepestSibling);
182 
183     if (deepestSibling != previousSibling)
184         m_ancestorSiblingStack.append(m_current);
185 
186     m_current = deepestSibling;
187 
<span class="line-modified">188 #if ASSERT_ENABLED</span>
189     // Drop the assertion when the iterator reaches the end.
190     if (!m_current)
191         m_assertions.dropEventDispatchAssertion();
192 #endif
193 
194     return *this;
195 }
196 
197 inline Element&amp; ElementDescendantIterator::operator*()
198 {
199     ASSERT(m_current);
200     ASSERT(!m_assertions.domTreeHasMutated());
201     return *m_current;
202 }
203 
204 inline Element* ElementDescendantIterator::operator-&gt;()
205 {
206     ASSERT(m_current);
207     ASSERT(!m_assertions.domTreeHasMutated());
208     return m_current;
</pre>
<hr />
<pre>
211 inline bool ElementDescendantIterator::operator==(const ElementDescendantIterator&amp; other) const
212 {
213     ASSERT(!m_assertions.domTreeHasMutated());
214     return m_current == other.m_current;
215 }
216 
217 inline bool ElementDescendantIterator::operator!=(const ElementDescendantIterator&amp; other) const
218 {
219     return !(*this == other);
220 }
221 
222 // ElementDescendantConstIterator
223 
224 inline ElementDescendantConstIterator::ElementDescendantConstIterator()
225     : m_current(nullptr)
226 {
227 }
228 
229 inline ElementDescendantConstIterator::ElementDescendantConstIterator(const Element* current)
230     : m_current(current)
<span class="line-modified">231 #if ASSERT_ENABLED</span>
232     , m_assertions(current)
233 #endif
234 {
235     m_ancestorSiblingStack.uncheckedAppend(nullptr);
236 }
237 
238 inline void ElementDescendantConstIterator::dropAssertions()
239 {
<span class="line-modified">240 #if ASSERT_ENABLED</span>
241     m_assertions.clear();
242 #endif
243 }
244 
245 ALWAYS_INLINE ElementDescendantConstIterator&amp; ElementDescendantConstIterator::operator++()
246 {
247     ASSERT(m_current);
248     ASSERT(!m_assertions.domTreeHasMutated());
249 
250     Element* firstChild = ElementTraversal::firstChild(*m_current);
251     Element* nextSibling = ElementTraversal::nextSibling(*m_current);
252 
253     if (firstChild) {
254         if (nextSibling)
255             m_ancestorSiblingStack.append(nextSibling);
256         m_current = firstChild;
257         return *this;
258     }
259 
260     if (nextSibling) {
261         m_current = nextSibling;
262         return *this;
263     }
264 
265     m_current = m_ancestorSiblingStack.takeLast();
266 
<span class="line-modified">267 #if ASSERT_ENABLED</span>
268     // Drop the assertion when the iterator reaches the end.
269     if (!m_current)
270         m_assertions.dropEventDispatchAssertion();
271 #endif
272 
273     return *this;
274 }
275 
276 inline const Element&amp; ElementDescendantConstIterator::operator*() const
277 {
278     ASSERT(m_current);
279     ASSERT(!m_assertions.domTreeHasMutated());
280     return *m_current;
281 }
282 
283 inline const Element* ElementDescendantConstIterator::operator-&gt;() const
284 {
285     ASSERT(m_current);
286     ASSERT(!m_assertions.domTreeHasMutated());
287     return m_current;
</pre>
</td>
</tr>
</table>
<center><a href="ElementData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ElementIterator.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
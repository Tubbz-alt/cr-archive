<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCMediaEndpoint.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1.  Redistributions of source code must retain the above copyright
  8  *     notice, this list of conditions and the following disclaimer.
  9  * 2.  Redistributions in binary form must reproduce the above copyright
 10  *     notice, this list of conditions and the following disclaimer in the
 11  *     documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 23  */
 24 
 25 #pragma once
 26 
 27 #if USE(LIBWEBRTC)
 28 
 29 #include &quot;LibWebRTCObservers.h&quot;
 30 #include &quot;LibWebRTCProvider.h&quot;
 31 #include &quot;LibWebRTCRtpSenderBackend.h&quot;
 32 #include &quot;RTCRtpReceiver.h&quot;
 33 #include &lt;Timer.h&gt;
 34 
 35 ALLOW_UNUSED_PARAMETERS_BEGIN
 36 
 37 #include &lt;webrtc/api/jsep.h&gt;
<a name="1" id="anc1"></a><span class="line-modified"> 38 #include &lt;webrtc/api/peer_connection_interface.h&gt;</span>
<span class="line-modified"> 39 #include &lt;webrtc/pc/peer_connection_factory.h&gt;</span>
<span class="line-modified"> 40 #include &lt;webrtc/pc/rtc_stats_collector.h&gt;</span>
 41 
 42 ALLOW_UNUSED_PARAMETERS_END
 43 
 44 #include &lt;wtf/LoggerHelper.h&gt;
 45 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
 46 
 47 namespace webrtc {
 48 class CreateSessionDescriptionObserver;
 49 class DataChannelInterface;
 50 class IceCandidateInterface;
 51 class MediaStreamInterface;
 52 class PeerConnectionObserver;
 53 class SessionDescriptionInterface;
 54 class SetSessionDescriptionObserver;
 55 }
 56 
 57 namespace WebCore {
 58 class LibWebRTCProvider;
 59 class LibWebRTCPeerConnectionBackend;
 60 class LibWebRTCRtpReceiverBackend;
 61 class LibWebRTCRtpTransceiverBackend;
 62 class LibWebRTCStatsCollector;
 63 class MediaStreamTrack;
 64 class RTCSessionDescription;
 65 
 66 class LibWebRTCMediaEndpoint
 67     : public ThreadSafeRefCounted&lt;LibWebRTCMediaEndpoint, WTF::DestructionThread::Main&gt;
 68     , private webrtc::PeerConnectionObserver
 69     , private webrtc::RTCStatsCollectorCallback
 70 #if !RELEASE_LOG_DISABLED
 71     , private LoggerHelper
 72 #endif
 73 {
 74 public:
 75     static Ref&lt;LibWebRTCMediaEndpoint&gt; create(LibWebRTCPeerConnectionBackend&amp; peerConnection, LibWebRTCProvider&amp; client) { return adoptRef(*new LibWebRTCMediaEndpoint(peerConnection, client)); }
 76     virtual ~LibWebRTCMediaEndpoint() = default;
 77 
 78     bool setConfiguration(LibWebRTCProvider&amp;, webrtc::PeerConnectionInterface::RTCConfiguration&amp;&amp;);
 79 
 80     webrtc::PeerConnectionInterface&amp; backend() const { ASSERT(m_backend); return *m_backend.get(); }
 81     void doSetLocalDescription(RTCSessionDescription&amp;);
 82     void doSetRemoteDescription(RTCSessionDescription&amp;);
 83     void doCreateOffer(const RTCOfferOptions&amp;);
 84     void doCreateAnswer();
 85     void getStats(Ref&lt;DeferredPromise&gt;&amp;&amp;);
 86     void getStats(webrtc::RtpReceiverInterface&amp;, Ref&lt;DeferredPromise&gt;&amp;&amp;);
 87     void getStats(webrtc::RtpSenderInterface&amp;, Ref&lt;DeferredPromise&gt;&amp;&amp;);
 88     std::unique_ptr&lt;RTCDataChannelHandler&gt; createDataChannel(const String&amp;, const RTCDataChannelInit&amp;);
 89     bool addIceCandidate(webrtc::IceCandidateInterface&amp; candidate) { return m_backend-&gt;AddIceCandidate(&amp;candidate); }
 90 
<a name="2" id="anc2"></a><span class="line-added"> 91     void close();</span>
 92     void stop();
 93     bool isStopped() const { return !m_backend; }
 94 
 95     RefPtr&lt;RTCSessionDescription&gt; localDescription() const;
 96     RefPtr&lt;RTCSessionDescription&gt; remoteDescription() const;
 97     RefPtr&lt;RTCSessionDescription&gt; currentLocalDescription() const;
 98     RefPtr&lt;RTCSessionDescription&gt; currentRemoteDescription() const;
 99     RefPtr&lt;RTCSessionDescription&gt; pendingLocalDescription() const;
100     RefPtr&lt;RTCSessionDescription&gt; pendingRemoteDescription() const;
101 
102     bool addTrack(LibWebRTCRtpSenderBackend&amp;, MediaStreamTrack&amp;, const Vector&lt;String&gt;&amp;);
103     void removeTrack(LibWebRTCRtpSenderBackend&amp;);
104 
105     struct Backends {
106         std::unique_ptr&lt;LibWebRTCRtpSenderBackend&gt; senderBackend;
107         std::unique_ptr&lt;LibWebRTCRtpReceiverBackend&gt; receiverBackend;
108         std::unique_ptr&lt;LibWebRTCRtpTransceiverBackend&gt; transceiverBackend;
109     };
110     Optional&lt;Backends&gt; addTransceiver(const String&amp; trackKind, const RTCRtpTransceiverInit&amp;);
111     Optional&lt;Backends&gt; addTransceiver(MediaStreamTrack&amp;, const RTCRtpTransceiverInit&amp;);
112     std::unique_ptr&lt;LibWebRTCRtpTransceiverBackend&gt; transceiverBackendFromSender(LibWebRTCRtpSenderBackend&amp;);
113 
114     void setSenderSourceFromTrack(LibWebRTCRtpSenderBackend&amp;, MediaStreamTrack&amp;);
115     void collectTransceivers();
116 
<a name="3" id="anc3"></a><span class="line-added">117     void suspend();</span>
<span class="line-added">118     void resume();</span>
<span class="line-added">119 </span>
120 private:
121     LibWebRTCMediaEndpoint(LibWebRTCPeerConnectionBackend&amp;, LibWebRTCProvider&amp;);
122 
123     // webrtc::PeerConnectionObserver API
124     void OnSignalingChange(webrtc::PeerConnectionInterface::SignalingState) final;
125     void OnAddStream(rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;) final;
126     void OnRemoveStream(rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;) final;
127     void OnDataChannel(rtc::scoped_refptr&lt;webrtc::DataChannelInterface&gt;) final;
<a name="4" id="anc4"></a>
128     void OnTrack(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt;) final;
129     void OnRemoveTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;) final;
130 
131     void OnRenegotiationNeeded() final;
132     void OnIceConnectionChange(webrtc::PeerConnectionInterface::IceConnectionState) final;
133     void OnIceGatheringChange(webrtc::PeerConnectionInterface::IceGatheringState) final;
134     void OnIceCandidate(const webrtc::IceCandidateInterface*) final;
135     void OnIceCandidatesRemoved(const std::vector&lt;cricket::Candidate&gt;&amp;) final;
136 
137     void createSessionDescriptionSucceeded(std::unique_ptr&lt;webrtc::SessionDescriptionInterface&gt;&amp;&amp;);
138     void createSessionDescriptionFailed(ExceptionCode, const char*);
139     void setLocalSessionDescriptionSucceeded();
140     void setLocalSessionDescriptionFailed(ExceptionCode, const char*);
141     void setRemoteSessionDescriptionSucceeded();
142     void setRemoteSessionDescriptionFailed(ExceptionCode, const char*);
143     void addRemoteStream(webrtc::MediaStreamInterface&amp;);
144     void addRemoteTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;&amp;&amp;, const std::vector&lt;rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;&gt;&amp;);
145     void removeRemoteStream(webrtc::MediaStreamInterface&amp;);
146     void newTransceiver(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt;&amp;&amp;);
147     void removeRemoteTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;&amp;&amp;);
148 
149     void addPendingTrackEvent(Ref&lt;RTCRtpReceiver&gt;&amp;&amp;, MediaStreamTrack&amp;, const std::vector&lt;rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;&gt;&amp;, RefPtr&lt;RTCRtpTransceiver&gt;&amp;&amp;);
150 
151     template&lt;typename T&gt;
152     Optional&lt;Backends&gt; createTransceiverBackends(T&amp;&amp;, const RTCRtpTransceiverInit&amp;, LibWebRTCRtpSenderBackend::Source&amp;&amp;);
153 
154     void OnStatsDelivered(const rtc::scoped_refptr&lt;const webrtc::RTCStatsReport&gt;&amp;) final;
155     void gatherStatsForLogging();
156     void startLoggingStats();
157     void stopLoggingStats();
158 
159     rtc::scoped_refptr&lt;LibWebRTCStatsCollector&gt; createStatsCollector(Ref&lt;DeferredPromise&gt;&amp;&amp;);
160 
161     MediaStream&amp; mediaStreamFromRTCStream(webrtc::MediaStreamInterface&amp;);
162 
163     void AddRef() const { ref(); }
164     rtc::RefCountReleaseStatus Release() const
165     {
166         auto result = refCount() - 1;
167         deref();
168         return result ? rtc::RefCountReleaseStatus::kOtherRefsRemained
169         : rtc::RefCountReleaseStatus::kDroppedLastRef;
170     }
171 
172     std::pair&lt;LibWebRTCRtpSenderBackend::Source, rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt;&gt; createSourceAndRTCTrack(MediaStreamTrack&amp;);
173     RefPtr&lt;RealtimeMediaSource&gt; sourceFromNewReceiver(webrtc::RtpReceiverInterface&amp;);
174 
175 #if !RELEASE_LOG_DISABLED
176     const Logger&amp; logger() const final { return m_logger.get(); }
177     const void* logIdentifier() const final { return m_logIdentifier; }
178     const char* logClassName() const final { return &quot;LibWebRTCMediaEndpoint&quot;; }
179     WTFLogChannel&amp; logChannel() const final;
180 
181     Seconds statsLogInterval(int64_t) const;
182 #endif
183 
184     LibWebRTCPeerConnectionBackend&amp; m_peerConnectionBackend;
185     webrtc::PeerConnectionFactoryInterface&amp; m_peerConnectionFactory;
186     rtc::scoped_refptr&lt;webrtc::PeerConnectionInterface&gt; m_backend;
187 
188     friend CreateSessionDescriptionObserver&lt;LibWebRTCMediaEndpoint&gt;;
189     friend SetLocalSessionDescriptionObserver&lt;LibWebRTCMediaEndpoint&gt;;
190     friend SetRemoteSessionDescriptionObserver&lt;LibWebRTCMediaEndpoint&gt;;
191 
192     CreateSessionDescriptionObserver&lt;LibWebRTCMediaEndpoint&gt; m_createSessionDescriptionObserver;
193     SetLocalSessionDescriptionObserver&lt;LibWebRTCMediaEndpoint&gt; m_setLocalSessionDescriptionObserver;
194     SetRemoteSessionDescriptionObserver&lt;LibWebRTCMediaEndpoint&gt; m_setRemoteSessionDescriptionObserver;
195 
196     HashMap&lt;String, RefPtr&lt;MediaStream&gt;&gt; m_remoteStreamsById;
197     HashMap&lt;MediaStreamTrack*, Vector&lt;String&gt;&gt; m_remoteStreamsFromRemoteTrack;
198 
199     bool m_isInitiator { false };
200     Timer m_statsLogTimer;
201 
202     HashMap&lt;String, rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;&gt; m_localStreams;
203 
<a name="5" id="anc5"></a><span class="line-modified">204     std::unique_ptr&lt;LibWebRTCProvider::SuspendableSocketFactory&gt; m_rtcSocketFactory;</span>
205 #if !RELEASE_LOG_DISABLED
206     int64_t m_statsFirstDeliveredTimestamp { 0 };
207     Ref&lt;const Logger&gt; m_logger;
208     const void* m_logIdentifier;
209 #endif
210 };
211 
212 } // namespace WebCore
213 
214 #endif // USE(LIBWEBRTC)
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
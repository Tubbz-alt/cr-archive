<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/style/NinePieceImage.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2000 Lars Knoll (knoll@kde.org)
  3  *           (C) 2000 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2000 Dirk Mueller (mueller@kde.org)
  5  * Copyright (C) 2003-2017 Apple Inc. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  *
 22  */
 23 
 24 #pragma once
 25 
 26 #include &quot;DataRef.h&quot;
 27 #include &quot;LengthBox.h&quot;
 28 #include &quot;StyleImage.h&quot;
 29 #include &lt;wtf/Vector.h&gt;
 30 
 31 namespace WebCore {
 32 
 33 class LayoutSize;
 34 class LayoutRect;
 35 class RenderStyle;
 36 
 37 enum class NinePieceImageRule : uint8_t {
 38     Stretch,
 39     Round,
 40     Space,
 41     Repeat,
 42 };
 43 
 44 // Used for array indexing, so not an enum class.
 45 enum ImagePiece {
 46     MinPiece = 0,
 47     TopLeftPiece = MinPiece,
 48     LeftPiece,
 49     BottomLeftPiece,
 50     TopRightPiece,
 51     RightPiece,
 52     BottomRightPiece,
 53     TopPiece,
 54     BottomPiece,
 55     MiddlePiece,
 56     MaxPiece
 57 };
 58 
 59 inline ImagePiece&amp; operator++(ImagePiece&amp; piece)
 60 {
 61     piece = static_cast&lt;ImagePiece&gt;(static_cast&lt;int&gt;(piece) + 1);
 62     return piece;
 63 }
 64 
 65 inline bool isCornerPiece(ImagePiece piece)
 66 {
 67     return piece == TopLeftPiece || piece == TopRightPiece || piece == BottomLeftPiece || piece == BottomRightPiece;
 68 }
 69 
 70 inline bool isMiddlePiece(ImagePiece piece)
 71 {
 72     return piece == MiddlePiece;
 73 }
 74 
 75 inline bool isHorizontalPiece(ImagePiece piece)
 76 {
 77     return piece == TopPiece || piece == BottomPiece || piece == MiddlePiece;
 78 }
 79 
 80 inline bool isVerticalPiece(ImagePiece piece)
 81 {
 82     return piece == LeftPiece || piece == RightPiece || piece == MiddlePiece;
 83 }
 84 
 85 inline Optional&lt;PhysicalBoxSide&gt; imagePieceHorizontalSide(ImagePiece piece)
 86 {
 87     if (piece == TopLeftPiece || piece == TopPiece || piece == TopRightPiece)
 88         return PhysicalBoxSide::Top;
 89 
 90     if (piece == BottomLeftPiece || piece == BottomPiece || piece == BottomRightPiece)
 91         return PhysicalBoxSide::Bottom;
 92 
 93     return WTF::nullopt;
 94 }
 95 
 96 inline Optional&lt;PhysicalBoxSide&gt; imagePieceVerticalSide(ImagePiece piece)
 97 {
 98     if (piece == TopLeftPiece || piece == LeftPiece || piece == BottomLeftPiece)
 99         return PhysicalBoxSide::Left;
100 
101     if (piece == TopRightPiece || piece == RightPiece || piece == BottomRightPiece)
102         return PhysicalBoxSide::Right;
103 
104     return WTF::nullopt;
105 }
106 
107 class NinePieceImage {
108 public:
109     enum class Type {
110         Normal,
111         Mask
112     };
113 
114     NinePieceImage(Type = Type::Normal);
115     NinePieceImage(RefPtr&lt;StyleImage&gt;&amp;&amp;, LengthBox imageSlices, bool fill, LengthBox borderSlices, LengthBox outset, NinePieceImageRule horizontalRule, NinePieceImageRule verticalRule);
116 
117     bool operator==(const NinePieceImage&amp; other) const { return m_data == other.m_data; }
118     bool operator!=(const NinePieceImage&amp; other) const { return m_data != other.m_data; }
119 
120     bool hasImage() const { return m_data-&gt;image; }
121     StyleImage* image() const { return m_data-&gt;image.get(); }
122     void setImage(RefPtr&lt;StyleImage&gt;&amp;&amp; image) { m_data.access().image = WTFMove(image); }
123 
124     const LengthBox&amp; imageSlices() const { return m_data-&gt;imageSlices; }
125     void setImageSlices(LengthBox slices) { m_data.access().imageSlices = WTFMove(slices); }
126 
127     bool fill() const { return m_data-&gt;fill; }
128     void setFill(bool fill) { m_data.access().fill = fill; }
129 
130     const LengthBox&amp; borderSlices() const { return m_data-&gt;borderSlices; }
131     void setBorderSlices(LengthBox slices) { m_data.access().borderSlices = WTFMove(slices); }
132 
133     const LengthBox&amp; outset() const { return m_data-&gt;outset; }
134     void setOutset(LengthBox outset) { m_data.access().outset = WTFMove(outset); }
135 
136     NinePieceImageRule horizontalRule() const { return m_data-&gt;horizontalRule; }
137     void setHorizontalRule(NinePieceImageRule rule) { m_data.access().horizontalRule = rule; }
138 
139     NinePieceImageRule verticalRule() const { return m_data-&gt;verticalRule; }
140     void setVerticalRule(NinePieceImageRule rule) { m_data.access().verticalRule = rule; }
141 
142     void copyImageSlicesFrom(const NinePieceImage&amp; other)
143     {
144         m_data.access().imageSlices = other.m_data-&gt;imageSlices;
145         m_data.access().fill = other.m_data-&gt;fill;
146     }
147 
148     void copyBorderSlicesFrom(const NinePieceImage&amp; other)
149     {
150         m_data.access().borderSlices = other.m_data-&gt;borderSlices;
151     }
152 
153     void copyOutsetFrom(const NinePieceImage&amp; other)
154     {
155         m_data.access().outset = other.m_data-&gt;outset;
156     }
157 
158     void copyRepeatFrom(const NinePieceImage&amp; other)
159     {
160         m_data.access().horizontalRule = other.m_data-&gt;horizontalRule;
161         m_data.access().verticalRule = other.m_data-&gt;verticalRule;
162     }
163 
164     static LayoutUnit computeOutset(const Length&amp; outsetSide, LayoutUnit borderSide)
165     {
166         if (outsetSide.isRelative())
167             return LayoutUnit(outsetSide.value() * borderSide);
168         return LayoutUnit(outsetSide.value());
169     }
170 
171     static LayoutUnit computeSlice(Length, LayoutUnit width, LayoutUnit slice, LayoutUnit extent);
172     static LayoutBoxExtent computeSlices(const LayoutSize&amp;, const LengthBox&amp; lengths, int scaleFactor);
173     static LayoutBoxExtent computeSlices(const LayoutSize&amp;, const LengthBox&amp; lengths, const FloatBoxExtent&amp; widths, const LayoutBoxExtent&amp; slices);
174 
175     static bool isEmptyPieceRect(ImagePiece, const LayoutBoxExtent&amp; slices);
176     static bool isEmptyPieceRect(ImagePiece, const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects);
177 
178     static Vector&lt;FloatRect&gt; computeNineRects(const FloatRect&amp; outer, const LayoutBoxExtent&amp; slices, float deviceScaleFactor);
179 
180     static void scaleSlicesIfNeeded(const LayoutSize&amp;, LayoutBoxExtent&amp; slices, float deviceScaleFactor);
181 
182     static FloatSize computeSideTileScale(ImagePiece, const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects);
183     static FloatSize computeMiddleTileScale(const Vector&lt;FloatSize&gt;&amp; scales, const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects, NinePieceImageRule hRule, NinePieceImageRule vRule);
184     static Vector&lt;FloatSize&gt; computeTileScales(const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects, NinePieceImageRule hRule, NinePieceImageRule vRule);
185 
186     void paint(GraphicsContext&amp;, RenderElement*, const RenderStyle&amp;, const LayoutRect&amp; destination, const LayoutSize&amp; source, float deviceScaleFactor, CompositeOperator) const;
187 
188 private:
189     struct Data : RefCounted&lt;Data&gt; {
190         static Ref&lt;Data&gt; create();
191         static Ref&lt;Data&gt; create(RefPtr&lt;StyleImage&gt;&amp;&amp;, LengthBox imageSlices, bool fill, LengthBox borderSlices, LengthBox outset, NinePieceImageRule horizontalRule, NinePieceImageRule verticalRule);
192         Ref&lt;Data&gt; copy() const;
193 
194         bool operator==(const Data&amp;) const;
195         bool operator!=(const Data&amp; other) const { return !(*this == other); }
196 
197         bool fill { false };
198         NinePieceImageRule horizontalRule { NinePieceImageRule::Stretch };
199         NinePieceImageRule verticalRule { NinePieceImageRule::Stretch };
200         RefPtr&lt;StyleImage&gt; image;
201         LengthBox imageSlices { { 100, Percent }, { 100, Percent }, { 100, Percent }, { 100, Percent } };
202         LengthBox borderSlices { { 1, Relative }, { 1, Relative }, { 1, Relative }, { 1, Relative } };
203         LengthBox outset { 0 };
204 
205     private:
206         Data();
207         Data(RefPtr&lt;StyleImage&gt;&amp;&amp;, LengthBox imageSlices, bool fill, LengthBox borderSlices, LengthBox outset, NinePieceImageRule horizontalRule, NinePieceImageRule verticalRule);
208         Data(const Data&amp;);
209     };
210 
211     static DataRef&lt;Data&gt;&amp; defaultData();
212     static DataRef&lt;Data&gt;&amp; defaultMaskData();
213 
214     DataRef&lt;Data&gt; m_data;
215 };
216 
217 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const NinePieceImage&amp;);
218 
219 } // namespace WebCore
    </pre>
  </body>
</html>
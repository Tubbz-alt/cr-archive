<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/StructureStubInfo.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StructureStubInfo.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SuperSampler.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/StructureStubInfo.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2008-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 

 28 #include &quot;CodeBlock.h&quot;
 29 #include &quot;CodeOrigin.h&quot;
 30 #include &quot;Instruction.h&quot;
 31 #include &quot;JITStubRoutine.h&quot;
 32 #include &quot;MacroAssembler.h&quot;
 33 #include &quot;Options.h&quot;
 34 #include &quot;RegisterSet.h&quot;
 35 #include &quot;Structure.h&quot;
 36 #include &quot;StructureSet.h&quot;
 37 #include &quot;StructureStubClearingWatchpoint.h&quot;
 38 #include &quot;StubInfoSummary.h&quot;

 39 
 40 namespace JSC {
 41 
 42 #if ENABLE(JIT)
 43 
 44 class AccessCase;
 45 class AccessGenerationResult;
 46 class PolymorphicAccess;
 47 
 48 enum class AccessType : int8_t {
<span class="line-modified"> 49     Get,</span>
<span class="line-modified"> 50     GetWithThis,</span>
<span class="line-modified"> 51     GetDirect,</span>
<span class="line-modified"> 52     TryGet,</span>

 53     Put,
 54     In,
 55     InstanceOf
 56 };
 57 
 58 enum class CacheType : int8_t {
 59     Unset,
 60     GetByIdSelf,
 61     PutByIdReplace,
 62     InByIdSelf,
 63     Stub,
 64     ArrayLength,
 65     StringLength
 66 };
 67 
 68 class StructureStubInfo {
 69     WTF_MAKE_NONCOPYABLE(StructureStubInfo);
 70     WTF_MAKE_FAST_ALLOCATED;
 71 public:
 72     StructureStubInfo(AccessType);
 73     ~StructureStubInfo();
 74 
<span class="line-modified"> 75     void initGetByIdSelf(CodeBlock*, Structure* baseObjectStructure, PropertyOffset);</span>
 76     void initArrayLength();
 77     void initStringLength();
 78     void initPutByIdReplace(CodeBlock*, Structure* baseObjectStructure, PropertyOffset);
 79     void initInByIdSelf(CodeBlock*, Structure* baseObjectStructure, PropertyOffset);
 80 
<span class="line-modified"> 81     AccessGenerationResult addAccessCase(const GCSafeConcurrentJSLocker&amp;, CodeBlock*, const Identifier&amp;, std::unique_ptr&lt;AccessCase&gt;);</span>
 82 
 83     void reset(CodeBlock*);
 84 
 85     void deref();
 86     void aboutToDie();
 87 


 88     // Check if the stub has weak references that are dead. If it does, then it resets itself,
 89     // either entirely or just enough to ensure that those dead pointers don&#39;t get used anymore.
 90     void visitWeakReferences(CodeBlock*);
 91 
 92     // This returns true if it has marked everything that it will ever mark.
 93     bool propagateTransitions(SlotVisitor&amp;);
 94 
<span class="line-modified"> 95     ALWAYS_INLINE bool considerCaching(VM&amp; vm, CodeBlock* codeBlock, Structure* structure)</span>
 96     {
 97         DisallowGC disallowGC;
 98 
 99         // We never cache non-cells.
100         if (!structure) {
101             sawNonCell = true;
102             return false;
103         }
104 
105         // This method is called from the Optimize variants of IC slow paths. The first part of this
106         // method tries to determine if the Optimize variant should really behave like the
107         // non-Optimize variant and leave the IC untouched.
108         //
109         // If we determine that we should do something to the IC then the next order of business is
110         // to determine if this Structure would impact the IC at all. We know that it won&#39;t, if we
111         // have already buffered something on its behalf. That&#39;s what the bufferedStructures set is
112         // for.
113 
114         everConsidered = true;
115         if (!countdown) {
</pre>
<hr />
<pre>
135             }
136 
137             // We don&#39;t want to return false due to buffering indefinitely.
138             if (!bufferingCountdown) {
139                 // Note that when this returns true, it&#39;s possible that we will not even get an
140                 // AccessCase because this may cause Repatch.cpp to simply do an in-place
141                 // repatching.
142                 return true;
143             }
144 
145             bufferingCountdown--;
146 
147             // Now protect the IC buffering. We want to proceed only if this is a structure that
148             // we don&#39;t already have a case buffered for. Note that if this returns true but the
149             // bufferingCountdown is not zero then we will buffer the access case for later without
150             // immediately generating code for it.
151             //
152             // NOTE: This will behave oddly for InstanceOf if the user varies the prototype but not
153             // the base&#39;s structure. That seems unlikely for the canonical use of instanceof, where
154             // the prototype is fixed.
<span class="line-modified">155             bool isNewlyAdded = bufferedStructures.add(structure);</span>
156             if (isNewlyAdded)
157                 vm.heap.writeBarrier(codeBlock);
158             return isNewlyAdded;
159         }
160         countdown--;
161         return false;
162     }
163 
<span class="line-modified">164     StubInfoSummary summary() const;</span>
165 
<span class="line-modified">166     static StubInfoSummary summary(const StructureStubInfo*);</span>
167 
168     bool containsPC(void* pc) const;
169 
170     CodeOrigin codeOrigin;
<span class="line-modified">171     CallSiteIndex callSiteIndex;</span>


172 
173     union {
174         struct {
175             WriteBarrierBase&lt;Structure&gt; baseObjectStructure;
176             PropertyOffset offset;
177         } byIdSelf;
178         PolymorphicAccess* stub;
179     } u;
180 







181     // Represents those structures that already have buffered AccessCases in the PolymorphicAccess.
182     // Note that it&#39;s always safe to clear this. If we clear it prematurely, then if we see the same
183     // structure again during this buffering countdown, we will create an AccessCase object for it.
184     // That&#39;s not so bad - we&#39;ll get rid of the redundant ones once we regenerate.
<span class="line-modified">185     StructureSet bufferedStructures;</span>

186 
<span class="line-modified">187     struct {</span>
<span class="line-modified">188         CodeLocationLabel&lt;JITStubRoutinePtrTag&gt; start; // This is either the start of the inline IC for *byId caches. or the location of patchable jump for &#39;instanceof&#39; caches.</span>
<span class="line-modified">189         CodeLocationLabel&lt;JSInternalPtrTag&gt; doneLocation;</span>
<span class="line-modified">190         CodeLocationCall&lt;JSInternalPtrTag&gt; slowPathCallLocation;</span>
<span class="line-removed">191         CodeLocationLabel&lt;JITStubRoutinePtrTag&gt; slowPathStartLocation;</span>
192 
<span class="line-modified">193         RegisterSet usedRegisters;</span>
194 
<span class="line-modified">195         uint32_t inlineSize() const</span>
<span class="line-modified">196         {</span>
<span class="line-modified">197             int32_t inlineSize = MacroAssembler::differenceBetweenCodePtr(start, doneLocation);</span>
<span class="line-modified">198             ASSERT(inlineSize &gt;= 0);</span>
<span class="line-modified">199             return inlineSize;</span>
<span class="line-modified">200         }</span>
201 
<span class="line-modified">202         GPRReg baseGPR;</span>
<span class="line-modified">203         GPRReg valueGPR;</span>

204         GPRReg thisGPR;



205 #if USE(JSVALUE32_64)
<span class="line-modified">206         GPRReg valueTagGPR;</span>
<span class="line-modified">207         GPRReg baseTagGPR;</span>



208         GPRReg thisTagGPR;


209 #endif
<span class="line-removed">210     } patch;</span>
211 
<span class="line-modified">212     GPRReg baseGPR() const</span>
213     {
<span class="line-modified">214         return patch.baseGPR;</span>

215     }
216 
<span class="line-modified">217     CodeLocationCall&lt;JSInternalPtrTag&gt; slowPathCallLocation() { return patch.slowPathCallLocation; }</span>
<span class="line-modified">218     CodeLocationLabel&lt;JSInternalPtrTag&gt; doneLocation() { return patch.doneLocation; }</span>
<span class="line-modified">219     CodeLocationLabel&lt;JITStubRoutinePtrTag&gt; slowPathStartLocation() { return patch.slowPathStartLocation; }</span>





220 
<span class="line-modified">221     CodeLocationJump&lt;JSInternalPtrTag&gt; patchableJump()</span>
222     {
<span class="line-modified">223         ASSERT(accessType == AccessType::InstanceOf);</span>
<span class="line-modified">224         return patch.start.jumpAtOffset&lt;JSInternalPtrTag&gt;(0);</span>



225     }
226 
<span class="line-modified">227     JSValueRegs valueRegs() const</span>
228     {
229         return JSValueRegs(
230 #if USE(JSVALUE32_64)
<span class="line-modified">231             patch.valueTagGPR,</span>
232 #endif
<span class="line-modified">233             patch.valueGPR);</span>
234     }
235 







236 
237     AccessType accessType;
<span class="line-modified">238     CacheType cacheType;</span>




239     uint8_t countdown; // We repatch only when this is zero. If not zero, we decrement.
240     uint8_t repatchCount;
241     uint8_t numberOfCoolDowns;



242     uint8_t bufferingCountdown;
243     bool resetByGC : 1;
244     bool tookSlowPath : 1;
245     bool everConsidered : 1;
246     bool prototypeIsKnownObject : 1; // Only relevant for InstanceOf.
247     bool sawNonCell : 1;




248 };
249 
250 inline CodeOrigin getStructureStubInfoCodeOrigin(StructureStubInfo&amp; structureStubInfo)
251 {
252     return structureStubInfo.codeOrigin;
253 }
254 
<span class="line-modified">255 inline J_JITOperation_ESsiJI appropriateOptimizingGetByIdFunction(AccessType type)</span>
256 {
257     switch (type) {
<span class="line-modified">258     case AccessType::Get:</span>
259         return operationGetByIdOptimize;
<span class="line-modified">260     case AccessType::TryGet:</span>
261         return operationTryGetByIdOptimize;
<span class="line-modified">262     case AccessType::GetDirect:</span>
263         return operationGetByIdDirectOptimize;
<span class="line-modified">264     case AccessType::GetWithThis:</span>
265     default:
266         ASSERT_NOT_REACHED();
267         return nullptr;
268     }
269 }
270 
<span class="line-modified">271 inline J_JITOperation_EJI appropriateGenericGetByIdFunction(AccessType type)</span>
272 {
273     switch (type) {
<span class="line-modified">274     case AccessType::Get:</span>
275         return operationGetByIdGeneric;
<span class="line-modified">276     case AccessType::TryGet:</span>
277         return operationTryGetByIdGeneric;
<span class="line-modified">278     case AccessType::GetDirect:</span>
279         return operationGetByIdDirectGeneric;
<span class="line-modified">280     case AccessType::GetWithThis:</span>
281     default:
282         ASSERT_NOT_REACHED();
283         return nullptr;
284     }
285 }
286 
287 #else
288 
289 class StructureStubInfo;
290 
291 #endif // ENABLE(JIT)
292 
293 typedef HashMap&lt;CodeOrigin, StructureStubInfo*, CodeOriginApproximateHash&gt; StubInfoMap;
294 
295 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2008-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
<span class="line-added"> 28 #include &quot;CacheableIdentifier.h&quot;</span>
 29 #include &quot;CodeBlock.h&quot;
 30 #include &quot;CodeOrigin.h&quot;
 31 #include &quot;Instruction.h&quot;
 32 #include &quot;JITStubRoutine.h&quot;
 33 #include &quot;MacroAssembler.h&quot;
 34 #include &quot;Options.h&quot;
 35 #include &quot;RegisterSet.h&quot;
 36 #include &quot;Structure.h&quot;
 37 #include &quot;StructureSet.h&quot;
 38 #include &quot;StructureStubClearingWatchpoint.h&quot;
 39 #include &quot;StubInfoSummary.h&quot;
<span class="line-added"> 40 #include &lt;wtf/Box.h&gt;</span>
 41 
 42 namespace JSC {
 43 
 44 #if ENABLE(JIT)
 45 
 46 class AccessCase;
 47 class AccessGenerationResult;
 48 class PolymorphicAccess;
 49 
 50 enum class AccessType : int8_t {
<span class="line-modified"> 51     GetById,</span>
<span class="line-modified"> 52     GetByIdWithThis,</span>
<span class="line-modified"> 53     GetByIdDirect,</span>
<span class="line-modified"> 54     TryGetById,</span>
<span class="line-added"> 55     GetByVal,</span>
 56     Put,
 57     In,
 58     InstanceOf
 59 };
 60 
 61 enum class CacheType : int8_t {
 62     Unset,
 63     GetByIdSelf,
 64     PutByIdReplace,
 65     InByIdSelf,
 66     Stub,
 67     ArrayLength,
 68     StringLength
 69 };
 70 
 71 class StructureStubInfo {
 72     WTF_MAKE_NONCOPYABLE(StructureStubInfo);
 73     WTF_MAKE_FAST_ALLOCATED;
 74 public:
 75     StructureStubInfo(AccessType);
 76     ~StructureStubInfo();
 77 
<span class="line-modified"> 78     void initGetByIdSelf(CodeBlock*, Structure* baseObjectStructure, PropertyOffset, CacheableIdentifier);</span>
 79     void initArrayLength();
 80     void initStringLength();
 81     void initPutByIdReplace(CodeBlock*, Structure* baseObjectStructure, PropertyOffset);
 82     void initInByIdSelf(CodeBlock*, Structure* baseObjectStructure, PropertyOffset);
 83 
<span class="line-modified"> 84     AccessGenerationResult addAccessCase(const GCSafeConcurrentJSLocker&amp;, CodeBlock*, CacheableIdentifier, std::unique_ptr&lt;AccessCase&gt;);</span>
 85 
 86     void reset(CodeBlock*);
 87 
 88     void deref();
 89     void aboutToDie();
 90 
<span class="line-added"> 91     void visitAggregate(SlotVisitor&amp;);</span>
<span class="line-added"> 92 </span>
 93     // Check if the stub has weak references that are dead. If it does, then it resets itself,
 94     // either entirely or just enough to ensure that those dead pointers don&#39;t get used anymore.
 95     void visitWeakReferences(CodeBlock*);
 96 
 97     // This returns true if it has marked everything that it will ever mark.
 98     bool propagateTransitions(SlotVisitor&amp;);
 99 
<span class="line-modified">100     ALWAYS_INLINE bool considerCaching(VM&amp; vm, CodeBlock* codeBlock, Structure* structure, UniquedStringImpl* impl = nullptr)</span>
101     {
102         DisallowGC disallowGC;
103 
104         // We never cache non-cells.
105         if (!structure) {
106             sawNonCell = true;
107             return false;
108         }
109 
110         // This method is called from the Optimize variants of IC slow paths. The first part of this
111         // method tries to determine if the Optimize variant should really behave like the
112         // non-Optimize variant and leave the IC untouched.
113         //
114         // If we determine that we should do something to the IC then the next order of business is
115         // to determine if this Structure would impact the IC at all. We know that it won&#39;t, if we
116         // have already buffered something on its behalf. That&#39;s what the bufferedStructures set is
117         // for.
118 
119         everConsidered = true;
120         if (!countdown) {
</pre>
<hr />
<pre>
140             }
141 
142             // We don&#39;t want to return false due to buffering indefinitely.
143             if (!bufferingCountdown) {
144                 // Note that when this returns true, it&#39;s possible that we will not even get an
145                 // AccessCase because this may cause Repatch.cpp to simply do an in-place
146                 // repatching.
147                 return true;
148             }
149 
150             bufferingCountdown--;
151 
152             // Now protect the IC buffering. We want to proceed only if this is a structure that
153             // we don&#39;t already have a case buffered for. Note that if this returns true but the
154             // bufferingCountdown is not zero then we will buffer the access case for later without
155             // immediately generating code for it.
156             //
157             // NOTE: This will behave oddly for InstanceOf if the user varies the prototype but not
158             // the base&#39;s structure. That seems unlikely for the canonical use of instanceof, where
159             // the prototype is fixed.
<span class="line-modified">160             bool isNewlyAdded = bufferedStructures.add({ structure, impl }).isNewEntry;</span>
161             if (isNewlyAdded)
162                 vm.heap.writeBarrier(codeBlock);
163             return isNewlyAdded;
164         }
165         countdown--;
166         return false;
167     }
168 
<span class="line-modified">169     StubInfoSummary summary(VM&amp;) const;</span>
170 
<span class="line-modified">171     static StubInfoSummary summary(VM&amp;, const StructureStubInfo*);</span>
172 
173     bool containsPC(void* pc) const;
174 
175     CodeOrigin codeOrigin;
<span class="line-modified">176 private:</span>
<span class="line-added">177     CacheableIdentifier m_getByIdSelfIdentifier;</span>
<span class="line-added">178 public:</span>
179 
180     union {
181         struct {
182             WriteBarrierBase&lt;Structure&gt; baseObjectStructure;
183             PropertyOffset offset;
184         } byIdSelf;
185         PolymorphicAccess* stub;
186     } u;
187 
<span class="line-added">188     CacheableIdentifier getByIdSelfIdentifier()</span>
<span class="line-added">189     {</span>
<span class="line-added">190         RELEASE_ASSERT(m_cacheType == CacheType::GetByIdSelf);</span>
<span class="line-added">191         return m_getByIdSelfIdentifier;</span>
<span class="line-added">192     }</span>
<span class="line-added">193 </span>
<span class="line-added">194 private:</span>
195     // Represents those structures that already have buffered AccessCases in the PolymorphicAccess.
196     // Note that it&#39;s always safe to clear this. If we clear it prematurely, then if we see the same
197     // structure again during this buffering countdown, we will create an AccessCase object for it.
198     // That&#39;s not so bad - we&#39;ll get rid of the redundant ones once we regenerate.
<span class="line-modified">199     HashSet&lt;std::pair&lt;Structure*, RefPtr&lt;UniquedStringImpl&gt;&gt;&gt; bufferedStructures;</span>
<span class="line-added">200 public:</span>
201 
<span class="line-modified">202     CodeLocationLabel&lt;JITStubRoutinePtrTag&gt; start; // This is either the start of the inline IC for *byId caches. or the location of patchable jump for &#39;instanceof&#39; caches.</span>
<span class="line-modified">203     CodeLocationLabel&lt;JSInternalPtrTag&gt; doneLocation;</span>
<span class="line-modified">204     CodeLocationCall&lt;JSInternalPtrTag&gt; slowPathCallLocation;</span>
<span class="line-modified">205     CodeLocationLabel&lt;JITStubRoutinePtrTag&gt; slowPathStartLocation;</span>

206 
<span class="line-modified">207     RegisterSet usedRegisters;</span>
208 
<span class="line-modified">209     uint32_t inlineSize() const</span>
<span class="line-modified">210     {</span>
<span class="line-modified">211         int32_t inlineSize = MacroAssembler::differenceBetweenCodePtr(start, doneLocation);</span>
<span class="line-modified">212         ASSERT(inlineSize &gt;= 0);</span>
<span class="line-modified">213         return inlineSize;</span>
<span class="line-modified">214     }</span>
215 
<span class="line-modified">216     GPRReg baseGPR;</span>
<span class="line-modified">217     GPRReg valueGPR;</span>
<span class="line-added">218     union {</span>
219         GPRReg thisGPR;
<span class="line-added">220         GPRReg prototypeGPR;</span>
<span class="line-added">221         GPRReg propertyGPR;</span>
<span class="line-added">222     } regs;</span>
223 #if USE(JSVALUE32_64)
<span class="line-modified">224     GPRReg valueTagGPR;</span>
<span class="line-modified">225     // FIXME: [32-bits] Check if StructureStubInfo::baseTagGPR is used somewhere.</span>
<span class="line-added">226     // https://bugs.webkit.org/show_bug.cgi?id=204726</span>
<span class="line-added">227     GPRReg baseTagGPR;</span>
<span class="line-added">228     union {</span>
229         GPRReg thisTagGPR;
<span class="line-added">230         GPRReg propertyTagGPR;</span>
<span class="line-added">231     } v;</span>
232 #endif

233 
<span class="line-modified">234     CodeLocationJump&lt;JSInternalPtrTag&gt; patchableJump()</span>
235     {
<span class="line-modified">236         ASSERT(accessType == AccessType::InstanceOf);</span>
<span class="line-added">237         return start.jumpAtOffset&lt;JSInternalPtrTag&gt;(0);</span>
238     }
239 
<span class="line-modified">240     JSValueRegs valueRegs() const</span>
<span class="line-modified">241     {</span>
<span class="line-modified">242         return JSValueRegs(</span>
<span class="line-added">243 #if USE(JSVALUE32_64)</span>
<span class="line-added">244             valueTagGPR,</span>
<span class="line-added">245 #endif</span>
<span class="line-added">246             valueGPR);</span>
<span class="line-added">247     }</span>
248 
<span class="line-modified">249     JSValueRegs propertyRegs() const</span>
250     {
<span class="line-modified">251         return JSValueRegs(</span>
<span class="line-modified">252 #if USE(JSVALUE32_64)</span>
<span class="line-added">253             v.propertyTagGPR,</span>
<span class="line-added">254 #endif</span>
<span class="line-added">255             regs.propertyGPR);</span>
256     }
257 
<span class="line-modified">258     JSValueRegs baseRegs() const</span>
259     {
260         return JSValueRegs(
261 #if USE(JSVALUE32_64)
<span class="line-modified">262             baseTagGPR,</span>
263 #endif
<span class="line-modified">264             baseGPR);</span>
265     }
266 
<span class="line-added">267     bool thisValueIsInThisGPR() const { return accessType == AccessType::GetByIdWithThis; }</span>
<span class="line-added">268 </span>
<span class="line-added">269 #if ASSERT_ENABLED</span>
<span class="line-added">270     void checkConsistency();</span>
<span class="line-added">271 #else</span>
<span class="line-added">272     ALWAYS_INLINE void checkConsistency() { }</span>
<span class="line-added">273 #endif</span>
274 
275     AccessType accessType;
<span class="line-modified">276 private:</span>
<span class="line-added">277     CacheType m_cacheType;</span>
<span class="line-added">278     void setCacheType(CacheType);</span>
<span class="line-added">279 public:</span>
<span class="line-added">280     CacheType cacheType() const { return m_cacheType; }</span>
281     uint8_t countdown; // We repatch only when this is zero. If not zero, we decrement.
282     uint8_t repatchCount;
283     uint8_t numberOfCoolDowns;
<span class="line-added">284 </span>
<span class="line-added">285     CallSiteIndex callSiteIndex;</span>
<span class="line-added">286 </span>
287     uint8_t bufferingCountdown;
288     bool resetByGC : 1;
289     bool tookSlowPath : 1;
290     bool everConsidered : 1;
291     bool prototypeIsKnownObject : 1; // Only relevant for InstanceOf.
292     bool sawNonCell : 1;
<span class="line-added">293     bool hasConstantIdentifier : 1;</span>
<span class="line-added">294     bool propertyIsString : 1;</span>
<span class="line-added">295     bool propertyIsInt32 : 1;</span>
<span class="line-added">296     bool propertyIsSymbol : 1;</span>
297 };
298 
299 inline CodeOrigin getStructureStubInfoCodeOrigin(StructureStubInfo&amp; structureStubInfo)
300 {
301     return structureStubInfo.codeOrigin;
302 }
303 
<span class="line-modified">304 inline auto appropriateOptimizingGetByIdFunction(AccessType type) -&gt; decltype(&amp;operationGetByIdOptimize)</span>
305 {
306     switch (type) {
<span class="line-modified">307     case AccessType::GetById:</span>
308         return operationGetByIdOptimize;
<span class="line-modified">309     case AccessType::TryGetById:</span>
310         return operationTryGetByIdOptimize;
<span class="line-modified">311     case AccessType::GetByIdDirect:</span>
312         return operationGetByIdDirectOptimize;
<span class="line-modified">313     case AccessType::GetByIdWithThis:</span>
314     default:
315         ASSERT_NOT_REACHED();
316         return nullptr;
317     }
318 }
319 
<span class="line-modified">320 inline auto appropriateGenericGetByIdFunction(AccessType type) -&gt; decltype(&amp;operationGetByIdGeneric)</span>
321 {
322     switch (type) {
<span class="line-modified">323     case AccessType::GetById:</span>
324         return operationGetByIdGeneric;
<span class="line-modified">325     case AccessType::TryGetById:</span>
326         return operationTryGetByIdGeneric;
<span class="line-modified">327     case AccessType::GetByIdDirect:</span>
328         return operationGetByIdDirectGeneric;
<span class="line-modified">329     case AccessType::GetByIdWithThis:</span>
330     default:
331         ASSERT_NOT_REACHED();
332         return nullptr;
333     }
334 }
335 
336 #else
337 
338 class StructureStubInfo;
339 
340 #endif // ENABLE(JIT)
341 
342 typedef HashMap&lt;CodeOrigin, StructureStubInfo*, CodeOriginApproximateHash&gt; StubInfoMap;
343 
344 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="StructureStubInfo.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SuperSampler.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ScopedArguments.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ScopedArguments.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ScopedArguments.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ScopedArguments.h
@@ -36,20 +36,20 @@
 // object will store the overflow arguments, if there are any. This object will use the symbol
 // table's ScopedArgumentsTable and the activation, or its overflow storage, to handle all indexed
 // lookups.
 class ScopedArguments final : public GenericArguments<ScopedArguments> {
 private:
-    ScopedArguments(VM&, Structure*, WriteBarrier<Unknown>* storage);
+    ScopedArguments(VM&, Structure*, WriteBarrier<Unknown>* storage, unsigned totalLength);
     void finishCreation(VM&, JSFunction* callee, ScopedArgumentsTable*, JSLexicalEnvironment*);
     using Base = GenericArguments<ScopedArguments>;
 
 public:
     template<typename CellType, SubspaceAccess>
-    static CompleteSubspace* subspaceFor(VM& vm)
+    static IsoSubspace* subspaceFor(VM& vm)
     {
         static_assert(!CellType::needsDestruction, "");
-        return &vm.jsValueGigacageCellSpace;
+        return &vm.scopedArgumentsSpace;
     }
 
     // Creates an arguments object but leaves it uninitialized. This is dangerous if we GC right
     // after allocation.
     static ScopedArguments* createUninitialized(VM&, Structure*, JSFunction* callee, ScopedArgumentsTable*, JSLexicalEnvironment*, unsigned totalLength);
@@ -57,145 +57,113 @@
     // Creates an arguments object and initializes everything to the empty value. Use this if you
     // cannot guarantee that you'll immediately initialize all of the elements.
     static ScopedArguments* create(VM&, Structure*, JSFunction* callee, ScopedArgumentsTable*, JSLexicalEnvironment*, unsigned totalLength);
 
     // Creates an arguments object by copying the arguments from the stack.
-    static ScopedArguments* createByCopying(ExecState*, ScopedArgumentsTable*, JSLexicalEnvironment*);
+    static ScopedArguments* createByCopying(JSGlobalObject*, CallFrame*, ScopedArgumentsTable*, JSLexicalEnvironment*);
 
     // Creates an arguments object by copying the arguments from a well-defined stack location.
     static ScopedArguments* createByCopyingFrom(VM&, Structure*, Register* argumentsStart, unsigned totalLength, JSFunction* callee, ScopedArgumentsTable*, JSLexicalEnvironment*);
 
     static void visitChildren(JSCell*, SlotVisitor&);
 
     uint32_t internalLength() const
     {
-        return storageHeader().totalLength;
+        return m_totalLength;
     }
 
-    uint32_t length(ExecState* exec) const
+    uint32_t length(JSGlobalObject* globalObject) const
     {
-        VM& vm = exec->vm();
+        VM& vm = getVM(globalObject);
         auto scope = DECLARE_THROW_SCOPE(vm);
-        if (UNLIKELY(storageHeader().overrodeThings)) {
-            auto value = get(exec, vm.propertyNames->length);
+        if (UNLIKELY(m_overrodeThings)) {
+            auto value = get(globalObject, vm.propertyNames->length);
             RETURN_IF_EXCEPTION(scope, 0);
-            RELEASE_AND_RETURN(scope, value.toUInt32(exec));
+            RELEASE_AND_RETURN(scope, value.toUInt32(globalObject));
         }
         return internalLength();
     }
 
     bool isMappedArgument(uint32_t i) const
     {
-        WriteBarrier<Unknown>* storage = overflowStorage();
-        if (i >= storageHeader(storage).totalLength)
+        if (i >= m_totalLength)
             return false;
         unsigned namedLength = m_table->length();
         if (i < namedLength)
             return !!m_table->get(i);
-        return !!storage[i - namedLength].get();
+        return !!storage()[i - namedLength].get();
     }
 
     bool isMappedArgumentInDFG(uint32_t i) const
     {
         return isMappedArgument(i);
     }
 
     JSValue getIndexQuickly(uint32_t i) const
     {
         ASSERT_WITH_SECURITY_IMPLICATION(isMappedArgument(i));
-        WriteBarrier<Unknown>* storage = overflowStorage();
-        unsigned totalLength = storageHeader(storage).totalLength;
         unsigned namedLength = m_table->length();
         if (i < namedLength)
-            return preciseIndexMaskPtr(i, totalLength, &m_scope->variableAt(m_table->get(i)))->get();
-        return preciseIndexMaskPtr(i, totalLength, storage + (i - namedLength))->get();
+            return m_scope->variableAt(m_table->get(i)).get();
+        return storage()[i - namedLength].get();
     }
 
     void setIndexQuickly(VM& vm, uint32_t i, JSValue value)
     {
         ASSERT_WITH_SECURITY_IMPLICATION(isMappedArgument(i));
-        WriteBarrier<Unknown>* storage = overflowStorage();
-        unsigned totalLength = storageHeader(storage).totalLength;
         unsigned namedLength = m_table->length();
         if (i < namedLength)
-            preciseIndexMaskPtr(i, totalLength, &m_scope->variableAt(m_table->get(i)))->set(vm, m_scope.get(), value);
+            m_scope->variableAt(m_table->get(i)).set(vm, m_scope.get(), value);
         else
-            preciseIndexMaskPtr(i, totalLength, storage + (i - namedLength))->set(vm, this, value);
+            storage()[i - namedLength].set(vm, this, value);
     }
 
     JSFunction* callee()
     {
         return m_callee.get();
     }
 
-    bool overrodeThings() const { return storageHeader().overrodeThings; }
-    void overrideThings(VM&);
-    void overrideThingsIfNecessary(VM&);
-    void unmapArgument(VM&, uint32_t index);
+    bool overrodeThings() const { return m_overrodeThings; }
+    void overrideThings(JSGlobalObject*);
+    void overrideThingsIfNecessary(JSGlobalObject*);
+    void unmapArgument(JSGlobalObject*, uint32_t index);
 
-    void initModifiedArgumentsDescriptorIfNecessary(VM& vm)
+    void initModifiedArgumentsDescriptorIfNecessary(JSGlobalObject* globalObject)
     {
-        GenericArguments<ScopedArguments>::initModifiedArgumentsDescriptorIfNecessary(vm, m_table->length());
+        GenericArguments<ScopedArguments>::initModifiedArgumentsDescriptorIfNecessary(globalObject, m_table->length());
     }
 
-    void setModifiedArgumentDescriptor(VM& vm, unsigned index)
+    void setModifiedArgumentDescriptor(JSGlobalObject* globalObject, unsigned index)
     {
-        GenericArguments<ScopedArguments>::setModifiedArgumentDescriptor(vm, index, m_table->length());
+        GenericArguments<ScopedArguments>::setModifiedArgumentDescriptor(globalObject, index, m_table->length());
     }
 
     bool isModifiedArgumentDescriptor(unsigned index)
     {
         return GenericArguments<ScopedArguments>::isModifiedArgumentDescriptor(index, m_table->length());
     }
 
-    void copyToArguments(ExecState*, VirtualRegister firstElementDest, unsigned offset, unsigned length);
+    void copyToArguments(JSGlobalObject*, JSValue* firstElementDest, unsigned offset, unsigned length);
 
     DECLARE_INFO;
 
     static Structure* createStructure(VM&, JSGlobalObject*, JSValue prototype);
 
-    static ptrdiff_t offsetOfStorage() { return OBJECT_OFFSETOF(ScopedArguments, m_storage); }
-    static ptrdiff_t offsetOfOverrodeThingsInStorage() { return OBJECT_OFFSETOF(StorageHeader, overrodeThings) - sizeof(WriteBarrier<Unknown>); }
-    static ptrdiff_t offsetOfTotalLengthInStorage() { return OBJECT_OFFSETOF(StorageHeader, totalLength) - sizeof(WriteBarrier<Unknown>); }
+    static ptrdiff_t offsetOfOverrodeThings() { return OBJECT_OFFSETOF(ScopedArguments, m_overrodeThings); }
+    static ptrdiff_t offsetOfTotalLength() { return OBJECT_OFFSETOF(ScopedArguments, m_totalLength); }
     static ptrdiff_t offsetOfTable() { return OBJECT_OFFSETOF(ScopedArguments, m_table); }
     static ptrdiff_t offsetOfScope() { return OBJECT_OFFSETOF(ScopedArguments, m_scope); }
-
-    static size_t allocationSize(size_t inlineSize)
-    {
-        RELEASE_ASSERT(!inlineSize);
-        return sizeof(ScopedArguments);
-    }
-
-    static size_t storageSize(Checked<size_t> capacity)
-    {
-        return (sizeof(WriteBarrier<Unknown>) * (capacity + static_cast<size_t>(1))).unsafeGet();
-    }
-
-    static size_t storageHeaderSize() { return sizeof(WriteBarrier<Unknown>); }
+    static ptrdiff_t offsetOfStorage() { return OBJECT_OFFSETOF(ScopedArguments, m_storage); }
 
 private:
-    struct StorageHeader {
-        unsigned totalLength;
-        bool overrodeThings; // True if length, callee, and caller are fully materialized in the object.
-    };
-
-    WriteBarrier<Unknown>* overflowStorage() const
+    WriteBarrier<Unknown>* storage() const
     {
         return m_storage.get();
     }
 
-    static StorageHeader& storageHeader(WriteBarrier<Unknown>* storage)
-    {
-        static_assert(sizeof(StorageHeader) <= sizeof(WriteBarrier<Unknown>), "StorageHeader needs to be no bigger than a JSValue");
-        return *bitwise_cast<StorageHeader*>(storage - 1);
-    }
-
-    StorageHeader& storageHeader() const
-    {
-        return storageHeader(overflowStorage());
-    }
-
+    bool m_overrodeThings { false }; // True if length, callee, and caller are fully materialized in the object.
+    unsigned m_totalLength; // The length of declared plus overflow arguments.
     WriteBarrier<JSFunction> m_callee;
     WriteBarrier<ScopedArgumentsTable> m_table;
     WriteBarrier<JSLexicalEnvironment> m_scope;
 
     AuxiliaryBarrier<WriteBarrier<Unknown>*> m_storage;

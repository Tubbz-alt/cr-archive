<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/animation/AnimationBase.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AnimationBase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSAnimationController.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/animation/AnimationBase.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 32 #include &quot;CSSPropertyBlendingClient.h&quot;
 33 #include &quot;CSSPropertyNames.h&quot;
 34 #include &quot;RenderStyleConstants.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 class CompositeAnimation;
 39 class Element;
 40 class FloatRect;
 41 class LayoutRect;
 42 class RenderElement;
 43 class RenderStyle;
 44 class TimingFunction;
 45 
 46 enum class AnimateChange {
 47     StyleBlended            = 1 &lt;&lt; 0, // Style was changed.
 48     StateChange             = 1 &lt;&lt; 1, // Animation state() changed.
 49     RunningStateChange      = 1 &lt;&lt; 2, // Animation &quot;running or paused&quot; changed.
 50 };
 51 





 52 class AnimationBase : public RefCounted&lt;AnimationBase&gt;
 53     , public CSSPropertyBlendingClient {
 54     friend class CompositeAnimation;
 55     friend class CSSPropertyAnimation;
 56     WTF_MAKE_FAST_ALLOCATED;
 57 public:
 58     AnimationBase(const Animation&amp; transition, Element&amp;, CompositeAnimation&amp;);
 59     virtual ~AnimationBase();
 60 
 61     Element* element() const { return m_element.get(); }
 62     const RenderStyle&amp; currentStyle() const override;
 63     RenderElement* renderer() const override;
 64     virtual void clear();
 65 
 66     double duration() const;
 67 
 68     // Animations and Transitions go through the states below. When entering the STARTED state
 69     // the animation is started. This may or may not require deferred response from the animator.
 70     // If so, we stay in this state until that response is received (and it returns the start time).
 71     // Otherwise, we use the current time as the start time and go immediately to AnimationState::Looping
</pre>
<hr />
<pre>
120     {
121         return m_animationState == AnimationState::New || m_animationState == AnimationState::StartWaitTimer || m_animationState == AnimationState::StartWaitStyleAvailable || m_animationState == AnimationState::StartWaitResponse;
122     }
123 
124     bool postActive() const { return m_animationState == AnimationState::Done; }
125     bool fillingForwards() const { return m_animationState == AnimationState::FillingForwards; }
126     bool active() const { return !postActive() &amp;&amp; !preActive(); }
127     bool running() const { return !isNew() &amp;&amp; !postActive(); }
128     bool paused() const { return m_pauseTime || m_animationState == AnimationState::PausedNew; }
129 
130     static bool isPausedState(AnimationState state) { return state &gt;= AnimationState::PausedNew &amp;&amp; state &lt;= AnimationState::PausedRun; }
131     static bool isRunningState(AnimationState state) { return state &gt;= AnimationState::StartWaitStyleAvailable &amp;&amp; state &lt; AnimationState::Done; }
132 
133     bool inPausedState() const { return isPausedState(m_animationState); }
134     bool inRunningState() const { return isRunningState(m_animationState); }
135 
136     bool isNew() const { return m_animationState == AnimationState::New || m_animationState == AnimationState::PausedNew; }
137     bool waitingForStartTime() const { return m_animationState == AnimationState::StartWaitResponse; }
138     bool waitingForStyleAvailable() const { return m_animationState == AnimationState::StartWaitStyleAvailable; }
139 
<span class="line-modified">140     bool isAccelerated() const override { return m_isAccelerated; }</span>
141 
142     virtual Optional&lt;Seconds&gt; timeToNextService();
143 
144     double progress(double scale = 1, double offset = 0, const TimingFunction* = nullptr) const;
145 
146     virtual void getAnimatedStyle(std::unique_ptr&lt;RenderStyle&gt;&amp; /*animatedStyle*/) = 0;
147 
148     virtual bool computeExtentOfTransformAnimation(LayoutRect&amp;) const = 0;
149 
150     virtual bool shouldFireEvents() const { return false; }
151 
152     void fireAnimationEventsIfNeeded();
153 
154     bool animationsMatch(const Animation&amp;) const;
155 
156     const Animation&amp; animation() const { return m_animation; }
157     void setAnimation(const Animation&amp; animation) { m_animation = const_cast&lt;Animation&amp;&gt;(animation); }
158 
159     // Return true if this animation is overridden. This will only be the case for
160     // ImplicitAnimations and is used to determine whether or not we should force
</pre>
</td>
<td>
<hr />
<pre>
 32 #include &quot;CSSPropertyBlendingClient.h&quot;
 33 #include &quot;CSSPropertyNames.h&quot;
 34 #include &quot;RenderStyleConstants.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 class CompositeAnimation;
 39 class Element;
 40 class FloatRect;
 41 class LayoutRect;
 42 class RenderElement;
 43 class RenderStyle;
 44 class TimingFunction;
 45 
 46 enum class AnimateChange {
 47     StyleBlended            = 1 &lt;&lt; 0, // Style was changed.
 48     StateChange             = 1 &lt;&lt; 1, // Animation state() changed.
 49     RunningStateChange      = 1 &lt;&lt; 2, // Animation &quot;running or paused&quot; changed.
 50 };
 51 
<span class="line-added"> 52 enum class AnimationImpact {</span>
<span class="line-added"> 53     RequiresRecomposite     = 1 &lt;&lt; 0,</span>
<span class="line-added"> 54     ForcesStackingContext   = 1 &lt;&lt; 1</span>
<span class="line-added"> 55 };</span>
<span class="line-added"> 56 </span>
 57 class AnimationBase : public RefCounted&lt;AnimationBase&gt;
 58     , public CSSPropertyBlendingClient {
 59     friend class CompositeAnimation;
 60     friend class CSSPropertyAnimation;
 61     WTF_MAKE_FAST_ALLOCATED;
 62 public:
 63     AnimationBase(const Animation&amp; transition, Element&amp;, CompositeAnimation&amp;);
 64     virtual ~AnimationBase();
 65 
 66     Element* element() const { return m_element.get(); }
 67     const RenderStyle&amp; currentStyle() const override;
 68     RenderElement* renderer() const override;
 69     virtual void clear();
 70 
 71     double duration() const;
 72 
 73     // Animations and Transitions go through the states below. When entering the STARTED state
 74     // the animation is started. This may or may not require deferred response from the animator.
 75     // If so, we stay in this state until that response is received (and it returns the start time).
 76     // Otherwise, we use the current time as the start time and go immediately to AnimationState::Looping
</pre>
<hr />
<pre>
125     {
126         return m_animationState == AnimationState::New || m_animationState == AnimationState::StartWaitTimer || m_animationState == AnimationState::StartWaitStyleAvailable || m_animationState == AnimationState::StartWaitResponse;
127     }
128 
129     bool postActive() const { return m_animationState == AnimationState::Done; }
130     bool fillingForwards() const { return m_animationState == AnimationState::FillingForwards; }
131     bool active() const { return !postActive() &amp;&amp; !preActive(); }
132     bool running() const { return !isNew() &amp;&amp; !postActive(); }
133     bool paused() const { return m_pauseTime || m_animationState == AnimationState::PausedNew; }
134 
135     static bool isPausedState(AnimationState state) { return state &gt;= AnimationState::PausedNew &amp;&amp; state &lt;= AnimationState::PausedRun; }
136     static bool isRunningState(AnimationState state) { return state &gt;= AnimationState::StartWaitStyleAvailable &amp;&amp; state &lt; AnimationState::Done; }
137 
138     bool inPausedState() const { return isPausedState(m_animationState); }
139     bool inRunningState() const { return isRunningState(m_animationState); }
140 
141     bool isNew() const { return m_animationState == AnimationState::New || m_animationState == AnimationState::PausedNew; }
142     bool waitingForStartTime() const { return m_animationState == AnimationState::StartWaitResponse; }
143     bool waitingForStyleAvailable() const { return m_animationState == AnimationState::StartWaitStyleAvailable; }
144 
<span class="line-modified">145     bool isAccelerated() const { return m_isAccelerated; }</span>
146 
147     virtual Optional&lt;Seconds&gt; timeToNextService();
148 
149     double progress(double scale = 1, double offset = 0, const TimingFunction* = nullptr) const;
150 
151     virtual void getAnimatedStyle(std::unique_ptr&lt;RenderStyle&gt;&amp; /*animatedStyle*/) = 0;
152 
153     virtual bool computeExtentOfTransformAnimation(LayoutRect&amp;) const = 0;
154 
155     virtual bool shouldFireEvents() const { return false; }
156 
157     void fireAnimationEventsIfNeeded();
158 
159     bool animationsMatch(const Animation&amp;) const;
160 
161     const Animation&amp; animation() const { return m_animation; }
162     void setAnimation(const Animation&amp; animation) { m_animation = const_cast&lt;Animation&amp;&gt;(animation); }
163 
164     // Return true if this animation is overridden. This will only be the case for
165     // ImplicitAnimations and is used to determine whether or not we should force
</pre>
</td>
</tr>
</table>
<center><a href="AnimationBase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSAnimationController.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
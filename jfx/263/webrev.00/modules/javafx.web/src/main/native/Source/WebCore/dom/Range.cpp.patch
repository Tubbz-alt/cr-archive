diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/Range.cpp b/modules/javafx.web/src/main/native/Source/WebCore/dom/Range.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/Range.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/Range.cpp
@@ -474,31 +474,25 @@
 ExceptionOr<bool> Range::intersectsNode(Node& refNode) const
 {
     if (!refNode.isConnected() || &refNode.document() != &ownerDocument())
         return false;
 
-    ContainerNode* parentNode = refNode.parentNode();
+    auto* parentNode = refNode.parentNode();
     if (!parentNode)
         return true;
 
     unsigned nodeIndex = refNode.computeNodeIndex();
 
-    // If (parent, offset) is before end and (parent, offset + 1) is after start, return true.
+    // If (parentNode, nodeIndex) is before end and (parentNode, nodeIndex + 1) is after start, return true.
     // Otherwise, return false.
-    auto result = comparePoint(*parentNode, nodeIndex);
-    if (result.hasException())
-        return result.releaseException();
-    auto compareFirst = result.releaseReturnValue();
-    result = comparePoint(*parentNode, nodeIndex + 1);
-    if (result.hasException())
-        return result.releaseException();
-    auto compareSecond = result.releaseReturnValue();
-
-    bool isFirstBeforeEnd = m_start == m_end ? compareFirst < 0 : compareFirst <= 0;
-    bool isSecondAfterStart = m_start == m_end ? compareSecond > 0 : compareSecond >= 0;
-
-    return isFirstBeforeEnd && isSecondAfterStart;
+    auto compareEndResult = compareBoundaryPoints(parentNode, nodeIndex, m_end.container(), m_end.offset());
+    if (compareEndResult.hasException())
+        return compareEndResult.releaseException();
+    auto compareStartResult = compareBoundaryPoints(parentNode, nodeIndex + 1, m_start.container(), m_start.offset());
+    if (compareStartResult.hasException())
+        return compareStartResult.releaseException();
+    return compareEndResult.returnValue() == -1 && compareStartResult.returnValue() == 1;
 }
 
 static inline Node* highestAncestorUnderCommonRoot(Node* node, Node* commonRoot)
 {
     if (node == commonRoot)
@@ -940,15 +934,13 @@
 
     Node* pastLast = pastLastNode();
     for (Node* node = firstNode(); node != pastLast; node = NodeTraversal::next(*node)) {
         auto type = node->nodeType();
         if (type == Node::TEXT_NODE || type == Node::CDATA_SECTION_NODE) {
-            auto& data = downcast<CharacterData>(*node).data();
-            unsigned length = data.length();
-            unsigned start = node == &startContainer() ? std::min(m_start.offset(), length) : 0U;
-            unsigned end = node == &endContainer() ? std::min(std::max(start, m_end.offset()), length) : length;
-            builder.appendSubstring(data, start, end - start);
+            unsigned start = node == &startContainer() ? m_start.offset() : 0U;
+            unsigned end = node == &endContainer() ? std::max(start, m_end.offset()) : std::numeric_limits<unsigned>::max();
+            builder.appendSubstring(downcast<CharacterData>(*node).data(), start, end - start);
         }
     }
 
     return builder.toString();
 }
@@ -1149,26 +1141,28 @@
     if (Node* child = endContainer().traverseToChildAt(m_end.offset()))
         return child;
     return NodeTraversal::nextSkippingChildren(endContainer());
 }
 
-IntRect Range::absoluteBoundingBox() const
+IntRect Range::absoluteBoundingBox(OptionSet<BoundingRectBehavior> rectOptions) const
 {
     IntRect result;
     Vector<IntRect> rects;
-    absoluteTextRects(rects);
+    bool useSelectionHeight = false;
+    RangeInFixedPosition* inFixed = nullptr;
+    absoluteTextRects(rects, useSelectionHeight, inFixed, rectOptions);
     for (auto& rect : rects)
         result.unite(rect);
     return result;
 }
 
 Vector<FloatRect> Range::absoluteRectsForRangeInText(Node* node, RenderText& renderText, bool useSelectionHeight, bool& isFixed, OptionSet<BoundingRectBehavior> rectOptions) const
 {
     unsigned startOffset = node == &startContainer() ? m_start.offset() : 0;
     unsigned endOffset = node == &endContainer() ? m_end.offset() : std::numeric_limits<unsigned>::max();
 
-    auto textQuads = renderText.absoluteQuadsForRange(startOffset, endOffset, useSelectionHeight, &isFixed);
+    auto textQuads = renderText.absoluteQuadsForRange(startOffset, endOffset, useSelectionHeight, rectOptions.contains(BoundingRectBehavior::IgnoreEmptyTextSelections), &isFixed);
 
     if (rectOptions.contains(BoundingRectBehavior::RespectClipping)) {
         Vector<FloatRect> clippedRects;
         clippedRects.reserveInitialCapacity(textQuads.size());
 
@@ -1233,11 +1227,11 @@
         if (renderer->isBR())
             renderer->absoluteQuads(quads, &isFixed);
         else if (is<RenderText>(*renderer)) {
             unsigned startOffset = node == &startContainer() ? m_start.offset() : 0;
             unsigned endOffset = node == &endContainer() ? m_end.offset() : std::numeric_limits<unsigned>::max();
-            quads.appendVector(downcast<RenderText>(*renderer).absoluteQuadsForRange(startOffset, endOffset, useSelectionHeight, &isFixed));
+            quads.appendVector(downcast<RenderText>(*renderer).absoluteQuadsForRange(startOffset, endOffset, useSelectionHeight, false /* ignoreEmptyTextSelections */, &isFixed));
         } else
             continue;
         allFixed &= isFixed;
         someFixed |= isFixed;
     }
@@ -1571,11 +1565,11 @@
         return false;
 
     if (a == b)
         return true;
 
-    if (a->commonAncestorContainer()->ownerDocument() != b->commonAncestorContainer()->ownerDocument())
+    if (!areNodesConnectedInSameTreeScope(a->commonAncestorContainer(), b->commonAncestorContainer()))
         return false;
 
     short startToStart = a->compareBoundaryPoints(Range::START_TO_START, *b).releaseReturnValue();
     short endToEnd = a->compareBoundaryPoints(Range::END_TO_END, *b).releaseReturnValue();
 

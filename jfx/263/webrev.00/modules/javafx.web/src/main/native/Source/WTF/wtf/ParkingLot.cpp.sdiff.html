<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/ParkingLot.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PageBlock.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Platform.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/ParkingLot.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
338 {
339     // We try to ensure that the size of the hashtable used for thread queues is always large enough
340     // to avoid collisions. So, since we started a new thread, we may need to increase the size of the
341     // hashtable. This does just that. Note that we never free the old spine, since we never lock
342     // around spine accesses (i.e. the &quot;hashtable&quot; global variable).
343 
344     // First do a fast check to see if rehashing is needed.
345     Hashtable* oldHashtable = hashtable.load();
346     if (oldHashtable &amp;&amp; static_cast&lt;double&gt;(oldHashtable-&gt;size) / static_cast&lt;double&gt;(numThreads) &gt;= maxLoadFactor) {
347         if (verbose)
348             dataLog(toString(Thread::current(), &quot;: no need to rehash because &quot;, oldHashtable-&gt;size, &quot; / &quot;, numThreads, &quot; &gt;= &quot;, maxLoadFactor, &quot;\n&quot;));
349         return;
350     }
351 
352     // Seems like we *might* have to rehash, so lock the hashtable and try again.
353     Vector&lt;Bucket*&gt; bucketsToUnlock = lockHashtable();
354 
355     // Check again, since the hashtable could have rehashed while we were locking it. Also,
356     // lockHashtable() creates an initial hashtable for us.
357     oldHashtable = hashtable.load();
<span class="line-modified">358     if (oldHashtable &amp;&amp; static_cast&lt;double&gt;(oldHashtable-&gt;size) / static_cast&lt;double&gt;(numThreads) &gt;= maxLoadFactor) {</span>

359         if (verbose)
360             dataLog(toString(Thread::current(), &quot;: after locking, no need to rehash because &quot;, oldHashtable-&gt;size, &quot; / &quot;, numThreads, &quot; &gt;= &quot;, maxLoadFactor, &quot;\n&quot;));
361         unlockHashtable(bucketsToUnlock);
362         return;
363     }
364 
365     Vector&lt;Bucket*&gt; reusableBuckets = bucketsToUnlock;
366 
367     // OK, now we resize. First we gather all thread datas from the old hashtable. These thread datas
368     // are placed into the vector in queue order.
369     Vector&lt;ThreadData*&gt; threadDatas;
370     for (Bucket* bucket : reusableBuckets) {
371         while (ThreadData* threadData = bucket-&gt;dequeue())
372             threadDatas.append(threadData);
373     }
374 
375     unsigned newSize = numThreads * growthFactor * maxLoadFactor;
376     RELEASE_ASSERT(newSize &gt; oldHashtable-&gt;size);
377 
378     Hashtable* newHashtable = Hashtable::create(newSize);
</pre>
</td>
<td>
<hr />
<pre>
338 {
339     // We try to ensure that the size of the hashtable used for thread queues is always large enough
340     // to avoid collisions. So, since we started a new thread, we may need to increase the size of the
341     // hashtable. This does just that. Note that we never free the old spine, since we never lock
342     // around spine accesses (i.e. the &quot;hashtable&quot; global variable).
343 
344     // First do a fast check to see if rehashing is needed.
345     Hashtable* oldHashtable = hashtable.load();
346     if (oldHashtable &amp;&amp; static_cast&lt;double&gt;(oldHashtable-&gt;size) / static_cast&lt;double&gt;(numThreads) &gt;= maxLoadFactor) {
347         if (verbose)
348             dataLog(toString(Thread::current(), &quot;: no need to rehash because &quot;, oldHashtable-&gt;size, &quot; / &quot;, numThreads, &quot; &gt;= &quot;, maxLoadFactor, &quot;\n&quot;));
349         return;
350     }
351 
352     // Seems like we *might* have to rehash, so lock the hashtable and try again.
353     Vector&lt;Bucket*&gt; bucketsToUnlock = lockHashtable();
354 
355     // Check again, since the hashtable could have rehashed while we were locking it. Also,
356     // lockHashtable() creates an initial hashtable for us.
357     oldHashtable = hashtable.load();
<span class="line-modified">358     RELEASE_ASSERT(oldHashtable);</span>
<span class="line-added">359     if (static_cast&lt;double&gt;(oldHashtable-&gt;size) / static_cast&lt;double&gt;(numThreads) &gt;= maxLoadFactor) {</span>
360         if (verbose)
361             dataLog(toString(Thread::current(), &quot;: after locking, no need to rehash because &quot;, oldHashtable-&gt;size, &quot; / &quot;, numThreads, &quot; &gt;= &quot;, maxLoadFactor, &quot;\n&quot;));
362         unlockHashtable(bucketsToUnlock);
363         return;
364     }
365 
366     Vector&lt;Bucket*&gt; reusableBuckets = bucketsToUnlock;
367 
368     // OK, now we resize. First we gather all thread datas from the old hashtable. These thread datas
369     // are placed into the vector in queue order.
370     Vector&lt;ThreadData*&gt; threadDatas;
371     for (Bucket* bucket : reusableBuckets) {
372         while (ThreadData* threadData = bucket-&gt;dequeue())
373             threadDatas.append(threadData);
374     }
375 
376     unsigned newSize = numThreads * growthFactor * maxLoadFactor;
377     RELEASE_ASSERT(newSize &gt; oldHashtable-&gt;size);
378 
379     Hashtable* newHashtable = Hashtable::create(newSize);
</pre>
</td>
</tr>
</table>
<center><a href="PageBlock.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Platform.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
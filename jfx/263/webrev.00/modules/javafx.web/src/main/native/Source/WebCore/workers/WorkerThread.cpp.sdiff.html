<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerThread.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WorkerScriptLoader.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WorkerThread.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerThread.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  *
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;WorkerThread.h&quot;
 29 
<span class="line-removed"> 30 #include &quot;ContentSecurityPolicyResponseHeaders.h&quot;</span>
 31 #include &quot;IDBConnectionProxy.h&quot;
 32 #include &quot;ScriptSourceCode.h&quot;
 33 #include &quot;SecurityOrigin.h&quot;
 34 #include &quot;SocketProvider.h&quot;
 35 #include &quot;ThreadGlobalData.h&quot;
<span class="line-removed"> 36 #include &lt;wtf/URL.h&gt;</span>
 37 #include &quot;WorkerGlobalScope.h&quot;
 38 #include &quot;WorkerInspectorController.h&quot;
 39 #include &lt;utility&gt;
 40 #include &lt;wtf/Lock.h&gt;
 41 #include &lt;wtf/NeverDestroyed.h&gt;
 42 #include &lt;wtf/Noncopyable.h&gt;
 43 #include &lt;wtf/text/WTFString.h&gt;
 44 
 45 #if PLATFORM(IOS_FAMILY)
 46 #include &quot;FloatingPointEnvironment.h&quot;
 47 #include &quot;WebCoreThread.h&quot;
 48 #endif
 49 
 50 #if PLATFORM(JAVA)
 51 #include &lt;wtf/java/JavaEnv.h&gt;
 52 #endif
 53 
 54 #if USE(GLIB)
 55 #include &lt;wtf/glib/GRefPtr.h&gt;
 56 #endif
</pre>
<hr />
<pre>
 58 namespace WebCore {
 59 
 60 HashSet&lt;WorkerThread*&gt;&amp; WorkerThread::workerThreads(const LockHolder&amp;)
 61 {
 62     static NeverDestroyed&lt;HashSet&lt;WorkerThread*&gt;&gt; workerThreads;
 63     return workerThreads;
 64 }
 65 
 66 Lock&amp; WorkerThread::workerThreadsMutex()
 67 {
 68     static Lock mutex;
 69     return mutex;
 70 }
 71 
 72 unsigned WorkerThread::workerThreadCount()
 73 {
 74     LockHolder lock(workerThreadsMutex());
 75     return workerThreads(lock).size();
 76 }
 77 















 78 struct WorkerThreadStartupData {
 79     WTF_MAKE_NONCOPYABLE(WorkerThreadStartupData); WTF_MAKE_FAST_ALLOCATED;
 80 public:
<span class="line-modified"> 81     WorkerThreadStartupData(const URL&amp; scriptURL, const String&amp; name, const String&amp; identifier, const String&amp; userAgent, bool isOnline, const String&amp; sourceCode, WorkerThreadStartMode, const ContentSecurityPolicyResponseHeaders&amp;, bool shouldBypassMainWorldContentSecurityPolicy, const SecurityOrigin&amp; topOrigin, MonotonicTime timeOrigin, PAL::SessionID);</span>
<span class="line-modified"> 82 </span>
<span class="line-modified"> 83     URL m_scriptURL;</span>
<span class="line-modified"> 84     Ref&lt;SecurityOrigin&gt; m_origin;</span>
<span class="line-modified"> 85     String m_name;</span>
<span class="line-modified"> 86     String m_identifier;</span>
<span class="line-modified"> 87     String m_userAgent;</span>
<span class="line-removed"> 88     String m_sourceCode;</span>
<span class="line-removed"> 89     WorkerThreadStartMode m_startMode;</span>
<span class="line-removed"> 90     ContentSecurityPolicyResponseHeaders m_contentSecurityPolicyResponseHeaders;</span>
<span class="line-removed"> 91     bool m_shouldBypassMainWorldContentSecurityPolicy;</span>
<span class="line-removed"> 92     bool m_isOnline;</span>
<span class="line-removed"> 93     Ref&lt;SecurityOrigin&gt; m_topOrigin;</span>
<span class="line-removed"> 94     MonotonicTime m_timeOrigin;</span>
<span class="line-removed"> 95     PAL::SessionID m_sessionID;</span>
 96 };
 97 
<span class="line-modified"> 98 WorkerThreadStartupData::WorkerThreadStartupData(const URL&amp; scriptURL, const String&amp; name, const String&amp; identifier, const String&amp; userAgent, bool isOnline, const String&amp; sourceCode, WorkerThreadStartMode startMode, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicyResponseHeaders, bool shouldBypassMainWorldContentSecurityPolicy, const SecurityOrigin&amp; topOrigin, MonotonicTime timeOrigin, PAL::SessionID sessionID)</span>
<span class="line-modified"> 99     : m_scriptURL(scriptURL.isolatedCopy())</span>
<span class="line-modified">100     , m_origin(SecurityOrigin::create(m_scriptURL)-&gt;isolatedCopy())</span>
<span class="line-modified">101     , m_name(name.isolatedCopy())</span>
<span class="line-modified">102     , m_identifier(identifier.isolatedCopy())</span>
<span class="line-modified">103     , m_userAgent(userAgent.isolatedCopy())</span>
<span class="line-removed">104     , m_sourceCode(sourceCode.isolatedCopy())</span>
<span class="line-removed">105     , m_startMode(startMode)</span>
<span class="line-removed">106     , m_contentSecurityPolicyResponseHeaders(contentSecurityPolicyResponseHeaders.isolatedCopy())</span>
<span class="line-removed">107     , m_shouldBypassMainWorldContentSecurityPolicy(shouldBypassMainWorldContentSecurityPolicy)</span>
<span class="line-removed">108     , m_isOnline(isOnline)</span>
<span class="line-removed">109     , m_topOrigin(topOrigin.isolatedCopy())</span>
<span class="line-removed">110     , m_timeOrigin(timeOrigin)</span>
<span class="line-removed">111     , m_sessionID(sessionID.isolatedCopy())</span>
112 {
113 }
114 
<span class="line-modified">115 WorkerThread::WorkerThread(const URL&amp; scriptURL, const String&amp; name, const String&amp; identifier, const String&amp; userAgent, bool isOnline, const String&amp; sourceCode, WorkerLoaderProxy&amp; workerLoaderProxy, WorkerDebuggerProxy&amp; workerDebuggerProxy, WorkerReportingProxy&amp; workerReportingProxy, WorkerThreadStartMode startMode, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicyResponseHeaders, bool shouldBypassMainWorldContentSecurityPolicy, const SecurityOrigin&amp; topOrigin, MonotonicTime timeOrigin, IDBClient::IDBConnectionProxy* connectionProxy, SocketProvider* socketProvider, JSC::RuntimeFlags runtimeFlags, PAL::SessionID sessionID)</span>
<span class="line-modified">116     : m_identifier(identifier.isolatedCopy())</span>
117     , m_workerLoaderProxy(workerLoaderProxy)
118     , m_workerDebuggerProxy(workerDebuggerProxy)
119     , m_workerReportingProxy(workerReportingProxy)
120     , m_runtimeFlags(runtimeFlags)
<span class="line-modified">121     , m_startupData(makeUnique&lt;WorkerThreadStartupData&gt;(scriptURL, name, identifier, userAgent, isOnline, sourceCode, startMode, contentSecurityPolicyResponseHeaders, shouldBypassMainWorldContentSecurityPolicy, topOrigin, timeOrigin, sessionID))</span>
122 #if ENABLE(INDEXED_DATABASE)
123     , m_idbConnectionProxy(connectionProxy)
124 #endif
125     , m_socketProvider(socketProvider)
126 {
127 #if !ENABLE(INDEXED_DATABASE)
128     UNUSED_PARAM(connectionProxy);
129 #endif
130 
131     LockHolder lock(workerThreadsMutex());
132     workerThreads(lock).add(this);
133 }
134 
135 WorkerThread::~WorkerThread()
136 {
137     LockHolder lock(workerThreadsMutex());
138     ASSERT(workerThreads(lock).contains(this));
139     workerThreads(lock).remove(this);
140 }
141 
</pre>
<hr />
<pre>
160     WTF::AttachThreadAsDaemonToJavaEnv autoAttach;
161 #endif
162     auto protectedThis = makeRef(*this);
163 
164     // Propagate the mainThread&#39;s fenv to workers.
165 #if PLATFORM(IOS_FAMILY)
166     FloatingPointEnvironment::singleton().propagateMainThreadEnvironment();
167 #endif
168 
169 #if USE(GLIB)
170     GRefPtr&lt;GMainContext&gt; mainContext = adoptGRef(g_main_context_new());
171     g_main_context_push_thread_default(mainContext.get());
172 #endif
173 
174     WorkerScriptController* scriptController;
175     {
176         // Mutex protection is necessary to ensure that we don&#39;t change m_workerGlobalScope
177         // while WorkerThread::stop() is accessing it. Note that WorkerThread::stop() can
178         // be called before we&#39;ve finished creating the WorkerGlobalScope.
179         LockHolder lock(m_threadCreationAndWorkerGlobalScopeMutex);
<span class="line-modified">180         m_workerGlobalScope = createWorkerGlobalScope(m_startupData-&gt;m_scriptURL, WTFMove(m_startupData-&gt;m_origin), m_startupData-&gt;m_name, m_startupData-&gt;m_identifier, m_startupData-&gt;m_userAgent, m_startupData-&gt;m_isOnline, m_startupData-&gt;m_contentSecurityPolicyResponseHeaders, m_startupData-&gt;m_shouldBypassMainWorldContentSecurityPolicy, WTFMove(m_startupData-&gt;m_topOrigin), m_startupData-&gt;m_timeOrigin, m_startupData-&gt;m_sessionID);</span>
181 
182         scriptController = m_workerGlobalScope-&gt;script();
183 
184         if (m_runLoop.terminated()) {
185             // The worker was terminated before the thread had a chance to run. Since the context didn&#39;t exist yet,
186             // forbidExecution() couldn&#39;t be called from stop().
187             scriptController-&gt;scheduleExecutionTermination();
188             scriptController-&gt;forbidExecution();
189         }
190     }
191 
<span class="line-modified">192     if (m_startupData-&gt;m_startMode == WorkerThreadStartMode::WaitForInspector) {</span>
193         startRunningDebuggerTasks();
194 
195         // If the worker was somehow terminated while processing debugger commands.
196         if (m_runLoop.terminated())
197             scriptController-&gt;forbidExecution();
198     }
199 
200     String exceptionMessage;
<span class="line-modified">201     scriptController-&gt;evaluate(ScriptSourceCode(m_startupData-&gt;m_sourceCode, URL(m_startupData-&gt;m_scriptURL)), &amp;exceptionMessage);</span>


202 
203     callOnMainThread([evaluateCallback = WTFMove(m_evaluateCallback), message = exceptionMessage.isolatedCopy()] {
204         if (evaluateCallback)
205             evaluateCallback(message);
206     });
207 
208     // Free the startup data to cause its member variable deref&#39;s happen on the worker&#39;s thread (since
209     // all ref/derefs of these objects are happening on the thread at this point). Note that
210     // WorkerThread::~WorkerThread happens on a different thread where it was created.
211     m_startupData = nullptr;
212 
213     runEventLoop();
214 
215 #if USE(GLIB)
216     g_main_context_pop_thread_default(mainContext.get());
217 #endif
218 
219     RefPtr&lt;Thread&gt; protector = m_thread;
220 
221     ASSERT(m_workerGlobalScope-&gt;hasOneRef());
</pre>
<hr />
<pre>
255     ASSERT(!m_pausedForDebugger);
256     m_pausedForDebugger = true;
257 
258     MessageQueueWaitResult result;
259     do {
260         result = m_runLoop.runInDebuggerMode(*m_workerGlobalScope);
261     } while (result != MessageQueueTerminated &amp;&amp; m_pausedForDebugger);
262 }
263 
264 void WorkerThread::stopRunningDebuggerTasks()
265 {
266     m_pausedForDebugger = false;
267 }
268 
269 void WorkerThread::runEventLoop()
270 {
271     // Does not return until terminated.
272     m_runLoop.run(m_workerGlobalScope.get());
273 }
274 

























275 void WorkerThread::stop(WTF::Function&lt;void()&gt;&amp;&amp; stoppedCallback)
276 {
277     // Mutex protection is necessary to ensure that m_workerGlobalScope isn&#39;t changed by
278     // WorkerThread::workerThread() while we&#39;re accessing it. Note also that stop() can
279     // be called before m_workerGlobalScope is fully created.
280     auto locker = Locker&lt;Lock&gt;::tryLock(m_threadCreationAndWorkerGlobalScopeMutex);
281     if (!locker) {
282         // The thread is still starting, spin the runloop and try again to avoid deadlocks if the worker thread
283         // needs to interact with the main thread during startup.
284         callOnMainThread([this, stoppedCallback = WTFMove(stoppedCallback)]() mutable {
285             stop(WTFMove(stoppedCallback));
286         });
287         return;
288     }
289 




290     ASSERT(!m_stoppedCallback);
291     m_stoppedCallback = WTFMove(stoppedCallback);
292 
293     // Ensure that tasks are being handled by thread event loop. If script execution weren&#39;t forbidden, a while(1) loop in JS could keep the thread alive forever.
294     if (m_workerGlobalScope) {
295         m_workerGlobalScope-&gt;script()-&gt;scheduleExecutionTermination();
296 
297         m_runLoop.postTaskAndTerminate({ ScriptExecutionContext::Task::CleanupTask, [] (ScriptExecutionContext&amp; context ) {
298             WorkerGlobalScope&amp; workerGlobalScope = downcast&lt;WorkerGlobalScope&gt;(context);
299 
300             workerGlobalScope.prepareForTermination();
301 
302             // Stick a shutdown command at the end of the queue, so that we deal
303             // with all the cleanup tasks the databases post first.
304             workerGlobalScope.postTask({ ScriptExecutionContext::Task::CleanupTask, [] (ScriptExecutionContext&amp; context) {
305                 WorkerGlobalScope&amp; workerGlobalScope = downcast&lt;WorkerGlobalScope&gt;(context);
306                 // It&#39;s not safe to call clearScript until all the cleanup tasks posted by functions initiated by WorkerThreadShutdownStartTask have completed.
307                 workerGlobalScope.clearScript();
308             } });
309 
</pre>
</td>
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  *
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;WorkerThread.h&quot;
 29 

 30 #include &quot;IDBConnectionProxy.h&quot;
 31 #include &quot;ScriptSourceCode.h&quot;
 32 #include &quot;SecurityOrigin.h&quot;
 33 #include &quot;SocketProvider.h&quot;
 34 #include &quot;ThreadGlobalData.h&quot;

 35 #include &quot;WorkerGlobalScope.h&quot;
 36 #include &quot;WorkerInspectorController.h&quot;
 37 #include &lt;utility&gt;
 38 #include &lt;wtf/Lock.h&gt;
 39 #include &lt;wtf/NeverDestroyed.h&gt;
 40 #include &lt;wtf/Noncopyable.h&gt;
 41 #include &lt;wtf/text/WTFString.h&gt;
 42 
 43 #if PLATFORM(IOS_FAMILY)
 44 #include &quot;FloatingPointEnvironment.h&quot;
 45 #include &quot;WebCoreThread.h&quot;
 46 #endif
 47 
 48 #if PLATFORM(JAVA)
 49 #include &lt;wtf/java/JavaEnv.h&gt;
 50 #endif
 51 
 52 #if USE(GLIB)
 53 #include &lt;wtf/glib/GRefPtr.h&gt;
 54 #endif
</pre>
<hr />
<pre>
 56 namespace WebCore {
 57 
 58 HashSet&lt;WorkerThread*&gt;&amp; WorkerThread::workerThreads(const LockHolder&amp;)
 59 {
 60     static NeverDestroyed&lt;HashSet&lt;WorkerThread*&gt;&gt; workerThreads;
 61     return workerThreads;
 62 }
 63 
 64 Lock&amp; WorkerThread::workerThreadsMutex()
 65 {
 66     static Lock mutex;
 67     return mutex;
 68 }
 69 
 70 unsigned WorkerThread::workerThreadCount()
 71 {
 72     LockHolder lock(workerThreadsMutex());
 73     return workerThreads(lock).size();
 74 }
 75 
<span class="line-added"> 76 WorkerParameters WorkerParameters::isolatedCopy() const</span>
<span class="line-added"> 77 {</span>
<span class="line-added"> 78     return {</span>
<span class="line-added"> 79         scriptURL.isolatedCopy(),</span>
<span class="line-added"> 80         name.isolatedCopy(),</span>
<span class="line-added"> 81         identifier.isolatedCopy(),</span>
<span class="line-added"> 82         userAgent.isolatedCopy(),</span>
<span class="line-added"> 83         isOnline,</span>
<span class="line-added"> 84         contentSecurityPolicyResponseHeaders,</span>
<span class="line-added"> 85         shouldBypassMainWorldContentSecurityPolicy,</span>
<span class="line-added"> 86         timeOrigin,</span>
<span class="line-added"> 87         referrerPolicy,</span>
<span class="line-added"> 88     };</span>
<span class="line-added"> 89 }</span>
<span class="line-added"> 90 </span>
 91 struct WorkerThreadStartupData {
 92     WTF_MAKE_NONCOPYABLE(WorkerThreadStartupData); WTF_MAKE_FAST_ALLOCATED;
 93 public:
<span class="line-modified"> 94     WorkerThreadStartupData(const WorkerParameters&amp; params, const String&amp; sourceCode, WorkerThreadStartMode, const SecurityOrigin&amp; topOrigin);</span>
<span class="line-modified"> 95 </span>
<span class="line-modified"> 96     WorkerParameters params;</span>
<span class="line-modified"> 97     Ref&lt;SecurityOrigin&gt; origin;</span>
<span class="line-modified"> 98     String sourceCode;</span>
<span class="line-modified"> 99     WorkerThreadStartMode startMode;</span>
<span class="line-modified">100     Ref&lt;SecurityOrigin&gt; topOrigin;</span>








101 };
102 
<span class="line-modified">103 WorkerThreadStartupData::WorkerThreadStartupData(const WorkerParameters&amp; other, const String&amp; sourceCode, WorkerThreadStartMode startMode, const SecurityOrigin&amp; topOrigin)</span>
<span class="line-modified">104     : params(other.isolatedCopy())</span>
<span class="line-modified">105     , origin(SecurityOrigin::create(other.scriptURL)-&gt;isolatedCopy())</span>
<span class="line-modified">106     , sourceCode(sourceCode.isolatedCopy())</span>
<span class="line-modified">107     , startMode(startMode)</span>
<span class="line-modified">108     , topOrigin(topOrigin.isolatedCopy())</span>








109 {
110 }
111 
<span class="line-modified">112 WorkerThread::WorkerThread(const WorkerParameters&amp; params, const String&amp; sourceCode, WorkerLoaderProxy&amp; workerLoaderProxy, WorkerDebuggerProxy&amp; workerDebuggerProxy, WorkerReportingProxy&amp; workerReportingProxy, WorkerThreadStartMode startMode, const SecurityOrigin&amp; topOrigin, IDBClient::IDBConnectionProxy* connectionProxy, SocketProvider* socketProvider, JSC::RuntimeFlags runtimeFlags)</span>
<span class="line-modified">113     : m_identifier(params.identifier.isolatedCopy())</span>
114     , m_workerLoaderProxy(workerLoaderProxy)
115     , m_workerDebuggerProxy(workerDebuggerProxy)
116     , m_workerReportingProxy(workerReportingProxy)
117     , m_runtimeFlags(runtimeFlags)
<span class="line-modified">118     , m_startupData(makeUnique&lt;WorkerThreadStartupData&gt;(params, sourceCode, startMode, topOrigin))</span>
119 #if ENABLE(INDEXED_DATABASE)
120     , m_idbConnectionProxy(connectionProxy)
121 #endif
122     , m_socketProvider(socketProvider)
123 {
124 #if !ENABLE(INDEXED_DATABASE)
125     UNUSED_PARAM(connectionProxy);
126 #endif
127 
128     LockHolder lock(workerThreadsMutex());
129     workerThreads(lock).add(this);
130 }
131 
132 WorkerThread::~WorkerThread()
133 {
134     LockHolder lock(workerThreadsMutex());
135     ASSERT(workerThreads(lock).contains(this));
136     workerThreads(lock).remove(this);
137 }
138 
</pre>
<hr />
<pre>
157     WTF::AttachThreadAsDaemonToJavaEnv autoAttach;
158 #endif
159     auto protectedThis = makeRef(*this);
160 
161     // Propagate the mainThread&#39;s fenv to workers.
162 #if PLATFORM(IOS_FAMILY)
163     FloatingPointEnvironment::singleton().propagateMainThreadEnvironment();
164 #endif
165 
166 #if USE(GLIB)
167     GRefPtr&lt;GMainContext&gt; mainContext = adoptGRef(g_main_context_new());
168     g_main_context_push_thread_default(mainContext.get());
169 #endif
170 
171     WorkerScriptController* scriptController;
172     {
173         // Mutex protection is necessary to ensure that we don&#39;t change m_workerGlobalScope
174         // while WorkerThread::stop() is accessing it. Note that WorkerThread::stop() can
175         // be called before we&#39;ve finished creating the WorkerGlobalScope.
176         LockHolder lock(m_threadCreationAndWorkerGlobalScopeMutex);
<span class="line-modified">177         m_workerGlobalScope = createWorkerGlobalScope(m_startupData-&gt;params, WTFMove(m_startupData-&gt;origin), WTFMove(m_startupData-&gt;topOrigin));</span>
178 
179         scriptController = m_workerGlobalScope-&gt;script();
180 
181         if (m_runLoop.terminated()) {
182             // The worker was terminated before the thread had a chance to run. Since the context didn&#39;t exist yet,
183             // forbidExecution() couldn&#39;t be called from stop().
184             scriptController-&gt;scheduleExecutionTermination();
185             scriptController-&gt;forbidExecution();
186         }
187     }
188 
<span class="line-modified">189     if (m_startupData-&gt;startMode == WorkerThreadStartMode::WaitForInspector) {</span>
190         startRunningDebuggerTasks();
191 
192         // If the worker was somehow terminated while processing debugger commands.
193         if (m_runLoop.terminated())
194             scriptController-&gt;forbidExecution();
195     }
196 
197     String exceptionMessage;
<span class="line-modified">198     scriptController-&gt;evaluate(ScriptSourceCode(m_startupData-&gt;sourceCode, URL(m_startupData-&gt;params.scriptURL)), &amp;exceptionMessage);</span>
<span class="line-added">199 </span>
<span class="line-added">200     finishedEvaluatingScript();</span>
201 
202     callOnMainThread([evaluateCallback = WTFMove(m_evaluateCallback), message = exceptionMessage.isolatedCopy()] {
203         if (evaluateCallback)
204             evaluateCallback(message);
205     });
206 
207     // Free the startup data to cause its member variable deref&#39;s happen on the worker&#39;s thread (since
208     // all ref/derefs of these objects are happening on the thread at this point). Note that
209     // WorkerThread::~WorkerThread happens on a different thread where it was created.
210     m_startupData = nullptr;
211 
212     runEventLoop();
213 
214 #if USE(GLIB)
215     g_main_context_pop_thread_default(mainContext.get());
216 #endif
217 
218     RefPtr&lt;Thread&gt; protector = m_thread;
219 
220     ASSERT(m_workerGlobalScope-&gt;hasOneRef());
</pre>
<hr />
<pre>
254     ASSERT(!m_pausedForDebugger);
255     m_pausedForDebugger = true;
256 
257     MessageQueueWaitResult result;
258     do {
259         result = m_runLoop.runInDebuggerMode(*m_workerGlobalScope);
260     } while (result != MessageQueueTerminated &amp;&amp; m_pausedForDebugger);
261 }
262 
263 void WorkerThread::stopRunningDebuggerTasks()
264 {
265     m_pausedForDebugger = false;
266 }
267 
268 void WorkerThread::runEventLoop()
269 {
270     // Does not return until terminated.
271     m_runLoop.run(m_workerGlobalScope.get());
272 }
273 
<span class="line-added">274 void WorkerThread::suspend()</span>
<span class="line-added">275 {</span>
<span class="line-added">276     m_isSuspended = true;</span>
<span class="line-added">277     runLoop().postTask([&amp;](ScriptExecutionContext&amp;) {</span>
<span class="line-added">278 #if ENABLE(INDEXED_DATABASE)</span>
<span class="line-added">279         if (m_workerGlobalScope)</span>
<span class="line-added">280             m_workerGlobalScope-&gt;suspend();</span>
<span class="line-added">281 #endif</span>
<span class="line-added">282 </span>
<span class="line-added">283         m_suspensionSemaphore.wait();</span>
<span class="line-added">284 </span>
<span class="line-added">285 #if ENABLE(INDEXED_DATABASE)</span>
<span class="line-added">286         if (m_workerGlobalScope)</span>
<span class="line-added">287             m_workerGlobalScope-&gt;resume();</span>
<span class="line-added">288 #endif</span>
<span class="line-added">289     });</span>
<span class="line-added">290 }</span>
<span class="line-added">291 </span>
<span class="line-added">292 void WorkerThread::resume()</span>
<span class="line-added">293 {</span>
<span class="line-added">294     ASSERT(m_isSuspended);</span>
<span class="line-added">295     m_isSuspended = false;</span>
<span class="line-added">296     m_suspensionSemaphore.signal();</span>
<span class="line-added">297 }</span>
<span class="line-added">298 </span>
299 void WorkerThread::stop(WTF::Function&lt;void()&gt;&amp;&amp; stoppedCallback)
300 {
301     // Mutex protection is necessary to ensure that m_workerGlobalScope isn&#39;t changed by
302     // WorkerThread::workerThread() while we&#39;re accessing it. Note also that stop() can
303     // be called before m_workerGlobalScope is fully created.
304     auto locker = Locker&lt;Lock&gt;::tryLock(m_threadCreationAndWorkerGlobalScopeMutex);
305     if (!locker) {
306         // The thread is still starting, spin the runloop and try again to avoid deadlocks if the worker thread
307         // needs to interact with the main thread during startup.
308         callOnMainThread([this, stoppedCallback = WTFMove(stoppedCallback)]() mutable {
309             stop(WTFMove(stoppedCallback));
310         });
311         return;
312     }
313 
<span class="line-added">314     // If the thread is suspended, resume it now so that we can dispatch the cleanup tasks below.</span>
<span class="line-added">315     if (m_isSuspended)</span>
<span class="line-added">316         resume();</span>
<span class="line-added">317 </span>
318     ASSERT(!m_stoppedCallback);
319     m_stoppedCallback = WTFMove(stoppedCallback);
320 
321     // Ensure that tasks are being handled by thread event loop. If script execution weren&#39;t forbidden, a while(1) loop in JS could keep the thread alive forever.
322     if (m_workerGlobalScope) {
323         m_workerGlobalScope-&gt;script()-&gt;scheduleExecutionTermination();
324 
325         m_runLoop.postTaskAndTerminate({ ScriptExecutionContext::Task::CleanupTask, [] (ScriptExecutionContext&amp; context ) {
326             WorkerGlobalScope&amp; workerGlobalScope = downcast&lt;WorkerGlobalScope&gt;(context);
327 
328             workerGlobalScope.prepareForTermination();
329 
330             // Stick a shutdown command at the end of the queue, so that we deal
331             // with all the cleanup tasks the databases post first.
332             workerGlobalScope.postTask({ ScriptExecutionContext::Task::CleanupTask, [] (ScriptExecutionContext&amp; context) {
333                 WorkerGlobalScope&amp; workerGlobalScope = downcast&lt;WorkerGlobalScope&gt;(context);
334                 // It&#39;s not safe to call clearScript until all the cleanup tasks posted by functions initiated by WorkerThreadShutdownStartTask have completed.
335                 workerGlobalScope.clearScript();
336             } });
337 
</pre>
</td>
</tr>
</table>
<center><a href="WorkerScriptLoader.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WorkerThread.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
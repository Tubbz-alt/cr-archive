<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/nicosia/NicosiaAnimation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../java/PathJava.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="NicosiaAnimation.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/nicosia/NicosiaAnimation.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
185 }
186 
187 Animation::Animation(const Animation&amp; other)
188     : m_name(other.m_name.isSafeToSendToAnotherThread() ? other.m_name : other.m_name.isolatedCopy())
189     , m_keyframes(other.m_keyframes)
190     , m_boxSize(other.m_boxSize)
191     , m_timingFunction(other.m_timingFunction-&gt;clone())
192     , m_iterationCount(other.m_iterationCount)
193     , m_duration(other.m_duration)
194     , m_direction(other.m_direction)
195     , m_fillsForwards(other.m_fillsForwards)
196     , m_listsMatch(other.m_listsMatch)
197     , m_startTime(other.m_startTime)
198     , m_pauseTime(other.m_pauseTime)
199     , m_totalRunningTime(other.m_totalRunningTime)
200     , m_lastRefreshedTime(other.m_lastRefreshedTime)
201     , m_state(other.m_state)
202 {
203 }
204 



















205 void Animation::apply(ApplicationResult&amp; applicationResults, MonotonicTime time)
206 {
<span class="line-modified">207     if (!isActive())</span>
<span class="line-modified">208         return;</span>
209 
210     Seconds totalRunningTime = computeTotalRunningTime(time);
211     double normalizedValue = normalizedAnimationValue(totalRunningTime.seconds(), m_duration, m_direction, m_iterationCount);
212 
213     if (m_iterationCount != WebCore::Animation::IterationCountInfinite &amp;&amp; totalRunningTime.seconds() &gt;= m_duration * m_iterationCount) {
214         m_state = AnimationState::Stopped;
215         m_pauseTime = 0_s;
<span class="line-modified">216         if (m_fillsForwards)</span>
<span class="line-removed">217             normalizedValue = normalizedAnimationValueForFillsForwards(m_iterationCount, m_direction);</span>
218     }
219 
220     applicationResults.hasRunningAnimations |= (m_state == AnimationState::Playing);
221 
222     if (!normalizedValue) {
223         applyInternal(applicationResults, m_keyframes.at(0), m_keyframes.at(1), 0);
224         return;
225     }
226 
227     if (normalizedValue == 1.0) {
228         applyInternal(applicationResults, m_keyframes.at(m_keyframes.size() - 2), m_keyframes.at(m_keyframes.size() - 1), 1);
229         return;
230     }
231     if (m_keyframes.size() == 2) {
232         auto&amp; timingFunction = timingFunctionForAnimationValue(m_keyframes.at(0), *this);
233         normalizedValue = timingFunction.transformTime(normalizedValue, m_duration);
234         applyInternal(applicationResults, m_keyframes.at(0), m_keyframes.at(1), normalizedValue);
235         return;
236     }
237 
</pre>
<hr />
<pre>
272 {
273     m_state = AnimationState::Playing;
274     // FIXME: This seems wrong. m_totalRunningTime is cleared.
275     // https://bugs.webkit.org/show_bug.cgi?id=183113
276     m_pauseTime = 0_s;
277     m_totalRunningTime = m_pauseTime;
278     m_lastRefreshedTime = MonotonicTime::now();
279 }
280 
281 Seconds Animation::computeTotalRunningTime(MonotonicTime time)
282 {
283     if (m_state == AnimationState::Paused)
284         return m_pauseTime;
285 
286     MonotonicTime oldLastRefreshedTime = m_lastRefreshedTime;
287     m_lastRefreshedTime = time;
288     m_totalRunningTime += m_lastRefreshedTime - oldLastRefreshedTime;
289     return m_totalRunningTime;
290 }
291 
<span class="line-removed">292 bool Animation::isActive() const</span>
<span class="line-removed">293 {</span>
<span class="line-removed">294     return m_state != AnimationState::Stopped || m_fillsForwards;</span>
<span class="line-removed">295 }</span>
<span class="line-removed">296 </span>
297 void Animation::applyInternal(ApplicationResult&amp; applicationResults, const AnimationValue&amp; from, const AnimationValue&amp; to, float progress)
298 {
299     switch (m_keyframes.property()) {
300     case AnimatedPropertyTransform:
301         applicationResults.transform = applyTransformAnimation(static_cast&lt;const TransformAnimationValue&amp;&gt;(from).value(), static_cast&lt;const TransformAnimationValue&amp;&gt;(to).value(), progress, m_boxSize, m_listsMatch);
302         return;
303     case AnimatedPropertyOpacity:
304         applicationResults.opacity = applyOpacityAnimation((static_cast&lt;const FloatAnimationValue&amp;&gt;(from).value()), (static_cast&lt;const FloatAnimationValue&amp;&gt;(to).value()), progress);
305         return;
306     case AnimatedPropertyFilter:
307         applicationResults.filters = applyFilterAnimation(static_cast&lt;const FilterAnimationValue&amp;&gt;(from).value(), static_cast&lt;const FilterAnimationValue&amp;&gt;(to).value(), progress, m_boxSize);
308         return;
309     default:
310         ASSERT_NOT_REACHED();
311     }
312 }
313 
314 void Animations::add(const Animation&amp; animation)
315 {
316     // Remove the old state if we are resuming a paused animation.
</pre>
<hr />
<pre>
354     for (auto&amp; animation : m_animations)
355         animation.resume();
356 }
357 
358 void Animations::apply(Animation::ApplicationResult&amp; applicationResults, MonotonicTime time)
359 {
360     for (auto&amp; animation : m_animations)
361         animation.apply(applicationResults, time);
362 }
363 
364 void Animations::applyKeepingInternalState(Animation::ApplicationResult&amp; applicationResults, MonotonicTime time)
365 {
366     for (auto&amp; animation : m_animations)
367         animation.applyKeepingInternalState(applicationResults, time);
368 }
369 
370 bool Animations::hasActiveAnimationsOfType(AnimatedPropertyID type) const
371 {
372     return std::any_of(m_animations.begin(), m_animations.end(),
373         [&amp;type](const Animation&amp; animation) {
<span class="line-modified">374             return animation.isActive() &amp;&amp; animation.keyframes().property() == type;</span>
375         });
376 }
377 
378 bool Animations::hasRunningAnimations() const
379 {
380     return std::any_of(m_animations.begin(), m_animations.end(),
381         [](const Animation&amp; animation) {
382             return animation.state() == Animation::AnimationState::Playing;
383         });
384 }
385 
<span class="line-removed">386 Animations Animations::getActiveAnimations() const</span>
<span class="line-removed">387 {</span>
<span class="line-removed">388     Animations active;</span>
<span class="line-removed">389     for (auto&amp; animation : m_animations) {</span>
<span class="line-removed">390         if (animation.isActive())</span>
<span class="line-removed">391             active.add(animation);</span>
<span class="line-removed">392     }</span>
<span class="line-removed">393     return active;</span>
<span class="line-removed">394 }</span>
<span class="line-removed">395 </span>
396 } // namespace Nicosia
</pre>
</td>
<td>
<hr />
<pre>
185 }
186 
187 Animation::Animation(const Animation&amp; other)
188     : m_name(other.m_name.isSafeToSendToAnotherThread() ? other.m_name : other.m_name.isolatedCopy())
189     , m_keyframes(other.m_keyframes)
190     , m_boxSize(other.m_boxSize)
191     , m_timingFunction(other.m_timingFunction-&gt;clone())
192     , m_iterationCount(other.m_iterationCount)
193     , m_duration(other.m_duration)
194     , m_direction(other.m_direction)
195     , m_fillsForwards(other.m_fillsForwards)
196     , m_listsMatch(other.m_listsMatch)
197     , m_startTime(other.m_startTime)
198     , m_pauseTime(other.m_pauseTime)
199     , m_totalRunningTime(other.m_totalRunningTime)
200     , m_lastRefreshedTime(other.m_lastRefreshedTime)
201     , m_state(other.m_state)
202 {
203 }
204 
<span class="line-added">205 Animation&amp; Animation::operator=(const Animation&amp; other)</span>
<span class="line-added">206 {</span>
<span class="line-added">207     m_name = other.m_name.isSafeToSendToAnotherThread() ? other.m_name : other.m_name.isolatedCopy();</span>
<span class="line-added">208     m_keyframes = other.m_keyframes;</span>
<span class="line-added">209     m_boxSize = other.m_boxSize;</span>
<span class="line-added">210     m_timingFunction = other.m_timingFunction-&gt;clone();</span>
<span class="line-added">211     m_iterationCount = other.m_iterationCount;</span>
<span class="line-added">212     m_duration = other.m_duration;</span>
<span class="line-added">213     m_direction = other.m_direction;</span>
<span class="line-added">214     m_fillsForwards = other.m_fillsForwards;</span>
<span class="line-added">215     m_listsMatch = other.m_listsMatch;</span>
<span class="line-added">216     m_startTime = other.m_startTime;</span>
<span class="line-added">217     m_pauseTime = other.m_pauseTime;</span>
<span class="line-added">218     m_totalRunningTime = other.m_totalRunningTime;</span>
<span class="line-added">219     m_lastRefreshedTime = other.m_lastRefreshedTime;</span>
<span class="line-added">220     m_state = other.m_state;</span>
<span class="line-added">221     return *this;</span>
<span class="line-added">222 }</span>
<span class="line-added">223 </span>
224 void Animation::apply(ApplicationResult&amp; applicationResults, MonotonicTime time)
225 {
<span class="line-modified">226     // Even when m_state == AnimationState::Stopped &amp;&amp; !m_fillsForwards, we should calculate the last value to avoid a flash.</span>
<span class="line-modified">227     // CoordinatedGraphicsScene will soon remove the stopped animation and update the value instead of this function.</span>
228 
229     Seconds totalRunningTime = computeTotalRunningTime(time);
230     double normalizedValue = normalizedAnimationValue(totalRunningTime.seconds(), m_duration, m_direction, m_iterationCount);
231 
232     if (m_iterationCount != WebCore::Animation::IterationCountInfinite &amp;&amp; totalRunningTime.seconds() &gt;= m_duration * m_iterationCount) {
233         m_state = AnimationState::Stopped;
234         m_pauseTime = 0_s;
<span class="line-modified">235         normalizedValue = normalizedAnimationValueForFillsForwards(m_iterationCount, m_direction);</span>

236     }
237 
238     applicationResults.hasRunningAnimations |= (m_state == AnimationState::Playing);
239 
240     if (!normalizedValue) {
241         applyInternal(applicationResults, m_keyframes.at(0), m_keyframes.at(1), 0);
242         return;
243     }
244 
245     if (normalizedValue == 1.0) {
246         applyInternal(applicationResults, m_keyframes.at(m_keyframes.size() - 2), m_keyframes.at(m_keyframes.size() - 1), 1);
247         return;
248     }
249     if (m_keyframes.size() == 2) {
250         auto&amp; timingFunction = timingFunctionForAnimationValue(m_keyframes.at(0), *this);
251         normalizedValue = timingFunction.transformTime(normalizedValue, m_duration);
252         applyInternal(applicationResults, m_keyframes.at(0), m_keyframes.at(1), normalizedValue);
253         return;
254     }
255 
</pre>
<hr />
<pre>
290 {
291     m_state = AnimationState::Playing;
292     // FIXME: This seems wrong. m_totalRunningTime is cleared.
293     // https://bugs.webkit.org/show_bug.cgi?id=183113
294     m_pauseTime = 0_s;
295     m_totalRunningTime = m_pauseTime;
296     m_lastRefreshedTime = MonotonicTime::now();
297 }
298 
299 Seconds Animation::computeTotalRunningTime(MonotonicTime time)
300 {
301     if (m_state == AnimationState::Paused)
302         return m_pauseTime;
303 
304     MonotonicTime oldLastRefreshedTime = m_lastRefreshedTime;
305     m_lastRefreshedTime = time;
306     m_totalRunningTime += m_lastRefreshedTime - oldLastRefreshedTime;
307     return m_totalRunningTime;
308 }
309 





310 void Animation::applyInternal(ApplicationResult&amp; applicationResults, const AnimationValue&amp; from, const AnimationValue&amp; to, float progress)
311 {
312     switch (m_keyframes.property()) {
313     case AnimatedPropertyTransform:
314         applicationResults.transform = applyTransformAnimation(static_cast&lt;const TransformAnimationValue&amp;&gt;(from).value(), static_cast&lt;const TransformAnimationValue&amp;&gt;(to).value(), progress, m_boxSize, m_listsMatch);
315         return;
316     case AnimatedPropertyOpacity:
317         applicationResults.opacity = applyOpacityAnimation((static_cast&lt;const FloatAnimationValue&amp;&gt;(from).value()), (static_cast&lt;const FloatAnimationValue&amp;&gt;(to).value()), progress);
318         return;
319     case AnimatedPropertyFilter:
320         applicationResults.filters = applyFilterAnimation(static_cast&lt;const FilterAnimationValue&amp;&gt;(from).value(), static_cast&lt;const FilterAnimationValue&amp;&gt;(to).value(), progress, m_boxSize);
321         return;
322     default:
323         ASSERT_NOT_REACHED();
324     }
325 }
326 
327 void Animations::add(const Animation&amp; animation)
328 {
329     // Remove the old state if we are resuming a paused animation.
</pre>
<hr />
<pre>
367     for (auto&amp; animation : m_animations)
368         animation.resume();
369 }
370 
371 void Animations::apply(Animation::ApplicationResult&amp; applicationResults, MonotonicTime time)
372 {
373     for (auto&amp; animation : m_animations)
374         animation.apply(applicationResults, time);
375 }
376 
377 void Animations::applyKeepingInternalState(Animation::ApplicationResult&amp; applicationResults, MonotonicTime time)
378 {
379     for (auto&amp; animation : m_animations)
380         animation.applyKeepingInternalState(applicationResults, time);
381 }
382 
383 bool Animations::hasActiveAnimationsOfType(AnimatedPropertyID type) const
384 {
385     return std::any_of(m_animations.begin(), m_animations.end(),
386         [&amp;type](const Animation&amp; animation) {
<span class="line-modified">387             return animation.keyframes().property() == type;</span>
388         });
389 }
390 
391 bool Animations::hasRunningAnimations() const
392 {
393     return std::any_of(m_animations.begin(), m_animations.end(),
394         [](const Animation&amp; animation) {
395             return animation.state() == Animation::AnimationState::Playing;
396         });
397 }
398 










399 } // namespace Nicosia
</pre>
</td>
</tr>
</table>
<center><a href="../java/PathJava.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="NicosiaAnimation.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
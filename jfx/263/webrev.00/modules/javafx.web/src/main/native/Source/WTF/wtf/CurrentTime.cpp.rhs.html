<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/CurrentTime.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2006-2019 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) 2008 Google Inc. All rights reserved.
  4  * Copyright (C) 2007-2009 Torch Mobile, Inc.
  5  * Copyright (C) 2008 Cameron Zwarich &lt;cwzwarich@uwaterloo.ca&gt;
  6  *
  7  * Redistribution and use in source and binary forms, with or without
  8  * modification, are permitted provided that the following conditions are
  9  * met:
 10  *
 11  *     * Redistributions of source code must retain the above copyright
 12  * notice, this list of conditions and the following disclaimer.
 13  *     * Redistributions in binary form must reproduce the above
 14  * copyright notice, this list of conditions and the following disclaimer
 15  * in the documentation and/or other materials provided with the
 16  * distribution.
 17  *     * Neither the name of Google Inc. nor the names of its
 18  * contributors may be used to endorse or promote products derived from
 19  * this software without specific prior written permission.
 20  *
 21  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 22  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 23  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 24  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 25  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 26  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 27  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 28  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 29  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 30  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 31  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 
 34 #include &quot;config.h&quot;
 35 #include &lt;wtf/MonotonicTime.h&gt;
 36 
 37 #include &lt;time.h&gt;
 38 #include &lt;wtf/WallTime.h&gt;
 39 
 40 #if OS(DARWIN)
 41 #include &lt;mach/mach.h&gt;
 42 #include &lt;mach/mach_time.h&gt;
 43 #include &lt;mutex&gt;
 44 #include &lt;sys/time.h&gt;
 45 #elif OS(WINDOWS)
 46 
 47 // Windows is first since we want to use hires timers, despite USE(CF)
 48 // being defined.
 49 // If defined, WIN32_LEAN_AND_MEAN disables timeBeginPeriod/timeEndPeriod.
 50 #undef WIN32_LEAN_AND_MEAN
 51 #include &lt;windows.h&gt;
 52 #include &lt;math.h&gt;
 53 #include &lt;stdint.h&gt;
 54 #else
 55 #include &lt;sys/time.h&gt;
 56 #endif
 57 
 58 #if OS(FUCHSIA)
 59 #include &lt;zircon/syscalls.h&gt;
 60 #endif
 61 
 62 #if USE(GLIB)
 63 #include &lt;glib.h&gt;
 64 #endif
 65 
 66 namespace WTF {
 67 
 68 #if OS(WINDOWS)
 69 
 70 // Number of 100 nanosecond between January 1, 1601 and January 1, 1970.
<a name="2" id="anc2"></a><span class="line-modified"> 71 static constexpr ULONGLONG epochBias = 116444736000000000ULL;</span>
<span class="line-modified"> 72 static constexpr double hundredsOfNanosecondsPerMillisecond = 10000;</span>
 73 
 74 static double lowResUTCTime()
 75 {
 76     FILETIME fileTime;
 77 
 78     GetSystemTimeAsFileTime(&amp;fileTime);
 79 
 80     // As per Windows documentation for FILETIME, copy the resulting FILETIME structure to a
 81     // ULARGE_INTEGER structure using memcpy (using memcpy instead of direct assignment can
 82     // prevent alignment faults on 64-bit Windows).
 83 
 84     ULARGE_INTEGER dateTime;
 85     memcpy(&amp;dateTime, &amp;fileTime, sizeof(dateTime));
 86 
 87     // Windows file times are in 100s of nanoseconds.
 88     return (dateTime.QuadPart - epochBias) / hundredsOfNanosecondsPerMillisecond;
 89 }
 90 
 91 #if USE(QUERY_PERFORMANCE_COUNTER)
 92 
 93 static LARGE_INTEGER qpcFrequency;
 94 static bool syncedTime;
 95 
 96 static double highResUpTime()
 97 {
 98     // We use QPC, but only after sanity checking its result, due to bugs:
 99     // http://support.microsoft.com/kb/274323
100     // http://support.microsoft.com/kb/895980
101     // http://msdn.microsoft.com/en-us/library/ms644904.aspx (&quot;...you can get different results on different processors due to bugs in the basic input/output system (BIOS) or the hardware abstraction layer (HAL).&quot;
102 
103     static LARGE_INTEGER qpcLast;
104     static DWORD tickCountLast;
105     static bool inited;
106 
107     LARGE_INTEGER qpc;
108     QueryPerformanceCounter(&amp;qpc);
109 #if defined(_M_IX86) || defined(__i386__)
110     DWORD tickCount = GetTickCount();
111 #else
112     ULONGLONG tickCount = GetTickCount64();
113 #endif
114 
115     if (inited) {
116         __int64 qpcElapsed = ((qpc.QuadPart - qpcLast.QuadPart) * 1000) / qpcFrequency.QuadPart;
117         __int64 tickCountElapsed;
118         if (tickCount &gt;= tickCountLast)
119             tickCountElapsed = (tickCount - tickCountLast);
120         else {
121 #if COMPILER(MINGW)
122             __int64 tickCountLarge = tickCount + 0x100000000ULL;
123 #else
124             __int64 tickCountLarge = tickCount + 0x100000000I64;
125 #endif
126             tickCountElapsed = tickCountLarge - tickCountLast;
127         }
128 
129         // force a re-sync if QueryPerformanceCounter differs from GetTickCount by more than 500ms.
130         // (500ms value is from http://support.microsoft.com/kb/274323)
131         __int64 diff = tickCountElapsed - qpcElapsed;
132         if (diff &gt; 500 || diff &lt; -500)
133             syncedTime = false;
134     } else
135         inited = true;
136 
137     qpcLast = qpc;
138     tickCountLast = tickCount;
139 
140     return (1000.0 * qpc.QuadPart) / static_cast&lt;double&gt;(qpcFrequency.QuadPart);
141 }
142 
143 static bool qpcAvailable()
144 {
145     static bool available;
146     static bool checked;
147 
148     if (checked)
149         return available;
150 
151     available = QueryPerformanceFrequency(&amp;qpcFrequency);
152     checked = true;
153     return available;
154 }
155 
156 static inline double currentTime()
157 {
158     // Use a combination of ftime and QueryPerformanceCounter.
159     // ftime returns the information we want, but doesn&#39;t have sufficient resolution.
160     // QueryPerformanceCounter has high resolution, but is only usable to measure time intervals.
161     // To combine them, we call ftime and QueryPerformanceCounter initially. Later calls will use QueryPerformanceCounter
162     // by itself, adding the delta to the saved ftime.  We periodically re-sync to correct for drift.
163     static double syncLowResUTCTime;
164     static double syncHighResUpTime;
165     static double lastUTCTime;
166 
167     double lowResTime = lowResUTCTime();
168 
169     if (!qpcAvailable())
170         return lowResTime / 1000.0;
171 
172     double highResTime = highResUpTime();
173 
174     if (!syncedTime) {
175         timeBeginPeriod(1); // increase time resolution around low-res time getter
176         syncLowResUTCTime = lowResTime = lowResUTCTime();
177         timeEndPeriod(1); // restore time resolution
178         syncHighResUpTime = highResTime;
179         syncedTime = true;
180     }
181 
182     double highResElapsed = highResTime - syncHighResUpTime;
183     double utc = syncLowResUTCTime + highResElapsed;
184 
185     // force a clock re-sync if we&#39;ve drifted
186     double lowResElapsed = lowResTime - syncLowResUTCTime;
187     const double maximumAllowedDriftMsec = 15.625 * 2.0; // 2x the typical low-res accuracy
188     if (fabs(highResElapsed - lowResElapsed) &gt; maximumAllowedDriftMsec)
189         syncedTime = false;
190 
191     // make sure time doesn&#39;t run backwards (only correct if difference is &lt; 2 seconds, since DST or clock changes could occur)
192     const double backwardTimeLimit = 2000.0;
193     if (utc &lt; lastUTCTime &amp;&amp; (lastUTCTime - utc) &lt; backwardTimeLimit)
194         return lastUTCTime / 1000.0;
195     lastUTCTime = utc;
196     return utc / 1000.0;
197 }
198 
199 #else
200 
201 static inline double currentTime()
202 {
203     static bool init = false;
204     static double lastTime;
205     static DWORD lastTickCount;
206     if (!init) {
207         lastTime = lowResUTCTime();
208         lastTickCount = GetTickCount();
209         init = true;
210         return lastTime;
211     }
212 
213     DWORD tickCountNow = GetTickCount();
214     DWORD elapsed = tickCountNow - lastTickCount;
215     double timeNow = lastTime + (double)elapsed / 1000.;
216     if (elapsed &gt;= 0x7FFFFFFF) {
217         lastTime = timeNow;
218         lastTickCount = tickCountNow;
219     }
220     return timeNow;
221 }
222 
223 #endif // USE(QUERY_PERFORMANCE_COUNTER)
224 
225 #elif USE(GLIB)
226 
227 // Note: GTK on Windows will pick up the PLATFORM(WIN) implementation above which provides
228 // better accuracy compared with Windows implementation of g_get_current_time:
229 // (http://www.google.com/codesearch/p?hl=en#HHnNRjks1t0/glib-2.5.2/glib/gmain.c&amp;q=g_get_current_time).
230 // Non-Windows GTK builds could use gettimeofday() directly but for the sake of consistency lets use GTK function.
231 static inline double currentTime()
232 {
<a name="3" id="anc3"></a><span class="line-modified">233     return static_cast&lt;double&gt;(g_get_real_time() / 1000000.0);</span>


234 }
235 
236 #else
237 
238 static inline double currentTime()
239 {
240     struct timeval now;
241     gettimeofday(&amp;now, 0);
242     return now.tv_sec + now.tv_usec / 1000000.0;
243 }
244 
245 #endif
246 
247 WallTime WallTime::now()
248 {
249     return fromRawSeconds(currentTime());
250 }
251 
252 MonotonicTime MonotonicTime::now()
253 {
254 #if USE(GLIB)
255     return fromRawSeconds(static_cast&lt;double&gt;(g_get_monotonic_time() / 1000000.0));
256 #elif OS(DARWIN)
257     // Based on listing #2 from Apple QA 1398, but modified to be thread-safe.
258     static mach_timebase_info_data_t timebaseInfo;
259     static std::once_flag initializeTimerOnceFlag;
260     std::call_once(initializeTimerOnceFlag, [] {
261         kern_return_t kr = mach_timebase_info(&amp;timebaseInfo);
262         ASSERT_UNUSED(kr, kr == KERN_SUCCESS);
263         ASSERT(timebaseInfo.denom);
264     });
265 
266     return fromRawSeconds((mach_absolute_time() * timebaseInfo.numer) / (1.0e9 * timebaseInfo.denom));
267 #elif OS(FUCHSIA)
268     return fromRawSeconds(zx_clock_get_monotonic() / static_cast&lt;double&gt;(ZX_SEC(1)));
269 #elif OS(LINUX) || OS(FREEBSD) || OS(OPENBSD) || OS(NETBSD)
270     struct timespec ts { };
271     clock_gettime(CLOCK_MONOTONIC, &amp;ts);
272     return fromRawSeconds(static_cast&lt;double&gt;(ts.tv_sec) + ts.tv_nsec / 1.0e9);
273 #elif OS(WINDOWS) &amp;&amp; PLATFORM(JAVA)
274     // monotonicallyIncreasingTime() implementation is done by taking reference from glib library
275     uint64_t ticks = GetTickCount64();
276     uint32_t ticks32 = timeGetTime();
277     uint32_t ticksAs32Bit = static_cast&lt;uint32_t&gt;(ticks);
278     if (ticks32 - ticksAs32Bit &lt;= INT_MAX) {
279         ticks += ticks32 - ticksAs32Bit;
280     } else {
281         ticks -= ticksAs32Bit - ticks32;
282     }
283     return fromRawSeconds(ticks / 1000.0);
284 #else
285     static double lastTime = 0;
286     double currentTimeNow = currentTime();
287     if (currentTimeNow &lt; lastTime)
288         return lastTime;
289     lastTime = currentTimeNow;
290     return fromRawSeconds(currentTimeNow);
291 #endif
292 }
293 
294 } // namespace WTF
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
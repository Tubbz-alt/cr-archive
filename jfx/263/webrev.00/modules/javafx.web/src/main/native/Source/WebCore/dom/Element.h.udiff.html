<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/dom/Element.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Element.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Element.idl.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Element.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -26,16 +26,15 @@</span>
  
  #include &quot;AXTextStateChangeIntent.h&quot;
  #include &quot;Document.h&quot;
  #include &quot;ElementData.h&quot;
  #include &quot;HTMLNames.h&quot;
<span class="udiff-line-removed">- #include &quot;KeyframeAnimationOptions.h&quot;</span>
<span class="udiff-line-removed">- #include &quot;ScrollToOptions.h&quot;</span>
  #include &quot;ScrollTypes.h&quot;
  #include &quot;ShadowRootMode.h&quot;
  #include &quot;SimulatedClickOptions.h&quot;
  #include &quot;StyleChange.h&quot;
<span class="udiff-line-added">+ #include &lt;JavaScriptCore/Strong.h&gt;</span>
  
  namespace WebCore {
  
  class CustomElementReactionQueue;
  class DatasetDOMStringMap;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -45,35 +44,39 @@</span>
  class ElementRareData;
  class Frame;
  class HTMLDocument;
  class IntSize;
  class JSCustomElementInterface;
<span class="udiff-line-added">+ class KeyframeEffectStack;</span>
  class KeyboardEvent;
  class Locale;
  class PlatformKeyboardEvent;
  class PlatformMouseEvent;
  class PlatformWheelEvent;
  class PseudoElement;
  class RenderTreePosition;
  class StylePropertyMap;
  class WebAnimation;
<span class="udiff-line-modified-removed">- struct ElementStyle;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+ struct GetAnimationsOptions;</span>
<span class="udiff-line-added">+ struct KeyframeAnimationOptions;</span>
  struct ScrollIntoViewOptions;
<span class="udiff-line-added">+ struct ScrollToOptions;</span>
  
  #if ENABLE(INTERSECTION_OBSERVER)
  struct IntersectionObserverData;
  #endif
  
  #if ENABLE(RESIZE_OBSERVER)
  struct ResizeObserverData;
  #endif
  
<span class="udiff-line-modified-removed">- enum SpellcheckAttributeState {</span>
<span class="udiff-line-modified-removed">-     SpellcheckAttributeTrue,</span>
<span class="udiff-line-modified-removed">-     SpellcheckAttributeFalse,</span>
<span class="udiff-line-modified-removed">-     SpellcheckAttributeDefault</span>
<span class="udiff-line-modified-removed">- };</span>
<span class="udiff-line-modified-added">+ namespace Style {</span>
<span class="udiff-line-modified-added">+ struct ElementStyle;</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ enum class AnimationImpact;</span>
  
  class Element : public ContainerNode {
      WTF_MAKE_ISO_ALLOCATED(Element);
  public:
      static Ref&lt;Element&gt; create(const QualifiedName&amp;, Document&amp;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -97,18 +100,17 @@</span>
  
      // Call this to get the value of an attribute that is known not to be the style
      // attribute or one of the SVG animatable attributes.
      bool hasAttributeWithoutSynchronization(const QualifiedName&amp;) const;
      const AtomString&amp; attributeWithoutSynchronization(const QualifiedName&amp;) const;
<span class="udiff-line-removed">- #ifndef NDEBUG</span>
<span class="udiff-line-removed">-     WEBCORE_EXPORT bool fastAttributeLookupAllowed(const QualifiedName&amp;) const;</span>
<span class="udiff-line-removed">- #endif</span>
  
  #if DUMP_NODE_STATISTICS
      bool hasNamedNodeMap() const;
  #endif
<span class="udiff-line-added">+ </span>
      WEBCORE_EXPORT bool hasAttributes() const;
<span class="udiff-line-added">+ </span>
      // This variant will not update the potentially invalid attributes. To be used when not interested
      // in style attribute or one of the SVG animation attributes.
      bool hasAttributesWithoutUpdate() const;
  
      WEBCORE_EXPORT bool hasAttribute(const AtomString&amp; qualifiedName) const;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -192,10 +194,11 @@</span>
      WEBCORE_EXPORT Ref&lt;DOMRectList&gt; getClientRects();
      Ref&lt;DOMRect&gt; getBoundingClientRect();
  
      // Returns the absolute bounding box translated into client coordinates.
      WEBCORE_EXPORT IntRect clientRect() const;
<span class="udiff-line-added">+ </span>
      // Returns the absolute bounding box translated into screen coordinates.
      WEBCORE_EXPORT IntRect screenRect() const;
  
      WEBCORE_EXPORT bool removeAttribute(const AtomString&amp; qualifiedName);
      WEBCORE_EXPORT bool removeAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -215,18 +218,17 @@</span>
      const Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; attrNodeList();
  
      const QualifiedName&amp; tagQName() const { return m_tagName; }
  #if ENABLE(JIT)
      static ptrdiff_t tagQNameMemoryOffset() { return OBJECT_OFFSETOF(Element, m_tagName); }
<span class="udiff-line-modified-removed">- #endif // ENABLE(JIT)</span>
<span class="udiff-line-modified-added">+ #endif</span>
      String tagName() const { return nodeName(); }
      bool hasTagName(const QualifiedName&amp; tagName) const { return m_tagName.matches(tagName); }
      bool hasTagName(const HTMLQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
      bool hasTagName(const MathMLQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
      bool hasTagName(const SVGQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
  
<span class="udiff-line-removed">-     // A fast function for checking the local name against another atomic string.</span>
      bool hasLocalName(const AtomString&amp; other) const { return m_tagName.localName() == other; }
  
      const AtomString&amp; localName() const final { return m_tagName.localName(); }
      const AtomString&amp; prefix() const final { return m_tagName.prefix(); }
      const AtomString&amp; namespaceURI() const final { return m_tagName.namespaceURI(); }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -249,11 +251,11 @@</span>
      enum AttributeModificationReason {
          ModifiedDirectly,
          ModifiedByCloning
      };
  
<span class="udiff-line-modified-removed">-     // This method is called whenever an attribute is added, changed or removed.</span>
<span class="udiff-line-modified-added">+     // These functions are called whenever an attribute is added, changed or removed.</span>
      virtual void attributeChanged(const QualifiedName&amp;, const AtomString&amp; oldValue, const AtomString&amp; newValue, AttributeModificationReason = ModifiedDirectly);
      virtual void parseAttribute(const QualifiedName&amp;, const AtomString&amp;) { }
  
      // Only called by the parser immediately after element construction.
      void parserSetAttributes(const Vector&lt;Attribute&gt;&amp;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -282,16 +284,18 @@</span>
  
      virtual void copyNonAttributePropertiesFromElement(const Element&amp;) { }
  
      virtual RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;);
      virtual bool rendererIsNeeded(const RenderStyle&amp;);
<span class="udiff-line-added">+     virtual bool rendererIsEverNeeded() { return true; }</span>
  
      WEBCORE_EXPORT ShadowRoot* shadowRoot() const;
<span class="udiff-line-modified-removed">-     ShadowRoot* shadowRootForBindings(JSC::ExecState&amp;) const;</span>
<span class="udiff-line-modified-added">+     ShadowRoot* shadowRootForBindings(JSC::JSGlobalObject&amp;) const;</span>
  
      struct ShadowRootInit {
          ShadowRootMode mode;
<span class="udiff-line-added">+         bool delegatesFocus { false };</span>
      };
      ExceptionOr&lt;ShadowRoot&amp;&gt; attachShadow(const ShadowRootInit&amp;);
  
      RefPtr&lt;ShadowRoot&gt; userAgentShadowRoot() const;
      WEBCORE_EXPORT ShadowRoot&amp; ensureUserAgentShadowRoot();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -300,11 +304,11 @@</span>
      void setIsFailedCustomElement(JSCustomElementInterface&amp;);
      void setIsCustomElementUpgradeCandidate();
      void enqueueToUpgrade(JSCustomElementInterface&amp;);
      CustomElementReactionQueue* reactionQueue() const;
  
<span class="udiff-line-modified-removed">-     // FIXME: this should not be virtual, do not override this.</span>
<span class="udiff-line-modified-added">+     // FIXME: This should not be virtual. Please do not add additional overrides of this function.</span>
      virtual const AtomString&amp; shadowPseudoId() const;
  
      bool isInActiveChain() const { return isUserActionElement() &amp;&amp; isUserActionElementInActiveChain(); }
      bool active() const { return isUserActionElement() &amp;&amp; isUserActionElementActive(); }
      bool hovered() const { return isUserActionElement() &amp;&amp; isUserActionElementHovered(); }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -414,25 +418,15 @@</span>
  
      // Use Document::registerForDocumentActivationCallbacks() to subscribe to these
      virtual void prepareForDocumentSuspension() { }
      virtual void resumeFromDocumentSuspension() { }
  
<span class="udiff-line-removed">-     // Use Document::registerForMediaVolumeCallbacks() to subscribe to this</span>
<span class="udiff-line-removed">-     virtual void mediaVolumeDidChange() { }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Use Document::registerForPrivateBrowsingStateChangedCallbacks() to subscribe to this.</span>
<span class="udiff-line-removed">-     virtual void privateBrowsingStateDidChange(PAL::SessionID) { }</span>
<span class="udiff-line-removed">- </span>
      virtual void willBecomeFullscreenElement();
      virtual void ancestorWillEnterFullscreen() { }
      virtual void didBecomeFullscreenElement() { }
      virtual void willStopBeingFullscreenElement() { }
  
<span class="udiff-line-removed">- #if ENABLE(VIDEO_TRACK)</span>
<span class="udiff-line-removed">-     virtual void captionPreferencesChanged() { }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
      bool isFinishedParsingChildren() const { return isParsingChildrenFinished(); }
      void finishParsingChildren() override;
      void beginParsingChildren() final;
  
      WEBCORE_EXPORT PseudoElement* beforePseudoElement() const;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -449,10 +443,13 @@</span>
      WEBCORE_EXPORT ExceptionOr&lt;Element*&gt; closest(const String&amp; selectors);
      virtual bool shouldAppearIndeterminate() const;
  
      WEBCORE_EXPORT DOMTokenList&amp; classList();
  
<span class="udiff-line-added">+     SpaceSplitString partNames() const;</span>
<span class="udiff-line-added">+     DOMTokenList&amp; part();</span>
<span class="udiff-line-added">+ </span>
      DatasetDOMStringMap&amp; dataset();
  
  #if ENABLE(VIDEO)
      virtual bool isMediaElement() const { return false; }
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -483,10 +480,15 @@</span>
  
      bool hasCSSAnimation() const;
      void setHasCSSAnimation();
      void clearHasCSSAnimation();
  
<span class="udiff-line-added">+     KeyframeEffectStack* keyframeEffectStack() const;</span>
<span class="udiff-line-added">+     KeyframeEffectStack&amp; ensureKeyframeEffectStack();</span>
<span class="udiff-line-added">+     bool hasKeyframeEffects() const;</span>
<span class="udiff-line-added">+     OptionSet&lt;AnimationImpact&gt; applyKeyframeEffects(RenderStyle&amp;);</span>
<span class="udiff-line-added">+ </span>
  #if ENABLE(FULLSCREEN_API)
      WEBCORE_EXPORT bool containsFullScreenElement() const;
      void setContainsFullScreenElement(bool);
      void setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(bool);
      WEBCORE_EXPORT virtual void webkitRequestFullscreen();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -529,11 +531,11 @@</span>
      virtual void willResetComputedStyle();
      virtual void willAttachRenderers();
      virtual void didAttachRenderers();
      virtual void willDetachRenderers();
      virtual void didDetachRenderers();
<span class="udiff-line-modified-removed">-     virtual Optional&lt;ElementStyle&gt; resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle* shadowHostStyle);</span>
<span class="udiff-line-modified-added">+     virtual Optional&lt;Style::ElementStyle&gt; resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle* shadowHostStyle);</span>
  
      LayoutRect absoluteEventHandlerBounds(bool&amp; includesFixedPositionElements) override;
  
      const RenderStyle* existingComputedStyle() const;
      WEBCORE_EXPORT const RenderStyle* renderOrDisplayContentsStyle() const;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -550,12 +552,12 @@</span>
  
  #if ENABLE(TOUCH_EVENTS)
      bool allowsDoubleTapGesture() const override;
  #endif
  
<span class="udiff-line-modified-removed">-     StyleResolver&amp; styleResolver();</span>
<span class="udiff-line-modified-removed">-     ElementStyle resolveStyle(const RenderStyle* parentStyle);</span>
<span class="udiff-line-modified-added">+     Style::Resolver&amp; styleResolver();</span>
<span class="udiff-line-modified-added">+     Style::ElementStyle resolveStyle(const RenderStyle* parentStyle);</span>
  
      // Invalidates the style of a single element. Style is resolved lazily.
      // Descendant elements are resolved as needed, for example if an inherited property changes.
      // This should be called whenever an element changes in a manner that can affect its style.
      void invalidateStyle();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -594,12 +596,12 @@</span>
      ResizeObserverData* resizeObserverData();
  #endif
  
      Element* findAnchorElementForLink(String&amp; outAnchorName);
  
<span class="udiff-line-modified-removed">-     ExceptionOr&lt;Ref&lt;WebAnimation&gt;&gt; animate(JSC::ExecState&amp;, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp;, Optional&lt;Variant&lt;double, KeyframeAnimationOptions&gt;&gt;&amp;&amp;);</span>
<span class="udiff-line-modified-removed">-     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; getAnimations();</span>
<span class="udiff-line-modified-added">+     ExceptionOr&lt;Ref&lt;WebAnimation&gt;&gt; animate(JSC::JSGlobalObject&amp;, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp;, Optional&lt;Variant&lt;double, KeyframeAnimationOptions&gt;&gt;&amp;&amp;);</span>
<span class="udiff-line-modified-added">+     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; getAnimations(Optional&lt;GetAnimationsOptions&gt;);</span>
  
      ElementIdentifier createElementIdentifier();
  
  protected:
      Element(const QualifiedName&amp;, Document&amp;, ConstructionType);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -611,14 +613,12 @@</span>
      virtual void parserDidSetAttributes();
  
      void clearTabIndexExplicitlyIfNeeded();
      void setTabIndexExplicitly(int);
  
<span class="udiff-line-removed">-     // classAttributeChanged() exists to share code between</span>
<span class="udiff-line-removed">-     // parseAttribute (called via setAttribute()) and</span>
<span class="udiff-line-removed">-     // svgAttributeChanged (called when element.className.baseValue is set)</span>
      void classAttributeChanged(const AtomString&amp; newClassString);
<span class="udiff-line-added">+     void partAttributeChanged(const AtomString&amp; newValue);</span>
  
      void addShadowRoot(Ref&lt;ShadowRoot&gt;&amp;&amp;);
  
      static ExceptionOr&lt;void&gt; mergeWithNextTextNode(Text&amp;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -695,12 +695,10 @@</span>
      const RenderStyle&amp; resolveComputedStyle();
      const RenderStyle&amp; resolvePseudoElementStyle(PseudoId);
  
      unsigned rareDataChildIndex() const;
  
<span class="udiff-line-removed">-     SpellcheckAttributeState spellcheckAttributeState() const;</span>
<span class="udiff-line-removed">- </span>
      void createUniqueElementData();
  
      ElementRareData* elementRareData() const;
      ElementRareData&amp; ensureElementRareData();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -712,10 +710,14 @@</span>
      // Anyone thinking of using this should call document instead of ownerDocument.
      void ownerDocument() const = delete;
  
      void attachAttributeNodeIfNeeded(Attr&amp;);
  
<span class="udiff-line-added">+ #if ASSERT_ENABLED</span>
<span class="udiff-line-added">+     WEBCORE_EXPORT bool fastAttributeLookupAllowed(const QualifiedName&amp;) const;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
      QualifiedName m_tagName;
      RefPtr&lt;ElementData&gt; m_elementData;
  };
  
  inline bool Node::hasAttributes() const
</pre>
<center><a href="Element.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Element.idl.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/svg/SVGSVGElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2004, 2005, 2006, 2019 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  3  * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2010 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.
  5  * Copyright (C) 2014 Adobe Systems Incorporated. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;SVGSVGElement.h&quot;
 25 
 26 #include &quot;CSSHelper.h&quot;
 27 #include &quot;DOMMatrix2DInit.h&quot;
 28 #include &quot;DOMWrapperWorld.h&quot;
 29 #include &quot;ElementIterator.h&quot;
 30 #include &quot;EventNames.h&quot;
 31 #include &quot;Frame.h&quot;
 32 #include &quot;FrameSelection.h&quot;
 33 #include &quot;RenderSVGResource.h&quot;
 34 #include &quot;RenderSVGRoot.h&quot;
 35 #include &quot;RenderSVGViewportContainer.h&quot;
 36 #include &quot;RenderView.h&quot;
 37 #include &quot;SMILTimeContainer.h&quot;
 38 #include &quot;SVGAngle.h&quot;
 39 #include &quot;SVGDocumentExtensions.h&quot;
 40 #include &quot;SVGLength.h&quot;
 41 #include &quot;SVGMatrix.h&quot;
 42 #include &quot;SVGNumber.h&quot;
 43 #include &quot;SVGPoint.h&quot;
 44 #include &quot;SVGRect.h&quot;
 45 #include &quot;SVGTransform.h&quot;
 46 #include &quot;SVGViewElement.h&quot;
 47 #include &quot;SVGViewSpec.h&quot;
 48 #include &quot;StaticNodeList.h&quot;
 49 #include &lt;wtf/IsoMallocInlines.h&gt;
 50 
 51 namespace WebCore {
 52 
 53 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGSVGElement);
 54 
 55 inline SVGSVGElement::SVGSVGElement(const QualifiedName&amp; tagName, Document&amp; document)
 56     : SVGGraphicsElement(tagName, document)
 57     , SVGFitToViewBox(this)
 58     , m_timeContainer(SMILTimeContainer::create(*this))
 59 {
 60     ASSERT(hasTagName(SVGNames::svgTag));
 61     document.registerForDocumentSuspensionCallbacks(*this);
 62 
 63     static std::once_flag onceFlag;
 64     std::call_once(onceFlag, [] {
 65         PropertyRegistry::registerProperty&lt;SVGNames::xAttr, &amp;SVGSVGElement::m_x&gt;();
 66         PropertyRegistry::registerProperty&lt;SVGNames::yAttr, &amp;SVGSVGElement::m_y&gt;();
 67         PropertyRegistry::registerProperty&lt;SVGNames::widthAttr, &amp;SVGSVGElement::m_width&gt;();
 68         PropertyRegistry::registerProperty&lt;SVGNames::heightAttr, &amp;SVGSVGElement::m_height&gt;();
 69     });
 70 }
 71 
 72 Ref&lt;SVGSVGElement&gt; SVGSVGElement::create(const QualifiedName&amp; tagName, Document&amp; document)
 73 {
 74     return adoptRef(*new SVGSVGElement(tagName, document));
 75 }
 76 
 77 Ref&lt;SVGSVGElement&gt; SVGSVGElement::create(Document&amp; document)
 78 {
 79     return create(SVGNames::svgTag, document);
 80 }
 81 
 82 SVGSVGElement::~SVGSVGElement()
 83 {
 84     if (m_viewSpec)
 85         m_viewSpec-&gt;resetContextElement();
 86     document().unregisterForDocumentSuspensionCallbacks(*this);
 87     document().accessSVGExtensions().removeTimeContainer(*this);
 88 }
 89 
 90 void SVGSVGElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
 91 {
 92     oldDocument.unregisterForDocumentSuspensionCallbacks(*this);
 93     document().registerForDocumentSuspensionCallbacks(*this);
 94     SVGGraphicsElement::didMoveToNewDocument(oldDocument, newDocument);
 95 }
 96 
 97 SVGViewSpec&amp; SVGSVGElement::currentView()
 98 {
 99     if (!m_viewSpec)
100         m_viewSpec = SVGViewSpec::create(*this);
101     return *m_viewSpec;
102 }
103 
104 RefPtr&lt;Frame&gt; SVGSVGElement::frameForCurrentScale() const
105 {
106     // The behavior of currentScale() is undefined when we&#39;re dealing with non-standalone SVG documents.
107     // If the document is embedded, the scaling is handled by the host renderer.
108     if (!isConnected() || !isOutermostSVGSVGElement())
109         return nullptr;
110     auto frame = makeRefPtr(document().frame());
111     return frame &amp;&amp; frame-&gt;isMainFrame() ? frame : nullptr;
112 }
113 
114 float SVGSVGElement::currentScale() const
115 {
116     // When asking from inside an embedded SVG document, a scale value of 1 seems reasonable, as it doesn&#39;t
117     // know anything about the parent scale.
118     auto frame = frameForCurrentScale();
119     return frame ? frame-&gt;pageZoomFactor() : 1;
120 }
121 
122 void SVGSVGElement::setCurrentScale(float scale)
123 {
124     if (auto frame = frameForCurrentScale())
125         frame-&gt;setPageZoomFactor(scale);
126 }
127 
128 void SVGSVGElement::setCurrentTranslate(const FloatPoint&amp; translation)
129 {
130     if (m_currentTranslate-&gt;value() == translation)
131         return;
132     m_currentTranslate-&gt;setValue(translation);
133     updateCurrentTranslate();
134 }
135 
136 void SVGSVGElement::updateCurrentTranslate()
137 {
138     if (RenderObject* object = renderer())
139         object-&gt;setNeedsLayout();
140     if (parentNode() == &amp;document() &amp;&amp; document().renderView())
141         document().renderView()-&gt;repaint();
142 }
143 
144 void SVGSVGElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
145 {
146     if (!nearestViewportElement() &amp;&amp; isConnected()) {
147         // For these events, the outermost &lt;svg&gt; element works like a &lt;body&gt; element does,
148         // setting certain event handlers directly on the window object.
149         if (name == HTMLNames::onunloadAttr) {
150             document().setWindowAttributeEventListener(eventNames().unloadEvent, name, value, mainThreadNormalWorld());
151             return;
152         }
153         if (name == HTMLNames::onresizeAttr) {
154             document().setWindowAttributeEventListener(eventNames().resizeEvent, name, value, mainThreadNormalWorld());
155             return;
156         }
157         if (name == HTMLNames::onscrollAttr) {
158             document().setWindowAttributeEventListener(eventNames().scrollEvent, name, value, mainThreadNormalWorld());
159             return;
160         }
161         if (name == SVGNames::onzoomAttr) {
162             document().setWindowAttributeEventListener(eventNames().zoomEvent, name, value, mainThreadNormalWorld());
163             return;
164         }
165         if (name == HTMLNames::onabortAttr) {
166             document().setWindowAttributeEventListener(eventNames().abortEvent, name, value, mainThreadNormalWorld());
167             return;
168         }
169         if (name == HTMLNames::onerrorAttr) {
170             document().setWindowAttributeEventListener(eventNames().errorEvent, name, value, mainThreadNormalWorld());
171             return;
172         }
173     }
174 
175     SVGParsingError parseError = NoError;
176 
177     if (name == SVGNames::xAttr)
178         m_x-&gt;setBaseValInternal(SVGLengthValue::construct(SVGLengthMode::Width, value, parseError));
179     else if (name == SVGNames::yAttr)
180         m_y-&gt;setBaseValInternal(SVGLengthValue::construct(SVGLengthMode::Height, value, parseError));
181     else if (name == SVGNames::widthAttr) {
182         auto length = SVGLengthValue::construct(SVGLengthMode::Width, value, parseError, SVGLengthNegativeValuesMode::Forbid);
183         if (parseError != NoError || value.isEmpty()) {
184             // FIXME: This is definitely the correct behavior for a missing/removed attribute.
185             // Not sure it&#39;s correct for the empty string or for something that can&#39;t be parsed.
186             length = SVGLengthValue(SVGLengthMode::Width, &quot;100%&quot;_s);
187         }
188         m_width-&gt;setBaseValInternal(length);
189     } else if (name == SVGNames::heightAttr) {
190         auto length = SVGLengthValue::construct(SVGLengthMode::Height, value, parseError, SVGLengthNegativeValuesMode::Forbid);
191         if (parseError != NoError || value.isEmpty()) {
192             // FIXME: This is definitely the correct behavior for a removed attribute.
193             // Not sure it&#39;s correct for the empty string or for something that can&#39;t be parsed.
194             length = SVGLengthValue(SVGLengthMode::Height, &quot;100%&quot;_s);
195         }
196         m_height-&gt;setBaseValInternal(length);
197     }
198 
199     reportAttributeParsingError(parseError, name, value);
200 
201     SVGGraphicsElement::parseAttribute(name, value);
202     SVGFitToViewBox::parseAttribute(name, value);
203     SVGZoomAndPan::parseAttribute(name, value);
204 }
205 
206 void SVGSVGElement::svgAttributeChanged(const QualifiedName&amp; attrName)
207 {
208     if (PropertyRegistry::isKnownAttribute(attrName)) {
209         InstanceInvalidationGuard guard(*this);
210         invalidateSVGPresentationAttributeStyle();
211 
212         if (auto renderer = this-&gt;renderer())
213             RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
214         return;
215     }
216 
217     if (SVGFitToViewBox::isKnownAttribute(attrName)) {
218         if (auto* renderer = this-&gt;renderer()) {
219             renderer-&gt;setNeedsTransformUpdate();
220             RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
221         }
222         return;
223     }
224 
225     SVGGraphicsElement::svgAttributeChanged(attrName);
226 }
227 
228 Ref&lt;NodeList&gt; SVGSVGElement::collectIntersectionOrEnclosureList(SVGRect&amp; rect, SVGElement* referenceElement, bool (*checkFunction)(SVGElement&amp;, SVGRect&amp;))
229 {
230     Vector&lt;Ref&lt;Element&gt;&gt; elements;
231     for (auto&amp; element : descendantsOfType&lt;SVGElement&gt;(referenceElement ? *referenceElement : *this)) {
232         if (checkFunction(element, rect))
233             elements.append(element);
234     }
235     return StaticElementList::create(WTFMove(elements));
236 }
237 
238 static bool checkIntersectionWithoutUpdatingLayout(SVGElement&amp; element, SVGRect&amp; rect)
239 {
240     return RenderSVGModelObject::checkIntersection(element.renderer(), rect.value());
241 }
242 
243 static bool checkEnclosureWithoutUpdatingLayout(SVGElement&amp; element, SVGRect&amp; rect)
244 {
245     return RenderSVGModelObject::checkEnclosure(element.renderer(), rect.value());
246 }
247 
248 Ref&lt;NodeList&gt; SVGSVGElement::getIntersectionList(SVGRect&amp; rect, SVGElement* referenceElement)
249 {
250     document().updateLayoutIgnorePendingStylesheets();
251     return collectIntersectionOrEnclosureList(rect, referenceElement, checkIntersectionWithoutUpdatingLayout);
252 }
253 
254 Ref&lt;NodeList&gt; SVGSVGElement::getEnclosureList(SVGRect&amp; rect, SVGElement* referenceElement)
255 {
256     document().updateLayoutIgnorePendingStylesheets();
257     return collectIntersectionOrEnclosureList(rect, referenceElement, checkEnclosureWithoutUpdatingLayout);
258 }
259 
260 bool SVGSVGElement::checkIntersection(Ref&lt;SVGElement&gt;&amp;&amp; element, SVGRect&amp; rect)
261 {
262     element-&gt;document().updateLayoutIgnorePendingStylesheets();
263     return checkIntersectionWithoutUpdatingLayout(element, rect);
264 }
265 
266 bool SVGSVGElement::checkEnclosure(Ref&lt;SVGElement&gt;&amp;&amp; element, SVGRect&amp; rect)
267 {
268     element-&gt;document().updateLayoutIgnorePendingStylesheets();
269     return checkEnclosureWithoutUpdatingLayout(element, rect);
270 }
271 
272 void SVGSVGElement::deselectAll()
273 {
274     if (auto frame = makeRefPtr(document().frame()))
275         frame-&gt;selection().clear();
276 }
277 
278 Ref&lt;SVGNumber&gt; SVGSVGElement::createSVGNumber()
279 {
280     return SVGNumber::create();
281 }
282 
283 Ref&lt;SVGLength&gt; SVGSVGElement::createSVGLength()
284 {
285     return SVGLength::create();
286 }
287 
288 Ref&lt;SVGAngle&gt; SVGSVGElement::createSVGAngle()
289 {
290     return SVGAngle::create();
291 }
292 
293 Ref&lt;SVGPoint&gt; SVGSVGElement::createSVGPoint()
294 {
295     return SVGPoint::create();
296 }
297 
298 Ref&lt;SVGMatrix&gt; SVGSVGElement::createSVGMatrix()
299 {
300     return SVGMatrix::create();
301 }
302 
303 Ref&lt;SVGRect&gt; SVGSVGElement::createSVGRect()
304 {
305     return SVGRect::create();
306 }
307 
308 Ref&lt;SVGTransform&gt; SVGSVGElement::createSVGTransform()
309 {
310     return SVGTransform::create(SVGTransformValue::SVG_TRANSFORM_MATRIX);
311 }
312 
313 Ref&lt;SVGTransform&gt; SVGSVGElement::createSVGTransformFromMatrix(DOMMatrix2DInit&amp;&amp; matrixInit)
314 {
315     AffineTransform transform;
316     if (matrixInit.a.hasValue())
317         transform.setA(matrixInit.a.value());
318     if (matrixInit.b.hasValue())
319         transform.setB(matrixInit.b.value());
320     if (matrixInit.c.hasValue())
321         transform.setC(matrixInit.c.value());
322     if (matrixInit.d.hasValue())
323         transform.setD(matrixInit.d.value());
324     if (matrixInit.e.hasValue())
325         transform.setE(matrixInit.e.value());
326     if (matrixInit.f.hasValue())
327         transform.setF(matrixInit.f.value());
328     return SVGTransform::create(transform);
329 }
330 
331 AffineTransform SVGSVGElement::localCoordinateSpaceTransform(SVGLocatable::CTMScope mode) const
332 {
333     AffineTransform viewBoxTransform;
334     if (!hasEmptyViewBox()) {
335         FloatSize size = currentViewportSize();
336         viewBoxTransform = viewBoxToViewTransform(size.width(), size.height());
337     }
338 
339     AffineTransform transform;
340     if (!isOutermostSVGSVGElement()) {
341         SVGLengthContext lengthContext(this);
342         transform.translate(x().value(lengthContext), y().value(lengthContext));
343     } else if (mode == SVGLocatable::ScreenScope) {
344         if (auto* renderer = this-&gt;renderer()) {
345             FloatPoint location;
346             float zoomFactor = 1;
347 
348             // At the SVG/HTML boundary (aka RenderSVGRoot), we apply the localToBorderBoxTransform
349             // to map an element from SVG viewport coordinates to CSS box coordinates.
350             // RenderSVGRoot&#39;s localToAbsolute method expects CSS box coordinates.
351             // We also need to adjust for the zoom level factored into CSS coordinates (bug #96361).
352             if (is&lt;RenderSVGRoot&gt;(*renderer)) {
353                 location = downcast&lt;RenderSVGRoot&gt;(*renderer).localToBorderBoxTransform().mapPoint(location);
354                 zoomFactor = 1 / renderer-&gt;style().effectiveZoom();
355             }
356 
357             // Translate in our CSS parent coordinate space
358             // FIXME: This doesn&#39;t work correctly with CSS transforms.
359             location = renderer-&gt;localToAbsolute(location, UseTransforms);
360             location.scale(zoomFactor);
361 
362             // Be careful here! localToBorderBoxTransform() included the x/y offset coming from the viewBoxToViewTransform(),
363             // so we have to subtract it here (original cause of bug #27183)
364             transform.translate(location.x() - viewBoxTransform.e(), location.y() - viewBoxTransform.f());
365 
366             // Respect scroll offset.
367             if (auto view = makeRefPtr(document().view())) {
368                 LayoutPoint scrollPosition = view-&gt;scrollPosition();
369                 scrollPosition.scale(zoomFactor);
370                 transform.translate(-scrollPosition);
371             }
372         }
373     }
374 
375     return transform.multiply(viewBoxTransform);
376 }
377 
378 bool SVGSVGElement::rendererIsNeeded(const RenderStyle&amp; style)
379 {
380     if (!isValid())
381         return false;
382     // FIXME: We should respect display: none on the documentElement svg element
383     // but many things in FrameView and SVGImage depend on the RenderSVGRoot when
384     // they should instead depend on the RenderView.
385     // https://bugs.webkit.org/show_bug.cgi?id=103493
386     if (document().documentElement() == this)
387         return true;
388     return StyledElement::rendererIsNeeded(style);
389 }
390 
391 RenderPtr&lt;RenderElement&gt; SVGSVGElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
392 {
393     if (isOutermostSVGSVGElement())
394         return createRenderer&lt;RenderSVGRoot&gt;(*this, WTFMove(style));
395     return createRenderer&lt;RenderSVGViewportContainer&gt;(*this, WTFMove(style));
396 }
397 
398 Node::InsertedIntoAncestorResult SVGSVGElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
399 {
400     if (insertionType.connectedToDocument) {
401         document().accessSVGExtensions().addTimeContainer(*this);
402         if (!document().accessSVGExtensions().areAnimationsPaused())
403             unpauseAnimations();
404 
405         // Animations are started at the end of document parsing and after firing the load event,
406         // but if we miss that train (deferred programmatic element insertion for example) we need
407         // to initialize the time container here.
408         if (!document().parsing() &amp;&amp; !document().processingLoadEvent() &amp;&amp; document().loadEventFinished() &amp;&amp; !m_timeContainer-&gt;isStarted())
409             m_timeContainer-&gt;begin();
410     }
411     return SVGGraphicsElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
412 }
413 
414 void SVGSVGElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
415 {
416     if (removalType.disconnectedFromDocument) {
417         document().accessSVGExtensions().removeTimeContainer(*this);
418         pauseAnimations();
419     }
420     SVGGraphicsElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
421 }
422 
423 void SVGSVGElement::pauseAnimations()
424 {
425     if (!m_timeContainer-&gt;isPaused())
426         m_timeContainer-&gt;pause();
427 }
428 
429 void SVGSVGElement::unpauseAnimations()
430 {
431     if (m_timeContainer-&gt;isPaused())
432         m_timeContainer-&gt;resume();
433 }
434 
435 bool SVGSVGElement::animationsPaused() const
436 {
437     return m_timeContainer-&gt;isPaused();
438 }
439 
440 bool SVGSVGElement::hasActiveAnimation() const
441 {
442     return m_timeContainer-&gt;isActive();
443 }
444 
445 float SVGSVGElement::getCurrentTime() const
446 {
447     return narrowPrecisionToFloat(m_timeContainer-&gt;elapsed().value());
448 }
449 
450 void SVGSVGElement::setCurrentTime(float seconds)
451 {
452     if (!std::isfinite(seconds))
453         return;
454     m_timeContainer-&gt;setElapsed(std::max(seconds, 0.0f));
455 }
456 
457 bool SVGSVGElement::selfHasRelativeLengths() const
458 {
459     return x().isRelative()
460         || y().isRelative()
461         || width().isRelative()
462         || height().isRelative()
463         || hasAttribute(SVGNames::viewBoxAttr);
464 }
465 
466 FloatRect SVGSVGElement::currentViewBoxRect() const
467 {
468     if (m_useCurrentView)
469         return m_viewSpec ? m_viewSpec-&gt;viewBox() : FloatRect();
470 
471     FloatRect viewBox = this-&gt;viewBox();
472     if (!viewBox.isEmpty())
473         return viewBox;
474 
475     if (!is&lt;RenderSVGRoot&gt;(renderer()))
476         return { };
477     if (!downcast&lt;RenderSVGRoot&gt;(*renderer()).isEmbeddedThroughSVGImage())
478         return { };
479 
480     Length intrinsicWidth = this-&gt;intrinsicWidth();
481     Length intrinsicHeight = this-&gt;intrinsicHeight();
482     if (!intrinsicWidth.isFixed() || !intrinsicHeight.isFixed())
483         return { };
484 
485     // If no viewBox is specified but non-relative width/height values, then we
486     // should always synthesize a viewBox if we&#39;re embedded through a SVGImage.
487     return { 0, 0, floatValueForLength(intrinsicWidth, 0), floatValueForLength(intrinsicHeight, 0) };
488 }
489 
490 FloatSize SVGSVGElement::currentViewportSize() const
491 {
492     FloatSize viewportSize;
493 
494     if (renderer()) {
495         if (is&lt;RenderSVGRoot&gt;(*renderer())) {
496             auto&amp; root = downcast&lt;RenderSVGRoot&gt;(*renderer());
497             viewportSize = root.contentBoxRect().size() / root.style().effectiveZoom();
498         } else
499             viewportSize = downcast&lt;RenderSVGViewportContainer&gt;(*renderer()).viewport().size();
500     }
501 
502     if (!viewportSize.isEmpty())
503         return viewportSize;
504 
505     if (!(hasIntrinsicWidth() &amp;&amp; hasIntrinsicHeight()))
506         return { };
507 
508     return FloatSize(floatValueForLength(intrinsicWidth(), 0), floatValueForLength(intrinsicHeight(), 0));
509 }
510 
511 bool SVGSVGElement::hasIntrinsicWidth() const
512 {
513     return width().lengthType() != SVGLengthType::Percentage;
514 }
515 
516 bool SVGSVGElement::hasIntrinsicHeight() const
517 {
518     return height().lengthType() != SVGLengthType::Percentage;
519 }
520 
521 Length SVGSVGElement::intrinsicWidth() const
522 {
523     if (width().lengthType() == SVGLengthType::Percentage)
524         return Length(0, Fixed);
525 
526     SVGLengthContext lengthContext(this);
527     return Length(width().value(lengthContext), Fixed);
528 }
529 
530 Length SVGSVGElement::intrinsicHeight() const
531 {
532     if (height().lengthType() == SVGLengthType::Percentage)
533         return Length(0, Fixed);
534 
535     SVGLengthContext lengthContext(this);
536     return Length(height().value(lengthContext), Fixed);
537 }
538 
539 AffineTransform SVGSVGElement::viewBoxToViewTransform(float viewWidth, float viewHeight) const
540 {
541     if (!m_useCurrentView || !m_viewSpec)
542         return SVGFitToViewBox::viewBoxToViewTransform(currentViewBoxRect(), preserveAspectRatio(), viewWidth, viewHeight);
543 
544     AffineTransform transform = SVGFitToViewBox::viewBoxToViewTransform(currentViewBoxRect(), m_viewSpec-&gt;preserveAspectRatio(), viewWidth, viewHeight);
545     transform *= m_viewSpec-&gt;transform()-&gt;concatenate();
546     return transform;
547 }
548 
549 SVGViewElement* SVGSVGElement::findViewAnchor(const String&amp; fragmentIdentifier) const
550 {
551     auto* anchorElement = document().findAnchor(fragmentIdentifier);
552     return is&lt;SVGViewElement&gt;(anchorElement) ? downcast&lt;SVGViewElement&gt;(anchorElement): nullptr;
553 }
554 
555 SVGSVGElement* SVGSVGElement::findRootAnchor(const SVGViewElement* viewElement) const
556 {
557     auto* viewportElement = SVGLocatable::nearestViewportElement(viewElement);
558     return is&lt;SVGSVGElement&gt;(viewportElement) ? downcast&lt;SVGSVGElement&gt;(viewportElement) : nullptr;
559 }
560 
561 SVGSVGElement* SVGSVGElement::findRootAnchor(const String&amp; fragmentIdentifier) const
562 {
563     if (auto* viewElement = findViewAnchor(fragmentIdentifier))
564         return findRootAnchor(viewElement);
565     return nullptr;
566 }
567 
568 bool SVGSVGElement::scrollToFragment(const String&amp; fragmentIdentifier)
569 {
570     auto renderer = this-&gt;renderer();
571     auto view = m_viewSpec;
572     if (view)
573         view-&gt;reset();
574 
575     bool hadUseCurrentView = m_useCurrentView;
576     m_useCurrentView = false;
577 
578     if (fragmentIdentifier.startsWith(&quot;xpointer(&quot;)) {
579         // FIXME: XPointer references are ignored (https://bugs.webkit.org/show_bug.cgi?id=17491)
580         if (renderer &amp;&amp; hadUseCurrentView)
581             RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
582         return false;
583     }
584 
585     if (fragmentIdentifier.startsWith(&quot;svgView(&quot;)) {
586         if (!view)
587             view = &amp;currentView(); // Create the SVGViewSpec.
588         if (view-&gt;parseViewSpec(fragmentIdentifier))
589             m_useCurrentView = true;
590         else
591             view-&gt;reset();
592         if (renderer &amp;&amp; (hadUseCurrentView || m_useCurrentView))
593             RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
594         return m_useCurrentView;
595     }
596 
597     // Spec: If the SVG fragment identifier addresses a &quot;view&quot; element within an SVG document (e.g., MyDrawing.svg#MyView
598     // or MyDrawing.svg#xpointer(id(&#39;MyView&#39;))) then the closest ancestor &quot;svg&quot; element is displayed in the viewport.
599     // Any view specification attributes included on the given &quot;view&quot; element override the corresponding view specification
600     // attributes on the closest ancestor &quot;svg&quot; element.
601     if (auto* viewElement = findViewAnchor(fragmentIdentifier)) {
602         if (auto* rootElement = findRootAnchor(viewElement)) {
603             if (rootElement-&gt;m_currentViewElement) {
604                 ASSERT(rootElement-&gt;m_currentViewElement-&gt;targetElement() == rootElement);
605 
606                 // If the viewElement has changed, remove the link from the SVGViewElement to the previously selected SVGSVGElement.
607                 if (rootElement-&gt;m_currentViewElement != viewElement)
608                     rootElement-&gt;m_currentViewElement-&gt;resetTargetElement();
609             }
610 
611             if (rootElement-&gt;m_currentViewElement != viewElement) {
612                 rootElement-&gt;m_currentViewElement = viewElement;
613                 rootElement-&gt;m_currentViewElement-&gt;setTargetElement(*rootElement);
614             }
615 
616             rootElement-&gt;inheritViewAttributes(*viewElement);
617             if (auto* renderer = rootElement-&gt;renderer())
618                 RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
619             m_currentViewFragmentIdentifier = fragmentIdentifier;
620             return true;
621         }
622     }
623 
624     // FIXME: We need to decide which &lt;svg&gt; to focus on, and zoom to it.
625     // FIXME: We need to actually &quot;highlight&quot; the viewTarget(s).
626     return false;
627 }
628 
629 void SVGSVGElement::resetScrollAnchor()
630 {
631     if (!m_useCurrentView &amp;&amp; m_currentViewFragmentIdentifier.isEmpty())
632         return;
633 
634     if (m_viewSpec)
635         m_viewSpec-&gt;reset();
636 
637     if (!m_currentViewFragmentIdentifier.isEmpty()) {
638         if (auto* rootElement = findRootAnchor(m_currentViewFragmentIdentifier)) {
639             SVGViewSpec&amp; view = rootElement-&gt;currentView();
640             view.setViewBox(viewBox());
641             view.setPreserveAspectRatio(preserveAspectRatio());
642             view.setZoomAndPan(zoomAndPan());
643             m_currentViewFragmentIdentifier = { };
644         }
645     }
646 
647     m_useCurrentView = false;
648     if (renderer())
649         RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer());
650 }
651 
652 void SVGSVGElement::inheritViewAttributes(const SVGViewElement&amp; viewElement)
653 {
654     SVGViewSpec&amp; view = currentView();
655     m_useCurrentView = true;
656 
657     if (viewElement.hasAttribute(SVGNames::viewBoxAttr))
658         view.setViewBox(viewElement.viewBox());
659     else
660         view.setViewBox(viewBox());
661 
662     if (viewElement.hasAttribute(SVGNames::preserveAspectRatioAttr))
663         view.setPreserveAspectRatio(viewElement.preserveAspectRatio());
664     else
665         view.setPreserveAspectRatio(preserveAspectRatio());
666 
667     if (viewElement.hasAttribute(SVGNames::zoomAndPanAttr))
668         view.setZoomAndPan(viewElement.zoomAndPan());
669     else
670         view.setZoomAndPan(zoomAndPan());
671 }
672 
673 void SVGSVGElement::prepareForDocumentSuspension()
674 {
675     pauseAnimations();
676 }
677 
678 void SVGSVGElement::resumeFromDocumentSuspension()
679 {
680     unpauseAnimations();
681 }
682 
683 // getElementById on SVGSVGElement is restricted to only the child subtree defined by the &lt;svg&gt; element.
684 // See http://www.w3.org/TR/SVG11/struct.html#InterfaceSVGSVGElement
685 Element* SVGSVGElement::getElementById(const AtomString&amp; id)
686 {
687     if (id.isNull())
688         return nullptr;
689 
690     auto element = makeRefPtr(treeScope().getElementById(id));
691     if (element &amp;&amp; element-&gt;isDescendantOf(*this))
692         return element.get();
693     if (treeScope().containsMultipleElementsWithId(id)) {
694         for (auto* element : *treeScope().getAllElementsById(id)) {
695             if (element-&gt;isDescendantOf(*this))
696                 return element;
697         }
698     }
699     return nullptr;
700 }
701 
702 bool SVGSVGElement::isValid() const
703 {
704     return SVGTests::isValid();
705 }
706 
707 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/ContainerNode.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
  5  * Copyright (C) 2004-2018 Apple Inc. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;ContainerNode.h&quot;
 25 
 26 #include &quot;AXObjectCache.h&quot;
 27 #include &quot;AllDescendantsCollection.h&quot;
 28 #include &quot;ChildListMutationScope.h&quot;
 29 #include &quot;ClassCollection.h&quot;
 30 #include &quot;CommonVM.h&quot;
 31 #include &quot;ContainerNodeAlgorithms.h&quot;
 32 #include &quot;Editor.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;FloatRect.h&quot;
 35 #include &quot;FrameView.h&quot;
 36 #include &quot;GenericCachedHTMLCollection.h&quot;
 37 #include &quot;HTMLFormControlsCollection.h&quot;
 38 #include &quot;HTMLOptionsCollection.h&quot;
 39 #include &quot;HTMLSlotElement.h&quot;
 40 #include &quot;HTMLTableRowsCollection.h&quot;
 41 #include &quot;InlineTextBox.h&quot;
 42 #include &quot;InspectorInstrumentation.h&quot;
 43 #include &quot;JSNode.h&quot;
 44 #include &quot;LabelsNodeList.h&quot;
 45 #include &quot;MutationEvent.h&quot;
 46 #include &quot;NameNodeList.h&quot;
 47 #include &quot;NodeRareData.h&quot;
 48 #include &quot;NodeRenderStyle.h&quot;
 49 #include &quot;RadioNodeList.h&quot;
 50 #include &quot;RenderBox.h&quot;
 51 #include &quot;RenderTheme.h&quot;
 52 #include &quot;RenderTreeUpdater.h&quot;
 53 #include &quot;RenderWidget.h&quot;
 54 #include &quot;RootInlineBox.h&quot;
<a name="1" id="anc1"></a>
 55 #include &quot;SVGDocumentExtensions.h&quot;
 56 #include &quot;SVGElement.h&quot;
 57 #include &quot;SVGNames.h&quot;
 58 #include &quot;SVGUseElement.h&quot;
 59 #include &quot;ScriptDisallowedScope.h&quot;
 60 #include &quot;SelectorQuery.h&quot;
 61 #include &quot;SlotAssignment.h&quot;
 62 #include &quot;TemplateContentDocumentFragment.h&quot;
 63 #include &lt;algorithm&gt;
 64 #include &lt;wtf/IsoMallocInlines.h&gt;
 65 #include &lt;wtf/Variant.h&gt;
 66 
 67 namespace WebCore {
 68 
 69 WTF_MAKE_ISO_ALLOCATED_IMPL(ContainerNode);
 70 
 71 static void dispatchChildInsertionEvents(Node&amp;);
 72 static void dispatchChildRemovalEvents(Ref&lt;Node&gt;&amp;);
 73 
 74 ChildNodesLazySnapshot* ChildNodesLazySnapshot::latestSnapshot;
 75 
 76 unsigned ScriptDisallowedScope::s_count = 0;
<a name="2" id="anc2"></a><span class="line-modified"> 77 #if ASSERT_ENABLED</span>
 78 ScriptDisallowedScope::EventAllowedScope* ScriptDisallowedScope::EventAllowedScope::s_currentScope = nullptr;
 79 #endif
 80 
 81 ALWAYS_INLINE NodeVector ContainerNode::removeAllChildrenWithScriptAssertion(ChildChangeSource source, DeferChildrenChanged deferChildrenChanged)
 82 {
 83     auto children = collectChildNodes(*this);
 84 
 85     if (source == ContainerNode::ChildChangeSource::API) {
 86         ChildListMutationScope mutation(*this);
 87         for (auto&amp; child : children) {
 88             mutation.willRemoveChild(child.get());
 89             child-&gt;notifyMutationObserversNodeWillDetach();
 90             dispatchChildRemovalEvents(child);
 91         }
 92     } else {
 93         ASSERT(source == ContainerNode::ChildChangeSource::Parser);
 94         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
 95         if (UNLIKELY(document().hasMutationObserversOfType(MutationObserver::ChildList))) {
 96             ChildListMutationScope mutation(*this);
 97             for (auto&amp; child : children)
 98                 mutation.willRemoveChild(child.get());
 99         }
100     }
101 
102     disconnectSubframesIfNeeded(*this, DescendantsOnly);
103 
104     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
105     ScriptDisallowedScope::InMainThread scriptDisallowedScope;
106 
107     if (UNLIKELY(isShadowRoot() || isInShadowTree()))
108         containingShadowRoot()-&gt;willRemoveAllChildren(*this);
109 
110     document().nodeChildrenWillBeRemoved(*this);
111 
112     while (RefPtr&lt;Node&gt; child = m_firstChild) {
113         removeBetween(nullptr, child-&gt;nextSibling(), *child);
114         notifyChildNodeRemoved(*this, *child);
115     }
116 
117     if (deferChildrenChanged == DeferChildrenChanged::No)
118         childrenChanged(ContainerNode::ChildChange { ContainerNode::AllChildrenRemoved, nullptr, nullptr, source });
119 
120     return children;
121 }
122 
123 ALWAYS_INLINE bool ContainerNode::removeNodeWithScriptAssertion(Node&amp; childToRemove, ChildChangeSource source)
124 {
125     Ref&lt;Node&gt; protectedChildToRemove(childToRemove);
126     ASSERT_WITH_SECURITY_IMPLICATION(childToRemove.parentNode() == this);
127     {
128         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
129         ChildListMutationScope(*this).willRemoveChild(childToRemove);
130     }
131 
132     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isEventDispatchAllowedInSubtree(childToRemove));
133     if (source == ContainerNode::ChildChangeSource::API) {
134         childToRemove.notifyMutationObserversNodeWillDetach();
135         dispatchChildRemovalEvents(protectedChildToRemove);
136         if (childToRemove.parentNode() != this)
137             return false;
138     }
139 
140     if (source == ContainerNode::ChildChangeSource::Parser) {
141         // FIXME: Merge these two code paths. It&#39;s a bug in the parser not to update connectedSubframeCount in time.
142         disconnectSubframesIfNeeded(*this, DescendantsOnly);
143     } else {
144         if (is&lt;ContainerNode&gt;(childToRemove))
145             disconnectSubframesIfNeeded(downcast&lt;ContainerNode&gt;(childToRemove), RootAndDescendants);
146     }
147 
148     if (childToRemove.parentNode() != this)
149         return false;
150 
151     ChildChange change;
152     {
153         WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
154         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
155 
156         if (UNLIKELY(isShadowRoot() || isInShadowTree()))
157             containingShadowRoot()-&gt;resolveSlotsBeforeNodeInsertionOrRemoval();
158 
159         document().nodeWillBeRemoved(childToRemove);
160 
161         ASSERT_WITH_SECURITY_IMPLICATION(childToRemove.parentNode() == this);
162         ASSERT(!childToRemove.isDocumentFragment());
163 
164         RefPtr&lt;Node&gt; previousSibling = childToRemove.previousSibling();
165         RefPtr&lt;Node&gt; nextSibling = childToRemove.nextSibling();
166         removeBetween(previousSibling.get(), nextSibling.get(), childToRemove);
167         notifyChildNodeRemoved(*this, childToRemove);
168 
169         change.type = is&lt;Element&gt;(childToRemove) ? ElementRemoved : (is&lt;Text&gt;(childToRemove) ? TextRemoved : NonContentsChildRemoved);
170         change.previousSiblingElement = (!previousSibling || is&lt;Element&gt;(*previousSibling)) ? downcast&lt;Element&gt;(previousSibling.get()) : ElementTraversal::previousSibling(*previousSibling);
171         change.nextSiblingElement = (!nextSibling || is&lt;Element&gt;(*nextSibling)) ? downcast&lt;Element&gt;(nextSibling.get()) : ElementTraversal::nextSibling(*nextSibling);
172         change.source = source;
173     }
174 
175     // FIXME: Move childrenChanged into ScriptDisallowedScope block.
176     childrenChanged(change);
177 
178     return true;
179 }
180 
181 enum class ReplacedAllChildren { No, Yes };
182 
183 template&lt;typename DOMInsertionWork&gt;
184 static ALWAYS_INLINE void executeNodeInsertionWithScriptAssertion(ContainerNode&amp; containerNode, Node&amp; child,
185     ContainerNode::ChildChangeSource source, ReplacedAllChildren replacedAllChildren, DOMInsertionWork doNodeInsertion)
186 {
187     NodeVector postInsertionNotificationTargets;
188     {
189         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
190 
191         if (UNLIKELY(containerNode.isShadowRoot() || containerNode.isInShadowTree()))
192             containerNode.containingShadowRoot()-&gt;resolveSlotsBeforeNodeInsertionOrRemoval();
193 
194         doNodeInsertion();
195         ChildListMutationScope(containerNode).childAdded(child);
196         postInsertionNotificationTargets = notifyChildNodeInserted(containerNode, child);
197     }
198 
199     // FIXME: Move childrenChanged into ScriptDisallowedScope block.
200     if (replacedAllChildren == ReplacedAllChildren::Yes)
201         containerNode.childrenChanged(ContainerNode::ChildChange { ContainerNode::AllChildrenReplaced, nullptr, nullptr, source });
202     else {
203         containerNode.childrenChanged(ContainerNode::ChildChange {
204             child.isElementNode() ? ContainerNode::ElementInserted : (child.isTextNode() ? ContainerNode::TextInserted : ContainerNode::NonContentsChildInserted),
205             ElementTraversal::previousSibling(child),
206             ElementTraversal::nextSibling(child),
207             source
208         });
209     }
210 
211     ASSERT(ScriptDisallowedScope::InMainThread::isEventDispatchAllowedInSubtree(child));
212     for (auto&amp; target : postInsertionNotificationTargets)
213         target-&gt;didFinishInsertingNode();
214 
215     if (source == ContainerNode::ChildChangeSource::API)
216         dispatchChildInsertionEvents(child);
217 }
218 
219 static ExceptionOr&lt;void&gt; collectChildrenAndRemoveFromOldParent(Node&amp; node, NodeVector&amp; nodes)
220 {
221     if (!is&lt;DocumentFragment&gt;(node)) {
222         nodes.append(node);
223         auto* oldParent = node.parentNode();
224         if (!oldParent)
225             return { };
226         return oldParent-&gt;removeChild(node);
227     }
228 
229     nodes = collectChildNodes(node);
230     downcast&lt;DocumentFragment&gt;(node).removeChildren();
231     return { };
232 }
233 
234 // FIXME: This function must get a new name.
235 // It removes all children, not just a category called &quot;detached children&quot;.
236 // So this name is terribly confusing.
237 void ContainerNode::removeDetachedChildren()
238 {
239     if (connectedSubframeCount()) {
240         for (Node* child = firstChild(); child; child = child-&gt;nextSibling())
241             child-&gt;updateAncestorConnectedSubframeCountForRemoval();
242     }
243     // FIXME: We should be able to ASSERT(!attached()) here: https://bugs.webkit.org/show_bug.cgi?id=107801
244     ScriptDisallowedScope::InMainThread scriptDisallowedScope;
245     removeDetachedChildrenInContainer(*this);
246 }
247 
248 static inline void destroyRenderTreeIfNeeded(Node&amp; child)
249 {
250     bool isElement = is&lt;Element&gt;(child);
251     auto hasDisplayContents = isElement &amp;&amp; downcast&lt;Element&gt;(child).hasDisplayContents();
252     if (!child.renderer() &amp;&amp; !hasDisplayContents)
253         return;
254     if (isElement)
255         RenderTreeUpdater::tearDownRenderers(downcast&lt;Element&gt;(child));
256     else if (is&lt;Text&gt;(child))
257         RenderTreeUpdater::tearDownRenderer(downcast&lt;Text&gt;(child));
258 }
259 
260 void ContainerNode::takeAllChildrenFrom(ContainerNode* oldParent)
261 {
262     ASSERT(oldParent);
263 
264     auto children = oldParent-&gt;removeAllChildrenWithScriptAssertion(ChildChangeSource::Parser);
265 
266     // FIXME: assert that we don&#39;t dispatch events here since this container node is still disconnected.
267     for (auto&amp; child : children) {
268         RELEASE_ASSERT(!child-&gt;parentNode() &amp;&amp; &amp;child-&gt;treeScope() == &amp;treeScope());
269         ASSERT(!ensurePreInsertionValidity(child, nullptr).hasException());
270         child-&gt;setTreeScopeRecursively(treeScope());
271         parserAppendChild(child);
272     }
273 }
274 
275 ContainerNode::~ContainerNode()
276 {
277     if (!isDocumentNode())
278         willBeDeletedFrom(document());
279     removeDetachedChildren();
280 }
281 
282 static inline bool isChildTypeAllowed(ContainerNode&amp; newParent, Node&amp; child)
283 {
284     if (!child.isDocumentFragment())
285         return newParent.childTypeAllowed(child.nodeType());
286 
287     for (Node* node = child.firstChild(); node; node = node-&gt;nextSibling()) {
288         if (!newParent.childTypeAllowed(node-&gt;nodeType()))
289             return false;
290     }
291     return true;
292 }
293 
294 static bool containsIncludingHostElements(const Node&amp; possibleAncestor, const Node&amp; node)
295 {
296     const Node* currentNode = &amp;node;
297     do {
298         if (currentNode == &amp;possibleAncestor)
299             return true;
300         const ContainerNode* parent = currentNode-&gt;parentNode();
301         if (!parent) {
302             if (is&lt;ShadowRoot&gt;(currentNode))
303                 parent = downcast&lt;ShadowRoot&gt;(currentNode)-&gt;host();
304             else if (is&lt;DocumentFragment&gt;(*currentNode) &amp;&amp; downcast&lt;DocumentFragment&gt;(*currentNode).isTemplateContent())
305                 parent = static_cast&lt;const TemplateContentDocumentFragment*&gt;(currentNode)-&gt;host();
306         }
307         currentNode = parent;
308     } while (currentNode);
309 
310     return false;
311 }
312 
<a name="3" id="anc3"></a><span class="line-modified">313 enum class ShouldValidateChildParent { No, Yes };</span>
<span class="line-added">314 static inline ExceptionOr&lt;void&gt; checkAcceptChild(ContainerNode&amp; newParent, Node&amp; newChild, const Node* refChild, Document::AcceptChildOperation operation, ShouldValidateChildParent shouldValidateChildParent)</span>
315 {
316     if (containsIncludingHostElements(newChild, newParent))
317         return Exception { HierarchyRequestError };
318 
319     // Use common case fast path if possible.
320     if ((newChild.isElementNode() || newChild.isTextNode()) &amp;&amp; newParent.isElementNode()) {
321         ASSERT(!newParent.isDocumentTypeNode());
322         ASSERT(isChildTypeAllowed(newParent, newChild));
<a name="4" id="anc4"></a><span class="line-modified">323         if (shouldValidateChildParent == ShouldValidateChildParent::Yes &amp;&amp; refChild &amp;&amp; refChild-&gt;parentNode() != &amp;newParent)</span>
324             return Exception { NotFoundError };
325         return { };
326     }
327 
328     // This should never happen, but also protect release builds from tree corruption.
329     ASSERT(!newChild.isPseudoElement());
330     if (newChild.isPseudoElement())
331         return Exception { HierarchyRequestError };
332 
<a name="5" id="anc5"></a><span class="line-modified">333     if (shouldValidateChildParent == ShouldValidateChildParent::Yes &amp;&amp; refChild &amp;&amp; refChild-&gt;parentNode() != &amp;newParent)</span>
334         return Exception { NotFoundError };
335 
336     if (is&lt;Document&gt;(newParent)) {
337         if (!downcast&lt;Document&gt;(newParent).canAcceptChild(newChild, refChild, operation))
338             return Exception { HierarchyRequestError };
339     } else if (!isChildTypeAllowed(newParent, newChild))
340         return Exception { HierarchyRequestError };
341 
342     return { };
343 }
344 
345 static inline ExceptionOr&lt;void&gt; checkAcceptChildGuaranteedNodeTypes(ContainerNode&amp; newParent, Node&amp; newChild)
346 {
347     ASSERT(!newParent.isDocumentTypeNode());
348     ASSERT(isChildTypeAllowed(newParent, newChild));
349     if (containsIncludingHostElements(newChild, newParent))
350         return Exception { HierarchyRequestError };
351     return { };
352 }
353 
354 // https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
355 ExceptionOr&lt;void&gt; ContainerNode::ensurePreInsertionValidity(Node&amp; newChild, Node* refChild)
356 {
<a name="6" id="anc6"></a><span class="line-modified">357     return checkAcceptChild(*this, newChild, refChild, Document::AcceptChildOperation::InsertOrAdd, ShouldValidateChildParent::Yes);</span>
358 }
359 
360 // https://dom.spec.whatwg.org/#concept-node-replace
<a name="7" id="anc7"></a><span class="line-modified">361 static inline ExceptionOr&lt;void&gt; checkPreReplacementValidity(ContainerNode&amp; newParent, Node&amp; newChild, Node&amp; oldChild, ShouldValidateChildParent shouldValidateChildParent)</span>
362 {
<a name="8" id="anc8"></a><span class="line-modified">363     return checkAcceptChild(newParent, newChild, &amp;oldChild, Document::AcceptChildOperation::Replace, shouldValidateChildParent);</span>
364 }
365 
366 ExceptionOr&lt;void&gt; ContainerNode::insertBefore(Node&amp; newChild, Node* refChild)
367 {
368     // Check that this node is not &quot;floating&quot;.
369     // If it is, it can be deleted as a side effect of sending mutation events.
370     ASSERT(refCount() || parentOrShadowHostNode());
371 
372     // Make sure adding the new child is OK.
373     auto validityCheckResult = ensurePreInsertionValidity(newChild, refChild);
374     if (validityCheckResult.hasException())
375         return validityCheckResult.releaseException();
376 
377     if (refChild == &amp;newChild)
378         refChild = newChild.nextSibling();
379 
380     // insertBefore(node, null) is equivalent to appendChild(node)
381     if (!refChild)
382         return appendChildWithoutPreInsertionValidityCheck(newChild);
383 
384     Ref&lt;ContainerNode&gt; protectedThis(*this);
385     Ref&lt;Node&gt; next(*refChild);
386 
387     NodeVector targets;
388     auto removeResult = collectChildrenAndRemoveFromOldParent(newChild, targets);
389     if (removeResult.hasException())
390         return removeResult.releaseException();
391     if (targets.isEmpty())
392         return { };
393 
394     // We need this extra check because collectChildrenAndRemoveFromOldParent() can fire mutation events.
395     for (auto&amp; child : targets) {
396         auto checkAcceptResult = checkAcceptChildGuaranteedNodeTypes(*this, child);
397         if (checkAcceptResult.hasException())
398             return checkAcceptResult.releaseException();
399     }
400 
401     InspectorInstrumentation::willInsertDOMNode(document(), *this);
402 
403     ChildListMutationScope mutation(*this);
404     for (auto&amp; child : targets) {
405         // Due to arbitrary code running in response to a DOM mutation event it&#39;s
406         // possible that &quot;next&quot; is no longer a child of &quot;this&quot;.
407         // It&#39;s also possible that &quot;child&quot; has been inserted elsewhere.
408         // In either of those cases, we&#39;ll just stop.
409         if (next-&gt;parentNode() != this)
410             break;
411         if (child-&gt;parentNode())
412             break;
413 
414         executeNodeInsertionWithScriptAssertion(*this, child.get(), ChildChangeSource::API, ReplacedAllChildren::No, [&amp;] {
415             child-&gt;setTreeScopeRecursively(treeScope());
416             insertBeforeCommon(next, child);
417         });
418     }
419 
420     dispatchSubtreeModifiedEvent();
421     return { };
422 }
423 
424 void ContainerNode::insertBeforeCommon(Node&amp; nextChild, Node&amp; newChild)
425 {
426     ScriptDisallowedScope::InMainThread scriptDisallowedScope;
427 
428     ASSERT(!newChild.parentNode()); // Use insertBefore if you need to handle reparenting (and want DOM mutation events).
429     ASSERT(!newChild.nextSibling());
430     ASSERT(!newChild.previousSibling());
431     ASSERT(!newChild.isShadowRoot());
432 
433     Node* prev = nextChild.previousSibling();
434     ASSERT(m_lastChild != prev);
435     nextChild.setPreviousSibling(&amp;newChild);
436     if (prev) {
437         ASSERT(m_firstChild != &amp;nextChild);
438         ASSERT(prev-&gt;nextSibling() == &amp;nextChild);
439         prev-&gt;setNextSibling(&amp;newChild);
440     } else {
441         ASSERT(m_firstChild == &amp;nextChild);
442         m_firstChild = &amp;newChild;
443     }
444     newChild.setParentNode(this);
445     newChild.setPreviousSibling(prev);
446     newChild.setNextSibling(&amp;nextChild);
447 }
448 
449 void ContainerNode::appendChildCommon(Node&amp; child)
450 {
451     ScriptDisallowedScope::InMainThread scriptDisallowedScope;
452 
453     child.setParentNode(this);
454 
455     if (m_lastChild) {
456         child.setPreviousSibling(m_lastChild);
457         m_lastChild-&gt;setNextSibling(&amp;child);
458     } else
459         m_firstChild = &amp;child;
460 
461     m_lastChild = &amp;child;
462 }
463 
464 void ContainerNode::parserInsertBefore(Node&amp; newChild, Node&amp; nextChild)
465 {
466     ASSERT(nextChild.parentNode() == this);
467     ASSERT(!newChild.isDocumentFragment());
468     ASSERT(!hasTagName(HTMLNames::templateTag));
469 
470     if (nextChild.previousSibling() == &amp;newChild || &amp;nextChild == &amp;newChild) // nothing to do
471         return;
472 
473     executeNodeInsertionWithScriptAssertion(*this, newChild, ChildChangeSource::Parser, ReplacedAllChildren::No, [&amp;] {
474         if (&amp;document() != &amp;newChild.document())
475             document().adoptNode(newChild);
476 
477         insertBeforeCommon(nextChild, newChild);
478 
479         newChild.updateAncestorConnectedSubframeCountForInsertion();
480     });
481 }
482 
483 ExceptionOr&lt;void&gt; ContainerNode::replaceChild(Node&amp; newChild, Node&amp; oldChild)
484 {
485     // Check that this node is not &quot;floating&quot;.
486     // If it is, it can be deleted as a side effect of sending mutation events.
487     ASSERT(refCount() || parentOrShadowHostNode());
488 
489     Ref&lt;ContainerNode&gt; protectedThis(*this);
490 
491     // Make sure replacing the old child with the new is ok
<a name="9" id="anc9"></a><span class="line-modified">492     auto validityResult = checkPreReplacementValidity(*this, newChild, oldChild, ShouldValidateChildParent::Yes);</span>
493     if (validityResult.hasException())
494         return validityResult.releaseException();
495 
<a name="10" id="anc10"></a>



496     RefPtr&lt;Node&gt; refChild = oldChild.nextSibling();
497     if (refChild.get() == &amp;newChild)
498         refChild = refChild-&gt;nextSibling();
499 
500     NodeVector targets;
501     {
502         ChildListMutationScope mutation(*this);
503         auto collectResult = collectChildrenAndRemoveFromOldParent(newChild, targets);
504         if (collectResult.hasException())
505             return collectResult.releaseException();
506     }
507 
508     // Do this one more time because collectChildrenAndRemoveFromOldParent() fires a MutationEvent.
509     for (auto&amp; child : targets) {
<a name="11" id="anc11"></a><span class="line-modified">510         validityResult = checkPreReplacementValidity(*this, child, oldChild, ShouldValidateChildParent::No);</span>
511         if (validityResult.hasException())
512             return validityResult.releaseException();
513     }
514 
515     // Remove the node we&#39;re replacing.
516     Ref&lt;Node&gt; protectOldChild(oldChild);
517 
518     ChildListMutationScope mutation(*this);
519 
520     // If oldChild == newChild then oldChild no longer has a parent at this point.
521     if (oldChild.parentNode()) {
522         auto removeResult = removeChild(oldChild);
523         if (removeResult.hasException())
524             return removeResult.releaseException();
525 
526         // Does this one more time because removeChild() fires a MutationEvent.
527         for (auto&amp; child : targets) {
<a name="12" id="anc12"></a><span class="line-modified">528             validityResult = checkPreReplacementValidity(*this, child, oldChild, ShouldValidateChildParent::No);</span>
529             if (validityResult.hasException())
530                 return validityResult.releaseException();
531         }
532     }
533 
534     InspectorInstrumentation::willInsertDOMNode(document(), *this);
535 
536     // Add the new child(ren).
537     for (auto&amp; child : targets) {
538         // Due to arbitrary code running in response to a DOM mutation event it&#39;s
539         // possible that &quot;refChild&quot; is no longer a child of &quot;this&quot;.
540         // It&#39;s also possible that &quot;child&quot; has been inserted elsewhere.
541         // In either of those cases, we&#39;ll just stop.
542         if (refChild &amp;&amp; refChild-&gt;parentNode() != this)
543             break;
544         if (child-&gt;parentNode())
545             break;
546 
547         executeNodeInsertionWithScriptAssertion(*this, child.get(), ChildChangeSource::API, ReplacedAllChildren::No, [&amp;] {
548             child-&gt;setTreeScopeRecursively(treeScope());
549             if (refChild)
550                 insertBeforeCommon(*refChild, child.get());
551             else
552                 appendChildCommon(child);
553         });
554     }
555 
556     dispatchSubtreeModifiedEvent();
557     return { };
558 }
559 
560 void ContainerNode::disconnectDescendantFrames()
561 {
562     disconnectSubframesIfNeeded(*this, RootAndDescendants);
563 }
564 
565 ExceptionOr&lt;void&gt; ContainerNode::removeChild(Node&amp; oldChild)
566 {
567     // Check that this node is not &quot;floating&quot;.
568     // If it is, it can be deleted as a side effect of sending mutation events.
569     ASSERT(refCount() || parentOrShadowHostNode());
570 
571     Ref&lt;ContainerNode&gt; protectedThis(*this);
572 
573     // NotFoundError: Raised if oldChild is not a child of this node.
574     if (oldChild.parentNode() != this)
575         return Exception { NotFoundError };
576 
577     if (!removeNodeWithScriptAssertion(oldChild, ChildChangeSource::API))
578         return Exception { NotFoundError };
579 
580     rebuildSVGExtensionsElementsIfNecessary();
581     dispatchSubtreeModifiedEvent();
582 
583     return { };
584 }
585 
586 void ContainerNode::removeBetween(Node* previousChild, Node* nextChild, Node&amp; oldChild)
587 {
588     InspectorInstrumentation::didRemoveDOMNode(oldChild.document(), oldChild);
589 
590     ScriptDisallowedScope::InMainThread scriptDisallowedScope;
591 
592     ASSERT(oldChild.parentNode() == this);
593 
594     destroyRenderTreeIfNeeded(oldChild);
595 
596     if (nextChild) {
597         nextChild-&gt;setPreviousSibling(previousChild);
598         oldChild.setNextSibling(nullptr);
599     } else {
600         ASSERT(m_lastChild == &amp;oldChild);
601         m_lastChild = previousChild;
602     }
603     if (previousChild) {
604         previousChild-&gt;setNextSibling(nextChild);
605         oldChild.setPreviousSibling(nullptr);
606     } else {
607         ASSERT(m_firstChild == &amp;oldChild);
608         m_firstChild = nextChild;
609     }
610 
611     ASSERT(m_firstChild != &amp;oldChild);
612     ASSERT(m_lastChild != &amp;oldChild);
613     ASSERT(!oldChild.previousSibling());
614     ASSERT(!oldChild.nextSibling());
615     oldChild.setParentNode(nullptr);
616 
617     oldChild.setTreeScopeRecursively(document());
618 }
619 
620 void ContainerNode::parserRemoveChild(Node&amp; oldChild)
621 {
622     removeNodeWithScriptAssertion(oldChild, ChildChangeSource::Parser);
623 }
624 
625 // https://dom.spec.whatwg.org/#concept-node-replace-all
626 void ContainerNode::replaceAllChildren(std::nullptr_t)
627 {
628     ChildListMutationScope mutation(*this);
629     removeChildren();
630 }
631 
632 // https://dom.spec.whatwg.org/#concept-node-replace-all
633 void ContainerNode::replaceAllChildren(Ref&lt;Node&gt;&amp;&amp; node)
634 {
635     // This function assumes the input node is not a DocumentFragment and is parentless to decrease complexity.
636     ASSERT(!is&lt;DocumentFragment&gt;(node));
637     ASSERT(!node-&gt;parentNode());
638 
639     if (!hasChildNodes()) {
640         // appendChildWithoutPreInsertionValidityCheck() can only throw when node has a parent and we already asserted it doesn&#39;t.
641         auto result = appendChildWithoutPreInsertionValidityCheck(node);
642         ASSERT_UNUSED(result, !result.hasException());
643         return;
644     }
645 
646     Ref&lt;ContainerNode&gt; protectedThis(*this);
647     ChildListMutationScope mutation(*this);
648     removeAllChildrenWithScriptAssertion(ChildChangeSource::API, DeferChildrenChanged::Yes);
649 
650     executeNodeInsertionWithScriptAssertion(*this, node.get(), ChildChangeSource::API, ReplacedAllChildren::Yes, [&amp;] {
651         ASSERT(!ensurePreInsertionValidity(node, nullptr).hasException());
652         InspectorInstrumentation::willInsertDOMNode(document(), *this);
653         node-&gt;setTreeScopeRecursively(treeScope());
654         appendChildCommon(node);
655     });
656 
657     rebuildSVGExtensionsElementsIfNecessary();
658     dispatchSubtreeModifiedEvent();
659 }
660 
661 inline void ContainerNode::rebuildSVGExtensionsElementsIfNecessary()
662 {
663     if (document().svgExtensions() &amp;&amp; !is&lt;SVGUseElement&gt;(shadowHost()))
664         document().accessSVGExtensions().rebuildElements();
665 }
666 
667 // this differs from other remove functions because it forcibly removes all the children,
668 // regardless of read-only status or event exceptions, e.g.
669 void ContainerNode::removeChildren()
670 {
671     if (!m_firstChild)
672         return;
673 
674     Ref&lt;ContainerNode&gt; protectedThis(*this);
675     removeAllChildrenWithScriptAssertion(ChildChangeSource::API);
676 
677     rebuildSVGExtensionsElementsIfNecessary();
678     dispatchSubtreeModifiedEvent();
679 }
680 
681 ExceptionOr&lt;void&gt; ContainerNode::appendChild(Node&amp; newChild)
682 {
683     // Check that this node is not &quot;floating&quot;.
684     // If it is, it can be deleted as a side effect of sending mutation events.
685     ASSERT(refCount() || parentOrShadowHostNode());
686 
687     // Make sure adding the new child is ok
688     auto validityCheckResult = ensurePreInsertionValidity(newChild, nullptr);
689     if (validityCheckResult.hasException())
690         return validityCheckResult.releaseException();
691 
692     return appendChildWithoutPreInsertionValidityCheck(newChild);
693 }
694 
695 ExceptionOr&lt;void&gt; ContainerNode::appendChildWithoutPreInsertionValidityCheck(Node&amp; newChild)
696 {
697     Ref&lt;ContainerNode&gt; protectedThis(*this);
698 
699     NodeVector targets;
700     auto removeResult = collectChildrenAndRemoveFromOldParent(newChild, targets);
701     if (removeResult.hasException())
702         return removeResult.releaseException();
703 
704     if (targets.isEmpty())
705         return { };
706 
707     // We need this extra check because collectChildrenAndRemoveFromOldParent() can fire mutation events.
708     for (auto&amp; child : targets) {
709         auto nodeTypeResult = checkAcceptChildGuaranteedNodeTypes(*this, child);
710         if (nodeTypeResult.hasException())
711             return nodeTypeResult.releaseException();
712     }
713 
714     InspectorInstrumentation::willInsertDOMNode(document(), *this);
715 
716     // Now actually add the child(ren)
717     ChildListMutationScope mutation(*this);
718     for (auto&amp; child : targets) {
719         // If the child has a parent again, just stop what we&#39;re doing, because
720         // that means someone is doing something with DOM mutation -- can&#39;t re-parent
721         // a child that already has a parent.
722         if (child-&gt;parentNode())
723             break;
724 
725         // Append child to the end of the list
726         executeNodeInsertionWithScriptAssertion(*this, child.get(), ChildChangeSource::API, ReplacedAllChildren::No, [&amp;] {
727             child-&gt;setTreeScopeRecursively(treeScope());
728             appendChildCommon(child);
729         });
730     }
731 
732     dispatchSubtreeModifiedEvent();
733     return { };
734 }
735 
736 void ContainerNode::parserAppendChild(Node&amp; newChild)
737 {
738     ASSERT(!newChild.parentNode()); // Use appendChild if you need to handle reparenting (and want DOM mutation events).
739     ASSERT(!newChild.isDocumentFragment());
740     ASSERT(!hasTagName(HTMLNames::templateTag));
741 
742     executeNodeInsertionWithScriptAssertion(*this, newChild, ChildChangeSource::Parser, ReplacedAllChildren::No, [&amp;] {
743         if (&amp;document() != &amp;newChild.document())
744             document().adoptNode(newChild);
745 
746         appendChildCommon(newChild);
747         newChild.setTreeScopeRecursively(treeScope());
748         newChild.updateAncestorConnectedSubframeCountForInsertion();
749     });
750 }
751 
752 static bool affectsElements(const ContainerNode::ChildChange&amp; change)
753 {
754     switch (change.type) {
755     case ContainerNode::ElementInserted:
756     case ContainerNode::ElementRemoved:
757     case ContainerNode::AllChildrenRemoved:
758     case ContainerNode::AllChildrenReplaced:
759         return true;
760     case ContainerNode::TextInserted:
761     case ContainerNode::TextRemoved:
762     case ContainerNode::TextChanged:
763     case ContainerNode::NonContentsChildInserted:
764     case ContainerNode::NonContentsChildRemoved:
765         return false;
766     }
767     ASSERT_NOT_REACHED();
768     return false;
769 }
770 
771 void ContainerNode::childrenChanged(const ChildChange&amp; change)
772 {
773     document().incDOMTreeVersion();
774 
775     if (affectsElements(change))
776         document().invalidateAccessKeyCache();
777 
778     // FIXME: Unclear why it&#39;s always safe to skip this when parser is adding children.
779     // FIXME: Seems like it&#39;s equally safe to skip for TextInserted and TextRemoved as for TextChanged.
780     // FIXME: Should use switch for change type so we remember to update when adding new types.
781     if (change.source == ChildChangeSource::API &amp;&amp; change.type != TextChanged)
782         document().updateRangesAfterChildrenChanged(*this);
783 
784     invalidateNodeListAndCollectionCachesInAncestors();
785 }
786 
787 void ContainerNode::cloneChildNodes(ContainerNode&amp; clone)
788 {
789     Document&amp; targetDocument = clone.document();
790     for (Node* child = firstChild(); child; child = child-&gt;nextSibling()) {
791         auto clonedChild = child-&gt;cloneNodeInternal(targetDocument, CloningOperation::SelfWithTemplateContent);
792         if (!clone.appendChild(clonedChild).hasException() &amp;&amp; is&lt;ContainerNode&gt;(*child))
793             downcast&lt;ContainerNode&gt;(*child).cloneChildNodes(downcast&lt;ContainerNode&gt;(clonedChild.get()));
794     }
795 }
796 
797 unsigned ContainerNode::countChildNodes() const
798 {
799     unsigned count = 0;
800     for (Node* child = firstChild(); child; child = child-&gt;nextSibling())
801         ++count;
802     return count;
803 }
804 
805 Node* ContainerNode::traverseToChildAt(unsigned index) const
806 {
807     Node* child = firstChild();
808     for (; child &amp;&amp; index &gt; 0; --index)
809         child = child-&gt;nextSibling();
810     return child;
811 }
812 
813 static void dispatchChildInsertionEvents(Node&amp; child)
814 {
815     if (child.isInShadowTree())
816         return;
817 
818     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isEventDispatchAllowedInSubtree(child));
819 
820     RefPtr&lt;Node&gt; c = &amp;child;
821     Ref&lt;Document&gt; document(child.document());
822 
823     if (c-&gt;parentNode() &amp;&amp; document-&gt;hasListenerType(Document::DOMNODEINSERTED_LISTENER))
824         c-&gt;dispatchScopedEvent(MutationEvent::create(eventNames().DOMNodeInsertedEvent, Event::CanBubble::Yes, c-&gt;parentNode()));
825 
826     // dispatch the DOMNodeInsertedIntoDocument event to all descendants
827     if (c-&gt;isConnected() &amp;&amp; document-&gt;hasListenerType(Document::DOMNODEINSERTEDINTODOCUMENT_LISTENER)) {
828         for (; c; c = NodeTraversal::next(*c, &amp;child))
829             c-&gt;dispatchScopedEvent(MutationEvent::create(eventNames().DOMNodeInsertedIntoDocumentEvent, Event::CanBubble::No));
830     }
831 }
832 
833 static void dispatchChildRemovalEvents(Ref&lt;Node&gt;&amp; child)
834 {
835     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isEventDispatchAllowedInSubtree(child));
836     InspectorInstrumentation::willRemoveDOMNode(child-&gt;document(), child.get());
837 
838     if (child-&gt;isInShadowTree())
839         return;
840 
841     // FIXME: This doesn&#39;t belong in dispatchChildRemovalEvents.
842     // FIXME: Nodes removed from a shadow tree should also be kept alive.
843     willCreatePossiblyOrphanedTreeByRemoval(child.ptr());
844 
845     Ref&lt;Document&gt; document = child-&gt;document();
846 
847     // dispatch pre-removal mutation events
848     if (child-&gt;parentNode() &amp;&amp; document-&gt;hasListenerType(Document::DOMNODEREMOVED_LISTENER))
849         child-&gt;dispatchScopedEvent(MutationEvent::create(eventNames().DOMNodeRemovedEvent, Event::CanBubble::Yes, child-&gt;parentNode()));
850 
851     // dispatch the DOMNodeRemovedFromDocument event to all descendants
852     if (child-&gt;isConnected() &amp;&amp; document-&gt;hasListenerType(Document::DOMNODEREMOVEDFROMDOCUMENT_LISTENER)) {
853         for (RefPtr&lt;Node&gt; currentNode = child.copyRef(); currentNode; currentNode = NodeTraversal::next(*currentNode, child.ptr()))
854             currentNode-&gt;dispatchScopedEvent(MutationEvent::create(eventNames().DOMNodeRemovedFromDocumentEvent, Event::CanBubble::No));
855     }
856 }
857 
858 ExceptionOr&lt;Element*&gt; ContainerNode::querySelector(const String&amp; selectors)
859 {
860     auto query = document().selectorQueryForString(selectors);
861     if (query.hasException())
862         return query.releaseException();
863     return query.releaseReturnValue().queryFirst(*this);
864 }
865 
866 ExceptionOr&lt;Ref&lt;NodeList&gt;&gt; ContainerNode::querySelectorAll(const String&amp; selectors)
867 {
868     auto query = document().selectorQueryForString(selectors);
869     if (query.hasException())
870         return query.releaseException();
871     return query.releaseReturnValue().queryAll(*this);
872 }
873 
874 Ref&lt;HTMLCollection&gt; ContainerNode::getElementsByTagName(const AtomString&amp; qualifiedName)
875 {
876     ASSERT(!qualifiedName.isNull());
877 
878     if (qualifiedName == starAtom())
879         return ensureRareData().ensureNodeLists().addCachedCollection&lt;AllDescendantsCollection&gt;(*this, AllDescendants);
880 
881     if (document().isHTMLDocument())
882         return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLTagCollection&gt;(*this, ByHTMLTag, qualifiedName);
883     return ensureRareData().ensureNodeLists().addCachedCollection&lt;TagCollection&gt;(*this, ByTag, qualifiedName);
884 }
885 
886 Ref&lt;HTMLCollection&gt; ContainerNode::getElementsByTagNameNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName)
887 {
888     ASSERT(!localName.isNull());
889     return ensureRareData().ensureNodeLists().addCachedTagCollectionNS(*this, namespaceURI.isEmpty() ? nullAtom() : namespaceURI, localName);
890 }
891 
892 Ref&lt;NodeList&gt; ContainerNode::getElementsByName(const String&amp; elementName)
893 {
<a name="13" id="anc13"></a><span class="line-modified">894     return ensureRareData().ensureNodeLists().addCacheWithAtomName&lt;NameNodeList&gt;(*this, elementName);</span>
895 }
896 
897 Ref&lt;HTMLCollection&gt; ContainerNode::getElementsByClassName(const AtomString&amp; classNames)
898 {
899     return ensureRareData().ensureNodeLists().addCachedCollection&lt;ClassCollection&gt;(*this, ByClass, classNames);
900 }
901 
902 Ref&lt;RadioNodeList&gt; ContainerNode::radioNodeList(const AtomString&amp; name)
903 {
904     ASSERT(hasTagName(HTMLNames::formTag) || hasTagName(HTMLNames::fieldsetTag));
<a name="14" id="anc14"></a><span class="line-modified">905     return ensureRareData().ensureNodeLists().addCacheWithAtomName&lt;RadioNodeList&gt;(*this, name);</span>
906 }
907 
908 Ref&lt;HTMLCollection&gt; ContainerNode::children()
909 {
910     return ensureRareData().ensureNodeLists().addCachedCollection&lt;GenericCachedHTMLCollection&lt;CollectionTypeTraits&lt;NodeChildren&gt;::traversalType&gt;&gt;(*this, NodeChildren);
911 }
912 
913 Element* ContainerNode::firstElementChild() const
914 {
915     return ElementTraversal::firstChild(*this);
916 }
917 
918 Element* ContainerNode::lastElementChild() const
919 {
920     return ElementTraversal::lastChild(*this);
921 }
922 
923 unsigned ContainerNode::childElementCount() const
924 {
925     auto children = childrenOfType&lt;Element&gt;(*this);
926     return std::distance(children.begin(), children.end());
927 }
928 
929 ExceptionOr&lt;void&gt; ContainerNode::append(Vector&lt;NodeOrString&gt;&amp;&amp; vector)
930 {
931     auto result = convertNodesOrStringsIntoNode(WTFMove(vector));
932     if (result.hasException())
933         return result.releaseException();
934 
935     auto node = result.releaseReturnValue();
936     if (!node)
937         return { };
938 
939     return appendChild(*node);
940 }
941 
942 ExceptionOr&lt;void&gt; ContainerNode::prepend(Vector&lt;NodeOrString&gt;&amp;&amp; vector)
943 {
944     auto result = convertNodesOrStringsIntoNode(WTFMove(vector));
945     if (result.hasException())
946         return result.releaseException();
947 
948     auto node = result.releaseReturnValue();
949     if (!node)
950         return { };
951 
952     return insertBefore(*node, firstChild());
953 }
954 
955 HTMLCollection* ContainerNode::cachedHTMLCollection(CollectionType type)
956 {
957     return hasRareData() &amp;&amp; rareData()-&gt;nodeLists() ? rareData()-&gt;nodeLists()-&gt;cachedCollection&lt;HTMLCollection&gt;(type) : nullptr;
958 }
959 
960 } // namespace WebCore
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
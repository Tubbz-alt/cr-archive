<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FrameView.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameViewLayoutContext.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
100 
101     Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation) final;
102 
103     bool avoidScrollbarCreation() const final;
104 
105     void setContentsSize(const IntSize&amp;) final;
106     void updateContentsSize() final;
107 
108     const FrameViewLayoutContext&amp; layoutContext() const { return m_layoutContext; }
109     FrameViewLayoutContext&amp; layoutContext() { return m_layoutContext; }
110 
111     WEBCORE_EXPORT bool didFirstLayout() const;
112     void queuePostLayoutCallback(WTF::Function&lt;void ()&gt;&amp;&amp;);
113 
114     WEBCORE_EXPORT bool needsLayout() const;
115     WEBCORE_EXPORT void setNeedsLayoutAfterViewConfigurationChange();
116 
117     void setNeedsCompositingConfigurationUpdate();
118     void setNeedsCompositingGeometryUpdate();
119 
<span class="line-modified">120     void setViewportConstrainedObjectsNeedLayout();</span>
121 
122     WEBCORE_EXPORT bool renderedCharactersExceed(unsigned threshold);
123 
124     void scheduleSelectionUpdate();
125 
126 #if PLATFORM(IOS_FAMILY)
127     bool useCustomFixedPositionLayoutRect() const;
128     IntRect customFixedPositionLayoutRect() const { return m_customFixedPositionLayoutRect; }
129     WEBCORE_EXPORT void setCustomFixedPositionLayoutRect(const IntRect&amp;);
130     bool updateFixedPositionLayoutRect();
131 
132     IntSize customSizeForResizeEvent() const { return m_customSizeForResizeEvent; }
133     WEBCORE_EXPORT void setCustomSizeForResizeEvent(IntSize);
134 
135     WEBCORE_EXPORT void setScrollVelocity(const VelocityData&amp;);
136 #else
137     bool useCustomFixedPositionLayoutRect() const { return false; }
138 #endif
139 
140     void willRecalcStyle();

141     bool updateCompositingLayersAfterStyleChange();
142     void updateCompositingLayersAfterLayout();
143 
144     // Called when changes to the GraphicsLayer hierarchy have to be synchronized with
145     // content rendered via the normal painting path.
146     void setNeedsOneShotDrawingSynchronization();
147 
148     WEBCORE_EXPORT GraphicsLayer* graphicsLayerForPlatformWidget(PlatformWidget);
149     WEBCORE_EXPORT void scheduleLayerFlushAllowingThrottling();
150 
151     WEBCORE_EXPORT TiledBacking* tiledBacking() const;
152 
153     ScrollingNodeID scrollingNodeID() const override;
154     ScrollableArea* scrollableAreaForScrollLayerID(uint64_t) const;
155     bool usesAsyncScrolling() const final;
156 
157     WEBCORE_EXPORT void enterCompositingMode();
158     WEBCORE_EXPORT bool isEnclosedInCompositingLayer() const;
159 
160     // Only used with accelerated compositing, but outside the #ifdef to make linkage easier.
</pre>
<hr />
<pre>
205     IntRect extendedBackgroundRectForPainting() const;
206 
207     bool shouldUpdateWhileOffscreen() const;
208     WEBCORE_EXPORT void setShouldUpdateWhileOffscreen(bool);
209     bool shouldUpdate() const;
210 
211     WEBCORE_EXPORT void adjustViewSize();
212 
213     WEBCORE_EXPORT void setViewportSizeForCSSViewportUnits(IntSize);
214     void clearViewportSizeOverrideForCSSViewportUnits();
215     IntSize viewportSizeForCSSViewportUnits() const;
216 
217     IntRect windowClipRect() const final;
218     WEBCORE_EXPORT IntRect windowClipRectForFrameOwner(const HTMLFrameOwnerElement*, bool clipToLayerContents) const;
219 
220     float visibleContentScaleFactor() const final;
221 
222 #if USE(COORDINATED_GRAPHICS)
223     WEBCORE_EXPORT void setFixedVisibleContentRect(const IntRect&amp;) final;
224 #endif
<span class="line-modified">225     WEBCORE_EXPORT void setScrollPosition(const ScrollPosition&amp;) final;</span>
226     void restoreScrollbar();
227     void scheduleScrollToFocusedElement(SelectionRevealMode);
228     void scrollToFocusedElementImmediatelyIfNeeded();
229     void updateLayerPositionsAfterScrolling() final;
230     void updateCompositingLayersAfterScrolling() final;
<span class="line-modified">231     bool requestScrollPositionUpdate(const ScrollPosition&amp;) final;</span>
232     bool isRubberBandInProgress() const final;
233     WEBCORE_EXPORT ScrollPosition minimumScrollPosition() const final;
234     WEBCORE_EXPORT ScrollPosition maximumScrollPosition() const final;
235 
236     // The scrollOrigin, scrollPosition, minimumScrollPosition and maximumScrollPosition are all affected by frame scale,
237     // but layoutViewport computations require unscaled scroll positions.
238     ScrollPosition unscaledMinimumScrollPosition() const;
239     ScrollPosition unscaledMaximumScrollPosition() const;
240 
241     IntPoint unscaledScrollOrigin() const;
242 
243     WEBCORE_EXPORT LayoutPoint minStableLayoutViewportOrigin() const;
244     WEBCORE_EXPORT LayoutPoint maxStableLayoutViewportOrigin() const;
245 
246     enum class TriggerLayoutOrNot {
247         No,
248         Yes
249     };
250     // This origin can be overridden by setLayoutViewportOverrideRect.
251     void setBaseLayoutViewportOrigin(LayoutPoint, TriggerLayoutOrNot = TriggerLayoutOrNot::Yes);
</pre>
<hr />
<pre>
378     enum CoordinateSpaceForSnapshot { DocumentCoordinates, ViewCoordinates };
379     WEBCORE_EXPORT void paintContentsForSnapshot(GraphicsContext&amp;, const IntRect&amp; imageRect, SelectionInSnapshot shouldPaintSelection, CoordinateSpaceForSnapshot);
380 
381     void paintOverhangAreas(GraphicsContext&amp;, const IntRect&amp; horizontalOverhangArea, const IntRect&amp; verticalOverhangArea, const IntRect&amp; dirtyRect) final;
382     void paintScrollCorner(GraphicsContext&amp;, const IntRect&amp; cornerRect) final;
383     void paintScrollbar(GraphicsContext&amp;, Scrollbar&amp;, const IntRect&amp;) final;
384 
385     WEBCORE_EXPORT Color documentBackgroundColor() const;
386 
387     bool isInChildFrameWithFrameFlattening() const;
388 
389     void startDisallowingLayout() { layoutContext().startDisallowingLayout(); }
390     void endDisallowingLayout() { layoutContext().endDisallowingLayout(); }
391 
392     static MonotonicTime currentPaintTimeStamp() { return sCurrentPaintTimeStamp; } // returns 0 if not painting
393 
394     WEBCORE_EXPORT void updateLayoutAndStyleIfNeededRecursive();
395 
396     void incrementVisuallyNonEmptyCharacterCount(const String&amp;);
397     void incrementVisuallyNonEmptyPixelCount(const IntSize&amp;);
<span class="line-removed">398     void updateIsVisuallyNonEmpty();</span>
<span class="line-removed">399     void updateSignificantRenderedTextMilestoneIfNeeded();</span>
400     bool isVisuallyNonEmpty() const { return m_isVisuallyNonEmpty; }
401     WEBCORE_EXPORT bool qualifiesAsVisuallyNonEmpty() const;
402 
403     WEBCORE_EXPORT void enableAutoSizeMode(bool enable, const IntSize&amp; minSize);
404     WEBCORE_EXPORT void setAutoSizeFixedMinimumHeight(int);
405     bool isAutoSizeEnabled() const { return m_shouldAutoSize; }
406     IntSize autoSizingIntrinsicContentSize() const { return m_autoSizeContentSize; }
407 
408     WEBCORE_EXPORT void forceLayout(bool allowSubtreeLayout = false);
409     WEBCORE_EXPORT void forceLayoutForPagination(const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkFactor, AdjustViewSizeOrNot);
410 
411     // FIXME: This method is retained because of embedded WebViews in AppKit.  When a WebView is embedded inside
412     // some enclosing view with auto-pagination, no call happens to resize the view.  The new pagination model
413     // needs the view to resize as a result of the breaks, but that means that the enclosing view has to potentially
414     // resize around that view.  Auto-pagination uses the bounds of the actual view that&#39;s being printed to determine
415     // the edges of the print operation, so the resize is necessary if the enclosing view&#39;s bounds depend on the
416     // web document&#39;s bounds.
417     //
418     // This is already a problem if the view needs to be a different size because of printer fonts or because of print stylesheets.
419     // Mail/Dictionary work around this problem by using the _layoutForPrinting SPI
420     // to at least get print stylesheets and printer fonts into play, but since WebKit doesn&#39;t know about the page offset or
421     // page size, it can&#39;t actually paginate correctly during _layoutForPrinting.
422     //
423     // We can eventually move Mail to a newer SPI that would let them opt in to the layout-time pagination model,
424     // but that doesn&#39;t solve the general problem of how other AppKit views could opt in to the better model.
425     //
426     // NO OTHER PLATFORM BESIDES MAC SHOULD USE THIS METHOD.
427     WEBCORE_EXPORT void adjustPageHeightDeprecated(float* newBottom, float oldTop, float oldBottom, float bottomLimit);
428 
429     bool scrollToFragment(const URL&amp;);
<span class="line-removed">430     bool scrollToAnchor(const String&amp;);</span>
431     void maintainScrollPositionAtAnchor(ContainerNode*);
432     WEBCORE_EXPORT void scrollElementToRect(const Element&amp;, const IntRect&amp;);
433 
434     // Coordinate systems:
435     //
436     // &quot;View&quot;
437     //     Top left is top left of the FrameView/ScrollView/Widget. Size is Widget::boundsRect().size().
438     //
439     // &quot;TotalContents&quot;
440     //    Relative to ScrollView&#39;s scrolled contents, including headers and footers. Size is totalContentsSize().
441     //
442     // &quot;Contents&quot;
443     //    Relative to ScrollView&#39;s scrolled contents, excluding headers and footers, so top left is top left of the scroll view&#39;s
444     //    document, and size is contentsSize().
445     //
446     // &quot;Absolute&quot;
447     //    Relative to the document&#39;s scroll origin (non-zero for RTL documents), but affected by page zoom and page scale. Mostly used
448     //    in rendering code.
449     //
450     // &quot;Document&quot;
</pre>
<hr />
<pre>
537     typedef HashSet&lt;ScrollableArea*&gt; ScrollableAreaSet;
538     // Returns whether the scrollable area has just been newly added.
539     WEBCORE_EXPORT bool addScrollableArea(ScrollableArea*);
540     // Returns whether the scrollable area has just been removed.
541     WEBCORE_EXPORT bool removeScrollableArea(ScrollableArea*);
542     bool containsScrollableArea(ScrollableArea*) const;
543     const ScrollableAreaSet* scrollableAreas() const { return m_scrollableAreas.get(); }
544 
545     WEBCORE_EXPORT void addChild(Widget&amp;) final;
546     WEBCORE_EXPORT void removeChild(Widget&amp;) final;
547 
548     // This function exists for ports that need to handle wheel events manually.
549     // On Mac WebKit1 the underlying NSScrollView just does the scrolling, but on most other platforms
550     // we need this function in order to do the scroll ourselves.
551     bool wheelEvent(const PlatformWheelEvent&amp;);
552 
553     WEBCORE_EXPORT void setScrollingPerformanceLoggingEnabled(bool);
554 
555     // Page and FrameView both store a Pagination value. Page::pagination() is set only by API,
556     // and FrameView::pagination() is set only by CSS. Page::pagination() will affect all
<span class="line-modified">557     // FrameViews in the page cache, but FrameView::pagination() only affects the current</span>
558     // FrameView. FrameView::pagination() will return m_pagination if it has been set. Otherwise,
559     // it will return Page::pagination() since currently there are no callers that need to
560     // distinguish between the two.
561     const Pagination&amp; pagination() const;
562     void setPagination(const Pagination&amp;);
563 
564 #if ENABLE(CSS_DEVICE_ADAPTATION)
565     IntSize initialViewportSize() const { return m_initialViewportSize; }
566     void setInitialViewportSize(const IntSize&amp; size) { m_initialViewportSize = size; }
567 #endif
568 
569     bool isActive() const final;
570     bool forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const final;
571 
572 #if ENABLE(RUBBER_BANDING)
573     WEBCORE_EXPORT GraphicsLayer* setWantsLayerForTopOverHangArea(bool) const;
574     WEBCORE_EXPORT GraphicsLayer* setWantsLayerForBottomOverHangArea(bool) const;
575 #endif
576 
577     // This function &quot;smears&quot; the &quot;position:fixed&quot; uninflatedBounds for scrolling, returning a rect that is the union of
</pre>
<hr />
<pre>
626     // clipping by other UI elements), whereas visibleContentRect is
627     // internal to WebCore and doesn&#39;t respect those things.
628     WEBCORE_EXPORT void setViewExposedRect(Optional&lt;FloatRect&gt;);
629     Optional&lt;FloatRect&gt; viewExposedRect() const { return m_viewExposedRect; }
630 
631 #if ENABLE(CSS_SCROLL_SNAP)
632     void updateSnapOffsets() final;
633     bool isScrollSnapInProgress() const final;
634     void updateScrollingCoordinatorScrollSnapProperties() const;
635 #endif
636 
637     float adjustScrollStepForFixedContent(float step, ScrollbarOrientation, ScrollGranularity) final;
638 
639     void didChangeScrollOffset();
640 
641     void show() final;
642     void hide() final;
643 
644     bool shouldPlaceBlockDirectionScrollbarOnLeft() const final;
645 
<span class="line-modified">646     void didRestoreFromPageCache();</span>
647 
648     void willDestroyRenderTree();
649     void didDestroyRenderTree();
650 
651     void setSpeculativeTilingDelayDisabledForTesting(bool disabled) { m_speculativeTilingDelayDisabledForTesting = disabled; }
652 
653     WEBCORE_EXPORT FrameFlattening effectiveFrameFlattening() const;
654 
655     WEBCORE_EXPORT void traverseForPaintInvalidation(GraphicsContext::PaintInvalidationReasons);
656     void invalidateControlTints() { traverseForPaintInvalidation(GraphicsContext::PaintInvalidationReasons::InvalidatingControlTints); }
657     void invalidateImagesWithAsyncDecodes() { traverseForPaintInvalidation(GraphicsContext::PaintInvalidationReasons::InvalidatingImagesWithAsyncDecodes); }
658 
659     GraphicsLayer* layerForHorizontalScrollbar() const final;
660     GraphicsLayer* layerForVerticalScrollbar() const final;
661 


662 protected:
663     bool scrollContentsFastPath(const IntSize&amp; scrollDelta, const IntRect&amp; rectToScroll, const IntRect&amp; clipRect) final;
664     void scrollContentsSlowPath(const IntRect&amp; updateRect) final;
665 
666     void repaintSlowRepaintObjects();
667 
668     bool isVerticalDocument() const final;
669     bool isFlippedDocument() const final;
670 
671 private:
672     explicit FrameView(Frame&amp;);
673 
674     void reset();
675     void init();
676 
677     enum LayoutPhase {
678         OutsideLayout,
679         InPreLayout,
680         InRenderTreeLayout,
681         InViewSizeAdjust,
</pre>
<hr />
<pre>
705     void forceLayoutParentViewIfNeeded();
706     void flushPostLayoutTasksQueue();
707     void performPostLayoutTasks();
708     void autoSizeIfEnabled();
709 
710     void applyRecursivelyWithVisibleRect(const WTF::Function&lt;void (FrameView&amp; frameView, const IntRect&amp; visibleRect)&gt;&amp;);
711     void resumeVisibleImageAnimations(const IntRect&amp; visibleRect);
712     void updateScriptedAnimationsAndTimersThrottlingState(const IntRect&amp; visibleRect);
713 
714     void updateLayerFlushThrottling();
715     WEBCORE_EXPORT void adjustTiledBackingCoverage();
716 
717     void repaintContentRectangle(const IntRect&amp;) final;
718     void addedOrRemovedScrollbar() final;
719 
720     void scrollToFocusedElementTimerFired();
721     void scrollToFocusedElementInternal();
722 
723     void delegatesScrollingDidChange() final;
724 


725     // ScrollableArea interface
726     void invalidateScrollbarRect(Scrollbar&amp;, const IntRect&amp;) final;
727     void scrollTo(const ScrollPosition&amp;) final;
728     void setVisibleScrollerThumbRect(const IntRect&amp;) final;
729     ScrollableArea* enclosingScrollableArea() const final;
730     IntRect scrollableAreaBoundingBox(bool* = nullptr) const final;
731     bool scrollAnimatorEnabled() const final;
732     GraphicsLayer* layerForScrollCorner() const final;
733 #if ENABLE(RUBBER_BANDING)
734     GraphicsLayer* layerForOverhangAreas() const final;
735 #endif
736     void contentsResized() final;
737 
<span class="line-removed">738 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">739     void unobscuredContentSizeChanged() final;</span>
<span class="line-removed">740 #endif</span>
<span class="line-removed">741 </span>
742 #if ENABLE(DARK_MODE_CSS)
743     RenderObject* rendererForColorScheme() const;
744 #endif
745 
746     bool usesCompositedScrolling() const final;
747     bool usesMockScrollAnimator() const final;
748     void logMockScrollAnimatorMessage(const String&amp;) const final;
749 




750     // Override scrollbar notifications to update the AXObject cache.
751     void didAddScrollbar(Scrollbar*, ScrollbarOrientation) final;
752     void willRemoveScrollbar(Scrollbar*, ScrollbarOrientation) final;
753 
754     IntSize sizeForResizeEvent() const;
755     void sendResizeEventIfNeeded();
756 


757     void adjustScrollbarsForLayout(bool firstLayout);
758 
759     void handleDeferredScrollbarsUpdateAfterDirectionChange();
760 
761     void updateScrollableAreaSet();
762     void updateLayoutViewport();
763 
764     void notifyPageThatContentAreaWillPaint() const final;
765 
766     void enableSpeculativeTilingIfNeeded();
767     void speculativeTilingEnableTimerFired();
768 
769     void updateEmbeddedObjectsTimerFired();
770     bool updateEmbeddedObjects();
771     void updateEmbeddedObject(RenderEmbeddedObject&amp;);
772 
773     void updateWidgetPositionsTimerFired();
774 

775     void scrollToAnchor();
776     void scrollPositionChanged(const ScrollPosition&amp; oldPosition, const ScrollPosition&amp; newPosition);
777     void scrollableAreaSetChanged();
778     void sendScrollEvent();
779     void resetScrollAnchor();
780 
781     bool hasCustomScrollbars() const;
782 
783     void updateScrollCorner() final;
784 
785     FrameView* parentFrameView() const;
786 
787     bool frameFlatteningEnabled() const;
788     bool isFrameFlatteningValidForThisFrame() const;
789 
790     void markRootOrBodyRendererDirty() const;
791 
792     bool qualifiesAsSignificantRenderedText() const;
793     void updateHasReachedSignificantRenderedTextThreshold();
794 
</pre>
</td>
<td>
<hr />
<pre>
100 
101     Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation) final;
102 
103     bool avoidScrollbarCreation() const final;
104 
105     void setContentsSize(const IntSize&amp;) final;
106     void updateContentsSize() final;
107 
108     const FrameViewLayoutContext&amp; layoutContext() const { return m_layoutContext; }
109     FrameViewLayoutContext&amp; layoutContext() { return m_layoutContext; }
110 
111     WEBCORE_EXPORT bool didFirstLayout() const;
112     void queuePostLayoutCallback(WTF::Function&lt;void ()&gt;&amp;&amp;);
113 
114     WEBCORE_EXPORT bool needsLayout() const;
115     WEBCORE_EXPORT void setNeedsLayoutAfterViewConfigurationChange();
116 
117     void setNeedsCompositingConfigurationUpdate();
118     void setNeedsCompositingGeometryUpdate();
119 
<span class="line-modified">120     WEBCORE_EXPORT void setViewportConstrainedObjectsNeedLayout();</span>
121 
122     WEBCORE_EXPORT bool renderedCharactersExceed(unsigned threshold);
123 
124     void scheduleSelectionUpdate();
125 
126 #if PLATFORM(IOS_FAMILY)
127     bool useCustomFixedPositionLayoutRect() const;
128     IntRect customFixedPositionLayoutRect() const { return m_customFixedPositionLayoutRect; }
129     WEBCORE_EXPORT void setCustomFixedPositionLayoutRect(const IntRect&amp;);
130     bool updateFixedPositionLayoutRect();
131 
132     IntSize customSizeForResizeEvent() const { return m_customSizeForResizeEvent; }
133     WEBCORE_EXPORT void setCustomSizeForResizeEvent(IntSize);
134 
135     WEBCORE_EXPORT void setScrollVelocity(const VelocityData&amp;);
136 #else
137     bool useCustomFixedPositionLayoutRect() const { return false; }
138 #endif
139 
140     void willRecalcStyle();
<span class="line-added">141     void styleDidChange() override;</span>
142     bool updateCompositingLayersAfterStyleChange();
143     void updateCompositingLayersAfterLayout();
144 
145     // Called when changes to the GraphicsLayer hierarchy have to be synchronized with
146     // content rendered via the normal painting path.
147     void setNeedsOneShotDrawingSynchronization();
148 
149     WEBCORE_EXPORT GraphicsLayer* graphicsLayerForPlatformWidget(PlatformWidget);
150     WEBCORE_EXPORT void scheduleLayerFlushAllowingThrottling();
151 
152     WEBCORE_EXPORT TiledBacking* tiledBacking() const;
153 
154     ScrollingNodeID scrollingNodeID() const override;
155     ScrollableArea* scrollableAreaForScrollLayerID(uint64_t) const;
156     bool usesAsyncScrolling() const final;
157 
158     WEBCORE_EXPORT void enterCompositingMode();
159     WEBCORE_EXPORT bool isEnclosedInCompositingLayer() const;
160 
161     // Only used with accelerated compositing, but outside the #ifdef to make linkage easier.
</pre>
<hr />
<pre>
206     IntRect extendedBackgroundRectForPainting() const;
207 
208     bool shouldUpdateWhileOffscreen() const;
209     WEBCORE_EXPORT void setShouldUpdateWhileOffscreen(bool);
210     bool shouldUpdate() const;
211 
212     WEBCORE_EXPORT void adjustViewSize();
213 
214     WEBCORE_EXPORT void setViewportSizeForCSSViewportUnits(IntSize);
215     void clearViewportSizeOverrideForCSSViewportUnits();
216     IntSize viewportSizeForCSSViewportUnits() const;
217 
218     IntRect windowClipRect() const final;
219     WEBCORE_EXPORT IntRect windowClipRectForFrameOwner(const HTMLFrameOwnerElement*, bool clipToLayerContents) const;
220 
221     float visibleContentScaleFactor() const final;
222 
223 #if USE(COORDINATED_GRAPHICS)
224     WEBCORE_EXPORT void setFixedVisibleContentRect(const IntRect&amp;) final;
225 #endif
<span class="line-modified">226     WEBCORE_EXPORT void setScrollPosition(const ScrollPosition&amp;, ScrollClamping = ScrollClamping::Clamped) final;</span>
227     void restoreScrollbar();
228     void scheduleScrollToFocusedElement(SelectionRevealMode);
229     void scrollToFocusedElementImmediatelyIfNeeded();
230     void updateLayerPositionsAfterScrolling() final;
231     void updateCompositingLayersAfterScrolling() final;
<span class="line-modified">232     bool requestScrollPositionUpdate(const ScrollPosition&amp;, ScrollType = ScrollType::User, ScrollClamping = ScrollClamping::Clamped) final;</span>
233     bool isRubberBandInProgress() const final;
234     WEBCORE_EXPORT ScrollPosition minimumScrollPosition() const final;
235     WEBCORE_EXPORT ScrollPosition maximumScrollPosition() const final;
236 
237     // The scrollOrigin, scrollPosition, minimumScrollPosition and maximumScrollPosition are all affected by frame scale,
238     // but layoutViewport computations require unscaled scroll positions.
239     ScrollPosition unscaledMinimumScrollPosition() const;
240     ScrollPosition unscaledMaximumScrollPosition() const;
241 
242     IntPoint unscaledScrollOrigin() const;
243 
244     WEBCORE_EXPORT LayoutPoint minStableLayoutViewportOrigin() const;
245     WEBCORE_EXPORT LayoutPoint maxStableLayoutViewportOrigin() const;
246 
247     enum class TriggerLayoutOrNot {
248         No,
249         Yes
250     };
251     // This origin can be overridden by setLayoutViewportOverrideRect.
252     void setBaseLayoutViewportOrigin(LayoutPoint, TriggerLayoutOrNot = TriggerLayoutOrNot::Yes);
</pre>
<hr />
<pre>
379     enum CoordinateSpaceForSnapshot { DocumentCoordinates, ViewCoordinates };
380     WEBCORE_EXPORT void paintContentsForSnapshot(GraphicsContext&amp;, const IntRect&amp; imageRect, SelectionInSnapshot shouldPaintSelection, CoordinateSpaceForSnapshot);
381 
382     void paintOverhangAreas(GraphicsContext&amp;, const IntRect&amp; horizontalOverhangArea, const IntRect&amp; verticalOverhangArea, const IntRect&amp; dirtyRect) final;
383     void paintScrollCorner(GraphicsContext&amp;, const IntRect&amp; cornerRect) final;
384     void paintScrollbar(GraphicsContext&amp;, Scrollbar&amp;, const IntRect&amp;) final;
385 
386     WEBCORE_EXPORT Color documentBackgroundColor() const;
387 
388     bool isInChildFrameWithFrameFlattening() const;
389 
390     void startDisallowingLayout() { layoutContext().startDisallowingLayout(); }
391     void endDisallowingLayout() { layoutContext().endDisallowingLayout(); }
392 
393     static MonotonicTime currentPaintTimeStamp() { return sCurrentPaintTimeStamp; } // returns 0 if not painting
394 
395     WEBCORE_EXPORT void updateLayoutAndStyleIfNeededRecursive();
396 
397     void incrementVisuallyNonEmptyCharacterCount(const String&amp;);
398     void incrementVisuallyNonEmptyPixelCount(const IntSize&amp;);


399     bool isVisuallyNonEmpty() const { return m_isVisuallyNonEmpty; }
400     WEBCORE_EXPORT bool qualifiesAsVisuallyNonEmpty() const;
401 
402     WEBCORE_EXPORT void enableAutoSizeMode(bool enable, const IntSize&amp; minSize);
403     WEBCORE_EXPORT void setAutoSizeFixedMinimumHeight(int);
404     bool isAutoSizeEnabled() const { return m_shouldAutoSize; }
405     IntSize autoSizingIntrinsicContentSize() const { return m_autoSizeContentSize; }
406 
407     WEBCORE_EXPORT void forceLayout(bool allowSubtreeLayout = false);
408     WEBCORE_EXPORT void forceLayoutForPagination(const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkFactor, AdjustViewSizeOrNot);
409 
410     // FIXME: This method is retained because of embedded WebViews in AppKit.  When a WebView is embedded inside
411     // some enclosing view with auto-pagination, no call happens to resize the view.  The new pagination model
412     // needs the view to resize as a result of the breaks, but that means that the enclosing view has to potentially
413     // resize around that view.  Auto-pagination uses the bounds of the actual view that&#39;s being printed to determine
414     // the edges of the print operation, so the resize is necessary if the enclosing view&#39;s bounds depend on the
415     // web document&#39;s bounds.
416     //
417     // This is already a problem if the view needs to be a different size because of printer fonts or because of print stylesheets.
418     // Mail/Dictionary work around this problem by using the _layoutForPrinting SPI
419     // to at least get print stylesheets and printer fonts into play, but since WebKit doesn&#39;t know about the page offset or
420     // page size, it can&#39;t actually paginate correctly during _layoutForPrinting.
421     //
422     // We can eventually move Mail to a newer SPI that would let them opt in to the layout-time pagination model,
423     // but that doesn&#39;t solve the general problem of how other AppKit views could opt in to the better model.
424     //
425     // NO OTHER PLATFORM BESIDES MAC SHOULD USE THIS METHOD.
426     WEBCORE_EXPORT void adjustPageHeightDeprecated(float* newBottom, float oldTop, float oldBottom, float bottomLimit);
427 
428     bool scrollToFragment(const URL&amp;);

429     void maintainScrollPositionAtAnchor(ContainerNode*);
430     WEBCORE_EXPORT void scrollElementToRect(const Element&amp;, const IntRect&amp;);
431 
432     // Coordinate systems:
433     //
434     // &quot;View&quot;
435     //     Top left is top left of the FrameView/ScrollView/Widget. Size is Widget::boundsRect().size().
436     //
437     // &quot;TotalContents&quot;
438     //    Relative to ScrollView&#39;s scrolled contents, including headers and footers. Size is totalContentsSize().
439     //
440     // &quot;Contents&quot;
441     //    Relative to ScrollView&#39;s scrolled contents, excluding headers and footers, so top left is top left of the scroll view&#39;s
442     //    document, and size is contentsSize().
443     //
444     // &quot;Absolute&quot;
445     //    Relative to the document&#39;s scroll origin (non-zero for RTL documents), but affected by page zoom and page scale. Mostly used
446     //    in rendering code.
447     //
448     // &quot;Document&quot;
</pre>
<hr />
<pre>
535     typedef HashSet&lt;ScrollableArea*&gt; ScrollableAreaSet;
536     // Returns whether the scrollable area has just been newly added.
537     WEBCORE_EXPORT bool addScrollableArea(ScrollableArea*);
538     // Returns whether the scrollable area has just been removed.
539     WEBCORE_EXPORT bool removeScrollableArea(ScrollableArea*);
540     bool containsScrollableArea(ScrollableArea*) const;
541     const ScrollableAreaSet* scrollableAreas() const { return m_scrollableAreas.get(); }
542 
543     WEBCORE_EXPORT void addChild(Widget&amp;) final;
544     WEBCORE_EXPORT void removeChild(Widget&amp;) final;
545 
546     // This function exists for ports that need to handle wheel events manually.
547     // On Mac WebKit1 the underlying NSScrollView just does the scrolling, but on most other platforms
548     // we need this function in order to do the scroll ourselves.
549     bool wheelEvent(const PlatformWheelEvent&amp;);
550 
551     WEBCORE_EXPORT void setScrollingPerformanceLoggingEnabled(bool);
552 
553     // Page and FrameView both store a Pagination value. Page::pagination() is set only by API,
554     // and FrameView::pagination() is set only by CSS. Page::pagination() will affect all
<span class="line-modified">555     // FrameViews in the back/forward cache, but FrameView::pagination() only affects the current</span>
556     // FrameView. FrameView::pagination() will return m_pagination if it has been set. Otherwise,
557     // it will return Page::pagination() since currently there are no callers that need to
558     // distinguish between the two.
559     const Pagination&amp; pagination() const;
560     void setPagination(const Pagination&amp;);
561 
562 #if ENABLE(CSS_DEVICE_ADAPTATION)
563     IntSize initialViewportSize() const { return m_initialViewportSize; }
564     void setInitialViewportSize(const IntSize&amp; size) { m_initialViewportSize = size; }
565 #endif
566 
567     bool isActive() const final;
568     bool forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const final;
569 
570 #if ENABLE(RUBBER_BANDING)
571     WEBCORE_EXPORT GraphicsLayer* setWantsLayerForTopOverHangArea(bool) const;
572     WEBCORE_EXPORT GraphicsLayer* setWantsLayerForBottomOverHangArea(bool) const;
573 #endif
574 
575     // This function &quot;smears&quot; the &quot;position:fixed&quot; uninflatedBounds for scrolling, returning a rect that is the union of
</pre>
<hr />
<pre>
624     // clipping by other UI elements), whereas visibleContentRect is
625     // internal to WebCore and doesn&#39;t respect those things.
626     WEBCORE_EXPORT void setViewExposedRect(Optional&lt;FloatRect&gt;);
627     Optional&lt;FloatRect&gt; viewExposedRect() const { return m_viewExposedRect; }
628 
629 #if ENABLE(CSS_SCROLL_SNAP)
630     void updateSnapOffsets() final;
631     bool isScrollSnapInProgress() const final;
632     void updateScrollingCoordinatorScrollSnapProperties() const;
633 #endif
634 
635     float adjustScrollStepForFixedContent(float step, ScrollbarOrientation, ScrollGranularity) final;
636 
637     void didChangeScrollOffset();
638 
639     void show() final;
640     void hide() final;
641 
642     bool shouldPlaceBlockDirectionScrollbarOnLeft() const final;
643 
<span class="line-modified">644     void didRestoreFromBackForwardCache();</span>
645 
646     void willDestroyRenderTree();
647     void didDestroyRenderTree();
648 
649     void setSpeculativeTilingDelayDisabledForTesting(bool disabled) { m_speculativeTilingDelayDisabledForTesting = disabled; }
650 
651     WEBCORE_EXPORT FrameFlattening effectiveFrameFlattening() const;
652 
653     WEBCORE_EXPORT void traverseForPaintInvalidation(GraphicsContext::PaintInvalidationReasons);
654     void invalidateControlTints() { traverseForPaintInvalidation(GraphicsContext::PaintInvalidationReasons::InvalidatingControlTints); }
655     void invalidateImagesWithAsyncDecodes() { traverseForPaintInvalidation(GraphicsContext::PaintInvalidationReasons::InvalidatingImagesWithAsyncDecodes); }
656 
657     GraphicsLayer* layerForHorizontalScrollbar() const final;
658     GraphicsLayer* layerForVerticalScrollbar() const final;
659 
<span class="line-added">660     void renderLayerDidScroll(const RenderLayer&amp;);</span>
<span class="line-added">661 </span>
662 protected:
663     bool scrollContentsFastPath(const IntSize&amp; scrollDelta, const IntRect&amp; rectToScroll, const IntRect&amp; clipRect) final;
664     void scrollContentsSlowPath(const IntRect&amp; updateRect) final;
665 
666     void repaintSlowRepaintObjects();
667 
668     bool isVerticalDocument() const final;
669     bool isFlippedDocument() const final;
670 
671 private:
672     explicit FrameView(Frame&amp;);
673 
674     void reset();
675     void init();
676 
677     enum LayoutPhase {
678         OutsideLayout,
679         InPreLayout,
680         InRenderTreeLayout,
681         InViewSizeAdjust,
</pre>
<hr />
<pre>
705     void forceLayoutParentViewIfNeeded();
706     void flushPostLayoutTasksQueue();
707     void performPostLayoutTasks();
708     void autoSizeIfEnabled();
709 
710     void applyRecursivelyWithVisibleRect(const WTF::Function&lt;void (FrameView&amp; frameView, const IntRect&amp; visibleRect)&gt;&amp;);
711     void resumeVisibleImageAnimations(const IntRect&amp; visibleRect);
712     void updateScriptedAnimationsAndTimersThrottlingState(const IntRect&amp; visibleRect);
713 
714     void updateLayerFlushThrottling();
715     WEBCORE_EXPORT void adjustTiledBackingCoverage();
716 
717     void repaintContentRectangle(const IntRect&amp;) final;
718     void addedOrRemovedScrollbar() final;
719 
720     void scrollToFocusedElementTimerFired();
721     void scrollToFocusedElementInternal();
722 
723     void delegatesScrollingDidChange() final;
724 
<span class="line-added">725     void unobscuredContentSizeChanged() final;</span>
<span class="line-added">726 </span>
727     // ScrollableArea interface
728     void invalidateScrollbarRect(Scrollbar&amp;, const IntRect&amp;) final;
729     void scrollTo(const ScrollPosition&amp;) final;
730     void setVisibleScrollerThumbRect(const IntRect&amp;) final;
731     ScrollableArea* enclosingScrollableArea() const final;
732     IntRect scrollableAreaBoundingBox(bool* = nullptr) const final;
733     bool scrollAnimatorEnabled() const final;
734     GraphicsLayer* layerForScrollCorner() const final;
735 #if ENABLE(RUBBER_BANDING)
736     GraphicsLayer* layerForOverhangAreas() const final;
737 #endif
738     void contentsResized() final;
739 




740 #if ENABLE(DARK_MODE_CSS)
741     RenderObject* rendererForColorScheme() const;
742 #endif
743 
744     bool usesCompositedScrolling() const final;
745     bool usesMockScrollAnimator() const final;
746     void logMockScrollAnimatorMessage(const String&amp;) const final;
747 
<span class="line-added">748     bool styleHidesScrollbarWithOrientation(ScrollbarOrientation) const;</span>
<span class="line-added">749     bool horizontalScrollbarHiddenByStyle() const final;</span>
<span class="line-added">750     bool verticalScrollbarHiddenByStyle() const final;</span>
<span class="line-added">751 </span>
752     // Override scrollbar notifications to update the AXObject cache.
753     void didAddScrollbar(Scrollbar*, ScrollbarOrientation) final;
754     void willRemoveScrollbar(Scrollbar*, ScrollbarOrientation) final;
755 
756     IntSize sizeForResizeEvent() const;
757     void sendResizeEventIfNeeded();
758 
<span class="line-added">759     RefPtr&lt;Element&gt; rootElementForCustomScrollbarPartStyle(PseudoId) const;</span>
<span class="line-added">760 </span>
761     void adjustScrollbarsForLayout(bool firstLayout);
762 
763     void handleDeferredScrollbarsUpdateAfterDirectionChange();
764 
765     void updateScrollableAreaSet();
766     void updateLayoutViewport();
767 
768     void notifyPageThatContentAreaWillPaint() const final;
769 
770     void enableSpeculativeTilingIfNeeded();
771     void speculativeTilingEnableTimerFired();
772 
773     void updateEmbeddedObjectsTimerFired();
774     bool updateEmbeddedObjects();
775     void updateEmbeddedObject(RenderEmbeddedObject&amp;);
776 
777     void updateWidgetPositionsTimerFired();
778 
<span class="line-added">779     bool scrollToFragmentInternal(const String&amp;);</span>
780     void scrollToAnchor();
781     void scrollPositionChanged(const ScrollPosition&amp; oldPosition, const ScrollPosition&amp; newPosition);
782     void scrollableAreaSetChanged();
783     void sendScrollEvent();
784     void resetScrollAnchor();
785 
786     bool hasCustomScrollbars() const;
787 
788     void updateScrollCorner() final;
789 
790     FrameView* parentFrameView() const;
791 
792     bool frameFlatteningEnabled() const;
793     bool isFrameFlatteningValidForThisFrame() const;
794 
795     void markRootOrBodyRendererDirty() const;
796 
797     bool qualifiesAsSignificantRenderedText() const;
798     void updateHasReachedSignificantRenderedTextThreshold();
799 
</pre>
</td>
</tr>
</table>
<center><a href="FrameView.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameViewLayoutContext.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
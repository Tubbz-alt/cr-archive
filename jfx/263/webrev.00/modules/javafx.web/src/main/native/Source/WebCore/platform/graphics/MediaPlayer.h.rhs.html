<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/MediaPlayer.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2007-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(VIDEO)
 29 
 30 #include &quot;AudioTrackPrivate.h&quot;
 31 #include &quot;ContentType.h&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 32 #include &quot;GraphicsTypesGL.h&quot;</span>

 33 #include &quot;LayoutRect.h&quot;
 34 #include &quot;LegacyCDMSession.h&quot;
 35 #include &quot;MediaPlayerEnums.h&quot;
 36 #include &quot;NativeImage.h&quot;
 37 #include &quot;PlatformLayer.h&quot;
 38 #include &quot;PlatformMediaResourceLoader.h&quot;
 39 #include &quot;PlatformMediaSession.h&quot;
 40 #include &quot;SecurityOriginHash.h&quot;
 41 #include &quot;Timer.h&quot;
 42 #include &lt;wtf/URL.h&gt;
 43 #include &quot;VideoTrackPrivate.h&quot;
 44 #include &lt;JavaScriptCore/Uint8Array.h&gt;
 45 #include &lt;wtf/Function.h&gt;
 46 #include &lt;wtf/HashSet.h&gt;
 47 #include &lt;wtf/Logger.h&gt;
 48 #include &lt;wtf/MediaTime.h&gt;
 49 #include &lt;wtf/WallTime.h&gt;
 50 #include &lt;wtf/text/StringHash.h&gt;
 51 
 52 #if ENABLE(AVF_CAPTIONS)
 53 #include &quot;PlatformTextTrack.h&quot;
 54 #endif
 55 
 56 OBJC_CLASS AVPlayer;
 57 OBJC_CLASS NSArray;
 58 
 59 namespace WebCore {
 60 
 61 class AudioSourceProvider;
 62 class CDMInstance;
 63 class CachedResourceLoader;
<a name="2" id="anc2"></a><span class="line-modified"> 64 class GraphicsContextGLOpenGL;</span>
 65 class GraphicsContext;
<a name="3" id="anc3"></a><span class="line-added"> 66 class InbandTextTrackPrivate;</span>
 67 class LegacyCDMSessionClient;
 68 class MediaPlaybackTarget;
 69 class MediaPlayer;
<a name="4" id="anc4"></a><span class="line-added"> 70 class MediaPlayerFactory;</span>
 71 class MediaPlayerPrivateInterface;
 72 class MediaPlayerRequestInstallMissingPluginsCallback;
 73 class MediaSourcePrivateClient;
 74 class MediaStreamPrivate;
 75 class PlatformTimeRanges;
 76 class TextTrackRepresentation;
 77 
 78 struct Cookie;
 79 struct GraphicsDeviceAdapter;
<a name="5" id="anc5"></a>
 80 
 81 struct MediaEngineSupportParameters {
 82     ContentType type;
 83     URL url;
 84     bool isMediaSource { false };
 85     bool isMediaStream { false };
 86     Vector&lt;ContentType&gt; contentTypesRequiringHardwareSupport;
<a name="6" id="anc6"></a><span class="line-added"> 87 </span>
<span class="line-added"> 88     template&lt;class Encoder&gt;</span>
<span class="line-added"> 89     void encode(Encoder&amp; encoder) const</span>
<span class="line-added"> 90     {</span>
<span class="line-added"> 91         encoder &lt;&lt; type;</span>
<span class="line-added"> 92         encoder &lt;&lt; url;</span>
<span class="line-added"> 93         encoder &lt;&lt; isMediaSource;</span>
<span class="line-added"> 94         encoder &lt;&lt; isMediaStream;</span>
<span class="line-added"> 95         encoder &lt;&lt; contentTypesRequiringHardwareSupport;</span>
<span class="line-added"> 96     }</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98     template &lt;class Decoder&gt;</span>
<span class="line-added"> 99     static Optional&lt;MediaEngineSupportParameters&gt; decode(Decoder&amp; decoder)</span>
<span class="line-added">100     {</span>
<span class="line-added">101         Optional&lt;ContentType&gt; type;</span>
<span class="line-added">102         decoder &gt;&gt; type;</span>
<span class="line-added">103         if (!type)</span>
<span class="line-added">104             return WTF::nullopt;</span>
<span class="line-added">105 </span>
<span class="line-added">106         Optional&lt;URL&gt; url;</span>
<span class="line-added">107         decoder &gt;&gt; url;</span>
<span class="line-added">108         if (!url)</span>
<span class="line-added">109             return WTF::nullopt;</span>
<span class="line-added">110 </span>
<span class="line-added">111         Optional&lt;bool&gt; isMediaSource;</span>
<span class="line-added">112         decoder &gt;&gt; isMediaSource;</span>
<span class="line-added">113         if (!isMediaSource)</span>
<span class="line-added">114             return WTF::nullopt;</span>
<span class="line-added">115 </span>
<span class="line-added">116         Optional&lt;bool&gt; isMediaStream;</span>
<span class="line-added">117         decoder &gt;&gt; isMediaStream;</span>
<span class="line-added">118         if (!isMediaStream)</span>
<span class="line-added">119             return WTF::nullopt;</span>
<span class="line-added">120 </span>
<span class="line-added">121         Optional&lt;Vector&lt;ContentType&gt;&gt; typesRequiringHardware;</span>
<span class="line-added">122         decoder &gt;&gt; typesRequiringHardware;</span>
<span class="line-added">123         if (!typesRequiringHardware)</span>
<span class="line-added">124             return WTF::nullopt;</span>
<span class="line-added">125 </span>
<span class="line-added">126         return {{ WTFMove(*type), WTFMove(*url), *isMediaSource, *isMediaStream, *typesRequiringHardware }};</span>
<span class="line-added">127     }</span>
128 };
129 
130 struct VideoPlaybackQualityMetrics {
131     uint32_t totalVideoFrames { 0 };
132     uint32_t droppedVideoFrames { 0 };
133     uint32_t corruptedVideoFrames { 0 };
134     double totalFrameDelay { 0 };
135     uint32_t displayCompositedVideoFrames { 0 };
136 };
137 
138 class MediaPlayerClient {
139 public:
140     virtual ~MediaPlayerClient() = default;
141 
142     // the network state has changed
<a name="7" id="anc7"></a><span class="line-modified">143     virtual void mediaPlayerNetworkStateChanged() { }</span>
144 
145     // the ready state has changed
<a name="8" id="anc8"></a><span class="line-modified">146     virtual void mediaPlayerReadyStateChanged() { }</span>
147 
148     // the volume state has changed
<a name="9" id="anc9"></a><span class="line-modified">149     virtual void mediaPlayerVolumeChanged() { }</span>
150 
151     // the mute state has changed
<a name="10" id="anc10"></a><span class="line-modified">152     virtual void mediaPlayerMuteChanged() { }</span>
153 
154     // time has jumped, eg. not as a result of normal playback
<a name="11" id="anc11"></a><span class="line-modified">155     virtual void mediaPlayerTimeChanged() { }</span>
156 
157     // the media file duration has changed, or is now known
<a name="12" id="anc12"></a><span class="line-modified">158     virtual void mediaPlayerDurationChanged() { }</span>
159 
160     // the playback rate has changed
<a name="13" id="anc13"></a><span class="line-modified">161     virtual void mediaPlayerRateChanged() { }</span>
162 
163     // the play/pause status changed
<a name="14" id="anc14"></a><span class="line-modified">164     virtual void mediaPlayerPlaybackStateChanged() { }</span>





165 
166     // The MediaPlayer could not discover an engine which supports the requested resource.
<a name="15" id="anc15"></a><span class="line-modified">167     virtual void mediaPlayerResourceNotSupported() { }</span>
168 
169 // Presentation-related methods
170     // a new frame of video is available
<a name="16" id="anc16"></a><span class="line-modified">171     virtual void mediaPlayerRepaint() { }</span>
172 
173     // the movie size has changed
<a name="17" id="anc17"></a><span class="line-modified">174     virtual void mediaPlayerSizeChanged() { }</span>
175 
<a name="18" id="anc18"></a><span class="line-modified">176     virtual void mediaPlayerEngineUpdated() { }</span>
177 
178     // The first frame of video is available to render. A media engine need only make this callback if the
179     // first frame is not available immediately when prepareForRendering is called.
<a name="19" id="anc19"></a><span class="line-modified">180     virtual void mediaPlayerFirstVideoFrameAvailable() { }</span>
181 
182     // A characteristic of the media file, eg. video, audio, closed captions, etc, has changed.
<a name="20" id="anc20"></a><span class="line-modified">183     virtual void mediaPlayerCharacteristicChanged() { }</span>
184 
185     // whether the rendering system can accelerate the display of this MediaPlayer.
<a name="21" id="anc21"></a><span class="line-modified">186     virtual bool mediaPlayerRenderingCanBeAccelerated() { return false; }</span>
187 
188     // called when the media player&#39;s rendering mode changed, which indicates a change in the
189     // availability of the platformLayer().
<a name="22" id="anc22"></a><span class="line-modified">190     virtual void mediaPlayerRenderingModeChanged() { }</span>
191 
192     // whether accelerated compositing is enabled for video rendering
193     virtual bool mediaPlayerAcceleratedCompositingEnabled() { return false; }
194 
<a name="23" id="anc23"></a><span class="line-modified">195     virtual void mediaPlayerActiveSourceBuffersChanged() { }</span>
196 
197 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
<a name="24" id="anc24"></a><span class="line-modified">198     virtual GraphicsDeviceAdapter* mediaPlayerGraphicsDeviceAdapter() const { return nullptr; }</span>
199 #endif
200 
201 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
202     virtual RefPtr&lt;ArrayBuffer&gt; mediaPlayerCachedKeyForKeyId(const String&amp;) const { return nullptr; }
<a name="25" id="anc25"></a><span class="line-modified">203     virtual bool mediaPlayerKeyNeeded(Uint8Array*) { return false; }</span>
204     virtual String mediaPlayerMediaKeysStorageDirectory() const { return emptyString(); }
205 #endif
206 
207 #if ENABLE(ENCRYPTED_MEDIA)
208     virtual void mediaPlayerInitializationDataEncountered(const String&amp;, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;) { }
209     virtual void mediaPlayerWaitingForKeyChanged() { }
210 #endif
211 
212 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<a name="26" id="anc26"></a><span class="line-modified">213     virtual void mediaPlayerCurrentPlaybackTargetIsWirelessChanged(bool) { };</span>
214 #endif
215 
216     virtual String mediaPlayerReferrer() const { return String(); }
217     virtual String mediaPlayerUserAgent() const { return String(); }
218     virtual void mediaPlayerEnterFullscreen() { }
219     virtual void mediaPlayerExitFullscreen() { }
220     virtual bool mediaPlayerIsFullscreen() const { return false; }
221     virtual bool mediaPlayerIsFullscreenPermitted() const { return false; }
222     virtual bool mediaPlayerIsVideo() const { return false; }
223     virtual LayoutRect mediaPlayerContentBoxRect() const { return LayoutRect(); }
224     virtual float mediaPlayerContentsScale() const { return 1; }
<a name="27" id="anc27"></a>
225     virtual void mediaPlayerPause() { }
226     virtual void mediaPlayerPlay() { }
227     virtual bool mediaPlayerPlatformVolumeConfigurationRequired() const { return false; }
<a name="28" id="anc28"></a>
228     virtual bool mediaPlayerIsLooping() const { return false; }
229     virtual CachedResourceLoader* mediaPlayerCachedResourceLoader() { return nullptr; }
230     virtual RefPtr&lt;PlatformMediaResourceLoader&gt; mediaPlayerCreateResourceLoader() { return nullptr; }
231     virtual bool doesHaveAttribute(const AtomString&amp;, AtomString* = nullptr) const { return false; }
232     virtual bool mediaPlayerShouldUsePersistentCache() const { return true; }
233     virtual const String&amp; mediaPlayerMediaCacheDirectory() const { return emptyString(); }
234 
235 #if ENABLE(VIDEO_TRACK)
236     virtual void mediaPlayerDidAddAudioTrack(AudioTrackPrivate&amp;) { }
237     virtual void mediaPlayerDidAddTextTrack(InbandTextTrackPrivate&amp;) { }
238     virtual void mediaPlayerDidAddVideoTrack(VideoTrackPrivate&amp;) { }
239     virtual void mediaPlayerDidRemoveAudioTrack(AudioTrackPrivate&amp;) { }
240     virtual void mediaPlayerDidRemoveTextTrack(InbandTextTrackPrivate&amp;) { }
241     virtual void mediaPlayerDidRemoveVideoTrack(VideoTrackPrivate&amp;) { }
242 
243     virtual void textTrackRepresentationBoundsChanged(const IntRect&amp;) { }
244 #endif
245 
246 #if ENABLE(VIDEO_TRACK) &amp;&amp; ENABLE(AVF_CAPTIONS)
247     virtual Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; outOfBandTrackSources() { return { }; }
248 #endif
249 
250 #if PLATFORM(IOS_FAMILY)
251     virtual String mediaPlayerNetworkInterfaceName() const { return String(); }
252     virtual bool mediaPlayerGetRawCookies(const URL&amp;, Vector&lt;Cookie&gt;&amp;) const { return false; }
253 #endif
254 
<a name="29" id="anc29"></a>

255     virtual String mediaPlayerSourceApplicationIdentifier() const { return emptyString(); }
256 
<a name="30" id="anc30"></a>
257     virtual void mediaPlayerEngineFailedToLoad() const { }
258 
259     virtual double mediaPlayerRequestedPlaybackRate() const { return 0; }
260     virtual MediaPlayerEnums::VideoFullscreenMode mediaPlayerFullscreenMode() const { return MediaPlayerEnums::VideoFullscreenModeNone; }
261     virtual bool mediaPlayerIsVideoFullscreenStandby() const { return false; }
262     virtual Vector&lt;String&gt; mediaPlayerPreferredAudioCharacteristics() const { return Vector&lt;String&gt;(); }
263 
264 #if USE(GSTREAMER)
265     virtual void requestInstallMissingPlugins(const String&amp;, const String&amp;, MediaPlayerRequestInstallMissingPluginsCallback&amp;) { };
266 #endif
267 
268     virtual bool mediaPlayerShouldDisableSleep() const { return false; }
<a name="31" id="anc31"></a><span class="line-modified">269     virtual const Vector&lt;ContentType&gt;&amp; mediaContentTypesRequiringHardwareSupport() const = 0;</span>
270     virtual bool mediaPlayerShouldCheckHardwareSupport() const { return false; }
271 
<a name="32" id="anc32"></a><span class="line-added">272     virtual void mediaPlayerBufferedTimeRangesChanged() { }</span>
<span class="line-added">273     virtual void mediaPlayerSeekableTimeRangesChanged() { }</span>
<span class="line-added">274 </span>
275 #if !RELEASE_LOG_DISABLED
276     virtual const void* mediaPlayerLogIdentifier() { return nullptr; }
277     virtual const Logger&amp; mediaPlayerLogger() = 0;
278 #endif
279 };
280 
<a name="33" id="anc33"></a><span class="line-modified">281 class WEBCORE_EXPORT MediaPlayer : public MediaPlayerEnums, public RefCounted&lt;MediaPlayer&gt; {</span>
282     WTF_MAKE_NONCOPYABLE(MediaPlayer); WTF_MAKE_FAST_ALLOCATED;
283 public:
284     static Ref&lt;MediaPlayer&gt; create(MediaPlayerClient&amp;);
<a name="34" id="anc34"></a><span class="line-added">285     static Ref&lt;MediaPlayer&gt; create(MediaPlayerClient&amp;, MediaPlayerEnums::MediaEngineIdentifier);</span>
286     virtual ~MediaPlayer();
287 
288     void invalidate();
289 
290     // Media engine support.
291     using MediaPlayerEnums::SupportsType;
<a name="35" id="anc35"></a><span class="line-added">292     static const MediaPlayerFactory* mediaEngine(MediaPlayerEnums::MediaEngineIdentifier);</span>
293     static SupportsType supportsType(const MediaEngineSupportParameters&amp;);
294     static void getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp;);
295     static bool isAvailable();
296     static HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp; path);
297     static void clearMediaCache(const String&amp; path, WallTime modifiedSince);
298     static void clearMediaCacheForOrigins(const String&amp; path, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;);
299     static bool supportsKeySystem(const String&amp; keySystem, const String&amp; mimeType);
300 
301     bool supportsPictureInPicture() const;
302     bool supportsFullscreen() const;
303     bool supportsScanning() const;
304     bool canSaveMediaData() const;
305     bool requiresImmediateCompositing() const;
306     bool doesHaveAttribute(const AtomString&amp;, AtomString* value = nullptr) const;
307     PlatformLayer* platformLayer() const;
308 
309 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
310     void setVideoFullscreenLayer(PlatformLayer*, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
311     void setVideoFullscreenFrame(FloatRect);
312     void updateVideoFullscreenInlineImage();
313     using MediaPlayerEnums::VideoGravity;
314     void setVideoFullscreenGravity(VideoGravity);
315     void setVideoFullscreenMode(VideoFullscreenMode);
316     VideoFullscreenMode fullscreenMode() const;
317     void videoFullscreenStandbyChanged();
318     bool isVideoFullscreenStandby() const;
319 #endif
320 
321 #if PLATFORM(IOS_FAMILY)
322     NSArray *timedMetadata() const;
323     String accessLog() const;
324     String errorLog() const;
325 #endif
326 
327     FloatSize naturalSize();
328     bool hasVideo() const;
329     bool hasAudio() const;
330 
<a name="36" id="anc36"></a>

331     IntSize size() const { return m_size; }
332     void setSize(const IntSize&amp; size);
333 
334     bool load(const URL&amp;, const ContentType&amp;, const String&amp; keySystem);
335 #if ENABLE(MEDIA_SOURCE)
336     bool load(const URL&amp;, const ContentType&amp;, MediaSourcePrivateClient*);
337 #endif
338 #if ENABLE(MEDIA_STREAM)
339     bool load(MediaStreamPrivate&amp;);
340 #endif
341     void cancelLoad();
342 
343     bool visible() const;
344     void setVisible(bool);
345 
346     void prepareToPlay();
347     void play();
348     void pause();
349 
350     using MediaPlayerEnums::BufferingPolicy;
351     void setBufferingPolicy(BufferingPolicy);
352 
353 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
354     // Represents synchronous exceptions that can be thrown from the Encrypted Media methods.
355     // This is different from the asynchronous MediaKeyError.
356     enum MediaKeyException { NoError, InvalidPlayerState, KeySystemNotSupported };
357 
358     std::unique_ptr&lt;LegacyCDMSession&gt; createSession(const String&amp; keySystem, LegacyCDMSessionClient*);
359     void setCDMSession(LegacyCDMSession*);
360     void keyAdded();
361 #endif
362 
363 #if ENABLE(ENCRYPTED_MEDIA)
364     void cdmInstanceAttached(CDMInstance&amp;);
365     void cdmInstanceDetached(CDMInstance&amp;);
366     void attemptToDecryptWithInstance(CDMInstance&amp;);
367 #endif
368 
369     bool paused() const;
370     bool seeking() const;
371 
372     static double invalidTime() { return -1.0;}
373     MediaTime duration() const;
374     MediaTime currentTime() const;
375     void seek(const MediaTime&amp;);
376     void seekWithTolerance(const MediaTime&amp;, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance);
377 
378     MediaTime startTime() const;
379     MediaTime initialTime() const;
380 
381     MediaTime getStartDate() const;
382 
383     double rate() const;
384     void setRate(double);
385     double requestedRate() const;
386 
387     bool preservesPitch() const;
388     void setPreservesPitch(bool);
389 
390     std::unique_ptr&lt;PlatformTimeRanges&gt; buffered();
391     std::unique_ptr&lt;PlatformTimeRanges&gt; seekable();
<a name="37" id="anc37"></a><span class="line-added">392     void bufferedTimeRangesChanged();</span>
<span class="line-added">393     void seekableTimeRangesChanged();</span>
394     MediaTime minTimeSeekable();
395     MediaTime maxTimeSeekable();
396 
397     double seekableTimeRangesLastModifiedTime();
398     double liveUpdateInterval();
399 
400     bool didLoadingProgress();
401 
402     double volume() const;
403     void setVolume(double);
404     bool platformVolumeConfigurationRequired() const { return client().mediaPlayerPlatformVolumeConfigurationRequired(); }
405 
406     bool muted() const;
407     void setMuted(bool);
408 
409     bool hasClosedCaptions() const;
410     void setClosedCaptionsVisible(bool closedCaptionsVisible);
411 
412     void paint(GraphicsContext&amp;, const FloatRect&amp;);
413     void paintCurrentFrameInContext(GraphicsContext&amp;, const FloatRect&amp;);
414 
415     // copyVideoTextureToPlatformTexture() is used to do the GPU-GPU textures copy without a readback to system memory.
416     // The first five parameters denote the corresponding GraphicsContext, destination texture, requested level, requested type and the required internalFormat for destination texture.
417     // The last two parameters premultiplyAlpha and flipY denote whether addtional premultiplyAlpha and flip operation are required during the copy.
418     // It returns true on success and false on failure.
419 
420     // In the GPU-GPU textures copy, the source texture(Video texture) should have valid target, internalFormat and size, etc.
421     // The destination texture may need to be resized to to the dimensions of the source texture or re-defined to the required internalFormat.
422     // The current restrictions require that format shoud be RGB or RGBA, type should be UNSIGNED_BYTE and level should be 0. It may be lifted in the future.
423 
<a name="38" id="anc38"></a><span class="line-modified">424     bool copyVideoTextureToPlatformTexture(GraphicsContextGLOpenGL*, PlatformGLObject texture, GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLenum format, GCGLenum type, bool premultiplyAlpha, bool flipY);</span>
425 
426     NativeImagePtr nativeImageForCurrentTime();
427 
428     using MediaPlayerEnums::NetworkState;
429     NetworkState networkState();
430 
431     using MediaPlayerEnums::ReadyState;
432     ReadyState readyState();
433 
434     using MediaPlayerEnums::MovieLoadType;
435     MovieLoadType movieLoadType() const;
436 
437     using MediaPlayerEnums::Preload;
438     Preload preload() const;
439     void setPreload(Preload);
440 
441     void networkStateChanged();
442     void readyStateChanged();
443     void volumeChanged(double);
444     void muteChanged(bool);
445     void timeChanged();
446     void sizeChanged();
447     void rateChanged();
448     void playbackStateChanged();
449     void durationChanged();
450     void firstVideoFrameAvailable();
451     void characteristicChanged();
452 
453     void repaint();
454 
<a name="39" id="anc39"></a>

455     bool hasAvailableVideoFrame() const;
456     void prepareForRendering();
457 
<a name="40" id="anc40"></a>


458 #if USE(NATIVE_FULLSCREEN_VIDEO)
459     void enterFullscreen();
460     void exitFullscreen();
461 #endif
462 
463 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
464     enum WirelessPlaybackTargetType { TargetTypeNone, TargetTypeAirPlay, TargetTypeTVOut };
465     WirelessPlaybackTargetType wirelessPlaybackTargetType() const;
466 
467     String wirelessPlaybackTargetName() const;
468 
469     bool wirelessVideoPlaybackDisabled() const;
470     void setWirelessVideoPlaybackDisabled(bool);
471 
<a name="41" id="anc41"></a><span class="line-modified">472     void currentPlaybackTargetIsWirelessChanged(bool);</span>
473     void playbackTargetAvailabilityChanged();
474 
475     bool isCurrentPlaybackTargetWireless() const;
476     bool canPlayToWirelessPlaybackTarget() const;
477     void setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;);
478 
479     void setShouldPlayToPlaybackTarget(bool);
480 #endif
481 
482     double minFastReverseRate() const;
483     double maxFastForwardRate() const;
484 
485 #if USE(NATIVE_FULLSCREEN_VIDEO)
486     bool canEnterFullscreen() const;
487 #endif
488 
489     // whether accelerated rendering is supported by the media engine for the current media.
490     bool supportsAcceleratedRendering() const;
491     // called when the rendering system flips the into or out of accelerated rendering mode.
492     void acceleratedRenderingStateChanged();
493 
494     bool shouldMaintainAspectRatio() const;
495     void setShouldMaintainAspectRatio(bool);
496 
497 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
498     GraphicsDeviceAdapter* graphicsDeviceAdapter() const;
499 #endif
500 
501     bool hasSingleSecurityOrigin() const;
502     bool didPassCORSAccessCheck() const;
503     bool wouldTaintOrigin(const SecurityOrigin&amp;) const;
504 
505     MediaTime mediaTimeForTimeValue(const MediaTime&amp;) const;
506 
507     double maximumDurationToCacheMediaTime() const;
508 
509     unsigned decodedFrameCount() const;
510     unsigned droppedFrameCount() const;
511     unsigned audioDecodedByteCount() const;
512     unsigned videoDecodedByteCount() const;
513 
514     void setPrivateBrowsingMode(bool);
515 
516 #if ENABLE(WEB_AUDIO)
517     AudioSourceProvider* audioSourceProvider();
518 #endif
519 
520 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
521     RefPtr&lt;ArrayBuffer&gt; cachedKeyForKeyId(const String&amp; keyId) const;
522     bool keyNeeded(Uint8Array* initData);
523     String mediaKeysStorageDirectory() const;
524 #endif
525 
526 #if ENABLE(ENCRYPTED_MEDIA)
527     void initializationDataEncountered(const String&amp;, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;);
528     void waitingForKeyChanged();
529     bool waitingForKey() const;
530 #endif
531 
532     String referrer() const;
533     String userAgent() const;
534 
535     String engineDescription() const;
536     long platformErrorCode() const;
537 
538     CachedResourceLoader* cachedResourceLoader();
539     RefPtr&lt;PlatformMediaResourceLoader&gt; createResourceLoader();
540 
541 #if ENABLE(VIDEO_TRACK)
542     void addAudioTrack(AudioTrackPrivate&amp;);
543     void addTextTrack(InbandTextTrackPrivate&amp;);
544     void addVideoTrack(VideoTrackPrivate&amp;);
545     void removeAudioTrack(AudioTrackPrivate&amp;);
546     void removeTextTrack(InbandTextTrackPrivate&amp;);
547     void removeVideoTrack(VideoTrackPrivate&amp;);
548 
549     bool requiresTextTrackRepresentation() const;
550     void setTextTrackRepresentation(TextTrackRepresentation*);
551     void syncTextTrackBounds();
552     void tracksChanged();
553 #endif
554 
555 #if ENABLE(VIDEO_TRACK) &amp;&amp; ENABLE(AVF_CAPTIONS)
556     void notifyTrackModeChanged();
557     Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; outOfBandTrackSources();
558 #endif
559 
560 #if PLATFORM(IOS_FAMILY)
561     String mediaPlayerNetworkInterfaceName() const;
562     bool getRawCookies(const URL&amp;, Vector&lt;Cookie&gt;&amp;) const;
563 #endif
564 
565     static void resetMediaEngines();
566 
567 #if USE(GSTREAMER)
<a name="42" id="anc42"></a><span class="line-modified">568     void simulateAudioInterruption();</span>
569 #endif
570 
<a name="43" id="anc43"></a><span class="line-modified">571     void beginSimulatedHDCPError();</span>
<span class="line-modified">572     void endSimulatedHDCPError();</span>
573 
574     String languageOfPrimaryAudioTrack() const;
575 
576     size_t extraMemoryCost() const;
577 
578     unsigned long long fileSize() const;
579 
580     Optional&lt;VideoPlaybackQualityMetrics&gt; videoPlaybackQualityMetrics();
581 
<a name="44" id="anc44"></a>
582     String sourceApplicationIdentifier() const;
583     Vector&lt;String&gt; preferredAudioCharacteristics() const;
584 
585     bool ended() const;
586 
587     void setShouldDisableSleep(bool);
588     bool shouldDisableSleep() const;
589 
590     String contentMIMEType() const { return m_contentType.containerType(); }
591     String contentTypeCodecs() const { return m_contentType.parameter(ContentType::codecsParameter()); }
592     bool contentMIMETypeWasInferredFromExtension() const { return m_contentMIMETypeWasInferredFromExtension; }
593 
594     const Vector&lt;ContentType&gt;&amp; mediaContentTypesRequiringHardwareSupport() const;
595     bool shouldCheckHardwareSupport() const;
596 
597 #if !RELEASE_LOG_DISABLED
598     const Logger&amp; mediaPlayerLogger();
599     const void* mediaPlayerLogIdentifier() { return client().mediaPlayerLogIdentifier(); }
600 #endif
601 
602     void applicationWillResignActive();
603     void applicationDidBecomeActive();
604 
605 #if USE(AVFOUNDATION)
<a name="45" id="anc45"></a><span class="line-modified">606     AVPlayer *objCAVFoundationAVPlayer() const;</span>
607 #endif
608 
609     bool performTaskAtMediaTime(WTF::Function&lt;void()&gt;&amp;&amp;, MediaTime);
610 
611     bool shouldIgnoreIntrinsicSize();
612 
<a name="46" id="anc46"></a><span class="line-added">613     bool renderingCanBeAccelerated() const { return client().mediaPlayerRenderingCanBeAccelerated(); }</span>
<span class="line-added">614     void renderingModeChanged() const  { client().mediaPlayerRenderingModeChanged(); }</span>
<span class="line-added">615     bool acceleratedCompositingEnabled() { return client().mediaPlayerAcceleratedCompositingEnabled(); }</span>
<span class="line-added">616     void activeSourceBuffersChanged() { client().mediaPlayerActiveSourceBuffersChanged(); }</span>
<span class="line-added">617     LayoutRect playerContentBoxRect() const { return client().mediaPlayerContentBoxRect(); }</span>
<span class="line-added">618     float playerContentsScale() const { return client().mediaPlayerContentsScale(); }</span>
<span class="line-added">619     bool shouldUsePersistentCache() const { return client().mediaPlayerShouldUsePersistentCache(); }</span>
<span class="line-added">620     const String&amp; mediaCacheDirectory() const { return client().mediaPlayerMediaCacheDirectory(); }</span>
<span class="line-added">621     bool isVideoPlayer() const { return client().mediaPlayerIsVideo(); }</span>
<span class="line-added">622     void mediaEngineUpdated() { client().mediaPlayerEngineUpdated(); }</span>
<span class="line-added">623     void resourceNotSupported() { client().mediaPlayerResourceNotSupported(); }</span>
<span class="line-added">624     bool isLooping() const { return client().mediaPlayerIsLooping(); }</span>
<span class="line-added">625 </span>
<span class="line-added">626     void remoteEngineFailedToLoad();</span>
<span class="line-added">627 </span>
<span class="line-added">628 #if USE(GSTREAMER)</span>
<span class="line-added">629     void requestInstallMissingPlugins(const String&amp; details, const String&amp; description, MediaPlayerRequestInstallMissingPluginsCallback&amp; callback) { client().requestInstallMissingPlugins(details, description, callback); }</span>
<span class="line-added">630 #endif</span>
<span class="line-added">631 </span>
632 private:
633     MediaPlayer(MediaPlayerClient&amp;);
<a name="47" id="anc47"></a><span class="line-added">634     MediaPlayer(MediaPlayerClient&amp;, MediaPlayerEnums::MediaEngineIdentifier);</span>
635 
<a name="48" id="anc48"></a><span class="line-modified">636     MediaPlayerClient&amp; client() const { return *m_client; }</span>
<span class="line-added">637 </span>
<span class="line-added">638     const MediaPlayerFactory* nextBestMediaEngine(const MediaPlayerFactory*);</span>
639     void loadWithNextMediaEngine(const MediaPlayerFactory*);
<a name="49" id="anc49"></a><span class="line-added">640     const MediaPlayerFactory* nextMediaEngine(const MediaPlayerFactory*);</span>
641     void reloadTimerFired();
642 
643     MediaPlayerClient* m_client;
644     Timer m_reloadTimer;
645     std::unique_ptr&lt;MediaPlayerPrivateInterface&gt; m_private;
646     const MediaPlayerFactory* m_currentMediaEngine { nullptr };
647     URL m_url;
648     ContentType m_contentType;
649     String m_keySystem;
<a name="50" id="anc50"></a><span class="line-added">650     Optional&lt;MediaPlayerEnums::MediaEngineIdentifier&gt; m_activeEngineIdentifier;</span>
651     IntSize m_size;
<a name="51" id="anc51"></a><span class="line-modified">652     Preload m_preload { Preload::Auto };</span>
653     double m_volume { 1 };
654     bool m_visible { false };
655     bool m_muted { false };
656     bool m_preservesPitch { true };
657     bool m_privateBrowsing { false };
658     bool m_shouldPrepareToRender { false };
659     bool m_contentMIMETypeWasInferredFromExtension { false };
660     bool m_initializingMediaEngine { false };
661 
662 #if ENABLE(MEDIA_SOURCE)
663     RefPtr&lt;MediaSourcePrivateClient&gt; m_mediaSource;
664 #endif
665 #if ENABLE(MEDIA_STREAM)
666     RefPtr&lt;MediaStreamPrivate&gt; m_mediaStream;
667 #endif
668 };
669 
<a name="52" id="anc52"></a><span class="line-modified">670 class MediaPlayerFactory {</span>
<span class="line-modified">671     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-modified">672 public:</span>
<span class="line-modified">673     MediaPlayerFactory() = default;</span>
<span class="line-modified">674     virtual ~MediaPlayerFactory() = default;</span>
<span class="line-modified">675 </span>
<span class="line-modified">676     virtual MediaPlayerEnums::MediaEngineIdentifier identifier() const  = 0;</span>
<span class="line-added">677     virtual std::unique_ptr&lt;MediaPlayerPrivateInterface&gt; createMediaEnginePlayer(MediaPlayer*) const = 0;</span>
<span class="line-added">678     virtual void getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp;) const = 0;</span>
<span class="line-added">679     virtual MediaPlayer::SupportsType supportsTypeAndCodecs(const MediaEngineSupportParameters&amp;) const = 0;</span>
<span class="line-added">680 </span>
<span class="line-added">681     virtual HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp;) const { return { }; }</span>
<span class="line-added">682     virtual void clearMediaCache(const String&amp;, WallTime) const { }</span>
<span class="line-added">683     virtual void clearMediaCacheForOrigins(const String&amp;, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;) const { }</span>
<span class="line-added">684     virtual bool supportsKeySystem(const String&amp; /* keySystem */, const String&amp; /* mimeType */) const { return false; }</span>
<span class="line-added">685 };</span>
686 
<a name="53" id="anc53"></a><span class="line-modified">687 using MediaEngineRegistrar = void(std::unique_ptr&lt;MediaPlayerFactory&gt;&amp;&amp;);</span>
<span class="line-modified">688 using MediaEngineRegister = void(MediaEngineRegistrar);</span>

689 
690 class MediaPlayerFactorySupport {
691 public:
692     WEBCORE_EXPORT static void callRegisterMediaEngine(MediaEngineRegister);
693 };
694 
<a name="54" id="anc54"></a><span class="line-added">695 class RemoteMediaPlayerSupport {</span>
<span class="line-added">696 public:</span>
<span class="line-added">697     using RegisterRemotePlayerCallback = WTF::Function&lt;void(MediaEngineRegistrar, MediaPlayerEnums::MediaEngineIdentifier)&gt;;</span>
<span class="line-added">698     WEBCORE_EXPORT static void setRegisterRemotePlayerCallback(RegisterRemotePlayerCallback&amp;&amp;);</span>
<span class="line-added">699 };</span>
<span class="line-added">700 </span>
<span class="line-added">701 </span>
702 } // namespace WebCore
703 
704 #endif // ENABLE(VIDEO)
<a name="55" id="anc55"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="55" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSScope.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSRunLoopTimer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSScope.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSScope.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 48,13 ***</span>
      Base::visitChildren(thisObject, visitor);
      visitor.append(thisObject-&gt;m_next);
  }
  
  // Returns true if we found enough information to terminate optimization.
<span class="line-modified">! static inline bool abstractAccess(ExecState* exec, JSScope* scope, const Identifier&amp; ident, GetOrPut getOrPut, size_t depth, bool&amp; needsVarInjectionChecks, ResolveOp&amp; op, InitializationMode initializationMode)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      if (scope-&gt;isJSLexicalEnvironment()) {
          JSLexicalEnvironment* lexicalEnvironment = jsCast&lt;JSLexicalEnvironment*&gt;(scope);
  
<span class="line-new-header">--- 48,13 ---</span>
      Base::visitChildren(thisObject, visitor);
      visitor.append(thisObject-&gt;m_next);
  }
  
  // Returns true if we found enough information to terminate optimization.
<span class="line-modified">! static inline bool abstractAccess(JSGlobalObject* globalObject, JSScope* scope, const Identifier&amp; ident, GetOrPut getOrPut, size_t depth, bool&amp; needsVarInjectionChecks, ResolveOp&amp; op, InitializationMode initializationMode)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      if (scope-&gt;isJSLexicalEnvironment()) {
          JSLexicalEnvironment* lexicalEnvironment = jsCast&lt;JSLexicalEnvironment*&gt;(scope);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,11 ***</span>
          }
  
          if (scope-&gt;type() == ModuleEnvironmentType) {
              JSModuleEnvironment* moduleEnvironment = jsCast&lt;JSModuleEnvironment*&gt;(scope);
              AbstractModuleRecord* moduleRecord = moduleEnvironment-&gt;moduleRecord();
<span class="line-modified">!             AbstractModuleRecord::Resolution resolution = moduleRecord-&gt;resolveImport(exec, ident);</span>
              RETURN_IF_EXCEPTION(throwScope, false);
              if (resolution.type == AbstractModuleRecord::Resolution::Type::Resolved) {
                  AbstractModuleRecord* importedRecord = resolution.moduleRecord;
                  JSModuleEnvironment* importedEnvironment = importedRecord-&gt;moduleEnvironment();
                  SymbolTable* symbolTable = importedEnvironment-&gt;symbolTable();
<span class="line-new-header">--- 77,11 ---</span>
          }
  
          if (scope-&gt;type() == ModuleEnvironmentType) {
              JSModuleEnvironment* moduleEnvironment = jsCast&lt;JSModuleEnvironment*&gt;(scope);
              AbstractModuleRecord* moduleRecord = moduleEnvironment-&gt;moduleRecord();
<span class="line-modified">!             AbstractModuleRecord::Resolution resolution = moduleRecord-&gt;resolveImport(globalObject, ident);</span>
              RETURN_IF_EXCEPTION(throwScope, false);
              if (resolution.type == AbstractModuleRecord::Resolution::Type::Resolved) {
                  AbstractModuleRecord* importedRecord = resolution.moduleRecord;
                  JSModuleEnvironment* importedEnvironment = importedRecord-&gt;moduleEnvironment();
                  SymbolTable* symbolTable = importedEnvironment-&gt;symbolTable();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 153,11 ***</span>
                  return true;
              }
          }
  
          PropertySlot slot(globalObject, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!         bool hasOwnProperty = globalObject-&gt;getOwnPropertySlot(globalObject, exec, ident, slot);</span>
          if (!hasOwnProperty) {
              op = ResolveOp(makeType(UnresolvedProperty, needsVarInjectionChecks), 0, 0, 0, 0, 0);
              return true;
          }
  
<span class="line-new-header">--- 153,11 ---</span>
                  return true;
              }
          }
  
          PropertySlot slot(globalObject, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!         bool hasOwnProperty = globalObject-&gt;getOwnPropertySlot(globalObject, globalObject, ident, slot);</span>
          if (!hasOwnProperty) {
              op = ResolveOp(makeType(UnresolvedProperty, needsVarInjectionChecks), 0, 0, 0, 0, 0);
              return true;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 199,31 ***</span>
  
      return object;
  }
  
  // When an exception occurs, the result of isUnscopable becomes false.
<span class="line-modified">! static inline bool isUnscopable(ExecState* exec, JSScope* scope, JSObject* object, const Identifier&amp; ident)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
      if (scope-&gt;type() != WithScopeType)
          return false;
  
<span class="line-modified">!     JSValue unscopables = object-&gt;get(exec, vm.propertyNames-&gt;unscopablesSymbol);</span>
      RETURN_IF_EXCEPTION(throwScope, false);
      if (!unscopables.isObject())
          return false;
<span class="line-modified">!     JSValue blocked = jsCast&lt;JSObject*&gt;(unscopables)-&gt;get(exec, ident);</span>
      RETURN_IF_EXCEPTION(throwScope, false);
  
<span class="line-modified">!     return blocked.toBoolean(exec);</span>
  }
  
  template&lt;typename ReturnPredicateFunctor, typename SkipPredicateFunctor&gt;
<span class="line-modified">! ALWAYS_INLINE JSObject* JSScope::resolve(ExecState* exec, JSScope* scope, const Identifier&amp; ident, ReturnPredicateFunctor returnPredicate, SkipPredicateFunctor skipPredicate)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
      ScopeChainIterator end = scope-&gt;end();
      ScopeChainIterator it = scope-&gt;begin();
      while (1) {
          JSScope* scope = it.scope();
<span class="line-new-header">--- 199,31 ---</span>
  
      return object;
  }
  
  // When an exception occurs, the result of isUnscopable becomes false.
<span class="line-modified">! static inline bool isUnscopable(JSGlobalObject* globalObject, JSScope* scope, JSObject* object, const Identifier&amp; ident)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
      if (scope-&gt;type() != WithScopeType)
          return false;
  
<span class="line-modified">!     JSValue unscopables = object-&gt;get(globalObject, vm.propertyNames-&gt;unscopablesSymbol);</span>
      RETURN_IF_EXCEPTION(throwScope, false);
      if (!unscopables.isObject())
          return false;
<span class="line-modified">!     JSValue blocked = jsCast&lt;JSObject*&gt;(unscopables)-&gt;get(globalObject, ident);</span>
      RETURN_IF_EXCEPTION(throwScope, false);
  
<span class="line-modified">!     return blocked.toBoolean(globalObject);</span>
  }
  
  template&lt;typename ReturnPredicateFunctor, typename SkipPredicateFunctor&gt;
<span class="line-modified">! ALWAYS_INLINE JSObject* JSScope::resolve(JSGlobalObject* globalObject, JSScope* scope, const Identifier&amp; ident, ReturnPredicateFunctor returnPredicate, SkipPredicateFunctor skipPredicate)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
      ScopeChainIterator end = scope-&gt;end();
      ScopeChainIterator it = scope-&gt;begin();
      while (1) {
          JSScope* scope = it.scope();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 231,90 ***</span>
  
          // Global scope.
          if (++it == end) {
              JSScope* globalScopeExtension = scope-&gt;globalObject(vm)-&gt;globalScopeExtension();
              if (UNLIKELY(globalScopeExtension)) {
<span class="line-modified">!                 bool hasProperty = object-&gt;hasProperty(exec, ident);</span>
                  RETURN_IF_EXCEPTION(throwScope, nullptr);
                  if (hasProperty)
                      return object;
                  JSObject* extensionScopeObject = JSScope::objectAtScope(globalScopeExtension);
<span class="line-modified">!                 hasProperty = extensionScopeObject-&gt;hasProperty(exec, ident);</span>
                  RETURN_IF_EXCEPTION(throwScope, nullptr);
                  if (hasProperty)
                      return extensionScopeObject;
              }
              return object;
          }
  
          if (skipPredicate(scope))
              continue;
  
<span class="line-modified">!         bool hasProperty = object-&gt;hasProperty(exec, ident);</span>
          RETURN_IF_EXCEPTION(throwScope, nullptr);
          if (hasProperty) {
<span class="line-modified">!             bool unscopable = isUnscopable(exec, scope, object, ident);</span>
              EXCEPTION_ASSERT(!throwScope.exception() || !unscopable);
              if (!unscopable)
                  return object;
          }
  
          if (returnPredicate(scope))
              return object;
      }
  }
  
<span class="line-modified">! JSValue JSScope::resolveScopeForHoistingFuncDeclInEval(ExecState* exec, JSScope* scope, const Identifier&amp; ident)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      auto returnPredicate = [&amp;] (JSScope* scope) -&gt; bool {
          return scope-&gt;isVarScope();
      };
      auto skipPredicate = [&amp;] (JSScope* scope) -&gt; bool {
          return scope-&gt;isWithScope();
      };
<span class="line-modified">!     JSObject* object = resolve(exec, scope, ident, returnPredicate, skipPredicate);</span>
      RETURN_IF_EXCEPTION(throwScope, { });
  
      bool result = false;
      if (JSScope* scope = jsDynamicCast&lt;JSScope*&gt;(vm, object)) {
          if (SymbolTable* scopeSymbolTable = scope-&gt;symbolTable(vm)) {
              result = scope-&gt;isGlobalObject()
<span class="line-modified">!                 ? JSObject::isExtensible(object, exec)</span>
                  : scopeSymbolTable-&gt;scopeType() == SymbolTable::ScopeType::VarScope;
          }
      }
  
      return result ? JSValue(object) : jsUndefined();
  }
  
<span class="line-modified">! JSObject* JSScope::resolve(ExecState* exec, JSScope* scope, const Identifier&amp; ident)</span>
  {
      auto predicate1 = [&amp;] (JSScope*) -&gt; bool {
          return false;
      };
      auto predicate2 = [&amp;] (JSScope*) -&gt; bool {
          return false;
      };
<span class="line-modified">!     return resolve(exec, scope, ident, predicate1, predicate2);</span>
  }
  
<span class="line-modified">! ResolveOp JSScope::abstractResolve(ExecState* exec, size_t depthOffset, JSScope* scope, const Identifier&amp; ident, GetOrPut getOrPut, ResolveType unlinkedType, InitializationMode initializationMode)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      ResolveOp op(Dynamic, 0, 0, 0, 0, 0);
      if (unlinkedType == Dynamic)
          return op;
  
      bool needsVarInjectionChecks = JSC::needsVarInjectionChecks(unlinkedType);
      size_t depth = depthOffset;
      for (; scope; scope = scope-&gt;next()) {
<span class="line-modified">!         bool success = abstractAccess(exec, scope, ident, getOrPut, depth, needsVarInjectionChecks, op, initializationMode);</span>
          RETURN_IF_EXCEPTION(throwScope, ResolveOp(Dynamic, 0, 0, 0, 0, 0));
          if (success)
              break;
          ++depth;
      }
<span class="line-new-header">--- 231,90 ---</span>
  
          // Global scope.
          if (++it == end) {
              JSScope* globalScopeExtension = scope-&gt;globalObject(vm)-&gt;globalScopeExtension();
              if (UNLIKELY(globalScopeExtension)) {
<span class="line-modified">!                 bool hasProperty = object-&gt;hasProperty(globalObject, ident);</span>
                  RETURN_IF_EXCEPTION(throwScope, nullptr);
                  if (hasProperty)
                      return object;
                  JSObject* extensionScopeObject = JSScope::objectAtScope(globalScopeExtension);
<span class="line-modified">!                 hasProperty = extensionScopeObject-&gt;hasProperty(globalObject, ident);</span>
                  RETURN_IF_EXCEPTION(throwScope, nullptr);
                  if (hasProperty)
                      return extensionScopeObject;
              }
              return object;
          }
  
          if (skipPredicate(scope))
              continue;
  
<span class="line-modified">!         bool hasProperty = object-&gt;hasProperty(globalObject, ident);</span>
          RETURN_IF_EXCEPTION(throwScope, nullptr);
          if (hasProperty) {
<span class="line-modified">!             bool unscopable = isUnscopable(globalObject, scope, object, ident);</span>
              EXCEPTION_ASSERT(!throwScope.exception() || !unscopable);
              if (!unscopable)
                  return object;
          }
  
          if (returnPredicate(scope))
              return object;
      }
  }
  
<span class="line-modified">! JSValue JSScope::resolveScopeForHoistingFuncDeclInEval(JSGlobalObject* globalObject, JSScope* scope, const Identifier&amp; ident)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      auto returnPredicate = [&amp;] (JSScope* scope) -&gt; bool {
          return scope-&gt;isVarScope();
      };
      auto skipPredicate = [&amp;] (JSScope* scope) -&gt; bool {
          return scope-&gt;isWithScope();
      };
<span class="line-modified">!     JSObject* object = resolve(globalObject, scope, ident, returnPredicate, skipPredicate);</span>
      RETURN_IF_EXCEPTION(throwScope, { });
  
      bool result = false;
      if (JSScope* scope = jsDynamicCast&lt;JSScope*&gt;(vm, object)) {
          if (SymbolTable* scopeSymbolTable = scope-&gt;symbolTable(vm)) {
              result = scope-&gt;isGlobalObject()
<span class="line-modified">!                 ? JSObject::isExtensible(object, globalObject)</span>
                  : scopeSymbolTable-&gt;scopeType() == SymbolTable::ScopeType::VarScope;
          }
      }
  
      return result ? JSValue(object) : jsUndefined();
  }
  
<span class="line-modified">! JSObject* JSScope::resolve(JSGlobalObject* globalObject, JSScope* scope, const Identifier&amp; ident)</span>
  {
      auto predicate1 = [&amp;] (JSScope*) -&gt; bool {
          return false;
      };
      auto predicate2 = [&amp;] (JSScope*) -&gt; bool {
          return false;
      };
<span class="line-modified">!     return resolve(globalObject, scope, ident, predicate1, predicate2);</span>
  }
  
<span class="line-modified">! ResolveOp JSScope::abstractResolve(JSGlobalObject* globalObject, size_t depthOffset, JSScope* scope, const Identifier&amp; ident, GetOrPut getOrPut, ResolveType unlinkedType, InitializationMode initializationMode)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      ResolveOp op(Dynamic, 0, 0, 0, 0, 0);
      if (unlinkedType == Dynamic)
          return op;
  
      bool needsVarInjectionChecks = JSC::needsVarInjectionChecks(unlinkedType);
      size_t depth = depthOffset;
      for (; scope; scope = scope-&gt;next()) {
<span class="line-modified">!         bool success = abstractAccess(globalObject, scope, ident, getOrPut, depth, needsVarInjectionChecks, op, initializationMode);</span>
          RETURN_IF_EXCEPTION(throwScope, ResolveOp(Dynamic, 0, 0, 0, 0, 0));
          if (success)
              break;
          ++depth;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 407,13 ***</span>
          return symbolTableObject-&gt;symbolTable();
  
      return nullptr;
  }
  
<span class="line-modified">! JSValue JSScope::toThis(JSCell*, ExecState* exec, ECMAMode ecmaMode)</span>
  {
      if (ecmaMode == StrictMode)
          return jsUndefined();
<span class="line-modified">!     return exec-&gt;globalThisValue();</span>
  }
  
  } // namespace JSC
<span class="line-new-header">--- 407,13 ---</span>
          return symbolTableObject-&gt;symbolTable();
  
      return nullptr;
  }
  
<span class="line-modified">! JSValue JSScope::toThis(JSCell*, JSGlobalObject* globalObject, ECMAMode ecmaMode)</span>
  {
      if (ecmaMode == StrictMode)
          return jsUndefined();
<span class="line-modified">!     return globalObject-&gt;globalThis();</span>
  }
  
  } // namespace JSC
</pre>
<center><a href="JSRunLoopTimer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSScope.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
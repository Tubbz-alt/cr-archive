diff a/modules/javafx.web/src/main/native/Source/WebCore/editing/InsertListCommand.cpp b/modules/javafx.web/src/main/native/Source/WebCore/editing/InsertListCommand.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/editing/InsertListCommand.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/editing/InsertListCommand.cpp
@@ -52,18 +52,21 @@
     RefPtr<InsertListCommand> insertCommand = create(document, type);
     insertCommand->apply();
     return insertCommand->m_listElement;
 }
 
-HTMLElement& InsertListCommand::fixOrphanedListChild(Node& node)
+HTMLElement* InsertListCommand::fixOrphanedListChild(Node& node)
 {
     auto listElement = HTMLUListElement::create(document());
     insertNodeBefore(listElement.copyRef(), node);
+    if (!listElement->hasEditableStyle())
+        return nullptr;
+
     removeNode(node);
     appendNode(node, listElement.copyRef());
     m_listElement = WTFMove(listElement);
-    return *m_listElement;
+    return m_listElement.get();
 }
 
 Ref<HTMLElement> InsertListCommand::mergeWithNeighboringLists(HTMLElement& list)
 {
     Ref<HTMLElement> protectedList = list;
@@ -204,12 +207,17 @@
     Node* listChildNode = enclosingListChild(selectionNode);
     bool switchListType = false;
     if (listChildNode) {
         // Remove the list chlild.
         RefPtr<HTMLElement> listNode = enclosingList(listChildNode);
-        if (!listNode)
-            listNode = mergeWithNeighboringLists(fixOrphanedListChild(*listChildNode));
+        if (!listNode) {
+            RefPtr<HTMLElement> listElement = fixOrphanedListChild(*listChildNode);
+            if (!listElement)
+                return;
+
+            listNode = mergeWithNeighboringLists(*listElement);
+        }
 
         if (!listNode->hasTagName(listTag)) {
             // listChildNode will be removed from the list and a list of type m_type will be created.
             switchListType = true;
         }
@@ -223,10 +231,12 @@
             bool rangeStartIsInList = visiblePositionBeforeNode(*listNode) == currentSelection->startPosition();
             bool rangeEndIsInList = visiblePositionAfterNode(*listNode) == currentSelection->endPosition();
 
             RefPtr<HTMLElement> newList = createHTMLElement(document(), listTag);
             insertNodeBefore(*newList, *listNode);
+            if (!newList->hasEditableStyle())
+                return;
 
             auto* firstChildInList = enclosingListChild(VisiblePosition(firstPositionInNode(listNode.get())).deepEquivalent().deprecatedNode(), listNode.get());
             Node* outerBlock = firstChildInList && isBlockFlowElement(*firstChildInList) ? firstChildInList : listNode.get();
 
             moveParagraphWithClones(firstPositionInNode(listNode.get()), lastPositionInNode(listNode.get()), newList.get(), outerBlock);
@@ -336,11 +346,11 @@
 RefPtr<HTMLElement> InsertListCommand::listifyParagraph(const VisiblePosition& originalStart, const QualifiedName& listTag)
 {
     VisiblePosition start = startOfParagraph(originalStart, CanSkipOverEditingBoundary);
     VisiblePosition end = endOfParagraph(start, CanSkipOverEditingBoundary);
 
-    if (start.isNull() || end.isNull())
+    if (start.isNull() || end.isNull() || !start.deepEquivalent().containerNode()->hasEditableStyle() || !end.deepEquivalent().containerNode()->hasEditableStyle())
         return 0;
 
     // Check for adjoining lists.
     auto listItemElement = HTMLLIElement::create(document());
     auto placeholder = HTMLBRElement::create(document());

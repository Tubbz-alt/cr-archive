diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedMetadataTable.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedMetadataTable.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedMetadataTable.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedMetadataTable.cpp
@@ -33,20 +33,22 @@
 #include "UnlinkedMetadataTableInlines.h"
 #include <wtf/FastMalloc.h>
 
 namespace JSC {
 
+DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(MetadataTable);
+
 #define JSC_ALIGNMENT_CHECK(size) static_assert(size <= UnlinkedMetadataTable::s_maxMetadataAlignment);
 FOR_EACH_BYTECODE_METADATA_ALIGNMENT(JSC_ALIGNMENT_CHECK)
 #undef JSC_ALIGNMENT_CHECK
 
 void UnlinkedMetadataTable::finalize()
 {
     ASSERT(!m_isFinalized);
     m_isFinalized = true;
     if (!m_hasMetadata) {
-        fastFree(m_rawBuffer);
+        MetadataTableMalloc::free(m_rawBuffer);
         m_rawBuffer = nullptr;
         return;
     }
 
     unsigned offset = s_offset16TableSize;
@@ -67,11 +69,11 @@
         buffer[s_offsetTableEntries - 1] = offset;
         m_is32Bit = offset > UINT16_MAX;
     }
 
     if (m_is32Bit) {
-        m_rawBuffer = reinterpret_cast<uint8_t*>(fastRealloc(m_rawBuffer, s_offset16TableSize + s_offset32TableSize + sizeof(LinkingData)));
+        m_rawBuffer = reinterpret_cast<uint8_t*>(MetadataTableMalloc::realloc(m_rawBuffer, s_offset16TableSize + s_offset32TableSize + sizeof(LinkingData)));
         memmove(m_rawBuffer + sizeof(LinkingData) + s_offset16TableSize, m_rawBuffer + sizeof(LinkingData), s_offset32TableSize);
         memset(m_rawBuffer + sizeof(LinkingData), 0, s_offset16TableSize);
         Offset32* buffer = bitwise_cast<Offset32*>(m_rawBuffer + sizeof(LinkingData) + s_offset16TableSize);
         // This adjustment does not break the alignment calculated for metadata in the above loop so long as s_offset32TableSize is rounded with 8.
         for (unsigned i = 0; i < s_offsetTableEntries; i++)
@@ -79,10 +81,10 @@
     } else {
         Offset32* oldBuffer = bitwise_cast<Offset32*>(m_rawBuffer + sizeof(LinkingData));
         Offset16* buffer = bitwise_cast<Offset16*>(m_rawBuffer + sizeof(LinkingData));
         for (unsigned i = 0; i < s_offsetTableEntries; i++)
             buffer[i] = oldBuffer[i];
-        m_rawBuffer = static_cast<uint8_t*>(fastRealloc(m_rawBuffer, s_offset16TableSize + sizeof(LinkingData)));
+        m_rawBuffer = static_cast<uint8_t*>(MetadataTableMalloc::realloc(m_rawBuffer, s_offset16TableSize + sizeof(LinkingData)));
     }
 }
 
 } // namespace JSC

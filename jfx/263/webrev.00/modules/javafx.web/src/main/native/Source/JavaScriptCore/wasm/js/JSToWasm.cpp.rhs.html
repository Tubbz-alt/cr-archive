<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSToWasm.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JSToWasm.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;CCallHelpers.h&quot;
 32 #include &quot;DisallowMacroScratchRegisterUsage.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 33 #include &quot;FrameTracers.h&quot;</span>
 34 #include &quot;JSCInlines.h&quot;
 35 #include &quot;JSWebAssemblyHelpers.h&quot;
 36 #include &quot;JSWebAssemblyInstance.h&quot;
 37 #include &quot;JSWebAssemblyRuntimeError.h&quot;
 38 #include &quot;MaxFrameExtentForSlowPathCall.h&quot;
 39 #include &quot;WasmCallingConvention.h&quot;
 40 #include &quot;WasmContextInlines.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 41 #include &quot;WasmOperations.h&quot;</span>
 42 #include &quot;WasmSignatureInlines.h&quot;
 43 #include &quot;WasmToJS.h&quot;
 44 
 45 namespace JSC { namespace Wasm {
 46 
<a name="3" id="anc3"></a><span class="line-modified"> 47 inline void boxWasmResult(CCallHelpers&amp; jit, Wasm::Type type, Reg src, JSValueRegs dst)</span>
 48 {
<a name="4" id="anc4"></a><span class="line-modified"> 49     switch (type) {</span>
<span class="line-added"> 50     case Wasm::Void:</span>
<span class="line-added"> 51         jit.moveTrustedValue(jsUndefined(), dst);</span>
<span class="line-added"> 52         break;</span>
<span class="line-added"> 53     case Wasm::Anyref:</span>
<span class="line-added"> 54     case Wasm::Funcref:</span>
<span class="line-added"> 55         jit.move(src.gpr(), dst.payloadGPR());</span>
<span class="line-added"> 56         break;</span>
<span class="line-added"> 57     case Wasm::I32:</span>
<span class="line-added"> 58         jit.zeroExtend32ToPtr(src.gpr(), dst.payloadGPR());</span>
<span class="line-added"> 59         jit.boxInt32(dst.payloadGPR(), dst, DoNotHaveTagRegisters);</span>
<span class="line-added"> 60         break;</span>
<span class="line-added"> 61     case Wasm::F32:</span>
<span class="line-added"> 62         jit.convertFloatToDouble(src.fpr(), src.fpr());</span>
<span class="line-added"> 63         FALLTHROUGH;</span>
<span class="line-added"> 64     case Wasm::F64: {</span>
<span class="line-added"> 65         jit.moveTrustedValue(jsNumber(pureNaN()), dst);</span>
<span class="line-added"> 66         auto isNaN = jit.branchIfNaN(src.fpr());</span>
<span class="line-added"> 67         jit.boxDouble(src.fpr(), dst, DoNotHaveTagRegisters);</span>
<span class="line-added"> 68         isNaN.link(&amp;jit);</span>
<span class="line-added"> 69         break;</span>
<span class="line-added"> 70     }</span>
<span class="line-added"> 71     default:</span>
<span class="line-added"> 72         jit.breakpoint();</span>
<span class="line-added"> 73         break;</span>
<span class="line-added"> 74     }</span>
<span class="line-added"> 75 }</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77 void marshallJSResult(CCallHelpers&amp; jit, const Signature&amp; signature, const CallInformation&amp; wasmFrameConvention, const RegisterAtOffsetList&amp; savedResultRegisters)</span>
<span class="line-added"> 78 {</span>
<span class="line-added"> 79     if (signature.returnsVoid())</span>
<span class="line-added"> 80         jit.moveTrustedValue(jsUndefined(), JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-added"> 81     else if (signature.returnCount() == 1)</span>
<span class="line-added"> 82         boxWasmResult(jit, signature.returnType(0), wasmFrameConvention.results[0].reg(), JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-added"> 83     else {</span>
<span class="line-added"> 84         IndexingType indexingType = ArrayWithUndecided;</span>
<span class="line-added"> 85         JSValueRegs scratch = JSValueRegs { wasmCallingConvention().prologueScratchGPRs[1] };</span>
<span class="line-added"> 86         // We can use the first floating point register as a scratch since it will always be moved onto the stack before other values.</span>
<span class="line-added"> 87         FPRReg fprScratch = wasmCallingConvention().fprArgs[0].fpr();</span>
<span class="line-added"> 88         for (unsigned i = 0; i &lt; signature.returnCount(); ++i) {</span>
<span class="line-added"> 89             B3::ValueRep rep = wasmFrameConvention.results[i];</span>
<span class="line-added"> 90             Type type = signature.returnType(i);</span>
<span class="line-added"> 91 </span>
<span class="line-added"> 92             if (rep.isReg()) {</span>
<span class="line-added"> 93                 boxWasmResult(jit, signature.returnType(i), rep.reg(), scratch);</span>
<span class="line-added"> 94                 jit.storeValue(scratch, CCallHelpers::Address(CCallHelpers::stackPointerRegister, savedResultRegisters.find(rep.reg())-&gt;offset() + wasmFrameConvention.headerAndArgumentStackSizeInBytes));</span>
<span class="line-added"> 95             } else {</span>
<span class="line-added"> 96                 auto location = CCallHelpers::Address(CCallHelpers::stackPointerRegister, rep.offsetFromSP());</span>
<span class="line-added"> 97                 Reg tmp = type == F32 || type == F64 ? Reg(fprScratch) : Reg(scratch.gpr());</span>
<span class="line-added"> 98                 jit.load64ToReg(location, tmp);</span>
<span class="line-added"> 99                 boxWasmResult(jit, signature.returnType(i), tmp, scratch);</span>
<span class="line-added">100                 jit.storeValue(scratch, location);</span>
<span class="line-added">101             }</span>
<span class="line-added">102 </span>
<span class="line-added">103             switch (type) {</span>
<span class="line-added">104             case Wasm::I32:</span>
<span class="line-added">105                 indexingType = leastUpperBoundOfIndexingTypes(indexingType, ArrayWithInt32);</span>
<span class="line-added">106                 break;</span>
<span class="line-added">107             case Wasm::F32:</span>
<span class="line-added">108             case Wasm::F64:</span>
<span class="line-added">109                 indexingType = leastUpperBoundOfIndexingTypes(indexingType, ArrayWithDouble);</span>
<span class="line-added">110                 break;</span>
<span class="line-added">111             default:</span>
<span class="line-added">112                 indexingType = leastUpperBoundOfIndexingTypes(indexingType, ArrayWithContiguous);</span>
<span class="line-added">113                 break;</span>
<span class="line-added">114             }</span>
<span class="line-added">115         }</span>
<span class="line-added">116 </span>
<span class="line-added">117         GPRReg wasmContextInstanceGPR = PinnedRegisterInfo::get().wasmContextInstancePointer;</span>
<span class="line-added">118         if (Context::useFastTLS()) {</span>
<span class="line-added">119             wasmContextInstanceGPR = GPRInfo::argumentGPR1;</span>
<span class="line-added">120             static_assert(std::is_same_v&lt;Wasm::Instance*, typename FunctionTraits&lt;decltype(operationAllocateResultsArray)&gt;::ArgumentType&lt;1&gt;&gt;);</span>
<span class="line-added">121             jit.loadWasmContextInstance(wasmContextInstanceGPR);</span>
<span class="line-added">122         }</span>
<span class="line-added">123 </span>
<span class="line-added">124         jit.setupArguments&lt;decltype(operationAllocateResultsArray)&gt;(wasmContextInstanceGPR, CCallHelpers::TrustedImmPtr(&amp;signature), indexingType, CCallHelpers::stackPointerRegister);</span>
<span class="line-added">125         jit.callOperation(FunctionPtr&lt;OperationPtrTag&gt;(operationAllocateResultsArray));</span>
<span class="line-added">126     }</span>
<span class="line-added">127 }</span>
128 
<a name="5" id="anc5"></a><span class="line-added">129 std::unique_ptr&lt;InternalFunction&gt; createJSToWasmWrapper(CCallHelpers&amp; jit, const Signature&amp; signature, Vector&lt;UnlinkedWasmToWasmCall&gt;* unlinkedWasmToWasmCalls, const ModuleInformation&amp; info, MemoryMode mode, unsigned functionIndex)</span>
<span class="line-added">130 {</span>
131     auto result = makeUnique&lt;InternalFunction&gt;();
132     jit.emitFunctionPrologue();
133 
134     // FIXME Stop using 0 as codeBlocks. https://bugs.webkit.org/show_bug.cgi?id=165321
135     jit.store64(CCallHelpers::TrustedImm64(0), CCallHelpers::Address(GPRInfo::callFrameRegister, CallFrameSlot::codeBlock * static_cast&lt;int&gt;(sizeof(Register))));
136     MacroAssembler::DataLabelPtr calleeMoveLocation = jit.moveWithPatch(MacroAssembler::TrustedImmPtr(nullptr), GPRInfo::nonPreservedNonReturnGPR);
137     jit.storePtr(GPRInfo::nonPreservedNonReturnGPR, CCallHelpers::Address(GPRInfo::callFrameRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));
138     CodeLocationDataLabelPtr&lt;WasmEntryPtrTag&gt;* linkedCalleeMove = &amp;result-&gt;calleeMoveLocation;
139     jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
140         *linkedCalleeMove = linkBuffer.locationOf&lt;WasmEntryPtrTag&gt;(calleeMoveLocation);
141     });
142 
143     const PinnedRegisterInfo&amp; pinnedRegs = PinnedRegisterInfo::get();
144     RegisterSet toSave = pinnedRegs.toSave(mode);
145 
<a name="6" id="anc6"></a><span class="line-modified">146 #if ASSERT_ENABLED</span>
147     unsigned toSaveSize = toSave.numberOfSetGPRs();
148     // They should all be callee saves.
149     toSave.filter(RegisterSet::calleeSaveRegisters());
150     ASSERT(toSave.numberOfSetGPRs() == toSaveSize);
151 #endif
152 
153     RegisterAtOffsetList registersToSpill(toSave, RegisterAtOffsetList::OffsetBaseType::FramePointerBased);
154     result-&gt;entrypoint.calleeSaveRegisters = registersToSpill;
155 
<a name="7" id="anc7"></a><span class="line-modified">156     size_t totalFrameSize = registersToSpill.size() * sizeof(CPURegister);</span>
<span class="line-modified">157     CallInformation wasmFrameConvention = wasmCallingConvention().callInformationFor(signature);</span>
<span class="line-modified">158     RegisterAtOffsetList savedResultRegisters = wasmFrameConvention.computeResultsOffsetList();</span>
<span class="line-modified">159     totalFrameSize += wasmFrameConvention.headerAndArgumentStackSizeInBytes;</span>
<span class="line-modified">160     totalFrameSize += savedResultRegisters.size() * sizeof(CPURegister);</span>























161 
162     totalFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), totalFrameSize);
163     jit.subPtr(MacroAssembler::TrustedImm32(totalFrameSize), MacroAssembler::stackPointerRegister);
164 
165     // We save all these registers regardless of having a memory or not.
166     // The reason is that we use one of these as a scratch. That said,
167     // almost all real wasm programs use memory, so it&#39;s not really
168     // worth optimizing for the case that they don&#39;t.
169     for (const RegisterAtOffset&amp; regAtOffset : registersToSpill) {
170         GPRReg reg = regAtOffset.reg().gpr();
171         ptrdiff_t offset = regAtOffset.offset();
172         jit.storePtr(reg, CCallHelpers::Address(GPRInfo::callFrameRegister, offset));
173     }
174 
<a name="8" id="anc8"></a><span class="line-modified">175     if (wasmFrameConvention.argumentsIncludeI64 || wasmFrameConvention.resultsIncludeI64) {</span>
176         if (Context::useFastTLS())
177             jit.loadWasmContextInstance(GPRInfo::argumentGPR2);
178         else {
179             // vmEntryToWasm passes the JSWebAssemblyInstance corresponding to Wasm::Context*&#39;s
180             // instance as the first JS argument when we&#39;re not using fast TLS to hold the
181             // Wasm::Context*&#39;s instance.
182             jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, CallFrameSlot::thisArgument * sizeof(EncodedJSValue)), GPRInfo::argumentGPR2);
183             jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR2, JSWebAssemblyInstance::offsetOfInstance()), GPRInfo::argumentGPR2);
184         }
185 
<a name="9" id="anc9"></a><span class="line-modified">186         emitThrowWasmToJSException(jit, GPRInfo::argumentGPR2, wasmFrameConvention.argumentsIncludeI64 ? ExceptionType::I64ArgumentType : ExceptionType::I64ReturnType);</span>
187         return result;
188     }
189 
190     GPRReg wasmContextInstanceGPR = pinnedRegs.wasmContextInstancePointer;
191 
192     {
<a name="10" id="anc10"></a><span class="line-modified">193         CallInformation jsFrameConvention = jsCallingConvention().callInformationFor(signature, CallRole::Callee);</span>
<span class="line-modified">194 </span>
<span class="line-modified">195         CCallHelpers::Address calleeFrame = CCallHelpers::Address(MacroAssembler::stackPointerRegister, 0);</span>
<span class="line-added">196 </span>
197         // We&#39;re going to set the pinned registers after this. So
198         // we can use this as a scratch for now since we saved it above.
199         GPRReg scratchReg = pinnedRegs.baseMemoryPointer;
200 
<a name="11" id="anc11"></a>




201         if (!Context::useFastTLS()) {
<a name="12" id="anc12"></a><span class="line-modified">202             jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, JSCallingConvention::instanceStackOffset), wasmContextInstanceGPR);</span>
203             jit.loadPtr(CCallHelpers::Address(wasmContextInstanceGPR, JSWebAssemblyInstance::offsetOfInstance()), wasmContextInstanceGPR);
<a name="13" id="anc13"></a>
204         }
205 
<a name="14" id="anc14"></a>
206         for (unsigned i = 0; i &lt; signature.argumentCount(); i++) {
<a name="15" id="anc15"></a><span class="line-modified">207             RELEASE_ASSERT(jsFrameConvention.params[i].isStack());</span>
<span class="line-modified">208 </span>
<span class="line-modified">209             Type type = signature.argument(i);</span>
<span class="line-modified">210             CCallHelpers::Address jsParam(GPRInfo::callFrameRegister, jsFrameConvention.params[i].offsetFromFP());</span>
<span class="line-modified">211             if (wasmFrameConvention.params[i].isStackArgument()) {</span>
<span class="line-modified">212                 if (type == Wasm::I32 || type == Wasm::F32) {</span>
<span class="line-modified">213                     jit.load32(jsParam, scratchReg);</span>
<span class="line-modified">214                     jit.store32(scratchReg, calleeFrame.withOffset(wasmFrameConvention.params[i].offsetFromSP()));</span>

























215                 } else {
<a name="16" id="anc16"></a><span class="line-modified">216                     jit.load64(jsParam, scratchReg);</span>
<span class="line-modified">217                     jit.store64(scratchReg, calleeFrame.withOffset(wasmFrameConvention.params[i].offsetFromSP()));</span>


218                 }
<a name="17" id="anc17"></a><span class="line-modified">219             } else {</span>
<span class="line-modified">220                 if (type == Wasm::I32 || type == Wasm::F32)</span>
<span class="line-modified">221                     jit.load32ToReg(jsParam, wasmFrameConvention.params[i].reg());</span>
<span class="line-modified">222                 else</span>
<span class="line-added">223                     jit.load64ToReg(jsParam, wasmFrameConvention.params[i].reg());</span>
224             }
<a name="18" id="anc18"></a>

225         }
226     }
227 
228     if (!!info.memory) {
229         GPRReg baseMemory = pinnedRegs.baseMemoryPointer;
<a name="19" id="anc19"></a><span class="line-modified">230         GPRReg scratchOrSize = wasmCallingConvention().prologueScratchGPRs[0];</span>
231 
232         if (Context::useFastTLS())
233             jit.loadWasmContextInstance(baseMemory);
234 
235         GPRReg currentInstanceGPR = Context::useFastTLS() ? baseMemory : wasmContextInstanceGPR;
236         if (isARM64E()) {
237             if (mode != Wasm::MemoryMode::Signaling)
238                 scratchOrSize = pinnedRegs.sizeRegister;
239             jit.loadPtr(CCallHelpers::Address(currentInstanceGPR, Wasm::Instance::offsetOfCachedMemorySize()), scratchOrSize);
240         } else {
241             if (mode != Wasm::MemoryMode::Signaling)
242                 jit.loadPtr(CCallHelpers::Address(currentInstanceGPR, Wasm::Instance::offsetOfCachedMemorySize()), pinnedRegs.sizeRegister);
243         }
244 
245         jit.loadPtr(CCallHelpers::Address(currentInstanceGPR, Wasm::Instance::offsetOfCachedMemory()), baseMemory);
246         jit.cageConditionally(Gigacage::Primitive, baseMemory, scratchOrSize, scratchOrSize);
247     }
248 
249     CCallHelpers::Call call = jit.threadSafePatchableNearCall();
250     unsigned functionIndexSpace = functionIndex + info.importFunctionCount();
251     ASSERT(functionIndexSpace &lt; info.functionIndexSpaceSize());
252     jit.addLinkTask([unlinkedWasmToWasmCalls, call, functionIndexSpace] (LinkBuffer&amp; linkBuffer) {
253         unlinkedWasmToWasmCalls-&gt;append({ linkBuffer.locationOfNearCall&lt;WasmEntryPtrTag&gt;(call), functionIndexSpace });
254     });
255 
<a name="20" id="anc20"></a><span class="line-added">256     marshallJSResult(jit, signature, wasmFrameConvention, savedResultRegisters);</span>
<span class="line-added">257 </span>
258     for (const RegisterAtOffset&amp; regAtOffset : registersToSpill) {
259         GPRReg reg = regAtOffset.reg().gpr();
260         ASSERT(reg != GPRInfo::returnValueGPR);
261         ptrdiff_t offset = regAtOffset.offset();
262         jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, offset), reg);
263     }
264 
<a name="21" id="anc21"></a>




























265     jit.emitFunctionEpilogue();
266     jit.ret();
267 
268     return result;
269 }
270 
271 } } // namespace JSC::Wasm
272 
273 #endif // ENABLE(WEBASSEMBLY)
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
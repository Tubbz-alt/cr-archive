<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLCanvasElement.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLCanvasElement.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLCanvasElement.idl.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLCanvasElement.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,24 ***</span>
  
  #include &quot;CanvasBase.h&quot;
  #include &quot;FloatRect.h&quot;
  #include &quot;HTMLElement.h&quot;
  #include &quot;ImageBitmapRenderingContextSettings.h&quot;
<span class="line-removed">- #include &quot;IntSize.h&quot;</span>
  #include &lt;memory&gt;
  #include &lt;wtf/Forward.h&gt;
  
  #if ENABLE(WEBGL)
  #include &quot;WebGLContextAttributes.h&quot;
  #endif
  
  namespace WebCore {
  
  class BlobCallback;
  class CanvasRenderingContext2D;
  class GraphicsContext;
<span class="line-removed">- class GraphicsContextStateSaver;</span>
  class Image;
  class ImageBuffer;
  class ImageData;
  class MediaSample;
  class MediaStream;
<span class="line-new-header">--- 29,23 ---</span>
  
  #include &quot;CanvasBase.h&quot;
  #include &quot;FloatRect.h&quot;
  #include &quot;HTMLElement.h&quot;
  #include &quot;ImageBitmapRenderingContextSettings.h&quot;
  #include &lt;memory&gt;
  #include &lt;wtf/Forward.h&gt;
  
  #if ENABLE(WEBGL)
  #include &quot;WebGLContextAttributes.h&quot;
  #endif
  
  namespace WebCore {
  
  class BlobCallback;
<span class="line-added">+ class CanvasRenderingContext;</span>
  class CanvasRenderingContext2D;
  class GraphicsContext;
  class Image;
  class ImageBuffer;
  class ImageData;
  class MediaSample;
  class MediaStream;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 63,30 ***</span>
  public:
      static Ref&lt;HTMLCanvasElement&gt; create(Document&amp;);
      static Ref&lt;HTMLCanvasElement&gt; create(const QualifiedName&amp;, Document&amp;);
      virtual ~HTMLCanvasElement();
  
<span class="line-removed">-     unsigned width() const final { return size().width(); }</span>
<span class="line-removed">-     unsigned height() const final { return size().height(); }</span>
<span class="line-removed">- </span>
      WEBCORE_EXPORT ExceptionOr&lt;void&gt; setWidth(unsigned);
      WEBCORE_EXPORT ExceptionOr&lt;void&gt; setHeight(unsigned);
  
<span class="line-modified">!     const IntSize&amp; size() const final { return m_size; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void setSize(const IntSize&amp; newSize) override</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         if (newSize == size())</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         m_ignoreReset = true;</span>
<span class="line-removed">-         setWidth(newSize.width());</span>
<span class="line-removed">-         setHeight(newSize.height());</span>
<span class="line-removed">-         m_ignoreReset = false;</span>
<span class="line-removed">-         reset();</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     ExceptionOr&lt;Optional&lt;RenderingContext&gt;&gt; getContext(JSC::ExecState&amp;, const String&amp; contextId, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments);</span>
  
      CanvasRenderingContext* getContext(const String&amp;);
  
      static bool is2dType(const String&amp;);
      CanvasRenderingContext2D* createContext2d(const String&amp; type);
<span class="line-new-header">--- 62,17 ---</span>
  public:
      static Ref&lt;HTMLCanvasElement&gt; create(Document&amp;);
      static Ref&lt;HTMLCanvasElement&gt; create(const QualifiedName&amp;, Document&amp;);
      virtual ~HTMLCanvasElement();
  
      WEBCORE_EXPORT ExceptionOr&lt;void&gt; setWidth(unsigned);
      WEBCORE_EXPORT ExceptionOr&lt;void&gt; setHeight(unsigned);
  
<span class="line-modified">!     void setSize(const IntSize&amp; newSize) override;</span>
  
<span class="line-modified">!     CanvasRenderingContext* renderingContext() const final { return m_context.get(); }</span>
<span class="line-added">+     ExceptionOr&lt;Optional&lt;RenderingContext&gt;&gt; getContext(JSC::JSGlobalObject&amp;, const String&amp; contextId, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments);</span>
  
      CanvasRenderingContext* getContext(const String&amp;);
  
      static bool is2dType(const String&amp;);
      CanvasRenderingContext2D* createContext2d(const String&amp; type);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 114,46 ***</span>
      // Used for rendering
      void didDraw(const FloatRect&amp;) final;
  
      void paint(GraphicsContext&amp;, const LayoutRect&amp;);
  
<span class="line-removed">-     GraphicsContext* drawingContext() const final;</span>
<span class="line-removed">-     GraphicsContext* existingDrawingContext() const final;</span>
<span class="line-removed">- </span>
  #if ENABLE(MEDIA_STREAM)
      RefPtr&lt;MediaSample&gt; toMediaSample();
      ExceptionOr&lt;Ref&lt;MediaStream&gt;&gt; captureStream(Document&amp;, Optional&lt;double&gt;&amp;&amp; frameRequestRate);
  #endif
  
<span class="line-removed">-     ImageBuffer* buffer() const;</span>
      Image* copiedImage() const final;
      void clearCopiedImage();
      RefPtr&lt;ImageData&gt; getImageData();
      void makePresentationCopy();
      void clearPresentationCopy();
  
      SecurityOrigin* securityOrigin() const final;
  
<span class="line-removed">-     AffineTransform baseTransform() const final;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void makeRenderingResultsAvailable() final;</span>
<span class="line-removed">-     bool hasCreatedImageBuffer() const { return m_hasCreatedImageBuffer; }</span>
<span class="line-removed">- </span>
      bool shouldAccelerate(const IntSize&amp;) const;
  
      WEBCORE_EXPORT void setUsesDisplayListDrawing(bool);
      WEBCORE_EXPORT void setTracksDisplayListReplay(bool);
      WEBCORE_EXPORT String displayListAsText(DisplayList::AsTextFlags) const;
      WEBCORE_EXPORT String replayDisplayListAsText(DisplayList::AsTextFlags) const;
  
<span class="line-removed">-     size_t memoryCost() const;</span>
<span class="line-removed">-     size_t externalMemoryCost() const;</span>
<span class="line-removed">- </span>
      // FIXME: Only some canvas rendering contexts need an ImageBuffer.
      // It would be better to have the contexts own the buffers.
      void setImageBufferAndMarkDirty(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp;);
  
  private:
      HTMLCanvasElement(const QualifiedName&amp;, Document&amp;);
  
      bool isHTMLCanvasElement() const final { return true; }
  
<span class="line-new-header">--- 100,36 ---</span>
      // Used for rendering
      void didDraw(const FloatRect&amp;) final;
  
      void paint(GraphicsContext&amp;, const LayoutRect&amp;);
  
  #if ENABLE(MEDIA_STREAM)
      RefPtr&lt;MediaSample&gt; toMediaSample();
      ExceptionOr&lt;Ref&lt;MediaStream&gt;&gt; captureStream(Document&amp;, Optional&lt;double&gt;&amp;&amp; frameRequestRate);
  #endif
  
      Image* copiedImage() const final;
      void clearCopiedImage();
      RefPtr&lt;ImageData&gt; getImageData();
      void makePresentationCopy();
      void clearPresentationCopy();
  
      SecurityOrigin* securityOrigin() const final;
  
      bool shouldAccelerate(const IntSize&amp;) const;
  
      WEBCORE_EXPORT void setUsesDisplayListDrawing(bool);
      WEBCORE_EXPORT void setTracksDisplayListReplay(bool);
      WEBCORE_EXPORT String displayListAsText(DisplayList::AsTextFlags) const;
      WEBCORE_EXPORT String replayDisplayListAsText(DisplayList::AsTextFlags) const;
  
      // FIXME: Only some canvas rendering contexts need an ImageBuffer.
      // It would be better to have the contexts own the buffers.
      void setImageBufferAndMarkDirty(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp;);
  
<span class="line-added">+     WEBCORE_EXPORT static void setMaxPixelMemoryForTesting(size_t);</span>
<span class="line-added">+ </span>
  private:
      HTMLCanvasElement(const QualifiedName&amp;, Document&amp;);
  
      bool isHTMLCanvasElement() const final { return true; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 163,16 ***</span>
      bool canContainRangeEndPoint() const final;
      bool canStartSelection() const final;
  
      void reset();
  
<span class="line-modified">!     void createImageBuffer() const;</span>
      void clearImageBuffer() const;
  
      void setSurfaceSize(const IntSize&amp;);
<span class="line-removed">-     void setImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp;) const;</span>
<span class="line-removed">-     void releaseImageBufferAndContext();</span>
  
      bool paintsIntoCanvasBuffer() const;
  
      bool isGPUBased() const;
  
<span class="line-new-header">--- 139,16 ---</span>
      bool canContainRangeEndPoint() const final;
      bool canStartSelection() const final;
  
      void reset();
  
<span class="line-modified">!     void createImageBuffer() const final;</span>
      void clearImageBuffer() const;
  
<span class="line-added">+     bool hasCreatedImageBuffer() const final { return m_hasCreatedImageBuffer; }</span>
<span class="line-added">+ </span>
      void setSurfaceSize(const IntSize&amp;);
  
      bool paintsIntoCanvasBuffer() const;
  
      bool isGPUBased() const;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 180,24 ***</span>
      void derefCanvasBase() final { HTMLElement::deref(); }
  
      ScriptExecutionContext* canvasBaseScriptExecutionContext() const final { return HTMLElement::scriptExecutionContext(); }
  
      FloatRect m_dirtyRect;
<span class="line-removed">-     mutable IntSize m_size;</span>
  
      bool m_ignoreReset { false };
  
      bool m_usesDisplayListDrawing { false };
      bool m_tracksDisplayListReplay { false };
  
<span class="line-modified">!     mutable Lock m_imageBufferAssignmentLock;</span>
  
<span class="line-modified">!     // m_createdImageBuffer means we tried to malloc the buffer.  We didn&#39;t necessarily get it.</span>
      mutable bool m_hasCreatedImageBuffer { false };
      mutable bool m_didClearImageBuffer { false };
<span class="line-removed">-     mutable std::unique_ptr&lt;ImageBuffer&gt; m_imageBuffer;</span>
<span class="line-removed">-     mutable std::unique_ptr&lt;GraphicsContextStateSaver&gt; m_contextStateSaver;</span>
  
      mutable RefPtr&lt;Image&gt; m_presentedImage;
      mutable RefPtr&lt;Image&gt; m_copiedImage; // FIXME: This is temporary for platforms that have to copy the image buffer to render (and for CSSCanvasValue).
  };
  
<span class="line-new-header">--- 156,21 ---</span>
      void derefCanvasBase() final { HTMLElement::deref(); }
  
      ScriptExecutionContext* canvasBaseScriptExecutionContext() const final { return HTMLElement::scriptExecutionContext(); }
  
      FloatRect m_dirtyRect;
  
      bool m_ignoreReset { false };
  
      bool m_usesDisplayListDrawing { false };
      bool m_tracksDisplayListReplay { false };
  
<span class="line-modified">!     std::unique_ptr&lt;CanvasRenderingContext&gt; m_context;</span>
  
<span class="line-modified">!     // m_hasCreatedImageBuffer means we tried to malloc the buffer. We didn&#39;t necessarily get it.</span>
      mutable bool m_hasCreatedImageBuffer { false };
      mutable bool m_didClearImageBuffer { false };
  
      mutable RefPtr&lt;Image&gt; m_presentedImage;
      mutable RefPtr&lt;Image&gt; m_copiedImage; // FIXME: This is temporary for platforms that have to copy the image buffer to render (and for CSSCanvasValue).
  };
  
</pre>
<center><a href="HTMLCanvasElement.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLCanvasElement.idl.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
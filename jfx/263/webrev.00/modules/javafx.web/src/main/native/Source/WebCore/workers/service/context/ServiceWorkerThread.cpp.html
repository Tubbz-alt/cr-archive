<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/ServiceWorkerThread.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ServiceWorkerThread.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;CacheStorageProvider.h&quot;
 32 #include &quot;ContentSecurityPolicyResponseHeaders.h&quot;
 33 #include &quot;EventLoop.h&quot;
 34 #include &quot;EventNames.h&quot;
 35 #include &quot;ExtendableMessageEvent.h&quot;
 36 #include &quot;JSDOMPromise.h&quot;
 37 #include &quot;LoaderStrategy.h&quot;
 38 #include &quot;PlatformStrategies.h&quot;
 39 #include &quot;SWContextManager.h&quot;
 40 #include &quot;SecurityOrigin.h&quot;
 41 #include &quot;ServiceWorkerFetch.h&quot;
 42 #include &quot;ServiceWorkerGlobalScope.h&quot;
 43 #include &quot;ServiceWorkerWindowClient.h&quot;
 44 #include &quot;WorkerDebuggerProxy.h&quot;
 45 #include &quot;WorkerLoaderProxy.h&quot;
 46 #include &quot;WorkerObjectProxy.h&quot;
 47 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 48 #include &lt;JavaScriptCore/RuntimeFlags.h&gt;
 49 #include &lt;wtf/NeverDestroyed.h&gt;
 50 
 51 using namespace PAL;
 52 
 53 namespace WebCore {
 54 
 55 class DummyServiceWorkerThreadProxy : public WorkerObjectProxy {
 56 public:
 57     static DummyServiceWorkerThreadProxy&amp; shared()
 58     {
 59         static NeverDestroyed&lt;DummyServiceWorkerThreadProxy&gt; proxy;
 60         return proxy;
 61     }
 62 
 63 private:
 64     void postExceptionToWorkerObject(const String&amp;, int, int, const String&amp;) final { };
 65     void workerGlobalScopeDestroyed() final { };
 66     void postMessageToWorkerObject(MessageWithMessagePorts&amp;&amp;) final { };
 67     void confirmMessageFromWorkerObject(bool) final { };
 68     void reportPendingActivity(bool) final { };
 69 };
 70 
 71 // FIXME: Use a valid WorkerReportingProxy
 72 // FIXME: Use a valid WorkerObjectProxy
 73 // FIXME: Use valid runtime flags
 74 
 75 ServiceWorkerThread::ServiceWorkerThread(const ServiceWorkerContextData&amp; data, String&amp;&amp; userAgent, WorkerLoaderProxy&amp; loaderProxy, WorkerDebuggerProxy&amp; debuggerProxy, IDBClient::IDBConnectionProxy* idbConnectionProxy, SocketProvider* socketProvider)
 76     : WorkerThread({ data.scriptURL, emptyString(), &quot;serviceworker:&quot; + Inspector::IdentifiersFactory::createIdentifier(), WTFMove(userAgent), platformStrategies()-&gt;loaderStrategy()-&gt;isOnLine(), data.contentSecurityPolicy, false, MonotonicTime::now(), { } }, data.script, loaderProxy, debuggerProxy, DummyServiceWorkerThreadProxy::shared(), WorkerThreadStartMode::Normal, data.registration.key.topOrigin().securityOrigin().get(), idbConnectionProxy, socketProvider, JSC::RuntimeFlags::createAllEnabled())
 77     , m_data(data.isolatedCopy())
 78     , m_workerObjectProxy(DummyServiceWorkerThreadProxy::shared())
 79     , m_heartBeatTimeout(SWContextManager::singleton().connection()-&gt;shouldUseShortTimeout() ? heartBeatTimeoutForTest : heartBeatTimeout)
 80     , m_heartBeatTimer { *this, &amp;ServiceWorkerThread::heartBeatTimerFired }
 81 {
 82     AtomString::init();
 83 }
 84 
 85 ServiceWorkerThread::~ServiceWorkerThread() = default;
 86 
 87 Ref&lt;WorkerGlobalScope&gt; ServiceWorkerThread::createWorkerGlobalScope(const WorkerParameters&amp; params, Ref&lt;SecurityOrigin&gt;&amp;&amp; origin, Ref&lt;SecurityOrigin&gt;&amp;&amp; topOrigin)
 88 {
 89     return ServiceWorkerGlobalScope::create(m_data, params, WTFMove(origin), *this, WTFMove(topOrigin), idbConnectionProxy(), socketProvider());
 90 }
 91 
 92 void ServiceWorkerThread::runEventLoop()
 93 {
 94     // FIXME: There will be ServiceWorker specific things to do here.
 95     WorkerThread::runEventLoop();
 96 }
 97 
 98 void ServiceWorkerThread::queueTaskToFireFetchEvent(Ref&lt;ServiceWorkerFetch::Client&gt;&amp;&amp; client, Optional&lt;ServiceWorkerClientIdentifier&gt;&amp;&amp; clientId, ResourceRequest&amp;&amp; request, String&amp;&amp; referrer, FetchOptions&amp;&amp; options)
 99 {
100     auto serviceWorkerGlobalScope = makeRef(downcast&lt;ServiceWorkerGlobalScope&gt;(*workerGlobalScope()));
101     serviceWorkerGlobalScope-&gt;eventLoop().queueTask(TaskSource::DOMManipulation, [serviceWorkerGlobalScope = serviceWorkerGlobalScope.copyRef(), client = WTFMove(client), clientId, request = WTFMove(request), referrer = WTFMove(referrer), options = WTFMove(options)]() mutable {
102         ServiceWorkerFetch::dispatchFetchEvent(WTFMove(client), serviceWorkerGlobalScope, clientId, WTFMove(request), WTFMove(referrer), WTFMove(options));
103     });
104 }
105 
106 static void fireMessageEvent(ServiceWorkerGlobalScope&amp; scope, MessageWithMessagePorts&amp;&amp; message, ExtendableMessageEventSource&amp;&amp; source, const URL&amp; sourceURL)
107 {
108     auto ports = MessagePort::entanglePorts(scope, WTFMove(message.transferredPorts));
109     auto messageEvent = ExtendableMessageEvent::create(WTFMove(ports), WTFMove(message.message), SecurityOriginData::fromURL(sourceURL).toString(), { }, source);
110     scope.dispatchEvent(messageEvent);
111     scope.thread().workerObjectProxy().confirmMessageFromWorkerObject(scope.hasPendingActivity());
112     scope.updateExtendedEventsSet(messageEvent.ptr());
113 }
114 
115 void ServiceWorkerThread::queueTaskToPostMessage(MessageWithMessagePorts&amp;&amp; message, ServiceWorkerOrClientData&amp;&amp; sourceData)
116 {
117     auto serviceWorkerGlobalScope = makeRef(downcast&lt;ServiceWorkerGlobalScope&gt;(*workerGlobalScope()));
118     serviceWorkerGlobalScope-&gt;eventLoop().queueTask(TaskSource::DOMManipulation, [serviceWorkerGlobalScope = serviceWorkerGlobalScope.copyRef(), message = WTFMove(message), sourceData = WTFMove(sourceData), serviceWorkerIdentifier = this-&gt;identifier()]() mutable {
119         URL sourceURL;
120         ExtendableMessageEventSource source;
121         if (WTF::holds_alternative&lt;ServiceWorkerClientData&gt;(sourceData)) {
122             RefPtr&lt;ServiceWorkerClient&gt; sourceClient = ServiceWorkerClient::getOrCreate(serviceWorkerGlobalScope, WTFMove(WTF::get&lt;ServiceWorkerClientData&gt;(sourceData)));
123 
124             RELEASE_ASSERT(!sourceClient-&gt;url().protocolIsInHTTPFamily() || !serviceWorkerGlobalScope-&gt;url().protocolIsInHTTPFamily() || protocolHostAndPortAreEqual(serviceWorkerGlobalScope-&gt;url(), sourceClient-&gt;url()));
125 
126             sourceURL = sourceClient-&gt;url();
127             source = WTFMove(sourceClient);
128         } else {
129             RefPtr&lt;ServiceWorker&gt; sourceWorker = ServiceWorker::getOrCreate(serviceWorkerGlobalScope, WTFMove(WTF::get&lt;ServiceWorkerData&gt;(sourceData)));
130 
131             RELEASE_ASSERT(!sourceWorker-&gt;scriptURL().protocolIsInHTTPFamily() || !serviceWorkerGlobalScope-&gt;url().protocolIsInHTTPFamily() || protocolHostAndPortAreEqual(serviceWorkerGlobalScope-&gt;url(), sourceWorker-&gt;scriptURL()));
132 
133             sourceURL = sourceWorker-&gt;scriptURL();
134             source = WTFMove(sourceWorker);
135         }
136         fireMessageEvent(serviceWorkerGlobalScope, WTFMove(message), ExtendableMessageEventSource { source }, sourceURL);
137         callOnMainThread([serviceWorkerIdentifier] {
138             if (auto* serviceWorkerThreadProxy = SWContextManager::singleton().serviceWorkerThreadProxy(serviceWorkerIdentifier))
139                 serviceWorkerThreadProxy-&gt;thread().finishedFiringMessageEvent();
140         });
141     });
142 }
143 
144 void ServiceWorkerThread::queueTaskToFireInstallEvent()
145 {
146     auto serviceWorkerGlobalScope = makeRef(downcast&lt;ServiceWorkerGlobalScope&gt;(*workerGlobalScope()));
147     serviceWorkerGlobalScope-&gt;eventLoop().queueTask(TaskSource::DOMManipulation, [serviceWorkerGlobalScope = serviceWorkerGlobalScope.copyRef(), jobDataIdentifier = m_data.jobDataIdentifier, serviceWorkerIdentifier = this-&gt;identifier()] {
148         auto installEvent = ExtendableEvent::create(eventNames().installEvent, { }, ExtendableEvent::IsTrusted::Yes);
149         serviceWorkerGlobalScope-&gt;dispatchEvent(installEvent);
150 
151         installEvent-&gt;whenAllExtendLifetimePromisesAreSettled([jobDataIdentifier, serviceWorkerIdentifier](HashSet&lt;Ref&lt;DOMPromise&gt;&gt;&amp;&amp; extendLifetimePromises) {
152             bool hasRejectedAnyPromise = false;
153             for (auto&amp; promise : extendLifetimePromises) {
154                 if (promise-&gt;status() == DOMPromise::Status::Rejected) {
155                     hasRejectedAnyPromise = true;
156                     break;
157                 }
158             }
159             callOnMainThread([serviceWorkerIdentifier, hasRejectedAnyPromise] {
160                 if (auto* serviceWorkerThreadProxy = SWContextManager::singleton().serviceWorkerThreadProxy(serviceWorkerIdentifier))
161                     serviceWorkerThreadProxy-&gt;thread().finishedFiringInstallEvent(hasRejectedAnyPromise);
162             });
163         });
164     });
165 }
166 
167 void ServiceWorkerThread::queueTaskToFireActivateEvent()
168 {
169     auto serviceWorkerGlobalScope = makeRef(downcast&lt;ServiceWorkerGlobalScope&gt;(*workerGlobalScope()));
170     serviceWorkerGlobalScope-&gt;eventLoop().queueTask(TaskSource::DOMManipulation, [serviceWorkerGlobalScope = serviceWorkerGlobalScope.copyRef(), serviceWorkerIdentifier = this-&gt;identifier()]() mutable {
171         auto activateEvent = ExtendableEvent::create(eventNames().activateEvent, { }, ExtendableEvent::IsTrusted::Yes);
172         serviceWorkerGlobalScope-&gt;dispatchEvent(activateEvent);
173 
174         activateEvent-&gt;whenAllExtendLifetimePromisesAreSettled([serviceWorkerIdentifier](HashSet&lt;Ref&lt;DOMPromise&gt;&gt;&amp;&amp;) {
175             callOnMainThread([serviceWorkerIdentifier] {
176                 if (auto* serviceWorkerThreadProxy = SWContextManager::singleton().serviceWorkerThreadProxy(serviceWorkerIdentifier))
177                     serviceWorkerThreadProxy-&gt;thread().finishedFiringActivateEvent();
178             });
179         });
180     });
181 }
182 
183 void ServiceWorkerThread::finishedEvaluatingScript()
184 {
185     ASSERT(!isMainThread());
186     m_doesHandleFetch = workerGlobalScope()-&gt;hasEventListeners(eventNames().fetchEvent);
187 }
188 
189 void ServiceWorkerThread::start(Function&lt;void(const String&amp;, bool)&gt;&amp;&amp; callback)
190 {
191     m_state = State::Starting;
192     startHeartBeatTimer();
193 
194     WorkerThread::start([callback = WTFMove(callback), serviceWorkerIdentifier = this-&gt;identifier()](auto&amp; errorMessage) mutable {
195         bool doesHandleFetch = true;
196         if (auto* threadProxy = SWContextManager::singleton().workerByID(serviceWorkerIdentifier)) {
197             threadProxy-&gt;thread().finishedStarting();
198             doesHandleFetch = threadProxy-&gt;thread().doesHandleFetch();
199         }
200         callback(errorMessage, doesHandleFetch);
201     });
202 }
203 
204 void ServiceWorkerThread::finishedStarting()
205 {
206     m_state = State::Idle;
207 }
208 
209 void ServiceWorkerThread::startFetchEventMonitoring()
210 {
211     m_isHandlingFetchEvent = true;
212     startHeartBeatTimer();
213 }
214 
215 void ServiceWorkerThread::startHeartBeatTimer()
216 {
217     if (m_heartBeatTimer.isActive())
218         return;
219 
220     m_ongoingHeartBeatCheck = true;
221     runLoop().postTask([this, protectedThis = makeRef(*this)](auto&amp;) mutable {
222         callOnMainThread([this, protectedThis = WTFMove(protectedThis)]() {
223             m_ongoingHeartBeatCheck = false;
224         });
225     });
226 
227     m_heartBeatTimer.startOneShot(m_heartBeatTimeout);
228 }
229 
230 void ServiceWorkerThread::heartBeatTimerFired()
231 {
232     if (!m_ongoingHeartBeatCheck) {
233         if (m_state == State::Installing || m_state == State::Activating || m_isHandlingFetchEvent || m_messageEventCount)
234             startHeartBeatTimer();
235         return;
236     }
237 
238     auto* serviceWorkerThreadProxy = SWContextManager::singleton().serviceWorkerThreadProxy(identifier());
239     if (!serviceWorkerThreadProxy || serviceWorkerThreadProxy-&gt;isTerminatingOrTerminated())
240         return;
241 
242     auto* connection = SWContextManager::singleton().connection();
243     if (!connection)
244         return;
245 
246     switch (m_state) {
247     case State::Idle:
248     case State::Activating:
249         connection-&gt;didFailHeartBeatCheck(identifier());
250         break;
251     case State::Starting:
252         connection-&gt;serviceWorkerFailedToStart(m_data.jobDataIdentifier, identifier(), &quot;Service Worker script execution timed out&quot;_s);
253         break;
254     case State::Installing:
255         connection-&gt;didFinishInstall(m_data.jobDataIdentifier, identifier(), false);
256         break;
257     }
258 }
259 
260 void ServiceWorkerThread::willPostTaskToFireInstallEvent()
261 {
262     m_state = State::Installing;
263     startHeartBeatTimer();
264 }
265 
266 void ServiceWorkerThread::finishedFiringInstallEvent(bool hasRejectedAnyPromise)
267 {
268     m_state = State::Idle;
269 
270     if (auto* connection = SWContextManager::singleton().connection())
271         connection-&gt;didFinishInstall(m_data.jobDataIdentifier, identifier(), !hasRejectedAnyPromise);
272 }
273 
274 void ServiceWorkerThread::willPostTaskToFireActivateEvent()
275 {
276     m_state = State::Activating;
277     startHeartBeatTimer();
278 }
279 
280 void ServiceWorkerThread::finishedFiringActivateEvent()
281 {
282     m_state = State::Idle;
283 
284     if (auto* connection = SWContextManager::singleton().connection())
285         connection-&gt;didFinishActivation(identifier());
286 }
287 
288 void ServiceWorkerThread::willPostTaskToFireMessageEvent()
289 {
290     if (!m_messageEventCount++)
291         startHeartBeatTimer();
292 }
293 
294 void ServiceWorkerThread::finishedFiringMessageEvent()
295 {
296     ASSERT(m_messageEventCount);
297     --m_messageEventCount;
298 }
299 
300 } // namespace WebCore
301 
302 #endif // ENABLE(SERVICE_WORKER)
    </pre>
  </body>
</html>
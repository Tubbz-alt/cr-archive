<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/BytecodeGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../bytecode/Watchpoint.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeGenerator.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/BytecodeGenerator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  17  *     from this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  23  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  26  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  28  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29  */
  30 
  31 #include &quot;config.h&quot;
  32 #include &quot;BytecodeGenerator.h&quot;
  33 
  34 #include &quot;ArithProfile.h&quot;
  35 #include &quot;BuiltinExecutables.h&quot;
  36 #include &quot;BuiltinNames.h&quot;

  37 #include &quot;BytecodeGeneratorification.h&quot;
  38 #include &quot;BytecodeLivenessAnalysis.h&quot;
<span class="line-removed">  39 #include &quot;BytecodeStructs.h&quot;</span>
  40 #include &quot;BytecodeUseDef.h&quot;
  41 #include &quot;CatchScope.h&quot;
  42 #include &quot;DefinePropertyAttributes.h&quot;
  43 #include &quot;Interpreter.h&quot;
<span class="line-modified">  44 #include &quot;JSAsyncGeneratorFunction.h&quot;</span>
  45 #include &quot;JSBigInt.h&quot;
  46 #include &quot;JSCInlines.h&quot;
<span class="line-removed">  47 #include &quot;JSFixedArray.h&quot;</span>
  48 #include &quot;JSFunction.h&quot;
  49 #include &quot;JSGeneratorFunction.h&quot;
  50 #include &quot;JSImmutableButterfly.h&quot;
  51 #include &quot;JSLexicalEnvironment.h&quot;
  52 #include &quot;JSTemplateObjectDescriptor.h&quot;

  53 #include &quot;LowLevelInterpreter.h&quot;
  54 #include &quot;Options.h&quot;
  55 #include &quot;PreciseJumpTargetsInlines.h&quot;
  56 #include &quot;StackAlignment.h&quot;
  57 #include &quot;StrongInlines.h&quot;
  58 #include &quot;SuperSamplerBytecodeScope.h&quot;
  59 #include &quot;UnlinkedCodeBlock.h&quot;
  60 #include &quot;UnlinkedEvalCodeBlock.h&quot;
  61 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
  62 #include &quot;UnlinkedMetadataTableInlines.h&quot;
  63 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
  64 #include &quot;UnlinkedProgramCodeBlock.h&quot;
  65 #include &lt;wtf/BitVector.h&gt;
  66 #include &lt;wtf/CommaPrinter.h&gt;
  67 #include &lt;wtf/Optional.h&gt;
  68 #include &lt;wtf/SmallPtrSet.h&gt;
  69 #include &lt;wtf/StdLibExtras.h&gt;
  70 #include &lt;wtf/text/WTFString.h&gt;
  71 
  72 namespace JSC {
  73 
  74 template&lt;typename CallOp, typename = std::true_type&gt;
  75 struct VarArgsOp;
  76 
  77 template&lt;typename CallOp&gt;
  78 struct VarArgsOp&lt;CallOp, std::enable_if_t&lt;std::is_same&lt;CallOp, OpTailCall&gt;::value, std::true_type&gt;&gt; {
  79     using type = OpTailCallVarargs;
  80 };
  81 
  82 
  83 template&lt;typename CallOp&gt;
  84 struct VarArgsOp&lt;CallOp, std::enable_if_t&lt;!std::is_same&lt;CallOp, OpTailCall&gt;::value, std::true_type&gt;&gt; {
  85     using type = OpCallVarargs;
  86 };
  87 
<span class="line-modified">  88 </span>
<span class="line-modified">  89 template&lt;typename T&gt;</span>
<span class="line-removed">  90 static inline void shrinkToFit(T&amp; segmentedVector)</span>
<span class="line-removed">  91 {</span>
<span class="line-removed">  92     while (segmentedVector.size() &amp;&amp; !segmentedVector.last().refCount())</span>
<span class="line-removed">  93         segmentedVector.removeLast();</span>
<span class="line-removed">  94 }</span>
<span class="line-removed">  95 </span>
<span class="line-removed">  96 void Label::setLocation(BytecodeGenerator&amp; generator, unsigned location)</span>
  97 {
  98     m_location = location;
  99 
 100     for (auto offset : m_unresolvedJumps) {
 101         auto instruction = generator.m_writer.ref(offset);
 102         int target = m_location - offset;
 103 
 104 #define CASE(__op) \
 105     case __op::opcodeID:  \
 106         instruction-&gt;cast&lt;__op&gt;()-&gt;setTargetLabel(BoundLabel(target), [&amp;]() { \
 107             generator.m_codeBlock-&gt;addOutOfLineJumpTarget(instruction.offset(), target); \
 108             return BoundLabel(); \
 109         }); \
 110         break;
 111 
 112         switch (instruction-&gt;opcodeID()) {
 113         CASE(OpJmp)
 114         CASE(OpJtrue)
 115         CASE(OpJfalse)
 116         CASE(OpJeqNull)
</pre>
<hr />
<pre>
 122         CASE(OpJneq)
 123         CASE(OpJneqPtr)
 124         CASE(OpJnstricteq)
 125         CASE(OpJless)
 126         CASE(OpJlesseq)
 127         CASE(OpJgreater)
 128         CASE(OpJgreatereq)
 129         CASE(OpJnless)
 130         CASE(OpJnlesseq)
 131         CASE(OpJngreater)
 132         CASE(OpJngreatereq)
 133         CASE(OpJbelow)
 134         CASE(OpJbeloweq)
 135         default:
 136             ASSERT_NOT_REACHED();
 137         }
 138 #undef CASE
 139     }
 140 }
 141 
<span class="line-removed"> 142 int BoundLabel::target()</span>
<span class="line-removed"> 143 {</span>
<span class="line-removed"> 144     switch (m_type) {</span>
<span class="line-removed"> 145     case Offset:</span>
<span class="line-removed"> 146         return m_target;</span>
<span class="line-removed"> 147     case GeneratorBackward:</span>
<span class="line-removed"> 148         return m_target - m_generator-&gt;m_writer.position();</span>
<span class="line-removed"> 149     case GeneratorForward:</span>
<span class="line-removed"> 150         return 0;</span>
<span class="line-removed"> 151     default:</span>
<span class="line-removed"> 152         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed"> 153     }</span>
<span class="line-removed"> 154 }</span>
<span class="line-removed"> 155 </span>
<span class="line-removed"> 156 int BoundLabel::saveTarget()</span>
<span class="line-removed"> 157 {</span>
<span class="line-removed"> 158     if (m_type == GeneratorForward) {</span>
<span class="line-removed"> 159         m_savedTarget = m_generator-&gt;m_writer.position();</span>
<span class="line-removed"> 160         return 0;</span>
<span class="line-removed"> 161     }</span>
<span class="line-removed"> 162 </span>
<span class="line-removed"> 163     m_savedTarget = target();</span>
<span class="line-removed"> 164     return m_savedTarget;</span>
<span class="line-removed"> 165 }</span>
<span class="line-removed"> 166 </span>
<span class="line-removed"> 167 int BoundLabel::commitTarget()</span>
<span class="line-removed"> 168 {</span>
<span class="line-removed"> 169     if (m_type == GeneratorForward) {</span>
<span class="line-removed"> 170         m_label-&gt;m_unresolvedJumps.append(m_savedTarget);</span>
<span class="line-removed"> 171         return 0;</span>
<span class="line-removed"> 172     }</span>
<span class="line-removed"> 173 </span>
<span class="line-removed"> 174     return m_savedTarget;</span>
<span class="line-removed"> 175 }</span>
<span class="line-removed"> 176 </span>
 177 void Variable::dump(PrintStream&amp; out) const
 178 {
 179     out.print(
 180         &quot;{ident = &quot;, m_ident,
 181         &quot;, offset = &quot;, m_offset,
 182         &quot;, local = &quot;, RawPointer(m_local),
 183         &quot;, attributes = &quot;, m_attributes,
 184         &quot;, kind = &quot;, m_kind,
 185         &quot;, symbolTableConstantIndex = &quot;, m_symbolTableConstantIndex,
 186         &quot;, isLexicallyScoped = &quot;, m_isLexicallyScoped, &quot;}&quot;);
 187 }
 188 
 189 FinallyContext::FinallyContext(BytecodeGenerator&amp; generator, Label&amp; finallyLabel)
 190     : m_outerContext(generator.m_currentFinallyContext)
 191     , m_finallyLabel(&amp;finallyLabel)
 192 {
 193     ASSERT(m_jumps.isEmpty());
 194     m_completionRecord.typeRegister = generator.newTemporary();
 195     m_completionRecord.valueRegister = generator.newTemporary();
 196     generator.emitLoad(completionTypeRegister(), CompletionType::Normal);
</pre>
<hr />
<pre>
 231                     //         {
 232                     //             let x;
 233                     //             {
 234                     //             //// error thrown here
 235                     //                  eval(&quot;function x(){}&quot;);
 236                     //             }
 237                     //         }
 238                     //     }
 239                     // ```
 240                     // Therefore, we&#39;re guaranteed to have this resolve to a top level variable.
 241                     RefPtr&lt;RegisterID&gt; tolLevelObjectScope = emitResolveScope(nullptr, Variable(metadata-&gt;ident()));
 242                     tolLevelScope = newBlockScopeVariable();
 243                     move(tolLevelScope.get(), tolLevelObjectScope.get());
 244                 }
 245                 emitPutToScope(tolLevelScope.get(), Variable(metadata-&gt;ident()), temp.get(), ThrowIfNotFound, InitializationMode::NotInitialization);
 246             } else
 247                 RELEASE_ASSERT_NOT_REACHED();
 248         }
 249     }
 250 
<span class="line-modified"> 251     bool callingClassConstructor = constructorKind() != ConstructorKind::None &amp;&amp; !isConstructor();</span>









 252     if (!callingClassConstructor)
 253         m_scopeNode-&gt;emitBytecode(*this);
 254     else {
 255         // At this point we would have emitted an unconditional throw followed by some nonsense that&#39;s
 256         // just an artifact of how this generator is structured. That code never runs, but it confuses
 257         // bytecode analyses because it constitutes an unterminated basic block. So, we terminate the
 258         // basic block the strongest way possible.
 259         emitUnreachable();
 260     }
 261 
 262     for (auto&amp; handler : m_exceptionHandlersToEmit) {
 263         Ref&lt;Label&gt; realCatchTarget = newLabel();
 264         TryData* tryData = handler.tryData;
 265 
 266         OpCatch::emit(this, handler.exceptionRegister, handler.thrownValueRegister);
 267         realCatchTarget-&gt;setLocation(*this, m_lastInstruction.offset());
 268         if (handler.completionTypeRegister.isValid()) {
 269             RegisterID completionTypeRegister { handler.completionTypeRegister };
 270             CompletionType completionType =
 271                 tryData-&gt;handlerType == HandlerType::Finally || tryData-&gt;handlerType == HandlerType::SynthesizedFinally
</pre>
<hr />
<pre>
 304         // but because we haven&#39;t yet had a chance to plant the catch target. Then when we finish
 305         // emitting code for the outer finally block, we repush the try contex, this time with a
 306         // new start index. But that means that the start index for the try range corresponding
 307         // to the inner-finally-following-the-return (marked as &quot;*HERE*&quot; above) will be greater
 308         // than the end index of the try block. This is harmless since end &lt; start handlers will
 309         // never get matched in our logic, but we do the runtime a favor and choose to not emit
 310         // such handlers at all.
 311         if (end &lt;= start)
 312             continue;
 313 
 314         UnlinkedHandlerInfo info(static_cast&lt;uint32_t&gt;(start), static_cast&lt;uint32_t&gt;(end),
 315             static_cast&lt;uint32_t&gt;(range.tryData-&gt;target-&gt;bind()), range.tryData-&gt;handlerType);
 316         m_codeBlock-&gt;addExceptionHandler(info);
 317     }
 318 
 319 
 320     if (isGeneratorOrAsyncFunctionBodyParseMode(m_codeBlock-&gt;parseMode()))
 321         performGeneratorification(*this, m_codeBlock.get(), m_writer, m_generatorFrameSymbolTable.get(), m_generatorFrameSymbolTableIndex);
 322 
 323     RELEASE_ASSERT(static_cast&lt;unsigned&gt;(m_codeBlock-&gt;numCalleeLocals()) &lt; static_cast&lt;unsigned&gt;(FirstConstantRegisterIndex));
<span class="line-modified"> 324     m_codeBlock-&gt;setInstructions(m_writer.finalize());</span>
<span class="line-removed"> 325 </span>
<span class="line-removed"> 326     m_codeBlock-&gt;shrinkToFit();</span>
<span class="line-removed"> 327 </span>
 328     if (m_expressionTooDeep)
 329         return ParserError(ParserError::OutOfMemory);
 330     return ParserError(ParserError::ErrorNone);
 331 }
 332 
 333 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ProgramNode* programNode, UnlinkedProgramCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<span class="line-modified"> 334     : m_codeGenerationMode(codeGenerationMode)</span>

 335     , m_scopeNode(programNode)
<span class="line-removed"> 336     , m_codeBlock(vm, codeBlock)</span>
 337     , m_thisRegister(CallFrame::thisArgumentOffset())
 338     , m_codeType(GlobalCode)
 339     , m_vm(vm)
 340     , m_needsToUpdateArrowFunctionContext(programNode-&gt;usesArrowFunction() || programNode-&gt;usesEval())
 341 {
 342     ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
 343 
<span class="line-removed"> 344     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)</span>
<span class="line-removed"> 345         constantRegister = nullptr;</span>
<span class="line-removed"> 346 </span>
<span class="line-removed"> 347     allocateCalleeSaveSpace();</span>
<span class="line-removed"> 348 </span>
 349     m_codeBlock-&gt;setNumParameters(1); // Allocate space for &quot;this&quot;
 350 
 351     emitEnter();
 352 
 353     allocateAndEmitScope();
 354 


 355     const FunctionStack&amp; functionStack = programNode-&gt;functionStack();
 356 
 357     for (auto* function : functionStack)
 358         m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
 359 
 360     if (Options::validateBytecode()) {
 361         for (auto&amp; entry : programNode-&gt;varDeclarations())
 362             RELEASE_ASSERT(entry.value.isVar());
 363     }
 364     codeBlock-&gt;setVariableDeclarations(programNode-&gt;varDeclarations());
 365     codeBlock-&gt;setLexicalDeclarations(programNode-&gt;lexicalVariables());
 366     // Even though this program may have lexical variables that go under TDZ, when linking the get_from_scope/put_to_scope
 367     // operations we emit we will have ResolveTypes that implictly do TDZ checks. Therefore, we don&#39;t need
 368     // additional TDZ checks on top of those. This is why we can omit pushing programNode-&gt;lexicalVariables()
 369     // to the TDZ stack.
 370 
 371     if (needsToUpdateArrowFunctionContext()) {
 372         initializeArrowFunctionContextScopeIfNeeded();
 373         emitPutThisToArrowFunctionContextScope();
 374     }
 375 }
 376 
 377 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, FunctionNode* functionNode, UnlinkedFunctionCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<span class="line-modified"> 378     : m_codeGenerationMode(codeGenerationMode)</span>

 379     , m_scopeNode(functionNode)
<span class="line-removed"> 380     , m_codeBlock(vm, codeBlock)</span>
 381     , m_codeType(FunctionCode)
 382     , m_vm(vm)
 383     , m_isBuiltinFunction(codeBlock-&gt;isBuiltinFunction())
 384     , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
 385     // FIXME: We should be able to have tail call elimination with the profiler
 386     // enabled. This is currently not possible because the profiler expects
 387     // op_will_call / op_did_call pairs before and after a call, which are not
 388     // compatible with tail calls (we have no way of emitting op_did_call).
 389     // https://bugs.webkit.org/show_bug.cgi?id=148819


 390     , m_inTailPosition(Options::useTailCalls() &amp;&amp; !isConstructor() &amp;&amp; constructorKind() == ConstructorKind::None &amp;&amp; isStrictMode())
 391     , m_needsToUpdateArrowFunctionContext(functionNode-&gt;usesArrowFunction() || functionNode-&gt;usesEval())
 392     , m_derivedContextType(codeBlock-&gt;derivedContextType())
 393 {
<span class="line-removed"> 394     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)</span>
<span class="line-removed"> 395         constantRegister = nullptr;</span>
<span class="line-removed"> 396 </span>
<span class="line-removed"> 397     allocateCalleeSaveSpace();</span>
<span class="line-removed"> 398 </span>
 399     SymbolTable* functionSymbolTable = SymbolTable::create(m_vm);
 400     functionSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
 401     int symbolTableConstantIndex = 0;
 402 
 403     FunctionParameters&amp; parameters = *functionNode-&gt;parameters();
 404     // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-functiondeclarationinstantiation
 405     // This implements IsSimpleParameterList in the Ecma 2015 spec.
 406     // If IsSimpleParameterList is false, we will create a strict-mode like arguments object.
 407     // IsSimpleParameterList is false if the argument list contains any default parameter values,
 408     // a rest parameter, or any destructuring patterns.
 409     // If we do have default parameters, destructuring parameters, or a rest parameter, our parameters will be allocated in a different scope.
 410     bool isSimpleParameterList = parameters.isSimpleParameterList();
 411 
 412     SourceParseMode parseMode = codeBlock-&gt;parseMode();
 413 
 414     bool containsArrowOrEvalButNotInArrowBlock = ((functionNode-&gt;usesArrowFunction() &amp;&amp; functionNode-&gt;doAnyInnerArrowFunctionsUseAnyFeature()) || functionNode-&gt;usesEval()) &amp;&amp; !m_codeBlock-&gt;isArrowFunction();
 415     bool shouldCaptureSomeOfTheThings = shouldEmitDebugHooks() || functionNode-&gt;needsActivation() || containsArrowOrEvalButNotInArrowBlock;
 416 
 417     bool shouldCaptureAllOfTheThings = shouldEmitDebugHooks() || codeBlock-&gt;usesEval();
<span class="line-modified"> 418     bool needsArguments = ((functionNode-&gt;usesArguments() &amp;&amp; !codeBlock-&gt;isArrowFunction()) || codeBlock-&gt;usesEval() || (functionNode-&gt;usesArrowFunction() &amp;&amp; !codeBlock-&gt;isArrowFunction() &amp;&amp; isArgumentsUsedInInnerArrowFunction()));</span>
 419 
 420     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
 421         // Generator and AsyncFunction never provides &quot;arguments&quot;. &quot;arguments&quot; reference will be resolved in an upper generator function scope.
 422         needsArguments = false;
 423     }
 424 
 425     if (isGeneratorOrAsyncFunctionWrapperParseMode(parseMode) &amp;&amp; needsArguments) {
 426         // Generator does not provide &quot;arguments&quot;. Instead, wrapping GeneratorFunction provides &quot;arguments&quot;.
 427         // This is because arguments of a generator should be evaluated before starting it.
 428         // To workaround it, we evaluate these arguments as arguments of a wrapping generator function, and reference it from a generator.
 429         //
 430         //    function *gen(a, b = hello())
 431         //    {
 432         //        return {
 433         //            @generatorNext: function (@generator, @generatorState, @generatorValue, @generatorResumeMode, @generatorFrame)
 434         //            {
 435         //                arguments;  // This `arguments` should reference to the gen&#39;s arguments.
 436         //                ...
 437         //            }
 438         //        }
</pre>
<hr />
<pre>
 454             return true;
 455         }
 456         return functionNode-&gt;captures(uid);
 457     });
 458     auto varKind = [&amp;] (UniquedStringImpl* uid) -&gt; VarKind {
 459         return captures(uid) ? VarKind::Scope : VarKind::Stack;
 460     };
 461 
 462     m_calleeRegister.setIndex(CallFrameSlot::callee);
 463 
 464     initializeParameters(parameters);
 465     ASSERT(!(isSimpleParameterList &amp;&amp; m_restParameter));
 466 
 467     emitEnter();
 468 
 469     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode))
 470         m_generatorRegister = &amp;m_parameters[1];
 471 
 472     allocateAndEmitScope();
 473 


 474     if (functionNameIsInScope(functionNode-&gt;ident(), functionNode-&gt;functionMode())) {
 475         ASSERT(parseMode != SourceParseMode::GeneratorBodyMode);
 476         ASSERT(!isAsyncFunctionBodyParseMode(parseMode));
 477         bool isDynamicScope = functionNameScopeIsDynamic(codeBlock-&gt;usesEval(), codeBlock-&gt;isStrictMode());
 478         bool isFunctionNameCaptured = captures(functionNode-&gt;ident().impl());
 479         bool markAsCaptured = isDynamicScope || isFunctionNameCaptured;
 480         emitPushFunctionNameScope(functionNode-&gt;ident(), &amp;m_calleeRegister, markAsCaptured);
 481     }
 482 
 483     if (shouldCaptureSomeOfTheThings)
 484         m_lexicalEnvironmentRegister = addVar();
 485 
 486     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode) || shouldCaptureSomeOfTheThings || shouldEmitTypeProfilerHooks())
 487         symbolTableConstantIndex = addConstantValue(functionSymbolTable)-&gt;index();
 488 
 489     // We can allocate the &quot;var&quot; environment if we don&#39;t have default parameter expressions. If we have
 490     // default parameter expressions, we have to hold off on allocating the &quot;var&quot; environment because
 491     // the parent scope of the &quot;var&quot; environment is the parameter environment.
 492     if (isSimpleParameterList)
 493         initializeVarLexicalEnvironment(symbolTableConstantIndex, functionSymbolTable, shouldCaptureSomeOfTheThings);
</pre>
<hr />
<pre>
 532         if (capturesAnyArgumentByName) {
 533             functionSymbolTable-&gt;setArgumentsLength(vm, parameters.size());
 534 
 535             // For each parameter, we have two possibilities:
 536             // Either it&#39;s a binding node with no function overlap, in which case it gets a name
 537             // in the symbol table - or it just gets space reserved in the symbol table. Either
 538             // way we lift the value into the scope.
 539             for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 540                 ScopeOffset offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
 541                 functionSymbolTable-&gt;setArgumentOffset(vm, i, offset);
 542                 if (UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first)) {
 543                     VarOffset varOffset(offset);
 544                     SymbolTableEntry entry(varOffset);
 545                     // Stores to these variables via the ScopedArguments object will not do
 546                     // notifyWrite(), since that would be cumbersome. Also, watching formal
 547                     // parameters when &quot;arguments&quot; is in play is unlikely to be super profitable.
 548                     // So, we just disable it.
 549                     entry.disableWatching(m_vm);
 550                     functionSymbolTable-&gt;set(NoLockingNecessary, name, entry);
 551                 }
<span class="line-modified"> 552                 OpPutToScope::emit(this, m_lexicalEnvironmentRegister, UINT_MAX, virtualRegisterForArgument(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), SymbolTableOrScopeDepth::symbolTable(VirtualRegister { symbolTableConstantIndex }), offset.offset());</span>
 553             }
 554 
 555             // This creates a scoped arguments object and copies the overflow arguments into the
 556             // scope. It&#39;s the equivalent of calling ScopedArguments::createByCopying().
 557             OpCreateScopedArguments::emit(this, m_argumentsRegister, m_lexicalEnvironmentRegister);
 558         } else {
 559             // We&#39;re going to put all parameters into the DirectArguments object. First ensure
 560             // that the symbol table knows that this is happening.
 561             for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 562                 if (UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first))
 563                     functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(DirectArgumentsOffset(i))));
 564             }
 565 
 566             OpCreateDirectArguments::emit(this, m_argumentsRegister);
 567         }
 568     } else if (isSimpleParameterList) {
 569         // Create the formal parameters the normal way. Any of them could be captured, or not. If
 570         // captured, lift them into the scope. We cannot do this if we have default parameter expressions
 571         // because when default parameter expressions exist, they belong in their own lexical environment
 572         // separate from the &quot;var&quot; lexical environment.
 573         for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 574             UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first);
 575             if (!name)
 576                 continue;
 577 
 578             if (!captures(name)) {
 579                 // This is the easy case - just tell the symbol table about the argument. It will
 580                 // be accessed directly.
<span class="line-modified"> 581                 functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(virtualRegisterForArgument(1 + i))));</span>
 582                 continue;
 583             }
 584 
 585             ScopeOffset offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
 586             const Identifier&amp; ident =
 587                 static_cast&lt;const BindingNode*&gt;(parameters.at(i).first)-&gt;boundProperty();
 588             functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(offset)));
 589 
<span class="line-modified"> 590             OpPutToScope::emit(this, m_lexicalEnvironmentRegister, addConstant(ident), virtualRegisterForArgument(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), SymbolTableOrScopeDepth::symbolTable(VirtualRegister { symbolTableConstantIndex }), offset.offset());</span>
 591         }
 592     }
 593 
 594     if (needsArguments &amp;&amp; (codeBlock-&gt;isStrictMode() || !isSimpleParameterList)) {
 595         // Allocate a cloned arguments object.
 596         OpCreateClonedArguments::emit(this, m_argumentsRegister);
 597     }
 598 
 599     // There are some variables that need to be preinitialized to something other than Undefined:
 600     //
 601     // - &quot;arguments&quot;: unless it&#39;s used as a function or parameter, this should refer to the
 602     //   arguments object.
 603     //
 604     // - functions: these always override everything else.
 605     //
 606     // The most logical way to do all of this is to initialize none of the variables until now,
 607     // and then initialize them in BytecodeGenerator::generate() in such an order that the rules
 608     // for how these things override each other end up holding. We would initialize &quot;arguments&quot; first,
 609     // then all arguments, then the functions.
 610     //
</pre>
<hr />
<pre>
 620     bool shouldCreateArgumentsVariableInParameterScope = false;
 621     if (needsArguments) {
 622         // If &quot;arguments&quot; is overridden by a function or destructuring parameter name, then it&#39;s
 623         // OK for us to call createVariable() because it won&#39;t change anything. It&#39;s also OK for
 624         // us to them tell BytecodeGenerator::generate() to write to it because it will do so
 625         // before it initializes functions and destructuring parameters. But if &quot;arguments&quot; is
 626         // overridden by a &quot;simple&quot; function parameter, then we have to bail: createVariable()
 627         // would assert and BytecodeGenerator::generate() would write the &quot;arguments&quot; after the
 628         // argument value had already been properly initialized.
 629 
 630         bool haveParameterNamedArguments = false;
 631         for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 632             UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first);
 633             if (name == propertyNames().arguments.impl()) {
 634                 haveParameterNamedArguments = true;
 635                 break;
 636             }
 637         }
 638 
 639         bool shouldCreateArgumensVariable = !haveParameterNamedArguments
<span class="line-modified"> 640             &amp;&amp; !SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(m_codeBlock-&gt;parseMode());</span>
 641         shouldCreateArgumentsVariableInParameterScope = shouldCreateArgumensVariable &amp;&amp; !isSimpleParameterList;
 642         // Do not create arguments variable in case of Arrow function. Value will be loaded from parent scope
 643         if (shouldCreateArgumensVariable &amp;&amp; !shouldCreateArgumentsVariableInParameterScope) {
 644             createVariable(
 645                 propertyNames().arguments, varKind(propertyNames().arguments.impl()), functionSymbolTable);
 646 
 647             m_needToInitializeArguments = true;
 648         }
 649     }
 650 
 651     for (FunctionMetadataNode* function : functionNode-&gt;functionStack()) {
 652         const Identifier&amp; ident = function-&gt;ident();
 653         createVariable(ident, varKind(ident.impl()), functionSymbolTable);
 654         m_functionsToInitialize.append(std::make_pair(function, NormalFunctionVariable));
 655     }
 656     for (auto&amp; entry : functionNode-&gt;varDeclarations()) {
 657         ASSERT(!entry.value.isLet() &amp;&amp; !entry.value.isConst());
 658         if (!entry.value.isVar()) // This is either a parameter or callee.
 659             continue;
 660         if (shouldCreateArgumentsVariableInParameterScope &amp;&amp; entry.key.get() == propertyNames().arguments.impl())
 661             continue;
 662         createVariable(Identifier::fromUid(m_vm, entry.key.get()), varKind(entry.key.get()), functionSymbolTable, IgnoreExisting);
 663     }
 664 
 665 
 666     if (functionNode-&gt;needsNewTargetRegisterForThisScope() || isNewTargetUsedInInnerArrowFunction() || codeBlock-&gt;usesEval())
 667         m_newTargetRegister = addVar();
 668 
 669     switch (parseMode) {
 670     case SourceParseMode::GeneratorWrapperFunctionMode:
<span class="line-modified"> 671     case SourceParseMode::GeneratorWrapperMethodMode:</span>










 672     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
 673     case SourceParseMode::AsyncGeneratorWrapperFunctionMode: {
 674         m_generatorRegister = addVar();
 675 
 676         // FIXME: Emit to_this only when Generator uses it.
 677         // https://bugs.webkit.org/show_bug.cgi?id=151586
 678         emitToThis();
 679 
<span class="line-modified"> 680         move(m_generatorRegister, &amp;m_calleeRegister);</span>
<span class="line-removed"> 681         emitCreateThis(m_generatorRegister);</span>
 682         break;
 683     }
 684 
 685     case SourceParseMode::AsyncArrowFunctionMode:
 686     case SourceParseMode::AsyncMethodMode:
 687     case SourceParseMode::AsyncFunctionMode: {
 688         ASSERT(!isConstructor());
 689         ASSERT(constructorKind() == ConstructorKind::None);
 690         m_generatorRegister = addVar();
<span class="line-modified"> 691         m_promiseCapabilityRegister = addVar();</span>
 692 
 693         if (parseMode != SourceParseMode::AsyncArrowFunctionMode) {
 694             // FIXME: Emit to_this only when AsyncFunctionBody uses it.
 695             // https://bugs.webkit.org/show_bug.cgi?id=151586
 696             emitToThis();
 697         }
 698 
<span class="line-modified"> 699         emitNewObject(m_generatorRegister);</span>
<span class="line-modified"> 700 </span>
<span class="line-removed"> 701         // let promiseCapability be @newPromiseCapability(@Promise)</span>
<span class="line-removed"> 702         auto varNewPromiseCapability = variable(propertyNames().builtinNames().newPromiseCapabilityPrivateName());</span>
<span class="line-removed"> 703         RefPtr&lt;RegisterID&gt; scope = newTemporary();</span>
<span class="line-removed"> 704         move(scope.get(), emitResolveScope(scope.get(), varNewPromiseCapability));</span>
<span class="line-removed"> 705         RefPtr&lt;RegisterID&gt; newPromiseCapability = emitGetFromScope(newTemporary(), scope.get(), varNewPromiseCapability, ThrowIfNotFound);</span>
<span class="line-removed"> 706 </span>
<span class="line-removed"> 707         CallArguments args(*this, nullptr, 1);</span>
<span class="line-removed"> 708         emitLoad(args.thisRegister(), jsUndefined());</span>
<span class="line-removed"> 709 </span>
<span class="line-removed"> 710         auto&amp; builtinNames = propertyNames().builtinNames();</span>
<span class="line-removed"> 711         auto varPromiseConstructor = variable(m_isBuiltinFunction ? builtinNames.InternalPromisePrivateName() : builtinNames.PromisePrivateName());</span>
<span class="line-removed"> 712         move(scope.get(), emitResolveScope(scope.get(), varPromiseConstructor));</span>
<span class="line-removed"> 713         emitGetFromScope(args.argumentRegister(0), scope.get(), varPromiseConstructor, ThrowIfNotFound);</span>
<span class="line-removed"> 714 </span>
<span class="line-removed"> 715         // JSTextPosition(int _line, int _offset, int _lineStartOffset)</span>
<span class="line-removed"> 716         JSTextPosition divot(m_scopeNode-&gt;firstLine(), m_scopeNode-&gt;startOffset(), m_scopeNode-&gt;lineStartOffset());</span>
<span class="line-removed"> 717         emitCall(promiseCapabilityRegister(), newPromiseCapability.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);</span>
 718         break;
 719     }
 720 
 721     case SourceParseMode::AsyncGeneratorBodyMode:
 722     case SourceParseMode::AsyncFunctionBodyMode:
 723     case SourceParseMode::AsyncArrowFunctionBodyMode:
 724     case SourceParseMode::GeneratorBodyMode: {
 725         // |this| is already filled correctly before here.
 726         if (m_newTargetRegister)
 727             emitLoad(m_newTargetRegister, jsUndefined());
 728         break;
 729     }
 730 
 731     default: {
 732         if (SourceParseMode::ArrowFunctionMode != parseMode) {
 733             if (isConstructor()) {
 734                 if (m_newTargetRegister)
 735                     move(m_newTargetRegister, &amp;m_thisRegister);
<span class="line-modified"> 736                 if (constructorKind() == ConstructorKind::Extends) {</span>
<span class="line-modified"> 737                     moveEmptyValue(&amp;m_thisRegister);</span>
<span class="line-modified"> 738                 } else</span>



 739                     emitCreateThis(&amp;m_thisRegister);
<span class="line-modified"> 740             } else if (constructorKind() != ConstructorKind::None)</span>
<span class="line-modified"> 741                 emitThrowTypeError(&quot;Cannot call a class constructor without |new|&quot;);</span>
<span class="line-modified"> 742             else {</span>
<span class="line-modified"> 743                 bool shouldEmitToThis = false;</span>
<span class="line-modified"> 744                 if (functionNode-&gt;usesThis() || codeBlock-&gt;usesEval() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseThis() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval())</span>
<span class="line-modified"> 745                     shouldEmitToThis = true;</span>
<span class="line-modified"> 746                 else if ((functionNode-&gt;usesSuperProperty() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperProperty()) &amp;&amp; !codeBlock-&gt;isStrictMode()) {</span>
<span class="line-modified"> 747                     // We must emit to_this when we&#39;re not in strict mode because we</span>
<span class="line-modified"> 748                     // will convert |this| to an object, and that object may be passed</span>
<span class="line-modified"> 749                     // to a strict function as |this|. This is observable because that</span>
<span class="line-modified"> 750                     // strict function&#39;s to_this will just return the object.</span>
<span class="line-modified"> 751                     //</span>
<span class="line-modified"> 752                     // We don&#39;t need to emit this for strict-mode code because</span>
<span class="line-modified"> 753                     // strict-mode code may call another strict function, which will</span>
<span class="line-modified"> 754                     // to_this if it directly uses this; this is OK, because we defer</span>
<span class="line-modified"> 755                     // to_this until |this| is used directly. Strict-mode code might</span>
<span class="line-modified"> 756                     // also call a sloppy mode function, and that will to_this, which</span>
<span class="line-modified"> 757                     // will defer the conversion, again, until necessary.</span>
<span class="line-modified"> 758                     shouldEmitToThis = true;</span>




















 759                 }
<span class="line-removed"> 760 </span>
<span class="line-removed"> 761                 if (shouldEmitToThis)</span>
<span class="line-removed"> 762                     emitToThis();</span>
 763             }
 764         }
 765         break;
 766     }
 767     }
 768 
 769     // We need load |super| &amp; |this| for arrow function before initializeDefaultParameterValuesAndSetupFunctionScopeStack
 770     // if we have default parameter expression. Because |super| &amp; |this| values can be used there
 771     if ((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; !isSimpleParameterList) || parseMode == SourceParseMode::AsyncArrowFunctionBodyMode) {
 772         if (functionNode-&gt;usesThis() || functionNode-&gt;usesSuperProperty())
 773             emitLoadThisFromArrowFunctionLexicalEnvironment();
 774 
 775         if (m_scopeNode-&gt;needsNewTargetRegisterForThisScope())
 776             emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 777     }
 778 
 779     if (needsToUpdateArrowFunctionContext() &amp;&amp; !codeBlock-&gt;isArrowFunction()) {
 780         bool canReuseLexicalEnvironment = isSimpleParameterList;
 781         initializeArrowFunctionContextScopeIfNeeded(functionSymbolTable, canReuseLexicalEnvironment);
 782         emitPutThisToArrowFunctionContextScope();
</pre>
<hr />
<pre>
 790 
 791     Ref&lt;Label&gt; catchLabel = newLabel();
 792     TryData* tryFormalParametersData = nullptr;
 793     bool needTryCatch = isAsyncFunctionWrapperParseMode(parseMode) &amp;&amp; !isSimpleParameterList;
 794     if (needTryCatch) {
 795         Ref&lt;Label&gt; tryFormalParametersStart = newEmittedLabel();
 796         tryFormalParametersData = pushTry(tryFormalParametersStart.get(), catchLabel.get(), HandlerType::SynthesizedCatch);
 797     }
 798 
 799     initializeDefaultParameterValuesAndSetupFunctionScopeStack(parameters, isSimpleParameterList, functionNode, functionSymbolTable, symbolTableConstantIndex, captures, shouldCreateArgumentsVariableInParameterScope);
 800 
 801     if (needTryCatch) {
 802         Ref&lt;Label&gt; didNotThrow = newLabel();
 803         emitJump(didNotThrow.get());
 804         emitLabel(catchLabel.get());
 805         popTry(tryFormalParametersData, catchLabel.get());
 806 
 807         RefPtr&lt;RegisterID&gt; thrownValue = newTemporary();
 808         emitOutOfLineCatchHandler(thrownValue.get(), nullptr, tryFormalParametersData);
 809 
<span class="line-modified"> 810         // return promiseCapability.@reject(thrownValue)</span>
<span class="line-modified"> 811         RefPtr&lt;RegisterID&gt; reject = emitGetById(newTemporary(), promiseCapabilityRegister(), m_vm.propertyNames-&gt;builtinNames().rejectPrivateName());</span>
<span class="line-modified"> 812 </span>
<span class="line-modified"> 813         CallArguments args(*this, nullptr, 1);</span>
 814         emitLoad(args.thisRegister(), jsUndefined());
<span class="line-modified"> 815         move(args.argumentRegister(0), thrownValue.get());</span>
<span class="line-modified"> 816 </span>
 817         JSTextPosition divot(functionNode-&gt;firstLine(), functionNode-&gt;startOffset(), functionNode-&gt;lineStartOffset());

 818 
<span class="line-modified"> 819         RefPtr&lt;RegisterID&gt; result = emitCall(newTemporary(), reject.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);</span>
<span class="line-removed"> 820         emitReturn(emitGetById(newTemporary(), promiseCapabilityRegister(), m_vm.propertyNames-&gt;builtinNames().promisePrivateName()));</span>
<span class="line-removed"> 821 </span>
 822         emitLabel(didNotThrow.get());
 823     }
 824 
 825     // If we don&#39;t have  default parameter expression, then loading |this| inside an arrow function must be done
 826     // after initializeDefaultParameterValuesAndSetupFunctionScopeStack() because that function sets up the
 827     // SymbolTable stack and emitLoadThisFromArrowFunctionLexicalEnvironment() consults the SymbolTable stack
 828     if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; isSimpleParameterList) {
 829         if (functionNode-&gt;usesThis() || functionNode-&gt;usesSuperProperty())
 830             emitLoadThisFromArrowFunctionLexicalEnvironment();
 831 
 832         if (m_scopeNode-&gt;needsNewTargetRegisterForThisScope())
 833             emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 834     }
 835 
 836     // Set up the lexical environment scope as the generator frame. We store the saved and resumed generator registers into this scope with the symbol keys.
 837     // Since they are symbol keyed, these variables cannot be reached from the usual code.
 838     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
 839         m_generatorFrameSymbolTable.set(m_vm, functionSymbolTable);
 840         m_generatorFrameSymbolTableIndex = symbolTableConstantIndex;
 841         if (m_lexicalEnvironmentRegister)
 842             move(generatorFrameRegister(), m_lexicalEnvironmentRegister);
 843         else {
 844             // It would be possible that generator does not need to suspend and resume any registers.
 845             // In this case, we would like to avoid creating a lexical environment as much as possible.
 846             // op_create_generator_frame_environment is a marker, which is similar to op_yield.
 847             // Generatorification inserts lexical environment creation if necessary. Otherwise, we convert it to op_mov frame, `undefined`.
 848             OpCreateGeneratorFrameEnvironment::emit(this, generatorFrameRegister(), scopeRegister(), VirtualRegister { symbolTableConstantIndex }, addConstantValue(jsUndefined()));
 849         }
<span class="line-modified"> 850         emitPutById(generatorRegister(), propertyNames().builtinNames().generatorFramePrivateName(), generatorFrameRegister());</span>

 851     }
 852 
 853     bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
 854     pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
 855 }
 856 
 857 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, EvalNode* evalNode, UnlinkedEvalCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<span class="line-modified"> 858     : m_codeGenerationMode(codeGenerationMode)</span>

 859     , m_scopeNode(evalNode)
<span class="line-removed"> 860     , m_codeBlock(vm, codeBlock)</span>
 861     , m_thisRegister(CallFrame::thisArgumentOffset())
 862     , m_codeType(EvalCode)
 863     , m_vm(vm)
 864     , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
 865     , m_needsToUpdateArrowFunctionContext(evalNode-&gt;usesArrowFunction() || evalNode-&gt;usesEval())
 866     , m_derivedContextType(codeBlock-&gt;derivedContextType())
 867 {
<span class="line-removed"> 868     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)</span>
<span class="line-removed"> 869         constantRegister = nullptr;</span>
<span class="line-removed"> 870 </span>
<span class="line-removed"> 871     allocateCalleeSaveSpace();</span>
<span class="line-removed"> 872 </span>
 873     m_codeBlock-&gt;setNumParameters(1);
 874 
 875     pushTDZVariables(*parentScopeTDZVariables, TDZCheckOptimization::DoNotOptimize, TDZRequirement::UnderTDZ);
 876 
 877     emitEnter();
 878 
 879     allocateAndEmitScope();
 880 


 881     for (FunctionMetadataNode* function : evalNode-&gt;functionStack()) {
 882         m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
 883         m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
 884     }
 885 
 886     const VariableEnvironment&amp; varDeclarations = evalNode-&gt;varDeclarations();
 887     Vector&lt;Identifier, 0, UnsafeVectorOverflow&gt; variables;
 888     Vector&lt;Identifier, 0, UnsafeVectorOverflow&gt; hoistedFunctions;
 889     for (auto&amp; entry : varDeclarations) {
 890         ASSERT(entry.value.isVar());
 891         ASSERT(entry.key-&gt;isAtom() || entry.key-&gt;isSymbol());
 892         if (entry.value.isSloppyModeHoistingCandidate())
 893             hoistedFunctions.append(Identifier::fromUid(m_vm, entry.key.get()));
 894         else
 895             variables.append(Identifier::fromUid(m_vm, entry.key.get()));
 896     }
 897     codeBlock-&gt;adoptVariables(variables);
 898     codeBlock-&gt;adoptFunctionHoistingCandidates(WTFMove(hoistedFunctions));
 899 
 900     if (evalNode-&gt;needsNewTargetRegisterForThisScope())
 901         m_newTargetRegister = addVar();
 902 
 903     if (codeBlock-&gt;isArrowFunctionContext() &amp;&amp; (evalNode-&gt;usesThis() || evalNode-&gt;usesSuperProperty()))
 904         emitLoadThisFromArrowFunctionLexicalEnvironment();
 905 
 906     if (evalNode-&gt;needsNewTargetRegisterForThisScope())
 907         emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 908 
 909     if (needsToUpdateArrowFunctionContext() &amp;&amp; !codeBlock-&gt;isArrowFunctionContext() &amp;&amp; !isDerivedConstructorContext()) {
 910         initializeArrowFunctionContextScopeIfNeeded();
 911         emitPutThisToArrowFunctionContextScope();
 912     }
 913 
 914     bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
 915     pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
 916 }
 917 
 918 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ModuleProgramNode* moduleProgramNode, UnlinkedModuleProgramCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<span class="line-modified"> 919     : m_codeGenerationMode(codeGenerationMode)</span>

 920     , m_scopeNode(moduleProgramNode)
<span class="line-removed"> 921     , m_codeBlock(vm, codeBlock)</span>
 922     , m_thisRegister(CallFrame::thisArgumentOffset())
 923     , m_codeType(ModuleCode)
 924     , m_vm(vm)
 925     , m_usesNonStrictEval(false)
 926     , m_needsToUpdateArrowFunctionContext(moduleProgramNode-&gt;usesArrowFunction() || moduleProgramNode-&gt;usesEval())
 927 {
 928     ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
 929 
<span class="line-removed"> 930     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)</span>
<span class="line-removed"> 931         constantRegister = nullptr;</span>
<span class="line-removed"> 932 </span>
<span class="line-removed"> 933     allocateCalleeSaveSpace();</span>
<span class="line-removed"> 934 </span>
 935     SymbolTable* moduleEnvironmentSymbolTable = SymbolTable::create(m_vm);
 936     moduleEnvironmentSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
 937     moduleEnvironmentSymbolTable-&gt;setScopeType(SymbolTable::ScopeType::LexicalScope);
 938 
 939     bool shouldCaptureAllOfTheThings = shouldEmitDebugHooks() || codeBlock-&gt;usesEval();
 940     if (shouldCaptureAllOfTheThings)
 941         moduleProgramNode-&gt;varDeclarations().markAllVariablesAsCaptured();
 942 
 943     auto captures = [&amp;] (UniquedStringImpl* uid) -&gt; bool {
 944         return moduleProgramNode-&gt;captures(uid);
 945     };
 946     auto lookUpVarKind = [&amp;] (UniquedStringImpl* uid, const VariableEnvironmentEntry&amp; entry) -&gt; VarKind {
 947         // Allocate the exported variables in the module environment.
 948         if (entry.isExported())
 949             return VarKind::Scope;
 950 
 951         // Allocate the namespace variables in the module environment to instantiate
 952         // it from the outside of the module code.
 953         if (entry.isImportedNamespace())
 954             return VarKind::Scope;
 955 
 956         if (entry.isCaptured())
 957             return VarKind::Scope;
 958         return captures(uid) ? VarKind::Scope : VarKind::Stack;
 959     };
 960 
 961     emitEnter();
 962 
 963     allocateAndEmitScope();
 964 


 965     m_calleeRegister.setIndex(CallFrameSlot::callee);
 966 
 967     m_codeBlock-&gt;setNumParameters(1); // Allocate space for &quot;this&quot;
 968 
 969     // Now declare all variables.
 970 
 971     createVariable(m_vm.propertyNames-&gt;builtinNames().metaPrivateName(), VarKind::Scope, moduleEnvironmentSymbolTable, VerifyExisting);
 972 
 973     for (auto&amp; entry : moduleProgramNode-&gt;varDeclarations()) {
 974         ASSERT(!entry.value.isLet() &amp;&amp; !entry.value.isConst());
 975         if (!entry.value.isVar()) // This is either a parameter or callee.
 976             continue;
 977         // Imported bindings are not allocated in the module environment as usual variables&#39; way.
 978         // These references remain the &quot;Dynamic&quot; in the unlinked code block. Later, when linking
 979         // the code block, we resolve the reference to the &quot;ModuleVar&quot;.
 980         if (entry.value.isImported() &amp;&amp; !entry.value.isImportedNamespace())
 981             continue;
 982         createVariable(Identifier::fromUid(m_vm, entry.key.get()), lookUpVarKind(entry.key.get(), entry.value), moduleEnvironmentSymbolTable, IgnoreExisting);
 983     }
 984 
</pre>
<hr />
<pre>
1200     }
1201 
1202     if (needsDerivedConstructorInArrowFunctionLexicalEnvironment()) {
1203         auto derivedConstructor = environment.add(propertyNames().builtinNames().derivedConstructorPrivateName());
1204         derivedConstructor.iterator-&gt;value.setIsCaptured();
1205         derivedConstructor.iterator-&gt;value.setIsLet();
1206     }
1207 
1208     if (environment.size() &gt; 0) {
1209         size_t size = m_lexicalScopeStack.size();
1210         pushLexicalScopeInternal(environment, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, TDZRequirement::UnderTDZ, ScopeType::LetConstScope, ScopeRegisterType::Block);
1211 
1212         ASSERT_UNUSED(size, m_lexicalScopeStack.size() == size + 1);
1213 
1214         m_arrowFunctionContextLexicalEnvironmentRegister = m_lexicalScopeStack.last().m_scope;
1215     }
1216 }
1217 
1218 RegisterID* BytecodeGenerator::initializeNextParameter()
1219 {
<span class="line-modified">1220     VirtualRegister reg = virtualRegisterForArgument(m_codeBlock-&gt;numParameters());</span>
1221     m_parameters.grow(m_parameters.size() + 1);
1222     auto&amp; parameter = registerFor(reg);
<span class="line-modified">1223     parameter.setIndex(reg.offset());</span>
<span class="line-modified">1224     m_codeBlock-&gt;addParameter();</span>
1225     return &amp;parameter;
1226 }
1227 
1228 void BytecodeGenerator::initializeParameters(FunctionParameters&amp; parameters)
1229 {
1230     // Make sure the code block knows about all of our parameters, and make sure that parameters
1231     // needing destructuring are noted.
<span class="line-modified">1232     m_thisRegister.setIndex(initializeNextParameter()-&gt;index()); // this</span>
1233 
1234     bool nonSimpleArguments = false;
1235     for (unsigned i = 0; i &lt; parameters.size(); ++i) {
1236         auto parameter = parameters.at(i);
1237         auto pattern = parameter.first;
1238         if (pattern-&gt;isRestParameter()) {
1239             RELEASE_ASSERT(!m_restParameter);
1240             m_restParameter = static_cast&lt;RestParameterNode*&gt;(pattern);
1241             nonSimpleArguments = true;
1242             continue;
1243         }
1244         if (parameter.second) {
1245             nonSimpleArguments = true;
1246             continue;
1247         }
1248         if (!nonSimpleArguments)
1249             initializeNextParameter();
1250     }
1251 }
1252 
</pre>
<hr />
<pre>
1258 
1259         OpMov::emit(this, scopeRegister(), m_lexicalEnvironmentRegister);
1260 
1261         pushLocalControlFlowScope();
1262     }
1263     bool isWithScope = false;
1264     m_lexicalScopeStack.append({ functionSymbolTable, m_lexicalEnvironmentRegister, isWithScope, symbolTableConstantIndex });
1265     m_varScopeLexicalScopeStackIndex = m_lexicalScopeStack.size() - 1;
1266 }
1267 
1268 UniquedStringImpl* BytecodeGenerator::visibleNameForParameter(DestructuringPatternNode* pattern)
1269 {
1270     if (pattern-&gt;isBindingNode()) {
1271         const Identifier&amp; ident = static_cast&lt;const BindingNode*&gt;(pattern)-&gt;boundProperty();
1272         if (!m_functions.contains(ident.impl()))
1273             return ident.impl();
1274     }
1275     return nullptr;
1276 }
1277 
<span class="line-removed">1278 RegisterID* BytecodeGenerator::newRegister()</span>
<span class="line-removed">1279 {</span>
<span class="line-removed">1280     m_calleeLocals.append(virtualRegisterForLocal(m_calleeLocals.size()));</span>
<span class="line-removed">1281     int numCalleeLocals = std::max&lt;int&gt;(m_codeBlock-&gt;m_numCalleeLocals, m_calleeLocals.size());</span>
<span class="line-removed">1282     numCalleeLocals = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), numCalleeLocals);</span>
<span class="line-removed">1283     m_codeBlock-&gt;m_numCalleeLocals = numCalleeLocals;</span>
<span class="line-removed">1284     return &amp;m_calleeLocals.last();</span>
<span class="line-removed">1285 }</span>
<span class="line-removed">1286 </span>
<span class="line-removed">1287 void BytecodeGenerator::reclaimFreeRegisters()</span>
<span class="line-removed">1288 {</span>
<span class="line-removed">1289     shrinkToFit(m_calleeLocals);</span>
<span class="line-removed">1290 }</span>
<span class="line-removed">1291 </span>
1292 RegisterID* BytecodeGenerator::newBlockScopeVariable()
1293 {
1294     reclaimFreeRegisters();
1295 
1296     return newRegister();
1297 }
1298 
<span class="line-removed">1299 RegisterID* BytecodeGenerator::newTemporary()</span>
<span class="line-removed">1300 {</span>
<span class="line-removed">1301     reclaimFreeRegisters();</span>
<span class="line-removed">1302 </span>
<span class="line-removed">1303     RegisterID* result = newRegister();</span>
<span class="line-removed">1304     result-&gt;setTemporary();</span>
<span class="line-removed">1305     return result;</span>
<span class="line-removed">1306 }</span>
<span class="line-removed">1307 </span>
1308 Ref&lt;LabelScope&gt; BytecodeGenerator::newLabelScope(LabelScope::Type type, const Identifier* name)
1309 {
1310     shrinkToFit(m_labelScopes);
1311 
1312     // Allocate new label scope.
1313     m_labelScopes.append(type, name, labelScopeDepth(), newLabel(), type == LabelScope::Loop ? RefPtr&lt;Label&gt;(newLabel()) : RefPtr&lt;Label&gt;()); // Only loops have continue targets.
1314     return m_labelScopes.last();
1315 }
1316 
<span class="line-removed">1317 Ref&lt;Label&gt; BytecodeGenerator::newLabel()</span>
<span class="line-removed">1318 {</span>
<span class="line-removed">1319     shrinkToFit(m_labels);</span>
<span class="line-removed">1320 </span>
<span class="line-removed">1321     // Allocate new label ID.</span>
<span class="line-removed">1322     m_labels.append();</span>
<span class="line-removed">1323     return m_labels.last();</span>
<span class="line-removed">1324 }</span>
<span class="line-removed">1325 </span>
<span class="line-removed">1326 Ref&lt;Label&gt; BytecodeGenerator::newEmittedLabel()</span>
<span class="line-removed">1327 {</span>
<span class="line-removed">1328     Ref&lt;Label&gt; label = newLabel();</span>
<span class="line-removed">1329     emitLabel(label.get());</span>
<span class="line-removed">1330     return label;</span>
<span class="line-removed">1331 }</span>
<span class="line-removed">1332 </span>
<span class="line-removed">1333 void BytecodeGenerator::recordOpcode(OpcodeID opcodeID)</span>
<span class="line-removed">1334 {</span>
<span class="line-removed">1335     ASSERT(m_lastOpcodeID == op_end || (m_lastOpcodeID == m_lastInstruction-&gt;opcodeID() &amp;&amp; m_writer.position() == m_lastInstruction.offset() + m_lastInstruction-&gt;size()));</span>
<span class="line-removed">1336     m_lastInstruction = m_writer.ref();</span>
<span class="line-removed">1337     m_lastOpcodeID = opcodeID;</span>
<span class="line-removed">1338 }</span>
<span class="line-removed">1339 </span>
<span class="line-removed">1340 void BytecodeGenerator::alignWideOpcode16()</span>
<span class="line-removed">1341 {</span>
<span class="line-removed">1342 #if CPU(NEEDS_ALIGNED_ACCESS)</span>
<span class="line-removed">1343     while ((m_writer.position() + 1) % OpcodeSize::Wide16)</span>
<span class="line-removed">1344         OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);</span>
<span class="line-removed">1345 #endif</span>
<span class="line-removed">1346 }</span>
<span class="line-removed">1347 </span>
<span class="line-removed">1348 void BytecodeGenerator::alignWideOpcode32()</span>
<span class="line-removed">1349 {</span>
<span class="line-removed">1350 #if CPU(NEEDS_ALIGNED_ACCESS)</span>
<span class="line-removed">1351     while ((m_writer.position() + 1) % OpcodeSize::Wide32)</span>
<span class="line-removed">1352         OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);</span>
<span class="line-removed">1353 #endif</span>
<span class="line-removed">1354 }</span>
<span class="line-removed">1355 </span>
<span class="line-removed">1356 void BytecodeGenerator::emitLabel(Label&amp; l0)</span>
<span class="line-removed">1357 {</span>
<span class="line-removed">1358     unsigned newLabelIndex = instructions().size();</span>
<span class="line-removed">1359     l0.setLocation(*this, newLabelIndex);</span>
<span class="line-removed">1360 </span>
<span class="line-removed">1361     if (m_codeBlock-&gt;numberOfJumpTargets()) {</span>
<span class="line-removed">1362         unsigned lastLabelIndex = m_codeBlock-&gt;lastJumpTarget();</span>
<span class="line-removed">1363         ASSERT(lastLabelIndex &lt;= newLabelIndex);</span>
<span class="line-removed">1364         if (newLabelIndex == lastLabelIndex) {</span>
<span class="line-removed">1365             // Peephole optimizations have already been disabled by emitting the last label</span>
<span class="line-removed">1366             return;</span>
<span class="line-removed">1367         }</span>
<span class="line-removed">1368     }</span>
<span class="line-removed">1369 </span>
<span class="line-removed">1370     m_codeBlock-&gt;addJumpTarget(newLabelIndex);</span>
<span class="line-removed">1371 </span>
<span class="line-removed">1372     // This disables peephole optimizations when an instruction is a jump target</span>
<span class="line-removed">1373     m_lastOpcodeID = op_end;</span>
<span class="line-removed">1374 }</span>
<span class="line-removed">1375 </span>
1376 void BytecodeGenerator::emitEnter()
1377 {
1378     OpEnter::emit(this);
1379 
1380     if (LIKELY(Options::optimizeRecursiveTailCalls())) {
1381         // We must add the end of op_enter as a potential jump target, because the bytecode parser may decide to split its basic block
1382         // to have somewhere to jump to if there is a recursive tail-call that points to this function.
1383         m_codeBlock-&gt;addJumpTarget(instructions().size());
1384         // This disables peephole optimizations when an instruction is a jump target
1385         m_lastOpcodeID = op_end;
1386     }
1387 }
1388 
1389 void BytecodeGenerator::emitLoopHint()
1390 {
1391     OpLoopHint::emit(this);

1392 }
1393 
1394 void BytecodeGenerator::emitJump(Label&amp; target)
1395 {
1396     OpJmp::emit(this, target.bind(this));
1397 }
1398 





1399 void ALWAYS_INLINE BytecodeGenerator::rewind()
1400 {
1401     ASSERT(m_lastInstruction.isValid());
1402     m_lastOpcodeID = op_end;
1403     m_writer.rewind(m_lastInstruction);
1404 }
1405 
1406 template&lt;typename BinOp, typename JmpOp&gt;
1407 bool BytecodeGenerator::fuseCompareAndJump(RegisterID* cond, Label&amp; target, bool swapOperands)
1408 {
1409     ASSERT(canDoPeepholeOptimization());
1410     auto binop = m_lastInstruction-&gt;as&lt;BinOp&gt;();
1411     if (cond-&gt;index() == binop.m_dst.offset() &amp;&amp; cond-&gt;isTemporary() &amp;&amp; !cond-&gt;refCount()) {
1412         rewind();
1413 
1414         if (swapOperands)
1415             std::swap(binop.m_lhs, binop.m_rhs);
1416 
1417         JmpOp::emit(this, binop.m_lhs, binop.m_rhs, target.bind(this));
1418         return true;
</pre>
<hr />
<pre>
1518         } else if (m_lastOpcodeID == op_not) {
1519             if (fuseTestAndJmp&lt;OpNot, OpJtrue&gt;(cond, target))
1520                 return;
1521         } else if (m_lastOpcodeID == op_eq_null &amp;&amp; target.isForward()) {
1522             if (fuseTestAndJmp&lt;OpEqNull, OpJneqNull&gt;(cond, target))
1523                 return;
1524         } else if (m_lastOpcodeID == op_neq_null &amp;&amp; target.isForward()) {
1525             if (fuseTestAndJmp&lt;OpNeqNull, OpJeqNull&gt;(cond, target))
1526                 return;
1527         } else if (m_lastOpcodeID == op_is_undefined_or_null &amp;&amp; target.isForward()) {
1528             if (fuseTestAndJmp&lt;OpIsUndefinedOrNull, OpJnundefinedOrNull&gt;(cond, target))
1529                 return;
1530         }
1531     }
1532 
1533     OpJfalse::emit(this, cond, target.bind(this));
1534 }
1535 
1536 void BytecodeGenerator::emitJumpIfNotFunctionCall(RegisterID* cond, Label&amp; target)
1537 {
<span class="line-modified">1538     OpJneqPtr::emit(this, cond, Special::CallFunction, target.bind(this));</span>
1539 }
1540 
1541 void BytecodeGenerator::emitJumpIfNotFunctionApply(RegisterID* cond, Label&amp; target)
1542 {
<span class="line-modified">1543     OpJneqPtr::emit(this, cond, Special::ApplyFunction, target.bind(this));</span>
1544 }
1545 
1546 bool BytecodeGenerator::hasConstant(const Identifier&amp; ident) const
1547 {
1548     UniquedStringImpl* rep = ident.impl();
1549     return m_identifierMap.contains(rep);
1550 }
1551 
1552 unsigned BytecodeGenerator::addConstant(const Identifier&amp; ident)
1553 {
1554     UniquedStringImpl* rep = ident.impl();
1555     IdentifierMap::AddResult result = m_identifierMap.add(rep, m_codeBlock-&gt;numberOfIdentifiers());
1556     if (result.isNewEntry)
1557         m_codeBlock-&gt;addIdentifier(ident);
1558 
1559     return result.iterator-&gt;value;
1560 }
1561 
1562 // We can&#39;t hash JSValue(), so we use a dedicated data member to cache it.
1563 RegisterID* BytecodeGenerator::addConstantEmptyValue()
</pre>
<hr />
<pre>
1575 {
1576     if (!v)
1577         return addConstantEmptyValue();
1578 
1579     int index = m_nextConstantOffset;
1580 
1581     if (sourceCodeRepresentation == SourceCodeRepresentation::Double &amp;&amp; v.isInt32())
1582         v = jsDoubleNumber(v.asNumber());
1583     EncodedJSValueWithRepresentation valueMapKey { JSValue::encode(v), sourceCodeRepresentation };
1584     JSValueMap::AddResult result = m_jsValueMap.add(valueMapKey, m_nextConstantOffset);
1585     if (result.isNewEntry) {
1586         addConstantIndex();
1587         m_codeBlock-&gt;addConstant(v, sourceCodeRepresentation);
1588     } else
1589         index = result.iterator-&gt;value;
1590     return &amp;m_constantPoolRegisters[index];
1591 }
1592 
1593 RegisterID* BytecodeGenerator::moveLinkTimeConstant(RegisterID* dst, LinkTimeConstant type)
1594 {
<span class="line-modified">1595     unsigned constantIndex = static_cast&lt;unsigned&gt;(type);</span>
<span class="line-removed">1596     if (!m_linkTimeConstantRegisters[constantIndex]) {</span>
1597         int index = addConstantIndex();
1598         m_codeBlock-&gt;addConstant(type);
<span class="line-modified">1599         m_linkTimeConstantRegisters[constantIndex] = &amp;m_constantPoolRegisters[index];</span>
<span class="line-modified">1600     }</span>
<span class="line-removed">1601 </span>
1602     if (!dst)
<span class="line-modified">1603         return m_linkTimeConstantRegisters[constantIndex];</span>
1604 
<span class="line-modified">1605     OpMov::emit(this, dst, m_linkTimeConstantRegisters[constantIndex]);</span>
1606 
1607     return dst;
1608 }
1609 
1610 RegisterID* BytecodeGenerator::moveEmptyValue(RegisterID* dst)
1611 {
1612     RefPtr&lt;RegisterID&gt; emptyValue = addConstantEmptyValue();
1613 
1614     OpMov::emit(this, dst, emptyValue.get());
1615 
1616     return dst;
1617 }
1618 
1619 RegisterID* BytecodeGenerator::emitMove(RegisterID* dst, RegisterID* src)
1620 {
1621     ASSERT(src != m_emptyValueRegister);
1622 
1623     m_staticPropertyAnalyzer.mov(dst, src);
1624     OpMov::emit(this, dst, src);
1625 
1626     return dst;
1627 }
1628 
<span class="line-modified">1629 RegisterID* BytecodeGenerator::emitUnaryOp(OpcodeID opcodeID, RegisterID* dst, RegisterID* src, OperandTypes types)</span>
1630 {
1631     switch (opcodeID) {
1632     case op_not:
1633         emitUnaryOp&lt;OpNot&gt;(dst, src);
1634         break;
1635     case op_negate:
<span class="line-modified">1636         OpNegate::emit(this, dst, src, types);</span>
1637         break;
1638     case op_bitnot:
1639         emitUnaryOp&lt;OpBitnot&gt;(dst, src);
1640         break;
1641     case op_to_number:
1642         emitUnaryOp&lt;OpToNumber&gt;(dst, src);
1643         break;



1644     default:
1645         ASSERT_NOT_REACHED();
1646     }
1647     return dst;
1648 }
1649 
1650 RegisterID* BytecodeGenerator::emitBinaryOp(OpcodeID opcodeID, RegisterID* dst, RegisterID* src1, RegisterID* src2, OperandTypes types)
1651 {
1652     switch (opcodeID) {
1653     case op_eq:
1654         return emitBinaryOp&lt;OpEq&gt;(dst, src1, src2, types);
1655     case op_neq:
1656         return emitBinaryOp&lt;OpNeq&gt;(dst, src1, src2, types);
1657     case op_stricteq:
1658         return emitBinaryOp&lt;OpStricteq&gt;(dst, src1, src2, types);
1659     case op_nstricteq:
1660         return emitBinaryOp&lt;OpNstricteq&gt;(dst, src1, src2, types);
1661     case op_less:
1662         return emitBinaryOp&lt;OpLess&gt;(dst, src1, src2, types);
1663     case op_lesseq:
</pre>
<hr />
<pre>
1694         return emitBinaryOp&lt;OpBitxor&gt;(dst, src1, src2, types);
1695     case op_bitor:
1696         return emitBinaryOp&lt;OpBitor&gt;(dst, src1, src2, types);
1697     default:
1698         ASSERT_NOT_REACHED();
1699         return nullptr;
1700     }
1701 }
1702 
1703 RegisterID* BytecodeGenerator::emitToObject(RegisterID* dst, RegisterID* src, const Identifier&amp; message)
1704 {
1705     OpToObject::emit(this, dst, src, addConstant(message));
1706     return dst;
1707 }
1708 
1709 RegisterID* BytecodeGenerator::emitToNumber(RegisterID* dst, RegisterID* src)
1710 {
1711     return emitUnaryOp&lt;OpToNumber&gt;(dst, src);
1712 }
1713 





1714 RegisterID* BytecodeGenerator::emitToString(RegisterID* dst, RegisterID* src)
1715 {
1716     return emitUnaryOp&lt;OpToString&gt;(dst, src);
1717 }
1718 
1719 RegisterID* BytecodeGenerator::emitTypeOf(RegisterID* dst, RegisterID* src)
1720 {
1721     return emitUnaryOp&lt;OpTypeof&gt;(dst, src);
1722 }
1723 
1724 RegisterID* BytecodeGenerator::emitInc(RegisterID* srcDst)
1725 {
1726     OpInc::emit(this, srcDst);
1727     return srcDst;
1728 }
1729 
1730 RegisterID* BytecodeGenerator::emitDec(RegisterID* srcDst)
1731 {
1732     OpDec::emit(this, srcDst);
1733     return srcDst;
1734 }
1735 
1736 bool BytecodeGenerator::emitEqualityOpImpl(RegisterID* dst, RegisterID* src1, RegisterID* src2)
1737 {
1738     if (!canDoPeepholeOptimization())
1739         return false;
1740 
1741     if (m_lastInstruction-&gt;is&lt;OpTypeof&gt;()) {
1742         auto op = m_lastInstruction-&gt;as&lt;OpTypeof&gt;();
<span class="line-modified">1743         if (src1-&gt;index() == op.m_dst.offset()</span>
1744             &amp;&amp; src1-&gt;isTemporary()
<span class="line-modified">1745             &amp;&amp; m_codeBlock-&gt;isConstantRegisterIndex(src2-&gt;index())</span>
<span class="line-modified">1746             &amp;&amp; m_codeBlock-&gt;constantRegister(src2-&gt;index()).get().isString()) {</span>
<span class="line-modified">1747             const String&amp; value = asString(m_codeBlock-&gt;constantRegister(src2-&gt;index()).get())-&gt;tryGetValue();</span>
1748             if (value == &quot;undefined&quot;) {
1749                 rewind();
1750                 OpIsUndefined::emit(this, dst, op.m_value);
1751                 return true;
1752             }
1753             if (value == &quot;boolean&quot;) {
1754                 rewind();
1755                 OpIsBoolean::emit(this, dst, op.m_value);
1756                 return true;
1757             }
1758             if (value == &quot;number&quot;) {
1759                 rewind();
1760                 OpIsNumber::emit(this, dst, op.m_value);
1761                 return true;
1762             }
1763             if (value == &quot;string&quot;) {
1764                 rewind();
1765                 OpIsCellWithType::emit(this, dst, op.m_value, StringType);
1766                 return true;
1767             }
</pre>
<hr />
<pre>
2202         environment.markAllVariablesAsCaptured();
2203 
2204     auto stackEntry = m_lexicalScopeStack.takeLast();
2205     SymbolTable* symbolTable = stackEntry.m_symbolTable;
2206     bool hasCapturedVariables = false;
2207     for (auto&amp; entry : environment) {
2208         if (entry.value.isCaptured()) {
2209             hasCapturedVariables = true;
2210             continue;
2211         }
2212         SymbolTableEntry symbolTableEntry = symbolTable-&gt;get(NoLockingNecessary, entry.key.get());
2213         ASSERT(!symbolTableEntry.isNull());
2214         VarOffset offset = symbolTableEntry.varOffset();
2215         ASSERT(offset.isStack());
2216         RegisterID* local = &amp;registerFor(offset.stackOffset());
2217         local-&gt;deref();
2218     }
2219 
2220     if (hasCapturedVariables) {
2221         RELEASE_ASSERT(stackEntry.m_scope);
<span class="line-modified">2222         emitPopScope(scopeRegister(), stackEntry.m_scope);</span>
2223         popLocalControlFlowScope();
2224         stackEntry.m_scope-&gt;deref();
2225     }
2226 
2227     m_TDZStack.removeLast();
2228     m_cachedVariablesUnderTDZ = { };
2229 }
2230 
2231 void BytecodeGenerator::prepareLexicalScopeForNextForLoopIteration(VariableEnvironmentNode* node, RegisterID* loopSymbolTable)
2232 {
2233     VariableEnvironment&amp; environment = node-&gt;lexicalVariables();
2234     if (!environment.size())
2235         return;
2236     if (shouldEmitDebugHooks())
2237         environment.markAllVariablesAsCaptured();
2238     if (!environment.hasCapturedVariables())
2239         return;
2240 
2241     RELEASE_ASSERT(loopSymbolTable);
2242 
</pre>
<hr />
<pre>
2260         for (auto end = symbolTable-&gt;end(NoLockingNecessary), ptr = symbolTable-&gt;begin(NoLockingNecessary); ptr != end; ++ptr) {
2261             if (!ptr-&gt;value.varOffset().isScope())
2262                 continue;
2263 
2264             RefPtr&lt;UniquedStringImpl&gt; ident = ptr-&gt;key;
2265             Identifier identifier = Identifier::fromUid(m_vm, ident.get());
2266 
2267             RegisterID* transitionValue = newBlockScopeVariable();
2268             transitionValue-&gt;ref();
2269             emitGetFromScope(transitionValue, loopScope, variableForLocalEntry(identifier, ptr-&gt;value, loopSymbolTable-&gt;index(), true), DoNotThrowIfNotFound);
2270             activationValuesToCopyOver.uncheckedAppend(std::make_pair(transitionValue, identifier));
2271         }
2272     }
2273 
2274     // We need this dynamic behavior of the executing code to ensure
2275     // each loop iteration has a new activation object. (It&#39;s pretty ugly).
2276     // Also, this new activation needs to be assigned to the same register
2277     // as the previous scope because the loop body is compiled under
2278     // the assumption that the scope&#39;s register index is constant even
2279     // though the value in that register will change on each loop iteration.
<span class="line-modified">2280     RefPtr&lt;RegisterID&gt; parentScope = emitGetParentScope(newTemporary(), loopScope);</span>
<span class="line-removed">2281     move(scopeRegister(), parentScope.get());</span>
2282 
2283     OpCreateLexicalEnvironment::emit(this, loopScope, scopeRegister(), loopSymbolTable, addConstantValue(jsTDZValue()));
2284 
2285     move(scopeRegister(), loopScope);
2286 
2287     {
<span class="line-modified">2288         for (auto pair : activationValuesToCopyOver) {</span>
2289             const Identifier&amp; identifier = pair.second;
2290             SymbolTableEntry entry = symbolTable-&gt;get(NoLockingNecessary, identifier.impl());
2291             RELEASE_ASSERT(!entry.isNull());
2292             RegisterID* transitionValue = pair.first;
2293             emitPutToScope(loopScope, variableForLocalEntry(identifier, entry, loopSymbolTable-&gt;index(), true), transitionValue, DoNotThrowIfNotFound, InitializationMode::NotInitialization);
2294             transitionValue-&gt;deref();
2295         }
2296     }
2297 }
2298 
2299 Variable BytecodeGenerator::variable(const Identifier&amp; property, ThisResolutionType thisResolutionType)
2300 {
2301     if (property == propertyNames().thisIdentifier &amp;&amp; thisResolutionType == ThisResolutionType::Local)
2302         return Variable(property, VarOffset(thisRegister()-&gt;virtualRegister()), thisRegister(), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly), Variable::SpecialVariable, 0, false);
2303 
2304     // We can optimize lookups if the lexical variable is found before a &quot;with&quot; or &quot;catch&quot;
2305     // scope because we&#39;re guaranteed static resolution. If we have to pass through
2306     // a &quot;with&quot; or &quot;catch&quot; scope we loose this guarantee.
2307     // We can&#39;t optimize cases like this:
2308     // {
</pre>
<hr />
<pre>
2451             // scope and the resolved scope.
2452             RELEASE_ASSERT(!stackEntry.m_isWithScope);
2453 
2454             if (stackEntry.m_symbolTable-&gt;get(NoLockingNecessary, variable.ident().impl()).isNull())
2455                 continue;
2456 
2457             RegisterID* scope = stackEntry.m_scope;
2458             RELEASE_ASSERT(scope);
2459             return scope;
2460         }
2461 
2462         RELEASE_ASSERT_NOT_REACHED();
2463         return nullptr;
2464 
2465     }
2466     case VarKind::Invalid:
2467         // Indicates non-local resolution.
2468 
2469         dst = tempDestination(dst);
2470         OpResolveScope::emit(this, kill(dst), scopeRegister(), addConstant(variable.ident()), resolveType(), localScopeDepth());
<span class="line-removed">2471         m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());</span>
2472         return dst;
2473     }
2474 
2475     RELEASE_ASSERT_NOT_REACHED();
2476     return nullptr;
2477 }
2478 
2479 RegisterID* BytecodeGenerator::emitGetFromScope(RegisterID* dst, RegisterID* scope, const Variable&amp; variable, ResolveMode resolveMode)
2480 {
2481     switch (variable.offset().kind()) {
2482     case VarKind::Stack:
2483         return move(dst, variable.local());
2484 
2485     case VarKind::DirectArgument: {
2486         OpGetFromArguments::emit(this, kill(dst), scope, variable.offset().capturedArgumentsOffset().offset());
2487         return dst;
2488     }
2489 
2490     case VarKind::Scope:
2491     case VarKind::Invalid: {
2492         OpGetFromScope::emit(
2493             this,
2494             kill(dst),
2495             scope,
2496             addConstant(variable.ident()),
2497             GetPutInfo(resolveMode, variable.offset().isScope() ? LocalClosureVar : resolveType(), InitializationMode::NotInitialization),
2498             localScopeDepth(),
2499             variable.offset().isScope() ? variable.offset().scopeOffset().offset() : 0);
<span class="line-removed">2500         m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());</span>
2501         return dst;
2502     } }
2503 
2504     RELEASE_ASSERT_NOT_REACHED();
2505 }
2506 
2507 RegisterID* BytecodeGenerator::emitPutToScope(RegisterID* scope, const Variable&amp; variable, RegisterID* value, ResolveMode resolveMode, InitializationMode initializationMode)
2508 {
2509     switch (variable.offset().kind()) {
2510     case VarKind::Stack:
2511         move(variable.local(), value);
2512         return value;
2513 
2514     case VarKind::DirectArgument:
2515         OpPutToArguments::emit(this, scope, variable.offset().capturedArgumentsOffset().offset(), value);
2516         return value;
2517 
2518     case VarKind::Scope:
2519     case VarKind::Invalid: {
2520         GetPutInfo getPutInfo(0);
2521         SymbolTableOrScopeDepth symbolTableOrScopeDepth;
2522         ScopeOffset offset;
2523         if (variable.offset().isScope()) {
2524             offset = variable.offset().scopeOffset();
2525             getPutInfo = GetPutInfo(resolveMode, LocalClosureVar, initializationMode);
2526             symbolTableOrScopeDepth = SymbolTableOrScopeDepth::symbolTable(VirtualRegister { variable.symbolTableConstantIndex() });
2527         } else {
2528             ASSERT(resolveType() != LocalClosureVar);
2529             getPutInfo = GetPutInfo(resolveMode, resolveType(), initializationMode);
2530             symbolTableOrScopeDepth = SymbolTableOrScopeDepth::scopeDepth(localScopeDepth());
2531         }
2532         OpPutToScope::emit(this, scope, addConstant(variable.ident()), value, getPutInfo, symbolTableOrScopeDepth, !!offset ? offset.offset() : 0);
<span class="line-removed">2533         m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());</span>
2534         return value;
2535     } }
2536 
2537     RELEASE_ASSERT_NOT_REACHED();
2538 }
2539 
2540 RegisterID* BytecodeGenerator::initializeVariable(const Variable&amp; variable, RegisterID* value)
2541 {
2542     RELEASE_ASSERT(variable.offset().kind() != VarKind::Invalid);
2543     RegisterID* scope = emitResolveScope(nullptr, variable);
2544     return emitPutToScope(scope, variable, value, ThrowIfNotFound, InitializationMode::NotInitialization);
2545 }
2546 
2547 RegisterID* BytecodeGenerator::emitInstanceOf(RegisterID* dst, RegisterID* value, RegisterID* basePrototype)
2548 {
2549     OpInstanceof::emit(this, dst, value, basePrototype);
2550     return dst;
2551 }
2552 
2553 RegisterID* BytecodeGenerator::emitInstanceOfCustom(RegisterID* dst, RegisterID* value, RegisterID* constructor, RegisterID* hasInstanceValue)
</pre>
<hr />
<pre>
2564 
2565 RegisterID* BytecodeGenerator::emitInById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2566 {
2567     OpInById::emit(this, dst, base, addConstant(property));
2568     return dst;
2569 }
2570 
2571 RegisterID* BytecodeGenerator::emitTryGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2572 {
2573     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties are not supported with tryGetById.&quot;);
2574 
2575     OpTryGetById::emit(this, kill(dst), base, addConstant(property));
2576     return dst;
2577 }
2578 
2579 RegisterID* BytecodeGenerator::emitGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2580 {
2581     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with get_by_val.&quot;);
2582 
2583     OpGetById::emit(this, kill(dst), base, addConstant(property));
<span class="line-removed">2584     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());</span>
2585     return dst;
2586 }
2587 
2588 RegisterID* BytecodeGenerator::emitGetById(RegisterID* dst, RegisterID* base, RegisterID* thisVal, const Identifier&amp; property)
2589 {
2590     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with get_by_val.&quot;);
2591 
2592     OpGetByIdWithThis::emit(this, kill(dst), base, thisVal, addConstant(property));
2593     return dst;
2594 }
2595 
2596 RegisterID* BytecodeGenerator::emitDirectGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2597 {
2598     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with get_by_val_direct.&quot;);
2599 
2600     OpGetByIdDirect::emit(this, kill(dst), base, addConstant(property));
<span class="line-removed">2601     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());</span>
2602     return dst;
2603 }
2604 
2605 RegisterID* BytecodeGenerator::emitPutById(RegisterID* base, const Identifier&amp; property, RegisterID* value)
2606 {
2607     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with put_by_val.&quot;);
2608 
2609     unsigned propertyIndex = addConstant(property);
2610 
2611     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2612 
2613     OpPutById::emit(this, base, propertyIndex, value, PutByIdNone); // is not direct
<span class="line-removed">2614     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());</span>
<span class="line-removed">2615 </span>
2616     return value;
2617 }
2618 
2619 RegisterID* BytecodeGenerator::emitPutById(RegisterID* base, RegisterID* thisValue, const Identifier&amp; property, RegisterID* value)
2620 {
2621     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with put_by_val.&quot;);
2622 
2623     unsigned propertyIndex = addConstant(property);
2624 
2625     OpPutByIdWithThis::emit(this, base, thisValue, propertyIndex, value);
2626 
2627     return value;
2628 }
2629 
2630 RegisterID* BytecodeGenerator::emitDirectPutById(RegisterID* base, const Identifier&amp; property, RegisterID* value, PropertyNode::PutType putType)
2631 {
2632     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with put_by_val(direct).&quot;);
2633 
2634     unsigned propertyIndex = addConstant(property);
2635 
2636     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2637 
2638     PutByIdFlags type = (putType == PropertyNode::KnownDirect || property != m_vm.propertyNames-&gt;underscoreProto) ? PutByIdIsDirect : PutByIdNone;
2639     OpPutById::emit(this, base, propertyIndex, value, type);
<span class="line-removed">2640     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());</span>
2641     return value;
2642 }
2643 
2644 void BytecodeGenerator::emitPutGetterById(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* getter)
2645 {
2646     unsigned propertyIndex = addConstant(property);
2647     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2648 
2649     OpPutGetterById::emit(this, base, propertyIndex, attributes, getter);
2650 }
2651 
2652 void BytecodeGenerator::emitPutSetterById(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* setter)
2653 {
2654     unsigned propertyIndex = addConstant(property);
2655     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2656 
2657     OpPutSetterById::emit(this, base, propertyIndex, attributes, setter);
2658 }
2659 
2660 void BytecodeGenerator::emitPutGetterSetter(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* getter, RegisterID* setter)
2661 {
2662     unsigned propertyIndex = addConstant(property);
2663 
2664     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2665 
2666     OpPutGetterSetterById::emit(this, base, propertyIndex, attributes, getter, setter);
2667 }
2668 
2669 void BytecodeGenerator::emitPutGetterByVal(RegisterID* base, RegisterID* property, unsigned attributes, RegisterID* getter)
2670 {
2671     OpPutGetterByVal::emit(this, base, property, attributes, getter);
2672 }
2673 
2674 void BytecodeGenerator::emitPutSetterByVal(RegisterID* base, RegisterID* property, unsigned attributes, RegisterID* setter)
2675 {
2676     OpPutSetterByVal::emit(this, base, property, attributes, setter);
2677 }
2678 
2679 void BytecodeGenerator::emitPutGeneratorFields(RegisterID* nextFunction)
2680 {
<span class="line-modified">2681     // FIXME: Currently, we just create an object and store generator related fields as its properties for ease.</span>
<span class="line-removed">2682     // But to make it efficient, we will introduce JSGenerator class, add opcode new_generator and use its C++ fields instead of these private properties.</span>
<span class="line-removed">2683     // https://bugs.webkit.org/show_bug.cgi?id=151545</span>
<span class="line-removed">2684 </span>
<span class="line-removed">2685     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorNextPrivateName(), nextFunction, PropertyNode::KnownDirect);</span>
2686 
2687     // We do not store &#39;this&#39; in arrow function within constructor,
2688     // because it might be not initialized, if super is called later.
2689     if (!(isDerivedConstructorContext() &amp;&amp; m_codeBlock-&gt;parseMode() == SourceParseMode::AsyncArrowFunctionMode))
<span class="line-modified">2690         emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorThisPrivateName(), &amp;m_thisRegister, PropertyNode::KnownDirect);</span>
<span class="line-removed">2691 </span>
<span class="line-removed">2692     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorStatePrivateName(), emitLoad(nullptr, jsNumber(0)), PropertyNode::KnownDirect);</span>
<span class="line-removed">2693 </span>
<span class="line-removed">2694     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorFramePrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);</span>
2695 }
2696 
2697 void BytecodeGenerator::emitPutAsyncGeneratorFields(RegisterID* nextFunction)
2698 {
2699     ASSERT(isAsyncGeneratorWrapperParseMode(parseMode()));
2700 
<span class="line-modified">2701     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorNextPrivateName(), nextFunction, PropertyNode::KnownDirect);</span>
<span class="line-modified">2702 </span>
<span class="line-removed">2703     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorThisPrivateName(), &amp;m_thisRegister, PropertyNode::KnownDirect);</span>
<span class="line-removed">2704 </span>
<span class="line-removed">2705     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorStatePrivateName(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSAsyncGeneratorFunction::AsyncGeneratorState::SuspendedStart))), PropertyNode::KnownDirect);</span>
<span class="line-removed">2706 </span>
<span class="line-removed">2707     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorFramePrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);</span>
<span class="line-removed">2708 </span>
<span class="line-removed">2709     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().asyncGeneratorSuspendReasonPrivateName(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::None))), PropertyNode::KnownDirect);</span>
<span class="line-removed">2710 </span>
<span class="line-removed">2711     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().asyncGeneratorQueueFirstPrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);</span>
<span class="line-removed">2712     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().asyncGeneratorQueueLastPrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);</span>
2713 }
2714 
2715 RegisterID* BytecodeGenerator::emitDeleteById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2716 {
2717     OpDelById::emit(this, dst, base, addConstant(property));
2718     return dst;
2719 }
2720 
2721 RegisterID* BytecodeGenerator::emitGetByVal(RegisterID* dst, RegisterID* base, RegisterID* property)
2722 {
2723     for (size_t i = m_forInContextStack.size(); i--; ) {
2724         ForInContext&amp; context = m_forInContextStack[i].get();
2725         if (context.local() != property)
2726             continue;
2727 
2728         if (context.isIndexedForInContext()) {
2729             auto&amp; indexedContext = context.asIndexedForInContext();
2730             kill(dst);
2731             if (OpGetByVal::checkWithoutMetadataID&lt;OpcodeSize::Narrow&gt;(this, dst, base, property))
2732                 OpGetByVal::emitWithSmallestSizeRequirement&lt;OpcodeSize::Narrow&gt;(this, dst, base, indexedContext.index());
</pre>
<hr />
<pre>
2763 }
2764 
2765 RegisterID* BytecodeGenerator::emitPutByVal(RegisterID* base, RegisterID* thisValue, RegisterID* property, RegisterID* value)
2766 {
2767     OpPutByValWithThis::emit(this, base, thisValue, property, value);
2768     return value;
2769 }
2770 
2771 RegisterID* BytecodeGenerator::emitDirectPutByVal(RegisterID* base, RegisterID* property, RegisterID* value)
2772 {
2773     OpPutByValDirect::emit(this, base, property, value);
2774     return value;
2775 }
2776 
2777 RegisterID* BytecodeGenerator::emitDeleteByVal(RegisterID* dst, RegisterID* base, RegisterID* property)
2778 {
2779     OpDelByVal::emit(this, dst, base, property);
2780     return dst;
2781 }
2782 












2783 void BytecodeGenerator::emitSuperSamplerBegin()
2784 {
2785     OpSuperSamplerBegin::emit(this);
2786 }
2787 
2788 void BytecodeGenerator::emitSuperSamplerEnd()
2789 {
2790     OpSuperSamplerEnd::emit(this);
2791 }
2792 
2793 RegisterID* BytecodeGenerator::emitIdWithProfile(RegisterID* src, SpeculatedType profile)
2794 {
2795     OpIdentityWithProfile::emit(this, src, static_cast&lt;uint32_t&gt;(profile &gt;&gt; 32), static_cast&lt;uint32_t&gt;(profile));
2796     return src;
2797 }
2798 
2799 void BytecodeGenerator::emitUnreachable()
2800 {
2801     OpUnreachable::emit(this);
2802 }
2803 
2804 RegisterID* BytecodeGenerator::emitGetArgument(RegisterID* dst, int32_t index)
2805 {
2806     OpGetArgument::emit(this, dst, index + 1 /* Including |this| */);
2807     return dst;
2808 }
2809 
2810 RegisterID* BytecodeGenerator::emitCreateThis(RegisterID* dst)
2811 {
2812     OpCreateThis::emit(this, dst, dst, 0);
2813     m_staticPropertyAnalyzer.createThis(dst, m_lastInstruction);
















































2814 
<span class="line-removed">2815     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());</span>
2816     return dst;
2817 }
2818 
2819 void BytecodeGenerator::emitTDZCheck(RegisterID* target)
2820 {
2821     OpCheckTdz::emit(this, target);
2822 }
2823 
2824 bool BytecodeGenerator::needsTDZCheck(const Variable&amp; variable)
2825 {
2826     for (unsigned i = m_TDZStack.size(); i--;) {
2827         auto iter = m_TDZStack[i].find(variable.ident().impl());
2828         if (iter == m_TDZStack[i].end())
2829             continue;
2830         return iter-&gt;value != TDZNecessityLevel::NotNeeded;
2831     }
2832 
2833     return false;
2834 }
2835 
</pre>
<hr />
<pre>
2932 void BytecodeGenerator::restoreTDZStack(const BytecodeGenerator::PreservedTDZStack&amp; preservedStack)
2933 {
2934     m_TDZStack = preservedStack.m_preservedTDZStack;
2935     m_cachedVariablesUnderTDZ = { };
2936 }
2937 
2938 RegisterID* BytecodeGenerator::emitNewObject(RegisterID* dst)
2939 {
2940     OpNewObject::emit(this, dst, 0);
2941     m_staticPropertyAnalyzer.newObject(dst, m_lastInstruction);
2942 
2943     return dst;
2944 }
2945 
2946 JSValue BytecodeGenerator::addBigIntConstant(const Identifier&amp; identifier, uint8_t radix, bool sign)
2947 {
2948     return m_bigIntMap.ensure(BigIntMapEntry(identifier.impl(), radix, sign), [&amp;] {
2949         auto scope = DECLARE_CATCH_SCOPE(vm());
2950         auto parseIntSign = sign ? JSBigInt::ParseIntSign::Signed : JSBigInt::ParseIntSign::Unsigned;
2951         JSBigInt* bigIntInMap = JSBigInt::parseInt(nullptr, vm(), identifier.string(), radix, JSBigInt::ErrorParseMode::ThrowExceptions, parseIntSign);
<span class="line-removed">2952         // FIXME: [ESNext] Enables a way to throw an error on ByteCodeGenerator step</span>
<span class="line-removed">2953         // https://bugs.webkit.org/show_bug.cgi?id=180139</span>
2954         scope.assertNoException();
<span class="line-removed">2955         RELEASE_ASSERT(bigIntInMap);</span>
2956         addConstantValue(bigIntInMap);
2957 
2958         return bigIntInMap;
2959     }).iterator-&gt;value;
2960 }
2961 
2962 JSString* BytecodeGenerator::addStringConstant(const Identifier&amp; identifier)
2963 {
2964     JSString*&amp; stringInMap = m_stringMap.add(identifier.impl(), nullptr).iterator-&gt;value;
2965     if (!stringInMap) {
2966         stringInMap = jsString(vm(), identifier.string());
2967         addConstantValue(stringInMap);
2968     }
2969     return stringInMap;
2970 }
2971 
2972 RegisterID* BytecodeGenerator::addTemplateObjectConstant(Ref&lt;TemplateObjectDescriptor&gt;&amp;&amp; descriptor, int endOffset)
2973 {
2974     auto result = m_templateObjectDescriptorSet.add(WTFMove(descriptor));
2975     JSTemplateObjectDescriptor* descriptorValue = m_templateDescriptorMap.ensure(endOffset, [&amp;] {
</pre>
<hr />
<pre>
3080 {
3081     emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
3082     return dst;
3083 }
3084 
3085 RegisterID* BytecodeGenerator::emitNewArrowFunctionExpression(RegisterID* dst, ArrowFuncExprNode* func)
3086 {
3087     ASSERT(SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(func-&gt;metadata()-&gt;parseMode()));
3088     emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
3089     return dst;
3090 }
3091 
3092 RegisterID* BytecodeGenerator::emitNewMethodDefinition(RegisterID* dst, MethodDefinitionNode* func)
3093 {
3094     ASSERT(isMethodParseMode(func-&gt;metadata()-&gt;parseMode()));
3095     emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
3096     return dst;
3097 }
3098 
3099 RegisterID* BytecodeGenerator::emitNewDefaultConstructor(RegisterID* dst, ConstructorKind constructorKind, const Identifier&amp; name,
<span class="line-modified">3100     const Identifier&amp; ecmaName, const SourceCode&amp; classSource)</span>
3101 {
<span class="line-modified">3102     UnlinkedFunctionExecutable* executable = m_vm.builtinExecutables()-&gt;createDefaultConstructor(constructorKind, name);</span>
3103     executable-&gt;setInvalidTypeProfilingOffsets();
3104     executable-&gt;setEcmaName(ecmaName);
3105     executable-&gt;setClassSource(classSource);
3106 
3107     unsigned index = m_codeBlock-&gt;addFunctionExpr(executable);
3108 
3109     OpNewFuncExp::emit(this, dst, scopeRegister(), index);
3110     return dst;
3111 }
3112 



























3113 RegisterID* BytecodeGenerator::emitNewFunction(RegisterID* dst, FunctionMetadataNode* function)
3114 {
3115     unsigned index = m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
3116     if (isGeneratorWrapperParseMode(function-&gt;parseMode()))
3117         OpNewGeneratorFunc::emit(this, dst, scopeRegister(), index);
3118     else if (function-&gt;parseMode() == SourceParseMode::AsyncFunctionMode)
3119         OpNewAsyncFunc::emit(this, dst, scopeRegister(), index);
3120     else if (isAsyncGeneratorWrapperParseMode(function-&gt;parseMode()))
3121         OpNewAsyncGeneratorFunc::emit(this, dst, scopeRegister(), index);
3122     else
3123         OpNewFunc::emit(this, dst, scopeRegister(), index);
3124     return dst;
3125 }
3126 
<span class="line-modified">3127 void BytecodeGenerator::emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, RegisterID* name)</span>

3128 {
3129     if (valueNode-&gt;isBaseFuncExprNode()) {
3130         FunctionMetadataNode* metadata = static_cast&lt;BaseFuncExprNode*&gt;(valueNode)-&gt;metadata();
3131         if (!metadata-&gt;ecmaName().isNull())
3132             return;
3133     } else if (valueNode-&gt;isClassExprNode()) {
3134         ClassExprNode* classExprNode = static_cast&lt;ClassExprNode*&gt;(valueNode);
3135         if (!classExprNode-&gt;ecmaName().isNull())
3136             return;
3137         if (classExprNode-&gt;hasStaticProperty(m_vm.propertyNames-&gt;name))
3138             return;
3139     } else
3140         return;
3141 


3142     // FIXME: We should use an op_call to an internal function here instead.
3143     // https://bugs.webkit.org/show_bug.cgi?id=155547
3144     OpSetFunctionName::emit(this, value, name);
3145 }
3146 










3147 RegisterID* BytecodeGenerator::emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3148 {
3149     return emitCall&lt;OpCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3150 }
3151 
3152 RegisterID* BytecodeGenerator::emitCallInTailPosition(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3153 {
3154     if (m_inTailPosition) {
3155         m_codeBlock-&gt;setHasTailCalls();
3156         return emitCall&lt;OpTailCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3157     }
3158     return emitCall&lt;OpCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3159 }
3160 
3161 RegisterID* BytecodeGenerator::emitCallEval(RegisterID* dst, RegisterID* func, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3162 {
3163     return emitCall&lt;OpCallEval&gt;(dst, func, NoExpectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3164 }
3165 
3166 ExpectedFunction BytecodeGenerator::expectedFunctionForIdentifier(const Identifier&amp; identifier)
3167 {
3168     if (identifier == propertyNames().Object || identifier == propertyNames().builtinNames().ObjectPrivateName())
3169         return ExpectObjectConstructor;
3170     if (identifier == propertyNames().Array || identifier == propertyNames().builtinNames().ArrayPrivateName())
3171         return ExpectArrayConstructor;
3172     return NoExpectedFunction;
3173 }
3174 
3175 ExpectedFunction BytecodeGenerator::emitExpectedFunctionSnippet(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, Label&amp; done)
3176 {
3177     Ref&lt;Label&gt; realCall = newLabel();
3178     switch (expectedFunction) {
3179     case ExpectObjectConstructor: {
3180         // If the number of arguments is non-zero, then we can&#39;t do anything interesting.
3181         if (callArguments.argumentCountIncludingThis() &gt;= 2)
3182             return NoExpectedFunction;
3183 
<span class="line-modified">3184         OpJneqPtr::emit(this, func, Special::ObjectConstructor, realCall-&gt;bind(this));</span>
3185 
3186         if (dst != ignoredResult())
3187             emitNewObject(dst);
3188         break;
3189     }
3190 
3191     case ExpectArrayConstructor: {
3192         // If you&#39;re doing anything other than &quot;new Array()&quot; or &quot;new Array(foo)&quot; then we
3193         // don&#39;t do inline it, for now. The only reason is that call arguments are in
3194         // the opposite order of what op_new_array expects, so we&#39;d either need to change
3195         // how op_new_array works or we&#39;d need an op_new_array_reverse. Neither of these
3196         // things sounds like it&#39;s worth it.
3197         if (callArguments.argumentCountIncludingThis() &gt; 2)
3198             return NoExpectedFunction;
3199 
<span class="line-modified">3200         OpJneqPtr::emit(this, func, Special::ArrayConstructor, realCall-&gt;bind(this));</span>
3201 
3202         if (dst != ignoredResult()) {
3203             if (callArguments.argumentCountIncludingThis() == 2)
3204                 emitNewArrayWithSize(dst, callArguments.argumentRegister(0));
3205             else {
3206                 ASSERT(callArguments.argumentCountIncludingThis() == 1);
3207                 OpNewArray::emit(this, dst, VirtualRegister { 0 }, 0, ArrayWithUndecided);
3208             }
3209         }
3210         break;
3211     }
3212 
3213     default:
3214         ASSERT(expectedFunction == NoExpectedFunction);
3215         return NoExpectedFunction;
3216     }
3217 
3218     OpJmp::emit(this, done.bind(this));
3219     emitLabel(realCall.get());
3220 
</pre>
<hr />
<pre>
3302 {
3303     // We must emit a tail call here because we did not allocate an arguments object thus we would otherwise have no way to correctly make this call.
3304     ASSERT(m_inTailPosition || !Options::useTailCalls());
3305     return emitCallVarargs&lt;OpTailCallForwardArguments&gt;(dst, func, thisRegister, nullptr, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3306 }
3307 
3308 template&lt;typename VarargsOp&gt;
3309 RegisterID* BytecodeGenerator::emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3310 {
3311     if (shouldEmitDebugHooks() &amp;&amp; debuggableCall == DebuggableCall::Yes)
3312         emitDebugHook(WillExecuteExpression, divotStart);
3313 
3314     emitExpressionInfo(divot, divotStart, divotEnd);
3315 
3316     if (VarargsOp::opcodeID == op_tail_call_varargs)
3317         emitLogShadowChickenTailIfNecessary();
3318 
3319     // Emit call.
3320     ASSERT(dst != ignoredResult());
3321     VarargsOp::emit(this, dst, func, thisRegister, arguments ? arguments : VirtualRegister(0), firstFreeRegister, firstVarArgOffset);


3322     return dst;
3323 }
3324 
3325 void BytecodeGenerator::emitLogShadowChickenPrologueIfNecessary()
3326 {
3327     if (!shouldEmitDebugHooks() &amp;&amp; !Options::alwaysUseShadowChicken())
3328         return;
3329     OpLogShadowChickenPrologue::emit(this, scopeRegister());
3330 }
3331 
3332 void BytecodeGenerator::emitLogShadowChickenTailIfNecessary()
3333 {
3334     if (!shouldEmitDebugHooks() &amp;&amp; !Options::alwaysUseShadowChicken())
3335         return;
3336     OpLogShadowChickenTail::emit(this, thisRegister(), scopeRegister());
3337 }
3338 
3339 void BytecodeGenerator::emitCallDefineProperty(RegisterID* newObj, RegisterID* propertyNameRegister,
3340     RegisterID* valueRegister, RegisterID* getterRegister, RegisterID* setterRegister, unsigned options, const JSTextPosition&amp; position)
3341 {
</pre>
<hr />
<pre>
3348     else if (valueRegister)
3349         attributes.setWritable(false);
3350 
3351     if (options &amp; PropertyEnumerable)
3352         attributes.setEnumerable(true);
3353 
3354     if (valueRegister)
3355         attributes.setValue();
3356     if (getterRegister)
3357         attributes.setGet();
3358     if (setterRegister)
3359         attributes.setSet();
3360 
3361     ASSERT(!valueRegister || (!getterRegister &amp;&amp; !setterRegister));
3362 
3363     emitExpressionInfo(position, position, position);
3364 
3365     if (attributes.hasGet() || attributes.hasSet()) {
3366         RefPtr&lt;RegisterID&gt; throwTypeErrorFunction;
3367         if (!attributes.hasGet() || !attributes.hasSet())
<span class="line-modified">3368             throwTypeErrorFunction = moveLinkTimeConstant(nullptr, LinkTimeConstant::ThrowTypeErrorFunction);</span>
3369 
3370         RefPtr&lt;RegisterID&gt; getter;
3371         if (attributes.hasGet())
3372             getter = getterRegister;
3373         else
3374             getter = throwTypeErrorFunction;
3375 
3376         RefPtr&lt;RegisterID&gt; setter;
3377         if (attributes.hasSet())
3378             setter = setterRegister;
3379         else
3380             setter = throwTypeErrorFunction;
3381 
3382         OpDefineAccessorProperty::emit(this, newObj, propertyNameRegister, getter.get(), setter.get(), emitLoad(nullptr, jsNumber(attributes.rawRepresentation())));
3383     } else {
3384         OpDefineDataProperty::emit(this, newObj, propertyNameRegister, valueRegister, emitLoad(nullptr, jsNumber(attributes.rawRepresentation())));
3385     }
3386 }
3387 
3388 RegisterID* BytecodeGenerator::emitReturn(RegisterID* src, ReturnFrom from)
3389 {
<span class="line-modified">3390     if (isConstructor()) {</span>

3391         bool isDerived = constructorKind() == ConstructorKind::Extends;
3392         bool srcIsThis = src-&gt;index() == m_thisRegister.index();
3393 
3394         if (isDerived &amp;&amp; (srcIsThis || from == ReturnFrom::Finally))
3395             emitTDZCheck(src);
3396 
3397         if (!srcIsThis || from == ReturnFrom::Finally) {
3398             Ref&lt;Label&gt; isObjectLabel = newLabel();
3399             emitJumpIfTrue(emitIsObject(newTemporary(), src), isObjectLabel.get());
3400 
3401             if (isDerived) {
3402                 Ref&lt;Label&gt; isUndefinedLabel = newLabel();
3403                 emitJumpIfTrue(emitIsUndefined(newTemporary(), src), isUndefinedLabel.get());
3404                 emitThrowTypeError(&quot;Cannot return a non-object type in the constructor of a derived class.&quot;);
3405                 emitLabel(isUndefinedLabel.get());
3406                 emitTDZCheck(&amp;m_thisRegister);
3407             }
3408             OpRet::emit(this, &amp;m_thisRegister);
3409             emitLabel(isObjectLabel.get());
3410         }
</pre>
<hr />
<pre>
3469 
3470     OpConstruct::emit(this, dst, func, callArguments.argumentCountIncludingThis(), callArguments.stackOffset());
3471 
3472     if (expectedFunction != NoExpectedFunction)
3473         emitLabel(done.get());
3474 
3475     return dst;
3476 }
3477 
3478 RegisterID* BytecodeGenerator::emitStrcat(RegisterID* dst, RegisterID* src, int count)
3479 {
3480     OpStrcat::emit(this, dst, src, count);
3481     return dst;
3482 }
3483 
3484 void BytecodeGenerator::emitToPrimitive(RegisterID* dst, RegisterID* src)
3485 {
3486     OpToPrimitive::emit(this, dst, src);
3487 }
3488 






3489 void BytecodeGenerator::emitGetScope()
3490 {
3491     OpGetScope::emit(this, scopeRegister());
3492 }
3493 
3494 RegisterID* BytecodeGenerator::emitPushWithScope(RegisterID* objectScope)
3495 {
3496     pushLocalControlFlowScope();
3497     RegisterID* newScope = newBlockScopeVariable();
3498     newScope-&gt;ref();
3499 
3500     OpPushWithScope::emit(this, newScope, scopeRegister(), objectScope);
3501 
3502     move(scopeRegister(), newScope);
3503     m_lexicalScopeStack.append({ nullptr, newScope, true, 0 });
3504 
3505     return newScope;
3506 }
3507 
3508 RegisterID* BytecodeGenerator::emitGetParentScope(RegisterID* dst, RegisterID* scope)
3509 {
3510     OpGetParentScope::emit(this, dst, scope);
3511     return dst;
3512 }
3513 
<span class="line-removed">3514 void BytecodeGenerator::emitPopScope(RegisterID* dst, RegisterID* scope)</span>
<span class="line-removed">3515 {</span>
<span class="line-removed">3516     RefPtr&lt;RegisterID&gt; parentScope = emitGetParentScope(newTemporary(), scope);</span>
<span class="line-removed">3517     move(dst, parentScope.get());</span>
<span class="line-removed">3518 }</span>
<span class="line-removed">3519 </span>
3520 void BytecodeGenerator::emitPopWithScope()
3521 {
<span class="line-modified">3522     emitPopScope(scopeRegister(), scopeRegister());</span>
3523     popLocalControlFlowScope();
3524     auto stackEntry = m_lexicalScopeStack.takeLast();
3525     stackEntry.m_scope-&gt;deref();
3526     RELEASE_ASSERT(stackEntry.m_isWithScope);
3527 }
3528 
3529 void BytecodeGenerator::emitDebugHook(DebugHookType debugHookType, const JSTextPosition&amp; divot)
3530 {
3531     if (!shouldEmitDebugHooks())
3532         return;
3533 
3534     emitExpressionInfo(divot, divot, divot);
3535     OpDebug::emit(this, debugHookType, false);
3536 }
3537 
3538 void BytecodeGenerator::emitDebugHook(DebugHookType debugHookType, unsigned line, unsigned charOffset, unsigned lineStart)
3539 {
3540     emitDebugHook(debugHookType, JSTextPosition(line, charOffset, lineStart));
3541 }
3542 
</pre>
<hr />
<pre>
3623             }
3624         }
3625         return nullptr;
3626     }
3627 
3628     // Continue to the loop nested nearest to the label scope that matches
3629     // &#39;name&#39;.
3630     LabelScope* result = nullptr;
3631     for (int i = m_labelScopes.size() - 1; i &gt;= 0; --i) {
3632         LabelScope&amp; scope = m_labelScopes[i];
3633         if (scope.type() == LabelScope::Loop) {
3634             ASSERT(scope.continueTarget());
3635             result = &amp;scope;
3636         }
3637         if (scope.name() &amp;&amp; *scope.name() == name)
3638             return result; // may be null.
3639     }
3640     return nullptr;
3641 }
3642 
<span class="line-removed">3643 void BytecodeGenerator::allocateCalleeSaveSpace()</span>
<span class="line-removed">3644 {</span>
<span class="line-removed">3645     size_t virtualRegisterCountForCalleeSaves = CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters();</span>
<span class="line-removed">3646 </span>
<span class="line-removed">3647     for (size_t i = 0; i &lt; virtualRegisterCountForCalleeSaves; i++) {</span>
<span class="line-removed">3648         RegisterID* localRegister = addVar();</span>
<span class="line-removed">3649         localRegister-&gt;ref();</span>
<span class="line-removed">3650         m_localRegistersForCalleeSaveRegisters.append(localRegister);</span>
<span class="line-removed">3651     }</span>
<span class="line-removed">3652 }</span>
<span class="line-removed">3653 </span>
3654 void BytecodeGenerator::allocateAndEmitScope()
3655 {
3656     m_scopeRegister = addVar();
3657     m_scopeRegister-&gt;ref();
3658     m_codeBlock-&gt;setScopeRegister(scopeRegister()-&gt;virtualRegister());
3659     emitGetScope();
3660     m_topMostScope = addVar();
3661     move(m_topMostScope, scopeRegister());
3662 }
3663 
3664 TryData* BytecodeGenerator::pushTry(Label&amp; start, Label&amp; handlerLabel, HandlerType handlerType)
3665 {
3666     m_tryData.append(TryData { handlerLabel, handlerType });
3667     TryData* result = &amp;m_tryData.last();
3668 
3669     m_tryContextStack.append(TryContext {
3670         start,
3671         result
3672     });
3673 
</pre>
<hr />
<pre>
3804 {
3805     emitThrowStaticError(ErrorType::Error, Identifier::fromString(m_vm, &quot;Out of memory&quot;));
3806 }
3807 
3808 void BytecodeGenerator::emitPushFunctionNameScope(const Identifier&amp; property, RegisterID* callee, bool isCaptured)
3809 {
3810     // There is some nuance here:
3811     // If we&#39;re in strict mode code, the function name scope variable acts exactly like a &quot;const&quot; variable.
3812     // If we&#39;re not in strict mode code, we want to allow bogus assignments to the name scoped variable.
3813     // This means any assignment to the variable won&#39;t throw, but it won&#39;t actually assign a new value to it.
3814     // To accomplish this, we don&#39;t report that this scope is a lexical scope. This will prevent
3815     // any throws when trying to assign to the variable (while still ensuring it keeps its original
3816     // value). There is some ugliness and exploitation of a leaky abstraction here, but it&#39;s better than
3817     // having a completely new op code and a class to handle name scopes which are so close in functionality
3818     // to lexical environments.
3819     VariableEnvironment nameScopeEnvironment;
3820     auto addResult = nameScopeEnvironment.add(property);
3821     if (isCaptured)
3822         addResult.iterator-&gt;value.setIsCaptured();
3823     addResult.iterator-&gt;value.setIsConst(); // The function name scope name acts like a const variable.
<span class="line-modified">3824     unsigned numVars = m_codeBlock-&gt;m_numVars;</span>
3825     pushLexicalScopeInternal(nameScopeEnvironment, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, TDZRequirement::NotUnderTDZ, ScopeType::FunctionNameScope, ScopeRegisterType::Var);
<span class="line-modified">3826     ASSERT_UNUSED(numVars, m_codeBlock-&gt;m_numVars == static_cast&lt;int&gt;(numVars + 1)); // Should have only created one new &quot;var&quot; for the function name scope.</span>
3827     bool shouldTreatAsLexicalVariable = isStrictMode();
3828     Variable functionVar = variableForLocalEntry(property, m_lexicalScopeStack.last().m_symbolTable-&gt;get(NoLockingNecessary, property.impl()), m_lexicalScopeStack.last().m_symbolTableConstantIndex, shouldTreatAsLexicalVariable);
3829     emitPutToScope(m_lexicalScopeStack.last().m_scope, functionVar, callee, ThrowIfNotFound, InitializationMode::NotInitialization);
3830 }
3831 
3832 void BytecodeGenerator::pushLocalControlFlowScope()
3833 {
3834     ControlFlowScope scope(ControlFlowScope::Label, currentLexicalScopeIndex());
3835     m_controlFlowScopeStack.append(WTFMove(scope));
3836     m_localScopeDepth++;
3837 }
3838 
3839 void BytecodeGenerator::popLocalControlFlowScope()
3840 {
3841     ASSERT(m_controlFlowScopeStack.size());
3842     ASSERT(!m_controlFlowScopeStack.last().isFinallyScope());
3843     m_controlFlowScopeStack.removeLast();
3844     m_localScopeDepth--;
3845 }
3846 
</pre>
<hr />
<pre>
3897 
3898 static int32_t keyForCharacterSwitch(ExpressionNode* node, int32_t min, int32_t max)
3899 {
3900     UNUSED_PARAM(max);
3901     ASSERT(node-&gt;isString());
3902     StringImpl* clause = static_cast&lt;StringNode*&gt;(node)-&gt;value().impl();
3903     ASSERT(clause-&gt;length() == 1);
3904 
3905     int32_t key = (*clause)[0];
3906     ASSERT(key &gt;= min);
3907     ASSERT(key &lt;= max);
3908     return key - min;
3909 }
3910 
3911 static void prepareJumpTableForSwitch(
3912     UnlinkedSimpleJumpTable&amp; jumpTable, int32_t switchAddress, uint32_t clauseCount,
3913     const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp; labels, ExpressionNode** nodes, int32_t min, int32_t max,
3914     int32_t (*keyGetter)(ExpressionNode*, int32_t min, int32_t max))
3915 {
3916     jumpTable.min = min;
<span class="line-modified">3917     jumpTable.branchOffsets.resize(max - min + 1);</span>
<span class="line-modified">3918     jumpTable.branchOffsets.fill(0);</span>
3919     for (uint32_t i = 0; i &lt; clauseCount; ++i) {
3920         // We&#39;re emitting this after the clause labels should have been fixed, so
3921         // the labels should not be &quot;forward&quot; references
3922         ASSERT(!labels[i]-&gt;isForward());
3923         jumpTable.add(keyGetter(nodes[i], min, max), labels[i]-&gt;bind(switchAddress));
3924     }
3925 }
3926 
3927 static void prepareJumpTableForStringSwitch(UnlinkedStringJumpTable&amp; jumpTable, int32_t switchAddress, uint32_t clauseCount, const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp; labels, ExpressionNode** nodes)
3928 {
3929     for (uint32_t i = 0; i &lt; clauseCount; ++i) {
3930         // We&#39;re emitting this after the clause labels should have been fixed, so
3931         // the labels should not be &quot;forward&quot; references
3932         ASSERT(!labels[i]-&gt;isForward());
3933 
3934         ASSERT(nodes[i]-&gt;isString());
3935         StringImpl* clause = static_cast&lt;StringNode*&gt;(nodes[i])-&gt;value().impl();
3936         jumpTable.offsetTable.add(clause, UnlinkedStringJumpTable::OffsetLocation { labels[i]-&gt;bind(switchAddress) });
3937     }
3938 }
</pre>
<hr />
<pre>
4316 
4317 void BytecodeGenerator::pushIndexedForInScope(RegisterID* localRegister, RegisterID* indexRegister)
4318 {
4319     if (!localRegister)
4320         return;
4321     unsigned bodyBytecodeStartOffset = instructions().size();
4322     m_forInContextStack.append(adoptRef(*new IndexedForInContext(localRegister, indexRegister, bodyBytecodeStartOffset)));
4323 }
4324 
4325 void BytecodeGenerator::popIndexedForInScope(RegisterID* localRegister)
4326 {
4327     if (!localRegister)
4328         return;
4329     unsigned bodyBytecodeEndOffset = instructions().size();
4330     m_forInContextStack.last()-&gt;asIndexedForInContext().finalize(*this, m_codeBlock.get(), bodyBytecodeEndOffset);
4331     m_forInContextStack.removeLast();
4332 }
4333 
4334 RegisterID* BytecodeGenerator::emitLoadArrowFunctionLexicalEnvironment(const Identifier&amp; identifier)
4335 {
<span class="line-modified">4336     ASSERT(m_codeBlock-&gt;isArrowFunction() || m_codeBlock-&gt;isArrowFunctionContext() || constructorKind() == ConstructorKind::Extends || m_codeType == EvalCode);</span>
4337 
4338     return emitResolveScope(nullptr, variable(identifier, ThisResolutionType::Scoped));
4339 }
4340 
4341 void BytecodeGenerator::emitLoadThisFromArrowFunctionLexicalEnvironment()
4342 {
4343     emitGetFromScope(thisRegister(), emitLoadArrowFunctionLexicalEnvironment(propertyNames().thisIdentifier), variable(propertyNames().thisIdentifier, ThisResolutionType::Scoped), DoNotThrowIfNotFound);
4344 }
4345 
4346 RegisterID* BytecodeGenerator::emitLoadNewTargetFromArrowFunctionLexicalEnvironment()
4347 {
4348     Variable newTargetVar = variable(propertyNames().builtinNames().newTargetLocalPrivateName());
4349 
4350     return emitGetFromScope(m_newTargetRegister, emitLoadArrowFunctionLexicalEnvironment(propertyNames().builtinNames().newTargetLocalPrivateName()), newTargetVar, ThrowIfNotFound);
4351 
4352 }
4353 
4354 RegisterID* BytecodeGenerator::emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment()
4355 {
4356     Variable protoScopeVar = variable(propertyNames().builtinNames().derivedConstructorPrivateName());
4357     return emitGetFromScope(newTemporary(), emitLoadArrowFunctionLexicalEnvironment(propertyNames().builtinNames().derivedConstructorPrivateName()), protoScopeVar, ThrowIfNotFound);
4358 }
4359 








4360 RegisterID* BytecodeGenerator::ensureThis()
4361 {
4362     if (constructorKind() == ConstructorKind::Extends || isDerivedConstructorContext()) {
4363         if ((needsToUpdateArrowFunctionContext() &amp;&amp; isSuperCallUsedInInnerArrowFunction()) || m_codeBlock-&gt;parseMode() == SourceParseMode::AsyncArrowFunctionBodyMode)
4364             emitLoadThisFromArrowFunctionLexicalEnvironment();
4365 
4366         emitTDZCheck(thisRegister());
4367     }
4368 
4369     return thisRegister();
4370 }
4371 
4372 bool BytecodeGenerator::isThisUsedInInnerArrowFunction()
4373 {
4374     return m_scopeNode-&gt;doAnyInnerArrowFunctionsUseThis() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperProperty() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperCall() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval() || m_codeBlock-&gt;usesEval();
4375 }
4376 
4377 bool BytecodeGenerator::isArgumentsUsedInInnerArrowFunction()
4378 {
4379     return m_scopeNode-&gt;doAnyInnerArrowFunctionsUseArguments() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval();
</pre>
<hr />
<pre>
4444 }
4445 
4446 RegisterID* BytecodeGenerator::emitRestParameter(RegisterID* result, unsigned numParametersToSkip)
4447 {
4448     RefPtr&lt;RegisterID&gt; restArrayLength = newTemporary();
4449     OpGetRestLength::emit(this, restArrayLength.get(), numParametersToSkip);
4450 
4451     OpCreateRest::emit(this, result, restArrayLength.get(), numParametersToSkip);
4452 
4453     return result;
4454 }
4455 
4456 void BytecodeGenerator::emitRequireObjectCoercible(RegisterID* value, const String&amp; error)
4457 {
4458     Ref&lt;Label&gt; target = newLabel();
4459     OpJnundefinedOrNull::emit(this, value, target-&gt;bind(this));
4460     emitThrowTypeError(error);
4461     emitLabel(target.get());
4462 }
4463 
<span class="line-modified">4464 void BytecodeGenerator::emitYieldPoint(RegisterID* argument, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason result)</span>
4465 {
4466     Ref&lt;Label&gt; mergePoint = newLabel();
4467     unsigned yieldPointIndex = m_yieldPoints++;
4468     emitGeneratorStateChange(yieldPointIndex + 1);
4469 
4470     if (parseMode() == SourceParseMode::AsyncGeneratorBodyMode) {
4471         int suspendReason = static_cast&lt;int32_t&gt;(result);
<span class="line-modified">4472         emitPutById(generatorRegister(), propertyNames().builtinNames().asyncGeneratorSuspendReasonPrivateName(), emitLoad(nullptr, jsNumber(suspendReason)));</span>
4473     }
4474 
4475     // Split the try range here.
4476     Ref&lt;Label&gt; savePoint = newEmittedLabel();
4477     for (unsigned i = m_tryContextStack.size(); i--;) {
4478         TryContext&amp; context = m_tryContextStack[i];
4479         m_tryRanges.append(TryRange {
4480             context.start.copyRef(),
4481             savePoint.copyRef(),
4482             context.tryData
4483         });
4484         // Try range will be restared at the merge point.
4485         context.start = mergePoint.get();
4486     }
4487     Vector&lt;TryContext&gt; savedTryContextStack;
4488     m_tryContextStack.swap(savedTryContextStack);
4489 
4490 
4491 #if CPU(NEEDS_ALIGNED_ACCESS)
4492     // conservatively align for the bytecode rewriter: it will delete this yield and
4493     // append a fragment, so we make sure that the start of the fragments is aligned
4494     while (m_writer.position() % OpcodeSize::Wide32)
4495         OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);
4496 #endif
4497     OpYield::emit(this, generatorFrameRegister(), yieldPointIndex, argument);
4498 
4499     // Restore the try contexts, which start offset is updated to the merge point.
4500     m_tryContextStack.swap(savedTryContextStack);
4501     emitLabel(mergePoint.get());
4502 }
4503 
<span class="line-modified">4504 RegisterID* BytecodeGenerator::emitYield(RegisterID* argument, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason result)</span>
4505 {
4506     emitYieldPoint(argument, result);
4507 
4508     Ref&lt;Label&gt; normalLabel = newLabel();
4509     RefPtr&lt;RegisterID&gt; condition = newTemporary();
<span class="line-modified">4510     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::NormalMode))));</span>
4511     emitJumpIfTrue(condition.get(), normalLabel.get());
4512 
4513     Ref&lt;Label&gt; throwLabel = newLabel();
<span class="line-modified">4514     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::ThrowMode))));</span>
4515     emitJumpIfTrue(condition.get(), throwLabel.get());
4516     // Return.
4517     {
4518         RefPtr&lt;RegisterID&gt; returnRegister = generatorValueRegister();
4519         bool hasFinally = emitReturnViaFinallyIfNeeded(returnRegister.get());
4520         if (!hasFinally)
4521             emitReturn(returnRegister.get());
4522     }
4523 
4524     // Throw.
4525     emitLabel(throwLabel.get());
4526     emitThrow(generatorValueRegister());
4527 
4528     // Normal.
4529     emitLabel(normalLabel.get());
4530     return generatorValueRegister();
4531 }
4532 
4533 RegisterID* BytecodeGenerator::emitCallIterator(RegisterID* iterator, RegisterID* argument, ThrowableExpressionData* node)
4534 {
4535     CallArguments args(*this, nullptr);
4536     move(args.thisRegister(), argument);
4537     emitCall(iterator, iterator, NoExpectedFunction, args, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4538 
4539     return iterator;
4540 }
4541 
4542 void BytecodeGenerator::emitAwait(RegisterID* value)
4543 {
<span class="line-modified">4544     emitYield(value, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Await);</span>
4545     move(value, generatorValueRegister());
4546 }
4547 
4548 RegisterID* BytecodeGenerator::emitGetIterator(RegisterID* argument, ThrowableExpressionData* node)
4549 {
4550     RefPtr&lt;RegisterID&gt; iterator = emitGetById(newTemporary(), argument, propertyNames().iteratorSymbol);
4551     emitCallIterator(iterator.get(), argument, node);
4552 
4553     return iterator.get();
4554 }
4555 
4556 RegisterID* BytecodeGenerator::emitGetAsyncIterator(RegisterID* argument, ThrowableExpressionData* node)
4557 {
4558     RefPtr&lt;RegisterID&gt; iterator = emitGetById(newTemporary(), argument, propertyNames().asyncIteratorSymbol);
4559     Ref&lt;Label&gt; asyncIteratorNotFound = newLabel();
4560     Ref&lt;Label&gt; asyncIteratorFound = newLabel();
4561     Ref&lt;Label&gt; iteratorReceived = newLabel();
4562 
4563     emitJumpIfTrue(emitUnaryOp&lt;OpEqNull&gt;(newTemporary(), iterator.get()), asyncIteratorNotFound.get());
4564 
4565     emitJump(asyncIteratorFound.get());
4566     emitLabel(asyncIteratorNotFound.get());
4567 
4568     RefPtr&lt;RegisterID&gt; commonIterator = emitGetIterator(argument, node);
4569     move(iterator.get(), commonIterator.get());
4570 
4571     RefPtr&lt;RegisterID&gt; nextMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().next);
4572 
<span class="line-modified">4573     auto varCreateAsyncFromSyncIterator = variable(propertyNames().builtinNames().createAsyncFromSyncIteratorPrivateName());</span>
<span class="line-removed">4574     RefPtr&lt;RegisterID&gt; scope = newTemporary();</span>
<span class="line-removed">4575     move(scope.get(), emitResolveScope(scope.get(), varCreateAsyncFromSyncIterator));</span>
<span class="line-removed">4576     RefPtr&lt;RegisterID&gt; createAsyncFromSyncIterator = emitGetFromScope(newTemporary(), scope.get(), varCreateAsyncFromSyncIterator, ThrowIfNotFound);</span>
4577 
4578     CallArguments args(*this, nullptr, 2);
4579     emitLoad(args.thisRegister(), jsUndefined());
4580 
4581     move(args.argumentRegister(0), iterator.get());
4582     move(args.argumentRegister(1), nextMethod.get());
4583 
4584     JSTextPosition divot(m_scopeNode-&gt;firstLine(), m_scopeNode-&gt;startOffset(), m_scopeNode-&gt;lineStartOffset());
4585     emitCall(iterator.get(), createAsyncFromSyncIterator.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
4586 
4587     emitJump(iteratorReceived.get());
4588 
4589     emitLabel(asyncIteratorFound.get());
4590     emitCallIterator(iterator.get(), argument, node);
4591     emitLabel(iteratorReceived.get());
4592 
4593     return iterator.get();
4594 }
4595 
4596 RegisterID* BytecodeGenerator::emitDelegateYield(RegisterID* argument, ThrowableExpressionData* node)
4597 {
4598     RefPtr&lt;RegisterID&gt; value = newTemporary();
4599     {
4600         RefPtr&lt;RegisterID&gt; iterator = parseMode() == SourceParseMode::AsyncGeneratorBodyMode ? emitGetAsyncIterator(argument, node) : emitGetIterator(argument, node);
4601         RefPtr&lt;RegisterID&gt; nextMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().next);
4602 
4603         Ref&lt;Label&gt; loopDone = newLabel();
4604         {
4605             Ref&lt;Label&gt; nextElement = newLabel();
4606             emitLoad(value.get(), jsUndefined());
4607 
4608             emitJump(nextElement.get());
4609 
4610             Ref&lt;Label&gt; loopStart = newLabel();
4611             emitLabel(loopStart.get());
4612             emitLoopHint();
4613 
4614             Ref&lt;Label&gt; branchOnResult = newLabel();
4615             {
<span class="line-modified">4616                 emitYieldPoint(value.get(), JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Yield);</span>
4617 
4618                 Ref&lt;Label&gt; normalLabel = newLabel();
4619                 Ref&lt;Label&gt; returnLabel = newLabel();
4620                 {
4621                     RefPtr&lt;RegisterID&gt; condition = newTemporary();
<span class="line-modified">4622                     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::NormalMode))));</span>
4623                     emitJumpIfTrue(condition.get(), normalLabel.get());
4624 
<span class="line-modified">4625                     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::ReturnMode))));</span>
4626                     emitJumpIfTrue(condition.get(), returnLabel.get());
4627 
4628                     // Fallthrough to ThrowMode.
4629                 }
4630 
4631                 // Throw.
4632                 {
4633                     Ref&lt;Label&gt; throwMethodFound = newLabel();
4634                     RefPtr&lt;RegisterID&gt; throwMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().throwKeyword);
4635                     emitJumpIfFalse(emitIsUndefined(newTemporary(), throwMethod.get()), throwMethodFound.get());
4636 
4637                     EmitAwait emitAwaitInIteratorClose = parseMode() == SourceParseMode::AsyncGeneratorBodyMode ? EmitAwait::Yes : EmitAwait::No;
4638                     emitIteratorClose(iterator.get(), node, emitAwaitInIteratorClose);
4639 
4640                     emitThrowTypeError(&quot;Delegated generator does not have a &#39;throw&#39; method.&quot;_s);
4641 
4642                     emitLabel(throwMethodFound.get());
4643                     CallArguments throwArguments(*this, nullptr, 1);
4644                     move(throwArguments.thisRegister(), iterator.get());
4645                     move(throwArguments.argumentRegister(0), generatorValueRegister());
</pre>
<hr />
<pre>
4707             emitJumpIfTrue(emitIsObject(newTemporary(), value.get()), iteratorValueIsObject.get());
4708             emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
4709             emitLabel(iteratorValueIsObject.get());
4710 
4711             emitJumpIfTrue(emitGetById(newTemporary(), value.get(), propertyNames().done), loopDone.get());
4712             emitGetById(value.get(), value.get(), propertyNames().value);
4713 
4714             emitJump(loopStart.get());
4715         }
4716         emitLabel(loopDone.get());
4717     }
4718 
4719     emitGetById(value.get(), value.get(), propertyNames().value);
4720     return value.get();
4721 }
4722 
4723 
4724 void BytecodeGenerator::emitGeneratorStateChange(int32_t state)
4725 {
4726     RegisterID* completedState = emitLoad(nullptr, jsNumber(state));
<span class="line-modified">4727     emitPutById(generatorRegister(), propertyNames().builtinNames().generatorStatePrivateName(), completedState);</span>

4728 }
4729 
4730 bool BytecodeGenerator::emitJumpViaFinallyIfNeeded(int targetLabelScopeDepth, Label&amp; jumpTarget)
4731 {
4732     ASSERT(labelScopeDepth() - targetLabelScopeDepth &gt;= 0);
4733     size_t numberOfScopesToCheckForFinally = labelScopeDepth() - targetLabelScopeDepth;
4734     ASSERT(numberOfScopesToCheckForFinally &lt;= m_controlFlowScopeStack.size());
4735     if (!numberOfScopesToCheckForFinally)
4736         return false;
4737 
4738     FinallyContext* innermostFinallyContext = nullptr;
4739     FinallyContext* outermostFinallyContext = nullptr;
4740     size_t scopeIndex = m_controlFlowScopeStack.size() - 1;
4741     while (numberOfScopesToCheckForFinally--) {
4742         ControlFlowScope* scope = &amp;m_controlFlowScopeStack[scopeIndex--];
4743         if (scope-&gt;isFinallyScope()) {
4744             FinallyContext* finallyContext = scope-&gt;finallyContext;
4745             if (!innermostFinallyContext)
4746                 innermostFinallyContext = finallyContext;
4747             outermostFinallyContext = finallyContext;
</pre>
<hr />
<pre>
4965     emitLabel(m_optionalChainTargetStack.takeLast().get());
4966 }
4967 
4968 void BytecodeGenerator::popOptionalChainTarget(RegisterID* dst, bool isDelete)
4969 {
4970     Ref&lt;Label&gt; endLabel = newLabel();
4971     emitJump(endLabel.get());
4972 
4973     popOptionalChainTarget();
4974     emitLoad(dst, isDelete ? jsBoolean(true) : jsUndefined());
4975 
4976     emitLabel(endLabel.get());
4977 }
4978 
4979 void BytecodeGenerator::emitOptionalCheck(RegisterID* src)
4980 {
4981     ASSERT(m_optionalChainTargetStack.size());
4982     emitJumpIfTrue(emitIsUndefinedOrNull(newTemporary(), src), m_optionalChainTargetStack.last().get());
4983 }
4984 
<span class="line-modified">4985 void ForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)</span>
4986 {
4987     // Lexically invalidating ForInContexts is kind of weak sauce, but it only occurs if
4988     // either of the following conditions is true:
4989     //
4990     // (1) The loop iteration variable is re-assigned within the body of the loop.
4991     // (2) The loop iteration variable is captured in the lexical scope of the function.
4992     //
4993     // These two situations occur sufficiently rarely that it&#39;s okay to use this style of
4994     // &quot;analysis&quot; to make iteration faster. If we didn&#39;t want to do this, we would either have
4995     // to perform some flow-sensitive analysis to see if/when the loop iteration variable was
4996     // reassigned, or we&#39;d have to resort to runtime checks to see if the variable had been
4997     // reassigned from its original value.
4998 
4999     for (unsigned offset = bodyBytecodeStartOffset(); isValid() &amp;&amp; offset &lt; bodyBytecodeEndOffset;) {
5000         auto instruction = generator.instructions().at(offset);
<span class="line-modified">5001         OpcodeID opcodeID = instruction-&gt;opcodeID();</span>
<span class="line-modified">5002 </span>
<span class="line-removed">5003         ASSERT(opcodeID != op_enter);</span>
<span class="line-removed">5004         computeDefsForBytecodeOffset(codeBlock, opcodeID, instruction.ptr(), [&amp;] (VirtualRegister operand) {</span>
5005             if (local()-&gt;virtualRegister() == operand)
5006                 invalidate();
5007         });
5008         offset += instruction-&gt;size();
5009     }
5010 }
5011 
<span class="line-modified">5012 void StructureForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)</span>
5013 {
5014     Base::finalize(generator, codeBlock, bodyBytecodeEndOffset);
5015     if (isValid())
5016         return;
5017 
5018     OpcodeID lastOpcodeID = generator.m_lastOpcodeID;
5019     InstructionStream::MutableRef lastInstruction = generator.m_lastInstruction;
5020     for (const auto&amp; instTuple : m_getInsts) {
5021         unsigned instIndex = std::get&lt;0&gt;(instTuple);
5022         int propertyRegIndex = std::get&lt;1&gt;(instTuple);
5023         auto instruction = generator.m_writer.ref(instIndex);
5024         auto end = instIndex + instruction-&gt;size();
5025         ASSERT(instruction-&gt;isWide32());
5026 
5027         generator.m_writer.seek(instIndex);
5028 
5029         auto bytecode = instruction-&gt;as&lt;OpGetDirectPname&gt;();
5030 
5031         // disable peephole optimizations
5032         generator.m_lastOpcodeID = op_end;
5033 
5034         // Change the opcode to get_by_val.
5035         // 1. dst stays the same.
5036         // 2. base stays the same.
5037         // 3. property gets switched to the original property.
5038         OpGetByVal::emit&lt;OpcodeSize::Wide32&gt;(&amp;generator, bytecode.m_dst, bytecode.m_base, VirtualRegister(propertyRegIndex));
5039 
5040         // 4. nop out the remaining bytes
5041         while (generator.m_writer.position() &lt; end)
5042             OpNop::emit&lt;OpcodeSize::Narrow&gt;(&amp;generator);
5043     }
5044     generator.m_writer.seek(generator.m_writer.size());
5045     if (generator.m_lastInstruction.offset() + generator.m_lastInstruction-&gt;size() != generator.m_writer.size()) {
5046         generator.m_lastOpcodeID = lastOpcodeID;
5047         generator.m_lastInstruction = lastInstruction;
5048     }
5049 }
5050 
<span class="line-modified">5051 void IndexedForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)</span>
5052 {
5053     Base::finalize(generator, codeBlock, bodyBytecodeEndOffset);
5054     if (isValid())
5055         return;
5056 
5057     for (const auto&amp; instPair : m_getInsts) {
5058         unsigned instIndex = instPair.first;
5059         int propertyRegIndex = instPair.second;
5060         generator.m_writer.ref(instIndex)-&gt;cast&lt;OpGetByVal&gt;()-&gt;setProperty(VirtualRegister(propertyRegIndex), []() {
5061             ASSERT_NOT_REACHED();
5062             return VirtualRegister();
5063         });
5064     }
5065 }
5066 
5067 void StaticPropertyAnalysis::record()
5068 {
5069     auto* instruction = m_instructionRef.ptr();
5070     auto size = m_propertyIndexes.size();
5071     switch (instruction-&gt;opcodeID()) {
5072     case OpNewObject::opcodeID:
5073         instruction-&gt;cast&lt;OpNewObject&gt;()-&gt;setInlineCapacity(size, []() {
5074             return 255;
5075         });
5076         return;
5077     case OpCreateThis::opcodeID:
5078         instruction-&gt;cast&lt;OpCreateThis&gt;()-&gt;setInlineCapacity(size, []() {
5079             return 255;
5080         });
5081         return;
5082     default:
5083         ASSERT_NOT_REACHED();
5084     }
5085 }
5086 
5087 void BytecodeGenerator::emitToThis()
5088 {
5089     OpToThis::emit(this, kill(&amp;m_thisRegister));
<span class="line-removed">5090     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());</span>
5091 }
5092 
5093 } // namespace JSC
5094 
5095 namespace WTF {
5096 
5097 void printInternal(PrintStream&amp; out, JSC::Variable::VariableKind kind)
5098 {
5099     switch (kind) {
5100     case JSC::Variable::NormalVariable:
5101         out.print(&quot;Normal&quot;);
5102         return;
5103     case JSC::Variable::SpecialVariable:
5104         out.print(&quot;Special&quot;);
5105         return;
5106     }
5107     RELEASE_ASSERT_NOT_REACHED();
5108 }
5109 
5110 } // namespace WTF
</pre>
</td>
<td>
<hr />
<pre>
  17  *     from this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  23  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  26  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  28  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29  */
  30 
  31 #include &quot;config.h&quot;
  32 #include &quot;BytecodeGenerator.h&quot;
  33 
  34 #include &quot;ArithProfile.h&quot;
  35 #include &quot;BuiltinExecutables.h&quot;
  36 #include &quot;BuiltinNames.h&quot;
<span class="line-added">  37 #include &quot;BytecodeGeneratorBaseInlines.h&quot;</span>
  38 #include &quot;BytecodeGeneratorification.h&quot;
  39 #include &quot;BytecodeLivenessAnalysis.h&quot;

  40 #include &quot;BytecodeUseDef.h&quot;
  41 #include &quot;CatchScope.h&quot;
  42 #include &quot;DefinePropertyAttributes.h&quot;
  43 #include &quot;Interpreter.h&quot;
<span class="line-modified">  44 #include &quot;JSAsyncGenerator.h&quot;</span>
  45 #include &quot;JSBigInt.h&quot;
  46 #include &quot;JSCInlines.h&quot;

  47 #include &quot;JSFunction.h&quot;
  48 #include &quot;JSGeneratorFunction.h&quot;
  49 #include &quot;JSImmutableButterfly.h&quot;
  50 #include &quot;JSLexicalEnvironment.h&quot;
  51 #include &quot;JSTemplateObjectDescriptor.h&quot;
<span class="line-added">  52 #include &quot;LinkTimeConstant.h&quot;</span>
  53 #include &quot;LowLevelInterpreter.h&quot;
  54 #include &quot;Options.h&quot;
  55 #include &quot;PreciseJumpTargetsInlines.h&quot;
  56 #include &quot;StackAlignment.h&quot;
  57 #include &quot;StrongInlines.h&quot;
  58 #include &quot;SuperSamplerBytecodeScope.h&quot;
  59 #include &quot;UnlinkedCodeBlock.h&quot;
  60 #include &quot;UnlinkedEvalCodeBlock.h&quot;
  61 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
  62 #include &quot;UnlinkedMetadataTableInlines.h&quot;
  63 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
  64 #include &quot;UnlinkedProgramCodeBlock.h&quot;
  65 #include &lt;wtf/BitVector.h&gt;
  66 #include &lt;wtf/CommaPrinter.h&gt;
  67 #include &lt;wtf/Optional.h&gt;
  68 #include &lt;wtf/SmallPtrSet.h&gt;
  69 #include &lt;wtf/StdLibExtras.h&gt;
  70 #include &lt;wtf/text/WTFString.h&gt;
  71 
  72 namespace JSC {
  73 
  74 template&lt;typename CallOp, typename = std::true_type&gt;
  75 struct VarArgsOp;
  76 
  77 template&lt;typename CallOp&gt;
  78 struct VarArgsOp&lt;CallOp, std::enable_if_t&lt;std::is_same&lt;CallOp, OpTailCall&gt;::value, std::true_type&gt;&gt; {
  79     using type = OpTailCallVarargs;
  80 };
  81 
  82 
  83 template&lt;typename CallOp&gt;
  84 struct VarArgsOp&lt;CallOp, std::enable_if_t&lt;!std::is_same&lt;CallOp, OpTailCall&gt;::value, std::true_type&gt;&gt; {
  85     using type = OpCallVarargs;
  86 };
  87 
<span class="line-modified">  88 template&lt;&gt;</span>
<span class="line-modified">  89 void GenericLabel&lt;JSGeneratorTraits&gt;::setLocation(BytecodeGenerator&amp; generator, unsigned location)</span>







  90 {
  91     m_location = location;
  92 
  93     for (auto offset : m_unresolvedJumps) {
  94         auto instruction = generator.m_writer.ref(offset);
  95         int target = m_location - offset;
  96 
  97 #define CASE(__op) \
  98     case __op::opcodeID:  \
  99         instruction-&gt;cast&lt;__op&gt;()-&gt;setTargetLabel(BoundLabel(target), [&amp;]() { \
 100             generator.m_codeBlock-&gt;addOutOfLineJumpTarget(instruction.offset(), target); \
 101             return BoundLabel(); \
 102         }); \
 103         break;
 104 
 105         switch (instruction-&gt;opcodeID()) {
 106         CASE(OpJmp)
 107         CASE(OpJtrue)
 108         CASE(OpJfalse)
 109         CASE(OpJeqNull)
</pre>
<hr />
<pre>
 115         CASE(OpJneq)
 116         CASE(OpJneqPtr)
 117         CASE(OpJnstricteq)
 118         CASE(OpJless)
 119         CASE(OpJlesseq)
 120         CASE(OpJgreater)
 121         CASE(OpJgreatereq)
 122         CASE(OpJnless)
 123         CASE(OpJnlesseq)
 124         CASE(OpJngreater)
 125         CASE(OpJngreatereq)
 126         CASE(OpJbelow)
 127         CASE(OpJbeloweq)
 128         default:
 129             ASSERT_NOT_REACHED();
 130         }
 131 #undef CASE
 132     }
 133 }
 134 



































 135 void Variable::dump(PrintStream&amp; out) const
 136 {
 137     out.print(
 138         &quot;{ident = &quot;, m_ident,
 139         &quot;, offset = &quot;, m_offset,
 140         &quot;, local = &quot;, RawPointer(m_local),
 141         &quot;, attributes = &quot;, m_attributes,
 142         &quot;, kind = &quot;, m_kind,
 143         &quot;, symbolTableConstantIndex = &quot;, m_symbolTableConstantIndex,
 144         &quot;, isLexicallyScoped = &quot;, m_isLexicallyScoped, &quot;}&quot;);
 145 }
 146 
 147 FinallyContext::FinallyContext(BytecodeGenerator&amp; generator, Label&amp; finallyLabel)
 148     : m_outerContext(generator.m_currentFinallyContext)
 149     , m_finallyLabel(&amp;finallyLabel)
 150 {
 151     ASSERT(m_jumps.isEmpty());
 152     m_completionRecord.typeRegister = generator.newTemporary();
 153     m_completionRecord.valueRegister = generator.newTemporary();
 154     generator.emitLoad(completionTypeRegister(), CompletionType::Normal);
</pre>
<hr />
<pre>
 189                     //         {
 190                     //             let x;
 191                     //             {
 192                     //             //// error thrown here
 193                     //                  eval(&quot;function x(){}&quot;);
 194                     //             }
 195                     //         }
 196                     //     }
 197                     // ```
 198                     // Therefore, we&#39;re guaranteed to have this resolve to a top level variable.
 199                     RefPtr&lt;RegisterID&gt; tolLevelObjectScope = emitResolveScope(nullptr, Variable(metadata-&gt;ident()));
 200                     tolLevelScope = newBlockScopeVariable();
 201                     move(tolLevelScope.get(), tolLevelObjectScope.get());
 202                 }
 203                 emitPutToScope(tolLevelScope.get(), Variable(metadata-&gt;ident()), temp.get(), ThrowIfNotFound, InitializationMode::NotInitialization);
 204             } else
 205                 RELEASE_ASSERT_NOT_REACHED();
 206         }
 207     }
 208 
<span class="line-modified"> 209     bool callingClassConstructor = false;</span>
<span class="line-added"> 210     switch (constructorKind()) {</span>
<span class="line-added"> 211     case ConstructorKind::None:</span>
<span class="line-added"> 212     case ConstructorKind::Naked:</span>
<span class="line-added"> 213         break;</span>
<span class="line-added"> 214     case ConstructorKind::Base:</span>
<span class="line-added"> 215     case ConstructorKind::Extends:</span>
<span class="line-added"> 216         callingClassConstructor = !isConstructor();</span>
<span class="line-added"> 217         break;</span>
<span class="line-added"> 218     }</span>
 219     if (!callingClassConstructor)
 220         m_scopeNode-&gt;emitBytecode(*this);
 221     else {
 222         // At this point we would have emitted an unconditional throw followed by some nonsense that&#39;s
 223         // just an artifact of how this generator is structured. That code never runs, but it confuses
 224         // bytecode analyses because it constitutes an unterminated basic block. So, we terminate the
 225         // basic block the strongest way possible.
 226         emitUnreachable();
 227     }
 228 
 229     for (auto&amp; handler : m_exceptionHandlersToEmit) {
 230         Ref&lt;Label&gt; realCatchTarget = newLabel();
 231         TryData* tryData = handler.tryData;
 232 
 233         OpCatch::emit(this, handler.exceptionRegister, handler.thrownValueRegister);
 234         realCatchTarget-&gt;setLocation(*this, m_lastInstruction.offset());
 235         if (handler.completionTypeRegister.isValid()) {
 236             RegisterID completionTypeRegister { handler.completionTypeRegister };
 237             CompletionType completionType =
 238                 tryData-&gt;handlerType == HandlerType::Finally || tryData-&gt;handlerType == HandlerType::SynthesizedFinally
</pre>
<hr />
<pre>
 271         // but because we haven&#39;t yet had a chance to plant the catch target. Then when we finish
 272         // emitting code for the outer finally block, we repush the try contex, this time with a
 273         // new start index. But that means that the start index for the try range corresponding
 274         // to the inner-finally-following-the-return (marked as &quot;*HERE*&quot; above) will be greater
 275         // than the end index of the try block. This is harmless since end &lt; start handlers will
 276         // never get matched in our logic, but we do the runtime a favor and choose to not emit
 277         // such handlers at all.
 278         if (end &lt;= start)
 279             continue;
 280 
 281         UnlinkedHandlerInfo info(static_cast&lt;uint32_t&gt;(start), static_cast&lt;uint32_t&gt;(end),
 282             static_cast&lt;uint32_t&gt;(range.tryData-&gt;target-&gt;bind()), range.tryData-&gt;handlerType);
 283         m_codeBlock-&gt;addExceptionHandler(info);
 284     }
 285 
 286 
 287     if (isGeneratorOrAsyncFunctionBodyParseMode(m_codeBlock-&gt;parseMode()))
 288         performGeneratorification(*this, m_codeBlock.get(), m_writer, m_generatorFrameSymbolTable.get(), m_generatorFrameSymbolTableIndex);
 289 
 290     RELEASE_ASSERT(static_cast&lt;unsigned&gt;(m_codeBlock-&gt;numCalleeLocals()) &lt; static_cast&lt;unsigned&gt;(FirstConstantRegisterIndex));
<span class="line-modified"> 291     m_codeBlock-&gt;finalize(m_writer.finalize());</span>



 292     if (m_expressionTooDeep)
 293         return ParserError(ParserError::OutOfMemory);
 294     return ParserError(ParserError::ErrorNone);
 295 }
 296 
 297 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ProgramNode* programNode, UnlinkedProgramCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<span class="line-modified"> 298     : BytecodeGeneratorBase(makeUnique&lt;UnlinkedCodeBlockGenerator&gt;(vm, codeBlock), CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters())</span>
<span class="line-added"> 299     , m_codeGenerationMode(codeGenerationMode)</span>
 300     , m_scopeNode(programNode)

 301     , m_thisRegister(CallFrame::thisArgumentOffset())
 302     , m_codeType(GlobalCode)
 303     , m_vm(vm)
 304     , m_needsToUpdateArrowFunctionContext(programNode-&gt;usesArrowFunction() || programNode-&gt;usesEval())
 305 {
 306     ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
 307 





 308     m_codeBlock-&gt;setNumParameters(1); // Allocate space for &quot;this&quot;
 309 
 310     emitEnter();
 311 
 312     allocateAndEmitScope();
 313 
<span class="line-added"> 314     emitCheckTraps();</span>
<span class="line-added"> 315 </span>
 316     const FunctionStack&amp; functionStack = programNode-&gt;functionStack();
 317 
 318     for (auto* function : functionStack)
 319         m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
 320 
 321     if (Options::validateBytecode()) {
 322         for (auto&amp; entry : programNode-&gt;varDeclarations())
 323             RELEASE_ASSERT(entry.value.isVar());
 324     }
 325     codeBlock-&gt;setVariableDeclarations(programNode-&gt;varDeclarations());
 326     codeBlock-&gt;setLexicalDeclarations(programNode-&gt;lexicalVariables());
 327     // Even though this program may have lexical variables that go under TDZ, when linking the get_from_scope/put_to_scope
 328     // operations we emit we will have ResolveTypes that implictly do TDZ checks. Therefore, we don&#39;t need
 329     // additional TDZ checks on top of those. This is why we can omit pushing programNode-&gt;lexicalVariables()
 330     // to the TDZ stack.
 331 
 332     if (needsToUpdateArrowFunctionContext()) {
 333         initializeArrowFunctionContextScopeIfNeeded();
 334         emitPutThisToArrowFunctionContextScope();
 335     }
 336 }
 337 
 338 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, FunctionNode* functionNode, UnlinkedFunctionCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<span class="line-modified"> 339     : BytecodeGeneratorBase(makeUnique&lt;UnlinkedCodeBlockGenerator&gt;(vm, codeBlock), CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters())</span>
<span class="line-added"> 340     , m_codeGenerationMode(codeGenerationMode)</span>
 341     , m_scopeNode(functionNode)

 342     , m_codeType(FunctionCode)
 343     , m_vm(vm)
 344     , m_isBuiltinFunction(codeBlock-&gt;isBuiltinFunction())
 345     , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
 346     // FIXME: We should be able to have tail call elimination with the profiler
 347     // enabled. This is currently not possible because the profiler expects
 348     // op_will_call / op_did_call pairs before and after a call, which are not
 349     // compatible with tail calls (we have no way of emitting op_did_call).
 350     // https://bugs.webkit.org/show_bug.cgi?id=148819
<span class="line-added"> 351     //</span>
<span class="line-added"> 352     // Note that we intentionally enable tail call for naked constructors since it does not have special code for &quot;return&quot;.</span>
 353     , m_inTailPosition(Options::useTailCalls() &amp;&amp; !isConstructor() &amp;&amp; constructorKind() == ConstructorKind::None &amp;&amp; isStrictMode())
 354     , m_needsToUpdateArrowFunctionContext(functionNode-&gt;usesArrowFunction() || functionNode-&gt;usesEval())
 355     , m_derivedContextType(codeBlock-&gt;derivedContextType())
 356 {





 357     SymbolTable* functionSymbolTable = SymbolTable::create(m_vm);
 358     functionSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
 359     int symbolTableConstantIndex = 0;
 360 
 361     FunctionParameters&amp; parameters = *functionNode-&gt;parameters();
 362     // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-functiondeclarationinstantiation
 363     // This implements IsSimpleParameterList in the Ecma 2015 spec.
 364     // If IsSimpleParameterList is false, we will create a strict-mode like arguments object.
 365     // IsSimpleParameterList is false if the argument list contains any default parameter values,
 366     // a rest parameter, or any destructuring patterns.
 367     // If we do have default parameters, destructuring parameters, or a rest parameter, our parameters will be allocated in a different scope.
 368     bool isSimpleParameterList = parameters.isSimpleParameterList();
 369 
 370     SourceParseMode parseMode = codeBlock-&gt;parseMode();
 371 
 372     bool containsArrowOrEvalButNotInArrowBlock = ((functionNode-&gt;usesArrowFunction() &amp;&amp; functionNode-&gt;doAnyInnerArrowFunctionsUseAnyFeature()) || functionNode-&gt;usesEval()) &amp;&amp; !m_codeBlock-&gt;isArrowFunction();
 373     bool shouldCaptureSomeOfTheThings = shouldEmitDebugHooks() || functionNode-&gt;needsActivation() || containsArrowOrEvalButNotInArrowBlock;
 374 
 375     bool shouldCaptureAllOfTheThings = shouldEmitDebugHooks() || codeBlock-&gt;usesEval();
<span class="line-modified"> 376     bool needsArguments = ((functionNode-&gt;usesArguments() &amp;&amp; !codeBlock-&gt;isArrowFunction()) || codeBlock-&gt;usesEval() || (functionNode-&gt;usesArrowFunction() &amp;&amp; !codeBlock-&gt;isArrowFunction() &amp;&amp; isArgumentsUsedInInnerArrowFunction())) &amp;&amp; parseMode != SourceParseMode::InstanceFieldInitializerMode;</span>
 377 
 378     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
 379         // Generator and AsyncFunction never provides &quot;arguments&quot;. &quot;arguments&quot; reference will be resolved in an upper generator function scope.
 380         needsArguments = false;
 381     }
 382 
 383     if (isGeneratorOrAsyncFunctionWrapperParseMode(parseMode) &amp;&amp; needsArguments) {
 384         // Generator does not provide &quot;arguments&quot;. Instead, wrapping GeneratorFunction provides &quot;arguments&quot;.
 385         // This is because arguments of a generator should be evaluated before starting it.
 386         // To workaround it, we evaluate these arguments as arguments of a wrapping generator function, and reference it from a generator.
 387         //
 388         //    function *gen(a, b = hello())
 389         //    {
 390         //        return {
 391         //            @generatorNext: function (@generator, @generatorState, @generatorValue, @generatorResumeMode, @generatorFrame)
 392         //            {
 393         //                arguments;  // This `arguments` should reference to the gen&#39;s arguments.
 394         //                ...
 395         //            }
 396         //        }
</pre>
<hr />
<pre>
 412             return true;
 413         }
 414         return functionNode-&gt;captures(uid);
 415     });
 416     auto varKind = [&amp;] (UniquedStringImpl* uid) -&gt; VarKind {
 417         return captures(uid) ? VarKind::Scope : VarKind::Stack;
 418     };
 419 
 420     m_calleeRegister.setIndex(CallFrameSlot::callee);
 421 
 422     initializeParameters(parameters);
 423     ASSERT(!(isSimpleParameterList &amp;&amp; m_restParameter));
 424 
 425     emitEnter();
 426 
 427     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode))
 428         m_generatorRegister = &amp;m_parameters[1];
 429 
 430     allocateAndEmitScope();
 431 
<span class="line-added"> 432     emitCheckTraps();</span>
<span class="line-added"> 433 </span>
 434     if (functionNameIsInScope(functionNode-&gt;ident(), functionNode-&gt;functionMode())) {
 435         ASSERT(parseMode != SourceParseMode::GeneratorBodyMode);
 436         ASSERT(!isAsyncFunctionBodyParseMode(parseMode));
 437         bool isDynamicScope = functionNameScopeIsDynamic(codeBlock-&gt;usesEval(), codeBlock-&gt;isStrictMode());
 438         bool isFunctionNameCaptured = captures(functionNode-&gt;ident().impl());
 439         bool markAsCaptured = isDynamicScope || isFunctionNameCaptured;
 440         emitPushFunctionNameScope(functionNode-&gt;ident(), &amp;m_calleeRegister, markAsCaptured);
 441     }
 442 
 443     if (shouldCaptureSomeOfTheThings)
 444         m_lexicalEnvironmentRegister = addVar();
 445 
 446     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode) || shouldCaptureSomeOfTheThings || shouldEmitTypeProfilerHooks())
 447         symbolTableConstantIndex = addConstantValue(functionSymbolTable)-&gt;index();
 448 
 449     // We can allocate the &quot;var&quot; environment if we don&#39;t have default parameter expressions. If we have
 450     // default parameter expressions, we have to hold off on allocating the &quot;var&quot; environment because
 451     // the parent scope of the &quot;var&quot; environment is the parameter environment.
 452     if (isSimpleParameterList)
 453         initializeVarLexicalEnvironment(symbolTableConstantIndex, functionSymbolTable, shouldCaptureSomeOfTheThings);
</pre>
<hr />
<pre>
 492         if (capturesAnyArgumentByName) {
 493             functionSymbolTable-&gt;setArgumentsLength(vm, parameters.size());
 494 
 495             // For each parameter, we have two possibilities:
 496             // Either it&#39;s a binding node with no function overlap, in which case it gets a name
 497             // in the symbol table - or it just gets space reserved in the symbol table. Either
 498             // way we lift the value into the scope.
 499             for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 500                 ScopeOffset offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
 501                 functionSymbolTable-&gt;setArgumentOffset(vm, i, offset);
 502                 if (UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first)) {
 503                     VarOffset varOffset(offset);
 504                     SymbolTableEntry entry(varOffset);
 505                     // Stores to these variables via the ScopedArguments object will not do
 506                     // notifyWrite(), since that would be cumbersome. Also, watching formal
 507                     // parameters when &quot;arguments&quot; is in play is unlikely to be super profitable.
 508                     // So, we just disable it.
 509                     entry.disableWatching(m_vm);
 510                     functionSymbolTable-&gt;set(NoLockingNecessary, name, entry);
 511                 }
<span class="line-modified"> 512                 OpPutToScope::emit(this, m_lexicalEnvironmentRegister, UINT_MAX, virtualRegisterForArgumentIncludingThis(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), SymbolTableOrScopeDepth::symbolTable(VirtualRegister { symbolTableConstantIndex }), offset.offset());</span>
 513             }
 514 
 515             // This creates a scoped arguments object and copies the overflow arguments into the
 516             // scope. It&#39;s the equivalent of calling ScopedArguments::createByCopying().
 517             OpCreateScopedArguments::emit(this, m_argumentsRegister, m_lexicalEnvironmentRegister);
 518         } else {
 519             // We&#39;re going to put all parameters into the DirectArguments object. First ensure
 520             // that the symbol table knows that this is happening.
 521             for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 522                 if (UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first))
 523                     functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(DirectArgumentsOffset(i))));
 524             }
 525 
 526             OpCreateDirectArguments::emit(this, m_argumentsRegister);
 527         }
 528     } else if (isSimpleParameterList) {
 529         // Create the formal parameters the normal way. Any of them could be captured, or not. If
 530         // captured, lift them into the scope. We cannot do this if we have default parameter expressions
 531         // because when default parameter expressions exist, they belong in their own lexical environment
 532         // separate from the &quot;var&quot; lexical environment.
 533         for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 534             UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first);
 535             if (!name)
 536                 continue;
 537 
 538             if (!captures(name)) {
 539                 // This is the easy case - just tell the symbol table about the argument. It will
 540                 // be accessed directly.
<span class="line-modified"> 541                 functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(virtualRegisterForArgumentIncludingThis(1 + i))));</span>
 542                 continue;
 543             }
 544 
 545             ScopeOffset offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
 546             const Identifier&amp; ident =
 547                 static_cast&lt;const BindingNode*&gt;(parameters.at(i).first)-&gt;boundProperty();
 548             functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(offset)));
 549 
<span class="line-modified"> 550             OpPutToScope::emit(this, m_lexicalEnvironmentRegister, addConstant(ident), virtualRegisterForArgumentIncludingThis(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), SymbolTableOrScopeDepth::symbolTable(VirtualRegister { symbolTableConstantIndex }), offset.offset());</span>
 551         }
 552     }
 553 
 554     if (needsArguments &amp;&amp; (codeBlock-&gt;isStrictMode() || !isSimpleParameterList)) {
 555         // Allocate a cloned arguments object.
 556         OpCreateClonedArguments::emit(this, m_argumentsRegister);
 557     }
 558 
 559     // There are some variables that need to be preinitialized to something other than Undefined:
 560     //
 561     // - &quot;arguments&quot;: unless it&#39;s used as a function or parameter, this should refer to the
 562     //   arguments object.
 563     //
 564     // - functions: these always override everything else.
 565     //
 566     // The most logical way to do all of this is to initialize none of the variables until now,
 567     // and then initialize them in BytecodeGenerator::generate() in such an order that the rules
 568     // for how these things override each other end up holding. We would initialize &quot;arguments&quot; first,
 569     // then all arguments, then the functions.
 570     //
</pre>
<hr />
<pre>
 580     bool shouldCreateArgumentsVariableInParameterScope = false;
 581     if (needsArguments) {
 582         // If &quot;arguments&quot; is overridden by a function or destructuring parameter name, then it&#39;s
 583         // OK for us to call createVariable() because it won&#39;t change anything. It&#39;s also OK for
 584         // us to them tell BytecodeGenerator::generate() to write to it because it will do so
 585         // before it initializes functions and destructuring parameters. But if &quot;arguments&quot; is
 586         // overridden by a &quot;simple&quot; function parameter, then we have to bail: createVariable()
 587         // would assert and BytecodeGenerator::generate() would write the &quot;arguments&quot; after the
 588         // argument value had already been properly initialized.
 589 
 590         bool haveParameterNamedArguments = false;
 591         for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 592             UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first);
 593             if (name == propertyNames().arguments.impl()) {
 594                 haveParameterNamedArguments = true;
 595                 break;
 596             }
 597         }
 598 
 599         bool shouldCreateArgumensVariable = !haveParameterNamedArguments
<span class="line-modified"> 600             &amp;&amp; !SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode, SourceParseMode::InstanceFieldInitializerMode).contains(m_codeBlock-&gt;parseMode());</span>
 601         shouldCreateArgumentsVariableInParameterScope = shouldCreateArgumensVariable &amp;&amp; !isSimpleParameterList;
 602         // Do not create arguments variable in case of Arrow function. Value will be loaded from parent scope
 603         if (shouldCreateArgumensVariable &amp;&amp; !shouldCreateArgumentsVariableInParameterScope) {
 604             createVariable(
 605                 propertyNames().arguments, varKind(propertyNames().arguments.impl()), functionSymbolTable);
 606 
 607             m_needToInitializeArguments = true;
 608         }
 609     }
 610 
 611     for (FunctionMetadataNode* function : functionNode-&gt;functionStack()) {
 612         const Identifier&amp; ident = function-&gt;ident();
 613         createVariable(ident, varKind(ident.impl()), functionSymbolTable);
 614         m_functionsToInitialize.append(std::make_pair(function, NormalFunctionVariable));
 615     }
 616     for (auto&amp; entry : functionNode-&gt;varDeclarations()) {
 617         ASSERT(!entry.value.isLet() &amp;&amp; !entry.value.isConst());
 618         if (!entry.value.isVar()) // This is either a parameter or callee.
 619             continue;
 620         if (shouldCreateArgumentsVariableInParameterScope &amp;&amp; entry.key.get() == propertyNames().arguments.impl())
 621             continue;
 622         createVariable(Identifier::fromUid(m_vm, entry.key.get()), varKind(entry.key.get()), functionSymbolTable, IgnoreExisting);
 623     }
 624 
 625 
 626     if (functionNode-&gt;needsNewTargetRegisterForThisScope() || isNewTargetUsedInInnerArrowFunction() || codeBlock-&gt;usesEval())
 627         m_newTargetRegister = addVar();
 628 
 629     switch (parseMode) {
 630     case SourceParseMode::GeneratorWrapperFunctionMode:
<span class="line-modified"> 631     case SourceParseMode::GeneratorWrapperMethodMode: {</span>
<span class="line-added"> 632         m_generatorRegister = addVar();</span>
<span class="line-added"> 633 </span>
<span class="line-added"> 634         // FIXME: Emit to_this only when Generator uses it.</span>
<span class="line-added"> 635         // https://bugs.webkit.org/show_bug.cgi?id=151586</span>
<span class="line-added"> 636         emitToThis();</span>
<span class="line-added"> 637 </span>
<span class="line-added"> 638         emitCreateGenerator(m_generatorRegister, &amp;m_calleeRegister);</span>
<span class="line-added"> 639         break;</span>
<span class="line-added"> 640     }</span>
<span class="line-added"> 641 </span>
 642     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
 643     case SourceParseMode::AsyncGeneratorWrapperFunctionMode: {
 644         m_generatorRegister = addVar();
 645 
 646         // FIXME: Emit to_this only when Generator uses it.
 647         // https://bugs.webkit.org/show_bug.cgi?id=151586
 648         emitToThis();
 649 
<span class="line-modified"> 650         emitCreateAsyncGenerator(m_generatorRegister, &amp;m_calleeRegister);</span>

 651         break;
 652     }
 653 
 654     case SourceParseMode::AsyncArrowFunctionMode:
 655     case SourceParseMode::AsyncMethodMode:
 656     case SourceParseMode::AsyncFunctionMode: {
 657         ASSERT(!isConstructor());
 658         ASSERT(constructorKind() == ConstructorKind::None);
 659         m_generatorRegister = addVar();
<span class="line-modified"> 660         m_promiseRegister = addVar();</span>
 661 
 662         if (parseMode != SourceParseMode::AsyncArrowFunctionMode) {
 663             // FIXME: Emit to_this only when AsyncFunctionBody uses it.
 664             // https://bugs.webkit.org/show_bug.cgi?id=151586
 665             emitToThis();
 666         }
 667 
<span class="line-modified"> 668         emitNewGenerator(m_generatorRegister);</span>
<span class="line-modified"> 669         emitNewPromise(promiseRegister(), m_isBuiltinFunction);</span>

















 670         break;
 671     }
 672 
 673     case SourceParseMode::AsyncGeneratorBodyMode:
 674     case SourceParseMode::AsyncFunctionBodyMode:
 675     case SourceParseMode::AsyncArrowFunctionBodyMode:
 676     case SourceParseMode::GeneratorBodyMode: {
 677         // |this| is already filled correctly before here.
 678         if (m_newTargetRegister)
 679             emitLoad(m_newTargetRegister, jsUndefined());
 680         break;
 681     }
 682 
 683     default: {
 684         if (SourceParseMode::ArrowFunctionMode != parseMode) {
 685             if (isConstructor()) {
 686                 if (m_newTargetRegister)
 687                     move(m_newTargetRegister, &amp;m_thisRegister);
<span class="line-modified"> 688                 switch (constructorKind()) {</span>
<span class="line-modified"> 689                 case ConstructorKind::Naked:</span>
<span class="line-modified"> 690                     // Naked constructor not create |this| automatically.</span>
<span class="line-added"> 691                     break;</span>
<span class="line-added"> 692                 case ConstructorKind::None:</span>
<span class="line-added"> 693                 case ConstructorKind::Base:</span>
 694                     emitCreateThis(&amp;m_thisRegister);
<span class="line-modified"> 695                     if (Options::useClassFields())</span>
<span class="line-modified"> 696                         emitInstanceFieldInitializationIfNeeded(&amp;m_thisRegister, &amp;m_calleeRegister, m_scopeNode-&gt;position(), m_scopeNode-&gt;position(), m_scopeNode-&gt;position());</span>
<span class="line-modified"> 697                     break;</span>
<span class="line-modified"> 698                 case ConstructorKind::Extends:</span>
<span class="line-modified"> 699                     moveEmptyValue(&amp;m_thisRegister);</span>
<span class="line-modified"> 700                     break;</span>
<span class="line-modified"> 701                 }</span>
<span class="line-modified"> 702             } else {</span>
<span class="line-modified"> 703                 switch (constructorKind()) {</span>
<span class="line-modified"> 704                 case ConstructorKind::None: {</span>
<span class="line-modified"> 705                     bool shouldEmitToThis = false;</span>
<span class="line-modified"> 706                     if (functionNode-&gt;usesThis() || codeBlock-&gt;usesEval() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseThis() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval())</span>
<span class="line-modified"> 707                         shouldEmitToThis = true;</span>
<span class="line-modified"> 708                     else if ((functionNode-&gt;usesSuperProperty() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperProperty()) &amp;&amp; !codeBlock-&gt;isStrictMode()) {</span>
<span class="line-modified"> 709                         // We must emit to_this when we&#39;re not in strict mode because we</span>
<span class="line-modified"> 710                         // will convert |this| to an object, and that object may be passed</span>
<span class="line-modified"> 711                         // to a strict function as |this|. This is observable because that</span>
<span class="line-modified"> 712                         // strict function&#39;s to_this will just return the object.</span>
<span class="line-modified"> 713                         //</span>
<span class="line-added"> 714                         // We don&#39;t need to emit this for strict-mode code because</span>
<span class="line-added"> 715                         // strict-mode code may call another strict function, which will</span>
<span class="line-added"> 716                         // to_this if it directly uses this; this is OK, because we defer</span>
<span class="line-added"> 717                         // to_this until |this| is used directly. Strict-mode code might</span>
<span class="line-added"> 718                         // also call a sloppy mode function, and that will to_this, which</span>
<span class="line-added"> 719                         // will defer the conversion, again, until necessary.</span>
<span class="line-added"> 720                         shouldEmitToThis = true;</span>
<span class="line-added"> 721                     }</span>
<span class="line-added"> 722 </span>
<span class="line-added"> 723                     if (shouldEmitToThis)</span>
<span class="line-added"> 724                         emitToThis();</span>
<span class="line-added"> 725                     break;</span>
<span class="line-added"> 726                 }</span>
<span class="line-added"> 727                 case ConstructorKind::Naked:</span>
<span class="line-added"> 728                     emitThrowTypeError(&quot;Cannot call a constructor without |new|&quot;);</span>
<span class="line-added"> 729                     break;</span>
<span class="line-added"> 730                 case ConstructorKind::Base:</span>
<span class="line-added"> 731                 case ConstructorKind::Extends:</span>
<span class="line-added"> 732                     emitThrowTypeError(&quot;Cannot call a class constructor without |new|&quot;);</span>
<span class="line-added"> 733                     break;</span>
 734                 }



 735             }
 736         }
 737         break;
 738     }
 739     }
 740 
 741     // We need load |super| &amp; |this| for arrow function before initializeDefaultParameterValuesAndSetupFunctionScopeStack
 742     // if we have default parameter expression. Because |super| &amp; |this| values can be used there
 743     if ((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; !isSimpleParameterList) || parseMode == SourceParseMode::AsyncArrowFunctionBodyMode) {
 744         if (functionNode-&gt;usesThis() || functionNode-&gt;usesSuperProperty())
 745             emitLoadThisFromArrowFunctionLexicalEnvironment();
 746 
 747         if (m_scopeNode-&gt;needsNewTargetRegisterForThisScope())
 748             emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 749     }
 750 
 751     if (needsToUpdateArrowFunctionContext() &amp;&amp; !codeBlock-&gt;isArrowFunction()) {
 752         bool canReuseLexicalEnvironment = isSimpleParameterList;
 753         initializeArrowFunctionContextScopeIfNeeded(functionSymbolTable, canReuseLexicalEnvironment);
 754         emitPutThisToArrowFunctionContextScope();
</pre>
<hr />
<pre>
 762 
 763     Ref&lt;Label&gt; catchLabel = newLabel();
 764     TryData* tryFormalParametersData = nullptr;
 765     bool needTryCatch = isAsyncFunctionWrapperParseMode(parseMode) &amp;&amp; !isSimpleParameterList;
 766     if (needTryCatch) {
 767         Ref&lt;Label&gt; tryFormalParametersStart = newEmittedLabel();
 768         tryFormalParametersData = pushTry(tryFormalParametersStart.get(), catchLabel.get(), HandlerType::SynthesizedCatch);
 769     }
 770 
 771     initializeDefaultParameterValuesAndSetupFunctionScopeStack(parameters, isSimpleParameterList, functionNode, functionSymbolTable, symbolTableConstantIndex, captures, shouldCreateArgumentsVariableInParameterScope);
 772 
 773     if (needTryCatch) {
 774         Ref&lt;Label&gt; didNotThrow = newLabel();
 775         emitJump(didNotThrow.get());
 776         emitLabel(catchLabel.get());
 777         popTry(tryFormalParametersData, catchLabel.get());
 778 
 779         RefPtr&lt;RegisterID&gt; thrownValue = newTemporary();
 780         emitOutOfLineCatchHandler(thrownValue.get(), nullptr, tryFormalParametersData);
 781 
<span class="line-modified"> 782         // @rejectPromiseWithFirstResolvingFunctionCallCheck(@promise, thrownValue);</span>
<span class="line-modified"> 783         // return @promise;</span>
<span class="line-modified"> 784         RefPtr&lt;RegisterID&gt; rejectPromise = moveLinkTimeConstant(nullptr, LinkTimeConstant::rejectPromiseWithFirstResolvingFunctionCallCheck);</span>
<span class="line-modified"> 785         CallArguments args(*this, nullptr, 2);</span>
 786         emitLoad(args.thisRegister(), jsUndefined());
<span class="line-modified"> 787         move(args.argumentRegister(0), promiseRegister());</span>
<span class="line-modified"> 788         move(args.argumentRegister(1), thrownValue.get());</span>
 789         JSTextPosition divot(functionNode-&gt;firstLine(), functionNode-&gt;startOffset(), functionNode-&gt;lineStartOffset());
<span class="line-added"> 790         emitCall(newTemporary(), rejectPromise.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);</span>
 791 
<span class="line-modified"> 792         emitReturn(promiseRegister());</span>


 793         emitLabel(didNotThrow.get());
 794     }
 795 
 796     // If we don&#39;t have  default parameter expression, then loading |this| inside an arrow function must be done
 797     // after initializeDefaultParameterValuesAndSetupFunctionScopeStack() because that function sets up the
 798     // SymbolTable stack and emitLoadThisFromArrowFunctionLexicalEnvironment() consults the SymbolTable stack
 799     if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; isSimpleParameterList) {
 800         if (functionNode-&gt;usesThis() || functionNode-&gt;usesSuperProperty())
 801             emitLoadThisFromArrowFunctionLexicalEnvironment();
 802 
 803         if (m_scopeNode-&gt;needsNewTargetRegisterForThisScope())
 804             emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 805     }
 806 
 807     // Set up the lexical environment scope as the generator frame. We store the saved and resumed generator registers into this scope with the symbol keys.
 808     // Since they are symbol keyed, these variables cannot be reached from the usual code.
 809     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
 810         m_generatorFrameSymbolTable.set(m_vm, functionSymbolTable);
 811         m_generatorFrameSymbolTableIndex = symbolTableConstantIndex;
 812         if (m_lexicalEnvironmentRegister)
 813             move(generatorFrameRegister(), m_lexicalEnvironmentRegister);
 814         else {
 815             // It would be possible that generator does not need to suspend and resume any registers.
 816             // In this case, we would like to avoid creating a lexical environment as much as possible.
 817             // op_create_generator_frame_environment is a marker, which is similar to op_yield.
 818             // Generatorification inserts lexical environment creation if necessary. Otherwise, we convert it to op_mov frame, `undefined`.
 819             OpCreateGeneratorFrameEnvironment::emit(this, generatorFrameRegister(), scopeRegister(), VirtualRegister { symbolTableConstantIndex }, addConstantValue(jsUndefined()));
 820         }
<span class="line-modified"> 821         static_assert(static_cast&lt;unsigned&gt;(JSGenerator::Field::Frame) == static_cast&lt;unsigned&gt;(JSAsyncGenerator::Field::Frame));</span>
<span class="line-added"> 822         emitPutInternalField(generatorRegister(), static_cast&lt;unsigned&gt;(JSGenerator::Field::Frame), generatorFrameRegister());</span>
 823     }
 824 
 825     bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
 826     pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
 827 }
 828 
 829 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, EvalNode* evalNode, UnlinkedEvalCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<span class="line-modified"> 830     : BytecodeGeneratorBase(makeUnique&lt;UnlinkedCodeBlockGenerator&gt;(vm, codeBlock), CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters())</span>
<span class="line-added"> 831     , m_codeGenerationMode(codeGenerationMode)</span>
 832     , m_scopeNode(evalNode)

 833     , m_thisRegister(CallFrame::thisArgumentOffset())
 834     , m_codeType(EvalCode)
 835     , m_vm(vm)
 836     , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
 837     , m_needsToUpdateArrowFunctionContext(evalNode-&gt;usesArrowFunction() || evalNode-&gt;usesEval())
 838     , m_derivedContextType(codeBlock-&gt;derivedContextType())
 839 {





 840     m_codeBlock-&gt;setNumParameters(1);
 841 
 842     pushTDZVariables(*parentScopeTDZVariables, TDZCheckOptimization::DoNotOptimize, TDZRequirement::UnderTDZ);
 843 
 844     emitEnter();
 845 
 846     allocateAndEmitScope();
 847 
<span class="line-added"> 848     emitCheckTraps();</span>
<span class="line-added"> 849 </span>
 850     for (FunctionMetadataNode* function : evalNode-&gt;functionStack()) {
 851         m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
 852         m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
 853     }
 854 
 855     const VariableEnvironment&amp; varDeclarations = evalNode-&gt;varDeclarations();
 856     Vector&lt;Identifier, 0, UnsafeVectorOverflow&gt; variables;
 857     Vector&lt;Identifier, 0, UnsafeVectorOverflow&gt; hoistedFunctions;
 858     for (auto&amp; entry : varDeclarations) {
 859         ASSERT(entry.value.isVar());
 860         ASSERT(entry.key-&gt;isAtom() || entry.key-&gt;isSymbol());
 861         if (entry.value.isSloppyModeHoistingCandidate())
 862             hoistedFunctions.append(Identifier::fromUid(m_vm, entry.key.get()));
 863         else
 864             variables.append(Identifier::fromUid(m_vm, entry.key.get()));
 865     }
 866     codeBlock-&gt;adoptVariables(variables);
 867     codeBlock-&gt;adoptFunctionHoistingCandidates(WTFMove(hoistedFunctions));
 868 
 869     if (evalNode-&gt;needsNewTargetRegisterForThisScope())
 870         m_newTargetRegister = addVar();
 871 
 872     if (codeBlock-&gt;isArrowFunctionContext() &amp;&amp; (evalNode-&gt;usesThis() || evalNode-&gt;usesSuperProperty()))
 873         emitLoadThisFromArrowFunctionLexicalEnvironment();
 874 
 875     if (evalNode-&gt;needsNewTargetRegisterForThisScope())
 876         emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 877 
 878     if (needsToUpdateArrowFunctionContext() &amp;&amp; !codeBlock-&gt;isArrowFunctionContext() &amp;&amp; !isDerivedConstructorContext()) {
 879         initializeArrowFunctionContextScopeIfNeeded();
 880         emitPutThisToArrowFunctionContextScope();
 881     }
 882 
 883     bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
 884     pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
 885 }
 886 
 887 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ModuleProgramNode* moduleProgramNode, UnlinkedModuleProgramCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<span class="line-modified"> 888     : BytecodeGeneratorBase(makeUnique&lt;UnlinkedCodeBlockGenerator&gt;(vm, codeBlock), CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters())</span>
<span class="line-added"> 889     , m_codeGenerationMode(codeGenerationMode)</span>
 890     , m_scopeNode(moduleProgramNode)

 891     , m_thisRegister(CallFrame::thisArgumentOffset())
 892     , m_codeType(ModuleCode)
 893     , m_vm(vm)
 894     , m_usesNonStrictEval(false)
 895     , m_needsToUpdateArrowFunctionContext(moduleProgramNode-&gt;usesArrowFunction() || moduleProgramNode-&gt;usesEval())
 896 {
 897     ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
 898 





 899     SymbolTable* moduleEnvironmentSymbolTable = SymbolTable::create(m_vm);
 900     moduleEnvironmentSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
 901     moduleEnvironmentSymbolTable-&gt;setScopeType(SymbolTable::ScopeType::LexicalScope);
 902 
 903     bool shouldCaptureAllOfTheThings = shouldEmitDebugHooks() || codeBlock-&gt;usesEval();
 904     if (shouldCaptureAllOfTheThings)
 905         moduleProgramNode-&gt;varDeclarations().markAllVariablesAsCaptured();
 906 
 907     auto captures = [&amp;] (UniquedStringImpl* uid) -&gt; bool {
 908         return moduleProgramNode-&gt;captures(uid);
 909     };
 910     auto lookUpVarKind = [&amp;] (UniquedStringImpl* uid, const VariableEnvironmentEntry&amp; entry) -&gt; VarKind {
 911         // Allocate the exported variables in the module environment.
 912         if (entry.isExported())
 913             return VarKind::Scope;
 914 
 915         // Allocate the namespace variables in the module environment to instantiate
 916         // it from the outside of the module code.
 917         if (entry.isImportedNamespace())
 918             return VarKind::Scope;
 919 
 920         if (entry.isCaptured())
 921             return VarKind::Scope;
 922         return captures(uid) ? VarKind::Scope : VarKind::Stack;
 923     };
 924 
 925     emitEnter();
 926 
 927     allocateAndEmitScope();
 928 
<span class="line-added"> 929     emitCheckTraps();</span>
<span class="line-added"> 930 </span>
 931     m_calleeRegister.setIndex(CallFrameSlot::callee);
 932 
 933     m_codeBlock-&gt;setNumParameters(1); // Allocate space for &quot;this&quot;
 934 
 935     // Now declare all variables.
 936 
 937     createVariable(m_vm.propertyNames-&gt;builtinNames().metaPrivateName(), VarKind::Scope, moduleEnvironmentSymbolTable, VerifyExisting);
 938 
 939     for (auto&amp; entry : moduleProgramNode-&gt;varDeclarations()) {
 940         ASSERT(!entry.value.isLet() &amp;&amp; !entry.value.isConst());
 941         if (!entry.value.isVar()) // This is either a parameter or callee.
 942             continue;
 943         // Imported bindings are not allocated in the module environment as usual variables&#39; way.
 944         // These references remain the &quot;Dynamic&quot; in the unlinked code block. Later, when linking
 945         // the code block, we resolve the reference to the &quot;ModuleVar&quot;.
 946         if (entry.value.isImported() &amp;&amp; !entry.value.isImportedNamespace())
 947             continue;
 948         createVariable(Identifier::fromUid(m_vm, entry.key.get()), lookUpVarKind(entry.key.get(), entry.value), moduleEnvironmentSymbolTable, IgnoreExisting);
 949     }
 950 
</pre>
<hr />
<pre>
1166     }
1167 
1168     if (needsDerivedConstructorInArrowFunctionLexicalEnvironment()) {
1169         auto derivedConstructor = environment.add(propertyNames().builtinNames().derivedConstructorPrivateName());
1170         derivedConstructor.iterator-&gt;value.setIsCaptured();
1171         derivedConstructor.iterator-&gt;value.setIsLet();
1172     }
1173 
1174     if (environment.size() &gt; 0) {
1175         size_t size = m_lexicalScopeStack.size();
1176         pushLexicalScopeInternal(environment, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, TDZRequirement::UnderTDZ, ScopeType::LetConstScope, ScopeRegisterType::Block);
1177 
1178         ASSERT_UNUSED(size, m_lexicalScopeStack.size() == size + 1);
1179 
1180         m_arrowFunctionContextLexicalEnvironmentRegister = m_lexicalScopeStack.last().m_scope;
1181     }
1182 }
1183 
1184 RegisterID* BytecodeGenerator::initializeNextParameter()
1185 {
<span class="line-modified">1186     VirtualRegister reg = virtualRegisterForArgumentIncludingThis(m_codeBlock-&gt;numParameters());</span>
1187     m_parameters.grow(m_parameters.size() + 1);
1188     auto&amp; parameter = registerFor(reg);
<span class="line-modified">1189     parameter.setIndex(reg);</span>
<span class="line-modified">1190     m_codeBlock-&gt;setNumParameters(m_codeBlock-&gt;numParameters() + 1);</span>
1191     return &amp;parameter;
1192 }
1193 
1194 void BytecodeGenerator::initializeParameters(FunctionParameters&amp; parameters)
1195 {
1196     // Make sure the code block knows about all of our parameters, and make sure that parameters
1197     // needing destructuring are noted.
<span class="line-modified">1198     m_thisRegister.setIndex(VirtualRegister(initializeNextParameter()-&gt;index())); // this</span>
1199 
1200     bool nonSimpleArguments = false;
1201     for (unsigned i = 0; i &lt; parameters.size(); ++i) {
1202         auto parameter = parameters.at(i);
1203         auto pattern = parameter.first;
1204         if (pattern-&gt;isRestParameter()) {
1205             RELEASE_ASSERT(!m_restParameter);
1206             m_restParameter = static_cast&lt;RestParameterNode*&gt;(pattern);
1207             nonSimpleArguments = true;
1208             continue;
1209         }
1210         if (parameter.second) {
1211             nonSimpleArguments = true;
1212             continue;
1213         }
1214         if (!nonSimpleArguments)
1215             initializeNextParameter();
1216     }
1217 }
1218 
</pre>
<hr />
<pre>
1224 
1225         OpMov::emit(this, scopeRegister(), m_lexicalEnvironmentRegister);
1226 
1227         pushLocalControlFlowScope();
1228     }
1229     bool isWithScope = false;
1230     m_lexicalScopeStack.append({ functionSymbolTable, m_lexicalEnvironmentRegister, isWithScope, symbolTableConstantIndex });
1231     m_varScopeLexicalScopeStackIndex = m_lexicalScopeStack.size() - 1;
1232 }
1233 
1234 UniquedStringImpl* BytecodeGenerator::visibleNameForParameter(DestructuringPatternNode* pattern)
1235 {
1236     if (pattern-&gt;isBindingNode()) {
1237         const Identifier&amp; ident = static_cast&lt;const BindingNode*&gt;(pattern)-&gt;boundProperty();
1238         if (!m_functions.contains(ident.impl()))
1239             return ident.impl();
1240     }
1241     return nullptr;
1242 }
1243 














1244 RegisterID* BytecodeGenerator::newBlockScopeVariable()
1245 {
1246     reclaimFreeRegisters();
1247 
1248     return newRegister();
1249 }
1250 









1251 Ref&lt;LabelScope&gt; BytecodeGenerator::newLabelScope(LabelScope::Type type, const Identifier* name)
1252 {
1253     shrinkToFit(m_labelScopes);
1254 
1255     // Allocate new label scope.
1256     m_labelScopes.append(type, name, labelScopeDepth(), newLabel(), type == LabelScope::Loop ? RefPtr&lt;Label&gt;(newLabel()) : RefPtr&lt;Label&gt;()); // Only loops have continue targets.
1257     return m_labelScopes.last();
1258 }
1259 



























































1260 void BytecodeGenerator::emitEnter()
1261 {
1262     OpEnter::emit(this);
1263 
1264     if (LIKELY(Options::optimizeRecursiveTailCalls())) {
1265         // We must add the end of op_enter as a potential jump target, because the bytecode parser may decide to split its basic block
1266         // to have somewhere to jump to if there is a recursive tail-call that points to this function.
1267         m_codeBlock-&gt;addJumpTarget(instructions().size());
1268         // This disables peephole optimizations when an instruction is a jump target
1269         m_lastOpcodeID = op_end;
1270     }
1271 }
1272 
1273 void BytecodeGenerator::emitLoopHint()
1274 {
1275     OpLoopHint::emit(this);
<span class="line-added">1276     emitCheckTraps();</span>
1277 }
1278 
1279 void BytecodeGenerator::emitJump(Label&amp; target)
1280 {
1281     OpJmp::emit(this, target.bind(this));
1282 }
1283 
<span class="line-added">1284 void BytecodeGenerator::emitCheckTraps()</span>
<span class="line-added">1285 {</span>
<span class="line-added">1286     OpCheckTraps::emit(this);</span>
<span class="line-added">1287 }</span>
<span class="line-added">1288 </span>
1289 void ALWAYS_INLINE BytecodeGenerator::rewind()
1290 {
1291     ASSERT(m_lastInstruction.isValid());
1292     m_lastOpcodeID = op_end;
1293     m_writer.rewind(m_lastInstruction);
1294 }
1295 
1296 template&lt;typename BinOp, typename JmpOp&gt;
1297 bool BytecodeGenerator::fuseCompareAndJump(RegisterID* cond, Label&amp; target, bool swapOperands)
1298 {
1299     ASSERT(canDoPeepholeOptimization());
1300     auto binop = m_lastInstruction-&gt;as&lt;BinOp&gt;();
1301     if (cond-&gt;index() == binop.m_dst.offset() &amp;&amp; cond-&gt;isTemporary() &amp;&amp; !cond-&gt;refCount()) {
1302         rewind();
1303 
1304         if (swapOperands)
1305             std::swap(binop.m_lhs, binop.m_rhs);
1306 
1307         JmpOp::emit(this, binop.m_lhs, binop.m_rhs, target.bind(this));
1308         return true;
</pre>
<hr />
<pre>
1408         } else if (m_lastOpcodeID == op_not) {
1409             if (fuseTestAndJmp&lt;OpNot, OpJtrue&gt;(cond, target))
1410                 return;
1411         } else if (m_lastOpcodeID == op_eq_null &amp;&amp; target.isForward()) {
1412             if (fuseTestAndJmp&lt;OpEqNull, OpJneqNull&gt;(cond, target))
1413                 return;
1414         } else if (m_lastOpcodeID == op_neq_null &amp;&amp; target.isForward()) {
1415             if (fuseTestAndJmp&lt;OpNeqNull, OpJeqNull&gt;(cond, target))
1416                 return;
1417         } else if (m_lastOpcodeID == op_is_undefined_or_null &amp;&amp; target.isForward()) {
1418             if (fuseTestAndJmp&lt;OpIsUndefinedOrNull, OpJnundefinedOrNull&gt;(cond, target))
1419                 return;
1420         }
1421     }
1422 
1423     OpJfalse::emit(this, cond, target.bind(this));
1424 }
1425 
1426 void BytecodeGenerator::emitJumpIfNotFunctionCall(RegisterID* cond, Label&amp; target)
1427 {
<span class="line-modified">1428     OpJneqPtr::emit(this, cond, moveLinkTimeConstant(nullptr, LinkTimeConstant::callFunction), target.bind(this));</span>
1429 }
1430 
1431 void BytecodeGenerator::emitJumpIfNotFunctionApply(RegisterID* cond, Label&amp; target)
1432 {
<span class="line-modified">1433     OpJneqPtr::emit(this, cond, moveLinkTimeConstant(nullptr, LinkTimeConstant::applyFunction), target.bind(this));</span>
1434 }
1435 
1436 bool BytecodeGenerator::hasConstant(const Identifier&amp; ident) const
1437 {
1438     UniquedStringImpl* rep = ident.impl();
1439     return m_identifierMap.contains(rep);
1440 }
1441 
1442 unsigned BytecodeGenerator::addConstant(const Identifier&amp; ident)
1443 {
1444     UniquedStringImpl* rep = ident.impl();
1445     IdentifierMap::AddResult result = m_identifierMap.add(rep, m_codeBlock-&gt;numberOfIdentifiers());
1446     if (result.isNewEntry)
1447         m_codeBlock-&gt;addIdentifier(ident);
1448 
1449     return result.iterator-&gt;value;
1450 }
1451 
1452 // We can&#39;t hash JSValue(), so we use a dedicated data member to cache it.
1453 RegisterID* BytecodeGenerator::addConstantEmptyValue()
</pre>
<hr />
<pre>
1465 {
1466     if (!v)
1467         return addConstantEmptyValue();
1468 
1469     int index = m_nextConstantOffset;
1470 
1471     if (sourceCodeRepresentation == SourceCodeRepresentation::Double &amp;&amp; v.isInt32())
1472         v = jsDoubleNumber(v.asNumber());
1473     EncodedJSValueWithRepresentation valueMapKey { JSValue::encode(v), sourceCodeRepresentation };
1474     JSValueMap::AddResult result = m_jsValueMap.add(valueMapKey, m_nextConstantOffset);
1475     if (result.isNewEntry) {
1476         addConstantIndex();
1477         m_codeBlock-&gt;addConstant(v, sourceCodeRepresentation);
1478     } else
1479         index = result.iterator-&gt;value;
1480     return &amp;m_constantPoolRegisters[index];
1481 }
1482 
1483 RegisterID* BytecodeGenerator::moveLinkTimeConstant(RegisterID* dst, LinkTimeConstant type)
1484 {
<span class="line-modified">1485     RegisterID* constant = m_linkTimeConstantRegisters.ensure(type, [&amp;] {</span>

1486         int index = addConstantIndex();
1487         m_codeBlock-&gt;addConstant(type);
<span class="line-modified">1488         return &amp;m_constantPoolRegisters[index];</span>
<span class="line-modified">1489     }).iterator-&gt;value;</span>

1490     if (!dst)
<span class="line-modified">1491         return constant;</span>
1492 
<span class="line-modified">1493     OpMov::emit(this, dst, constant);</span>
1494 
1495     return dst;
1496 }
1497 
1498 RegisterID* BytecodeGenerator::moveEmptyValue(RegisterID* dst)
1499 {
1500     RefPtr&lt;RegisterID&gt; emptyValue = addConstantEmptyValue();
1501 
1502     OpMov::emit(this, dst, emptyValue.get());
1503 
1504     return dst;
1505 }
1506 
1507 RegisterID* BytecodeGenerator::emitMove(RegisterID* dst, RegisterID* src)
1508 {
1509     ASSERT(src != m_emptyValueRegister);
1510 
1511     m_staticPropertyAnalyzer.mov(dst, src);
1512     OpMov::emit(this, dst, src);
1513 
1514     return dst;
1515 }
1516 
<span class="line-modified">1517 RegisterID* BytecodeGenerator::emitUnaryOp(OpcodeID opcodeID, RegisterID* dst, RegisterID* src, ResultType type)</span>
1518 {
1519     switch (opcodeID) {
1520     case op_not:
1521         emitUnaryOp&lt;OpNot&gt;(dst, src);
1522         break;
1523     case op_negate:
<span class="line-modified">1524         OpNegate::emit(this, dst, src, type);</span>
1525         break;
1526     case op_bitnot:
1527         emitUnaryOp&lt;OpBitnot&gt;(dst, src);
1528         break;
1529     case op_to_number:
1530         emitUnaryOp&lt;OpToNumber&gt;(dst, src);
1531         break;
<span class="line-added">1532     case op_to_numeric:</span>
<span class="line-added">1533         emitUnaryOp&lt;OpToNumeric&gt;(dst, src);</span>
<span class="line-added">1534         break;</span>
1535     default:
1536         ASSERT_NOT_REACHED();
1537     }
1538     return dst;
1539 }
1540 
1541 RegisterID* BytecodeGenerator::emitBinaryOp(OpcodeID opcodeID, RegisterID* dst, RegisterID* src1, RegisterID* src2, OperandTypes types)
1542 {
1543     switch (opcodeID) {
1544     case op_eq:
1545         return emitBinaryOp&lt;OpEq&gt;(dst, src1, src2, types);
1546     case op_neq:
1547         return emitBinaryOp&lt;OpNeq&gt;(dst, src1, src2, types);
1548     case op_stricteq:
1549         return emitBinaryOp&lt;OpStricteq&gt;(dst, src1, src2, types);
1550     case op_nstricteq:
1551         return emitBinaryOp&lt;OpNstricteq&gt;(dst, src1, src2, types);
1552     case op_less:
1553         return emitBinaryOp&lt;OpLess&gt;(dst, src1, src2, types);
1554     case op_lesseq:
</pre>
<hr />
<pre>
1585         return emitBinaryOp&lt;OpBitxor&gt;(dst, src1, src2, types);
1586     case op_bitor:
1587         return emitBinaryOp&lt;OpBitor&gt;(dst, src1, src2, types);
1588     default:
1589         ASSERT_NOT_REACHED();
1590         return nullptr;
1591     }
1592 }
1593 
1594 RegisterID* BytecodeGenerator::emitToObject(RegisterID* dst, RegisterID* src, const Identifier&amp; message)
1595 {
1596     OpToObject::emit(this, dst, src, addConstant(message));
1597     return dst;
1598 }
1599 
1600 RegisterID* BytecodeGenerator::emitToNumber(RegisterID* dst, RegisterID* src)
1601 {
1602     return emitUnaryOp&lt;OpToNumber&gt;(dst, src);
1603 }
1604 
<span class="line-added">1605 RegisterID* BytecodeGenerator::emitToNumeric(RegisterID* dst, RegisterID* src)</span>
<span class="line-added">1606 {</span>
<span class="line-added">1607     return emitUnaryOp&lt;OpToNumeric&gt;(dst, src);</span>
<span class="line-added">1608 }</span>
<span class="line-added">1609 </span>
1610 RegisterID* BytecodeGenerator::emitToString(RegisterID* dst, RegisterID* src)
1611 {
1612     return emitUnaryOp&lt;OpToString&gt;(dst, src);
1613 }
1614 
1615 RegisterID* BytecodeGenerator::emitTypeOf(RegisterID* dst, RegisterID* src)
1616 {
1617     return emitUnaryOp&lt;OpTypeof&gt;(dst, src);
1618 }
1619 
1620 RegisterID* BytecodeGenerator::emitInc(RegisterID* srcDst)
1621 {
1622     OpInc::emit(this, srcDst);
1623     return srcDst;
1624 }
1625 
1626 RegisterID* BytecodeGenerator::emitDec(RegisterID* srcDst)
1627 {
1628     OpDec::emit(this, srcDst);
1629     return srcDst;
1630 }
1631 
1632 bool BytecodeGenerator::emitEqualityOpImpl(RegisterID* dst, RegisterID* src1, RegisterID* src2)
1633 {
1634     if (!canDoPeepholeOptimization())
1635         return false;
1636 
1637     if (m_lastInstruction-&gt;is&lt;OpTypeof&gt;()) {
1638         auto op = m_lastInstruction-&gt;as&lt;OpTypeof&gt;();
<span class="line-modified">1639         if (src1-&gt;virtualRegister() == op.m_dst</span>
1640             &amp;&amp; src1-&gt;isTemporary()
<span class="line-modified">1641             &amp;&amp; src2-&gt;virtualRegister().isConstant()</span>
<span class="line-modified">1642             &amp;&amp; m_codeBlock-&gt;constantRegister(src2-&gt;virtualRegister()).get().isString()) {</span>
<span class="line-modified">1643             const String&amp; value = asString(m_codeBlock-&gt;constantRegister(src2-&gt;virtualRegister()).get())-&gt;tryGetValue();</span>
1644             if (value == &quot;undefined&quot;) {
1645                 rewind();
1646                 OpIsUndefined::emit(this, dst, op.m_value);
1647                 return true;
1648             }
1649             if (value == &quot;boolean&quot;) {
1650                 rewind();
1651                 OpIsBoolean::emit(this, dst, op.m_value);
1652                 return true;
1653             }
1654             if (value == &quot;number&quot;) {
1655                 rewind();
1656                 OpIsNumber::emit(this, dst, op.m_value);
1657                 return true;
1658             }
1659             if (value == &quot;string&quot;) {
1660                 rewind();
1661                 OpIsCellWithType::emit(this, dst, op.m_value, StringType);
1662                 return true;
1663             }
</pre>
<hr />
<pre>
2098         environment.markAllVariablesAsCaptured();
2099 
2100     auto stackEntry = m_lexicalScopeStack.takeLast();
2101     SymbolTable* symbolTable = stackEntry.m_symbolTable;
2102     bool hasCapturedVariables = false;
2103     for (auto&amp; entry : environment) {
2104         if (entry.value.isCaptured()) {
2105             hasCapturedVariables = true;
2106             continue;
2107         }
2108         SymbolTableEntry symbolTableEntry = symbolTable-&gt;get(NoLockingNecessary, entry.key.get());
2109         ASSERT(!symbolTableEntry.isNull());
2110         VarOffset offset = symbolTableEntry.varOffset();
2111         ASSERT(offset.isStack());
2112         RegisterID* local = &amp;registerFor(offset.stackOffset());
2113         local-&gt;deref();
2114     }
2115 
2116     if (hasCapturedVariables) {
2117         RELEASE_ASSERT(stackEntry.m_scope);
<span class="line-modified">2118         emitGetParentScope(scopeRegister(), stackEntry.m_scope);</span>
2119         popLocalControlFlowScope();
2120         stackEntry.m_scope-&gt;deref();
2121     }
2122 
2123     m_TDZStack.removeLast();
2124     m_cachedVariablesUnderTDZ = { };
2125 }
2126 
2127 void BytecodeGenerator::prepareLexicalScopeForNextForLoopIteration(VariableEnvironmentNode* node, RegisterID* loopSymbolTable)
2128 {
2129     VariableEnvironment&amp; environment = node-&gt;lexicalVariables();
2130     if (!environment.size())
2131         return;
2132     if (shouldEmitDebugHooks())
2133         environment.markAllVariablesAsCaptured();
2134     if (!environment.hasCapturedVariables())
2135         return;
2136 
2137     RELEASE_ASSERT(loopSymbolTable);
2138 
</pre>
<hr />
<pre>
2156         for (auto end = symbolTable-&gt;end(NoLockingNecessary), ptr = symbolTable-&gt;begin(NoLockingNecessary); ptr != end; ++ptr) {
2157             if (!ptr-&gt;value.varOffset().isScope())
2158                 continue;
2159 
2160             RefPtr&lt;UniquedStringImpl&gt; ident = ptr-&gt;key;
2161             Identifier identifier = Identifier::fromUid(m_vm, ident.get());
2162 
2163             RegisterID* transitionValue = newBlockScopeVariable();
2164             transitionValue-&gt;ref();
2165             emitGetFromScope(transitionValue, loopScope, variableForLocalEntry(identifier, ptr-&gt;value, loopSymbolTable-&gt;index(), true), DoNotThrowIfNotFound);
2166             activationValuesToCopyOver.uncheckedAppend(std::make_pair(transitionValue, identifier));
2167         }
2168     }
2169 
2170     // We need this dynamic behavior of the executing code to ensure
2171     // each loop iteration has a new activation object. (It&#39;s pretty ugly).
2172     // Also, this new activation needs to be assigned to the same register
2173     // as the previous scope because the loop body is compiled under
2174     // the assumption that the scope&#39;s register index is constant even
2175     // though the value in that register will change on each loop iteration.
<span class="line-modified">2176     emitGetParentScope(scopeRegister(), loopScope);</span>

2177 
2178     OpCreateLexicalEnvironment::emit(this, loopScope, scopeRegister(), loopSymbolTable, addConstantValue(jsTDZValue()));
2179 
2180     move(scopeRegister(), loopScope);
2181 
2182     {
<span class="line-modified">2183         for (const auto&amp; pair : activationValuesToCopyOver) {</span>
2184             const Identifier&amp; identifier = pair.second;
2185             SymbolTableEntry entry = symbolTable-&gt;get(NoLockingNecessary, identifier.impl());
2186             RELEASE_ASSERT(!entry.isNull());
2187             RegisterID* transitionValue = pair.first;
2188             emitPutToScope(loopScope, variableForLocalEntry(identifier, entry, loopSymbolTable-&gt;index(), true), transitionValue, DoNotThrowIfNotFound, InitializationMode::NotInitialization);
2189             transitionValue-&gt;deref();
2190         }
2191     }
2192 }
2193 
2194 Variable BytecodeGenerator::variable(const Identifier&amp; property, ThisResolutionType thisResolutionType)
2195 {
2196     if (property == propertyNames().thisIdentifier &amp;&amp; thisResolutionType == ThisResolutionType::Local)
2197         return Variable(property, VarOffset(thisRegister()-&gt;virtualRegister()), thisRegister(), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly), Variable::SpecialVariable, 0, false);
2198 
2199     // We can optimize lookups if the lexical variable is found before a &quot;with&quot; or &quot;catch&quot;
2200     // scope because we&#39;re guaranteed static resolution. If we have to pass through
2201     // a &quot;with&quot; or &quot;catch&quot; scope we loose this guarantee.
2202     // We can&#39;t optimize cases like this:
2203     // {
</pre>
<hr />
<pre>
2346             // scope and the resolved scope.
2347             RELEASE_ASSERT(!stackEntry.m_isWithScope);
2348 
2349             if (stackEntry.m_symbolTable-&gt;get(NoLockingNecessary, variable.ident().impl()).isNull())
2350                 continue;
2351 
2352             RegisterID* scope = stackEntry.m_scope;
2353             RELEASE_ASSERT(scope);
2354             return scope;
2355         }
2356 
2357         RELEASE_ASSERT_NOT_REACHED();
2358         return nullptr;
2359 
2360     }
2361     case VarKind::Invalid:
2362         // Indicates non-local resolution.
2363 
2364         dst = tempDestination(dst);
2365         OpResolveScope::emit(this, kill(dst), scopeRegister(), addConstant(variable.ident()), resolveType(), localScopeDepth());

2366         return dst;
2367     }
2368 
2369     RELEASE_ASSERT_NOT_REACHED();
2370     return nullptr;
2371 }
2372 
2373 RegisterID* BytecodeGenerator::emitGetFromScope(RegisterID* dst, RegisterID* scope, const Variable&amp; variable, ResolveMode resolveMode)
2374 {
2375     switch (variable.offset().kind()) {
2376     case VarKind::Stack:
2377         return move(dst, variable.local());
2378 
2379     case VarKind::DirectArgument: {
2380         OpGetFromArguments::emit(this, kill(dst), scope, variable.offset().capturedArgumentsOffset().offset());
2381         return dst;
2382     }
2383 
2384     case VarKind::Scope:
2385     case VarKind::Invalid: {
2386         OpGetFromScope::emit(
2387             this,
2388             kill(dst),
2389             scope,
2390             addConstant(variable.ident()),
2391             GetPutInfo(resolveMode, variable.offset().isScope() ? LocalClosureVar : resolveType(), InitializationMode::NotInitialization),
2392             localScopeDepth(),
2393             variable.offset().isScope() ? variable.offset().scopeOffset().offset() : 0);

2394         return dst;
2395     } }
2396 
2397     RELEASE_ASSERT_NOT_REACHED();
2398 }
2399 
2400 RegisterID* BytecodeGenerator::emitPutToScope(RegisterID* scope, const Variable&amp; variable, RegisterID* value, ResolveMode resolveMode, InitializationMode initializationMode)
2401 {
2402     switch (variable.offset().kind()) {
2403     case VarKind::Stack:
2404         move(variable.local(), value);
2405         return value;
2406 
2407     case VarKind::DirectArgument:
2408         OpPutToArguments::emit(this, scope, variable.offset().capturedArgumentsOffset().offset(), value);
2409         return value;
2410 
2411     case VarKind::Scope:
2412     case VarKind::Invalid: {
2413         GetPutInfo getPutInfo(0);
2414         SymbolTableOrScopeDepth symbolTableOrScopeDepth;
2415         ScopeOffset offset;
2416         if (variable.offset().isScope()) {
2417             offset = variable.offset().scopeOffset();
2418             getPutInfo = GetPutInfo(resolveMode, LocalClosureVar, initializationMode);
2419             symbolTableOrScopeDepth = SymbolTableOrScopeDepth::symbolTable(VirtualRegister { variable.symbolTableConstantIndex() });
2420         } else {
2421             ASSERT(resolveType() != LocalClosureVar);
2422             getPutInfo = GetPutInfo(resolveMode, resolveType(), initializationMode);
2423             symbolTableOrScopeDepth = SymbolTableOrScopeDepth::scopeDepth(localScopeDepth());
2424         }
2425         OpPutToScope::emit(this, scope, addConstant(variable.ident()), value, getPutInfo, symbolTableOrScopeDepth, !!offset ? offset.offset() : 0);

2426         return value;
2427     } }
2428 
2429     RELEASE_ASSERT_NOT_REACHED();
2430 }
2431 
2432 RegisterID* BytecodeGenerator::initializeVariable(const Variable&amp; variable, RegisterID* value)
2433 {
2434     RELEASE_ASSERT(variable.offset().kind() != VarKind::Invalid);
2435     RegisterID* scope = emitResolveScope(nullptr, variable);
2436     return emitPutToScope(scope, variable, value, ThrowIfNotFound, InitializationMode::NotInitialization);
2437 }
2438 
2439 RegisterID* BytecodeGenerator::emitInstanceOf(RegisterID* dst, RegisterID* value, RegisterID* basePrototype)
2440 {
2441     OpInstanceof::emit(this, dst, value, basePrototype);
2442     return dst;
2443 }
2444 
2445 RegisterID* BytecodeGenerator::emitInstanceOfCustom(RegisterID* dst, RegisterID* value, RegisterID* constructor, RegisterID* hasInstanceValue)
</pre>
<hr />
<pre>
2456 
2457 RegisterID* BytecodeGenerator::emitInById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2458 {
2459     OpInById::emit(this, dst, base, addConstant(property));
2460     return dst;
2461 }
2462 
2463 RegisterID* BytecodeGenerator::emitTryGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2464 {
2465     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties are not supported with tryGetById.&quot;);
2466 
2467     OpTryGetById::emit(this, kill(dst), base, addConstant(property));
2468     return dst;
2469 }
2470 
2471 RegisterID* BytecodeGenerator::emitGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2472 {
2473     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with get_by_val.&quot;);
2474 
2475     OpGetById::emit(this, kill(dst), base, addConstant(property));

2476     return dst;
2477 }
2478 
2479 RegisterID* BytecodeGenerator::emitGetById(RegisterID* dst, RegisterID* base, RegisterID* thisVal, const Identifier&amp; property)
2480 {
2481     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with get_by_val.&quot;);
2482 
2483     OpGetByIdWithThis::emit(this, kill(dst), base, thisVal, addConstant(property));
2484     return dst;
2485 }
2486 
2487 RegisterID* BytecodeGenerator::emitDirectGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2488 {
2489     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with get_by_val_direct.&quot;);
2490 
2491     OpGetByIdDirect::emit(this, kill(dst), base, addConstant(property));

2492     return dst;
2493 }
2494 
2495 RegisterID* BytecodeGenerator::emitPutById(RegisterID* base, const Identifier&amp; property, RegisterID* value)
2496 {
2497     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with put_by_val.&quot;);
2498 
2499     unsigned propertyIndex = addConstant(property);
2500 
2501     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2502 
2503     OpPutById::emit(this, base, propertyIndex, value, PutByIdNone); // is not direct


2504     return value;
2505 }
2506 
2507 RegisterID* BytecodeGenerator::emitPutById(RegisterID* base, RegisterID* thisValue, const Identifier&amp; property, RegisterID* value)
2508 {
2509     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with put_by_val.&quot;);
2510 
2511     unsigned propertyIndex = addConstant(property);
2512 
2513     OpPutByIdWithThis::emit(this, base, thisValue, propertyIndex, value);
2514 
2515     return value;
2516 }
2517 
2518 RegisterID* BytecodeGenerator::emitDirectPutById(RegisterID* base, const Identifier&amp; property, RegisterID* value, PropertyNode::PutType putType)
2519 {
2520     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with put_by_val(direct).&quot;);
2521 
2522     unsigned propertyIndex = addConstant(property);
2523 
2524     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2525 
2526     PutByIdFlags type = (putType == PropertyNode::KnownDirect || property != m_vm.propertyNames-&gt;underscoreProto) ? PutByIdIsDirect : PutByIdNone;
2527     OpPutById::emit(this, base, propertyIndex, value, type);

2528     return value;
2529 }
2530 
2531 void BytecodeGenerator::emitPutGetterById(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* getter)
2532 {
2533     unsigned propertyIndex = addConstant(property);
2534     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2535 
2536     OpPutGetterById::emit(this, base, propertyIndex, attributes, getter);
2537 }
2538 
2539 void BytecodeGenerator::emitPutSetterById(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* setter)
2540 {
2541     unsigned propertyIndex = addConstant(property);
2542     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2543 
2544     OpPutSetterById::emit(this, base, propertyIndex, attributes, setter);
2545 }
2546 
2547 void BytecodeGenerator::emitPutGetterSetter(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* getter, RegisterID* setter)
2548 {
2549     unsigned propertyIndex = addConstant(property);
2550 
2551     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2552 
2553     OpPutGetterSetterById::emit(this, base, propertyIndex, attributes, getter, setter);
2554 }
2555 
2556 void BytecodeGenerator::emitPutGetterByVal(RegisterID* base, RegisterID* property, unsigned attributes, RegisterID* getter)
2557 {
2558     OpPutGetterByVal::emit(this, base, property, attributes, getter);
2559 }
2560 
2561 void BytecodeGenerator::emitPutSetterByVal(RegisterID* base, RegisterID* property, unsigned attributes, RegisterID* setter)
2562 {
2563     OpPutSetterByVal::emit(this, base, property, attributes, setter);
2564 }
2565 
2566 void BytecodeGenerator::emitPutGeneratorFields(RegisterID* nextFunction)
2567 {
<span class="line-modified">2568     emitPutInternalField(m_generatorRegister, static_cast&lt;unsigned&gt;(JSGenerator::Field::Next), nextFunction);</span>




2569 
2570     // We do not store &#39;this&#39; in arrow function within constructor,
2571     // because it might be not initialized, if super is called later.
2572     if (!(isDerivedConstructorContext() &amp;&amp; m_codeBlock-&gt;parseMode() == SourceParseMode::AsyncArrowFunctionMode))
<span class="line-modified">2573         emitPutInternalField(m_generatorRegister, static_cast&lt;unsigned&gt;(JSGenerator::Field::This), &amp;m_thisRegister);</span>




2574 }
2575 
2576 void BytecodeGenerator::emitPutAsyncGeneratorFields(RegisterID* nextFunction)
2577 {
2578     ASSERT(isAsyncGeneratorWrapperParseMode(parseMode()));
2579 
<span class="line-modified">2580     emitPutInternalField(m_generatorRegister, static_cast&lt;unsigned&gt;(JSAsyncGenerator::Field::Next), nextFunction);</span>
<span class="line-modified">2581     emitPutInternalField(m_generatorRegister, static_cast&lt;unsigned&gt;(JSAsyncGenerator::Field::This), &amp;m_thisRegister);</span>










2582 }
2583 
2584 RegisterID* BytecodeGenerator::emitDeleteById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2585 {
2586     OpDelById::emit(this, dst, base, addConstant(property));
2587     return dst;
2588 }
2589 
2590 RegisterID* BytecodeGenerator::emitGetByVal(RegisterID* dst, RegisterID* base, RegisterID* property)
2591 {
2592     for (size_t i = m_forInContextStack.size(); i--; ) {
2593         ForInContext&amp; context = m_forInContextStack[i].get();
2594         if (context.local() != property)
2595             continue;
2596 
2597         if (context.isIndexedForInContext()) {
2598             auto&amp; indexedContext = context.asIndexedForInContext();
2599             kill(dst);
2600             if (OpGetByVal::checkWithoutMetadataID&lt;OpcodeSize::Narrow&gt;(this, dst, base, property))
2601                 OpGetByVal::emitWithSmallestSizeRequirement&lt;OpcodeSize::Narrow&gt;(this, dst, base, indexedContext.index());
</pre>
<hr />
<pre>
2632 }
2633 
2634 RegisterID* BytecodeGenerator::emitPutByVal(RegisterID* base, RegisterID* thisValue, RegisterID* property, RegisterID* value)
2635 {
2636     OpPutByValWithThis::emit(this, base, thisValue, property, value);
2637     return value;
2638 }
2639 
2640 RegisterID* BytecodeGenerator::emitDirectPutByVal(RegisterID* base, RegisterID* property, RegisterID* value)
2641 {
2642     OpPutByValDirect::emit(this, base, property, value);
2643     return value;
2644 }
2645 
2646 RegisterID* BytecodeGenerator::emitDeleteByVal(RegisterID* dst, RegisterID* base, RegisterID* property)
2647 {
2648     OpDelByVal::emit(this, dst, base, property);
2649     return dst;
2650 }
2651 
<span class="line-added">2652 RegisterID* BytecodeGenerator::emitGetInternalField(RegisterID* dst, RegisterID* base, unsigned index)</span>
<span class="line-added">2653 {</span>
<span class="line-added">2654     OpGetInternalField::emit(this, dst, base, index);</span>
<span class="line-added">2655     return dst;</span>
<span class="line-added">2656 }</span>
<span class="line-added">2657 </span>
<span class="line-added">2658 RegisterID* BytecodeGenerator::emitPutInternalField(RegisterID* base, unsigned index, RegisterID* value)</span>
<span class="line-added">2659 {</span>
<span class="line-added">2660     OpPutInternalField::emit(this, base, index, value);</span>
<span class="line-added">2661     return value;</span>
<span class="line-added">2662 }</span>
<span class="line-added">2663 </span>
2664 void BytecodeGenerator::emitSuperSamplerBegin()
2665 {
2666     OpSuperSamplerBegin::emit(this);
2667 }
2668 
2669 void BytecodeGenerator::emitSuperSamplerEnd()
2670 {
2671     OpSuperSamplerEnd::emit(this);
2672 }
2673 
2674 RegisterID* BytecodeGenerator::emitIdWithProfile(RegisterID* src, SpeculatedType profile)
2675 {
2676     OpIdentityWithProfile::emit(this, src, static_cast&lt;uint32_t&gt;(profile &gt;&gt; 32), static_cast&lt;uint32_t&gt;(profile));
2677     return src;
2678 }
2679 
2680 void BytecodeGenerator::emitUnreachable()
2681 {
2682     OpUnreachable::emit(this);
2683 }
2684 
2685 RegisterID* BytecodeGenerator::emitGetArgument(RegisterID* dst, int32_t index)
2686 {
2687     OpGetArgument::emit(this, dst, index + 1 /* Including |this| */);
2688     return dst;
2689 }
2690 
2691 RegisterID* BytecodeGenerator::emitCreateThis(RegisterID* dst)
2692 {
2693     OpCreateThis::emit(this, dst, dst, 0);
2694     m_staticPropertyAnalyzer.createThis(dst, m_lastInstruction);
<span class="line-added">2695     return dst;</span>
<span class="line-added">2696 }</span>
<span class="line-added">2697 </span>
<span class="line-added">2698 RegisterID* BytecodeGenerator::emitCreatePromise(RegisterID* dst, RegisterID* newTarget, bool isInternalPromise)</span>
<span class="line-added">2699 {</span>
<span class="line-added">2700     OpCreatePromise::emit(this, dst, newTarget, isInternalPromise);</span>
<span class="line-added">2701     return dst;</span>
<span class="line-added">2702 }</span>
<span class="line-added">2703 </span>
<span class="line-added">2704 RegisterID* BytecodeGenerator::emitNewPromise(RegisterID* dst, bool isInternalPromise)</span>
<span class="line-added">2705 {</span>
<span class="line-added">2706     OpNewPromise::emit(this, dst, isInternalPromise);</span>
<span class="line-added">2707     return dst;</span>
<span class="line-added">2708 }</span>
<span class="line-added">2709 </span>
<span class="line-added">2710 RegisterID* BytecodeGenerator::emitCreateGenerator(RegisterID* dst, RegisterID* newTarget)</span>
<span class="line-added">2711 {</span>
<span class="line-added">2712     OpCreateGenerator::emit(this, dst, newTarget);</span>
<span class="line-added">2713     return dst;</span>
<span class="line-added">2714 }</span>
<span class="line-added">2715 </span>
<span class="line-added">2716 RegisterID* BytecodeGenerator::emitNewGenerator(RegisterID* dst)</span>
<span class="line-added">2717 {</span>
<span class="line-added">2718     OpNewGenerator::emit(this, dst);</span>
<span class="line-added">2719     return dst;</span>
<span class="line-added">2720 }</span>
<span class="line-added">2721 </span>
<span class="line-added">2722 RegisterID* BytecodeGenerator::emitCreateAsyncGenerator(RegisterID* dst, RegisterID* newTarget)</span>
<span class="line-added">2723 {</span>
<span class="line-added">2724     OpCreateAsyncGenerator::emit(this, dst, newTarget);</span>
<span class="line-added">2725     return dst;</span>
<span class="line-added">2726 }</span>
<span class="line-added">2727 </span>
<span class="line-added">2728 RegisterID* BytecodeGenerator::emitCreateArgumentsButterfly(RegisterID* dst)</span>
<span class="line-added">2729 {</span>
<span class="line-added">2730     OpCreateArgumentsButterfly::emit(this, dst);</span>
<span class="line-added">2731     return dst;</span>
<span class="line-added">2732 }</span>
<span class="line-added">2733 </span>
<span class="line-added">2734 RegisterID* BytecodeGenerator::emitInstanceFieldInitializationIfNeeded(RegisterID* dst, RegisterID* constructor, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)</span>
<span class="line-added">2735 {</span>
<span class="line-added">2736     if (!(isConstructor() || isDerivedConstructorContext()) || needsClassFieldInitializer() == NeedsClassFieldInitializer::No)</span>
<span class="line-added">2737         return dst;</span>
<span class="line-added">2738 </span>
<span class="line-added">2739     RefPtr&lt;RegisterID&gt; initializer = emitDirectGetById(newTemporary(), constructor, propertyNames().builtinNames().instanceFieldInitializerPrivateName());</span>
<span class="line-added">2740     CallArguments args(*this, nullptr);</span>
<span class="line-added">2741     emitMove(args.thisRegister(), dst);</span>
<span class="line-added">2742     emitCall(newTemporary(), initializer.get(), NoExpectedFunction, args, divot, divotStart, divotEnd, DebuggableCall::No);</span>
2743 

2744     return dst;
2745 }
2746 
2747 void BytecodeGenerator::emitTDZCheck(RegisterID* target)
2748 {
2749     OpCheckTdz::emit(this, target);
2750 }
2751 
2752 bool BytecodeGenerator::needsTDZCheck(const Variable&amp; variable)
2753 {
2754     for (unsigned i = m_TDZStack.size(); i--;) {
2755         auto iter = m_TDZStack[i].find(variable.ident().impl());
2756         if (iter == m_TDZStack[i].end())
2757             continue;
2758         return iter-&gt;value != TDZNecessityLevel::NotNeeded;
2759     }
2760 
2761     return false;
2762 }
2763 
</pre>
<hr />
<pre>
2860 void BytecodeGenerator::restoreTDZStack(const BytecodeGenerator::PreservedTDZStack&amp; preservedStack)
2861 {
2862     m_TDZStack = preservedStack.m_preservedTDZStack;
2863     m_cachedVariablesUnderTDZ = { };
2864 }
2865 
2866 RegisterID* BytecodeGenerator::emitNewObject(RegisterID* dst)
2867 {
2868     OpNewObject::emit(this, dst, 0);
2869     m_staticPropertyAnalyzer.newObject(dst, m_lastInstruction);
2870 
2871     return dst;
2872 }
2873 
2874 JSValue BytecodeGenerator::addBigIntConstant(const Identifier&amp; identifier, uint8_t radix, bool sign)
2875 {
2876     return m_bigIntMap.ensure(BigIntMapEntry(identifier.impl(), radix, sign), [&amp;] {
2877         auto scope = DECLARE_CATCH_SCOPE(vm());
2878         auto parseIntSign = sign ? JSBigInt::ParseIntSign::Signed : JSBigInt::ParseIntSign::Unsigned;
2879         JSBigInt* bigIntInMap = JSBigInt::parseInt(nullptr, vm(), identifier.string(), radix, JSBigInt::ErrorParseMode::ThrowExceptions, parseIntSign);


2880         scope.assertNoException();

2881         addConstantValue(bigIntInMap);
2882 
2883         return bigIntInMap;
2884     }).iterator-&gt;value;
2885 }
2886 
2887 JSString* BytecodeGenerator::addStringConstant(const Identifier&amp; identifier)
2888 {
2889     JSString*&amp; stringInMap = m_stringMap.add(identifier.impl(), nullptr).iterator-&gt;value;
2890     if (!stringInMap) {
2891         stringInMap = jsString(vm(), identifier.string());
2892         addConstantValue(stringInMap);
2893     }
2894     return stringInMap;
2895 }
2896 
2897 RegisterID* BytecodeGenerator::addTemplateObjectConstant(Ref&lt;TemplateObjectDescriptor&gt;&amp;&amp; descriptor, int endOffset)
2898 {
2899     auto result = m_templateObjectDescriptorSet.add(WTFMove(descriptor));
2900     JSTemplateObjectDescriptor* descriptorValue = m_templateDescriptorMap.ensure(endOffset, [&amp;] {
</pre>
<hr />
<pre>
3005 {
3006     emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
3007     return dst;
3008 }
3009 
3010 RegisterID* BytecodeGenerator::emitNewArrowFunctionExpression(RegisterID* dst, ArrowFuncExprNode* func)
3011 {
3012     ASSERT(SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(func-&gt;metadata()-&gt;parseMode()));
3013     emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
3014     return dst;
3015 }
3016 
3017 RegisterID* BytecodeGenerator::emitNewMethodDefinition(RegisterID* dst, MethodDefinitionNode* func)
3018 {
3019     ASSERT(isMethodParseMode(func-&gt;metadata()-&gt;parseMode()));
3020     emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
3021     return dst;
3022 }
3023 
3024 RegisterID* BytecodeGenerator::emitNewDefaultConstructor(RegisterID* dst, ConstructorKind constructorKind, const Identifier&amp; name,
<span class="line-modified">3025     const Identifier&amp; ecmaName, const SourceCode&amp; classSource, NeedsClassFieldInitializer needsClassFieldInitializer)</span>
3026 {
<span class="line-modified">3027     UnlinkedFunctionExecutable* executable = m_vm.builtinExecutables()-&gt;createDefaultConstructor(constructorKind, name, needsClassFieldInitializer);</span>
3028     executable-&gt;setInvalidTypeProfilingOffsets();
3029     executable-&gt;setEcmaName(ecmaName);
3030     executable-&gt;setClassSource(classSource);
3031 
3032     unsigned index = m_codeBlock-&gt;addFunctionExpr(executable);
3033 
3034     OpNewFuncExp::emit(this, dst, scopeRegister(), index);
3035     return dst;
3036 }
3037 
<span class="line-added">3038 RegisterID* BytecodeGenerator::emitNewInstanceFieldInitializerFunction(RegisterID* dst, Vector&lt;JSTextPosition&gt;&amp;&amp; instanceFieldLocations, bool isDerived)</span>
<span class="line-added">3039 {</span>
<span class="line-added">3040     DerivedContextType newDerivedContextType;</span>
<span class="line-added">3041     SuperBinding superBinding;</span>
<span class="line-added">3042     if (!isDerived) {</span>
<span class="line-added">3043         newDerivedContextType = DerivedContextType::None;</span>
<span class="line-added">3044         superBinding = SuperBinding::NotNeeded;</span>
<span class="line-added">3045     } else {</span>
<span class="line-added">3046         newDerivedContextType = DerivedContextType::DerivedMethodContext;</span>
<span class="line-added">3047         superBinding = SuperBinding::Needed;</span>
<span class="line-added">3048     }</span>
<span class="line-added">3049 </span>
<span class="line-added">3050     Optional&lt;CompactVariableMap::Handle&gt; variablesUnderTDZ = getVariablesUnderTDZ();</span>
<span class="line-added">3051     SourceParseMode parseMode = SourceParseMode::InstanceFieldInitializerMode;</span>
<span class="line-added">3052     ConstructAbility constructAbility = ConstructAbility::CannotConstruct;</span>
<span class="line-added">3053 </span>
<span class="line-added">3054     const bool alwaysStrictInClass = true;</span>
<span class="line-added">3055     FunctionMetadataNode metadata(parserArena(), JSTokenLocation(), JSTokenLocation(), 0, 0, 0, 0, 0, alwaysStrictInClass, ConstructorKind::None, superBinding, 0, parseMode, false);</span>
<span class="line-added">3056     metadata.finishParsing(m_scopeNode-&gt;source(), Identifier(), FunctionMode::MethodDefinition);</span>
<span class="line-added">3057     auto initializer = UnlinkedFunctionExecutable::create(m_vm, m_scopeNode-&gt;source(), &amp;metadata, isBuiltinFunction() ? UnlinkedBuiltinFunction : UnlinkedNormalFunction, constructAbility, scriptMode(), WTFMove(variablesUnderTDZ), newDerivedContextType, NeedsClassFieldInitializer::No);</span>
<span class="line-added">3058     initializer-&gt;setInstanceFieldLocations(WTFMove(instanceFieldLocations));</span>
<span class="line-added">3059 </span>
<span class="line-added">3060     unsigned index = m_codeBlock-&gt;addFunctionExpr(initializer);</span>
<span class="line-added">3061     OpNewFuncExp::emit(this, dst, scopeRegister(), index);</span>
<span class="line-added">3062     return dst;</span>
<span class="line-added">3063 }</span>
<span class="line-added">3064 </span>
3065 RegisterID* BytecodeGenerator::emitNewFunction(RegisterID* dst, FunctionMetadataNode* function)
3066 {
3067     unsigned index = m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
3068     if (isGeneratorWrapperParseMode(function-&gt;parseMode()))
3069         OpNewGeneratorFunc::emit(this, dst, scopeRegister(), index);
3070     else if (function-&gt;parseMode() == SourceParseMode::AsyncFunctionMode)
3071         OpNewAsyncFunc::emit(this, dst, scopeRegister(), index);
3072     else if (isAsyncGeneratorWrapperParseMode(function-&gt;parseMode()))
3073         OpNewAsyncGeneratorFunc::emit(this, dst, scopeRegister(), index);
3074     else
3075         OpNewFunc::emit(this, dst, scopeRegister(), index);
3076     return dst;
3077 }
3078 
<span class="line-modified">3079 template&lt;typename LazyNameRegisterFn&gt;</span>
<span class="line-added">3080 void BytecodeGenerator::emitSetFunctionNameIfNeededImpl(ExpressionNode* valueNode, RegisterID* value, const LazyNameRegisterFn&amp; lazyNameFn)</span>
3081 {
3082     if (valueNode-&gt;isBaseFuncExprNode()) {
3083         FunctionMetadataNode* metadata = static_cast&lt;BaseFuncExprNode*&gt;(valueNode)-&gt;metadata();
3084         if (!metadata-&gt;ecmaName().isNull())
3085             return;
3086     } else if (valueNode-&gt;isClassExprNode()) {
3087         ClassExprNode* classExprNode = static_cast&lt;ClassExprNode*&gt;(valueNode);
3088         if (!classExprNode-&gt;ecmaName().isNull())
3089             return;
3090         if (classExprNode-&gt;hasStaticProperty(m_vm.propertyNames-&gt;name))
3091             return;
3092     } else
3093         return;
3094 
<span class="line-added">3095     RegisterID* name = lazyNameFn();</span>
<span class="line-added">3096 </span>
3097     // FIXME: We should use an op_call to an internal function here instead.
3098     // https://bugs.webkit.org/show_bug.cgi?id=155547
3099     OpSetFunctionName::emit(this, value, name);
3100 }
3101 
<span class="line-added">3102 void BytecodeGenerator::emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, const Identifier&amp; ident)</span>
<span class="line-added">3103 {</span>
<span class="line-added">3104     emitSetFunctionNameIfNeededImpl(valueNode, value, [=]() { return emitLoad(newTemporary(), ident); });</span>
<span class="line-added">3105 }</span>
<span class="line-added">3106 </span>
<span class="line-added">3107 void BytecodeGenerator::emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, RegisterID* name)</span>
<span class="line-added">3108 {</span>
<span class="line-added">3109     emitSetFunctionNameIfNeededImpl(valueNode, value, [=]() { return name; });</span>
<span class="line-added">3110 }</span>
<span class="line-added">3111 </span>
3112 RegisterID* BytecodeGenerator::emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3113 {
3114     return emitCall&lt;OpCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3115 }
3116 
3117 RegisterID* BytecodeGenerator::emitCallInTailPosition(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3118 {
3119     if (m_inTailPosition) {
3120         m_codeBlock-&gt;setHasTailCalls();
3121         return emitCall&lt;OpTailCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3122     }
3123     return emitCall&lt;OpCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3124 }
3125 
3126 RegisterID* BytecodeGenerator::emitCallEval(RegisterID* dst, RegisterID* func, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3127 {
3128     return emitCall&lt;OpCallEval&gt;(dst, func, NoExpectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3129 }
3130 
3131 ExpectedFunction BytecodeGenerator::expectedFunctionForIdentifier(const Identifier&amp; identifier)
3132 {
3133     if (identifier == propertyNames().Object || identifier == propertyNames().builtinNames().ObjectPrivateName())
3134         return ExpectObjectConstructor;
3135     if (identifier == propertyNames().Array || identifier == propertyNames().builtinNames().ArrayPrivateName())
3136         return ExpectArrayConstructor;
3137     return NoExpectedFunction;
3138 }
3139 
3140 ExpectedFunction BytecodeGenerator::emitExpectedFunctionSnippet(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, Label&amp; done)
3141 {
3142     Ref&lt;Label&gt; realCall = newLabel();
3143     switch (expectedFunction) {
3144     case ExpectObjectConstructor: {
3145         // If the number of arguments is non-zero, then we can&#39;t do anything interesting.
3146         if (callArguments.argumentCountIncludingThis() &gt;= 2)
3147             return NoExpectedFunction;
3148 
<span class="line-modified">3149         OpJneqPtr::emit(this, func, moveLinkTimeConstant(nullptr, LinkTimeConstant::Object), realCall-&gt;bind(this));</span>
3150 
3151         if (dst != ignoredResult())
3152             emitNewObject(dst);
3153         break;
3154     }
3155 
3156     case ExpectArrayConstructor: {
3157         // If you&#39;re doing anything other than &quot;new Array()&quot; or &quot;new Array(foo)&quot; then we
3158         // don&#39;t do inline it, for now. The only reason is that call arguments are in
3159         // the opposite order of what op_new_array expects, so we&#39;d either need to change
3160         // how op_new_array works or we&#39;d need an op_new_array_reverse. Neither of these
3161         // things sounds like it&#39;s worth it.
3162         if (callArguments.argumentCountIncludingThis() &gt; 2)
3163             return NoExpectedFunction;
3164 
<span class="line-modified">3165         OpJneqPtr::emit(this, func, moveLinkTimeConstant(nullptr, LinkTimeConstant::Array), realCall-&gt;bind(this));</span>
3166 
3167         if (dst != ignoredResult()) {
3168             if (callArguments.argumentCountIncludingThis() == 2)
3169                 emitNewArrayWithSize(dst, callArguments.argumentRegister(0));
3170             else {
3171                 ASSERT(callArguments.argumentCountIncludingThis() == 1);
3172                 OpNewArray::emit(this, dst, VirtualRegister { 0 }, 0, ArrayWithUndecided);
3173             }
3174         }
3175         break;
3176     }
3177 
3178     default:
3179         ASSERT(expectedFunction == NoExpectedFunction);
3180         return NoExpectedFunction;
3181     }
3182 
3183     OpJmp::emit(this, done.bind(this));
3184     emitLabel(realCall.get());
3185 
</pre>
<hr />
<pre>
3267 {
3268     // We must emit a tail call here because we did not allocate an arguments object thus we would otherwise have no way to correctly make this call.
3269     ASSERT(m_inTailPosition || !Options::useTailCalls());
3270     return emitCallVarargs&lt;OpTailCallForwardArguments&gt;(dst, func, thisRegister, nullptr, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3271 }
3272 
3273 template&lt;typename VarargsOp&gt;
3274 RegisterID* BytecodeGenerator::emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3275 {
3276     if (shouldEmitDebugHooks() &amp;&amp; debuggableCall == DebuggableCall::Yes)
3277         emitDebugHook(WillExecuteExpression, divotStart);
3278 
3279     emitExpressionInfo(divot, divotStart, divotEnd);
3280 
3281     if (VarargsOp::opcodeID == op_tail_call_varargs)
3282         emitLogShadowChickenTailIfNecessary();
3283 
3284     // Emit call.
3285     ASSERT(dst != ignoredResult());
3286     VarargsOp::emit(this, dst, func, thisRegister, arguments ? arguments : VirtualRegister(0), firstFreeRegister, firstVarArgOffset);
<span class="line-added">3287     if (VarargsOp::opcodeID != op_tail_call_forward_arguments)</span>
<span class="line-added">3288         ASSERT(m_codeBlock-&gt;hasCheckpoints());</span>
3289     return dst;
3290 }
3291 
3292 void BytecodeGenerator::emitLogShadowChickenPrologueIfNecessary()
3293 {
3294     if (!shouldEmitDebugHooks() &amp;&amp; !Options::alwaysUseShadowChicken())
3295         return;
3296     OpLogShadowChickenPrologue::emit(this, scopeRegister());
3297 }
3298 
3299 void BytecodeGenerator::emitLogShadowChickenTailIfNecessary()
3300 {
3301     if (!shouldEmitDebugHooks() &amp;&amp; !Options::alwaysUseShadowChicken())
3302         return;
3303     OpLogShadowChickenTail::emit(this, thisRegister(), scopeRegister());
3304 }
3305 
3306 void BytecodeGenerator::emitCallDefineProperty(RegisterID* newObj, RegisterID* propertyNameRegister,
3307     RegisterID* valueRegister, RegisterID* getterRegister, RegisterID* setterRegister, unsigned options, const JSTextPosition&amp; position)
3308 {
</pre>
<hr />
<pre>
3315     else if (valueRegister)
3316         attributes.setWritable(false);
3317 
3318     if (options &amp; PropertyEnumerable)
3319         attributes.setEnumerable(true);
3320 
3321     if (valueRegister)
3322         attributes.setValue();
3323     if (getterRegister)
3324         attributes.setGet();
3325     if (setterRegister)
3326         attributes.setSet();
3327 
3328     ASSERT(!valueRegister || (!getterRegister &amp;&amp; !setterRegister));
3329 
3330     emitExpressionInfo(position, position, position);
3331 
3332     if (attributes.hasGet() || attributes.hasSet()) {
3333         RefPtr&lt;RegisterID&gt; throwTypeErrorFunction;
3334         if (!attributes.hasGet() || !attributes.hasSet())
<span class="line-modified">3335             throwTypeErrorFunction = moveLinkTimeConstant(nullptr, LinkTimeConstant::throwTypeErrorFunction);</span>
3336 
3337         RefPtr&lt;RegisterID&gt; getter;
3338         if (attributes.hasGet())
3339             getter = getterRegister;
3340         else
3341             getter = throwTypeErrorFunction;
3342 
3343         RefPtr&lt;RegisterID&gt; setter;
3344         if (attributes.hasSet())
3345             setter = setterRegister;
3346         else
3347             setter = throwTypeErrorFunction;
3348 
3349         OpDefineAccessorProperty::emit(this, newObj, propertyNameRegister, getter.get(), setter.get(), emitLoad(nullptr, jsNumber(attributes.rawRepresentation())));
3350     } else {
3351         OpDefineDataProperty::emit(this, newObj, propertyNameRegister, valueRegister, emitLoad(nullptr, jsNumber(attributes.rawRepresentation())));
3352     }
3353 }
3354 
3355 RegisterID* BytecodeGenerator::emitReturn(RegisterID* src, ReturnFrom from)
3356 {
<span class="line-modified">3357     // Normal functions and naked constructors do not handle `return` specially.</span>
<span class="line-added">3358     if (isConstructor() &amp;&amp; constructorKind() != ConstructorKind::Naked) {</span>
3359         bool isDerived = constructorKind() == ConstructorKind::Extends;
3360         bool srcIsThis = src-&gt;index() == m_thisRegister.index();
3361 
3362         if (isDerived &amp;&amp; (srcIsThis || from == ReturnFrom::Finally))
3363             emitTDZCheck(src);
3364 
3365         if (!srcIsThis || from == ReturnFrom::Finally) {
3366             Ref&lt;Label&gt; isObjectLabel = newLabel();
3367             emitJumpIfTrue(emitIsObject(newTemporary(), src), isObjectLabel.get());
3368 
3369             if (isDerived) {
3370                 Ref&lt;Label&gt; isUndefinedLabel = newLabel();
3371                 emitJumpIfTrue(emitIsUndefined(newTemporary(), src), isUndefinedLabel.get());
3372                 emitThrowTypeError(&quot;Cannot return a non-object type in the constructor of a derived class.&quot;);
3373                 emitLabel(isUndefinedLabel.get());
3374                 emitTDZCheck(&amp;m_thisRegister);
3375             }
3376             OpRet::emit(this, &amp;m_thisRegister);
3377             emitLabel(isObjectLabel.get());
3378         }
</pre>
<hr />
<pre>
3437 
3438     OpConstruct::emit(this, dst, func, callArguments.argumentCountIncludingThis(), callArguments.stackOffset());
3439 
3440     if (expectedFunction != NoExpectedFunction)
3441         emitLabel(done.get());
3442 
3443     return dst;
3444 }
3445 
3446 RegisterID* BytecodeGenerator::emitStrcat(RegisterID* dst, RegisterID* src, int count)
3447 {
3448     OpStrcat::emit(this, dst, src, count);
3449     return dst;
3450 }
3451 
3452 void BytecodeGenerator::emitToPrimitive(RegisterID* dst, RegisterID* src)
3453 {
3454     OpToPrimitive::emit(this, dst, src);
3455 }
3456 
<span class="line-added">3457 RegisterID* BytecodeGenerator::emitToPropertyKey(RegisterID* dst, RegisterID* src)</span>
<span class="line-added">3458 {</span>
<span class="line-added">3459     OpToPropertyKey::emit(this, dst, src);</span>
<span class="line-added">3460     return dst;</span>
<span class="line-added">3461 }</span>
<span class="line-added">3462 </span>
3463 void BytecodeGenerator::emitGetScope()
3464 {
3465     OpGetScope::emit(this, scopeRegister());
3466 }
3467 
3468 RegisterID* BytecodeGenerator::emitPushWithScope(RegisterID* objectScope)
3469 {
3470     pushLocalControlFlowScope();
3471     RegisterID* newScope = newBlockScopeVariable();
3472     newScope-&gt;ref();
3473 
3474     OpPushWithScope::emit(this, newScope, scopeRegister(), objectScope);
3475 
3476     move(scopeRegister(), newScope);
3477     m_lexicalScopeStack.append({ nullptr, newScope, true, 0 });
3478 
3479     return newScope;
3480 }
3481 
3482 RegisterID* BytecodeGenerator::emitGetParentScope(RegisterID* dst, RegisterID* scope)
3483 {
3484     OpGetParentScope::emit(this, dst, scope);
3485     return dst;
3486 }
3487 






3488 void BytecodeGenerator::emitPopWithScope()
3489 {
<span class="line-modified">3490     emitGetParentScope(scopeRegister(), scopeRegister());</span>
3491     popLocalControlFlowScope();
3492     auto stackEntry = m_lexicalScopeStack.takeLast();
3493     stackEntry.m_scope-&gt;deref();
3494     RELEASE_ASSERT(stackEntry.m_isWithScope);
3495 }
3496 
3497 void BytecodeGenerator::emitDebugHook(DebugHookType debugHookType, const JSTextPosition&amp; divot)
3498 {
3499     if (!shouldEmitDebugHooks())
3500         return;
3501 
3502     emitExpressionInfo(divot, divot, divot);
3503     OpDebug::emit(this, debugHookType, false);
3504 }
3505 
3506 void BytecodeGenerator::emitDebugHook(DebugHookType debugHookType, unsigned line, unsigned charOffset, unsigned lineStart)
3507 {
3508     emitDebugHook(debugHookType, JSTextPosition(line, charOffset, lineStart));
3509 }
3510 
</pre>
<hr />
<pre>
3591             }
3592         }
3593         return nullptr;
3594     }
3595 
3596     // Continue to the loop nested nearest to the label scope that matches
3597     // &#39;name&#39;.
3598     LabelScope* result = nullptr;
3599     for (int i = m_labelScopes.size() - 1; i &gt;= 0; --i) {
3600         LabelScope&amp; scope = m_labelScopes[i];
3601         if (scope.type() == LabelScope::Loop) {
3602             ASSERT(scope.continueTarget());
3603             result = &amp;scope;
3604         }
3605         if (scope.name() &amp;&amp; *scope.name() == name)
3606             return result; // may be null.
3607     }
3608     return nullptr;
3609 }
3610 











3611 void BytecodeGenerator::allocateAndEmitScope()
3612 {
3613     m_scopeRegister = addVar();
3614     m_scopeRegister-&gt;ref();
3615     m_codeBlock-&gt;setScopeRegister(scopeRegister()-&gt;virtualRegister());
3616     emitGetScope();
3617     m_topMostScope = addVar();
3618     move(m_topMostScope, scopeRegister());
3619 }
3620 
3621 TryData* BytecodeGenerator::pushTry(Label&amp; start, Label&amp; handlerLabel, HandlerType handlerType)
3622 {
3623     m_tryData.append(TryData { handlerLabel, handlerType });
3624     TryData* result = &amp;m_tryData.last();
3625 
3626     m_tryContextStack.append(TryContext {
3627         start,
3628         result
3629     });
3630 
</pre>
<hr />
<pre>
3761 {
3762     emitThrowStaticError(ErrorType::Error, Identifier::fromString(m_vm, &quot;Out of memory&quot;));
3763 }
3764 
3765 void BytecodeGenerator::emitPushFunctionNameScope(const Identifier&amp; property, RegisterID* callee, bool isCaptured)
3766 {
3767     // There is some nuance here:
3768     // If we&#39;re in strict mode code, the function name scope variable acts exactly like a &quot;const&quot; variable.
3769     // If we&#39;re not in strict mode code, we want to allow bogus assignments to the name scoped variable.
3770     // This means any assignment to the variable won&#39;t throw, but it won&#39;t actually assign a new value to it.
3771     // To accomplish this, we don&#39;t report that this scope is a lexical scope. This will prevent
3772     // any throws when trying to assign to the variable (while still ensuring it keeps its original
3773     // value). There is some ugliness and exploitation of a leaky abstraction here, but it&#39;s better than
3774     // having a completely new op code and a class to handle name scopes which are so close in functionality
3775     // to lexical environments.
3776     VariableEnvironment nameScopeEnvironment;
3777     auto addResult = nameScopeEnvironment.add(property);
3778     if (isCaptured)
3779         addResult.iterator-&gt;value.setIsCaptured();
3780     addResult.iterator-&gt;value.setIsConst(); // The function name scope name acts like a const variable.
<span class="line-modified">3781     unsigned numVars = m_codeBlock-&gt;numVars();</span>
3782     pushLexicalScopeInternal(nameScopeEnvironment, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, TDZRequirement::NotUnderTDZ, ScopeType::FunctionNameScope, ScopeRegisterType::Var);
<span class="line-modified">3783     ASSERT_UNUSED(numVars, m_codeBlock-&gt;numVars() == static_cast&lt;int&gt;(numVars + 1)); // Should have only created one new &quot;var&quot; for the function name scope.</span>
3784     bool shouldTreatAsLexicalVariable = isStrictMode();
3785     Variable functionVar = variableForLocalEntry(property, m_lexicalScopeStack.last().m_symbolTable-&gt;get(NoLockingNecessary, property.impl()), m_lexicalScopeStack.last().m_symbolTableConstantIndex, shouldTreatAsLexicalVariable);
3786     emitPutToScope(m_lexicalScopeStack.last().m_scope, functionVar, callee, ThrowIfNotFound, InitializationMode::NotInitialization);
3787 }
3788 
3789 void BytecodeGenerator::pushLocalControlFlowScope()
3790 {
3791     ControlFlowScope scope(ControlFlowScope::Label, currentLexicalScopeIndex());
3792     m_controlFlowScopeStack.append(WTFMove(scope));
3793     m_localScopeDepth++;
3794 }
3795 
3796 void BytecodeGenerator::popLocalControlFlowScope()
3797 {
3798     ASSERT(m_controlFlowScopeStack.size());
3799     ASSERT(!m_controlFlowScopeStack.last().isFinallyScope());
3800     m_controlFlowScopeStack.removeLast();
3801     m_localScopeDepth--;
3802 }
3803 
</pre>
<hr />
<pre>
3854 
3855 static int32_t keyForCharacterSwitch(ExpressionNode* node, int32_t min, int32_t max)
3856 {
3857     UNUSED_PARAM(max);
3858     ASSERT(node-&gt;isString());
3859     StringImpl* clause = static_cast&lt;StringNode*&gt;(node)-&gt;value().impl();
3860     ASSERT(clause-&gt;length() == 1);
3861 
3862     int32_t key = (*clause)[0];
3863     ASSERT(key &gt;= min);
3864     ASSERT(key &lt;= max);
3865     return key - min;
3866 }
3867 
3868 static void prepareJumpTableForSwitch(
3869     UnlinkedSimpleJumpTable&amp; jumpTable, int32_t switchAddress, uint32_t clauseCount,
3870     const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp; labels, ExpressionNode** nodes, int32_t min, int32_t max,
3871     int32_t (*keyGetter)(ExpressionNode*, int32_t min, int32_t max))
3872 {
3873     jumpTable.min = min;
<span class="line-modified">3874     jumpTable.branchOffsets = RefCountedArray&lt;int32_t&gt;(max - min + 1);</span>
<span class="line-modified">3875     std::fill(jumpTable.branchOffsets.begin(), jumpTable.branchOffsets.end(), 0);</span>
3876     for (uint32_t i = 0; i &lt; clauseCount; ++i) {
3877         // We&#39;re emitting this after the clause labels should have been fixed, so
3878         // the labels should not be &quot;forward&quot; references
3879         ASSERT(!labels[i]-&gt;isForward());
3880         jumpTable.add(keyGetter(nodes[i], min, max), labels[i]-&gt;bind(switchAddress));
3881     }
3882 }
3883 
3884 static void prepareJumpTableForStringSwitch(UnlinkedStringJumpTable&amp; jumpTable, int32_t switchAddress, uint32_t clauseCount, const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp; labels, ExpressionNode** nodes)
3885 {
3886     for (uint32_t i = 0; i &lt; clauseCount; ++i) {
3887         // We&#39;re emitting this after the clause labels should have been fixed, so
3888         // the labels should not be &quot;forward&quot; references
3889         ASSERT(!labels[i]-&gt;isForward());
3890 
3891         ASSERT(nodes[i]-&gt;isString());
3892         StringImpl* clause = static_cast&lt;StringNode*&gt;(nodes[i])-&gt;value().impl();
3893         jumpTable.offsetTable.add(clause, UnlinkedStringJumpTable::OffsetLocation { labels[i]-&gt;bind(switchAddress) });
3894     }
3895 }
</pre>
<hr />
<pre>
4273 
4274 void BytecodeGenerator::pushIndexedForInScope(RegisterID* localRegister, RegisterID* indexRegister)
4275 {
4276     if (!localRegister)
4277         return;
4278     unsigned bodyBytecodeStartOffset = instructions().size();
4279     m_forInContextStack.append(adoptRef(*new IndexedForInContext(localRegister, indexRegister, bodyBytecodeStartOffset)));
4280 }
4281 
4282 void BytecodeGenerator::popIndexedForInScope(RegisterID* localRegister)
4283 {
4284     if (!localRegister)
4285         return;
4286     unsigned bodyBytecodeEndOffset = instructions().size();
4287     m_forInContextStack.last()-&gt;asIndexedForInContext().finalize(*this, m_codeBlock.get(), bodyBytecodeEndOffset);
4288     m_forInContextStack.removeLast();
4289 }
4290 
4291 RegisterID* BytecodeGenerator::emitLoadArrowFunctionLexicalEnvironment(const Identifier&amp; identifier)
4292 {
<span class="line-modified">4293     ASSERT(m_codeBlock-&gt;isArrowFunction() || m_codeBlock-&gt;isArrowFunctionContext() || constructorKind() == ConstructorKind::Extends || m_codeType == EvalCode || m_codeBlock-&gt;parseMode() == SourceParseMode::InstanceFieldInitializerMode);</span>
4294 
4295     return emitResolveScope(nullptr, variable(identifier, ThisResolutionType::Scoped));
4296 }
4297 
4298 void BytecodeGenerator::emitLoadThisFromArrowFunctionLexicalEnvironment()
4299 {
4300     emitGetFromScope(thisRegister(), emitLoadArrowFunctionLexicalEnvironment(propertyNames().thisIdentifier), variable(propertyNames().thisIdentifier, ThisResolutionType::Scoped), DoNotThrowIfNotFound);
4301 }
4302 
4303 RegisterID* BytecodeGenerator::emitLoadNewTargetFromArrowFunctionLexicalEnvironment()
4304 {
4305     Variable newTargetVar = variable(propertyNames().builtinNames().newTargetLocalPrivateName());
4306 
4307     return emitGetFromScope(m_newTargetRegister, emitLoadArrowFunctionLexicalEnvironment(propertyNames().builtinNames().newTargetLocalPrivateName()), newTargetVar, ThrowIfNotFound);
4308 
4309 }
4310 
4311 RegisterID* BytecodeGenerator::emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment()
4312 {
4313     Variable protoScopeVar = variable(propertyNames().builtinNames().derivedConstructorPrivateName());
4314     return emitGetFromScope(newTemporary(), emitLoadArrowFunctionLexicalEnvironment(propertyNames().builtinNames().derivedConstructorPrivateName()), protoScopeVar, ThrowIfNotFound);
4315 }
4316 
<span class="line-added">4317 RegisterID* BytecodeGenerator::emitLoadDerivedConstructor()</span>
<span class="line-added">4318 {</span>
<span class="line-added">4319     ASSERT(constructorKind() == ConstructorKind::Extends || isDerivedConstructorContext());</span>
<span class="line-added">4320     if (constructorKind() == ConstructorKind::Extends)</span>
<span class="line-added">4321         return &amp;m_calleeRegister;</span>
<span class="line-added">4322     return emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment();</span>
<span class="line-added">4323 }</span>
<span class="line-added">4324 </span>
4325 RegisterID* BytecodeGenerator::ensureThis()
4326 {
4327     if (constructorKind() == ConstructorKind::Extends || isDerivedConstructorContext()) {
4328         if ((needsToUpdateArrowFunctionContext() &amp;&amp; isSuperCallUsedInInnerArrowFunction()) || m_codeBlock-&gt;parseMode() == SourceParseMode::AsyncArrowFunctionBodyMode)
4329             emitLoadThisFromArrowFunctionLexicalEnvironment();
4330 
4331         emitTDZCheck(thisRegister());
4332     }
4333 
4334     return thisRegister();
4335 }
4336 
4337 bool BytecodeGenerator::isThisUsedInInnerArrowFunction()
4338 {
4339     return m_scopeNode-&gt;doAnyInnerArrowFunctionsUseThis() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperProperty() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperCall() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval() || m_codeBlock-&gt;usesEval();
4340 }
4341 
4342 bool BytecodeGenerator::isArgumentsUsedInInnerArrowFunction()
4343 {
4344     return m_scopeNode-&gt;doAnyInnerArrowFunctionsUseArguments() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval();
</pre>
<hr />
<pre>
4409 }
4410 
4411 RegisterID* BytecodeGenerator::emitRestParameter(RegisterID* result, unsigned numParametersToSkip)
4412 {
4413     RefPtr&lt;RegisterID&gt; restArrayLength = newTemporary();
4414     OpGetRestLength::emit(this, restArrayLength.get(), numParametersToSkip);
4415 
4416     OpCreateRest::emit(this, result, restArrayLength.get(), numParametersToSkip);
4417 
4418     return result;
4419 }
4420 
4421 void BytecodeGenerator::emitRequireObjectCoercible(RegisterID* value, const String&amp; error)
4422 {
4423     Ref&lt;Label&gt; target = newLabel();
4424     OpJnundefinedOrNull::emit(this, value, target-&gt;bind(this));
4425     emitThrowTypeError(error);
4426     emitLabel(target.get());
4427 }
4428 
<span class="line-modified">4429 void BytecodeGenerator::emitYieldPoint(RegisterID* argument, JSAsyncGenerator::AsyncGeneratorSuspendReason result)</span>
4430 {
4431     Ref&lt;Label&gt; mergePoint = newLabel();
4432     unsigned yieldPointIndex = m_yieldPoints++;
4433     emitGeneratorStateChange(yieldPointIndex + 1);
4434 
4435     if (parseMode() == SourceParseMode::AsyncGeneratorBodyMode) {
4436         int suspendReason = static_cast&lt;int32_t&gt;(result);
<span class="line-modified">4437         emitPutInternalField(generatorRegister(), static_cast&lt;unsigned&gt;(JSAsyncGenerator::Field::SuspendReason), emitLoad(nullptr, jsNumber(suspendReason)));</span>
4438     }
4439 
4440     // Split the try range here.
4441     Ref&lt;Label&gt; savePoint = newEmittedLabel();
4442     for (unsigned i = m_tryContextStack.size(); i--;) {
4443         TryContext&amp; context = m_tryContextStack[i];
4444         m_tryRanges.append(TryRange {
4445             context.start.copyRef(),
4446             savePoint.copyRef(),
4447             context.tryData
4448         });
4449         // Try range will be restared at the merge point.
4450         context.start = mergePoint.get();
4451     }
4452     Vector&lt;TryContext&gt; savedTryContextStack;
4453     m_tryContextStack.swap(savedTryContextStack);
4454 
4455 
4456 #if CPU(NEEDS_ALIGNED_ACCESS)
4457     // conservatively align for the bytecode rewriter: it will delete this yield and
4458     // append a fragment, so we make sure that the start of the fragments is aligned
4459     while (m_writer.position() % OpcodeSize::Wide32)
4460         OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);
4461 #endif
4462     OpYield::emit(this, generatorFrameRegister(), yieldPointIndex, argument);
4463 
4464     // Restore the try contexts, which start offset is updated to the merge point.
4465     m_tryContextStack.swap(savedTryContextStack);
4466     emitLabel(mergePoint.get());
4467 }
4468 
<span class="line-modified">4469 RegisterID* BytecodeGenerator::emitYield(RegisterID* argument, JSAsyncGenerator::AsyncGeneratorSuspendReason result)</span>
4470 {
4471     emitYieldPoint(argument, result);
4472 
4473     Ref&lt;Label&gt; normalLabel = newLabel();
4474     RefPtr&lt;RegisterID&gt; condition = newTemporary();
<span class="line-modified">4475     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::NormalMode))));</span>
4476     emitJumpIfTrue(condition.get(), normalLabel.get());
4477 
4478     Ref&lt;Label&gt; throwLabel = newLabel();
<span class="line-modified">4479     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::ThrowMode))));</span>
4480     emitJumpIfTrue(condition.get(), throwLabel.get());
4481     // Return.
4482     {
4483         RefPtr&lt;RegisterID&gt; returnRegister = generatorValueRegister();
4484         bool hasFinally = emitReturnViaFinallyIfNeeded(returnRegister.get());
4485         if (!hasFinally)
4486             emitReturn(returnRegister.get());
4487     }
4488 
4489     // Throw.
4490     emitLabel(throwLabel.get());
4491     emitThrow(generatorValueRegister());
4492 
4493     // Normal.
4494     emitLabel(normalLabel.get());
4495     return generatorValueRegister();
4496 }
4497 
4498 RegisterID* BytecodeGenerator::emitCallIterator(RegisterID* iterator, RegisterID* argument, ThrowableExpressionData* node)
4499 {
4500     CallArguments args(*this, nullptr);
4501     move(args.thisRegister(), argument);
4502     emitCall(iterator, iterator, NoExpectedFunction, args, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4503 
4504     return iterator;
4505 }
4506 
4507 void BytecodeGenerator::emitAwait(RegisterID* value)
4508 {
<span class="line-modified">4509     emitYield(value, JSAsyncGenerator::AsyncGeneratorSuspendReason::Await);</span>
4510     move(value, generatorValueRegister());
4511 }
4512 
4513 RegisterID* BytecodeGenerator::emitGetIterator(RegisterID* argument, ThrowableExpressionData* node)
4514 {
4515     RefPtr&lt;RegisterID&gt; iterator = emitGetById(newTemporary(), argument, propertyNames().iteratorSymbol);
4516     emitCallIterator(iterator.get(), argument, node);
4517 
4518     return iterator.get();
4519 }
4520 
4521 RegisterID* BytecodeGenerator::emitGetAsyncIterator(RegisterID* argument, ThrowableExpressionData* node)
4522 {
4523     RefPtr&lt;RegisterID&gt; iterator = emitGetById(newTemporary(), argument, propertyNames().asyncIteratorSymbol);
4524     Ref&lt;Label&gt; asyncIteratorNotFound = newLabel();
4525     Ref&lt;Label&gt; asyncIteratorFound = newLabel();
4526     Ref&lt;Label&gt; iteratorReceived = newLabel();
4527 
4528     emitJumpIfTrue(emitUnaryOp&lt;OpEqNull&gt;(newTemporary(), iterator.get()), asyncIteratorNotFound.get());
4529 
4530     emitJump(asyncIteratorFound.get());
4531     emitLabel(asyncIteratorNotFound.get());
4532 
4533     RefPtr&lt;RegisterID&gt; commonIterator = emitGetIterator(argument, node);
4534     move(iterator.get(), commonIterator.get());
4535 
4536     RefPtr&lt;RegisterID&gt; nextMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().next);
4537 
<span class="line-modified">4538     RefPtr&lt;RegisterID&gt; createAsyncFromSyncIterator = moveLinkTimeConstant(nullptr, LinkTimeConstant::createAsyncFromSyncIterator);</span>



4539 
4540     CallArguments args(*this, nullptr, 2);
4541     emitLoad(args.thisRegister(), jsUndefined());
4542 
4543     move(args.argumentRegister(0), iterator.get());
4544     move(args.argumentRegister(1), nextMethod.get());
4545 
4546     JSTextPosition divot(m_scopeNode-&gt;firstLine(), m_scopeNode-&gt;startOffset(), m_scopeNode-&gt;lineStartOffset());
4547     emitCall(iterator.get(), createAsyncFromSyncIterator.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
4548 
4549     emitJump(iteratorReceived.get());
4550 
4551     emitLabel(asyncIteratorFound.get());
4552     emitCallIterator(iterator.get(), argument, node);
4553     emitLabel(iteratorReceived.get());
4554 
4555     return iterator.get();
4556 }
4557 
4558 RegisterID* BytecodeGenerator::emitDelegateYield(RegisterID* argument, ThrowableExpressionData* node)
4559 {
4560     RefPtr&lt;RegisterID&gt; value = newTemporary();
4561     {
4562         RefPtr&lt;RegisterID&gt; iterator = parseMode() == SourceParseMode::AsyncGeneratorBodyMode ? emitGetAsyncIterator(argument, node) : emitGetIterator(argument, node);
4563         RefPtr&lt;RegisterID&gt; nextMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().next);
4564 
4565         Ref&lt;Label&gt; loopDone = newLabel();
4566         {
4567             Ref&lt;Label&gt; nextElement = newLabel();
4568             emitLoad(value.get(), jsUndefined());
4569 
4570             emitJump(nextElement.get());
4571 
4572             Ref&lt;Label&gt; loopStart = newLabel();
4573             emitLabel(loopStart.get());
4574             emitLoopHint();
4575 
4576             Ref&lt;Label&gt; branchOnResult = newLabel();
4577             {
<span class="line-modified">4578                 emitYieldPoint(value.get(), JSAsyncGenerator::AsyncGeneratorSuspendReason::Yield);</span>
4579 
4580                 Ref&lt;Label&gt; normalLabel = newLabel();
4581                 Ref&lt;Label&gt; returnLabel = newLabel();
4582                 {
4583                     RefPtr&lt;RegisterID&gt; condition = newTemporary();
<span class="line-modified">4584                     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::NormalMode))));</span>
4585                     emitJumpIfTrue(condition.get(), normalLabel.get());
4586 
<span class="line-modified">4587                     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::ReturnMode))));</span>
4588                     emitJumpIfTrue(condition.get(), returnLabel.get());
4589 
4590                     // Fallthrough to ThrowMode.
4591                 }
4592 
4593                 // Throw.
4594                 {
4595                     Ref&lt;Label&gt; throwMethodFound = newLabel();
4596                     RefPtr&lt;RegisterID&gt; throwMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().throwKeyword);
4597                     emitJumpIfFalse(emitIsUndefined(newTemporary(), throwMethod.get()), throwMethodFound.get());
4598 
4599                     EmitAwait emitAwaitInIteratorClose = parseMode() == SourceParseMode::AsyncGeneratorBodyMode ? EmitAwait::Yes : EmitAwait::No;
4600                     emitIteratorClose(iterator.get(), node, emitAwaitInIteratorClose);
4601 
4602                     emitThrowTypeError(&quot;Delegated generator does not have a &#39;throw&#39; method.&quot;_s);
4603 
4604                     emitLabel(throwMethodFound.get());
4605                     CallArguments throwArguments(*this, nullptr, 1);
4606                     move(throwArguments.thisRegister(), iterator.get());
4607                     move(throwArguments.argumentRegister(0), generatorValueRegister());
</pre>
<hr />
<pre>
4669             emitJumpIfTrue(emitIsObject(newTemporary(), value.get()), iteratorValueIsObject.get());
4670             emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
4671             emitLabel(iteratorValueIsObject.get());
4672 
4673             emitJumpIfTrue(emitGetById(newTemporary(), value.get(), propertyNames().done), loopDone.get());
4674             emitGetById(value.get(), value.get(), propertyNames().value);
4675 
4676             emitJump(loopStart.get());
4677         }
4678         emitLabel(loopDone.get());
4679     }
4680 
4681     emitGetById(value.get(), value.get(), propertyNames().value);
4682     return value.get();
4683 }
4684 
4685 
4686 void BytecodeGenerator::emitGeneratorStateChange(int32_t state)
4687 {
4688     RegisterID* completedState = emitLoad(nullptr, jsNumber(state));
<span class="line-modified">4689     static_assert(static_cast&lt;unsigned&gt;(JSGenerator::Field::State) == static_cast&lt;unsigned&gt;(JSAsyncGenerator::Field::State));</span>
<span class="line-added">4690     emitPutInternalField(generatorRegister(), static_cast&lt;unsigned&gt;(JSGenerator::Field::State), completedState);</span>
4691 }
4692 
4693 bool BytecodeGenerator::emitJumpViaFinallyIfNeeded(int targetLabelScopeDepth, Label&amp; jumpTarget)
4694 {
4695     ASSERT(labelScopeDepth() - targetLabelScopeDepth &gt;= 0);
4696     size_t numberOfScopesToCheckForFinally = labelScopeDepth() - targetLabelScopeDepth;
4697     ASSERT(numberOfScopesToCheckForFinally &lt;= m_controlFlowScopeStack.size());
4698     if (!numberOfScopesToCheckForFinally)
4699         return false;
4700 
4701     FinallyContext* innermostFinallyContext = nullptr;
4702     FinallyContext* outermostFinallyContext = nullptr;
4703     size_t scopeIndex = m_controlFlowScopeStack.size() - 1;
4704     while (numberOfScopesToCheckForFinally--) {
4705         ControlFlowScope* scope = &amp;m_controlFlowScopeStack[scopeIndex--];
4706         if (scope-&gt;isFinallyScope()) {
4707             FinallyContext* finallyContext = scope-&gt;finallyContext;
4708             if (!innermostFinallyContext)
4709                 innermostFinallyContext = finallyContext;
4710             outermostFinallyContext = finallyContext;
</pre>
<hr />
<pre>
4928     emitLabel(m_optionalChainTargetStack.takeLast().get());
4929 }
4930 
4931 void BytecodeGenerator::popOptionalChainTarget(RegisterID* dst, bool isDelete)
4932 {
4933     Ref&lt;Label&gt; endLabel = newLabel();
4934     emitJump(endLabel.get());
4935 
4936     popOptionalChainTarget();
4937     emitLoad(dst, isDelete ? jsBoolean(true) : jsUndefined());
4938 
4939     emitLabel(endLabel.get());
4940 }
4941 
4942 void BytecodeGenerator::emitOptionalCheck(RegisterID* src)
4943 {
4944     ASSERT(m_optionalChainTargetStack.size());
4945     emitJumpIfTrue(emitIsUndefinedOrNull(newTemporary(), src), m_optionalChainTargetStack.last().get());
4946 }
4947 
<span class="line-modified">4948 void ForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlockGenerator* codeBlock, unsigned bodyBytecodeEndOffset)</span>
4949 {
4950     // Lexically invalidating ForInContexts is kind of weak sauce, but it only occurs if
4951     // either of the following conditions is true:
4952     //
4953     // (1) The loop iteration variable is re-assigned within the body of the loop.
4954     // (2) The loop iteration variable is captured in the lexical scope of the function.
4955     //
4956     // These two situations occur sufficiently rarely that it&#39;s okay to use this style of
4957     // &quot;analysis&quot; to make iteration faster. If we didn&#39;t want to do this, we would either have
4958     // to perform some flow-sensitive analysis to see if/when the loop iteration variable was
4959     // reassigned, or we&#39;d have to resort to runtime checks to see if the variable had been
4960     // reassigned from its original value.
4961 
4962     for (unsigned offset = bodyBytecodeStartOffset(); isValid() &amp;&amp; offset &lt; bodyBytecodeEndOffset;) {
4963         auto instruction = generator.instructions().at(offset);
<span class="line-modified">4964         ASSERT(!instruction-&gt;is&lt;OpEnter&gt;());</span>
<span class="line-modified">4965         computeDefsForBytecodeIndex(codeBlock, instruction.ptr(), [&amp;] (VirtualRegister operand) {</span>


4966             if (local()-&gt;virtualRegister() == operand)
4967                 invalidate();
4968         });
4969         offset += instruction-&gt;size();
4970     }
4971 }
4972 
<span class="line-modified">4973 void StructureForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlockGenerator* codeBlock, unsigned bodyBytecodeEndOffset)</span>
4974 {
4975     Base::finalize(generator, codeBlock, bodyBytecodeEndOffset);
4976     if (isValid())
4977         return;
4978 
4979     OpcodeID lastOpcodeID = generator.m_lastOpcodeID;
4980     InstructionStream::MutableRef lastInstruction = generator.m_lastInstruction;
4981     for (const auto&amp; instTuple : m_getInsts) {
4982         unsigned instIndex = std::get&lt;0&gt;(instTuple);
4983         int propertyRegIndex = std::get&lt;1&gt;(instTuple);
4984         auto instruction = generator.m_writer.ref(instIndex);
4985         auto end = instIndex + instruction-&gt;size();
4986         ASSERT(instruction-&gt;isWide32());
4987 
4988         generator.m_writer.seek(instIndex);
4989 
4990         auto bytecode = instruction-&gt;as&lt;OpGetDirectPname&gt;();
4991 
4992         // disable peephole optimizations
4993         generator.m_lastOpcodeID = op_end;
4994 
4995         // Change the opcode to get_by_val.
4996         // 1. dst stays the same.
4997         // 2. base stays the same.
4998         // 3. property gets switched to the original property.
4999         OpGetByVal::emit&lt;OpcodeSize::Wide32&gt;(&amp;generator, bytecode.m_dst, bytecode.m_base, VirtualRegister(propertyRegIndex));
5000 
5001         // 4. nop out the remaining bytes
5002         while (generator.m_writer.position() &lt; end)
5003             OpNop::emit&lt;OpcodeSize::Narrow&gt;(&amp;generator);
5004     }
5005     generator.m_writer.seek(generator.m_writer.size());
5006     if (generator.m_lastInstruction.offset() + generator.m_lastInstruction-&gt;size() != generator.m_writer.size()) {
5007         generator.m_lastOpcodeID = lastOpcodeID;
5008         generator.m_lastInstruction = lastInstruction;
5009     }
5010 }
5011 
<span class="line-modified">5012 void IndexedForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlockGenerator* codeBlock, unsigned bodyBytecodeEndOffset)</span>
5013 {
5014     Base::finalize(generator, codeBlock, bodyBytecodeEndOffset);
5015     if (isValid())
5016         return;
5017 
5018     for (const auto&amp; instPair : m_getInsts) {
5019         unsigned instIndex = instPair.first;
5020         int propertyRegIndex = instPair.second;
5021         generator.m_writer.ref(instIndex)-&gt;cast&lt;OpGetByVal&gt;()-&gt;setProperty(VirtualRegister(propertyRegIndex), []() {
5022             ASSERT_NOT_REACHED();
5023             return VirtualRegister();
5024         });
5025     }
5026 }
5027 
5028 void StaticPropertyAnalysis::record()
5029 {
5030     auto* instruction = m_instructionRef.ptr();
5031     auto size = m_propertyIndexes.size();
5032     switch (instruction-&gt;opcodeID()) {
5033     case OpNewObject::opcodeID:
5034         instruction-&gt;cast&lt;OpNewObject&gt;()-&gt;setInlineCapacity(size, []() {
5035             return 255;
5036         });
5037         return;
5038     case OpCreateThis::opcodeID:
5039         instruction-&gt;cast&lt;OpCreateThis&gt;()-&gt;setInlineCapacity(size, []() {
5040             return 255;
5041         });
5042         return;
5043     default:
5044         ASSERT_NOT_REACHED();
5045     }
5046 }
5047 
5048 void BytecodeGenerator::emitToThis()
5049 {
5050     OpToThis::emit(this, kill(&amp;m_thisRegister));

5051 }
5052 
5053 } // namespace JSC
5054 
5055 namespace WTF {
5056 
5057 void printInternal(PrintStream&amp; out, JSC::Variable::VariableKind kind)
5058 {
5059     switch (kind) {
5060     case JSC::Variable::NormalVariable:
5061         out.print(&quot;Normal&quot;);
5062         return;
5063     case JSC::Variable::SpecialVariable:
5064         out.print(&quot;Special&quot;);
5065         return;
5066     }
5067     RELEASE_ASSERT_NOT_REACHED();
5068 }
5069 
5070 } // namespace WTF
</pre>
</td>
</tr>
</table>
<center><a href="../bytecode/Watchpoint.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeGenerator.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
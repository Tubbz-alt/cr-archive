<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerBacking.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 102 enum ShouldRespectOverflowClip {
 103     IgnoreOverflowClip,
 104     RespectOverflowClip
 105 };
 106 
 107 enum ShouldApplyRootOffsetToFragments {
 108     ApplyRootOffsetToFragments,
 109     IgnoreRootOffsetForFragments
 110 };
 111 
 112 enum class RequestState {
 113     Unknown,
 114     DontCare,
 115     False,
 116     True,
 117     Undetermined
 118 };
 119 
 120 enum class IndirectCompositingReason {
 121     None,

 122     Stacking,
 123     OverflowScrollPositioning,
 124     Overlap,
 125     BackgroundLayer,
 126     GraphicalEffect, // opacity, mask, filter, transform etc.
 127     Perspective,
 128     Preserve3D
 129 };
 130 
 131 struct ScrollRectToVisibleOptions {
 132     SelectionRevealMode revealMode { SelectionRevealMode::Reveal };
 133     const ScrollAlignment&amp; alignX { ScrollAlignment::alignCenterIfNeeded };
 134     const ScrollAlignment&amp; alignY { ScrollAlignment::alignCenterIfNeeded };
 135     ShouldAllowCrossOriginScrolling shouldAllowCrossOriginScrolling { ShouldAllowCrossOriginScrolling::No };
 136 };
 137 

 138 class RenderLayer final : public ScrollableArea {
<span class="line-modified"> 139     WTF_MAKE_FAST_ALLOCATED;</span>
 140 public:
 141     friend class RenderReplica;
 142     friend class RenderLayerFilters;
 143     friend class RenderLayerBacking;
 144     friend class RenderLayerCompositor;
 145 
 146     explicit RenderLayer(RenderLayerModelObject&amp;);
 147     virtual ~RenderLayer();
 148 
 149 #if PLATFORM(IOS_FAMILY)
 150     // Called before the renderer&#39;s widget (if any) has been nulled out.
 151     void willBeDestroyed();
 152 #endif
 153     String name() const;
 154 
 155     Page&amp; page() const { return renderer().page(); }
 156     RenderLayerModelObject&amp; renderer() const { return m_renderer; }
 157     RenderBox* renderBox() const { return is&lt;RenderBox&gt;(renderer()) ? &amp;downcast&lt;RenderBox&gt;(renderer()) : nullptr; }
 158 
 159     RenderLayer* parent() const { return m_parent; }
 160     RenderLayer* previousSibling() const { return m_previous; }
 161     RenderLayer* nextSibling() const { return m_next; }
 162     RenderLayer* firstChild() const { return m_first; }
 163     RenderLayer* lastChild() const { return m_last; }
 164     bool isDescendantOf(const RenderLayer&amp;) const;

 165 
 166     // This does an ancestor tree walk. Avoid it!
 167     const RenderLayer* root() const
 168     {
 169         const RenderLayer* curr = this;
 170         while (curr-&gt;parent())
 171             curr = curr-&gt;parent();
 172         return curr;
 173     }
 174 
 175     void addChild(RenderLayer&amp; newChild, RenderLayer* beforeChild = nullptr);
 176     void removeChild(RenderLayer&amp;);
 177 
<span class="line-modified"> 178     void insertOnlyThisLayer();</span>
<span class="line-modified"> 179     void removeOnlyThisLayer();</span>




 180 
 181     bool isNormalFlowOnly() const { return m_isNormalFlowOnly; }
 182 
 183     // isStackingContext is true for layers that we&#39;ve determined should be stacking contexts for painting.
 184     // Not all stacking contexts are CSS stacking contexts.
 185     bool isStackingContext() const { return isCSSStackingContext() || m_isOpportunisticStackingContext; }
 186 
 187     // isCSSStackingContext is true for layers that are stacking contexts from a CSS perspective.
 188     // isCSSStackingContext() =&gt; isStackingContext().
 189     // FIXME: m_forcedStackingContext should affect isStackingContext(), not isCSSStackingContext(), but doing so breaks media control mix-blend-mode.
 190     bool isCSSStackingContext() const { return m_isCSSStackingContext || m_forcedStackingContext; }
 191 
 192     // Gets the enclosing stacking context for this layer, excluding this layer itself.
 193     RenderLayer* stackingContext() const;
 194 
 195     // Gets the enclosing stacking container for this layer, possibly the layer
 196     // itself, if it is a stacking container.
 197     RenderLayer* enclosingStackingContext() { return isStackingContext() ? this : stackingContext(); }
 198 
 199     RenderLayer* paintOrderParent() const;
 200 
 201     void dirtyNormalFlowList();
 202     void dirtyZOrderLists();
 203     void dirtyStackingContextZOrderLists();
 204 
 205     bool normalFlowListDirty() const { return m_normalFlowListDirty; }
 206     bool zOrderListsDirty() const { return m_zOrderListsDirty; }
 207 
<span class="line-modified"> 208 #if !ASSERT_DISABLED</span>
 209     bool layerListMutationAllowed() const { return m_layerListMutationAllowed; }
 210     void setLayerListMutationAllowed(bool flag) { m_layerListMutationAllowed = flag; }
 211 #endif
 212 
 213 private:
 214     // These flags propagate in paint order (z-order tree).
 215     enum class Compositing {
 216         HasDescendantNeedingRequirementsTraversal           = 1 &lt;&lt; 0, // Need to do the overlap-testing tree walk because hierarchy or geometry changed.
 217         HasDescendantNeedingBackingOrHierarchyTraversal     = 1 &lt;&lt; 1, // Need to update geometry, configuration and update the GraphicsLayer tree.
 218 
 219         // Things that trigger HasDescendantNeedingRequirementsTraversal
 220         NeedsPaintOrderChildrenUpdate                       = 1 &lt;&lt; 2, // The paint order children of this layer changed (gained/lost child, order change).
 221         NeedsPostLayoutUpdate                               = 1 &lt;&lt; 3, // Needs compositing to be re-evaluated after layout (it depends on geometry).
 222         DescendantsNeedRequirementsTraversal                = 1 &lt;&lt; 4, // Something changed that forces computeCompositingRequirements to traverse all descendant layers.
 223         SubsequentLayersNeedRequirementsTraversal           = 1 &lt;&lt; 5, // Something changed that forces computeCompositingRequirements to traverse all layers later in paint order.
 224 
 225         // Things that trigger HasDescendantNeedingBackingOrHierarchyTraversal
 226         NeedsGeometryUpdate                                 = 1 &lt;&lt; 6, // This layer needs a geometry update.
 227         NeedsConfigurationUpdate                            = 1 &lt;&lt; 7, // This layer needs a configuration update (updating its internal compositing hierarchy).
 228         NeedsScrollingTreeUpdate                            = 1 &lt;&lt; 8, // Something changed that requires this layer&#39;s scrolling tree node to be updated.
</pre>
<hr />
<pre>
 415     const LayoutPoint&amp; location() const { return m_topLeft; }
 416     void setLocation(const LayoutPoint&amp; p) { m_topLeft = p; }
 417 
 418     const IntSize&amp; size() const { return m_layerSize; }
 419     void setSize(const IntSize&amp; size) { m_layerSize = size; } // Only public for RenderTreeAsText.
 420 
 421     LayoutRect rect() const { return LayoutRect(location(), size()); }
 422 
 423     IntSize visibleSize() const override;
 424     IntSize contentsSize() const override;
 425     IntSize reachableTotalContentsSize() const override;
 426 
 427     int scrollWidth() const;
 428     int scrollHeight() const;
 429 
 430     void panScrollFromPoint(const IntPoint&amp;);
 431 
 432     // Scrolling methods for layers that can scroll their overflow.
 433     void scrollByRecursively(const IntSize&amp; delta, ScrollableArea** scrolledArea = nullptr);
 434 


 435     WEBCORE_EXPORT void scrollToOffset(const ScrollOffset&amp;, ScrollType = ScrollType::Programmatic, ScrollClamping = ScrollClamping::Clamped);
 436 
 437     void scrollToXPosition(int x, ScrollType, ScrollClamping = ScrollClamping::Clamped);
 438     void scrollToYPosition(int y, ScrollType, ScrollClamping = ScrollClamping::Clamped);
 439 
 440     // These are only used by marquee.
 441     void scrollToXOffset(int x) { scrollToOffset(ScrollOffset(x, scrollOffset().y()), ScrollType::Programmatic, ScrollClamping::Unclamped); }
 442     void scrollToYOffset(int y) { scrollToOffset(ScrollOffset(scrollOffset().x(), y), ScrollType::Programmatic, ScrollClamping::Unclamped); }
 443 
 444     void setPostLayoutScrollPosition(Optional&lt;ScrollPosition&gt;);
 445     void applyPostLayoutScrollPositionIfNeeded();
 446 
 447     void availableContentSizeChanged(AvailableSizeChangeReason) override;
 448 
 449     // &quot;absoluteRect&quot; is in scaled document coordinates.
 450     void scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp;);
 451 
 452     bool scrollsOverflow() const;
 453     bool hasScrollableHorizontalOverflow() const;
 454     bool hasScrollableVerticalOverflow() const;
</pre>
<hr />
<pre>
 630     RenderLayer* ancestorCompositingLayer() const { return enclosingCompositingLayer(ExcludeSelf); }
 631 
 632     RenderLayer* enclosingFilterLayer(IncludeSelfOrNot = IncludeSelf) const;
 633     RenderLayer* enclosingFilterRepaintLayer() const;
 634     void setFilterBackendNeedsRepaintingInRect(const LayoutRect&amp;);
 635     bool hasAncestorWithFilterOutsets() const;
 636 
 637     bool canUseOffsetFromAncestor() const
 638     {
 639         // FIXME: This really needs to know if there are transforms on this layer and any of the layers
 640         // between it and the ancestor in question.
 641         return !renderer().hasTransform() &amp;&amp; !renderer().isSVGRoot();
 642     }
 643 
 644     // FIXME: adjustForColumns allows us to position compositing layers in columns correctly, but eventually they need to be split across columns too.
 645     enum ColumnOffsetAdjustment { DontAdjustForColumns, AdjustForColumns };
 646     void convertToPixelSnappedLayerCoords(const RenderLayer* ancestorLayer, IntPoint&amp; location, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
 647     LayoutPoint convertToLayerCoords(const RenderLayer* ancestorLayer, const LayoutPoint&amp;, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
 648     LayoutSize offsetFromAncestor(const RenderLayer*, ColumnOffsetAdjustment = DontAdjustForColumns) const;
 649 
<span class="line-modified"> 650     int zIndex() const { return renderer().style().zIndex(); }</span>
 651 
 652     enum PaintLayerFlag {
 653         PaintLayerHaveTransparency                      = 1 &lt;&lt; 0,
 654         PaintLayerAppliedTransform                      = 1 &lt;&lt; 1,
 655         PaintLayerTemporaryClipRects                    = 1 &lt;&lt; 2,
 656         PaintLayerPaintingReflection                    = 1 &lt;&lt; 3,
 657         PaintLayerPaintingOverlayScrollbars             = 1 &lt;&lt; 4,
 658         PaintLayerPaintingCompositingBackgroundPhase    = 1 &lt;&lt; 5,
 659         PaintLayerPaintingCompositingForegroundPhase    = 1 &lt;&lt; 6,
 660         PaintLayerPaintingCompositingMaskPhase          = 1 &lt;&lt; 7,
 661         PaintLayerPaintingCompositingClipPathPhase      = 1 &lt;&lt; 8,
 662         PaintLayerPaintingCompositingScrollingPhase     = 1 &lt;&lt; 9,
 663         PaintLayerPaintingOverflowContents              = 1 &lt;&lt; 10,
 664         PaintLayerPaintingRootBackgroundOnly            = 1 &lt;&lt; 11,
 665         PaintLayerPaintingSkipRootBackground            = 1 &lt;&lt; 12,
 666         PaintLayerPaintingChildClippingMaskPhase        = 1 &lt;&lt; 13,
 667         PaintLayerCollectingEventRegion                 = 1 &lt;&lt; 14,
 668     };
 669     static constexpr OptionSet&lt;PaintLayerFlag&gt; paintLayerPaintingCompositingAllPhasesFlags() { return { PaintLayerPaintingCompositingBackgroundPhase, PaintLayerPaintingCompositingForegroundPhase }; }
 670 
</pre>
<hr />
<pre>
 772     bool hasTransform() const { return renderer().hasTransform(); }
 773     // Note that this transform has the transform-origin baked in.
 774     TransformationMatrix* transform() const { return m_transform.get(); }
 775     // currentTransform computes a transform which takes accelerated animations into account. The
 776     // resulting transform has transform-origin baked in. If the layer does not have a transform,
 777     // returns the identity matrix.
 778     TransformationMatrix currentTransform(RenderStyle::ApplyTransformOrigin = RenderStyle::IncludeTransformOrigin) const;
 779     TransformationMatrix renderableTransform(OptionSet&lt;PaintBehavior&gt;) const;
 780 
 781     // Get the perspective transform, which is applied to transformed sublayers.
 782     // Returns true if the layer has a -webkit-perspective.
 783     // Note that this transform has the perspective-origin baked in.
 784     TransformationMatrix perspectiveTransform() const;
 785     FloatPoint perspectiveOrigin() const;
 786     bool preserves3D() const { return renderer().style().transformStyle3D() == TransformStyle3D::Preserve3D; }
 787     bool has3DTransform() const { return m_transform &amp;&amp; !m_transform-&gt;isAffine(); }
 788     bool hasTransformedAncestor() const { return m_hasTransformedAncestor; }
 789 
 790     void filterNeedsRepaint();
 791     bool hasFilter() const { return renderer().hasFilter(); }


 792     bool hasBackdropFilter() const
 793     {
 794 #if ENABLE(FILTERS_LEVEL_2)
 795         return renderer().hasBackdropFilter();
 796 #else
 797         return false;
 798 #endif
 799     }
 800 
 801 #if ENABLE(CSS_COMPOSITING)
 802     bool hasBlendMode() const { return renderer().hasBlendMode(); }
 803     BlendMode blendMode() const { return static_cast&lt;BlendMode&gt;(m_blendMode); }
 804 
 805     bool isolatesCompositedBlending() const { return m_hasNotIsolatedCompositedBlendingDescendants &amp;&amp; isCSSStackingContext(); }
 806     bool hasNotIsolatedCompositedBlendingDescendants() const { return m_hasNotIsolatedCompositedBlendingDescendants; }
 807     void setHasNotIsolatedCompositedBlendingDescendants(bool hasNotIsolatedCompositedBlendingDescendants)
 808     {
 809         m_hasNotIsolatedCompositedBlendingDescendants = hasNotIsolatedCompositedBlendingDescendants;
 810     }
 811 
</pre>
<hr />
<pre>
 880     ViewportConstrainedNotCompositedReason viewportConstrainedNotCompositedReason() const { return static_cast&lt;ViewportConstrainedNotCompositedReason&gt;(m_viewportConstrainedNotCompositedReason); }
 881 
 882     IndirectCompositingReason indirectCompositingReason() const { return static_cast&lt;IndirectCompositingReason&gt;(m_indirectCompositingReason); }
 883 
 884     bool isRenderFragmentedFlow() const { return renderer().isRenderFragmentedFlow(); }
 885     bool isOutOfFlowRenderFragmentedFlow() const { return renderer().isOutOfFlowRenderFragmentedFlow(); }
 886     bool isInsideFragmentedFlow() const { return renderer().fragmentedFlowState() != RenderObject::NotInsideFragmentedFlow; }
 887     bool isDirtyRenderFragmentedFlow() const
 888     {
 889         ASSERT(isRenderFragmentedFlow());
 890         return zOrderListsDirty() || normalFlowListDirty();
 891     }
 892 
 893     RenderLayer* enclosingFragmentedFlowAncestor() const;
 894 
 895     bool shouldPlaceBlockDirectionScrollbarOnLeft() const final { return renderer().shouldPlaceBlockDirectionScrollbarOnLeft(); }
 896 
 897     void simulateFrequentPaint() { SinglePaintFrequencyTracking { m_paintFrequencyTracker }; }
 898     bool paintingFrequently() const { return m_paintFrequencyTracker.paintingFrequently(); }
 899 
<span class="line-modified"> 900     WEBCORE_EXPORT bool isTransparentOrFullyClippedRespectingParentFrames() const;</span>
 901 
 902     void invalidateEventRegion();
 903 
 904 private:
 905 
 906     void setNextSibling(RenderLayer* next) { m_next = next; }
 907     void setPreviousSibling(RenderLayer* prev) { m_previous = prev; }
 908     void setParent(RenderLayer*);
 909     void setFirstChild(RenderLayer* first) { m_first = first; }
 910     void setLastChild(RenderLayer* last) { m_last = last; }
 911 
 912     void dirtyPaintOrderListsOnChildChange(RenderLayer&amp;);
 913 
 914     bool shouldBeNormalFlowOnly() const;
 915     bool shouldBeCSSStackingContext() const;
 916 
 917     // Return true if changed.
 918     bool setIsNormalFlowOnly(bool);
 919 
 920     bool setIsOpportunisticStackingContext(bool);
 921     bool setIsCSSStackingContext(bool);
 922 
 923     void isStackingContextChanged();
 924 
 925     bool isDirtyStackingContext() const { return m_zOrderListsDirty &amp;&amp; isStackingContext(); }
 926 
 927     void updateZOrderLists();
 928     void rebuildZOrderLists();
<span class="line-modified"> 929     void rebuildZOrderLists(std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;);</span>
<span class="line-modified"> 930     void collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;);</span>
 931     void clearZOrderLists();
 932 
 933     void updateNormalFlowList();
 934 
 935     struct LayerPaintingInfo {
 936         LayerPaintingInfo(RenderLayer* inRootLayer, const LayoutRect&amp; inDirtyRect, OptionSet&lt;PaintBehavior&gt; inPaintBehavior, const LayoutSize&amp; inSubpixelOffset, RenderObject* inSubtreePaintRoot = nullptr, OverlapTestRequestMap* inOverlapTestRequests = nullptr, bool inRequireSecurityOriginAccessForWidgets = false)
 937             : rootLayer(inRootLayer)
 938             , subtreePaintRoot(inSubtreePaintRoot)
 939             , paintDirtyRect(inDirtyRect)
 940             , subpixelOffset(inSubpixelOffset)
 941             , overlapTestRequests(inOverlapTestRequests)
 942             , paintBehavior(inPaintBehavior)
 943             , requireSecurityOriginAccessForWidgets(inRequireSecurityOriginAccessForWidgets)
 944         { }
 945 
 946         RenderLayer* rootLayer;
 947         RenderObject* subtreePaintRoot; // Only paint descendants of this object.
 948         LayoutRect paintDirtyRect; // Relative to rootLayer;
 949         LayoutSize subpixelOffset;
 950         OverlapTestRequestMap* overlapTestRequests; // May be null.
</pre>
<hr />
<pre>
1221 
1222     bool m_visibleContentStatusDirty : 1;
1223     bool m_hasVisibleContent : 1;
1224     bool m_visibleDescendantStatusDirty : 1;
1225     bool m_hasVisibleDescendant : 1;
1226     bool m_registeredScrollableArea : 1;
1227     bool m_isFixedIntersectingViewport : 1;
1228     bool m_behavesAsFixed : 1;
1229 
1230     bool m_3DTransformedDescendantStatusDirty : 1;
1231     bool m_has3DTransformedDescendant : 1;  // Set on a stacking context layer that has 3D descendants anywhere
1232                                             // in a preserves3D hierarchy. Hint to do 3D-aware hit testing.
1233     bool m_hasCompositingDescendant : 1; // In the z-order tree.
1234 
1235     bool m_hasCompositedScrollingAncestor : 1; // In the layer-order tree.
1236     bool m_hasCompositedScrollableOverflow : 1;
1237 
1238     bool m_hasTransformedAncestor : 1;
1239     bool m_has3DTransformedAncestor : 1;
1240 
<span class="line-modified">1241     unsigned m_indirectCompositingReason : 3;</span>
<span class="line-modified">1242     unsigned m_viewportConstrainedNotCompositedReason : 2;</span>
1243 
1244 #if PLATFORM(IOS_FAMILY)
1245 #if ENABLE(IOS_TOUCH_EVENTS)
1246     bool m_registeredAsTouchEventListenerForScrolling : 1;
1247 #endif
1248     bool m_adjustForIOSCaretWhenScrolling : 1;
1249 #endif
1250 
1251     bool m_requiresScrollPositionReconciliation : 1;
1252     bool m_containsDirtyOverlayScrollbars : 1;
1253     bool m_updatingMarqueePosition : 1;
1254 
<span class="line-modified">1255 #if !ASSERT_DISABLED</span>
1256     bool m_layerListMutationAllowed : 1;
1257 #endif
1258 
1259 #if ENABLE(CSS_COMPOSITING)
<span class="line-modified">1260     unsigned m_blendMode : 5;</span>
1261     bool m_hasNotIsolatedCompositedBlendingDescendants : 1;
1262     bool m_hasNotIsolatedBlendingDescendants : 1;
1263     bool m_hasNotIsolatedBlendingDescendantsStatusDirty : 1;
1264 #endif
1265 
1266     RenderLayerModelObject&amp; m_renderer;
1267 
1268     RenderLayer* m_parent { nullptr };
1269     RenderLayer* m_previous { nullptr };
1270     RenderLayer* m_next { nullptr };
1271     RenderLayer* m_first { nullptr };
1272     RenderLayer* m_last { nullptr };
1273 
1274     WeakPtr&lt;RenderLayer&gt; m_backingProviderLayer;
1275 
1276     // For layers that establish stacking contexts, m_posZOrderList holds a sorted list of all the
1277     // descendant layers within the stacking context that have z-indices of 0 or greater
1278     // (auto will count as 0). m_negZOrderList holds descendants within our stacking context with negative
1279     // z-indices.
1280     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_posZOrderList;
</pre>
<hr />
<pre>
1343 
1344 inline void RenderLayer::updateZOrderLists()
1345 {
1346     if (!m_zOrderListsDirty)
1347         return;
1348 
1349     if (!isStackingContext()) {
1350         clearZOrderLists();
1351         m_zOrderListsDirty = false;
1352         return;
1353     }
1354 
1355     rebuildZOrderLists();
1356 }
1357 
1358 inline RenderLayer* RenderLayer::paintOrderParent() const
1359 {
1360     return m_isNormalFlowOnly ? m_parent : stackingContext();
1361 }
1362 
<span class="line-modified">1363 #if !ASSERT_DISABLED</span>
1364 class LayerListMutationDetector {
1365 public:
1366     LayerListMutationDetector(RenderLayer&amp; layer)
1367         : m_layer(layer)
1368         , m_previousMutationAllowedState(layer.layerListMutationAllowed())
1369     {
1370         m_layer.setLayerListMutationAllowed(false);
1371     }
1372 
1373     ~LayerListMutationDetector()
1374     {
1375         m_layer.setLayerListMutationAllowed(m_previousMutationAllowedState);
1376     }
1377 
1378 private:
1379     RenderLayer&amp; m_layer;
1380     bool m_previousMutationAllowedState;
1381 };
<span class="line-modified">1382 #endif</span>
1383 
1384 void makeMatrixRenderable(TransformationMatrix&amp;, bool has3DRendering);
1385 
1386 bool compositedWithOwnBackingStore(const RenderLayer&amp;);
1387 
1388 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, ClipRectsType);
1389 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const RenderLayer&amp;);
1390 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const RenderLayer::ClipRectsContext&amp;);
1391 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, IndirectCompositingReason);
1392 
1393 } // namespace WebCore
1394 
1395 #if ENABLE(TREE_DEBUGGING)
1396 // Outside the WebCore namespace for ease of invocation from lldb.
1397 void showLayerTree(const WebCore::RenderLayer*);
1398 void showPaintOrderTree(const WebCore::RenderLayer*);
1399 void showLayerTree(const WebCore::RenderObject*);
1400 #endif
</pre>
</td>
<td>
<hr />
<pre>
 102 enum ShouldRespectOverflowClip {
 103     IgnoreOverflowClip,
 104     RespectOverflowClip
 105 };
 106 
 107 enum ShouldApplyRootOffsetToFragments {
 108     ApplyRootOffsetToFragments,
 109     IgnoreRootOffsetForFragments
 110 };
 111 
 112 enum class RequestState {
 113     Unknown,
 114     DontCare,
 115     False,
 116     True,
 117     Undetermined
 118 };
 119 
 120 enum class IndirectCompositingReason {
 121     None,
<span class="line-added"> 122     Clipping,</span>
 123     Stacking,
 124     OverflowScrollPositioning,
 125     Overlap,
 126     BackgroundLayer,
 127     GraphicalEffect, // opacity, mask, filter, transform etc.
 128     Perspective,
 129     Preserve3D
 130 };
 131 
 132 struct ScrollRectToVisibleOptions {
 133     SelectionRevealMode revealMode { SelectionRevealMode::Reveal };
 134     const ScrollAlignment&amp; alignX { ScrollAlignment::alignCenterIfNeeded };
 135     const ScrollAlignment&amp; alignY { ScrollAlignment::alignCenterIfNeeded };
 136     ShouldAllowCrossOriginScrolling shouldAllowCrossOriginScrolling { ShouldAllowCrossOriginScrolling::No };
 137 };
 138 
<span class="line-added"> 139 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(RenderLayer);</span>
 140 class RenderLayer final : public ScrollableArea {
<span class="line-modified"> 141     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(RenderLayer);</span>
 142 public:
 143     friend class RenderReplica;
 144     friend class RenderLayerFilters;
 145     friend class RenderLayerBacking;
 146     friend class RenderLayerCompositor;
 147 
 148     explicit RenderLayer(RenderLayerModelObject&amp;);
 149     virtual ~RenderLayer();
 150 
 151 #if PLATFORM(IOS_FAMILY)
 152     // Called before the renderer&#39;s widget (if any) has been nulled out.
 153     void willBeDestroyed();
 154 #endif
 155     String name() const;
 156 
 157     Page&amp; page() const { return renderer().page(); }
 158     RenderLayerModelObject&amp; renderer() const { return m_renderer; }
 159     RenderBox* renderBox() const { return is&lt;RenderBox&gt;(renderer()) ? &amp;downcast&lt;RenderBox&gt;(renderer()) : nullptr; }
 160 
 161     RenderLayer* parent() const { return m_parent; }
 162     RenderLayer* previousSibling() const { return m_previous; }
 163     RenderLayer* nextSibling() const { return m_next; }
 164     RenderLayer* firstChild() const { return m_first; }
 165     RenderLayer* lastChild() const { return m_last; }
 166     bool isDescendantOf(const RenderLayer&amp;) const;
<span class="line-added"> 167     RenderLayer* commonAncestorWithLayer(const RenderLayer&amp;) const;</span>
 168 
 169     // This does an ancestor tree walk. Avoid it!
 170     const RenderLayer* root() const
 171     {
 172         const RenderLayer* curr = this;
 173         while (curr-&gt;parent())
 174             curr = curr-&gt;parent();
 175         return curr;
 176     }
 177 
 178     void addChild(RenderLayer&amp; newChild, RenderLayer* beforeChild = nullptr);
 179     void removeChild(RenderLayer&amp;);
 180 
<span class="line-modified"> 181     enum class LayerChangeTiming {</span>
<span class="line-modified"> 182         StyleChange,</span>
<span class="line-added"> 183         RenderTreeConstruction,</span>
<span class="line-added"> 184     };</span>
<span class="line-added"> 185     void insertOnlyThisLayer(LayerChangeTiming);</span>
<span class="line-added"> 186     void removeOnlyThisLayer(LayerChangeTiming);</span>
 187 
 188     bool isNormalFlowOnly() const { return m_isNormalFlowOnly; }
 189 
 190     // isStackingContext is true for layers that we&#39;ve determined should be stacking contexts for painting.
 191     // Not all stacking contexts are CSS stacking contexts.
 192     bool isStackingContext() const { return isCSSStackingContext() || m_isOpportunisticStackingContext; }
 193 
 194     // isCSSStackingContext is true for layers that are stacking contexts from a CSS perspective.
 195     // isCSSStackingContext() =&gt; isStackingContext().
 196     // FIXME: m_forcedStackingContext should affect isStackingContext(), not isCSSStackingContext(), but doing so breaks media control mix-blend-mode.
 197     bool isCSSStackingContext() const { return m_isCSSStackingContext || m_forcedStackingContext; }
 198 
 199     // Gets the enclosing stacking context for this layer, excluding this layer itself.
 200     RenderLayer* stackingContext() const;
 201 
 202     // Gets the enclosing stacking container for this layer, possibly the layer
 203     // itself, if it is a stacking container.
 204     RenderLayer* enclosingStackingContext() { return isStackingContext() ? this : stackingContext(); }
 205 
 206     RenderLayer* paintOrderParent() const;
 207 
 208     void dirtyNormalFlowList();
 209     void dirtyZOrderLists();
 210     void dirtyStackingContextZOrderLists();
 211 
 212     bool normalFlowListDirty() const { return m_normalFlowListDirty; }
 213     bool zOrderListsDirty() const { return m_zOrderListsDirty; }
 214 
<span class="line-modified"> 215 #if ASSERT_ENABLED</span>
 216     bool layerListMutationAllowed() const { return m_layerListMutationAllowed; }
 217     void setLayerListMutationAllowed(bool flag) { m_layerListMutationAllowed = flag; }
 218 #endif
 219 
 220 private:
 221     // These flags propagate in paint order (z-order tree).
 222     enum class Compositing {
 223         HasDescendantNeedingRequirementsTraversal           = 1 &lt;&lt; 0, // Need to do the overlap-testing tree walk because hierarchy or geometry changed.
 224         HasDescendantNeedingBackingOrHierarchyTraversal     = 1 &lt;&lt; 1, // Need to update geometry, configuration and update the GraphicsLayer tree.
 225 
 226         // Things that trigger HasDescendantNeedingRequirementsTraversal
 227         NeedsPaintOrderChildrenUpdate                       = 1 &lt;&lt; 2, // The paint order children of this layer changed (gained/lost child, order change).
 228         NeedsPostLayoutUpdate                               = 1 &lt;&lt; 3, // Needs compositing to be re-evaluated after layout (it depends on geometry).
 229         DescendantsNeedRequirementsTraversal                = 1 &lt;&lt; 4, // Something changed that forces computeCompositingRequirements to traverse all descendant layers.
 230         SubsequentLayersNeedRequirementsTraversal           = 1 &lt;&lt; 5, // Something changed that forces computeCompositingRequirements to traverse all layers later in paint order.
 231 
 232         // Things that trigger HasDescendantNeedingBackingOrHierarchyTraversal
 233         NeedsGeometryUpdate                                 = 1 &lt;&lt; 6, // This layer needs a geometry update.
 234         NeedsConfigurationUpdate                            = 1 &lt;&lt; 7, // This layer needs a configuration update (updating its internal compositing hierarchy).
 235         NeedsScrollingTreeUpdate                            = 1 &lt;&lt; 8, // Something changed that requires this layer&#39;s scrolling tree node to be updated.
</pre>
<hr />
<pre>
 422     const LayoutPoint&amp; location() const { return m_topLeft; }
 423     void setLocation(const LayoutPoint&amp; p) { m_topLeft = p; }
 424 
 425     const IntSize&amp; size() const { return m_layerSize; }
 426     void setSize(const IntSize&amp; size) { m_layerSize = size; } // Only public for RenderTreeAsText.
 427 
 428     LayoutRect rect() const { return LayoutRect(location(), size()); }
 429 
 430     IntSize visibleSize() const override;
 431     IntSize contentsSize() const override;
 432     IntSize reachableTotalContentsSize() const override;
 433 
 434     int scrollWidth() const;
 435     int scrollHeight() const;
 436 
 437     void panScrollFromPoint(const IntPoint&amp;);
 438 
 439     // Scrolling methods for layers that can scroll their overflow.
 440     void scrollByRecursively(const IntSize&amp; delta, ScrollableArea** scrolledArea = nullptr);
 441 
<span class="line-added"> 442     bool requestScrollPositionUpdate(const ScrollPosition&amp;, ScrollType = ScrollType::User, ScrollClamping = ScrollClamping::Clamped) override;</span>
<span class="line-added"> 443 </span>
 444     WEBCORE_EXPORT void scrollToOffset(const ScrollOffset&amp;, ScrollType = ScrollType::Programmatic, ScrollClamping = ScrollClamping::Clamped);
 445 
 446     void scrollToXPosition(int x, ScrollType, ScrollClamping = ScrollClamping::Clamped);
 447     void scrollToYPosition(int y, ScrollType, ScrollClamping = ScrollClamping::Clamped);
 448 
 449     // These are only used by marquee.
 450     void scrollToXOffset(int x) { scrollToOffset(ScrollOffset(x, scrollOffset().y()), ScrollType::Programmatic, ScrollClamping::Unclamped); }
 451     void scrollToYOffset(int y) { scrollToOffset(ScrollOffset(scrollOffset().x(), y), ScrollType::Programmatic, ScrollClamping::Unclamped); }
 452 
 453     void setPostLayoutScrollPosition(Optional&lt;ScrollPosition&gt;);
 454     void applyPostLayoutScrollPositionIfNeeded();
 455 
 456     void availableContentSizeChanged(AvailableSizeChangeReason) override;
 457 
 458     // &quot;absoluteRect&quot; is in scaled document coordinates.
 459     void scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp;);
 460 
 461     bool scrollsOverflow() const;
 462     bool hasScrollableHorizontalOverflow() const;
 463     bool hasScrollableVerticalOverflow() const;
</pre>
<hr />
<pre>
 639     RenderLayer* ancestorCompositingLayer() const { return enclosingCompositingLayer(ExcludeSelf); }
 640 
 641     RenderLayer* enclosingFilterLayer(IncludeSelfOrNot = IncludeSelf) const;
 642     RenderLayer* enclosingFilterRepaintLayer() const;
 643     void setFilterBackendNeedsRepaintingInRect(const LayoutRect&amp;);
 644     bool hasAncestorWithFilterOutsets() const;
 645 
 646     bool canUseOffsetFromAncestor() const
 647     {
 648         // FIXME: This really needs to know if there are transforms on this layer and any of the layers
 649         // between it and the ancestor in question.
 650         return !renderer().hasTransform() &amp;&amp; !renderer().isSVGRoot();
 651     }
 652 
 653     // FIXME: adjustForColumns allows us to position compositing layers in columns correctly, but eventually they need to be split across columns too.
 654     enum ColumnOffsetAdjustment { DontAdjustForColumns, AdjustForColumns };
 655     void convertToPixelSnappedLayerCoords(const RenderLayer* ancestorLayer, IntPoint&amp; location, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
 656     LayoutPoint convertToLayerCoords(const RenderLayer* ancestorLayer, const LayoutPoint&amp;, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
 657     LayoutSize offsetFromAncestor(const RenderLayer*, ColumnOffsetAdjustment = DontAdjustForColumns) const;
 658 
<span class="line-modified"> 659     int zIndex() const { return renderer().style().usedZIndex(); }</span>
 660 
 661     enum PaintLayerFlag {
 662         PaintLayerHaveTransparency                      = 1 &lt;&lt; 0,
 663         PaintLayerAppliedTransform                      = 1 &lt;&lt; 1,
 664         PaintLayerTemporaryClipRects                    = 1 &lt;&lt; 2,
 665         PaintLayerPaintingReflection                    = 1 &lt;&lt; 3,
 666         PaintLayerPaintingOverlayScrollbars             = 1 &lt;&lt; 4,
 667         PaintLayerPaintingCompositingBackgroundPhase    = 1 &lt;&lt; 5,
 668         PaintLayerPaintingCompositingForegroundPhase    = 1 &lt;&lt; 6,
 669         PaintLayerPaintingCompositingMaskPhase          = 1 &lt;&lt; 7,
 670         PaintLayerPaintingCompositingClipPathPhase      = 1 &lt;&lt; 8,
 671         PaintLayerPaintingCompositingScrollingPhase     = 1 &lt;&lt; 9,
 672         PaintLayerPaintingOverflowContents              = 1 &lt;&lt; 10,
 673         PaintLayerPaintingRootBackgroundOnly            = 1 &lt;&lt; 11,
 674         PaintLayerPaintingSkipRootBackground            = 1 &lt;&lt; 12,
 675         PaintLayerPaintingChildClippingMaskPhase        = 1 &lt;&lt; 13,
 676         PaintLayerCollectingEventRegion                 = 1 &lt;&lt; 14,
 677     };
 678     static constexpr OptionSet&lt;PaintLayerFlag&gt; paintLayerPaintingCompositingAllPhasesFlags() { return { PaintLayerPaintingCompositingBackgroundPhase, PaintLayerPaintingCompositingForegroundPhase }; }
 679 
</pre>
<hr />
<pre>
 781     bool hasTransform() const { return renderer().hasTransform(); }
 782     // Note that this transform has the transform-origin baked in.
 783     TransformationMatrix* transform() const { return m_transform.get(); }
 784     // currentTransform computes a transform which takes accelerated animations into account. The
 785     // resulting transform has transform-origin baked in. If the layer does not have a transform,
 786     // returns the identity matrix.
 787     TransformationMatrix currentTransform(RenderStyle::ApplyTransformOrigin = RenderStyle::IncludeTransformOrigin) const;
 788     TransformationMatrix renderableTransform(OptionSet&lt;PaintBehavior&gt;) const;
 789 
 790     // Get the perspective transform, which is applied to transformed sublayers.
 791     // Returns true if the layer has a -webkit-perspective.
 792     // Note that this transform has the perspective-origin baked in.
 793     TransformationMatrix perspectiveTransform() const;
 794     FloatPoint perspectiveOrigin() const;
 795     bool preserves3D() const { return renderer().style().transformStyle3D() == TransformStyle3D::Preserve3D; }
 796     bool has3DTransform() const { return m_transform &amp;&amp; !m_transform-&gt;isAffine(); }
 797     bool hasTransformedAncestor() const { return m_hasTransformedAncestor; }
 798 
 799     void filterNeedsRepaint();
 800     bool hasFilter() const { return renderer().hasFilter(); }
<span class="line-added"> 801     bool hasFilterOutsets() const { return !filterOutsets().isZero(); }</span>
<span class="line-added"> 802     IntOutsets filterOutsets() const;</span>
 803     bool hasBackdropFilter() const
 804     {
 805 #if ENABLE(FILTERS_LEVEL_2)
 806         return renderer().hasBackdropFilter();
 807 #else
 808         return false;
 809 #endif
 810     }
 811 
 812 #if ENABLE(CSS_COMPOSITING)
 813     bool hasBlendMode() const { return renderer().hasBlendMode(); }
 814     BlendMode blendMode() const { return static_cast&lt;BlendMode&gt;(m_blendMode); }
 815 
 816     bool isolatesCompositedBlending() const { return m_hasNotIsolatedCompositedBlendingDescendants &amp;&amp; isCSSStackingContext(); }
 817     bool hasNotIsolatedCompositedBlendingDescendants() const { return m_hasNotIsolatedCompositedBlendingDescendants; }
 818     void setHasNotIsolatedCompositedBlendingDescendants(bool hasNotIsolatedCompositedBlendingDescendants)
 819     {
 820         m_hasNotIsolatedCompositedBlendingDescendants = hasNotIsolatedCompositedBlendingDescendants;
 821     }
 822 
</pre>
<hr />
<pre>
 891     ViewportConstrainedNotCompositedReason viewportConstrainedNotCompositedReason() const { return static_cast&lt;ViewportConstrainedNotCompositedReason&gt;(m_viewportConstrainedNotCompositedReason); }
 892 
 893     IndirectCompositingReason indirectCompositingReason() const { return static_cast&lt;IndirectCompositingReason&gt;(m_indirectCompositingReason); }
 894 
 895     bool isRenderFragmentedFlow() const { return renderer().isRenderFragmentedFlow(); }
 896     bool isOutOfFlowRenderFragmentedFlow() const { return renderer().isOutOfFlowRenderFragmentedFlow(); }
 897     bool isInsideFragmentedFlow() const { return renderer().fragmentedFlowState() != RenderObject::NotInsideFragmentedFlow; }
 898     bool isDirtyRenderFragmentedFlow() const
 899     {
 900         ASSERT(isRenderFragmentedFlow());
 901         return zOrderListsDirty() || normalFlowListDirty();
 902     }
 903 
 904     RenderLayer* enclosingFragmentedFlowAncestor() const;
 905 
 906     bool shouldPlaceBlockDirectionScrollbarOnLeft() const final { return renderer().shouldPlaceBlockDirectionScrollbarOnLeft(); }
 907 
 908     void simulateFrequentPaint() { SinglePaintFrequencyTracking { m_paintFrequencyTracker }; }
 909     bool paintingFrequently() const { return m_paintFrequencyTracker.paintingFrequently(); }
 910 
<span class="line-modified"> 911     WEBCORE_EXPORT bool isTransparentRespectingParentFrames() const;</span>
 912 
 913     void invalidateEventRegion();
 914 
 915 private:
 916 
 917     void setNextSibling(RenderLayer* next) { m_next = next; }
 918     void setPreviousSibling(RenderLayer* prev) { m_previous = prev; }
 919     void setParent(RenderLayer*);
 920     void setFirstChild(RenderLayer* first) { m_first = first; }
 921     void setLastChild(RenderLayer* last) { m_last = last; }
 922 
 923     void dirtyPaintOrderListsOnChildChange(RenderLayer&amp;);
 924 
 925     bool shouldBeNormalFlowOnly() const;
 926     bool shouldBeCSSStackingContext() const;
 927 
 928     // Return true if changed.
 929     bool setIsNormalFlowOnly(bool);
 930 
 931     bool setIsOpportunisticStackingContext(bool);
 932     bool setIsCSSStackingContext(bool);
 933 
 934     void isStackingContextChanged();
 935 
 936     bool isDirtyStackingContext() const { return m_zOrderListsDirty &amp;&amp; isStackingContext(); }
 937 
 938     void updateZOrderLists();
 939     void rebuildZOrderLists();
<span class="line-modified"> 940     void rebuildZOrderLists(std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, OptionSet&lt;Compositing&gt;&amp;);</span>
<span class="line-modified"> 941     void collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, OptionSet&lt;Compositing&gt;&amp;);</span>
 942     void clearZOrderLists();
 943 
 944     void updateNormalFlowList();
 945 
 946     struct LayerPaintingInfo {
 947         LayerPaintingInfo(RenderLayer* inRootLayer, const LayoutRect&amp; inDirtyRect, OptionSet&lt;PaintBehavior&gt; inPaintBehavior, const LayoutSize&amp; inSubpixelOffset, RenderObject* inSubtreePaintRoot = nullptr, OverlapTestRequestMap* inOverlapTestRequests = nullptr, bool inRequireSecurityOriginAccessForWidgets = false)
 948             : rootLayer(inRootLayer)
 949             , subtreePaintRoot(inSubtreePaintRoot)
 950             , paintDirtyRect(inDirtyRect)
 951             , subpixelOffset(inSubpixelOffset)
 952             , overlapTestRequests(inOverlapTestRequests)
 953             , paintBehavior(inPaintBehavior)
 954             , requireSecurityOriginAccessForWidgets(inRequireSecurityOriginAccessForWidgets)
 955         { }
 956 
 957         RenderLayer* rootLayer;
 958         RenderObject* subtreePaintRoot; // Only paint descendants of this object.
 959         LayoutRect paintDirtyRect; // Relative to rootLayer;
 960         LayoutSize subpixelOffset;
 961         OverlapTestRequestMap* overlapTestRequests; // May be null.
</pre>
<hr />
<pre>
1232 
1233     bool m_visibleContentStatusDirty : 1;
1234     bool m_hasVisibleContent : 1;
1235     bool m_visibleDescendantStatusDirty : 1;
1236     bool m_hasVisibleDescendant : 1;
1237     bool m_registeredScrollableArea : 1;
1238     bool m_isFixedIntersectingViewport : 1;
1239     bool m_behavesAsFixed : 1;
1240 
1241     bool m_3DTransformedDescendantStatusDirty : 1;
1242     bool m_has3DTransformedDescendant : 1;  // Set on a stacking context layer that has 3D descendants anywhere
1243                                             // in a preserves3D hierarchy. Hint to do 3D-aware hit testing.
1244     bool m_hasCompositingDescendant : 1; // In the z-order tree.
1245 
1246     bool m_hasCompositedScrollingAncestor : 1; // In the layer-order tree.
1247     bool m_hasCompositedScrollableOverflow : 1;
1248 
1249     bool m_hasTransformedAncestor : 1;
1250     bool m_has3DTransformedAncestor : 1;
1251 
<span class="line-modified">1252     unsigned m_indirectCompositingReason : 4; // IndirectCompositingReason</span>
<span class="line-modified">1253     unsigned m_viewportConstrainedNotCompositedReason : 2; // ViewportConstrainedNotCompositedReason</span>
1254 
1255 #if PLATFORM(IOS_FAMILY)
1256 #if ENABLE(IOS_TOUCH_EVENTS)
1257     bool m_registeredAsTouchEventListenerForScrolling : 1;
1258 #endif
1259     bool m_adjustForIOSCaretWhenScrolling : 1;
1260 #endif
1261 
1262     bool m_requiresScrollPositionReconciliation : 1;
1263     bool m_containsDirtyOverlayScrollbars : 1;
1264     bool m_updatingMarqueePosition : 1;
1265 
<span class="line-modified">1266 #if ASSERT_ENABLED</span>
1267     bool m_layerListMutationAllowed : 1;
1268 #endif
1269 
1270 #if ENABLE(CSS_COMPOSITING)
<span class="line-modified">1271     unsigned m_blendMode : 5; // BlendMode</span>
1272     bool m_hasNotIsolatedCompositedBlendingDescendants : 1;
1273     bool m_hasNotIsolatedBlendingDescendants : 1;
1274     bool m_hasNotIsolatedBlendingDescendantsStatusDirty : 1;
1275 #endif
1276 
1277     RenderLayerModelObject&amp; m_renderer;
1278 
1279     RenderLayer* m_parent { nullptr };
1280     RenderLayer* m_previous { nullptr };
1281     RenderLayer* m_next { nullptr };
1282     RenderLayer* m_first { nullptr };
1283     RenderLayer* m_last { nullptr };
1284 
1285     WeakPtr&lt;RenderLayer&gt; m_backingProviderLayer;
1286 
1287     // For layers that establish stacking contexts, m_posZOrderList holds a sorted list of all the
1288     // descendant layers within the stacking context that have z-indices of 0 or greater
1289     // (auto will count as 0). m_negZOrderList holds descendants within our stacking context with negative
1290     // z-indices.
1291     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_posZOrderList;
</pre>
<hr />
<pre>
1354 
1355 inline void RenderLayer::updateZOrderLists()
1356 {
1357     if (!m_zOrderListsDirty)
1358         return;
1359 
1360     if (!isStackingContext()) {
1361         clearZOrderLists();
1362         m_zOrderListsDirty = false;
1363         return;
1364     }
1365 
1366     rebuildZOrderLists();
1367 }
1368 
1369 inline RenderLayer* RenderLayer::paintOrderParent() const
1370 {
1371     return m_isNormalFlowOnly ? m_parent : stackingContext();
1372 }
1373 
<span class="line-modified">1374 #if ASSERT_ENABLED</span>
1375 class LayerListMutationDetector {
1376 public:
1377     LayerListMutationDetector(RenderLayer&amp; layer)
1378         : m_layer(layer)
1379         , m_previousMutationAllowedState(layer.layerListMutationAllowed())
1380     {
1381         m_layer.setLayerListMutationAllowed(false);
1382     }
1383 
1384     ~LayerListMutationDetector()
1385     {
1386         m_layer.setLayerListMutationAllowed(m_previousMutationAllowedState);
1387     }
1388 
1389 private:
1390     RenderLayer&amp; m_layer;
1391     bool m_previousMutationAllowedState;
1392 };
<span class="line-modified">1393 #endif // ASSERT_ENABLED</span>
1394 
1395 void makeMatrixRenderable(TransformationMatrix&amp;, bool has3DRendering);
1396 
1397 bool compositedWithOwnBackingStore(const RenderLayer&amp;);
1398 
1399 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, ClipRectsType);
1400 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const RenderLayer&amp;);
1401 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const RenderLayer::ClipRectsContext&amp;);
1402 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, IndirectCompositingReason);
1403 
1404 } // namespace WebCore
1405 
1406 #if ENABLE(TREE_DEBUGGING)
1407 // Outside the WebCore namespace for ease of invocation from lldb.
1408 void showLayerTree(const WebCore::RenderLayer*);
1409 void showPaintOrderTree(const WebCore::RenderLayer*);
1410 void showLayerTree(const WebCore::RenderObject*);
1411 #endif
</pre>
</td>
</tr>
</table>
<center><a href="RenderLayer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerBacking.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
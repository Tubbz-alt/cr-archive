<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFragmentedFlow.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderFragmentedFlow.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderFullScreen.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFragmentedFlow.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  *    disclaimer in the documentation and/or other materials
 14  *    provided with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER &quot;AS IS&quot; AND ANY
 17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 19  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
 20  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 21  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 25  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 26  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 27  * SUCH DAMAGE.
 28  */
 29 
 30 #pragma once
 31 
 32 #include &quot;LayerFragment.h&quot;

 33 #include &quot;RenderBlockFlow.h&quot;
 34 #include &quot;RenderFragmentContainer.h&quot;
 35 #include &lt;wtf/ListHashSet.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 class CurrentRenderFragmentContainerMaintainer;
 40 class RenderFragmentedFlow;
 41 class RenderStyle;
 42 class RenderFragmentContainer;
 43 class RootInlineBox;
 44 
 45 typedef ListHashSet&lt;RenderFragmentContainer*&gt; RenderFragmentContainerList;
 46 typedef Vector&lt;RenderLayer*&gt; RenderLayerList;
 47 typedef HashMap&lt;const RootInlineBox*, RenderFragmentContainer*&gt; ContainingFragmentMap;
 48 
 49 // RenderFragmentedFlow is used to collect all the render objects that participate in a
 50 // flow thread. It will also help in doing the layout. However, it will not render
 51 // directly to screen. Instead, RenderFragmentContainer objects will redirect their paint
 52 // and nodeAtPoint methods to this object. Each RenderFragmentContainer will actually be a viewPort
</pre>
<hr />
<pre>
185 
186     const char* renderName() const override = 0;
187 
188     // Overridden by columns/pages to set up an initial logical width of the page width even when
189     // no fragments have been generated yet.
190     virtual LayoutUnit initialLogicalWidth() const { return 0; };
191 
192     void clearLinesToFragmentMap();
193     void willBeDestroyed() override;
194 
195     void mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp;, MapCoordinatesFlags, bool* wasFixed) const override;
196 
197     void updateFragmentsFragmentedFlowPortionRect();
198     bool shouldRepaint(const LayoutRect&amp;) const;
199 
200     bool getFragmentRangeForBoxFromCachedInfo(const RenderBox*, RenderFragmentContainer*&amp; startFragment, RenderFragmentContainer*&amp; endFragment) const;
201 
202     void removeRenderBoxFragmentInfo(RenderBox&amp;);
203     void removeLineFragmentInfo(const RenderBlockFlow&amp;);
204 
<span class="line-removed">205     RenderFragmentContainerList m_fragmentList;</span>
<span class="line-removed">206 </span>
207     class RenderFragmentContainerRange {
208     public:
209         RenderFragmentContainerRange() = default;
210         RenderFragmentContainerRange(RenderFragmentContainer* start, RenderFragmentContainer* end)
211         {
212             setRange(start, end);
213         }
214 
215         void setRange(RenderFragmentContainer* start, RenderFragmentContainer* end)
216         {
217             m_startFragment = makeWeakPtr(start);
218             m_endFragment = makeWeakPtr(end);
219             m_rangeInvalidated = true;
220         }
221 
222         RenderFragmentContainer* startFragment() const { return m_startFragment.get(); }
223         RenderFragmentContainer* endFragment() const { return m_endFragment.get(); }
224         bool rangeInvalidated() const { return m_rangeInvalidated; }
225         void clearRangeInvalidated() { m_rangeInvalidated = false; }
226 
227     private:
228         WeakPtr&lt;RenderFragmentContainer&gt; m_startFragment;
229         WeakPtr&lt;RenderFragmentContainer&gt; m_endFragment;
230         bool m_rangeInvalidated;
231     };
232 
<span class="line-modified">233     typedef PODInterval&lt;LayoutUnit, WeakPtr&lt;RenderFragmentContainer&gt;&gt; FragmentInterval;</span>
<span class="line-removed">234     typedef PODIntervalTree&lt;LayoutUnit, WeakPtr&lt;RenderFragmentContainer&gt;&gt; FragmentIntervalTree;</span>
<span class="line-removed">235 </span>
<span class="line-removed">236     class FragmentSearchAdapter {</span>
<span class="line-removed">237     public:</span>
<span class="line-removed">238         FragmentSearchAdapter(LayoutUnit offset)</span>
<span class="line-removed">239             : m_offset(offset)</span>
<span class="line-removed">240         {</span>
<span class="line-removed">241         }</span>
<span class="line-removed">242 </span>
<span class="line-removed">243         const LayoutUnit&amp; lowValue() const { return m_offset; }</span>
<span class="line-removed">244         const LayoutUnit&amp; highValue() const { return m_offset; }</span>
<span class="line-removed">245         void collectIfNeeded(const FragmentInterval&amp;);</span>
<span class="line-removed">246 </span>
<span class="line-removed">247         RenderFragmentContainer* result() const { return m_result.get(); }</span>
248 
<span class="line-modified">249     private:</span>
<span class="line-removed">250         LayoutUnit m_offset;</span>
<span class="line-removed">251         WeakPtr&lt;RenderFragmentContainer&gt; m_result;</span>
<span class="line-removed">252     };</span>
253 
254     // Map a line to its containing fragment.
255     std::unique_ptr&lt;ContainingFragmentMap&gt; m_lineToFragmentMap;
256 
257     // Map a box to the list of fragments in which the box is rendered.
<span class="line-modified">258     typedef HashMap&lt;const RenderBox*, RenderFragmentContainerRange&gt; RenderFragmentContainerRangeMap;</span>
259     RenderFragmentContainerRangeMap m_fragmentRangeMap;
260 
261     // Map a box with a fragment break to the auto height fragment affected by that break.
<span class="line-modified">262     typedef HashMap&lt;RenderBox*, RenderFragmentContainer*&gt; RenderBoxToFragmentMap;</span>
263     RenderBoxToFragmentMap m_breakBeforeToFragmentMap;
264     RenderBoxToFragmentMap m_breakAfterToFragmentMap;
265 

266     FragmentIntervalTree m_fragmentIntervalTree;
267 
268     CurrentRenderFragmentContainerMaintainer* m_currentFragmentMaintainer;
269 
270     bool m_fragmentsInvalidated : 1;
271     bool m_fragmentsHaveUniformLogicalWidth : 1;
272     bool m_fragmentsHaveUniformLogicalHeight : 1;
273     bool m_pageLogicalSizeChanged : 1;
274 };
275 
276 } // namespace WebCore
277 
<span class="line-removed">278 #ifndef NDEBUG</span>
<span class="line-removed">279 </span>
<span class="line-removed">280 namespace WTF {</span>
<span class="line-removed">281 </span>
<span class="line-removed">282 // This structure is used by PODIntervalTree for debugging.</span>
<span class="line-removed">283 template &lt;&gt; struct ValueToString&lt;WebCore::RenderFragmentContainer*&gt; {</span>
<span class="line-removed">284     static String string(const WebCore::RenderFragmentContainer* value) { return value-&gt;debugString(); }</span>
<span class="line-removed">285 };</span>
<span class="line-removed">286 template &lt;&gt; struct ValueToString&lt;WeakPtr&lt;WebCore::RenderFragmentContainer&gt;&gt; {</span>
<span class="line-removed">287     static String string(const WeakPtr&lt;WebCore::RenderFragmentContainer&gt;&amp; value) { return value ? value-&gt;debugString() : String { }; }</span>
<span class="line-removed">288 };</span>
<span class="line-removed">289 </span>
<span class="line-removed">290 } // namespace WTF</span>
<span class="line-removed">291 </span>
<span class="line-removed">292 #endif</span>
<span class="line-removed">293 </span>
294 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderFragmentedFlow, isRenderFragmentedFlow())
</pre>
</td>
<td>
<hr />
<pre>
 13  *    disclaimer in the documentation and/or other materials
 14  *    provided with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER &quot;AS IS&quot; AND ANY
 17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 19  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
 20  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 21  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 25  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 26  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 27  * SUCH DAMAGE.
 28  */
 29 
 30 #pragma once
 31 
 32 #include &quot;LayerFragment.h&quot;
<span class="line-added"> 33 #include &quot;PODIntervalTree.h&quot;</span>
 34 #include &quot;RenderBlockFlow.h&quot;
 35 #include &quot;RenderFragmentContainer.h&quot;
 36 #include &lt;wtf/ListHashSet.h&gt;
 37 
 38 namespace WebCore {
 39 
 40 class CurrentRenderFragmentContainerMaintainer;
 41 class RenderFragmentedFlow;
 42 class RenderStyle;
 43 class RenderFragmentContainer;
 44 class RootInlineBox;
 45 
 46 typedef ListHashSet&lt;RenderFragmentContainer*&gt; RenderFragmentContainerList;
 47 typedef Vector&lt;RenderLayer*&gt; RenderLayerList;
 48 typedef HashMap&lt;const RootInlineBox*, RenderFragmentContainer*&gt; ContainingFragmentMap;
 49 
 50 // RenderFragmentedFlow is used to collect all the render objects that participate in a
 51 // flow thread. It will also help in doing the layout. However, it will not render
 52 // directly to screen. Instead, RenderFragmentContainer objects will redirect their paint
 53 // and nodeAtPoint methods to this object. Each RenderFragmentContainer will actually be a viewPort
</pre>
<hr />
<pre>
186 
187     const char* renderName() const override = 0;
188 
189     // Overridden by columns/pages to set up an initial logical width of the page width even when
190     // no fragments have been generated yet.
191     virtual LayoutUnit initialLogicalWidth() const { return 0; };
192 
193     void clearLinesToFragmentMap();
194     void willBeDestroyed() override;
195 
196     void mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp;, MapCoordinatesFlags, bool* wasFixed) const override;
197 
198     void updateFragmentsFragmentedFlowPortionRect();
199     bool shouldRepaint(const LayoutRect&amp;) const;
200 
201     bool getFragmentRangeForBoxFromCachedInfo(const RenderBox*, RenderFragmentContainer*&amp; startFragment, RenderFragmentContainer*&amp; endFragment) const;
202 
203     void removeRenderBoxFragmentInfo(RenderBox&amp;);
204     void removeLineFragmentInfo(const RenderBlockFlow&amp;);
205 


206     class RenderFragmentContainerRange {
207     public:
208         RenderFragmentContainerRange() = default;
209         RenderFragmentContainerRange(RenderFragmentContainer* start, RenderFragmentContainer* end)
210         {
211             setRange(start, end);
212         }
213 
214         void setRange(RenderFragmentContainer* start, RenderFragmentContainer* end)
215         {
216             m_startFragment = makeWeakPtr(start);
217             m_endFragment = makeWeakPtr(end);
218             m_rangeInvalidated = true;
219         }
220 
221         RenderFragmentContainer* startFragment() const { return m_startFragment.get(); }
222         RenderFragmentContainer* endFragment() const { return m_endFragment.get(); }
223         bool rangeInvalidated() const { return m_rangeInvalidated; }
224         void clearRangeInvalidated() { m_rangeInvalidated = false; }
225 
226     private:
227         WeakPtr&lt;RenderFragmentContainer&gt; m_startFragment;
228         WeakPtr&lt;RenderFragmentContainer&gt; m_endFragment;
229         bool m_rangeInvalidated;
230     };
231 
<span class="line-modified">232     class FragmentSearchAdapter;</span>














233 
<span class="line-modified">234     RenderFragmentContainerList m_fragmentList;</span>



235 
236     // Map a line to its containing fragment.
237     std::unique_ptr&lt;ContainingFragmentMap&gt; m_lineToFragmentMap;
238 
239     // Map a box to the list of fragments in which the box is rendered.
<span class="line-modified">240     using RenderFragmentContainerRangeMap = HashMap&lt;const RenderBox*, RenderFragmentContainerRange&gt;;</span>
241     RenderFragmentContainerRangeMap m_fragmentRangeMap;
242 
243     // Map a box with a fragment break to the auto height fragment affected by that break.
<span class="line-modified">244     using RenderBoxToFragmentMap = HashMap&lt;RenderBox*, RenderFragmentContainer*&gt;;</span>
245     RenderBoxToFragmentMap m_breakBeforeToFragmentMap;
246     RenderBoxToFragmentMap m_breakAfterToFragmentMap;
247 
<span class="line-added">248     using FragmentIntervalTree = PODIntervalTree&lt;LayoutUnit, WeakPtr&lt;RenderFragmentContainer&gt;&gt;;</span>
249     FragmentIntervalTree m_fragmentIntervalTree;
250 
251     CurrentRenderFragmentContainerMaintainer* m_currentFragmentMaintainer;
252 
253     bool m_fragmentsInvalidated : 1;
254     bool m_fragmentsHaveUniformLogicalWidth : 1;
255     bool m_fragmentsHaveUniformLogicalHeight : 1;
256     bool m_pageLogicalSizeChanged : 1;
257 };
258 
259 } // namespace WebCore
260 
















261 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderFragmentedFlow, isRenderFragmentedFlow())
</pre>
</td>
</tr>
</table>
<center><a href="RenderFragmentedFlow.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderFullScreen.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
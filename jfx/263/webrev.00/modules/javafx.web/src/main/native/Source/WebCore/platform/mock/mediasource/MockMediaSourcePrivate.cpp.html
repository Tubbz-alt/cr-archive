<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/mock/mediasource/MockMediaSourcePrivate.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;MockMediaSourcePrivate.h&quot;
 28 
 29 #if ENABLE(MEDIA_SOURCE)
 30 
 31 #include &quot;ContentType.h&quot;
 32 #include &quot;MediaSourcePrivateClient.h&quot;
 33 #include &quot;MockMediaPlayerMediaSource.h&quot;
 34 #include &quot;MockSourceBufferPrivate.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 Ref&lt;MockMediaSourcePrivate&gt; MockMediaSourcePrivate::create(MockMediaPlayerMediaSource&amp; parent, MediaSourcePrivateClient&amp; client)
 39 {
 40     auto source = adoptRef(*new MockMediaSourcePrivate(parent, client));
 41     client.setPrivateAndOpen(source.copyRef());
 42     return source;
 43 }
 44 
 45 MockMediaSourcePrivate::MockMediaSourcePrivate(MockMediaPlayerMediaSource&amp; parent, MediaSourcePrivateClient&amp; client)
 46     : m_player(parent)
 47     , m_client(client)
 48 {
 49 #if !RELEASE_LOG_DISABLED
 50     m_client-&gt;setLogIdentifier(m_player.mediaPlayerLogIdentifier());
 51 #endif
 52 }
 53 
 54 MockMediaSourcePrivate::~MockMediaSourcePrivate()
 55 {
 56     for (auto&amp; buffer : m_sourceBuffers)
 57         buffer-&gt;clearMediaSource();
 58 }
 59 
 60 MediaSourcePrivate::AddStatus MockMediaSourcePrivate::addSourceBuffer(const ContentType&amp; contentType, RefPtr&lt;SourceBufferPrivate&gt;&amp; outPrivate)
 61 {
 62     MediaEngineSupportParameters parameters;
 63     parameters.isMediaSource = true;
 64     parameters.type = contentType;
 65     if (MockMediaPlayerMediaSource::supportsType(parameters) == MediaPlayer::SupportsType::IsNotSupported)
 66         return NotSupported;
 67 
 68     m_sourceBuffers.append(MockSourceBufferPrivate::create(this));
 69     outPrivate = m_sourceBuffers.last();
 70 
 71     return Ok;
 72 }
 73 
 74 void MockMediaSourcePrivate::removeSourceBuffer(SourceBufferPrivate* buffer)
 75 {
 76     ASSERT(m_sourceBuffers.contains(buffer));
 77     m_activeSourceBuffers.removeFirst(buffer);
 78     m_sourceBuffers.removeFirst(buffer);
 79 }
 80 
 81 MediaTime MockMediaSourcePrivate::duration()
 82 {
 83     return m_client-&gt;duration();
 84 }
 85 
 86 std::unique_ptr&lt;PlatformTimeRanges&gt; MockMediaSourcePrivate::buffered()
 87 {
 88     return m_client-&gt;buffered();
 89 }
 90 
 91 void MockMediaSourcePrivate::durationChanged()
 92 {
 93     m_player.updateDuration(duration());
 94 }
 95 
 96 void MockMediaSourcePrivate::markEndOfStream(EndOfStreamStatus status)
 97 {
 98     if (status == EosNoError)
 99         m_player.setNetworkState(MediaPlayer::NetworkState::Loaded);
100     m_isEnded = true;
101 }
102 
103 void MockMediaSourcePrivate::unmarkEndOfStream()
104 {
105     m_isEnded = false;
106 }
107 
108 MediaPlayer::ReadyState MockMediaSourcePrivate::readyState() const
109 {
110     return m_player.readyState();
111 }
112 
113 void MockMediaSourcePrivate::setReadyState(MediaPlayer::ReadyState readyState)
114 {
115     m_player.setReadyState(readyState);
116 }
117 
118 void MockMediaSourcePrivate::waitForSeekCompleted()
119 {
120     m_player.waitForSeekCompleted();
121 }
122 
123 void MockMediaSourcePrivate::seekCompleted()
124 {
125     m_player.seekCompleted();
126 }
127 
128 void MockMediaSourcePrivate::sourceBufferPrivateDidChangeActiveState(MockSourceBufferPrivate* buffer, bool active)
129 {
130     if (active &amp;&amp; !m_activeSourceBuffers.contains(buffer))
131         m_activeSourceBuffers.append(buffer);
132 
133     if (!active)
134         m_activeSourceBuffers.removeFirst(buffer);
135 }
136 
137 static bool MockSourceBufferPrivateHasAudio(MockSourceBufferPrivate* sourceBuffer)
138 {
139     return sourceBuffer-&gt;hasAudio();
140 }
141 
142 bool MockMediaSourcePrivate::hasAudio() const
143 {
144     return std::any_of(m_activeSourceBuffers.begin(), m_activeSourceBuffers.end(), MockSourceBufferPrivateHasAudio);
145 }
146 
147 static bool MockSourceBufferPrivateHasVideo(MockSourceBufferPrivate* sourceBuffer)
148 {
149     return sourceBuffer-&gt;hasVideo();
150 }
151 
152 bool MockMediaSourcePrivate::hasVideo() const
153 {
154     return std::any_of(m_activeSourceBuffers.begin(), m_activeSourceBuffers.end(), MockSourceBufferPrivateHasVideo);
155 }
156 
157 void MockMediaSourcePrivate::seekToTime(const MediaTime&amp; time)
158 {
159     m_client-&gt;seekToTime(time);
160 }
161 
162 MediaTime MockMediaSourcePrivate::seekToTime(const MediaTime&amp; targetTime, const MediaTime&amp; negativeThreshold, const MediaTime&amp; positiveThreshold)
163 {
164     MediaTime seekTime = targetTime;
165     for (auto&amp; buffer : m_activeSourceBuffers) {
166         MediaTime sourceSeekTime = buffer-&gt;fastSeekTimeForMediaTime(targetTime, negativeThreshold, positiveThreshold);
167         if (abs(targetTime - sourceSeekTime) &gt; abs(targetTime - seekTime))
168             seekTime = sourceSeekTime;
169     }
170 
171     return seekTime;
172 }
173 
174 Optional&lt;VideoPlaybackQualityMetrics&gt; MockMediaSourcePrivate::videoPlaybackQualityMetrics()
175 {
176     return VideoPlaybackQualityMetrics {
177         m_totalVideoFrames,
178         m_droppedVideoFrames,
179         m_corruptedVideoFrames,
180         m_totalFrameDelay.toDouble(),
181         0,
182     };
183 }
184 
185 #if !RELEASE_LOG_DISABLED
186 const Logger&amp; MockMediaSourcePrivate::mediaSourceLogger() const
187 {
188     return m_player.mediaPlayerLogger();
189 }
190 
191 const void* MockMediaSourcePrivate::mediaSourceLogIdentifier()
192 {
193     return m_player.mediaPlayerLogIdentifier();
194 }
195 #endif
196 
197 }
198 
199 #endif
    </pre>
  </body>
</html>
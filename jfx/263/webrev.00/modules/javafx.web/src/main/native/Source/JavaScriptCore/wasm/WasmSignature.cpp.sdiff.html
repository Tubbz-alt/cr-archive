<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSignature.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmSections.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmSignature.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSignature.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmSignature.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;WasmSignatureInlines.h&quot;

 32 #include &lt;wtf/FastMalloc.h&gt;
 33 #include &lt;wtf/HashFunctions.h&gt;
 34 #include &lt;wtf/PrintStream.h&gt;

 35 #include &lt;wtf/text/WTFString.h&gt;
 36 
 37 namespace JSC { namespace Wasm {
 38 
 39 namespace {
 40 namespace WasmSignatureInternal {
<span class="line-modified"> 41 static const bool verbose = false;</span>
 42 }
 43 }
 44 
 45 SignatureInformation* SignatureInformation::theOne { nullptr };
 46 std::once_flag SignatureInformation::signatureInformationFlag;
 47 
 48 String Signature::toString() const
 49 {
<span class="line-modified"> 50     String result(makeString(returnType()));</span>
<span class="line-removed"> 51     result.append(&quot; (&quot;);</span>
<span class="line-removed"> 52     for (SignatureArgCount arg = 0; arg &lt; argumentCount(); ++arg) {</span>
<span class="line-removed"> 53         if (arg)</span>
<span class="line-removed"> 54             result.append(&quot;, &quot;);</span>
<span class="line-removed"> 55         result.append(makeString(argument(arg)));</span>
<span class="line-removed"> 56     }</span>
<span class="line-removed"> 57     result.append(&#39;)&#39;);</span>
<span class="line-removed"> 58     return result;</span>
 59 }
 60 
 61 void Signature::dump(PrintStream&amp; out) const
 62 {
<span class="line-modified"> 63     out.print(toString());</span>














 64 }
 65 
<span class="line-modified"> 66 unsigned Signature::hash() const</span>
 67 {
 68     unsigned accumulator = 0xa1bcedd8u;
<span class="line-modified"> 69     for (uint32_t i = 0; i &lt; argumentCount(); ++i)</span>
<span class="line-modified"> 70         accumulator = WTF::pairIntHash(accumulator, WTF::IntHash&lt;uint8_t&gt;::hash(static_cast&lt;uint8_t&gt;(argument(i))));</span>
<span class="line-modified"> 71     accumulator = WTF::pairIntHash(accumulator, WTF::IntHash&lt;uint8_t&gt;::hash(static_cast&lt;uint8_t&gt;(returnType())));</span>

 72     return accumulator;
 73 }
 74 
<span class="line-modified"> 75 RefPtr&lt;Signature&gt; Signature::tryCreate(SignatureArgCount argumentCount)</span>





 76 {
 77     // We use WTF_MAKE_FAST_ALLOCATED for this class.
<span class="line-modified"> 78     auto result = tryFastMalloc(allocatedSize(argumentCount));</span>
 79     void* memory = nullptr;
 80     if (!result.getValue(memory))
 81         return nullptr;
<span class="line-modified"> 82     Signature* signature = new (NotNull, memory) Signature(argumentCount);</span>
 83     return adoptRef(signature);
 84 }
 85 
 86 SignatureInformation::SignatureInformation()
 87 {




















 88 }
 89 
<span class="line-modified"> 90 Ref&lt;Signature&gt; SignatureInformation::adopt(Ref&lt;Signature&gt;&amp;&amp; signature)</span>













































 91 {
 92     SignatureInformation&amp; info = singleton();
 93     LockHolder lock(info.m_lock);
 94 
<span class="line-modified"> 95     SignatureIndex nextValue = signature-&gt;index();</span>
<span class="line-modified"> 96     auto addResult = info.m_signatureSet.add(SignatureHash { signature.copyRef() });</span>
<span class="line-removed"> 97     if (addResult.isNewEntry) {</span>
<span class="line-removed"> 98         if (WasmSignatureInternal::verbose)</span>
<span class="line-removed"> 99             dataLogLn(&quot;Adopt new signature &quot;, signature.get(), &quot; with index &quot;, nextValue, &quot; hash: &quot;, signature-&gt;hash());</span>
<span class="line-removed">100         return WTFMove(signature);</span>
<span class="line-removed">101     }</span>
<span class="line-removed">102     nextValue = addResult.iterator-&gt;key-&gt;index();</span>
<span class="line-removed">103     if (WasmSignatureInternal::verbose)</span>
<span class="line-removed">104         dataLogLn(&quot;Existing signature &quot;, signature.get(), &quot; with index &quot;, nextValue, &quot; hash: &quot;, signature-&gt;hash());</span>
<span class="line-removed">105     return Ref&lt;Signature&gt;(*addResult.iterator-&gt;key);</span>
106 }
107 
108 void SignatureInformation::tryCleanup()
109 {
110     SignatureInformation&amp; info = singleton();
111     LockHolder lock(info.m_lock);
112 
113     info.m_signatureSet.removeIf([&amp;] (auto&amp; hash) {
114         const auto&amp; signature = hash.key;
115         return signature-&gt;refCount() == 1;
116     });
117 }
118 
119 } } // namespace JSC::Wasm
120 
121 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmSignature.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;WasmSignatureInlines.h&quot;
<span class="line-added"> 32 #include &lt;wtf/CommaPrinter.h&gt;</span>
 33 #include &lt;wtf/FastMalloc.h&gt;
 34 #include &lt;wtf/HashFunctions.h&gt;
 35 #include &lt;wtf/PrintStream.h&gt;
<span class="line-added"> 36 #include &lt;wtf/StringPrintStream.h&gt;</span>
 37 #include &lt;wtf/text/WTFString.h&gt;
 38 
 39 namespace JSC { namespace Wasm {
 40 
 41 namespace {
 42 namespace WasmSignatureInternal {
<span class="line-modified"> 43 static constexpr bool verbose = false;</span>
 44 }
 45 }
 46 
 47 SignatureInformation* SignatureInformation::theOne { nullptr };
 48 std::once_flag SignatureInformation::signatureInformationFlag;
 49 
 50 String Signature::toString() const
 51 {
<span class="line-modified"> 52     return WTF::toString(*this);</span>








 53 }
 54 
 55 void Signature::dump(PrintStream&amp; out) const
 56 {
<span class="line-modified"> 57     {</span>
<span class="line-added"> 58         out.print(&quot;(&quot;);</span>
<span class="line-added"> 59         CommaPrinter comma;</span>
<span class="line-added"> 60         for (SignatureArgCount arg = 0; arg &lt; argumentCount(); ++arg)</span>
<span class="line-added"> 61             out.print(comma, makeString(argument(arg)));</span>
<span class="line-added"> 62         out.print(&quot;)&quot;);</span>
<span class="line-added"> 63     }</span>
<span class="line-added"> 64 </span>
<span class="line-added"> 65     {</span>
<span class="line-added"> 66         CommaPrinter comma;</span>
<span class="line-added"> 67         out.print(&quot; -&gt; [&quot;);</span>
<span class="line-added"> 68         for (SignatureArgCount ret = 0; ret &lt; returnCount(); ++ret)</span>
<span class="line-added"> 69             out.print(comma, makeString(returnType(ret)));</span>
<span class="line-added"> 70         out.print(&quot;]&quot;);</span>
<span class="line-added"> 71     }</span>
 72 }
 73 
<span class="line-modified"> 74 static unsigned computeHash(size_t returnCount, const Type* returnTypes, size_t argumentCount, const Type* argumentTypes)</span>
 75 {
 76     unsigned accumulator = 0xa1bcedd8u;
<span class="line-modified"> 77     for (uint32_t i = 0; i &lt; argumentCount; ++i)</span>
<span class="line-modified"> 78         accumulator = WTF::pairIntHash(accumulator, WTF::IntHash&lt;uint8_t&gt;::hash(static_cast&lt;uint8_t&gt;(argumentTypes[i])));</span>
<span class="line-modified"> 79     for (uint32_t i = 0; i &lt; returnCount; ++i)</span>
<span class="line-added"> 80         accumulator = WTF::pairIntHash(accumulator, WTF::IntHash&lt;uint8_t&gt;::hash(static_cast&lt;uint8_t&gt;(returnTypes[i])));</span>
 81     return accumulator;
 82 }
 83 
<span class="line-modified"> 84 unsigned Signature::hash() const</span>
<span class="line-added"> 85 {</span>
<span class="line-added"> 86     return computeHash(returnCount(), storage(0), argumentCount(), storage(returnCount()));</span>
<span class="line-added"> 87 }</span>
<span class="line-added"> 88 </span>
<span class="line-added"> 89 RefPtr&lt;Signature&gt; Signature::tryCreate(SignatureArgCount returnCount, SignatureArgCount argumentCount)</span>
 90 {
 91     // We use WTF_MAKE_FAST_ALLOCATED for this class.
<span class="line-modified"> 92     auto result = tryFastMalloc(allocatedSize(returnCount, argumentCount));</span>
 93     void* memory = nullptr;
 94     if (!result.getValue(memory))
 95         return nullptr;
<span class="line-modified"> 96     Signature* signature = new (NotNull, memory) Signature(returnCount, argumentCount);</span>
 97     return adoptRef(signature);
 98 }
 99 
100 SignatureInformation::SignatureInformation()
101 {
<span class="line-added">102 #define MAKE_THUNK_SIGNATURE(type, enc, str, val)                          \</span>
<span class="line-added">103     do {                                                                   \</span>
<span class="line-added">104         if (type != Void) {                                                \</span>
<span class="line-added">105             RefPtr&lt;Signature&gt; sig = Signature::tryCreate(1, 0);            \</span>
<span class="line-added">106             sig-&gt;ref();                                                    \</span>
<span class="line-added">107             sig-&gt;getReturnType(0) = type;                                  \</span>
<span class="line-added">108             thunkSignatures[linearizeType(type)] = sig.get();              \</span>
<span class="line-added">109             m_signatureSet.add(SignatureHash { sig.releaseNonNull() });    \</span>
<span class="line-added">110         }                                                                  \</span>
<span class="line-added">111     } while (false);</span>
<span class="line-added">112 </span>
<span class="line-added">113     FOR_EACH_WASM_TYPE(MAKE_THUNK_SIGNATURE);</span>
<span class="line-added">114 </span>
<span class="line-added">115     // Make Void again because we don&#39;t use the one that has void in it.</span>
<span class="line-added">116     {</span>
<span class="line-added">117         RefPtr&lt;Signature&gt; sig = Signature::tryCreate(0, 0);</span>
<span class="line-added">118         sig-&gt;ref();</span>
<span class="line-added">119         thunkSignatures[linearizeType(Void)] = sig.get();</span>
<span class="line-added">120         m_signatureSet.add(SignatureHash { sig.releaseNonNull() });</span>
<span class="line-added">121     }</span>
122 }
123 
<span class="line-modified">124 </span>
<span class="line-added">125 </span>
<span class="line-added">126 struct ParameterTypes {</span>
<span class="line-added">127     const Vector&lt;Type, 1&gt;&amp; returnTypes;</span>
<span class="line-added">128     const Vector&lt;Type&gt;&amp; argumentTypes;</span>
<span class="line-added">129 </span>
<span class="line-added">130     static unsigned hash(const ParameterTypes&amp; params)</span>
<span class="line-added">131     {</span>
<span class="line-added">132         return computeHash(params.returnTypes.size(), params.returnTypes.data(), params.argumentTypes.size(), params.argumentTypes.data());</span>
<span class="line-added">133     }</span>
<span class="line-added">134 </span>
<span class="line-added">135     static bool equal(const SignatureHash&amp; sig, const ParameterTypes&amp; params)</span>
<span class="line-added">136     {</span>
<span class="line-added">137         if (sig.key-&gt;argumentCount() != params.argumentTypes.size())</span>
<span class="line-added">138             return false;</span>
<span class="line-added">139         if (sig.key-&gt;returnCount() != params.returnTypes.size())</span>
<span class="line-added">140             return false;</span>
<span class="line-added">141 </span>
<span class="line-added">142         for (unsigned i = 0; i &lt; sig.key-&gt;argumentCount(); ++i) {</span>
<span class="line-added">143             if (sig.key-&gt;argument(i) != params.argumentTypes[i])</span>
<span class="line-added">144                 return false;</span>
<span class="line-added">145         }</span>
<span class="line-added">146 </span>
<span class="line-added">147         for (unsigned i = 0; i &lt; sig.key-&gt;returnCount(); ++i) {</span>
<span class="line-added">148             if (sig.key-&gt;returnType(i) != params.returnTypes[i])</span>
<span class="line-added">149                 return false;</span>
<span class="line-added">150         }</span>
<span class="line-added">151         return true;</span>
<span class="line-added">152     }</span>
<span class="line-added">153 </span>
<span class="line-added">154     static void translate(SignatureHash&amp; entry, const ParameterTypes&amp; params, unsigned)</span>
<span class="line-added">155     {</span>
<span class="line-added">156         RefPtr&lt;Signature&gt; signature = Signature::tryCreate(params.returnTypes.size(), params.argumentTypes.size());</span>
<span class="line-added">157         RELEASE_ASSERT(signature);</span>
<span class="line-added">158 </span>
<span class="line-added">159         for (unsigned i = 0; i &lt; params.returnTypes.size(); ++i)</span>
<span class="line-added">160             signature-&gt;getReturnType(i) = params.returnTypes[i];</span>
<span class="line-added">161 </span>
<span class="line-added">162         for (unsigned i = 0; i &lt; params.argumentTypes.size(); ++i)</span>
<span class="line-added">163             signature-&gt;getArgument(i) = params.argumentTypes[i];</span>
<span class="line-added">164 </span>
<span class="line-added">165         entry.key = WTFMove(signature);</span>
<span class="line-added">166     }</span>
<span class="line-added">167 };</span>
<span class="line-added">168 </span>
<span class="line-added">169 RefPtr&lt;Signature&gt; SignatureInformation::signatureFor(const Vector&lt;Type, 1&gt;&amp; results, const Vector&lt;Type&gt;&amp; args)</span>
170 {
171     SignatureInformation&amp; info = singleton();
172     LockHolder lock(info.m_lock);
173 
<span class="line-modified">174     auto addResult = info.m_signatureSet.template add&lt;ParameterTypes&gt;(ParameterTypes { results, args });</span>
<span class="line-modified">175     return makeRef(*addResult.iterator-&gt;key);</span>









176 }
177 
178 void SignatureInformation::tryCleanup()
179 {
180     SignatureInformation&amp; info = singleton();
181     LockHolder lock(info.m_lock);
182 
183     info.m_signatureSet.removeIf([&amp;] (auto&amp; hash) {
184         const auto&amp; signature = hash.key;
185         return signature-&gt;refCount() == 1;
186     });
187 }
188 
189 } } // namespace JSC::Wasm
190 
191 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
</tr>
</table>
<center><a href="WasmSections.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmSignature.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
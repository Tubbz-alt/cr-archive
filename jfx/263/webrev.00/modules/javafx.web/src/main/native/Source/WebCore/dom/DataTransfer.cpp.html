<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/dom/DataTransfer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006, 2007, 2008, 2013 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DataTransfer.h&quot;
 28 
 29 #include &quot;CachedImage.h&quot;
 30 #include &quot;CachedImageClient.h&quot;
 31 #include &quot;DataTransferItem.h&quot;
 32 #include &quot;DataTransferItemList.h&quot;
 33 #include &quot;DocumentFragment.h&quot;
 34 #include &quot;DragData.h&quot;
 35 #include &quot;Editor.h&quot;
 36 #include &quot;FileList.h&quot;
 37 #include &quot;Frame.h&quot;
 38 #include &quot;FrameLoader.h&quot;
 39 #include &quot;HTMLImageElement.h&quot;
 40 #include &quot;HTMLParserIdioms.h&quot;
 41 #include &quot;Image.h&quot;
 42 #include &quot;Pasteboard.h&quot;
 43 #include &quot;RuntimeEnabledFeatures.h&quot;
 44 #include &quot;Settings.h&quot;
 45 #include &quot;StaticPasteboard.h&quot;
 46 #include &quot;WebContentReader.h&quot;
 47 #include &quot;WebCorePasteboardFileReader.h&quot;
 48 #include &quot;markup.h&quot;
 49 #include &lt;wtf/URLParser.h&gt;
 50 #include &lt;wtf/unicode/CharacterNames.h&gt;
 51 
 52 namespace WebCore {
 53 
 54 #if ENABLE(DRAG_SUPPORT)
 55 
 56 class DragImageLoader final : private CachedImageClient {
 57     WTF_MAKE_NONCOPYABLE(DragImageLoader); WTF_MAKE_FAST_ALLOCATED;
 58 public:
 59     explicit DragImageLoader(DataTransfer*);
 60     void startLoading(CachedResourceHandle&lt;CachedImage&gt;&amp;);
 61     void stopLoading(CachedResourceHandle&lt;CachedImage&gt;&amp;);
 62     void moveToDataTransfer(DataTransfer&amp;);
 63 
 64 private:
 65     void imageChanged(CachedImage*, const IntRect*) override;
 66     DataTransfer* m_dataTransfer;
 67 };
 68 
 69 #endif
 70 
 71 DataTransfer::DataTransfer(StoreMode mode, std::unique_ptr&lt;Pasteboard&gt; pasteboard, Type type)
 72     : m_storeMode(mode)
 73     , m_pasteboard(WTFMove(pasteboard))
 74 #if ENABLE(DRAG_SUPPORT)
 75     , m_type(type)
 76     , m_dropEffect(&quot;uninitialized&quot;_s)
 77     , m_effectAllowed(&quot;uninitialized&quot;_s)
 78     , m_shouldUpdateDragImage(false)
 79 #endif
 80 {
 81 #if !ENABLE(DRAG_SUPPORT)
 82     ASSERT_UNUSED(type, type != Type::DragAndDropData &amp;&amp; type != Type::DragAndDropFiles);
 83 #endif
 84 }
 85 
 86 Ref&lt;DataTransfer&gt; DataTransfer::createForCopyAndPaste(const Document&amp; document, StoreMode storeMode, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard)
 87 {
 88     auto dataTransfer = adoptRef(*new DataTransfer(storeMode, WTFMove(pasteboard)));
 89     dataTransfer-&gt;m_originIdentifier = document.originIdentifierForPasteboard();
 90     return dataTransfer;
 91 }
 92 
 93 DataTransfer::~DataTransfer()
 94 {
 95 #if ENABLE(DRAG_SUPPORT)
 96     if (m_dragImageLoader &amp;&amp; m_dragImage)
 97         m_dragImageLoader-&gt;stopLoading(m_dragImage);
 98 #endif
 99 }
100 
101 bool DataTransfer::canReadTypes() const
102 {
103     return m_storeMode == StoreMode::Readonly || m_storeMode == StoreMode::Protected || m_storeMode == StoreMode::ReadWrite;
104 }
105 
106 bool DataTransfer::canReadData() const
107 {
108     return m_storeMode == StoreMode::Readonly || m_storeMode == StoreMode::ReadWrite;
109 }
110 
111 bool DataTransfer::canWriteData() const
112 {
113     return m_storeMode == StoreMode::ReadWrite;
114 }
115 
116 static String normalizeType(const String&amp; type)
117 {
118     if (type.isNull())
119         return type;
120 
121     String lowercaseType = stripLeadingAndTrailingHTMLSpaces(type).convertToASCIILowercase();
122     if (lowercaseType == &quot;text&quot; || lowercaseType.startsWith(&quot;text/plain;&quot;))
123         return &quot;text/plain&quot;;
124     if (lowercaseType == &quot;url&quot; || lowercaseType.startsWith(&quot;text/uri-list;&quot;))
125         return &quot;text/uri-list&quot;;
126     if (lowercaseType.startsWith(&quot;text/html;&quot;))
127         return &quot;text/html&quot;;
128 
129     return lowercaseType;
130 }
131 
132 void DataTransfer::clearData(const String&amp; type)
133 {
134     if (!canWriteData())
135         return;
136 
137     String normalizedType = normalizeType(type);
138     if (normalizedType.isNull())
139         m_pasteboard-&gt;clear();
140     else
141         m_pasteboard-&gt;clear(normalizedType);
142     if (m_itemList)
143         m_itemList-&gt;didClearStringData(normalizedType);
144 }
145 
146 static String readURLsFromPasteboardAsString(Pasteboard&amp; pasteboard, Function&lt;bool(const String&amp;)&gt;&amp;&amp; shouldIncludeURL)
147 {
148     StringBuilder urlList;
149     for (const auto&amp; urlString : pasteboard.readAllStrings(&quot;text/uri-list&quot;_s)) {
150         if (!shouldIncludeURL(urlString))
151             continue;
152         if (!urlList.isEmpty())
153             urlList.append(newlineCharacter);
154         urlList.append(urlString);
155     }
156     return urlList.toString();
157 }
158 
159 String DataTransfer::getDataForItem(Document&amp; document, const String&amp; type) const
160 {
161     if (!canReadData())
162         return { };
163 
164     auto lowercaseType = stripLeadingAndTrailingHTMLSpaces(type).convertToASCIILowercase();
165     if (shouldSuppressGetAndSetDataToAvoidExposingFilePaths()) {
166         if (lowercaseType == &quot;text/uri-list&quot;) {
167             return readURLsFromPasteboardAsString(*m_pasteboard, [] (auto&amp; urlString) {
168                 return Pasteboard::canExposeURLToDOMWhenPasteboardContainsFiles(urlString);
169             });
170         }
171 
172         if (lowercaseType == &quot;text/html&quot; &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().customPasteboardDataEnabled()) {
173             // If the pasteboard contains files and the page requests &#39;text/html&#39;, we only read from rich text types to prevent file
174             // paths from leaking (e.g. from plain text data on the pasteboard) since we sanitize cross-origin markup. However, if
175             // custom pasteboard data is disabled, then we can&#39;t ensure that the markup we deliver is sanitized, so we fall back to
176             // current behavior and return an empty string.
177             return readStringFromPasteboard(document, lowercaseType, WebContentReadingPolicy::OnlyRichTextTypes);
178         }
179 
180         return { };
181     }
182 
183     return readStringFromPasteboard(document, lowercaseType, WebContentReadingPolicy::AnyType);
184 }
185 
186 String DataTransfer::readStringFromPasteboard(Document&amp; document, const String&amp; lowercaseType, WebContentReadingPolicy policy) const
187 {
188     if (!RuntimeEnabledFeatures::sharedFeatures().customPasteboardDataEnabled())
189         return m_pasteboard-&gt;readString(lowercaseType);
190 
191     // StaticPasteboard is only used to stage data written by websites before being committed to the system pasteboard.
192     bool isSameOrigin = is&lt;StaticPasteboard&gt;(*m_pasteboard) || (!m_originIdentifier.isNull() &amp;&amp; m_originIdentifier == m_pasteboard-&gt;readOrigin());
193     if (isSameOrigin) {
194         String value = m_pasteboard-&gt;readStringInCustomData(lowercaseType);
195         if (!value.isNull())
196             return value;
197     }
198     if (!Pasteboard::isSafeTypeForDOMToReadAndWrite(lowercaseType))
199         return { };
200 
201     if (!is&lt;StaticPasteboard&gt;(*m_pasteboard) &amp;&amp; lowercaseType == &quot;text/html&quot;) {
202         if (!document.frame())
203             return { };
204         WebContentMarkupReader reader { *document.frame() };
205         m_pasteboard-&gt;read(reader, policy);
206         return reader.markup;
207     }
208 
209     if (!is&lt;StaticPasteboard&gt;(*m_pasteboard) &amp;&amp; lowercaseType == &quot;text/uri-list&quot;) {
210         return readURLsFromPasteboardAsString(*m_pasteboard, [] (auto&amp;) {
211             return true;
212         });
213     }
214 
215     return m_pasteboard-&gt;readString(lowercaseType);
216 }
217 
218 String DataTransfer::getData(Document&amp; document, const String&amp; type) const
219 {
220     return getDataForItem(document, normalizeType(type));
221 }
222 
223 bool DataTransfer::shouldSuppressGetAndSetDataToAvoidExposingFilePaths() const
224 {
225     if (!forFileDrag() &amp;&amp; !RuntimeEnabledFeatures::sharedFeatures().customPasteboardDataEnabled())
226         return false;
227     return m_pasteboard-&gt;fileContentState() == Pasteboard::FileContentState::MayContainFilePaths;
228 }
229 
230 void DataTransfer::setData(const String&amp; type, const String&amp; data)
231 {
232     if (!canWriteData())
233         return;
234 
235     if (shouldSuppressGetAndSetDataToAvoidExposingFilePaths())
236         return;
237 
238     auto normalizedType = normalizeType(type);
239     setDataFromItemList(normalizedType, data);
240     if (m_itemList)
241         m_itemList-&gt;didSetStringData(normalizedType);
242 }
243 
244 void DataTransfer::setDataFromItemList(const String&amp; type, const String&amp; data)
245 {
246     ASSERT(canWriteData());
247     RELEASE_ASSERT(is&lt;StaticPasteboard&gt;(*m_pasteboard));
248 
249     if (!RuntimeEnabledFeatures::sharedFeatures().customPasteboardDataEnabled()) {
250         m_pasteboard-&gt;writeString(type, data);
251         return;
252     }
253 
254     String sanitizedData;
255     if (type == &quot;text/html&quot;)
256         sanitizedData = sanitizeMarkup(data);
257     else if (type == &quot;text/uri-list&quot;) {
258         auto url = URL({ }, data);
259         if (url.isValid())
260             sanitizedData = url.string();
261     } else if (type == &quot;text/plain&quot;)
262         sanitizedData = data; // Nothing to sanitize.
263 
264     if (sanitizedData != data)
265         downcast&lt;StaticPasteboard&gt;(*m_pasteboard).writeStringInCustomData(type, data);
266 
267     if (Pasteboard::isSafeTypeForDOMToReadAndWrite(type) &amp;&amp; !sanitizedData.isNull())
268         m_pasteboard-&gt;writeString(type, sanitizedData);
269 }
270 
271 void DataTransfer::updateFileList()
272 {
273     ASSERT(canWriteData());
274 
275     m_fileList-&gt;m_files = filesFromPasteboardAndItemList();
276 }
277 
278 void DataTransfer::didAddFileToItemList()
279 {
280     ASSERT(canWriteData());
281     if (!m_fileList)
282         return;
283 
284     auto&amp; newItem = m_itemList-&gt;items().last();
285     ASSERT(newItem-&gt;isFile());
286     m_fileList-&gt;append(*newItem-&gt;file());
287 }
288 
289 DataTransferItemList&amp; DataTransfer::items()
290 {
291     if (!m_itemList)
292         m_itemList = makeUnique&lt;DataTransferItemList&gt;(*this);
293     return *m_itemList;
294 }
295 
296 Vector&lt;String&gt; DataTransfer::types() const
297 {
298     return types(AddFilesType::Yes);
299 }
300 
301 Vector&lt;String&gt; DataTransfer::typesForItemList() const
302 {
303     return types(AddFilesType::No);
304 }
305 
306 Vector&lt;String&gt; DataTransfer::types(AddFilesType addFilesType) const
307 {
308     if (!canReadTypes())
309         return { };
310 
311     if (!RuntimeEnabledFeatures::sharedFeatures().customPasteboardDataEnabled()) {
312         auto types = m_pasteboard-&gt;typesForLegacyUnsafeBindings();
313         ASSERT(!types.contains(&quot;Files&quot;));
314         if (m_pasteboard-&gt;fileContentState() != Pasteboard::FileContentState::NoFileOrImageData &amp;&amp; addFilesType == AddFilesType::Yes)
315             types.append(&quot;Files&quot;);
316         return types;
317     }
318 
319     auto safeTypes = m_pasteboard-&gt;typesSafeForBindings(m_originIdentifier);
320     bool hasFileBackedItem = m_itemList &amp;&amp; m_itemList-&gt;hasItems() &amp;&amp; notFound != m_itemList-&gt;items().findMatching([] (const auto&amp; item) {
321         return item-&gt;isFile();
322     });
323 
324     auto fileContentState = m_pasteboard-&gt;fileContentState();
325     if (hasFileBackedItem || fileContentState != Pasteboard::FileContentState::NoFileOrImageData) {
326         Vector&lt;String&gt; types;
327         if (addFilesType == AddFilesType::Yes)
328             types.append(&quot;Files&quot;_s);
329 
330         if (fileContentState != Pasteboard::FileContentState::MayContainFilePaths) {
331             types.appendVector(WTFMove(safeTypes));
332             return types;
333         }
334 
335         if (safeTypes.contains(&quot;text/uri-list&quot;))
336             types.append(&quot;text/uri-list&quot;_s);
337         if (safeTypes.contains(&quot;text/html&quot;) &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().customPasteboardDataEnabled())
338             types.append(&quot;text/html&quot;_s);
339         return types;
340     }
341 
342     ASSERT(!safeTypes.contains(&quot;Files&quot;));
343     return safeTypes;
344 }
345 
346 Vector&lt;Ref&lt;File&gt;&gt; DataTransfer::filesFromPasteboardAndItemList() const
347 {
348     bool addedFilesFromPasteboard = false;
349     Vector&lt;Ref&lt;File&gt;&gt; files;
350     if ((!forDrag() || forFileDrag()) &amp;&amp; m_pasteboard-&gt;fileContentState() != Pasteboard::FileContentState::NoFileOrImageData) {
351         WebCorePasteboardFileReader reader;
352         m_pasteboard-&gt;read(reader);
353         files = WTFMove(reader.files);
354         addedFilesFromPasteboard = !files.isEmpty();
355     }
356 
357     bool itemListContainsItems = false;
358     if (m_itemList &amp;&amp; m_itemList-&gt;hasItems()) {
359         for (auto&amp; item : m_itemList-&gt;items()) {
360             if (auto file = item-&gt;file())
361                 files.append(file.releaseNonNull());
362         }
363         itemListContainsItems = true;
364     }
365 
366     bool containsItemsAndFiles = itemListContainsItems &amp;&amp; addedFilesFromPasteboard;
367     ASSERT_UNUSED(containsItemsAndFiles, !containsItemsAndFiles);
368     return files;
369 }
370 
371 FileList&amp; DataTransfer::files() const
372 {
373     if (!canReadData()) {
374         if (m_fileList)
375             m_fileList-&gt;clear();
376         else
377             m_fileList = FileList::create();
378         return *m_fileList;
379     }
380 
381     if (!m_fileList)
382         m_fileList = FileList::create(filesFromPasteboardAndItemList());
383 
384     return *m_fileList;
385 }
386 
387 struct PasteboardFileTypeReader final : PasteboardFileReader {
388     void readFilename(const String&amp; filename)
389     {
390         types.add(File::contentTypeForFile(filename));
391     }
392 
393     void readBuffer(const String&amp;, const String&amp; type, Ref&lt;SharedBuffer&gt;&amp;&amp;)
394     {
395         types.add(type);
396     }
397 
398     HashSet&lt;String, ASCIICaseInsensitiveHash&gt; types;
399 };
400 
401 bool DataTransfer::hasFileOfType(const String&amp; type)
402 {
403     ASSERT_WITH_SECURITY_IMPLICATION(canReadTypes());
404     PasteboardFileTypeReader reader;
405     m_pasteboard-&gt;read(reader);
406     return reader.types.contains(type);
407 }
408 
409 bool DataTransfer::hasStringOfType(const String&amp; type)
410 {
411     ASSERT_WITH_SECURITY_IMPLICATION(canReadTypes());
412 
413     return !type.isNull() &amp;&amp; types().contains(type);
414 }
415 
416 Ref&lt;DataTransfer&gt; DataTransfer::createForInputEvent(const String&amp; plainText, const String&amp; htmlText)
417 {
418     auto pasteboard = makeUnique&lt;StaticPasteboard&gt;();
419     pasteboard-&gt;writeString(&quot;text/plain&quot;_s, plainText);
420     pasteboard-&gt;writeString(&quot;text/html&quot;_s, htmlText);
421     return adoptRef(*new DataTransfer(StoreMode::Readonly, WTFMove(pasteboard), Type::InputEvent));
422 }
423 
424 void DataTransfer::commitToPasteboard(Pasteboard&amp; nativePasteboard)
425 {
426     ASSERT(is&lt;StaticPasteboard&gt;(*m_pasteboard) &amp;&amp; !is&lt;StaticPasteboard&gt;(nativePasteboard));
427     PasteboardCustomData customData = downcast&lt;StaticPasteboard&gt;(*m_pasteboard).takeCustomData();
428     if (!customData.hasData())
429         return;
430 
431     if (RuntimeEnabledFeatures::sharedFeatures().customPasteboardDataEnabled()) {
432         customData.setOrigin(m_originIdentifier);
433         nativePasteboard.writeCustomData({ customData });
434         return;
435     }
436 
437     customData.forEachPlatformString([&amp;] (auto&amp; type, auto&amp; string) {
438         nativePasteboard.writeString(type, string);
439     });
440 
441     customData.forEachCustomString([&amp;] (auto&amp; type, auto&amp; string) {
442         nativePasteboard.writeString(type, string);
443     });
444 }
445 
446 #if !ENABLE(DRAG_SUPPORT)
447 
448 String DataTransfer::dropEffect() const
449 {
450     return &quot;none&quot;_s;
451 }
452 
453 void DataTransfer::setDropEffect(const String&amp;)
454 {
455 }
456 
457 String DataTransfer::effectAllowed() const
458 {
459     return &quot;uninitialized&quot;_s;
460 }
461 
462 void DataTransfer::setEffectAllowed(const String&amp;)
463 {
464 }
465 
466 void DataTransfer::setDragImage(Element*, int, int)
467 {
468 }
469 
470 #else
471 
472 Ref&lt;DataTransfer&gt; DataTransfer::createForDrag()
473 {
474     return adoptRef(*new DataTransfer(StoreMode::ReadWrite, Pasteboard::createForDragAndDrop(), Type::DragAndDropData));
475 }
476 
477 Ref&lt;DataTransfer&gt; DataTransfer::createForDragStartEvent(const Document&amp; document)
478 {
479     auto dataTransfer = adoptRef(*new DataTransfer(StoreMode::ReadWrite, makeUnique&lt;StaticPasteboard&gt;(), Type::DragAndDropData));
480     dataTransfer-&gt;m_originIdentifier = document.originIdentifierForPasteboard();
481     return dataTransfer;
482 }
483 
484 Ref&lt;DataTransfer&gt; DataTransfer::createForDrop(const Document&amp; document, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
485 {
486     auto dataTransfer = adoptRef(*new DataTransfer(DataTransfer::StoreMode::Readonly, WTFMove(pasteboard), draggingFiles ? Type::DragAndDropFiles : Type::DragAndDropData));
487     dataTransfer-&gt;setSourceOperation(sourceOperation);
488     dataTransfer-&gt;m_originIdentifier = document.originIdentifierForPasteboard();
489     return dataTransfer;
490 }
491 
492 Ref&lt;DataTransfer&gt; DataTransfer::createForUpdatingDropTarget(const Document&amp; document, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
493 {
494     auto dataTransfer = adoptRef(*new DataTransfer(DataTransfer::StoreMode::Protected, WTFMove(pasteboard), draggingFiles ? Type::DragAndDropFiles : Type::DragAndDropData));
495     dataTransfer-&gt;setSourceOperation(sourceOperation);
496     dataTransfer-&gt;m_originIdentifier = document.originIdentifierForPasteboard();
497     return dataTransfer;
498 }
499 
500 void DataTransfer::setDragImage(Element* element, int x, int y)
501 {
502     if (!forDrag() || !canWriteData())
503         return;
504 
505     CachedImage* image = nullptr;
506     if (is&lt;HTMLImageElement&gt;(element) &amp;&amp; !element-&gt;isConnected())
507         image = downcast&lt;HTMLImageElement&gt;(*element).cachedImage();
508 
509     m_dragLocation = IntPoint(x, y);
510 
511     if (m_dragImageLoader &amp;&amp; m_dragImage)
512         m_dragImageLoader-&gt;stopLoading(m_dragImage);
513     m_dragImage = image;
514     if (m_dragImage) {
515         if (!m_dragImageLoader)
516             m_dragImageLoader = makeUnique&lt;DragImageLoader&gt;(this);
517         m_dragImageLoader-&gt;startLoading(m_dragImage);
518     }
519 
520     m_dragImageElement = image ? nullptr : element;
521 
522     updateDragImage();
523 }
524 
525 void DataTransfer::updateDragImage()
526 {
527     // Don&#39;t allow setting the image if we haven&#39;t started dragging yet; we&#39;ll rely on the dragging code
528     // to install this drag image as part of getting the drag kicked off.
529     if (!m_shouldUpdateDragImage)
530         return;
531 
532     IntPoint computedHotSpot;
533     auto computedImage = DragImage { createDragImage(computedHotSpot) };
534     if (!computedImage)
535         return;
536 
537     m_pasteboard-&gt;setDragImage(WTFMove(computedImage), computedHotSpot);
538 }
539 
540 RefPtr&lt;Element&gt; DataTransfer::dragImageElement() const
541 {
542     return m_dragImageElement;
543 }
544 
545 #if !PLATFORM(MAC)
546 
547 DragImageRef DataTransfer::createDragImage(IntPoint&amp; location) const
548 {
549     location = m_dragLocation;
550 
551     if (m_dragImage)
552         return createDragImageFromImage(m_dragImage-&gt;image(), ImageOrientation::None);
553 
554     if (m_dragImageElement) {
555         if (Frame* frame = m_dragImageElement-&gt;document().frame())
556             return createDragImageForNode(*frame, *m_dragImageElement);
557     }
558 
559     // We do not have enough information to create a drag image, use the default icon.
560     return nullptr;
561 }
562 
563 #endif
564 
565 DragImageLoader::DragImageLoader(DataTransfer* dataTransfer)
566     : m_dataTransfer(dataTransfer)
567 {
568 }
569 
570 void DragImageLoader::moveToDataTransfer(DataTransfer&amp; newDataTransfer)
571 {
572     m_dataTransfer = &amp;newDataTransfer;
573 }
574 
575 void DragImageLoader::startLoading(CachedResourceHandle&lt;WebCore::CachedImage&gt;&amp; image)
576 {
577     // FIXME: Does this really trigger a load? Does it need to?
578     image-&gt;addClient(*this);
579 }
580 
581 void DragImageLoader::stopLoading(CachedResourceHandle&lt;WebCore::CachedImage&gt;&amp; image)
582 {
583     image-&gt;removeClient(*this);
584 }
585 
586 void DragImageLoader::imageChanged(CachedImage*, const IntRect*)
587 {
588     m_dataTransfer-&gt;updateDragImage();
589 }
590 
591 static DragOperation dragOpFromIEOp(const String&amp; operation)
592 {
593     if (operation == &quot;uninitialized&quot;)
594         return DragOperationEvery;
595     if (operation == &quot;none&quot;)
596         return DragOperationNone;
597     if (operation == &quot;copy&quot;)
598         return DragOperationCopy;
599     if (operation == &quot;link&quot;)
600         return DragOperationLink;
601     if (operation == &quot;move&quot;)
602         return (DragOperation)(DragOperationGeneric | DragOperationMove);
603     if (operation == &quot;copyLink&quot;)
604         return (DragOperation)(DragOperationCopy | DragOperationLink);
605     if (operation == &quot;copyMove&quot;)
606         return (DragOperation)(DragOperationCopy | DragOperationGeneric | DragOperationMove);
607     if (operation == &quot;linkMove&quot;)
608         return (DragOperation)(DragOperationLink | DragOperationGeneric | DragOperationMove);
609     if (operation == &quot;all&quot;)
610         return DragOperationEvery;
611     return DragOperationPrivate; // really a marker for &quot;no conversion&quot;
612 }
613 
614 static const char* IEOpFromDragOp(DragOperation operation)
615 {
616     bool isGenericMove = operation &amp; (DragOperationGeneric | DragOperationMove);
617 
618     if ((isGenericMove &amp;&amp; (operation &amp; DragOperationCopy) &amp;&amp; (operation &amp; DragOperationLink)) || operation == DragOperationEvery)
619         return &quot;all&quot;;
620     if (isGenericMove &amp;&amp; (operation &amp; DragOperationCopy))
621         return &quot;copyMove&quot;;
622     if (isGenericMove &amp;&amp; (operation &amp; DragOperationLink))
623         return &quot;linkMove&quot;;
624     if ((operation &amp; DragOperationCopy) &amp;&amp; (operation &amp; DragOperationLink))
625         return &quot;copyLink&quot;;
626     if (isGenericMove)
627         return &quot;move&quot;;
628     if (operation &amp; DragOperationCopy)
629         return &quot;copy&quot;;
630     if (operation &amp; DragOperationLink)
631         return &quot;link&quot;;
632     return &quot;none&quot;;
633 }
634 
635 DragOperation DataTransfer::sourceOperation() const
636 {
637     DragOperation operation = dragOpFromIEOp(m_effectAllowed);
638     ASSERT(operation != DragOperationPrivate);
639     return operation;
640 }
641 
642 DragOperation DataTransfer::destinationOperation() const
643 {
644     DragOperation operation = dragOpFromIEOp(m_dropEffect);
645     ASSERT(operation == DragOperationCopy || operation == DragOperationNone || operation == DragOperationLink || operation == (DragOperation)(DragOperationGeneric | DragOperationMove) || operation == DragOperationEvery);
646     return operation;
647 }
648 
649 void DataTransfer::setSourceOperation(DragOperation operation)
650 {
651     ASSERT_ARG(operation, operation != DragOperationPrivate);
652     m_effectAllowed = IEOpFromDragOp(operation);
653 }
654 
655 void DataTransfer::setDestinationOperation(DragOperation operation)
656 {
657     ASSERT_ARG(operation, operation == DragOperationCopy || operation == DragOperationNone || operation == DragOperationLink || operation == DragOperationGeneric || operation == DragOperationMove || operation == (DragOperation)(DragOperationGeneric | DragOperationMove));
658     m_dropEffect = IEOpFromDragOp(operation);
659 }
660 
661 String DataTransfer::dropEffect() const
662 {
663     return m_dropEffect == &quot;uninitialized&quot; ? &quot;none&quot;_s : m_dropEffect;
664 }
665 
666 void DataTransfer::setDropEffect(const String&amp; effect)
667 {
668     if (!forDrag())
669         return;
670 
671     if (effect != &quot;none&quot; &amp;&amp; effect != &quot;copy&quot; &amp;&amp; effect != &quot;link&quot; &amp;&amp; effect != &quot;move&quot;)
672         return;
673 
674     // FIXME: The spec allows this in all circumstances. There is probably no value
675     // in ignoring attempts to change it.
676     if (!canReadTypes())
677         return;
678 
679     m_dropEffect = effect;
680 }
681 
682 String DataTransfer::effectAllowed() const
683 {
684     return m_effectAllowed;
685 }
686 
687 void DataTransfer::setEffectAllowed(const String&amp; effect)
688 {
689     if (!forDrag())
690         return;
691 
692     // Ignore any attempts to set it to an unknown value.
693     if (dragOpFromIEOp(effect) == DragOperationPrivate)
694         return;
695 
696     if (!canWriteData())
697         return;
698 
699     m_effectAllowed = effect;
700 }
701 
702 void DataTransfer::moveDragState(Ref&lt;DataTransfer&gt;&amp;&amp; other)
703 {
704     RELEASE_ASSERT(is&lt;StaticPasteboard&gt;(other-&gt;pasteboard()));
705     // We clear the platform pasteboard here to ensure that the pasteboard doesn&#39;t contain any data
706     // that may have been written before starting the drag, and after ending the last drag session.
707     // After pushing the static pasteboard&#39;s contents to the platform, the pasteboard should only
708     // contain data that was in the static pasteboard.
709     m_pasteboard-&gt;clear();
710     other-&gt;commitToPasteboard(*m_pasteboard);
711 
712     m_dropEffect = other-&gt;m_dropEffect;
713     m_effectAllowed = other-&gt;m_effectAllowed;
714     m_dragLocation = other-&gt;m_dragLocation;
715     m_dragImage = other-&gt;m_dragImage;
716     m_dragImageElement = WTFMove(other-&gt;m_dragImageElement);
717     m_dragImageLoader = WTFMove(other-&gt;m_dragImageLoader);
718     if (m_dragImageLoader)
719         m_dragImageLoader-&gt;moveToDataTransfer(*this);
720     m_fileList = WTFMove(other-&gt;m_fileList);
721 }
722 
723 bool DataTransfer::hasDragImage() const
724 {
725     return m_dragImage || m_dragImageElement;
726 }
727 
728 #endif // ENABLE(DRAG_SUPPORT)
729 
730 } // namespace WebCore
    </pre>
  </body>
</html>
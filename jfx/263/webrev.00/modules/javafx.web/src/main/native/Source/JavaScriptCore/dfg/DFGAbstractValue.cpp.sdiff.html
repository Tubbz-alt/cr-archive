<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGAbstractInterpreterInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGAbstractValue.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractValue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
249     // sure that new information gleaned from the SpeculatedType needs to be fed back
250     // into the information gleaned from the RegisteredStructureSet.
251     m_structure.filter(m_type);
252 
253     filterArrayModesByType();
254     filterValueByType();
255     return normalizeClarity(graph);
256 }
257 
258 FiltrationResult AbstractValue::changeStructure(Graph&amp; graph, const RegisteredStructureSet&amp; other)
259 {
260     m_type &amp;= other.speculationFromStructures();
261     m_arrayModes = other.arrayModesFromStructures();
262     m_structure = other;
263 
264     filterValueByType();
265 
266     return normalizeClarity(graph);
267 }
268 
<span class="line-modified">269 FiltrationResult AbstractValue::filterArrayModes(ArrayModes arrayModes)</span>
270 {
271     ASSERT(arrayModes);

272 
273     if (isClear())
274         return FiltrationOK;
275 
<span class="line-modified">276     m_type &amp;= SpecCell;</span>
277     m_arrayModes &amp;= arrayModes;
278     return normalizeClarity();
279 }
280 
281 FiltrationResult AbstractValue::filterClassInfo(Graph&amp; graph, const ClassInfo* classInfo)
282 {
283     // FIXME: AI should track ClassInfo to leverage hierarchical class information.
284     // https://bugs.webkit.org/show_bug.cgi?id=162989
285     if (isClear())
286         return FiltrationOK;
287 
288     m_type &amp;= speculationFromClassInfo(classInfo);
289     m_structure.filterClassInfo(classInfo);
290 
291     m_structure.filter(m_type);
292 
293     filterArrayModesByType();
294     filterValueByType();
295     return normalizeClarity(graph);
296 }
</pre>
<hr />
<pre>
424     FiltrationResult result;
425 
426     if (shouldBeClear()) {
427         clear();
428         result = Contradiction;
429     } else
430         result = FiltrationOK;
431 
432     checkConsistency();
433 
434     return result;
435 }
436 
437 FiltrationResult AbstractValue::normalizeClarity(Graph&amp; graph)
438 {
439     FiltrationResult result = normalizeClarity();
440     assertIsRegistered(graph);
441     return result;
442 }
443 
<span class="line-modified">444 #if !ASSERT_DISABLED</span>
445 void AbstractValue::checkConsistency() const
446 {
447     if (!(m_type &amp; SpecCell)) {
448         RELEASE_ASSERT(m_structure.isClear());
449         RELEASE_ASSERT(!m_arrayModes);
450     }
451 
452     if (isClear())
453         RELEASE_ASSERT(!m_value);
454 
455     if (!!m_value)
456         RELEASE_ASSERT(validateTypeAcceptingBoxedInt52(m_value));
457 
458     // Note that it&#39;s possible for a prediction like (Final, []). This really means that
459     // the value is bottom and that any code that uses the value is unreachable. But
460     // we don&#39;t want to get pedantic about this as it would only increase the computational
461     // complexity of the code.
462 }
463 
464 void AbstractValue::assertIsRegistered(Graph&amp; graph) const
465 {
466     m_structure.assertIsRegistered(graph);
467 }
<span class="line-modified">468 #endif // !ASSERT_DISABLED</span>
469 
470 ResultType AbstractValue::resultType() const
471 {
472     ASSERT(isType(SpecBytecodeTop));
473     if (isType(SpecBoolean))
474         return ResultType::booleanType();
475     if (isType(SpecInt32Only))
476         return ResultType::numberTypeIsInt32();
477     if (isType(SpecBytecodeNumber))
478         return ResultType::numberType();
479     if (isType(SpecString))
480         return ResultType::stringType();
481     if (isType(SpecString | SpecBytecodeNumber))
482         return ResultType::stringOrNumberType();
483     return ResultType::unknownType();
484 }
485 
486 void AbstractValue::dump(PrintStream&amp; out) const
487 {
488     dumpInContext(out, 0);
</pre>
</td>
<td>
<hr />
<pre>
249     // sure that new information gleaned from the SpeculatedType needs to be fed back
250     // into the information gleaned from the RegisteredStructureSet.
251     m_structure.filter(m_type);
252 
253     filterArrayModesByType();
254     filterValueByType();
255     return normalizeClarity(graph);
256 }
257 
258 FiltrationResult AbstractValue::changeStructure(Graph&amp; graph, const RegisteredStructureSet&amp; other)
259 {
260     m_type &amp;= other.speculationFromStructures();
261     m_arrayModes = other.arrayModesFromStructures();
262     m_structure = other;
263 
264     filterValueByType();
265 
266     return normalizeClarity(graph);
267 }
268 
<span class="line-modified">269 FiltrationResult AbstractValue::filterArrayModes(ArrayModes arrayModes, SpeculatedType admittedTypes)</span>
270 {
271     ASSERT(arrayModes);
<span class="line-added">272     ASSERT(!(admittedTypes &amp; SpecCell));</span>
273 
274     if (isClear())
275         return FiltrationOK;
276 
<span class="line-modified">277     m_type &amp;= SpecCell | admittedTypes;</span>
278     m_arrayModes &amp;= arrayModes;
279     return normalizeClarity();
280 }
281 
282 FiltrationResult AbstractValue::filterClassInfo(Graph&amp; graph, const ClassInfo* classInfo)
283 {
284     // FIXME: AI should track ClassInfo to leverage hierarchical class information.
285     // https://bugs.webkit.org/show_bug.cgi?id=162989
286     if (isClear())
287         return FiltrationOK;
288 
289     m_type &amp;= speculationFromClassInfo(classInfo);
290     m_structure.filterClassInfo(classInfo);
291 
292     m_structure.filter(m_type);
293 
294     filterArrayModesByType();
295     filterValueByType();
296     return normalizeClarity(graph);
297 }
</pre>
<hr />
<pre>
425     FiltrationResult result;
426 
427     if (shouldBeClear()) {
428         clear();
429         result = Contradiction;
430     } else
431         result = FiltrationOK;
432 
433     checkConsistency();
434 
435     return result;
436 }
437 
438 FiltrationResult AbstractValue::normalizeClarity(Graph&amp; graph)
439 {
440     FiltrationResult result = normalizeClarity();
441     assertIsRegistered(graph);
442     return result;
443 }
444 
<span class="line-modified">445 #if ASSERT_ENABLED</span>
446 void AbstractValue::checkConsistency() const
447 {
448     if (!(m_type &amp; SpecCell)) {
449         RELEASE_ASSERT(m_structure.isClear());
450         RELEASE_ASSERT(!m_arrayModes);
451     }
452 
453     if (isClear())
454         RELEASE_ASSERT(!m_value);
455 
456     if (!!m_value)
457         RELEASE_ASSERT(validateTypeAcceptingBoxedInt52(m_value));
458 
459     // Note that it&#39;s possible for a prediction like (Final, []). This really means that
460     // the value is bottom and that any code that uses the value is unreachable. But
461     // we don&#39;t want to get pedantic about this as it would only increase the computational
462     // complexity of the code.
463 }
464 
465 void AbstractValue::assertIsRegistered(Graph&amp; graph) const
466 {
467     m_structure.assertIsRegistered(graph);
468 }
<span class="line-modified">469 #endif // ASSERT_ENABLED</span>
470 
471 ResultType AbstractValue::resultType() const
472 {
473     ASSERT(isType(SpecBytecodeTop));
474     if (isType(SpecBoolean))
475         return ResultType::booleanType();
476     if (isType(SpecInt32Only))
477         return ResultType::numberTypeIsInt32();
478     if (isType(SpecBytecodeNumber))
479         return ResultType::numberType();
480     if (isType(SpecString))
481         return ResultType::stringType();
482     if (isType(SpecString | SpecBytecodeNumber))
483         return ResultType::stringOrNumberType();
484     return ResultType::unknownType();
485 }
486 
487 void AbstractValue::dump(PrintStream&amp; out) const
488 {
489     dumpInContext(out, 0);
</pre>
</td>
</tr>
</table>
<center><a href="DFGAbstractInterpreterInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGAbstractValue.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
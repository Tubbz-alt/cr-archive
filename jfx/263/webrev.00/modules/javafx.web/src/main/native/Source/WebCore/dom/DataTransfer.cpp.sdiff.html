<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/DataTransfer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DOMImplementation.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DataTransfer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/DataTransfer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 51 
 52 namespace WebCore {
 53 
 54 #if ENABLE(DRAG_SUPPORT)
 55 
 56 class DragImageLoader final : private CachedImageClient {
 57     WTF_MAKE_NONCOPYABLE(DragImageLoader); WTF_MAKE_FAST_ALLOCATED;
 58 public:
 59     explicit DragImageLoader(DataTransfer*);
 60     void startLoading(CachedResourceHandle&lt;CachedImage&gt;&amp;);
 61     void stopLoading(CachedResourceHandle&lt;CachedImage&gt;&amp;);
 62     void moveToDataTransfer(DataTransfer&amp;);
 63 
 64 private:
 65     void imageChanged(CachedImage*, const IntRect*) override;
 66     DataTransfer* m_dataTransfer;
 67 };
 68 
 69 #endif
 70 
<span class="line-modified"> 71 DataTransfer::DataTransfer(const Document&amp; document, StoreMode mode, std::unique_ptr&lt;Pasteboard&gt; pasteboard, Type type)</span>
<span class="line-modified"> 72     : m_sessionID(document.sessionID())</span>
<span class="line-removed"> 73     , m_storeMode(mode)</span>
 74     , m_pasteboard(WTFMove(pasteboard))
 75 #if ENABLE(DRAG_SUPPORT)
 76     , m_type(type)
 77     , m_dropEffect(&quot;uninitialized&quot;_s)
 78     , m_effectAllowed(&quot;uninitialized&quot;_s)
 79     , m_shouldUpdateDragImage(false)
 80 #endif
 81 {
 82 #if !ENABLE(DRAG_SUPPORT)
 83     ASSERT_UNUSED(type, type != Type::DragAndDropData &amp;&amp; type != Type::DragAndDropFiles);
 84 #endif
 85 }
 86 
 87 Ref&lt;DataTransfer&gt; DataTransfer::createForCopyAndPaste(const Document&amp; document, StoreMode storeMode, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard)
 88 {
<span class="line-modified"> 89     auto dataTransfer = adoptRef(*new DataTransfer(document, storeMode, WTFMove(pasteboard)));</span>
 90     dataTransfer-&gt;m_originIdentifier = document.originIdentifierForPasteboard();
 91     return dataTransfer;
 92 }
 93 
 94 DataTransfer::~DataTransfer()
 95 {
 96 #if ENABLE(DRAG_SUPPORT)
 97     if (m_dragImageLoader &amp;&amp; m_dragImage)
 98         m_dragImageLoader-&gt;stopLoading(m_dragImage);
 99 #endif
100 }
101 
102 bool DataTransfer::canReadTypes() const
103 {
104     return m_storeMode == StoreMode::Readonly || m_storeMode == StoreMode::Protected || m_storeMode == StoreMode::ReadWrite;
105 }
106 
107 bool DataTransfer::canReadData() const
108 {
109     return m_storeMode == StoreMode::Readonly || m_storeMode == StoreMode::ReadWrite;
</pre>
<hr />
<pre>
332             types.appendVector(WTFMove(safeTypes));
333             return types;
334         }
335 
336         if (safeTypes.contains(&quot;text/uri-list&quot;))
337             types.append(&quot;text/uri-list&quot;_s);
338         if (safeTypes.contains(&quot;text/html&quot;) &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().customPasteboardDataEnabled())
339             types.append(&quot;text/html&quot;_s);
340         return types;
341     }
342 
343     ASSERT(!safeTypes.contains(&quot;Files&quot;));
344     return safeTypes;
345 }
346 
347 Vector&lt;Ref&lt;File&gt;&gt; DataTransfer::filesFromPasteboardAndItemList() const
348 {
349     bool addedFilesFromPasteboard = false;
350     Vector&lt;Ref&lt;File&gt;&gt; files;
351     if ((!forDrag() || forFileDrag()) &amp;&amp; m_pasteboard-&gt;fileContentState() != Pasteboard::FileContentState::NoFileOrImageData) {
<span class="line-modified">352         WebCorePasteboardFileReader reader { m_sessionID };</span>
353         m_pasteboard-&gt;read(reader);
354         files = WTFMove(reader.files);
355         addedFilesFromPasteboard = !files.isEmpty();
356     }
357 
358     bool itemListContainsItems = false;
359     if (m_itemList &amp;&amp; m_itemList-&gt;hasItems()) {
360         for (auto&amp; item : m_itemList-&gt;items()) {
361             if (auto file = item-&gt;file())
362                 files.append(file.releaseNonNull());
363         }
364         itemListContainsItems = true;
365     }
366 
367     bool containsItemsAndFiles = itemListContainsItems &amp;&amp; addedFilesFromPasteboard;
368     ASSERT_UNUSED(containsItemsAndFiles, !containsItemsAndFiles);
369     return files;
370 }
371 
372 FileList&amp; DataTransfer::files() const
</pre>
<hr />
<pre>
397     }
398 
399     HashSet&lt;String, ASCIICaseInsensitiveHash&gt; types;
400 };
401 
402 bool DataTransfer::hasFileOfType(const String&amp; type)
403 {
404     ASSERT_WITH_SECURITY_IMPLICATION(canReadTypes());
405     PasteboardFileTypeReader reader;
406     m_pasteboard-&gt;read(reader);
407     return reader.types.contains(type);
408 }
409 
410 bool DataTransfer::hasStringOfType(const String&amp; type)
411 {
412     ASSERT_WITH_SECURITY_IMPLICATION(canReadTypes());
413 
414     return !type.isNull() &amp;&amp; types().contains(type);
415 }
416 
<span class="line-modified">417 Ref&lt;DataTransfer&gt; DataTransfer::createForInputEvent(const Document&amp; document, const String&amp; plainText, const String&amp; htmlText)</span>
418 {
419     auto pasteboard = makeUnique&lt;StaticPasteboard&gt;();
420     pasteboard-&gt;writeString(&quot;text/plain&quot;_s, plainText);
421     pasteboard-&gt;writeString(&quot;text/html&quot;_s, htmlText);
<span class="line-modified">422     return adoptRef(*new DataTransfer(document, StoreMode::Readonly, WTFMove(pasteboard), Type::InputEvent));</span>
423 }
424 
425 void DataTransfer::commitToPasteboard(Pasteboard&amp; nativePasteboard)
426 {
427     ASSERT(is&lt;StaticPasteboard&gt;(*m_pasteboard) &amp;&amp; !is&lt;StaticPasteboard&gt;(nativePasteboard));
428     PasteboardCustomData customData = downcast&lt;StaticPasteboard&gt;(*m_pasteboard).takeCustomData();



429     if (RuntimeEnabledFeatures::sharedFeatures().customPasteboardDataEnabled()) {
<span class="line-modified">430         customData.origin = m_originIdentifier;</span>
<span class="line-modified">431         nativePasteboard.writeCustomData(customData);</span>
432         return;
433     }
434 
<span class="line-modified">435     for (auto&amp; entry : customData.platformData)</span>
<span class="line-modified">436         nativePasteboard.writeString(entry.key, entry.value);</span>
<span class="line-modified">437     for (auto&amp; entry : customData.sameOriginCustomData)</span>
<span class="line-modified">438         nativePasteboard.writeString(entry.key, entry.value);</span>



439 }
440 
441 #if !ENABLE(DRAG_SUPPORT)
442 
443 String DataTransfer::dropEffect() const
444 {
445     return &quot;none&quot;_s;
446 }
447 
448 void DataTransfer::setDropEffect(const String&amp;)
449 {
450 }
451 
452 String DataTransfer::effectAllowed() const
453 {
454     return &quot;uninitialized&quot;_s;
455 }
456 
457 void DataTransfer::setEffectAllowed(const String&amp;)
458 {
459 }
460 
461 void DataTransfer::setDragImage(Element*, int, int)
462 {
463 }
464 
465 #else
466 
<span class="line-modified">467 Ref&lt;DataTransfer&gt; DataTransfer::createForDrag(const Document&amp; document)</span>
468 {
<span class="line-modified">469     return adoptRef(*new DataTransfer(document, StoreMode::ReadWrite, Pasteboard::createForDragAndDrop(), Type::DragAndDropData));</span>
470 }
471 
472 Ref&lt;DataTransfer&gt; DataTransfer::createForDragStartEvent(const Document&amp; document)
473 {
<span class="line-modified">474     auto dataTransfer = adoptRef(*new DataTransfer(document, StoreMode::ReadWrite, makeUnique&lt;StaticPasteboard&gt;(), Type::DragAndDropData));</span>
475     dataTransfer-&gt;m_originIdentifier = document.originIdentifierForPasteboard();
476     return dataTransfer;
477 }
478 
479 Ref&lt;DataTransfer&gt; DataTransfer::createForDrop(const Document&amp; document, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
480 {
<span class="line-modified">481     auto dataTransfer = adoptRef(*new DataTransfer(document, DataTransfer::StoreMode::Readonly, WTFMove(pasteboard), draggingFiles ? Type::DragAndDropFiles : Type::DragAndDropData));</span>
482     dataTransfer-&gt;setSourceOperation(sourceOperation);
483     dataTransfer-&gt;m_originIdentifier = document.originIdentifierForPasteboard();
484     return dataTransfer;
485 }
486 
487 Ref&lt;DataTransfer&gt; DataTransfer::createForUpdatingDropTarget(const Document&amp; document, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
488 {
<span class="line-modified">489     auto dataTransfer = adoptRef(*new DataTransfer(document, DataTransfer::StoreMode::Protected, WTFMove(pasteboard), draggingFiles ? Type::DragAndDropFiles : Type::DragAndDropData));</span>
490     dataTransfer-&gt;setSourceOperation(sourceOperation);
491     dataTransfer-&gt;m_originIdentifier = document.originIdentifierForPasteboard();
492     return dataTransfer;
493 }
494 
495 void DataTransfer::setDragImage(Element* element, int x, int y)
496 {
497     if (!forDrag() || !canWriteData())
498         return;
499 
500     CachedImage* image = nullptr;
501     if (is&lt;HTMLImageElement&gt;(element) &amp;&amp; !element-&gt;isConnected())
502         image = downcast&lt;HTMLImageElement&gt;(*element).cachedImage();
503 
504     m_dragLocation = IntPoint(x, y);
505 
506     if (m_dragImageLoader &amp;&amp; m_dragImage)
507         m_dragImageLoader-&gt;stopLoading(m_dragImage);
508     m_dragImage = image;
509     if (m_dragImage) {
</pre>
</td>
<td>
<hr />
<pre>
 51 
 52 namespace WebCore {
 53 
 54 #if ENABLE(DRAG_SUPPORT)
 55 
 56 class DragImageLoader final : private CachedImageClient {
 57     WTF_MAKE_NONCOPYABLE(DragImageLoader); WTF_MAKE_FAST_ALLOCATED;
 58 public:
 59     explicit DragImageLoader(DataTransfer*);
 60     void startLoading(CachedResourceHandle&lt;CachedImage&gt;&amp;);
 61     void stopLoading(CachedResourceHandle&lt;CachedImage&gt;&amp;);
 62     void moveToDataTransfer(DataTransfer&amp;);
 63 
 64 private:
 65     void imageChanged(CachedImage*, const IntRect*) override;
 66     DataTransfer* m_dataTransfer;
 67 };
 68 
 69 #endif
 70 
<span class="line-modified"> 71 DataTransfer::DataTransfer(StoreMode mode, std::unique_ptr&lt;Pasteboard&gt; pasteboard, Type type)</span>
<span class="line-modified"> 72     : m_storeMode(mode)</span>

 73     , m_pasteboard(WTFMove(pasteboard))
 74 #if ENABLE(DRAG_SUPPORT)
 75     , m_type(type)
 76     , m_dropEffect(&quot;uninitialized&quot;_s)
 77     , m_effectAllowed(&quot;uninitialized&quot;_s)
 78     , m_shouldUpdateDragImage(false)
 79 #endif
 80 {
 81 #if !ENABLE(DRAG_SUPPORT)
 82     ASSERT_UNUSED(type, type != Type::DragAndDropData &amp;&amp; type != Type::DragAndDropFiles);
 83 #endif
 84 }
 85 
 86 Ref&lt;DataTransfer&gt; DataTransfer::createForCopyAndPaste(const Document&amp; document, StoreMode storeMode, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard)
 87 {
<span class="line-modified"> 88     auto dataTransfer = adoptRef(*new DataTransfer(storeMode, WTFMove(pasteboard)));</span>
 89     dataTransfer-&gt;m_originIdentifier = document.originIdentifierForPasteboard();
 90     return dataTransfer;
 91 }
 92 
 93 DataTransfer::~DataTransfer()
 94 {
 95 #if ENABLE(DRAG_SUPPORT)
 96     if (m_dragImageLoader &amp;&amp; m_dragImage)
 97         m_dragImageLoader-&gt;stopLoading(m_dragImage);
 98 #endif
 99 }
100 
101 bool DataTransfer::canReadTypes() const
102 {
103     return m_storeMode == StoreMode::Readonly || m_storeMode == StoreMode::Protected || m_storeMode == StoreMode::ReadWrite;
104 }
105 
106 bool DataTransfer::canReadData() const
107 {
108     return m_storeMode == StoreMode::Readonly || m_storeMode == StoreMode::ReadWrite;
</pre>
<hr />
<pre>
331             types.appendVector(WTFMove(safeTypes));
332             return types;
333         }
334 
335         if (safeTypes.contains(&quot;text/uri-list&quot;))
336             types.append(&quot;text/uri-list&quot;_s);
337         if (safeTypes.contains(&quot;text/html&quot;) &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().customPasteboardDataEnabled())
338             types.append(&quot;text/html&quot;_s);
339         return types;
340     }
341 
342     ASSERT(!safeTypes.contains(&quot;Files&quot;));
343     return safeTypes;
344 }
345 
346 Vector&lt;Ref&lt;File&gt;&gt; DataTransfer::filesFromPasteboardAndItemList() const
347 {
348     bool addedFilesFromPasteboard = false;
349     Vector&lt;Ref&lt;File&gt;&gt; files;
350     if ((!forDrag() || forFileDrag()) &amp;&amp; m_pasteboard-&gt;fileContentState() != Pasteboard::FileContentState::NoFileOrImageData) {
<span class="line-modified">351         WebCorePasteboardFileReader reader;</span>
352         m_pasteboard-&gt;read(reader);
353         files = WTFMove(reader.files);
354         addedFilesFromPasteboard = !files.isEmpty();
355     }
356 
357     bool itemListContainsItems = false;
358     if (m_itemList &amp;&amp; m_itemList-&gt;hasItems()) {
359         for (auto&amp; item : m_itemList-&gt;items()) {
360             if (auto file = item-&gt;file())
361                 files.append(file.releaseNonNull());
362         }
363         itemListContainsItems = true;
364     }
365 
366     bool containsItemsAndFiles = itemListContainsItems &amp;&amp; addedFilesFromPasteboard;
367     ASSERT_UNUSED(containsItemsAndFiles, !containsItemsAndFiles);
368     return files;
369 }
370 
371 FileList&amp; DataTransfer::files() const
</pre>
<hr />
<pre>
396     }
397 
398     HashSet&lt;String, ASCIICaseInsensitiveHash&gt; types;
399 };
400 
401 bool DataTransfer::hasFileOfType(const String&amp; type)
402 {
403     ASSERT_WITH_SECURITY_IMPLICATION(canReadTypes());
404     PasteboardFileTypeReader reader;
405     m_pasteboard-&gt;read(reader);
406     return reader.types.contains(type);
407 }
408 
409 bool DataTransfer::hasStringOfType(const String&amp; type)
410 {
411     ASSERT_WITH_SECURITY_IMPLICATION(canReadTypes());
412 
413     return !type.isNull() &amp;&amp; types().contains(type);
414 }
415 
<span class="line-modified">416 Ref&lt;DataTransfer&gt; DataTransfer::createForInputEvent(const String&amp; plainText, const String&amp; htmlText)</span>
417 {
418     auto pasteboard = makeUnique&lt;StaticPasteboard&gt;();
419     pasteboard-&gt;writeString(&quot;text/plain&quot;_s, plainText);
420     pasteboard-&gt;writeString(&quot;text/html&quot;_s, htmlText);
<span class="line-modified">421     return adoptRef(*new DataTransfer(StoreMode::Readonly, WTFMove(pasteboard), Type::InputEvent));</span>
422 }
423 
424 void DataTransfer::commitToPasteboard(Pasteboard&amp; nativePasteboard)
425 {
426     ASSERT(is&lt;StaticPasteboard&gt;(*m_pasteboard) &amp;&amp; !is&lt;StaticPasteboard&gt;(nativePasteboard));
427     PasteboardCustomData customData = downcast&lt;StaticPasteboard&gt;(*m_pasteboard).takeCustomData();
<span class="line-added">428     if (!customData.hasData())</span>
<span class="line-added">429         return;</span>
<span class="line-added">430 </span>
431     if (RuntimeEnabledFeatures::sharedFeatures().customPasteboardDataEnabled()) {
<span class="line-modified">432         customData.setOrigin(m_originIdentifier);</span>
<span class="line-modified">433         nativePasteboard.writeCustomData({ customData });</span>
434         return;
435     }
436 
<span class="line-modified">437     customData.forEachPlatformString([&amp;] (auto&amp; type, auto&amp; string) {</span>
<span class="line-modified">438         nativePasteboard.writeString(type, string);</span>
<span class="line-modified">439     });</span>
<span class="line-modified">440 </span>
<span class="line-added">441     customData.forEachCustomString([&amp;] (auto&amp; type, auto&amp; string) {</span>
<span class="line-added">442         nativePasteboard.writeString(type, string);</span>
<span class="line-added">443     });</span>
444 }
445 
446 #if !ENABLE(DRAG_SUPPORT)
447 
448 String DataTransfer::dropEffect() const
449 {
450     return &quot;none&quot;_s;
451 }
452 
453 void DataTransfer::setDropEffect(const String&amp;)
454 {
455 }
456 
457 String DataTransfer::effectAllowed() const
458 {
459     return &quot;uninitialized&quot;_s;
460 }
461 
462 void DataTransfer::setEffectAllowed(const String&amp;)
463 {
464 }
465 
466 void DataTransfer::setDragImage(Element*, int, int)
467 {
468 }
469 
470 #else
471 
<span class="line-modified">472 Ref&lt;DataTransfer&gt; DataTransfer::createForDrag()</span>
473 {
<span class="line-modified">474     return adoptRef(*new DataTransfer(StoreMode::ReadWrite, Pasteboard::createForDragAndDrop(), Type::DragAndDropData));</span>
475 }
476 
477 Ref&lt;DataTransfer&gt; DataTransfer::createForDragStartEvent(const Document&amp; document)
478 {
<span class="line-modified">479     auto dataTransfer = adoptRef(*new DataTransfer(StoreMode::ReadWrite, makeUnique&lt;StaticPasteboard&gt;(), Type::DragAndDropData));</span>
480     dataTransfer-&gt;m_originIdentifier = document.originIdentifierForPasteboard();
481     return dataTransfer;
482 }
483 
484 Ref&lt;DataTransfer&gt; DataTransfer::createForDrop(const Document&amp; document, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
485 {
<span class="line-modified">486     auto dataTransfer = adoptRef(*new DataTransfer(DataTransfer::StoreMode::Readonly, WTFMove(pasteboard), draggingFiles ? Type::DragAndDropFiles : Type::DragAndDropData));</span>
487     dataTransfer-&gt;setSourceOperation(sourceOperation);
488     dataTransfer-&gt;m_originIdentifier = document.originIdentifierForPasteboard();
489     return dataTransfer;
490 }
491 
492 Ref&lt;DataTransfer&gt; DataTransfer::createForUpdatingDropTarget(const Document&amp; document, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
493 {
<span class="line-modified">494     auto dataTransfer = adoptRef(*new DataTransfer(DataTransfer::StoreMode::Protected, WTFMove(pasteboard), draggingFiles ? Type::DragAndDropFiles : Type::DragAndDropData));</span>
495     dataTransfer-&gt;setSourceOperation(sourceOperation);
496     dataTransfer-&gt;m_originIdentifier = document.originIdentifierForPasteboard();
497     return dataTransfer;
498 }
499 
500 void DataTransfer::setDragImage(Element* element, int x, int y)
501 {
502     if (!forDrag() || !canWriteData())
503         return;
504 
505     CachedImage* image = nullptr;
506     if (is&lt;HTMLImageElement&gt;(element) &amp;&amp; !element-&gt;isConnected())
507         image = downcast&lt;HTMLImageElement&gt;(*element).cachedImage();
508 
509     m_dragLocation = IntPoint(x, y);
510 
511     if (m_dragImageLoader &amp;&amp; m_dragImage)
512         m_dragImageLoader-&gt;stopLoading(m_dragImage);
513     m_dragImage = image;
514     if (m_dragImage) {
</pre>
</td>
</tr>
</table>
<center><a href="DOMImplementation.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DataTransfer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
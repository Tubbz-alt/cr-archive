diff a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoSharedPageInlines.h b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoSharedPageInlines.h
--- a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoSharedPageInlines.h
+++ b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoSharedPageInlines.h
@@ -33,22 +33,22 @@
 
 // IsoSharedPage never becomes empty state again after we allocate some cells from IsoSharedPage. This makes IsoSharedPage management super simple.
 // This is because empty IsoSharedPage is still split into various different objects that should keep some part of virtual memory region dedicated.
 // We cannot set up bump allocation for such a page. Not freeing IsoSharedPages are OK since IsoSharedPage is only used for the lower tier of IsoHeap.
 template<typename Config, typename Type>
-void IsoSharedPage::free(const std::lock_guard<Mutex>&, api::IsoHeap<Type>& handle, void* ptr)
+void IsoSharedPage::free(const LockHolder&, api::IsoHeap<Type>& handle, void* ptr)
 {
     auto& heapImpl = handle.impl();
     uint8_t index = *indexSlotFor<Config>(ptr) & IsoHeapImplBase::maxAllocationFromSharedMask;
     // IsoDeallocator::deallocate is called from delete operator. This is dispatched by vtable if virtual destructor exists.
     // If vptr is replaced to the other vptr, we may accidentally chain this pointer to the incorrect HeapImplBase, which totally breaks the IsoHeap's goal.
     // To harden that, we validate that this pointer is actually allocated for a specific HeapImplBase here by checking whether this pointer is listed in HeapImplBase's shared cells.
-    RELEASE_BASSERT(heapImpl.m_sharedCells[index] == ptr);
+    RELEASE_BASSERT(heapImpl.m_sharedCells[index].get() == ptr);
     heapImpl.m_availableShared |= (1U << index);
 }
 
-inline VariadicBumpAllocator IsoSharedPage::startAllocating()
+inline VariadicBumpAllocator IsoSharedPage::startAllocating(const LockHolder&)
 {
     static constexpr bool verbose = false;
 
     if (verbose) {
         fprintf(stderr, "%p: starting shared allocation.\n", this);
@@ -59,11 +59,11 @@
     unsigned remaining = static_cast<unsigned>(roundDownToMultipleOf<alignmentForIsoSharedAllocation>(static_cast<uintptr_t>(IsoSharedPage::pageSize - sizeof(IsoSharedPage))));
 
     return VariadicBumpAllocator(payloadEnd, remaining);
 }
 
-inline void IsoSharedPage::stopAllocating()
+inline void IsoSharedPage::stopAllocating(const LockHolder&)
 {
     static constexpr bool verbose = false;
 
     if (verbose)
         fprintf(stderr, "%p: stopping shared allocation.\n", this);

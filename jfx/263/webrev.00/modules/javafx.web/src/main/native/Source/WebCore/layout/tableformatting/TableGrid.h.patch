diff a/modules/javafx.web/src/main/native/Source/WebCore/layout/tableformatting/TableGrid.h b/modules/javafx.web/src/main/native/Source/WebCore/layout/tableformatting/TableGrid.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/layout/tableformatting/TableGrid.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/layout/tableformatting/TableGrid.h
@@ -25,29 +25,37 @@
 
 #pragma once
 
 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 
+#include "FormattingContext.h"
 #include "IntPointHash.h"
-#include "LayoutBox.h"
 #include <wtf/HashMap.h>
 #include <wtf/IsoMalloc.h>
 #include <wtf/ListHashSet.h>
 #include <wtf/WeakPtr.h>
 
 namespace WebCore {
 namespace Layout {
+class Box;
 
 class TableGrid {
     WTF_MAKE_ISO_ALLOCATED(TableGrid);
 public:
     TableGrid();
 
     void appendCell(const Box&);
     void insertCell(const Box&, const Box& before);
     void removeCell(const Box&);
 
+    void setHorizontalSpacing(LayoutUnit horizontalSpacing) { m_horizontalSpacing = horizontalSpacing; }
+    LayoutUnit horizontalSpacing() const { return m_horizontalSpacing; }
+    LayoutUnit totalHorizontalSpacing() const { return (columnsContext().columns().size() + 1) * horizontalSpacing(); }
+
+    void setVerticalSpacing(LayoutUnit verticalSpacing) { m_verticalSpacing = verticalSpacing; }
+    LayoutUnit verticalSpacing() const { return m_verticalSpacing; }
+
     using SlotPosition = IntPoint;
 
     // Cell represents a <td> or <th>. It can span multiple slots in the grid.
     using CellSize = IntSize;
     struct CellInfo : public CanMakeWeakPtr<CellInfo> {
@@ -66,26 +74,30 @@
     class Column {
     public:
         void setWidthConstraints(FormattingContext::IntrinsicWidthConstraints);
         FormattingContext::IntrinsicWidthConstraints widthConstraints() const;
 
+        void setLogicalLeft(LayoutUnit);
+        LayoutUnit logicalLeft() const;
+        LayoutUnit logicalRight() const { return logicalLeft() + logicalWidth(); }
         void setLogicalWidth(LayoutUnit);
         LayoutUnit logicalWidth() const;
 
-        void setLogicalLeft(LayoutUnit);
-        LayoutUnit logicalLeft() const;
+        bool hasFixedWidth() const;
 
-        LayoutUnit logicalRight() const { return logicalLeft() + logicalWidth(); }
+        const Box* columnBox() const { return m_columnBox.get(); }
 
     private:
         friend class ColumnsContext;
-        Column() = default;
+        Column(const Box* columnBox);
 
         FormattingContext::IntrinsicWidthConstraints m_widthConstraints;
         LayoutUnit m_computedLogicalWidth;
         LayoutUnit m_computedLogicalLeft;
-#ifndef NDEBUG
+        WeakPtr<const Box> m_columnBox;
+
+#if ASSERT_ENABLED
         bool m_hasWidthConstraints { false };
         bool m_hasComputedWidth { false };
         bool m_hasComputedLeft { false };
 #endif
     };
@@ -93,24 +105,28 @@
     class ColumnsContext {
     public:
         using ColumnList = Vector<Column>;
         ColumnList& columns() { return m_columns; }
         const ColumnList& columns() const { return m_columns; }
+        void addColumn(const Box* columnBox = nullptr);
 
-        enum class WidthConstraintsType { Minimum, Maximum };
-        void useAsLogicalWidth(WidthConstraintsType);
+        LayoutUnit logicalWidth() const { return columns().last().logicalRight() - columns().first().logicalLeft(); }
 
     private:
         friend class TableGrid;
-        void addColumn();
 
         ColumnList m_columns;
     };
+    const ColumnsContext& columnsContext() const { return m_columnsContext; }
     ColumnsContext& columnsContext() { return m_columnsContext; }
 
     struct Row {
     public:
+        Row(const Box&);
+
+        const Box& box() const { return m_layoutBox; }
+
         void setLogicalTop(LayoutUnit logicalTop) { m_logicalTop = logicalTop; }
         LayoutUnit logicalTop() const { return m_logicalTop; }
 
         void setLogicalHeight(LayoutUnit logicalHeight) { m_logicalHeight = logicalHeight; }
         LayoutUnit logicalHeight() const { return m_logicalHeight; }
@@ -118,10 +134,11 @@
         LayoutUnit logicalBottom() const { return logicalTop() + logicalHeight(); }
 
     private:
         LayoutUnit m_logicalTop;
         LayoutUnit m_logicalHeight;
+        const Box& m_layoutBox;
     };
     using RowList = WTF::Vector<Row>;
     RowList& rows() { return m_rows; }
 
     struct SlotInfo {
@@ -132,19 +149,23 @@
         WeakPtr<CellInfo> cell;
         FormattingContext::IntrinsicWidthConstraints widthConstraints;
     };
     SlotInfo* slot(SlotPosition);
 
-    FormattingContext::IntrinsicWidthConstraints widthConstraints() const;
+    bool hasComputedWidthConstraints() const { return m_intrinsicWidthConstraints.hasValue(); }
+    FormattingContext::IntrinsicWidthConstraints widthConstraints();
 
 private:
     using SlotMap = WTF::HashMap<SlotPosition, std::unique_ptr<SlotInfo>>;
 
     SlotMap m_slotMap;
     CellList m_cellList;
     ColumnsContext m_columnsContext;
     RowList m_rows;
+    LayoutUnit m_horizontalSpacing;
+    LayoutUnit m_verticalSpacing;
+    Optional<FormattingContext::IntrinsicWidthConstraints> m_intrinsicWidthConstraints;
 };
 
 }
 }
 #endif

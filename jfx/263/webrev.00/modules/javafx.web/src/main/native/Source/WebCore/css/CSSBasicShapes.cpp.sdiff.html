<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSBasicShapes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSAspectRatioValue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSCalculationValue.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSBasicShapes.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
139         result.append(radiusY);
140         needsSeparator = true;
141     }
142     if (!centerX.isNull() || !centerY.isNull()) {
143         if (needsSeparator)
144             result.append(&#39; &#39;);
145         result.append(&quot;at &quot;, centerX, &#39; &#39;, centerY);
146     }
147     result.append(&#39;)&#39;);
148     return result.toString();
149 }
150 
151 String CSSBasicShapeEllipse::cssText() const
152 {
153     Ref&lt;CSSPrimitiveValue&gt; normalizedCX = buildSerializablePositionOffset(m_centerX.get(), CSSValueLeft);
154     Ref&lt;CSSPrimitiveValue&gt; normalizedCY = buildSerializablePositionOffset(m_centerY.get(), CSSValueTop);
155 
156     String radiusX;
157     String radiusY;
158     if (m_radiusX) {
<span class="line-modified">159         bool shouldSerializeRadiusXValue = m_radiusX-&gt;valueID() != CSSValueClosestSide;</span>
<span class="line-modified">160         bool shouldSerializeRadiusYValue = false;</span>
<span class="line-modified">161 </span>
<span class="line-modified">162         if (m_radiusY) {</span>
<span class="line-removed">163             shouldSerializeRadiusYValue = m_radiusY-&gt;valueID() != CSSValueClosestSide;</span>
<span class="line-removed">164             if (shouldSerializeRadiusYValue)</span>
<span class="line-removed">165                 radiusY = m_radiusY-&gt;cssText();</span>
<span class="line-removed">166         }</span>
<span class="line-removed">167         if (shouldSerializeRadiusXValue || (!shouldSerializeRadiusXValue &amp;&amp; shouldSerializeRadiusYValue))</span>
168             radiusX = m_radiusX-&gt;cssText();


169     }
170     return buildEllipseString(radiusX, radiusY,
171         serializePositionOffset(*normalizedCX-&gt;pairValue(), *normalizedCY-&gt;pairValue()),
172         serializePositionOffset(*normalizedCY-&gt;pairValue(), *normalizedCX-&gt;pairValue()));
173 }
174 
175 bool CSSBasicShapeEllipse::equals(const CSSBasicShape&amp; shape) const
176 {
177     if (!is&lt;CSSBasicShapeEllipse&gt;(shape))
178         return false;
179 
180     const CSSBasicShapeEllipse&amp; other = downcast&lt;CSSBasicShapeEllipse&gt;(shape);
181     return compareCSSValuePtr(m_centerX, other.m_centerX)
182         &amp;&amp; compareCSSValuePtr(m_centerY, other.m_centerY)
183         &amp;&amp; compareCSSValuePtr(m_radiusX, other.m_radiusX)
184         &amp;&amp; compareCSSValuePtr(m_radiusY, other.m_radiusY);
185 }
186 
187 CSSBasicShapePath::CSSBasicShapePath(std::unique_ptr&lt;SVGPathByteStream&gt;&amp;&amp; pathData)
188     : m_byteStream(WTFMove(pathData))
</pre>
</td>
<td>
<hr />
<pre>
139         result.append(radiusY);
140         needsSeparator = true;
141     }
142     if (!centerX.isNull() || !centerY.isNull()) {
143         if (needsSeparator)
144             result.append(&#39; &#39;);
145         result.append(&quot;at &quot;, centerX, &#39; &#39;, centerY);
146     }
147     result.append(&#39;)&#39;);
148     return result.toString();
149 }
150 
151 String CSSBasicShapeEllipse::cssText() const
152 {
153     Ref&lt;CSSPrimitiveValue&gt; normalizedCX = buildSerializablePositionOffset(m_centerX.get(), CSSValueLeft);
154     Ref&lt;CSSPrimitiveValue&gt; normalizedCY = buildSerializablePositionOffset(m_centerY.get(), CSSValueTop);
155 
156     String radiusX;
157     String radiusY;
158     if (m_radiusX) {
<span class="line-modified">159         ASSERT(m_radiusY);</span>
<span class="line-modified">160         bool radiusXClosestSide = m_radiusX-&gt;valueID() == CSSValueClosestSide;</span>
<span class="line-modified">161         bool radiusYClosestSide = m_radiusY-&gt;valueID() == CSSValueClosestSide;</span>
<span class="line-modified">162         if (!radiusXClosestSide || !radiusYClosestSide) {</span>





163             radiusX = m_radiusX-&gt;cssText();
<span class="line-added">164             radiusY = m_radiusY-&gt;cssText();</span>
<span class="line-added">165         }</span>
166     }
167     return buildEllipseString(radiusX, radiusY,
168         serializePositionOffset(*normalizedCX-&gt;pairValue(), *normalizedCY-&gt;pairValue()),
169         serializePositionOffset(*normalizedCY-&gt;pairValue(), *normalizedCX-&gt;pairValue()));
170 }
171 
172 bool CSSBasicShapeEllipse::equals(const CSSBasicShape&amp; shape) const
173 {
174     if (!is&lt;CSSBasicShapeEllipse&gt;(shape))
175         return false;
176 
177     const CSSBasicShapeEllipse&amp; other = downcast&lt;CSSBasicShapeEllipse&gt;(shape);
178     return compareCSSValuePtr(m_centerX, other.m_centerX)
179         &amp;&amp; compareCSSValuePtr(m_centerY, other.m_centerY)
180         &amp;&amp; compareCSSValuePtr(m_radiusX, other.m_radiusX)
181         &amp;&amp; compareCSSValuePtr(m_radiusY, other.m_radiusY);
182 }
183 
184 CSSBasicShapePath::CSSBasicShapePath(std::unique_ptr&lt;SVGPathByteStream&gt;&amp;&amp; pathData)
185     : m_byteStream(WTFMove(pathData))
</pre>
</td>
</tr>
</table>
<center><a href="CSSAspectRatioValue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSCalculationValue.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
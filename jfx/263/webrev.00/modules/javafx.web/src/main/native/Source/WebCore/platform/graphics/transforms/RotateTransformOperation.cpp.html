<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/transforms/RotateTransformOperation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Antti Koivisto (koivisto@kde.org)
  3  * Copyright (C) 2004, 2005, 2006, 2007, 2008 Apple Inc. All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;RotateTransformOperation.h&quot;
 24 
 25 #include &quot;AnimationUtilities.h&quot;
 26 #include &lt;algorithm&gt;
 27 #include &lt;wtf/MathExtras.h&gt;
 28 #include &lt;wtf/text/TextStream.h&gt;
 29 
 30 #if PLATFORM(JAVA)
 31 #include &lt;wtf/java/JavaMath.h&gt;
 32 #endif
 33 
 34 namespace WebCore {
 35 
 36 bool RotateTransformOperation::operator==(const TransformOperation&amp; other) const
 37 {
 38     if (!isSameType(other))
 39         return false;
 40     const RotateTransformOperation&amp; r = downcast&lt;RotateTransformOperation&gt;(other);
 41     return m_x == r.m_x &amp;&amp; m_y == r.m_y &amp;&amp; m_z == r.m_z &amp;&amp; m_angle == r.m_angle;
 42 }
 43 
 44 Ref&lt;TransformOperation&gt; RotateTransformOperation::blend(const TransformOperation* from, double progress, bool blendToIdentity)
 45 {
 46     if (from &amp;&amp; !from-&gt;isSameType(*this))
 47         return *this;
 48 
 49     if (blendToIdentity)
 50         return RotateTransformOperation::create(m_x, m_y, m_z, m_angle - m_angle * progress, type());
 51 
 52     const RotateTransformOperation* fromOp = downcast&lt;RotateTransformOperation&gt;(from);
 53 
 54     // Optimize for single axis rotation
 55     if (!fromOp || (fromOp-&gt;m_x == 0 &amp;&amp; fromOp-&gt;m_y == 0 &amp;&amp; fromOp-&gt;m_z == 1) ||
 56                    (fromOp-&gt;m_x == 0 &amp;&amp; fromOp-&gt;m_y == 1 &amp;&amp; fromOp-&gt;m_z == 0) ||
 57                    (fromOp-&gt;m_x == 1 &amp;&amp; fromOp-&gt;m_y == 0 &amp;&amp; fromOp-&gt;m_z == 0)) {
 58         double fromAngle = fromOp ? fromOp-&gt;m_angle : 0;
 59         return RotateTransformOperation::create(fromOp ? fromOp-&gt;m_x : m_x,
 60                                                 fromOp ? fromOp-&gt;m_y : m_y,
 61                                                 fromOp ? fromOp-&gt;m_z : m_z,
 62                                                 WebCore::blend(fromAngle, m_angle, progress), type());
 63     }
 64 
 65     const RotateTransformOperation* toOp = this;
 66 
 67     // Create the 2 rotation matrices
 68     TransformationMatrix fromT;
 69     TransformationMatrix toT;
 70     fromT.rotate3d((fromOp ? fromOp-&gt;m_x : 0),
 71         (fromOp ? fromOp-&gt;m_y : 0),
 72         (fromOp ? fromOp-&gt;m_z : 1),
 73         (fromOp ? fromOp-&gt;m_angle : 0));
 74 
 75     toT.rotate3d((toOp ? toOp-&gt;m_x : 0),
 76         (toOp ? toOp-&gt;m_y : 0),
 77         (toOp ? toOp-&gt;m_z : 1),
 78         (toOp ? toOp-&gt;m_angle : 0));
 79 
 80     // Blend them
 81     toT.blend(fromT, progress);
 82 
 83     // Extract the result as a quaternion
 84     TransformationMatrix::Decomposed4Type decomp;
 85     toT.decompose4(decomp);
 86 
 87     // Convert that to Axis/Angle form
 88     double x = -decomp.quaternionX;
 89     double y = -decomp.quaternionY;
 90     double z = -decomp.quaternionZ;
 91 #if PLATFORM(JAVA)
 92     double length = javamath::hypot(x, y, z);
 93 #else
 94     double length = std::hypot(x, y, z);
 95 #endif
 96     double angle = 0;
 97 
 98     if (length &gt; 0.00001) {
 99         x /= length;
100         y /= length;
101         z /= length;
102         angle = rad2deg(acos(decomp.quaternionW) * 2);
103     } else {
104         x = 0;
105         y = 0;
106         z = 1;
107     }
108     return RotateTransformOperation::create(x, y, z, angle, ROTATE_3D);
109 }
110 
111 void RotateTransformOperation::dump(TextStream&amp; ts) const
112 {
113     ts &lt;&lt; type() &lt;&lt; &quot;(&quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_x) &lt;&lt; &quot;, &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_y) &lt;&lt; &quot;, &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_z) &lt;&lt; &quot;, &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_angle) &lt;&lt; &quot;deg)&quot;;
114 }
115 
116 } // namespace WebCore
    </pre>
  </body>
</html>
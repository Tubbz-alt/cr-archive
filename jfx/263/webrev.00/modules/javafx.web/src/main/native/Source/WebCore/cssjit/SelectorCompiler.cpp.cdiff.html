<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/cssjit/SelectorCompiler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FunctionCall.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorCompiler.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/cssjit/SelectorCompiler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 394,16 ***</span>
  
  static FunctionType constructFragments(const CSSSelector* rootSelector, SelectorContext, SelectorFragmentList&amp; selectorFragments, FragmentsLevel, FragmentPositionInRootFragments, bool visitedMatchEnabled, VisitedMode&amp;, PseudoElementMatchingBehavior);
  
  static void computeBacktrackingInformation(SelectorFragmentList&amp; selectorFragments, unsigned level = 0);
  
<span class="line-modified">! SelectorCompilationStatus compileSelector(const CSSSelector* lastSelector, SelectorContext selectorContext, JSC::MacroAssemblerCodeRef&lt;CSSSelectorPtrTag&gt;&amp; codeRef)</span>
  {
<span class="line-modified">!     if (!JSC::VM::canUseJIT())</span>
<span class="line-modified">!         return SelectorCompilationStatus::CannotCompile;</span>
<span class="line-modified">!     SelectorCodeGenerator codeGenerator(lastSelector, selectorContext);</span>
<span class="line-modified">!     return codeGenerator.compile(codeRef);</span>
  }
  
  static inline FragmentRelation fragmentRelationForSelectorRelation(CSSSelector::RelationType relation)
  {
      switch (relation) {
<span class="line-new-header">--- 394,27 ---</span>
  
  static FunctionType constructFragments(const CSSSelector* rootSelector, SelectorContext, SelectorFragmentList&amp; selectorFragments, FragmentsLevel, FragmentPositionInRootFragments, bool visitedMatchEnabled, VisitedMode&amp;, PseudoElementMatchingBehavior);
  
  static void computeBacktrackingInformation(SelectorFragmentList&amp; selectorFragments, unsigned level = 0);
  
<span class="line-modified">! void compileSelector(CompiledSelector&amp; compiledSelector, const CSSSelector* selector, SelectorContext selectorContext)</span>
  {
<span class="line-modified">!     ASSERT(compiledSelector.status == SelectorCompilationStatus::NotCompiled);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (!JSC::VM::canUseJIT()) {</span>
<span class="line-modified">!         compiledSelector.status = SelectorCompilationStatus::CannotCompile;</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     SelectorCodeGenerator codeGenerator(selector, selectorContext);</span>
<span class="line-added">+     compiledSelector.status = codeGenerator.compile(compiledSelector.codeRef);</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if defined(CSS_SELECTOR_JIT_PROFILING) &amp;&amp; CSS_SELECTOR_JIT_PROFILING</span>
<span class="line-added">+     compiledSelector.selector = selector;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(compiledSelector.status != SelectorCompilationStatus::NotCompiled);</span>
  }
  
  static inline FragmentRelation fragmentRelationForSelectorRelation(CSSSelector::RelationType relation)
  {
      switch (relation) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 556,10 ***</span>
<span class="line-new-header">--- 567,13 ---</span>
          fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesEnabledPseudoClass));
          return FunctionType::SimpleSelectorChecker;
      case CSSSelector::PseudoClassDefined:
          fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isDefinedElement));
          return FunctionType::SimpleSelectorChecker;
<span class="line-added">+     case CSSSelector::PseudoClassDirectFocus:</span>
<span class="line-added">+         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(SelectorChecker::matchesDirectFocusPseudoClass));</span>
<span class="line-added">+         return FunctionType::SimpleSelectorChecker;</span>
      case CSSSelector::PseudoClassFocus:
          fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(SelectorChecker::matchesFocusPseudoClass));
          return FunctionType::SimpleSelectorChecker;
      case CSSSelector::PseudoClassFullPageMedia:
          fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isMediaDocument));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 611,10 ***</span>
<span class="line-new-header">--- 625,17 ---</span>
  
      case CSSSelector::PseudoClassFullScreenControlsHidden:
          fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenControlsHiddenPseudoClass));
          return FunctionType::SimpleSelectorChecker;
  #endif
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">+     case CSSSelector::PseudoClassPictureInPicture:</span>
<span class="line-added">+         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesPictureInPicturePseudoClass));</span>
<span class="line-added">+         return FunctionType::SimpleSelectorChecker;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  #if ENABLE(VIDEO_TRACK)
      case CSSSelector::PseudoClassFuture:
          fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFutureCuePseudoClass));
          return FunctionType::SimpleSelectorChecker;
      case CSSSelector::PseudoClassPast:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 782,11 ***</span>
              return functionType;
          }
  
      case CSSSelector::PseudoClassLang:
          {
<span class="line-modified">!             const Vector&lt;AtomString&gt;* selectorLangArgumentList = selector.langArgumentList();</span>
              ASSERT(selectorLangArgumentList &amp;&amp; !selectorLangArgumentList-&gt;isEmpty());
              fragment.languageArgumentsList.append(selectorLangArgumentList);
              return FunctionType::SimpleSelectorChecker;
          }
  
<span class="line-new-header">--- 803,11 ---</span>
              return functionType;
          }
  
      case CSSSelector::PseudoClassLang:
          {
<span class="line-modified">!             const Vector&lt;AtomString&gt;* selectorLangArgumentList = selector.argumentList();</span>
              ASSERT(selectorLangArgumentList &amp;&amp; !selectorLangArgumentList-&gt;isEmpty());
              fragment.languageArgumentsList.append(selectorLangArgumentList);
              return FunctionType::SimpleSelectorChecker;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2448,11 ***</span>
              remainderAllocation = RegisterAllocationType::AllocatedLocally;
          }
      }
  
      // If the input register is used by idiv, save its value to restore it after the operation.
<span class="line-modified">!     Assembler::RegisterID inputDividendCopy;</span>
      StackAllocator::StackReference pushedInputDividendStackReference;
      RegisterAllocationType savedInputDividendAllocationType = RegisterAllocationType::External;
      if (inputDividend == dividend || inputDividend == remainder) {
          if (m_registerAllocator.availableRegisterCount() &gt; 1) {
              inputDividendCopy = m_registerAllocator.allocateRegister();
<span class="line-new-header">--- 2469,11 ---</span>
              remainderAllocation = RegisterAllocationType::AllocatedLocally;
          }
      }
  
      // If the input register is used by idiv, save its value to restore it after the operation.
<span class="line-modified">!     Assembler::RegisterID inputDividendCopy = JSC::InvalidGPRReg;</span>
      StackAllocator::StackReference pushedInputDividendStackReference;
      RegisterAllocationType savedInputDividendAllocationType = RegisterAllocationType::External;
      if (inputDividend == dividend || inputDividend == remainder) {
          if (m_registerAllocator.availableRegisterCount() &gt; 1) {
              inputDividendCopy = m_registerAllocator.allocateRegister();
</pre>
<center><a href="FunctionCall.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorCompiler.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
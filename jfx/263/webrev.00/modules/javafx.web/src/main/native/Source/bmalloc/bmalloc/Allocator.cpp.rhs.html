<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Allocator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2014-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;Allocator.h&quot;
 27 #include &quot;BAssert.h&quot;
 28 #include &quot;Chunk.h&quot;
 29 #include &quot;Deallocator.h&quot;
 30 #include &quot;Environment.h&quot;
 31 #include &quot;Heap.h&quot;
 32 #include &quot;PerProcess.h&quot;
 33 #include &quot;Sizes.h&quot;
 34 #include &lt;algorithm&gt;
 35 #include &lt;cstdlib&gt;
 36 
 37 namespace bmalloc {
 38 
 39 Allocator::Allocator(Heap&amp; heap, Deallocator&amp; deallocator)
 40     : m_heap(heap)
 41     , m_deallocator(deallocator)
 42 {
 43     BASSERT(!Environment::get()-&gt;isDebugHeapEnabled());
 44     for (size_t sizeClass = 0; sizeClass &lt; sizeClassCount; ++sizeClass)
 45         m_bumpAllocators[sizeClass].init(objectSize(sizeClass));
 46 }
 47 
 48 Allocator::~Allocator()
 49 {
 50     scavenge();
 51 }
 52 
<a name="2" id="anc2"></a><span class="line-modified"> 53 void* Allocator::allocateImpl(size_t alignment, size_t size, FailureAction action)</span>





















 54 {
 55     BASSERT(isPowerOfTwo(alignment));
 56 
 57     if (!size)
 58         size = alignment;
 59 
 60     if (size &lt;= smallMax &amp;&amp; alignment &lt;= smallMax)
<a name="3" id="anc3"></a><span class="line-modified"> 61         return allocateImpl(roundUpToMultipleOf(alignment, size), action);</span>
 62 
<a name="4" id="anc4"></a><span class="line-modified"> 63     return allocateLarge(size, action);</span>



 64 }
 65 
<a name="5" id="anc5"></a><span class="line-modified"> 66 void* Allocator::reallocateImpl(void* object, size_t newSize, FailureAction action)</span>
 67 {
<a name="6" id="anc6"></a><span class="line-modified"> 68     if (!object)</span>
<span class="line-modified"> 69         return allocateImpl(newSize, action);</span>







 70 
<a name="7" id="anc7"></a>

 71     size_t oldSize = 0;
 72     switch (objectType(m_heap, object)) {
 73     case ObjectType::Small: {
<a name="8" id="anc8"></a>



 74         size_t sizeClass = Object(object).page()-&gt;sizeClass();
 75         oldSize = objectSize(sizeClass);
 76         break;
 77     }
 78     case ObjectType::Large: {
<a name="9" id="anc9"></a><span class="line-modified"> 79         UniqueLockHolder lock(Heap::mutex());</span>
 80         oldSize = m_heap.largeSize(lock, object);
 81 
 82         if (newSize &lt; oldSize &amp;&amp; newSize &gt; smallMax) {
 83             m_heap.shrinkLarge(lock, Range(object, oldSize), newSize);
 84             return object;
 85         }
 86         break;
 87     }
 88     }
 89 
 90     void* result = nullptr;
<a name="10" id="anc10"></a><span class="line-modified"> 91     result = allocateImpl(newSize, action);</span>
<span class="line-modified"> 92     if (!result) {</span>
<span class="line-modified"> 93         BASSERT(action == FailureAction::ReturnNull);</span>
<span class="line-modified"> 94         return nullptr;</span>


 95     }
 96     size_t copySize = std::min(oldSize, newSize);
 97     memcpy(result, object, copySize);
 98     m_deallocator.deallocate(object);
 99     return result;
100 }
101 
102 void Allocator::scavenge()
103 {
104     for (size_t sizeClass = 0; sizeClass &lt; sizeClassCount; ++sizeClass) {
105         BumpAllocator&amp; allocator = m_bumpAllocators[sizeClass];
106         BumpRangeCache&amp; bumpRangeCache = m_bumpRangeCaches[sizeClass];
107 
108         while (allocator.canAllocate())
109             m_deallocator.deallocate(allocator.allocate());
110 
111         while (bumpRangeCache.size()) {
112             allocator.refill(bumpRangeCache.pop());
113             while (allocator.canAllocate())
114                 m_deallocator.deallocate(allocator.allocate());
115         }
116 
117         allocator.clear();
118     }
119 }
120 
<a name="11" id="anc11"></a><span class="line-modified">121 BNO_INLINE void Allocator::refillAllocatorSlowCase(BumpAllocator&amp; allocator, size_t sizeClass, FailureAction action)</span>
122 {
123     BumpRangeCache&amp; bumpRangeCache = m_bumpRangeCaches[sizeClass];
124 
<a name="12" id="anc12"></a><span class="line-modified">125     UniqueLockHolder lock(Heap::mutex());</span>
126     m_deallocator.processObjectLog(lock);
<a name="13" id="anc13"></a><span class="line-modified">127     m_heap.allocateSmallBumpRanges(lock, sizeClass, allocator, bumpRangeCache, m_deallocator.lineCache(lock), action);</span>
128 }
129 
<a name="14" id="anc14"></a><span class="line-modified">130 BINLINE void Allocator::refillAllocator(BumpAllocator&amp; allocator, size_t sizeClass, FailureAction action)</span>
131 {
132     BumpRangeCache&amp; bumpRangeCache = m_bumpRangeCaches[sizeClass];
133     if (!bumpRangeCache.size())
<a name="15" id="anc15"></a><span class="line-modified">134         return refillAllocatorSlowCase(allocator, sizeClass, action);</span>
135     return allocator.refill(bumpRangeCache.pop());
136 }
137 
<a name="16" id="anc16"></a><span class="line-modified">138 BNO_INLINE void* Allocator::allocateLarge(size_t size, FailureAction action)</span>
139 {
<a name="17" id="anc17"></a><span class="line-modified">140     UniqueLockHolder lock(Heap::mutex());</span>
<span class="line-modified">141     return m_heap.allocateLarge(lock, alignment, size, action);</span>
142 }
143 
<a name="18" id="anc18"></a><span class="line-modified">144 BNO_INLINE void* Allocator::allocateLogSizeClass(size_t size, FailureAction action)</span>
145 {
146     size_t sizeClass = bmalloc::sizeClass(size);
147     BumpAllocator&amp; allocator = m_bumpAllocators[sizeClass];
148     if (!allocator.canAllocate())
<a name="19" id="anc19"></a><span class="line-modified">149         refillAllocator(allocator, sizeClass, action);</span>
<span class="line-added">150     if (action == FailureAction::ReturnNull &amp;&amp; !allocator.canAllocate())</span>
<span class="line-added">151         return nullptr;</span>
152     return allocator.allocate();
153 }
154 
<a name="20" id="anc20"></a><span class="line-modified">155 void* Allocator::allocateSlowCase(size_t size, FailureAction action)</span>
156 {
157     if (size &lt;= maskSizeClassMax) {
158         size_t sizeClass = bmalloc::maskSizeClass(size);
159         BumpAllocator&amp; allocator = m_bumpAllocators[sizeClass];
<a name="21" id="anc21"></a><span class="line-modified">160         refillAllocator(allocator, sizeClass, action);</span>
<span class="line-added">161         if (action == FailureAction::ReturnNull &amp;&amp; !allocator.canAllocate())</span>
<span class="line-added">162             return nullptr;</span>
163         return allocator.allocate();
164     }
165 
166     if (size &lt;= smallMax)
<a name="22" id="anc22"></a><span class="line-modified">167         return allocateLogSizeClass(size, action);</span>
168 
<a name="23" id="anc23"></a><span class="line-modified">169     return allocateLarge(size, action);</span>
170 }
171 
172 } // namespace bmalloc
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
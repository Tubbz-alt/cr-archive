<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/displaylists/DisplayListItems.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2015 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DisplayListItems.h&quot;
  28 
  29 #include &quot;FontCascade.h&quot;
  30 #include &lt;wtf/text/TextStream.h&gt;
  31 
  32 #if USE(CG)
  33 #include &quot;GraphicsContextPlatformPrivateCG.h&quot;
  34 #endif
  35 
  36 namespace WebCore {
  37 namespace DisplayList {
  38 
  39 // Should match RenderTheme::platformFocusRingWidth()
  40 static const float platformFocusRingWidth = 3;
  41 
  42 #if !defined(NDEBUG) || !LOG_DISABLED
  43 WTF::CString Item::description() const
  44 {
  45     TextStream ts;
  46     ts &lt;&lt; *this;
  47     return ts.release().utf8();
  48 }
  49 #endif
  50 
  51 Item::Item(ItemType type)
  52     : m_type(type)
  53 {
  54 }
  55 
  56 Item::~Item() = default;
  57 
  58 size_t Item::sizeInBytes(const Item&amp; item)
  59 {
  60     switch (item.type()) {
  61     case ItemType::Save:
  62         return sizeof(downcast&lt;Save&gt;(item));
  63     case ItemType::Restore:
  64         return sizeof(downcast&lt;Restore&gt;(item));
  65     case ItemType::Translate:
  66         return sizeof(downcast&lt;Translate&gt;(item));
  67     case ItemType::Rotate:
  68         return sizeof(downcast&lt;Rotate&gt;(item));
  69     case ItemType::Scale:
  70         return sizeof(downcast&lt;Scale&gt;(item));
  71     case ItemType::SetCTM:
  72         return sizeof(downcast&lt;SetCTM&gt;(item));
  73     case ItemType::ConcatenateCTM:
  74         return sizeof(downcast&lt;ConcatenateCTM&gt;(item));
  75     case ItemType::SetState:
  76         return sizeof(downcast&lt;SetState&gt;(item));
  77     case ItemType::SetLineCap:
  78         return sizeof(downcast&lt;SetLineCap&gt;(item));
  79     case ItemType::SetLineDash:
  80         return sizeof(downcast&lt;SetLineDash&gt;(item));
  81     case ItemType::SetLineJoin:
  82         return sizeof(downcast&lt;SetLineJoin&gt;(item));
  83     case ItemType::SetMiterLimit:
  84         return sizeof(downcast&lt;SetMiterLimit&gt;(item));
  85     case ItemType::ClearShadow:
  86         return sizeof(downcast&lt;ClearShadow&gt;(item));
  87     case ItemType::Clip:
  88         return sizeof(downcast&lt;Clip&gt;(item));
  89     case ItemType::ClipOut:
  90         return sizeof(downcast&lt;ClipOut&gt;(item));
  91     case ItemType::ClipOutToPath:
  92         return sizeof(downcast&lt;ClipOutToPath&gt;(item));
  93     case ItemType::ClipPath:
  94         return sizeof(downcast&lt;ClipPath&gt;(item));
  95     case ItemType::DrawGlyphs:
  96         return sizeof(downcast&lt;DrawGlyphs&gt;(item));
  97     case ItemType::DrawImage:
  98         return sizeof(downcast&lt;DrawImage&gt;(item));
  99     case ItemType::DrawTiledImage:
 100         return sizeof(downcast&lt;DrawTiledImage&gt;(item));
 101     case ItemType::DrawTiledScaledImage:
 102         return sizeof(downcast&lt;DrawTiledScaledImage&gt;(item));
 103 #if USE(CG) || USE(CAIRO)
 104     case ItemType::DrawNativeImage:
 105         return sizeof(downcast&lt;DrawNativeImage&gt;(item));
 106 #endif
 107     case ItemType::DrawPattern:
 108         return sizeof(downcast&lt;DrawPattern&gt;(item));
 109     case ItemType::DrawRect:
 110         return sizeof(downcast&lt;DrawRect&gt;(item));
 111     case ItemType::DrawLine:
 112         return sizeof(downcast&lt;DrawLine&gt;(item));
 113     case ItemType::DrawLinesForText:
 114         return sizeof(downcast&lt;DrawLinesForText&gt;(item));
 115     case ItemType::DrawDotsForDocumentMarker:
 116         return sizeof(downcast&lt;DrawDotsForDocumentMarker&gt;(item));
 117     case ItemType::DrawEllipse:
 118         return sizeof(downcast&lt;DrawEllipse&gt;(item));
 119     case ItemType::DrawPath:
 120         return sizeof(downcast&lt;DrawPath&gt;(item));
 121     case ItemType::DrawFocusRingPath:
 122         return sizeof(downcast&lt;DrawFocusRingPath&gt;(item));
 123     case ItemType::DrawFocusRingRects:
 124         return sizeof(downcast&lt;DrawFocusRingRects&gt;(item));
 125     case ItemType::FillRect:
 126         return sizeof(downcast&lt;FillRect&gt;(item));
 127     case ItemType::FillRectWithColor:
 128         return sizeof(downcast&lt;FillRectWithColor&gt;(item));
 129     case ItemType::FillRectWithGradient:
 130         return sizeof(downcast&lt;FillRectWithGradient&gt;(item));
 131     case ItemType::FillCompositedRect:
 132         return sizeof(downcast&lt;FillCompositedRect&gt;(item));
 133     case ItemType::FillRoundedRect:
 134         return sizeof(downcast&lt;FillRoundedRect&gt;(item));
 135     case ItemType::FillRectWithRoundedHole:
 136         return sizeof(downcast&lt;FillRectWithRoundedHole&gt;(item));
 137     case ItemType::FillPath:
 138         return sizeof(downcast&lt;FillPath&gt;(item));
 139     case ItemType::FillEllipse:
 140         return sizeof(downcast&lt;FillEllipse&gt;(item));
 141     case ItemType::StrokeRect:
 142         return sizeof(downcast&lt;StrokeRect&gt;(item));
 143     case ItemType::StrokePath:
 144         return sizeof(downcast&lt;StrokePath&gt;(item));
 145     case ItemType::StrokeEllipse:
 146         return sizeof(downcast&lt;StrokeEllipse&gt;(item));
 147     case ItemType::ClearRect:
 148         return sizeof(downcast&lt;ClearRect&gt;(item));
 149     case ItemType::BeginTransparencyLayer:
 150         return sizeof(downcast&lt;BeginTransparencyLayer&gt;(item));
 151     case ItemType::EndTransparencyLayer:
 152         return sizeof(downcast&lt;EndTransparencyLayer&gt;(item));
 153 #if USE(CG)
 154     case ItemType::ApplyStrokePattern:
 155         return sizeof(downcast&lt;ApplyStrokePattern&gt;(item));
 156     case ItemType::ApplyFillPattern:
 157         return sizeof(downcast&lt;ApplyFillPattern&gt;(item));
 158 #endif
 159     case ItemType::ApplyDeviceScaleFactor:
 160         return sizeof(downcast&lt;ApplyDeviceScaleFactor&gt;(item));
 161     }
 162     return 0;
 163 }
 164 
 165 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawingItem&amp; item)
 166 {
 167     ts.startGroup();
 168     ts &lt;&lt; &quot;extent &quot;;
 169     if (item.extentKnown())
 170         ts &lt;&lt; item.extent();
 171     else
 172         ts &lt;&lt; &quot;unknown&quot;;
 173 
 174     ts.endGroup();
 175     return ts;
 176 }
 177 
 178 DrawingItem::DrawingItem(ItemType type)
 179     : Item(type)
 180 {
 181 }
 182 
 183 DrawingItem::~DrawingItem() = default;
 184 
 185 Save::Save()
 186     : Item(ItemType::Save)
 187 {
 188 }
 189 
 190 Save::~Save() = default;
 191 
 192 void Save::apply(GraphicsContext&amp; context) const
 193 {
 194     context.save();
 195 }
 196 
 197 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Save&amp; item)
 198 {
 199     ts.dumpProperty(&quot;restore-index&quot;, item.restoreIndex());
 200     return ts;
 201 }
 202 
 203 Restore::Restore()
 204     : Item(ItemType::Restore)
 205 {
 206 }
 207 
 208 Restore::~Restore() = default;
 209 
 210 void Restore::apply(GraphicsContext&amp; context) const
 211 {
 212     context.restore();
 213 }
 214 
 215 Translate::Translate(float x, float y)
 216     : Item(ItemType::Translate)
 217     , m_x(x)
 218     , m_y(y)
 219 {
 220 }
 221 
 222 Translate::~Translate() = default;
 223 
 224 void Translate::apply(GraphicsContext&amp; context) const
 225 {
 226     context.translate(m_x, m_y);
 227 }
 228 
 229 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Translate&amp; item)
 230 {
 231     ts.dumpProperty(&quot;x&quot;, item.x());
 232     ts.dumpProperty(&quot;y&quot;, item.y());
 233 
 234     return ts;
 235 }
 236 
 237 Rotate::Rotate(float angle)
 238     : Item(ItemType::Rotate)
 239     , m_angle(angle)
 240 {
 241 }
 242 
 243 Rotate::~Rotate() = default;
 244 
 245 void Rotate::apply(GraphicsContext&amp; context) const
 246 {
 247     context.rotate(m_angle);
 248 }
 249 
 250 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Rotate&amp; item)
 251 {
 252     ts.dumpProperty(&quot;angle&quot;, item.angle());
 253 
 254     return ts;
 255 }
 256 
 257 Scale::Scale(const FloatSize&amp; size)
 258     : Item(ItemType::Scale)
 259     , m_size(size)
 260 {
 261 }
 262 
 263 Scale::~Scale() = default;
 264 
 265 void Scale::apply(GraphicsContext&amp; context) const
 266 {
 267     context.scale(m_size);
 268 }
 269 
 270 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Scale&amp; item)
 271 {
 272     ts.dumpProperty(&quot;size&quot;, item.amount());
 273 
 274     return ts;
 275 }
 276 
 277 SetCTM::SetCTM(const AffineTransform&amp; transform)
 278     : Item(ItemType::SetCTM)
 279     , m_transform(transform)
 280 {
 281 }
 282 
 283 SetCTM::~SetCTM() = default;
 284 
 285 void SetCTM::apply(GraphicsContext&amp; context) const
 286 {
 287     context.setCTM(m_transform);
 288 }
 289 
 290 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetCTM&amp; item)
 291 {
 292     ts.dumpProperty(&quot;set-ctm&quot;, item.transform());
 293 
 294     return ts;
 295 }
 296 
 297 ConcatenateCTM::ConcatenateCTM(const AffineTransform&amp; transform)
 298     : Item(ItemType::ConcatenateCTM)
 299     , m_transform(transform)
 300 {
 301 }
 302 
 303 ConcatenateCTM::~ConcatenateCTM() = default;
 304 
 305 void ConcatenateCTM::apply(GraphicsContext&amp; context) const
 306 {
 307     context.concatCTM(m_transform);
 308 }
 309 
 310 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ConcatenateCTM&amp; item)
 311 {
 312     ts.dumpProperty(&quot;ctm&quot;, item.transform());
 313 
 314     return ts;
 315 }
 316 
 317 SetState::SetState(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 318     : Item(ItemType::SetState)
 319     , m_state(state, flags)
 320 {
 321 }
 322 
 323 SetState::SetState(const GraphicsContextStateChange&amp; stateChange)
 324     : Item(ItemType::SetState)
 325     , m_state(stateChange)
 326 {
 327 }
 328 
 329 SetState::~SetState() = default;
 330 
 331 void SetState::apply(GraphicsContext&amp; context) const
 332 {
 333     m_state.apply(context);
 334 }
 335 
 336 void SetState::accumulate(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 337 {
 338     m_state.accumulate(state, flags);
 339 }
 340 
 341 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetState&amp; state)
 342 {
 343     ts &lt;&lt; state.state();
 344     return ts;
 345 }
 346 
 347 SetLineCap::SetLineCap(LineCap lineCap)
 348     : Item(ItemType::SetLineCap)
 349     , m_lineCap(lineCap)
 350 {
 351 }
 352 
 353 SetLineCap::~SetLineCap() = default;
 354 
 355 void SetLineCap::apply(GraphicsContext&amp; context) const
 356 {
 357     context.setLineCap(m_lineCap);
 358 }
 359 
 360 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetLineCap&amp; lineCap)
 361 {
 362     ts.dumpProperty(&quot;line-cap&quot;, lineCap.lineCap());
 363     return ts;
 364 }
 365 
 366 SetLineDash::SetLineDash(const DashArray&amp; dashArray, float dashOffset)
 367     : Item(ItemType::SetLineDash)
 368     , m_dashArray(dashArray)
 369     , m_dashOffset(dashOffset)
 370 {
 371 }
 372 
 373 SetLineDash::~SetLineDash() = default;
 374 
 375 void SetLineDash::apply(GraphicsContext&amp; context) const
 376 {
 377     context.setLineDash(m_dashArray, m_dashOffset);
 378 }
 379 
 380 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetLineDash&amp; lineDash)
 381 {
 382     ts.dumpProperty(&quot;dash-array&quot;, lineDash.dashArray());
 383     ts.dumpProperty(&quot;dash-offset&quot;, lineDash.dashOffset());
 384     return ts;
 385 }
 386 
 387 SetLineJoin::SetLineJoin(LineJoin lineJoin)
 388     : Item(ItemType::SetLineJoin)
 389     , m_lineJoin(lineJoin)
 390 {
 391 }
 392 
 393 SetLineJoin::~SetLineJoin() = default;
 394 
 395 void SetLineJoin::apply(GraphicsContext&amp; context) const
 396 {
 397     context.setLineJoin(m_lineJoin);
 398 }
 399 
 400 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetLineJoin&amp; lineJoin)
 401 {
 402     ts.dumpProperty(&quot;line-join&quot;, lineJoin.lineJoin());
 403     return ts;
 404 }
 405 
 406 SetMiterLimit::SetMiterLimit(float miterLimit)
 407     : Item(ItemType::SetMiterLimit)
 408     , m_miterLimit(miterLimit)
 409 {
 410 }
 411 
 412 SetMiterLimit::~SetMiterLimit() = default;
 413 
 414 void SetMiterLimit::apply(GraphicsContext&amp; context) const
 415 {
 416     context.setMiterLimit(m_miterLimit);
 417 }
 418 
 419 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetMiterLimit&amp; miterLimit)
 420 {
 421     ts.dumpProperty(&quot;mitre-limit&quot;, miterLimit.miterLimit());
 422     return ts;
 423 }
 424 
 425 ClearShadow::ClearShadow()
 426     : Item(ItemType::ClearShadow)
 427 {
 428 }
 429 
 430 ClearShadow::~ClearShadow() = default;
 431 
 432 void ClearShadow::apply(GraphicsContext&amp; context) const
 433 {
 434     context.clearShadow();
 435 }
 436 
 437 Clip::Clip(const FloatRect&amp; rect)
 438     : Item(ItemType::Clip)
 439     , m_rect(rect)
 440 {
 441 }
 442 
 443 Clip::~Clip() = default;
 444 
 445 void Clip::apply(GraphicsContext&amp; context) const
 446 {
 447     context.clip(m_rect);
 448 }
 449 
 450 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Clip&amp; item)
 451 {
 452     ts.dumpProperty(&quot;rect&quot;, item.rect());
 453     return ts;
 454 }
 455 
 456 ClipOut::ClipOut(const FloatRect&amp; rect)
 457     : Item(ItemType::ClipOut)
 458     , m_rect(rect)
 459 {
 460 }
 461 
 462 ClipOut::~ClipOut() = default;
 463 
 464 void ClipOut::apply(GraphicsContext&amp; context) const
 465 {
 466     context.clipOut(m_rect);
 467 }
 468 
 469 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipOut&amp; item)
 470 {
 471     ts.dumpProperty(&quot;rect&quot;, item.rect());
 472     return ts;
 473 }
 474 
 475 ClipOutToPath::ClipOutToPath(const Path&amp; path)
 476     : Item(ItemType::ClipOutToPath)
 477     , m_path(path)
 478 {
 479 }
 480 
 481 ClipOutToPath::~ClipOutToPath() = default;
 482 
 483 void ClipOutToPath::apply(GraphicsContext&amp; context) const
 484 {
 485     context.clipOut(m_path);
 486 }
 487 
 488 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipOutToPath&amp; item)
 489 {
 490     ts.dumpProperty(&quot;path&quot;, item.path());
 491     return ts;
 492 }
 493 
 494 ClipPath::ClipPath(const Path&amp; path, WindRule windRule)
 495     : Item(ItemType::ClipPath)
 496     , m_path(path)
 497     , m_windRule(windRule)
 498 {
 499 }
 500 
 501 ClipPath::~ClipPath() = default;
 502 
 503 void ClipPath::apply(GraphicsContext&amp; context) const
 504 {
 505     context.clipPath(m_path, m_windRule);
 506 }
 507 
 508 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipPath&amp; item)
 509 {
 510     ts.dumpProperty(&quot;path&quot;, item.path());
 511     ts.dumpProperty(&quot;wind-rule&quot;, item.windRule());
 512     return ts;
 513 }
 514 
 515 DrawGlyphs::DrawGlyphs(const Font&amp; font, Vector&lt;GlyphBufferGlyph, 128&gt;&amp;&amp; glyphs, Vector&lt;GlyphBufferAdvance, 128&gt;&amp;&amp; advances, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode smoothingMode)
 516     : DrawingItem(ItemType::DrawGlyphs)
 517     , m_font(const_cast&lt;Font&amp;&gt;(font))
 518     , m_glyphs(WTFMove(glyphs))
 519     , m_advances(WTFMove(advances))
 520     , m_blockLocation(blockLocation)
 521     , m_localAnchor(localAnchor)
 522     , m_smoothingMode(smoothingMode)
 523 {
 524     computeBounds();
 525 }
 526 
 527 DrawGlyphs::DrawGlyphs(const Font&amp; font, const GlyphBufferGlyph* glyphs, const GlyphBufferAdvance* advances, unsigned count, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode smoothingMode)
 528     : DrawingItem(ItemType::DrawGlyphs)
 529     , m_font(const_cast&lt;Font&amp;&gt;(font))
 530     , m_blockLocation(blockLocation)
 531     , m_localAnchor(localAnchor)
 532     , m_smoothingMode(smoothingMode)
 533 {
 534     m_glyphs.reserveInitialCapacity(count);
 535     m_advances.reserveInitialCapacity(count);
 536     for (unsigned i = 0; i &lt; count; ++i) {
 537         m_glyphs.uncheckedAppend(glyphs[i]);
 538         m_advances.uncheckedAppend(advances[i]);
 539     }
 540     computeBounds();
 541 }
 542 
 543 DrawGlyphs::~DrawGlyphs() = default;
 544 
 545 inline GlyphBuffer DrawGlyphs::generateGlyphBuffer() const
 546 {
 547     GlyphBuffer result;
 548     for (size_t i = 0; i &lt; m_glyphs.size(); ++i) {
 549         result.add(m_glyphs[i], &amp;m_font.get(), m_advances[i], GlyphBuffer::noOffset);
 550     }
 551     return result;
 552 }
 553 
 554 void DrawGlyphs::apply(GraphicsContext&amp; context) const
 555 {
 556     context.drawGlyphs(m_font, generateGlyphBuffer(), 0, m_glyphs.size(), anchorPoint(), m_smoothingMode);
 557 }
 558 
 559 void DrawGlyphs::computeBounds()
 560 {
 561     // FIXME: This code doesn&#39;t actually take the extents of the glyphs into consideration. It assumes that
 562     // the glyph lies entirely within its [(ascent + descent), advance] rect.
 563     float ascent = m_font-&gt;fontMetrics().floatAscent();
 564     float descent = m_font-&gt;fontMetrics().floatDescent();
 565     FloatPoint current = toFloatPoint(localAnchor());
 566     size_t numGlyphs = m_glyphs.size();
 567     for (size_t i = 0; i &lt; numGlyphs; ++i) {
 568         GlyphBufferAdvance advance = m_advances[i];
 569         FloatRect glyphRect = FloatRect(current.x(), current.y() - ascent, advance.width(), ascent + descent);
 570         m_bounds.unite(glyphRect);
 571 
 572         current.move(advance.width(), advance.height());
 573     }
 574 }
 575 
 576 Optional&lt;FloatRect&gt; DrawGlyphs::localBounds(const GraphicsContext&amp;) const
 577 {
 578     FloatRect localBounds = m_bounds;
 579     localBounds.move(m_blockLocation.x(), m_blockLocation.y());
 580     return localBounds;
 581 }
 582 
 583 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawGlyphs&amp; item)
 584 {
 585     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 586     // FIXME: dump more stuff.
 587     ts.dumpProperty(&quot;block-location&quot;, item.blockLocation());
 588     ts.dumpProperty(&quot;local-anchor&quot;, item.localAnchor());
 589     ts.dumpProperty(&quot;anchor-point&quot;, item.anchorPoint());
 590     ts.dumpProperty(&quot;length&quot;, item.glyphs().size());
 591 
 592     return ts;
 593 }
 594 
 595 DrawImage::DrawImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; imagePaintingOptions)
 596     : DrawingItem(ItemType::DrawImage)
 597     , m_image(image)
 598     , m_destination(destination)
 599     , m_source(source)
 600     , m_imagePaintingOptions(imagePaintingOptions)
 601 {
 602 }
 603 
 604 DrawImage::~DrawImage() = default;
 605 
 606 void DrawImage::apply(GraphicsContext&amp; context) const
 607 {
 608     context.drawImage(m_image.get(), m_destination, m_source, m_imagePaintingOptions);
 609 }
 610 
 611 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawImage&amp; item)
 612 {
 613     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 614     ts.dumpProperty(&quot;image&quot;, item.image());
 615     ts.dumpProperty(&quot;source-rect&quot;, item.source());
 616     ts.dumpProperty(&quot;dest-rect&quot;, item.destination());
 617     return ts;
 618 }
 619 
 620 DrawTiledImage::DrawTiledImage(Image&amp; image, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; imagePaintingOptions)
 621     : DrawingItem(ItemType::DrawTiledImage)
 622     , m_image(image)
 623     , m_destination(destination)
 624     , m_source(source)
 625     , m_tileSize(tileSize)
 626     , m_spacing(spacing)
 627     , m_imagePaintingOptions(imagePaintingOptions)
 628 {
 629 }
 630 
 631 DrawTiledImage::~DrawTiledImage() = default;
 632 
 633 void DrawTiledImage::apply(GraphicsContext&amp; context) const
 634 {
 635     context.drawTiledImage(m_image.get(), m_destination, m_source, m_tileSize, m_spacing, m_imagePaintingOptions);
 636 }
 637 
 638 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawTiledImage&amp; item)
 639 {
 640     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 641     ts.dumpProperty(&quot;image&quot;, item.image());
 642     ts.dumpProperty(&quot;source-point&quot;, item.source());
 643     ts.dumpProperty(&quot;dest-rect&quot;, item.destination());
 644     ts.dumpProperty(&quot;tile-size&quot;, item.tileSize());
 645     ts.dumpProperty(&quot;spacing&quot;, item.spacing());
 646     return ts;
 647 }
 648 
 649 DrawTiledScaledImage::DrawTiledScaledImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp; imagePaintingOptions)
 650     : DrawingItem(ItemType::DrawTiledScaledImage)
 651     , m_image(image)
 652     , m_destination(destination)
 653     , m_source(source)
 654     , m_tileScaleFactor(tileScaleFactor)
 655     , m_hRule(hRule)
 656     , m_vRule(vRule)
 657     , m_imagePaintingOptions(imagePaintingOptions)
 658 {
 659 }
 660 
 661 DrawTiledScaledImage::~DrawTiledScaledImage() = default;
 662 
 663 void DrawTiledScaledImage::apply(GraphicsContext&amp; context) const
 664 {
 665     context.drawTiledImage(m_image.get(), m_destination, m_source, m_tileScaleFactor, m_hRule, m_vRule, m_imagePaintingOptions);
 666 }
 667 
 668 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawTiledScaledImage&amp; item)
 669 {
 670     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 671     ts.dumpProperty(&quot;image&quot;, item.image());
 672     ts.dumpProperty(&quot;source-rect&quot;, item.source());
 673     ts.dumpProperty(&quot;dest-rect&quot;, item.destination());
 674     return ts;
 675 }
 676 
 677 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)
 678 DrawNativeImage::DrawNativeImage(const NativeImagePtr&amp; image, const FloatSize&amp; imageSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; options)
 679     : DrawingItem(ItemType::DrawNativeImage)
 680 #if USE(CG)
 681     // FIXME: Need to store an image for Cairo.
 682     , m_image(image)
 683 #endif
 684     , m_imageSize(imageSize)
 685     , m_destinationRect(destRect)
 686     , m_srcRect(srcRect)
 687     , m_options(options)
 688 {
 689 #if !USE(CG)
 690     UNUSED_PARAM(image);
 691 #endif
 692 }
 693 
 694 DrawNativeImage::~DrawNativeImage() = default;
 695 
 696 void DrawNativeImage::apply(GraphicsContext&amp; context) const
 697 {
 698 #if USE(CG)
 699     context.drawNativeImage(m_image, m_imageSize, m_destinationRect, m_srcRect, m_options);
 700 #else
 701     UNUSED_PARAM(context);
 702 #endif
 703 }
 704 
 705 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawNativeImage&amp; item)
 706 {
 707     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 708     // FIXME: dump more stuff.
 709     ts.dumpProperty(&quot;source-rect&quot;, item.source());
 710     ts.dumpProperty(&quot;dest-rect&quot;, item.destinationRect());
 711     return ts;
 712 }
 713 #endif
 714 
 715 DrawPattern::DrawPattern(Image&amp; image, const FloatRect&amp; destRect, const FloatRect&amp; tileRect, const AffineTransform&amp; patternTransform, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; options)
 716     : DrawingItem(ItemType::DrawPattern)
 717     , m_image(image)
 718     , m_patternTransform(patternTransform)
 719     , m_tileRect(tileRect)
 720     , m_destination(destRect)
 721     , m_phase(phase)
 722     , m_spacing(spacing)
 723     , m_options(options)
 724 {
 725 }
 726 
 727 DrawPattern::~DrawPattern() = default;
 728 
 729 void DrawPattern::apply(GraphicsContext&amp; context) const
 730 {
 731     context.drawPattern(m_image.get(), m_destination, m_tileRect, m_patternTransform, m_phase, m_spacing, m_options);
 732 }
 733 
 734 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawPattern&amp; item)
 735 {
 736     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 737     ts.dumpProperty(&quot;image&quot;, item.image());
 738     ts.dumpProperty(&quot;pattern-transform&quot;, item.patternTransform());
 739     ts.dumpProperty(&quot;tile-rect&quot;, item.tileRect());
 740     ts.dumpProperty(&quot;dest-rect&quot;, item.destRect());
 741     ts.dumpProperty(&quot;phase&quot;, item.phase());
 742     ts.dumpProperty(&quot;spacing&quot;, item.spacing());
 743     return ts;
 744 }
 745 
 746 DrawRect::DrawRect(const FloatRect&amp; rect, float borderThickness)
 747     : DrawingItem(ItemType::DrawRect)
 748     , m_rect(rect)
 749     , m_borderThickness(borderThickness)
 750 {
 751 }
 752 
 753 DrawRect::~DrawRect() = default;
 754 
 755 void DrawRect::apply(GraphicsContext&amp; context) const
 756 {
 757     context.drawRect(m_rect, m_borderThickness);
 758 }
 759 
 760 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawRect&amp; item)
 761 {
 762     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 763     ts.dumpProperty(&quot;rect&quot;, item.rect());
 764     ts.dumpProperty(&quot;border-thickness&quot;, item.borderThickness());
 765     return ts;
 766 }
 767 
 768 DrawLine::DrawLine(const FloatPoint&amp; point1, const FloatPoint&amp; point2)
 769     : DrawingItem(ItemType::DrawLine)
 770     , m_point1(point1)
 771     , m_point2(point2)
 772 {
 773 }
 774 
 775 DrawLine::~DrawLine() = default;
 776 
 777 Optional&lt;FloatRect&gt; DrawLine::localBounds(const GraphicsContext&amp;) const
 778 {
 779     FloatRect bounds;
 780     bounds.fitToPoints(m_point1, m_point2);
 781     return bounds;
 782 }
 783 
 784 void DrawLine::apply(GraphicsContext&amp; context) const
 785 {
 786     context.drawLine(m_point1, m_point2);
 787 }
 788 
 789 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawLine&amp; item)
 790 {
 791     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 792     ts.dumpProperty(&quot;point-1&quot;, item.point1());
 793     ts.dumpProperty(&quot;point-2&quot;, item.point2());
 794     return ts;
 795 }
 796 
 797 DrawLinesForText::DrawLinesForText(const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, float thickness, const DashArray&amp; widths, bool printing, bool doubleLines)
 798     : DrawingItem(ItemType::DrawLinesForText)
 799     , m_blockLocation(blockLocation)
 800     , m_localAnchor(localAnchor)
 801     , m_widths(widths)
 802     , m_thickness(thickness)
 803     , m_printing(printing)
 804     , m_doubleLines(doubleLines)
 805 {
 806 }
 807 
 808 DrawLinesForText::~DrawLinesForText() = default;
 809 
 810 void DrawLinesForText::apply(GraphicsContext&amp; context) const
 811 {
 812     context.drawLinesForText(point(), m_thickness, m_widths, m_printing, m_doubleLines);
 813 }
 814 
 815 Optional&lt;FloatRect&gt; DrawLinesForText::localBounds(const GraphicsContext&amp;) const
 816 {
 817     // This function needs to return a value equal to or enclosing what GraphicsContext::computeLineBoundsAndAntialiasingModeForText() returns.
 818 
 819     if (!m_widths.size())
 820         return FloatRect();
 821 
 822     FloatRect result(point(), FloatSize(m_widths.last(), m_thickness));
 823     result.inflate(1); // Account for pixel snapping. FIXME: This isn&#39;t perfect, as it doesn&#39;t take the CTM into account.
 824     return result;
 825 }
 826 
 827 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawLinesForText&amp; item)
 828 {
 829     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 830     ts.dumpProperty(&quot;block-location&quot;, item.blockLocation());
 831     ts.dumpProperty(&quot;local-anchor&quot;, item.localAnchor());
 832     ts.dumpProperty(&quot;point&quot;, item.point());
 833     ts.dumpProperty(&quot;thickness&quot;, item.thickness());
 834     ts.dumpProperty(&quot;double&quot;, item.doubleLines());
 835     ts.dumpProperty(&quot;widths&quot;, item.widths());
 836     ts.dumpProperty(&quot;is-printing&quot;, item.isPrinting());
 837     ts.dumpProperty(&quot;double&quot;, item.doubleLines());
 838     return ts;
 839 }
 840 
 841 DrawDotsForDocumentMarker::DrawDotsForDocumentMarker(const FloatRect&amp; rect, DocumentMarkerLineStyle style)
 842     : DrawingItem(ItemType::DrawDotsForDocumentMarker)
 843     , m_rect(rect)
 844     , m_style(style)
 845 {
 846 }
 847 
 848 DrawDotsForDocumentMarker::~DrawDotsForDocumentMarker() = default;
 849 
 850 void DrawDotsForDocumentMarker::apply(GraphicsContext&amp; context) const
 851 {
 852     context.drawDotsForDocumentMarker(m_rect, m_style);
 853 }
 854 
 855 Optional&lt;FloatRect&gt; DrawDotsForDocumentMarker::localBounds(const GraphicsContext&amp;) const
 856 {
 857     return m_rect;
 858 }
 859 
 860 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawDotsForDocumentMarker&amp; item)
 861 {
 862     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 863     ts.dumpProperty(&quot;rect&quot;, item.rect());
 864     return ts;
 865 }
 866 
 867 DrawEllipse::DrawEllipse(const FloatRect&amp; rect)
 868     : DrawingItem(ItemType::DrawEllipse)
 869     , m_rect(rect)
 870 {
 871 }
 872 
 873 DrawEllipse::~DrawEllipse() = default;
 874 
 875 void DrawEllipse::apply(GraphicsContext&amp; context) const
 876 {
 877     context.drawEllipse(m_rect);
 878 }
 879 
 880 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawEllipse&amp; item)
 881 {
 882     ts.dumpProperty(&quot;rect&quot;, item.rect());
 883     return ts;
 884 }
 885 
 886 DrawPath::DrawPath(const Path&amp; path)
 887     : DrawingItem(ItemType::DrawPath)
 888     , m_path(path)
 889 {
 890 }
 891 
 892 DrawPath::~DrawPath() = default;
 893 
 894 void DrawPath::apply(GraphicsContext&amp; context) const
 895 {
 896 #if USE(CG)
 897     context.drawPath(m_path);
 898 #else
 899     UNUSED_PARAM(context);
 900 #endif
 901 }
 902 
 903 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawPath&amp; item)
 904 {
 905     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 906 //    ts.dumpProperty(&quot;path&quot;, item.path()); // FIXME: add logging for paths.
 907     return ts;
 908 }
 909 
 910 DrawFocusRingPath::DrawFocusRingPath(const Path&amp; path, float width, float offset, const Color&amp; color)
 911     : DrawingItem(ItemType::DrawFocusRingPath)
 912     , m_path(path)
 913     , m_width(width)
 914     , m_offset(offset)
 915     , m_color(color)
 916 {
 917 }
 918 
 919 DrawFocusRingPath::~DrawFocusRingPath() = default;
 920 
 921 void DrawFocusRingPath::apply(GraphicsContext&amp; context) const
 922 {
 923     context.drawFocusRing(m_path, m_width, m_offset, m_color);
 924 }
 925 
 926 Optional&lt;FloatRect&gt; DrawFocusRingPath::localBounds(const GraphicsContext&amp;) const
 927 {
 928     FloatRect result = m_path.fastBoundingRect();
 929     result.inflate(platformFocusRingWidth);
 930     return result;
 931 }
 932 
 933 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawFocusRingPath&amp; item)
 934 {
 935     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 936 //    ts.dumpProperty(&quot;path&quot;, item.path()); // FIXME: add logging for paths.
 937     ts.dumpProperty(&quot;width&quot;, item.width());
 938     ts.dumpProperty(&quot;offset&quot;, item.offset());
 939     ts.dumpProperty(&quot;color&quot;, item.color());
 940     return ts;
 941 }
 942 
 943 DrawFocusRingRects::DrawFocusRingRects(const Vector&lt;FloatRect&gt;&amp; rects, float width, float offset, const Color&amp; color)
 944     : DrawingItem(ItemType::DrawFocusRingRects)
 945     , m_rects(rects)
 946     , m_width(width)
 947     , m_offset(offset)
 948     , m_color(color)
 949 {
 950 }
 951 
 952 DrawFocusRingRects::~DrawFocusRingRects() = default;
 953 
 954 void DrawFocusRingRects::apply(GraphicsContext&amp; context) const
 955 {
 956     context.drawFocusRing(m_rects, m_width, m_offset, m_color);
 957 }
 958 
 959 Optional&lt;FloatRect&gt; DrawFocusRingRects::localBounds(const GraphicsContext&amp;) const
 960 {
 961     FloatRect result;
 962     for (auto&amp; rect : m_rects)
 963         result.unite(rect);
 964     result.inflate(platformFocusRingWidth);
 965     return result;
 966 }
 967 
 968 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawFocusRingRects&amp; item)
 969 {
 970     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 971     ts.dumpProperty(&quot;rects&quot;, item.rects());
 972     ts.dumpProperty(&quot;width&quot;, item.width());
 973     ts.dumpProperty(&quot;offset&quot;, item.offset());
 974     ts.dumpProperty(&quot;color&quot;, item.color());
 975     return ts;
 976 }
 977 
 978 FillRect::FillRect(const FloatRect&amp; rect)
 979     : DrawingItem(ItemType::FillRect)
 980     , m_rect(rect)
 981 {
 982 }
 983 
 984 FillRect::~FillRect() = default;
 985 
 986 void FillRect::apply(GraphicsContext&amp; context) const
 987 {
 988     context.fillRect(m_rect);
 989 }
 990 
 991 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRect&amp; item)
 992 {
 993     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 994     ts.dumpProperty(&quot;rect&quot;, item.rect());
 995     return ts;
 996 }
 997 
 998 FillRectWithColor::FillRectWithColor(const FloatRect&amp; rect, const Color&amp; color)
 999     : DrawingItem(ItemType::FillRectWithColor)
1000     , m_rect(rect)
1001     , m_color(color)
1002 {
1003 }
1004 
1005 FillRectWithColor::~FillRectWithColor() = default;
1006 
1007 void FillRectWithColor::apply(GraphicsContext&amp; context) const
1008 {
1009     context.fillRect(m_rect, m_color);
1010 }
1011 
1012 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRectWithColor&amp; item)
1013 {
1014     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1015     ts.dumpProperty(&quot;rect&quot;, item.rect());
1016     ts.dumpProperty(&quot;color&quot;, item.color());
1017     return ts;
1018 }
1019 
1020 FillRectWithGradient::FillRectWithGradient(const FloatRect&amp; rect, Gradient&amp; gradient)
1021     : DrawingItem(ItemType::FillRectWithGradient)
1022     , m_rect(rect)
1023     , m_gradient(gradient)
1024 {
1025 }
1026 
1027 FillRectWithGradient::~FillRectWithGradient() = default;
1028 
1029 void FillRectWithGradient::apply(GraphicsContext&amp; context) const
1030 {
1031     context.fillRect(m_rect, m_gradient.get());
1032 }
1033 
1034 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRectWithGradient&amp; item)
1035 {
1036     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1037     // FIXME: log gradient.
1038     ts.dumpProperty(&quot;rect&quot;, item.rect());
1039     return ts;
1040 }
1041 
1042 FillCompositedRect::FillCompositedRect(const FloatRect&amp; rect, const Color&amp; color, CompositeOperator op, BlendMode blendMode)
1043     : DrawingItem(ItemType::FillCompositedRect)
1044     , m_rect(rect)
1045     , m_color(color)
1046     , m_op(op)
1047     , m_blendMode(blendMode)
1048 {
1049 }
1050 
1051 FillCompositedRect::~FillCompositedRect() = default;
1052 
1053 void FillCompositedRect::apply(GraphicsContext&amp; context) const
1054 {
1055     context.fillRect(m_rect, m_color, m_op, m_blendMode);
1056 }
1057 
1058 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillCompositedRect&amp; item)
1059 {
1060     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1061     ts.dumpProperty(&quot;rect&quot;, item.rect());
1062     ts.dumpProperty(&quot;color&quot;, item.color());
1063     ts.dumpProperty(&quot;composite-operation&quot;, item.compositeOperator());
1064     ts.dumpProperty(&quot;blend-mode&quot;, item.blendMode());
1065     return ts;
1066 }
1067 
1068 FillRoundedRect::FillRoundedRect(const FloatRoundedRect&amp; rect, const Color&amp; color, BlendMode blendMode)
1069     : DrawingItem(ItemType::FillRoundedRect)
1070     , m_rect(rect)
1071     , m_color(color)
1072     , m_blendMode(blendMode)
1073 {
1074 }
1075 
1076 FillRoundedRect::~FillRoundedRect() = default;
1077 
1078 void FillRoundedRect::apply(GraphicsContext&amp; context) const
1079 {
1080     context.fillRoundedRect(m_rect, m_color, m_blendMode);
1081 }
1082 
1083 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRoundedRect&amp; item)
1084 {
1085     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1086     ts.dumpProperty(&quot;rect&quot;, item.roundedRect());
1087     ts.dumpProperty(&quot;color&quot;, item.color());
1088     ts.dumpProperty(&quot;blend-mode&quot;, item.blendMode());
1089     return ts;
1090 }
1091 
1092 FillRectWithRoundedHole::FillRectWithRoundedHole(const FloatRect&amp; rect, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp; color)
1093     : DrawingItem(ItemType::FillRectWithRoundedHole)
1094     , m_rect(rect)
1095     , m_roundedHoleRect(roundedHoleRect)
1096     , m_color(color)
1097 {
1098 }
1099 
1100 FillRectWithRoundedHole::~FillRectWithRoundedHole() = default;
1101 
1102 void FillRectWithRoundedHole::apply(GraphicsContext&amp; context) const
1103 {
1104     context.fillRectWithRoundedHole(m_rect, m_roundedHoleRect, m_color);
1105 }
1106 
1107 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRectWithRoundedHole&amp; item)
1108 {
1109     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1110     ts.dumpProperty(&quot;rect&quot;, item.rect());
1111     ts.dumpProperty(&quot;rounded-hole-rect&quot;, item.roundedHoleRect());
1112     ts.dumpProperty(&quot;color&quot;, item.color());
1113     return ts;
1114 }
1115 
1116 FillPath::FillPath(const Path&amp; path)
1117     : DrawingItem(ItemType::FillPath)
1118     , m_path(path)
1119 {
1120 }
1121 
1122 FillPath::~FillPath() = default;
1123 
1124 void FillPath::apply(GraphicsContext&amp; context) const
1125 {
1126     context.fillPath(m_path);
1127 }
1128 
1129 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillPath&amp; item)
1130 {
1131     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1132     ts.dumpProperty(&quot;path&quot;, item.path());
1133     return ts;
1134 }
1135 
1136 FillEllipse::FillEllipse(const FloatRect&amp; rect)
1137     : DrawingItem(ItemType::FillEllipse)
1138     , m_rect(rect)
1139 {
1140 }
1141 
1142 FillEllipse::~FillEllipse() = default;
1143 
1144 void FillEllipse::apply(GraphicsContext&amp; context) const
1145 {
1146     context.fillEllipse(m_rect);
1147 }
1148 
1149 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillEllipse&amp; item)
1150 {
1151     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1152     ts.dumpProperty(&quot;rect&quot;, item.rect());
1153     return ts;
1154 }
1155 
1156 StrokeRect::StrokeRect(const FloatRect&amp; rect, float lineWidth)
1157     : DrawingItem(ItemType::StrokeRect)
1158     , m_rect(rect)
1159     , m_lineWidth(lineWidth)
1160 {
1161 }
1162 
1163 StrokeRect::~StrokeRect() = default;
1164 
1165 Optional&lt;FloatRect&gt; StrokeRect::localBounds(const GraphicsContext&amp;) const
1166 {
1167     FloatRect bounds = m_rect;
1168     bounds.expand(m_lineWidth, m_lineWidth);
1169     return bounds;
1170 }
1171 
1172 void StrokeRect::apply(GraphicsContext&amp; context) const
1173 {
1174     context.strokeRect(m_rect, m_lineWidth);
1175 }
1176 
1177 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const StrokeRect&amp; item)
1178 {
1179     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1180     ts.dumpProperty(&quot;rect&quot;, item.rect());
1181     ts.dumpProperty(&quot;line-width&quot;, item.lineWidth());
1182     return ts;
1183 }
1184 
1185 Optional&lt;FloatRect&gt; StrokePath::localBounds(const GraphicsContext&amp; context) const
1186 {
1187     // FIXME: Need to take stroke thickness into account correctly, via CGPathByStrokingPath().
1188     float strokeThickness = context.strokeThickness();
1189 
1190     FloatRect bounds = m_path.boundingRect();
1191     bounds.expand(strokeThickness, strokeThickness);
1192     return bounds;
1193 }
1194 
1195 void StrokePath::apply(GraphicsContext&amp; context) const
1196 {
1197     context.strokePath(m_path);
1198 }
1199 
1200 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const StrokePath&amp; item)
1201 {
1202     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1203     ts.dumpProperty(&quot;path&quot;, item.path());
1204     return ts;
1205 }
1206 
1207 StrokeEllipse::StrokeEllipse(const FloatRect&amp; rect)
1208     : DrawingItem(ItemType::StrokeEllipse)
1209     , m_rect(rect)
1210 {
1211 }
1212 
1213 StrokeEllipse::~StrokeEllipse() = default;
1214 
1215 Optional&lt;FloatRect&gt; StrokeEllipse::localBounds(const GraphicsContext&amp; context) const
1216 {
1217     float strokeThickness = context.strokeThickness();
1218 
1219     FloatRect bounds = m_rect;
1220     bounds.expand(strokeThickness, strokeThickness);
1221     return bounds;
1222 }
1223 
1224 void StrokeEllipse::apply(GraphicsContext&amp; context) const
1225 {
1226     context.strokeEllipse(m_rect);
1227 }
1228 
1229 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const StrokeEllipse&amp; item)
1230 {
1231     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1232     ts.dumpProperty(&quot;rect&quot;, item.rect());
1233     return ts;
1234 }
1235 
1236 StrokePath::StrokePath(const Path&amp; path)
1237     : DrawingItem(ItemType::StrokePath)
1238     , m_path(path)
1239 {
1240 }
1241 
1242 StrokePath::~StrokePath() = default;
1243 
1244 ClearRect::ClearRect(const FloatRect&amp; rect)
1245     : DrawingItem(ItemType::ClearRect)
1246     , m_rect(rect)
1247 {
1248 }
1249 
1250 ClearRect::~ClearRect() = default;
1251 
1252 void ClearRect::apply(GraphicsContext&amp; context) const
1253 {
1254     context.clearRect(m_rect);
1255 }
1256 
1257 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClearRect&amp; item)
1258 {
1259     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1260     ts.dumpProperty(&quot;rect&quot;, item.rect());
1261     return ts;
1262 }
1263 
1264 BeginTransparencyLayer::BeginTransparencyLayer(float opacity)
1265     : DrawingItem(ItemType::BeginTransparencyLayer)
1266     , m_opacity(opacity)
1267 {
1268 }
1269 
1270 BeginTransparencyLayer::~BeginTransparencyLayer() = default;
1271 
1272 void BeginTransparencyLayer::apply(GraphicsContext&amp; context) const
1273 {
1274     context.beginTransparencyLayer(m_opacity);
1275 }
1276 
1277 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const BeginTransparencyLayer&amp; item)
1278 {
1279     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1280     ts.dumpProperty(&quot;opacity&quot;, item.opacity());
1281     return ts;
1282 }
1283 
1284 EndTransparencyLayer::EndTransparencyLayer()
1285     : DrawingItem(ItemType::EndTransparencyLayer)
1286 {
1287 }
1288 
1289 EndTransparencyLayer::~EndTransparencyLayer() = default;
1290 
1291 void EndTransparencyLayer::apply(GraphicsContext&amp; context) const
1292 {
1293     context.endTransparencyLayer();
1294 }
1295 
1296 #if USE(CG)
1297 ApplyStrokePattern::ApplyStrokePattern()
1298     : Item(ItemType::ApplyStrokePattern)
1299 {
1300 }
1301 
1302 ApplyStrokePattern::~ApplyStrokePattern() = default;
1303 
1304 void ApplyStrokePattern::apply(GraphicsContext&amp; context) const
1305 {
1306     context.applyStrokePattern();
1307 }
1308 
1309 ApplyFillPattern::ApplyFillPattern()
1310     : Item(ItemType::ApplyFillPattern)
1311 {
1312 }
1313 
1314 ApplyFillPattern::~ApplyFillPattern() = default;
1315 
1316 void ApplyFillPattern::apply(GraphicsContext&amp; context) const
1317 {
1318     context.applyFillPattern();
1319 }
1320 #endif
1321 
1322 ApplyDeviceScaleFactor::ApplyDeviceScaleFactor(float scaleFactor)
1323     : Item(ItemType::ApplyDeviceScaleFactor)
1324     , m_scaleFactor(scaleFactor)
1325 {
1326 }
1327 
1328 ApplyDeviceScaleFactor::~ApplyDeviceScaleFactor() = default;
1329 
1330 void ApplyDeviceScaleFactor::apply(GraphicsContext&amp; context) const
1331 {
1332     context.applyDeviceScaleFactor(m_scaleFactor);
1333 }
1334 
1335 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ApplyDeviceScaleFactor&amp; item)
1336 {
1337     ts.dumpProperty(&quot;scale-factor&quot;, item.scaleFactor());
1338     return ts;
1339 }
1340 
1341 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ItemType&amp; type)
1342 {
1343     switch (type) {
1344     case ItemType::Save: ts &lt;&lt; &quot;save&quot;; break;
1345     case ItemType::Restore: ts &lt;&lt; &quot;restore&quot;; break;
1346     case ItemType::Translate: ts &lt;&lt; &quot;translate&quot;; break;
1347     case ItemType::Rotate: ts &lt;&lt; &quot;rotate&quot;; break;
1348     case ItemType::Scale: ts &lt;&lt; &quot;scale&quot;; break;
1349     case ItemType::SetCTM: ts &lt;&lt; &quot;set-ctm&quot;; break;
1350     case ItemType::ConcatenateCTM: ts &lt;&lt; &quot;concatentate-ctm&quot;; break;
1351     case ItemType::SetState: ts &lt;&lt; &quot;set-state&quot;; break;
1352     case ItemType::SetLineCap: ts &lt;&lt; &quot;set-line-cap&quot;; break;
1353     case ItemType::SetLineDash: ts &lt;&lt; &quot;set-line-dash&quot;; break;
1354     case ItemType::SetLineJoin: ts &lt;&lt; &quot;set-line-join&quot;; break;
1355     case ItemType::SetMiterLimit: ts &lt;&lt; &quot;set-miter-limit&quot;; break;
1356     case ItemType::Clip: ts &lt;&lt; &quot;clip&quot;; break;
1357     case ItemType::ClipOut: ts &lt;&lt; &quot;clip-out&quot;; break;
1358     case ItemType::ClipOutToPath: ts &lt;&lt; &quot;clip-out-to-path&quot;; break;
1359     case ItemType::ClipPath: ts &lt;&lt; &quot;clip-path&quot;; break;
1360     case ItemType::DrawGlyphs: ts &lt;&lt; &quot;draw-glyphs&quot;; break;
1361     case ItemType::DrawImage: ts &lt;&lt; &quot;draw-image&quot;; break;
1362     case ItemType::DrawTiledImage: ts &lt;&lt; &quot;draw-tiled-image&quot;; break;
1363     case ItemType::DrawTiledScaledImage: ts &lt;&lt; &quot;draw-tiled-scaled-image&quot;; break;
1364 #if USE(CG) || USE(CAIRO)
1365     case ItemType::DrawNativeImage: ts &lt;&lt; &quot;draw-native-image&quot;; break;
1366 #endif
1367     case ItemType::DrawPattern: ts &lt;&lt; &quot;draw-pattern&quot;; break;
1368     case ItemType::DrawRect: ts &lt;&lt; &quot;draw-rect&quot;; break;
1369     case ItemType::DrawLine: ts &lt;&lt; &quot;draw-line&quot;; break;
1370     case ItemType::DrawLinesForText: ts &lt;&lt; &quot;draw-lines-for-text&quot;; break;
1371     case ItemType::DrawDotsForDocumentMarker: ts &lt;&lt; &quot;draw-dots-for-document-marker&quot;; break;
1372     case ItemType::DrawEllipse: ts &lt;&lt; &quot;draw-ellipse&quot;; break;
1373     case ItemType::DrawPath: ts &lt;&lt; &quot;draw-path&quot;; break;
1374     case ItemType::DrawFocusRingPath: ts &lt;&lt; &quot;draw-focus-ring-path&quot;; break;
1375     case ItemType::DrawFocusRingRects: ts &lt;&lt; &quot;draw-focus-ring-rects&quot;; break;
1376     case ItemType::FillRect: ts &lt;&lt; &quot;fill-rect&quot;; break;
1377     case ItemType::FillRectWithColor: ts &lt;&lt; &quot;fill-rect-with-color&quot;; break;
1378     case ItemType::FillRectWithGradient: ts &lt;&lt; &quot;fill-rect-with-gradient&quot;; break;
1379     case ItemType::FillCompositedRect: ts &lt;&lt; &quot;fill-composited-rect&quot;; break;
1380     case ItemType::FillRoundedRect: ts &lt;&lt; &quot;fill-rounded-rect&quot;; break;
1381     case ItemType::FillRectWithRoundedHole: ts &lt;&lt; &quot;fill-rect-with-rounded-hole&quot;; break;
1382     case ItemType::FillPath: ts &lt;&lt; &quot;fill-path&quot;; break;
1383     case ItemType::FillEllipse: ts &lt;&lt; &quot;fill-ellipse&quot;; break;
1384     case ItemType::StrokeRect: ts &lt;&lt; &quot;stroke-rect&quot;; break;
1385     case ItemType::StrokePath: ts &lt;&lt; &quot;stroke-path&quot;; break;
1386     case ItemType::StrokeEllipse: ts &lt;&lt; &quot;stroke-ellipse&quot;; break;
1387     case ItemType::ClearRect: ts &lt;&lt; &quot;clear-rect&quot;; break;
1388     case ItemType::BeginTransparencyLayer: ts &lt;&lt; &quot;begin-transparency-layer&quot;; break;
1389     case ItemType::EndTransparencyLayer: ts &lt;&lt; &quot;end-transparency-layer&quot;; break;
1390 #if USE(CG)
1391     case ItemType::ApplyStrokePattern: ts &lt;&lt; &quot;apply-stroke-pattern&quot;; break;
1392     case ItemType::ApplyFillPattern: ts &lt;&lt; &quot;apply-fill-pattern&quot;; break;
1393 #endif
1394     case ItemType::ApplyDeviceScaleFactor: ts &lt;&lt; &quot;apply-device-scale-factor&quot;; break;
1395     case ItemType::ClearShadow: ts &lt;&lt; &quot;clear-shadow&quot;; break;
1396     }
1397     return ts;
1398 }
1399 
1400 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Item&amp; item)
1401 {
1402     TextStream::GroupScope group(ts);
1403     ts &lt;&lt; item.type();
1404 
1405     // FIXME: Make a macro which takes a macro for all these enumeration switches
1406     switch (item.type()) {
1407     case ItemType::Save:
1408         ts &lt;&lt; downcast&lt;Save&gt;(item);
1409         break;
1410     case ItemType::Translate:
1411         ts &lt;&lt; downcast&lt;Translate&gt;(item);
1412         break;
1413     case ItemType::Rotate:
1414         ts &lt;&lt; downcast&lt;Rotate&gt;(item);
1415         break;
1416     case ItemType::Scale:
1417         ts &lt;&lt; downcast&lt;Scale&gt;(item);
1418         break;
1419     case ItemType::SetCTM:
1420         ts &lt;&lt; downcast&lt;SetCTM&gt;(item);
1421         break;
1422     case ItemType::ConcatenateCTM:
1423         ts &lt;&lt; downcast&lt;ConcatenateCTM&gt;(item);
1424         break;
1425     case ItemType::SetState:
1426         ts &lt;&lt; downcast&lt;SetState&gt;(item);
1427         break;
1428     case ItemType::SetLineCap:
1429         ts &lt;&lt; downcast&lt;SetLineCap&gt;(item);
1430         break;
1431     case ItemType::SetLineDash:
1432         ts &lt;&lt; downcast&lt;SetLineDash&gt;(item);
1433         break;
1434     case ItemType::SetLineJoin:
1435         ts &lt;&lt; downcast&lt;SetLineJoin&gt;(item);
1436         break;
1437     case ItemType::SetMiterLimit:
1438         ts &lt;&lt; downcast&lt;SetMiterLimit&gt;(item);
1439         break;
1440     case ItemType::Clip:
1441         ts &lt;&lt; downcast&lt;Clip&gt;(item);
1442         break;
1443     case ItemType::ClipOut:
1444         ts &lt;&lt; downcast&lt;ClipOut&gt;(item);
1445         break;
1446     case ItemType::ClipOutToPath:
1447         ts &lt;&lt; downcast&lt;ClipOutToPath&gt;(item);
1448         break;
1449     case ItemType::ClipPath:
1450         ts &lt;&lt; downcast&lt;ClipPath&gt;(item);
1451         break;
1452     case ItemType::DrawGlyphs:
1453         ts &lt;&lt; downcast&lt;DrawGlyphs&gt;(item);
1454         break;
1455     case ItemType::DrawImage:
1456         ts &lt;&lt; downcast&lt;DrawImage&gt;(item);
1457         break;
1458     case ItemType::DrawTiledImage:
1459         ts &lt;&lt; downcast&lt;DrawTiledImage&gt;(item);
1460         break;
1461     case ItemType::DrawTiledScaledImage:
1462         ts &lt;&lt; downcast&lt;DrawTiledScaledImage&gt;(item);
1463         break;
1464 #if USE(CG) || USE(CAIRO)
1465     case ItemType::DrawNativeImage:
1466         ts &lt;&lt; downcast&lt;DrawNativeImage&gt;(item);
1467         break;
1468 #endif
1469     case ItemType::DrawPattern:
1470         ts &lt;&lt; downcast&lt;DrawPattern&gt;(item);
1471         break;
1472     case ItemType::DrawRect:
1473         ts &lt;&lt; downcast&lt;DrawRect&gt;(item);
1474         break;
1475     case ItemType::DrawLine:
1476         ts &lt;&lt; downcast&lt;DrawLine&gt;(item);
1477         break;
1478     case ItemType::DrawLinesForText:
1479         ts &lt;&lt; downcast&lt;DrawLinesForText&gt;(item);
1480         break;
1481     case ItemType::DrawDotsForDocumentMarker:
1482         ts &lt;&lt; downcast&lt;DrawDotsForDocumentMarker&gt;(item);
1483         break;
1484     case ItemType::DrawEllipse:
1485         ts &lt;&lt; downcast&lt;DrawEllipse&gt;(item);
1486         break;
1487     case ItemType::DrawPath:
1488         ts &lt;&lt; downcast&lt;DrawPath&gt;(item);
1489         break;
1490     case ItemType::DrawFocusRingPath:
1491         ts &lt;&lt; downcast&lt;DrawFocusRingPath&gt;(item);
1492         break;
1493     case ItemType::DrawFocusRingRects:
1494         ts &lt;&lt; downcast&lt;DrawFocusRingRects&gt;(item);
1495         break;
1496     case ItemType::FillRect:
1497         ts &lt;&lt; downcast&lt;FillRect&gt;(item);
1498         break;
1499     case ItemType::FillRectWithColor:
1500         ts &lt;&lt; downcast&lt;FillRectWithColor&gt;(item);
1501         break;
1502     case ItemType::FillRectWithGradient:
1503         ts &lt;&lt; downcast&lt;FillRectWithGradient&gt;(item);
1504         break;
1505     case ItemType::FillCompositedRect:
1506         ts &lt;&lt; downcast&lt;FillCompositedRect&gt;(item);
1507         break;
1508     case ItemType::FillRoundedRect:
1509         ts &lt;&lt; downcast&lt;FillRoundedRect&gt;(item);
1510         break;
1511     case ItemType::FillRectWithRoundedHole:
1512         ts &lt;&lt; downcast&lt;FillRectWithRoundedHole&gt;(item);
1513         break;
1514     case ItemType::FillPath:
1515         ts &lt;&lt; downcast&lt;FillPath&gt;(item);
1516         break;
1517     case ItemType::FillEllipse:
1518         ts &lt;&lt; downcast&lt;FillEllipse&gt;(item);
1519         break;
1520     case ItemType::StrokeRect:
1521         ts &lt;&lt; downcast&lt;StrokeRect&gt;(item);
1522         break;
1523     case ItemType::StrokePath:
1524         ts &lt;&lt; downcast&lt;StrokePath&gt;(item);
1525         break;
1526     case ItemType::StrokeEllipse:
1527         ts &lt;&lt; downcast&lt;StrokeEllipse&gt;(item);
1528         break;
1529     case ItemType::ClearRect:
1530         ts &lt;&lt; downcast&lt;ClearRect&gt;(item);
1531         break;
1532     case ItemType::BeginTransparencyLayer:
1533         ts &lt;&lt; downcast&lt;BeginTransparencyLayer&gt;(item);
1534         break;
1535     case ItemType::ApplyDeviceScaleFactor:
1536         ts &lt;&lt; downcast&lt;ApplyDeviceScaleFactor&gt;(item);
1537         break;
1538 
1539     // Items with no additional data.
1540     case ItemType::Restore:
1541     case ItemType::EndTransparencyLayer:
1542 #if USE(CG)
1543     case ItemType::ApplyStrokePattern:
1544     case ItemType::ApplyFillPattern:
1545 #endif
1546     case ItemType::ClearShadow:
1547         break;
1548     }
1549     return ts;
1550 }
1551 
1552 }
1553 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/shapes/BoxShape.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../line/BreakingContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PolygonShape.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/shapes/BoxShape.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 60         computeMarginBoxShapeRadius(radii.topRight(), LayoutSize(renderer.marginRight(), renderer.marginTop())),
 61         computeMarginBoxShapeRadius(radii.bottomLeft(), LayoutSize(renderer.marginLeft(), renderer.marginBottom())),
 62         computeMarginBoxShapeRadius(radii.bottomRight(), LayoutSize(renderer.marginRight(), renderer.marginBottom())));
 63 }
 64 
 65 RoundedRect computeRoundedRectForBoxShape(CSSBoxType box, const RenderBox&amp; renderer)
 66 {
 67     const RenderStyle&amp; style = renderer.style();
 68     switch (box) {
 69     case CSSBoxType::MarginBox: {
 70         if (!style.hasBorderRadius())
 71             return RoundedRect(renderer.marginBoxRect(), RoundedRect::Radii());
 72 
 73         LayoutRect marginBox = renderer.marginBoxRect();
 74         RoundedRect::Radii radii = computeMarginBoxShapeRadii(style.getRoundedBorderFor(renderer.borderBoxRect()).radii(), renderer);
 75         radii.scale(calcBorderRadiiConstraintScaleFor(marginBox, radii));
 76         return RoundedRect(marginBox, radii);
 77     }
 78     case CSSBoxType::PaddingBox:
 79         return style.getRoundedInnerBorderFor(renderer.borderBoxRect());


 80     case CSSBoxType::ContentBox:
 81         return style.getRoundedInnerBorderFor(renderer.borderBoxRect(),
 82             renderer.paddingTop() + renderer.borderTop(), renderer.paddingBottom() + renderer.borderBottom(),
 83             renderer.paddingLeft() + renderer.borderLeft(), renderer.paddingRight() + renderer.borderRight());
<span class="line-modified"> 84     // fill, stroke, view-box compute to border-box for HTML elements.</span>
 85     case CSSBoxType::BorderBox:
<span class="line-removed"> 86     case CSSBoxType::FillBox:</span>
 87     case CSSBoxType::StrokeBox:
 88     case CSSBoxType::ViewBox:
 89     case CSSBoxType::BoxMissing:
 90         return style.getRoundedBorderFor(renderer.borderBoxRect());
 91     }
 92 
 93     ASSERT_NOT_REACHED();
 94     return style.getRoundedBorderFor(renderer.borderBoxRect());
 95 }
 96 
 97 LayoutRect BoxShape::shapeMarginLogicalBoundingBox() const
 98 {
 99     FloatRect marginBounds(m_bounds.rect());
100     if (shapeMargin() &gt; 0)
101         marginBounds.inflate(shapeMargin());
102     return static_cast&lt;LayoutRect&gt;(marginBounds);
103 }
104 
105 FloatRoundedRect BoxShape::shapeMarginBounds() const
106 {
</pre>
<hr />
<pre>
141 
142     if (y1 &lt;= marginBounds.topRightCorner().maxY() &amp;&amp; y2 &gt;= marginBounds.bottomRightCorner().y())
143         x2 = rect.maxX();
144 
145     if (marginBounds.xInterceptsAtY(y1, minXIntercept, maxXIntercept)) {
146         x1 = std::min&lt;float&gt;(x1, minXIntercept);
147         x2 = std::max&lt;float&gt;(x2, maxXIntercept);
148     }
149 
150     if (marginBounds.xInterceptsAtY(y2, minXIntercept, maxXIntercept)) {
151         x1 = std::min&lt;float&gt;(x1, minXIntercept);
152         x2 = std::max&lt;float&gt;(x2, maxXIntercept);
153     }
154 
155     ASSERT(x2 &gt;= x1);
156     return LineSegment(x1, x2);
157 }
158 
159 void BoxShape::buildDisplayPaths(DisplayPaths&amp; paths) const
160 {
<span class="line-modified">161     paths.shape.addRoundedRect(m_bounds, Path::PreferBezierRoundedRect);</span>
162     if (shapeMargin())
<span class="line-modified">163         paths.marginShape.addRoundedRect(shapeMarginBounds(), Path::PreferBezierRoundedRect);</span>
164 }
165 
166 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 60         computeMarginBoxShapeRadius(radii.topRight(), LayoutSize(renderer.marginRight(), renderer.marginTop())),
 61         computeMarginBoxShapeRadius(radii.bottomLeft(), LayoutSize(renderer.marginLeft(), renderer.marginBottom())),
 62         computeMarginBoxShapeRadius(radii.bottomRight(), LayoutSize(renderer.marginRight(), renderer.marginBottom())));
 63 }
 64 
 65 RoundedRect computeRoundedRectForBoxShape(CSSBoxType box, const RenderBox&amp; renderer)
 66 {
 67     const RenderStyle&amp; style = renderer.style();
 68     switch (box) {
 69     case CSSBoxType::MarginBox: {
 70         if (!style.hasBorderRadius())
 71             return RoundedRect(renderer.marginBoxRect(), RoundedRect::Radii());
 72 
 73         LayoutRect marginBox = renderer.marginBoxRect();
 74         RoundedRect::Radii radii = computeMarginBoxShapeRadii(style.getRoundedBorderFor(renderer.borderBoxRect()).radii(), renderer);
 75         radii.scale(calcBorderRadiiConstraintScaleFor(marginBox, radii));
 76         return RoundedRect(marginBox, radii);
 77     }
 78     case CSSBoxType::PaddingBox:
 79         return style.getRoundedInnerBorderFor(renderer.borderBoxRect());
<span class="line-added"> 80     // fill-box compute to content-box for HTML elements.</span>
<span class="line-added"> 81     case CSSBoxType::FillBox:</span>
 82     case CSSBoxType::ContentBox:
 83         return style.getRoundedInnerBorderFor(renderer.borderBoxRect(),
 84             renderer.paddingTop() + renderer.borderTop(), renderer.paddingBottom() + renderer.borderBottom(),
 85             renderer.paddingLeft() + renderer.borderLeft(), renderer.paddingRight() + renderer.borderRight());
<span class="line-modified"> 86     // stroke-box, view-box compute to border-box for HTML elements.</span>
 87     case CSSBoxType::BorderBox:

 88     case CSSBoxType::StrokeBox:
 89     case CSSBoxType::ViewBox:
 90     case CSSBoxType::BoxMissing:
 91         return style.getRoundedBorderFor(renderer.borderBoxRect());
 92     }
 93 
 94     ASSERT_NOT_REACHED();
 95     return style.getRoundedBorderFor(renderer.borderBoxRect());
 96 }
 97 
 98 LayoutRect BoxShape::shapeMarginLogicalBoundingBox() const
 99 {
100     FloatRect marginBounds(m_bounds.rect());
101     if (shapeMargin() &gt; 0)
102         marginBounds.inflate(shapeMargin());
103     return static_cast&lt;LayoutRect&gt;(marginBounds);
104 }
105 
106 FloatRoundedRect BoxShape::shapeMarginBounds() const
107 {
</pre>
<hr />
<pre>
142 
143     if (y1 &lt;= marginBounds.topRightCorner().maxY() &amp;&amp; y2 &gt;= marginBounds.bottomRightCorner().y())
144         x2 = rect.maxX();
145 
146     if (marginBounds.xInterceptsAtY(y1, minXIntercept, maxXIntercept)) {
147         x1 = std::min&lt;float&gt;(x1, minXIntercept);
148         x2 = std::max&lt;float&gt;(x2, maxXIntercept);
149     }
150 
151     if (marginBounds.xInterceptsAtY(y2, minXIntercept, maxXIntercept)) {
152         x1 = std::min&lt;float&gt;(x1, minXIntercept);
153         x2 = std::max&lt;float&gt;(x2, maxXIntercept);
154     }
155 
156     ASSERT(x2 &gt;= x1);
157     return LineSegment(x1, x2);
158 }
159 
160 void BoxShape::buildDisplayPaths(DisplayPaths&amp; paths) const
161 {
<span class="line-modified">162     paths.shape.addRoundedRect(m_bounds, Path::RoundedRectStrategy::PreferBezier);</span>
163     if (shapeMargin())
<span class="line-modified">164         paths.marginShape.addRoundedRect(shapeMarginBounds(), Path::RoundedRectStrategy::PreferBezier);</span>
165 }
166 
167 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="../line/BreakingContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PolygonShape.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
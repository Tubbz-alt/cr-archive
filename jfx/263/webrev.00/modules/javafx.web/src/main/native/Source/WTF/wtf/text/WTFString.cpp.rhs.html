<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/text/WTFString.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * (C) 1999 Lars Knoll (knoll@kde.org)
   3  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   4  * Copyright (C) 2007-2009 Torch Mobile, Inc.
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public License
  17  * along with this library; see the file COPYING.LIB.  If not, write to
  18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 #include &quot;config.h&quot;
  23 #include &lt;wtf/text/WTFString.h&gt;
  24 
  25 #include &lt;stdarg.h&gt;
  26 #include &lt;wtf/ASCIICType.h&gt;
  27 #include &lt;wtf/DataLog.h&gt;
  28 #include &lt;wtf/HexNumber.h&gt;
  29 #include &lt;wtf/MathExtras.h&gt;
  30 #include &lt;wtf/NeverDestroyed.h&gt;
  31 #include &lt;wtf/Vector.h&gt;
  32 #include &lt;wtf/dtoa.h&gt;
  33 #include &lt;wtf/text/CString.h&gt;
  34 #include &lt;wtf/text/IntegerToStringConversion.h&gt;
<a name="1" id="anc1"></a><span class="line-added">  35 #include &lt;wtf/text/StringBuilder.h&gt;</span>
  36 #include &lt;wtf/text/StringToIntegerConversion.h&gt;
  37 #include &lt;wtf/unicode/CharacterNames.h&gt;
  38 #include &lt;wtf/unicode/UTF8Conversion.h&gt;
  39 
  40 namespace WTF {
  41 
  42 using namespace Unicode;
  43 
  44 // Construct a string with UTF-16 data.
  45 String::String(const UChar* characters, unsigned length)
  46 {
  47     if (characters)
  48         m_impl = StringImpl::create(characters, length);
  49 }
  50 
  51 // Construct a string with UTF-16 data, from a null-terminated source.
  52 String::String(const UChar* nullTerminatedString)
  53 {
  54     if (nullTerminatedString)
  55         m_impl = StringImpl::create(nullTerminatedString, lengthOfNullTerminatedString(nullTerminatedString));
  56 }
  57 
  58 // Construct a string with latin1 data.
  59 String::String(const LChar* characters, unsigned length)
  60 {
  61     if (characters)
  62         m_impl = StringImpl::create(characters, length);
  63 }
  64 
  65 String::String(const char* characters, unsigned length)
  66 {
  67     if (characters)
  68         m_impl = StringImpl::create(reinterpret_cast&lt;const LChar*&gt;(characters), length);
  69 }
  70 
  71 // Construct a string with Latin-1 data, from a null-terminated source.
  72 String::String(const LChar* nullTerminatedString)
  73 {
  74     if (nullTerminatedString)
  75         m_impl = StringImpl::create(nullTerminatedString);
  76 }
  77 
  78 String::String(const char* nullTerminatedString)
  79 {
  80     if (nullTerminatedString)
  81         m_impl = StringImpl::create(reinterpret_cast&lt;const LChar*&gt;(nullTerminatedString));
  82 }
  83 
  84 String::String(ASCIILiteral characters)
  85     : m_impl(StringImpl::createFromLiteral(characters))
  86 {
  87 }
  88 
  89 void String::append(const String&amp; otherString)
  90 {
  91     // FIXME: This is extremely inefficient. So much so that we might want to take this out of String&#39;s API.
  92 
  93     if (!m_impl) {
  94         m_impl = otherString.m_impl;
  95         return;
  96     }
  97 
  98     if (otherString.isEmpty())
  99         return;
 100 
 101     auto length = m_impl-&gt;length();
 102     auto otherLength = otherString.m_impl-&gt;length();
 103     if (otherLength &gt; MaxLength - length)
 104         CRASH();
 105 
 106     if (m_impl-&gt;is8Bit() &amp;&amp; otherString.m_impl-&gt;is8Bit()) {
 107         LChar* data;
 108         auto newImpl = StringImpl::createUninitialized(length + otherLength, data);
 109         StringImpl::copyCharacters(data, m_impl-&gt;characters8(), length);
 110         StringImpl::copyCharacters(data + length, otherString.m_impl-&gt;characters8(), otherLength);
 111         m_impl = WTFMove(newImpl);
 112         return;
 113     }
 114     UChar* data;
 115     auto newImpl = StringImpl::createUninitialized(length + otherLength, data);
 116     StringView(*m_impl).getCharactersWithUpconvert(data);
 117     StringView(*otherString.m_impl).getCharactersWithUpconvert(data + length);
 118     m_impl = WTFMove(newImpl);
 119 }
 120 
 121 void String::append(LChar character)
 122 {
 123     // FIXME: This is extremely inefficient. So much so that we might want to take this out of String&#39;s API.
 124 
 125     if (!m_impl) {
 126         m_impl = StringImpl::create(&amp;character, 1);
 127         return;
 128     }
 129     if (!is8Bit()) {
 130         append(static_cast&lt;UChar&gt;(character));
 131         return;
 132     }
 133     if (m_impl-&gt;length() &gt;= MaxLength)
 134         CRASH();
 135     LChar* data;
 136     auto newImpl = StringImpl::createUninitialized(m_impl-&gt;length() + 1, data);
 137     StringImpl::copyCharacters(data, m_impl-&gt;characters8(), m_impl-&gt;length());
 138     data[m_impl-&gt;length()] = character;
 139     m_impl = WTFMove(newImpl);
 140 }
 141 
 142 void String::append(UChar character)
 143 {
 144     // FIXME: This is extremely inefficient. So much so that we might want to take this out of String&#39;s API.
 145 
 146     if (!m_impl) {
 147         m_impl = StringImpl::create(&amp;character, 1);
 148         return;
 149     }
 150     if (isLatin1(character) &amp;&amp; is8Bit()) {
 151         append(static_cast&lt;LChar&gt;(character));
 152         return;
 153     }
 154     if (m_impl-&gt;length() &gt;= MaxLength)
 155         CRASH();
 156     UChar* data;
 157     auto newImpl = StringImpl::createUninitialized(m_impl-&gt;length() + 1, data);
 158     StringView(*m_impl).getCharactersWithUpconvert(data);
 159     data[m_impl-&gt;length()] = character;
 160     m_impl = WTFMove(newImpl);
 161 }
 162 
 163 int codePointCompare(const String&amp; a, const String&amp; b)
 164 {
 165     return codePointCompare(a.impl(), b.impl());
 166 }
 167 
 168 void String::insert(const String&amp; string, unsigned position)
 169 {
 170     // FIXME: This is extremely inefficient. So much so that we might want to take this out of String&#39;s API.
 171 
 172     unsigned lengthToInsert = string.length();
 173 
 174     if (!lengthToInsert) {
 175         if (string.isNull())
 176             return;
 177         if (isNull())
 178             m_impl = string.impl();
 179         return;
 180     }
 181 
 182     if (position &gt;= length()) {
 183         append(string);
 184         return;
 185     }
 186 
 187     if (lengthToInsert &gt; MaxLength - length())
 188         CRASH();
 189 
 190     if (is8Bit() &amp;&amp; string.is8Bit()) {
 191         LChar* data;
 192         auto newString = StringImpl::createUninitialized(length() + lengthToInsert, data);
 193         StringView(*m_impl).substring(0, position).getCharactersWithUpconvert(data);
 194         StringView(string).getCharactersWithUpconvert(data + position);
 195         StringView(*m_impl).substring(position).getCharactersWithUpconvert(data + position + lengthToInsert);
 196         m_impl = WTFMove(newString);
 197     } else {
 198         UChar* data;
 199         auto newString = StringImpl::createUninitialized(length() + lengthToInsert, data);
 200         StringView(*m_impl).substring(0, position).getCharactersWithUpconvert(data);
 201         StringView(string).getCharactersWithUpconvert(data + position);
 202         StringView(*m_impl).substring(position).getCharactersWithUpconvert(data + position + lengthToInsert);
 203         m_impl = WTFMove(newString);
 204     }
 205 }
 206 
 207 void String::append(const LChar* charactersToAppend, unsigned lengthToAppend)
 208 {
 209     // FIXME: This is extremely inefficient. So much so that we might want to take this out of String&#39;s API.
 210 
 211     if (!m_impl) {
 212         if (!charactersToAppend)
 213             return;
 214         m_impl = StringImpl::create(charactersToAppend, lengthToAppend);
 215         return;
 216     }
 217 
 218     if (!lengthToAppend)
 219         return;
 220 
 221     ASSERT(charactersToAppend);
 222 
 223     unsigned strLength = m_impl-&gt;length();
 224 
 225     if (m_impl-&gt;is8Bit()) {
 226         if (lengthToAppend &gt; MaxLength - strLength)
 227             CRASH();
 228         LChar* data;
 229         auto newImpl = StringImpl::createUninitialized(strLength + lengthToAppend, data);
 230         StringImpl::copyCharacters(data, m_impl-&gt;characters8(), strLength);
 231         StringImpl::copyCharacters(data + strLength, charactersToAppend, lengthToAppend);
 232         m_impl = WTFMove(newImpl);
 233         return;
 234     }
 235 
 236     if (lengthToAppend &gt; MaxLength - strLength)
 237         CRASH();
 238     UChar* data;
 239     auto newImpl = StringImpl::createUninitialized(length() + lengthToAppend, data);
 240     StringImpl::copyCharacters(data, m_impl-&gt;characters16(), strLength);
 241     StringImpl::copyCharacters(data + strLength, charactersToAppend, lengthToAppend);
 242     m_impl = WTFMove(newImpl);
 243 }
 244 
 245 void String::append(const UChar* charactersToAppend, unsigned lengthToAppend)
 246 {
 247     // FIXME: This is extremely inefficient. So much so that we might want to take this out of String&#39;s API.
 248 
 249     if (!m_impl) {
 250         if (!charactersToAppend)
 251             return;
 252         m_impl = StringImpl::create(charactersToAppend, lengthToAppend);
 253         return;
 254     }
 255 
 256     if (!lengthToAppend)
 257         return;
 258 
 259     unsigned strLength = m_impl-&gt;length();
 260 
 261     ASSERT(charactersToAppend);
 262     if (lengthToAppend &gt; MaxLength - strLength)
 263         CRASH();
 264     UChar* data;
 265     auto newImpl = StringImpl::createUninitialized(strLength + lengthToAppend, data);
 266     if (m_impl-&gt;is8Bit())
 267         StringImpl::copyCharacters(data, characters8(), strLength);
 268     else
 269         StringImpl::copyCharacters(data, characters16(), strLength);
 270     StringImpl::copyCharacters(data + strLength, charactersToAppend, lengthToAppend);
 271     m_impl = WTFMove(newImpl);
 272 }
 273 
 274 
 275 UChar32 String::characterStartingAt(unsigned i) const
 276 {
 277     if (!m_impl || i &gt;= m_impl-&gt;length())
 278         return 0;
 279     return m_impl-&gt;characterStartingAt(i);
 280 }
 281 
 282 void String::truncate(unsigned position)
 283 {
 284     if (m_impl)
 285         m_impl = m_impl-&gt;substring(0, position);
 286 }
 287 
 288 template&lt;typename CharacterType&gt; inline void String::removeInternal(const CharacterType* characters, unsigned position, unsigned lengthToRemove)
 289 {
 290     CharacterType* data;
 291     auto newImpl = StringImpl::createUninitialized(length() - lengthToRemove, data);
 292     StringImpl::copyCharacters(data, characters, position);
 293     StringImpl::copyCharacters(data + position, characters + position + lengthToRemove, length() - lengthToRemove - position);
 294     m_impl = WTFMove(newImpl);
 295 }
 296 
 297 void String::remove(unsigned position, unsigned lengthToRemove)
 298 {
 299     if (!lengthToRemove)
 300         return;
 301     auto length = this-&gt;length();
 302     if (position &gt;= length)
 303         return;
 304     lengthToRemove = std::min(lengthToRemove, length - position);
 305     if (is8Bit())
 306         removeInternal(characters8(), position, lengthToRemove);
 307     else
 308         removeInternal(characters16(), position, lengthToRemove);
 309 }
 310 
 311 String String::substring(unsigned position, unsigned length) const
 312 {
 313     // FIXME: Should this function, and the many others like it, be inlined?
 314     return m_impl ? m_impl-&gt;substring(position, length) : String { };
 315 }
 316 
 317 String String::substringSharingImpl(unsigned offset, unsigned length) const
 318 {
 319     // FIXME: We used to check against a limit of Heap::minExtraCost / sizeof(UChar).
 320 
 321     unsigned stringLength = this-&gt;length();
 322     offset = std::min(offset, stringLength);
 323     length = std::min(length, stringLength - offset);
 324 
 325     if (!offset &amp;&amp; length == stringLength)
 326         return *this;
 327     return StringImpl::createSubstringSharingImpl(*m_impl, offset, length);
 328 }
 329 
 330 String String::convertToASCIILowercase() const
 331 {
 332     // FIXME: Should this function, and the many others like it, be inlined?
 333     return m_impl ? m_impl-&gt;convertToASCIILowercase() : String { };
 334 }
 335 
 336 String String::convertToASCIIUppercase() const
 337 {
 338     // FIXME: Should this function, and the many others like it, be inlined?
 339     return m_impl ? m_impl-&gt;convertToASCIIUppercase() : String { };
 340 }
 341 
 342 String String::convertToLowercaseWithoutLocale() const
 343 {
 344     // FIXME: Should this function, and the many others like it, be inlined?
 345     return m_impl ? m_impl-&gt;convertToLowercaseWithoutLocale() : String { };
 346 }
 347 
 348 String String::convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(unsigned failingIndex) const
 349 {
 350     // FIXME: Should this function, and the many others like it, be inlined?
 351     return m_impl ? m_impl-&gt;convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(failingIndex) : String { };
 352 }
 353 
 354 String String::convertToUppercaseWithoutLocale() const
 355 {
 356     // FIXME: Should this function, and the many others like it, be inlined?
 357     return m_impl ? m_impl-&gt;convertToUppercaseWithoutLocale() : String { };
 358 }
 359 
 360 String String::convertToLowercaseWithLocale(const AtomString&amp; localeIdentifier) const
 361 {
 362     // FIXME: Should this function, and the many others like it, be inlined?
 363     return m_impl ? m_impl-&gt;convertToLowercaseWithLocale(localeIdentifier) : String { };
 364 }
 365 
 366 String String::convertToUppercaseWithLocale(const AtomString&amp; localeIdentifier) const
 367 {
 368     // FIXME: Should this function, and the many others like it, be inlined?
 369     return m_impl ? m_impl-&gt;convertToUppercaseWithLocale(localeIdentifier) : String { };
 370 }
 371 
 372 String String::stripWhiteSpace() const
 373 {
 374     // FIXME: Should this function, and the many others like it, be inlined?
 375     // FIXME: This function needs a new name. For one thing, &quot;whitespace&quot; is a single
 376     // word so the &quot;s&quot; should be lowercase. For another, it&#39;s not clear from this name
 377     // that the function uses the Unicode definition of whitespace. Most WebKit callers
 378     // don&#39;t want that and eventually we should consider deleting this.
 379     return m_impl ? m_impl-&gt;stripWhiteSpace() : String { };
 380 }
 381 
 382 String String::stripLeadingAndTrailingCharacters(CodeUnitMatchFunction predicate) const
 383 {
 384     // FIXME: Should this function, and the many others like it, be inlined?
 385     return m_impl ? m_impl-&gt;stripLeadingAndTrailingCharacters(predicate) : String { };
 386 }
 387 
 388 String String::simplifyWhiteSpace() const
 389 {
 390     // FIXME: Should this function, and the many others like it, be inlined?
 391     // FIXME: This function needs a new name. For one thing, &quot;whitespace&quot; is a single
 392     // word so the &quot;s&quot; should be lowercase. For another, it&#39;s not clear from this name
 393     // that the function uses the Unicode definition of whitespace. Most WebKit callers
 394     // don&#39;t want that and eventually we should consider deleting this.
 395     return m_impl ? m_impl-&gt;simplifyWhiteSpace() : String { };
 396 }
 397 
 398 String String::simplifyWhiteSpace(CodeUnitMatchFunction isWhiteSpace) const
 399 {
 400     // FIXME: Should this function, and the many others like it, be inlined?
 401     return m_impl ? m_impl-&gt;simplifyWhiteSpace(isWhiteSpace) : String { };
 402 }
 403 
 404 String String::removeCharacters(CodeUnitMatchFunction findMatch) const
 405 {
 406     // FIXME: Should this function, and the many others like it, be inlined?
 407     return m_impl ? m_impl-&gt;removeCharacters(findMatch) : String { };
 408 }
 409 
 410 String String::foldCase() const
 411 {
 412     // FIXME: Should this function, and the many others like it, be inlined?
 413     return m_impl ? m_impl-&gt;foldCase() : String { };
 414 }
 415 
 416 bool String::percentage(int&amp; result) const
 417 {
 418     if (!m_impl || !m_impl-&gt;length())
 419         return false;
 420 
 421     if ((*m_impl)[m_impl-&gt;length() - 1] != &#39;%&#39;)
 422        return false;
 423 
 424     if (m_impl-&gt;is8Bit())
 425         result = charactersToIntStrict(m_impl-&gt;characters8(), m_impl-&gt;length() - 1);
 426     else
 427         result = charactersToIntStrict(m_impl-&gt;characters16(), m_impl-&gt;length() - 1);
 428     return true;
 429 }
 430 
 431 Vector&lt;UChar&gt; String::charactersWithNullTermination() const
 432 {
 433     Vector&lt;UChar&gt; result;
 434 
 435     if (m_impl) {
 436         result.reserveInitialCapacity(length() + 1);
 437 
 438         if (is8Bit()) {
 439             const LChar* characters8 = m_impl-&gt;characters8();
 440             for (size_t i = 0; i &lt; length(); ++i)
 441                 result.uncheckedAppend(characters8[i]);
 442         } else {
 443             const UChar* characters16 = m_impl-&gt;characters16();
 444             result.append(characters16, m_impl-&gt;length());
 445         }
 446 
 447         result.append(0);
 448     }
 449 
 450     return result;
 451 }
 452 
 453 String String::number(int number)
 454 {
 455     return numberToStringSigned&lt;String&gt;(number);
 456 }
 457 
 458 String String::number(unsigned number)
 459 {
 460     return numberToStringUnsigned&lt;String&gt;(number);
 461 }
 462 
 463 String String::number(long number)
 464 {
 465     return numberToStringSigned&lt;String&gt;(number);
 466 }
 467 
 468 String String::number(unsigned long number)
 469 {
 470     return numberToStringUnsigned&lt;String&gt;(number);
 471 }
 472 
 473 String String::number(long long number)
 474 {
 475     return numberToStringSigned&lt;String&gt;(number);
 476 }
 477 
 478 String String::number(unsigned long long number)
 479 {
 480     return numberToStringUnsigned&lt;String&gt;(number);
 481 }
 482 
 483 String String::numberToStringFixedPrecision(float number, unsigned precision, TrailingZerosTruncatingPolicy trailingZerosTruncatingPolicy)
 484 {
 485     NumberToStringBuffer buffer;
 486     return numberToFixedPrecisionString(number, precision, buffer, trailingZerosTruncatingPolicy == TruncateTrailingZeros);
 487 }
 488 
 489 String String::numberToStringFixedPrecision(double number, unsigned precision, TrailingZerosTruncatingPolicy trailingZerosTruncatingPolicy)
 490 {
 491     NumberToStringBuffer buffer;
 492     return numberToFixedPrecisionString(number, precision, buffer, trailingZerosTruncatingPolicy == TruncateTrailingZeros);
 493 }
 494 
 495 String String::number(float number)
 496 {
 497     NumberToStringBuffer buffer;
 498     return numberToString(number, buffer);
 499 }
 500 
 501 String String::number(double number)
 502 {
 503     NumberToStringBuffer buffer;
 504     return numberToString(number, buffer);
 505 }
 506 
 507 String String::numberToStringFixedWidth(double number, unsigned decimalPlaces)
 508 {
 509     NumberToStringBuffer buffer;
 510     return numberToFixedWidthString(number, decimalPlaces, buffer);
 511 }
 512 
 513 int String::toIntStrict(bool* ok, int base) const
 514 {
 515     if (!m_impl) {
 516         if (ok)
 517             *ok = false;
 518         return 0;
 519     }
 520     return m_impl-&gt;toIntStrict(ok, base);
 521 }
 522 
 523 unsigned String::toUIntStrict(bool* ok, int base) const
 524 {
 525     if (!m_impl) {
 526         if (ok)
 527             *ok = false;
 528         return 0;
 529     }
 530     return m_impl-&gt;toUIntStrict(ok, base);
 531 }
 532 
 533 int64_t String::toInt64Strict(bool* ok, int base) const
 534 {
 535     if (!m_impl) {
 536         if (ok)
 537             *ok = false;
 538         return 0;
 539     }
 540     return m_impl-&gt;toInt64Strict(ok, base);
 541 }
 542 
 543 uint64_t String::toUInt64Strict(bool* ok, int base) const
 544 {
 545     if (!m_impl) {
 546         if (ok)
 547             *ok = false;
 548         return 0;
 549     }
 550     return m_impl-&gt;toUInt64Strict(ok, base);
 551 }
 552 
 553 intptr_t String::toIntPtrStrict(bool* ok, int base) const
 554 {
 555     if (!m_impl) {
 556         if (ok)
 557             *ok = false;
 558         return 0;
 559     }
 560     return m_impl-&gt;toIntPtrStrict(ok, base);
 561 }
 562 
 563 int String::toInt(bool* ok) const
 564 {
 565     if (!m_impl) {
 566         if (ok)
 567             *ok = false;
 568         return 0;
 569     }
 570     return m_impl-&gt;toInt(ok);
 571 }
 572 
 573 unsigned String::toUInt(bool* ok) const
 574 {
 575     if (!m_impl) {
 576         if (ok)
 577             *ok = false;
 578         return 0;
 579     }
 580     return m_impl-&gt;toUInt(ok);
 581 }
 582 
 583 int64_t String::toInt64(bool* ok) const
 584 {
 585     if (!m_impl) {
 586         if (ok)
 587             *ok = false;
 588         return 0;
 589     }
 590     return m_impl-&gt;toInt64(ok);
 591 }
 592 
 593 uint64_t String::toUInt64(bool* ok) const
 594 {
 595     if (!m_impl) {
 596         if (ok)
 597             *ok = false;
 598         return 0;
 599     }
 600     return m_impl-&gt;toUInt64(ok);
 601 }
 602 
 603 intptr_t String::toIntPtr(bool* ok) const
 604 {
 605     if (!m_impl) {
 606         if (ok)
 607             *ok = false;
 608         return 0;
 609     }
 610     return m_impl-&gt;toIntPtr(ok);
 611 }
 612 
 613 double String::toDouble(bool* ok) const
 614 {
 615     if (!m_impl) {
 616         if (ok)
 617             *ok = false;
 618         return 0.0;
 619     }
 620     return m_impl-&gt;toDouble(ok);
 621 }
 622 
 623 float String::toFloat(bool* ok) const
 624 {
 625     if (!m_impl) {
 626         if (ok)
 627             *ok = false;
 628         return 0.0f;
 629     }
 630     return m_impl-&gt;toFloat(ok);
 631 }
 632 
 633 String String::isolatedCopy() const &amp;
 634 {
 635     // FIXME: Should this function, and the many others like it, be inlined?
 636     return m_impl ? m_impl-&gt;isolatedCopy() : String { };
 637 }
 638 
 639 String String::isolatedCopy() &amp;&amp;
 640 {
 641     if (isSafeToSendToAnotherThread()) {
 642         // Since we know that our string is a temporary that will be destroyed
 643         // we can just steal the m_impl from it, thus avoiding a copy.
 644         return { WTFMove(*this) };
 645     }
 646 
 647     return m_impl ? m_impl-&gt;isolatedCopy() : String { };
 648 }
 649 
 650 bool String::isSafeToSendToAnotherThread() const
 651 {
 652     // AtomStrings are not safe to send between threads, as ~StringImpl()
 653     // will try to remove them from the wrong AtomStringTable.
 654     return isEmpty() || (m_impl-&gt;hasOneRef() &amp;&amp; !m_impl-&gt;isAtom());
 655 }
 656 
 657 template&lt;bool allowEmptyEntries&gt;
 658 inline Vector&lt;String&gt; String::splitInternal(const String&amp; separator) const
 659 {
 660     Vector&lt;String&gt; result;
 661 
 662     unsigned startPos = 0;
 663     size_t endPos;
 664     while ((endPos = find(separator, startPos)) != notFound) {
 665         if (allowEmptyEntries || startPos != endPos)
 666             result.append(substring(startPos, endPos - startPos));
 667         startPos = endPos + separator.length();
 668     }
 669     if (allowEmptyEntries || startPos != length())
 670         result.append(substring(startPos));
 671 
 672     return result;
 673 }
 674 
 675 template&lt;bool allowEmptyEntries&gt;
 676 inline void String::splitInternal(UChar separator, const SplitFunctor&amp; functor) const
 677 {
 678     StringView view(*this);
 679 
 680     unsigned startPos = 0;
 681     size_t endPos;
 682     while ((endPos = find(separator, startPos)) != notFound) {
 683         if (allowEmptyEntries || startPos != endPos)
 684             functor(view.substring(startPos, endPos - startPos));
 685         startPos = endPos + 1;
 686     }
 687     if (allowEmptyEntries || startPos != length())
 688         functor(view.substring(startPos));
 689 }
 690 
 691 template&lt;bool allowEmptyEntries&gt;
 692 inline Vector&lt;String&gt; String::splitInternal(UChar separator) const
 693 {
 694     Vector&lt;String&gt; result;
 695     splitInternal&lt;allowEmptyEntries&gt;(separator, [&amp;result](StringView item) {
 696         result.append(item.toString());
 697     });
 698 
 699     return result;
 700 }
 701 
 702 void String::split(UChar separator, const SplitFunctor&amp; functor) const
 703 {
 704     splitInternal&lt;false&gt;(separator, functor);
 705 }
 706 
 707 Vector&lt;String&gt; String::split(UChar separator) const
 708 {
 709     return splitInternal&lt;false&gt;(separator);
 710 }
 711 
 712 Vector&lt;String&gt; String::split(const String&amp; separator) const
 713 {
 714     return splitInternal&lt;false&gt;(separator);
 715 }
 716 
 717 void String::splitAllowingEmptyEntries(UChar separator, const SplitFunctor&amp; functor) const
 718 {
 719     splitInternal&lt;true&gt;(separator, functor);
 720 }
 721 
 722 Vector&lt;String&gt; String::splitAllowingEmptyEntries(UChar separator) const
 723 {
 724     return splitInternal&lt;true&gt;(separator);
 725 }
 726 
 727 Vector&lt;String&gt; String::splitAllowingEmptyEntries(const String&amp; separator) const
 728 {
 729     return splitInternal&lt;true&gt;(separator);
 730 }
 731 
 732 CString String::ascii() const
 733 {
 734     // Printable ASCII characters 32..127 and the null character are
 735     // preserved, characters outside of this range are converted to &#39;?&#39;.
 736 
 737     unsigned length = this-&gt;length();
 738     if (!length) {
 739         char* characterBuffer;
 740         return CString::newUninitialized(length, characterBuffer);
 741     }
 742 
 743     if (this-&gt;is8Bit()) {
 744         const LChar* characters = this-&gt;characters8();
 745 
 746         char* characterBuffer;
 747         CString result = CString::newUninitialized(length, characterBuffer);
 748 
 749         for (unsigned i = 0; i &lt; length; ++i) {
 750             LChar ch = characters[i];
 751             characterBuffer[i] = ch &amp;&amp; (ch &lt; 0x20 || ch &gt; 0x7f) ? &#39;?&#39; : ch;
 752         }
 753 
 754         return result;
 755     }
 756 
 757     const UChar* characters = this-&gt;characters16();
 758 
 759     char* characterBuffer;
 760     CString result = CString::newUninitialized(length, characterBuffer);
 761 
 762     for (unsigned i = 0; i &lt; length; ++i) {
 763         UChar ch = characters[i];
 764         characterBuffer[i] = ch &amp;&amp; (ch &lt; 0x20 || ch &gt; 0x7f) ? &#39;?&#39; : ch;
 765     }
 766 
 767     return result;
 768 }
 769 
 770 CString String::latin1() const
 771 {
 772     // Basic Latin1 (ISO) encoding - Unicode characters 0..255 are
 773     // preserved, characters outside of this range are converted to &#39;?&#39;.
 774 
 775     unsigned length = this-&gt;length();
 776 
 777     if (!length)
 778         return CString(&quot;&quot;, 0);
 779 
 780     if (is8Bit())
 781         return CString(reinterpret_cast&lt;const char*&gt;(this-&gt;characters8()), length);
 782 
 783     const UChar* characters = this-&gt;characters16();
 784 
 785     char* characterBuffer;
 786     CString result = CString::newUninitialized(length, characterBuffer);
 787 
 788     for (unsigned i = 0; i &lt; length; ++i) {
 789         UChar ch = characters[i];
 790         characterBuffer[i] = !isLatin1(ch) ? &#39;?&#39; : ch;
 791     }
 792 
 793     return result;
 794 }
 795 
 796 Expected&lt;CString, UTF8ConversionError&gt; String::tryGetUtf8(ConversionMode mode) const
 797 {
 798     return m_impl ? m_impl-&gt;tryGetUtf8(mode) : CString { &quot;&quot;, 0 };
 799 }
 800 
 801 Expected&lt;CString, UTF8ConversionError&gt; String::tryGetUtf8() const
 802 {
 803     return tryGetUtf8(LenientConversion);
 804 }
 805 
 806 CString String::utf8(ConversionMode mode) const
 807 {
 808     Expected&lt;CString, UTF8ConversionError&gt; expectedString = tryGetUtf8(mode);
 809     RELEASE_ASSERT(expectedString);
 810     return expectedString.value();
 811 }
 812 
 813 CString String::utf8() const
 814 {
 815     return utf8(LenientConversion);
 816 }
 817 
 818 String String::make8BitFrom16BitSource(const UChar* source, size_t length)
 819 {
 820     if (!length)
 821         return String();
 822 
 823     LChar* destination;
 824     String result = String::createUninitialized(length, destination);
 825 
 826     copyLCharsFromUCharSource(destination, source, length);
 827 
 828     return result;
 829 }
 830 
 831 String String::make16BitFrom8BitSource(const LChar* source, size_t length)
 832 {
 833     if (!length)
 834         return String();
 835 
 836     UChar* destination;
 837     String result = String::createUninitialized(length, destination);
 838 
 839     StringImpl::copyCharacters(destination, source, length);
 840 
 841     return result;
 842 }
 843 
 844 String String::fromUTF8(const LChar* stringStart, size_t length)
 845 {
 846     if (length &gt; MaxLength)
 847         CRASH();
 848 
 849     if (!stringStart)
 850         return String();
 851 
 852     if (!length)
 853         return emptyString();
 854 
 855     if (charactersAreAllASCII(stringStart, length))
 856         return StringImpl::create(stringStart, length);
 857 
 858     Vector&lt;UChar, 1024&gt; buffer(length);
 859     UChar* bufferStart = buffer.data();
 860 
 861     UChar* bufferCurrent = bufferStart;
 862     const char* stringCurrent = reinterpret_cast&lt;const char*&gt;(stringStart);
 863     if (!convertUTF8ToUTF16(stringCurrent, reinterpret_cast&lt;const char *&gt;(stringStart + length), &amp;bufferCurrent, bufferCurrent + buffer.size()))
 864         return String();
 865 
 866     unsigned utf16Length = bufferCurrent - bufferStart;
 867     ASSERT_WITH_SECURITY_IMPLICATION(utf16Length &lt; length);
 868     return StringImpl::create(bufferStart, utf16Length);
 869 }
 870 
 871 String String::fromUTF8(const LChar* string)
 872 {
 873     if (!string)
 874         return String();
 875     return fromUTF8(string, strlen(reinterpret_cast&lt;const char*&gt;(string)));
 876 }
 877 
 878 String String::fromUTF8(const CString&amp; s)
 879 {
 880     return fromUTF8(s.data());
 881 }
 882 
 883 String String::fromUTF8WithLatin1Fallback(const LChar* string, size_t size)
 884 {
 885     String utf8 = fromUTF8(string, size);
 886     if (!utf8)
 887         return String(string, size);
 888     return utf8;
 889 }
 890 
 891 // String Operations
 892 template&lt;typename CharacterType&gt;
 893 static unsigned lengthOfCharactersAsInteger(const CharacterType* data, size_t length)
 894 {
 895     size_t i = 0;
 896 
 897     // Allow leading spaces.
 898     for (; i != length; ++i) {
 899         if (!isSpaceOrNewline(data[i]))
 900             break;
 901     }
 902 
 903     // Allow sign.
 904     if (i != length &amp;&amp; (data[i] == &#39;+&#39; || data[i] == &#39;-&#39;))
 905         ++i;
 906 
 907     // Allow digits.
 908     for (; i != length; ++i) {
 909         if (!isASCIIDigit(data[i]))
 910             break;
 911     }
 912 
 913     return i;
 914 }
 915 
 916 int charactersToIntStrict(const LChar* data, size_t length, bool* ok, int base)
 917 {
 918     return toIntegralType&lt;int, LChar&gt;(data, length, ok, base);
 919 }
 920 
 921 int charactersToIntStrict(const UChar* data, size_t length, bool* ok, int base)
 922 {
 923     return toIntegralType&lt;int, UChar&gt;(data, length, ok, base);
 924 }
 925 
 926 unsigned charactersToUIntStrict(const LChar* data, size_t length, bool* ok, int base)
 927 {
 928     return toIntegralType&lt;unsigned, LChar&gt;(data, length, ok, base);
 929 }
 930 
 931 unsigned charactersToUIntStrict(const UChar* data, size_t length, bool* ok, int base)
 932 {
 933     return toIntegralType&lt;unsigned, UChar&gt;(data, length, ok, base);
 934 }
 935 
 936 int64_t charactersToInt64Strict(const LChar* data, size_t length, bool* ok, int base)
 937 {
 938     return toIntegralType&lt;int64_t, LChar&gt;(data, length, ok, base);
 939 }
 940 
 941 int64_t charactersToInt64Strict(const UChar* data, size_t length, bool* ok, int base)
 942 {
 943     return toIntegralType&lt;int64_t, UChar&gt;(data, length, ok, base);
 944 }
 945 
 946 uint64_t charactersToUInt64Strict(const LChar* data, size_t length, bool* ok, int base)
 947 {
 948     return toIntegralType&lt;uint64_t, LChar&gt;(data, length, ok, base);
 949 }
 950 
 951 uint64_t charactersToUInt64Strict(const UChar* data, size_t length, bool* ok, int base)
 952 {
 953     return toIntegralType&lt;uint64_t, UChar&gt;(data, length, ok, base);
 954 }
 955 
 956 intptr_t charactersToIntPtrStrict(const LChar* data, size_t length, bool* ok, int base)
 957 {
 958     return toIntegralType&lt;intptr_t, LChar&gt;(data, length, ok, base);
 959 }
 960 
 961 intptr_t charactersToIntPtrStrict(const UChar* data, size_t length, bool* ok, int base)
 962 {
 963     return toIntegralType&lt;intptr_t, UChar&gt;(data, length, ok, base);
 964 }
 965 
 966 int charactersToInt(const LChar* data, size_t length, bool* ok)
 967 {
 968     return toIntegralType&lt;int, LChar&gt;(data, lengthOfCharactersAsInteger&lt;LChar&gt;(data, length), ok, 10);
 969 }
 970 
 971 int charactersToInt(const UChar* data, size_t length, bool* ok)
 972 {
 973     return toIntegralType&lt;int, UChar&gt;(data, lengthOfCharactersAsInteger(data, length), ok, 10);
 974 }
 975 
 976 unsigned charactersToUInt(const LChar* data, size_t length, bool* ok)
 977 {
 978     return toIntegralType&lt;unsigned, LChar&gt;(data, lengthOfCharactersAsInteger&lt;LChar&gt;(data, length), ok, 10);
 979 }
 980 
 981 unsigned charactersToUInt(const UChar* data, size_t length, bool* ok)
 982 {
 983     return toIntegralType&lt;unsigned, UChar&gt;(data, lengthOfCharactersAsInteger&lt;UChar&gt;(data, length), ok, 10);
 984 }
 985 
 986 int64_t charactersToInt64(const LChar* data, size_t length, bool* ok)
 987 {
 988     return toIntegralType&lt;int64_t, LChar&gt;(data, lengthOfCharactersAsInteger&lt;LChar&gt;(data, length), ok, 10);
 989 }
 990 
 991 int64_t charactersToInt64(const UChar* data, size_t length, bool* ok)
 992 {
 993     return toIntegralType&lt;int64_t, UChar&gt;(data, lengthOfCharactersAsInteger&lt;UChar&gt;(data, length), ok, 10);
 994 }
 995 
 996 uint64_t charactersToUInt64(const LChar* data, size_t length, bool* ok)
 997 {
 998     return toIntegralType&lt;uint64_t, LChar&gt;(data, lengthOfCharactersAsInteger&lt;LChar&gt;(data, length), ok, 10);
 999 }
1000 
1001 uint64_t charactersToUInt64(const UChar* data, size_t length, bool* ok)
1002 {
1003     return toIntegralType&lt;uint64_t, UChar&gt;(data, lengthOfCharactersAsInteger&lt;UChar&gt;(data, length), ok, 10);
1004 }
1005 
1006 intptr_t charactersToIntPtr(const LChar* data, size_t length, bool* ok)
1007 {
1008     return toIntegralType&lt;intptr_t, LChar&gt;(data, lengthOfCharactersAsInteger&lt;LChar&gt;(data, length), ok, 10);
1009 }
1010 
1011 intptr_t charactersToIntPtr(const UChar* data, size_t length, bool* ok)
1012 {
1013     return toIntegralType&lt;intptr_t, UChar&gt;(data, lengthOfCharactersAsInteger&lt;UChar&gt;(data, length), ok, 10);
1014 }
1015 
1016 enum TrailingJunkPolicy { DisallowTrailingJunk, AllowTrailingJunk };
1017 
1018 template&lt;typename CharacterType, TrailingJunkPolicy policy&gt;
1019 static inline double toDoubleType(const CharacterType* data, size_t length, bool* ok, size_t&amp; parsedLength)
1020 {
1021     size_t leadingSpacesLength = 0;
1022     while (leadingSpacesLength &lt; length &amp;&amp; isASCIISpace(data[leadingSpacesLength]))
1023         ++leadingSpacesLength;
1024 
1025     double number = parseDouble(data + leadingSpacesLength, length - leadingSpacesLength, parsedLength);
1026     if (!parsedLength) {
1027         if (ok)
1028             *ok = false;
1029         return 0.0;
1030     }
1031 
1032     parsedLength += leadingSpacesLength;
1033     if (ok)
1034         *ok = policy == AllowTrailingJunk || parsedLength == length;
1035     return number;
1036 }
1037 
1038 double charactersToDouble(const LChar* data, size_t length, bool* ok)
1039 {
1040     size_t parsedLength;
1041     return toDoubleType&lt;LChar, DisallowTrailingJunk&gt;(data, length, ok, parsedLength);
1042 }
1043 
1044 double charactersToDouble(const UChar* data, size_t length, bool* ok)
1045 {
1046     size_t parsedLength;
1047     return toDoubleType&lt;UChar, DisallowTrailingJunk&gt;(data, length, ok, parsedLength);
1048 }
1049 
1050 float charactersToFloat(const LChar* data, size_t length, bool* ok)
1051 {
1052     // FIXME: This will return ok even when the string fits into a double but not a float.
1053     size_t parsedLength;
1054     return static_cast&lt;float&gt;(toDoubleType&lt;LChar, DisallowTrailingJunk&gt;(data, length, ok, parsedLength));
1055 }
1056 
1057 float charactersToFloat(const UChar* data, size_t length, bool* ok)
1058 {
1059     // FIXME: This will return ok even when the string fits into a double but not a float.
1060     size_t parsedLength;
1061     return static_cast&lt;float&gt;(toDoubleType&lt;UChar, DisallowTrailingJunk&gt;(data, length, ok, parsedLength));
1062 }
1063 
1064 float charactersToFloat(const LChar* data, size_t length, size_t&amp; parsedLength)
1065 {
1066     // FIXME: This will return ok even when the string fits into a double but not a float.
1067     return static_cast&lt;float&gt;(toDoubleType&lt;LChar, AllowTrailingJunk&gt;(data, length, 0, parsedLength));
1068 }
1069 
1070 float charactersToFloat(const UChar* data, size_t length, size_t&amp; parsedLength)
1071 {
1072     // FIXME: This will return ok even when the string fits into a double but not a float.
1073     return static_cast&lt;float&gt;(toDoubleType&lt;UChar, AllowTrailingJunk&gt;(data, length, 0, parsedLength));
1074 }
1075 
1076 const String&amp; emptyString()
1077 {
1078     static NeverDestroyed&lt;String&gt; emptyString(StringImpl::empty());
1079     return emptyString;
1080 }
1081 
1082 const String&amp; nullString()
1083 {
1084     static NeverDestroyed&lt;String&gt; nullString;
1085     return nullString;
1086 }
1087 
1088 } // namespace WTF
1089 
1090 #ifndef NDEBUG
1091 
1092 // For use in the debugger.
1093 String* string(const char*);
1094 Vector&lt;char&gt; asciiDebug(StringImpl* impl);
1095 Vector&lt;char&gt; asciiDebug(String&amp; string);
1096 
1097 void String::show() const
1098 {
1099     dataLogF(&quot;%s\n&quot;, asciiDebug(impl()).data());
1100 }
1101 
1102 String* string(const char* s)
1103 {
1104     // Intentionally leaks memory!
1105     return new String(s);
1106 }
1107 
1108 Vector&lt;char&gt; asciiDebug(StringImpl* impl)
1109 {
1110     if (!impl)
1111         return asciiDebug(String(&quot;[null]&quot;_s).impl());
1112 
<a name="2" id="anc2"></a><span class="line-modified">1113     StringBuilder buffer;</span>
1114     for (unsigned i = 0; i &lt; impl-&gt;length(); ++i) {
1115         UChar ch = (*impl)[i];
1116         if (isASCIIPrintable(ch)) {
1117             if (ch == &#39;\\&#39;)
1118                 buffer.append(ch);
1119             buffer.append(ch);
1120         } else {
1121             buffer.append(&#39;\\&#39;);
1122             buffer.append(&#39;u&#39;);
<a name="3" id="anc3"></a><span class="line-modified">1123             buffer.append(hex(ch, 4));</span>
1124         }
1125     }
<a name="4" id="anc4"></a><span class="line-modified">1126     CString narrowString = buffer.toString().ascii();</span>
<span class="line-modified">1127     Vector&lt;char&gt; result;</span>
<span class="line-added">1128     result.append(reinterpret_cast&lt;const char*&gt;(narrowString.data()), narrowString.length() + 1);</span>
<span class="line-added">1129     return result;</span>
1130 }
1131 
1132 Vector&lt;char&gt; asciiDebug(String&amp; string)
1133 {
1134     return asciiDebug(string.impl());
1135 }
1136 
1137 #endif
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
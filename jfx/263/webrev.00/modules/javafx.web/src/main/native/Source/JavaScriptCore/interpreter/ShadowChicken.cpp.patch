diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/ShadowChicken.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/ShadowChicken.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/ShadowChicken.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/ShadowChicken.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2016 Apple Inc. All rights reserved.
+ * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -32,24 +32,31 @@
 #include <wtf/ListDump.h>
 
 namespace JSC {
 
 namespace ShadowChickenInternal {
-static const bool verbose = false;
+static constexpr bool verbose = false;
 }
 
 void ShadowChicken::Packet::dump(PrintStream& out) const
 {
     if (!*this) {
         out.print("empty");
         return;
     }
 
     if (isPrologue()) {
+        String name = "?"_s;
+        if (auto* function = jsDynamicCast<JSFunction*>(callee->vm(), callee)) {
+            name = function->name(callee->vm());
+            if (name.isEmpty())
+                name = "?"_s;
+        }
+
         out.print(
             "{callee = ", RawPointer(callee), ", frame = ", RawPointer(frame), ", callerFrame = ",
-            RawPointer(callerFrame), "}");
+            RawPointer(callerFrame), ", name = ", name, "}");
         return;
     }
 
     if (isTail()) {
         out.print("tail-packet:{frame = ", RawPointer(frame), "}");
@@ -60,35 +67,48 @@
     out.print("throw");
 }
 
 void ShadowChicken::Frame::dump(PrintStream& out) const
 {
+    String name = "?"_s;
+    if (auto* function = jsDynamicCast<JSFunction*>(callee->vm(), callee)) {
+        name = function->name(callee->vm());
+        if (name.isEmpty())
+            name = "?"_s;
+    }
+
     out.print(
-        "{callee = ", RawPointer(callee), ", frame = ", RawPointer(frame), ", isTailDeleted = ",
-        isTailDeleted, "}");
+        "{callee = ", *callee, ", frame = ", RawPointer(frame), ", isTailDeleted = ",
+        isTailDeleted, ", name = ", name, "}");
 }
 
 ShadowChicken::ShadowChicken()
     : m_logSize(Options::shadowChickenLogSize())
 {
-    m_log = static_cast<Packet*>(fastZeroedMalloc(sizeof(Packet) * m_logSize));
+    // Allow one additional packet beyond m_logEnd. This is useful for the moment we
+    // log a packet when the log is full and force an update. At that moment the packet
+    // that is being logged should be included in the update because it may be
+    // a critical prologue needed to rationalize the current machine stack with the
+    // shadow stack.
+    m_log = static_cast<Packet*>(fastZeroedMalloc(sizeof(Packet) * (m_logSize + 1)));
     m_logCursor = m_log;
     m_logEnd = m_log + m_logSize;
 }
 
 ShadowChicken::~ShadowChicken()
 {
     fastFree(m_log);
 }
 
-void ShadowChicken::log(VM& vm, ExecState* exec, const Packet& packet)
+void ShadowChicken::log(VM& vm, CallFrame* callFrame, const Packet& packet)
 {
-    update(vm, exec);
+    // This write is allowed because we construct the log with space for 1 additional packet.
     *m_logCursor++ = packet;
+    update(vm, callFrame);
 }
 
-void ShadowChicken::update(VM& vm, ExecState* exec)
+void ShadowChicken::update(VM& vm, CallFrame* callFrame)
 {
     if (ShadowChickenInternal::verbose) {
         dataLog("Running update on: ", *this, "\n");
         WTFReportBacktrace();
     }
@@ -99,11 +119,11 @@
     // that by figuring out how much of the shadow stack to pop. We apply three different rules. The
     // precise rule relies on the log. The log contains caller frames, which means that we know
     // where we bottomed out after making any call. If we bottomed out but made no calls then 'exec'
     // will tell us. That's why "highestPointSinceLastTime" will go no lower than exec. The third
     // rule, based on comparing to the current real stack, is executed in a later loop.
-    CallFrame* highestPointSinceLastTime = exec;
+    CallFrame* highestPointSinceLastTime = callFrame;
     for (unsigned i = logCursorIndex; i--;) {
         Packet packet = m_log[i];
         if (packet.isPrologue()) {
             CallFrame* watermark;
             if (i && m_log[i - 1].isTail())
@@ -140,23 +160,22 @@
                 break;
             }
         }
     }
 
-
     if (ShadowChickenInternal::verbose)
         dataLog("    Revised stack: ", listDump(m_stack), "\n");
 
-    // The log-based and exec-based rules require that ShadowChicken was enabled. The point of
+    // The log-based and callFrame-based rules require that ShadowChicken was enabled. The point of
     // ShadowChicken is to give sensible-looking results even if we had not logged. This means that
     // we need to reconcile the shadow stack and the real stack by actually looking at the real
     // stack. This reconciliation allows the shadow stack to have extra tail-deleted frames, but it
     // forbids it from diverging from the real stack on normal frames.
     if (!m_stack.isEmpty()) {
         Vector<Frame> stackRightNow;
         StackVisitor::visit(
-            exec, &vm, [&] (StackVisitor& visitor) -> StackVisitor::Status {
+            callFrame, vm, [&] (StackVisitor& visitor) -> StackVisitor::Status {
                 if (visitor->isInlinedFrame())
                     return StackVisitor::Continue;
                 if (visitor->isWasmFrame()) {
                     // FIXME: Make shadow chicken work with Wasm.
                     // https://bugs.webkit.org/show_bug.cgi?id=165441
@@ -273,11 +292,11 @@
         return false;
     };
 
     Vector<Frame> toPush;
     StackVisitor::visit(
-        exec, &vm, [&] (StackVisitor& visitor) -> StackVisitor::Status {
+        callFrame, vm, [&] (StackVisitor& visitor) -> StackVisitor::Status {
             if (visitor->isInlinedFrame()) {
                 // FIXME: Handle inlining.
                 // https://bugs.webkit.org/show_bug.cgi?id=155686
                 return StackVisitor::Continue;
             }
@@ -286,23 +305,33 @@
                 // FIXME: Make shadow chicken work with Wasm.
                 return StackVisitor::Continue;
             }
 
             CallFrame* callFrame = visitor->callFrame();
-            if (ShadowChickenInternal::verbose)
-                dataLog("    Examining ", RawPointer(callFrame), "\n");
+            if (ShadowChickenInternal::verbose) {
+                dataLog("    Examining callFrame:", RawPointer(callFrame), ", callee:", RawPointer(callFrame->jsCallee()), ", callerFrame:", RawPointer(callFrame->callerFrame()), "\n");
+                JSObject* callee = callFrame->jsCallee();
+                if (auto* function = jsDynamicCast<JSFunction*>(callee->vm(), callee))
+                    dataLog("      Function = ", function->name(callee->vm()), "\n");
+            }
+
             if (callFrame == highestPointSinceLastTime) {
                 if (ShadowChickenInternal::verbose)
-                    dataLog("    Bailing at ", RawPointer(callFrame), " because it's the highest point since last time.\n");
+                    dataLog("    Bailing at ", RawPointer(callFrame), " because it's the highest point since last time\n");
+
+                // FIXME: At this point the shadow stack may still have tail deleted frames
+                // that do not run into the current call frame but are left in the shadow stack.
+                // Those tail deleted frames should be validated somehow.
+
                 return StackVisitor::Done;
             }
 
             bool foundFrame = advanceIndexInLogTo(callFrame, callFrame->jsCallee(), callFrame->callerFrame());
             bool isTailDeleted = false;
             JSScope* scope = nullptr;
             CodeBlock* codeBlock = callFrame->codeBlock();
-            JSValue scopeValue = callFrame->bytecodeOffset() && codeBlock && codeBlock->scopeRegister().isValid()
+            JSValue scopeValue = callFrame->bytecodeIndex() && codeBlock && codeBlock->scopeRegister().isValid()
                 ? callFrame->registers()[codeBlock->scopeRegister().offset()].jsValue()
                 : jsUndefined();
             if (!scopeValue.isUndefined() && codeBlock->wasCompiledWithDebuggingOpcodes()) {
                 scope = jsCast<JSScope*>(scopeValue.asCell());
                 RELEASE_ASSERT(scope->inherits<JSScope>(vm));
@@ -316,11 +345,11 @@
             if (indexInLog < logCursorIndex
                 // This condition protects us from the case where advanceIndexInLogTo didn't find
                 // anything.
                 && m_log[indexInLog].frame == toPush.last().frame) {
                 if (ShadowChickenInternal::verbose)
-                    dataLog("    Going to loop through to find tail deleted frames with indexInLog = ", indexInLog, " and push-stack top = ", toPush.last(), "\n");
+                    dataLog("    Going to loop through to find tail deleted frames using ", RawPointer(callFrame), " with indexInLog = ", indexInLog, " and push-stack top = ", toPush.last(), "\n");
                 for (;;) {
                     ASSERT(m_log[indexInLog].frame == toPush.last().frame);
 
                     // Right now the index is pointing at a prologue packet of the last frame that
                     // we pushed. Peek behind that packet to see if there is a tail packet. If there
@@ -339,10 +368,14 @@
                         // https://bugs.webkit.org/show_bug.cgi?id=155687
                         break;
                     }
                     indexInLog--; // Skip over the tail packet.
 
+                    // FIXME: After a few iterations the tail packet referenced frame may not be the
+                    // same as the original callFrame for the real stack frame we started with.
+                    // It is unclear when we should break.
+
                     if (!advanceIndexInLogTo(tailPacket.frame, nullptr, nullptr)) {
                         if (ShadowChickenInternal::verbose)
                             dataLog("Can't find prologue packet for tail: ", RawPointer(tailPacket.frame), "\n");
                         // We were unable to locate the prologue packet for this tail packet.
                         // This is rare but can happen in a situation like:
@@ -377,11 +410,11 @@
         m_logCursor = m_log + 1;
     } else
         m_logCursor = m_log;
 
     if (ShadowChickenInternal::verbose)
-        dataLog("    After pushing: ", *this, "\n");
+        dataLog("    After pushing: ", listDump(m_stack), "\n");
 
     // Remove tail frames until the number of tail deleted frames is small enough.
     const unsigned maxTailDeletedFrames = Options::shadowChickenMaxTailDeletedFramesSize();
     if (m_stack.size() > maxTailDeletedFrames) {
         unsigned numberOfTailDeletedFrames = 0;
@@ -445,25 +478,25 @@
 
     CommaPrinter comma;
     unsigned limit = static_cast<unsigned>(m_logCursor - m_log);
     out.print("\n");
     for (unsigned i = 0; i < limit; ++i)
-        out.print("\t", comma, m_log[i], "\n");
+        out.print("\t", comma, "[", i, "] ", m_log[i], "\n");
     out.print("]}");
 }
 
-JSArray* ShadowChicken::functionsOnStack(ExecState* exec)
+JSArray* ShadowChicken::functionsOnStack(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
-    JSArray* result = constructEmptyArray(exec, 0);
+    JSArray* result = constructEmptyArray(globalObject, nullptr);
     RETURN_IF_EXCEPTION(scope, nullptr);
 
     iterate(
-        vm, exec,
+        vm, callFrame,
         [&] (const Frame& frame) -> bool {
-            result->push(exec, frame.callee);
+            result->push(globalObject, frame.callee);
             scope.releaseAssertNoException(); // This function is only called from tests.
             return true;
         });
 
     return result;

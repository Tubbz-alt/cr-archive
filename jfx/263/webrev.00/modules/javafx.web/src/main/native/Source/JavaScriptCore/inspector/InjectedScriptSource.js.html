<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/InjectedScriptSource.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2007, 2014-2015 Apple Inc.  All rights reserved.
   3  * Copyright (C) 2013 Google Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 //# sourceURL=__InjectedScript_InjectedScriptSource.js
  31 
  32 (function (InjectedScriptHost, inspectedGlobalObject, injectedScriptId) {
  33 
  34 // FIXME: &lt;https://webkit.org/b/152294&gt; Web Inspector: Parse InjectedScriptSource as a built-in to get guaranteed non-user-overridden built-ins
  35 
  36 var Object = {}.constructor;
  37 
  38 function toString(obj)
  39 {
  40     return String(obj);
  41 }
  42 
  43 function toStringDescription(obj)
  44 {
  45     if (obj === 0 &amp;&amp; 1 / obj &lt; 0)
  46         return &quot;-0&quot;;
  47 
  48     if (isBigInt(obj))
  49         return toString(obj) + &quot;n&quot;;
  50 
  51     return toString(obj);
  52 }
  53 
  54 function isUInt32(obj)
  55 {
  56     if (typeof obj === &quot;number&quot;)
  57         return obj &gt;&gt;&gt; 0 === obj &amp;&amp; (obj &gt; 0 || 1 / obj &gt; 0);
  58     return &quot;&quot; + (obj &gt;&gt;&gt; 0) === obj;
  59 }
  60 
  61 function isSymbol(value)
  62 {
  63     return typeof value === &quot;symbol&quot;;
  64 }
  65 
  66 function isBigInt(value)
  67 {
  68     return typeof value === &quot;bigint&quot;;
  69 }
  70 
  71 function isEmptyObject(object)
  72 {
  73     for (let key in object)
  74         return false;
  75     return true;
  76 }
  77 
  78 function isDefined(value)
  79 {
  80     return !!value || InjectedScriptHost.isHTMLAllCollection(value);
  81 }
  82 
  83 function isPrimitiveValue(value)
  84 {
  85     switch (typeof value) {
  86     case &quot;boolean&quot;:
  87     case &quot;number&quot;:
  88     case &quot;string&quot;:
  89         return true;
  90     case &quot;undefined&quot;:
  91         return !InjectedScriptHost.isHTMLAllCollection(value);
  92     default:
  93         return false;
  94     }
  95 }
  96 
  97 // -------
  98 
  99 let InjectedScript = class InjectedScript
 100 {
 101     constructor()
 102     {
 103         this._lastBoundObjectId = 1;
 104         this._idToWrappedObject = {};
 105         this._idToObjectGroupName = {};
 106         this._objectGroups = {};
 107         this._modules = {};
 108         this._nextSavedResultIndex = 1;
 109         this._savedResults = [];
 110     }
 111 
 112     // InjectedScript C++ API
 113 
 114     execute(functionString, objectGroup, includeCommandLineAPI, returnByValue, generatePreview, saveResult, args)
 115     {
 116         return this._wrapAndSaveCall(objectGroup, returnByValue, generatePreview, saveResult, () =&gt; {
 117             const isEvalOnCallFrame = false;
 118             return this._evaluateOn(InjectedScriptHost.evaluateWithScopeExtension, InjectedScriptHost, functionString, isEvalOnCallFrame, includeCommandLineAPI).apply(undefined, args);
 119         });
 120     }
 121 
 122     evaluate(expression, objectGroup, includeCommandLineAPI, returnByValue, generatePreview, saveResult)
 123     {
 124         const isEvalOnCallFrame = false;
 125         return this._evaluateAndWrap(InjectedScriptHost.evaluateWithScopeExtension, InjectedScriptHost, expression, objectGroup, isEvalOnCallFrame, includeCommandLineAPI, returnByValue, generatePreview, saveResult);
 126     }
 127 
 128     awaitPromise(promiseObjectId, returnByValue, generatePreview, saveResult, callback)
 129     {
 130         let parsedPromiseObjectId = this._parseObjectId(promiseObjectId);
 131         let promiseObject = this._objectForId(parsedPromiseObjectId);
 132         let promiseObjectGroupName = this._idToObjectGroupName[parsedPromiseObjectId.id];
 133 
 134         if (!isDefined(promiseObject)) {
 135             callback(&quot;Could not find object with given id&quot;);
 136             return;
 137         }
 138 
 139         if (!(promiseObject instanceof Promise)) {
 140             callback(&quot;Object with given id is not a Promise&quot;);
 141             return;
 142         }
 143 
 144         let resolve = (value) =&gt; {
 145             let returnObject = {
 146                 wasThrown: false,
 147                 result: RemoteObject.create(value, promiseObjectGroupName, returnByValue, generatePreview),
 148             };
 149 
 150             if (saveResult) {
 151                 this._savedResultIndex = 0;
 152                 this._saveResult(returnObject.result);
 153                 if (this._savedResultIndex)
 154                     returnObject.savedResultIndex = this._savedResultIndex;
 155             }
 156 
 157             callback(returnObject);
 158         };
 159         let reject = (reason) =&gt; {
 160             callback(this._createThrownValue(reason, promiseObjectGroupName));
 161         };
 162         promiseObject.then(resolve, reject);
 163     }
 164 
 165     evaluateOnCallFrame(topCallFrame, callFrameId, expression, objectGroup, includeCommandLineAPI, returnByValue, generatePreview, saveResult)
 166     {
 167         let callFrame = this._callFrameForId(topCallFrame, callFrameId);
 168         if (!callFrame)
 169             return &quot;Could not find call frame with given id&quot;;
 170         const isEvalOnCallFrame = true;
 171         return this._evaluateAndWrap(callFrame.evaluateWithScopeExtension, callFrame, expression, objectGroup, isEvalOnCallFrame, includeCommandLineAPI, returnByValue, generatePreview, saveResult);
 172     }
 173 
 174     callFunctionOn(objectId, expression, args, returnByValue, generatePreview)
 175     {
 176         let parsedObjectId = this._parseObjectId(objectId);
 177         let object = this._objectForId(parsedObjectId);
 178         let objectGroupName = this._idToObjectGroupName[parsedObjectId.id];
 179 
 180         if (!isDefined(object))
 181             return &quot;Could not find object with given id&quot;;
 182 
 183         let resolvedArgs = [];
 184         if (args) {
 185             let callArgs = InjectedScriptHost.evaluate(args);
 186             for (let i = 0; i &lt; callArgs.length; ++i) {
 187                 try {
 188                     resolvedArgs[i] = this._resolveCallArgument(callArgs[i]);
 189                 } catch (e) {
 190                     return String(e);
 191                 }
 192             }
 193         }
 194 
 195         try {
 196             let func = InjectedScriptHost.evaluate(&quot;(&quot; + expression + &quot;)&quot;);
 197             if (typeof func !== &quot;function&quot;)
 198                 return &quot;Given expression does not evaluate to a function&quot;;
 199 
 200             return {
 201                 wasThrown: false,
 202                 result: RemoteObject.create(func.apply(object, resolvedArgs), objectGroupName, returnByValue, generatePreview)
 203             };
 204         } catch (e) {
 205             return this._createThrownValue(e, objectGroupName);
 206         }
 207     }
 208 
 209     getFunctionDetails(objectId)
 210     {
 211         let parsedObjectId = this._parseObjectId(objectId);
 212         let object = this._objectForId(parsedObjectId);
 213         if (typeof object !== &quot;function&quot;)
 214             return &quot;Cannot resolve function by id.&quot;;
 215         return this.functionDetails(object);
 216     }
 217 
 218     functionDetails(func)
 219     {
 220         let details = InjectedScriptHost.functionDetails(func);
 221         if (!details)
 222             return &quot;Cannot resolve function details.&quot;;
 223         return details;
 224     }
 225 
 226     getPreview(objectId)
 227     {
 228         let parsedObjectId = this._parseObjectId(objectId);
 229         let object = this._objectForId(parsedObjectId);
 230         return RemoteObject.createObjectPreviewForValue(object, true);
 231     }
 232 
 233     getProperties(objectId, ownProperties, fetchStart, fetchCount, generatePreview)
 234     {
 235         let collectionMode = ownProperties ? InjectedScript.CollectionMode.OwnProperties : InjectedScript.CollectionMode.AllProperties;
 236         return this._getProperties(objectId, collectionMode, {fetchStart, fetchCount, generatePreview});
 237     }
 238 
 239     getDisplayableProperties(objectId, fetchStart, fetchCount, generatePreview)
 240     {
 241         let collectionMode = InjectedScript.CollectionMode.OwnProperties | InjectedScript.CollectionMode.NativeGetterProperties;
 242         return this._getProperties(objectId, collectionMode, {fetchStart, fetchCount, generatePreview, nativeGettersAsValues: true});
 243     }
 244 
 245     getInternalProperties(objectId, generatePreview)
 246     {
 247         let parsedObjectId = this._parseObjectId(objectId);
 248         let object = this._objectForId(parsedObjectId);
 249         let objectGroupName = this._idToObjectGroupName[parsedObjectId.id];
 250 
 251         if (!isDefined(object))
 252             return false;
 253 
 254         if (isSymbol(object))
 255             return false;
 256 
 257         let descriptors = this._internalPropertyDescriptors(object);
 258         if (!descriptors)
 259             return [];
 260 
 261         for (let i = 0; i &lt; descriptors.length; ++i) {
 262             let descriptor = descriptors[i];
 263             if (&quot;value&quot; in descriptor)
 264                 descriptor.value = RemoteObject.create(descriptor.value, objectGroupName, false, generatePreview);
 265         }
 266 
 267         return descriptors;
 268     }
 269 
 270     getCollectionEntries(objectId, objectGroupName, fetchStart, fetchCount)
 271     {
 272         let parsedObjectId = this._parseObjectId(objectId);
 273         let object = this._objectForId(parsedObjectId);
 274         objectGroupName = objectGroupName || this._idToObjectGroupName[parsedObjectId.id];
 275 
 276         if (!isDefined(object))
 277             return;
 278 
 279         if (typeof object !== &quot;object&quot;)
 280             return;
 281 
 282         let entries = this._entries(object, InjectedScriptHost.subtype(object), fetchStart, fetchCount);
 283         return entries.map(function(entry) {
 284             entry.value = RemoteObject.create(entry.value, objectGroupName, false, true);
 285             if (&quot;key&quot; in entry)
 286                 entry.key = RemoteObject.create(entry.key, objectGroupName, false, true);
 287             return entry;
 288         });
 289     }
 290 
 291     saveResult(callArgumentJSON)
 292     {
 293         this._savedResultIndex = 0;
 294 
 295         try {
 296             let callArgument = InjectedScriptHost.evaluate(&quot;(&quot; + callArgumentJSON + &quot;)&quot;);
 297             let value = this._resolveCallArgument(callArgument);
 298             this._saveResult(value);
 299         } catch { }
 300 
 301         return this._savedResultIndex;
 302     }
 303 
 304     wrapCallFrames(callFrame)
 305     {
 306         if (!callFrame)
 307             return false;
 308 
 309         let result = [];
 310         let depth = 0;
 311         do {
 312             result.push(new InjectedScript.CallFrameProxy(depth++, callFrame));
 313             callFrame = callFrame.caller;
 314         } while (callFrame);
 315         return result;
 316     }
 317 
 318     wrapObject(object, groupName, canAccessInspectedGlobalObject, generatePreview)
 319     {
 320         if (!canAccessInspectedGlobalObject)
 321             return this._fallbackWrapper(object);
 322 
 323         return RemoteObject.create(object, groupName, false, generatePreview);
 324     }
 325 
 326     wrapJSONString(jsonString, groupName, generatePreview)
 327     {
 328         try {
 329             return this.wrapObject(JSON.parse(jsonString), groupName, true, generatePreview);
 330         } catch {
 331             return null;
 332         }
 333     }
 334 
 335     wrapTable(canAccessInspectedGlobalObject, table, columns)
 336     {
 337         if (!canAccessInspectedGlobalObject)
 338             return this._fallbackWrapper(table);
 339 
 340         // FIXME: Currently columns are ignored. Instead, the frontend filters all
 341         // properties based on the provided column names and in the provided order.
 342         // We could filter here to avoid sending very large preview objects.
 343 
 344         let columnNames = null;
 345         if (typeof columns === &quot;string&quot;)
 346             columns = [columns];
 347 
 348         if (InjectedScriptHost.subtype(columns) === &quot;array&quot;) {
 349             columnNames = [];
 350             for (let i = 0; i &lt; columns.length; ++i)
 351                 columnNames.push(toString(columns[i]));
 352         }
 353 
 354         return RemoteObject.create(table, &quot;console&quot;, false, true, columnNames);
 355     }
 356 
 357     previewValue(value)
 358     {
 359         return RemoteObject.createObjectPreviewForValue(value, true);
 360     }
 361 
 362     setEventValue(value)
 363     {
 364         this._eventValue = value;
 365     }
 366 
 367     clearEventValue()
 368     {
 369         delete this._eventValue;
 370     }
 371 
 372     setExceptionValue(value)
 373     {
 374         this._exceptionValue = value;
 375     }
 376 
 377     clearExceptionValue()
 378     {
 379         delete this._exceptionValue;
 380     }
 381 
 382     findObjectById(objectId)
 383     {
 384         let parsedObjectId = this._parseObjectId(objectId);
 385         return this._objectForId(parsedObjectId);
 386     }
 387 
 388     releaseObject(objectId)
 389     {
 390         let parsedObjectId = this._parseObjectId(objectId);
 391         this._releaseObject(parsedObjectId.id);
 392     }
 393 
 394     releaseObjectGroup(objectGroupName)
 395     {
 396         if (objectGroupName === &quot;console&quot;) {
 397             delete this._lastResult;
 398             this._nextSavedResultIndex = 1;
 399             this._savedResults = [];
 400         }
 401 
 402         let group = this._objectGroups[objectGroupName];
 403         if (!group)
 404             return;
 405 
 406         for (let i = 0; i &lt; group.length; i++)
 407             this._releaseObject(group[i]);
 408 
 409         delete this._objectGroups[objectGroupName];
 410     }
 411 
 412     // CommandLineAPI
 413 
 414     inspectObject(object)
 415     {
 416         if (this._inspectObject)
 417             this._inspectObject(object);
 418     }
 419 
 420     // InjectedScriptModule C++ API
 421 
 422     hasInjectedModule(name)
 423     {
 424         return this._modules[name];
 425     }
 426 
 427     injectModule(name, source, host)
 428     {
 429         this._modules[name] = false;
 430 
 431         let moduleFunction = InjectedScriptHost.evaluate(&quot;(&quot; + source + &quot;)&quot;);
 432         if (typeof moduleFunction !== &quot;function&quot;)
 433             throw &quot;Error: Web Inspector: a function was expected for injectModule&quot;;
 434         moduleFunction(InjectedScriptHost, inspectedGlobalObject, injectedScriptId, this, {RemoteObject, CommandLineAPI}, host);
 435 
 436         this._modules[name] = true;
 437     }
 438 
 439     // InjectedScriptModule JavaScript API
 440 
 441     isPrimitiveValue(value)
 442     {
 443         return isPrimitiveValue(value);
 444     }
 445 
 446     // Private
 447 
 448     _parseObjectId(objectId)
 449     {
 450         return InjectedScriptHost.evaluate(&quot;(&quot; + objectId + &quot;)&quot;);
 451     }
 452 
 453     _objectForId(objectId)
 454     {
 455         return this._idToWrappedObject[objectId.id];
 456     }
 457 
 458     _bind(object, objectGroupName)
 459     {
 460         let id = this._lastBoundObjectId++;
 461         let objectId = `{&quot;injectedScriptId&quot;:${injectedScriptId},&quot;id&quot;:${id}}`;
 462 
 463         this._idToWrappedObject[id] = object;
 464 
 465         if (objectGroupName) {
 466             let group = this._objectGroups[objectGroupName];
 467             if (!group) {
 468                 group = [];
 469                 this._objectGroups[objectGroupName] = group;
 470             }
 471             group.push(id);
 472             this._idToObjectGroupName[id] = objectGroupName;
 473         }
 474 
 475         return objectId;
 476     }
 477 
 478     _releaseObject(id)
 479     {
 480         delete this._idToWrappedObject[id];
 481         delete this._idToObjectGroupName[id];
 482     }
 483 
 484     _fallbackWrapper(object)
 485     {
 486         let result = {};
 487         result.type = typeof object;
 488         if (isPrimitiveValue(object))
 489             result.value = object;
 490         else
 491             result.description = toStringDescription(object);
 492         return result;
 493     }
 494 
 495     _resolveCallArgument(callArgumentJSON)
 496     {
 497         if (&quot;value&quot; in callArgumentJSON)
 498             return callArgumentJSON.value;
 499 
 500         let objectId = callArgumentJSON.objectId;
 501         if (objectId) {
 502             let parsedArgId = this._parseObjectId(objectId);
 503             if (!parsedArgId || parsedArgId[&quot;injectedScriptId&quot;] !== injectedScriptId)
 504                 throw &quot;Arguments should belong to the same JavaScript world as the target object.&quot;;
 505 
 506             let resolvedArg = this._objectForId(parsedArgId);
 507             if (!isDefined(resolvedArg))
 508                 throw &quot;Could not find object with given id&quot;;
 509 
 510             return resolvedArg;
 511         }
 512 
 513         return undefined;
 514     }
 515 
 516     _createThrownValue(value, objectGroup)
 517     {
 518         let remoteObject = RemoteObject.create(value, objectGroup);
 519         try {
 520             remoteObject.description = toStringDescription(value);
 521         } catch { }
 522         return {
 523             wasThrown: true,
 524             result: remoteObject
 525         };
 526     }
 527 
 528     _evaluateAndWrap(evalFunction, object, expression, objectGroup, isEvalOnCallFrame, includeCommandLineAPI, returnByValue, generatePreview, saveResult)
 529     {
 530         return this._wrapAndSaveCall(objectGroup, returnByValue, generatePreview, saveResult, () =&gt; {
 531             return this._evaluateOn(evalFunction, object, expression, isEvalOnCallFrame, includeCommandLineAPI);
 532         });
 533     }
 534 
 535     _wrapAndSaveCall(objectGroup, returnByValue, generatePreview, saveResult, func)
 536     {
 537         return this._wrapCall(objectGroup, returnByValue, generatePreview, saveResult, () =&gt; {
 538             let result = func();
 539             if (saveResult)
 540                 this._saveResult(result);
 541             return result;
 542         });
 543     }
 544 
 545     _wrapCall(objectGroup, returnByValue, generatePreview, saveResult, func)
 546     {
 547         try {
 548             this._savedResultIndex = 0;
 549 
 550             let returnObject = {
 551                 wasThrown: false,
 552                 result: RemoteObject.create(func(), objectGroup, returnByValue, generatePreview)
 553             };
 554 
 555             if (saveResult &amp;&amp; this._savedResultIndex)
 556                 returnObject.savedResultIndex = this._savedResultIndex;
 557 
 558             return returnObject;
 559         } catch (e) {
 560             return this._createThrownValue(e, objectGroup);
 561         }
 562     }
 563 
 564     _evaluateOn(evalFunction, object, expression, isEvalOnCallFrame, includeCommandLineAPI)
 565     {
 566         let commandLineAPI = null;
 567         if (includeCommandLineAPI)
 568             commandLineAPI = new CommandLineAPI(isEvalOnCallFrame ? object : null);
 569         return evalFunction.call(object, expression, commandLineAPI);
 570     }
 571 
 572     _callFrameForId(topCallFrame, callFrameId)
 573     {
 574         let parsedCallFrameId = InjectedScriptHost.evaluate(&quot;(&quot; + callFrameId + &quot;)&quot;);
 575         let ordinal = parsedCallFrameId[&quot;ordinal&quot;];
 576         let callFrame = topCallFrame;
 577         while (--ordinal &gt;= 0 &amp;&amp; callFrame)
 578             callFrame = callFrame.caller;
 579         return callFrame;
 580     }
 581 
 582     _getProperties(objectId, collectionMode, {fetchStart, fetchCount, generatePreview, nativeGettersAsValues})
 583     {
 584         let parsedObjectId = this._parseObjectId(objectId);
 585         let object = this._objectForId(parsedObjectId);
 586         let objectGroupName = this._idToObjectGroupName[parsedObjectId.id];
 587 
 588         if (!isDefined(object))
 589             return false;
 590 
 591         if (isSymbol(object))
 592             return false;
 593 
 594         let start = fetchStart || 0;
 595         if (start &lt; 0)
 596             start = 0;
 597 
 598         let count = fetchCount || 0;
 599         if (count &lt; 0)
 600             count = 0;
 601 
 602         // Always include __proto__ at the end, but only for the first fetch.
 603         let includeProto = !start;
 604 
 605         let descriptors = [];
 606         this._forEachPropertyDescriptor(object, collectionMode, (descriptor) =&gt; {
 607             if (start &gt; 0) {
 608                 --start;
 609                 return InjectedScript.PropertyFetchAction.Continue;
 610             }
 611 
 612             if (&quot;get&quot; in descriptor)
 613                 descriptor.get = RemoteObject.create(descriptor.get, objectGroupName);
 614             if (&quot;set&quot; in descriptor)
 615                 descriptor.set = RemoteObject.create(descriptor.set, objectGroupName);
 616             if (&quot;value&quot; in descriptor)
 617                 descriptor.value = RemoteObject.create(descriptor.value, objectGroupName, false, generatePreview);
 618             if (&quot;symbol&quot; in descriptor)
 619                 descriptor.symbol = RemoteObject.create(descriptor.symbol, objectGroupName);
 620             descriptors.push(descriptor);
 621 
 622             if (includeProto &amp;&amp; count &amp;&amp; descriptors.length &gt;= count &amp;&amp; descriptor.name !== &quot;__proto__&quot;)
 623                 return InjectedScript.PropertyFetchAction.Stop;
 624 
 625             return (count &amp;&amp; descriptors.length &gt;= count) ? InjectedScript.PropertyFetchAction.Stop : InjectedScript.PropertyFetchAction.Continue;
 626         }, {nativeGettersAsValues, includeProto});
 627         return descriptors;
 628     }
 629 
 630     _internalPropertyDescriptors(object, completeDescriptor)
 631     {
 632         let internalProperties = InjectedScriptHost.getInternalProperties(object);
 633         if (!internalProperties)
 634             return null;
 635 
 636         let descriptors = [];
 637         for (let i = 0; i &lt; internalProperties.length; i++) {
 638             let property = internalProperties[i];
 639             let descriptor = {name: property.name, value: property.value};
 640             if (completeDescriptor)
 641                 descriptor.isOwn = true;
 642             descriptors.push(descriptor);
 643         }
 644         return descriptors;
 645     }
 646 
 647     _forEachPropertyDescriptor(object, collectionMode, callback, {nativeGettersAsValues, includeProto})
 648     {
 649         if (InjectedScriptHost.subtype(object) === &quot;proxy&quot;)
 650             return;
 651 
 652         let nameProcessed = new Set;
 653 
 654         // Handled below when `includeProto`.
 655         nameProcessed.add(&quot;__proto__&quot;);
 656 
 657         function createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty, possibleNativeBindingGetter)
 658         {
 659             try {
 660                 let fakeDescriptor = {name, value: object[name]};
 661                 if (descriptor) {
 662                     if (descriptor.writable)
 663                         fakeDescriptor.writable = true;
 664                     if (descriptor.configurable)
 665                         fakeDescriptor.configurable = true;
 666                     if (descriptor.enumerable)
 667                         fakeDescriptor.enumerable = true;
 668                 }
 669                 if (possibleNativeBindingGetter)
 670                     fakeDescriptor.nativeGetter = true;
 671                 if (isOwnProperty)
 672                     fakeDescriptor.isOwn = true;
 673                 if (symbol)
 674                     fakeDescriptor.symbol = symbol;
 675                 // Silence any possible unhandledrejection exceptions created from accessing a native accessor with a wrong this object.
 676                 if (fakeDescriptor.value instanceof Promise &amp;&amp; InjectedScriptHost.isPromiseRejectedWithNativeGetterTypeError(fakeDescriptor.value))
 677                     fakeDescriptor.value.catch(function(){});
 678                 return fakeDescriptor;
 679             } catch (e) {
 680                 let errorDescriptor = {name, value: e, wasThrown: true};
 681                 if (isOwnProperty)
 682                     errorDescriptor.isOwn = true;
 683                 if (symbol)
 684                     errorDescriptor.symbol = symbol;
 685                 return errorDescriptor;
 686             }
 687         }
 688 
 689         function processDescriptor(descriptor, isOwnProperty, possibleNativeBindingGetter)
 690         {
 691             // All properties.
 692             if (collectionMode &amp; InjectedScript.CollectionMode.AllProperties)
 693                 return callback(descriptor);
 694 
 695             // Own properties.
 696             if (collectionMode &amp; InjectedScript.CollectionMode.OwnProperties &amp;&amp; isOwnProperty)
 697                 return callback(descriptor);
 698 
 699             // Native Getter properties.
 700             if (collectionMode &amp; InjectedScript.CollectionMode.NativeGetterProperties) {
 701                 if (possibleNativeBindingGetter)
 702                     return callback(descriptor);
 703             }
 704         }
 705 
 706         function processProperty(o, propertyName, isOwnProperty)
 707         {
 708             if (nameProcessed.has(propertyName))
 709                 return InjectedScript.PropertyFetchAction.Continue;
 710 
 711             nameProcessed.add(propertyName);
 712 
 713             let name = toString(propertyName);
 714             let symbol = isSymbol(propertyName) ? propertyName : null;
 715 
 716             let descriptor = Object.getOwnPropertyDescriptor(o, propertyName);
 717             if (!descriptor) {
 718                 // FIXME: Bad descriptor. Can we get here?
 719                 // Fall back to very restrictive settings.
 720                 let fakeDescriptor = createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty);
 721                 return processDescriptor(fakeDescriptor, isOwnProperty);
 722             }
 723 
 724             if (nativeGettersAsValues) {
 725                 if (String(descriptor.get).endsWith(&quot;[native code]\n}&quot;) || (!descriptor.get &amp;&amp; descriptor.hasOwnProperty(&quot;get&quot;) &amp;&amp; !descriptor.set &amp;&amp; descriptor.hasOwnProperty(&quot;set&quot;))) {
 726                     // Developers may create such a descriptor, so we should be resilient:
 727                     // let x = {}; Object.defineProperty(x, &quot;p&quot;, {get:undefined}); Object.getOwnPropertyDescriptor(x, &quot;p&quot;)
 728                     let fakeDescriptor = createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty, true);
 729                     return processDescriptor(fakeDescriptor, isOwnProperty, true);
 730                 }
 731             }
 732 
 733             descriptor.name = name;
 734             if (isOwnProperty)
 735                 descriptor.isOwn = true;
 736             if (symbol)
 737                 descriptor.symbol = symbol;
 738             return processDescriptor(descriptor, isOwnProperty);
 739         }
 740 
 741         let isArrayLike = false;
 742         try {
 743             isArrayLike = RemoteObject.subtype(object) === &quot;array&quot; &amp;&amp; isFinite(object.length) &amp;&amp; object.length &gt; 0;
 744         } catch { }
 745 
 746         for (let o = object; isDefined(o); o = Object.getPrototypeOf(o)) {
 747             let isOwnProperty = o === object;
 748             let shouldBreak = false;
 749 
 750             // FIXME: &lt;https://webkit.org/b/201861&gt; Web Inspector: show autocomplete entries for non-index properties on arrays
 751             if (isArrayLike &amp;&amp; isOwnProperty) {
 752                 for (let i = 0; i &lt; o.length; ++i) {
 753                     if (!(i in o))
 754                         continue;
 755 
 756                     let result = processProperty(o, toString(i), isOwnProperty);
 757                     shouldBreak = result === InjectedScript.PropertyFetchAction.Stop;
 758                     if (shouldBreak)
 759                         break;
 760                 }
 761             } else {
 762                 let propertyNames = Object.getOwnPropertyNames(o);
 763                 for (let i = 0; i &lt; propertyNames.length; ++i) {
 764                     let result = processProperty(o, propertyNames[i], isOwnProperty);
 765                     shouldBreak = result === InjectedScript.PropertyFetchAction.Stop;
 766                     if (shouldBreak)
 767                         break;
 768                 }
 769             }
 770 
 771             if (shouldBreak)
 772                 break;
 773 
 774             if (Object.getOwnPropertySymbols) {
 775                 let propertySymbols = Object.getOwnPropertySymbols(o);
 776                 for (let i = 0; i &lt; propertySymbols.length; ++i) {
 777                     let result = processProperty(o, propertySymbols[i], isOwnProperty);
 778                     shouldBreak = result === InjectedScript.PropertyFetchAction.Stop;
 779                     if (shouldBreak)
 780                         break;
 781                 }
 782             }
 783 
 784             if (shouldBreak)
 785                 break;
 786 
 787             if (collectionMode === InjectedScript.CollectionMode.OwnProperties)
 788                 break;
 789         }
 790 
 791         if (includeProto) {
 792             try {
 793                 if (object.__proto__)
 794                     callback({name: &quot;__proto__&quot;, value: object.__proto__, writable: true, configurable: true, isOwn: true});
 795             } catch { }
 796         }
 797     }
 798 
 799     _getSetEntries(object, fetchStart, fetchCount)
 800     {
 801         let entries = [];
 802 
 803         // FIXME: This is observable if the page overrides Set.prototype[Symbol.iterator].
 804         for (let value of object) {
 805             if (fetchStart &gt; 0) {
 806                 fetchStart--;
 807                 continue;
 808             }
 809 
 810             entries.push({value});
 811 
 812             if (fetchCount &amp;&amp; entries.length === fetchCount)
 813                 break;
 814         }
 815 
 816         return entries;
 817     }
 818 
 819     _getMapEntries(object, fetchStart, fetchCount)
 820     {
 821         let entries = [];
 822 
 823         // FIXME: This is observable if the page overrides Map.prototype[Symbol.iterator].
 824         for (let [key, value] of object) {
 825             if (fetchStart &gt; 0) {
 826                 fetchStart--;
 827                 continue;
 828             }
 829 
 830             entries.push({key, value});
 831 
 832             if (fetchCount &amp;&amp; entries.length === fetchCount)
 833                 break;
 834         }
 835 
 836         return entries;
 837     }
 838 
 839     _getWeakMapEntries(object, fetchCount)
 840     {
 841         return InjectedScriptHost.weakMapEntries(object, fetchCount);
 842     }
 843 
 844     _getWeakSetEntries(object, fetchCount)
 845     {
 846         return InjectedScriptHost.weakSetEntries(object, fetchCount);
 847     }
 848 
 849     _getIteratorEntries(object, fetchCount)
 850     {
 851         return InjectedScriptHost.iteratorEntries(object, fetchCount);
 852     }
 853 
 854     _entries(object, subtype, fetchStart, fetchCount)
 855     {
 856         if (subtype === &quot;set&quot;)
 857             return this._getSetEntries(object, fetchStart, fetchCount);
 858         if (subtype === &quot;map&quot;)
 859             return this._getMapEntries(object, fetchStart, fetchCount);
 860         if (subtype === &quot;weakmap&quot;)
 861             return this._getWeakMapEntries(object, fetchCount);
 862         if (subtype === &quot;weakset&quot;)
 863             return this._getWeakSetEntries(object, fetchCount);
 864         if (subtype === &quot;iterator&quot;)
 865             return this._getIteratorEntries(object, fetchCount);
 866 
 867         throw &quot;unexpected type&quot;;
 868     }
 869 
 870     _saveResult(result)
 871     {
 872         this._lastResult = result;
 873 
 874         if (result === undefined || result === null)
 875             return;
 876 
 877         let existingIndex = this._savedResults.indexOf(result);
 878         if (existingIndex !== -1) {
 879             this._savedResultIndex = existingIndex;
 880             return;
 881         }
 882 
 883         this._savedResultIndex = this._nextSavedResultIndex;
 884         this._savedResults[this._nextSavedResultIndex++] = result;
 885 
 886         // $n is limited from $1-$99. $0 is special.
 887         if (this._nextSavedResultIndex &gt;= 100)
 888             this._nextSavedResultIndex = 1;
 889     }
 890 };
 891 
 892 InjectedScript.CollectionMode = {
 893     OwnProperties: 1 &lt;&lt; 0,          // own properties.
 894     NativeGetterProperties: 1 &lt;&lt; 1, // native getter properties in the prototype chain.
 895     AllProperties: 1 &lt;&lt; 2,          // all properties in the prototype chain.
 896 };
 897 
 898 InjectedScript.PropertyFetchAction = {
 899     Continue: Symbol(&quot;continue&quot;),
 900     Stop: Symbol(&quot;stop&quot;),
 901 }
 902 
 903 var injectedScript = new InjectedScript;
 904 
 905 // -------
 906 
 907 let RemoteObject = class RemoteObject
 908 {
 909     constructor(object, objectGroupName, forceValueType, generatePreview, columnNames)
 910     {
 911         this.type = typeof object;
 912 
 913         if (this.type === &quot;undefined&quot; &amp;&amp; InjectedScriptHost.isHTMLAllCollection(object))
 914             this.type = &quot;object&quot;;
 915 
 916         if (isPrimitiveValue(object) || isBigInt(object) || object === null || forceValueType) {
 917             // We don&#39;t send undefined values over JSON.
 918             // BigInt values are not JSON serializable.
 919             if (this.type !== &quot;undefined&quot; &amp;&amp; this.type !== &quot;bigint&quot;)
 920                 this.value = object;
 921 
 922             // Null object is object with &#39;null&#39; subtype.
 923             if (object === null)
 924                 this.subtype = &quot;null&quot;;
 925 
 926             // Provide user-friendly number values.
 927             if (this.type === &quot;number&quot; || this.type === &quot;bigint&quot;)
 928                 this.description = toStringDescription(object);
 929 
 930             return;
 931         }
 932 
 933         this.objectId = injectedScript._bind(object, objectGroupName);
 934 
 935         let subtype = RemoteObject.subtype(object);
 936         if (subtype)
 937             this.subtype = subtype;
 938 
 939         this.className = InjectedScriptHost.internalConstructorName(object);
 940         this.description = RemoteObject.describe(object);
 941 
 942         if (subtype === &quot;array&quot;)
 943             this.size = typeof object.length === &quot;number&quot; ? object.length : 0;
 944         else if (subtype === &quot;set&quot; || subtype === &quot;map&quot;)
 945             this.size = object.size;
 946         else if (subtype === &quot;weakmap&quot;)
 947             this.size = InjectedScriptHost.weakMapSize(object);
 948         else if (subtype === &quot;weakset&quot;)
 949             this.size = InjectedScriptHost.weakSetSize(object);
 950         else if (subtype === &quot;class&quot;) {
 951             this.classPrototype = RemoteObject.create(object.prototype, objectGroupName);
 952             this.className = object.name;
 953         }
 954 
 955         if (generatePreview &amp;&amp; this.type === &quot;object&quot;) {
 956             if (subtype === &quot;proxy&quot;) {
 957                 this.preview = this._generatePreview(InjectedScriptHost.proxyTargetValue(object));
 958                 this.preview.lossless = false;
 959             } else
 960                 this.preview = this._generatePreview(object, undefined, columnNames);
 961         }
 962     }
 963 
 964     // Static
 965 
 966     static create(object, objectGroupName, forceValueType, generatePreview, columnNames)
 967     {
 968         try {
 969             return new RemoteObject(object, objectGroupName, forceValueType, generatePreview, columnNames);
 970         } catch (e) {
 971             let description;
 972             try {
 973                 description = RemoteObject.describe(e);
 974             } catch (ex) {
 975                 alert(ex.message);
 976                 description = &quot;&lt;failed to convert exception to string&gt;&quot;;
 977             }
 978             return new RemoteObject(description);
 979         }
 980     }
 981 
 982     static createObjectPreviewForValue(value, generatePreview, columnNames)
 983     {
 984         let remoteObject = new RemoteObject(value, undefined, false, generatePreview, columnNames);
 985         if (remoteObject.objectId)
 986             injectedScript.releaseObject(remoteObject.objectId);
 987         if (remoteObject.classPrototype &amp;&amp; remoteObject.classPrototype.objectId)
 988             injectedScript.releaseObject(remoteObject.classPrototype.objectId);
 989         return remoteObject.preview || remoteObject._emptyPreview();
 990     }
 991 
 992     static subtype(value)
 993     {
 994         if (value === null)
 995             return &quot;null&quot;;
 996 
 997         if (isPrimitiveValue(value) || isBigInt(value) || isSymbol(value))
 998             return null;
 999 
1000         if (InjectedScriptHost.isHTMLAllCollection(value))
1001             return &quot;array&quot;;
1002 
1003         let preciseType = InjectedScriptHost.subtype(value);
1004         if (preciseType)
1005             return preciseType;
1006 
1007         // FireBug&#39;s array detection.
1008         try {
1009             if (typeof value.splice === &quot;function&quot; &amp;&amp; isFinite(value.length))
1010                 return &quot;array&quot;;
1011         } catch { }
1012 
1013         return null;
1014     }
1015 
1016     static describe(value)
1017     {
1018         if (isPrimitiveValue(value))
1019             return null;
1020 
1021         if (isBigInt(value))
1022             return null;
1023 
1024         if (isSymbol(value))
1025             return toString(value);
1026 
1027         let subtype = RemoteObject.subtype(value);
1028 
1029         if (subtype === &quot;regexp&quot;)
1030             return toString(value);
1031 
1032         if (subtype === &quot;date&quot;)
1033             return toString(value);
1034 
1035         if (subtype === &quot;error&quot;)
1036             return toString(value);
1037 
1038         if (subtype === &quot;proxy&quot;)
1039             return &quot;Proxy&quot;;
1040 
1041         if (subtype === &quot;node&quot;)
1042             return RemoteObject.nodePreview(value);
1043 
1044         let className = InjectedScriptHost.internalConstructorName(value);
1045         if (subtype === &quot;array&quot;)
1046             return className;
1047 
1048         if (subtype === &quot;iterator&quot; &amp;&amp; Symbol.toStringTag in value)
1049             return value[Symbol.toStringTag];
1050 
1051         // NodeList in JSC is a function, check for array prior to this.
1052         if (typeof value === &quot;function&quot;)
1053             return value.toString();
1054 
1055         // If Object, try for a better name from the constructor.
1056         if (className === &quot;Object&quot;) {
1057             let constructorName = value.constructor &amp;&amp; value.constructor.name;
1058             if (constructorName)
1059                 return constructorName;
1060         }
1061 
1062         return className;
1063     }
1064 
1065     static nodePreview(node)
1066     {
1067         let isXMLDocument = node.ownerDocument &amp;&amp; !!node.ownerDocument.xmlVersion;
1068         let nodeName = isXMLDocument ? node.nodeName : node.nodeName.toLowerCase();
1069 
1070         switch (node.nodeType) {
1071         case 1: // Node.ELEMENT_NODE
1072             if (node.id)
1073                 return &quot;&lt;&quot; + nodeName + &quot; id=\&quot;&quot; + node.id + &quot;\&quot;&gt;&quot;;
1074             if (node.classList.length)
1075                 return &quot;&lt;&quot; + nodeName + &quot; class=\&quot;&quot; + node.classList.toString().replace(/\s+/, &quot; &quot;) + &quot;\&quot;&gt;&quot;;
1076             if (nodeName === &quot;input&quot; &amp;&amp; node.type)
1077                 return &quot;&lt;&quot; + nodeName + &quot; type=\&quot;&quot; + node.type + &quot;\&quot;&gt;&quot;;
1078             return &quot;&lt;&quot; + nodeName + &quot;&gt;&quot;;
1079 
1080         case 3: // Node.TEXT_NODE
1081             return nodeName + &quot; \&quot;&quot; + node.nodeValue + &quot;\&quot;&quot;;
1082 
1083         case 8: // Node.COMMENT_NODE
1084             return &quot;&lt;!--&quot; + node.nodeValue + &quot;--&gt;&quot;;
1085 
1086         case 10: // Node.DOCUMENT_TYPE_NODE
1087             return &quot;&lt;!DOCTYPE &quot; + nodeName + &quot;&gt;&quot;;
1088 
1089         default:
1090             return nodeName;
1091         }
1092     }
1093 
1094     // Private
1095 
1096     _initialPreview()
1097     {
1098         let preview = {
1099             type: this.type,
1100             description: this.description || toString(this.value),
1101             lossless: true,
1102         };
1103 
1104         if (this.subtype) {
1105             preview.subtype = this.subtype;
1106             if (this.subtype !== &quot;null&quot;) {
1107                 preview.overflow = false;
1108                 preview.properties = [];
1109             }
1110         }
1111 
1112         if (&quot;size&quot; in this)
1113             preview.size = this.size;
1114 
1115         return preview;
1116     }
1117 
1118     _emptyPreview()
1119     {
1120         let preview = this._initialPreview();
1121 
1122         if (this.subtype === &quot;map&quot; || this.subtype === &quot;set&quot; || this.subtype === &quot;weakmap&quot; || this.subtype === &quot;weakset&quot; || this.subtype === &quot;iterator&quot;) {
1123             if (this.size) {
1124                 preview.entries = [];
1125                 preview.lossless = false;
1126                 preview.overflow = true;
1127             }
1128         }
1129 
1130         return preview;
1131     }
1132 
1133     _generatePreview(object, firstLevelKeys, secondLevelKeys)
1134     {
1135         let preview = this._initialPreview();
1136         let isTableRowsRequest = secondLevelKeys === null || secondLevelKeys;
1137         let firstLevelKeysCount = firstLevelKeys ? firstLevelKeys.length : 0;
1138 
1139         let propertiesThreshold = {
1140             properties: isTableRowsRequest ? 1000 : Math.max(5, firstLevelKeysCount),
1141             indexes: isTableRowsRequest ? 1000 : Math.max(10, firstLevelKeysCount)
1142         };
1143 
1144         try {
1145             // Maps, Sets, and Iterators have entries.
1146             if (this.subtype === &quot;map&quot; || this.subtype === &quot;set&quot; || this.subtype === &quot;weakmap&quot; || this.subtype === &quot;weakset&quot; || this.subtype === &quot;iterator&quot;)
1147                 this._appendEntryPreviews(object, preview);
1148 
1149             preview.properties = [];
1150 
1151             // Internal Properties.
1152             let internalPropertyDescriptors = injectedScript._internalPropertyDescriptors(object, true);
1153             if (internalPropertyDescriptors) {
1154                 for (let i = 0; i &lt; internalPropertyDescriptors.length; ++i) {
1155                     let result = this._appendPropertyPreview(object, preview, internalPropertyDescriptors[i], propertiesThreshold, firstLevelKeys, secondLevelKeys, {internal: true});
1156                     if (result === InjectedScript.PropertyFetchAction.Stop)
1157                         return preview;
1158                 }
1159             }
1160 
1161             if (preview.entries)
1162                 return preview;
1163 
1164             // Properties.
1165             injectedScript._forEachPropertyDescriptor(object, InjectedScript.CollectionMode.AllProperties, (descriptor) =&gt; {
1166                 return this._appendPropertyPreview(object, preview, descriptor, propertiesThreshold, firstLevelKeys, secondLevelKeys);
1167             }, {nativeGettersAsValues: true, includeProto: true})
1168         } catch {
1169             preview.lossless = false;
1170         }
1171 
1172         return preview;
1173     }
1174 
1175     _appendPropertyPreview(object, preview, descriptor, propertiesThreshold, firstLevelKeys, secondLevelKeys, {internal} = {})
1176     {
1177         // Error in descriptor.
1178         if (descriptor.wasThrown) {
1179             preview.lossless = false;
1180             return InjectedScript.PropertyFetchAction.Continue;
1181         }
1182 
1183         // Do not show &quot;__proto__&quot; in preview.
1184         let name = descriptor.name;
1185         if (name === &quot;__proto__&quot;) {
1186             // Non basic __proto__ objects may have interesting, non-enumerable, methods to show.
1187             if (descriptor.value &amp;&amp; descriptor.value.constructor
1188                 &amp;&amp; descriptor.value.constructor !== Object
1189                 &amp;&amp; descriptor.value.constructor !== Array
1190                 &amp;&amp; descriptor.value.constructor !== RegExp)
1191                 preview.lossless = false;
1192             return InjectedScript.PropertyFetchAction.Continue;
1193         }
1194 
1195         // For arrays, only allow indexes.
1196         if (this.subtype === &quot;array&quot; &amp;&amp; !isUInt32(name))
1197             return InjectedScript.PropertyFetchAction.Continue;
1198 
1199         // Do not show non-enumerable non-own properties.
1200         // Special case to allow array indexes that may be on the prototype.
1201         // Special case to allow native getters on non-RegExp objects.
1202         if (!descriptor.enumerable &amp;&amp; !descriptor.isOwn &amp;&amp; !(this.subtype === &quot;array&quot; || (this.subtype !== &quot;regexp&quot; &amp;&amp; descriptor.nativeGetter)))
1203             return InjectedScript.PropertyFetchAction.Continue;
1204 
1205         // If we have a filter, only show properties in the filter.
1206         // FIXME: Currently these filters do nothing on the backend.
1207         if (firstLevelKeys &amp;&amp; !firstLevelKeys.includes(name))
1208             return InjectedScript.PropertyFetchAction.Continue;
1209 
1210         function appendPreview(property) {
1211             if (toString(property.name &gt;&gt;&gt; 0) === property.name)
1212                 propertiesThreshold.indexes--;
1213             else
1214                 propertiesThreshold.properties--;
1215 
1216             if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0) {
1217                 preview.overflow = true;
1218                 preview.lossless = false;
1219                 return InjectedScript.PropertyFetchAction.Stop;
1220             }
1221 
1222             if (internal)
1223                 property.internal = true;
1224 
1225             preview.properties.push(property);
1226             return InjectedScript.PropertyFetchAction.Continue;
1227         }
1228 
1229         // Getter/setter.
1230         if (!(&quot;value&quot; in descriptor)) {
1231             preview.lossless = false;
1232             return appendPreview({name, type: &quot;accessor&quot;});
1233         }
1234 
1235         // Null value.
1236         let value = descriptor.value;
1237         if (value === null)
1238             return appendPreview({name, type: &quot;object&quot;, subtype: &quot;null&quot;, value: &quot;null&quot;});
1239 
1240         // Ignore non-enumerable functions.
1241         let type = typeof value;
1242         if (!descriptor.enumerable &amp;&amp; type === &quot;function&quot;)
1243             return InjectedScript.PropertyFetchAction.Continue;
1244 
1245         // Fix type of document.all.
1246         if (InjectedScriptHost.isHTMLAllCollection(value))
1247             type = &quot;object&quot;;
1248 
1249         // Primitive.
1250         const maxLength = 100;
1251         if (isPrimitiveValue(value) || isBigInt(value)) {
1252             if (type === &quot;string&quot; &amp;&amp; value.length &gt; maxLength) {
1253                 value = this._abbreviateString(value, maxLength, true);
1254                 preview.lossless = false;
1255             }
1256             return appendPreview({name, type, value: toStringDescription(value)});
1257         }
1258 
1259         // Symbol.
1260         if (isSymbol(value)) {
1261             let symbolString = toString(value);
1262             if (symbolString.length &gt; maxLength) {
1263                 symbolString = this._abbreviateString(symbolString, maxLength, true);
1264                 preview.lossless = false;
1265             }
1266             return appendPreview({name, type, value: symbolString});
1267         }
1268 
1269         // Object.
1270         let property = {name, type};
1271         let subtype = RemoteObject.subtype(value);
1272         if (subtype)
1273             property.subtype = subtype;
1274 
1275         // Second level.
1276         if ((secondLevelKeys === null || secondLevelKeys) || this._isPreviewableObject(value, object)) {
1277             // FIXME: If we want secondLevelKeys filter to continue we would need some refactoring.
1278             let subPreview = RemoteObject.createObjectPreviewForValue(value, value !== object, secondLevelKeys);
1279             property.valuePreview = subPreview;
1280             if (!subPreview.lossless)
1281                 preview.lossless = false;
1282             if (subPreview.overflow)
1283                 preview.overflow = true;
1284         } else {
1285             let description = &quot;&quot;;
1286             if (type !== &quot;function&quot; || subtype === &quot;class&quot;) {
1287                 let fullDescription;
1288                 if (subtype === &quot;class&quot;)
1289                     fullDescription = &quot;class &quot; + value.name;
1290                 else if (subtype === &quot;node&quot;)
1291                     fullDescription = RemoteObject.nodePreview(value);
1292                 else
1293                     fullDescription = RemoteObject.describe(value);
1294                 description = this._abbreviateString(fullDescription, maxLength, subtype === &quot;regexp&quot;);
1295             }
1296             property.value = description;
1297             preview.lossless = false;
1298         }
1299 
1300         return appendPreview(property);
1301     }
1302 
1303     _appendEntryPreviews(object, preview)
1304     {
1305         // Fetch 6, but only return 5, so we can tell if we overflowed.
1306         let entries = injectedScript._entries(object, this.subtype, 0, 6);
1307         if (!entries)
1308             return;
1309 
1310         if (entries.length &gt; 5) {
1311             entries.pop();
1312             preview.overflow = true;
1313             preview.lossless = false;
1314         }
1315 
1316         function updateMainPreview(subPreview) {
1317             if (!subPreview.lossless)
1318                 preview.lossless = false;
1319         }
1320 
1321         preview.entries = entries.map(function(entry) {
1322             entry.value = RemoteObject.createObjectPreviewForValue(entry.value, entry.value !== object);
1323             updateMainPreview(entry.value);
1324             if (&quot;key&quot; in entry) {
1325                 entry.key = RemoteObject.createObjectPreviewForValue(entry.key, entry.key !== object);
1326                 updateMainPreview(entry.key);
1327             }
1328             return entry;
1329         });
1330     }
1331 
1332     _isPreviewableObject(value, object)
1333     {
1334         let set = new Set;
1335         set.add(object);
1336 
1337         return this._isPreviewableObjectInternal(value, set, 1);
1338     }
1339 
1340     _isPreviewableObjectInternal(object, knownObjects, depth)
1341     {
1342         // Deep object.
1343         if (depth &gt; 3)
1344             return false;
1345 
1346         // Primitive.
1347         if (isPrimitiveValue(object) || isBigInt(object) || isSymbol(object))
1348             return true;
1349 
1350         // Null.
1351         if (object === null)
1352             return true;
1353 
1354         // Cyclic objects.
1355         if (knownObjects.has(object))
1356             return false;
1357 
1358         ++depth;
1359         knownObjects.add(object);
1360 
1361         // Arrays are simple if they have 5 or less simple objects.
1362         let subtype = RemoteObject.subtype(object);
1363         if (subtype === &quot;array&quot;) {
1364             let length = object.length;
1365             if (length &gt; 5)
1366                 return false;
1367             for (let i = 0; i &lt; length; ++i) {
1368                 if (!this._isPreviewableObjectInternal(object[i], knownObjects, depth))
1369                     return false;
1370             }
1371             return true;
1372         }
1373 
1374         // Not a basic object.
1375         if (object.__proto__ &amp;&amp; object.__proto__.__proto__)
1376             return false;
1377 
1378         // Objects are simple if they have 3 or less simple value properties.
1379         let ownPropertyNames = Object.getOwnPropertyNames(object);
1380         if (ownPropertyNames.length &gt; 3)
1381             return false;
1382         for (let i = 0; i &lt; ownPropertyNames.length; ++i) {
1383             let propertyName = ownPropertyNames[i];
1384             let descriptor = Object.getOwnPropertyDescriptor(object, propertyName);
1385             if (descriptor &amp;&amp; !(&quot;value&quot; in descriptor))
1386                 return false;
1387             if (!this._isPreviewableObjectInternal(object[propertyName], knownObjects, depth))
1388                 return false;
1389         }
1390 
1391         return true;
1392     }
1393 
1394     _abbreviateString(string, maxLength, middle)
1395     {
1396         if (string.length &lt;= maxLength)
1397             return string;
1398 
1399         if (middle) {
1400             let leftHalf = maxLength &gt;&gt; 1;
1401             let rightHalf = maxLength - leftHalf - 1;
1402             return string.substr(0, leftHalf) + &quot;\u2026&quot; + string.substr(string.length - rightHalf, rightHalf);
1403         }
1404 
1405         return string.substr(0, maxLength) + &quot;\u2026&quot;;
1406     }
1407 };
1408 
1409 // -------
1410 
1411 InjectedScript.CallFrameProxy = function(ordinal, callFrame)
1412 {
1413     this.callFrameId = `{&quot;ordinal&quot;:${ordinal},&quot;injectedScriptId&quot;:${injectedScriptId}}`;
1414     this.functionName = callFrame.functionName;
1415     this.location = {scriptId: String(callFrame.sourceID), lineNumber: callFrame.line, columnNumber: callFrame.column};
1416     this.scopeChain = this._wrapScopeChain(callFrame);
1417     this.this = RemoteObject.create(callFrame.thisObject, &quot;backtrace&quot;);
1418     this.isTailDeleted = callFrame.isTailDeleted;
1419 };
1420 
1421 InjectedScript.CallFrameProxy.prototype = {
1422     _wrapScopeChain(callFrame)
1423     {
1424         let scopeChain = callFrame.scopeChain;
1425         let scopeDescriptions = callFrame.scopeDescriptions();
1426 
1427         let scopeChainProxy = [];
1428         for (let i = 0; i &lt; scopeChain.length; i++)
1429             scopeChainProxy[i] = InjectedScript.CallFrameProxy._createScopeJson(scopeChain[i], scopeDescriptions[i], &quot;backtrace&quot;);
1430         return scopeChainProxy;
1431     }
1432 };
1433 
1434 InjectedScript.CallFrameProxy._scopeTypeNames = {
1435     0: &quot;global&quot;, // GLOBAL_SCOPE
1436     1: &quot;with&quot;, // WITH_SCOPE
1437     2: &quot;closure&quot;, // CLOSURE_SCOPE
1438     3: &quot;catch&quot;, // CATCH_SCOPE
1439     4: &quot;functionName&quot;, // FUNCTION_NAME_SCOPE
1440     5: &quot;globalLexicalEnvironment&quot;, // GLOBAL_LEXICAL_ENVIRONMENT_SCOPE
1441     6: &quot;nestedLexical&quot;, // NESTED_LEXICAL_SCOPE
1442 };
1443 
1444 InjectedScript.CallFrameProxy._createScopeJson = function(object, {name, type, location}, groupId)
1445 {
1446     let scope = {
1447         object: RemoteObject.create(object, groupId),
1448         type: InjectedScript.CallFrameProxy._scopeTypeNames[type],
1449     };
1450 
1451     if (name)
1452         scope.name = name;
1453 
1454     if (location)
1455         scope.location = location;
1456 
1457     if (isEmptyObject(object))
1458         scope.empty = true;
1459 
1460     return scope;
1461 }
1462 
1463 // -------
1464 
1465 function CommandLineAPI(callFrame)
1466 {
1467     let savedResultAlias = InjectedScriptHost.savedResultAlias;
1468 
1469     let defineGetter = (key, value, wrap) =&gt; {
1470         if (wrap) {
1471             let originalValue = value;
1472             value = function() { return originalValue; };
1473         }
1474 
1475         this.__defineGetter__(&quot;$&quot; + key, value);
1476         if (savedResultAlias &amp;&amp; savedResultAlias !== &quot;$&quot;)
1477             this.__defineGetter__(savedResultAlias + key, value);
1478     };
1479 
1480     if (&quot;_lastResult&quot; in injectedScript)
1481         defineGetter(&quot;_&quot;, injectedScript._lastResult, true);
1482 
1483     if (&quot;_exceptionValue&quot; in injectedScript)
1484         defineGetter(&quot;exception&quot;, injectedScript._exceptionValue, true);
1485 
1486     if (&quot;_eventValue&quot; in injectedScript)
1487         defineGetter(&quot;event&quot;, injectedScript._eventValue, true);
1488 
1489     // $1-$99
1490     for (let i = 1; i &lt; injectedScript._savedResults.length; ++i)
1491         defineGetter(i, injectedScript._savedResults[i], true);
1492 
1493     for (let name in CommandLineAPI.getters)
1494         defineGetter(name, CommandLineAPI.getters[name]);
1495 
1496     for (let name in CommandLineAPI.methods)
1497         this[name] = CommandLineAPI.methods[name];
1498 }
1499 
1500 CommandLineAPI.getters = {};
1501 
1502 CommandLineAPI.methods = {};
1503 
1504 CommandLineAPI.methods[&quot;keys&quot;] = function(object) { return Object.keys(object); };
1505 CommandLineAPI.methods[&quot;values&quot;] = function(object) { return Object.values(object); };
1506 
1507 CommandLineAPI.methods[&quot;queryInstances&quot;] = function() { return InjectedScriptHost.queryInstances(...arguments); };
1508 CommandLineAPI.methods[&quot;queryObjects&quot;] = function() { return InjectedScriptHost.queryInstances(...arguments); };
1509 CommandLineAPI.methods[&quot;queryHolders&quot;] = function() { return InjectedScriptHost.queryHolders(...arguments); };
1510 
1511 CommandLineAPI.methods[&quot;inspect&quot;] = function(object) { return injectedScript.inspectObject(object); };
1512 
1513 CommandLineAPI.methods[&quot;assert&quot;] = function() { return inspectedGlobalObject.console.assert(...arguments); };
1514 CommandLineAPI.methods[&quot;clear&quot;] = function() { return inspectedGlobalObject.console.clear(...arguments); };
1515 CommandLineAPI.methods[&quot;count&quot;] = function() { return inspectedGlobalObject.console.count(...arguments); };
1516 CommandLineAPI.methods[&quot;countReset&quot;] = function() { return inspectedGlobalObject.console.countReset(...arguments); };
1517 CommandLineAPI.methods[&quot;debug&quot;] = function() { return inspectedGlobalObject.console.debug(...arguments); };
1518 CommandLineAPI.methods[&quot;dir&quot;] = function() { return inspectedGlobalObject.console.dir(...arguments); };
1519 CommandLineAPI.methods[&quot;dirxml&quot;] = function() { return inspectedGlobalObject.console.dirxml(...arguments); };
1520 CommandLineAPI.methods[&quot;error&quot;] = function() { return inspectedGlobalObject.console.error(...arguments); };
1521 CommandLineAPI.methods[&quot;group&quot;] = function() { return inspectedGlobalObject.console.group(...arguments); };
1522 CommandLineAPI.methods[&quot;groupCollapsed&quot;] = function() { return inspectedGlobalObject.console.groupCollapsed(...arguments); };
1523 CommandLineAPI.methods[&quot;groupEnd&quot;] = function() { return inspectedGlobalObject.console.groupEnd(...arguments); };
1524 CommandLineAPI.methods[&quot;info&quot;] = function() { return inspectedGlobalObject.console.info(...arguments); };
1525 CommandLineAPI.methods[&quot;log&quot;] = function() { return inspectedGlobalObject.console.log(...arguments); };
1526 CommandLineAPI.methods[&quot;profile&quot;] = function() { return inspectedGlobalObject.console.profile(...arguments); };
1527 CommandLineAPI.methods[&quot;profileEnd&quot;] = function() { return inspectedGlobalObject.console.profileEnd(...arguments); };
1528 CommandLineAPI.methods[&quot;record&quot;] = function() { return inspectedGlobalObject.console.record(...arguments); };
1529 CommandLineAPI.methods[&quot;recordEnd&quot;] = function() { return inspectedGlobalObject.console.recordEnd(...arguments); };
1530 CommandLineAPI.methods[&quot;screenshot&quot;] = function() { return inspectedGlobalObject.console.screenshot(...arguments); };
1531 CommandLineAPI.methods[&quot;table&quot;] = function() { return inspectedGlobalObject.console.table(...arguments); };
1532 CommandLineAPI.methods[&quot;takeHeapSnapshot&quot;] = function() { return inspectedGlobalObject.console.takeHeapSnapshot(...arguments); };
1533 CommandLineAPI.methods[&quot;time&quot;] = function() { return inspectedGlobalObject.console.time(...arguments); };
1534 CommandLineAPI.methods[&quot;timeEnd&quot;] = function() { return inspectedGlobalObject.console.timeEnd(...arguments); };
1535 CommandLineAPI.methods[&quot;timeLog&quot;] = function() { return inspectedGlobalObject.console.timeLog(...arguments); };
1536 CommandLineAPI.methods[&quot;timeStamp&quot;] = function() { return inspectedGlobalObject.console.timeStamp(...arguments); };
1537 CommandLineAPI.methods[&quot;trace&quot;] = function() { return inspectedGlobalObject.console.trace(...arguments); };
1538 CommandLineAPI.methods[&quot;warn&quot;] = function() { return inspectedGlobalObject.console.warn(...arguments); };
1539 
1540 for (let name in CommandLineAPI.methods)
1541     CommandLineAPI.methods[name].toString = function() { return &quot;function &quot; + name + &quot;() { [Command Line API] }&quot;; };
1542 
1543 return injectedScript;
1544 })
    </pre>
  </body>
</html>
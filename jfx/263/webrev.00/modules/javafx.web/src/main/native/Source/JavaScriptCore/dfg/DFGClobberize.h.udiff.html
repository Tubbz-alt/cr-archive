<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGClobberize.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGCapabilities.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGClobbersExitState.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGClobberize.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -33,11 +33,10 @@</span>
  #include &quot;DFGLazyNode.h&quot;
  #include &quot;DFGPureValue.h&quot;
  #include &quot;DOMJITCallDOMGetterSnippet.h&quot;
  #include &quot;DOMJITSignature.h&quot;
  #include &quot;InlineCallFrame.h&quot;
<span class="udiff-line-removed">- #include &quot;JSFixedArray.h&quot;</span>
  #include &quot;JSImmutableButterfly.h&quot;
  
  namespace JSC { namespace DFG {
  
  template&lt;typename ReadFunctor, typename WriteFunctor, typename DefFunctor&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -110,13 +109,13 @@</span>
      // by calls into the runtime. For debugging we might replace the implementation of any node with a call
      // to the runtime, and that call may walk stack. Therefore, each node must read() anything that a stack
      // scan would read. That&#39;s what this does.
      for (InlineCallFrame* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame(); inlineCallFrame; inlineCallFrame = inlineCallFrame-&gt;directCaller.inlineCallFrame()) {
          if (inlineCallFrame-&gt;isClosureCall)
<span class="udiff-line-modified-removed">-             read(AbstractHeap(Stack, inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee));</span>
<span class="udiff-line-modified-added">+             read(AbstractHeap(Stack, VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee)));</span>
          if (inlineCallFrame-&gt;isVarargs())
<span class="udiff-line-modified-removed">-             read(AbstractHeap(Stack, inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount));</span>
<span class="udiff-line-modified-added">+             read(AbstractHeap(Stack, VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCountIncludingThis)));</span>
      }
  
      // We don&#39;t want to specifically account which nodes can read from the scope
      // when the debugger is enabled. It&#39;s helpful to just claim all nodes do.
      // Specifically, if a node allocates, this may call into the debugger&#39;s machinery.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -166,10 +165,11 @@</span>
      case ArithPow:
      case GetScope:
      case SkipScope:
      case GetGlobalObject:
      case StringCharCodeAt:
<span class="udiff-line-added">+     case StringCodePointAt:</span>
      case CompareStrictEq:
      case SameValue:
      case IsEmpty:
      case IsUndefined:
      case IsUndefinedOrNull:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -279,11 +279,11 @@</span>
  
      case ArithBitAnd:
      case ArithBitOr:
      case ArithBitXor:
      case ArithBitLShift:
<span class="udiff-line-modified-removed">-     case BitRShift:</span>
<span class="udiff-line-modified-added">+     case ArithBitRShift:</span>
      case BitURShift:
          if (node-&gt;child1().useKind() == UntypedUse || node-&gt;child2().useKind() == UntypedUse) {
              read(World);
              write(Heap);
              return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -430,20 +430,20 @@</span>
  
      case AssertNotEmpty:
          write(SideState);
          return;
  
<span class="udiff-line-modified-removed">-     case CheckStringIdent:</span>
<span class="udiff-line-modified-removed">-         def(PureValue(CheckStringIdent, AdjacencyList(AdjacencyList::Fixed, node-&gt;child1()), node-&gt;uidOperand()));</span>
<span class="udiff-line-modified-added">+     case CheckIdent:</span>
<span class="udiff-line-modified-added">+         def(PureValue(CheckIdent, AdjacencyList(AdjacencyList::Fixed, node-&gt;child1()), node-&gt;uidOperand()));</span>
          return;
  
      case ConstantStoragePointer:
          def(PureValue(node, node-&gt;storagePointer()));
          return;
  
      case KillStack:
<span class="udiff-line-modified-removed">-         write(AbstractHeap(Stack, node-&gt;unlinkedLocal()));</span>
<span class="udiff-line-modified-added">+         write(AbstractHeap(Stack, node-&gt;unlinkedOperand()));</span>
          return;
  
      case MovHint:
      case ZombieHint:
      case ExitOK:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -468,11 +468,11 @@</span>
      case ProfileType:
      case ProfileControlFlow:
      case PutHint:
      case InitializeEntrypointArguments:
      case FilterCallLinkStatus:
<span class="udiff-line-modified-removed">-     case FilterGetByIdStatus:</span>
<span class="udiff-line-modified-added">+     case FilterGetByStatus:</span>
      case FilterPutByIdStatus:
      case FilterInByIdStatus:
          write(SideState);
          return;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -495,11 +495,11 @@</span>
          write(SideState);
          def(HeapLocation(InvalidationPointLoc, Watchpoint_fire), LazyNode(node));
          return;
  
      case Flush:
<span class="udiff-line-modified-removed">-         read(AbstractHeap(Stack, node-&gt;local()));</span>
<span class="udiff-line-modified-added">+         read(AbstractHeap(Stack, node-&gt;operand()));</span>
          write(SideState);
          return;
  
      case NotifyWrite:
          write(Watchpoint_fire);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -522,10 +522,11 @@</span>
      }
  
      case CreateDirectArguments:
      case CreateScopedArguments:
      case CreateClonedArguments:
<span class="udiff-line-added">+     case CreateArgumentsButterfly:</span>
          read(Stack);
          read(HeapObjectCount);
          write(HeapObjectCount);
          return;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -646,10 +647,11 @@</span>
      case TailCallVarargsInlinedCaller:
      case TailCallForwardVarargsInlinedCaller:
      case ConstructVarargs:
      case ConstructForwardVarargs:
      case ToPrimitive:
<span class="udiff-line-added">+     case ToPropertyKey:</span>
      case InByVal:
      case InById:
      case HasOwnProperty:
      case ValueNegate:
      case SetFunctionName:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -662,29 +664,51 @@</span>
      case HasStructureProperty:
      case GetPropertyEnumerator:
      case GetDirectPname:
      case InstanceOfCustom:
      case ToNumber:
<span class="udiff-line-added">+     case ToNumeric:</span>
      case NumberToStringWithRadix:
      case CreateThis:
<span class="udiff-line-added">+     case CreatePromise:</span>
<span class="udiff-line-added">+     case CreateGenerator:</span>
<span class="udiff-line-added">+     case CreateAsyncGenerator:</span>
      case InstanceOf:
      case StringValueOf:
      case ObjectKeys:
          read(World);
          write(Heap);
          return;
  
<span class="udiff-line-added">+     case Inc:</span>
<span class="udiff-line-added">+     case Dec:</span>
<span class="udiff-line-added">+         switch (node-&gt;child1().useKind()) {</span>
<span class="udiff-line-added">+         case Int32Use:</span>
<span class="udiff-line-added">+         case Int52RepUse:</span>
<span class="udiff-line-added">+         case DoubleRepUse:</span>
<span class="udiff-line-added">+         case BigIntUse:</span>
<span class="udiff-line-added">+             def(PureValue(node));</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         case UntypedUse:</span>
<span class="udiff-line-added">+             read(World);</span>
<span class="udiff-line-added">+             write(Heap);</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         default:</span>
<span class="udiff-line-added">+             DFG_CRASH(graph, node, &quot;Bad use kind&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
      case ValueBitAnd:
      case ValueBitXor:
      case ValueBitOr:
      case ValueAdd:
      case ValueSub:
      case ValueMul:
      case ValueDiv:
      case ValueMod:
      case ValuePow:
      case ValueBitLShift:
<span class="udiff-line-added">+     case ValueBitRShift:</span>
          if (node-&gt;isBinaryUseKind(BigIntUse)) {
              def(PureValue(node));
              return;
          }
          read(World);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -714,11 +738,11 @@</span>
      }
  
      case CallEval:
          ASSERT(!node-&gt;origin.semantic.inlineCallFrame());
          read(AbstractHeap(Stack, graph.m_codeBlock-&gt;scopeRegister()));
<span class="udiff-line-modified-removed">-         read(AbstractHeap(Stack, virtualRegisterForArgument(0)));</span>
<span class="udiff-line-modified-added">+         read(AbstractHeap(Stack, virtualRegisterForArgumentIncludingThis(0)));</span>
          read(World);
          write(Heap);
          return;
  
      case Throw:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -740,75 +764,81 @@</span>
          read(GetterSetter_setter);
          def(HeapLocation(SetterLoc, GetterSetter_setter, node-&gt;child1()), LazyNode(node));
          return;
  
      case GetCallee:
<span class="udiff-line-modified-removed">-         read(AbstractHeap(Stack, CallFrameSlot::callee));</span>
<span class="udiff-line-modified-removed">-         def(HeapLocation(StackLoc, AbstractHeap(Stack, CallFrameSlot::callee)), LazyNode(node));</span>
<span class="udiff-line-modified-added">+         read(AbstractHeap(Stack, VirtualRegister(CallFrameSlot::callee)));</span>
<span class="udiff-line-modified-added">+         def(HeapLocation(StackLoc, AbstractHeap(Stack, VirtualRegister(CallFrameSlot::callee))), LazyNode(node));</span>
          return;
  
      case SetCallee:
<span class="udiff-line-modified-removed">-         write(AbstractHeap(Stack, CallFrameSlot::callee));</span>
<span class="udiff-line-modified-added">+         write(AbstractHeap(Stack, VirtualRegister(CallFrameSlot::callee)));</span>
          return;
  
      case GetArgumentCountIncludingThis: {
<span class="udiff-line-modified-removed">-         auto heap = AbstractHeap(Stack, remapOperand(node-&gt;argumentsInlineCallFrame(), VirtualRegister(CallFrameSlot::argumentCount)));</span>
<span class="udiff-line-modified-added">+         auto heap = AbstractHeap(Stack, remapOperand(node-&gt;argumentsInlineCallFrame(), VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
          read(heap);
          def(HeapLocation(StackPayloadLoc, heap), LazyNode(node));
          return;
      }
  
      case SetArgumentCountIncludingThis:
<span class="udiff-line-modified-removed">-         write(AbstractHeap(Stack, CallFrameSlot::argumentCount));</span>
<span class="udiff-line-modified-added">+         write(AbstractHeap(Stack, VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
          return;
  
      case GetRestLength:
          read(Stack);
          return;
  
      case GetLocal:
<span class="udiff-line-modified-removed">-         read(AbstractHeap(Stack, node-&gt;local()));</span>
<span class="udiff-line-modified-removed">-         def(HeapLocation(StackLoc, AbstractHeap(Stack, node-&gt;local())), LazyNode(node));</span>
<span class="udiff-line-modified-added">+         read(AbstractHeap(Stack, node-&gt;operand()));</span>
<span class="udiff-line-modified-added">+         def(HeapLocation(StackLoc, AbstractHeap(Stack, node-&gt;operand())), LazyNode(node));</span>
          return;
  
      case SetLocal:
<span class="udiff-line-modified-removed">-         write(AbstractHeap(Stack, node-&gt;local()));</span>
<span class="udiff-line-modified-removed">-         def(HeapLocation(StackLoc, AbstractHeap(Stack, node-&gt;local())), LazyNode(node-&gt;child1().node()));</span>
<span class="udiff-line-modified-added">+         write(AbstractHeap(Stack, node-&gt;operand()));</span>
<span class="udiff-line-modified-added">+         def(HeapLocation(StackLoc, AbstractHeap(Stack, node-&gt;operand())), LazyNode(node-&gt;child1().node()));</span>
          return;
  
      case GetStack: {
<span class="udiff-line-modified-removed">-         AbstractHeap heap(Stack, node-&gt;stackAccessData()-&gt;local);</span>
<span class="udiff-line-modified-added">+         AbstractHeap heap(Stack, node-&gt;stackAccessData()-&gt;operand);</span>
          read(heap);
          def(HeapLocation(StackLoc, heap), LazyNode(node));
          return;
      }
  
      case PutStack: {
<span class="udiff-line-modified-removed">-         AbstractHeap heap(Stack, node-&gt;stackAccessData()-&gt;local);</span>
<span class="udiff-line-modified-added">+         AbstractHeap heap(Stack, node-&gt;stackAccessData()-&gt;operand);</span>
          write(heap);
          def(HeapLocation(StackLoc, heap), LazyNode(node-&gt;child1().node()));
          return;
      }
  
<span class="udiff-line-added">+     case VarargsLength: {</span>
<span class="udiff-line-added">+         read(World);</span>
<span class="udiff-line-added">+         write(Heap);</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      case LoadVarargs: {
          read(World);
          write(Heap);
          LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="udiff-line-modified-removed">-         write(AbstractHeap(Stack, data-&gt;count.offset()));</span>
<span class="udiff-line-modified-added">+         write(AbstractHeap(Stack, data-&gt;count));</span>
          for (unsigned i = data-&gt;limit; i--;)
<span class="udiff-line-modified-removed">-             write(AbstractHeap(Stack, data-&gt;start.offset() + static_cast&lt;int&gt;(i)));</span>
<span class="udiff-line-modified-added">+             write(AbstractHeap(Stack, data-&gt;start + static_cast&lt;int&gt;(i)));</span>
          return;
      }
  
      case ForwardVarargs: {
          // We could be way more precise here.
          read(Stack);
  
          LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="udiff-line-modified-removed">-         write(AbstractHeap(Stack, data-&gt;count.offset()));</span>
<span class="udiff-line-modified-added">+         write(AbstractHeap(Stack, data-&gt;count));</span>
          for (unsigned i = data-&gt;limit; i--;)
<span class="udiff-line-modified-removed">-             write(AbstractHeap(Stack, data-&gt;start.offset() + static_cast&lt;int&gt;(i)));</span>
<span class="udiff-line-modified-added">+             write(AbstractHeap(Stack, data-&gt;start + static_cast&lt;int&gt;(i)));</span>
          return;
      }
  
      case GetByVal: {
          ArrayMode mode = node-&gt;arrayMode();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1016,12 +1046,12 @@</span>
                  write(Heap);
                  return;
              }
              read(Butterfly_publicLength);
              read(Butterfly_vectorLength);
<span class="udiff-line-modified-removed">-             read(ArrayStorageProperties);</span>
<span class="udiff-line-modified-removed">-             write(ArrayStorageProperties);</span>
<span class="udiff-line-modified-added">+             read(IndexedArrayStorageProperties);</span>
<span class="udiff-line-modified-added">+             write(IndexedArrayStorageProperties);</span>
              if (node-&gt;arrayMode().mayStoreToHole())
                  write(Butterfly_publicLength);
              return;
  
          case Array::SlowPutArrayStorage:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1030,12 +1060,12 @@</span>
                  write(Heap);
                  return;
              }
              read(Butterfly_publicLength);
              read(Butterfly_vectorLength);
<span class="udiff-line-modified-removed">-             read(ArrayStorageProperties);</span>
<span class="udiff-line-modified-removed">-             write(ArrayStorageProperties);</span>
<span class="udiff-line-modified-added">+             read(IndexedArrayStorageProperties);</span>
<span class="udiff-line-modified-added">+             write(IndexedArrayStorageProperties);</span>
              return;
  
          case Array::Int8Array:
          case Array::Int16Array:
          case Array::Int32Array:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1064,16 +1094,20 @@</span>
      case CheckStructureOrEmpty:
      case CheckStructure:
          read(JSCell_structureID);
          return;
  
<span class="udiff-line-added">+     case CheckArrayOrEmpty:</span>
      case CheckArray:
          read(JSCell_indexingType);
<span class="udiff-line-removed">-         read(JSCell_typeInfoType);</span>
          read(JSCell_structureID);
          return;
  
<span class="udiff-line-added">+     case CheckNeutered:</span>
<span class="udiff-line-added">+         read(MiscFields);</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
      case CheckTypeInfoFlags:
          read(JSCell_typeInfoFlags);
          def(HeapLocation(CheckTypeInfoFlagsLoc, JSCell_typeInfoFlags, node-&gt;child1()), LazyNode(node));
          return;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1094,11 +1128,10 @@</span>
          return;
  
      case PutStructure:
          read(JSObject_butterfly);
          write(JSCell_structureID);
<span class="udiff-line-removed">-         write(JSCell_typeInfoType);</span>
          write(JSCell_typeInfoFlags);
          write(JSCell_indexingType);
          return;
  
      case AllocatePropertyStorage:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1314,10 +1347,24 @@</span>
      case PutClosureVar:
          write(AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()));
          def(HeapLocation(ClosureVariableLoc, AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()), node-&gt;child1()), LazyNode(node-&gt;child2().node()));
          return;
  
<span class="udiff-line-added">+     case GetInternalField: {</span>
<span class="udiff-line-added">+         AbstractHeap heap(JSInternalFields, node-&gt;internalFieldIndex());</span>
<span class="udiff-line-added">+         read(heap);</span>
<span class="udiff-line-added">+         def(HeapLocation(InternalFieldObjectLoc, heap, node-&gt;child1()), LazyNode(node));</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case PutInternalField: {</span>
<span class="udiff-line-added">+         AbstractHeap heap(JSInternalFields, node-&gt;internalFieldIndex());</span>
<span class="udiff-line-added">+         write(heap);</span>
<span class="udiff-line-added">+         def(HeapLocation(InternalFieldObjectLoc, heap, node-&gt;child1()), LazyNode(node-&gt;child2().node()));</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      case GetRegExpObjectLastIndex:
          read(RegExpObject_lastIndex);
          def(HeapLocation(RegExpObjectLastIndexLoc, RegExpObject_lastIndex, node-&gt;child1()), LazyNode(node));
          return;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1381,12 +1428,12 @@</span>
              DFG_CRASH(graph, node, &quot;Bad use kind&quot;);
          }
          break;
  
      case NewArrayWithSpread: {
<span class="udiff-line-removed">-         // This also reads from JSFixedArray&#39;s data store, but we don&#39;t have any way of describing that yet.</span>
          read(HeapObjectCount);
<span class="udiff-line-added">+         // This appears to read nothing because it&#39;s only reading immutable butterfly data.</span>
          for (unsigned i = 0; i &lt; node-&gt;numChildren(); i++) {
              Node* child = graph.varArgChild(node, i).node();
              if (child-&gt;op() == PhantomSpread) {
                  read(Stack);
                  break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1547,19 +1594,25 @@</span>
              return;
          }
      }
  
      case NewObject:
<span class="udiff-line-added">+     case NewPromise:</span>
<span class="udiff-line-added">+     case NewGenerator:</span>
<span class="udiff-line-added">+     case NewAsyncGenerator:</span>
<span class="udiff-line-added">+     case NewArrayIterator:</span>
      case NewRegexp:
      case NewSymbol:
      case NewStringObject:
      case PhantomNewObject:
      case MaterializeNewObject:
      case PhantomNewFunction:
      case PhantomNewGeneratorFunction:
      case PhantomNewAsyncFunction:
      case PhantomNewAsyncGeneratorFunction:
<span class="udiff-line-added">+     case PhantomNewArrayIterator:</span>
<span class="udiff-line-added">+     case MaterializeNewInternalFieldObject:</span>
      case PhantomCreateActivation:
      case MaterializeCreateActivation:
      case PhantomNewRegexp:
          read(HeapObjectCount);
          write(HeapObjectCount);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1789,10 +1842,17 @@</span>
          return;
  
      case NumberToStringWithValidRadixConstant:
          def(PureValue(node, node-&gt;validRadixConstant()));
          return;
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case DateGetTime:</span>
<span class="udiff-line-added">+     case DateGetInt32OrNaN: {</span>
<span class="udiff-line-added">+         read(JSDateFields);</span>
<span class="udiff-line-added">+         def(HeapLocation(DateFieldLoc, AbstractHeap(JSDateFields, static_cast&lt;uint64_t&gt;(node-&gt;intrinsic())), node-&gt;child1()), LazyNode(node));</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     }</span>
  
      case DataViewGetFloat:
      case DataViewGetInt: {
          read(MiscFields);
          read(TypedArrayProperties);
</pre>
<center><a href="DFGCapabilities.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGClobbersExitState.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/Ref.h b/modules/javafx.web/src/main/native/Source/WTF/wtf/Ref.h
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/Ref.h
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/Ref.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -43,13 +43,14 @@
 inline void adopted(const void*) { }
 
 template<typename T, typename PtrTraits> class Ref;
 template<typename T, typename PtrTraits = DumbPtrTraits<T>> Ref<T, PtrTraits> adoptRef(T&);
 
-template<typename T, typename PtrTraits>
+template<typename T, typename Traits>
 class Ref {
 public:
+    using PtrTraits = Traits;
     static constexpr bool isRef = true;
 
     ~Ref()
     {
 #if ASAN_ENABLED
@@ -92,13 +93,12 @@
     template<typename X, typename Y> Ref& operator=(const Ref<X, Y>&) = delete;
 
     template<typename X, typename Y> void swap(Ref<X, Y>&);
 
     // Hash table deleted values, which are only constructed and never copied or destroyed.
-    Ref(HashTableDeletedValueType) : m_ptr(hashTableDeletedValue()) { }
-    bool isHashTableDeletedValue() const { return m_ptr == hashTableDeletedValue(); }
-    static T* hashTableDeletedValue() { return reinterpret_cast<T*>(-1); }
+    Ref(HashTableDeletedValueType) : m_ptr(PtrTraits::hashTableDeletedValue()) { }
+    bool isHashTableDeletedValue() const { return PtrTraits::isHashTableDeletedValue(m_ptr); }
 
     Ref(HashTableEmptyValueType) : m_ptr(hashTableEmptyValue()) { }
     bool isHashTableEmptyValue() const { return m_ptr == hashTableEmptyValue(); }
     static T* hashTableEmptyValue() { return nullptr; }
 
@@ -237,11 +237,11 @@
     static T* getPtr(const Ref<T, U>& p) { return const_cast<T*>(p.ptr()); }
 };
 
 template <typename T, typename U>
 struct IsSmartPtr<Ref<T, U>> {
-    static const bool value = true;
+    static constexpr bool value = true;
 };
 
 template<typename T, typename U>
 inline Ref<T, U> adoptRef(T& reference)
 {

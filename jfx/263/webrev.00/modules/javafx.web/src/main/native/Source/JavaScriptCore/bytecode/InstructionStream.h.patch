diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InstructionStream.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InstructionStream.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InstructionStream.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InstructionStream.h
@@ -24,21 +24,22 @@
  */
 
 
 #pragma once
 
+#include "BytecodeIndex.h"
 #include "Instruction.h"
 #include <wtf/Vector.h>
 
 namespace JSC {
 
-struct Instruction;
+DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(InstructionStream);
 
 class InstructionStream {
     WTF_MAKE_FAST_ALLOCATED;
 
-    using InstructionBuffer = Vector<uint8_t, 0, UnsafeVectorOverflow>;
+    using InstructionBuffer = Vector<uint8_t, 0, UnsafeVectorOverflow, 16, InstructionStreamMalloc>;
 
     friend class InstructionStreamWriter;
     friend class CachedInstructionStream;
 public:
     size_t sizeInBytes() const;
@@ -75,14 +76,12 @@
         BaseRef next() const
         {
             return BaseRef { m_instructions, m_index + ptr()->size() };
         }
 
-        inline Offset offset() const
-        {
-            return m_index;
-        }
+        inline Offset offset() const { return m_index; }
+        inline BytecodeIndex index() const { return BytecodeIndex(offset()); }
 
         bool isValid() const
         {
             return m_index < m_instructions.size();
         }
@@ -110,18 +109,21 @@
         using BaseRef<InstructionBuffer>::BaseRef;
 
     public:
         Ref freeze() const  { return Ref { m_instructions, m_index }; }
         inline Instruction* operator->() { return unwrap(); }
+        inline const Instruction* operator->() const { return unwrap(); }
         inline Instruction* ptr() { return unwrap(); }
+        inline const Instruction* ptr() const { return unwrap(); }
         inline operator Ref()
         {
             return Ref { m_instructions, m_index };
         }
 
     private:
         inline Instruction* unwrap() { return reinterpret_cast<Instruction*>(&m_instructions[m_index]); }
+        inline const Instruction* unwrap() const { return reinterpret_cast<const Instruction*>(&m_instructions[m_index]); }
     };
 
 private:
     class iterator : public Ref {
         friend class InstructionStream;
@@ -132,15 +134,20 @@
         Ref& operator*()
         {
             return *this;
         }
 
-        iterator operator++()
+        iterator& operator+=(size_t size)
         {
-            m_index += ptr()->size();
+            m_index += size;
             return *this;
         }
+
+        iterator& operator++()
+        {
+            return *this += ptr()->size();
+        }
     };
 
 public:
     inline iterator begin() const
     {
@@ -150,10 +157,11 @@
     inline iterator end() const
     {
         return iterator { m_instructions, m_instructions.size() };
     }
 
+    inline const Ref at(BytecodeIndex index) const { return at(index.offset()); }
     inline const Ref at(Offset offset) const
     {
         ASSERT(offset < m_instructions.size());
         return Ref { m_instructions, offset };
     }
@@ -276,15 +284,20 @@
         MutableRef& operator*()
         {
             return *this;
         }
 
-        iterator operator++()
+        iterator& operator+=(size_t size)
         {
-            m_index += ptr()->size();
+            m_index += size;
             return *this;
         }
+
+        iterator& operator++()
+        {
+            return *this += ptr()->size();
+        }
     };
 
 public:
     iterator begin()
     {

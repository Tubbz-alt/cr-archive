<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScheduledAction.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScriptController.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptController.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,10 ***</span>
<span class="line-new-header">--- 24,11 ---</span>
  #include &quot;BridgeJSC.h&quot;
  #include &quot;CachedScriptFetcher.h&quot;
  #include &quot;CommonVM.h&quot;
  #include &quot;ContentSecurityPolicy.h&quot;
  #include &quot;CustomHeaderFields.h&quot;
<span class="line-added">+ #include &quot;DOMWrapperWorld.h&quot;</span>
  #include &quot;DocumentLoader.h&quot;
  #include &quot;Event.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;FrameLoader.h&quot;
  #include &quot;FrameLoaderClient.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 45,31 ***</span>
<span class="line-new-header">--- 46,35 ---</span>
  #include &quot;Page.h&quot;
  #include &quot;PageConsoleClient.h&quot;
  #include &quot;PageGroup.h&quot;
  #include &quot;PaymentCoordinator.h&quot;
  #include &quot;PluginViewBase.h&quot;
<span class="line-added">+ #include &quot;RunJavaScriptParameters.h&quot;</span>
  #include &quot;RuntimeApplicationChecks.h&quot;
  #include &quot;ScriptDisallowedScope.h&quot;
  #include &quot;ScriptSourceCode.h&quot;
  #include &quot;ScriptableDocumentParser.h&quot;
  #include &quot;Settings.h&quot;
  #include &quot;UserGestureIndicator.h&quot;
  #include &quot;WebCoreJSClientData.h&quot;
  #include &quot;npruntime_impl.h&quot;
  #include &quot;runtime_root.h&quot;
  #include &lt;JavaScriptCore/Debugger.h&gt;
<span class="line-added">+ #include &lt;JavaScriptCore/Heap.h&gt;</span>
  #include &lt;JavaScriptCore/InitializeThreading.h&gt;
  #include &lt;JavaScriptCore/JSFunction.h&gt;
  #include &lt;JavaScriptCore/JSInternalPromise.h&gt;
  #include &lt;JavaScriptCore/JSLock.h&gt;
  #include &lt;JavaScriptCore/JSModuleRecord.h&gt;
  #include &lt;JavaScriptCore/JSNativeStdFunction.h&gt;
  #include &lt;JavaScriptCore/JSScriptFetchParameters.h&gt;
  #include &lt;JavaScriptCore/JSScriptFetcher.h&gt;
  #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
  #include &lt;JavaScriptCore/StrongInlines.h&gt;
<span class="line-added">+ #include &lt;JavaScriptCore/WeakGCMapInlines.h&gt;</span>
  #include &lt;wtf/SetForScope.h&gt;
<span class="line-added">+ #include &lt;wtf/SharedTask.h&gt;</span>
  #include &lt;wtf/Threading.h&gt;
  #include &lt;wtf/text/TextPosition.h&gt;
  
  namespace WebCore {
  using namespace JSC;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 104,11 ***</span>
          m_cacheableBindingRootObject-&gt;invalidate();
          m_cacheableBindingRootObject = nullptr;
      }
  }
  
<span class="line-modified">! JSValue ScriptController::evaluateInWorld(const ScriptSourceCode&amp; sourceCode, DOMWrapperWorld&amp; world, ExceptionDetails* exceptionDetails)</span>
  {
      JSLockHolder lock(world.vm());
  
      const SourceCode&amp; jsSourceCode = sourceCode.jsSourceCode();
      String sourceURL = jsSourceCode.provider()-&gt;url();
<span class="line-new-header">--- 109,17 ---</span>
          m_cacheableBindingRootObject-&gt;invalidate();
          m_cacheableBindingRootObject = nullptr;
      }
  }
  
<span class="line-modified">! JSC::JSValue ScriptController::evaluateInWorldIgnoringException(const ScriptSourceCode&amp; sourceCode, DOMWrapperWorld&amp; world)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto result = evaluateInWorld(sourceCode, world);</span>
<span class="line-added">+     return result ? result.value() : JSC::JSValue { };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ ValueOrException ScriptController::evaluateInWorld(const ScriptSourceCode&amp; sourceCode, DOMWrapperWorld&amp; world)</span>
  {
      JSLockHolder lock(world.vm());
  
      const SourceCode&amp; jsSourceCode = sourceCode.jsSourceCode();
      String sourceURL = jsSourceCode.provider()-&gt;url();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 119,46 ***</span>
      // inlineCode is true for &lt;a href=&quot;javascript:doSomething()&quot;&gt;
      // and false for &lt;script&gt;doSomething()&lt;/script&gt;. Check if it has the
      // expected value in all cases.
      // See smart window.open policy for where this is used.
      auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">!     auto&amp; exec = *proxy.window()-&gt;globalExec();</span>
      const String* savedSourceURL = m_sourceURL;
      m_sourceURL = &amp;sourceURL;
  
      Ref&lt;Frame&gt; protector(m_frame);
  
<span class="line-modified">!     InspectorInstrumentationCookie cookie = InspectorInstrumentation::willEvaluateScript(m_frame, sourceURL, sourceCode.startLine(), sourceCode.startColumn());</span>
  
      NakedPtr&lt;JSC::Exception&gt; evaluationException;
<span class="line-modified">!     JSValue returnValue = JSExecState::profiledEvaluate(&amp;exec, JSC::ProfilingReason::Other, jsSourceCode, &amp;proxy, evaluationException);</span>
  
<span class="line-modified">!     InspectorInstrumentation::didEvaluateScript(cookie, m_frame);</span>
  
      if (evaluationException) {
<span class="line-modified">!         reportException(&amp;exec, evaluationException, sourceCode.cachedScript(), exceptionDetails);</span>
<span class="line-modified">!         m_sourceURL = savedSourceURL;</span>
<span class="line-modified">!         return { };</span>
      }
  
      m_sourceURL = savedSourceURL;
      return returnValue;
  }
  
<span class="line-modified">! JSValue ScriptController::evaluate(const ScriptSourceCode&amp; sourceCode, ExceptionDetails* exceptionDetails)</span>
  {
<span class="line-modified">!     return evaluateInWorld(sourceCode, mainThreadNormalWorld(), exceptionDetails);</span>
  }
  
  void ScriptController::loadModuleScriptInWorld(LoadableModuleScript&amp; moduleScript, const String&amp; moduleName, Ref&lt;ModuleFetchParameters&gt;&amp;&amp; topLevelFetchParameters, DOMWrapperWorld&amp; world)
  {
      JSLockHolder lock(world.vm());
  
      auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">!     auto&amp; state = *proxy.window()-&gt;globalExec();</span>
  
<span class="line-modified">!     auto&amp; promise = JSExecState::loadModule(state, moduleName, JSC::JSScriptFetchParameters::create(state.vm(), WTFMove(topLevelFetchParameters)), JSC::JSScriptFetcher::create(state.vm(), { &amp;moduleScript }));</span>
      setupModuleScriptHandlers(moduleScript, promise, world);
  }
  
  void ScriptController::loadModuleScript(LoadableModuleScript&amp; moduleScript, const String&amp; moduleName, Ref&lt;ModuleFetchParameters&gt;&amp;&amp; topLevelFetchParameters)
  {
<span class="line-new-header">--- 130,50 ---</span>
      // inlineCode is true for &lt;a href=&quot;javascript:doSomething()&quot;&gt;
      // and false for &lt;script&gt;doSomething()&lt;/script&gt;. Check if it has the
      // expected value in all cases.
      // See smart window.open policy for where this is used.
      auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">!     auto&amp; globalObject = *proxy.window();</span>
      const String* savedSourceURL = m_sourceURL;
      m_sourceURL = &amp;sourceURL;
  
      Ref&lt;Frame&gt; protector(m_frame);
  
<span class="line-modified">!     InspectorInstrumentation::willEvaluateScript(m_frame, sourceURL, sourceCode.startLine(), sourceCode.startColumn());</span>
  
      NakedPtr&lt;JSC::Exception&gt; evaluationException;
<span class="line-modified">!     JSValue returnValue = JSExecState::profiledEvaluate(&amp;globalObject, JSC::ProfilingReason::Other, jsSourceCode, &amp;proxy, evaluationException);</span>
  
<span class="line-modified">!     InspectorInstrumentation::didEvaluateScript(m_frame);</span>
  
<span class="line-added">+     Optional&lt;ExceptionDetails&gt; optionalDetails;</span>
      if (evaluationException) {
<span class="line-modified">!         ExceptionDetails details;</span>
<span class="line-modified">!         reportException(&amp;globalObject, evaluationException, sourceCode.cachedScript(), &amp;details);</span>
<span class="line-modified">!         optionalDetails = WTFMove(details);</span>
      }
  
      m_sourceURL = savedSourceURL;
<span class="line-added">+     if (optionalDetails)</span>
<span class="line-added">+         return makeUnexpected(*optionalDetails);</span>
<span class="line-added">+ </span>
      return returnValue;
  }
  
<span class="line-modified">! JSC::JSValue ScriptController::evaluateIgnoringException(const ScriptSourceCode&amp; sourceCode)</span>
  {
<span class="line-modified">!     return evaluateInWorldIgnoringException(sourceCode, mainThreadNormalWorld());</span>
  }
  
  void ScriptController::loadModuleScriptInWorld(LoadableModuleScript&amp; moduleScript, const String&amp; moduleName, Ref&lt;ModuleFetchParameters&gt;&amp;&amp; topLevelFetchParameters, DOMWrapperWorld&amp; world)
  {
      JSLockHolder lock(world.vm());
  
      auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">!     auto&amp; lexicalGlobalObject = *proxy.window();</span>
  
<span class="line-modified">!     auto&amp; promise = JSExecState::loadModule(lexicalGlobalObject, moduleName, JSC::JSScriptFetchParameters::create(lexicalGlobalObject.vm(), WTFMove(topLevelFetchParameters)), JSC::JSScriptFetcher::create(lexicalGlobalObject.vm(), { &amp;moduleScript }));</span>
      setupModuleScriptHandlers(moduleScript, promise, world);
  }
  
  void ScriptController::loadModuleScript(LoadableModuleScript&amp; moduleScript, const String&amp; moduleName, Ref&lt;ModuleFetchParameters&gt;&amp;&amp; topLevelFetchParameters)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 168,13 ***</span>
  void ScriptController::loadModuleScriptInWorld(LoadableModuleScript&amp; moduleScript, const ScriptSourceCode&amp; sourceCode, DOMWrapperWorld&amp; world)
  {
      JSLockHolder lock(world.vm());
  
      auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">!     auto&amp; state = *proxy.window()-&gt;globalExec();</span>
  
<span class="line-modified">!     auto&amp; promise = JSExecState::loadModule(state, sourceCode.jsSourceCode(), JSC::JSScriptFetcher::create(state.vm(), { &amp;moduleScript }));</span>
      setupModuleScriptHandlers(moduleScript, promise, world);
  }
  
  void ScriptController::loadModuleScript(LoadableModuleScript&amp; moduleScript, const ScriptSourceCode&amp; sourceCode)
  {
<span class="line-new-header">--- 183,13 ---</span>
  void ScriptController::loadModuleScriptInWorld(LoadableModuleScript&amp; moduleScript, const ScriptSourceCode&amp; sourceCode, DOMWrapperWorld&amp; world)
  {
      JSLockHolder lock(world.vm());
  
      auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">!     auto&amp; lexicalGlobalObject = *proxy.window();</span>
  
<span class="line-modified">!     auto&amp; promise = JSExecState::loadModule(lexicalGlobalObject, sourceCode.jsSourceCode(), JSC::JSScriptFetcher::create(lexicalGlobalObject.vm(), { &amp;moduleScript }));</span>
      setupModuleScriptHandlers(moduleScript, promise, world);
  }
  
  void ScriptController::loadModuleScript(LoadableModuleScript&amp; moduleScript, const ScriptSourceCode&amp; sourceCode)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 185,22 ***</span>
  {
      JSC::VM&amp; vm = world.vm();
      JSLockHolder lock(vm);
  
      auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">!     auto&amp; state = *proxy.window()-&gt;globalExec();</span>
  
      // FIXME: Preventing Frame from being destroyed is essentially unnecessary.
      // https://bugs.webkit.org/show_bug.cgi?id=164763
      Ref&lt;Frame&gt; protector(m_frame);
  
      NakedPtr&lt;JSC::Exception&gt; evaluationException;
<span class="line-modified">!     auto returnValue = JSExecState::linkAndEvaluateModule(state, Identifier::fromUid(vm, moduleScript.moduleKey()), jsUndefined(), evaluationException);</span>
      if (evaluationException) {
          // FIXME: Give a chance to dump the stack trace if the &quot;crossorigin&quot; attribute allows.
          // https://bugs.webkit.org/show_bug.cgi?id=164539
<span class="line-modified">!         reportException(&amp;state, evaluationException, nullptr);</span>
          return jsUndefined();
      }
      return returnValue;
  }
  
<span class="line-new-header">--- 200,22 ---</span>
  {
      JSC::VM&amp; vm = world.vm();
      JSLockHolder lock(vm);
  
      auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">!     auto&amp; lexicalGlobalObject = *proxy.window();</span>
  
      // FIXME: Preventing Frame from being destroyed is essentially unnecessary.
      // https://bugs.webkit.org/show_bug.cgi?id=164763
      Ref&lt;Frame&gt; protector(m_frame);
  
      NakedPtr&lt;JSC::Exception&gt; evaluationException;
<span class="line-modified">!     auto returnValue = JSExecState::linkAndEvaluateModule(lexicalGlobalObject, Identifier::fromUid(vm, moduleScript.moduleKey()), jsUndefined(), evaluationException);</span>
      if (evaluationException) {
          // FIXME: Give a chance to dump the stack trace if the &quot;crossorigin&quot; attribute allows.
          // https://bugs.webkit.org/show_bug.cgi?id=164539
<span class="line-modified">!         reportException(&amp;lexicalGlobalObject, evaluationException, nullptr);</span>
          return jsUndefined();
      }
      return returnValue;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 214,31 ***</span>
      JSLockHolder lock(world.vm());
  
      const auto&amp; jsSourceCode = moduleRecord.sourceCode();
  
      auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">!     auto&amp; state = *proxy.window()-&gt;globalExec();</span>
      SetForScope&lt;const String*&gt; sourceURLScope(m_sourceURL, &amp;sourceURL.string());
  
      Ref&lt;Frame&gt; protector(m_frame);
  
<span class="line-modified">!     auto cookie = InspectorInstrumentation::willEvaluateScript(m_frame, sourceURL, jsSourceCode.firstLine().oneBasedInt(), jsSourceCode.startColumn().oneBasedInt());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto returnValue = moduleRecord.evaluate(&amp;state);</span>
<span class="line-removed">-     InspectorInstrumentation::didEvaluateScript(cookie, m_frame);</span>
  
      return returnValue;
  }
  
  JSC::JSValue ScriptController::evaluateModule(const URL&amp; sourceURL, JSModuleRecord&amp; moduleRecord)
  {
      return evaluateModule(sourceURL, moduleRecord, mainThreadNormalWorld());
  }
  
<span class="line-modified">! Ref&lt;DOMWrapperWorld&gt; ScriptController::createWorld()</span>
  {
<span class="line-modified">!     return DOMWrapperWorld::create(commonVM());</span>
  }
  
  void ScriptController::getAllWorlds(Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt;&amp; worlds)
  {
      static_cast&lt;JSVMClientData*&gt;(commonVM().clientData)-&gt;getAllWorlds(worlds);
<span class="line-new-header">--- 229,30 ---</span>
      JSLockHolder lock(world.vm());
  
      const auto&amp; jsSourceCode = moduleRecord.sourceCode();
  
      auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">!     auto&amp; lexicalGlobalObject = *proxy.window();</span>
      SetForScope&lt;const String*&gt; sourceURLScope(m_sourceURL, &amp;sourceURL.string());
  
      Ref&lt;Frame&gt; protector(m_frame);
  
<span class="line-modified">!     InspectorInstrumentation::willEvaluateScript(m_frame, sourceURL, jsSourceCode.firstLine().oneBasedInt(), jsSourceCode.startColumn().oneBasedInt());</span>
<span class="line-modified">!     auto returnValue = moduleRecord.evaluate(&amp;lexicalGlobalObject);</span>
<span class="line-modified">!     InspectorInstrumentation::didEvaluateScript(m_frame);</span>
  
      return returnValue;
  }
  
  JSC::JSValue ScriptController::evaluateModule(const URL&amp; sourceURL, JSModuleRecord&amp; moduleRecord)
  {
      return evaluateModule(sourceURL, moduleRecord, mainThreadNormalWorld());
  }
  
<span class="line-modified">! Ref&lt;DOMWrapperWorld&gt; ScriptController::createWorld(const String&amp; name, WorldType type)</span>
  {
<span class="line-modified">!     return DOMWrapperWorld::create(commonVM(), type == WorldType::User ? DOMWrapperWorld::Type::User : DOMWrapperWorld::Type::Internal, name);</span>
  }
  
  void ScriptController::getAllWorlds(Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt;&amp; worlds)
  {
      static_cast&lt;JSVMClientData*&gt;(commonVM().clientData)-&gt;getAllWorlds(worlds);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 260,41 ***</span>
      }
  
      m_frame.loader().dispatchDidClearWindowObjectInWorld(world);
  }
  
<span class="line-modified">! static Identifier jsValueToModuleKey(ExecState* exec, JSValue value)</span>
  {
      if (value.isSymbol())
          return Identifier::fromUid(jsCast&lt;Symbol*&gt;(value)-&gt;privateName());
      ASSERT(value.isString());
<span class="line-modified">!     return asString(value)-&gt;toIdentifier(exec);</span>
  }
  
  void ScriptController::setupModuleScriptHandlers(LoadableModuleScript&amp; moduleScriptRef, JSInternalPromise&amp; promise, DOMWrapperWorld&amp; world)
  {
      auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">!     auto&amp; state = *proxy.window()-&gt;globalExec();</span>
  
      // It is not guaranteed that either fulfillHandler or rejectHandler is eventually called.
      // For example, if the page load is canceled, the DeferredPromise used in the module loader pipeline will stop executing JS code.
      // Thus the promise returned from this function could remain unresolved.
  
      RefPtr&lt;LoadableModuleScript&gt; moduleScript(&amp;moduleScriptRef);
  
<span class="line-modified">!     auto&amp; fulfillHandler = *JSNativeStdFunction::create(state.vm(), proxy.window(), 1, String(), [moduleScript](ExecState* exec) -&gt; JSC::EncodedJSValue {</span>
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         Identifier moduleKey = jsValueToModuleKey(exec, exec-&gt;argument(0));</span>
          RETURN_IF_EXCEPTION(scope, { });
          moduleScript-&gt;notifyLoadCompleted(*moduleKey.impl());
          return JSValue::encode(jsUndefined());
      });
  
<span class="line-modified">!     auto&amp; rejectHandler = *JSNativeStdFunction::create(state.vm(), proxy.window(), 1, String(), [moduleScript](ExecState* exec) {</span>
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!         JSValue errorValue = exec-&gt;argument(0);</span>
          if (errorValue.isObject()) {
              auto* object = JSC::asObject(errorValue);
              if (JSValue failureKindValue = object-&gt;getDirect(vm, static_cast&lt;JSVMClientData&amp;&gt;(*vm.clientData).builtinNames().failureKindPrivateName())) {
                  // This is host propagated error in the module loader pipeline.
                  switch (static_cast&lt;ModuleFetchFailureKind&gt;(failureKindValue.asInt32())) {
<span class="line-new-header">--- 274,41 ---</span>
      }
  
      m_frame.loader().dispatchDidClearWindowObjectInWorld(world);
  }
  
<span class="line-modified">! static Identifier jsValueToModuleKey(JSGlobalObject* lexicalGlobalObject, JSValue value)</span>
  {
      if (value.isSymbol())
          return Identifier::fromUid(jsCast&lt;Symbol*&gt;(value)-&gt;privateName());
      ASSERT(value.isString());
<span class="line-modified">!     return asString(value)-&gt;toIdentifier(lexicalGlobalObject);</span>
  }
  
  void ScriptController::setupModuleScriptHandlers(LoadableModuleScript&amp; moduleScriptRef, JSInternalPromise&amp; promise, DOMWrapperWorld&amp; world)
  {
      auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">!     auto&amp; lexicalGlobalObject = *proxy.window();</span>
  
      // It is not guaranteed that either fulfillHandler or rejectHandler is eventually called.
      // For example, if the page load is canceled, the DeferredPromise used in the module loader pipeline will stop executing JS code.
      // Thus the promise returned from this function could remain unresolved.
  
      RefPtr&lt;LoadableModuleScript&gt; moduleScript(&amp;moduleScriptRef);
  
<span class="line-modified">!     auto&amp; fulfillHandler = *JSNativeStdFunction::create(lexicalGlobalObject.vm(), proxy.window(), 1, String(), [moduleScript](JSGlobalObject* globalObject, CallFrame* callFrame) -&gt; JSC::EncodedJSValue {</span>
<span class="line-modified">!         VM&amp; vm = globalObject-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         Identifier moduleKey = jsValueToModuleKey(globalObject, callFrame-&gt;argument(0));</span>
          RETURN_IF_EXCEPTION(scope, { });
          moduleScript-&gt;notifyLoadCompleted(*moduleKey.impl());
          return JSValue::encode(jsUndefined());
      });
  
<span class="line-modified">!     auto&amp; rejectHandler = *JSNativeStdFunction::create(lexicalGlobalObject.vm(), proxy.window(), 1, String(), [moduleScript](JSGlobalObject* globalObject, CallFrame* callFrame) {</span>
<span class="line-modified">!         VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!         JSValue errorValue = callFrame-&gt;argument(0);</span>
          if (errorValue.isObject()) {
              auto* object = JSC::asObject(errorValue);
              if (JSValue failureKindValue = object-&gt;getDirect(vm, static_cast&lt;JSVMClientData&amp;&gt;(*vm.clientData).builtinNames().failureKindPrivateName())) {
                  // This is host propagated error in the module loader pipeline.
                  switch (static_cast&lt;ModuleFetchFailureKind&gt;(failureKindValue.asInt32())) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 316,17 ***</span>
          moduleScript-&gt;notifyLoadFailed(LoadableScript::Error {
              LoadableScript::ErrorType::CachedScript,
              LoadableScript::ConsoleMessage {
                  MessageSource::JS,
                  MessageLevel::Error,
<span class="line-modified">!                 retrieveErrorMessage(*exec, vm, errorValue, scope),</span>
              }
          });
          return JSValue::encode(jsUndefined());
      });
  
<span class="line-modified">!     promise.then(&amp;state, &amp;fulfillHandler, &amp;rejectHandler);</span>
  }
  
  WindowProxy&amp; ScriptController::windowProxy()
  {
      return m_frame.windowProxy();
<span class="line-new-header">--- 330,17 ---</span>
          moduleScript-&gt;notifyLoadFailed(LoadableScript::Error {
              LoadableScript::ErrorType::CachedScript,
              LoadableScript::ConsoleMessage {
                  MessageSource::JS,
                  MessageLevel::Error,
<span class="line-modified">!                 retrieveErrorMessage(*globalObject, vm, errorValue, scope),</span>
              }
          });
          return JSValue::encode(jsUndefined());
      });
  
<span class="line-modified">!     promise.then(&amp;lexicalGlobalObject, &amp;fulfillHandler, &amp;rejectHandler);</span>
  }
  
  WindowProxy&amp; ScriptController::windowProxy()
  {
      return m_frame.windowProxy();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 384,19 ***</span>
      jsWindowProxy-&gt;window()-&gt;setWebAssemblyEnabled(false, errorMessage);
  }
  
  bool ScriptController::canAccessFromCurrentOrigin(Frame* frame, Document&amp; accessingDocument)
  {
<span class="line-modified">!     auto* state = JSExecState::currentState();</span>
  
<span class="line-modified">!     // If the current state is null we should use the accessing document for the security check.</span>
<span class="line-modified">!     if (!state) {</span>
          auto* targetDocument = frame ? frame-&gt;document() : nullptr;
          return targetDocument &amp;&amp; accessingDocument.securityOrigin().canAccess(targetDocument-&gt;securityOrigin());
      }
  
<span class="line-modified">!     return BindingSecurity::shouldAllowAccessToFrame(state, frame);</span>
  }
  
  void ScriptController::updateDocument()
  {
      for (auto&amp; jsWindowProxy : windowProxy().jsWindowProxiesAsVector()) {
<span class="line-new-header">--- 398,19 ---</span>
      jsWindowProxy-&gt;window()-&gt;setWebAssemblyEnabled(false, errorMessage);
  }
  
  bool ScriptController::canAccessFromCurrentOrigin(Frame* frame, Document&amp; accessingDocument)
  {
<span class="line-modified">!     auto* lexicalGlobalObject = JSExecState::currentState();</span>
  
<span class="line-modified">!     // If the current lexicalGlobalObject is null we should use the accessing document for the security check.</span>
<span class="line-modified">!     if (!lexicalGlobalObject) {</span>
          auto* targetDocument = frame ? frame-&gt;document() : nullptr;
          return targetDocument &amp;&amp; accessingDocument.securityOrigin().canAccess(targetDocument-&gt;securityOrigin());
      }
  
<span class="line-modified">!     return BindingSecurity::shouldAllowAccessToFrame(lexicalGlobalObject, frame);</span>
  }
  
  void ScriptController::updateDocument()
  {
      for (auto&amp; jsWindowProxy : windowProxy().jsWindowProxiesAsVector()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 439,16 ***</span>
  
      m_rootObjects.set(nativeHandle, rootObject.copyRef());
      return rootObject;
  }
  
<span class="line-modified">! void ScriptController::collectIsolatedContexts(Vector&lt;std::pair&lt;JSC::ExecState*, SecurityOrigin*&gt;&gt;&amp; result)</span>
  {
      for (auto&amp; jsWindowProxy : windowProxy().jsWindowProxiesAsVector()) {
<span class="line-modified">!         auto* exec = jsWindowProxy-&gt;window()-&gt;globalExec();</span>
          auto* origin = &amp;downcast&lt;DOMWindow&gt;(jsWindowProxy-&gt;wrapped()).document()-&gt;securityOrigin();
<span class="line-modified">!         result.append(std::make_pair(exec, origin));</span>
      }
  }
  
  #if ENABLE(NETSCAPE_PLUGIN_API)
  NPObject* ScriptController::windowScriptNPObject()
<span class="line-new-header">--- 453,16 ---</span>
  
      m_rootObjects.set(nativeHandle, rootObject.copyRef());
      return rootObject;
  }
  
<span class="line-modified">! void ScriptController::collectIsolatedContexts(Vector&lt;std::pair&lt;JSC::JSGlobalObject*, SecurityOrigin*&gt;&gt;&amp; result)</span>
  {
      for (auto&amp; jsWindowProxy : windowProxy().jsWindowProxiesAsVector()) {
<span class="line-modified">!         auto* lexicalGlobalObject = jsWindowProxy-&gt;window();</span>
          auto* origin = &amp;downcast&lt;DOMWindow&gt;(jsWindowProxy-&gt;wrapped()).document()-&gt;securityOrigin();
<span class="line-modified">!         result.append(std::make_pair(lexicalGlobalObject, origin));</span>
      }
  }
  
  #if ENABLE(NETSCAPE_PLUGIN_API)
  NPObject* ScriptController::windowScriptNPObject()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 492,11 ***</span>
      JSLockHolder lock(commonVM());
  
      // Create a JSObject bound to this element
      auto* globalObj = globalObject(pluginWorld());
      // FIXME: is normal okay? - used for NP plugins?
<span class="line-modified">!     JSValue jsElementValue = toJS(globalObj-&gt;globalExec(), globalObj, plugin);</span>
      if (!jsElementValue || !jsElementValue.isObject())
          return nullptr;
  
      return jsElementValue.getObject();
  }
<span class="line-new-header">--- 506,11 ---</span>
      JSLockHolder lock(commonVM());
  
      // Create a JSObject bound to this element
      auto* globalObj = globalObject(pluginWorld());
      // FIXME: is normal okay? - used for NP plugins?
<span class="line-modified">!     JSValue jsElementValue = toJS(globalObj, globalObj, plugin);</span>
      if (!jsElementValue || !jsElementValue.isObject())
          return nullptr;
  
      return jsElementValue.getObject();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 546,40 ***</span>
          m_windowScriptNPObject = nullptr;
      }
  #endif
  }
  
<span class="line-modified">! JSValue ScriptController::executeScriptInWorld(DOMWrapperWorld&amp; world, const String&amp; script, bool forceUserGesture, ExceptionDetails* exceptionDetails)</span>
  {
<span class="line-modified">!     UserGestureIndicator gestureIndicator(forceUserGesture ? Optional&lt;ProcessingUserGestureState&gt;(ProcessingUserGesture) : WTF::nullopt);</span>
<span class="line-removed">-     ScriptSourceCode sourceCode(script, URL(m_frame.document()-&gt;url()), TextPosition(), JSC::SourceProviderSourceType::Program, CachedScriptFetcher::create(m_frame.document()-&gt;charset()));</span>
  
      if (!canExecuteScripts(AboutToExecuteScript) || isPaused())
<span class="line-modified">!         return { };</span>
  
<span class="line-modified">!     return evaluateInWorld(sourceCode, world, exceptionDetails);</span>
  }
  
<span class="line-modified">! JSValue ScriptController::executeUserAgentScriptInWorld(DOMWrapperWorld&amp; world, const String&amp; script, bool forceUserGesture, ExceptionDetails* exceptionDetails)</span>
  {
      auto&amp; document = *m_frame.document();
<span class="line-modified">!     if (!shouldAllowUserAgentScripts(document))</span>
<span class="line-modified">!         return { };</span>
  
      document.setHasEvaluatedUserAgentScripts();
<span class="line-modified">!     return executeScriptInWorld(world, script, forceUserGesture, exceptionDetails);</span>
  }
  
<span class="line-modified">! bool ScriptController::shouldAllowUserAgentScripts(Document&amp; document) const</span>
  {
  #if ENABLE(APPLE_PAY)
      if (auto page = m_frame.page())
          return page-&gt;paymentCoordinator().shouldAllowUserAgentScripts(document);
  #else
      UNUSED_PARAM(document);
  #endif
<span class="line-modified">!     return true;</span>
  }
  
  bool ScriptController::canExecuteScripts(ReasonForCallingCanExecuteScripts reason)
  {
      if (reason == AboutToExecuteScript)
<span class="line-new-header">--- 560,221 ---</span>
          m_windowScriptNPObject = nullptr;
      }
  #endif
  }
  
<span class="line-modified">! JSC::JSValue ScriptController::executeScriptIgnoringException(const String&amp; script, bool forceUserGesture)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return executeScriptInWorldIgnoringException(mainThreadNormalWorld(), script, forceUserGesture);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JSC::JSValue ScriptController::executeScriptInWorldIgnoringException(DOMWrapperWorld&amp; world, const String&amp; script, bool forceUserGesture)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto result = executeScriptInWorld(world, RunJavaScriptParameters { script, false, WTF::nullopt, forceUserGesture });</span>
<span class="line-added">+     return result ? result.value() : JSC::JSValue { };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ ValueOrException ScriptController::executeScriptInWorld(DOMWrapperWorld&amp; world, RunJavaScriptParameters&amp;&amp; parameters)</span>
  {
<span class="line-modified">!     UserGestureIndicator gestureIndicator(parameters.forceUserGesture == ForceUserGesture::Yes ? Optional&lt;ProcessingUserGestureState&gt;(ProcessingUserGesture) : WTF::nullopt);</span>
  
      if (!canExecuteScripts(AboutToExecuteScript) || isPaused())
<span class="line-modified">!         return makeUnexpected(ExceptionDetails { &quot;Cannot execute JavaScript in this document&quot;_s });</span>
<span class="line-added">+ </span>
<span class="line-added">+     switch (parameters.runAsAsyncFunction) {</span>
<span class="line-added">+     case RunAsAsyncFunction::No: {</span>
<span class="line-added">+         ScriptSourceCode sourceCode(parameters.source, URL(m_frame.document()-&gt;url()), TextPosition(), JSC::SourceProviderSourceType::Program, CachedScriptFetcher::create(m_frame.document()-&gt;charset()));</span>
<span class="line-added">+         return evaluateInWorld(sourceCode, world);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case RunAsAsyncFunction::Yes:</span>
<span class="line-added">+         return callInWorld(WTFMove(parameters), world);</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ ValueOrException ScriptController::callInWorld(RunJavaScriptParameters&amp;&amp; parameters, DOMWrapperWorld&amp; world)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(parameters.runAsAsyncFunction == RunAsAsyncFunction::Yes);</span>
<span class="line-added">+     ASSERT(parameters.arguments);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto&amp; proxy = jsWindowProxy(world);</span>
<span class="line-added">+     auto&amp; globalObject = *proxy.window();</span>
<span class="line-added">+     MarkedArgumentBuffer markedArguments;</span>
<span class="line-added">+     StringBuilder functionStringBuilder;</span>
<span class="line-added">+     String errorMessage;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Build up a new script string that is an async function with arguments, and deserialize those arguments.</span>
<span class="line-added">+     functionStringBuilder.append(&quot;(async function(&quot;);</span>
<span class="line-added">+     for (auto argument = parameters.arguments-&gt;begin(); argument != parameters.arguments-&gt;end();) {</span>
<span class="line-added">+         functionStringBuilder.append(argument-&gt;key);</span>
<span class="line-added">+         auto serializedArgument = SerializedScriptValue::createFromWireBytes(WTFMove(argument-&gt;value));</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto scope = DECLARE_CATCH_SCOPE(globalObject.vm());</span>
<span class="line-added">+         auto jsArgument = serializedArgument-&gt;deserialize(globalObject, &amp;globalObject);</span>
<span class="line-added">+         if (UNLIKELY(scope.exception())) {</span>
<span class="line-added">+             errorMessage = &quot;Unable to deserialize argument to execute asynchronous JavaScript function&quot;;</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         markedArguments.append(jsArgument);</span>
<span class="line-added">+ </span>
<span class="line-added">+         ++argument;</span>
<span class="line-added">+         if (argument != parameters.arguments-&gt;end())</span>
<span class="line-added">+             functionStringBuilder.append(&#39;,&#39;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!errorMessage.isEmpty())</span>
<span class="line-added">+         return makeUnexpected(ExceptionDetails { errorMessage });</span>
<span class="line-added">+ </span>
<span class="line-added">+     functionStringBuilder.append(&quot;){&quot;, parameters.source, &quot;})&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto sourceCode = ScriptSourceCode { functionStringBuilder.toString(), URL(m_frame.document()-&gt;url()), TextPosition(), JSC::SourceProviderSourceType::Program, CachedScriptFetcher::create(m_frame.document()-&gt;charset()) };</span>
<span class="line-added">+     const auto&amp; jsSourceCode = sourceCode.jsSourceCode();</span>
<span class="line-added">+ </span>
<span class="line-added">+     String sourceURL = jsSourceCode.provider()-&gt;url();</span>
<span class="line-added">+     const String* savedSourceURL = m_sourceURL;</span>
<span class="line-added">+     m_sourceURL = &amp;sourceURL;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Ref&lt;Frame&gt; protector(m_frame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     InspectorInstrumentation::willEvaluateScript(m_frame, sourceURL, sourceCode.startLine(), sourceCode.startColumn());</span>
<span class="line-added">+ </span>
<span class="line-added">+     NakedPtr&lt;JSC::Exception&gt; evaluationException;</span>
<span class="line-added">+     Optional&lt;ExceptionDetails&gt; optionalDetails;</span>
<span class="line-added">+     JSValue returnValue;</span>
<span class="line-added">+     do {</span>
<span class="line-added">+         JSValue functionObject = JSExecState::profiledEvaluate(&amp;globalObject, JSC::ProfilingReason::Other, jsSourceCode, &amp;proxy, evaluationException);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (evaluationException)</span>
<span class="line-added">+             break;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!functionObject || !functionObject.isFunction(world.vm())) {</span>
<span class="line-added">+             optionalDetails = { { &quot;Unable to create JavaScript async function to call&quot;_s } };</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=205562</span>
<span class="line-added">+         // Getting CallData/CallType shouldn&#39;t be required to call into JS.</span>
<span class="line-added">+         CallData callData;</span>
<span class="line-added">+         CallType callType = getCallData(world.vm(), functionObject, callData);</span>
<span class="line-added">+         if (callType == CallType::None) {</span>
<span class="line-added">+             optionalDetails = { { &quot;Unable to prepare JavaScript async function to be called&quot;_s } };</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         returnValue = JSExecState::profiledCall(&amp;globalObject, JSC::ProfilingReason::Other, functionObject, callType, callData, &amp;proxy, markedArguments, evaluationException);</span>
<span class="line-added">+     } while (false);</span>
<span class="line-added">+ </span>
<span class="line-added">+     InspectorInstrumentation::didEvaluateScript(m_frame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (evaluationException &amp;&amp; !optionalDetails) {</span>
<span class="line-added">+         ExceptionDetails details;</span>
<span class="line-added">+         reportException(&amp;globalObject, evaluationException, sourceCode.cachedScript(), &amp;details);</span>
<span class="line-added">+         optionalDetails = WTFMove(details);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_sourceURL = savedSourceURL;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (optionalDetails)</span>
<span class="line-added">+         return makeUnexpected(*optionalDetails);</span>
<span class="line-added">+     return returnValue;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! JSC::JSValue ScriptController::executeUserAgentScriptInWorldIgnoringException(DOMWrapperWorld&amp; world, const String&amp; script, bool forceUserGesture)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto result = executeUserAgentScriptInWorld(world, script, forceUserGesture);</span>
<span class="line-added">+     return result ? result.value() : JSC::JSValue { };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ ValueOrException ScriptController::executeUserAgentScriptInWorld(DOMWrapperWorld&amp; world, const String&amp; script, bool forceUserGesture)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return executeUserAgentScriptInWorldInternal(world, { script, false, WTF::nullopt, forceUserGesture });</span>
  }
  
<span class="line-modified">! ValueOrException ScriptController::executeUserAgentScriptInWorldInternal(DOMWrapperWorld&amp; world, RunJavaScriptParameters&amp;&amp; parameters)</span>
  {
      auto&amp; document = *m_frame.document();
<span class="line-modified">!     auto allowed = shouldAllowUserAgentScripts(document);</span>
<span class="line-modified">!     if (!allowed)</span>
<span class="line-added">+         return makeUnexpected(allowed.error());</span>
  
      document.setHasEvaluatedUserAgentScripts();
<span class="line-modified">!     return executeScriptInWorld(world, WTFMove(parameters));</span>
  }
  
<span class="line-modified">! void ScriptController::executeAsynchronousUserAgentScriptInWorld(DOMWrapperWorld&amp; world, RunJavaScriptParameters&amp;&amp; parameters, ResolveFunction&amp;&amp; resolveCompletionHandler)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto result = executeUserAgentScriptInWorldInternal(world, WTFMove(parameters));</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (parameters.runAsAsyncFunction == RunAsAsyncFunction::No || !result || !result.value().isObject()) {</span>
<span class="line-added">+         resolveCompletionHandler(result);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // When running JavaScript as an async function, any &quot;thenable&quot; object gets promise-like behavior of deferred completion.</span>
<span class="line-added">+     auto thenIdentifier = world.vm().propertyNames-&gt;then;</span>
<span class="line-added">+     auto&amp; proxy = jsWindowProxy(world);</span>
<span class="line-added">+     auto&amp; globalObject = *proxy.window();</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto thenFunction = result.value().get(&amp;globalObject, thenIdentifier);</span>
<span class="line-added">+     if (!thenFunction.isObject()) {</span>
<span class="line-added">+         resolveCompletionHandler(result);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     CallData callData;</span>
<span class="line-added">+     CallType callType = asObject(thenFunction)-&gt;methodTable(world.vm())-&gt;getCallData(asObject(thenFunction), callData);</span>
<span class="line-added">+     if (callType == CallType::None) {</span>
<span class="line-added">+         resolveCompletionHandler(result);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto sharedResolveFunction = createSharedTask&lt;void(ValueOrException)&gt;([resolveCompletionHandler = WTFMove(resolveCompletionHandler)](ValueOrException result) mutable {</span>
<span class="line-added">+         if (resolveCompletionHandler)</span>
<span class="line-added">+             resolveCompletionHandler(result);</span>
<span class="line-added">+         resolveCompletionHandler = nullptr;</span>
<span class="line-added">+     });</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* fulfillHandler = JSC::JSNativeStdFunction::create(world.vm(), &amp;globalObject, 1, String { }, [sharedResolveFunction = sharedResolveFunction.copyRef()] (JSGlobalObject*, CallFrame* callFrame) mutable {</span>
<span class="line-added">+         sharedResolveFunction-&gt;run(callFrame-&gt;argument(0));</span>
<span class="line-added">+         return JSValue::encode(jsUndefined());</span>
<span class="line-added">+     });</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* rejectHandler = JSC::JSNativeStdFunction::create(world.vm(), &amp;globalObject, 1, String { }, [sharedResolveFunction = sharedResolveFunction.copyRef()] (JSGlobalObject* globalObject, CallFrame* callFrame) mutable {</span>
<span class="line-added">+         sharedResolveFunction-&gt;run(makeUnexpected(ExceptionDetails { callFrame-&gt;argument(0).toWTFString(globalObject) }));</span>
<span class="line-added">+         return JSValue::encode(jsUndefined());</span>
<span class="line-added">+     });</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto finalizeCount = makeUniqueWithoutFastMallocCheck&lt;unsigned&gt;(0);</span>
<span class="line-added">+     auto finalizeGuard = createSharedTask&lt;void()&gt;([sharedResolveFunction = WTFMove(sharedResolveFunction), finalizeCount = WTFMove(finalizeCount)]() {</span>
<span class="line-added">+         if (++(*finalizeCount) == 2)</span>
<span class="line-added">+             sharedResolveFunction-&gt;run(makeUnexpected(ExceptionDetails { &quot;Completion handler for function call is no longer reachable&quot;_s }));</span>
<span class="line-added">+     });</span>
<span class="line-added">+ </span>
<span class="line-added">+     world.vm().heap.addFinalizer(fulfillHandler, [finalizeGuard = finalizeGuard.copyRef()](JSCell*) {</span>
<span class="line-added">+         finalizeGuard-&gt;run();</span>
<span class="line-added">+     });</span>
<span class="line-added">+     world.vm().heap.addFinalizer(rejectHandler, [finalizeGuard = finalizeGuard.copyRef()](JSCell*) {</span>
<span class="line-added">+         finalizeGuard-&gt;run();</span>
<span class="line-added">+     });</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSC::MarkedArgumentBuffer arguments;</span>
<span class="line-added">+     arguments.append(fulfillHandler);</span>
<span class="line-added">+     arguments.append(rejectHandler);</span>
<span class="line-added">+ </span>
<span class="line-added">+     call(&amp;globalObject, thenFunction, callType, callData, result.value(), arguments);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Expected&lt;void, ExceptionDetails&gt; ScriptController::shouldAllowUserAgentScripts(Document&amp; document) const</span>
  {
  #if ENABLE(APPLE_PAY)
      if (auto page = m_frame.page())
          return page-&gt;paymentCoordinator().shouldAllowUserAgentScripts(document);
  #else
      UNUSED_PARAM(document);
  #endif
<span class="line-modified">!     return { };</span>
  }
  
  bool ScriptController::canExecuteScripts(ReasonForCallingCanExecuteScripts reason)
  {
      if (reason == AboutToExecuteScript)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 596,33 ***</span>
          return false;
  
      return m_frame.loader().client().allowScript(m_frame.settings().isScriptEnabled());
  }
  
<span class="line-modified">! JSValue ScriptController::executeScript(const String&amp; script, bool forceUserGesture, ExceptionDetails* exceptionDetails)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     UserGestureIndicator gestureIndicator(forceUserGesture ? Optional&lt;ProcessingUserGestureState&gt;(ProcessingUserGesture) : WTF::nullopt);</span>
<span class="line-removed">-     return executeScript(ScriptSourceCode(script, URL(m_frame.document()-&gt;url()), TextPosition(), JSC::SourceProviderSourceType::Program, CachedScriptFetcher::create(m_frame.document()-&gt;charset())), exceptionDetails);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JSValue ScriptController::executeScript(const ScriptSourceCode&amp; sourceCode, ExceptionDetails* exceptionDetails)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!canExecuteScripts(AboutToExecuteScript) || isPaused())</span>
<span class="line-removed">-         return { }; // FIXME: Would jsNull be better?</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // FIXME: Preventing Frame from being destroyed is essentially unnecessary.</span>
<span class="line-removed">-     // https://bugs.webkit.org/show_bug.cgi?id=164763</span>
<span class="line-removed">-     Ref&lt;Frame&gt; protector(m_frame); // Script execution can destroy the frame, and thus the ScriptController.</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return evaluate(sourceCode, exceptionDetails);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool ScriptController::executeIfJavaScriptURL(const URL&amp; url, ShouldReplaceDocumentIfJavaScriptURL shouldReplaceDocumentIfJavaScriptURL)</span>
  {
      if (!WTF::protocolIsJavaScript(url))
          return false;
  
      if (!m_frame.page() || !m_frame.document()-&gt;contentSecurityPolicy()-&gt;allowJavaScriptURLs(m_frame.document()-&gt;url(), eventHandlerPosition().m_line))
          return true;
  
      // We need to hold onto the Frame here because executing script can
      // destroy the frame.
<span class="line-new-header">--- 791,18 ---</span>
          return false;
  
      return m_frame.loader().client().allowScript(m_frame.settings().isScriptEnabled());
  }
  
<span class="line-modified">! bool ScriptController::executeIfJavaScriptURL(const URL&amp; url, RefPtr&lt;SecurityOrigin&gt; requesterSecurityOrigin, ShouldReplaceDocumentIfJavaScriptURL shouldReplaceDocumentIfJavaScriptURL)</span>
  {
      if (!WTF::protocolIsJavaScript(url))
          return false;
  
<span class="line-added">+     if (requesterSecurityOrigin &amp;&amp; !requesterSecurityOrigin-&gt;canAccess(m_frame.document()-&gt;securityOrigin()))</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+ </span>
      if (!m_frame.page() || !m_frame.document()-&gt;contentSecurityPolicy()-&gt;allowJavaScriptURLs(m_frame.document()-&gt;url(), eventHandlerPosition().m_line))
          return true;
  
      // We need to hold onto the Frame here because executing script can
      // destroy the frame.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 630,19 ***</span>
      RefPtr&lt;Document&gt; ownerDocument(m_frame.document());
  
      const int javascriptSchemeLength = sizeof(&quot;javascript:&quot;) - 1;
  
      String decodedURL = decodeURLEscapeSequences(url.string());
<span class="line-modified">!     auto result = executeScript(decodedURL.substring(javascriptSchemeLength));</span>
  
      // If executing script caused this frame to be removed from the page, we
      // don&#39;t want to try to replace its document!
      if (!m_frame.page())
          return true;
  
      String scriptResult;
<span class="line-modified">!     if (!result || !result.getString(jsWindowProxy(mainThreadNormalWorld()).window()-&gt;globalExec(), scriptResult))</span>
          return true;
  
      // FIXME: We should always replace the document, but doing so
      //        synchronously can cause crashes:
      //        http://bugs.webkit.org/show_bug.cgi?id=16782
<span class="line-new-header">--- 810,19 ---</span>
      RefPtr&lt;Document&gt; ownerDocument(m_frame.document());
  
      const int javascriptSchemeLength = sizeof(&quot;javascript:&quot;) - 1;
  
      String decodedURL = decodeURLEscapeSequences(url.string());
<span class="line-modified">!     auto result = executeScriptIgnoringException(decodedURL.substring(javascriptSchemeLength));</span>
  
      // If executing script caused this frame to be removed from the page, we
      // don&#39;t want to try to replace its document!
      if (!m_frame.page())
          return true;
  
      String scriptResult;
<span class="line-modified">!     if (!result || !result.getString(jsWindowProxy(mainThreadNormalWorld()).window(), scriptResult))</span>
          return true;
  
      // FIXME: We should always replace the document, but doing so
      //        synchronously can cause crashes:
      //        http://bugs.webkit.org/show_bug.cgi?id=16782
</pre>
<center><a href="ScheduledAction.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScriptController.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
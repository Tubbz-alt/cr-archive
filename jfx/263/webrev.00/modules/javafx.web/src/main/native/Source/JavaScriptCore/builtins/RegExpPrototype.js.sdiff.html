<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/RegExpPrototype.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PromisePrototype.js.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegExpStringIteratorPrototype.js.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/RegExpPrototype.js</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 31 
 32     @putByIdDirectPrivate(this, &quot;regExpStringIteratorRegExp&quot;, regExp);
 33     @putByIdDirectPrivate(this, &quot;regExpStringIteratorString&quot;, string);
 34     @putByIdDirectPrivate(this, &quot;regExpStringIteratorGlobal&quot;, global);
 35     @putByIdDirectPrivate(this, &quot;regExpStringIteratorUnicode&quot;, fullUnicode);
 36     @putByIdDirectPrivate(this, &quot;regExpStringIteratorDone&quot;, false);
 37 }
 38 
 39 @globalPrivate
 40 function advanceStringIndex(string, index, unicode)
 41 {
 42     // This function implements AdvanceStringIndex described in ES6 21.2.5.2.3.
 43     &quot;use strict&quot;;
 44 
 45     if (!unicode)
 46         return index + 1;
 47 
 48     if (index + 1 &gt;= string.length)
 49         return index + 1;
 50 
<span class="line-modified"> 51     let first = string.@charCodeAt(index);</span>
 52     if (first &lt; 0xD800 || first &gt; 0xDBFF)
 53         return index + 1;
 54 
<span class="line-modified"> 55     let second = string.@charCodeAt(index + 1);</span>
 56     if (second &lt; 0xDC00 || second &gt; 0xDFFF)
 57         return index + 1;
 58 
 59     return index + 2;
 60 }
 61 
 62 @globalPrivate
 63 function regExpExec(regexp, str)
 64 {
 65     &quot;use strict&quot;;
 66 
<span class="line-modified"> 67     let exec = regexp.exec;</span>
<span class="line-modified"> 68     let builtinExec = @regExpBuiltinExec;</span>
 69     if (exec !== builtinExec &amp;&amp; typeof exec === &quot;function&quot;) {
<span class="line-modified"> 70         let result = exec.@call(regexp, str);</span>
 71         if (result !== null &amp;&amp; !@isObject(result))
 72             @throwTypeError(&quot;The result of a RegExp exec must be null or an object&quot;);
 73         return result;
 74     }
 75     return builtinExec.@call(regexp, str);
 76 }
 77 
 78 @globalPrivate
 79 function hasObservableSideEffectsForRegExpMatch(regexp)
 80 {
 81     &quot;use strict&quot;;
 82 
 83     if (!@isRegExpObject(regexp))
 84         return true;
 85 
 86     // This is accessed by the RegExpExec internal function.
<span class="line-modified"> 87     let regexpExec = @tryGetById(regexp, &quot;exec&quot;);</span>
 88     if (regexpExec !== @regExpBuiltinExec)
 89         return true;
 90 
<span class="line-modified"> 91     let regexpGlobal = @tryGetById(regexp, &quot;global&quot;);</span>
 92     if (regexpGlobal !== @regExpProtoGlobalGetter)
 93         return true;
<span class="line-modified"> 94     let regexpUnicode = @tryGetById(regexp, &quot;unicode&quot;);</span>
 95     if (regexpUnicode !== @regExpProtoUnicodeGetter)
 96         return true;
 97 
 98     return typeof regexp.lastIndex !== &quot;number&quot;;
 99 }
100 
101 @globalPrivate
102 function matchSlow(regexp, str)
103 {
104     &quot;use strict&quot;;
105 
106     if (!regexp.global)
107         return @regExpExec(regexp, str);
108     
<span class="line-modified">109     let unicode = regexp.unicode;</span>
110     regexp.lastIndex = 0;
<span class="line-modified">111     let resultList = [];</span>
112 
113     // FIXME: It would be great to implement a solution similar to what we do in
114     // RegExpObject::matchGlobal(). It&#39;s not clear if this is possible, since this loop has
115     // effects. https://bugs.webkit.org/show_bug.cgi?id=158145
<span class="line-modified">116     const maximumReasonableMatchSize = 100000000;</span>
117 
118     while (true) {
<span class="line-modified">119         let result = @regExpExec(regexp, str);</span>
120         
121         if (result === null) {
122             if (resultList.length === 0)
123                 return null;
124             return resultList;
125         }
126 
127         if (resultList.length &gt; maximumReasonableMatchSize)
128             @throwOutOfMemoryError();
129 
<span class="line-modified">130         let resultString = @toString(result[0]);</span>
131 
132         if (!resultString.length)
133             regexp.lastIndex = @advanceStringIndex(str, regexp.lastIndex, unicode);
134 
135         resultList.@push(resultString);
136     }
137 }
138 
139 @overriddenName=&quot;[Symbol.match]&quot;
140 function match(strArg)
141 {
142     &quot;use strict&quot;;
143 
144     if (!@isObject(this))
145         @throwTypeError(&quot;RegExp.prototype.@@match requires that |this| be an Object&quot;);
146 
<span class="line-modified">147     let str = @toString(strArg);</span>
148 
149     // Check for observable side effects and call the fast path if there aren&#39;t any.
150     if (!@hasObservableSideEffectsForRegExpMatch(this))
151         return @regExpMatchFast.@call(this, str);
152     return @matchSlow(this, str);
153 }
154 
155 @overriddenName=&quot;[Symbol.matchAll]&quot;
156 function matchAll(strArg)
157 {
158     &quot;use strict&quot;;
159 
<span class="line-modified">160     let regExp = this;</span>
161     if (!@isObject(regExp))
162         @throwTypeError(&quot;RegExp.prototype.@@matchAll requires |this| to be an Object&quot;);
163 
<span class="line-modified">164     let string = @toString(strArg);</span>
<span class="line-modified">165     let Matcher = @speciesConstructor(regExp, @RegExp);</span>
166 
<span class="line-modified">167     let flags = @toString(regExp.flags);</span>
<span class="line-modified">168     let matcher = new Matcher(regExp, flags);</span>
169     matcher.lastIndex = @toLength(regExp.lastIndex);
170 
<span class="line-modified">171     let global = @stringIncludesInternal.@call(flags, &quot;g&quot;);</span>
<span class="line-modified">172     let fullUnicode = @stringIncludesInternal.@call(flags, &quot;u&quot;);</span>
173 
174     return new @RegExpStringIterator(matcher, string, global, fullUnicode);
175 }
176 
177 @overriddenName=&quot;[Symbol.replace]&quot;
178 function replace(strArg, replace)
179 {
180     &quot;use strict&quot;;
181 
<span class="line-modified">182     function getSubstitution(matched, str, position, captures, replacement)</span>
183     {
184         &quot;use strict&quot;;
185 
<span class="line-modified">186         let matchLength = matched.length;</span>
<span class="line-modified">187         let stringLength = str.length;</span>
<span class="line-modified">188         let tailPos = position + matchLength;</span>
<span class="line-modified">189         let m = captures.length;</span>
<span class="line-modified">190         let replacementLength = replacement.length;</span>
<span class="line-modified">191         let result = &quot;&quot;;</span>
<span class="line-modified">192         let lastStart = 0;</span>
193 
<span class="line-modified">194         for (let start = 0; start = replacement.indexOf(&quot;$&quot;, lastStart), start !== -1; lastStart = start) {</span>
195             if (start - lastStart &gt; 0)
196                 result = result + replacement.substring(lastStart, start);
197             start++;
<span class="line-modified">198             let ch = replacement.charAt(start);</span>
199             if (ch === &quot;&quot;)
200                 result = result + &quot;$&quot;;
201             else {
202                 switch (ch)
203                 {
204                 case &quot;$&quot;:
205                     result = result + &quot;$&quot;;
206                     start++;
207                     break;
208                 case &quot;&amp;&quot;:
209                     result = result + matched;
210                     start++;
211                     break;
212                 case &quot;`&quot;:
213                     if (position &gt; 0)
214                         result = result + str.substring(0, position);
215                     start++;
216                     break;
217                 case &quot;&#39;&quot;:
218                     if (tailPos &lt; stringLength)
219                         result = result + str.substring(tailPos);
220                     start++;
221                     break;


















222                 default:
<span class="line-modified">223                     let chCode = ch.charCodeAt(0);</span>
224                     if (chCode &gt;= 0x30 &amp;&amp; chCode &lt;= 0x39) {

225                         start++;
<span class="line-modified">226                         let n = chCode - 0x30;</span>
<span class="line-modified">227                         if (n &gt; m)</span>


228                             break;


229                         if (start &lt; replacementLength) {
<span class="line-modified">230                             let nextChCode = replacement.charCodeAt(start);</span>
231                             if (nextChCode &gt;= 0x30 &amp;&amp; nextChCode &lt;= 0x39) {
<span class="line-modified">232                                 let nn = 10 * n + nextChCode - 0x30;</span>
233                                 if (nn &lt;= m) {
234                                     n = nn;
235                                     start++;
236                                 }
237                             }
238                         }
239 
<span class="line-modified">240                         if (n == 0)</span>

241                             break;

242 
<span class="line-modified">243                         if (captures[n] != @undefined)</span>
<span class="line-modified">244                             result = result + captures[n];</span>

245                     } else
246                         result = result + &quot;$&quot;;
247                     break;
248                 }
249             }
250         }
251 
252         return result + replacement.substring(lastStart);
253     }
254 
255     if (!@isObject(this))
256         @throwTypeError(&quot;RegExp.prototype.@@replace requires that |this| be an Object&quot;);
257 
<span class="line-modified">258     let regexp = this;</span>
259 
<span class="line-modified">260     let str = @toString(strArg);</span>
<span class="line-modified">261     let stringLength = str.length;</span>
<span class="line-modified">262     let functionalReplace = typeof replace === &#39;function&#39;;</span>
263 
264     if (!functionalReplace)
265         replace = @toString(replace);
266 
<span class="line-modified">267     let global = regexp.global;</span>
<span class="line-modified">268     let unicode = false;</span>
269 
270     if (global) {
271         unicode = regexp.unicode;
272         regexp.lastIndex = 0;
273     }
274 
<span class="line-modified">275     let resultList = [];</span>
<span class="line-modified">276     let result;</span>
<span class="line-modified">277     let done = false;</span>
278     while (!done) {
279         result = @regExpExec(regexp, str);
280 
281         if (result === null)
282             done = true;
283         else {
284             resultList.@push(result);
285             if (!global)
286                 done = true;
287             else {
<span class="line-modified">288                 let matchStr = @toString(result[0]);</span>
289 
290                 if (!matchStr.length)
291                     regexp.lastIndex = @advanceStringIndex(str, regexp.lastIndex, unicode);
292             }
293         }
294     }
295 
<span class="line-modified">296     let accumulatedResult = &quot;&quot;;</span>
<span class="line-modified">297     let nextSourcePosition = 0;</span>
<span class="line-modified">298     let lastPosition = 0;</span>
299 
<span class="line-modified">300     for (let i = 0, resultListLength = resultList.length; i &lt; resultListLength; ++i) {</span>
<span class="line-modified">301         let result = resultList[i];</span>
<span class="line-modified">302         let nCaptures = result.length - 1;</span>
303         if (nCaptures &lt; 0)
304             nCaptures = 0;
<span class="line-modified">305         let matched = @toString(result[0]);</span>
<span class="line-modified">306         let matchLength = matched.length;</span>
<span class="line-modified">307         let position = result.index;</span>
308         position = (position &gt; stringLength) ? stringLength : position;
309         position = (position &lt; 0) ? 0 : position;
310 
<span class="line-modified">311         let captures = [];</span>
<span class="line-modified">312         for (let n = 1; n &lt;= nCaptures; n++) {</span>
<span class="line-modified">313             let capN = result[n];</span>
314             if (capN !== @undefined)
315                 capN = @toString(capN);
<span class="line-modified">316             captures[n] = capN;</span>
317         }
318 
<span class="line-modified">319         let replacement;</span>

320 
321         if (functionalReplace) {
<span class="line-modified">322             let replacerArgs = [ matched ].concat(captures.slice(1));</span>
323             replacerArgs.@push(position);
324             replacerArgs.@push(str);
325 
<span class="line-modified">326             let replValue = replace.@apply(@undefined, replacerArgs);</span>



327             replacement = @toString(replValue);
<span class="line-modified">328         } else</span>
<span class="line-modified">329             replacement = getSubstitution(matched, str, position, captures, replace);</span>




330 
331         if (position &gt;= nextSourcePosition &amp;&amp; position &gt;= lastPosition) {
332             accumulatedResult = accumulatedResult + str.substring(nextSourcePosition, position) + replacement;
333             nextSourcePosition = position + matchLength;
334             lastPosition = position;
335         }
336     }
337 
338     if (nextSourcePosition &gt;= stringLength)
339         return  accumulatedResult;
340 
341     return accumulatedResult + str.substring(nextSourcePosition);
342 }
343 
344 // 21.2.5.9 RegExp.prototype[@@search] (string)
345 @overriddenName=&quot;[Symbol.search]&quot;
346 function search(strArg)
347 {
348     &quot;use strict&quot;;
349 
<span class="line-modified">350     let regexp = this;</span>
351 
352     // Check for observable side effects and call the fast path if there aren&#39;t any.
353     if (@isRegExpObject(regexp)
354         &amp;&amp; @tryGetById(regexp, &quot;exec&quot;) === @regExpBuiltinExec
355         &amp;&amp; typeof regexp.lastIndex === &quot;number&quot;)
356         return @regExpSearchFast.@call(regexp, strArg);
357 
358     // 1. Let rx be the this value.
359     // 2. If Type(rx) is not Object, throw a TypeError exception.
360     if (!@isObject(this))
361         @throwTypeError(&quot;RegExp.prototype.@@search requires that |this| be an Object&quot;);
362 
363     // 3. Let S be ? ToString(string).
<span class="line-modified">364     let str = @toString(strArg)</span>
365 
366     // 4. Let previousLastIndex be ? Get(rx, &quot;lastIndex&quot;).
<span class="line-modified">367     let previousLastIndex = regexp.lastIndex;</span>
368 
369     // 5.If SameValue(previousLastIndex, 0) is false, then
370     // 5.a. Perform ? Set(rx, &quot;lastIndex&quot;, 0, true).
371     // FIXME: Add SameValue support. https://bugs.webkit.org/show_bug.cgi?id=173226
372     if (previousLastIndex !== 0)
373         regexp.lastIndex = 0;
374 
375     // 6. Let result be ? RegExpExec(rx, S).
<span class="line-modified">376     let result = @regExpExec(regexp, str);</span>
377 
378     // 7. Let currentLastIndex be ? Get(rx, &quot;lastIndex&quot;).
379     // 8. If SameValue(currentLastIndex, previousLastIndex) is false, then
380     // 8.a. Perform ? Set(rx, &quot;lastIndex&quot;, previousLastIndex, true).
381     // FIXME: Add SameValue support. https://bugs.webkit.org/show_bug.cgi?id=173226
382     if (regexp.lastIndex !== previousLastIndex)
383         regexp.lastIndex = previousLastIndex;
384 
385     // 9. If result is null, return -1.
386     if (result === null)
387         return -1;
388 
389     // 10. Return ? Get(result, &quot;index&quot;).
390     return result.index;
391 }
392 
393 @globalPrivate
394 function hasObservableSideEffectsForRegExpSplit(regexp)
395 {
396     &quot;use strict&quot;;
397 
398     if (!@isRegExpObject(regexp))
399         return true;
400 
401     // This is accessed by the RegExpExec internal function.
<span class="line-modified">402     let regexpExec = @tryGetById(regexp, &quot;exec&quot;);</span>
403     if (regexpExec !== @regExpBuiltinExec)
404         return true;
405     
406     // This is accessed by step 5 below.
<span class="line-modified">407     let regexpFlags = @tryGetById(regexp, &quot;flags&quot;);</span>
408     if (regexpFlags !== @regExpProtoFlagsGetter)
409         return true;
410     
411     // These are accessed by the builtin flags getter.
<span class="line-modified">412     let regexpGlobal = @tryGetById(regexp, &quot;global&quot;);</span>
413     if (regexpGlobal !== @regExpProtoGlobalGetter)
414         return true;
<span class="line-modified">415     let regexpIgnoreCase = @tryGetById(regexp, &quot;ignoreCase&quot;);</span>
416     if (regexpIgnoreCase !== @regExpProtoIgnoreCaseGetter)
417         return true;
<span class="line-modified">418     let regexpMultiline = @tryGetById(regexp, &quot;multiline&quot;);</span>
419     if (regexpMultiline !== @regExpProtoMultilineGetter)
420         return true;
<span class="line-modified">421     let regexpSticky = @tryGetById(regexp, &quot;sticky&quot;);</span>
422     if (regexpSticky !== @regExpProtoStickyGetter)
423         return true;
<span class="line-modified">424     let regexpUnicode = @tryGetById(regexp, &quot;unicode&quot;);</span>
425     if (regexpUnicode !== @regExpProtoUnicodeGetter)
426         return true;
427     
428     // This is accessed by the RegExp species constructor.
<span class="line-modified">429     let regexpSource = @tryGetById(regexp, &quot;source&quot;);</span>
430     if (regexpSource !== @regExpProtoSourceGetter)
431         return true;
432 
433     return typeof regexp.lastIndex !== &quot;number&quot;;
434 }
435 
436 // ES 21.2.5.11 RegExp.prototype[@@split](string, limit)
437 @overriddenName=&quot;[Symbol.split]&quot;
438 function split(string, limit)
439 {
440     &quot;use strict&quot;;
441 
442     // 1. Let rx be the this value.
443     // 2. If Type(rx) is not Object, throw a TypeError exception.
444     if (!@isObject(this))
445         @throwTypeError(&quot;RegExp.prototype.@@split requires that |this| be an Object&quot;);
<span class="line-modified">446     let regexp = this;</span>
447 
448     // 3. Let S be ? ToString(string).
<span class="line-modified">449     let str = @toString(string);</span>
450 
451     // 4. Let C be ? SpeciesConstructor(rx, %RegExp%).
<span class="line-modified">452     let speciesConstructor = @speciesConstructor(regexp, @RegExp);</span>
453 
454     if (speciesConstructor === @RegExp &amp;&amp; !@hasObservableSideEffectsForRegExpSplit(regexp))
455         return @regExpSplitFast.@call(regexp, str, limit);
456 
457     // 5. Let flags be ? ToString(? Get(rx, &quot;flags&quot;)).
<span class="line-modified">458     let flags = @toString(regexp.flags);</span>
459 
<span class="line-modified">460     // 6. If flags contains &quot;u&quot;, let unicodeMatching be true.</span>
461     // 7. Else, let unicodeMatching be false.
<span class="line-modified">462     let unicodeMatching = @stringIncludesInternal.@call(flags, &quot;u&quot;);</span>
<span class="line-modified">463     // 8. If flags contains &quot;y&quot;, let newFlags be flags.</span>
464     // 9. Else, let newFlags be the string that is the concatenation of flags and &quot;y&quot;.
<span class="line-modified">465     let newFlags = @stringIncludesInternal.@call(flags, &quot;y&quot;) ? flags : flags + &quot;y&quot;;</span>
466 
467     // 10. Let splitter be ? Construct(C, « rx, newFlags »).
<span class="line-modified">468     let splitter = new speciesConstructor(regexp, newFlags);</span>
469 
470     // We need to check again for RegExp subclasses that will fail the speciesConstructor test
471     // but can still use the fast path after we invoke the constructor above.
472     if (!@hasObservableSideEffectsForRegExpSplit(splitter))
473         return @regExpSplitFast.@call(splitter, str, limit);
474 
475     // 11. Let A be ArrayCreate(0).
476     // 12. Let lengthA be 0.
<span class="line-modified">477     let result = [];</span>
478 
<span class="line-modified">479     // 13. If limit is undefined, let lim be 2^32-1; else let lim be ? ToUint32(limit).</span>
480     limit = (limit === @undefined) ? 0xffffffff : limit &gt;&gt;&gt; 0;
481 
482     // 16. If lim = 0, return A.
483     if (!limit)
484         return result;
485 
486     // 14. [Defered from above] Let size be the number of elements in S.
<span class="line-modified">487     let size = str.length;</span>
488 
489     // 17. If size = 0, then
490     if (!size) {
491         // a. Let z be ? RegExpExec(splitter, S).
<span class="line-modified">492         let z = @regExpExec(splitter, str);</span>
493         // b. If z is not null, return A.
494         if (z != null)
495             return result;
496         // c. Perform ! CreateDataProperty(A, &quot;0&quot;, S).
497         @putByValDirect(result, 0, str);
498         // d. Return A.
499         return result;
500     }
501 
502     // 15. [Defered from above] Let p be 0.
<span class="line-modified">503     let position = 0;</span>
504     // 18. Let q be p.
<span class="line-modified">505     let matchPosition = 0;</span>
506 
507     // 19. Repeat, while q &lt; size
508     while (matchPosition &lt; size) {
509         // a. Perform ? Set(splitter, &quot;lastIndex&quot;, q, true).
510         splitter.lastIndex = matchPosition;
511         // b. Let z be ? RegExpExec(splitter, S).
<span class="line-modified">512         let matches = @regExpExec(splitter, str);</span>
513         // c. If z is null, let q be AdvanceStringIndex(S, q, unicodeMatching).
514         if (matches === null)
515             matchPosition = @advanceStringIndex(str, matchPosition, unicodeMatching);
516         // d. Else z is not null,
517         else {
518             // i. Let e be ? ToLength(? Get(splitter, &quot;lastIndex&quot;)).
<span class="line-modified">519             let endPosition = @toLength(splitter.lastIndex);</span>
520             // ii. Let e be min(e, size).
521             endPosition = (endPosition &lt;= size) ? endPosition : size;
522             // iii. If e = p, let q be AdvanceStringIndex(S, q, unicodeMatching).
523             if (endPosition === position)
524                 matchPosition = @advanceStringIndex(str, matchPosition, unicodeMatching);
525             // iv. Else e != p,
526             else {
527                 // 1. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through q (exclusive).
<span class="line-modified">528                 let subStr = @stringSubstrInternal.@call(str, position, matchPosition - position);</span>
529                 // 2. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
530                 // 3. Let lengthA be lengthA + 1.
531                 @putByValDirect(result, result.length, subStr);
532                 // 4. If lengthA = lim, return A.
533                 if (result.length == limit)
534                     return result;
535 
536                 // 5. Let p be e.
537                 position = endPosition;
538                 // 6. Let numberOfCaptures be ? ToLength(? Get(z, &quot;length&quot;)).
539                 // 7. Let numberOfCaptures be max(numberOfCaptures-1, 0).
<span class="line-modified">540                 let numberOfCaptures = matches.length &gt; 1 ? matches.length - 1 : 0;</span>
541 
542                 // 8. Let i be 1.
<span class="line-modified">543                 let i = 1;</span>
544                 // 9. Repeat, while i &lt;= numberOfCaptures,
545                 while (i &lt;= numberOfCaptures) {
546                     // a. Let nextCapture be ? Get(z, ! ToString(i)).
<span class="line-modified">547                     let nextCapture = matches[i];</span>
548                     // b. Perform ! CreateDataProperty(A, ! ToString(lengthA), nextCapture).
549                     // d. Let lengthA be lengthA + 1.
550                     @putByValDirect(result, result.length, nextCapture);
551                     // e. If lengthA = lim, return A.
552                     if (result.length == limit)
553                         return result;
554                     // c. Let i be i + 1.
555                     i++;
556                 }
557                 // 10. Let q be p.
558                 matchPosition = position;
559             }
560         }
561     }
562     // 20. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive).
<span class="line-modified">563     let remainingStr = @stringSubstrInternal.@call(str, position, size);</span>
564     // 21. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
565     @putByValDirect(result, result.length, remainingStr);
566     // 22. Return A.
567     return result;
568 }
569 
570 // ES 21.2.5.13 RegExp.prototype.test(string)
571 @intrinsic=RegExpTestIntrinsic
572 function test(strArg)
573 {
574     &quot;use strict&quot;;
575 
<span class="line-modified">576     let regexp = this;</span>
577 
578     // Check for observable side effects and call the fast path if there aren&#39;t any.
579     if (@isRegExpObject(regexp)
580         &amp;&amp; @tryGetById(regexp, &quot;exec&quot;) === @regExpBuiltinExec
581         &amp;&amp; typeof regexp.lastIndex === &quot;number&quot;)
582         return @regExpTestFast.@call(regexp, strArg);
583 
584     // 1. Let R be the this value.
585     // 2. If Type(R) is not Object, throw a TypeError exception.
586     if (!@isObject(regexp))
587         @throwTypeError(&quot;RegExp.prototype.test requires that |this| be an Object&quot;);
588 
589     // 3. Let string be ? ToString(S).
<span class="line-modified">590     let str = @toString(strArg);</span>
591 
592     // 4. Let match be ? RegExpExec(R, string).
<span class="line-modified">593     let match = @regExpExec(regexp, str);</span>
594 
595     // 5. If match is not null, return true; else return false.
596     if (match !== null)
597         return true;
598     return false;
599 }
</pre>
</td>
<td>
<hr />
<pre>
 31 
 32     @putByIdDirectPrivate(this, &quot;regExpStringIteratorRegExp&quot;, regExp);
 33     @putByIdDirectPrivate(this, &quot;regExpStringIteratorString&quot;, string);
 34     @putByIdDirectPrivate(this, &quot;regExpStringIteratorGlobal&quot;, global);
 35     @putByIdDirectPrivate(this, &quot;regExpStringIteratorUnicode&quot;, fullUnicode);
 36     @putByIdDirectPrivate(this, &quot;regExpStringIteratorDone&quot;, false);
 37 }
 38 
 39 @globalPrivate
 40 function advanceStringIndex(string, index, unicode)
 41 {
 42     // This function implements AdvanceStringIndex described in ES6 21.2.5.2.3.
 43     &quot;use strict&quot;;
 44 
 45     if (!unicode)
 46         return index + 1;
 47 
 48     if (index + 1 &gt;= string.length)
 49         return index + 1;
 50 
<span class="line-modified"> 51     var first = string.@charCodeAt(index);</span>
 52     if (first &lt; 0xD800 || first &gt; 0xDBFF)
 53         return index + 1;
 54 
<span class="line-modified"> 55     var second = string.@charCodeAt(index + 1);</span>
 56     if (second &lt; 0xDC00 || second &gt; 0xDFFF)
 57         return index + 1;
 58 
 59     return index + 2;
 60 }
 61 
 62 @globalPrivate
 63 function regExpExec(regexp, str)
 64 {
 65     &quot;use strict&quot;;
 66 
<span class="line-modified"> 67     var exec = regexp.exec;</span>
<span class="line-modified"> 68     var builtinExec = @regExpBuiltinExec;</span>
 69     if (exec !== builtinExec &amp;&amp; typeof exec === &quot;function&quot;) {
<span class="line-modified"> 70         var result = exec.@call(regexp, str);</span>
 71         if (result !== null &amp;&amp; !@isObject(result))
 72             @throwTypeError(&quot;The result of a RegExp exec must be null or an object&quot;);
 73         return result;
 74     }
 75     return builtinExec.@call(regexp, str);
 76 }
 77 
 78 @globalPrivate
 79 function hasObservableSideEffectsForRegExpMatch(regexp)
 80 {
 81     &quot;use strict&quot;;
 82 
 83     if (!@isRegExpObject(regexp))
 84         return true;
 85 
 86     // This is accessed by the RegExpExec internal function.
<span class="line-modified"> 87     var regexpExec = @tryGetById(regexp, &quot;exec&quot;);</span>
 88     if (regexpExec !== @regExpBuiltinExec)
 89         return true;
 90 
<span class="line-modified"> 91     var regexpGlobal = @tryGetById(regexp, &quot;global&quot;);</span>
 92     if (regexpGlobal !== @regExpProtoGlobalGetter)
 93         return true;
<span class="line-modified"> 94     var regexpUnicode = @tryGetById(regexp, &quot;unicode&quot;);</span>
 95     if (regexpUnicode !== @regExpProtoUnicodeGetter)
 96         return true;
 97 
 98     return typeof regexp.lastIndex !== &quot;number&quot;;
 99 }
100 
101 @globalPrivate
102 function matchSlow(regexp, str)
103 {
104     &quot;use strict&quot;;
105 
106     if (!regexp.global)
107         return @regExpExec(regexp, str);
108     
<span class="line-modified">109     var unicode = regexp.unicode;</span>
110     regexp.lastIndex = 0;
<span class="line-modified">111     var resultList = [];</span>
112 
113     // FIXME: It would be great to implement a solution similar to what we do in
114     // RegExpObject::matchGlobal(). It&#39;s not clear if this is possible, since this loop has
115     // effects. https://bugs.webkit.org/show_bug.cgi?id=158145
<span class="line-modified">116     var maximumReasonableMatchSize = 100000000;</span>
117 
118     while (true) {
<span class="line-modified">119         var result = @regExpExec(regexp, str);</span>
120         
121         if (result === null) {
122             if (resultList.length === 0)
123                 return null;
124             return resultList;
125         }
126 
127         if (resultList.length &gt; maximumReasonableMatchSize)
128             @throwOutOfMemoryError();
129 
<span class="line-modified">130         var resultString = @toString(result[0]);</span>
131 
132         if (!resultString.length)
133             regexp.lastIndex = @advanceStringIndex(str, regexp.lastIndex, unicode);
134 
135         resultList.@push(resultString);
136     }
137 }
138 
139 @overriddenName=&quot;[Symbol.match]&quot;
140 function match(strArg)
141 {
142     &quot;use strict&quot;;
143 
144     if (!@isObject(this))
145         @throwTypeError(&quot;RegExp.prototype.@@match requires that |this| be an Object&quot;);
146 
<span class="line-modified">147     var str = @toString(strArg);</span>
148 
149     // Check for observable side effects and call the fast path if there aren&#39;t any.
150     if (!@hasObservableSideEffectsForRegExpMatch(this))
151         return @regExpMatchFast.@call(this, str);
152     return @matchSlow(this, str);
153 }
154 
155 @overriddenName=&quot;[Symbol.matchAll]&quot;
156 function matchAll(strArg)
157 {
158     &quot;use strict&quot;;
159 
<span class="line-modified">160     var regExp = this;</span>
161     if (!@isObject(regExp))
162         @throwTypeError(&quot;RegExp.prototype.@@matchAll requires |this| to be an Object&quot;);
163 
<span class="line-modified">164     var string = @toString(strArg);</span>
<span class="line-modified">165     var Matcher = @speciesConstructor(regExp, @RegExp);</span>
166 
<span class="line-modified">167     var flags = @toString(regExp.flags);</span>
<span class="line-modified">168     var matcher = new Matcher(regExp, flags);</span>
169     matcher.lastIndex = @toLength(regExp.lastIndex);
170 
<span class="line-modified">171     var global = @stringIncludesInternal.@call(flags, &quot;g&quot;);</span>
<span class="line-modified">172     var fullUnicode = @stringIncludesInternal.@call(flags, &quot;u&quot;);</span>
173 
174     return new @RegExpStringIterator(matcher, string, global, fullUnicode);
175 }
176 
177 @overriddenName=&quot;[Symbol.replace]&quot;
178 function replace(strArg, replace)
179 {
180     &quot;use strict&quot;;
181 
<span class="line-modified">182     function getSubstitution(matched, str, position, captures, namedCaptures, replacement)</span>
183     {
184         &quot;use strict&quot;;
185 
<span class="line-modified">186         var matchLength = matched.length;</span>
<span class="line-modified">187         var stringLength = str.length;</span>
<span class="line-modified">188         var tailPos = position + matchLength;</span>
<span class="line-modified">189         var m = captures.length;</span>
<span class="line-modified">190         var replacementLength = replacement.length;</span>
<span class="line-modified">191         var result = &quot;&quot;;</span>
<span class="line-modified">192         var lastStart = 0;</span>
193 
<span class="line-modified">194         for (var start = 0; start = replacement.indexOf(&quot;$&quot;, lastStart), start !== -1; lastStart = start) {</span>
195             if (start - lastStart &gt; 0)
196                 result = result + replacement.substring(lastStart, start);
197             start++;
<span class="line-modified">198             var ch = replacement.charAt(start);</span>
199             if (ch === &quot;&quot;)
200                 result = result + &quot;$&quot;;
201             else {
202                 switch (ch)
203                 {
204                 case &quot;$&quot;:
205                     result = result + &quot;$&quot;;
206                     start++;
207                     break;
208                 case &quot;&amp;&quot;:
209                     result = result + matched;
210                     start++;
211                     break;
212                 case &quot;`&quot;:
213                     if (position &gt; 0)
214                         result = result + str.substring(0, position);
215                     start++;
216                     break;
217                 case &quot;&#39;&quot;:
218                     if (tailPos &lt; stringLength)
219                         result = result + str.substring(tailPos);
220                     start++;
221                     break;
<span class="line-added">222                 case &quot;&lt;&quot;:</span>
<span class="line-added">223                     if (namedCaptures !== @undefined) {</span>
<span class="line-added">224                         var groupNameStartIndex = start + 1;</span>
<span class="line-added">225                         var groupNameEndIndex = replacement.indexOf(&quot;&gt;&quot;, groupNameStartIndex);</span>
<span class="line-added">226                         if (groupNameEndIndex !== -1) {</span>
<span class="line-added">227                             var groupName = replacement.substring(groupNameStartIndex, groupNameEndIndex);</span>
<span class="line-added">228                             var capture = namedCaptures[groupName];</span>
<span class="line-added">229                             if (capture !== @undefined)</span>
<span class="line-added">230                                 result = result + @toString(capture);</span>
<span class="line-added">231 </span>
<span class="line-added">232                             start = groupNameEndIndex + 1;</span>
<span class="line-added">233                             break;</span>
<span class="line-added">234                         }</span>
<span class="line-added">235                     }</span>
<span class="line-added">236 </span>
<span class="line-added">237                     result = result + &quot;$&lt;&quot;;</span>
<span class="line-added">238                     start++;</span>
<span class="line-added">239                     break;</span>
240                 default:
<span class="line-modified">241                     var chCode = ch.charCodeAt(0);</span>
242                     if (chCode &gt;= 0x30 &amp;&amp; chCode &lt;= 0x39) {
<span class="line-added">243                         var originalStart = start - 1;</span>
244                         start++;
<span class="line-modified">245 </span>
<span class="line-modified">246                         var n = chCode - 0x30;</span>
<span class="line-added">247                         if (n &gt; m) {</span>
<span class="line-added">248                             result = result + replacement.substring(originalStart, start);</span>
249                             break;
<span class="line-added">250                         }</span>
<span class="line-added">251 </span>
252                         if (start &lt; replacementLength) {
<span class="line-modified">253                             var nextChCode = replacement.charCodeAt(start);</span>
254                             if (nextChCode &gt;= 0x30 &amp;&amp; nextChCode &lt;= 0x39) {
<span class="line-modified">255                                 var nn = 10 * n + nextChCode - 0x30;</span>
256                                 if (nn &lt;= m) {
257                                     n = nn;
258                                     start++;
259                                 }
260                             }
261                         }
262 
<span class="line-modified">263                         if (n == 0) {</span>
<span class="line-added">264                             result = result + replacement.substring(originalStart, start);</span>
265                             break;
<span class="line-added">266                         }</span>
267 
<span class="line-modified">268                         var capture = captures[n - 1];</span>
<span class="line-modified">269                         if (capture !== @undefined)</span>
<span class="line-added">270                             result = result + capture;</span>
271                     } else
272                         result = result + &quot;$&quot;;
273                     break;
274                 }
275             }
276         }
277 
278         return result + replacement.substring(lastStart);
279     }
280 
281     if (!@isObject(this))
282         @throwTypeError(&quot;RegExp.prototype.@@replace requires that |this| be an Object&quot;);
283 
<span class="line-modified">284     var regexp = this;</span>
285 
<span class="line-modified">286     var str = @toString(strArg);</span>
<span class="line-modified">287     var stringLength = str.length;</span>
<span class="line-modified">288     var functionalReplace = typeof replace === &#39;function&#39;;</span>
289 
290     if (!functionalReplace)
291         replace = @toString(replace);
292 
<span class="line-modified">293     var global = regexp.global;</span>
<span class="line-modified">294     var unicode = false;</span>
295 
296     if (global) {
297         unicode = regexp.unicode;
298         regexp.lastIndex = 0;
299     }
300 
<span class="line-modified">301     var resultList = [];</span>
<span class="line-modified">302     var result;</span>
<span class="line-modified">303     var done = false;</span>
304     while (!done) {
305         result = @regExpExec(regexp, str);
306 
307         if (result === null)
308             done = true;
309         else {
310             resultList.@push(result);
311             if (!global)
312                 done = true;
313             else {
<span class="line-modified">314                 var matchStr = @toString(result[0]);</span>
315 
316                 if (!matchStr.length)
317                     regexp.lastIndex = @advanceStringIndex(str, regexp.lastIndex, unicode);
318             }
319         }
320     }
321 
<span class="line-modified">322     var accumulatedResult = &quot;&quot;;</span>
<span class="line-modified">323     var nextSourcePosition = 0;</span>
<span class="line-modified">324     var lastPosition = 0;</span>
325 
<span class="line-modified">326     for (var i = 0, resultListLength = resultList.length; i &lt; resultListLength; ++i) {</span>
<span class="line-modified">327         var result = resultList[i];</span>
<span class="line-modified">328         var nCaptures = result.length - 1;</span>
329         if (nCaptures &lt; 0)
330             nCaptures = 0;
<span class="line-modified">331         var matched = @toString(result[0]);</span>
<span class="line-modified">332         var matchLength = matched.length;</span>
<span class="line-modified">333         var position = result.index;</span>
334         position = (position &gt; stringLength) ? stringLength : position;
335         position = (position &lt; 0) ? 0 : position;
336 
<span class="line-modified">337         var captures = [];</span>
<span class="line-modified">338         for (var n = 1; n &lt;= nCaptures; n++) {</span>
<span class="line-modified">339             var capN = result[n];</span>
340             if (capN !== @undefined)
341                 capN = @toString(capN);
<span class="line-modified">342             captures.@push(capN);</span>
343         }
344 
<span class="line-modified">345         var replacement;</span>
<span class="line-added">346         var namedCaptures = result.groups;</span>
347 
348         if (functionalReplace) {
<span class="line-modified">349             var replacerArgs = [ matched ].concat(captures);</span>
350             replacerArgs.@push(position);
351             replacerArgs.@push(str);
352 
<span class="line-modified">353             if (namedCaptures !== @undefined)</span>
<span class="line-added">354                 replacerArgs.@push(namedCaptures);</span>
<span class="line-added">355 </span>
<span class="line-added">356             var replValue = replace.@apply(@undefined, replacerArgs);</span>
357             replacement = @toString(replValue);
<span class="line-modified">358         } else {</span>
<span class="line-modified">359             if (namedCaptures !== @undefined)</span>
<span class="line-added">360                 namedCaptures = @toObject(namedCaptures, &quot;RegExp.prototype[Symbol.replace] requires &#39;groups&#39; property of a match not be null&quot;);</span>
<span class="line-added">361 </span>
<span class="line-added">362             replacement = getSubstitution(matched, str, position, captures, namedCaptures, replace);</span>
<span class="line-added">363         }</span>
364 
365         if (position &gt;= nextSourcePosition &amp;&amp; position &gt;= lastPosition) {
366             accumulatedResult = accumulatedResult + str.substring(nextSourcePosition, position) + replacement;
367             nextSourcePosition = position + matchLength;
368             lastPosition = position;
369         }
370     }
371 
372     if (nextSourcePosition &gt;= stringLength)
373         return  accumulatedResult;
374 
375     return accumulatedResult + str.substring(nextSourcePosition);
376 }
377 
378 // 21.2.5.9 RegExp.prototype[@@search] (string)
379 @overriddenName=&quot;[Symbol.search]&quot;
380 function search(strArg)
381 {
382     &quot;use strict&quot;;
383 
<span class="line-modified">384     var regexp = this;</span>
385 
386     // Check for observable side effects and call the fast path if there aren&#39;t any.
387     if (@isRegExpObject(regexp)
388         &amp;&amp; @tryGetById(regexp, &quot;exec&quot;) === @regExpBuiltinExec
389         &amp;&amp; typeof regexp.lastIndex === &quot;number&quot;)
390         return @regExpSearchFast.@call(regexp, strArg);
391 
392     // 1. Let rx be the this value.
393     // 2. If Type(rx) is not Object, throw a TypeError exception.
394     if (!@isObject(this))
395         @throwTypeError(&quot;RegExp.prototype.@@search requires that |this| be an Object&quot;);
396 
397     // 3. Let S be ? ToString(string).
<span class="line-modified">398     var str = @toString(strArg)</span>
399 
400     // 4. Let previousLastIndex be ? Get(rx, &quot;lastIndex&quot;).
<span class="line-modified">401     var previousLastIndex = regexp.lastIndex;</span>
402 
403     // 5.If SameValue(previousLastIndex, 0) is false, then
404     // 5.a. Perform ? Set(rx, &quot;lastIndex&quot;, 0, true).
405     // FIXME: Add SameValue support. https://bugs.webkit.org/show_bug.cgi?id=173226
406     if (previousLastIndex !== 0)
407         regexp.lastIndex = 0;
408 
409     // 6. Let result be ? RegExpExec(rx, S).
<span class="line-modified">410     var result = @regExpExec(regexp, str);</span>
411 
412     // 7. Let currentLastIndex be ? Get(rx, &quot;lastIndex&quot;).
413     // 8. If SameValue(currentLastIndex, previousLastIndex) is false, then
414     // 8.a. Perform ? Set(rx, &quot;lastIndex&quot;, previousLastIndex, true).
415     // FIXME: Add SameValue support. https://bugs.webkit.org/show_bug.cgi?id=173226
416     if (regexp.lastIndex !== previousLastIndex)
417         regexp.lastIndex = previousLastIndex;
418 
419     // 9. If result is null, return -1.
420     if (result === null)
421         return -1;
422 
423     // 10. Return ? Get(result, &quot;index&quot;).
424     return result.index;
425 }
426 
427 @globalPrivate
428 function hasObservableSideEffectsForRegExpSplit(regexp)
429 {
430     &quot;use strict&quot;;
431 
432     if (!@isRegExpObject(regexp))
433         return true;
434 
435     // This is accessed by the RegExpExec internal function.
<span class="line-modified">436     var regexpExec = @tryGetById(regexp, &quot;exec&quot;);</span>
437     if (regexpExec !== @regExpBuiltinExec)
438         return true;
439     
440     // This is accessed by step 5 below.
<span class="line-modified">441     var regexpFlags = @tryGetById(regexp, &quot;flags&quot;);</span>
442     if (regexpFlags !== @regExpProtoFlagsGetter)
443         return true;
444     
445     // These are accessed by the builtin flags getter.
<span class="line-modified">446     var regexpGlobal = @tryGetById(regexp, &quot;global&quot;);</span>
447     if (regexpGlobal !== @regExpProtoGlobalGetter)
448         return true;
<span class="line-modified">449     var regexpIgnoreCase = @tryGetById(regexp, &quot;ignoreCase&quot;);</span>
450     if (regexpIgnoreCase !== @regExpProtoIgnoreCaseGetter)
451         return true;
<span class="line-modified">452     var regexpMultiline = @tryGetById(regexp, &quot;multiline&quot;);</span>
453     if (regexpMultiline !== @regExpProtoMultilineGetter)
454         return true;
<span class="line-modified">455     var regexpSticky = @tryGetById(regexp, &quot;sticky&quot;);</span>
456     if (regexpSticky !== @regExpProtoStickyGetter)
457         return true;
<span class="line-modified">458     var regexpUnicode = @tryGetById(regexp, &quot;unicode&quot;);</span>
459     if (regexpUnicode !== @regExpProtoUnicodeGetter)
460         return true;
461     
462     // This is accessed by the RegExp species constructor.
<span class="line-modified">463     var regexpSource = @tryGetById(regexp, &quot;source&quot;);</span>
464     if (regexpSource !== @regExpProtoSourceGetter)
465         return true;
466 
467     return typeof regexp.lastIndex !== &quot;number&quot;;
468 }
469 
470 // ES 21.2.5.11 RegExp.prototype[@@split](string, limit)
471 @overriddenName=&quot;[Symbol.split]&quot;
472 function split(string, limit)
473 {
474     &quot;use strict&quot;;
475 
476     // 1. Let rx be the this value.
477     // 2. If Type(rx) is not Object, throw a TypeError exception.
478     if (!@isObject(this))
479         @throwTypeError(&quot;RegExp.prototype.@@split requires that |this| be an Object&quot;);
<span class="line-modified">480     var regexp = this;</span>
481 
482     // 3. Let S be ? ToString(string).
<span class="line-modified">483     var str = @toString(string);</span>
484 
485     // 4. Let C be ? SpeciesConstructor(rx, %RegExp%).
<span class="line-modified">486     var speciesConstructor = @speciesConstructor(regexp, @RegExp);</span>
487 
488     if (speciesConstructor === @RegExp &amp;&amp; !@hasObservableSideEffectsForRegExpSplit(regexp))
489         return @regExpSplitFast.@call(regexp, str, limit);
490 
491     // 5. Let flags be ? ToString(? Get(rx, &quot;flags&quot;)).
<span class="line-modified">492     var flags = @toString(regexp.flags);</span>
493 
<span class="line-modified">494     // 6. If flags contains &quot;u&quot;, var unicodeMatching be true.</span>
495     // 7. Else, let unicodeMatching be false.
<span class="line-modified">496     var unicodeMatching = @stringIncludesInternal.@call(flags, &quot;u&quot;);</span>
<span class="line-modified">497     // 8. If flags contains &quot;y&quot;, var newFlags be flags.</span>
498     // 9. Else, let newFlags be the string that is the concatenation of flags and &quot;y&quot;.
<span class="line-modified">499     var newFlags = @stringIncludesInternal.@call(flags, &quot;y&quot;) ? flags : flags + &quot;y&quot;;</span>
500 
501     // 10. Let splitter be ? Construct(C, « rx, newFlags »).
<span class="line-modified">502     var splitter = new speciesConstructor(regexp, newFlags);</span>
503 
504     // We need to check again for RegExp subclasses that will fail the speciesConstructor test
505     // but can still use the fast path after we invoke the constructor above.
506     if (!@hasObservableSideEffectsForRegExpSplit(splitter))
507         return @regExpSplitFast.@call(splitter, str, limit);
508 
509     // 11. Let A be ArrayCreate(0).
510     // 12. Let lengthA be 0.
<span class="line-modified">511     var result = [];</span>
512 
<span class="line-modified">513     // 13. If limit is undefined, let lim be 2^32-1; else var lim be ? ToUint32(limit).</span>
514     limit = (limit === @undefined) ? 0xffffffff : limit &gt;&gt;&gt; 0;
515 
516     // 16. If lim = 0, return A.
517     if (!limit)
518         return result;
519 
520     // 14. [Defered from above] Let size be the number of elements in S.
<span class="line-modified">521     var size = str.length;</span>
522 
523     // 17. If size = 0, then
524     if (!size) {
525         // a. Let z be ? RegExpExec(splitter, S).
<span class="line-modified">526         var z = @regExpExec(splitter, str);</span>
527         // b. If z is not null, return A.
528         if (z != null)
529             return result;
530         // c. Perform ! CreateDataProperty(A, &quot;0&quot;, S).
531         @putByValDirect(result, 0, str);
532         // d. Return A.
533         return result;
534     }
535 
536     // 15. [Defered from above] Let p be 0.
<span class="line-modified">537     var position = 0;</span>
538     // 18. Let q be p.
<span class="line-modified">539     var matchPosition = 0;</span>
540 
541     // 19. Repeat, while q &lt; size
542     while (matchPosition &lt; size) {
543         // a. Perform ? Set(splitter, &quot;lastIndex&quot;, q, true).
544         splitter.lastIndex = matchPosition;
545         // b. Let z be ? RegExpExec(splitter, S).
<span class="line-modified">546         var matches = @regExpExec(splitter, str);</span>
547         // c. If z is null, let q be AdvanceStringIndex(S, q, unicodeMatching).
548         if (matches === null)
549             matchPosition = @advanceStringIndex(str, matchPosition, unicodeMatching);
550         // d. Else z is not null,
551         else {
552             // i. Let e be ? ToLength(? Get(splitter, &quot;lastIndex&quot;)).
<span class="line-modified">553             var endPosition = @toLength(splitter.lastIndex);</span>
554             // ii. Let e be min(e, size).
555             endPosition = (endPosition &lt;= size) ? endPosition : size;
556             // iii. If e = p, let q be AdvanceStringIndex(S, q, unicodeMatching).
557             if (endPosition === position)
558                 matchPosition = @advanceStringIndex(str, matchPosition, unicodeMatching);
559             // iv. Else e != p,
560             else {
561                 // 1. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through q (exclusive).
<span class="line-modified">562                 var subStr = @stringSubstrInternal.@call(str, position, matchPosition - position);</span>
563                 // 2. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
564                 // 3. Let lengthA be lengthA + 1.
565                 @putByValDirect(result, result.length, subStr);
566                 // 4. If lengthA = lim, return A.
567                 if (result.length == limit)
568                     return result;
569 
570                 // 5. Let p be e.
571                 position = endPosition;
572                 // 6. Let numberOfCaptures be ? ToLength(? Get(z, &quot;length&quot;)).
573                 // 7. Let numberOfCaptures be max(numberOfCaptures-1, 0).
<span class="line-modified">574                 var numberOfCaptures = matches.length &gt; 1 ? matches.length - 1 : 0;</span>
575 
576                 // 8. Let i be 1.
<span class="line-modified">577                 var i = 1;</span>
578                 // 9. Repeat, while i &lt;= numberOfCaptures,
579                 while (i &lt;= numberOfCaptures) {
580                     // a. Let nextCapture be ? Get(z, ! ToString(i)).
<span class="line-modified">581                     var nextCapture = matches[i];</span>
582                     // b. Perform ! CreateDataProperty(A, ! ToString(lengthA), nextCapture).
583                     // d. Let lengthA be lengthA + 1.
584                     @putByValDirect(result, result.length, nextCapture);
585                     // e. If lengthA = lim, return A.
586                     if (result.length == limit)
587                         return result;
588                     // c. Let i be i + 1.
589                     i++;
590                 }
591                 // 10. Let q be p.
592                 matchPosition = position;
593             }
594         }
595     }
596     // 20. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive).
<span class="line-modified">597     var remainingStr = @stringSubstrInternal.@call(str, position, size);</span>
598     // 21. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
599     @putByValDirect(result, result.length, remainingStr);
600     // 22. Return A.
601     return result;
602 }
603 
604 // ES 21.2.5.13 RegExp.prototype.test(string)
605 @intrinsic=RegExpTestIntrinsic
606 function test(strArg)
607 {
608     &quot;use strict&quot;;
609 
<span class="line-modified">610     var regexp = this;</span>
611 
612     // Check for observable side effects and call the fast path if there aren&#39;t any.
613     if (@isRegExpObject(regexp)
614         &amp;&amp; @tryGetById(regexp, &quot;exec&quot;) === @regExpBuiltinExec
615         &amp;&amp; typeof regexp.lastIndex === &quot;number&quot;)
616         return @regExpTestFast.@call(regexp, strArg);
617 
618     // 1. Let R be the this value.
619     // 2. If Type(R) is not Object, throw a TypeError exception.
620     if (!@isObject(regexp))
621         @throwTypeError(&quot;RegExp.prototype.test requires that |this| be an Object&quot;);
622 
623     // 3. Let string be ? ToString(S).
<span class="line-modified">624     var str = @toString(strArg);</span>
625 
626     // 4. Let match be ? RegExpExec(R, string).
<span class="line-modified">627     var match = @regExpExec(regexp, str);</span>
628 
629     // 5. If match is not null, return true; else return false.
630     if (match !== null)
631         return true;
632     return false;
633 }
</pre>
</td>
</tr>
</table>
<center><a href="PromisePrototype.js.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegExpStringIteratorPrototype.js.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
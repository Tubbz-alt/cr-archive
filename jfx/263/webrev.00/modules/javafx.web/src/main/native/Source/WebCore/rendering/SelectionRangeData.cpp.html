<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/SelectionRangeData.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014 Igalia S.L.
  3  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1. Redistributions of source code must retain the above
 10  *    copyright notice, this list of conditions and the following
 11  *    disclaimer.
 12  * 2. Redistributions in binary form must reproduce the above
 13  *    copyright notice, this list of conditions and the following
 14  *    disclaimer in the documentation and/or other materials
 15  *    provided with the distribution.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 19  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 20  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
 21  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 22  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 23  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 24  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 25  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 26  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 27  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 28  * SUCH DAMAGE.
 29  */
 30 
 31 #include &quot;config.h&quot;
 32 #include &quot;SelectionRangeData.h&quot;
 33 
 34 #include &quot;Document.h&quot;
 35 #include &quot;FrameSelection.h&quot;
 36 #include &quot;Position.h&quot;
 37 #include &quot;Range.h&quot;
 38 #include &quot;RenderLayer.h&quot;
 39 #include &quot;RenderMultiColumnSpannerPlaceholder.h&quot;
 40 #include &quot;RenderObject.h&quot;
 41 #include &quot;RenderView.h&quot;
 42 #include &quot;VisibleSelection.h&quot;
 43 
 44 namespace WebCore {
 45 
 46 namespace { // See bug #177808.
 47 
 48 struct SelectionData {
 49     using RendererMap = HashMap&lt;RenderObject*, std::unique_ptr&lt;RenderSelectionInfo&gt;&gt;;
 50     using RenderBlockMap = HashMap&lt;const RenderBlock*, std::unique_ptr&lt;RenderBlockSelectionInfo&gt;&gt;;
 51 
 52     Optional&lt;unsigned&gt; startOffset;
 53     Optional&lt;unsigned&gt; endOffset;
 54     RendererMap renderers;
 55     RenderBlockMap blocks;
 56 };
 57 
 58 class SelectionIterator {
 59 public:
 60     SelectionIterator(RenderObject* start)
 61         : m_current(start)
 62     {
 63         checkForSpanner();
 64     }
 65 
 66     RenderObject* current() const
 67     {
 68         return m_current;
 69     }
 70 
 71     RenderObject* next()
 72     {
 73         RenderObject* currentSpan = m_spannerStack.isEmpty() ? nullptr : m_spannerStack.last()-&gt;spanner();
 74         m_current = m_current-&gt;nextInPreOrder(currentSpan);
 75         checkForSpanner();
 76         if (!m_current &amp;&amp; currentSpan) {
 77             RenderObject* placeholder = m_spannerStack.last();
 78             m_spannerStack.removeLast();
 79             m_current = placeholder-&gt;nextInPreOrder();
 80             checkForSpanner();
 81         }
 82         return m_current;
 83     }
 84 
 85 private:
 86     void checkForSpanner()
 87     {
 88         if (!is&lt;RenderMultiColumnSpannerPlaceholder&gt;(m_current))
 89             return;
 90         auto&amp; placeholder = downcast&lt;RenderMultiColumnSpannerPlaceholder&gt;(*m_current);
 91         m_spannerStack.append(&amp;placeholder);
 92         m_current = placeholder.spanner();
 93     }
 94 
 95     RenderObject* m_current { nullptr };
 96     Vector&lt;RenderMultiColumnSpannerPlaceholder*&gt; m_spannerStack;
 97 };
 98 
 99 } // anonymous namespace
100 
101 static RenderObject* rendererAfterOffset(const RenderObject&amp; renderer, unsigned offset)
102 {
103     auto* child = renderer.childAt(offset);
104     return child ? child : renderer.nextInPreOrderAfterChildren();
105 }
106 
107 static bool isValidRendererForSelection(const RenderObject&amp; renderer, const SelectionRangeData::Context&amp; selection)
108 {
109     return (renderer.canBeSelectionLeaf() || &amp;renderer == selection.start() || &amp;renderer == selection.end())
110         &amp;&amp; renderer.selectionState() != RenderObject::SelectionNone
111         &amp;&amp; renderer.containingBlock();
112 }
113 
114 static RenderBlock* containingBlockBelowView(const RenderObject&amp; renderer)
115 {
116     auto* containingBlock = renderer.containingBlock();
117     return is&lt;RenderView&gt;(containingBlock) ? nullptr : containingBlock;
118 }
119 
120 static SelectionData collect(const SelectionRangeData::Context&amp; selection, bool repaintDifference)
121 {
122     SelectionData oldSelectionData { selection.startOffset(), selection.endOffset(), { }, { } };
123     // Blocks contain selected objects and fill gaps between them, either on the left, right, or in between lines and blocks.
124     // In order to get the repaint rect right, we have to examine left, middle, and right rects individually, since otherwise
125     // the union of those rects might remain the same even when changes have occurred.
126     auto* start = selection.start();
127     RenderObject* stop = nullptr;
128     if (selection.end())
129         stop = rendererAfterOffset(*selection.end(), selection.endOffset().value());
130     SelectionIterator selectionIterator(start);
131     while (start &amp;&amp; start != stop) {
132         if (isValidRendererForSelection(*start, selection)) {
133             // Blocks are responsible for painting line gaps and margin gaps. They must be examined as well.
134             oldSelectionData.renderers.set(start, makeUnique&lt;RenderSelectionInfo&gt;(*start, true));
135             if (repaintDifference) {
136                 for (auto* block = containingBlockBelowView(*start); block; block = containingBlockBelowView(*block)) {
137                     auto&amp; blockInfo = oldSelectionData.blocks.add(block, nullptr).iterator-&gt;value;
138                     if (blockInfo)
139                         break;
140                     blockInfo = makeUnique&lt;RenderBlockSelectionInfo&gt;(*block);
141                 }
142             }
143         }
144         start = selectionIterator.next();
145     }
146     return oldSelectionData;
147 }
148 
149 SelectionRangeData::SelectionRangeData(RenderView&amp; view)
150     : m_renderView(view)
151 #if ENABLE(SERVICE_CONTROLS)
152     , m_selectionRectGatherer(view)
153 #endif
154 {
155 }
156 
157 void SelectionRangeData::setContext(const Context&amp; context)
158 {
159     ASSERT(context.start() &amp;&amp; context.end());
160     m_selectionContext = context;
161 }
162 
163 RenderObject::SelectionState SelectionRangeData::selectionStateForRenderer(RenderObject&amp; renderer)
164 {
165     // FIXME: we shouldln&#39;t have to check that a renderer is a descendant of the render node
166     // from the range. This is likely because we aren&#39;t using VisiblePositions yet.
167     // Planned fix in a followup: &lt;rdar://problem/58095923&gt;
168     // https://bugs.webkit.org/show_bug.cgi?id=205529
169 
170     if (&amp;renderer == m_selectionContext.start()) {
171         if (m_selectionContext.start() &amp;&amp; m_selectionContext.end() &amp;&amp; m_selectionContext.start() == m_selectionContext.end())
172             return RenderObject::SelectionBoth;
173         if (m_selectionContext.start())
174             return RenderObject::SelectionStart;
175     }
176     if (&amp;renderer == m_selectionContext.end())
177         return RenderObject::SelectionEnd;
178 
179     RenderObject* selectionEnd = nullptr;
180     auto* selectionDataEnd = m_selectionContext.end();
181     if (selectionDataEnd)
182         selectionEnd = rendererAfterOffset(*selectionDataEnd, m_selectionContext.endOffset().value());
183     SelectionIterator selectionIterator(m_selectionContext.start());
184     for (auto* currentRenderer = m_selectionContext.start(); currentRenderer &amp;&amp; currentRenderer != m_selectionContext.end(); currentRenderer = selectionIterator.next()) {
185         if (currentRenderer == m_selectionContext.start() || currentRenderer == m_selectionContext.end())
186             continue;
187         if (!currentRenderer-&gt;canBeSelectionLeaf())
188             continue;
189         if (&amp;renderer == currentRenderer)
190             return RenderObject::SelectionInside;
191     }
192     return RenderObject::SelectionNone;
193 
194 }
195 
196 void SelectionRangeData::set(const Context&amp; selection, RepaintMode blockRepaintMode)
197 {
198     if ((selection.start() &amp;&amp; !selection.end()) || (selection.end() &amp;&amp; !selection.start()))
199         return;
200     // Just return if the selection hasn&#39;t changed.
201     auto isCaret = m_renderView.frame().selection().isCaret();
202     if (selection == m_selectionContext &amp;&amp; m_selectionWasCaret == isCaret)
203         return;
204 #if ENABLE(SERVICE_CONTROLS)
205     // Clear the current rects and create a notifier for the new rects we are about to gather.
206     // The Notifier updates the Editor when it goes out of scope and is destroyed.
207     auto rectNotifier = m_selectionRectGatherer.clearAndCreateNotifier();
208 #endif
209     m_selectionWasCaret = isCaret;
210     apply(selection, blockRepaintMode);
211 }
212 
213 void SelectionRangeData::clear()
214 {
215     m_renderView.layer()-&gt;repaintBlockSelectionGaps();
216     set({ }, SelectionRangeData::RepaintMode::NewMinusOld);
217 }
218 
219 void SelectionRangeData::repaint() const
220 {
221     HashSet&lt;RenderBlock*&gt; processedBlocks;
222     RenderObject* end = nullptr;
223     if (m_selectionContext.end())
224         end = rendererAfterOffset(*m_selectionContext.end(), m_selectionContext.endOffset().value());
225     SelectionIterator selectionIterator(m_selectionContext.start());
226     for (auto* renderer = selectionIterator.current(); renderer &amp;&amp; renderer != end; renderer = selectionIterator.next()) {
227         if (!renderer-&gt;canBeSelectionLeaf() &amp;&amp; renderer != m_selectionContext.start() &amp;&amp; renderer != m_selectionContext.end())
228             continue;
229         if (renderer-&gt;selectionState() == RenderObject::SelectionNone)
230             continue;
231         RenderSelectionInfo(*renderer, true).repaint();
232         // Blocks are responsible for painting line gaps and margin gaps. They must be examined as well.
233         for (auto* block = containingBlockBelowView(*renderer); block; block = containingBlockBelowView(*block)) {
234             if (!processedBlocks.add(block).isNewEntry)
235                 break;
236             RenderSelectionInfo(*block, true).repaint();
237         }
238     }
239 }
240 
241 IntRect SelectionRangeData::collectBounds(ClipToVisibleContent clipToVisibleContent) const
242 {
243     SelectionData::RendererMap renderers;
244     auto* start = m_selectionContext.start();
245     RenderObject* stop = nullptr;
246     if (m_selectionContext.end())
247         stop = rendererAfterOffset(*m_selectionContext.end(), m_selectionContext.endOffset().value());
248     SelectionIterator selectionIterator(start);
249     while (start &amp;&amp; start != stop) {
250         if ((start-&gt;canBeSelectionLeaf() || start == m_selectionContext.start() || start == m_selectionContext.end())
251             &amp;&amp; start-&gt;selectionState() != RenderObject::SelectionNone) {
252             // Blocks are responsible for painting line gaps and margin gaps. They must be examined as well.
253             renderers.set(start, makeUnique&lt;RenderSelectionInfo&gt;(*start, clipToVisibleContent == ClipToVisibleContent::Yes));
254             auto* block = start-&gt;containingBlock();
255             while (block &amp;&amp; !is&lt;RenderView&gt;(*block)) {
256                 std::unique_ptr&lt;RenderSelectionInfo&gt;&amp; blockInfo = renderers.add(block, nullptr).iterator-&gt;value;
257                 if (blockInfo)
258                     break;
259                 blockInfo = makeUnique&lt;RenderSelectionInfo&gt;(*block, clipToVisibleContent == ClipToVisibleContent::Yes);
260                 block = block-&gt;containingBlock();
261             }
262         }
263         start = selectionIterator.next();
264     }
265 
266     // Now create a single bounding box rect that encloses the whole selection.
267     LayoutRect selectionRect;
268     for (auto&amp; info : renderers.values()) {
269         // RenderSelectionInfo::rect() is in the coordinates of the repaintContainer, so map to page coordinates.
270         LayoutRect currentRect = info-&gt;rect();
271         if (auto* repaintContainer = info-&gt;repaintContainer()) {
272             FloatQuad absQuad = repaintContainer-&gt;localToAbsoluteQuad(FloatRect(currentRect));
273             currentRect = absQuad.enclosingBoundingBox();
274         }
275         selectionRect.unite(currentRect);
276     }
277     return snappedIntRect(selectionRect);
278 }
279 
280 void SelectionRangeData::apply(const Context&amp; newSelection, RepaintMode blockRepaintMode)
281 {
282     auto oldSelectionData = collect(m_selectionContext, blockRepaintMode == RepaintMode::NewXOROld);
283     // Remove current selection.
284     for (auto* renderer : oldSelectionData.renderers.keys())
285         renderer-&gt;setSelectionStateIfNeeded(RenderObject::SelectionNone);
286     m_selectionContext = newSelection;
287     auto* selectionStart = m_selectionContext.start();
288     // Update the selection status of all objects between selectionStart and selectionEnd
289     if (selectionStart &amp;&amp; selectionStart == m_selectionContext.end())
290         selectionStart-&gt;setSelectionStateIfNeeded(RenderObject::SelectionBoth);
291     else {
292         if (selectionStart)
293             selectionStart-&gt;setSelectionStateIfNeeded(RenderObject::SelectionStart);
294         if (auto* end = m_selectionContext.end())
295             end-&gt;setSelectionStateIfNeeded(RenderObject::SelectionEnd);
296     }
297 
298     RenderObject* selectionEnd = nullptr;
299     auto* selectionDataEnd = m_selectionContext.end();
300     if (selectionDataEnd)
301         selectionEnd = rendererAfterOffset(*selectionDataEnd, m_selectionContext.endOffset().value());
302     SelectionIterator selectionIterator(selectionStart);
303     for (auto* currentRenderer = selectionStart; currentRenderer &amp;&amp; currentRenderer != selectionEnd; currentRenderer = selectionIterator.next()) {
304         if (currentRenderer == selectionStart || currentRenderer == m_selectionContext.end())
305             continue;
306         if (!currentRenderer-&gt;canBeSelectionLeaf())
307             continue;
308         currentRenderer-&gt;setSelectionStateIfNeeded(RenderObject::SelectionInside);
309     }
310 
311     if (blockRepaintMode != RepaintMode::Nothing)
312         m_renderView.layer()-&gt;clearBlockSelectionGapsBounds();
313 
314     // Now that the selection state has been updated for the new objects, walk them again and
315     // put them in the new objects list.
316     SelectionData::RendererMap newSelectedRenderers;
317     SelectionData::RenderBlockMap newSelectedBlocks;
318     selectionIterator = SelectionIterator(selectionStart);
319     for (auto* currentRenderer = selectionStart; currentRenderer &amp;&amp; currentRenderer != selectionEnd; currentRenderer = selectionIterator.next()) {
320         if (isValidRendererForSelection(*currentRenderer, m_selectionContext)) {
321             std::unique_ptr&lt;RenderSelectionInfo&gt; selectionInfo = makeUnique&lt;RenderSelectionInfo&gt;(*currentRenderer, true);
322 #if ENABLE(SERVICE_CONTROLS)
323             for (auto&amp; rect : selectionInfo-&gt;collectedSelectionRects())
324                 m_selectionRectGatherer.addRect(selectionInfo-&gt;repaintContainer(), rect);
325             if (!currentRenderer-&gt;isTextOrLineBreak())
326                 m_selectionRectGatherer.setTextOnly(false);
327 #endif
328             newSelectedRenderers.set(currentRenderer, WTFMove(selectionInfo));
329             auto* containingBlock = currentRenderer-&gt;containingBlock();
330             while (containingBlock &amp;&amp; !is&lt;RenderView&gt;(*containingBlock)) {
331                 std::unique_ptr&lt;RenderBlockSelectionInfo&gt;&amp; blockInfo = newSelectedBlocks.add(containingBlock, nullptr).iterator-&gt;value;
332                 if (blockInfo)
333                     break;
334                 blockInfo = makeUnique&lt;RenderBlockSelectionInfo&gt;(*containingBlock);
335                 containingBlock = containingBlock-&gt;containingBlock();
336 #if ENABLE(SERVICE_CONTROLS)
337                 m_selectionRectGatherer.addGapRects(blockInfo-&gt;repaintContainer(), blockInfo-&gt;rects());
338 #endif
339             }
340         }
341     }
342 
343     if (blockRepaintMode == RepaintMode::Nothing)
344         return;
345 
346     // Have any of the old selected objects changed compared to the new selection?
347     for (auto&amp; selectedRendererInfo : oldSelectionData.renderers) {
348         auto* renderer = selectedRendererInfo.key;
349         auto* newInfo = newSelectedRenderers.get(renderer);
350         auto* oldInfo = selectedRendererInfo.value.get();
351         if (!newInfo || oldInfo-&gt;rect() != newInfo-&gt;rect() || oldInfo-&gt;state() != newInfo-&gt;state()
352             || (m_selectionContext.start() == renderer &amp;&amp; oldSelectionData.startOffset != m_selectionContext.startOffset())
353             || (m_selectionContext.end() == renderer &amp;&amp; oldSelectionData.endOffset != m_selectionContext.endOffset())) {
354             oldInfo-&gt;repaint();
355             if (newInfo) {
356                 newInfo-&gt;repaint();
357                 newSelectedRenderers.remove(renderer);
358             }
359         }
360     }
361 
362     // Any new objects that remain were not found in the old objects dict, and so they need to be updated.
363     for (auto&amp; selectedRendererInfo : newSelectedRenderers)
364         selectedRendererInfo.value-&gt;repaint();
365 
366     // Have any of the old blocks changed?
367     for (auto&amp; selectedBlockInfo : oldSelectionData.blocks) {
368         auto* block = selectedBlockInfo.key;
369         auto* newInfo = newSelectedBlocks.get(block);
370         auto* oldInfo = selectedBlockInfo.value.get();
371         if (!newInfo || oldInfo-&gt;rects() != newInfo-&gt;rects() || oldInfo-&gt;state() != newInfo-&gt;state()) {
372             oldInfo-&gt;repaint();
373             if (newInfo) {
374                 newInfo-&gt;repaint();
375                 newSelectedBlocks.remove(block);
376             }
377         }
378     }
379 
380     // Any new blocks that remain were not found in the old blocks dict, and so they need to be updated.
381     for (auto&amp; selectedBlockInfo : newSelectedBlocks)
382         selectedBlockInfo.value-&gt;repaint();
383 }
384 
385 } // namespace WebCore
    </pre>
  </body>
</html>
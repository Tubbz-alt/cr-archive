<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.idl</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 24  */
 25 
 26 typedef unsigned long GLenum;
 27 typedef boolean GLboolean;
 28 typedef unsigned long GLbitfield;
 29 typedef byte GLbyte; /* &#39;byte&#39; should be a signed 8 bit type. */
 30 typedef short GLshort;
 31 typedef long GLint;
 32 typedef long GLsizei;
 33 typedef long long GLintptr;
 34 typedef long long GLsizeiptr;
 35 typedef octet GLubyte; /* &#39;octet&#39; should be an unsigned 8 bit type. */
 36 typedef unsigned short GLushort;
 37 typedef unsigned long GLuint;
 38 typedef unrestricted float GLfloat;
 39 typedef unrestricted float GLclampf;
 40 typedef (ArrayBuffer or ArrayBufferView) BufferDataSource;
 41 typedef (Float32Array or sequence&lt;GLfloat&gt;) Float32List;
 42 typedef (Int32Array or sequence&lt;GLint&gt;) Int32List;
 43 
<a name="1" id="anc1"></a>
 44 typedef (HTMLCanvasElement or OffscreenCanvas) WebGLCanvas;
<a name="2" id="anc2"></a>


 45 
 46 [
 47     Conditional=WEBGL,
 48     CustomIsReachable,
 49     CustomToJSObject,
 50     DoNotCheckConstants,
 51     JSCustomMarkFunction,
 52     NoInterfaceObject,
 53     ExportMacro=WEBCORE_EXPORT,
 54 ] interface WebGLRenderingContextBase {
 55 
 56     readonly attribute WebGLCanvas canvas;
 57 
 58     /* ClearBufferMask */
 59     const GLenum DEPTH_BUFFER_BIT = 0x00000100;
 60     const GLenum STENCIL_BUFFER_BIT = 0x00000400;
 61     const GLenum COLOR_BUFFER_BIT = 0x00004000;
 62 
 63     /* BeginMode */
 64     const GLenum POINTS = 0x0000;
 65     const GLenum LINES = 0x0001;
 66     const GLenum LINE_LOOP = 0x0002;
 67     const GLenum LINE_STRIP = 0x0003;
 68     const GLenum TRIANGLES = 0x0004;
 69     const GLenum TRIANGLE_STRIP = 0x0005;
 70     const GLenum TRIANGLE_FAN = 0x0006;
 71 
 72     /* AlphaFunction (not supported in ES20) */
 73     /*  NEVER */
 74     /*  LESS */
 75     /*  EQUAL */
 76     /*  LEQUAL */
 77     /*  GREATER */
 78     /*  NOTEQUAL */
 79     /*  GEQUAL */
 80     /*  ALWAYS */
 81 
 82     /* BlendingFactorDest */
 83     const GLenum ZERO = 0;
 84     const GLenum ONE = 1;
 85     const GLenum SRC_COLOR = 0x0300;
 86     const GLenum ONE_MINUS_SRC_COLOR = 0x0301;
 87     const GLenum SRC_ALPHA = 0x0302;
 88     const GLenum ONE_MINUS_SRC_ALPHA = 0x0303;
 89     const GLenum DST_ALPHA = 0x0304;
 90     const GLenum ONE_MINUS_DST_ALPHA = 0x0305;
 91 
 92     /* BlendingFactorSrc */
 93     /*  ZERO */
 94     /*  ONE */
 95     const GLenum DST_COLOR = 0x0306;
 96     const GLenum ONE_MINUS_DST_COLOR = 0x0307;
 97     const GLenum SRC_ALPHA_SATURATE = 0x0308;
 98     /*  SRC_ALPHA */
 99     /*  ONE_MINUS_SRC_ALPHA */
100     /*  DST_ALPHA */
101     /*  ONE_MINUS_DST_ALPHA */
102 
103     /* BlendEquationSeparate */
104     const GLenum FUNC_ADD = 0x8006;
105     const GLenum BLEND_EQUATION = 0x8009;
106     const GLenum BLEND_EQUATION_RGB = 0x8009;   /* same as BLEND_EQUATION */
107     const GLenum BLEND_EQUATION_ALPHA = 0x883D;
108 
109     /* BlendSubtract */
110     const GLenum FUNC_SUBTRACT = 0x800A;
111     const GLenum FUNC_REVERSE_SUBTRACT = 0x800B;
112 
113     /* Separate Blend Functions */
114     const GLenum BLEND_DST_RGB = 0x80C8;
115     const GLenum BLEND_SRC_RGB = 0x80C9;
116     const GLenum BLEND_DST_ALPHA = 0x80CA;
117     const GLenum BLEND_SRC_ALPHA = 0x80CB;
118     const GLenum CONSTANT_COLOR = 0x8001;
119     const GLenum ONE_MINUS_CONSTANT_COLOR = 0x8002;
120     const GLenum CONSTANT_ALPHA = 0x8003;
121     const GLenum ONE_MINUS_CONSTANT_ALPHA = 0x8004;
122     const GLenum BLEND_COLOR = 0x8005;
123 
124     /* Buffer Objects */
125     const GLenum ARRAY_BUFFER = 0x8892;
126     const GLenum ELEMENT_ARRAY_BUFFER = 0x8893;
127     const GLenum ARRAY_BUFFER_BINDING = 0x8894;
128     const GLenum ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;
129 
130     const GLenum STREAM_DRAW = 0x88E0;
131     const GLenum STATIC_DRAW = 0x88E4;
132     const GLenum DYNAMIC_DRAW = 0x88E8;
133 
134     const GLenum BUFFER_SIZE = 0x8764;
135     const GLenum BUFFER_USAGE = 0x8765;
136 
137     const GLenum CURRENT_VERTEX_ATTRIB = 0x8626;
138 
139     /* CullFaceMode */
140     const GLenum FRONT = 0x0404;
141     const GLenum BACK = 0x0405;
142     const GLenum FRONT_AND_BACK = 0x0408;
143 
144     /* DepthFunction */
145     /*  NEVER */
146     /*  LESS */
147     /*  EQUAL */
148     /*  LEQUAL */
149     /*  GREATER */
150     /*  NOTEQUAL */
151     /*  GEQUAL */
152     /*  ALWAYS */
153 
154     /* EnableCap */
155     const GLenum TEXTURE_2D = 0x0DE1;
156     const GLenum CULL_FACE = 0x0B44;
157     const GLenum BLEND = 0x0BE2;
158     const GLenum DITHER = 0x0BD0;
159     const GLenum STENCIL_TEST = 0x0B90;
160     const GLenum DEPTH_TEST = 0x0B71;
161     const GLenum SCISSOR_TEST = 0x0C11;
162     const GLenum POLYGON_OFFSET_FILL = 0x8037;
163     const GLenum SAMPLE_ALPHA_TO_COVERAGE = 0x809E;
164     const GLenum SAMPLE_COVERAGE = 0x80A0;
165 
166     /* ErrorCode */
167     const GLenum NO_ERROR = 0;
168     const GLenum INVALID_ENUM = 0x0500;
169     const GLenum INVALID_VALUE = 0x0501;
170     const GLenum INVALID_OPERATION = 0x0502;
171     const GLenum OUT_OF_MEMORY = 0x0505;
172 
173     /* FrontFaceDirection */
174     const GLenum CW = 0x0900;
175     const GLenum CCW = 0x0901;
176 
177     /* GetPName */
178     const GLenum LINE_WIDTH = 0x0B21;
179     const GLenum ALIASED_POINT_SIZE_RANGE = 0x846D;
180     const GLenum ALIASED_LINE_WIDTH_RANGE = 0x846E;
181     const GLenum CULL_FACE_MODE = 0x0B45;
182     const GLenum FRONT_FACE = 0x0B46;
183     const GLenum DEPTH_RANGE = 0x0B70;
184     const GLenum DEPTH_WRITEMASK = 0x0B72;
185     const GLenum DEPTH_CLEAR_VALUE = 0x0B73;
186     const GLenum DEPTH_FUNC = 0x0B74;
187     const GLenum STENCIL_CLEAR_VALUE = 0x0B91;
188     const GLenum STENCIL_FUNC = 0x0B92;
189     const GLenum STENCIL_FAIL = 0x0B94;
190     const GLenum STENCIL_PASS_DEPTH_FAIL = 0x0B95;
191     const GLenum STENCIL_PASS_DEPTH_PASS = 0x0B96;
192     const GLenum STENCIL_REF = 0x0B97;
193     const GLenum STENCIL_VALUE_MASK = 0x0B93;
194     const GLenum STENCIL_WRITEMASK = 0x0B98;
195     const GLenum STENCIL_BACK_FUNC = 0x8800;
196     const GLenum STENCIL_BACK_FAIL = 0x8801;
197     const GLenum STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;
198     const GLenum STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;
199     const GLenum STENCIL_BACK_REF = 0x8CA3;
200     const GLenum STENCIL_BACK_VALUE_MASK = 0x8CA4;
201     const GLenum STENCIL_BACK_WRITEMASK = 0x8CA5;
202     const GLenum VIEWPORT = 0x0BA2;
203     const GLenum SCISSOR_BOX = 0x0C10;
204     /*  SCISSOR_TEST */
205     const GLenum COLOR_CLEAR_VALUE = 0x0C22;
206     const GLenum COLOR_WRITEMASK = 0x0C23;
207     const GLenum UNPACK_ALIGNMENT = 0x0CF5;
208     const GLenum PACK_ALIGNMENT = 0x0D05;
209     const GLenum MAX_TEXTURE_SIZE = 0x0D33;
210     const GLenum MAX_VIEWPORT_DIMS = 0x0D3A;
211     const GLenum SUBPIXEL_BITS = 0x0D50;
212     const GLenum RED_BITS = 0x0D52;
213     const GLenum GREEN_BITS = 0x0D53;
214     const GLenum BLUE_BITS = 0x0D54;
215     const GLenum ALPHA_BITS = 0x0D55;
216     const GLenum DEPTH_BITS = 0x0D56;
217     const GLenum STENCIL_BITS = 0x0D57;
218     const GLenum POLYGON_OFFSET_UNITS = 0x2A00;
219     /*  POLYGON_OFFSET_FILL */
220     const GLenum POLYGON_OFFSET_FACTOR = 0x8038;
221     const GLenum TEXTURE_BINDING_2D = 0x8069;
222     const GLenum SAMPLE_BUFFERS = 0x80A8;
223     const GLenum SAMPLES = 0x80A9;
224     const GLenum SAMPLE_COVERAGE_VALUE = 0x80AA;
225     const GLenum SAMPLE_COVERAGE_INVERT = 0x80AB;
226 
227     /* GetTextureParameter */
228     /*  TEXTURE_MAG_FILTER */
229     /*  TEXTURE_MIN_FILTER */
230     /*  TEXTURE_WRAP_S */
231     /*  TEXTURE_WRAP_T */
232 
233     const GLenum COMPRESSED_TEXTURE_FORMATS = 0x86A3;
234 
235     /* HintMode */
236     const GLenum DONT_CARE = 0x1100;
237     const GLenum FASTEST = 0x1101;
238     const GLenum NICEST = 0x1102;
239 
240     /* HintTarget */
241     const GLenum GENERATE_MIPMAP_HINT = 0x8192;
242 
243     /* DataType */
244     const GLenum BYTE = 0x1400;
245     const GLenum UNSIGNED_BYTE = 0x1401;
246     const GLenum SHORT = 0x1402;
247     const GLenum UNSIGNED_SHORT = 0x1403;
248     const GLenum INT = 0x1404;
249     const GLenum UNSIGNED_INT = 0x1405;
250     const GLenum FLOAT = 0x1406;
251 
252     /* PixelFormat */
253     const GLenum DEPTH_COMPONENT = 0x1902;
254     const GLenum ALPHA = 0x1906;
255     const GLenum RGB = 0x1907;
256     const GLenum RGBA = 0x1908;
257     const GLenum LUMINANCE = 0x1909;
258     const GLenum LUMINANCE_ALPHA = 0x190A;
259 
260     /* PixelType */
261     /*  UNSIGNED_BYTE */
262     const GLenum UNSIGNED_SHORT_4_4_4_4 = 0x8033;
263     const GLenum UNSIGNED_SHORT_5_5_5_1 = 0x8034;
264     const GLenum UNSIGNED_SHORT_5_6_5 = 0x8363;
265 
266     /* Shaders */
267     const GLenum FRAGMENT_SHADER = 0x8B30;
268     const GLenum VERTEX_SHADER = 0x8B31;
269     const GLenum MAX_VERTEX_ATTRIBS = 0x8869;
270     const GLenum MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;
271     const GLenum MAX_VARYING_VECTORS = 0x8DFC;
272     const GLenum MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
273     const GLenum MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;
274     const GLenum MAX_TEXTURE_IMAGE_UNITS = 0x8872;
275     const GLenum MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;
276     const GLenum SHADER_TYPE = 0x8B4F;
277     const GLenum DELETE_STATUS = 0x8B80;
278     const GLenum LINK_STATUS = 0x8B82;
279     const GLenum VALIDATE_STATUS = 0x8B83;
280     const GLenum ATTACHED_SHADERS = 0x8B85;
281     const GLenum ACTIVE_UNIFORMS = 0x8B86;
282     const GLenum ACTIVE_ATTRIBUTES = 0x8B89;
283     const GLenum SHADING_LANGUAGE_VERSION = 0x8B8C;
284     const GLenum CURRENT_PROGRAM = 0x8B8D;
285 
286     /* StencilFunction */
287     const GLenum NEVER = 0x0200;
288     const GLenum LESS = 0x0201;
289     const GLenum EQUAL = 0x0202;
290     const GLenum LEQUAL = 0x0203;
291     const GLenum GREATER = 0x0204;
292     const GLenum NOTEQUAL = 0x0205;
293     const GLenum GEQUAL = 0x0206;
294     const GLenum ALWAYS = 0x0207;
295 
296     /* StencilOp */
297     /*  ZERO */
298     const GLenum KEEP = 0x1E00;
299     const GLenum REPLACE = 0x1E01;
300     const GLenum INCR = 0x1E02;
301     const GLenum DECR = 0x1E03;
302     const GLenum INVERT = 0x150A;
303     const GLenum INCR_WRAP = 0x8507;
304     const GLenum DECR_WRAP = 0x8508;
305 
306     /* StringName */
307     const GLenum VENDOR = 0x1F00;
308     const GLenum RENDERER = 0x1F01;
309     const GLenum VERSION = 0x1F02;
310 
311     /* TextureMagFilter */
312     const GLenum NEAREST = 0x2600;
313     const GLenum LINEAR = 0x2601;
314 
315     /* TextureMinFilter */
316     /*  NEAREST */
317     /*  LINEAR */
318     const GLenum NEAREST_MIPMAP_NEAREST = 0x2700;
319     const GLenum LINEAR_MIPMAP_NEAREST = 0x2701;
320     const GLenum NEAREST_MIPMAP_LINEAR = 0x2702;
321     const GLenum LINEAR_MIPMAP_LINEAR = 0x2703;
322 
323     /* TextureParameterName */
324     const GLenum TEXTURE_MAG_FILTER = 0x2800;
325     const GLenum TEXTURE_MIN_FILTER = 0x2801;
326     const GLenum TEXTURE_WRAP_S = 0x2802;
327     const GLenum TEXTURE_WRAP_T = 0x2803;
328 
329     /* TextureTarget */
330     /*  TEXTURE_2D */
331     const GLenum TEXTURE = 0x1702;
332 
333     const GLenum TEXTURE_CUBE_MAP = 0x8513;
334     const GLenum TEXTURE_BINDING_CUBE_MAP = 0x8514;
335     const GLenum TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
336     const GLenum TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
337     const GLenum TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
338     const GLenum TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
339     const GLenum TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
340     const GLenum TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;
341     const GLenum MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;
342 
343     /* TextureUnit */
344     const GLenum TEXTURE0 = 0x84C0;
345     const GLenum TEXTURE1 = 0x84C1;
346     const GLenum TEXTURE2 = 0x84C2;
347     const GLenum TEXTURE3 = 0x84C3;
348     const GLenum TEXTURE4 = 0x84C4;
349     const GLenum TEXTURE5 = 0x84C5;
350     const GLenum TEXTURE6 = 0x84C6;
351     const GLenum TEXTURE7 = 0x84C7;
352     const GLenum TEXTURE8 = 0x84C8;
353     const GLenum TEXTURE9 = 0x84C9;
354     const GLenum TEXTURE10 = 0x84CA;
355     const GLenum TEXTURE11 = 0x84CB;
356     const GLenum TEXTURE12 = 0x84CC;
357     const GLenum TEXTURE13 = 0x84CD;
358     const GLenum TEXTURE14 = 0x84CE;
359     const GLenum TEXTURE15 = 0x84CF;
360     const GLenum TEXTURE16 = 0x84D0;
361     const GLenum TEXTURE17 = 0x84D1;
362     const GLenum TEXTURE18 = 0x84D2;
363     const GLenum TEXTURE19 = 0x84D3;
364     const GLenum TEXTURE20 = 0x84D4;
365     const GLenum TEXTURE21 = 0x84D5;
366     const GLenum TEXTURE22 = 0x84D6;
367     const GLenum TEXTURE23 = 0x84D7;
368     const GLenum TEXTURE24 = 0x84D8;
369     const GLenum TEXTURE25 = 0x84D9;
370     const GLenum TEXTURE26 = 0x84DA;
371     const GLenum TEXTURE27 = 0x84DB;
372     const GLenum TEXTURE28 = 0x84DC;
373     const GLenum TEXTURE29 = 0x84DD;
374     const GLenum TEXTURE30 = 0x84DE;
375     const GLenum TEXTURE31 = 0x84DF;
376     const GLenum ACTIVE_TEXTURE = 0x84E0;
377 
378     /* TextureWrapMode */
379     const GLenum REPEAT = 0x2901;
380     const GLenum CLAMP_TO_EDGE = 0x812F;
381     const GLenum MIRRORED_REPEAT = 0x8370;
382 
383     /* Uniform Types */
384     const GLenum FLOAT_VEC2 = 0x8B50;
385     const GLenum FLOAT_VEC3 = 0x8B51;
386     const GLenum FLOAT_VEC4 = 0x8B52;
387     const GLenum INT_VEC2 = 0x8B53;
388     const GLenum INT_VEC3 = 0x8B54;
389     const GLenum INT_VEC4 = 0x8B55;
390     const GLenum BOOL = 0x8B56;
391     const GLenum BOOL_VEC2 = 0x8B57;
392     const GLenum BOOL_VEC3 = 0x8B58;
393     const GLenum BOOL_VEC4 = 0x8B59;
394     const GLenum FLOAT_MAT2 = 0x8B5A;
395     const GLenum FLOAT_MAT3 = 0x8B5B;
396     const GLenum FLOAT_MAT4 = 0x8B5C;
397     const GLenum SAMPLER_2D = 0x8B5E;
398     const GLenum SAMPLER_CUBE = 0x8B60;
399 
400     /* Vertex Arrays */
401     const GLenum VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;
402     const GLenum VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;
403     const GLenum VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;
404     const GLenum VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;
405     const GLenum VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;
406     const GLenum VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;
407     const GLenum VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;
408 
409     /* Read Format */
410     const GLenum IMPLEMENTATION_COLOR_READ_TYPE = 0x8B9A;
411     const GLenum IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B;
412 
413     /* Shader Source */
414     const GLenum COMPILE_STATUS = 0x8B81;
415 
416     /* Shader Precision-Specified Types */
417     const GLenum LOW_FLOAT = 0x8DF0;
418     const GLenum MEDIUM_FLOAT = 0x8DF1;
419     const GLenum HIGH_FLOAT = 0x8DF2;
420     const GLenum LOW_INT = 0x8DF3;
421     const GLenum MEDIUM_INT = 0x8DF4;
422     const GLenum HIGH_INT = 0x8DF5;
423 
424     /* Framebuffer Object. */
425     const GLenum FRAMEBUFFER = 0x8D40;
426     const GLenum RENDERBUFFER = 0x8D41;
427 
428     const GLenum RGBA4 = 0x8056;
429     const GLenum RGB5_A1 = 0x8057;
430     const GLenum RGB565 = 0x8D62;
431     const GLenum DEPTH_COMPONENT16 = 0x81A5;
432     const GLenum STENCIL_INDEX = 0x1901;
433     const GLenum STENCIL_INDEX8 = 0x8D48;
434     const GLenum DEPTH_STENCIL = 0x84F9;
435 
436     const GLenum RENDERBUFFER_WIDTH = 0x8D42;
437     const GLenum RENDERBUFFER_HEIGHT = 0x8D43;
438     const GLenum RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;
439     const GLenum RENDERBUFFER_RED_SIZE = 0x8D50;
440     const GLenum RENDERBUFFER_GREEN_SIZE = 0x8D51;
441     const GLenum RENDERBUFFER_BLUE_SIZE = 0x8D52;
442     const GLenum RENDERBUFFER_ALPHA_SIZE = 0x8D53;
443     const GLenum RENDERBUFFER_DEPTH_SIZE = 0x8D54;
444     const GLenum RENDERBUFFER_STENCIL_SIZE = 0x8D55;
445 
446     const GLenum FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;
447     const GLenum FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;
448     const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;
449     const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;
450 
451     const GLenum COLOR_ATTACHMENT0 = 0x8CE0;
452     const GLenum DEPTH_ATTACHMENT = 0x8D00;
453     const GLenum STENCIL_ATTACHMENT = 0x8D20;
454     const GLenum DEPTH_STENCIL_ATTACHMENT = 0x821A;
455 
456     const GLenum NONE = 0;
457 
458     const GLenum FRAMEBUFFER_COMPLETE = 0x8CD5;
459     const GLenum FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;
460     const GLenum FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
461     const GLenum FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;
462     const GLenum FRAMEBUFFER_UNSUPPORTED = 0x8CDD;
463 
464     const GLenum FRAMEBUFFER_BINDING = 0x8CA6;
465     const GLenum RENDERBUFFER_BINDING = 0x8CA7;
466     const GLenum MAX_RENDERBUFFER_SIZE = 0x84E8;
467 
468     const GLenum INVALID_FRAMEBUFFER_OPERATION = 0x0506;
469 
470     /* WebGL-specific enums */
471     const GLenum UNPACK_FLIP_Y_WEBGL = 0x9240;
472     const GLenum UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
473     const GLenum CONTEXT_LOST_WEBGL = 0x9242;
474     const GLenum UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
475     const GLenum BROWSER_DEFAULT_WEBGL = 0x9244;
476 
477     readonly attribute GLsizei drawingBufferWidth;
478     readonly attribute GLsizei drawingBufferHeight;
479 
480     void activeTexture(GLenum texture);
481     void attachShader(WebGLProgram? program, WebGLShader? shader);
482     void bindAttribLocation(WebGLProgram? program, GLuint index, DOMString name);
483     void bindBuffer(GLenum target, WebGLBuffer? buffer);
484     void bindFramebuffer(GLenum target, WebGLFramebuffer? framebuffer);
485     void bindRenderbuffer(GLenum target, WebGLRenderbuffer? renderbuffer);
486     void bindTexture(GLenum target, WebGLTexture? texture);
487     void blendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
488     void blendEquation(GLenum mode);
489     void blendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);
490     void blendFunc(GLenum sfactor, GLenum dfactor);
491     void blendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
492     void bufferData(GLenum target, BufferDataSource? data, GLenum usage);
493     void bufferData(GLenum target, GLsizeiptr size, GLenum usage);
494     void bufferSubData(GLenum target, GLintptr offset, BufferDataSource? data);
495 
496     GLenum checkFramebufferStatus(GLenum target);
497     void clear(GLbitfield mask);
498     void clearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
499     void clearDepth(GLclampf depth);
500     void clearStencil(GLint s);
501     void colorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
502     void compileShader(WebGLShader? shader);
503 
<a name="3" id="anc3"></a><span class="line-modified">504     // compressedTexImage2D is split between WebGLRenderingContext and</span>
<span class="line-modified">505     // WebGL2RenderingContext because the ArrayBufferView overloads are</span>
<span class="line-modified">506     // indistinguishable.</span>





507 
<a name="4" id="anc4"></a><span class="line-removed">508     void compressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset,</span>
<span class="line-removed">509         GLsizei width, GLsizei height, GLenum format, ArrayBufferView data);</span>
<span class="line-removed">510     </span>
511     void copyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
512     void copyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
513 
514     WebGLBuffer createBuffer();
515     WebGLFramebuffer createFramebuffer();
516     WebGLProgram createProgram();
517     WebGLRenderbuffer createRenderbuffer();
518     WebGLShader createShader(GLenum type);
519     WebGLTexture createTexture();
520 
521     void cullFace(GLenum mode);
522 
523     void deleteBuffer(WebGLBuffer? buffer);
524     void deleteFramebuffer(WebGLFramebuffer? framebuffer);
525     void deleteProgram(WebGLProgram? program);
526     void deleteRenderbuffer(WebGLRenderbuffer? renderbuffer);
527     void deleteShader(WebGLShader? shader);
528     void deleteTexture(WebGLTexture? texture);
529 
530     void depthFunc(GLenum func);
531     void depthMask(GLboolean flag);
532     void depthRange(GLclampf zNear, GLclampf zFar);
533     void detachShader(WebGLProgram? program, WebGLShader? shader);
534     void disable(GLenum cap);
535     void disableVertexAttribArray(GLuint index);
536     void drawArrays(GLenum mode, GLint first, GLsizei count);
537     void drawElements(GLenum mode, GLsizei count, GLenum type, GLintptr offset);
538 
539     void enable(GLenum cap);
540     void enableVertexAttribArray(GLuint index);
541     void finish();
542     void flush();
543     void framebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, WebGLRenderbuffer? renderbuffer);
544     void framebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, WebGLTexture? texture, GLint level);
545     void frontFace(GLenum mode);
546     void generateMipmap(GLenum target);
547     
548     WebGLActiveInfo getActiveAttrib(WebGLProgram? program, GLuint index);
549     WebGLActiveInfo getActiveUniform(WebGLProgram? program, GLuint index);
550 
551     // FIXME: The spec says this should not take a nullable WebGLProgram.
552     sequence&lt;WebGLShader&gt;? getAttachedShaders(WebGLProgram? program);
553 
554     GLint getAttribLocation(WebGLProgram? program, DOMString name);
555 
556     [OverrideIDLType=IDLWebGLAny] any getBufferParameter(GLenum target, GLenum pname);
557 
558     WebGLContextAttributes? getContextAttributes();
559 
560     GLenum getError();
561 
562     sequence&lt;DOMString&gt;? getSupportedExtensions();
563     [OverrideIDLType=IDLWebGLExtension] object? getExtension(DOMString name);
564 
565     [OverrideIDLType=IDLWebGLAny] any getFramebufferAttachmentParameter(GLenum target, GLenum attachment, GLenum pname);
566     [OverrideIDLType=IDLWebGLAny] any getParameter(GLenum pname);
567     [OverrideIDLType=IDLWebGLAny] any getProgramParameter(WebGLProgram? program, GLenum pname);
568     DOMString? getProgramInfoLog(WebGLProgram? program);
569     [OverrideIDLType=IDLWebGLAny] any getRenderbufferParameter(GLenum target, GLenum pname);
570     [OverrideIDLType=IDLWebGLAny] any getShaderParameter(WebGLShader? shader, GLenum pname);
571 
572     DOMString? getShaderInfoLog(WebGLShader? shader);
573 
574     WebGLShaderPrecisionFormat getShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype);
575 
576     DOMString? getShaderSource(WebGLShader? shader);
577 
578     [OverrideIDLType=IDLWebGLAny] any getTexParameter(GLenum target, GLenum pname);
579 
580     [OverrideIDLType=IDLWebGLAny] any getUniform(WebGLProgram? program, WebGLUniformLocation? location);
581 
582     WebGLUniformLocation getUniformLocation(WebGLProgram? program, DOMString name);
583 
584     [OverrideIDLType=IDLWebGLAny] any getVertexAttrib(GLuint index, GLenum pname);
585 
586     GLsizeiptr getVertexAttribOffset(GLuint index, GLenum pname);
587 
588     void hint(GLenum target, GLenum mode);
589     GLboolean isBuffer(WebGLBuffer? buffer);
590     GLboolean isContextLost();
591     GLboolean isEnabled(GLenum cap);
592     GLboolean isFramebuffer(WebGLFramebuffer? framebuffer);
593     GLboolean isProgram(WebGLProgram? program);
594     GLboolean isRenderbuffer(WebGLRenderbuffer? renderbuffer);
595     GLboolean isShader(WebGLShader? shader);
596     GLboolean isTexture(WebGLTexture? texture);
597     void lineWidth(GLfloat width);
598     void linkProgram(WebGLProgram? program);
599     void pixelStorei(GLenum pname, GLint param);
600     void polygonOffset(GLfloat factor, GLfloat units);
601 
602     void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, ArrayBufferView pixels);
603     
604     void releaseShaderCompiler();
605     void renderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
606     void sampleCoverage(GLclampf value, GLboolean invert);
607     void scissor(GLint x, GLint y, GLsizei width, GLsizei height);
608     void shaderSource(WebGLShader? shader, DOMString string);
609     void stencilFunc(GLenum func, GLint ref, GLuint mask);
610     void stencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);
611     void stencilMask(GLuint mask);
612     void stencilMaskSeparate(GLenum face, GLuint mask);
613     void stencilOp(GLenum fail, GLenum zfail, GLenum zpass);
614     void stencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass);
615 
616     void texParameterf(GLenum target, GLenum pname, GLfloat param);
617     void texParameteri(GLenum target, GLenum pname, GLint param);
618 
619     void uniform1f(WebGLUniformLocation? location, GLfloat x);
620     void uniform2f(WebGLUniformLocation? location, GLfloat x, GLfloat y);
621     void uniform3f(WebGLUniformLocation? location, GLfloat x, GLfloat y, GLfloat z);
622     void uniform4f(WebGLUniformLocation? location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
623 
624     void uniform1i(WebGLUniformLocation? location, GLint x);
625     void uniform2i(WebGLUniformLocation? location, GLint x, GLint y);
626     void uniform3i(WebGLUniformLocation? location, GLint x, GLint y, GLint z);
627     void uniform4i(WebGLUniformLocation? location, GLint x, GLint y, GLint z, GLint w);
628 
629     void uniform1fv(WebGLUniformLocation? location, Float32List v);
630     void uniform2fv(WebGLUniformLocation? location, Float32List v);
631     void uniform3fv(WebGLUniformLocation? location, Float32List v);
632     void uniform4fv(WebGLUniformLocation? location, Float32List v);
633 
634     void uniform1iv(WebGLUniformLocation? location, Int32List v);
635     void uniform2iv(WebGLUniformLocation? location, Int32List v);
636     void uniform3iv(WebGLUniformLocation? location, Int32List v);
637     void uniform4iv(WebGLUniformLocation? location, Int32List v);
638 
639     void uniformMatrix2fv(WebGLUniformLocation? location, GLboolean transpose, Float32List array);
640     void uniformMatrix3fv(WebGLUniformLocation? location, GLboolean transpose, Float32List array);
641     void uniformMatrix4fv(WebGLUniformLocation? location, GLboolean transpose, Float32List array);
642 
643     void useProgram(WebGLProgram? program);
644     void validateProgram(WebGLProgram? program);
645 
646     void vertexAttrib1f(GLuint index, GLfloat x);
647     void vertexAttrib2f(GLuint index, GLfloat x, GLfloat y);
648     void vertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z);
649     void vertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
650 
651     void vertexAttrib1fv(GLuint index, Float32List values);
652     void vertexAttrib2fv(GLuint index, Float32List values);
653     void vertexAttrib3fv(GLuint index, Float32List values);
654     void vertexAttrib4fv(GLuint index, Float32List values);
655 
656     void vertexAttribPointer(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset);
657 
658     void viewport(GLint x, GLint y, GLsizei width, GLsizei height);
659 };
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSString.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSString.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSString.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSString.cpp
@@ -62,15 +62,10 @@
     ASSERT(string->length() == m_length);
     m_strings.clear();
     m_strings.append(string);
 }
 
-void JSString::destroy(JSCell* cell)
-{
-    static_cast<JSString*>(cell)->JSString::~JSString();
-}
-
 void JSString::dumpToStream(const JSCell* cell, PrintStream& out)
 {
     VM& vm = cell->vm();
     const JSString* thisObject = jsCast<const JSString*>(cell);
     out.printf("<%p, %s, [%u], ", thisObject, thisObject->className(vm), thisObject->length());
@@ -89,17 +84,17 @@
         }
     }
     out.printf(">");
 }
 
-bool JSString::equalSlowCase(ExecState* exec, JSString* other) const
+bool JSString::equalSlowCase(JSGlobalObject* globalObject, JSString* other) const
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
-    String str1 = value(exec);
+    String str1 = value(globalObject);
     RETURN_IF_EXCEPTION(scope, false);
-    String str2 = other->value(exec);
+    String str2 = other->value(globalObject);
     RETURN_IF_EXCEPTION(scope, false);
     return WTF::equal(*str1.impl(), *str2.impl());
 }
 
 size_t JSString::estimatedSize(JSCell* cell, VM& vm)
@@ -147,62 +142,44 @@
     }
     if (StringImpl* impl = bitwise_cast<StringImpl*>(pointer))
         visitor.reportExtraMemoryVisited(impl->costDuringGC());
 }
 
-static const unsigned maxLengthForOnStackResolve = 2048;
+static constexpr unsigned maxLengthForOnStackResolve = 2048;
 
 void JSRopeString::resolveRopeInternal8(LChar* buffer) const
 {
     if (isSubstring()) {
         StringImpl::copyCharacters(buffer, substringBase()->valueInternal().characters8() + substringOffset(), length());
         return;
     }
 
-    resolveRopeInternal8NoSubstring(buffer);
-}
-
-void JSRopeString::resolveRopeInternal8NoSubstring(LChar* buffer) const
-{
-    for (size_t i = 0; i < s_maxInternalRopeLength && fiber(i); ++i) {
-        if (fiber(i)->isRope()) {
-            resolveRopeSlowCase8(buffer);
-            return;
-        }
-    }
-
-    LChar* position = buffer;
-    for (size_t i = 0; i < s_maxInternalRopeLength && fiber(i); ++i) {
-        const StringImpl& fiberString = *fiber(i)->valueInternal().impl();
-        unsigned length = fiberString.length();
-        StringImpl::copyCharacters(position, fiberString.characters8(), length);
-        position += length;
-    }
-    ASSERT((buffer + length()) == position);
+    resolveRopeInternalNoSubstring(buffer);
 }
 
 void JSRopeString::resolveRopeInternal16(UChar* buffer) const
 {
     if (isSubstring()) {
         StringImpl::copyCharacters(
             buffer, substringBase()->valueInternal().characters16() + substringOffset(), length());
         return;
     }
 
-    resolveRopeInternal16NoSubstring(buffer);
+    resolveRopeInternalNoSubstring(buffer);
 }
 
-void JSRopeString::resolveRopeInternal16NoSubstring(UChar* buffer) const
+template<typename CharacterType>
+void JSRopeString::resolveRopeInternalNoSubstring(CharacterType* buffer) const
 {
     for (size_t i = 0; i < s_maxInternalRopeLength && fiber(i); ++i) {
         if (fiber(i)->isRope()) {
             resolveRopeSlowCase(buffer);
             return;
         }
     }
 
-    UChar* position = buffer;
+    CharacterType* position = buffer;
     for (size_t i = 0; i < s_maxInternalRopeLength && fiber(i); ++i) {
         const StringImpl& fiberString = *fiber(i)->valueInternal().impl();
         unsigned length = fiberString.length();
         if (fiberString.is8Bit())
             StringImpl::copyCharacters(position, fiberString.characters8(), length);
@@ -211,18 +188,18 @@
         position += length;
     }
     ASSERT((buffer + length()) == position);
 }
 
-AtomString JSRopeString::resolveRopeToAtomString(ExecState* exec) const
+AtomString JSRopeString::resolveRopeToAtomString(JSGlobalObject* globalObject) const
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (length() > maxLengthForOnStackResolve) {
         scope.release();
-        return resolveRopeWithFunction(exec, [&] (Ref<StringImpl>&& newImpl) {
+        return resolveRopeWithFunction(globalObject, [&] (Ref<StringImpl>&& newImpl) {
             return AtomStringImpl::add(newImpl.ptr());
         });
     }
 
     if (is8Bit()) {
@@ -251,18 +228,18 @@
     static_assert(sizeof(String) == sizeof(RefPtr<StringImpl>), "JSString's String initialization must be done in one pointer move.");
     // We do not clear the trailing fibers and length information (fiber1 and fiber2) because we could be reading the length concurrently.
     ASSERT(!JSString::isRope());
 }
 
-RefPtr<AtomStringImpl> JSRopeString::resolveRopeToExistingAtomString(ExecState* exec) const
+RefPtr<AtomStringImpl> JSRopeString::resolveRopeToExistingAtomString(JSGlobalObject* globalObject) const
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (length() > maxLengthForOnStackResolve) {
         RefPtr<AtomStringImpl> existingAtomString;
-        resolveRopeWithFunction(exec, [&] (Ref<StringImpl>&& newImpl) -> Ref<StringImpl> {
+        resolveRopeWithFunction(globalObject, [&] (Ref<StringImpl>&& newImpl) -> Ref<StringImpl> {
             existingAtomString = AtomStringImpl::lookUp(newImpl.ptr());
             if (existingAtomString)
                 return makeRef(*existingAtomString);
             return WTFMove(newImpl);
         });
@@ -288,11 +265,11 @@
 
     return nullptr;
 }
 
 template<typename Function>
-const String& JSRopeString::resolveRopeWithFunction(ExecState* nullOrExecForOOM, Function&& function) const
+const String& JSRopeString::resolveRopeWithFunction(JSGlobalObject* nullOrGlobalObjectForOOM, Function&& function) const
 {
     ASSERT(isRope());
 
     VM& vm = this->vm();
     if (isSubstring()) {
@@ -304,36 +281,36 @@
 
     if (is8Bit()) {
         LChar* buffer;
         auto newImpl = StringImpl::tryCreateUninitialized(length(), buffer);
         if (!newImpl) {
-            outOfMemory(nullOrExecForOOM);
+            outOfMemory(nullOrGlobalObjectForOOM);
             return nullString();
         }
         vm.heap.reportExtraMemoryAllocated(newImpl->cost());
 
-        resolveRopeInternal8NoSubstring(buffer);
+        resolveRopeInternalNoSubstring(buffer);
         convertToNonRope(function(newImpl.releaseNonNull()));
         return valueInternal();
     }
 
     UChar* buffer;
     auto newImpl = StringImpl::tryCreateUninitialized(length(), buffer);
     if (!newImpl) {
-        outOfMemory(nullOrExecForOOM);
+        outOfMemory(nullOrGlobalObjectForOOM);
         return nullString();
     }
     vm.heap.reportExtraMemoryAllocated(newImpl->cost());
 
-    resolveRopeInternal16NoSubstring(buffer);
+    resolveRopeInternalNoSubstring(buffer);
     convertToNonRope(function(newImpl.releaseNonNull()));
     return valueInternal();
 }
 
-const String& JSRopeString::resolveRope(ExecState* nullOrExecForOOM) const
+const String& JSRopeString::resolveRope(JSGlobalObject* nullOrGlobalObjectForOOM) const
 {
-    return resolveRopeWithFunction(nullOrExecForOOM, [] (Ref<StringImpl>&& newImpl) {
+    return resolveRopeWithFunction(nullOrGlobalObjectForOOM, [] (Ref<StringImpl>&& newImpl) {
         return WTFMove(newImpl);
     });
 }
 
 // Overview: These functions convert a JSString from holding a string in rope form
@@ -344,49 +321,14 @@
 // in this fashion should minimize work queue size.  (If we built the queue forwards
 // we would likely have to place all of the constituent StringImpls into the
 // Vector before performing any concatenation, but by working backwards we likely
 // only fill the queue with the number of substrings at any given level in a
 // rope-of-ropes.)
-void JSRopeString::resolveRopeSlowCase8(LChar* buffer) const
-{
-    LChar* position = buffer + length(); // We will be working backwards over the rope.
-    Vector<JSString*, 32, UnsafeVectorOverflow> workQueue; // Putting strings into a Vector is only OK because there are no GC points in this method.
-
-    for (size_t i = 0; i < s_maxInternalRopeLength && fiber(i); ++i)
-        workQueue.append(fiber(i));
-
-    while (!workQueue.isEmpty()) {
-        JSString* currentFiber = workQueue.last();
-        workQueue.removeLast();
-
-        const LChar* characters;
-
-        if (currentFiber->isRope()) {
-            JSRopeString* currentFiberAsRope = static_cast<JSRopeString*>(currentFiber);
-            if (!currentFiberAsRope->isSubstring()) {
-                for (size_t i = 0; i < s_maxInternalRopeLength && currentFiberAsRope->fiber(i); ++i)
-                    workQueue.append(currentFiberAsRope->fiber(i));
-                continue;
-            }
-            ASSERT(!currentFiberAsRope->substringBase()->isRope());
-            characters =
-                currentFiberAsRope->substringBase()->valueInternal().characters8() +
-                currentFiberAsRope->substringOffset();
-        } else
-            characters = currentFiber->valueInternal().characters8();
-
-        unsigned length = currentFiber->length();
-        position -= length;
-        StringImpl::copyCharacters(position, characters, length);
-    }
-
-    ASSERT(buffer == position);
-}
-
-void JSRopeString::resolveRopeSlowCase(UChar* buffer) const
+template<typename CharacterType>
+void JSRopeString::resolveRopeSlowCase(CharacterType* buffer) const
 {
-    UChar* position = buffer + length(); // We will be working backwards over the rope.
+    CharacterType* position = buffer + length(); // We will be working backwards over the rope.
     Vector<JSString*, 32, UnsafeVectorOverflow> workQueue; // These strings are kept alive by the parent rope, so using a Vector is OK.
 
     for (size_t i = 0; i < s_maxInternalRopeLength && fiber(i); ++i)
         workQueue.append(fiber(i));
 
@@ -424,41 +366,41 @@
     }
 
     ASSERT(buffer == position);
 }
 
-void JSRopeString::outOfMemory(ExecState* nullOrExecForOOM) const
+void JSRopeString::outOfMemory(JSGlobalObject* nullOrGlobalObjectForOOM) const
 {
     ASSERT(isRope());
-    if (nullOrExecForOOM) {
-        VM& vm = nullOrExecForOOM->vm();
+    if (nullOrGlobalObjectForOOM) {
+        VM& vm = nullOrGlobalObjectForOOM->vm();
         auto scope = DECLARE_THROW_SCOPE(vm);
-        throwOutOfMemoryError(nullOrExecForOOM, scope);
+        throwOutOfMemoryError(nullOrGlobalObjectForOOM, scope);
     }
 }
 
-JSValue JSString::toPrimitive(ExecState*, PreferredPrimitiveType) const
+JSValue JSString::toPrimitive(JSGlobalObject*, PreferredPrimitiveType) const
 {
     return const_cast<JSString*>(this);
 }
 
-bool JSString::getPrimitiveNumber(ExecState* exec, double& number, JSValue& result) const
+bool JSString::getPrimitiveNumber(JSGlobalObject* globalObject, double& number, JSValue& result) const
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
-    StringView view = unsafeView(exec);
+    StringView view = unsafeView(globalObject);
     RETURN_IF_EXCEPTION(scope, false);
     result = this;
     number = jsToNumber(view);
     return false;
 }
 
-double JSString::toNumber(ExecState* exec) const
+double JSString::toNumber(JSGlobalObject* globalObject) const
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
-    StringView view = unsafeView(exec);
+    StringView view = unsafeView(globalObject);
     RETURN_IF_EXCEPTION(scope, 0);
     return jsToNumber(view);
 }
 
 inline StringObject* StringObject::create(VM& vm, JSGlobalObject* globalObject, JSString* string)
@@ -466,33 +408,33 @@
     StringObject* object = new (NotNull, allocateCell<StringObject>(vm.heap)) StringObject(vm, globalObject->stringObjectStructure());
     object->finishCreation(vm, string);
     return object;
 }
 
-JSObject* JSString::toObject(ExecState* exec, JSGlobalObject* globalObject) const
+JSObject* JSString::toObject(JSGlobalObject* globalObject) const
 {
-    return StringObject::create(exec->vm(), globalObject, const_cast<JSString*>(this));
+    return StringObject::create(globalObject->vm(), globalObject, const_cast<JSString*>(this));
 }
 
-JSValue JSString::toThis(JSCell* cell, ExecState* exec, ECMAMode ecmaMode)
+JSValue JSString::toThis(JSCell* cell, JSGlobalObject* globalObject, ECMAMode ecmaMode)
 {
     if (ecmaMode == StrictMode)
         return cell;
-    return StringObject::create(exec->vm(), exec->lexicalGlobalObject(), asString(cell));
+    return StringObject::create(globalObject->vm(), globalObject, asString(cell));
 }
 
-bool JSString::getStringPropertyDescriptor(ExecState* exec, PropertyName propertyName, PropertyDescriptor& descriptor)
+bool JSString::getStringPropertyDescriptor(JSGlobalObject* globalObject, PropertyName propertyName, PropertyDescriptor& descriptor)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     if (propertyName == vm.propertyNames->length) {
         descriptor.setDescriptor(jsNumber(length()), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
         return true;
     }
 
     Optional<uint32_t> index = parseIndex(propertyName);
     if (index && index.value() < length()) {
-        descriptor.setDescriptor(getIndex(exec, index.value()), PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
+        descriptor.setDescriptor(getIndex(globalObject, index.value()), PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
         return true;
     }
 
     return false;
 }

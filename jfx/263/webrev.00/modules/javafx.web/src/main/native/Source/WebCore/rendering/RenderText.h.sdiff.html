<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderText.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderText.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderTextLineBoxes.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderText.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #pragma once
 24 
 25 #include &quot;RenderElement.h&quot;
 26 #include &quot;RenderTextLineBoxes.h&quot;
 27 #include &quot;SimpleLineLayout.h&quot;
 28 #include &quot;Text.h&quot;
 29 #include &lt;wtf/Forward.h&gt;
 30 #include &lt;wtf/text/TextBreakIterator.h&gt;
 31 
 32 namespace WebCore {
 33 
 34 class Font;
 35 class InlineTextBox;
 36 struct GlyphOverflow;
 37 




 38 class RenderText : public RenderObject {
 39     WTF_MAKE_ISO_ALLOCATED(RenderText);
 40 public:
 41     RenderText(Text&amp;, const String&amp;);
 42     RenderText(Document&amp;, const String&amp;);
 43 
 44     virtual ~RenderText();
 45 
 46     WEBCORE_EXPORT Text* textNode() const;
 47 
 48     virtual bool isTextFragment() const;
 49 
 50     const RenderStyle&amp; style() const;
 51     const RenderStyle&amp; firstLineStyle() const;
 52     const RenderStyle* getCachedPseudoStyle(PseudoId, const RenderStyle* parentStyle = nullptr) const;
 53 
 54     Color selectionBackgroundColor() const;
 55     Color selectionForegroundColor() const;
 56     Color selectionEmphasisMarkColor() const;
 57     std::unique_ptr&lt;RenderStyle&gt; selectionPseudoStyle() const;
 58 
 59     virtual String originalText() const;
 60 
 61     void extractTextBox(InlineTextBox&amp; box) { m_lineBoxes.extract(box); }
 62     void attachTextBox(InlineTextBox&amp; box) { m_lineBoxes.attach(box); }
 63     void removeTextBox(InlineTextBox&amp; box) { m_lineBoxes.remove(box); }
 64 
 65     StringImpl&amp; text() const { return *m_text.impl(); } // Since m_text can never be null, returning this type means callers won&#39;t null check.
 66     String textWithoutConvertingBackslashToYenSymbol() const;
 67 
 68     InlineTextBox* createInlineTextBox() { return m_lineBoxes.createAndAppendLineBox(*this); }
 69     void dirtyLineBoxes(bool fullLayout);
 70 
 71     void absoluteRects(Vector&lt;IntRect&gt;&amp;, const LayoutPoint&amp; accumulatedOffset) const final;
 72     Vector&lt;IntRect&gt; absoluteRectsForRange(unsigned startOffset = 0, unsigned endOffset = UINT_MAX, bool useSelectionHeight = false, bool* wasFixed = nullptr) const;
 73 #if PLATFORM(IOS_FAMILY)
 74     void collectSelectionRects(Vector&lt;SelectionRect&gt;&amp;, unsigned startOffset = 0, unsigned endOffset = std::numeric_limits&lt;unsigned&gt;::max()) final;
 75 #endif
 76 
 77     void absoluteQuads(Vector&lt;FloatQuad&gt;&amp;, bool* wasFixed) const final;
<span class="line-modified"> 78     Vector&lt;FloatQuad&gt; absoluteQuadsForRange(unsigned startOffset = 0, unsigned endOffset = UINT_MAX, bool useSelectionHeight = false, bool* wasFixed = nullptr) const;</span>
 79 
 80     Vector&lt;FloatQuad&gt; absoluteQuadsClippedToEllipsis() const;
 81 
 82     Position positionForPoint(const LayoutPoint&amp;) final;
 83 
 84     UChar characterAt(unsigned) const;
 85     unsigned length() const final { return text().length(); }
 86 
 87     void positionLineBox(InlineTextBox&amp;);
 88 
 89     virtual float width(unsigned from, unsigned length, const FontCascade&amp;, float xPos, HashSet&lt;const Font*&gt;* fallbackFonts = nullptr, GlyphOverflow* = nullptr) const;
 90     virtual float width(unsigned from, unsigned length, float xPos, bool firstLine = false, HashSet&lt;const Font*&gt;* fallbackFonts = nullptr, GlyphOverflow* = nullptr) const;
 91 
 92     float minLogicalWidth() const;
 93     float maxLogicalWidth() const;
 94 
 95     struct Widths {
 96         float min { 0 };
 97         float max { 0 };
 98         float beginMin { 0 };
</pre>
<hr />
<pre>
147     void momentarilyRevealLastTypedCharacter(unsigned offsetAfterLastTypedCharacter);
148 
149     InlineTextBox* findNextInlineTextBox(int offset, int&amp; pos) const { return m_lineBoxes.findNext(offset, pos); }
150 
151     bool isAllCollapsibleWhitespace() const;
152 
153     bool canUseSimpleFontCodePath() const { return m_canUseSimpleFontCodePath; }
154 
155     void removeAndDestroyTextBoxes();
156 
157     virtual void styleDidChange(StyleDifference, const RenderStyle* oldStyle);
158 
159     virtual std::unique_ptr&lt;InlineTextBox&gt; createTextBox();
160 
161 #if ENABLE(TEXT_AUTOSIZING)
162     float candidateComputedTextSize() const { return m_candidateComputedTextSize; }
163     void setCandidateComputedTextSize(float size) { m_candidateComputedTextSize = size; }
164 #endif
165 
166     void ensureLineBoxes();
<span class="line-removed">167     void deleteLineBoxesBeforeSimpleLineLayout();</span>
168     const SimpleLineLayout::Layout* simpleLineLayout() const;




169 
170     StringView stringView(unsigned start = 0, Optional&lt;unsigned&gt; stop = WTF::nullopt) const;
171 
172     LayoutUnit topOfFirstText() const;
173 
174     bool containsOnlyHTMLWhitespace(unsigned from, unsigned length) const;
175 
176     bool canUseSimplifiedTextMeasuring() const { return m_canUseSimplifiedTextMeasuring; }
177 
178     Vector&lt;std::pair&lt;unsigned, unsigned&gt;&gt; draggedContentRangesBetweenOffsets(unsigned startOffset, unsigned endOffset) const;
179 
180     RenderInline* inlineWrapperForDisplayContents();
181     void setInlineWrapperForDisplayContents(RenderInline*);
182 
183     static RenderText* findByDisplayContentsInlineWrapperCandidate(RenderElement&amp;);
184 
185 protected:
186     virtual void computePreferredLogicalWidths(float leadWidth);
187     void willBeDestroyed() override;
188 
</pre>
</td>
<td>
<hr />
<pre>
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #pragma once
 24 
 25 #include &quot;RenderElement.h&quot;
 26 #include &quot;RenderTextLineBoxes.h&quot;
 27 #include &quot;SimpleLineLayout.h&quot;
 28 #include &quot;Text.h&quot;
 29 #include &lt;wtf/Forward.h&gt;
 30 #include &lt;wtf/text/TextBreakIterator.h&gt;
 31 
 32 namespace WebCore {
 33 
 34 class Font;
 35 class InlineTextBox;
 36 struct GlyphOverflow;
 37 
<span class="line-added"> 38 namespace LayoutIntegration {</span>
<span class="line-added"> 39 class LineLayout;</span>
<span class="line-added"> 40 }</span>
<span class="line-added"> 41 </span>
 42 class RenderText : public RenderObject {
 43     WTF_MAKE_ISO_ALLOCATED(RenderText);
 44 public:
 45     RenderText(Text&amp;, const String&amp;);
 46     RenderText(Document&amp;, const String&amp;);
 47 
 48     virtual ~RenderText();
 49 
 50     WEBCORE_EXPORT Text* textNode() const;
 51 
 52     virtual bool isTextFragment() const;
 53 
 54     const RenderStyle&amp; style() const;
 55     const RenderStyle&amp; firstLineStyle() const;
 56     const RenderStyle* getCachedPseudoStyle(PseudoId, const RenderStyle* parentStyle = nullptr) const;
 57 
 58     Color selectionBackgroundColor() const;
 59     Color selectionForegroundColor() const;
 60     Color selectionEmphasisMarkColor() const;
 61     std::unique_ptr&lt;RenderStyle&gt; selectionPseudoStyle() const;
 62 
 63     virtual String originalText() const;
 64 
 65     void extractTextBox(InlineTextBox&amp; box) { m_lineBoxes.extract(box); }
 66     void attachTextBox(InlineTextBox&amp; box) { m_lineBoxes.attach(box); }
 67     void removeTextBox(InlineTextBox&amp; box) { m_lineBoxes.remove(box); }
 68 
 69     StringImpl&amp; text() const { return *m_text.impl(); } // Since m_text can never be null, returning this type means callers won&#39;t null check.
 70     String textWithoutConvertingBackslashToYenSymbol() const;
 71 
 72     InlineTextBox* createInlineTextBox() { return m_lineBoxes.createAndAppendLineBox(*this); }
 73     void dirtyLineBoxes(bool fullLayout);
 74 
 75     void absoluteRects(Vector&lt;IntRect&gt;&amp;, const LayoutPoint&amp; accumulatedOffset) const final;
 76     Vector&lt;IntRect&gt; absoluteRectsForRange(unsigned startOffset = 0, unsigned endOffset = UINT_MAX, bool useSelectionHeight = false, bool* wasFixed = nullptr) const;
 77 #if PLATFORM(IOS_FAMILY)
 78     void collectSelectionRects(Vector&lt;SelectionRect&gt;&amp;, unsigned startOffset = 0, unsigned endOffset = std::numeric_limits&lt;unsigned&gt;::max()) final;
 79 #endif
 80 
 81     void absoluteQuads(Vector&lt;FloatQuad&gt;&amp;, bool* wasFixed) const final;
<span class="line-modified"> 82     Vector&lt;FloatQuad&gt; absoluteQuadsForRange(unsigned startOffset = 0, unsigned endOffset = UINT_MAX, bool useSelectionHeight = false, bool ignoreEmptyTextSelections = false, bool* wasFixed = nullptr) const;</span>
 83 
 84     Vector&lt;FloatQuad&gt; absoluteQuadsClippedToEllipsis() const;
 85 
 86     Position positionForPoint(const LayoutPoint&amp;) final;
 87 
 88     UChar characterAt(unsigned) const;
 89     unsigned length() const final { return text().length(); }
 90 
 91     void positionLineBox(InlineTextBox&amp;);
 92 
 93     virtual float width(unsigned from, unsigned length, const FontCascade&amp;, float xPos, HashSet&lt;const Font*&gt;* fallbackFonts = nullptr, GlyphOverflow* = nullptr) const;
 94     virtual float width(unsigned from, unsigned length, float xPos, bool firstLine = false, HashSet&lt;const Font*&gt;* fallbackFonts = nullptr, GlyphOverflow* = nullptr) const;
 95 
 96     float minLogicalWidth() const;
 97     float maxLogicalWidth() const;
 98 
 99     struct Widths {
100         float min { 0 };
101         float max { 0 };
102         float beginMin { 0 };
</pre>
<hr />
<pre>
151     void momentarilyRevealLastTypedCharacter(unsigned offsetAfterLastTypedCharacter);
152 
153     InlineTextBox* findNextInlineTextBox(int offset, int&amp; pos) const { return m_lineBoxes.findNext(offset, pos); }
154 
155     bool isAllCollapsibleWhitespace() const;
156 
157     bool canUseSimpleFontCodePath() const { return m_canUseSimpleFontCodePath; }
158 
159     void removeAndDestroyTextBoxes();
160 
161     virtual void styleDidChange(StyleDifference, const RenderStyle* oldStyle);
162 
163     virtual std::unique_ptr&lt;InlineTextBox&gt; createTextBox();
164 
165 #if ENABLE(TEXT_AUTOSIZING)
166     float candidateComputedTextSize() const { return m_candidateComputedTextSize; }
167     void setCandidateComputedTextSize(float size) { m_candidateComputedTextSize = size; }
168 #endif
169 
170     void ensureLineBoxes();

171     const SimpleLineLayout::Layout* simpleLineLayout() const;
<span class="line-added">172 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">173     const LayoutIntegration::LineLayout* layoutFormattingContextLineLayout() const;</span>
<span class="line-added">174 #endif</span>
<span class="line-added">175     bool usesComplexLineLayoutPath() const;</span>
176 
177     StringView stringView(unsigned start = 0, Optional&lt;unsigned&gt; stop = WTF::nullopt) const;
178 
179     LayoutUnit topOfFirstText() const;
180 
181     bool containsOnlyHTMLWhitespace(unsigned from, unsigned length) const;
182 
183     bool canUseSimplifiedTextMeasuring() const { return m_canUseSimplifiedTextMeasuring; }
184 
185     Vector&lt;std::pair&lt;unsigned, unsigned&gt;&gt; draggedContentRangesBetweenOffsets(unsigned startOffset, unsigned endOffset) const;
186 
187     RenderInline* inlineWrapperForDisplayContents();
188     void setInlineWrapperForDisplayContents(RenderInline*);
189 
190     static RenderText* findByDisplayContentsInlineWrapperCandidate(RenderElement&amp;);
191 
192 protected:
193     virtual void computePreferredLogicalWidths(float leadWidth);
194     void willBeDestroyed() override;
195 
</pre>
</td>
</tr>
</table>
<center><a href="RenderText.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderTextLineBoxes.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
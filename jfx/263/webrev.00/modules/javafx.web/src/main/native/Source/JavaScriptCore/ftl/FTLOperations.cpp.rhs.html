<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2014-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FTLOperations.h&quot;
 28 
 29 #if ENABLE(FTL_JIT)
 30 
 31 #include &quot;BytecodeStructs.h&quot;
 32 #include &quot;ClonedArguments.h&quot;
 33 #include &quot;CommonSlowPaths.h&quot;
 34 #include &quot;DirectArguments.h&quot;
 35 #include &quot;FTLJITCode.h&quot;
 36 #include &quot;FTLLazySlowPath.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 37 #include &quot;FrameTracers.h&quot;</span>
 38 #include &quot;InlineCallFrame.h&quot;
 39 #include &quot;Interpreter.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 40 #include &quot;JSArrayIterator.h&quot;</span>
 41 #include &quot;JSAsyncFunction.h&quot;
 42 #include &quot;JSAsyncGeneratorFunction.h&quot;
 43 #include &quot;JSCInlines.h&quot;
<a name="3" id="anc3"></a>
 44 #include &quot;JSGeneratorFunction.h&quot;
 45 #include &quot;JSImmutableButterfly.h&quot;
 46 #include &quot;JSLexicalEnvironment.h&quot;
 47 #include &quot;RegExpObject.h&quot;
 48 
<a name="4" id="anc4"></a><span class="line-added"> 49 IGNORE_WARNINGS_BEGIN(&quot;frame-address&quot;)</span>
<span class="line-added"> 50 </span>
 51 namespace JSC { namespace FTL {
 52 
<a name="5" id="anc5"></a><span class="line-modified"> 53 extern &quot;C&quot; void JIT_OPERATION operationPopulateObjectInOSR(JSGlobalObject* globalObject, ExitTimeObjectMaterialization* materialization, EncodedJSValue* encodedValue, EncodedJSValue* values)</span>


 54 {
 55     using namespace DFG;
<a name="6" id="anc6"></a><span class="line-modified"> 56     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 57     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 58     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 59 </span>
<span class="line-added"> 60     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
 61 
 62     // We cannot GC. We&#39;ve got pointers in evil places.
 63     // FIXME: We are not doing anything that can GC here, and this is
 64     // probably unnecessary.
 65     DeferGCForAWhile deferGC(vm.heap);
 66 
 67     switch (materialization-&gt;type()) {
 68     case PhantomNewObject: {
 69         JSFinalObject* object = jsCast&lt;JSFinalObject*&gt;(JSValue::decode(*encodedValue));
 70         Structure* structure = object-&gt;structure(vm);
 71 
 72         // Figure out what the heck to populate the object with. Use
 73         // getPropertiesConcurrently() because that happens to be
 74         // lower-level and more convenient. It doesn&#39;t change the
 75         // materialization of the property table. We want to have
 76         // minimal visible effects on the system. Also, don&#39;t mind
 77         // that this is O(n^2). It doesn&#39;t matter. We only get here
 78         // from OSR exit.
 79         for (PropertyMapEntry entry : structure-&gt;getPropertiesConcurrently()) {
 80             for (unsigned i = materialization-&gt;properties().size(); i--;) {
 81                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
 82                 if (property.location().kind() != NamedPropertyPLoc)
 83                     continue;
 84                 if (codeBlock-&gt;identifier(property.location().info()).impl() != entry.key)
 85                     continue;
 86 
 87                 object-&gt;putDirect(vm, entry.offset, JSValue::decode(values[i]));
 88             }
 89         }
 90         break;
 91     }
 92 
 93     case PhantomNewFunction:
 94     case PhantomNewGeneratorFunction:
 95     case PhantomNewAsyncFunction:
 96     case PhantomNewAsyncGeneratorFunction:
 97     case PhantomDirectArguments:
 98     case PhantomClonedArguments:
 99     case PhantomCreateRest:
100     case PhantomSpread:
101     case PhantomNewArrayWithSpread:
102     case PhantomNewArrayBuffer:
103         // Those are completely handled by operationMaterializeObjectInOSR
104         break;
105 
106     case PhantomCreateActivation: {
107         JSLexicalEnvironment* activation = jsCast&lt;JSLexicalEnvironment*&gt;(JSValue::decode(*encodedValue));
108 
109         // Figure out what to populate the activation with
110         for (unsigned i = materialization-&gt;properties().size(); i--;) {
111             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
112             if (property.location().kind() != ClosureVarPLoc)
113                 continue;
114 
115             activation-&gt;variableAt(ScopeOffset(property.location().info())).set(vm, activation, JSValue::decode(values[i]));
116         }
117 
118         break;
119     }
120 
<a name="7" id="anc7"></a><span class="line-added">121     case PhantomNewArrayIterator: {</span>
<span class="line-added">122         JSArrayIterator* arrayIterator = jsCast&lt;JSArrayIterator*&gt;(JSValue::decode(*encodedValue));</span>
<span class="line-added">123 </span>
<span class="line-added">124         // Figure out what to populate the iterator with</span>
<span class="line-added">125         for (unsigned i = materialization-&gt;properties().size(); i--;) {</span>
<span class="line-added">126             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];</span>
<span class="line-added">127             if (property.location().kind() != InternalFieldObjectPLoc)</span>
<span class="line-added">128                 continue;</span>
<span class="line-added">129             arrayIterator-&gt;internalField(static_cast&lt;JSArrayIterator::Field&gt;(property.location().info())).set(vm, arrayIterator, JSValue::decode(values[i]));</span>
<span class="line-added">130         }</span>
<span class="line-added">131         break;</span>
<span class="line-added">132     }</span>
<span class="line-added">133 </span>
134     case PhantomNewRegexp: {
135         RegExpObject* regExpObject = jsCast&lt;RegExpObject*&gt;(JSValue::decode(*encodedValue));
136 
137         for (unsigned i = materialization-&gt;properties().size(); i--;) {
138             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
139             if (property.location().kind() != RegExpObjectLastIndexPLoc)
140                 continue;
141 
<a name="8" id="anc8"></a><span class="line-modified">142             regExpObject-&gt;setLastIndex(globalObject, JSValue::decode(values[i]), false /* shouldThrow */);</span>
143             break;
144         }
145         break;
146     }
147 
148     default:
149         RELEASE_ASSERT_NOT_REACHED();
150         break;
151 
152     }
153 }
154 
<a name="9" id="anc9"></a><span class="line-modified">155 extern &quot;C&quot; JSCell* JIT_OPERATION operationMaterializeObjectInOSR(JSGlobalObject* globalObject, ExitTimeObjectMaterialization* materialization, EncodedJSValue* values)</span>

156 {
157     using namespace DFG;
<a name="10" id="anc10"></a><span class="line-modified">158     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">159     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">160     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
161 
162     // We cannot GC. We&#39;ve got pointers in evil places.
163     DeferGCForAWhile deferGC(vm.heap);
164 
165     switch (materialization-&gt;type()) {
166     case PhantomNewObject: {
167         // Figure out what the structure is
168         Structure* structure = nullptr;
169         for (unsigned i = materialization-&gt;properties().size(); i--;) {
170             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
171             if (property.location() != PromotedLocationDescriptor(StructurePLoc))
172                 continue;
173 
174             RELEASE_ASSERT(JSValue::decode(values[i]).asCell()-&gt;inherits&lt;Structure&gt;(vm));
175             structure = jsCast&lt;Structure*&gt;(JSValue::decode(values[i]));
176             break;
177         }
178         RELEASE_ASSERT(structure);
179 
180         JSFinalObject* result = JSFinalObject::create(vm, structure);
181 
182         // The real values will be put subsequently by
183         // operationPopulateNewObjectInOSR. We can&#39;t fill them in
184         // now, because they may not be available yet (typically
185         // because we have a cyclic dependency graph).
186 
187         // We put a dummy value here in order to avoid super-subtle
188         // GC-and-OSR-exit crashes in case we have a bug and some
189         // field is, for any reason, not filled later.
190         // We use a random-ish number instead of a sensible value like
191         // undefined to make possible bugs easier to track.
192         for (PropertyMapEntry entry : structure-&gt;getPropertiesConcurrently())
193             result-&gt;putDirect(vm, entry.offset, jsNumber(19723));
194 
195         return result;
196     }
197 
198     case PhantomNewFunction:
199     case PhantomNewGeneratorFunction:
200     case PhantomNewAsyncGeneratorFunction:
201     case PhantomNewAsyncFunction: {
202         // Figure out what the executable and activation are
203         FunctionExecutable* executable = nullptr;
204         JSScope* activation = nullptr;
205         for (unsigned i = materialization-&gt;properties().size(); i--;) {
206             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
207             if (property.location() == PromotedLocationDescriptor(FunctionExecutablePLoc)) {
208                 RELEASE_ASSERT(JSValue::decode(values[i]).asCell()-&gt;inherits&lt;FunctionExecutable&gt;(vm));
209                 executable = jsCast&lt;FunctionExecutable*&gt;(JSValue::decode(values[i]));
210             }
211             if (property.location() == PromotedLocationDescriptor(FunctionActivationPLoc)) {
212                 RELEASE_ASSERT(JSValue::decode(values[i]).asCell()-&gt;inherits&lt;JSScope&gt;(vm));
213                 activation = jsCast&lt;JSScope*&gt;(JSValue::decode(values[i]));
214             }
215         }
216         RELEASE_ASSERT(executable &amp;&amp; activation);
217 
218         if (materialization-&gt;type() == PhantomNewFunction)
219             return JSFunction::createWithInvalidatedReallocationWatchpoint(vm, executable, activation);
220         else if (materialization-&gt;type() == PhantomNewGeneratorFunction)
221             return JSGeneratorFunction::createWithInvalidatedReallocationWatchpoint(vm, executable, activation);
222         else if (materialization-&gt;type() == PhantomNewAsyncGeneratorFunction)
223             return JSAsyncGeneratorFunction::createWithInvalidatedReallocationWatchpoint(vm, executable, activation);
224         ASSERT(materialization-&gt;type() == PhantomNewAsyncFunction);
225         return JSAsyncFunction::createWithInvalidatedReallocationWatchpoint(vm, executable, activation);
226     }
227 
228     case PhantomCreateActivation: {
229         // Figure out what the scope and symbol table are
230         JSScope* scope = nullptr;
231         SymbolTable* table = nullptr;
232         for (unsigned i = materialization-&gt;properties().size(); i--;) {
233             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
234             if (property.location() == PromotedLocationDescriptor(ActivationScopePLoc)) {
235                 RELEASE_ASSERT(JSValue::decode(values[i]).asCell()-&gt;inherits&lt;JSScope&gt;(vm));
236                 scope = jsCast&lt;JSScope*&gt;(JSValue::decode(values[i]));
237             } else if (property.location() == PromotedLocationDescriptor(ActivationSymbolTablePLoc)) {
238                 RELEASE_ASSERT(JSValue::decode(values[i]).asCell()-&gt;inherits&lt;SymbolTable&gt;(vm));
239                 table = jsCast&lt;SymbolTable*&gt;(JSValue::decode(values[i]));
240             }
241         }
242         RELEASE_ASSERT(scope);
243         RELEASE_ASSERT(table);
244 
245         CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<a name="11" id="anc11"></a><span class="line-modified">246             materialization-&gt;origin(), callFrame-&gt;codeBlock()-&gt;baselineAlternative());</span>
247         Structure* structure = codeBlock-&gt;globalObject()-&gt;activationStructure();
248 
249         // It doesn&#39;t matter what values we initialize as bottom values inside the activation constructor because
250         // activation sinking will set bottom values for each slot.
251         // FIXME: Slight optimization would be to create a constructor that doesn&#39;t initialize all slots.
252         JSLexicalEnvironment* result = JSLexicalEnvironment::create(vm, structure, scope, table, jsUndefined());
253 
254         RELEASE_ASSERT(materialization-&gt;properties().size() - 2 == table-&gt;scopeSize());
255 
256         // The real values will be put subsequently by
257         // operationPopulateNewObjectInOSR. See the PhantomNewObject
258         // case for details.
259         for (unsigned i = materialization-&gt;properties().size(); i--;) {
260             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
261             if (property.location().kind() != ClosureVarPLoc)
262                 continue;
263 
264             result-&gt;variableAt(ScopeOffset(property.location().info())).set(
265                 vm, result, jsNumber(29834));
266         }
267 
268         if (validationEnabled()) {
269             // Validate to make sure every slot in the scope has one value.
270             ConcurrentJSLocker locker(table-&gt;m_lock);
271             for (auto iter = table-&gt;begin(locker), end = table-&gt;end(locker); iter != end; ++iter) {
272                 bool found = false;
273                 for (unsigned i = materialization-&gt;properties().size(); i--;) {
274                     const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
275                     if (property.location().kind() != ClosureVarPLoc)
276                         continue;
277                     if (ScopeOffset(property.location().info()) == iter-&gt;value.scopeOffset()) {
278                         found = true;
279                         break;
280                     }
281                 }
282                 ASSERT_UNUSED(found, found);
283             }
284             unsigned numberOfClosureVarPloc = 0;
285             for (unsigned i = materialization-&gt;properties().size(); i--;) {
286                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
287                 if (property.location().kind() == ClosureVarPLoc)
288                     numberOfClosureVarPloc++;
289             }
290             ASSERT(numberOfClosureVarPloc == table-&gt;scopeSize());
291         }
292 
293         return result;
294     }
295 
<a name="12" id="anc12"></a><span class="line-added">296     case PhantomNewArrayIterator: {</span>
<span class="line-added">297         // Figure out what structure.</span>
<span class="line-added">298         Structure* structure = nullptr;</span>
<span class="line-added">299         for (unsigned i = materialization-&gt;properties().size(); i--;) {</span>
<span class="line-added">300             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];</span>
<span class="line-added">301             if (property.location() == PromotedLocationDescriptor(StructurePLoc)) {</span>
<span class="line-added">302                 RELEASE_ASSERT(JSValue::decode(values[i]).asCell()-&gt;inherits&lt;Structure&gt;(vm));</span>
<span class="line-added">303                 structure = jsCast&lt;Structure*&gt;(JSValue::decode(values[i]));</span>
<span class="line-added">304             }</span>
<span class="line-added">305         }</span>
<span class="line-added">306         RELEASE_ASSERT(structure);</span>
<span class="line-added">307 </span>
<span class="line-added">308         JSArrayIterator* result = JSArrayIterator::createWithInitialValues(vm, structure);</span>
<span class="line-added">309 </span>
<span class="line-added">310         RELEASE_ASSERT(materialization-&gt;properties().size() - 1 == JSArrayIterator::numberOfInternalFields);</span>
<span class="line-added">311 </span>
<span class="line-added">312         // The real values will be put subsequently by</span>
<span class="line-added">313         // operationPopulateNewObjectInOSR. See the PhantomNewObject</span>
<span class="line-added">314         // case for details.</span>
<span class="line-added">315         return result;</span>
<span class="line-added">316     }</span>
<span class="line-added">317 </span>
318     case PhantomCreateRest:
319     case PhantomDirectArguments:
320     case PhantomClonedArguments: {
321         if (!materialization-&gt;origin().inlineCallFrame()) {
322             switch (materialization-&gt;type()) {
323             case PhantomDirectArguments:
<a name="13" id="anc13"></a><span class="line-modified">324                 return DirectArguments::createByCopying(globalObject, callFrame);</span>
325             case PhantomClonedArguments:
<a name="14" id="anc14"></a><span class="line-modified">326                 return ClonedArguments::createWithMachineFrame(globalObject, callFrame, ArgumentsMode::Cloned);</span>
327             case PhantomCreateRest: {
328                 CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<a name="15" id="anc15"></a><span class="line-modified">329                     materialization-&gt;origin(), callFrame-&gt;codeBlock()-&gt;baselineAlternative());</span>
330 
331                 unsigned numberOfArgumentsToSkip = codeBlock-&gt;numberOfArgumentsToSkip();
332                 JSGlobalObject* globalObject = codeBlock-&gt;globalObject();
333                 Structure* structure = globalObject-&gt;restParameterStructure();
<a name="16" id="anc16"></a><span class="line-modified">334                 JSValue* argumentsToCopyRegion = callFrame-&gt;addressOfArgumentsStart() + numberOfArgumentsToSkip;</span>
<span class="line-modified">335                 unsigned arraySize = callFrame-&gt;argumentCount() &gt; numberOfArgumentsToSkip ? callFrame-&gt;argumentCount() - numberOfArgumentsToSkip : 0;</span>
<span class="line-modified">336                 return constructArray(globalObject, structure, argumentsToCopyRegion, arraySize);</span>
337             }
338             default:
339                 RELEASE_ASSERT_NOT_REACHED();
340                 return nullptr;
341             }
342         }
343 
344         // First figure out the argument count. If there isn&#39;t one then we represent the machine frame.
345         unsigned argumentCount = 0;
346         if (materialization-&gt;origin().inlineCallFrame()-&gt;isVarargs()) {
347             for (unsigned i = materialization-&gt;properties().size(); i--;) {
348                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
349                 if (property.location() != PromotedLocationDescriptor(ArgumentCountPLoc))
350                     continue;
351                 argumentCount = JSValue::decode(values[i]).asUInt32();
352                 break;
353             }
354         } else
355             argumentCount = materialization-&gt;origin().inlineCallFrame()-&gt;argumentCountIncludingThis;
356         RELEASE_ASSERT(argumentCount);
357 
358         JSFunction* callee = nullptr;
359         if (materialization-&gt;origin().inlineCallFrame()-&gt;isClosureCall) {
360             for (unsigned i = materialization-&gt;properties().size(); i--;) {
361                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
362                 if (property.location() != PromotedLocationDescriptor(ArgumentsCalleePLoc))
363                     continue;
364 
365                 callee = jsCast&lt;JSFunction*&gt;(JSValue::decode(values[i]));
366                 break;
367             }
368         } else
369             callee = materialization-&gt;origin().inlineCallFrame()-&gt;calleeConstant();
370         RELEASE_ASSERT(callee);
371 
372         CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<a name="17" id="anc17"></a><span class="line-modified">373             materialization-&gt;origin(), callFrame-&gt;codeBlock()-&gt;baselineAlternative());</span>
374 
375         // We have an inline frame and we have all of the data we need to recreate it.
376         switch (materialization-&gt;type()) {
377         case PhantomDirectArguments: {
378             unsigned length = argumentCount - 1;
379             unsigned capacity = std::max(length, static_cast&lt;unsigned&gt;(codeBlock-&gt;numParameters() - 1));
380             DirectArguments* result = DirectArguments::create(
381                 vm, codeBlock-&gt;globalObject()-&gt;directArgumentsStructure(), length, capacity);
382             result-&gt;setCallee(vm, callee);
383             for (unsigned i = materialization-&gt;properties().size(); i--;) {
384                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
385                 if (property.location().kind() != ArgumentPLoc)
386                     continue;
387 
388                 unsigned index = property.location().info();
389                 if (index &gt;= capacity)
390                     continue;
391 
392                 // We don&#39;t want to use setIndexQuickly(), since that&#39;s only for the passed-in
393                 // arguments but sometimes the number of named arguments is greater. For
394                 // example:
395                 //
396                 // function foo(a, b, c) { ... }
397                 // foo();
398                 //
399                 // setIndexQuickly() would fail for indices 0, 1, 2 - but we need to recover
400                 // those here.
401                 result-&gt;argument(DirectArgumentsOffset(index)).set(
402                     vm, result, JSValue::decode(values[i]));
403             }
404             return result;
405         }
406         case PhantomClonedArguments: {
407             unsigned length = argumentCount - 1;
408             ClonedArguments* result = ClonedArguments::createEmpty(
409                 vm, codeBlock-&gt;globalObject()-&gt;clonedArgumentsStructure(), callee, length);
410 
411             for (unsigned i = materialization-&gt;properties().size(); i--;) {
412                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
413                 if (property.location().kind() != ArgumentPLoc)
414                     continue;
415 
416                 unsigned index = property.location().info();
417                 if (index &gt;= length)
418                     continue;
<a name="18" id="anc18"></a><span class="line-modified">419                 result-&gt;putDirectIndex(globalObject, index, JSValue::decode(values[i]));</span>
420             }
421 
422             return result;
423         }
424         case PhantomCreateRest: {
425             unsigned numberOfArgumentsToSkip = codeBlock-&gt;numberOfArgumentsToSkip();
426             JSGlobalObject* globalObject = codeBlock-&gt;globalObject();
427             Structure* structure = globalObject-&gt;restParameterStructure();
428             ASSERT(argumentCount &gt; 0);
429             unsigned arraySize = (argumentCount - 1) &gt; numberOfArgumentsToSkip ? argumentCount - 1 - numberOfArgumentsToSkip : 0;
430 
431             // FIXME: we should throw an out of memory error here if tryCreate() fails.
432             // https://bugs.webkit.org/show_bug.cgi?id=169784
433             JSArray* array = JSArray::tryCreate(vm, structure, arraySize);
434             RELEASE_ASSERT(array);
435 
436             for (unsigned i = materialization-&gt;properties().size(); i--;) {
437                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
438                 if (property.location().kind() != ArgumentPLoc)
439                     continue;
440 
441                 unsigned argIndex = property.location().info();
442                 if (numberOfArgumentsToSkip &gt; argIndex)
443                     continue;
444                 unsigned arrayIndex = argIndex - numberOfArgumentsToSkip;
445                 if (arrayIndex &gt;= arraySize)
446                     continue;
<a name="19" id="anc19"></a><span class="line-modified">447                 array-&gt;putDirectIndex(globalObject, arrayIndex, JSValue::decode(values[i]));</span>
448             }
449 
<a name="20" id="anc20"></a><span class="line-modified">450 #if ASSERT_ENABLED</span>
451             // We avoid this O(n^2) loop when asserts are disabled, but the condition checked here
452             // must hold to ensure the correctness of the above loop because of how we allocate the array.
453             for (unsigned targetIndex = 0; targetIndex &lt; arraySize; ++targetIndex) {
454                 bool found = false;
455                 for (unsigned i = materialization-&gt;properties().size(); i--;) {
456                     const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
457                     if (property.location().kind() != ArgumentPLoc)
458                         continue;
459 
460                     unsigned argIndex = property.location().info();
461                     if (numberOfArgumentsToSkip &gt; argIndex)
462                         continue;
463                     unsigned arrayIndex = argIndex - numberOfArgumentsToSkip;
464                     if (arrayIndex &gt;= arraySize)
465                         continue;
466                     if (arrayIndex == targetIndex) {
467                         found = true;
468                         break;
469                     }
470                 }
471                 ASSERT(found);
472             }
<a name="21" id="anc21"></a><span class="line-modified">473 #endif // ASSERT_ENABLED</span>
474             return array;
475         }
476 
477         default:
478             RELEASE_ASSERT_NOT_REACHED();
479             return nullptr;
480         }
481     }
482 
483     case PhantomSpread: {
484         JSArray* array = nullptr;
485         for (unsigned i = materialization-&gt;properties().size(); i--;) {
486             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
487             if (property.location().kind() == SpreadPLoc) {
488                 array = jsCast&lt;JSArray*&gt;(JSValue::decode(values[i]));
489                 break;
490             }
491         }
492         RELEASE_ASSERT(array);
493 
<a name="22" id="anc22"></a><span class="line-modified">494         // Note: it is sound for JSImmutableButterfly::createFromArray to call getDirectIndex here</span>
495         // because we&#39;re guaranteed we won&#39;t be calling any getters. The reason for this is
496         // that we only support PhantomSpread over CreateRest, which is an array we create.
497         // Any attempts to put a getter on any indices on the rest array will escape the array.
<a name="23" id="anc23"></a><span class="line-modified">498         auto* fixedArray = JSImmutableButterfly::createFromArray(globalObject, vm, array);</span>
499         RELEASE_ASSERT(fixedArray);
500         return fixedArray;
501     }
502 
503     case PhantomNewArrayBuffer: {
504         JSImmutableButterfly* immutableButterfly = nullptr;
505         for (unsigned i = materialization-&gt;properties().size(); i--;) {
506             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
507             if (property.location().kind() == NewArrayBufferPLoc) {
508                 immutableButterfly = jsCast&lt;JSImmutableButterfly*&gt;(JSValue::decode(values[i]));
509                 break;
510             }
511         }
512         RELEASE_ASSERT(immutableButterfly);
513 
514         // For now, we use array allocation profile in the actual CodeBlock. It is OK since current NewArrayBuffer
515         // and PhantomNewArrayBuffer are always bound to a specific op_new_array_buffer.
<a name="24" id="anc24"></a><span class="line-modified">516         CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(materialization-&gt;origin(), callFrame-&gt;codeBlock()-&gt;baselineAlternative());</span>
517         const Instruction* currentInstruction = codeBlock-&gt;instructions().at(materialization-&gt;origin().bytecodeIndex()).ptr();
518         if (!currentInstruction-&gt;is&lt;OpNewArrayBuffer&gt;()) {
519             // This case can happen if Object.keys, an OpCall is first converted into a NewArrayBuffer which is then converted into a PhantomNewArrayBuffer.
520             // There is no need to update the array allocation profile in that case.
521             RELEASE_ASSERT(currentInstruction-&gt;is&lt;OpCall&gt;());
<a name="25" id="anc25"></a><span class="line-modified">522             Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(immutableButterfly-&gt;indexingMode());</span>
523             return CommonSlowPaths::allocateNewArrayBuffer(vm, structure, immutableButterfly);
524         }
525         auto newArrayBuffer = currentInstruction-&gt;as&lt;OpNewArrayBuffer&gt;();
526         ArrayAllocationProfile* profile = &amp;newArrayBuffer.metadata(codeBlock).m_arrayAllocationProfile;
527 
528         // FIXME: Share the code with CommonSlowPaths. Currently, codeBlock etc. are slightly different.
529         IndexingType indexingMode = profile-&gt;selectIndexingType();
<a name="26" id="anc26"></a><span class="line-modified">530         Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingMode);</span>
531         ASSERT(isCopyOnWrite(indexingMode));
532         ASSERT(!structure-&gt;outOfLineCapacity());
533 
534         if (UNLIKELY(immutableButterfly-&gt;indexingMode() != indexingMode)) {
535             auto* newButterfly = JSImmutableButterfly::create(vm, indexingMode, immutableButterfly-&gt;length());
536             for (unsigned i = 0; i &lt; immutableButterfly-&gt;length(); ++i)
537                 newButterfly-&gt;setIndex(vm, i, immutableButterfly-&gt;get(i));
538             immutableButterfly = newButterfly;
539 
540             // FIXME: This is kinda gross and only works because we can&#39;t inline new_array_bufffer in the baseline.
541             // We also cannot allocate a new butterfly from compilation threads since it&#39;s invalid to allocate cells from
542             // a compilation thread.
543             WTF::storeStoreFence();
<a name="27" id="anc27"></a><span class="line-modified">544             codeBlock-&gt;constantRegister(newArrayBuffer.m_immutableButterfly).set(vm, codeBlock, immutableButterfly);</span>
545             WTF::storeStoreFence();
546         }
547 
548         JSArray* result = CommonSlowPaths::allocateNewArrayBuffer(vm, structure, immutableButterfly);
549         ArrayAllocationProfile::updateLastAllocationFor(profile, result);
550         return result;
551     }
552 
553     case PhantomNewArrayWithSpread: {
554         CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<a name="28" id="anc28"></a><span class="line-modified">555             materialization-&gt;origin(), callFrame-&gt;codeBlock()-&gt;baselineAlternative());</span>
556         JSGlobalObject* globalObject = codeBlock-&gt;globalObject();
557         Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);
558 
559         Checked&lt;unsigned, RecordOverflow&gt; checkedArraySize = 0;
560         unsigned numProperties = 0;
561         for (unsigned i = materialization-&gt;properties().size(); i--;) {
562             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
563             if (property.location().kind() == NewArrayWithSpreadArgumentPLoc) {
564                 ++numProperties;
565                 JSValue value = JSValue::decode(values[i]);
<a name="29" id="anc29"></a><span class="line-modified">566                 if (JSImmutableButterfly* immutableButterfly = jsDynamicCast&lt;JSImmutableButterfly*&gt;(vm, value))</span>
<span class="line-modified">567                     checkedArraySize += immutableButterfly-&gt;publicLength();</span>
568                 else
569                     checkedArraySize += 1;
570             }
571         }
572 
573         // FIXME: we should throw an out of memory error here if checkedArraySize has hasOverflowed() or tryCreate() fails.
574         // https://bugs.webkit.org/show_bug.cgi?id=169784
575         unsigned arraySize = checkedArraySize.unsafeGet(); // Crashes if overflowed.
576         JSArray* result = JSArray::tryCreate(vm, structure, arraySize);
577         RELEASE_ASSERT(result);
578 
<a name="30" id="anc30"></a><span class="line-modified">579 #if ASSERT_ENABLED</span>
580         // Ensure we see indices for everything in the range: [0, numProperties)
581         for (unsigned i = 0; i &lt; numProperties; ++i) {
582             bool found = false;
583             for (unsigned j = 0; j &lt; materialization-&gt;properties().size(); ++j) {
584                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[j];
585                 if (property.location().kind() == NewArrayWithSpreadArgumentPLoc &amp;&amp; property.location().info() == i) {
586                     found = true;
587                     break;
588                 }
589             }
590             ASSERT(found);
591         }
<a name="31" id="anc31"></a><span class="line-modified">592 #endif // ASSERT_ENABLED</span>
593 
594         Vector&lt;JSValue, 8&gt; arguments;
595         arguments.grow(numProperties);
596 
597         for (unsigned i = materialization-&gt;properties().size(); i--;) {
598             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
599             if (property.location().kind() == NewArrayWithSpreadArgumentPLoc) {
600                 JSValue value = JSValue::decode(values[i]);
601                 RELEASE_ASSERT(property.location().info() &lt; numProperties);
602                 arguments[property.location().info()] = value;
603             }
604         }
605 
606         unsigned arrayIndex = 0;
607         for (JSValue value : arguments) {
<a name="32" id="anc32"></a><span class="line-modified">608             if (JSImmutableButterfly* immutableButterfly = jsDynamicCast&lt;JSImmutableButterfly*&gt;(vm, value)) {</span>
<span class="line-modified">609                 for (unsigned i = 0; i &lt; immutableButterfly-&gt;publicLength(); i++) {</span>
<span class="line-modified">610                     ASSERT(immutableButterfly-&gt;get(i));</span>
<span class="line-modified">611                     result-&gt;putDirectIndex(globalObject, arrayIndex, immutableButterfly-&gt;get(i));</span>
612                     ++arrayIndex;
613                 }
614             } else {
615                 // We are not spreading.
<a name="33" id="anc33"></a><span class="line-modified">616                 result-&gt;putDirectIndex(globalObject, arrayIndex, value);</span>
617                 ++arrayIndex;
618             }
619         }
620 
621         return result;
622     }
623 
624     case PhantomNewRegexp: {
625         RegExp* regExp = nullptr;
626         for (unsigned i = materialization-&gt;properties().size(); i--;) {
627             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
628             if (property.location() == PromotedLocationDescriptor(RegExpObjectRegExpPLoc)) {
629                 RELEASE_ASSERT(JSValue::decode(values[i]).asCell()-&gt;inherits&lt;RegExp&gt;(vm));
630                 regExp = jsCast&lt;RegExp*&gt;(JSValue::decode(values[i]));
631             }
632         }
633         RELEASE_ASSERT(regExp);
<a name="34" id="anc34"></a><span class="line-modified">634         CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(materialization-&gt;origin(), callFrame-&gt;codeBlock()-&gt;baselineAlternative());</span>
635         Structure* structure = codeBlock-&gt;globalObject()-&gt;regExpStructure();
636         return RegExpObject::create(vm, structure, regExp);
637     }
638 
639     default:
640         RELEASE_ASSERT_NOT_REACHED();
641         return nullptr;
642     }
643 }
644 
<a name="35" id="anc35"></a><span class="line-modified">645 extern &quot;C&quot; void* JIT_OPERATION operationCompileFTLLazySlowPath(CallFrame* callFrame, unsigned index)</span>
646 {
<a name="36" id="anc36"></a><span class="line-modified">647     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
648 
649     // We cannot GC. We&#39;ve got pointers in evil places.
650     DeferGCForAWhile deferGC(vm.heap);
651 
<a name="37" id="anc37"></a><span class="line-modified">652     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
653     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;ftl();
654 
655     LazySlowPath&amp; lazySlowPath = *jitCode-&gt;lazySlowPaths[index];
656     lazySlowPath.generate(codeBlock);
657 
658     return lazySlowPath.stub().code().executableAddress();
659 }
660 
661 } } // namespace JSC::FTL
662 
<a name="38" id="anc38"></a><span class="line-added">663 IGNORE_WARNINGS_END</span>
<span class="line-added">664 </span>
665 #endif // ENABLE(FTL_JIT)
666 
<a name="39" id="anc39"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="39" type="hidden" />
</body>
</html>
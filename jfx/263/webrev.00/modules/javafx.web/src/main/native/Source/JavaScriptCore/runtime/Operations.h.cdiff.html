<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Operations.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Operations.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Options.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Operations.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,30 ***</span>
  
  namespace JSC {
  
  #define InvalidPrototypeChain (std::numeric_limits&lt;size_t&gt;::max())
  
<span class="line-modified">! NEVER_INLINE JSValue jsAddSlowCase(CallFrame*, JSValue, JSValue);</span>
<span class="line-modified">! JSValue jsTypeStringForValue(CallFrame*, JSValue);</span>
  JSValue jsTypeStringForValue(VM&amp;, JSGlobalObject*, JSValue);
<span class="line-modified">! bool jsIsObjectTypeOrNull(CallFrame*, JSValue);</span>
<span class="line-modified">! size_t normalizePrototypeChain(CallFrame*, JSCell*, bool&amp; sawPolyProto);</span>
  
<span class="line-modified">! ALWAYS_INLINE JSString* jsString(ExecState* exec, const String&amp; u1, JSString* s2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned length1 = u1.length();
      if (!length1)
          return s2;
      unsigned length2 = s2-&gt;length();
      if (!length2)
          return jsString(vm, u1);
      static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
      if (sumOverflows&lt;int32_t&gt;(length1, length2)) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
  
      // (1) Cost of making JSString    : sizeof(JSString) (for new string) + sizeof(StringImpl header) + length1 + length2
      // (2) Cost of making JSRopeString: sizeof(JSString) (for u1) + sizeof(JSRopeString)
<span class="line-new-header">--- 29,30 ---</span>
  
  namespace JSC {
  
  #define InvalidPrototypeChain (std::numeric_limits&lt;size_t&gt;::max())
  
<span class="line-modified">! NEVER_INLINE JSValue jsAddSlowCase(JSGlobalObject*, JSValue, JSValue);</span>
<span class="line-modified">! JSValue jsTypeStringForValue(JSGlobalObject*, JSValue);</span>
  JSValue jsTypeStringForValue(VM&amp;, JSGlobalObject*, JSValue);
<span class="line-modified">! bool jsIsObjectTypeOrNull(JSGlobalObject*, JSValue);</span>
<span class="line-modified">! size_t normalizePrototypeChain(JSGlobalObject*, JSCell*, bool&amp; sawPolyProto);</span>
  
<span class="line-modified">! ALWAYS_INLINE JSString* jsString(JSGlobalObject* globalObject, const String&amp; u1, JSString* s2)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned length1 = u1.length();
      if (!length1)
          return s2;
      unsigned length2 = s2-&gt;length();
      if (!length2)
          return jsString(vm, u1);
      static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
      if (sumOverflows&lt;int32_t&gt;(length1, length2)) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
  
      // (1) Cost of making JSString    : sizeof(JSString) (for new string) + sizeof(StringImpl header) + length1 + length2
      // (2) Cost of making JSRopeString: sizeof(JSString) (for u1) + sizeof(JSRopeString)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 61,201 ***</span>
      // strings are relatively rare. But we can do that if we need to consider it.
      if (s2-&gt;isRope() || (StringImpl::headerSize&lt;LChar&gt;() + length1 + length2) &gt;= sizeof(JSRopeString))
          return JSRopeString::create(vm, jsString(vm, u1), s2);
  
      ASSERT(!s2-&gt;isRope());
<span class="line-modified">!     const String&amp; u2 = s2-&gt;value(exec);</span>
      scope.assertNoException();
      String newString = tryMakeString(u1, u2);
      if (!newString) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
      return JSString::create(vm, newString.releaseImpl().releaseNonNull());
  }
  
<span class="line-modified">! ALWAYS_INLINE JSString* jsString(ExecState* exec, JSString* s1, const String&amp; u2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned length1 = s1-&gt;length();
      if (!length1)
          return jsString(vm, u2);
      unsigned length2 = u2.length();
      if (!length2)
          return s1;
      static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
      if (sumOverflows&lt;int32_t&gt;(length1, length2)) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
  
      // (1) Cost of making JSString    : sizeof(JSString) (for new string) + sizeof(StringImpl header) + length1 + length2
      // (2) Cost of making JSRopeString: sizeof(JSString) (for u2) + sizeof(JSRopeString)
      if (s1-&gt;isRope() || (StringImpl::headerSize&lt;LChar&gt;() + length1 + length2) &gt;= sizeof(JSRopeString))
          return JSRopeString::create(vm, s1, jsString(vm, u2));
  
      ASSERT(!s1-&gt;isRope());
<span class="line-modified">!     const String&amp; u1 = s1-&gt;value(exec);</span>
      scope.assertNoException();
      String newString = tryMakeString(u1, u2);
      if (!newString) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
      return JSString::create(vm, newString.releaseImpl().releaseNonNull());
  }
  
<span class="line-modified">! ALWAYS_INLINE JSString* jsString(ExecState* exec, JSString* s1, JSString* s2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned length1 = s1-&gt;length();
      if (!length1)
          return s2;
      unsigned length2 = s2-&gt;length();
      if (!length2)
          return s1;
      static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
      if (sumOverflows&lt;int32_t&gt;(length1, length2)) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
  
      return JSRopeString::create(vm, s1, s2);
  }
  
<span class="line-modified">! ALWAYS_INLINE JSString* jsString(ExecState* exec, JSString* s1, JSString* s2, JSString* s3)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned length1 = s1-&gt;length();
      if (!length1)
<span class="line-modified">!         RELEASE_AND_RETURN(scope, jsString(exec, s2, s3));</span>
  
      unsigned length2 = s2-&gt;length();
      if (!length2)
<span class="line-modified">!         RELEASE_AND_RETURN(scope, jsString(exec, s1, s3));</span>
  
      unsigned length3 = s3-&gt;length();
      if (!length3)
<span class="line-modified">!         RELEASE_AND_RETURN(scope, jsString(exec, s1, s2));</span>
  
      static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
      if (sumOverflows&lt;int32_t&gt;(length1, length2, length3)) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
  
      return JSRopeString::create(vm, s1, s2, s3);
  }
  
<span class="line-modified">! ALWAYS_INLINE JSString* jsString(ExecState* exec, const String&amp; u1, const String&amp; u2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned length1 = u1.length();
      if (!length1)
          return jsString(vm, u2);
      unsigned length2 = u2.length();
      if (!length2)
          return jsString(vm, u1);
      static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
      if (sumOverflows&lt;int32_t&gt;(length1, length2)) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
  
      // (1) Cost of making JSString    : sizeof(JSString) (for new string) + sizeof(StringImpl header) + length1 + length2
      // (2) Cost of making JSRopeString: sizeof(JSString) (for u1) + sizeof(JSString) (for u2) + sizeof(JSRopeString)
      if ((StringImpl::headerSize&lt;LChar&gt;() + length1 + length2) &gt;= (sizeof(JSRopeString) + sizeof(JSString)))
          return JSRopeString::create(vm, jsString(vm, u1), jsString(vm, u2));
  
      String newString = tryMakeString(u1, u2);
      if (!newString) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
      return JSString::create(vm, newString.releaseImpl().releaseNonNull());
  }
  
<span class="line-modified">! ALWAYS_INLINE JSString* jsString(ExecState* exec, const String&amp; u1, const String&amp; u2, const String&amp; u3)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned length1 = u1.length();
      unsigned length2 = u2.length();
      unsigned length3 = u3.length();
      ASSERT(length1 &lt;= JSString::MaxLength);
      ASSERT(length2 &lt;= JSString::MaxLength);
      ASSERT(length3 &lt;= JSString::MaxLength);
  
      if (!length1)
<span class="line-modified">!         RELEASE_AND_RETURN(scope, jsString(exec, u2, u3));</span>
  
      if (!length2)
<span class="line-modified">!         RELEASE_AND_RETURN(scope, jsString(exec, u1, u3));</span>
  
      if (!length3)
<span class="line-modified">!         RELEASE_AND_RETURN(scope, jsString(exec, u1, u2));</span>
  
      static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
      if (sumOverflows&lt;int32_t&gt;(length1, length2, length3)) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
  
      // (1) Cost of making JSString    : sizeof(JSString) (for new string) + sizeof(StringImpl header) + length1 + length2 + length3
      // (2) Cost of making JSRopeString: sizeof(JSString) (for u1) + sizeof(JSString) (for u2) + sizeof(JSString) (for u3) + sizeof(JSRopeString)
      if ((StringImpl::headerSize&lt;LChar&gt;() + length1 + length2 + length3) &gt;= (sizeof(JSRopeString) + sizeof(JSString) * 2))
          return JSRopeString::create(vm, jsString(vm, u1), jsString(vm, u2), jsString(vm, u3));
  
      String newString = tryMakeString(u1, u2, u3);
      if (!newString) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
      return JSString::create(vm, newString.releaseImpl().releaseNonNull());
  }
  
<span class="line-modified">! ALWAYS_INLINE JSValue jsStringFromRegisterArray(ExecState* exec, Register* strings, unsigned count)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSRopeString::RopeBuilder&lt;RecordOverflow&gt; ropeBuilder(vm);
  
      for (unsigned i = 0; i &lt; count; ++i) {
          JSValue v = strings[-static_cast&lt;int&gt;(i)].jsValue();
<span class="line-modified">!         JSString* string = v.toString(exec);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (!ropeBuilder.append(string))
<span class="line-modified">!             return throwOutOfMemoryError(exec, scope);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return ropeBuilder.release();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- ALWAYS_INLINE JSValue jsStringFromArguments(ExecState* exec, JSValue thisValue)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">-     JSRopeString::RopeBuilder&lt;RecordOverflow&gt; ropeBuilder(vm);</span>
<span class="line-removed">-     JSString* str = thisValue.toString(exec);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-removed">-     ropeBuilder.append(str);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-removed">-         JSValue v = exec-&gt;argument(i);</span>
<span class="line-removed">-         JSString* str = v.toString(exec);</span>
<span class="line-removed">-         RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-removed">-         if (UNLIKELY(!ropeBuilder.append(str)))</span>
<span class="line-removed">-             return throwOutOfMemoryError(exec, scope);</span>
      }
  
      return ropeBuilder.release();
  }
  
<span class="line-new-header">--- 61,181 ---</span>
      // strings are relatively rare. But we can do that if we need to consider it.
      if (s2-&gt;isRope() || (StringImpl::headerSize&lt;LChar&gt;() + length1 + length2) &gt;= sizeof(JSRopeString))
          return JSRopeString::create(vm, jsString(vm, u1), s2);
  
      ASSERT(!s2-&gt;isRope());
<span class="line-modified">!     const String&amp; u2 = s2-&gt;value(globalObject);</span>
      scope.assertNoException();
      String newString = tryMakeString(u1, u2);
      if (!newString) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
      return JSString::create(vm, newString.releaseImpl().releaseNonNull());
  }
  
<span class="line-modified">! ALWAYS_INLINE JSString* jsString(JSGlobalObject* globalObject, JSString* s1, const String&amp; u2)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned length1 = s1-&gt;length();
      if (!length1)
          return jsString(vm, u2);
      unsigned length2 = u2.length();
      if (!length2)
          return s1;
      static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
      if (sumOverflows&lt;int32_t&gt;(length1, length2)) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
  
      // (1) Cost of making JSString    : sizeof(JSString) (for new string) + sizeof(StringImpl header) + length1 + length2
      // (2) Cost of making JSRopeString: sizeof(JSString) (for u2) + sizeof(JSRopeString)
      if (s1-&gt;isRope() || (StringImpl::headerSize&lt;LChar&gt;() + length1 + length2) &gt;= sizeof(JSRopeString))
          return JSRopeString::create(vm, s1, jsString(vm, u2));
  
      ASSERT(!s1-&gt;isRope());
<span class="line-modified">!     const String&amp; u1 = s1-&gt;value(globalObject);</span>
      scope.assertNoException();
      String newString = tryMakeString(u1, u2);
      if (!newString) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
      return JSString::create(vm, newString.releaseImpl().releaseNonNull());
  }
  
<span class="line-modified">! ALWAYS_INLINE JSString* jsString(JSGlobalObject* globalObject, JSString* s1, JSString* s2)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned length1 = s1-&gt;length();
      if (!length1)
          return s2;
      unsigned length2 = s2-&gt;length();
      if (!length2)
          return s1;
      static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
      if (sumOverflows&lt;int32_t&gt;(length1, length2)) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
  
      return JSRopeString::create(vm, s1, s2);
  }
  
<span class="line-modified">! ALWAYS_INLINE JSString* jsString(JSGlobalObject* globalObject, JSString* s1, JSString* s2, JSString* s3)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned length1 = s1-&gt;length();
      if (!length1)
<span class="line-modified">!         RELEASE_AND_RETURN(scope, jsString(globalObject, s2, s3));</span>
  
      unsigned length2 = s2-&gt;length();
      if (!length2)
<span class="line-modified">!         RELEASE_AND_RETURN(scope, jsString(globalObject, s1, s3));</span>
  
      unsigned length3 = s3-&gt;length();
      if (!length3)
<span class="line-modified">!         RELEASE_AND_RETURN(scope, jsString(globalObject, s1, s2));</span>
  
      static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
      if (sumOverflows&lt;int32_t&gt;(length1, length2, length3)) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
  
      return JSRopeString::create(vm, s1, s2, s3);
  }
  
<span class="line-modified">! ALWAYS_INLINE JSString* jsString(JSGlobalObject* globalObject, const String&amp; u1, const String&amp; u2)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned length1 = u1.length();
      if (!length1)
          return jsString(vm, u2);
      unsigned length2 = u2.length();
      if (!length2)
          return jsString(vm, u1);
      static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
      if (sumOverflows&lt;int32_t&gt;(length1, length2)) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
  
      // (1) Cost of making JSString    : sizeof(JSString) (for new string) + sizeof(StringImpl header) + length1 + length2
      // (2) Cost of making JSRopeString: sizeof(JSString) (for u1) + sizeof(JSString) (for u2) + sizeof(JSRopeString)
      if ((StringImpl::headerSize&lt;LChar&gt;() + length1 + length2) &gt;= (sizeof(JSRopeString) + sizeof(JSString)))
          return JSRopeString::create(vm, jsString(vm, u1), jsString(vm, u2));
  
      String newString = tryMakeString(u1, u2);
      if (!newString) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
      return JSString::create(vm, newString.releaseImpl().releaseNonNull());
  }
  
<span class="line-modified">! ALWAYS_INLINE JSString* jsString(JSGlobalObject* globalObject, const String&amp; u1, const String&amp; u2, const String&amp; u3)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned length1 = u1.length();
      unsigned length2 = u2.length();
      unsigned length3 = u3.length();
      ASSERT(length1 &lt;= JSString::MaxLength);
      ASSERT(length2 &lt;= JSString::MaxLength);
      ASSERT(length3 &lt;= JSString::MaxLength);
  
      if (!length1)
<span class="line-modified">!         RELEASE_AND_RETURN(scope, jsString(globalObject, u2, u3));</span>
  
      if (!length2)
<span class="line-modified">!         RELEASE_AND_RETURN(scope, jsString(globalObject, u1, u3));</span>
  
      if (!length3)
<span class="line-modified">!         RELEASE_AND_RETURN(scope, jsString(globalObject, u1, u2));</span>
  
      static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
      if (sumOverflows&lt;int32_t&gt;(length1, length2, length3)) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
  
      // (1) Cost of making JSString    : sizeof(JSString) (for new string) + sizeof(StringImpl header) + length1 + length2 + length3
      // (2) Cost of making JSRopeString: sizeof(JSString) (for u1) + sizeof(JSString) (for u2) + sizeof(JSString) (for u3) + sizeof(JSRopeString)
      if ((StringImpl::headerSize&lt;LChar&gt;() + length1 + length2 + length3) &gt;= (sizeof(JSRopeString) + sizeof(JSString) * 2))
          return JSRopeString::create(vm, jsString(vm, u1), jsString(vm, u2), jsString(vm, u3));
  
      String newString = tryMakeString(u1, u2, u3);
      if (!newString) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
      return JSString::create(vm, newString.releaseImpl().releaseNonNull());
  }
  
<span class="line-modified">! ALWAYS_INLINE JSValue jsStringFromRegisterArray(JSGlobalObject* globalObject, Register* strings, unsigned count)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSRopeString::RopeBuilder&lt;RecordOverflow&gt; ropeBuilder(vm);
  
      for (unsigned i = 0; i &lt; count; ++i) {
          JSValue v = strings[-static_cast&lt;int&gt;(i)].jsValue();
<span class="line-modified">!         JSString* string = v.toString(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (!ropeBuilder.append(string))
<span class="line-modified">!             return throwOutOfMemoryError(globalObject, scope);</span>
      }
  
      return ropeBuilder.release();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 266,98 ***</span>
  
      ASSERT(comparisonMode == JSBigInt::ComparisonMode::LessThanOrEqual);
      return comparisonResult == JSBigInt::ComparisonResult::LessThan || comparisonResult == JSBigInt::ComparisonResult::Equal;
  }
  
<span class="line-modified">! ALWAYS_INLINE bool bigIntCompare(CallFrame* callFrame, JSValue v1, JSValue v2, JSBigInt::ComparisonMode comparisonMode)</span>
  {
      ASSERT(v1.isBigInt() || v2.isBigInt());
      ASSERT(v1.isPrimitive() &amp;&amp; v2.isPrimitive());
  
<span class="line-modified">!     VM&amp; vm = callFrame-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (v1.isBigInt() &amp;&amp; v2.isBigInt())
          return bigIntCompareResult(JSBigInt::compare(asBigInt(v1), asBigInt(v2)), comparisonMode);
  
      if (v1.isBigInt()) {
          JSValue primValue = v2;
          if (primValue.isString()) {
<span class="line-modified">!             JSBigInt* bigIntValue = JSBigInt::stringToBigInt(callFrame, asString(primValue)-&gt;value(callFrame));</span>
              RETURN_IF_EXCEPTION(scope, false);
              if (!bigIntValue)
                  return false;
  
              return bigIntCompareResult(JSBigInt::compare(asBigInt(v1), bigIntValue), comparisonMode);
          }
  
          if (primValue.isBigInt())
              return bigIntCompareResult(JSBigInt::compare(asBigInt(v1), asBigInt(primValue)), comparisonMode);
  
<span class="line-modified">!         double numberValue = primValue.toNumber(callFrame);</span>
          RETURN_IF_EXCEPTION(scope, false);
          return bigIntCompareResult(JSBigInt::compareToDouble(asBigInt(v1), numberValue), comparisonMode);
      }
  
      JSValue primValue = v1;
      if (primValue.isString()) {
<span class="line-modified">!         JSBigInt* bigIntValue = JSBigInt::stringToBigInt(callFrame, asString(primValue)-&gt;value(callFrame));</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (!bigIntValue)
              return false;
  
          return bigIntCompareResult(JSBigInt::compare(bigIntValue, asBigInt(v2)), comparisonMode);
      }
  
      if (primValue.isBigInt())
          return bigIntCompareResult(JSBigInt::compare(asBigInt(primValue), asBigInt(v2)), comparisonMode);
  
<span class="line-modified">!     double numberValue = primValue.toNumber(callFrame);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      // Here we check inverted because BigInt is the v2
      JSBigInt::ComparisonResult comparisonResult = JSBigInt::compareToDouble(asBigInt(v2), numberValue);
      if (comparisonMode == JSBigInt::ComparisonMode::LessThan)
          return comparisonResult == JSBigInt::ComparisonResult::GreaterThan;
  
      return comparisonResult == JSBigInt::ComparisonResult::GreaterThan || comparisonResult == JSBigInt::ComparisonResult::Equal;
  }
  
<span class="line-modified">! ALWAYS_INLINE bool toPrimitiveNumeric(CallFrame* callFrame, JSValue v, JSValue&amp; p, double&amp; n)</span>
  {
<span class="line-modified">!     VM&amp; vm = callFrame-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     p = v.toPrimitive(callFrame, PreferNumber);</span>
      RETURN_IF_EXCEPTION(scope, false);
      if (p.isBigInt())
          return true;
  
<span class="line-modified">!     n = p.toNumber(callFrame);</span>
      RETURN_IF_EXCEPTION(scope, false);
      return !p.isString();
  }
  
  // See ES5 11.8.1/11.8.2/11.8.5 for definition of leftFirst, this value ensures correct
  // evaluation ordering for argument conversions for &#39;&lt;&#39; and &#39;&gt;&#39;. For &#39;&lt;&#39; pass the value
  // true, for leftFirst, for &#39;&gt;&#39; pass the value false (and reverse operand order).
  template&lt;bool leftFirst&gt;
<span class="line-modified">! ALWAYS_INLINE bool jsLess(CallFrame* callFrame, JSValue v1, JSValue v2)</span>
  {
<span class="line-modified">!     VM&amp; vm = callFrame-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (v1.isInt32() &amp;&amp; v2.isInt32())
          return v1.asInt32() &lt; v2.asInt32();
  
      if (v1.isNumber() &amp;&amp; v2.isNumber())
          return v1.asNumber() &lt; v2.asNumber();
  
      if (isJSString(v1) &amp;&amp; isJSString(v2)) {
<span class="line-modified">!         String s1 = asString(v1)-&gt;value(callFrame);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         String s2 = asString(v2)-&gt;value(callFrame);</span>
          RETURN_IF_EXCEPTION(scope, false);
          return codePointCompareLessThan(s1, s2);
      }
  
      double n1;
<span class="line-new-header">--- 246,98 ---</span>
  
      ASSERT(comparisonMode == JSBigInt::ComparisonMode::LessThanOrEqual);
      return comparisonResult == JSBigInt::ComparisonResult::LessThan || comparisonResult == JSBigInt::ComparisonResult::Equal;
  }
  
<span class="line-modified">! ALWAYS_INLINE bool bigIntCompare(JSGlobalObject* globalObject, JSValue v1, JSValue v2, JSBigInt::ComparisonMode comparisonMode)</span>
  {
      ASSERT(v1.isBigInt() || v2.isBigInt());
      ASSERT(v1.isPrimitive() &amp;&amp; v2.isPrimitive());
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (v1.isBigInt() &amp;&amp; v2.isBigInt())
          return bigIntCompareResult(JSBigInt::compare(asBigInt(v1), asBigInt(v2)), comparisonMode);
  
      if (v1.isBigInt()) {
          JSValue primValue = v2;
          if (primValue.isString()) {
<span class="line-modified">!             JSBigInt* bigIntValue = JSBigInt::stringToBigInt(globalObject, asString(primValue)-&gt;value(globalObject));</span>
              RETURN_IF_EXCEPTION(scope, false);
              if (!bigIntValue)
                  return false;
  
              return bigIntCompareResult(JSBigInt::compare(asBigInt(v1), bigIntValue), comparisonMode);
          }
  
          if (primValue.isBigInt())
              return bigIntCompareResult(JSBigInt::compare(asBigInt(v1), asBigInt(primValue)), comparisonMode);
  
<span class="line-modified">!         double numberValue = primValue.toNumber(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, false);
          return bigIntCompareResult(JSBigInt::compareToDouble(asBigInt(v1), numberValue), comparisonMode);
      }
  
      JSValue primValue = v1;
      if (primValue.isString()) {
<span class="line-modified">!         JSBigInt* bigIntValue = JSBigInt::stringToBigInt(globalObject, asString(primValue)-&gt;value(globalObject));</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (!bigIntValue)
              return false;
  
          return bigIntCompareResult(JSBigInt::compare(bigIntValue, asBigInt(v2)), comparisonMode);
      }
  
      if (primValue.isBigInt())
          return bigIntCompareResult(JSBigInt::compare(asBigInt(primValue), asBigInt(v2)), comparisonMode);
  
<span class="line-modified">!     double numberValue = primValue.toNumber(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      // Here we check inverted because BigInt is the v2
      JSBigInt::ComparisonResult comparisonResult = JSBigInt::compareToDouble(asBigInt(v2), numberValue);
      if (comparisonMode == JSBigInt::ComparisonMode::LessThan)
          return comparisonResult == JSBigInt::ComparisonResult::GreaterThan;
  
      return comparisonResult == JSBigInt::ComparisonResult::GreaterThan || comparisonResult == JSBigInt::ComparisonResult::Equal;
  }
  
<span class="line-modified">! ALWAYS_INLINE bool toPrimitiveNumeric(JSGlobalObject* globalObject, JSValue v, JSValue&amp; p, double&amp; n)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     p = v.toPrimitive(globalObject, PreferNumber);</span>
      RETURN_IF_EXCEPTION(scope, false);
      if (p.isBigInt())
          return true;
  
<span class="line-modified">!     n = p.toNumber(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
      return !p.isString();
  }
  
  // See ES5 11.8.1/11.8.2/11.8.5 for definition of leftFirst, this value ensures correct
  // evaluation ordering for argument conversions for &#39;&lt;&#39; and &#39;&gt;&#39;. For &#39;&lt;&#39; pass the value
  // true, for leftFirst, for &#39;&gt;&#39; pass the value false (and reverse operand order).
  template&lt;bool leftFirst&gt;
<span class="line-modified">! ALWAYS_INLINE bool jsLess(JSGlobalObject* globalObject, JSValue v1, JSValue v2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (v1.isInt32() &amp;&amp; v2.isInt32())
          return v1.asInt32() &lt; v2.asInt32();
  
      if (v1.isNumber() &amp;&amp; v2.isNumber())
          return v1.asNumber() &lt; v2.asNumber();
  
      if (isJSString(v1) &amp;&amp; isJSString(v2)) {
<span class="line-modified">!         String s1 = asString(v1)-&gt;value(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         String s2 = asString(v2)-&gt;value(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, false);
          return codePointCompareLessThan(s1, s2);
      }
  
      double n1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 365,49 ***</span>
      JSValue p1;
      JSValue p2;
      bool wasNotString1;
      bool wasNotString2;
      if (leftFirst) {
<span class="line-modified">!         wasNotString1 = toPrimitiveNumeric(callFrame, v1, p1, n1);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         wasNotString2 = toPrimitiveNumeric(callFrame, v2, p2, n2);</span>
      } else {
<span class="line-modified">!         wasNotString2 = toPrimitiveNumeric(callFrame, v2, p2, n2);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         wasNotString1 = toPrimitiveNumeric(callFrame, v1, p1, n1);</span>
      }
      RETURN_IF_EXCEPTION(scope, false);
  
      if (wasNotString1 | wasNotString2) {
          if (p1.isBigInt() || p2.isBigInt())
<span class="line-modified">!             RELEASE_AND_RETURN(scope, bigIntCompare(callFrame, p1, p2, JSBigInt::ComparisonMode::LessThan));</span>
  
          return n1 &lt; n2;
      }
  
<span class="line-modified">!     return codePointCompareLessThan(asString(p1)-&gt;value(callFrame), asString(p2)-&gt;value(callFrame));</span>
  }
  
  // See ES5 11.8.3/11.8.4/11.8.5 for definition of leftFirst, this value ensures correct
  // evaluation ordering for argument conversions for &#39;&lt;=&#39; and &#39;=&gt;&#39;. For &#39;&lt;=&#39; pass the
  // value true, for leftFirst, for &#39;=&gt;&#39; pass the value false (and reverse operand order).
  template&lt;bool leftFirst&gt;
<span class="line-modified">! ALWAYS_INLINE bool jsLessEq(CallFrame* callFrame, JSValue v1, JSValue v2)</span>
  {
<span class="line-modified">!     VM&amp; vm = callFrame-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (v1.isInt32() &amp;&amp; v2.isInt32())
          return v1.asInt32() &lt;= v2.asInt32();
  
      if (v1.isNumber() &amp;&amp; v2.isNumber())
          return v1.asNumber() &lt;= v2.asNumber();
  
      if (isJSString(v1) &amp;&amp; isJSString(v2)) {
<span class="line-modified">!         String s1 = asString(v1)-&gt;value(callFrame);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         String s2 = asString(v2)-&gt;value(callFrame);</span>
          RETURN_IF_EXCEPTION(scope, false);
          return !codePointCompareLessThan(s2, s1);
      }
  
      double n1;
<span class="line-new-header">--- 345,49 ---</span>
      JSValue p1;
      JSValue p2;
      bool wasNotString1;
      bool wasNotString2;
      if (leftFirst) {
<span class="line-modified">!         wasNotString1 = toPrimitiveNumeric(globalObject, v1, p1, n1);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         wasNotString2 = toPrimitiveNumeric(globalObject, v2, p2, n2);</span>
      } else {
<span class="line-modified">!         wasNotString2 = toPrimitiveNumeric(globalObject, v2, p2, n2);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         wasNotString1 = toPrimitiveNumeric(globalObject, v1, p1, n1);</span>
      }
      RETURN_IF_EXCEPTION(scope, false);
  
      if (wasNotString1 | wasNotString2) {
          if (p1.isBigInt() || p2.isBigInt())
<span class="line-modified">!             RELEASE_AND_RETURN(scope, bigIntCompare(globalObject, p1, p2, JSBigInt::ComparisonMode::LessThan));</span>
  
          return n1 &lt; n2;
      }
  
<span class="line-modified">!     return codePointCompareLessThan(asString(p1)-&gt;value(globalObject), asString(p2)-&gt;value(globalObject));</span>
  }
  
  // See ES5 11.8.3/11.8.4/11.8.5 for definition of leftFirst, this value ensures correct
  // evaluation ordering for argument conversions for &#39;&lt;=&#39; and &#39;=&gt;&#39;. For &#39;&lt;=&#39; pass the
  // value true, for leftFirst, for &#39;=&gt;&#39; pass the value false (and reverse operand order).
  template&lt;bool leftFirst&gt;
<span class="line-modified">! ALWAYS_INLINE bool jsLessEq(JSGlobalObject* globalObject, JSValue v1, JSValue v2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (v1.isInt32() &amp;&amp; v2.isInt32())
          return v1.asInt32() &lt;= v2.asInt32();
  
      if (v1.isNumber() &amp;&amp; v2.isNumber())
          return v1.asNumber() &lt;= v2.asNumber();
  
      if (isJSString(v1) &amp;&amp; isJSString(v2)) {
<span class="line-modified">!         String s1 = asString(v1)-&gt;value(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         String s2 = asString(v2)-&gt;value(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, false);
          return !codePointCompareLessThan(s2, s1);
      }
  
      double n1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 415,27 ***</span>
      JSValue p1;
      JSValue p2;
      bool wasNotString1;
      bool wasNotString2;
      if (leftFirst) {
<span class="line-modified">!         wasNotString1 = toPrimitiveNumeric(callFrame, v1, p1, n1);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         wasNotString2 = toPrimitiveNumeric(callFrame, v2, p2, n2);</span>
      } else {
<span class="line-modified">!         wasNotString2 = toPrimitiveNumeric(callFrame, v2, p2, n2);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         wasNotString1 = toPrimitiveNumeric(callFrame, v1, p1, n1);</span>
      }
      RETURN_IF_EXCEPTION(scope, false);
  
      if (wasNotString1 | wasNotString2) {
          if (p1.isBigInt() || p2.isBigInt())
<span class="line-modified">!             RELEASE_AND_RETURN(scope, bigIntCompare(callFrame, p1, p2, JSBigInt::ComparisonMode::LessThanOrEqual));</span>
  
          return n1 &lt;= n2;
      }
<span class="line-modified">!     return !codePointCompareLessThan(asString(p2)-&gt;value(callFrame), asString(p1)-&gt;value(callFrame));</span>
  }
  
  // Fast-path choices here are based on frequency data from SunSpider:
  //    &lt;times&gt; Add case: &lt;t1&gt; &lt;t2&gt;
  //    ---------------------------
<span class="line-new-header">--- 395,27 ---</span>
      JSValue p1;
      JSValue p2;
      bool wasNotString1;
      bool wasNotString2;
      if (leftFirst) {
<span class="line-modified">!         wasNotString1 = toPrimitiveNumeric(globalObject, v1, p1, n1);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         wasNotString2 = toPrimitiveNumeric(globalObject, v2, p2, n2);</span>
      } else {
<span class="line-modified">!         wasNotString2 = toPrimitiveNumeric(globalObject, v2, p2, n2);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         wasNotString1 = toPrimitiveNumeric(globalObject, v1, p1, n1);</span>
      }
      RETURN_IF_EXCEPTION(scope, false);
  
      if (wasNotString1 | wasNotString2) {
          if (p1.isBigInt() || p2.isBigInt())
<span class="line-modified">!             RELEASE_AND_RETURN(scope, bigIntCompare(globalObject, p1, p2, JSBigInt::ComparisonMode::LessThanOrEqual));</span>
  
          return n1 &lt;= n2;
      }
<span class="line-modified">!     return !codePointCompareLessThan(asString(p2)-&gt;value(globalObject), asString(p1)-&gt;value(globalObject));</span>
  }
  
  // Fast-path choices here are based on frequency data from SunSpider:
  //    &lt;times&gt; Add case: &lt;t1&gt; &lt;t2&gt;
  //    ---------------------------
</pre>
<hr />
<pre>
<span class="line-old-header">*** 444,86 ***</span>
  //    20900   Add case: 5 6
  //    13962   Add case: 5 3
  //    4000    Add case: 3 5
  
  
<span class="line-modified">! ALWAYS_INLINE JSValue jsAddNonNumber(CallFrame* callFrame, JSValue v1, JSValue v2)</span>
  {
<span class="line-modified">!     VM&amp; vm = callFrame-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      ASSERT(!v1.isNumber() || !v2.isNumber());
  
      if (LIKELY(v1.isString() &amp;&amp; !v2.isObject())) {
          if (v2.isString())
<span class="line-modified">!             RELEASE_AND_RETURN(scope, jsString(callFrame, asString(v1), asString(v2)));</span>
<span class="line-modified">!         String s2 = v2.toWTFString(callFrame);</span>
          RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!         RELEASE_AND_RETURN(scope, jsString(callFrame, asString(v1), s2));</span>
      }
  
      // All other cases are pretty uncommon
<span class="line-modified">!     RELEASE_AND_RETURN(scope, jsAddSlowCase(callFrame, v1, v2));</span>
  }
  
<span class="line-modified">! ALWAYS_INLINE JSValue jsAdd(CallFrame* callFrame, JSValue v1, JSValue v2)</span>
  {
      if (v1.isNumber() &amp;&amp; v2.isNumber())
          return jsNumber(v1.asNumber() + v2.asNumber());
  
<span class="line-modified">!     return jsAddNonNumber(callFrame, v1, v2);</span>
  }
  
<span class="line-modified">! ALWAYS_INLINE JSValue jsSub(ExecState* exec, JSValue v1, JSValue v2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto leftNumeric = v1.toNumeric(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!     auto rightNumeric = v2.toNumeric(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
              scope.release();
<span class="line-modified">!             return JSBigInt::sub(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
          }
  
<span class="line-modified">!         return throwTypeError(exec, scope, &quot;Invalid mix of BigInt and other type in subtraction.&quot;_s);</span>
      }
  
      return jsNumber(WTF::get&lt;double&gt;(leftNumeric) - WTF::get&lt;double&gt;(rightNumeric));
  }
  
<span class="line-modified">! ALWAYS_INLINE JSValue jsMul(ExecState* state, JSValue v1, JSValue v2)</span>
  {
<span class="line-modified">!     VM&amp; vm = state-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Variant&lt;JSBigInt*, double&gt; leftNumeric = v1.toNumeric(state);</span>
      RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!     Variant&lt;JSBigInt*, double&gt; rightNumeric = v2.toNumeric(state);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
              scope.release();
<span class="line-modified">!             return JSBigInt::multiply(state, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
          }
  
<span class="line-modified">!         throwTypeError(state, scope, &quot;Invalid mix of BigInt and other type in multiplication.&quot;_s);</span>
          return { };
      }
  
      double leftValue =  WTF::get&lt;double&gt;(leftNumeric);
      double rightValue =  WTF::get&lt;double&gt;(rightNumeric);
      return jsNumber(leftValue * rightValue);
  }
  
  inline bool scribbleFreeCells()
  {
<span class="line-modified">!     return !ASSERT_DISABLED || Options::scribbleFreeCells();</span>
  }
  
  #define SCRIBBLE_WORD static_cast&lt;intptr_t&gt;(0xbadbeef0)
  
  inline bool isScribbledValue(JSValue value)
<span class="line-new-header">--- 424,86 ---</span>
  //    20900   Add case: 5 6
  //    13962   Add case: 5 3
  //    4000    Add case: 3 5
  
  
<span class="line-modified">! ALWAYS_INLINE JSValue jsAddNonNumber(JSGlobalObject* globalObject, JSValue v1, JSValue v2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      ASSERT(!v1.isNumber() || !v2.isNumber());
  
      if (LIKELY(v1.isString() &amp;&amp; !v2.isObject())) {
          if (v2.isString())
<span class="line-modified">!             RELEASE_AND_RETURN(scope, jsString(globalObject, asString(v1), asString(v2)));</span>
<span class="line-modified">!         String s2 = v2.toWTFString(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!         RELEASE_AND_RETURN(scope, jsString(globalObject, asString(v1), s2));</span>
      }
  
      // All other cases are pretty uncommon
<span class="line-modified">!     RELEASE_AND_RETURN(scope, jsAddSlowCase(globalObject, v1, v2));</span>
  }
  
<span class="line-modified">! ALWAYS_INLINE JSValue jsAdd(JSGlobalObject* globalObject, JSValue v1, JSValue v2)</span>
  {
      if (v1.isNumber() &amp;&amp; v2.isNumber())
          return jsNumber(v1.asNumber() + v2.asNumber());
  
<span class="line-modified">!     return jsAddNonNumber(globalObject, v1, v2);</span>
  }
  
<span class="line-modified">! ALWAYS_INLINE JSValue jsSub(JSGlobalObject* globalObject, JSValue v1, JSValue v2)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto leftNumeric = v1.toNumeric(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!     auto rightNumeric = v2.toNumeric(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
              scope.release();
<span class="line-modified">!             return JSBigInt::sub(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
          }
  
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;Invalid mix of BigInt and other type in subtraction.&quot;_s);</span>
      }
  
      return jsNumber(WTF::get&lt;double&gt;(leftNumeric) - WTF::get&lt;double&gt;(rightNumeric));
  }
  
<span class="line-modified">! ALWAYS_INLINE JSValue jsMul(JSGlobalObject* globalObject, JSValue v1, JSValue v2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Variant&lt;JSBigInt*, double&gt; leftNumeric = v1.toNumeric(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!     Variant&lt;JSBigInt*, double&gt; rightNumeric = v2.toNumeric(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
              scope.release();
<span class="line-modified">!             return JSBigInt::multiply(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
          }
  
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;Invalid mix of BigInt and other type in multiplication.&quot;_s);</span>
          return { };
      }
  
      double leftValue =  WTF::get&lt;double&gt;(leftNumeric);
      double rightValue =  WTF::get&lt;double&gt;(rightNumeric);
      return jsNumber(leftValue * rightValue);
  }
  
  inline bool scribbleFreeCells()
  {
<span class="line-modified">!     return ASSERT_ENABLED || Options::scribbleFreeCells();</span>
  }
  
  #define SCRIBBLE_WORD static_cast&lt;intptr_t&gt;(0xbadbeef0)
  
  inline bool isScribbledValue(JSValue value)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 537,6 ***</span>
<span class="line-new-header">--- 517,20 ---</span>
          // Use a 16-byte aligned value to ensure that it passes the cell check.
          static_cast&lt;EncodedJSValue*&gt;(base)[i] = JSValue::encode(bitwise_cast&lt;JSCell*&gt;(SCRIBBLE_WORD));
      }
  }
  
<span class="line-added">+ ALWAYS_INLINE EncodedJSValue getByValWithIndex(JSGlobalObject* globalObject, JSCell* base, uint32_t index)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (base-&gt;isObject()) {</span>
<span class="line-added">+         JSObject* object = asObject(base);</span>
<span class="line-added">+         if (object-&gt;canGetIndexQuickly(index))</span>
<span class="line-added">+             return JSValue::encode(object-&gt;getIndexQuickly(index));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (isJSString(base) &amp;&amp; asString(base)-&gt;canGetIndex(index))</span>
<span class="line-added">+         return JSValue::encode(asString(base)-&gt;getIndex(globalObject, index));</span>
<span class="line-added">+ </span>
<span class="line-added">+     return JSValue::encode(JSValue(base).get(globalObject, index));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  } // namespace JSC
</pre>
<center><a href="Operations.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Options.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
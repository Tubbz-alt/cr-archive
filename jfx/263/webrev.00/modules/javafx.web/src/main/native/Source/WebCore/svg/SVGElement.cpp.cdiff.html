<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/svg/SVGElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGDocumentExtensions.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGElement.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/SVGElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 49,10 ***</span>
<span class="line-new-header">--- 49,11 ---</span>
  #include &quot;SVGRenderSupport.h&quot;
  #include &quot;SVGSVGElement.h&quot;
  #include &quot;SVGTitleElement.h&quot;
  #include &quot;SVGUseElement.h&quot;
  #include &quot;ShadowRoot.h&quot;
<span class="line-added">+ #include &quot;StyleAdjuster.h&quot;</span>
  #include &quot;XMLNames.h&quot;
  #include &lt;wtf/Assertions.h&gt;
  #include &lt;wtf/HashMap.h&gt;
  #include &lt;wtf/IsoMallocInlines.h&gt;
  #include &lt;wtf/NeverDestroyed.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,11 ***</span>
      return map;
  }
  
  SVGElement::SVGElement(const QualifiedName&amp; tagName, Document&amp; document)
      : StyledElement(tagName, document, CreateSVGElement)
<span class="line-removed">-     , SVGLangSpace(this)</span>
      , m_propertyAnimatorFactory(makeUnique&lt;SVGPropertyAnimatorFactory&gt;())
  {
      static std::once_flag onceFlag;
      std::call_once(onceFlag, [] {
          PropertyRegistry::registerProperty&lt;HTMLNames::classAttr, &amp;SVGElement::m_className&gt;();
<span class="line-new-header">--- 159,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 352,12 ***</span>
      auto&amp; eventName = HTMLElement::eventNameForEventHandlerAttribute(name);
      if (!eventName.isNull()) {
          setAttributeEventListener(eventName, name, value);
          return;
      }
<span class="line-removed">- </span>
<span class="line-removed">-     SVGLangSpace::parseAttribute(name, value);</span>
  }
  
  bool SVGElement::haveLoadedRequiredResources()
  {
      for (auto&amp; child : childrenOfType&lt;SVGElement&gt;(*this)) {
<span class="line-new-header">--- 352,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 438,68 ***</span>
      }
  
      return false;
  }
  
<span class="line-modified">! void SVGElement::sendSVGLoadEventIfPossible(bool sendParentLoadEvents)</span>
  {
      if (!isConnected() || !document().frame())
          return;
  
<span class="line-modified">!     RefPtr&lt;SVGElement&gt; currentTarget = this;</span>
<span class="line-modified">!     while (currentTarget &amp;&amp; currentTarget-&gt;haveLoadedRequiredResources()) {</span>
<span class="line-removed">-         RefPtr&lt;Element&gt; parent;</span>
<span class="line-removed">-         if (sendParentLoadEvents)</span>
<span class="line-removed">-             parent = currentTarget-&gt;parentOrShadowHostElement(); // save the next parent to dispatch too incase dispatching the event changes the tree</span>
<span class="line-removed">-         if (hasLoadListener(currentTarget.get()))</span>
<span class="line-removed">-             currentTarget-&gt;dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
<span class="line-removed">-         currentTarget = (parent &amp;&amp; parent-&gt;isSVGElement()) ? static_pointer_cast&lt;SVGElement&gt;(parent) : RefPtr&lt;SVGElement&gt;();</span>
<span class="line-removed">-         SVGElement* element = currentTarget.get();</span>
<span class="line-removed">-         if (!element || !element-&gt;isOutermostSVGSVGElement())</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Consider &lt;svg onload=&quot;foo()&quot;&gt;&lt;image xlink:href=&quot;foo.png&quot; externalResourcesRequired=&quot;true&quot;/&gt;&lt;/svg&gt;.</span>
<span class="line-removed">-         // If foo.png is not yet loaded, the first SVGLoad event will go to the &lt;svg&gt; element, sent through</span>
<span class="line-removed">-         // Document::implicitClose(). Then the SVGLoad event will fire for &lt;image&gt;, once its loaded.</span>
<span class="line-removed">-         ASSERT(sendParentLoadEvents);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // If the load event was not sent yet by Document::implicitClose(), but the &lt;image&gt; from the example</span>
<span class="line-removed">-         // above, just appeared, don&#39;t send the SVGLoad event to the outermost &lt;svg&gt;, but wait for the document</span>
<span class="line-removed">-         // to be &quot;ready to render&quot;, first.</span>
<span class="line-removed">-         if (!document().loadEventFinished())</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void SVGElement::sendSVGLoadEventIfPossibleAsynchronously()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     svgLoadEventTimer()-&gt;startOneShot(0_s);</span>
  }
  
<span class="line-modified">! void SVGElement::svgLoadEventTimerFired()</span>
  {
<span class="line-modified">!     sendSVGLoadEventIfPossible();</span>
  }
  
<span class="line-modified">! Timer* SVGElement::svgLoadEventTimer()</span>
  {
      ASSERT_NOT_REACHED();
      return nullptr;
  }
  
  void SVGElement::finishParsingChildren()
  {
      StyledElement::finishParsingChildren();
  
<span class="line-removed">-     // The outermost SVGSVGElement SVGLoad event is fired through Document::dispatchWindowLoadEvent.</span>
      if (isOutermostSVGSVGElement())
          return;
  
<span class="line-removed">-     // finishParsingChildren() is called when the close tag is reached for an element (e.g. &lt;/svg&gt;)</span>
<span class="line-removed">-     // we send SVGLoad events here if we can, otherwise they&#39;ll be sent when any required loads finish</span>
<span class="line-removed">-     sendSVGLoadEventIfPossible();</span>
<span class="line-removed">- </span>
      // Notify all the elements which have references to this element to rebuild their shadow and render
      // trees, e.g. a &lt;use&gt; element references a target element before this target element is defined.
      invalidateInstances();
  }
  
<span class="line-new-header">--- 436,39 ---</span>
      }
  
      return false;
  }
  
<span class="line-modified">! void SVGElement::sendLoadEventIfPossible()</span>
  {
      if (!isConnected() || !document().frame())
          return;
  
<span class="line-modified">!     if (!haveLoadedRequiredResources() || !hasLoadListener(this))</span>
<span class="line-modified">!         return;</span>
  
<span class="line-modified">!     dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
  }
  
<span class="line-modified">! void SVGElement::loadEventTimerFired()</span>
  {
<span class="line-modified">!     sendLoadEventIfPossible();</span>
  }
  
<span class="line-modified">! Timer* SVGElement::loadEventTimer()</span>
  {
      ASSERT_NOT_REACHED();
      return nullptr;
  }
  
  void SVGElement::finishParsingChildren()
  {
      StyledElement::finishParsingChildren();
  
      if (isOutermostSVGSVGElement())
          return;
  
      // Notify all the elements which have references to this element to rebuild their shadow and render
      // trees, e.g. a &lt;use&gt; element references a target element before this target element is defined.
      invalidateInstances();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 579,11 ***</span>
      ASSERT(attributeName != nullQName());
  
      // A change in a style property, e.g SVGRectElement::x should be serialized to
      // the attribute immediately. Otherwise it is okay to be lazy in this regard.
      if (!propertyRegistry().isAnimatedStylePropertyAttribute(attributeName))
<span class="line-modified">!         animatedProperty.setDirty();</span>
      else
          setSynchronizedLazyAttribute(attributeName, animatedProperty.baseValAsString());
  
      invalidateSVGAttributes();
      svgAttributeChanged(attributeName);
<span class="line-new-header">--- 548,11 ---</span>
      ASSERT(attributeName != nullQName());
  
      // A change in a style property, e.g SVGRectElement::x should be serialized to
      // the attribute immediately. Otherwise it is okay to be lazy in this regard.
      if (!propertyRegistry().isAnimatedStylePropertyAttribute(attributeName))
<span class="line-modified">!         propertyRegistry().setAnimatedPropertDirty(attributeName, animatedProperty);</span>
      else
          setSynchronizedLazyAttribute(attributeName, animatedProperty.baseValAsString());
  
      invalidateSVGAttributes();
      svgAttributeChanged(attributeName);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 622,16 ***</span>
  void SVGElement::animatorWillBeDeleted(const QualifiedName&amp; attributeName)
  {
      propertyAnimatorFactory().animatorWillBeDeleted(attributeName);
  }
  
<span class="line-modified">! Optional&lt;ElementStyle&gt; SVGElement::resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle*)</span>
  {
      // If the element is in a &lt;use&gt; tree we get the style from the definition tree.
      if (auto styleElement = makeRefPtr(this-&gt;correspondingElement())) {
<span class="line-modified">!         Optional&lt;ElementStyle&gt; style = styleElement-&gt;resolveStyle(&amp;parentStyle);</span>
<span class="line-modified">!         StyleResolver::adjustSVGElementStyle(*this, *style-&gt;renderStyle);</span>
          return style;
      }
  
      return resolveStyle(&amp;parentStyle);
  }
<span class="line-new-header">--- 591,16 ---</span>
  void SVGElement::animatorWillBeDeleted(const QualifiedName&amp; attributeName)
  {
      propertyAnimatorFactory().animatorWillBeDeleted(attributeName);
  }
  
<span class="line-modified">! Optional&lt;Style::ElementStyle&gt; SVGElement::resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle*)</span>
  {
      // If the element is in a &lt;use&gt; tree we get the style from the definition tree.
      if (auto styleElement = makeRefPtr(this-&gt;correspondingElement())) {
<span class="line-modified">!         auto style = styleElement-&gt;resolveStyle(&amp;parentStyle);</span>
<span class="line-modified">!         Style::Adjuster::adjustSVGElementStyle(*style.renderStyle, *this);</span>
          return style;
      }
  
      return resolveStyle(&amp;parentStyle);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 861,12 ***</span>
          if (isConnected())
              buildPendingResourcesIfNeeded();
          invalidateInstances();
          return;
      }
<span class="line-removed">- </span>
<span class="line-removed">-     SVGLangSpace::svgAttributeChanged(attrName);</span>
  }
  
  Node::InsertedIntoAncestorResult SVGElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
  {
      StyledElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
<span class="line-new-header">--- 830,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 905,29 ***</span>
      if (change.source == ChildChangeSource::Parser)
          return;
      invalidateInstances();
  }
  
<span class="line-removed">- RefPtr&lt;DeprecatedCSSOMValue&gt; SVGElement::getPresentationAttribute(const String&amp; name)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!hasAttributesWithoutUpdate())</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     QualifiedName attributeName(nullAtom(), name, nullAtom());</span>
<span class="line-removed">-     const Attribute* attribute = findAttributeByName(attributeName);</span>
<span class="line-removed">-     if (!attribute)</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto style = MutableStyleProperties::create(SVGAttributeMode);</span>
<span class="line-removed">-     CSSPropertyID propertyID = cssPropertyIdForSVGAttributeName(attribute-&gt;name());</span>
<span class="line-removed">-     style-&gt;setProperty(propertyID, attribute-&gt;value());</span>
<span class="line-removed">-     auto cssValue = style-&gt;getPropertyCSSValue(propertyID);</span>
<span class="line-removed">-     if (!cssValue)</span>
<span class="line-removed">-         return nullptr;</span>
<span class="line-removed">-     return cssValue-&gt;createDeprecatedCSSOMWrapper(style-&gt;ensureCSSStyleDeclaration());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool SVGElement::instanceUpdatesBlocked() const
  {
      return m_svgRareData &amp;&amp; m_svgRareData-&gt;instanceUpdatesBlocked();
  }
  
<span class="line-new-header">--- 872,10 ---</span>
</pre>
<center><a href="SVGDocumentExtensions.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGElement.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
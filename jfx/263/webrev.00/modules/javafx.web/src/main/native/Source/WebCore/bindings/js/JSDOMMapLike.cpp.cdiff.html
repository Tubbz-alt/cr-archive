<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMMapLike.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMIterator.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMMapLike.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMMapLike.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,72 ***</span>
  #include &quot;config.h&quot;
  #include &quot;JSDOMMapLike.h&quot;
  
  #include &quot;WebCoreJSClientData.h&quot;
  #include &lt;JavaScriptCore/CatchScope.h&gt;
  
  namespace WebCore {
  
<span class="line-modified">! static inline JSC::JSObject&amp; getBackingMap(JSC::ExecState&amp; state, JSC::JSObject&amp; mapLike)</span>
  {
<span class="line-modified">!     auto&amp; vm = state.vm();</span>
<span class="line-modified">!     auto backingMap = mapLike.get(&amp;state, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().backingMapPrivateName());</span>
<span class="line-modified">!     return *JSC::asObject(backingMap);</span>
  }
  
<span class="line-modified">! void initializeBackingMap(JSC::VM&amp; vm, JSC::JSObject&amp; mapLike, JSC::JSMap&amp; backingMap)</span>
  {
<span class="line-modified">!     mapLike.putDirect(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().backingMapPrivateName(), &amp;backingMap, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));</span>
  }
  
<span class="line-modified">! JSC::JSMap&amp; createBackingMap(JSC::ExecState&amp; state, JSC::JSGlobalObject&amp; globalObject, JSC::JSObject&amp; mapLike)</span>
  {
<span class="line-modified">!     auto&amp; vm = state.vm();</span>
<span class="line-modified">!     auto scope = DECLARE_CATCH_SCOPE(vm);</span>
  
<span class="line-modified">!     ASSERT(mapLike.get(&amp;state, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().backingMapPrivateName()).isUndefined());</span>
<span class="line-modified">!     auto backingMap = JSC::JSMap::create(&amp;state, vm, globalObject.mapStructure());</span>
<span class="line-modified">!     scope.releaseAssertNoException();</span>
<span class="line-modified">!     mapLike.putDirect(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().backingMapPrivateName(), backingMap, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     return *backingMap;</span>
  }
  
<span class="line-modified">! JSC::JSValue forwardAttributeGetterToBackingMap(JSC::ExecState&amp; state, JSC::JSObject&amp; mapLike, const JSC::Identifier&amp; attributeName)</span>
  {
<span class="line-modified">!     return getBackingMap(state, mapLike).get(&amp;state, attributeName);</span>
  }
  
<span class="line-modified">! JSC::JSValue forwardFunctionCallToBackingMap(JSC::ExecState&amp; state, JSC::JSObject&amp; mapLike, const JSC::Identifier&amp; functionName)</span>
  {
<span class="line-modified">!     auto&amp; backingMap = getBackingMap(state, mapLike);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JSC::JSValue function = backingMap.get(&amp;state, functionName);</span>
<span class="line-removed">-     ASSERT(function);</span>
  
      JSC::CallData callData;
<span class="line-modified">!     JSC::CallType callType = JSC::getCallData(state.vm(), function, callData);</span>
<span class="line-modified">!     ASSERT(callType != JSC::CallType::None);</span>
      JSC::MarkedArgumentBuffer arguments;
<span class="line-modified">!     for (size_t cptr = 0; cptr &lt; state.argumentCount(); ++cptr)</span>
<span class="line-modified">!         arguments.append(state.uncheckedArgument(cptr));</span>
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     return JSC::call(&amp;state, function, callType, callData, &amp;backingMap, arguments);</span>
  }
  
<span class="line-modified">! JSC::JSValue forwardForEachCallToBackingMap(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, JSC::JSObject&amp; mapLike)</span>
  {
<span class="line-modified">!     auto* function = globalObject.builtinInternalFunctions().jsDOMBindingInternals().m_mapLikeForEachFunction.get();</span>
<span class="line-modified">!     ASSERT(function);</span>
  
<span class="line-modified">!     getBackingMap(state, mapLike);</span>
  
      JSC::CallData callData;
<span class="line-modified">!     JSC::CallType callType = JSC::getCallData(state.vm(), function, callData);</span>
      ASSERT(callType != JSC::CallType::None);
      JSC::MarkedArgumentBuffer arguments;
<span class="line-modified">!     for (size_t cptr = 0; cptr &lt; state.argumentCount(); ++cptr)</span>
<span class="line-modified">!         arguments.append(state.uncheckedArgument(cptr));</span>
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     return JSC::call(&amp;state, function, callType, callData, &amp;mapLike, arguments);</span>
  }
  
  }
<span class="line-new-header">--- 26,102 ---</span>
  #include &quot;config.h&quot;
  #include &quot;JSDOMMapLike.h&quot;
  
  #include &quot;WebCoreJSClientData.h&quot;
  #include &lt;JavaScriptCore/CatchScope.h&gt;
<span class="line-added">+ #include &lt;JavaScriptCore/JSMap.h&gt;</span>
  
  namespace WebCore {
  
<span class="line-modified">! std::pair&lt;bool, std::reference_wrapper&lt;JSC::JSObject&gt;&gt; getBackingMap(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; mapLike)</span>
  {
<span class="line-modified">!     auto&amp; vm = lexicalGlobalObject.vm();</span>
<span class="line-modified">!     auto backingMap = mapLike.get(&amp;lexicalGlobalObject, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().backingMapPrivateName());</span>
<span class="line-modified">!     if (!backingMap.isUndefined())</span>
<span class="line-added">+         return { false, *JSC::asObject(backingMap) };</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto scope = DECLARE_CATCH_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     backingMap = JSC::JSMap::create(&amp;lexicalGlobalObject, vm, lexicalGlobalObject.mapStructure());</span>
<span class="line-added">+     scope.releaseAssertNoException();</span>
<span class="line-added">+ </span>
<span class="line-added">+     mapLike.putDirect(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().backingMapPrivateName(), backingMap, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));</span>
<span class="line-added">+     return { true, *JSC::asObject(backingMap) };</span>
  }
  
<span class="line-modified">! void clearBackingMap(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; backingMap)</span>
  {
<span class="line-modified">!     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
<span class="line-added">+     auto function = backingMap.get(&amp;lexicalGlobalObject, vm.propertyNames-&gt;clear);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSC::CallData callData;</span>
<span class="line-added">+     auto callType = JSC::getCallData(vm, function, callData);</span>
<span class="line-added">+     if (callType == JSC::CallType::None)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSC::MarkedArgumentBuffer arguments;</span>
<span class="line-added">+     JSC::call(&amp;lexicalGlobalObject, function, callType, callData, &amp;backingMap, arguments);</span>
  }
  
<span class="line-modified">! void setToBackingMap(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; backingMap, JSC::JSValue key, JSC::JSValue value)</span>
  {
<span class="line-modified">!     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
<span class="line-modified">!     auto function = backingMap.get(&amp;lexicalGlobalObject, vm.propertyNames-&gt;set);</span>
  
<span class="line-modified">!     JSC::CallData callData;</span>
<span class="line-modified">!     auto callType = JSC::getCallData(vm, function, callData);</span>
<span class="line-modified">!     if (callType == JSC::CallType::None)</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">! </span>
<span class="line-added">+     JSC::MarkedArgumentBuffer arguments;</span>
<span class="line-added">+     arguments.append(key);</span>
<span class="line-added">+     arguments.append(value);</span>
<span class="line-added">+     JSC::call(&amp;lexicalGlobalObject, function, callType, callData, &amp;backingMap, arguments);</span>
  }
  
<span class="line-modified">! JSC::JSValue forwardAttributeGetterToBackingMap(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; backingMap, const JSC::Identifier&amp; attributeName)</span>
  {
<span class="line-modified">!     return backingMap.get(&amp;lexicalGlobalObject, attributeName);</span>
  }
  
<span class="line-modified">! JSC::JSValue forwardFunctionCallToBackingMap(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, JSC::JSObject&amp; backingMap, const JSC::Identifier&amp; functionName)</span>
  {
<span class="line-modified">!     auto function = backingMap.get(&amp;lexicalGlobalObject, functionName);</span>
  
      JSC::CallData callData;
<span class="line-modified">!     auto callType = JSC::getCallData(lexicalGlobalObject.vm(), function, callData);</span>
<span class="line-modified">!     if (callType == JSC::CallType::None)</span>
<span class="line-added">+         return JSC::jsUndefined();</span>
<span class="line-added">+ </span>
      JSC::MarkedArgumentBuffer arguments;
<span class="line-modified">!     for (size_t cptr = 0; cptr &lt; callFrame.argumentCount(); ++cptr)</span>
<span class="line-modified">!         arguments.append(callFrame.uncheckedArgument(cptr));</span>
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     return JSC::call(&amp;lexicalGlobalObject, function, callType, callData, &amp;backingMap, arguments);</span>
  }
  
<span class="line-modified">! JSC::JSValue forwardForEachCallToBackingMap(JSDOMGlobalObject&amp; globalObject, JSC::CallFrame&amp; callFrame, JSC::JSObject&amp; mapLike)</span>
  {
<span class="line-modified">!     auto result = getBackingMap(globalObject, mapLike);</span>
<span class="line-modified">!     ASSERT(!result.first);</span>
  
<span class="line-modified">!     auto* function = globalObject.builtinInternalFunctions().jsDOMBindingInternals().m_forEachWrapperFunction.get();</span>
<span class="line-added">+     ASSERT(function);</span>
  
      JSC::CallData callData;
<span class="line-modified">!     auto callType = JSC::getCallData(globalObject.vm(), function, callData);</span>
      ASSERT(callType != JSC::CallType::None);
<span class="line-added">+ </span>
      JSC::MarkedArgumentBuffer arguments;
<span class="line-modified">!     arguments.append(&amp;result.second.get());</span>
<span class="line-modified">!     for (size_t cptr = 0; cptr &lt; callFrame.argumentCount(); ++cptr)</span>
<span class="line-added">+         arguments.append(callFrame.uncheckedArgument(cptr));</span>
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     return JSC::call(&amp;globalObject, function, callType, callData, &amp;mapLike, arguments);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void DOMMapAdapter::clear()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     clearBackingMap(m_lexicalGlobalObject, m_backingMap);</span>
  }
  
  }
</pre>
<center><a href="JSDOMIterator.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMMapLike.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
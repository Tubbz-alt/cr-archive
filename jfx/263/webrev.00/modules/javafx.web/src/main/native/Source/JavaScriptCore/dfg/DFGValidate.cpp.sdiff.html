<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGUseKind.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGVarargsForwardingPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 269                 case ArithMin:
 270                 case ArithMax:
 271                 case ArithPow:
 272                 case CompareLess:
 273                 case CompareLessEq:
 274                 case CompareGreater:
 275                 case CompareGreaterEq:
 276                 case CompareBelow:
 277                 case CompareBelowEq:
 278                 case CompareEq:
 279                 case CompareStrictEq:
 280                 case SameValue:
 281                 case StrCat:
 282                     VALIDATE((node), !!node-&gt;child1());
 283                     VALIDATE((node), !!node-&gt;child2());
 284                     break;
 285                 case CompareEqPtr:
 286                     VALIDATE((node), !!node-&gt;child1());
 287                     VALIDATE((node), !!node-&gt;cellOperand()-&gt;value() &amp;&amp; node-&gt;cellOperand()-&gt;value().isCell());
 288                     break;





 289                 case CheckStructureOrEmpty:
 290                     VALIDATE((node), is64Bit());
 291                     VALIDATE((node), !!node-&gt;child1());
 292                     VALIDATE((node), node-&gt;child1().useKind() == CellUse);
 293                     break;
 294                 case CheckStructure:
 295                 case StringFromCharCode:
 296                     VALIDATE((node), !!node-&gt;child1());
 297                     break;
 298                 case PutStructure:
 299                     VALIDATE((node), !node-&gt;transition()-&gt;previous-&gt;dfgShouldWatch());
 300                     break;
 301                 case MultiPutByOffset:
 302                     for (unsigned i = node-&gt;multiPutByOffsetData().variants.size(); i--;) {
 303                         const PutByIdVariant&amp; variant = node-&gt;multiPutByOffsetData().variants[i];
 304                         if (variant.kind() != PutByIdVariant::Transition)
 305                             continue;
 306                         VALIDATE((node), !variant.oldStructureForTransition()-&gt;dfgShouldWatch());
 307                     }
 308                     break;
</pre>
<hr />
<pre>
 456 
 457             for (size_t i = 0; i &lt; block-&gt;numNodes(); ++i) {
 458                 Node* node = block-&gt;node(i);
 459                 nodesInThisBlock.add(node);
 460                 if (block-&gt;isPhiIndex(i))
 461                     phisInThisBlock.add(node);
 462                 for (unsigned j = 0; j &lt; m_graph.numChildren(node); ++j) {
 463                     Edge edge = m_graph.child(node, j);
 464                     if (!edge)
 465                         continue;
 466                     VALIDATE((node, edge), m_acceptableNodes.contains(edge.node()));
 467                 }
 468             }
 469 
 470             {
 471                 HashSet&lt;Node*&gt; seenNodes;
 472                 for (size_t i = 0; i &lt; block-&gt;size(); ++i) {
 473                     Node* node = block-&gt;at(i);
 474                     m_graph.doToChildren(node, [&amp;] (const Edge&amp; edge) {
 475                         Node* child = edge.node();
<span class="line-modified"> 476                         VALIDATE((node), block-&gt;isInPhis(child) || seenNodes.contains(child));</span>
 477                     });
 478                     seenNodes.add(node);
 479                 }
 480             }
 481 
 482             for (size_t i = 0; i &lt; block-&gt;phis.size(); ++i) {
 483                 Node* node = block-&gt;phis[i];
 484                 ASSERT(phisInThisBlock.contains(node));
 485                 VALIDATE((node), node-&gt;op() == Phi);
<span class="line-modified"> 486                 VirtualRegister local = node-&gt;local();</span>
 487                 for (unsigned j = 0; j &lt; m_graph.numChildren(node); ++j) {
 488                     // Phi children in LoadStore form are invalid.
 489                     if (m_graph.m_form == LoadStore &amp;&amp; block-&gt;isPhiIndex(i))
 490                         continue;
 491 
 492                     Edge edge = m_graph.child(node, j);
 493                     if (!edge)
 494                         continue;
 495 
 496                     VALIDATE(
 497                         (node, edge),
 498                         edge-&gt;op() == SetLocal
 499                         || edge-&gt;op() == SetArgumentDefinitely
 500                         || edge-&gt;op() == SetArgumentMaybe
 501                         || edge-&gt;op() == Phi);
 502 
 503                     if (phisInThisBlock.contains(edge.node()))
 504                         continue;
 505 
 506                     if (nodesInThisBlock.contains(edge.node())) {
 507                         VALIDATE(
 508                             (node, edge),
 509                             edge-&gt;op() == SetLocal
 510                             || edge-&gt;op() == SetArgumentDefinitely
 511                             || edge-&gt;op() == SetArgumentMaybe);
 512 
 513                         continue;
 514                     }
 515 
 516                     // There must exist a predecessor block that has this node index in
 517                     // its tail variables.
 518                     bool found = false;
 519                     for (unsigned k = 0; k &lt; block-&gt;predecessors.size(); ++k) {
 520                         BasicBlock* prevBlock = block-&gt;predecessors[k];
 521                         VALIDATE((block-&gt;predecessors[k]), prevBlock);
<span class="line-modified"> 522                         Node* prevNode = prevBlock-&gt;variablesAtTail.operand(local);</span>
 523                         // If we have a Phi that is not referring to *this* block then all predecessors
 524                         // must have that local available.
<span class="line-modified"> 525                         VALIDATE((local, block, block-&gt;predecessors[k]), prevNode);</span>
 526                         switch (prevNode-&gt;op()) {
 527                         case GetLocal:
 528                         case Flush:
 529                         case PhantomLocal:
 530                             prevNode = prevNode-&gt;child1().node();
 531                             break;
 532                         default:
 533                             break;
 534                         }
 535                         if (node-&gt;shouldGenerate()) {
<span class="line-modified"> 536                             VALIDATE((local, block-&gt;predecessors[k], prevNode),</span>
 537                                      prevNode-&gt;shouldGenerate());
 538                         }
 539                         VALIDATE(
<span class="line-modified"> 540                             (local, block-&gt;predecessors[k], prevNode),</span>
 541                             prevNode-&gt;op() == SetLocal
 542                             || prevNode-&gt;op() == SetArgumentDefinitely
 543                             || prevNode-&gt;op() == SetArgumentMaybe
 544                             || prevNode-&gt;op() == Phi);
 545                         if (prevNode == edge.node()) {
 546                             found = true;
 547                             break;
 548                         }
 549                         // At this point it cannot refer into this block.
<span class="line-modified"> 550                         VALIDATE((local, block-&gt;predecessors[k], prevNode), !prevBlock-&gt;isInBlock(edge.node()));</span>
 551                     }
 552 
 553                     VALIDATE((node, edge), found);
 554                 }
 555             }
 556 
<span class="line-modified"> 557             Operands&lt;size_t&gt; getLocalPositions(</span>
<span class="line-modified"> 558                 block-&gt;variablesAtHead.numberOfArguments(),</span>
<span class="line-removed"> 559                 block-&gt;variablesAtHead.numberOfLocals());</span>
<span class="line-removed"> 560             Operands&lt;size_t&gt; setLocalPositions(</span>
<span class="line-removed"> 561                 block-&gt;variablesAtHead.numberOfArguments(),</span>
<span class="line-removed"> 562                 block-&gt;variablesAtHead.numberOfLocals());</span>
 563 
 564             for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfArguments(); ++i) {
<span class="line-modified"> 565                 VALIDATE((virtualRegisterForArgument(i), block), !block-&gt;variablesAtHead.argument(i) || block-&gt;variablesAtHead.argument(i)-&gt;accessesStack(m_graph));</span>
 566                 if (m_graph.m_form == ThreadedCPS)
<span class="line-modified"> 567                     VALIDATE((virtualRegisterForArgument(i), block), !block-&gt;variablesAtTail.argument(i) || block-&gt;variablesAtTail.argument(i)-&gt;accessesStack(m_graph));</span>
 568 
 569                 getLocalPositions.argument(i) = notSet;
 570                 setLocalPositions.argument(i) = notSet;
 571             }
 572             for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfLocals(); ++i) {
 573                 VALIDATE((virtualRegisterForLocal(i), block), !block-&gt;variablesAtHead.local(i) || block-&gt;variablesAtHead.local(i)-&gt;accessesStack(m_graph));
 574                 if (m_graph.m_form == ThreadedCPS)
 575                     VALIDATE((virtualRegisterForLocal(i), block), !block-&gt;variablesAtTail.local(i) || block-&gt;variablesAtTail.local(i)-&gt;accessesStack(m_graph));
 576 
 577                 getLocalPositions.local(i) = notSet;
 578                 setLocalPositions.local(i) = notSet;
 579             }
 580 
 581             for (size_t i = 0; i &lt; block-&gt;size(); ++i) {
 582                 Node* node = block-&gt;at(i);
 583                 ASSERT(nodesInThisBlock.contains(node));
 584                 VALIDATE((node), node-&gt;op() != Phi);
 585                 VALIDATE((node), node-&gt;origin.forExit.isSet());
 586                 for (unsigned j = 0; j &lt; m_graph.numChildren(node); ++j) {
 587                     Edge edge = m_graph.child(node, j);
</pre>
<hr />
<pre>
 651                         VALIDATE((node), !hasDouble(structure-&gt;indexingType()));
 652                     }
 653                     break;
 654                 }
 655                 case Phantom:
 656                     VALIDATE((node), m_graph.m_fixpointState != FixpointNotConverged);
 657                     break;
 658                 default:
 659                     break;
 660                 }
 661 
 662                 if (!node-&gt;shouldGenerate())
 663                     continue;
 664                 switch (node-&gt;op()) {
 665                 case GetLocal:
 666                     // Ignore GetLocal&#39;s that we know to be dead, but that the graph
 667                     // doesn&#39;t yet know to be dead.
 668                     if (!m_myRefCounts.get(node))
 669                         break;
 670                     if (m_graph.m_form == ThreadedCPS) {
<span class="line-modified"> 671                         VALIDATE((node, block), getLocalPositions.operand(node-&gt;local()) == notSet);</span>
 672                         VALIDATE((node, block), !!node-&gt;child1());
 673                         VALIDATE((node, block), node-&gt;child1()-&gt;op() == SetArgumentDefinitely || node-&gt;child1()-&gt;op() == Phi);
 674                     }
<span class="line-modified"> 675                     getLocalPositions.operand(node-&gt;local()) = i;</span>
 676                     break;
 677                 case SetLocal:
 678                     // Only record the first SetLocal. There may be multiple SetLocals
 679                     // because of flushing.
<span class="line-modified"> 680                     if (setLocalPositions.operand(node-&gt;local()) != notSet)</span>
 681                         break;
<span class="line-modified"> 682                     setLocalPositions.operand(node-&gt;local()) = i;</span>
 683                     break;
 684                 case SetArgumentDefinitely:
 685                     // This acts like a reset. It&#39;s ok to have a second GetLocal for a local in the same
 686                     // block if we had a SetArgumentDefinitely for that local.
<span class="line-modified"> 687                     getLocalPositions.operand(node-&gt;local()) = notSet;</span>
<span class="line-modified"> 688                     setLocalPositions.operand(node-&gt;local()) = notSet;</span>
 689                     break;
 690                 case SetArgumentMaybe:
 691                     break;
 692                 case Flush:
 693                 case PhantomLocal:
 694                     if (m_graph.m_form == ThreadedCPS) {
 695                         VALIDATE((node, block),
 696                             node-&gt;child1()-&gt;op() == Phi
 697                             || node-&gt;child1()-&gt;op() == SetLocal
 698                             || node-&gt;child1()-&gt;op() == SetArgumentDefinitely
 699                             || node-&gt;child1()-&gt;op() == SetArgumentMaybe);
 700                         if (node-&gt;op() == PhantomLocal)
 701                             VALIDATE((node, block), node-&gt;child1()-&gt;op() != SetArgumentMaybe);
 702                     }
 703                     break;
 704                 default:
 705                     break;
 706                 }
 707             }
 708 
 709             if (m_graph.m_form == LoadStore)
 710                 continue;
 711 
 712             for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfArguments(); ++i) {
 713                 checkOperand(
<span class="line-modified"> 714                     block, getLocalPositions, setLocalPositions, virtualRegisterForArgument(i));</span>
 715             }
 716             for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfLocals(); ++i) {
 717                 checkOperand(
 718                     block, getLocalPositions, setLocalPositions, virtualRegisterForLocal(i));
 719             }
 720         }
 721 
 722         if (m_graph.m_form == ThreadedCPS) {
 723             Vector&lt;Node*&gt; worklist;
 724             HashSet&lt;Node*&gt; seen;
 725             for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
 726                 for (Node* node : *block) {
 727                     if (node-&gt;op() == GetLocal || node-&gt;op() == PhantomLocal) {
 728                         worklist.append(node);
 729                         auto addResult = seen.add(node);
 730                         VALIDATE((node, block), addResult.isNewEntry);
 731                     }
 732                 }
 733             }
 734 
</pre>
<hr />
<pre>
 742                         worklist.append(child);
 743                     break;
 744                 }
 745                 case Phi: {
 746                     for (unsigned i = 0; i &lt; m_graph.numChildren(node); ++i) {
 747                         Edge edge = m_graph.child(node, i);
 748                         if (!edge)
 749                             continue;
 750                         if (seen.add(edge.node()).isNewEntry)
 751                             worklist.append(edge.node());
 752                     }
 753                     break;
 754                 }
 755                 case SetLocal:
 756                 case SetArgumentDefinitely:
 757                     break;
 758                 case SetArgumentMaybe:
 759                     VALIDATE((node), !&quot;Should not reach SetArgumentMaybe. GetLocal that has data flow that reaches a SetArgumentMaybe is invalid IR.&quot;);
 760                     break;
 761                 default:
<span class="line-modified"> 762                     VALIDATE((node), !&quot;Unexecpted node type.&quot;);</span>
 763                     break;
 764                 }
 765             }
 766         }
 767     }
 768 
 769     void validateSSA()
 770     {
 771         // FIXME: Add more things here.
 772         // https://bugs.webkit.org/show_bug.cgi?id=123471
 773 
 774         VALIDATE((), m_graph.m_roots.size() == 1);
 775         VALIDATE((), m_graph.m_roots[0] == m_graph.block(0));
 776         VALIDATE((), !m_graph.m_argumentFormats.isEmpty()); // We always have at least one entrypoint.
 777         VALIDATE((), m_graph.m_rootToArguments.isEmpty()); // This is only used in CPS.
 778 
 779         m_graph.initializeNodeOwners();
 780 
 781         auto&amp; dominators = m_graph.ensureSSADominators();
 782 
<span class="line-modified"> 783         for (unsigned entrypointIndex : m_graph.m_entrypointIndexToCatchBytecodeOffset.keys())</span>
 784             VALIDATE((), entrypointIndex &gt; 0); // By convention, 0 is the entrypoint index for the op_enter entrypoint, which can not be in a catch.
 785 
 786         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
 787             BasicBlock* block = m_graph.block(blockIndex);
 788             if (!block)
 789                 continue;
 790 
 791             VALIDATE((block), block-&gt;phis.isEmpty());
 792 
 793             bool didSeeExitOK = false;
 794             bool isOSRExited = false;
 795 
 796             HashSet&lt;Node*&gt; nodesInThisBlock;
 797 
 798             for (auto* node : *block) {
 799                 didSeeExitOK |= node-&gt;origin.exitOK;
 800                 switch (node-&gt;op()) {
 801                 case Phi:
 802                     // Phi cannot exit, and it would be wrong to hoist anything to the Phi that could
 803                     // exit.
</pre>
<hr />
<pre>
 951             getLocalPositions.operand(operand) &lt; setLocalPositions.operand(operand));
 952     }
 953 
 954     void reportValidationContext() { }
 955 
 956     void reportValidationContext(Node* node)
 957     {
 958         dataLogF(&quot;@%u&quot;, node-&gt;index());
 959     }
 960 
 961     void reportValidationContext(BasicBlock* block)
 962     {
 963         dataLog(&quot;Block &quot;, *block);
 964     }
 965 
 966     void reportValidationContext(Node* node, Edge edge)
 967     {
 968         dataLog(node, &quot; -&gt; &quot;, edge);
 969     }
 970 
<span class="line-modified"> 971     void reportValidationContext(VirtualRegister local, BasicBlock* block)</span>
 972     {
 973         if (!block) {
<span class="line-modified"> 974             dataLog(local, &quot; in null Block &quot;);</span>
 975             return;
 976         }
 977 
<span class="line-modified"> 978         dataLog(local, &quot; in Block &quot;, *block);</span>
 979     }
 980 
 981     void reportValidationContext(
<span class="line-modified"> 982         VirtualRegister local, BasicBlock* sourceBlock, BasicBlock* destinationBlock)</span>
 983     {
<span class="line-modified"> 984         dataLog(local, &quot; in Block &quot;, *sourceBlock, &quot; -&gt; &quot;, *destinationBlock);</span>
 985     }
 986 
 987     void reportValidationContext(
<span class="line-modified"> 988         VirtualRegister local, BasicBlock* sourceBlock, Node* prevNode)</span>
 989     {
<span class="line-modified"> 990         dataLog(prevNode, &quot; for &quot;, local, &quot; in Block &quot;, *sourceBlock);</span>
 991     }
 992 
 993     void reportValidationContext(Node* node, BasicBlock* block)
 994     {
 995         dataLog(node, &quot; in Block &quot;, *block);
 996     }
 997 
 998     void reportValidationContext(Node* node, Node* node2, BasicBlock* block)
 999     {
1000         dataLog(node, &quot; and &quot;, node2, &quot; in Block &quot;, *block);
1001     }
1002 
1003     void reportValidationContext(
1004         Node* node, BasicBlock* block, Node* expectedNode, Edge incomingEdge)
1005     {
1006         dataLog(node, &quot; in Block &quot;, *block, &quot;, searching for &quot;, expectedNode, &quot; from &quot;, incomingEdge);
1007     }
1008 
1009     void dumpGraphIfAppropriate()
1010     {
</pre>
</td>
<td>
<hr />
<pre>
 269                 case ArithMin:
 270                 case ArithMax:
 271                 case ArithPow:
 272                 case CompareLess:
 273                 case CompareLessEq:
 274                 case CompareGreater:
 275                 case CompareGreaterEq:
 276                 case CompareBelow:
 277                 case CompareBelowEq:
 278                 case CompareEq:
 279                 case CompareStrictEq:
 280                 case SameValue:
 281                 case StrCat:
 282                     VALIDATE((node), !!node-&gt;child1());
 283                     VALIDATE((node), !!node-&gt;child2());
 284                     break;
 285                 case CompareEqPtr:
 286                     VALIDATE((node), !!node-&gt;child1());
 287                     VALIDATE((node), !!node-&gt;cellOperand()-&gt;value() &amp;&amp; node-&gt;cellOperand()-&gt;value().isCell());
 288                     break;
<span class="line-added"> 289                 case CheckArrayOrEmpty:</span>
<span class="line-added"> 290                     VALIDATE((node), is64Bit());</span>
<span class="line-added"> 291                     VALIDATE((node), !!node-&gt;child1());</span>
<span class="line-added"> 292                     VALIDATE((node), node-&gt;child1().useKind() == CellUse);</span>
<span class="line-added"> 293                     break;</span>
 294                 case CheckStructureOrEmpty:
 295                     VALIDATE((node), is64Bit());
 296                     VALIDATE((node), !!node-&gt;child1());
 297                     VALIDATE((node), node-&gt;child1().useKind() == CellUse);
 298                     break;
 299                 case CheckStructure:
 300                 case StringFromCharCode:
 301                     VALIDATE((node), !!node-&gt;child1());
 302                     break;
 303                 case PutStructure:
 304                     VALIDATE((node), !node-&gt;transition()-&gt;previous-&gt;dfgShouldWatch());
 305                     break;
 306                 case MultiPutByOffset:
 307                     for (unsigned i = node-&gt;multiPutByOffsetData().variants.size(); i--;) {
 308                         const PutByIdVariant&amp; variant = node-&gt;multiPutByOffsetData().variants[i];
 309                         if (variant.kind() != PutByIdVariant::Transition)
 310                             continue;
 311                         VALIDATE((node), !variant.oldStructureForTransition()-&gt;dfgShouldWatch());
 312                     }
 313                     break;
</pre>
<hr />
<pre>
 461 
 462             for (size_t i = 0; i &lt; block-&gt;numNodes(); ++i) {
 463                 Node* node = block-&gt;node(i);
 464                 nodesInThisBlock.add(node);
 465                 if (block-&gt;isPhiIndex(i))
 466                     phisInThisBlock.add(node);
 467                 for (unsigned j = 0; j &lt; m_graph.numChildren(node); ++j) {
 468                     Edge edge = m_graph.child(node, j);
 469                     if (!edge)
 470                         continue;
 471                     VALIDATE((node, edge), m_acceptableNodes.contains(edge.node()));
 472                 }
 473             }
 474 
 475             {
 476                 HashSet&lt;Node*&gt; seenNodes;
 477                 for (size_t i = 0; i &lt; block-&gt;size(); ++i) {
 478                     Node* node = block-&gt;at(i);
 479                     m_graph.doToChildren(node, [&amp;] (const Edge&amp; edge) {
 480                         Node* child = edge.node();
<span class="line-modified"> 481                         VALIDATE((node, edge), block-&gt;isInPhis(child) || seenNodes.contains(child));</span>
 482                     });
 483                     seenNodes.add(node);
 484                 }
 485             }
 486 
 487             for (size_t i = 0; i &lt; block-&gt;phis.size(); ++i) {
 488                 Node* node = block-&gt;phis[i];
 489                 ASSERT(phisInThisBlock.contains(node));
 490                 VALIDATE((node), node-&gt;op() == Phi);
<span class="line-modified"> 491                 Operand operand = node-&gt;operand();</span>
 492                 for (unsigned j = 0; j &lt; m_graph.numChildren(node); ++j) {
 493                     // Phi children in LoadStore form are invalid.
 494                     if (m_graph.m_form == LoadStore &amp;&amp; block-&gt;isPhiIndex(i))
 495                         continue;
 496 
 497                     Edge edge = m_graph.child(node, j);
 498                     if (!edge)
 499                         continue;
 500 
 501                     VALIDATE(
 502                         (node, edge),
 503                         edge-&gt;op() == SetLocal
 504                         || edge-&gt;op() == SetArgumentDefinitely
 505                         || edge-&gt;op() == SetArgumentMaybe
 506                         || edge-&gt;op() == Phi);
 507 
 508                     if (phisInThisBlock.contains(edge.node()))
 509                         continue;
 510 
 511                     if (nodesInThisBlock.contains(edge.node())) {
 512                         VALIDATE(
 513                             (node, edge),
 514                             edge-&gt;op() == SetLocal
 515                             || edge-&gt;op() == SetArgumentDefinitely
 516                             || edge-&gt;op() == SetArgumentMaybe);
 517 
 518                         continue;
 519                     }
 520 
 521                     // There must exist a predecessor block that has this node index in
 522                     // its tail variables.
 523                     bool found = false;
 524                     for (unsigned k = 0; k &lt; block-&gt;predecessors.size(); ++k) {
 525                         BasicBlock* prevBlock = block-&gt;predecessors[k];
 526                         VALIDATE((block-&gt;predecessors[k]), prevBlock);
<span class="line-modified"> 527                         Node* prevNode = prevBlock-&gt;variablesAtTail.operand(operand);</span>
 528                         // If we have a Phi that is not referring to *this* block then all predecessors
 529                         // must have that local available.
<span class="line-modified"> 530                         VALIDATE((operand, block, block-&gt;predecessors[k]), prevNode);</span>
 531                         switch (prevNode-&gt;op()) {
 532                         case GetLocal:
 533                         case Flush:
 534                         case PhantomLocal:
 535                             prevNode = prevNode-&gt;child1().node();
 536                             break;
 537                         default:
 538                             break;
 539                         }
 540                         if (node-&gt;shouldGenerate()) {
<span class="line-modified"> 541                             VALIDATE((operand, block-&gt;predecessors[k], prevNode),</span>
 542                                      prevNode-&gt;shouldGenerate());
 543                         }
 544                         VALIDATE(
<span class="line-modified"> 545                             (operand, block-&gt;predecessors[k], prevNode),</span>
 546                             prevNode-&gt;op() == SetLocal
 547                             || prevNode-&gt;op() == SetArgumentDefinitely
 548                             || prevNode-&gt;op() == SetArgumentMaybe
 549                             || prevNode-&gt;op() == Phi);
 550                         if (prevNode == edge.node()) {
 551                             found = true;
 552                             break;
 553                         }
 554                         // At this point it cannot refer into this block.
<span class="line-modified"> 555                         VALIDATE((operand, block-&gt;predecessors[k], prevNode), !prevBlock-&gt;isInBlock(edge.node()));</span>
 556                     }
 557 
 558                     VALIDATE((node, edge), found);
 559                 }
 560             }
 561 
<span class="line-modified"> 562             Operands&lt;size_t&gt; getLocalPositions(OperandsLike, block-&gt;variablesAtHead);</span>
<span class="line-modified"> 563             Operands&lt;size_t&gt; setLocalPositions(OperandsLike, block-&gt;variablesAtHead);</span>




 564 
 565             for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfArguments(); ++i) {
<span class="line-modified"> 566                 VALIDATE((virtualRegisterForArgumentIncludingThis(i), block), !block-&gt;variablesAtHead.argument(i) || block-&gt;variablesAtHead.argument(i)-&gt;accessesStack(m_graph));</span>
 567                 if (m_graph.m_form == ThreadedCPS)
<span class="line-modified"> 568                     VALIDATE((virtualRegisterForArgumentIncludingThis(i), block), !block-&gt;variablesAtTail.argument(i) || block-&gt;variablesAtTail.argument(i)-&gt;accessesStack(m_graph));</span>
 569 
 570                 getLocalPositions.argument(i) = notSet;
 571                 setLocalPositions.argument(i) = notSet;
 572             }
 573             for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfLocals(); ++i) {
 574                 VALIDATE((virtualRegisterForLocal(i), block), !block-&gt;variablesAtHead.local(i) || block-&gt;variablesAtHead.local(i)-&gt;accessesStack(m_graph));
 575                 if (m_graph.m_form == ThreadedCPS)
 576                     VALIDATE((virtualRegisterForLocal(i), block), !block-&gt;variablesAtTail.local(i) || block-&gt;variablesAtTail.local(i)-&gt;accessesStack(m_graph));
 577 
 578                 getLocalPositions.local(i) = notSet;
 579                 setLocalPositions.local(i) = notSet;
 580             }
 581 
 582             for (size_t i = 0; i &lt; block-&gt;size(); ++i) {
 583                 Node* node = block-&gt;at(i);
 584                 ASSERT(nodesInThisBlock.contains(node));
 585                 VALIDATE((node), node-&gt;op() != Phi);
 586                 VALIDATE((node), node-&gt;origin.forExit.isSet());
 587                 for (unsigned j = 0; j &lt; m_graph.numChildren(node); ++j) {
 588                     Edge edge = m_graph.child(node, j);
</pre>
<hr />
<pre>
 652                         VALIDATE((node), !hasDouble(structure-&gt;indexingType()));
 653                     }
 654                     break;
 655                 }
 656                 case Phantom:
 657                     VALIDATE((node), m_graph.m_fixpointState != FixpointNotConverged);
 658                     break;
 659                 default:
 660                     break;
 661                 }
 662 
 663                 if (!node-&gt;shouldGenerate())
 664                     continue;
 665                 switch (node-&gt;op()) {
 666                 case GetLocal:
 667                     // Ignore GetLocal&#39;s that we know to be dead, but that the graph
 668                     // doesn&#39;t yet know to be dead.
 669                     if (!m_myRefCounts.get(node))
 670                         break;
 671                     if (m_graph.m_form == ThreadedCPS) {
<span class="line-modified"> 672                         VALIDATE((node, block), getLocalPositions.operand(node-&gt;operand()) == notSet);</span>
 673                         VALIDATE((node, block), !!node-&gt;child1());
 674                         VALIDATE((node, block), node-&gt;child1()-&gt;op() == SetArgumentDefinitely || node-&gt;child1()-&gt;op() == Phi);
 675                     }
<span class="line-modified"> 676                     getLocalPositions.operand(node-&gt;operand()) = i;</span>
 677                     break;
 678                 case SetLocal:
 679                     // Only record the first SetLocal. There may be multiple SetLocals
 680                     // because of flushing.
<span class="line-modified"> 681                     if (setLocalPositions.operand(node-&gt;operand()) != notSet)</span>
 682                         break;
<span class="line-modified"> 683                     setLocalPositions.operand(node-&gt;operand()) = i;</span>
 684                     break;
 685                 case SetArgumentDefinitely:
 686                     // This acts like a reset. It&#39;s ok to have a second GetLocal for a local in the same
 687                     // block if we had a SetArgumentDefinitely for that local.
<span class="line-modified"> 688                     getLocalPositions.operand(node-&gt;operand()) = notSet;</span>
<span class="line-modified"> 689                     setLocalPositions.operand(node-&gt;operand()) = notSet;</span>
 690                     break;
 691                 case SetArgumentMaybe:
 692                     break;
 693                 case Flush:
 694                 case PhantomLocal:
 695                     if (m_graph.m_form == ThreadedCPS) {
 696                         VALIDATE((node, block),
 697                             node-&gt;child1()-&gt;op() == Phi
 698                             || node-&gt;child1()-&gt;op() == SetLocal
 699                             || node-&gt;child1()-&gt;op() == SetArgumentDefinitely
 700                             || node-&gt;child1()-&gt;op() == SetArgumentMaybe);
 701                         if (node-&gt;op() == PhantomLocal)
 702                             VALIDATE((node, block), node-&gt;child1()-&gt;op() != SetArgumentMaybe);
 703                     }
 704                     break;
 705                 default:
 706                     break;
 707                 }
 708             }
 709 
 710             if (m_graph.m_form == LoadStore)
 711                 continue;
 712 
 713             for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfArguments(); ++i) {
 714                 checkOperand(
<span class="line-modified"> 715                     block, getLocalPositions, setLocalPositions, virtualRegisterForArgumentIncludingThis(i));</span>
 716             }
 717             for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfLocals(); ++i) {
 718                 checkOperand(
 719                     block, getLocalPositions, setLocalPositions, virtualRegisterForLocal(i));
 720             }
 721         }
 722 
 723         if (m_graph.m_form == ThreadedCPS) {
 724             Vector&lt;Node*&gt; worklist;
 725             HashSet&lt;Node*&gt; seen;
 726             for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
 727                 for (Node* node : *block) {
 728                     if (node-&gt;op() == GetLocal || node-&gt;op() == PhantomLocal) {
 729                         worklist.append(node);
 730                         auto addResult = seen.add(node);
 731                         VALIDATE((node, block), addResult.isNewEntry);
 732                     }
 733                 }
 734             }
 735 
</pre>
<hr />
<pre>
 743                         worklist.append(child);
 744                     break;
 745                 }
 746                 case Phi: {
 747                     for (unsigned i = 0; i &lt; m_graph.numChildren(node); ++i) {
 748                         Edge edge = m_graph.child(node, i);
 749                         if (!edge)
 750                             continue;
 751                         if (seen.add(edge.node()).isNewEntry)
 752                             worklist.append(edge.node());
 753                     }
 754                     break;
 755                 }
 756                 case SetLocal:
 757                 case SetArgumentDefinitely:
 758                     break;
 759                 case SetArgumentMaybe:
 760                     VALIDATE((node), !&quot;Should not reach SetArgumentMaybe. GetLocal that has data flow that reaches a SetArgumentMaybe is invalid IR.&quot;);
 761                     break;
 762                 default:
<span class="line-modified"> 763                     VALIDATE((node), !&quot;Unexpected node type.&quot;);</span>
 764                     break;
 765                 }
 766             }
 767         }
 768     }
 769 
 770     void validateSSA()
 771     {
 772         // FIXME: Add more things here.
 773         // https://bugs.webkit.org/show_bug.cgi?id=123471
 774 
 775         VALIDATE((), m_graph.m_roots.size() == 1);
 776         VALIDATE((), m_graph.m_roots[0] == m_graph.block(0));
 777         VALIDATE((), !m_graph.m_argumentFormats.isEmpty()); // We always have at least one entrypoint.
 778         VALIDATE((), m_graph.m_rootToArguments.isEmpty()); // This is only used in CPS.
 779 
 780         m_graph.initializeNodeOwners();
 781 
 782         auto&amp; dominators = m_graph.ensureSSADominators();
 783 
<span class="line-modified"> 784         for (unsigned entrypointIndex : m_graph.m_entrypointIndexToCatchBytecodeIndex.keys())</span>
 785             VALIDATE((), entrypointIndex &gt; 0); // By convention, 0 is the entrypoint index for the op_enter entrypoint, which can not be in a catch.
 786 
 787         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
 788             BasicBlock* block = m_graph.block(blockIndex);
 789             if (!block)
 790                 continue;
 791 
 792             VALIDATE((block), block-&gt;phis.isEmpty());
 793 
 794             bool didSeeExitOK = false;
 795             bool isOSRExited = false;
 796 
 797             HashSet&lt;Node*&gt; nodesInThisBlock;
 798 
 799             for (auto* node : *block) {
 800                 didSeeExitOK |= node-&gt;origin.exitOK;
 801                 switch (node-&gt;op()) {
 802                 case Phi:
 803                     // Phi cannot exit, and it would be wrong to hoist anything to the Phi that could
 804                     // exit.
</pre>
<hr />
<pre>
 952             getLocalPositions.operand(operand) &lt; setLocalPositions.operand(operand));
 953     }
 954 
 955     void reportValidationContext() { }
 956 
 957     void reportValidationContext(Node* node)
 958     {
 959         dataLogF(&quot;@%u&quot;, node-&gt;index());
 960     }
 961 
 962     void reportValidationContext(BasicBlock* block)
 963     {
 964         dataLog(&quot;Block &quot;, *block);
 965     }
 966 
 967     void reportValidationContext(Node* node, Edge edge)
 968     {
 969         dataLog(node, &quot; -&gt; &quot;, edge);
 970     }
 971 
<span class="line-modified"> 972     void reportValidationContext(Operand operand, BasicBlock* block)</span>
 973     {
 974         if (!block) {
<span class="line-modified"> 975             dataLog(operand, &quot; in null Block &quot;);</span>
 976             return;
 977         }
 978 
<span class="line-modified"> 979         dataLog(operand, &quot; in Block &quot;, *block);</span>
 980     }
 981 
 982     void reportValidationContext(
<span class="line-modified"> 983         Operand operand, BasicBlock* sourceBlock, BasicBlock* destinationBlock)</span>
 984     {
<span class="line-modified"> 985         dataLog(operand, &quot; in Block &quot;, *sourceBlock, &quot; -&gt; &quot;, *destinationBlock);</span>
 986     }
 987 
 988     void reportValidationContext(
<span class="line-modified"> 989         Operand operand, BasicBlock* sourceBlock, Node* prevNode)</span>
 990     {
<span class="line-modified"> 991         dataLog(prevNode, &quot; for &quot;, operand, &quot; in Block &quot;, *sourceBlock);</span>
 992     }
 993 
 994     void reportValidationContext(Node* node, BasicBlock* block)
 995     {
 996         dataLog(node, &quot; in Block &quot;, *block);
 997     }
 998 
 999     void reportValidationContext(Node* node, Node* node2, BasicBlock* block)
1000     {
1001         dataLog(node, &quot; and &quot;, node2, &quot; in Block &quot;, *block);
1002     }
1003 
1004     void reportValidationContext(
1005         Node* node, BasicBlock* block, Node* expectedNode, Edge incomingEdge)
1006     {
1007         dataLog(node, &quot; in Block &quot;, *block, &quot;, searching for &quot;, expectedNode, &quot; from &quot;, incomingEdge);
1008     }
1009 
1010     void dumpGraphIfAppropriate()
1011     {
</pre>
</td>
</tr>
</table>
<center><a href="DFGUseKind.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGVarargsForwardingPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IteratorOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;.
  3  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;IteratorOperations.h&quot;
 29 
 30 #include &quot;CatchScope.h&quot;
 31 #include &quot;Error.h&quot;
 32 #include &quot;JSCInlines.h&quot;
 33 #include &quot;ObjectConstructor.h&quot;
 34 
 35 namespace JSC {
 36 
 37 JSValue iteratorNext(ExecState* exec, IterationRecord iterationRecord, JSValue argument)
 38 {
 39     VM&amp; vm = exec-&gt;vm();
 40     auto scope = DECLARE_THROW_SCOPE(vm);
 41 
 42     JSValue iterator = iterationRecord.iterator;
 43     JSValue nextFunction = iterationRecord.nextMethod;
 44 
 45     CallData nextFunctionCallData;
 46     CallType nextFunctionCallType = getCallData(vm, nextFunction, nextFunctionCallData);
 47     if (nextFunctionCallType == CallType::None)
 48         return throwTypeError(exec, scope);
 49 
 50     MarkedArgumentBuffer nextFunctionArguments;
 51     if (!argument.isEmpty())
 52         nextFunctionArguments.append(argument);
 53     ASSERT(!nextFunctionArguments.hasOverflowed());
 54     JSValue result = call(exec, nextFunction, nextFunctionCallType, nextFunctionCallData, iterator, nextFunctionArguments);
 55     RETURN_IF_EXCEPTION(scope, JSValue());
 56 
 57     if (!result.isObject())
 58         return throwTypeError(exec, scope, &quot;Iterator result interface is not an object.&quot;_s);
 59 
 60     return result;
 61 }
 62 
 63 JSValue iteratorValue(ExecState* exec, JSValue iterResult)
 64 {
 65     return iterResult.get(exec, exec-&gt;vm().propertyNames-&gt;value);
 66 }
 67 
 68 bool iteratorComplete(ExecState* exec, JSValue iterResult)
 69 {
 70     JSValue done = iterResult.get(exec, exec-&gt;vm().propertyNames-&gt;done);
 71     return done.toBoolean(exec);
 72 }
 73 
 74 JSValue iteratorStep(ExecState* exec, IterationRecord iterationRecord)
 75 {
 76     VM&amp; vm = exec-&gt;vm();
 77     auto scope = DECLARE_THROW_SCOPE(vm);
 78 
 79     JSValue result = iteratorNext(exec, iterationRecord);
 80     RETURN_IF_EXCEPTION(scope, JSValue());
 81     bool done = iteratorComplete(exec, result);
 82     RETURN_IF_EXCEPTION(scope, JSValue());
 83     if (done)
 84         return jsBoolean(false);
 85     return result;
 86 }
 87 
 88 void iteratorClose(ExecState* exec, IterationRecord iterationRecord)
 89 {
 90     VM&amp; vm = exec-&gt;vm();
 91     auto throwScope = DECLARE_THROW_SCOPE(vm);
 92     auto catchScope = DECLARE_CATCH_SCOPE(vm);
 93 
 94     Exception* exception = nullptr;
 95     if (UNLIKELY(catchScope.exception())) {
 96         exception = catchScope.exception();
 97         catchScope.clearException();
 98     }
 99     JSValue returnFunction = iterationRecord.iterator.get(exec, vm.propertyNames-&gt;returnKeyword);
100     RETURN_IF_EXCEPTION(throwScope, void());
101 
102     if (returnFunction.isUndefined()) {
103         if (exception)
104             throwException(exec, throwScope, exception);
105         return;
106     }
107 
108     CallData returnFunctionCallData;
109     CallType returnFunctionCallType = getCallData(vm, returnFunction, returnFunctionCallData);
110     if (returnFunctionCallType == CallType::None) {
111         if (exception)
112             throwException(exec, throwScope, exception);
113         else
114             throwTypeError(exec, throwScope);
115         return;
116     }
117 
118     MarkedArgumentBuffer returnFunctionArguments;
119     ASSERT(!returnFunctionArguments.hasOverflowed());
120     JSValue innerResult = call(exec, returnFunction, returnFunctionCallType, returnFunctionCallData, iterationRecord.iterator, returnFunctionArguments);
121 
122     if (exception) {
123         throwException(exec, throwScope, exception);
124         return;
125     }
126 
127     RETURN_IF_EXCEPTION(throwScope, void());
128 
129     if (!innerResult.isObject()) {
130         throwTypeError(exec, throwScope, &quot;Iterator result interface is not an object.&quot;_s);
131         return;
132     }
133 }
134 
135 static const PropertyOffset valuePropertyOffset = 0;
136 static const PropertyOffset donePropertyOffset = 1;
137 
138 Structure* createIteratorResultObjectStructure(VM&amp; vm, JSGlobalObject&amp; globalObject)
139 {
140     Structure* iteratorResultStructure = vm.structureCache.emptyObjectStructureForPrototype(&amp;globalObject, globalObject.objectPrototype(), JSFinalObject::defaultInlineCapacity());
141     PropertyOffset offset;
142     iteratorResultStructure = Structure::addPropertyTransition(vm, iteratorResultStructure, vm.propertyNames-&gt;value, 0, offset);
143     RELEASE_ASSERT(offset == valuePropertyOffset);
144     iteratorResultStructure = Structure::addPropertyTransition(vm, iteratorResultStructure, vm.propertyNames-&gt;done, 0, offset);
145     RELEASE_ASSERT(offset == donePropertyOffset);
146     return iteratorResultStructure;
147 }
148 
149 JSObject* createIteratorResultObject(ExecState* exec, JSValue value, bool done)
150 {
151     VM&amp; vm = exec-&gt;vm();
152     JSObject* resultObject = constructEmptyObject(exec, exec-&gt;lexicalGlobalObject()-&gt;iteratorResultObjectStructure());
153     resultObject-&gt;putDirect(vm, valuePropertyOffset, value);
154     resultObject-&gt;putDirect(vm, donePropertyOffset, jsBoolean(done));
155     return resultObject;
156 }
157 
158 bool hasIteratorMethod(ExecState&amp; state, JSValue value)
159 {
160     auto&amp; vm = state.vm();
161     auto scope = DECLARE_THROW_SCOPE(vm);
162 
163     if (!value.isObject())
164         return false;
165 
166     JSObject* object = asObject(value);
167     CallData callData;
168     CallType callType;
169     JSValue applyMethod = object-&gt;getMethod(&amp;state, callData, callType, vm.propertyNames-&gt;iteratorSymbol, &quot;Symbol.iterator property should be callable&quot;_s);
170     RETURN_IF_EXCEPTION(scope, false);
171 
172     return !applyMethod.isUndefined();
173 }
174 
175 JSValue iteratorMethod(ExecState&amp; state, JSObject* object)
176 {
177     auto&amp; vm = state.vm();
178     auto scope = DECLARE_THROW_SCOPE(vm);
179 
180     CallData callData;
181     CallType callType;
182     JSValue method = object-&gt;getMethod(&amp;state, callData, callType, vm.propertyNames-&gt;iteratorSymbol, &quot;Symbol.iterator property should be callable&quot;_s);
183     RETURN_IF_EXCEPTION(scope, jsUndefined());
184 
185     return method;
186 }
187 
188 IterationRecord iteratorForIterable(ExecState&amp; state, JSObject* object, JSValue iteratorMethod)
189 {
190     VM&amp; vm = state.vm();
191     auto scope = DECLARE_THROW_SCOPE(vm);
192 
193     CallData iteratorMethodCallData;
194     CallType iteratorMethodCallType = getCallData(vm, iteratorMethod, iteratorMethodCallData);
195     if (iteratorMethodCallType == CallType::None) {
196         throwTypeError(&amp;state, scope);
197         return { };
198     }
199 
200     ArgList iteratorMethodArguments;
201     JSValue iterator = call(&amp;state, iteratorMethod, iteratorMethodCallType, iteratorMethodCallData, object, iteratorMethodArguments);
202     RETURN_IF_EXCEPTION(scope, { });
203 
204     if (!iterator.isObject()) {
205         throwTypeError(&amp;state, scope);
206         return { };
207     }
208 
209     JSValue nextMethod = iterator.getObject()-&gt;get(&amp;state, vm.propertyNames-&gt;next);
210     RETURN_IF_EXCEPTION(scope, { });
211 
212     return { iterator, nextMethod };
213 }
214 
215 IterationRecord iteratorForIterable(ExecState* state, JSValue iterable)
216 {
217     VM&amp; vm = state-&gt;vm();
218     auto scope = DECLARE_THROW_SCOPE(vm);
219 
220     JSValue iteratorFunction = iterable.get(state, vm.propertyNames-&gt;iteratorSymbol);
221     RETURN_IF_EXCEPTION(scope, { });
222 
223     CallData iteratorFunctionCallData;
224     CallType iteratorFunctionCallType = getCallData(vm, iteratorFunction, iteratorFunctionCallData);
225     if (iteratorFunctionCallType == CallType::None) {
226         throwTypeError(state, scope);
227         return { };
228     }
229 
230     ArgList iteratorFunctionArguments;
231     JSValue iterator = call(state, iteratorFunction, iteratorFunctionCallType, iteratorFunctionCallData, iterable, iteratorFunctionArguments);
232     RETURN_IF_EXCEPTION(scope, { });
233 
234     if (!iterator.isObject()) {
235         throwTypeError(state, scope);
236         return { };
237     }
238 
239     JSValue nextMethod = iterator.getObject()-&gt;get(state, vm.propertyNames-&gt;next);
240     RETURN_IF_EXCEPTION(scope, { });
241 
242     return { iterator, nextMethod };
243 }
244 
245 } // namespace JSC
    </pre>
  </body>
</html>
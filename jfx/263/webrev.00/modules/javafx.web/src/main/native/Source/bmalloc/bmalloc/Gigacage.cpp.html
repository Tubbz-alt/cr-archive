<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Gigacage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;Gigacage.h&quot;
 27 
 28 #include &quot;CryptoRandom.h&quot;
 29 #include &quot;Environment.h&quot;
 30 #include &quot;ProcessCheck.h&quot;
 31 #include &quot;StaticPerProcess.h&quot;
 32 #include &quot;VMAllocate.h&quot;
 33 #include &quot;Vector.h&quot;
 34 #include &quot;bmalloc.h&quot;
 35 #include &lt;cstdio&gt;
 36 #include &lt;mutex&gt;
 37 
 38 #if BOS(DARWIN)
 39 #include &lt;mach/mach.h&gt;
 40 #endif
 41 
 42 #if GIGACAGE_ENABLED
 43 
 44 namespace Gigacage {
 45 
 46 struct Callback {
 47     Callback() { }
 48 
 49     Callback(void (*function)(void*), void *argument)
 50         : function(function)
 51         , argument(argument)
 52     {
 53     }
 54 
 55     void (*function)(void*) { nullptr };
 56     void* argument { nullptr };
 57 };
 58 
 59 }
 60 
 61 namespace bmalloc {
 62 
 63 struct PrimitiveDisableCallbacks : public StaticPerProcess&lt;PrimitiveDisableCallbacks&gt; {
 64     PrimitiveDisableCallbacks(const LockHolder&amp;) { }
 65 
 66     Vector&lt;Gigacage::Callback&gt; callbacks;
 67 };
 68 DECLARE_STATIC_PER_PROCESS_STORAGE(PrimitiveDisableCallbacks);
 69 DEFINE_STATIC_PER_PROCESS_STORAGE(PrimitiveDisableCallbacks);
 70 
 71 } // namespace bmalloc
 72 
 73 namespace Gigacage {
 74 
 75 // This is exactly 32GB because inside JSC, indexed accesses for arrays, typed arrays, etc,
 76 // use unsigned 32-bit ints as indices. The items those indices access are 8 bytes or less
 77 // in size. 2^32 * 8 = 32GB. This means if an access on a caged type happens to go out of
 78 // bounds, the access is guaranteed to land somewhere else in the cage or inside the runway.
 79 // If this were less than 32GB, those OOB accesses could reach outside of the cage.
 80 constexpr size_t gigacageRunway = 32llu * bmalloc::Sizes::GB;
 81 
 82 alignas(configSizeToProtect) Config g_gigacageConfig;
 83 
 84 using namespace bmalloc;
 85 
 86 namespace {
 87 
 88 #if BOS(DARWIN)
 89 enum {
 90     AllowPermissionChangesAfterThis = false,
 91     DisallowPermissionChangesAfterThis = true
 92 };
 93 #endif
 94 
 95 static void freezeGigacageConfig()
 96 {
 97     int result;
 98 #if BOS(DARWIN)
 99     result = vm_protect(mach_task_self(), reinterpret_cast&lt;vm_address_t&gt;(&amp;g_gigacageConfig), configSizeToProtect, AllowPermissionChangesAfterThis, VM_PROT_READ);
100 #else
101     result = mprotect(&amp;g_gigacageConfig, configSizeToProtect, PROT_READ);
102 #endif
103     RELEASE_BASSERT(!result);
104 }
105 
106 static void unfreezeGigacageConfig()
107 {
108     RELEASE_BASSERT(!g_gigacageConfig.isPermanentlyFrozen);
109     int result;
110 #if BOS(DARWIN)
111     result = vm_protect(mach_task_self(), reinterpret_cast&lt;vm_address_t&gt;(&amp;g_gigacageConfig), configSizeToProtect, AllowPermissionChangesAfterThis, VM_PROT_READ | VM_PROT_WRITE);
112 #else
113     result = mprotect(&amp;g_gigacageConfig, configSizeToProtect, PROT_READ | PROT_WRITE);
114 #endif
115     RELEASE_BASSERT(!result);
116 }
117 
118 static void permanentlyFreezeGigacageConfig()
119 {
120     if (!g_gigacageConfig.isPermanentlyFrozen) {
121         unfreezeGigacageConfig();
122         g_gigacageConfig.isPermanentlyFrozen = true;
123     }
124 
125     // There&#39;s no going back now!
126     int result;
127 #if BOS(DARWIN)
128     result = vm_protect(mach_task_self(), reinterpret_cast&lt;vm_address_t&gt;(&amp;g_gigacageConfig), configSizeToProtect, DisallowPermissionChangesAfterThis, VM_PROT_READ);
129 #else
130     result = mprotect(&amp;g_gigacageConfig, configSizeToProtect, PROT_READ);
131 #endif
132     RELEASE_BASSERT(!result);
133 }
134 
135 class UnfreezeGigacageConfigScope {
136 public:
137     UnfreezeGigacageConfigScope()
138     {
139         unfreezeGigacageConfig();
140     }
141 
142     ~UnfreezeGigacageConfigScope()
143     {
144         freezeGigacageConfig();
145     }
146 };
147 
148 size_t runwaySize(Kind kind)
149 {
150     switch (kind) {
151     case Kind::Primitive:
152         return gigacageRunway;
153     case Kind::JSValue:
154         return 0;
155     case Kind::NumberOfKinds:
156         RELEASE_BASSERT_NOT_REACHED();
157     }
158     return 0;
159 }
160 
161 } // anonymous namespace
162 
163 void ensureGigacage()
164 {
165     static std::once_flag onceFlag;
166     std::call_once(
167         onceFlag,
168         [] {
169             RELEASE_BASSERT(!g_gigacageConfig.ensureGigacageHasBeenCalled);
170             g_gigacageConfig.ensureGigacageHasBeenCalled = true;
171 
172             if (!shouldBeEnabled())
173                 return;
174 
175             // We might only get page size alignment, but that&#39;s also the minimum
176             // alignment we need for freezing the Config.
177             RELEASE_BASSERT(!(reinterpret_cast&lt;size_t&gt;(&amp;g_gigacageConfig) &amp; (vmPageSize() - 1)));
178 
179             Kind shuffledKinds[NumberOfKinds];
180             for (unsigned i = 0; i &lt; NumberOfKinds; ++i)
181                 shuffledKinds[i] = static_cast&lt;Kind&gt;(i);
182 
183             // We just go ahead and assume that 64 bits is enough randomness. That&#39;s trivially true right
184             // now, but would stop being true if we went crazy with gigacages. Based on my math, 21 is the
185             // largest value of n so that n! &lt;= 2^64.
186             static_assert(NumberOfKinds &lt;= 21, &quot;too many kinds&quot;);
187             uint64_t random;
188             cryptoRandom(reinterpret_cast&lt;unsigned char*&gt;(&amp;random), sizeof(random));
189             for (unsigned i = NumberOfKinds; i--;) {
190                 unsigned limit = i + 1;
191                 unsigned j = static_cast&lt;unsigned&gt;(random % limit);
192                 random /= limit;
193                 std::swap(shuffledKinds[i], shuffledKinds[j]);
194             }
195 
196             auto alignTo = [] (Kind kind, size_t totalSize) -&gt; size_t {
197                 return roundUpToMultipleOf(alignment(kind), totalSize);
198             };
199             auto bump = [] (Kind kind, size_t totalSize) -&gt; size_t {
200                 return totalSize + size(kind);
201             };
202 
203             size_t totalSize = 0;
204             size_t maxAlignment = 0;
205 
206             for (Kind kind : shuffledKinds) {
207                 totalSize = bump(kind, alignTo(kind, totalSize));
208                 totalSize += runwaySize(kind);
209                 maxAlignment = std::max(maxAlignment, alignment(kind));
210             }
211 
212             // FIXME: Randomize where this goes.
213             // https://bugs.webkit.org/show_bug.cgi?id=175245
214             void* base = tryVMAllocate(maxAlignment, totalSize, VMTag::JSGigacage);
215             if (!base) {
216                 if (GIGACAGE_ALLOCATION_CAN_FAIL)
217                     return;
218                 fprintf(stderr, &quot;FATAL: Could not allocate gigacage memory with maxAlignment = %lu, totalSize = %lu.\n&quot;, maxAlignment, totalSize);
219                 fprintf(stderr, &quot;(Make sure you have not set a virtual memory limit.)\n&quot;);
220                 BCRASH();
221             }
222 
223             size_t nextCage = 0;
224             for (Kind kind : shuffledKinds) {
225                 nextCage = alignTo(kind, nextCage);
226                 g_gigacageConfig.setBasePtr(kind, reinterpret_cast&lt;char*&gt;(base) + nextCage);
227                 nextCage = bump(kind, nextCage);
228                 if (runwaySize(kind) &gt; 0) {
229                     char* runway = reinterpret_cast&lt;char*&gt;(base) + nextCage;
230                     // Make OOB accesses into the runway crash.
231                     vmRevokePermissions(runway, runwaySize(kind));
232                     nextCage += runwaySize(kind);
233                 }
234             }
235 
236             g_gigacageConfig.start = base;
237             g_gigacageConfig.totalSize = totalSize;
238             vmDeallocatePhysicalPages(base, totalSize);
239             g_gigacageConfig.isEnabled = true;
240             freezeGigacageConfig();
241         });
242 }
243 
244 void disablePrimitiveGigacage()
245 {
246     if (g_gigacageConfig.disablingPrimitiveGigacageIsForbidden)
247         fprintf(stderr, &quot;FATAL: Disabling Primitive gigacage is forbidden, but we don&#39;t want that in this process.\n&quot;);
248 
249     RELEASE_BASSERT(!g_gigacageConfig.disablingPrimitiveGigacageIsForbidden);
250     RELEASE_BASSERT(!g_gigacageConfig.isPermanentlyFrozen);
251 
252     ensureGigacage();
253     if (!g_gigacageConfig.basePtrs[Primitive]) {
254         // It was never enabled. That means that we never even saved any callbacks. Or, we had already disabled
255         // it before, and already called the callbacks.
256         return;
257     }
258 
259     PrimitiveDisableCallbacks&amp; callbacks = *PrimitiveDisableCallbacks::get();
260     UniqueLockHolder lock(PrimitiveDisableCallbacks::mutex());
261     for (Callback&amp; callback : callbacks.callbacks)
262         callback.function(callback.argument);
263     callbacks.callbacks.shrink(0);
264     UnfreezeGigacageConfigScope unfreezeScope;
265     g_gigacageConfig.basePtrs[Primitive] = nullptr;
266 }
267 
268 void addPrimitiveDisableCallback(void (*function)(void*), void* argument)
269 {
270     ensureGigacage();
271     if (!g_gigacageConfig.basePtrs[Primitive]) {
272         // It was already disabled or we were never able to enable it.
273         function(argument);
274         return;
275     }
276 
277     PrimitiveDisableCallbacks&amp; callbacks = *PrimitiveDisableCallbacks::get();
278     UniqueLockHolder lock(PrimitiveDisableCallbacks::mutex());
279     callbacks.callbacks.push(Callback(function, argument));
280 }
281 
282 void removePrimitiveDisableCallback(void (*function)(void*), void* argument)
283 {
284     PrimitiveDisableCallbacks&amp; callbacks = *PrimitiveDisableCallbacks::get();
285     UniqueLockHolder lock(PrimitiveDisableCallbacks::mutex());
286     for (size_t i = 0; i &lt; callbacks.callbacks.size(); ++i) {
287         if (callbacks.callbacks[i].function == function
288             &amp;&amp; callbacks.callbacks[i].argument == argument) {
289             callbacks.callbacks[i] = callbacks.callbacks.last();
290             callbacks.callbacks.pop();
291             return;
292         }
293     }
294 }
295 
296 static bool verifyGigacageIsEnabled()
297 {
298     bool isEnabled = g_gigacageConfig.isEnabled;
299     for (size_t i = 0; i &lt; NumberOfKinds; ++i)
300         isEnabled = isEnabled &amp;&amp; g_gigacageConfig.basePtrs[i];
301     isEnabled = isEnabled &amp;&amp; g_gigacageConfig.start;
302     isEnabled = isEnabled &amp;&amp; g_gigacageConfig.totalSize;
303     return isEnabled;
304 }
305 
306 void forbidDisablingPrimitiveGigacage()
307 {
308     ensureGigacage();
309     RELEASE_BASSERT(g_gigacageConfig.shouldBeEnabledHasBeenCalled
310         &amp;&amp; (GIGACAGE_ALLOCATION_CAN_FAIL || !g_gigacageConfig.shouldBeEnabled || verifyGigacageIsEnabled()));
311 
312     if (!g_gigacageConfig.disablingPrimitiveGigacageIsForbidden) {
313         unfreezeGigacageConfig();
314         g_gigacageConfig.disablingPrimitiveGigacageIsForbidden = true;
315     }
316     permanentlyFreezeGigacageConfig();
317     RELEASE_BASSERT(isDisablingPrimitiveGigacageForbidden());
318 }
319 
320 BNO_INLINE bool isDisablingPrimitiveGigacageForbidden()
321 {
322     return g_gigacageConfig.disablingPrimitiveGigacageIsForbidden;
323 }
324 
325 bool shouldBeEnabled()
326 {
327     static std::once_flag onceFlag;
328     std::call_once(
329         onceFlag,
330         [] {
331             RELEASE_BASSERT(!g_gigacageConfig.shouldBeEnabledHasBeenCalled);
332             g_gigacageConfig.shouldBeEnabledHasBeenCalled = true;
333 
334             bool debugHeapEnabled = Environment::get()-&gt;isDebugHeapEnabled();
335             if (debugHeapEnabled)
336                 return;
337 
338             if (!gigacageEnabledForProcess())
339                 return;
340 
341             if (char* gigacageEnabled = getenv(&quot;GIGACAGE_ENABLED&quot;)) {
342                 if (!strcasecmp(gigacageEnabled, &quot;no&quot;) || !strcasecmp(gigacageEnabled, &quot;false&quot;) || !strcasecmp(gigacageEnabled, &quot;0&quot;)) {
343                     fprintf(stderr, &quot;Warning: disabling gigacage because GIGACAGE_ENABLED=%s!\n&quot;, gigacageEnabled);
344                     return;
345                 } else if (strcasecmp(gigacageEnabled, &quot;yes&quot;) &amp;&amp; strcasecmp(gigacageEnabled, &quot;true&quot;) &amp;&amp; strcasecmp(gigacageEnabled, &quot;1&quot;))
346                     fprintf(stderr, &quot;Warning: invalid argument to GIGACAGE_ENABLED: %s\n&quot;, gigacageEnabled);
347             }
348 
349             g_gigacageConfig.shouldBeEnabled = true;
350         });
351     return g_gigacageConfig.shouldBeEnabled;
352 }
353 
354 } // namespace Gigacage
355 
356 #endif // GIGACAGE_ENABLED
    </pre>
  </body>
</html>
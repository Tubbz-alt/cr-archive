diff a/modules/javafx.web/src/main/native/Source/WebCore/page/DOMWindow.h b/modules/javafx.web/src/main/native/Source/WebCore/page/DOMWindow.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/page/DOMWindow.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/page/DOMWindow.h
@@ -31,23 +31,25 @@
 #include "ContextDestructionObserver.h"
 #include "ExceptionOr.h"
 #include "Frame.h"
 #include "FrameDestructionObserver.h"
 #include "ImageBitmap.h"
+#include "PostMessageOptions.h"
 #include "ScrollToOptions.h"
 #include "ScrollTypes.h"
 #include "Supplementable.h"
 #include <JavaScriptCore/HandleTypes.h>
+#include <JavaScriptCore/Strong.h>
 #include <wtf/Function.h>
 #include <wtf/HashSet.h>
+#include <wtf/MonotonicTime.h>
 #include <wtf/WeakPtr.h>
 
 namespace JSC {
-class ExecState;
+class CallFrame;
 class JSObject;
 class JSValue;
-template<typename> class Strong;
 }
 
 namespace WebCore {
 
 class BarProp;
@@ -62,20 +64,22 @@
 class Document;
 class Element;
 class EventListener;
 class FloatRect;
 class History;
+class IdleRequestCallback;
 class Location;
 class MediaQueryList;
 class Navigator;
 class Node;
 class NodeList;
 class Page;
 class PageConsoleClient;
 class Performance;
 class PostMessageTimer;
 class RequestAnimationFrameCallback;
+class RequestIdleCallback;
 class ScheduledAction;
 class Screen;
 class Storage;
 class StyleMedia;
 class VisualViewport;
@@ -85,16 +89,27 @@
 #if ENABLE(DEVICE_ORIENTATION)
 class DeviceMotionController;
 class DeviceOrientationController;
 #endif
 
+struct IdleRequestOptions;
 struct ImageBitmapOptions;
 struct WindowFeatures;
 
 enum SetLocationLocking { LockHistoryBasedOnGestureState, LockHistoryAndBackForwardList };
 enum class IncludeTargetOrigin { No, Yes };
 
+struct WindowPostMessageOptions : public PostMessageOptions {
+    WindowPostMessageOptions() = default;
+    WindowPostMessageOptions(String&& targetOrigin, Vector<JSC::Strong<JSC::JSObject>>&& transfer)
+        : PostMessageOptions(WTFMove(transfer))
+        , targetOrigin(WTFMove(targetOrigin))
+    { }
+
+    String targetOrigin { "/"_s };
+};
+
 // FIXME: Rename DOMWindow to LocalWindow and AbstractDOMWindow to DOMWindow.
 class DOMWindow final
     : public AbstractDOMWindow
     , public CanMakeWeakPtr<DOMWindow>
     , public ContextDestructionObserver
@@ -117,23 +132,23 @@
 
     class Observer {
     public:
         virtual ~Observer() { }
 
-        virtual void suspendForPageCache() { }
-        virtual void resumeFromPageCache() { }
+        virtual void suspendForBackForwardCache() { }
+        virtual void resumeFromBackForwardCache() { }
         virtual void willDestroyGlobalObjectInCachedFrame() { }
         virtual void willDestroyGlobalObjectInFrame() { }
         virtual void willDetachGlobalObjectFromFrame() { }
     };
 
     void registerObserver(Observer&);
     void unregisterObserver(Observer&);
 
     void resetUnlessSuspendedForDocumentSuspension();
-    void suspendForPageCache();
-    void resumeFromPageCache();
+    void suspendForBackForwardCache();
+    void resumeFromBackForwardCache();
 
     WEBCORE_EXPORT Frame* frame() const final;
 
     RefPtr<MediaQueryList> matchMedia(const String&);
 
@@ -160,11 +175,18 @@
     BarProp& toolbar();
     WEBCORE_EXPORT Navigator& navigator();
     Navigator* optionalNavigator() const { return m_navigator.get(); }
     Navigator& clientInformation() { return navigator(); }
 
-    Location& location();
+    WEBCORE_EXPORT static void overrideTransientActivationDurationForTesting(Optional<Seconds>&&);
+    void setLastActivationTimestamp(MonotonicTime lastActivationTimestamp) { m_lastActivationTimestamp = lastActivationTimestamp; }
+    MonotonicTime lastActivationTimestamp() const { return m_lastActivationTimestamp; }
+    void notifyActivated(MonotonicTime);
+    bool hasTransientActivation() const;
+    bool consumeTransientActivation();
+
+    WEBCORE_EXPORT Location& location();
     void setLocation(DOMWindow& activeWindow, const URL& completedURL, SetLocationLocking = LockHistoryBasedOnGestureState);
 
     DOMSelection* getSelection();
 
     Element* frameElement() const;
@@ -182,11 +204,11 @@
     void showModalDialog(const String& urlString, const String& dialogFeaturesString, DOMWindow& activeWindow, DOMWindow& firstWindow, const WTF::Function<void(DOMWindow&)>& prepareDialogFunction);
 
     void prewarmLocalStorageIfNecessary();
 
     void alert(const String& message = emptyString());
-    bool confirm(const String& message);
+    bool confirmForBindings(const String& message);
     String prompt(const String& message, const String& defaultValue);
 
     bool find(const String&, bool caseSensitive, bool backwards, bool wrap, bool wholeWord, bool searchInFrames, bool showDialog) const;
 
     bool offscreenBuffering() const;
@@ -218,10 +240,11 @@
     void disownOpener();
     WindowProxy* parent() const;
     WindowProxy* top() const;
 
     String origin() const;
+    SecurityOrigin* securityOrigin() const;
 
     // DOM Level 2 AbstractView Interface
 
     WEBCORE_EXPORT Document* document() const;
 
@@ -241,15 +264,20 @@
     RefPtr<WebKitPoint> webkitConvertPointFromPageToNode(Node*, const WebKitPoint*) const;
     RefPtr<WebKitPoint> webkitConvertPointFromNodeToPage(Node*, const WebKitPoint*) const;
 
     PageConsoleClient* console() const;
 
-    void printErrorMessage(const String&);
+    void printErrorMessage(const String&) const;
 
     String crossDomainAccessErrorMessage(const DOMWindow& activeWindow, IncludeTargetOrigin);
 
-    ExceptionOr<void> postMessage(JSC::ExecState&, DOMWindow& incumbentWindow, JSC::JSValue message, const String& targetOrigin, Vector<JSC::Strong<JSC::JSObject>>&&);
+    ExceptionOr<void> postMessage(JSC::JSGlobalObject&, DOMWindow& incumbentWindow, JSC::JSValue message, WindowPostMessageOptions&&);
+    ExceptionOr<void> postMessage(JSC::JSGlobalObject& globalObject, DOMWindow& incumbentWindow, JSC::JSValue message, String&& targetOrigin, Vector<JSC::Strong<JSC::JSObject>>&& transfer)
+    {
+        return postMessage(globalObject, incumbentWindow, message, WindowPostMessageOptions { WTFMove(targetOrigin), WTFMove(transfer) });
+    }
+
     void postMessageTimerFired(PostMessageTimer&);
 
     void languagesChanged();
 
     void scrollBy(const ScrollToOptions&) const;
@@ -264,19 +292,22 @@
     void resizeTo(float width, float height) const;
 
     VisualViewport& visualViewport();
 
     // Timers
-    ExceptionOr<int> setTimeout(JSC::ExecState&, std::unique_ptr<ScheduledAction>, int timeout, Vector<JSC::Strong<JSC::Unknown>>&& arguments);
+    ExceptionOr<int> setTimeout(JSC::JSGlobalObject&, std::unique_ptr<ScheduledAction>, int timeout, Vector<JSC::Strong<JSC::Unknown>>&& arguments);
     void clearTimeout(int timeoutId);
-    ExceptionOr<int> setInterval(JSC::ExecState&, std::unique_ptr<ScheduledAction>, int timeout, Vector<JSC::Strong<JSC::Unknown>>&& arguments);
+    ExceptionOr<int> setInterval(JSC::JSGlobalObject&, std::unique_ptr<ScheduledAction>, int timeout, Vector<JSC::Strong<JSC::Unknown>>&& arguments);
     void clearInterval(int timeoutId);
 
     int requestAnimationFrame(Ref<RequestAnimationFrameCallback>&&);
     int webkitRequestAnimationFrame(Ref<RequestAnimationFrameCallback>&&);
     void cancelAnimationFrame(int id);
 
+    int requestIdleCallback(Ref<IdleRequestCallback>&&, const IdleRequestOptions&);
+    void cancelIdleCallback(int id);
+
     // ImageBitmap
     void createImageBitmap(ImageBitmap::Source&&, ImageBitmapOptions&&, ImageBitmap::Promise&&);
     void createImageBitmap(ImageBitmap::Source&&, int sx, int sy, int sw, int sh, ImageBitmapOptions&&, ImageBitmap::Promise&&);
 
     // Secure Contexts
@@ -439,10 +470,16 @@
 
     RefPtr<CustomElementRegistry> m_customElementRegistry;
 
     mutable RefPtr<Performance> m_performance;
 
+    // For the purpose of tracking user activation, each Window W has a last activation timestamp. This is a number indicating the last time W got
+    // an activation notification. It corresponds to a DOMHighResTimeStamp value except for two cases: positive infinity indicates that W has never
+    // been activated, while negative infinity indicates that a user activation-gated API has consumed the last user activation of W. The initial
+    // value is positive infinity.
+    MonotonicTime m_lastActivationTimestamp { MonotonicTime::infinity() };
+
 #if ENABLE(USER_MESSAGE_HANDLERS)
     mutable RefPtr<WebKitNamespace> m_webkitNamespace;
 #endif
 };
 

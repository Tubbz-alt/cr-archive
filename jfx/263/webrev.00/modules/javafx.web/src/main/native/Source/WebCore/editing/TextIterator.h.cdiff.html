<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/editing/TextIterator.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TextIterator.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TypingCommand.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/TextIterator.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,10 ***</span>
<span class="line-new-header">--- 26,11 ---</span>
  #pragma once
  
  // FIXME: Move each iterator class into a separate header file.
  
  #include &quot;FindOptions.h&quot;
<span class="line-added">+ #include &quot;LineLayoutTraversal.h&quot;</span>
  #include &quot;Range.h&quot;
  #include &quot;TextIteratorBehavior.h&quot;
  #include &lt;wtf/Vector.h&gt;
  #include &lt;wtf/text/StringView.h&gt;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 165,33 ***</span>
      TextIteratorCopyableText m_copyableText;
      StringView m_text;
  
      // Used when there is still some pending text from the current node; when these are false and null, we go back to normal iterating.
      Node* m_nodeForAdditionalNewline { nullptr };
<span class="line-modified">!     InlineTextBox* m_textBox { nullptr };</span>
  
      // Used when iterating over :first-letter text to save pointer to remaining text box.
<span class="line-modified">!     InlineTextBox* m_remainingTextBox { nullptr };</span>
  
      // Used to point to RenderText object for :first-letter.
      RenderText* m_firstLetterText { nullptr };
  
      // Used to do the whitespace collapsing logic.
      Text* m_lastTextNode { nullptr };
      bool m_lastTextNodeEndedWithCollapsedSpace { false };
      UChar m_lastCharacter { 0 };
  
<span class="line-removed">-     // Used to do simple line layout run logic.</span>
<span class="line-removed">-     bool m_nextRunNeedsWhitespace { false };</span>
<span class="line-removed">-     unsigned m_accumulatedSimpleTextLengthInFlow { 0 };</span>
<span class="line-removed">-     Text* m_previousSimpleTextNodeInFlow { nullptr };</span>
<span class="line-removed">-     std::unique_ptr&lt;SimpleLineLayout::RunResolver&gt; m_flowRunResolverCache;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Used when text boxes are out of order (Hebrew/Arabic with embedded LTR text)</span>
<span class="line-removed">-     Vector&lt;InlineTextBox*&gt; m_sortedTextBoxes;</span>
<span class="line-removed">-     size_t m_sortedTextBoxesPosition { 0 };</span>
<span class="line-removed">- </span>
      // Used when deciding whether to emit a &quot;positioning&quot; (e.g. newline) before any other content
      bool m_hasEmitted { false };
  
      // Used when deciding text fragment created by :first-letter should be looked into.
      bool m_handledFirstLetter { false };
<span class="line-new-header">--- 166,23 ---</span>
      TextIteratorCopyableText m_copyableText;
      StringView m_text;
  
      // Used when there is still some pending text from the current node; when these are false and null, we go back to normal iterating.
      Node* m_nodeForAdditionalNewline { nullptr };
<span class="line-modified">!     LineLayoutTraversal::TextBoxIterator m_textBox;</span>
  
      // Used when iterating over :first-letter text to save pointer to remaining text box.
<span class="line-modified">!     LineLayoutTraversal::TextBoxIterator m_remainingTextBox;</span>
  
      // Used to point to RenderText object for :first-letter.
      RenderText* m_firstLetterText { nullptr };
  
      // Used to do the whitespace collapsing logic.
      Text* m_lastTextNode { nullptr };
      bool m_lastTextNodeEndedWithCollapsedSpace { false };
      UChar m_lastCharacter { 0 };
  
      // Used when deciding whether to emit a &quot;positioning&quot; (e.g. newline) before any other content
      bool m_hasEmitted { false };
  
      // Used when deciding text fragment created by :first-letter should be looked into.
      bool m_handledFirstLetter { false };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 255,11 ***</span>
  
  // Builds on the text iterator, adding a character position so we can walk one
  // character at a time, or faster, as needed. Useful for searching.
  class CharacterIterator {
  public:
<span class="line-modified">!     explicit CharacterIterator(const Range&amp;, TextIteratorBehavior = TextIteratorDefaultBehavior);</span>
      WEBCORE_EXPORT explicit CharacterIterator(Position start, Position end, TextIteratorBehavior = TextIteratorDefaultBehavior);
  
      bool atEnd() const { return m_underlyingIterator.atEnd(); }
      WEBCORE_EXPORT void advance(int numCharacters);
  
<span class="line-new-header">--- 246,11 ---</span>
  
  // Builds on the text iterator, adding a character position so we can walk one
  // character at a time, or faster, as needed. Useful for searching.
  class CharacterIterator {
  public:
<span class="line-modified">!     WEBCORE_EXPORT explicit CharacterIterator(const Range&amp;, TextIteratorBehavior = TextIteratorDefaultBehavior);</span>
      WEBCORE_EXPORT explicit CharacterIterator(Position start, Position end, TextIteratorBehavior = TextIteratorDefaultBehavior);
  
      bool atEnd() const { return m_underlyingIterator.atEnd(); }
      WEBCORE_EXPORT void advance(int numCharacters);
  
</pre>
<center><a href="TextIterator.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TypingCommand.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
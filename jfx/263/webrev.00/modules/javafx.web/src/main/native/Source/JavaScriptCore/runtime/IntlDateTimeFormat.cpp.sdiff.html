<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlDateTimeFormat.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IntlCollatorPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IntlDateTimeFormat.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlDateTimeFormat.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 2015 Andy VanWagoner (andy@vanwagoner.family)
<span class="line-modified">   3  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  15  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  16  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
</pre>
<hr />
<pre>
  69 void IntlDateTimeFormat::UFieldPositionIteratorDeleter::operator()(UFieldPositionIterator* iterator) const
  70 {
  71     if (iterator)
  72         ufieldpositer_close(iterator);
  73 }
  74 #endif
  75 
  76 IntlDateTimeFormat* IntlDateTimeFormat::create(VM&amp; vm, Structure* structure)
  77 {
  78     IntlDateTimeFormat* format = new (NotNull, allocateCell&lt;IntlDateTimeFormat&gt;(vm.heap)) IntlDateTimeFormat(vm, structure);
  79     format-&gt;finishCreation(vm);
  80     return format;
  81 }
  82 
  83 Structure* IntlDateTimeFormat::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  84 {
  85     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
  86 }
  87 
  88 IntlDateTimeFormat::IntlDateTimeFormat(VM&amp; vm, Structure* structure)
<span class="line-modified">  89     : JSDestructibleObject(vm, structure)</span>
  90 {
  91 }
  92 
  93 void IntlDateTimeFormat::finishCreation(VM&amp; vm)
  94 {
  95     Base::finishCreation(vm);
  96     ASSERT(inherits(vm, info()));
  97 }
  98 
<span class="line-removed">  99 void IntlDateTimeFormat::destroy(JSCell* cell)</span>
<span class="line-removed"> 100 {</span>
<span class="line-removed"> 101     static_cast&lt;IntlDateTimeFormat*&gt;(cell)-&gt;IntlDateTimeFormat::~IntlDateTimeFormat();</span>
<span class="line-removed"> 102 }</span>
<span class="line-removed"> 103 </span>
 104 void IntlDateTimeFormat::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 105 {
 106     IntlDateTimeFormat* thisObject = jsCast&lt;IntlDateTimeFormat*&gt;(cell);
 107     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 108 
 109     Base::visitChildren(thisObject, visitor);
 110 
 111     visitor.append(thisObject-&gt;m_boundFormat);
 112 }
 113 
 114 void IntlDateTimeFormat::setBoundFormat(VM&amp; vm, JSBoundFunction* format)
 115 {
 116     m_boundFormat.set(vm, this, format);
 117 }
 118 
 119 static String defaultTimeZone()
 120 {
 121     // 6.4.3 DefaultTimeZone () (ECMA-402 2.0)
 122     // The DefaultTimeZone abstract operation returns a String value representing the valid (6.4.1) and canonicalized (6.4.2) time zone name for the host environmentâ€™s current time zone.
 123 
</pre>
<hr />
<pre>
 221         uenum_close(calendars);
 222         break;
 223     }
 224     case indexOfExtensionKeyNu:
 225         keyLocaleData = numberingSystemsForLocale(locale);
 226         break;
 227     case indexOfExtensionKeyHc:
 228         // Null default so we know to use &#39;j&#39; in pattern.
 229         keyLocaleData.append(String());
 230         keyLocaleData.append(&quot;h11&quot;_s);
 231         keyLocaleData.append(&quot;h12&quot;_s);
 232         keyLocaleData.append(&quot;h23&quot;_s);
 233         keyLocaleData.append(&quot;h24&quot;_s);
 234         break;
 235     default:
 236         ASSERT_NOT_REACHED();
 237     }
 238     return keyLocaleData;
 239 }
 240 
<span class="line-modified"> 241 static JSObject* toDateTimeOptionsAnyDate(ExecState&amp; exec, JSValue originalOptions)</span>
 242 {
 243     // 12.1.1 ToDateTimeOptions abstract operation (ECMA-402 2.0)
<span class="line-modified"> 244     VM&amp; vm = exec.vm();</span>
 245     auto scope = DECLARE_THROW_SCOPE(vm);
 246 
 247     // 1. If options is undefined, then let options be null, else let options be ToObject(options).
 248     // 2. ReturnIfAbrupt(options).
 249     // 3. Let options be ObjectCreate(options).
 250     JSObject* options;
 251     if (originalOptions.isUndefined())
<span class="line-modified"> 252         options = constructEmptyObject(&amp;exec, exec.lexicalGlobalObject()-&gt;nullPrototypeObjectStructure());</span>
 253     else {
<span class="line-modified"> 254         JSObject* originalToObject = originalOptions.toObject(&amp;exec);</span>
 255         RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 256         options = constructEmptyObject(&amp;exec, originalToObject);</span>
 257     }
 258 
 259     // 4. Let needDefaults be true.
 260     bool needDefaults = true;
 261 
 262     // 5. If required is &quot;date&quot; or &quot;any&quot;,
 263     // Always &quot;any&quot;.
 264 
 265     // a. For each of the property names &quot;weekday&quot;, &quot;year&quot;, &quot;month&quot;, &quot;day&quot;:
 266     // i. Let prop be the property name.
 267     // ii. Let value be Get(options, prop).
 268     // iii. ReturnIfAbrupt(value).
 269     // iv. If value is not undefined, then let needDefaults be false.
<span class="line-modified"> 270     JSValue weekday = options-&gt;get(&amp;exec, vm.propertyNames-&gt;weekday);</span>
 271     RETURN_IF_EXCEPTION(scope, nullptr);
 272     if (!weekday.isUndefined())
 273         needDefaults = false;
 274 
<span class="line-modified"> 275     JSValue year = options-&gt;get(&amp;exec, vm.propertyNames-&gt;year);</span>
 276     RETURN_IF_EXCEPTION(scope, nullptr);
 277     if (!year.isUndefined())
 278         needDefaults = false;
 279 
<span class="line-modified"> 280     JSValue month = options-&gt;get(&amp;exec, vm.propertyNames-&gt;month);</span>
 281     RETURN_IF_EXCEPTION(scope, nullptr);
 282     if (!month.isUndefined())
 283         needDefaults = false;
 284 
<span class="line-modified"> 285     JSValue day = options-&gt;get(&amp;exec, vm.propertyNames-&gt;day);</span>
 286     RETURN_IF_EXCEPTION(scope, nullptr);
 287     if (!day.isUndefined())
 288         needDefaults = false;
 289 
 290     // 6. If required is &quot;time&quot; or &quot;any&quot;,
 291     // Always &quot;any&quot;.
 292 
 293     // a. For each of the property names &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;:
 294     // i. Let prop be the property name.
 295     // ii. Let value be Get(options, prop).
 296     // iii. ReturnIfAbrupt(value).
 297     // iv. If value is not undefined, then let needDefaults be false.
<span class="line-modified"> 298     JSValue hour = options-&gt;get(&amp;exec, vm.propertyNames-&gt;hour);</span>
 299     RETURN_IF_EXCEPTION(scope, nullptr);
 300     if (!hour.isUndefined())
 301         needDefaults = false;
 302 
<span class="line-modified"> 303     JSValue minute = options-&gt;get(&amp;exec, vm.propertyNames-&gt;minute);</span>
 304     RETURN_IF_EXCEPTION(scope, nullptr);
 305     if (!minute.isUndefined())
 306         needDefaults = false;
 307 
<span class="line-modified"> 308     JSValue second = options-&gt;get(&amp;exec, vm.propertyNames-&gt;second);</span>
 309     RETURN_IF_EXCEPTION(scope, nullptr);
 310     if (!second.isUndefined())
 311         needDefaults = false;
 312 
 313     // 7. If needDefaults is true and defaults is either &quot;date&quot; or &quot;all&quot;, then
 314     // Defaults is always &quot;date&quot;.
 315     if (needDefaults) {
 316         // a. For each of the property names &quot;year&quot;, &quot;month&quot;, &quot;day&quot;:
 317         // i. Let status be CreateDatePropertyOrThrow(options, prop, &quot;numeric&quot;).
 318         // ii. ReturnIfAbrupt(status).
 319         JSString* numeric = jsNontrivialString(vm, &quot;numeric&quot;_s);
 320 
 321         options-&gt;putDirect(vm, vm.propertyNames-&gt;year, numeric);
 322         RETURN_IF_EXCEPTION(scope, nullptr);
 323 
 324         options-&gt;putDirect(vm, vm.propertyNames-&gt;month, numeric);
 325         RETURN_IF_EXCEPTION(scope, nullptr);
 326 
 327         options-&gt;putDirect(vm, vm.propertyNames-&gt;day, numeric);
 328         RETURN_IF_EXCEPTION(scope, nullptr);
</pre>
<hr />
<pre>
 424                 m_minute = Minute::TwoDigit;
 425             break;
 426         case &#39;s&#39;:
 427             if (count == 1)
 428                 m_second = Second::Numeric;
 429             else if (count == 2)
 430                 m_second = Second::TwoDigit;
 431             break;
 432         case &#39;z&#39;:
 433         case &#39;v&#39;:
 434         case &#39;V&#39;:
 435             if (count == 1)
 436                 m_timeZoneName = TimeZoneName::Short;
 437             else if (count == 4)
 438                 m_timeZoneName = TimeZoneName::Long;
 439             break;
 440         }
 441     }
 442 }
 443 
<span class="line-modified"> 444 void IntlDateTimeFormat::initializeDateTimeFormat(ExecState&amp; exec, JSValue locales, JSValue originalOptions)</span>
 445 {
<span class="line-modified"> 446     VM&amp; vm = exec.vm();</span>
 447     auto scope = DECLARE_THROW_SCOPE(vm);
 448 
 449     // 12.1.1 InitializeDateTimeFormat (dateTimeFormat, locales, options) (ECMA-402)
 450     // https://tc39.github.io/ecma402/#sec-initializedatetimeformat
 451 
<span class="line-modified"> 452     Vector&lt;String&gt; requestedLocales = canonicalizeLocaleList(exec, locales);</span>
 453     RETURN_IF_EXCEPTION(scope, void());
 454 
<span class="line-modified"> 455     JSObject* options = IntlDTFInternal::toDateTimeOptionsAnyDate(exec, originalOptions);</span>
 456     RETURN_IF_EXCEPTION(scope, void());
 457 
 458     HashMap&lt;String, String&gt; opt;
 459 
<span class="line-modified"> 460     String localeMatcher = intlStringOption(exec, options, vm.propertyNames-&gt;localeMatcher, { &quot;lookup&quot;, &quot;best fit&quot; }, &quot;localeMatcher must be either \&quot;lookup\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);</span>
 461     RETURN_IF_EXCEPTION(scope, void());
 462     opt.add(vm.propertyNames-&gt;localeMatcher.string(), localeMatcher);
 463 
 464     bool isHour12Undefined;
<span class="line-modified"> 465     bool hour12 = intlBooleanOption(exec, options, vm.propertyNames-&gt;hour12, isHour12Undefined);</span>
 466     RETURN_IF_EXCEPTION(scope, void());
 467 
<span class="line-modified"> 468     String hourCycle = intlStringOption(exec, options, vm.propertyNames-&gt;hourCycle, { &quot;h11&quot;, &quot;h12&quot;, &quot;h23&quot;, &quot;h24&quot; }, &quot;hourCycle must be \&quot;h11\&quot;, \&quot;h12\&quot;, \&quot;h23\&quot;, or \&quot;h24\&quot;&quot;, nullptr);</span>
 469     RETURN_IF_EXCEPTION(scope, void());
 470     if (isHour12Undefined) {
 471         // Set hour12 here to simplify hour logic later.
 472         hour12 = (hourCycle == &quot;h11&quot; || hourCycle == &quot;h12&quot;);
 473         if (!hourCycle.isNull())
 474             opt.add(&quot;hc&quot;_s, hourCycle);
 475     } else
 476         opt.add(&quot;hc&quot;_s, String());
 477 
<span class="line-modified"> 478     const HashSet&lt;String&gt; availableLocales = exec.jsCallee()-&gt;globalObject(vm)-&gt;intlDateTimeFormatAvailableLocales();</span>
<span class="line-modified"> 479     HashMap&lt;String, String&gt; resolved = resolveLocale(exec, availableLocales, requestedLocales, opt, IntlDTFInternal::relevantExtensionKeys, WTF_ARRAY_LENGTH(IntlDTFInternal::relevantExtensionKeys), IntlDTFInternal::localeData);</span>
 480 
 481     m_locale = resolved.get(vm.propertyNames-&gt;locale.string());
 482     if (m_locale.isEmpty()) {
<span class="line-modified"> 483         throwTypeError(&amp;exec, scope, &quot;failed to initialize DateTimeFormat due to invalid locale&quot;_s);</span>
 484         return;
 485     }
 486 
 487     m_calendar = resolved.get(&quot;ca&quot;_s);
 488     if (m_calendar == &quot;gregorian&quot;)
 489         m_calendar = &quot;gregory&quot;_s;
 490     else if (m_calendar == &quot;islamicc&quot;)
 491         m_calendar = &quot;islamic-civil&quot;_s;
 492     else if (m_calendar == &quot;ethioaa&quot;)
 493         m_calendar = &quot;ethiopic-amete-alem&quot;_s;
 494 
 495     m_hourCycle = resolved.get(&quot;hc&quot;_s);
 496     m_numberingSystem = resolved.get(&quot;nu&quot;_s);
 497     String dataLocale = resolved.get(&quot;dataLocale&quot;_s);
 498 
<span class="line-modified"> 499     JSValue tzValue = options-&gt;get(&amp;exec, vm.propertyNames-&gt;timeZone);</span>
 500     RETURN_IF_EXCEPTION(scope, void());
 501     String tz;
 502     if (!tzValue.isUndefined()) {
<span class="line-modified"> 503         String originalTz = tzValue.toWTFString(&amp;exec);</span>
 504         RETURN_IF_EXCEPTION(scope, void());
 505         tz = canonicalizeTimeZoneName(originalTz);
 506         if (tz.isNull()) {
<span class="line-modified"> 507             throwRangeError(&amp;exec, scope, &quot;invalid time zone: &quot; + originalTz);</span>
 508             return;
 509         }
 510     } else
 511         tz = defaultTimeZone();
 512     m_timeZone = tz;
 513 
 514     StringBuilder skeletonBuilder;
 515     auto narrowShortLong = { &quot;narrow&quot;, &quot;short&quot;, &quot;long&quot; };
 516     auto twoDigitNumeric = { &quot;2-digit&quot;, &quot;numeric&quot; };
 517     auto twoDigitNumericNarrowShortLong = { &quot;2-digit&quot;, &quot;numeric&quot;, &quot;narrow&quot;, &quot;short&quot;, &quot;long&quot; };
 518     auto shortLong = { &quot;short&quot;, &quot;long&quot; };
 519 
<span class="line-modified"> 520     String weekday = intlStringOption(exec, options, vm.propertyNames-&gt;weekday, narrowShortLong, &quot;weekday must be \&quot;narrow\&quot;, \&quot;short\&quot;, or \&quot;long\&quot;&quot;, nullptr);</span>
 521     RETURN_IF_EXCEPTION(scope, void());
 522     if (!weekday.isNull()) {
 523         if (weekday == &quot;narrow&quot;)
 524             skeletonBuilder.appendLiteral(&quot;EEEEE&quot;);
 525         else if (weekday == &quot;short&quot;)
 526             skeletonBuilder.appendLiteral(&quot;EEE&quot;);
 527         else if (weekday == &quot;long&quot;)
 528             skeletonBuilder.appendLiteral(&quot;EEEE&quot;);
 529     }
 530 
<span class="line-modified"> 531     String era = intlStringOption(exec, options, vm.propertyNames-&gt;era, narrowShortLong, &quot;era must be \&quot;narrow\&quot;, \&quot;short\&quot;, or \&quot;long\&quot;&quot;, nullptr);</span>
 532     RETURN_IF_EXCEPTION(scope, void());
 533     if (!era.isNull()) {
 534         if (era == &quot;narrow&quot;)
 535             skeletonBuilder.appendLiteral(&quot;GGGGG&quot;);
 536         else if (era == &quot;short&quot;)
 537             skeletonBuilder.appendLiteral(&quot;GGG&quot;);
 538         else if (era == &quot;long&quot;)
 539             skeletonBuilder.appendLiteral(&quot;GGGG&quot;);
 540     }
 541 
<span class="line-modified"> 542     String year = intlStringOption(exec, options, vm.propertyNames-&gt;year, twoDigitNumeric, &quot;year must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
 543     RETURN_IF_EXCEPTION(scope, void());
 544     if (!year.isNull()) {
 545         if (year == &quot;2-digit&quot;)
 546             skeletonBuilder.appendLiteral(&quot;yy&quot;);
 547         else if (year == &quot;numeric&quot;)
 548             skeletonBuilder.append(&#39;y&#39;);
 549     }
 550 
<span class="line-modified"> 551     String month = intlStringOption(exec, options, vm.propertyNames-&gt;month, twoDigitNumericNarrowShortLong, &quot;month must be \&quot;2-digit\&quot;, \&quot;numeric\&quot;, \&quot;narrow\&quot;, \&quot;short\&quot;, or \&quot;long\&quot;&quot;, nullptr);</span>
 552     RETURN_IF_EXCEPTION(scope, void());
 553     if (!month.isNull()) {
 554         if (month == &quot;2-digit&quot;)
 555             skeletonBuilder.appendLiteral(&quot;MM&quot;);
 556         else if (month == &quot;numeric&quot;)
 557             skeletonBuilder.append(&#39;M&#39;);
 558         else if (month == &quot;narrow&quot;)
 559             skeletonBuilder.appendLiteral(&quot;MMMMM&quot;);
 560         else if (month == &quot;short&quot;)
 561             skeletonBuilder.appendLiteral(&quot;MMM&quot;);
 562         else if (month == &quot;long&quot;)
 563             skeletonBuilder.appendLiteral(&quot;MMMM&quot;);
 564     }
 565 
<span class="line-modified"> 566     String day = intlStringOption(exec, options, vm.propertyNames-&gt;day, twoDigitNumeric, &quot;day must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
 567     RETURN_IF_EXCEPTION(scope, void());
 568     if (!day.isNull()) {
 569         if (day == &quot;2-digit&quot;)
 570             skeletonBuilder.appendLiteral(&quot;dd&quot;);
 571         else if (day == &quot;numeric&quot;)
 572             skeletonBuilder.append(&#39;d&#39;);
 573     }
 574 
<span class="line-modified"> 575     String hour = intlStringOption(exec, options, vm.propertyNames-&gt;hour, twoDigitNumeric, &quot;hour must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
 576     RETURN_IF_EXCEPTION(scope, void());
 577     if (hour == &quot;2-digit&quot;) {
 578         if (isHour12Undefined &amp;&amp; m_hourCycle.isNull())
 579             skeletonBuilder.appendLiteral(&quot;jj&quot;);
 580         else if (hour12)
 581             skeletonBuilder.appendLiteral(&quot;hh&quot;);
 582         else
 583             skeletonBuilder.appendLiteral(&quot;HH&quot;);
 584     } else if (hour == &quot;numeric&quot;) {
 585         if (isHour12Undefined &amp;&amp; m_hourCycle.isNull())
 586             skeletonBuilder.append(&#39;j&#39;);
 587         else if (hour12)
 588             skeletonBuilder.append(&#39;h&#39;);
 589         else
 590             skeletonBuilder.append(&#39;H&#39;);
 591     } else
 592         m_hourCycle = String();
 593 
<span class="line-modified"> 594     String minute = intlStringOption(exec, options, vm.propertyNames-&gt;minute, twoDigitNumeric, &quot;minute must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
 595     RETURN_IF_EXCEPTION(scope, void());
 596     if (!minute.isNull()) {
 597         if (minute == &quot;2-digit&quot;)
 598             skeletonBuilder.appendLiteral(&quot;mm&quot;);
 599         else if (minute == &quot;numeric&quot;)
 600             skeletonBuilder.append(&#39;m&#39;);
 601     }
 602 
<span class="line-modified"> 603     String second = intlStringOption(exec, options, vm.propertyNames-&gt;second, twoDigitNumeric, &quot;second must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
 604     RETURN_IF_EXCEPTION(scope, void());
 605     if (!second.isNull()) {
 606         if (second == &quot;2-digit&quot;)
 607             skeletonBuilder.appendLiteral(&quot;ss&quot;);
 608         else if (second == &quot;numeric&quot;)
 609             skeletonBuilder.append(&#39;s&#39;);
 610     }
 611 
<span class="line-modified"> 612     String timeZoneName = intlStringOption(exec, options, vm.propertyNames-&gt;timeZoneName, shortLong, &quot;timeZoneName must be \&quot;short\&quot; or \&quot;long\&quot;&quot;, nullptr);</span>
 613     RETURN_IF_EXCEPTION(scope, void());
 614     if (!timeZoneName.isNull()) {
 615         if (timeZoneName == &quot;short&quot;)
 616             skeletonBuilder.append(&#39;z&#39;);
 617         else if (timeZoneName == &quot;long&quot;)
 618             skeletonBuilder.appendLiteral(&quot;zzzz&quot;);
 619     }
 620 
<span class="line-modified"> 621     intlStringOption(exec, options, vm.propertyNames-&gt;formatMatcher, { &quot;basic&quot;, &quot;best fit&quot; }, &quot;formatMatcher must be either \&quot;basic\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);</span>
 622     RETURN_IF_EXCEPTION(scope, void());
 623 
 624     // Always use ICU date format generator, rather than our own pattern list and matcher.
 625     UErrorCode status = U_ZERO_ERROR;
 626     UDateTimePatternGenerator* generator = udatpg_open(dataLocale.utf8().data(), &amp;status);
 627     if (U_FAILURE(status)) {
<span class="line-modified"> 628         throwTypeError(&amp;exec, scope, &quot;failed to initialize DateTimeFormat&quot;_s);</span>
 629         return;
 630     }
 631 
 632     String skeleton = skeletonBuilder.toString();
 633     StringView skeletonView(skeleton);
 634     Vector&lt;UChar, 32&gt; patternBuffer(32);
 635     status = U_ZERO_ERROR;
 636     auto patternLength = udatpg_getBestPatternWithOptions(generator, skeletonView.upconvertedCharacters(), skeletonView.length(), UDATPG_MATCH_HOUR_FIELD_LENGTH, patternBuffer.data(), patternBuffer.size(), &amp;status);
 637     if (status == U_BUFFER_OVERFLOW_ERROR) {
 638         status = U_ZERO_ERROR;
 639         patternBuffer.grow(patternLength);
 640         udatpg_getBestPattern(generator, skeletonView.upconvertedCharacters(), skeletonView.length(), patternBuffer.data(), patternLength, &amp;status);
 641     }
 642     udatpg_close(generator);
 643     if (U_FAILURE(status)) {
<span class="line-modified"> 644         throwTypeError(&amp;exec, scope, &quot;failed to initialize DateTimeFormat&quot;_s);</span>
 645         return;
 646     }
 647 
 648     // Enforce our hourCycle, replacing hour characters in pattern.
 649     if (!m_hourCycle.isNull()) {
 650         UChar hour = &#39;H&#39;;
 651         if (m_hourCycle == &quot;h11&quot;)
 652             hour = &#39;K&#39;;
 653         else if (m_hourCycle == &quot;h12&quot;)
 654             hour = &#39;h&#39;;
 655         else if (m_hourCycle == &quot;h24&quot;)
 656             hour = &#39;k&#39;;
 657 
 658         bool isEscaped = false;
 659         bool hasHour = false;
 660         for (auto i = 0; i &lt; patternLength; ++i) {
 661             UChar c = patternBuffer[i];
 662             if (c == &#39;\&#39;&#39;)
 663                 isEscaped = !isEscaped;
 664             else if (!isEscaped &amp;&amp; (c == &#39;h&#39; || c == &#39;H&#39; || c == &#39;k&#39; || c == &#39;K&#39;)) {
 665                 patternBuffer[i] = hour;
 666                 hasHour = true;
 667             }
 668         }
 669         if (!hasHour)
 670             m_hourCycle = String();
 671     }
 672 
 673     StringView pattern(patternBuffer.data(), patternLength);
 674     setFormatsFromPattern(pattern);
 675 
 676     status = U_ZERO_ERROR;
 677     StringView timeZoneView(m_timeZone);
 678     m_dateFormat = std::unique_ptr&lt;UDateFormat, UDateFormatDeleter&gt;(udat_open(UDAT_PATTERN, UDAT_PATTERN, m_locale.utf8().data(), timeZoneView.upconvertedCharacters(), timeZoneView.length(), pattern.upconvertedCharacters(), pattern.length(), &amp;status));
 679     if (U_FAILURE(status)) {
<span class="line-modified"> 680         throwTypeError(&amp;exec, scope, &quot;failed to initialize DateTimeFormat&quot;_s);</span>
 681         return;
 682     }
 683 
 684     // Gregorian calendar should be used from the beginning of ECMAScript time.
 685     // Failure here means unsupported calendar, and can safely be ignored.
 686     UCalendar* cal = const_cast&lt;UCalendar*&gt;(udat_getCalendar(m_dateFormat.get()));
 687     ucal_setGregorianChange(cal, minECMAScriptTime, &amp;status);
 688 
 689     m_initializedDateTimeFormat = true;
 690 }
 691 
 692 ASCIILiteral IntlDateTimeFormat::weekdayString(Weekday weekday)
 693 {
 694     switch (weekday) {
 695     case Weekday::Narrow:
 696         return &quot;narrow&quot;_s;
 697     case Weekday::Short:
 698         return &quot;short&quot;_s;
 699     case Weekday::Long:
 700         return &quot;long&quot;_s;
</pre>
<hr />
<pre>
 817     }
 818     ASSERT_NOT_REACHED();
 819     return ASCIILiteral::null();
 820 }
 821 
 822 ASCIILiteral IntlDateTimeFormat::timeZoneNameString(TimeZoneName timeZoneName)
 823 {
 824     switch (timeZoneName) {
 825     case TimeZoneName::Short:
 826         return &quot;short&quot;_s;
 827     case TimeZoneName::Long:
 828         return &quot;long&quot;_s;
 829     case TimeZoneName::None:
 830         ASSERT_NOT_REACHED();
 831         return ASCIILiteral::null();
 832     }
 833     ASSERT_NOT_REACHED();
 834     return ASCIILiteral::null();
 835 }
 836 
<span class="line-modified"> 837 JSObject* IntlDateTimeFormat::resolvedOptions(ExecState&amp; exec)</span>
 838 {
<span class="line-modified"> 839     VM&amp; vm = exec.vm();</span>
 840     auto scope = DECLARE_THROW_SCOPE(vm);
 841 
 842     // 12.3.5 Intl.DateTimeFormat.prototype.resolvedOptions() (ECMA-402 2.0)
 843     // The function returns a new object whose properties and attributes are set as if constructed by an object literal assigning to each of the following properties the value of the corresponding internal slot of this DateTimeFormat object (see 12.4): locale, calendar, numberingSystem, timeZone, hour12, weekday, era, year, month, day, hour, minute, second, and timeZoneName. Properties whose corresponding internal slots are not present are not assigned.
 844     // Note: In this version of the ECMAScript 2015 Internationalization API, the timeZone property will be the name of the default time zone if no timeZone property was provided in the options object provided to the Intl.DateTimeFormat constructor. The previous version left the timeZone property undefined in this case.
 845     if (!m_initializedDateTimeFormat) {
<span class="line-modified"> 846         initializeDateTimeFormat(exec, jsUndefined(), jsUndefined());</span>
 847         scope.assertNoException();
 848     }
 849 
<span class="line-modified"> 850     JSObject* options = constructEmptyObject(&amp;exec);</span>
 851     options-&gt;putDirect(vm, vm.propertyNames-&gt;locale, jsNontrivialString(vm, m_locale));
 852     options-&gt;putDirect(vm, vm.propertyNames-&gt;calendar, jsNontrivialString(vm, m_calendar));
 853     options-&gt;putDirect(vm, vm.propertyNames-&gt;numberingSystem, jsNontrivialString(vm, m_numberingSystem));
 854     options-&gt;putDirect(vm, vm.propertyNames-&gt;timeZone, jsNontrivialString(vm, m_timeZone));
 855 





 856     if (m_weekday != Weekday::None)
 857         options-&gt;putDirect(vm, vm.propertyNames-&gt;weekday, jsNontrivialString(vm, weekdayString(m_weekday)));
 858 
 859     if (m_era != Era::None)
 860         options-&gt;putDirect(vm, vm.propertyNames-&gt;era, jsNontrivialString(vm, eraString(m_era)));
 861 
 862     if (m_year != Year::None)
 863         options-&gt;putDirect(vm, vm.propertyNames-&gt;year, jsNontrivialString(vm, yearString(m_year)));
 864 
 865     if (m_month != Month::None)
 866         options-&gt;putDirect(vm, vm.propertyNames-&gt;month, jsNontrivialString(vm, monthString(m_month)));
 867 
 868     if (m_day != Day::None)
 869         options-&gt;putDirect(vm, vm.propertyNames-&gt;day, jsNontrivialString(vm, dayString(m_day)));
 870 
 871     if (m_hour != Hour::None)
 872         options-&gt;putDirect(vm, vm.propertyNames-&gt;hour, jsNontrivialString(vm, hourString(m_hour)));
 873 
<span class="line-removed"> 874     if (!m_hourCycle.isNull()) {</span>
<span class="line-removed"> 875         options-&gt;putDirect(vm, vm.propertyNames-&gt;hourCycle, jsNontrivialString(vm, m_hourCycle));</span>
<span class="line-removed"> 876         options-&gt;putDirect(vm, vm.propertyNames-&gt;hour12, jsBoolean(m_hourCycle == &quot;h11&quot; || m_hourCycle == &quot;h12&quot;));</span>
<span class="line-removed"> 877     }</span>
<span class="line-removed"> 878 </span>
 879     if (m_minute != Minute::None)
 880         options-&gt;putDirect(vm, vm.propertyNames-&gt;minute, jsNontrivialString(vm, minuteString(m_minute)));
 881 
 882     if (m_second != Second::None)
 883         options-&gt;putDirect(vm, vm.propertyNames-&gt;second, jsNontrivialString(vm, secondString(m_second)));
 884 
 885     if (m_timeZoneName != TimeZoneName::None)
 886         options-&gt;putDirect(vm, vm.propertyNames-&gt;timeZoneName, jsNontrivialString(vm, timeZoneNameString(m_timeZoneName)));
 887 
 888     return options;
 889 }
 890 
<span class="line-modified"> 891 JSValue IntlDateTimeFormat::format(ExecState&amp; exec, double value)</span>
 892 {
<span class="line-modified"> 893     VM&amp; vm = exec.vm();</span>
 894     auto scope = DECLARE_THROW_SCOPE(vm);
 895 
 896     // 12.3.4 FormatDateTime abstract operation (ECMA-402 2.0)
 897     if (!m_initializedDateTimeFormat) {
<span class="line-modified"> 898         initializeDateTimeFormat(exec, jsUndefined(), jsUndefined());</span>
 899         scope.assertNoException();
 900     }
 901 
 902     // 1. If x is not a finite Number, then throw a RangeError exception.
 903     if (!std::isfinite(value))
<span class="line-modified"> 904         return throwRangeError(&amp;exec, scope, &quot;date value is not finite in DateTimeFormat format()&quot;_s);</span>
 905 
 906     // Delegate remaining steps to ICU.
 907     UErrorCode status = U_ZERO_ERROR;
 908     Vector&lt;UChar, 32&gt; result(32);
 909     auto resultLength = udat_format(m_dateFormat.get(), value, result.data(), result.size(), nullptr, &amp;status);
 910     if (status == U_BUFFER_OVERFLOW_ERROR) {
 911         status = U_ZERO_ERROR;
 912         result.grow(resultLength);
 913         udat_format(m_dateFormat.get(), value, result.data(), resultLength, nullptr, &amp;status);
 914     }
 915     if (U_FAILURE(status))
<span class="line-modified"> 916         return throwTypeError(&amp;exec, scope, &quot;failed to format date value&quot;_s);</span>
 917 
 918     return jsString(vm, String(result.data(), resultLength));
 919 }
 920 
 921 #if JSC_ICU_HAS_UFIELDPOSITER
 922 ASCIILiteral IntlDateTimeFormat::partTypeString(UDateFormatField field)
 923 {
 924     switch (field) {
 925     case UDAT_ERA_FIELD:
 926         return &quot;era&quot;_s;
 927     case UDAT_YEAR_FIELD:
 928     case UDAT_YEAR_NAME_FIELD:
 929     case UDAT_EXTENDED_YEAR_FIELD:
 930         return &quot;year&quot;_s;
 931     case UDAT_MONTH_FIELD:
 932     case UDAT_STANDALONE_MONTH_FIELD:
 933         return &quot;month&quot;_s;
 934     case UDAT_DATE_FIELD:
 935         return &quot;day&quot;_s;
 936     case UDAT_HOUR_OF_DAY1_FIELD:
</pre>
<hr />
<pre>
 968     case UDAT_WEEK_OF_YEAR_FIELD:
 969     case UDAT_WEEK_OF_MONTH_FIELD:
 970     case UDAT_YEAR_WOY_FIELD:
 971     case UDAT_JULIAN_DAY_FIELD:
 972     case UDAT_MILLISECONDS_IN_DAY_FIELD:
 973     case UDAT_QUARTER_FIELD:
 974     case UDAT_STANDALONE_QUARTER_FIELD:
 975     case UDAT_RELATED_YEAR_FIELD:
 976     case UDAT_TIME_SEPARATOR_FIELD:
 977 #if U_ICU_VERSION_MAJOR_NUM &lt; 58 || !defined(U_HIDE_DEPRECATED_API)
 978     case UDAT_FIELD_COUNT:
 979 #endif
 980     // Any newer additions to the UDateFormatField enum should just be considered an &quot;unknown&quot; part.
 981     default:
 982         return &quot;unknown&quot;_s;
 983     }
 984     return &quot;unknown&quot;_s;
 985 }
 986 
 987 
<span class="line-modified"> 988 JSValue IntlDateTimeFormat::formatToParts(ExecState&amp; exec, double value)</span>
 989 {
<span class="line-modified"> 990     VM&amp; vm = exec.vm();</span>
 991     auto scope = DECLARE_THROW_SCOPE(vm);
 992 
 993     // 12.1.8 FormatDateTimeToParts (ECMA-402 4.0)
 994     // https://tc39.github.io/ecma402/#sec-formatdatetimetoparts
 995 
 996     if (!std::isfinite(value))
<span class="line-modified"> 997         return throwRangeError(&amp;exec, scope, &quot;date value is not finite in DateTimeFormat formatToParts()&quot;_s);</span>
 998 
 999     UErrorCode status = U_ZERO_ERROR;
1000     auto fields = std::unique_ptr&lt;UFieldPositionIterator, UFieldPositionIteratorDeleter&gt;(ufieldpositer_open(&amp;status));
1001     if (U_FAILURE(status))
<span class="line-modified">1002         return throwTypeError(&amp;exec, scope, &quot;failed to open field position iterator&quot;_s);</span>
1003 
1004     status = U_ZERO_ERROR;
1005     Vector&lt;UChar, 32&gt; result(32);
1006     auto resultLength = udat_formatForFields(m_dateFormat.get(), value, result.data(), result.size(), fields.get(), &amp;status);
1007     if (status == U_BUFFER_OVERFLOW_ERROR) {
1008         status = U_ZERO_ERROR;
1009         result.grow(resultLength);
1010         udat_formatForFields(m_dateFormat.get(), value, result.data(), resultLength, fields.get(), &amp;status);
1011     }
1012     if (U_FAILURE(status))
<span class="line-modified">1013         return throwTypeError(&amp;exec, scope, &quot;failed to format date value&quot;_s);</span>
1014 
<span class="line-removed">1015     JSGlobalObject* globalObject = exec.jsCallee()-&gt;globalObject(vm);</span>
1016     JSArray* parts = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), 0);
1017     if (!parts)
<span class="line-modified">1018         return throwOutOfMemoryError(&amp;exec, scope);</span>
1019 
1020     auto resultString = String(result.data(), resultLength);
1021     auto typePropertyName = Identifier::fromString(vm, &quot;type&quot;);
<span class="line-modified">1022     auto literalString = jsString(vm, &quot;literal&quot;_s);</span>
1023 
1024     int32_t previousEndIndex = 0;
1025     int32_t beginIndex = 0;
1026     int32_t endIndex = 0;
1027     while (previousEndIndex &lt; resultLength) {
1028         auto fieldType = ufieldpositer_next(fields.get(), &amp;beginIndex, &amp;endIndex);
1029         if (fieldType &lt; 0)
1030             beginIndex = endIndex = resultLength;
1031 
1032         if (previousEndIndex &lt; beginIndex) {
1033             auto value = jsString(vm, resultString.substring(previousEndIndex, beginIndex - previousEndIndex));
<span class="line-modified">1034             JSObject* part = constructEmptyObject(&amp;exec);</span>
1035             part-&gt;putDirect(vm, typePropertyName, literalString);
1036             part-&gt;putDirect(vm, vm.propertyNames-&gt;value, value);
<span class="line-modified">1037             parts-&gt;push(&amp;exec, part);</span>
1038             RETURN_IF_EXCEPTION(scope, { });
1039         }
1040         previousEndIndex = endIndex;
1041 
1042         if (fieldType &gt;= 0) {
1043             auto type = jsString(vm, partTypeString(UDateFormatField(fieldType)));
1044             auto value = jsString(vm, resultString.substring(beginIndex, endIndex - beginIndex));
<span class="line-modified">1045             JSObject* part = constructEmptyObject(&amp;exec);</span>
1046             part-&gt;putDirect(vm, typePropertyName, type);
1047             part-&gt;putDirect(vm, vm.propertyNames-&gt;value, value);
<span class="line-modified">1048             parts-&gt;push(&amp;exec, part);</span>
1049             RETURN_IF_EXCEPTION(scope, { });
1050         }
1051     }
1052 
1053 
1054     return parts;
1055 }
1056 #endif
1057 
1058 } // namespace JSC
1059 
1060 #endif // ENABLE(INTL)
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 2015 Andy VanWagoner (andy@vanwagoner.family)
<span class="line-modified">   3  * Copyright (C) 2016-2020 Apple Inc. All rights reserved.</span>
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  15  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  16  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
</pre>
<hr />
<pre>
  69 void IntlDateTimeFormat::UFieldPositionIteratorDeleter::operator()(UFieldPositionIterator* iterator) const
  70 {
  71     if (iterator)
  72         ufieldpositer_close(iterator);
  73 }
  74 #endif
  75 
  76 IntlDateTimeFormat* IntlDateTimeFormat::create(VM&amp; vm, Structure* structure)
  77 {
  78     IntlDateTimeFormat* format = new (NotNull, allocateCell&lt;IntlDateTimeFormat&gt;(vm.heap)) IntlDateTimeFormat(vm, structure);
  79     format-&gt;finishCreation(vm);
  80     return format;
  81 }
  82 
  83 Structure* IntlDateTimeFormat::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  84 {
  85     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
  86 }
  87 
  88 IntlDateTimeFormat::IntlDateTimeFormat(VM&amp; vm, Structure* structure)
<span class="line-modified">  89     : Base(vm, structure)</span>
  90 {
  91 }
  92 
  93 void IntlDateTimeFormat::finishCreation(VM&amp; vm)
  94 {
  95     Base::finishCreation(vm);
  96     ASSERT(inherits(vm, info()));
  97 }
  98 





  99 void IntlDateTimeFormat::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 100 {
 101     IntlDateTimeFormat* thisObject = jsCast&lt;IntlDateTimeFormat*&gt;(cell);
 102     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 103 
 104     Base::visitChildren(thisObject, visitor);
 105 
 106     visitor.append(thisObject-&gt;m_boundFormat);
 107 }
 108 
 109 void IntlDateTimeFormat::setBoundFormat(VM&amp; vm, JSBoundFunction* format)
 110 {
 111     m_boundFormat.set(vm, this, format);
 112 }
 113 
 114 static String defaultTimeZone()
 115 {
 116     // 6.4.3 DefaultTimeZone () (ECMA-402 2.0)
 117     // The DefaultTimeZone abstract operation returns a String value representing the valid (6.4.1) and canonicalized (6.4.2) time zone name for the host environmentâ€™s current time zone.
 118 
</pre>
<hr />
<pre>
 216         uenum_close(calendars);
 217         break;
 218     }
 219     case indexOfExtensionKeyNu:
 220         keyLocaleData = numberingSystemsForLocale(locale);
 221         break;
 222     case indexOfExtensionKeyHc:
 223         // Null default so we know to use &#39;j&#39; in pattern.
 224         keyLocaleData.append(String());
 225         keyLocaleData.append(&quot;h11&quot;_s);
 226         keyLocaleData.append(&quot;h12&quot;_s);
 227         keyLocaleData.append(&quot;h23&quot;_s);
 228         keyLocaleData.append(&quot;h24&quot;_s);
 229         break;
 230     default:
 231         ASSERT_NOT_REACHED();
 232     }
 233     return keyLocaleData;
 234 }
 235 
<span class="line-modified"> 236 static JSObject* toDateTimeOptionsAnyDate(JSGlobalObject* globalObject, JSValue originalOptions)</span>
 237 {
 238     // 12.1.1 ToDateTimeOptions abstract operation (ECMA-402 2.0)
<span class="line-modified"> 239     VM&amp; vm = globalObject-&gt;vm();</span>
 240     auto scope = DECLARE_THROW_SCOPE(vm);
 241 
 242     // 1. If options is undefined, then let options be null, else let options be ToObject(options).
 243     // 2. ReturnIfAbrupt(options).
 244     // 3. Let options be ObjectCreate(options).
 245     JSObject* options;
 246     if (originalOptions.isUndefined())
<span class="line-modified"> 247         options = constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure());</span>
 248     else {
<span class="line-modified"> 249         JSObject* originalToObject = originalOptions.toObject(globalObject);</span>
 250         RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 251         options = constructEmptyObject(globalObject, originalToObject);</span>
 252     }
 253 
 254     // 4. Let needDefaults be true.
 255     bool needDefaults = true;
 256 
 257     // 5. If required is &quot;date&quot; or &quot;any&quot;,
 258     // Always &quot;any&quot;.
 259 
 260     // a. For each of the property names &quot;weekday&quot;, &quot;year&quot;, &quot;month&quot;, &quot;day&quot;:
 261     // i. Let prop be the property name.
 262     // ii. Let value be Get(options, prop).
 263     // iii. ReturnIfAbrupt(value).
 264     // iv. If value is not undefined, then let needDefaults be false.
<span class="line-modified"> 265     JSValue weekday = options-&gt;get(globalObject, vm.propertyNames-&gt;weekday);</span>
 266     RETURN_IF_EXCEPTION(scope, nullptr);
 267     if (!weekday.isUndefined())
 268         needDefaults = false;
 269 
<span class="line-modified"> 270     JSValue year = options-&gt;get(globalObject, vm.propertyNames-&gt;year);</span>
 271     RETURN_IF_EXCEPTION(scope, nullptr);
 272     if (!year.isUndefined())
 273         needDefaults = false;
 274 
<span class="line-modified"> 275     JSValue month = options-&gt;get(globalObject, vm.propertyNames-&gt;month);</span>
 276     RETURN_IF_EXCEPTION(scope, nullptr);
 277     if (!month.isUndefined())
 278         needDefaults = false;
 279 
<span class="line-modified"> 280     JSValue day = options-&gt;get(globalObject, vm.propertyNames-&gt;day);</span>
 281     RETURN_IF_EXCEPTION(scope, nullptr);
 282     if (!day.isUndefined())
 283         needDefaults = false;
 284 
 285     // 6. If required is &quot;time&quot; or &quot;any&quot;,
 286     // Always &quot;any&quot;.
 287 
 288     // a. For each of the property names &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;:
 289     // i. Let prop be the property name.
 290     // ii. Let value be Get(options, prop).
 291     // iii. ReturnIfAbrupt(value).
 292     // iv. If value is not undefined, then let needDefaults be false.
<span class="line-modified"> 293     JSValue hour = options-&gt;get(globalObject, vm.propertyNames-&gt;hour);</span>
 294     RETURN_IF_EXCEPTION(scope, nullptr);
 295     if (!hour.isUndefined())
 296         needDefaults = false;
 297 
<span class="line-modified"> 298     JSValue minute = options-&gt;get(globalObject, vm.propertyNames-&gt;minute);</span>
 299     RETURN_IF_EXCEPTION(scope, nullptr);
 300     if (!minute.isUndefined())
 301         needDefaults = false;
 302 
<span class="line-modified"> 303     JSValue second = options-&gt;get(globalObject, vm.propertyNames-&gt;second);</span>
 304     RETURN_IF_EXCEPTION(scope, nullptr);
 305     if (!second.isUndefined())
 306         needDefaults = false;
 307 
 308     // 7. If needDefaults is true and defaults is either &quot;date&quot; or &quot;all&quot;, then
 309     // Defaults is always &quot;date&quot;.
 310     if (needDefaults) {
 311         // a. For each of the property names &quot;year&quot;, &quot;month&quot;, &quot;day&quot;:
 312         // i. Let status be CreateDatePropertyOrThrow(options, prop, &quot;numeric&quot;).
 313         // ii. ReturnIfAbrupt(status).
 314         JSString* numeric = jsNontrivialString(vm, &quot;numeric&quot;_s);
 315 
 316         options-&gt;putDirect(vm, vm.propertyNames-&gt;year, numeric);
 317         RETURN_IF_EXCEPTION(scope, nullptr);
 318 
 319         options-&gt;putDirect(vm, vm.propertyNames-&gt;month, numeric);
 320         RETURN_IF_EXCEPTION(scope, nullptr);
 321 
 322         options-&gt;putDirect(vm, vm.propertyNames-&gt;day, numeric);
 323         RETURN_IF_EXCEPTION(scope, nullptr);
</pre>
<hr />
<pre>
 419                 m_minute = Minute::TwoDigit;
 420             break;
 421         case &#39;s&#39;:
 422             if (count == 1)
 423                 m_second = Second::Numeric;
 424             else if (count == 2)
 425                 m_second = Second::TwoDigit;
 426             break;
 427         case &#39;z&#39;:
 428         case &#39;v&#39;:
 429         case &#39;V&#39;:
 430             if (count == 1)
 431                 m_timeZoneName = TimeZoneName::Short;
 432             else if (count == 4)
 433                 m_timeZoneName = TimeZoneName::Long;
 434             break;
 435         }
 436     }
 437 }
 438 
<span class="line-modified"> 439 void IntlDateTimeFormat::initializeDateTimeFormat(JSGlobalObject* globalObject, JSValue locales, JSValue originalOptions)</span>
 440 {
<span class="line-modified"> 441     VM&amp; vm = globalObject-&gt;vm();</span>
 442     auto scope = DECLARE_THROW_SCOPE(vm);
 443 
 444     // 12.1.1 InitializeDateTimeFormat (dateTimeFormat, locales, options) (ECMA-402)
 445     // https://tc39.github.io/ecma402/#sec-initializedatetimeformat
 446 
<span class="line-modified"> 447     Vector&lt;String&gt; requestedLocales = canonicalizeLocaleList(globalObject, locales);</span>
 448     RETURN_IF_EXCEPTION(scope, void());
 449 
<span class="line-modified"> 450     JSObject* options = IntlDTFInternal::toDateTimeOptionsAnyDate(globalObject, originalOptions);</span>
 451     RETURN_IF_EXCEPTION(scope, void());
 452 
 453     HashMap&lt;String, String&gt; opt;
 454 
<span class="line-modified"> 455     String localeMatcher = intlStringOption(globalObject, options, vm.propertyNames-&gt;localeMatcher, { &quot;lookup&quot;, &quot;best fit&quot; }, &quot;localeMatcher must be either \&quot;lookup\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);</span>
 456     RETURN_IF_EXCEPTION(scope, void());
 457     opt.add(vm.propertyNames-&gt;localeMatcher.string(), localeMatcher);
 458 
 459     bool isHour12Undefined;
<span class="line-modified"> 460     bool hour12 = intlBooleanOption(globalObject, options, vm.propertyNames-&gt;hour12, isHour12Undefined);</span>
 461     RETURN_IF_EXCEPTION(scope, void());
 462 
<span class="line-modified"> 463     String hourCycle = intlStringOption(globalObject, options, vm.propertyNames-&gt;hourCycle, { &quot;h11&quot;, &quot;h12&quot;, &quot;h23&quot;, &quot;h24&quot; }, &quot;hourCycle must be \&quot;h11\&quot;, \&quot;h12\&quot;, \&quot;h23\&quot;, or \&quot;h24\&quot;&quot;, nullptr);</span>
 464     RETURN_IF_EXCEPTION(scope, void());
 465     if (isHour12Undefined) {
 466         // Set hour12 here to simplify hour logic later.
 467         hour12 = (hourCycle == &quot;h11&quot; || hourCycle == &quot;h12&quot;);
 468         if (!hourCycle.isNull())
 469             opt.add(&quot;hc&quot;_s, hourCycle);
 470     } else
 471         opt.add(&quot;hc&quot;_s, String());
 472 
<span class="line-modified"> 473     const HashSet&lt;String&gt;&amp; availableLocales = intlDateTimeFormatAvailableLocales();</span>
<span class="line-modified"> 474     HashMap&lt;String, String&gt; resolved = resolveLocale(globalObject, availableLocales, requestedLocales, opt, IntlDTFInternal::relevantExtensionKeys, WTF_ARRAY_LENGTH(IntlDTFInternal::relevantExtensionKeys), IntlDTFInternal::localeData);</span>
 475 
 476     m_locale = resolved.get(vm.propertyNames-&gt;locale.string());
 477     if (m_locale.isEmpty()) {
<span class="line-modified"> 478         throwTypeError(globalObject, scope, &quot;failed to initialize DateTimeFormat due to invalid locale&quot;_s);</span>
 479         return;
 480     }
 481 
 482     m_calendar = resolved.get(&quot;ca&quot;_s);
 483     if (m_calendar == &quot;gregorian&quot;)
 484         m_calendar = &quot;gregory&quot;_s;
 485     else if (m_calendar == &quot;islamicc&quot;)
 486         m_calendar = &quot;islamic-civil&quot;_s;
 487     else if (m_calendar == &quot;ethioaa&quot;)
 488         m_calendar = &quot;ethiopic-amete-alem&quot;_s;
 489 
 490     m_hourCycle = resolved.get(&quot;hc&quot;_s);
 491     m_numberingSystem = resolved.get(&quot;nu&quot;_s);
 492     String dataLocale = resolved.get(&quot;dataLocale&quot;_s);
 493 
<span class="line-modified"> 494     JSValue tzValue = options-&gt;get(globalObject, vm.propertyNames-&gt;timeZone);</span>
 495     RETURN_IF_EXCEPTION(scope, void());
 496     String tz;
 497     if (!tzValue.isUndefined()) {
<span class="line-modified"> 498         String originalTz = tzValue.toWTFString(globalObject);</span>
 499         RETURN_IF_EXCEPTION(scope, void());
 500         tz = canonicalizeTimeZoneName(originalTz);
 501         if (tz.isNull()) {
<span class="line-modified"> 502             throwRangeError(globalObject, scope, &quot;invalid time zone: &quot; + originalTz);</span>
 503             return;
 504         }
 505     } else
 506         tz = defaultTimeZone();
 507     m_timeZone = tz;
 508 
 509     StringBuilder skeletonBuilder;
 510     auto narrowShortLong = { &quot;narrow&quot;, &quot;short&quot;, &quot;long&quot; };
 511     auto twoDigitNumeric = { &quot;2-digit&quot;, &quot;numeric&quot; };
 512     auto twoDigitNumericNarrowShortLong = { &quot;2-digit&quot;, &quot;numeric&quot;, &quot;narrow&quot;, &quot;short&quot;, &quot;long&quot; };
 513     auto shortLong = { &quot;short&quot;, &quot;long&quot; };
 514 
<span class="line-modified"> 515     String weekday = intlStringOption(globalObject, options, vm.propertyNames-&gt;weekday, narrowShortLong, &quot;weekday must be \&quot;narrow\&quot;, \&quot;short\&quot;, or \&quot;long\&quot;&quot;, nullptr);</span>
 516     RETURN_IF_EXCEPTION(scope, void());
 517     if (!weekday.isNull()) {
 518         if (weekday == &quot;narrow&quot;)
 519             skeletonBuilder.appendLiteral(&quot;EEEEE&quot;);
 520         else if (weekday == &quot;short&quot;)
 521             skeletonBuilder.appendLiteral(&quot;EEE&quot;);
 522         else if (weekday == &quot;long&quot;)
 523             skeletonBuilder.appendLiteral(&quot;EEEE&quot;);
 524     }
 525 
<span class="line-modified"> 526     String era = intlStringOption(globalObject, options, vm.propertyNames-&gt;era, narrowShortLong, &quot;era must be \&quot;narrow\&quot;, \&quot;short\&quot;, or \&quot;long\&quot;&quot;, nullptr);</span>
 527     RETURN_IF_EXCEPTION(scope, void());
 528     if (!era.isNull()) {
 529         if (era == &quot;narrow&quot;)
 530             skeletonBuilder.appendLiteral(&quot;GGGGG&quot;);
 531         else if (era == &quot;short&quot;)
 532             skeletonBuilder.appendLiteral(&quot;GGG&quot;);
 533         else if (era == &quot;long&quot;)
 534             skeletonBuilder.appendLiteral(&quot;GGGG&quot;);
 535     }
 536 
<span class="line-modified"> 537     String year = intlStringOption(globalObject, options, vm.propertyNames-&gt;year, twoDigitNumeric, &quot;year must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
 538     RETURN_IF_EXCEPTION(scope, void());
 539     if (!year.isNull()) {
 540         if (year == &quot;2-digit&quot;)
 541             skeletonBuilder.appendLiteral(&quot;yy&quot;);
 542         else if (year == &quot;numeric&quot;)
 543             skeletonBuilder.append(&#39;y&#39;);
 544     }
 545 
<span class="line-modified"> 546     String month = intlStringOption(globalObject, options, vm.propertyNames-&gt;month, twoDigitNumericNarrowShortLong, &quot;month must be \&quot;2-digit\&quot;, \&quot;numeric\&quot;, \&quot;narrow\&quot;, \&quot;short\&quot;, or \&quot;long\&quot;&quot;, nullptr);</span>
 547     RETURN_IF_EXCEPTION(scope, void());
 548     if (!month.isNull()) {
 549         if (month == &quot;2-digit&quot;)
 550             skeletonBuilder.appendLiteral(&quot;MM&quot;);
 551         else if (month == &quot;numeric&quot;)
 552             skeletonBuilder.append(&#39;M&#39;);
 553         else if (month == &quot;narrow&quot;)
 554             skeletonBuilder.appendLiteral(&quot;MMMMM&quot;);
 555         else if (month == &quot;short&quot;)
 556             skeletonBuilder.appendLiteral(&quot;MMM&quot;);
 557         else if (month == &quot;long&quot;)
 558             skeletonBuilder.appendLiteral(&quot;MMMM&quot;);
 559     }
 560 
<span class="line-modified"> 561     String day = intlStringOption(globalObject, options, vm.propertyNames-&gt;day, twoDigitNumeric, &quot;day must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
 562     RETURN_IF_EXCEPTION(scope, void());
 563     if (!day.isNull()) {
 564         if (day == &quot;2-digit&quot;)
 565             skeletonBuilder.appendLiteral(&quot;dd&quot;);
 566         else if (day == &quot;numeric&quot;)
 567             skeletonBuilder.append(&#39;d&#39;);
 568     }
 569 
<span class="line-modified"> 570     String hour = intlStringOption(globalObject, options, vm.propertyNames-&gt;hour, twoDigitNumeric, &quot;hour must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
 571     RETURN_IF_EXCEPTION(scope, void());
 572     if (hour == &quot;2-digit&quot;) {
 573         if (isHour12Undefined &amp;&amp; m_hourCycle.isNull())
 574             skeletonBuilder.appendLiteral(&quot;jj&quot;);
 575         else if (hour12)
 576             skeletonBuilder.appendLiteral(&quot;hh&quot;);
 577         else
 578             skeletonBuilder.appendLiteral(&quot;HH&quot;);
 579     } else if (hour == &quot;numeric&quot;) {
 580         if (isHour12Undefined &amp;&amp; m_hourCycle.isNull())
 581             skeletonBuilder.append(&#39;j&#39;);
 582         else if (hour12)
 583             skeletonBuilder.append(&#39;h&#39;);
 584         else
 585             skeletonBuilder.append(&#39;H&#39;);
 586     } else
 587         m_hourCycle = String();
 588 
<span class="line-modified"> 589     String minute = intlStringOption(globalObject, options, vm.propertyNames-&gt;minute, twoDigitNumeric, &quot;minute must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
 590     RETURN_IF_EXCEPTION(scope, void());
 591     if (!minute.isNull()) {
 592         if (minute == &quot;2-digit&quot;)
 593             skeletonBuilder.appendLiteral(&quot;mm&quot;);
 594         else if (minute == &quot;numeric&quot;)
 595             skeletonBuilder.append(&#39;m&#39;);
 596     }
 597 
<span class="line-modified"> 598     String second = intlStringOption(globalObject, options, vm.propertyNames-&gt;second, twoDigitNumeric, &quot;second must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
 599     RETURN_IF_EXCEPTION(scope, void());
 600     if (!second.isNull()) {
 601         if (second == &quot;2-digit&quot;)
 602             skeletonBuilder.appendLiteral(&quot;ss&quot;);
 603         else if (second == &quot;numeric&quot;)
 604             skeletonBuilder.append(&#39;s&#39;);
 605     }
 606 
<span class="line-modified"> 607     String timeZoneName = intlStringOption(globalObject, options, vm.propertyNames-&gt;timeZoneName, shortLong, &quot;timeZoneName must be \&quot;short\&quot; or \&quot;long\&quot;&quot;, nullptr);</span>
 608     RETURN_IF_EXCEPTION(scope, void());
 609     if (!timeZoneName.isNull()) {
 610         if (timeZoneName == &quot;short&quot;)
 611             skeletonBuilder.append(&#39;z&#39;);
 612         else if (timeZoneName == &quot;long&quot;)
 613             skeletonBuilder.appendLiteral(&quot;zzzz&quot;);
 614     }
 615 
<span class="line-modified"> 616     intlStringOption(globalObject, options, vm.propertyNames-&gt;formatMatcher, { &quot;basic&quot;, &quot;best fit&quot; }, &quot;formatMatcher must be either \&quot;basic\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);</span>
 617     RETURN_IF_EXCEPTION(scope, void());
 618 
 619     // Always use ICU date format generator, rather than our own pattern list and matcher.
 620     UErrorCode status = U_ZERO_ERROR;
 621     UDateTimePatternGenerator* generator = udatpg_open(dataLocale.utf8().data(), &amp;status);
 622     if (U_FAILURE(status)) {
<span class="line-modified"> 623         throwTypeError(globalObject, scope, &quot;failed to initialize DateTimeFormat&quot;_s);</span>
 624         return;
 625     }
 626 
 627     String skeleton = skeletonBuilder.toString();
 628     StringView skeletonView(skeleton);
 629     Vector&lt;UChar, 32&gt; patternBuffer(32);
 630     status = U_ZERO_ERROR;
 631     auto patternLength = udatpg_getBestPatternWithOptions(generator, skeletonView.upconvertedCharacters(), skeletonView.length(), UDATPG_MATCH_HOUR_FIELD_LENGTH, patternBuffer.data(), patternBuffer.size(), &amp;status);
 632     if (status == U_BUFFER_OVERFLOW_ERROR) {
 633         status = U_ZERO_ERROR;
 634         patternBuffer.grow(patternLength);
 635         udatpg_getBestPattern(generator, skeletonView.upconvertedCharacters(), skeletonView.length(), patternBuffer.data(), patternLength, &amp;status);
 636     }
 637     udatpg_close(generator);
 638     if (U_FAILURE(status)) {
<span class="line-modified"> 639         throwTypeError(globalObject, scope, &quot;failed to initialize DateTimeFormat&quot;_s);</span>
 640         return;
 641     }
 642 
 643     // Enforce our hourCycle, replacing hour characters in pattern.
 644     if (!m_hourCycle.isNull()) {
 645         UChar hour = &#39;H&#39;;
 646         if (m_hourCycle == &quot;h11&quot;)
 647             hour = &#39;K&#39;;
 648         else if (m_hourCycle == &quot;h12&quot;)
 649             hour = &#39;h&#39;;
 650         else if (m_hourCycle == &quot;h24&quot;)
 651             hour = &#39;k&#39;;
 652 
 653         bool isEscaped = false;
 654         bool hasHour = false;
 655         for (auto i = 0; i &lt; patternLength; ++i) {
 656             UChar c = patternBuffer[i];
 657             if (c == &#39;\&#39;&#39;)
 658                 isEscaped = !isEscaped;
 659             else if (!isEscaped &amp;&amp; (c == &#39;h&#39; || c == &#39;H&#39; || c == &#39;k&#39; || c == &#39;K&#39;)) {
 660                 patternBuffer[i] = hour;
 661                 hasHour = true;
 662             }
 663         }
 664         if (!hasHour)
 665             m_hourCycle = String();
 666     }
 667 
 668     StringView pattern(patternBuffer.data(), patternLength);
 669     setFormatsFromPattern(pattern);
 670 
 671     status = U_ZERO_ERROR;
 672     StringView timeZoneView(m_timeZone);
 673     m_dateFormat = std::unique_ptr&lt;UDateFormat, UDateFormatDeleter&gt;(udat_open(UDAT_PATTERN, UDAT_PATTERN, m_locale.utf8().data(), timeZoneView.upconvertedCharacters(), timeZoneView.length(), pattern.upconvertedCharacters(), pattern.length(), &amp;status));
 674     if (U_FAILURE(status)) {
<span class="line-modified"> 675         throwTypeError(globalObject, scope, &quot;failed to initialize DateTimeFormat&quot;_s);</span>
 676         return;
 677     }
 678 
 679     // Gregorian calendar should be used from the beginning of ECMAScript time.
 680     // Failure here means unsupported calendar, and can safely be ignored.
 681     UCalendar* cal = const_cast&lt;UCalendar*&gt;(udat_getCalendar(m_dateFormat.get()));
 682     ucal_setGregorianChange(cal, minECMAScriptTime, &amp;status);
 683 
 684     m_initializedDateTimeFormat = true;
 685 }
 686 
 687 ASCIILiteral IntlDateTimeFormat::weekdayString(Weekday weekday)
 688 {
 689     switch (weekday) {
 690     case Weekday::Narrow:
 691         return &quot;narrow&quot;_s;
 692     case Weekday::Short:
 693         return &quot;short&quot;_s;
 694     case Weekday::Long:
 695         return &quot;long&quot;_s;
</pre>
<hr />
<pre>
 812     }
 813     ASSERT_NOT_REACHED();
 814     return ASCIILiteral::null();
 815 }
 816 
 817 ASCIILiteral IntlDateTimeFormat::timeZoneNameString(TimeZoneName timeZoneName)
 818 {
 819     switch (timeZoneName) {
 820     case TimeZoneName::Short:
 821         return &quot;short&quot;_s;
 822     case TimeZoneName::Long:
 823         return &quot;long&quot;_s;
 824     case TimeZoneName::None:
 825         ASSERT_NOT_REACHED();
 826         return ASCIILiteral::null();
 827     }
 828     ASSERT_NOT_REACHED();
 829     return ASCIILiteral::null();
 830 }
 831 
<span class="line-modified"> 832 JSObject* IntlDateTimeFormat::resolvedOptions(JSGlobalObject* globalObject)</span>
 833 {
<span class="line-modified"> 834     VM&amp; vm = globalObject-&gt;vm();</span>
 835     auto scope = DECLARE_THROW_SCOPE(vm);
 836 
 837     // 12.3.5 Intl.DateTimeFormat.prototype.resolvedOptions() (ECMA-402 2.0)
 838     // The function returns a new object whose properties and attributes are set as if constructed by an object literal assigning to each of the following properties the value of the corresponding internal slot of this DateTimeFormat object (see 12.4): locale, calendar, numberingSystem, timeZone, hour12, weekday, era, year, month, day, hour, minute, second, and timeZoneName. Properties whose corresponding internal slots are not present are not assigned.
 839     // Note: In this version of the ECMAScript 2015 Internationalization API, the timeZone property will be the name of the default time zone if no timeZone property was provided in the options object provided to the Intl.DateTimeFormat constructor. The previous version left the timeZone property undefined in this case.
 840     if (!m_initializedDateTimeFormat) {
<span class="line-modified"> 841         initializeDateTimeFormat(globalObject, jsUndefined(), jsUndefined());</span>
 842         scope.assertNoException();
 843     }
 844 
<span class="line-modified"> 845     JSObject* options = constructEmptyObject(globalObject);</span>
 846     options-&gt;putDirect(vm, vm.propertyNames-&gt;locale, jsNontrivialString(vm, m_locale));
 847     options-&gt;putDirect(vm, vm.propertyNames-&gt;calendar, jsNontrivialString(vm, m_calendar));
 848     options-&gt;putDirect(vm, vm.propertyNames-&gt;numberingSystem, jsNontrivialString(vm, m_numberingSystem));
 849     options-&gt;putDirect(vm, vm.propertyNames-&gt;timeZone, jsNontrivialString(vm, m_timeZone));
 850 
<span class="line-added"> 851     if (!m_hourCycle.isNull()) {</span>
<span class="line-added"> 852         options-&gt;putDirect(vm, vm.propertyNames-&gt;hourCycle, jsNontrivialString(vm, m_hourCycle));</span>
<span class="line-added"> 853         options-&gt;putDirect(vm, vm.propertyNames-&gt;hour12, jsBoolean(m_hourCycle == &quot;h11&quot; || m_hourCycle == &quot;h12&quot;));</span>
<span class="line-added"> 854     }</span>
<span class="line-added"> 855 </span>
 856     if (m_weekday != Weekday::None)
 857         options-&gt;putDirect(vm, vm.propertyNames-&gt;weekday, jsNontrivialString(vm, weekdayString(m_weekday)));
 858 
 859     if (m_era != Era::None)
 860         options-&gt;putDirect(vm, vm.propertyNames-&gt;era, jsNontrivialString(vm, eraString(m_era)));
 861 
 862     if (m_year != Year::None)
 863         options-&gt;putDirect(vm, vm.propertyNames-&gt;year, jsNontrivialString(vm, yearString(m_year)));
 864 
 865     if (m_month != Month::None)
 866         options-&gt;putDirect(vm, vm.propertyNames-&gt;month, jsNontrivialString(vm, monthString(m_month)));
 867 
 868     if (m_day != Day::None)
 869         options-&gt;putDirect(vm, vm.propertyNames-&gt;day, jsNontrivialString(vm, dayString(m_day)));
 870 
 871     if (m_hour != Hour::None)
 872         options-&gt;putDirect(vm, vm.propertyNames-&gt;hour, jsNontrivialString(vm, hourString(m_hour)));
 873 





 874     if (m_minute != Minute::None)
 875         options-&gt;putDirect(vm, vm.propertyNames-&gt;minute, jsNontrivialString(vm, minuteString(m_minute)));
 876 
 877     if (m_second != Second::None)
 878         options-&gt;putDirect(vm, vm.propertyNames-&gt;second, jsNontrivialString(vm, secondString(m_second)));
 879 
 880     if (m_timeZoneName != TimeZoneName::None)
 881         options-&gt;putDirect(vm, vm.propertyNames-&gt;timeZoneName, jsNontrivialString(vm, timeZoneNameString(m_timeZoneName)));
 882 
 883     return options;
 884 }
 885 
<span class="line-modified"> 886 JSValue IntlDateTimeFormat::format(JSGlobalObject* globalObject, double value)</span>
 887 {
<span class="line-modified"> 888     VM&amp; vm = globalObject-&gt;vm();</span>
 889     auto scope = DECLARE_THROW_SCOPE(vm);
 890 
 891     // 12.3.4 FormatDateTime abstract operation (ECMA-402 2.0)
 892     if (!m_initializedDateTimeFormat) {
<span class="line-modified"> 893         initializeDateTimeFormat(globalObject, jsUndefined(), jsUndefined());</span>
 894         scope.assertNoException();
 895     }
 896 
 897     // 1. If x is not a finite Number, then throw a RangeError exception.
 898     if (!std::isfinite(value))
<span class="line-modified"> 899         return throwRangeError(globalObject, scope, &quot;date value is not finite in DateTimeFormat format()&quot;_s);</span>
 900 
 901     // Delegate remaining steps to ICU.
 902     UErrorCode status = U_ZERO_ERROR;
 903     Vector&lt;UChar, 32&gt; result(32);
 904     auto resultLength = udat_format(m_dateFormat.get(), value, result.data(), result.size(), nullptr, &amp;status);
 905     if (status == U_BUFFER_OVERFLOW_ERROR) {
 906         status = U_ZERO_ERROR;
 907         result.grow(resultLength);
 908         udat_format(m_dateFormat.get(), value, result.data(), resultLength, nullptr, &amp;status);
 909     }
 910     if (U_FAILURE(status))
<span class="line-modified"> 911         return throwTypeError(globalObject, scope, &quot;failed to format date value&quot;_s);</span>
 912 
 913     return jsString(vm, String(result.data(), resultLength));
 914 }
 915 
 916 #if JSC_ICU_HAS_UFIELDPOSITER
 917 ASCIILiteral IntlDateTimeFormat::partTypeString(UDateFormatField field)
 918 {
 919     switch (field) {
 920     case UDAT_ERA_FIELD:
 921         return &quot;era&quot;_s;
 922     case UDAT_YEAR_FIELD:
 923     case UDAT_YEAR_NAME_FIELD:
 924     case UDAT_EXTENDED_YEAR_FIELD:
 925         return &quot;year&quot;_s;
 926     case UDAT_MONTH_FIELD:
 927     case UDAT_STANDALONE_MONTH_FIELD:
 928         return &quot;month&quot;_s;
 929     case UDAT_DATE_FIELD:
 930         return &quot;day&quot;_s;
 931     case UDAT_HOUR_OF_DAY1_FIELD:
</pre>
<hr />
<pre>
 963     case UDAT_WEEK_OF_YEAR_FIELD:
 964     case UDAT_WEEK_OF_MONTH_FIELD:
 965     case UDAT_YEAR_WOY_FIELD:
 966     case UDAT_JULIAN_DAY_FIELD:
 967     case UDAT_MILLISECONDS_IN_DAY_FIELD:
 968     case UDAT_QUARTER_FIELD:
 969     case UDAT_STANDALONE_QUARTER_FIELD:
 970     case UDAT_RELATED_YEAR_FIELD:
 971     case UDAT_TIME_SEPARATOR_FIELD:
 972 #if U_ICU_VERSION_MAJOR_NUM &lt; 58 || !defined(U_HIDE_DEPRECATED_API)
 973     case UDAT_FIELD_COUNT:
 974 #endif
 975     // Any newer additions to the UDateFormatField enum should just be considered an &quot;unknown&quot; part.
 976     default:
 977         return &quot;unknown&quot;_s;
 978     }
 979     return &quot;unknown&quot;_s;
 980 }
 981 
 982 
<span class="line-modified"> 983 JSValue IntlDateTimeFormat::formatToParts(JSGlobalObject* globalObject, double value)</span>
 984 {
<span class="line-modified"> 985     VM&amp; vm = globalObject-&gt;vm();</span>
 986     auto scope = DECLARE_THROW_SCOPE(vm);
 987 
 988     // 12.1.8 FormatDateTimeToParts (ECMA-402 4.0)
 989     // https://tc39.github.io/ecma402/#sec-formatdatetimetoparts
 990 
 991     if (!std::isfinite(value))
<span class="line-modified"> 992         return throwRangeError(globalObject, scope, &quot;date value is not finite in DateTimeFormat formatToParts()&quot;_s);</span>
 993 
 994     UErrorCode status = U_ZERO_ERROR;
 995     auto fields = std::unique_ptr&lt;UFieldPositionIterator, UFieldPositionIteratorDeleter&gt;(ufieldpositer_open(&amp;status));
 996     if (U_FAILURE(status))
<span class="line-modified"> 997         return throwTypeError(globalObject, scope, &quot;failed to open field position iterator&quot;_s);</span>
 998 
 999     status = U_ZERO_ERROR;
1000     Vector&lt;UChar, 32&gt; result(32);
1001     auto resultLength = udat_formatForFields(m_dateFormat.get(), value, result.data(), result.size(), fields.get(), &amp;status);
1002     if (status == U_BUFFER_OVERFLOW_ERROR) {
1003         status = U_ZERO_ERROR;
1004         result.grow(resultLength);
1005         udat_formatForFields(m_dateFormat.get(), value, result.data(), resultLength, fields.get(), &amp;status);
1006     }
1007     if (U_FAILURE(status))
<span class="line-modified">1008         return throwTypeError(globalObject, scope, &quot;failed to format date value&quot;_s);</span>
1009 

1010     JSArray* parts = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), 0);
1011     if (!parts)
<span class="line-modified">1012         return throwOutOfMemoryError(globalObject, scope);</span>
1013 
1014     auto resultString = String(result.data(), resultLength);
1015     auto typePropertyName = Identifier::fromString(vm, &quot;type&quot;);
<span class="line-modified">1016     auto literalString = jsNontrivialString(vm, &quot;literal&quot;_s);</span>
1017 
1018     int32_t previousEndIndex = 0;
1019     int32_t beginIndex = 0;
1020     int32_t endIndex = 0;
1021     while (previousEndIndex &lt; resultLength) {
1022         auto fieldType = ufieldpositer_next(fields.get(), &amp;beginIndex, &amp;endIndex);
1023         if (fieldType &lt; 0)
1024             beginIndex = endIndex = resultLength;
1025 
1026         if (previousEndIndex &lt; beginIndex) {
1027             auto value = jsString(vm, resultString.substring(previousEndIndex, beginIndex - previousEndIndex));
<span class="line-modified">1028             JSObject* part = constructEmptyObject(globalObject);</span>
1029             part-&gt;putDirect(vm, typePropertyName, literalString);
1030             part-&gt;putDirect(vm, vm.propertyNames-&gt;value, value);
<span class="line-modified">1031             parts-&gt;push(globalObject, part);</span>
1032             RETURN_IF_EXCEPTION(scope, { });
1033         }
1034         previousEndIndex = endIndex;
1035 
1036         if (fieldType &gt;= 0) {
1037             auto type = jsString(vm, partTypeString(UDateFormatField(fieldType)));
1038             auto value = jsString(vm, resultString.substring(beginIndex, endIndex - beginIndex));
<span class="line-modified">1039             JSObject* part = constructEmptyObject(globalObject);</span>
1040             part-&gt;putDirect(vm, typePropertyName, type);
1041             part-&gt;putDirect(vm, vm.propertyNames-&gt;value, value);
<span class="line-modified">1042             parts-&gt;push(globalObject, part);</span>
1043             RETURN_IF_EXCEPTION(scope, { });
1044         }
1045     }
1046 
1047 
1048     return parts;
1049 }
1050 #endif
1051 
1052 } // namespace JSC
1053 
1054 #endif // ENABLE(INTL)
</pre>
</td>
</tr>
</table>
<center><a href="IntlCollatorPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IntlDateTimeFormat.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
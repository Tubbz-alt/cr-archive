<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/css/StyleSheetContents.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StyleRuleImport.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleSheetContents.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/StyleSheetContents.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 50,11 ***</span>
  
  // Rough size estimate for the memory cache.
  unsigned StyleSheetContents::estimatedSizeInBytes() const
  {
      // Note that this does not take into account size of the strings hanging from various objects.
<span class="line-modified">!     // The assumption is that nearly all of of them are atomic and would exist anyway.</span>
      unsigned size = sizeof(*this);
  
      // FIXME: This ignores the children of media and region rules.
      // Most rules are StyleRules.
      size += ruleCount() * StyleRule::averageSizeInBytes();
<span class="line-new-header">--- 50,11 ---</span>
  
  // Rough size estimate for the memory cache.
  unsigned StyleSheetContents::estimatedSizeInBytes() const
  {
      // Note that this does not take into account size of the strings hanging from various objects.
<span class="line-modified">!     // The assumption is that nearly all of of them are atoms that would exist anyway.</span>
      unsigned size = sizeof(*this);
  
      // FIXME: This ignores the children of media and region rules.
      // Most rules are StyleRules.
      size += ruleCount() * StyleRule::averageSizeInBytes();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 154,12 ***</span>
      if (is&lt;StyleRuleMedia&gt;(rule))
          reportMediaQueryWarningIfNeeded(singleOwnerDocument(), downcast&lt;StyleRuleMedia&gt;(rule.get()).mediaQueries());
  
      // NOTE: The selector list has to fit into RuleData. &lt;http://webkit.org/b/118369&gt;
      // If we&#39;re adding a rule with a huge number of selectors, split it up into multiple rules
<span class="line-modified">!     if (is&lt;StyleRule&gt;(rule) &amp;&amp; downcast&lt;StyleRule&gt;(rule.get()).selectorList().componentCount() &gt; RuleData::maximumSelectorComponentCount) {</span>
<span class="line-modified">!         m_childRules.appendVector(downcast&lt;StyleRule&gt;(rule.get()).splitIntoMultipleRulesWithMaximumSelectorComponentCount(RuleData::maximumSelectorComponentCount));</span>
          return;
      }
  
      m_childRules.append(WTFMove(rule));
  }
<span class="line-new-header">--- 154,12 ---</span>
      if (is&lt;StyleRuleMedia&gt;(rule))
          reportMediaQueryWarningIfNeeded(singleOwnerDocument(), downcast&lt;StyleRuleMedia&gt;(rule.get()).mediaQueries());
  
      // NOTE: The selector list has to fit into RuleData. &lt;http://webkit.org/b/118369&gt;
      // If we&#39;re adding a rule with a huge number of selectors, split it up into multiple rules
<span class="line-modified">!     if (is&lt;StyleRule&gt;(rule) &amp;&amp; downcast&lt;StyleRule&gt;(rule.get()).selectorList().componentCount() &gt; Style::RuleData::maximumSelectorComponentCount) {</span>
<span class="line-modified">!         m_childRules.appendVector(downcast&lt;StyleRule&gt;(rule.get()).splitIntoMultipleRulesWithMaximumSelectorComponentCount(Style::RuleData::maximumSelectorComponentCount));</span>
          return;
      }
  
      m_childRules.append(WTFMove(rule));
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 262,11 ***</span>
      if (is&lt;StyleRuleNamespace&gt;(rule))
          return false;
      childVectorIndex -= m_namespaceRules.size();
  
      // If the number of selectors would overflow RuleData, we drop the operation.
<span class="line-modified">!     if (is&lt;StyleRule&gt;(rule) &amp;&amp; downcast&lt;StyleRule&gt;(rule.get()).selectorList().componentCount() &gt; RuleData::maximumSelectorComponentCount)</span>
          return false;
  
      m_childRules.insert(childVectorIndex, WTFMove(rule));
      return true;
  }
<span class="line-new-header">--- 262,11 ---</span>
      if (is&lt;StyleRuleNamespace&gt;(rule))
          return false;
      childVectorIndex -= m_namespaceRules.size();
  
      // If the number of selectors would overflow RuleData, we drop the operation.
<span class="line-modified">!     if (is&lt;StyleRule&gt;(rule) &amp;&amp; downcast&lt;StyleRule&gt;(rule.get()).selectorList().componentCount() &gt; Style::RuleData::maximumSelectorComponentCount)</span>
          return false;
  
      m_childRules.insert(childVectorIndex, WTFMove(rule));
      return true;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 314,11 ***</span>
      if (it == m_namespaces.end())
          return nullAtom();
      return it-&gt;value;
  }
  
<span class="line-modified">! void StyleSheetContents::parseAuthorStyleSheet(const CachedCSSStyleSheet* cachedStyleSheet, const SecurityOrigin* securityOrigin)</span>
  {
      bool isSameOriginRequest = securityOrigin &amp;&amp; securityOrigin-&gt;canRequest(baseURL());
      CachedCSSStyleSheet::MIMETypeCheckHint mimeTypeCheckHint = isStrictParserMode(m_parserContext.mode) || !isSameOriginRequest ? CachedCSSStyleSheet::MIMETypeCheckHint::Strict : CachedCSSStyleSheet::MIMETypeCheckHint::Lax;
      bool hasValidMIMEType = true;
      String sheetText = cachedStyleSheet-&gt;sheetText(mimeTypeCheckHint, &amp;hasValidMIMEType);
<span class="line-new-header">--- 314,11 ---</span>
      if (it == m_namespaces.end())
          return nullAtom();
      return it-&gt;value;
  }
  
<span class="line-modified">! bool StyleSheetContents::parseAuthorStyleSheet(const CachedCSSStyleSheet* cachedStyleSheet, const SecurityOrigin* securityOrigin)</span>
  {
      bool isSameOriginRequest = securityOrigin &amp;&amp; securityOrigin-&gt;canRequest(baseURL());
      CachedCSSStyleSheet::MIMETypeCheckHint mimeTypeCheckHint = isStrictParserMode(m_parserContext.mode) || !isSameOriginRequest ? CachedCSSStyleSheet::MIMETypeCheckHint::Strict : CachedCSSStyleSheet::MIMETypeCheckHint::Lax;
      bool hasValidMIMEType = true;
      String sheetText = cachedStyleSheet-&gt;sheetText(mimeTypeCheckHint, &amp;hasValidMIMEType);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 333,14 ***</span>
                      page-&gt;console().addMessage(MessageSource::Security, MessageLevel::Error, makeString(&quot;Did not parse stylesheet at &#39;&quot;, cachedStyleSheet-&gt;url().stringCenterEllipsizedToLength(), &quot;&#39; because non CSS MIME types are not allowed when &#39;X-Content-Type: nosniff&#39; is given.&quot;));
                  else
                      page-&gt;console().addMessage(MessageSource::Security, MessageLevel::Error, makeString(&quot;Did not parse stylesheet at &#39;&quot;, cachedStyleSheet-&gt;url().stringCenterEllipsizedToLength(), &quot;&#39; because non CSS MIME types are not allowed for cross-origin stylesheets.&quot;));
              }
          }
<span class="line-modified">!         return;</span>
      }
  
      CSSParser(parserContext()).parseSheet(this, sheetText, CSSParser::RuleParsing::Deferred);
  }
  
  bool StyleSheetContents::parseString(const String&amp; sheetText)
  {
      CSSParser p(parserContext());
<span class="line-new-header">--- 333,15 ---</span>
                      page-&gt;console().addMessage(MessageSource::Security, MessageLevel::Error, makeString(&quot;Did not parse stylesheet at &#39;&quot;, cachedStyleSheet-&gt;url().stringCenterEllipsizedToLength(), &quot;&#39; because non CSS MIME types are not allowed when &#39;X-Content-Type: nosniff&#39; is given.&quot;));
                  else
                      page-&gt;console().addMessage(MessageSource::Security, MessageLevel::Error, makeString(&quot;Did not parse stylesheet at &#39;&quot;, cachedStyleSheet-&gt;url().stringCenterEllipsizedToLength(), &quot;&#39; because non CSS MIME types are not allowed for cross-origin stylesheets.&quot;));
              }
          }
<span class="line-modified">!         return false;</span>
      }
  
      CSSParser(parserContext()).parseSheet(this, sheetText, CSSParser::RuleParsing::Deferred);
<span class="line-added">+     return true;</span>
  }
  
  bool StyleSheetContents::parseString(const String&amp; sheetText)
  {
      CSSParser p(parserContext());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 424,30 ***</span>
  {
      for (auto&amp; rule : rules) {
          if (handler(*rule))
              return true;
          switch (rule-&gt;type()) {
<span class="line-modified">!         case StyleRuleBase::Media: {</span>
              auto* childRules = downcast&lt;StyleRuleMedia&gt;(*rule).childRulesWithoutDeferredParsing();
              if (childRules &amp;&amp; traverseRulesInVector(*childRules, handler))
                  return true;
              break;
          }
<span class="line-modified">!         case StyleRuleBase::Import:</span>
              ASSERT_NOT_REACHED();
              break;
<span class="line-modified">!         case StyleRuleBase::Style:</span>
<span class="line-modified">!         case StyleRuleBase::FontFace:</span>
<span class="line-modified">!         case StyleRuleBase::Page:</span>
<span class="line-modified">!         case StyleRuleBase::Keyframes:</span>
<span class="line-modified">!         case StyleRuleBase::Namespace:</span>
<span class="line-modified">!         case StyleRuleBase::Unknown:</span>
<span class="line-modified">!         case StyleRuleBase::Charset:</span>
<span class="line-modified">!         case StyleRuleBase::Keyframe:</span>
<span class="line-modified">!         case StyleRuleBase::Supports:</span>
  #if ENABLE(CSS_DEVICE_ADAPTATION)
<span class="line-modified">!         case StyleRuleBase::Viewport:</span>
  #endif
              break;
          }
      }
      return false;
<span class="line-new-header">--- 425,30 ---</span>
  {
      for (auto&amp; rule : rules) {
          if (handler(*rule))
              return true;
          switch (rule-&gt;type()) {
<span class="line-modified">!         case StyleRuleType::Media: {</span>
              auto* childRules = downcast&lt;StyleRuleMedia&gt;(*rule).childRulesWithoutDeferredParsing();
              if (childRules &amp;&amp; traverseRulesInVector(*childRules, handler))
                  return true;
              break;
          }
<span class="line-modified">!         case StyleRuleType::Import:</span>
              ASSERT_NOT_REACHED();
              break;
<span class="line-modified">!         case StyleRuleType::Style:</span>
<span class="line-modified">!         case StyleRuleType::FontFace:</span>
<span class="line-modified">!         case StyleRuleType::Page:</span>
<span class="line-modified">!         case StyleRuleType::Keyframes:</span>
<span class="line-modified">!         case StyleRuleType::Namespace:</span>
<span class="line-modified">!         case StyleRuleType::Unknown:</span>
<span class="line-modified">!         case StyleRuleType::Charset:</span>
<span class="line-modified">!         case StyleRuleType::Keyframe:</span>
<span class="line-modified">!         case StyleRuleType::Supports:</span>
  #if ENABLE(CSS_DEVICE_ADAPTATION)
<span class="line-modified">!         case StyleRuleType::Viewport:</span>
  #endif
              break;
          }
      }
      return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 467,30 ***</span>
  
  bool StyleSheetContents::traverseSubresources(const WTF::Function&lt;bool (const CachedResource&amp;)&gt;&amp; handler) const
  {
      return traverseRules([&amp;] (const StyleRuleBase&amp; rule) {
          switch (rule.type()) {
<span class="line-modified">!         case StyleRuleBase::Style: {</span>
              auto* properties = downcast&lt;StyleRule&gt;(rule).propertiesWithoutDeferredParsing();
              return properties &amp;&amp; properties-&gt;traverseSubresources(handler);
          }
<span class="line-modified">!         case StyleRuleBase::FontFace:</span>
              return downcast&lt;StyleRuleFontFace&gt;(rule).properties().traverseSubresources(handler);
<span class="line-modified">!         case StyleRuleBase::Import:</span>
              if (auto* cachedResource = downcast&lt;StyleRuleImport&gt;(rule).cachedCSSStyleSheet())
                  return handler(*cachedResource);
              return false;
<span class="line-modified">!         case StyleRuleBase::Media:</span>
<span class="line-modified">!         case StyleRuleBase::Page:</span>
<span class="line-modified">!         case StyleRuleBase::Keyframes:</span>
<span class="line-modified">!         case StyleRuleBase::Namespace:</span>
<span class="line-modified">!         case StyleRuleBase::Unknown:</span>
<span class="line-modified">!         case StyleRuleBase::Charset:</span>
<span class="line-modified">!         case StyleRuleBase::Keyframe:</span>
<span class="line-modified">!         case StyleRuleBase::Supports:</span>
  #if ENABLE(CSS_DEVICE_ADAPTATION)
<span class="line-modified">!         case StyleRuleBase::Viewport:</span>
  #endif
              return false;
          };
          ASSERT_NOT_REACHED();
          return false;
<span class="line-new-header">--- 468,30 ---</span>
  
  bool StyleSheetContents::traverseSubresources(const WTF::Function&lt;bool (const CachedResource&amp;)&gt;&amp; handler) const
  {
      return traverseRules([&amp;] (const StyleRuleBase&amp; rule) {
          switch (rule.type()) {
<span class="line-modified">!         case StyleRuleType::Style: {</span>
              auto* properties = downcast&lt;StyleRule&gt;(rule).propertiesWithoutDeferredParsing();
              return properties &amp;&amp; properties-&gt;traverseSubresources(handler);
          }
<span class="line-modified">!         case StyleRuleType::FontFace:</span>
              return downcast&lt;StyleRuleFontFace&gt;(rule).properties().traverseSubresources(handler);
<span class="line-modified">!         case StyleRuleType::Import:</span>
              if (auto* cachedResource = downcast&lt;StyleRuleImport&gt;(rule).cachedCSSStyleSheet())
                  return handler(*cachedResource);
              return false;
<span class="line-modified">!         case StyleRuleType::Media:</span>
<span class="line-modified">!         case StyleRuleType::Page:</span>
<span class="line-modified">!         case StyleRuleType::Keyframes:</span>
<span class="line-modified">!         case StyleRuleType::Namespace:</span>
<span class="line-modified">!         case StyleRuleType::Unknown:</span>
<span class="line-modified">!         case StyleRuleType::Charset:</span>
<span class="line-modified">!         case StyleRuleType::Keyframe:</span>
<span class="line-modified">!         case StyleRuleType::Supports:</span>
  #if ENABLE(CSS_DEVICE_ADAPTATION)
<span class="line-modified">!         case StyleRuleType::Viewport:</span>
  #endif
              return false;
          };
          ASSERT_NOT_REACHED();
          return false;
</pre>
<center><a href="StyleRuleImport.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleSheetContents.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
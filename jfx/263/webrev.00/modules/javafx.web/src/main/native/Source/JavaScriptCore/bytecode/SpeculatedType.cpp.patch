diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/SpeculatedType.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/SpeculatedType.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/SpeculatedType.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/SpeculatedType.cpp
@@ -27,10 +27,11 @@
  */
 
 #include "config.h"
 #include "SpeculatedType.h"
 
+#include "DateInstance.h"
 #include "DirectArguments.h"
 #include "JSArray.h"
 #include "JSBigInt.h"
 #include "JSBoundFunction.h"
 #include "JSCInlines.h"
@@ -172,10 +173,20 @@
             if (value & SpecRegExpObject)
                 strOut.print("RegExpObject");
             else
                 isTop = false;
 
+            if (value & SpecDateObject)
+                strOut.print("DateObject");
+            else
+                isTop = false;
+
+            if (value & SpecPromiseObject)
+                strOut.print("PromiseObject");
+            else
+                isTop = false;
+
             if (value & SpecMapObject)
                 strOut.print("MapObject");
             else
                 isTop = false;
 
@@ -261,17 +272,17 @@
             strOut.print("NonIntAsDouble");
         else
             isTop = false;
 
         if (value & SpecDoublePureNaN)
-            strOut.print("DoublePureNan");
+            strOut.print("DoublePureNaN");
         else
             isTop = false;
     }
 
     if (value & SpecDoubleImpureNaN)
-        out.print("DoubleImpureNan");
+        strOut.print("DoubleImpureNaN");
 
     if (value & SpecBoolean)
         strOut.print("Bool");
     else
         isTop = false;
@@ -438,10 +449,13 @@
         return SpecStringObject;
 
     if (classInfo == RegExpObject::info())
         return SpecRegExpObject;
 
+    if (classInfo == DateInstance::info())
+        return SpecDateObject;
+
     if (classInfo == JSMap::info())
         return SpecMapObject;
 
     if (classInfo == JSSet::info())
         return SpecSetObject;
@@ -462,10 +476,13 @@
         if (classInfo == JSBoundFunction::info())
             return SpecFunctionWithNonDefaultHasInstance;
         return SpecFunctionWithDefaultHasInstance;
     }
 
+    if (classInfo->isSubClassOf(JSPromise::info()))
+        return SpecPromiseObject;
+
     if (isTypedView(classInfo->typedArrayStorageType))
         return speculationFromTypedArrayType(classInfo->typedArrayStorageType);
 
     if (classInfo->isSubClassOf(JSArray::info()))
         return SpecDerivedArray;
@@ -569,11 +586,11 @@
         return TypeFloat64;
 
     return NotTypedArray;
 }
 
-SpeculatedType speculationFromJSType(JSType type)
+Optional<SpeculatedType> speculationFromJSType(JSType type)
 {
     switch (type) {
     case StringType:
         return SpecString;
     case SymbolType:
@@ -584,12 +601,16 @@
         return SpecArray;
     case DerivedArrayType:
         return SpecDerivedArray;
     case RegExpObjectType:
         return SpecRegExpObject;
+    case JSDateType:
+        return SpecDateObject;
     case ProxyObjectType:
         return SpecProxyObject;
+    case JSPromiseType:
+        return SpecPromiseObject;
     case JSMapType:
         return SpecMapObject;
     case JSSetType:
         return SpecSetObject;
     case JSWeakMapType:
@@ -597,13 +618,12 @@
     case JSWeakSetType:
         return SpecWeakSetObject;
     case DataViewType:
         return SpecDataViewObject;
     default:
-        ASSERT_NOT_REACHED();
+        return WTF::nullopt;
     }
-    return SpecNone;
 }
 
 SpeculatedType leastUpperBoundOfStrictlyEquivalentSpeculations(SpeculatedType type)
 {
     // SpecNonIntAsDouble includes negative zero (-0.0), which can be equal to 0 and 0.0 in the context of == and ===.
@@ -613,14 +633,25 @@
     if (type & SpecString)
         type |= SpecString;
     return type;
 }
 
+static inline SpeculatedType leastUpperBoundOfEquivalentSpeculations(SpeculatedType type)
+{
+    type = leastUpperBoundOfStrictlyEquivalentSpeculations(type);
+
+    // Boolean or BigInt can be converted to Number when performing non-strict equal.
+    if (type & (SpecIntAnyFormat | SpecNonIntAsDouble | SpecBoolean | SpecBigInt))
+        type |= (SpecIntAnyFormat | SpecNonIntAsDouble | SpecBoolean | SpecBigInt);
+
+    return type;
+}
+
 bool valuesCouldBeEqual(SpeculatedType a, SpeculatedType b)
 {
-    a = leastUpperBoundOfStrictlyEquivalentSpeculations(a);
-    b = leastUpperBoundOfStrictlyEquivalentSpeculations(b);
+    a = leastUpperBoundOfEquivalentSpeculations(a);
+    b = leastUpperBoundOfEquivalentSpeculations(b);
 
     // Anything could be equal to a string.
     if (a & SpecString)
         return true;
     if (b & SpecString)
@@ -670,10 +701,21 @@
 SpeculatedType typeOfDoubleDifference(SpeculatedType a, SpeculatedType b)
 {
     return typeOfDoubleSumOrDifferenceOrProduct(a, b);
 }
 
+SpeculatedType typeOfDoubleIncOrDec(SpeculatedType t)
+{
+    // Impure NaN could become pure NaN during addition because addition may clear bits.
+    if (t & SpecDoubleImpureNaN)
+        t |= SpecDoublePureNaN;
+    // Values could overflow, or fractions could become integers.
+    if (t & SpecDoubleReal)
+        t |= SpecDoubleReal;
+    return t;
+}
+
 SpeculatedType typeOfDoubleProduct(SpeculatedType a, SpeculatedType b)
 {
     return typeOfDoubleSumOrDifferenceOrProduct(a, b);
 }
 
@@ -792,10 +834,14 @@
         return SpecScopedArguments;
     if (!strncmp(speculation, "SpecStringObject", strlen("SpecStringObject")))
         return SpecStringObject;
     if (!strncmp(speculation, "SpecRegExpObject", strlen("SpecRegExpObject")))
         return SpecRegExpObject;
+    if (!strncmp(speculation, "SpecDateObject", strlen("SpecDateObject")))
+        return SpecDateObject;
+    if (!strncmp(speculation, "SpecPromiseObject", strlen("SpecPromiseObject")))
+        return SpecPromiseObject;
     if (!strncmp(speculation, "SpecMapObject", strlen("SpecMapObject")))
         return SpecMapObject;
     if (!strncmp(speculation, "SpecSetObject", strlen("SpecSetObject")))
         return SpecSetObject;
     if (!strncmp(speculation, "SpecWeakMapObject", strlen("SpecWeakMapObject")))

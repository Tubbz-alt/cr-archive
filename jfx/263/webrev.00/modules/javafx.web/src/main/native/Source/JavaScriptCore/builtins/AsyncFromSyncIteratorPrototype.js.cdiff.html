<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/AsyncFromSyncIteratorPrototype.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ArrayPrototype.js.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AsyncFunctionPrototype.js.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/AsyncFromSyncIteratorPrototype.js</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
<span class="line-new-header">--- 1,8 ---</span>
  /*
   * Copyright (C) 2017 Oleksandr Skachkov &lt;gskachkov@gmail.com&gt;.
<span class="line-added">+  * Copyright (C) 2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 25,129 ***</span>
  
  function next(value)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     const promiseCapability = @newPromiseCapability(@Promise);</span>
  
      if (!@isObject(this) || !@isObject(@getByIdDirectPrivate(this, &quot;syncIterator&quot;))) {
<span class="line-modified">!         promiseCapability.@reject.@call(@undefined, @makeTypeError(&#39;Iterator is not an object.&#39;));</span>
<span class="line-modified">!         return promiseCapability.@promise;</span>
      }
  
<span class="line-modified">!     const syncIterator = @getByIdDirectPrivate(this, &quot;syncIterator&quot;);</span>
  
      try {
<span class="line-modified">!         const { value: nextValue, done: nextDone } = @getByIdDirectPrivate(this, &quot;nextMethod&quot;).@call(syncIterator, value);</span>
<span class="line-modified">!         const valueWrapperCapability = @newPromiseCapability(@Promise);</span>
<span class="line-modified">!         valueWrapperCapability.@resolve.@call(@undefined, nextValue);</span>
<span class="line-modified">!         valueWrapperCapability.@promise.@then(</span>
<span class="line-modified">!             function (result) { promiseCapability.@resolve.@call(@undefined, { value: result, done: !!nextDone }); },</span>
<span class="line-modified">!             function (error) { promiseCapability.@reject.@call(@undefined, error); });</span>
<span class="line-modified">!      } catch(e) {</span>
<span class="line-modified">!          promiseCapability.@reject.@call(@undefined, e);</span>
<span class="line-modified">!      }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     return promiseCapability.@promise;</span>
  }
  
  function return(value)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     const promiseCapability = @newPromiseCapability(@Promise);</span>
  
      if (!@isObject(this) || !@isObject(@getByIdDirectPrivate(this, &quot;syncIterator&quot;))) {
<span class="line-modified">!         promiseCapability.@reject.@call(@undefined, @makeTypeError(&#39;Iterator is not an object.&#39;));</span>
<span class="line-modified">!         return promiseCapability.@promise;</span>
      }
  
<span class="line-modified">!     const syncIterator = @getByIdDirectPrivate(this, &quot;syncIterator&quot;);</span>
  
<span class="line-modified">!     let returnMethod;</span>
  
      try {
          returnMethod = syncIterator.return;
      } catch (e) {
<span class="line-modified">!         promiseCapability.@reject.@call(@undefined, e);</span>
<span class="line-modified">!         return promiseCapability.@promise;</span>
      }
  
      if (returnMethod === @undefined) {
<span class="line-modified">!         promiseCapability.@resolve.@call(@undefined, { value, done: true });</span>
<span class="line-modified">!         return promiseCapability.@promise;</span>
      }
      
      try {
<span class="line-modified">!         const returnResult = returnMethod.@call(syncIterator, value);</span>
  
          if (!@isObject(returnResult)) {
<span class="line-modified">!             promiseCapability.@reject.@call(@undefined, @makeTypeError(&#39;Iterator result interface is not an object.&#39;));</span>
<span class="line-modified">!             return promiseCapability.@promise;</span>
          }
  
<span class="line-modified">!         const { value: resultValue, done: resultDone } = returnResult;</span>
<span class="line-modified">!         const valueWrapperCapability = @newPromiseCapability(@Promise);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         valueWrapperCapability.@resolve.@call(@undefined, resultValue);</span>
<span class="line-modified">!         valueWrapperCapability.@promise.@then(</span>
<span class="line-removed">-             function (result) { promiseCapability.@resolve.@call(@undefined, { value: result, done: resultDone }); },</span>
<span class="line-removed">-             function (error) { promiseCapability.@reject.@call(@undefined, error); });</span>
      } catch (e) {
<span class="line-modified">!         promiseCapability.@reject.@call(@undefined, e);</span>
      }
  
<span class="line-modified">!     return promiseCapability.@promise;</span>
  }
  
  function throw(exception)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     const promiseCapability = @newPromiseCapability(@Promise);</span>
  
      if (!@isObject(this) || !@isObject(@getByIdDirectPrivate(this, &quot;syncIterator&quot;))) {
<span class="line-modified">!         promiseCapability.@reject.@call(@undefined, @makeTypeError(&#39;Iterator is not an object.&#39;));</span>
<span class="line-modified">!         return promiseCapability.@promise;</span>
      }
  
<span class="line-modified">!     const syncIterator = @getByIdDirectPrivate(this, &quot;syncIterator&quot;);</span>
  
<span class="line-modified">!     let throwMethod;</span>
  
      try {
          throwMethod = syncIterator.throw;
      } catch (e) {
<span class="line-modified">!         promiseCapability.@reject.@call(@undefined, e);</span>
<span class="line-modified">!         return promiseCapability.@promise;</span>
      }
  
      if (throwMethod === @undefined) {
<span class="line-modified">!         promiseCapability.@reject.@call(@undefined, exception);</span>
<span class="line-modified">!         return promiseCapability.@promise;</span>
      }
      
      try {
<span class="line-modified">!         const throwResult = throwMethod.@call(syncIterator, exception);</span>
          
          if (!@isObject(throwResult)) {
<span class="line-modified">!             promiseCapability.@reject.@call(@undefined, @makeTypeError(&#39;Iterator result interface is not an object.&#39;));</span>
<span class="line-modified">!             return promiseCapability.@promise;</span>
          }
          
<span class="line-modified">!         const { value: throwValue, done: throwDone } = throwResult;</span>
<span class="line-modified">!         const valueWrapperCapability = @newPromiseCapability(@Promise);</span>
<span class="line-modified">!         </span>
<span class="line-modified">!         valueWrapperCapability.@resolve.@call(@undefined, throwValue);</span>
<span class="line-modified">!         valueWrapperCapability.@promise.@then(</span>
<span class="line-removed">-             function (result) { promiseCapability.@resolve.@call(@undefined, { value: result, done: throwDone }); },</span>
<span class="line-removed">-             function (error) { promiseCapability.@reject.@call(@undefined, error); });</span>
      } catch (e) {
<span class="line-modified">!         promiseCapability.@reject.@call(@undefined, e);</span>
      }
      
<span class="line-modified">!     return promiseCapability.@promise;</span>
  }
  
  @globalPrivate
  function createAsyncFromSyncIterator(syncIterator, nextMethod)
  {
<span class="line-new-header">--- 26,125 ---</span>
  
  function next(value)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     var promise = @newPromise();</span>
  
      if (!@isObject(this) || !@isObject(@getByIdDirectPrivate(this, &quot;syncIterator&quot;))) {
<span class="line-modified">!         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, @makeTypeError(&#39;Iterator is not an object.&#39;));</span>
<span class="line-modified">!         return promise;</span>
      }
  
<span class="line-modified">!     var syncIterator = @getByIdDirectPrivate(this, &quot;syncIterator&quot;);</span>
  
      try {
<span class="line-modified">!         var nextResult = @getByIdDirectPrivate(this, &quot;nextMethod&quot;).@call(syncIterator, value);</span>
<span class="line-modified">!         var nextDone = !!nextResult.done;</span>
<span class="line-modified">!         var nextValue = nextResult.value;</span>
<span class="line-modified">!         @resolveWithoutPromise(nextValue,</span>
<span class="line-modified">!             function (result) { @resolvePromiseWithFirstResolvingFunctionCallCheck(promise, { value: result, done: nextDone }); },</span>
<span class="line-modified">!             function (error) { @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, error); });</span>
<span class="line-modified">!     } catch (e) {</span>
<span class="line-modified">!         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, e);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     return promise;</span>
  }
  
  function return(value)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     var promise = @newPromise();</span>
  
      if (!@isObject(this) || !@isObject(@getByIdDirectPrivate(this, &quot;syncIterator&quot;))) {
<span class="line-modified">!         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, @makeTypeError(&#39;Iterator is not an object.&#39;));</span>
<span class="line-modified">!         return promise;</span>
      }
  
<span class="line-modified">!     var syncIterator = @getByIdDirectPrivate(this, &quot;syncIterator&quot;);</span>
  
<span class="line-modified">!     var returnMethod;</span>
  
      try {
          returnMethod = syncIterator.return;
      } catch (e) {
<span class="line-modified">!         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, e);</span>
<span class="line-modified">!         return promise;</span>
      }
  
      if (returnMethod === @undefined) {
<span class="line-modified">!         @resolvePromiseWithFirstResolvingFunctionCallCheck(promise, { value, done: true });</span>
<span class="line-modified">!         return promise;</span>
      }
      
      try {
<span class="line-modified">!         var returnResult = returnMethod.@call(syncIterator, value);</span>
  
          if (!@isObject(returnResult)) {
<span class="line-modified">!             @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, @makeTypeError(&#39;Iterator result interface is not an object.&#39;));</span>
<span class="line-modified">!             return promise;</span>
          }
  
<span class="line-modified">!         var resultDone = !!returnResult.done;</span>
<span class="line-modified">!         var resultValue = returnResult.value;</span>
<span class="line-modified">!         @resolveWithoutPromise(resultValue,</span>
<span class="line-modified">!             function (result) { @resolvePromiseWithFirstResolvingFunctionCallCheck(promise, { value: result, done: resultDone }); },</span>
<span class="line-modified">!             function (error) { @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, error); });</span>
      } catch (e) {
<span class="line-modified">!         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, e);</span>
      }
  
<span class="line-modified">!     return promise;</span>
  }
  
  function throw(exception)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     var promise = @newPromise();</span>
  
      if (!@isObject(this) || !@isObject(@getByIdDirectPrivate(this, &quot;syncIterator&quot;))) {
<span class="line-modified">!         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, @makeTypeError(&#39;Iterator is not an object.&#39;));</span>
<span class="line-modified">!         return promise;</span>
      }
  
<span class="line-modified">!     var syncIterator = @getByIdDirectPrivate(this, &quot;syncIterator&quot;);</span>
  
<span class="line-modified">!     var throwMethod;</span>
  
      try {
          throwMethod = syncIterator.throw;
      } catch (e) {
<span class="line-modified">!         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, e);</span>
<span class="line-modified">!         return promise;</span>
      }
  
      if (throwMethod === @undefined) {
<span class="line-modified">!         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, exception);</span>
<span class="line-modified">!         return promise;</span>
      }
      
      try {
<span class="line-modified">!         var throwResult = throwMethod.@call(syncIterator, exception);</span>
          
          if (!@isObject(throwResult)) {
<span class="line-modified">!             @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, @makeTypeError(&#39;Iterator result interface is not an object.&#39;));</span>
<span class="line-modified">!             return promise;</span>
          }
          
<span class="line-modified">!         var throwDone = !!throwResult.done;</span>
<span class="line-modified">!         var throwValue = throwResult.value;</span>
<span class="line-modified">!         @resolveWithoutPromise(throwValue,</span>
<span class="line-modified">!             function (result) { @resolvePromiseWithFirstResolvingFunctionCallCheck(promise, { value: result, done: throwDone }); },</span>
<span class="line-modified">!             function (error) { @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, error); });</span>
      } catch (e) {
<span class="line-modified">!         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, e);</span>
      }
      
<span class="line-modified">!     return promise;</span>
  }
  
  @globalPrivate
  function createAsyncFromSyncIterator(syncIterator, nextMethod)
  {
</pre>
<center><a href="ArrayPrototype.js.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AsyncFunctionPrototype.js.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
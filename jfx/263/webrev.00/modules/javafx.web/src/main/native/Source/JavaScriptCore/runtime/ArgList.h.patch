diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArgList.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArgList.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArgList.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArgList.h
@@ -131,10 +131,21 @@
         return Base::hasOverflowed();
     }
 
     void overflowCheckNotNeeded() { clearNeedsOverflowCheck(); }
 
+    template<typename Functor>
+    void fill(size_t count, const Functor& func)
+    {
+        ASSERT(!m_size);
+        ensureCapacity(count);
+        if (Base::hasOverflowed())
+            return;
+        m_size = count;
+        func(reinterpret_cast<JSValue*>(&slotFor(0)));
+    }
+
 private:
     void expandCapacity();
     void expandCapacity(int newCapacity);
     void slowEnsureCapacity(size_t requestedCapacity);
 
@@ -152,19 +163,19 @@
         if (m_buffer == m_inlineBuffer)
             return 0;
         return &slotFor(0);
     }
 
-#if ASSERT_DISABLED
-    void setNeedsOverflowCheck() { }
-    void clearNeedsOverflowCheck() { }
-#else
+#if ASSERT_ENABLED
     void setNeedsOverflowCheck() { m_needsOverflowCheck = true; }
     void clearNeedsOverflowCheck() { m_needsOverflowCheck = false; }
 
     bool m_needsOverflowCheck { false };
-#endif
+#else
+    void setNeedsOverflowCheck() { }
+    void clearNeedsOverflowCheck() { }
+#endif // ASSERT_ENABLED
     int m_size;
     int m_capacity;
     EncodedJSValue m_inlineBuffer[inlineCapacity];
     EncodedJSValue* m_buffer;
     ListSet* m_markSet;
@@ -179,13 +190,13 @@
         : m_args(0)
         , m_argCount(0)
     {
     }
 
-    ArgList(ExecState* exec)
-        : m_args(reinterpret_cast<JSValue*>(&exec[CallFrame::argumentOffset(0)]))
-        , m_argCount(exec->argumentCount())
+    ArgList(CallFrame* callFrame)
+        : m_args(reinterpret_cast<JSValue*>(&callFrame[CallFrame::argumentOffset(0)]))
+        , m_argCount(callFrame->argumentCount())
     {
     }
 
     ArgList(const MarkedArgumentBuffer& args)
         : m_args(reinterpret_cast<JSValue*>(args.m_buffer))

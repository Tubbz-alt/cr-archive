<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/BitmapImage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AudioTrackPrivate.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BitmapImage.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/BitmapImage.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;BitmapImage.h&quot;
 29 
 30 #include &quot;FloatRect.h&quot;
 31 #include &quot;GraphicsContext.h&quot;
 32 #include &quot;ImageBuffer.h&quot;
 33 #include &quot;ImageObserver.h&quot;
 34 #include &quot;IntRect.h&quot;
 35 #include &quot;Logging.h&quot;
 36 #include &quot;Settings.h&quot;
 37 #include &quot;Timer.h&quot;
 38 #include &lt;wtf/Vector.h&gt;
 39 #include &lt;wtf/text/TextStream.h&gt;
 40 #include &lt;wtf/text/WTFString.h&gt;
 41 




 42 namespace WebCore {
 43 
 44 BitmapImage::BitmapImage(ImageObserver* observer)
 45     : Image(observer)
 46     , m_source(ImageSource::create(this))
 47 {
 48 }
 49 
 50 BitmapImage::BitmapImage(NativeImagePtr&amp;&amp; image, ImageObserver* observer)
 51     : Image(observer)
 52     , m_source(ImageSource::create(WTFMove(image)))
 53 {
 54 }
 55 
 56 BitmapImage::~BitmapImage()
 57 {
 58     invalidatePlatformData();
 59     clearTimer();
 60     m_source-&gt;clearImage();
 61     m_source-&gt;stopAsyncDecodingQueue();
</pre>
<hr />
<pre>
130         invalidatePlatformData();
131     }
132 #if USE(DIRECT2D)
133     m_source-&gt;setTargetContext(targetContext);
134 #else
135     UNUSED_PARAM(targetContext);
136 #endif
137     return m_source-&gt;frameImageAtIndexCacheIfNeeded(index, subsamplingLevel);
138 }
139 
140 NativeImagePtr BitmapImage::nativeImage(const GraphicsContext* targetContext)
141 {
142     return frameImageAtIndexCacheIfNeeded(0, SubsamplingLevel::Default, targetContext);
143 }
144 
145 NativeImagePtr BitmapImage::nativeImageForCurrentFrame(const GraphicsContext* targetContext)
146 {
147     return frameImageAtIndexCacheIfNeeded(m_currentFrame, SubsamplingLevel::Default, targetContext);
148 }
149 


























150 #if USE(CG)
151 NativeImagePtr BitmapImage::nativeImageOfSize(const IntSize&amp; size, const GraphicsContext* targetContext)
152 {
153     size_t count = frameCount();
154 
155     for (size_t i = 0; i &lt; count; ++i) {
156         auto image = frameImageAtIndexCacheIfNeeded(i, SubsamplingLevel::Default, targetContext);
157         if (image &amp;&amp; nativeImageSize(image) == size)
158             return image;
159     }
160 
161     // Fallback to the first frame image if we can&#39;t find the right size
162     return frameImageAtIndexCacheIfNeeded(0, SubsamplingLevel::Default, targetContext);
163 }
164 
165 Vector&lt;NativeImagePtr&gt; BitmapImage::framesNativeImages()
166 {
167     Vector&lt;NativeImagePtr&gt; images;
168     size_t count = frameCount();
169 
170     for (size_t i = 0; i &lt; count; ++i) {
171         if (auto image = frameImageAtIndexCacheIfNeeded(i))
172             images.append(image);
173     }
174 
175     return images;
176 }
177 #endif
178 
<span class="line-modified">179 #if !ASSERT_DISABLED</span>
180 bool BitmapImage::notSolidColor()
181 {
182     return size().width() != 1 || size().height() != 1 || frameCount() &gt; 1;
183 }
<span class="line-modified">184 #endif</span>
185 
186 ImageDrawResult BitmapImage::draw(GraphicsContext&amp; context, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; options)
187 {
188     if (destRect.isEmpty() || srcRect.isEmpty())
189         return ImageDrawResult::DidNothing;
190 
191     FloatSize scaleFactorForDrawing = context.scaleFactorForDrawing(destRect, srcRect);
192     IntSize sizeForDrawing = expandedIntSize(size() * scaleFactorForDrawing);
193     ImageDrawResult result = ImageDrawResult::DidDraw;
194 
195     m_currentSubsamplingLevel = m_allowSubsampling ? subsamplingLevelForScaleFactor(context, scaleFactorForDrawing) : SubsamplingLevel::Default;
196     LOG(Images, &quot;BitmapImage::%s - %p - url: %s [subsamplingLevel = %d scaleFactorForDrawing = (%.4f, %.4f)]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data(), static_cast&lt;int&gt;(m_currentSubsamplingLevel), scaleFactorForDrawing.width(), scaleFactorForDrawing.height());
197 
198     NativeImagePtr image;
199     if (options.decodingMode() == DecodingMode::Asynchronous) {
200         ASSERT(!canAnimate());
201         ASSERT(!m_currentFrame || m_animationFinished);
202 
203         bool frameIsCompatible = frameHasDecodedNativeImageCompatibleWithOptionsAtIndex(m_currentFrame, m_currentSubsamplingLevel, DecodingOptions(sizeForDrawing));
204         bool frameIsBeingDecoded = frameIsBeingDecodedAndIsCompatibleWithOptionsAtIndex(m_currentFrame, DecodingOptions(sizeForDrawing));
</pre>
<hr />
<pre>
274         drawNativeImage(image, context, destRect, srcRect, IntSize(size()), options);
275 
276     m_currentFrameDecodingStatus = frameDecodingStatusAtIndex(m_currentFrame);
277 
278     if (imageObserver())
279         imageObserver()-&gt;didDraw(*this);
280 
281     return result;
282 }
283 
284 void BitmapImage::drawPattern(GraphicsContext&amp; ctxt, const FloatRect&amp; destRect, const FloatRect&amp; tileRect, const AffineTransform&amp; transform, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; options)
285 {
286     if (tileRect.isEmpty())
287         return;
288 
289     if (!ctxt.drawLuminanceMask()) {
290         // If new data is received, the current incomplete decoded frame has to be destroyed.
291         if (m_currentFrameDecodingStatus == DecodingStatus::Invalid)
292             m_source-&gt;destroyIncompleteDecodedData();
293 
<span class="line-modified">294         Image::drawPattern(ctxt, destRect, tileRect, transform, phase, spacing, options);</span>
295         m_currentFrameDecodingStatus = frameDecodingStatusAtIndex(m_currentFrame);
296         return;
297     }
298 
299     if (!m_cachedImage) {
<span class="line-modified">300         auto buffer = ImageBuffer::createCompatibleBuffer(expandedIntSize(tileRect.size()), ColorSpaceSRGB, ctxt);</span>
301         if (!buffer)
302             return;
303 
304         ImageObserver* observer = imageObserver();
305 
306         // Temporarily reset image observer, we don&#39;t want to receive any changeInRect() calls due to this relayout.
307         setImageObserver(nullptr);
308 
<span class="line-modified">309         draw(buffer-&gt;context(), tileRect, tileRect, { options, DecodingMode::Synchronous, ImageOrientation::None });</span>
310 
311         setImageObserver(observer);
312         buffer-&gt;convertToLuminanceMask();
313 
314         m_cachedImage = ImageBuffer::sinkIntoImage(WTFMove(buffer), PreserveResolution::Yes);
315         if (!m_cachedImage)
316             return;
317     }
318 
319     ctxt.setDrawLuminanceMask(false);
<span class="line-modified">320     m_cachedImage-&gt;drawPattern(ctxt, destRect, tileRect, transform, phase, spacing, options);</span>
321 }
322 
323 bool BitmapImage::shouldAnimate() const
324 {
325     return repetitionCount() &amp;&amp; !m_animationFinished &amp;&amp; imageObserver();
326 }
327 
328 bool BitmapImage::canAnimate() const
329 {
330     return shouldAnimate() &amp;&amp; frameCount() &gt; 1;
331 }
332 
333 bool BitmapImage::canUseAsyncDecodingForLargeImages() const
334 {
335     return !canAnimate() &amp;&amp; m_source-&gt;canUseAsyncDecoding();
336 }
337 
338 bool BitmapImage::shouldUseAsyncDecodingForAnimatedImages() const
339 {
340     return canAnimate() &amp;&amp; m_allowAnimatedImageAsyncDecoding &amp;&amp; (shouldUseAsyncDecodingForTesting() || m_source-&gt;canUseAsyncDecoding());
</pre>
</td>
<td>
<hr />
<pre>
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;BitmapImage.h&quot;
 29 
 30 #include &quot;FloatRect.h&quot;
 31 #include &quot;GraphicsContext.h&quot;
 32 #include &quot;ImageBuffer.h&quot;
 33 #include &quot;ImageObserver.h&quot;
 34 #include &quot;IntRect.h&quot;
 35 #include &quot;Logging.h&quot;
 36 #include &quot;Settings.h&quot;
 37 #include &quot;Timer.h&quot;
 38 #include &lt;wtf/Vector.h&gt;
 39 #include &lt;wtf/text/TextStream.h&gt;
 40 #include &lt;wtf/text/WTFString.h&gt;
 41 
<span class="line-added"> 42 #if USE(CG)</span>
<span class="line-added"> 43 #include &lt;pal/spi/cg/CoreGraphicsSPI.h&gt;</span>
<span class="line-added"> 44 #endif</span>
<span class="line-added"> 45 </span>
 46 namespace WebCore {
 47 
 48 BitmapImage::BitmapImage(ImageObserver* observer)
 49     : Image(observer)
 50     , m_source(ImageSource::create(this))
 51 {
 52 }
 53 
 54 BitmapImage::BitmapImage(NativeImagePtr&amp;&amp; image, ImageObserver* observer)
 55     : Image(observer)
 56     , m_source(ImageSource::create(WTFMove(image)))
 57 {
 58 }
 59 
 60 BitmapImage::~BitmapImage()
 61 {
 62     invalidatePlatformData();
 63     clearTimer();
 64     m_source-&gt;clearImage();
 65     m_source-&gt;stopAsyncDecodingQueue();
</pre>
<hr />
<pre>
134         invalidatePlatformData();
135     }
136 #if USE(DIRECT2D)
137     m_source-&gt;setTargetContext(targetContext);
138 #else
139     UNUSED_PARAM(targetContext);
140 #endif
141     return m_source-&gt;frameImageAtIndexCacheIfNeeded(index, subsamplingLevel);
142 }
143 
144 NativeImagePtr BitmapImage::nativeImage(const GraphicsContext* targetContext)
145 {
146     return frameImageAtIndexCacheIfNeeded(0, SubsamplingLevel::Default, targetContext);
147 }
148 
149 NativeImagePtr BitmapImage::nativeImageForCurrentFrame(const GraphicsContext* targetContext)
150 {
151     return frameImageAtIndexCacheIfNeeded(m_currentFrame, SubsamplingLevel::Default, targetContext);
152 }
153 
<span class="line-added">154 NativeImagePtr BitmapImage::nativeImageForCurrentFrameRespectingOrientation(const GraphicsContext* targetContext)</span>
<span class="line-added">155 {</span>
<span class="line-added">156     auto image = nativeImageForCurrentFrame(targetContext);</span>
<span class="line-added">157 </span>
<span class="line-added">158     ImageOrientation orientation = orientationForCurrentFrame();</span>
<span class="line-added">159     if (orientation == ImageOrientation::None)</span>
<span class="line-added">160         return image;</span>
<span class="line-added">161 </span>
<span class="line-added">162     FloatRect rect = { FloatPoint(), size() };</span>
<span class="line-added">163     auto buffer = ImageBuffer::create(rect.size(), RenderingMode::Unaccelerated);</span>
<span class="line-added">164     if (!buffer)</span>
<span class="line-added">165         return image;</span>
<span class="line-added">166 </span>
<span class="line-added">167 #if USE(CG) || USE(DIRECT2D) || USE(CAIRO)</span>
<span class="line-added">168     buffer-&gt;context().drawNativeImage(image, rect.size(), rect, rect, { orientation });</span>
<span class="line-added">169 #endif</span>
<span class="line-added">170 </span>
<span class="line-added">171 #if USE(CG) || USE(DIRECT2D)</span>
<span class="line-added">172     return ImageBuffer::sinkIntoNativeImage(WTFMove(buffer));</span>
<span class="line-added">173 #elif USE(CAIRO)</span>
<span class="line-added">174     return buffer-&gt;nativeImage();</span>
<span class="line-added">175 #endif</span>
<span class="line-added">176 </span>
<span class="line-added">177     return nullptr;</span>
<span class="line-added">178 }</span>
<span class="line-added">179 </span>
180 #if USE(CG)
181 NativeImagePtr BitmapImage::nativeImageOfSize(const IntSize&amp; size, const GraphicsContext* targetContext)
182 {
183     size_t count = frameCount();
184 
185     for (size_t i = 0; i &lt; count; ++i) {
186         auto image = frameImageAtIndexCacheIfNeeded(i, SubsamplingLevel::Default, targetContext);
187         if (image &amp;&amp; nativeImageSize(image) == size)
188             return image;
189     }
190 
191     // Fallback to the first frame image if we can&#39;t find the right size
192     return frameImageAtIndexCacheIfNeeded(0, SubsamplingLevel::Default, targetContext);
193 }
194 
195 Vector&lt;NativeImagePtr&gt; BitmapImage::framesNativeImages()
196 {
197     Vector&lt;NativeImagePtr&gt; images;
198     size_t count = frameCount();
199 
200     for (size_t i = 0; i &lt; count; ++i) {
201         if (auto image = frameImageAtIndexCacheIfNeeded(i))
202             images.append(image);
203     }
204 
205     return images;
206 }
207 #endif
208 
<span class="line-modified">209 #if ASSERT_ENABLED</span>
210 bool BitmapImage::notSolidColor()
211 {
212     return size().width() != 1 || size().height() != 1 || frameCount() &gt; 1;
213 }
<span class="line-modified">214 #endif // ASSERT_ENABLED</span>
215 
216 ImageDrawResult BitmapImage::draw(GraphicsContext&amp; context, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; options)
217 {
218     if (destRect.isEmpty() || srcRect.isEmpty())
219         return ImageDrawResult::DidNothing;
220 
221     FloatSize scaleFactorForDrawing = context.scaleFactorForDrawing(destRect, srcRect);
222     IntSize sizeForDrawing = expandedIntSize(size() * scaleFactorForDrawing);
223     ImageDrawResult result = ImageDrawResult::DidDraw;
224 
225     m_currentSubsamplingLevel = m_allowSubsampling ? subsamplingLevelForScaleFactor(context, scaleFactorForDrawing) : SubsamplingLevel::Default;
226     LOG(Images, &quot;BitmapImage::%s - %p - url: %s [subsamplingLevel = %d scaleFactorForDrawing = (%.4f, %.4f)]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data(), static_cast&lt;int&gt;(m_currentSubsamplingLevel), scaleFactorForDrawing.width(), scaleFactorForDrawing.height());
227 
228     NativeImagePtr image;
229     if (options.decodingMode() == DecodingMode::Asynchronous) {
230         ASSERT(!canAnimate());
231         ASSERT(!m_currentFrame || m_animationFinished);
232 
233         bool frameIsCompatible = frameHasDecodedNativeImageCompatibleWithOptionsAtIndex(m_currentFrame, m_currentSubsamplingLevel, DecodingOptions(sizeForDrawing));
234         bool frameIsBeingDecoded = frameIsBeingDecodedAndIsCompatibleWithOptionsAtIndex(m_currentFrame, DecodingOptions(sizeForDrawing));
</pre>
<hr />
<pre>
304         drawNativeImage(image, context, destRect, srcRect, IntSize(size()), options);
305 
306     m_currentFrameDecodingStatus = frameDecodingStatusAtIndex(m_currentFrame);
307 
308     if (imageObserver())
309         imageObserver()-&gt;didDraw(*this);
310 
311     return result;
312 }
313 
314 void BitmapImage::drawPattern(GraphicsContext&amp; ctxt, const FloatRect&amp; destRect, const FloatRect&amp; tileRect, const AffineTransform&amp; transform, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; options)
315 {
316     if (tileRect.isEmpty())
317         return;
318 
319     if (!ctxt.drawLuminanceMask()) {
320         // If new data is received, the current incomplete decoded frame has to be destroyed.
321         if (m_currentFrameDecodingStatus == DecodingStatus::Invalid)
322             m_source-&gt;destroyIncompleteDecodedData();
323 
<span class="line-modified">324         Image::drawPattern(ctxt, destRect, tileRect, transform, phase, spacing, { options, ImageOrientation::FromImage });</span>
325         m_currentFrameDecodingStatus = frameDecodingStatusAtIndex(m_currentFrame);
326         return;
327     }
328 
329     if (!m_cachedImage) {
<span class="line-modified">330         auto buffer = ImageBuffer::createCompatibleBuffer(expandedIntSize(tileRect.size()), ColorSpace::SRGB, ctxt);</span>
331         if (!buffer)
332             return;
333 
334         ImageObserver* observer = imageObserver();
335 
336         // Temporarily reset image observer, we don&#39;t want to receive any changeInRect() calls due to this relayout.
337         setImageObserver(nullptr);
338 
<span class="line-modified">339         draw(buffer-&gt;context(), tileRect, tileRect, { options, DecodingMode::Synchronous, ImageOrientation::FromImage });</span>
340 
341         setImageObserver(observer);
342         buffer-&gt;convertToLuminanceMask();
343 
344         m_cachedImage = ImageBuffer::sinkIntoImage(WTFMove(buffer), PreserveResolution::Yes);
345         if (!m_cachedImage)
346             return;
347     }
348 
349     ctxt.setDrawLuminanceMask(false);
<span class="line-modified">350     m_cachedImage-&gt;drawPattern(ctxt, destRect, tileRect, transform, phase, spacing, { options, ImageOrientation::FromImage });</span>
351 }
352 
353 bool BitmapImage::shouldAnimate() const
354 {
355     return repetitionCount() &amp;&amp; !m_animationFinished &amp;&amp; imageObserver();
356 }
357 
358 bool BitmapImage::canAnimate() const
359 {
360     return shouldAnimate() &amp;&amp; frameCount() &gt; 1;
361 }
362 
363 bool BitmapImage::canUseAsyncDecodingForLargeImages() const
364 {
365     return !canAnimate() &amp;&amp; m_source-&gt;canUseAsyncDecoding();
366 }
367 
368 bool BitmapImage::shouldUseAsyncDecodingForAnimatedImages() const
369 {
370     return canAnimate() &amp;&amp; m_allowAnimatedImageAsyncDecoding &amp;&amp; (shouldUseAsyncDecodingForTesting() || m_source-&gt;canUseAsyncDecoding());
</pre>
</td>
</tr>
</table>
<center><a href="AudioTrackPrivate.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BitmapImage.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
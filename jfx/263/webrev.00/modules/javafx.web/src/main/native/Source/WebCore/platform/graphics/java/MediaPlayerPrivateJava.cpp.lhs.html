<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/java/MediaPlayerPrivateJava.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #include &quot;GraphicsContext.h&quot;
 29 #include &quot;PlatformJavaClasses.h&quot;
 30 #include &quot;MediaPlayerPrivateJava.h&quot;
 31 #include &quot;NotImplemented.h&quot;
 32 #include &quot;PlatformContextJava.h&quot;
 33 
 34 #include &quot;Document.h&quot;
 35 #include &quot;Settings.h&quot;
 36 
 37 #include &lt;wtf/text/CString.h&gt; // todo tav remove when building w/ pch
 38 
 39 #include &quot;com_sun_webkit_graphics_WCMediaPlayer.h&quot;
 40 #include &quot;com_sun_webkit_graphics_GraphicsDecoder.h&quot;
 41 
 42 
 43 namespace WebCore {
 44 
 45 
 46 ///////////////////////// log support
 47 
 48 #if defined(NDEBUG)
 49 
 50     #define LOG_TRACE0(szFormat)                    ((void)0)
 51     #define LOG_TRACE1(szFormat, p1)                ((void)0)
 52     #define LOG_TRACE2(szFormat, p1, p2)            ((void)0)
 53     #define LOG_TRACE3(szFormat, p1, p2, p3)        ((void)0)
 54     #define LOG_TRACE4(szFormat, p1, p2, p3, p4)    ((void)0)
 55 
 56     #define LOG_ERROR0(szFormat)                    ((void)0)
 57     #define LOG_ERROR1(szFormat, p1)                ((void)0)
 58 
 59     #define PLOG_TRACE0(szFormat)                    ((void)0)
 60     #define PLOG_TRACE1(szFormat, p1)                ((void)0)
 61     #define PLOG_TRACE2(szFormat, p1, p2)            ((void)0)
 62     #define PLOG_TRACE3(szFormat, p1, p2, p3)        ((void)0)
 63     #define PLOG_TRACE4(szFormat, p1, p2, p3, p4)    ((void)0)
 64 
 65     #define PLOG_ERROR0(szFormat)                    ((void)0)
 66     #define PLOG_ERROR1(szFormat, p1)                ((void)0)
 67 
 68 #else
 69 
 70     #include &lt;stdio.h&gt;
 71     #include &lt;wtf/Threading.h&gt;
 72 
 73     const char* networkStateStr(MediaPlayer::NetworkState networkState) {
 74         switch (networkState) {
<a name="1" id="anc1"></a><span class="line-modified"> 75         case MediaPlayer::Empty:</span>
 76             return &quot;Empty&quot;;
<a name="2" id="anc2"></a><span class="line-modified"> 77         case MediaPlayer::Idle:</span>
 78             return &quot;Idle&quot;;
<a name="3" id="anc3"></a><span class="line-modified"> 79         case MediaPlayer::Loading:</span>
 80             return &quot;Loading&quot;;
<a name="4" id="anc4"></a><span class="line-modified"> 81         case MediaPlayer::Loaded:</span>
 82             return &quot;Loaded&quot;;
<a name="5" id="anc5"></a><span class="line-modified"> 83         case MediaPlayer::FormatError:</span>
 84             return &quot;FormatError&quot;;
<a name="6" id="anc6"></a><span class="line-modified"> 85         case MediaPlayer::NetworkError:</span>
 86             return &quot;NetworkError&quot;;
<a name="7" id="anc7"></a><span class="line-modified"> 87         case MediaPlayer::DecodeError:</span>
 88             return &quot;DecodeError&quot;;
 89         }
 90         return &quot;&lt;unknown network state&gt;&quot;;
 91     }
 92 
 93     const char* readyStateStr(MediaPlayer::ReadyState readyState) {
 94         switch (readyState) {
<a name="8" id="anc8"></a><span class="line-modified"> 95         case MediaPlayer::HaveNothing:</span>
 96             return &quot;HaveNothing&quot;;
<a name="9" id="anc9"></a><span class="line-modified"> 97         case MediaPlayer::HaveMetadata:</span>
 98             return &quot;HaveMetadata&quot;;
<a name="10" id="anc10"></a><span class="line-modified"> 99         case MediaPlayer::HaveCurrentData:</span>
100             return &quot;HaveCurrentData&quot;;
<a name="11" id="anc11"></a><span class="line-modified">101         case MediaPlayer::HaveFutureData:</span>
102             return &quot;HaveFutureData&quot;;
<a name="12" id="anc12"></a><span class="line-modified">103         case MediaPlayer::HaveEnoughData:</span>
104             return &quot;HaveEnoughData&quot;;
105         }
106         return &quot;&lt;unknown ready state&gt;&quot;;
107     }
108 
109     namespace Logger {
110 
111         FILE* getLogStream() {
112             FILE *stream = stderr;
113             //FILE *stream = fopen(&quot;webVideo.log&quot;, &quot;a&quot;);
114             return stream;
115         }
116 
117         void releaseLogStream(FILE *stream) {
118             fflush(stream);
119             //fclose(stream);
120         }
121 
122         void AMLogf(const char* szLevel, const char* szFormat, ...) {
123             FILE *stream = getLogStream();
124             fprintf(stream, &quot;[%s (native)] &quot;, szLevel);
125             va_list args;
126             va_start(args, szFormat);
127             vfprintf(stream, szFormat, args);
128             releaseLogStream(stream);
129         }
130 
131         void AMLogf_p(const MediaPlayerPrivate *p, const char* szLevel, const char* szFormat, ...) {
132             FILE *stream = getLogStream();
133             fprintf(stream, &quot;[%s (native),states:(%s,%s), paused:%d, seeking:%d, pos:%f/%f]&quot;,
134                 szLevel, networkStateStr(p-&gt;networkState()), readyStateStr(p-&gt;readyState()),
135                 (p-&gt;paused() ? 1 : 0), (p-&gt;seeking() ? 1 : 0),
136                 p-&gt;currentTime(), p-&gt;duration());
137             va_list args;
138             va_start(args, szFormat);
139             vfprintf(stream, szFormat, args);
140             releaseLogStream(stream);
141         }
142     }
143 
144     #define LOG_TRACE0(szFormat)                    Logger::AMLogf(&quot;INFO&quot;, szFormat)
145     #define LOG_TRACE1(szFormat, p1)                Logger::AMLogf(&quot;INFO&quot;, szFormat, p1)
146     #define LOG_TRACE2(szFormat, p1, p2)            Logger::AMLogf(&quot;INFO&quot;, szFormat, p1, p2)
147     #define LOG_TRACE3(szFormat, p1, p2, p3)        Logger::AMLogf(&quot;INFO&quot;, szFormat, p1, p2, p3)
148     #define LOG_TRACE4(szFormat, p1, p2, p3, p4)    Logger::AMLogf(&quot;INFO&quot;, szFormat, p1, p2, p3, p4)
149 
150     #define LOG_ERROR0(szFormat)                    Logger::AMLogf(&quot;SEVERE&quot;, szFormat)
151     #define LOG_ERROR1(szFormat, p1)                Logger::AMLogf(&quot;SEVERE&quot;, szFormat, p1)
152 
153     #define PLOG_TRACE0(szFormat)                   Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat)
154     #define PLOG_TRACE1(szFormat, p1)               Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat, p1)
155     #define PLOG_TRACE2(szFormat, p1, p2)           Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat, p1, p2)
156     #define PLOG_TRACE3(szFormat, p1, p2, p3)       Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat, p1, p2, p3)
157     #define PLOG_TRACE4(szFormat, p1, p2, p3, p4)   Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat, p1, p2, p3, p4)
158 
159     #define PLOG_ERROR0(szFormat)                   Logger::AMLogf_p(this, &quot;SEVERE&quot;, szFormat)
160     #define PLOG_ERROR1(szFormat, p1)               Logger::AMLogf_p(this, &quot;SEVERE&quot;, szFormat, p1)
161 
162 #endif
163 
164 ////////////////////////
165 
<a name="13" id="anc13"></a>


166 
<a name="14" id="anc14"></a>



167 
<a name="15" id="anc15"></a>









168 
169 void MediaPlayerPrivate::registerMediaEngine(MediaEngineRegistrar registrar)
170 {
171     LOG_TRACE0(&quot;&gt;&gt;registerMediaEngine\n&quot;);
172     JNIEnv* env = WTF::GetJavaEnv();
173     jclass playerCls = PG_GetMediaPlayerClass(env);
174     if (!playerCls) {
175         LOG_ERROR0(&quot;&lt;&lt;registerMediaEngine ERROR: MediaPlayer class is unavailable\n&quot;);
176         return;
177     }
<a name="16" id="anc16"></a><span class="line-modified">178     //CreateMediaEnginePlayer, MediaEngineSupportedTypes, MediaEngineSupportsType,</span>
<span class="line-modified">179     //MediaEngineGetSitesInMediaCache, MediaEngineClearMediaCache, MediaEngineClearMediaCacheForSite</span>
<span class="line-removed">180     registrar([] (MediaPlayer* player) { return std::unique_ptr&lt;MediaPlayerPrivate&gt;(new MediaPlayerPrivate(player)); },</span>
<span class="line-removed">181         MediaEngineSupportedTypes, MediaEngineSupportsType, 0, 0, 0, 0);</span>
182 }
183 
184 void MediaPlayerPrivate::MediaEngineSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; types)
185 {
186     LOG_TRACE0(&quot;&gt;&gt;MediaEngineSupportedTypes\n&quot;);
187     HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; supportedTypes = GetSupportedTypes();
188     for (const auto&amp; type : supportedTypes) {
189         types.add(type);
190     }
191     LOG_TRACE0(&quot;&lt;&lt;MediaEngineSupportedTypes\n&quot;);
192 }
193 
194 MediaPlayer::SupportsType MediaPlayerPrivate::MediaEngineSupportsType(const MediaEngineSupportParameters&amp; parameters)
195 {
196     for (const auto&amp; codecValue: parameters.type.codecs()) {
197         UNUSED_PARAM(codecValue);
198         LOG_TRACE2(&quot;&gt;&gt;MediaEngineSupportsType, type=%s, codecs=%s\n&quot;, parameters.type.raw().utf8().data(), codecValue.utf8().data());
199     }
200 
201     if (parameters.type.isEmpty()) {
202         LOG_TRACE0(&quot;&lt;&lt;MediaEngineSupportsType: NOT supported (type is empty)\n&quot;);
<a name="17" id="anc17"></a><span class="line-modified">203         return MediaPlayer::IsNotSupported;</span>
204     }
205 
206     if (GetSupportedTypes().contains(parameters.type.containerType())) {
207         LOG_TRACE0(&quot;&lt;&lt;MediaEngineSupportsType: MayBeSupported/IsSupported\n&quot;);
208         auto codecs = parameters.type.parameter(ContentType::codecsParameter());
<a name="18" id="anc18"></a><span class="line-modified">209         return codecs.isEmpty() ? MediaPlayer::MayBeSupported : MediaPlayer::IsSupported;</span>
210     }
211     LOG_TRACE0(&quot;&lt;&lt;MediaEngineSupportsType: NOT supported\n&quot;);
<a name="19" id="anc19"></a><span class="line-modified">212     return MediaPlayer::IsNotSupported;</span>
213 }
214 
215 HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; MediaPlayerPrivate::GetSupportedTypes()
216 {
217     static HashSet&lt;String, ASCIICaseInsensitiveHash&gt; supportedTypes;
218     // TODO: refresh after change
219 
220     if (!supportedTypes.isEmpty()) {
221         return supportedTypes;
222     }
223 
224     JNIEnv* env = WTF::GetJavaEnv();
225     static jmethodID s_mID = env-&gt;GetMethodID(PG_GetGraphicsManagerClass(env),
226         &quot;getSupportedMediaTypes&quot;, &quot;()[Ljava/lang/String;&quot;);
227     ASSERT(s_mID);
228 
229     JLocalRef&lt;jobjectArray&gt; jArray(
230         (jobjectArray)env-&gt;CallObjectMethod(PL_GetGraphicsManager(env), s_mID));
231     ASSERT(jArray);
232     WTF::CheckAndClearException(env);
233 
234     jsize len = env-&gt;GetArrayLength(jArray);
235     for (jsize  i=0; i&lt;len; i++) {
236         JLString jStr((jstring)env-&gt;GetObjectArrayElement(jArray, i));
237         String s(env, jStr);
238         supportedTypes.add(s);
239     }
240 
241     return supportedTypes;
242 }
243 
244 
245 // *********************************************************
246 // MediaPlayerPrivate
247 // *********************************************************
248 MediaPlayerPrivate::MediaPlayerPrivate(MediaPlayer *player)
249     : m_player(player)
<a name="20" id="anc20"></a><span class="line-modified">250     , m_networkState(MediaPlayer::Empty)</span>
<span class="line-modified">251     , m_readyState(MediaPlayer::HaveNothing)</span>
252     , m_isVisible(false)
253     , m_hasVideo(false)
254     , m_hasAudio(false)
255     , m_paused(true)
256     , m_seeking(false)
257     , m_seekTime(0)
258     , m_duration(0)
259     , m_bytesLoaded(0)
260     , m_didLoadingProgress(false)
261 {
262     JNIEnv* env = WTF::GetJavaEnv();
263     static jmethodID mid = env-&gt;GetMethodID(PG_GetGraphicsManagerClass(env),
264         &quot;fwkCreateMediaPlayer&quot;, &quot;(J)Lcom/sun/webkit/graphics/WCMediaPlayer;&quot;);
265     ASSERT(mid);
266 
267     JLocalRef&lt;jobject&gt; obj(env-&gt;CallObjectMethod(PL_GetGraphicsManager(env),
268         mid, ptr_to_jlong(this)));
269     ASSERT(obj);
270     WTF::CheckAndClearException(env);
271 
272     m_buffered = std::make_unique&lt;PlatformTimeRanges&gt;();
273     m_jPlayer = RQRef::create(obj);
274 }
275 
276 MediaPlayerPrivate::~MediaPlayerPrivate()
277 {
278     WC_GETJAVAENV_CHKRET(env);
279     static jmethodID s_mID
280         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkDispose&quot;, &quot;()V&quot;);
281     ASSERT(s_mID);
282 
283     env-&gt;CallVoidMethod(*m_jPlayer, s_mID);
284     WTF::CheckAndClearException(env);
285 }
286 
287 void MediaPlayerPrivate::load(const String&amp; url)
288 {
<a name="21" id="anc21"></a><span class="line-modified">289     if (m_networkState == MediaPlayer::Loading) {</span>
290         cancelLoad();
291     }
292 
293     String userAgent;
294     // MediaPlayerClient mpClient = m_player-&gt;client();
295     // Document* doc = mpClient.mediaPlayerOwningDocument(); //XXX: mediaPlayerOwningDocument removed
296     // if (doc != NULL &amp;&amp; doc-&gt;settings() != NULL) {
297     //     userAgent = doc-&gt;settings()-&gt;userAgent();
298     // }
299 
300     JNIEnv* env = WTF::GetJavaEnv();
301     static jmethodID s_mID
302         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkLoad&quot;, &quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;);
303     ASSERT(s_mID);
304 
305     env-&gt;CallVoidMethod(*m_jPlayer, s_mID,
306         (jstring)url.toJavaString(env),
307         userAgent.isEmpty() ? NULL : (jstring)userAgent.toJavaString(env));
308     WTF::CheckAndClearException(env);
309 }
310 
311 void MediaPlayerPrivate::cancelLoad()
312 {
313     m_paused = true;
314     m_seeking = false;
315 
316     JNIEnv* env = WTF::GetJavaEnv();
317     static jmethodID s_mID
318         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkCancelLoad&quot;, &quot;()V&quot;);
319     ASSERT(s_mID);
320 
321     env-&gt;CallVoidMethod(*m_jPlayer, s_mID);
322     WTF::CheckAndClearException(env);
323 }
324 
325 void MediaPlayerPrivate::prepareToPlay()
326 {
327     JNIEnv* env = WTF::GetJavaEnv();
328     static jmethodID s_mID
329         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkPrepareToPlay&quot;, &quot;()V&quot;);
330     ASSERT(s_mID);
331 
332     env-&gt;CallVoidMethod(*m_jPlayer, s_mID);
333     WTF::CheckAndClearException(env);
334 }
335 
336 //PlatformMedia MediaPlayerPrivate::platformMedia() const { return NoPlatformMedia; }
337 
338 //#if USE(ACCELERATED_COMPOSITING)
339 //        PlatformLayer* MediaPlayerPrivate::platformLayer() const { return 0; }
340 //#endif
341 
342 void MediaPlayerPrivate::play()
343 {
344     PLOG_TRACE0(&quot;&gt;&gt;MediaPlayerPrivate::play\n&quot;);
345 
346     if (!paused()) {
347         PLOG_TRACE0(&quot;&lt;&lt;MediaPlayerPrivate::play - already playing\n&quot;);
348         return;
349     }
350 
351     JNIEnv* env = WTF::GetJavaEnv();
352     static jmethodID s_mID
353         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkPlay&quot;, &quot;()V&quot;);
354     ASSERT(s_mID);
355 
356     env-&gt;CallVoidMethod(*m_jPlayer, s_mID);
357     WTF::CheckAndClearException(env);
358 
359     PLOG_TRACE0(&quot;&lt;&lt;MediaPlayerPrivate::play\n&quot;);
360 }
361 
362 void MediaPlayerPrivate::pause()
363 {
364     if (paused()) {
365         return;
366     }
367 
368     JNIEnv* env = WTF::GetJavaEnv();
369     static jmethodID s_mID
370         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkPause&quot;, &quot;()V&quot;);
371     ASSERT(s_mID);
372 
373     env-&gt;CallVoidMethod(*m_jPlayer, s_mID);
374     WTF::CheckAndClearException(env);
375 }
376 
377 //bool MediaPlayerPrivate::supportsFullscreen() const { return false; }
378 //bool MediaPlayerPrivate::supportsSave() const { return false; }
379 
380 FloatSize MediaPlayerPrivate::naturalSize() const
381 {
382 //    PLOG_TRACE2(&quot;MediaPlayerPrivate naturalSize - return %d x %d\n&quot;, m_naturalSize.width(), m_naturalSize.height());
383     return m_naturalSize;
384 }
385 
386 bool MediaPlayerPrivate::hasVideo() const
387 {
388 //    PLOG_TRACE1(&quot;MediaPlayerPrivate hasVideo - return %d\n&quot;, m_hasVideo ? 1 : 0);
389     return m_hasVideo;
390 }
391 
392 bool MediaPlayerPrivate::hasAudio() const
393 {
394 //    PLOG_TRACE1(&quot;MediaPlayerPrivate hasAudio - return %d\n&quot;, m_hasAudio ? 1 : 0);
395     return m_hasAudio;
396 }
397 
398 void MediaPlayerPrivate::setVisible(bool visible)
399 {
400     if (m_isVisible != visible) {
401         PLOG_TRACE2(&quot;MediaPlayerPrivate setVisible: %d =&gt; %d\n&quot;, m_isVisible ? 1 : 0, visible ? 1 : 0);
402         m_isVisible = visible;
403     }
404 }
405 
406 float MediaPlayerPrivate::duration() const
407 {
408     // return numeric_limits&lt;float&gt;::infinity(); // &quot;live&quot; stream
409     return m_duration;
410 }
411 
412 float MediaPlayerPrivate::currentTime() const
413 {
414     if (m_seeking) {
415         LOG_TRACE1(&quot;MediaPlayerPrivate currentTime returns (seekTime): %f\n&quot;, m_seekTime);
416         return m_seekTime;
417     }
418     JNIEnv* env = WTF::GetJavaEnv();
419     static jmethodID s_mID
420         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkGetCurrentTime&quot;, &quot;()F&quot;);
421     ASSERT(s_mID);
422 
423     double result = env-&gt;CallFloatMethod(*m_jPlayer, s_mID);
424     WTF::CheckAndClearException(env);
425 
426 //    LOG_TRACE1(&quot;MediaPlayerPrivate currentTime returns: %f\n&quot;, (float)result);
427 
428     return (float)result;
429 }
430 
431 void MediaPlayerPrivate::seek(float time)
432 {
433     PLOG_TRACE1(&quot;&gt;&gt;MediaPlayerPrivate::seek(%f)\n&quot;, time);
434 
435     m_seekTime = time;
436 
437     JNIEnv* env = WTF::GetJavaEnv();
438     static jmethodID s_mID
439         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkSeek&quot;, &quot;(F)V&quot;);
440     ASSERT(s_mID);
441 
442     env-&gt;CallVoidMethod(*m_jPlayer, s_mID, time);
443     WTF::CheckAndClearException(env);
444 
445     PLOG_TRACE1(&quot;&lt;&lt;MediaPlayerPrivate::seek(%f)\n&quot;, time);
446 }
447 
448 bool MediaPlayerPrivate::seeking() const
449 {
450     return m_seeking;
451 }
452 
453 MediaTime MediaPlayerPrivate::startTime() const
454 {
455     // always 0
456     return MediaTime::zeroTime();
457 }
458 
459 void MediaPlayerPrivate::setRate(float rate)
460 {
461     JNIEnv* env = WTF::GetJavaEnv();
462     static jmethodID s_mID
463         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkSetRate&quot;, &quot;(F)V&quot;);
464     ASSERT(s_mID);
465 
466     env-&gt;CallVoidMethod(*m_jPlayer, s_mID, rate);
467     WTF::CheckAndClearException(env);
468 }
469 
470 void MediaPlayerPrivate::setPreservesPitch(bool preserve)
471 {
472     JNIEnv* env = WTF::GetJavaEnv();
473     static jmethodID s_mID
474         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkSetPreservesPitch&quot;, &quot;(Z)V&quot;);
475     ASSERT(s_mID);
476 
477     env-&gt;CallVoidMethod(*m_jPlayer, s_mID, bool_to_jbool(preserve));
478     WTF::CheckAndClearException(env);
479 }
480 
481 bool MediaPlayerPrivate::paused() const
482 {
483     return m_paused;
484 }
485 
486 void MediaPlayerPrivate::setVolume(float volume)
487 {
488     JNIEnv* env = WTF::GetJavaEnv();
489     static jmethodID s_mID
490         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkSetVolume&quot;, &quot;(F)V&quot;);
491     ASSERT(s_mID);
492 
493     env-&gt;CallVoidMethod(*m_jPlayer, s_mID, volume);
494     WTF::CheckAndClearException(env);
495 }
496 
497 bool MediaPlayerPrivate::supportsMuting() const
498 {
499     return true;
500 }
501 
502 void MediaPlayerPrivate::setMuted(bool mute)
503 {
504     JNIEnv* env = WTF::GetJavaEnv();
505     static jmethodID
506         s_mID = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkSetMute&quot;, &quot;(Z)V&quot;);
507     ASSERT(s_mID);
508 
509     env-&gt;CallVoidMethod(*m_jPlayer, s_mID, bool_to_jbool(mute));
510     WTF::CheckAndClearException(env);
511 }
512 
513 //bool MediaPlayerPrivate::hasClosedCaptions() const { return false; }
514 //void MediaPlayerPrivate::setClosedCaptionsVisible(bool) { }
515 
516 MediaPlayer::NetworkState MediaPlayerPrivate::networkState() const
517 {
518 //    LOG_TRACE1(&quot;MediaPlayerPrivate networkState - return %d\n&quot;, (int)m_networkState);
519     return m_networkState;
520 }
521 
522 MediaPlayer::ReadyState MediaPlayerPrivate::readyState() const
523 {
524 //    LOG_TRACE1(&quot;MediaPlayerPrivate readyState - return %d\n&quot;, (int)m_readyState);
525     return m_readyState;
526 }
527 
528 float MediaPlayerPrivate::maxTimeSeekable() const
529 {
530     return m_duration;
531 }
532 
533 bool MediaPlayerPrivate::didLoadingProgress() const
534 {
535     bool didLoadingProgress = m_didLoadingProgress;
536     m_didLoadingProgress = false;
537     PLOG_TRACE1(&quot;MediaPlayerPrivate didLoadingProgress - returning %d&quot;, didLoadingProgress ? 1 : 0);
538     return didLoadingProgress;
539 }
540 
541 std::unique_ptr&lt;PlatformTimeRanges&gt; MediaPlayerPrivate::buffered() const
542 {
543     return std::make_unique&lt;PlatformTimeRanges&gt;(); //XXX recheck; USE m_buffered
544 }
545 
546 unsigned MediaPlayerPrivate::bytesLoaded() const
547 {
548     return m_bytesLoaded;
549 }
550 
551 void MediaPlayerPrivate::setSize(const IntSize&amp; size)
552 {
553     JNIEnv* env = WTF::GetJavaEnv();
554     static jmethodID s_mID
555         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkSetSize&quot;, &quot;(II)V&quot;);
556     ASSERT(s_mID);
557 
558     env-&gt;CallVoidMethod(*m_jPlayer, s_mID, (jint)size.width(), (jint)size.height());
559     WTF::CheckAndClearException(env);
560 }
561 
562 void MediaPlayerPrivate::paint(GraphicsContext&amp; gc, const FloatRect&amp; r)
563 {
564 //    PLOG_TRACE4(&quot;&gt;&gt;MediaPlayerPrivate paint (%d, %d), [%d x %d]\n&quot;, r.x(), r.y(), r.width(), r.height());
565     if (gc.paintingDisabled()) {
566         PLOG_TRACE0(&quot;&lt;&lt;MediaPlayerPrivate paint (!gc or paintingDisabled)\n&quot;);
567         return;
568     }
569     if (!m_isVisible) {
570         PLOG_TRACE0(&quot;&lt;&lt;MediaPlayerPrivate paint (!visible)\n&quot;);
571         return;
572     }
573 
574     gc.platformContext()-&gt;rq().freeSpace(24)
575     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_RENDERMEDIAPLAYER
576     &lt;&lt; m_jPlayer &lt;&lt; (jint)r.x() &lt;&lt;  (jint)r.y()
577     &lt;&lt; (jint)r.width() &lt;&lt; (jint)r.height();
578 
579 //    PLOG_TRACE0(&quot;&lt;&lt;MediaPlayerPrivate paint (OK)\n&quot;);
580 }
581 
582 //void MediaPlayerPrivate::paintCurrentFrameInContext(GraphicsContext* c, const IntRect&amp; r) { paint(c, r); }
583 
584 void MediaPlayerPrivate::setPreload(MediaPlayer::Preload preload)
585 {
586     // enum Preload { None, MetaData, Auto };
587     PLOG_TRACE1(&quot;MediaPlayerPrivate setPreload, preload=%u\n&quot;, (int)preload);
588     jint jPreload =
<a name="22" id="anc22"></a><span class="line-modified">589         (preload == MediaPlayer::None) ? com_sun_webkit_graphics_WCMediaPlayer_PRELOAD_NONE</span>
<span class="line-modified">590         : (preload == MediaPlayer::MetaData) ? com_sun_webkit_graphics_WCMediaPlayer_PRELOAD_METADATA</span>
<span class="line-modified">591         : (preload == MediaPlayer::Auto) ? com_sun_webkit_graphics_WCMediaPlayer_PRELOAD_AUTO</span>
592         : -1;
593     if (jPreload &lt; 0) {
594         // unexpected preload value
595         return;
596     }
597     JNIEnv* env = WTF::GetJavaEnv();
598     static jmethodID s_mID
599         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkSetPreload&quot;, &quot;(I)V&quot;);
600     ASSERT(s_mID);
601 
602     env-&gt;CallVoidMethod(*m_jPlayer, s_mID, jPreload);
603     WTF::CheckAndClearException(env);
604 }
605 
<a name="23" id="anc23"></a><span class="line-modified">606 //bool MediaPlayerPrivate::hasAvailableVideoFrame() const { return readyState() &gt;= MediaPlayer::HaveCurrentData; }</span>
607 
608 //bool MediaPlayerPrivate::canLoadPoster() const { return false; }
609 //void MediaPlayerPrivate::setPoster(const String&amp;) { }
610 
611 //#if ENABLE(PLUGIN_PROXY_FOR_VIDEO)
612 //        virtual void deliverNotification(MediaPlayerProxyNotificationType) = 0;
613 //        virtual void setMediaPlayerProxy(WebMediaPlayerProxy*) = 0;
614 //#endif
615 
616 //#if USE(ACCELERATED_COMPOSITING)
617 //        // whether accelerated rendering is supported by the media engine for the current media.
618 //        virtual bool supportsAcceleratedRendering() const { return false; }
619 //        // called when the rendering system flips the into or out of accelerated rendering mode.
620 //        virtual void acceleratedRenderingStateChanged() { }
621 //#endif
622 
623 //bool MediaPlayerPrivate::hasSingleSecurityOrigin() const { return false; }
624 
<a name="24" id="anc24"></a><span class="line-modified">625 //MediaPlayer::MovieLoadType MediaPlayerPrivate::movieLoadType() const { return MediaPlayer::Unknown; }</span>
626 
627 void MediaPlayerPrivate::setNetworkState(MediaPlayer::NetworkState networkState)
628 {
629     if (m_networkState != networkState) {
630         PLOG_TRACE4(&quot;MediaPlayerPrivate NetworkState: %s (%d) =&gt; %s (%d)\n&quot;,
631             networkStateStr(m_networkState), (int)m_networkState, networkStateStr(networkState), (int)networkState);
632         m_networkState = networkState;
633         m_player-&gt;networkStateChanged();
634     }
635 }
636 
637 void MediaPlayerPrivate::setReadyState(MediaPlayer::ReadyState readyState)
638 {
639     if (m_readyState != readyState) {
640         PLOG_TRACE4(&quot;MediaPlayerPrivate ReadyState: %s (%d) =&gt; %s (%d)\n&quot;,
641             readyStateStr(m_readyState), (int)m_readyState, readyStateStr(readyState), (int)readyState);
642         m_readyState = readyState;
643         m_player-&gt;readyStateChanged();
644     }
645 }
646 
647 
648 MediaPlayerPrivate* MediaPlayerPrivate::getPlayer(jlong ptr)
649 {
650     return reinterpret_cast&lt;MediaPlayerPrivate *&gt;(jlong_to_ptr(ptr));
651 }
652 
653 void MediaPlayerPrivate::notifyNetworkStateChanged(int networkState)
654 {
655     switch (networkState) {
656     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_EMPTY:
<a name="25" id="anc25"></a><span class="line-modified">657         setNetworkState(MediaPlayer::Empty);</span>
658         break;
659     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_IDLE:
<a name="26" id="anc26"></a><span class="line-modified">660         setNetworkState(MediaPlayer::Idle);</span>
661         break;
662     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_LOADING:
<a name="27" id="anc27"></a><span class="line-modified">663         setNetworkState(MediaPlayer::Loading);</span>
664         break;
665     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_LOADED:
<a name="28" id="anc28"></a><span class="line-modified">666         setNetworkState(MediaPlayer::Loaded);</span>
667         break;
668     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_FORMAT_ERROR:
<a name="29" id="anc29"></a><span class="line-modified">669         setNetworkState(MediaPlayer::FormatError);</span>
670         break;
671     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_NETWORK_ERROR:
<a name="30" id="anc30"></a><span class="line-modified">672         setNetworkState(MediaPlayer::NetworkError);</span>
673         break;
674     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_DECODE_ERROR:
<a name="31" id="anc31"></a><span class="line-modified">675         setNetworkState(MediaPlayer::DecodeError);</span>
676         break;
677     }
678 }
679 
680 void MediaPlayerPrivate::notifyReadyStateChanged(int readyState)
681 {
682     switch (readyState) {
683     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_NOTHING:
<a name="32" id="anc32"></a><span class="line-modified">684         setReadyState(MediaPlayer::HaveNothing);</span>
685         break;
686     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_METADATA:
<a name="33" id="anc33"></a><span class="line-modified">687         setReadyState(MediaPlayer::HaveMetadata);</span>
688         break;
689     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_CURRENT_DATA:
<a name="34" id="anc34"></a><span class="line-modified">690         setReadyState(MediaPlayer::HaveCurrentData);</span>
691         break;
692     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_FUTURE_DATA:
<a name="35" id="anc35"></a><span class="line-modified">693         setReadyState(MediaPlayer::HaveFutureData);</span>
694         break;
695     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_ENOUGH_DATA:
<a name="36" id="anc36"></a><span class="line-modified">696         setReadyState(MediaPlayer::HaveEnoughData);</span>
697         break;
698     }
699 }
700 
701 void MediaPlayerPrivate::notifyPaused(bool paused)
702 {
703     PLOG_TRACE2(&quot;&gt;&gt;MediaPlayerPrivate notifyPaused: %d =&gt; %d\n&quot;, m_paused ? 1 : 0, paused ? 1 : 0);
704 
705     if (m_paused != paused) {
706         m_paused = paused;
707         m_player-&gt;playbackStateChanged();
708     }
709 }
710 
711 void MediaPlayerPrivate::notifySeeking(bool seeking)
712 {
713     PLOG_TRACE2(&quot;&gt;&gt;MediaPlayerPrivate notifySeeking: %d =&gt; %d\n&quot;, m_seeking ? 1 : 0, seeking ? 1 : 0);
714     if (m_seeking != seeking) {
715         m_seeking = seeking;
716         if (!seeking) {
717             // notify time change after seek completed
718             //LOG_TRACE0(&quot;==MediaPlayerPrivate notifySeeking: NOTIFYING time changed\n&quot;);
719             m_player-&gt;timeChanged();
720         }
721     }
722 }
723 
724 void MediaPlayerPrivate::notifyFinished() {
725     PLOG_TRACE0(&quot;&gt;&gt;MediaPlayerPrivate notifyFinished\n&quot;);
726     m_player-&gt;timeChanged();
727 }
728 
729 void MediaPlayerPrivate::notifyReady(bool hasVideo, bool hasAudio)
730 {
731     PLOG_TRACE2(&quot;&gt;&gt;MediaPlayerPrivate notifyReady: hasVideo=%d, hasAudio=%d\n&quot;, hasVideo ? 1 : 0, hasAudio ? 1 : 0);
732     m_hasVideo = hasVideo;
733     m_hasAudio = hasAudio;
734     PLOG_TRACE0(&quot;&lt;&lt;MediaPlayerPrivate notifyReady\n&quot;);
735 }
736 
737 void MediaPlayerPrivate::notifyDurationChanged(float duration)
738 {
739     PLOG_TRACE2(&quot;&gt;&gt;MediaPlayerPrivate notifyDurationChanged, %f =&gt; %f\n&quot;,
740         m_duration, duration);
741     m_duration = duration;
742     m_player-&gt;durationChanged();
743 }
744 
745 void MediaPlayerPrivate::notifySizeChanged(int width, int height)
746 {
747     PLOG_TRACE2(&quot;MediaPlayerPrivate notifySizeChanged: %d x %d\n&quot;, width, height);
748     m_naturalSize = FloatSize(width, height); //XXX leave it as IntSize?
749 }
750 
751 void MediaPlayerPrivate::notifyNewFrame()
752 {
753     PLOG_TRACE0(&quot;&gt;&gt;MediaPlayerPrivate notifyNewFrame\n&quot;);
754     m_player-&gt;repaint();
755     //PLOG_TRACE0(&quot;&lt;&lt;MediaPlayerPrivate notifyNewFrame\n&quot;);
756 }
757 
758 void MediaPlayerPrivate::notifyBufferChanged(std::unique_ptr&lt;PlatformTimeRanges&gt; timeRanges, int bytesLoaded)
759 {
760     PLOG_TRACE0(&quot;MediaPlayerPrivate notifyBufferChanged\n&quot;);
761     m_buffered = std::move(timeRanges);
762     m_bytesLoaded = bytesLoaded;
763     m_didLoadingProgress = true;
764 }
765 
766 
767 // *********************************************************
768 // JNI functions
769 // *********************************************************
770 extern &quot;C&quot; {
771 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifyNetworkStateChanged
772     (JNIEnv*, jobject, jlong ptr, jint networkState)
773 {
774     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
775     player-&gt;notifyNetworkStateChanged(networkState);
776 }
777 
778 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifyReadyStateChanged
779     (JNIEnv*, jobject, jlong ptr, jint readyState)
780 {
781     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
782     player-&gt;notifyReadyStateChanged(readyState);
783 }
784 
785 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifyPaused
786     (JNIEnv*, jobject, jlong ptr, jboolean paused)
787 {
788     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
789     player-&gt;notifyPaused(jbool_to_bool(paused));
790 }
791 
792 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifySeeking
793     (JNIEnv*, jobject, jlong ptr, jboolean seeking, jint /*readyState*/)
794 {
795     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
796     player-&gt;notifySeeking(jbool_to_bool(seeking));
797 }
798 
799 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifyFinished
800     (JNIEnv*, jobject, jlong ptr)
801 {
802     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
803     player-&gt;notifyFinished();
804 }
805 
806 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifyReady
807     (JNIEnv*, jobject, jlong ptr, jboolean hasVideo, jboolean hasAudio, jfloat duration)
808 {
809     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
810     player-&gt;notifyReady(jbool_to_bool(hasVideo), jbool_to_bool(hasAudio));
811     if (duration &gt;= 0) {
812         player-&gt;notifyDurationChanged(duration);
813     }
814 }
815 
816 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifyDurationChanged
817   (JNIEnv*, jobject, jlong ptr, jfloat duration)
818 {
819     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
820     if (duration != player-&gt;duration()) {
821         player-&gt;notifyDurationChanged(duration);
822     }
823 }
824 
825 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifySizeChanged
826     (JNIEnv*, jobject, jlong ptr, jint width, jint height)
827 {
828     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
829     player-&gt;notifySizeChanged(width, height);
830 }
831 
832 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifyNewFrame
833     (JNIEnv*, jobject, jlong ptr)
834 {
835     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
836     player-&gt;notifyNewFrame();
837 }
838 
839 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifyBufferChanged
840   (JNIEnv *env, jobject, jlong ptr, jfloatArray ranges, jint bytesLoaded)
841 {
842     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
843 
844     jboolean isCopy;
845     jint len = env-&gt;GetArrayLength(ranges);
846     jfloat* rangesElems = env-&gt;GetFloatArrayElements(ranges, &amp;isCopy);
847 
848     PlatformTimeRanges* timeRanges = new PlatformTimeRanges();
849     for (int i = 0; i &lt; len; i+=2) {
850         timeRanges-&gt;add(MediaTime::createWithDouble(rangesElems[i]),
851                         MediaTime::createWithDouble(rangesElems[i+1]));
852     }
853     if (isCopy == JNI_TRUE) {
854        env-&gt;ReleaseFloatArrayElements(ranges, rangesElems, JNI_ABORT);
855     }
856 
857     player-&gt;notifyBufferChanged(std::unique_ptr&lt;PlatformTimeRanges&gt;(timeRanges), bytesLoaded);
858 }
859 
860 } // extern &quot;C&quot;
861 
862 } // namespace WebCore
863 
<a name="37" id="anc37"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="37" type="hidden" />
</body>
</html>
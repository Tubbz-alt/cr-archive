<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGSlowPathGenerator.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -37,10 +37,11 @@</span>
  #include &quot;DFGMayExit.h&quot;
  #include &quot;DFGOSRExitFuzz.h&quot;
  #include &quot;DFGSaneStringGetByValSlowPathGenerator.h&quot;
  #include &quot;DFGSlowPathGenerator.h&quot;
  #include &quot;DFGSnippetParams.h&quot;
<span class="udiff-line-added">+ #include &quot;DateInstance.h&quot;</span>
  #include &quot;DirectArguments.h&quot;
  #include &quot;DisallowMacroScratchRegisterUsage.h&quot;
  #include &quot;JITAddGenerator.h&quot;
  #include &quot;JITBitAndGenerator.h&quot;
  #include &quot;JITBitOrGenerator.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -48,14 +49,14 @@</span>
  #include &quot;JITDivGenerator.h&quot;
  #include &quot;JITLeftShiftGenerator.h&quot;
  #include &quot;JITMulGenerator.h&quot;
  #include &quot;JITRightShiftGenerator.h&quot;
  #include &quot;JITSubGenerator.h&quot;
<span class="udiff-line-added">+ #include &quot;JSArrayIterator.h&quot;</span>
  #include &quot;JSAsyncFunction.h&quot;
  #include &quot;JSAsyncGeneratorFunction.h&quot;
  #include &quot;JSCInlines.h&quot;
<span class="udiff-line-removed">- #include &quot;JSFixedArray.h&quot;</span>
  #include &quot;JSGeneratorFunction.h&quot;
  #include &quot;JSImmutableButterfly.h&quot;
  #include &quot;JSLexicalEnvironment.h&quot;
  #include &quot;JSPropertyNameEnumerator.h&quot;
  #include &quot;LinkBuffer.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -69,10 +70,12 @@</span>
  #include &lt;wtf/Box.h&gt;
  #include &lt;wtf/MathExtras.h&gt;
  
  namespace JSC { namespace DFG {
  
<span class="udiff-line-added">+ DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(SpeculativeJIT);</span>
<span class="udiff-line-added">+ </span>
  SpeculativeJIT::SpeculativeJIT(JITCompiler&amp; jit)
      : m_jit(jit)
      , m_graph(m_jit.graph())
      , m_currentNode(0)
      , m_lastGeneratedNode(LastNodeType)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -668,11 +671,11 @@</span>
      case SetDoubleConstant:
          m_jit.moveDouble(Imm64(reinterpretDoubleToInt64(plan.node()-&gt;asNumber())), plan.fpr());
          break;
      case Load32PayloadBoxInt:
          m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
<span class="udiff-line-modified-removed">-         m_jit.or64(GPRInfo::tagTypeNumberRegister, plan.gpr());</span>
<span class="udiff-line-modified-added">+         m_jit.or64(GPRInfo::numberTagRegister, plan.gpr());</span>
          break;
      case Load32PayloadConvertToInt52:
          m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
          m_jit.signExtend32ToPtr(plan.gpr(), plan.gpr());
          m_jit.lshift64(TrustedImm32(JSValue::int52ShiftAmount), plan.gpr());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -824,14 +827,42 @@</span>
  
      SpeculateCellOperand base(this, node-&gt;child1());
      GPRReg baseReg = base.gpr();
  
      if (node-&gt;arrayMode().alreadyChecked(m_jit.graph(), node, m_state.forNode(node-&gt;child1()))) {
<span class="udiff-line-added">+         // We can purge Empty check completely in this case of CheckArrayOrEmpty since CellUse only accepts SpecCell | SpecEmpty.</span>
<span class="udiff-line-added">+         ASSERT(typeFilterFor(node-&gt;child1().useKind()) &amp; SpecEmpty);</span>
          noResult(m_currentNode);
          return;
      }
  
<span class="udiff-line-added">+     Optional&lt;GPRTemporary&gt; temp;</span>
<span class="udiff-line-added">+     Optional&lt;GPRReg&gt; tempGPR;</span>
<span class="udiff-line-added">+     switch (node-&gt;arrayMode().type()) {</span>
<span class="udiff-line-added">+     case Array::Int32:</span>
<span class="udiff-line-added">+     case Array::Double:</span>
<span class="udiff-line-added">+     case Array::Contiguous:</span>
<span class="udiff-line-added">+     case Array::Undecided:</span>
<span class="udiff-line-added">+     case Array::ArrayStorage:</span>
<span class="udiff-line-added">+     case Array::SlowPutArrayStorage: {</span>
<span class="udiff-line-added">+         temp.emplace(this);</span>
<span class="udiff-line-added">+         tempGPR = temp-&gt;gpr();</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     CCallHelpers::Jump isEmpty;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if USE(JSVALUE64)</span>
<span class="udiff-line-added">+     if (node-&gt;op() == CheckArrayOrEmpty) {</span>
<span class="udiff-line-added">+         if (m_interpreter.forNode(node-&gt;child1()).m_type &amp; SpecEmpty)</span>
<span class="udiff-line-added">+             isEmpty = m_jit.branchIfEmpty(baseReg);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
      switch (node-&gt;arrayMode().type()) {
      case Array::AnyTypedArray:
      case Array::String:
          RELEASE_ASSERT_NOT_REACHED(); // Should have been a Phantom(String:)
          return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -839,35 +870,32 @@</span>
      case Array::Double:
      case Array::Contiguous:
      case Array::Undecided:
      case Array::ArrayStorage:
      case Array::SlowPutArrayStorage: {
<span class="udiff-line-modified-removed">-         GPRTemporary temp(this);</span>
<span class="udiff-line-removed">-         GPRReg tempGPR = temp.gpr();</span>
<span class="udiff-line-removed">-         m_jit.load8(MacroAssembler::Address(baseReg, JSCell::indexingTypeAndMiscOffset()), tempGPR);</span>
<span class="udiff-line-modified-added">+         m_jit.load8(MacroAssembler::Address(baseReg, JSCell::indexingTypeAndMiscOffset()), tempGPR.value());</span>
          speculationCheck(
              BadIndexingType, JSValueSource::unboxedCell(baseReg), 0,
<span class="udiff-line-modified-removed">-             jumpSlowForUnwantedArrayMode(tempGPR, node-&gt;arrayMode()));</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-         noResult(m_currentNode);</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-modified-added">+             jumpSlowForUnwantedArrayMode(tempGPR.value(), node-&gt;arrayMode()));</span>
<span class="udiff-line-modified-added">+         break;</span>
      }
      case Array::DirectArguments:
          speculateCellTypeWithoutTypeFiltering(node-&gt;child1(), baseReg, DirectArgumentsType);
<span class="udiff-line-modified-removed">-         noResult(m_currentNode);</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-modified-added">+         break;</span>
      case Array::ScopedArguments:
          speculateCellTypeWithoutTypeFiltering(node-&gt;child1(), baseReg, ScopedArgumentsType);
<span class="udiff-line-modified-removed">-         noResult(m_currentNode);</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-modified-added">+         break;</span>
      default:
          speculateCellTypeWithoutTypeFiltering(
              node-&gt;child1(), baseReg,
              typeForTypedArrayType(node-&gt;arrayMode().typedArrayType()));
<span class="udiff-line-modified-removed">-         noResult(m_currentNode);</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-modified-added">+         break;</span>
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (isEmpty.isSet())</span>
<span class="udiff-line-added">+         isEmpty.link(&amp;m_jit);</span>
<span class="udiff-line-added">+     noResult(m_currentNode);</span>
  }
  
  void SpeculativeJIT::arrayify(Node* node, GPRReg baseReg, GPRReg propertyReg)
  {
      ASSERT(node-&gt;arrayMode().doesConversion());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -981,11 +1009,11 @@</span>
      }
  }
  
  void SpeculativeJIT::compileGetById(Node* node, AccessType accessType)
  {
<span class="udiff-line-modified-removed">-     ASSERT(accessType == AccessType::Get || accessType == AccessType::GetDirect || accessType == AccessType::TryGet);</span>
<span class="udiff-line-modified-added">+     ASSERT(accessType == AccessType::GetById || accessType == AccessType::GetByIdDirect || accessType == AccessType::TryGetById);</span>
  
      switch (node-&gt;child1().useKind()) {
      case CellUse: {
          SpeculateCellOperand base(this, node-&gt;child1());
          JSValueRegsTemporary result(this, Reuse, base);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1088,11 +1116,11 @@</span>
      gen.generateFastPath(m_jit);
  
      auto slowPath = slowPathCall(
          gen.slowPathJump(), this, operationInByIdOptimize,
          NeedToSpill, ExceptionCheckRequirement::CheckNeeded,
<span class="udiff-line-modified-removed">-         resultRegs, gen.stubInfo(), CCallHelpers::CellValue(baseGPR), identifierUID(node-&gt;identifierNumber()));</span>
<span class="udiff-line-modified-added">+         resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), gen.stubInfo(), CCallHelpers::CellValue(baseGPR), identifierUID(node-&gt;identifierNumber()));</span>
  
      m_jit.addInById(gen, slowPath.get());
      addSlowPathGenerator(WTFMove(slowPath));
  
      blessedBooleanResult(resultRegs.payloadGPR(), node, UseChildrenCalledExplicitly);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1110,11 +1138,11 @@</span>
      key.use();
  
      flushRegisters();
      JSValueRegsFlushedCallResult result(this);
      JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-     callOperation(operationInByVal, resultRegs, baseGPR, regs);</span>
<span class="udiff-line-modified-added">+     callOperation(operationInByVal, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, regs);</span>
      m_jit.exceptionCheck();
      blessedBooleanResult(resultRegs.payloadGPR(), node, UseChildrenCalledExplicitly);
  }
  
  void SpeculativeJIT::compileDeleteById(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1126,11 +1154,11 @@</span>
      GPRReg resultGPR = result.gpr();
  
      value.use();
  
      flushRegisters();
<span class="udiff-line-modified-removed">-     callOperation(operationDeleteById, resultGPR, valueRegs, identifierUID(node-&gt;identifierNumber()));</span>
<span class="udiff-line-modified-added">+     callOperation(operationDeleteById, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs, identifierUID(node-&gt;identifierNumber()));</span>
      m_jit.exceptionCheck();
  
      unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1146,11 +1174,11 @@</span>
  
      base.use();
      key.use();
  
      flushRegisters();
<span class="udiff-line-modified-removed">-     callOperation(operationDeleteByVal, resultGPR, baseRegs, keyRegs);</span>
<span class="udiff-line-modified-added">+     callOperation(operationDeleteByVal, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs, keyRegs);</span>
      m_jit.exceptionCheck();
  
      unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1167,19 +1195,19 @@</span>
          SpeculateCellOperand object(this, objectEdge);
          GPRReg objectGPR = object.gpr();
          speculateObject(objectEdge, objectGPR);
  
          flushRegisters();
<span class="udiff-line-modified-removed">-         callOperation(operationPushWithScopeObject, resultGPR, currentScopeGPR, objectGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationPushWithScopeObject, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), currentScopeGPR, objectGPR);</span>
          // No exception check here as we did not have to call toObject().
      } else {
          ASSERT(objectEdge.useKind() == UntypedUse);
          JSValueOperand object(this, objectEdge);
          JSValueRegs objectRegs = object.jsValueRegs();
  
          flushRegisters();
<span class="udiff-line-modified-removed">-         callOperation(operationPushWithScope, resultGPR, currentScopeGPR, objectRegs);</span>
<span class="udiff-line-modified-added">+         callOperation(operationPushWithScope, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), currentScopeGPR, objectRegs);</span>
          m_jit.exceptionCheck();
      }
  
      cellResult(resultGPR, node);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1602,18 +1630,18 @@</span>
  
      m_jit.lshift32(MacroAssembler::TrustedImm32(sizeof(void*) == 4 ? 2 : 3), tempGPR);
      m_jit.addPtr(TrustedImmPtr(vm.smallStrings.singleCharacterStrings()), tempGPR);
      m_jit.loadPtr(tempGPR, tempGPR);
  
<span class="udiff-line-modified-removed">-     addSlowPathGenerator(slowPathCall(bigCharacter, this, operationSingleCharacterString, tempGPR, tempGPR));</span>
<span class="udiff-line-modified-added">+     addSlowPathGenerator(slowPathCall(bigCharacter, this, operationSingleCharacterString, tempGPR, &amp;vm, tempGPR));</span>
  
<span class="udiff-line-modified-removed">-     addSlowPathGenerator(slowPathCall(slowCases, this, operationStringSubstr, tempGPR, stringGPR, startIndexGPR, tempGPR));</span>
<span class="udiff-line-modified-added">+     addSlowPathGenerator(slowPathCall(slowCases, this, operationStringSubstr, tempGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR, startIndexGPR, tempGPR));</span>
  
      if (endGPR)
<span class="udiff-line-modified-removed">-         addSlowPathGenerator(slowPathCall(isRope, this, operationStringSlice, tempGPR, stringGPR, startGPR, *endGPR));</span>
<span class="udiff-line-modified-added">+         addSlowPathGenerator(slowPathCall(isRope, this, operationStringSlice, tempGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR, startGPR, *endGPR));</span>
      else
<span class="udiff-line-modified-removed">-         addSlowPathGenerator(slowPathCall(isRope, this, operationStringSlice, tempGPR, stringGPR, startGPR, TrustedImm32(std::numeric_limits&lt;int32_t&gt;::max())));</span>
<span class="udiff-line-modified-added">+         addSlowPathGenerator(slowPathCall(isRope, this, operationStringSlice, tempGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR, startGPR, TrustedImm32(std::numeric_limits&lt;int32_t&gt;::max())));</span>
  
      doneCases.link(&amp;m_jit);
      cellResult(tempGPR, node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1656,11 +1684,11 @@</span>
      m_jit.add32(TrustedImm32(1), indexGPR);
      m_jit.jump().linkTo(loopStart, &amp;m_jit);
  
      slowPath.link(&amp;m_jit);
      silentSpillAllRegisters(lengthGPR);
<span class="udiff-line-modified-removed">-     callOperation(operationToLowerCase, lengthGPR, stringGPR, indexGPR);</span>
<span class="udiff-line-modified-added">+     callOperation(operationToLowerCase, lengthGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR, indexGPR);</span>
      silentFillAllRegisters();
      m_jit.exceptionCheck();
      auto done = m_jit.jump();
  
      loopDone.link(&amp;m_jit);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1700,11 +1728,11 @@</span>
  
      jump(notTaken);
  }
  
  // Returns true if the compare is fused with a subsequent branch.
<span class="udiff-line-modified-removed">- bool SpeculativeJIT::compilePeepHoleBranch(Node* node, MacroAssembler::RelationalCondition condition, MacroAssembler::DoubleCondition doubleCondition, S_JITOperation_EJJ operation)</span>
<span class="udiff-line-modified-added">+ bool SpeculativeJIT::compilePeepHoleBranch(Node* node, MacroAssembler::RelationalCondition condition, MacroAssembler::DoubleCondition doubleCondition, S_JITOperation_GJJ operation)</span>
  {
      // Fused compare &amp; branch.
      unsigned branchIndexInBlock = detectPeepHoleBranch();
      if (branchIndexInBlock != UINT_MAX) {
          Node* branchNode = m_block-&gt;at(branchIndexInBlock);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1773,11 +1801,23 @@</span>
      ASSERT(node-&gt;containsMovHint() &amp;&amp; node-&gt;op() != ZombieHint);
  
      Node* child = node-&gt;child1().node();
      noticeOSRBirth(child);
  
<span class="udiff-line-modified-removed">-     m_stream-&gt;appendAndLog(VariableEvent::movHint(MinifiedID(child), node-&gt;unlinkedLocal()));</span>
<span class="udiff-line-modified-added">+     m_stream-&gt;appendAndLog(VariableEvent::movHint(MinifiedID(child), node-&gt;unlinkedOperand()));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SpeculativeJIT::compileCheckNeutered(Node* node)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     SpeculateCellOperand base(this, node-&gt;child1());</span>
<span class="udiff-line-added">+     GPRReg baseReg = base.gpr();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     speculationCheck(</span>
<span class="udiff-line-added">+         BadIndexingType, JSValueSource::unboxedCell(baseReg), node-&gt;child1(),</span>
<span class="udiff-line-added">+         m_jit.branchTestPtr(MacroAssembler::Zero, MacroAssembler::Address(baseReg, JSArrayBufferView::offsetOfVector())));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     noResult(node);</span>
  }
  
  void SpeculativeJIT::bail(AbortReason reason)
  {
      if (verboseCompilationEnabled())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1806,12 +1846,10 @@</span>
          return;
      }
  
      if (m_block-&gt;isCatchEntrypoint) {
          m_jit.addPtr(CCallHelpers::TrustedImm32(-(m_jit.graph().frameRegisterCount() * sizeof(Register))), GPRInfo::callFrameRegister,  CCallHelpers::stackPointerRegister);
<span class="udiff-line-removed">-         if (Options::zeroStackFrame())</span>
<span class="udiff-line-removed">-             m_jit.clearStackFrame(GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister, GPRInfo::regT0, m_jit.graph().frameRegisterCount() * sizeof(Register));</span>
          m_jit.emitSaveCalleeSaves();
          m_jit.emitMaterializeTagCheckRegisters();
          m_jit.emitPutToCallFrameHeader(m_jit.codeBlock(), CallFrameSlot::codeBlock);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1823,25 +1861,22 @@</span>
  
      m_state.reset();
      m_state.beginBasicBlock(m_block);
  
      for (size_t i = m_block-&gt;variablesAtHead.size(); i--;) {
<span class="udiff-line-modified-removed">-         int operand = m_block-&gt;variablesAtHead.operandForIndex(i);</span>
<span class="udiff-line-modified-added">+         Operand operand = m_block-&gt;variablesAtHead.operandForIndex(i);</span>
          Node* node = m_block-&gt;variablesAtHead[i];
          if (!node)
              continue; // No need to record dead SetLocal&#39;s.
  
          VariableAccessData* variable = node-&gt;variableAccessData();
          DataFormat format;
          if (!node-&gt;refCount())
              continue; // No need to record dead SetLocal&#39;s.
          format = dataFormatFor(variable-&gt;flushFormat());
<span class="udiff-line-modified-removed">-         m_stream-&gt;appendAndLog(</span>
<span class="udiff-line-modified-removed">-             VariableEvent::setLocal(</span>
<span class="udiff-line-removed">-                 VirtualRegister(operand),</span>
<span class="udiff-line-removed">-                 variable-&gt;machineLocal(),</span>
<span class="udiff-line-removed">-                 format));</span>
<span class="udiff-line-modified-added">+         DFG_ASSERT(m_jit.graph(), node, !operand.isArgument() || operand.virtualRegister().toArgument() &gt;= 0);</span>
<span class="udiff-line-modified-added">+         m_stream-&gt;appendAndLog(VariableEvent::setLocal(operand, variable-&gt;machineLocal(), format));</span>
      }
  
      m_origin = NodeOrigin();
  
      for (m_indexInBlock = 0; m_indexInBlock &lt; m_block-&gt;size(); ++m_indexInBlock) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1860,17 +1895,12 @@</span>
          m_origin = m_currentNode-&gt;origin;
          m_lastGeneratedNode = m_currentNode-&gt;op();
  
          ASSERT(m_currentNode-&gt;shouldGenerate());
  
<span class="udiff-line-modified-removed">-         if (verboseCompilationEnabled()) {</span>
<span class="udiff-line-modified-removed">-             dataLogF(</span>
<span class="udiff-line-removed">-                 &quot;SpeculativeJIT generating Node @%d (bc#%u) at JIT offset 0x%x&quot;,</span>
<span class="udiff-line-removed">-                 (int)m_currentNode-&gt;index(),</span>
<span class="udiff-line-removed">-                 m_currentNode-&gt;origin.semantic.bytecodeIndex(), m_jit.debugOffset());</span>
<span class="udiff-line-removed">-             dataLog(&quot;\n&quot;);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         if (verboseCompilationEnabled())</span>
<span class="udiff-line-modified-added">+             dataLogLn(&quot;SpeculativeJIT generating Node @&quot;, (int)m_currentNode-&gt;index(), &quot; (&quot;, m_currentNode-&gt;origin.semantic.bytecodeIndex().offset(), &quot;) at JIT offset 0x&quot;, m_jit.debugOffset());</span>
  
          if (Options::validateDFGExceptionHandling() &amp;&amp; (mayExit(m_jit.graph(), m_currentNode) != DoesNotExit || m_currentNode-&gt;isTerminal()))
              m_jit.jitReleaseAssertNoException(m_jit.vm());
  
          m_jit.pcToCodeOriginMapBuilder().appendItem(m_jit.labelIgnoringWatchpoints(), m_origin.semantic);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1892,22 +1922,22 @@</span>
          // Make sure that the abstract state is rematerialized for the next node.
          m_interpreter.executeEffects(m_indexInBlock);
      }
  
      // Perform the most basic verification that children have been used correctly.
<span class="udiff-line-modified-removed">-     if (!ASSERT_DISABLED) {</span>
<span class="udiff-line-modified-added">+     if (ASSERT_ENABLED) {</span>
          for (auto&amp; info : m_generationInfo)
              RELEASE_ASSERT(!info.alive());
      }
  }
  
  // If we are making type predictions about our arguments then
  // we need to check that they are correct on function entry.
  void SpeculativeJIT::checkArgumentTypes()
  {
      ASSERT(!m_currentNode);
<span class="udiff-line-modified-removed">-     m_origin = NodeOrigin(CodeOrigin(0), CodeOrigin(0), true);</span>
<span class="udiff-line-modified-added">+     m_origin = NodeOrigin(CodeOrigin(BytecodeIndex(0)), CodeOrigin(BytecodeIndex(0)), true);</span>
  
      auto&amp; arguments = m_jit.graph().m_rootToArguments.find(m_jit.graph().block(0))-&gt;value;
      for (int i = 0; i &lt; m_jit.codeBlock()-&gt;numParameters(); ++i) {
          Node* node = arguments[i];
          if (!node) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1922,29 +1952,30 @@</span>
          FlushFormat format = variableAccessData-&gt;flushFormat();
  
          if (format == FlushedJSValue)
              continue;
  
<span class="udiff-line-modified-removed">-         VirtualRegister virtualRegister = variableAccessData-&gt;local();</span>
<span class="udiff-line-modified-added">+         VirtualRegister virtualRegister = variableAccessData-&gt;operand().virtualRegister();</span>
<span class="udiff-line-added">+         ASSERT(virtualRegister.isArgument());</span>
  
          JSValueSource valueSource = JSValueSource(JITCompiler::addressFor(virtualRegister));
  
  #if USE(JSVALUE64)
          switch (format) {
          case FlushedInt32: {
<span class="udiff-line-modified-removed">-             speculationCheck(BadType, valueSource, node, m_jit.branch64(MacroAssembler::Below, JITCompiler::addressFor(virtualRegister), GPRInfo::tagTypeNumberRegister));</span>
<span class="udiff-line-modified-added">+             speculationCheck(BadType, valueSource, node, m_jit.branch64(MacroAssembler::Below, JITCompiler::addressFor(virtualRegister), GPRInfo::numberTagRegister));</span>
              break;
          }
          case FlushedBoolean: {
              GPRTemporary temp(this);
              m_jit.load64(JITCompiler::addressFor(virtualRegister), temp.gpr());
<span class="udiff-line-modified-removed">-             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), temp.gpr());</span>
<span class="udiff-line-modified-added">+             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), temp.gpr());</span>
              speculationCheck(BadType, valueSource, node, m_jit.branchTest64(MacroAssembler::NonZero, temp.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
              break;
          }
          case FlushedCell: {
<span class="udiff-line-modified-removed">-             speculationCheck(BadType, valueSource, node, m_jit.branchTest64(MacroAssembler::NonZero, JITCompiler::addressFor(virtualRegister), GPRInfo::tagMaskRegister));</span>
<span class="udiff-line-modified-added">+             speculationCheck(BadType, valueSource, node, m_jit.branchTest64(MacroAssembler::NonZero, JITCompiler::addressFor(virtualRegister), GPRInfo::notCellMaskRegister));</span>
              break;
          }
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2051,11 +2082,11 @@</span>
      GPRReg unusedGPR = unused.gpr();
  
      JITCompiler::Jump needTrapHandling = m_jit.branchTest8(JITCompiler::NonZero,
          JITCompiler::AbsoluteAddress(m_jit.vm().needTrapHandlingAddress()));
  
<span class="udiff-line-modified-removed">-     addSlowPathGenerator(slowPathCall(needTrapHandling, this, operationHandleTraps, unusedGPR));</span>
<span class="udiff-line-modified-added">+     addSlowPathGenerator(slowPathCall(needTrapHandling, this, operationHandleTraps, unusedGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic))));</span>
      noResult(node);
  }
  
  void SpeculativeJIT::compileDoublePutByVal(Node* node, SpeculateCellOperand&amp; base, SpeculateStrictInt32Operand&amp; property)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2126,11 +2157,11 @@</span>
              slowPathCall(
                  slowCase, this,
                  m_jit.isStrictModeFor(node-&gt;origin.semantic)
                      ? (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsStrict : operationPutDoubleByValBeyondArrayBoundsStrict)
                      : (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsNonStrict : operationPutDoubleByValBeyondArrayBoundsNonStrict),
<span class="udiff-line-modified-removed">-                 NoResult, baseReg, propertyReg, valueReg));</span>
<span class="udiff-line-modified-added">+                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, valueReg));</span>
      }
  
      noResult(m_currentNode, UseChildrenCalledExplicitly);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2221,11 +2252,11 @@</span>
      m_jit.addPtr(TrustedImmPtr(vm.smallStrings.singleCharacterStrings()), scratchReg);
      m_jit.loadPtr(scratchReg, scratchReg);
  
      addSlowPathGenerator(
          slowPathCall(
<span class="udiff-line-modified-removed">-             bigCharacter, this, operationSingleCharacterString, scratchReg, scratchReg));</span>
<span class="udiff-line-modified-added">+             bigCharacter, this, operationSingleCharacterString, scratchReg, &amp;vm, scratchReg));</span>
  
      if (node-&gt;arrayMode().isOutOfBounds()) {
  #if USE(JSVALUE32_64)
          m_jit.move(TrustedImm32(JSValue::CellTag), resultTagReg);
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2245,27 +2276,26 @@</span>
              m_jit.graph().registerAndWatchStructureTransition(stringPrototypeStructure);
              m_jit.graph().registerAndWatchStructureTransition(objectPrototypeStructure);
  
  #if USE(JSVALUE64)
              addSlowPathGenerator(makeUnique&lt;SaneStringGetByValSlowPathGenerator&gt;(
<span class="udiff-line-modified-removed">-                 outOfBounds, this, JSValueRegs(scratchReg), baseReg, propertyReg));</span>
<span class="udiff-line-modified-added">+                 outOfBounds, this, JSValueRegs(scratchReg), TrustedImmPtr::weakPointer(m_graph, globalObject), baseReg, propertyReg));</span>
  #else
              addSlowPathGenerator(makeUnique&lt;SaneStringGetByValSlowPathGenerator&gt;(
<span class="udiff-line-modified-removed">-                 outOfBounds, this, JSValueRegs(resultTagReg, scratchReg),</span>
<span class="udiff-line-removed">-                 baseReg, propertyReg));</span>
<span class="udiff-line-modified-added">+                 outOfBounds, this, JSValueRegs(resultTagReg, scratchReg), TrustedImmPtr::weakPointer(m_graph, globalObject), baseReg, propertyReg));</span>
  #endif
          } else {
  #if USE(JSVALUE64)
              addSlowPathGenerator(
                  slowPathCall(
                      outOfBounds, this, operationGetByValStringInt,
<span class="udiff-line-modified-removed">-                     scratchReg, baseReg, propertyReg));</span>
<span class="udiff-line-modified-added">+                     scratchReg, TrustedImmPtr::weakPointer(m_graph, globalObject), baseReg, propertyReg));</span>
  #else
              addSlowPathGenerator(
                  slowPathCall(
                      outOfBounds, this, operationGetByValStringInt,
<span class="udiff-line-modified-removed">-                     JSValueRegs(resultTagReg, scratchReg), baseReg, propertyReg));</span>
<span class="udiff-line-modified-added">+                     JSValueRegs(resultTagReg, scratchReg), TrustedImmPtr::weakPointer(m_graph, globalObject), baseReg, propertyReg));</span>
  #endif
          }
  
  #if USE(JSVALUE64)
          jsValueResult(scratchReg, m_currentNode);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2284,11 +2314,11 @@</span>
          JSValueRegs oprRegs = opr.jsValueRegs();
  
          flushRegisters();
          JSValueRegsFlushedCallResult result(this);
          JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-         callOperation(operationStringFromCharCodeUntyped, resultRegs, oprRegs);</span>
<span class="udiff-line-modified-added">+         callOperation(operationStringFromCharCodeUntyped, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), oprRegs);</span>
          m_jit.exceptionCheck();
  
          jsValueResult(resultRegs, node);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2304,11 +2334,11 @@</span>
      slowCases.append(m_jit.branch32(MacroAssembler::Above, propertyReg, TrustedImm32(maxSingleCharacterString)));
      m_jit.move(TrustedImmPtr(vm().smallStrings.singleCharacterStrings()), smallStringsReg);
      m_jit.loadPtr(MacroAssembler::BaseIndex(smallStringsReg, propertyReg, MacroAssembler::ScalePtr, 0), scratchReg);
  
      slowCases.append(m_jit.branchTest32(MacroAssembler::Zero, scratchReg));
<span class="udiff-line-modified-removed">-     addSlowPathGenerator(slowPathCall(slowCases, this, operationStringFromCharCode, scratchReg, propertyReg));</span>
<span class="udiff-line-modified-added">+     addSlowPathGenerator(slowPathCall(slowCases, this, operationStringFromCharCode, scratchReg, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), propertyReg));</span>
      cellResult(scratchReg, m_currentNode);
  }
  
  GeneratedOperandType SpeculativeJIT::checkGeneratedTypeForToInt32(Node* node)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2407,11 +2437,11 @@</span>
  
                  DFG_TYPE_CHECK(
                      JSValueRegs(gpr), node-&gt;child1(), ~SpecCellCheck, m_jit.branchIfCell(JSValueRegs(gpr)));
  
                  // It&#39;s not a cell: so true turns into 1 and all else turns into 0.
<span class="udiff-line-modified-removed">-                 m_jit.compare64(JITCompiler::Equal, gpr, TrustedImm32(ValueTrue), resultGpr);</span>
<span class="udiff-line-modified-added">+                 m_jit.compare64(JITCompiler::Equal, gpr, TrustedImm32(JSValue::ValueTrue), resultGpr);</span>
                  converted.append(m_jit.jump());
  
                  isNumber.link(&amp;m_jit);
              }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2628,21 +2658,21 @@</span>
  
          if (node-&gt;child1().useKind() == NotCellUse) {
              JITCompiler::Jump isNumber = m_jit.branchIfNumber(op1GPR);
              JITCompiler::Jump isUndefined = m_jit.branchIfUndefined(op1GPR);
  
<span class="udiff-line-modified-removed">-             static const double zero = 0;</span>
<span class="udiff-line-modified-added">+             static constexpr double zero = 0;</span>
              m_jit.loadDouble(TrustedImmPtr(&amp;zero), resultFPR);
  
              JITCompiler::Jump isNull = m_jit.branchIfNull(op1GPR);
              done.append(isNull);
  
              DFG_TYPE_CHECK(JSValueRegs(op1GPR), node-&gt;child1(), ~SpecCellCheck,
<span class="udiff-line-modified-removed">-                 m_jit.branchTest64(JITCompiler::Zero, op1GPR, TrustedImm32(static_cast&lt;int32_t&gt;(TagBitBool))));</span>
<span class="udiff-line-modified-added">+                 m_jit.branchTest64(JITCompiler::Zero, op1GPR, TrustedImm32(JSValue::BoolTag)));</span>
  
<span class="udiff-line-modified-removed">-             JITCompiler::Jump isFalse = m_jit.branch64(JITCompiler::Equal, op1GPR, TrustedImm64(ValueFalse));</span>
<span class="udiff-line-modified-removed">-             static const double one = 1;</span>
<span class="udiff-line-modified-added">+             JITCompiler::Jump isFalse = m_jit.branch64(JITCompiler::Equal, op1GPR, TrustedImm64(JSValue::ValueFalse));</span>
<span class="udiff-line-modified-added">+             static constexpr double one = 1;</span>
              m_jit.loadDouble(TrustedImmPtr(&amp;one), resultFPR);
              done.append(m_jit.jump());
              done.append(isFalse);
  
              isUndefined.link(&amp;m_jit);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2676,20 +2706,20 @@</span>
  
          if (node-&gt;child1().useKind() == NotCellUse) {
              JITCompiler::Jump isNumber = m_jit.branch32(JITCompiler::Below, op1TagGPR, JITCompiler::TrustedImm32(JSValue::LowestTag + 1));
              JITCompiler::Jump isUndefined = m_jit.branchIfUndefined(op1TagGPR);
  
<span class="udiff-line-modified-removed">-             static const double zero = 0;</span>
<span class="udiff-line-modified-added">+             static constexpr double zero = 0;</span>
              m_jit.loadDouble(TrustedImmPtr(&amp;zero), resultFPR);
  
              JITCompiler::Jump isNull = m_jit.branchIfNull(op1TagGPR);
              done.append(isNull);
  
              DFG_TYPE_CHECK(JSValueRegs(op1TagGPR, op1PayloadGPR), node-&gt;child1(), ~SpecCell, m_jit.branchIfNotBoolean(op1TagGPR, InvalidGPRReg));
  
              JITCompiler::Jump isFalse = m_jit.branchTest32(JITCompiler::Zero, op1PayloadGPR, TrustedImm32(1));
<span class="udiff-line-modified-removed">-             static const double one = 1;</span>
<span class="udiff-line-modified-added">+             static constexpr double one = 1;</span>
              m_jit.loadDouble(TrustedImmPtr(&amp;one), resultFPR);
              done.append(m_jit.jump());
              done.append(isFalse);
  
              isUndefined.link(&amp;m_jit);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2805,13 +2835,13 @@</span>
  }
  
  static void compileClampDoubleToByte(JITCompiler&amp; jit, GPRReg result, FPRReg source, FPRReg scratch)
  {
      // Unordered compare so we pick up NaN
<span class="udiff-line-modified-removed">-     static const double zero = 0;</span>
<span class="udiff-line-modified-removed">-     static const double byteMax = 255;</span>
<span class="udiff-line-modified-removed">-     static const double half = 0.5;</span>
<span class="udiff-line-modified-added">+     static constexpr double zero = 0;</span>
<span class="udiff-line-modified-added">+     static constexpr double byteMax = 255;</span>
<span class="udiff-line-modified-added">+     static constexpr double half = 0.5;</span>
      jit.loadDouble(JITCompiler::TrustedImmPtr(&amp;zero), scratch);
      MacroAssembler::Jump tooSmall = jit.branchDouble(MacroAssembler::DoubleLessThanOrEqualOrUnordered, source, scratch);
      jit.loadDouble(JITCompiler::TrustedImmPtr(&amp;byteMax), scratch);
      MacroAssembler::Jump tooBig = jit.branchDouble(MacroAssembler::DoubleGreaterThan, source, scratch);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3070,11 +3100,11 @@</span>
  
                  fixed.append(m_jit.branchTruncateDoubleToInt32(
                      fpr, gpr, MacroAssembler::BranchIfTruncateSuccessful));
  
  #if USE(JSVALUE64)
<span class="udiff-line-modified-removed">-                 m_jit.or64(GPRInfo::tagTypeNumberRegister, property);</span>
<span class="udiff-line-modified-added">+                 m_jit.or64(GPRInfo::numberTagRegister, property);</span>
                  boxDouble(fpr, gpr);
  #else
                  UNUSED_PARAM(property);
                  m_jit.move(TrustedImm32(JSValue::Int32Tag), propertyTagGPR);
                  boxDouble(fpr, valueTagGPR, gpr);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3156,28 +3186,28 @@</span>
  #if USE(JSVALUE64)
          if (node-&gt;op() == PutByValDirect) {
              addSlowPathGenerator(slowPathCall(
                  slowPathCases, this,
                  m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectStrict : operationPutByValDirectNonStrict,
<span class="udiff-line-modified-removed">-                 NoResult, base, property, valueGPR));</span>
<span class="udiff-line-modified-added">+                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), base, property, valueGPR));</span>
          } else {
              addSlowPathGenerator(slowPathCall(
                  slowPathCases, this,
                  m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValStrict : operationPutByValNonStrict,
<span class="udiff-line-modified-removed">-                 NoResult, base, property, valueGPR));</span>
<span class="udiff-line-modified-added">+                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), base, property, valueGPR));</span>
          }
  #else // not USE(JSVALUE64)
          if (node-&gt;op() == PutByValDirect) {
              addSlowPathGenerator(slowPathCall(
                  slowPathCases, this,
                  m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectCellStrict : operationPutByValDirectCellNonStrict,
<span class="udiff-line-modified-removed">-                 NoResult, base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));</span>
<span class="udiff-line-modified-added">+                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));</span>
          } else {
              addSlowPathGenerator(slowPathCall(
                  slowPathCases, this,
                  m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStrict : operationPutByValCellNonStrict,
<span class="udiff-line-modified-removed">-                 NoResult, base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));</span>
<span class="udiff-line-modified-added">+                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));</span>
          }
  #endif
      }
  
      noResult(node);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3265,11 +3295,11 @@</span>
      speculateString(m_graph.varArgChild(node, 1), arg2GPR);
  
      flushRegisters();
      JSValueRegsFlushedCallResult result(this);
      JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-     callOperation(operationGetByValObjectString, resultRegs, arg1GPR, arg2GPR);</span>
<span class="udiff-line-modified-added">+     callOperation(operationGetByValObjectString, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR);</span>
      m_jit.exceptionCheck();
  
      jsValueResult(resultRegs, node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3285,11 +3315,11 @@</span>
      speculateSymbol(m_graph.varArgChild(node, 1), arg2GPR);
  
      flushRegisters();
      JSValueRegsFlushedCallResult result(this);
      JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-     callOperation(operationGetByValObjectSymbol, resultRegs, arg1GPR, arg2GPR);</span>
<span class="udiff-line-modified-added">+     callOperation(operationGetByValObjectSymbol, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR);</span>
      m_jit.exceptionCheck();
  
      jsValueResult(resultRegs, node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3304,11 +3334,11 @@</span>
      JSValueRegs arg3Regs = arg3.jsValueRegs();
  
      speculateString(child2, arg2GPR);
  
      flushRegisters();
<span class="udiff-line-modified-removed">-     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStringStrict : operationPutByValCellStringNonStrict, arg1GPR, arg2GPR, arg3Regs);</span>
<span class="udiff-line-modified-added">+     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStringStrict : operationPutByValCellStringNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR, arg3Regs);</span>
      m_jit.exceptionCheck();
  
      noResult(node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3323,11 +3353,11 @@</span>
      JSValueRegs arg3Regs = arg3.jsValueRegs();
  
      speculateSymbol(child2, arg2GPR);
  
      flushRegisters();
<span class="udiff-line-modified-removed">-     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellSymbolStrict : operationPutByValCellSymbolNonStrict, arg1GPR, arg2GPR, arg3Regs);</span>
<span class="udiff-line-modified-added">+     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellSymbolStrict : operationPutByValCellSymbolNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR, arg3Regs);</span>
      m_jit.exceptionCheck();
  
      noResult(node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3341,11 +3371,11 @@</span>
      JSValueRegs subscriptRegs = subscript.jsValueRegs();
  
      flushRegisters();
      JSValueRegsFlushedCallResult result(this);
      JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-     callOperation(operationGetByValWithThis, resultRegs, baseRegs, thisValueRegs, subscriptRegs);</span>
<span class="udiff-line-modified-added">+     callOperation(operationGetByValWithThis, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs, thisValueRegs, subscriptRegs);</span>
      m_jit.exceptionCheck();
  
      jsValueResult(resultRegs, node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3374,11 +3404,11 @@</span>
              JSValueRegs valueRegs = value.jsValueRegs();
  
              flushRegisters();
              JSValueRegsFlushedCallResult result(this);
              JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-             callOperation(operationParseIntGeneric, resultRegs, valueRegs, radixGPR);</span>
<span class="udiff-line-modified-added">+             callOperation(operationParseIntGeneric, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs, radixGPR);</span>
              m_jit.exceptionCheck();
              jsValueResult(resultRegs, node);
              return;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3387,11 +3417,11 @@</span>
          speculateString(node-&gt;child1(), valueGPR);
  
          flushRegisters();
          JSValueRegsFlushedCallResult result(this);
          JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-         callOperation(operationParseIntString, resultRegs, valueGPR, radixGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationParseIntString, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueGPR, radixGPR);</span>
          m_jit.exceptionCheck();
          jsValueResult(resultRegs, node);
          return;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3400,11 +3430,11 @@</span>
          JSValueRegs valueRegs = value.jsValueRegs();
  
          flushRegisters();
          JSValueRegsFlushedCallResult result(this);
          JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-         callOperation(operationParseIntNoRadixGeneric, resultRegs, valueRegs);</span>
<span class="udiff-line-modified-added">+         callOperation(operationParseIntNoRadixGeneric, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs);</span>
          m_jit.exceptionCheck();
          jsValueResult(resultRegs, node);
          return;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3413,11 +3443,11 @@</span>
      speculateString(node-&gt;child1(), valueGPR);
  
      flushRegisters();
      JSValueRegsFlushedCallResult result(this);
      JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-     callOperation(operationParseIntStringNoRadix, resultRegs, valueGPR);</span>
<span class="udiff-line-modified-added">+     callOperation(operationParseIntStringNoRadix, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueGPR);</span>
      m_jit.exceptionCheck();
      jsValueResult(resultRegs, node);
  }
  
  void SpeculativeJIT::compileOverridesHasInstance(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3471,11 +3501,11 @@</span>
  
      JITCompiler::JumpList slowCases;
      slowCases.append(slowCase);
  
      std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(
<span class="udiff-line-modified-removed">-         slowCases, this, operationInstanceOfOptimize, resultGPR, gen.stubInfo(), valueRegs,</span>
<span class="udiff-line-modified-added">+         slowCases, this, operationInstanceOfOptimize, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), gen.stubInfo(), valueRegs,</span>
          prototypeRegs);
  
      m_jit.addInstanceOf(gen, slowPath.get());
      addSlowPathGenerator(WTFMove(slowPath));
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3548,11 +3578,11 @@</span>
  
          flushRegisters();
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
  
<span class="udiff-line-modified-removed">-         callOperation(operationBitNotBigInt, resultGPR, operandGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationBitNotBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), operandGPR);</span>
          m_jit.exceptionCheck();
          cellResult(resultGPR, node);
  
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3561,11 +3591,11 @@</span>
      JSValueRegs operandRegs = operand.jsValueRegs();
  
      flushRegisters();
      JSValueRegsFlushedCallResult result(this);
      JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-     callOperation(operationValueBitNot, resultRegs, operandRegs);</span>
<span class="udiff-line-modified-added">+     callOperation(operationValueBitNot, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), operandRegs);</span>
      m_jit.exceptionCheck();
  
      jsValueResult(resultRegs, node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3582,11 +3612,11 @@</span>
      m_jit.not32(resultGPR);
  
      int32Result(resultGPR, node);
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename SnippetGenerator, J_JITOperation_EJJ snippetSlowPathFunction&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename SnippetGenerator, J_JITOperation_GJJ snippetSlowPathFunction&gt;</span>
  void SpeculativeJIT::emitUntypedBitOp(Node* node)
  {
      Edge&amp; leftChild = node-&gt;child1();
      Edge&amp; rightChild = node-&gt;child2();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3597,11 +3627,11 @@</span>
          JSValueRegs rightRegs = right.jsValueRegs();
  
          flushRegisters();
          JSValueRegsFlushedCallResult result(this);
          JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-         callOperation(snippetSlowPathFunction, resultRegs, leftRegs, rightRegs);</span>
<span class="udiff-line-modified-added">+         callOperation(snippetSlowPathFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
          m_jit.exceptionCheck();
  
          jsValueResult(resultRegs, node);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3660,11 +3690,11 @@</span>
      } else if (rightOperand.isConst()) {
          rightRegs = resultRegs;
          m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
      }
  
<span class="udiff-line-modified-removed">-     callOperation(snippetSlowPathFunction, resultRegs, leftRegs, rightRegs);</span>
<span class="udiff-line-modified-added">+     callOperation(snippetSlowPathFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
  
      silentFillAllRegisters();
      m_jit.exceptionCheck();
  
      gen.endJumpList().link(&amp;m_jit);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3707,17 +3737,17 @@</span>
      GPRFlushedCallResult result(this);
      GPRReg resultGPR = result.gpr();
  
      switch (op) {
      case ValueBitAnd:
<span class="udiff-line-modified-removed">-         callOperation(operationBitAndBigInt, resultGPR, leftGPR, rightGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationBitAndBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
          break;
      case ValueBitXor:
<span class="udiff-line-modified-removed">-         callOperation(operationBitXorBigInt, resultGPR, leftGPR, rightGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationBitXorBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
          break;
      case ValueBitOr:
<span class="udiff-line-modified-removed">-         callOperation(operationBitOrBigInt, resultGPR, leftGPR, rightGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationBitOrBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
          break;
      default:
          RELEASE_ASSERT_NOT_REACHED();
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3762,13 +3792,13 @@</span>
      int32Result(result.gpr(), node);
  }
  
  void SpeculativeJIT::emitUntypedRightShiftBitOp(Node* node)
  {
<span class="udiff-line-modified-removed">-     J_JITOperation_EJJ snippetSlowPathFunction = node-&gt;op() == BitRShift</span>
<span class="udiff-line-modified-added">+     J_JITOperation_GJJ snippetSlowPathFunction = node-&gt;op() == ValueBitRShift</span>
          ? operationValueBitRShift : operationValueBitURShift;
<span class="udiff-line-modified-removed">-     JITRightShiftGenerator::ShiftType shiftType = node-&gt;op() == BitRShift</span>
<span class="udiff-line-modified-added">+     JITRightShiftGenerator::ShiftType shiftType = node-&gt;op() == ValueBitRShift</span>
          ? JITRightShiftGenerator::SignedShift : JITRightShiftGenerator::UnsignedShift;
  
      Edge&amp; leftChild = node-&gt;child1();
      Edge&amp; rightChild = node-&gt;child2();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3779,11 +3809,11 @@</span>
          JSValueRegs rightRegs = right.jsValueRegs();
  
          flushRegisters();
          JSValueRegsFlushedCallResult result(this);
          JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-         callOperation(snippetSlowPathFunction, resultRegs, leftRegs, rightRegs);</span>
<span class="udiff-line-modified-added">+         callOperation(snippetSlowPathFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
          m_jit.exceptionCheck();
  
          jsValueResult(resultRegs, node);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3849,11 +3879,11 @@</span>
      } else if (rightOperand.isConst()) {
          rightRegs = resultRegs;
          m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
      }
  
<span class="udiff-line-modified-removed">-     callOperation(snippetSlowPathFunction, resultRegs, leftRegs, rightRegs);</span>
<span class="udiff-line-modified-added">+     callOperation(snippetSlowPathFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
  
      silentFillAllRegisters();
      m_jit.exceptionCheck();
  
      gen.endJumpList().link(&amp;m_jit);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3877,35 +3907,58 @@</span>
  
          flushRegisters();
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
  
<span class="udiff-line-modified-removed">-         callOperation(operationBitLShiftBigInt, resultGPR, leftGPR, rightGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationBitLShiftBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
          m_jit.exceptionCheck();
          cellResult(resultGPR, node);
          return;
      }
  
      ASSERT(leftChild.useKind() == UntypedUse &amp;&amp; rightChild.useKind() == UntypedUse);
      emitUntypedBitOp&lt;JITLeftShiftGenerator, operationValueBitLShift&gt;(node);
  }
  
<span class="udiff-line-added">+ void SpeculativeJIT::compileValueBitRShift(Node* node)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     Edge&amp; leftChild = node-&gt;child1();</span>
<span class="udiff-line-added">+     Edge&amp; rightChild = node-&gt;child2();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (node-&gt;isBinaryUseKind(BigIntUse)) {</span>
<span class="udiff-line-added">+         SpeculateCellOperand left(this, leftChild);</span>
<span class="udiff-line-added">+         SpeculateCellOperand right(this, rightChild);</span>
<span class="udiff-line-added">+         GPRReg leftGPR = left.gpr();</span>
<span class="udiff-line-added">+         GPRReg rightGPR = right.gpr();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         speculateBigInt(leftChild, leftGPR);</span>
<span class="udiff-line-added">+         speculateBigInt(rightChild, rightGPR);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         flushRegisters();</span>
<span class="udiff-line-added">+         GPRFlushedCallResult result(this);</span>
<span class="udiff-line-added">+         GPRReg resultGPR = result.gpr();</span>
<span class="udiff-line-added">+         callOperation(operationBitRShiftBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
<span class="udiff-line-added">+         m_jit.exceptionCheck();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         cellResult(resultGPR, node);</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     ASSERT(leftChild.useKind() == UntypedUse &amp;&amp; rightChild.useKind() == UntypedUse);</span>
<span class="udiff-line-added">+     emitUntypedRightShiftBitOp(node);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void SpeculativeJIT::compileShiftOp(Node* node)
  {
      NodeType op = node-&gt;op();
      Edge&amp; leftChild = node-&gt;child1();
      Edge&amp; rightChild = node-&gt;child2();
  
      if (leftChild.useKind() == UntypedUse || rightChild.useKind() == UntypedUse) {
<span class="udiff-line-modified-removed">-         switch (op) {</span>
<span class="udiff-line-modified-removed">-         case BitRShift:</span>
<span class="udiff-line-modified-removed">-         case BitURShift:</span>
<span class="udiff-line-removed">-             emitUntypedRightShiftBitOp(node);</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-         default:</span>
<span class="udiff-line-removed">-             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         RELEASE_ASSERT(op == BitURShift);</span>
<span class="udiff-line-modified-added">+         emitUntypedRightShiftBitOp(node);</span>
<span class="udiff-line-modified-added">+         return;</span>
      }
  
      if (rightChild-&gt;isInt32Constant()) {
          SpeculateInt32Operand op1(this, leftChild);
          GPRTemporary result(this, Reuse, op1);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3942,11 +3995,11 @@</span>
          speculateBigInt(rightChild, rightGPR);
  
          flushRegisters();
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-         callOperation(operationAddBigInt, resultGPR, leftGPR, rightGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationAddBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
          m_jit.exceptionCheck();
  
          cellResult(resultGPR, node);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3958,11 +4011,11 @@</span>
          JSValueRegs rightRegs = right.jsValueRegs();
  
          flushRegisters();
          JSValueRegsFlushedCallResult result(this);
          JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-         callOperation(operationValueAddNotNumber, resultRegs, leftRegs, rightRegs);</span>
<span class="udiff-line-modified-added">+         callOperation(operationValueAddNotNumber, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
          m_jit.exceptionCheck();
  
          jsValueResult(resultRegs, node);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3974,12 +4027,12 @@</span>
      bool needsScratchGPRReg = true;
      bool needsScratchFPRReg = true;
  #endif
  
      CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="udiff-line-modified-removed">-     unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="udiff-line-modified-removed">-     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
<span class="udiff-line-modified-added">+     BytecodeIndex bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="udiff-line-modified-added">+     BinaryArithProfile* arithProfile = baselineCodeBlock-&gt;binaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
      JITAddIC* addIC = m_jit.codeBlock()-&gt;addJITAddIC(arithProfile);
      auto repatchingFunction = operationValueAddOptimize;
      auto nonRepatchingFunction = operationValueAdd;
  
      compileMathIC(node, addIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3998,12 +4051,12 @@</span>
          bool needsScratchGPRReg = true;
          bool needsScratchFPRReg = true;
  #endif
  
          CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="udiff-line-modified-removed">-         unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="udiff-line-modified-removed">-         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
<span class="udiff-line-modified-added">+         BytecodeIndex bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="udiff-line-modified-added">+         BinaryArithProfile* arithProfile = baselineCodeBlock-&gt;binaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
          JITSubIC* subIC = m_jit.codeBlock()-&gt;addJITSubIC(arithProfile);
          auto repatchingFunction = operationValueSubOptimize;
          auto nonRepatchingFunction = operationValueSub;
  
          compileMathIC(node, subIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4022,11 +4075,11 @@</span>
  
      flushRegisters();
      GPRFlushedCallResult result(this);
      GPRReg resultGPR = result.gpr();
  
<span class="udiff-line-modified-removed">-     callOperation(operationSubBigInt, resultGPR, leftGPR, rightGPR);</span>
<span class="udiff-line-modified-added">+     callOperation(operationSubBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
  
      m_jit.exceptionCheck();
      cellResult(resultGPR, node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4129,13 +4182,13 @@</span>
                  innerRightRegs = resultRegs;
                  m_jit.moveValue(rightChild-&gt;asJSValue(), innerRightRegs);
              }
  
              if (addICGenerationState-&gt;shouldSlowPathRepatch)
<span class="udiff-line-modified-removed">-                 addICGenerationState-&gt;slowPathCall = callOperation(bitwise_cast&lt;J_JITOperation_EJJMic&gt;(repatchingFunction), resultRegs, innerLeftRegs, innerRightRegs, TrustedImmPtr(mathIC));</span>
<span class="udiff-line-modified-added">+                 addICGenerationState-&gt;slowPathCall = callOperation(bitwise_cast&lt;J_JITOperation_GJJMic&gt;(repatchingFunction), resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), innerLeftRegs, innerRightRegs, TrustedImmPtr(mathIC));</span>
              else
<span class="udiff-line-modified-removed">-                 addICGenerationState-&gt;slowPathCall = callOperation(nonRepatchingFunction, resultRegs, innerLeftRegs, innerRightRegs);</span>
<span class="udiff-line-modified-added">+                 addICGenerationState-&gt;slowPathCall = callOperation(nonRepatchingFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), innerLeftRegs, innerRightRegs);</span>
  
              silentFill(savePlans);
              m_jit.exceptionCheck();
              m_jit.jump().linkTo(done, &amp;m_jit);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4160,11 +4213,11 @@</span>
              right.emplace(this, rightChild);
              rightRegs = right-&gt;jsValueRegs();
          }
  
          flushRegisters();
<span class="udiff-line-modified-removed">-         callOperation(nonRepatchingFunction, resultRegs, leftRegs, rightRegs);</span>
<span class="udiff-line-modified-added">+         callOperation(nonRepatchingFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
          m_jit.exceptionCheck();
      }
  
  #if ENABLE(MATH_IC_STATS)
      auto inlineEnd = m_jit.label();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4193,11 +4246,11 @@</span>
      JSValueRegs hasInstanceRegs = hasInstanceValue.jsValueRegs();
      GPRReg resultGPR = result.gpr();
  
      MacroAssembler::Jump slowCase = m_jit.jump();
  
<span class="udiff-line-modified-removed">-     addSlowPathGenerator(slowPathCall(slowCase, this, operationInstanceOfCustom, resultGPR, valueRegs, constructorGPR, hasInstanceRegs));</span>
<span class="udiff-line-modified-added">+     addSlowPathGenerator(slowPathCall(slowCase, this, operationInstanceOfCustom, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs, constructorGPR, hasInstanceRegs));</span>
  
      unblessedBooleanResult(resultGPR, node);
  }
  
  void SpeculativeJIT::compileIsCellWithType(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4288,13 +4341,16 @@</span>
      MacroAssembler::JumpList slowCases;
      slowCases.append(m_jit.branchIfNotCell(valueRegs));
      slowCases.append(m_jit.branchIfNotObject(valueRegs.payloadGPR()));
      m_jit.move(valueRegs.payloadGPR(), resultGPR);
  
<span class="udiff-line-modified-removed">-     if (node-&gt;op() == ToObject)</span>
<span class="udiff-line-modified-removed">-         addSlowPathGenerator(slowPathCall(slowCases, this, operationToObject, resultGPR, m_jit.graph().globalObjectFor(node-&gt;origin.semantic), valueRegs, identifierUID(node-&gt;identifierNumber())));</span>
<span class="udiff-line-modified-removed">-     else</span>
<span class="udiff-line-modified-added">+     if (node-&gt;op() == ToObject) {</span>
<span class="udiff-line-modified-added">+         UniquedStringImpl* errorMessage = nullptr;</span>
<span class="udiff-line-modified-added">+         if (node-&gt;identifierNumber() != UINT32_MAX)</span>
<span class="udiff-line-added">+             errorMessage = identifierUID(node-&gt;identifierNumber());</span>
<span class="udiff-line-added">+         addSlowPathGenerator(slowPathCall(slowCases, this, operationToObject, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs, errorMessage));</span>
<span class="udiff-line-added">+     } else</span>
          addSlowPathGenerator(slowPathCall(slowCases, this, operationCallObjectConstructor, resultGPR, TrustedImmPtr(node-&gt;cellOperand()), valueRegs));
  
      cellResult(resultGPR, node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4435,11 +4491,11 @@</span>
          DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
          JSValueOperand op1(this, node-&gt;child1());
          JSValueRegs op1Regs = op1.jsValueRegs();
          flushRegisters();
          FPRResult result(this);
<span class="udiff-line-modified-removed">-         callOperation(operationArithAbs, result.fpr(), op1Regs);</span>
<span class="udiff-line-modified-added">+         callOperation(operationArithAbs, result.fpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
          m_jit.exceptionCheck();
          doubleResult(result.fpr(), node);
          break;
      }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4459,16 +4515,16 @@</span>
      JSValueOperand op1(this, node-&gt;child1());
      JSValueRegs op1Regs = op1.jsValueRegs();
      GPRTemporary result(this);
      GPRReg resultReg = result.gpr();
      flushRegisters();
<span class="udiff-line-modified-removed">-     callOperation(operationArithClz32, resultReg, op1Regs);</span>
<span class="udiff-line-modified-added">+     callOperation(operationArithClz32, resultReg, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
      m_jit.exceptionCheck();
      int32Result(resultReg, node);
  }
  
<span class="udiff-line-modified-removed">- void SpeculativeJIT::compileArithDoubleUnaryOp(Node* node, double (*doubleFunction)(double), double (*operation)(ExecState*, EncodedJSValue))</span>
<span class="udiff-line-modified-added">+ void SpeculativeJIT::compileArithDoubleUnaryOp(Node* node, double (*doubleFunction)(double), double (*operation)(JSGlobalObject*, EncodedJSValue))</span>
  {
      if (node-&gt;child1().useKind() == DoubleRepUse) {
          SpeculateDoubleOperand op1(this, node-&gt;child1());
          FPRReg op1FPR = op1.fpr();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4483,11 +4539,11 @@</span>
  
      JSValueOperand op1(this, node-&gt;child1());
      JSValueRegs op1Regs = op1.jsValueRegs();
      flushRegisters();
      FPRResult result(this);
<span class="udiff-line-modified-removed">-     callOperation(operation, result.fpr(), op1Regs);</span>
<span class="udiff-line-modified-added">+     callOperation(operation, result.fpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
      m_jit.exceptionCheck();
      doubleResult(result.fpr(), node);
  }
  
  void SpeculativeJIT::compileArithSub(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4589,15 +4645,31 @@</span>
          RELEASE_ASSERT_NOT_REACHED();
          return;
      }
  }
  
<span class="udiff-line-added">+ void SpeculativeJIT::compileIncOrDec(Node* node)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // In all other cases the node should have been transformed into an add or a sub by FixupPhase</span>
<span class="udiff-line-added">+     ASSERT(node-&gt;child1().useKind() == UntypedUse);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     JSValueOperand op1(this, node-&gt;child1());</span>
<span class="udiff-line-added">+     JSValueRegs op1Regs = op1.jsValueRegs();</span>
<span class="udiff-line-added">+     flushRegisters();</span>
<span class="udiff-line-added">+     JSValueRegsFlushedCallResult result(this);</span>
<span class="udiff-line-added">+     JSValueRegs resultRegs = result.regs();</span>
<span class="udiff-line-added">+     auto operation = node-&gt;op() == Inc ? operationInc : operationDec;</span>
<span class="udiff-line-added">+     callOperation(operation, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
<span class="udiff-line-added">+     m_jit.exceptionCheck();</span>
<span class="udiff-line-added">+     jsValueResult(resultRegs, node);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void SpeculativeJIT::compileValueNegate(Node* node)
  {
      CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="udiff-line-modified-removed">-     unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="udiff-line-modified-removed">-     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
<span class="udiff-line-modified-added">+     BytecodeIndex bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="udiff-line-modified-added">+     UnaryArithProfile* arithProfile = baselineCodeBlock-&gt;unaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
      JITNegIC* negIC = m_jit.codeBlock()-&gt;addJITNegIC(arithProfile);
      auto repatchingFunction = operationArithNegateOptimize;
      auto nonRepatchingFunction = operationArithNegate;
      bool needsScratchGPRReg = true;
      compileMathIC(node, negIC, needsScratchGPRReg, repatchingFunction, nonRepatchingFunction);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4727,13 +4799,13 @@</span>
  #endif
  
              silentSpill(savePlans);
  
              if (icGenerationState-&gt;shouldSlowPathRepatch)
<span class="udiff-line-modified-removed">-                 icGenerationState-&gt;slowPathCall = callOperation(bitwise_cast&lt;J_JITOperation_EJMic&gt;(repatchingFunction), resultRegs, childRegs, TrustedImmPtr(mathIC));</span>
<span class="udiff-line-modified-added">+                 icGenerationState-&gt;slowPathCall = callOperation(bitwise_cast&lt;J_JITOperation_GJMic&gt;(repatchingFunction), resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), childRegs, TrustedImmPtr(mathIC));</span>
              else
<span class="udiff-line-modified-removed">-                 icGenerationState-&gt;slowPathCall = callOperation(nonRepatchingFunction, resultRegs, childRegs);</span>
<span class="udiff-line-modified-added">+                 icGenerationState-&gt;slowPathCall = callOperation(nonRepatchingFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), childRegs);</span>
  
              silentFill(savePlans);
              m_jit.exceptionCheck();
              m_jit.jump().linkTo(done, &amp;m_jit);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4750,11 +4822,11 @@</span>
  #endif
  
          });
      } else {
          flushRegisters();
<span class="udiff-line-modified-removed">-         callOperation(nonRepatchingFunction, resultRegs, childRegs);</span>
<span class="udiff-line-modified-added">+         callOperation(nonRepatchingFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), childRegs);</span>
          m_jit.exceptionCheck();
      }
  
  #if ENABLE(MATH_IC_STATS)
      auto inlineEnd = m_jit.label();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4784,11 +4856,11 @@</span>
  
          flushRegisters();
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
  
<span class="udiff-line-modified-removed">-         callOperation(operationMulBigInt, resultGPR, leftGPR, rightGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationMulBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
  
          m_jit.exceptionCheck();
          cellResult(resultGPR, node);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4800,11 +4872,11 @@</span>
          JSValueRegs rightRegs = right.jsValueRegs();
  
          flushRegisters();
          JSValueRegsFlushedCallResult result(this);
          JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-         callOperation(operationValueMul, resultRegs, leftRegs, rightRegs);</span>
<span class="udiff-line-modified-added">+         callOperation(operationValueMul, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
          m_jit.exceptionCheck();
  
          jsValueResult(resultRegs, node);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4815,12 +4887,12 @@</span>
  #else
      bool needsScratchFPRReg = true;
  #endif
  
      CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<span class="udiff-line-modified-removed">-     unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="udiff-line-modified-removed">-     ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);</span>
<span class="udiff-line-modified-added">+     BytecodeIndex bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="udiff-line-modified-added">+     BinaryArithProfile* arithProfile = baselineCodeBlock-&gt;binaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
      JITMulIC* mulIC = m_jit.codeBlock()-&gt;addJITMulIC(arithProfile);
      auto repatchingFunction = operationValueMulOptimize;
      auto nonRepatchingFunction = operationValueMul;
  
      compileMathIC(node, mulIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4986,11 +5058,11 @@</span>
  
          flushRegisters();
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
  
<span class="udiff-line-modified-removed">-         callOperation(operationDivBigInt, resultGPR, leftGPR, rightGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationDivBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
  
          m_jit.exceptionCheck();
          cellResult(resultGPR, node);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5002,11 +5074,11 @@</span>
          JSValueRegs rightRegs = right.jsValueRegs();
  
          flushRegisters();
          JSValueRegsFlushedCallResult result(this);
          JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-         callOperation(operationValueDiv, resultRegs, leftRegs, rightRegs);</span>
<span class="udiff-line-modified-added">+         callOperation(operationValueDiv, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
          m_jit.exceptionCheck();
  
          jsValueResult(resultRegs, node);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5084,11 +5156,11 @@</span>
      if (rightOperand.isConst()) {
          rightRegs = resultRegs;
          m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
      }
  
<span class="udiff-line-modified-removed">-     callOperation(operationValueDiv, resultRegs, leftRegs, rightRegs);</span>
<span class="udiff-line-modified-added">+     callOperation(operationValueDiv, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
  
      silentFillAllRegisters();
      m_jit.exceptionCheck();
  
      gen.endJumpList().link(&amp;m_jit);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5097,11 +5169,11 @@</span>
  
  void SpeculativeJIT::compileArithDiv(Node* node)
  {
      switch (node-&gt;binaryUseKind()) {
      case Int32Use: {
<span class="udiff-line-modified-removed">- #if CPU(X86) || CPU(X86_64)</span>
<span class="udiff-line-modified-added">+ #if CPU(X86_64)</span>
          SpeculateInt32Operand op1(this, node-&gt;child1());
          SpeculateInt32Operand op2(this, node-&gt;child2());
          GPRTemporary eax(this, X86Registers::eax);
          GPRTemporary edx(this, X86Registers::edx);
          GPRReg op1GPR = op1.gpr();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5248,11 +5320,11 @@</span>
  
      JSValueOperand op1(this, node-&gt;child1());
      JSValueRegs op1Regs = op1.jsValueRegs();
      flushRegisters();
      FPRResult result(this);
<span class="udiff-line-modified-removed">-     callOperation(operationArithFRound, result.fpr(), op1Regs);</span>
<span class="udiff-line-modified-added">+     callOperation(operationArithFRound, result.fpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
      m_jit.exceptionCheck();
      doubleResult(result.fpr(), node);
  }
  
  void SpeculativeJIT::compileValueMod(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5271,11 +5343,11 @@</span>
  
          flushRegisters();
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
  
<span class="udiff-line-modified-removed">-         callOperation(operationModBigInt, resultGPR, leftGPR, rightGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationModBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
  
          m_jit.exceptionCheck();
          cellResult(resultGPR, node);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5286,11 +5358,11 @@</span>
      JSValueRegs op1Regs = op1.jsValueRegs();
      JSValueRegs op2Regs = op2.jsValueRegs();
      flushRegisters();
      JSValueRegsFlushedCallResult result(this);
      JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-     callOperation(operationValueMod, resultRegs, op1Regs, op2Regs);</span>
<span class="udiff-line-modified-added">+     callOperation(operationValueMod, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs, op2Regs);</span>
      m_jit.exceptionCheck();
      jsValueResult(resultRegs, node);
  }
  
  void SpeculativeJIT::compileArithMod(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5360,11 +5432,11 @@</span>
                  int32Result(resultGPR, node);
                  return;
              }
          }
  
<span class="udiff-line-modified-removed">- #if CPU(X86) || CPU(X86_64)</span>
<span class="udiff-line-modified-added">+ #if CPU(X86_64)</span>
          if (node-&gt;child2()-&gt;isInt32Constant()) {
              int32_t divisor = node-&gt;child2()-&gt;asInt32();
              if (divisor &amp;&amp; divisor != -1) {
                  GPRReg op1Gpr = op1.gpr();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5401,11 +5473,11 @@</span>
              }
          }
  #endif
  
          SpeculateInt32Operand op2(this, node-&gt;child2());
<span class="udiff-line-modified-removed">- #if CPU(X86) || CPU(X86_64)</span>
<span class="udiff-line-modified-added">+ #if CPU(X86_64)</span>
          GPRTemporary eax(this, X86Registers::eax);
          GPRTemporary edx(this, X86Registers::edx);
          GPRReg op1GPR = op1.gpr();
          GPRReg op2GPR = op2.gpr();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5596,27 +5668,25 @@</span>
              switch (node-&gt;op()) {
              case ArithRound: {
                  FPRTemporary result(this);
                  FPRReg resultFPR = result.fpr();
                  if (producesInteger(node-&gt;arithRoundingMode()) &amp;&amp; !shouldCheckNegativeZero(node-&gt;arithRoundingMode())) {
<span class="udiff-line-modified-removed">-                     static const double halfConstant = 0.5;</span>
<span class="udiff-line-modified-added">+                     static constexpr double halfConstant = 0.5;</span>
                      m_jit.loadDouble(TrustedImmPtr(&amp;halfConstant), resultFPR);
                      m_jit.addDouble(valueFPR, resultFPR);
                      m_jit.floorDouble(resultFPR, resultFPR);
                  } else {
                      m_jit.ceilDouble(valueFPR, resultFPR);
<span class="udiff-line-removed">-                     FPRTemporary realPart(this);</span>
<span class="udiff-line-removed">-                     FPRReg realPartFPR = realPart.fpr();</span>
<span class="udiff-line-removed">-                     m_jit.subDouble(resultFPR, valueFPR, realPartFPR);</span>
  
                      FPRTemporary scratch(this);
                      FPRReg scratchFPR = scratch.fpr();
<span class="udiff-line-modified-removed">-                     static const double halfConstant = 0.5;</span>
<span class="udiff-line-modified-added">+                     static constexpr double halfConstant = -0.5;</span>
                      m_jit.loadDouble(TrustedImmPtr(&amp;halfConstant), scratchFPR);
<span class="udiff-line-added">+                     m_jit.addDouble(resultFPR, scratchFPR);</span>
  
<span class="udiff-line-modified-removed">-                     JITCompiler::Jump shouldUseCeiled = m_jit.branchDouble(JITCompiler::DoubleLessThanOrEqual, realPartFPR, scratchFPR);</span>
<span class="udiff-line-modified-removed">-                     static const double oneConstant = -1.0;</span>
<span class="udiff-line-modified-added">+                     JITCompiler::Jump shouldUseCeiled = m_jit.branchDouble(JITCompiler::DoubleLessThanOrEqual, scratchFPR, valueFPR);</span>
<span class="udiff-line-modified-added">+                     static constexpr double oneConstant = -1.0;</span>
                      m_jit.loadDouble(TrustedImmPtr(&amp;oneConstant), scratchFPR);
                      m_jit.addDouble(scratchFPR, resultFPR);
                      shouldUseCeiled.link(&amp;m_jit);
                  }
                  setResult(resultFPR);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5676,22 +5746,22 @@</span>
      JSValueRegs argumentRegs = argument.jsValueRegs();
  
      flushRegisters();
      JSValueRegsFlushedCallResult result(this);
      JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-     J_JITOperation_EJ operation = nullptr;</span>
<span class="udiff-line-modified-added">+     J_JITOperation_GJ operation = nullptr;</span>
      if (node-&gt;op() == ArithRound)
          operation = operationArithRound;
      else if (node-&gt;op() == ArithFloor)
          operation = operationArithFloor;
      else if (node-&gt;op() == ArithCeil)
          operation = operationArithCeil;
      else {
          ASSERT(node-&gt;op() == ArithTrunc);
          operation = operationArithTrunc;
      }
<span class="udiff-line-modified-removed">-     callOperation(operation, resultRegs, argumentRegs);</span>
<span class="udiff-line-modified-added">+     callOperation(operation, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentRegs);</span>
      m_jit.exceptionCheck();
      jsValueResult(resultRegs, node);
  }
  
  void SpeculativeJIT::compileArithUnary(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5720,11 +5790,11 @@</span>
  
      JSValueOperand op1(this, node-&gt;child1());
      JSValueRegs op1Regs = op1.jsValueRegs();
      flushRegisters();
      FPRResult result(this);
<span class="udiff-line-modified-removed">-     callOperation(operationArithSqrt, result.fpr(), op1Regs);</span>
<span class="udiff-line-modified-added">+     callOperation(operationArithSqrt, result.fpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
      m_jit.exceptionCheck();
      doubleResult(result.fpr(), node);
  }
  
  void SpeculativeJIT::compileArithMinMax(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5802,11 +5872,11 @@</span>
  static MacroAssembler::Jump compileArithPowIntegerFastPath(JITCompiler&amp; assembler, FPRReg xOperand, GPRReg yOperand, FPRReg result)
  {
      MacroAssembler::JumpList skipFastPath;
      skipFastPath.append(assembler.branch32(MacroAssembler::Above, yOperand, MacroAssembler::TrustedImm32(maxExponentForIntegerMathPow)));
  
<span class="udiff-line-modified-removed">-     static const double oneConstant = 1.0;</span>
<span class="udiff-line-modified-added">+     static constexpr double oneConstant = 1.0;</span>
      assembler.loadDouble(MacroAssembler::TrustedImmPtr(&amp;oneConstant), result);
  
      MacroAssembler::Label startLoop(assembler.label());
      MacroAssembler::Jump exponentIsEven = assembler.branchTest32(MacroAssembler::Zero, yOperand, MacroAssembler::TrustedImm32(1));
      assembler.mulDouble(xOperand, result);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5837,11 +5907,11 @@</span>
  
          flushRegisters();
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
  
<span class="udiff-line-modified-removed">-         callOperation(operationPowBigInt, resultGPR, leftGPR, rightGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationPowBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
  
          m_jit.exceptionCheck();
          cellResult(resultGPR, node);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5854,11 +5924,11 @@</span>
      JSValueRegs rightRegs = right.jsValueRegs();
  
      flushRegisters();
      JSValueRegsFlushedCallResult result(this);
      JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-     callOperation(operationValuePow, resultRegs, leftRegs, rightRegs);</span>
<span class="udiff-line-modified-added">+     callOperation(operationValuePow, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
      m_jit.exceptionCheck();
  
      jsValueResult(resultRegs, node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5893,12 +5963,12 @@</span>
          return;
      }
  
      if (node-&gt;child2()-&gt;isDoubleConstant()) {
          double exponent = node-&gt;child2()-&gt;asNumber();
<span class="udiff-line-modified-removed">-         static const double infinityConstant = std::numeric_limits&lt;double&gt;::infinity();</span>
<span class="udiff-line-modified-removed">-         static const double minusInfinityConstant = -std::numeric_limits&lt;double&gt;::infinity();</span>
<span class="udiff-line-modified-added">+         static constexpr double infinityConstant = std::numeric_limits&lt;double&gt;::infinity();</span>
<span class="udiff-line-modified-added">+         static constexpr double minusInfinityConstant = -std::numeric_limits&lt;double&gt;::infinity();</span>
          if (exponent == 0.5) {
              SpeculateDoubleOperand xOperand(this, node-&gt;child1());
              FPRTemporary result(this);
              FPRReg xOperandFpr = xOperand.fpr();
              FPRReg resultFpr = result.fpr();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5934,11 +6004,11 @@</span>
              MacroAssembler::Jump xIsZeroOrNegativeZero = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
  
              m_jit.loadDouble(TrustedImmPtr(&amp;minusInfinityConstant), resultFpr);
              MacroAssembler::Jump xIsMinusInfinity = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
  
<span class="udiff-line-modified-removed">-             static const double oneConstant = 1.;</span>
<span class="udiff-line-modified-added">+             static constexpr double oneConstant = 1.;</span>
              m_jit.loadDouble(TrustedImmPtr(&amp;oneConstant), resultFpr);
              m_jit.sqrtDouble(xOperandFpr, scratchFPR);
              m_jit.divDouble(resultFpr, scratchFPR, resultFpr);
              MacroAssembler::Jump doneWithSqrt = m_jit.jump();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5985,11 +6055,11 @@</span>
      skipFallback.link(&amp;m_jit);
      doubleResult(resultFpr, node);
  }
  
  // Returns true if the compare is fused with a subsequent branch.
<span class="udiff-line-modified-removed">- bool SpeculativeJIT::compare(Node* node, MacroAssembler::RelationalCondition condition, MacroAssembler::DoubleCondition doubleCondition, S_JITOperation_EJJ operation)</span>
<span class="udiff-line-modified-added">+ bool SpeculativeJIT::compare(Node* node, MacroAssembler::RelationalCondition condition, MacroAssembler::DoubleCondition doubleCondition, S_JITOperation_GJJ operation)</span>
  {
      if (compilePeepHoleBranch(node, condition, doubleCondition, operation))
          return true;
  
      if (node-&gt;isBinaryUseKind(Int32Use)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6439,11 +6509,11 @@</span>
      moveFalseTo(leftTempGPR);
  
      done.link(&amp;m_jit);
      addSlowPathGenerator(
          slowPathCall(
<span class="udiff-line-modified-removed">-             slowCase, this, operationCompareStringEq, leftTempGPR, leftGPR, rightGPR));</span>
<span class="udiff-line-modified-added">+             slowCase, this, operationCompareStringEq, leftTempGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR));</span>
  
      blessedBooleanResult(leftTempGPR, node);
  }
  
  void SpeculativeJIT::compileStringEquality(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6573,11 +6643,11 @@</span>
      GPRReg rightGPR = right.gpr();
  
      speculateString(node-&gt;child1(), leftGPR);
      speculateString(node-&gt;child2(), rightGPR);
  
<span class="udiff-line-modified-removed">-     C_JITOperation_B_EJssJss compareFunction = nullptr;</span>
<span class="udiff-line-modified-added">+     C_JITOperation_B_GJssJss compareFunction = nullptr;</span>
      if (condition == MacroAssembler::LessThan)
          compareFunction = operationCompareStringLess;
      else if (condition == MacroAssembler::LessThanOrEqual)
          compareFunction = operationCompareStringLessEq;
      else if (condition == MacroAssembler::GreaterThan)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6589,11 +6659,11 @@</span>
  
      GPRFlushedCallResult result(this);
      GPRReg resultGPR = result.gpr();
  
      flushRegisters();
<span class="udiff-line-modified-removed">-     callOperation(compareFunction, resultGPR, leftGPR, rightGPR);</span>
<span class="udiff-line-modified-added">+     callOperation(compareFunction, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
      m_jit.exceptionCheck();
  
      unblessedBooleanResult(resultGPR, node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6690,11 +6760,11 @@</span>
  
      flushRegisters();
  
      GPRFlushedCallResult result(this);
      GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-     callOperation(operationSameValue, resultGPR, arg1Regs, arg2Regs);</span>
<span class="udiff-line-modified-added">+     callOperation(operationSameValue, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);</span>
      m_jit.exceptionCheck();
  
      unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6829,11 +6899,11 @@</span>
          m_jit.loadPtr(MacroAssembler::Address(baseReg, JSString::offsetOfValue()), storageReg);
  
          addSlowPathGenerator(
              slowPathCall(
                  m_jit.branchIfRopeStringImpl(storageReg),
<span class="udiff-line-modified-removed">-                 this, operationResolveRope, storageReg, baseReg));</span>
<span class="udiff-line-modified-added">+                 this, operationResolveRope, storageReg, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg));</span>
  
          m_jit.loadPtr(MacroAssembler::Address(storageReg, StringImpl::dataOffset()), storageReg);
          break;
  
      default: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6936,11 +7006,11 @@</span>
  
      if (!node-&gt;arrayMode().isInBounds()) {
          addSlowPathGenerator(
              slowPathCall(
                  isOutOfBounds, this, operationGetByValObjectInt,
<span class="udiff-line-modified-removed">-                 extractResult(resultRegs), baseReg, propertyReg));</span>
<span class="udiff-line-modified-added">+                 extractResult(resultRegs), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg));</span>
      }
  
      jsValueResult(resultRegs, node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6949,35 +7019,30 @@</span>
      SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
      SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
      JSValueRegsTemporary result(this);
      GPRTemporary scratch(this);
      GPRTemporary scratch2(this);
<span class="udiff-line-removed">-     GPRTemporary indexMask(this);</span>
  
      GPRReg baseReg = base.gpr();
      GPRReg propertyReg = property.gpr();
      JSValueRegs resultRegs = result.regs();
      GPRReg scratchReg = scratch.gpr();
      GPRReg scratch2Reg = scratch2.gpr();
<span class="udiff-line-removed">-     GPRReg indexMaskReg = indexMask.gpr();</span>
  
      if (!m_compileOkay)
          return;
  
      ASSERT(ArrayMode(Array::ScopedArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(m_graph.varArgChild(node, 0))));
  
      m_jit.loadPtr(
          MacroAssembler::Address(baseReg, ScopedArguments::offsetOfStorage()), resultRegs.payloadGPR());
<span class="udiff-line-removed">-     m_jit.load32(</span>
<span class="udiff-line-removed">-         MacroAssembler::Address(resultRegs.payloadGPR(), ScopedArguments::offsetOfTotalLengthInStorage()),</span>
<span class="udiff-line-removed">-         scratchReg);</span>
  
      speculationCheck(
          ExoticObjectMode, JSValueSource(), nullptr,
<span class="udiff-line-modified-removed">-         m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, scratchReg));</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     m_jit.emitPreparePreciseIndexMask32(propertyReg, scratchReg, indexMaskReg);</span>
<span class="udiff-line-modified-added">+         m_jit.branch32(</span>
<span class="udiff-line-modified-added">+             MacroAssembler::AboveOrEqual, propertyReg,</span>
<span class="udiff-line-modified-added">+             MacroAssembler::Address(baseReg, ScopedArguments::offsetOfTotalLength())));</span>
  
      m_jit.loadPtr(MacroAssembler::Address(baseReg, ScopedArguments::offsetOfTable()), scratchReg);
      m_jit.load32(
          MacroAssembler::Address(scratchReg, ScopedArgumentsTable::offsetOfLength()), scratch2Reg);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7016,12 +7081,10 @@</span>
          resultRegs);
      speculationCheck(ExoticObjectMode, JSValueSource(), nullptr, m_jit.branchIfEmpty(resultRegs));
  
      done.link(&amp;m_jit);
  
<span class="udiff-line-removed">-     m_jit.andPtr(indexMaskReg, resultRegs.payloadGPR());</span>
<span class="udiff-line-removed">- </span>
      jsValueResult(resultRegs, node);
  }
  
  void SpeculativeJIT::compileGetScope(Node* node)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7148,31 +7211,28 @@</span>
          int32Result(resultReg, node);
          break;
      }
      case Array::ScopedArguments: {
          SpeculateCellOperand base(this, node-&gt;child1());
<span class="udiff-line-modified-removed">-         GPRTemporary result(this);</span>
<span class="udiff-line-modified-added">+         GPRTemporary result(this, Reuse, base);</span>
  
          GPRReg baseReg = base.gpr();
          GPRReg resultReg = result.gpr();
  
          if (!m_compileOkay)
              return;
  
          ASSERT(ArrayMode(Array::ScopedArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(node-&gt;child1())));
  
<span class="udiff-line-removed">-         m_jit.loadPtr(</span>
<span class="udiff-line-removed">-             MacroAssembler::Address(baseReg, ScopedArguments::offsetOfStorage()), resultReg);</span>
<span class="udiff-line-removed">- </span>
          speculationCheck(
              ExoticObjectMode, JSValueSource(), 0,
              m_jit.branchTest8(
                  MacroAssembler::NonZero,
<span class="udiff-line-modified-removed">-                 MacroAssembler::Address(resultReg, ScopedArguments::offsetOfOverrodeThingsInStorage())));</span>
<span class="udiff-line-modified-added">+                 MacroAssembler::Address(baseReg, ScopedArguments::offsetOfOverrodeThings())));</span>
  
          m_jit.load32(
<span class="udiff-line-modified-removed">-             MacroAssembler::Address(resultReg, ScopedArguments::offsetOfTotalLengthInStorage()), resultReg);</span>
<span class="udiff-line-modified-added">+             MacroAssembler::Address(baseReg, ScopedArguments::offsetOfTotalLength()), resultReg);</span>
  
          int32Result(resultReg, node);
          break;
      }
      default: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7185,60 +7245,42 @@</span>
          int32Result(resultGPR, node);
          break;
      } }
  }
  
<span class="udiff-line-modified-removed">- void SpeculativeJIT::compileCheckStringIdent(Node* node)</span>
<span class="udiff-line-modified-added">+ void SpeculativeJIT::compileCheckIdent(Node* node)</span>
  {
<span class="udiff-line-modified-removed">-     SpeculateCellOperand string(this, node-&gt;child1());</span>
<span class="udiff-line-modified-removed">-     GPRTemporary storage(this);</span>
<span class="udiff-line-modified-added">+     SpeculateCellOperand stringOrSymbol(this, node-&gt;child1());</span>
<span class="udiff-line-modified-added">+     GPRTemporary impl(this);</span>
<span class="udiff-line-added">+     GPRReg stringOrSymbolGPR = stringOrSymbol.gpr();</span>
<span class="udiff-line-added">+     GPRReg implGPR = impl.gpr();</span>
  
<span class="udiff-line-modified-removed">-     GPRReg stringGPR = string.gpr();</span>
<span class="udiff-line-modified-removed">-     GPRReg storageGPR = storage.gpr();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     speculateString(node-&gt;child1(), stringGPR);</span>
<span class="udiff-line-modified-removed">-     speculateStringIdentAndLoadStorage(node-&gt;child1(), stringGPR, storageGPR);</span>
<span class="udiff-line-modified-added">+     if (node-&gt;child1().useKind() == StringIdentUse) {</span>
<span class="udiff-line-modified-added">+         speculateString(node-&gt;child1(), stringOrSymbolGPR);</span>
<span class="udiff-line-modified-added">+         speculateStringIdentAndLoadStorage(node-&gt;child1(), stringOrSymbolGPR, implGPR);</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+         ASSERT(node-&gt;child1().useKind() == SymbolUse);</span>
<span class="udiff-line-added">+         speculateSymbol(node-&gt;child1(), stringOrSymbolGPR);</span>
<span class="udiff-line-added">+         m_jit.loadPtr(MacroAssembler::Address(stringOrSymbolGPR, Symbol::offsetOfSymbolImpl()), implGPR);</span>
<span class="udiff-line-added">+     }</span>
  
      UniquedStringImpl* uid = node-&gt;uidOperand();
      speculationCheck(
          BadIdent, JSValueSource(), nullptr,
<span class="udiff-line-modified-removed">-         m_jit.branchPtr(JITCompiler::NotEqual, storageGPR, TrustedImmPtr(uid)));</span>
<span class="udiff-line-modified-added">+         m_jit.branchPtr(JITCompiler::NotEqual, implGPR, TrustedImmPtr(uid)));</span>
      noResult(node);
  }
  
  template &lt;typename ClassType&gt;
  void SpeculativeJIT::compileNewFunctionCommon(GPRReg resultGPR, RegisteredStructure structure, GPRReg scratch1GPR, GPRReg scratch2GPR, GPRReg scopeGPR, MacroAssembler::JumpList&amp; slowPath, size_t size, FunctionExecutable* executable)
  {
      auto butterfly = TrustedImmPtr(nullptr);
      emitAllocateJSObjectWithKnownSize&lt;ClassType&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowPath, size);
  
      m_jit.storePtr(scopeGPR, JITCompiler::Address(resultGPR, JSFunction::offsetOfScopeChain()));
<span class="udiff-line-modified-removed">-     m_jit.storePtr(TrustedImmPtr::weakPointer(m_jit.graph(), executable), JITCompiler::Address(resultGPR, JSFunction::offsetOfExecutable()));</span>
<span class="udiff-line-modified-removed">-     m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, JSFunction::offsetOfRareData()));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (executable-&gt;isAnonymousBuiltinFunction()) {</span>
<span class="udiff-line-removed">-         VM&amp; vm = this-&gt;vm();</span>
<span class="udiff-line-removed">-         m_jit.mutatorFence(vm);</span>
<span class="udiff-line-removed">-         GPRTemporary allocator(this);</span>
<span class="udiff-line-removed">-         Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;FunctionRareData&gt;(vm, sizeof(FunctionRareData), AllocatorForMode::AllocatorIfExists);</span>
<span class="udiff-line-removed">-         emitAllocateJSCell(scratch1GPR, JITAllocator::constant(allocatorValue), allocator.gpr(), TrustedImmPtr(m_jit.graph().registerStructure(vm.functionRareDataStructure.get())), scratch2GPR, slowPath);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         ptrdiff_t objectAllocationProfileOffset = FunctionRareData::offsetOfObjectAllocationProfile();</span>
<span class="udiff-line-removed">-         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, objectAllocationProfileOffset + ObjectAllocationProfileWithPrototype::offsetOfAllocator()));</span>
<span class="udiff-line-removed">-         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, objectAllocationProfileOffset + ObjectAllocationProfileWithPrototype::offsetOfStructure()));</span>
<span class="udiff-line-removed">-         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, objectAllocationProfileOffset + ObjectAllocationProfileWithPrototype::offsetOfPrototype()));</span>
<span class="udiff-line-removed">-         m_jit.storePtr(TrustedImmPtr(0x1), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfObjectAllocationProfileWatchpoint()));</span>
<span class="udiff-line-removed">-         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfInternalFunctionAllocationProfile() + InternalFunctionAllocationProfile::offsetOfStructure()));</span>
<span class="udiff-line-removed">-         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfBoundFunctionStructure()));</span>
<span class="udiff-line-removed">-         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfAllocationProfileClearingWatchpoint()));</span>
<span class="udiff-line-removed">-         m_jit.store8(TrustedImm32(0), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfHasReifiedLength()));</span>
<span class="udiff-line-removed">-         m_jit.store8(TrustedImm32(1), JITCompiler::Address(scratch1GPR, FunctionRareData::offsetOfHasReifiedName()));</span>
<span class="udiff-line-removed">-         m_jit.mutatorFence(vm);</span>
<span class="udiff-line-removed">-         m_jit.storePtr(scratch1GPR, JITCompiler::Address(resultGPR, JSFunction::offsetOfRareData()));</span>
<span class="udiff-line-removed">-     } else</span>
<span class="udiff-line-removed">-         m_jit.mutatorFence(vm());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+     m_jit.storePtr(TrustedImmPtr::weakPointer(m_jit.graph(), executable), JITCompiler::Address(resultGPR, JSFunction::offsetOfExecutableOrRareData()));</span>
<span class="udiff-line-modified-added">+     m_jit.mutatorFence(vm());</span>
  }
  
  void SpeculativeJIT::compileNewFunction(Node* node)
  {
      NodeType nodeType = node-&gt;op();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7254,17 +7296,17 @@</span>
          GPRReg resultGPR = result.gpr();
  
          flushRegisters();
  
          if (nodeType == NewGeneratorFunction)
<span class="udiff-line-modified-removed">-             callOperation(operationNewGeneratorFunction, resultGPR, scopeGPR, executable);</span>
<span class="udiff-line-modified-added">+             callOperation(operationNewGeneratorFunction, resultGPR, &amp;vm(), scopeGPR, executable);</span>
          else if (nodeType == NewAsyncFunction)
<span class="udiff-line-modified-removed">-             callOperation(operationNewAsyncFunction, resultGPR, scopeGPR, executable);</span>
<span class="udiff-line-modified-added">+             callOperation(operationNewAsyncFunction, resultGPR, &amp;vm(), scopeGPR, executable);</span>
          else if (nodeType == NewAsyncGeneratorFunction)
<span class="udiff-line-modified-removed">-             callOperation(operationNewAsyncGeneratorFunction, resultGPR, scopeGPR, executable);</span>
<span class="udiff-line-modified-added">+             callOperation(operationNewAsyncGeneratorFunction, resultGPR, &amp;vm(), scopeGPR, executable);</span>
          else
<span class="udiff-line-modified-removed">-             callOperation(operationNewFunction, resultGPR, scopeGPR, executable);</span>
<span class="udiff-line-modified-added">+             callOperation(operationNewFunction, resultGPR, &amp;vm(), scopeGPR, executable);</span>
          m_jit.exceptionCheck();
          cellResult(resultGPR, node);
          return;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7296,29 +7338,29 @@</span>
      JITCompiler::JumpList slowPath;
  
      if (nodeType == NewFunction) {
          compileNewFunctionCommon&lt;JSFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSFunction::allocationSize(0), executable);
  
<span class="udiff-line-modified-removed">-         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewFunctionWithInvalidatedReallocationWatchpoint, resultGPR, scopeGPR, executable));</span>
<span class="udiff-line-modified-added">+         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewFunctionWithInvalidatedReallocationWatchpoint, resultGPR, &amp;vm(), scopeGPR, executable));</span>
      }
  
      if (nodeType == NewGeneratorFunction) {
          compileNewFunctionCommon&lt;JSGeneratorFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSGeneratorFunction::allocationSize(0), executable);
  
<span class="udiff-line-modified-removed">-         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewGeneratorFunctionWithInvalidatedReallocationWatchpoint, resultGPR, scopeGPR, executable));</span>
<span class="udiff-line-modified-added">+         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewGeneratorFunctionWithInvalidatedReallocationWatchpoint, resultGPR, &amp;vm(), scopeGPR, executable));</span>
      }
  
      if (nodeType == NewAsyncFunction) {
          compileNewFunctionCommon&lt;JSAsyncFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSAsyncFunction::allocationSize(0), executable);
  
<span class="udiff-line-modified-removed">-         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewAsyncFunctionWithInvalidatedReallocationWatchpoint, resultGPR, scopeGPR, executable));</span>
<span class="udiff-line-modified-added">+         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewAsyncFunctionWithInvalidatedReallocationWatchpoint, resultGPR, &amp;vm(), scopeGPR, executable));</span>
      }
  
      if (nodeType == NewAsyncGeneratorFunction) {
          compileNewFunctionCommon&lt;JSAsyncGeneratorFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSAsyncGeneratorFunction::allocationSize(0), executable);
  
<span class="udiff-line-modified-removed">-         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewAsyncGeneratorFunctionWithInvalidatedReallocationWatchpoint, resultGPR, scopeGPR, executable));</span>
<span class="udiff-line-modified-added">+         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewAsyncGeneratorFunctionWithInvalidatedReallocationWatchpoint, resultGPR, &amp;vm(), scopeGPR, executable));</span>
      }
  
      cellResult(resultGPR, node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7328,84 +7370,87 @@</span>
      GPRReg funcGPR = func.gpr();
      JSValueOperand nameValue(this, node-&gt;child2());
      JSValueRegs nameValueRegs = nameValue.jsValueRegs();
  
      flushRegisters();
<span class="udiff-line-modified-removed">-     callOperation(operationSetFunctionName, funcGPR, nameValueRegs);</span>
<span class="udiff-line-modified-added">+     callOperation(operationSetFunctionName, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), funcGPR, nameValueRegs);</span>
      m_jit.exceptionCheck();
  
      noResult(node);
  }
  
<span class="udiff-line-modified-removed">- void SpeculativeJIT::compileLoadVarargs(Node* node)</span>
<span class="udiff-line-modified-added">+ void SpeculativeJIT::compileVarargsLength(Node* node)</span>
  {
      LoadVarargsData* data = node-&gt;loadVarargsData();
  
      JSValueRegs argumentsRegs;
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-         JSValueOperand arguments(this, node-&gt;child1());</span>
<span class="udiff-line-modified-removed">-         argumentsRegs = arguments.jsValueRegs();</span>
<span class="udiff-line-modified-removed">-         flushRegisters();</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     lock(GPRInfo::returnValueGPR);</span>
<span class="udiff-line-modified-added">+     JSValueOperand arguments(this, node-&gt;argumentsChild());</span>
<span class="udiff-line-modified-added">+     argumentsRegs = arguments.jsValueRegs();</span>
<span class="udiff-line-modified-added">+     flushRegisters();</span>
<span class="udiff-line-modified-added">+     unlock(GPRInfo::returnValueGPR);</span>
  
<span class="udiff-line-modified-removed">-     callOperation(operationSizeOfVarargs, GPRInfo::returnValueGPR, argumentsRegs, data-&gt;offset);</span>
<span class="udiff-line-modified-added">+     callOperation(operationSizeOfVarargs, GPRInfo::returnValueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentsRegs, data-&gt;offset);</span>
      m_jit.exceptionCheck();
  
      lock(GPRInfo::returnValueGPR);
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-         JSValueOperand arguments(this, node-&gt;child1());</span>
<span class="udiff-line-removed">-         argumentsRegs = arguments.jsValueRegs();</span>
<span class="udiff-line-removed">-         flushRegisters();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     GPRTemporary argCountIncludingThis(this);</span>
<span class="udiff-line-modified-added">+     GPRReg argCountIncludingThisGPR = argCountIncludingThis.gpr();</span>
      unlock(GPRInfo::returnValueGPR);
  
<span class="udiff-line-modified-removed">-     // FIXME: There is a chance that we will call an effectful length property twice. This is safe</span>
<span class="udiff-line-modified-removed">-     // from the standpoint of the VM&#39;s integrity, but it&#39;s subtly wrong from a spec compliance</span>
<span class="udiff-line-modified-removed">-     // standpoint. The best solution would be one where we can exit *into* the op_call_varargs right</span>
<span class="udiff-line-modified-removed">-     // past the sizing.</span>
<span class="udiff-line-removed">-     // https://bugs.webkit.org/show_bug.cgi?id=141448</span>
<span class="udiff-line-modified-added">+     m_jit.add32(TrustedImm32(1), GPRInfo::returnValueGPR, argCountIncludingThisGPR);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     int32Result(argCountIncludingThisGPR, node);</span>
<span class="udiff-line-modified-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     GPRReg argCountIncludingThisGPR =</span>
<span class="udiff-line-modified-removed">-         JITCompiler::selectScratchGPR(GPRInfo::returnValueGPR, argumentsRegs);</span>
<span class="udiff-line-modified-added">+ void SpeculativeJIT::compileLoadVarargs(Node* node)</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-added">+     LoadVarargsData* data = node-&gt;loadVarargsData();</span>
  
<span class="udiff-line-modified-removed">-     m_jit.add32(TrustedImm32(1), GPRInfo::returnValueGPR, argCountIncludingThisGPR);</span>
<span class="udiff-line-modified-added">+     SpeculateStrictInt32Operand argumentCount(this, node-&gt;child1());</span>
<span class="udiff-line-added">+     JSValueOperand arguments(this, node-&gt;argumentsChild());</span>
<span class="udiff-line-added">+     GPRReg argumentCountIncludingThis = argumentCount.gpr();</span>
<span class="udiff-line-added">+     JSValueRegs argumentsRegs = arguments.jsValueRegs();</span>
  
      speculationCheck(
<span class="udiff-line-modified-removed">-         VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(</span>
<span class="udiff-line-modified-removed">-             MacroAssembler::Above,</span>
<span class="udiff-line-modified-removed">-             GPRInfo::returnValueGPR,</span>
<span class="udiff-line-removed">-             argCountIncludingThisGPR));</span>
<span class="udiff-line-modified-added">+         VarargsOverflow, JSValueSource(), Edge(), m_jit.branchTest32(</span>
<span class="udiff-line-modified-added">+             MacroAssembler::Zero,</span>
<span class="udiff-line-modified-added">+             argumentCountIncludingThis));</span>
  
      speculationCheck(
          VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(
              MacroAssembler::Above,
<span class="udiff-line-modified-removed">-             argCountIncludingThisGPR,</span>
<span class="udiff-line-modified-added">+             argumentCountIncludingThis,</span>
              TrustedImm32(data-&gt;limit)));
  
<span class="udiff-line-modified-removed">-     m_jit.store32(argCountIncludingThisGPR, JITCompiler::payloadFor(data-&gt;machineCount));</span>
<span class="udiff-line-modified-added">+     flushRegisters();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     m_jit.store32(argumentCountIncludingThis, JITCompiler::payloadFor(data-&gt;machineCount));</span>
  
<span class="udiff-line-modified-removed">-     callOperation(operationLoadVarargs, data-&gt;machineStart.offset(), argumentsRegs, data-&gt;offset, GPRInfo::returnValueGPR, data-&gt;mandatoryMinimum);</span>
<span class="udiff-line-modified-added">+     callOperation(operationLoadVarargs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), data-&gt;machineStart.offset(), argumentsRegs, data-&gt;offset, argumentCountIncludingThis, data-&gt;mandatoryMinimum);</span>
      m_jit.exceptionCheck();
  
      noResult(node);
  }
  
  void SpeculativeJIT::compileForwardVarargs(Node* node)
  {
      LoadVarargsData* data = node-&gt;loadVarargsData();
      InlineCallFrame* inlineCallFrame;
<span class="udiff-line-modified-removed">-     if (node-&gt;child1())</span>
<span class="udiff-line-modified-removed">-         inlineCallFrame = node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();</span>
<span class="udiff-line-modified-added">+     if (node-&gt;argumentsChild())</span>
<span class="udiff-line-modified-added">+         inlineCallFrame = node-&gt;argumentsChild()-&gt;origin.semantic.inlineCallFrame();</span>
      else
          inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
  
<span class="udiff-line-added">+     SpeculateStrictInt32Operand argumentCount(this, node-&gt;child1());</span>
      GPRTemporary length(this);
      JSValueRegsTemporary temp(this);
<span class="udiff-line-modified-removed">-     GPRReg lengthGPR = length.gpr();</span>
<span class="udiff-line-modified-added">+     GPRReg argumentCountIncludingThis = argumentCount.gpr();</span>
<span class="udiff-line-added">+     GPRReg lengthGPR = argumentCount.gpr();</span>
      JSValueRegs tempRegs = temp.regs();
  
<span class="udiff-line-modified-removed">-     emitGetLength(inlineCallFrame, lengthGPR, /* includeThis = */ true);</span>
<span class="udiff-line-modified-added">+     m_jit.move(argumentCountIncludingThis, lengthGPR);</span>
      if (data-&gt;offset)
          m_jit.sub32(TrustedImm32(data-&gt;offset), lengthGPR);
  
      speculationCheck(
          VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7478,14 +7523,14 @@</span>
  
          flushRegisters();
  
  #if USE(JSVALUE64)
          callOperation(operationCreateActivationDirect,
<span class="udiff-line-modified-removed">-             resultGPR, structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue)));</span>
<span class="udiff-line-modified-added">+             resultGPR, &amp;vm(), structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue)));</span>
  #else
          callOperation(operationCreateActivationDirect,
<span class="udiff-line-modified-removed">-             resultGPR, structure, scopeGPR, table, initializationRegs);</span>
<span class="udiff-line-modified-added">+             resultGPR, &amp;vm(), structure, scopeGPR, table, initializationRegs);</span>
  #endif
          m_jit.exceptionCheck();
          cellResult(resultGPR, node);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7527,15 +7572,15 @@</span>
      m_jit.mutatorFence(vm());
  
  #if USE(JSVALUE64)
      addSlowPathGenerator(
          slowPathCall(
<span class="udiff-line-modified-removed">-             slowPath, this, operationCreateActivationDirect, resultGPR, structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue))));</span>
<span class="udiff-line-modified-added">+             slowPath, this, operationCreateActivationDirect, resultGPR, &amp;vm(), structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue))));</span>
  #else
      addSlowPathGenerator(
          slowPathCall(
<span class="udiff-line-modified-removed">-             slowPath, this, operationCreateActivationDirect, resultGPR, structure, scopeGPR, table, initializationRegs));</span>
<span class="udiff-line-modified-added">+             slowPath, this, operationCreateActivationDirect, resultGPR, &amp;vm(), structure, scopeGPR, table, initializationRegs));</span>
  #endif
  
      cellResult(resultGPR, node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7560,11 +7605,11 @@</span>
      unsigned knownLength;
      bool lengthIsKnown; // if false, lengthGPR will have the length.
      auto* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
      if (inlineCallFrame
          &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
<span class="udiff-line-modified-removed">-         knownLength = inlineCallFrame-&gt;argumentCountIncludingThis - 1;</span>
<span class="udiff-line-modified-added">+         knownLength = static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1);</span>
          lengthIsKnown = true;
      } else {
          knownLength = UINT_MAX;
          lengthIsKnown = false;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7626,11 +7671,11 @@</span>
          TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, DirectArguments::offsetOfModifiedArgumentsDescriptor()));
  
      if (lengthIsKnown) {
          addSlowPathGenerator(
              slowPathCall(
<span class="udiff-line-modified-removed">-                 slowPath, this, operationCreateDirectArguments, resultGPR, structure,</span>
<span class="udiff-line-modified-added">+                 slowPath, this, operationCreateDirectArguments, resultGPR, &amp;vm(), structure,</span>
                  knownLength, minCapacity));
      } else {
          auto generator = makeUnique&lt;CallCreateDirectArgumentsSlowPathGenerator&gt;(
              slowPath, this, resultGPR, structure, lengthGPR, minCapacity);
          addSlowPathGenerator(WTFMove(generator));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7743,15 +7788,17 @@</span>
  
      GPRFlushedCallResult result(this);
      GPRReg resultGPR = result.gpr();
      flushRegisters();
  
<span class="udiff-line-added">+     JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="udiff-line-added">+ </span>
      // We set up the arguments ourselves, because we have the whole register file and we can
      // set them up directly into the argument registers. This also means that we don&#39;t have to
      // invent a four-argument-register shuffle.
  
<span class="udiff-line-modified-removed">-     // Arguments: 0:exec, 1:structure, 2:start, 3:length, 4:callee, 5:scope</span>
<span class="udiff-line-modified-added">+     // Arguments: 0:JSGlobalObject*, 1:structure, 2:start, 3:length, 4:callee, 5:scope</span>
  
      // Do the scopeGPR first, since it might alias an argument register.
      m_jit.setupArgument(5, [&amp;] (GPRReg destGPR) { m_jit.move(scopeGPR, destGPR); });
  
      // These other things could be done in any order.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7759,14 +7806,14 @@</span>
      m_jit.setupArgument(3, [&amp;] (GPRReg destGPR) { emitGetLength(node-&gt;origin.semantic, destGPR); });
      m_jit.setupArgument(2, [&amp;] (GPRReg destGPR) { emitGetArgumentStart(node-&gt;origin.semantic, destGPR); });
      m_jit.setupArgument(
          1, [&amp;] (GPRReg destGPR) {
              m_jit.move(
<span class="udiff-line-modified-removed">-                 TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.globalObjectFor(node-&gt;origin.semantic)-&gt;scopedArgumentsStructure()),</span>
<span class="udiff-line-modified-added">+                 TrustedImmPtr::weakPointer(m_jit.graph(), globalObject-&gt;scopedArgumentsStructure()),</span>
                  destGPR);
          });
<span class="udiff-line-modified-removed">-     m_jit.setupArgument(0, [&amp;] (GPRReg destGPR) { m_jit.move(GPRInfo::callFrameRegister, destGPR); });</span>
<span class="udiff-line-modified-added">+     m_jit.setupArgument(0, [&amp;] (GPRReg destGPR) { m_jit.move(TrustedImmPtr::weakPointer(m_graph, globalObject), destGPR); });</span>
  
      appendCallSetResult(operationCreateScopedArguments, resultGPR);
      m_jit.exceptionCheck();
  
      cellResult(resultGPR, node);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7776,37 +7823,60 @@</span>
  {
      GPRFlushedCallResult result(this);
      GPRReg resultGPR = result.gpr();
      flushRegisters();
  
<span class="udiff-line-added">+     JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="udiff-line-added">+ </span>
      // We set up the arguments ourselves, because we have the whole register file and we can
      // set them up directly into the argument registers.
  
<span class="udiff-line-modified-removed">-     // Arguments: 0:exec, 1:structure, 2:start, 3:length, 4:callee</span>
<span class="udiff-line-modified-added">+     // Arguments: 0:JSGlobalObject*, 1:structure, 2:start, 3:length, 4:callee</span>
      m_jit.setupArgument(4, [&amp;] (GPRReg destGPR) { emitGetCallee(node-&gt;origin.semantic, destGPR); });
      m_jit.setupArgument(3, [&amp;] (GPRReg destGPR) { emitGetLength(node-&gt;origin.semantic, destGPR); });
      m_jit.setupArgument(2, [&amp;] (GPRReg destGPR) { emitGetArgumentStart(node-&gt;origin.semantic, destGPR); });
      m_jit.setupArgument(
          1, [&amp;] (GPRReg destGPR) {
              m_jit.move(
                  TrustedImmPtr::weakPointer(
<span class="udiff-line-modified-removed">-                     m_jit.graph(), m_jit.globalObjectFor(node-&gt;origin.semantic)-&gt;clonedArgumentsStructure()),</span>
<span class="udiff-line-modified-added">+                     m_jit.graph(), globalObject-&gt;clonedArgumentsStructure()),</span>
                  destGPR);
          });
<span class="udiff-line-modified-removed">-     m_jit.setupArgument(0, [&amp;] (GPRReg destGPR) { m_jit.move(GPRInfo::callFrameRegister, destGPR); });</span>
<span class="udiff-line-modified-added">+     m_jit.setupArgument(0, [&amp;] (GPRReg destGPR) { m_jit.move(TrustedImmPtr::weakPointer(m_graph, globalObject), destGPR); });</span>
  
      appendCallSetResult(operationCreateClonedArguments, resultGPR);
      m_jit.exceptionCheck();
  
      cellResult(resultGPR, node);
  }
  
<span class="udiff-line-added">+ void SpeculativeJIT::compileCreateArgumentsButterfly(Node* node)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     GPRFlushedCallResult result(this);</span>
<span class="udiff-line-added">+     GPRReg resultGPR = result.gpr();</span>
<span class="udiff-line-added">+     flushRegisters();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // We set up the arguments ourselves, because we have the whole register file and we can</span>
<span class="udiff-line-added">+     // set them up directly into the argument registers.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Arguments: 0:JSGlobalObject*, 1:start, 3:length</span>
<span class="udiff-line-added">+     m_jit.setupArgument(2, [&amp;] (GPRReg destGPR) { emitGetLength(node-&gt;origin.semantic, destGPR); });</span>
<span class="udiff-line-added">+     m_jit.setupArgument(1, [&amp;] (GPRReg destGPR) { emitGetArgumentStart(node-&gt;origin.semantic, destGPR); });</span>
<span class="udiff-line-added">+     m_jit.setupArgument(0, [&amp;] (GPRReg destGPR) { m_jit.move(TrustedImmPtr::weakPointer(m_graph, globalObject), destGPR); });</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     appendCallSetResult(operationCreateArgumentsButterfly, resultGPR);</span>
<span class="udiff-line-added">+     m_jit.exceptionCheck();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     cellResult(resultGPR, node);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void SpeculativeJIT::compileCreateRest(Node* node)
  {
      ASSERT(node-&gt;op() == CreateRest);
  
<span class="udiff-line-removed">- #if !CPU(X86)</span>
      if (m_jit.graph().isWatchingHavingABadTimeWatchpoint(node)) {
          SpeculateStrictInt32Operand arrayLength(this, node-&gt;child1());
          GPRTemporary arrayResult(this);
  
          GPRReg arrayLengthGPR = arrayLength.gpr();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7815,11 +7885,10 @@</span>
          // We can tell compileAllocateNewArrayWithSize() that it does not need to check
          // for large arrays and use ArrayStorage structure because arrayLength here will
          // always be bounded by stack size. Realistically, we won&#39;t be able to push enough
          // arguments to have arrayLength exceed MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH.
          bool shouldAllowForArrayStorageStructureForLargeArrays = false;
<span class="udiff-line-removed">-         ASSERT(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;restParameterStructure()-&gt;indexingMode() == ArrayWithContiguous || m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;isHavingABadTime());</span>
          compileAllocateNewArrayWithSize(m_jit.graph().globalObjectFor(node-&gt;origin.semantic), arrayResultGPR, arrayLengthGPR, ArrayWithContiguous, shouldAllowForArrayStorageStructureForLargeArrays);
  
          GPRTemporary argumentsStart(this);
          GPRReg argumentsStartGPR = argumentsStart.gpr();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7847,11 +7916,10 @@</span>
  
          skipLoop.link(&amp;m_jit);
          cellResult(arrayResultGPR, node);
          return;
      }
<span class="udiff-line-removed">- #endif // !CPU(X86)</span>
  
      SpeculateStrictInt32Operand arrayLength(this, node-&gt;child1());
      GPRTemporary argumentsStart(this);
      GPRTemporary numberOfArgumentsToSkip(this);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7862,11 +7930,11 @@</span>
  
      flushRegisters();
  
      GPRFlushedCallResult result(this);
      GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-     callOperation(operationCreateRest, resultGPR, argumentsStartGPR, Imm32(node-&gt;numberOfArgumentsToSkip()), arrayLengthGPR);</span>
<span class="udiff-line-modified-added">+     callOperation(operationCreateRest, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentsStartGPR, Imm32(node-&gt;numberOfArgumentsToSkip()), arrayLengthGPR);</span>
      m_jit.exceptionCheck();
  
      cellResult(resultGPR, node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7893,31 +7961,39 @@</span>
          GPRReg scratch2GPR = scratch2.gpr();
          GPRReg lengthGPR = length.gpr();
          FPRReg doubleFPR = doubleRegister.fpr();
  
          MacroAssembler::JumpList slowPath;
<span class="udiff-line-added">+         MacroAssembler::JumpList done;</span>
  
          m_jit.load8(MacroAssembler::Address(argument, JSCell::indexingTypeAndMiscOffset()), scratch1GPR);
<span class="udiff-line-added">+         m_jit.and32(TrustedImm32(IndexingModeMask), scratch1GPR);</span>
<span class="udiff-line-added">+         auto notShareCase = m_jit.branch32(CCallHelpers::NotEqual, scratch1GPR, TrustedImm32(CopyOnWriteArrayWithContiguous));</span>
<span class="udiff-line-added">+         m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), resultGPR);</span>
<span class="udiff-line-added">+         m_jit.addPtr(TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(JSImmutableButterfly::offsetOfData())), resultGPR);</span>
<span class="udiff-line-added">+         done.append(m_jit.jump());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         notShareCase.link(&amp;m_jit);</span>
          m_jit.and32(TrustedImm32(IndexingShapeMask), scratch1GPR);
          m_jit.sub32(TrustedImm32(Int32Shape), scratch1GPR);
  
          slowPath.append(m_jit.branch32(MacroAssembler::Above, scratch1GPR, TrustedImm32(ContiguousShape - Int32Shape)));
  
          m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), lengthGPR);
          m_jit.load32(MacroAssembler::Address(lengthGPR, Butterfly::offsetOfPublicLength()), lengthGPR);
<span class="udiff-line-added">+         slowPath.append(m_jit.branch32(MacroAssembler::Above, lengthGPR, TrustedImm32(MAX_STORAGE_VECTOR_LENGTH)));</span>
          static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;This is strongly assumed in the code below.&quot;);
          m_jit.move(lengthGPR, scratch1GPR);
          m_jit.lshift32(TrustedImm32(3), scratch1GPR);
<span class="udiff-line-modified-removed">-         m_jit.add32(TrustedImm32(JSFixedArray::offsetOfData()), scratch1GPR);</span>
<span class="udiff-line-modified-added">+         m_jit.add32(TrustedImm32(JSImmutableButterfly::offsetOfData()), scratch1GPR);</span>
  
<span class="udiff-line-modified-removed">-         m_jit.emitAllocateVariableSizedCell&lt;JSFixedArray&gt;(vm(), resultGPR, TrustedImmPtr(m_jit.graph().registerStructure(m_jit.graph().m_vm.fixedArrayStructure.get())), scratch1GPR, scratch1GPR, scratch2GPR, slowPath);</span>
<span class="udiff-line-modified-removed">-         m_jit.store32(lengthGPR, MacroAssembler::Address(resultGPR, JSFixedArray::offsetOfSize()));</span>
<span class="udiff-line-modified-added">+         m_jit.emitAllocateVariableSizedCell&lt;JSImmutableButterfly&gt;(vm(), resultGPR, TrustedImmPtr(m_jit.graph().registerStructure(m_jit.graph().m_vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get())), scratch1GPR, scratch1GPR, scratch2GPR, slowPath);</span>
<span class="udiff-line-modified-added">+         m_jit.store32(lengthGPR, MacroAssembler::Address(resultGPR, JSImmutableButterfly::offsetOfPublicLength()));</span>
<span class="udiff-line-added">+         m_jit.store32(lengthGPR, MacroAssembler::Address(resultGPR, JSImmutableButterfly::offsetOfVectorLength()));</span>
  
          m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), scratch1GPR);
  
<span class="udiff-line-removed">-         MacroAssembler::JumpList done;</span>
<span class="udiff-line-removed">- </span>
          m_jit.load8(MacroAssembler::Address(argument, JSCell::indexingTypeAndMiscOffset()), scratch2GPR);
          m_jit.and32(TrustedImm32(IndexingShapeMask), scratch2GPR);
          auto isDoubleArray = m_jit.branch32(MacroAssembler::Equal, scratch2GPR, TrustedImm32(DoubleShape));
  
          {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7926,11 +8002,11 @@</span>
              m_jit.sub32(TrustedImm32(1), lengthGPR);
              m_jit.load64(MacroAssembler::BaseIndex(scratch1GPR, lengthGPR, MacroAssembler::TimesEight), scratch2GPR);
              auto notEmpty = m_jit.branchIfNotEmpty(scratch2GPR);
              m_jit.move(TrustedImm64(JSValue::encode(jsUndefined())), scratch2GPR);
              notEmpty.link(&amp;m_jit);
<span class="udiff-line-modified-removed">-             m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSFixedArray::offsetOfData()));</span>
<span class="udiff-line-modified-added">+             m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSImmutableButterfly::offsetOfData()));</span>
              m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loopStart, &amp;m_jit);
              done.append(m_jit.jump());
          }
  
          isDoubleArray.link(&amp;m_jit);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7943,54 +8019,45 @@</span>
              m_jit.move(TrustedImm64(JSValue::encode(jsUndefined())), scratch2GPR);
              auto doStore = m_jit.jump();
              notEmpty.link(&amp;m_jit);
              m_jit.boxDouble(doubleFPR, scratch2GPR);
              doStore.link(&amp;m_jit);
<span class="udiff-line-modified-removed">-             m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSFixedArray::offsetOfData()));</span>
<span class="udiff-line-modified-added">+             m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSImmutableButterfly::offsetOfData()));</span>
              m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loopStart, &amp;m_jit);
              done.append(m_jit.jump());
          }
  
<span class="udiff-line-modified-removed">-         m_jit.mutatorFence(vm());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         slowPath.link(&amp;m_jit);</span>
<span class="udiff-line-removed">-         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationSpreadFastArray, resultGPR, argument));</span>
<span class="udiff-line-modified-added">+         addSlowPathGenerator(slowPathCall(slowPath, this, operationSpreadFastArray, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argument));</span>
  
          done.link(&amp;m_jit);
<span class="udiff-line-added">+         m_jit.mutatorFence(vm());</span>
          cellResult(resultGPR, node);
  #else
          flushRegisters();
  
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-         callOperation(operationSpreadFastArray, resultGPR, argument);</span>
<span class="udiff-line-modified-added">+         callOperation(operationSpreadFastArray, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argument);</span>
          m_jit.exceptionCheck();
          cellResult(resultGPR, node);
  #endif // USE(JSVALUE64)
      } else {
          flushRegisters();
  
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-         callOperation(operationSpreadGeneric, resultGPR, argument);</span>
<span class="udiff-line-modified-added">+         callOperation(operationSpreadGeneric, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argument);</span>
          m_jit.exceptionCheck();
          cellResult(resultGPR, node);
      }
  }
  
  void SpeculativeJIT::compileNewArray(Node* node)
  {
      JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
<span class="udiff-line-added">+     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType()));</span>
      if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(node-&gt;indexingType())) {
<span class="udiff-line-removed">-         RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType()));</span>
<span class="udiff-line-removed">-         DFG_ASSERT(m_jit.graph(), node, structure-&gt;indexingType() == node-&gt;indexingType(), structure-&gt;indexingType(), node-&gt;indexingType());</span>
<span class="udiff-line-removed">-         ASSERT(</span>
<span class="udiff-line-removed">-             hasUndecided(structure-&gt;indexingType())</span>
<span class="udiff-line-removed">-             || hasInt32(structure-&gt;indexingType())</span>
<span class="udiff-line-removed">-             || hasDouble(structure-&gt;indexingType())</span>
<span class="udiff-line-removed">-             || hasContiguous(structure-&gt;indexingType()));</span>
<span class="udiff-line-removed">- </span>
          unsigned numElements = node-&gt;numChildren();
          unsigned vectorLengthHint = node-&gt;vectorLengthHint();
          ASSERT(vectorLengthHint &gt;= numElements);
  
          GPRTemporary result(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8052,11 +8119,11 @@</span>
      }
  
      if (!node-&gt;numChildren()) {
          flushRegisters();
          GPRFlushedCallResult result(this);
<span class="udiff-line-modified-removed">-         callOperation(operationNewEmptyArray, result.gpr(), m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType())));</span>
<span class="udiff-line-modified-added">+         callOperation(operationNewEmptyArray, result.gpr(), &amp;vm(), structure);</span>
          m_jit.exceptionCheck();
          cellResult(result.gpr(), node);
          return;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8123,11 +8190,11 @@</span>
      }
  
      GPRFlushedCallResult result(this);
  
      callOperation(
<span class="udiff-line-modified-removed">-         operationNewArray, result.gpr(), m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType())),</span>
<span class="udiff-line-modified-added">+         operationNewArray, result.gpr(), TrustedImmPtr::weakPointer(m_graph, globalObject), m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType())),</span>
          static_cast&lt;void*&gt;(buffer), size_t(node-&gt;numChildren()));
      m_jit.exceptionCheck();
  
      if (scratchSize) {
          GPRTemporary scratch(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8140,17 +8207,48 @@</span>
  }
  
  void SpeculativeJIT::compileNewArrayWithSpread(Node* node)
  {
      ASSERT(node-&gt;op() == NewArrayWithSpread);
<span class="udiff-line-added">+     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);</span>
  
  #if USE(JSVALUE64)
      if (m_jit.graph().isWatchingHavingABadTimeWatchpoint(node)) {
          GPRTemporary result(this);
          GPRReg resultGPR = result.gpr();
  
          BitVector* bitVector = node-&gt;bitVector();
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (node-&gt;numChildren() == 1 &amp;&amp; bitVector-&gt;get(0)) {</span>
<span class="udiff-line-added">+             Edge use = m_jit.graph().varArgChild(node, 0);</span>
<span class="udiff-line-added">+             SpeculateCellOperand immutableButterfly(this, use);</span>
<span class="udiff-line-added">+             GPRTemporary result(this);</span>
<span class="udiff-line-added">+             GPRTemporary butterfly(this);</span>
<span class="udiff-line-added">+             GPRTemporary scratch1(this);</span>
<span class="udiff-line-added">+             GPRTemporary scratch2(this);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             GPRReg immutableButterflyGPR = immutableButterfly.gpr();</span>
<span class="udiff-line-added">+             GPRReg resultGPR = result.gpr();</span>
<span class="udiff-line-added">+             GPRReg butterflyGPR = butterfly.gpr();</span>
<span class="udiff-line-added">+             GPRReg scratch1GPR = scratch1.gpr();</span>
<span class="udiff-line-added">+             GPRReg scratch2GPR = scratch2.gpr();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;originalArrayStructureForIndexingType(CopyOnWriteArrayWithContiguous));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             MacroAssembler::JumpList slowCases;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             m_jit.move(immutableButterflyGPR, butterflyGPR);</span>
<span class="udiff-line-added">+             m_jit.addPtr(TrustedImm32(JSImmutableButterfly::offsetOfData()), butterflyGPR);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(structure), butterflyGPR, scratch1GPR, scratch2GPR, slowCases);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             addSlowPathGenerator(slowPathCall(slowCases, this, operationNewArrayBuffer, resultGPR, &amp;vm(), structure, immutableButterflyGPR));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             cellResult(resultGPR, node);</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          {
              unsigned startLength = 0;
              for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
                  if (!bitVector-&gt;get(i))
                      ++startLength;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8161,25 +8259,24 @@</span>
              m_jit.move(TrustedImm32(startLength), lengthGPR);
  
              for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
                  if (bitVector-&gt;get(i)) {
                      Edge use = m_jit.graph().varArgChild(node, i);
<span class="udiff-line-modified-removed">-                     SpeculateCellOperand fixedArray(this, use);</span>
<span class="udiff-line-modified-removed">-                     GPRReg fixedArrayGPR = fixedArray.gpr();</span>
<span class="udiff-line-modified-removed">-                     speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branchAdd32(MacroAssembler::Overflow, MacroAssembler::Address(fixedArrayGPR, JSFixedArray::offsetOfSize()), lengthGPR));</span>
<span class="udiff-line-modified-added">+                     SpeculateCellOperand immutableButterfly(this, use);</span>
<span class="udiff-line-modified-added">+                     GPRReg immutableButterflyGPR = immutableButterfly.gpr();</span>
<span class="udiff-line-modified-added">+                     speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branchAdd32(MacroAssembler::Overflow, MacroAssembler::Address(immutableButterflyGPR, JSImmutableButterfly::offsetOfPublicLength()), lengthGPR));</span>
                  }
              }
  
              speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branch32(MacroAssembler::AboveOrEqual, lengthGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)));
  
              // We can tell compileAllocateNewArrayWithSize() that it does not need to
              // check for large arrays and use ArrayStorage structure because we already
              // ensured above that the spread array length will definitely fit in a
              // non-ArrayStorage shaped array.
              bool shouldAllowForArrayStorageStructureForLargeArrays = false;
<span class="udiff-line-modified-removed">-             ASSERT(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;restParameterStructure()-&gt;indexingType() == ArrayWithContiguous || m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;isHavingABadTime());</span>
<span class="udiff-line-removed">-             compileAllocateNewArrayWithSize(m_jit.graph().globalObjectFor(node-&gt;origin.semantic), resultGPR, lengthGPR, ArrayWithContiguous, shouldAllowForArrayStorageStructureForLargeArrays);</span>
<span class="udiff-line-modified-added">+             compileAllocateNewArrayWithSize(globalObject, resultGPR, lengthGPR, ArrayWithContiguous, shouldAllowForArrayStorageStructureForLargeArrays);</span>
          }
  
          GPRTemporary index(this);
          GPRReg indexGPR = index.gpr();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8190,34 +8287,34 @@</span>
          m_jit.loadPtr(MacroAssembler::Address(resultGPR, JSObject::butterflyOffset()), storageGPR);
  
          for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
              Edge use = m_jit.graph().varArgChild(node, i);
              if (bitVector-&gt;get(i)) {
<span class="udiff-line-modified-removed">-                 SpeculateCellOperand fixedArray(this, use);</span>
<span class="udiff-line-modified-removed">-                 GPRReg fixedArrayGPR = fixedArray.gpr();</span>
<span class="udiff-line-modified-added">+                 SpeculateCellOperand immutableButterfly(this, use);</span>
<span class="udiff-line-modified-added">+                 GPRReg immutableButterflyGPR = immutableButterfly.gpr();</span>
  
<span class="udiff-line-modified-removed">-                 GPRTemporary fixedIndex(this);</span>
<span class="udiff-line-modified-removed">-                 GPRReg fixedIndexGPR = fixedIndex.gpr();</span>
<span class="udiff-line-modified-added">+                 GPRTemporary immutableButterflyIndex(this);</span>
<span class="udiff-line-modified-added">+                 GPRReg immutableButterflyIndexGPR = immutableButterflyIndex.gpr();</span>
  
                  GPRTemporary item(this);
                  GPRReg itemGPR = item.gpr();
  
<span class="udiff-line-modified-removed">-                 GPRTemporary fixedLength(this);</span>
<span class="udiff-line-modified-removed">-                 GPRReg fixedLengthGPR = fixedLength.gpr();</span>
<span class="udiff-line-modified-added">+                 GPRTemporary immutableButterflyLength(this);</span>
<span class="udiff-line-modified-added">+                 GPRReg immutableButterflyLengthGPR = immutableButterflyLength.gpr();</span>
  
<span class="udiff-line-modified-removed">-                 m_jit.load32(MacroAssembler::Address(fixedArrayGPR, JSFixedArray::offsetOfSize()), fixedLengthGPR);</span>
<span class="udiff-line-modified-removed">-                 m_jit.move(TrustedImm32(0), fixedIndexGPR);</span>
<span class="udiff-line-modified-removed">-                 auto done = m_jit.branchPtr(MacroAssembler::AboveOrEqual, fixedIndexGPR, fixedLengthGPR);</span>
<span class="udiff-line-modified-added">+                 m_jit.load32(MacroAssembler::Address(immutableButterflyGPR, JSImmutableButterfly::offsetOfPublicLength()), immutableButterflyLengthGPR);</span>
<span class="udiff-line-modified-added">+                 m_jit.move(TrustedImm32(0), immutableButterflyIndexGPR);</span>
<span class="udiff-line-modified-added">+                 auto done = m_jit.branchPtr(MacroAssembler::AboveOrEqual, immutableButterflyIndexGPR, immutableButterflyLengthGPR);</span>
                  auto loopStart = m_jit.label();
                  m_jit.load64(
<span class="udiff-line-modified-removed">-                     MacroAssembler::BaseIndex(fixedArrayGPR, fixedIndexGPR, MacroAssembler::TimesEight, JSFixedArray::offsetOfData()),</span>
<span class="udiff-line-modified-added">+                     MacroAssembler::BaseIndex(immutableButterflyGPR, immutableButterflyIndexGPR, MacroAssembler::TimesEight, JSImmutableButterfly::offsetOfData()),</span>
                      itemGPR);
  
                  m_jit.store64(itemGPR, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight));
<span class="udiff-line-modified-removed">-                 m_jit.addPtr(TrustedImm32(1), fixedIndexGPR);</span>
<span class="udiff-line-modified-added">+                 m_jit.addPtr(TrustedImm32(1), immutableButterflyIndexGPR);</span>
                  m_jit.addPtr(TrustedImm32(1), indexGPR);
<span class="udiff-line-modified-removed">-                 m_jit.branchPtr(MacroAssembler::Below, fixedIndexGPR, fixedLengthGPR).linkTo(loopStart, &amp;m_jit);</span>
<span class="udiff-line-modified-added">+                 m_jit.branchPtr(MacroAssembler::Below, immutableButterflyIndexGPR, immutableButterflyLengthGPR).linkTo(loopStart, &amp;m_jit);</span>
  
                  done.link(&amp;m_jit);
              } else {
                  JSValueOperand item(this, use);
                  GPRReg itemGPR = item.gpr();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8238,17 +8335,17 @@</span>
  
      BitVector* bitVector = node-&gt;bitVector();
      for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
          Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + i];
          if (bitVector-&gt;get(i)) {
<span class="udiff-line-modified-removed">-             SpeculateCellOperand fixedArray(this, use);</span>
<span class="udiff-line-modified-removed">-             GPRReg arrayGPR = fixedArray.gpr();</span>
<span class="udiff-line-modified-added">+             SpeculateCellOperand immutableButterfly(this, use);</span>
<span class="udiff-line-modified-added">+             GPRReg immutableButterflyGPR = immutableButterfly.gpr();</span>
  #if USE(JSVALUE64)
<span class="udiff-line-modified-removed">-             m_jit.store64(arrayGPR, &amp;buffer[i]);</span>
<span class="udiff-line-modified-added">+             m_jit.store64(immutableButterflyGPR, &amp;buffer[i]);</span>
  #else
              char* pointer = static_cast&lt;char*&gt;(static_cast&lt;void*&gt;(&amp;buffer[i]));
<span class="udiff-line-modified-removed">-             m_jit.store32(arrayGPR, pointer + PayloadOffset);</span>
<span class="udiff-line-modified-added">+             m_jit.store32(immutableButterflyGPR, pointer + PayloadOffset);</span>
              m_jit.store32(TrustedImm32(JSValue::CellTag), pointer + TagOffset);
  #endif
          } else {
              JSValueOperand input(this, use);
              JSValueRegs inputRegs = input.jsValueRegs();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8265,11 +8362,11 @@</span>
      flushRegisters();
  
      GPRFlushedCallResult result(this);
      GPRReg resultGPR = result.gpr();
  
<span class="udiff-line-modified-removed">-     callOperation(operationNewArrayWithSpreadSlow, resultGPR, buffer, node-&gt;numChildren());</span>
<span class="udiff-line-modified-added">+     callOperation(operationNewArrayWithSpreadSlow, resultGPR, TrustedImmPtr::weakPointer(m_graph, globalObject), buffer, node-&gt;numChildren());</span>
      m_jit.exceptionCheck();
      {
          GPRTemporary scratch(this);
          m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
          m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(scratch.gpr()));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8450,11 +8547,11 @@</span>
          } else {
              slowCases.append(m_jit.jump());
          }
  
          addSlowPathGenerator(makeUnique&lt;CallArrayAllocatorWithVariableStructureVariableSizeSlowPathGenerator&gt;(
<span class="udiff-line-modified-removed">-             slowCases, this, operationNewArrayWithSize, resultGPR, tempValue, sizeGPR, storageResultGPR));</span>
<span class="udiff-line-modified-added">+             slowCases, this, operationNewArrayWithSize, resultGPR, TrustedImmPtr::weakPointer(m_graph, globalObject), tempValue, sizeGPR, storageResultGPR));</span>
      }
  
      GPRTemporary temp4(this);
      GPRReg loadIndex = temp4.gpr();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8669,11 +8766,11 @@</span>
  
          speculateString(searchElementEdge, searchElementGPR);
  
          flushRegisters();
  
<span class="udiff-line-modified-removed">-         callOperation(operationArrayIndexOfString, lengthGPR, storageGPR, searchElementGPR, indexGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationArrayIndexOfString, lengthGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), storageGPR, searchElementGPR, indexGPR);</span>
          m_jit.exceptionCheck();
  
          int32Result(lengthGPR, node);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8684,15 +8781,15 @@</span>
          JSValueRegs searchElementRegs = searchElement.jsValueRegs();
  
          flushRegisters();
          switch (node-&gt;arrayMode().type()) {
          case Array::Double:
<span class="udiff-line-modified-removed">-             callOperation(operationArrayIndexOfValueDouble, lengthGPR, storageGPR, searchElementRegs, indexGPR);</span>
<span class="udiff-line-modified-added">+             callOperation(operationArrayIndexOfValueDouble, lengthGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), storageGPR, searchElementRegs, indexGPR);</span>
              break;
          case Array::Int32:
          case Array::Contiguous:
<span class="udiff-line-modified-removed">-             callOperation(operationArrayIndexOfValueInt32OrContiguous, lengthGPR, storageGPR, searchElementRegs, indexGPR);</span>
<span class="udiff-line-modified-added">+             callOperation(operationArrayIndexOfValueInt32OrContiguous, lengthGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), storageGPR, searchElementRegs, indexGPR);</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8757,11 +8854,11 @@</span>
              m_jit.add32(TrustedImm32(1), storageLengthGPR);
              m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
              m_jit.boxInt32(storageLengthGPR, resultRegs);
  
              addSlowPathGenerator(
<span class="udiff-line-modified-removed">-                 slowPathCall(slowPath, this, operationArrayPush, resultRegs, valueRegs, baseGPR));</span>
<span class="udiff-line-modified-added">+                 slowPathCall(slowPath, this, operationArrayPush, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs, baseGPR));</span>
  
              jsValueResult(resultRegs, node);
              return;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8805,11 +8902,11 @@</span>
              value.use();
          }
  
          MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
  
<span class="udiff-line-modified-removed">-         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationArrayPushMultiple, resultRegs, baseGPR, bufferGPR, TrustedImm32(elementCount)));</span>
<span class="udiff-line-modified-added">+         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationArrayPushMultiple, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, bufferGPR, TrustedImm32(elementCount)));</span>
  
          m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
          m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
  
          base.use();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8833,11 +8930,11 @@</span>
              m_jit.add32(TrustedImm32(1), storageLengthGPR);
              m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
              m_jit.boxInt32(storageLengthGPR, resultRegs);
  
              addSlowPathGenerator(
<span class="udiff-line-modified-removed">-                 slowPathCall(slowPath, this, operationArrayPushDouble, resultRegs, valueFPR, baseGPR));</span>
<span class="udiff-line-modified-added">+                 slowPathCall(slowPath, this, operationArrayPushDouble, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueFPR, baseGPR));</span>
  
              jsValueResult(resultRegs, node);
              return;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8879,11 +8976,11 @@</span>
              value.use();
          }
  
          MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
  
<span class="udiff-line-modified-removed">-         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationArrayPushDoubleMultiple, resultRegs, baseGPR, bufferGPR, TrustedImm32(elementCount)));</span>
<span class="udiff-line-modified-added">+         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationArrayPushDoubleMultiple, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, bufferGPR, TrustedImm32(elementCount)));</span>
  
          m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
          m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
  
          base.use();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8915,11 +9012,11 @@</span>
              m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
              m_jit.add32(TrustedImm32(1), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
              m_jit.boxInt32(storageLengthGPR, resultRegs);
  
              addSlowPathGenerator(
<span class="udiff-line-modified-removed">-                 slowPathCall(slowPath, this, operationArrayPush, resultRegs, valueRegs, baseGPR));</span>
<span class="udiff-line-modified-added">+                 slowPathCall(slowPath, this, operationArrayPush, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs, baseGPR));</span>
  
              jsValueResult(resultRegs, node);
              return;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8961,11 +9058,11 @@</span>
          }
  
          MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
  
          addSlowPathGenerator(
<span class="udiff-line-modified-removed">-             slowPathCall(m_jit.jump(), this, operationArrayPushMultiple, resultRegs, baseGPR, bufferGPR, TrustedImm32(elementCount)));</span>
<span class="udiff-line-modified-added">+             slowPathCall(m_jit.jump(), this, operationArrayPushMultiple, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, bufferGPR, TrustedImm32(elementCount)));</span>
  
          m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
          m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
  
          base.use();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8989,11 +9086,11 @@</span>
          JITCompiler::NotEqual,
          JITCompiler::AbsoluteAddress(set-&gt;addressOfState()),
          TrustedImm32(IsInvalidated));
  
      addSlowPathGenerator(
<span class="udiff-line-modified-removed">-         slowPathCall(slowCase, this, operationNotifyWrite, NeedToSpill, ExceptionCheckRequirement::CheckNotNeeded, NoResult, set));</span>
<span class="udiff-line-modified-added">+         slowPathCall(slowCase, this, operationNotifyWrite, NeedToSpill, ExceptionCheckRequirement::CheckNotNeeded, NoResult, &amp;vm(), set));</span>
  
      noResult(node);
  }
  
  void SpeculativeJIT::compileIsObject(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9236,11 +9333,11 @@</span>
          GPRReg baseGPR = base.gpr();
  
          flushRegisters();
  
          GPRFlushedCallResult result(this);
<span class="udiff-line-modified-removed">-         callOperation(operationAllocateComplexPropertyStorageWithInitialCapacity, result.gpr(), baseGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationAllocateComplexPropertyStorageWithInitialCapacity, result.gpr(), &amp;vm(), baseGPR);</span>
          m_jit.exceptionCheck();
  
          storageResult(result.gpr(), node);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9256,11 +9353,11 @@</span>
      JITCompiler::JumpList slowPath;
      m_jit.emitAllocate(scratchGPR1, JITAllocator::constant(allocator), scratchGPR2, scratchGPR3, slowPath);
      m_jit.addPtr(JITCompiler::TrustedImm32(size + sizeof(IndexingHeader)), scratchGPR1);
  
      addSlowPathGenerator(
<span class="udiff-line-modified-removed">-         slowPathCall(slowPath, this, operationAllocateSimplePropertyStorageWithInitialCapacity, scratchGPR1));</span>
<span class="udiff-line-modified-added">+         slowPathCall(slowPath, this, operationAllocateSimplePropertyStorageWithInitialCapacity, scratchGPR1, &amp;vm()));</span>
  
      for (ptrdiff_t offset = 0; offset &lt; static_cast&lt;ptrdiff_t&gt;(size); offset += sizeof(void*))
          m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
  
      storageResult(scratchGPR1, node);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9280,11 +9377,11 @@</span>
          GPRReg baseGPR = base.gpr();
  
          flushRegisters();
  
          GPRFlushedCallResult result(this);
<span class="udiff-line-modified-removed">-         callOperation(operationAllocateComplexPropertyStorage, result.gpr(), baseGPR, newSize / sizeof(JSValue));</span>
<span class="udiff-line-modified-added">+         callOperation(operationAllocateComplexPropertyStorage, result.gpr(), &amp;vm(), baseGPR, newSize / sizeof(JSValue));</span>
          m_jit.exceptionCheck();
  
          storageResult(result.gpr(), node);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9303,11 +9400,11 @@</span>
      m_jit.emitAllocate(scratchGPR1, JITAllocator::constant(allocator), scratchGPR2, scratchGPR3, slowPath);
  
      m_jit.addPtr(JITCompiler::TrustedImm32(newSize + sizeof(IndexingHeader)), scratchGPR1);
  
      addSlowPathGenerator(
<span class="udiff-line-modified-removed">-         slowPathCall(slowPath, this, operationAllocateSimplePropertyStorage, scratchGPR1, newSize / sizeof(JSValue)));</span>
<span class="udiff-line-modified-added">+         slowPathCall(slowPath, this, operationAllocateSimplePropertyStorage, scratchGPR1, &amp;vm(), newSize / sizeof(JSValue)));</span>
  
      for (ptrdiff_t offset = oldSize; offset &lt; static_cast&lt;ptrdiff_t&gt;(newSize); offset += sizeof(void*))
          m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
  
      // We have scratchGPR1 = new storage, scratchGPR2 = scratch
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9421,21 +9518,23 @@</span>
      JSValueRegsTemporary result(this);
      JSValueRegs resultRegs = result.regs();
  
      flushRegisters();
  
<span class="udiff-line-added">+     // FIXME: Revisit JSGlobalObject.</span>
<span class="udiff-line-added">+     // https://bugs.webkit.org/show_bug.cgi?id=203204</span>
      auto function = CFunctionPtr(signature-&gt;functionWithoutTypeCheck);
      unsigned argumentCountIncludingThis = signature-&gt;argumentCount + 1;
      switch (argumentCountIncludingThis) {
      case 1:
<span class="udiff-line-modified-removed">-         callOperation(reinterpret_cast&lt;J_JITOperation_EP&gt;(function.get()), extractResult(resultRegs), regs[0]);</span>
<span class="udiff-line-modified-added">+         callOperation(reinterpret_cast&lt;J_JITOperation_GP&gt;(function.get()), extractResult(resultRegs), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), regs[0]);</span>
          break;
      case 2:
<span class="udiff-line-modified-removed">-         callOperation(reinterpret_cast&lt;J_JITOperation_EPP&gt;(function.get()), extractResult(resultRegs), regs[0], regs[1]);</span>
<span class="udiff-line-modified-added">+         callOperation(reinterpret_cast&lt;J_JITOperation_GPP&gt;(function.get()), extractResult(resultRegs), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), regs[0], regs[1]);</span>
          break;
      case 3:
<span class="udiff-line-modified-removed">-         callOperation(reinterpret_cast&lt;J_JITOperation_EPPP&gt;(function.get()), extractResult(resultRegs), regs[0], regs[1], regs[2]);</span>
<span class="udiff-line-modified-added">+         callOperation(reinterpret_cast&lt;J_JITOperation_GPPP&gt;(function.get()), extractResult(resultRegs), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), regs[0], regs[1], regs[2]);</span>
          break;
      default:
          RELEASE_ASSERT_NOT_REACHED();
          break;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9454,11 +9553,11 @@</span>
  
          JSValueRegs resultRegs = result.regs();
          GPRReg baseGPR = base.gpr();
  
          flushRegisters();
<span class="udiff-line-modified-removed">-         m_jit.setupArguments&lt;J_JITOperation_EJI&gt;(CCallHelpers::CellValue(baseGPR), identifierUID(node-&gt;callDOMGetterData()-&gt;identifierNumber));</span>
<span class="udiff-line-modified-added">+         m_jit.setupArguments&lt;J_JITOperation_GJI&gt;(TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), CCallHelpers::CellValue(baseGPR), identifierUID(node-&gt;callDOMGetterData()-&gt;identifierNumber));</span>
          m_jit.storePtr(GPRInfo::callFrameRegister, &amp;vm().topCallFrame);
          m_jit.emitStoreCodeOrigin(m_currentNode-&gt;origin.semantic);
          m_jit.appendCall(getter.retagged&lt;CFunctionPtrTag&gt;());
          m_jit.setupResults(resultRegs);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9563,14 +9662,14 @@</span>
          speculateNotCell(node-&gt;child1(), op1Regs);
  
          flushRegisters();
  
          if (node-&gt;op() == ToString)
<span class="udiff-line-modified-removed">-             callOperation(operationToString, resultGPR, op1Regs);</span>
<span class="udiff-line-modified-added">+             callOperation(operationToString, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
          else {
              ASSERT(node-&gt;op() == CallStringConstructor);
<span class="udiff-line-modified-removed">-             callOperation(operationCallStringConstructor, resultGPR, op1Regs);</span>
<span class="udiff-line-modified-added">+             callOperation(operationCallStringConstructor, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
          }
          m_jit.exceptionCheck();
          cellResult(resultGPR, node);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9593,16 +9692,16 @@</span>
              done = m_jit.jump();
              slowPath1.link(&amp;m_jit);
              slowPath2.link(&amp;m_jit);
          }
          if (node-&gt;op() == ToString)
<span class="udiff-line-modified-removed">-             callOperation(operationToString, resultGPR, op1Regs);</span>
<span class="udiff-line-modified-added">+             callOperation(operationToString, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
          else if (node-&gt;op() == StringValueOf)
<span class="udiff-line-modified-removed">-             callOperation(operationStringValueOf, resultGPR, op1Regs);</span>
<span class="udiff-line-modified-added">+             callOperation(operationStringValueOf, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
          else {
              ASSERT(node-&gt;op() == CallStringConstructor);
<span class="udiff-line-modified-removed">-             callOperation(operationCallStringConstructor, resultGPR, op1Regs);</span>
<span class="udiff-line-modified-added">+             callOperation(operationCallStringConstructor, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
          }
          m_jit.exceptionCheck();
          if (done.isSet())
              done.link(&amp;m_jit);
          cellResult(resultGPR, node);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9669,14 +9768,14 @@</span>
              m_jit.move(op1GPR, resultGPR);
              done = m_jit.jump();
              needCall.link(&amp;m_jit);
          }
          if (node-&gt;op() == ToString)
<span class="udiff-line-modified-removed">-             callOperation(operationToStringOnCell, resultGPR, op1GPR);</span>
<span class="udiff-line-modified-added">+             callOperation(operationToStringOnCell, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1GPR);</span>
          else {
              ASSERT(node-&gt;op() == CallStringConstructor);
<span class="udiff-line-modified-removed">-             callOperation(operationCallStringConstructorOnCell, resultGPR, op1GPR);</span>
<span class="udiff-line-modified-added">+             callOperation(operationCallStringConstructorOnCell, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1GPR);</span>
          }
          m_jit.exceptionCheck();
          if (done.isSet())
              done.link(&amp;m_jit);
          cellResult(resultGPR, node);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9695,11 +9794,11 @@</span>
  
  void SpeculativeJIT::compileNumberToStringWithValidRadixConstant(Node* node, int32_t radix)
  {
      auto callToString = [&amp;] (auto operation, GPRReg resultGPR, auto valueReg) {
          flushRegisters();
<span class="udiff-line-modified-removed">-         callOperation(operation, resultGPR, valueReg, TrustedImm32(radix));</span>
<span class="udiff-line-modified-added">+         callOperation(operation, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueReg, TrustedImm32(radix));</span>
          m_jit.exceptionCheck();
          cellResult(resultGPR, node);
      };
  
      switch (node-&gt;child1().useKind()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9740,11 +9839,11 @@</span>
              validRadixIsGuaranteed = true;
      }
  
      auto callToString = [&amp;] (auto operation, GPRReg resultGPR, auto valueReg, GPRReg radixGPR) {
          flushRegisters();
<span class="udiff-line-modified-removed">-         callOperation(operation, resultGPR, valueReg, radixGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operation, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueReg, radixGPR);</span>
          m_jit.exceptionCheck();
          cellResult(resultGPR, node);
      };
  
      switch (node-&gt;child1().useKind()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9815,22 +9914,22 @@</span>
  #endif
  
      m_jit.mutatorFence(vm());
  
      addSlowPathGenerator(slowPathCall(
<span class="udiff-line-modified-removed">-         slowPath, this, operationNewStringObject, resultGPR, operandGPR, node-&gt;structure()));</span>
<span class="udiff-line-modified-added">+         slowPath, this, operationNewStringObject, resultGPR, &amp;vm(), operandGPR, node-&gt;structure()));</span>
  
      cellResult(resultGPR, node);
  }
  
  void SpeculativeJIT::compileNewSymbol(Node* node)
  {
      if (!node-&gt;child1()) {
          flushRegisters();
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-         callOperation(operationNewSymbol, resultGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationNewSymbol, resultGPR, &amp;vm());</span>
          m_jit.exceptionCheck();
          cellResult(resultGPR, node);
          return;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9841,11 +9940,11 @@</span>
      GPRReg stringGPR = operand.gpr();
  
      flushRegisters();
      GPRFlushedCallResult result(this);
      GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-     callOperation(operationNewSymbolWithDescription, resultGPR, stringGPR);</span>
<span class="udiff-line-modified-added">+     callOperation(operationNewSymbolWithDescription, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR);</span>
      m_jit.exceptionCheck();
      cellResult(resultGPR, node);
  }
  
  void SpeculativeJIT::compileNewTypedArrayWithSize(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9908,13 +10007,24 @@</span>
      m_jit.zeroExtend32ToPtr(sizeGPR, scratchGPR);
      m_jit.tagArrayPtr(scratchGPR, storageGPR);
  #endif
  
      auto butterfly = TrustedImmPtr(nullptr);
<span class="udiff-line-modified-removed">-     emitAllocateJSObject&lt;JSArrayBufferView&gt;(</span>
<span class="udiff-line-modified-removed">-         resultGPR, TrustedImmPtr(structure), butterfly, scratchGPR, scratchGPR2,</span>
<span class="udiff-line-modified-removed">-         slowCases);</span>
<span class="udiff-line-modified-added">+     switch (typedArrayType) {</span>
<span class="udiff-line-modified-added">+ #define TYPED_ARRAY_TYPE_CASE(name) \</span>
<span class="udiff-line-modified-added">+     case Type ## name: \</span>
<span class="udiff-line-added">+         emitAllocateJSObject&lt;JS##name##Array&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratchGPR, scratchGPR2, slowCases); \</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     FOR_EACH_TYPED_ARRAY_TYPE_EXCLUDING_DATA_VIEW(TYPED_ARRAY_TYPE_CASE)</span>
<span class="udiff-line-added">+ #undef TYPED_ARRAY_TYPE_CASE</span>
<span class="udiff-line-added">+     case TypeDataView:</span>
<span class="udiff-line-added">+         emitAllocateJSObject&lt;JSDataView&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratchGPR, scratchGPR2, slowCases);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
  
      m_jit.storePtr(
          storageGPR,
          MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfVector()));
      m_jit.store32(
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9926,11 +10036,11 @@</span>
  
      m_jit.mutatorFence(vm());
  
      addSlowPathGenerator(slowPathCall(
          slowCases, this, operationNewTypedArrayWithSizeForType(typedArrayType),
<span class="udiff-line-modified-removed">-         resultGPR, structure, sizeGPR, storageGPR));</span>
<span class="udiff-line-modified-added">+         resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), structure, sizeGPR, storageGPR));</span>
  
      cellResult(resultGPR, node);
  }
  
  void SpeculativeJIT::compileNewRegexp(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9957,11 +10067,11 @@</span>
          TrustedImmPtr(node-&gt;cellOperand()),
          CCallHelpers::Address(resultGPR, RegExpObject::offsetOfRegExpAndLastIndexIsNotWritableFlag()));
      m_jit.storeValue(lastIndexRegs, CCallHelpers::Address(resultGPR, RegExpObject::offsetOfLastIndex()));
      m_jit.mutatorFence(vm());
  
<span class="udiff-line-modified-removed">-     addSlowPathGenerator(slowPathCall(slowPath, this, operationNewRegexpWithLastIndex, resultGPR, regexp, lastIndexRegs));</span>
<span class="udiff-line-modified-added">+     addSlowPathGenerator(slowPathCall(slowPath, this, operationNewRegexpWithLastIndex, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), regexp, lastIndexRegs));</span>
  
      cellResult(resultGPR, node);
  }
  
  void SpeculativeJIT::speculateCellTypeWithoutTypeFiltering(
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -10181,10 +10291,38 @@</span>
  
      SpeculateCellOperand operand(this, edge);
      speculateDerivedArray(edge, operand.gpr());
  }
  
<span class="udiff-line-added">+ void SpeculativeJIT::speculatePromiseObject(Edge edge, GPRReg cell)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     speculateCellType(edge, cell, SpecPromiseObject, JSPromiseType);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SpeculativeJIT::speculatePromiseObject(Edge edge)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (!needsTypeCheck(edge, SpecPromiseObject))</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     SpeculateCellOperand operand(this, edge);</span>
<span class="udiff-line-added">+     speculatePromiseObject(edge, operand.gpr());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SpeculativeJIT::speculateDateObject(Edge edge, GPRReg cell)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     speculateCellType(edge, cell, SpecDateObject, JSDateType);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SpeculativeJIT::speculateDateObject(Edge edge)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (!needsTypeCheck(edge, SpecDateObject))</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     SpeculateCellOperand operand(this, edge);</span>
<span class="udiff-line-added">+     speculateDateObject(edge, operand.gpr());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void SpeculativeJIT::speculateMapObject(Edge edge, GPRReg cell)
  {
      speculateCellType(edge, cell, SpecMapObject, JSMapType);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -10495,11 +10633,11 @@</span>
  void SpeculativeJIT::speculateMisc(Edge edge, JSValueRegs regs)
  {
  #if USE(JSVALUE64)
      DFG_TYPE_CHECK(
          regs, edge, SpecMisc,
<span class="udiff-line-modified-removed">-         m_jit.branch64(MacroAssembler::Above, regs.gpr(), MacroAssembler::TrustedImm64(TagBitTypeOther | TagBitBool | TagBitUndefined)));</span>
<span class="udiff-line-modified-added">+         m_jit.branch64(MacroAssembler::Above, regs.gpr(), MacroAssembler::TrustedImm64(JSValue::MiscTag)));</span>
  #else
      IGNORE_WARNINGS_BEGIN(&quot;enum-compare&quot;)
      static_assert(JSValue::Int32Tag &gt;= JSValue::UndefinedTag, &quot;Int32Tag is included in &gt;= JSValue::UndefinedTag range.&quot;);
      IGNORE_WARNINGS_END
      DFG_TYPE_CHECK(
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -10577,16 +10715,22 @@</span>
          speculateFinalObject(edge);
          break;
      case RegExpObjectUse:
          speculateRegExpObject(edge);
          break;
<span class="udiff-line-added">+     case PromiseObjectUse:</span>
<span class="udiff-line-added">+         speculatePromiseObject(edge);</span>
<span class="udiff-line-added">+         break;</span>
      case ProxyObjectUse:
          speculateProxyObject(edge);
          break;
      case DerivedArrayUse:
          speculateDerivedArray(edge);
          break;
<span class="udiff-line-added">+     case DateObjectUse:</span>
<span class="udiff-line-added">+         speculateDateObject(edge);</span>
<span class="udiff-line-added">+         break;</span>
      case MapObjectUse:
          speculateMapObject(edge);
          break;
      case SetObjectUse:
          speculateSetObject(edge);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -10683,11 +10827,11 @@</span>
          auto notInt32 = m_jit.branchIfNotInt32(valueRegs);
          emitSwitchIntJump(data, valueRegs.payloadGPR(), scratch);
          notInt32.link(&amp;m_jit);
          addBranch(m_jit.branchIfNotNumber(valueRegs, scratch), data-&gt;fallThrough.block);
          silentSpillAllRegisters(scratch);
<span class="udiff-line-modified-removed">-         callOperation(operationFindSwitchImmTargetForDouble, scratch, valueRegs, data-&gt;switchTableIndex);</span>
<span class="udiff-line-modified-added">+         callOperation(operationFindSwitchImmTargetForDouble, scratch, &amp;vm(), valueRegs, data-&gt;switchTableIndex);</span>
          silentFillAllRegisters();
  
          m_jit.farJump(scratch, JSSwitchPtrTag);
          noResult(node, UseChildrenCalledExplicitly);
          break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -10697,25 +10841,23 @@</span>
          RELEASE_ASSERT_NOT_REACHED();
          break;
      }
  }
  
<span class="udiff-line-modified-removed">- void SpeculativeJIT::emitSwitchCharStringJump(</span>
<span class="udiff-line-removed">-     SwitchData* data, GPRReg value, GPRReg scratch)</span>
<span class="udiff-line-modified-added">+ void SpeculativeJIT::emitSwitchCharStringJump(Node* node, SwitchData* data, GPRReg value, GPRReg scratch)</span>
  {
      m_jit.loadPtr(MacroAssembler::Address(value, JSString::offsetOfValue()), scratch);
      auto isRope = m_jit.branchIfRopeStringImpl(scratch);
<span class="udiff-line-added">+     addSlowPathGenerator(slowPathCall(isRope, this, operationResolveRope, scratch, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), value));</span>
  
      addBranch(
          m_jit.branch32(
              MacroAssembler::NotEqual,
              MacroAssembler::Address(scratch, StringImpl::lengthMemoryOffset()),
              TrustedImm32(1)),
          data-&gt;fallThrough.block);
  
<span class="udiff-line-removed">-     addSlowPathGenerator(slowPathCall(isRope, this, operationResolveRope, scratch, value));</span>
<span class="udiff-line-removed">- </span>
      m_jit.loadPtr(MacroAssembler::Address(scratch, StringImpl::dataOffset()), value);
  
      JITCompiler::Jump is8Bit = m_jit.branchTest32(
          MacroAssembler::NonZero,
          MacroAssembler::Address(scratch, StringImpl::flagsOffset()),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -10743,11 +10885,11 @@</span>
          GPRReg tempGPR = temp.gpr();
  
          op1.use();
  
          speculateString(node-&gt;child1(), op1GPR);
<span class="udiff-line-modified-removed">-         emitSwitchCharStringJump(data, op1GPR, tempGPR);</span>
<span class="udiff-line-modified-added">+         emitSwitchCharStringJump(node, data, op1GPR, tempGPR);</span>
          noResult(node, UseChildrenCalledExplicitly);
          break;
      }
  
      case UntypedUse: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -10761,11 +10903,11 @@</span>
  
          addBranch(m_jit.branchIfNotCell(op1Regs), data-&gt;fallThrough.block);
  
          addBranch(m_jit.branchIfNotString(op1Regs.payloadGPR()), data-&gt;fallThrough.block);
  
<span class="udiff-line-modified-removed">-         emitSwitchCharStringJump(data, op1Regs.payloadGPR(), tempGPR);</span>
<span class="udiff-line-modified-added">+         emitSwitchCharStringJump(node, data, op1Regs.payloadGPR(), tempGPR);</span>
          noResult(node, UseChildrenCalledExplicitly);
          break;
      }
  
      default:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -10792,11 +10934,11 @@</span>
  void SpeculativeJIT::emitBinarySwitchStringRecurse(
      SwitchData* data, const Vector&lt;SpeculativeJIT::StringSwitchCase&gt;&amp; cases,
      unsigned numChecked, unsigned begin, unsigned end, GPRReg buffer, GPRReg length,
      GPRReg temp, unsigned alreadyCheckedLength, bool checkedExactLength)
  {
<span class="udiff-line-modified-removed">-     static const bool verbose = false;</span>
<span class="udiff-line-modified-added">+     static constexpr bool verbose = false;</span>
  
      if (verbose) {
          dataLog(&quot;We&#39;re down to the following cases, alreadyCheckedLength = &quot;, alreadyCheckedLength, &quot;:\n&quot;);
          for (unsigned i = begin; i &lt; end; ++i) {
              dataLog(&quot;    &quot;, cases[i].string, &quot;\n&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -10853,11 +10995,11 @@</span>
      if (minLength == commonChars) {
          // This is the case where one of the cases is a prefix of all of the other cases.
          // We&#39;ve already checked that the input string is a prefix of all of the cases,
          // so we just check length to jump to that case.
  
<span class="udiff-line-modified-removed">-         if (!ASSERT_DISABLED) {</span>
<span class="udiff-line-modified-added">+         if (ASSERT_ENABLED) {</span>
              ASSERT(cases[begin].string-&gt;length() == commonChars);
              for (unsigned i = begin + 1; i &lt; end; ++i)
                  ASSERT(cases[i].string-&gt;length() &gt; commonChars);
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -10918,11 +11060,11 @@</span>
      }
  
      addBranch(binarySwitch.fallThrough(), data-&gt;fallThrough.block);
  }
  
<span class="udiff-line-modified-removed">- void SpeculativeJIT::emitSwitchStringOnString(SwitchData* data, GPRReg string)</span>
<span class="udiff-line-modified-added">+ void SpeculativeJIT::emitSwitchStringOnString(Node* node, SwitchData* data, GPRReg string)</span>
  {
      data-&gt;didUseJumpTable = true;
  
      bool canDoBinarySwitch = true;
      unsigned totalLength = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -10941,11 +11083,11 @@</span>
      }
  
      if (!canDoBinarySwitch || totalLength &gt; Options::maximumBinaryStringSwitchTotalLength()) {
          flushRegisters();
          callOperation(
<span class="udiff-line-modified-removed">-             operationSwitchString, string, static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);</span>
<span class="udiff-line-modified-added">+             operationSwitchString, string, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);</span>
          m_jit.exceptionCheck();
          m_jit.farJump(string, JSSwitchPtrTag);
          return;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -10978,11 +11120,11 @@</span>
      emitBinarySwitchStringRecurse(
          data, cases, 0, 0, cases.size(), string, lengthGPR, tempGPR, 0, false);
  
      slowCases.link(&amp;m_jit);
      silentSpillAllRegisters(string);
<span class="udiff-line-modified-removed">-     callOperation(operationSwitchString, string, static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);</span>
<span class="udiff-line-modified-added">+     callOperation(operationSwitchString, string, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);</span>
      silentFillAllRegisters();
      m_jit.exceptionCheck();
      m_jit.farJump(string, JSSwitchPtrTag);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11020,11 +11162,11 @@</span>
          GPRReg op1GPR = op1.gpr();
  
          op1.use();
  
          speculateString(node-&gt;child1(), op1GPR);
<span class="udiff-line-modified-removed">-         emitSwitchStringOnString(data, op1GPR);</span>
<span class="udiff-line-modified-added">+         emitSwitchStringOnString(node, data, op1GPR);</span>
          noResult(node, UseChildrenCalledExplicitly);
          break;
      }
  
      case UntypedUse: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11036,11 +11178,11 @@</span>
  
          addBranch(m_jit.branchIfNotCell(op1Regs), data-&gt;fallThrough.block);
  
          addBranch(m_jit.branchIfNotString(op1Regs.payloadGPR()), data-&gt;fallThrough.block);
  
<span class="udiff-line-modified-removed">-         emitSwitchStringOnString(data, op1Regs.payloadGPR());</span>
<span class="udiff-line-modified-added">+         emitSwitchStringOnString(node, data, op1Regs.payloadGPR());</span>
          noResult(node, UseChildrenCalledExplicitly);
          break;
      }
  
      default:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11107,11 +11249,11 @@</span>
          noFence.link(&amp;m_jit);
      } else
          ok.append(m_jit.barrierBranchWithoutFence(baseGPR));
  
      silentSpillAllRegisters(InvalidGPRReg);
<span class="udiff-line-modified-removed">-     callOperation(operationWriteBarrierSlowPath, baseGPR);</span>
<span class="udiff-line-modified-added">+     callOperation(operationWriteBarrierSlowPath, &amp;vm(), baseGPR);</span>
      silentFillAllRegisters();
  
      ok.link(&amp;m_jit);
  
      noResult(node);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11124,11 +11266,11 @@</span>
  
      GPRReg baseGPR = base.gpr();
      GPRReg accessorGPR = accessor.gpr();
  
      flushRegisters();
<span class="udiff-line-modified-removed">-     callOperation(node-&gt;op() == PutGetterById ? operationPutGetterById : operationPutSetterById, NoResult, baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), accessorGPR);</span>
<span class="udiff-line-modified-added">+     callOperation(node-&gt;op() == PutGetterById ? operationPutGetterById : operationPutSetterById, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), accessorGPR);</span>
      m_jit.exceptionCheck();
  
      noResult(node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11142,11 +11284,11 @@</span>
      GPRReg baseGPR = base.gpr();
      GPRReg getterGPR = getter.gpr();
      GPRReg setterGPR = setter.gpr();
  
      flushRegisters();
<span class="udiff-line-modified-removed">-     callOperation(operationPutGetterSetter, NoResult, baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), getterGPR, setterGPR);</span>
<span class="udiff-line-modified-added">+     callOperation(operationPutGetterSetter, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), getterGPR, setterGPR);</span>
  #else
      // These JSValues may be JSUndefined OR JSFunction*.
      // At that time,
      // 1. If the JSValue is JSUndefined, its payload becomes nullptr.
      // 2. If the JSValue is JSFunction*, its payload becomes JSFunction*.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11154,11 +11296,11 @@</span>
      GPRReg baseGPR = base.gpr();
      JSValueRegs getterRegs = getter.jsValueRegs();
      JSValueRegs setterRegs = setter.jsValueRegs();
  
      flushRegisters();
<span class="udiff-line-modified-removed">-     callOperation(operationPutGetterSetter, NoResult, baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), getterRegs.payloadGPR(), setterRegs.payloadGPR());</span>
<span class="udiff-line-modified-added">+     callOperation(operationPutGetterSetter, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), getterRegs.payloadGPR(), setterRegs.payloadGPR());</span>
  #endif
      m_jit.exceptionCheck();
  
      noResult(node);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11168,11 +11310,11 @@</span>
      SpeculateCellOperand scope(this, node-&gt;child1());
      GPRReg scopeGPR = scope.gpr();
      GPRFlushedCallResult result(this);
      GPRReg resultGPR = result.gpr();
      flushRegisters();
<span class="udiff-line-modified-removed">-     callOperation(operationResolveScope, resultGPR, scopeGPR, identifierUID(node-&gt;identifierNumber()));</span>
<span class="udiff-line-modified-added">+     callOperation(operationResolveScope, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), scopeGPR, identifierUID(node-&gt;identifierNumber()));</span>
      m_jit.exceptionCheck();
      cellResult(resultGPR, node);
  }
  
  void SpeculativeJIT::compileResolveScopeForHoistingFuncDeclInEval(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11180,11 +11322,11 @@</span>
      SpeculateCellOperand scope(this, node-&gt;child1());
      GPRReg scopeGPR = scope.gpr();
      flushRegisters();
      JSValueRegsFlushedCallResult result(this);
      JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-     callOperation(operationResolveScopeForHoistingFuncDeclInEval, resultRegs, scopeGPR, identifierUID(node-&gt;identifierNumber()));</span>
<span class="udiff-line-modified-added">+     callOperation(operationResolveScopeForHoistingFuncDeclInEval, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), scopeGPR, identifierUID(node-&gt;identifierNumber()));</span>
      m_jit.exceptionCheck();
      jsValueResult(resultRegs, node);
  }
  
  void SpeculativeJIT::compileGetGlobalVariable(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11208,11 +11350,11 @@</span>
      SpeculateCellOperand scope(this, node-&gt;child1());
      GPRReg scopeGPR = scope.gpr();
      flushRegisters();
      JSValueRegsFlushedCallResult result(this);
      JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-     callOperation(operationGetDynamicVar, resultRegs, scopeGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());</span>
<span class="udiff-line-modified-added">+     callOperation(operationGetDynamicVar, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), scopeGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());</span>
      m_jit.exceptionCheck();
      jsValueResult(resultRegs, node);
  }
  
  void SpeculativeJIT::compilePutDynamicVar(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11222,11 +11364,11 @@</span>
  
      GPRReg scopeGPR = scope.gpr();
      JSValueRegs valueRegs = value.jsValueRegs();
  
      flushRegisters();
<span class="udiff-line-modified-removed">-     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutDynamicVarStrict : operationPutDynamicVarNonStrict, NoResult, scopeGPR, valueRegs, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());</span>
<span class="udiff-line-modified-added">+     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutDynamicVarStrict : operationPutDynamicVarNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), scopeGPR, valueRegs, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());</span>
      m_jit.exceptionCheck();
      noResult(node);
  }
  
  void SpeculativeJIT::compileGetClosureVar(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11251,10 +11393,34 @@</span>
  
      m_jit.storeValue(valueRegs, JITCompiler::Address(baseGPR, JSLexicalEnvironment::offsetOfVariable(node-&gt;scopeOffset())));
      noResult(node);
  }
  
<span class="udiff-line-added">+ void SpeculativeJIT::compileGetInternalField(Node* node)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     SpeculateCellOperand base(this, node-&gt;child1());</span>
<span class="udiff-line-added">+     JSValueRegsTemporary result(this);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     GPRReg baseGPR = base.gpr();</span>
<span class="udiff-line-added">+     JSValueRegs resultRegs = result.regs();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     m_jit.loadValue(JITCompiler::Address(baseGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(node-&gt;internalFieldIndex())), resultRegs);</span>
<span class="udiff-line-added">+     jsValueResult(resultRegs, node);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SpeculativeJIT::compilePutInternalField(Node* node)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     SpeculateCellOperand base(this, node-&gt;child1());</span>
<span class="udiff-line-added">+     JSValueOperand value(this, node-&gt;child2());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     GPRReg baseGPR = base.gpr();</span>
<span class="udiff-line-added">+     JSValueRegs valueRegs = value.jsValueRegs();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     m_jit.storeValue(valueRegs, JITCompiler::Address(baseGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(node-&gt;internalFieldIndex())));</span>
<span class="udiff-line-added">+     noResult(node);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void SpeculativeJIT::compilePutAccessorByVal(Node* node)
  {
      SpeculateCellOperand base(this, node-&gt;child1());
      JSValueOperand subscript(this, node-&gt;child2());
      SpeculateCellOperand accessor(this, node-&gt;child3());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11264,11 +11430,11 @@</span>
      GPRReg baseGPR = base.gpr();
      JSValueRegs subscriptRegs = subscript.jsValueRegs();
      GPRReg accessorGPR = accessor.gpr();
  
      flushRegisters();
<span class="udiff-line-modified-removed">-     callOperation(operation, NoResult, baseGPR, subscriptRegs, node-&gt;accessorAttributes(), accessorGPR);</span>
<span class="udiff-line-modified-added">+     callOperation(operation, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, subscriptRegs, node-&gt;accessorAttributes(), accessorGPR);</span>
      m_jit.exceptionCheck();
  
      noResult(node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11441,11 +11607,11 @@</span>
                  speculateString(node-&gt;child1(), stringGPR);
                  speculateRegExpObject(node-&gt;child2(), regExpGPR);
  
                  flushRegisters();
                  GPRFlushedCallResult result(this);
<span class="udiff-line-modified-removed">-                 callOperation(operationStringProtoFuncReplaceRegExpEmptyStr, result.gpr(), stringGPR, regExpGPR);</span>
<span class="udiff-line-modified-added">+                 callOperation(operationStringProtoFuncReplaceRegExpEmptyStr, result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR, regExpGPR);</span>
                  m_jit.exceptionCheck();
                  cellResult(result.gpr(), node);
                  if (sample)
                      m_jit.decrementSuperSamplerCount();
                  return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11462,11 +11628,11 @@</span>
          speculateRegExpObject(node-&gt;child2(), regExpGPR);
          speculateString(node-&gt;child3(), replaceGPR);
  
          flushRegisters();
          GPRFlushedCallResult result(this);
<span class="udiff-line-modified-removed">-         callOperation(operationStringProtoFuncReplaceRegExpString, result.gpr(), stringGPR, regExpGPR, replaceGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationStringProtoFuncReplaceRegExpString, result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR, regExpGPR, replaceGPR);</span>
          m_jit.exceptionCheck();
          cellResult(result.gpr(), node);
          if (sample)
              m_jit.decrementSuperSamplerCount();
          return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11484,11 +11650,11 @@</span>
      JSValueRegs searchRegs = search.jsValueRegs();
      JSValueRegs replaceRegs = replace.jsValueRegs();
  
      flushRegisters();
      GPRFlushedCallResult result(this);
<span class="udiff-line-modified-removed">-     callOperation(operationStringProtoFuncReplaceGeneric, result.gpr(), stringRegs, searchRegs, replaceRegs);</span>
<span class="udiff-line-modified-added">+     callOperation(operationStringProtoFuncReplaceGeneric, result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringRegs, searchRegs, replaceRegs);</span>
      m_jit.exceptionCheck();
      cellResult(result.gpr(), node);
      if (sample)
          m_jit.decrementSuperSamplerCount();
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11707,11 +11873,11 @@</span>
          speculateString(propertyEdge, propertyGPR);
  
          useChildren(node);
  
          flushRegisters();
<span class="udiff-line-modified-removed">-         callOperation(operationDefineDataPropertyString, NoResult, baseGPR, propertyGPR, valueRegs, attributesGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationDefineDataPropertyString, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyGPR, valueRegs, attributesGPR);</span>
          m_jit.exceptionCheck();
          break;
      }
      case StringIdentUse: {
          SpeculateCellOperand property(this, propertyEdge);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11724,11 +11890,11 @@</span>
          speculateStringIdentAndLoadStorage(propertyEdge, propertyGPR, identGPR);
  
          useChildren(node);
  
          flushRegisters();
<span class="udiff-line-modified-removed">-         callOperation(operationDefineDataPropertyStringIdent, NoResult, baseGPR, identGPR, valueRegs, attributesGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationDefineDataPropertyStringIdent, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, identGPR, valueRegs, attributesGPR);</span>
          m_jit.exceptionCheck();
          break;
      }
      case SymbolUse: {
          SpeculateCellOperand property(this, propertyEdge);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11736,22 +11902,22 @@</span>
          speculateSymbol(propertyEdge, propertyGPR);
  
          useChildren(node);
  
          flushRegisters();
<span class="udiff-line-modified-removed">-         callOperation(operationDefineDataPropertySymbol, NoResult, baseGPR, propertyGPR, valueRegs, attributesGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationDefineDataPropertySymbol, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyGPR, valueRegs, attributesGPR);</span>
          m_jit.exceptionCheck();
          break;
      }
      case UntypedUse: {
          JSValueOperand property(this, propertyEdge);
          JSValueRegs propertyRegs = property.jsValueRegs();
  
          useChildren(node);
  
          flushRegisters();
<span class="udiff-line-modified-removed">-         callOperation(operationDefineDataProperty, NoResult, baseGPR, propertyRegs, valueRegs, attributesGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationDefineDataProperty, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyRegs, valueRegs, attributesGPR);</span>
          m_jit.exceptionCheck();
          break;
      }
      default:
          RELEASE_ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11788,11 +11954,11 @@</span>
          speculateString(propertyEdge, propertyGPR);
  
          useChildren(node);
  
          flushRegisters();
<span class="udiff-line-modified-removed">-         callOperation(operationDefineAccessorPropertyString, NoResult, baseGPR, propertyGPR, getterGPR, setterGPR, attributesGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationDefineAccessorPropertyString, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyGPR, getterGPR, setterGPR, attributesGPR);</span>
          m_jit.exceptionCheck();
          break;
      }
      case StringIdentUse: {
          SpeculateCellOperand property(this, propertyEdge);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11805,11 +11971,11 @@</span>
          speculateStringIdentAndLoadStorage(propertyEdge, propertyGPR, identGPR);
  
          useChildren(node);
  
          flushRegisters();
<span class="udiff-line-modified-removed">-         callOperation(operationDefineAccessorPropertyStringIdent, NoResult, baseGPR, identGPR, getterGPR, setterGPR, attributesGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationDefineAccessorPropertyStringIdent, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, identGPR, getterGPR, setterGPR, attributesGPR);</span>
          m_jit.exceptionCheck();
          break;
      }
      case SymbolUse: {
          SpeculateCellOperand property(this, propertyEdge);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11817,22 +11983,22 @@</span>
          speculateSymbol(propertyEdge, propertyGPR);
  
          useChildren(node);
  
          flushRegisters();
<span class="udiff-line-modified-removed">-         callOperation(operationDefineAccessorPropertySymbol, NoResult, baseGPR, propertyGPR, getterGPR, setterGPR, attributesGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationDefineAccessorPropertySymbol, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyGPR, getterGPR, setterGPR, attributesGPR);</span>
          m_jit.exceptionCheck();
          break;
      }
      case UntypedUse: {
          JSValueOperand property(this, propertyEdge);
          JSValueRegs propertyRegs = property.jsValueRegs();
  
          useChildren(node);
  
          flushRegisters();
<span class="udiff-line-modified-removed">-         callOperation(operationDefineAccessorProperty, NoResult, baseGPR, propertyRegs, getterGPR, setterGPR, attributesGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationDefineAccessorProperty, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyRegs, getterGPR, setterGPR, attributesGPR);</span>
          m_jit.exceptionCheck();
          break;
      }
      default:
          RELEASE_ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -11846,11 +12012,11 @@</span>
      RELEASE_ASSERT(RegisterSet(storageResultGPR, sizeGPR, scratch1, scratch2, scratch3).numberOfSetGPRs() == 5);
      ASSERT((1 &lt;&lt; 3) == sizeof(JSValue));
      m_jit.zeroExtend32ToPtr(sizeGPR, scratch1);
      m_jit.lshift32(TrustedImm32(3), scratch1);
      m_jit.add32(TrustedImm32(sizeof(IndexingHeader)), scratch1, scratch2);
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
      MacroAssembler::Jump didNotOverflow = m_jit.branch32(MacroAssembler::AboveOrEqual, scratch2, sizeGPR);
      m_jit.abortWithReason(UncheckedOverflow);
      didNotOverflow.link(&amp;m_jit);
  #endif
      m_jit.emitAllocateVariableSized(
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12016,11 +12182,11 @@</span>
  void SpeculativeJIT::compileThrow(Node* node)
  {
      JSValueOperand value(this, node-&gt;child1());
      JSValueRegs valueRegs = value.jsValueRegs();
      flushRegisters();
<span class="udiff-line-modified-removed">-     callOperation(operationThrowDFG, valueRegs);</span>
<span class="udiff-line-modified-added">+     callOperation(operationThrowDFG, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs);</span>
      m_jit.exceptionCheck();
      m_jit.breakpoint();
      noResult(node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12028,11 +12194,11 @@</span>
  {
      SpeculateCellOperand message(this, node-&gt;child1());
      GPRReg messageGPR = message.gpr();
      speculateString(node-&gt;child1(), messageGPR);
      flushRegisters();
<span class="udiff-line-modified-removed">-     callOperation(operationThrowStaticError, messageGPR, node-&gt;errorType());</span>
<span class="udiff-line-modified-added">+     callOperation(operationThrowStaticError, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), messageGPR, node-&gt;errorType());</span>
      m_jit.exceptionCheck();
      m_jit.breakpoint();
      noResult(node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12055,11 +12221,11 @@</span>
      GPRReg propertyGPR = property.gpr();
  
      flushRegisters();
      JSValueRegsFlushedCallResult result(this);
      JSValueRegs resultRegs = result.regs();
<span class="udiff-line-modified-removed">-     callOperation(operationHasGenericProperty, resultRegs, baseRegs, propertyGPR);</span>
<span class="udiff-line-modified-added">+     callOperation(operationHasGenericProperty, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs, propertyGPR);</span>
      m_jit.exceptionCheck();
      blessedBooleanResult(resultRegs.payloadGPR(), node);
  }
  
  void SpeculativeJIT::compileToIndexString(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12068,11 +12234,11 @@</span>
      GPRReg indexGPR = index.gpr();
  
      flushRegisters();
      GPRFlushedCallResult result(this);
      GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-     callOperation(operationToIndexString, resultGPR, indexGPR);</span>
<span class="udiff-line-modified-added">+     callOperation(operationToIndexString, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), indexGPR);</span>
      m_jit.exceptionCheck();
      cellResult(resultGPR, node);
  }
  
  void SpeculativeJIT::compilePutByIdFlush(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12130,11 +12296,11 @@</span>
      JSValueOperand value(this, node-&gt;child3());
      JSValueRegs valueRegs = value.jsValueRegs();
  
      flushRegisters();
      callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByIdWithThisStrict : operationPutByIdWithThis,
<span class="udiff-line-modified-removed">-         NoResult, baseRegs, thisRegs, valueRegs, identifierUID(node-&gt;identifierNumber()));</span>
<span class="udiff-line-modified-added">+         TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs, thisRegs, valueRegs, identifierUID(node-&gt;identifierNumber()));</span>
      m_jit.exceptionCheck();
  
      noResult(node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12220,11 +12386,11 @@</span>
      moveTrueTo(resultRegs.payloadGPR());
      MacroAssembler::Jump done = m_jit.jump();
  
      done.link(&amp;m_jit);
  
<span class="udiff-line-modified-removed">-     addSlowPathGenerator(slowPathCall(wrongStructure, this, operationHasGenericProperty, resultRegs, baseRegs, propertyGPR));</span>
<span class="udiff-line-modified-added">+     addSlowPathGenerator(slowPathCall(wrongStructure, this, operationHasGenericProperty, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs, propertyGPR));</span>
      blessedBooleanResult(resultRegs.payloadGPR(), node);
  }
  
  void SpeculativeJIT::compileGetPropertyEnumerator(Node* node)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12233,11 +12399,11 @@</span>
          GPRReg baseGPR = base.gpr();
  
          flushRegisters();
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-         callOperation(operationGetPropertyEnumeratorCell, resultGPR, baseGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationGetPropertyEnumeratorCell, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR);</span>
          m_jit.exceptionCheck();
          cellResult(resultGPR, node);
          return;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12245,11 +12411,11 @@</span>
      JSValueRegs baseRegs = base.jsValueRegs();
  
      flushRegisters();
      GPRFlushedCallResult result(this);
      GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-     callOperation(operationGetPropertyEnumerator, resultGPR, baseRegs);</span>
<span class="udiff-line-modified-added">+     callOperation(operationGetPropertyEnumerator, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs);</span>
      m_jit.exceptionCheck();
      cellResult(resultGPR, node);
  }
  
  void SpeculativeJIT::compileGetEnumeratorPname(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12290,11 +12456,14 @@</span>
      SpeculateCellOperand function(this, node-&gt;child1());
      GPRTemporary result(this, Reuse, function);
      GPRReg functionGPR = function.gpr();
      GPRReg resultGPR = result.gpr();
      speculateCellType(node-&gt;child1(), functionGPR, SpecFunction, JSFunctionType);
<span class="udiff-line-modified-removed">-     m_jit.loadPtr(JITCompiler::Address(functionGPR, JSFunction::offsetOfExecutable()), resultGPR);</span>
<span class="udiff-line-modified-added">+     m_jit.loadPtr(JITCompiler::Address(functionGPR, JSFunction::offsetOfExecutableOrRareData()), resultGPR);</span>
<span class="udiff-line-added">+     auto hasExecutable = m_jit.branchTestPtr(CCallHelpers::Zero, resultGPR, CCallHelpers::TrustedImm32(JSFunction::rareDataTag));</span>
<span class="udiff-line-added">+     m_jit.loadPtr(CCallHelpers::Address(resultGPR, FunctionRareData::offsetOfExecutable() - JSFunction::rareDataTag), resultGPR);</span>
<span class="udiff-line-added">+     hasExecutable.link(&amp;m_jit);</span>
      cellResult(resultGPR, node);
  }
  
  void SpeculativeJIT::compileGetGetter(Node* node)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12341,18 +12510,18 @@</span>
      GPRTemporary result(this);
      VirtualRegister argumentCountRegister;
      if (InlineCallFrame* inlineCallFrame = node-&gt;argumentsInlineCallFrame())
          argumentCountRegister = inlineCallFrame-&gt;argumentCountRegister;
      else
<span class="udiff-line-modified-removed">-         argumentCountRegister = VirtualRegister(CallFrameSlot::argumentCount);</span>
<span class="udiff-line-modified-added">+         argumentCountRegister = CallFrameSlot::argumentCountIncludingThis;</span>
      m_jit.load32(JITCompiler::payloadFor(argumentCountRegister), result.gpr());
      int32Result(result.gpr(), node);
  }
  
  void SpeculativeJIT::compileSetArgumentCountIncludingThis(Node* node)
  {
<span class="udiff-line-modified-removed">-     m_jit.store32(TrustedImm32(node-&gt;argumentCountIncludingThis()), JITCompiler::payloadFor(CallFrameSlot::argumentCount));</span>
<span class="udiff-line-modified-added">+     m_jit.store32(TrustedImm32(node-&gt;argumentCountIncludingThis()), JITCompiler::payloadFor(CallFrameSlot::argumentCountIncludingThis));</span>
      noResult(node);
  }
  
  void SpeculativeJIT::compileStrCat(Node* node)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12369,13 +12538,13 @@</span>
  
      flushRegisters();
  
      GPRFlushedCallResult result(this);
      if (node-&gt;child3())
<span class="udiff-line-modified-removed">-         callOperation(operationStrCat3, result.gpr(), op1Regs, op2Regs, op3Regs);</span>
<span class="udiff-line-modified-added">+         callOperation(operationStrCat3, result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs, op2Regs, op3Regs);</span>
      else
<span class="udiff-line-modified-removed">-         callOperation(operationStrCat2, result.gpr(), op1Regs, op2Regs);</span>
<span class="udiff-line-modified-added">+         callOperation(operationStrCat2, result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs, op2Regs);</span>
      m_jit.exceptionCheck();
  
      cellResult(result.gpr(), node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12398,21 +12567,21 @@</span>
  
          MacroAssembler::JumpList slowCases;
  
          emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(structure), TrustedImmPtr(array-&gt;toButterfly()), scratch1GPR, scratch2GPR, slowCases);
  
<span class="udiff-line-modified-removed">-         addSlowPathGenerator(slowPathCall(slowCases, this, operationNewArrayBuffer, result.gpr(), structure, array));</span>
<span class="udiff-line-modified-added">+         addSlowPathGenerator(slowPathCall(slowCases, this, operationNewArrayBuffer, result.gpr(), &amp;vm(), structure, array));</span>
  
          DFG_ASSERT(m_jit.graph(), node, indexingMode &amp; IsArray, indexingMode);
          cellResult(resultGPR, node);
          return;
      }
  
      flushRegisters();
      GPRFlushedCallResult result(this);
  
<span class="udiff-line-modified-removed">-     callOperation(operationNewArrayBuffer, result.gpr(), structure, TrustedImmPtr(node-&gt;cellOperand()));</span>
<span class="udiff-line-modified-added">+     callOperation(operationNewArrayBuffer, result.gpr(), &amp;vm(), structure, TrustedImmPtr(node-&gt;cellOperand()));</span>
      m_jit.exceptionCheck();
  
      cellResult(result.gpr(), node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12441,11 +12610,11 @@</span>
      m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType()))), structureGPR);
      MacroAssembler::Jump done = m_jit.jump();
      bigLength.link(&amp;m_jit);
      m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage))), structureGPR);
      done.link(&amp;m_jit);
<span class="udiff-line-modified-removed">-     callOperation(operationNewArrayWithSize, resultGPR, structureGPR, sizeGPR, nullptr);</span>
<span class="udiff-line-modified-added">+     callOperation(operationNewArrayWithSize, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), structureGPR, sizeGPR, nullptr);</span>
      m_jit.exceptionCheck();
      cellResult(resultGPR, node);
  }
  
  void SpeculativeJIT::compileNewTypedArray(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12464,11 +12633,11 @@</span>
          GPRReg resultGPR = result.gpr();
  
          JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
          callOperation(
              operationNewTypedArrayWithOneArgumentForType(node-&gt;typedArrayType()),
<span class="udiff-line-modified-removed">-             resultGPR, m_jit.graph().registerStructure(globalObject-&gt;typedArrayStructureConcurrently(node-&gt;typedArrayType())), argumentRegs);</span>
<span class="udiff-line-modified-added">+             resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), m_jit.graph().registerStructure(globalObject-&gt;typedArrayStructureConcurrently(node-&gt;typedArrayType())), argumentRegs);</span>
          m_jit.exceptionCheck();
  
          cellResult(resultGPR, node);
          break;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12494,16 +12663,16 @@</span>
              MacroAssembler::NonZero,
              MacroAssembler::Address(thisValueRegs.payloadGPR(), JSCell::typeInfoFlagsOffset()),
              MacroAssembler::TrustedImm32(OverridesToThis)));
      m_jit.moveValueRegs(thisValueRegs, tempRegs);
  
<span class="udiff-line-modified-removed">-     J_JITOperation_EJ function;</span>
<span class="udiff-line-modified-added">+     J_JITOperation_GJ function;</span>
      if (m_jit.isStrictModeFor(node-&gt;origin.semantic))
          function = operationToThisStrict;
      else
          function = operationToThis;
<span class="udiff-line-modified-removed">-     addSlowPathGenerator(slowPathCall(slowCases, this, function, tempRegs, thisValueRegs));</span>
<span class="udiff-line-modified-added">+     addSlowPathGenerator(slowPathCall(slowCases, this, function, tempRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), thisValueRegs));</span>
  
      jsValueResult(tempRegs, node);
  }
  
  void SpeculativeJIT::compileObjectKeys(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12543,17 +12712,17 @@</span>
  
              JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
              RegisteredStructure arrayStructure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(CopyOnWriteArrayWithContiguous));
  
              m_jit.move(scratchGPR, scratch3GPR);
<span class="udiff-line-modified-removed">-             m_jit.addPtr(TrustedImmPtr(JSImmutableButterfly::offsetOfData()), scratchGPR);</span>
<span class="udiff-line-modified-added">+             m_jit.addPtr(TrustedImm32(JSImmutableButterfly::offsetOfData()), scratchGPR);</span>
  
              emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(arrayStructure), scratchGPR, structureGPR, scratch2GPR, slowButArrayBufferCases);
  
<span class="udiff-line-modified-removed">-             addSlowPathGenerator(slowPathCall(slowButArrayBufferCases, this, operationNewArrayBuffer, resultGPR, arrayStructure, scratch3GPR));</span>
<span class="udiff-line-modified-added">+             addSlowPathGenerator(slowPathCall(slowButArrayBufferCases, this, operationNewArrayBuffer, resultGPR, &amp;vm(), arrayStructure, scratch3GPR));</span>
  
<span class="udiff-line-modified-removed">-             addSlowPathGenerator(slowPathCall(slowCases, this, operationObjectKeysObject, resultGPR, objectGPR));</span>
<span class="udiff-line-modified-added">+             addSlowPathGenerator(slowPathCall(slowCases, this, operationObjectKeysObject, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), objectGPR));</span>
  
              cellResult(resultGPR, node);
              break;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12564,11 +12733,11 @@</span>
          speculateObject(node-&gt;child1(), objectGPR);
  
          flushRegisters();
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-         callOperation(operationObjectKeysObject, resultGPR, objectGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationObjectKeysObject, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), objectGPR);</span>
          m_jit.exceptionCheck();
  
          cellResult(resultGPR, node);
          break;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12579,11 +12748,11 @@</span>
          JSValueRegs objectRegs = object.jsValueRegs();
  
          flushRegisters();
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-         callOperation(operationObjectKeys, resultGPR, objectRegs);</span>
<span class="udiff-line-modified-added">+         callOperation(operationObjectKeys, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), objectRegs);</span>
          m_jit.exceptionCheck();
  
          cellResult(resultGPR, node);
          break;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12605,11 +12774,11 @@</span>
          speculateObject(node-&gt;child1(), prototypeGPR);
  
          flushRegisters();
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-         callOperation(operationObjectCreateObject, resultGPR, prototypeGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationObjectCreateObject, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), prototypeGPR);</span>
          m_jit.exceptionCheck();
  
          cellResult(resultGPR, node);
          break;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12620,11 +12789,11 @@</span>
          JSValueRegs prototypeRegs = prototype.jsValueRegs();
  
          flushRegisters();
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-         callOperation(operationObjectCreate, resultGPR, prototypeRegs);</span>
<span class="udiff-line-modified-added">+         callOperation(operationObjectCreate, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), prototypeRegs);</span>
          m_jit.exceptionCheck();
  
          cellResult(resultGPR, node);
          break;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12660,27 +12829,132 @@</span>
      GPRReg inlineCapacityGPR = rareDataGPR;
  
      MacroAssembler::JumpList slowPath;
  
      slowPath.append(m_jit.branchIfNotFunction(calleeGPR));
<span class="udiff-line-modified-removed">-     m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfRareData()), rareDataGPR);</span>
<span class="udiff-line-modified-removed">-     slowPath.append(m_jit.branchTestPtr(MacroAssembler::Zero, rareDataGPR));</span>
<span class="udiff-line-modified-removed">-     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfAllocator()), allocatorGPR);</span>
<span class="udiff-line-modified-removed">-     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfStructure()), structureGPR);</span>
<span class="udiff-line-modified-added">+     m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfExecutableOrRareData()), rareDataGPR);</span>
<span class="udiff-line-modified-added">+     slowPath.append(m_jit.branchTestPtr(MacroAssembler::Zero, rareDataGPR, CCallHelpers::TrustedImm32(JSFunction::rareDataTag)));</span>
<span class="udiff-line-modified-added">+     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfAllocator() - JSFunction::rareDataTag), allocatorGPR);</span>
<span class="udiff-line-modified-added">+     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfStructure() - JSFunction::rareDataTag), structureGPR);</span>
  
      auto butterfly = TrustedImmPtr(nullptr);
      emitAllocateJSObject(resultGPR, JITAllocator::variable(), allocatorGPR, structureGPR, butterfly, scratchGPR, slowPath);
  
      m_jit.load8(JITCompiler::Address(structureGPR, Structure::inlineCapacityOffset()), inlineCapacityGPR);
      m_jit.emitInitializeInlineStorage(resultGPR, inlineCapacityGPR);
      m_jit.mutatorFence(vm());
  
<span class="udiff-line-modified-removed">-     addSlowPathGenerator(slowPathCall(slowPath, this, operationCreateThis, resultGPR, calleeGPR, node-&gt;inlineCapacity()));</span>
<span class="udiff-line-modified-added">+     addSlowPathGenerator(slowPathCall(slowPath, this, operationCreateThis, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), calleeGPR, node-&gt;inlineCapacity()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     cellResult(resultGPR, node);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SpeculativeJIT::compileCreatePromise(Node* node)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     SpeculateCellOperand callee(this, node-&gt;child1());</span>
<span class="udiff-line-added">+     GPRTemporary result(this);</span>
<span class="udiff-line-added">+     GPRTemporary structure(this);</span>
<span class="udiff-line-added">+     GPRTemporary scratch1(this);</span>
<span class="udiff-line-added">+     GPRTemporary scratch2(this);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     GPRReg calleeGPR = callee.gpr();</span>
<span class="udiff-line-added">+     GPRReg resultGPR = result.gpr();</span>
<span class="udiff-line-added">+     GPRReg structureGPR = structure.gpr();</span>
<span class="udiff-line-added">+     GPRReg scratch1GPR = scratch1.gpr();</span>
<span class="udiff-line-added">+     GPRReg scratch2GPR = scratch2.gpr();</span>
<span class="udiff-line-added">+     // Rare data is only used to access the allocator &amp; structure</span>
<span class="udiff-line-added">+     // We can avoid using an additional GPR this way</span>
<span class="udiff-line-added">+     GPRReg rareDataGPR = structureGPR;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseStructure() : globalObject-&gt;promiseStructure())), structureGPR);</span>
<span class="udiff-line-added">+     auto fastPromisePath = m_jit.branchPtr(CCallHelpers::Equal, calleeGPR, TrustedImmPtr::weakPointer(m_jit.graph(), node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseConstructor() : globalObject-&gt;promiseConstructor()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     MacroAssembler::JumpList slowCases;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     slowCases.append(m_jit.branchIfNotFunction(calleeGPR));</span>
<span class="udiff-line-added">+     m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfExecutableOrRareData()), rareDataGPR);</span>
<span class="udiff-line-added">+     slowCases.append(m_jit.branchTestPtr(MacroAssembler::Zero, rareDataGPR, CCallHelpers::TrustedImm32(JSFunction::rareDataTag)));</span>
<span class="udiff-line-added">+     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfInternalFunctionAllocationProfile() + InternalFunctionAllocationProfile::offsetOfStructure() - JSFunction::rareDataTag), structureGPR);</span>
<span class="udiff-line-added">+     slowCases.append(m_jit.branchTestPtr(CCallHelpers::Zero, structureGPR));</span>
<span class="udiff-line-added">+     m_jit.move(TrustedImmPtr(node-&gt;isInternalPromise() ? JSInternalPromise::info() : JSPromise::info()), scratch1GPR);</span>
<span class="udiff-line-added">+     slowCases.append(m_jit.branchPtr(CCallHelpers::NotEqual, scratch1GPR, CCallHelpers::Address(structureGPR, Structure::classInfoOffset())));</span>
<span class="udiff-line-added">+     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), globalObject), scratch1GPR);</span>
<span class="udiff-line-added">+     slowCases.append(m_jit.branchPtr(CCallHelpers::NotEqual, scratch1GPR, CCallHelpers::Address(structureGPR, Structure::globalObjectOffset())));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     fastPromisePath.link(&amp;m_jit);</span>
<span class="udiff-line-added">+     auto butterfly = TrustedImmPtr(nullptr);</span>
<span class="udiff-line-added">+     if (node-&gt;isInternalPromise())</span>
<span class="udiff-line-added">+         emitAllocateJSObjectWithKnownSize&lt;JSInternalPromise&gt;(resultGPR, structureGPR, butterfly, scratch1GPR, scratch2GPR, slowCases, sizeof(JSInternalPromise));</span>
<span class="udiff-line-added">+     else</span>
<span class="udiff-line-added">+         emitAllocateJSObjectWithKnownSize&lt;JSPromise&gt;(resultGPR, structureGPR, butterfly, scratch1GPR, scratch2GPR, slowCases, sizeof(JSPromise));</span>
<span class="udiff-line-added">+     m_jit.storeTrustedValue(jsNumber(static_cast&lt;unsigned&gt;(JSPromise::Status::Pending)), CCallHelpers::Address(resultGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(static_cast&lt;unsigned&gt;(JSPromise::Field::Flags))));</span>
<span class="udiff-line-added">+     m_jit.storeTrustedValue(jsUndefined(), CCallHelpers::Address(resultGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(static_cast&lt;unsigned&gt;(JSPromise::Field::ReactionsOrResult))));</span>
<span class="udiff-line-added">+     m_jit.mutatorFence(m_jit.vm());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     addSlowPathGenerator(slowPathCall(slowCases, this, node-&gt;isInternalPromise() ? operationCreateInternalPromise : operationCreatePromise, resultGPR, TrustedImmPtr::weakPointer(m_jit.graph(), globalObject), calleeGPR));</span>
  
      cellResult(resultGPR, node);
  }
  
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template&lt;typename JSClass, typename Operation&gt;</span>
<span class="udiff-line-added">+ void SpeculativeJIT::compileCreateInternalFieldObject(Node* node, Operation operation)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     SpeculateCellOperand callee(this, node-&gt;child1());</span>
<span class="udiff-line-added">+     GPRTemporary result(this);</span>
<span class="udiff-line-added">+     GPRTemporary structure(this);</span>
<span class="udiff-line-added">+     GPRTemporary scratch1(this);</span>
<span class="udiff-line-added">+     GPRTemporary scratch2(this);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     GPRReg calleeGPR = callee.gpr();</span>
<span class="udiff-line-added">+     GPRReg resultGPR = result.gpr();</span>
<span class="udiff-line-added">+     GPRReg structureGPR = structure.gpr();</span>
<span class="udiff-line-added">+     GPRReg scratch1GPR = scratch1.gpr();</span>
<span class="udiff-line-added">+     GPRReg scratch2GPR = scratch2.gpr();</span>
<span class="udiff-line-added">+     // Rare data is only used to access the allocator &amp; structure</span>
<span class="udiff-line-added">+     // We can avoid using an additional GPR this way</span>
<span class="udiff-line-added">+     GPRReg rareDataGPR = structureGPR;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     MacroAssembler::JumpList slowCases;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     slowCases.append(m_jit.branchIfNotFunction(calleeGPR));</span>
<span class="udiff-line-added">+     m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfExecutableOrRareData()), rareDataGPR);</span>
<span class="udiff-line-added">+     slowCases.append(m_jit.branchTestPtr(MacroAssembler::Zero, rareDataGPR, CCallHelpers::TrustedImm32(JSFunction::rareDataTag)));</span>
<span class="udiff-line-added">+     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfInternalFunctionAllocationProfile() + InternalFunctionAllocationProfile::offsetOfStructure() - JSFunction::rareDataTag), structureGPR);</span>
<span class="udiff-line-added">+     slowCases.append(m_jit.branchTestPtr(CCallHelpers::Zero, structureGPR));</span>
<span class="udiff-line-added">+     m_jit.move(TrustedImmPtr(JSClass::info()), scratch1GPR);</span>
<span class="udiff-line-added">+     slowCases.append(m_jit.branchPtr(CCallHelpers::NotEqual, scratch1GPR, CCallHelpers::Address(structureGPR, Structure::classInfoOffset())));</span>
<span class="udiff-line-added">+     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), globalObject), scratch1GPR);</span>
<span class="udiff-line-added">+     slowCases.append(m_jit.branchPtr(CCallHelpers::NotEqual, scratch1GPR, CCallHelpers::Address(structureGPR, Structure::globalObjectOffset())));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto butterfly = TrustedImmPtr(nullptr);</span>
<span class="udiff-line-added">+     emitAllocateJSObjectWithKnownSize&lt;JSClass&gt;(resultGPR, structureGPR, butterfly, scratch1GPR, scratch2GPR, slowCases, sizeof(JSClass));</span>
<span class="udiff-line-added">+     auto initialValues = JSClass::initialValues();</span>
<span class="udiff-line-added">+     ASSERT(initialValues.size() == JSClass::numberOfInternalFields);</span>
<span class="udiff-line-added">+     for (unsigned index = 0; index &lt; initialValues.size(); ++index)</span>
<span class="udiff-line-added">+         m_jit.storeTrustedValue(initialValues[index], CCallHelpers::Address(resultGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index)));</span>
<span class="udiff-line-added">+     m_jit.mutatorFence(m_jit.vm());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     addSlowPathGenerator(slowPathCall(slowCases, this, operation, resultGPR, TrustedImmPtr::weakPointer(m_jit.graph(), globalObject), calleeGPR));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     cellResult(resultGPR, node);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SpeculativeJIT::compileCreateGenerator(Node* node)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     compileCreateInternalFieldObject&lt;JSGenerator&gt;(node, operationCreateGenerator);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SpeculativeJIT::compileCreateAsyncGenerator(Node* node)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     compileCreateInternalFieldObject&lt;JSAsyncGenerator&gt;(node, operationCreateAsyncGenerator);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void SpeculativeJIT::compileNewObject(Node* node)
  {
      GPRTemporary result(this);
      GPRTemporary allocator(this);
      GPRTemporary scratch(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12701,15 +12975,84 @@</span>
          emitAllocateJSObject(resultGPR, JITAllocator::constant(allocatorValue), allocatorGPR, TrustedImmPtr(structure), butterfly, scratchGPR, slowPath);
          m_jit.emitInitializeInlineStorage(resultGPR, structure-&gt;inlineCapacity());
          m_jit.mutatorFence(vm());
      }
  
<span class="udiff-line-modified-removed">-     addSlowPathGenerator(slowPathCall(slowPath, this, operationNewObject, resultGPR, structure));</span>
<span class="udiff-line-modified-added">+     addSlowPathGenerator(slowPathCall(slowPath, this, operationNewObject, resultGPR, &amp;vm(), structure));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     cellResult(resultGPR, node);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SpeculativeJIT::compileNewPromise(Node* node)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     GPRTemporary result(this);</span>
<span class="udiff-line-added">+     GPRTemporary scratch1(this);</span>
<span class="udiff-line-added">+     GPRTemporary scratch2(this);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     GPRReg resultGPR = result.gpr();</span>
<span class="udiff-line-added">+     GPRReg scratch1GPR = scratch1.gpr();</span>
<span class="udiff-line-added">+     GPRReg scratch2GPR = scratch2.gpr();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     MacroAssembler::JumpList slowCases;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     FrozenValue* structure = m_graph.freezeStrong(node-&gt;structure().get());</span>
<span class="udiff-line-added">+     auto butterfly = TrustedImmPtr(nullptr);</span>
<span class="udiff-line-added">+     if (node-&gt;isInternalPromise())</span>
<span class="udiff-line-added">+         emitAllocateJSObjectWithKnownSize&lt;JSInternalPromise&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowCases, sizeof(JSInternalPromise));</span>
<span class="udiff-line-added">+     else</span>
<span class="udiff-line-added">+         emitAllocateJSObjectWithKnownSize&lt;JSPromise&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowCases, sizeof(JSPromise));</span>
<span class="udiff-line-added">+     m_jit.storeTrustedValue(jsNumber(static_cast&lt;unsigned&gt;(JSPromise::Status::Pending)), CCallHelpers::Address(resultGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(static_cast&lt;unsigned&gt;(JSPromise::Field::Flags))));</span>
<span class="udiff-line-added">+     m_jit.storeTrustedValue(jsUndefined(), CCallHelpers::Address(resultGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(static_cast&lt;unsigned&gt;(JSPromise::Field::ReactionsOrResult))));</span>
<span class="udiff-line-added">+     m_jit.mutatorFence(m_jit.vm());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     addSlowPathGenerator(slowPathCall(slowCases, this, node-&gt;isInternalPromise() ? operationNewInternalPromise : operationNewPromise, resultGPR, TrustedImmPtr(&amp;vm()), TrustedImmPtr(structure)));</span>
  
      cellResult(resultGPR, node);
  }
  
<span class="udiff-line-added">+ template&lt;typename JSClass, typename Operation&gt;</span>
<span class="udiff-line-added">+ void SpeculativeJIT::compileNewInternalFieldObject(Node* node, Operation operation)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     GPRTemporary result(this);</span>
<span class="udiff-line-added">+     GPRTemporary scratch1(this);</span>
<span class="udiff-line-added">+     GPRTemporary scratch2(this);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     GPRReg resultGPR = result.gpr();</span>
<span class="udiff-line-added">+     GPRReg scratch1GPR = scratch1.gpr();</span>
<span class="udiff-line-added">+     GPRReg scratch2GPR = scratch2.gpr();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     MacroAssembler::JumpList slowCases;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     FrozenValue* structure = m_graph.freezeStrong(node-&gt;structure().get());</span>
<span class="udiff-line-added">+     auto butterfly = TrustedImmPtr(nullptr);</span>
<span class="udiff-line-added">+     emitAllocateJSObjectWithKnownSize&lt;JSClass&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowCases, sizeof(JSClass));</span>
<span class="udiff-line-added">+     auto initialValues = JSClass::initialValues();</span>
<span class="udiff-line-added">+     static_assert(initialValues.size() == JSClass::numberOfInternalFields);</span>
<span class="udiff-line-added">+     for (unsigned index = 0; index &lt; initialValues.size(); ++index)</span>
<span class="udiff-line-added">+         m_jit.storeTrustedValue(initialValues[index], CCallHelpers::Address(resultGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index)));</span>
<span class="udiff-line-added">+     m_jit.mutatorFence(m_jit.vm());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     addSlowPathGenerator(slowPathCall(slowCases, this, operation, resultGPR, &amp;vm(), TrustedImmPtr(structure)));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     cellResult(resultGPR, node);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SpeculativeJIT::compileNewGenerator(Node* node)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     compileNewInternalFieldObject&lt;JSGenerator&gt;(node, operationNewGenerator);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SpeculativeJIT::compileNewAsyncGenerator(Node* node)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     compileNewInternalFieldObject&lt;JSAsyncGenerator&gt;(node, operationNewAsyncGenerator);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SpeculativeJIT::compileNewArrayIterator(Node* node)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     compileNewInternalFieldObject&lt;JSArrayIterator&gt;(node, operationNewArrayIterator);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void SpeculativeJIT::compileToPrimitive(Node* node)
  {
      DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
      JSValueOperand argument(this, node-&gt;child1());
      JSValueRegsTemporary result(this, Reuse, argument);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12723,15 +13066,67 @@</span>
      MacroAssembler::Jump notPrimitive = m_jit.branchIfObject(argumentRegs.payloadGPR());
  
      alreadyPrimitive.link(&amp;m_jit);
      m_jit.moveValueRegs(argumentRegs, resultRegs);
  
<span class="udiff-line-modified-removed">-     addSlowPathGenerator(slowPathCall(notPrimitive, this, operationToPrimitive, resultRegs, argumentRegs));</span>
<span class="udiff-line-modified-added">+     addSlowPathGenerator(slowPathCall(notPrimitive, this, operationToPrimitive, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentRegs));</span>
  
      jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
  }
  
<span class="udiff-line-added">+ void SpeculativeJIT::compileToPropertyKey(Node* node)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());</span>
<span class="udiff-line-added">+     JSValueOperand argument(this, node-&gt;child1());</span>
<span class="udiff-line-added">+     JSValueRegsTemporary result(this, Reuse, argument);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     JSValueRegs argumentRegs = argument.jsValueRegs();</span>
<span class="udiff-line-added">+     JSValueRegs resultRegs = result.regs();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     argument.use();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     MacroAssembler::JumpList slowCases;</span>
<span class="udiff-line-added">+     slowCases.append(m_jit.branchIfNotCell(argumentRegs));</span>
<span class="udiff-line-added">+     MacroAssembler::Jump alreadyPropertyKey = m_jit.branchIfSymbol(argumentRegs.payloadGPR());</span>
<span class="udiff-line-added">+     slowCases.append(m_jit.branchIfNotString(argumentRegs.payloadGPR()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     alreadyPropertyKey.link(&amp;m_jit);</span>
<span class="udiff-line-added">+     m_jit.moveValueRegs(argumentRegs, resultRegs);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     addSlowPathGenerator(slowPathCall(slowCases, this, operationToPropertyKey, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentRegs));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     jsValueResult(resultRegs, node, DataFormatJSCell, UseChildrenCalledExplicitly);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SpeculativeJIT::compileToNumeric(Node* node)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());</span>
<span class="udiff-line-added">+     JSValueOperand argument(this, node-&gt;child1());</span>
<span class="udiff-line-added">+     JSValueRegsTemporary result(this);</span>
<span class="udiff-line-added">+     GPRTemporary temp(this);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     JSValueRegs argumentRegs = argument.jsValueRegs();</span>
<span class="udiff-line-added">+     JSValueRegs resultRegs = result.regs();</span>
<span class="udiff-line-added">+     GPRReg scratch = temp.gpr();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     MacroAssembler::JumpList slowCases;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     MacroAssembler::Jump notCell = m_jit.branchIfNotCell(argumentRegs);</span>
<span class="udiff-line-added">+     slowCases.append(m_jit.branchIfNotBigInt(argumentRegs.payloadGPR()));</span>
<span class="udiff-line-added">+     MacroAssembler::Jump isBigInt = m_jit.jump();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     notCell.link(&amp;m_jit);</span>
<span class="udiff-line-added">+     slowCases.append(m_jit.branchIfNotNumber(argumentRegs, scratch));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     isBigInt.link(&amp;m_jit);</span>
<span class="udiff-line-added">+     m_jit.moveValueRegs(argumentRegs, resultRegs);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     addSlowPathGenerator(slowPathCall(slowCases, this, operationToNumeric, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentRegs));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     jsValueResult(resultRegs, node, DataFormatJS);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void SpeculativeJIT::compileLogShadowChickenPrologue(Node* node)
  {
      flushRegisters();
      prepareForExternalCall();
      m_jit.emitStoreCodeOrigin(node-&gt;origin.semantic);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12789,11 +13184,11 @@</span>
      speculateSetObject(node-&gt;child1(), setGPR);
  
      flushRegisters();
      GPRFlushedCallResult result(this);
      GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-     callOperation(operationSetAdd, resultGPR, setGPR, keyRegs, hashGPR);</span>
<span class="udiff-line-modified-added">+     callOperation(operationSetAdd, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), setGPR, keyRegs, hashGPR);</span>
      m_jit.exceptionCheck();
      cellResult(resultGPR, node);
  }
  
  void SpeculativeJIT::compileMapSet(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12811,11 +13206,11 @@</span>
      speculateMapObject(m_jit.graph().varArgChild(node, 0), mapGPR);
  
      flushRegisters();
      GPRFlushedCallResult result(this);
      GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-     callOperation(operationMapSet, resultGPR, mapGPR, keyRegs, valueRegs, hashGPR);</span>
<span class="udiff-line-modified-added">+     callOperation(operationMapSet, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), mapGPR, keyRegs, valueRegs, hashGPR);</span>
      m_jit.exceptionCheck();
      cellResult(resultGPR, node);
  }
  
  void SpeculativeJIT::compileWeakMapGet(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12928,11 +13323,11 @@</span>
  
      speculateWeakSetObject(node-&gt;child1(), setGPR);
      speculateObject(node-&gt;child2(), keyGPR);
  
      flushRegisters();
<span class="udiff-line-modified-removed">-     callOperation(operationWeakSetAdd, setGPR, keyGPR, hashGPR);</span>
<span class="udiff-line-modified-added">+     callOperation(operationWeakSetAdd, &amp;vm(), setGPR, keyGPR, hashGPR);</span>
      m_jit.exceptionCheck();
      noResult(node);
  }
  
  void SpeculativeJIT::compileWeakMapSet(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -12949,11 +13344,11 @@</span>
  
      speculateWeakMapObject(m_jit.graph().varArgChild(node, 0), mapGPR);
      speculateObject(m_jit.graph().varArgChild(node, 1), keyGPR);
  
      flushRegisters();
<span class="udiff-line-modified-removed">-     callOperation(operationWeakMapSet, mapGPR, keyGPR, valueRegs, hashGPR);</span>
<span class="udiff-line-modified-added">+     callOperation(operationWeakMapSet, &amp;vm(), mapGPR, keyGPR, valueRegs, hashGPR);</span>
      m_jit.exceptionCheck();
      noResult(node);
  }
  
  void SpeculativeJIT::compileGetPrototypeOf(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13048,11 +13443,11 @@</span>
          JSValueRegs resultRegs = result.regs();
  
          speculateObject(node-&gt;child1(), valueGPR);
  
          flushRegisters();
<span class="udiff-line-modified-removed">-         callOperation(operationGetPrototypeOfObject, resultRegs, valueGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationGetPrototypeOfObject, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueGPR);</span>
          m_jit.exceptionCheck();
          jsValueResult(resultRegs, node);
          return;
      }
      default: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13061,11 +13456,11 @@</span>
  
          JSValueRegs valueRegs = value.jsValueRegs();
          JSValueRegs resultRegs = result.regs();
  
          flushRegisters();
<span class="udiff-line-modified-removed">-         callOperation(operationGetPrototypeOf, resultRegs, valueRegs);</span>
<span class="udiff-line-modified-added">+         callOperation(operationGetPrototypeOf, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs);</span>
          m_jit.exceptionCheck();
          jsValueResult(resultRegs, node);
          return;
      }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13153,18 +13548,18 @@</span>
      m_jit.move(TrustedImmPtr(nullptr), storageGPR);
  
      MacroAssembler::JumpList slowCases;
      if (shouldConvertLargeSizeToArrayStorage)
          slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)));
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
      else {
          MacroAssembler::Jump lengthIsWithinLimits;
          lengthIsWithinLimits = m_jit.branch32(MacroAssembler::Below, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH));
          m_jit.abortWithReason(UncheckedOverflow);
          lengthIsWithinLimits.link(&amp;m_jit);
      }
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+ #endif // ASSERT_ENABLED</span>
  
      // We can use resultGPR as a scratch right now.
      emitAllocateButterfly(storageGPR, sizeGPR, scratchGPR, scratch2GPR, resultGPR, slowCases);
  
  #if USE(JSVALUE64)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13188,10 +13583,11 @@</span>
  
      m_jit.mutatorFence(vm());
  
      addSlowPathGenerator(makeUnique&lt;CallArrayAllocatorWithVariableSizeSlowPathGenerator&gt;(
          slowCases, this, operationNewArrayWithSize, resultGPR,
<span class="udiff-line-added">+         TrustedImmPtr::weakPointer(m_graph, globalObject),</span>
          structure,
          shouldConvertLargeSizeToArrayStorage ? m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage)) : structure,
          sizeGPR, storageGPR));
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13279,11 +13675,11 @@</span>
          slowCases.append(m_jit.jump());
          break;
      }
      }
  
<span class="udiff-line-modified-removed">-     addSlowPathGenerator(slowPathCall(slowCases, this, operationHasIndexedPropertyByInt, resultGPR, baseGPR, indexGPR, static_cast&lt;int32_t&gt;(node-&gt;internalMethodType())));</span>
<span class="udiff-line-modified-added">+     addSlowPathGenerator(slowPathCall(slowCases, this, operationHasIndexedPropertyByInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, indexGPR, static_cast&lt;int32_t&gt;(node-&gt;internalMethodType())));</span>
  
      unblessedBooleanResult(resultGPR, node);
  }
  
  void SpeculativeJIT::compileGetDirectPname(Node* node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13295,20 +13691,10 @@</span>
      SpeculateCellOperand base(this, baseEdge);
      SpeculateCellOperand property(this, propertyEdge);
      GPRReg baseGPR = base.gpr();
      GPRReg propertyGPR = property.gpr();
  
<span class="udiff-line-removed">- #if CPU(X86)</span>
<span class="udiff-line-removed">-     // Not enough registers on X86 for this code, so always use the slow path.</span>
<span class="udiff-line-removed">-     speculate(node, indexEdge);</span>
<span class="udiff-line-removed">-     flushRegisters();</span>
<span class="udiff-line-removed">-     JSValueRegsFlushedCallResult result(this);</span>
<span class="udiff-line-removed">-     JSValueRegs resultRegs = result.regs();</span>
<span class="udiff-line-removed">-     callOperation(operationGetByValCell, resultRegs, baseGPR, CCallHelpers::CellValue(propertyGPR));</span>
<span class="udiff-line-removed">-     m_jit.exceptionCheck();</span>
<span class="udiff-line-removed">-     jsValueResult(resultRegs, node);</span>
<span class="udiff-line-removed">- #else</span>
      Edge&amp; enumeratorEdge = m_jit.graph().varArgChild(node, 3);
      SpeculateStrictInt32Operand index(this, indexEdge);
      SpeculateCellOperand enumerator(this, enumeratorEdge);
      GPRTemporary scratch(this);
      JSValueRegsTemporary result(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13348,14 +13734,13 @@</span>
      int32_t offsetOfFirstProperty = static_cast&lt;int32_t&gt;(offsetInButterfly(firstOutOfLineOffset)) * sizeof(EncodedJSValue);
      m_jit.loadValue(MacroAssembler::BaseIndex(resultRegs.payloadGPR(), scratchGPR, MacroAssembler::TimesEight, offsetOfFirstProperty), resultRegs);
  
      done.link(&amp;m_jit);
  
<span class="udiff-line-modified-removed">-     addSlowPathGenerator(slowPathCall(slowPath, this, operationGetByValCell, resultRegs, baseGPR, CCallHelpers::CellValue(propertyGPR)));</span>
<span class="udiff-line-modified-added">+     addSlowPathGenerator(slowPathCall(slowPath, this, operationGetByValCell, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, CCallHelpers::CellValue(propertyGPR)));</span>
  
      jsValueResult(resultRegs, node);
<span class="udiff-line-removed">- #endif</span>
  }
  
  void SpeculativeJIT::compileExtractCatchLocal(Node* node)
  {
      JSValueRegsTemporary result(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13438,11 +13823,11 @@</span>
      // Increment the current log entry.
      m_jit.addPtr(TrustedImm32(sizeof(TypeProfilerLog::LogEntry)), scratch1GPR);
      m_jit.storePtr(scratch1GPR, MacroAssembler::Address(scratch2GPR, TypeProfilerLog::currentLogEntryOffset()));
      MacroAssembler::Jump clearLog = m_jit.branchPtr(MacroAssembler::Equal, scratch1GPR, TrustedImmPtr(cachedTypeProfilerLog-&gt;logEndPtr()));
      addSlowPathGenerator(
<span class="udiff-line-modified-removed">-         slowPathCall(clearLog, this, operationProcessTypeProfilerLogDFG, NoResult));</span>
<span class="udiff-line-modified-added">+         slowPathCall(clearLog, this, operationProcessTypeProfilerLogDFG, NoResult, TrustedImmPtr(&amp;vm())));</span>
  
      jumpToEnd.link(&amp;m_jit);
  
      noResult(node);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13467,18 +13852,18 @@</span>
      if (slowPathTarget.isSet())
          slowCases.append(slowPathTarget);
      slowCases.append(gen.slowPathJump());
  
      auto slowPath = slowPathCall(
<span class="udiff-line-modified-removed">-         slowCases, this, gen.slowPathFunction(), NoResult, gen.stubInfo(), valueRegs,</span>
<span class="udiff-line-modified-added">+         slowCases, this, gen.slowPathFunction(), NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), valueRegs,</span>
          CCallHelpers::CellValue(baseGPR), identifierUID(identifierNumber));
  
      m_jit.addPutById(gen, slowPath.get());
      addSlowPathGenerator(WTFMove(slowPath));
  }
  
<span class="udiff-line-modified-removed">- void SpeculativeJIT::nonSpeculativeNonPeepholeCompare(Node* node, MacroAssembler::RelationalCondition cond, S_JITOperation_EJJ helperFunction)</span>
<span class="udiff-line-modified-added">+ void SpeculativeJIT::nonSpeculativeNonPeepholeCompare(Node* node, MacroAssembler::RelationalCondition cond, S_JITOperation_GJJ helperFunction)</span>
  {
      ASSERT(node-&gt;isBinaryUseKind(UntypedUse));
      JSValueOperand arg1(this, node-&gt;child1());
      JSValueOperand arg2(this, node-&gt;child2());
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13493,11 +13878,11 @@</span>
  
          arg1.use();
          arg2.use();
  
          flushRegisters();
<span class="udiff-line-modified-removed">-         callOperation(helperFunction, resultGPR, arg1Regs, arg2Regs);</span>
<span class="udiff-line-modified-added">+         callOperation(helperFunction, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);</span>
          m_jit.exceptionCheck();
  
          unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13514,16 +13899,16 @@</span>
          slowPath.append(m_jit.branchIfNotInt32(arg2Regs));
  
      m_jit.compare32(cond, arg1Regs.payloadGPR(), arg2Regs.payloadGPR(), resultGPR);
  
      if (!isKnownInteger(node-&gt;child1().node()) || !isKnownInteger(node-&gt;child2().node()))
<span class="udiff-line-modified-removed">-         addSlowPathGenerator(slowPathCall(slowPath, this, helperFunction, resultGPR, arg1Regs, arg2Regs));</span>
<span class="udiff-line-modified-added">+         addSlowPathGenerator(slowPathCall(slowPath, this, helperFunction, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs));</span>
  
      unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
  }
  
<span class="udiff-line-modified-removed">- void SpeculativeJIT::nonSpeculativePeepholeBranch(Node* node, Node* branchNode, MacroAssembler::RelationalCondition cond, S_JITOperation_EJJ helperFunction)</span>
<span class="udiff-line-modified-added">+ void SpeculativeJIT::nonSpeculativePeepholeBranch(Node* node, Node* branchNode, MacroAssembler::RelationalCondition cond, S_JITOperation_GJJ helperFunction)</span>
  {
      BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
      BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
  
      JITCompiler::ResultCondition callResultCondition = JITCompiler::NonZero;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13551,11 +13936,11 @@</span>
  
          arg1.use();
          arg2.use();
  
          flushRegisters();
<span class="udiff-line-modified-removed">-         callOperation(helperFunction, resultGPR, arg1Regs, arg2Regs);</span>
<span class="udiff-line-modified-added">+         callOperation(helperFunction, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);</span>
          m_jit.exceptionCheck();
  
          branchTest32(callResultCondition, resultGPR, taken);
      } else {
          GPRTemporary result(this, Reuse, arg2, TagWord);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13575,11 +13960,11 @@</span>
              jump(notTaken, ForceJump);
  
              slowPath.link(&amp;m_jit);
  
              silentSpillAllRegisters(resultGPR);
<span class="udiff-line-modified-removed">-             callOperation(helperFunction, resultGPR, arg1Regs, arg2Regs);</span>
<span class="udiff-line-modified-added">+             callOperation(helperFunction, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);</span>
              silentFillAllRegisters();
              m_jit.exceptionCheck();
  
              branchTest32(callResultCondition, resultGPR, taken);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13615,11 +14000,11 @@</span>
      JITCompiler::Jump done = m_jit.jump();
  
      notEqualCase.link(&amp;m_jit);
  
      silentSpillAllRegisters(resultGPR);
<span class="udiff-line-modified-removed">-     callOperation(operationCompareStrictEqCell, resultGPR, leftGPR, rightGPR);</span>
<span class="udiff-line-modified-added">+     callOperation(operationCompareStrictEqCell, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
      silentFillAllRegisters();
  
      done.link(&amp;m_jit);
  
      unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13691,11 +14076,11 @@</span>
                  m_jit.load32(CCallHelpers::Address(opGPRs[0], JSRopeString::offsetOfLength()), allocatorGPR);
                  done.link(&amp;m_jit);
              }
          }
  
<span class="udiff-line-modified-removed">-         if (!ASSERT_DISABLED) {</span>
<span class="udiff-line-modified-added">+         if (ASSERT_ENABLED) {</span>
              CCallHelpers::Jump ok = m_jit.branch32(
                  CCallHelpers::GreaterThanOrEqual, allocatorGPR, TrustedImm32(0));
              m_jit.abortWithReason(DFGNegativeStringLength);
              ok.link(&amp;m_jit);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13735,11 +14120,11 @@</span>
                  done.link(&amp;m_jit);
              }
          }
      }
  
<span class="udiff-line-modified-removed">-     if (!ASSERT_DISABLED) {</span>
<span class="udiff-line-modified-added">+     if (ASSERT_ENABLED) {</span>
          CCallHelpers::Jump ok = m_jit.branch32(
              CCallHelpers::GreaterThanOrEqual, allocatorGPR, TrustedImm32(0));
          m_jit.abortWithReason(DFGNegativeStringLength);
          ok.link(&amp;m_jit);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13776,15 +14161,15 @@</span>
      m_jit.mutatorFence(vm());
  
      switch (numOpGPRs) {
      case 2:
          addSlowPathGenerator(slowPathCall(
<span class="udiff-line-modified-removed">-             slowPath, this, operationMakeRope2, resultGPR, opGPRs[0], opGPRs[1]));</span>
<span class="udiff-line-modified-added">+             slowPath, this, operationMakeRope2, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), opGPRs[0], opGPRs[1]));</span>
          break;
      case 3:
          addSlowPathGenerator(slowPathCall(
<span class="udiff-line-modified-removed">-             slowPath, this, operationMakeRope3, resultGPR, opGPRs[0], opGPRs[1], opGPRs[2]));</span>
<span class="udiff-line-modified-added">+             slowPath, this, operationMakeRope3, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), opGPRs[0], opGPRs[1], opGPRs[2]));</span>
          break;
      default:
          RELEASE_ASSERT_NOT_REACHED();
          break;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13794,15 +14179,15 @@</span>
      flushRegisters();
      GPRFlushedCallResult result(this);
      GPRReg resultGPR = result.gpr();
      switch (numOpGPRs) {
      case 2:
<span class="udiff-line-modified-removed">-         callOperation(operationMakeRope2, resultGPR, opGPRs[0], opGPRs[1]);</span>
<span class="udiff-line-modified-added">+         callOperation(operationMakeRope2, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), opGPRs[0], opGPRs[1]);</span>
          m_jit.exceptionCheck();
          break;
      case 3:
<span class="udiff-line-modified-removed">-         callOperation(operationMakeRope3, resultGPR, opGPRs[0], opGPRs[1], opGPRs[2]);</span>
<span class="udiff-line-modified-added">+         callOperation(operationMakeRope3, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), opGPRs[0], opGPRs[1], opGPRs[2]);</span>
          m_jit.exceptionCheck();
          break;
      default:
          RELEASE_ASSERT_NOT_REACHED();
          break;
</pre>
<center><a href="DFGSlowPathGenerator.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
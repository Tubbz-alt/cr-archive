<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/CCallHelpers.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(JIT)
 29 
 30 #include &quot;AssemblyHelpers.h&quot;
 31 #include &quot;FPRInfo.h&quot;
 32 #include &quot;GPRInfo.h&quot;
 33 #include &quot;StackAlignment.h&quot;
 34 #include &lt;wtf/FunctionTraits.h&gt;
 35 
 36 namespace JSC {
 37 
 38 #if CPU(MIPS) || (OS(WINDOWS) &amp;&amp; CPU(X86_64))
 39 #define POKE_ARGUMENT_OFFSET 4
 40 #else
 41 #define POKE_ARGUMENT_OFFSET 0
 42 #endif
 43 
 44 class CallFrame;
 45 class Structure;
 46 namespace DFG {
 47 class RegisteredStructure;
 48 };
 49 
 50 class CCallHelpers : public AssemblyHelpers {
 51 public:
 52     CCallHelpers(CodeBlock* codeBlock = 0)
 53         : AssemblyHelpers(codeBlock)
 54     {
 55     }
 56 
 57     // Wrapper to encode JSCell GPR into JSValue.
 58     class CellValue {
 59     public:
 60         explicit CellValue(GPRReg gpr)
 61             : m_gpr(gpr)
 62         {
 63         }
 64 
 65         GPRReg gpr() const { return m_gpr; }
 66 
 67     private:
 68         GPRReg m_gpr;
 69     };
 70 
 71     // The most general helper for setting arguments that fit in a GPR, if you can compute each
 72     // argument without using any argument registers. You usually want one of the setupArguments*()
 73     // methods below instead of this. This thing is most useful if you have *a lot* of arguments.
 74     template&lt;typename Functor&gt;
 75     void setupArgument(unsigned argumentIndex, const Functor&amp; functor)
 76     {
 77         unsigned numberOfRegs = GPRInfo::numberOfArgumentRegisters; // Disguise the constant from clang&#39;s tautological compare warning.
 78         if (argumentIndex &lt; numberOfRegs) {
 79             functor(GPRInfo::toArgumentRegister(argumentIndex));
 80             return;
 81         }
 82 
 83         functor(GPRInfo::nonArgGPR0);
 84         poke(GPRInfo::nonArgGPR0, POKE_ARGUMENT_OFFSET + argumentIndex - GPRInfo::numberOfArgumentRegisters);
 85     }
 86 
 87 private:
 88 
 89     template&lt;unsigned NumberOfRegisters, typename RegType&gt;
 90     ALWAYS_INLINE void setupStubArgs(std::array&lt;RegType, NumberOfRegisters&gt; destinations, std::array&lt;RegType, NumberOfRegisters&gt; sources)
 91     {
 92         if (ASSERT_ENABLED) {
 93             RegisterSet set;
 94             for (RegType dest : destinations)
 95                 set.set(dest);
 96             ASSERT_WITH_MESSAGE(set.numberOfSetRegisters() == NumberOfRegisters, &quot;Destinations should not be aliased.&quot;);
 97         }
 98 
 99         typedef std::pair&lt;RegType, RegType&gt; RegPair;
100         Vector&lt;RegPair, NumberOfRegisters&gt; pairs;
101 
102         for (unsigned i = 0; i &lt; NumberOfRegisters; ++i) {
103             if (sources[i] != destinations[i])
104                 pairs.append(std::make_pair(sources[i], destinations[i]));
105         }
106 
107 #if ASSERT_ENABLED
108         auto numUniqueSources = [&amp;] () -&gt; unsigned {
109             RegisterSet set;
110             for (auto&amp; pair : pairs) {
111                 RegType source = pair.first;
112                 set.set(source);
113             }
114             return set.numberOfSetRegisters();
115         };
116 
117         auto numUniqueDests = [&amp;] () -&gt; unsigned {
118             RegisterSet set;
119             for (auto&amp; pair : pairs) {
120                 RegType dest = pair.second;
121                 set.set(dest);
122             }
123             return set.numberOfSetRegisters();
124         };
125 #endif
126 
127         while (pairs.size()) {
128             RegisterSet freeDestinations;
129             for (auto&amp; pair : pairs) {
130                 RegType dest = pair.second;
131                 freeDestinations.set(dest);
132             }
133             for (auto&amp; pair : pairs) {
134                 RegType source = pair.first;
135                 freeDestinations.clear(source);
136             }
137 
138             if (freeDestinations.numberOfSetRegisters()) {
139                 bool madeMove = false;
140                 for (unsigned i = 0; i &lt; pairs.size(); i++) {
141                     auto&amp; pair = pairs[i];
142                     RegType source = pair.first;
143                     RegType dest = pair.second;
144                     if (freeDestinations.get(dest)) {
145                         move(source, dest);
146                         pairs.remove(i);
147                         madeMove = true;
148                         break;
149                     }
150                 }
151                 ASSERT_UNUSED(madeMove, madeMove);
152                 continue;
153             }
154 
155             ASSERT(numUniqueDests() == numUniqueSources());
156             ASSERT(numUniqueDests() == pairs.size());
157             // The set of source and destination registers are equivalent sets. This means we don&#39;t have
158             // any free destination registers that won&#39;t also clobber a source. We get around this by
159             // exchanging registers.
160 
161             RegType source = pairs[0].first;
162             RegType dest = pairs[0].second;
163             swap(source, dest);
164             pairs.remove(0);
165 
166             RegType newSource = source;
167             for (auto&amp; pair : pairs) {
168                 RegType source = pair.first;
169                 if (source == dest) {
170                     pair.first = newSource;
171                     break;
172                 }
173             }
174 
175             // We may have introduced pairs that have the same source and destination. Remove those now.
176             for (unsigned i = 0; i &lt; pairs.size(); i++) {
177                 auto&amp; pair = pairs[i];
178                 if (pair.first == pair.second) {
179                     pairs.remove(i);
180                     i--;
181                 }
182             }
183         }
184     }
185 
186 #if CPU(MIPS) || (CPU(ARM_THUMB2) &amp;&amp; !CPU(ARM_HARDFP))
187     template&lt;unsigned NumCrossSources, unsigned NumberOfRegisters&gt;
188     ALWAYS_INLINE void setupStubCrossArgs(std::array&lt;GPRReg, NumberOfRegisters&gt; destinations, std::array&lt;FPRReg, NumberOfRegisters&gt; sources) {
189         for (unsigned i = 0; i &lt; NumCrossSources; i++) {
190             GPRReg dest = destinations[i];
191             FPRReg source = sources[i];
192 
193             moveDouble(source, dest);
194         }
195     }
196 #endif
197 
198     template&lt;typename RegType&gt;
199     using InfoTypeForReg = decltype(toInfoFromReg(RegType(-1)));
200 
201     // extraGPRArgs is used to track 64-bit argument types passed in register on 32-bit architectures.
202     // extraPoke is used to track 64-bit argument types passed on the stack.
203     template&lt;unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke&gt;
204     struct ArgCollection {
205         ArgCollection()
206         {
207             gprSources.fill(InvalidGPRReg);
208             gprDestinations.fill(InvalidGPRReg);
209             fprSources.fill(InvalidFPRReg);
210             fprDestinations.fill(InvalidFPRReg);
211             crossSources.fill(InvalidFPRReg);
212             crossDestinations.fill(InvalidGPRReg);
213         }
214 
215         template&lt;unsigned a, unsigned b, unsigned c, unsigned d, unsigned e, unsigned f, unsigned g&gt;
216         ArgCollection(ArgCollection&lt;a, b, c, d, e, f, g&gt;&amp; other)
217         {
218             gprSources = other.gprSources;
219             gprDestinations = other.gprDestinations;
220             fprSources = other.fprSources;
221             fprDestinations = other.fprDestinations;
222             crossSources = other.crossSources;
223             crossDestinations = other.crossDestinations;
224         }
225 
226         ArgCollection&lt;numGPRArgs + 1, numGPRSources + 1, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; pushRegArg(GPRReg argument, GPRReg destination)
227         {
228             ArgCollection&lt;numGPRArgs + 1, numGPRSources + 1, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; result(*this);
229 
230             result.gprSources[numGPRSources] = argument;
231             result.gprDestinations[numGPRSources] = destination;
232             return result;
233         }
234 
235         ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs + 1, numFPRSources + 1, numCrossSources, extraGPRArgs, extraPoke&gt; pushRegArg(FPRReg argument, FPRReg destination)
236         {
237             ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs + 1, numFPRSources + 1, numCrossSources, extraGPRArgs, extraPoke&gt; result(*this);
238 
239             result.fprSources[numFPRSources] = argument;
240             result.fprDestinations[numFPRSources] = destination;
241             return result;
242         }
243 
244         ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs + 1, numFPRSources, numCrossSources + 1, extraGPRArgs, extraPoke&gt; pushRegArg(FPRReg argument, GPRReg destination)
245         {
246             ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs + 1, numFPRSources, numCrossSources + 1, extraGPRArgs, extraPoke&gt; result(*this);
247 
248             result.crossSources[numCrossSources] = argument;
249             result.crossDestinations[numCrossSources] = destination;
250             return result;
251         }
252 
253         ArgCollection&lt;numGPRArgs, numGPRSources + 1, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs + 1, extraPoke&gt; pushExtraRegArg(GPRReg argument, GPRReg destination)
254         {
255             ArgCollection&lt;numGPRArgs, numGPRSources + 1, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs + 1, extraPoke&gt; result(*this);
256 
257             result.gprSources[numGPRSources] = argument;
258             result.gprDestinations[numGPRSources] = destination;
259             return result;
260         }
261 
262         ArgCollection&lt;numGPRArgs + 1, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; addGPRArg()
263         {
264             return ArgCollection&lt;numGPRArgs + 1, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt;(*this);
265         }
266 
267         ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs + 1, extraPoke&gt; addGPRExtraArg()
268         {
269             return ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs + 1, extraPoke&gt;(*this);
270         }
271 
272         ArgCollection&lt;numGPRArgs + 1, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; addStackArg(GPRReg)
273         {
274             return ArgCollection&lt;numGPRArgs + 1, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt;(*this);
275         }
276 
277         ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs + 1, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; addStackArg(FPRReg)
278         {
279             return ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs + 1, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt;(*this);
280         }
281 
282         ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke + 1&gt; addPoke()
283         {
284             return ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke + 1&gt;(*this);
285         }
286 
287 #if OS(WINDOWS) &amp;&amp; CPU(X86_64)
288         unsigned argCount(GPRReg) { return numGPRArgs + numFPRArgs; }
289         unsigned argCount(FPRReg) { return numGPRArgs + numFPRArgs; }
290 #else
291         unsigned argCount(GPRReg) { return numGPRArgs + extraGPRArgs; }
292         unsigned argCount(FPRReg) { return numFPRArgs; }
293 #endif
294 
295         // store GPR -&gt; GPR assignments
296         std::array&lt;GPRReg, GPRInfo::numberOfRegisters&gt; gprSources;
297         std::array&lt;GPRReg, GPRInfo::numberOfRegisters&gt; gprDestinations;
298 
299         // store FPR -&gt; FPR assignments
300         std::array&lt;FPRReg, FPRInfo::numberOfRegisters&gt; fprSources;
301         std::array&lt;FPRReg, FPRInfo::numberOfRegisters&gt; fprDestinations;
302 
303         // store FPR -&gt; GPR assignments
304         std::array&lt;FPRReg, GPRInfo::numberOfRegisters&gt; crossSources;
305         std::array&lt;GPRReg, GPRInfo::numberOfRegisters&gt; crossDestinations;
306     };
307 
308     template&lt;unsigned TargetSize, typename RegType&gt;
309     std::array&lt;RegType, TargetSize&gt; clampArrayToSize(std::array&lt;RegType, InfoTypeForReg&lt;RegType&gt;::numberOfRegisters&gt; sourceArray)
310     {
311         static_assert(TargetSize &lt;= sourceArray.size(), &quot;TargetSize is bigger than source.size()&quot;);
312         RELEASE_ASSERT(TargetSize &lt;= InfoTypeForReg&lt;RegType&gt;::numberOfRegisters);
313 
314         std::array&lt;RegType, TargetSize&gt; result { };
315 
316         for (unsigned i = 0; i &lt; TargetSize; i++) {
317             ASSERT(sourceArray[i] != static_cast&lt;int32_t&gt;(InfoTypeForReg&lt;RegType&gt;::InvalidIndex));
318             result[i] = sourceArray[i];
319         }
320 
321         return result;
322     }
323 
324     ALWAYS_INLINE unsigned calculatePokeOffset(unsigned currentGPRArgument, unsigned currentFPRArgument, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke)
325     {
326         // Clang claims that it cannot find the symbol for FPRReg/GPRReg::numberOfArgumentRegisters when they are passed directly to std::max... seems like a bug
327         unsigned numberOfFPArgumentRegisters = FPRInfo::numberOfArgumentRegisters;
328         unsigned numberOfGPArgumentRegisters = GPRInfo::numberOfArgumentRegisters;
329 
330         currentGPRArgument += extraGPRArgs;
331         currentFPRArgument -= numCrossSources;
332         IGNORE_WARNINGS_BEGIN(&quot;type-limits&quot;)
333         ASSERT(currentGPRArgument &gt;= GPRInfo::numberOfArgumentRegisters || currentFPRArgument &gt;= FPRInfo::numberOfArgumentRegisters);
334         IGNORE_WARNINGS_END
335 
336         unsigned pokeOffset = POKE_ARGUMENT_OFFSET + extraPoke;
337         pokeOffset += std::max(currentGPRArgument, numberOfGPArgumentRegisters) - numberOfGPArgumentRegisters;
338         pokeOffset += std::max(currentFPRArgument, numberOfFPArgumentRegisters) - numberOfFPArgumentRegisters;
339         return pokeOffset;
340     }
341 
342     template&lt;typename ArgType&gt;
343     ALWAYS_INLINE void pokeForArgument(ArgType arg, unsigned currentGPRArgument, unsigned currentFPRArgument, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke)
344     {
345         unsigned pokeOffset = calculatePokeOffset(currentGPRArgument, currentFPRArgument, numCrossSources, extraGPRArgs, extraPoke);
346         poke(arg, pokeOffset);
347     }
348 
349     ALWAYS_INLINE bool stackAligned(unsigned currentGPRArgument, unsigned currentFPRArgument, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke)
350     {
351         unsigned pokeOffset = calculatePokeOffset(currentGPRArgument, currentFPRArgument, numCrossSources, extraGPRArgs, extraPoke);
352         return !(pokeOffset &amp; 1);
353     }
354 
355     // In the auto-calling convention code below the order of operations is:
356     //    1) spill arguments to stack slots
357     //    2) shuffle incomming argument values in registers to argument registers
358     //    3) fill immediate values to argument registers
359     // To do this, we recurse forwards through our args collecting argument values in registers and spilling stack slots.
360     // when we run out of args we then run our shuffling code to relocate registers. Finally, as we unwind from our
361     // recursion we can fill immediates.
362 
363 #define CURRENT_ARGUMENT_TYPE typename FunctionTraits&lt;OperationType&gt;::template ArgumentType&lt;numGPRArgs + numFPRArgs&gt;
364 #define RESULT_TYPE typename FunctionTraits&lt;OperationType&gt;::ResultType
365 
366 #if USE(JSVALUE64)
367 
368     // Avoid MSVC optimization time explosion associated with __forceinline in recursive templates.
369     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename RegType, typename... Args&gt;
370     ALWAYS_INLINE_EXCEPT_MSVC void marshallArgumentRegister(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, RegType arg, Args... args)
371     {
372         using InfoType = InfoTypeForReg&lt;RegType&gt;;
373         unsigned numArgRegisters = InfoType::numberOfArgumentRegisters;
374 #if OS(WINDOWS) &amp;&amp; CPU(X86_64)
375         unsigned currentArgCount = argSourceRegs.argCount(arg) + (std::is_same&lt;RESULT_TYPE, SlowPathReturnType&gt;::value ? 1 : 0);
376 #else
377         unsigned currentArgCount = argSourceRegs.argCount(arg);
378 #endif
379         if (currentArgCount &lt; numArgRegisters) {
380             auto updatedArgSourceRegs = argSourceRegs.pushRegArg(arg, InfoType::toArgumentRegister(currentArgCount));
381             setupArgumentsImpl&lt;OperationType&gt;(updatedArgSourceRegs, args...);
382             return;
383         }
384 
385         pokeForArgument(arg, numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke);
386         setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs.addStackArg(arg), args...);
387     }
388 
389     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;
390     ALWAYS_INLINE void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, FPRReg arg, Args... args)
391     {
392         static_assert(std::is_same&lt;CURRENT_ARGUMENT_TYPE, double&gt;::value, &quot;We should only be passing FPRRegs to a double&quot;);
393         marshallArgumentRegister&lt;OperationType&gt;(argSourceRegs, arg, args...);
394     }
395 
396     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;
397     ALWAYS_INLINE void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, GPRReg arg, Args... args)
398     {
399         marshallArgumentRegister&lt;OperationType&gt;(argSourceRegs, arg, args...);
400     }
401 
402     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;
403     ALWAYS_INLINE void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, JSValueRegs arg, Args... args)
404     {
405         marshallArgumentRegister&lt;OperationType&gt;(argSourceRegs, arg.gpr(), args...);
406     }
407 
408     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;
409     ALWAYS_INLINE void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, CellValue arg, Args... args)
410     {
411         marshallArgumentRegister&lt;OperationType&gt;(argSourceRegs, arg.gpr(), args...);
412     }
413 
414 #else // USE(JSVALUE64)
415 #if CPU(ARM_THUMB2) || CPU(MIPS)
416 
417     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;
418     void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, FPRReg arg, Args... args)
419     {
420         static_assert(std::is_same&lt;CURRENT_ARGUMENT_TYPE, double&gt;::value, &quot;We should only be passing FPRRegs to a double&quot;);
421 
422         // MIPS and ARM-hardfp pass FP arguments in FP registers.
423 #if CPU(MIPS)
424         unsigned numberOfFPArgumentRegisters = FPRInfo::numberOfArgumentRegisters;
425         unsigned currentFPArgCount = argSourceRegs.argCount(arg);
426 
427         // MIPS can only use FP argument registers if it isn&#39;t preceeded by any GP argument.
428         if (currentFPArgCount &lt; numberOfFPArgumentRegisters &amp;&amp; !numGPRArgs) {
429             auto updatedArgSourceRegs = argSourceRegs.pushRegArg(arg, FPRInfo::toArgumentRegister(currentFPArgCount));
430             setupArgumentsImpl&lt;OperationType&gt;(updatedArgSourceRegs.addGPRExtraArg().addGPRExtraArg(), args...);
431             return;
432         }
433 #elif CPU(ARM_THUMB2) &amp;&amp; CPU(ARM_HARDFP)
434         unsigned numberOfFPArgumentRegisters = FPRInfo::numberOfArgumentRegisters;
435         unsigned currentFPArgCount = argSourceRegs.argCount(arg);
436 
437         if (currentFPArgCount &lt; numberOfFPArgumentRegisters) {
438             auto updatedArgSourceRegs = argSourceRegs.pushRegArg(arg, FPRInfo::toArgumentRegister(currentFPArgCount));
439             setupArgumentsImpl&lt;OperationType&gt;(updatedArgSourceRegs, args...);
440             return;
441         }
442 #endif
443 
444 #if CPU(MIPS) || (CPU(ARM_THUMB2) &amp;&amp; !CPU(ARM_HARDFP))
445         // On MIPS and ARM-softfp FP arguments can be passed in GP registers.
446         unsigned numberOfGPArgumentRegisters = GPRInfo::numberOfArgumentRegisters;
447         unsigned currentGPArgCount = argSourceRegs.argCount(GPRInfo::regT0);
448         unsigned alignedGPArgCount = roundUpToMultipleOf&lt;2&gt;(currentGPArgCount);
449 
450         if (alignedGPArgCount + 1 &lt; numberOfGPArgumentRegisters) {
451             auto updatedArgSourceRegs = argSourceRegs.pushRegArg(arg, GPRInfo::toArgumentRegister(alignedGPArgCount));
452 
453             if (alignedGPArgCount &gt; currentGPArgCount)
454                 setupArgumentsImpl&lt;OperationType&gt;(updatedArgSourceRegs.addGPRExtraArg().addGPRExtraArg().addGPRExtraArg(), args...);
455             else
456                 setupArgumentsImpl&lt;OperationType&gt;(updatedArgSourceRegs.addGPRExtraArg().addGPRExtraArg(), args...);
457 
458             return;
459         }
460 
461         if (currentGPArgCount &lt; numberOfGPArgumentRegisters) {
462             pokeForArgument(arg, numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs + 1, extraPoke);
463             setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs.addGPRExtraArg().addStackArg(arg).addPoke(), args...);
464             return;
465         }
466 #endif
467 
468         // Otherwise pass FP argument on stack.
469         if (stackAligned(numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke)) {
470             pokeForArgument(arg, numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke);
471             setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs.addStackArg(arg).addPoke(), args...);
472         } else {
473             pokeForArgument(arg, numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke + 1);
474             setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs.addStackArg(arg).addPoke().addPoke(), args...);
475         }
476     }
477 
478     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;
479     std::enable_if_t&lt;sizeof(CURRENT_ARGUMENT_TYPE) &lt;= 4&gt;
480     setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, GPRReg arg, Args... args)
481     {
482         unsigned numArgRegisters = GPRInfo::numberOfArgumentRegisters;
483         unsigned currentArgCount = argSourceRegs.argCount(arg);
484         if (currentArgCount &lt; numArgRegisters) {
485             auto updatedArgSourceRegs = argSourceRegs.pushRegArg(arg, GPRInfo::toArgumentRegister(currentArgCount));
486             setupArgumentsImpl&lt;OperationType&gt;(updatedArgSourceRegs, args...);
487             return;
488         }
489 
490         pokeForArgument(arg, numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke);
491         setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs.addStackArg(arg), args...);
492     }
493 
494     template&lt;typename OperationType, typename Arg1, typename Arg2, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;
495     void pokeArgumentsAligned(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, Arg1 arg1, Arg2 arg2, Args... args)
496     {
497         unsigned numArgRegisters = GPRInfo::numberOfArgumentRegisters;
498         unsigned currentArgCount = argSourceRegs.argCount(GPRInfo::regT0);
499 
500         if (currentArgCount + 1 == numArgRegisters) {
501             pokeForArgument(arg1, numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs + 1, extraPoke);
502             pokeForArgument(arg2, numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs + 1, extraPoke + 1);
503             setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs.addGPRExtraArg().addGPRArg().addPoke(), args...);
504         } else if (stackAligned(numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke)) {
505             pokeForArgument(arg1, numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke);
506             pokeForArgument(arg2, numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke + 1);
507             setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs.addGPRArg().addPoke(), args...);
508         } else {
509             pokeForArgument(arg1, numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke + 1);
510             pokeForArgument(arg2, numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke + 2);
511             setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs.addGPRArg().addPoke().addPoke(), args...);
512         }
513     }
514 
515     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;
516     std::enable_if_t&lt;std::is_same&lt;CURRENT_ARGUMENT_TYPE, EncodedJSValue&gt;::value&gt;
517     setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, CellValue payload, Args... args)
518     {
519         unsigned numArgRegisters = GPRInfo::numberOfArgumentRegisters;
520         unsigned currentArgCount = argSourceRegs.argCount(payload.gpr());
521         unsigned alignedArgCount = roundUpToMultipleOf&lt;2&gt;(currentArgCount);
522 
523         if (alignedArgCount + 1 &lt; numArgRegisters) {
524             auto updatedArgSourceRegs = argSourceRegs.pushRegArg(payload.gpr(), GPRInfo::toArgumentRegister(alignedArgCount));
525 
526             if (alignedArgCount &gt; currentArgCount)
527                 setupArgumentsImpl&lt;OperationType&gt;(updatedArgSourceRegs.addGPRExtraArg().addGPRExtraArg(), args...);
528             else
529                 setupArgumentsImpl&lt;OperationType&gt;(updatedArgSourceRegs.addGPRExtraArg(), args...);
530 
531             move(TrustedImm32(JSValue::CellTag), GPRInfo::toArgumentRegister(alignedArgCount + 1));
532 
533         } else
534             pokeArgumentsAligned&lt;OperationType&gt;(argSourceRegs, payload.gpr(), TrustedImm32(JSValue::CellTag), args...);
535     }
536 
537     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;
538     std::enable_if_t&lt;std::is_same&lt;CURRENT_ARGUMENT_TYPE, EncodedJSValue&gt;::value&gt;
539     setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, JSValueRegs arg, Args... args)
540     {
541         unsigned numArgRegisters = GPRInfo::numberOfArgumentRegisters;
542         unsigned currentArgCount = argSourceRegs.argCount(arg.tagGPR());
543         unsigned alignedArgCount = roundUpToMultipleOf&lt;2&gt;(currentArgCount);
544 
545         if (alignedArgCount + 1 &lt; numArgRegisters) {
546             // JSValueRegs is passed in two 32-bit registers on these architectures. Increase both numGPRArgs and extraGPRArgs by 1.
547             // We can&#39;t just add 2 to numGPRArgs, since it is used for CURRENT_ARGUMENT_TYPE. Adding 2 would lead to a skipped argument.
548             auto updatedArgSourceRegs1 = argSourceRegs.pushRegArg(arg.payloadGPR(), GPRInfo::toArgumentRegister(alignedArgCount));
549             auto updatedArgSourceRegs2 = updatedArgSourceRegs1.pushExtraRegArg(arg.tagGPR(), GPRInfo::toArgumentRegister(alignedArgCount + 1));
550 
551             if (alignedArgCount &gt; currentArgCount)
552                 setupArgumentsImpl&lt;OperationType&gt;(updatedArgSourceRegs2.addGPRExtraArg(), args...);
553             else
554                 setupArgumentsImpl&lt;OperationType&gt;(updatedArgSourceRegs2, args...);
555         } else
556             pokeArgumentsAligned&lt;OperationType&gt;(argSourceRegs, arg.payloadGPR(), arg.tagGPR(), args...);
557     }
558 
559 #endif // CPU(ARM_THUMB2) || CPU(MIPS)
560 #endif // USE(JSVALUE64)
561 
562     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename Arg, typename... Args&gt;
563     ALWAYS_INLINE std::enable_if_t&lt;
564         std::is_base_of&lt;TrustedImm, Arg&gt;::value
565         || std::is_convertible&lt;Arg, TrustedImm&gt;::value&gt; // We have this since DFGSpeculativeJIT has it&#39;s own implementation of TrustedImmPtr
566     setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, Arg arg, Args... args)
567     {
568         // Right now this only supports non-floating point immediate arguments since we never call operations with non-register values.
569         // If we ever needed to support immediate floating point arguments we would need to duplicate this logic for both types, which sounds
570         // gross so it&#39;s probably better to do that marshalling before the call operation...
571         static_assert(!std::is_floating_point&lt;CURRENT_ARGUMENT_TYPE&gt;::value, &quot;We don&#39;t support immediate floats/doubles in setupArguments&quot;);
572         auto numArgRegisters = GPRInfo::numberOfArgumentRegisters;
573 #if OS(WINDOWS) &amp;&amp; CPU(X86_64)
574         auto currentArgCount = numGPRArgs + numFPRArgs + (std::is_same&lt;RESULT_TYPE, SlowPathReturnType&gt;::value ? 1 : 0);
575 #else
576         auto currentArgCount = numGPRArgs + extraGPRArgs;
577 #endif
578         if (currentArgCount &lt; numArgRegisters) {
579             setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs.addGPRArg(), args...);
580             move(arg, GPRInfo::toArgumentRegister(currentArgCount));
581             return;
582         }
583 
584         pokeForArgument(arg, numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke);
585         setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs.addGPRArg(), args...);
586     }
587 
588     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename Arg, typename... Args&gt;
589     ALWAYS_INLINE std::enable_if_t&lt;
590         std::is_same&lt;CURRENT_ARGUMENT_TYPE, Arg&gt;::value
591         &amp;&amp; std::is_integral&lt;CURRENT_ARGUMENT_TYPE&gt;::value
592         &amp;&amp; (sizeof(CURRENT_ARGUMENT_TYPE) &lt;= 4)&gt;
593     setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, Arg arg, Args... args)
594     {
595         setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs, TrustedImm32(arg), args...);
596     }
597 
598     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename Arg, typename... Args&gt;
599     ALWAYS_INLINE std::enable_if_t&lt;
600         std::is_same&lt;CURRENT_ARGUMENT_TYPE, Arg&gt;::value
601         &amp;&amp; std::is_integral&lt;CURRENT_ARGUMENT_TYPE&gt;::value
602         &amp;&amp; (sizeof(CURRENT_ARGUMENT_TYPE) == 8)&gt;
603     setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, Arg arg, Args... args)
604     {
605         setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs, TrustedImm64(arg), args...);
606     }
607 
608     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename Arg, typename... Args&gt;
609     ALWAYS_INLINE std::enable_if_t&lt;
610         std::is_pointer&lt;CURRENT_ARGUMENT_TYPE&gt;::value
611         &amp;&amp; ((std::is_pointer&lt;Arg&gt;::value &amp;&amp; std::is_convertible&lt;std::remove_const_t&lt;std::remove_pointer_t&lt;Arg&gt;&gt;*, CURRENT_ARGUMENT_TYPE&gt;::value)
612             || std::is_same&lt;Arg, std::nullptr_t&gt;::value)&gt;
613     setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, Arg arg, Args... args)
614     {
615         setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs, TrustedImmPtr(arg), args...);
616     }
617 
618     // Special case DFG::RegisteredStructure because it&#39;s really annoying to deal with otherwise...
619     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename Arg, typename... Args&gt;
620     ALWAYS_INLINE std::enable_if_t&lt;
621         std::is_same&lt;CURRENT_ARGUMENT_TYPE, Structure*&gt;::value
622         &amp;&amp; std::is_same&lt;Arg, DFG::RegisteredStructure&gt;::value&gt;
623     setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, Arg arg, Args... args)
624     {
625         setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs, TrustedImmPtr(arg.get()), args...);
626     }
627 
628 #undef CURRENT_ARGUMENT_TYPE
629 #undef RESULT_TYPE
630 
631     // Base case; set up the argument registers.
632     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke&gt;
633     ALWAYS_INLINE void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs)
634     {
635         static_assert(FunctionTraits&lt;OperationType&gt;::arity == numGPRArgs + numFPRArgs, &quot;One last sanity check&quot;);
636 #if USE(JSVALUE64)
637         static_assert(FunctionTraits&lt;OperationType&gt;::cCallArity() == numGPRArgs + numFPRArgs + extraPoke, &quot;Check the CCall arity&quot;);
638 #endif
639         setupStubArgs&lt;numGPRSources, GPRReg&gt;(clampArrayToSize&lt;numGPRSources, GPRReg&gt;(argSourceRegs.gprDestinations), clampArrayToSize&lt;numGPRSources, GPRReg&gt;(argSourceRegs.gprSources));
640 #if CPU(MIPS) || (CPU(ARM_THUMB2) &amp;&amp; !CPU(ARM_HARDFP))
641         setupStubCrossArgs&lt;numCrossSources&gt;(argSourceRegs.crossDestinations, argSourceRegs.crossSources);
642 #else
643         static_assert(!numCrossSources, &quot;shouldn&#39;t be used on this architecture.&quot;);
644 #endif
645         setupStubArgs&lt;numFPRSources, FPRReg&gt;(clampArrayToSize&lt;numFPRSources, FPRReg&gt;(argSourceRegs.fprDestinations), clampArrayToSize&lt;numFPRSources, FPRReg&gt;(argSourceRegs.fprSources));
646     }
647 
648 public:
649 
650 #define FIRST_ARGUMENT_TYPE typename FunctionTraits&lt;OperationType&gt;::template ArgumentType&lt;0&gt;
651 
652     template&lt;typename OperationType, typename... Args&gt;
653     ALWAYS_INLINE std::enable_if_t&lt;std::is_same&lt;FIRST_ARGUMENT_TYPE, CallFrame*&gt;::value&gt; setupArguments(Args... args)
654     {
655 #if USE(JSVALUE64)
656         // This only really works for 64-bit since jsvalue regs mess things up for 32-bit...
657         static_assert(FunctionTraits&lt;OperationType&gt;::cCallArity() == sizeof...(Args) + 1, &quot;Basic sanity check&quot;);
658 #endif
659         setupArgumentsImpl&lt;OperationType, 0, 0, 0, 0, 0, 0, 0&gt;(ArgCollection&lt;0, 0, 0, 0, 0, 0, 0&gt;(), GPRInfo::callFrameRegister, args...);
660     }
661 
662     template&lt;typename OperationType, typename... Args&gt;
663     ALWAYS_INLINE std::enable_if_t&lt;!std::is_same&lt;FIRST_ARGUMENT_TYPE, CallFrame*&gt;::value&gt; setupArguments(Args... args)
664     {
665 #if USE(JSVALUE64)
666         // This only really works for 64-bit since jsvalue regs mess things up for 32-bit...
667         static_assert(FunctionTraits&lt;OperationType&gt;::cCallArity() == sizeof...(Args), &quot;Basic sanity check&quot;);
668 #endif
669         setupArgumentsImpl&lt;OperationType, 0, 0, 0, 0, 0, 0, 0&gt;(ArgCollection&lt;0, 0, 0, 0, 0, 0, 0&gt;(), args...);
670     }
671 
672 #undef FIRST_ARGUMENT_TYPE
673 
674     void setupResults(GPRReg destA, GPRReg destB)
675     {
676         GPRReg srcA = GPRInfo::returnValueGPR;
677         GPRReg srcB = GPRInfo::returnValueGPR2;
678 
679         if (destA == InvalidGPRReg)
680             move(srcB, destB);
681         else if (destB == InvalidGPRReg)
682             move(srcA, destA);
683         else if (srcB != destA) {
684             // Handle the easy cases - two simple moves.
685             move(srcA, destA);
686             move(srcB, destB);
687         } else if (srcA != destB) {
688             // Handle the non-swap case - just put srcB in place first.
689             move(srcB, destB);
690             move(srcA, destA);
691         } else
692             swap(destA, destB);
693     }
694 
695     void setupResults(JSValueRegs regs)
696     {
697 #if USE(JSVALUE64)
698         move(GPRInfo::returnValueGPR, regs.gpr());
699 #else
700         setupResults(regs.payloadGPR(), regs.tagGPR());
701 #endif
702     }
703 
704     void jumpToExceptionHandler(VM&amp; vm)
705     {
706         // genericUnwind() leaves the handler CallFrame* in vm-&gt;callFrameForCatch,
707         // and the address of the handler in vm-&gt;targetMachinePCForThrow.
708         loadPtr(&amp;vm.targetMachinePCForThrow, GPRInfo::regT1);
709         farJump(GPRInfo::regT1, ExceptionHandlerPtrTag);
710     }
711 
712     void prepareForTailCallSlow(GPRReg calleeGPR = InvalidGPRReg)
713     {
714         GPRReg temp1 = calleeGPR == GPRInfo::regT0 ? GPRInfo::regT3 : GPRInfo::regT0;
715         GPRReg temp2 = calleeGPR == GPRInfo::regT1 ? GPRInfo::regT3 : GPRInfo::regT1;
716         GPRReg temp3 = calleeGPR == GPRInfo::regT2 ? GPRInfo::regT3 : GPRInfo::regT2;
717 
718         GPRReg newFramePointer = temp1;
719         GPRReg newFrameSizeGPR = temp2;
720         {
721             // The old frame size is its number of arguments (or number of
722             // parameters in case of arity fixup), plus the frame header size,
723             // aligned
724             GPRReg oldFrameSizeGPR = temp2;
725             {
726                 GPRReg argCountGPR = oldFrameSizeGPR;
727                 load32(Address(framePointerRegister, CallFrameSlot::argumentCountIncludingThis * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset), argCountGPR);
728 
729                 {
730                     GPRReg numParametersGPR = temp1;
731                     {
732                         GPRReg codeBlockGPR = numParametersGPR;
733                         loadPtr(Address(framePointerRegister, CallFrameSlot::codeBlock * static_cast&lt;int&gt;(sizeof(Register))), codeBlockGPR);
734                         load32(Address(codeBlockGPR, CodeBlock::offsetOfNumParameters()), numParametersGPR);
735                     }
736 
737                     ASSERT(numParametersGPR != argCountGPR);
738                     Jump argumentCountWasNotFixedUp = branch32(BelowOrEqual, numParametersGPR, argCountGPR);
739                     move(numParametersGPR, argCountGPR);
740                     argumentCountWasNotFixedUp.link(this);
741                 }
742 
743                 add32(TrustedImm32(stackAlignmentRegisters() + CallFrame::headerSizeInRegisters - 1), argCountGPR, oldFrameSizeGPR);
744                 and32(TrustedImm32(-stackAlignmentRegisters()), oldFrameSizeGPR);
745                 // We assume &lt; 2^28 arguments
746                 mul32(TrustedImm32(sizeof(Register)), oldFrameSizeGPR, oldFrameSizeGPR);
747             }
748 
749             // The new frame pointer is at framePointer + oldFrameSize - newFrameSize
750             ASSERT(newFramePointer != oldFrameSizeGPR);
751             addPtr(framePointerRegister, oldFrameSizeGPR, newFramePointer);
752 
753             // The new frame size is just the number of arguments plus the
754             // frame header size, aligned
755             ASSERT(newFrameSizeGPR != newFramePointer);
756             load32(Address(stackPointerRegister, CallFrameSlot::argumentCountIncludingThis * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset - sizeof(CallerFrameAndPC)),
757                 newFrameSizeGPR);
758             add32(TrustedImm32(stackAlignmentRegisters() + CallFrame::headerSizeInRegisters - 1), newFrameSizeGPR);
759             and32(TrustedImm32(-stackAlignmentRegisters()), newFrameSizeGPR);
760             // We assume &lt; 2^28 arguments
761             mul32(TrustedImm32(sizeof(Register)), newFrameSizeGPR, newFrameSizeGPR);
762         }
763 
764         GPRReg tempGPR = temp3;
765         ASSERT(tempGPR != newFramePointer &amp;&amp; tempGPR != newFrameSizeGPR);
766 
767         // We don&#39;t need the current frame beyond this point. Masquerade as our
768         // caller.
769 #if CPU(ARM_THUMB2) || CPU(ARM64)
770         loadPtr(Address(framePointerRegister, CallFrame::returnPCOffset()), linkRegister);
771         subPtr(TrustedImm32(2 * sizeof(void*)), newFrameSizeGPR);
772 #if CPU(ARM64E)
773         addPtr(TrustedImm32(sizeof(CallerFrameAndPC)), MacroAssembler::framePointerRegister, tempGPR);
774         untagPtr(tempGPR, linkRegister);
775 #endif
776 #elif CPU(MIPS)
777         loadPtr(Address(framePointerRegister, sizeof(void*)), returnAddressRegister);
778         subPtr(TrustedImm32(2 * sizeof(void*)), newFrameSizeGPR);
779 #elif CPU(X86_64)
780         loadPtr(Address(framePointerRegister, sizeof(void*)), tempGPR);
781         push(tempGPR);
782         subPtr(TrustedImm32(sizeof(void*)), newFrameSizeGPR);
783 #else
784         UNREACHABLE_FOR_PLATFORM();
785 #endif
786         subPtr(newFrameSizeGPR, newFramePointer);
787         loadPtr(Address(framePointerRegister), framePointerRegister);
788 
789 
790         // We need to move the newFrameSizeGPR slots above the stack pointer by
791         // newFramePointer registers. We use pointer-sized chunks.
792         MacroAssembler::Label copyLoop(label());
793 
794         subPtr(TrustedImm32(sizeof(void*)), newFrameSizeGPR);
795         loadPtr(BaseIndex(stackPointerRegister, newFrameSizeGPR, TimesOne), tempGPR);
796         storePtr(tempGPR, BaseIndex(newFramePointer, newFrameSizeGPR, TimesOne));
797 
798         branchTest32(MacroAssembler::NonZero, newFrameSizeGPR).linkTo(copyLoop, this);
799 
800         // Ready for a jump!
801         move(newFramePointer, stackPointerRegister);
802     }
803 
804     // These operations clobber all volatile registers. They assume that there is room on the top of
805     // stack to marshall call arguments.
806     void logShadowChickenProloguePacket(GPRReg shadowPacket, GPRReg scratch1, GPRReg scope);
807     void logShadowChickenTailPacket(GPRReg shadowPacket, JSValueRegs thisRegs, GPRReg scope, CodeBlock*, CallSiteIndex);
808     // Leaves behind a pointer to the Packet we should write to in shadowPacket.
809     void ensureShadowChickenPacket(VM&amp;, GPRReg shadowPacket, GPRReg scratch1NonArgGPR, GPRReg scratch2);
810 };
811 
812 } // namespace JSC
813 
814 #endif // ENABLE(JIT)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/FontFaceSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FontFace.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FontFaceSet.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/FontFaceSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FontFaceSet.h&quot;
 28 

 29 #include &quot;Document.h&quot;

 30 #include &quot;FontFace.h&quot;
 31 #include &quot;FrameLoader.h&quot;
 32 #include &quot;JSDOMBinding.h&quot;

 33 #include &quot;JSFontFace.h&quot;
 34 #include &quot;JSFontFaceSet.h&quot;
 35 #include &lt;wtf/IsoMallocInlines.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 WTF_MAKE_ISO_ALLOCATED_IMPL(FontFaceSet);
 40 
 41 Ref&lt;FontFaceSet&gt; FontFaceSet::create(Document&amp; document, const Vector&lt;RefPtr&lt;FontFace&gt;&gt;&amp; initialFaces)
 42 {
 43     Ref&lt;FontFaceSet&gt; result = adoptRef(*new FontFaceSet(document, initialFaces));
 44     result-&gt;suspendIfNeeded();
 45     return result;
 46 }
 47 
 48 Ref&lt;FontFaceSet&gt; FontFaceSet::create(Document&amp; document, CSSFontFaceSet&amp; backing)
 49 {
 50     Ref&lt;FontFaceSet&gt; result = adoptRef(*new FontFaceSet(document, backing));
 51     result-&gt;suspendIfNeeded();
 52     return result;
 53 }
 54 
 55 FontFaceSet::FontFaceSet(Document&amp; document, const Vector&lt;RefPtr&lt;FontFace&gt;&gt;&amp; initialFaces)
 56     : ActiveDOMObject(document)
 57     , m_backing(CSSFontFaceSet::create())
<span class="line-modified"> 58     , m_readyPromise(*this, &amp;FontFaceSet::readyPromiseResolve)</span>
 59 {
 60     m_backing-&gt;addClient(*this);
 61     for (auto&amp; face : initialFaces)
 62         add(*face);
 63 }
 64 
 65 FontFaceSet::FontFaceSet(Document&amp; document, CSSFontFaceSet&amp; backing)
 66     : ActiveDOMObject(document)
 67     , m_backing(backing)
<span class="line-modified"> 68     , m_readyPromise(*this, &amp;FontFaceSet::readyPromiseResolve)</span>
 69 {
 70     if (document.frame())
<span class="line-modified"> 71         m_isFirstLayoutDone = document.frame()-&gt;loader().stateMachine().firstLayoutDone();</span>
 72 
<span class="line-modified"> 73     if (m_isFirstLayoutDone &amp;&amp; !backing.hasActiveFontFaces())</span>
<span class="line-modified"> 74         m_readyPromise.resolve(*this);</span>
 75 
 76     m_backing-&gt;addClient(*this);
 77 }
 78 
 79 FontFaceSet::~FontFaceSet()
 80 {
 81     m_backing-&gt;removeClient(*this);
 82 }
 83 
 84 FontFaceSet::Iterator::Iterator(FontFaceSet&amp; set)
 85     : m_target(set)
 86 {
 87 }
 88 
 89 RefPtr&lt;FontFace&gt; FontFaceSet::Iterator::next()
 90 {
 91     if (m_index == m_target-&gt;size())
 92         return nullptr;
 93     return m_target-&gt;backing()[m_index++].wrapper();
 94 }
 95 
 96 FontFaceSet::PendingPromise::PendingPromise(LoadPromise&amp;&amp; promise)
<span class="line-modified"> 97     : promise(WTFMove(promise))</span>
 98 {
 99 }
100 
101 FontFaceSet::PendingPromise::~PendingPromise() = default;
102 
103 bool FontFaceSet::has(FontFace&amp; face) const
104 {
105     return m_backing-&gt;hasFace(face.backing());
106 }
107 
108 size_t FontFaceSet::size() const
109 {
110     return m_backing-&gt;faceCount();
111 }
112 
113 FontFaceSet&amp; FontFaceSet::add(FontFace&amp; face)
114 {
115     if (!m_backing-&gt;hasFace(face.backing()))
116         m_backing-&gt;add(face.backing());
117     return *this;
</pre>
<hr />
<pre>
151     for (auto&amp; face : matchingFaces) {
152         if (face.get().status() == CSSFontFace::Status::Failure) {
153             promise.reject(NetworkError);
154             return;
155         }
156     }
157 
158     auto pendingPromise = PendingPromise::create(WTFMove(promise));
159     bool waiting = false;
160 
161     for (auto&amp; face : matchingFaces) {
162         pendingPromise-&gt;faces.append(face.get().wrapper());
163         if (face.get().status() == CSSFontFace::Status::Success)
164             continue;
165         waiting = true;
166         ASSERT(face.get().existingWrapper());
167         m_pendingPromises.add(face.get().existingWrapper(), Vector&lt;Ref&lt;PendingPromise&gt;&gt;()).iterator-&gt;value.append(pendingPromise.copyRef());
168     }
169 
170     if (!waiting)
<span class="line-modified">171         pendingPromise-&gt;promise.resolve(pendingPromise-&gt;faces);</span>
172 }
173 
174 ExceptionOr&lt;bool&gt; FontFaceSet::check(const String&amp; family, const String&amp; text)
175 {
176     return m_backing-&gt;check(family, text);
177 }
178 
179 auto FontFaceSet::status() const -&gt; LoadStatus
180 {
181     switch (m_backing-&gt;status()) {
182     case CSSFontFaceSet::Status::Loading:
183         return LoadStatus::Loading;
184     case CSSFontFaceSet::Status::Loaded:
185         return LoadStatus::Loaded;
186     }
187     ASSERT_NOT_REACHED();
188     return LoadStatus::Loaded;
189 }
190 
<span class="line-removed">191 bool FontFaceSet::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">192 {</span>
<span class="line-removed">193     return m_backing-&gt;status() == CSSFontFaceSet::Status::Loaded;</span>
<span class="line-removed">194 }</span>
<span class="line-removed">195 </span>
196 void FontFaceSet::startedLoading()
197 {
198     // FIXME: Fire a &quot;loading&quot; event asynchronously.
199 }
200 
<span class="line-modified">201 void FontFaceSet::didFirstLayout()</span>
202 {
<span class="line-modified">203     m_isFirstLayoutDone = true;</span>
<span class="line-modified">204     if (!m_backing-&gt;hasActiveFontFaces() &amp;&amp; !m_readyPromise.isFulfilled())</span>
<span class="line-modified">205         m_readyPromise.resolve(*this);</span>
206 }
207 
208 void FontFaceSet::completedLoading()
209 {
<span class="line-modified">210     if (m_isFirstLayoutDone &amp;&amp; !m_readyPromise.isFulfilled())</span>
<span class="line-modified">211         m_readyPromise.resolve(*this);</span>
212 }
213 
214 void FontFaceSet::faceFinished(CSSFontFace&amp; face, CSSFontFace::Status newStatus)
215 {
216     if (!face.existingWrapper())
217         return;
218 
<span class="line-modified">219     auto iterator = m_pendingPromises.find(face.existingWrapper());</span>
<span class="line-modified">220     if (iterator == m_pendingPromises.end())</span>
221         return;
222 
<span class="line-modified">223     for (auto&amp; pendingPromise : iterator-&gt;value) {</span>
224         if (pendingPromise-&gt;hasReachedTerminalState)
225             continue;
226         if (newStatus == CSSFontFace::Status::Success) {
227             if (pendingPromise-&gt;hasOneRef()) {
<span class="line-modified">228                 pendingPromise-&gt;promise.resolve(pendingPromise-&gt;faces);</span>
229                 pendingPromise-&gt;hasReachedTerminalState = true;
230             }
231         } else {
232             ASSERT(newStatus == CSSFontFace::Status::Failure);
<span class="line-modified">233             pendingPromise-&gt;promise.reject(NetworkError);</span>
234             pendingPromise-&gt;hasReachedTerminalState = true;
235         }
236     }
<span class="line-removed">237 </span>
<span class="line-removed">238     m_pendingPromises.remove(iterator);</span>
239 }
240 
241 FontFaceSet&amp; FontFaceSet::readyPromiseResolve()
242 {
243     return *this;
244 }
245 
246 }
</pre>
</td>
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FontFaceSet.h&quot;
 28 
<span class="line-added"> 29 #include &quot;DOMPromiseProxy.h&quot;</span>
 30 #include &quot;Document.h&quot;
<span class="line-added"> 31 #include &quot;EventLoop.h&quot;</span>
 32 #include &quot;FontFace.h&quot;
 33 #include &quot;FrameLoader.h&quot;
 34 #include &quot;JSDOMBinding.h&quot;
<span class="line-added"> 35 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 36 #include &quot;JSFontFace.h&quot;
 37 #include &quot;JSFontFaceSet.h&quot;
 38 #include &lt;wtf/IsoMallocInlines.h&gt;
 39 
 40 namespace WebCore {
 41 
 42 WTF_MAKE_ISO_ALLOCATED_IMPL(FontFaceSet);
 43 
 44 Ref&lt;FontFaceSet&gt; FontFaceSet::create(Document&amp; document, const Vector&lt;RefPtr&lt;FontFace&gt;&gt;&amp; initialFaces)
 45 {
 46     Ref&lt;FontFaceSet&gt; result = adoptRef(*new FontFaceSet(document, initialFaces));
 47     result-&gt;suspendIfNeeded();
 48     return result;
 49 }
 50 
 51 Ref&lt;FontFaceSet&gt; FontFaceSet::create(Document&amp; document, CSSFontFaceSet&amp; backing)
 52 {
 53     Ref&lt;FontFaceSet&gt; result = adoptRef(*new FontFaceSet(document, backing));
 54     result-&gt;suspendIfNeeded();
 55     return result;
 56 }
 57 
 58 FontFaceSet::FontFaceSet(Document&amp; document, const Vector&lt;RefPtr&lt;FontFace&gt;&gt;&amp; initialFaces)
 59     : ActiveDOMObject(document)
 60     , m_backing(CSSFontFaceSet::create())
<span class="line-modified"> 61     , m_readyPromise(makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;FontFaceSet::readyPromiseResolve))</span>
 62 {
 63     m_backing-&gt;addClient(*this);
 64     for (auto&amp; face : initialFaces)
 65         add(*face);
 66 }
 67 
 68 FontFaceSet::FontFaceSet(Document&amp; document, CSSFontFaceSet&amp; backing)
 69     : ActiveDOMObject(document)
 70     , m_backing(backing)
<span class="line-modified"> 71     , m_readyPromise(makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;FontFaceSet::readyPromiseResolve))</span>
 72 {
 73     if (document.frame())
<span class="line-modified"> 74         m_isDocumentLoaded = document.loadEventFinished() &amp;&amp; !document.processingLoadEvent();</span>
 75 
<span class="line-modified"> 76     if (m_isDocumentLoaded &amp;&amp; !backing.hasActiveFontFaces())</span>
<span class="line-modified"> 77         m_readyPromise-&gt;resolve(*this);</span>
 78 
 79     m_backing-&gt;addClient(*this);
 80 }
 81 
 82 FontFaceSet::~FontFaceSet()
 83 {
 84     m_backing-&gt;removeClient(*this);
 85 }
 86 
 87 FontFaceSet::Iterator::Iterator(FontFaceSet&amp; set)
 88     : m_target(set)
 89 {
 90 }
 91 
 92 RefPtr&lt;FontFace&gt; FontFaceSet::Iterator::next()
 93 {
 94     if (m_index == m_target-&gt;size())
 95         return nullptr;
 96     return m_target-&gt;backing()[m_index++].wrapper();
 97 }
 98 
 99 FontFaceSet::PendingPromise::PendingPromise(LoadPromise&amp;&amp; promise)
<span class="line-modified">100     : promise(makeUniqueRef&lt;LoadPromise&gt;(WTFMove(promise)))</span>
101 {
102 }
103 
104 FontFaceSet::PendingPromise::~PendingPromise() = default;
105 
106 bool FontFaceSet::has(FontFace&amp; face) const
107 {
108     return m_backing-&gt;hasFace(face.backing());
109 }
110 
111 size_t FontFaceSet::size() const
112 {
113     return m_backing-&gt;faceCount();
114 }
115 
116 FontFaceSet&amp; FontFaceSet::add(FontFace&amp; face)
117 {
118     if (!m_backing-&gt;hasFace(face.backing()))
119         m_backing-&gt;add(face.backing());
120     return *this;
</pre>
<hr />
<pre>
154     for (auto&amp; face : matchingFaces) {
155         if (face.get().status() == CSSFontFace::Status::Failure) {
156             promise.reject(NetworkError);
157             return;
158         }
159     }
160 
161     auto pendingPromise = PendingPromise::create(WTFMove(promise));
162     bool waiting = false;
163 
164     for (auto&amp; face : matchingFaces) {
165         pendingPromise-&gt;faces.append(face.get().wrapper());
166         if (face.get().status() == CSSFontFace::Status::Success)
167             continue;
168         waiting = true;
169         ASSERT(face.get().existingWrapper());
170         m_pendingPromises.add(face.get().existingWrapper(), Vector&lt;Ref&lt;PendingPromise&gt;&gt;()).iterator-&gt;value.append(pendingPromise.copyRef());
171     }
172 
173     if (!waiting)
<span class="line-modified">174         pendingPromise-&gt;promise-&gt;resolve(pendingPromise-&gt;faces);</span>
175 }
176 
177 ExceptionOr&lt;bool&gt; FontFaceSet::check(const String&amp; family, const String&amp; text)
178 {
179     return m_backing-&gt;check(family, text);
180 }
181 
182 auto FontFaceSet::status() const -&gt; LoadStatus
183 {
184     switch (m_backing-&gt;status()) {
185     case CSSFontFaceSet::Status::Loading:
186         return LoadStatus::Loading;
187     case CSSFontFaceSet::Status::Loaded:
188         return LoadStatus::Loaded;
189     }
190     ASSERT_NOT_REACHED();
191     return LoadStatus::Loaded;
192 }
193 





194 void FontFaceSet::startedLoading()
195 {
196     // FIXME: Fire a &quot;loading&quot; event asynchronously.
197 }
198 
<span class="line-modified">199 void FontFaceSet::documentDidFinishLoading()</span>
200 {
<span class="line-modified">201     m_isDocumentLoaded = true;</span>
<span class="line-modified">202     if (!m_backing-&gt;hasActiveFontFaces() &amp;&amp; !m_readyPromise-&gt;isFulfilled())</span>
<span class="line-modified">203         m_readyPromise-&gt;resolve(*this);</span>
204 }
205 
206 void FontFaceSet::completedLoading()
207 {
<span class="line-modified">208     if (m_isDocumentLoaded &amp;&amp; !m_readyPromise-&gt;isFulfilled())</span>
<span class="line-modified">209         m_readyPromise-&gt;resolve(*this);</span>
210 }
211 
212 void FontFaceSet::faceFinished(CSSFontFace&amp; face, CSSFontFace::Status newStatus)
213 {
214     if (!face.existingWrapper())
215         return;
216 
<span class="line-modified">217     auto pendingPromises = m_pendingPromises.take(face.existingWrapper());</span>
<span class="line-modified">218     if (pendingPromises.isEmpty())</span>
219         return;
220 
<span class="line-modified">221     for (auto&amp; pendingPromise : pendingPromises) {</span>
222         if (pendingPromise-&gt;hasReachedTerminalState)
223             continue;
224         if (newStatus == CSSFontFace::Status::Success) {
225             if (pendingPromise-&gt;hasOneRef()) {
<span class="line-modified">226                 pendingPromise-&gt;promise-&gt;resolve(pendingPromise-&gt;faces);</span>
227                 pendingPromise-&gt;hasReachedTerminalState = true;
228             }
229         } else {
230             ASSERT(newStatus == CSSFontFace::Status::Failure);
<span class="line-modified">231             pendingPromise-&gt;promise-&gt;reject(NetworkError);</span>
232             pendingPromise-&gt;hasReachedTerminalState = true;
233         }
234     }


235 }
236 
237 FontFaceSet&amp; FontFaceSet::readyPromiseResolve()
238 {
239     return *this;
240 }
241 
242 }
</pre>
</td>
</tr>
</table>
<center><a href="FontFace.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FontFaceSet.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
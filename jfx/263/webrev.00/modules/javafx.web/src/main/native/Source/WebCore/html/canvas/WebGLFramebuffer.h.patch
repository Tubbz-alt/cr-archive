diff a/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLFramebuffer.h b/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLFramebuffer.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLFramebuffer.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLFramebuffer.h
@@ -27,11 +27,13 @@
 
 #if ENABLE(WEBGL)
 
 #include "WebGLContextObject.h"
 #include "WebGLSharedObject.h"
+#include <wtf/HashMap.h>
 #include <wtf/RefCounted.h>
+#include <wtf/Vector.h>
 
 namespace WebCore {
 
 class WebGLRenderbuffer;
 class WebGLTexture;
@@ -40,95 +42,95 @@
 public:
     class WebGLAttachment : public RefCounted<WebGLAttachment> {
     public:
         virtual ~WebGLAttachment();
 
-        virtual GC3Dsizei getWidth() const = 0;
-        virtual GC3Dsizei getHeight() const = 0;
-        virtual GC3Denum getFormat() const = 0;
+        virtual GCGLsizei getWidth() const = 0;
+        virtual GCGLsizei getHeight() const = 0;
+        virtual GCGLenum getFormat() const = 0;
         virtual WebGLSharedObject* getObject() const = 0;
         virtual bool isSharedObject(WebGLSharedObject*) const = 0;
         virtual bool isValid() const = 0;
         virtual bool isInitialized() const = 0;
         virtual void setInitialized() = 0;
-        virtual void onDetached(GraphicsContext3D*) = 0;
-        virtual void attach(GraphicsContext3D*, GC3Denum attachment) = 0;
-        virtual void unattach(GraphicsContext3D*, GC3Denum attachment) = 0;
+        virtual void onDetached(GraphicsContextGLOpenGL*) = 0;
+        virtual void attach(GraphicsContextGLOpenGL*, GCGLenum attachment) = 0;
+        virtual void unattach(GraphicsContextGLOpenGL*, GCGLenum attachment) = 0;
 
     protected:
         WebGLAttachment();
     };
 
     virtual ~WebGLFramebuffer();
 
     static Ref<WebGLFramebuffer> create(WebGLRenderingContextBase&);
 
-    void setAttachmentForBoundFramebuffer(GC3Denum attachment, GC3Denum texTarget, WebGLTexture*, GC3Dint level);
-    void setAttachmentForBoundFramebuffer(GC3Denum attachment, WebGLRenderbuffer*);
+    void setAttachmentForBoundFramebuffer(GCGLenum attachment, GCGLenum texTarget, WebGLTexture*, GCGLint level);
+    void setAttachmentForBoundFramebuffer(GCGLenum attachment, WebGLRenderbuffer*);
     // If an object is attached to the currently bound framebuffer, remove it.
     void removeAttachmentFromBoundFramebuffer(WebGLSharedObject*);
     // If a given attachment point for the currently bound framebuffer is not null, remove the attached object.
-    void removeAttachmentFromBoundFramebuffer(GC3Denum);
-    WebGLSharedObject* getAttachmentObject(GC3Denum) const;
+    void removeAttachmentFromBoundFramebuffer(GCGLenum);
+    WebGLSharedObject* getAttachmentObject(GCGLenum) const;
 
-    GC3Denum getColorBufferFormat() const;
-    GC3Dsizei getColorBufferWidth() const;
-    GC3Dsizei getColorBufferHeight() const;
+    GCGLenum getColorBufferFormat() const;
+    GCGLsizei getColorBufferWidth() const;
+    GCGLsizei getColorBufferHeight() const;
 
     // This should always be called before drawArray, drawElements, clear,
     // readPixels, copyTexImage2D, copyTexSubImage2D if this framebuffer is
     // currently bound.
     // Return false if the framebuffer is incomplete; otherwise initialize
     // the buffers if they haven't been initialized and
     // needToInitializeAttachments is true.
-    bool onAccess(GraphicsContext3D*, const char** reason);
+    bool onAccess(GraphicsContextGLOpenGL*, const char** reason);
 
     // Software version of glCheckFramebufferStatus(), except that when
     // FRAMEBUFFER_COMPLETE is returned, it is still possible for
     // glCheckFramebufferStatus() to return FRAMEBUFFER_UNSUPPORTED,
     // depending on hardware implementation.
-    GC3Denum checkStatus(const char** reason) const;
+    GCGLenum checkStatus(const char** reason) const;
 
     bool hasEverBeenBound() const { return object() && m_hasEverBeenBound; }
 
     void setHasEverBeenBound() { m_hasEverBeenBound = true; }
 
     bool hasStencilBuffer() const;
 
     // Wrapper for drawBuffersEXT/drawBuffersARB to work around a driver bug.
-    void drawBuffers(const Vector<GC3Denum>& bufs);
+    void drawBuffers(const Vector<GCGLenum>& bufs);
 
-    GC3Denum getDrawBuffer(GC3Denum);
+    GCGLenum getDrawBuffer(GCGLenum);
 
 protected:
     WebGLFramebuffer(WebGLRenderingContextBase&);
 
-    void deleteObjectImpl(GraphicsContext3D*, Platform3DObject) override;
+    void deleteObjectImpl(GraphicsContextGLOpenGL*, PlatformGLObject) override;
 
 private:
-    WebGLAttachment* getAttachment(GC3Denum) const;
+    WebGLAttachment* getAttachment(GCGLenum) const;
 
     // Return false if framebuffer is incomplete.
-    bool initializeAttachments(GraphicsContext3D*, const char** reason);
+    bool initializeAttachments(GraphicsContextGLOpenGL*, const char** reason);
 
     // Check if the framebuffer is currently bound.
     bool isBound() const;
 
     // attach 'attachment' at 'attachmentPoint'.
-    void attach(GC3Denum attachment, GC3Denum attachmentPoint);
+    void attach(GCGLenum attachment, GCGLenum attachmentPoint);
 
     // Check if a new drawBuffers call should be issued. This is called when we add or remove an attachment.
     void drawBuffersIfNecessary(bool force);
 
-    typedef WTF::HashMap<GC3Denum, RefPtr<WebGLAttachment>> AttachmentMap;
+    typedef WTF::HashMap<GCGLenum, RefPtr<WebGLAttachment>> AttachmentMap;
 
     AttachmentMap m_attachments;
 
     bool m_hasEverBeenBound;
 
-    Vector<GC3Denum> m_drawBuffers;
-    Vector<GC3Denum> m_filteredDrawBuffers;
+    Vector<GCGLenum> m_drawBuffers;
+    Vector<GCGLenum> m_filteredDrawBuffers;
 };
 
 } // namespace WebCore
 
 #endif

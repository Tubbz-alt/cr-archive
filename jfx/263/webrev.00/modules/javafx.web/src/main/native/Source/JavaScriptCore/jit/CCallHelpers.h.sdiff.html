<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/CCallHelpers.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CCallHelpers.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallFrameShuffleData.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/CCallHelpers.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(JIT)
 29 
 30 #include &quot;AssemblyHelpers.h&quot;
 31 #include &quot;FPRInfo.h&quot;
 32 #include &quot;GPRInfo.h&quot;
 33 #include &quot;StackAlignment.h&quot;
 34 #include &lt;wtf/FunctionTraits.h&gt;
 35 
 36 namespace JSC {
 37 
 38 #if CPU(MIPS) || (OS(WINDOWS) &amp;&amp; CPU(X86_64))
 39 #define POKE_ARGUMENT_OFFSET 4
 40 #else
 41 #define POKE_ARGUMENT_OFFSET 0
 42 #endif
 43 
<span class="line-modified"> 44 class ExecState;</span>
 45 class Structure;
 46 namespace DFG {
 47 class RegisteredStructure;
 48 };
 49 
 50 class CCallHelpers : public AssemblyHelpers {
 51 public:
 52     CCallHelpers(CodeBlock* codeBlock = 0)
 53         : AssemblyHelpers(codeBlock)
 54     {
 55     }
 56 
 57     // Wrapper to encode JSCell GPR into JSValue.
 58     class CellValue {
 59     public:
 60         explicit CellValue(GPRReg gpr)
 61             : m_gpr(gpr)
 62         {
 63         }
 64 
</pre>
<hr />
<pre>
 72     // argument without using any argument registers. You usually want one of the setupArguments*()
 73     // methods below instead of this. This thing is most useful if you have *a lot* of arguments.
 74     template&lt;typename Functor&gt;
 75     void setupArgument(unsigned argumentIndex, const Functor&amp; functor)
 76     {
 77         unsigned numberOfRegs = GPRInfo::numberOfArgumentRegisters; // Disguise the constant from clang&#39;s tautological compare warning.
 78         if (argumentIndex &lt; numberOfRegs) {
 79             functor(GPRInfo::toArgumentRegister(argumentIndex));
 80             return;
 81         }
 82 
 83         functor(GPRInfo::nonArgGPR0);
 84         poke(GPRInfo::nonArgGPR0, POKE_ARGUMENT_OFFSET + argumentIndex - GPRInfo::numberOfArgumentRegisters);
 85     }
 86 
 87 private:
 88 
 89     template&lt;unsigned NumberOfRegisters, typename RegType&gt;
 90     ALWAYS_INLINE void setupStubArgs(std::array&lt;RegType, NumberOfRegisters&gt; destinations, std::array&lt;RegType, NumberOfRegisters&gt; sources)
 91     {
<span class="line-modified"> 92         if (!ASSERT_DISABLED) {</span>
 93             RegisterSet set;
 94             for (RegType dest : destinations)
 95                 set.set(dest);
 96             ASSERT_WITH_MESSAGE(set.numberOfSetRegisters() == NumberOfRegisters, &quot;Destinations should not be aliased.&quot;);
 97         }
 98 
 99         typedef std::pair&lt;RegType, RegType&gt; RegPair;
100         Vector&lt;RegPair, NumberOfRegisters&gt; pairs;
101 
102         for (unsigned i = 0; i &lt; NumberOfRegisters; ++i) {
103             if (sources[i] != destinations[i])
104                 pairs.append(std::make_pair(sources[i], destinations[i]));
105         }
106 
<span class="line-modified">107 #if !ASSERT_DISABLED</span>
108         auto numUniqueSources = [&amp;] () -&gt; unsigned {
109             RegisterSet set;
110             for (auto&amp; pair : pairs) {
111                 RegType source = pair.first;
112                 set.set(source);
113             }
114             return set.numberOfSetRegisters();
115         };
116 
117         auto numUniqueDests = [&amp;] () -&gt; unsigned {
118             RegisterSet set;
119             for (auto&amp; pair : pairs) {
120                 RegType dest = pair.second;
121                 set.set(dest);
122             }
123             return set.numberOfSetRegisters();
124         };
125 #endif
126 
127         while (pairs.size()) {
</pre>
<hr />
<pre>
395 
396     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;
397     ALWAYS_INLINE void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, GPRReg arg, Args... args)
398     {
399         marshallArgumentRegister&lt;OperationType&gt;(argSourceRegs, arg, args...);
400     }
401 
402     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;
403     ALWAYS_INLINE void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, JSValueRegs arg, Args... args)
404     {
405         marshallArgumentRegister&lt;OperationType&gt;(argSourceRegs, arg.gpr(), args...);
406     }
407 
408     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;
409     ALWAYS_INLINE void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, CellValue arg, Args... args)
410     {
411         marshallArgumentRegister&lt;OperationType&gt;(argSourceRegs, arg.gpr(), args...);
412     }
413 
414 #else // USE(JSVALUE64)
<span class="line-modified">415 #if CPU(X86)</span>
<span class="line-removed">416 </span>
<span class="line-removed">417     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;</span>
<span class="line-removed">418     ALWAYS_INLINE void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, FPRReg arg, Args... args)</span>
<span class="line-removed">419     {</span>
<span class="line-removed">420         static_assert(std::is_same&lt;CURRENT_ARGUMENT_TYPE, double&gt;::value, &quot;We should only be passing FPRRegs to a double&quot;);</span>
<span class="line-removed">421         pokeForArgument(arg, numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke);</span>
<span class="line-removed">422         setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs.addStackArg(arg).addPoke(), args...);</span>
<span class="line-removed">423     }</span>
<span class="line-removed">424 </span>
<span class="line-removed">425     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;</span>
<span class="line-removed">426     ALWAYS_INLINE std::enable_if_t&lt;sizeof(CURRENT_ARGUMENT_TYPE) &lt;= 4&gt;</span>
<span class="line-removed">427     setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, GPRReg arg, Args... args)</span>
<span class="line-removed">428     {</span>
<span class="line-removed">429         pokeForArgument(arg, numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke);</span>
<span class="line-removed">430         setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs.addGPRArg(), args...);</span>
<span class="line-removed">431     }</span>
<span class="line-removed">432 </span>
<span class="line-removed">433     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;</span>
<span class="line-removed">434     ALWAYS_INLINE std::enable_if_t&lt;std::is_same&lt;CURRENT_ARGUMENT_TYPE, EncodedJSValue&gt;::value&gt;</span>
<span class="line-removed">435     setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, CellValue payload, Args... args)</span>
<span class="line-removed">436     {</span>
<span class="line-removed">437         pokeForArgument(payload.gpr(), numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke);</span>
<span class="line-removed">438         pokeForArgument(TrustedImm32(JSValue::CellTag), numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke + 1);</span>
<span class="line-removed">439         setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs.addGPRArg().addPoke(), args...);</span>
<span class="line-removed">440     }</span>
<span class="line-removed">441 </span>
<span class="line-removed">442     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;</span>
<span class="line-removed">443     ALWAYS_INLINE std::enable_if_t&lt;std::is_same&lt;CURRENT_ARGUMENT_TYPE, EncodedJSValue&gt;::value&gt;</span>
<span class="line-removed">444     setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, JSValueRegs arg, Args... args)</span>
<span class="line-removed">445     {</span>
<span class="line-removed">446         pokeForArgument(arg.payloadGPR(), numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke);</span>
<span class="line-removed">447         pokeForArgument(arg.tagGPR(), numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke + 1);</span>
<span class="line-removed">448         setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs.addGPRArg().addPoke(), args...);</span>
<span class="line-removed">449     }</span>
<span class="line-removed">450 </span>
<span class="line-removed">451 #elif CPU(ARM_THUMB2) || CPU(MIPS)</span>
452 
453     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;
454     void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, FPRReg arg, Args... args)
455     {
456         static_assert(std::is_same&lt;CURRENT_ARGUMENT_TYPE, double&gt;::value, &quot;We should only be passing FPRRegs to a double&quot;);
457 
458         // MIPS and ARM-hardfp pass FP arguments in FP registers.
459 #if CPU(MIPS)
460         unsigned numberOfFPArgumentRegisters = FPRInfo::numberOfArgumentRegisters;
461         unsigned currentFPArgCount = argSourceRegs.argCount(arg);
462 
463         // MIPS can only use FP argument registers if it isn&#39;t preceeded by any GP argument.
464         if (currentFPArgCount &lt; numberOfFPArgumentRegisters &amp;&amp; !numGPRArgs) {
465             auto updatedArgSourceRegs = argSourceRegs.pushRegArg(arg, FPRInfo::toArgumentRegister(currentFPArgCount));
466             setupArgumentsImpl&lt;OperationType&gt;(updatedArgSourceRegs.addGPRExtraArg().addGPRExtraArg(), args...);
467             return;
468         }
469 #elif CPU(ARM_THUMB2) &amp;&amp; CPU(ARM_HARDFP)
470         unsigned numberOfFPArgumentRegisters = FPRInfo::numberOfArgumentRegisters;
471         unsigned currentFPArgCount = argSourceRegs.argCount(arg);
</pre>
<hr />
<pre>
652     }
653 
654     // Special case DFG::RegisteredStructure because it&#39;s really annoying to deal with otherwise...
655     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename Arg, typename... Args&gt;
656     ALWAYS_INLINE std::enable_if_t&lt;
657         std::is_same&lt;CURRENT_ARGUMENT_TYPE, Structure*&gt;::value
658         &amp;&amp; std::is_same&lt;Arg, DFG::RegisteredStructure&gt;::value&gt;
659     setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, Arg arg, Args... args)
660     {
661         setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs, TrustedImmPtr(arg.get()), args...);
662     }
663 
664 #undef CURRENT_ARGUMENT_TYPE
665 #undef RESULT_TYPE
666 
667     // Base case; set up the argument registers.
668     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke&gt;
669     ALWAYS_INLINE void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs)
670     {
671         static_assert(FunctionTraits&lt;OperationType&gt;::arity == numGPRArgs + numFPRArgs, &quot;One last sanity check&quot;);
<span class="line-modified">672 #if USE(JSVALUE64) || CPU(X86)</span>
673         static_assert(FunctionTraits&lt;OperationType&gt;::cCallArity() == numGPRArgs + numFPRArgs + extraPoke, &quot;Check the CCall arity&quot;);
674 #endif
675         setupStubArgs&lt;numGPRSources, GPRReg&gt;(clampArrayToSize&lt;numGPRSources, GPRReg&gt;(argSourceRegs.gprDestinations), clampArrayToSize&lt;numGPRSources, GPRReg&gt;(argSourceRegs.gprSources));
676 #if CPU(MIPS) || (CPU(ARM_THUMB2) &amp;&amp; !CPU(ARM_HARDFP))
677         setupStubCrossArgs&lt;numCrossSources&gt;(argSourceRegs.crossDestinations, argSourceRegs.crossSources);
678 #else
679         static_assert(!numCrossSources, &quot;shouldn&#39;t be used on this architecture.&quot;);
680 #endif
681         setupStubArgs&lt;numFPRSources, FPRReg&gt;(clampArrayToSize&lt;numFPRSources, FPRReg&gt;(argSourceRegs.fprDestinations), clampArrayToSize&lt;numFPRSources, FPRReg&gt;(argSourceRegs.fprSources));
682     }
683 
684 public:
685 
686 #define FIRST_ARGUMENT_TYPE typename FunctionTraits&lt;OperationType&gt;::template ArgumentType&lt;0&gt;
687 
688     template&lt;typename OperationType, typename... Args&gt;
<span class="line-modified">689     ALWAYS_INLINE std::enable_if_t&lt;std::is_same&lt;FIRST_ARGUMENT_TYPE, ExecState*&gt;::value&gt; setupArguments(Args... args)</span>
690     {
691 #if USE(JSVALUE64)
692         // This only really works for 64-bit since jsvalue regs mess things up for 32-bit...
693         static_assert(FunctionTraits&lt;OperationType&gt;::cCallArity() == sizeof...(Args) + 1, &quot;Basic sanity check&quot;);
694 #endif
695         setupArgumentsImpl&lt;OperationType, 0, 0, 0, 0, 0, 0, 0&gt;(ArgCollection&lt;0, 0, 0, 0, 0, 0, 0&gt;(), GPRInfo::callFrameRegister, args...);
696     }
697 
698     template&lt;typename OperationType, typename... Args&gt;
<span class="line-modified">699     ALWAYS_INLINE std::enable_if_t&lt;!std::is_same&lt;FIRST_ARGUMENT_TYPE, ExecState*&gt;::value&gt; setupArguments(Args... args)</span>
700     {
701 #if USE(JSVALUE64)
702         // This only really works for 64-bit since jsvalue regs mess things up for 32-bit...
703         static_assert(FunctionTraits&lt;OperationType&gt;::cCallArity() == sizeof...(Args), &quot;Basic sanity check&quot;);
704 #endif
705         setupArgumentsImpl&lt;OperationType, 0, 0, 0, 0, 0, 0, 0&gt;(ArgCollection&lt;0, 0, 0, 0, 0, 0, 0&gt;(), args...);
706     }
707 
708 #undef FIRST_ARGUMENT_TYPE
709 
710     void setupResults(GPRReg destA, GPRReg destB)
711     {
712         GPRReg srcA = GPRInfo::returnValueGPR;
713         GPRReg srcB = GPRInfo::returnValueGPR2;
714 
715         if (destA == InvalidGPRReg)
716             move(srcB, destB);
717         else if (destB == InvalidGPRReg)
718             move(srcA, destA);
719         else if (srcB != destA) {
</pre>
<hr />
<pre>
743         // and the address of the handler in vm-&gt;targetMachinePCForThrow.
744         loadPtr(&amp;vm.targetMachinePCForThrow, GPRInfo::regT1);
745         farJump(GPRInfo::regT1, ExceptionHandlerPtrTag);
746     }
747 
748     void prepareForTailCallSlow(GPRReg calleeGPR = InvalidGPRReg)
749     {
750         GPRReg temp1 = calleeGPR == GPRInfo::regT0 ? GPRInfo::regT3 : GPRInfo::regT0;
751         GPRReg temp2 = calleeGPR == GPRInfo::regT1 ? GPRInfo::regT3 : GPRInfo::regT1;
752         GPRReg temp3 = calleeGPR == GPRInfo::regT2 ? GPRInfo::regT3 : GPRInfo::regT2;
753 
754         GPRReg newFramePointer = temp1;
755         GPRReg newFrameSizeGPR = temp2;
756         {
757             // The old frame size is its number of arguments (or number of
758             // parameters in case of arity fixup), plus the frame header size,
759             // aligned
760             GPRReg oldFrameSizeGPR = temp2;
761             {
762                 GPRReg argCountGPR = oldFrameSizeGPR;
<span class="line-modified">763                 load32(Address(framePointerRegister, CallFrameSlot::argumentCount * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset), argCountGPR);</span>
764 
765                 {
766                     GPRReg numParametersGPR = temp1;
767                     {
768                         GPRReg codeBlockGPR = numParametersGPR;
769                         loadPtr(Address(framePointerRegister, CallFrameSlot::codeBlock * static_cast&lt;int&gt;(sizeof(Register))), codeBlockGPR);
770                         load32(Address(codeBlockGPR, CodeBlock::offsetOfNumParameters()), numParametersGPR);
771                     }
772 
773                     ASSERT(numParametersGPR != argCountGPR);
774                     Jump argumentCountWasNotFixedUp = branch32(BelowOrEqual, numParametersGPR, argCountGPR);
775                     move(numParametersGPR, argCountGPR);
776                     argumentCountWasNotFixedUp.link(this);
777                 }
778 
779                 add32(TrustedImm32(stackAlignmentRegisters() + CallFrame::headerSizeInRegisters - 1), argCountGPR, oldFrameSizeGPR);
780                 and32(TrustedImm32(-stackAlignmentRegisters()), oldFrameSizeGPR);
781                 // We assume &lt; 2^28 arguments
782                 mul32(TrustedImm32(sizeof(Register)), oldFrameSizeGPR, oldFrameSizeGPR);
783             }
784 
785             // The new frame pointer is at framePointer + oldFrameSize - newFrameSize
786             ASSERT(newFramePointer != oldFrameSizeGPR);
787             addPtr(framePointerRegister, oldFrameSizeGPR, newFramePointer);
788 
789             // The new frame size is just the number of arguments plus the
790             // frame header size, aligned
791             ASSERT(newFrameSizeGPR != newFramePointer);
<span class="line-modified">792             load32(Address(stackPointerRegister, CallFrameSlot::argumentCount * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset - sizeof(CallerFrameAndPC)),</span>
793                 newFrameSizeGPR);
794             add32(TrustedImm32(stackAlignmentRegisters() + CallFrame::headerSizeInRegisters - 1), newFrameSizeGPR);
795             and32(TrustedImm32(-stackAlignmentRegisters()), newFrameSizeGPR);
796             // We assume &lt; 2^28 arguments
797             mul32(TrustedImm32(sizeof(Register)), newFrameSizeGPR, newFrameSizeGPR);
798         }
799 
800         GPRReg tempGPR = temp3;
801         ASSERT(tempGPR != newFramePointer &amp;&amp; tempGPR != newFrameSizeGPR);
802 
803         // We don&#39;t need the current frame beyond this point. Masquerade as our
804         // caller.
805 #if CPU(ARM_THUMB2) || CPU(ARM64)
806         loadPtr(Address(framePointerRegister, CallFrame::returnPCOffset()), linkRegister);
807         subPtr(TrustedImm32(2 * sizeof(void*)), newFrameSizeGPR);
808 #if CPU(ARM64E)
809         addPtr(TrustedImm32(sizeof(CallerFrameAndPC)), MacroAssembler::framePointerRegister, tempGPR);
810         untagPtr(tempGPR, linkRegister);
811 #endif
812 #elif CPU(MIPS)
813         loadPtr(Address(framePointerRegister, sizeof(void*)), returnAddressRegister);
814         subPtr(TrustedImm32(2 * sizeof(void*)), newFrameSizeGPR);
<span class="line-modified">815 #elif CPU(X86) || CPU(X86_64)</span>
816         loadPtr(Address(framePointerRegister, sizeof(void*)), tempGPR);
817         push(tempGPR);
818         subPtr(TrustedImm32(sizeof(void*)), newFrameSizeGPR);
819 #else
820         UNREACHABLE_FOR_PLATFORM();
821 #endif
822         subPtr(newFrameSizeGPR, newFramePointer);
823         loadPtr(Address(framePointerRegister), framePointerRegister);
824 
825 
826         // We need to move the newFrameSizeGPR slots above the stack pointer by
827         // newFramePointer registers. We use pointer-sized chunks.
828         MacroAssembler::Label copyLoop(label());
829 
830         subPtr(TrustedImm32(sizeof(void*)), newFrameSizeGPR);
831         loadPtr(BaseIndex(stackPointerRegister, newFrameSizeGPR, TimesOne), tempGPR);
832         storePtr(tempGPR, BaseIndex(newFramePointer, newFrameSizeGPR, TimesOne));
833 
834         branchTest32(MacroAssembler::NonZero, newFrameSizeGPR).linkTo(copyLoop, this);
835 
</pre>
</td>
<td>
<hr />
<pre>
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(JIT)
 29 
 30 #include &quot;AssemblyHelpers.h&quot;
 31 #include &quot;FPRInfo.h&quot;
 32 #include &quot;GPRInfo.h&quot;
 33 #include &quot;StackAlignment.h&quot;
 34 #include &lt;wtf/FunctionTraits.h&gt;
 35 
 36 namespace JSC {
 37 
 38 #if CPU(MIPS) || (OS(WINDOWS) &amp;&amp; CPU(X86_64))
 39 #define POKE_ARGUMENT_OFFSET 4
 40 #else
 41 #define POKE_ARGUMENT_OFFSET 0
 42 #endif
 43 
<span class="line-modified"> 44 class CallFrame;</span>
 45 class Structure;
 46 namespace DFG {
 47 class RegisteredStructure;
 48 };
 49 
 50 class CCallHelpers : public AssemblyHelpers {
 51 public:
 52     CCallHelpers(CodeBlock* codeBlock = 0)
 53         : AssemblyHelpers(codeBlock)
 54     {
 55     }
 56 
 57     // Wrapper to encode JSCell GPR into JSValue.
 58     class CellValue {
 59     public:
 60         explicit CellValue(GPRReg gpr)
 61             : m_gpr(gpr)
 62         {
 63         }
 64 
</pre>
<hr />
<pre>
 72     // argument without using any argument registers. You usually want one of the setupArguments*()
 73     // methods below instead of this. This thing is most useful if you have *a lot* of arguments.
 74     template&lt;typename Functor&gt;
 75     void setupArgument(unsigned argumentIndex, const Functor&amp; functor)
 76     {
 77         unsigned numberOfRegs = GPRInfo::numberOfArgumentRegisters; // Disguise the constant from clang&#39;s tautological compare warning.
 78         if (argumentIndex &lt; numberOfRegs) {
 79             functor(GPRInfo::toArgumentRegister(argumentIndex));
 80             return;
 81         }
 82 
 83         functor(GPRInfo::nonArgGPR0);
 84         poke(GPRInfo::nonArgGPR0, POKE_ARGUMENT_OFFSET + argumentIndex - GPRInfo::numberOfArgumentRegisters);
 85     }
 86 
 87 private:
 88 
 89     template&lt;unsigned NumberOfRegisters, typename RegType&gt;
 90     ALWAYS_INLINE void setupStubArgs(std::array&lt;RegType, NumberOfRegisters&gt; destinations, std::array&lt;RegType, NumberOfRegisters&gt; sources)
 91     {
<span class="line-modified"> 92         if (ASSERT_ENABLED) {</span>
 93             RegisterSet set;
 94             for (RegType dest : destinations)
 95                 set.set(dest);
 96             ASSERT_WITH_MESSAGE(set.numberOfSetRegisters() == NumberOfRegisters, &quot;Destinations should not be aliased.&quot;);
 97         }
 98 
 99         typedef std::pair&lt;RegType, RegType&gt; RegPair;
100         Vector&lt;RegPair, NumberOfRegisters&gt; pairs;
101 
102         for (unsigned i = 0; i &lt; NumberOfRegisters; ++i) {
103             if (sources[i] != destinations[i])
104                 pairs.append(std::make_pair(sources[i], destinations[i]));
105         }
106 
<span class="line-modified">107 #if ASSERT_ENABLED</span>
108         auto numUniqueSources = [&amp;] () -&gt; unsigned {
109             RegisterSet set;
110             for (auto&amp; pair : pairs) {
111                 RegType source = pair.first;
112                 set.set(source);
113             }
114             return set.numberOfSetRegisters();
115         };
116 
117         auto numUniqueDests = [&amp;] () -&gt; unsigned {
118             RegisterSet set;
119             for (auto&amp; pair : pairs) {
120                 RegType dest = pair.second;
121                 set.set(dest);
122             }
123             return set.numberOfSetRegisters();
124         };
125 #endif
126 
127         while (pairs.size()) {
</pre>
<hr />
<pre>
395 
396     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;
397     ALWAYS_INLINE void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, GPRReg arg, Args... args)
398     {
399         marshallArgumentRegister&lt;OperationType&gt;(argSourceRegs, arg, args...);
400     }
401 
402     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;
403     ALWAYS_INLINE void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, JSValueRegs arg, Args... args)
404     {
405         marshallArgumentRegister&lt;OperationType&gt;(argSourceRegs, arg.gpr(), args...);
406     }
407 
408     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;
409     ALWAYS_INLINE void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, CellValue arg, Args... args)
410     {
411         marshallArgumentRegister&lt;OperationType&gt;(argSourceRegs, arg.gpr(), args...);
412     }
413 
414 #else // USE(JSVALUE64)
<span class="line-modified">415 #if CPU(ARM_THUMB2) || CPU(MIPS)</span>




































416 
417     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;
418     void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, FPRReg arg, Args... args)
419     {
420         static_assert(std::is_same&lt;CURRENT_ARGUMENT_TYPE, double&gt;::value, &quot;We should only be passing FPRRegs to a double&quot;);
421 
422         // MIPS and ARM-hardfp pass FP arguments in FP registers.
423 #if CPU(MIPS)
424         unsigned numberOfFPArgumentRegisters = FPRInfo::numberOfArgumentRegisters;
425         unsigned currentFPArgCount = argSourceRegs.argCount(arg);
426 
427         // MIPS can only use FP argument registers if it isn&#39;t preceeded by any GP argument.
428         if (currentFPArgCount &lt; numberOfFPArgumentRegisters &amp;&amp; !numGPRArgs) {
429             auto updatedArgSourceRegs = argSourceRegs.pushRegArg(arg, FPRInfo::toArgumentRegister(currentFPArgCount));
430             setupArgumentsImpl&lt;OperationType&gt;(updatedArgSourceRegs.addGPRExtraArg().addGPRExtraArg(), args...);
431             return;
432         }
433 #elif CPU(ARM_THUMB2) &amp;&amp; CPU(ARM_HARDFP)
434         unsigned numberOfFPArgumentRegisters = FPRInfo::numberOfArgumentRegisters;
435         unsigned currentFPArgCount = argSourceRegs.argCount(arg);
</pre>
<hr />
<pre>
616     }
617 
618     // Special case DFG::RegisteredStructure because it&#39;s really annoying to deal with otherwise...
619     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename Arg, typename... Args&gt;
620     ALWAYS_INLINE std::enable_if_t&lt;
621         std::is_same&lt;CURRENT_ARGUMENT_TYPE, Structure*&gt;::value
622         &amp;&amp; std::is_same&lt;Arg, DFG::RegisteredStructure&gt;::value&gt;
623     setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, Arg arg, Args... args)
624     {
625         setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs, TrustedImmPtr(arg.get()), args...);
626     }
627 
628 #undef CURRENT_ARGUMENT_TYPE
629 #undef RESULT_TYPE
630 
631     // Base case; set up the argument registers.
632     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke&gt;
633     ALWAYS_INLINE void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs)
634     {
635         static_assert(FunctionTraits&lt;OperationType&gt;::arity == numGPRArgs + numFPRArgs, &quot;One last sanity check&quot;);
<span class="line-modified">636 #if USE(JSVALUE64)</span>
637         static_assert(FunctionTraits&lt;OperationType&gt;::cCallArity() == numGPRArgs + numFPRArgs + extraPoke, &quot;Check the CCall arity&quot;);
638 #endif
639         setupStubArgs&lt;numGPRSources, GPRReg&gt;(clampArrayToSize&lt;numGPRSources, GPRReg&gt;(argSourceRegs.gprDestinations), clampArrayToSize&lt;numGPRSources, GPRReg&gt;(argSourceRegs.gprSources));
640 #if CPU(MIPS) || (CPU(ARM_THUMB2) &amp;&amp; !CPU(ARM_HARDFP))
641         setupStubCrossArgs&lt;numCrossSources&gt;(argSourceRegs.crossDestinations, argSourceRegs.crossSources);
642 #else
643         static_assert(!numCrossSources, &quot;shouldn&#39;t be used on this architecture.&quot;);
644 #endif
645         setupStubArgs&lt;numFPRSources, FPRReg&gt;(clampArrayToSize&lt;numFPRSources, FPRReg&gt;(argSourceRegs.fprDestinations), clampArrayToSize&lt;numFPRSources, FPRReg&gt;(argSourceRegs.fprSources));
646     }
647 
648 public:
649 
650 #define FIRST_ARGUMENT_TYPE typename FunctionTraits&lt;OperationType&gt;::template ArgumentType&lt;0&gt;
651 
652     template&lt;typename OperationType, typename... Args&gt;
<span class="line-modified">653     ALWAYS_INLINE std::enable_if_t&lt;std::is_same&lt;FIRST_ARGUMENT_TYPE, CallFrame*&gt;::value&gt; setupArguments(Args... args)</span>
654     {
655 #if USE(JSVALUE64)
656         // This only really works for 64-bit since jsvalue regs mess things up for 32-bit...
657         static_assert(FunctionTraits&lt;OperationType&gt;::cCallArity() == sizeof...(Args) + 1, &quot;Basic sanity check&quot;);
658 #endif
659         setupArgumentsImpl&lt;OperationType, 0, 0, 0, 0, 0, 0, 0&gt;(ArgCollection&lt;0, 0, 0, 0, 0, 0, 0&gt;(), GPRInfo::callFrameRegister, args...);
660     }
661 
662     template&lt;typename OperationType, typename... Args&gt;
<span class="line-modified">663     ALWAYS_INLINE std::enable_if_t&lt;!std::is_same&lt;FIRST_ARGUMENT_TYPE, CallFrame*&gt;::value&gt; setupArguments(Args... args)</span>
664     {
665 #if USE(JSVALUE64)
666         // This only really works for 64-bit since jsvalue regs mess things up for 32-bit...
667         static_assert(FunctionTraits&lt;OperationType&gt;::cCallArity() == sizeof...(Args), &quot;Basic sanity check&quot;);
668 #endif
669         setupArgumentsImpl&lt;OperationType, 0, 0, 0, 0, 0, 0, 0&gt;(ArgCollection&lt;0, 0, 0, 0, 0, 0, 0&gt;(), args...);
670     }
671 
672 #undef FIRST_ARGUMENT_TYPE
673 
674     void setupResults(GPRReg destA, GPRReg destB)
675     {
676         GPRReg srcA = GPRInfo::returnValueGPR;
677         GPRReg srcB = GPRInfo::returnValueGPR2;
678 
679         if (destA == InvalidGPRReg)
680             move(srcB, destB);
681         else if (destB == InvalidGPRReg)
682             move(srcA, destA);
683         else if (srcB != destA) {
</pre>
<hr />
<pre>
707         // and the address of the handler in vm-&gt;targetMachinePCForThrow.
708         loadPtr(&amp;vm.targetMachinePCForThrow, GPRInfo::regT1);
709         farJump(GPRInfo::regT1, ExceptionHandlerPtrTag);
710     }
711 
712     void prepareForTailCallSlow(GPRReg calleeGPR = InvalidGPRReg)
713     {
714         GPRReg temp1 = calleeGPR == GPRInfo::regT0 ? GPRInfo::regT3 : GPRInfo::regT0;
715         GPRReg temp2 = calleeGPR == GPRInfo::regT1 ? GPRInfo::regT3 : GPRInfo::regT1;
716         GPRReg temp3 = calleeGPR == GPRInfo::regT2 ? GPRInfo::regT3 : GPRInfo::regT2;
717 
718         GPRReg newFramePointer = temp1;
719         GPRReg newFrameSizeGPR = temp2;
720         {
721             // The old frame size is its number of arguments (or number of
722             // parameters in case of arity fixup), plus the frame header size,
723             // aligned
724             GPRReg oldFrameSizeGPR = temp2;
725             {
726                 GPRReg argCountGPR = oldFrameSizeGPR;
<span class="line-modified">727                 load32(Address(framePointerRegister, CallFrameSlot::argumentCountIncludingThis * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset), argCountGPR);</span>
728 
729                 {
730                     GPRReg numParametersGPR = temp1;
731                     {
732                         GPRReg codeBlockGPR = numParametersGPR;
733                         loadPtr(Address(framePointerRegister, CallFrameSlot::codeBlock * static_cast&lt;int&gt;(sizeof(Register))), codeBlockGPR);
734                         load32(Address(codeBlockGPR, CodeBlock::offsetOfNumParameters()), numParametersGPR);
735                     }
736 
737                     ASSERT(numParametersGPR != argCountGPR);
738                     Jump argumentCountWasNotFixedUp = branch32(BelowOrEqual, numParametersGPR, argCountGPR);
739                     move(numParametersGPR, argCountGPR);
740                     argumentCountWasNotFixedUp.link(this);
741                 }
742 
743                 add32(TrustedImm32(stackAlignmentRegisters() + CallFrame::headerSizeInRegisters - 1), argCountGPR, oldFrameSizeGPR);
744                 and32(TrustedImm32(-stackAlignmentRegisters()), oldFrameSizeGPR);
745                 // We assume &lt; 2^28 arguments
746                 mul32(TrustedImm32(sizeof(Register)), oldFrameSizeGPR, oldFrameSizeGPR);
747             }
748 
749             // The new frame pointer is at framePointer + oldFrameSize - newFrameSize
750             ASSERT(newFramePointer != oldFrameSizeGPR);
751             addPtr(framePointerRegister, oldFrameSizeGPR, newFramePointer);
752 
753             // The new frame size is just the number of arguments plus the
754             // frame header size, aligned
755             ASSERT(newFrameSizeGPR != newFramePointer);
<span class="line-modified">756             load32(Address(stackPointerRegister, CallFrameSlot::argumentCountIncludingThis * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset - sizeof(CallerFrameAndPC)),</span>
757                 newFrameSizeGPR);
758             add32(TrustedImm32(stackAlignmentRegisters() + CallFrame::headerSizeInRegisters - 1), newFrameSizeGPR);
759             and32(TrustedImm32(-stackAlignmentRegisters()), newFrameSizeGPR);
760             // We assume &lt; 2^28 arguments
761             mul32(TrustedImm32(sizeof(Register)), newFrameSizeGPR, newFrameSizeGPR);
762         }
763 
764         GPRReg tempGPR = temp3;
765         ASSERT(tempGPR != newFramePointer &amp;&amp; tempGPR != newFrameSizeGPR);
766 
767         // We don&#39;t need the current frame beyond this point. Masquerade as our
768         // caller.
769 #if CPU(ARM_THUMB2) || CPU(ARM64)
770         loadPtr(Address(framePointerRegister, CallFrame::returnPCOffset()), linkRegister);
771         subPtr(TrustedImm32(2 * sizeof(void*)), newFrameSizeGPR);
772 #if CPU(ARM64E)
773         addPtr(TrustedImm32(sizeof(CallerFrameAndPC)), MacroAssembler::framePointerRegister, tempGPR);
774         untagPtr(tempGPR, linkRegister);
775 #endif
776 #elif CPU(MIPS)
777         loadPtr(Address(framePointerRegister, sizeof(void*)), returnAddressRegister);
778         subPtr(TrustedImm32(2 * sizeof(void*)), newFrameSizeGPR);
<span class="line-modified">779 #elif CPU(X86_64)</span>
780         loadPtr(Address(framePointerRegister, sizeof(void*)), tempGPR);
781         push(tempGPR);
782         subPtr(TrustedImm32(sizeof(void*)), newFrameSizeGPR);
783 #else
784         UNREACHABLE_FOR_PLATFORM();
785 #endif
786         subPtr(newFrameSizeGPR, newFramePointer);
787         loadPtr(Address(framePointerRegister), framePointerRegister);
788 
789 
790         // We need to move the newFrameSizeGPR slots above the stack pointer by
791         // newFramePointer registers. We use pointer-sized chunks.
792         MacroAssembler::Label copyLoop(label());
793 
794         subPtr(TrustedImm32(sizeof(void*)), newFrameSizeGPR);
795         loadPtr(BaseIndex(stackPointerRegister, newFrameSizeGPR, TimesOne), tempGPR);
796         storePtr(tempGPR, BaseIndex(newFramePointer, newFrameSizeGPR, TimesOne));
797 
798         branchTest32(MacroAssembler::NonZero, newFrameSizeGPR).linkTo(copyLoop, this);
799 
</pre>
</td>
</tr>
</table>
<center><a href="CCallHelpers.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallFrameShuffleData.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
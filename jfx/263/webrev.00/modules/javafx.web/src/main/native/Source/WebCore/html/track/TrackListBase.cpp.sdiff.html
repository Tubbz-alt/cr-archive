<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/track/TrackListBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TrackEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TrackListBase.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/track/TrackListBase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(VIDEO_TRACK)
 29 
 30 #include &quot;TrackListBase.h&quot;
 31 
 32 #include &quot;EventNames.h&quot;
 33 #include &quot;HTMLMediaElement.h&quot;
 34 #include &quot;ScriptExecutionContext.h&quot;
 35 #include &quot;TrackEvent.h&quot;
 36 #include &lt;wtf/IsoMallocInlines.h&gt;
 37 
 38 namespace WebCore {
 39 
 40 WTF_MAKE_ISO_ALLOCATED_IMPL(TrackListBase);
 41 
<span class="line-modified"> 42 TrackListBase::TrackListBase(HTMLMediaElement* element, ScriptExecutionContext* context)</span>
<span class="line-modified"> 43     : ActiveDOMObject(context)</span>
 44     , m_element(element)
<span class="line-modified"> 45     , m_asyncEventQueue(*this)</span>
 46 {
 47     ASSERT(!context || is&lt;Document&gt;(context));
<span class="line-removed"> 48     suspendIfNeeded();</span>
 49 }
 50 
 51 TrackListBase::~TrackListBase()
 52 {
 53     clearElement();
 54 }
 55 
 56 void TrackListBase::clearElement()
 57 {
 58     m_element = nullptr;
 59     for (auto&amp; track : m_inbandTracks) {
 60         track-&gt;setMediaElement(nullptr);
 61         track-&gt;clearClient();
 62     }
 63 }
 64 
 65 Element* TrackListBase::element() const
 66 {
<span class="line-modified"> 67     return m_element;</span>
 68 }
 69 
 70 unsigned TrackListBase::length() const
 71 {
 72     return m_inbandTracks.size();
 73 }
 74 
 75 void TrackListBase::remove(TrackBase&amp; track, bool scheduleEvent)
 76 {
 77     size_t index = m_inbandTracks.find(&amp;track);
 78     if (index == notFound)
 79         return;
 80 
 81     if (track.mediaElement()) {
 82         ASSERT(track.mediaElement() == m_element);
 83         track.setMediaElement(nullptr);
 84     }
 85 
 86     Ref&lt;TrackBase&gt; trackRef = *m_inbandTracks[index];
 87 
 88     m_inbandTracks.remove(index);
 89 
 90     if (scheduleEvent)
 91         scheduleRemoveTrackEvent(WTFMove(trackRef));
 92 }
 93 
 94 bool TrackListBase::contains(TrackBase&amp; track) const
 95 {
 96     return m_inbandTracks.find(&amp;track) != notFound;
 97 }
 98 
 99 void TrackListBase::scheduleTrackEvent(const AtomString&amp; eventName, Ref&lt;TrackBase&gt;&amp;&amp; track)
100 {
<span class="line-modified">101     m_asyncEventQueue.enqueueEvent(TrackEvent::create(eventName, Event::CanBubble::No, Event::IsCancelable::No, WTFMove(track)));</span>
102 }
103 
104 void TrackListBase::scheduleAddTrackEvent(Ref&lt;TrackBase&gt;&amp;&amp; track)
105 {
106     // 4.8.10.5 Loading the media resource
107     // ...
108     // Fire a trusted event with the name addtrack, that does not bubble and is
109     // not cancelable, and that uses the TrackEvent interface, with the track
110     // attribute initialized to the new AudioTrack object, at this
111     // AudioTrackList object.
112     // ...
113     // Fire a trusted event with the name addtrack, that does not bubble and is
114     // not cancelable, and that uses the TrackEvent interface, with the track
115     // attribute initialized to the new VideoTrack object, at this
116     // VideoTrackList object.
117 
118     // 4.8.10.12.3 Sourcing out-of-band text tracks
119     // 4.8.10.12.4 Text track API
120     // ... then queue a task to fire an event with the name addtrack, that does not
121     // bubble and is not cancelable, and that uses the TrackEvent interface, with
</pre>
<hr />
<pre>
144     // media element, then the user agent must remove the track element&#39;s
145     // corresponding text track from the media element&#39;s list of text tracks,
146     // and then queue a task to fire a trusted event with the name removetrack,
147     // that does not bubble and is not cancelable, and that uses the TrackEvent
148     // interface, with the track attribute initialized to the text track&#39;s
149     // TextTrack object, at the media element&#39;s textTracks attribute&#39;s
150     // TextTrackList object.
151     scheduleTrackEvent(eventNames().removetrackEvent, WTFMove(track));
152 }
153 
154 void TrackListBase::scheduleChangeEvent()
155 {
156     // 4.8.10.6 Offsets into the media resource
157     // Whenever an audio track in an AudioTrackList is enabled or disabled, the
158     // user agent must queue a task to fire a simple event named change at the
159     // AudioTrackList object.
160     // ...
161     // Whenever a track in a VideoTrackList that was previously not selected is
162     // selected, the user agent must queue a task to fire a simple event named
163     // change at the VideoTrackList object.
<span class="line-modified">164     m_asyncEventQueue.enqueueEvent(Event::create(eventNames().changeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
165 }
166 
167 bool TrackListBase::isChangeEventScheduled() const
168 {
<span class="line-modified">169     return m_asyncEventQueue.hasPendingEventsOfType(eventNames().changeEvent);</span>
170 }
171 
172 bool TrackListBase::isAnyTrackEnabled() const
173 {
174     for (auto&amp; track : m_inbandTracks) {
175         if (track-&gt;enabled())
176             return true;
177     }
178     return false;
179 }
180 
<span class="line-removed">181 bool TrackListBase::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">182 {</span>
<span class="line-removed">183     return !m_asyncEventQueue.hasPendingEvents();</span>
<span class="line-removed">184 }</span>
<span class="line-removed">185 </span>
<span class="line-removed">186 void TrackListBase::suspend(ReasonForSuspension reason)</span>
<span class="line-removed">187 {</span>
<span class="line-removed">188     switch (reason) {</span>
<span class="line-removed">189     case ReasonForSuspension::PageCache:</span>
<span class="line-removed">190     case ReasonForSuspension::PageWillBeSuspended:</span>
<span class="line-removed">191         m_asyncEventQueue.suspend();</span>
<span class="line-removed">192         break;</span>
<span class="line-removed">193     case ReasonForSuspension::JavaScriptDebuggerPaused:</span>
<span class="line-removed">194     case ReasonForSuspension::WillDeferLoading:</span>
<span class="line-removed">195         // Do nothing, we don&#39;t pause media playback in these cases.</span>
<span class="line-removed">196         break;</span>
<span class="line-removed">197     }</span>
<span class="line-removed">198 }</span>
<span class="line-removed">199 </span>
<span class="line-removed">200 void TrackListBase::resume()</span>
<span class="line-removed">201 {</span>
<span class="line-removed">202     m_asyncEventQueue.resume();</span>
<span class="line-removed">203 }</span>
<span class="line-removed">204 </span>
<span class="line-removed">205 void TrackListBase::stop()</span>
<span class="line-removed">206 {</span>
<span class="line-removed">207     m_asyncEventQueue.close();</span>
<span class="line-removed">208 }</span>
<span class="line-removed">209 </span>
210 } // namespace WebCore
211 
212 #endif
</pre>
</td>
<td>
<hr />
<pre>
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(VIDEO_TRACK)
 29 
 30 #include &quot;TrackListBase.h&quot;
 31 
 32 #include &quot;EventNames.h&quot;
 33 #include &quot;HTMLMediaElement.h&quot;
 34 #include &quot;ScriptExecutionContext.h&quot;
 35 #include &quot;TrackEvent.h&quot;
 36 #include &lt;wtf/IsoMallocInlines.h&gt;
 37 
 38 namespace WebCore {
 39 
 40 WTF_MAKE_ISO_ALLOCATED_IMPL(TrackListBase);
 41 
<span class="line-modified"> 42 TrackListBase::TrackListBase(WeakPtr&lt;HTMLMediaElement&gt; element, ScriptExecutionContext* context)</span>
<span class="line-modified"> 43     : ContextDestructionObserver(context)</span>
 44     , m_element(element)
<span class="line-modified"> 45     , m_asyncEventQueue(MainThreadGenericEventQueue::create(*this))</span>
 46 {
 47     ASSERT(!context || is&lt;Document&gt;(context));

 48 }
 49 
 50 TrackListBase::~TrackListBase()
 51 {
 52     clearElement();
 53 }
 54 
 55 void TrackListBase::clearElement()
 56 {
 57     m_element = nullptr;
 58     for (auto&amp; track : m_inbandTracks) {
 59         track-&gt;setMediaElement(nullptr);
 60         track-&gt;clearClient();
 61     }
 62 }
 63 
 64 Element* TrackListBase::element() const
 65 {
<span class="line-modified"> 66     return m_element.get();</span>
 67 }
 68 
 69 unsigned TrackListBase::length() const
 70 {
 71     return m_inbandTracks.size();
 72 }
 73 
 74 void TrackListBase::remove(TrackBase&amp; track, bool scheduleEvent)
 75 {
 76     size_t index = m_inbandTracks.find(&amp;track);
 77     if (index == notFound)
 78         return;
 79 
 80     if (track.mediaElement()) {
 81         ASSERT(track.mediaElement() == m_element);
 82         track.setMediaElement(nullptr);
 83     }
 84 
 85     Ref&lt;TrackBase&gt; trackRef = *m_inbandTracks[index];
 86 
 87     m_inbandTracks.remove(index);
 88 
 89     if (scheduleEvent)
 90         scheduleRemoveTrackEvent(WTFMove(trackRef));
 91 }
 92 
 93 bool TrackListBase::contains(TrackBase&amp; track) const
 94 {
 95     return m_inbandTracks.find(&amp;track) != notFound;
 96 }
 97 
 98 void TrackListBase::scheduleTrackEvent(const AtomString&amp; eventName, Ref&lt;TrackBase&gt;&amp;&amp; track)
 99 {
<span class="line-modified">100     m_asyncEventQueue-&gt;enqueueEvent(TrackEvent::create(eventName, Event::CanBubble::No, Event::IsCancelable::No, WTFMove(track)));</span>
101 }
102 
103 void TrackListBase::scheduleAddTrackEvent(Ref&lt;TrackBase&gt;&amp;&amp; track)
104 {
105     // 4.8.10.5 Loading the media resource
106     // ...
107     // Fire a trusted event with the name addtrack, that does not bubble and is
108     // not cancelable, and that uses the TrackEvent interface, with the track
109     // attribute initialized to the new AudioTrack object, at this
110     // AudioTrackList object.
111     // ...
112     // Fire a trusted event with the name addtrack, that does not bubble and is
113     // not cancelable, and that uses the TrackEvent interface, with the track
114     // attribute initialized to the new VideoTrack object, at this
115     // VideoTrackList object.
116 
117     // 4.8.10.12.3 Sourcing out-of-band text tracks
118     // 4.8.10.12.4 Text track API
119     // ... then queue a task to fire an event with the name addtrack, that does not
120     // bubble and is not cancelable, and that uses the TrackEvent interface, with
</pre>
<hr />
<pre>
143     // media element, then the user agent must remove the track element&#39;s
144     // corresponding text track from the media element&#39;s list of text tracks,
145     // and then queue a task to fire a trusted event with the name removetrack,
146     // that does not bubble and is not cancelable, and that uses the TrackEvent
147     // interface, with the track attribute initialized to the text track&#39;s
148     // TextTrack object, at the media element&#39;s textTracks attribute&#39;s
149     // TextTrackList object.
150     scheduleTrackEvent(eventNames().removetrackEvent, WTFMove(track));
151 }
152 
153 void TrackListBase::scheduleChangeEvent()
154 {
155     // 4.8.10.6 Offsets into the media resource
156     // Whenever an audio track in an AudioTrackList is enabled or disabled, the
157     // user agent must queue a task to fire a simple event named change at the
158     // AudioTrackList object.
159     // ...
160     // Whenever a track in a VideoTrackList that was previously not selected is
161     // selected, the user agent must queue a task to fire a simple event named
162     // change at the VideoTrackList object.
<span class="line-modified">163     m_asyncEventQueue-&gt;enqueueEvent(Event::create(eventNames().changeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
164 }
165 
166 bool TrackListBase::isChangeEventScheduled() const
167 {
<span class="line-modified">168     return m_asyncEventQueue-&gt;hasPendingEventsOfType(eventNames().changeEvent);</span>
169 }
170 
171 bool TrackListBase::isAnyTrackEnabled() const
172 {
173     for (auto&amp; track : m_inbandTracks) {
174         if (track-&gt;enabled())
175             return true;
176     }
177     return false;
178 }
179 





























180 } // namespace WebCore
181 
182 #endif
</pre>
</td>
</tr>
</table>
<center><a href="TrackEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TrackListBase.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
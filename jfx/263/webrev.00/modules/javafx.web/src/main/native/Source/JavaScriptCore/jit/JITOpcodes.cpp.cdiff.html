<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOpcodes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITNegGenerator.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITOpcodes32_64.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOpcodes.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,11 ***</span>
  #include &quot;config.h&quot;
  #if ENABLE(JIT)
  #include &quot;JIT.h&quot;
  
  #include &quot;BasicBlockLocation.h&quot;
<span class="line-modified">! #include &quot;BytecodeStructs.h&quot;</span>
  #include &quot;Exception.h&quot;
  #include &quot;Heap.h&quot;
  #include &quot;InterpreterInlines.h&quot;
  #include &quot;JITInlines.h&quot;
  #include &quot;JSArray.h&quot;
<span class="line-new-header">--- 27,11 ---</span>
  #include &quot;config.h&quot;
  #if ENABLE(JIT)
  #include &quot;JIT.h&quot;
  
  #include &quot;BasicBlockLocation.h&quot;
<span class="line-modified">! #include &quot;BytecodeGenerator.h&quot;</span>
  #include &quot;Exception.h&quot;
  #include &quot;Heap.h&quot;
  #include &quot;InterpreterInlines.h&quot;
  #include &quot;JITInlines.h&quot;
  #include &quot;JSArray.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,14 ***</span>
  #if USE(JSVALUE64)
  
  void JIT::emit_op_mov(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpMov&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int src = bytecode.m_src.offset();</span>
  
<span class="line-modified">!     if (m_codeBlock-&gt;isConstantRegisterIndex(src)) {</span>
          JSValue value = m_codeBlock-&gt;getConstant(src);
          if (!value.isNumber())
              store64(TrustedImm64(JSValue::encode(value)), addressFor(dst));
          else
              store64(Imm64(JSValue::encode(value)), addressFor(dst));
<span class="line-new-header">--- 54,14 ---</span>
  #if USE(JSVALUE64)
  
  void JIT::emit_op_mov(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpMov&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister src = bytecode.m_src;</span>
  
<span class="line-modified">!     if (src.isConstant()) {</span>
          JSValue value = m_codeBlock-&gt;getConstant(src);
          if (!value.isNumber())
              store64(TrustedImm64(JSValue::encode(value)), addressFor(dst));
          else
              store64(Imm64(JSValue::encode(value)), addressFor(dst));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 75,11 ***</span>
  
  void JIT::emit_op_end(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEnd&gt;();
      RELEASE_ASSERT(returnValueGPR != callFrameRegister);
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_value.offset(), returnValueGPR);</span>
      emitRestoreCalleeSaves();
      emitFunctionEpilogue();
      ret();
  }
  
<span class="line-new-header">--- 75,11 ---</span>
  
  void JIT::emit_op_end(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEnd&gt;();
      RELEASE_ASSERT(returnValueGPR != callFrameRegister);
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_value, returnValueGPR);</span>
      emitRestoreCalleeSaves();
      emitFunctionEpilogue();
      ret();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 108,32 ***</span>
          JumpList slowCases;
          auto butterfly = TrustedImmPtr(nullptr);
          emitAllocateJSObject(resultReg, JITAllocator::constant(allocator), allocatorReg, TrustedImmPtr(structure), butterfly, scratchReg, slowCases);
          emitInitializeInlineStorage(resultReg, structure-&gt;inlineCapacity());
          addSlowCase(slowCases);
<span class="line-modified">!         emitPutVirtualRegister(bytecode.m_dst.offset());</span>
      }
  }
  
  void JIT::emitSlow_op_new_object(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpNewObject&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
      Structure* structure = metadata.m_objectAllocationProfile.structure();
<span class="line-modified">!     callOperation(operationNewObject, structure);</span>
      emitStoreCell(dst, returnValueGPR);
  }
  
  void JIT::emit_op_overrides_has_instance(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpOverridesHasInstance&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int constructor = bytecode.m_constructor.offset();</span>
<span class="line-modified">!     int hasInstanceValue = bytecode.m_hasInstanceValue.offset();</span>
  
      emitGetVirtualRegister(hasInstanceValue, regT0);
  
      // We don&#39;t jump if we know what Symbol.hasInstance would do.
      Jump customhasInstanceValue = branchPtr(NotEqual, regT0, TrustedImmPtr(m_codeBlock-&gt;globalObject()-&gt;functionProtoHasInstanceSymbolFunction()));
<span class="line-new-header">--- 108,32 ---</span>
          JumpList slowCases;
          auto butterfly = TrustedImmPtr(nullptr);
          emitAllocateJSObject(resultReg, JITAllocator::constant(allocator), allocatorReg, TrustedImmPtr(structure), butterfly, scratchReg, slowCases);
          emitInitializeInlineStorage(resultReg, structure-&gt;inlineCapacity());
          addSlowCase(slowCases);
<span class="line-modified">!         emitPutVirtualRegister(bytecode.m_dst);</span>
      }
  }
  
  void JIT::emitSlow_op_new_object(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpNewObject&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
      Structure* structure = metadata.m_objectAllocationProfile.structure();
<span class="line-modified">!     callOperation(operationNewObject, TrustedImmPtr(&amp;vm()), structure);</span>
      emitStoreCell(dst, returnValueGPR);
  }
  
  void JIT::emit_op_overrides_has_instance(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpOverridesHasInstance&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister constructor = bytecode.m_constructor;</span>
<span class="line-modified">!     VirtualRegister hasInstanceValue = bytecode.m_hasInstanceValue;</span>
  
      emitGetVirtualRegister(hasInstanceValue, regT0);
  
      // We don&#39;t jump if we know what Symbol.hasInstance would do.
      Jump customhasInstanceValue = branchPtr(NotEqual, regT0, TrustedImmPtr(m_codeBlock-&gt;globalObject()-&gt;functionProtoHasInstanceSymbolFunction()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 144,22 ***</span>
      test8(Zero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(ImplementsDefaultHasInstance), regT0);
      boxBoolean(regT0, JSValueRegs { regT0 });
      Jump done = jump();
  
      customhasInstanceValue.link(this);
<span class="line-modified">!     move(TrustedImm32(ValueTrue), regT0);</span>
  
      done.link(this);
      emitPutVirtualRegister(dst);
  }
  
  void JIT::emit_op_instanceof(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpInstanceof&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
<span class="line-modified">!     int proto = bytecode.m_prototype.offset();</span>
  
      // Load the operands (baseVal, proto, and value respectively) into registers.
      // We use regT0 for baseVal since we will be done with this first, and we can then use it for the result.
      emitGetVirtualRegister(value, regT2);
      emitGetVirtualRegister(proto, regT1);
<span class="line-new-header">--- 144,22 ---</span>
      test8(Zero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(ImplementsDefaultHasInstance), regT0);
      boxBoolean(regT0, JSValueRegs { regT0 });
      Jump done = jump();
  
      customhasInstanceValue.link(this);
<span class="line-modified">!     move(TrustedImm32(JSValue::ValueTrue), regT0);</span>
  
      done.link(this);
      emitPutVirtualRegister(dst);
  }
  
  void JIT::emit_op_instanceof(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpInstanceof&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
<span class="line-modified">!     VirtualRegister proto = bytecode.m_prototype;</span>
  
      // Load the operands (baseVal, proto, and value respectively) into registers.
      // We use regT0 for baseVal since we will be done with this first, and we can then use it for the result.
      emitGetVirtualRegister(value, regT2);
      emitGetVirtualRegister(proto, regT1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 167,11 ***</span>
      // Check that proto are cells. baseVal must be a cell - this is checked by the get_by_id for Symbol.hasInstance.
      emitJumpSlowCaseIfNotJSCell(regT2, value);
      emitJumpSlowCaseIfNotJSCell(regT1, proto);
  
      JITInstanceOfGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(m_bytecodeOffset),</span>
          RegisterSet::stubUnavailableRegisters(),
          regT0, // result
          regT2, // value
          regT1, // proto
          regT3, regT4); // scratch
<span class="line-new-header">--- 167,11 ---</span>
      // Check that proto are cells. baseVal must be a cell - this is checked by the get_by_id for Symbol.hasInstance.
      emitJumpSlowCaseIfNotJSCell(regT2, value);
      emitJumpSlowCaseIfNotJSCell(regT1, proto);
  
      JITInstanceOfGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex),</span>
          RegisterSet::stubUnavailableRegisters(),
          regT0, // result
          regT2, // value
          regT1, // proto
          regT3, regT4); // scratch
</pre>
<hr />
<pre>
<span class="line-old-header">*** 184,16 ***</span>
  void JIT::emitSlow_op_instanceof(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpInstanceof&gt;();
<span class="line-modified">!     int resultVReg = bytecode.m_dst.offset();</span>
  
      JITInstanceOfGenerator&amp; gen = m_instanceOfs[m_instanceOfIndex++];
  
      Label coldPathBegin = label();
<span class="line-modified">!     Call call = callOperation(operationInstanceOfOptimize, resultVReg, gen.stubInfo(), regT2, regT1);</span>
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emit_op_instanceof_custom(const Instruction*)
  {
<span class="line-new-header">--- 184,16 ---</span>
  void JIT::emitSlow_op_instanceof(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpInstanceof&gt;();
<span class="line-modified">!     VirtualRegister resultVReg = bytecode.m_dst;</span>
  
      JITInstanceOfGenerator&amp; gen = m_instanceOfs[m_instanceOfIndex++];
  
      Label coldPathBegin = label();
<span class="line-modified">!     Call call = callOperation(operationInstanceOfOptimize, resultVReg, TrustedImmPtr(m_codeBlock-&gt;globalObject()), gen.stubInfo(), regT2, regT1);</span>
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emit_op_instanceof_custom(const Instruction*)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 202,12 ***</span>
  }
  
  void JIT::emit_op_is_empty(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsEmpty&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int value = bytecode.m_operand.offset();</span>
  
      emitGetVirtualRegister(value, regT0);
      compare64(Equal, regT0, TrustedImm32(JSValue::encode(JSValue())), regT0);
  
      boxBoolean(regT0, JSValueRegs { regT0 });
<span class="line-new-header">--- 202,12 ---</span>
  }
  
  void JIT::emit_op_is_empty(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsEmpty&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_operand;</span>
  
      emitGetVirtualRegister(value, regT0);
      compare64(Equal, regT0, TrustedImm32(JSValue::encode(JSValue())), regT0);
  
      boxBoolean(regT0, JSValueRegs { regT0 });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 215,17 ***</span>
  }
  
  void JIT::emit_op_is_undefined(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsUndefined&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int value = bytecode.m_operand.offset();</span>
  
      emitGetVirtualRegister(value, regT0);
      Jump isCell = branchIfCell(regT0);
  
<span class="line-modified">!     compare64(Equal, regT0, TrustedImm32(ValueUndefined), regT0);</span>
      Jump done = jump();
  
      isCell.link(this);
      Jump isMasqueradesAsUndefined = branchTest8(NonZero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined));
      move(TrustedImm32(0), regT0);
<span class="line-new-header">--- 215,17 ---</span>
  }
  
  void JIT::emit_op_is_undefined(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsUndefined&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_operand;</span>
  
      emitGetVirtualRegister(value, regT0);
      Jump isCell = branchIfCell(regT0);
  
<span class="line-modified">!     compare64(Equal, regT0, TrustedImm32(JSValue::ValueUndefined), regT0);</span>
      Jump done = jump();
  
      isCell.link(this);
      Jump isMasqueradesAsUndefined = branchTest8(NonZero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined));
      move(TrustedImm32(0), regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,83 ***</span>
  }
  
  void JIT::emit_op_is_undefined_or_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsUndefinedOrNull&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int value = bytecode.m_operand.offset();</span>
  
      emitGetVirtualRegister(value, regT0);
  
<span class="line-modified">!     and64(TrustedImm32(~TagBitUndefined), regT0);</span>
<span class="line-modified">!     compare64(Equal, regT0, TrustedImm32(ValueNull), regT0);</span>
  
      boxBoolean(regT0, JSValueRegs { regT0 });
      emitPutVirtualRegister(dst);
  }
  
  void JIT::emit_op_is_boolean(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsBoolean&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int value = bytecode.m_operand.offset();</span>
  
      emitGetVirtualRegister(value, regT0);
<span class="line-modified">!     xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), regT0);</span>
      test64(Zero, regT0, TrustedImm32(static_cast&lt;int32_t&gt;(~1)), regT0);
      boxBoolean(regT0, JSValueRegs { regT0 });
      emitPutVirtualRegister(dst);
  }
  
  void JIT::emit_op_is_number(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsNumber&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int value = bytecode.m_operand.offset();</span>
  
      emitGetVirtualRegister(value, regT0);
<span class="line-modified">!     test64(NonZero, regT0, tagTypeNumberRegister, regT0);</span>
      boxBoolean(regT0, JSValueRegs { regT0 });
      emitPutVirtualRegister(dst);
  }
  
  void JIT::emit_op_is_cell_with_type(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsCellWithType&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int value = bytecode.m_operand.offset();</span>
      int type = bytecode.m_type;
  
      emitGetVirtualRegister(value, regT0);
      Jump isNotCell = branchIfNotCell(regT0);
  
      compare8(Equal, Address(regT0, JSCell::typeInfoTypeOffset()), TrustedImm32(type), regT0);
      boxBoolean(regT0, JSValueRegs { regT0 });
      Jump done = jump();
  
      isNotCell.link(this);
<span class="line-modified">!     move(TrustedImm32(ValueFalse), regT0);</span>
  
      done.link(this);
      emitPutVirtualRegister(dst);
  }
  
  void JIT::emit_op_is_object(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsObject&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int value = bytecode.m_operand.offset();</span>
  
      emitGetVirtualRegister(value, regT0);
      Jump isNotCell = branchIfNotCell(regT0);
  
      compare8(AboveOrEqual, Address(regT0, JSCell::typeInfoTypeOffset()), TrustedImm32(ObjectType), regT0);
      boxBoolean(regT0, JSValueRegs { regT0 });
      Jump done = jump();
  
      isNotCell.link(this);
<span class="line-modified">!     move(TrustedImm32(ValueFalse), regT0);</span>
  
      done.link(this);
      emitPutVirtualRegister(dst);
  }
  
<span class="line-new-header">--- 244,83 ---</span>
  }
  
  void JIT::emit_op_is_undefined_or_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsUndefinedOrNull&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_operand;</span>
  
      emitGetVirtualRegister(value, regT0);
  
<span class="line-modified">!     and64(TrustedImm32(~JSValue::UndefinedTag), regT0);</span>
<span class="line-modified">!     compare64(Equal, regT0, TrustedImm32(JSValue::ValueNull), regT0);</span>
  
      boxBoolean(regT0, JSValueRegs { regT0 });
      emitPutVirtualRegister(dst);
  }
  
  void JIT::emit_op_is_boolean(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsBoolean&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_operand;</span>
  
      emitGetVirtualRegister(value, regT0);
<span class="line-modified">!     xor64(TrustedImm32(JSValue::ValueFalse), regT0);</span>
      test64(Zero, regT0, TrustedImm32(static_cast&lt;int32_t&gt;(~1)), regT0);
      boxBoolean(regT0, JSValueRegs { regT0 });
      emitPutVirtualRegister(dst);
  }
  
  void JIT::emit_op_is_number(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsNumber&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_operand;</span>
  
      emitGetVirtualRegister(value, regT0);
<span class="line-modified">!     test64(NonZero, regT0, numberTagRegister, regT0);</span>
      boxBoolean(regT0, JSValueRegs { regT0 });
      emitPutVirtualRegister(dst);
  }
  
  void JIT::emit_op_is_cell_with_type(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsCellWithType&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_operand;</span>
      int type = bytecode.m_type;
  
      emitGetVirtualRegister(value, regT0);
      Jump isNotCell = branchIfNotCell(regT0);
  
      compare8(Equal, Address(regT0, JSCell::typeInfoTypeOffset()), TrustedImm32(type), regT0);
      boxBoolean(regT0, JSValueRegs { regT0 });
      Jump done = jump();
  
      isNotCell.link(this);
<span class="line-modified">!     move(TrustedImm32(JSValue::ValueFalse), regT0);</span>
  
      done.link(this);
      emitPutVirtualRegister(dst);
  }
  
  void JIT::emit_op_is_object(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsObject&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_operand;</span>
  
      emitGetVirtualRegister(value, regT0);
      Jump isNotCell = branchIfNotCell(regT0);
  
      compare8(AboveOrEqual, Address(regT0, JSCell::typeInfoTypeOffset()), TrustedImm32(ObjectType), regT0);
      boxBoolean(regT0, JSValueRegs { regT0 });
      Jump done = jump();
  
      isNotCell.link(this);
<span class="line-modified">!     move(TrustedImm32(JSValue::ValueFalse), regT0);</span>
  
      done.link(this);
      emitPutVirtualRegister(dst);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 330,23 ***</span>
      ASSERT(regT1 != returnValueGPR);
      ASSERT(returnValueGPR != callFrameRegister);
  
      // Return the result in %eax.
      auto bytecode = currentInstruction-&gt;as&lt;OpRet&gt;();
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_value.offset(), returnValueGPR);</span>
  
      checkStackPointerAlignment();
      emitRestoreCalleeSaves();
      emitFunctionEpilogue();
      ret();
  }
  
  void JIT::emit_op_to_primitive(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToPrimitive&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int src = bytecode.m_src.offset();</span>
  
      emitGetVirtualRegister(src, regT0);
  
      Jump isImm = branchIfNotCell(regT0);
      addSlowCase(branchIfObject(regT0));
<span class="line-new-header">--- 330,23 ---</span>
      ASSERT(regT1 != returnValueGPR);
      ASSERT(returnValueGPR != callFrameRegister);
  
      // Return the result in %eax.
      auto bytecode = currentInstruction-&gt;as&lt;OpRet&gt;();
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_value, returnValueGPR);</span>
  
      checkStackPointerAlignment();
      emitRestoreCalleeSaves();
      emitFunctionEpilogue();
      ret();
  }
  
  void JIT::emit_op_to_primitive(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToPrimitive&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister src = bytecode.m_src;</span>
  
      emitGetVirtualRegister(src, regT0);
  
      Jump isImm = branchIfNotCell(regT0);
      addSlowCase(branchIfObject(regT0));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 355,31 ***</span>
      if (dst != src)
          emitPutVirtualRegister(dst);
  
  }
  
  void JIT::emit_op_set_function_name(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSetFunctionName&gt;();
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_function.offset(), regT0);</span>
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_name.offset(), regT1);</span>
<span class="line-modified">!     callOperation(operationSetFunctionName, regT0, regT1);</span>
  }
  
  void JIT::emit_op_not(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNot&gt;();
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_operand.offset(), regT0);</span>
  
      // Invert against JSValue(false); if the value was tagged as a boolean, then all bits will be
      // clear other than the low bit (which will be 0 or 1 for false or true inputs respectively).
      // Then invert against JSValue(true), which will add the tag back in, and flip the low bit.
<span class="line-modified">!     xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), regT0);</span>
      addSlowCase(branchTestPtr(NonZero, regT0, TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
<span class="line-modified">!     xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueTrue)), regT0);</span>
  
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_dst.offset());</span>
  }
  
  void JIT::emit_op_jfalse(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJfalse&gt;();
<span class="line-new-header">--- 355,48 ---</span>
      if (dst != src)
          emitPutVirtualRegister(dst);
  
  }
  
<span class="line-added">+ void JIT::emit_op_to_property_key(const Instruction* currentInstruction)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto bytecode = currentInstruction-&gt;as&lt;OpToPropertyKey&gt;();</span>
<span class="line-added">+     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-added">+     VirtualRegister src = bytecode.m_src;</span>
<span class="line-added">+ </span>
<span class="line-added">+     emitGetVirtualRegister(src, regT0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     addSlowCase(branchIfNotCell(regT0));</span>
<span class="line-added">+     Jump done = branchIfSymbol(regT0);</span>
<span class="line-added">+     addSlowCase(branchIfNotString(regT0));</span>
<span class="line-added">+ </span>
<span class="line-added">+     done.link(this);</span>
<span class="line-added">+     if (src != dst)</span>
<span class="line-added">+         emitPutVirtualRegister(dst);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void JIT::emit_op_set_function_name(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSetFunctionName&gt;();
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_function, regT0);</span>
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_name, regT1);</span>
<span class="line-modified">!     callOperation(operationSetFunctionName, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, regT1);</span>
  }
  
  void JIT::emit_op_not(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNot&gt;();
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_operand, regT0);</span>
  
      // Invert against JSValue(false); if the value was tagged as a boolean, then all bits will be
      // clear other than the low bit (which will be 0 or 1 for false or true inputs respectively).
      // Then invert against JSValue(true), which will add the tag back in, and flip the low bit.
<span class="line-modified">!     xor64(TrustedImm32(JSValue::ValueFalse), regT0);</span>
      addSlowCase(branchTestPtr(NonZero, regT0, TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
<span class="line-modified">!     xor64(TrustedImm32(JSValue::ValueTrue), regT0);</span>
  
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_dst);</span>
  }
  
  void JIT::emit_op_jfalse(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJfalse&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 388,18 ***</span>
      GPRReg value = regT0;
      GPRReg scratch1 = regT1;
      GPRReg scratch2 = regT2;
      bool shouldCheckMasqueradesAsUndefined = true;
  
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_condition.offset(), value);</span>
      addJump(branchIfFalsey(vm(), JSValueRegs(value), scratch1, scratch2, fpRegT0, fpRegT1, shouldCheckMasqueradesAsUndefined, m_codeBlock-&gt;globalObject()), target);
  }
  
  void JIT::emit_op_jeq_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJeqNull&gt;();
<span class="line-modified">!     int src = bytecode.m_value.offset();</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitGetVirtualRegister(src, regT0);
      Jump isImmediate = branchIfNotCell(regT0);
  
<span class="line-new-header">--- 405,18 ---</span>
      GPRReg value = regT0;
      GPRReg scratch1 = regT1;
      GPRReg scratch2 = regT2;
      bool shouldCheckMasqueradesAsUndefined = true;
  
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_condition, value);</span>
      addJump(branchIfFalsey(vm(), JSValueRegs(value), scratch1, scratch2, fpRegT0, fpRegT1, shouldCheckMasqueradesAsUndefined, m_codeBlock-&gt;globalObject()), target);
  }
  
  void JIT::emit_op_jeq_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJeqNull&gt;();
<span class="line-modified">!     VirtualRegister src = bytecode.m_value;</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitGetVirtualRegister(src, regT0);
      Jump isImmediate = branchIfNotCell(regT0);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 410,20 ***</span>
      addJump(branchPtr(Equal, Address(regT2, Structure::globalObjectOffset()), regT0), target);
      Jump masqueradesGlobalObjectIsForeign = jump();
  
      // Now handle the immediate cases - undefined &amp; null
      isImmediate.link(this);
<span class="line-modified">!     and64(TrustedImm32(~TagBitUndefined), regT0);</span>
      addJump(branch64(Equal, regT0, TrustedImm64(JSValue::encode(jsNull()))), target);
  
      isNotMasqueradesAsUndefined.link(this);
      masqueradesGlobalObjectIsForeign.link(this);
  };
  void JIT::emit_op_jneq_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJneqNull&gt;();
<span class="line-modified">!     int src = bytecode.m_value.offset();</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitGetVirtualRegister(src, regT0);
      Jump isImmediate = branchIfNotCell(regT0);
  
<span class="line-new-header">--- 427,20 ---</span>
      addJump(branchPtr(Equal, Address(regT2, Structure::globalObjectOffset()), regT0), target);
      Jump masqueradesGlobalObjectIsForeign = jump();
  
      // Now handle the immediate cases - undefined &amp; null
      isImmediate.link(this);
<span class="line-modified">!     and64(TrustedImm32(~JSValue::UndefinedTag), regT0);</span>
      addJump(branch64(Equal, regT0, TrustedImm64(JSValue::encode(jsNull()))), target);
  
      isNotMasqueradesAsUndefined.link(this);
      masqueradesGlobalObjectIsForeign.link(this);
  };
  void JIT::emit_op_jneq_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJneqNull&gt;();
<span class="line-modified">!     VirtualRegister src = bytecode.m_value;</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitGetVirtualRegister(src, regT0);
      Jump isImmediate = branchIfNotCell(regT0);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 434,70 ***</span>
      addJump(branchPtr(NotEqual, Address(regT2, Structure::globalObjectOffset()), regT0), target);
      Jump wasNotImmediate = jump();
  
      // Now handle the immediate cases - undefined &amp; null
      isImmediate.link(this);
<span class="line-modified">!     and64(TrustedImm32(~TagBitUndefined), regT0);</span>
      addJump(branch64(NotEqual, regT0, TrustedImm64(JSValue::encode(jsNull()))), target);
  
      wasNotImmediate.link(this);
  }
  
  void JIT::emit_op_jundefined_or_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJundefinedOrNull&gt;();
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitGetVirtualRegister(value, regT0);
  
<span class="line-modified">!     and64(TrustedImm32(~TagBitUndefined), regT0);</span>
      addJump(branch64(Equal, regT0, TrustedImm64(JSValue::encode(jsNull()))), target);
  }
  
  void JIT::emit_op_jnundefined_or_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJnundefinedOrNull&gt;();
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitGetVirtualRegister(value, regT0);
  
<span class="line-modified">!     and64(TrustedImm32(~TagBitUndefined), regT0);</span>
      addJump(branch64(NotEqual, regT0, TrustedImm64(JSValue::encode(jsNull()))), target);
  }
  
  void JIT::emit_op_jneq_ptr(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJneqPtr&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int src = bytecode.m_value.offset();</span>
<span class="line-modified">!     Special::Pointer ptr = bytecode.m_specialPointer;</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitGetVirtualRegister(src, regT0);
<span class="line-modified">!     CCallHelpers::Jump equal = branchPtr(Equal, regT0, TrustedImmPtr(actualPointerFor(m_codeBlock, ptr)));</span>
      store8(TrustedImm32(1), &amp;metadata.m_hasJumped);
      addJump(jump(), target);
      equal.link(this);
  }
  
  void JIT::emit_op_eq(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEq&gt;();
<span class="line-modified">!     emitGetVirtualRegisters(bytecode.m_lhs.offset(), regT0, bytecode.m_rhs.offset(), regT1);</span>
      emitJumpSlowCaseIfNotInt(regT0, regT1, regT2);
      compare32(Equal, regT1, regT0, regT0);
      boxBoolean(regT0, JSValueRegs { regT0 });
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_dst.offset());</span>
  }
  
  void JIT::emit_op_jeq(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJeq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     emitGetVirtualRegisters(bytecode.m_lhs.offset(), regT0, bytecode.m_rhs.offset(), regT1);</span>
      emitJumpSlowCaseIfNotInt(regT0, regT1, regT2);
      addJump(branch32(Equal, regT0, regT1), target);
  }
  
  void JIT::emit_op_jtrue(const Instruction* currentInstruction)
<span class="line-new-header">--- 451,71 ---</span>
      addJump(branchPtr(NotEqual, Address(regT2, Structure::globalObjectOffset()), regT0), target);
      Jump wasNotImmediate = jump();
  
      // Now handle the immediate cases - undefined &amp; null
      isImmediate.link(this);
<span class="line-modified">!     and64(TrustedImm32(~JSValue::UndefinedTag), regT0);</span>
      addJump(branch64(NotEqual, regT0, TrustedImm64(JSValue::encode(jsNull()))), target);
  
      wasNotImmediate.link(this);
  }
  
  void JIT::emit_op_jundefined_or_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJundefinedOrNull&gt;();
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitGetVirtualRegister(value, regT0);
  
<span class="line-modified">!     and64(TrustedImm32(~JSValue::UndefinedTag), regT0);</span>
      addJump(branch64(Equal, regT0, TrustedImm64(JSValue::encode(jsNull()))), target);
  }
  
  void JIT::emit_op_jnundefined_or_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJnundefinedOrNull&gt;();
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitGetVirtualRegister(value, regT0);
  
<span class="line-modified">!     and64(TrustedImm32(~JSValue::UndefinedTag), regT0);</span>
      addJump(branch64(NotEqual, regT0, TrustedImm64(JSValue::encode(jsNull()))), target);
  }
  
  void JIT::emit_op_jneq_ptr(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJneqPtr&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister src = bytecode.m_value;</span>
<span class="line-modified">!     JSValue specialPointer = getConstantOperand(bytecode.m_specialPointer);</span>
<span class="line-added">+     ASSERT(specialPointer.isCell());</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitGetVirtualRegister(src, regT0);
<span class="line-modified">!     CCallHelpers::Jump equal = branchPtr(Equal, regT0, TrustedImmPtr(specialPointer.asCell()));</span>
      store8(TrustedImm32(1), &amp;metadata.m_hasJumped);
      addJump(jump(), target);
      equal.link(this);
  }
  
  void JIT::emit_op_eq(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEq&gt;();
<span class="line-modified">!     emitGetVirtualRegisters(bytecode.m_lhs, regT0, bytecode.m_rhs, regT1);</span>
      emitJumpSlowCaseIfNotInt(regT0, regT1, regT2);
      compare32(Equal, regT1, regT0, regT0);
      boxBoolean(regT0, JSValueRegs { regT0 });
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_dst);</span>
  }
  
  void JIT::emit_op_jeq(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJeq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     emitGetVirtualRegisters(bytecode.m_lhs, regT0, bytecode.m_rhs, regT1);</span>
      emitJumpSlowCaseIfNotInt(regT0, regT1, regT2);
      addJump(branch32(Equal, regT0, regT1), target);
  }
  
  void JIT::emit_op_jtrue(const Instruction* currentInstruction)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 507,51 ***</span>
  
      GPRReg value = regT0;
      GPRReg scratch1 = regT1;
      GPRReg scratch2 = regT2;
      bool shouldCheckMasqueradesAsUndefined = true;
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_condition.offset(), value);</span>
      addJump(branchIfTruthy(vm(), JSValueRegs(value), scratch1, scratch2, fpRegT0, fpRegT1, shouldCheckMasqueradesAsUndefined, m_codeBlock-&gt;globalObject()), target);
  }
  
  void JIT::emit_op_neq(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNeq&gt;();
<span class="line-modified">!     emitGetVirtualRegisters(bytecode.m_lhs.offset(), regT0, bytecode.m_rhs.offset(), regT1);</span>
      emitJumpSlowCaseIfNotInt(regT0, regT1, regT2);
      compare32(NotEqual, regT1, regT0, regT0);
      boxBoolean(regT0, JSValueRegs { regT0 });
  
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_dst.offset());</span>
  }
  
  void JIT::emit_op_jneq(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJneq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     emitGetVirtualRegisters(bytecode.m_lhs.offset(), regT0, bytecode.m_rhs.offset(), regT1);</span>
      emitJumpSlowCaseIfNotInt(regT0, regT1, regT2);
      addJump(branch32(NotEqual, regT0, regT1), target);
  }
  
  void JIT::emit_op_throw(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpThrow&gt;();
      ASSERT(regT0 == returnValueGPR);
      copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm().topEntryFrame);
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_value.offset(), regT0);</span>
<span class="line-modified">!     callOperationNoExceptionCheck(operationThrow, regT0);</span>
      jumpToExceptionHandler(vm());
  }
  
  template&lt;typename Op&gt;
  void JIT::compileOpStrictEq(const Instruction* currentInstruction, CompileOpStrictEqType type)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int src1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">!     int src2 = bytecode.m_rhs.offset();</span>
  
      emitGetVirtualRegisters(src1, regT0, src2, regT1);
  
      // Jump slow if both are cells (to cover strings).
      move(regT0, regT2);
<span class="line-new-header">--- 525,51 ---</span>
  
      GPRReg value = regT0;
      GPRReg scratch1 = regT1;
      GPRReg scratch2 = regT2;
      bool shouldCheckMasqueradesAsUndefined = true;
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_condition, value);</span>
      addJump(branchIfTruthy(vm(), JSValueRegs(value), scratch1, scratch2, fpRegT0, fpRegT1, shouldCheckMasqueradesAsUndefined, m_codeBlock-&gt;globalObject()), target);
  }
  
  void JIT::emit_op_neq(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNeq&gt;();
<span class="line-modified">!     emitGetVirtualRegisters(bytecode.m_lhs, regT0, bytecode.m_rhs, regT1);</span>
      emitJumpSlowCaseIfNotInt(regT0, regT1, regT2);
      compare32(NotEqual, regT1, regT0, regT0);
      boxBoolean(regT0, JSValueRegs { regT0 });
  
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_dst);</span>
  }
  
  void JIT::emit_op_jneq(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJneq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     emitGetVirtualRegisters(bytecode.m_lhs, regT0, bytecode.m_rhs, regT1);</span>
      emitJumpSlowCaseIfNotInt(regT0, regT1, regT2);
      addJump(branch32(NotEqual, regT0, regT1), target);
  }
  
  void JIT::emit_op_throw(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpThrow&gt;();
      ASSERT(regT0 == returnValueGPR);
      copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm().topEntryFrame);
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_value, regT0);</span>
<span class="line-modified">!     callOperationNoExceptionCheck(operationThrow, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0);</span>
      jumpToExceptionHandler(vm());
  }
  
  template&lt;typename Op&gt;
  void JIT::compileOpStrictEq(const Instruction* currentInstruction, CompileOpStrictEqType type)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister src1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister src2 = bytecode.m_rhs;</span>
  
      emitGetVirtualRegisters(src1, regT0, src2, regT1);
  
      // Jump slow if both are cells (to cover strings).
      move(regT0, regT2);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 589,12 ***</span>
  template&lt;typename Op&gt;
  void JIT::compileOpStrictEqJump(const Instruction* currentInstruction, CompileOpStrictEqType type)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
      int target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     int src1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">!     int src2 = bytecode.m_rhs.offset();</span>
  
      emitGetVirtualRegisters(src1, regT0, src2, regT1);
  
      // Jump slow if both are cells (to cover strings).
      move(regT0, regT2);
<span class="line-new-header">--- 607,12 ---</span>
  template&lt;typename Op&gt;
  void JIT::compileOpStrictEqJump(const Instruction* currentInstruction, CompileOpStrictEqType type)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
      int target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     VirtualRegister src1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister src2 = bytecode.m_rhs;</span>
  
      emitGetVirtualRegisters(src1, regT0, src2, regT1);
  
      // Jump slow if both are cells (to cover strings).
      move(regT0, regT2);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 630,55 ***</span>
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpJstricteq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     callOperation(operationCompareStrictEq, regT0, regT1);</span>
      emitJumpSlowToHot(branchTest32(NonZero, returnValueGPR), target);
  }
  
  void JIT::emitSlow_op_jnstricteq(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpJnstricteq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     callOperation(operationCompareStrictEq, regT0, regT1);</span>
      emitJumpSlowToHot(branchTest32(Zero, returnValueGPR), target);
  }
  
  void JIT::emit_op_to_number(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToNumber&gt;();
<span class="line-modified">!     int dstVReg = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int srcVReg = bytecode.m_operand.offset();</span>
      emitGetVirtualRegister(srcVReg, regT0);
  
      addSlowCase(branchIfNotNumber(regT0));
  
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
      if (srcVReg != dstVReg)
          emitPutVirtualRegister(dstVReg);
  }
  
  void JIT::emit_op_to_string(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToString&gt;();
<span class="line-modified">!     int srcVReg = bytecode.m_operand.offset();</span>
      emitGetVirtualRegister(srcVReg, regT0);
  
      addSlowCase(branchIfNotCell(regT0));
      addSlowCase(branchIfNotString(regT0));
  
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_dst.offset());</span>
  }
  
  void JIT::emit_op_to_object(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToObject&gt;();
<span class="line-modified">!     int dstVReg = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int srcVReg = bytecode.m_operand.offset();</span>
      emitGetVirtualRegister(srcVReg, regT0);
  
      addSlowCase(branchIfNotCell(regT0));
      addSlowCase(branchIfNotObject(regT0));
  
<span class="line-new-header">--- 648,75 ---</span>
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpJstricteq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     callOperation(operationCompareStrictEq, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, regT1);</span>
      emitJumpSlowToHot(branchTest32(NonZero, returnValueGPR), target);
  }
  
  void JIT::emitSlow_op_jnstricteq(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpJnstricteq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     callOperation(operationCompareStrictEq, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, regT1);</span>
      emitJumpSlowToHot(branchTest32(Zero, returnValueGPR), target);
  }
  
  void JIT::emit_op_to_number(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToNumber&gt;();
<span class="line-modified">!     VirtualRegister dstVReg = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister srcVReg = bytecode.m_operand;</span>
<span class="line-added">+     emitGetVirtualRegister(srcVReg, regT0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     addSlowCase(branchIfNotNumber(regT0));</span>
<span class="line-added">+ </span>
<span class="line-added">+     emitValueProfilingSite(bytecode.metadata(m_codeBlock));</span>
<span class="line-added">+     if (srcVReg != dstVReg)</span>
<span class="line-added">+         emitPutVirtualRegister(dstVReg);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JIT::emit_op_to_numeric(const Instruction* currentInstruction)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto bytecode = currentInstruction-&gt;as&lt;OpToNumeric&gt;();</span>
<span class="line-added">+     VirtualRegister dstVReg = bytecode.m_dst;</span>
<span class="line-added">+     VirtualRegister srcVReg = bytecode.m_operand;</span>
      emitGetVirtualRegister(srcVReg, regT0);
  
<span class="line-added">+     Jump isNotCell = branchIfNotCell(regT0);</span>
<span class="line-added">+     addSlowCase(branchIfNotBigInt(regT0));</span>
<span class="line-added">+     Jump isBigInt = jump();</span>
<span class="line-added">+ </span>
<span class="line-added">+     isNotCell.link(this);</span>
      addSlowCase(branchIfNotNumber(regT0));
<span class="line-added">+     isBigInt.link(this);</span>
  
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
      if (srcVReg != dstVReg)
          emitPutVirtualRegister(dstVReg);
  }
  
  void JIT::emit_op_to_string(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToString&gt;();
<span class="line-modified">!     VirtualRegister srcVReg = bytecode.m_operand;</span>
      emitGetVirtualRegister(srcVReg, regT0);
  
      addSlowCase(branchIfNotCell(regT0));
      addSlowCase(branchIfNotString(regT0));
  
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_dst);</span>
  }
  
  void JIT::emit_op_to_object(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToObject&gt;();
<span class="line-modified">!     VirtualRegister dstVReg = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister srcVReg = bytecode.m_operand;</span>
      emitGetVirtualRegister(srcVReg, regT0);
  
      addSlowCase(branchIfNotCell(regT0));
      addSlowCase(branchIfNotObject(regT0));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 697,40 ***</span>
      load64(Address(regT3, VM::callFrameForCatchOffset()), callFrameRegister);
      storePtr(TrustedImmPtr(nullptr), Address(regT3, VM::callFrameForCatchOffset()));
  
      addPtr(TrustedImm32(stackPointerOffsetFor(codeBlock()) * sizeof(Register)), callFrameRegister, stackPointerRegister);
  
<span class="line-modified">!     callOperationNoExceptionCheck(operationCheckIfExceptionIsUncatchableAndNotifyProfiler);</span>
      Jump isCatchableException = branchTest32(Zero, returnValueGPR);
      jumpToExceptionHandler(vm());
      isCatchableException.link(this);
  
      move(TrustedImmPtr(m_vm), regT3);
      load64(Address(regT3, VM::exceptionOffset()), regT0);
      store64(TrustedImm64(JSValue::encode(JSValue())), Address(regT3, VM::exceptionOffset()));
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_exception.offset());</span>
  
      load64(Address(regT0, Exception::valueOffset()), regT0);
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_thrownValue.offset());</span>
  
  #if ENABLE(DFG_JIT)
      // FIXME: consider inline caching the process of doing OSR entry, including
      // argument type proofs, storing locals to the buffer, etc
      // https://bugs.webkit.org/show_bug.cgi?id=175598
  
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     ValueProfileAndOperandBuffer* buffer = metadata.m_buffer;</span>
      if (buffer || !shouldEmitProfiling())
<span class="line-modified">!         callOperation(operationTryOSREnterAtCatch, m_bytecodeOffset);</span>
      else
<span class="line-modified">!         callOperation(operationTryOSREnterAtCatchAndValueProfile, m_bytecodeOffset);</span>
      auto skipOSREntry = branchTestPtr(Zero, returnValueGPR);
      emitRestoreCalleeSaves();
      farJump(returnValueGPR, ExceptionHandlerPtrTag);
      skipOSREntry.link(this);
      if (buffer &amp;&amp; shouldEmitProfiling()) {
<span class="line-modified">!         buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {</span>
              JSValueRegs regs(regT0);
              emitGetVirtualRegister(profile.m_operand, regs);
              emitValueProfilingSite(static_cast&lt;ValueProfile&amp;&gt;(profile));
          });
      }
<span class="line-new-header">--- 735,40 ---</span>
      load64(Address(regT3, VM::callFrameForCatchOffset()), callFrameRegister);
      storePtr(TrustedImmPtr(nullptr), Address(regT3, VM::callFrameForCatchOffset()));
  
      addPtr(TrustedImm32(stackPointerOffsetFor(codeBlock()) * sizeof(Register)), callFrameRegister, stackPointerRegister);
  
<span class="line-modified">!     callOperationNoExceptionCheck(operationCheckIfExceptionIsUncatchableAndNotifyProfiler, TrustedImmPtr(&amp;vm()));</span>
      Jump isCatchableException = branchTest32(Zero, returnValueGPR);
      jumpToExceptionHandler(vm());
      isCatchableException.link(this);
  
      move(TrustedImmPtr(m_vm), regT3);
      load64(Address(regT3, VM::exceptionOffset()), regT0);
      store64(TrustedImm64(JSValue::encode(JSValue())), Address(regT3, VM::exceptionOffset()));
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_exception);</span>
  
      load64(Address(regT0, Exception::valueOffset()), regT0);
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_thrownValue);</span>
  
  #if ENABLE(DFG_JIT)
      // FIXME: consider inline caching the process of doing OSR entry, including
      // argument type proofs, storing locals to the buffer, etc
      // https://bugs.webkit.org/show_bug.cgi?id=175598
  
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     ValueProfileAndVirtualRegisterBuffer* buffer = metadata.m_buffer;</span>
      if (buffer || !shouldEmitProfiling())
<span class="line-modified">!         callOperation(operationTryOSREnterAtCatch, &amp;vm(), m_bytecodeIndex.asBits());</span>
      else
<span class="line-modified">!         callOperation(operationTryOSREnterAtCatchAndValueProfile, &amp;vm(), m_bytecodeIndex.asBits());</span>
      auto skipOSREntry = branchTestPtr(Zero, returnValueGPR);
      emitRestoreCalleeSaves();
      farJump(returnValueGPR, ExceptionHandlerPtrTag);
      skipOSREntry.link(this);
      if (buffer &amp;&amp; shouldEmitProfiling()) {
<span class="line-modified">!         buffer-&gt;forEach([&amp;] (ValueProfileAndVirtualRegister&amp; profile) {</span>
              JSValueRegs regs(regT0);
              emitGetVirtualRegister(profile.m_operand, regs);
              emitValueProfilingSite(static_cast&lt;ValueProfile&amp;&gt;(profile));
          });
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 743,80 ***</span>
  }
  
  void JIT::emit_op_get_parent_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetParentScope&gt;();
<span class="line-modified">!     int currentScope = bytecode.m_scope.offset();</span>
      emitGetVirtualRegister(currentScope, regT0);
      loadPtr(Address(regT0, JSScope::offsetOfNext()), regT0);
<span class="line-modified">!     emitStoreCell(bytecode.m_dst.offset(), regT0);</span>
  }
  
  void JIT::emit_op_switch_imm(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSwitchImm&gt;();
      size_t tableIndex = bytecode.m_tableIndex;
      unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
<span class="line-modified">!     unsigned scrutinee = bytecode.m_scrutinee.offset();</span>
  
      // create jump table for switch destinations, track this switch statement.
      SimpleJumpTable* jumpTable = &amp;m_codeBlock-&gt;switchJumpTable(tableIndex);
<span class="line-modified">!     m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset, SwitchRecord::Immediate));</span>
      jumpTable-&gt;ensureCTITable();
  
      emitGetVirtualRegister(scrutinee, regT0);
<span class="line-modified">!     callOperation(operationSwitchImmWithUnknownKeyType, regT0, tableIndex);</span>
      farJump(returnValueGPR, JSSwitchPtrTag);
  }
  
  void JIT::emit_op_switch_char(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSwitchChar&gt;();
      size_t tableIndex = bytecode.m_tableIndex;
      unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
<span class="line-modified">!     unsigned scrutinee = bytecode.m_scrutinee.offset();</span>
  
      // create jump table for switch destinations, track this switch statement.
      SimpleJumpTable* jumpTable = &amp;m_codeBlock-&gt;switchJumpTable(tableIndex);
<span class="line-modified">!     m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset, SwitchRecord::Character));</span>
      jumpTable-&gt;ensureCTITable();
  
      emitGetVirtualRegister(scrutinee, regT0);
<span class="line-modified">!     callOperation(operationSwitchCharWithUnknownKeyType, regT0, tableIndex);</span>
      farJump(returnValueGPR, JSSwitchPtrTag);
  }
  
  void JIT::emit_op_switch_string(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSwitchString&gt;();
      size_t tableIndex = bytecode.m_tableIndex;
      unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
<span class="line-modified">!     unsigned scrutinee = bytecode.m_scrutinee.offset();</span>
  
      // create jump table for switch destinations, track this switch statement.
      StringJumpTable* jumpTable = &amp;m_codeBlock-&gt;stringSwitchJumpTable(tableIndex);
<span class="line-modified">!     m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset));</span>
  
      emitGetVirtualRegister(scrutinee, regT0);
<span class="line-modified">!     callOperation(operationSwitchStringWithUnknownKeyType, regT0, tableIndex);</span>
      farJump(returnValueGPR, JSSwitchPtrTag);
  }
  
  void JIT::emit_op_debug(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDebug&gt;();
      load32(codeBlock()-&gt;debuggerRequestsAddress(), regT0);
      Jump noDebuggerRequests = branchTest32(Zero, regT0);
<span class="line-modified">!     callOperation(operationDebug, static_cast&lt;int&gt;(bytecode.m_debugHookType));</span>
      noDebuggerRequests.link(this);
  }
  
  void JIT::emit_op_eq_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEqNull&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int src1 = bytecode.m_operand.offset();</span>
  
      emitGetVirtualRegister(src1, regT0);
      Jump isImmediate = branchIfNotCell(regT0);
  
      Jump isMasqueradesAsUndefined = branchTest8(NonZero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined));
<span class="line-new-header">--- 781,80 ---</span>
  }
  
  void JIT::emit_op_get_parent_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetParentScope&gt;();
<span class="line-modified">!     VirtualRegister currentScope = bytecode.m_scope;</span>
      emitGetVirtualRegister(currentScope, regT0);
      loadPtr(Address(regT0, JSScope::offsetOfNext()), regT0);
<span class="line-modified">!     emitStoreCell(bytecode.m_dst, regT0);</span>
  }
  
  void JIT::emit_op_switch_imm(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSwitchImm&gt;();
      size_t tableIndex = bytecode.m_tableIndex;
      unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
<span class="line-modified">!     VirtualRegister scrutinee = bytecode.m_scrutinee;</span>
  
      // create jump table for switch destinations, track this switch statement.
      SimpleJumpTable* jumpTable = &amp;m_codeBlock-&gt;switchJumpTable(tableIndex);
<span class="line-modified">!     m_switches.append(SwitchRecord(jumpTable, m_bytecodeIndex, defaultOffset, SwitchRecord::Immediate));</span>
      jumpTable-&gt;ensureCTITable();
  
      emitGetVirtualRegister(scrutinee, regT0);
<span class="line-modified">!     callOperation(operationSwitchImmWithUnknownKeyType, TrustedImmPtr(&amp;vm()), regT0, tableIndex);</span>
      farJump(returnValueGPR, JSSwitchPtrTag);
  }
  
  void JIT::emit_op_switch_char(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSwitchChar&gt;();
      size_t tableIndex = bytecode.m_tableIndex;
      unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
<span class="line-modified">!     VirtualRegister scrutinee = bytecode.m_scrutinee;</span>
  
      // create jump table for switch destinations, track this switch statement.
      SimpleJumpTable* jumpTable = &amp;m_codeBlock-&gt;switchJumpTable(tableIndex);
<span class="line-modified">!     m_switches.append(SwitchRecord(jumpTable, m_bytecodeIndex, defaultOffset, SwitchRecord::Character));</span>
      jumpTable-&gt;ensureCTITable();
  
      emitGetVirtualRegister(scrutinee, regT0);
<span class="line-modified">!     callOperation(operationSwitchCharWithUnknownKeyType, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, tableIndex);</span>
      farJump(returnValueGPR, JSSwitchPtrTag);
  }
  
  void JIT::emit_op_switch_string(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSwitchString&gt;();
      size_t tableIndex = bytecode.m_tableIndex;
      unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
<span class="line-modified">!     VirtualRegister scrutinee = bytecode.m_scrutinee;</span>
  
      // create jump table for switch destinations, track this switch statement.
      StringJumpTable* jumpTable = &amp;m_codeBlock-&gt;stringSwitchJumpTable(tableIndex);
<span class="line-modified">!     m_switches.append(SwitchRecord(jumpTable, m_bytecodeIndex, defaultOffset));</span>
  
      emitGetVirtualRegister(scrutinee, regT0);
<span class="line-modified">!     callOperation(operationSwitchStringWithUnknownKeyType, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, tableIndex);</span>
      farJump(returnValueGPR, JSSwitchPtrTag);
  }
  
  void JIT::emit_op_debug(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDebug&gt;();
      load32(codeBlock()-&gt;debuggerRequestsAddress(), regT0);
      Jump noDebuggerRequests = branchTest32(Zero, regT0);
<span class="line-modified">!     callOperation(operationDebug, &amp;vm(), static_cast&lt;int&gt;(bytecode.m_debugHookType));</span>
      noDebuggerRequests.link(this);
  }
  
  void JIT::emit_op_eq_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEqNull&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister src1 = bytecode.m_operand;</span>
  
      emitGetVirtualRegister(src1, regT0);
      Jump isImmediate = branchIfNotCell(regT0);
  
      Jump isMasqueradesAsUndefined = branchTest8(NonZero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 830,12 ***</span>
      comparePtr(Equal, regT0, regT2, regT0);
      Jump wasNotImmediate = jump();
  
      isImmediate.link(this);
  
<span class="line-modified">!     and64(TrustedImm32(~TagBitUndefined), regT0);</span>
<span class="line-modified">!     compare64(Equal, regT0, TrustedImm32(ValueNull), regT0);</span>
  
      wasNotImmediate.link(this);
      wasNotMasqueradesAsUndefined.link(this);
  
      boxBoolean(regT0, JSValueRegs { regT0 });
<span class="line-new-header">--- 868,12 ---</span>
      comparePtr(Equal, regT0, regT2, regT0);
      Jump wasNotImmediate = jump();
  
      isImmediate.link(this);
  
<span class="line-modified">!     and64(TrustedImm32(~JSValue::UndefinedTag), regT0);</span>
<span class="line-modified">!     compare64(Equal, regT0, TrustedImm32(JSValue::ValueNull), regT0);</span>
  
      wasNotImmediate.link(this);
      wasNotMasqueradesAsUndefined.link(this);
  
      boxBoolean(regT0, JSValueRegs { regT0 });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 844,12 ***</span>
  }
  
  void JIT::emit_op_neq_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNeqNull&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int src1 = bytecode.m_operand.offset();</span>
  
      emitGetVirtualRegister(src1, regT0);
      Jump isImmediate = branchIfNotCell(regT0);
  
      Jump isMasqueradesAsUndefined = branchTest8(NonZero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined));
<span class="line-new-header">--- 882,12 ---</span>
  }
  
  void JIT::emit_op_neq_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNeqNull&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister src1 = bytecode.m_operand;</span>
  
      emitGetVirtualRegister(src1, regT0);
      Jump isImmediate = branchIfNotCell(regT0);
  
      Jump isMasqueradesAsUndefined = branchTest8(NonZero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 863,35 ***</span>
      comparePtr(NotEqual, regT0, regT2, regT0);
      Jump wasNotImmediate = jump();
  
      isImmediate.link(this);
  
<span class="line-modified">!     and64(TrustedImm32(~TagBitUndefined), regT0);</span>
<span class="line-modified">!     compare64(NotEqual, regT0, TrustedImm32(ValueNull), regT0);</span>
  
      wasNotImmediate.link(this);
      wasNotMasqueradesAsUndefined.link(this);
  
      boxBoolean(regT0, JSValueRegs { regT0 });
      emitPutVirtualRegister(dst);
  }
  
  void JIT::emit_op_get_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetScope&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
      emitGetFromCallFrameHeaderPtr(CallFrameSlot::callee, regT0);
      loadPtr(Address(regT0, JSFunction::offsetOfScopeChain()), regT0);
      emitStoreCell(dst, regT0);
  }
  
  void JIT::emit_op_to_this(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToThis&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
      StructureID* cachedStructureID = &amp;metadata.m_cachedStructureID;
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_srcDst.offset(), regT1);</span>
  
      emitJumpSlowCaseIfNotJSCell(regT1);
  
      addSlowCase(branchIfNotType(regT1, FinalObjectType));
      load32(cachedStructureID, regT2);
<span class="line-new-header">--- 901,49 ---</span>
      comparePtr(NotEqual, regT0, regT2, regT0);
      Jump wasNotImmediate = jump();
  
      isImmediate.link(this);
  
<span class="line-modified">!     and64(TrustedImm32(~JSValue::UndefinedTag), regT0);</span>
<span class="line-modified">!     compare64(NotEqual, regT0, TrustedImm32(JSValue::ValueNull), regT0);</span>
  
      wasNotImmediate.link(this);
      wasNotMasqueradesAsUndefined.link(this);
  
      boxBoolean(regT0, JSValueRegs { regT0 });
      emitPutVirtualRegister(dst);
  }
  
<span class="line-added">+ void JIT::emit_op_enter(const Instruction*)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // Even though CTI doesn&#39;t use them, we initialize our constant</span>
<span class="line-added">+     // registers to zap stale pointers, to avoid unnecessarily prolonging</span>
<span class="line-added">+     // object lifetime and increasing GC pressure.</span>
<span class="line-added">+     size_t count = m_codeBlock-&gt;numVars();</span>
<span class="line-added">+     for (size_t j = CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters(); j &lt; count; ++j)</span>
<span class="line-added">+         emitInitRegister(virtualRegisterForLocal(j));</span>
<span class="line-added">+ </span>
<span class="line-added">+     emitWriteBarrier(m_codeBlock);</span>
<span class="line-added">+ </span>
<span class="line-added">+     emitEnterOptimizationCheck();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void JIT::emit_op_get_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetScope&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
      emitGetFromCallFrameHeaderPtr(CallFrameSlot::callee, regT0);
      loadPtr(Address(regT0, JSFunction::offsetOfScopeChain()), regT0);
      emitStoreCell(dst, regT0);
  }
  
  void JIT::emit_op_to_this(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToThis&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
      StructureID* cachedStructureID = &amp;metadata.m_cachedStructureID;
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_srcDst, regT1);</span>
  
      emitJumpSlowCaseIfNotJSCell(regT1);
  
      addSlowCase(branchIfNotType(regT1, FinalObjectType));
      load32(cachedStructureID, regT2);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 900,11 ***</span>
  
  void JIT::emit_op_create_this(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpCreateThis&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int callee = bytecode.m_callee.offset();</span>
      WriteBarrierBase&lt;JSCell&gt;* cachedFunction = &amp;metadata.m_cachedCallee;
      RegisterID calleeReg = regT0;
      RegisterID rareDataReg = regT4;
      RegisterID resultReg = regT0;
      RegisterID allocatorReg = regT1;
<span class="line-new-header">--- 952,11 ---</span>
  
  void JIT::emit_op_create_this(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpCreateThis&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister callee = bytecode.m_callee;</span>
      WriteBarrierBase&lt;JSCell&gt;* cachedFunction = &amp;metadata.m_cachedCallee;
      RegisterID calleeReg = regT0;
      RegisterID rareDataReg = regT4;
      RegisterID resultReg = regT0;
      RegisterID allocatorReg = regT1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 912,14 ***</span>
      RegisterID cachedFunctionReg = regT4;
      RegisterID scratchReg = regT3;
  
      emitGetVirtualRegister(callee, calleeReg);
      addSlowCase(branchIfNotFunction(calleeReg));
<span class="line-modified">!     loadPtr(Address(calleeReg, JSFunction::offsetOfRareData()), rareDataReg);</span>
<span class="line-modified">!     addSlowCase(branchTestPtr(Zero, rareDataReg));</span>
<span class="line-modified">!     loadPtr(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfAllocator()), allocatorReg);</span>
<span class="line-modified">!     loadPtr(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfStructure()), structureReg);</span>
  
      loadPtr(cachedFunction, cachedFunctionReg);
      Jump hasSeenMultipleCallees = branchPtr(Equal, cachedFunctionReg, TrustedImmPtr(JSCell::seenMultipleCalleeObjects()));
      addSlowCase(branchPtr(NotEqual, calleeReg, cachedFunctionReg));
      hasSeenMultipleCallees.link(this);
<span class="line-new-header">--- 964,14 ---</span>
      RegisterID cachedFunctionReg = regT4;
      RegisterID scratchReg = regT3;
  
      emitGetVirtualRegister(callee, calleeReg);
      addSlowCase(branchIfNotFunction(calleeReg));
<span class="line-modified">!     loadPtr(Address(calleeReg, JSFunction::offsetOfExecutableOrRareData()), rareDataReg);</span>
<span class="line-modified">!     addSlowCase(branchTestPtr(Zero, rareDataReg, TrustedImm32(JSFunction::rareDataTag)));</span>
<span class="line-modified">!     loadPtr(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfAllocator() - JSFunction::rareDataTag), allocatorReg);</span>
<span class="line-modified">!     loadPtr(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfStructure() - JSFunction::rareDataTag), structureReg);</span>
  
      loadPtr(cachedFunction, cachedFunctionReg);
      Jump hasSeenMultipleCallees = branchPtr(Equal, cachedFunctionReg, TrustedImmPtr(JSCell::seenMultipleCalleeObjects()));
      addSlowCase(branchPtr(NotEqual, calleeReg, cachedFunctionReg));
      hasSeenMultipleCallees.link(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 928,17 ***</span>
      auto butterfly = TrustedImmPtr(nullptr);
      emitAllocateJSObject(resultReg, JITAllocator::variable(), allocatorReg, structureReg, butterfly, scratchReg, slowCases);
      load8(Address(structureReg, Structure::inlineCapacityOffset()), scratchReg);
      emitInitializeInlineStorage(resultReg, scratchReg);
      addSlowCase(slowCases);
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_dst.offset());</span>
  }
  
  void JIT::emit_op_check_tdz(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpCheckTdz&gt;();
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_targetVirtualRegister.offset(), regT0);</span>
      addSlowCase(branchIfEmpty(regT0));
  }
  
  
  // Slow cases
<span class="line-new-header">--- 980,17 ---</span>
      auto butterfly = TrustedImmPtr(nullptr);
      emitAllocateJSObject(resultReg, JITAllocator::variable(), allocatorReg, structureReg, butterfly, scratchReg, slowCases);
      load8(Address(structureReg, Structure::inlineCapacityOffset()), scratchReg);
      emitInitializeInlineStorage(resultReg, scratchReg);
      addSlowCase(slowCases);
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_dst);</span>
  }
  
  void JIT::emit_op_check_tdz(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpCheckTdz&gt;();
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_targetVirtualRegister, regT0);</span>
      addSlowCase(branchIfEmpty(regT0));
  }
  
  
  // Slow cases
</pre>
<hr />
<pre>
<span class="line-old-header">*** 946,105 ***</span>
  void JIT::emitSlow_op_eq(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpEq&gt;();
<span class="line-modified">!     callOperation(operationCompareEq, regT0, regT1);</span>
      boxBoolean(returnValueGPR, JSValueRegs { returnValueGPR });
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_dst.offset(), returnValueGPR);</span>
  }
  
  void JIT::emitSlow_op_neq(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpNeq&gt;();
<span class="line-modified">!     callOperation(operationCompareEq, regT0, regT1);</span>
      xor32(TrustedImm32(0x1), regT0);
      boxBoolean(returnValueGPR, JSValueRegs { returnValueGPR });
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_dst.offset(), returnValueGPR);</span>
  }
  
  void JIT::emitSlow_op_jeq(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpJeq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     callOperation(operationCompareEq, regT0, regT1);</span>
      emitJumpSlowToHot(branchTest32(NonZero, returnValueGPR), target);
  }
  
  void JIT::emitSlow_op_jneq(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpJneq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     callOperation(operationCompareEq, regT0, regT1);</span>
      emitJumpSlowToHot(branchTest32(Zero, returnValueGPR), target);
  }
  
  void JIT::emitSlow_op_instanceof_custom(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpInstanceofCustom&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
<span class="line-modified">!     int constructor = bytecode.m_constructor.offset();</span>
<span class="line-modified">!     int hasInstanceValue = bytecode.m_hasInstanceValue.offset();</span>
  
      emitGetVirtualRegister(value, regT0);
      emitGetVirtualRegister(constructor, regT1);
      emitGetVirtualRegister(hasInstanceValue, regT2);
<span class="line-modified">!     callOperation(operationInstanceOfCustom, regT0, regT1, regT2);</span>
      boxBoolean(returnValueGPR, JSValueRegs { returnValueGPR });
      emitPutVirtualRegister(dst, returnValueGPR);
  }
  
  #endif // USE(JSVALUE64)
  
  void JIT::emit_op_loop_hint(const Instruction*)
  {
<span class="line-removed">-     // Check traps.</span>
<span class="line-removed">-     addSlowCase(branchTest8(NonZero, AbsoluteAddress(m_vm-&gt;needTrapHandlingAddress())));</span>
<span class="line-removed">- #if ENABLE(DFG_JIT)</span>
      // Emit the JIT optimization check:
      if (canBeOptimized()) {
          addSlowCase(branchAdd32(PositiveOrZero, TrustedImm32(Options::executionCounterIncrementForLoop()),
              AbsoluteAddress(m_codeBlock-&gt;addressOfJITExecuteCounter())));
      }
<span class="line-removed">- #endif</span>
  }
  
  void JIT::emitSlow_op_loop_hint(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
<span class="line-removed">-     linkSlowCase(iter);</span>
<span class="line-removed">-     callOperation(operationHandleTraps);</span>
  #if ENABLE(DFG_JIT)
      // Emit the slow path for the JIT optimization check:
      if (canBeOptimized()) {
<span class="line-modified">!         emitJumpSlowToHot(branchAdd32(Signed, TrustedImm32(Options::executionCounterIncrementForLoop()), AbsoluteAddress(m_codeBlock-&gt;addressOfJITExecuteCounter())), currentInstruction-&gt;size());</span>
<span class="line-removed">-         linkSlowCase(iter);</span>
  
          copyCalleeSavesFromFrameOrRegisterToEntryFrameCalleeSavesBuffer(vm().topEntryFrame);
  
<span class="line-modified">!         callOperation(operationOptimize, m_bytecodeOffset);</span>
<span class="line-modified">!         emitJumpSlowToHot(branchTestPtr(Zero, returnValueGPR), currentInstruction-&gt;size());</span>
<span class="line-modified">!         if (!ASSERT_DISABLED) {</span>
              Jump ok = branchPtr(MacroAssembler::Above, returnValueGPR, TrustedImmPtr(bitwise_cast&lt;void*&gt;(static_cast&lt;intptr_t&gt;(1000))));
              abortWithReason(JITUnreasonableLoopHintJumpTarget);
              ok.link(this);
          }
          farJump(returnValueGPR, GPRInfo::callFrameRegister);
      }
  #else
      UNUSED_PARAM(currentInstruction);
  #endif
  }
  
  void JIT::emit_op_nop(const Instruction*)
  {
  }
  
  void JIT::emit_op_super_sampler_begin(const Instruction*)
<span class="line-new-header">--- 998,107 ---</span>
  void JIT::emitSlow_op_eq(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpEq&gt;();
<span class="line-modified">!     callOperation(operationCompareEq, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, regT1);</span>
      boxBoolean(returnValueGPR, JSValueRegs { returnValueGPR });
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_dst, returnValueGPR);</span>
  }
  
  void JIT::emitSlow_op_neq(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpNeq&gt;();
<span class="line-modified">!     callOperation(operationCompareEq, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, regT1);</span>
      xor32(TrustedImm32(0x1), regT0);
      boxBoolean(returnValueGPR, JSValueRegs { returnValueGPR });
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_dst, returnValueGPR);</span>
  }
  
  void JIT::emitSlow_op_jeq(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpJeq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     callOperation(operationCompareEq, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, regT1);</span>
      emitJumpSlowToHot(branchTest32(NonZero, returnValueGPR), target);
  }
  
  void JIT::emitSlow_op_jneq(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpJneq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     callOperation(operationCompareEq, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, regT1);</span>
      emitJumpSlowToHot(branchTest32(Zero, returnValueGPR), target);
  }
  
  void JIT::emitSlow_op_instanceof_custom(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpInstanceofCustom&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
<span class="line-modified">!     VirtualRegister constructor = bytecode.m_constructor;</span>
<span class="line-modified">!     VirtualRegister hasInstanceValue = bytecode.m_hasInstanceValue;</span>
  
      emitGetVirtualRegister(value, regT0);
      emitGetVirtualRegister(constructor, regT1);
      emitGetVirtualRegister(hasInstanceValue, regT2);
<span class="line-modified">!     callOperation(operationInstanceOfCustom, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, regT1, regT2);</span>
      boxBoolean(returnValueGPR, JSValueRegs { returnValueGPR });
      emitPutVirtualRegister(dst, returnValueGPR);
  }
  
  #endif // USE(JSVALUE64)
  
  void JIT::emit_op_loop_hint(const Instruction*)
  {
      // Emit the JIT optimization check:
      if (canBeOptimized()) {
          addSlowCase(branchAdd32(PositiveOrZero, TrustedImm32(Options::executionCounterIncrementForLoop()),
              AbsoluteAddress(m_codeBlock-&gt;addressOfJITExecuteCounter())));
      }
  }
  
  void JIT::emitSlow_op_loop_hint(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
  #if ENABLE(DFG_JIT)
      // Emit the slow path for the JIT optimization check:
      if (canBeOptimized()) {
<span class="line-modified">!         linkAllSlowCases(iter);</span>
  
          copyCalleeSavesFromFrameOrRegisterToEntryFrameCalleeSavesBuffer(vm().topEntryFrame);
  
<span class="line-modified">!         callOperation(operationOptimize, &amp;vm(), m_bytecodeIndex.asBits());</span>
<span class="line-modified">!         Jump noOptimizedEntry = branchTestPtr(Zero, returnValueGPR);</span>
<span class="line-modified">!         if (ASSERT_ENABLED) {</span>
              Jump ok = branchPtr(MacroAssembler::Above, returnValueGPR, TrustedImmPtr(bitwise_cast&lt;void*&gt;(static_cast&lt;intptr_t&gt;(1000))));
              abortWithReason(JITUnreasonableLoopHintJumpTarget);
              ok.link(this);
          }
          farJump(returnValueGPR, GPRInfo::callFrameRegister);
<span class="line-added">+         noOptimizedEntry.link(this);</span>
<span class="line-added">+ </span>
<span class="line-added">+         emitJumpSlowToHot(jump(), currentInstruction-&gt;size());</span>
      }
  #else
      UNUSED_PARAM(currentInstruction);
<span class="line-added">+     UNUSED_PARAM(iter);</span>
  #endif
  }
  
<span class="line-added">+ void JIT::emit_op_check_traps(const Instruction*)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     addSlowCase(branchTest8(NonZero, AbsoluteAddress(m_vm-&gt;needTrapHandlingAddress())));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void JIT::emit_op_nop(const Instruction*)
  {
  }
  
  void JIT::emit_op_super_sampler_begin(const Instruction*)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1055,85 ***</span>
  void JIT::emit_op_super_sampler_end(const Instruction*)
  {
      sub32(TrustedImm32(1), AbsoluteAddress(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount)));
  }
  
<span class="line-modified">! void JIT::emit_op_enter(const Instruction*)</span>
  {
<span class="line-modified">!     // Even though JIT doesn&#39;t use them, we initialize our constant</span>
<span class="line-removed">-     // registers to zap stale pointers, to avoid unnecessarily prolonging</span>
<span class="line-removed">-     // object lifetime and increasing GC pressure.</span>
<span class="line-removed">-     size_t count = m_codeBlock-&gt;numVars();</span>
<span class="line-removed">-     for (size_t i = CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters(); i &lt; count; ++i)</span>
<span class="line-removed">-         emitInitRegister(virtualRegisterForLocal(i).offset());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     emitWriteBarrier(m_codeBlock);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Check traps.</span>
<span class="line-removed">-     addSlowCase(branchTest8(NonZero, AbsoluteAddress(m_vm-&gt;needTrapHandlingAddress())));</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if ENABLE(DFG_JIT)</span>
<span class="line-removed">-     if (canBeOptimized())</span>
<span class="line-removed">-         addSlowCase(branchAdd32(PositiveOrZero, TrustedImm32(Options::executionCounterIncrementForEntry()), AbsoluteAddress(m_codeBlock-&gt;addressOfJITExecuteCounter())));</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void JIT::emitSlow_op_enter(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     linkSlowCase(iter);</span>
<span class="line-removed">-     callOperation(operationHandleTraps);</span>
<span class="line-removed">- #if ENABLE(DFG_JIT)</span>
<span class="line-removed">-     if (canBeOptimized()) {</span>
<span class="line-removed">-         emitJumpSlowToHot(branchAdd32(Signed, TrustedImm32(Options::executionCounterIncrementForEntry()), AbsoluteAddress(m_codeBlock-&gt;addressOfJITExecuteCounter())), currentInstruction-&gt;size());</span>
<span class="line-removed">-         linkSlowCase(iter);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ASSERT(!m_bytecodeOffset);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         copyCalleeSavesFromFrameOrRegisterToEntryFrameCalleeSavesBuffer(vm().topEntryFrame);</span>
  
<span class="line-modified">!         callOperation(operationOptimize, m_bytecodeOffset);</span>
<span class="line-removed">-         emitJumpSlowToHot(branchTestPtr(Zero, returnValueGPR), currentInstruction-&gt;size());</span>
<span class="line-removed">-         farJump(returnValueGPR, GPRInfo::callFrameRegister);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     UNUSED_PARAM(currentInstruction);</span>
<span class="line-removed">- #endif</span>
  }
  
  void JIT::emit_op_new_regexp(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNewRegexp&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int regexp = bytecode.m_regexp.offset();</span>
<span class="line-modified">!     callOperation(operationNewRegexp, jsCast&lt;RegExp*&gt;(m_codeBlock-&gt;getConstant(regexp)));</span>
      emitStoreCell(dst, returnValueGPR);
  }
  
  template&lt;typename Op&gt;
  void JIT::emitNewFuncCommon(const Instruction* currentInstruction)
  {
      Jump lazyJump;
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
  
  #if USE(JSVALUE64)
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_scope.offset(), regT0);</span>
  #else
<span class="line-modified">!     emitLoadPayload(bytecode.m_scope.offset(), regT0);</span>
  #endif
      FunctionExecutable* funcExec = m_codeBlock-&gt;functionDecl(bytecode.m_functionDecl);
  
      OpcodeID opcodeID = Op::opcodeID;
      if (opcodeID == op_new_func)
<span class="line-modified">!         callOperation(operationNewFunction, dst, regT0, funcExec);</span>
      else if (opcodeID == op_new_generator_func)
<span class="line-modified">!         callOperation(operationNewGeneratorFunction, dst, regT0, funcExec);</span>
      else if (opcodeID == op_new_async_func)
<span class="line-modified">!         callOperation(operationNewAsyncFunction, dst, regT0, funcExec);</span>
      else {
          ASSERT(opcodeID == op_new_async_generator_func);
<span class="line-modified">!         callOperation(operationNewAsyncGeneratorFunction, dst, regT0, funcExec);</span>
      }
  }
  
  void JIT::emit_op_new_func(const Instruction* currentInstruction)
  {
<span class="line-new-header">--- 1109,50 ---</span>
  void JIT::emit_op_super_sampler_end(const Instruction*)
  {
      sub32(TrustedImm32(1), AbsoluteAddress(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount)));
  }
  
<span class="line-modified">! void JIT::emitSlow_op_check_traps(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)</span>
  {
<span class="line-modified">!     linkAllSlowCases(iter);</span>
  
<span class="line-modified">!     callOperation(operationHandleTraps, TrustedImmPtr(m_codeBlock-&gt;globalObject()));</span>
  }
  
  void JIT::emit_op_new_regexp(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNewRegexp&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister regexp = bytecode.m_regexp;</span>
<span class="line-modified">!     callOperation(operationNewRegexp, TrustedImmPtr(m_codeBlock-&gt;globalObject()), jsCast&lt;RegExp*&gt;(m_codeBlock-&gt;getConstant(regexp)));</span>
      emitStoreCell(dst, returnValueGPR);
  }
  
  template&lt;typename Op&gt;
  void JIT::emitNewFuncCommon(const Instruction* currentInstruction)
  {
      Jump lazyJump;
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
  
  #if USE(JSVALUE64)
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_scope, regT0);</span>
  #else
<span class="line-modified">!     emitLoadPayload(bytecode.m_scope, regT0);</span>
  #endif
      FunctionExecutable* funcExec = m_codeBlock-&gt;functionDecl(bytecode.m_functionDecl);
  
      OpcodeID opcodeID = Op::opcodeID;
      if (opcodeID == op_new_func)
<span class="line-modified">!         callOperation(operationNewFunction, dst, &amp;vm(), regT0, funcExec);</span>
      else if (opcodeID == op_new_generator_func)
<span class="line-modified">!         callOperation(operationNewGeneratorFunction, dst, &amp;vm(), regT0, funcExec);</span>
      else if (opcodeID == op_new_async_func)
<span class="line-modified">!         callOperation(operationNewAsyncFunction, dst, &amp;vm(), regT0, funcExec);</span>
      else {
          ASSERT(opcodeID == op_new_async_generator_func);
<span class="line-modified">!         callOperation(operationNewAsyncGeneratorFunction, dst, &amp;vm(), regT0, funcExec);</span>
      }
  }
  
  void JIT::emit_op_new_func(const Instruction* currentInstruction)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1157,29 ***</span>
  
  template&lt;typename Op&gt;
  void JIT::emitNewFuncExprCommon(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
  #if USE(JSVALUE64)
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_scope.offset(), regT0);</span>
  #else
<span class="line-modified">!     emitLoadPayload(bytecode.m_scope.offset(), regT0);</span>
  #endif
  
      FunctionExecutable* function = m_codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
      OpcodeID opcodeID = Op::opcodeID;
  
      if (opcodeID == op_new_func_exp)
<span class="line-modified">!         callOperation(operationNewFunction, dst, regT0, function);</span>
      else if (opcodeID == op_new_generator_func_exp)
<span class="line-modified">!         callOperation(operationNewGeneratorFunction, dst, regT0, function);</span>
      else if (opcodeID == op_new_async_func_exp)
<span class="line-modified">!         callOperation(operationNewAsyncFunction, dst, regT0, function);</span>
      else {
          ASSERT(opcodeID == op_new_async_generator_func_exp);
<span class="line-modified">!         callOperation(operationNewAsyncGeneratorFunction, dst, regT0, function);</span>
      }
  }
  
  void JIT::emit_op_new_func_exp(const Instruction* currentInstruction)
  {
<span class="line-new-header">--- 1176,29 ---</span>
  
  template&lt;typename Op&gt;
  void JIT::emitNewFuncExprCommon(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
  #if USE(JSVALUE64)
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_scope, regT0);</span>
  #else
<span class="line-modified">!     emitLoadPayload(bytecode.m_scope, regT0);</span>
  #endif
  
      FunctionExecutable* function = m_codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
      OpcodeID opcodeID = Op::opcodeID;
  
      if (opcodeID == op_new_func_exp)
<span class="line-modified">!         callOperation(operationNewFunction, dst, &amp;vm(), regT0, function);</span>
      else if (opcodeID == op_new_generator_func_exp)
<span class="line-modified">!         callOperation(operationNewGeneratorFunction, dst, &amp;vm(), regT0, function);</span>
      else if (opcodeID == op_new_async_func_exp)
<span class="line-modified">!         callOperation(operationNewAsyncFunction, dst, &amp;vm(), regT0, function);</span>
      else {
          ASSERT(opcodeID == op_new_async_generator_func_exp);
<span class="line-modified">!         callOperation(operationNewAsyncGeneratorFunction, dst, &amp;vm(), regT0, function);</span>
      }
  }
  
  void JIT::emit_op_new_func_exp(const Instruction* currentInstruction)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1203,42 ***</span>
  
  void JIT::emit_op_new_array(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNewArray&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int valuesIndex = bytecode.m_argv.offset();</span>
      int size = bytecode.m_argc;
<span class="line-modified">!     addPtr(TrustedImm32(valuesIndex * sizeof(Register)), callFrameRegister, regT0);</span>
<span class="line-modified">!     callOperation(operationNewArrayWithProfile, dst,</span>
          &amp;metadata.m_arrayAllocationProfile, regT0, size);
  }
  
  void JIT::emit_op_new_array_with_size(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNewArrayWithSize&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int sizeIndex = bytecode.m_length.offset();</span>
  #if USE(JSVALUE64)
      emitGetVirtualRegister(sizeIndex, regT0);
<span class="line-modified">!     callOperation(operationNewArrayWithSizeAndProfile, dst,</span>
          &amp;metadata.m_arrayAllocationProfile, regT0);
  #else
      emitLoad(sizeIndex, regT1, regT0);
<span class="line-modified">!     callOperation(operationNewArrayWithSizeAndProfile, dst,</span>
          &amp;metadata.m_arrayAllocationProfile, JSValueRegs(regT1, regT0));
  #endif
  }
  
  #if USE(JSVALUE64)
  void JIT::emit_op_has_structure_property(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpHasStructureProperty&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int enumerator = bytecode.m_enumerator.offset();</span>
  
      emitGetVirtualRegister(base, regT0);
      emitGetVirtualRegister(enumerator, regT1);
      emitJumpSlowCaseIfNotJSCell(regT0, base);
  
<span class="line-new-header">--- 1222,42 ---</span>
  
  void JIT::emit_op_new_array(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNewArray&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister valuesStart = bytecode.m_argv;</span>
      int size = bytecode.m_argc;
<span class="line-modified">!     addPtr(TrustedImm32(valuesStart.offset() * sizeof(Register)), callFrameRegister, regT0);</span>
<span class="line-modified">!     callOperation(operationNewArrayWithProfile, dst, TrustedImmPtr(m_codeBlock-&gt;globalObject()),</span>
          &amp;metadata.m_arrayAllocationProfile, regT0, size);
  }
  
  void JIT::emit_op_new_array_with_size(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNewArrayWithSize&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister sizeIndex = bytecode.m_length;</span>
  #if USE(JSVALUE64)
      emitGetVirtualRegister(sizeIndex, regT0);
<span class="line-modified">!     callOperation(operationNewArrayWithSizeAndProfile, dst, TrustedImmPtr(m_codeBlock-&gt;globalObject()),</span>
          &amp;metadata.m_arrayAllocationProfile, regT0);
  #else
      emitLoad(sizeIndex, regT1, regT0);
<span class="line-modified">!     callOperation(operationNewArrayWithSizeAndProfile, dst, TrustedImmPtr(m_codeBlock-&gt;globalObject()),</span>
          &amp;metadata.m_arrayAllocationProfile, JSValueRegs(regT1, regT0));
  #endif
  }
  
  #if USE(JSVALUE64)
  void JIT::emit_op_has_structure_property(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpHasStructureProperty&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister enumerator = bytecode.m_enumerator;</span>
  
      emitGetVirtualRegister(base, regT0);
      emitGetVirtualRegister(enumerator, regT1);
      emitJumpSlowCaseIfNotJSCell(regT0, base);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1278,13 ***</span>
  
  void JIT::emit_op_has_indexed_property(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpHasIndexedProperty&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int property = bytecode.m_property.offset();</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
      ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();
  
      emitGetVirtualRegisters(base, regT0, property, regT1);
  
<span class="line-new-header">--- 1297,13 ---</span>
  
  void JIT::emit_op_has_indexed_property(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpHasIndexedProperty&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister property = bytecode.m_property;</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
      ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();
  
      emitGetVirtualRegisters(base, regT0, property, regT1);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1318,41 ***</span>
  
      emitPutVirtualRegister(dst);
  
      Label nextHotPath = label();
  
<span class="line-modified">!     m_byValCompilationInfo.append(ByValCompilationInfo(byValInfo, m_bytecodeOffset, PatchableJump(), badType, mode, profile, done, nextHotPath));</span>
  }
  
  void JIT::emitSlow_op_has_indexed_property(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpHasIndexedProperty&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int property = bytecode.m_property.offset();</span>
      ByValInfo* byValInfo = m_byValCompilationInfo[m_byValInstructionIndex].byValInfo;
  
      Label slowPath = label();
  
      emitGetVirtualRegister(base, regT0);
      emitGetVirtualRegister(property, regT1);
<span class="line-modified">!     Call call = callOperation(operationHasIndexedPropertyDefault, dst, regT0, regT1, byValInfo);</span>
  
      m_byValCompilationInfo[m_byValInstructionIndex].slowPathTarget = slowPath;
      m_byValCompilationInfo[m_byValInstructionIndex].returnAddress = call;
      m_byValInstructionIndex++;
  }
  
  void JIT::emit_op_get_direct_pname(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetDirectPname&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int index = bytecode.m_index.offset();</span>
<span class="line-modified">!     int enumerator = bytecode.m_enumerator.offset();</span>
  
      // Check that base is a cell
      emitGetVirtualRegister(base, regT0);
      emitJumpSlowCaseIfNotJSCell(regT0, base);
  
<span class="line-new-header">--- 1337,41 ---</span>
  
      emitPutVirtualRegister(dst);
  
      Label nextHotPath = label();
  
<span class="line-modified">!     m_byValCompilationInfo.append(ByValCompilationInfo(byValInfo, m_bytecodeIndex, PatchableJump(), badType, mode, profile, done, nextHotPath));</span>
  }
  
  void JIT::emitSlow_op_has_indexed_property(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpHasIndexedProperty&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister property = bytecode.m_property;</span>
      ByValInfo* byValInfo = m_byValCompilationInfo[m_byValInstructionIndex].byValInfo;
  
      Label slowPath = label();
  
      emitGetVirtualRegister(base, regT0);
      emitGetVirtualRegister(property, regT1);
<span class="line-modified">!     Call call = callOperation(operationHasIndexedPropertyDefault, dst, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, regT1, byValInfo);</span>
  
      m_byValCompilationInfo[m_byValInstructionIndex].slowPathTarget = slowPath;
      m_byValCompilationInfo[m_byValInstructionIndex].returnAddress = call;
      m_byValInstructionIndex++;
  }
  
  void JIT::emit_op_get_direct_pname(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetDirectPname&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister index = bytecode.m_index;</span>
<span class="line-modified">!     VirtualRegister enumerator = bytecode.m_enumerator;</span>
  
      // Check that base is a cell
      emitGetVirtualRegister(base, regT0);
      emitJumpSlowCaseIfNotJSCell(regT0, base);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1386,13 ***</span>
  }
  
  void JIT::emit_op_enumerator_structure_pname(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEnumeratorStructurePname&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int enumerator = bytecode.m_enumerator.offset();</span>
<span class="line-modified">!     int index = bytecode.m_index.offset();</span>
  
      emitGetVirtualRegister(index, regT0);
      emitGetVirtualRegister(enumerator, regT1);
      Jump inBounds = branch32(Below, regT0, Address(regT1, JSPropertyNameEnumerator::endStructurePropertyIndexOffset()));
  
<span class="line-new-header">--- 1405,13 ---</span>
  }
  
  void JIT::emit_op_enumerator_structure_pname(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEnumeratorStructurePname&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister enumerator = bytecode.m_enumerator;</span>
<span class="line-modified">!     VirtualRegister index = bytecode.m_index;</span>
  
      emitGetVirtualRegister(index, regT0);
      emitGetVirtualRegister(enumerator, regT1);
      Jump inBounds = branch32(Below, regT0, Address(regT1, JSPropertyNameEnumerator::endStructurePropertyIndexOffset()));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1410,13 ***</span>
  }
  
  void JIT::emit_op_enumerator_generic_pname(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEnumeratorGenericPname&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int enumerator = bytecode.m_enumerator.offset();</span>
<span class="line-modified">!     int index = bytecode.m_index.offset();</span>
  
      emitGetVirtualRegister(index, regT0);
      emitGetVirtualRegister(enumerator, regT1);
      Jump inBounds = branch32(Below, regT0, Address(regT1, JSPropertyNameEnumerator::endGenericPropertyIndexOffset()));
  
<span class="line-new-header">--- 1429,13 ---</span>
  }
  
  void JIT::emit_op_enumerator_generic_pname(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEnumeratorGenericPname&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister enumerator = bytecode.m_enumerator;</span>
<span class="line-modified">!     VirtualRegister index = bytecode.m_index;</span>
  
      emitGetVirtualRegister(index, regT0);
      emitGetVirtualRegister(enumerator, regT1);
      Jump inBounds = branch32(Below, regT0, Address(regT1, JSPropertyNameEnumerator::endGenericPropertyIndexOffset()));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1436,11 ***</span>
  void JIT::emit_op_profile_type(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpProfileType&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
      TypeLocation* cachedTypeLocation = metadata.m_typeLocation;
<span class="line-modified">!     int valueToProfile = bytecode.m_targetVirtualRegister.offset();</span>
  
      emitGetVirtualRegister(valueToProfile, regT0);
  
      JumpList jumpToEnd;
  
<span class="line-new-header">--- 1455,11 ---</span>
  void JIT::emit_op_profile_type(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpProfileType&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
      TypeLocation* cachedTypeLocation = metadata.m_typeLocation;
<span class="line-modified">!     VirtualRegister valueToProfile = bytecode.m_targetVirtualRegister;</span>
  
      emitGetVirtualRegister(valueToProfile, regT0);
  
      JumpList jumpToEnd;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1489,11 ***</span>
      // Increment the current log entry.
      addPtr(TrustedImm32(sizeof(TypeProfilerLog::LogEntry)), regT1);
      store64(regT1, Address(regT2, TypeProfilerLog::currentLogEntryOffset()));
      Jump skipClearLog = branchPtr(NotEqual, regT1, TrustedImmPtr(cachedTypeProfilerLog-&gt;logEndPtr()));
      // Clear the log if we&#39;re at the end of the log.
<span class="line-modified">!     callOperation(operationProcessTypeProfilerLog);</span>
      skipClearLog.link(this);
  
      jumpToEnd.link(this);
  }
  
<span class="line-new-header">--- 1508,11 ---</span>
      // Increment the current log entry.
      addPtr(TrustedImm32(sizeof(TypeProfilerLog::LogEntry)), regT1);
      store64(regT1, Address(regT2, TypeProfilerLog::currentLogEntryOffset()));
      Jump skipClearLog = branchPtr(NotEqual, regT1, TrustedImmPtr(cachedTypeProfilerLog-&gt;logEndPtr()));
      // Clear the log if we&#39;re at the end of the log.
<span class="line-modified">!     callOperation(operationProcessTypeProfilerLog, &amp;vm());</span>
      skipClearLog.link(this);
  
      jumpToEnd.link(this);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1505,11 ***</span>
      auto bytecode = currentInstruction-&gt;as&lt;OpLogShadowChickenPrologue&gt;();
      GPRReg shadowPacketReg = regT0;
      GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
      GPRReg scratch2Reg = regT2;
      ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_scope.offset(), regT3);</span>
      logShadowChickenProloguePacket(shadowPacketReg, scratch1Reg, regT3);
  }
  
  void JIT::emit_op_log_shadow_chicken_tail(const Instruction* currentInstruction)
  {
<span class="line-new-header">--- 1524,11 ---</span>
      auto bytecode = currentInstruction-&gt;as&lt;OpLogShadowChickenPrologue&gt;();
      GPRReg shadowPacketReg = regT0;
      GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
      GPRReg scratch2Reg = regT2;
      ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_scope, regT3);</span>
      logShadowChickenProloguePacket(shadowPacketReg, scratch1Reg, regT3);
  }
  
  void JIT::emit_op_log_shadow_chicken_tail(const Instruction* currentInstruction)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1519,13 ***</span>
      auto bytecode = currentInstruction-&gt;as&lt;OpLogShadowChickenTail&gt;();
      GPRReg shadowPacketReg = regT0;
      GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
      GPRReg scratch2Reg = regT2;
      ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_thisValue.offset(), regT2);</span>
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_scope.offset(), regT3);</span>
<span class="line-modified">!     logShadowChickenTailPacket(shadowPacketReg, JSValueRegs(regT2), regT3, m_codeBlock, CallSiteIndex(m_bytecodeOffset));</span>
  }
  
  #endif // USE(JSVALUE64)
  
  void JIT::emit_op_profile_control_flow(const Instruction* currentInstruction)
<span class="line-new-header">--- 1538,13 ---</span>
      auto bytecode = currentInstruction-&gt;as&lt;OpLogShadowChickenTail&gt;();
      GPRReg shadowPacketReg = regT0;
      GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
      GPRReg scratch2Reg = regT2;
      ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_thisValue, regT2);</span>
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_scope, regT3);</span>
<span class="line-modified">!     logShadowChickenTailPacket(shadowPacketReg, JSValueRegs(regT2), regT3, m_codeBlock, CallSiteIndex(m_bytecodeIndex));</span>
  }
  
  #endif // USE(JSVALUE64)
  
  void JIT::emit_op_profile_control_flow(const Instruction* currentInstruction)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1541,24 ***</span>
  }
  
  void JIT::emit_op_argument_count(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpArgumentCount&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     load32(payloadFor(CallFrameSlot::argumentCount), regT0);</span>
      sub32(TrustedImm32(1), regT0);
      JSValueRegs result = JSValueRegs::withTwoAvailableRegs(regT0, regT1);
      boxInt32(regT0, result);
      emitPutVirtualRegister(dst, result);
  }
  
  void JIT::emit_op_get_rest_length(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetRestLength&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
      unsigned numParamsToSkip = bytecode.m_numParametersToSkip;
<span class="line-modified">!     load32(payloadFor(CallFrameSlot::argumentCount), regT0);</span>
      sub32(TrustedImm32(1), regT0);
      Jump zeroLength = branch32(LessThanOrEqual, regT0, Imm32(numParamsToSkip));
      sub32(Imm32(numParamsToSkip), regT0);
  #if USE(JSVALUE64)
      boxInt32(regT0, JSValueRegs(regT0));
<span class="line-new-header">--- 1560,24 ---</span>
  }
  
  void JIT::emit_op_argument_count(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpArgumentCount&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     load32(payloadFor(CallFrameSlot::argumentCountIncludingThis), regT0);</span>
      sub32(TrustedImm32(1), regT0);
      JSValueRegs result = JSValueRegs::withTwoAvailableRegs(regT0, regT1);
      boxInt32(regT0, result);
      emitPutVirtualRegister(dst, result);
  }
  
  void JIT::emit_op_get_rest_length(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetRestLength&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
      unsigned numParamsToSkip = bytecode.m_numParametersToSkip;
<span class="line-modified">!     load32(payloadFor(CallFrameSlot::argumentCountIncludingThis), regT0);</span>
      sub32(TrustedImm32(1), regT0);
      Jump zeroLength = branch32(LessThanOrEqual, regT0, Imm32(numParamsToSkip));
      sub32(Imm32(numParamsToSkip), regT0);
  #if USE(JSVALUE64)
      boxInt32(regT0, JSValueRegs(regT0));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1582,21 ***</span>
  }
  
  void JIT::emit_op_get_argument(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetArgument&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
      int index = bytecode.m_index;
  #if USE(JSVALUE64)
      JSValueRegs resultRegs(regT0);
  #else
      JSValueRegs resultRegs(regT1, regT0);
  #endif
  
<span class="line-modified">!     load32(payloadFor(CallFrameSlot::argumentCount), regT2);</span>
      Jump argumentOutOfBounds = branch32(LessThanOrEqual, regT2, TrustedImm32(index));
<span class="line-modified">!     loadValue(addressFor(CallFrameSlot::thisArgument + index), resultRegs);</span>
      Jump done = jump();
  
      argumentOutOfBounds.link(this);
      moveValue(jsUndefined(), resultRegs);
  
<span class="line-new-header">--- 1601,21 ---</span>
  }
  
  void JIT::emit_op_get_argument(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetArgument&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
      int index = bytecode.m_index;
  #if USE(JSVALUE64)
      JSValueRegs resultRegs(regT0);
  #else
      JSValueRegs resultRegs(regT1, regT0);
  #endif
  
<span class="line-modified">!     load32(payloadFor(CallFrameSlot::argumentCountIncludingThis), regT2);</span>
      Jump argumentOutOfBounds = branch32(LessThanOrEqual, regT2, TrustedImm32(index));
<span class="line-modified">!     loadValue(addressFor(VirtualRegister(CallFrameSlot::thisArgument + index)), resultRegs);</span>
      Jump done = jump();
  
      argumentOutOfBounds.link(this);
      moveValue(jsUndefined(), resultRegs);
  
</pre>
<center><a href="JITNegGenerator.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITOpcodes32_64.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
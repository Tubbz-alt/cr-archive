<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSFontFaceSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSFontFace.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSFontFaceSource.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSFontFaceSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
140         return serifFamily.get();
141     case CSSValueSansSerif:
142         return sansSerifFamily.get();
143     case CSSValueCursive:
144         return cursiveFamily.get();
145     case CSSValueFantasy:
146         return fantasyFamily.get();
147     case CSSValueMonospace:
148         return monospaceFamily.get();
149     case CSSValueWebkitPictograph:
150         return pictographFamily.get();
151     case CSSValueSystemUi:
152         return systemUiFamily.get();
153     default:
154         return { };
155     }
156 }
157 
158 void CSSFontFaceSet::addToFacesLookupTable(CSSFontFace&amp; face)
159 {
<span class="line-modified">160     if (!face.families())</span>
161         return;

162 
<span class="line-modified">163     for (auto&amp; item : *face.families()) {</span>
164         String familyName = CSSFontFaceSet::familyNameFromPrimitive(downcast&lt;CSSPrimitiveValue&gt;(item.get()));
165         if (familyName.isEmpty())
166             continue;
167 
168         auto addResult = m_facesLookupTable.add(familyName, Vector&lt;Ref&lt;CSSFontFace&gt;&gt;());
169         auto&amp; familyFontFaces = addResult.iterator-&gt;value;
170         if (addResult.isNewEntry) {
171             // m_locallyInstalledFontFaces grows without bound, eventually encorporating every font installed on the system.
172             // This is by design.
173             if (m_owningFontSelector)
174                 ensureLocalFontFacesForFamilyRegistered(familyName);
175             familyFontFaces = { };
176         }
177 
178         familyFontFaces.append(face);
179     }
180 }
181 
182 void CSSFontFaceSet::add(CSSFontFace&amp; face)
183 {
</pre>
<hr />
<pre>
220                 found = true;
221                 iterator-&gt;value.remove(i);
222                 break;
223             }
224         }
225         ASSERT_UNUSED(found, found);
226         if (!iterator-&gt;value.size())
227             m_facesLookupTable.remove(iterator);
228     }
229 }
230 
231 void CSSFontFaceSet::remove(const CSSFontFace&amp; face)
232 {
233     auto protect = makeRef(face);
234 
235     m_cache.clear();
236 
237     for (auto* client : m_clients)
238         client-&gt;fontModified();
239 
<span class="line-modified">240     if (face.families())</span>
<span class="line-modified">241         removeFromFacesLookupTable(face, *face.families());</span>
242 
243     if (face.cssConnection()) {
244         ASSERT(m_constituentCSSConnections.get(face.cssConnection()) == &amp;face);
245         m_constituentCSSConnections.remove(face.cssConnection());
246     }
247 
248     for (size_t i = 0; i &lt; m_faces.size(); ++i) {
249         if (m_faces[i].ptr() == &amp;face) {
250             if (i &lt; m_facesPartitionIndex)
251                 --m_facesPartitionIndex;
252             m_faces[i]-&gt;removeClient(*this);
253             m_faces.remove(i);
254             if (face.status() == CSSFontFace::Status::Loading || face.status() == CSSFontFace::Status::TimedOut)
255                 decrementActiveCount();
256             return;
257         }
258     }
259     ASSERT_NOT_REACHED();
260 }
261 
</pre>
<hr />
<pre>
283 
284 void CSSFontFaceSet::clear()
285 {
286     for (auto&amp; face : m_faces)
287         face-&gt;removeClient(*this);
288     m_faces.clear();
289     m_facesLookupTable.clear();
290     m_locallyInstalledFacesLookupTable.clear();
291     m_cache.clear();
292     m_constituentCSSConnections.clear();
293     m_facesPartitionIndex = 0;
294     m_status = Status::Loaded;
295 }
296 
297 CSSFontFace&amp; CSSFontFaceSet::operator[](size_t i)
298 {
299     ASSERT(i &lt; faceCount());
300     return m_faces[i];
301 }
302 
<span class="line-modified">303 static FontSelectionRequest computeFontSelectionRequest(MutableStyleProperties&amp; style)</span>
304 {
305     RefPtr&lt;CSSValue&gt; weightValue = style.getPropertyCSSValue(CSSPropertyFontWeight).get();
<span class="line-modified">306     if (!weightValue)</span>
307         weightValue = CSSValuePool::singleton().createIdentifierValue(CSSValueNormal).ptr();
308 
309     RefPtr&lt;CSSValue&gt; stretchValue = style.getPropertyCSSValue(CSSPropertyFontStretch).get();
<span class="line-modified">310     if (!stretchValue)</span>
311         stretchValue = CSSValuePool::singleton().createIdentifierValue(CSSValueNormal).ptr();
312 
313     RefPtr&lt;CSSValue&gt; styleValue = style.getPropertyCSSValue(CSSPropertyFontStyle).get();
<span class="line-modified">314     if (!styleValue)</span>
315         styleValue = CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueNormal));
316 
<span class="line-modified">317     auto weightSelectionValue = StyleBuilderConverter::convertFontWeightFromValue(*weightValue);</span>
<span class="line-modified">318     auto stretchSelectionValue = StyleBuilderConverter::convertFontStretchFromValue(*stretchValue);</span>
<span class="line-modified">319     auto styleSelectionValue = StyleBuilderConverter::convertFontStyleFromValue(*styleValue);</span>



320 
<span class="line-modified">321     return { weightSelectionValue, stretchSelectionValue, styleSelectionValue };</span>
322 }
323 
324 static HashSet&lt;UChar32&gt; codePointsFromString(StringView stringView)
325 {
326     HashSet&lt;UChar32&gt; result;
327     auto graphemeClusters = stringView.graphemeClusters();
328     for (auto cluster : graphemeClusters) {
329         ASSERT(cluster.length() &gt; 0);
330         UChar32 character = 0;
331         if (cluster.is8Bit())
332             character = cluster[0];
333         else
334             U16_GET(cluster.characters16(), 0, 0, cluster.length(), character);
335         result.add(character);
336     }
337     return result;
338 }
339 
340 ExceptionOr&lt;Vector&lt;std::reference_wrapper&lt;CSSFontFace&gt;&gt;&gt; CSSFontFaceSet::matchingFacesExcludingPreinstalledFonts(const String&amp; font, const String&amp; string)
341 {
342     auto style = MutableStyleProperties::create();
343     auto parseResult = CSSParser::parseValue(style, CSSPropertyFont, font, true, HTMLStandardMode);
344     if (parseResult == CSSParser::ParseResult::Error)
345         return Exception { SyntaxError };
346 
<span class="line-modified">347     FontSelectionRequest request = computeFontSelectionRequest(style.get());</span>



348 
349     auto family = style-&gt;getPropertyCSSValue(CSSPropertyFontFamily);
350     if (!is&lt;CSSValueList&gt;(family))
351         return Exception { SyntaxError };
352     CSSValueList&amp; familyList = downcast&lt;CSSValueList&gt;(*family);
353 
354     HashSet&lt;AtomString&gt; uniqueFamilies;
355     Vector&lt;AtomString&gt; familyOrder;
356     for (auto&amp; family : familyList) {
357         auto&amp; primitive = downcast&lt;CSSPrimitiveValue&gt;(family.get());
358         if (!primitive.isFontFamily())
359             continue;
360         if (uniqueFamilies.add(primitive.fontFamily().familyName).isNewEntry)
361             familyOrder.append(primitive.fontFamily().familyName);
362     }
363 
364     HashSet&lt;CSSFontFace*&gt; resultConstituents;
365     for (auto codePoint : codePointsFromString(string)) {
366         bool found = false;
367         for (auto&amp; family : familyOrder) {
</pre>
<hr />
<pre>
403 }
404 
405 CSSSegmentedFontFace* CSSFontFaceSet::fontFace(FontSelectionRequest request, const AtomString&amp; family)
406 {
407     auto iterator = m_facesLookupTable.find(family);
408     if (iterator == m_facesLookupTable.end())
409         return nullptr;
410     auto&amp; familyFontFaces = iterator-&gt;value;
411 
412     auto&amp; segmentedFontFaceCache = m_cache.add(family, FontSelectionHashMap()).iterator-&gt;value;
413 
414     auto&amp; face = segmentedFontFaceCache.add(request, nullptr).iterator-&gt;value;
415     if (face)
416         return face.get();
417 
418     face = CSSSegmentedFontFace::create();
419 
420     Vector&lt;std::reference_wrapper&lt;CSSFontFace&gt;, 32&gt; candidateFontFaces;
421     for (int i = familyFontFaces.size() - 1; i &gt;= 0; --i) {
422         CSSFontFace&amp; candidate = familyFontFaces[i];
<span class="line-modified">423         auto capabilities = candidate.fontSelectionCapabilities();</span>



424         if (!isItalic(request.slope) &amp;&amp; isItalic(capabilities.slope.minimum))
425             continue;
426         candidateFontFaces.append(candidate);
427     }
428 
429     auto localIterator = m_locallyInstalledFacesLookupTable.find(family);
430     if (localIterator != m_locallyInstalledFacesLookupTable.end()) {
431         for (auto&amp; candidate : localIterator-&gt;value) {
<span class="line-modified">432             auto capabilities = candidate-&gt;fontSelectionCapabilities();</span>



433             if (!isItalic(request.slope) &amp;&amp; isItalic(capabilities.slope.minimum))
434                 continue;
435             candidateFontFaces.append(candidate);
436         }
437     }
438 
439     if (!candidateFontFaces.isEmpty()) {
440         Vector&lt;FontSelectionCapabilities&gt; capabilities;
441         capabilities.reserveInitialCapacity(candidateFontFaces.size());
<span class="line-modified">442         for (auto&amp; face : candidateFontFaces)</span>
<span class="line-modified">443             capabilities.uncheckedAppend(face.get().fontSelectionCapabilities());</span>




444         FontSelectionAlgorithm fontSelectionAlgorithm(request, capabilities);
445         std::stable_sort(candidateFontFaces.begin(), candidateFontFaces.end(), [&amp;fontSelectionAlgorithm](const CSSFontFace&amp; first, const CSSFontFace&amp; second) {
<span class="line-modified">446             auto firstCapabilities = first.fontSelectionCapabilities();</span>
<span class="line-modified">447             auto secondCapabilities = second.fontSelectionCapabilities();</span>

448 


449             auto stretchDistanceFirst = fontSelectionAlgorithm.stretchDistance(firstCapabilities).distance;
450             auto stretchDistanceSecond = fontSelectionAlgorithm.stretchDistance(secondCapabilities).distance;
451             if (stretchDistanceFirst &lt; stretchDistanceSecond)
452                 return true;
453             if (stretchDistanceFirst &gt; stretchDistanceSecond)
454                 return false;
455 
456             auto styleDistanceFirst = fontSelectionAlgorithm.styleDistance(firstCapabilities).distance;
457             auto styleDistanceSecond = fontSelectionAlgorithm.styleDistance(secondCapabilities).distance;
458             if (styleDistanceFirst &lt; styleDistanceSecond)
459                 return true;
460             if (styleDistanceFirst &gt; styleDistanceSecond)
461                 return false;
462 
463             auto weightDistanceFirst = fontSelectionAlgorithm.weightDistance(firstCapabilities).distance;
464             auto weightDistanceSecond = fontSelectionAlgorithm.weightDistance(secondCapabilities).distance;
465             if (weightDistanceFirst &lt; weightDistanceSecond)
466                 return true;
467             return false;
468         });
</pre>
</td>
<td>
<hr />
<pre>
140         return serifFamily.get();
141     case CSSValueSansSerif:
142         return sansSerifFamily.get();
143     case CSSValueCursive:
144         return cursiveFamily.get();
145     case CSSValueFantasy:
146         return fantasyFamily.get();
147     case CSSValueMonospace:
148         return monospaceFamily.get();
149     case CSSValueWebkitPictograph:
150         return pictographFamily.get();
151     case CSSValueSystemUi:
152         return systemUiFamily.get();
153     default:
154         return { };
155     }
156 }
157 
158 void CSSFontFaceSet::addToFacesLookupTable(CSSFontFace&amp; face)
159 {
<span class="line-modified">160     if (!face.families() || !face.families().hasValue())</span>
161         return;
<span class="line-added">162     auto families = face.families().value();</span>
163 
<span class="line-modified">164     for (auto&amp; item : *families) {</span>
165         String familyName = CSSFontFaceSet::familyNameFromPrimitive(downcast&lt;CSSPrimitiveValue&gt;(item.get()));
166         if (familyName.isEmpty())
167             continue;
168 
169         auto addResult = m_facesLookupTable.add(familyName, Vector&lt;Ref&lt;CSSFontFace&gt;&gt;());
170         auto&amp; familyFontFaces = addResult.iterator-&gt;value;
171         if (addResult.isNewEntry) {
172             // m_locallyInstalledFontFaces grows without bound, eventually encorporating every font installed on the system.
173             // This is by design.
174             if (m_owningFontSelector)
175                 ensureLocalFontFacesForFamilyRegistered(familyName);
176             familyFontFaces = { };
177         }
178 
179         familyFontFaces.append(face);
180     }
181 }
182 
183 void CSSFontFaceSet::add(CSSFontFace&amp; face)
184 {
</pre>
<hr />
<pre>
221                 found = true;
222                 iterator-&gt;value.remove(i);
223                 break;
224             }
225         }
226         ASSERT_UNUSED(found, found);
227         if (!iterator-&gt;value.size())
228             m_facesLookupTable.remove(iterator);
229     }
230 }
231 
232 void CSSFontFaceSet::remove(const CSSFontFace&amp; face)
233 {
234     auto protect = makeRef(face);
235 
236     m_cache.clear();
237 
238     for (auto* client : m_clients)
239         client-&gt;fontModified();
240 
<span class="line-modified">241     if (face.families() &amp;&amp; face.families().hasValue())</span>
<span class="line-modified">242         removeFromFacesLookupTable(face, *face.families().value());</span>
243 
244     if (face.cssConnection()) {
245         ASSERT(m_constituentCSSConnections.get(face.cssConnection()) == &amp;face);
246         m_constituentCSSConnections.remove(face.cssConnection());
247     }
248 
249     for (size_t i = 0; i &lt; m_faces.size(); ++i) {
250         if (m_faces[i].ptr() == &amp;face) {
251             if (i &lt; m_facesPartitionIndex)
252                 --m_facesPartitionIndex;
253             m_faces[i]-&gt;removeClient(*this);
254             m_faces.remove(i);
255             if (face.status() == CSSFontFace::Status::Loading || face.status() == CSSFontFace::Status::TimedOut)
256                 decrementActiveCount();
257             return;
258         }
259     }
260     ASSERT_NOT_REACHED();
261 }
262 
</pre>
<hr />
<pre>
284 
285 void CSSFontFaceSet::clear()
286 {
287     for (auto&amp; face : m_faces)
288         face-&gt;removeClient(*this);
289     m_faces.clear();
290     m_facesLookupTable.clear();
291     m_locallyInstalledFacesLookupTable.clear();
292     m_cache.clear();
293     m_constituentCSSConnections.clear();
294     m_facesPartitionIndex = 0;
295     m_status = Status::Loaded;
296 }
297 
298 CSSFontFace&amp; CSSFontFaceSet::operator[](size_t i)
299 {
300     ASSERT(i &lt; faceCount());
301     return m_faces[i];
302 }
303 
<span class="line-modified">304 static ExceptionOr&lt;FontSelectionRequest&gt; computeFontSelectionRequest(MutableStyleProperties&amp; style)</span>
305 {
306     RefPtr&lt;CSSValue&gt; weightValue = style.getPropertyCSSValue(CSSPropertyFontWeight).get();
<span class="line-modified">307     if (!weightValue || weightValue-&gt;isInitialValue())</span>
308         weightValue = CSSValuePool::singleton().createIdentifierValue(CSSValueNormal).ptr();
309 
310     RefPtr&lt;CSSValue&gt; stretchValue = style.getPropertyCSSValue(CSSPropertyFontStretch).get();
<span class="line-modified">311     if (!stretchValue || stretchValue-&gt;isInitialValue())</span>
312         stretchValue = CSSValuePool::singleton().createIdentifierValue(CSSValueNormal).ptr();
313 
314     RefPtr&lt;CSSValue&gt; styleValue = style.getPropertyCSSValue(CSSPropertyFontStyle).get();
<span class="line-modified">315     if (!styleValue || styleValue-&gt;isInitialValue())</span>
316         styleValue = CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueNormal));
317 
<span class="line-modified">318     if (weightValue-&gt;isGlobalKeyword() || stretchValue-&gt;isGlobalKeyword() || styleValue-&gt;isGlobalKeyword())</span>
<span class="line-modified">319         return Exception { SyntaxError };</span>
<span class="line-modified">320 </span>
<span class="line-added">321     auto weightSelectionValue = Style::BuilderConverter::convertFontWeightFromValue(*weightValue);</span>
<span class="line-added">322     auto stretchSelectionValue = Style::BuilderConverter::convertFontStretchFromValue(*stretchValue);</span>
<span class="line-added">323     auto styleSelectionValue = Style::BuilderConverter::convertFontStyleFromValue(*styleValue);</span>
324 
<span class="line-modified">325     return {{ weightSelectionValue, stretchSelectionValue, styleSelectionValue }};</span>
326 }
327 
328 static HashSet&lt;UChar32&gt; codePointsFromString(StringView stringView)
329 {
330     HashSet&lt;UChar32&gt; result;
331     auto graphemeClusters = stringView.graphemeClusters();
332     for (auto cluster : graphemeClusters) {
333         ASSERT(cluster.length() &gt; 0);
334         UChar32 character = 0;
335         if (cluster.is8Bit())
336             character = cluster[0];
337         else
338             U16_GET(cluster.characters16(), 0, 0, cluster.length(), character);
339         result.add(character);
340     }
341     return result;
342 }
343 
344 ExceptionOr&lt;Vector&lt;std::reference_wrapper&lt;CSSFontFace&gt;&gt;&gt; CSSFontFaceSet::matchingFacesExcludingPreinstalledFonts(const String&amp; font, const String&amp; string)
345 {
346     auto style = MutableStyleProperties::create();
347     auto parseResult = CSSParser::parseValue(style, CSSPropertyFont, font, true, HTMLStandardMode);
348     if (parseResult == CSSParser::ParseResult::Error)
349         return Exception { SyntaxError };
350 
<span class="line-modified">351     auto requestOrException = computeFontSelectionRequest(style.get());</span>
<span class="line-added">352     if (requestOrException.hasException())</span>
<span class="line-added">353         return requestOrException.releaseException();</span>
<span class="line-added">354     auto request = requestOrException.releaseReturnValue();</span>
355 
356     auto family = style-&gt;getPropertyCSSValue(CSSPropertyFontFamily);
357     if (!is&lt;CSSValueList&gt;(family))
358         return Exception { SyntaxError };
359     CSSValueList&amp; familyList = downcast&lt;CSSValueList&gt;(*family);
360 
361     HashSet&lt;AtomString&gt; uniqueFamilies;
362     Vector&lt;AtomString&gt; familyOrder;
363     for (auto&amp; family : familyList) {
364         auto&amp; primitive = downcast&lt;CSSPrimitiveValue&gt;(family.get());
365         if (!primitive.isFontFamily())
366             continue;
367         if (uniqueFamilies.add(primitive.fontFamily().familyName).isNewEntry)
368             familyOrder.append(primitive.fontFamily().familyName);
369     }
370 
371     HashSet&lt;CSSFontFace*&gt; resultConstituents;
372     for (auto codePoint : codePointsFromString(string)) {
373         bool found = false;
374         for (auto&amp; family : familyOrder) {
</pre>
<hr />
<pre>
410 }
411 
412 CSSSegmentedFontFace* CSSFontFaceSet::fontFace(FontSelectionRequest request, const AtomString&amp; family)
413 {
414     auto iterator = m_facesLookupTable.find(family);
415     if (iterator == m_facesLookupTable.end())
416         return nullptr;
417     auto&amp; familyFontFaces = iterator-&gt;value;
418 
419     auto&amp; segmentedFontFaceCache = m_cache.add(family, FontSelectionHashMap()).iterator-&gt;value;
420 
421     auto&amp; face = segmentedFontFaceCache.add(request, nullptr).iterator-&gt;value;
422     if (face)
423         return face.get();
424 
425     face = CSSSegmentedFontFace::create();
426 
427     Vector&lt;std::reference_wrapper&lt;CSSFontFace&gt;, 32&gt; candidateFontFaces;
428     for (int i = familyFontFaces.size() - 1; i &gt;= 0; --i) {
429         CSSFontFace&amp; candidate = familyFontFaces[i];
<span class="line-modified">430         auto capabilitiesWrapped = candidate.fontSelectionCapabilities();</span>
<span class="line-added">431         if (!capabilitiesWrapped.hasValue())</span>
<span class="line-added">432             continue;</span>
<span class="line-added">433         auto capabilities = capabilitiesWrapped.value();</span>
434         if (!isItalic(request.slope) &amp;&amp; isItalic(capabilities.slope.minimum))
435             continue;
436         candidateFontFaces.append(candidate);
437     }
438 
439     auto localIterator = m_locallyInstalledFacesLookupTable.find(family);
440     if (localIterator != m_locallyInstalledFacesLookupTable.end()) {
441         for (auto&amp; candidate : localIterator-&gt;value) {
<span class="line-modified">442             auto capabilitiesWrapped = candidate-&gt;fontSelectionCapabilities();</span>
<span class="line-added">443             if (!capabilitiesWrapped.hasValue())</span>
<span class="line-added">444                 continue;</span>
<span class="line-added">445             auto capabilities = capabilitiesWrapped.value();</span>
446             if (!isItalic(request.slope) &amp;&amp; isItalic(capabilities.slope.minimum))
447                 continue;
448             candidateFontFaces.append(candidate);
449         }
450     }
451 
452     if (!candidateFontFaces.isEmpty()) {
453         Vector&lt;FontSelectionCapabilities&gt; capabilities;
454         capabilities.reserveInitialCapacity(candidateFontFaces.size());
<span class="line-modified">455         for (auto&amp; face : candidateFontFaces) {</span>
<span class="line-modified">456             auto fontSelectionCapabilitiesWrapped = face.get().fontSelectionCapabilities();</span>
<span class="line-added">457             ASSERT(fontSelectionCapabilitiesWrapped.hasValue());</span>
<span class="line-added">458             auto fontSelectionCapabilities = fontSelectionCapabilitiesWrapped.value();</span>
<span class="line-added">459             capabilities.uncheckedAppend(fontSelectionCapabilities);</span>
<span class="line-added">460         }</span>
461         FontSelectionAlgorithm fontSelectionAlgorithm(request, capabilities);
462         std::stable_sort(candidateFontFaces.begin(), candidateFontFaces.end(), [&amp;fontSelectionAlgorithm](const CSSFontFace&amp; first, const CSSFontFace&amp; second) {
<span class="line-modified">463             auto firstCapabilitiesWrapped = first.fontSelectionCapabilities();</span>
<span class="line-modified">464             auto secondCapabilitiesWrapped = second.fontSelectionCapabilities();</span>
<span class="line-added">465             ASSERT(firstCapabilitiesWrapped.hasValue() &amp;&amp; secondCapabilitiesWrapped.hasValue());</span>
466 
<span class="line-added">467             auto firstCapabilities = firstCapabilitiesWrapped.value();</span>
<span class="line-added">468             auto secondCapabilities = secondCapabilitiesWrapped.value();</span>
469             auto stretchDistanceFirst = fontSelectionAlgorithm.stretchDistance(firstCapabilities).distance;
470             auto stretchDistanceSecond = fontSelectionAlgorithm.stretchDistance(secondCapabilities).distance;
471             if (stretchDistanceFirst &lt; stretchDistanceSecond)
472                 return true;
473             if (stretchDistanceFirst &gt; stretchDistanceSecond)
474                 return false;
475 
476             auto styleDistanceFirst = fontSelectionAlgorithm.styleDistance(firstCapabilities).distance;
477             auto styleDistanceSecond = fontSelectionAlgorithm.styleDistance(secondCapabilities).distance;
478             if (styleDistanceFirst &lt; styleDistanceSecond)
479                 return true;
480             if (styleDistanceFirst &gt; styleDistanceSecond)
481                 return false;
482 
483             auto weightDistanceFirst = fontSelectionAlgorithm.weightDistance(firstCapabilities).distance;
484             auto weightDistanceSecond = fontSelectionAlgorithm.weightDistance(secondCapabilities).distance;
485             if (weightDistanceFirst &lt; weightDistanceSecond)
486                 return true;
487             return false;
488         });
</pre>
</td>
</tr>
</table>
<center><a href="CSSFontFace.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSFontFaceSource.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/PlatformCPU.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2020 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #ifndef WTF_PLATFORM_GUARD_AGAINST_INDIRECT_INCLUSION
 29 #error &quot;Please #include &lt;wtf/Platform.h&gt; instead of this file directly.&quot;
 30 #endif
 31 
 32 /* CPU() - the target CPU architecture */
 33 #define CPU(WTF_FEATURE) (defined WTF_CPU_##WTF_FEATURE  &amp;&amp; WTF_CPU_##WTF_FEATURE)
 34 
 35 /* ==== CPU() - the target CPU architecture ==== */
 36 /* CPU(KNOWN) becomes true if we explicitly support a target CPU. */
 37 
 38 /* CPU(MIPS) - MIPS 32-bit and 64-bit */
 39 #if (defined(mips) || defined(__mips__) || defined(MIPS) || defined(_MIPS_) || defined(__mips64))
 40 #if defined(_ABI64) &amp;&amp; (_MIPS_SIM == _ABI64)
 41 #define WTF_CPU_MIPS64 1
 42 #define WTF_MIPS_ARCH __mips64
 43 #else
 44 #define WTF_CPU_MIPS 1
 45 #define WTF_MIPS_ARCH __mips
 46 #endif
 47 #define WTF_CPU_KNOWN 1
 48 #define WTF_MIPS_PIC (defined __PIC__)
 49 #define WTF_MIPS_ISA(v) (defined WTF_MIPS_ARCH &amp;&amp; WTF_MIPS_ARCH == v)
 50 #define WTF_MIPS_ISA_AT_LEAST(v) (defined WTF_MIPS_ARCH &amp;&amp; WTF_MIPS_ARCH &gt;= v)
 51 #define WTF_MIPS_ARCH_REV __mips_isa_rev
 52 #define WTF_MIPS_ISA_REV(v) (defined WTF_MIPS_ARCH_REV &amp;&amp; WTF_MIPS_ARCH_REV == v)
 53 #define WTF_MIPS_ISA_REV_AT_LEAST(v) (defined WTF_MIPS_ARCH_REV &amp;&amp; WTF_MIPS_ARCH_REV &gt;= v)
 54 #define WTF_MIPS_DOUBLE_FLOAT (defined __mips_hard_float &amp;&amp; !defined __mips_single_float)
 55 #define WTF_MIPS_FP64 (defined __mips_fpr &amp;&amp; __mips_fpr == 64)
 56 #endif
 57 
 58 /* CPU(PPC64) - PowerPC 64-bit Big Endian */
 59 #if (  defined(__ppc64__)      \
 60     || defined(__PPC64__))     \
 61     &amp;&amp; defined(__BYTE_ORDER__) \
 62     &amp;&amp; (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
 63 #define WTF_CPU_PPC64 1
 64 #define WTF_CPU_KNOWN 1
 65 #endif
 66 
 67 /* CPU(PPC64LE) - PowerPC 64-bit Little Endian */
 68 #if (   defined(__ppc64__)     \
 69     || defined(__PPC64__)      \
 70     || defined(__ppc64le__)    \
 71     || defined(__PPC64LE__))   \
 72     &amp;&amp; defined(__BYTE_ORDER__) \
 73     &amp;&amp; (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
 74 #define WTF_CPU_PPC64LE 1
 75 #define WTF_CPU_KNOWN 1
 76 #endif
 77 
 78 /* CPU(PPC) - PowerPC 32-bit */
 79 #if (  defined(__ppc__)        \
 80     || defined(__PPC__)        \
 81     || defined(__powerpc__)    \
 82     || defined(__powerpc)      \
 83     || defined(__POWERPC__)    \
 84     || defined(_M_PPC)         \
 85     || defined(__PPC))         \
 86     &amp;&amp; !CPU(PPC64)             \
 87     &amp;&amp; CPU(BIG_ENDIAN)
 88 #define WTF_CPU_PPC 1
 89 #define WTF_CPU_KNOWN 1
 90 #endif
 91 
 92 /* CPU(X86) - i386 / x86 32-bit */
 93 #if   defined(__i386__) \
 94     || defined(i386)     \
 95     || defined(_M_IX86)  \
 96     || defined(_X86_)    \
 97     || defined(__THW_INTEL)
 98 #define WTF_CPU_X86 1
 99 #define WTF_CPU_KNOWN 1
100 
101 #if defined(__SSE2__) || (defined(_M_IX86_FP) &amp;&amp; _M_IX86_FP &gt;= 2)
102 #define WTF_CPU_X86_SSE2 1
103 #endif
104 
105 #endif
106 
107 /* CPU(X86_64) - AMD64 / Intel64 / x86_64 64-bit */
108 #if   defined(__x86_64__) \
109     || defined(_M_X64)
110 #define WTF_CPU_X86_64 1
111 #define WTF_CPU_X86_SSE2 1
112 #define WTF_CPU_KNOWN 1
113 #endif
114 
115 /* CPU(ARM64) - Apple */
116 #if (defined(__arm64__) &amp;&amp; defined(__APPLE__)) || defined(__aarch64__)
117 #define WTF_CPU_ARM64 1
118 #define WTF_CPU_KNOWN 1
119 
120 #if defined(__arm64e__)
121 #define WTF_CPU_ARM64E 1
122 #endif
123 #endif
124 
125 /* CPU(ARM) - ARM, any version*/
126 #define WTF_ARM_ARCH_AT_LEAST(N) (CPU(ARM) &amp;&amp; WTF_ARM_ARCH_VERSION &gt;= N)
127 
128 #if   defined(arm) \
129     || defined(__arm__) \
130     || defined(ARM) \
131     || defined(_ARM_)
132 #define WTF_CPU_ARM 1
133 #define WTF_CPU_KNOWN 1
134 
135 #if defined(__ARM_PCS_VFP)
136 #define WTF_CPU_ARM_HARDFP 1
137 #endif
138 
139 /* Set WTF_ARM_ARCH_VERSION */
140 #if   defined(__ARM_ARCH_4__) \
141     || defined(__ARM_ARCH_4T__) \
142     || defined(__MARM_ARMV4__)
143 #define WTF_ARM_ARCH_VERSION 4
144 
145 #elif defined(__ARM_ARCH_5__) \
146     || defined(__ARM_ARCH_5T__) \
147     || defined(__MARM_ARMV5__)
148 #define WTF_ARM_ARCH_VERSION 5
149 
150 #elif defined(__ARM_ARCH_5E__) \
151     || defined(__ARM_ARCH_5TE__) \
152     || defined(__ARM_ARCH_5TEJ__)
153 #define WTF_ARM_ARCH_VERSION 5
154 
155 #elif defined(__ARM_ARCH_6__) \
156     || defined(__ARM_ARCH_6J__) \
157     || defined(__ARM_ARCH_6K__) \
158     || defined(__ARM_ARCH_6Z__) \
159     || defined(__ARM_ARCH_6ZK__) \
160     || defined(__ARM_ARCH_6T2__) \
161     || defined(__ARMV6__)
162 #define WTF_ARM_ARCH_VERSION 6
163 
164 #elif defined(__ARM_ARCH_7A__) \
165     || defined(__ARM_ARCH_7K__) \
166     || defined(__ARM_ARCH_7R__) \
167     || defined(__ARM_ARCH_7S__)
168 #define WTF_ARM_ARCH_VERSION 7
169 
170 #elif defined(__ARM_ARCH_8__) \
171     || defined(__ARM_ARCH_8A__)
172 #define WTF_ARM_ARCH_VERSION 8
173 
174 /* MSVC sets _M_ARM */
175 #elif defined(_M_ARM)
176 #define WTF_ARM_ARCH_VERSION _M_ARM
177 
178 /* RVCT sets _TARGET_ARCH_ARM */
179 #elif defined(__TARGET_ARCH_ARM)
180 #define WTF_ARM_ARCH_VERSION __TARGET_ARCH_ARM
181 
182 #else
183 #define WTF_ARM_ARCH_VERSION 0
184 
185 #endif
186 
187 /* FIXME: WTF_THUMB_ARCH_VERSION seems unused. Remove. */
188 /* Set WTF_THUMB_ARCH_VERSION */
189 #if   defined(__ARM_ARCH_4T__)
190 #define WTF_THUMB_ARCH_VERSION 1
191 
192 #elif defined(__ARM_ARCH_5T__) \
193     || defined(__ARM_ARCH_5TE__) \
194     || defined(__ARM_ARCH_5TEJ__)
195 #define WTF_THUMB_ARCH_VERSION 2
196 
197 #elif defined(__ARM_ARCH_6J__) \
198     || defined(__ARM_ARCH_6K__) \
199     || defined(__ARM_ARCH_6Z__) \
200     || defined(__ARM_ARCH_6ZK__) \
201     || defined(__ARM_ARCH_6M__)
202 #define WTF_THUMB_ARCH_VERSION 3
203 
204 #elif defined(__ARM_ARCH_6T2__) \
205     || defined(__ARM_ARCH_7__) \
206     || defined(__ARM_ARCH_7A__) \
207     || defined(__ARM_ARCH_7K__) \
208     || defined(__ARM_ARCH_7M__) \
209     || defined(__ARM_ARCH_7R__) \
210     || defined(__ARM_ARCH_7S__)
211 #define WTF_THUMB_ARCH_VERSION 4
212 
213 /* RVCT sets __TARGET_ARCH_THUMB */
214 #elif defined(__TARGET_ARCH_THUMB)
215 #define WTF_THUMB_ARCH_VERSION __TARGET_ARCH_THUMB
216 
217 #else
218 #define WTF_THUMB_ARCH_VERSION 0
219 #endif
220 
221 
222 /* FIXME: CPU(ARMV5_OR_LOWER) seems unused. Remove. */
223 /* CPU(ARMV5_OR_LOWER) - ARM instruction set v5 or earlier */
224 /* On ARMv5 and below the natural alignment is required.
225    And there are some other differences for v5 or earlier. */
226 #if !defined(ARMV5_OR_LOWER) &amp;&amp; !WTF_ARM_ARCH_AT_LEAST(6)
227 #define WTF_CPU_ARMV5_OR_LOWER 1
228 #endif
229 
230 
231 /* CPU(ARM_TRADITIONAL) - Thumb2 is not available, only traditional ARM (v4 or greater) */
232 /* CPU(ARM_THUMB2) - Thumb2 instruction set is available */
233 /* Only one of these will be defined. */
234 #if !defined(WTF_CPU_ARM_TRADITIONAL) &amp;&amp; !defined(WTF_CPU_ARM_THUMB2)
235 #  if defined(thumb2) || defined(__thumb2__) \
236     || ((defined(__thumb) || defined(__thumb__)) &amp;&amp; WTF_THUMB_ARCH_VERSION == 4)
237 #    define WTF_CPU_ARM_TRADITIONAL 0
238 #    define WTF_CPU_ARM_THUMB2 1
239 #  elif WTF_ARM_ARCH_AT_LEAST(4)
240 #    define WTF_CPU_ARM_TRADITIONAL 1
241 #    define WTF_CPU_ARM_THUMB2 0
242 #  else
243 #    error &quot;Not supported ARM architecture&quot;
244 #  endif
245 #elif CPU(ARM_TRADITIONAL) &amp;&amp; CPU(ARM_THUMB2) /* Sanity Check */
246 #  error &quot;Cannot use both of WTF_CPU_ARM_TRADITIONAL and WTF_CPU_ARM_THUMB2 platforms&quot;
247 #endif /* !defined(WTF_CPU_ARM_TRADITIONAL) &amp;&amp; !defined(WTF_CPU_ARM_THUMB2) */
248 
249 #if defined(__ARM_NEON__) &amp;&amp; !defined(WTF_CPU_ARM_NEON)
250 #define WTF_CPU_ARM_NEON 1
251 #endif
252 
253 #if (defined(__VFP_FP__) &amp;&amp; !defined(__SOFTFP__))
254 #define WTF_CPU_ARM_VFP 1
255 #endif
256 
257 /* If CPU(ARM_NEON) is not enabled, we&#39;ll conservatively assume only VFP2 or VFPv3D16
258    support is available. Hence, only the first 16 64-bit floating point registers
259    are available. See:
260    NEON registers: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0473c/CJACABEJ.html
261    VFP2 and VFP3 registers: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0473c/CIHDIBDG.html
262    NEON to VFP register mapping: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0473c/CJAIJHFC.html
263 */
264 #if CPU(ARM_NEON)
265 #define WTF_CPU_ARM_VFP_V3_D32 1
266 #else
267 #define WTF_CPU_ARM_VFP_V2 1
268 #endif
269 
270 #if defined(__ARM_ARCH_7K__)
271 #define WTF_CPU_APPLE_ARMV7K 1
272 #endif
273 
274 #if defined(__ARM_ARCH_7S__)
275 #define WTF_CPU_APPLE_ARMV7S 1
276 #endif
277 
278 #endif /* ARM */
279 
280 #if !CPU(KNOWN)
281 #define WTF_CPU_UNKNOWN 1
282 #endif
283 
284 #if CPU(ARM) || CPU(MIPS) || CPU(UNKNOWN)
285 #define WTF_CPU_NEEDS_ALIGNED_ACCESS 1
286 #endif
287 
288 #if COMPILER(GCC_COMPATIBLE)
289 /* __LP64__ is not defined on 64bit Windows since it uses LLP64. Using __SIZEOF_POINTER__ is simpler. */
290 #if __SIZEOF_POINTER__ == 8
291 #define WTF_CPU_ADDRESS64 1
292 #elif __SIZEOF_POINTER__ == 4
293 #define WTF_CPU_ADDRESS32 1
294 #else
295 #error &quot;Unsupported pointer width&quot;
296 #endif
297 #elif COMPILER(MSVC)
298 #if defined(_WIN64)
299 #define WTF_CPU_ADDRESS64 1
300 #else
301 #define WTF_CPU_ADDRESS32 1
302 #endif
303 #else
304 /* This is the most generic way. But in OS(DARWIN), Platform.h can be included by sandbox definition file (.sb).
305  * At that time, we cannot include &quot;stdint.h&quot; header. So in the case of known compilers, we use predefined constants instead. */
306 #include &lt;stdint.h&gt;
307 #if UINTPTR_MAX &gt; UINT32_MAX
308 #define WTF_CPU_ADDRESS64 1
309 #else
310 #define WTF_CPU_ADDRESS32 1
311 #endif
312 #endif
313 
314 /* CPU(BIG_ENDIAN) or CPU(MIDDLE_ENDIAN) or neither, as appropriate. */
315 
316 #if COMPILER(GCC_COMPATIBLE)
317 #if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
318 #define WTF_CPU_BIG_ENDIAN 1
319 #elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
320 #define WTF_CPU_LITTLE_ENDIAN 1
321 #elif __BYTE_ORDER__ == __ORDER_PDP_ENDIAN__
322 #define WTF_CPU_MIDDLE_ENDIAN 1
323 #else
324 #error &quot;Unknown endian&quot;
325 #endif
326 #else
327 #if defined(WIN32) || defined(_WIN32)
328 /* Windows only have little endian architecture. */
329 #define WTF_CPU_LITTLE_ENDIAN 1
330 #else
331 #include &lt;sys/types.h&gt;
332 #if __has_include(&lt;endian.h&gt;)
333 #include &lt;endian.h&gt;
334 #if __BYTE_ORDER == __BIG_ENDIAN
335 #define WTF_CPU_BIG_ENDIAN 1
336 #elif __BYTE_ORDER == __LITTLE_ENDIAN
337 #define WTF_CPU_LITTLE_ENDIAN 1
338 #elif __BYTE_ORDER == __PDP_ENDIAN
339 #define WTF_CPU_MIDDLE_ENDIAN 1
340 #else
341 #error &quot;Unknown endian&quot;
342 #endif
343 #else
344 #if __has_include(&lt;machine/endian.h&gt;)
345 #include &lt;machine/endian.h&gt;
346 #else
347 #include &lt;sys/endian.h&gt;
348 #endif
349 #if BYTE_ORDER == BIG_ENDIAN
350 #define WTF_CPU_BIG_ENDIAN 1
351 #elif BYTE_ORDER == LITTLE_ENDIAN
352 #define WTF_CPU_LITTLE_ENDIAN 1
353 #elif BYTE_ORDER == PDP_ENDIAN
354 #define WTF_CPU_MIDDLE_ENDIAN 1
355 #else
356 #error &quot;Unknown endian&quot;
357 #endif
358 #endif
359 #endif
360 #endif
361 
362 #if !CPU(LITTLE_ENDIAN) &amp;&amp; !CPU(BIG_ENDIAN)
363 #error &quot;Unsupported endian&quot;
364 #endif
    </pre>
  </body>
</html>
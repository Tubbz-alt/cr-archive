<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FloatPolygon.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2012 Adobe Systems Incorporated. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1. Redistributions of source code must retain the above
  9  *    copyright notice, this list of conditions and the following
 10  *    disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above
 12  *    copyright notice, this list of conditions and the following
 13  *    disclaimer in the documentation and/or other materials
 14  *    provided with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 17  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 18  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 19  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 20  * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 21  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 23  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 24  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 25  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 26  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 27  * OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;FloatPolygon.h&quot;
 32 
 33 #include &lt;wtf/HexNumber.h&gt;
 34 #include &lt;wtf/MathExtras.h&gt;
 35 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 namespace FloatPolygonInternal {
 40 static inline float determinant(const FloatSize&amp; a, const FloatSize&amp; b)
 41 {
 42     return a.width() * b.height() - a.height() * b.width();
 43 }
 44 }
 45 
 46 static inline bool areCollinearPoints(const FloatPoint&amp; p0, const FloatPoint&amp; p1, const FloatPoint&amp; p2)
 47 {
 48     return !FloatPolygonInternal::determinant(p1 - p0, p2 - p0);
 49 }
 50 
 51 static inline bool areCoincidentPoints(const FloatPoint&amp; p0, const FloatPoint&amp; p1)
 52 {
 53     return p0.x() == p1.x() &amp;&amp; p0.y() == p1.y();
 54 }
 55 
 56 static inline bool isPointOnLineSegment(const FloatPoint&amp; vertex1, const FloatPoint&amp; vertex2, const FloatPoint&amp; point)
 57 {
 58     return point.x() &gt;= std::min(vertex1.x(), vertex2.x())
 59         &amp;&amp; point.x() &lt;= std::max(vertex1.x(), vertex2.x())
 60         &amp;&amp; areCollinearPoints(vertex1, vertex2, point);
 61 }
 62 
 63 static inline unsigned nextVertexIndex(unsigned vertexIndex, unsigned nVertices, bool clockwise)
 64 {
 65     return ((clockwise) ? vertexIndex + 1 : vertexIndex - 1 + nVertices) % nVertices;
 66 }
 67 
 68 static unsigned findNextEdgeVertexIndex(const FloatPolygon&amp; polygon, unsigned vertexIndex1, bool clockwise)
 69 {
 70     unsigned nVertices = polygon.numberOfVertices();
 71     unsigned vertexIndex2 = nextVertexIndex(vertexIndex1, nVertices, clockwise);
 72 
 73     while (vertexIndex2 &amp;&amp; areCoincidentPoints(polygon.vertexAt(vertexIndex1), polygon.vertexAt(vertexIndex2)))
 74         vertexIndex2 = nextVertexIndex(vertexIndex2, nVertices, clockwise);
 75 
 76     while (vertexIndex2) {
 77         unsigned vertexIndex3 = nextVertexIndex(vertexIndex2, nVertices, clockwise);
 78         if (!areCollinearPoints(polygon.vertexAt(vertexIndex1), polygon.vertexAt(vertexIndex2), polygon.vertexAt(vertexIndex3)))
 79             break;
 80         vertexIndex2 = vertexIndex3;
 81     }
 82 
 83     return vertexIndex2;
 84 }
 85 
 86 FloatPolygon::FloatPolygon(std::unique_ptr&lt;Vector&lt;FloatPoint&gt;&gt; vertices, WindRule fillRule)
 87     : m_vertices(WTFMove(vertices))
 88     , m_fillRule(fillRule)
 89 {
 90     unsigned nVertices = numberOfVertices();
 91     m_edges.resize(nVertices);
 92     m_empty = nVertices &lt; 3;
 93 
 94     if (nVertices)
 95         m_boundingBox.setLocation(vertexAt(0));
 96 
 97     if (m_empty)
 98         return;
 99 
100     unsigned minVertexIndex = 0;
101     for (unsigned i = 1; i &lt; nVertices; ++i) {
102         const FloatPoint&amp; vertex = vertexAt(i);
103         if (vertex.y() &lt; vertexAt(minVertexIndex).y() || (vertex.y() == vertexAt(minVertexIndex).y() &amp;&amp; vertex.x() &lt; vertexAt(minVertexIndex).x()))
104             minVertexIndex = i;
105     }
106     FloatPoint nextVertex = vertexAt((minVertexIndex + 1) % nVertices);
107     FloatPoint prevVertex = vertexAt((minVertexIndex + nVertices - 1) % nVertices);
108     bool clockwise = FloatPolygonInternal::determinant(vertexAt(minVertexIndex) - prevVertex, nextVertex - prevVertex) &gt; 0;
109 
110     unsigned edgeIndex = 0;
111     unsigned vertexIndex1 = 0;
112     do {
113         m_boundingBox.extend(vertexAt(vertexIndex1));
114         unsigned vertexIndex2 = findNextEdgeVertexIndex(*this, vertexIndex1, clockwise);
115         m_edges[edgeIndex].m_polygon = this;
116         m_edges[edgeIndex].m_vertexIndex1 = vertexIndex1;
117         m_edges[edgeIndex].m_vertexIndex2 = vertexIndex2;
118         m_edges[edgeIndex].m_edgeIndex = edgeIndex;
119         ++edgeIndex;
120         vertexIndex1 = vertexIndex2;
121     } while (vertexIndex1);
122 
123     if (edgeIndex &gt; 3) {
124         const FloatPolygonEdge&amp; firstEdge = m_edges[0];
125         const FloatPolygonEdge&amp; lastEdge = m_edges[edgeIndex - 1];
126         if (areCollinearPoints(lastEdge.vertex1(), lastEdge.vertex2(), firstEdge.vertex2())) {
127             m_edges[0].m_vertexIndex1 = lastEdge.m_vertexIndex1;
128             edgeIndex--;
129         }
130     }
131 
132     m_edges.resize(edgeIndex);
133     m_empty = m_edges.size() &lt; 3;
134 
135     if (m_empty)
136         return;
137 
<a name="1" id="anc1"></a><span class="line-modified">138     for (auto&amp; edge : m_edges)</span>
<span class="line-modified">139         m_edgeTree.add({ edge.minY(), edge.maxY(), &amp;edge });</span>


140 }
141 
<a name="2" id="anc2"></a><span class="line-modified">142 Vector&lt;std::reference_wrapper&lt;const FloatPolygonEdge&gt;&gt; FloatPolygon::overlappingEdges(float minY, float maxY) const</span>
143 {
<a name="3" id="anc3"></a><span class="line-modified">144     auto overlappingEdgeIntervals = m_edgeTree.allOverlaps({ minY, maxY });</span>
<span class="line-modified">145     Vector&lt;std::reference_wrapper&lt;const FloatPolygonEdge&gt;&gt; result;</span>
<span class="line-modified">146     result.reserveInitialCapacity(overlappingEdgeIntervals.size());</span>
<span class="line-modified">147     for (auto&amp; interval : overlappingEdgeIntervals)</span>
<span class="line-modified">148         result.uncheckedAppend(*interval.data());</span>
<span class="line-modified">149     return result;</span>




150 }
151 
152 static inline float leftSide(const FloatPoint&amp; vertex1, const FloatPoint&amp; vertex2, const FloatPoint&amp; point)
153 {
154     return ((point.x() - vertex1.x()) * (vertex2.y() - vertex1.y())) - ((vertex2.x() - vertex1.x()) * (point.y() - vertex1.y()));
155 }
156 
157 bool FloatPolygon::containsEvenOdd(const FloatPoint&amp; point) const
158 {
159     unsigned crossingCount = 0;
160     for (unsigned i = 0; i &lt; numberOfEdges(); ++i) {
161         const FloatPoint&amp; vertex1 = edgeAt(i).vertex1();
162         const FloatPoint&amp; vertex2 = edgeAt(i).vertex2();
163         if (isPointOnLineSegment(vertex1, vertex2, point))
164             return true;
165         if ((vertex1.y() &lt;= point.y() &amp;&amp; vertex2.y() &gt; point.y()) || (vertex1.y() &gt; point.y() &amp;&amp; vertex2.y() &lt;= point.y())) {
166             float vt = (point.y()  - vertex1.y()) / (vertex2.y() - vertex1.y());
167             if (point.x() &lt; vertex1.x() + vt * (vertex2.x() - vertex1.x()))
168                 ++crossingCount;
169         }
170     }
171     return crossingCount &amp; 1;
172 }
173 
174 bool FloatPolygon::containsNonZero(const FloatPoint&amp; point) const
175 {
176     int windingNumber = 0;
177     for (unsigned i = 0; i &lt; numberOfEdges(); ++i) {
178         const FloatPoint&amp; vertex1 = edgeAt(i).vertex1();
179         const FloatPoint&amp; vertex2 = edgeAt(i).vertex2();
180         if (isPointOnLineSegment(vertex1, vertex2, point))
181             return true;
182         if (vertex2.y() &lt; point.y()) {
183             if ((vertex1.y() &gt; point.y()) &amp;&amp; (leftSide(vertex1, vertex2, point) &gt; 0))
184                 ++windingNumber;
185         } else if (vertex2.y() &gt; point.y()) {
186             if ((vertex1.y() &lt;= point.y()) &amp;&amp; (leftSide(vertex1, vertex2, point) &lt; 0))
187                 --windingNumber;
188         }
189     }
190     return windingNumber;
191 }
192 
193 bool FloatPolygon::contains(const FloatPoint&amp; point) const
194 {
195     if (!m_boundingBox.contains(point))
196         return false;
197     return fillRule() == WindRule::NonZero ? containsNonZero(point) : containsEvenOdd(point);
198 }
199 
200 bool VertexPair::overlapsRect(const FloatRect&amp; rect) const
201 {
202     bool boundsOverlap = (minX() &lt; rect.maxX()) &amp;&amp; (maxX() &gt; rect.x()) &amp;&amp; (minY() &lt; rect.maxY()) &amp;&amp; (maxY() &gt; rect.y());
203     if (!boundsOverlap)
204         return false;
205 
206     float leftSideValues[4] = {
207         leftSide(vertex1(), vertex2(), rect.minXMinYCorner()),
208         leftSide(vertex1(), vertex2(), rect.maxXMinYCorner()),
209         leftSide(vertex1(), vertex2(), rect.minXMaxYCorner()),
210         leftSide(vertex1(), vertex2(), rect.maxXMaxYCorner())
211     };
212 
213     int currentLeftSideSign = 0;
214     for (unsigned i = 0; i &lt; 4; ++i) {
215         if (!leftSideValues[i])
216             continue;
217         int leftSideSign = leftSideValues[i] &gt; 0 ? 1 : -1;
218         if (!currentLeftSideSign)
219             currentLeftSideSign = leftSideSign;
220         else if (currentLeftSideSign != leftSideSign)
221             return true;
222     }
223 
224     return false;
225 }
226 
227 bool VertexPair::intersection(const VertexPair&amp; other, FloatPoint&amp; point) const
228 {
229     // See: http://paulbourke.net/geometry/pointlineplane/, &quot;Intersection point of two lines in 2 dimensions&quot;
230 
231     const FloatSize&amp; thisDelta = vertex2() - vertex1();
232     const FloatSize&amp; otherDelta = other.vertex2() - other.vertex1();
233     float denominator = FloatPolygonInternal::determinant(thisDelta, otherDelta);
234     if (!denominator)
235         return false;
236 
237     // The two line segments: &quot;this&quot; vertex1,vertex2 and &quot;other&quot; vertex1,vertex2, have been defined
238     // in parametric form. Each point on the line segment is: vertex1 + u * (vertex2 - vertex1),
239     // when 0 &lt;= u &lt;= 1. We&#39;re computing the values of u for each line at their intersection point.
240 
241     const FloatSize&amp; vertex1Delta = vertex1() - other.vertex1();
242     float uThisLine = FloatPolygonInternal::determinant(otherDelta, vertex1Delta) / denominator;
243     float uOtherLine = FloatPolygonInternal::determinant(thisDelta, vertex1Delta) / denominator;
244 
245     if (uThisLine &lt; 0 || uOtherLine &lt; 0 || uThisLine &gt; 1 || uOtherLine &gt; 1)
246         return false;
247 
248     point = vertex1() + uThisLine * thisDelta;
249     return true;
250 }
251 
252 #ifndef NDEBUG
253 
<a name="4" id="anc4"></a><span class="line-modified">254 TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, const FloatPolygonEdge&amp; edge)</span>
255 {
<a name="5" id="anc5"></a><span class="line-modified">256     return stream &lt;&lt; &amp;edge &lt;&lt; &quot; (&quot; &lt;&lt; edge.vertex1().x() &lt;&lt; &#39;,&#39; &lt;&lt; edge.vertex1().y() &lt;&lt; &#39; &#39; &lt;&lt; edge.vertex2().x() &lt;&lt; &#39;,&#39; &lt;&lt; edge.vertex2().y() &lt;&lt; &#39;)&#39;;</span>
257 }
258 
259 #endif
260 
261 } // namespace WebCore
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
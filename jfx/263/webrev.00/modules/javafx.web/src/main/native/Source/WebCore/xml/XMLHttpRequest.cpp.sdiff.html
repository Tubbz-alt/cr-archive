<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/xml/XMLHttpRequest.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NativeXPathNSResolver.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="XMLHttpRequest.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/xml/XMLHttpRequest.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  16  *  Lesser General Public License for more details.
  17  *
  18  *  You should have received a copy of the GNU Lesser General Public
  19  *  License along with this library; if not, write to the Free Software
  20  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;XMLHttpRequest.h&quot;
  25 
  26 #include &quot;Blob.h&quot;
  27 #include &quot;CachedResourceRequestInitiators.h&quot;
  28 #include &quot;ContentSecurityPolicy.h&quot;
  29 #include &quot;CrossOriginAccessControl.h&quot;
  30 #include &quot;DOMFormData.h&quot;
  31 #include &quot;DOMWindow.h&quot;
  32 #include &quot;Event.h&quot;
  33 #include &quot;EventNames.h&quot;
  34 #include &quot;File.h&quot;
  35 #include &quot;HTMLDocument.h&quot;

  36 #include &quot;HTTPHeaderNames.h&quot;
  37 #include &quot;HTTPHeaderValues.h&quot;
  38 #include &quot;HTTPParsers.h&quot;
  39 #include &quot;InspectorInstrumentation.h&quot;
  40 #include &quot;JSDOMBinding.h&quot;
  41 #include &quot;JSDOMWindow.h&quot;
  42 #include &quot;MIMETypeRegistry.h&quot;
  43 #include &quot;MemoryCache.h&quot;
  44 #include &quot;ParsedContentType.h&quot;
  45 #include &quot;ResourceError.h&quot;
  46 #include &quot;ResourceRequest.h&quot;
  47 #include &quot;RuntimeApplicationChecks.h&quot;
  48 #include &quot;SecurityOriginPolicy.h&quot;
  49 #include &quot;Settings.h&quot;
  50 #include &quot;SharedBuffer.h&quot;
  51 #include &quot;StringAdaptors.h&quot;
  52 #include &quot;TextResourceDecoder.h&quot;
  53 #include &quot;ThreadableLoader.h&quot;
  54 #include &quot;XMLDocument.h&quot;
  55 #include &quot;XMLHttpRequestProgressEvent.h&quot;
</pre>
<hr />
<pre>
  99 }
 100 
 101 Ref&lt;XMLHttpRequest&gt; XMLHttpRequest::create(ScriptExecutionContext&amp; context)
 102 {
 103     auto xmlHttpRequest = adoptRef(*new XMLHttpRequest(context));
 104     xmlHttpRequest-&gt;suspendIfNeeded();
 105     return xmlHttpRequest;
 106 }
 107 
 108 XMLHttpRequest::XMLHttpRequest(ScriptExecutionContext&amp; context)
 109     : ActiveDOMObject(&amp;context)
 110     , m_async(true)
 111     , m_includeCredentials(false)
 112     , m_sendFlag(false)
 113     , m_createdDocument(false)
 114     , m_error(false)
 115     , m_uploadListenerFlag(false)
 116     , m_uploadComplete(false)
 117     , m_wasAbortedByClient(false)
 118     , m_responseCacheIsValid(false)
<span class="line-removed"> 119     , m_dispatchErrorOnResuming(false)</span>
 120     , m_readyState(static_cast&lt;unsigned&gt;(UNSENT))
 121     , m_responseType(static_cast&lt;unsigned&gt;(ResponseType::EmptyString))
<span class="line-modified"> 122     , m_progressEventThrottle(this)</span>
<span class="line-removed"> 123     , m_resumeTimer(*this, &amp;XMLHttpRequest::resumeTimerFired)</span>
 124     , m_networkErrorTimer(*this, &amp;XMLHttpRequest::networkErrorTimerFired)
 125     , m_timeoutTimer(*this, &amp;XMLHttpRequest::didReachTimeout)
 126     , m_maximumIntervalForUserGestureForwarding(maximumIntervalForUserGestureForwarding)
 127 {
 128 #ifndef NDEBUG
 129     xmlHttpRequestCounter.increment();
 130 #endif
 131 }
 132 
 133 XMLHttpRequest::~XMLHttpRequest()
 134 {
 135 #ifndef NDEBUG
 136     xmlHttpRequestCounter.decrement();
 137 #endif
 138 }
 139 
 140 Document* XMLHttpRequest::document() const
 141 {
 142     ASSERT(scriptExecutionContext());
 143     return downcast&lt;Document&gt;(scriptExecutionContext());
</pre>
<hr />
<pre>
 156 }
 157 
 158 void XMLHttpRequest::didCacheResponse()
 159 {
 160     ASSERT(doneWithoutErrors());
 161     m_responseCacheIsValid = true;
 162     m_responseBuilder.clear();
 163 }
 164 
 165 ExceptionOr&lt;Document*&gt; XMLHttpRequest::responseXML()
 166 {
 167     ASSERT(scriptExecutionContext()-&gt;isDocument());
 168 
 169     if (responseType() != ResponseType::EmptyString &amp;&amp; responseType() != ResponseType::Document)
 170         return Exception { InvalidStateError };
 171 
 172     if (!doneWithoutErrors())
 173         return nullptr;
 174 
 175     if (!m_createdDocument) {
<span class="line-modified"> 176         auto&amp; context = *scriptExecutionContext();</span>
 177 
 178         String mimeType = responseMIMEType();
 179         bool isHTML = equalLettersIgnoringASCIICase(mimeType, &quot;text/html&quot;);
 180 
 181         // The W3C spec requires the final MIME type to be some valid XML type, or text/html.
 182         // If it is text/html, then the responseType of &quot;document&quot; must have been supplied explicitly.
 183         if ((m_response.isHTTP() &amp;&amp; !responseIsXML() &amp;&amp; !isHTML)
 184             || (isHTML &amp;&amp; responseType() == ResponseType::EmptyString)) {
 185             m_responseDocument = nullptr;
 186         } else {
 187             if (isHTML)
<span class="line-modified"> 188                 m_responseDocument = HTMLDocument::create(context.sessionID(), nullptr, m_url);</span>
 189             else
<span class="line-modified"> 190                 m_responseDocument = XMLDocument::create(context.sessionID(), nullptr, m_url);</span>
 191             m_responseDocument-&gt;overrideLastModified(m_response.lastModified());
 192             m_responseDocument-&gt;setContent(m_responseBuilder.toStringPreserveCapacity());
<span class="line-modified"> 193             m_responseDocument-&gt;setContextDocument(downcast&lt;Document&gt;(context));</span>
 194             m_responseDocument-&gt;setSecurityOriginPolicy(context.securityOriginPolicy());
 195             m_responseDocument-&gt;overrideMIMEType(mimeType);
 196 
 197             if (!m_responseDocument-&gt;wellFormed())
 198                 m_responseDocument = nullptr;
 199         }
 200         m_createdDocument = true;
 201     }
 202 
 203     return m_responseDocument.get();
 204 }
 205 
 206 Ref&lt;Blob&gt; XMLHttpRequest::createResponseBlob()
 207 {
 208     ASSERT(responseType() == ResponseType::Blob);
 209     ASSERT(doneWithoutErrors());
 210 
 211     // FIXME: We just received the data from NetworkProcess, and are sending it back. This is inefficient.
 212     Vector&lt;uint8_t&gt; data;
 213     if (m_binaryResponseBuilder)
 214         data.append(m_binaryResponseBuilder-&gt;data(), m_binaryResponseBuilder-&gt;size());
 215     m_binaryResponseBuilder = nullptr;
 216     String normalizedContentType = Blob::normalizedContentType(responseMIMEType()); // responseMIMEType defaults to text/xml which may be incorrect.
<span class="line-modified"> 217     return Blob::create(scriptExecutionContext()-&gt;sessionID(), WTFMove(data), normalizedContentType);</span>
 218 }
 219 
 220 RefPtr&lt;ArrayBuffer&gt; XMLHttpRequest::createResponseArrayBuffer()
 221 {
 222     ASSERT(responseType() == ResponseType::Arraybuffer);
 223     ASSERT(doneWithoutErrors());
 224 
 225     auto result = m_binaryResponseBuilder ? m_binaryResponseBuilder-&gt;tryCreateArrayBuffer() : ArrayBuffer::create(nullptr, 0);
 226     m_binaryResponseBuilder = nullptr;
 227     return result;
 228 }
 229 
 230 ExceptionOr&lt;void&gt; XMLHttpRequest::setTimeout(unsigned timeout)
 231 {
 232     if (scriptExecutionContext()-&gt;isDocument() &amp;&amp; !m_async) {
 233         logConsoleError(scriptExecutionContext(), &quot;XMLHttpRequest.timeout cannot be set for synchronous HTTP(S) requests made from the window context.&quot;);
 234         return Exception { InvalidAccessError };
 235     }
 236     m_timeoutMilliseconds = timeout;
 237     if (!m_timeoutTimer.isActive())
</pre>
<hr />
<pre>
 319     }
 320 }
 321 
 322 ExceptionOr&lt;void&gt; XMLHttpRequest::setWithCredentials(bool value)
 323 {
 324     if (readyState() &gt; OPENED || m_sendFlag)
 325         return Exception { InvalidStateError };
 326 
 327     m_includeCredentials = value;
 328     return { };
 329 }
 330 
 331 ExceptionOr&lt;void&gt; XMLHttpRequest::open(const String&amp; method, const String&amp; url)
 332 {
 333     // If the async argument is omitted, set async to true.
 334     return open(method, scriptExecutionContext()-&gt;completeURL(url), true);
 335 }
 336 
 337 ExceptionOr&lt;void&gt; XMLHttpRequest::open(const String&amp; method, const URL&amp; url, bool async)
 338 {





 339     if (!isValidHTTPToken(method))
 340         return Exception { SyntaxError };
 341 
 342     if (isForbiddenMethod(method))
 343         return Exception { SecurityError };
 344 
 345     if (!url.isValid())
 346         return Exception { SyntaxError };
 347 
<span class="line-modified"> 348     if (!async &amp;&amp; scriptExecutionContext()-&gt;isDocument()) {</span>
 349         // Newer functionality is not available to synchronous requests in window contexts, as a spec-mandated
 350         // attempt to discourage synchronous XHR use. responseType is one such piece of functionality.
 351         // We&#39;ll only disable this functionality for HTTP(S) requests since sync requests for local protocols
 352         // such as file: and data: still make sense to allow.
 353         if (url.protocolIsInHTTPFamily() &amp;&amp; responseType() != ResponseType::EmptyString) {
<span class="line-modified"> 354             logConsoleError(scriptExecutionContext(), &quot;Synchronous HTTP(S) requests made from the window context cannot have XMLHttpRequest.responseType set.&quot;);</span>
 355             return Exception { InvalidAccessError };
 356         }
 357 
 358         // Similarly, timeouts are disabled for synchronous requests as well.
 359         if (m_timeoutMilliseconds &gt; 0) {
<span class="line-modified"> 360             logConsoleError(scriptExecutionContext(), &quot;Synchronous XMLHttpRequests must not have a timeout value set.&quot;);</span>
 361             return Exception { InvalidAccessError };
 362         }
 363     }
 364 
 365     if (!internalAbort())
 366         return { };
 367 
 368     m_sendFlag = false;
 369     m_uploadListenerFlag = false;
 370     m_method = normalizeHTTPMethod(method);
 371     m_error = false;
 372     m_uploadComplete = false;
 373     m_wasAbortedByClient = false;
 374 
 375     // clear stuff from possible previous load
 376     clearResponse();
 377     clearRequest();
 378 
 379     m_url = url;
<span class="line-modified"> 380     scriptExecutionContext()-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(m_url, ContentSecurityPolicy::InsecureRequestType::Load);</span>
 381 
 382     m_async = async;
 383 
 384     ASSERT(!m_loader);
 385 
 386     changeState(OPENED);
 387 
 388     return { };
 389 }
 390 
 391 ExceptionOr&lt;void&gt; XMLHttpRequest::open(const String&amp; method, const String&amp; url, bool async, const String&amp; user, const String&amp; password)
 392 {
 393     URL urlWithCredentials = scriptExecutionContext()-&gt;completeURL(url);
 394     if (!user.isNull())
 395         urlWithCredentials.setUser(user);
 396     if (!password.isNull())
 397         urlWithCredentials.setPass(password);
 398 
 399     return open(method, urlWithCredentials, async);
 400 }
 401 
 402 Optional&lt;ExceptionOr&lt;void&gt;&gt; XMLHttpRequest::prepareToSend()
 403 {
 404     // A return value other than WTF::nullopt means we should not try to send, and we should return that value to the caller.
 405     // WTF::nullopt means we are ready to send and should continue with the send algorithm.
 406 
 407     if (!scriptExecutionContext())
 408         return ExceptionOr&lt;void&gt; { };
 409 
 410     auto&amp; context = *scriptExecutionContext();
 411 





 412     if (readyState() != OPENED || m_sendFlag)
 413         return ExceptionOr&lt;void&gt; { Exception { InvalidStateError } };
 414     ASSERT(!m_loader);
 415 
 416     // FIXME: Convert this to check the isolated world&#39;s Content Security Policy once webkit.org/b/104520 is solved.
 417     if (!context.shouldBypassMainWorldContentSecurityPolicy() &amp;&amp; !context.contentSecurityPolicy()-&gt;allowConnectToSource(m_url)) {
 418         if (!m_async)
 419             return ExceptionOr&lt;void&gt; { Exception { NetworkError } };
 420         setPendingActivity(*this);
 421         m_timeoutTimer.stop();
 422         m_networkErrorTimer.startOneShot(0_s);
 423         return ExceptionOr&lt;void&gt; { };
 424     }
 425 
 426     m_error = false;
 427     return WTF::nullopt;
 428 }
 429 
 430 ExceptionOr&lt;void&gt; XMLHttpRequest::send(Optional&lt;SendTypes&gt;&amp;&amp; sendType)
 431 {
</pre>
<hr />
<pre>
 606     options.sniffContentEncoding = ContentEncodingSniffingPolicy::DoNotSniff;
 607 
 608     if (m_timeoutMilliseconds) {
 609         if (!m_async)
 610             request.setTimeoutInterval(m_timeoutMilliseconds / 1000.0);
 611         else {
 612             request.setTimeoutInterval(std::numeric_limits&lt;double&gt;::infinity());
 613             m_sendingTime = MonotonicTime::now();
 614             m_timeoutTimer.startOneShot(1_ms * m_timeoutMilliseconds);
 615         }
 616     }
 617 
 618     m_exceptionCode = WTF::nullopt;
 619     m_error = false;
 620     m_uploadComplete = !request.httpBody();
 621     m_sendFlag = true;
 622 
 623     if (m_async) {
 624         m_progressEventThrottle.dispatchProgressEvent(eventNames().loadstartEvent);
 625         if (!m_uploadComplete &amp;&amp; m_uploadListenerFlag)
<span class="line-modified"> 626             m_upload-&gt;dispatchProgressEvent(eventNames().loadstartEvent, 0, request.httpBody()-&gt;lengthInBytes(scriptExecutionContext()-&gt;sessionID()));</span>
 627 
 628         if (readyState() != OPENED || !m_sendFlag || m_loader)
 629             return { };
 630 
 631         // ThreadableLoader::create can return null here, for example if we&#39;re no longer attached to a page or if a content blocker blocks the load.
 632         // This is true while running onunload handlers.
 633         // FIXME: Maybe we need to be able to send XMLHttpRequests from onunload, &lt;http://bugs.webkit.org/show_bug.cgi?id=10904&gt;.
 634         m_loader = ThreadableLoader::create(*scriptExecutionContext(), *this, WTFMove(request), options);
 635 
 636         // Either loader is null or some error was synchronously sent to us.
 637         ASSERT(m_loader || !m_sendFlag);
 638 
 639         // Neither this object nor the JavaScript wrapper should be deleted while
 640         // a request is in progress because we need to keep the listeners alive,
 641         // and they are referenced by the JavaScript wrapper.
 642         if (m_loader)
 643             setPendingActivity(*this);
 644     } else {



 645         request.setDomainForCachePartition(scriptExecutionContext()-&gt;domainForCachePartition());
 646         InspectorInstrumentation::willLoadXHRSynchronously(scriptExecutionContext());
 647         ThreadableLoader::loadResourceSynchronously(*scriptExecutionContext(), WTFMove(request), *this, options);
 648         InspectorInstrumentation::didLoadXHRSynchronously(scriptExecutionContext());
 649     }
 650 
 651     if (m_exceptionCode)
 652         return Exception { m_exceptionCode.value() };
 653     if (m_error)
 654         return Exception { NetworkError };
 655     return { };
 656 }
 657 
 658 void XMLHttpRequest::abort()
 659 {
 660     // internalAbort() calls unsetPendingActivity(this), which may release the last reference.
 661     Ref&lt;XMLHttpRequest&gt; protectedThis(*this);
 662 
 663     m_wasAbortedByClient = true;
 664     if (!internalAbort())
</pre>
<hr />
<pre>
1053         m_receivedLength += len;
1054 
1055         if (readyState() != LOADING)
1056             changeState(LOADING);
1057         else {
1058             // Firefox calls readyStateChanged every time it receives data, 4449442
1059             callReadyStateChangeListener();
1060         }
1061 
1062         if (m_async) {
1063             long long expectedLength = m_response.expectedContentLength();
1064             bool lengthComputable = expectedLength &gt; 0 &amp;&amp; m_receivedLength &lt;= expectedLength;
1065             unsigned long long total = lengthComputable ? expectedLength : 0;
1066             m_progressEventThrottle.dispatchThrottledProgressEvent(lengthComputable, m_receivedLength, total);
1067         }
1068     }
1069 }
1070 
1071 void XMLHttpRequest::dispatchEvent(Event&amp; event)
1072 {


1073     if (m_userGestureToken &amp;&amp; m_userGestureToken-&gt;hasExpired(m_maximumIntervalForUserGestureForwarding))
1074         m_userGestureToken = nullptr;
1075 
1076     if (readyState() != DONE || !m_userGestureToken || !m_userGestureToken-&gt;processingUserGesture()) {
1077         EventTarget::dispatchEvent(event);
1078         return;
1079     }
1080 
1081     UserGestureIndicator gestureIndicator(m_userGestureToken, UserGestureToken::GestureScope::MediaOnly);
1082     EventTarget::dispatchEvent(event);
1083 }
1084 
1085 void XMLHttpRequest::dispatchErrorEvents(const AtomString&amp; type)
1086 {
1087     if (!m_uploadComplete) {
1088         m_uploadComplete = true;
1089         if (m_upload &amp;&amp; m_uploadListenerFlag) {
1090             m_upload-&gt;dispatchProgressEvent(type, 0, 0);
1091             m_upload-&gt;dispatchProgressEvent(eventNames().loadendEvent, 0, 0);
1092         }
</pre>
<hr />
<pre>
1103         return;
1104 
1105     clearResponse();
1106     clearRequest();
1107 
1108     m_sendFlag = false;
1109     m_error = true;
1110     m_exceptionCode = TimeoutError;
1111 
1112     if (!m_async) {
1113         m_readyState = static_cast&lt;State&gt;(DONE);
1114         m_exceptionCode = TimeoutError;
1115         return;
1116     }
1117 
1118     changeState(DONE);
1119 
1120     dispatchErrorEvents(eventNames().timeoutEvent);
1121 }
1122 
<span class="line-removed">1123 bool XMLHttpRequest::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">1124 {</span>
<span class="line-removed">1125     // If the load event has not fired yet, cancelling the load in suspend() may cause</span>
<span class="line-removed">1126     // the load event to be fired and arbitrary JS execution, which would be unsafe.</span>
<span class="line-removed">1127     // Therefore, we prevent suspending in this case.</span>
<span class="line-removed">1128     return document()-&gt;loadEventFinished();</span>
<span class="line-removed">1129 }</span>
<span class="line-removed">1130 </span>
1131 const char* XMLHttpRequest::activeDOMObjectName() const
1132 {
1133     return &quot;XMLHttpRequest&quot;;
1134 }
1135 
<span class="line-modified">1136 void XMLHttpRequest::suspend(ReasonForSuspension reason)</span>
1137 {
1138     m_progressEventThrottle.suspend();
<span class="line-removed">1139 </span>
<span class="line-removed">1140     if (m_resumeTimer.isActive()) {</span>
<span class="line-removed">1141         m_resumeTimer.stop();</span>
<span class="line-removed">1142         m_dispatchErrorOnResuming = true;</span>
<span class="line-removed">1143     }</span>
<span class="line-removed">1144 </span>
<span class="line-removed">1145     if (reason == ReasonForSuspension::PageCache &amp;&amp; m_loader) {</span>
<span class="line-removed">1146         // Going into PageCache, abort the request and dispatch a network error on resuming.</span>
<span class="line-removed">1147         genericError();</span>
<span class="line-removed">1148         m_dispatchErrorOnResuming = true;</span>
<span class="line-removed">1149         bool aborted = internalAbort();</span>
<span class="line-removed">1150         // It should not be possible to restart the load when aborting in suspend() because</span>
<span class="line-removed">1151         // we are not allowed to execute in JS in suspend().</span>
<span class="line-removed">1152         ASSERT_UNUSED(aborted, aborted);</span>
<span class="line-removed">1153     }</span>
1154 }
1155 
1156 void XMLHttpRequest::resume()
1157 {
1158     m_progressEventThrottle.resume();
<span class="line-removed">1159 </span>
<span class="line-removed">1160     // We are not allowed to execute arbitrary JS in resume() so dispatch</span>
<span class="line-removed">1161     // the error event in a timer.</span>
<span class="line-removed">1162     if (m_dispatchErrorOnResuming &amp;&amp; !m_resumeTimer.isActive())</span>
<span class="line-removed">1163         m_resumeTimer.startOneShot(0_s);</span>
<span class="line-removed">1164 }</span>
<span class="line-removed">1165 </span>
<span class="line-removed">1166 void XMLHttpRequest::resumeTimerFired()</span>
<span class="line-removed">1167 {</span>
<span class="line-removed">1168     ASSERT(m_dispatchErrorOnResuming);</span>
<span class="line-removed">1169     m_dispatchErrorOnResuming = false;</span>
<span class="line-removed">1170     dispatchErrorEvents(eventNames().errorEvent);</span>
1171 }
1172 
1173 void XMLHttpRequest::stop()
1174 {
1175     internalAbort();
1176 }
1177 
1178 void XMLHttpRequest::contextDestroyed()
1179 {
1180     ASSERT(!m_loader);
1181     ActiveDOMObject::contextDestroyed();
1182 }
1183 
1184 void XMLHttpRequest::setMaximumIntervalForUserGestureForwarding(double interval)
1185 {
1186     m_maximumIntervalForUserGestureForwarding = Seconds(interval);
1187 }
1188 
1189 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  16  *  Lesser General Public License for more details.
  17  *
  18  *  You should have received a copy of the GNU Lesser General Public
  19  *  License along with this library; if not, write to the Free Software
  20  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;XMLHttpRequest.h&quot;
  25 
  26 #include &quot;Blob.h&quot;
  27 #include &quot;CachedResourceRequestInitiators.h&quot;
  28 #include &quot;ContentSecurityPolicy.h&quot;
  29 #include &quot;CrossOriginAccessControl.h&quot;
  30 #include &quot;DOMFormData.h&quot;
  31 #include &quot;DOMWindow.h&quot;
  32 #include &quot;Event.h&quot;
  33 #include &quot;EventNames.h&quot;
  34 #include &quot;File.h&quot;
  35 #include &quot;HTMLDocument.h&quot;
<span class="line-added">  36 #include &quot;HTMLIFrameElement.h&quot;</span>
  37 #include &quot;HTTPHeaderNames.h&quot;
  38 #include &quot;HTTPHeaderValues.h&quot;
  39 #include &quot;HTTPParsers.h&quot;
  40 #include &quot;InspectorInstrumentation.h&quot;
  41 #include &quot;JSDOMBinding.h&quot;
  42 #include &quot;JSDOMWindow.h&quot;
  43 #include &quot;MIMETypeRegistry.h&quot;
  44 #include &quot;MemoryCache.h&quot;
  45 #include &quot;ParsedContentType.h&quot;
  46 #include &quot;ResourceError.h&quot;
  47 #include &quot;ResourceRequest.h&quot;
  48 #include &quot;RuntimeApplicationChecks.h&quot;
  49 #include &quot;SecurityOriginPolicy.h&quot;
  50 #include &quot;Settings.h&quot;
  51 #include &quot;SharedBuffer.h&quot;
  52 #include &quot;StringAdaptors.h&quot;
  53 #include &quot;TextResourceDecoder.h&quot;
  54 #include &quot;ThreadableLoader.h&quot;
  55 #include &quot;XMLDocument.h&quot;
  56 #include &quot;XMLHttpRequestProgressEvent.h&quot;
</pre>
<hr />
<pre>
 100 }
 101 
 102 Ref&lt;XMLHttpRequest&gt; XMLHttpRequest::create(ScriptExecutionContext&amp; context)
 103 {
 104     auto xmlHttpRequest = adoptRef(*new XMLHttpRequest(context));
 105     xmlHttpRequest-&gt;suspendIfNeeded();
 106     return xmlHttpRequest;
 107 }
 108 
 109 XMLHttpRequest::XMLHttpRequest(ScriptExecutionContext&amp; context)
 110     : ActiveDOMObject(&amp;context)
 111     , m_async(true)
 112     , m_includeCredentials(false)
 113     , m_sendFlag(false)
 114     , m_createdDocument(false)
 115     , m_error(false)
 116     , m_uploadListenerFlag(false)
 117     , m_uploadComplete(false)
 118     , m_wasAbortedByClient(false)
 119     , m_responseCacheIsValid(false)

 120     , m_readyState(static_cast&lt;unsigned&gt;(UNSENT))
 121     , m_responseType(static_cast&lt;unsigned&gt;(ResponseType::EmptyString))
<span class="line-modified"> 122     , m_progressEventThrottle(*this)</span>

 123     , m_networkErrorTimer(*this, &amp;XMLHttpRequest::networkErrorTimerFired)
 124     , m_timeoutTimer(*this, &amp;XMLHttpRequest::didReachTimeout)
 125     , m_maximumIntervalForUserGestureForwarding(maximumIntervalForUserGestureForwarding)
 126 {
 127 #ifndef NDEBUG
 128     xmlHttpRequestCounter.increment();
 129 #endif
 130 }
 131 
 132 XMLHttpRequest::~XMLHttpRequest()
 133 {
 134 #ifndef NDEBUG
 135     xmlHttpRequestCounter.decrement();
 136 #endif
 137 }
 138 
 139 Document* XMLHttpRequest::document() const
 140 {
 141     ASSERT(scriptExecutionContext());
 142     return downcast&lt;Document&gt;(scriptExecutionContext());
</pre>
<hr />
<pre>
 155 }
 156 
 157 void XMLHttpRequest::didCacheResponse()
 158 {
 159     ASSERT(doneWithoutErrors());
 160     m_responseCacheIsValid = true;
 161     m_responseBuilder.clear();
 162 }
 163 
 164 ExceptionOr&lt;Document*&gt; XMLHttpRequest::responseXML()
 165 {
 166     ASSERT(scriptExecutionContext()-&gt;isDocument());
 167 
 168     if (responseType() != ResponseType::EmptyString &amp;&amp; responseType() != ResponseType::Document)
 169         return Exception { InvalidStateError };
 170 
 171     if (!doneWithoutErrors())
 172         return nullptr;
 173 
 174     if (!m_createdDocument) {
<span class="line-modified"> 175         auto&amp; context = downcast&lt;Document&gt;(*scriptExecutionContext());</span>
 176 
 177         String mimeType = responseMIMEType();
 178         bool isHTML = equalLettersIgnoringASCIICase(mimeType, &quot;text/html&quot;);
 179 
 180         // The W3C spec requires the final MIME type to be some valid XML type, or text/html.
 181         // If it is text/html, then the responseType of &quot;document&quot; must have been supplied explicitly.
 182         if ((m_response.isHTTP() &amp;&amp; !responseIsXML() &amp;&amp; !isHTML)
 183             || (isHTML &amp;&amp; responseType() == ResponseType::EmptyString)) {
 184             m_responseDocument = nullptr;
 185         } else {
 186             if (isHTML)
<span class="line-modified"> 187                 m_responseDocument = HTMLDocument::create(nullptr, m_response.url());</span>
 188             else
<span class="line-modified"> 189                 m_responseDocument = XMLDocument::create(nullptr, m_response.url());</span>
 190             m_responseDocument-&gt;overrideLastModified(m_response.lastModified());
 191             m_responseDocument-&gt;setContent(m_responseBuilder.toStringPreserveCapacity());
<span class="line-modified"> 192             m_responseDocument-&gt;setContextDocument(context);</span>
 193             m_responseDocument-&gt;setSecurityOriginPolicy(context.securityOriginPolicy());
 194             m_responseDocument-&gt;overrideMIMEType(mimeType);
 195 
 196             if (!m_responseDocument-&gt;wellFormed())
 197                 m_responseDocument = nullptr;
 198         }
 199         m_createdDocument = true;
 200     }
 201 
 202     return m_responseDocument.get();
 203 }
 204 
 205 Ref&lt;Blob&gt; XMLHttpRequest::createResponseBlob()
 206 {
 207     ASSERT(responseType() == ResponseType::Blob);
 208     ASSERT(doneWithoutErrors());
 209 
 210     // FIXME: We just received the data from NetworkProcess, and are sending it back. This is inefficient.
 211     Vector&lt;uint8_t&gt; data;
 212     if (m_binaryResponseBuilder)
 213         data.append(m_binaryResponseBuilder-&gt;data(), m_binaryResponseBuilder-&gt;size());
 214     m_binaryResponseBuilder = nullptr;
 215     String normalizedContentType = Blob::normalizedContentType(responseMIMEType()); // responseMIMEType defaults to text/xml which may be incorrect.
<span class="line-modified"> 216     return Blob::create(WTFMove(data), normalizedContentType);</span>
 217 }
 218 
 219 RefPtr&lt;ArrayBuffer&gt; XMLHttpRequest::createResponseArrayBuffer()
 220 {
 221     ASSERT(responseType() == ResponseType::Arraybuffer);
 222     ASSERT(doneWithoutErrors());
 223 
 224     auto result = m_binaryResponseBuilder ? m_binaryResponseBuilder-&gt;tryCreateArrayBuffer() : ArrayBuffer::create(nullptr, 0);
 225     m_binaryResponseBuilder = nullptr;
 226     return result;
 227 }
 228 
 229 ExceptionOr&lt;void&gt; XMLHttpRequest::setTimeout(unsigned timeout)
 230 {
 231     if (scriptExecutionContext()-&gt;isDocument() &amp;&amp; !m_async) {
 232         logConsoleError(scriptExecutionContext(), &quot;XMLHttpRequest.timeout cannot be set for synchronous HTTP(S) requests made from the window context.&quot;);
 233         return Exception { InvalidAccessError };
 234     }
 235     m_timeoutMilliseconds = timeout;
 236     if (!m_timeoutTimer.isActive())
</pre>
<hr />
<pre>
 318     }
 319 }
 320 
 321 ExceptionOr&lt;void&gt; XMLHttpRequest::setWithCredentials(bool value)
 322 {
 323     if (readyState() &gt; OPENED || m_sendFlag)
 324         return Exception { InvalidStateError };
 325 
 326     m_includeCredentials = value;
 327     return { };
 328 }
 329 
 330 ExceptionOr&lt;void&gt; XMLHttpRequest::open(const String&amp; method, const String&amp; url)
 331 {
 332     // If the async argument is omitted, set async to true.
 333     return open(method, scriptExecutionContext()-&gt;completeURL(url), true);
 334 }
 335 
 336 ExceptionOr&lt;void&gt; XMLHttpRequest::open(const String&amp; method, const URL&amp; url, bool async)
 337 {
<span class="line-added"> 338     auto* context = scriptExecutionContext();</span>
<span class="line-added"> 339     bool contextIsDocument = is&lt;Document&gt;(*context);</span>
<span class="line-added"> 340     if (contextIsDocument &amp;&amp; !downcast&lt;Document&gt;(*context).isFullyActive())</span>
<span class="line-added"> 341         return Exception { InvalidStateError, &quot;Document is not fully active&quot;_s };</span>
<span class="line-added"> 342 </span>
 343     if (!isValidHTTPToken(method))
 344         return Exception { SyntaxError };
 345 
 346     if (isForbiddenMethod(method))
 347         return Exception { SecurityError };
 348 
 349     if (!url.isValid())
 350         return Exception { SyntaxError };
 351 
<span class="line-modified"> 352     if (!async &amp;&amp; contextIsDocument) {</span>
 353         // Newer functionality is not available to synchronous requests in window contexts, as a spec-mandated
 354         // attempt to discourage synchronous XHR use. responseType is one such piece of functionality.
 355         // We&#39;ll only disable this functionality for HTTP(S) requests since sync requests for local protocols
 356         // such as file: and data: still make sense to allow.
 357         if (url.protocolIsInHTTPFamily() &amp;&amp; responseType() != ResponseType::EmptyString) {
<span class="line-modified"> 358             logConsoleError(context, &quot;Synchronous HTTP(S) requests made from the window context cannot have XMLHttpRequest.responseType set.&quot;);</span>
 359             return Exception { InvalidAccessError };
 360         }
 361 
 362         // Similarly, timeouts are disabled for synchronous requests as well.
 363         if (m_timeoutMilliseconds &gt; 0) {
<span class="line-modified"> 364             logConsoleError(context, &quot;Synchronous XMLHttpRequests must not have a timeout value set.&quot;);</span>
 365             return Exception { InvalidAccessError };
 366         }
 367     }
 368 
 369     if (!internalAbort())
 370         return { };
 371 
 372     m_sendFlag = false;
 373     m_uploadListenerFlag = false;
 374     m_method = normalizeHTTPMethod(method);
 375     m_error = false;
 376     m_uploadComplete = false;
 377     m_wasAbortedByClient = false;
 378 
 379     // clear stuff from possible previous load
 380     clearResponse();
 381     clearRequest();
 382 
 383     m_url = url;
<span class="line-modified"> 384     context-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(m_url, ContentSecurityPolicy::InsecureRequestType::Load);</span>
 385 
 386     m_async = async;
 387 
 388     ASSERT(!m_loader);
 389 
 390     changeState(OPENED);
 391 
 392     return { };
 393 }
 394 
 395 ExceptionOr&lt;void&gt; XMLHttpRequest::open(const String&amp; method, const String&amp; url, bool async, const String&amp; user, const String&amp; password)
 396 {
 397     URL urlWithCredentials = scriptExecutionContext()-&gt;completeURL(url);
 398     if (!user.isNull())
 399         urlWithCredentials.setUser(user);
 400     if (!password.isNull())
 401         urlWithCredentials.setPass(password);
 402 
 403     return open(method, urlWithCredentials, async);
 404 }
 405 
 406 Optional&lt;ExceptionOr&lt;void&gt;&gt; XMLHttpRequest::prepareToSend()
 407 {
 408     // A return value other than WTF::nullopt means we should not try to send, and we should return that value to the caller.
 409     // WTF::nullopt means we are ready to send and should continue with the send algorithm.
 410 
 411     if (!scriptExecutionContext())
 412         return ExceptionOr&lt;void&gt; { };
 413 
 414     auto&amp; context = *scriptExecutionContext();
 415 
<span class="line-added"> 416     if (is&lt;Document&gt;(context) &amp;&amp; downcast&lt;Document&gt;(context).shouldIgnoreSyncXHRs()) {</span>
<span class="line-added"> 417         logConsoleError(scriptExecutionContext(), makeString(&quot;Ignoring XMLHttpRequest.send() call for &#39;&quot;, m_url.string(), &quot;&#39; because the maximum number of synchronous failures was reached.&quot;));</span>
<span class="line-added"> 418         return ExceptionOr&lt;void&gt; { };</span>
<span class="line-added"> 419     }</span>
<span class="line-added"> 420 </span>
 421     if (readyState() != OPENED || m_sendFlag)
 422         return ExceptionOr&lt;void&gt; { Exception { InvalidStateError } };
 423     ASSERT(!m_loader);
 424 
 425     // FIXME: Convert this to check the isolated world&#39;s Content Security Policy once webkit.org/b/104520 is solved.
 426     if (!context.shouldBypassMainWorldContentSecurityPolicy() &amp;&amp; !context.contentSecurityPolicy()-&gt;allowConnectToSource(m_url)) {
 427         if (!m_async)
 428             return ExceptionOr&lt;void&gt; { Exception { NetworkError } };
 429         setPendingActivity(*this);
 430         m_timeoutTimer.stop();
 431         m_networkErrorTimer.startOneShot(0_s);
 432         return ExceptionOr&lt;void&gt; { };
 433     }
 434 
 435     m_error = false;
 436     return WTF::nullopt;
 437 }
 438 
 439 ExceptionOr&lt;void&gt; XMLHttpRequest::send(Optional&lt;SendTypes&gt;&amp;&amp; sendType)
 440 {
</pre>
<hr />
<pre>
 615     options.sniffContentEncoding = ContentEncodingSniffingPolicy::DoNotSniff;
 616 
 617     if (m_timeoutMilliseconds) {
 618         if (!m_async)
 619             request.setTimeoutInterval(m_timeoutMilliseconds / 1000.0);
 620         else {
 621             request.setTimeoutInterval(std::numeric_limits&lt;double&gt;::infinity());
 622             m_sendingTime = MonotonicTime::now();
 623             m_timeoutTimer.startOneShot(1_ms * m_timeoutMilliseconds);
 624         }
 625     }
 626 
 627     m_exceptionCode = WTF::nullopt;
 628     m_error = false;
 629     m_uploadComplete = !request.httpBody();
 630     m_sendFlag = true;
 631 
 632     if (m_async) {
 633         m_progressEventThrottle.dispatchProgressEvent(eventNames().loadstartEvent);
 634         if (!m_uploadComplete &amp;&amp; m_uploadListenerFlag)
<span class="line-modified"> 635             m_upload-&gt;dispatchProgressEvent(eventNames().loadstartEvent, 0, request.httpBody()-&gt;lengthInBytes());</span>
 636 
 637         if (readyState() != OPENED || !m_sendFlag || m_loader)
 638             return { };
 639 
 640         // ThreadableLoader::create can return null here, for example if we&#39;re no longer attached to a page or if a content blocker blocks the load.
 641         // This is true while running onunload handlers.
 642         // FIXME: Maybe we need to be able to send XMLHttpRequests from onunload, &lt;http://bugs.webkit.org/show_bug.cgi?id=10904&gt;.
 643         m_loader = ThreadableLoader::create(*scriptExecutionContext(), *this, WTFMove(request), options);
 644 
 645         // Either loader is null or some error was synchronously sent to us.
 646         ASSERT(m_loader || !m_sendFlag);
 647 
 648         // Neither this object nor the JavaScript wrapper should be deleted while
 649         // a request is in progress because we need to keep the listeners alive,
 650         // and they are referenced by the JavaScript wrapper.
 651         if (m_loader)
 652             setPendingActivity(*this);
 653     } else {
<span class="line-added"> 654         if (scriptExecutionContext()-&gt;isDocument() &amp;&amp; !isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::SyncXHR, *document()))</span>
<span class="line-added"> 655             return Exception { NetworkError };</span>
<span class="line-added"> 656 </span>
 657         request.setDomainForCachePartition(scriptExecutionContext()-&gt;domainForCachePartition());
 658         InspectorInstrumentation::willLoadXHRSynchronously(scriptExecutionContext());
 659         ThreadableLoader::loadResourceSynchronously(*scriptExecutionContext(), WTFMove(request), *this, options);
 660         InspectorInstrumentation::didLoadXHRSynchronously(scriptExecutionContext());
 661     }
 662 
 663     if (m_exceptionCode)
 664         return Exception { m_exceptionCode.value() };
 665     if (m_error)
 666         return Exception { NetworkError };
 667     return { };
 668 }
 669 
 670 void XMLHttpRequest::abort()
 671 {
 672     // internalAbort() calls unsetPendingActivity(this), which may release the last reference.
 673     Ref&lt;XMLHttpRequest&gt; protectedThis(*this);
 674 
 675     m_wasAbortedByClient = true;
 676     if (!internalAbort())
</pre>
<hr />
<pre>
1065         m_receivedLength += len;
1066 
1067         if (readyState() != LOADING)
1068             changeState(LOADING);
1069         else {
1070             // Firefox calls readyStateChanged every time it receives data, 4449442
1071             callReadyStateChangeListener();
1072         }
1073 
1074         if (m_async) {
1075             long long expectedLength = m_response.expectedContentLength();
1076             bool lengthComputable = expectedLength &gt; 0 &amp;&amp; m_receivedLength &lt;= expectedLength;
1077             unsigned long long total = lengthComputable ? expectedLength : 0;
1078             m_progressEventThrottle.dispatchThrottledProgressEvent(lengthComputable, m_receivedLength, total);
1079         }
1080     }
1081 }
1082 
1083 void XMLHttpRequest::dispatchEvent(Event&amp; event)
1084 {
<span class="line-added">1085     RELEASE_ASSERT(!scriptExecutionContext()-&gt;activeDOMObjectsAreSuspended());</span>
<span class="line-added">1086 </span>
1087     if (m_userGestureToken &amp;&amp; m_userGestureToken-&gt;hasExpired(m_maximumIntervalForUserGestureForwarding))
1088         m_userGestureToken = nullptr;
1089 
1090     if (readyState() != DONE || !m_userGestureToken || !m_userGestureToken-&gt;processingUserGesture()) {
1091         EventTarget::dispatchEvent(event);
1092         return;
1093     }
1094 
1095     UserGestureIndicator gestureIndicator(m_userGestureToken, UserGestureToken::GestureScope::MediaOnly);
1096     EventTarget::dispatchEvent(event);
1097 }
1098 
1099 void XMLHttpRequest::dispatchErrorEvents(const AtomString&amp; type)
1100 {
1101     if (!m_uploadComplete) {
1102         m_uploadComplete = true;
1103         if (m_upload &amp;&amp; m_uploadListenerFlag) {
1104             m_upload-&gt;dispatchProgressEvent(type, 0, 0);
1105             m_upload-&gt;dispatchProgressEvent(eventNames().loadendEvent, 0, 0);
1106         }
</pre>
<hr />
<pre>
1117         return;
1118 
1119     clearResponse();
1120     clearRequest();
1121 
1122     m_sendFlag = false;
1123     m_error = true;
1124     m_exceptionCode = TimeoutError;
1125 
1126     if (!m_async) {
1127         m_readyState = static_cast&lt;State&gt;(DONE);
1128         m_exceptionCode = TimeoutError;
1129         return;
1130     }
1131 
1132     changeState(DONE);
1133 
1134     dispatchErrorEvents(eventNames().timeoutEvent);
1135 }
1136 








1137 const char* XMLHttpRequest::activeDOMObjectName() const
1138 {
1139     return &quot;XMLHttpRequest&quot;;
1140 }
1141 
<span class="line-modified">1142 void XMLHttpRequest::suspend(ReasonForSuspension)</span>
1143 {
1144     m_progressEventThrottle.suspend();















1145 }
1146 
1147 void XMLHttpRequest::resume()
1148 {
1149     m_progressEventThrottle.resume();












1150 }
1151 
1152 void XMLHttpRequest::stop()
1153 {
1154     internalAbort();
1155 }
1156 
1157 void XMLHttpRequest::contextDestroyed()
1158 {
1159     ASSERT(!m_loader);
1160     ActiveDOMObject::contextDestroyed();
1161 }
1162 
1163 void XMLHttpRequest::setMaximumIntervalForUserGestureForwarding(double interval)
1164 {
1165     m_maximumIntervalForUserGestureForwarding = Seconds(interval);
1166 }
1167 
1168 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="NativeXPathNSResolver.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="XMLHttpRequest.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/StyleSheetContents.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StyleRuleImport.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleSheetContents.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/StyleSheetContents.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 35 #include &quot;PageConsoleClient.h&quot;
 36 #include &quot;ResourceLoadInfo.h&quot;
 37 #include &quot;RuleSet.h&quot;
 38 #include &quot;SecurityOrigin.h&quot;
 39 #include &quot;StyleRule.h&quot;
 40 #include &quot;StyleRuleImport.h&quot;
 41 #include &lt;wtf/Deque.h&gt;
 42 #include &lt;wtf/NeverDestroyed.h&gt;
 43 #include &lt;wtf/Ref.h&gt;
 44 
 45 #if ENABLE(CONTENT_EXTENSIONS)
 46 #include &quot;UserContentController.h&quot;
 47 #endif
 48 
 49 namespace WebCore {
 50 
 51 // Rough size estimate for the memory cache.
 52 unsigned StyleSheetContents::estimatedSizeInBytes() const
 53 {
 54     // Note that this does not take into account size of the strings hanging from various objects.
<span class="line-modified"> 55     // The assumption is that nearly all of of them are atomic and would exist anyway.</span>
 56     unsigned size = sizeof(*this);
 57 
 58     // FIXME: This ignores the children of media and region rules.
 59     // Most rules are StyleRules.
 60     size += ruleCount() * StyleRule::averageSizeInBytes();
 61 
 62     for (unsigned i = 0; i &lt; m_importRules.size(); ++i) {
 63         if (StyleSheetContents* sheet = m_importRules[i]-&gt;styleSheet())
 64             size += sheet-&gt;estimatedSizeInBytes();
 65     }
 66     return size;
 67 }
 68 
 69 StyleSheetContents::StyleSheetContents(StyleRuleImport* ownerRule, const String&amp; originalURL, const CSSParserContext&amp; context)
 70     : m_ownerRule(ownerRule)
 71     , m_originalURL(originalURL)
 72     , m_defaultNamespace(starAtom())
 73     , m_isUserStyleSheet(ownerRule &amp;&amp; ownerRule-&gt;parentStyleSheet() &amp;&amp; ownerRule-&gt;parentStyleSheet()-&gt;isUserStyleSheet())
 74     , m_parserContext(context)
 75 {
</pre>
<hr />
<pre>
139         m_importRules.last()-&gt;setParentStyleSheet(this);
140         m_importRules.last()-&gt;requestStyleSheet();
141         return;
142     }
143 
144     if (is&lt;StyleRuleNamespace&gt;(rule)) {
145         // Parser enforces that @namespace rules come before all rules other than
146         // import/charset rules
147         ASSERT(m_childRules.isEmpty());
148         StyleRuleNamespace&amp; namespaceRule = downcast&lt;StyleRuleNamespace&gt;(rule.get());
149         parserAddNamespace(namespaceRule.prefix(), namespaceRule.uri());
150         m_namespaceRules.append(downcast&lt;StyleRuleNamespace&gt;(rule.ptr()));
151         return;
152     }
153 
154     if (is&lt;StyleRuleMedia&gt;(rule))
155         reportMediaQueryWarningIfNeeded(singleOwnerDocument(), downcast&lt;StyleRuleMedia&gt;(rule.get()).mediaQueries());
156 
157     // NOTE: The selector list has to fit into RuleData. &lt;http://webkit.org/b/118369&gt;
158     // If we&#39;re adding a rule with a huge number of selectors, split it up into multiple rules
<span class="line-modified">159     if (is&lt;StyleRule&gt;(rule) &amp;&amp; downcast&lt;StyleRule&gt;(rule.get()).selectorList().componentCount() &gt; RuleData::maximumSelectorComponentCount) {</span>
<span class="line-modified">160         m_childRules.appendVector(downcast&lt;StyleRule&gt;(rule.get()).splitIntoMultipleRulesWithMaximumSelectorComponentCount(RuleData::maximumSelectorComponentCount));</span>
161         return;
162     }
163 
164     m_childRules.append(WTFMove(rule));
165 }
166 
167 StyleRuleBase* StyleSheetContents::ruleAt(unsigned index) const
168 {
169     ASSERT_WITH_SECURITY_IMPLICATION(index &lt; ruleCount());
170 
171     unsigned childVectorIndex = index;
172     if (childVectorIndex &lt; m_importRules.size())
173         return m_importRules[childVectorIndex].get();
174 
175     childVectorIndex -= m_importRules.size();
176 
177     if (childVectorIndex &lt; m_namespaceRules.size())
178         return m_namespaceRules[childVectorIndex].get();
179 
180     childVectorIndex -= m_namespaceRules.size();
</pre>
<hr />
<pre>
247         // Inserting @namespace rule when rules other than import/namespace/charset
248         // are present is not allowed.
249         if (!m_childRules.isEmpty())
250             return false;
251 
252         StyleRuleNamespace&amp; namespaceRule = downcast&lt;StyleRuleNamespace&gt;(rule.get());
253         m_namespaceRules.insert(index, downcast&lt;StyleRuleNamespace&gt;(rule.ptr()));
254 
255         // For now to be compatible with IE and Firefox if a namespace rule with the same
256         // prefix is added, it overwrites previous ones.
257         // FIXME: The eventual correct behavior would be to ensure that the last value in
258         // the list wins.
259         parserAddNamespace(namespaceRule.prefix(), namespaceRule.uri());
260         return true;
261     }
262     if (is&lt;StyleRuleNamespace&gt;(rule))
263         return false;
264     childVectorIndex -= m_namespaceRules.size();
265 
266     // If the number of selectors would overflow RuleData, we drop the operation.
<span class="line-modified">267     if (is&lt;StyleRule&gt;(rule) &amp;&amp; downcast&lt;StyleRule&gt;(rule.get()).selectorList().componentCount() &gt; RuleData::maximumSelectorComponentCount)</span>
268         return false;
269 
270     m_childRules.insert(childVectorIndex, WTFMove(rule));
271     return true;
272 }
273 
274 void StyleSheetContents::wrapperDeleteRule(unsigned index)
275 {
276     ASSERT(m_isMutable);
277     ASSERT_WITH_SECURITY_IMPLICATION(index &lt; ruleCount());
278 
279     unsigned childVectorIndex = index;
280     if (childVectorIndex &lt; m_importRules.size()) {
281         m_importRules[childVectorIndex]-&gt;clearParentStyleSheet();
282         m_importRules.remove(childVectorIndex);
283         return;
284     }
285     childVectorIndex -= m_importRules.size();
286 
287     if (childVectorIndex &lt; m_namespaceRules.size()) {
</pre>
<hr />
<pre>
299 {
300     ASSERT(!uri.isNull());
301     if (prefix.isNull()) {
302         m_defaultNamespace = uri;
303         return;
304     }
305     PrefixNamespaceURIMap::AddResult result = m_namespaces.add(prefix, uri);
306     if (result.isNewEntry)
307         return;
308     result.iterator-&gt;value = uri;
309 }
310 
311 const AtomString&amp; StyleSheetContents::namespaceURIFromPrefix(const AtomString&amp; prefix)
312 {
313     PrefixNamespaceURIMap::const_iterator it = m_namespaces.find(prefix);
314     if (it == m_namespaces.end())
315         return nullAtom();
316     return it-&gt;value;
317 }
318 
<span class="line-modified">319 void StyleSheetContents::parseAuthorStyleSheet(const CachedCSSStyleSheet* cachedStyleSheet, const SecurityOrigin* securityOrigin)</span>
320 {
321     bool isSameOriginRequest = securityOrigin &amp;&amp; securityOrigin-&gt;canRequest(baseURL());
322     CachedCSSStyleSheet::MIMETypeCheckHint mimeTypeCheckHint = isStrictParserMode(m_parserContext.mode) || !isSameOriginRequest ? CachedCSSStyleSheet::MIMETypeCheckHint::Strict : CachedCSSStyleSheet::MIMETypeCheckHint::Lax;
323     bool hasValidMIMEType = true;
324     String sheetText = cachedStyleSheet-&gt;sheetText(mimeTypeCheckHint, &amp;hasValidMIMEType);
325 
326     if (!hasValidMIMEType) {
327         ASSERT(sheetText.isNull());
328         if (auto* document = singleOwnerDocument()) {
329             if (auto* page = document-&gt;page()) {
330                 if (isStrictParserMode(m_parserContext.mode))
331                     page-&gt;console().addMessage(MessageSource::Security, MessageLevel::Error, makeString(&quot;Did not parse stylesheet at &#39;&quot;, cachedStyleSheet-&gt;url().stringCenterEllipsizedToLength(), &quot;&#39; because non CSS MIME types are not allowed in strict mode.&quot;));
332                 else if (!cachedStyleSheet-&gt;mimeTypeAllowedByNosniff())
333                     page-&gt;console().addMessage(MessageSource::Security, MessageLevel::Error, makeString(&quot;Did not parse stylesheet at &#39;&quot;, cachedStyleSheet-&gt;url().stringCenterEllipsizedToLength(), &quot;&#39; because non CSS MIME types are not allowed when &#39;X-Content-Type: nosniff&#39; is given.&quot;));
334                 else
335                     page-&gt;console().addMessage(MessageSource::Security, MessageLevel::Error, makeString(&quot;Did not parse stylesheet at &#39;&quot;, cachedStyleSheet-&gt;url().stringCenterEllipsizedToLength(), &quot;&#39; because non CSS MIME types are not allowed for cross-origin stylesheets.&quot;));
336             }
337         }
<span class="line-modified">338         return;</span>
339     }
340 
341     CSSParser(parserContext()).parseSheet(this, sheetText, CSSParser::RuleParsing::Deferred);

342 }
343 
344 bool StyleSheetContents::parseString(const String&amp; sheetText)
345 {
346     CSSParser p(parserContext());
347     p.parseSheet(this, sheetText, parserContext().mode != UASheetMode ? CSSParser::RuleParsing::Deferred : CSSParser::RuleParsing::Normal);
348     return true;
349 }
350 
351 bool StyleSheetContents::isLoading() const
352 {
353     for (unsigned i = 0; i &lt; m_importRules.size(); ++i) {
354         if (m_importRules[i]-&gt;isLoading())
355             return true;
356     }
357     return false;
358 }
359 
360 void StyleSheetContents::checkLoaded()
361 {
</pre>
<hr />
<pre>
409     return root-&gt;m_clients[0]-&gt;ownerNode();
410 }
411 
412 Document* StyleSheetContents::singleOwnerDocument() const
413 {
414     Node* ownerNode = singleOwnerNode();
415     return ownerNode ? &amp;ownerNode-&gt;document() : 0;
416 }
417 
418 URL StyleSheetContents::completeURL(const String&amp; url) const
419 {
420     return m_parserContext.completeURL(url);
421 }
422 
423 static bool traverseRulesInVector(const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; rules, const WTF::Function&lt;bool (const StyleRuleBase&amp;)&gt;&amp; handler)
424 {
425     for (auto&amp; rule : rules) {
426         if (handler(*rule))
427             return true;
428         switch (rule-&gt;type()) {
<span class="line-modified">429         case StyleRuleBase::Media: {</span>
430             auto* childRules = downcast&lt;StyleRuleMedia&gt;(*rule).childRulesWithoutDeferredParsing();
431             if (childRules &amp;&amp; traverseRulesInVector(*childRules, handler))
432                 return true;
433             break;
434         }
<span class="line-modified">435         case StyleRuleBase::Import:</span>
436             ASSERT_NOT_REACHED();
437             break;
<span class="line-modified">438         case StyleRuleBase::Style:</span>
<span class="line-modified">439         case StyleRuleBase::FontFace:</span>
<span class="line-modified">440         case StyleRuleBase::Page:</span>
<span class="line-modified">441         case StyleRuleBase::Keyframes:</span>
<span class="line-modified">442         case StyleRuleBase::Namespace:</span>
<span class="line-modified">443         case StyleRuleBase::Unknown:</span>
<span class="line-modified">444         case StyleRuleBase::Charset:</span>
<span class="line-modified">445         case StyleRuleBase::Keyframe:</span>
<span class="line-modified">446         case StyleRuleBase::Supports:</span>
447 #if ENABLE(CSS_DEVICE_ADAPTATION)
<span class="line-modified">448         case StyleRuleBase::Viewport:</span>
449 #endif
450             break;
451         }
452     }
453     return false;
454 }
455 
456 bool StyleSheetContents::traverseRules(const WTF::Function&lt;bool (const StyleRuleBase&amp;)&gt;&amp; handler) const
457 {
458     for (auto&amp; importRule : m_importRules) {
459         if (handler(*importRule))
460             return true;
461         auto* importedStyleSheet = importRule-&gt;styleSheet();
462         if (importedStyleSheet &amp;&amp; importedStyleSheet-&gt;traverseRules(handler))
463             return true;
464     }
465     return traverseRulesInVector(m_childRules, handler);
466 }
467 
468 bool StyleSheetContents::traverseSubresources(const WTF::Function&lt;bool (const CachedResource&amp;)&gt;&amp; handler) const
469 {
470     return traverseRules([&amp;] (const StyleRuleBase&amp; rule) {
471         switch (rule.type()) {
<span class="line-modified">472         case StyleRuleBase::Style: {</span>
473             auto* properties = downcast&lt;StyleRule&gt;(rule).propertiesWithoutDeferredParsing();
474             return properties &amp;&amp; properties-&gt;traverseSubresources(handler);
475         }
<span class="line-modified">476         case StyleRuleBase::FontFace:</span>
477             return downcast&lt;StyleRuleFontFace&gt;(rule).properties().traverseSubresources(handler);
<span class="line-modified">478         case StyleRuleBase::Import:</span>
479             if (auto* cachedResource = downcast&lt;StyleRuleImport&gt;(rule).cachedCSSStyleSheet())
480                 return handler(*cachedResource);
481             return false;
<span class="line-modified">482         case StyleRuleBase::Media:</span>
<span class="line-modified">483         case StyleRuleBase::Page:</span>
<span class="line-modified">484         case StyleRuleBase::Keyframes:</span>
<span class="line-modified">485         case StyleRuleBase::Namespace:</span>
<span class="line-modified">486         case StyleRuleBase::Unknown:</span>
<span class="line-modified">487         case StyleRuleBase::Charset:</span>
<span class="line-modified">488         case StyleRuleBase::Keyframe:</span>
<span class="line-modified">489         case StyleRuleBase::Supports:</span>
490 #if ENABLE(CSS_DEVICE_ADAPTATION)
<span class="line-modified">491         case StyleRuleBase::Viewport:</span>
492 #endif
493             return false;
494         };
495         ASSERT_NOT_REACHED();
496         return false;
497     });
498 }
499 
500 bool StyleSheetContents::subresourcesAllowReuse(CachePolicy cachePolicy, FrameLoader&amp; loader) const
501 {
502     bool hasFailedOrExpiredResources = traverseSubresources([cachePolicy, &amp;loader](const CachedResource&amp; resource) {
503         if (resource.loadFailedOrCanceled())
504             return true;
505         // We can&#39;t revalidate subresources individually so don&#39;t use reuse the parsed sheet if they need revalidation.
506         if (resource.makeRevalidationDecision(cachePolicy) != CachedResource::RevalidationDecision::No)
507             return true;
508 
509 #if ENABLE(CONTENT_EXTENSIONS)
510         // If a cached subresource is blocked or made HTTPS by a content blocker, we cannot reuse the cached stylesheet.
511         auto* page = loader.frame().page();
</pre>
</td>
<td>
<hr />
<pre>
 35 #include &quot;PageConsoleClient.h&quot;
 36 #include &quot;ResourceLoadInfo.h&quot;
 37 #include &quot;RuleSet.h&quot;
 38 #include &quot;SecurityOrigin.h&quot;
 39 #include &quot;StyleRule.h&quot;
 40 #include &quot;StyleRuleImport.h&quot;
 41 #include &lt;wtf/Deque.h&gt;
 42 #include &lt;wtf/NeverDestroyed.h&gt;
 43 #include &lt;wtf/Ref.h&gt;
 44 
 45 #if ENABLE(CONTENT_EXTENSIONS)
 46 #include &quot;UserContentController.h&quot;
 47 #endif
 48 
 49 namespace WebCore {
 50 
 51 // Rough size estimate for the memory cache.
 52 unsigned StyleSheetContents::estimatedSizeInBytes() const
 53 {
 54     // Note that this does not take into account size of the strings hanging from various objects.
<span class="line-modified"> 55     // The assumption is that nearly all of of them are atoms that would exist anyway.</span>
 56     unsigned size = sizeof(*this);
 57 
 58     // FIXME: This ignores the children of media and region rules.
 59     // Most rules are StyleRules.
 60     size += ruleCount() * StyleRule::averageSizeInBytes();
 61 
 62     for (unsigned i = 0; i &lt; m_importRules.size(); ++i) {
 63         if (StyleSheetContents* sheet = m_importRules[i]-&gt;styleSheet())
 64             size += sheet-&gt;estimatedSizeInBytes();
 65     }
 66     return size;
 67 }
 68 
 69 StyleSheetContents::StyleSheetContents(StyleRuleImport* ownerRule, const String&amp; originalURL, const CSSParserContext&amp; context)
 70     : m_ownerRule(ownerRule)
 71     , m_originalURL(originalURL)
 72     , m_defaultNamespace(starAtom())
 73     , m_isUserStyleSheet(ownerRule &amp;&amp; ownerRule-&gt;parentStyleSheet() &amp;&amp; ownerRule-&gt;parentStyleSheet()-&gt;isUserStyleSheet())
 74     , m_parserContext(context)
 75 {
</pre>
<hr />
<pre>
139         m_importRules.last()-&gt;setParentStyleSheet(this);
140         m_importRules.last()-&gt;requestStyleSheet();
141         return;
142     }
143 
144     if (is&lt;StyleRuleNamespace&gt;(rule)) {
145         // Parser enforces that @namespace rules come before all rules other than
146         // import/charset rules
147         ASSERT(m_childRules.isEmpty());
148         StyleRuleNamespace&amp; namespaceRule = downcast&lt;StyleRuleNamespace&gt;(rule.get());
149         parserAddNamespace(namespaceRule.prefix(), namespaceRule.uri());
150         m_namespaceRules.append(downcast&lt;StyleRuleNamespace&gt;(rule.ptr()));
151         return;
152     }
153 
154     if (is&lt;StyleRuleMedia&gt;(rule))
155         reportMediaQueryWarningIfNeeded(singleOwnerDocument(), downcast&lt;StyleRuleMedia&gt;(rule.get()).mediaQueries());
156 
157     // NOTE: The selector list has to fit into RuleData. &lt;http://webkit.org/b/118369&gt;
158     // If we&#39;re adding a rule with a huge number of selectors, split it up into multiple rules
<span class="line-modified">159     if (is&lt;StyleRule&gt;(rule) &amp;&amp; downcast&lt;StyleRule&gt;(rule.get()).selectorList().componentCount() &gt; Style::RuleData::maximumSelectorComponentCount) {</span>
<span class="line-modified">160         m_childRules.appendVector(downcast&lt;StyleRule&gt;(rule.get()).splitIntoMultipleRulesWithMaximumSelectorComponentCount(Style::RuleData::maximumSelectorComponentCount));</span>
161         return;
162     }
163 
164     m_childRules.append(WTFMove(rule));
165 }
166 
167 StyleRuleBase* StyleSheetContents::ruleAt(unsigned index) const
168 {
169     ASSERT_WITH_SECURITY_IMPLICATION(index &lt; ruleCount());
170 
171     unsigned childVectorIndex = index;
172     if (childVectorIndex &lt; m_importRules.size())
173         return m_importRules[childVectorIndex].get();
174 
175     childVectorIndex -= m_importRules.size();
176 
177     if (childVectorIndex &lt; m_namespaceRules.size())
178         return m_namespaceRules[childVectorIndex].get();
179 
180     childVectorIndex -= m_namespaceRules.size();
</pre>
<hr />
<pre>
247         // Inserting @namespace rule when rules other than import/namespace/charset
248         // are present is not allowed.
249         if (!m_childRules.isEmpty())
250             return false;
251 
252         StyleRuleNamespace&amp; namespaceRule = downcast&lt;StyleRuleNamespace&gt;(rule.get());
253         m_namespaceRules.insert(index, downcast&lt;StyleRuleNamespace&gt;(rule.ptr()));
254 
255         // For now to be compatible with IE and Firefox if a namespace rule with the same
256         // prefix is added, it overwrites previous ones.
257         // FIXME: The eventual correct behavior would be to ensure that the last value in
258         // the list wins.
259         parserAddNamespace(namespaceRule.prefix(), namespaceRule.uri());
260         return true;
261     }
262     if (is&lt;StyleRuleNamespace&gt;(rule))
263         return false;
264     childVectorIndex -= m_namespaceRules.size();
265 
266     // If the number of selectors would overflow RuleData, we drop the operation.
<span class="line-modified">267     if (is&lt;StyleRule&gt;(rule) &amp;&amp; downcast&lt;StyleRule&gt;(rule.get()).selectorList().componentCount() &gt; Style::RuleData::maximumSelectorComponentCount)</span>
268         return false;
269 
270     m_childRules.insert(childVectorIndex, WTFMove(rule));
271     return true;
272 }
273 
274 void StyleSheetContents::wrapperDeleteRule(unsigned index)
275 {
276     ASSERT(m_isMutable);
277     ASSERT_WITH_SECURITY_IMPLICATION(index &lt; ruleCount());
278 
279     unsigned childVectorIndex = index;
280     if (childVectorIndex &lt; m_importRules.size()) {
281         m_importRules[childVectorIndex]-&gt;clearParentStyleSheet();
282         m_importRules.remove(childVectorIndex);
283         return;
284     }
285     childVectorIndex -= m_importRules.size();
286 
287     if (childVectorIndex &lt; m_namespaceRules.size()) {
</pre>
<hr />
<pre>
299 {
300     ASSERT(!uri.isNull());
301     if (prefix.isNull()) {
302         m_defaultNamespace = uri;
303         return;
304     }
305     PrefixNamespaceURIMap::AddResult result = m_namespaces.add(prefix, uri);
306     if (result.isNewEntry)
307         return;
308     result.iterator-&gt;value = uri;
309 }
310 
311 const AtomString&amp; StyleSheetContents::namespaceURIFromPrefix(const AtomString&amp; prefix)
312 {
313     PrefixNamespaceURIMap::const_iterator it = m_namespaces.find(prefix);
314     if (it == m_namespaces.end())
315         return nullAtom();
316     return it-&gt;value;
317 }
318 
<span class="line-modified">319 bool StyleSheetContents::parseAuthorStyleSheet(const CachedCSSStyleSheet* cachedStyleSheet, const SecurityOrigin* securityOrigin)</span>
320 {
321     bool isSameOriginRequest = securityOrigin &amp;&amp; securityOrigin-&gt;canRequest(baseURL());
322     CachedCSSStyleSheet::MIMETypeCheckHint mimeTypeCheckHint = isStrictParserMode(m_parserContext.mode) || !isSameOriginRequest ? CachedCSSStyleSheet::MIMETypeCheckHint::Strict : CachedCSSStyleSheet::MIMETypeCheckHint::Lax;
323     bool hasValidMIMEType = true;
324     String sheetText = cachedStyleSheet-&gt;sheetText(mimeTypeCheckHint, &amp;hasValidMIMEType);
325 
326     if (!hasValidMIMEType) {
327         ASSERT(sheetText.isNull());
328         if (auto* document = singleOwnerDocument()) {
329             if (auto* page = document-&gt;page()) {
330                 if (isStrictParserMode(m_parserContext.mode))
331                     page-&gt;console().addMessage(MessageSource::Security, MessageLevel::Error, makeString(&quot;Did not parse stylesheet at &#39;&quot;, cachedStyleSheet-&gt;url().stringCenterEllipsizedToLength(), &quot;&#39; because non CSS MIME types are not allowed in strict mode.&quot;));
332                 else if (!cachedStyleSheet-&gt;mimeTypeAllowedByNosniff())
333                     page-&gt;console().addMessage(MessageSource::Security, MessageLevel::Error, makeString(&quot;Did not parse stylesheet at &#39;&quot;, cachedStyleSheet-&gt;url().stringCenterEllipsizedToLength(), &quot;&#39; because non CSS MIME types are not allowed when &#39;X-Content-Type: nosniff&#39; is given.&quot;));
334                 else
335                     page-&gt;console().addMessage(MessageSource::Security, MessageLevel::Error, makeString(&quot;Did not parse stylesheet at &#39;&quot;, cachedStyleSheet-&gt;url().stringCenterEllipsizedToLength(), &quot;&#39; because non CSS MIME types are not allowed for cross-origin stylesheets.&quot;));
336             }
337         }
<span class="line-modified">338         return false;</span>
339     }
340 
341     CSSParser(parserContext()).parseSheet(this, sheetText, CSSParser::RuleParsing::Deferred);
<span class="line-added">342     return true;</span>
343 }
344 
345 bool StyleSheetContents::parseString(const String&amp; sheetText)
346 {
347     CSSParser p(parserContext());
348     p.parseSheet(this, sheetText, parserContext().mode != UASheetMode ? CSSParser::RuleParsing::Deferred : CSSParser::RuleParsing::Normal);
349     return true;
350 }
351 
352 bool StyleSheetContents::isLoading() const
353 {
354     for (unsigned i = 0; i &lt; m_importRules.size(); ++i) {
355         if (m_importRules[i]-&gt;isLoading())
356             return true;
357     }
358     return false;
359 }
360 
361 void StyleSheetContents::checkLoaded()
362 {
</pre>
<hr />
<pre>
410     return root-&gt;m_clients[0]-&gt;ownerNode();
411 }
412 
413 Document* StyleSheetContents::singleOwnerDocument() const
414 {
415     Node* ownerNode = singleOwnerNode();
416     return ownerNode ? &amp;ownerNode-&gt;document() : 0;
417 }
418 
419 URL StyleSheetContents::completeURL(const String&amp; url) const
420 {
421     return m_parserContext.completeURL(url);
422 }
423 
424 static bool traverseRulesInVector(const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; rules, const WTF::Function&lt;bool (const StyleRuleBase&amp;)&gt;&amp; handler)
425 {
426     for (auto&amp; rule : rules) {
427         if (handler(*rule))
428             return true;
429         switch (rule-&gt;type()) {
<span class="line-modified">430         case StyleRuleType::Media: {</span>
431             auto* childRules = downcast&lt;StyleRuleMedia&gt;(*rule).childRulesWithoutDeferredParsing();
432             if (childRules &amp;&amp; traverseRulesInVector(*childRules, handler))
433                 return true;
434             break;
435         }
<span class="line-modified">436         case StyleRuleType::Import:</span>
437             ASSERT_NOT_REACHED();
438             break;
<span class="line-modified">439         case StyleRuleType::Style:</span>
<span class="line-modified">440         case StyleRuleType::FontFace:</span>
<span class="line-modified">441         case StyleRuleType::Page:</span>
<span class="line-modified">442         case StyleRuleType::Keyframes:</span>
<span class="line-modified">443         case StyleRuleType::Namespace:</span>
<span class="line-modified">444         case StyleRuleType::Unknown:</span>
<span class="line-modified">445         case StyleRuleType::Charset:</span>
<span class="line-modified">446         case StyleRuleType::Keyframe:</span>
<span class="line-modified">447         case StyleRuleType::Supports:</span>
448 #if ENABLE(CSS_DEVICE_ADAPTATION)
<span class="line-modified">449         case StyleRuleType::Viewport:</span>
450 #endif
451             break;
452         }
453     }
454     return false;
455 }
456 
457 bool StyleSheetContents::traverseRules(const WTF::Function&lt;bool (const StyleRuleBase&amp;)&gt;&amp; handler) const
458 {
459     for (auto&amp; importRule : m_importRules) {
460         if (handler(*importRule))
461             return true;
462         auto* importedStyleSheet = importRule-&gt;styleSheet();
463         if (importedStyleSheet &amp;&amp; importedStyleSheet-&gt;traverseRules(handler))
464             return true;
465     }
466     return traverseRulesInVector(m_childRules, handler);
467 }
468 
469 bool StyleSheetContents::traverseSubresources(const WTF::Function&lt;bool (const CachedResource&amp;)&gt;&amp; handler) const
470 {
471     return traverseRules([&amp;] (const StyleRuleBase&amp; rule) {
472         switch (rule.type()) {
<span class="line-modified">473         case StyleRuleType::Style: {</span>
474             auto* properties = downcast&lt;StyleRule&gt;(rule).propertiesWithoutDeferredParsing();
475             return properties &amp;&amp; properties-&gt;traverseSubresources(handler);
476         }
<span class="line-modified">477         case StyleRuleType::FontFace:</span>
478             return downcast&lt;StyleRuleFontFace&gt;(rule).properties().traverseSubresources(handler);
<span class="line-modified">479         case StyleRuleType::Import:</span>
480             if (auto* cachedResource = downcast&lt;StyleRuleImport&gt;(rule).cachedCSSStyleSheet())
481                 return handler(*cachedResource);
482             return false;
<span class="line-modified">483         case StyleRuleType::Media:</span>
<span class="line-modified">484         case StyleRuleType::Page:</span>
<span class="line-modified">485         case StyleRuleType::Keyframes:</span>
<span class="line-modified">486         case StyleRuleType::Namespace:</span>
<span class="line-modified">487         case StyleRuleType::Unknown:</span>
<span class="line-modified">488         case StyleRuleType::Charset:</span>
<span class="line-modified">489         case StyleRuleType::Keyframe:</span>
<span class="line-modified">490         case StyleRuleType::Supports:</span>
491 #if ENABLE(CSS_DEVICE_ADAPTATION)
<span class="line-modified">492         case StyleRuleType::Viewport:</span>
493 #endif
494             return false;
495         };
496         ASSERT_NOT_REACHED();
497         return false;
498     });
499 }
500 
501 bool StyleSheetContents::subresourcesAllowReuse(CachePolicy cachePolicy, FrameLoader&amp; loader) const
502 {
503     bool hasFailedOrExpiredResources = traverseSubresources([cachePolicy, &amp;loader](const CachedResource&amp; resource) {
504         if (resource.loadFailedOrCanceled())
505             return true;
506         // We can&#39;t revalidate subresources individually so don&#39;t use reuse the parsed sheet if they need revalidation.
507         if (resource.makeRevalidationDecision(cachePolicy) != CachedResource::RevalidationDecision::No)
508             return true;
509 
510 #if ENABLE(CONTENT_EXTENSIONS)
511         // If a cached subresource is blocked or made HTTPS by a content blocker, we cannot reuse the cached stylesheet.
512         auto* page = loader.frame().page();
</pre>
</td>
</tr>
</table>
<center><a href="StyleRuleImport.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleSheetContents.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
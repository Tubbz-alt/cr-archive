<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/UniqueIDBDatabase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2015, 2016 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;UniqueIDBDatabase.h&quot;
  28 
  29 #if ENABLE(INDEXED_DATABASE)
  30 
<a name="1" id="anc1"></a>
  31 #include &quot;IDBCursorInfo.h&quot;
  32 #include &quot;IDBGetAllRecordsData.h&quot;
  33 #include &quot;IDBGetAllResult.h&quot;
  34 #include &quot;IDBGetRecordData.h&quot;
  35 #include &quot;IDBIterateCursorData.h&quot;
  36 #include &quot;IDBKeyRangeData.h&quot;
  37 #include &quot;IDBResultData.h&quot;
  38 #include &quot;IDBServer.h&quot;
  39 #include &quot;IDBTransactionInfo.h&quot;
  40 #include &quot;IDBValue.h&quot;
  41 #include &quot;Logging.h&quot;
<a name="2" id="anc2"></a>
  42 #include &quot;StorageQuotaManager.h&quot;
  43 #include &quot;UniqueIDBDatabaseConnection.h&quot;
<a name="3" id="anc3"></a>




  44 #include &lt;wtf/Scope.h&gt;
  45 
  46 namespace WebCore {
  47 using namespace JSC;
  48 namespace IDBServer {
  49 
  50 static const uint64_t defaultWriteOperationCost = 4;
  51 
  52 static inline uint64_t estimateSize(const IDBKeyData&amp; keyData)
  53 {
  54     uint64_t size = 4;
  55     switch (keyData.type()) {
  56     case IndexedDB::KeyType::String:
  57         size += keyData.string().sizeInBytes();
  58         break;
  59     case IndexedDB::KeyType::Binary: {
  60         size += keyData.binary().size();
  61         break;
  62     }
  63     case IndexedDB::KeyType::Array:
  64         for (auto&amp; data : keyData.array())
  65             size += estimateSize(data);
  66         break;
  67     default:
  68         break;
  69     }
  70     return size;
  71 }
  72 
  73 static inline uint64_t estimateSize(const IDBValue&amp; value)
  74 {
  75     uint64_t size = 4;
  76     size += value.data().size();
  77     for (auto&amp; url : value.blobURLs())
  78         size += url.sizeInBytes();
  79     for (auto&amp; path : value.blobFilePaths())
  80         size += path.sizeInBytes();
  81     return size;
  82 }
  83 
<a name="4" id="anc4"></a><span class="line-added">  84 static inline uint64_t estimateSize(const IDBKeyPath&amp; keyPath)</span>
<span class="line-added">  85 {</span>
<span class="line-added">  86     return WTF::switchOn(keyPath, [](const String&amp; path) {</span>
<span class="line-added">  87         return static_cast&lt;uint64_t&gt;(path.sizeInBytes());</span>
<span class="line-added">  88     }, [](const Vector&lt;String&gt;&amp; paths) {</span>
<span class="line-added">  89         uint64_t size = 0;</span>
<span class="line-added">  90         for (auto path : paths)</span>
<span class="line-added">  91             size += path.sizeInBytes();</span>
<span class="line-added">  92         return size;</span>
<span class="line-added">  93     });</span>
<span class="line-added">  94 }</span>
<span class="line-added">  95 </span>
  96 static inline uint64_t estimateSize(const IDBIndexInfo&amp; info)
  97 {
  98     uint64_t size = 4;
  99     size += info.name().sizeInBytes();
<a name="5" id="anc5"></a><span class="line-added"> 100     size += estimateSize(info.keyPath());</span>
 101     return size;
 102 }
 103 
 104 static inline uint64_t estimateSize(const IDBObjectStoreInfo&amp; info)
 105 {
 106     uint64_t size = 4;
 107     size += info.name().sizeInBytes();
<a name="6" id="anc6"></a><span class="line-modified"> 108     if (auto keyPath = info.keyPath())</span>
<span class="line-modified"> 109         size += estimateSize(*keyPath);</span>

 110     return size;
 111 }
 112 
 113 UniqueIDBDatabase::UniqueIDBDatabase(IDBServer&amp; server, const IDBDatabaseIdentifier&amp; identifier)
 114     : m_server(server)
 115     , m_identifier(identifier)
<a name="7" id="anc7"></a>
 116 {
<a name="8" id="anc8"></a><span class="line-modified"> 117     ASSERT(!isMainThread());</span>
<span class="line-added"> 118 </span>
<span class="line-added"> 119     m_server.addDatabase(*this);</span>
<span class="line-added"> 120     LOG(IndexedDB, &quot;UniqueIDBDatabase::UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.loggingString().utf8().data());</span>
 121 }
 122 
 123 UniqueIDBDatabase::~UniqueIDBDatabase()
 124 {
<a name="9" id="anc9"></a><span class="line-modified"> 125     LOG(IndexedDB, &quot;UniqueIDBDatabase::~UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.loggingString().utf8().data());</span>
<span class="line-modified"> 126     ASSERT(!isMainThread());</span>
<span class="line-modified"> 127     ASSERT(m_pendingOpenDBRequests.isEmpty());</span>
<span class="line-modified"> 128     ASSERT(!m_currentOpenDBRequest);</span>
<span class="line-added"> 129     ASSERT(m_inProgressTransactions.isEmpty());</span>
 130     ASSERT(m_pendingTransactions.isEmpty());
<a name="10" id="anc10"></a><span class="line-modified"> 131     ASSERT(!hasAnyOpenConnections());</span>
<span class="line-modified"> 132     ASSERT(!m_versionChangeTransaction);</span>
<span class="line-modified"> 133     ASSERT(!m_versionChangeDatabaseConnection);</span>



 134     RELEASE_ASSERT(!m_backingStore);
<a name="11" id="anc11"></a><span class="line-added"> 135 </span>
<span class="line-added"> 136     m_server.removeDatabase(*this);</span>
 137 }
 138 
 139 const IDBDatabaseInfo&amp; UniqueIDBDatabase::info() const
 140 {
 141     RELEASE_ASSERT(m_databaseInfo);
 142     return *m_databaseInfo;
 143 }
 144 
 145 void UniqueIDBDatabase::openDatabaseConnection(IDBConnectionToClient&amp; connection, const IDBRequestData&amp; requestData)
 146 {
 147     LOG(IndexedDB, &quot;UniqueIDBDatabase::openDatabaseConnection&quot;);
<a name="12" id="anc12"></a><span class="line-modified"> 148     ASSERT(!isMainThread());</span>

 149 
 150     m_pendingOpenDBRequests.add(ServerOpenDBRequest::create(connection, requestData));
 151 
<a name="13" id="anc13"></a>



 152     handleDatabaseOperations();
 153 }
 154 
<a name="14" id="anc14"></a>


















 155 static inline String quotaErrorMessageName(const char* taskName)
 156 {
 157     return makeString(&quot;Failed to &quot;, taskName, &quot; in database because not enough space for domain&quot;);
 158 }
 159 
<a name="15" id="anc15"></a>




























 160 void UniqueIDBDatabase::performCurrentOpenOperation()
 161 {
<a name="16" id="anc16"></a><span class="line-modified"> 162     LOG(IndexedDB, &quot;UniqueIDBDatabase::performCurrentOpenOperation (%p)&quot;, this);</span>
 163 
 164     ASSERT(m_currentOpenDBRequest);
 165     ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
 166 
<a name="17" id="anc17"></a><span class="line-modified"> 167     IDBError backingStoreOpenError;</span>
<span class="line-modified"> 168     if (!m_backingStore) {</span>
<span class="line-modified"> 169         // Quota check.</span>
<span class="line-modified"> 170         auto decision = m_server.requestSpace(m_identifier.origin(), defaultWriteOperationCost);</span>
<span class="line-modified"> 171         if (decision == StorageQuotaManager::Decision::Deny)</span>
<span class="line-modified"> 172             backingStoreOpenError = IDBError { QuotaExceededError, quotaErrorMessageName(&quot;OpenBackingStore&quot;) };</span>
<span class="line-modified"> 173         else {</span>
<span class="line-modified"> 174             m_backingStore = m_server.createBackingStore(m_identifier);</span>
<span class="line-modified"> 175             IDBDatabaseInfo databaseInfo;</span>
<span class="line-modified"> 176             backingStoreOpenError = m_backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);</span>
<span class="line-modified"> 177             if (backingStoreOpenError.isNull())</span>
<span class="line-modified"> 178                 m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(databaseInfo);</span>
<span class="line-modified"> 179             else</span>
<span class="line-modified"> 180                 m_backingStore = nullptr;</span>










 181         }
<a name="18" id="anc18"></a><span class="line-added"> 182     }</span>
<span class="line-added"> 183 </span>
<span class="line-added"> 184     if (!backingStoreOpenError.isNull()) {</span>
<span class="line-added"> 185         auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), backingStoreOpenError);</span>
<span class="line-added"> 186         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);</span>
<span class="line-added"> 187         m_currentOpenDBRequest = nullptr;</span>
<span class="line-added"> 188 </span>
 189         return;
 190     }
 191 
 192     // If we previously started a version change operation but were blocked by having open connections,
 193     // we might now be unblocked.
 194     if (m_versionChangeDatabaseConnection) {
 195         if (!m_versionChangeTransaction &amp;&amp; !hasAnyOpenConnections())
 196             startVersionChangeTransaction();
 197         return;
 198     }
 199 
 200     // 3.3.1 Opening a database
 201     // If requested version is undefined, then let requested version be 1 if db was created in the previous step,
 202     // or the current version of db otherwise.
 203     uint64_t requestedVersion = m_currentOpenDBRequest-&gt;requestData().requestedVersion();
 204     if (!requestedVersion)
 205         requestedVersion = m_databaseInfo-&gt;version() ? m_databaseInfo-&gt;version() : 1;
 206 
 207     // 3.3.1 Opening a database
 208     // If the database version higher than the requested version, abort these steps and return a VersionError.
 209     if (requestedVersion &lt; m_databaseInfo-&gt;version()) {
 210         auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), IDBError(VersionError));
 211         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);
 212         m_currentOpenDBRequest = nullptr;
 213 
 214         return;
 215     }
 216 
<a name="19" id="anc19"></a>







 217     Ref&lt;UniqueIDBDatabaseConnection&gt; connection = UniqueIDBDatabaseConnection::create(*this, *m_currentOpenDBRequest);
 218 
 219     if (requestedVersion == m_databaseInfo-&gt;version()) {
 220         auto* rawConnection = &amp;connection.get();
 221         addOpenDatabaseConnection(WTFMove(connection));
 222 
 223         auto result = IDBResultData::openDatabaseSuccess(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), *rawConnection);
 224         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);
 225         m_currentOpenDBRequest = nullptr;
 226 
 227         return;
 228     }
 229 
 230     ASSERT(!m_versionChangeDatabaseConnection);
 231     m_versionChangeDatabaseConnection = WTFMove(connection);
 232 
 233     // 3.3.7 &quot;versionchange&quot; transaction steps
 234     // If there&#39;s no other open connections to this database, the version change process can begin immediately.
 235     if (!hasAnyOpenConnections()) {
 236         startVersionChangeTransaction();
 237         return;
 238     }
 239 
 240     // Otherwise we have to notify all those open connections and wait for them to close.
 241     maybeNotifyConnectionsOfVersionChange();
 242 }
 243 
 244 void UniqueIDBDatabase::performCurrentDeleteOperation()
 245 {
<a name="20" id="anc20"></a><span class="line-modified"> 246     LOG(IndexedDB, &quot;UniqueIDBDatabase::performCurrentDeleteOperation - %s&quot;, m_identifier.loggingString().utf8().data());</span>

 247 
 248     ASSERT(m_currentOpenDBRequest);
 249     ASSERT(m_currentOpenDBRequest-&gt;isDeleteRequest());
 250 
<a name="21" id="anc21"></a>


 251     if (hasAnyOpenConnections()) {
 252         maybeNotifyConnectionsOfVersionChange();
 253         return;
 254     }
 255 
<a name="22" id="anc22"></a>



 256     ASSERT(m_pendingTransactions.isEmpty());
 257     ASSERT(m_openDatabaseConnections.isEmpty());
 258 
 259     // It&#39;s possible to have multiple delete requests queued up in a row.
 260     // In that scenario only the first request will actually have to delete the database.
 261     // Subsequent requests can immediately notify their completion.
 262 
<a name="23" id="anc23"></a><span class="line-modified"> 263     if (!m_databaseInfo &amp;&amp; m_mostRecentDeletedDatabaseInfo)</span>
<span class="line-modified"> 264         didDeleteBackingStore(0);</span>
<span class="line-modified"> 265     else</span>
<span class="line-modified"> 266         deleteBackingStore();</span>




 267 }
 268 
<a name="24" id="anc24"></a><span class="line-modified"> 269 void UniqueIDBDatabase::deleteBackingStore()</span>
 270 {
 271     ASSERT(!isMainThread());
<a name="25" id="anc25"></a><span class="line-modified"> 272     LOG(IndexedDB, &quot;UniqueIDBDatabase::deleteBackingStore&quot;);</span>
 273 
 274     uint64_t deletedVersion = 0;
 275 
 276     if (m_backingStore) {
 277         m_backingStore-&gt;deleteBackingStore();
<a name="26" id="anc26"></a>

 278         m_backingStore = nullptr;
<a name="27" id="anc27"></a>

 279     } else {
<a name="28" id="anc28"></a><span class="line-modified"> 280         auto backingStore = m_server.createBackingStore(m_identifier);</span>

 281 
 282         IDBDatabaseInfo databaseInfo;
 283         auto error = backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);
 284         if (!error.isNull())
<a name="29" id="anc29"></a><span class="line-modified"> 285             LOG_ERROR(&quot;Error getting database info from database %s that we are trying to delete&quot;, m_identifier.loggingString().utf8().data());</span>
 286 
 287         deletedVersion = databaseInfo.version();
 288         backingStore-&gt;deleteBackingStore();
<a name="30" id="anc30"></a>















































 289     }
<a name="31" id="anc31"></a>



 290 
<a name="32" id="anc32"></a><span class="line-modified"> 291     didDeleteBackingStore(deletedVersion);</span>





 292 }
 293 
 294 void UniqueIDBDatabase::didDeleteBackingStore(uint64_t deletedVersion)
 295 {
<a name="33" id="anc33"></a><span class="line-modified"> 296     LOG(IndexedDB, &quot;UniqueIDBDatabase::didDeleteBackingStore&quot;);</span>

 297 
<a name="34" id="anc34"></a><span class="line-modified"> 298     ASSERT(m_inProgressTransactions.isEmpty());</span>

 299     ASSERT(m_pendingTransactions.isEmpty());
 300     ASSERT(m_openDatabaseConnections.isEmpty());
 301     ASSERT(!m_backingStore);
 302 
<a name="35" id="anc35"></a><span class="line-modified"> 303     ASSERT(m_currentOpenDBRequest-&gt;isDeleteRequest());</span>


 304 
 305     if (m_databaseInfo)
 306         m_mostRecentDeletedDatabaseInfo = WTFMove(m_databaseInfo);
 307 
 308     // If this UniqueIDBDatabase was brought into existence for the purpose of deleting the file on disk,
 309     // we won&#39;t have a m_mostRecentDeletedDatabaseInfo. In that case, we&#39;ll manufacture one using the
 310     // passed in deletedVersion argument.
 311     if (!m_mostRecentDeletedDatabaseInfo)
<a name="36" id="anc36"></a><span class="line-modified"> 312         m_mostRecentDeletedDatabaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), deletedVersion, 0);</span>
 313 
 314     if (m_currentOpenDBRequest) {
 315         m_currentOpenDBRequest-&gt;notifyDidDeleteDatabase(*m_mostRecentDeletedDatabaseInfo);
 316         m_currentOpenDBRequest = nullptr;
 317     }
<a name="37" id="anc37"></a>








 318 }
 319 
 320 void UniqueIDBDatabase::clearStalePendingOpenDBRequests()
 321 {
 322     while (!m_pendingOpenDBRequests.isEmpty() &amp;&amp; m_pendingOpenDBRequests.first()-&gt;connection().isClosed())
 323         m_pendingOpenDBRequests.removeFirst();
 324 }
 325 
 326 void UniqueIDBDatabase::handleDatabaseOperations()
 327 {
<a name="38" id="anc38"></a><span class="line-modified"> 328     ASSERT(!isMainThread());</span>
<span class="line-modified"> 329     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleDatabaseOperations - There are %u pending&quot;, m_pendingOpenDBRequests.size());</span>






 330 
<a name="39" id="anc39"></a><span class="line-modified"> 331     if (m_versionChangeDatabaseConnection || m_versionChangeTransaction) {</span>
 332         // We can&#39;t start any new open-database operations right now, but we might be able to start handling a delete operation.
<a name="40" id="anc40"></a><span class="line-modified"> 333         if (!m_currentOpenDBRequest)</span>
<span class="line-modified"> 334             m_currentOpenDBRequest = takeNextRunnableRequest(RequestType::Delete);</span>
<span class="line-modified"> 335     } else if (!m_currentOpenDBRequest || m_currentOpenDBRequest-&gt;connection().isClosed())</span>
<span class="line-modified"> 336         m_currentOpenDBRequest = takeNextRunnableRequest();</span>





 337 
<a name="41" id="anc41"></a><span class="line-modified"> 338     while (m_currentOpenDBRequest) {</span>
<span class="line-modified"> 339         handleCurrentOperation();</span>
<span class="line-modified"> 340         if (!m_currentOpenDBRequest) {</span>
<span class="line-added"> 341             if (m_versionChangeTransaction)</span>
<span class="line-added"> 342                 m_currentOpenDBRequest = takeNextRunnableRequest(RequestType::Delete);</span>
<span class="line-added"> 343             else</span>
<span class="line-added"> 344                 m_currentOpenDBRequest = takeNextRunnableRequest();</span>
<span class="line-added"> 345         } else // Request need multiple attempts to handle.</span>
<span class="line-added"> 346             break;</span>
 347     }
<a name="42" id="anc42"></a><span class="line-modified"> 348     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleDatabaseOperations - There are %u pending after this round of handling&quot;, m_pendingOpenDBRequests.size());</span>




 349 }
 350 
 351 void UniqueIDBDatabase::handleCurrentOperation()
 352 {
<a name="43" id="anc43"></a><span class="line-modified"> 353     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleCurrentOperation&quot;);</span>

 354     ASSERT(m_currentOpenDBRequest);
 355 
 356     if (m_currentOpenDBRequest-&gt;isOpenRequest())
 357         performCurrentOpenOperation();
 358     else if (m_currentOpenDBRequest-&gt;isDeleteRequest())
 359         performCurrentDeleteOperation();
 360     else
 361         ASSERT_NOT_REACHED();
<a name="44" id="anc44"></a>


 362 }
 363 
 364 bool UniqueIDBDatabase::hasAnyOpenConnections() const
 365 {
 366     return !m_openDatabaseConnections.isEmpty();
 367 }
 368 
 369 bool UniqueIDBDatabase::allConnectionsAreClosedOrClosing() const
 370 {
 371     for (auto&amp; connection : m_openDatabaseConnections) {
 372         if (!connection-&gt;connectionIsClosing())
 373             return false;
 374     }
 375 
 376     return true;
 377 }
 378 
<a name="45" id="anc45"></a>
























































































 379 void UniqueIDBDatabase::handleDelete(IDBConnectionToClient&amp; connection, const IDBRequestData&amp; requestData)
 380 {
<a name="46" id="anc46"></a><span class="line-modified"> 381     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleDelete&quot;);</span>

 382 
 383     m_pendingOpenDBRequests.add(ServerOpenDBRequest::create(connection, requestData));
 384     handleDatabaseOperations();
 385 }
 386 
 387 void UniqueIDBDatabase::startVersionChangeTransaction()
 388 {
<a name="47" id="anc47"></a><span class="line-modified"> 389     LOG(IndexedDB, &quot;UniqueIDBDatabase::startVersionChangeTransaction&quot;);</span>
 390 
 391     ASSERT(!m_versionChangeTransaction);
 392     ASSERT(m_currentOpenDBRequest);
 393     ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
 394     ASSERT(m_versionChangeDatabaseConnection);
 395 
 396     uint64_t requestedVersion = m_currentOpenDBRequest-&gt;requestData().requestedVersion();
 397     if (!requestedVersion)
 398         requestedVersion = m_databaseInfo-&gt;version() ? m_databaseInfo-&gt;version() : 1;
 399 
 400     m_versionChangeTransaction = &amp;m_versionChangeDatabaseConnection-&gt;createVersionChangeTransaction(requestedVersion);
<a name="48" id="anc48"></a><span class="line-modified"> 401     auto versionChangeTransactionInfo = m_versionChangeTransaction-&gt;info();</span>
<span class="line-modified"> 402     m_inProgressTransactions.set(versionChangeTransactionInfo.identifier(), m_versionChangeTransaction);</span>


















 403 
<a name="49" id="anc49"></a><span class="line-modified"> 404     auto error = m_backingStore-&gt;beginTransaction(versionChangeTransactionInfo);</span>

 405     auto operation = WTFMove(m_currentOpenDBRequest);
 406     IDBResultData result;
 407     if (error.isNull()) {
 408         addOpenDatabaseConnection(*m_versionChangeDatabaseConnection);
<a name="50" id="anc50"></a><span class="line-modified"> 409         m_databaseInfo-&gt;setVersion(versionChangeTransactionInfo.newVersion());</span>
 410         result = IDBResultData::openDatabaseUpgradeNeeded(operation-&gt;requestData().requestIdentifier(), *m_versionChangeTransaction);
 411         operation-&gt;connection().didOpenDatabase(result);
 412     } else {
 413         m_versionChangeDatabaseConnection-&gt;abortTransactionWithoutCallback(*m_versionChangeTransaction);
 414         m_versionChangeDatabaseConnection = nullptr;
 415         result = IDBResultData::error(operation-&gt;requestData().requestIdentifier(), error);
 416         operation-&gt;connection().didOpenDatabase(result);
 417     }
<a name="51" id="anc51"></a>

 418 }
 419 
 420 void UniqueIDBDatabase::maybeNotifyConnectionsOfVersionChange()
 421 {
 422     ASSERT(m_currentOpenDBRequest);
 423 
 424     if (m_currentOpenDBRequest-&gt;hasNotifiedConnectionsOfVersionChange())
 425         return;
 426 
 427     uint64_t newVersion = m_currentOpenDBRequest-&gt;isOpenRequest() ? m_currentOpenDBRequest-&gt;requestData().requestedVersion() : 0;
 428     auto requestIdentifier = m_currentOpenDBRequest-&gt;requestData().requestIdentifier();
 429 
<a name="52" id="anc52"></a><span class="line-modified"> 430     LOG(IndexedDB, &quot;UniqueIDBDatabase::notifyConnectionsOfVersionChange - %&quot; PRIu64, newVersion);</span>
 431 
 432     // 3.3.7 &quot;versionchange&quot; transaction steps
 433     // Fire a versionchange event at each connection in m_openDatabaseConnections that is open.
 434     // The event must not be fired on connections which has the closePending flag set.
 435     HashSet&lt;uint64_t&gt; connectionIdentifiers;
 436     for (const auto&amp; connection : m_openDatabaseConnections) {
 437         if (connection-&gt;closePending())
 438             continue;
 439 
 440         connection-&gt;fireVersionChangeEvent(requestIdentifier, newVersion);
 441         connectionIdentifiers.add(connection-&gt;identifier());
 442     }
 443 
 444     if (!connectionIdentifiers.isEmpty())
 445         m_currentOpenDBRequest-&gt;notifiedConnectionsOfVersionChange(WTFMove(connectionIdentifiers));
 446     else
 447         m_currentOpenDBRequest-&gt;maybeNotifyRequestBlocked(m_databaseInfo-&gt;version());
 448 }
 449 
 450 void UniqueIDBDatabase::notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(uint64_t connectionIdentifier)
 451 {
 452     LOG(IndexedDB, &quot;UniqueIDBDatabase::notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent - %&quot; PRIu64, connectionIdentifier);
 453 
 454     ASSERT(m_currentOpenDBRequest);
 455 
 456     m_currentOpenDBRequest-&gt;connectionClosedOrFiredVersionChangeEvent(connectionIdentifier);
 457 
 458     if (m_currentOpenDBRequest-&gt;hasConnectionsPendingVersionChangeEvent())
 459         return;
 460 
 461     if (!hasAnyOpenConnections() || allConnectionsAreClosedOrClosing()) {
<a name="53" id="anc53"></a><span class="line-modified"> 462         handleDatabaseOperations();</span>
 463         return;
 464     }
 465 
 466     // Since all open connections have fired their version change events but not all of them have closed,
 467     // this request is officially blocked.
 468     m_currentOpenDBRequest-&gt;maybeNotifyRequestBlocked(m_databaseInfo-&gt;version());
 469 }
 470 
<a name="54" id="anc54"></a><span class="line-modified"> 471 void UniqueIDBDatabase::clearTransactionsOnConnection(UniqueIDBDatabaseConnection&amp; connection)</span>
<span class="line-added"> 472 {</span>
<span class="line-added"> 473     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; pendingTransactions;</span>
<span class="line-added"> 474     while (!m_pendingTransactions.isEmpty()) {</span>
<span class="line-added"> 475         auto transaction = m_pendingTransactions.takeFirst();</span>
<span class="line-added"> 476         if (&amp;transaction-&gt;databaseConnection() != &amp;connection)</span>
<span class="line-added"> 477             pendingTransactions.append(WTFMove(transaction));</span>
<span class="line-added"> 478         else</span>
<span class="line-added"> 479             connection.deleteTransaction(*transaction);</span>
<span class="line-added"> 480     }</span>
<span class="line-added"> 481     if (!pendingTransactions.isEmpty())</span>
<span class="line-added"> 482         m_pendingTransactions.swap(pendingTransactions);</span>
<span class="line-added"> 483 </span>
<span class="line-added"> 484     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; transactionsToAbort;</span>
<span class="line-added"> 485     for (auto&amp; transaction : m_inProgressTransactions.values()) {</span>
<span class="line-added"> 486         if (&amp;transaction-&gt;databaseConnection() == &amp;connection)</span>
<span class="line-added"> 487             transactionsToAbort.append(transaction);</span>
<span class="line-added"> 488     }</span>
<span class="line-added"> 489     for (auto&amp; transaction : transactionsToAbort)</span>
<span class="line-added"> 490         transaction-&gt;abortWithoutCallback();</span>
<span class="line-added"> 491 }</span>
<span class="line-added"> 492 </span>
<span class="line-added"> 493 void UniqueIDBDatabase::didFireVersionChangeEvent(UniqueIDBDatabaseConnection&amp; connection, const IDBResourceIdentifier&amp; requestIdentifier, IndexedDB::ConnectionClosedOnBehalfOfServer connectionClosedOnBehalfOfServer)</span>
 494 {
 495     LOG(IndexedDB, &quot;UniqueIDBDatabase::didFireVersionChangeEvent&quot;);
 496 
 497     if (!m_currentOpenDBRequest)
 498         return;
 499 
 500     ASSERT_UNUSED(requestIdentifier, m_currentOpenDBRequest-&gt;requestData().requestIdentifier() == requestIdentifier);
 501 
<a name="55" id="anc55"></a><span class="line-added"> 502     if (connectionClosedOnBehalfOfServer == IndexedDB::ConnectionClosedOnBehalfOfServer::Yes) {</span>
<span class="line-added"> 503         if (m_openDatabaseConnections.contains(&amp;connection)) {</span>
<span class="line-added"> 504             clearTransactionsOnConnection(connection);</span>
<span class="line-added"> 505             m_openDatabaseConnections.remove(&amp;connection);</span>
<span class="line-added"> 506         }</span>
<span class="line-added"> 507     }</span>
<span class="line-added"> 508 </span>
 509     notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(connection.identifier());
 510 }
 511 
 512 void UniqueIDBDatabase::openDBRequestCancelled(const IDBResourceIdentifier&amp; requestIdentifier)
 513 {
 514     LOG(IndexedDB, &quot;UniqueIDBDatabase::openDBRequestCancelled - %s&quot;, requestIdentifier.loggingString().utf8().data());
 515 
 516     if (m_currentOpenDBRequest &amp;&amp; m_currentOpenDBRequest-&gt;requestData().requestIdentifier() == requestIdentifier)
 517         m_currentOpenDBRequest = nullptr;
 518 
 519     if (m_versionChangeDatabaseConnection &amp;&amp; m_versionChangeDatabaseConnection-&gt;openRequestIdentifier() == requestIdentifier) {
 520         ASSERT(!m_versionChangeTransaction || m_versionChangeTransaction-&gt;databaseConnection().openRequestIdentifier() == requestIdentifier);
 521         ASSERT(!m_versionChangeTransaction || &amp;m_versionChangeTransaction-&gt;databaseConnection() == m_versionChangeDatabaseConnection);
 522 
 523         connectionClosedFromClient(*m_versionChangeDatabaseConnection);
 524     }
 525 
 526     for (auto&amp; request : m_pendingOpenDBRequests) {
 527         if (request-&gt;requestData().requestIdentifier() == requestIdentifier) {
 528             m_pendingOpenDBRequests.remove(request);
 529             return;
 530         }
 531     }
 532 }
 533 
 534 void UniqueIDBDatabase::addOpenDatabaseConnection(Ref&lt;UniqueIDBDatabaseConnection&gt;&amp;&amp; connection)
 535 {
 536     ASSERT(!m_openDatabaseConnections.contains(&amp;connection.get()));
 537     m_openDatabaseConnections.add(adoptRef(connection.leakRef()));
 538 }
 539 
<a name="56" id="anc56"></a><span class="line-modified"> 540 void UniqueIDBDatabase::createObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const IDBObjectStoreInfo&amp; info, ErrorCallback callback)</span>
 541 {
 542     ASSERT(!isMainThread());
<a name="57" id="anc57"></a><span class="line-modified"> 543     LOG(IndexedDB, &quot;UniqueIDBDatabase::createObjectStore&quot;);</span>
 544 
<a name="58" id="anc58"></a><span class="line-modified"> 545     ASSERT(m_backingStore);</span>



 546 
<a name="59" id="anc59"></a><span class="line-modified"> 547     // Quota check.</span>
<span class="line-modified"> 548     auto taskSize = defaultWriteOperationCost + estimateSize(info);</span>
<span class="line-modified"> 549     if (m_server.requestSpace(m_identifier.origin(), taskSize) == StorageQuotaManager::Decision::Deny) {</span>
<span class="line-added"> 550         callback(IDBError { QuotaExceededError, quotaErrorMessageName(&quot;CreateObjectStore&quot;) });</span>
<span class="line-added"> 551         return;</span>
<span class="line-added"> 552     }</span>
 553 
<a name="60" id="anc60"></a><span class="line-modified"> 554     auto error = m_backingStore-&gt;createObjectStore(transaction.info().identifier(), info);</span>
<span class="line-modified"> 555     if (error.isNull())</span>
<span class="line-added"> 556         m_databaseInfo-&gt;addExistingObjectStore(info);</span>
 557 
<a name="61" id="anc61"></a><span class="line-modified"> 558     callback(error);</span>
 559 }
 560 
<a name="62" id="anc62"></a><span class="line-modified"> 561 void UniqueIDBDatabase::deleteObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const String&amp; objectStoreName, ErrorCallback callback)</span>
 562 {
<a name="63" id="anc63"></a><span class="line-modified"> 563     ASSERT(!isMainThread());</span>
<span class="line-modified"> 564     LOG(IndexedDB, &quot;UniqueIDBDatabase::deleteObjectStore&quot;);</span>








 565 
<a name="64" id="anc64"></a><span class="line-modified"> 566     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreName);</span>
<span class="line-added"> 567     if (!info) {</span>
<span class="line-added"> 568         callback(IDBError { UnknownError, &quot;Attempt to delete non-existant object store&quot;_s });</span>
 569         return;
<a name="65" id="anc65"></a><span class="line-added"> 570     }</span>
 571 
<a name="66" id="anc66"></a><span class="line-modified"> 572     ASSERT(m_backingStore);</span>
<span class="line-added"> 573     auto error = m_backingStore-&gt;deleteObjectStore(transaction.info().identifier(), info-&gt;identifier());</span>
<span class="line-added"> 574     if (error.isNull())</span>
<span class="line-added"> 575         m_databaseInfo-&gt;deleteObjectStore(info-&gt;identifier());</span>
<span class="line-added"> 576 </span>
<span class="line-added"> 577     callback(error);</span>
 578 }
 579 
<a name="67" id="anc67"></a><span class="line-modified"> 580 void UniqueIDBDatabase::renameObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; newName, ErrorCallback callback)</span>
 581 {
<a name="68" id="anc68"></a><span class="line-modified"> 582     ASSERT(!isMainThread());</span>
<span class="line-modified"> 583     LOG(IndexedDB, &quot;UniqueIDBDatabase::renameObjectStore&quot;);</span>
 584 
<a name="69" id="anc69"></a><span class="line-modified"> 585     // Quota check.</span>
<span class="line-modified"> 586     auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();</span>
<span class="line-modified"> 587     if (m_server.requestSpace(m_identifier.origin(), taskSize) == StorageQuotaManager::Decision::Deny) {</span>
<span class="line-modified"> 588         callback(IDBError(QuotaExceededError, quotaErrorMessageName(&quot;RenameObjectStore&quot;)));</span>
<span class="line-modified"> 589         return;</span>
<span class="line-modified"> 590     }</span>







 591 
<a name="70" id="anc70"></a><span class="line-modified"> 592     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);</span>
<span class="line-modified"> 593     if (!info) {</span>
<span class="line-modified"> 594         callback(IDBError { UnknownError, &quot;Attempt to rename non-existant object store&quot;_s });</span>

 595         return;
<a name="71" id="anc71"></a><span class="line-added"> 596     }</span>
<span class="line-added"> 597 </span>
<span class="line-added"> 598     ASSERT(m_backingStore);</span>
<span class="line-added"> 599     auto error = m_backingStore-&gt;renameObjectStore(transaction.info().identifier(), objectStoreIdentifier, newName);</span>
<span class="line-added"> 600     if (error.isNull())</span>
<span class="line-added"> 601         m_databaseInfo-&gt;renameObjectStore(objectStoreIdentifier, newName);</span>
 602 
<a name="72" id="anc72"></a><span class="line-modified"> 603     callback(error);</span>
 604 }
 605 
<a name="73" id="anc73"></a><span class="line-modified"> 606 void UniqueIDBDatabase::clearObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, ErrorCallback callback)</span>
 607 {
 608     ASSERT(!isMainThread());
<a name="74" id="anc74"></a><span class="line-modified"> 609     LOG(IndexedDB, &quot;UniqueIDBDatabase::clearObjectStore&quot;);</span>
 610 
 611     ASSERT(m_backingStore);
<a name="75" id="anc75"></a><span class="line-modified"> 612     auto error = m_backingStore-&gt;clearObjectStore(transaction.info().identifier(), objectStoreIdentifier);</span>
 613 
<a name="76" id="anc76"></a><span class="line-modified"> 614     callback(error);</span>

 615 }
 616 
<a name="77" id="anc77"></a><span class="line-modified"> 617 void UniqueIDBDatabase::createIndex(UniqueIDBDatabaseTransaction&amp; transaction, const IDBIndexInfo&amp; info, ErrorCallback callback)</span>
 618 {
<a name="78" id="anc78"></a><span class="line-modified"> 619     ASSERT(!isMainThread());</span>
<span class="line-modified"> 620     LOG(IndexedDB, &quot;UniqueIDBDatabase::createIndex&quot;);</span>
 621 
<a name="79" id="anc79"></a><span class="line-modified"> 622     // Quota check.</span>
<span class="line-modified"> 623     auto taskSize = defaultWriteOperationCost + estimateSize(info);</span>
<span class="line-added"> 624     if (m_server.requestSpace(m_identifier.origin(), taskSize) == StorageQuotaManager::Decision::Deny) {</span>
<span class="line-added"> 625         callback(IDBError { QuotaExceededError, quotaErrorMessageName(&quot;CreateIndex&quot;) });</span>
<span class="line-added"> 626         return;</span>
<span class="line-added"> 627     }</span>
<span class="line-added"> 628 </span>
<span class="line-added"> 629     ASSERT(m_backingStore);</span>
<span class="line-added"> 630     auto error = m_backingStore-&gt;createIndex(transaction.info().identifier(), info);</span>
<span class="line-added"> 631     if (error.isNull()) {</span>
<span class="line-added"> 632         ASSERT(m_databaseInfo);</span>
<span class="line-added"> 633         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());</span>
<span class="line-added"> 634         ASSERT(objectStoreInfo);</span>
<span class="line-added"> 635         objectStoreInfo-&gt;addExistingIndex(info);</span>
<span class="line-added"> 636         m_databaseInfo-&gt;setMaxIndexID(info.identifier());</span>
<span class="line-added"> 637     }</span>
 638 
<a name="80" id="anc80"></a><span class="line-modified"> 639     callback(error);</span>
 640 }
 641 
<a name="81" id="anc81"></a><span class="line-modified"> 642 void UniqueIDBDatabase::deleteIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; indexName, ErrorCallback callback)</span>
 643 {
<a name="82" id="anc82"></a><span class="line-modified"> 644     ASSERT(!isMainThread());</span>
<span class="line-modified"> 645     LOG(IndexedDB, &quot;UniqueIDBDatabase::deleteIndex&quot;);</span>














































































































































































































































 646 
 647     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
 648     if (!objectStoreInfo) {
<a name="83" id="anc83"></a><span class="line-modified"> 649         callback(IDBError { UnknownError, &quot;Attempt to delete index from non-existant object store&quot;_s });</span>
 650         return;
 651     }
 652 
 653     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexName);
 654     if (!indexInfo) {
<a name="84" id="anc84"></a><span class="line-modified"> 655         callback(IDBError { UnknownError, &quot;Attempt to delete non-existant index&quot;_s });</span>
 656         return;
 657     }
<a name="85" id="anc85"></a><span class="line-modified"> 658     auto indexIdentifier = indexInfo-&gt;identifier();</span>







 659 
 660     ASSERT(m_backingStore);
<a name="86" id="anc86"></a><span class="line-modified"> 661     auto error = m_backingStore-&gt;deleteIndex(transaction.info().identifier(), objectStoreIdentifier, indexIdentifier);</span>
<span class="line-modified"> 662     if (error.isNull())</span>
<span class="line-modified"> 663         objectStoreInfo-&gt;deleteIndex(indexIdentifier);</span>













 664 
<a name="87" id="anc87"></a><span class="line-modified"> 665     callback(error);</span>
 666 }
 667 
 668 void UniqueIDBDatabase::renameIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName, ErrorCallback callback)
 669 {
<a name="88" id="anc88"></a><span class="line-modified"> 670     ASSERT(!isMainThread());</span>
<span class="line-modified"> 671     LOG(IndexedDB, &quot;UniqueIDBDatabase::renameIndex&quot;);</span>
 672 
<a name="89" id="anc89"></a><span class="line-added"> 673     // Quota check.</span>
 674     auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();
<a name="90" id="anc90"></a><span class="line-modified"> 675     if (m_server.requestSpace(m_identifier.origin(), taskSize) == StorageQuotaManager::Decision::Deny) {</span>
<span class="line-modified"> 676         callback(IDBError { QuotaExceededError, quotaErrorMessageName(&quot;RenameIndex&quot;) });</span>















 677         return;
<a name="91" id="anc91"></a><span class="line-added"> 678     }</span>
 679 
 680     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
 681     if (!objectStoreInfo) {
<a name="92" id="anc92"></a><span class="line-modified"> 682         callback(IDBError { UnknownError, &quot;Attempt to rename index in non-existant object store&quot;_s });</span>
 683         return;
 684     }
 685 
 686     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
 687     if (!indexInfo) {
<a name="93" id="anc93"></a><span class="line-modified"> 688         callback(IDBError { UnknownError, &quot;Attempt to rename non-existant index&quot;_s });</span>
 689         return;
 690     }
 691 
<a name="94" id="anc94"></a>







 692     ASSERT(m_backingStore);
<a name="95" id="anc95"></a><span class="line-modified"> 693     auto error = m_backingStore-&gt;renameIndex(transaction.info().identifier(), objectStoreIdentifier, indexIdentifier, newName);</span>
<span class="line-modified"> 694     if (error.isNull())</span>
<span class="line-modified"> 695         indexInfo-&gt;rename(newName);</span>

















 696 
<a name="96" id="anc96"></a><span class="line-modified"> 697     callback(error);</span>
 698 }
 699 
 700 void UniqueIDBDatabase::putOrAdd(const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode, KeyDataCallback callback)
<a name="97" id="anc97"></a>






















 701 {
 702     ASSERT(!isMainThread());
<a name="98" id="anc98"></a><span class="line-modified"> 703     LOG(IndexedDB, &quot;UniqueIDBDatabase::putOrAdd&quot;);</span>
 704 
<a name="99" id="anc99"></a><span class="line-modified"> 705     ASSERT(m_databaseInfo);</span>

 706 
 707     IDBKeyData usedKey;
 708     IDBError error;
 709 
<a name="100" id="anc100"></a><span class="line-modified"> 710     ASSERT(m_backingStore);</span>
<span class="line-modified"> 711     auto objectStoreIdentifier = requestData.objectStoreIdentifier();</span>
<span class="line-modified"> 712     auto* objectStoreInfo = m_backingStore-&gt;infoForObjectStore(objectStoreIdentifier);</span>
<span class="line-modified"> 713     if (!objectStoreInfo) {</span>
<span class="line-added"> 714         callback(IDBError { InvalidStateError, &quot;Object store cannot be found in the backing store&quot;_s }, usedKey);</span>
 715         return;
 716     }
 717 
<a name="101" id="anc101"></a><span class="line-modified"> 718     // Quota check.</span>
<span class="line-modified"> 719     auto taskSize = defaultWriteOperationCost + estimateSize(keyData) + estimateSize(value);</span>
<span class="line-modified"> 720     auto* objectStore = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);</span>
<span class="line-modified"> 721     if (objectStore)</span>
<span class="line-added"> 722         taskSize += objectStore-&gt;indexNames().size() * taskSize;</span>
<span class="line-added"> 723     if (m_server.requestSpace(m_identifier.origin(), taskSize) == StorageQuotaManager::Decision::Deny) {</span>
<span class="line-added"> 724         callback(IDBError { QuotaExceededError, quotaErrorMessageName(&quot;PutOrAdd&quot;) }, usedKey);</span>
 725         return;
 726     }
 727 
 728     bool usedKeyIsGenerated = false;
 729     uint64_t keyNumber;
<a name="102" id="anc102"></a><span class="line-added"> 730     auto transactionIdentifier = requestData.transactionIdentifier();</span>
 731     auto generatedKeyResetter = WTF::makeScopeExit([this, transactionIdentifier, objectStoreIdentifier, &amp;keyNumber, &amp;usedKeyIsGenerated]() {
 732         if (usedKeyIsGenerated)
 733             m_backingStore-&gt;revertGeneratedKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
 734     });
<a name="103" id="anc103"></a><span class="line-added"> 735 </span>
 736     if (objectStoreInfo-&gt;autoIncrement() &amp;&amp; !keyData.isValid()) {
 737         error = m_backingStore-&gt;generateKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
 738         if (!error.isNull()) {
<a name="104" id="anc104"></a><span class="line-modified"> 739             callback(error, usedKey);</span>
 740             return;
 741         }
<a name="105" id="anc105"></a>
 742         usedKey.setNumberValue(keyNumber);
 743         usedKeyIsGenerated = true;
 744     } else
 745         usedKey = keyData;
 746 
 747     if (overwriteMode == IndexedDB::ObjectStoreOverwriteMode::NoOverwrite) {
 748         bool keyExists;
 749         error = m_backingStore-&gt;keyExistsInObjectStore(transactionIdentifier, objectStoreIdentifier, usedKey, keyExists);
 750         if (error.isNull() &amp;&amp; keyExists)
<a name="106" id="anc106"></a><span class="line-modified"> 751             error = IDBError { ConstraintError, &quot;Key already exists in the object store&quot;_s };</span>
 752 
 753         if (!error.isNull()) {
<a name="107" id="anc107"></a><span class="line-modified"> 754             callback(error, usedKey);</span>
 755             return;
 756         }
 757     }
<a name="108" id="anc108"></a><span class="line-modified"> 758     // If a record already exists in store, then remove the record from store using the steps for deleting records from an object store.</span>



 759     // This is important because formally deleting it from from the object store also removes it from the appropriate indexes.
 760     error = m_backingStore-&gt;deleteRange(transactionIdentifier, objectStoreIdentifier, usedKey);
 761     if (!error.isNull()) {
<a name="109" id="anc109"></a><span class="line-modified"> 762         callback(error, usedKey);</span>
 763         return;
 764     }
 765 
<a name="110" id="anc110"></a><span class="line-modified"> 766     error = m_backingStore-&gt;addRecord(transactionIdentifier, *objectStoreInfo, usedKey, value);</span>

 767     if (!error.isNull()) {
<a name="111" id="anc111"></a><span class="line-modified"> 768         callback(error, usedKey);</span>
 769         return;
 770     }
 771 
 772     if (overwriteMode != IndexedDB::ObjectStoreOverwriteMode::OverwriteForCursor &amp;&amp; objectStoreInfo-&gt;autoIncrement() &amp;&amp; keyData.type() == IndexedDB::KeyType::Number)
 773         error = m_backingStore-&gt;maybeUpdateKeyGeneratorNumber(transactionIdentifier, objectStoreIdentifier, keyData.number());
 774 
 775     generatedKeyResetter.release();
<a name="112" id="anc112"></a><span class="line-modified"> 776     callback(error, usedKey);</span>








 777 }
 778 
 779 void UniqueIDBDatabase::getRecord(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData, GetResultCallback callback)
<a name="113" id="anc113"></a>
















































 780 {
 781     ASSERT(!isMainThread());
<a name="114" id="anc114"></a><span class="line-modified"> 782     LOG(IndexedDB, &quot;UniqueIDBDatabase::getRecord&quot;);</span>


 783 
 784     IDBGetResult result;
<a name="115" id="anc115"></a><span class="line-modified"> 785     IDBError error;</span>








 786 
 787     ASSERT(m_backingStore);
<a name="116" id="anc116"></a><span class="line-added"> 788     if (uint64_t indexIdentifier = requestData.indexIdentifier())</span>
<span class="line-added"> 789         error = m_backingStore-&gt;getIndexRecord(requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), indexIdentifier, requestData.indexRecordType(), getRecordData.keyRangeData, result);</span>
<span class="line-added"> 790     else</span>
<span class="line-added"> 791         error = m_backingStore-&gt;getRecord(requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), getRecordData.keyRangeData, getRecordData.type, result);</span>
 792 
<a name="117" id="anc117"></a><span class="line-modified"> 793     callback(error, result);</span>











 794 }
 795 
<a name="118" id="anc118"></a><span class="line-modified"> 796 void UniqueIDBDatabase::getAllRecords(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData, GetAllResultsCallback callback)</span>
 797 {
 798     ASSERT(!isMainThread());
<a name="119" id="anc119"></a><span class="line-modified"> 799     LOG(IndexedDB, &quot;UniqueIDBDatabase::getAllRecords&quot;);</span>
 800 
 801     ASSERT(m_backingStore);
<a name="120" id="anc120"></a>
 802     IDBGetAllResult result;
<a name="121" id="anc121"></a><span class="line-modified"> 803     auto error = m_backingStore-&gt;getAllRecords(requestData.transactionIdentifier(), getAllRecordsData, result);</span>























































 804 
<a name="122" id="anc122"></a><span class="line-modified"> 805     callback(error, result);</span>










































































































































































 806 }
 807 
<a name="123" id="anc123"></a><span class="line-modified"> 808 void UniqueIDBDatabase::getCount(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; range, CountCallback callback)</span>
 809 {
<a name="124" id="anc124"></a><span class="line-modified"> 810     ASSERT(!isMainThread());</span>
<span class="line-modified"> 811     LOG(IndexedDB, &quot;UniqueIDBDatabase::getCount&quot;);</span>








 812 
<a name="125" id="anc125"></a><span class="line-modified"> 813     ASSERT(m_backingStore);</span>
<span class="line-modified"> 814     uint64_t count = 0;</span>
<span class="line-modified"> 815     auto error = m_backingStore-&gt;getCount(requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), requestData.indexIdentifier(), range, count);</span>
 816 
<a name="126" id="anc126"></a><span class="line-modified"> 817     callback(error, count);</span>
 818 }
 819 
<a name="127" id="anc127"></a><span class="line-modified"> 820 void UniqueIDBDatabase::deleteRecord(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData, ErrorCallback callback)</span>
 821 {
 822     ASSERT(!isMainThread());
<a name="128" id="anc128"></a><span class="line-modified"> 823     LOG(IndexedDB, &quot;UniqueIDBDatabase::deleteRecord&quot;);</span>
<span class="line-added"> 824 </span>
<span class="line-added"> 825     ASSERT(m_backingStore);</span>
<span class="line-added"> 826     auto error = m_backingStore-&gt;deleteRange(requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyRangeData);</span>
 827 
<a name="129" id="anc129"></a><span class="line-modified"> 828     callback(error);</span>

 829 }
 830 
<a name="130" id="anc130"></a><span class="line-modified"> 831 void UniqueIDBDatabase::openCursor(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info, GetResultCallback callback)</span>
 832 {
<a name="131" id="anc131"></a><span class="line-modified"> 833     ASSERT(!isMainThread());</span>
<span class="line-modified"> 834     LOG(IndexedDB, &quot;UniqueIDBDatabase::openCursor&quot;);</span>
 835 
<a name="132" id="anc132"></a><span class="line-modified"> 836     ASSERT(m_backingStore);</span>














 837 
<a name="133" id="anc133"></a><span class="line-modified"> 838     IDBGetResult result;</span>
<span class="line-added"> 839     auto error = m_backingStore-&gt;openCursor(requestData.transactionIdentifier(), info, result);</span>
 840 
<a name="134" id="anc134"></a><span class="line-modified"> 841     callback(error, result);</span>
 842 }
 843 
<a name="135" id="anc135"></a><span class="line-modified"> 844 void UniqueIDBDatabase::iterateCursor(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data, GetResultCallback callback)</span>
 845 {
<a name="136" id="anc136"></a><span class="line-modified"> 846     ASSERT(!isMainThread());</span>
<span class="line-modified"> 847     LOG(IndexedDB, &quot;UniqueIDBDatabase::iterateCursor&quot;);</span>





















 848 
<a name="137" id="anc137"></a><span class="line-modified"> 849     ASSERT(m_backingStore);</span>





 850 
<a name="138" id="anc138"></a><span class="line-modified"> 851     IDBGetResult result;</span>
<span class="line-modified"> 852     auto transactionIdentifier = requestData.transactionIdentifier();</span>
<span class="line-modified"> 853     auto cursorIdentifier = requestData.cursorIdentifier();</span>
<span class="line-added"> 854     auto error = m_backingStore-&gt;iterateCursor(transactionIdentifier, cursorIdentifier, data, result);</span>
 855 
<a name="139" id="anc139"></a><span class="line-modified"> 856     callback(error, result);</span>
 857 }
 858 
<a name="140" id="anc140"></a><span class="line-modified"> 859 void UniqueIDBDatabase::commitTransaction(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)</span>
 860 {
<a name="141" id="anc141"></a><span class="line-modified"> 861     ASSERT(!isMainThread());</span>
<span class="line-modified"> 862     LOG(IndexedDB, &quot;UniqueIDBDatabase::commitTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());</span>



 863 
<a name="142" id="anc142"></a><span class="line-modified"> 864     ASSERT(transaction.databaseConnection().database() == this);</span>
<span class="line-modified"> 865     ASSERT(m_backingStore);</span>
<span class="line-added"> 866     auto takenTransaction = m_inProgressTransactions.take(transaction.info().identifier());</span>
<span class="line-added"> 867     if (!takenTransaction) {</span>
<span class="line-added"> 868         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection()))</span>
<span class="line-added"> 869             return;</span>
 870 
<a name="143" id="anc143"></a><span class="line-modified"> 871         callback(IDBError { UnknownError, &quot;Attempt to commit transaction that is not running&quot;_s });</span>

 872         return;
 873     }
 874 
<a name="144" id="anc144"></a><span class="line-modified"> 875     auto error = m_backingStore-&gt;commitTransaction(transaction.info().identifier());</span>
<span class="line-added"> 876 </span>
<span class="line-added"> 877     callback(error);</span>
<span class="line-added"> 878     transactionCompleted(WTFMove(takenTransaction));</span>
 879 }
 880 
<a name="145" id="anc145"></a><span class="line-modified"> 881 void UniqueIDBDatabase::abortTransaction(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)</span>
 882 {
 883     ASSERT(!isMainThread());
<a name="146" id="anc146"></a><span class="line-modified"> 884     LOG(IndexedDB, &quot;UniqueIDBDatabase::abortTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());</span>
 885 
<a name="147" id="anc147"></a><span class="line-modified"> 886     ASSERT(transaction.databaseConnection().database() == this);</span>


 887 
<a name="148" id="anc148"></a><span class="line-modified"> 888     auto takenTransaction = m_inProgressTransactions.take(transaction.info().identifier());</span>
<span class="line-modified"> 889     if (!takenTransaction) {</span>
<span class="line-modified"> 890         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection()))</span>
<span class="line-modified"> 891             return;</span>
 892 
<a name="149" id="anc149"></a><span class="line-modified"> 893         callback(IDBError { UnknownError, &quot;Attempt to abort transaction that is not running&quot;_s });</span>
<span class="line-modified"> 894         return;</span>
<span class="line-added"> 895     }</span>
<span class="line-added"> 896 </span>
<span class="line-added"> 897     // If transaction is already aborted on the main thread for suspension,</span>
<span class="line-added"> 898     // return the result of that abort.</span>
<span class="line-added"> 899     if (auto existingAbortResult = takenTransaction-&gt;mainThreadAbortResult()) {</span>
<span class="line-added"> 900         callback(*existingAbortResult);</span>
<span class="line-added"> 901         transactionCompleted(WTFMove(takenTransaction));</span>
<span class="line-added"> 902         return;</span>
<span class="line-added"> 903     }</span>
 904 
<a name="150" id="anc150"></a><span class="line-added"> 905     auto transactionIdentifier = transaction.info().identifier();</span>
 906     if (m_versionChangeTransaction &amp;&amp; m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier) {
<a name="151" id="anc151"></a><span class="line-modified"> 907         ASSERT(m_versionChangeTransaction == &amp;transaction);</span>
 908         ASSERT(!m_versionChangeDatabaseConnection || &amp;m_versionChangeTransaction-&gt;databaseConnection() == m_versionChangeDatabaseConnection);
 909         ASSERT(m_versionChangeTransaction-&gt;originalDatabaseInfo());
 910         m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(*m_versionChangeTransaction-&gt;originalDatabaseInfo());
 911     }
 912 
<a name="152" id="anc152"></a><span class="line-modified"> 913     auto error = m_backingStore-&gt;abortTransaction(transactionIdentifier);</span>

 914 
<a name="153" id="anc153"></a><span class="line-modified"> 915     callback(error);</span>
<span class="line-added"> 916     transactionCompleted(WTFMove(takenTransaction));</span>
 917 }
 918 
<a name="154" id="anc154"></a><span class="line-modified"> 919 void UniqueIDBDatabase::didFinishHandlingVersionChange(UniqueIDBDatabaseConnection&amp; connection, const IDBResourceIdentifier&amp; transactionIdentifier)</span>
 920 {
<a name="155" id="anc155"></a><span class="line-modified"> 921     ASSERT(!isMainThread());</span>
<span class="line-modified"> 922     LOG(IndexedDB, &quot;UniqueIDBDatabase::didFinishHandlingVersionChange&quot;);</span>
<span class="line-added"> 923 </span>
<span class="line-added"> 924     ASSERT_UNUSED(transactionIdentifier, !m_versionChangeTransaction || m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier);</span>
<span class="line-added"> 925     ASSERT_UNUSED(connection, !m_versionChangeDatabaseConnection || m_versionChangeDatabaseConnection.get() == &amp;connection);</span>
<span class="line-added"> 926 </span>
<span class="line-added"> 927     m_versionChangeTransaction = nullptr;</span>
<span class="line-added"> 928     m_versionChangeDatabaseConnection = nullptr;</span>
<span class="line-added"> 929 </span>
<span class="line-added"> 930     handleDatabaseOperations();</span>
<span class="line-added"> 931     handleTransactions();</span>
 932 }
 933 
 934 void UniqueIDBDatabase::connectionClosedFromClient(UniqueIDBDatabaseConnection&amp; connection)
 935 {
<a name="156" id="anc156"></a><span class="line-modified"> 936     ASSERT(!isMainThread());</span>
<span class="line-modified"> 937     LOG(IndexedDB, &quot;UniqueIDBDatabase::connectionClosedFromClient - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());</span>







 938 
 939     Ref&lt;UniqueIDBDatabaseConnection&gt; protectedConnection(connection);
 940     m_openDatabaseConnections.remove(&amp;connection);
 941 
 942     if (m_versionChangeDatabaseConnection == &amp;connection) {
<a name="157" id="anc157"></a><span class="line-added"> 943         m_versionChangeDatabaseConnection = nullptr;</span>
 944         if (m_versionChangeTransaction) {
<a name="158" id="anc158"></a><span class="line-modified"> 945             connection.abortTransactionWithoutCallback(*m_versionChangeTransaction);</span>
<span class="line-added"> 946             ASSERT(!connection.hasNonFinishedTransactions());</span>
 947 
<a name="159" id="anc159"></a><span class="line-modified"> 948             // Previous blocked operations or transactions may be runnable.</span>
<span class="line-modified"> 949             handleDatabaseOperations();</span>
<span class="line-modified"> 950             handleTransactions();</span>


 951 
 952             return;
 953         }
<a name="160" id="anc160"></a>

















 954     }
 955 
<a name="161" id="anc161"></a><span class="line-modified"> 956     // Remove all pending transactions on the connection.</span>
<span class="line-modified"> 957     clearTransactionsOnConnection(connection);</span>
 958 
 959     if (m_currentOpenDBRequest)
 960         notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(connection.identifier());
 961 
<a name="162" id="anc162"></a><span class="line-modified"> 962     ASSERT(!connection.hasNonFinishedTransactions());</span>








 963 
 964     // Now that a database connection has closed, previously blocked operations might be runnable.
<a name="163" id="anc163"></a><span class="line-modified"> 965     handleDatabaseOperations();</span>
<span class="line-added"> 966     handleTransactions();</span>
 967 }
 968 
 969 void UniqueIDBDatabase::connectionClosedFromServer(UniqueIDBDatabaseConnection&amp; connection)
 970 {
<a name="164" id="anc164"></a><span class="line-modified"> 971     ASSERT(!isMainThread());</span>
 972     LOG(IndexedDB, &quot;UniqueIDBDatabase::connectionClosedFromServer - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
 973 
<a name="165" id="anc165"></a>








 974     connection.connectionToClient().didCloseFromServer(connection, IDBError::userDeleteError());
 975 
<a name="166" id="anc166"></a><span class="line-modified"> 976     m_openDatabaseConnections.remove(&amp;connection);</span>













 977 }
 978 
 979 void UniqueIDBDatabase::enqueueTransaction(Ref&lt;UniqueIDBDatabaseTransaction&gt;&amp;&amp; transaction)
 980 {
 981     LOG(IndexedDB, &quot;UniqueIDBDatabase::enqueueTransaction - %s&quot;, transaction-&gt;info().loggingString().utf8().data());
<a name="167" id="anc167"></a>
 982 
 983     ASSERT(transaction-&gt;info().mode() != IDBTransactionMode::Versionchange);
 984 
 985     m_pendingTransactions.append(WTFMove(transaction));
 986 
<a name="168" id="anc168"></a><span class="line-modified"> 987     handleTransactions();</span>




















 988 }
 989 
<a name="169" id="anc169"></a><span class="line-modified"> 990 void UniqueIDBDatabase::handleTransactions()</span>
 991 {
<a name="170" id="anc170"></a><span class="line-modified"> 992     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleTransactions - There are %zu pending&quot;, m_pendingTransactions.size());</span>



















 993 
 994     bool hadDeferredTransactions = false;
 995     auto transaction = takeNextRunnableTransaction(hadDeferredTransactions);
 996 
<a name="171" id="anc171"></a><span class="line-modified"> 997     while (transaction) {</span>
 998         m_inProgressTransactions.set(transaction-&gt;info().identifier(), transaction);
 999         for (auto objectStore : transaction-&gt;objectStoreIdentifiers()) {
1000             m_objectStoreTransactionCounts.add(objectStore);
1001             if (!transaction-&gt;isReadOnly()) {
1002                 m_objectStoreWriteTransactions.add(objectStore);
<a name="172" id="anc172"></a><span class="line-modified">1003                 ASSERT(m_objectStoreTransactionCounts.count(objectStore) == 1);</span>
1004             }
1005         }
1006 
1007         activateTransactionInBackingStore(*transaction);
<a name="173" id="anc173"></a><span class="line-modified">1008         if (hadDeferredTransactions)</span>
<span class="line-modified">1009             break;</span>
<span class="line-modified">1010         transaction = takeNextRunnableTransaction(hadDeferredTransactions);</span>

1011     }
<a name="174" id="anc174"></a><span class="line-added">1012     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleTransactions - There are %zu pending after this round of handling&quot;, m_pendingTransactions.size());</span>
1013 }
1014 
1015 void UniqueIDBDatabase::activateTransactionInBackingStore(UniqueIDBDatabaseTransaction&amp; transaction)
1016 {
<a name="175" id="anc175"></a><span class="line-modified">1017     LOG(IndexedDB, &quot;UniqueIDBDatabase::activateTransactionInBackingStore&quot;);</span>

























1018 
<a name="176" id="anc176"></a><span class="line-modified">1019     ASSERT(m_backingStore);</span>

1020 
<a name="177" id="anc177"></a><span class="line-modified">1021     auto error = m_backingStore-&gt;beginTransaction(transaction.info());</span>
1022 
<a name="178" id="anc178"></a><span class="line-modified">1023     transaction.didActivateInBackingStore(error);</span>
1024 }
1025 
1026 template&lt;typename T&gt; bool scopesOverlap(const T&amp; aScopes, const Vector&lt;uint64_t&gt;&amp; bScopes)
1027 {
1028     for (auto scope : bScopes) {
1029         if (aScopes.contains(scope))
1030             return true;
1031     }
1032 
1033     return false;
1034 }
1035 
1036 RefPtr&lt;UniqueIDBDatabaseTransaction&gt; UniqueIDBDatabase::takeNextRunnableTransaction(bool&amp; hadDeferredTransactions)
1037 {
1038     hadDeferredTransactions = false;
1039 
1040     if (m_pendingTransactions.isEmpty())
1041         return nullptr;
1042 
<a name="179" id="anc179"></a><span class="line-modified">1043     if (!m_backingStore-&gt;supportsSimultaneousTransactions() &amp;&amp; !m_inProgressTransactions.isEmpty()) {</span>
1044         LOG(IndexedDB, &quot;UniqueIDBDatabase::takeNextRunnableTransaction - Backing store only supports 1 transaction, and we already have 1&quot;);
1045         return nullptr;
1046     }
1047 
1048     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; deferredTransactions;
1049     RefPtr&lt;UniqueIDBDatabaseTransaction&gt; currentTransaction;
1050 
1051     HashSet&lt;uint64_t&gt; deferredReadWriteScopes;
1052 
1053     while (!m_pendingTransactions.isEmpty()) {
1054         currentTransaction = m_pendingTransactions.takeFirst();
1055 
1056         switch (currentTransaction-&gt;info().mode()) {
1057         case IDBTransactionMode::Readonly: {
1058             bool hasOverlappingScopes = scopesOverlap(deferredReadWriteScopes, currentTransaction-&gt;objectStoreIdentifiers());
1059             hasOverlappingScopes |= scopesOverlap(m_objectStoreWriteTransactions, currentTransaction-&gt;objectStoreIdentifiers());
1060 
1061             if (hasOverlappingScopes)
1062                 deferredTransactions.append(WTFMove(currentTransaction));
1063 
1064             break;
1065         }
1066         case IDBTransactionMode::Readwrite: {
1067             bool hasOverlappingScopes = scopesOverlap(m_objectStoreTransactionCounts, currentTransaction-&gt;objectStoreIdentifiers());
1068             hasOverlappingScopes |= scopesOverlap(deferredReadWriteScopes, currentTransaction-&gt;objectStoreIdentifiers());
1069 
1070             if (hasOverlappingScopes) {
1071                 for (auto objectStore : currentTransaction-&gt;objectStoreIdentifiers())
1072                     deferredReadWriteScopes.add(objectStore);
1073                 deferredTransactions.append(WTFMove(currentTransaction));
1074             }
1075 
1076             break;
1077         }
1078         case IDBTransactionMode::Versionchange:
1079             // Version change transactions should never be scheduled in the traditional manner.
1080             RELEASE_ASSERT_NOT_REACHED();
1081         }
1082 
1083         // If we didn&#39;t defer the currentTransaction above, it can be run now.
1084         if (currentTransaction)
1085             break;
1086     }
1087 
1088     hadDeferredTransactions = !deferredTransactions.isEmpty();
1089     if (!hadDeferredTransactions)
1090         return currentTransaction;
1091 
1092     // Prepend the deferred transactions back on the beginning of the deque for future scheduling passes.
1093     while (!deferredTransactions.isEmpty())
1094         m_pendingTransactions.prepend(deferredTransactions.takeLast());
1095 
1096     return currentTransaction;
1097 }
1098 
1099 void UniqueIDBDatabase::transactionCompleted(RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&amp;&amp; transaction)
1100 {
1101     ASSERT(transaction);
1102     ASSERT(!m_inProgressTransactions.contains(transaction-&gt;info().identifier()));
<a name="180" id="anc180"></a><span class="line-modified">1103     ASSERT(!isMainThread());</span>

1104 
1105     for (auto objectStore : transaction-&gt;objectStoreIdentifiers()) {
1106         if (!transaction-&gt;isReadOnly()) {
1107             m_objectStoreWriteTransactions.remove(objectStore);
<a name="181" id="anc181"></a><span class="line-modified">1108             ASSERT(m_objectStoreTransactionCounts.count(objectStore) == 1);</span>
1109         }
1110         m_objectStoreTransactionCounts.remove(objectStore);
1111     }
1112 
<a name="182" id="anc182"></a>


1113     if (m_versionChangeTransaction == transaction)
1114         m_versionChangeTransaction = nullptr;
1115 
<a name="183" id="anc183"></a>






1116     // Previously blocked operations might be runnable.
<a name="184" id="anc184"></a><span class="line-modified">1117     handleDatabaseOperations();</span>
<span class="line-modified">1118     handleTransactions();</span>






























































1119 }
1120 
1121 static void errorOpenDBRequestForUserDelete(ServerOpenDBRequest&amp; request)
1122 {
1123     auto result = IDBResultData::error(request.requestData().requestIdentifier(), IDBError::userDeleteError());
1124     if (request.isOpenRequest())
1125         request.connection().didOpenDatabase(result);
1126     else
1127         request.connection().didDeleteDatabase(result);
1128 }
1129 
1130 void UniqueIDBDatabase::immediateCloseForUserDelete()
1131 {
<a name="185" id="anc185"></a><span class="line-modified">1132     LOG(IndexedDB, &quot;UniqueIDBDatabase::immediateCloseForUserDelete&quot;);</span>


1133 
<a name="186" id="anc186"></a><span class="line-modified">1134     // Error out all transactions.</span>
<span class="line-modified">1135     // Pending transactions must be cleared before in-progress transactions,</span>
<span class="line-added">1136     // or they may get started right away after aborting in-progress transactions.</span>
<span class="line-added">1137     for (auto&amp; transaction : m_pendingTransactions)</span>
<span class="line-added">1138         transaction-&gt;databaseConnection().deleteTransaction(*transaction);</span>
<span class="line-added">1139     m_pendingTransactions.clear();</span>
1140 
<a name="187" id="anc187"></a>
1141     for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys()))
1142         m_inProgressTransactions.get(identifier)-&gt;abortWithoutCallback();
1143 
1144     ASSERT(m_inProgressTransactions.isEmpty());
1145 
<a name="188" id="anc188"></a>


1146     m_objectStoreTransactionCounts.clear();
1147     m_objectStoreWriteTransactions.clear();
1148 
<a name="189" id="anc189"></a>





















1149     // Error out all IDBOpenDBRequests
1150     if (m_currentOpenDBRequest) {
1151         errorOpenDBRequestForUserDelete(*m_currentOpenDBRequest);
1152         m_currentOpenDBRequest = nullptr;
1153     }
1154 
1155     for (auto&amp; request : m_pendingOpenDBRequests)
1156         errorOpenDBRequestForUserDelete(*request);
1157 
1158     m_pendingOpenDBRequests.clear();
1159 
1160     // Close all open connections
1161     auto openDatabaseConnections = m_openDatabaseConnections;
1162     for (auto&amp; connection : openDatabaseConnections)
1163         connectionClosedFromServer(*connection);
1164 
1165     if (m_versionChangeDatabaseConnection) {
1166         connectionClosedFromServer(*m_versionChangeDatabaseConnection);
1167         m_versionChangeDatabaseConnection = nullptr;
1168     }
1169 
<a name="190" id="anc190"></a><span class="line-modified">1170     ASSERT(!hasAnyOpenConnections());</span>











1171 
<a name="191" id="anc191"></a><span class="line-modified">1172     close();</span>



1173 }
1174 
<a name="192" id="anc192"></a><span class="line-modified">1175 void UniqueIDBDatabase::abortActiveTransactions()</span>
1176 {
1177     ASSERT(isMainThread());
<a name="193" id="anc193"></a><span class="line-added">1178     ASSERT(m_server.lock().isHeld());</span>
1179 
<a name="194" id="anc194"></a><span class="line-modified">1180     for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys())) {</span>
<span class="line-modified">1181         auto transaction = m_inProgressTransactions.get(identifier);</span>
<span class="line-modified">1182         transaction-&gt;setMainThreadAbortResult(m_backingStore-&gt;abortTransaction(transaction-&gt;info().identifier()));</span>


















































1183     }
1184 }
1185 
<a name="195" id="anc195"></a><span class="line-modified">1186 void UniqueIDBDatabase::close()</span>
1187 {
<a name="196" id="anc196"></a><span class="line-modified">1188     LOG(IndexedDB, &quot;UniqueIDBDatabase::close&quot;);</span>







1189 
<a name="197" id="anc197"></a><span class="line-modified">1190     if (m_backingStore) {</span>
<span class="line-modified">1191         m_backingStore-&gt;close();</span>
<span class="line-modified">1192         m_backingStore = nullptr;</span>





1193     }
1194 }
1195 
<a name="198" id="anc198"></a><span class="line-modified">1196 RefPtr&lt;ServerOpenDBRequest&gt; UniqueIDBDatabase::takeNextRunnableRequest(RequestType requestType)</span>










1197 {
<a name="199" id="anc199"></a><span class="line-modified">1198     // Connection of request may be closed or lost.</span>
<span class="line-modified">1199     clearStalePendingOpenDBRequests();</span>











1200 
<a name="200" id="anc200"></a><span class="line-modified">1201     if (!m_pendingOpenDBRequests.isEmpty()) {</span>
<span class="line-modified">1202         if (requestType == RequestType::Delete &amp;&amp; !m_pendingOpenDBRequests.first()-&gt;isDeleteRequest())</span>
<span class="line-modified">1203             return nullptr;</span>
<span class="line-added">1204         return m_pendingOpenDBRequests.takeFirst();</span>
1205     }
1206 
<a name="201" id="anc201"></a><span class="line-modified">1207     return nullptr;</span>

















1208 }
1209 
1210 } // namespace IDBServer
1211 } // namespace WebCore
1212 
1213 #endif // ENABLE(INDEXED_DATABASE)
<a name="202" id="anc202"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="202" type="hidden" />
</body>
</html>
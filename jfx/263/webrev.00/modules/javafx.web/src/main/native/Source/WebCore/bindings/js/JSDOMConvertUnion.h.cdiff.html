<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertUnion.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMConvertStrings.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMConvertVariadic.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertUnion.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 60,38 ***</span>
  template&lt;typename ReturnType, typename T, bool enabled&gt;
  struct ConditionalConverter;
  
  template&lt;typename ReturnType, typename T&gt;
  struct ConditionalConverter&lt;ReturnType, T, true&gt; {
<span class="line-modified">!     static Optional&lt;ReturnType&gt; convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
      {
<span class="line-modified">!         return ReturnType(Converter&lt;T&gt;::convert(state, value));</span>
      }
  };
  
  template&lt;typename ReturnType, typename T&gt;
  struct ConditionalConverter&lt;ReturnType, T, false&gt; {
<span class="line-modified">!     static Optional&lt;ReturnType&gt; convert(JSC::ExecState&amp;, JSC::JSValue)</span>
      {
          return WTF::nullopt;
      }
  };
  
  template&lt;typename ReturnType, typename T, bool enabled&gt;
  struct ConditionalSequenceConverter;
  
  template&lt;typename ReturnType, typename T&gt;
  struct ConditionalSequenceConverter&lt;ReturnType, T, true&gt; {
<span class="line-modified">!     static Optional&lt;ReturnType&gt; convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
      {
<span class="line-modified">!         return ReturnType(Converter&lt;T&gt;::convert(state, object, method));</span>
      }
  };
  
  template&lt;typename ReturnType, typename T&gt;
  struct ConditionalSequenceConverter&lt;ReturnType, T, false&gt; {
<span class="line-modified">!     static Optional&lt;ReturnType&gt; convert(JSC::ExecState&amp;, JSC::JSObject*, JSC::JSValue)</span>
      {
          return WTF::nullopt;
      }
  };
  
<span class="line-new-header">--- 60,38 ---</span>
  template&lt;typename ReturnType, typename T, bool enabled&gt;
  struct ConditionalConverter;
  
  template&lt;typename ReturnType, typename T&gt;
  struct ConditionalConverter&lt;ReturnType, T, true&gt; {
<span class="line-modified">!     static Optional&lt;ReturnType&gt; convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
      {
<span class="line-modified">!         return ReturnType(Converter&lt;T&gt;::convert(lexicalGlobalObject, value));</span>
      }
  };
  
  template&lt;typename ReturnType, typename T&gt;
  struct ConditionalConverter&lt;ReturnType, T, false&gt; {
<span class="line-modified">!     static Optional&lt;ReturnType&gt; convert(JSC::JSGlobalObject&amp;, JSC::JSValue)</span>
      {
          return WTF::nullopt;
      }
  };
  
  template&lt;typename ReturnType, typename T, bool enabled&gt;
  struct ConditionalSequenceConverter;
  
  template&lt;typename ReturnType, typename T&gt;
  struct ConditionalSequenceConverter&lt;ReturnType, T, true&gt; {
<span class="line-modified">!     static Optional&lt;ReturnType&gt; convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject* object, JSC::JSValue method)</span>
      {
<span class="line-modified">!         return ReturnType(Converter&lt;T&gt;::convert(lexicalGlobalObject, object, method));</span>
      }
  };
  
  template&lt;typename ReturnType, typename T&gt;
  struct ConditionalSequenceConverter&lt;ReturnType, T, false&gt; {
<span class="line-modified">!     static Optional&lt;ReturnType&gt; convert(JSC::JSGlobalObject&amp;, JSC::JSObject*, JSC::JSValue)</span>
      {
          return WTF::nullopt;
      }
  };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 161,30 ***</span>
      static constexpr bool hasAnyObjectType = (numberOfSequenceTypes + numberOfFrozenArrayTypes + numberOfDictionaryTypes + numberOfRecordTypes + numberOfObjectTypes) &gt; 0;
  
      using InterfaceTypeList = brigand::filter&lt;TypeList, IsIDLInterface&lt;brigand::_1&gt;&gt;;
      using TypedArrayTypeList = brigand::filter&lt;TypeList, IsIDLTypedArray&lt;brigand::_1&gt;&gt;;
  
<span class="line-modified">!     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
      {
<span class="line-modified">!         JSC::VM&amp; vm = state.vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
          // 1. If the union type includes a nullable type and V is null or undefined, then return the IDL value null.
          constexpr bool hasNullType = brigand::any&lt;TypeList, std::is_same&lt;IDLNull, brigand::_1&gt;&gt;::value;
          if (hasNullType) {
              if (value.isUndefinedOrNull())
<span class="line-modified">!                 return ConditionalConverter&lt;ReturnType, IDLNull, hasNullType&gt;::convert(state, value).value();</span>
          }
  
          // 2. Let types be the flattened member types of the union type.
          // NOTE: Union is expected to be pre-flattented.
  
          // 3. If V is null or undefined then:
          if (hasDictionaryType) {
              if (value.isUndefinedOrNull()) {
                  //     1. If types includes a dictionary type, then return the result of converting V to that dictionary type.
<span class="line-modified">!                 return ConditionalConverter&lt;ReturnType, DictionaryType, hasDictionaryType&gt;::convert(state, value).value();</span>
              }
          }
  
          // 4. If V is a platform object, then:
          //     1. If types includes an interface type that V implements, then return the IDL value that is a reference to the object V.
<span class="line-new-header">--- 161,30 ---</span>
      static constexpr bool hasAnyObjectType = (numberOfSequenceTypes + numberOfFrozenArrayTypes + numberOfDictionaryTypes + numberOfRecordTypes + numberOfObjectTypes) &gt; 0;
  
      using InterfaceTypeList = brigand::filter&lt;TypeList, IsIDLInterface&lt;brigand::_1&gt;&gt;;
      using TypedArrayTypeList = brigand::filter&lt;TypeList, IsIDLTypedArray&lt;brigand::_1&gt;&gt;;
  
<span class="line-modified">!     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
      {
<span class="line-modified">!         JSC::VM&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
          // 1. If the union type includes a nullable type and V is null or undefined, then return the IDL value null.
          constexpr bool hasNullType = brigand::any&lt;TypeList, std::is_same&lt;IDLNull, brigand::_1&gt;&gt;::value;
          if (hasNullType) {
              if (value.isUndefinedOrNull())
<span class="line-modified">!                 return ConditionalConverter&lt;ReturnType, IDLNull, hasNullType&gt;::convert(lexicalGlobalObject, value).value();</span>
          }
  
          // 2. Let types be the flattened member types of the union type.
          // NOTE: Union is expected to be pre-flattented.
  
          // 3. If V is null or undefined then:
          if (hasDictionaryType) {
              if (value.isUndefinedOrNull()) {
                  //     1. If types includes a dictionary type, then return the result of converting V to that dictionary type.
<span class="line-modified">!                 return ConditionalConverter&lt;ReturnType, DictionaryType, hasDictionaryType&gt;::convert(lexicalGlobalObject, value).value();</span>
              }
          }
  
          // 4. If V is a platform object, then:
          //     1. If types includes an interface type that V implements, then return the IDL value that is a reference to the object V.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 198,11 ***</span>
  
                  using Type = typename WTF::RemoveCVAndReference&lt;decltype(type)&gt;::type::type;
                  using ImplementationType = typename Type::ImplementationType;
                  using RawType = typename Type::RawType;
  
<span class="line-modified">!                 auto castedValue = JSToWrappedOverloader&lt;RawType&gt;::toWrapped(state, value);</span>
                  if (!castedValue)
                      return;
  
                  returnValue = ReturnType(ImplementationType(castedValue));
              });
<span class="line-new-header">--- 198,11 ---</span>
  
                  using Type = typename WTF::RemoveCVAndReference&lt;decltype(type)&gt;::type::type;
                  using ImplementationType = typename Type::ImplementationType;
                  using RawType = typename Type::RawType;
  
<span class="line-modified">!                 auto castedValue = JSToWrappedOverloader&lt;RawType&gt;::toWrapped(lexicalGlobalObject, value);</span>
                  if (!castedValue)
                      return;
  
                  returnValue = ReturnType(ImplementationType(castedValue));
              });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 229,21 ***</span>
          if (hasArrayBufferType || hasObjectType) {
              auto arrayBuffer = JSC::JSArrayBuffer::toWrapped(vm, value);
              if (arrayBuffer) {
                  if (hasArrayBufferType)
                      return ConditionalReturner&lt;ReturnType, hasArrayBufferType&gt;::get(WTFMove(arrayBuffer)).value();
<span class="line-modified">!                 return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(state, value).value();</span>
              }
          }
  
          constexpr bool hasArrayBufferViewType = brigand::any&lt;TypeList, std::is_same&lt;IDLArrayBufferView, brigand::_1&gt;&gt;::value;
          if (hasArrayBufferViewType || hasObjectType) {
              auto arrayBufferView = JSC::JSArrayBufferView::toWrapped(vm, value);
              if (arrayBufferView) {
                  if (hasArrayBufferViewType)
                      return ConditionalReturner&lt;ReturnType, hasArrayBufferViewType&gt;::get(WTFMove(arrayBufferView)).value();
<span class="line-modified">!                 return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(state, value).value();</span>
              }
          }
  
          // 8. If Type(V) is Object and V has a [[DataView]] internal slot, then:
          //     1. If types includes DataView, then return the result of converting V to DataView.
<span class="line-new-header">--- 229,21 ---</span>
          if (hasArrayBufferType || hasObjectType) {
              auto arrayBuffer = JSC::JSArrayBuffer::toWrapped(vm, value);
              if (arrayBuffer) {
                  if (hasArrayBufferType)
                      return ConditionalReturner&lt;ReturnType, hasArrayBufferType&gt;::get(WTFMove(arrayBuffer)).value();
<span class="line-modified">!                 return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(lexicalGlobalObject, value).value();</span>
              }
          }
  
          constexpr bool hasArrayBufferViewType = brigand::any&lt;TypeList, std::is_same&lt;IDLArrayBufferView, brigand::_1&gt;&gt;::value;
          if (hasArrayBufferViewType || hasObjectType) {
              auto arrayBufferView = JSC::JSArrayBufferView::toWrapped(vm, value);
              if (arrayBufferView) {
                  if (hasArrayBufferViewType)
                      return ConditionalReturner&lt;ReturnType, hasArrayBufferViewType&gt;::get(WTFMove(arrayBufferView)).value();
<span class="line-modified">!                 return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(lexicalGlobalObject, value).value();</span>
              }
          }
  
          // 8. If Type(V) is Object and V has a [[DataView]] internal slot, then:
          //     1. If types includes DataView, then return the result of converting V to DataView.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 252,11 ***</span>
          if (hasDataViewType || hasObjectType) {
              auto dataView = JSC::JSDataView::toWrapped(vm, value);
              if (dataView) {
                  if (hasDataViewType)
                      return ConditionalReturner&lt;ReturnType, hasDataViewType&gt;::get(WTFMove(dataView)).value();
<span class="line-modified">!                 return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(state, value).value();</span>
              }
          }
  
          // 9. If Type(V) is Object and V has a [[TypedArrayName]] internal slot, then:
          //     1. If types includes a typed array type whose name is the value of V’s [[TypedArrayName]] internal slot, then return the result of converting V to that type.
<span class="line-new-header">--- 252,11 ---</span>
          if (hasDataViewType || hasObjectType) {
              auto dataView = JSC::JSDataView::toWrapped(vm, value);
              if (dataView) {
                  if (hasDataViewType)
                      return ConditionalReturner&lt;ReturnType, hasDataViewType&gt;::get(WTFMove(dataView)).value();
<span class="line-modified">!                 return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(lexicalGlobalObject, value).value();</span>
              }
          }
  
          // 9. If Type(V) is Object and V has a [[TypedArrayName]] internal slot, then:
          //     1. If types includes a typed array type whose name is the value of V’s [[TypedArrayName]] internal slot, then return the result of converting V to that type.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 302,79 ***</span>
                      //         2. ReturnIfAbrupt(method).
                      //         3. If method is not undefined, return the result of creating a
                      //            sequence of that type from V and method.
                      constexpr bool hasSequenceType = numberOfSequenceTypes != 0;
                      if (hasSequenceType) {
<span class="line-modified">!                         auto method = JSC::iteratorMethod(state, object);</span>
                          RETURN_IF_EXCEPTION(scope, ReturnType());
                          if (!method.isUndefined())
<span class="line-modified">!                             return ConditionalSequenceConverter&lt;ReturnType, SequenceType, hasSequenceType&gt;::convert(state, object, method).value();</span>
                      }
  
                      //     2. If types includes a frozen array type, then:
                      //         1. Let method be the result of GetMethod(V, @@iterator).
                      //         2. ReturnIfAbrupt(method).
                      //         3. If method is not undefined, return the result of creating a
                      //            frozen array of that type from V and method.
                      constexpr bool hasFrozenArrayType = numberOfFrozenArrayTypes != 0;
                      if (hasFrozenArrayType) {
<span class="line-modified">!                         auto method = JSC::iteratorMethod(state, object);</span>
                          RETURN_IF_EXCEPTION(scope, ReturnType());
                          if (!method.isUndefined())
<span class="line-modified">!                             return ConditionalSequenceConverter&lt;ReturnType, FrozenArrayType, hasFrozenArrayType&gt;::convert(state, object, method).value();</span>
                      }
  
                      //     3. If types includes a dictionary type, then return the result of
                      //        converting V to that dictionary type.
                      if (hasDictionaryType)
<span class="line-modified">!                         return ConditionalConverter&lt;ReturnType, DictionaryType, hasDictionaryType&gt;::convert(state, value).value();</span>
  
                      //     4. If types includes a record type, then return the result of converting V to that record type.
                      if (hasRecordType)
<span class="line-modified">!                         return ConditionalConverter&lt;ReturnType, RecordType, hasRecordType&gt;::convert(state, value).value();</span>
  
                      //     5. If types includes a callback interface type, then return the result of converting V to that interface type.
                      //         (FIXME: Add support for callback interface type and step 12.5)
  
                      //     6. If types includes object, then return the IDL value that is a reference to the object V.
                      if (hasObjectType)
<span class="line-modified">!                         return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(state, value).value();</span>
                  }
              }
          }
  
          // 12. If V is a Boolean value, then:
          //     1. If types includes a boolean, then return the result of converting V to boolean.
          constexpr bool hasBooleanType = brigand::any&lt;TypeList, std::is_same&lt;IDLBoolean, brigand::_1&gt;&gt;::value;
          if (hasBooleanType) {
              if (value.isBoolean())
<span class="line-modified">!                 return ConditionalConverter&lt;ReturnType, IDLBoolean, hasBooleanType&gt;::convert(state, value).value();</span>
          }
  
          // 13. If V is a Number value, then:
          //     1. If types includes a numeric type, then return the result of converting V to that numeric type.
          constexpr bool hasNumericType = brigand::size&lt;NumericTypeList&gt;::value != 0;
          if (hasNumericType) {
              if (value.isNumber())
<span class="line-modified">!                 return ConditionalConverter&lt;ReturnType, NumericType, hasNumericType&gt;::convert(state, value).value();</span>
          }
  
          // 14. If types includes a string type, then return the result of converting V to that type.
          constexpr bool hasStringType = brigand::size&lt;StringTypeList&gt;::value != 0;
          if (hasStringType)
<span class="line-modified">!             return ConditionalConverter&lt;ReturnType, StringType, hasStringType&gt;::convert(state, value).value();</span>
  
          // 15. If types includes a numeric type, then return the result of converting V to that numeric type.
          if (hasNumericType)
<span class="line-modified">!             return ConditionalConverter&lt;ReturnType, NumericType, hasNumericType&gt;::convert(state, value).value();</span>
  
          // 16. If types includes a boolean, then return the result of converting V to boolean.
          if (hasBooleanType)
<span class="line-modified">!             return ConditionalConverter&lt;ReturnType, IDLBoolean, hasBooleanType&gt;::convert(state, value).value();</span>
  
          // 17. Throw a TypeError.
<span class="line-modified">!         throwTypeError(&amp;state, scope);</span>
          return ReturnType();
      }
  };
  
  template&lt;typename... T&gt; struct JSConverter&lt;IDLUnion&lt;T...&gt;&gt; {
<span class="line-new-header">--- 302,79 ---</span>
                      //         2. ReturnIfAbrupt(method).
                      //         3. If method is not undefined, return the result of creating a
                      //            sequence of that type from V and method.
                      constexpr bool hasSequenceType = numberOfSequenceTypes != 0;
                      if (hasSequenceType) {
<span class="line-modified">!                         auto method = JSC::iteratorMethod(&amp;lexicalGlobalObject, object);</span>
                          RETURN_IF_EXCEPTION(scope, ReturnType());
                          if (!method.isUndefined())
<span class="line-modified">!                             return ConditionalSequenceConverter&lt;ReturnType, SequenceType, hasSequenceType&gt;::convert(lexicalGlobalObject, object, method).value();</span>
                      }
  
                      //     2. If types includes a frozen array type, then:
                      //         1. Let method be the result of GetMethod(V, @@iterator).
                      //         2. ReturnIfAbrupt(method).
                      //         3. If method is not undefined, return the result of creating a
                      //            frozen array of that type from V and method.
                      constexpr bool hasFrozenArrayType = numberOfFrozenArrayTypes != 0;
                      if (hasFrozenArrayType) {
<span class="line-modified">!                         auto method = JSC::iteratorMethod(&amp;lexicalGlobalObject, object);</span>
                          RETURN_IF_EXCEPTION(scope, ReturnType());
                          if (!method.isUndefined())
<span class="line-modified">!                             return ConditionalSequenceConverter&lt;ReturnType, FrozenArrayType, hasFrozenArrayType&gt;::convert(lexicalGlobalObject, object, method).value();</span>
                      }
  
                      //     3. If types includes a dictionary type, then return the result of
                      //        converting V to that dictionary type.
                      if (hasDictionaryType)
<span class="line-modified">!                         return ConditionalConverter&lt;ReturnType, DictionaryType, hasDictionaryType&gt;::convert(lexicalGlobalObject, value).value();</span>
  
                      //     4. If types includes a record type, then return the result of converting V to that record type.
                      if (hasRecordType)
<span class="line-modified">!                         return ConditionalConverter&lt;ReturnType, RecordType, hasRecordType&gt;::convert(lexicalGlobalObject, value).value();</span>
  
                      //     5. If types includes a callback interface type, then return the result of converting V to that interface type.
                      //         (FIXME: Add support for callback interface type and step 12.5)
  
                      //     6. If types includes object, then return the IDL value that is a reference to the object V.
                      if (hasObjectType)
<span class="line-modified">!                         return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(lexicalGlobalObject, value).value();</span>
                  }
              }
          }
  
          // 12. If V is a Boolean value, then:
          //     1. If types includes a boolean, then return the result of converting V to boolean.
          constexpr bool hasBooleanType = brigand::any&lt;TypeList, std::is_same&lt;IDLBoolean, brigand::_1&gt;&gt;::value;
          if (hasBooleanType) {
              if (value.isBoolean())
<span class="line-modified">!                 return ConditionalConverter&lt;ReturnType, IDLBoolean, hasBooleanType&gt;::convert(lexicalGlobalObject, value).value();</span>
          }
  
          // 13. If V is a Number value, then:
          //     1. If types includes a numeric type, then return the result of converting V to that numeric type.
          constexpr bool hasNumericType = brigand::size&lt;NumericTypeList&gt;::value != 0;
          if (hasNumericType) {
              if (value.isNumber())
<span class="line-modified">!                 return ConditionalConverter&lt;ReturnType, NumericType, hasNumericType&gt;::convert(lexicalGlobalObject, value).value();</span>
          }
  
          // 14. If types includes a string type, then return the result of converting V to that type.
          constexpr bool hasStringType = brigand::size&lt;StringTypeList&gt;::value != 0;
          if (hasStringType)
<span class="line-modified">!             return ConditionalConverter&lt;ReturnType, StringType, hasStringType&gt;::convert(lexicalGlobalObject, value).value();</span>
  
          // 15. If types includes a numeric type, then return the result of converting V to that numeric type.
          if (hasNumericType)
<span class="line-modified">!             return ConditionalConverter&lt;ReturnType, NumericType, hasNumericType&gt;::convert(lexicalGlobalObject, value).value();</span>
  
          // 16. If types includes a boolean, then return the result of converting V to boolean.
          if (hasBooleanType)
<span class="line-modified">!             return ConditionalConverter&lt;ReturnType, IDLBoolean, hasBooleanType&gt;::convert(lexicalGlobalObject, value).value();</span>
  
          // 17. Throw a TypeError.
<span class="line-modified">!         throwTypeError(&amp;lexicalGlobalObject, scope);</span>
          return ReturnType();
      }
  };
  
  template&lt;typename... T&gt; struct JSConverter&lt;IDLUnion&lt;T...&gt;&gt; {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 385,20 ***</span>
      static constexpr bool needsState = true;
      static constexpr bool needsGlobalObject = true;
  
      using Sequence = brigand::make_sequence&lt;brigand::ptrdiff_t&lt;0&gt;, WTF::variant_size&lt;ImplementationType&gt;::value&gt;;
  
<span class="line-modified">!     static JSC::JSValue convert(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const ImplementationType&amp; variant)</span>
      {
          auto index = variant.index();
  
          Optional&lt;JSC::JSValue&gt; returnValue;
          brigand::for_each&lt;Sequence&gt;([&amp;](auto&amp;&amp; type) {
              using I = typename WTF::RemoveCVAndReference&lt;decltype(type)&gt;::type::type;
              if (I::value == index) {
                  ASSERT(!returnValue);
<span class="line-modified">!                 returnValue = toJS&lt;brigand::at&lt;TypeList, I&gt;&gt;(state, globalObject, WTF::get&lt;I::value&gt;(variant));</span>
              }
          });
  
          ASSERT(returnValue);
          return returnValue.value();
<span class="line-new-header">--- 385,20 ---</span>
      static constexpr bool needsState = true;
      static constexpr bool needsGlobalObject = true;
  
      using Sequence = brigand::make_sequence&lt;brigand::ptrdiff_t&lt;0&gt;, WTF::variant_size&lt;ImplementationType&gt;::value&gt;;
  
<span class="line-modified">!     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const ImplementationType&amp; variant)</span>
      {
          auto index = variant.index();
  
          Optional&lt;JSC::JSValue&gt; returnValue;
          brigand::for_each&lt;Sequence&gt;([&amp;](auto&amp;&amp; type) {
              using I = typename WTF::RemoveCVAndReference&lt;decltype(type)&gt;::type::type;
              if (I::value == index) {
                  ASSERT(!returnValue);
<span class="line-modified">!                 returnValue = toJS&lt;brigand::at&lt;TypeList, I&gt;&gt;(lexicalGlobalObject, globalObject, WTF::get&lt;I::value&gt;(variant));</span>
              }
          });
  
          ASSERT(returnValue);
          return returnValue.value();
</pre>
<center><a href="JSDOMConvertStrings.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMConvertVariadic.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Parser.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Parser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ParserArena.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Parser.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 164         , m_hasDirectSuper(false)
 165         , m_needsSuperBinding(false)
 166         , m_allowsVarDeclarations(true)
 167         , m_allowsLexicalDeclarations(true)
 168         , m_strictMode(strictMode)
 169         , m_isFunction(isFunction)
 170         , m_isGenerator(isGenerator)
 171         , m_isGeneratorBoundary(false)
 172         , m_isArrowFunction(isArrowFunction)
 173         , m_isArrowFunctionBoundary(false)
 174         , m_isAsyncFunction(isAsyncFunction)
 175         , m_isAsyncFunctionBoundary(false)
 176         , m_isLexicalScope(false)
 177         , m_isGlobalCodeScope(false)
 178         , m_isSimpleCatchParameterScope(false)
 179         , m_isFunctionBoundary(false)
 180         , m_isValidStrictMode(true)
 181         , m_hasArguments(false)
 182         , m_isEvalContext(false)
 183         , m_hasNonSimpleParameterList(false)

 184         , m_evalContextType(EvalContextType::None)
 185         , m_constructorKind(static_cast&lt;unsigned&gt;(ConstructorKind::None))
 186         , m_expectedSuperBinding(static_cast&lt;unsigned&gt;(SuperBinding::NotNeeded))
 187         , m_loopDepth(0)
 188         , m_switchDepth(0)
 189         , m_innerArrowFunctionFeatures(0)
 190     {
 191         m_usedVariables.append(UniquedStringImplPtrSet());
 192     }
 193 
 194     Scope(Scope&amp;&amp;) = default;
 195 
 196     void startSwitch() { m_switchDepth++; }
 197     void endSwitch() { m_switchDepth--; }
 198     void startLoop() { m_loopDepth++; }
 199     void endLoop() { ASSERT(m_loopDepth); m_loopDepth--; }
 200     bool inLoop() { return !!m_loopDepth; }
 201     bool breakIsValid() { return m_loopDepth || m_switchDepth; }
 202     bool continueIsValid() { return m_loopDepth; }
 203 
</pre>
<hr />
<pre>
 241             break;
 242 
 243         case SourceParseMode::GeneratorBodyMode:
 244             setIsGenerator();
 245             break;
 246 
 247         case SourceParseMode::GeneratorWrapperFunctionMode:
 248         case SourceParseMode::GeneratorWrapperMethodMode:
 249             setIsGeneratorFunction();
 250             break;
 251 
 252         case SourceParseMode::AsyncGeneratorWrapperMethodMode:
 253         case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
 254             setIsAsyncGeneratorFunction();
 255             break;
 256 
 257         case SourceParseMode::NormalFunctionMode:
 258         case SourceParseMode::GetterMode:
 259         case SourceParseMode::SetterMode:
 260         case SourceParseMode::MethodMode:

 261             setIsFunction();
 262             break;
 263 
 264         case SourceParseMode::ArrowFunctionMode:
 265             setIsArrowFunction();
 266             break;
 267 
 268         case SourceParseMode::AsyncFunctionMode:
 269         case SourceParseMode::AsyncMethodMode:
 270             setIsAsyncFunction();
 271             break;
 272 
 273         case SourceParseMode::AsyncArrowFunctionMode:
 274             setIsAsyncArrowFunction();
 275             break;
 276 
 277         case SourceParseMode::ProgramMode:
 278         case SourceParseMode::ModuleAnalyzeMode:
 279         case SourceParseMode::ModuleEvaluateMode:
 280             break;
 281         }
 282     }
 283 
 284     bool isFunction() const { return m_isFunction; }
 285     bool isFunctionBoundary() const { return m_isFunctionBoundary; }
 286     bool isGenerator() const { return m_isGenerator; }
 287     bool isGeneratorBoundary() const { return m_isGeneratorBoundary; }
 288     bool isAsyncFunction() const { return m_isAsyncFunction; }
 289     bool isAsyncFunctionBoundary() const { return m_isAsyncFunctionBoundary; }

 290 
 291     bool hasArguments() const { return m_hasArguments; }
 292 
 293     void setIsGlobalCodeScope() { m_isGlobalCodeScope = true; }
 294     bool isGlobalCodeScope() const { return m_isGlobalCodeScope; }
 295 
 296     void setIsSimpleCatchParameterScope() { m_isSimpleCatchParameterScope = true; }
 297     bool isSimpleCatchParameterScope() { return m_isSimpleCatchParameterScope; }
 298 
 299     void setIsLexicalScope()
 300     {
 301         m_isLexicalScope = true;
 302         m_allowsLexicalDeclarations = true;
 303     }






 304     bool isLexicalScope() { return m_isLexicalScope; }
 305     bool usesEval() { return m_usesEval; }
 306 
 307     const HashSet&lt;UniquedStringImpl*&gt;&amp; closedVariableCandidates() const { return m_closedVariableCandidates; }
 308     VariableEnvironment&amp; declaredVariables() { return m_declaredVariables; }
 309     VariableEnvironment&amp; lexicalVariables() { return m_lexicalVariables; }
 310     VariableEnvironment&amp; finalizeLexicalEnvironment()
 311     {
 312         if (m_usesEval || m_needsFullActivation)
 313             m_lexicalVariables.markAllVariablesAsCaptured();
 314         else
 315             computeLexicallyCapturedVariablesAndPurgeCandidates();
 316 
 317         return m_lexicalVariables;
 318     }
 319 
 320     void computeLexicallyCapturedVariablesAndPurgeCandidates()
 321     {
 322         // Because variables may be defined at any time in the range of a lexical scope, we must
 323         // track lexical variables that might be captured. Then, when we&#39;re preparing to pop the top
 324         // lexical scope off the stack, we should find which variables are truly captured, and which
 325         // variable still may be captured in a parent scope.
 326         if (m_lexicalVariables.size() &amp;&amp; m_closedVariableCandidates.size()) {
 327             for (UniquedStringImpl* impl : m_closedVariableCandidates)
 328                 m_lexicalVariables.markVariableAsCapturedIfDefined(impl);
 329         }
 330 
 331         // We can now purge values from the captured candidates because they&#39;re captured in this scope.
 332         {
<span class="line-modified"> 333             for (auto entry : m_lexicalVariables) {</span>
 334                 if (entry.value.isCaptured())
 335                     m_closedVariableCandidates.remove(entry.key.get());
 336             }
 337         }
 338     }
 339 
 340     DeclarationResultMask declareCallee(const Identifier* ident)
 341     {
 342         auto addResult = m_declaredVariables.add(ident-&gt;impl());
 343         // We want to track if callee is captured, but we don&#39;t want to act like it&#39;s a &#39;var&#39;
 344         // because that would cause the BytecodeGenerator to emit bad code.
 345         addResult.iterator-&gt;value.clearIsVar();
 346 
 347         DeclarationResultMask result = DeclarationResult::Valid;
 348         if (isEvalOrArgumentsIdentifier(m_vm, ident))
 349             result |= DeclarationResult::InvalidStrictMode;
 350         return result;
 351     }
 352 
 353     DeclarationResultMask declareVariable(const Identifier* ident)
</pre>
<hr />
<pre>
 565 
 566     bool isEvalContext() const { return m_isEvalContext; }
 567     void setIsEvalContext(bool isEvalContext) { m_isEvalContext = isEvalContext; }
 568 
 569     void setInnerArrowFunctionUsesEvalAndUseArgumentsIfNeeded()
 570     {
 571         ASSERT(m_isArrowFunction);
 572 
 573         if (m_usesEval)
 574             setInnerArrowFunctionUsesEval();
 575 
 576         if (usedVariablesContains(m_vm.propertyNames-&gt;arguments.impl()))
 577             setInnerArrowFunctionUsesArguments();
 578     }
 579 
 580     void addClosedVariableCandidateUnconditionally(UniquedStringImpl* impl)
 581     {
 582         m_closedVariableCandidates.add(impl);
 583     }
 584 






 585     void collectFreeVariables(Scope* nestedScope, bool shouldTrackClosedVariables)
 586     {
 587         if (nestedScope-&gt;m_usesEval)
 588             m_usesEval = true;
 589 
 590         {
 591             UniquedStringImplPtrSet&amp; destinationSet = m_usedVariables.last();
 592             for (const UniquedStringImplPtrSet&amp; usedVariablesSet : nestedScope-&gt;m_usedVariables) {
 593                 for (UniquedStringImpl* impl : usedVariablesSet) {
 594                     if (nestedScope-&gt;m_declaredVariables.contains(impl) || nestedScope-&gt;m_lexicalVariables.contains(impl))
 595                         continue;
 596 
 597                     // &quot;arguments&quot; reference should be resolved at function boudary.
 598                     if (nestedScope-&gt;isFunctionBoundary() &amp;&amp; nestedScope-&gt;hasArguments() &amp;&amp; impl == m_vm.propertyNames-&gt;arguments.impl() &amp;&amp; !nestedScope-&gt;isArrowFunctionBoundary())
 599                         continue;
 600 
 601                     destinationSet.add(impl);
 602                     // We don&#39;t want a declared variable that is used in an inner scope to be thought of as captured if
 603                     // that inner scope is both a lexical scope and not a function. Only inner functions and &quot;catch&quot;
 604                     // statements can cause variables to be captured.
</pre>
<hr />
<pre>
 692         // This is somewhat unfortunate and we should refactor to do this at some point
 693         // because parameters logically form a parent scope to var/let/const variables.
 694         // But because we don&#39;t do this, we must grab capture candidates from a parameter
 695         // list before we parse the body of a function because the body&#39;s declarations
 696         // might make us believe something isn&#39;t actually a capture candidate when it really
 697         // is.
 698         for (UniquedStringImpl* impl : capturesFromParameterExpressions)
 699             parameters.usedVariables.append(impl);
 700     }
 701 
 702     void restoreFromSourceProviderCache(const SourceProviderCacheItem* info)
 703     {
 704         ASSERT(m_isFunction);
 705         m_usesEval = info-&gt;usesEval;
 706         m_strictMode = info-&gt;strictMode;
 707         m_innerArrowFunctionFeatures = info-&gt;innerArrowFunctionFeatures;
 708         m_needsFullActivation = info-&gt;needsFullActivation;
 709         m_needsSuperBinding = info-&gt;needsSuperBinding;
 710         UniquedStringImplPtrSet&amp; destSet = m_usedVariables.last();
 711         for (unsigned i = 0; i &lt; info-&gt;usedVariablesCount; ++i)
<span class="line-modified"> 712             destSet.add(info-&gt;usedVariables()[i]);</span>
 713     }
 714 
 715     class MaybeParseAsGeneratorForScope;
 716 
 717 private:
 718     void setIsFunction()
 719     {
 720         m_isFunction = true;
 721         m_isFunctionBoundary = true;
 722         m_hasArguments = true;
 723         setIsLexicalScope();
 724         m_isGenerator = false;
 725         m_isGeneratorBoundary = false;
 726         m_isArrowFunctionBoundary = false;
 727         m_isArrowFunction = false;
 728         m_isAsyncFunction = false;
 729         m_isAsyncFunctionBoundary = false;
 730     }
 731 
 732     void setIsGeneratorFunction()
</pre>
<hr />
<pre>
 802     bool m_hasDirectSuper;
 803     bool m_needsSuperBinding;
 804     bool m_allowsVarDeclarations;
 805     bool m_allowsLexicalDeclarations;
 806     bool m_strictMode;
 807     bool m_isFunction;
 808     bool m_isGenerator;
 809     bool m_isGeneratorBoundary;
 810     bool m_isArrowFunction;
 811     bool m_isArrowFunctionBoundary;
 812     bool m_isAsyncFunction;
 813     bool m_isAsyncFunctionBoundary;
 814     bool m_isLexicalScope;
 815     bool m_isGlobalCodeScope;
 816     bool m_isSimpleCatchParameterScope;
 817     bool m_isFunctionBoundary;
 818     bool m_isValidStrictMode;
 819     bool m_hasArguments;
 820     bool m_isEvalContext;
 821     bool m_hasNonSimpleParameterList;

 822     EvalContextType m_evalContextType;
 823     unsigned m_constructorKind;
 824     unsigned m_expectedSuperBinding;
 825     int m_loopDepth;
 826     int m_switchDepth;
 827     InnerArrowFunctionCodeFeatures m_innerArrowFunctionFeatures;
 828 
 829     typedef Vector&lt;ScopeLabelInfo, 2&gt; LabelStack;
 830     std::unique_ptr&lt;LabelStack&gt; m_labels;
 831     UniquedStringImplPtrSet m_declaredParameters;
 832     VariableEnvironment m_declaredVariables;
 833     VariableEnvironment m_lexicalVariables;
 834     Vector&lt;UniquedStringImplPtrSet, 6&gt; m_usedVariables;
 835     UniquedStringImplPtrSet m_variablesBeingHoisted;
 836     UniquedStringImplPtrSet m_sloppyModeHoistableFunctionCandidates;
 837     HashSet&lt;UniquedStringImpl*&gt; m_closedVariableCandidates;
 838     DeclarationStacks::FunctionStack m_functionDeclarations;
 839 };
 840 
 841 typedef Vector&lt;Scope, 10&gt; ScopeStack;
</pre>
<hr />
<pre>
 868 
 869     bool operator!=(const ScopeRef&amp; other)
 870     {
 871         return !(*this == other);
 872     }
 873 
 874 private:
 875     ScopeStack* m_scopeStack;
 876     unsigned m_index;
 877 };
 878 
 879 enum class ArgumentType { Normal, Spread };
 880 enum class ParsingContext { Program, FunctionConstructor, Eval };
 881 
 882 template &lt;typename LexerType&gt;
 883 class Parser {
 884     WTF_MAKE_NONCOPYABLE(Parser);
 885     WTF_MAKE_FAST_ALLOCATED;
 886 
 887 public:
<span class="line-modified"> 888     Parser(VM&amp;, const SourceCode&amp;, JSParserBuiltinMode, JSParserStrictMode, JSParserScriptMode, SourceParseMode, SuperBinding, ConstructorKind defaultConstructorKind = ConstructorKind::None, DerivedContextType = DerivedContextType::None, bool isEvalContext = false, EvalContextType = EvalContextType::None, DebuggerParseData* = nullptr);</span>
 889     ~Parser();
 890 
 891     template &lt;class ParsedNode&gt;
<span class="line-modified"> 892     std::unique_ptr&lt;ParsedNode&gt; parse(ParserError&amp;, const Identifier&amp;, SourceParseMode, ParsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);</span>
 893 
 894     JSTextPosition positionBeforeLastNewline() const { return m_lexer-&gt;positionBeforeLastNewline(); }
 895     JSTokenLocation locationBeforeLastToken() const { return m_lexer-&gt;lastTokenLocation(); }
 896 
 897     struct CallOrApplyDepthScope {
 898         CallOrApplyDepthScope(Parser* parser)
 899             : m_parser(parser)
 900             , m_parent(parser-&gt;m_callOrApplyDepthScope)
 901             , m_depth(m_parent ? m_parent-&gt;m_depth + 1 : 0)
 902             , m_depthOfInnermostChild(m_depth)
 903         {
 904             parser-&gt;m_callOrApplyDepthScope = this;
 905         }
 906 
 907         size_t distanceToInnermostChild() const
 908         {
 909             ASSERT(m_depthOfInnermostChild &gt;= m_depth);
 910             return m_depthOfInnermostChild - m_depth;
 911         }
 912 
</pre>
<hr />
<pre>
1155         unsigned i = m_scopeStack.size() - 1;
1156         ASSERT(i &lt; m_scopeStack.size());
1157         while (i &amp;&amp; !m_scopeStack[i].isFunctionBoundary()) {
1158             i--;
1159             ASSERT(i &lt; m_scopeStack.size());
1160         }
1161         // When reaching the top level scope (it can be non function scope), we return it.
1162         return ScopeRef(&amp;m_scopeStack, i);
1163     }
1164 
1165     ScopeRef closestParentOrdinaryFunctionNonLexicalScope()
1166     {
1167         unsigned i = m_scopeStack.size() - 1;
1168         ASSERT(i &lt; m_scopeStack.size() &amp;&amp; m_scopeStack.size());
1169         while (i &amp;&amp; (!m_scopeStack[i].isFunctionBoundary() || m_scopeStack[i].isGeneratorBoundary() || m_scopeStack[i].isAsyncFunctionBoundary() || m_scopeStack[i].isArrowFunctionBoundary()))
1170             i--;
1171         // When reaching the top level scope (it can be non ordinary function scope), we return it.
1172         return ScopeRef(&amp;m_scopeStack, i);
1173     }
1174 









1175     ScopeRef pushScope()
1176     {
1177         bool isFunction = false;
1178         bool isStrict = false;
1179         bool isGenerator = false;
1180         bool isArrowFunction = false;
1181         bool isAsyncFunction = false;
1182         if (!m_scopeStack.isEmpty()) {
1183             isStrict = m_scopeStack.last().strictMode();
1184             isFunction = m_scopeStack.last().isFunction();
1185             isGenerator = m_scopeStack.last().isGenerator();
1186             isArrowFunction = m_scopeStack.last().isArrowFunction();
1187             isAsyncFunction = m_scopeStack.last().isAsyncFunction();
1188         }
1189         m_scopeStack.constructAndAppend(m_vm, isFunction, isGenerator, isStrict, isArrowFunction, isAsyncFunction);
1190         return currentScope();
1191     }
1192 
1193     void popScopeInternal(ScopeRef&amp; scope, bool shouldTrackClosedVariables)
1194     {
</pre>
<hr />
<pre>
1330         }
1331         return m_scopeStack[i].hasDeclaredParameter(ident);
1332     }
1333 
1334     bool exportName(const Identifier&amp; ident)
1335     {
1336         ASSERT(currentScope().index() == 0);
1337         ASSERT(m_moduleScopeData);
1338         return m_moduleScopeData-&gt;exportName(ident);
1339     }
1340 
1341     ScopeStack m_scopeStack;
1342 
1343     const SourceProviderCacheItem* findCachedFunctionInfo(int openBracePos)
1344     {
1345         return m_functionCache ? m_functionCache-&gt;get(openBracePos) : 0;
1346     }
1347 
1348     Parser();
1349 
<span class="line-modified">1350     String parseInner(const Identifier&amp;, SourceParseMode, ParsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);</span>
<span class="line-modified">1351 </span>
<span class="line-modified">1352     void didFinishParsing(SourceElements*, DeclarationStacks::FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, CodeFeatures, int);</span>







1353 
1354     // Used to determine type of error to report.
1355     bool isFunctionMetadataNode(ScopeNode*) { return false; }
1356     bool isFunctionMetadataNode(FunctionMetadataNode*) { return true; }
1357 
<span class="line-modified">1358     ALWAYS_INLINE void next(unsigned lexerFlags = 0)</span>
1359     {
1360         int lastLine = m_token.m_location.line;
1361         int lastTokenEnd = m_token.m_location.endOffset;
1362         int lastTokenLineStart = m_token.m_location.lineStartOffset;
1363         m_lastTokenEndPosition = JSTextPosition(lastLine, lastTokenEnd, lastTokenLineStart);
1364         m_lexer-&gt;setLastLineNumber(lastLine);
1365         m_token.m_type = m_lexer-&gt;lex(&amp;m_token, lexerFlags, strictMode());
1366     }
1367 
<span class="line-modified">1368     ALWAYS_INLINE void nextWithoutClearingLineTerminator(unsigned lexerFlags = 0)</span>
1369     {
1370         int lastLine = m_token.m_location.line;
1371         int lastTokenEnd = m_token.m_location.endOffset;
1372         int lastTokenLineStart = m_token.m_location.lineStartOffset;
1373         m_lastTokenEndPosition = JSTextPosition(lastLine, lastTokenEnd, lastTokenLineStart);
1374         m_lexer-&gt;setLastLineNumber(lastLine);
1375         m_token.m_type = m_lexer-&gt;lexWithoutClearingLineTerminator(&amp;m_token, lexerFlags, strictMode());
1376     }
1377 
<span class="line-modified">1378     ALWAYS_INLINE void nextExpectIdentifier(unsigned lexerFlags = 0)</span>
1379     {
1380         int lastLine = m_token.m_location.line;
1381         int lastTokenEnd = m_token.m_location.endOffset;
1382         int lastTokenLineStart = m_token.m_location.lineStartOffset;
1383         m_lastTokenEndPosition = JSTextPosition(lastLine, lastTokenEnd, lastTokenLineStart);
1384         m_lexer-&gt;setLastLineNumber(lastLine);
1385         m_token.m_type = m_lexer-&gt;lexExpectIdentifier(&amp;m_token, lexerFlags, strictMode());
1386     }
1387 
<span class="line-modified">1388     ALWAYS_INLINE void lexCurrentTokenAgainUnderCurrentContext()</span>

1389     {
<span class="line-modified">1390         auto savePoint = createSavePoint();</span>
<span class="line-modified">1391         restoreSavePoint(savePoint);</span>
1392     }
1393 
1394     ALWAYS_INLINE bool nextTokenIsColon()
1395     {
1396         return m_lexer-&gt;nextTokenIsColon();
1397     }
1398 
<span class="line-modified">1399     ALWAYS_INLINE bool consume(JSTokenType expected, unsigned flags = 0)</span>
1400     {
1401         bool result = m_token.m_type == expected;
1402         if (result)
1403             next(flags);
1404         return result;
1405     }
1406 
1407     void printUnexpectedTokenText(WTF::PrintStream&amp;);
1408     ALWAYS_INLINE StringView getToken()
1409     {
1410         return m_lexer-&gt;getToken(m_token);
1411     }
1412 
1413     ALWAYS_INLINE StringView getToken(const JSToken&amp; token)
1414     {
1415         return m_lexer-&gt;getToken(token);
1416     }
1417 
1418     ALWAYS_INLINE bool match(JSTokenType expected)
1419     {
</pre>
<hr />
<pre>
1559     {
1560         return match(YIELD) &amp;&amp; !strictMode() &amp;&amp; !inGenerator;
1561     }
1562 
1563     // http://ecma-international.org/ecma-262/6.0/#sec-generator-function-definitions-static-semantics-early-errors
1564     ALWAYS_INLINE bool matchSpecIdentifier(bool inGenerator)
1565     {
1566         return match(IDENT) || isLETMaskedAsIDENT() || isYIELDMaskedAsIDENT(inGenerator) || isSafeContextualKeyword(m_token);
1567     }
1568 
1569     ALWAYS_INLINE bool matchSpecIdentifier()
1570     {
1571         return match(IDENT) || isLETMaskedAsIDENT() || isYIELDMaskedAsIDENT(currentScope()-&gt;isGenerator()) || isSafeContextualKeyword(m_token);
1572     }
1573 
1574     template &lt;class TreeBuilder&gt; TreeSourceElements parseSourceElements(TreeBuilder&amp;, SourceElementsMode);
1575     template &lt;class TreeBuilder&gt; TreeSourceElements parseGeneratorFunctionSourceElements(TreeBuilder&amp;, const Identifier&amp; name, SourceElementsMode);
1576     template &lt;class TreeBuilder&gt; TreeSourceElements parseAsyncFunctionSourceElements(TreeBuilder&amp;, SourceParseMode, bool isArrowFunctionBodyExpression, SourceElementsMode);
1577     template &lt;class TreeBuilder&gt; TreeSourceElements parseAsyncGeneratorFunctionSourceElements(TreeBuilder&amp;, SourceParseMode, bool isArrowFunctionBodyExpression, SourceElementsMode);
1578     template &lt;class TreeBuilder&gt; TreeSourceElements parseSingleFunction(TreeBuilder&amp;, Optional&lt;int&gt; functionConstructorParametersEndPosition);

1579     template &lt;class TreeBuilder&gt; TreeStatement parseStatementListItem(TreeBuilder&amp;, const Identifier*&amp; directive, unsigned* directiveLiteralLength);
1580     template &lt;class TreeBuilder&gt; TreeStatement parseStatement(TreeBuilder&amp;, const Identifier*&amp; directive, unsigned* directiveLiteralLength = 0);
1581     enum class ExportType { Exported, NotExported };
1582     template &lt;class TreeBuilder&gt; TreeStatement parseClassDeclaration(TreeBuilder&amp;, ExportType = ExportType::NotExported, DeclarationDefaultContext = DeclarationDefaultContext::Standard);
1583     template &lt;class TreeBuilder&gt; TreeStatement parseFunctionDeclaration(TreeBuilder&amp;, ExportType = ExportType::NotExported, DeclarationDefaultContext = DeclarationDefaultContext::Standard, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
1584     template &lt;class TreeBuilder&gt; TreeStatement parseFunctionDeclarationStatement(TreeBuilder&amp;, bool isAsync, bool parentAllowsFunctionDeclarationAsStatement);
1585     template &lt;class TreeBuilder&gt; TreeStatement parseAsyncFunctionDeclaration(TreeBuilder&amp;, ExportType = ExportType::NotExported, DeclarationDefaultContext = DeclarationDefaultContext::Standard, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
1586     template &lt;class TreeBuilder&gt; NEVER_INLINE bool maybeParseAsyncFunctionDeclarationStatement(TreeBuilder&amp; context, TreeStatement&amp; result, bool parentAllowsFunctionDeclarationAsStatement);
1587     template &lt;class TreeBuilder&gt; TreeStatement parseVariableDeclaration(TreeBuilder&amp;, DeclarationType, ExportType = ExportType::NotExported);
1588     template &lt;class TreeBuilder&gt; TreeStatement parseDoWhileStatement(TreeBuilder&amp;);
1589     template &lt;class TreeBuilder&gt; TreeStatement parseWhileStatement(TreeBuilder&amp;);
1590     template &lt;class TreeBuilder&gt; TreeStatement parseForStatement(TreeBuilder&amp;);
1591     template &lt;class TreeBuilder&gt; TreeStatement parseBreakStatement(TreeBuilder&amp;);
1592     template &lt;class TreeBuilder&gt; TreeStatement parseContinueStatement(TreeBuilder&amp;);
1593     template &lt;class TreeBuilder&gt; TreeStatement parseReturnStatement(TreeBuilder&amp;);
1594     template &lt;class TreeBuilder&gt; TreeStatement parseThrowStatement(TreeBuilder&amp;);
1595     template &lt;class TreeBuilder&gt; TreeStatement parseWithStatement(TreeBuilder&amp;);
1596     template &lt;class TreeBuilder&gt; TreeStatement parseSwitchStatement(TreeBuilder&amp;);
1597     template &lt;class TreeBuilder&gt; TreeClauseList parseSwitchClauses(TreeBuilder&amp;);
1598     template &lt;class TreeBuilder&gt; TreeClause parseSwitchDefaultClause(TreeBuilder&amp;);
1599     template &lt;class TreeBuilder&gt; TreeStatement parseTryStatement(TreeBuilder&amp;);
1600     template &lt;class TreeBuilder&gt; TreeStatement parseDebuggerStatement(TreeBuilder&amp;);
1601     template &lt;class TreeBuilder&gt; TreeStatement parseExpressionStatement(TreeBuilder&amp;);
1602     template &lt;class TreeBuilder&gt; TreeStatement parseExpressionOrLabelStatement(TreeBuilder&amp;, bool allowFunctionDeclarationAsStatement);
1603     template &lt;class TreeBuilder&gt; TreeStatement parseIfStatement(TreeBuilder&amp;);
1604     template &lt;class TreeBuilder&gt; TreeStatement parseBlockStatement(TreeBuilder&amp;);
1605     template &lt;class TreeBuilder&gt; TreeExpression parseExpression(TreeBuilder&amp;);
1606     template &lt;class TreeBuilder&gt; TreeExpression parseAssignmentExpression(TreeBuilder&amp;, ExpressionErrorClassifier&amp;);
1607     template &lt;class TreeBuilder&gt; TreeExpression parseAssignmentExpression(TreeBuilder&amp;);
1608     template &lt;class TreeBuilder&gt; TreeExpression parseAssignmentExpressionOrPropagateErrorClass(TreeBuilder&amp;);
1609     template &lt;class TreeBuilder&gt; TreeExpression parseYieldExpression(TreeBuilder&amp;);
1610     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseConditionalExpression(TreeBuilder&amp;);
1611     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseBinaryExpression(TreeBuilder&amp;);
1612     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseUnaryExpression(TreeBuilder&amp;);
1613     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeExpression parseAwaitExpression(TreeBuilder&amp;);
1614     template &lt;class TreeBuilder&gt; TreeExpression parseMemberExpression(TreeBuilder&amp;);
1615     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parsePrimaryExpression(TreeBuilder&amp;);
1616     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseArrayLiteral(TreeBuilder&amp;);
1617     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseObjectLiteral(TreeBuilder&amp;);
<span class="line-removed">1618     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeExpression parseStrictObjectLiteral(TreeBuilder&amp;);</span>
1619     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeClassExpression parseClassExpression(TreeBuilder&amp;);
1620     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseFunctionExpression(TreeBuilder&amp;);
1621     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseAsyncFunctionExpression(TreeBuilder&amp;);
1622     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeArguments parseArguments(TreeBuilder&amp;);
1623     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseArgument(TreeBuilder&amp;, ArgumentType&amp;);
1624     template &lt;class TreeBuilder&gt; TreeProperty parseProperty(TreeBuilder&amp;, bool strict);
1625     template &lt;class TreeBuilder&gt; TreeExpression parsePropertyMethod(TreeBuilder&amp; context, const Identifier* methodName, SourceParseMode);
1626     template &lt;class TreeBuilder&gt; TreeProperty parseGetterSetter(TreeBuilder&amp;, bool strict, PropertyNode::Type, unsigned getterOrSetterStartOffset, ConstructorKind, ClassElementTag);
1627     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeFunctionBody parseFunctionBody(TreeBuilder&amp;, SyntaxChecker&amp;, const JSTokenLocation&amp;, int, int functionKeywordStart, int functionNameStart, int parametersStart, ConstructorKind, SuperBinding, FunctionBodyType, unsigned, SourceParseMode);
1628     template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool parseFormalParameters(TreeBuilder&amp;, TreeFormalParameterList, bool isArrowFunction, bool isMethod, unsigned&amp;);
1629     enum VarDeclarationListContext { ForLoopContext, VarDeclarationContext };
1630     template &lt;class TreeBuilder&gt; TreeExpression parseVariableDeclarationList(TreeBuilder&amp;, int&amp; declarations, TreeDestructuringPattern&amp; lastPattern, TreeExpression&amp; lastInitializer, JSTextPosition&amp; identStart, JSTextPosition&amp; initStart, JSTextPosition&amp; initEnd, VarDeclarationListContext, DeclarationType, ExportType, bool&amp; forLoopConstDoesNotHaveInitializer);
1631     template &lt;class TreeBuilder&gt; TreeSourceElements parseArrowFunctionSingleExpressionBodySourceElements(TreeBuilder&amp;);
1632     template &lt;class TreeBuilder&gt; TreeExpression parseArrowFunctionExpression(TreeBuilder&amp;, bool isAsync);
<span class="line-modified">1633     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern createBindingPattern(TreeBuilder&amp;, DestructuringKind, ExportType, const Identifier&amp;, JSToken, AssignmentContext, const Identifier** duplicateIdentifier);</span>
1634     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern createAssignmentElement(TreeBuilder&amp;, TreeExpression&amp;, const JSTextPosition&amp;, const JSTextPosition&amp;);
1635     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseObjectRestBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind, ExportType, const Identifier** duplicateIdentifier, AssignmentContext bindingContext);
1636     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind, ExportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth);
1637     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseObjectRestAssignmentElement(TreeBuilder&amp; context);
1638     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseAssignmentElement(TreeBuilder&amp; context, DestructuringKind, ExportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth);
1639     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseObjectRestElement(TreeBuilder&amp;, DestructuringKind, ExportType, const Identifier** duplicateIdentifier = nullptr, AssignmentContext = AssignmentContext::DeclarationStatement);
1640     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseDestructuringPattern(TreeBuilder&amp;, DestructuringKind, ExportType, const Identifier** duplicateIdentifier = nullptr, bool* hasDestructuringPattern = nullptr, AssignmentContext = AssignmentContext::DeclarationStatement, int depth = 0);
1641     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern tryParseDestructuringPatternExpression(TreeBuilder&amp;, AssignmentContext);
1642     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeExpression parseDefaultValueForDestructuringPattern(TreeBuilder&amp;);
1643     template &lt;class TreeBuilder&gt; TreeSourceElements parseModuleSourceElements(TreeBuilder&amp;, SourceParseMode);
1644     enum class ImportSpecifierType { NamespaceImport, NamedImport, DefaultImport };
1645     template &lt;class TreeBuilder&gt; typename TreeBuilder::ImportSpecifier parseImportClauseItem(TreeBuilder&amp;, ImportSpecifierType);
1646     template &lt;class TreeBuilder&gt; typename TreeBuilder::ModuleName parseModuleName(TreeBuilder&amp;);
1647     template &lt;class TreeBuilder&gt; TreeStatement parseImportDeclaration(TreeBuilder&amp;);
1648     template &lt;class TreeBuilder&gt; typename TreeBuilder::ExportSpecifier parseExportSpecifier(TreeBuilder&amp; context, Vector&lt;std::pair&lt;const Identifier*, const Identifier*&gt;&gt;&amp; maybeExportedLocalNames, bool&amp; hasKeywordForLocalBindings);
1649     template &lt;class TreeBuilder&gt; TreeStatement parseExportDeclaration(TreeBuilder&amp;);
1650 
1651     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression createResolveAndUseVariable(TreeBuilder&amp;, const Identifier*, bool isEval, const JSTextPosition&amp;, const JSTokenLocation&amp;);
1652 
1653     enum class FunctionDefinitionType { Expression, Declaration, Method };
1654     template &lt;class TreeBuilder&gt; NEVER_INLINE bool parseFunctionInfo(TreeBuilder&amp;, FunctionNameRequirements, SourceParseMode, bool nameIsInContainingScope, ConstructorKind, SuperBinding, int functionKeywordStart, ParserFunctionInfo&lt;TreeBuilder&gt;&amp;, FunctionDefinitionType, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
1655 
<span class="line-modified">1656     ALWAYS_INLINE bool isArrowFunctionParameters();</span>
1657 
1658     template &lt;class TreeBuilder, class FunctionInfoType&gt; NEVER_INLINE typename TreeBuilder::FormalParameterList parseFunctionParameters(TreeBuilder&amp;, SourceParseMode, FunctionInfoType&amp;);
1659     template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::FormalParameterList createGeneratorParameters(TreeBuilder&amp;, unsigned&amp; parameterCount);
1660 
1661     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeClassExpression parseClass(TreeBuilder&amp;, FunctionNameRequirements, ParserClassInfo&lt;TreeBuilder&gt;&amp;);
1662 
1663     template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::TemplateString parseTemplateString(TreeBuilder&amp; context, bool isTemplateHead, typename LexerType::RawStringsBuildMode, bool&amp; elementIsTail);
1664     template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::TemplateLiteral parseTemplateLiteral(TreeBuilder&amp;, typename LexerType::RawStringsBuildMode);
1665 
1666     template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool shouldCheckPropertyForUnderscoreProtoDuplicate(TreeBuilder&amp;, const TreeProperty&amp;);
1667 
1668     template &lt;class TreeBuilder&gt; NEVER_INLINE const char* metaPropertyName(TreeBuilder&amp;, TreeExpression);
1669 
1670     template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool isSimpleAssignmentTarget(TreeBuilder&amp;, TreeExpression);
1671 
1672     ALWAYS_INLINE int isBinaryOperator(JSTokenType);
1673     bool allowAutomaticSemicolon();
1674 
1675     bool autoSemiColon()
1676     {
</pre>
<hr />
<pre>
1742             return &quot;in a module&quot;;
1743         RELEASE_ASSERT_NOT_REACHED();
1744         return nullptr;
1745     }
1746 
1747     const char* disallowedIdentifierYieldReason()
1748     {
1749         if (strictMode())
1750             return &quot;in strict mode&quot;;
1751         if (currentScope()-&gt;isGenerator())
1752             return &quot;in a generator function&quot;;
1753         RELEASE_ASSERT_NOT_REACHED();
1754         return nullptr;
1755     }
1756 
1757     enum class FunctionParsePhase { Parameters, Body };
1758     struct ParserState {
1759         int assignmentCount { 0 };
1760         int nonLHSCount { 0 };
1761         int nonTrivialExpressionCount { 0 };

1762         FunctionParsePhase functionParsePhase { FunctionParsePhase::Body };
1763         const Identifier* lastIdentifier { nullptr };
1764         const Identifier* lastFunctionName { nullptr };
1765         bool allowAwait { true };

1766     };
1767 
1768     // If you&#39;re using this directly, you probably should be using
1769     // createSavePoint() instead.
<span class="line-modified">1770     ALWAYS_INLINE ParserState internalSaveParserState()</span>

1771     {
<span class="line-modified">1772         return m_parserState;</span>


1773     }
1774 
<span class="line-modified">1775     ALWAYS_INLINE void restoreParserState(const ParserState&amp; state)</span>

1776     {
1777         m_parserState = state;

1778     }
1779 
1780     struct LexerState {
1781         int startOffset;
1782         unsigned oldLineStartOffset;
1783         unsigned oldLastLineNumber;
1784         unsigned oldLineNumber;
1785         bool hasLineTerminatorBeforeToken;
1786     };
1787 
1788     // If you&#39;re using this directly, you probably should be using
1789     // createSavePoint() instead.
1790     // i.e, if you parse any kind of AssignmentExpression between
1791     // saving/restoring, you should definitely not be using this directly.
1792     ALWAYS_INLINE LexerState internalSaveLexerState()
1793     {
1794         LexerState result;
1795         result.startOffset = m_token.m_location.startOffset;
1796         result.oldLineStartOffset = m_token.m_location.lineStartOffset;
1797         result.oldLastLineNumber = m_lexer-&gt;lastLineNumber();
</pre>
<hr />
<pre>
1805     {
1806         // setOffset clears lexer errors.
1807         m_lexer-&gt;setOffset(lexerState.startOffset, lexerState.oldLineStartOffset);
1808         m_lexer-&gt;setLineNumber(lexerState.oldLineNumber);
1809         m_lexer-&gt;setHasLineTerminatorBeforeToken(lexerState.hasLineTerminatorBeforeToken);
1810         nextWithoutClearingLineTerminator();
1811         m_lexer-&gt;setLastLineNumber(lexerState.oldLastLineNumber);
1812     }
1813 
1814     struct SavePoint {
1815         ParserState parserState;
1816         LexerState lexerState;
1817     };
1818 
1819     struct SavePointWithError : public SavePoint {
1820         bool lexerError;
1821         String lexerErrorMessage;
1822         String parserErrorMessage;
1823     };
1824 
<span class="line-modified">1825     ALWAYS_INLINE void internalSaveState(SavePoint&amp; savePoint)</span>

1826     {
<span class="line-modified">1827         savePoint.parserState = internalSaveParserState();</span>
1828         savePoint.lexerState = internalSaveLexerState();
1829     }
1830 
<span class="line-modified">1831     ALWAYS_INLINE SavePointWithError createSavePointForError()</span>

1832     {
1833         SavePointWithError savePoint;
<span class="line-modified">1834         internalSaveState(savePoint);</span>
1835         savePoint.lexerError = m_lexer-&gt;sawError();
1836         savePoint.lexerErrorMessage = m_lexer-&gt;getErrorMessage();
1837         savePoint.parserErrorMessage = m_errorMessage;



1838         return savePoint;
1839     }
1840 
<span class="line-modified">1841     ALWAYS_INLINE SavePoint createSavePoint()</span>

1842     {
1843         ASSERT(!hasError());
1844         SavePoint savePoint;
<span class="line-modified">1845         internalSaveState(savePoint);</span>
1846         return savePoint;
1847     }
1848 
<span class="line-modified">1849     ALWAYS_INLINE void internalRestoreState(const SavePoint&amp; savePoint)</span>

1850     {
1851         restoreLexerState(savePoint.lexerState);
<span class="line-modified">1852         restoreParserState(savePoint.parserState);</span>
1853     }
1854 
<span class="line-modified">1855     ALWAYS_INLINE void restoreSavePointWithError(const SavePointWithError&amp; savePoint)</span>

1856     {
<span class="line-modified">1857         internalRestoreState(savePoint);</span>
1858         m_lexer-&gt;setSawError(savePoint.lexerError);
1859         m_lexer-&gt;setErrorMessage(savePoint.lexerErrorMessage);
1860         m_errorMessage = savePoint.parserErrorMessage;
1861     }
1862 
<span class="line-modified">1863     ALWAYS_INLINE void restoreSavePoint(const SavePoint&amp; savePoint)</span>

1864     {
<span class="line-modified">1865         internalRestoreState(savePoint);</span>
1866         m_errorMessage = String();
1867     }
1868 
1869     VM&amp; m_vm;
1870     const SourceCode* m_source;
1871     ParserArena m_parserArena;
1872     std::unique_ptr&lt;LexerType&gt; m_lexer;
<span class="line-removed">1873     FunctionParameters* m_parameters { nullptr };</span>
1874 
1875     ParserState m_parserState;
1876 
1877     bool m_hasStackOverflow;
1878     String m_errorMessage;
1879     JSToken m_token;
1880     bool m_allowsIn;
1881     JSTextPosition m_lastTokenEndPosition;
1882     int m_statementDepth;
1883     RefPtr&lt;SourceProviderCache&gt; m_functionCache;
<span class="line-removed">1884     SourceElements* m_sourceElements;</span>
1885     bool m_parsingBuiltin;
1886     JSParserScriptMode m_scriptMode;
1887     SuperBinding m_superBinding;
<span class="line-modified">1888     ConstructorKind m_defaultConstructorKind;</span>
<span class="line-removed">1889     VariableEnvironment m_varDeclarations;</span>
<span class="line-removed">1890     DeclarationStacks::FunctionStack m_funcDeclarations;</span>
<span class="line-removed">1891     UniquedStringImplPtrSet m_sloppyModeHoistedFunctions;</span>
<span class="line-removed">1892     CodeFeatures m_features;</span>
<span class="line-removed">1893     int m_numConstants;</span>
1894     ExpressionErrorClassifier* m_expressionErrorClassifier;
1895     bool m_isEvalContext;
1896     bool m_immediateParentAllowsFunctionDeclarationInStatement;
1897     RefPtr&lt;ModuleScopeData&gt; m_moduleScopeData;
1898     DebuggerParseData* m_debuggerParseData;
1899     CallOrApplyDepthScope* m_callOrApplyDepthScope { nullptr };
1900     bool m_seenTaggedTemplate { false };
1901 };
1902 
1903 
1904 template &lt;typename LexerType&gt;
1905 template &lt;class ParsedNode&gt;
<span class="line-modified">1906 std::unique_ptr&lt;ParsedNode&gt; Parser&lt;LexerType&gt;::parse(ParserError&amp; error, const Identifier&amp; calleeName, SourceParseMode parseMode, ParsingContext parsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition)</span>
1907 {
1908     int errLine;
1909     String errMsg;
1910 
1911     if (ParsedNode::scopeIsFunction)
1912         m_lexer-&gt;setIsReparsingFunction();
1913 
<span class="line-removed">1914     m_sourceElements = 0;</span>
<span class="line-removed">1915 </span>
1916     errLine = -1;
1917     errMsg = String();
1918 
1919     JSTokenLocation startLocation(tokenLocation());
1920     ASSERT(m_source-&gt;startColumn() &gt; OrdinalNumber::beforeFirst());
1921     unsigned startColumn = m_source-&gt;startColumn().zeroBasedInt();
1922 
<span class="line-modified">1923     String parseError = parseInner(calleeName, parseMode, parsingContext, functionConstructorParametersEndPosition);</span>
1924 
1925     int lineNumber = m_lexer-&gt;lineNumber();
1926     bool lexError = m_lexer-&gt;sawError();
1927     String lexErrorMessage = lexError ? m_lexer-&gt;getErrorMessage() : String();
1928     ASSERT(lexErrorMessage.isNull() != lexError);
1929     m_lexer-&gt;clear();
1930 
<span class="line-modified">1931     if (!parseError.isNull() || lexError) {</span>
1932         errLine = lineNumber;
<span class="line-modified">1933         errMsg = !lexErrorMessage.isNull() ? lexErrorMessage : parseError;</span>
<span class="line-removed">1934         m_sourceElements = 0;</span>
1935     }
1936 
1937     std::unique_ptr&lt;ParsedNode&gt; result;
<span class="line-modified">1938     if (m_sourceElements) {</span>
1939         JSTokenLocation endLocation;
1940         endLocation.line = m_lexer-&gt;lineNumber();
1941         endLocation.lineStartOffset = m_lexer-&gt;currentLineStartOffset();
1942         endLocation.startOffset = m_lexer-&gt;currentOffset();
1943         unsigned endColumn = endLocation.startOffset - endLocation.lineStartOffset;
1944         result = makeUnique&lt;ParsedNode&gt;(m_parserArena,
1945                                     startLocation,
1946                                     endLocation,
1947                                     startColumn,
1948                                     endColumn,
<span class="line-modified">1949                                     m_sourceElements,</span>
<span class="line-modified">1950                                     m_varDeclarations,</span>
<span class="line-modified">1951                                     WTFMove(m_funcDeclarations),</span>
1952                                     currentScope()-&gt;finalizeLexicalEnvironment(),
<span class="line-modified">1953                                     WTFMove(m_sloppyModeHoistedFunctions),</span>
<span class="line-modified">1954                                     m_parameters,</span>
1955                                     *m_source,
<span class="line-modified">1956                                     m_features,</span>
1957                                     currentScope()-&gt;innerArrowFunctionFeatures(),
<span class="line-modified">1958                                     m_numConstants,</span>
1959                                     WTFMove(m_moduleScopeData));
1960         result-&gt;setLoc(m_source-&gt;firstLine().oneBasedInt(), m_lexer-&gt;lineNumber(), m_lexer-&gt;currentOffset(), m_lexer-&gt;currentLineStartOffset());
1961         result-&gt;setEndOffset(m_lexer-&gt;currentOffset());
1962 
1963         if (!isFunctionParseMode(parseMode)) {
1964             m_source-&gt;provider()-&gt;setSourceURLDirective(m_lexer-&gt;sourceURLDirective());
1965             m_source-&gt;provider()-&gt;setSourceMappingURLDirective(m_lexer-&gt;sourceMappingURLDirective());
1966         }
1967     } else {
1968         // We can never see a syntax error when reparsing a function, since we should have
1969         // reported the error when parsing the containing program or eval code. So if we&#39;re
1970         // parsing a function body node, we assume that what actually happened here is that
1971         // we ran out of stack while parsing. If we see an error while parsing eval or program
1972         // code we assume that it was a syntax error since running out of stack is much less
1973         // likely, and we are currently unable to distinguish between the two cases.
1974         if (isFunctionMetadataNode(static_cast&lt;ParsedNode*&gt;(0)) || m_hasStackOverflow)
1975             error = ParserError(ParserError::StackOverflow, ParserError::SyntaxErrorNone, m_token);
1976         else {
1977             ParserError::SyntaxErrorType errorType = ParserError::SyntaxErrorIrrecoverable;
1978             if (m_token.m_type == EOFTOK)
</pre>
<hr />
<pre>
1984                 else
1985                     errorType = ParserError::SyntaxErrorUnterminatedLiteral;
1986             }
1987 
1988             if (isEvalNode&lt;ParsedNode&gt;())
1989                 error = ParserError(ParserError::EvalError, errorType, m_token, errMsg, errLine);
1990             else
1991                 error = ParserError(ParserError::SyntaxError, errorType, m_token, errMsg, errLine);
1992         }
1993     }
1994 
1995     return result;
1996 }
1997 
1998 template &lt;class ParsedNode&gt;
1999 std::unique_ptr&lt;ParsedNode&gt; parse(
2000     VM&amp; vm, const SourceCode&amp; source,
2001     const Identifier&amp; name, JSParserBuiltinMode builtinMode,
2002     JSParserStrictMode strictMode, JSParserScriptMode scriptMode, SourceParseMode parseMode, SuperBinding superBinding,
2003     ParserError&amp; error, JSTextPosition* positionBeforeLastNewline = nullptr,
<span class="line-modified">2004     ConstructorKind defaultConstructorKind = ConstructorKind::None,</span>
2005     DerivedContextType derivedContextType = DerivedContextType::None,
2006     EvalContextType evalContextType = EvalContextType::None,
<span class="line-modified">2007     DebuggerParseData* debuggerParseData = nullptr)</span>

2008 {
2009     ASSERT(!source.provider()-&gt;source().isNull());
2010 
2011     MonotonicTime before;
2012     if (UNLIKELY(Options::reportParseTimes()))
2013         before = MonotonicTime::now();
2014 
2015     std::unique_ptr&lt;ParsedNode&gt; result;
2016     if (source.provider()-&gt;source().is8Bit()) {
<span class="line-modified">2017         Parser&lt;Lexer&lt;LChar&gt;&gt; parser(vm, source, builtinMode, strictMode, scriptMode, parseMode, superBinding, defaultConstructorKind, derivedContextType, isEvalNode&lt;ParsedNode&gt;(), evalContextType, debuggerParseData);</span>
<span class="line-modified">2018         result = parser.parse&lt;ParsedNode&gt;(error, name, parseMode, isEvalNode&lt;ParsedNode&gt;() ? ParsingContext::Eval : ParsingContext::Program);</span>
2019         if (positionBeforeLastNewline)
2020             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2021         if (builtinMode == JSParserBuiltinMode::Builtin) {
2022             if (!result) {
2023                 ASSERT(error.isValid());
2024                 if (error.type() != ParserError::StackOverflow)
2025                     dataLogLn(&quot;Unexpected error compiling builtin: &quot;, error.message());
2026             }
2027         }
2028     } else {
<span class="line-modified">2029         ASSERT_WITH_MESSAGE(defaultConstructorKind == ConstructorKind::None, &quot;BuiltinExecutables::createDefaultConstructor should always use a 8-bit string&quot;);</span>
<span class="line-modified">2030         Parser&lt;Lexer&lt;UChar&gt;&gt; parser(vm, source, builtinMode, strictMode, scriptMode, parseMode, superBinding, defaultConstructorKind, derivedContextType, isEvalNode&lt;ParsedNode&gt;(), evalContextType, debuggerParseData);</span>
<span class="line-modified">2031         result = parser.parse&lt;ParsedNode&gt;(error, name, parseMode, isEvalNode&lt;ParsedNode&gt;() ? ParsingContext::Eval : ParsingContext::Program);</span>
2032         if (positionBeforeLastNewline)
2033             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2034     }
2035 
2036     if (UNLIKELY(Options::countParseTimes()))
2037         globalParseCount++;
2038 
2039     if (UNLIKELY(Options::reportParseTimes())) {
2040         MonotonicTime after = MonotonicTime::now();
2041         ParseHash hash(source);
2042         dataLogLn(result ? &quot;Parsed #&quot; : &quot;Failed to parse #&quot;, hash.hashForCall(), &quot;/#&quot;, hash.hashForConstruct(), &quot; in &quot;, (after - before).milliseconds(), &quot; ms.&quot;);
2043     }
2044 
2045     return result;
2046 }
2047 
2048 inline std::unique_ptr&lt;ProgramNode&gt; parseFunctionForFunctionConstructor(VM&amp; vm, const SourceCode&amp; source, ParserError&amp; error, JSTextPosition* positionBeforeLastNewline, Optional&lt;int&gt; functionConstructorParametersEndPosition)
2049 {
2050     ASSERT(!source.provider()-&gt;source().isNull());
2051 
</pre>
</td>
<td>
<hr />
<pre>
 164         , m_hasDirectSuper(false)
 165         , m_needsSuperBinding(false)
 166         , m_allowsVarDeclarations(true)
 167         , m_allowsLexicalDeclarations(true)
 168         , m_strictMode(strictMode)
 169         , m_isFunction(isFunction)
 170         , m_isGenerator(isGenerator)
 171         , m_isGeneratorBoundary(false)
 172         , m_isArrowFunction(isArrowFunction)
 173         , m_isArrowFunctionBoundary(false)
 174         , m_isAsyncFunction(isAsyncFunction)
 175         , m_isAsyncFunctionBoundary(false)
 176         , m_isLexicalScope(false)
 177         , m_isGlobalCodeScope(false)
 178         , m_isSimpleCatchParameterScope(false)
 179         , m_isFunctionBoundary(false)
 180         , m_isValidStrictMode(true)
 181         , m_hasArguments(false)
 182         , m_isEvalContext(false)
 183         , m_hasNonSimpleParameterList(false)
<span class="line-added"> 184         , m_isClassScope(false)</span>
 185         , m_evalContextType(EvalContextType::None)
 186         , m_constructorKind(static_cast&lt;unsigned&gt;(ConstructorKind::None))
 187         , m_expectedSuperBinding(static_cast&lt;unsigned&gt;(SuperBinding::NotNeeded))
 188         , m_loopDepth(0)
 189         , m_switchDepth(0)
 190         , m_innerArrowFunctionFeatures(0)
 191     {
 192         m_usedVariables.append(UniquedStringImplPtrSet());
 193     }
 194 
 195     Scope(Scope&amp;&amp;) = default;
 196 
 197     void startSwitch() { m_switchDepth++; }
 198     void endSwitch() { m_switchDepth--; }
 199     void startLoop() { m_loopDepth++; }
 200     void endLoop() { ASSERT(m_loopDepth); m_loopDepth--; }
 201     bool inLoop() { return !!m_loopDepth; }
 202     bool breakIsValid() { return m_loopDepth || m_switchDepth; }
 203     bool continueIsValid() { return m_loopDepth; }
 204 
</pre>
<hr />
<pre>
 242             break;
 243 
 244         case SourceParseMode::GeneratorBodyMode:
 245             setIsGenerator();
 246             break;
 247 
 248         case SourceParseMode::GeneratorWrapperFunctionMode:
 249         case SourceParseMode::GeneratorWrapperMethodMode:
 250             setIsGeneratorFunction();
 251             break;
 252 
 253         case SourceParseMode::AsyncGeneratorWrapperMethodMode:
 254         case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
 255             setIsAsyncGeneratorFunction();
 256             break;
 257 
 258         case SourceParseMode::NormalFunctionMode:
 259         case SourceParseMode::GetterMode:
 260         case SourceParseMode::SetterMode:
 261         case SourceParseMode::MethodMode:
<span class="line-added"> 262         case SourceParseMode::InstanceFieldInitializerMode:</span>
 263             setIsFunction();
 264             break;
 265 
 266         case SourceParseMode::ArrowFunctionMode:
 267             setIsArrowFunction();
 268             break;
 269 
 270         case SourceParseMode::AsyncFunctionMode:
 271         case SourceParseMode::AsyncMethodMode:
 272             setIsAsyncFunction();
 273             break;
 274 
 275         case SourceParseMode::AsyncArrowFunctionMode:
 276             setIsAsyncArrowFunction();
 277             break;
 278 
 279         case SourceParseMode::ProgramMode:
 280         case SourceParseMode::ModuleAnalyzeMode:
 281         case SourceParseMode::ModuleEvaluateMode:
 282             break;
 283         }
 284     }
 285 
 286     bool isFunction() const { return m_isFunction; }
 287     bool isFunctionBoundary() const { return m_isFunctionBoundary; }
 288     bool isGenerator() const { return m_isGenerator; }
 289     bool isGeneratorBoundary() const { return m_isGeneratorBoundary; }
 290     bool isAsyncFunction() const { return m_isAsyncFunction; }
 291     bool isAsyncFunctionBoundary() const { return m_isAsyncFunctionBoundary; }
<span class="line-added"> 292     bool isClassScope() const { return m_isClassScope; }</span>
 293 
 294     bool hasArguments() const { return m_hasArguments; }
 295 
 296     void setIsGlobalCodeScope() { m_isGlobalCodeScope = true; }
 297     bool isGlobalCodeScope() const { return m_isGlobalCodeScope; }
 298 
 299     void setIsSimpleCatchParameterScope() { m_isSimpleCatchParameterScope = true; }
 300     bool isSimpleCatchParameterScope() { return m_isSimpleCatchParameterScope; }
 301 
 302     void setIsLexicalScope()
 303     {
 304         m_isLexicalScope = true;
 305         m_allowsLexicalDeclarations = true;
 306     }
<span class="line-added"> 307 </span>
<span class="line-added"> 308     void setIsClassScope()</span>
<span class="line-added"> 309     {</span>
<span class="line-added"> 310         m_isClassScope = true;</span>
<span class="line-added"> 311     }</span>
<span class="line-added"> 312 </span>
 313     bool isLexicalScope() { return m_isLexicalScope; }
 314     bool usesEval() { return m_usesEval; }
 315 
 316     const HashSet&lt;UniquedStringImpl*&gt;&amp; closedVariableCandidates() const { return m_closedVariableCandidates; }
 317     VariableEnvironment&amp; declaredVariables() { return m_declaredVariables; }
 318     VariableEnvironment&amp; lexicalVariables() { return m_lexicalVariables; }
 319     VariableEnvironment&amp; finalizeLexicalEnvironment()
 320     {
 321         if (m_usesEval || m_needsFullActivation)
 322             m_lexicalVariables.markAllVariablesAsCaptured();
 323         else
 324             computeLexicallyCapturedVariablesAndPurgeCandidates();
 325 
 326         return m_lexicalVariables;
 327     }
 328 
 329     void computeLexicallyCapturedVariablesAndPurgeCandidates()
 330     {
 331         // Because variables may be defined at any time in the range of a lexical scope, we must
 332         // track lexical variables that might be captured. Then, when we&#39;re preparing to pop the top
 333         // lexical scope off the stack, we should find which variables are truly captured, and which
 334         // variable still may be captured in a parent scope.
 335         if (m_lexicalVariables.size() &amp;&amp; m_closedVariableCandidates.size()) {
 336             for (UniquedStringImpl* impl : m_closedVariableCandidates)
 337                 m_lexicalVariables.markVariableAsCapturedIfDefined(impl);
 338         }
 339 
 340         // We can now purge values from the captured candidates because they&#39;re captured in this scope.
 341         {
<span class="line-modified"> 342             for (const auto&amp; entry : m_lexicalVariables) {</span>
 343                 if (entry.value.isCaptured())
 344                     m_closedVariableCandidates.remove(entry.key.get());
 345             }
 346         }
 347     }
 348 
 349     DeclarationResultMask declareCallee(const Identifier* ident)
 350     {
 351         auto addResult = m_declaredVariables.add(ident-&gt;impl());
 352         // We want to track if callee is captured, but we don&#39;t want to act like it&#39;s a &#39;var&#39;
 353         // because that would cause the BytecodeGenerator to emit bad code.
 354         addResult.iterator-&gt;value.clearIsVar();
 355 
 356         DeclarationResultMask result = DeclarationResult::Valid;
 357         if (isEvalOrArgumentsIdentifier(m_vm, ident))
 358             result |= DeclarationResult::InvalidStrictMode;
 359         return result;
 360     }
 361 
 362     DeclarationResultMask declareVariable(const Identifier* ident)
</pre>
<hr />
<pre>
 574 
 575     bool isEvalContext() const { return m_isEvalContext; }
 576     void setIsEvalContext(bool isEvalContext) { m_isEvalContext = isEvalContext; }
 577 
 578     void setInnerArrowFunctionUsesEvalAndUseArgumentsIfNeeded()
 579     {
 580         ASSERT(m_isArrowFunction);
 581 
 582         if (m_usesEval)
 583             setInnerArrowFunctionUsesEval();
 584 
 585         if (usedVariablesContains(m_vm.propertyNames-&gt;arguments.impl()))
 586             setInnerArrowFunctionUsesArguments();
 587     }
 588 
 589     void addClosedVariableCandidateUnconditionally(UniquedStringImpl* impl)
 590     {
 591         m_closedVariableCandidates.add(impl);
 592     }
 593 
<span class="line-added"> 594     void markLastUsedVariablesSetAsCaptured()</span>
<span class="line-added"> 595     {</span>
<span class="line-added"> 596         for (UniquedStringImpl* impl : m_usedVariables.last())</span>
<span class="line-added"> 597             m_closedVariableCandidates.add(impl);</span>
<span class="line-added"> 598     }</span>
<span class="line-added"> 599 </span>
 600     void collectFreeVariables(Scope* nestedScope, bool shouldTrackClosedVariables)
 601     {
 602         if (nestedScope-&gt;m_usesEval)
 603             m_usesEval = true;
 604 
 605         {
 606             UniquedStringImplPtrSet&amp; destinationSet = m_usedVariables.last();
 607             for (const UniquedStringImplPtrSet&amp; usedVariablesSet : nestedScope-&gt;m_usedVariables) {
 608                 for (UniquedStringImpl* impl : usedVariablesSet) {
 609                     if (nestedScope-&gt;m_declaredVariables.contains(impl) || nestedScope-&gt;m_lexicalVariables.contains(impl))
 610                         continue;
 611 
 612                     // &quot;arguments&quot; reference should be resolved at function boudary.
 613                     if (nestedScope-&gt;isFunctionBoundary() &amp;&amp; nestedScope-&gt;hasArguments() &amp;&amp; impl == m_vm.propertyNames-&gt;arguments.impl() &amp;&amp; !nestedScope-&gt;isArrowFunctionBoundary())
 614                         continue;
 615 
 616                     destinationSet.add(impl);
 617                     // We don&#39;t want a declared variable that is used in an inner scope to be thought of as captured if
 618                     // that inner scope is both a lexical scope and not a function. Only inner functions and &quot;catch&quot;
 619                     // statements can cause variables to be captured.
</pre>
<hr />
<pre>
 707         // This is somewhat unfortunate and we should refactor to do this at some point
 708         // because parameters logically form a parent scope to var/let/const variables.
 709         // But because we don&#39;t do this, we must grab capture candidates from a parameter
 710         // list before we parse the body of a function because the body&#39;s declarations
 711         // might make us believe something isn&#39;t actually a capture candidate when it really
 712         // is.
 713         for (UniquedStringImpl* impl : capturesFromParameterExpressions)
 714             parameters.usedVariables.append(impl);
 715     }
 716 
 717     void restoreFromSourceProviderCache(const SourceProviderCacheItem* info)
 718     {
 719         ASSERT(m_isFunction);
 720         m_usesEval = info-&gt;usesEval;
 721         m_strictMode = info-&gt;strictMode;
 722         m_innerArrowFunctionFeatures = info-&gt;innerArrowFunctionFeatures;
 723         m_needsFullActivation = info-&gt;needsFullActivation;
 724         m_needsSuperBinding = info-&gt;needsSuperBinding;
 725         UniquedStringImplPtrSet&amp; destSet = m_usedVariables.last();
 726         for (unsigned i = 0; i &lt; info-&gt;usedVariablesCount; ++i)
<span class="line-modified"> 727             destSet.add(info-&gt;usedVariables()[i].get());</span>
 728     }
 729 
 730     class MaybeParseAsGeneratorForScope;
 731 
 732 private:
 733     void setIsFunction()
 734     {
 735         m_isFunction = true;
 736         m_isFunctionBoundary = true;
 737         m_hasArguments = true;
 738         setIsLexicalScope();
 739         m_isGenerator = false;
 740         m_isGeneratorBoundary = false;
 741         m_isArrowFunctionBoundary = false;
 742         m_isArrowFunction = false;
 743         m_isAsyncFunction = false;
 744         m_isAsyncFunctionBoundary = false;
 745     }
 746 
 747     void setIsGeneratorFunction()
</pre>
<hr />
<pre>
 817     bool m_hasDirectSuper;
 818     bool m_needsSuperBinding;
 819     bool m_allowsVarDeclarations;
 820     bool m_allowsLexicalDeclarations;
 821     bool m_strictMode;
 822     bool m_isFunction;
 823     bool m_isGenerator;
 824     bool m_isGeneratorBoundary;
 825     bool m_isArrowFunction;
 826     bool m_isArrowFunctionBoundary;
 827     bool m_isAsyncFunction;
 828     bool m_isAsyncFunctionBoundary;
 829     bool m_isLexicalScope;
 830     bool m_isGlobalCodeScope;
 831     bool m_isSimpleCatchParameterScope;
 832     bool m_isFunctionBoundary;
 833     bool m_isValidStrictMode;
 834     bool m_hasArguments;
 835     bool m_isEvalContext;
 836     bool m_hasNonSimpleParameterList;
<span class="line-added"> 837     bool m_isClassScope;</span>
 838     EvalContextType m_evalContextType;
 839     unsigned m_constructorKind;
 840     unsigned m_expectedSuperBinding;
 841     int m_loopDepth;
 842     int m_switchDepth;
 843     InnerArrowFunctionCodeFeatures m_innerArrowFunctionFeatures;
 844 
 845     typedef Vector&lt;ScopeLabelInfo, 2&gt; LabelStack;
 846     std::unique_ptr&lt;LabelStack&gt; m_labels;
 847     UniquedStringImplPtrSet m_declaredParameters;
 848     VariableEnvironment m_declaredVariables;
 849     VariableEnvironment m_lexicalVariables;
 850     Vector&lt;UniquedStringImplPtrSet, 6&gt; m_usedVariables;
 851     UniquedStringImplPtrSet m_variablesBeingHoisted;
 852     UniquedStringImplPtrSet m_sloppyModeHoistableFunctionCandidates;
 853     HashSet&lt;UniquedStringImpl*&gt; m_closedVariableCandidates;
 854     DeclarationStacks::FunctionStack m_functionDeclarations;
 855 };
 856 
 857 typedef Vector&lt;Scope, 10&gt; ScopeStack;
</pre>
<hr />
<pre>
 884 
 885     bool operator!=(const ScopeRef&amp; other)
 886     {
 887         return !(*this == other);
 888     }
 889 
 890 private:
 891     ScopeStack* m_scopeStack;
 892     unsigned m_index;
 893 };
 894 
 895 enum class ArgumentType { Normal, Spread };
 896 enum class ParsingContext { Program, FunctionConstructor, Eval };
 897 
 898 template &lt;typename LexerType&gt;
 899 class Parser {
 900     WTF_MAKE_NONCOPYABLE(Parser);
 901     WTF_MAKE_FAST_ALLOCATED;
 902 
 903 public:
<span class="line-modified"> 904     Parser(VM&amp;, const SourceCode&amp;, JSParserBuiltinMode, JSParserStrictMode, JSParserScriptMode, SourceParseMode, SuperBinding, ConstructorKind defaultConstructorKindForTopLevelFunction = ConstructorKind::None, DerivedContextType = DerivedContextType::None, bool isEvalContext = false, EvalContextType = EvalContextType::None, DebuggerParseData* = nullptr);</span>
 905     ~Parser();
 906 
 907     template &lt;class ParsedNode&gt;
<span class="line-modified"> 908     std::unique_ptr&lt;ParsedNode&gt; parse(ParserError&amp;, const Identifier&amp;, SourceParseMode, ParsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt, const Vector&lt;JSTextPosition&gt;* = nullptr);</span>
 909 
 910     JSTextPosition positionBeforeLastNewline() const { return m_lexer-&gt;positionBeforeLastNewline(); }
 911     JSTokenLocation locationBeforeLastToken() const { return m_lexer-&gt;lastTokenLocation(); }
 912 
 913     struct CallOrApplyDepthScope {
 914         CallOrApplyDepthScope(Parser* parser)
 915             : m_parser(parser)
 916             , m_parent(parser-&gt;m_callOrApplyDepthScope)
 917             , m_depth(m_parent ? m_parent-&gt;m_depth + 1 : 0)
 918             , m_depthOfInnermostChild(m_depth)
 919         {
 920             parser-&gt;m_callOrApplyDepthScope = this;
 921         }
 922 
 923         size_t distanceToInnermostChild() const
 924         {
 925             ASSERT(m_depthOfInnermostChild &gt;= m_depth);
 926             return m_depthOfInnermostChild - m_depth;
 927         }
 928 
</pre>
<hr />
<pre>
1171         unsigned i = m_scopeStack.size() - 1;
1172         ASSERT(i &lt; m_scopeStack.size());
1173         while (i &amp;&amp; !m_scopeStack[i].isFunctionBoundary()) {
1174             i--;
1175             ASSERT(i &lt; m_scopeStack.size());
1176         }
1177         // When reaching the top level scope (it can be non function scope), we return it.
1178         return ScopeRef(&amp;m_scopeStack, i);
1179     }
1180 
1181     ScopeRef closestParentOrdinaryFunctionNonLexicalScope()
1182     {
1183         unsigned i = m_scopeStack.size() - 1;
1184         ASSERT(i &lt; m_scopeStack.size() &amp;&amp; m_scopeStack.size());
1185         while (i &amp;&amp; (!m_scopeStack[i].isFunctionBoundary() || m_scopeStack[i].isGeneratorBoundary() || m_scopeStack[i].isAsyncFunctionBoundary() || m_scopeStack[i].isArrowFunctionBoundary()))
1186             i--;
1187         // When reaching the top level scope (it can be non ordinary function scope), we return it.
1188         return ScopeRef(&amp;m_scopeStack, i);
1189     }
1190 
<span class="line-added">1191     ScopeRef closestClassScopeOrTopLevelScope()</span>
<span class="line-added">1192     {</span>
<span class="line-added">1193         unsigned i = m_scopeStack.size() - 1;</span>
<span class="line-added">1194         ASSERT(i &lt; m_scopeStack.size());</span>
<span class="line-added">1195         while (i &amp;&amp; !m_scopeStack[i].isClassScope())</span>
<span class="line-added">1196             i--;</span>
<span class="line-added">1197         return ScopeRef(&amp;m_scopeStack, i);</span>
<span class="line-added">1198     }</span>
<span class="line-added">1199 </span>
1200     ScopeRef pushScope()
1201     {
1202         bool isFunction = false;
1203         bool isStrict = false;
1204         bool isGenerator = false;
1205         bool isArrowFunction = false;
1206         bool isAsyncFunction = false;
1207         if (!m_scopeStack.isEmpty()) {
1208             isStrict = m_scopeStack.last().strictMode();
1209             isFunction = m_scopeStack.last().isFunction();
1210             isGenerator = m_scopeStack.last().isGenerator();
1211             isArrowFunction = m_scopeStack.last().isArrowFunction();
1212             isAsyncFunction = m_scopeStack.last().isAsyncFunction();
1213         }
1214         m_scopeStack.constructAndAppend(m_vm, isFunction, isGenerator, isStrict, isArrowFunction, isAsyncFunction);
1215         return currentScope();
1216     }
1217 
1218     void popScopeInternal(ScopeRef&amp; scope, bool shouldTrackClosedVariables)
1219     {
</pre>
<hr />
<pre>
1355         }
1356         return m_scopeStack[i].hasDeclaredParameter(ident);
1357     }
1358 
1359     bool exportName(const Identifier&amp; ident)
1360     {
1361         ASSERT(currentScope().index() == 0);
1362         ASSERT(m_moduleScopeData);
1363         return m_moduleScopeData-&gt;exportName(ident);
1364     }
1365 
1366     ScopeStack m_scopeStack;
1367 
1368     const SourceProviderCacheItem* findCachedFunctionInfo(int openBracePos)
1369     {
1370         return m_functionCache ? m_functionCache-&gt;get(openBracePos) : 0;
1371     }
1372 
1373     Parser();
1374 
<span class="line-modified">1375     struct ParseInnerResult {</span>
<span class="line-modified">1376         FunctionParameters* parameters;</span>
<span class="line-modified">1377         SourceElements* sourceElements;</span>
<span class="line-added">1378         DeclarationStacks::FunctionStack functionDeclarations;</span>
<span class="line-added">1379         VariableEnvironment varDeclarations;</span>
<span class="line-added">1380         UniquedStringImplPtrSet sloppyModeHoistedFunctions;</span>
<span class="line-added">1381         CodeFeatures features;</span>
<span class="line-added">1382         int numConstants;</span>
<span class="line-added">1383     };</span>
<span class="line-added">1384     Expected&lt;ParseInnerResult, String&gt; parseInner(const Identifier&amp;, SourceParseMode, ParsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt, const Vector&lt;JSTextPosition&gt;* = nullptr);</span>
1385 
1386     // Used to determine type of error to report.
1387     bool isFunctionMetadataNode(ScopeNode*) { return false; }
1388     bool isFunctionMetadataNode(FunctionMetadataNode*) { return true; }
1389 
<span class="line-modified">1390     ALWAYS_INLINE void next(OptionSet&lt;LexerFlags&gt; lexerFlags = { })</span>
1391     {
1392         int lastLine = m_token.m_location.line;
1393         int lastTokenEnd = m_token.m_location.endOffset;
1394         int lastTokenLineStart = m_token.m_location.lineStartOffset;
1395         m_lastTokenEndPosition = JSTextPosition(lastLine, lastTokenEnd, lastTokenLineStart);
1396         m_lexer-&gt;setLastLineNumber(lastLine);
1397         m_token.m_type = m_lexer-&gt;lex(&amp;m_token, lexerFlags, strictMode());
1398     }
1399 
<span class="line-modified">1400     ALWAYS_INLINE void nextWithoutClearingLineTerminator(OptionSet&lt;LexerFlags&gt; lexerFlags = { })</span>
1401     {
1402         int lastLine = m_token.m_location.line;
1403         int lastTokenEnd = m_token.m_location.endOffset;
1404         int lastTokenLineStart = m_token.m_location.lineStartOffset;
1405         m_lastTokenEndPosition = JSTextPosition(lastLine, lastTokenEnd, lastTokenLineStart);
1406         m_lexer-&gt;setLastLineNumber(lastLine);
1407         m_token.m_type = m_lexer-&gt;lexWithoutClearingLineTerminator(&amp;m_token, lexerFlags, strictMode());
1408     }
1409 
<span class="line-modified">1410     ALWAYS_INLINE void nextExpectIdentifier(OptionSet&lt;LexerFlags&gt; lexerFlags = { })</span>
1411     {
1412         int lastLine = m_token.m_location.line;
1413         int lastTokenEnd = m_token.m_location.endOffset;
1414         int lastTokenLineStart = m_token.m_location.lineStartOffset;
1415         m_lastTokenEndPosition = JSTextPosition(lastLine, lastTokenEnd, lastTokenLineStart);
1416         m_lexer-&gt;setLastLineNumber(lastLine);
1417         m_token.m_type = m_lexer-&gt;lexExpectIdentifier(&amp;m_token, lexerFlags, strictMode());
1418     }
1419 
<span class="line-modified">1420     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">1421     ALWAYS_INLINE void lexCurrentTokenAgainUnderCurrentContext(TreeBuilder&amp; context)</span>
1422     {
<span class="line-modified">1423         auto savePoint = createSavePoint(context);</span>
<span class="line-modified">1424         restoreSavePoint(context, savePoint);</span>
1425     }
1426 
1427     ALWAYS_INLINE bool nextTokenIsColon()
1428     {
1429         return m_lexer-&gt;nextTokenIsColon();
1430     }
1431 
<span class="line-modified">1432     ALWAYS_INLINE bool consume(JSTokenType expected, OptionSet&lt;LexerFlags&gt; flags = { })</span>
1433     {
1434         bool result = m_token.m_type == expected;
1435         if (result)
1436             next(flags);
1437         return result;
1438     }
1439 
1440     void printUnexpectedTokenText(WTF::PrintStream&amp;);
1441     ALWAYS_INLINE StringView getToken()
1442     {
1443         return m_lexer-&gt;getToken(m_token);
1444     }
1445 
1446     ALWAYS_INLINE StringView getToken(const JSToken&amp; token)
1447     {
1448         return m_lexer-&gt;getToken(token);
1449     }
1450 
1451     ALWAYS_INLINE bool match(JSTokenType expected)
1452     {
</pre>
<hr />
<pre>
1592     {
1593         return match(YIELD) &amp;&amp; !strictMode() &amp;&amp; !inGenerator;
1594     }
1595 
1596     // http://ecma-international.org/ecma-262/6.0/#sec-generator-function-definitions-static-semantics-early-errors
1597     ALWAYS_INLINE bool matchSpecIdentifier(bool inGenerator)
1598     {
1599         return match(IDENT) || isLETMaskedAsIDENT() || isYIELDMaskedAsIDENT(inGenerator) || isSafeContextualKeyword(m_token);
1600     }
1601 
1602     ALWAYS_INLINE bool matchSpecIdentifier()
1603     {
1604         return match(IDENT) || isLETMaskedAsIDENT() || isYIELDMaskedAsIDENT(currentScope()-&gt;isGenerator()) || isSafeContextualKeyword(m_token);
1605     }
1606 
1607     template &lt;class TreeBuilder&gt; TreeSourceElements parseSourceElements(TreeBuilder&amp;, SourceElementsMode);
1608     template &lt;class TreeBuilder&gt; TreeSourceElements parseGeneratorFunctionSourceElements(TreeBuilder&amp;, const Identifier&amp; name, SourceElementsMode);
1609     template &lt;class TreeBuilder&gt; TreeSourceElements parseAsyncFunctionSourceElements(TreeBuilder&amp;, SourceParseMode, bool isArrowFunctionBodyExpression, SourceElementsMode);
1610     template &lt;class TreeBuilder&gt; TreeSourceElements parseAsyncGeneratorFunctionSourceElements(TreeBuilder&amp;, SourceParseMode, bool isArrowFunctionBodyExpression, SourceElementsMode);
1611     template &lt;class TreeBuilder&gt; TreeSourceElements parseSingleFunction(TreeBuilder&amp;, Optional&lt;int&gt; functionConstructorParametersEndPosition);
<span class="line-added">1612     template &lt;class TreeBuilder&gt; TreeSourceElements parseInstanceFieldInitializerSourceElements(TreeBuilder&amp;, const Vector&lt;JSTextPosition&gt;&amp;);</span>
1613     template &lt;class TreeBuilder&gt; TreeStatement parseStatementListItem(TreeBuilder&amp;, const Identifier*&amp; directive, unsigned* directiveLiteralLength);
1614     template &lt;class TreeBuilder&gt; TreeStatement parseStatement(TreeBuilder&amp;, const Identifier*&amp; directive, unsigned* directiveLiteralLength = 0);
1615     enum class ExportType { Exported, NotExported };
1616     template &lt;class TreeBuilder&gt; TreeStatement parseClassDeclaration(TreeBuilder&amp;, ExportType = ExportType::NotExported, DeclarationDefaultContext = DeclarationDefaultContext::Standard);
1617     template &lt;class TreeBuilder&gt; TreeStatement parseFunctionDeclaration(TreeBuilder&amp;, ExportType = ExportType::NotExported, DeclarationDefaultContext = DeclarationDefaultContext::Standard, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
1618     template &lt;class TreeBuilder&gt; TreeStatement parseFunctionDeclarationStatement(TreeBuilder&amp;, bool isAsync, bool parentAllowsFunctionDeclarationAsStatement);
1619     template &lt;class TreeBuilder&gt; TreeStatement parseAsyncFunctionDeclaration(TreeBuilder&amp;, ExportType = ExportType::NotExported, DeclarationDefaultContext = DeclarationDefaultContext::Standard, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
1620     template &lt;class TreeBuilder&gt; NEVER_INLINE bool maybeParseAsyncFunctionDeclarationStatement(TreeBuilder&amp; context, TreeStatement&amp; result, bool parentAllowsFunctionDeclarationAsStatement);
1621     template &lt;class TreeBuilder&gt; TreeStatement parseVariableDeclaration(TreeBuilder&amp;, DeclarationType, ExportType = ExportType::NotExported);
1622     template &lt;class TreeBuilder&gt; TreeStatement parseDoWhileStatement(TreeBuilder&amp;);
1623     template &lt;class TreeBuilder&gt; TreeStatement parseWhileStatement(TreeBuilder&amp;);
1624     template &lt;class TreeBuilder&gt; TreeStatement parseForStatement(TreeBuilder&amp;);
1625     template &lt;class TreeBuilder&gt; TreeStatement parseBreakStatement(TreeBuilder&amp;);
1626     template &lt;class TreeBuilder&gt; TreeStatement parseContinueStatement(TreeBuilder&amp;);
1627     template &lt;class TreeBuilder&gt; TreeStatement parseReturnStatement(TreeBuilder&amp;);
1628     template &lt;class TreeBuilder&gt; TreeStatement parseThrowStatement(TreeBuilder&amp;);
1629     template &lt;class TreeBuilder&gt; TreeStatement parseWithStatement(TreeBuilder&amp;);
1630     template &lt;class TreeBuilder&gt; TreeStatement parseSwitchStatement(TreeBuilder&amp;);
1631     template &lt;class TreeBuilder&gt; TreeClauseList parseSwitchClauses(TreeBuilder&amp;);
1632     template &lt;class TreeBuilder&gt; TreeClause parseSwitchDefaultClause(TreeBuilder&amp;);
1633     template &lt;class TreeBuilder&gt; TreeStatement parseTryStatement(TreeBuilder&amp;);
1634     template &lt;class TreeBuilder&gt; TreeStatement parseDebuggerStatement(TreeBuilder&amp;);
1635     template &lt;class TreeBuilder&gt; TreeStatement parseExpressionStatement(TreeBuilder&amp;);
1636     template &lt;class TreeBuilder&gt; TreeStatement parseExpressionOrLabelStatement(TreeBuilder&amp;, bool allowFunctionDeclarationAsStatement);
1637     template &lt;class TreeBuilder&gt; TreeStatement parseIfStatement(TreeBuilder&amp;);
1638     template &lt;class TreeBuilder&gt; TreeStatement parseBlockStatement(TreeBuilder&amp;);
1639     template &lt;class TreeBuilder&gt; TreeExpression parseExpression(TreeBuilder&amp;);
1640     template &lt;class TreeBuilder&gt; TreeExpression parseAssignmentExpression(TreeBuilder&amp;, ExpressionErrorClassifier&amp;);
1641     template &lt;class TreeBuilder&gt; TreeExpression parseAssignmentExpression(TreeBuilder&amp;);
1642     template &lt;class TreeBuilder&gt; TreeExpression parseAssignmentExpressionOrPropagateErrorClass(TreeBuilder&amp;);
1643     template &lt;class TreeBuilder&gt; TreeExpression parseYieldExpression(TreeBuilder&amp;);
1644     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseConditionalExpression(TreeBuilder&amp;);
1645     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseBinaryExpression(TreeBuilder&amp;);
1646     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseUnaryExpression(TreeBuilder&amp;);
1647     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeExpression parseAwaitExpression(TreeBuilder&amp;);
1648     template &lt;class TreeBuilder&gt; TreeExpression parseMemberExpression(TreeBuilder&amp;);
1649     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parsePrimaryExpression(TreeBuilder&amp;);
1650     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseArrayLiteral(TreeBuilder&amp;);
1651     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseObjectLiteral(TreeBuilder&amp;);

1652     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeClassExpression parseClassExpression(TreeBuilder&amp;);
1653     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseFunctionExpression(TreeBuilder&amp;);
1654     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseAsyncFunctionExpression(TreeBuilder&amp;);
1655     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeArguments parseArguments(TreeBuilder&amp;);
1656     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseArgument(TreeBuilder&amp;, ArgumentType&amp;);
1657     template &lt;class TreeBuilder&gt; TreeProperty parseProperty(TreeBuilder&amp;, bool strict);
1658     template &lt;class TreeBuilder&gt; TreeExpression parsePropertyMethod(TreeBuilder&amp; context, const Identifier* methodName, SourceParseMode);
1659     template &lt;class TreeBuilder&gt; TreeProperty parseGetterSetter(TreeBuilder&amp;, bool strict, PropertyNode::Type, unsigned getterOrSetterStartOffset, ConstructorKind, ClassElementTag);
1660     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeFunctionBody parseFunctionBody(TreeBuilder&amp;, SyntaxChecker&amp;, const JSTokenLocation&amp;, int, int functionKeywordStart, int functionNameStart, int parametersStart, ConstructorKind, SuperBinding, FunctionBodyType, unsigned, SourceParseMode);
1661     template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool parseFormalParameters(TreeBuilder&amp;, TreeFormalParameterList, bool isArrowFunction, bool isMethod, unsigned&amp;);
1662     enum VarDeclarationListContext { ForLoopContext, VarDeclarationContext };
1663     template &lt;class TreeBuilder&gt; TreeExpression parseVariableDeclarationList(TreeBuilder&amp;, int&amp; declarations, TreeDestructuringPattern&amp; lastPattern, TreeExpression&amp; lastInitializer, JSTextPosition&amp; identStart, JSTextPosition&amp; initStart, JSTextPosition&amp; initEnd, VarDeclarationListContext, DeclarationType, ExportType, bool&amp; forLoopConstDoesNotHaveInitializer);
1664     template &lt;class TreeBuilder&gt; TreeSourceElements parseArrowFunctionSingleExpressionBodySourceElements(TreeBuilder&amp;);
1665     template &lt;class TreeBuilder&gt; TreeExpression parseArrowFunctionExpression(TreeBuilder&amp;, bool isAsync);
<span class="line-modified">1666     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern createBindingPattern(TreeBuilder&amp;, DestructuringKind, ExportType, const Identifier&amp;, const JSToken&amp;, AssignmentContext, const Identifier** duplicateIdentifier);</span>
1667     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern createAssignmentElement(TreeBuilder&amp;, TreeExpression&amp;, const JSTextPosition&amp;, const JSTextPosition&amp;);
1668     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseObjectRestBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind, ExportType, const Identifier** duplicateIdentifier, AssignmentContext bindingContext);
1669     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind, ExportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth);
1670     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseObjectRestAssignmentElement(TreeBuilder&amp; context);
1671     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseAssignmentElement(TreeBuilder&amp; context, DestructuringKind, ExportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth);
1672     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseObjectRestElement(TreeBuilder&amp;, DestructuringKind, ExportType, const Identifier** duplicateIdentifier = nullptr, AssignmentContext = AssignmentContext::DeclarationStatement);
1673     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseDestructuringPattern(TreeBuilder&amp;, DestructuringKind, ExportType, const Identifier** duplicateIdentifier = nullptr, bool* hasDestructuringPattern = nullptr, AssignmentContext = AssignmentContext::DeclarationStatement, int depth = 0);
1674     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern tryParseDestructuringPatternExpression(TreeBuilder&amp;, AssignmentContext);
1675     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeExpression parseDefaultValueForDestructuringPattern(TreeBuilder&amp;);
1676     template &lt;class TreeBuilder&gt; TreeSourceElements parseModuleSourceElements(TreeBuilder&amp;, SourceParseMode);
1677     enum class ImportSpecifierType { NamespaceImport, NamedImport, DefaultImport };
1678     template &lt;class TreeBuilder&gt; typename TreeBuilder::ImportSpecifier parseImportClauseItem(TreeBuilder&amp;, ImportSpecifierType);
1679     template &lt;class TreeBuilder&gt; typename TreeBuilder::ModuleName parseModuleName(TreeBuilder&amp;);
1680     template &lt;class TreeBuilder&gt; TreeStatement parseImportDeclaration(TreeBuilder&amp;);
1681     template &lt;class TreeBuilder&gt; typename TreeBuilder::ExportSpecifier parseExportSpecifier(TreeBuilder&amp; context, Vector&lt;std::pair&lt;const Identifier*, const Identifier*&gt;&gt;&amp; maybeExportedLocalNames, bool&amp; hasKeywordForLocalBindings);
1682     template &lt;class TreeBuilder&gt; TreeStatement parseExportDeclaration(TreeBuilder&amp;);
1683 
1684     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression createResolveAndUseVariable(TreeBuilder&amp;, const Identifier*, bool isEval, const JSTextPosition&amp;, const JSTokenLocation&amp;);
1685 
1686     enum class FunctionDefinitionType { Expression, Declaration, Method };
1687     template &lt;class TreeBuilder&gt; NEVER_INLINE bool parseFunctionInfo(TreeBuilder&amp;, FunctionNameRequirements, SourceParseMode, bool nameIsInContainingScope, ConstructorKind, SuperBinding, int functionKeywordStart, ParserFunctionInfo&lt;TreeBuilder&gt;&amp;, FunctionDefinitionType, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
1688 
<span class="line-modified">1689     template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool isArrowFunctionParameters(TreeBuilder&amp;);</span>
1690 
1691     template &lt;class TreeBuilder, class FunctionInfoType&gt; NEVER_INLINE typename TreeBuilder::FormalParameterList parseFunctionParameters(TreeBuilder&amp;, SourceParseMode, FunctionInfoType&amp;);
1692     template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::FormalParameterList createGeneratorParameters(TreeBuilder&amp;, unsigned&amp; parameterCount);
1693 
1694     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeClassExpression parseClass(TreeBuilder&amp;, FunctionNameRequirements, ParserClassInfo&lt;TreeBuilder&gt;&amp;);
1695 
1696     template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::TemplateString parseTemplateString(TreeBuilder&amp; context, bool isTemplateHead, typename LexerType::RawStringsBuildMode, bool&amp; elementIsTail);
1697     template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::TemplateLiteral parseTemplateLiteral(TreeBuilder&amp;, typename LexerType::RawStringsBuildMode);
1698 
1699     template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool shouldCheckPropertyForUnderscoreProtoDuplicate(TreeBuilder&amp;, const TreeProperty&amp;);
1700 
1701     template &lt;class TreeBuilder&gt; NEVER_INLINE const char* metaPropertyName(TreeBuilder&amp;, TreeExpression);
1702 
1703     template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool isSimpleAssignmentTarget(TreeBuilder&amp;, TreeExpression);
1704 
1705     ALWAYS_INLINE int isBinaryOperator(JSTokenType);
1706     bool allowAutomaticSemicolon();
1707 
1708     bool autoSemiColon()
1709     {
</pre>
<hr />
<pre>
1775             return &quot;in a module&quot;;
1776         RELEASE_ASSERT_NOT_REACHED();
1777         return nullptr;
1778     }
1779 
1780     const char* disallowedIdentifierYieldReason()
1781     {
1782         if (strictMode())
1783             return &quot;in strict mode&quot;;
1784         if (currentScope()-&gt;isGenerator())
1785             return &quot;in a generator function&quot;;
1786         RELEASE_ASSERT_NOT_REACHED();
1787         return nullptr;
1788     }
1789 
1790     enum class FunctionParsePhase { Parameters, Body };
1791     struct ParserState {
1792         int assignmentCount { 0 };
1793         int nonLHSCount { 0 };
1794         int nonTrivialExpressionCount { 0 };
<span class="line-added">1795         int unaryTokenStackDepth { 0 };</span>
1796         FunctionParsePhase functionParsePhase { FunctionParsePhase::Body };
1797         const Identifier* lastIdentifier { nullptr };
1798         const Identifier* lastFunctionName { nullptr };
1799         bool allowAwait { true };
<span class="line-added">1800         bool isParsingClassFieldInitializer { false };</span>
1801     };
1802 
1803     // If you&#39;re using this directly, you probably should be using
1804     // createSavePoint() instead.
<span class="line-modified">1805     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">1806     ALWAYS_INLINE ParserState internalSaveParserState(TreeBuilder&amp; context)</span>
1807     {
<span class="line-modified">1808         auto parserState = m_parserState;</span>
<span class="line-added">1809         parserState.unaryTokenStackDepth = context.unaryTokenStackDepth();</span>
<span class="line-added">1810         return parserState;</span>
1811     }
1812 
<span class="line-modified">1813     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">1814     ALWAYS_INLINE void restoreParserState(TreeBuilder&amp; context, const ParserState&amp; state)</span>
1815     {
1816         m_parserState = state;
<span class="line-added">1817         context.setUnaryTokenStackDepth(m_parserState.unaryTokenStackDepth);</span>
1818     }
1819 
1820     struct LexerState {
1821         int startOffset;
1822         unsigned oldLineStartOffset;
1823         unsigned oldLastLineNumber;
1824         unsigned oldLineNumber;
1825         bool hasLineTerminatorBeforeToken;
1826     };
1827 
1828     // If you&#39;re using this directly, you probably should be using
1829     // createSavePoint() instead.
1830     // i.e, if you parse any kind of AssignmentExpression between
1831     // saving/restoring, you should definitely not be using this directly.
1832     ALWAYS_INLINE LexerState internalSaveLexerState()
1833     {
1834         LexerState result;
1835         result.startOffset = m_token.m_location.startOffset;
1836         result.oldLineStartOffset = m_token.m_location.lineStartOffset;
1837         result.oldLastLineNumber = m_lexer-&gt;lastLineNumber();
</pre>
<hr />
<pre>
1845     {
1846         // setOffset clears lexer errors.
1847         m_lexer-&gt;setOffset(lexerState.startOffset, lexerState.oldLineStartOffset);
1848         m_lexer-&gt;setLineNumber(lexerState.oldLineNumber);
1849         m_lexer-&gt;setHasLineTerminatorBeforeToken(lexerState.hasLineTerminatorBeforeToken);
1850         nextWithoutClearingLineTerminator();
1851         m_lexer-&gt;setLastLineNumber(lexerState.oldLastLineNumber);
1852     }
1853 
1854     struct SavePoint {
1855         ParserState parserState;
1856         LexerState lexerState;
1857     };
1858 
1859     struct SavePointWithError : public SavePoint {
1860         bool lexerError;
1861         String lexerErrorMessage;
1862         String parserErrorMessage;
1863     };
1864 
<span class="line-modified">1865     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">1866     ALWAYS_INLINE void internalSaveState(TreeBuilder&amp; context, SavePoint&amp; savePoint)</span>
1867     {
<span class="line-modified">1868         savePoint.parserState = internalSaveParserState(context);</span>
1869         savePoint.lexerState = internalSaveLexerState();
1870     }
1871 
<span class="line-modified">1872     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">1873     ALWAYS_INLINE SavePointWithError swapSavePointForError(TreeBuilder&amp; context, SavePoint&amp; oldSavePoint)</span>
1874     {
1875         SavePointWithError savePoint;
<span class="line-modified">1876         internalSaveState(context, savePoint);</span>
1877         savePoint.lexerError = m_lexer-&gt;sawError();
1878         savePoint.lexerErrorMessage = m_lexer-&gt;getErrorMessage();
1879         savePoint.parserErrorMessage = m_errorMessage;
<span class="line-added">1880         // Make sure we set our new savepoints unary stack to what oldSavePoint had as it currently may contain stale info.</span>
<span class="line-added">1881         savePoint.parserState.unaryTokenStackDepth = oldSavePoint.parserState.unaryTokenStackDepth;</span>
<span class="line-added">1882         restoreSavePoint(context, oldSavePoint);</span>
1883         return savePoint;
1884     }
1885 
<span class="line-modified">1886     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">1887     ALWAYS_INLINE SavePoint createSavePoint(TreeBuilder&amp; context)</span>
1888     {
1889         ASSERT(!hasError());
1890         SavePoint savePoint;
<span class="line-modified">1891         internalSaveState(context, savePoint);</span>
1892         return savePoint;
1893     }
1894 
<span class="line-modified">1895     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">1896     ALWAYS_INLINE void internalRestoreState(TreeBuilder&amp; context, const SavePoint&amp; savePoint)</span>
1897     {
1898         restoreLexerState(savePoint.lexerState);
<span class="line-modified">1899         restoreParserState(context, savePoint.parserState);</span>
1900     }
1901 
<span class="line-modified">1902     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">1903     ALWAYS_INLINE void restoreSavePointWithError(TreeBuilder&amp; context, const SavePointWithError&amp; savePoint)</span>
1904     {
<span class="line-modified">1905         internalRestoreState(context, savePoint);</span>
1906         m_lexer-&gt;setSawError(savePoint.lexerError);
1907         m_lexer-&gt;setErrorMessage(savePoint.lexerErrorMessage);
1908         m_errorMessage = savePoint.parserErrorMessage;
1909     }
1910 
<span class="line-modified">1911     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">1912     ALWAYS_INLINE void restoreSavePoint(TreeBuilder&amp; context, const SavePoint&amp; savePoint)</span>
1913     {
<span class="line-modified">1914         internalRestoreState(context, savePoint);</span>
1915         m_errorMessage = String();
1916     }
1917 
1918     VM&amp; m_vm;
1919     const SourceCode* m_source;
1920     ParserArena m_parserArena;
1921     std::unique_ptr&lt;LexerType&gt; m_lexer;

1922 
1923     ParserState m_parserState;
1924 
1925     bool m_hasStackOverflow;
1926     String m_errorMessage;
1927     JSToken m_token;
1928     bool m_allowsIn;
1929     JSTextPosition m_lastTokenEndPosition;
1930     int m_statementDepth;
1931     RefPtr&lt;SourceProviderCache&gt; m_functionCache;

1932     bool m_parsingBuiltin;
1933     JSParserScriptMode m_scriptMode;
1934     SuperBinding m_superBinding;
<span class="line-modified">1935     ConstructorKind m_defaultConstructorKindForTopLevelFunction;</span>





1936     ExpressionErrorClassifier* m_expressionErrorClassifier;
1937     bool m_isEvalContext;
1938     bool m_immediateParentAllowsFunctionDeclarationInStatement;
1939     RefPtr&lt;ModuleScopeData&gt; m_moduleScopeData;
1940     DebuggerParseData* m_debuggerParseData;
1941     CallOrApplyDepthScope* m_callOrApplyDepthScope { nullptr };
1942     bool m_seenTaggedTemplate { false };
1943 };
1944 
1945 
1946 template &lt;typename LexerType&gt;
1947 template &lt;class ParsedNode&gt;
<span class="line-modified">1948 std::unique_ptr&lt;ParsedNode&gt; Parser&lt;LexerType&gt;::parse(ParserError&amp; error, const Identifier&amp; calleeName, SourceParseMode parseMode, ParsingContext parsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition, const Vector&lt;JSTextPosition&gt;* instanceFieldLocations)</span>
1949 {
1950     int errLine;
1951     String errMsg;
1952 
1953     if (ParsedNode::scopeIsFunction)
1954         m_lexer-&gt;setIsReparsingFunction();
1955 


1956     errLine = -1;
1957     errMsg = String();
1958 
1959     JSTokenLocation startLocation(tokenLocation());
1960     ASSERT(m_source-&gt;startColumn() &gt; OrdinalNumber::beforeFirst());
1961     unsigned startColumn = m_source-&gt;startColumn().zeroBasedInt();
1962 
<span class="line-modified">1963     auto parseResult = parseInner(calleeName, parseMode, parsingContext, functionConstructorParametersEndPosition, instanceFieldLocations);</span>
1964 
1965     int lineNumber = m_lexer-&gt;lineNumber();
1966     bool lexError = m_lexer-&gt;sawError();
1967     String lexErrorMessage = lexError ? m_lexer-&gt;getErrorMessage() : String();
1968     ASSERT(lexErrorMessage.isNull() != lexError);
1969     m_lexer-&gt;clear();
1970 
<span class="line-modified">1971     if (!parseResult || lexError) {</span>
1972         errLine = lineNumber;
<span class="line-modified">1973         errMsg = !lexErrorMessage.isNull() ? lexErrorMessage : parseResult.error();</span>

1974     }
1975 
1976     std::unique_ptr&lt;ParsedNode&gt; result;
<span class="line-modified">1977     if (parseResult) {</span>
1978         JSTokenLocation endLocation;
1979         endLocation.line = m_lexer-&gt;lineNumber();
1980         endLocation.lineStartOffset = m_lexer-&gt;currentLineStartOffset();
1981         endLocation.startOffset = m_lexer-&gt;currentOffset();
1982         unsigned endColumn = endLocation.startOffset - endLocation.lineStartOffset;
1983         result = makeUnique&lt;ParsedNode&gt;(m_parserArena,
1984                                     startLocation,
1985                                     endLocation,
1986                                     startColumn,
1987                                     endColumn,
<span class="line-modified">1988                                     parseResult.value().sourceElements,</span>
<span class="line-modified">1989                                     parseResult.value().varDeclarations,</span>
<span class="line-modified">1990                                     WTFMove(parseResult.value().functionDeclarations),</span>
1991                                     currentScope()-&gt;finalizeLexicalEnvironment(),
<span class="line-modified">1992                                     WTFMove(parseResult.value().sloppyModeHoistedFunctions),</span>
<span class="line-modified">1993                                     parseResult.value().parameters,</span>
1994                                     *m_source,
<span class="line-modified">1995                                     parseResult.value().features,</span>
1996                                     currentScope()-&gt;innerArrowFunctionFeatures(),
<span class="line-modified">1997                                     parseResult.value().numConstants,</span>
1998                                     WTFMove(m_moduleScopeData));
1999         result-&gt;setLoc(m_source-&gt;firstLine().oneBasedInt(), m_lexer-&gt;lineNumber(), m_lexer-&gt;currentOffset(), m_lexer-&gt;currentLineStartOffset());
2000         result-&gt;setEndOffset(m_lexer-&gt;currentOffset());
2001 
2002         if (!isFunctionParseMode(parseMode)) {
2003             m_source-&gt;provider()-&gt;setSourceURLDirective(m_lexer-&gt;sourceURLDirective());
2004             m_source-&gt;provider()-&gt;setSourceMappingURLDirective(m_lexer-&gt;sourceMappingURLDirective());
2005         }
2006     } else {
2007         // We can never see a syntax error when reparsing a function, since we should have
2008         // reported the error when parsing the containing program or eval code. So if we&#39;re
2009         // parsing a function body node, we assume that what actually happened here is that
2010         // we ran out of stack while parsing. If we see an error while parsing eval or program
2011         // code we assume that it was a syntax error since running out of stack is much less
2012         // likely, and we are currently unable to distinguish between the two cases.
2013         if (isFunctionMetadataNode(static_cast&lt;ParsedNode*&gt;(0)) || m_hasStackOverflow)
2014             error = ParserError(ParserError::StackOverflow, ParserError::SyntaxErrorNone, m_token);
2015         else {
2016             ParserError::SyntaxErrorType errorType = ParserError::SyntaxErrorIrrecoverable;
2017             if (m_token.m_type == EOFTOK)
</pre>
<hr />
<pre>
2023                 else
2024                     errorType = ParserError::SyntaxErrorUnterminatedLiteral;
2025             }
2026 
2027             if (isEvalNode&lt;ParsedNode&gt;())
2028                 error = ParserError(ParserError::EvalError, errorType, m_token, errMsg, errLine);
2029             else
2030                 error = ParserError(ParserError::SyntaxError, errorType, m_token, errMsg, errLine);
2031         }
2032     }
2033 
2034     return result;
2035 }
2036 
2037 template &lt;class ParsedNode&gt;
2038 std::unique_ptr&lt;ParsedNode&gt; parse(
2039     VM&amp; vm, const SourceCode&amp; source,
2040     const Identifier&amp; name, JSParserBuiltinMode builtinMode,
2041     JSParserStrictMode strictMode, JSParserScriptMode scriptMode, SourceParseMode parseMode, SuperBinding superBinding,
2042     ParserError&amp; error, JSTextPosition* positionBeforeLastNewline = nullptr,
<span class="line-modified">2043     ConstructorKind defaultConstructorKindForTopLevelFunction = ConstructorKind::None,</span>
2044     DerivedContextType derivedContextType = DerivedContextType::None,
2045     EvalContextType evalContextType = EvalContextType::None,
<span class="line-modified">2046     DebuggerParseData* debuggerParseData = nullptr,</span>
<span class="line-added">2047     const Vector&lt;JSTextPosition&gt;* instanceFieldLocations = nullptr)</span>
2048 {
2049     ASSERT(!source.provider()-&gt;source().isNull());
2050 
2051     MonotonicTime before;
2052     if (UNLIKELY(Options::reportParseTimes()))
2053         before = MonotonicTime::now();
2054 
2055     std::unique_ptr&lt;ParsedNode&gt; result;
2056     if (source.provider()-&gt;source().is8Bit()) {
<span class="line-modified">2057         Parser&lt;Lexer&lt;LChar&gt;&gt; parser(vm, source, builtinMode, strictMode, scriptMode, parseMode, superBinding, defaultConstructorKindForTopLevelFunction, derivedContextType, isEvalNode&lt;ParsedNode&gt;(), evalContextType, debuggerParseData);</span>
<span class="line-modified">2058         result = parser.parse&lt;ParsedNode&gt;(error, name, parseMode, isEvalNode&lt;ParsedNode&gt;() ? ParsingContext::Eval : ParsingContext::Program, WTF::nullopt, instanceFieldLocations);</span>
2059         if (positionBeforeLastNewline)
2060             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2061         if (builtinMode == JSParserBuiltinMode::Builtin) {
2062             if (!result) {
2063                 ASSERT(error.isValid());
2064                 if (error.type() != ParserError::StackOverflow)
2065                     dataLogLn(&quot;Unexpected error compiling builtin: &quot;, error.message());
2066             }
2067         }
2068     } else {
<span class="line-modified">2069         ASSERT_WITH_MESSAGE(defaultConstructorKindForTopLevelFunction == ConstructorKind::None, &quot;BuiltinExecutables&#39;s special constructors should always use a 8-bit string&quot;);</span>
<span class="line-modified">2070         Parser&lt;Lexer&lt;UChar&gt;&gt; parser(vm, source, builtinMode, strictMode, scriptMode, parseMode, superBinding, defaultConstructorKindForTopLevelFunction, derivedContextType, isEvalNode&lt;ParsedNode&gt;(), evalContextType, debuggerParseData);</span>
<span class="line-modified">2071         result = parser.parse&lt;ParsedNode&gt;(error, name, parseMode, isEvalNode&lt;ParsedNode&gt;() ? ParsingContext::Eval : ParsingContext::Program, WTF::nullopt, instanceFieldLocations);</span>
2072         if (positionBeforeLastNewline)
2073             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2074     }
2075 
2076     if (UNLIKELY(Options::countParseTimes()))
2077         globalParseCount++;
2078 
2079     if (UNLIKELY(Options::reportParseTimes())) {
2080         MonotonicTime after = MonotonicTime::now();
2081         ParseHash hash(source);
2082         dataLogLn(result ? &quot;Parsed #&quot; : &quot;Failed to parse #&quot;, hash.hashForCall(), &quot;/#&quot;, hash.hashForConstruct(), &quot; in &quot;, (after - before).milliseconds(), &quot; ms.&quot;);
2083     }
2084 
2085     return result;
2086 }
2087 
2088 inline std::unique_ptr&lt;ProgramNode&gt; parseFunctionForFunctionConstructor(VM&amp; vm, const SourceCode&amp; source, ParserError&amp; error, JSTextPosition* positionBeforeLastNewline, Optional&lt;int&gt; functionConstructorParametersEndPosition)
2089 {
2090     ASSERT(!source.provider()-&gt;source().isNull());
2091 
</pre>
</td>
</tr>
</table>
<center><a href="Parser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ParserArena.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
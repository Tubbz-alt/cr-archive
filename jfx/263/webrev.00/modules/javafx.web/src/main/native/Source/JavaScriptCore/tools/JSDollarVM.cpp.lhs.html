<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/JSDollarVM.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;JSDollarVM.h&quot;
  28 
  29 #include &quot;BuiltinExecutableCreator.h&quot;
  30 #include &quot;CodeBlock.h&quot;
  31 #include &quot;DOMAttributeGetterSetter.h&quot;
  32 #include &quot;DOMJITGetterSetter.h&quot;
<a name="1" id="anc1"></a>

  33 #include &quot;FrameTracers.h&quot;
  34 #include &quot;FunctionCodeBlock.h&quot;
  35 #include &quot;GetterSetter.h&quot;
  36 #include &quot;JSArray.h&quot;
  37 #include &quot;JSArrayBuffer.h&quot;
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;JSFunction.h&quot;
  40 #include &quot;JSONObject.h&quot;
  41 #include &quot;JSProxy.h&quot;
  42 #include &quot;JSString.h&quot;
<a name="2" id="anc2"></a>
  43 #include &quot;Parser.h&quot;
<a name="3" id="anc3"></a>
  44 #include &quot;ShadowChicken.h&quot;
  45 #include &quot;Snippet.h&quot;
  46 #include &quot;SnippetParams.h&quot;
  47 #include &quot;TypeProfiler.h&quot;
  48 #include &quot;TypeProfilerLog.h&quot;
  49 #include &quot;VMInspector.h&quot;
  50 #include &quot;WasmCapabilities.h&quot;
  51 #include &lt;wtf/Atomics.h&gt;
<a name="4" id="anc4"></a>
  52 #include &lt;wtf/DataLog.h&gt;
  53 #include &lt;wtf/ProcessID.h&gt;
  54 #include &lt;wtf/StringPrintStream.h&gt;
  55 
  56 #if ENABLE(WEBASSEMBLY)
  57 #include &quot;JSWebAssemblyHelpers.h&quot;
  58 #include &quot;WasmStreamingParser.h&quot;
  59 #endif
  60 
  61 using namespace JSC;
  62 
<a name="5" id="anc5"></a>























  63 namespace {
  64 
<a name="6" id="anc6"></a><span class="line-modified">  65 class JSDollarVMCallFrame : public JSDestructibleObject {</span>
<span class="line-modified">  66     using Base = JSDestructibleObject;</span>
















  67 public:
  68     JSDollarVMCallFrame(VM&amp; vm, Structure* structure)
  69         : Base(vm, structure)
<a name="7" id="anc7"></a><span class="line-modified">  70     { }</span>


  71 
  72     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  73     {
<a name="8" id="anc8"></a>
  74         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
  75     }
  76 
<a name="9" id="anc9"></a><span class="line-modified">  77     static JSDollarVMCallFrame* create(ExecState* exec, unsigned requestedFrameIndex)</span>
  78     {
<a name="10" id="anc10"></a><span class="line-modified">  79         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">  80         JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
  81         Structure* structure = createStructure(vm, globalObject, jsNull());
  82         JSDollarVMCallFrame* frame = new (NotNull, allocateCell&lt;JSDollarVMCallFrame&gt;(vm.heap)) JSDollarVMCallFrame(vm, structure);
<a name="11" id="anc11"></a><span class="line-modified">  83         frame-&gt;finishCreation(vm, exec, requestedFrameIndex);</span>
  84         return frame;
  85     }
  86 
<a name="12" id="anc12"></a><span class="line-modified">  87     void finishCreation(VM&amp; vm, CallFrame* frame, unsigned requestedFrameIndex)</span>
  88     {
<a name="13" id="anc13"></a>
  89         Base::finishCreation(vm);
  90 
  91         auto addProperty = [&amp;] (VM&amp; vm, const char* name, JSValue value) {
<a name="14" id="anc14"></a>
  92             JSDollarVMCallFrame::addProperty(vm, name, value);
  93         };
  94 
  95         unsigned frameIndex = 0;
  96         bool isValid = false;
<a name="15" id="anc15"></a><span class="line-modified">  97         frame-&gt;iterate([&amp;] (StackVisitor&amp; visitor) {</span>

  98 
  99             if (frameIndex++ != requestedFrameIndex)
 100                 return StackVisitor::Continue;
 101 
 102             addProperty(vm, &quot;name&quot;, jsString(vm, visitor-&gt;functionName()));
 103 
 104             if (visitor-&gt;callee().isCell())
 105                 addProperty(vm, &quot;callee&quot;, visitor-&gt;callee().asCell());
 106 
 107             CodeBlock* codeBlock = visitor-&gt;codeBlock();
 108             if (codeBlock) {
 109                 addProperty(vm, &quot;codeBlock&quot;, codeBlock);
 110                 addProperty(vm, &quot;unlinkedCodeBlock&quot;, codeBlock-&gt;unlinkedCodeBlock());
 111                 addProperty(vm, &quot;executable&quot;, codeBlock-&gt;ownerExecutable());
 112             }
 113             isValid = true;
 114 
 115             return StackVisitor::Done;
 116         });
 117 
 118         addProperty(vm, &quot;valid&quot;, jsBoolean(isValid));
 119     }
 120 
 121     DECLARE_INFO;
 122 
 123 private:
 124     void addProperty(VM&amp; vm, const char* name, JSValue value)
 125     {
<a name="16" id="anc16"></a>
 126         Identifier identifier = Identifier::fromString(vm, name);
 127         putDirect(vm, identifier, value);
 128     }
 129 };
 130 
 131 const ClassInfo JSDollarVMCallFrame::s_info = { &quot;CallFrame&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDollarVMCallFrame) };
 132 
 133 class ElementHandleOwner;
 134 class Root;
 135 
 136 class Element : public JSNonFinalObject {
 137 public:
 138     Element(VM&amp; vm, Structure* structure)
 139         : Base(vm, structure)
 140     {
<a name="17" id="anc17"></a>
 141     }
 142 
 143     typedef JSNonFinalObject Base;
 144 
 145     Root* root() const { return m_root.get(); }
 146     void setRoot(VM&amp; vm, Root* root) { m_root.set(vm, this, root); }
 147 
 148     static Element* create(VM&amp; vm, JSGlobalObject* globalObject, Root* root)
 149     {
<a name="18" id="anc18"></a>
 150         Structure* structure = createStructure(vm, globalObject, jsNull());
 151         Element* element = new (NotNull, allocateCell&lt;Element&gt;(vm.heap)) Element(vm, structure);
 152         element-&gt;finishCreation(vm, root);
 153         return element;
 154     }
 155 
 156     void finishCreation(VM&amp;, Root*);
 157 
 158     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 159     {
<a name="19" id="anc19"></a>
 160         Element* thisObject = jsCast&lt;Element*&gt;(cell);
 161         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 162         Base::visitChildren(thisObject, visitor);
 163         visitor.append(thisObject-&gt;m_root);
 164     }
 165 
 166     static ElementHandleOwner* handleOwner();
 167 
 168     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 169     {
<a name="20" id="anc20"></a>
 170         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 171     }
 172 
 173     DECLARE_INFO;
 174 
 175 private:
 176     WriteBarrier&lt;Root&gt; m_root;
 177 };
 178 
 179 class ElementHandleOwner : public WeakHandleOwner {
 180     WTF_MAKE_FAST_ALLOCATED;
 181 public:
<a name="21" id="anc21"></a><span class="line-modified"> 182     bool isReachableFromOpaqueRoots(Handle&lt;JSC::Unknown&gt; handle, void*, SlotVisitor&amp; visitor, const char** reason) override</span>
 183     {
<a name="22" id="anc22"></a>
 184         if (UNLIKELY(reason))
 185             *reason = &quot;JSC::Element is opaque root&quot;;
 186         Element* element = jsCast&lt;Element*&gt;(handle.slot()-&gt;asCell());
 187         return visitor.containsOpaqueRoot(element-&gt;root());
 188     }
 189 };
 190 
 191 class Root : public JSDestructibleObject {
 192 public:
 193     Root(VM&amp; vm, Structure* structure)
 194         : Base(vm, structure)
 195     {
<a name="23" id="anc23"></a>
 196     }
 197 
 198     Element* element()
 199     {
 200         return m_element.get();
 201     }
 202 
 203     void setElement(Element* element)
 204     {
<a name="24" id="anc24"></a>
 205         Weak&lt;Element&gt; newElement(element, Element::handleOwner());
 206         m_element.swap(newElement);
 207     }
 208 
 209     static Root* create(VM&amp; vm, JSGlobalObject* globalObject)
 210     {
<a name="25" id="anc25"></a>
 211         Structure* structure = createStructure(vm, globalObject, jsNull());
 212         Root* root = new (NotNull, allocateCell&lt;Root&gt;(vm.heap)) Root(vm, structure);
 213         root-&gt;finishCreation(vm);
 214         return root;
 215     }
 216 
 217     typedef JSDestructibleObject Base;
 218 
 219     DECLARE_INFO;
 220 
 221     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 222     {
<a name="26" id="anc26"></a>
 223         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 224     }
 225 
 226     static void visitChildren(JSCell* thisObject, SlotVisitor&amp; visitor)
 227     {
<a name="27" id="anc27"></a>
 228         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 229         Base::visitChildren(thisObject, visitor);
 230         visitor.addOpaqueRoot(thisObject);
 231     }
 232 
 233 private:
 234     Weak&lt;Element&gt; m_element;
 235 };
 236 
 237 class SimpleObject : public JSNonFinalObject {
 238 public:
 239     SimpleObject(VM&amp; vm, Structure* structure)
 240         : Base(vm, structure)
 241     {
<a name="28" id="anc28"></a>
 242     }
 243 
 244     typedef JSNonFinalObject Base;
<a name="29" id="anc29"></a><span class="line-modified"> 245     static const bool needsDestruction = false;</span>
 246 
 247     static SimpleObject* create(VM&amp; vm, JSGlobalObject* globalObject)
 248     {
<a name="30" id="anc30"></a>
 249         Structure* structure = createStructure(vm, globalObject, jsNull());
 250         SimpleObject* simpleObject = new (NotNull, allocateCell&lt;SimpleObject&gt;(vm.heap)) SimpleObject(vm, structure);
 251         simpleObject-&gt;finishCreation(vm);
 252         return simpleObject;
 253     }
 254 
 255     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 256     {
<a name="31" id="anc31"></a>
 257         SimpleObject* thisObject = jsCast&lt;SimpleObject*&gt;(cell);
 258         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 259         Base::visitChildren(thisObject, visitor);
 260         visitor.append(thisObject-&gt;m_hiddenValue);
 261     }
 262 
 263     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 264     {
<a name="32" id="anc32"></a>
 265         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 266     }
 267 
 268     JSValue hiddenValue()
 269     {
 270         return m_hiddenValue.get();
 271     }
 272 
 273     void setHiddenValue(VM&amp; vm, JSValue value)
 274     {
 275         ASSERT(value.isCell());
 276         m_hiddenValue.set(vm, this, value);
 277     }
 278 
 279     DECLARE_INFO;
 280 
 281 private:
 282     WriteBarrier&lt;JSC::Unknown&gt; m_hiddenValue;
 283 };
 284 
 285 class ImpureGetter : public JSNonFinalObject {
 286 public:
 287     ImpureGetter(VM&amp; vm, Structure* structure)
 288         : Base(vm, structure)
 289     {
<a name="33" id="anc33"></a>
 290     }
 291 
 292     DECLARE_INFO;
 293     typedef JSNonFinalObject Base;
<a name="34" id="anc34"></a><span class="line-modified"> 294     static const unsigned StructureFlags = Base::StructureFlags | JSC::GetOwnPropertySlotIsImpure | JSC::OverridesGetOwnPropertySlot;</span>
 295 
 296     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 297     {
<a name="35" id="anc35"></a>
 298         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 299     }
 300 
 301     static ImpureGetter* create(VM&amp; vm, Structure* structure, JSObject* delegate)
 302     {
<a name="36" id="anc36"></a>
 303         ImpureGetter* getter = new (NotNull, allocateCell&lt;ImpureGetter&gt;(vm.heap)) ImpureGetter(vm, structure);
 304         getter-&gt;finishCreation(vm, delegate);
 305         return getter;
 306     }
 307 
 308     void finishCreation(VM&amp; vm, JSObject* delegate)
 309     {
<a name="37" id="anc37"></a>
 310         Base::finishCreation(vm);
 311         if (delegate)
 312             m_delegate.set(vm, this, delegate);
 313     }
 314 
<a name="38" id="anc38"></a><span class="line-modified"> 315     static bool getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName name, PropertySlot&amp; slot)</span>
 316     {
<a name="39" id="anc39"></a><span class="line-modified"> 317         VM&amp; vm = exec-&gt;vm();</span>

 318         auto scope = DECLARE_THROW_SCOPE(vm);
 319         ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(object);
 320 
 321         if (thisObject-&gt;m_delegate) {
<a name="40" id="anc40"></a><span class="line-modified"> 322             if (thisObject-&gt;m_delegate-&gt;getPropertySlot(exec, name, slot))</span>
 323                 return true;
 324             RETURN_IF_EXCEPTION(scope, false);
 325         }
 326 
<a name="41" id="anc41"></a><span class="line-modified"> 327         return Base::getOwnPropertySlot(object, exec, name, slot);</span>
 328     }
 329 
 330     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 331     {
<a name="42" id="anc42"></a>
 332         ASSERT_GC_OBJECT_INHERITS(cell, info());
 333         Base::visitChildren(cell, visitor);
 334         ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(cell);
 335         visitor.append(thisObject-&gt;m_delegate);
 336     }
 337 
 338     void setDelegate(VM&amp; vm, JSObject* delegate)
 339     {
 340         m_delegate.set(vm, this, delegate);
 341     }
 342 
 343 private:
 344     WriteBarrier&lt;JSObject&gt; m_delegate;
 345 };
 346 
 347 class CustomGetter : public JSNonFinalObject {
 348 public:
 349     CustomGetter(VM&amp; vm, Structure* structure)
 350         : Base(vm, structure)
 351     {
<a name="43" id="anc43"></a>
 352     }
 353 
 354     DECLARE_INFO;
 355     typedef JSNonFinalObject Base;
<a name="44" id="anc44"></a><span class="line-modified"> 356     static const unsigned StructureFlags = Base::StructureFlags | JSC::OverridesGetOwnPropertySlot;</span>
 357 
 358     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 359     {
<a name="45" id="anc45"></a>
 360         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 361     }
 362 
 363     static CustomGetter* create(VM&amp; vm, Structure* structure)
 364     {
<a name="46" id="anc46"></a>
 365         CustomGetter* getter = new (NotNull, allocateCell&lt;CustomGetter&gt;(vm.heap)) CustomGetter(vm, structure);
 366         getter-&gt;finishCreation(vm);
 367         return getter;
 368     }
 369 
<a name="47" id="anc47"></a><span class="line-modified"> 370     static bool getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
 371     {
<a name="48" id="anc48"></a><span class="line-modified"> 372         VM&amp; vm = exec-&gt;vm();</span>

 373         CustomGetter* thisObject = jsCast&lt;CustomGetter*&gt;(object);
 374         if (propertyName == PropertyName(Identifier::fromString(vm, &quot;customGetter&quot;))) {
 375             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;customGetter);
 376             return true;
 377         }
 378 
 379         if (propertyName == PropertyName(Identifier::fromString(vm, &quot;customGetterAccessor&quot;))) {
 380             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::CustomAccessor, thisObject-&gt;customGetterAcessor);
 381             return true;
 382         }
 383 
<a name="49" id="anc49"></a><span class="line-modified"> 384         return JSObject::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
 385     }
 386 
 387 private:
<a name="50" id="anc50"></a><span class="line-modified"> 388     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
 389     {
<a name="51" id="anc51"></a><span class="line-modified"> 390         VM&amp; vm = exec-&gt;vm();</span>

 391         auto scope = DECLARE_THROW_SCOPE(vm);
 392 
 393         CustomGetter* thisObject = jsDynamicCast&lt;CustomGetter*&gt;(vm, JSValue::decode(thisValue));
 394         if (!thisObject)
<a name="52" id="anc52"></a><span class="line-modified"> 395             return throwVMTypeError(exec, scope);</span>
<span class="line-modified"> 396         bool shouldThrow = thisObject-&gt;get(exec, PropertyName(Identifier::fromString(vm, &quot;shouldThrow&quot;))).toBoolean(exec);</span>
 397         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 398         if (shouldThrow)
<a name="53" id="anc53"></a><span class="line-modified"> 399             return throwVMTypeError(exec, scope);</span>
 400         return JSValue::encode(jsNumber(100));
 401     }
 402 
<a name="54" id="anc54"></a><span class="line-modified"> 403     static EncodedJSValue customGetterAcessor(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
 404     {
<a name="55" id="anc55"></a><span class="line-modified"> 405         VM&amp; vm = exec-&gt;vm();</span>

 406         auto scope = DECLARE_THROW_SCOPE(vm);
 407 
 408         JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
 409         if (!thisObject)
<a name="56" id="anc56"></a><span class="line-modified"> 410             return throwVMTypeError(exec, scope);</span>
<span class="line-modified"> 411         bool shouldThrow = thisObject-&gt;get(exec, PropertyName(Identifier::fromString(vm, &quot;shouldThrow&quot;))).toBoolean(exec);</span>
 412         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 413         if (shouldThrow)
<a name="57" id="anc57"></a><span class="line-modified"> 414             return throwVMTypeError(exec, scope);</span>
 415         return JSValue::encode(jsNumber(100));
 416     }
 417 };
 418 
 419 class RuntimeArray : public JSArray {
 420 public:
 421     typedef JSArray Base;
<a name="58" id="anc58"></a><span class="line-modified"> 422     static const unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero | OverridesGetPropertyNames;</span>
 423 
<a name="59" id="anc59"></a><span class="line-modified"> 424     static RuntimeArray* create(ExecState* exec)</span>
 425     {
<a name="60" id="anc60"></a><span class="line-modified"> 426         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 427         JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
 428         Structure* structure = createStructure(vm, globalObject, createPrototype(vm, globalObject));
<a name="61" id="anc61"></a><span class="line-modified"> 429         RuntimeArray* runtimeArray = new (NotNull, allocateCell&lt;RuntimeArray&gt;(vm.heap)) RuntimeArray(exec, structure);</span>
<span class="line-modified"> 430         runtimeArray-&gt;finishCreation(exec);</span>
 431         vm.heap.addFinalizer(runtimeArray, destroy);
 432         return runtimeArray;
 433     }
 434 
 435     ~RuntimeArray() { }
 436 
 437     static void destroy(JSCell* cell)
 438     {
<a name="62" id="anc62"></a>
 439         static_cast&lt;RuntimeArray*&gt;(cell)-&gt;RuntimeArray::~RuntimeArray();
 440     }
 441 
<a name="63" id="anc63"></a><span class="line-modified"> 442     static const bool needsDestruction = false;</span>
 443 
<a name="64" id="anc64"></a><span class="line-modified"> 444     static bool getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
 445     {
<a name="65" id="anc65"></a><span class="line-modified"> 446         VM&amp; vm = exec-&gt;vm();</span>

 447         RuntimeArray* thisObject = jsCast&lt;RuntimeArray*&gt;(object);
 448         if (propertyName == vm.propertyNames-&gt;length) {
 449             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;lengthGetter);
 450             return true;
 451         }
 452 
 453         Optional&lt;uint32_t&gt; index = parseIndex(propertyName);
 454         if (index &amp;&amp; index.value() &lt; thisObject-&gt;getLength()) {
 455             slot.setValue(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::DontEnum, jsNumber(thisObject-&gt;m_vector[index.value()]));
 456             return true;
 457         }
 458 
<a name="66" id="anc66"></a><span class="line-modified"> 459         return JSObject::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
 460     }
 461 
<a name="67" id="anc67"></a><span class="line-modified"> 462     static bool getOwnPropertySlotByIndex(JSObject* object, ExecState* exec, unsigned index, PropertySlot&amp; slot)</span>
 463     {
<a name="68" id="anc68"></a>
 464         RuntimeArray* thisObject = jsCast&lt;RuntimeArray*&gt;(object);
 465         if (index &lt; thisObject-&gt;getLength()) {
 466             slot.setValue(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::DontEnum, jsNumber(thisObject-&gt;m_vector[index]));
 467             return true;
 468         }
 469 
<a name="69" id="anc69"></a><span class="line-modified"> 470         return JSObject::getOwnPropertySlotByIndex(thisObject, exec, index, slot);</span>
 471     }
 472 
<a name="70" id="anc70"></a><span class="line-modified"> 473     static NO_RETURN_DUE_TO_CRASH bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;)</span>
 474     {
 475         RELEASE_ASSERT_NOT_REACHED();
 476     }
 477 
<a name="71" id="anc71"></a><span class="line-modified"> 478     static NO_RETURN_DUE_TO_CRASH bool deleteProperty(JSCell*, ExecState*, PropertyName)</span>
 479     {
 480         RELEASE_ASSERT_NOT_REACHED();
 481     }
 482 
 483     unsigned getLength() const { return m_vector.size(); }
 484 
 485     DECLARE_INFO;
 486 
 487     static ArrayPrototype* createPrototype(VM&amp;, JSGlobalObject* globalObject)
 488     {
<a name="72" id="anc72"></a>
 489         return globalObject-&gt;arrayPrototype();
 490     }
 491 
 492     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 493     {
<a name="73" id="anc73"></a>
 494         return Structure::create(vm, globalObject, prototype, TypeInfo(DerivedArrayType, StructureFlags), info(), ArrayClass);
 495     }
 496 
 497 protected:
<a name="74" id="anc74"></a><span class="line-modified"> 498     void finishCreation(ExecState* exec)</span>
 499     {
<a name="75" id="anc75"></a><span class="line-modified"> 500         VM&amp; vm = exec-&gt;vm();</span>

 501         Base::finishCreation(vm);
 502         ASSERT(inherits(vm, info()));
 503 
<a name="76" id="anc76"></a><span class="line-modified"> 504         for (size_t i = 0; i &lt; exec-&gt;argumentCount(); i++)</span>
<span class="line-modified"> 505             m_vector.append(exec-&gt;argument(i).toInt32(exec));</span>
 506     }
 507 
 508 private:
<a name="77" id="anc77"></a><span class="line-modified"> 509     RuntimeArray(ExecState* exec, Structure* structure)</span>
<span class="line-modified"> 510         : JSArray(exec-&gt;vm(), structure, 0)</span>
 511     {
<a name="78" id="anc78"></a>
 512     }
 513 
<a name="79" id="anc79"></a><span class="line-modified"> 514     static EncodedJSValue lengthGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
 515     {
<a name="80" id="anc80"></a><span class="line-modified"> 516         VM&amp; vm = exec-&gt;vm();</span>

 517         auto scope = DECLARE_THROW_SCOPE(vm);
 518 
 519         RuntimeArray* thisObject = jsDynamicCast&lt;RuntimeArray*&gt;(vm, JSValue::decode(thisValue));
 520         if (!thisObject)
<a name="81" id="anc81"></a><span class="line-modified"> 521             return throwVMTypeError(exec, scope);</span>
 522         return JSValue::encode(jsNumber(thisObject-&gt;getLength()));
 523     }
 524 
 525     Vector&lt;int&gt; m_vector;
 526 };
 527 
<a name="82" id="anc82"></a>












































































































 528 class DOMJITNode : public JSNonFinalObject {
 529 public:
 530     DOMJITNode(VM&amp; vm, Structure* structure)
 531         : Base(vm, structure)
 532     {
<a name="83" id="anc83"></a>
 533     }
 534 
 535     DECLARE_INFO;
 536     typedef JSNonFinalObject Base;
<a name="84" id="anc84"></a><span class="line-modified"> 537     static const unsigned StructureFlags = Base::StructureFlags;</span>
 538 
 539     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 540     {
<a name="85" id="anc85"></a>
 541         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 542     }
 543 
 544 #if ENABLE(JIT)
 545     static Ref&lt;Snippet&gt; checkSubClassSnippet()
 546     {
<a name="86" id="anc86"></a>
 547         Ref&lt;Snippet&gt; snippet = Snippet::create();
<a name="87" id="anc87"></a><span class="line-modified"> 548         snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>

 549             CCallHelpers::JumpList failureCases;
 550             failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
 551             return failureCases;
 552         });
 553         return snippet;
 554     }
 555 #endif
 556 
 557     static DOMJITNode* create(VM&amp; vm, Structure* structure)
 558     {
<a name="88" id="anc88"></a>
 559         DOMJITNode* getter = new (NotNull, allocateCell&lt;DOMJITNode&gt;(vm.heap)) DOMJITNode(vm, structure);
 560         getter-&gt;finishCreation(vm);
 561         return getter;
 562     }
 563 
 564     int32_t value() const
 565     {
 566         return m_value;
 567     }
 568 
 569     static ptrdiff_t offsetOfValue() { return OBJECT_OFFSETOF(DOMJITNode, m_value); }
 570 
 571 private:
 572     int32_t m_value { 42 };
 573 };
 574 
 575 class DOMJITGetter : public DOMJITNode {
 576 public:
 577     DOMJITGetter(VM&amp; vm, Structure* structure)
 578         : Base(vm, structure)
 579     {
<a name="89" id="anc89"></a>
 580     }
 581 
 582     DECLARE_INFO;
 583     typedef DOMJITNode Base;
<a name="90" id="anc90"></a><span class="line-modified"> 584     static const unsigned StructureFlags = Base::StructureFlags;</span>
 585 
 586     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 587     {
<a name="91" id="anc91"></a>
 588         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 589     }
 590 
 591     static DOMJITGetter* create(VM&amp; vm, Structure* structure)
 592     {
<a name="92" id="anc92"></a>
 593         DOMJITGetter* getter = new (NotNull, allocateCell&lt;DOMJITGetter&gt;(vm.heap)) DOMJITGetter(vm, structure);
 594         getter-&gt;finishCreation(vm);
 595         return getter;
 596     }
 597 
 598     class DOMJITAttribute : public DOMJIT::GetterSetter {
 599     public:
<a name="93" id="anc93"></a><span class="line-modified"> 600         constexpr DOMJITAttribute()</span>
 601             : DOMJIT::GetterSetter(
 602                 DOMJITGetter::customGetter,
 603 #if ENABLE(JIT)
 604                 &amp;callDOMGetter,
 605 #else
 606                 nullptr,
 607 #endif
 608                 SpecInt32Only)
 609         {
 610         }
 611 
 612 #if ENABLE(JIT)
<a name="94" id="anc94"></a><span class="line-modified"> 613         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)</span>
 614         {
<a name="95" id="anc95"></a><span class="line-modified"> 615             VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 616             NativeCallFrameTracer tracer(vm, exec);</span>


 617             return JSValue::encode(jsNumber(static_cast&lt;DOMJITGetter*&gt;(pointer)-&gt;value()));
 618         }
 619 
 620         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 621         {
<a name="96" id="anc96"></a>
 622             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
<a name="97" id="anc97"></a><span class="line-modified"> 623             snippet-&gt;requireGlobalObject = false;</span>
<span class="line-modified"> 624             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>

 625                 JSValueRegs results = params[0].jsValueRegs();
<a name="98" id="anc98"></a><span class="line-modified"> 626                 GPRReg dom = params[1].gpr();</span>
<span class="line-modified"> 627                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, dom);</span>

 628                 return CCallHelpers::JumpList();
 629 
 630             });
 631             return snippet;
 632         }
 633 #endif
 634     };
 635 
 636 private:
 637     void finishCreation(VM&amp;);
 638 
<a name="99" id="anc99"></a><span class="line-modified"> 639     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
 640     {
<a name="100" id="anc100"></a><span class="line-modified"> 641         VM&amp; vm = exec-&gt;vm();</span>

 642         DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, JSValue::decode(thisValue));
 643         ASSERT(thisObject);
 644         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 645     }
 646 };
 647 
 648 static const DOMJITGetter::DOMJITAttribute DOMJITGetterDOMJIT;
 649 
 650 void DOMJITGetter::finishCreation(VM&amp; vm)
 651 {
<a name="101" id="anc101"></a>
 652     Base::finishCreation(vm);
 653     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterDOMJIT;
 654     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITNode::info(), domJIT });
 655     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
 656 }
 657 
<a name="102" id="anc102"></a>
 658 class DOMJITGetterComplex : public DOMJITNode {
 659 public:
 660     DOMJITGetterComplex(VM&amp; vm, Structure* structure)
 661         : Base(vm, structure)
 662     {
<a name="103" id="anc103"></a>
 663     }
 664 
 665     DECLARE_INFO;
 666     typedef DOMJITNode Base;
<a name="104" id="anc104"></a><span class="line-modified"> 667     static const unsigned StructureFlags = Base::StructureFlags;</span>
 668 
 669     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 670     {
<a name="105" id="anc105"></a>
 671         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 672     }
 673 
 674     static DOMJITGetterComplex* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 675     {
<a name="106" id="anc106"></a>
 676         DOMJITGetterComplex* getter = new (NotNull, allocateCell&lt;DOMJITGetterComplex&gt;(vm.heap)) DOMJITGetterComplex(vm, structure);
 677         getter-&gt;finishCreation(vm, globalObject);
 678         return getter;
 679     }
 680 
 681     class DOMJITAttribute : public DOMJIT::GetterSetter {
 682     public:
<a name="107" id="anc107"></a><span class="line-modified"> 683         constexpr DOMJITAttribute()</span>
 684             : DOMJIT::GetterSetter(
 685                 DOMJITGetterComplex::customGetter,
 686 #if ENABLE(JIT)
 687                 &amp;callDOMGetter,
 688 #else
 689                 nullptr,
 690 #endif
 691                 SpecInt32Only)
 692         {
 693         }
 694 
 695 #if ENABLE(JIT)
<a name="108" id="anc108"></a><span class="line-modified"> 696         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)</span>
 697         {
<a name="109" id="anc109"></a><span class="line-modified"> 698             VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 699             NativeCallFrameTracer tracer(vm, exec);</span>


 700             auto scope = DECLARE_THROW_SCOPE(vm);
 701             auto* object = static_cast&lt;DOMJITNode*&gt;(pointer);
 702             auto* domjitGetterComplex = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, object);
 703             if (domjitGetterComplex) {
 704                 if (domjitGetterComplex-&gt;m_enableException)
<a name="110" id="anc110"></a><span class="line-modified"> 705                     return JSValue::encode(throwException(exec, scope, createError(exec, &quot;DOMJITGetterComplex slow call exception&quot;_s)));</span>
 706             }
 707             return JSValue::encode(jsNumber(object-&gt;value()));
 708         }
 709 
 710         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 711         {
<a name="111" id="anc111"></a>
 712             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
 713             static_assert(GPRInfo::numberOfRegisters &gt;= 4, &quot;Number of registers should be larger or equal to 4.&quot;);
 714             unsigned numGPScratchRegisters = GPRInfo::numberOfRegisters - 4;
 715             snippet-&gt;numGPScratchRegisters = numGPScratchRegisters;
 716             snippet-&gt;numFPScratchRegisters = 3;
<a name="112" id="anc112"></a><span class="line-modified"> 717             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>


 718                 JSValueRegs results = params[0].jsValueRegs();
 719                 GPRReg domGPR = params[1].gpr();
<a name="113" id="anc113"></a>
 720                 for (unsigned i = 0; i &lt; numGPScratchRegisters; ++i)
 721                     jit.move(CCallHelpers::TrustedImm32(42), params.gpScratch(i));
 722 
<a name="114" id="anc114"></a><span class="line-modified"> 723                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, domGPR);</span>
 724                 return CCallHelpers::JumpList();
 725             });
 726             return snippet;
 727         }
 728 #endif
 729     };
 730 
 731 private:
 732     void finishCreation(VM&amp;, JSGlobalObject*);
 733 
<a name="115" id="anc115"></a><span class="line-modified"> 734     static EncodedJSValue JSC_HOST_CALL functionEnableException(ExecState* exec)</span>
 735     {
<a name="116" id="anc116"></a><span class="line-modified"> 736         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 737         auto* object = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, exec-&gt;thisValue());</span>

 738         if (object)
 739             object-&gt;m_enableException = true;
 740         return JSValue::encode(jsUndefined());
 741     }
 742 
<a name="117" id="anc117"></a><span class="line-modified"> 743     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
 744     {
<a name="118" id="anc118"></a><span class="line-modified"> 745         VM&amp; vm = exec-&gt;vm();</span>

 746         auto scope = DECLARE_THROW_SCOPE(vm);
 747 
 748         auto* thisObject = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, JSValue::decode(thisValue));
 749         ASSERT(thisObject);
 750         if (thisObject-&gt;m_enableException)
<a name="119" id="anc119"></a><span class="line-modified"> 751             return JSValue::encode(throwException(exec, scope, createError(exec, &quot;DOMJITGetterComplex slow call exception&quot;_s)));</span>
 752         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 753     }
 754 
 755     bool m_enableException { false };
 756 };
 757 
 758 static const DOMJITGetterComplex::DOMJITAttribute DOMJITGetterComplexDOMJIT;
 759 
 760 void DOMJITGetterComplex::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 761 {
<a name="120" id="anc120"></a>
 762     Base::finishCreation(vm);
 763     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterComplexDOMJIT;
 764     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITGetterComplex::info(), domJIT });
 765     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
 766     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;enableException&quot;), 0, functionEnableException, NoIntrinsic, 0);
 767 }
 768 
 769 class DOMJITFunctionObject : public DOMJITNode {
 770 public:
 771     DOMJITFunctionObject(VM&amp; vm, Structure* structure)
 772         : Base(vm, structure)
 773     {
<a name="121" id="anc121"></a>
 774     }
 775 
 776     DECLARE_INFO;
 777     typedef DOMJITNode Base;
<a name="122" id="anc122"></a><span class="line-modified"> 778     static const unsigned StructureFlags = Base::StructureFlags;</span>
<span class="line-removed"> 779 </span>
 780 
 781     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 782     {
<a name="123" id="anc123"></a>
 783         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 784     }
 785 
 786     static DOMJITFunctionObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 787     {
<a name="124" id="anc124"></a>
 788         DOMJITFunctionObject* object = new (NotNull, allocateCell&lt;DOMJITFunctionObject&gt;(vm.heap)) DOMJITFunctionObject(vm, structure);
 789         object-&gt;finishCreation(vm, globalObject);
 790         return object;
 791     }
 792 
<a name="125" id="anc125"></a><span class="line-modified"> 793     static EncodedJSValue JSC_HOST_CALL functionWithTypeCheck(ExecState* exec)</span>
 794     {
<a name="126" id="anc126"></a><span class="line-modified"> 795         VM&amp; vm = exec-&gt;vm();</span>

 796         auto scope = DECLARE_THROW_SCOPE(vm);
 797 
<a name="127" id="anc127"></a><span class="line-modified"> 798         DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, exec-&gt;thisValue());</span>
 799         if (!thisObject)
<a name="128" id="anc128"></a><span class="line-modified"> 800             return throwVMTypeError(exec, scope);</span>
 801         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 802     }
 803 
<a name="129" id="anc129"></a><span class="line-modified"> 804     static EncodedJSValue JIT_OPERATION functionWithoutTypeCheck(ExecState* exec, DOMJITNode* node)</span>
 805     {
<a name="130" id="anc130"></a><span class="line-modified"> 806         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 807         NativeCallFrameTracer tracer(vm, exec);</span>


 808         return JSValue::encode(jsNumber(node-&gt;value()));
 809     }
 810 
 811 #if ENABLE(JIT)
 812     static Ref&lt;Snippet&gt; checkSubClassSnippet()
 813     {
<a name="131" id="anc131"></a>
 814         Ref&lt;Snippet&gt; snippet = Snippet::create();
 815         snippet-&gt;numFPScratchRegisters = 1;
<a name="132" id="anc132"></a><span class="line-modified"> 816         snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>

 817             static const double value = 42.0;
 818             CCallHelpers::JumpList failureCases;
 819             // May use scratch registers.
 820             jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;value), params.fpScratch(0));
 821             failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
 822             return failureCases;
 823         });
 824         return snippet;
 825     }
 826 #endif
 827 
 828 private:
 829     void finishCreation(VM&amp;, JSGlobalObject*);
 830 };
 831 
 832 static const DOMJIT::Signature DOMJITFunctionObjectSignature(DOMJITFunctionObject::functionWithoutTypeCheck, DOMJITFunctionObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);
 833 
 834 void DOMJITFunctionObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 835 {
<a name="133" id="anc133"></a>
 836     Base::finishCreation(vm);
 837     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;func&quot;), 0, functionWithTypeCheck, NoIntrinsic, &amp;DOMJITFunctionObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 838 }
 839 
 840 class DOMJITCheckSubClassObject : public DOMJITNode {
 841 public:
 842     DOMJITCheckSubClassObject(VM&amp; vm, Structure* structure)
 843         : Base(vm, structure)
 844     {
<a name="134" id="anc134"></a>
 845     }
 846 
 847     DECLARE_INFO;
 848     typedef DOMJITNode Base;
<a name="135" id="anc135"></a><span class="line-modified"> 849     static const unsigned StructureFlags = Base::StructureFlags;</span>
<span class="line-removed"> 850 </span>
 851 
 852     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 853     {
<a name="136" id="anc136"></a>
 854         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 855     }
 856 
 857     static DOMJITCheckSubClassObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 858     {
<a name="137" id="anc137"></a>
 859         DOMJITCheckSubClassObject* object = new (NotNull, allocateCell&lt;DOMJITCheckSubClassObject&gt;(vm.heap)) DOMJITCheckSubClassObject(vm, structure);
 860         object-&gt;finishCreation(vm, globalObject);
 861         return object;
 862     }
 863 
<a name="138" id="anc138"></a><span class="line-modified"> 864     static EncodedJSValue JSC_HOST_CALL functionWithTypeCheck(ExecState* exec)</span>
 865     {
<a name="139" id="anc139"></a><span class="line-modified"> 866         VM&amp; vm = exec-&gt;vm();</span>

 867         auto scope = DECLARE_THROW_SCOPE(vm);
 868 
<a name="140" id="anc140"></a><span class="line-modified"> 869         auto* thisObject = jsDynamicCast&lt;DOMJITCheckSubClassObject*&gt;(vm, exec-&gt;thisValue());</span>
 870         if (!thisObject)
<a name="141" id="anc141"></a><span class="line-modified"> 871             return throwVMTypeError(exec, scope);</span>
 872         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 873     }
 874 
<a name="142" id="anc142"></a><span class="line-modified"> 875     static EncodedJSValue JIT_OPERATION functionWithoutTypeCheck(ExecState* exec, DOMJITNode* node)</span>
 876     {
<a name="143" id="anc143"></a><span class="line-modified"> 877         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 878         NativeCallFrameTracer tracer(vm, exec);</span>


 879         return JSValue::encode(jsNumber(node-&gt;value()));
 880     }
 881 
 882 private:
 883     void finishCreation(VM&amp;, JSGlobalObject*);
 884 };
 885 
 886 static const DOMJIT::Signature DOMJITCheckSubClassObjectSignature(DOMJITCheckSubClassObject::functionWithoutTypeCheck, DOMJITCheckSubClassObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);
 887 
 888 void DOMJITCheckSubClassObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 889 {
<a name="144" id="anc144"></a>
 890     Base::finishCreation(vm);
 891     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;func&quot;), 0, functionWithTypeCheck, NoIntrinsic, &amp;DOMJITCheckSubClassObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 892 }
 893 
 894 class DOMJITGetterBaseJSObject : public DOMJITNode {
 895 public:
 896     DOMJITGetterBaseJSObject(VM&amp; vm, Structure* structure)
 897         : Base(vm, structure)
 898     {
<a name="145" id="anc145"></a>
 899     }
 900 
 901     DECLARE_INFO;
 902     using Base = DOMJITNode;
<a name="146" id="anc146"></a><span class="line-modified"> 903     static const unsigned StructureFlags = Base::StructureFlags;</span>
 904 
 905     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 906     {
<a name="147" id="anc147"></a>
 907         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 908     }
 909 
 910     static DOMJITGetterBaseJSObject* create(VM&amp; vm, Structure* structure)
 911     {
<a name="148" id="anc148"></a>
 912         DOMJITGetterBaseJSObject* getter = new (NotNull, allocateCell&lt;DOMJITGetterBaseJSObject&gt;(vm.heap)) DOMJITGetterBaseJSObject(vm, structure);
 913         getter-&gt;finishCreation(vm);
 914         return getter;
 915     }
 916 
 917     class DOMJITAttribute : public DOMJIT::GetterSetter {
 918     public:
<a name="149" id="anc149"></a><span class="line-modified"> 919         constexpr DOMJITAttribute()</span>
 920             : DOMJIT::GetterSetter(
 921                 DOMJITGetterBaseJSObject::customGetter,
 922 #if ENABLE(JIT)
 923                 &amp;callDOMGetter,
 924 #else
 925                 nullptr,
 926 #endif
 927                 SpecBytecodeTop)
 928         {
 929         }
 930 
 931 #if ENABLE(JIT)
<a name="150" id="anc150"></a><span class="line-modified"> 932         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)</span>
 933         {
<a name="151" id="anc151"></a><span class="line-modified"> 934             VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 935             NativeCallFrameTracer tracer(vm, exec);</span>


 936             JSObject* object = static_cast&lt;JSObject*&gt;(pointer);
 937             return JSValue::encode(object-&gt;getPrototypeDirect(vm));
 938         }
 939 
 940         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 941         {
<a name="152" id="anc152"></a>
 942             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
<a name="153" id="anc153"></a><span class="line-modified"> 943             snippet-&gt;requireGlobalObject = false;</span>
<span class="line-modified"> 944             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>

 945                 JSValueRegs results = params[0].jsValueRegs();
<a name="154" id="anc154"></a><span class="line-modified"> 946                 GPRReg dom = params[1].gpr();</span>
<span class="line-modified"> 947                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, dom);</span>

 948                 return CCallHelpers::JumpList();
 949 
 950             });
 951             return snippet;
 952         }
 953 #endif
 954     };
 955 
 956 private:
 957     void finishCreation(VM&amp;);
 958 
<a name="155" id="anc155"></a><span class="line-modified"> 959     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
 960     {
<a name="156" id="anc156"></a><span class="line-modified"> 961         VM&amp; vm = exec-&gt;vm();</span>

 962         JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
 963         RELEASE_ASSERT(thisObject);
 964         return JSValue::encode(thisObject-&gt;getPrototypeDirect(vm));
 965     }
 966 };
 967 
 968 static const DOMJITGetterBaseJSObject::DOMJITAttribute DOMJITGetterBaseJSObjectDOMJIT;
 969 
 970 void DOMJITGetterBaseJSObject::finishCreation(VM&amp; vm)
 971 {
<a name="157" id="anc157"></a>
 972     Base::finishCreation(vm);
 973     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterBaseJSObjectDOMJIT;
 974     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { JSObject::info(), domJIT });
 975     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
 976 }
 977 
 978 class Message : public ThreadSafeRefCounted&lt;Message&gt; {
 979 public:
 980     Message(ArrayBufferContents&amp;&amp;, int32_t);
 981     ~Message();
 982 
 983     ArrayBufferContents&amp;&amp; releaseContents() { return WTFMove(m_contents); }
 984     int32_t index() const { return m_index; }
 985 
 986 private:
 987     ArrayBufferContents m_contents;
 988     int32_t m_index { 0 };
 989 };
 990 
 991 class JSTestCustomGetterSetter : public JSNonFinalObject {
 992 public:
 993     using Base = JSNonFinalObject;
<a name="158" id="anc158"></a><span class="line-modified"> 994     static const unsigned StructureFlags = Base::StructureFlags;</span>
 995 
 996     JSTestCustomGetterSetter(VM&amp; vm, Structure* structure)
 997         : Base(vm, structure)
<a name="159" id="anc159"></a><span class="line-modified"> 998     { }</span>


 999 
1000     static JSTestCustomGetterSetter* create(VM&amp; vm, JSGlobalObject*, Structure* structure)
1001     {
<a name="160" id="anc160"></a>
1002         JSTestCustomGetterSetter* result = new (NotNull, allocateCell&lt;JSTestCustomGetterSetter&gt;(vm.heap)) JSTestCustomGetterSetter(vm, structure);
1003         result-&gt;finishCreation(vm);
1004         return result;
1005     }
1006 
1007     void finishCreation(VM&amp;);
1008 
1009     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject)
1010     {
<a name="161" id="anc161"></a>
1011         return Structure::create(vm, globalObject, globalObject-&gt;objectPrototype(), TypeInfo(ObjectType, StructureFlags), info());
1012     }
1013 
1014     DECLARE_INFO;
1015 };
1016 
1017 
<a name="162" id="anc162"></a><span class="line-modified">1018 static EncodedJSValue customGetAccessor(ExecState*, EncodedJSValue thisValue, PropertyName)</span>
1019 {
1020     // Passed |this|
1021     return thisValue;
1022 }
1023 
<a name="163" id="anc163"></a><span class="line-modified">1024 static EncodedJSValue customGetValue(ExecState* exec, EncodedJSValue slotValue, PropertyName)</span>
1025 {
<a name="164" id="anc164"></a><span class="line-modified">1026     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(exec-&gt;vm()));</span>
1027     // Passed property holder.
1028     return slotValue;
1029 }
1030 
<a name="165" id="anc165"></a><span class="line-modified">1031 static bool customSetAccessor(ExecState* exec, EncodedJSValue thisObject, EncodedJSValue encodedValue)</span>
1032 {
<a name="166" id="anc166"></a><span class="line-modified">1033     VM&amp; vm = exec-&gt;vm();</span>

1034 
1035     JSValue value = JSValue::decode(encodedValue);
1036     RELEASE_ASSERT(value.isObject());
1037     JSObject* object = asObject(value);
1038     PutPropertySlot slot(object);
<a name="167" id="anc167"></a><span class="line-modified">1039     object-&gt;put(object, exec, Identifier::fromString(vm, &quot;result&quot;), JSValue::decode(thisObject), slot);</span>
1040 
1041     return true;
1042 }
1043 
<a name="168" id="anc168"></a><span class="line-modified">1044 static bool customSetValue(ExecState* exec, EncodedJSValue slotValue, EncodedJSValue encodedValue)</span>
1045 {
<a name="169" id="anc169"></a><span class="line-modified">1046     VM&amp; vm = exec-&gt;vm();</span>

1047 
<a name="170" id="anc170"></a><span class="line-modified">1048     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(exec-&gt;vm()));</span>
1049 
1050     JSValue value = JSValue::decode(encodedValue);
1051     RELEASE_ASSERT(value.isObject());
1052     JSObject* object = asObject(value);
1053     PutPropertySlot slot(object);
<a name="171" id="anc171"></a><span class="line-modified">1054     object-&gt;put(object, exec, Identifier::fromString(vm, &quot;result&quot;), JSValue::decode(slotValue), slot);</span>
1055 
1056     return true;
1057 }
1058 
1059 void JSTestCustomGetterSetter::finishCreation(VM&amp; vm)
1060 {
<a name="172" id="anc172"></a>
1061     Base::finishCreation(vm);
1062 
1063     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customValue&quot;),
1064         CustomGetterSetter::create(vm, customGetValue, customSetValue), 0);
1065     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customAccessor&quot;),
1066         CustomGetterSetter::create(vm, customGetAccessor, customSetAccessor), static_cast&lt;unsigned&gt;(PropertyAttribute::CustomAccessor));
1067 }
1068 
1069 const ClassInfo Element::s_info = { &quot;Element&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Element) };
1070 const ClassInfo Root::s_info = { &quot;Root&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Root) };
1071 const ClassInfo SimpleObject::s_info = { &quot;SimpleObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(SimpleObject) };
1072 const ClassInfo ImpureGetter::s_info = { &quot;ImpureGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ImpureGetter) };
1073 const ClassInfo CustomGetter::s_info = { &quot;CustomGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(CustomGetter) };
1074 const ClassInfo RuntimeArray::s_info = { &quot;RuntimeArray&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(RuntimeArray) };
1075 #if ENABLE(JIT)
1076 const ClassInfo DOMJITNode::s_info = { &quot;DOMJITNode&quot;, &amp;Base::s_info, nullptr, &amp;DOMJITNode::checkSubClassSnippet, CREATE_METHOD_TABLE(DOMJITNode) };
1077 #else
1078 const ClassInfo DOMJITNode::s_info = { &quot;DOMJITNode&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITNode) };
1079 #endif
1080 const ClassInfo DOMJITGetter::s_info = { &quot;DOMJITGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetter) };
1081 const ClassInfo DOMJITGetterComplex::s_info = { &quot;DOMJITGetterComplex&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetterComplex) };
1082 const ClassInfo DOMJITGetterBaseJSObject::s_info = { &quot;DOMJITGetterBaseJSObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetterBaseJSObject) };
1083 #if ENABLE(JIT)
1084 const ClassInfo DOMJITFunctionObject::s_info = { &quot;DOMJITFunctionObject&quot;, &amp;Base::s_info, nullptr, &amp;DOMJITFunctionObject::checkSubClassSnippet, CREATE_METHOD_TABLE(DOMJITFunctionObject) };
1085 #else
1086 const ClassInfo DOMJITFunctionObject::s_info = { &quot;DOMJITFunctionObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITFunctionObject) };
1087 #endif
1088 const ClassInfo DOMJITCheckSubClassObject::s_info = { &quot;DOMJITCheckSubClassObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITCheckSubClassObject) };
1089 const ClassInfo JSTestCustomGetterSetter::s_info = { &quot;JSTestCustomGetterSetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTestCustomGetterSetter) };
1090 
<a name="173" id="anc173"></a>


1091 ElementHandleOwner* Element::handleOwner()
1092 {
<a name="174" id="anc174"></a>
1093     static ElementHandleOwner* owner = 0;
1094     if (!owner)
1095         owner = new ElementHandleOwner();
1096     return owner;
1097 }
1098 
1099 void Element::finishCreation(VM&amp; vm, Root* root)
1100 {
<a name="175" id="anc175"></a>
1101     Base::finishCreation(vm);
1102     setRoot(vm, root);
1103     m_root-&gt;setElement(this);
1104 }
1105 
1106 #if ENABLE(WEBASSEMBLY)
1107 
<a name="176" id="anc176"></a><span class="line-modified">1108 static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(ExecState*);</span>
<span class="line-modified">1109 static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserFinalize(ExecState*);</span>
1110 
1111 class WasmStreamingParser : public JSDestructibleObject {
1112 public:
<a name="177" id="anc177"></a>













1113     WasmStreamingParser(VM&amp; vm, Structure* structure)
1114         : Base(vm, structure)
1115         , m_info(Wasm::ModuleInformation::create())
<a name="178" id="anc178"></a><span class="line-modified">1116         , m_streamingParser(m_info.get())</span>

1117     {
<a name="179" id="anc179"></a>
1118     }
1119 
1120     using Base = JSDestructibleObject;
1121 
1122     static WasmStreamingParser* create(VM&amp; vm, JSGlobalObject* globalObject)
1123     {
<a name="180" id="anc180"></a>
1124         Structure* structure = createStructure(vm, globalObject, jsNull());
1125         WasmStreamingParser* result = new (NotNull, allocateCell&lt;WasmStreamingParser&gt;(vm.heap)) WasmStreamingParser(vm, structure);
1126         result-&gt;finishCreation(vm);
1127         return result;
1128     }
1129 
1130     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1131     {
<a name="181" id="anc181"></a>
1132         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
1133     }
1134 
1135     Wasm::StreamingParser&amp; streamingParser() { return m_streamingParser; }
1136 
1137     void finishCreation(VM&amp; vm)
1138     {
<a name="182" id="anc182"></a>
1139         Base::finishCreation(vm);
1140 
1141         JSGlobalObject* globalObject = this-&gt;globalObject(vm);
1142         putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;addBytes&quot;), 0, functionWasmStreamingParserAddBytes, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
1143         putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;finalize&quot;), 0, functionWasmStreamingParserFinalize, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
1144     }
1145 
1146     DECLARE_INFO;
1147 
1148     Ref&lt;Wasm::ModuleInformation&gt; m_info;
<a name="183" id="anc183"></a>
1149     Wasm::StreamingParser m_streamingParser;
1150 };
1151 
1152 const ClassInfo WasmStreamingParser::s_info = { &quot;WasmStreamingParser&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(WasmStreamingParser) };
1153 
<a name="184" id="anc184"></a><span class="line-modified">1154 EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(ExecState* exec)</span>
1155 {
<a name="185" id="anc185"></a><span class="line-modified">1156     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1157     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());</span>
<span class="line-modified">1158     auto* thisObject = jsDynamicCast&lt;WasmStreamingParser*&gt;(vm, exec-&gt;thisValue());</span>


1159     if (!thisObject)
1160         RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(false)));
1161 
<a name="186" id="anc186"></a><span class="line-modified">1162     auto data = getWasmBufferFromValue(exec, exec-&gt;argument(0));</span>
1163     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1164     RELEASE_AND_RETURN(scope, JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(thisObject-&gt;streamingParser().addBytes(bitwise_cast&lt;const uint8_t*&gt;(data.first), data.second)))));
1165 }
1166 
<a name="187" id="anc187"></a><span class="line-modified">1167 EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserFinalize(ExecState* exec)</span>
1168 {
<a name="188" id="anc188"></a><span class="line-modified">1169     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1170     auto* thisObject = jsDynamicCast&lt;WasmStreamingParser*&gt;(vm, exec-&gt;thisValue());</span>

1171     if (!thisObject)
1172         return JSValue::encode(jsBoolean(false));
1173     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(thisObject-&gt;streamingParser().finalize())));
1174 }
1175 
1176 #endif
1177 
1178 } // namespace
1179 
1180 namespace JSC {
1181 
1182 const ClassInfo JSDollarVM::s_info = { &quot;DollarVM&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDollarVM) };
1183 
1184 // Triggers a crash immediately.
1185 // Usage: $vm.crash()
<a name="189" id="anc189"></a><span class="line-modified">1186 static NO_RETURN_DUE_TO_CRASH EncodedJSValue JSC_HOST_CALL functionCrash(ExecState*)</span>
1187 {
<a name="190" id="anc190"></a>
1188     CRASH();
1189 }
1190 
1191 // Executes a breakpoint instruction if the first argument is truthy or is unset.
1192 // Usage: $vm.breakpoint(&lt;condition&gt;)
<a name="191" id="anc191"></a><span class="line-modified">1193 static EncodedJSValue JSC_HOST_CALL functionBreakpoint(ExecState* exec)</span>
1194 {
<a name="192" id="anc192"></a>
1195     // Nothing should throw here but we might as well double check...
<a name="193" id="anc193"></a><span class="line-modified">1196     VM&amp; vm = exec-&gt;vm();</span>
1197     auto scope = DECLARE_CATCH_SCOPE(vm);
1198     UNUSED_PARAM(scope);
<a name="194" id="anc194"></a><span class="line-modified">1199     if (!exec-&gt;argumentCount() || exec-&gt;argument(0).toBoolean(exec))</span>
1200         WTFBreakpointTrap();
1201 
1202     return encodedJSUndefined();
1203 }
1204 
1205 // Returns true if the current frame is a DFG frame.
1206 // Usage: isDFG = $vm.dfgTrue()
<a name="195" id="anc195"></a><span class="line-modified">1207 static EncodedJSValue JSC_HOST_CALL functionDFGTrue(ExecState*)</span>
1208 {
<a name="196" id="anc196"></a>
1209     return JSValue::encode(jsBoolean(false));
1210 }
1211 
1212 // Returns true if the current frame is a FTL frame.
1213 // Usage: isFTL = $vm.ftlTrue()
<a name="197" id="anc197"></a><span class="line-modified">1214 static EncodedJSValue JSC_HOST_CALL functionFTLTrue(ExecState*)</span>
1215 {
<a name="198" id="anc198"></a>
1216     return JSValue::encode(jsBoolean(false));
1217 }
1218 
<a name="199" id="anc199"></a><span class="line-modified">1219 static EncodedJSValue JSC_HOST_CALL functionCpuMfence(ExecState*)</span>
1220 {
<a name="200" id="anc200"></a>
1221 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1222     asm volatile(&quot;mfence&quot; ::: &quot;memory&quot;);
1223 #endif
1224     return JSValue::encode(jsUndefined());
1225 }
1226 
<a name="201" id="anc201"></a><span class="line-modified">1227 static EncodedJSValue JSC_HOST_CALL functionCpuRdtsc(ExecState*)</span>
1228 {
<a name="202" id="anc202"></a>
1229 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1230     unsigned high;
1231     unsigned low;
1232     asm volatile (&quot;rdtsc&quot; : &quot;=a&quot;(low), &quot;=d&quot;(high));
1233     return JSValue::encode(jsNumber(low));
1234 #else
1235     return JSValue::encode(jsNumber(0));
1236 #endif
1237 }
1238 
<a name="203" id="anc203"></a><span class="line-modified">1239 static EncodedJSValue JSC_HOST_CALL functionCpuCpuid(ExecState*)</span>
1240 {
<a name="204" id="anc204"></a>
1241 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1242     WTF::x86_cpuid();
1243 #endif
1244     return JSValue::encode(jsUndefined());
1245 }
1246 
<a name="205" id="anc205"></a><span class="line-modified">1247 static EncodedJSValue JSC_HOST_CALL functionCpuPause(ExecState*)</span>
1248 {
<a name="206" id="anc206"></a>
1249 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1250     asm volatile (&quot;pause&quot; ::: &quot;memory&quot;);
1251 #endif
1252     return JSValue::encode(jsUndefined());
1253 }
1254 
1255 // This takes either a JSArrayBuffer, JSArrayBufferView*, or any other object as its first
1256 // argument. The second argument is expected to be an integer.
1257 //
1258 // If the first argument is a JSArrayBuffer, it&#39;ll clflush on that buffer
1259 // plus the second argument as a byte offset. It&#39;ll also flush on the object
1260 // itself so its length, etc, aren&#39;t in the cache.
1261 //
1262 // If the first argument is not a JSArrayBuffer, we load the butterfly
1263 // and clflush at the address of the butterfly.
<a name="207" id="anc207"></a><span class="line-modified">1264 static EncodedJSValue JSC_HOST_CALL functionCpuClflush(ExecState* exec)</span>
1265 {
<a name="208" id="anc208"></a>
1266 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
<a name="209" id="anc209"></a><span class="line-modified">1267     VM&amp; vm = exec-&gt;vm();</span>
1268 
<a name="210" id="anc210"></a><span class="line-modified">1269     if (!exec-&gt;argument(1).isInt32())</span>
1270         return JSValue::encode(jsBoolean(false));
1271 
1272     auto clflush = [] (void* ptr) {
<a name="211" id="anc211"></a>
1273         char* ptrToFlush = static_cast&lt;char*&gt;(ptr);
1274         asm volatile (&quot;clflush %0&quot; :: &quot;m&quot;(*ptrToFlush) : &quot;memory&quot;);
1275     };
1276 
1277     Vector&lt;void*&gt; toFlush;
1278 
<a name="212" id="anc212"></a><span class="line-modified">1279     uint32_t offset = exec-&gt;argument(1).asUInt32();</span>
1280 
<a name="213" id="anc213"></a><span class="line-modified">1281     if (JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, exec-&gt;argument(0)))</span>
1282         toFlush.append(bitwise_cast&lt;char*&gt;(view-&gt;vector()) + offset);
<a name="214" id="anc214"></a><span class="line-modified">1283     else if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0))) {</span>
1284         switch (object-&gt;indexingType()) {
1285         case ALL_INT32_INDEXING_TYPES:
1286         case ALL_CONTIGUOUS_INDEXING_TYPES:
1287         case ALL_DOUBLE_INDEXING_TYPES:
1288             toFlush.append(bitwise_cast&lt;char*&gt;(object-&gt;butterfly()) + Butterfly::offsetOfVectorLength());
1289             toFlush.append(bitwise_cast&lt;char*&gt;(object-&gt;butterfly()) + Butterfly::offsetOfPublicLength());
1290         }
1291     }
1292 
1293     if (!toFlush.size())
1294         return JSValue::encode(jsBoolean(false));
1295 
1296     for (void* ptr : toFlush)
1297         clflush(ptr);
1298     return JSValue::encode(jsBoolean(true));
1299 #else
<a name="215" id="anc215"></a><span class="line-modified">1300     UNUSED_PARAM(exec);</span>

1301     return JSValue::encode(jsBoolean(false));
1302 #endif
1303 }
1304 
1305 class CallerFrameJITTypeFunctor {
1306 public:
1307     CallerFrameJITTypeFunctor()
1308         : m_currentFrame(0)
1309         , m_jitType(JITType::None)
1310     {
<a name="216" id="anc216"></a>
1311     }
1312 
1313     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
1314     {
1315         if (m_currentFrame++ &gt; 1) {
1316             m_jitType = visitor-&gt;codeBlock()-&gt;jitType();
1317             return StackVisitor::Done;
1318         }
1319         return StackVisitor::Continue;
1320     }
1321 
1322     JITType jitType() { return m_jitType; }
1323 
1324 private:
1325     mutable unsigned m_currentFrame;
1326     mutable JITType m_jitType;
1327 };
1328 
1329 static FunctionExecutable* getExecutableForFunction(JSValue theFunctionValue)
1330 {
<a name="217" id="anc217"></a>
1331     if (!theFunctionValue.isCell())
1332         return nullptr;
1333 
1334     VM&amp; vm = theFunctionValue.asCell()-&gt;vm();
1335     JSFunction* theFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, theFunctionValue);
1336     if (!theFunction)
1337         return nullptr;
1338 
1339     FunctionExecutable* executable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm,
1340         theFunction-&gt;executable());
1341 
1342     return executable;
1343 }
1344 
1345 // Returns true if the current frame is a LLInt frame.
1346 // Usage: isLLInt = $vm.llintTrue()
<a name="218" id="anc218"></a><span class="line-modified">1347 static EncodedJSValue JSC_HOST_CALL functionLLintTrue(ExecState* exec)</span>
1348 {
<a name="219" id="anc219"></a><span class="line-modified">1349     if (!exec)</span>


1350         return JSValue::encode(jsUndefined());
1351     CallerFrameJITTypeFunctor functor;
<a name="220" id="anc220"></a><span class="line-modified">1352     exec-&gt;iterate(functor);</span>
1353     return JSValue::encode(jsBoolean(functor.jitType() == JITType::InterpreterThunk));
1354 }
1355 
1356 // Returns true if the current frame is a baseline JIT frame.
1357 // Usage: isBaselineJIT = $vm.jitTrue()
<a name="221" id="anc221"></a><span class="line-modified">1358 static EncodedJSValue JSC_HOST_CALL functionJITTrue(ExecState* exec)</span>
1359 {
<a name="222" id="anc222"></a><span class="line-modified">1360     if (!exec)</span>


1361         return JSValue::encode(jsUndefined());
1362     CallerFrameJITTypeFunctor functor;
<a name="223" id="anc223"></a><span class="line-modified">1363     exec-&gt;iterate(functor);</span>
1364     return JSValue::encode(jsBoolean(functor.jitType() == JITType::BaselineJIT));
1365 }
1366 
1367 // Set that the argument function should not be inlined.
1368 // Usage:
1369 // function f() { };
1370 // $vm.noInline(f);
<a name="224" id="anc224"></a><span class="line-modified">1371 static EncodedJSValue JSC_HOST_CALL functionNoInline(ExecState* exec)</span>
1372 {
<a name="225" id="anc225"></a><span class="line-modified">1373     if (exec-&gt;argumentCount() &lt; 1)</span>

1374         return JSValue::encode(jsUndefined());
1375 
<a name="226" id="anc226"></a><span class="line-modified">1376     JSValue theFunctionValue = exec-&gt;uncheckedArgument(0);</span>
1377 
1378     if (FunctionExecutable* executable = getExecutableForFunction(theFunctionValue))
1379         executable-&gt;setNeverInline(true);
1380 
1381     return JSValue::encode(jsUndefined());
1382 }
1383 
1384 // Runs a full GC synchronously.
1385 // Usage: $vm.gc()
<a name="227" id="anc227"></a><span class="line-modified">1386 static EncodedJSValue JSC_HOST_CALL functionGC(ExecState* exec)</span>
1387 {
<a name="228" id="anc228"></a><span class="line-modified">1388     VMInspector::gc(exec);</span>

1389     return JSValue::encode(jsUndefined());
1390 }
1391 
1392 // Runs the edenGC synchronously.
1393 // Usage: $vm.edenGC()
<a name="229" id="anc229"></a><span class="line-modified">1394 static EncodedJSValue JSC_HOST_CALL functionEdenGC(ExecState* exec)</span>
1395 {
<a name="230" id="anc230"></a><span class="line-modified">1396     VMInspector::edenGC(exec);</span>

1397     return JSValue::encode(jsUndefined());
1398 }
1399 
1400 // Dumps the hashes of all subspaces currently registered with the VM.
1401 // Usage: $vm.dumpSubspaceHashes()
<a name="231" id="anc231"></a><span class="line-modified">1402 static EncodedJSValue JSC_HOST_CALL functionDumpSubspaceHashes(ExecState* exec)</span>
1403 {
<a name="232" id="anc232"></a><span class="line-modified">1404     VM&amp; vm = exec-&gt;vm();</span>

1405     VMInspector::dumpSubspaceHashes(&amp;vm);
1406     return JSValue::encode(jsUndefined());
1407 }
1408 
1409 // Gets a JSDollarVMCallFrame for a specified frame index.
1410 // Usage: var callFrame = $vm.callFrame(0) // frame 0 is the top frame.
1411 // Usage: var callFrame = $vm.callFrame() // implies frame 0 i.e. current frame.
1412 //
1413 // This gives you the ability to query the following:
1414 //    callFrame.valid; // false if we asked for a frame beyond the end of the stack, else true.
1415 //    callFrame.callee;
1416 //    callFrame.codeBlock;
1417 //    callFrame.unlinkedCodeBlock;
1418 //    callFrame.executable;
1419 //
1420 // Note: you cannot toString() a codeBlock, unlinkedCodeBlock, or executable because
1421 // there are internal objects and not a JS object. Hence, you cannot do string
1422 // concatenation with them.
<a name="233" id="anc233"></a><span class="line-modified">1423 static EncodedJSValue JSC_HOST_CALL functionCallFrame(ExecState* exec)</span>
1424 {
<a name="234" id="anc234"></a>
1425     unsigned frameNumber = 1;
<a name="235" id="anc235"></a><span class="line-modified">1426     if (exec-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">1427         JSValue value = exec-&gt;uncheckedArgument(0);</span>
1428         if (!value.isUInt32())
1429             return JSValue::encode(jsUndefined());
1430 
1431         // We need to inc the frame number because the caller would consider
1432         // its own frame as frame 0. Hence, we need discount the frame for this
1433         // function.
1434         frameNumber = value.asUInt32() + 1;
1435     }
1436 
<a name="236" id="anc236"></a><span class="line-modified">1437     return JSValue::encode(JSDollarVMCallFrame::create(exec, frameNumber));</span>
1438 }
1439 
1440 // Gets a token for the CodeBlock for a specified frame index.
1441 // Usage: codeBlockToken = $vm.codeBlockForFrame(0) // frame 0 is the top frame.
1442 // Usage: codeBlockToken = $vm.codeBlockForFrame() // implies frame 0 i.e. current frame.
<a name="237" id="anc237"></a><span class="line-modified">1443 static EncodedJSValue JSC_HOST_CALL functionCodeBlockForFrame(ExecState* exec)</span>
1444 {
<a name="238" id="anc238"></a>
1445     unsigned frameNumber = 1;
<a name="239" id="anc239"></a><span class="line-modified">1446     if (exec-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">1447         JSValue value = exec-&gt;uncheckedArgument(0);</span>
1448         if (!value.isUInt32())
1449             return JSValue::encode(jsUndefined());
1450 
1451         // We need to inc the frame number because the caller would consider
1452         // its own frame as frame 0. Hence, we need discount the frame for this
1453         // function.
1454         frameNumber = value.asUInt32() + 1;
1455     }
1456 
<a name="240" id="anc240"></a><span class="line-modified">1457     CodeBlock* codeBlock = VMInspector::codeBlockForFrame(exec, frameNumber);</span>
1458     if (codeBlock)
1459         return JSValue::encode(codeBlock);
1460     return JSValue::encode(jsUndefined());
1461 }
1462 
<a name="241" id="anc241"></a><span class="line-modified">1463 static CodeBlock* codeBlockFromArg(ExecState* exec)</span>
1464 {
<a name="242" id="anc242"></a><span class="line-modified">1465     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1466     if (exec-&gt;argumentCount() &lt; 1)</span>

1467         return nullptr;
1468 
<a name="243" id="anc243"></a><span class="line-modified">1469     JSValue value = exec-&gt;uncheckedArgument(0);</span>
1470     CodeBlock* candidateCodeBlock = nullptr;
1471     if (value.isCell()) {
1472         JSFunction* func = jsDynamicCast&lt;JSFunction*&gt;(vm, value.asCell());
1473         if (func) {
1474             if (func-&gt;isHostFunction())
1475                 candidateCodeBlock = nullptr;
1476             else
1477                 candidateCodeBlock = func-&gt;jsExecutable()-&gt;eitherCodeBlock();
1478         } else
1479             candidateCodeBlock = static_cast&lt;CodeBlock*&gt;(value.asCell());
1480     }
1481 
<a name="244" id="anc244"></a><span class="line-modified">1482     if (candidateCodeBlock &amp;&amp; VMInspector::isValidCodeBlock(exec, candidateCodeBlock))</span>
1483         return candidateCodeBlock;
1484 
1485     if (candidateCodeBlock)
1486         dataLog(&quot;Invalid codeBlock: &quot;, RawPointer(candidateCodeBlock), &quot; &quot;, value, &quot;\n&quot;);
1487     else
1488         dataLog(&quot;Invalid codeBlock: &quot;, value, &quot;\n&quot;);
1489     return nullptr;
1490 }
1491 
1492 // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(functionObj))
1493 // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(codeBlockToken))
1494 // Note: you cannot toString() a codeBlock because it&#39;s an internal object and not
1495 // a JS object. Hence, you cannot do string concatenation with it.
<a name="245" id="anc245"></a><span class="line-modified">1496 static EncodedJSValue JSC_HOST_CALL functionCodeBlockFor(ExecState* exec)</span>
1497 {
<a name="246" id="anc246"></a><span class="line-modified">1498     CodeBlock* codeBlock = codeBlockFromArg(exec);</span>

1499     WTF::StringPrintStream stream;
1500     if (codeBlock) {
1501         stream.print(*codeBlock);
<a name="247" id="anc247"></a><span class="line-modified">1502         return JSValue::encode(jsString(exec-&gt;vm(), stream.toString()));</span>
1503     }
1504     return JSValue::encode(jsUndefined());
1505 }
1506 
1507 // Usage: $vm.dumpSourceFor(functionObj)
1508 // Usage: $vm.dumpSourceFor(codeBlockToken)
<a name="248" id="anc248"></a><span class="line-modified">1509 static EncodedJSValue JSC_HOST_CALL functionDumpSourceFor(ExecState* exec)</span>
1510 {
<a name="249" id="anc249"></a><span class="line-modified">1511     CodeBlock* codeBlock = codeBlockFromArg(exec);</span>

1512     if (codeBlock)
1513         codeBlock-&gt;dumpSource();
1514     return JSValue::encode(jsUndefined());
1515 }
1516 
1517 // Usage: $vm.dumpBytecodeFor(functionObj)
1518 // Usage: $vm.dumpBytecodeFor(codeBlock)
<a name="250" id="anc250"></a><span class="line-modified">1519 static EncodedJSValue JSC_HOST_CALL functionDumpBytecodeFor(ExecState* exec)</span>
1520 {
<a name="251" id="anc251"></a><span class="line-modified">1521     CodeBlock* codeBlock = codeBlockFromArg(exec);</span>

1522     if (codeBlock)
1523         codeBlock-&gt;dumpBytecode();
1524     return JSValue::encode(jsUndefined());
1525 }
1526 
<a name="252" id="anc252"></a><span class="line-modified">1527 static EncodedJSValue doPrint(ExecState* exec, bool addLineFeed)</span>
1528 {
<a name="253" id="anc253"></a><span class="line-modified">1529     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());</span>
<span class="line-modified">1530     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">1531         JSValue arg = exec-&gt;uncheckedArgument(i);</span>

1532         if (arg.isCell()
1533             &amp;&amp; !arg.isObject()
1534             &amp;&amp; !arg.isString()
1535             &amp;&amp; !arg.isBigInt()) {
1536             dataLog(arg);
1537             continue;
1538         }
<a name="254" id="anc254"></a><span class="line-modified">1539         String argStr = exec-&gt;uncheckedArgument(i).toWTFString(exec);</span>
1540         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1541         dataLog(argStr);
1542     }
1543     if (addLineFeed)
1544         dataLog(&quot;\n&quot;);
1545     return JSValue::encode(jsUndefined());
1546 }
1547 
1548 // Prints a series of comma separate strings without appending a newline.
1549 // Usage: $vm.dataLog(str1, str2, str3)
<a name="255" id="anc255"></a><span class="line-modified">1550 static EncodedJSValue JSC_HOST_CALL functionDataLog(ExecState* exec)</span>
1551 {
<a name="256" id="anc256"></a>
1552     const bool addLineFeed = false;
<a name="257" id="anc257"></a><span class="line-modified">1553     return doPrint(exec, addLineFeed);</span>
1554 }
1555 
1556 // Prints a series of comma separate strings and appends a newline.
1557 // Usage: $vm.print(str1, str2, str3)
<a name="258" id="anc258"></a><span class="line-modified">1558 static EncodedJSValue JSC_HOST_CALL functionPrint(ExecState* exec)</span>
1559 {
<a name="259" id="anc259"></a>
1560     const bool addLineFeed = true;
<a name="260" id="anc260"></a><span class="line-modified">1561     return doPrint(exec, addLineFeed);</span>
1562 }
1563 
1564 // Dumps the current CallFrame.
1565 // Usage: $vm.dumpCallFrame()
<a name="261" id="anc261"></a><span class="line-modified">1566 static EncodedJSValue JSC_HOST_CALL functionDumpCallFrame(ExecState* exec)</span>
1567 {
<a name="262" id="anc262"></a>
1568     // When the callers call this function, they are expecting to dump their
1569     // own frame. So skip 1 for this frame.
<a name="263" id="anc263"></a><span class="line-modified">1570     VMInspector::dumpCallFrame(exec, 1);</span>
1571     return JSValue::encode(jsUndefined());
1572 }
1573 
1574 // Dumps the JS stack.
1575 // Usage: $vm.printStack()
<a name="264" id="anc264"></a><span class="line-modified">1576 static EncodedJSValue JSC_HOST_CALL functionDumpStack(ExecState* exec)</span>
1577 {
<a name="265" id="anc265"></a>
1578     // When the callers call this function, they are expecting to dump the
1579     // stack starting their own frame. So skip 1 for this frame.
<a name="266" id="anc266"></a><span class="line-modified">1580     VMInspector::dumpStack(exec, 1);</span>
1581     return JSValue::encode(jsUndefined());
1582 }
1583 
1584 // Dumps the current CallFrame.
1585 // Usage: $vm.dumpRegisters(N) // dump the registers of the Nth CallFrame.
1586 // Usage: $vm.dumpRegisters() // dump the registers of the current CallFrame.
1587 // FIXME: Currently, this function dumps the physical frame. We should make
1588 // it dump the logical frame (i.e. be able to dump inlined frames as well).
<a name="267" id="anc267"></a><span class="line-modified">1589 static EncodedJSValue JSC_HOST_CALL functionDumpRegisters(ExecState* exec)</span>
1590 {
<a name="268" id="anc268"></a>

1591     unsigned requestedFrameIndex = 1;
<a name="269" id="anc269"></a><span class="line-modified">1592     if (exec-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">1593         JSValue value = exec-&gt;uncheckedArgument(0);</span>
1594         if (!value.isUInt32())
1595             return JSValue::encode(jsUndefined());
1596 
1597         // We need to inc the frame number because the caller would consider
1598         // its own frame as frame 0. Hence, we need discount the frame for this
1599         // function.
1600         requestedFrameIndex = value.asUInt32() + 1;
1601     }
1602 
1603     unsigned frameIndex = 0;
<a name="270" id="anc270"></a><span class="line-modified">1604     exec-&gt;iterate([&amp;] (StackVisitor&amp; visitor) {</span>

1605         if (frameIndex++ != requestedFrameIndex)
1606             return StackVisitor::Continue;
1607         VMInspector::dumpRegisters(visitor-&gt;callFrame());
1608         return StackVisitor::Done;
1609     });
1610 
1611     return encodedJSUndefined();
1612 }
1613 
1614 // Dumps the internal memory layout of a JSCell.
1615 // Usage: $vm.dumpCell(cell)
<a name="271" id="anc271"></a><span class="line-modified">1616 static EncodedJSValue JSC_HOST_CALL functionDumpCell(ExecState* exec)</span>
1617 {
<a name="272" id="anc272"></a><span class="line-modified">1618     JSValue value = exec-&gt;argument(0);</span>

1619     if (!value.isCell())
1620         return encodedJSUndefined();
1621 
1622     VMInspector::dumpCellMemory(value.asCell());
1623     return encodedJSUndefined();
1624 }
1625 
1626 // Gets the dataLog dump of the indexingMode of the passed value.
1627 // Usage: $vm.print(&quot;indexingMode = &quot; + $vm.indexingMode(jsValue))
<a name="273" id="anc273"></a><span class="line-modified">1628 static EncodedJSValue JSC_HOST_CALL functionIndexingMode(ExecState* exec)</span>
1629 {
<a name="274" id="anc274"></a><span class="line-modified">1630     if (!exec-&gt;argument(0).isObject())</span>

1631         return encodedJSUndefined();
1632 
1633     WTF::StringPrintStream stream;
<a name="275" id="anc275"></a><span class="line-modified">1634     stream.print(IndexingTypeDump(exec-&gt;uncheckedArgument(0).getObject()-&gt;indexingMode()));</span>
<span class="line-modified">1635     return JSValue::encode(jsString(exec-&gt;vm(), stream.toString()));</span>
1636 }
1637 
<a name="276" id="anc276"></a><span class="line-modified">1638 static EncodedJSValue JSC_HOST_CALL functionInlineCapacity(ExecState* exec)</span>
1639 {
<a name="277" id="anc277"></a><span class="line-modified">1640     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1641     if (auto* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0)))</span>

1642         return JSValue::encode(jsNumber(object-&gt;structure(vm)-&gt;inlineCapacity()));
1643 
1644     return encodedJSUndefined();
1645 }
1646 
1647 // Gets the dataLog dump of a given JS value as a string.
1648 // Usage: $vm.print(&quot;value = &quot; + $vm.value(jsValue))
<a name="278" id="anc278"></a><span class="line-modified">1649 static EncodedJSValue JSC_HOST_CALL functionValue(ExecState* exec)</span>
1650 {
<a name="279" id="anc279"></a>
1651     WTF::StringPrintStream stream;
<a name="280" id="anc280"></a><span class="line-modified">1652     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
1653         if (i)
1654             stream.print(&quot;, &quot;);
<a name="281" id="anc281"></a><span class="line-modified">1655         stream.print(exec-&gt;uncheckedArgument(i));</span>
1656     }
1657 
<a name="282" id="anc282"></a><span class="line-modified">1658     return JSValue::encode(jsString(exec-&gt;vm(), stream.toString()));</span>
1659 }
1660 
1661 // Gets the pid of the current process.
1662 // Usage: $vm.print(&quot;pid = &quot; + $vm.getpid())
<a name="283" id="anc283"></a><span class="line-modified">1663 static EncodedJSValue JSC_HOST_CALL functionGetPID(ExecState*)</span>
1664 {
<a name="284" id="anc284"></a>
1665     return JSValue::encode(jsNumber(getCurrentProcessID()));
1666 }
1667 
1668 // Make the globalObject have a bad time. Does nothing if the object is not a JSGlobalObject.
1669 // Usage: $vm.haveABadTime(globalObject)
<a name="285" id="anc285"></a><span class="line-modified">1670 static EncodedJSValue JSC_HOST_CALL functionHaveABadTime(ExecState* exec)</span>
1671 {
<a name="286" id="anc286"></a><span class="line-modified">1672     VM&amp; vm = exec-&gt;vm();</span>

1673     JSLockHolder lock(vm);
<a name="287" id="anc287"></a><span class="line-modified">1674     JSValue objValue = exec-&gt;argument(0);</span>
1675     if (!objValue.isObject())
1676         return JSValue::encode(jsBoolean(false));
1677 
1678     JSObject* obj = asObject(objValue.asCell());
<a name="288" id="anc288"></a><span class="line-modified">1679     JSGlobalObject* globalObject = jsDynamicCast&lt;JSGlobalObject*&gt;(vm, obj);</span>
<span class="line-modified">1680     if (!globalObject)</span>
1681         JSValue::encode(jsBoolean(false));
1682 
<a name="289" id="anc289"></a><span class="line-modified">1683     globalObject-&gt;haveABadTime(vm);</span>
1684     return JSValue::encode(jsBoolean(true));
1685 }
1686 
1687 // Checks if the object (or its global if the object is not a global) is having a bad time.
1688 // Usage: $vm.isHavingABadTime(obj)
<a name="290" id="anc290"></a><span class="line-modified">1689 static EncodedJSValue JSC_HOST_CALL functionIsHavingABadTime(ExecState* exec)</span>
1690 {
<a name="291" id="anc291"></a><span class="line-modified">1691     VM&amp; vm = exec-&gt;vm();</span>

1692     JSLockHolder lock(vm);
<a name="292" id="anc292"></a><span class="line-modified">1693     JSValue objValue = exec-&gt;argument(0);</span>
1694     if (!objValue.isObject())
1695         return JSValue::encode(jsUndefined());
1696 
1697     JSObject* obj = asObject(objValue.asCell());
<a name="293" id="anc293"></a><span class="line-modified">1698     JSGlobalObject* globalObject = jsDynamicCast&lt;JSGlobalObject*&gt;(vm, obj);</span>
<span class="line-modified">1699     if (globalObject)</span>
<span class="line-modified">1700         JSValue::encode(jsBoolean(globalObject-&gt;isHavingABadTime()));</span>
1701 
<a name="294" id="anc294"></a><span class="line-modified">1702     globalObject = obj-&gt;globalObject();</span>
<span class="line-modified">1703     if (!globalObject)</span>
1704         return JSValue::encode(jsUndefined());
1705 
<a name="295" id="anc295"></a><span class="line-modified">1706     return JSValue::encode(jsBoolean(globalObject-&gt;isHavingABadTime()));</span>

























































































































1707 }
1708 
1709 // Creates a new global object.
1710 // Usage: $vm.createGlobalObject()
<a name="296" id="anc296"></a><span class="line-modified">1711 static EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(ExecState* exec)</span>
1712 {
<a name="297" id="anc297"></a><span class="line-modified">1713     VM&amp; vm = exec-&gt;vm();</span>

1714     JSLockHolder lock(vm);
<a name="298" id="anc298"></a><span class="line-modified">1715     JSGlobalObject* globalObject = JSGlobalObject::create(vm, JSGlobalObject::createStructure(vm, jsNull()));</span>
<span class="line-removed">1716     return JSValue::encode(globalObject);</span>
1717 }
1718 
<a name="299" id="anc299"></a><span class="line-modified">1719 static EncodedJSValue JSC_HOST_CALL functionCreateProxy(ExecState* exec)</span>
1720 {
<a name="300" id="anc300"></a><span class="line-modified">1721     VM&amp; vm = exec-&gt;vm();</span>

1722     JSLockHolder lock(vm);
<a name="301" id="anc301"></a><span class="line-modified">1723     JSValue target = exec-&gt;argument(0);</span>
1724     if (!target.isObject())
1725         return JSValue::encode(jsUndefined());
1726     JSObject* jsTarget = asObject(target.asCell());
<a name="302" id="anc302"></a><span class="line-modified">1727     Structure* structure = JSProxy::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsTarget-&gt;getPrototypeDirect(vm), ImpureProxyType);</span>
1728     JSProxy* proxy = JSProxy::create(vm, structure, jsTarget);
1729     return JSValue::encode(proxy);
1730 }
1731 
<a name="303" id="anc303"></a><span class="line-modified">1732 static EncodedJSValue JSC_HOST_CALL functionCreateRuntimeArray(ExecState* exec)</span>
1733 {
<a name="304" id="anc304"></a><span class="line-modified">1734     JSLockHolder lock(exec);</span>
<span class="line-modified">1735     RuntimeArray* array = RuntimeArray::create(exec);</span>

1736     return JSValue::encode(array);
1737 }
1738 
<a name="305" id="anc305"></a><span class="line-modified">1739 static EncodedJSValue JSC_HOST_CALL functionCreateNullRopeString(ExecState* exec)</span>
1740 {
<a name="306" id="anc306"></a><span class="line-modified">1741     VM&amp; vm = exec-&gt;vm();</span>

1742     JSLockHolder lock(vm);
1743     return JSValue::encode(JSRopeString::createNullForTesting(vm));
1744 }
1745 
<a name="307" id="anc307"></a><span class="line-modified">1746 static EncodedJSValue JSC_HOST_CALL functionCreateImpureGetter(ExecState* exec)</span>
1747 {
<a name="308" id="anc308"></a><span class="line-modified">1748     VM&amp; vm = exec-&gt;vm();</span>

1749     JSLockHolder lock(vm);
<a name="309" id="anc309"></a><span class="line-modified">1750     JSValue target = exec-&gt;argument(0);</span>
1751     JSObject* delegate = nullptr;
1752     if (target.isObject())
1753         delegate = asObject(target.asCell());
<a name="310" id="anc310"></a><span class="line-modified">1754     Structure* structure = ImpureGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
1755     ImpureGetter* result = ImpureGetter::create(vm, structure, delegate);
1756     return JSValue::encode(result);
1757 }
1758 
<a name="311" id="anc311"></a><span class="line-modified">1759 static EncodedJSValue JSC_HOST_CALL functionCreateCustomGetterObject(ExecState* exec)</span>
1760 {
<a name="312" id="anc312"></a><span class="line-modified">1761     VM&amp; vm = exec-&gt;vm();</span>

1762     JSLockHolder lock(vm);
<a name="313" id="anc313"></a><span class="line-modified">1763     Structure* structure = CustomGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
1764     CustomGetter* result = CustomGetter::create(vm, structure);
1765     return JSValue::encode(result);
1766 }
1767 
<a name="314" id="anc314"></a><span class="line-modified">1768 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITNodeObject(ExecState* exec)</span>
1769 {
<a name="315" id="anc315"></a><span class="line-modified">1770     VM&amp; vm = exec-&gt;vm();</span>

1771     JSLockHolder lock(vm);
<a name="316" id="anc316"></a><span class="line-modified">1772     Structure* structure = DOMJITNode::createStructure(vm, exec-&gt;lexicalGlobalObject(), DOMJITGetter::create(vm, DOMJITGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull())));</span>
1773     DOMJITNode* result = DOMJITNode::create(vm, structure);
1774     return JSValue::encode(result);
1775 }
1776 
<a name="317" id="anc317"></a><span class="line-modified">1777 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterObject(ExecState* exec)</span>
1778 {
<a name="318" id="anc318"></a><span class="line-modified">1779     VM&amp; vm = exec-&gt;vm();</span>

1780     JSLockHolder lock(vm);
<a name="319" id="anc319"></a><span class="line-modified">1781     Structure* structure = DOMJITGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
1782     DOMJITGetter* result = DOMJITGetter::create(vm, structure);
1783     return JSValue::encode(result);
1784 }
1785 
<a name="320" id="anc320"></a><span class="line-modified">1786 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterComplexObject(ExecState* exec)</span>
1787 {
<a name="321" id="anc321"></a><span class="line-modified">1788     VM&amp; vm = exec-&gt;vm();</span>

1789     JSLockHolder lock(vm);
<a name="322" id="anc322"></a><span class="line-modified">1790     Structure* structure = DOMJITGetterComplex::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
<span class="line-modified">1791     DOMJITGetterComplex* result = DOMJITGetterComplex::create(vm, exec-&gt;lexicalGlobalObject(), structure);</span>
1792     return JSValue::encode(result);
1793 }
1794 
<a name="323" id="anc323"></a><span class="line-modified">1795 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITFunctionObject(ExecState* exec)</span>
1796 {
<a name="324" id="anc324"></a><span class="line-modified">1797     VM&amp; vm = exec-&gt;vm();</span>

1798     JSLockHolder lock(vm);
<a name="325" id="anc325"></a><span class="line-modified">1799     Structure* structure = DOMJITFunctionObject::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
<span class="line-modified">1800     DOMJITFunctionObject* result = DOMJITFunctionObject::create(vm, exec-&gt;lexicalGlobalObject(), structure);</span>
1801     return JSValue::encode(result);
1802 }
1803 
<a name="326" id="anc326"></a><span class="line-modified">1804 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITCheckSubClassObject(ExecState* exec)</span>
1805 {
<a name="327" id="anc327"></a><span class="line-modified">1806     VM&amp; vm = exec-&gt;vm();</span>

1807     JSLockHolder lock(vm);
<a name="328" id="anc328"></a><span class="line-modified">1808     Structure* structure = DOMJITCheckSubClassObject::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
<span class="line-modified">1809     DOMJITCheckSubClassObject* result = DOMJITCheckSubClassObject::create(vm, exec-&gt;lexicalGlobalObject(), structure);</span>
1810     return JSValue::encode(result);
1811 }
1812 
<a name="329" id="anc329"></a><span class="line-modified">1813 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterBaseJSObject(ExecState* exec)</span>
1814 {
<a name="330" id="anc330"></a><span class="line-modified">1815     VM&amp; vm = exec-&gt;vm();</span>

1816     JSLockHolder lock(vm);
<a name="331" id="anc331"></a><span class="line-modified">1817     Structure* structure = DOMJITGetterBaseJSObject::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
1818     DOMJITGetterBaseJSObject* result = DOMJITGetterBaseJSObject::create(vm, structure);
1819     return JSValue::encode(result);
1820 }
1821 
1822 #if ENABLE(WEBASSEMBLY)
<a name="332" id="anc332"></a><span class="line-modified">1823 static EncodedJSValue JSC_HOST_CALL functionCreateWasmStreamingParser(ExecState* exec)</span>
1824 {
<a name="333" id="anc333"></a><span class="line-modified">1825     VM&amp; vm = exec-&gt;vm();</span>

1826     JSLockHolder lock(vm);
<a name="334" id="anc334"></a><span class="line-modified">1827     return JSValue::encode(WasmStreamingParser::create(vm, exec-&gt;lexicalGlobalObject()));</span>
1828 }
1829 #endif
1830 
<a name="335" id="anc335"></a><span class="line-modified">1831 static EncodedJSValue JSC_HOST_CALL functionSetImpureGetterDelegate(ExecState* exec)</span>










1832 {
<a name="336" id="anc336"></a><span class="line-modified">1833     VM&amp; vm = exec-&gt;vm();</span>













1834     JSLockHolder lock(vm);
1835     auto scope = DECLARE_THROW_SCOPE(vm);
1836 
<a name="337" id="anc337"></a><span class="line-modified">1837     JSValue base = exec-&gt;argument(0);</span>
1838     if (!base.isObject())
1839         return JSValue::encode(jsUndefined());
<a name="338" id="anc338"></a><span class="line-modified">1840     JSValue delegate = exec-&gt;argument(1);</span>
1841     if (!delegate.isObject())
1842         return JSValue::encode(jsUndefined());
1843     ImpureGetter* impureGetter = jsDynamicCast&lt;ImpureGetter*&gt;(vm, asObject(base.asCell()));
1844     if (UNLIKELY(!impureGetter)) {
<a name="339" id="anc339"></a><span class="line-modified">1845         throwTypeError(exec, scope, &quot;argument is not an ImpureGetter&quot;_s);</span>
1846         return encodedJSValue();
1847     }
1848     impureGetter-&gt;setDelegate(vm, asObject(delegate.asCell()));
1849     return JSValue::encode(jsUndefined());
1850 }
1851 
<a name="340" id="anc340"></a><span class="line-modified">1852 static EncodedJSValue JSC_HOST_CALL functionCreateBuiltin(ExecState* exec)</span>
1853 {
<a name="341" id="anc341"></a><span class="line-modified">1854     VM&amp; vm = exec-&gt;vm();</span>

1855     auto scope = DECLARE_THROW_SCOPE(vm);
1856 
<a name="342" id="anc342"></a><span class="line-modified">1857     if (exec-&gt;argumentCount() &lt; 1 || !exec-&gt;argument(0).isString())</span>
1858         return JSValue::encode(jsUndefined());
1859 
<a name="343" id="anc343"></a><span class="line-modified">1860     String functionText = asString(exec-&gt;argument(0))-&gt;value(exec);</span>
1861     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1862 
<a name="344" id="anc344"></a><span class="line-modified">1863     const SourceCode&amp; source = makeSource(functionText, { });</span>
<span class="line-modified">1864     JSFunction* func = JSFunction::create(vm, createBuiltinExecutable(vm, source, Identifier::fromString(vm, &quot;foo&quot;), ConstructorKind::None, ConstructAbility::CannotConstruct)-&gt;link(vm, nullptr, source), exec-&gt;lexicalGlobalObject());</span>
1865 
1866     return JSValue::encode(func);
1867 }
1868 
<a name="345" id="anc345"></a><span class="line-modified">1869 static EncodedJSValue JSC_HOST_CALL functionGetPrivateProperty(ExecState* exec)</span>
1870 {
<a name="346" id="anc346"></a><span class="line-modified">1871     VM&amp; vm = exec-&gt;vm();</span>

1872     auto scope = DECLARE_THROW_SCOPE(vm);
1873 
<a name="347" id="anc347"></a><span class="line-modified">1874     if (exec-&gt;argumentCount() &lt; 2 || !exec-&gt;argument(1).isString())</span>
1875         return encodedJSUndefined();
1876 
<a name="348" id="anc348"></a><span class="line-modified">1877     String str = asString(exec-&gt;argument(1))-&gt;value(exec);</span>
1878 
1879     SymbolImpl* symbol = vm.propertyNames-&gt;lookUpPrivateName(Identifier::fromString(vm, str));
1880     if (!symbol)
<a name="349" id="anc349"></a><span class="line-modified">1881         return throwVMError(exec, scope, &quot;Unknown private name.&quot;);</span>
1882 
<a name="350" id="anc350"></a><span class="line-modified">1883     RELEASE_AND_RETURN(scope, JSValue::encode(exec-&gt;argument(0).get(exec, symbol)));</span>
1884 }
1885 
<a name="351" id="anc351"></a><span class="line-modified">1886 static EncodedJSValue JSC_HOST_CALL functionCreateRoot(ExecState* exec)</span>
1887 {
<a name="352" id="anc352"></a><span class="line-modified">1888     VM&amp; vm = exec-&gt;vm();</span>

1889     JSLockHolder lock(vm);
<a name="353" id="anc353"></a><span class="line-modified">1890     return JSValue::encode(Root::create(vm, exec-&gt;lexicalGlobalObject()));</span>
1891 }
1892 
<a name="354" id="anc354"></a><span class="line-modified">1893 static EncodedJSValue JSC_HOST_CALL functionCreateElement(ExecState* exec)</span>
1894 {
<a name="355" id="anc355"></a><span class="line-modified">1895     VM&amp; vm = exec-&gt;vm();</span>

1896     JSLockHolder lock(vm);
1897     auto scope = DECLARE_THROW_SCOPE(vm);
1898 
<a name="356" id="anc356"></a><span class="line-modified">1899     Root* root = jsDynamicCast&lt;Root*&gt;(vm, exec-&gt;argument(0));</span>
1900     if (!root)
<a name="357" id="anc357"></a><span class="line-modified">1901         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Cannot create Element without a Root.&quot;_s)));</span>
<span class="line-modified">1902     return JSValue::encode(Element::create(vm, exec-&gt;lexicalGlobalObject(), root));</span>
1903 }
1904 
<a name="358" id="anc358"></a><span class="line-modified">1905 static EncodedJSValue JSC_HOST_CALL functionGetElement(ExecState* exec)</span>
1906 {
<a name="359" id="anc359"></a><span class="line-modified">1907     VM&amp; vm = exec-&gt;vm();</span>

1908     JSLockHolder lock(vm);
<a name="360" id="anc360"></a><span class="line-modified">1909     Root* root = jsDynamicCast&lt;Root*&gt;(vm, exec-&gt;argument(0));</span>
1910     if (!root)
1911         return JSValue::encode(jsUndefined());
1912     Element* result = root-&gt;element();
1913     return JSValue::encode(result ? result : jsUndefined());
1914 }
1915 
<a name="361" id="anc361"></a><span class="line-modified">1916 static EncodedJSValue JSC_HOST_CALL functionCreateSimpleObject(ExecState* exec)</span>
1917 {
<a name="362" id="anc362"></a><span class="line-modified">1918     VM&amp; vm = exec-&gt;vm();</span>

1919     JSLockHolder lock(vm);
<a name="363" id="anc363"></a><span class="line-modified">1920     return JSValue::encode(SimpleObject::create(vm, exec-&gt;lexicalGlobalObject()));</span>
1921 }
1922 
<a name="364" id="anc364"></a><span class="line-modified">1923 static EncodedJSValue JSC_HOST_CALL functionGetHiddenValue(ExecState* exec)</span>
1924 {
<a name="365" id="anc365"></a><span class="line-modified">1925     VM&amp; vm = exec-&gt;vm();</span>

1926     JSLockHolder lock(vm);
1927     auto scope = DECLARE_THROW_SCOPE(vm);
1928 
<a name="366" id="anc366"></a><span class="line-modified">1929     SimpleObject* simpleObject = jsDynamicCast&lt;SimpleObject*&gt;(vm, exec-&gt;argument(0));</span>
1930     if (UNLIKELY(!simpleObject)) {
<a name="367" id="anc367"></a><span class="line-modified">1931         throwTypeError(exec, scope, &quot;Invalid use of getHiddenValue test function&quot;_s);</span>
1932         return encodedJSValue();
1933     }
1934     return JSValue::encode(simpleObject-&gt;hiddenValue());
1935 }
1936 
<a name="368" id="anc368"></a><span class="line-modified">1937 static EncodedJSValue JSC_HOST_CALL functionSetHiddenValue(ExecState* exec)</span>
1938 {
<a name="369" id="anc369"></a><span class="line-modified">1939     VM&amp; vm = exec-&gt;vm();</span>

1940     JSLockHolder lock(vm);
1941     auto scope = DECLARE_THROW_SCOPE(vm);
1942 
<a name="370" id="anc370"></a><span class="line-modified">1943     SimpleObject* simpleObject = jsDynamicCast&lt;SimpleObject*&gt;(vm, exec-&gt;argument(0));</span>
1944     if (UNLIKELY(!simpleObject)) {
<a name="371" id="anc371"></a><span class="line-modified">1945         throwTypeError(exec, scope, &quot;Invalid use of setHiddenValue test function&quot;_s);</span>
1946         return encodedJSValue();
1947     }
<a name="372" id="anc372"></a><span class="line-modified">1948     JSValue value = exec-&gt;argument(1);</span>
1949     simpleObject-&gt;setHiddenValue(vm, value);
1950     return JSValue::encode(jsUndefined());
1951 }
1952 
<a name="373" id="anc373"></a><span class="line-modified">1953 static EncodedJSValue JSC_HOST_CALL functionShadowChickenFunctionsOnStack(ExecState* exec)</span>
1954 {
<a name="374" id="anc374"></a><span class="line-modified">1955     VM&amp; vm = exec-&gt;vm();</span>

1956     auto scope = DECLARE_THROW_SCOPE(vm);
1957     if (auto* shadowChicken = vm.shadowChicken()) {
1958         scope.release();
<a name="375" id="anc375"></a><span class="line-modified">1959         return JSValue::encode(shadowChicken-&gt;functionsOnStack(exec));</span>
1960     }
1961 
<a name="376" id="anc376"></a><span class="line-modified">1962     JSArray* result = constructEmptyArray(exec, 0);</span>
1963     RETURN_IF_EXCEPTION(scope, { });
<a name="377" id="anc377"></a><span class="line-modified">1964     StackVisitor::visit(exec, &amp;vm, [&amp;] (StackVisitor&amp; visitor) -&gt; StackVisitor::Status {</span>

1965         if (visitor-&gt;isInlinedFrame())
1966             return StackVisitor::Continue;
1967         if (visitor-&gt;isWasmFrame())
1968             return StackVisitor::Continue;
<a name="378" id="anc378"></a><span class="line-modified">1969         result-&gt;push(exec, jsCast&lt;JSObject*&gt;(visitor-&gt;callee().asCell()));</span>
1970         scope.releaseAssertNoException(); // This function is only called from tests.
1971         return StackVisitor::Continue;
1972     });
1973     RETURN_IF_EXCEPTION(scope, { });
1974     return JSValue::encode(result);
1975 }
1976 
<a name="379" id="anc379"></a><span class="line-modified">1977 static EncodedJSValue JSC_HOST_CALL functionSetGlobalConstRedeclarationShouldNotThrow(ExecState* exec)</span>
1978 {
<a name="380" id="anc380"></a><span class="line-modified">1979     VM&amp; vm = exec-&gt;vm();</span>

1980     vm.setGlobalConstRedeclarationShouldThrow(false);
1981     return JSValue::encode(jsUndefined());
1982 }
1983 
<a name="381" id="anc381"></a><span class="line-modified">1984 static EncodedJSValue JSC_HOST_CALL functionFindTypeForExpression(ExecState* exec)</span>
1985 {
<a name="382" id="anc382"></a><span class="line-modified">1986     VM&amp; vm = exec-&gt;vm();</span>

1987     RELEASE_ASSERT(vm.typeProfiler());
1988     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;jsc Testing API: functionFindTypeForExpression&quot;_s);
1989 
<a name="383" id="anc383"></a><span class="line-modified">1990     JSValue functionValue = exec-&gt;argument(0);</span>
1991     RELEASE_ASSERT(functionValue.isFunction(vm));
1992     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
1993 
<a name="384" id="anc384"></a><span class="line-modified">1994     RELEASE_ASSERT(exec-&gt;argument(1).isString());</span>
<span class="line-modified">1995     String substring = asString(exec-&gt;argument(1))-&gt;value(exec);</span>
1996     String sourceCodeText = executable-&gt;source().view().toString();
1997     unsigned offset = static_cast&lt;unsigned&gt;(sourceCodeText.find(substring) + executable-&gt;source().startOffset());
1998 
1999     String jsonString = vm.typeProfiler()-&gt;typeInformationForExpressionAtOffset(TypeProfilerSearchDescriptorNormal, offset, executable-&gt;sourceID(), vm);
<a name="385" id="anc385"></a><span class="line-modified">2000     return JSValue::encode(JSONParse(exec, jsonString));</span>
2001 }
2002 
<a name="386" id="anc386"></a><span class="line-modified">2003 static EncodedJSValue JSC_HOST_CALL functionReturnTypeFor(ExecState* exec)</span>
2004 {
<a name="387" id="anc387"></a><span class="line-modified">2005     VM&amp; vm = exec-&gt;vm();</span>

2006     RELEASE_ASSERT(vm.typeProfiler());
2007     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;jsc Testing API: functionReturnTypeFor&quot;_s);
2008 
<a name="388" id="anc388"></a><span class="line-modified">2009     JSValue functionValue = exec-&gt;argument(0);</span>
2010     RELEASE_ASSERT(functionValue.isFunction(vm));
2011     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2012 
2013     unsigned offset = executable-&gt;typeProfilingStartOffset(vm);
2014     String jsonString = vm.typeProfiler()-&gt;typeInformationForExpressionAtOffset(TypeProfilerSearchDescriptorFunctionReturn, offset, executable-&gt;sourceID(), vm);
<a name="389" id="anc389"></a><span class="line-modified">2015     return JSValue::encode(JSONParse(exec, jsonString));</span>
2016 }
2017 
<a name="390" id="anc390"></a><span class="line-modified">2018 static EncodedJSValue JSC_HOST_CALL functionFlattenDictionaryObject(ExecState* exec)</span>
2019 {
<a name="391" id="anc391"></a><span class="line-modified">2020     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2021     JSValue value = exec-&gt;argument(0);</span>

2022     RELEASE_ASSERT(value.isObject() &amp;&amp; value.getObject()-&gt;structure()-&gt;isDictionary());
2023     value.getObject()-&gt;flattenDictionaryObject(vm);
2024     return encodedJSUndefined();
2025 }
2026 
<a name="392" id="anc392"></a><span class="line-modified">2027 static EncodedJSValue JSC_HOST_CALL functionDumpBasicBlockExecutionRanges(ExecState* exec)</span>
2028 {
<a name="393" id="anc393"></a><span class="line-modified">2029     VM&amp; vm = exec-&gt;vm();</span>

2030     RELEASE_ASSERT(vm.controlFlowProfiler());
2031     vm.controlFlowProfiler()-&gt;dumpData();
2032     return JSValue::encode(jsUndefined());
2033 }
2034 
<a name="394" id="anc394"></a><span class="line-modified">2035 static EncodedJSValue JSC_HOST_CALL functionHasBasicBlockExecuted(ExecState* exec)</span>
2036 {
<a name="395" id="anc395"></a><span class="line-modified">2037     VM&amp; vm = exec-&gt;vm();</span>

2038     RELEASE_ASSERT(vm.controlFlowProfiler());
2039 
<a name="396" id="anc396"></a><span class="line-modified">2040     JSValue functionValue = exec-&gt;argument(0);</span>
2041     RELEASE_ASSERT(functionValue.isFunction(vm));
2042     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2043 
<a name="397" id="anc397"></a><span class="line-modified">2044     RELEASE_ASSERT(exec-&gt;argument(1).isString());</span>
<span class="line-modified">2045     String substring = asString(exec-&gt;argument(1))-&gt;value(exec);</span>
2046     String sourceCodeText = executable-&gt;source().view().toString();
2047     RELEASE_ASSERT(sourceCodeText.contains(substring));
2048     int offset = sourceCodeText.find(substring) + executable-&gt;source().startOffset();
2049 
2050     bool hasExecuted = vm.controlFlowProfiler()-&gt;hasBasicBlockAtTextOffsetBeenExecuted(offset, executable-&gt;sourceID(), vm);
2051     return JSValue::encode(jsBoolean(hasExecuted));
2052 }
2053 
<a name="398" id="anc398"></a><span class="line-modified">2054 static EncodedJSValue JSC_HOST_CALL functionBasicBlockExecutionCount(ExecState* exec)</span>
2055 {
<a name="399" id="anc399"></a><span class="line-modified">2056     VM&amp; vm = exec-&gt;vm();</span>

2057     RELEASE_ASSERT(vm.controlFlowProfiler());
2058 
<a name="400" id="anc400"></a><span class="line-modified">2059     JSValue functionValue = exec-&gt;argument(0);</span>
2060     RELEASE_ASSERT(functionValue.isFunction(vm));
2061     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2062 
<a name="401" id="anc401"></a><span class="line-modified">2063     RELEASE_ASSERT(exec-&gt;argument(1).isString());</span>
<span class="line-modified">2064     String substring = asString(exec-&gt;argument(1))-&gt;value(exec);</span>
2065     String sourceCodeText = executable-&gt;source().view().toString();
2066     RELEASE_ASSERT(sourceCodeText.contains(substring));
2067     int offset = sourceCodeText.find(substring) + executable-&gt;source().startOffset();
2068 
2069     size_t executionCount = vm.controlFlowProfiler()-&gt;basicBlockExecutionCountAtTextOffset(offset, executable-&gt;sourceID(), vm);
2070     return JSValue::encode(JSValue(executionCount));
2071 }
2072 
<a name="402" id="anc402"></a><span class="line-modified">2073 static EncodedJSValue JSC_HOST_CALL functionEnableExceptionFuzz(ExecState*)</span>
2074 {
<a name="403" id="anc403"></a>
2075     Options::useExceptionFuzz() = true;
2076     return JSValue::encode(jsUndefined());
2077 }
2078 
<a name="404" id="anc404"></a><span class="line-modified">2079 static EncodedJSValue changeDebuggerModeWhenIdle(ExecState* exec, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode)</span>


















2080 {
<a name="405" id="anc405"></a><span class="line-modified">2081     bool newDebuggerMode = codeGenerationMode.contains(CodeGenerationMode::Debugger);</span>
<span class="line-modified">2082     if (Options::forceDebuggerBytecodeGeneration() == newDebuggerMode)</span>


2083         return JSValue::encode(jsUndefined());
2084 
<a name="406" id="anc406"></a><span class="line-modified">2085     VM* vm = &amp;exec-&gt;vm();</span>
2086     vm-&gt;whenIdle([=] () {
<a name="407" id="anc407"></a><span class="line-modified">2087         Options::forceDebuggerBytecodeGeneration() = newDebuggerMode;</span>
<span class="line-modified">2088         vm-&gt;deleteAllCode(PreventCollectionAndDeleteAllCode);</span>
<span class="line-modified">2089         if (newDebuggerMode)</span>
<span class="line-modified">2090             vm-&gt;ensureShadowChicken();</span>







2091     });
2092     return JSValue::encode(jsUndefined());
2093 }
2094 
<a name="408" id="anc408"></a><span class="line-modified">2095 static EncodedJSValue JSC_HOST_CALL functionEnableDebuggerModeWhenIdle(ExecState* exec)</span>
2096 {
<a name="409" id="anc409"></a><span class="line-modified">2097     return changeDebuggerModeWhenIdle(exec, { CodeGenerationMode::Debugger });</span>

2098 }
2099 
<a name="410" id="anc410"></a><span class="line-modified">2100 static EncodedJSValue JSC_HOST_CALL functionDisableDebuggerModeWhenIdle(ExecState* exec)</span>
2101 {
<a name="411" id="anc411"></a><span class="line-modified">2102     return changeDebuggerModeWhenIdle(exec, { });</span>

2103 }
2104 
<a name="412" id="anc412"></a><span class="line-modified">2105 static EncodedJSValue JSC_HOST_CALL functionDeleteAllCodeWhenIdle(ExecState* exec)</span>
2106 {
<a name="413" id="anc413"></a><span class="line-modified">2107     VM* vm = &amp;exec-&gt;vm();</span>

2108     vm-&gt;whenIdle([=] () {
<a name="414" id="anc414"></a>
2109         vm-&gt;deleteAllCode(PreventCollectionAndDeleteAllCode);
2110     });
2111     return JSValue::encode(jsUndefined());
2112 }
2113 
<a name="415" id="anc415"></a><span class="line-modified">2114 static EncodedJSValue JSC_HOST_CALL functionGlobalObjectCount(ExecState* exec)</span>
2115 {
<a name="416" id="anc416"></a><span class="line-modified">2116     return JSValue::encode(jsNumber(exec-&gt;vm().heap.globalObjectCount()));</span>

2117 }
2118 
<a name="417" id="anc417"></a><span class="line-modified">2119 static EncodedJSValue JSC_HOST_CALL functionGlobalObjectForObject(ExecState* exec)</span>
2120 {
<a name="418" id="anc418"></a><span class="line-modified">2121     JSValue value = exec-&gt;argument(0);</span>

2122     RELEASE_ASSERT(value.isObject());
<a name="419" id="anc419"></a><span class="line-modified">2123     JSGlobalObject* globalObject = jsCast&lt;JSObject*&gt;(value)-&gt;globalObject(exec-&gt;vm());</span>
<span class="line-modified">2124     RELEASE_ASSERT(globalObject);</span>
<span class="line-modified">2125     return JSValue::encode(globalObject);</span>
2126 }
2127 
<a name="420" id="anc420"></a><span class="line-modified">2128 static EncodedJSValue JSC_HOST_CALL functionGetGetterSetter(ExecState* exec)</span>
2129 {
<a name="421" id="anc421"></a><span class="line-modified">2130     VM&amp; vm = exec-&gt;vm();</span>

2131     auto scope = DECLARE_THROW_SCOPE(vm);
2132 
<a name="422" id="anc422"></a><span class="line-modified">2133     JSValue value = exec-&gt;argument(0);</span>
2134     if (!value.isObject())
2135         return JSValue::encode(jsUndefined());
2136 
<a name="423" id="anc423"></a><span class="line-modified">2137     JSValue property = exec-&gt;argument(1);</span>
2138     if (!property.isString())
2139         return JSValue::encode(jsUndefined());
2140 
<a name="424" id="anc424"></a><span class="line-modified">2141     auto propertyName = asString(property)-&gt;toIdentifier(exec);</span>
2142     RETURN_IF_EXCEPTION(scope, { });
2143 
2144     PropertySlot slot(value, PropertySlot::InternalMethodType::VMInquiry);
<a name="425" id="anc425"></a><span class="line-modified">2145     value.getPropertySlot(exec, propertyName, slot);</span>
2146     RETURN_IF_EXCEPTION(scope, { });
2147 
2148     JSValue result;
2149     if (slot.isCacheableGetter())
2150         result = slot.getterSetter();
2151     else
2152         result = jsNull();
2153 
2154     return JSValue::encode(result);
2155 }
2156 
<a name="426" id="anc426"></a><span class="line-modified">2157 static EncodedJSValue JSC_HOST_CALL functionLoadGetterFromGetterSetter(ExecState* exec)</span>
2158 {
<a name="427" id="anc427"></a><span class="line-modified">2159     VM&amp; vm = exec-&gt;vm();</span>

2160     auto scope = DECLARE_THROW_SCOPE(vm);
2161 
<a name="428" id="anc428"></a><span class="line-modified">2162     GetterSetter* getterSetter = jsDynamicCast&lt;GetterSetter*&gt;(vm, exec-&gt;argument(0));</span>
2163     if (UNLIKELY(!getterSetter)) {
<a name="429" id="anc429"></a><span class="line-modified">2164         throwTypeError(exec, scope, &quot;Invalid use of loadGetterFromGetterSetter test function: argument is not a GetterSetter&quot;_s);</span>
2165         return encodedJSValue();
2166     }
2167 
2168     JSObject* getter = getterSetter-&gt;getter();
2169     RELEASE_ASSERT(getter);
2170     return JSValue::encode(getter);
2171 }
2172 
<a name="430" id="anc430"></a><span class="line-modified">2173 static EncodedJSValue JSC_HOST_CALL functionCreateCustomTestGetterSetter(ExecState* exec)</span>
2174 {
<a name="431" id="anc431"></a><span class="line-modified">2175     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2176     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
2177     return JSValue::encode(JSTestCustomGetterSetter::create(vm, globalObject, JSTestCustomGetterSetter::createStructure(vm, globalObject)));
2178 }
2179 
<a name="432" id="anc432"></a><span class="line-modified">2180 static EncodedJSValue JSC_HOST_CALL functionDeltaBetweenButterflies(ExecState* exec)</span>
2181 {
<a name="433" id="anc433"></a><span class="line-modified">2182     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2183     JSObject* a = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0));</span>
<span class="line-modified">2184     JSObject* b = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(1));</span>

2185     if (!a || !b)
2186         return JSValue::encode(jsNumber(PNaN));
2187 
2188     ptrdiff_t delta = bitwise_cast&lt;char*&gt;(a-&gt;butterfly()) - bitwise_cast&lt;char*&gt;(b-&gt;butterfly());
2189     if (delta &lt; 0)
2190         return JSValue::encode(jsNumber(PNaN));
2191     if (delta &gt; std::numeric_limits&lt;int32_t&gt;::max())
2192         return JSValue::encode(jsNumber(PNaN));
2193     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(delta)));
2194 }
2195 
<a name="434" id="anc434"></a><span class="line-modified">2196 static EncodedJSValue JSC_HOST_CALL functionTotalGCTime(ExecState* exec)</span>






2197 {
<a name="435" id="anc435"></a><span class="line-modified">2198     VM&amp; vm = exec-&gt;vm();</span>

2199     return JSValue::encode(jsNumber(vm.heap.totalGCTime().seconds()));
2200 }
2201 
<a name="436" id="anc436"></a><span class="line-modified">2202 static EncodedJSValue JSC_HOST_CALL functionParseCount(ExecState*)</span>
2203 {
<a name="437" id="anc437"></a>
2204     return JSValue::encode(jsNumber(globalParseCount.load()));
2205 }
2206 
<a name="438" id="anc438"></a><span class="line-modified">2207 static EncodedJSValue JSC_HOST_CALL functionIsWasmSupported(ExecState*)</span>
2208 {
<a name="439" id="anc439"></a>
2209 #if ENABLE(WEBASSEMBLY)
2210     return JSValue::encode(jsBoolean(Wasm::isSupported()));
2211 #else
2212     return JSValue::encode(jsBoolean(false));
2213 #endif
2214 }
2215 
<a name="440" id="anc440"></a>







































































2216 void JSDollarVM::finishCreation(VM&amp; vm)
2217 {
<a name="441" id="anc441"></a>
2218     Base::finishCreation(vm);
2219 
2220     JSGlobalObject* globalObject = this-&gt;globalObject(vm);
2221 
2222     auto addFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {
<a name="442" id="anc442"></a>
2223         JSDollarVM::addFunction(vm, globalObject, name, function, arguments);
2224     };
2225     auto addConstructibleFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {
<a name="443" id="anc443"></a>
2226         JSDollarVM::addConstructibleFunction(vm, globalObject, name, function, arguments);
2227     };
2228 
2229     addFunction(vm, &quot;abort&quot;, functionCrash, 0);
2230     addFunction(vm, &quot;crash&quot;, functionCrash, 0);
2231     addFunction(vm, &quot;breakpoint&quot;, functionBreakpoint, 0);
2232 
2233     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;dfgTrue&quot;), 0, functionDFGTrue, DFGTrueIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
2234     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;ftlTrue&quot;), 0, functionFTLTrue, FTLTrueIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
2235 
2236     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuMfence&quot;), 0, functionCpuMfence, CPUMfenceIntrinsic, 0);
2237     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuRdtsc&quot;), 0, functionCpuRdtsc, CPURdtscIntrinsic, 0);
2238     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuCpuid&quot;), 0, functionCpuCpuid, CPUCpuidIntrinsic, 0);
2239     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuPause&quot;), 0, functionCpuPause, CPUPauseIntrinsic, 0);
2240     addFunction(vm, &quot;cpuClflush&quot;, functionCpuClflush, 2);
2241 
2242     addFunction(vm, &quot;llintTrue&quot;, functionLLintTrue, 0);
2243     addFunction(vm, &quot;jitTrue&quot;, functionJITTrue, 0);
2244 
2245     addFunction(vm, &quot;noInline&quot;, functionNoInline, 1);
2246 
2247     addFunction(vm, &quot;gc&quot;, functionGC, 0);
2248     addFunction(vm, &quot;edenGC&quot;, functionEdenGC, 0);
2249     addFunction(vm, &quot;dumpSubspaceHashes&quot;, functionDumpSubspaceHashes, 0);
2250 
2251     addFunction(vm, &quot;callFrame&quot;, functionCallFrame, 1);
2252     addFunction(vm, &quot;codeBlockFor&quot;, functionCodeBlockFor, 1);
2253     addFunction(vm, &quot;codeBlockForFrame&quot;, functionCodeBlockForFrame, 1);
2254     addFunction(vm, &quot;dumpSourceFor&quot;, functionDumpSourceFor, 1);
2255     addFunction(vm, &quot;dumpBytecodeFor&quot;, functionDumpBytecodeFor, 1);
2256 
2257     addFunction(vm, &quot;dataLog&quot;, functionDataLog, 1);
2258     addFunction(vm, &quot;print&quot;, functionPrint, 1);
2259     addFunction(vm, &quot;dumpCallFrame&quot;, functionDumpCallFrame, 0);
2260     addFunction(vm, &quot;dumpStack&quot;, functionDumpStack, 0);
2261     addFunction(vm, &quot;dumpRegisters&quot;, functionDumpRegisters, 1);
2262 
2263     addFunction(vm, &quot;dumpCell&quot;, functionDumpCell, 1);
2264 
2265     addFunction(vm, &quot;indexingMode&quot;, functionIndexingMode, 1);
2266     addFunction(vm, &quot;inlineCapacity&quot;, functionInlineCapacity, 1);
2267     addFunction(vm, &quot;value&quot;, functionValue, 1);
2268     addFunction(vm, &quot;getpid&quot;, functionGetPID, 0);
2269 
2270     addFunction(vm, &quot;haveABadTime&quot;, functionHaveABadTime, 1);
2271     addFunction(vm, &quot;isHavingABadTime&quot;, functionIsHavingABadTime, 1);
2272 
<a name="444" id="anc444"></a>

2273     addFunction(vm, &quot;createGlobalObject&quot;, functionCreateGlobalObject, 0);
2274     addFunction(vm, &quot;createProxy&quot;, functionCreateProxy, 1);
2275     addFunction(vm, &quot;createRuntimeArray&quot;, functionCreateRuntimeArray, 0);
2276     addFunction(vm, &quot;createNullRopeString&quot;, functionCreateNullRopeString, 0);
2277 
2278     addFunction(vm, &quot;createImpureGetter&quot;, functionCreateImpureGetter, 1);
2279     addFunction(vm, &quot;createCustomGetterObject&quot;, functionCreateCustomGetterObject, 0);
2280     addFunction(vm, &quot;createDOMJITNodeObject&quot;, functionCreateDOMJITNodeObject, 0);
2281     addFunction(vm, &quot;createDOMJITGetterObject&quot;, functionCreateDOMJITGetterObject, 0);
2282     addFunction(vm, &quot;createDOMJITGetterComplexObject&quot;, functionCreateDOMJITGetterComplexObject, 0);
2283     addFunction(vm, &quot;createDOMJITFunctionObject&quot;, functionCreateDOMJITFunctionObject, 0);
2284     addFunction(vm, &quot;createDOMJITCheckSubClassObject&quot;, functionCreateDOMJITCheckSubClassObject, 0);
2285     addFunction(vm, &quot;createDOMJITGetterBaseJSObject&quot;, functionCreateDOMJITGetterBaseJSObject, 0);
2286     addFunction(vm, &quot;createBuiltin&quot;, functionCreateBuiltin, 2);
2287 #if ENABLE(WEBASSEMBLY)
2288     addFunction(vm, &quot;createWasmStreamingParser&quot;, functionCreateWasmStreamingParser, 0);
2289 #endif
<a name="445" id="anc445"></a>

2290     addFunction(vm, &quot;getPrivateProperty&quot;, functionGetPrivateProperty, 2);
2291     addFunction(vm, &quot;setImpureGetterDelegate&quot;, functionSetImpureGetterDelegate, 2);
2292 
2293     addConstructibleFunction(vm, &quot;Root&quot;, functionCreateRoot, 0);
2294     addConstructibleFunction(vm, &quot;Element&quot;, functionCreateElement, 1);
2295     addFunction(vm, &quot;getElement&quot;, functionGetElement, 1);
2296 
2297     addConstructibleFunction(vm, &quot;SimpleObject&quot;, functionCreateSimpleObject, 0);
2298     addFunction(vm, &quot;getHiddenValue&quot;, functionGetHiddenValue, 1);
2299     addFunction(vm, &quot;setHiddenValue&quot;, functionSetHiddenValue, 2);
2300 
2301     addFunction(vm, &quot;shadowChickenFunctionsOnStack&quot;, functionShadowChickenFunctionsOnStack, 0);
2302     addFunction(vm, &quot;setGlobalConstRedeclarationShouldNotThrow&quot;, functionSetGlobalConstRedeclarationShouldNotThrow, 0);
2303 
2304     addFunction(vm, &quot;findTypeForExpression&quot;, functionFindTypeForExpression, 2);
2305     addFunction(vm, &quot;returnTypeFor&quot;, functionReturnTypeFor, 1);
2306 
2307     addFunction(vm, &quot;flattenDictionaryObject&quot;, functionFlattenDictionaryObject, 1);
2308 
2309     addFunction(vm, &quot;dumpBasicBlockExecutionRanges&quot;, functionDumpBasicBlockExecutionRanges , 0);
2310     addFunction(vm, &quot;hasBasicBlockExecuted&quot;, functionHasBasicBlockExecuted, 2);
2311     addFunction(vm, &quot;basicBlockExecutionCount&quot;, functionBasicBlockExecutionCount, 2);
2312 
2313     addFunction(vm, &quot;enableExceptionFuzz&quot;, functionEnableExceptionFuzz, 0);
2314 
2315     addFunction(vm, &quot;enableDebuggerModeWhenIdle&quot;, functionEnableDebuggerModeWhenIdle, 0);
2316     addFunction(vm, &quot;disableDebuggerModeWhenIdle&quot;, functionDisableDebuggerModeWhenIdle, 0);
2317 
2318     addFunction(vm, &quot;deleteAllCodeWhenIdle&quot;, functionDeleteAllCodeWhenIdle, 0);
2319 
2320     addFunction(vm, &quot;globalObjectCount&quot;, functionGlobalObjectCount, 0);
2321     addFunction(vm, &quot;globalObjectForObject&quot;, functionGlobalObjectForObject, 1);
2322 
2323     addFunction(vm, &quot;getGetterSetter&quot;, functionGetGetterSetter, 2);
2324     addFunction(vm, &quot;loadGetterFromGetterSetter&quot;, functionLoadGetterFromGetterSetter, 1);
2325     addFunction(vm, &quot;createCustomTestGetterSetter&quot;, functionCreateCustomTestGetterSetter, 1);
2326 
2327     addFunction(vm, &quot;deltaBetweenButterflies&quot;, functionDeltaBetweenButterflies, 2);
2328 
<a name="446" id="anc446"></a>
2329     addFunction(vm, &quot;totalGCTime&quot;, functionTotalGCTime, 0);
2330 
2331     addFunction(vm, &quot;parseCount&quot;, functionParseCount, 0);
2332 
2333     addFunction(vm, &quot;isWasmSupported&quot;, functionIsWasmSupported, 0);
<a name="447" id="anc447"></a>





2334 }
2335 
2336 void JSDollarVM::addFunction(VM&amp; vm, JSGlobalObject* globalObject, const char* name, NativeFunction function, unsigned arguments)
2337 {
<a name="448" id="anc448"></a>
2338     Identifier identifier = Identifier::fromString(vm, name);
2339     putDirect(vm, identifier, JSFunction::create(vm, globalObject, arguments, identifier.string(), function));
2340 }
2341 
2342 void JSDollarVM::addConstructibleFunction(VM&amp; vm, JSGlobalObject* globalObject, const char* name, NativeFunction function, unsigned arguments)
2343 {
<a name="449" id="anc449"></a>
2344     Identifier identifier = Identifier::fromString(vm, name);
2345     putDirect(vm, identifier, JSFunction::create(vm, globalObject, arguments, identifier.string(), function, NoIntrinsic, function));
2346 }
2347 
<a name="450" id="anc450"></a>






2348 } // namespace JSC
<a name="451" id="anc451"></a>

<a name="452" id="anc452"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="452" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/GCSegmentedArrayInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GCSegmentedArray.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="GigacageAlignedMemoryAllocator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/GCSegmentedArrayInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 45     ASSERT(m_segments.size() == 1);
 46     GCArraySegment&lt;T&gt;::destroy(m_segments.removeHead());
 47     m_numberOfSegments--;
 48     ASSERT(!m_numberOfSegments);
 49     ASSERT(!m_segments.size());
 50 }
 51 
 52 template &lt;typename T&gt;
 53 void GCSegmentedArray&lt;T&gt;::clear()
 54 {
 55     if (!m_segments.head())
 56         return;
 57     GCArraySegment&lt;T&gt;* next;
 58     for (GCArraySegment&lt;T&gt;* current = m_segments.head(); current-&gt;next(); current = next) {
 59         next = current-&gt;next();
 60         m_segments.remove(current);
 61         GCArraySegment&lt;T&gt;::destroy(current);
 62     }
 63     m_top = 0;
 64     m_numberOfSegments = 1;
<span class="line-modified"> 65 #if !ASSERT_DISABLED</span>
 66     m_segments.head()-&gt;m_top = 0;
 67 #endif
 68 }
 69 
 70 template &lt;typename T&gt;
 71 void GCSegmentedArray&lt;T&gt;::expand()
 72 {
 73     ASSERT(m_segments.head()-&gt;m_top == s_segmentCapacity);
 74 
 75     GCArraySegment&lt;T&gt;* nextSegment = GCArraySegment&lt;T&gt;::create();
 76     m_numberOfSegments++;
 77 
<span class="line-modified"> 78 #if !ASSERT_DISABLED</span>
 79     nextSegment-&gt;m_top = 0;
 80 #endif
 81 
 82     m_segments.push(nextSegment);
 83     setTopForEmptySegment();
 84     validatePrevious();
 85 }
 86 
 87 template &lt;typename T&gt;
 88 bool GCSegmentedArray&lt;T&gt;::refill()
 89 {
 90     validatePrevious();
 91     if (top())
 92         return true;
 93     GCArraySegment&lt;T&gt;::destroy(m_segments.removeHead());
 94     ASSERT(m_numberOfSegments &gt; 1);
 95     m_numberOfSegments--;
 96     setTopForFullSegment();
 97     validatePrevious();
 98     return true;
</pre>
<hr />
<pre>
109 
110     unsigned count = 0;
111     for (unsigned i = 0; i &lt; m_top; ++i) {
112         ASSERT(currentSegment-&gt;data()[i]);
113         vector[count++] = currentSegment-&gt;data()[i];
114     }
115 
116     currentSegment = currentSegment-&gt;next();
117     while (currentSegment) {
118         for (unsigned i = 0; i &lt; s_segmentCapacity; ++i) {
119             ASSERT(currentSegment-&gt;data()[i]);
120             vector[count++] = currentSegment-&gt;data()[i];
121         }
122         currentSegment = currentSegment-&gt;next();
123     }
124 }
125 
126 template &lt;typename T&gt;
127 inline GCArraySegment&lt;T&gt;* GCArraySegment&lt;T&gt;::create()
128 {
<span class="line-modified">129     return new (NotNull, fastMalloc(blockSize)) GCArraySegment&lt;T&gt;();</span>
130 }
131 
132 template &lt;typename T&gt;
133 inline void GCArraySegment&lt;T&gt;::destroy(GCArraySegment* segment)
134 {
135     segment-&gt;~GCArraySegment();
<span class="line-modified">136     fastFree(segment);</span>
137 }
138 
139 template &lt;typename T&gt;
140 inline size_t GCSegmentedArray&lt;T&gt;::postIncTop()
141 {
142     size_t result = m_top++;
143     ASSERT(result == m_segments.head()-&gt;m_top++);
144     return result;
145 }
146 
147 template &lt;typename T&gt;
148 inline size_t GCSegmentedArray&lt;T&gt;::preDecTop()
149 {
150     size_t result = --m_top;
151     ASSERT(result == --m_segments.head()-&gt;m_top);
152     return result;
153 }
154 
155 template &lt;typename T&gt;
156 inline void GCSegmentedArray&lt;T&gt;::setTopForFullSegment()
157 {
158     ASSERT(m_segments.head()-&gt;m_top == s_segmentCapacity);
159     m_top = s_segmentCapacity;
160 }
161 
162 template &lt;typename T&gt;
163 inline void GCSegmentedArray&lt;T&gt;::setTopForEmptySegment()
164 {
165     ASSERT(!m_segments.head()-&gt;m_top);
166     m_top = 0;
167 }
168 
169 template &lt;typename T&gt;
170 inline size_t GCSegmentedArray&lt;T&gt;::top()
171 {
172     ASSERT(m_top == m_segments.head()-&gt;m_top);
173     return m_top;
174 }
175 
176 template &lt;typename T&gt;
<span class="line-modified">177 #if ASSERT_DISABLED</span>
<span class="line-removed">178 inline void GCSegmentedArray&lt;T&gt;::validatePrevious() { }</span>
<span class="line-removed">179 #else</span>
180 inline void GCSegmentedArray&lt;T&gt;::validatePrevious()
181 {
182     unsigned count = 0;
183     for (GCArraySegment&lt;T&gt;* current = m_segments.head(); current; current = current-&gt;next())
184         count++;
185     ASSERT(m_segments.size() == m_numberOfSegments);
186 }
<span class="line-modified">187 #endif</span>


188 
189 template &lt;typename T&gt;
190 inline void GCSegmentedArray&lt;T&gt;::append(T value)
191 {
192     if (m_top == s_segmentCapacity)
193         expand();
194     m_segments.head()-&gt;data()[postIncTop()] = value;
195 }
196 
197 template &lt;typename T&gt;
198 inline bool GCSegmentedArray&lt;T&gt;::canRemoveLast()
199 {
200     return !!m_top;
201 }
202 
203 template &lt;typename T&gt;
204 inline const T GCSegmentedArray&lt;T&gt;::removeLast()
205 {
206     return m_segments.head()-&gt;data()[preDecTop()];
207 }
</pre>
</td>
<td>
<hr />
<pre>
 45     ASSERT(m_segments.size() == 1);
 46     GCArraySegment&lt;T&gt;::destroy(m_segments.removeHead());
 47     m_numberOfSegments--;
 48     ASSERT(!m_numberOfSegments);
 49     ASSERT(!m_segments.size());
 50 }
 51 
 52 template &lt;typename T&gt;
 53 void GCSegmentedArray&lt;T&gt;::clear()
 54 {
 55     if (!m_segments.head())
 56         return;
 57     GCArraySegment&lt;T&gt;* next;
 58     for (GCArraySegment&lt;T&gt;* current = m_segments.head(); current-&gt;next(); current = next) {
 59         next = current-&gt;next();
 60         m_segments.remove(current);
 61         GCArraySegment&lt;T&gt;::destroy(current);
 62     }
 63     m_top = 0;
 64     m_numberOfSegments = 1;
<span class="line-modified"> 65 #if ASSERT_ENABLED</span>
 66     m_segments.head()-&gt;m_top = 0;
 67 #endif
 68 }
 69 
 70 template &lt;typename T&gt;
 71 void GCSegmentedArray&lt;T&gt;::expand()
 72 {
 73     ASSERT(m_segments.head()-&gt;m_top == s_segmentCapacity);
 74 
 75     GCArraySegment&lt;T&gt;* nextSegment = GCArraySegment&lt;T&gt;::create();
 76     m_numberOfSegments++;
 77 
<span class="line-modified"> 78 #if ASSERT_ENABLED</span>
 79     nextSegment-&gt;m_top = 0;
 80 #endif
 81 
 82     m_segments.push(nextSegment);
 83     setTopForEmptySegment();
 84     validatePrevious();
 85 }
 86 
 87 template &lt;typename T&gt;
 88 bool GCSegmentedArray&lt;T&gt;::refill()
 89 {
 90     validatePrevious();
 91     if (top())
 92         return true;
 93     GCArraySegment&lt;T&gt;::destroy(m_segments.removeHead());
 94     ASSERT(m_numberOfSegments &gt; 1);
 95     m_numberOfSegments--;
 96     setTopForFullSegment();
 97     validatePrevious();
 98     return true;
</pre>
<hr />
<pre>
109 
110     unsigned count = 0;
111     for (unsigned i = 0; i &lt; m_top; ++i) {
112         ASSERT(currentSegment-&gt;data()[i]);
113         vector[count++] = currentSegment-&gt;data()[i];
114     }
115 
116     currentSegment = currentSegment-&gt;next();
117     while (currentSegment) {
118         for (unsigned i = 0; i &lt; s_segmentCapacity; ++i) {
119             ASSERT(currentSegment-&gt;data()[i]);
120             vector[count++] = currentSegment-&gt;data()[i];
121         }
122         currentSegment = currentSegment-&gt;next();
123     }
124 }
125 
126 template &lt;typename T&gt;
127 inline GCArraySegment&lt;T&gt;* GCArraySegment&lt;T&gt;::create()
128 {
<span class="line-modified">129     return new (NotNull, GCSegmentedArrayMalloc::malloc(blockSize)) GCArraySegment&lt;T&gt;();</span>
130 }
131 
132 template &lt;typename T&gt;
133 inline void GCArraySegment&lt;T&gt;::destroy(GCArraySegment* segment)
134 {
135     segment-&gt;~GCArraySegment();
<span class="line-modified">136     GCSegmentedArrayMalloc::free(segment);</span>
137 }
138 
139 template &lt;typename T&gt;
140 inline size_t GCSegmentedArray&lt;T&gt;::postIncTop()
141 {
142     size_t result = m_top++;
143     ASSERT(result == m_segments.head()-&gt;m_top++);
144     return result;
145 }
146 
147 template &lt;typename T&gt;
148 inline size_t GCSegmentedArray&lt;T&gt;::preDecTop()
149 {
150     size_t result = --m_top;
151     ASSERT(result == --m_segments.head()-&gt;m_top);
152     return result;
153 }
154 
155 template &lt;typename T&gt;
156 inline void GCSegmentedArray&lt;T&gt;::setTopForFullSegment()
157 {
158     ASSERT(m_segments.head()-&gt;m_top == s_segmentCapacity);
159     m_top = s_segmentCapacity;
160 }
161 
162 template &lt;typename T&gt;
163 inline void GCSegmentedArray&lt;T&gt;::setTopForEmptySegment()
164 {
165     ASSERT(!m_segments.head()-&gt;m_top);
166     m_top = 0;
167 }
168 
169 template &lt;typename T&gt;
170 inline size_t GCSegmentedArray&lt;T&gt;::top()
171 {
172     ASSERT(m_top == m_segments.head()-&gt;m_top);
173     return m_top;
174 }
175 
176 template &lt;typename T&gt;
<span class="line-modified">177 #if ASSERT_ENABLED</span>


178 inline void GCSegmentedArray&lt;T&gt;::validatePrevious()
179 {
180     unsigned count = 0;
181     for (GCArraySegment&lt;T&gt;* current = m_segments.head(); current; current = current-&gt;next())
182         count++;
183     ASSERT(m_segments.size() == m_numberOfSegments);
184 }
<span class="line-modified">185 #else</span>
<span class="line-added">186 inline void GCSegmentedArray&lt;T&gt;::validatePrevious() { }</span>
<span class="line-added">187 #endif // ASSERT_ENABLED</span>
188 
189 template &lt;typename T&gt;
190 inline void GCSegmentedArray&lt;T&gt;::append(T value)
191 {
192     if (m_top == s_segmentCapacity)
193         expand();
194     m_segments.head()-&gt;data()[postIncTop()] = value;
195 }
196 
197 template &lt;typename T&gt;
198 inline bool GCSegmentedArray&lt;T&gt;::canRemoveLast()
199 {
200     return !!m_top;
201 }
202 
203 template &lt;typename T&gt;
204 inline const T GCSegmentedArray&lt;T&gt;::removeLast()
205 {
206     return m_segments.head()-&gt;data()[preDecTop()];
207 }
</pre>
</td>
</tr>
</table>
<center><a href="GCSegmentedArray.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="GigacageAlignedMemoryAllocator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
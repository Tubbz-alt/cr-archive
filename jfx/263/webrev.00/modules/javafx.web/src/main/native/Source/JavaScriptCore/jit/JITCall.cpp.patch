diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITCall.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITCall.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITCall.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITCall.cpp
@@ -49,11 +49,11 @@
 
 template<typename Op>
 void JIT::emitPutCallResult(const Op& bytecode)
 {
     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
-    emitPutVirtualRegister(bytecode.m_dst.offset());
+    emitPutVirtualRegister(bytecode.m_dst);
 }
 
 template<typename Op>
 std::enable_if_t<
     Op::opcodeID != op_call_varargs && Op::opcodeID != op_construct_varargs
@@ -64,58 +64,58 @@
     auto& metadata = bytecode.metadata(m_codeBlock);
     int argCount = bytecode.m_argc;
     int registerOffset = -static_cast<int>(bytecode.m_argv);
 
     if (Op::opcodeID == op_call && shouldEmitProfiling()) {
-        emitGetVirtualRegister(registerOffset + CallFrame::argumentOffsetIncludingThis(0), regT0);
+        emitGetVirtualRegister(VirtualRegister(registerOffset + CallFrame::argumentOffsetIncludingThis(0)), regT0);
         Jump done = branchIfNotCell(regT0);
         load32(Address(regT0, JSCell::structureIDOffset()), regT0);
         store32(regT0, metadata.m_callLinkInfo.m_arrayProfile.addressOfLastSeenStructureID());
         done.link(this);
     }
 
     addPtr(TrustedImm32(registerOffset * sizeof(Register) + sizeof(CallerFrameAndPC)), callFrameRegister, stackPointerRegister);
-    store32(TrustedImm32(argCount), Address(stackPointerRegister, CallFrameSlot::argumentCount * static_cast<int>(sizeof(Register)) + PayloadOffset - sizeof(CallerFrameAndPC)));
+    store32(TrustedImm32(argCount), Address(stackPointerRegister, CallFrameSlot::argumentCountIncludingThis * static_cast<int>(sizeof(Register)) + PayloadOffset - sizeof(CallerFrameAndPC)));
 }
 
 
 template<typename Op>
 std::enable_if_t<
     Op::opcodeID == op_call_varargs || Op::opcodeID == op_construct_varargs
     || Op::opcodeID == op_tail_call_varargs || Op::opcodeID == op_tail_call_forward_arguments
 , void>
 JIT::compileSetupFrame(const Op& bytecode, CallLinkInfo* info)
 {
-    int thisValue = bytecode.m_thisValue.offset();
-    int arguments = bytecode.m_arguments.offset();
-    int firstFreeRegister = bytecode.m_firstFree.offset();
+    VirtualRegister thisValue = bytecode.m_thisValue;
+    VirtualRegister arguments = bytecode.m_arguments;
+    int firstFreeRegister = bytecode.m_firstFree.offset(); // FIXME: Why is this a virtual register if we never use it as one...
     int firstVarArgOffset = bytecode.m_firstVarArg;
 
     emitGetVirtualRegister(arguments, regT1);
-    Z_JITOperation_EJZZ sizeOperation;
+    Z_JITOperation_GJZZ sizeOperation;
     if (Op::opcodeID == op_tail_call_forward_arguments)
         sizeOperation = operationSizeFrameForForwardArguments;
     else
         sizeOperation = operationSizeFrameForVarargs;
-    callOperation(sizeOperation, regT1, -firstFreeRegister, firstVarArgOffset);
+    callOperation(sizeOperation, TrustedImmPtr(m_codeBlock->globalObject()), regT1, -firstFreeRegister, firstVarArgOffset);
     move(TrustedImm32(-firstFreeRegister), regT1);
     emitSetVarargsFrame(*this, returnValueGPR, false, regT1, regT1);
     addPtr(TrustedImm32(-(sizeof(CallerFrameAndPC) + WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(void*)))), regT1, stackPointerRegister);
     emitGetVirtualRegister(arguments, regT2);
-    F_JITOperation_EFJZZ setupOperation;
+    F_JITOperation_GFJZZ setupOperation;
     if (Op::opcodeID == op_tail_call_forward_arguments)
         setupOperation = operationSetupForwardArgumentsFrame;
     else
         setupOperation = operationSetupVarargsFrame;
-    callOperation(setupOperation, regT1, regT2, firstVarArgOffset, regT0);
+    callOperation(setupOperation, TrustedImmPtr(m_codeBlock->globalObject()), regT1, regT2, firstVarArgOffset, regT0);
     move(returnValueGPR, regT1);
 
     // Profile the argument count.
-    load32(Address(regT1, CallFrameSlot::argumentCount * static_cast<int>(sizeof(Register)) + PayloadOffset), regT2);
-    load32(info->addressOfMaxNumArguments(), regT0);
+    load32(Address(regT1, CallFrameSlot::argumentCountIncludingThis * static_cast<int>(sizeof(Register)) + PayloadOffset), regT2);
+    load32(info->addressOfMaxArgumentCountIncludingThis(), regT0);
     Jump notBiggest = branch32(Above, regT0, regT2);
-    store32(regT2, info->addressOfMaxNumArguments());
+    store32(regT2, info->addressOfMaxArgumentCountIncludingThis());
     notBiggest.link(this);
 
     // Initialize 'this'.
     emitGetVirtualRegister(thisValue, regT0);
     store64(regT0, Address(regT1, CallFrame::thisArgumentOffset() * static_cast<int>(sizeof(Register))));
@@ -136,11 +136,11 @@
     storePtr(callFrameRegister, Address(regT1, CallFrame::callerFrameOffset()));
 
     addPtr(TrustedImm32(stackPointerOffsetFor(m_codeBlock) * sizeof(Register)), callFrameRegister, stackPointerRegister);
     checkStackPointerAlignment();
 
-    callOperation(operationCallEval, regT1);
+    callOperation(operationCallEval, m_codeBlock->globalObject(), regT1);
 
     addSlowCase(branchIfEmpty(regT0));
 
     sampleCodeBlock(m_codeBlock);
 
@@ -153,18 +153,18 @@
 {
     linkAllSlowCases(iter);
 
     auto bytecode = instruction->as<OpCallEval>();
     CallLinkInfo* info = m_codeBlock->addCallLinkInfo();
-    info->setUpCall(CallLinkInfo::Call, CodeOrigin(m_bytecodeOffset), regT0);
+    info->setUpCall(CallLinkInfo::Call, CodeOrigin(m_bytecodeIndex), regT0);
 
     int registerOffset = -bytecode.m_argv;
 
     addPtr(TrustedImm32(registerOffset * sizeof(Register) + sizeof(CallerFrameAndPC)), callFrameRegister, stackPointerRegister);
 
     load64(Address(stackPointerRegister, sizeof(Register) * CallFrameSlot::callee - sizeof(CallerFrameAndPC)), regT0);
-    emitDumbVirtualCall(vm(), info);
+    emitDumbVirtualCall(vm(), m_codeBlock->globalObject(), info);
     addPtr(TrustedImm32(stackPointerOffsetFor(m_codeBlock) * sizeof(Register)), callFrameRegister, stackPointerRegister);
     checkStackPointerAlignment();
 
     sampleCodeBlock(m_codeBlock);
 
@@ -180,18 +180,18 @@
 template<>
 bool JIT::compileTailCall(const OpTailCall& bytecode, CallLinkInfo* info, unsigned callLinkInfoIndex)
 {
     CallFrameShuffleData shuffleData;
     shuffleData.numPassedArgs = bytecode.m_argc;
-    shuffleData.tagTypeNumber = GPRInfo::tagTypeNumberRegister;
+    shuffleData.numberTagRegister = GPRInfo::numberTagRegister;
     shuffleData.numLocals =
         bytecode.m_argv - sizeof(CallerFrameAndPC) / sizeof(Register);
     shuffleData.args.resize(bytecode.m_argc);
     for (unsigned i = 0; i < bytecode.m_argc; ++i) {
         shuffleData.args[i] =
             ValueRecovery::displacedInJSStack(
-                virtualRegisterForArgument(i) - bytecode.m_argv,
+                virtualRegisterForArgumentIncludingThis(i) - bytecode.m_argv,
                 DataFormatJS);
     }
     shuffleData.callee =
         ValueRecovery::inGPR(regT0, DataFormatJS);
     shuffleData.setupCalleeSaveRegisters(m_codeBlock);
@@ -204,11 +204,11 @@
 template<typename Op>
 void JIT::compileOpCall(const Instruction* instruction, unsigned callLinkInfoIndex)
 {
     OpcodeID opcodeID = Op::opcodeID;
     auto bytecode = instruction->as<Op>();
-    int callee = bytecode.m_callee.offset();
+    VirtualRegister callee = bytecode.m_callee;
 
     /* Caller always:
         - Updates callFrameRegister to callee callFrame.
         - Initializes ArgumentCount; CallerFrame; Callee.
 
@@ -224,13 +224,13 @@
     if (opcodeID != op_call_eval)
         info = m_codeBlock->addCallLinkInfo();
     compileSetupFrame(bytecode, info);
 
     // SP holds newCallFrame + sizeof(CallerFrameAndPC), with ArgumentCount initialized.
-    uint32_t bytecodeOffset = m_codeBlock->bytecodeOffset(instruction);
-    uint32_t locationBits = CallSiteIndex(bytecodeOffset).bits();
-    store32(TrustedImm32(locationBits), Address(callFrameRegister, CallFrameSlot::argumentCount * static_cast<int>(sizeof(Register)) + TagOffset));
+    auto bytecodeIndex = m_codeBlock->bytecodeIndex(instruction);
+    uint32_t locationBits = CallSiteIndex(bytecodeIndex).bits();
+    store32(TrustedImm32(locationBits), Address(callFrameRegister, CallFrameSlot::argumentCountIncludingThis * static_cast<int>(sizeof(Register)) + TagOffset));
 
     emitGetVirtualRegister(callee, regT0); // regT0 holds callee.
     store64(regT0, Address(stackPointerRegister, CallFrameSlot::callee * static_cast<int>(sizeof(Register)) - sizeof(CallerFrameAndPC)));
 
     if (compileCallEval(bytecode)) {
@@ -240,11 +240,11 @@
     DataLabelPtr addressOfLinkedFunctionCheck;
     Jump slowCase = branchPtrWithPatch(NotEqual, regT0, addressOfLinkedFunctionCheck, TrustedImmPtr(nullptr));
     addSlowCase(slowCase);
 
     ASSERT(m_callCompilationInfo.size() == callLinkInfoIndex);
-    info->setUpCall(CallLinkInfo::callTypeFor(opcodeID), CodeOrigin(m_bytecodeOffset), regT0);
+    info->setUpCall(CallLinkInfo::callTypeFor(opcodeID), CodeOrigin(m_bytecodeIndex), regT0);
     m_callCompilationInfo.append(CallCompilationInfo());
     m_callCompilationInfo[callLinkInfoIndex].hotPathBegin = addressOfLinkedFunctionCheck;
     m_callCompilationInfo[callLinkInfoIndex].callLinkInfo = info;
 
     if (compileTailCall(bytecode, info, callLinkInfoIndex)) {
@@ -277,10 +277,11 @@
     linkAllSlowCases(iter);
 
     if (opcodeID == op_tail_call || opcodeID == op_tail_call_varargs || opcodeID == op_tail_call_forward_arguments)
         emitRestoreCalleeSaves();
 
+    move(TrustedImmPtr(m_codeBlock->globalObject()), regT3);
     move(TrustedImmPtr(m_callCompilationInfo[callLinkInfoIndex].callLinkInfo), regT2);
 
     m_callCompilationInfo[callLinkInfoIndex].callReturnLocation =
         emitNakedCall(m_vm->getCTIStub(linkCallThunkGenerator).retaggedCode<NoPtrTag>());
 

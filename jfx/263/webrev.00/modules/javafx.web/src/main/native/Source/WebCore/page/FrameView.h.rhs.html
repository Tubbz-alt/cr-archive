<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2    Copyright (C) 1997 Martin Jones (mjones@kde.org)
  3              (C) 1998 Waldo Bastian (bastian@kde.org)
  4              (C) 1998, 1999 Torben Weis (weis@kde.org)
  5              (C) 1999 Lars Knoll (knoll@kde.org)
  6              (C) 1999 Antti Koivisto (koivisto@kde.org)
  7    Copyright (C) 2004-2019 Apple Inc. All rights reserved.
  8 
  9    This library is free software; you can redistribute it and/or
 10    modify it under the terms of the GNU Library General Public
 11    License as published by the Free Software Foundation; either
 12    version 2 of the License, or (at your option) any later version.
 13 
 14    This library is distributed in the hope that it will be useful,
 15    but WITHOUT ANY WARRANTY; without even the implied warranty of
 16    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 17    Library General Public License for more details.
 18 
 19    You should have received a copy of the GNU Library General Public License
 20    along with this library; see the file COPYING.LIB.  If not, write to
 21    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 22    Boston, MA 02110-1301, USA.
 23 */
 24 
 25 #pragma once
 26 
 27 #include &quot;AdjustViewSizeOrNot.h&quot;
 28 #include &quot;Color.h&quot;
 29 #include &quot;ContainerNode.h&quot;
 30 #include &quot;FrameViewLayoutContext.h&quot;
 31 #include &quot;GraphicsContext.h&quot;
 32 #include &quot;LayoutMilestone.h&quot;
 33 #include &quot;LayoutRect.h&quot;
 34 #include &quot;Pagination.h&quot;
 35 #include &quot;PaintPhase.h&quot;
 36 #include &quot;RenderPtr.h&quot;
 37 #include &quot;ScrollView.h&quot;
 38 #include &quot;StyleColor.h&quot;
 39 #include &quot;TiledBacking.h&quot;
 40 #include &lt;memory&gt;
 41 #include &lt;wtf/Forward.h&gt;
 42 #include &lt;wtf/Function.h&gt;
 43 #include &lt;wtf/HashSet.h&gt;
 44 #include &lt;wtf/IsoMalloc.h&gt;
 45 #include &lt;wtf/ListHashSet.h&gt;
 46 #include &lt;wtf/OptionSet.h&gt;
 47 #include &lt;wtf/text/WTFString.h&gt;
 48 
 49 namespace WebCore {
 50 
 51 class AXObjectCache;
 52 class Element;
 53 class FloatSize;
 54 class Frame;
 55 class HTMLFrameOwnerElement;
 56 class Page;
 57 class RenderBox;
 58 class RenderElement;
 59 class RenderEmbeddedObject;
 60 class RenderLayer;
 61 class RenderLayerModelObject;
 62 class RenderObject;
 63 class RenderScrollbarPart;
 64 class RenderStyle;
 65 class RenderView;
 66 class RenderWidget;
 67 
 68 enum class FrameFlattening;
 69 
 70 Pagination::Mode paginationModeForRenderStyle(const RenderStyle&amp;);
 71 
 72 class FrameView final : public ScrollView {
 73     WTF_MAKE_ISO_ALLOCATED(FrameView);
 74 public:
 75     friend class RenderView;
 76     friend class Internals;
 77     friend class FrameViewLayoutContext;
 78 
 79     WEBCORE_EXPORT static Ref&lt;FrameView&gt; create(Frame&amp;);
 80     static Ref&lt;FrameView&gt; create(Frame&amp;, const IntSize&amp; initialSize);
 81 
 82     virtual ~FrameView();
 83 
 84     HostWindow* hostWindow() const final;
 85 
 86     WEBCORE_EXPORT void invalidateRect(const IntRect&amp;) final;
 87     void setFrameRect(const IntRect&amp;) final;
 88 
 89     bool scheduleAnimation() final;
 90 
 91     Frame&amp; frame() const { return m_frame; }
 92 
 93     WEBCORE_EXPORT RenderView* renderView() const;
 94 
 95     int mapFromLayoutToCSSUnits(LayoutUnit) const;
 96     LayoutUnit mapFromCSSToLayoutUnits(int) const;
 97 
 98     WEBCORE_EXPORT void setCanHaveScrollbars(bool) final;
 99     WEBCORE_EXPORT void updateCanHaveScrollbars();
100 
101     Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation) final;
102 
103     bool avoidScrollbarCreation() const final;
104 
105     void setContentsSize(const IntSize&amp;) final;
106     void updateContentsSize() final;
107 
108     const FrameViewLayoutContext&amp; layoutContext() const { return m_layoutContext; }
109     FrameViewLayoutContext&amp; layoutContext() { return m_layoutContext; }
110 
111     WEBCORE_EXPORT bool didFirstLayout() const;
112     void queuePostLayoutCallback(WTF::Function&lt;void ()&gt;&amp;&amp;);
113 
114     WEBCORE_EXPORT bool needsLayout() const;
115     WEBCORE_EXPORT void setNeedsLayoutAfterViewConfigurationChange();
116 
117     void setNeedsCompositingConfigurationUpdate();
118     void setNeedsCompositingGeometryUpdate();
119 
<a name="1" id="anc1"></a><span class="line-modified">120     WEBCORE_EXPORT void setViewportConstrainedObjectsNeedLayout();</span>
121 
122     WEBCORE_EXPORT bool renderedCharactersExceed(unsigned threshold);
123 
124     void scheduleSelectionUpdate();
125 
126 #if PLATFORM(IOS_FAMILY)
127     bool useCustomFixedPositionLayoutRect() const;
128     IntRect customFixedPositionLayoutRect() const { return m_customFixedPositionLayoutRect; }
129     WEBCORE_EXPORT void setCustomFixedPositionLayoutRect(const IntRect&amp;);
130     bool updateFixedPositionLayoutRect();
131 
132     IntSize customSizeForResizeEvent() const { return m_customSizeForResizeEvent; }
133     WEBCORE_EXPORT void setCustomSizeForResizeEvent(IntSize);
134 
135     WEBCORE_EXPORT void setScrollVelocity(const VelocityData&amp;);
136 #else
137     bool useCustomFixedPositionLayoutRect() const { return false; }
138 #endif
139 
140     void willRecalcStyle();
<a name="2" id="anc2"></a><span class="line-added">141     void styleDidChange() override;</span>
142     bool updateCompositingLayersAfterStyleChange();
143     void updateCompositingLayersAfterLayout();
144 
145     // Called when changes to the GraphicsLayer hierarchy have to be synchronized with
146     // content rendered via the normal painting path.
147     void setNeedsOneShotDrawingSynchronization();
148 
149     WEBCORE_EXPORT GraphicsLayer* graphicsLayerForPlatformWidget(PlatformWidget);
150     WEBCORE_EXPORT void scheduleLayerFlushAllowingThrottling();
151 
152     WEBCORE_EXPORT TiledBacking* tiledBacking() const;
153 
154     ScrollingNodeID scrollingNodeID() const override;
155     ScrollableArea* scrollableAreaForScrollLayerID(uint64_t) const;
156     bool usesAsyncScrolling() const final;
157 
158     WEBCORE_EXPORT void enterCompositingMode();
159     WEBCORE_EXPORT bool isEnclosedInCompositingLayer() const;
160 
161     // Only used with accelerated compositing, but outside the #ifdef to make linkage easier.
162     // Returns true if the flush was completed.
163     WEBCORE_EXPORT bool flushCompositingStateIncludingSubframes();
164 
165     // Returns true when a paint with the PaintBehavior::FlattenCompositingLayers flag set gives
166     // a faithful representation of the content.
167     WEBCORE_EXPORT bool isSoftwareRenderable() const;
168 
169     void setIsInWindow(bool);
170 
171     void resetScrollbars();
172     void resetScrollbarsAndClearContentsSize();
173     void prepareForDetach();
174     void detachCustomScrollbars();
175     WEBCORE_EXPORT void recalculateScrollbarOverlayStyle();
176 #if ENABLE(DARK_MODE_CSS)
177     void recalculateBaseBackgroundColor();
178 #endif
179 
180     void clear();
181     void resetLayoutMilestones();
182 
183     WEBCORE_EXPORT bool isTransparent() const;
184     WEBCORE_EXPORT void setTransparent(bool isTransparent);
185 
186     // True if the FrameView is not transparent, and the base background color is opaque.
187     bool hasOpaqueBackground() const;
188 
189     WEBCORE_EXPORT Color baseBackgroundColor() const;
190     WEBCORE_EXPORT void setBaseBackgroundColor(const Color&amp;);
191     WEBCORE_EXPORT void updateBackgroundRecursively(const Optional&lt;Color&gt;&amp; backgroundColor);
192 
193     enum ExtendedBackgroundModeFlags {
194         ExtendedBackgroundModeNone          = 0,
195         ExtendedBackgroundModeVertical      = 1 &lt;&lt; 0,
196         ExtendedBackgroundModeHorizontal    = 1 &lt;&lt; 1,
197         ExtendedBackgroundModeAll           = ExtendedBackgroundModeVertical | ExtendedBackgroundModeHorizontal,
198     };
199     typedef unsigned ExtendedBackgroundMode;
200 
201     void updateExtendBackgroundIfNecessary();
202     void updateTilesForExtendedBackgroundMode(ExtendedBackgroundMode);
203     ExtendedBackgroundMode calculateExtendedBackgroundMode() const;
204 
205     bool hasExtendedBackgroundRectForPainting() const;
206     IntRect extendedBackgroundRectForPainting() const;
207 
208     bool shouldUpdateWhileOffscreen() const;
209     WEBCORE_EXPORT void setShouldUpdateWhileOffscreen(bool);
210     bool shouldUpdate() const;
211 
212     WEBCORE_EXPORT void adjustViewSize();
213 
214     WEBCORE_EXPORT void setViewportSizeForCSSViewportUnits(IntSize);
215     void clearViewportSizeOverrideForCSSViewportUnits();
216     IntSize viewportSizeForCSSViewportUnits() const;
217 
218     IntRect windowClipRect() const final;
219     WEBCORE_EXPORT IntRect windowClipRectForFrameOwner(const HTMLFrameOwnerElement*, bool clipToLayerContents) const;
220 
221     float visibleContentScaleFactor() const final;
222 
223 #if USE(COORDINATED_GRAPHICS)
224     WEBCORE_EXPORT void setFixedVisibleContentRect(const IntRect&amp;) final;
225 #endif
<a name="3" id="anc3"></a><span class="line-modified">226     WEBCORE_EXPORT void setScrollPosition(const ScrollPosition&amp;, ScrollClamping = ScrollClamping::Clamped) final;</span>
227     void restoreScrollbar();
228     void scheduleScrollToFocusedElement(SelectionRevealMode);
229     void scrollToFocusedElementImmediatelyIfNeeded();
230     void updateLayerPositionsAfterScrolling() final;
231     void updateCompositingLayersAfterScrolling() final;
<a name="4" id="anc4"></a><span class="line-modified">232     bool requestScrollPositionUpdate(const ScrollPosition&amp;, ScrollType = ScrollType::User, ScrollClamping = ScrollClamping::Clamped) final;</span>
233     bool isRubberBandInProgress() const final;
234     WEBCORE_EXPORT ScrollPosition minimumScrollPosition() const final;
235     WEBCORE_EXPORT ScrollPosition maximumScrollPosition() const final;
236 
237     // The scrollOrigin, scrollPosition, minimumScrollPosition and maximumScrollPosition are all affected by frame scale,
238     // but layoutViewport computations require unscaled scroll positions.
239     ScrollPosition unscaledMinimumScrollPosition() const;
240     ScrollPosition unscaledMaximumScrollPosition() const;
241 
242     IntPoint unscaledScrollOrigin() const;
243 
244     WEBCORE_EXPORT LayoutPoint minStableLayoutViewportOrigin() const;
245     WEBCORE_EXPORT LayoutPoint maxStableLayoutViewportOrigin() const;
246 
247     enum class TriggerLayoutOrNot {
248         No,
249         Yes
250     };
251     // This origin can be overridden by setLayoutViewportOverrideRect.
252     void setBaseLayoutViewportOrigin(LayoutPoint, TriggerLayoutOrNot = TriggerLayoutOrNot::Yes);
253     // This size can be overridden by setLayoutViewportOverrideRect.
254     WEBCORE_EXPORT LayoutSize baseLayoutViewportSize() const;
255 
256     // If set, overrides the default &quot;m_layoutViewportOrigin, size of initial containing block&quot; rect.
257     // Used with delegated scrolling (i.e. iOS).
258     WEBCORE_EXPORT void setLayoutViewportOverrideRect(Optional&lt;LayoutRect&gt;, TriggerLayoutOrNot = TriggerLayoutOrNot::Yes);
259     Optional&lt;LayoutRect&gt; layoutViewportOverrideRect() const { return m_layoutViewportOverrideRect; }
260 
261     WEBCORE_EXPORT void setVisualViewportOverrideRect(Optional&lt;LayoutRect&gt;);
262     Optional&lt;LayoutRect&gt; visualViewportOverrideRect() const { return m_visualViewportOverrideRect; }
263 
264     // These are in document coordinates, unaffected by page scale (but affected by zooming).
265     WEBCORE_EXPORT LayoutRect layoutViewportRect() const;
266     WEBCORE_EXPORT LayoutRect visualViewportRect() const;
267 
268     static LayoutRect visibleDocumentRect(const FloatRect&amp; visibleContentRect, float headerHeight, float footerHeight, const FloatSize&amp; totalContentsSize, float pageScaleFactor);
269 
270     // This is different than visibleContentRect() in that it ignores negative (or overly positive)
271     // offsets from rubber-banding, and it takes zooming into account.
272     LayoutRect viewportConstrainedVisibleContentRect() const;
273 
274     WEBCORE_EXPORT void layoutOrVisualViewportChanged();
275 
276     LayoutRect rectForFixedPositionLayout() const;
277 
278     void viewportContentsChanged();
279     WEBCORE_EXPORT void resumeVisibleImageAnimationsIncludingSubframes();
280 
281     String mediaType() const;
282     WEBCORE_EXPORT void setMediaType(const String&amp;);
283     void adjustMediaTypeForPrinting(bool printing);
284 
285     void setCannotBlitToWindow();
286     void setIsOverlapped(bool);
287     void setContentIsOpaque(bool);
288 
289     void addSlowRepaintObject(RenderElement&amp;);
290     void removeSlowRepaintObject(RenderElement&amp;);
291     bool hasSlowRepaintObject(const RenderElement&amp; renderer) const { return m_slowRepaintObjects &amp;&amp; m_slowRepaintObjects-&gt;contains(&amp;renderer); }
292     bool hasSlowRepaintObjects() const { return m_slowRepaintObjects &amp;&amp; m_slowRepaintObjects-&gt;size(); }
293 
294     // Includes fixed- and sticky-position objects.
295     typedef HashSet&lt;RenderLayerModelObject*&gt; ViewportConstrainedObjectSet;
296     void addViewportConstrainedObject(RenderLayerModelObject*);
297     void removeViewportConstrainedObject(RenderLayerModelObject*);
298     const ViewportConstrainedObjectSet* viewportConstrainedObjects() const { return m_viewportConstrainedObjects.get(); }
299     bool hasViewportConstrainedObjects() const { return m_viewportConstrainedObjects &amp;&amp; m_viewportConstrainedObjects-&gt;size() &gt; 0; }
300 
301     float frameScaleFactor() const;
302 
303     // Functions for querying the current scrolled position, negating the effects of overhang
304     // and adjusting for page scale.
305     LayoutPoint scrollPositionForFixedPosition() const;
306 
307     // Static function can be called from another thread.
308     WEBCORE_EXPORT static LayoutPoint scrollPositionForFixedPosition(const LayoutRect&amp; visibleContentRect, const LayoutSize&amp; totalContentsSize, const LayoutPoint&amp; scrollPosition, const LayoutPoint&amp; scrollOrigin, float frameScaleFactor, bool fixedElementsLayoutRelativeToFrame, ScrollBehaviorForFixedElements, int headerHeight, int footerHeight);
309 
310     WEBCORE_EXPORT static LayoutSize expandedLayoutViewportSize(const LayoutSize&amp; baseLayoutViewportSize, const LayoutSize&amp; documentSize, double heightExpansionFactor);
311 
312     enum class LayoutViewportConstraint { ConstrainedToDocumentRect, Unconstrained };
313     WEBCORE_EXPORT static LayoutRect computeUpdatedLayoutViewportRect(const LayoutRect&amp; layoutViewport, const LayoutRect&amp; documentRect, const LayoutSize&amp; unobscuredContentSize, const LayoutRect&amp; unobscuredContentRect, const LayoutSize&amp; baseLayoutViewportSize, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, LayoutViewportConstraint);
314 
315     WEBCORE_EXPORT static LayoutPoint computeLayoutViewportOrigin(const LayoutRect&amp; visualViewport, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, const LayoutRect&amp; layoutViewport, ScrollBehaviorForFixedElements);
316 
317     // These layers are positioned differently when there is a topContentInset, a header, or a footer. These value need to be computed
318     // on both the main thread and the scrolling thread.
319     static float yPositionForInsetClipLayer(const FloatPoint&amp; scrollPosition, float topContentInset);
320     WEBCORE_EXPORT static FloatPoint positionForRootContentLayer(const FloatPoint&amp; scrollPosition, const FloatPoint&amp; scrollOrigin, float topContentInset, float headerHeight);
321     WEBCORE_EXPORT FloatPoint positionForRootContentLayer() const;
322 
323     static float yPositionForHeaderLayer(const FloatPoint&amp; scrollPosition, float topContentInset);
324     static float yPositionForFooterLayer(const FloatPoint&amp; scrollPosition, float topContentInset, float totalContentsHeight, float footerHeight);
325 
326 #if PLATFORM(IOS_FAMILY)
327     WEBCORE_EXPORT LayoutRect viewportConstrainedObjectsRect() const;
328     // Static function can be called from another thread.
329     WEBCORE_EXPORT static LayoutRect rectForViewportConstrainedObjects(const LayoutRect&amp; visibleContentRect, const LayoutSize&amp; totalContentsSize, float frameScaleFactor, bool fixedElementsLayoutRelativeToFrame, ScrollBehaviorForFixedElements);
330 #endif
331 
332     IntRect viewRectExpandedByContentInsets() const;
333 
334     bool fixedElementsLayoutRelativeToFrame() const;
335 
336     WEBCORE_EXPORT void disableLayerFlushThrottlingTemporarilyForInteraction();
337     bool speculativeTilingEnabled() const { return m_speculativeTilingEnabled; }
338     void loadProgressingStatusChanged();
339 
340     WEBCORE_EXPORT void updateControlTints();
341 
342     WEBCORE_EXPORT bool wasScrolledByUser() const;
343     WEBCORE_EXPORT void setWasScrolledByUser(bool);
344 
345     bool safeToPropagateScrollToParent() const;
346 
347     void addEmbeddedObjectToUpdate(RenderEmbeddedObject&amp;);
348     void removeEmbeddedObjectToUpdate(RenderEmbeddedObject&amp;);
349 
350     WEBCORE_EXPORT void paintContents(GraphicsContext&amp;, const IntRect&amp; dirtyRect, SecurityOriginPaintPolicy = SecurityOriginPaintPolicy::AnyOrigin) final;
351 
352     struct PaintingState {
353         OptionSet&lt;PaintBehavior&gt; paintBehavior;
354         bool isTopLevelPainter;
355         bool isFlatteningPaintOfRootFrame;
356         PaintingState()
357             : paintBehavior()
358             , isTopLevelPainter(false)
359             , isFlatteningPaintOfRootFrame(false)
360         {
361         }
362     };
363 
364     void willPaintContents(GraphicsContext&amp;, const IntRect&amp; dirtyRect, PaintingState&amp;);
365     void didPaintContents(GraphicsContext&amp;, const IntRect&amp; dirtyRect, PaintingState&amp;);
366 
367 #if PLATFORM(IOS_FAMILY)
368     WEBCORE_EXPORT void didReplaceMultipartContent();
369 #endif
370 
371     WEBCORE_EXPORT void setPaintBehavior(OptionSet&lt;PaintBehavior&gt;);
372     WEBCORE_EXPORT OptionSet&lt;PaintBehavior&gt; paintBehavior() const;
373     bool isPainting() const;
374     bool hasEverPainted() const { return !!m_lastPaintTime; }
375     void setLastPaintTime(MonotonicTime lastPaintTime) { m_lastPaintTime = lastPaintTime; }
376     WEBCORE_EXPORT void setNodeToDraw(Node*);
377 
378     enum SelectionInSnapshot { IncludeSelection, ExcludeSelection };
379     enum CoordinateSpaceForSnapshot { DocumentCoordinates, ViewCoordinates };
380     WEBCORE_EXPORT void paintContentsForSnapshot(GraphicsContext&amp;, const IntRect&amp; imageRect, SelectionInSnapshot shouldPaintSelection, CoordinateSpaceForSnapshot);
381 
382     void paintOverhangAreas(GraphicsContext&amp;, const IntRect&amp; horizontalOverhangArea, const IntRect&amp; verticalOverhangArea, const IntRect&amp; dirtyRect) final;
383     void paintScrollCorner(GraphicsContext&amp;, const IntRect&amp; cornerRect) final;
384     void paintScrollbar(GraphicsContext&amp;, Scrollbar&amp;, const IntRect&amp;) final;
385 
386     WEBCORE_EXPORT Color documentBackgroundColor() const;
387 
388     bool isInChildFrameWithFrameFlattening() const;
389 
390     void startDisallowingLayout() { layoutContext().startDisallowingLayout(); }
391     void endDisallowingLayout() { layoutContext().endDisallowingLayout(); }
392 
393     static MonotonicTime currentPaintTimeStamp() { return sCurrentPaintTimeStamp; } // returns 0 if not painting
394 
395     WEBCORE_EXPORT void updateLayoutAndStyleIfNeededRecursive();
396 
397     void incrementVisuallyNonEmptyCharacterCount(const String&amp;);
398     void incrementVisuallyNonEmptyPixelCount(const IntSize&amp;);
<a name="5" id="anc5"></a>

399     bool isVisuallyNonEmpty() const { return m_isVisuallyNonEmpty; }
400     WEBCORE_EXPORT bool qualifiesAsVisuallyNonEmpty() const;
401 
402     WEBCORE_EXPORT void enableAutoSizeMode(bool enable, const IntSize&amp; minSize);
403     WEBCORE_EXPORT void setAutoSizeFixedMinimumHeight(int);
404     bool isAutoSizeEnabled() const { return m_shouldAutoSize; }
405     IntSize autoSizingIntrinsicContentSize() const { return m_autoSizeContentSize; }
406 
407     WEBCORE_EXPORT void forceLayout(bool allowSubtreeLayout = false);
408     WEBCORE_EXPORT void forceLayoutForPagination(const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkFactor, AdjustViewSizeOrNot);
409 
410     // FIXME: This method is retained because of embedded WebViews in AppKit.  When a WebView is embedded inside
411     // some enclosing view with auto-pagination, no call happens to resize the view.  The new pagination model
412     // needs the view to resize as a result of the breaks, but that means that the enclosing view has to potentially
413     // resize around that view.  Auto-pagination uses the bounds of the actual view that&#39;s being printed to determine
414     // the edges of the print operation, so the resize is necessary if the enclosing view&#39;s bounds depend on the
415     // web document&#39;s bounds.
416     //
417     // This is already a problem if the view needs to be a different size because of printer fonts or because of print stylesheets.
418     // Mail/Dictionary work around this problem by using the _layoutForPrinting SPI
419     // to at least get print stylesheets and printer fonts into play, but since WebKit doesn&#39;t know about the page offset or
420     // page size, it can&#39;t actually paginate correctly during _layoutForPrinting.
421     //
422     // We can eventually move Mail to a newer SPI that would let them opt in to the layout-time pagination model,
423     // but that doesn&#39;t solve the general problem of how other AppKit views could opt in to the better model.
424     //
425     // NO OTHER PLATFORM BESIDES MAC SHOULD USE THIS METHOD.
426     WEBCORE_EXPORT void adjustPageHeightDeprecated(float* newBottom, float oldTop, float oldBottom, float bottomLimit);
427 
428     bool scrollToFragment(const URL&amp;);
<a name="6" id="anc6"></a>
429     void maintainScrollPositionAtAnchor(ContainerNode*);
430     WEBCORE_EXPORT void scrollElementToRect(const Element&amp;, const IntRect&amp;);
431 
432     // Coordinate systems:
433     //
434     // &quot;View&quot;
435     //     Top left is top left of the FrameView/ScrollView/Widget. Size is Widget::boundsRect().size().
436     //
437     // &quot;TotalContents&quot;
438     //    Relative to ScrollView&#39;s scrolled contents, including headers and footers. Size is totalContentsSize().
439     //
440     // &quot;Contents&quot;
441     //    Relative to ScrollView&#39;s scrolled contents, excluding headers and footers, so top left is top left of the scroll view&#39;s
442     //    document, and size is contentsSize().
443     //
444     // &quot;Absolute&quot;
445     //    Relative to the document&#39;s scroll origin (non-zero for RTL documents), but affected by page zoom and page scale. Mostly used
446     //    in rendering code.
447     //
448     // &quot;Document&quot;
449     //    Relative to the document&#39;s scroll origin, but not affected by page zoom or page scale. Size is equivalent to CSS pixel dimensions.
450     //    FIXME: some uses are affected by page zoom (e.g. layout and visual viewports).
451     //
452     // &quot;Client&quot;
453     //    Relative to the visible part of the document (or, more strictly, the layout viewport rect), and with the same scaling
454     //    as Document coordinates, i.e. matching CSS pixels. Affected by scroll origin.
455     //
456     // &quot;LayoutViewport&quot;
457     //    Similar to client coordinates, but affected by page zoom (but not page scale).
458     //
459 
460     // Methods to convert points and rects between the coordinate space of the renderer, and this view.
461     WEBCORE_EXPORT IntRect convertFromRendererToContainingView(const RenderElement*, const IntRect&amp;) const;
462     WEBCORE_EXPORT IntRect convertFromContainingViewToRenderer(const RenderElement*, const IntRect&amp;) const;
463     WEBCORE_EXPORT FloatRect convertFromContainingViewToRenderer(const RenderElement*, const FloatRect&amp;) const;
464     WEBCORE_EXPORT IntPoint convertFromRendererToContainingView(const RenderElement*, const IntPoint&amp;) const;
465     WEBCORE_EXPORT IntPoint convertFromContainingViewToRenderer(const RenderElement*, const IntPoint&amp;) const;
466 
467     // Override ScrollView methods to do point conversion via renderers, in order to take transforms into account.
468     IntRect convertToContainingView(const IntRect&amp;) const final;
469     IntRect convertFromContainingView(const IntRect&amp;) const final;
470     FloatRect convertFromContainingView(const FloatRect&amp;) const final;
471     IntPoint convertToContainingView(const IntPoint&amp;) const final;
472     IntPoint convertFromContainingView(const IntPoint&amp;) const final;
473 
474     float documentToAbsoluteScaleFactor(Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;
475     float absoluteToDocumentScaleFactor(Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;
476 
477     WEBCORE_EXPORT FloatRect absoluteToDocumentRect(FloatRect, Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;
478     WEBCORE_EXPORT FloatPoint absoluteToDocumentPoint(FloatPoint, Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;
479 
480     FloatRect absoluteToClientRect(FloatRect, Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;
481 
482     FloatSize documentToClientOffset() const;
483     WEBCORE_EXPORT FloatRect documentToClientRect(FloatRect) const;
484     FloatPoint documentToClientPoint(FloatPoint) const;
485     WEBCORE_EXPORT FloatRect clientToDocumentRect(FloatRect) const;
486     WEBCORE_EXPORT FloatPoint clientToDocumentPoint(FloatPoint) const;
487 
488     WEBCORE_EXPORT FloatPoint absoluteToLayoutViewportPoint(FloatPoint) const;
489     FloatPoint layoutViewportToAbsolutePoint(FloatPoint) const;
490 
491     WEBCORE_EXPORT FloatRect absoluteToLayoutViewportRect(FloatRect) const;
492     FloatRect layoutViewportToAbsoluteRect(FloatRect) const;
493 
494     // Unlike client coordinates, layout viewport coordinates are affected by page zoom.
495     WEBCORE_EXPORT FloatRect clientToLayoutViewportRect(FloatRect) const;
496     WEBCORE_EXPORT FloatPoint clientToLayoutViewportPoint(FloatPoint) const;
497 
498     bool isFrameViewScrollCorner(const RenderScrollbarPart&amp; scrollCorner) const { return m_scrollCorner.get() == &amp;scrollCorner; }
499 
500     // isScrollable() takes an optional Scrollability parameter that allows the caller to define what they mean by &#39;scrollable.&#39;
501     // Most callers are interested in the default value, Scrollability::Scrollable, which means that there is actually content
502     // to scroll to, and a scrollbar that will allow you to access it. In some cases, callers want to know if the FrameView is allowed
503     // to rubber-band, which the main frame might be allowed to do even if there is no content to scroll to. In that case,
504     // callers use Scrollability::ScrollableOrRubberbandable.
505     enum class Scrollability { Scrollable, ScrollableOrRubberbandable };
506     WEBCORE_EXPORT bool isScrollable(Scrollability definitionOfScrollable = Scrollability::Scrollable);
507 
508     bool isScrollableOrRubberbandable() final;
509     bool hasScrollableOrRubberbandableAncestor() final;
510 
511     enum ScrollbarModesCalculationStrategy { RulesFromWebContentOnly, AnyRule };
512     void calculateScrollbarModesForLayout(ScrollbarMode&amp; hMode, ScrollbarMode&amp; vMode, ScrollbarModesCalculationStrategy = AnyRule);
513 
514     IntPoint lastKnownMousePosition() const final;
515     bool isHandlingWheelEvent() const final;
516     bool shouldSetCursor() const;
517 
518     WEBCORE_EXPORT bool useDarkAppearance() const final;
519     OptionSet&lt;StyleColor::Options&gt; styleColorOptions() const;
520 
521     // FIXME: Remove this method once plugin loading is decoupled from layout.
522     void flushAnyPendingPostLayoutTasks();
523 
524     bool shouldSuspendScrollAnimations() const final;
525     void scrollbarStyleChanged(ScrollbarStyle, bool forceUpdate) override;
526 
527     RenderBox* embeddedContentBox() const;
528 
529     WEBCORE_EXPORT void setTracksRepaints(bool);
530     bool isTrackingRepaints() const { return m_isTrackingRepaints; }
531     WEBCORE_EXPORT void resetTrackedRepaints();
532     const Vector&lt;FloatRect&gt;&amp; trackedRepaintRects() const { return m_trackedRepaintRects; }
533     String trackedRepaintRectsAsText() const;
534 
535     typedef HashSet&lt;ScrollableArea*&gt; ScrollableAreaSet;
536     // Returns whether the scrollable area has just been newly added.
537     WEBCORE_EXPORT bool addScrollableArea(ScrollableArea*);
538     // Returns whether the scrollable area has just been removed.
539     WEBCORE_EXPORT bool removeScrollableArea(ScrollableArea*);
540     bool containsScrollableArea(ScrollableArea*) const;
541     const ScrollableAreaSet* scrollableAreas() const { return m_scrollableAreas.get(); }
542 
543     WEBCORE_EXPORT void addChild(Widget&amp;) final;
544     WEBCORE_EXPORT void removeChild(Widget&amp;) final;
545 
546     // This function exists for ports that need to handle wheel events manually.
547     // On Mac WebKit1 the underlying NSScrollView just does the scrolling, but on most other platforms
548     // we need this function in order to do the scroll ourselves.
549     bool wheelEvent(const PlatformWheelEvent&amp;);
550 
551     WEBCORE_EXPORT void setScrollingPerformanceLoggingEnabled(bool);
552 
553     // Page and FrameView both store a Pagination value. Page::pagination() is set only by API,
554     // and FrameView::pagination() is set only by CSS. Page::pagination() will affect all
<a name="7" id="anc7"></a><span class="line-modified">555     // FrameViews in the back/forward cache, but FrameView::pagination() only affects the current</span>
556     // FrameView. FrameView::pagination() will return m_pagination if it has been set. Otherwise,
557     // it will return Page::pagination() since currently there are no callers that need to
558     // distinguish between the two.
559     const Pagination&amp; pagination() const;
560     void setPagination(const Pagination&amp;);
561 
562 #if ENABLE(CSS_DEVICE_ADAPTATION)
563     IntSize initialViewportSize() const { return m_initialViewportSize; }
564     void setInitialViewportSize(const IntSize&amp; size) { m_initialViewportSize = size; }
565 #endif
566 
567     bool isActive() const final;
568     bool forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const final;
569 
570 #if ENABLE(RUBBER_BANDING)
571     WEBCORE_EXPORT GraphicsLayer* setWantsLayerForTopOverHangArea(bool) const;
572     WEBCORE_EXPORT GraphicsLayer* setWantsLayerForBottomOverHangArea(bool) const;
573 #endif
574 
575     // This function &quot;smears&quot; the &quot;position:fixed&quot; uninflatedBounds for scrolling, returning a rect that is the union of
576     // all possible locations of the given rect under page scrolling.
577     LayoutRect fixedScrollableAreaBoundsInflatedForScrolling(const LayoutRect&amp; uninflatedBounds) const;
578 
579     LayoutPoint scrollPositionRespectingCustomFixedPosition() const;
580 
581     WEBCORE_EXPORT int headerHeight() const final;
582     WEBCORE_EXPORT int footerHeight() const final;
583 
584     WEBCORE_EXPORT float topContentInset(TopContentInsetType = TopContentInsetType::WebCoreContentInset) const final;
585     void topContentInsetDidChange(float newTopContentInset);
586 
587     void topContentDirectionDidChange();
588 
589     WEBCORE_EXPORT void willStartLiveResize() final;
590     WEBCORE_EXPORT void willEndLiveResize() final;
591 
592     WEBCORE_EXPORT void availableContentSizeChanged(AvailableSizeChangeReason) final;
593 
594     void updateTiledBackingAdaptiveSizing();
595     TiledBacking::Scrollability computeScrollability() const;
596 
597     void addPaintPendingMilestones(OptionSet&lt;LayoutMilestone&gt;);
598     void firePaintRelatedMilestonesIfNeeded();
599     void fireLayoutRelatedMilestonesIfNeeded();
600     OptionSet&lt;LayoutMilestone&gt; milestonesPendingPaint() const { return m_milestonesPendingPaint; }
601 
602     bool visualUpdatesAllowedByClient() const { return m_visualUpdatesAllowedByClient; }
603     WEBCORE_EXPORT void setVisualUpdatesAllowedByClient(bool);
604 
605     WEBCORE_EXPORT void setScrollPinningBehavior(ScrollPinningBehavior);
606 
607     ScrollBehaviorForFixedElements scrollBehaviorForFixedElements() const;
608 
609     bool hasFlippedBlockRenderers() const { return m_hasFlippedBlockRenderers; }
610     void setHasFlippedBlockRenderers(bool b) { m_hasFlippedBlockRenderers = b; }
611 
612     void updateWidgetPositions();
613     void scheduleUpdateWidgetPositions();
614 
615     void didAddWidgetToRenderTree(Widget&amp;);
616     void willRemoveWidgetFromRenderTree(Widget&amp;);
617 
618     const HashSet&lt;Widget*&gt;&amp; widgetsInRenderTree() const { return m_widgetsInRenderTree; }
619 
620     void addTrackedRepaintRect(const FloatRect&amp;);
621 
622     // exposedRect represents WebKit&#39;s understanding of what part
623     // of the view is actually exposed on screen (taking into account
624     // clipping by other UI elements), whereas visibleContentRect is
625     // internal to WebCore and doesn&#39;t respect those things.
626     WEBCORE_EXPORT void setViewExposedRect(Optional&lt;FloatRect&gt;);
627     Optional&lt;FloatRect&gt; viewExposedRect() const { return m_viewExposedRect; }
628 
629 #if ENABLE(CSS_SCROLL_SNAP)
630     void updateSnapOffsets() final;
631     bool isScrollSnapInProgress() const final;
632     void updateScrollingCoordinatorScrollSnapProperties() const;
633 #endif
634 
635     float adjustScrollStepForFixedContent(float step, ScrollbarOrientation, ScrollGranularity) final;
636 
637     void didChangeScrollOffset();
638 
639     void show() final;
640     void hide() final;
641 
642     bool shouldPlaceBlockDirectionScrollbarOnLeft() const final;
643 
<a name="8" id="anc8"></a><span class="line-modified">644     void didRestoreFromBackForwardCache();</span>
645 
646     void willDestroyRenderTree();
647     void didDestroyRenderTree();
648 
649     void setSpeculativeTilingDelayDisabledForTesting(bool disabled) { m_speculativeTilingDelayDisabledForTesting = disabled; }
650 
651     WEBCORE_EXPORT FrameFlattening effectiveFrameFlattening() const;
652 
653     WEBCORE_EXPORT void traverseForPaintInvalidation(GraphicsContext::PaintInvalidationReasons);
654     void invalidateControlTints() { traverseForPaintInvalidation(GraphicsContext::PaintInvalidationReasons::InvalidatingControlTints); }
655     void invalidateImagesWithAsyncDecodes() { traverseForPaintInvalidation(GraphicsContext::PaintInvalidationReasons::InvalidatingImagesWithAsyncDecodes); }
656 
657     GraphicsLayer* layerForHorizontalScrollbar() const final;
658     GraphicsLayer* layerForVerticalScrollbar() const final;
659 
<a name="9" id="anc9"></a><span class="line-added">660     void renderLayerDidScroll(const RenderLayer&amp;);</span>
<span class="line-added">661 </span>
662 protected:
663     bool scrollContentsFastPath(const IntSize&amp; scrollDelta, const IntRect&amp; rectToScroll, const IntRect&amp; clipRect) final;
664     void scrollContentsSlowPath(const IntRect&amp; updateRect) final;
665 
666     void repaintSlowRepaintObjects();
667 
668     bool isVerticalDocument() const final;
669     bool isFlippedDocument() const final;
670 
671 private:
672     explicit FrameView(Frame&amp;);
673 
674     void reset();
675     void init();
676 
677     enum LayoutPhase {
678         OutsideLayout,
679         InPreLayout,
680         InRenderTreeLayout,
681         InViewSizeAdjust,
682         InPostLayout
683     };
684 
685     bool isFrameView() const final { return true; }
686 
687     friend class RenderWidget;
688     bool useSlowRepaints(bool considerOverlap = true) const;
689     bool useSlowRepaintsIfNotOverlapped() const;
690     void updateCanBlitOnScrollRecursively();
691     bool shouldLayoutAfterContentsResized() const;
692 
693     bool shouldUpdateCompositingLayersAfterScrolling() const;
694     bool flushCompositingStateForThisFrame(const Frame&amp; rootFrameForFlush);
695 
696     bool shouldDeferScrollUpdateAfterContentSizeChange() final;
697 
698     void scrollOffsetChangedViaPlatformWidgetImpl(const ScrollOffset&amp; oldOffset, const ScrollOffset&amp; newOffset) final;
699 
700     void applyOverflowToViewport(const RenderElement&amp;, ScrollbarMode&amp; hMode, ScrollbarMode&amp; vMode);
701     void applyPaginationToViewport();
702 
703     void updateOverflowStatus(bool horizontalOverflow, bool verticalOverflow);
704 
705     void forceLayoutParentViewIfNeeded();
706     void flushPostLayoutTasksQueue();
707     void performPostLayoutTasks();
708     void autoSizeIfEnabled();
709 
710     void applyRecursivelyWithVisibleRect(const WTF::Function&lt;void (FrameView&amp; frameView, const IntRect&amp; visibleRect)&gt;&amp;);
711     void resumeVisibleImageAnimations(const IntRect&amp; visibleRect);
712     void updateScriptedAnimationsAndTimersThrottlingState(const IntRect&amp; visibleRect);
713 
714     void updateLayerFlushThrottling();
715     WEBCORE_EXPORT void adjustTiledBackingCoverage();
716 
717     void repaintContentRectangle(const IntRect&amp;) final;
718     void addedOrRemovedScrollbar() final;
719 
720     void scrollToFocusedElementTimerFired();
721     void scrollToFocusedElementInternal();
722 
723     void delegatesScrollingDidChange() final;
724 
<a name="10" id="anc10"></a><span class="line-added">725     void unobscuredContentSizeChanged() final;</span>
<span class="line-added">726 </span>
727     // ScrollableArea interface
728     void invalidateScrollbarRect(Scrollbar&amp;, const IntRect&amp;) final;
729     void scrollTo(const ScrollPosition&amp;) final;
730     void setVisibleScrollerThumbRect(const IntRect&amp;) final;
731     ScrollableArea* enclosingScrollableArea() const final;
732     IntRect scrollableAreaBoundingBox(bool* = nullptr) const final;
733     bool scrollAnimatorEnabled() const final;
734     GraphicsLayer* layerForScrollCorner() const final;
735 #if ENABLE(RUBBER_BANDING)
736     GraphicsLayer* layerForOverhangAreas() const final;
737 #endif
738     void contentsResized() final;
739 
<a name="11" id="anc11"></a>



740 #if ENABLE(DARK_MODE_CSS)
741     RenderObject* rendererForColorScheme() const;
742 #endif
743 
744     bool usesCompositedScrolling() const final;
745     bool usesMockScrollAnimator() const final;
746     void logMockScrollAnimatorMessage(const String&amp;) const final;
747 
<a name="12" id="anc12"></a><span class="line-added">748     bool styleHidesScrollbarWithOrientation(ScrollbarOrientation) const;</span>
<span class="line-added">749     bool horizontalScrollbarHiddenByStyle() const final;</span>
<span class="line-added">750     bool verticalScrollbarHiddenByStyle() const final;</span>
<span class="line-added">751 </span>
752     // Override scrollbar notifications to update the AXObject cache.
753     void didAddScrollbar(Scrollbar*, ScrollbarOrientation) final;
754     void willRemoveScrollbar(Scrollbar*, ScrollbarOrientation) final;
755 
756     IntSize sizeForResizeEvent() const;
757     void sendResizeEventIfNeeded();
758 
<a name="13" id="anc13"></a><span class="line-added">759     RefPtr&lt;Element&gt; rootElementForCustomScrollbarPartStyle(PseudoId) const;</span>
<span class="line-added">760 </span>
761     void adjustScrollbarsForLayout(bool firstLayout);
762 
763     void handleDeferredScrollbarsUpdateAfterDirectionChange();
764 
765     void updateScrollableAreaSet();
766     void updateLayoutViewport();
767 
768     void notifyPageThatContentAreaWillPaint() const final;
769 
770     void enableSpeculativeTilingIfNeeded();
771     void speculativeTilingEnableTimerFired();
772 
773     void updateEmbeddedObjectsTimerFired();
774     bool updateEmbeddedObjects();
775     void updateEmbeddedObject(RenderEmbeddedObject&amp;);
776 
777     void updateWidgetPositionsTimerFired();
778 
<a name="14" id="anc14"></a><span class="line-added">779     bool scrollToFragmentInternal(const String&amp;);</span>
780     void scrollToAnchor();
781     void scrollPositionChanged(const ScrollPosition&amp; oldPosition, const ScrollPosition&amp; newPosition);
782     void scrollableAreaSetChanged();
783     void sendScrollEvent();
784     void resetScrollAnchor();
785 
786     bool hasCustomScrollbars() const;
787 
788     void updateScrollCorner() final;
789 
790     FrameView* parentFrameView() const;
791 
792     bool frameFlatteningEnabled() const;
793     bool isFrameFlatteningValidForThisFrame() const;
794 
795     void markRootOrBodyRendererDirty() const;
796 
797     bool qualifiesAsSignificantRenderedText() const;
798     void updateHasReachedSignificantRenderedTextThreshold();
799 
800     bool isViewForDocumentInFrame() const;
801 
802     AXObjectCache* axObjectCache() const;
803     void notifyWidgetsInAllFrames(WidgetNotification);
804     void removeFromAXObjectCache();
805     void notifyWidgets(WidgetNotification);
806 
807     RenderElement* viewportRenderer() const;
808 
809     void willDoLayout(WeakPtr&lt;RenderElement&gt; layoutRoot);
810     void didLayout(WeakPtr&lt;RenderElement&gt; layoutRoot);
811 
812     struct OverrideViewportSize {
813         Optional&lt;int&gt; width;
814         Optional&lt;int&gt; height;
815 
816         bool operator==(const OverrideViewportSize&amp; rhs) const { return rhs.width == width &amp;&amp; rhs.height == height; }
817     };
818     void overrideViewportSizeForCSSViewportUnits(OverrideViewportSize);
819 
820     static MonotonicTime sCurrentPaintTimeStamp; // used for detecting decoded resource thrash in the cache
821 
822     const Ref&lt;Frame&gt; m_frame;
823     FrameViewLayoutContext m_layoutContext;
824 
825     HashSet&lt;Widget*&gt; m_widgetsInRenderTree;
826     std::unique_ptr&lt;ListHashSet&lt;RenderEmbeddedObject*&gt;&gt; m_embeddedObjectsToUpdate;
827     std::unique_ptr&lt;HashSet&lt;const RenderElement*&gt;&gt; m_slowRepaintObjects;
828 
829     RefPtr&lt;ContainerNode&gt; m_maintainScrollPositionAnchor;
830     RefPtr&lt;Node&gt; m_nodeToDraw;
831 
832     // Renderer to hold our custom scroll corner.
833     RenderPtr&lt;RenderScrollbarPart&gt; m_scrollCorner;
834 
835     Timer m_updateEmbeddedObjectsTimer;
836     Timer m_updateWidgetPositionsTimer;
837     Timer m_delayedScrollEventTimer;
838     Timer m_delayedScrollToFocusedElementTimer;
839     Timer m_speculativeTilingEnableTimer;
840 
841     MonotonicTime m_lastPaintTime;
842 
843     LayoutSize m_size;
844 
845     Color m_baseBackgroundColor { Color::white };
846     IntSize m_lastViewportSize;
847 
848     String m_mediaType { &quot;screen&quot;_s };
849     String m_mediaTypeWhenNotPrinting;
850 
851     Vector&lt;FloatRect&gt; m_trackedRepaintRects;
852 
853     IntRect* m_cachedWindowClipRect { nullptr };
854     Vector&lt;WTF::Function&lt;void ()&gt;&gt; m_postLayoutCallbackQueue;
855 
856     LayoutPoint m_layoutViewportOrigin;
857     Optional&lt;LayoutRect&gt; m_layoutViewportOverrideRect;
858     Optional&lt;LayoutRect&gt; m_visualViewportOverrideRect; // Used when the iOS keyboard is showing.
859 
860     Optional&lt;FloatRect&gt; m_viewExposedRect;
861 
862     OptionSet&lt;PaintBehavior&gt; m_paintBehavior;
863 
864     float m_lastZoomFactor { 1 };
865     unsigned m_visuallyNonEmptyCharacterCount { 0 };
866     unsigned m_visuallyNonEmptyPixelCount { 0 };
867     unsigned m_textRendererCountForVisuallyNonEmptyCharacters { 0 };
868     int m_headerHeight { 0 };
869     int m_footerHeight { 0 };
870 
871 #if PLATFORM(IOS_FAMILY)
872     bool m_useCustomFixedPositionLayoutRect { false };
873     bool m_useCustomSizeForResizeEvent { false };
874 
875     IntRect m_customFixedPositionLayoutRect;
876     IntSize m_customSizeForResizeEvent;
877 #endif
878 
879     Optional&lt;OverrideViewportSize&gt; m_overrideViewportSize;
880 
881     // The view size when autosizing.
882     IntSize m_autoSizeConstraint;
883     // The fixed height to resize the view to after autosizing is complete.
884     int m_autoSizeFixedMinimumHeight { 0 };
885     // The intrinsic content size decided by autosizing.
886     IntSize m_autoSizeContentSize;
887 
888     std::unique_ptr&lt;ScrollableAreaSet&gt; m_scrollableAreas;
889     std::unique_ptr&lt;ViewportConstrainedObjectSet&gt; m_viewportConstrainedObjects;
890 
891     OptionSet&lt;LayoutMilestone&gt; m_milestonesPendingPaint;
892 
893     static const unsigned visualCharacterThreshold = 200;
894     static const unsigned visualPixelThreshold = 32 * 32;
895 
896 #if ENABLE(CSS_DEVICE_ADAPTATION)
897     // Size of viewport before any UA or author styles have overridden
898     // the viewport given by the window or viewing area of the UA.
899     IntSize m_initialViewportSize;
900 #endif
901 
902     Pagination m_pagination;
903 
904     enum class ViewportRendererType : uint8_t { None, Document, Body };
905     ViewportRendererType m_viewportRendererType { ViewportRendererType::None };
906     ScrollPinningBehavior m_scrollPinningBehavior { DoNotPin };
907     SelectionRevealMode m_selectionRevealModeForFocusedElement { SelectionRevealMode::DoNotReveal };
908 
909     bool m_shouldUpdateWhileOffscreen { true };
910     bool m_overflowStatusDirty { true };
911     bool m_horizontalOverflow { false };
912     bool m_verticalOverflow { false };
913     bool m_canHaveScrollbars { true };
914     bool m_cannotBlitToWindow { false };
915     bool m_isOverlapped { false };
916     bool m_contentIsOpaque { false };
917     bool m_firstLayoutCallbackPending { false };
918 
919     bool m_isTransparent { false };
920 #if ENABLE(DARK_MODE_CSS)
921     bool m_usesDarkAppearance { false };
922 #endif
923 
924     bool m_isTrackingRepaints { false }; // Used for testing.
925     bool m_wasScrolledByUser { false };
926     bool m_shouldScrollToFocusedElement { false };
927 
928     bool m_isPainting { false };
929 
930     bool m_isVisuallyNonEmpty { false };
931 
932     bool m_renderedSignificantAmountOfText { false };
933     bool m_hasReachedSignificantRenderedTextThreshold { false };
934 
935     bool m_needsDeferredScrollbarsUpdate { false };
936     bool m_speculativeTilingEnabled { false };
937     bool m_visualUpdatesAllowedByClient { true };
938     bool m_hasFlippedBlockRenderers { false };
939     bool m_speculativeTilingDelayDisabledForTesting { false };
940 
941     // If true, automatically resize the frame view around its content.
942     bool m_shouldAutoSize { false };
943     bool m_inAutoSize { false };
944     // True if autosize has been run since m_shouldAutoSize was set.
945     bool m_didRunAutosize { false };
946 };
947 
948 inline void FrameView::incrementVisuallyNonEmptyPixelCount(const IntSize&amp; size)
949 {
950     if (m_visuallyNonEmptyPixelCount &gt; visualPixelThreshold)
951         return;
952     m_visuallyNonEmptyPixelCount += size.width() * size.height();
953 }
954 
955 } // namespace WebCore
956 
957 SPECIALIZE_TYPE_TRAITS_WIDGET(FrameView, isFrameView())
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
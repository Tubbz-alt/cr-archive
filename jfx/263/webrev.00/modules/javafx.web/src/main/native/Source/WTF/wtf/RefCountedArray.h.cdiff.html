<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WTF/wtf/RefCountedArray.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RefCounted.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RefPtr.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/RefCountedArray.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 41,10 ***</span>
<span class="line-new-header">--- 41,12 ---</span>
  //    it&#39;s used for things that aren&#39;t quite POD according to the official
  //    defintion, such as JSC::Instruction.
  
  namespace WTF {
  
<span class="line-added">+ DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(RefCountedArray);</span>
<span class="line-added">+ </span>
  template&lt;typename T, typename PtrTraits = DumbPtrTraits&lt;T&gt;&gt;
  class RefCountedArray {
      enum CommonCopyConstructorTag { CommonCopyConstructor };
  
  public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 65,11 ***</span>
              // NOTE: JSC&#39;s LowLevelInterpreter relies on this being nullptr when the size is zero.
              PtrTraits::exchange(m_data, nullptr);
              return;
          }
  
<span class="line-modified">!         T* data = (static_cast&lt;Header*&gt;(fastMalloc(Header::size() + sizeof(T) * size)))-&gt;payload();</span>
          m_data = data;
          Header::fromPayload(data)-&gt;refCount = 1;
          Header::fromPayload(data)-&gt;length = size;
          ASSERT(Header::fromPayload(data)-&gt;length == size);
          VectorTypeOperations&lt;T&gt;::initializeIfNonPOD(begin(), end());
<span class="line-new-header">--- 67,11 ---</span>
              // NOTE: JSC&#39;s LowLevelInterpreter relies on this being nullptr when the size is zero.
              PtrTraits::exchange(m_data, nullptr);
              return;
          }
  
<span class="line-modified">!         T* data = (static_cast&lt;Header*&gt;(RefCountedArrayMalloc::malloc(Header::size() + sizeof(T) * size)))-&gt;payload();</span>
          m_data = data;
          Header::fromPayload(data)-&gt;refCount = 1;
          Header::fromPayload(data)-&gt;length = size;
          ASSERT(Header::fromPayload(data)-&gt;length == size);
          VectorTypeOperations&lt;T&gt;::initializeIfNonPOD(begin(), end());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 92,11 ***</span>
          if (other.isEmpty()) {
              PtrTraits::exchange(m_data, nullptr);
              return;
          }
  
<span class="line-modified">!         T* data = (static_cast&lt;Header*&gt;(fastMalloc(Header::size() + sizeof(T) * other.size())))-&gt;payload();</span>
          m_data = data;
          Header::fromPayload(data)-&gt;refCount = 1;
          Header::fromPayload(data)-&gt;length = other.size();
          ASSERT(Header::fromPayload(data)-&gt;length == other.size());
          VectorTypeOperations&lt;T&gt;::uninitializedCopy(other.begin(), other.end(), data);
<span class="line-new-header">--- 94,11 ---</span>
          if (other.isEmpty()) {
              PtrTraits::exchange(m_data, nullptr);
              return;
          }
  
<span class="line-modified">!         T* data = (static_cast&lt;Header*&gt;(RefCountedArrayMalloc::malloc(Header::size() + sizeof(T) * other.size())))-&gt;payload();</span>
          m_data = data;
          Header::fromPayload(data)-&gt;refCount = 1;
          Header::fromPayload(data)-&gt;length = other.size();
          ASSERT(Header::fromPayload(data)-&gt;length == other.size());
          VectorTypeOperations&lt;T&gt;::uninitializedCopy(other.begin(), other.end(), data);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,19 ***</span>
      RefCountedArray&amp; operator=(const RefCountedArray&amp; other)
      {
          return assign&lt;PtrTraits&gt;(other);
      }
  
      ~RefCountedArray()
      {
          if (!m_data)
              return;
          T* data = this-&gt;data();
          if (--Header::fromPayload(data)-&gt;refCount)
              return;
          VectorTypeOperations&lt;T&gt;::destruct(begin(), end());
<span class="line-modified">!         fastFree(Header::fromPayload(data));</span>
      }
  
      unsigned refCount() const
      {
          if (!m_data)
<span class="line-new-header">--- 113,43 ---</span>
      RefCountedArray&amp; operator=(const RefCountedArray&amp; other)
      {
          return assign&lt;PtrTraits&gt;(other);
      }
  
<span class="line-added">+     template&lt;size_t inlineCapacity, typename OverflowHandler&gt;</span>
<span class="line-added">+     RefCountedArray&amp; operator=(const Vector&lt;T, inlineCapacity, OverflowHandler&gt;&amp; other)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         T* oldData = data();</span>
<span class="line-added">+         if (other.isEmpty())</span>
<span class="line-added">+             PtrTraits::exchange(m_data, nullptr);</span>
<span class="line-added">+         else {</span>
<span class="line-added">+             T* data = (static_cast&lt;Header*&gt;(RefCountedArrayMalloc::malloc(Header::size() + sizeof(T) * other.size())))-&gt;payload();</span>
<span class="line-added">+             m_data = data;</span>
<span class="line-added">+             Header::fromPayload(data)-&gt;refCount = 1;</span>
<span class="line-added">+             Header::fromPayload(data)-&gt;length = other.size();</span>
<span class="line-added">+             ASSERT(Header::fromPayload(data)-&gt;length == other.size());</span>
<span class="line-added">+             VectorTypeOperations&lt;T&gt;::uninitializedCopy(other.begin(), other.end(), data);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (!oldData)</span>
<span class="line-added">+             return *this;</span>
<span class="line-added">+         if (--Header::fromPayload(oldData)-&gt;refCount)</span>
<span class="line-added">+             return *this;</span>
<span class="line-added">+         VectorTypeOperations&lt;T&gt;::destruct(oldData, oldData + Header::fromPayload(oldData)-&gt;length);</span>
<span class="line-added">+ </span>
<span class="line-added">+         RefCountedArrayMalloc::free(Header::fromPayload(oldData));</span>
<span class="line-added">+         return *this;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      ~RefCountedArray()
      {
          if (!m_data)
              return;
          T* data = this-&gt;data();
          if (--Header::fromPayload(data)-&gt;refCount)
              return;
          VectorTypeOperations&lt;T&gt;::destruct(begin(), end());
<span class="line-modified">!         RefCountedArrayMalloc::free(Header::fromPayload(data));</span>
      }
  
      unsigned refCount() const
      {
          if (!m_data)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 136,10 ***</span>
<span class="line-new-header">--- 162,12 ---</span>
          if (!m_data)
              return 0;
          return Header::fromPayload(data())-&gt;length;
      }
  
<span class="line-added">+     bool isEmpty() const { return size() == 0; }</span>
<span class="line-added">+ </span>
      size_t byteSize() const { return size() * sizeof(T); }
  
      T* data() { return PtrTraits::unwrap(m_data); }
      T* begin() { return data(); }
      T* end()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 167,10 ***</span>
<span class="line-new-header">--- 195,15 ---</span>
      }
  
      T&amp; operator[](size_t i) { return at(i); }
      const T&amp; operator[](size_t i) const { return at(i); }
  
<span class="line-added">+     T&amp; first() { return (*this)[0]; }</span>
<span class="line-added">+     const T&amp; first() const { return (*this)[0]; }</span>
<span class="line-added">+     T&amp; last() { return (*this)[size() - 1]; }</span>
<span class="line-added">+     const T&amp; last() const { return (*this)[size() - 1]; }</span>
<span class="line-added">+ </span>
      template&lt;typename OtherTraits = PtrTraits&gt;
      bool operator==(const RefCountedArray&lt;T, OtherTraits&gt;&amp; other) const
      {
          T* data = const_cast&lt;T*&gt;(this-&gt;data());
          T* otherData = const_cast&lt;T*&gt;(other.data());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 203,11 ***</span>
          if (!oldData)
              return *this;
          if (--Header::fromPayload(oldData)-&gt;refCount)
              return *this;
          VectorTypeOperations&lt;T&gt;::destruct(oldData, oldData + Header::fromPayload(oldData)-&gt;length);
<span class="line-modified">!         fastFree(Header::fromPayload(oldData));</span>
          return *this;
      }
  
      struct Header {
          unsigned refCount;
<span class="line-new-header">--- 236,12 ---</span>
          if (!oldData)
              return *this;
          if (--Header::fromPayload(oldData)-&gt;refCount)
              return *this;
          VectorTypeOperations&lt;T&gt;::destruct(oldData, oldData + Header::fromPayload(oldData)-&gt;length);
<span class="line-modified">! </span>
<span class="line-added">+         RefCountedArrayMalloc::free(Header::fromPayload(oldData));</span>
          return *this;
      }
  
      struct Header {
          unsigned refCount;
</pre>
<center><a href="RefCounted.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RefPtr.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
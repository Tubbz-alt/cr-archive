<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorCanvasAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorCSSAgent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorCanvasAgent.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorCanvasAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,47 ***</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;InspectorCanvasAgent.h&quot;
  
<span class="line-removed">- #include &quot;ActiveDOMCallbackMicrotask.h&quot;</span>
  #include &quot;CanvasRenderingContext.h&quot;
  #include &quot;CanvasRenderingContext2D.h&quot;
  #include &quot;Document.h&quot;
  #include &quot;Element.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;HTMLCanvasElement.h&quot;
  #include &quot;ImageBitmapRenderingContext.h&quot;
  #include &quot;InspectorDOMAgent.h&quot;
  #include &quot;InstrumentingAgents.h&quot;
<span class="line-removed">- #include &quot;JSCanvasRenderingContext2D.h&quot;</span>
  #include &quot;JSExecState.h&quot;
<span class="line-removed">- #include &quot;JSImageBitmapRenderingContext.h&quot;</span>
<span class="line-removed">- #include &quot;Microtasks.h&quot;</span>
<span class="line-removed">- #include &quot;OffscreenCanvas.h&quot;</span>
  #include &quot;ScriptState.h&quot;
  #include &quot;StringAdaptors.h&quot;
  #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
  #include &lt;JavaScriptCore/InjectedScript.h&gt;
  #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
  #include &lt;JavaScriptCore/InspectorProtocolObjects.h&gt;
  #include &lt;JavaScriptCore/JSCInlines.h&gt;
  #include &lt;wtf/HashSet.h&gt;
  #include &lt;wtf/Lock.h&gt;
  
  #if ENABLE(WEBGL)
<span class="line-removed">- #include &quot;JSWebGLRenderingContext.h&quot;</span>
  #include &quot;WebGLProgram.h&quot;
<span class="line-modified">! #include &quot;WebGLShader.h&quot;</span>
  #endif
  
  #if ENABLE(WEBGL2)
<span class="line-modified">! #include &quot;JSWebGL2RenderingContext.h&quot;</span>
  #endif
  
  #if ENABLE(WEBGPU)
<span class="line-modified">! #include &quot;JSGPUCanvasContext.h&quot;</span>
  #endif
  
  namespace WebCore {
  
  using namespace Inspector;
<span class="line-new-header">--- 24,59 ---</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;InspectorCanvasAgent.h&quot;
  
  #include &quot;CanvasRenderingContext.h&quot;
  #include &quot;CanvasRenderingContext2D.h&quot;
  #include &quot;Document.h&quot;
  #include &quot;Element.h&quot;
<span class="line-added">+ #include &quot;EventLoop.h&quot;</span>
  #include &quot;Frame.h&quot;
  #include &quot;HTMLCanvasElement.h&quot;
<span class="line-added">+ #include &quot;ImageBitmap.h&quot;</span>
  #include &quot;ImageBitmapRenderingContext.h&quot;
  #include &quot;InspectorDOMAgent.h&quot;
<span class="line-added">+ #include &quot;InspectorShaderProgram.h&quot;</span>
  #include &quot;InstrumentingAgents.h&quot;
  #include &quot;JSExecState.h&quot;
  #include &quot;ScriptState.h&quot;
  #include &quot;StringAdaptors.h&quot;
  #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
  #include &lt;JavaScriptCore/InjectedScript.h&gt;
  #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
  #include &lt;JavaScriptCore/InspectorProtocolObjects.h&gt;
  #include &lt;JavaScriptCore/JSCInlines.h&gt;
<span class="line-added">+ #include &lt;wtf/HashMap.h&gt;</span>
  #include &lt;wtf/HashSet.h&gt;
  #include &lt;wtf/Lock.h&gt;
<span class="line-added">+ #include &lt;wtf/Optional.h&gt;</span>
<span class="line-added">+ #include &lt;wtf/RefPtr.h&gt;</span>
<span class="line-added">+ #include &lt;wtf/Vector.h&gt;</span>
<span class="line-added">+ #include &lt;wtf/text/WTFString.h&gt;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+ #include &quot;OffscreenCanvas.h&quot;</span>
<span class="line-added">+ #endif</span>
  
  #if ENABLE(WEBGL)
  #include &quot;WebGLProgram.h&quot;
<span class="line-modified">! #include &quot;WebGLRenderingContext.h&quot;</span>
<span class="line-added">+ #include &quot;WebGLRenderingContextBase.h&quot;</span>
  #endif
  
  #if ENABLE(WEBGL2)
<span class="line-modified">! #include &quot;WebGL2RenderingContext.h&quot;</span>
  #endif
  
  #if ENABLE(WEBGPU)
<span class="line-modified">! #include &quot;GPUCanvasContext.h&quot;</span>
<span class="line-added">+ #include &quot;WebGPUComputePipeline.h&quot;</span>
<span class="line-added">+ #include &quot;WebGPUDevice.h&quot;</span>
<span class="line-added">+ #include &quot;WebGPUPipeline.h&quot;</span>
<span class="line-added">+ #include &quot;WebGPURenderPipeline.h&quot;</span>
<span class="line-added">+ #include &quot;WebGPUSwapChain.h&quot;</span>
  #endif
  
  namespace WebCore {
  
  using namespace Inspector;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 74,10 ***</span>
<span class="line-new-header">--- 86,11 ---</span>
      , m_frontendDispatcher(makeUnique&lt;Inspector::CanvasFrontendDispatcher&gt;(context.frontendRouter))
      , m_backendDispatcher(Inspector::CanvasBackendDispatcher::create(context.backendDispatcher, this))
      , m_injectedScriptManager(context.injectedScriptManager)
      , m_inspectedPage(context.inspectedPage)
      , m_canvasDestroyedTimer(*this, &amp;InspectorCanvasAgent::canvasDestroyedTimerFired)
<span class="line-added">+     , m_programDestroyedTimer(*this, &amp;InspectorCanvasAgent::programDestroyedTimerFired)</span>
  {
  }
  
  InspectorCanvasAgent::~InspectorCanvasAgent() = default;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 91,57 ***</span>
      disable(ignored);
  }
  
  void InspectorCanvasAgent::discardAgent()
  {
<span class="line-modified">!     clearCanvasData();</span>
  }
  
  void InspectorCanvasAgent::enable(ErrorString&amp;)
  {
      if (m_instrumentingAgents.inspectorCanvasAgent() == this)
          return;
  
      m_instrumentingAgents.setInspectorCanvasAgent(this);
  
<span class="line-modified">!     const auto canvasExistsInCurrentPage = [&amp;] (CanvasRenderingContext* canvasRenderingContext) {</span>
<span class="line-removed">-         if (!canvasRenderingContext)</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto* scriptExecutionContext = canvasRenderingContext-&gt;canvasBase().scriptExecutionContext();</span>
          if (!is&lt;Document&gt;(scriptExecutionContext))
              return false;
  
          // FIXME: &lt;https://webkit.org/b/168475&gt; Web Inspector: Correctly display iframe&#39;s WebSockets
          auto* document = downcast&lt;Document&gt;(scriptExecutionContext);
          return document-&gt;page() == &amp;m_inspectedPage;
      };
  
      {
          LockHolder lock(CanvasRenderingContext::instancesMutex());
<span class="line-modified">!         for (auto* canvasRenderingContext : CanvasRenderingContext::instances(lock)) {</span>
<span class="line-modified">!             if (canvasExistsInCurrentPage(canvasRenderingContext))</span>
<span class="line-modified">!                 bindCanvas(*canvasRenderingContext, false);</span>
          }
      }
  
  #if ENABLE(WEBGL)
      {
          LockHolder lock(WebGLProgram::instancesMutex());
<span class="line-modified">!         for (auto&amp; entry : WebGLProgram::instances(lock)) {</span>
<span class="line-modified">!             if (canvasExistsInCurrentPage(entry.value))</span>
<span class="line-modified">!                 didCreateProgram(*entry.value, *entry.key);</span>
          }
      }
  #endif
  }
  
  void InspectorCanvasAgent::disable(ErrorString&amp;)
  {
      m_instrumentingAgents.setInspectorCanvasAgent(nullptr);
  
<span class="line-modified">!     clearCanvasData();</span>
  
      m_recordingAutoCaptureFrameCount = WTF::nullopt;
  }
  
  void InspectorCanvasAgent::requestNode(ErrorString&amp; errorString, const String&amp; canvasId, int* nodeId)
<span class="line-new-header">--- 104,79 ---</span>
      disable(ignored);
  }
  
  void InspectorCanvasAgent::discardAgent()
  {
<span class="line-modified">!     reset();</span>
  }
  
  void InspectorCanvasAgent::enable(ErrorString&amp;)
  {
      if (m_instrumentingAgents.inspectorCanvasAgent() == this)
          return;
  
      m_instrumentingAgents.setInspectorCanvasAgent(this);
  
<span class="line-modified">!     const auto existsInCurrentPage = [&amp;] (ScriptExecutionContext* scriptExecutionContext) {</span>
          if (!is&lt;Document&gt;(scriptExecutionContext))
              return false;
  
          // FIXME: &lt;https://webkit.org/b/168475&gt; Web Inspector: Correctly display iframe&#39;s WebSockets
          auto* document = downcast&lt;Document&gt;(scriptExecutionContext);
          return document-&gt;page() == &amp;m_inspectedPage;
      };
  
      {
          LockHolder lock(CanvasRenderingContext::instancesMutex());
<span class="line-modified">!         for (auto* context : CanvasRenderingContext::instances(lock)) {</span>
<span class="line-modified">! #if ENABLE(WEBGPU)</span>
<span class="line-modified">!             // The actual &quot;context&quot; for WebGPU is the `WebGPUDevice`, not the &lt;canvas&gt;.</span>
<span class="line-added">+             if (is&lt;GPUCanvasContext&gt;(context))</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (existsInCurrentPage(context-&gt;canvasBase().scriptExecutionContext()))</span>
<span class="line-added">+                 bindCanvas(*context, false);</span>
          }
      }
  
<span class="line-added">+ #if ENABLE(WEBGPU)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         LockHolder lock(WebGPUDevice::instancesMutex());</span>
<span class="line-added">+         for (auto* device : WebGPUDevice::instances(lock)) {</span>
<span class="line-added">+             if (existsInCurrentPage(device-&gt;scriptExecutionContext()))</span>
<span class="line-added">+                 bindCanvas(*device, false);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  #if ENABLE(WEBGL)
      {
          LockHolder lock(WebGLProgram::instancesMutex());
<span class="line-modified">!         for (auto&amp; [program, contextWebGLBase] : WebGLProgram::instances(lock)) {</span>
<span class="line-modified">!             if (contextWebGLBase &amp;&amp; existsInCurrentPage(contextWebGLBase-&gt;canvasBase().scriptExecutionContext()))</span>
<span class="line-modified">!                 didCreateWebGLProgram(*contextWebGLBase, *program);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(WEBGPU)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         LockHolder lock(WebGPUPipeline::instancesMutex());</span>
<span class="line-added">+         for (auto&amp; [pipeline, device] : WebGPUPipeline::instances(lock)) {</span>
<span class="line-added">+             if (device &amp;&amp; existsInCurrentPage(device-&gt;scriptExecutionContext()) &amp;&amp; pipeline-&gt;isValid())</span>
<span class="line-added">+                 didCreateWebGPUPipeline(*device, *pipeline);</span>
          }
      }
  #endif
  }
  
  void InspectorCanvasAgent::disable(ErrorString&amp;)
  {
      m_instrumentingAgents.setInspectorCanvasAgent(nullptr);
  
<span class="line-modified">!     reset();</span>
  
      m_recordingAutoCaptureFrameCount = WTF::nullopt;
  }
  
  void InspectorCanvasAgent::requestNode(ErrorString&amp; errorString, const String&amp; canvasId, int* nodeId)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 172,58 ***</span>
          return;
  
      *content = inspectorCanvas-&gt;getCanvasContentAsDataURL(errorString);
  }
  
<span class="line-modified">! void InspectorCanvasAgent::requestCSSCanvasClientNodes(ErrorString&amp; errorString, const String&amp; canvasId, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; result)</span>
  {
      auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
      if (!inspectorCanvas)
          return;
  
<span class="line-modified">!     result = JSON::ArrayOf&lt;int&gt;::create();</span>
<span class="line-modified">!     for (auto* client : inspectorCanvas-&gt;context().canvasBase().cssCanvasClients()) {</span>
<span class="line-modified">!         if (int documentNodeId = m_instrumentingAgents.inspectorDOMAgent()-&gt;boundNodeId(&amp;client-&gt;document()))</span>
<span class="line-modified">!             result-&gt;addItem(m_instrumentingAgents.inspectorDOMAgent()-&gt;pushNodeToFrontend(errorString, documentNodeId, client));</span>
      }
  }
  
<span class="line-modified">! static JSC::JSValue contextAsScriptValue(JSC::ExecState&amp; state, CanvasRenderingContext&amp; context)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     JSC::JSLockHolder lock(&amp;state);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (is&lt;CanvasRenderingContext2D&gt;(context))</span>
<span class="line-removed">-         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;CanvasRenderingContext2D&gt;(context));</span>
<span class="line-removed">- #if ENABLE(WEBGL)</span>
<span class="line-removed">-     if (is&lt;WebGLRenderingContext&gt;(context))</span>
<span class="line-removed">-         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;WebGLRenderingContext&gt;(context));</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- #if ENABLE(WEBGL2)</span>
<span class="line-removed">-     if (is&lt;WebGL2RenderingContext&gt;(context))</span>
<span class="line-removed">-         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;WebGL2RenderingContext&gt;(context));</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- #if ENABLE(WEBGPU)</span>
<span class="line-removed">-     if (is&lt;GPUCanvasContext&gt;(context))</span>
<span class="line-removed">-         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;GPUCanvasContext&gt;(context));</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     if (is&lt;ImageBitmapRenderingContext&gt;(context))</span>
<span class="line-removed">-         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;ImageBitmapRenderingContext&gt;(context));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return { };</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void InspectorCanvasAgent::resolveCanvasContext(ErrorString&amp; errorString, const String&amp; canvasId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)</span>
  {
      auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
      if (!inspectorCanvas)
          return;
  
<span class="line-modified">!     auto&amp; state = *inspectorCanvas-&gt;context().canvasBase().scriptExecutionContext()-&gt;execState();</span>
<span class="line-modified">!     auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);</span>
      ASSERT(!injectedScript.hasNoValue());
  
<span class="line-modified">!     JSC::JSValue value = contextAsScriptValue(state, inspectorCanvas-&gt;context());</span>
      if (!value) {
          ASSERT_NOT_REACHED();
          errorString = &quot;Internal error: unknown context of canvas for given canvasId&quot;_s;
          return;
      }
<span class="line-new-header">--- 207,41 ---</span>
          return;
  
      *content = inspectorCanvas-&gt;getCanvasContentAsDataURL(errorString);
  }
  
<span class="line-modified">! void InspectorCanvasAgent::requestClientNodes(ErrorString&amp; errorString, const String&amp; canvasId, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; clientNodeIds)</span>
  {
<span class="line-added">+     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();</span>
<span class="line-added">+     if (!domAgent) {</span>
<span class="line-added">+         errorString = &quot;DOM domain must be enabled&quot;_s;</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
      if (!inspectorCanvas)
          return;
  
<span class="line-modified">!     clientNodeIds = JSON::ArrayOf&lt;int&gt;::create();</span>
<span class="line-modified">!     for (auto&amp; clientNode : inspectorCanvas-&gt;clientNodes()) {</span>
<span class="line-modified">!         if (auto documentNodeId = domAgent-&gt;boundNodeId(&amp;clientNode-&gt;document()))</span>
<span class="line-modified">!             clientNodeIds-&gt;addItem(domAgent-&gt;pushNodeToFrontend(errorString, documentNodeId, clientNode));</span>
      }
  }
  
<span class="line-modified">! void InspectorCanvasAgent::resolveContext(ErrorString&amp; errorString, const String&amp; canvasId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)</span>
  {
      auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
      if (!inspectorCanvas)
          return;
  
<span class="line-modified">!     auto* state = inspectorCanvas-&gt;scriptExecutionContext()-&gt;execState();</span>
<span class="line-modified">!     auto injectedScript = m_injectedScriptManager.injectedScriptFor(state);</span>
      ASSERT(!injectedScript.hasNoValue());
  
<span class="line-modified">!     JSC::JSValue value = inspectorCanvas-&gt;resolveContext(state);</span>
<span class="line-added">+ </span>
      if (!value) {
          ASSERT_NOT_REACHED();
          errorString = &quot;Internal error: unknown context of canvas for given canvasId&quot;_s;
          return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,11 ***</span>
  {
      auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
      if (!inspectorCanvas)
          return;
  
<span class="line-modified">!     if (inspectorCanvas-&gt;context().callTracingActive()) {</span>
          errorString = &quot;Already recording canvas&quot;_s;
          return;
      }
  
      RecordingOptions recordingOptions;
<span class="line-new-header">--- 262,17 ---</span>
  {
      auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
      if (!inspectorCanvas)
          return;
  
<span class="line-modified">!     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* context = inspectorCanvas-&gt;canvasContext();</span>
<span class="line-added">+     if (!context)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (context-&gt;callTracingActive()) {</span>
          errorString = &quot;Already recording canvas&quot;_s;
          return;
      }
  
      RecordingOptions recordingOptions;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 263,105 ***</span>
  {
      auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
      if (!inspectorCanvas)
          return;
  
<span class="line-modified">!     if (!inspectorCanvas-&gt;context().callTracingActive()) {</span>
          errorString = &quot;Not recording canvas&quot;_s;
          return;
      }
  
<span class="line-modified">!     didFinishRecordingCanvasFrame(inspectorCanvas-&gt;context(), true);</span>
  }
  
<span class="line-modified">! void InspectorCanvasAgent::requestShaderSource(ErrorString&amp; errorString, const String&amp; programId, const String&amp; shaderType, String* content)</span>
  {
<span class="line-removed">- #if ENABLE(WEBGL)</span>
      auto inspectorProgram = assertInspectorProgram(errorString, programId);
      if (!inspectorProgram)
          return;
  
<span class="line-modified">!     auto* shader = inspectorProgram-&gt;shaderForType(shaderType);</span>
<span class="line-modified">!     if (!shader) {</span>
<span class="line-modified">!         errorString = &quot;Missing shader for given shaderType&quot;_s;</span>
          return;
      }
  
<span class="line-modified">!     *content = shader-&gt;getSource();</span>
<span class="line-modified">! #else</span>
<span class="line-modified">!     UNUSED_PARAM(programId);</span>
<span class="line-modified">!     UNUSED_PARAM(shaderType);</span>
<span class="line-modified">!     UNUSED_PARAM(content);</span>
<span class="line-modified">!     errorString = &quot;Not supported&quot;_s;</span>
<span class="line-modified">! #endif</span>
  }
  
<span class="line-modified">! void InspectorCanvasAgent::updateShader(ErrorString&amp; errorString, const String&amp; programId, const String&amp; shaderType, const String&amp; source)</span>
  {
<span class="line-removed">- #if ENABLE(WEBGL)</span>
      auto inspectorProgram = assertInspectorProgram(errorString, programId);
      if (!inspectorProgram)
          return;
  
<span class="line-modified">!     auto* shader = inspectorProgram-&gt;shaderForType(shaderType);</span>
<span class="line-modified">!     if (!shader) {</span>
<span class="line-modified">!         errorString = &quot;Missing shader for given shaderType&quot;_s;</span>
          return;
      }
  
<span class="line-modified">!     WebGLRenderingContextBase&amp; contextWebGL = inspectorProgram-&gt;context();</span>
<span class="line-modified">!     contextWebGL.shaderSource(shader, source);</span>
<span class="line-removed">-     contextWebGL.compileShader(shader);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!shader-&gt;isValid()) {</span>
<span class="line-removed">-         errorString = &quot;Failed to update shader&quot;_s;</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     contextWebGL.linkProgramWithoutInvalidatingAttribLocations(&amp;inspectorProgram-&gt;program());</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     UNUSED_PARAM(programId);</span>
<span class="line-removed">-     UNUSED_PARAM(shaderType);</span>
<span class="line-removed">-     UNUSED_PARAM(source);</span>
<span class="line-removed">-     errorString = &quot;Not supported&quot;_s;</span>
<span class="line-removed">- #endif</span>
  }
  
  void InspectorCanvasAgent::setShaderProgramDisabled(ErrorString&amp; errorString, const String&amp; programId, bool disabled)
  {
<span class="line-removed">- #if ENABLE(WEBGL)</span>
      auto inspectorProgram = assertInspectorProgram(errorString, programId);
      if (!inspectorProgram)
          return;
  
      inspectorProgram-&gt;setDisabled(disabled);
<span class="line-removed">- #else</span>
<span class="line-removed">-     UNUSED_PARAM(programId);</span>
<span class="line-removed">-     UNUSED_PARAM(disabled);</span>
<span class="line-removed">-     errorString = &quot;Not supported&quot;_s;</span>
<span class="line-removed">- #endif</span>
  }
  
  void InspectorCanvasAgent::setShaderProgramHighlighted(ErrorString&amp; errorString, const String&amp; programId, bool highlighted)
  {
<span class="line-removed">- #if ENABLE(WEBGL)</span>
      auto inspectorProgram = assertInspectorProgram(errorString, programId);
      if (!inspectorProgram)
          return;
  
      inspectorProgram-&gt;setHighlighted(highlighted);
<span class="line-removed">- #else</span>
<span class="line-removed">-     UNUSED_PARAM(programId);</span>
<span class="line-removed">-     UNUSED_PARAM(highlighted);</span>
<span class="line-removed">-     errorString = &quot;Not supported&quot;_s;</span>
<span class="line-removed">- #endif</span>
  }
  
  void InspectorCanvasAgent::frameNavigated(Frame&amp; frame)
  {
      if (frame.isMainFrame()) {
<span class="line-modified">!         clearCanvasData();</span>
          return;
      }
  
      Vector&lt;InspectorCanvas*&gt; inspectorCanvases;
      for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {
<span class="line-new-header">--- 287,83 ---</span>
  {
      auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
      if (!inspectorCanvas)
          return;
  
<span class="line-modified">!     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* context = inspectorCanvas-&gt;canvasContext();</span>
<span class="line-added">+     if (!context)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!context-&gt;callTracingActive()) {</span>
          errorString = &quot;Not recording canvas&quot;_s;
          return;
      }
  
<span class="line-modified">!     didFinishRecordingCanvasFrame(*context, true);</span>
  }
  
<span class="line-modified">! void InspectorCanvasAgent::requestShaderSource(ErrorString&amp; errorString, const String&amp; programId, const String&amp; shaderTypeString, String* outSource)</span>
  {
      auto inspectorProgram = assertInspectorProgram(errorString, programId);
      if (!inspectorProgram)
          return;
  
<span class="line-modified">!     auto shaderType = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::Canvas::ShaderType&gt;(shaderTypeString);</span>
<span class="line-modified">!     if (!shaderType) {</span>
<span class="line-modified">!         errorString = makeString(&quot;Unknown shaderType: &quot;_s, shaderTypeString);</span>
          return;
      }
  
<span class="line-modified">!     auto source = inspectorProgram-&gt;requestShaderSource(shaderType.value());</span>
<span class="line-modified">!     if (!source) {</span>
<span class="line-modified">!         errorString = &quot;Missing shader of given shaderType for given programId&quot;_s;</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     *outSource = source;</span>
  }
  
<span class="line-modified">! void InspectorCanvasAgent::updateShader(ErrorString&amp; errorString, const String&amp; programId, const String&amp; shaderTypeString, const String&amp; source)</span>
  {
      auto inspectorProgram = assertInspectorProgram(errorString, programId);
      if (!inspectorProgram)
          return;
  
<span class="line-modified">!     auto shaderType = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::Canvas::ShaderType&gt;(shaderTypeString);</span>
<span class="line-modified">!     if (!shaderType) {</span>
<span class="line-modified">!         errorString = makeString(&quot;Unknown shaderType: &quot;_s, shaderTypeString);</span>
          return;
      }
  
<span class="line-modified">!     if (!inspectorProgram-&gt;updateShader(shaderType.value(), source))</span>
<span class="line-modified">!         errorString = &quot;Failed to update shader of given shaderType for given programId&quot;_s;</span>
  }
  
  void InspectorCanvasAgent::setShaderProgramDisabled(ErrorString&amp; errorString, const String&amp; programId, bool disabled)
  {
      auto inspectorProgram = assertInspectorProgram(errorString, programId);
      if (!inspectorProgram)
          return;
  
      inspectorProgram-&gt;setDisabled(disabled);
  }
  
  void InspectorCanvasAgent::setShaderProgramHighlighted(ErrorString&amp; errorString, const String&amp; programId, bool highlighted)
  {
      auto inspectorProgram = assertInspectorProgram(errorString, programId);
      if (!inspectorProgram)
          return;
  
      inspectorProgram-&gt;setHighlighted(highlighted);
  }
  
  void InspectorCanvasAgent::frameNavigated(Frame&amp; frame)
  {
      if (frame.isMainFrame()) {
<span class="line-modified">!         reset();</span>
          return;
      }
  
      Vector&lt;InspectorCanvas*&gt; inspectorCanvases;
      for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 369,14 ***</span>
              if (canvasElement-&gt;document().frame() == &amp;frame)
                  inspectorCanvases.append(inspectorCanvas.get());
          }
      }
  
<span class="line-modified">!     for (auto* inspectorCanvas : inspectorCanvases) {</span>
<span class="line-modified">!         String identifier = unbindCanvas(*inspectorCanvas);</span>
<span class="line-removed">-         m_frontendDispatcher-&gt;canvasRemoved(identifier);</span>
<span class="line-removed">-     }</span>
  }
  
  void InspectorCanvasAgent::didChangeCSSCanvasClientNodes(CanvasBase&amp; canvasBase)
  {
      auto* context = canvasBase.renderingContext();
<span class="line-new-header">--- 371,12 ---</span>
              if (canvasElement-&gt;document().frame() == &amp;frame)
                  inspectorCanvases.append(inspectorCanvas.get());
          }
      }
  
<span class="line-modified">!     for (auto* inspectorCanvas : inspectorCanvases)</span>
<span class="line-modified">!         unbindCanvas(*inspectorCanvas);</span>
  }
  
  void InspectorCanvasAgent::didChangeCSSCanvasClientNodes(CanvasBase&amp; canvasBase)
  {
      auto* context = canvasBase.renderingContext();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 388,11 ***</span>
      auto inspectorCanvas = findInspectorCanvas(*context);
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
<span class="line-modified">!     m_frontendDispatcher-&gt;cssCanvasClientNodesChanged(inspectorCanvas-&gt;identifier());</span>
  }
  
  void InspectorCanvasAgent::didCreateCanvasRenderingContext(CanvasRenderingContext&amp; context)
  {
      if (findInspectorCanvas(context)) {
<span class="line-new-header">--- 388,11 ---</span>
      auto inspectorCanvas = findInspectorCanvas(*context);
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
<span class="line-modified">!     m_frontendDispatcher-&gt;clientNodesChanged(inspectorCanvas-&gt;identifier());</span>
  }
  
  void InspectorCanvasAgent::didCreateCanvasRenderingContext(CanvasRenderingContext&amp; context)
  {
      if (findInspectorCanvas(context)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 409,11 ***</span>
      }
  }
  
  void InspectorCanvasAgent::didChangeCanvasMemory(CanvasRenderingContext&amp; context)
  {
<span class="line-modified">!     auto inspectorCanvas = findInspectorCanvas(context);</span>
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
      // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations
<span class="line-new-header">--- 409,26 ---</span>
      }
  }
  
  void InspectorCanvasAgent::didChangeCanvasMemory(CanvasRenderingContext&amp; context)
  {
<span class="line-modified">!     RefPtr&lt;InspectorCanvas&gt; inspectorCanvas;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(WEBGPU)</span>
<span class="line-added">+     if (is&lt;GPUCanvasContext&gt;(context)) {</span>
<span class="line-added">+         for (auto&amp; item : m_identifierToInspectorCanvas.values()) {</span>
<span class="line-added">+             if (item-&gt;isDeviceForCanvasContext(context)) {</span>
<span class="line-added">+                 inspectorCanvas = item;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!inspectorCanvas)</span>
<span class="line-added">+         inspectorCanvas = findInspectorCanvas(context);</span>
<span class="line-added">+ </span>
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
      // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations
</pre>
<hr />
<pre>
<span class="line-old-header">*** 431,31 ***</span>
  
      ASSERT(canvasRenderingContext.callTracingActive());
      if (!canvasRenderingContext.callTracingActive())
          return;
  
<span class="line-modified">!     // Only enqueue a microtask for the first action of each frame. Any subsequent actions will be</span>
<span class="line-modified">!     // covered by the initial microtask until the next frame.</span>
<span class="line-modified">!     if (!inspectorCanvas-&gt;currentFrameHasData()) {</span>
<span class="line-modified">!         if (auto* scriptExecutionContext = inspectorCanvas-&gt;context().canvasBase().scriptExecutionContext()) {</span>
<span class="line-modified">!             auto&amp; queue = MicrotaskQueue::mainThreadQueue();</span>
<span class="line-modified">!             queue.append(makeUnique&lt;ActiveDOMCallbackMicrotask&gt;(queue, *scriptExecutionContext, [&amp;, protectedInspectorCanvas = inspectorCanvas.copyRef()] {</span>
<span class="line-modified">!                 if (auto* canvasElement = protectedInspectorCanvas-&gt;canvasElement()) {</span>
<span class="line-modified">!                     if (canvasElement-&gt;isDescendantOf(canvasElement-&gt;document()))</span>
<span class="line-modified">!                         return;</span>
                  }
  
<span class="line-modified">!                 if (protectedInspectorCanvas-&gt;context().callTracingActive())</span>
<span class="line-modified">!                     didFinishRecordingCanvasFrame(protectedInspectorCanvas-&gt;context());</span>
<span class="line-removed">-             }));</span>
          }
      }
  
      inspectorCanvas-&gt;recordAction(name, WTFMove(parameters));
  
      if (!inspectorCanvas-&gt;hasBufferSpace())
<span class="line-modified">!         didFinishRecordingCanvasFrame(inspectorCanvas-&gt;context(), true);</span>
  }
  
  void InspectorCanvasAgent::canvasChanged(CanvasBase&amp; canvasBase, const FloatRect&amp;)
  {
      auto* context = canvasBase.renderingContext();
<span class="line-new-header">--- 446,44 ---</span>
  
      ASSERT(canvasRenderingContext.callTracingActive());
      if (!canvasRenderingContext.callTracingActive())
          return;
  
<span class="line-modified">!     // Only enqueue one microtask for all actively recording canvases.</span>
<span class="line-modified">!     if (m_recordingCanvasIdentifiers.isEmpty()) {</span>
<span class="line-modified">!         if (auto* scriptExecutionContext = inspectorCanvas-&gt;scriptExecutionContext()) {</span>
<span class="line-modified">!             scriptExecutionContext-&gt;eventLoop().queueMicrotask([weakThis = makeWeakPtr(*this)] {</span>
<span class="line-modified">!                 if (!weakThis)</span>
<span class="line-modified">!                     return;</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 auto&amp; canvasAgent = *weakThis;</span>
<span class="line-modified">! </span>
<span class="line-added">+                 auto identifiers = copyToVector(canvasAgent.m_recordingCanvasIdentifiers);</span>
<span class="line-added">+                 for (auto&amp; identifier : identifiers) {</span>
<span class="line-added">+                     auto inspectorCanvas = canvasAgent.m_identifierToInspectorCanvas.get(identifier);</span>
<span class="line-added">+                     if (!inspectorCanvas)</span>
<span class="line-added">+                         continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+                     auto* canvasRenderingContext = inspectorCanvas-&gt;canvasContext();</span>
<span class="line-added">+                     ASSERT(canvasRenderingContext);</span>
<span class="line-added">+                     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if (canvasRenderingContext-&gt;callTracingActive())</span>
<span class="line-added">+                         canvasAgent.didFinishRecordingCanvasFrame(*canvasRenderingContext);</span>
                  }
  
<span class="line-modified">!                 canvasAgent.m_recordingCanvasIdentifiers.clear();</span>
<span class="line-modified">!             });</span>
          }
      }
  
<span class="line-added">+     m_recordingCanvasIdentifiers.add(inspectorCanvas-&gt;identifier());</span>
<span class="line-added">+ </span>
      inspectorCanvas-&gt;recordAction(name, WTFMove(parameters));
  
      if (!inspectorCanvas-&gt;hasBufferSpace())
<span class="line-modified">!         didFinishRecordingCanvasFrame(canvasRenderingContext, true);</span>
  }
  
  void InspectorCanvasAgent::canvasChanged(CanvasBase&amp; canvasBase, const FloatRect&amp;)
  {
      auto* context = canvasBase.renderingContext();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 479,35 ***</span>
      auto inspectorCanvas = findInspectorCanvas(*context);
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
<span class="line-modified">!     String identifier = unbindCanvas(*inspectorCanvas);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // WebCore::CanvasObserver::canvasDestroyed is called in response to the GC destroying the CanvasBase.</span>
<span class="line-removed">-     // Due to the single-process model used in WebKit1, the event must be dispatched from a timer to prevent</span>
<span class="line-removed">-     // the frontend from making JS allocations while the GC is still active.</span>
<span class="line-removed">-     m_removedCanvasIdentifiers.append(identifier);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!m_canvasDestroyedTimer.isActive())</span>
<span class="line-removed">-         m_canvasDestroyedTimer.startOneShot(0_s);</span>
  }
  
  void InspectorCanvasAgent::didFinishRecordingCanvasFrame(CanvasRenderingContext&amp; context, bool forceDispatch)
  {
      auto inspectorCanvas = findInspectorCanvas(context);
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
<span class="line-removed">-     if (!inspectorCanvas-&gt;context().callTracingActive())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
      if (!inspectorCanvas-&gt;hasRecordingData()) {
          if (forceDispatch) {
              m_frontendDispatcher-&gt;recordingFinished(inspectorCanvas-&gt;identifier(), nullptr);
              inspectorCanvas-&gt;resetRecordingData();
          }
          return;
      }
  
      if (forceDispatch)
<span class="line-new-header">--- 507,28 ---</span>
      auto inspectorCanvas = findInspectorCanvas(*context);
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
<span class="line-modified">!     unbindCanvas(*inspectorCanvas);</span>
  }
  
  void InspectorCanvasAgent::didFinishRecordingCanvasFrame(CanvasRenderingContext&amp; context, bool forceDispatch)
  {
<span class="line-added">+     if (!context.callTracingActive())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
      auto inspectorCanvas = findInspectorCanvas(context);
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
      if (!inspectorCanvas-&gt;hasRecordingData()) {
          if (forceDispatch) {
              m_frontendDispatcher-&gt;recordingFinished(inspectorCanvas-&gt;identifier(), nullptr);
              inspectorCanvas-&gt;resetRecordingData();
<span class="line-added">+             ASSERT(!m_recordingCanvasIdentifiers.contains(inspectorCanvas-&gt;identifier()));</span>
          }
          return;
      }
  
      if (forceDispatch)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 519,13 ***</span>
  
      if (!forceDispatch &amp;&amp; !inspectorCanvas-&gt;overFrameCount())
          return;
  
      m_frontendDispatcher-&gt;recordingFinished(inspectorCanvas-&gt;identifier(), inspectorCanvas-&gt;releaseObjectForRecording());
  }
  
<span class="line-modified">! void InspectorCanvasAgent::consoleStartRecordingCanvas(CanvasRenderingContext&amp; context, JSC::ExecState&amp; exec, JSC::JSObject* options)</span>
  {
      auto inspectorCanvas = findInspectorCanvas(context);
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
<span class="line-new-header">--- 540,15 ---</span>
  
      if (!forceDispatch &amp;&amp; !inspectorCanvas-&gt;overFrameCount())
          return;
  
      m_frontendDispatcher-&gt;recordingFinished(inspectorCanvas-&gt;identifier(), inspectorCanvas-&gt;releaseObjectForRecording());
<span class="line-added">+ </span>
<span class="line-added">+     m_recordingCanvasIdentifiers.remove(inspectorCanvas-&gt;identifier());</span>
  }
  
<span class="line-modified">! void InspectorCanvasAgent::consoleStartRecordingCanvas(CanvasRenderingContext&amp; context, JSC::JSGlobalObject&amp; exec, JSC::JSObject* options)</span>
  {
      auto inspectorCanvas = findInspectorCanvas(context);
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 543,10 ***</span>
<span class="line-new-header">--- 566,15 ---</span>
              recordingOptions.name = optionName.toWTFString(&amp;exec);
      }
      startRecording(*inspectorCanvas, Inspector::Protocol::Recording::Initiator::Console, WTFMove(recordingOptions));
  }
  
<span class="line-added">+ void InspectorCanvasAgent::consoleStopRecordingCanvas(CanvasRenderingContext&amp; context)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     didFinishRecordingCanvasFrame(context, true);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #if ENABLE(WEBGL)
  void InspectorCanvasAgent::didEnableExtension(WebGLRenderingContextBase&amp; context, const String&amp; extension)
  {
      auto inspectorCanvas = findInspectorCanvas(context);
      ASSERT(inspectorCanvas);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 554,79 ***</span>
          return;
  
      m_frontendDispatcher-&gt;extensionEnabled(inspectorCanvas-&gt;identifier(), extension);
  }
  
<span class="line-modified">! void InspectorCanvasAgent::didCreateProgram(WebGLRenderingContextBase&amp; context, WebGLProgram&amp; program)</span>
  {
      auto inspectorCanvas = findInspectorCanvas(context);
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
<span class="line-modified">!     auto inspectorProgram = InspectorShaderProgram::create(program, *inspectorCanvas);</span>
<span class="line-modified">!     String programIdentifier = inspectorProgram-&gt;identifier();</span>
<span class="line-modified">!     m_identifierToInspectorProgram.set(programIdentifier, WTFMove(inspectorProgram));</span>
<span class="line-modified">!     m_frontendDispatcher-&gt;programCreated(inspectorCanvas-&gt;identifier(), programIdentifier);</span>
  }
  
<span class="line-modified">! void InspectorCanvasAgent::willDeleteProgram(WebGLProgram&amp; program)</span>
  {
      auto inspectorProgram = findInspectorProgram(program);
      if (!inspectorProgram)
          return;
  
<span class="line-modified">!     String identifier = unbindProgram(*inspectorProgram);</span>
<span class="line-removed">-     m_frontendDispatcher-&gt;programDeleted(identifier);</span>
  }
  
<span class="line-modified">! bool InspectorCanvasAgent::isShaderProgramDisabled(WebGLProgram&amp; program)</span>
  {
      auto inspectorProgram = findInspectorProgram(program);
      ASSERT(inspectorProgram);
      if (!inspectorProgram)
          return false;
  
      return inspectorProgram-&gt;disabled();
  }
  
<span class="line-modified">! bool InspectorCanvasAgent::isShaderProgramHighlighted(WebGLProgram&amp; program)</span>
  {
      auto inspectorProgram = findInspectorProgram(program);
      ASSERT(inspectorProgram);
      if (!inspectorProgram)
          return false;
  
      return inspectorProgram-&gt;highlighted();
  }
  #endif
  
  void InspectorCanvasAgent::startRecording(InspectorCanvas&amp; inspectorCanvas, Inspector::Protocol::Recording::Initiator initiator, RecordingOptions&amp;&amp; recordingOptions)
  {
<span class="line-modified">!     auto&amp; canvasRenderingContext = inspectorCanvas.context();</span>
  
<span class="line-modified">!     if (!is&lt;CanvasRenderingContext2D&gt;(canvasRenderingContext)</span>
  #if ENABLE(WEBGL)
<span class="line-modified">!         &amp;&amp; !is&lt;WebGLRenderingContext&gt;(canvasRenderingContext)</span>
  #endif
  #if ENABLE(WEBGL2)
<span class="line-modified">!         &amp;&amp; !is&lt;WebGL2RenderingContext&gt;(canvasRenderingContext)</span>
  #endif
<span class="line-modified">!         &amp;&amp; !is&lt;ImageBitmapRenderingContext&gt;(canvasRenderingContext))</span>
          return;
  
<span class="line-modified">!     if (canvasRenderingContext.callTracingActive())</span>
          return;
  
      inspectorCanvas.resetRecordingData();
      if (recordingOptions.frameCount)
          inspectorCanvas.setFrameCount(recordingOptions.frameCount.value());
      if (recordingOptions.memoryLimit)
          inspectorCanvas.setBufferLimit(recordingOptions.memoryLimit.value());
      if (recordingOptions.name)
          inspectorCanvas.setRecordingName(recordingOptions.name.value());
<span class="line-modified">!     canvasRenderingContext.setCallTracingActive(true);</span>
  
      m_frontendDispatcher-&gt;recordingStarted(inspectorCanvas.identifier(), initiator);
  }
  
  void InspectorCanvasAgent::canvasDestroyedTimerFired()
<span class="line-new-header">--- 582,144 ---</span>
          return;
  
      m_frontendDispatcher-&gt;extensionEnabled(inspectorCanvas-&gt;identifier(), extension);
  }
  
<span class="line-modified">! void InspectorCanvasAgent::didCreateWebGLProgram(WebGLRenderingContextBase&amp; context, WebGLProgram&amp; program)</span>
  {
      auto inspectorCanvas = findInspectorCanvas(context);
      ASSERT(inspectorCanvas);
      if (!inspectorCanvas)
          return;
  
<span class="line-modified">!     auto inspectorProgramRef = InspectorShaderProgram::create(program, *inspectorCanvas);</span>
<span class="line-modified">!     auto&amp; inspectorProgram = inspectorProgramRef.get();</span>
<span class="line-modified">!     m_identifierToInspectorProgram.set(inspectorProgram.identifier(), WTFMove(inspectorProgramRef));</span>
<span class="line-modified">!     m_frontendDispatcher-&gt;programCreated(inspectorProgram.buildObjectForShaderProgram());</span>
  }
  
<span class="line-modified">! void InspectorCanvasAgent::willDestroyWebGLProgram(WebGLProgram&amp; program)</span>
  {
      auto inspectorProgram = findInspectorProgram(program);
      if (!inspectorProgram)
          return;
  
<span class="line-modified">!     unbindProgram(*inspectorProgram);</span>
  }
  
<span class="line-modified">! bool InspectorCanvasAgent::isWebGLProgramDisabled(WebGLProgram&amp; program)</span>
  {
      auto inspectorProgram = findInspectorProgram(program);
      ASSERT(inspectorProgram);
      if (!inspectorProgram)
          return false;
  
      return inspectorProgram-&gt;disabled();
  }
  
<span class="line-modified">! bool InspectorCanvasAgent::isWebGLProgramHighlighted(WebGLProgram&amp; program)</span>
  {
      auto inspectorProgram = findInspectorProgram(program);
      ASSERT(inspectorProgram);
      if (!inspectorProgram)
          return false;
  
      return inspectorProgram-&gt;highlighted();
  }
  #endif
  
<span class="line-added">+ #if ENABLE(WEBGPU)</span>
<span class="line-added">+ void InspectorCanvasAgent::didCreateWebGPUDevice(WebGPUDevice&amp; device)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (findInspectorCanvas(device)) {</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     bindCanvas(device, true);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void InspectorCanvasAgent::willDestroyWebGPUDevice(WebGPUDevice&amp; device)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto inspectorCanvas = findInspectorCanvas(device);</span>
<span class="line-added">+     ASSERT(inspectorCanvas);</span>
<span class="line-added">+     if (!inspectorCanvas)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     unbindCanvas(*inspectorCanvas);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void InspectorCanvasAgent::willConfigureSwapChain(GPUCanvasContext&amp; contextGPU, WebGPUSwapChain&amp; newSwapChain)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto notifyDeviceForSwapChain = [&amp;] (WebGPUSwapChain&amp; webGPUSwapChain) {</span>
<span class="line-added">+         for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {</span>
<span class="line-added">+             if (auto* device = inspectorCanvas-&gt;deviceContext()) {</span>
<span class="line-added">+                 if (device-&gt;device().swapChain() == webGPUSwapChain.swapChain())</span>
<span class="line-added">+                     m_frontendDispatcher-&gt;clientNodesChanged(inspectorCanvas-&gt;identifier());</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (auto* existingSwapChain = contextGPU.swapChain())</span>
<span class="line-added">+         notifyDeviceForSwapChain(*existingSwapChain);</span>
<span class="line-added">+ </span>
<span class="line-added">+     notifyDeviceForSwapChain(newSwapChain);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void InspectorCanvasAgent::didCreateWebGPUPipeline(WebGPUDevice&amp; device, WebGPUPipeline&amp; pipeline)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto inspectorCanvas = findInspectorCanvas(device);</span>
<span class="line-added">+     ASSERT(inspectorCanvas);</span>
<span class="line-added">+     if (!inspectorCanvas)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(pipeline.isValid());</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto inspectorProgramRef = InspectorShaderProgram::create(pipeline, *inspectorCanvas);</span>
<span class="line-added">+     auto&amp; inspectorProgram = inspectorProgramRef.get();</span>
<span class="line-added">+     m_identifierToInspectorProgram.set(inspectorProgram.identifier(), WTFMove(inspectorProgramRef));</span>
<span class="line-added">+     m_frontendDispatcher-&gt;programCreated(inspectorProgram.buildObjectForShaderProgram());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void InspectorCanvasAgent::willDestroyWebGPUPipeline(WebGPUPipeline&amp; pipeline)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto inspectorProgram = findInspectorProgram(pipeline);</span>
<span class="line-added">+     if (!inspectorProgram)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     unbindProgram(*inspectorProgram);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  void InspectorCanvasAgent::startRecording(InspectorCanvas&amp; inspectorCanvas, Inspector::Protocol::Recording::Initiator initiator, RecordingOptions&amp;&amp; recordingOptions)
  {
<span class="line-modified">!     auto* context = inspectorCanvas.canvasContext();</span>
<span class="line-added">+     ASSERT(context);</span>
<span class="line-added">+     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice</span>
  
<span class="line-modified">!     if (!is&lt;CanvasRenderingContext2D&gt;(context)</span>
<span class="line-added">+         &amp;&amp; !is&lt;ImageBitmapRenderingContext&gt;(context)</span>
  #if ENABLE(WEBGL)
<span class="line-modified">!         &amp;&amp; !is&lt;WebGLRenderingContext&gt;(context)</span>
  #endif
  #if ENABLE(WEBGL2)
<span class="line-modified">!         &amp;&amp; !is&lt;WebGL2RenderingContext&gt;(context)</span>
  #endif
<span class="line-modified">!     )</span>
          return;
  
<span class="line-modified">!     if (context-&gt;callTracingActive())</span>
          return;
  
      inspectorCanvas.resetRecordingData();
      if (recordingOptions.frameCount)
          inspectorCanvas.setFrameCount(recordingOptions.frameCount.value());
      if (recordingOptions.memoryLimit)
          inspectorCanvas.setBufferLimit(recordingOptions.memoryLimit.value());
      if (recordingOptions.name)
          inspectorCanvas.setRecordingName(recordingOptions.name.value());
<span class="line-modified">!     context-&gt;setCallTracingActive(true);</span>
  
      m_frontendDispatcher-&gt;recordingStarted(inspectorCanvas.identifier(), initiator);
  }
  
  void InspectorCanvasAgent::canvasDestroyedTimerFired()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 638,37 ***</span>
          m_frontendDispatcher-&gt;canvasRemoved(identifier);
  
      m_removedCanvasIdentifiers.clear();
  }
  
<span class="line-modified">! void InspectorCanvasAgent::clearCanvasData()</span>
  {
<span class="line-modified">!     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values())</span>
<span class="line-modified">!         inspectorCanvas-&gt;context().canvasBase().removeObserver(*this);</span>
  
      m_identifierToInspectorCanvas.clear();
<span class="line-removed">- #if ENABLE(WEBGL)</span>
<span class="line-removed">-     m_identifierToInspectorProgram.clear();</span>
      m_removedCanvasIdentifiers.clear();
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
      if (m_canvasDestroyedTimer.isActive())
          m_canvasDestroyedTimer.stop();
  }
  
  InspectorCanvas&amp; InspectorCanvasAgent::bindCanvas(CanvasRenderingContext&amp; context, bool captureBacktrace)
  {
      auto inspectorCanvas = InspectorCanvas::create(context);
      m_identifierToInspectorCanvas.set(inspectorCanvas-&gt;identifier(), inspectorCanvas.copyRef());
  
<span class="line-modified">!     inspectorCanvas-&gt;context().canvasBase().addObserver(*this);</span>
  
      m_frontendDispatcher-&gt;canvasAdded(inspectorCanvas-&gt;buildObjectForCanvas(captureBacktrace));
  
  #if ENABLE(WEBGL)
<span class="line-modified">!     if (is&lt;WebGLRenderingContextBase&gt;(inspectorCanvas-&gt;context())) {</span>
<span class="line-modified">!         WebGLRenderingContextBase&amp; contextWebGL = downcast&lt;WebGLRenderingContextBase&gt;(inspectorCanvas-&gt;context());</span>
          if (Optional&lt;Vector&lt;String&gt;&gt; extensions = contextWebGL.getSupportedExtensions()) {
              for (const String&amp; extension : *extensions) {
                  if (contextWebGL.extensionIsEnabled(extension))
                      m_frontendDispatcher-&gt;extensionEnabled(inspectorCanvas-&gt;identifier(), extension);
              }
<span class="line-new-header">--- 731,53 ---</span>
          m_frontendDispatcher-&gt;canvasRemoved(identifier);
  
      m_removedCanvasIdentifiers.clear();
  }
  
<span class="line-modified">! void InspectorCanvasAgent::programDestroyedTimerFired()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_removedProgramIdentifiers.size())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto&amp; identifier : m_removedProgramIdentifiers)</span>
<span class="line-added">+         m_frontendDispatcher-&gt;programDeleted(identifier);</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_removedProgramIdentifiers.clear();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void InspectorCanvasAgent::reset()</span>
  {
<span class="line-modified">!     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {</span>
<span class="line-modified">!         if (auto* context = inspectorCanvas-&gt;canvasContext())</span>
<span class="line-added">+             context-&gt;canvasBase().removeObserver(*this);</span>
<span class="line-added">+     }</span>
  
      m_identifierToInspectorCanvas.clear();
      m_removedCanvasIdentifiers.clear();
      if (m_canvasDestroyedTimer.isActive())
          m_canvasDestroyedTimer.stop();
<span class="line-added">+ </span>
<span class="line-added">+     m_identifierToInspectorProgram.clear();</span>
<span class="line-added">+     m_removedProgramIdentifiers.clear();</span>
<span class="line-added">+     if (m_programDestroyedTimer.isActive())</span>
<span class="line-added">+         m_programDestroyedTimer.stop();</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_recordingCanvasIdentifiers.clear();</span>
  }
  
  InspectorCanvas&amp; InspectorCanvasAgent::bindCanvas(CanvasRenderingContext&amp; context, bool captureBacktrace)
  {
      auto inspectorCanvas = InspectorCanvas::create(context);
      m_identifierToInspectorCanvas.set(inspectorCanvas-&gt;identifier(), inspectorCanvas.copyRef());
  
<span class="line-modified">!     context.canvasBase().addObserver(*this);</span>
  
      m_frontendDispatcher-&gt;canvasAdded(inspectorCanvas-&gt;buildObjectForCanvas(captureBacktrace));
  
  #if ENABLE(WEBGL)
<span class="line-modified">!     if (is&lt;WebGLRenderingContextBase&gt;(context)) {</span>
<span class="line-modified">!         auto&amp; contextWebGL = downcast&lt;WebGLRenderingContextBase&gt;(context);</span>
          if (Optional&lt;Vector&lt;String&gt;&gt; extensions = contextWebGL.getSupportedExtensions()) {
              for (const String&amp; extension : *extensions) {
                  if (contextWebGL.extensionIsEnabled(extension))
                      m_frontendDispatcher-&gt;extensionEnabled(inspectorCanvas-&gt;identifier(), extension);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 677,11 ***</span>
  #endif
  
      return inspectorCanvas;
  }
  
<span class="line-modified">! String InspectorCanvasAgent::unbindCanvas(InspectorCanvas&amp; inspectorCanvas)</span>
  {
  #if ENABLE(WEBGL)
      Vector&lt;InspectorShaderProgram*&gt; programsToRemove;
      for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {
          if (&amp;inspectorProgram-&gt;canvas() == &amp;inspectorCanvas)
<span class="line-new-header">--- 786,23 ---</span>
  #endif
  
      return inspectorCanvas;
  }
  
<span class="line-modified">! #if ENABLE(WEBGPU)</span>
<span class="line-added">+ InspectorCanvas&amp; InspectorCanvasAgent::bindCanvas(WebGPUDevice&amp; device, bool captureBacktrace)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto inspectorCanvas = InspectorCanvas::create(device);</span>
<span class="line-added">+     m_identifierToInspectorCanvas.set(inspectorCanvas-&gt;identifier(), inspectorCanvas.copyRef());</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_frontendDispatcher-&gt;canvasAdded(inspectorCanvas-&gt;buildObjectForCanvas(captureBacktrace));</span>
<span class="line-added">+ </span>
<span class="line-added">+     return inspectorCanvas;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ void InspectorCanvasAgent::unbindCanvas(InspectorCanvas&amp; inspectorCanvas)</span>
  {
  #if ENABLE(WEBGL)
      Vector&lt;InspectorShaderProgram*&gt; programsToRemove;
      for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {
          if (&amp;inspectorProgram-&gt;canvas() == &amp;inspectorCanvas)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 690,16 ***</span>
  
      for (auto* inspectorProgram : programsToRemove)
          unbindProgram(*inspectorProgram);
  #endif
  
<span class="line-modified">!     inspectorCanvas.context().canvasBase().removeObserver(*this);</span>
  
      String identifier = inspectorCanvas.identifier();
      m_identifierToInspectorCanvas.remove(identifier);
  
<span class="line-modified">!     return identifier;</span>
  }
  
  RefPtr&lt;InspectorCanvas&gt; InspectorCanvasAgent::assertInspectorCanvas(ErrorString&amp; errorString, const String&amp; canvasId)
  {
      auto inspectorCanvas = m_identifierToInspectorCanvas.get(canvasId);
<span class="line-new-header">--- 811,23 ---</span>
  
      for (auto* inspectorProgram : programsToRemove)
          unbindProgram(*inspectorProgram);
  #endif
  
<span class="line-modified">!     if (auto* context = inspectorCanvas.canvasContext())</span>
<span class="line-added">+         context-&gt;canvasBase().removeObserver(*this);</span>
  
      String identifier = inspectorCanvas.identifier();
      m_identifierToInspectorCanvas.remove(identifier);
  
<span class="line-modified">!     // This can be called in response to GC. Due to the single-process model used in WebKit1, the</span>
<span class="line-added">+     // event must be dispatched from a timer to prevent the frontend from making JS allocations</span>
<span class="line-added">+     // while the GC is still active.</span>
<span class="line-added">+     m_removedCanvasIdentifiers.append(identifier);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!m_canvasDestroyedTimer.isActive())</span>
<span class="line-added">+         m_canvasDestroyedTimer.startOneShot(0_s);</span>
  }
  
  RefPtr&lt;InspectorCanvas&gt; InspectorCanvasAgent::assertInspectorCanvas(ErrorString&amp; errorString, const String&amp; canvasId)
  {
      auto inspectorCanvas = m_identifierToInspectorCanvas.get(canvasId);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 711,23 ***</span>
  }
  
  RefPtr&lt;InspectorCanvas&gt; InspectorCanvasAgent::findInspectorCanvas(CanvasRenderingContext&amp; context)
  {
      for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {
<span class="line-modified">!         if (&amp;inspectorCanvas-&gt;context() == &amp;context)</span>
              return inspectorCanvas;
      }
      return nullptr;
  }
  
<span class="line-modified">! #if ENABLE(WEBGL)</span>
<span class="line-modified">! String InspectorCanvasAgent::unbindProgram(InspectorShaderProgram&amp; inspectorProgram)</span>
  {
      String identifier = inspectorProgram.identifier();
      m_identifierToInspectorProgram.remove(identifier);
  
<span class="line-modified">!     return identifier;</span>
  }
  
  RefPtr&lt;InspectorShaderProgram&gt; InspectorCanvasAgent::assertInspectorProgram(ErrorString&amp; errorString, const String&amp; programId)
  {
      auto inspectorProgram = m_identifierToInspectorProgram.get(programId);
<span class="line-new-header">--- 839,39 ---</span>
  }
  
  RefPtr&lt;InspectorCanvas&gt; InspectorCanvasAgent::findInspectorCanvas(CanvasRenderingContext&amp; context)
  {
      for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {
<span class="line-modified">!         if (inspectorCanvas-&gt;canvasContext() == &amp;context)</span>
              return inspectorCanvas;
      }
      return nullptr;
  }
  
<span class="line-modified">! #if ENABLE(WEBGPU)</span>
<span class="line-modified">! RefPtr&lt;InspectorCanvas&gt; InspectorCanvasAgent::findInspectorCanvas(WebGPUDevice&amp; device)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {</span>
<span class="line-added">+         if (inspectorCanvas-&gt;deviceContext() == &amp;device)</span>
<span class="line-added">+             return inspectorCanvas;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ void InspectorCanvasAgent::unbindProgram(InspectorShaderProgram&amp; inspectorProgram)</span>
  {
      String identifier = inspectorProgram.identifier();
      m_identifierToInspectorProgram.remove(identifier);
  
<span class="line-modified">!     // This can be called in response to GC. Due to the single-process model used in WebKit1, the</span>
<span class="line-added">+     // event must be dispatched from a timer to prevent the frontend from making JS allocations</span>
<span class="line-added">+     // while the GC is still active.</span>
<span class="line-added">+     m_removedProgramIdentifiers.append(identifier);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!m_programDestroyedTimer.isActive())</span>
<span class="line-added">+         m_programDestroyedTimer.startOneShot(0_s);</span>
  }
  
  RefPtr&lt;InspectorShaderProgram&gt; InspectorCanvasAgent::assertInspectorProgram(ErrorString&amp; errorString, const String&amp; programId)
  {
      auto inspectorProgram = m_identifierToInspectorProgram.get(programId);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 736,14 ***</span>
          return nullptr;
      }
      return inspectorProgram;
  }
  
  RefPtr&lt;InspectorShaderProgram&gt; InspectorCanvasAgent::findInspectorProgram(WebGLProgram&amp; program)
  {
      for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {
<span class="line-modified">!         if (&amp;inspectorProgram-&gt;program() == &amp;program)</span>
              return inspectorProgram;
      }
      return nullptr;
  }
  #endif
<span class="line-new-header">--- 880,26 ---</span>
          return nullptr;
      }
      return inspectorProgram;
  }
  
<span class="line-added">+ #if ENABLE(WEBGL)</span>
  RefPtr&lt;InspectorShaderProgram&gt; InspectorCanvasAgent::findInspectorProgram(WebGLProgram&amp; program)
  {
      for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {
<span class="line-modified">!         if (inspectorProgram-&gt;program() == &amp;program)</span>
<span class="line-added">+             return inspectorProgram;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(WEBGPU)</span>
<span class="line-added">+ RefPtr&lt;InspectorShaderProgram&gt; InspectorCanvasAgent::findInspectorProgram(WebGPUPipeline&amp; pipeline)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {</span>
<span class="line-added">+         if (inspectorProgram-&gt;pipeline() == &amp;pipeline)</span>
              return inspectorProgram;
      }
      return nullptr;
  }
  #endif
</pre>
<center><a href="InspectorCSSAgent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorCanvasAgent.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
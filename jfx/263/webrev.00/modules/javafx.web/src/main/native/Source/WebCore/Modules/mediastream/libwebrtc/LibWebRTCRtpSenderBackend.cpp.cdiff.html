<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCRtpSenderBackend.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LibWebRTCRtpReceiverBackend.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LibWebRTCRtpSenderBackend.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCRtpSenderBackend.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,59 ***</span>
  #include &quot;config.h&quot;
  #include &quot;LibWebRTCRtpSenderBackend.h&quot;
  
  #if ENABLE(WEB_RTC) &amp;&amp; USE(LIBWEBRTC)
  
  #include &quot;LibWebRTCDTMFSenderBackend.h&quot;
  #include &quot;LibWebRTCPeerConnectionBackend.h&quot;
  #include &quot;LibWebRTCUtils.h&quot;
  #include &quot;RTCPeerConnection.h&quot;
  #include &quot;RTCRtpSender.h&quot;
<span class="line-removed">- #include &quot;RuntimeEnabledFeatures.h&quot;</span>
  #include &quot;ScriptExecutionContext.h&quot;
  
  namespace WebCore {
  
<span class="line-modified">! template&lt;typename Source&gt;</span>
<span class="line-modified">! static inline bool updateTrackSource(Source&amp; source, MediaStreamTrack* track)</span>
  {
<span class="line-modified">!     if (!track) {</span>
<span class="line-modified">!         source.stop();</span>
<span class="line-modified">!         return true;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     return source.setSource(track-&gt;privateTrack());</span>
  }
  
  void LibWebRTCRtpSenderBackend::replaceTrack(ScriptExecutionContext&amp; context, RTCRtpSender&amp; sender, RefPtr&lt;MediaStreamTrack&gt;&amp;&amp; track, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
  {
      if (!m_peerConnectionBackend) {
          promise.reject(Exception { InvalidStateError, &quot;No WebRTC backend&quot;_s });
          return;
      }
  
<span class="line-modified">!     auto* currentTrack = sender.track();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     ASSERT(!track || !currentTrack || currentTrack-&gt;source().type() == track-&gt;source().type());</span>
<span class="line-modified">!     if (currentTrack) {</span>
<span class="line-modified">!     switch (currentTrack-&gt;source().type()) {</span>
<span class="line-modified">!     case RealtimeMediaSource::Type::None:</span>
<span class="line-modified">!         ASSERT_NOT_REACHED();</span>
<span class="line-modified">!         promise.reject(InvalidModificationError);</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!     case RealtimeMediaSource::Type::Audio:</span>
<span class="line-modified">!         if (!updateTrackSource(*audioSource(), track.get())) {</span>
<span class="line-modified">!             promise.reject(InvalidModificationError);</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!     case RealtimeMediaSource::Type::Video:</span>
<span class="line-removed">-         if (!updateTrackSource(*videoSource(), track.get())) {</span>
<span class="line-removed">-             promise.reject(InvalidModificationError);</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     }</span>
      }
  
      // FIXME: Remove this postTask once this whole function is executed as part of the RTCPeerConnection operation queue.
      context.postTask([protectedSender = makeRef(sender), promise = WTFMove(promise), track = WTFMove(track), this](ScriptExecutionContext&amp;) mutable {
          if (protectedSender-&gt;isStopped())
<span class="line-new-header">--- 25,77 ---</span>
  #include &quot;config.h&quot;
  #include &quot;LibWebRTCRtpSenderBackend.h&quot;
  
  #if ENABLE(WEB_RTC) &amp;&amp; USE(LIBWEBRTC)
  
<span class="line-added">+ #include &quot;JSDOMPromiseDeferred.h&quot;</span>
  #include &quot;LibWebRTCDTMFSenderBackend.h&quot;
  #include &quot;LibWebRTCPeerConnectionBackend.h&quot;
  #include &quot;LibWebRTCUtils.h&quot;
  #include &quot;RTCPeerConnection.h&quot;
  #include &quot;RTCRtpSender.h&quot;
  #include &quot;ScriptExecutionContext.h&quot;
  
  namespace WebCore {
  
<span class="line-modified">! LibWebRTCRtpSenderBackend::LibWebRTCRtpSenderBackend(LibWebRTCPeerConnectionBackend&amp; backend, rtc::scoped_refptr&lt;webrtc::RtpSenderInterface&gt;&amp;&amp; rtcSender, Source&amp;&amp; source)</span>
<span class="line-modified">!     : m_peerConnectionBackend(makeWeakPtr(&amp;backend))</span>
<span class="line-added">+     , m_rtcSender(WTFMove(rtcSender))</span>
<span class="line-added">+     , m_source(WTFMove(source))</span>
  {
<span class="line-modified">!     startSource();</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! LibWebRTCRtpSenderBackend::~LibWebRTCRtpSenderBackend()</span>
<span class="line-modified">! {</span>
<span class="line-added">+     stopSource();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void LibWebRTCRtpSenderBackend::startSource()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switchOn(m_source, [](Ref&lt;RealtimeOutgoingAudioSource&gt;&amp; source) {</span>
<span class="line-added">+         source-&gt;start();</span>
<span class="line-added">+     }, [](Ref&lt;RealtimeOutgoingVideoSource&gt;&amp; source) {</span>
<span class="line-added">+         source-&gt;start();</span>
<span class="line-added">+     }, [](std::nullptr_t&amp;) {</span>
<span class="line-added">+     });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void LibWebRTCRtpSenderBackend::stopSource()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switchOn(m_source, [](Ref&lt;RealtimeOutgoingAudioSource&gt;&amp; source) {</span>
<span class="line-added">+         source-&gt;stop();</span>
<span class="line-added">+     }, [](Ref&lt;RealtimeOutgoingVideoSource&gt;&amp; source) {</span>
<span class="line-added">+         source-&gt;stop();</span>
<span class="line-added">+     }, [](std::nullptr_t&amp;) {</span>
<span class="line-added">+     });</span>
<span class="line-added">+     m_source = nullptr;</span>
  }
  
  void LibWebRTCRtpSenderBackend::replaceTrack(ScriptExecutionContext&amp; context, RTCRtpSender&amp; sender, RefPtr&lt;MediaStreamTrack&gt;&amp;&amp; track, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
  {
      if (!m_peerConnectionBackend) {
          promise.reject(Exception { InvalidStateError, &quot;No WebRTC backend&quot;_s });
          return;
      }
  
<span class="line-modified">!     if (!track)</span>
<span class="line-modified">!         stopSource();</span>
<span class="line-modified">!     else if (sender.track()) {</span>
<span class="line-modified">!         switchOn(m_source, [&amp;](Ref&lt;RealtimeOutgoingAudioSource&gt;&amp; source) {</span>
<span class="line-modified">!             ASSERT(track-&gt;source().type() == RealtimeMediaSource::Type::Audio);</span>
<span class="line-modified">!             source-&gt;stop();</span>
<span class="line-modified">!             source-&gt;setSource(track-&gt;privateTrack());</span>
<span class="line-modified">!             source-&gt;start();</span>
<span class="line-modified">!         }, [&amp;](Ref&lt;RealtimeOutgoingVideoSource&gt;&amp; source) {</span>
<span class="line-modified">!             ASSERT(track-&gt;source().type() == RealtimeMediaSource::Type::Video);</span>
<span class="line-modified">!             source-&gt;stop();</span>
<span class="line-modified">!             source-&gt;setSource(track-&gt;privateTrack());</span>
<span class="line-modified">!             source-&gt;start();</span>
<span class="line-modified">!         }, [](std::nullptr_t&amp;) {</span>
<span class="line-modified">!             ASSERT_NOT_REACHED();</span>
<span class="line-modified">!         });</span>
      }
  
      // FIXME: Remove this postTask once this whole function is executed as part of the RTCPeerConnection operation queue.
      context.postTask([protectedSender = makeRef(sender), promise = WTFMove(promise), track = WTFMove(track), this](ScriptExecutionContext&amp;) mutable {
          if (protectedSender-&gt;isStopped())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 95,22 ***</span>
          if (hasTrack) {
              promise.resolve();
              return;
          }
  
<span class="line-modified">!         if (RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled()) {</span>
<span class="line-removed">-             m_source = nullptr;</span>
<span class="line-removed">-             m_peerConnectionBackend-&gt;setSenderSourceFromTrack(*this, *protectedSender-&gt;track());</span>
<span class="line-removed">-             promise.resolve();</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto result = m_peerConnectionBackend-&gt;addTrack(*protectedSender-&gt;track(), { });</span>
<span class="line-removed">-         if (result.hasException()) {</span>
<span class="line-removed">-             promise.reject(result.releaseException());</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
          promise.resolve();
      });
  }
  
  RTCRtpSendParameters LibWebRTCRtpSenderBackend::getParameters() const
<span class="line-new-header">--- 113,11 ---</span>
          if (hasTrack) {
              promise.resolve();
              return;
          }
  
<span class="line-modified">!         m_peerConnectionBackend-&gt;setSenderSourceFromTrack(*this, *protectedSender-&gt;track());</span>
          promise.resolve();
      });
  }
  
  RTCRtpSendParameters LibWebRTCRtpSenderBackend::getParameters() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 149,8 ***</span>
<span class="line-new-header">--- 156,39 ---</span>
  std::unique_ptr&lt;RTCDTMFSenderBackend&gt; LibWebRTCRtpSenderBackend::createDTMFBackend()
  {
      return makeUnique&lt;LibWebRTCDTMFSenderBackend&gt;(m_rtcSender-&gt;GetDtmfSender());
  }
  
<span class="line-added">+ RealtimeOutgoingVideoSource* LibWebRTCRtpSenderBackend::videoSource()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return switchOn(m_source,</span>
<span class="line-added">+         [](Ref&lt;RealtimeOutgoingVideoSource&gt;&amp; source) { return source.ptr(); },</span>
<span class="line-added">+         [](const auto&amp;) -&gt; RealtimeOutgoingVideoSource* { return nullptr; }</span>
<span class="line-added">+     );</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool LibWebRTCRtpSenderBackend::hasSource() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return switchOn(m_source,</span>
<span class="line-added">+         [](const std::nullptr_t&amp;) { return false; },</span>
<span class="line-added">+         [](const auto&amp;) { return true; }</span>
<span class="line-added">+     );</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void LibWebRTCRtpSenderBackend::setSource(Source&amp;&amp; source)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     stopSource();</span>
<span class="line-added">+     m_source = WTFMove(source);</span>
<span class="line-added">+     startSource();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void LibWebRTCRtpSenderBackend::takeSource(LibWebRTCRtpSenderBackend&amp; backend)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(backend.hasSource());</span>
<span class="line-added">+     stopSource();</span>
<span class="line-added">+     m_source = WTFMove(backend.m_source);</span>
<span class="line-added">+     backend.m_source = nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  } // namespace WebCore
  
  #endif // ENABLE(WEB_RTC) &amp;&amp; USE(LIBWEBRTC)
</pre>
<center><a href="LibWebRTCRtpReceiverBackend.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LibWebRTCRtpSenderBackend.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/parser/HTMLScriptRunner.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLResourcePreloader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="HTMLToken.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/parser/HTMLScriptRunner.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;HTMLScriptRunner.h&quot;
 29 
 30 #include &quot;Element.h&quot;
 31 #include &quot;Event.h&quot;

 32 #include &quot;EventNames.h&quot;
 33 #include &quot;Frame.h&quot;
 34 #include &quot;HTMLInputStream.h&quot;
 35 #include &quot;HTMLNames.h&quot;
 36 #include &quot;HTMLScriptRunnerHost.h&quot;
 37 #include &quot;IgnoreDestructiveWriteCountIncrementer.h&quot;
 38 #include &quot;InlineClassicScript.h&quot;
<span class="line-removed"> 39 #include &quot;Microtasks.h&quot;</span>
 40 #include &quot;MutationObserver.h&quot;
 41 #include &quot;NestingLevelIncrementer.h&quot;
 42 #include &quot;ScriptElement.h&quot;
 43 #include &quot;ScriptSourceCode.h&quot;
 44 
 45 namespace WebCore {
 46 
 47 using namespace HTMLNames;
 48 
 49 HTMLScriptRunner::HTMLScriptRunner(Document&amp; document, HTMLScriptRunnerHost&amp; host)
 50     : m_document(makeWeakPtr(document))
 51     , m_host(host)
 52     , m_scriptNestingLevel(0)
 53     , m_hasScriptsWaitingForStylesheets(false)
 54 {
 55 }
 56 
 57 HTMLScriptRunner::~HTMLScriptRunner()
 58 {
 59     // FIXME: Should we be passed a &quot;done loading/parsing&quot; callback sooner than destruction?
</pre>
<hr />
<pre>
 89 }
 90 
 91 bool HTMLScriptRunner::isPendingScriptReady(const PendingScript&amp; script)
 92 {
 93     if (!m_document)
 94         return false;
 95     m_hasScriptsWaitingForStylesheets = !m_document-&gt;haveStylesheetsLoaded();
 96     if (m_hasScriptsWaitingForStylesheets)
 97         return false;
 98     if (script.needsLoading() &amp;&amp; !script.isLoaded())
 99         return false;
100     return true;
101 }
102 
103 void HTMLScriptRunner::executePendingScriptAndDispatchEvent(PendingScript&amp; pendingScript)
104 {
105     // Stop watching loads before executeScript to prevent recursion if the script reloads itself.
106     if (pendingScript.watchingForLoad())
107         stopWatchingForLoad(pendingScript);
108 
<span class="line-modified">109     if (!isExecutingScript())</span>
<span class="line-modified">110         MicrotaskQueue::mainThreadQueue().performMicrotaskCheckpoint();</span>
111 
112     {
113         NestingLevelIncrementer nestingLevelIncrementer(m_scriptNestingLevel);
114         pendingScript.element().executePendingScript(pendingScript);
115     }
116     ASSERT(!isExecutingScript());
117 }
118 
119 void HTMLScriptRunner::watchForLoad(PendingScript&amp; pendingScript)
120 {
121     ASSERT(!pendingScript.watchingForLoad());
122     m_host.watchForLoad(pendingScript);
123 }
124 
125 void HTMLScriptRunner::stopWatchingForLoad(PendingScript&amp; pendingScript)
126 {
127     ASSERT(pendingScript.watchingForLoad());
128     m_host.stopWatchingForLoad(pendingScript);
129 }
130 
</pre>
<hr />
<pre>
224 }
225 
226 void HTMLScriptRunner::requestDeferredScript(ScriptElement&amp; scriptElement)
227 {
228     auto pendingScript = requestPendingScript(scriptElement);
229     ASSERT(pendingScript-&gt;needsLoading());
230     m_scriptsToExecuteAfterParsing.append(WTFMove(pendingScript));
231 }
232 
233 // This method is meant to match the HTML5 definition of &quot;running a script&quot;
234 // http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#running-a-script
235 void HTMLScriptRunner::runScript(ScriptElement&amp; scriptElement, const TextPosition&amp; scriptStartPosition)
236 {
237     ASSERT(m_document);
238     ASSERT(!hasParserBlockingScript());
239 
240     // FIXME: This may be too agressive as we always deliver mutations at
241     // every script element, even if it&#39;s not ready to execute yet. There&#39;s
242     // unfortunately no obvious way to tell if prepareScript is going to
243     // execute the script before calling it.
<span class="line-modified">244     if (!isExecutingScript())</span>
<span class="line-modified">245         MicrotaskQueue::mainThreadQueue().performMicrotaskCheckpoint();</span>
246 
247     InsertionPointRecord insertionPointRecord(m_host.inputStream());
248     NestingLevelIncrementer nestingLevelIncrementer(m_scriptNestingLevel);
249 
250     scriptElement.prepareScript(scriptStartPosition);
251 
252     if (!scriptElement.willBeParserExecuted())
253         return;
254 
255     if (scriptElement.willExecuteWhenDocumentFinishedParsing())
256         requestDeferredScript(scriptElement);
257     else if (scriptElement.readyToBeParserExecuted()) {
258         if (m_scriptNestingLevel == 1)
259             m_parserBlockingScript = PendingScript::create(scriptElement, scriptStartPosition);
260         else
261             scriptElement.executeClassicScript(ScriptSourceCode(scriptElement.element().textContent(), documentURLForScriptExecution(m_document.get()), scriptStartPosition, JSC::SourceProviderSourceType::Program, InlineClassicScript::create(scriptElement)));
262     } else
263         requestParsingBlockingScript(scriptElement);
264 }
265 
</pre>
</td>
<td>
<hr />
<pre>
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;HTMLScriptRunner.h&quot;
 29 
 30 #include &quot;Element.h&quot;
 31 #include &quot;Event.h&quot;
<span class="line-added"> 32 #include &quot;EventLoop.h&quot;</span>
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;Frame.h&quot;
 35 #include &quot;HTMLInputStream.h&quot;
 36 #include &quot;HTMLNames.h&quot;
 37 #include &quot;HTMLScriptRunnerHost.h&quot;
 38 #include &quot;IgnoreDestructiveWriteCountIncrementer.h&quot;
 39 #include &quot;InlineClassicScript.h&quot;

 40 #include &quot;MutationObserver.h&quot;
 41 #include &quot;NestingLevelIncrementer.h&quot;
 42 #include &quot;ScriptElement.h&quot;
 43 #include &quot;ScriptSourceCode.h&quot;
 44 
 45 namespace WebCore {
 46 
 47 using namespace HTMLNames;
 48 
 49 HTMLScriptRunner::HTMLScriptRunner(Document&amp; document, HTMLScriptRunnerHost&amp; host)
 50     : m_document(makeWeakPtr(document))
 51     , m_host(host)
 52     , m_scriptNestingLevel(0)
 53     , m_hasScriptsWaitingForStylesheets(false)
 54 {
 55 }
 56 
 57 HTMLScriptRunner::~HTMLScriptRunner()
 58 {
 59     // FIXME: Should we be passed a &quot;done loading/parsing&quot; callback sooner than destruction?
</pre>
<hr />
<pre>
 89 }
 90 
 91 bool HTMLScriptRunner::isPendingScriptReady(const PendingScript&amp; script)
 92 {
 93     if (!m_document)
 94         return false;
 95     m_hasScriptsWaitingForStylesheets = !m_document-&gt;haveStylesheetsLoaded();
 96     if (m_hasScriptsWaitingForStylesheets)
 97         return false;
 98     if (script.needsLoading() &amp;&amp; !script.isLoaded())
 99         return false;
100     return true;
101 }
102 
103 void HTMLScriptRunner::executePendingScriptAndDispatchEvent(PendingScript&amp; pendingScript)
104 {
105     // Stop watching loads before executeScript to prevent recursion if the script reloads itself.
106     if (pendingScript.watchingForLoad())
107         stopWatchingForLoad(pendingScript);
108 
<span class="line-modified">109     if (!isExecutingScript() &amp;&amp; m_document)</span>
<span class="line-modified">110         m_document-&gt;eventLoop().performMicrotaskCheckpoint();</span>
111 
112     {
113         NestingLevelIncrementer nestingLevelIncrementer(m_scriptNestingLevel);
114         pendingScript.element().executePendingScript(pendingScript);
115     }
116     ASSERT(!isExecutingScript());
117 }
118 
119 void HTMLScriptRunner::watchForLoad(PendingScript&amp; pendingScript)
120 {
121     ASSERT(!pendingScript.watchingForLoad());
122     m_host.watchForLoad(pendingScript);
123 }
124 
125 void HTMLScriptRunner::stopWatchingForLoad(PendingScript&amp; pendingScript)
126 {
127     ASSERT(pendingScript.watchingForLoad());
128     m_host.stopWatchingForLoad(pendingScript);
129 }
130 
</pre>
<hr />
<pre>
224 }
225 
226 void HTMLScriptRunner::requestDeferredScript(ScriptElement&amp; scriptElement)
227 {
228     auto pendingScript = requestPendingScript(scriptElement);
229     ASSERT(pendingScript-&gt;needsLoading());
230     m_scriptsToExecuteAfterParsing.append(WTFMove(pendingScript));
231 }
232 
233 // This method is meant to match the HTML5 definition of &quot;running a script&quot;
234 // http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#running-a-script
235 void HTMLScriptRunner::runScript(ScriptElement&amp; scriptElement, const TextPosition&amp; scriptStartPosition)
236 {
237     ASSERT(m_document);
238     ASSERT(!hasParserBlockingScript());
239 
240     // FIXME: This may be too agressive as we always deliver mutations at
241     // every script element, even if it&#39;s not ready to execute yet. There&#39;s
242     // unfortunately no obvious way to tell if prepareScript is going to
243     // execute the script before calling it.
<span class="line-modified">244     if (!isExecutingScript() &amp;&amp; m_document)</span>
<span class="line-modified">245         m_document-&gt;eventLoop().performMicrotaskCheckpoint();</span>
246 
247     InsertionPointRecord insertionPointRecord(m_host.inputStream());
248     NestingLevelIncrementer nestingLevelIncrementer(m_scriptNestingLevel);
249 
250     scriptElement.prepareScript(scriptStartPosition);
251 
252     if (!scriptElement.willBeParserExecuted())
253         return;
254 
255     if (scriptElement.willExecuteWhenDocumentFinishedParsing())
256         requestDeferredScript(scriptElement);
257     else if (scriptElement.readyToBeParserExecuted()) {
258         if (m_scriptNestingLevel == 1)
259             m_parserBlockingScript = PendingScript::create(scriptElement, scriptStartPosition);
260         else
261             scriptElement.executeClassicScript(ScriptSourceCode(scriptElement.element().textContent(), documentURLForScriptExecution(m_document.get()), scriptStartPosition, JSC::SourceProviderSourceType::Program, InlineClassicScript::create(scriptElement)));
262     } else
263         requestParsingBlockingScript(scriptElement);
264 }
265 
</pre>
</td>
</tr>
</table>
<center><a href="HTMLResourcePreloader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="HTMLToken.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
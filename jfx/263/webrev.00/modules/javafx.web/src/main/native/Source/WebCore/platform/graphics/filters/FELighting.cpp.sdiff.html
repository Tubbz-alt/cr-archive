<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/filters/FELighting.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FEGaussianBlur.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="FETile.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/filters/FELighting.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 67 }
 68 
 69 bool FELighting::setKernelUnitLengthX(float kernelUnitLengthX)
 70 {
 71     if (m_kernelUnitLengthX == kernelUnitLengthX)
 72         return false;
 73 
 74     m_kernelUnitLengthX = kernelUnitLengthX;
 75     return true;
 76 }
 77 
 78 bool FELighting::setKernelUnitLengthY(float kernelUnitLengthY)
 79 {
 80     if (m_kernelUnitLengthY == kernelUnitLengthY)
 81         return false;
 82 
 83     m_kernelUnitLengthY = kernelUnitLengthY;
 84     return true;
 85 }
 86 
<span class="line-modified"> 87 const static int cPixelSize = 4;</span>
<span class="line-modified"> 88 const static int cAlphaChannelOffset = 3;</span>
<span class="line-modified"> 89 const static uint8_t cOpaqueAlpha = static_cast&lt;uint8_t&gt;(0xFF);</span>
 90 
 91 // These factors and the normal coefficients come from the table under https://www.w3.org/TR/SVG/filters.html#feDiffuseLightingElement.
<span class="line-modified"> 92 const static float cFactor1div2 = -1 / 2.f;</span>
<span class="line-modified"> 93 const static float cFactor1div3 = -1 / 3.f;</span>
<span class="line-modified"> 94 const static float cFactor1div4 = -1 / 4.f;</span>
<span class="line-modified"> 95 const static float cFactor2div3 = -2 / 3.f;</span>
 96 
 97 inline IntSize FELighting::LightingData::topLeftNormal(int offset) const
 98 {
 99     int center = static_cast&lt;int&gt;(pixels-&gt;item(offset + cAlphaChannelOffset));
100     int right = static_cast&lt;int&gt;(pixels-&gt;item(offset + cPixelSize + cAlphaChannelOffset));
101     offset += widthMultipliedByPixelSize;
102     int bottom = static_cast&lt;int&gt;(pixels-&gt;item(offset + cAlphaChannelOffset));
103     int bottomRight = static_cast&lt;int&gt;(pixels-&gt;item(offset + cPixelSize + cAlphaChannelOffset));
104     return {
105         -2 * center + 2 * right - bottom + bottomRight,
106         -2 * center - right + 2 * bottom + bottomRight
107     };
108 }
109 
110 inline IntSize FELighting::LightingData::topRowNormal(int offset) const
111 {
112     int left = static_cast&lt;int&gt;(pixels-&gt;item(offset - cPixelSize + cAlphaChannelOffset));
113     int center = static_cast&lt;int&gt;(pixels-&gt;item(offset + cAlphaChannelOffset));
114     int right = static_cast&lt;int&gt;(pixels-&gt;item(offset + cPixelSize + cAlphaChannelOffset));
115     offset += widthMultipliedByPixelSize;
</pre>
<hr />
<pre>
386     platformApplyGeneric(data, paintingData);
387 #endif
388 }
389 
390 bool FELighting::drawLighting(Uint8ClampedArray&amp; pixels, int width, int height)
391 {
392     LightSource::PaintingData paintingData;
393     LightingData data;
394 
395     // FIXME: do something if width or height (or both) is 1 pixel.
396     // The W3 spec does not define this case. Now the filter just returns.
397     if (width &lt;= 2 || height &lt;= 2)
398         return false;
399 
400     data.pixels = &amp;pixels;
401     data.surfaceScale = m_surfaceScale / 255.0f;
402     data.widthMultipliedByPixelSize = width * cPixelSize;
403     data.widthDecreasedByOne = width - 1;
404     data.heightDecreasedByOne = height - 1;
405 
<span class="line-modified">406     FloatComponents lightColor = (operatingColorSpace() == ColorSpaceLinearRGB) ? sRGBColorToLinearComponents(m_lightingColor) : FloatComponents(m_lightingColor);</span>
407     paintingData.initialLightingData.colorVector = FloatPoint3D(lightColor.components[0], lightColor.components[1], lightColor.components[2]);
408     m_lightSource-&gt;initPaintingData(*this, paintingData);
409 
410     // Top left.
411     int offset = 0;
412     setPixel(offset, data, paintingData, 0, 0, cFactor2div3, cFactor2div3, data.topLeftNormal(offset));
413 
414     // Top right.
415     offset = data.widthMultipliedByPixelSize - cPixelSize;
416     setPixel(offset, data, paintingData, data.widthDecreasedByOne, 0, cFactor2div3, cFactor2div3, data.topRightNormal(offset));
417 
418     // Bottom left.
419     offset = data.heightDecreasedByOne * data.widthMultipliedByPixelSize;
420     setPixel(offset, data, paintingData, 0, data.heightDecreasedByOne, cFactor2div3, cFactor2div3, data.bottomLeftNormal(offset));
421 
422     // Bottom right.
423     offset = height * data.widthMultipliedByPixelSize - cPixelSize;
424     setPixel(offset, data, paintingData, data.widthDecreasedByOne, data.heightDecreasedByOne, cFactor2div3, cFactor2div3, data.bottomRightNormal(offset));
425 
426     if (width &gt;= 3) {
</pre>
</td>
<td>
<hr />
<pre>
 67 }
 68 
 69 bool FELighting::setKernelUnitLengthX(float kernelUnitLengthX)
 70 {
 71     if (m_kernelUnitLengthX == kernelUnitLengthX)
 72         return false;
 73 
 74     m_kernelUnitLengthX = kernelUnitLengthX;
 75     return true;
 76 }
 77 
 78 bool FELighting::setKernelUnitLengthY(float kernelUnitLengthY)
 79 {
 80     if (m_kernelUnitLengthY == kernelUnitLengthY)
 81         return false;
 82 
 83     m_kernelUnitLengthY = kernelUnitLengthY;
 84     return true;
 85 }
 86 
<span class="line-modified"> 87 static constexpr int cPixelSize = 4;</span>
<span class="line-modified"> 88 static constexpr int cAlphaChannelOffset = 3;</span>
<span class="line-modified"> 89 static constexpr uint8_t cOpaqueAlpha = static_cast&lt;uint8_t&gt;(0xFF);</span>
 90 
 91 // These factors and the normal coefficients come from the table under https://www.w3.org/TR/SVG/filters.html#feDiffuseLightingElement.
<span class="line-modified"> 92 static constexpr float cFactor1div2 = -1 / 2.f;</span>
<span class="line-modified"> 93 static constexpr float cFactor1div3 = -1 / 3.f;</span>
<span class="line-modified"> 94 static constexpr float cFactor1div4 = -1 / 4.f;</span>
<span class="line-modified"> 95 static constexpr float cFactor2div3 = -2 / 3.f;</span>
 96 
 97 inline IntSize FELighting::LightingData::topLeftNormal(int offset) const
 98 {
 99     int center = static_cast&lt;int&gt;(pixels-&gt;item(offset + cAlphaChannelOffset));
100     int right = static_cast&lt;int&gt;(pixels-&gt;item(offset + cPixelSize + cAlphaChannelOffset));
101     offset += widthMultipliedByPixelSize;
102     int bottom = static_cast&lt;int&gt;(pixels-&gt;item(offset + cAlphaChannelOffset));
103     int bottomRight = static_cast&lt;int&gt;(pixels-&gt;item(offset + cPixelSize + cAlphaChannelOffset));
104     return {
105         -2 * center + 2 * right - bottom + bottomRight,
106         -2 * center - right + 2 * bottom + bottomRight
107     };
108 }
109 
110 inline IntSize FELighting::LightingData::topRowNormal(int offset) const
111 {
112     int left = static_cast&lt;int&gt;(pixels-&gt;item(offset - cPixelSize + cAlphaChannelOffset));
113     int center = static_cast&lt;int&gt;(pixels-&gt;item(offset + cAlphaChannelOffset));
114     int right = static_cast&lt;int&gt;(pixels-&gt;item(offset + cPixelSize + cAlphaChannelOffset));
115     offset += widthMultipliedByPixelSize;
</pre>
<hr />
<pre>
386     platformApplyGeneric(data, paintingData);
387 #endif
388 }
389 
390 bool FELighting::drawLighting(Uint8ClampedArray&amp; pixels, int width, int height)
391 {
392     LightSource::PaintingData paintingData;
393     LightingData data;
394 
395     // FIXME: do something if width or height (or both) is 1 pixel.
396     // The W3 spec does not define this case. Now the filter just returns.
397     if (width &lt;= 2 || height &lt;= 2)
398         return false;
399 
400     data.pixels = &amp;pixels;
401     data.surfaceScale = m_surfaceScale / 255.0f;
402     data.widthMultipliedByPixelSize = width * cPixelSize;
403     data.widthDecreasedByOne = width - 1;
404     data.heightDecreasedByOne = height - 1;
405 
<span class="line-modified">406     FloatComponents lightColor = (operatingColorSpace() == ColorSpace::LinearRGB) ? sRGBColorToLinearComponents(m_lightingColor) : FloatComponents(m_lightingColor);</span>
407     paintingData.initialLightingData.colorVector = FloatPoint3D(lightColor.components[0], lightColor.components[1], lightColor.components[2]);
408     m_lightSource-&gt;initPaintingData(*this, paintingData);
409 
410     // Top left.
411     int offset = 0;
412     setPixel(offset, data, paintingData, 0, 0, cFactor2div3, cFactor2div3, data.topLeftNormal(offset));
413 
414     // Top right.
415     offset = data.widthMultipliedByPixelSize - cPixelSize;
416     setPixel(offset, data, paintingData, data.widthDecreasedByOne, 0, cFactor2div3, cFactor2div3, data.topRightNormal(offset));
417 
418     // Bottom left.
419     offset = data.heightDecreasedByOne * data.widthMultipliedByPixelSize;
420     setPixel(offset, data, paintingData, 0, data.heightDecreasedByOne, cFactor2div3, cFactor2div3, data.bottomLeftNormal(offset));
421 
422     // Bottom right.
423     offset = height * data.widthMultipliedByPixelSize - cPixelSize;
424     setPixel(offset, data, paintingData, data.widthDecreasedByOne, data.heightDecreasedByOne, cFactor2div3, cFactor2div3, data.bottomRightNormal(offset));
425 
426     if (width &gt;= 3) {
</pre>
</td>
</tr>
</table>
<center><a href="FEGaussianBlur.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="FETile.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
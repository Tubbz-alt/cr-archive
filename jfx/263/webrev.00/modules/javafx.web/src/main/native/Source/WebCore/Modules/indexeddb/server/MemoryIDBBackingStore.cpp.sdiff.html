<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/MemoryIDBBackingStore.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemoryCursor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="MemoryIDBBackingStore.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/MemoryIDBBackingStore.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 26 #include &quot;config.h&quot;
 27 #include &quot;MemoryIDBBackingStore.h&quot;
 28 
 29 #if ENABLE(INDEXED_DATABASE)
 30 
 31 #include &quot;IDBCursorInfo.h&quot;
 32 #include &quot;IDBGetAllRecordsData.h&quot;
 33 #include &quot;IDBGetRecordData.h&quot;
 34 #include &quot;IDBGetResult.h&quot;
 35 #include &quot;IDBIndexInfo.h&quot;
 36 #include &quot;IDBIterateCursorData.h&quot;
 37 #include &quot;IDBKeyRangeData.h&quot;
 38 #include &quot;Logging.h&quot;
 39 #include &quot;MemoryIndexCursor.h&quot;
 40 #include &quot;MemoryObjectStore.h&quot;
 41 #include &quot;MemoryObjectStoreCursor.h&quot;
 42 
 43 namespace WebCore {
 44 namespace IDBServer {
 45 
<span class="line-modified"> 46 // The IndexedDB spec states the value you can get from the key generator is 2^53</span>
<span class="line-modified"> 47 static uint64_t maxGeneratedKeyValue = 0x20000000000000;</span>
<span class="line-removed"> 48 </span>
<span class="line-removed"> 49 std::unique_ptr&lt;MemoryIDBBackingStore&gt; MemoryIDBBackingStore::create(PAL::SessionID sessionID, const IDBDatabaseIdentifier&amp; identifier)</span>
<span class="line-removed"> 50 {</span>
<span class="line-removed"> 51     return makeUnique&lt;MemoryIDBBackingStore&gt;(sessionID, identifier);</span>
<span class="line-removed"> 52 }</span>
 53 
 54 MemoryIDBBackingStore::MemoryIDBBackingStore(PAL::SessionID sessionID, const IDBDatabaseIdentifier&amp; identifier)
 55     : m_identifier(identifier)
 56     , m_sessionID(sessionID)
 57 {
 58 }
 59 
 60 MemoryIDBBackingStore::~MemoryIDBBackingStore() = default;
 61 
 62 IDBError MemoryIDBBackingStore::getOrEstablishDatabaseInfo(IDBDatabaseInfo&amp; info)
 63 {
 64     if (!m_databaseInfo)
<span class="line-modified"> 65         m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), 0);</span>
 66 
 67     info = *m_databaseInfo;
 68     return IDBError { };
 69 }
 70 
 71 void MemoryIDBBackingStore::setDatabaseInfo(const IDBDatabaseInfo&amp; info)
 72 {
 73     // It is not valid to directly set database info on a backing store that hasn&#39;t already set its own database info.
 74     ASSERT(m_databaseInfo);
 75 
 76     m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(info);
 77 }
 78 
 79 IDBError MemoryIDBBackingStore::beginTransaction(const IDBTransactionInfo&amp; info)
 80 {
 81     LOG(IndexedDB, &quot;MemoryIDBBackingStore::beginTransaction&quot;);
 82 
 83     if (m_transactions.contains(info.identifier()))
 84         return IDBError { InvalidStateError, &quot;Backing store asked to create transaction it already has a record of&quot; };
 85 
</pre>
<hr />
<pre>
177 {
178     LOG(IndexedDB, &quot;MemoryIDBBackingStore::renameObjectStore&quot;);
179 
180     ASSERT(m_databaseInfo);
181     if (!m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier))
182         return IDBError { ConstraintError };
183 
184     auto transaction = m_transactions.get(transactionIdentifier);
185     ASSERT(transaction);
186     ASSERT(transaction-&gt;isVersionChange());
187 
188     auto objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
189     ASSERT(objectStore);
190     if (!objectStore)
191         return IDBError { ConstraintError };
192 
193     String oldName = objectStore-&gt;info().name();
194     objectStore-&gt;rename(newName);
195     transaction-&gt;objectStoreRenamed(*objectStore, oldName);
196 



197     m_databaseInfo-&gt;renameObjectStore(objectStoreIdentifier, newName);
198 
199     return IDBError { };
200 }
201 
202 IDBError MemoryIDBBackingStore::clearObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)
203 {
204     LOG(IndexedDB, &quot;MemoryIDBBackingStore::clearObjectStore&quot;);
205     ASSERT(objectStoreIdentifier);
206 
207     ASSERT_UNUSED(transactionIdentifier, m_transactions.contains(transactionIdentifier));
208 
209 #ifndef NDEBUG
210     auto transaction = m_transactions.get(transactionIdentifier);
211     ASSERT(transaction-&gt;isWriting());
212 #endif
213 
214     auto objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
215     if (!objectStore)
216         return IDBError { ConstraintError };
217 
218     objectStore-&gt;clear();
219 
220     return IDBError { };
221 }
222 
223 IDBError MemoryIDBBackingStore::createIndex(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBIndexInfo&amp; info)
224 {
225     LOG(IndexedDB, &quot;MemoryIDBBackingStore::createIndex&quot;);
226 





227     auto rawTransaction = m_transactions.get(transactionIdentifier);
228     ASSERT(rawTransaction);
229     ASSERT(rawTransaction-&gt;isVersionChange());
230 
231     auto* objectStore = m_objectStoresByIdentifier.get(info.objectStoreIdentifier());
232     if (!objectStore)
233         return IDBError { ConstraintError };
234 
<span class="line-modified">235     return objectStore-&gt;createIndex(*rawTransaction, info);</span>






236 }
237 
238 IDBError MemoryIDBBackingStore::deleteIndex(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier)
239 {
240     LOG(IndexedDB, &quot;MemoryIDBBackingStore::deleteIndex&quot;);
241 









242     auto rawTransaction = m_transactions.get(transactionIdentifier);
243     ASSERT(rawTransaction);
244     ASSERT(rawTransaction-&gt;isVersionChange());
245 
246     auto* objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
247     if (!objectStore)
248         return IDBError { ConstraintError };
249 
<span class="line-modified">250     return objectStore-&gt;deleteIndex(*rawTransaction, indexIdentifier);</span>




251 }
252 
253 IDBError MemoryIDBBackingStore::renameIndex(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
254 {
255     LOG(IndexedDB, &quot;MemoryIDBBackingStore::renameIndex&quot;);
256 
257     ASSERT(m_databaseInfo);
258     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
259     if (!objectStoreInfo)
260         return IDBError { ConstraintError };
261 
262     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
263     if (!indexInfo)
264         return IDBError { ConstraintError };
265 
266     auto transaction = m_transactions.get(transactionIdentifier);
267     ASSERT(transaction);
268     ASSERT(transaction-&gt;isVersionChange());
269 
270     auto objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
</pre>
<hr />
<pre>
467     RELEASE_ASSERT(objectStore);
468 
469     objectStore-&gt;setKeyGeneratorValue(keyNumber);
470 
471     return IDBError { };
472 }
473 
474 IDBError MemoryIDBBackingStore::maybeUpdateKeyGeneratorNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, double newKeyNumber)
475 {
476     LOG(IndexedDB, &quot;MemoryIDBBackingStore::maybeUpdateKeyGeneratorNumber&quot;);
477     ASSERT(objectStoreIdentifier);
478     ASSERT_UNUSED(transactionIdentifier, m_transactions.contains(transactionIdentifier));
479     ASSERT_UNUSED(transactionIdentifier, m_transactions.get(transactionIdentifier)-&gt;isWriting());
480 
481     MemoryObjectStore* objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
482     RELEASE_ASSERT(objectStore);
483 
484     if (newKeyNumber &lt; objectStore-&gt;currentKeyGeneratorValue())
485         return IDBError { };
486 





487     uint64_t newKeyInteger(newKeyNumber);
488     if (newKeyInteger &lt;= uint64_t(newKeyNumber))
489         ++newKeyInteger;
490 
491     ASSERT(newKeyInteger &gt; uint64_t(newKeyNumber));
492 
493     objectStore-&gt;setKeyGeneratorValue(newKeyInteger);
494 
495     return IDBError { };
496 }
497 
498 IDBError MemoryIDBBackingStore::openCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBCursorInfo&amp; info, IDBGetResult&amp; outData)
499 {
500     LOG(IndexedDB, &quot;MemoryIDBBackingStore::openCursor&quot;);
501 
502     ASSERT(!MemoryCursor::cursorForIdentifier(info.identifier()));
503 
504     if (!m_transactions.contains(transactionIdentifier))
505         return IDBError { UnknownError, &quot;No backing store transaction found in which to open a cursor&quot;_s };
506 
</pre>
<hr />
<pre>
578     if (!objectStoreByIdentifier)
579         return nullptr;
580 
581     auto objectStore = m_objectStoresByName.take(objectStoreByIdentifier-&gt;info().name());
582     ASSERT_UNUSED(objectStore, objectStore);
583 
584     return objectStoreByIdentifier;
585 }
586 
587 IDBObjectStoreInfo* MemoryIDBBackingStore::infoForObjectStore(uint64_t objectStoreIdentifier)
588 {
589     ASSERT(m_databaseInfo);
590     return m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
591 }
592 
593 void MemoryIDBBackingStore::deleteBackingStore()
594 {
595     // The in-memory IDB backing store doesn&#39;t need to do any cleanup when it is deleted.
596 }
597 
<span class="line-removed">598 uint64_t MemoryIDBBackingStore::databaseSize() const</span>
<span class="line-removed">599 {</span>
<span class="line-removed">600     // FIXME: Implement this.</span>
<span class="line-removed">601     return 0;</span>
<span class="line-removed">602 }</span>
<span class="line-removed">603 </span>
604 void MemoryIDBBackingStore::close()
605 {
606 }
607 
608 } // namespace IDBServer
609 } // namespace WebCore
610 
611 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
<td>
<hr />
<pre>
 26 #include &quot;config.h&quot;
 27 #include &quot;MemoryIDBBackingStore.h&quot;
 28 
 29 #if ENABLE(INDEXED_DATABASE)
 30 
 31 #include &quot;IDBCursorInfo.h&quot;
 32 #include &quot;IDBGetAllRecordsData.h&quot;
 33 #include &quot;IDBGetRecordData.h&quot;
 34 #include &quot;IDBGetResult.h&quot;
 35 #include &quot;IDBIndexInfo.h&quot;
 36 #include &quot;IDBIterateCursorData.h&quot;
 37 #include &quot;IDBKeyRangeData.h&quot;
 38 #include &quot;Logging.h&quot;
 39 #include &quot;MemoryIndexCursor.h&quot;
 40 #include &quot;MemoryObjectStore.h&quot;
 41 #include &quot;MemoryObjectStoreCursor.h&quot;
 42 
 43 namespace WebCore {
 44 namespace IDBServer {
 45 
<span class="line-modified"> 46 // The IndexedDB spec states the maximum value you can get from the key generator is 2^53.</span>
<span class="line-modified"> 47 constexpr uint64_t maxGeneratedKeyValue = 0x20000000000000;</span>





 48 
 49 MemoryIDBBackingStore::MemoryIDBBackingStore(PAL::SessionID sessionID, const IDBDatabaseIdentifier&amp; identifier)
 50     : m_identifier(identifier)
 51     , m_sessionID(sessionID)
 52 {
 53 }
 54 
 55 MemoryIDBBackingStore::~MemoryIDBBackingStore() = default;
 56 
 57 IDBError MemoryIDBBackingStore::getOrEstablishDatabaseInfo(IDBDatabaseInfo&amp; info)
 58 {
 59     if (!m_databaseInfo)
<span class="line-modified"> 60         m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), 0, 0);</span>
 61 
 62     info = *m_databaseInfo;
 63     return IDBError { };
 64 }
 65 
 66 void MemoryIDBBackingStore::setDatabaseInfo(const IDBDatabaseInfo&amp; info)
 67 {
 68     // It is not valid to directly set database info on a backing store that hasn&#39;t already set its own database info.
 69     ASSERT(m_databaseInfo);
 70 
 71     m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(info);
 72 }
 73 
 74 IDBError MemoryIDBBackingStore::beginTransaction(const IDBTransactionInfo&amp; info)
 75 {
 76     LOG(IndexedDB, &quot;MemoryIDBBackingStore::beginTransaction&quot;);
 77 
 78     if (m_transactions.contains(info.identifier()))
 79         return IDBError { InvalidStateError, &quot;Backing store asked to create transaction it already has a record of&quot; };
 80 
</pre>
<hr />
<pre>
172 {
173     LOG(IndexedDB, &quot;MemoryIDBBackingStore::renameObjectStore&quot;);
174 
175     ASSERT(m_databaseInfo);
176     if (!m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier))
177         return IDBError { ConstraintError };
178 
179     auto transaction = m_transactions.get(transactionIdentifier);
180     ASSERT(transaction);
181     ASSERT(transaction-&gt;isVersionChange());
182 
183     auto objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
184     ASSERT(objectStore);
185     if (!objectStore)
186         return IDBError { ConstraintError };
187 
188     String oldName = objectStore-&gt;info().name();
189     objectStore-&gt;rename(newName);
190     transaction-&gt;objectStoreRenamed(*objectStore, oldName);
191 
<span class="line-added">192     m_objectStoresByName.remove(oldName);</span>
<span class="line-added">193     m_objectStoresByName.set(newName, objectStore);</span>
<span class="line-added">194 </span>
195     m_databaseInfo-&gt;renameObjectStore(objectStoreIdentifier, newName);
196 
197     return IDBError { };
198 }
199 
200 IDBError MemoryIDBBackingStore::clearObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)
201 {
202     LOG(IndexedDB, &quot;MemoryIDBBackingStore::clearObjectStore&quot;);
203     ASSERT(objectStoreIdentifier);
204 
205     ASSERT_UNUSED(transactionIdentifier, m_transactions.contains(transactionIdentifier));
206 
207 #ifndef NDEBUG
208     auto transaction = m_transactions.get(transactionIdentifier);
209     ASSERT(transaction-&gt;isWriting());
210 #endif
211 
212     auto objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
213     if (!objectStore)
214         return IDBError { ConstraintError };
215 
216     objectStore-&gt;clear();
217 
218     return IDBError { };
219 }
220 
221 IDBError MemoryIDBBackingStore::createIndex(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBIndexInfo&amp; info)
222 {
223     LOG(IndexedDB, &quot;MemoryIDBBackingStore::createIndex&quot;);
224 
<span class="line-added">225     ASSERT(m_databaseInfo);</span>
<span class="line-added">226     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());</span>
<span class="line-added">227     if (!objectStoreInfo)</span>
<span class="line-added">228         return IDBError { ConstraintError };</span>
<span class="line-added">229 </span>
230     auto rawTransaction = m_transactions.get(transactionIdentifier);
231     ASSERT(rawTransaction);
232     ASSERT(rawTransaction-&gt;isVersionChange());
233 
234     auto* objectStore = m_objectStoresByIdentifier.get(info.objectStoreIdentifier());
235     if (!objectStore)
236         return IDBError { ConstraintError };
237 
<span class="line-modified">238     auto error = objectStore-&gt;createIndex(*rawTransaction, info);</span>
<span class="line-added">239     if (error.isNull()) {</span>
<span class="line-added">240         objectStoreInfo-&gt;addExistingIndex(info);</span>
<span class="line-added">241         m_databaseInfo-&gt;setMaxIndexID(info.identifier());</span>
<span class="line-added">242     }</span>
<span class="line-added">243 </span>
<span class="line-added">244     return error;</span>
245 }
246 
247 IDBError MemoryIDBBackingStore::deleteIndex(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier)
248 {
249     LOG(IndexedDB, &quot;MemoryIDBBackingStore::deleteIndex&quot;);
250 
<span class="line-added">251     ASSERT(m_databaseInfo);</span>
<span class="line-added">252     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);</span>
<span class="line-added">253     if (!objectStoreInfo)</span>
<span class="line-added">254         return IDBError { ConstraintError };</span>
<span class="line-added">255 </span>
<span class="line-added">256     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);</span>
<span class="line-added">257     if (!indexInfo)</span>
<span class="line-added">258         return IDBError { ConstraintError };</span>
<span class="line-added">259 </span>
260     auto rawTransaction = m_transactions.get(transactionIdentifier);
261     ASSERT(rawTransaction);
262     ASSERT(rawTransaction-&gt;isVersionChange());
263 
264     auto* objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
265     if (!objectStore)
266         return IDBError { ConstraintError };
267 
<span class="line-modified">268     auto error = objectStore-&gt;deleteIndex(*rawTransaction, indexIdentifier);</span>
<span class="line-added">269     if (error.isNull())</span>
<span class="line-added">270         objectStoreInfo-&gt;deleteIndex(indexIdentifier);</span>
<span class="line-added">271 </span>
<span class="line-added">272     return error;</span>
273 }
274 
275 IDBError MemoryIDBBackingStore::renameIndex(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
276 {
277     LOG(IndexedDB, &quot;MemoryIDBBackingStore::renameIndex&quot;);
278 
279     ASSERT(m_databaseInfo);
280     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
281     if (!objectStoreInfo)
282         return IDBError { ConstraintError };
283 
284     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
285     if (!indexInfo)
286         return IDBError { ConstraintError };
287 
288     auto transaction = m_transactions.get(transactionIdentifier);
289     ASSERT(transaction);
290     ASSERT(transaction-&gt;isVersionChange());
291 
292     auto objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
</pre>
<hr />
<pre>
489     RELEASE_ASSERT(objectStore);
490 
491     objectStore-&gt;setKeyGeneratorValue(keyNumber);
492 
493     return IDBError { };
494 }
495 
496 IDBError MemoryIDBBackingStore::maybeUpdateKeyGeneratorNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, double newKeyNumber)
497 {
498     LOG(IndexedDB, &quot;MemoryIDBBackingStore::maybeUpdateKeyGeneratorNumber&quot;);
499     ASSERT(objectStoreIdentifier);
500     ASSERT_UNUSED(transactionIdentifier, m_transactions.contains(transactionIdentifier));
501     ASSERT_UNUSED(transactionIdentifier, m_transactions.get(transactionIdentifier)-&gt;isWriting());
502 
503     MemoryObjectStore* objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
504     RELEASE_ASSERT(objectStore);
505 
506     if (newKeyNumber &lt; objectStore-&gt;currentKeyGeneratorValue())
507         return IDBError { };
508 
<span class="line-added">509     if (newKeyNumber &gt;= (double)maxGeneratedKeyValue) {</span>
<span class="line-added">510         objectStore-&gt;setKeyGeneratorValue(maxGeneratedKeyValue + 1);</span>
<span class="line-added">511         return IDBError { };</span>
<span class="line-added">512     }</span>
<span class="line-added">513 </span>
514     uint64_t newKeyInteger(newKeyNumber);
515     if (newKeyInteger &lt;= uint64_t(newKeyNumber))
516         ++newKeyInteger;
517 
518     ASSERT(newKeyInteger &gt; uint64_t(newKeyNumber));
519 
520     objectStore-&gt;setKeyGeneratorValue(newKeyInteger);
521 
522     return IDBError { };
523 }
524 
525 IDBError MemoryIDBBackingStore::openCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBCursorInfo&amp; info, IDBGetResult&amp; outData)
526 {
527     LOG(IndexedDB, &quot;MemoryIDBBackingStore::openCursor&quot;);
528 
529     ASSERT(!MemoryCursor::cursorForIdentifier(info.identifier()));
530 
531     if (!m_transactions.contains(transactionIdentifier))
532         return IDBError { UnknownError, &quot;No backing store transaction found in which to open a cursor&quot;_s };
533 
</pre>
<hr />
<pre>
605     if (!objectStoreByIdentifier)
606         return nullptr;
607 
608     auto objectStore = m_objectStoresByName.take(objectStoreByIdentifier-&gt;info().name());
609     ASSERT_UNUSED(objectStore, objectStore);
610 
611     return objectStoreByIdentifier;
612 }
613 
614 IDBObjectStoreInfo* MemoryIDBBackingStore::infoForObjectStore(uint64_t objectStoreIdentifier)
615 {
616     ASSERT(m_databaseInfo);
617     return m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
618 }
619 
620 void MemoryIDBBackingStore::deleteBackingStore()
621 {
622     // The in-memory IDB backing store doesn&#39;t need to do any cleanup when it is deleted.
623 }
624 






625 void MemoryIDBBackingStore::close()
626 {
627 }
628 
629 } // namespace IDBServer
630 } // namespace WebCore
631 
632 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
</tr>
</table>
<center><a href="MemoryCursor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="MemoryIDBBackingStore.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
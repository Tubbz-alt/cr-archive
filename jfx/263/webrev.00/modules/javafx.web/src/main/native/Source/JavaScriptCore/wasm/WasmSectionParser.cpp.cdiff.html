<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSectionParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmPlan.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmSectionParser.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSectionParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 55,32 ***</span>
  
          WASM_PARSER_FAIL_IF(!parseInt7(type), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s type&quot;);
          WASM_PARSER_FAIL_IF(type != Func, i, &quot;th Type is non-Func &quot;, type);
          WASM_PARSER_FAIL_IF(!parseVarUInt32(argumentCount), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s argument count&quot;);
          WASM_PARSER_FAIL_IF(argumentCount &gt; maxFunctionParams, i, &quot;th argument count is too big &quot;, argumentCount, &quot; maximum &quot;, maxFunctionParams);
<span class="line-modified">!         RefPtr&lt;Signature&gt; maybeSignature = Signature::tryCreate(argumentCount);</span>
<span class="line-modified">!         WASM_PARSER_FAIL_IF(!maybeSignature, &quot;can&#39;t allocate enough memory for Type section&#39;s &quot;, i, &quot;th signature&quot;);</span>
<span class="line-removed">-         Ref&lt;Signature&gt; signature = maybeSignature.releaseNonNull();</span>
  
          for (unsigned i = 0; i &lt; argumentCount; ++i) {
              Type argumentType;
              WASM_PARSER_FAIL_IF(!parseValueType(argumentType), &quot;can&#39;t get &quot;, i, &quot;th argument Type&quot;);
<span class="line-modified">!             signature-&gt;argument(i) = argumentType;</span>
          }
  
<span class="line-modified">!         uint8_t returnCount;</span>
<span class="line-modified">!         WASM_PARSER_FAIL_IF(!parseVarUInt1(returnCount), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s return count&quot;);</span>
<span class="line-modified">!         Type returnType;</span>
<span class="line-modified">!         if (returnCount) {</span>
              Type value;
              WASM_PARSER_FAIL_IF(!parseValueType(value), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s return value&quot;);
<span class="line-modified">!             returnType = static_cast&lt;Type&gt;(value);</span>
<span class="line-modified">!         } else</span>
<span class="line-modified">!             returnType = Type::Void;</span>
<span class="line-modified">!         signature-&gt;returnType() = returnType;</span>
  
<span class="line-modified">!         m_info-&gt;usedSignatures.uncheckedAppend(SignatureInformation::adopt(WTFMove(signature)));</span>
      }
      return { };
  }
  
  auto SectionParser::parseImport() -&gt; PartialResult
<span class="line-new-header">--- 55,35 ---</span>
  
          WASM_PARSER_FAIL_IF(!parseInt7(type), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s type&quot;);
          WASM_PARSER_FAIL_IF(type != Func, i, &quot;th Type is non-Func &quot;, type);
          WASM_PARSER_FAIL_IF(!parseVarUInt32(argumentCount), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s argument count&quot;);
          WASM_PARSER_FAIL_IF(argumentCount &gt; maxFunctionParams, i, &quot;th argument count is too big &quot;, argumentCount, &quot; maximum &quot;, maxFunctionParams);
<span class="line-modified">!         Vector&lt;Type&gt; arguments;</span>
<span class="line-modified">!         WASM_PARSER_FAIL_IF(!arguments.tryReserveCapacity(argumentCount), &quot;can&#39;t allocate enough memory for Type section&#39;s &quot;, i, &quot;th signature&quot;);</span>
  
          for (unsigned i = 0; i &lt; argumentCount; ++i) {
              Type argumentType;
              WASM_PARSER_FAIL_IF(!parseValueType(argumentType), &quot;can&#39;t get &quot;, i, &quot;th argument Type&quot;);
<span class="line-modified">!             arguments.append(argumentType);</span>
          }
  
<span class="line-modified">!         uint32_t returnCount;</span>
<span class="line-modified">!         WASM_PARSER_FAIL_IF(!parseVarUInt32(returnCount), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s return count&quot;);</span>
<span class="line-modified">!         WASM_PARSER_FAIL_IF(returnCount &gt; 1 &amp;&amp; !Options::useWebAssemblyMultiValues(), &quot;Signatures cannot have more than one result type yet.&quot;);</span>
<span class="line-modified">! </span>
<span class="line-added">+         Vector&lt;Type, 1&gt; returnTypes;</span>
<span class="line-added">+         WASM_PARSER_FAIL_IF(!returnTypes.tryReserveCapacity(argumentCount), &quot;can&#39;t allocate enough memory for Type section&#39;s &quot;, i, &quot;th signature&quot;);</span>
<span class="line-added">+         for (unsigned i = 0; i &lt; returnCount; ++i) {</span>
              Type value;
              WASM_PARSER_FAIL_IF(!parseValueType(value), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s return value&quot;);
<span class="line-modified">!             returnTypes.append(value);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         RefPtr&lt;Signature&gt; signature = SignatureInformation::signatureFor(returnTypes, arguments);</span>
<span class="line-added">+         WASM_PARSER_FAIL_IF(!signature, &quot;can&#39;t allocate enough memory for Type section&#39;s &quot;, i, &quot;th signature&quot;);</span>
  
<span class="line-modified">!         m_info-&gt;usedSignatures.uncheckedAppend(signature.releaseNonNull());</span>
      }
      return { };
  }
  
  auto SectionParser::parseImport() -&gt; PartialResult
</pre>
<hr />
<pre>
<span class="line-old-header">*** 131,14 ***</span>
              if (UNLIKELY(!result))
                  return makeUnexpected(WTFMove(result.error()));
              break;
          }
          case ExternalKind::Global: {
<span class="line-modified">!             Global global;</span>
              WASM_FAIL_IF_HELPER_FAILS(parseGlobalType(global));
<span class="line-modified">!             WASM_PARSER_FAIL_IF(global.mutability == Global::Mutable, &quot;Mutable Globals aren&#39;t supported&quot;);</span>
<span class="line-modified">! </span>
              kindIndex = m_info-&gt;globals.size();
              m_info-&gt;globals.uncheckedAppend(WTFMove(global));
              break;
          }
          }
<span class="line-new-header">--- 134,15 ---</span>
              if (UNLIKELY(!result))
                  return makeUnexpected(WTFMove(result.error()));
              break;
          }
          case ExternalKind::Global: {
<span class="line-modified">!             GlobalInformation global;</span>
              WASM_FAIL_IF_HELPER_FAILS(parseGlobalType(global));
<span class="line-modified">!             // Only mutable globals need floating bindings.</span>
<span class="line-modified">!             if (global.mutability == GlobalInformation::Mutability::Mutable)</span>
<span class="line-added">+                 global.bindingMode = GlobalInformation::BindingMode::Portable;</span>
              kindIndex = m_info-&gt;globals.size();
              m_info-&gt;globals.uncheckedAppend(WTFMove(global));
              break;
          }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 280,22 ***</span>
      WASM_PARSER_FAIL_IF(globalCount &gt; maxGlobals, &quot;Global section&#39;s count is too big &quot;, globalCount, &quot; maximum &quot;, maxGlobals);
      size_t totalBytes = globalCount + m_info-&gt;firstInternalGlobal;
      WASM_PARSER_FAIL_IF((static_cast&lt;uint32_t&gt;(totalBytes) &lt; globalCount) || !m_info-&gt;globals.tryReserveCapacity(totalBytes), &quot;can&#39;t allocate memory for &quot;, totalBytes, &quot; globals&quot;);
  
      for (uint32_t globalIndex = 0; globalIndex &lt; globalCount; ++globalIndex) {
<span class="line-modified">!         Global global;</span>
          uint8_t initOpcode;
  
          WASM_FAIL_IF_HELPER_FAILS(parseGlobalType(global));
          Type typeForInitOpcode;
          WASM_FAIL_IF_HELPER_FAILS(parseInitExpr(initOpcode, global.initialBitsOrImportNumber, typeForInitOpcode));
          if (initOpcode == GetGlobal)
<span class="line-modified">!             global.initializationType = Global::FromGlobalImport;</span>
          else if (initOpcode == RefFunc)
<span class="line-modified">!             global.initializationType = Global::FromRefFunc;</span>
          else
<span class="line-modified">!             global.initializationType = Global::FromExpression;</span>
          WASM_PARSER_FAIL_IF(!isSubtype(typeForInitOpcode, global.type), &quot;Global init_expr opcode of type &quot;, typeForInitOpcode, &quot; doesn&#39;t match global&#39;s type &quot;, global.type);
  
          m_info-&gt;globals.uncheckedAppend(WTFMove(global));
      }
  
<span class="line-new-header">--- 284,22 ---</span>
      WASM_PARSER_FAIL_IF(globalCount &gt; maxGlobals, &quot;Global section&#39;s count is too big &quot;, globalCount, &quot; maximum &quot;, maxGlobals);
      size_t totalBytes = globalCount + m_info-&gt;firstInternalGlobal;
      WASM_PARSER_FAIL_IF((static_cast&lt;uint32_t&gt;(totalBytes) &lt; globalCount) || !m_info-&gt;globals.tryReserveCapacity(totalBytes), &quot;can&#39;t allocate memory for &quot;, totalBytes, &quot; globals&quot;);
  
      for (uint32_t globalIndex = 0; globalIndex &lt; globalCount; ++globalIndex) {
<span class="line-modified">!         GlobalInformation global;</span>
          uint8_t initOpcode;
  
          WASM_FAIL_IF_HELPER_FAILS(parseGlobalType(global));
          Type typeForInitOpcode;
          WASM_FAIL_IF_HELPER_FAILS(parseInitExpr(initOpcode, global.initialBitsOrImportNumber, typeForInitOpcode));
          if (initOpcode == GetGlobal)
<span class="line-modified">!             global.initializationType = GlobalInformation::FromGlobalImport;</span>
          else if (initOpcode == RefFunc)
<span class="line-modified">!             global.initializationType = GlobalInformation::FromRefFunc;</span>
          else
<span class="line-modified">!             global.initializationType = GlobalInformation::FromExpression;</span>
          WASM_PARSER_FAIL_IF(!isSubtype(typeForInitOpcode, global.type), &quot;Global init_expr opcode of type &quot;, typeForInitOpcode, &quot; doesn&#39;t match global&#39;s type &quot;, global.type);
  
          m_info-&gt;globals.uncheckedAppend(WTFMove(global));
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 338,11 ***</span>
              WASM_PARSER_FAIL_IF(kindIndex, &quot;can&#39;t export Memory &quot;, kindIndex, &quot; only one Table is currently supported&quot;);
              break;
          }
          case ExternalKind::Global: {
              WASM_PARSER_FAIL_IF(kindIndex &gt;= m_info-&gt;globals.size(), exportNumber, &quot;th Export has invalid global number &quot;, kindIndex, &quot; it exceeds the globals count &quot;, m_info-&gt;globals.size(), &quot;, named &#39;&quot;, fieldString, &quot;&#39;&quot;);
<span class="line-modified">!             WASM_PARSER_FAIL_IF(m_info-&gt;globals[kindIndex].mutability != Global::Immutable, exportNumber, &quot;th Export isn&#39;t immutable, named &#39;&quot;, fieldString, &quot;&#39;&quot;);</span>
              break;
          }
          }
  
          m_info-&gt;exports.uncheckedAppend({ WTFMove(fieldString), kind, kindIndex });
<span class="line-new-header">--- 342,14 ---</span>
              WASM_PARSER_FAIL_IF(kindIndex, &quot;can&#39;t export Memory &quot;, kindIndex, &quot; only one Table is currently supported&quot;);
              break;
          }
          case ExternalKind::Global: {
              WASM_PARSER_FAIL_IF(kindIndex &gt;= m_info-&gt;globals.size(), exportNumber, &quot;th Export has invalid global number &quot;, kindIndex, &quot; it exceeds the globals count &quot;, m_info-&gt;globals.size(), &quot;, named &#39;&quot;, fieldString, &quot;&#39;&quot;);
<span class="line-modified">!             // Only mutable globals need floating bindings.</span>
<span class="line-added">+             GlobalInformation&amp; global = m_info-&gt;globals[kindIndex];</span>
<span class="line-added">+             if (global.mutability == GlobalInformation::Mutability::Mutable)</span>
<span class="line-added">+                 global.bindingMode = GlobalInformation::BindingMode::Portable;</span>
              break;
          }
          }
  
          m_info-&gt;exports.uncheckedAppend({ WTFMove(fieldString), kind, kindIndex });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 357,11 ***</span>
      WASM_PARSER_FAIL_IF(!parseVarUInt32(startFunctionIndex), &quot;can&#39;t get Start index&quot;);
      WASM_PARSER_FAIL_IF(startFunctionIndex &gt;= m_info-&gt;functionIndexSpaceSize(), &quot;Start index &quot;, startFunctionIndex, &quot; exceeds function index space &quot;, m_info-&gt;functionIndexSpaceSize());
      SignatureIndex signatureIndex = m_info-&gt;signatureIndexFromFunctionIndexSpace(startFunctionIndex);
      const Signature&amp; signature = SignatureInformation::get(signatureIndex);
      WASM_PARSER_FAIL_IF(signature.argumentCount(), &quot;Start function can&#39;t have arguments&quot;);
<span class="line-modified">!     WASM_PARSER_FAIL_IF(signature.returnType() != Void, &quot;Start function can&#39;t return a value&quot;);</span>
      m_info-&gt;startFunctionIndexSpace = startFunctionIndex;
      return { };
  }
  
  auto SectionParser::parseElement() -&gt; PartialResult
<span class="line-new-header">--- 364,11 ---</span>
      WASM_PARSER_FAIL_IF(!parseVarUInt32(startFunctionIndex), &quot;can&#39;t get Start index&quot;);
      WASM_PARSER_FAIL_IF(startFunctionIndex &gt;= m_info-&gt;functionIndexSpaceSize(), &quot;Start index &quot;, startFunctionIndex, &quot; exceeds function index space &quot;, m_info-&gt;functionIndexSpaceSize());
      SignatureIndex signatureIndex = m_info-&gt;signatureIndexFromFunctionIndexSpace(startFunctionIndex);
      const Signature&amp; signature = SignatureInformation::get(signatureIndex);
      WASM_PARSER_FAIL_IF(signature.argumentCount(), &quot;Start function can&#39;t have arguments&quot;);
<span class="line-modified">!     WASM_PARSER_FAIL_IF(!signature.returnsVoid(), &quot;Start function can&#39;t return a value&quot;);</span>
      m_info-&gt;startFunctionIndexSpace = startFunctionIndex;
      return { };
  }
  
  auto SectionParser::parseElement() -&gt; PartialResult
</pre>
<hr />
<pre>
<span class="line-old-header">*** 409,34 ***</span>
      }
  
      return { };
  }
  
<span class="line-removed">- // This function will be changed to be RELEASE_ASSERT_NOT_REACHED once we switch our parsing infrastructure to the streaming parser.</span>
  auto SectionParser::parseCode() -&gt; PartialResult
  {
<span class="line-modified">!     m_info-&gt;codeSectionSize = length();</span>
<span class="line-modified">!     uint32_t count;</span>
<span class="line-removed">-     WASM_PARSER_FAIL_IF(!parseVarUInt32(count), &quot;can&#39;t get Code section&#39;s count&quot;);</span>
<span class="line-removed">-     WASM_PARSER_FAIL_IF(count == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;Code section&#39;s count is too big &quot;, count);</span>
<span class="line-removed">-     WASM_PARSER_FAIL_IF(count != m_info-&gt;functions.size(), &quot;Code section count &quot;, count, &quot; exceeds the declared number of functions &quot;, m_info-&gt;functions.size());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (uint32_t i = 0; i &lt; count; ++i) {</span>
<span class="line-removed">-         uint32_t functionSize;</span>
<span class="line-removed">-         WASM_PARSER_FAIL_IF(!parseVarUInt32(functionSize), &quot;can&#39;t get &quot;, i, &quot;th Code function&#39;s size&quot;);</span>
<span class="line-removed">-         WASM_PARSER_FAIL_IF(functionSize &gt; length(), &quot;Code function&#39;s size &quot;, functionSize, &quot; exceeds the module&#39;s size &quot;, length());</span>
<span class="line-removed">-         WASM_PARSER_FAIL_IF(functionSize &gt; length() - m_offset, &quot;Code function&#39;s size &quot;, functionSize, &quot; exceeds the module&#39;s remaining size&quot;, length() - m_offset);</span>
<span class="line-removed">-         WASM_PARSER_FAIL_IF(functionSize &gt; maxFunctionSize, &quot;Code function&#39;s size &quot;, functionSize, &quot; is too big&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         Vector&lt;uint8_t&gt; data(functionSize);</span>
<span class="line-removed">-         std::memcpy(data.data(), source() + m_offset, functionSize);</span>
<span class="line-removed">-         m_info-&gt;functions[i].start = m_offsetInSource + m_offset;</span>
<span class="line-removed">-         m_info-&gt;functions[i].end = m_offsetInSource + m_offset + functionSize;</span>
<span class="line-removed">-         m_info-&gt;functions[i].data = WTFMove(data);</span>
<span class="line-removed">-         m_offset += functionSize;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      return { };
  }
  
  auto SectionParser::parseInitExpr(uint8_t&amp; opcode, uint64_t&amp; bitsOrImportNumber, Type&amp; resultType) -&gt; PartialResult
  {
<span class="line-new-header">--- 416,14 ---</span>
      }
  
      return { };
  }
  
  auto SectionParser::parseCode() -&gt; PartialResult
  {
<span class="line-modified">!     // The Code section is handled specially in StreamingParser.</span>
<span class="line-modified">!     RELEASE_ASSERT_NOT_REACHED();</span>
      return { };
  }
  
  auto SectionParser::parseInitExpr(uint8_t&amp; opcode, uint64_t&amp; bitsOrImportNumber, Type&amp; resultType) -&gt; PartialResult
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 479,12 ***</span>
          uint32_t index;
          WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get get_global&#39;s index&quot;);
  
          WASM_PARSER_FAIL_IF(index &gt;= m_info-&gt;globals.size(), &quot;get_global&#39;s index &quot;, index, &quot; exceeds the number of globals &quot;, m_info-&gt;globals.size());
          WASM_PARSER_FAIL_IF(index &gt;= m_info-&gt;firstInternalGlobal, &quot;get_global import kind index &quot;, index, &quot; exceeds the first internal global &quot;, m_info-&gt;firstInternalGlobal);
  
<span class="line-removed">-         ASSERT(m_info-&gt;globals[index].mutability == Global::Immutable);</span>
          resultType = m_info-&gt;globals[index].type;
          bitsOrImportNumber = index;
          break;
      }
  
<span class="line-new-header">--- 466,12 ---</span>
          uint32_t index;
          WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get get_global&#39;s index&quot;);
  
          WASM_PARSER_FAIL_IF(index &gt;= m_info-&gt;globals.size(), &quot;get_global&#39;s index &quot;, index, &quot; exceeds the number of globals &quot;, m_info-&gt;globals.size());
          WASM_PARSER_FAIL_IF(index &gt;= m_info-&gt;firstInternalGlobal, &quot;get_global import kind index &quot;, index, &quot; exceeds the first internal global &quot;, m_info-&gt;firstInternalGlobal);
<span class="line-added">+         WASM_PARSER_FAIL_IF(m_info-&gt;globals[index].mutability != GlobalInformation::Immutable, &quot;get_global import kind index &quot;, index, &quot; is mutable &quot;);</span>
  
          resultType = m_info-&gt;globals[index].type;
          bitsOrImportNumber = index;
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 513,16 ***</span>
      WASM_PARSER_FAIL_IF(endOpcode != OpType::End, &quot;init_expr should end with end, ended with &quot;, endOpcode);
  
      return { };
  }
  
<span class="line-modified">! auto SectionParser::parseGlobalType(Global&amp; global) -&gt; PartialResult</span>
  {
      uint8_t mutability;
      WASM_PARSER_FAIL_IF(!parseValueType(global.type), &quot;can&#39;t get Global&#39;s value type&quot;);
      WASM_PARSER_FAIL_IF(!parseVarUInt1(mutability), &quot;can&#39;t get Global type&#39;s mutability&quot;);
<span class="line-modified">!     global.mutability = static_cast&lt;Global::Mutability&gt;(mutability);</span>
      return { };
  }
  
  auto SectionParser::parseData() -&gt; PartialResult
  {
<span class="line-new-header">--- 500,16 ---</span>
      WASM_PARSER_FAIL_IF(endOpcode != OpType::End, &quot;init_expr should end with end, ended with &quot;, endOpcode);
  
      return { };
  }
  
<span class="line-modified">! auto SectionParser::parseGlobalType(GlobalInformation&amp; global) -&gt; PartialResult</span>
  {
      uint8_t mutability;
      WASM_PARSER_FAIL_IF(!parseValueType(global.type), &quot;can&#39;t get Global&#39;s value type&quot;);
      WASM_PARSER_FAIL_IF(!parseVarUInt1(mutability), &quot;can&#39;t get Global type&#39;s mutability&quot;);
<span class="line-modified">!     global.mutability = static_cast&lt;GlobalInformation::Mutability&gt;(mutability);</span>
      return { };
  }
  
  auto SectionParser::parseData() -&gt; PartialResult
  {
</pre>
<center><a href="WasmPlan.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmSectionParser.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
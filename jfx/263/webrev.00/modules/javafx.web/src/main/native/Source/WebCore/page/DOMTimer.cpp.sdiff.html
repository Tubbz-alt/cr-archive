<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/DOMTimer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Crypto.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DOMTimer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/DOMTimer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
144             nestedTimers.remove(timeoutId);
145     }
146 
147     const_iterator begin() const { return nestedTimers.begin(); }
148     const_iterator end() const { return nestedTimers.end(); }
149 
150 private:
151     static NestedTimersMap&amp; instance()
152     {
153         static NeverDestroyed&lt;NestedTimersMap&gt; map;
154         return map;
155     }
156 
157     static bool isTrackingNestedTimers;
158     HashMap&lt;int /* timeoutId */, Ref&lt;DOMTimer&gt;&gt; nestedTimers;
159 };
160 
161 bool NestedTimersMap::isTrackingNestedTimers = false;
162 
163 DOMTimer::DOMTimer(ScriptExecutionContext&amp; context, std::unique_ptr&lt;ScheduledAction&gt; action, Seconds interval, bool singleShot)
<span class="line-modified">164     : SuspendableTimer(context)</span>
165     , m_nestingLevel(context.timerNestingLevel())
166     , m_action(WTFMove(action))
167     , m_originalInterval(interval)
168     , m_throttleState(Undetermined)
169     , m_currentTimerInterval(intervalClampedToMinimum())
170     , m_userGestureTokenToForward(UserGestureIndicator::currentUserGesture())
171 {
<span class="line-removed">172     RefPtr&lt;DOMTimer&gt; reference = adoptRef(this);</span>
<span class="line-removed">173 </span>
<span class="line-removed">174     // Keep asking for the next id until we&#39;re given one that we don&#39;t already have.</span>
<span class="line-removed">175     do {</span>
<span class="line-removed">176         m_timeoutId = context.circularSequentialID();</span>
<span class="line-removed">177     } while (!context.addTimeout(m_timeoutId, *this));</span>
<span class="line-removed">178 </span>
179     if (singleShot)
180         startOneShot(m_currentTimerInterval);
181     else
182         startRepeating(m_currentTimerInterval);
183 }
184 
185 DOMTimer::~DOMTimer() = default;
186 
187 int DOMTimer::install(ScriptExecutionContext&amp; context, std::unique_ptr&lt;ScheduledAction&gt; action, Seconds timeout, bool singleShot)
188 {
<span class="line-modified">189     // DOMTimer constructor passes ownership of the initial ref on the object to the constructor.</span>
<span class="line-removed">190     // This reference will be released automatically when a one-shot timer fires, when the context</span>
<span class="line-removed">191     // is destroyed, or if explicitly cancelled by removeById.</span>
<span class="line-removed">192     DOMTimer* timer = new DOMTimer(context, WTFMove(action), timeout, singleShot);</span>
193     timer-&gt;suspendIfNeeded();






194     InspectorInstrumentation::didInstallTimer(context, timer-&gt;m_timeoutId, timeout, singleShot);
195 
196     // Keep track of nested timer installs.
197     if (NestedTimersMap* nestedTimers = NestedTimersMap::instanceForContext(context))
<span class="line-modified">198         nestedTimers-&gt;add(timer-&gt;m_timeoutId, *timer);</span>
199 #if PLATFORM(IOS_FAMILY)
200     if (is&lt;Document&gt;(context)) {
201         auto&amp; document = downcast&lt;Document&gt;(context);
<span class="line-modified">202         document.contentChangeObserver().didInstallDOMTimer(*timer, timeout, singleShot);</span>
203         if (DeferDOMTimersForScope::isDeferring())
<span class="line-modified">204             document.domTimerHoldingTank().add(*timer);</span>
205     }
206 #endif
207     return timer-&gt;m_timeoutId;
208 }
209 
210 void DOMTimer::removeById(ScriptExecutionContext&amp; context, int timeoutId)
211 {
212     // timeout IDs have to be positive, and 0 and -1 are unsafe to
213     // even look up since they are the empty and deleted value
214     // respectively
215     if (timeoutId &lt;= 0)
216         return;
217 
218 #if PLATFORM(IOS_FAMILY)
219     if (is&lt;Document&gt;(context)) {
220         auto&amp; document = downcast&lt;Document&gt;(context);
221         if (auto* timer = document.findTimeout(timeoutId)) {
222             document.contentChangeObserver().didRemoveDOMTimer(*timer);
223             if (auto* holdingTank = document.domTimerHoldingTankIfExists())
224                 holdingTank-&gt;remove(*timer);
</pre>
<hr />
<pre>
270         }
271     }
272 }
273 
274 void DOMTimer::scriptDidInteractWithPlugin(HTMLPlugInElement&amp; pluginElement)
275 {
276     if (!DOMTimerFireState::current)
277         return;
278 
279     if (pluginElement.isUserObservable())
280         DOMTimerFireState::current-&gt;setScriptMadeUserObservableChanges();
281     else
282         DOMTimerFireState::current-&gt;setScriptMadeNonUserObservableChanges();
283 }
284 
285 void DOMTimer::fired()
286 {
287     // Retain this - if the timer is cancelled while this function is on the stack (implicitly and always
288     // for one-shot timers, or if removeById is called on itself from within an interval timer fire) then
289     // wait unit the end of this function to delete DOMTimer.
<span class="line-modified">290     RefPtr&lt;DOMTimer&gt; reference = this;</span>
291 
292     ASSERT(scriptExecutionContext());
293     ScriptExecutionContext&amp; context = *scriptExecutionContext();
294 
295 #if PLATFORM(IOS_FAMILY)
296     if (is&lt;Document&gt;(context)) {
297         auto&amp; document = downcast&lt;Document&gt;(context);
298         if (auto* holdingTank = document.domTimerHoldingTankIfExists(); holdingTank &amp;&amp; holdingTank-&gt;contains(*this)) {
299             if (!repeatInterval())
300                 startOneShot(0_s);
301             return;
302         }
303     }
304 #endif
305 
306     DOMTimerFireState fireState(context, std::min(m_nestingLevel + 1, maxTimerNestingLevel));
307 
308     if (m_userGestureTokenToForward &amp;&amp; m_userGestureTokenToForward-&gt;hasExpired(maxIntervalForUserGestureForwarding))
309         m_userGestureTokenToForward = nullptr;
310 
311     ASSERT(!isSuspended());
312     ASSERT(!context.activeDOMObjectsAreSuspended());
313     UserGestureIndicator gestureIndicator(m_userGestureTokenToForward);
314     // Only the first execution of a multi-shot timer should get an affirmative user gesture indicator.
315     m_userGestureTokenToForward = nullptr;
316 
<span class="line-modified">317     InspectorInstrumentationCookie cookie = InspectorInstrumentation::willFireTimer(context, m_timeoutId, !repeatInterval());</span>
318 
319     // Simple case for non-one-shot timers.
320     if (isActive()) {
321         if (m_nestingLevel &lt; maxTimerNestingLevel) {
322             m_nestingLevel++;
323             updateTimerIntervalIfNecessary();
324         }
325 
326         m_action-&gt;execute(context);
327 
<span class="line-modified">328         InspectorInstrumentation::didFireTimer(cookie);</span>
<span class="line-removed">329         updateThrottlingStateIfNecessary(fireState);</span>
330 

331         return;
332     }
333 
334     context.removeTimeout(m_timeoutId);
335 
336     // Keep track nested timer installs.
337     NestedTimersMap* nestedTimers = NestedTimersMap::instanceForContext(context);
338     if (nestedTimers)
339         nestedTimers-&gt;startTracking();
340 
341 #if PLATFORM(IOS_FAMILY)
342     ContentChangeObserver::DOMTimerScope observingScope(is&lt;Document&gt;(context) ? &amp;downcast&lt;Document&gt;(context) : nullptr, *this);
343 #endif
344     m_action-&gt;execute(context);
345 
<span class="line-modified">346     InspectorInstrumentation::didFireTimer(cookie);</span>
347 
348     // Check if we should throttle nested single-shot timers.
349     if (nestedTimers) {
350         for (auto&amp; idAndTimer : *nestedTimers) {
351             auto&amp; timer = idAndTimer.value;
352             if (timer-&gt;isActive() &amp;&amp; !timer-&gt;repeatInterval())
353                 timer-&gt;updateThrottlingStateIfNecessary(fireState);
354         }
355         nestedTimers-&gt;stopTracking();
356     }
357 }
358 
359 void DOMTimer::didStop()
360 {
361     // Need to release JS objects potentially protected by ScheduledAction
362     // because they can form circular references back to the ScriptExecutionContext
363     // which will cause a memory leak.
364     m_action = nullptr;
365 }
366 
</pre>
</td>
<td>
<hr />
<pre>
144             nestedTimers.remove(timeoutId);
145     }
146 
147     const_iterator begin() const { return nestedTimers.begin(); }
148     const_iterator end() const { return nestedTimers.end(); }
149 
150 private:
151     static NestedTimersMap&amp; instance()
152     {
153         static NeverDestroyed&lt;NestedTimersMap&gt; map;
154         return map;
155     }
156 
157     static bool isTrackingNestedTimers;
158     HashMap&lt;int /* timeoutId */, Ref&lt;DOMTimer&gt;&gt; nestedTimers;
159 };
160 
161 bool NestedTimersMap::isTrackingNestedTimers = false;
162 
163 DOMTimer::DOMTimer(ScriptExecutionContext&amp; context, std::unique_ptr&lt;ScheduledAction&gt; action, Seconds interval, bool singleShot)
<span class="line-modified">164     : SuspendableTimerBase(&amp;context)</span>
165     , m_nestingLevel(context.timerNestingLevel())
166     , m_action(WTFMove(action))
167     , m_originalInterval(interval)
168     , m_throttleState(Undetermined)
169     , m_currentTimerInterval(intervalClampedToMinimum())
170     , m_userGestureTokenToForward(UserGestureIndicator::currentUserGesture())
171 {







172     if (singleShot)
173         startOneShot(m_currentTimerInterval);
174     else
175         startRepeating(m_currentTimerInterval);
176 }
177 
178 DOMTimer::~DOMTimer() = default;
179 
180 int DOMTimer::install(ScriptExecutionContext&amp; context, std::unique_ptr&lt;ScheduledAction&gt; action, Seconds timeout, bool singleShot)
181 {
<span class="line-modified">182     Ref&lt;DOMTimer&gt; timer = adoptRef(*new DOMTimer(context, WTFMove(action), timeout, singleShot));</span>



183     timer-&gt;suspendIfNeeded();
<span class="line-added">184 </span>
<span class="line-added">185     // Keep asking for the next id until we&#39;re given one that we don&#39;t already have.</span>
<span class="line-added">186     do {</span>
<span class="line-added">187         timer-&gt;m_timeoutId = context.circularSequentialID();</span>
<span class="line-added">188     } while (!context.addTimeout(timer-&gt;m_timeoutId, timer.get()));</span>
<span class="line-added">189 </span>
190     InspectorInstrumentation::didInstallTimer(context, timer-&gt;m_timeoutId, timeout, singleShot);
191 
192     // Keep track of nested timer installs.
193     if (NestedTimersMap* nestedTimers = NestedTimersMap::instanceForContext(context))
<span class="line-modified">194         nestedTimers-&gt;add(timer-&gt;m_timeoutId, timer.get());</span>
195 #if PLATFORM(IOS_FAMILY)
196     if (is&lt;Document&gt;(context)) {
197         auto&amp; document = downcast&lt;Document&gt;(context);
<span class="line-modified">198         document.contentChangeObserver().didInstallDOMTimer(timer.get(), timeout, singleShot);</span>
199         if (DeferDOMTimersForScope::isDeferring())
<span class="line-modified">200             document.domTimerHoldingTank().add(timer.get());</span>
201     }
202 #endif
203     return timer-&gt;m_timeoutId;
204 }
205 
206 void DOMTimer::removeById(ScriptExecutionContext&amp; context, int timeoutId)
207 {
208     // timeout IDs have to be positive, and 0 and -1 are unsafe to
209     // even look up since they are the empty and deleted value
210     // respectively
211     if (timeoutId &lt;= 0)
212         return;
213 
214 #if PLATFORM(IOS_FAMILY)
215     if (is&lt;Document&gt;(context)) {
216         auto&amp; document = downcast&lt;Document&gt;(context);
217         if (auto* timer = document.findTimeout(timeoutId)) {
218             document.contentChangeObserver().didRemoveDOMTimer(*timer);
219             if (auto* holdingTank = document.domTimerHoldingTankIfExists())
220                 holdingTank-&gt;remove(*timer);
</pre>
<hr />
<pre>
266         }
267     }
268 }
269 
270 void DOMTimer::scriptDidInteractWithPlugin(HTMLPlugInElement&amp; pluginElement)
271 {
272     if (!DOMTimerFireState::current)
273         return;
274 
275     if (pluginElement.isUserObservable())
276         DOMTimerFireState::current-&gt;setScriptMadeUserObservableChanges();
277     else
278         DOMTimerFireState::current-&gt;setScriptMadeNonUserObservableChanges();
279 }
280 
281 void DOMTimer::fired()
282 {
283     // Retain this - if the timer is cancelled while this function is on the stack (implicitly and always
284     // for one-shot timers, or if removeById is called on itself from within an interval timer fire) then
285     // wait unit the end of this function to delete DOMTimer.
<span class="line-modified">286     Ref&lt;DOMTimer&gt; protectedThis(*this);</span>
287 
288     ASSERT(scriptExecutionContext());
289     ScriptExecutionContext&amp; context = *scriptExecutionContext();
290 
291 #if PLATFORM(IOS_FAMILY)
292     if (is&lt;Document&gt;(context)) {
293         auto&amp; document = downcast&lt;Document&gt;(context);
294         if (auto* holdingTank = document.domTimerHoldingTankIfExists(); holdingTank &amp;&amp; holdingTank-&gt;contains(*this)) {
295             if (!repeatInterval())
296                 startOneShot(0_s);
297             return;
298         }
299     }
300 #endif
301 
302     DOMTimerFireState fireState(context, std::min(m_nestingLevel + 1, maxTimerNestingLevel));
303 
304     if (m_userGestureTokenToForward &amp;&amp; m_userGestureTokenToForward-&gt;hasExpired(maxIntervalForUserGestureForwarding))
305         m_userGestureTokenToForward = nullptr;
306 
307     ASSERT(!isSuspended());
308     ASSERT(!context.activeDOMObjectsAreSuspended());
309     UserGestureIndicator gestureIndicator(m_userGestureTokenToForward);
310     // Only the first execution of a multi-shot timer should get an affirmative user gesture indicator.
311     m_userGestureTokenToForward = nullptr;
312 
<span class="line-modified">313     InspectorInstrumentation::willFireTimer(context, m_timeoutId, !repeatInterval());</span>
314 
315     // Simple case for non-one-shot timers.
316     if (isActive()) {
317         if (m_nestingLevel &lt; maxTimerNestingLevel) {
318             m_nestingLevel++;
319             updateTimerIntervalIfNecessary();
320         }
321 
322         m_action-&gt;execute(context);
323 
<span class="line-modified">324         InspectorInstrumentation::didFireTimer(context);</span>

325 
<span class="line-added">326         updateThrottlingStateIfNecessary(fireState);</span>
327         return;
328     }
329 
330     context.removeTimeout(m_timeoutId);
331 
332     // Keep track nested timer installs.
333     NestedTimersMap* nestedTimers = NestedTimersMap::instanceForContext(context);
334     if (nestedTimers)
335         nestedTimers-&gt;startTracking();
336 
337 #if PLATFORM(IOS_FAMILY)
338     ContentChangeObserver::DOMTimerScope observingScope(is&lt;Document&gt;(context) ? &amp;downcast&lt;Document&gt;(context) : nullptr, *this);
339 #endif
340     m_action-&gt;execute(context);
341 
<span class="line-modified">342     InspectorInstrumentation::didFireTimer(context);</span>
343 
344     // Check if we should throttle nested single-shot timers.
345     if (nestedTimers) {
346         for (auto&amp; idAndTimer : *nestedTimers) {
347             auto&amp; timer = idAndTimer.value;
348             if (timer-&gt;isActive() &amp;&amp; !timer-&gt;repeatInterval())
349                 timer-&gt;updateThrottlingStateIfNecessary(fireState);
350         }
351         nestedTimers-&gt;stopTracking();
352     }
353 }
354 
355 void DOMTimer::didStop()
356 {
357     // Need to release JS objects potentially protected by ScheduledAction
358     // because they can form circular references back to the ScriptExecutionContext
359     // which will cause a memory leak.
360     m_action = nullptr;
361 }
362 
</pre>
</td>
</tr>
</table>
<center><a href="Crypto.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DOMTimer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
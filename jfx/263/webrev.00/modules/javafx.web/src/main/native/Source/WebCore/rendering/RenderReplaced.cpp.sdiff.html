<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderReplaced.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderQuote.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderScrollbar.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderReplaced.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  *
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;RenderReplaced.h&quot;
 26 
 27 #include &quot;DocumentMarkerController.h&quot;
 28 #include &quot;FloatRoundedRect.h&quot;
 29 #include &quot;Frame.h&quot;
 30 #include &quot;GraphicsContext.h&quot;
 31 #include &quot;HTMLElement.h&quot;


 32 #include &quot;InlineElementBox.h&quot;
 33 #include &quot;LayoutRepainter.h&quot;
 34 #include &quot;RenderBlock.h&quot;
 35 #include &quot;RenderFragmentedFlow.h&quot;
 36 #include &quot;RenderImage.h&quot;
 37 #include &quot;RenderLayer.h&quot;
 38 #include &quot;RenderTheme.h&quot;
 39 #include &quot;RenderView.h&quot;
 40 #include &quot;RenderedDocumentMarker.h&quot;

 41 #include &quot;VisiblePosition.h&quot;
 42 #include &lt;wtf/IsoMallocInlines.h&gt;
 43 #include &lt;wtf/StackStats.h&gt;
 44 
 45 namespace WebCore {
 46 
 47 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderReplaced);
 48 
 49 const int cDefaultWidth = 300;
 50 const int cDefaultHeight = 150;
 51 
 52 RenderReplaced::RenderReplaced(Element&amp; element, RenderStyle&amp;&amp; style)
 53     : RenderBox(element, WTFMove(style), RenderReplacedFlag)
 54     , m_intrinsicSize(cDefaultWidth, cDefaultHeight)
 55 {
 56     setReplaced(true);
 57 }
 58 
 59 RenderReplaced::RenderReplaced(Element&amp; element, RenderStyle&amp;&amp; style, const LayoutSize&amp; intrinsicSize)
 60     : RenderBox(element, WTFMove(style), RenderReplacedFlag)
</pre>
<hr />
<pre>
420         break;
421     }
422 
423     LengthPoint objectPosition = style().objectPosition();
424 
425     LayoutUnit xOffset = minimumValueForLength(objectPosition.x(), contentRect.width() - finalRect.width());
426     LayoutUnit yOffset = minimumValueForLength(objectPosition.y(), contentRect.height() - finalRect.height());
427 
428     finalRect.move(xOffset, yOffset);
429 
430     return finalRect;
431 }
432 
433 void RenderReplaced::computeIntrinsicRatioInformation(FloatSize&amp; intrinsicSize, double&amp; intrinsicRatio) const
434 {
435     // If there&#39;s an embeddedContentBox() of a remote, referenced document available, this code-path should never be used.
436     ASSERT(!embeddedContentBox());
437     intrinsicSize = FloatSize(intrinsicLogicalWidth(), intrinsicLogicalHeight());
438 
439     // Figure out if we need to compute an intrinsic ratio.
<span class="line-modified">440     if (intrinsicSize.isEmpty() || !hasAspectRatio())</span>
441         return;
442 



















443     intrinsicRatio = intrinsicSize.width() / intrinsicSize.height();
444 }
445 
446 LayoutUnit RenderReplaced::computeConstrainedLogicalWidth(ShouldComputePreferred shouldComputePreferred) const
447 {
448     if (shouldComputePreferred == ComputePreferred)
449         return computeReplacedLogicalWidthRespectingMinMaxWidth(0_lu, ComputePreferred);
450 
451     // The aforementioned &#39;constraint equation&#39; used for block-level, non-replaced
452     // elements in normal flow:
453     // &#39;margin-left&#39; + &#39;border-left-width&#39; + &#39;padding-left&#39; + &#39;width&#39; +
454     // &#39;padding-right&#39; + &#39;border-right-width&#39; + &#39;margin-right&#39; = width of
455     // containing block
456     LayoutUnit logicalWidth = containingBlock()-&gt;availableLogicalWidth();
457 
458     // This solves above equation for &#39;width&#39; (== logicalWidth).
459     LayoutUnit marginStart = minimumValueForLength(style().marginStart(), logicalWidth);
460     LayoutUnit marginEnd = minimumValueForLength(style().marginEnd(), logicalWidth);
<span class="line-modified">461     logicalWidth = std::max(0_lu, (logicalWidth - (marginStart + marginEnd + (size().width() - clientWidth()))));</span>


462     return computeReplacedLogicalWidthRespectingMinMaxWidth(logicalWidth, shouldComputePreferred);
463 }
464 
465 LayoutUnit RenderReplaced::computeReplacedLogicalWidth(ShouldComputePreferred shouldComputePreferred) const
466 {
467     if (style().logicalWidth().isSpecified() || style().logicalWidth().isIntrinsic())
468         return computeReplacedLogicalWidthRespectingMinMaxWidth(computeReplacedLogicalWidthUsing(MainOrPreferredSize, style().logicalWidth()), shouldComputePreferred);
469 
470     RenderBox* contentRenderer = embeddedContentBox();
471 
472     // 10.3.2 Inline, replaced elements: http://www.w3.org/TR/CSS21/visudet.html#inline-replaced-width
473     double intrinsicRatio = 0;
474     FloatSize constrainedSize;
475     computeAspectRatioInformationForRenderBox(contentRenderer, constrainedSize, intrinsicRatio);
476 
477     if (style().logicalWidth().isAuto()) {
478         bool computedHeightIsAuto = style().logicalHeight().isAuto();
479         bool hasIntrinsicWidth = constrainedSize.width() &gt; 0;
480 
481         // If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element also has an intrinsic width, then that intrinsic width is the used value of &#39;width&#39;.
</pre>
<hr />
<pre>
648     return LayoutRect(newLogicalTop, 0_lu, rootBox.selectionHeight(), height());
649 }
650 
651 void RenderReplaced::setSelectionState(SelectionState state)
652 {
653     // The selection state for our containing block hierarchy is updated by the base class call.
654     RenderBox::setSelectionState(state);
655 
656     if (m_inlineBoxWrapper &amp;&amp; canUpdateSelectionOnRootLineBoxes())
657         m_inlineBoxWrapper-&gt;root().setHasSelectedChildren(isSelected());
658 }
659 
660 bool RenderReplaced::isSelected() const
661 {
662     SelectionState state = selectionState();
663     if (state == SelectionNone)
664         return false;
665     if (state == SelectionInside)
666         return true;
667 
<span class="line-modified">668     auto selectionStart = view().selection().startPosition();</span>
<span class="line-modified">669     auto selectionEnd = view().selection().endPosition();</span>
670     if (state == SelectionStart)
671         return !selectionStart;
672 
673     unsigned end = element()-&gt;hasChildNodes() ? element()-&gt;countChildNodes() : 1;
674     if (state == SelectionEnd)
675         return selectionEnd == end;
676     if (state == SelectionBoth)
677         return !selectionStart &amp;&amp; selectionEnd == end;
678     ASSERT_NOT_REACHED();
679     return false;
680 }
681 
682 LayoutRect RenderReplaced::clippedOverflowRectForRepaint(const RenderLayerModelObject* repaintContainer) const
683 {
684     if (style().visibility() != Visibility::Visible &amp;&amp; !enclosingLayer()-&gt;hasVisibleContent())
685         return LayoutRect();
686 
687     // The selectionRect can project outside of the overflowRect, so take their union
688     // for repainting to avoid selection painting glitches.
689     LayoutRect r = unionRect(localSelectionRect(false), visualOverflowRect());
</pre>
</td>
<td>
<hr />
<pre>
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  *
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;RenderReplaced.h&quot;
 26 
 27 #include &quot;DocumentMarkerController.h&quot;
 28 #include &quot;FloatRoundedRect.h&quot;
 29 #include &quot;Frame.h&quot;
 30 #include &quot;GraphicsContext.h&quot;
 31 #include &quot;HTMLElement.h&quot;
<span class="line-added"> 32 #include &quot;HTMLImageElement.h&quot;</span>
<span class="line-added"> 33 #include &quot;HTMLParserIdioms.h&quot;</span>
 34 #include &quot;InlineElementBox.h&quot;
 35 #include &quot;LayoutRepainter.h&quot;
 36 #include &quot;RenderBlock.h&quot;
 37 #include &quot;RenderFragmentedFlow.h&quot;
 38 #include &quot;RenderImage.h&quot;
 39 #include &quot;RenderLayer.h&quot;
 40 #include &quot;RenderTheme.h&quot;
 41 #include &quot;RenderView.h&quot;
 42 #include &quot;RenderedDocumentMarker.h&quot;
<span class="line-added"> 43 #include &quot;Settings.h&quot;</span>
 44 #include &quot;VisiblePosition.h&quot;
 45 #include &lt;wtf/IsoMallocInlines.h&gt;
 46 #include &lt;wtf/StackStats.h&gt;
 47 
 48 namespace WebCore {
 49 
 50 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderReplaced);
 51 
 52 const int cDefaultWidth = 300;
 53 const int cDefaultHeight = 150;
 54 
 55 RenderReplaced::RenderReplaced(Element&amp; element, RenderStyle&amp;&amp; style)
 56     : RenderBox(element, WTFMove(style), RenderReplacedFlag)
 57     , m_intrinsicSize(cDefaultWidth, cDefaultHeight)
 58 {
 59     setReplaced(true);
 60 }
 61 
 62 RenderReplaced::RenderReplaced(Element&amp; element, RenderStyle&amp;&amp; style, const LayoutSize&amp; intrinsicSize)
 63     : RenderBox(element, WTFMove(style), RenderReplacedFlag)
</pre>
<hr />
<pre>
423         break;
424     }
425 
426     LengthPoint objectPosition = style().objectPosition();
427 
428     LayoutUnit xOffset = minimumValueForLength(objectPosition.x(), contentRect.width() - finalRect.width());
429     LayoutUnit yOffset = minimumValueForLength(objectPosition.y(), contentRect.height() - finalRect.height());
430 
431     finalRect.move(xOffset, yOffset);
432 
433     return finalRect;
434 }
435 
436 void RenderReplaced::computeIntrinsicRatioInformation(FloatSize&amp; intrinsicSize, double&amp; intrinsicRatio) const
437 {
438     // If there&#39;s an embeddedContentBox() of a remote, referenced document available, this code-path should never be used.
439     ASSERT(!embeddedContentBox());
440     intrinsicSize = FloatSize(intrinsicLogicalWidth(), intrinsicLogicalHeight());
441 
442     // Figure out if we need to compute an intrinsic ratio.
<span class="line-modified">443     if (!hasAspectRatio())</span>
444         return;
445 
<span class="line-added">446     if (intrinsicSize.isEmpty()) {</span>
<span class="line-added">447         if (!settings().aspectRatioOfImgFromWidthAndHeightEnabled())</span>
<span class="line-added">448             return;</span>
<span class="line-added">449 </span>
<span class="line-added">450         auto* node = element();</span>
<span class="line-added">451         // The aspectRatioOfImgFromWidthAndHeight only applies to &lt;img&gt;.</span>
<span class="line-added">452         if (!node || !is&lt;HTMLImageElement&gt;(*node) || !node-&gt;hasAttribute(HTMLNames::widthAttr) || !node-&gt;hasAttribute(HTMLNames::heightAttr))</span>
<span class="line-added">453             return;</span>
<span class="line-added">454 </span>
<span class="line-added">455         // We shouldn&#39;t override the aspect-ratio when the &lt;img&gt; element has an empty src attribute.</span>
<span class="line-added">456         if (!is&lt;RenderImage&gt;(*this) || !downcast&lt;RenderImage&gt;(*this).cachedImage())</span>
<span class="line-added">457             return;</span>
<span class="line-added">458 </span>
<span class="line-added">459         intrinsicSize.setWidth(parseValidHTMLFloatingPointNumber(node-&gt;getAttribute(HTMLNames::widthAttr)).valueOr(0));</span>
<span class="line-added">460         intrinsicSize.setHeight(parseValidHTMLFloatingPointNumber(node-&gt;getAttribute(HTMLNames::heightAttr)).valueOr(0));</span>
<span class="line-added">461         if (intrinsicSize.isEmpty())</span>
<span class="line-added">462             return;</span>
<span class="line-added">463     }</span>
<span class="line-added">464 </span>
465     intrinsicRatio = intrinsicSize.width() / intrinsicSize.height();
466 }
467 
468 LayoutUnit RenderReplaced::computeConstrainedLogicalWidth(ShouldComputePreferred shouldComputePreferred) const
469 {
470     if (shouldComputePreferred == ComputePreferred)
471         return computeReplacedLogicalWidthRespectingMinMaxWidth(0_lu, ComputePreferred);
472 
473     // The aforementioned &#39;constraint equation&#39; used for block-level, non-replaced
474     // elements in normal flow:
475     // &#39;margin-left&#39; + &#39;border-left-width&#39; + &#39;padding-left&#39; + &#39;width&#39; +
476     // &#39;padding-right&#39; + &#39;border-right-width&#39; + &#39;margin-right&#39; = width of
477     // containing block
478     LayoutUnit logicalWidth = containingBlock()-&gt;availableLogicalWidth();
479 
480     // This solves above equation for &#39;width&#39; (== logicalWidth).
481     LayoutUnit marginStart = minimumValueForLength(style().marginStart(), logicalWidth);
482     LayoutUnit marginEnd = minimumValueForLength(style().marginEnd(), logicalWidth);
<span class="line-modified">483 </span>
<span class="line-added">484     // FIXME: This expression does not align with the comment above, which is quoting https://www.w3.org/TR/CSS22/visudet.html#blockwidth.</span>
<span class="line-added">485     logicalWidth = std::max(0_lu, (logicalWidth - (marginStart + marginEnd + borderLeft() + borderRight())));</span>
486     return computeReplacedLogicalWidthRespectingMinMaxWidth(logicalWidth, shouldComputePreferred);
487 }
488 
489 LayoutUnit RenderReplaced::computeReplacedLogicalWidth(ShouldComputePreferred shouldComputePreferred) const
490 {
491     if (style().logicalWidth().isSpecified() || style().logicalWidth().isIntrinsic())
492         return computeReplacedLogicalWidthRespectingMinMaxWidth(computeReplacedLogicalWidthUsing(MainOrPreferredSize, style().logicalWidth()), shouldComputePreferred);
493 
494     RenderBox* contentRenderer = embeddedContentBox();
495 
496     // 10.3.2 Inline, replaced elements: http://www.w3.org/TR/CSS21/visudet.html#inline-replaced-width
497     double intrinsicRatio = 0;
498     FloatSize constrainedSize;
499     computeAspectRatioInformationForRenderBox(contentRenderer, constrainedSize, intrinsicRatio);
500 
501     if (style().logicalWidth().isAuto()) {
502         bool computedHeightIsAuto = style().logicalHeight().isAuto();
503         bool hasIntrinsicWidth = constrainedSize.width() &gt; 0;
504 
505         // If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element also has an intrinsic width, then that intrinsic width is the used value of &#39;width&#39;.
</pre>
<hr />
<pre>
672     return LayoutRect(newLogicalTop, 0_lu, rootBox.selectionHeight(), height());
673 }
674 
675 void RenderReplaced::setSelectionState(SelectionState state)
676 {
677     // The selection state for our containing block hierarchy is updated by the base class call.
678     RenderBox::setSelectionState(state);
679 
680     if (m_inlineBoxWrapper &amp;&amp; canUpdateSelectionOnRootLineBoxes())
681         m_inlineBoxWrapper-&gt;root().setHasSelectedChildren(isSelected());
682 }
683 
684 bool RenderReplaced::isSelected() const
685 {
686     SelectionState state = selectionState();
687     if (state == SelectionNone)
688         return false;
689     if (state == SelectionInside)
690         return true;
691 
<span class="line-modified">692     auto selectionStart = view().selection().startOffset();</span>
<span class="line-modified">693     auto selectionEnd = view().selection().endOffset();</span>
694     if (state == SelectionStart)
695         return !selectionStart;
696 
697     unsigned end = element()-&gt;hasChildNodes() ? element()-&gt;countChildNodes() : 1;
698     if (state == SelectionEnd)
699         return selectionEnd == end;
700     if (state == SelectionBoth)
701         return !selectionStart &amp;&amp; selectionEnd == end;
702     ASSERT_NOT_REACHED();
703     return false;
704 }
705 
706 LayoutRect RenderReplaced::clippedOverflowRectForRepaint(const RenderLayerModelObject* repaintContainer) const
707 {
708     if (style().visibility() != Visibility::Visible &amp;&amp; !enclosingLayer()-&gt;hasVisibleContent())
709         return LayoutRect();
710 
711     // The selectionRect can project outside of the overflowRect, so take their union
712     // for repainting to avoid selection painting glitches.
713     LayoutRect r = unionRect(localSelectionRect(false), visualOverflowRect());
</pre>
</td>
</tr>
</table>
<center><a href="RenderQuote.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderScrollbar.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
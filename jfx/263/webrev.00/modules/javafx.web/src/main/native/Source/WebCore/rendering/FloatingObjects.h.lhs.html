<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/FloatingObjects.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2007 David Smith (catfish.man@gmail.com)
  5  * Copyright (C) 2003-2019 Apple Inc. All rights reserved.
  6  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  */
 23 
 24 #pragma once
 25 
<a name="1" id="anc1"></a><span class="line-removed"> 26 #include &quot;PODIntervalTree.h&quot;</span>
 27 #include &quot;RootInlineBox.h&quot;
 28 #include &lt;wtf/ListHashSet.h&gt;
 29 #include &lt;wtf/WeakPtr.h&gt;
 30 
 31 namespace WebCore {
 32 
 33 class RenderBlockFlow;
 34 class RenderBox;
 35 
<a name="2" id="anc2"></a>


 36 class FloatingObject {
 37     WTF_MAKE_NONCOPYABLE(FloatingObject); WTF_MAKE_FAST_ALLOCATED;
 38 public:
 39     // Note that Type uses bits so you can use FloatLeftRight as a mask to query for both left and right.
 40     enum Type { FloatLeft = 1, FloatRight = 2, FloatLeftRight = 3 };
 41 
 42     static std::unique_ptr&lt;FloatingObject&gt; create(RenderBox&amp;);
 43     std::unique_ptr&lt;FloatingObject&gt; copyToNewContainer(LayoutSize, bool shouldPaint = false, bool isDescendant = false) const;
 44     std::unique_ptr&lt;FloatingObject&gt; cloneForNewParent() const;
 45 
 46     explicit FloatingObject(RenderBox&amp;);
 47     FloatingObject(RenderBox&amp;, Type, const LayoutRect&amp;, const LayoutSize&amp;, bool shouldPaint, bool isDescendant);
 48 
 49     Type type() const { return static_cast&lt;Type&gt;(m_type); }
 50     RenderBox&amp; renderer() const { return *m_renderer; }
 51 
 52     bool isPlaced() const { return m_isPlaced; }
 53     void setIsPlaced(bool placed = true) { m_isPlaced = placed; }
 54 
 55     LayoutUnit x() const { ASSERT(isPlaced()); return m_frameRect.x(); }
 56     LayoutUnit maxX() const { ASSERT(isPlaced()); return m_frameRect.maxX(); }
 57     LayoutUnit y() const { ASSERT(isPlaced()); return m_frameRect.y(); }
 58     LayoutUnit maxY() const { ASSERT(isPlaced()); return m_frameRect.maxY(); }
 59     LayoutUnit width() const { return m_frameRect.width(); }
 60     LayoutUnit height() const { return m_frameRect.height(); }
 61 
 62     void setX(LayoutUnit x) { ASSERT(!isInPlacedTree()); m_frameRect.setX(x); }
 63     void setY(LayoutUnit y) { ASSERT(!isInPlacedTree()); m_frameRect.setY(y); }
 64     void setWidth(LayoutUnit width) { ASSERT(!isInPlacedTree()); m_frameRect.setWidth(width); }
 65     void setHeight(LayoutUnit height) { ASSERT(!isInPlacedTree()); m_frameRect.setHeight(height); }
 66 
 67     void setMarginOffset(LayoutSize offset) { ASSERT(!isInPlacedTree()); m_marginOffset = offset; }
 68 
 69     const LayoutRect&amp; frameRect() const { ASSERT(isPlaced()); return m_frameRect; }
 70     void setFrameRect(const LayoutRect&amp; frameRect) { ASSERT(!isInPlacedTree()); m_frameRect = frameRect; }
 71 
 72     LayoutUnit paginationStrut() const { return m_paginationStrut; }
 73     void setPaginationStrut(LayoutUnit strut) { m_paginationStrut = strut; }
 74 
<a name="3" id="anc3"></a><span class="line-modified"> 75 #ifndef NDEBUG</span>
 76     bool isInPlacedTree() const { return m_isInPlacedTree; }
 77     void setIsInPlacedTree(bool value) { m_isInPlacedTree = value; }
 78 #endif
 79 
 80     bool shouldPaint() const { return m_shouldPaint; }
 81     void setShouldPaint(bool shouldPaint) { m_shouldPaint = shouldPaint; }
 82     bool isDescendant() const { return m_isDescendant; }
 83     void setIsDescendant(bool isDescendant) { m_isDescendant = isDescendant; }
 84 
 85     // FIXME: Callers of these methods are dangerous and should be whitelisted explicitly or removed.
 86     RootInlineBox* originatingLine() const { return m_originatingLine.get(); }
 87     void clearOriginatingLine() { m_originatingLine = nullptr; }
 88     void setOriginatingLine(RootInlineBox&amp; line) { m_originatingLine = makeWeakPtr(line); }
 89 
 90     LayoutSize locationOffsetOfBorderBox() const
 91     {
 92         ASSERT(isPlaced());
 93         return LayoutSize(m_frameRect.location().x() + m_marginOffset.width(), m_frameRect.location().y() + m_marginOffset.height());
 94     }
 95     LayoutSize marginOffset() const { ASSERT(isPlaced()); return m_marginOffset; }
 96     LayoutSize translationOffsetToAncestor() const;
 97 
<a name="4" id="anc4"></a><span class="line-removed"> 98     String debugString() const;</span>
<span class="line-removed"> 99 </span>
100 private:
101     WeakPtr&lt;RenderBox&gt; m_renderer;
102     WeakPtr&lt;RootInlineBox&gt; m_originatingLine;
103     LayoutRect m_frameRect;
104     LayoutUnit m_paginationStrut;
105     LayoutSize m_marginOffset;
106 
107     unsigned m_type : 2; // Type (left or right aligned)
108     unsigned m_shouldPaint : 1;
109     unsigned m_isDescendant : 1;
110     unsigned m_isPlaced : 1;
<a name="5" id="anc5"></a><span class="line-modified">111 #ifndef NDEBUG</span>
112     unsigned m_isInPlacedTree : 1;
113 #endif
114 };
115 
116 // FIXME: This could be simplified if we made it inherit from PtrHash&lt;std::unique_ptr&lt;FloatingObject&gt;&gt; and
117 // changed PtrHashBase to have all of its hash and equal functions bottleneck through single functions (as
118 // is done here). That would allow us to only override those master hash and equal functions.
119 struct FloatingObjectHashFunctions {
120     typedef std::unique_ptr&lt;FloatingObject&gt; T;
121     typedef typename WTF::GetPtrHelper&lt;T&gt;::PtrType PtrType;
122 
123     static unsigned hash(PtrType key) { return PtrHash&lt;RenderBox*&gt;::hash(&amp;key-&gt;renderer()); }
124     static bool equal(PtrType a, PtrType b) { return &amp;a-&gt;renderer() == &amp;b-&gt;renderer(); }
125     static const bool safeToCompareToEmptyOrDeleted = true;
126 
127     static unsigned hash(const T&amp; key) { return hash(WTF::getPtr(key)); }
128     static bool equal(const T&amp; a, const T&amp; b) { return equal(WTF::getPtr(a), WTF::getPtr(b)); }
129     static bool equal(PtrType a, const T&amp; b) { return equal(a, WTF::getPtr(b)); }
130     static bool equal(const T&amp; a, PtrType b) { return equal(WTF::getPtr(a), b); }
131 };
132 struct FloatingObjectHashTranslator {
133     static unsigned hash(const RenderBox&amp; key) { return PtrHash&lt;const RenderBox*&gt;::hash(&amp;key); }
134     static bool equal(const std::unique_ptr&lt;FloatingObject&gt;&amp; a, const RenderBox&amp; b) { return &amp;a-&gt;renderer() == &amp;b; }
135 };
136 
137 typedef ListHashSet&lt;std::unique_ptr&lt;FloatingObject&gt;, FloatingObjectHashFunctions&gt; FloatingObjectSet;
138 
139 typedef PODInterval&lt;LayoutUnit, FloatingObject*&gt; FloatingObjectInterval;
140 typedef PODIntervalTree&lt;LayoutUnit, FloatingObject*&gt; FloatingObjectTree;
141 
142 // FIXME: This is really the same thing as FloatingObjectSet.
143 // Change clients to use that set directly, and replace the moveAllToFloatInfoMap function with a takeSet function.
144 typedef HashMap&lt;RenderBox*, std::unique_ptr&lt;FloatingObject&gt;&gt; RendererToFloatInfoMap;
145 
146 class FloatingObjects {
147     WTF_MAKE_NONCOPYABLE(FloatingObjects); WTF_MAKE_FAST_ALLOCATED;
148 public:
149     explicit FloatingObjects(const RenderBlockFlow&amp;);
150     ~FloatingObjects();
151 
152     void clear();
153     void moveAllToFloatInfoMap(RendererToFloatInfoMap&amp;);
154     FloatingObject* add(std::unique_ptr&lt;FloatingObject&gt;);
155     void remove(FloatingObject*);
156     void addPlacedObject(FloatingObject*);
157     void removePlacedObject(FloatingObject*);
158     void setHorizontalWritingMode(bool b = true) { m_horizontalWritingMode = b; }
159 
160     bool hasLeftObjects() const { return m_leftObjectsCount &gt; 0; }
161     bool hasRightObjects() const { return m_rightObjectsCount &gt; 0; }
162     const FloatingObjectSet&amp; set() const { return m_set; }
163     void clearLineBoxTreePointers();
164 
165     LayoutUnit logicalLeftOffset(LayoutUnit fixedOffset, LayoutUnit logicalTop, LayoutUnit logicalHeight);
166     LayoutUnit logicalRightOffset(LayoutUnit fixedOffset, LayoutUnit logicalTop, LayoutUnit logicalHeight);
167 
168     LayoutUnit logicalLeftOffsetForPositioningFloat(LayoutUnit fixedOffset, LayoutUnit logicalTop, LayoutUnit* heightRemaining);
169     LayoutUnit logicalRightOffsetForPositioningFloat(LayoutUnit fixedOffset, LayoutUnit logicalTop, LayoutUnit* heightRemaining);
170 
171     LayoutUnit findNextFloatLogicalBottomBelow(LayoutUnit logicalHeight);
172     LayoutUnit findNextFloatLogicalBottomBelowForBlock(LayoutUnit logicalHeight);
173 
174 private:
175     const RenderBlockFlow&amp; renderer() const { return *m_renderer; }
176     void computePlacedFloatsTree();
177     const FloatingObjectTree* placedFloatsTree();
178     void increaseObjectsCount(FloatingObject::Type);
179     void decreaseObjectsCount(FloatingObject::Type);
180     FloatingObjectInterval intervalForFloatingObject(FloatingObject*);
181 
182     FloatingObjectSet m_set;
183     std::unique_ptr&lt;FloatingObjectTree&gt; m_placedFloatsTree;
184     unsigned m_leftObjectsCount;
185     unsigned m_rightObjectsCount;
186     bool m_horizontalWritingMode;
187     WeakPtr&lt;const RenderBlockFlow&gt; m_renderer;
188 };
189 
<a name="6" id="anc6"></a><span class="line-removed">190 } // namespace WebCore</span>
<span class="line-removed">191 </span>
192 #ifndef NDEBUG
<a name="7" id="anc7"></a><span class="line-modified">193 </span>
<span class="line-removed">194 namespace WTF {</span>
<span class="line-removed">195 </span>
<span class="line-removed">196 // This helper is used by PODIntervalTree for debugging purposes.</span>
<span class="line-removed">197 template&lt;&gt; struct ValueToString&lt;WebCore::FloatingObject*&gt; {</span>
<span class="line-removed">198     static String string(const WebCore::FloatingObject* floatingObject) { return floatingObject-&gt;debugString(); }</span>
<span class="line-removed">199 };</span>
<span class="line-removed">200 </span>
<span class="line-removed">201 } // namespace WTF</span>
<span class="line-removed">202 </span>
203 #endif
<a name="8" id="anc8"></a>

<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
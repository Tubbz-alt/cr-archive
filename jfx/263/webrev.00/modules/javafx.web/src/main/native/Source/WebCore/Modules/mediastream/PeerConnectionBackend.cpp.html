<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/PeerConnectionBackend.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015 Ericsson AB. All rights reserved.
  3  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer
 13  *    in the documentation and/or other materials provided with the
 14  *    distribution.
 15  * 3. Neither the name of Ericsson nor the names of its contributors
 16  *    may be used to endorse or promote products derived from this
 17  *    software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;PeerConnectionBackend.h&quot;
 34 
 35 #if ENABLE(WEB_RTC)
 36 
 37 #include &quot;EventNames.h&quot;
 38 #include &quot;JSDOMPromiseDeferred.h&quot;
 39 #include &quot;JSRTCSessionDescription.h&quot;
 40 #include &quot;LibWebRTCCertificateGenerator.h&quot;
 41 #include &quot;Logging.h&quot;
 42 #include &quot;Page.h&quot;
 43 #include &quot;RTCIceCandidate.h&quot;
 44 #include &quot;RTCPeerConnection.h&quot;
 45 #include &quot;RTCPeerConnectionIceEvent.h&quot;
 46 #include &quot;RTCRtpCapabilities.h&quot;
 47 #include &quot;RTCTrackEvent.h&quot;
 48 #include &quot;RuntimeEnabledFeatures.h&quot;
 49 #include &lt;wtf/text/StringBuilder.h&gt;
 50 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 51 
 52 namespace WebCore {
 53 
 54 using namespace PAL;
 55 
 56 #if !USE(LIBWEBRTC)
 57 static std::unique_ptr&lt;PeerConnectionBackend&gt; createNoPeerConnectionBackend(RTCPeerConnection&amp;)
 58 {
 59     return nullptr;
 60 }
 61 
 62 CreatePeerConnectionBackend PeerConnectionBackend::create = createNoPeerConnectionBackend;
 63 
 64 Optional&lt;RTCRtpCapabilities&gt; PeerConnectionBackend::receiverCapabilities(ScriptExecutionContext&amp;, const String&amp;)
 65 {
 66     ASSERT_NOT_REACHED();
 67     return { };
 68 }
 69 
 70 Optional&lt;RTCRtpCapabilities&gt; PeerConnectionBackend::senderCapabilities(ScriptExecutionContext&amp;, const String&amp;)
 71 {
 72     ASSERT_NOT_REACHED();
 73     return { };
 74 }
 75 #endif
 76 
 77 PeerConnectionBackend::PeerConnectionBackend(RTCPeerConnection&amp; peerConnection)
 78     : m_peerConnection(peerConnection)
 79 #if !RELEASE_LOG_DISABLED
 80     , m_logger(peerConnection.logger())
 81     , m_logIdentifier(peerConnection.logIdentifier())
 82 #endif
 83 {
 84 }
 85 
 86 PeerConnectionBackend::~PeerConnectionBackend() = default;
 87 
 88 void PeerConnectionBackend::createOffer(RTCOfferOptions&amp;&amp; options, PeerConnection::SessionDescriptionPromise&amp;&amp; promise)
 89 {
 90     ASSERT(!m_offerAnswerPromise);
 91     ASSERT(!m_peerConnection.isClosed());
 92 
 93     m_offerAnswerPromise = WTF::makeUnique&lt;PeerConnection::SessionDescriptionPromise&gt;(WTFMove(promise));
 94     doCreateOffer(WTFMove(options));
 95 }
 96 
 97 void PeerConnectionBackend::createOfferSucceeded(String&amp;&amp; sdp)
 98 {
 99     ASSERT(isMainThread());
100     ALWAYS_LOG(LOGIDENTIFIER, &quot;Create offer succeeded:\n&quot;, sdp);
101 
102     ASSERT(m_offerAnswerPromise);
103     m_peerConnection.doTask([this, promise = WTFMove(m_offerAnswerPromise), sdp = filterSDP(WTFMove(sdp))]() mutable {
104         if (m_peerConnection.isClosed())
105             return;
106 
107         promise-&gt;resolve(RTCSessionDescription::Init { RTCSdpType::Offer, sdp });
108     });
109 }
110 
111 void PeerConnectionBackend::createOfferFailed(Exception&amp;&amp; exception)
112 {
113     ASSERT(isMainThread());
114     ALWAYS_LOG(LOGIDENTIFIER, &quot;Create offer failed:&quot;, exception.message());
115 
116     ASSERT(m_offerAnswerPromise);
117     m_peerConnection.doTask([this, promise = WTFMove(m_offerAnswerPromise), exception = WTFMove(exception)]() mutable {
118         if (m_peerConnection.isClosed())
119             return;
120 
121         promise-&gt;reject(WTFMove(exception));
122     });
123 }
124 
125 void PeerConnectionBackend::createAnswer(RTCAnswerOptions&amp;&amp; options, PeerConnection::SessionDescriptionPromise&amp;&amp; promise)
126 {
127     ASSERT(!m_offerAnswerPromise);
128     ASSERT(!m_peerConnection.isClosed());
129 
130     m_offerAnswerPromise = WTF::makeUnique&lt;PeerConnection::SessionDescriptionPromise&gt;(WTFMove(promise));
131     doCreateAnswer(WTFMove(options));
132 }
133 
134 void PeerConnectionBackend::createAnswerSucceeded(String&amp;&amp; sdp)
135 {
136     ASSERT(isMainThread());
137     ALWAYS_LOG(LOGIDENTIFIER, &quot;Create answer succeeded:\n&quot;, sdp);
138 
139     ASSERT(m_offerAnswerPromise);
140     m_peerConnection.doTask([this, promise = WTFMove(m_offerAnswerPromise), sdp = WTFMove(sdp)]() mutable {
141         if (m_peerConnection.isClosed())
142             return;
143 
144         promise-&gt;resolve(RTCSessionDescription::Init { RTCSdpType::Answer, sdp });
145     });
146 }
147 
148 void PeerConnectionBackend::createAnswerFailed(Exception&amp;&amp; exception)
149 {
150     ASSERT(isMainThread());
151     ALWAYS_LOG(LOGIDENTIFIER, &quot;Create answer failed:&quot;, exception.message());
152 
153     ASSERT(m_offerAnswerPromise);
154     m_peerConnection.doTask([this, promise = WTFMove(m_offerAnswerPromise), exception = WTFMove(exception)]() mutable {
155         if (m_peerConnection.isClosed())
156             return;
157 
158         promise-&gt;reject(WTFMove(exception));
159     });
160 }
161 
162 static inline bool isLocalDescriptionTypeValidForState(RTCSdpType type, RTCSignalingState state)
163 {
164     switch (state) {
165     case RTCSignalingState::Stable:
166         return type == RTCSdpType::Offer;
167     case RTCSignalingState::HaveLocalOffer:
168         return type == RTCSdpType::Offer;
169     case RTCSignalingState::HaveRemoteOffer:
170         return type == RTCSdpType::Answer || type == RTCSdpType::Pranswer;
171     case RTCSignalingState::HaveLocalPranswer:
172         return type == RTCSdpType::Answer || type == RTCSdpType::Pranswer;
173     default:
174         return false;
175     };
176 
177     ASSERT_NOT_REACHED();
178     return false;
179 }
180 
181 void PeerConnectionBackend::setLocalDescription(RTCSessionDescription&amp; sessionDescription, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
182 {
183     ASSERT(!m_peerConnection.isClosed());
184 
185     if (!isLocalDescriptionTypeValidForState(sessionDescription.type(), m_peerConnection.signalingState())) {
186         promise.reject(InvalidStateError, &quot;Description type incompatible with current signaling state&quot;);
187         return;
188     }
189 
190     m_setDescriptionPromise = WTF::makeUnique&lt;DOMPromiseDeferred&lt;void&gt;&gt;(WTFMove(promise));
191     doSetLocalDescription(sessionDescription);
192 }
193 
194 void PeerConnectionBackend::setLocalDescriptionSucceeded()
195 {
196     ASSERT(isMainThread());
197     ALWAYS_LOG(LOGIDENTIFIER);
198 
199     ASSERT(m_setDescriptionPromise);
200     m_peerConnection.doTask([this, promise = WTFMove(m_setDescriptionPromise)]() mutable {
201         if (m_peerConnection.isClosed())
202             return;
203 
204         promise-&gt;resolve();
205     });
206 }
207 
208 void PeerConnectionBackend::setLocalDescriptionFailed(Exception&amp;&amp; exception)
209 {
210     ASSERT(isMainThread());
211     ALWAYS_LOG(LOGIDENTIFIER, &quot;Set local description failed:&quot;, exception.message());
212 
213     ASSERT(m_setDescriptionPromise);
214     m_peerConnection.doTask([this, promise = WTFMove(m_setDescriptionPromise), exception = WTFMove(exception)]() mutable {
215         if (m_peerConnection.isClosed())
216             return;
217 
218         promise-&gt;reject(WTFMove(exception));
219     });
220 }
221 
222 static inline bool isRemoteDescriptionTypeValidForState(RTCSdpType type, RTCSignalingState state)
223 {
224     switch (state) {
225     case RTCSignalingState::Stable:
226         return type == RTCSdpType::Offer;
227     case RTCSignalingState::HaveLocalOffer:
228         return type == RTCSdpType::Answer || type == RTCSdpType::Pranswer;
229     case RTCSignalingState::HaveRemoteOffer:
230         return type == RTCSdpType::Offer;
231     case RTCSignalingState::HaveRemotePranswer:
232         return type == RTCSdpType::Answer || type == RTCSdpType::Pranswer;
233     default:
234         return false;
235     };
236 
237     ASSERT_NOT_REACHED();
238     return false;
239 }
240 
241 void PeerConnectionBackend::setRemoteDescription(RTCSessionDescription&amp; sessionDescription, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
242 {
243     ASSERT(!m_peerConnection.isClosed());
244 
245     if (!isRemoteDescriptionTypeValidForState(sessionDescription.type(), m_peerConnection.signalingState())) {
246         promise.reject(InvalidStateError, &quot;Description type incompatible with current signaling state&quot;);
247         return;
248     }
249 
250     m_setDescriptionPromise = WTF::makeUnique&lt;DOMPromiseDeferred&lt;void&gt;&gt;(WTFMove(promise));
251     doSetRemoteDescription(sessionDescription);
252 }
253 
254 void PeerConnectionBackend::setRemoteDescriptionSucceeded()
255 {
256     ASSERT(isMainThread());
257     ALWAYS_LOG(LOGIDENTIFIER, &quot;Set remote description succeeded&quot;);
258     ASSERT(m_setDescriptionPromise);
259 
260     auto promise = WTFMove(m_setDescriptionPromise);
261     auto events = WTFMove(m_pendingTrackEvents);
262     for (auto&amp; event : events) {
263         auto&amp; track = event.track.get();
264 
265         m_peerConnection.dispatchEventWhenFeasible(RTCTrackEvent::create(eventNames().trackEvent, Event::CanBubble::No, Event::IsCancelable::No, WTFMove(event.receiver), WTFMove(event.track), WTFMove(event.streams), WTFMove(event.transceiver)));
266 
267         if (m_peerConnection.isClosed())
268             return;
269 
270         // FIXME: As per spec, we should set muted to &#39;false&#39; when starting to receive the content from network.
271         track.source().setMuted(false);
272     }
273 
274     m_peerConnection.doTask([this, promise = WTFMove(promise)]() mutable {
275         if (m_peerConnection.isClosed())
276             return;
277 
278         promise-&gt;resolve();
279     });
280 }
281 
282 void PeerConnectionBackend::setRemoteDescriptionFailed(Exception&amp;&amp; exception)
283 {
284     ASSERT(isMainThread());
285     ALWAYS_LOG(LOGIDENTIFIER, &quot;Set remote description failed:&quot;, exception.message());
286 
287     ASSERT(m_pendingTrackEvents.isEmpty());
288     m_pendingTrackEvents.clear();
289 
290     ASSERT(m_setDescriptionPromise);
291     m_peerConnection.doTask([this, promise = WTFMove(m_setDescriptionPromise), exception = WTFMove(exception)]() mutable {
292         if (m_peerConnection.isClosed())
293             return;
294 
295         promise-&gt;reject(WTFMove(exception));
296     });
297 }
298 
299 void PeerConnectionBackend::addPendingTrackEvent(PendingTrackEvent&amp;&amp; event)
300 {
301     ASSERT(!m_peerConnection.isClosed());
302     m_pendingTrackEvents.append(WTFMove(event));
303 }
304 
305 static String extractIPAddres(const String&amp; sdp)
306 {
307     ASSERT(sdp.contains(&quot; host &quot;));
308     unsigned counter = 0;
309     for (auto item : StringView { sdp }.split(&#39; &#39;)) {
310         if (++counter == 5)
311             return item.toString();
312     }
313     return { };
314 }
315 
316 void PeerConnectionBackend::addIceCandidate(RTCIceCandidate* iceCandidate, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
317 {
318     ASSERT(!m_peerConnection.isClosed());
319 
320     if (!iceCandidate) {
321         endOfIceCandidates(WTFMove(promise));
322         return;
323     }
324 
325     // FIXME: As per https://w3c.github.io/webrtc-pc/#dom-rtcpeerconnection-addicecandidate(), this check should be done before enqueuing the task.
326     if (iceCandidate-&gt;sdpMid().isNull() &amp;&amp; !iceCandidate-&gt;sdpMLineIndex()) {
327         promise.reject(Exception { TypeError, &quot;Trying to add a candidate that is missing both sdpMid and sdpMLineIndex&quot;_s });
328         return;
329     }
330     m_addIceCandidatePromise = WTF::makeUnique&lt;DOMPromiseDeferred&lt;void&gt;&gt;(WTFMove(promise));
331     doAddIceCandidate(*iceCandidate);
332 }
333 
334 void PeerConnectionBackend::addIceCandidateSucceeded()
335 {
336     ASSERT(isMainThread());
337     ALWAYS_LOG(LOGIDENTIFIER, &quot;Adding ice candidate succeeded&quot;);
338 
339     ASSERT(m_addIceCandidatePromise);
340     m_peerConnection.doTask([this, promise = WTFMove(m_addIceCandidatePromise)]() mutable {
341         if (m_peerConnection.isClosed())
342             return;
343 
344         promise-&gt;resolve();
345     });
346 }
347 
348 void PeerConnectionBackend::addIceCandidateFailed(Exception&amp;&amp; exception)
349 {
350     ASSERT(isMainThread());
351     ALWAYS_LOG(LOGIDENTIFIER, &quot;Adding ice candidate failed:&quot;, exception.message());
352 
353     ASSERT(m_addIceCandidatePromise);
354     m_peerConnection.doTask([this, promise = WTFMove(m_addIceCandidatePromise), exception = WTFMove(exception)]() mutable {
355         if (m_peerConnection.isClosed())
356             return;
357 
358         promise-&gt;reject(WTFMove(exception));
359     });
360 }
361 
362 void PeerConnectionBackend::fireICECandidateEvent(RefPtr&lt;RTCIceCandidate&gt;&amp;&amp; candidate, String&amp;&amp; serverURL)
363 {
364     ASSERT(isMainThread());
365 
366     m_peerConnection.dispatchEventWhenFeasible(RTCPeerConnectionIceEvent::create(Event::CanBubble::No, Event::IsCancelable::No, WTFMove(candidate), WTFMove(serverURL)));
367 }
368 
369 void PeerConnectionBackend::enableICECandidateFiltering()
370 {
371     m_shouldFilterICECandidates = true;
372 }
373 
374 void PeerConnectionBackend::disableICECandidateFiltering()
375 {
376     m_shouldFilterICECandidates = false;
377     for (auto&amp; pendingICECandidate : m_pendingICECandidates)
378         fireICECandidateEvent(RTCIceCandidate::create(WTFMove(pendingICECandidate.sdp), WTFMove(pendingICECandidate.mid), pendingICECandidate.sdpMLineIndex), WTFMove(pendingICECandidate.serverURL));
379     m_pendingICECandidates.clear();
380 }
381 
382 static String filterICECandidate(String&amp;&amp; sdp)
383 {
384     ASSERT(!sdp.contains(&quot; host &quot;));
385 
386     if (!sdp.contains(&quot; raddr &quot;))
387         return WTFMove(sdp);
388 
389     bool skipNextItem = false;
390     bool isFirst = true;
391     StringBuilder filteredSDP;
392     sdp.split(&#39; &#39;, [&amp;](StringView item) {
393         if (skipNextItem) {
394             skipNextItem = false;
395             return;
396         }
397         if (item == &quot;raddr&quot;) {
398             filteredSDP.append(&quot; raddr 0.0.0.0&quot;);
399             skipNextItem = true;
400             return;
401         }
402         if (item == &quot;rport&quot;) {
403             filteredSDP.append(&quot; rport 0&quot;);
404             skipNextItem = true;
405             return;
406         }
407         if (isFirst)
408             isFirst = false;
409         else
410             filteredSDP.append(&#39; &#39;);
411         filteredSDP.append(item);
412     });
413     return filteredSDP.toString();
414 }
415 
416 String PeerConnectionBackend::filterSDP(String&amp;&amp; sdp) const
417 {
418     if (!m_shouldFilterICECandidates)
419         return WTFMove(sdp);
420 
421     StringBuilder filteredSDP;
422     sdp.split(&#39;\n&#39;, [&amp;filteredSDP](StringView line) {
423         if (line.startsWith(&quot;c=IN IP4&quot;))
424             filteredSDP.append(&quot;c=IN IP4 0.0.0.0\r&quot;);
425         else if (line.startsWith(&quot;c=IN IP6&quot;))
426             filteredSDP.append(&quot;c=IN IP6 ::\r&quot;);
427         else if (!line.startsWith(&quot;a=candidate&quot;))
428             filteredSDP.append(line);
429         else if (line.find(&quot; host &quot;, 11) == notFound)
430             filteredSDP.append(filterICECandidate(line.toString()));
431         else
432             return;
433         filteredSDP.append(&#39;\n&#39;);
434     });
435     return filteredSDP.toString();
436 }
437 
438 void PeerConnectionBackend::newICECandidate(String&amp;&amp; sdp, String&amp;&amp; mid, unsigned short sdpMLineIndex, String&amp;&amp; serverURL)
439 {
440     ALWAYS_LOG(LOGIDENTIFIER, &quot;Gathered ice candidate:&quot;, sdp);
441     m_finishedGatheringCandidates = false;
442 
443     if (!m_shouldFilterICECandidates) {
444         fireICECandidateEvent(RTCIceCandidate::create(WTFMove(sdp), WTFMove(mid), sdpMLineIndex), WTFMove(serverURL));
445         return;
446     }
447     if (sdp.find(&quot; host &quot;, 0) != notFound) {
448         // FIXME: We might need to clear all pending candidates when setting again local description.
449         m_pendingICECandidates.append(PendingICECandidate { String { sdp }, WTFMove(mid), sdpMLineIndex, WTFMove(serverURL) });
450         if (RuntimeEnabledFeatures::sharedFeatures().webRTCMDNSICECandidatesEnabled()) {
451             auto ipAddress = extractIPAddres(sdp);
452             // We restrict to IPv4 candidates for now.
453             if (ipAddress.contains(&#39;.&#39;))
454                 registerMDNSName(ipAddress);
455         }
456         return;
457     }
458     fireICECandidateEvent(RTCIceCandidate::create(filterICECandidate(WTFMove(sdp)), WTFMove(mid), sdpMLineIndex), WTFMove(serverURL));
459 }
460 
461 void PeerConnectionBackend::doneGatheringCandidates()
462 {
463     ASSERT(isMainThread());
464     ALWAYS_LOG(LOGIDENTIFIER, &quot;Finished ice candidate gathering&quot;);
465     m_finishedGatheringCandidates = true;
466 
467     if (m_waitingForMDNSRegistration)
468         return;
469 
470     m_peerConnection.dispatchEventWhenFeasible(RTCPeerConnectionIceEvent::create(Event::CanBubble::No, Event::IsCancelable::No, nullptr, { }));
471     m_peerConnection.updateIceGatheringState(RTCIceGatheringState::Complete);
472     m_pendingICECandidates.clear();
473 }
474 
475 void PeerConnectionBackend::endOfIceCandidates(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
476 {
477     promise.resolve();
478 }
479 
480 void PeerConnectionBackend::registerMDNSName(const String&amp; ipAddress)
481 {
482     ++m_waitingForMDNSRegistration;
483     auto&amp; document = downcast&lt;Document&gt;(*m_peerConnection.scriptExecutionContext());
484     auto&amp; provider = document.page()-&gt;libWebRTCProvider();
485     provider.registerMDNSName(document.identifier().toUInt64(), ipAddress, [peerConnection = makeRef(m_peerConnection), this, ipAddress] (LibWebRTCProvider::MDNSNameOrError&amp;&amp; result) {
486         if (peerConnection-&gt;isStopped())
487             return;
488 
489         --m_waitingForMDNSRegistration;
490         if (!result.has_value()) {
491             m_peerConnection.scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, makeString(&quot;MDNS registration of a host candidate failed with error &quot;, (unsigned)result.error()));
492             return;
493         }
494 
495         this-&gt;finishedRegisteringMDNSName(ipAddress, result.value());
496     });
497 }
498 
499 void PeerConnectionBackend::finishedRegisteringMDNSName(const String&amp; ipAddress, const String&amp; name)
500 {
501     Vector&lt;PendingICECandidate*&gt; candidates;
502     for (auto&amp; candidate : m_pendingICECandidates) {
503         if (candidate.sdp.find(ipAddress) != notFound) {
504             auto sdp = candidate.sdp;
505             sdp.replace(ipAddress, name);
506             fireICECandidateEvent(RTCIceCandidate::create(WTFMove(sdp), WTFMove(candidate.mid), candidate.sdpMLineIndex), WTFMove(candidate.serverURL));
507             candidates.append(&amp;candidate);
508         }
509     }
510     m_pendingICECandidates.removeAllMatching([&amp;] (const auto&amp; candidate) {
511         return candidates.contains(&amp;candidate);
512     });
513 
514     if (!m_waitingForMDNSRegistration &amp;&amp; m_finishedGatheringCandidates)
515         doneGatheringCandidates();
516 }
517 
518 void PeerConnectionBackend::updateSignalingState(RTCSignalingState newSignalingState)
519 {
520     ASSERT(isMainThread());
521 
522     if (newSignalingState != m_peerConnection.signalingState()) {
523         m_peerConnection.setSignalingState(newSignalingState);
524         m_peerConnection.dispatchEventWhenFeasible(Event::create(eventNames().signalingstatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
525     }
526 }
527 
528 void PeerConnectionBackend::stop()
529 {
530     m_offerAnswerPromise = nullptr;
531     m_setDescriptionPromise = nullptr;
532     m_addIceCandidatePromise = nullptr;
533 
534     m_pendingTrackEvents.clear();
535 
536     doStop();
537 }
538 
539 void PeerConnectionBackend::markAsNeedingNegotiation()
540 {
541     if (m_negotiationNeeded)
542         return;
543 
544     m_negotiationNeeded = true;
545 
546     if (m_peerConnection.signalingState() == RTCSignalingState::Stable)
547         m_peerConnection.scheduleNegotiationNeededEvent();
548 }
549 
550 ExceptionOr&lt;Ref&lt;RTCRtpSender&gt;&gt; PeerConnectionBackend::addTrack(MediaStreamTrack&amp;, Vector&lt;String&gt;&amp;&amp;)
551 {
552     return Exception { NotSupportedError, &quot;Not implemented&quot;_s };
553 }
554 
555 ExceptionOr&lt;Ref&lt;RTCRtpTransceiver&gt;&gt; PeerConnectionBackend::addTransceiver(const String&amp;, const RTCRtpTransceiverInit&amp;)
556 {
557     return Exception { NotSupportedError, &quot;Not implemented&quot;_s };
558 }
559 
560 ExceptionOr&lt;Ref&lt;RTCRtpTransceiver&gt;&gt; PeerConnectionBackend::addTransceiver(Ref&lt;MediaStreamTrack&gt;&amp;&amp;, const RTCRtpTransceiverInit&amp;)
561 {
562     return Exception { NotSupportedError, &quot;Not implemented&quot;_s };
563 }
564 
565 void PeerConnectionBackend::generateCertificate(Document&amp; document, const CertificateInformation&amp; info, DOMPromiseDeferred&lt;IDLInterface&lt;RTCCertificate&gt;&gt;&amp;&amp; promise)
566 {
567 #if USE(LIBWEBRTC)
568     LibWebRTCCertificateGenerator::generateCertificate(document.securityOrigin(), document.page()-&gt;libWebRTCProvider(), info, WTFMove(promise));
569 #else
570     UNUSED_PARAM(document);
571     UNUSED_PARAM(expires);
572     UNUSED_PARAM(type);
573     promise.reject(NotSupportedError);
574 #endif
575 }
576 
577 ScriptExecutionContext* PeerConnectionBackend::context() const
578 {
579     return m_peerConnection.scriptExecutionContext();
580 }
581 
582 RTCRtpTransceiver* PeerConnectionBackend::transceiverFromSender(const RTCRtpSender&amp; sender)
583 {
584     for (auto&amp; transceiver : m_peerConnection.currentTransceivers()) {
585         if (&amp;transceiver-&gt;sender() == &amp;sender)
586             return transceiver.get();
587     }
588     return nullptr;
589 }
590 
591 #if !RELEASE_LOG_DISABLED
592 WTFLogChannel&amp; PeerConnectionBackend::logChannel() const
593 {
594     return LogWebRTC;
595 }
596 #endif
597 
598 } // namespace WebCore
599 
600 #endif // ENABLE(WEB_RTC)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerThread.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WorkerScriptLoader.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WorkerThread.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerThread.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,17 ***</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;WorkerThread.h&quot;
  
<span class="line-removed">- #include &quot;ContentSecurityPolicyResponseHeaders.h&quot;</span>
  #include &quot;IDBConnectionProxy.h&quot;
  #include &quot;ScriptSourceCode.h&quot;
  #include &quot;SecurityOrigin.h&quot;
  #include &quot;SocketProvider.h&quot;
  #include &quot;ThreadGlobalData.h&quot;
<span class="line-removed">- #include &lt;wtf/URL.h&gt;</span>
  #include &quot;WorkerGlobalScope.h&quot;
  #include &quot;WorkerInspectorController.h&quot;
  #include &lt;utility&gt;
  #include &lt;wtf/Lock.h&gt;
  #include &lt;wtf/NeverDestroyed.h&gt;
<span class="line-new-header">--- 25,15 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 73,54 ***</span>
  {
      LockHolder lock(workerThreadsMutex());
      return workerThreads(lock).size();
  }
  
  struct WorkerThreadStartupData {
      WTF_MAKE_NONCOPYABLE(WorkerThreadStartupData); WTF_MAKE_FAST_ALLOCATED;
  public:
<span class="line-modified">!     WorkerThreadStartupData(const URL&amp; scriptURL, const String&amp; name, const String&amp; identifier, const String&amp; userAgent, bool isOnline, const String&amp; sourceCode, WorkerThreadStartMode, const ContentSecurityPolicyResponseHeaders&amp;, bool shouldBypassMainWorldContentSecurityPolicy, const SecurityOrigin&amp; topOrigin, MonotonicTime timeOrigin, PAL::SessionID);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     URL m_scriptURL;</span>
<span class="line-modified">!     Ref&lt;SecurityOrigin&gt; m_origin;</span>
<span class="line-modified">!     String m_name;</span>
<span class="line-modified">!     String m_identifier;</span>
<span class="line-modified">!     String m_userAgent;</span>
<span class="line-removed">-     String m_sourceCode;</span>
<span class="line-removed">-     WorkerThreadStartMode m_startMode;</span>
<span class="line-removed">-     ContentSecurityPolicyResponseHeaders m_contentSecurityPolicyResponseHeaders;</span>
<span class="line-removed">-     bool m_shouldBypassMainWorldContentSecurityPolicy;</span>
<span class="line-removed">-     bool m_isOnline;</span>
<span class="line-removed">-     Ref&lt;SecurityOrigin&gt; m_topOrigin;</span>
<span class="line-removed">-     MonotonicTime m_timeOrigin;</span>
<span class="line-removed">-     PAL::SessionID m_sessionID;</span>
  };
  
<span class="line-modified">! WorkerThreadStartupData::WorkerThreadStartupData(const URL&amp; scriptURL, const String&amp; name, const String&amp; identifier, const String&amp; userAgent, bool isOnline, const String&amp; sourceCode, WorkerThreadStartMode startMode, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicyResponseHeaders, bool shouldBypassMainWorldContentSecurityPolicy, const SecurityOrigin&amp; topOrigin, MonotonicTime timeOrigin, PAL::SessionID sessionID)</span>
<span class="line-modified">!     : m_scriptURL(scriptURL.isolatedCopy())</span>
<span class="line-modified">!     , m_origin(SecurityOrigin::create(m_scriptURL)-&gt;isolatedCopy())</span>
<span class="line-modified">!     , m_name(name.isolatedCopy())</span>
<span class="line-modified">!     , m_identifier(identifier.isolatedCopy())</span>
<span class="line-modified">!     , m_userAgent(userAgent.isolatedCopy())</span>
<span class="line-removed">-     , m_sourceCode(sourceCode.isolatedCopy())</span>
<span class="line-removed">-     , m_startMode(startMode)</span>
<span class="line-removed">-     , m_contentSecurityPolicyResponseHeaders(contentSecurityPolicyResponseHeaders.isolatedCopy())</span>
<span class="line-removed">-     , m_shouldBypassMainWorldContentSecurityPolicy(shouldBypassMainWorldContentSecurityPolicy)</span>
<span class="line-removed">-     , m_isOnline(isOnline)</span>
<span class="line-removed">-     , m_topOrigin(topOrigin.isolatedCopy())</span>
<span class="line-removed">-     , m_timeOrigin(timeOrigin)</span>
<span class="line-removed">-     , m_sessionID(sessionID.isolatedCopy())</span>
  {
  }
  
<span class="line-modified">! WorkerThread::WorkerThread(const URL&amp; scriptURL, const String&amp; name, const String&amp; identifier, const String&amp; userAgent, bool isOnline, const String&amp; sourceCode, WorkerLoaderProxy&amp; workerLoaderProxy, WorkerDebuggerProxy&amp; workerDebuggerProxy, WorkerReportingProxy&amp; workerReportingProxy, WorkerThreadStartMode startMode, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicyResponseHeaders, bool shouldBypassMainWorldContentSecurityPolicy, const SecurityOrigin&amp; topOrigin, MonotonicTime timeOrigin, IDBClient::IDBConnectionProxy* connectionProxy, SocketProvider* socketProvider, JSC::RuntimeFlags runtimeFlags, PAL::SessionID sessionID)</span>
<span class="line-modified">!     : m_identifier(identifier.isolatedCopy())</span>
      , m_workerLoaderProxy(workerLoaderProxy)
      , m_workerDebuggerProxy(workerDebuggerProxy)
      , m_workerReportingProxy(workerReportingProxy)
      , m_runtimeFlags(runtimeFlags)
<span class="line-modified">!     , m_startupData(makeUnique&lt;WorkerThreadStartupData&gt;(scriptURL, name, identifier, userAgent, isOnline, sourceCode, startMode, contentSecurityPolicyResponseHeaders, shouldBypassMainWorldContentSecurityPolicy, topOrigin, timeOrigin, sessionID))</span>
  #if ENABLE(INDEXED_DATABASE)
      , m_idbConnectionProxy(connectionProxy)
  #endif
      , m_socketProvider(socketProvider)
  {
<span class="line-new-header">--- 71,53 ---</span>
  {
      LockHolder lock(workerThreadsMutex());
      return workerThreads(lock).size();
  }
  
<span class="line-added">+ WorkerParameters WorkerParameters::isolatedCopy() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return {</span>
<span class="line-added">+         scriptURL.isolatedCopy(),</span>
<span class="line-added">+         name.isolatedCopy(),</span>
<span class="line-added">+         identifier.isolatedCopy(),</span>
<span class="line-added">+         userAgent.isolatedCopy(),</span>
<span class="line-added">+         isOnline,</span>
<span class="line-added">+         contentSecurityPolicyResponseHeaders,</span>
<span class="line-added">+         shouldBypassMainWorldContentSecurityPolicy,</span>
<span class="line-added">+         timeOrigin,</span>
<span class="line-added">+         referrerPolicy,</span>
<span class="line-added">+     };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  struct WorkerThreadStartupData {
      WTF_MAKE_NONCOPYABLE(WorkerThreadStartupData); WTF_MAKE_FAST_ALLOCATED;
  public:
<span class="line-modified">!     WorkerThreadStartupData(const WorkerParameters&amp; params, const String&amp; sourceCode, WorkerThreadStartMode, const SecurityOrigin&amp; topOrigin);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     WorkerParameters params;</span>
<span class="line-modified">!     Ref&lt;SecurityOrigin&gt; origin;</span>
<span class="line-modified">!     String sourceCode;</span>
<span class="line-modified">!     WorkerThreadStartMode startMode;</span>
<span class="line-modified">!     Ref&lt;SecurityOrigin&gt; topOrigin;</span>
  };
  
<span class="line-modified">! WorkerThreadStartupData::WorkerThreadStartupData(const WorkerParameters&amp; other, const String&amp; sourceCode, WorkerThreadStartMode startMode, const SecurityOrigin&amp; topOrigin)</span>
<span class="line-modified">!     : params(other.isolatedCopy())</span>
<span class="line-modified">!     , origin(SecurityOrigin::create(other.scriptURL)-&gt;isolatedCopy())</span>
<span class="line-modified">!     , sourceCode(sourceCode.isolatedCopy())</span>
<span class="line-modified">!     , startMode(startMode)</span>
<span class="line-modified">!     , topOrigin(topOrigin.isolatedCopy())</span>
  {
  }
  
<span class="line-modified">! WorkerThread::WorkerThread(const WorkerParameters&amp; params, const String&amp; sourceCode, WorkerLoaderProxy&amp; workerLoaderProxy, WorkerDebuggerProxy&amp; workerDebuggerProxy, WorkerReportingProxy&amp; workerReportingProxy, WorkerThreadStartMode startMode, const SecurityOrigin&amp; topOrigin, IDBClient::IDBConnectionProxy* connectionProxy, SocketProvider* socketProvider, JSC::RuntimeFlags runtimeFlags)</span>
<span class="line-modified">!     : m_identifier(params.identifier.isolatedCopy())</span>
      , m_workerLoaderProxy(workerLoaderProxy)
      , m_workerDebuggerProxy(workerDebuggerProxy)
      , m_workerReportingProxy(workerReportingProxy)
      , m_runtimeFlags(runtimeFlags)
<span class="line-modified">!     , m_startupData(makeUnique&lt;WorkerThreadStartupData&gt;(params, sourceCode, startMode, topOrigin))</span>
  #if ENABLE(INDEXED_DATABASE)
      , m_idbConnectionProxy(connectionProxy)
  #endif
      , m_socketProvider(socketProvider)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 175,11 ***</span>
      {
          // Mutex protection is necessary to ensure that we don&#39;t change m_workerGlobalScope
          // while WorkerThread::stop() is accessing it. Note that WorkerThread::stop() can
          // be called before we&#39;ve finished creating the WorkerGlobalScope.
          LockHolder lock(m_threadCreationAndWorkerGlobalScopeMutex);
<span class="line-modified">!         m_workerGlobalScope = createWorkerGlobalScope(m_startupData-&gt;m_scriptURL, WTFMove(m_startupData-&gt;m_origin), m_startupData-&gt;m_name, m_startupData-&gt;m_identifier, m_startupData-&gt;m_userAgent, m_startupData-&gt;m_isOnline, m_startupData-&gt;m_contentSecurityPolicyResponseHeaders, m_startupData-&gt;m_shouldBypassMainWorldContentSecurityPolicy, WTFMove(m_startupData-&gt;m_topOrigin), m_startupData-&gt;m_timeOrigin, m_startupData-&gt;m_sessionID);</span>
  
          scriptController = m_workerGlobalScope-&gt;script();
  
          if (m_runLoop.terminated()) {
              // The worker was terminated before the thread had a chance to run. Since the context didn&#39;t exist yet,
<span class="line-new-header">--- 172,11 ---</span>
      {
          // Mutex protection is necessary to ensure that we don&#39;t change m_workerGlobalScope
          // while WorkerThread::stop() is accessing it. Note that WorkerThread::stop() can
          // be called before we&#39;ve finished creating the WorkerGlobalScope.
          LockHolder lock(m_threadCreationAndWorkerGlobalScopeMutex);
<span class="line-modified">!         m_workerGlobalScope = createWorkerGlobalScope(m_startupData-&gt;params, WTFMove(m_startupData-&gt;origin), WTFMove(m_startupData-&gt;topOrigin));</span>
  
          scriptController = m_workerGlobalScope-&gt;script();
  
          if (m_runLoop.terminated()) {
              // The worker was terminated before the thread had a chance to run. Since the context didn&#39;t exist yet,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 187,20 ***</span>
              scriptController-&gt;scheduleExecutionTermination();
              scriptController-&gt;forbidExecution();
          }
      }
  
<span class="line-modified">!     if (m_startupData-&gt;m_startMode == WorkerThreadStartMode::WaitForInspector) {</span>
          startRunningDebuggerTasks();
  
          // If the worker was somehow terminated while processing debugger commands.
          if (m_runLoop.terminated())
              scriptController-&gt;forbidExecution();
      }
  
      String exceptionMessage;
<span class="line-modified">!     scriptController-&gt;evaluate(ScriptSourceCode(m_startupData-&gt;m_sourceCode, URL(m_startupData-&gt;m_scriptURL)), &amp;exceptionMessage);</span>
  
      callOnMainThread([evaluateCallback = WTFMove(m_evaluateCallback), message = exceptionMessage.isolatedCopy()] {
          if (evaluateCallback)
              evaluateCallback(message);
      });
<span class="line-new-header">--- 184,22 ---</span>
              scriptController-&gt;scheduleExecutionTermination();
              scriptController-&gt;forbidExecution();
          }
      }
  
<span class="line-modified">!     if (m_startupData-&gt;startMode == WorkerThreadStartMode::WaitForInspector) {</span>
          startRunningDebuggerTasks();
  
          // If the worker was somehow terminated while processing debugger commands.
          if (m_runLoop.terminated())
              scriptController-&gt;forbidExecution();
      }
  
      String exceptionMessage;
<span class="line-modified">!     scriptController-&gt;evaluate(ScriptSourceCode(m_startupData-&gt;sourceCode, URL(m_startupData-&gt;params.scriptURL)), &amp;exceptionMessage);</span>
<span class="line-added">+ </span>
<span class="line-added">+     finishedEvaluatingScript();</span>
  
      callOnMainThread([evaluateCallback = WTFMove(m_evaluateCallback), message = exceptionMessage.isolatedCopy()] {
          if (evaluateCallback)
              evaluateCallback(message);
      });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 270,10 ***</span>
<span class="line-new-header">--- 269,35 ---</span>
  {
      // Does not return until terminated.
      m_runLoop.run(m_workerGlobalScope.get());
  }
  
<span class="line-added">+ void WorkerThread::suspend()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_isSuspended = true;</span>
<span class="line-added">+     runLoop().postTask([&amp;](ScriptExecutionContext&amp;) {</span>
<span class="line-added">+ #if ENABLE(INDEXED_DATABASE)</span>
<span class="line-added">+         if (m_workerGlobalScope)</span>
<span class="line-added">+             m_workerGlobalScope-&gt;suspend();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_suspensionSemaphore.wait();</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(INDEXED_DATABASE)</span>
<span class="line-added">+         if (m_workerGlobalScope)</span>
<span class="line-added">+             m_workerGlobalScope-&gt;resume();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void WorkerThread::resume()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(m_isSuspended);</span>
<span class="line-added">+     m_isSuspended = false;</span>
<span class="line-added">+     m_suspensionSemaphore.signal();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void WorkerThread::stop(WTF::Function&lt;void()&gt;&amp;&amp; stoppedCallback)
  {
      // Mutex protection is necessary to ensure that m_workerGlobalScope isn&#39;t changed by
      // WorkerThread::workerThread() while we&#39;re accessing it. Note also that stop() can
      // be called before m_workerGlobalScope is fully created.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 285,10 ***</span>
<span class="line-new-header">--- 309,14 ---</span>
              stop(WTFMove(stoppedCallback));
          });
          return;
      }
  
<span class="line-added">+     // If the thread is suspended, resume it now so that we can dispatch the cleanup tasks below.</span>
<span class="line-added">+     if (m_isSuspended)</span>
<span class="line-added">+         resume();</span>
<span class="line-added">+ </span>
      ASSERT(!m_stoppedCallback);
      m_stoppedCallback = WTFMove(stoppedCallback);
  
      // Ensure that tasks are being handled by thread event loop. If script execution weren&#39;t forbidden, a while(1) loop in JS could keep the thread alive forever.
      if (m_workerGlobalScope) {
</pre>
<center><a href="WorkerScriptLoader.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WorkerThread.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/canvas/CanvasRenderingContext2DBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008, 2010 Nokia Corporation and/or its subsidiary(-ies)
   4  * Copyright (C) 2007 Alp Toker &lt;alp@atoker.com&gt;
   5  * Copyright (C) 2008 Eric Seidel &lt;eric@webkit.org&gt;
   6  * Copyright (C) 2008 Dirk Schulze &lt;krit@webkit.org&gt;
   7  * Copyright (C) 2010 Torch Mobile (Beijing) Co. Ltd. All rights reserved.
   8  * Copyright (C) 2012 Intel Corporation. All rights reserved.
   9  * Copyright (C) 2013, 2014 Adobe Systems Incorporated. All rights reserved.
  10  *
  11  * Redistribution and use in source and binary forms, with or without
  12  * modification, are permitted provided that the following conditions
  13  * are met:
  14  * 1. Redistributions of source code must retain the above copyright
  15  *    notice, this list of conditions and the following disclaimer.
  16  * 2. Redistributions in binary form must reproduce the above copyright
  17  *    notice, this list of conditions and the following disclaimer in the
  18  *    documentation and/or other materials provided with the distribution.
  19  *
  20  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  21  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  23  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  24  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  25  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  26  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  27  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  28  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  29  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  30  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  31  */
  32 
  33 #include &quot;config.h&quot;
  34 #include &quot;CanvasRenderingContext2DBase.h&quot;
  35 
  36 #include &quot;BitmapImage.h&quot;
  37 #include &quot;CSSFontSelector.h&quot;
  38 #include &quot;CSSParser.h&quot;
  39 #include &quot;CSSPropertyNames.h&quot;
  40 #include &quot;CachedImage.h&quot;
  41 #include &quot;CanvasGradient.h&quot;
  42 #include &quot;CanvasPattern.h&quot;
  43 #include &quot;DOMMatrix.h&quot;
  44 #include &quot;DOMMatrix2DInit.h&quot;
  45 #include &quot;DisplayListRecorder.h&quot;
  46 #include &quot;DisplayListReplayer.h&quot;
  47 #include &quot;FloatQuad.h&quot;
  48 #include &quot;HTMLCanvasElement.h&quot;
  49 #include &quot;HTMLImageElement.h&quot;
  50 #include &quot;HTMLVideoElement.h&quot;
  51 #include &quot;ImageBitmap.h&quot;
  52 #include &quot;ImageBuffer.h&quot;
  53 #include &quot;ImageData.h&quot;
  54 #include &quot;Path2D.h&quot;
  55 #include &quot;RenderElement.h&quot;
  56 #include &quot;RenderImage.h&quot;
  57 #include &quot;RenderLayer.h&quot;
  58 #include &quot;RenderTheme.h&quot;
  59 #include &quot;SecurityOrigin.h&quot;
  60 #include &quot;Settings.h&quot;
  61 #include &quot;StrokeStyleApplier.h&quot;
  62 #include &quot;StyleProperties.h&quot;
  63 #include &quot;StyleResolver.h&quot;
  64 #include &quot;TextMetrics.h&quot;
  65 #include &quot;TextRun.h&quot;
  66 #include &quot;TypedOMCSSImageValue.h&quot;
  67 #include &lt;wtf/CheckedArithmetic.h&gt;
  68 #include &lt;wtf/IsoMallocInlines.h&gt;
  69 #include &lt;wtf/MathExtras.h&gt;
  70 #include &lt;wtf/NeverDestroyed.h&gt;
  71 #include &lt;wtf/text/StringBuilder.h&gt;
  72 #include &lt;wtf/text/TextStream.h&gt;
  73 
  74 namespace WebCore {
  75 
  76 using namespace HTMLNames;
  77 
  78 WTF_MAKE_ISO_ALLOCATED_IMPL(CanvasRenderingContext2DBase);
  79 
  80 #if USE(CG)
  81 const ImageSmoothingQuality defaultSmoothingQuality = ImageSmoothingQuality::Low;
  82 #else
  83 const ImageSmoothingQuality defaultSmoothingQuality = ImageSmoothingQuality::Medium;
  84 #endif
  85 
  86 const int CanvasRenderingContext2DBase::DefaultFontSize = 10;
  87 const char* const CanvasRenderingContext2DBase::DefaultFontFamily = &quot;sans-serif&quot;;
  88 const char* const CanvasRenderingContext2DBase::DefaultFont = &quot;10px sans-serif&quot;;
  89 
  90 struct DisplayListDrawingContext {
  91     WTF_MAKE_FAST_ALLOCATED;
  92 public:
  93     GraphicsContext context;
  94     DisplayList::DisplayList displayList;
  95 
  96     DisplayListDrawingContext(GraphicsContext&amp; context, const FloatRect&amp; clip)
  97         : DisplayListDrawingContext(context.state(), clip)
  98     {
  99     }
 100 
 101     DisplayListDrawingContext(const GraphicsContextState&amp; state, const FloatRect&amp; clip)
 102         : context([&amp;](GraphicsContext&amp; displayListContext) {
 103             return makeUnique&lt;DisplayList::Recorder&gt;(displayListContext, displayList, state, clip, AffineTransform());
 104         })
 105     {
 106     }
 107 };
 108 
 109 typedef HashMap&lt;const CanvasRenderingContext2DBase*, std::unique_ptr&lt;DisplayList::DisplayList&gt;&gt; ContextDisplayListHashMap;
 110 
 111 static ContextDisplayListHashMap&amp; contextDisplayListMap()
 112 {
 113     static NeverDestroyed&lt;ContextDisplayListHashMap&gt; sharedHashMap;
 114     return sharedHashMap;
 115 }
 116 
 117 class CanvasStrokeStyleApplier : public StrokeStyleApplier {
 118 public:
 119     CanvasStrokeStyleApplier(CanvasRenderingContext2DBase* canvasContext)
 120         : m_canvasContext(canvasContext)
 121     {
 122     }
 123 
 124     void strokeStyle(GraphicsContext* c) override
 125     {
 126         c-&gt;setStrokeThickness(m_canvasContext-&gt;lineWidth());
 127         c-&gt;setLineCap(m_canvasContext-&gt;getLineCap());
 128         c-&gt;setLineJoin(m_canvasContext-&gt;getLineJoin());
 129         c-&gt;setMiterLimit(m_canvasContext-&gt;miterLimit());
 130         const Vector&lt;float&gt;&amp; lineDash = m_canvasContext-&gt;getLineDash();
 131         DashArray convertedLineDash(lineDash.size());
 132         for (size_t i = 0; i &lt; lineDash.size(); ++i)
 133             convertedLineDash[i] = static_cast&lt;DashArrayElement&gt;(lineDash[i]);
 134         c-&gt;setLineDash(convertedLineDash, m_canvasContext-&gt;lineDashOffset());
 135     }
 136 
 137 private:
 138     CanvasRenderingContext2DBase* m_canvasContext;
 139 };
 140 
 141 CanvasRenderingContext2DBase::CanvasRenderingContext2DBase(CanvasBase&amp; canvas, bool usesCSSCompatibilityParseMode)
 142     : CanvasRenderingContext(canvas)
 143     , m_stateStack(1)
 144     , m_usesCSSCompatibilityParseMode(usesCSSCompatibilityParseMode)
 145 {
 146 }
 147 
 148 void CanvasRenderingContext2DBase::unwindStateStack()
 149 {
 150     // Ensure that the state stack in the ImageBuffer&#39;s context
 151     // is cleared before destruction, to avoid assertions in the
 152     // GraphicsContext dtor.
 153     if (size_t stackSize = m_stateStack.size()) {
 154         if (auto* context = canvasBase().existingDrawingContext()) {
 155             while (--stackSize)
 156                 context-&gt;restore();
 157         }
 158     }
 159 }
 160 
 161 CanvasRenderingContext2DBase::~CanvasRenderingContext2DBase()
 162 {
<a name="1" id="anc1"></a><span class="line-modified"> 163 #if ASSERT_ENABLED</span>
 164     unwindStateStack();
 165 #endif
 166 
 167     if (UNLIKELY(tracksDisplayListReplay()))
 168         contextDisplayListMap().remove(this);
 169 }
 170 
 171 bool CanvasRenderingContext2DBase::isAccelerated() const
 172 {
 173 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
 174     auto* context = canvasBase().existingDrawingContext();
 175     return context &amp;&amp; context-&gt;isAcceleratedContext();
 176 #else
 177     return false;
 178 #endif
 179 }
 180 
 181 void CanvasRenderingContext2DBase::reset()
 182 {
 183     unwindStateStack();
 184     m_stateStack.resize(1);
 185     m_stateStack.first() = State();
 186     m_path.clear();
 187     m_unrealizedSaveCount = 0;
 188 
 189     m_recordingContext = nullptr;
 190 }
 191 
 192 CanvasRenderingContext2DBase::State::State()
 193     : strokeStyle(Color::black)
 194     , fillStyle(Color::black)
 195     , lineWidth(1)
 196     , lineCap(ButtCap)
 197     , lineJoin(MiterJoin)
 198     , miterLimit(10)
 199     , shadowBlur(0)
 200     , shadowColor(Color::transparent)
 201     , globalAlpha(1)
<a name="2" id="anc2"></a><span class="line-modified"> 202     , globalComposite(CompositeOperator::SourceOver)</span>
 203     , globalBlend(BlendMode::Normal)
 204     , hasInvertibleTransform(true)
 205     , lineDashOffset(0)
 206     , imageSmoothingEnabled(true)
 207     , imageSmoothingQuality(defaultSmoothingQuality)
 208     , textAlign(StartTextAlign)
 209     , textBaseline(AlphabeticTextBaseline)
 210     , direction(Direction::Inherit)
 211     , unparsedFont(DefaultFont)
 212 {
 213 }
 214 
 215 CanvasRenderingContext2DBase::State::State(const State&amp; other)
 216     : unparsedStrokeColor(other.unparsedStrokeColor)
 217     , unparsedFillColor(other.unparsedFillColor)
 218     , strokeStyle(other.strokeStyle)
 219     , fillStyle(other.fillStyle)
 220     , lineWidth(other.lineWidth)
 221     , lineCap(other.lineCap)
 222     , lineJoin(other.lineJoin)
 223     , miterLimit(other.miterLimit)
 224     , shadowOffset(other.shadowOffset)
 225     , shadowBlur(other.shadowBlur)
 226     , shadowColor(other.shadowColor)
 227     , globalAlpha(other.globalAlpha)
 228     , globalComposite(other.globalComposite)
 229     , globalBlend(other.globalBlend)
 230     , transform(other.transform)
 231     , hasInvertibleTransform(other.hasInvertibleTransform)
 232     , lineDashOffset(other.lineDashOffset)
 233     , imageSmoothingEnabled(other.imageSmoothingEnabled)
 234     , imageSmoothingQuality(other.imageSmoothingQuality)
 235     , textAlign(other.textAlign)
 236     , textBaseline(other.textBaseline)
 237     , direction(other.direction)
 238     , unparsedFont(other.unparsedFont)
 239     , font(other.font)
 240 {
 241 }
 242 
 243 CanvasRenderingContext2DBase::State&amp; CanvasRenderingContext2DBase::State::operator=(const State&amp; other)
 244 {
 245     if (this == &amp;other)
 246         return *this;
 247 
 248     unparsedStrokeColor = other.unparsedStrokeColor;
 249     unparsedFillColor = other.unparsedFillColor;
 250     strokeStyle = other.strokeStyle;
 251     fillStyle = other.fillStyle;
 252     lineWidth = other.lineWidth;
 253     lineCap = other.lineCap;
 254     lineJoin = other.lineJoin;
 255     miterLimit = other.miterLimit;
 256     shadowOffset = other.shadowOffset;
 257     shadowBlur = other.shadowBlur;
 258     shadowColor = other.shadowColor;
 259     globalAlpha = other.globalAlpha;
 260     globalComposite = other.globalComposite;
 261     globalBlend = other.globalBlend;
 262     transform = other.transform;
 263     hasInvertibleTransform = other.hasInvertibleTransform;
 264     imageSmoothingEnabled = other.imageSmoothingEnabled;
 265     imageSmoothingQuality = other.imageSmoothingQuality;
 266     textAlign = other.textAlign;
 267     textBaseline = other.textBaseline;
 268     direction = other.direction;
 269     unparsedFont = other.unparsedFont;
 270     font = other.font;
 271 
 272     return *this;
 273 }
 274 
 275 CanvasRenderingContext2DBase::FontProxy::~FontProxy()
 276 {
 277     if (realized())
 278         m_font.fontSelector()-&gt;unregisterForInvalidationCallbacks(*this);
 279 }
 280 
 281 CanvasRenderingContext2DBase::FontProxy::FontProxy(const FontProxy&amp; other)
 282     : m_font(other.m_font)
 283 {
 284     if (realized())
 285         m_font.fontSelector()-&gt;registerForInvalidationCallbacks(*this);
 286 }
 287 
 288 auto CanvasRenderingContext2DBase::FontProxy::operator=(const FontProxy&amp; other) -&gt; FontProxy&amp;
 289 {
 290     if (realized())
 291         m_font.fontSelector()-&gt;unregisterForInvalidationCallbacks(*this);
 292 
 293     m_font = other.m_font;
 294 
 295     if (realized())
 296         m_font.fontSelector()-&gt;registerForInvalidationCallbacks(*this);
 297 
 298     return *this;
 299 }
 300 
 301 inline void CanvasRenderingContext2DBase::FontProxy::update(FontSelector&amp; selector)
 302 {
 303     ASSERT(&amp;selector == m_font.fontSelector()); // This is an invariant. We should only ever be registered for callbacks on m_font.m_fonts.m_fontSelector.
 304     if (realized())
 305         m_font.fontSelector()-&gt;unregisterForInvalidationCallbacks(*this);
 306     m_font.update(&amp;selector);
 307     if (realized())
 308         m_font.fontSelector()-&gt;registerForInvalidationCallbacks(*this);
 309     ASSERT(&amp;selector == m_font.fontSelector());
 310 }
 311 
 312 void CanvasRenderingContext2DBase::FontProxy::fontsNeedUpdate(FontSelector&amp; selector)
 313 {
 314     ASSERT_ARG(selector, &amp;selector == m_font.fontSelector());
 315     ASSERT(realized());
 316 
 317     update(selector);
 318 }
 319 
 320 void CanvasRenderingContext2DBase::FontProxy::initialize(FontSelector&amp; fontSelector, const RenderStyle&amp; newStyle)
 321 {
 322     // Beware! m_font.fontSelector() might not point to document.fontSelector()!
 323     ASSERT(newStyle.fontCascade().fontSelector() == &amp;fontSelector);
 324     if (realized())
 325         m_font.fontSelector()-&gt;unregisterForInvalidationCallbacks(*this);
 326     m_font = newStyle.fontCascade();
 327     m_font.update(&amp;fontSelector);
 328     ASSERT(&amp;fontSelector == m_font.fontSelector());
 329     m_font.fontSelector()-&gt;registerForInvalidationCallbacks(*this);
 330 }
 331 
 332 const FontMetrics&amp; CanvasRenderingContext2DBase::FontProxy::fontMetrics() const
 333 {
 334     return m_font.fontMetrics();
 335 }
 336 
 337 const FontCascadeDescription&amp; CanvasRenderingContext2DBase::FontProxy::fontDescription() const
 338 {
 339     return m_font.fontDescription();
 340 }
 341 
 342 float CanvasRenderingContext2DBase::FontProxy::width(const TextRun&amp; textRun, GlyphOverflow* overflow) const
 343 {
 344     return m_font.width(textRun, 0, overflow);
 345 }
 346 
 347 void CanvasRenderingContext2DBase::FontProxy::drawBidiText(GraphicsContext&amp; context, const TextRun&amp; run, const FloatPoint&amp; point, FontCascade::CustomFontNotReadyAction action) const
 348 {
 349     context.drawBidiText(m_font, run, point, action);
 350 }
 351 
 352 void CanvasRenderingContext2DBase::realizeSaves()
 353 {
 354     if (m_unrealizedSaveCount)
 355         realizeSavesLoop();
 356 
 357     if (m_unrealizedSaveCount) {
 358         static NeverDestroyed&lt;String&gt; consoleMessage(MAKE_STATIC_STRING_IMPL(&quot;CanvasRenderingContext2D.save() has been called without a matching restore() too many times. Ignoring save().&quot;));
 359 
 360         canvasBase().scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::Rendering, MessageLevel::Error, consoleMessage);
 361     }
 362 }
 363 
 364 void CanvasRenderingContext2DBase::realizeSavesLoop()
 365 {
 366     ASSERT(m_unrealizedSaveCount);
 367     ASSERT(m_stateStack.size() &gt;= 1);
 368     GraphicsContext* context = drawingContext();
 369     do {
 370         if (m_stateStack.size() &gt; MaxSaveCount)
 371             break;
 372         m_stateStack.append(state());
 373         if (context)
 374             context-&gt;save();
 375     } while (--m_unrealizedSaveCount);
 376 }
 377 
 378 void CanvasRenderingContext2DBase::restore()
 379 {
 380     if (m_unrealizedSaveCount) {
 381         --m_unrealizedSaveCount;
 382         return;
 383     }
 384     ASSERT(m_stateStack.size() &gt;= 1);
 385     if (m_stateStack.size() &lt;= 1)
 386         return;
 387     m_path.transform(state().transform);
 388     m_stateStack.removeLast();
 389     if (Optional&lt;AffineTransform&gt; inverse = state().transform.inverse())
 390         m_path.transform(inverse.value());
 391     GraphicsContext* c = drawingContext();
 392     if (!c)
 393         return;
 394     c-&gt;restore();
 395 }
 396 
 397 void CanvasRenderingContext2DBase::setStrokeStyle(CanvasStyle style)
 398 {
 399     if (!style.isValid())
 400         return;
 401 
 402     if (state().strokeStyle.isValid() &amp;&amp; state().strokeStyle.isEquivalentColor(style))
 403         return;
 404 
<a name="3" id="anc3"></a><span class="line-modified"> 405     if (style.isCurrentColor()) {</span>


 406         if (style.hasOverrideAlpha()) {
 407             // FIXME: Should not use RGBA32 here.
<a name="4" id="anc4"></a><span class="line-modified"> 408             style = CanvasStyle(colorWithOverrideAlpha(currentColor(canvasBase()).rgb(), style.overrideAlpha()));</span>
 409         } else
<a name="5" id="anc5"></a><span class="line-modified"> 410             style = CanvasStyle(currentColor(canvasBase()));</span>
 411     } else
 412         checkOrigin(style.canvasPattern().get());
 413 
 414     realizeSaves();
 415     State&amp; state = modifiableState();
 416     state.strokeStyle = style;
 417     GraphicsContext* c = drawingContext();
 418     if (!c)
 419         return;
 420     state.strokeStyle.applyStrokeColor(*c);
 421     state.unparsedStrokeColor = String();
 422 }
 423 
 424 void CanvasRenderingContext2DBase::setFillStyle(CanvasStyle style)
 425 {
 426     if (!style.isValid())
 427         return;
 428 
 429     if (state().fillStyle.isValid() &amp;&amp; state().fillStyle.isEquivalentColor(style))
 430         return;
 431 
<a name="6" id="anc6"></a><span class="line-modified"> 432     if (style.isCurrentColor()) {</span>


 433         if (style.hasOverrideAlpha()) {
 434             // FIXME: Should not use RGBA32 here.
<a name="7" id="anc7"></a><span class="line-modified"> 435             style = CanvasStyle(colorWithOverrideAlpha(currentColor(canvasBase()).rgb(), style.overrideAlpha()));</span>
 436         } else
<a name="8" id="anc8"></a><span class="line-modified"> 437             style = CanvasStyle(currentColor(canvasBase()));</span>
 438     } else
 439         checkOrigin(style.canvasPattern().get());
 440 
 441     realizeSaves();
 442     State&amp; state = modifiableState();
 443     state.fillStyle = style;
 444     GraphicsContext* c = drawingContext();
 445     if (!c)
 446         return;
 447     state.fillStyle.applyFillColor(*c);
 448     state.unparsedFillColor = String();
 449 }
 450 
 451 float CanvasRenderingContext2DBase::lineWidth() const
 452 {
 453     return state().lineWidth;
 454 }
 455 
 456 void CanvasRenderingContext2DBase::setLineWidth(float width)
 457 {
 458     if (!(std::isfinite(width) &amp;&amp; width &gt; 0))
 459         return;
 460     if (state().lineWidth == width)
 461         return;
 462     realizeSaves();
 463     modifiableState().lineWidth = width;
 464     GraphicsContext* c = drawingContext();
 465     if (!c)
 466         return;
 467     c-&gt;setStrokeThickness(width);
 468 }
 469 
 470 static CanvasLineCap toCanvasLineCap(LineCap lineCap)
 471 {
 472     switch (lineCap) {
 473     case ButtCap:
 474         return CanvasLineCap::Butt;
 475     case RoundCap:
 476         return CanvasLineCap::Round;
 477     case SquareCap:
 478         return CanvasLineCap::Square;
 479     }
 480 
 481     ASSERT_NOT_REACHED();
 482     return CanvasLineCap::Butt;
 483 }
 484 
 485 static LineCap fromCanvasLineCap(CanvasLineCap canvasLineCap)
 486 {
 487     switch (canvasLineCap) {
 488     case CanvasLineCap::Butt:
 489         return ButtCap;
 490     case CanvasLineCap::Round:
 491         return RoundCap;
 492     case CanvasLineCap::Square:
 493         return SquareCap;
 494     }
 495 
 496     ASSERT_NOT_REACHED();
 497     return ButtCap;
 498 }
 499 
 500 CanvasLineCap CanvasRenderingContext2DBase::lineCap() const
 501 {
 502     return toCanvasLineCap(state().lineCap);
 503 }
 504 
 505 void CanvasRenderingContext2DBase::setLineCap(CanvasLineCap canvasLineCap)
 506 {
 507     auto lineCap = fromCanvasLineCap(canvasLineCap);
 508     if (state().lineCap == lineCap)
 509         return;
 510     realizeSaves();
 511     modifiableState().lineCap = lineCap;
 512     GraphicsContext* c = drawingContext();
 513     if (!c)
 514         return;
 515     c-&gt;setLineCap(lineCap);
 516 }
 517 
 518 void CanvasRenderingContext2DBase::setLineCap(const String&amp; stringValue)
 519 {
 520     CanvasLineCap cap;
 521     if (stringValue == &quot;butt&quot;)
 522         cap = CanvasLineCap::Butt;
 523     else if (stringValue == &quot;round&quot;)
 524         cap = CanvasLineCap::Round;
 525     else if (stringValue == &quot;square&quot;)
 526         cap = CanvasLineCap::Square;
 527     else
 528         return;
 529 
 530     setLineCap(cap);
 531 }
 532 
 533 static CanvasLineJoin toCanvasLineJoin(LineJoin lineJoin)
 534 {
 535     switch (lineJoin) {
 536     case RoundJoin:
 537         return CanvasLineJoin::Round;
 538     case BevelJoin:
 539         return CanvasLineJoin::Bevel;
 540     case MiterJoin:
 541         return CanvasLineJoin::Miter;
 542     }
 543 
 544     ASSERT_NOT_REACHED();
 545     return CanvasLineJoin::Round;
 546 }
 547 
 548 static LineJoin fromCanvasLineJoin(CanvasLineJoin canvasLineJoin)
 549 {
 550     switch (canvasLineJoin) {
 551     case CanvasLineJoin::Round:
 552         return RoundJoin;
 553     case CanvasLineJoin::Bevel:
 554         return BevelJoin;
 555     case CanvasLineJoin::Miter:
 556         return MiterJoin;
 557     }
 558 
 559     ASSERT_NOT_REACHED();
 560     return RoundJoin;
 561 }
 562 
 563 CanvasLineJoin CanvasRenderingContext2DBase::lineJoin() const
 564 {
 565     return toCanvasLineJoin(state().lineJoin);
 566 }
 567 
 568 void CanvasRenderingContext2DBase::setLineJoin(CanvasLineJoin canvasLineJoin)
 569 {
 570     auto lineJoin = fromCanvasLineJoin(canvasLineJoin);
 571     if (state().lineJoin == lineJoin)
 572         return;
 573     realizeSaves();
 574     modifiableState().lineJoin = lineJoin;
 575     GraphicsContext* c = drawingContext();
 576     if (!c)
 577         return;
 578     c-&gt;setLineJoin(lineJoin);
 579 }
 580 
 581 void CanvasRenderingContext2DBase::setLineJoin(const String&amp; stringValue)
 582 {
 583     CanvasLineJoin join;
 584     if (stringValue == &quot;round&quot;)
 585         join = CanvasLineJoin::Round;
 586     else if (stringValue == &quot;bevel&quot;)
 587         join = CanvasLineJoin::Bevel;
 588     else if (stringValue == &quot;miter&quot;)
 589         join = CanvasLineJoin::Miter;
 590     else
 591         return;
 592 
 593     setLineJoin(join);
 594 }
 595 
 596 float CanvasRenderingContext2DBase::miterLimit() const
 597 {
 598     return state().miterLimit;
 599 }
 600 
 601 void CanvasRenderingContext2DBase::setMiterLimit(float limit)
 602 {
 603     if (!(std::isfinite(limit) &amp;&amp; limit &gt; 0))
 604         return;
 605     if (state().miterLimit == limit)
 606         return;
 607     realizeSaves();
 608     modifiableState().miterLimit = limit;
 609     GraphicsContext* c = drawingContext();
 610     if (!c)
 611         return;
 612     c-&gt;setMiterLimit(limit);
 613 }
 614 
 615 float CanvasRenderingContext2DBase::shadowOffsetX() const
 616 {
 617     return state().shadowOffset.width();
 618 }
 619 
 620 void CanvasRenderingContext2DBase::setShadowOffsetX(float x)
 621 {
 622     if (!std::isfinite(x))
 623         return;
 624     if (state().shadowOffset.width() == x)
 625         return;
 626     realizeSaves();
 627     modifiableState().shadowOffset.setWidth(x);
 628     applyShadow();
 629 }
 630 
 631 float CanvasRenderingContext2DBase::shadowOffsetY() const
 632 {
 633     return state().shadowOffset.height();
 634 }
 635 
 636 void CanvasRenderingContext2DBase::setShadowOffsetY(float y)
 637 {
 638     if (!std::isfinite(y))
 639         return;
 640     if (state().shadowOffset.height() == y)
 641         return;
 642     realizeSaves();
 643     modifiableState().shadowOffset.setHeight(y);
 644     applyShadow();
 645 }
 646 
 647 float CanvasRenderingContext2DBase::shadowBlur() const
 648 {
 649     return state().shadowBlur;
 650 }
 651 
 652 void CanvasRenderingContext2DBase::setShadowBlur(float blur)
 653 {
 654     if (!(std::isfinite(blur) &amp;&amp; blur &gt;= 0))
 655         return;
 656     if (state().shadowBlur == blur)
 657         return;
 658     realizeSaves();
 659     modifiableState().shadowBlur = blur;
 660     applyShadow();
 661 }
 662 
 663 String CanvasRenderingContext2DBase::shadowColor() const
 664 {
 665     return Color(state().shadowColor).serialized();
 666 }
 667 
 668 void CanvasRenderingContext2DBase::setShadowColor(const String&amp; colorString)
 669 {
<a name="9" id="anc9"></a><span class="line-modified"> 670     Color color = parseColorOrCurrentColor(colorString, canvasBase());</span>

 671     if (!color.isValid())
 672         return;
 673     if (state().shadowColor == color)
 674         return;
 675     realizeSaves();
 676     modifiableState().shadowColor = color;
 677     applyShadow();
 678 }
 679 
 680 const Vector&lt;float&gt;&amp; CanvasRenderingContext2DBase::getLineDash() const
 681 {
 682     return state().lineDash;
 683 }
 684 
 685 static bool lineDashSequenceIsValid(const Vector&lt;float&gt;&amp; dash)
 686 {
 687     for (size_t i = 0; i &lt; dash.size(); i++) {
 688         if (!std::isfinite(dash[i]) || dash[i] &lt; 0)
 689             return false;
 690     }
 691     return true;
 692 }
 693 
 694 void CanvasRenderingContext2DBase::setLineDash(const Vector&lt;float&gt;&amp; dash)
 695 {
 696     if (!lineDashSequenceIsValid(dash))
 697         return;
 698 
 699     realizeSaves();
 700     modifiableState().lineDash = dash;
 701     // Spec requires the concatenation of two copies the dash list when the
 702     // number of elements is odd
 703     if (dash.size() % 2)
 704         modifiableState().lineDash.appendVector(dash);
 705 
 706     applyLineDash();
 707 }
 708 
 709 void CanvasRenderingContext2DBase::setWebkitLineDash(const Vector&lt;float&gt;&amp; dash)
 710 {
 711     if (!lineDashSequenceIsValid(dash))
 712         return;
 713 
 714     realizeSaves();
 715     modifiableState().lineDash = dash;
 716 
 717     applyLineDash();
 718 }
 719 
 720 float CanvasRenderingContext2DBase::lineDashOffset() const
 721 {
 722     return state().lineDashOffset;
 723 }
 724 
 725 void CanvasRenderingContext2DBase::setLineDashOffset(float offset)
 726 {
 727     if (!std::isfinite(offset) || state().lineDashOffset == offset)
 728         return;
 729 
 730     realizeSaves();
 731     modifiableState().lineDashOffset = offset;
 732     applyLineDash();
 733 }
 734 
 735 void CanvasRenderingContext2DBase::applyLineDash() const
 736 {
 737     GraphicsContext* c = drawingContext();
 738     if (!c)
 739         return;
 740     DashArray convertedLineDash(state().lineDash.size());
 741     for (size_t i = 0; i &lt; state().lineDash.size(); ++i)
 742         convertedLineDash[i] = static_cast&lt;DashArrayElement&gt;(state().lineDash[i]);
 743     c-&gt;setLineDash(convertedLineDash, state().lineDashOffset);
 744 }
 745 
 746 float CanvasRenderingContext2DBase::globalAlpha() const
 747 {
 748     return state().globalAlpha;
 749 }
 750 
 751 void CanvasRenderingContext2DBase::setGlobalAlpha(float alpha)
 752 {
 753     if (!(alpha &gt;= 0 &amp;&amp; alpha &lt;= 1))
 754         return;
 755     if (state().globalAlpha == alpha)
 756         return;
 757     realizeSaves();
 758     modifiableState().globalAlpha = alpha;
 759     GraphicsContext* c = drawingContext();
 760     if (!c)
 761         return;
 762     c-&gt;setAlpha(alpha);
 763 }
 764 
 765 String CanvasRenderingContext2DBase::globalCompositeOperation() const
 766 {
 767     return compositeOperatorName(state().globalComposite, state().globalBlend);
 768 }
 769 
 770 void CanvasRenderingContext2DBase::setGlobalCompositeOperation(const String&amp; operation)
 771 {
<a name="10" id="anc10"></a><span class="line-modified"> 772     CompositeOperator op = CompositeOperator::SourceOver;</span>
 773     BlendMode blendMode = BlendMode::Normal;
 774     if (!parseCompositeAndBlendOperator(operation, op, blendMode))
 775         return;
 776     if ((state().globalComposite == op) &amp;&amp; (state().globalBlend == blendMode))
 777         return;
 778     realizeSaves();
 779     modifiableState().globalComposite = op;
 780     modifiableState().globalBlend = blendMode;
 781     GraphicsContext* c = drawingContext();
 782     if (!c)
 783         return;
 784     c-&gt;setCompositeOperation(op, blendMode);
 785 }
 786 
 787 void CanvasRenderingContext2DBase::scale(float sx, float sy)
 788 {
 789     GraphicsContext* c = drawingContext();
 790     if (!c)
 791         return;
 792     if (!state().hasInvertibleTransform)
 793         return;
 794 
 795     if (!std::isfinite(sx) || !std::isfinite(sy))
 796         return;
 797 
 798     AffineTransform newTransform = state().transform;
 799     newTransform.scaleNonUniform(sx, sy);
 800     if (state().transform == newTransform)
 801         return;
 802 
 803     realizeSaves();
 804 
 805     if (!sx || !sy) {
 806         modifiableState().hasInvertibleTransform = false;
 807         return;
 808     }
 809 
 810     modifiableState().transform = newTransform;
 811     c-&gt;scale(FloatSize(sx, sy));
 812     m_path.transform(AffineTransform().scaleNonUniform(1.0 / sx, 1.0 / sy));
 813 }
 814 
 815 void CanvasRenderingContext2DBase::rotate(float angleInRadians)
 816 {
 817     GraphicsContext* c = drawingContext();
 818     if (!c)
 819         return;
 820     if (!state().hasInvertibleTransform)
 821         return;
 822 
 823     if (!std::isfinite(angleInRadians))
 824         return;
 825 
 826     AffineTransform newTransform = state().transform;
 827     newTransform.rotate(angleInRadians / piDouble * 180.0);
 828     if (state().transform == newTransform)
 829         return;
 830 
 831     realizeSaves();
 832 
 833     modifiableState().transform = newTransform;
 834     c-&gt;rotate(angleInRadians);
 835     m_path.transform(AffineTransform().rotate(-angleInRadians / piDouble * 180.0));
 836 }
 837 
 838 void CanvasRenderingContext2DBase::translate(float tx, float ty)
 839 {
 840     GraphicsContext* c = drawingContext();
 841     if (!c)
 842         return;
 843     if (!state().hasInvertibleTransform)
 844         return;
 845 
 846     if (!std::isfinite(tx) | !std::isfinite(ty))
 847         return;
 848 
 849     AffineTransform newTransform = state().transform;
 850     newTransform.translate(tx, ty);
 851     if (state().transform == newTransform)
 852         return;
 853 
 854     realizeSaves();
 855 
 856     modifiableState().transform = newTransform;
 857     c-&gt;translate(tx, ty);
 858     m_path.transform(AffineTransform().translate(-tx, -ty));
 859 }
 860 
 861 void CanvasRenderingContext2DBase::transform(float m11, float m12, float m21, float m22, float dx, float dy)
 862 {
 863     GraphicsContext* c = drawingContext();
 864     if (!c)
 865         return;
 866     if (!state().hasInvertibleTransform)
 867         return;
 868 
 869     if (!std::isfinite(m11) | !std::isfinite(m21) | !std::isfinite(dx) | !std::isfinite(m12) | !std::isfinite(m22) | !std::isfinite(dy))
 870         return;
 871 
 872     AffineTransform transform(m11, m12, m21, m22, dx, dy);
 873     AffineTransform newTransform = state().transform * transform;
 874     if (state().transform == newTransform)
 875         return;
 876 
 877     realizeSaves();
 878 
 879     if (auto inverse = transform.inverse()) {
 880         modifiableState().transform = newTransform;
 881         c-&gt;concatCTM(transform);
 882         m_path.transform(inverse.value());
 883         return;
 884     }
 885     modifiableState().hasInvertibleTransform = false;
 886 }
 887 
 888 Ref&lt;DOMMatrix&gt; CanvasRenderingContext2DBase::getTransform() const
 889 {
 890     return DOMMatrix::create(state().transform.toTransformationMatrix(), DOMMatrixReadOnly::Is2D::Yes);
 891 }
 892 
 893 void CanvasRenderingContext2DBase::setTransform(float m11, float m12, float m21, float m22, float dx, float dy)
 894 {
 895     GraphicsContext* c = drawingContext();
 896     if (!c)
 897         return;
 898 
 899     if (!std::isfinite(m11) | !std::isfinite(m21) | !std::isfinite(dx) | !std::isfinite(m12) | !std::isfinite(m22) | !std::isfinite(dy))
 900         return;
 901 
 902     resetTransform();
 903     transform(m11, m12, m21, m22, dx, dy);
 904 }
 905 
 906 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::setTransform(DOMMatrix2DInit&amp;&amp; matrixInit)
 907 {
 908     auto checkValid = DOMMatrixReadOnly::validateAndFixup(matrixInit);
 909     if (checkValid.hasException())
 910         return checkValid.releaseException();
 911 
 912     setTransform(matrixInit.m11.value(), matrixInit.m12.value(), matrixInit.m21.value(), matrixInit.m22.value(), matrixInit.m41.value(), matrixInit.m42.value());
 913     return { };
 914 }
 915 
 916 void CanvasRenderingContext2DBase::resetTransform()
 917 {
 918     GraphicsContext* c = drawingContext();
 919     if (!c)
 920         return;
 921 
 922     AffineTransform ctm = state().transform;
 923     bool hasInvertibleTransform = state().hasInvertibleTransform;
 924 
 925     realizeSaves();
 926 
 927     c-&gt;setCTM(canvasBase().baseTransform());
 928     modifiableState().transform = AffineTransform();
 929 
 930     if (hasInvertibleTransform)
 931         m_path.transform(ctm);
 932 
 933     modifiableState().hasInvertibleTransform = true;
 934 }
 935 
 936 void CanvasRenderingContext2DBase::setStrokeColor(const String&amp; color, Optional&lt;float&gt; alpha)
 937 {
 938     if (alpha) {
<a name="11" id="anc11"></a><span class="line-modified"> 939         setStrokeStyle(CanvasStyle::createFromStringWithOverrideAlpha(color, alpha.value(), canvasBase()));</span>
 940         return;
 941     }
 942 
 943     if (color == state().unparsedStrokeColor)
 944         return;
 945 
 946     realizeSaves();
<a name="12" id="anc12"></a><span class="line-modified"> 947     setStrokeStyle(CanvasStyle::createFromString(color, canvasBase()));</span>
 948     modifiableState().unparsedStrokeColor = color;
 949 }
 950 
 951 void CanvasRenderingContext2DBase::setStrokeColor(float grayLevel, float alpha)
 952 {
 953     if (state().strokeStyle.isValid() &amp;&amp; state().strokeStyle.isEquivalentRGBA(grayLevel, grayLevel, grayLevel, alpha))
 954         return;
 955     setStrokeStyle(CanvasStyle(grayLevel, alpha));
 956 }
 957 
 958 void CanvasRenderingContext2DBase::setStrokeColor(float r, float g, float b, float a)
 959 {
 960     if (state().strokeStyle.isValid() &amp;&amp; state().strokeStyle.isEquivalentRGBA(r, g, b, a))
 961         return;
 962     setStrokeStyle(CanvasStyle(r, g, b, a));
 963 }
 964 
 965 void CanvasRenderingContext2DBase::setStrokeColor(float c, float m, float y, float k, float a)
 966 {
 967     if (state().strokeStyle.isValid() &amp;&amp; state().strokeStyle.isEquivalentCMYKA(c, m, y, k, a))
 968         return;
 969     setStrokeStyle(CanvasStyle(c, m, y, k, a));
 970 }
 971 
 972 void CanvasRenderingContext2DBase::setFillColor(const String&amp; color, Optional&lt;float&gt; alpha)
 973 {
 974     if (alpha) {
<a name="13" id="anc13"></a><span class="line-modified"> 975         setFillStyle(CanvasStyle::createFromStringWithOverrideAlpha(color, alpha.value(), canvasBase()));</span>
 976         return;
 977     }
 978 
 979     if (color == state().unparsedFillColor)
 980         return;
 981 
 982     realizeSaves();
<a name="14" id="anc14"></a><span class="line-modified"> 983     setFillStyle(CanvasStyle::createFromString(color, canvasBase()));</span>
 984     modifiableState().unparsedFillColor = color;
 985 }
 986 
 987 void CanvasRenderingContext2DBase::setFillColor(float grayLevel, float alpha)
 988 {
 989     if (state().fillStyle.isValid() &amp;&amp; state().fillStyle.isEquivalentRGBA(grayLevel, grayLevel, grayLevel, alpha))
 990         return;
 991     setFillStyle(CanvasStyle(grayLevel, alpha));
 992 }
 993 
 994 void CanvasRenderingContext2DBase::setFillColor(float r, float g, float b, float a)
 995 {
 996     if (state().fillStyle.isValid() &amp;&amp; state().fillStyle.isEquivalentRGBA(r, g, b, a))
 997         return;
 998     setFillStyle(CanvasStyle(r, g, b, a));
 999 }
1000 
1001 void CanvasRenderingContext2DBase::setFillColor(float c, float m, float y, float k, float a)
1002 {
1003     if (state().fillStyle.isValid() &amp;&amp; state().fillStyle.isEquivalentCMYKA(c, m, y, k, a))
1004         return;
1005     setFillStyle(CanvasStyle(c, m, y, k, a));
1006 }
1007 
1008 void CanvasRenderingContext2DBase::beginPath()
1009 {
1010     m_path.clear();
1011 }
1012 
1013 static bool validateRectForCanvas(float&amp; x, float&amp; y, float&amp; width, float&amp; height)
1014 {
1015     if (!std::isfinite(x) | !std::isfinite(y) | !std::isfinite(width) | !std::isfinite(height))
1016         return false;
1017 
1018     if (!width &amp;&amp; !height)
1019         return false;
1020 
1021     if (width &lt; 0) {
1022         width = -width;
1023         x -= width;
1024     }
1025 
1026     if (height &lt; 0) {
1027         height = -height;
1028         y -= height;
1029     }
1030 
1031     return true;
1032 }
1033 
1034 bool CanvasRenderingContext2DBase::isFullCanvasCompositeMode(CompositeOperator op)
1035 {
1036     // See 4.8.11.1.3 Compositing
<a name="15" id="anc15"></a><span class="line-modified">1037     // CompositeOperator::SourceAtop and CompositeOperator::DestinationOut are not listed here as the platforms already</span>
1038     // implement the specification&#39;s behavior.
<a name="16" id="anc16"></a><span class="line-modified">1039     return op == CompositeOperator::SourceIn || op == CompositeOperator::SourceOut || op == CompositeOperator::DestinationIn || op == CompositeOperator::DestinationAtop;</span>
1040 }
1041 
1042 static WindRule toWindRule(CanvasFillRule rule)
1043 {
1044     return rule == CanvasFillRule::Nonzero ? WindRule::NonZero : WindRule::EvenOdd;
1045 }
1046 
1047 void CanvasRenderingContext2DBase::fill(CanvasFillRule windingRule)
1048 {
1049     fillInternal(m_path, windingRule);
1050 }
1051 
1052 void CanvasRenderingContext2DBase::stroke()
1053 {
1054     strokeInternal(m_path);
1055 }
1056 
1057 void CanvasRenderingContext2DBase::clip(CanvasFillRule windingRule)
1058 {
1059     clipInternal(m_path, windingRule);
1060 }
1061 
1062 void CanvasRenderingContext2DBase::fill(Path2D&amp; path, CanvasFillRule windingRule)
1063 {
1064     fillInternal(path.path(), windingRule);
1065 }
1066 
1067 void CanvasRenderingContext2DBase::stroke(Path2D&amp; path)
1068 {
1069     strokeInternal(path.path());
1070 }
1071 
1072 void CanvasRenderingContext2DBase::clip(Path2D&amp; path, CanvasFillRule windingRule)
1073 {
1074     clipInternal(path.path(), windingRule);
1075 }
1076 
1077 void CanvasRenderingContext2DBase::fillInternal(const Path&amp; path, CanvasFillRule windingRule)
1078 {
1079     auto* c = drawingContext();
1080     if (!c)
1081         return;
1082     if (!state().hasInvertibleTransform)
1083         return;
1084 
1085     // If gradient size is zero, then paint nothing.
1086     auto gradient = c-&gt;fillGradient();
1087     if (gradient &amp;&amp; gradient-&gt;isZeroSize())
1088         return;
1089 
1090     if (!path.isEmpty()) {
1091         auto savedFillRule = c-&gt;fillRule();
1092         c-&gt;setFillRule(toWindRule(windingRule));
1093 
1094         if (isFullCanvasCompositeMode(state().globalComposite)) {
1095             beginCompositeLayer();
1096             c-&gt;fillPath(path);
1097             endCompositeLayer();
1098             didDrawEntireCanvas();
<a name="17" id="anc17"></a><span class="line-modified">1099         } else if (state().globalComposite == CompositeOperator::Copy) {</span>
1100             clearCanvas();
1101             c-&gt;fillPath(path);
1102             didDrawEntireCanvas();
1103         } else {
1104             c-&gt;fillPath(path);
1105             didDraw(path.fastBoundingRect());
1106         }
1107 
1108         c-&gt;setFillRule(savedFillRule);
1109     }
1110 }
1111 
1112 void CanvasRenderingContext2DBase::strokeInternal(const Path&amp; path)
1113 {
1114     auto* c = drawingContext();
1115     if (!c)
1116         return;
1117     if (!state().hasInvertibleTransform)
1118         return;
1119 
1120     // If gradient size is zero, then paint nothing.
1121     auto gradient = c-&gt;strokeGradient();
1122     if (gradient &amp;&amp; gradient-&gt;isZeroSize())
1123         return;
1124 
1125     if (!path.isEmpty()) {
1126         if (isFullCanvasCompositeMode(state().globalComposite)) {
1127             beginCompositeLayer();
1128             c-&gt;strokePath(path);
1129             endCompositeLayer();
1130             didDrawEntireCanvas();
<a name="18" id="anc18"></a><span class="line-modified">1131         } else if (state().globalComposite == CompositeOperator::Copy) {</span>
1132             clearCanvas();
1133             c-&gt;strokePath(path);
1134             didDrawEntireCanvas();
1135         } else {
1136             FloatRect dirtyRect = path.fastBoundingRect();
1137             inflateStrokeRect(dirtyRect);
1138             c-&gt;strokePath(path);
1139             didDraw(dirtyRect);
1140         }
1141     }
1142 }
1143 
1144 void CanvasRenderingContext2DBase::clipInternal(const Path&amp; path, CanvasFillRule windingRule)
1145 {
1146     auto* c = drawingContext();
1147     if (!c)
1148         return;
1149     if (!state().hasInvertibleTransform)
1150         return;
1151 
1152     realizeSaves();
1153     c-&gt;canvasClip(path, toWindRule(windingRule));
1154 }
1155 
1156 void CanvasRenderingContext2DBase::beginCompositeLayer()
1157 {
1158 #if !USE(CAIRO)
1159     drawingContext()-&gt;beginTransparencyLayer(1);
1160 #endif
1161 }
1162 
1163 void CanvasRenderingContext2DBase::endCompositeLayer()
1164 {
1165 #if !USE(CAIRO)
1166     drawingContext()-&gt;endTransparencyLayer();
1167 #endif
1168 }
1169 
1170 bool CanvasRenderingContext2DBase::isPointInPath(float x, float y, CanvasFillRule windingRule)
1171 {
1172     return isPointInPathInternal(m_path, x, y, windingRule);
1173 }
1174 
1175 bool CanvasRenderingContext2DBase::isPointInStroke(float x, float y)
1176 {
1177     return isPointInStrokeInternal(m_path, x, y);
1178 }
1179 
1180 bool CanvasRenderingContext2DBase::isPointInPath(Path2D&amp; path, float x, float y, CanvasFillRule windingRule)
1181 {
1182     return isPointInPathInternal(path.path(), x, y, windingRule);
1183 }
1184 
1185 bool CanvasRenderingContext2DBase::isPointInStroke(Path2D&amp; path, float x, float y)
1186 {
1187     return isPointInStrokeInternal(path.path(), x, y);
1188 }
1189 
1190 bool CanvasRenderingContext2DBase::isPointInPathInternal(const Path&amp; path, float x, float y, CanvasFillRule windingRule)
1191 {
1192     auto* c = drawingContext();
1193     if (!c)
1194         return false;
1195     if (!state().hasInvertibleTransform)
1196         return false;
1197 
1198     auto transformedPoint = state().transform.inverse().valueOr(AffineTransform()).mapPoint(FloatPoint(x, y));
1199 
1200     if (!std::isfinite(transformedPoint.x()) || !std::isfinite(transformedPoint.y()))
1201         return false;
1202 
1203     return path.contains(transformedPoint, toWindRule(windingRule));
1204 }
1205 
1206 bool CanvasRenderingContext2DBase::isPointInStrokeInternal(const Path&amp; path, float x, float y)
1207 {
1208     auto* c = drawingContext();
1209     if (!c)
1210         return false;
1211     if (!state().hasInvertibleTransform)
1212         return false;
1213 
1214     auto transformedPoint = state().transform.inverse().valueOr(AffineTransform()).mapPoint(FloatPoint(x, y));
1215     if (!std::isfinite(transformedPoint.x()) || !std::isfinite(transformedPoint.y()))
1216         return false;
1217 
1218     CanvasStrokeStyleApplier applier(this);
<a name="19" id="anc19"></a><span class="line-modified">1219     return path.strokeContains(applier, transformedPoint);</span>
1220 }
1221 
1222 void CanvasRenderingContext2DBase::clearRect(float x, float y, float width, float height)
1223 {
1224     if (!validateRectForCanvas(x, y, width, height))
1225         return;
1226     auto* context = drawingContext();
1227     if (!context)
1228         return;
1229     if (!state().hasInvertibleTransform)
1230         return;
1231     FloatRect rect(x, y, width, height);
1232 
1233     bool saved = false;
1234     if (shouldDrawShadows()) {
1235         context-&gt;save();
1236         saved = true;
1237         context-&gt;setLegacyShadow(FloatSize(), 0, Color::transparent);
1238     }
1239     if (state().globalAlpha != 1) {
1240         if (!saved) {
1241             context-&gt;save();
1242             saved = true;
1243         }
1244         context-&gt;setAlpha(1);
1245     }
<a name="20" id="anc20"></a><span class="line-modified">1246     if (state().globalComposite != CompositeOperator::SourceOver) {</span>
1247         if (!saved) {
1248             context-&gt;save();
1249             saved = true;
1250         }
<a name="21" id="anc21"></a><span class="line-modified">1251         context-&gt;setCompositeOperation(CompositeOperator::SourceOver);</span>
1252     }
1253     context-&gt;clearRect(rect);
1254     if (saved)
1255         context-&gt;restore();
1256     didDraw(rect);
1257 }
1258 
1259 void CanvasRenderingContext2DBase::fillRect(float x, float y, float width, float height)
1260 {
1261     if (!validateRectForCanvas(x, y, width, height))
1262         return;
1263 
1264     auto* c = drawingContext();
1265     if (!c)
1266         return;
1267     if (!state().hasInvertibleTransform)
1268         return;
1269 
1270     // from the HTML5 Canvas spec:
1271     // If x0 = x1 and y0 = y1, then the linear gradient must paint nothing
1272     // If x0 = x1 and y0 = y1 and r0 = r1, then the radial gradient must paint nothing
1273     auto gradient = c-&gt;fillGradient();
1274     if (gradient &amp;&amp; gradient-&gt;isZeroSize())
1275         return;
1276 
1277     FloatRect rect(x, y, width, height);
1278 
1279     if (rectContainsCanvas(rect)) {
1280         c-&gt;fillRect(rect);
1281         didDrawEntireCanvas();
1282     } else if (isFullCanvasCompositeMode(state().globalComposite)) {
1283         beginCompositeLayer();
1284         c-&gt;fillRect(rect);
1285         endCompositeLayer();
1286         didDrawEntireCanvas();
<a name="22" id="anc22"></a><span class="line-modified">1287     } else if (state().globalComposite == CompositeOperator::Copy) {</span>
1288         clearCanvas();
1289         c-&gt;fillRect(rect);
1290         didDrawEntireCanvas();
1291     } else {
1292         c-&gt;fillRect(rect);
1293         didDraw(rect);
1294     }
1295 }
1296 
1297 void CanvasRenderingContext2DBase::strokeRect(float x, float y, float width, float height)
1298 {
1299     if (!validateRectForCanvas(x, y, width, height))
1300         return;
1301 
1302     auto* c = drawingContext();
1303     if (!c)
1304         return;
1305     if (!state().hasInvertibleTransform)
1306         return;
1307     if (!(state().lineWidth &gt;= 0))
1308         return;
1309 
1310     // If gradient size is zero, then paint nothing.
1311     auto gradient = c-&gt;strokeGradient();
1312     if (gradient &amp;&amp; gradient-&gt;isZeroSize())
1313         return;
1314 
1315     FloatRect rect(x, y, width, height);
1316     if (isFullCanvasCompositeMode(state().globalComposite)) {
1317         beginCompositeLayer();
1318         c-&gt;strokeRect(rect, state().lineWidth);
1319         endCompositeLayer();
1320         didDrawEntireCanvas();
<a name="23" id="anc23"></a><span class="line-modified">1321     } else if (state().globalComposite == CompositeOperator::Copy) {</span>
1322         clearCanvas();
1323         c-&gt;strokeRect(rect, state().lineWidth);
1324         didDrawEntireCanvas();
1325     } else {
1326         FloatRect boundingRect = rect;
1327         boundingRect.inflate(state().lineWidth / 2);
1328         c-&gt;strokeRect(rect, state().lineWidth);
1329         didDraw(boundingRect);
1330     }
1331 }
1332 
1333 void CanvasRenderingContext2DBase::setShadow(float width, float height, float blur, const String&amp; colorString, Optional&lt;float&gt; alpha)
1334 {
1335     Color color = Color::transparent;
1336     if (!colorString.isNull()) {
<a name="24" id="anc24"></a><span class="line-modified">1337         color = parseColorOrCurrentColor(colorString, canvasBase());</span>

1338         if (!color.isValid())
1339             return;
1340     }
1341     // FIXME: Should not use RGBA32 here.
1342     setShadow(FloatSize(width, height), blur, colorWithOverrideAlpha(color.rgb(), alpha));
1343 }
1344 
1345 void CanvasRenderingContext2DBase::setShadow(float width, float height, float blur, float grayLevel, float alpha)
1346 {
1347     setShadow(FloatSize(width, height), blur, Color(grayLevel, grayLevel, grayLevel, alpha));
1348 }
1349 
1350 void CanvasRenderingContext2DBase::setShadow(float width, float height, float blur, float r, float g, float b, float a)
1351 {
1352     setShadow(FloatSize(width, height), blur, Color(r, g, b, a));
1353 }
1354 
1355 void CanvasRenderingContext2DBase::setShadow(float width, float height, float blur, float c, float m, float y, float k, float a)
1356 {
1357     setShadow(FloatSize(width, height), blur, Color(c, m, y, k, a));
1358 }
1359 
1360 void CanvasRenderingContext2DBase::clearShadow()
1361 {
1362     setShadow(FloatSize(), 0, Color::transparent);
1363 }
1364 
1365 void CanvasRenderingContext2DBase::setShadow(const FloatSize&amp; offset, float blur, const Color&amp; color)
1366 {
1367     if (state().shadowOffset == offset &amp;&amp; state().shadowBlur == blur &amp;&amp; state().shadowColor == color)
1368         return;
1369     bool wasDrawingShadows = shouldDrawShadows();
1370     realizeSaves();
1371     modifiableState().shadowOffset = offset;
1372     modifiableState().shadowBlur = blur;
1373     modifiableState().shadowColor = color;
1374     if (!wasDrawingShadows &amp;&amp; !shouldDrawShadows())
1375         return;
1376     applyShadow();
1377 }
1378 
1379 void CanvasRenderingContext2DBase::applyShadow()
1380 {
1381     auto* c = drawingContext();
1382     if (!c)
1383         return;
1384 
1385     if (shouldDrawShadows()) {
1386         float width = state().shadowOffset.width();
1387         float height = state().shadowOffset.height();
1388         c-&gt;setLegacyShadow(FloatSize(width, -height), state().shadowBlur, state().shadowColor);
1389     } else
1390         c-&gt;setLegacyShadow(FloatSize(), 0, Color::transparent);
1391 }
1392 
1393 bool CanvasRenderingContext2DBase::shouldDrawShadows() const
1394 {
1395     return state().shadowColor.isVisible() &amp;&amp; (state().shadowBlur || !state().shadowOffset.isZero());
1396 }
1397 
1398 enum class ImageSizeType { AfterDevicePixelRatio, BeforeDevicePixelRatio };
1399 static LayoutSize size(HTMLImageElement&amp; element, ImageSizeType sizeType = ImageSizeType::BeforeDevicePixelRatio)
1400 {
1401     LayoutSize size;
1402     if (auto* cachedImage = element.cachedImage()) {
1403         size = cachedImage-&gt;imageSizeForRenderer(element.renderer(), 1.0f); // FIXME: Not sure about this.
1404         if (sizeType == ImageSizeType::AfterDevicePixelRatio &amp;&amp; is&lt;RenderImage&gt;(element.renderer()) &amp;&amp; cachedImage-&gt;image() &amp;&amp; !cachedImage-&gt;image()-&gt;hasRelativeWidth())
1405             size.scale(downcast&lt;RenderImage&gt;(*element.renderer()).imageDevicePixelRatio());
1406     }
1407     return size;
1408 }
1409 
<a name="25" id="anc25"></a><span class="line-modified">1410 static inline FloatSize size(CanvasBase&amp; canvas)</span>
1411 {
<a name="26" id="anc26"></a><span class="line-modified">1412     return canvas.size();</span>
1413 }
1414 
1415 static inline FloatSize size(ImageBitmap&amp; imageBitmap)
1416 {
1417     return FloatSize { static_cast&lt;float&gt;(imageBitmap.width()), static_cast&lt;float&gt;(imageBitmap.height()) };
1418 }
1419 
1420 #if ENABLE(VIDEO)
1421 
1422 static inline FloatSize size(HTMLVideoElement&amp; video)
1423 {
1424     auto player = video.player();
1425     if (!player)
1426         return { };
1427     return player-&gt;naturalSize();
1428 }
1429 
1430 #endif
1431 
1432 #if ENABLE(CSS_TYPED_OM)
1433 static inline FloatSize size(TypedOMCSSImageValue&amp; image)
1434 {
1435     auto* cachedImage = image.image();
1436     if (!cachedImage)
1437         return FloatSize();
1438 
1439     return cachedImage-&gt;imageSizeForRenderer(nullptr, 1.0f);
1440 }
1441 #endif
1442 
1443 static inline FloatRect normalizeRect(const FloatRect&amp; rect)
1444 {
1445     return FloatRect(std::min(rect.x(), rect.maxX()),
1446         std::min(rect.y(), rect.maxY()),
1447         std::max(rect.width(), -rect.width()),
1448         std::max(rect.height(), -rect.height()));
1449 }
1450 
1451 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(CanvasImageSource&amp;&amp; image, float dx, float dy)
1452 {
1453     return WTF::switchOn(image,
1454         [&amp;] (RefPtr&lt;HTMLImageElement&gt;&amp; imageElement) -&gt; ExceptionOr&lt;void&gt; {
1455             LayoutSize destRectSize = size(*imageElement, ImageSizeType::AfterDevicePixelRatio);
1456             LayoutSize sourceRectSize = size(*imageElement, ImageSizeType::BeforeDevicePixelRatio);
1457             return this-&gt;drawImage(*imageElement, FloatRect { 0, 0, sourceRectSize.width(), sourceRectSize.height() }, FloatRect { dx, dy, destRectSize.width(), destRectSize.height() });
1458         },
1459         [&amp;] (auto&amp; element) -&gt; ExceptionOr&lt;void&gt; {
1460             FloatSize elementSize = size(*element);
1461             return this-&gt;drawImage(*element, FloatRect { 0, 0, elementSize.width(), elementSize.height() }, FloatRect { dx, dy, elementSize.width(), elementSize.height() });
1462         }
1463     );
1464 }
1465 
1466 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(CanvasImageSource&amp;&amp; image, float dx, float dy, float dw, float dh)
1467 {
1468     return WTF::switchOn(image,
1469         [&amp;] (auto&amp; element) -&gt; ExceptionOr&lt;void&gt; {
1470             FloatSize elementSize = size(*element);
1471             return this-&gt;drawImage(*element, FloatRect { 0, 0, elementSize.width(), elementSize.height() }, FloatRect { dx, dy, dw, dh });
1472         }
1473     );
1474 }
1475 
1476 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(CanvasImageSource&amp;&amp; image, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh)
1477 {
1478     return WTF::switchOn(image,
1479         [&amp;] (auto&amp; element) -&gt; ExceptionOr&lt;void&gt; {
1480             return this-&gt;drawImage(*element, FloatRect { sx, sy, sw, sh }, FloatRect { dx, dy, dw, dh });
1481         }
1482     );
1483 }
1484 
1485 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(HTMLImageElement&amp; imageElement, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect)
1486 {
1487     return drawImage(imageElement, srcRect, dstRect, state().globalComposite, state().globalBlend);
1488 }
1489 
1490 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(HTMLImageElement&amp; imageElement, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect, const CompositeOperator&amp; op, const BlendMode&amp; blendMode)
1491 {
1492     if (!imageElement.complete())
1493         return { };
1494     FloatRect imageRect = FloatRect(FloatPoint(), size(imageElement, ImageSizeType::BeforeDevicePixelRatio));
1495 
1496     auto result = drawImage(imageElement.document(), imageElement.cachedImage(), imageElement.renderer(), imageRect, srcRect, dstRect, op, blendMode);
1497 
1498     if (!result.hasException())
1499         checkOrigin(&amp;imageElement);
1500     return result;
1501 }
1502 
1503 #if ENABLE(CSS_TYPED_OM)
1504 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(TypedOMCSSImageValue&amp; image, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect)
1505 {
1506     auto* cachedImage = image.image();
1507     if (!cachedImage || !image.document())
1508         return { };
1509     FloatRect imageRect = FloatRect(FloatPoint(), size(image));
1510 
1511     auto result = drawImage(*image.document(), cachedImage, nullptr, imageRect, srcRect, dstRect, state().globalComposite, state().globalBlend);
1512 
1513     if (!result.hasException())
1514         checkOrigin(image);
1515     return result;
1516 }
1517 #endif
1518 
1519 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(Document&amp; document, CachedImage* cachedImage, const RenderObject* renderer, const FloatRect&amp; imageRect, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect, const CompositeOperator&amp; op, const BlendMode&amp; blendMode)
1520 {
1521     if (!std::isfinite(dstRect.x()) || !std::isfinite(dstRect.y()) || !std::isfinite(dstRect.width()) || !std::isfinite(dstRect.height())
1522         || !std::isfinite(srcRect.x()) || !std::isfinite(srcRect.y()) || !std::isfinite(srcRect.width()) || !std::isfinite(srcRect.height()))
1523         return { };
1524 
1525     if (!dstRect.width() || !dstRect.height())
1526         return { };
1527 
1528     FloatRect normalizedSrcRect = normalizeRect(srcRect);
1529     FloatRect normalizedDstRect = normalizeRect(dstRect);
1530 
1531     if (!srcRect.width() || !srcRect.height())
1532         return Exception { IndexSizeError };
1533 
1534     // When the source rectangle is outside the source image, the source rectangle must be clipped
1535     // to the source image and the destination rectangle must be clipped in the same proportion.
1536     FloatRect originalNormalizedSrcRect = normalizedSrcRect;
1537     normalizedSrcRect.intersect(imageRect);
1538     if (normalizedSrcRect.isEmpty())
1539         return { };
1540 
1541     if (normalizedSrcRect != originalNormalizedSrcRect) {
1542         normalizedDstRect.setWidth(normalizedDstRect.width() * normalizedSrcRect.width() / originalNormalizedSrcRect.width());
1543         normalizedDstRect.setHeight(normalizedDstRect.height() * normalizedSrcRect.height() / originalNormalizedSrcRect.height());
1544         if (normalizedDstRect.isEmpty())
1545             return { };
1546     }
1547 
1548     GraphicsContext* c = drawingContext();
1549     if (!c)
1550         return { };
1551     if (!state().hasInvertibleTransform)
1552         return { };
1553 
1554     if (!cachedImage)
1555         return { };
1556 
1557     RefPtr&lt;Image&gt; image = cachedImage-&gt;imageForRenderer(renderer);
1558     if (!image)
1559         return { };
1560 
1561     ImageObserver* observer = image-&gt;imageObserver();
1562 
1563     if (image-&gt;isSVGImage()) {
1564         image-&gt;setImageObserver(nullptr);
1565         image-&gt;setContainerSize(imageRect.size());
1566     }
1567 
1568     if (image-&gt;isBitmapImage()) {
1569         // Drawing an animated image to a canvas should draw the first frame (except for a few layout tests)
1570         if (image-&gt;isAnimated() &amp;&amp; !document.settings().animatedImageDebugCanvasDrawingEnabled())
1571             image = BitmapImage::create(image-&gt;nativeImage());
1572         downcast&lt;BitmapImage&gt;(*image).updateFromSettings(document.settings());
1573     }
1574 
<a name="27" id="anc27"></a><span class="line-added">1575     ImagePaintingOptions options = { op, blendMode, ImageOrientation::FromImage };</span>
<span class="line-added">1576 </span>
1577     if (rectContainsCanvas(normalizedDstRect)) {
<a name="28" id="anc28"></a><span class="line-modified">1578         c-&gt;drawImage(*image, normalizedDstRect, normalizedSrcRect, options);</span>
1579         didDrawEntireCanvas();
1580     } else if (isFullCanvasCompositeMode(op)) {
1581         fullCanvasCompositedDrawImage(*image, normalizedDstRect, normalizedSrcRect, op);
1582         didDrawEntireCanvas();
<a name="29" id="anc29"></a><span class="line-modified">1583     } else if (op == CompositeOperator::Copy) {</span>
1584         clearCanvas();
<a name="30" id="anc30"></a><span class="line-modified">1585         c-&gt;drawImage(*image, normalizedDstRect, normalizedSrcRect, options);</span>
1586         didDrawEntireCanvas();
1587     } else {
<a name="31" id="anc31"></a><span class="line-modified">1588         c-&gt;drawImage(*image, normalizedDstRect, normalizedSrcRect, options);</span>
1589         didDraw(normalizedDstRect);
1590     }
1591 
1592     if (image-&gt;isSVGImage())
1593         image-&gt;setImageObserver(observer);
1594 
1595     return { };
1596 }
1597 
<a name="32" id="anc32"></a><span class="line-modified">1598 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(CanvasBase&amp; sourceCanvas, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect)</span>
1599 {
1600     FloatRect srcCanvasRect = FloatRect(FloatPoint(), sourceCanvas.size());
1601 
1602     if (!srcCanvasRect.width() || !srcCanvasRect.height())
1603         return Exception { InvalidStateError };
1604 
1605     if (!srcRect.width() || !srcRect.height())
1606         return Exception { IndexSizeError };
1607 
1608     if (!srcCanvasRect.contains(normalizeRect(srcRect)) || !dstRect.width() || !dstRect.height())
1609         return { };
1610 
1611     GraphicsContext* c = drawingContext();
1612     if (!c)
1613         return { };
1614     if (!state().hasInvertibleTransform)
1615         return { };
1616 
1617     // FIXME: Do this through platform-independent GraphicsContext API.
1618     ImageBuffer* buffer = sourceCanvas.buffer();
1619     if (!buffer)
1620         return { };
1621 
1622     checkOrigin(&amp;sourceCanvas);
1623 
1624 #if ENABLE(ACCELERATED_2D_CANVAS)
1625     // If we&#39;re drawing from one accelerated canvas 2d to another, avoid calling sourceCanvas.makeRenderingResultsAvailable()
1626     // as that will do a readback to software.
1627     RefPtr&lt;CanvasRenderingContext&gt; sourceContext = sourceCanvas.renderingContext();
1628     // FIXME: Implement an accelerated path for drawing from a WebGL canvas to a 2d canvas when possible.
1629     if (!isAccelerated() || !sourceContext || !sourceContext-&gt;isAccelerated() || !sourceContext-&gt;is2d())
1630         sourceCanvas.makeRenderingResultsAvailable();
1631 #else
1632     sourceCanvas.makeRenderingResultsAvailable();
1633 #endif
1634 
1635     if (rectContainsCanvas(dstRect)) {
1636         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });
1637         didDrawEntireCanvas();
1638     } else if (isFullCanvasCompositeMode(state().globalComposite)) {
1639         fullCanvasCompositedDrawImage(*buffer, dstRect, srcRect, state().globalComposite);
1640         didDrawEntireCanvas();
<a name="33" id="anc33"></a><span class="line-modified">1641     } else if (state().globalComposite == CompositeOperator::Copy) {</span>
1642         if (&amp;sourceCanvas == &amp;canvasBase()) {
<a name="34" id="anc34"></a><span class="line-modified">1643             if (auto copy = buffer-&gt;copyRectToBuffer(srcRect, ColorSpace::SRGB, *c)) {</span>
1644                 clearCanvas();
1645                 c-&gt;drawImageBuffer(*copy, dstRect, { { }, srcRect.size() }, { state().globalComposite, state().globalBlend });
1646             }
1647         } else {
1648             clearCanvas();
1649             c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });
1650         }
1651         didDrawEntireCanvas();
1652     } else {
1653         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });
1654         didDraw(dstRect);
1655     }
1656 
1657     return { };
1658 }
1659 
1660 #if ENABLE(VIDEO)
1661 
1662 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(HTMLVideoElement&amp; video, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect)
1663 {
1664     if (video.readyState() == HTMLMediaElement::HAVE_NOTHING || video.readyState() == HTMLMediaElement::HAVE_METADATA)
1665         return { };
1666 
1667     FloatRect videoRect = FloatRect(FloatPoint(), size(video));
1668     if (!srcRect.width() || !srcRect.height())
1669         return Exception { IndexSizeError };
1670 
1671     if (!videoRect.contains(normalizeRect(srcRect)) || !dstRect.width() || !dstRect.height())
1672         return { };
1673 
1674     GraphicsContext* c = drawingContext();
1675     if (!c)
1676         return { };
1677     if (!state().hasInvertibleTransform)
1678         return { };
1679 
1680     checkOrigin(&amp;video);
1681 
1682 #if USE(CG) || (ENABLE(ACCELERATED_2D_CANVAS) &amp;&amp; USE(GSTREAMER_GL) &amp;&amp; USE(CAIRO))
1683     if (NativeImagePtr image = video.nativeImageForCurrentTime()) {
1684         c-&gt;drawNativeImage(image, FloatSize(video.videoWidth(), video.videoHeight()), dstRect, srcRect);
1685         if (rectContainsCanvas(dstRect))
1686             didDrawEntireCanvas();
1687         else
1688             didDraw(dstRect);
1689 
1690         return { };
1691     }
1692 #endif
1693 
1694     GraphicsContextStateSaver stateSaver(*c);
1695     c-&gt;clip(dstRect);
1696     c-&gt;translate(dstRect.location());
1697     c-&gt;scale(FloatSize(dstRect.width() / srcRect.width(), dstRect.height() / srcRect.height()));
1698     c-&gt;translate(-srcRect.location());
1699     video.paintCurrentFrameInContext(*c, FloatRect(FloatPoint(), size(video)));
1700     stateSaver.restore();
1701     didDraw(dstRect);
1702 
1703     return { };
1704 }
1705 
1706 #endif
1707 
1708 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(ImageBitmap&amp; imageBitmap, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect)
1709 {
1710     if (!imageBitmap.width() || !imageBitmap.height())
1711         return Exception { InvalidStateError };
1712 
1713     if (!srcRect.width() || !srcRect.height())
1714         return Exception { IndexSizeError };
1715 
1716     FloatRect srcBitmapRect = FloatRect(FloatPoint(), FloatSize(imageBitmap.width(), imageBitmap.height()));
1717 
1718     if (!srcBitmapRect.contains(normalizeRect(srcRect)) || !dstRect.width() || !dstRect.height())
1719         return { };
1720 
1721     GraphicsContext* c = drawingContext();
1722     if (!c)
1723         return { };
1724     if (!state().hasInvertibleTransform)
1725         return { };
1726 
1727     ImageBuffer* buffer = imageBitmap.buffer();
1728     if (!buffer)
1729         return { };
1730 
1731     checkOrigin(&amp;imageBitmap);
1732 
1733     if (rectContainsCanvas(dstRect)) {
1734         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });
1735         didDrawEntireCanvas();
1736     } else if (isFullCanvasCompositeMode(state().globalComposite)) {
1737         fullCanvasCompositedDrawImage(*buffer, dstRect, srcRect, state().globalComposite);
1738         didDrawEntireCanvas();
<a name="35" id="anc35"></a><span class="line-modified">1739     } else if (state().globalComposite == CompositeOperator::Copy) {</span>
1740         clearCanvas();
1741         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });
1742         didDrawEntireCanvas();
1743     } else {
1744         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });
1745         didDraw(dstRect);
1746     }
1747 
1748     return { };
1749 }
1750 
1751 void CanvasRenderingContext2DBase::drawImageFromRect(HTMLImageElement&amp; imageElement, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh, const String&amp; compositeOperation)
1752 {
1753     CompositeOperator op;
1754     auto blendOp = BlendMode::Normal;
1755     if (!parseCompositeAndBlendOperator(compositeOperation, op, blendOp) || blendOp != BlendMode::Normal)
<a name="36" id="anc36"></a><span class="line-modified">1756         op = CompositeOperator::SourceOver;</span>
1757     drawImage(imageElement, FloatRect { sx, sy, sw, sh }, FloatRect { dx, dy, dw, dh }, op, BlendMode::Normal);
1758 }
1759 
1760 void CanvasRenderingContext2DBase::clearCanvas()
1761 {
1762     auto* c = drawingContext();
1763     if (!c)
1764         return;
1765 
1766     c-&gt;save();
1767     c-&gt;setCTM(canvasBase().baseTransform());
1768     c-&gt;clearRect(FloatRect(0, 0, canvasBase().width(), canvasBase().height()));
1769     c-&gt;restore();
1770 }
1771 
1772 Path CanvasRenderingContext2DBase::transformAreaToDevice(const Path&amp; path) const
1773 {
1774     Path transformed(path);
1775     transformed.transform(state().transform);
1776     transformed.transform(canvasBase().baseTransform());
1777     return transformed;
1778 }
1779 
1780 Path CanvasRenderingContext2DBase::transformAreaToDevice(const FloatRect&amp; rect) const
1781 {
1782     Path path;
1783     path.addRect(rect);
1784     return transformAreaToDevice(path);
1785 }
1786 
1787 bool CanvasRenderingContext2DBase::rectContainsCanvas(const FloatRect&amp; rect) const
1788 {
1789     FloatQuad quad(rect);
1790     FloatQuad canvasQuad(FloatRect(0, 0, canvasBase().width(), canvasBase().height()));
1791     return state().transform.mapQuad(quad).containsQuad(canvasQuad);
1792 }
1793 
1794 template&lt;class T&gt; IntRect CanvasRenderingContext2DBase::calculateCompositingBufferRect(const T&amp; area, IntSize* croppedOffset)
1795 {
1796     IntRect canvasRect(0, 0, canvasBase().width(), canvasBase().height());
1797     canvasRect = canvasBase().baseTransform().mapRect(canvasRect);
1798     Path path = transformAreaToDevice(area);
1799     IntRect bufferRect = enclosingIntRect(path.fastBoundingRect());
1800     IntPoint originalLocation = bufferRect.location();
1801     bufferRect.intersect(canvasRect);
1802     if (croppedOffset)
1803         *croppedOffset = originalLocation - bufferRect.location();
1804     return bufferRect;
1805 }
1806 
1807 std::unique_ptr&lt;ImageBuffer&gt; CanvasRenderingContext2DBase::createCompositingBuffer(const IntRect&amp; bufferRect)
1808 {
<a name="37" id="anc37"></a><span class="line-modified">1809     return ImageBuffer::create(bufferRect.size(), isAccelerated() ? RenderingMode::Accelerated : RenderingMode::Unaccelerated);</span>
1810 }
1811 
1812 void CanvasRenderingContext2DBase::compositeBuffer(ImageBuffer&amp; buffer, const IntRect&amp; bufferRect, CompositeOperator op)
1813 {
1814     IntRect canvasRect(0, 0, canvasBase().width(), canvasBase().height());
1815     canvasRect = canvasBase().baseTransform().mapRect(canvasRect);
1816 
1817     auto* c = drawingContext();
1818     if (!c)
1819         return;
1820 
1821     c-&gt;save();
1822     c-&gt;setCTM(AffineTransform());
1823     c-&gt;setCompositeOperation(op);
1824 
1825     c-&gt;save();
1826     c-&gt;clipOut(bufferRect);
1827     c-&gt;clearRect(canvasRect);
1828     c-&gt;restore();
1829     c-&gt;drawImageBuffer(buffer, bufferRect.location(), state().globalComposite);
1830     c-&gt;restore();
1831 }
1832 
1833 static void drawImageToContext(Image&amp; image, GraphicsContext&amp; context, const FloatRect&amp; dest, const FloatRect&amp; src, const ImagePaintingOptions&amp; options)
1834 {
1835     context.drawImage(image, dest, src, options);
1836 }
1837 
1838 static void drawImageToContext(ImageBuffer&amp; imageBuffer, GraphicsContext&amp; context, const FloatRect&amp; dest, const FloatRect&amp; src, const ImagePaintingOptions&amp; options)
1839 {
1840     context.drawImageBuffer(imageBuffer, dest, src, options);
1841 }
1842 
1843 template&lt;class T&gt; void CanvasRenderingContext2DBase::fullCanvasCompositedDrawImage(T&amp; image, const FloatRect&amp; dest, const FloatRect&amp; src, CompositeOperator op)
1844 {
1845     ASSERT(isFullCanvasCompositeMode(op));
1846 
1847     IntSize croppedOffset;
1848     auto bufferRect = calculateCompositingBufferRect(dest, &amp;croppedOffset);
1849     if (bufferRect.isEmpty()) {
1850         clearCanvas();
1851         return;
1852     }
1853 
1854     auto buffer = createCompositingBuffer(bufferRect);
1855     if (!buffer)
1856         return;
1857 
1858     auto* c = drawingContext();
1859     if (!c)
1860         return;
1861 
1862     FloatRect adjustedDest = dest;
1863     adjustedDest.setLocation(FloatPoint(0, 0));
1864     AffineTransform effectiveTransform = c-&gt;getCTM();
1865     IntRect transformedAdjustedRect = enclosingIntRect(effectiveTransform.mapRect(adjustedDest));
1866     buffer-&gt;context().translate(-transformedAdjustedRect.location());
1867     buffer-&gt;context().translate(croppedOffset);
1868     buffer-&gt;context().concatCTM(effectiveTransform);
<a name="38" id="anc38"></a><span class="line-modified">1869     drawImageToContext(image, buffer-&gt;context(), adjustedDest, src, { CompositeOperator::SourceOver });</span>
1870 
1871     compositeBuffer(*buffer, bufferRect, op);
1872 }
1873 
<a name="39" id="anc39"></a><span class="line-modified">1874 static CanvasRenderingContext2DBase::StyleVariant toStyleVariant(const CanvasStyle&amp; style)</span>
1875 {
1876     if (auto gradient = style.canvasGradient())
1877         return gradient;
1878     if (auto pattern = style.canvasPattern())
1879         return pattern;
1880     return style.color();
1881 }
1882 
<a name="40" id="anc40"></a><span class="line-modified">1883 CanvasRenderingContext2DBase::StyleVariant CanvasRenderingContext2DBase::strokeStyle() const</span>
1884 {
<a name="41" id="anc41"></a><span class="line-modified">1885     return toStyleVariant(state().strokeStyle);</span>
1886 }
1887 
<a name="42" id="anc42"></a><span class="line-modified">1888 void CanvasRenderingContext2DBase::setStrokeStyle(CanvasRenderingContext2DBase::StyleVariant&amp;&amp; style)</span>
1889 {
1890     WTF::switchOn(style,
1891         [this] (const String&amp; string) { this-&gt;setStrokeColor(string); },
1892         [this] (const RefPtr&lt;CanvasGradient&gt;&amp; gradient) { this-&gt;setStrokeStyle(CanvasStyle(*gradient)); },
1893         [this] (const RefPtr&lt;CanvasPattern&gt;&amp; pattern) { this-&gt;setStrokeStyle(CanvasStyle(*pattern)); }
1894     );
1895 }
1896 
<a name="43" id="anc43"></a><span class="line-modified">1897 CanvasRenderingContext2DBase::StyleVariant CanvasRenderingContext2DBase::fillStyle() const</span>
1898 {
<a name="44" id="anc44"></a><span class="line-modified">1899     return toStyleVariant(state().fillStyle);</span>
1900 }
1901 
<a name="45" id="anc45"></a><span class="line-modified">1902 void CanvasRenderingContext2DBase::setFillStyle(CanvasRenderingContext2DBase::StyleVariant&amp;&amp; style)</span>
1903 {
1904     WTF::switchOn(style,
1905         [this] (const String&amp; string) { this-&gt;setFillColor(string); },
1906         [this] (const RefPtr&lt;CanvasGradient&gt;&amp; gradient) { this-&gt;setFillStyle(CanvasStyle(*gradient)); },
1907         [this] (const RefPtr&lt;CanvasPattern&gt;&amp; pattern) { this-&gt;setFillStyle(CanvasStyle(*pattern)); }
1908     );
1909 }
1910 
1911 ExceptionOr&lt;Ref&lt;CanvasGradient&gt;&gt; CanvasRenderingContext2DBase::createLinearGradient(float x0, float y0, float x1, float y1)
1912 {
1913     if (!std::isfinite(x0) || !std::isfinite(y0) || !std::isfinite(x1) || !std::isfinite(y1))
1914         return Exception { NotSupportedError };
1915 
<a name="46" id="anc46"></a><span class="line-modified">1916     return CanvasGradient::create(FloatPoint(x0, y0), FloatPoint(x1, y1), canvasBase());</span>
1917 }
1918 
1919 ExceptionOr&lt;Ref&lt;CanvasGradient&gt;&gt; CanvasRenderingContext2DBase::createRadialGradient(float x0, float y0, float r0, float x1, float y1, float r1)
1920 {
1921     if (!std::isfinite(x0) || !std::isfinite(y0) || !std::isfinite(r0) || !std::isfinite(x1) || !std::isfinite(y1) || !std::isfinite(r1))
1922         return Exception { NotSupportedError };
1923 
1924     if (r0 &lt; 0 || r1 &lt; 0)
1925         return Exception { IndexSizeError };
1926 
<a name="47" id="anc47"></a><span class="line-modified">1927     return CanvasGradient::create(FloatPoint(x0, y0), r0, FloatPoint(x1, y1), r1, canvasBase());</span>
1928 }
1929 
1930 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(CanvasImageSource&amp;&amp; image, const String&amp; repetition)
1931 {
1932     bool repeatX, repeatY;
1933     if (!CanvasPattern::parseRepetitionType(repetition, repeatX, repeatY))
1934         return Exception { SyntaxError };
1935 
1936     return WTF::switchOn(image,
1937         [&amp;] (auto&amp; element) -&gt; ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; { return this-&gt;createPattern(*element, repeatX, repeatY); }
1938     );
1939 }
1940 
1941 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(HTMLImageElement&amp; imageElement, bool repeatX, bool repeatY)
1942 {
1943     auto* cachedImage = imageElement.cachedImage();
1944 
1945     // If the image loading hasn&#39;t started or the image is not complete, it is not fully decodable.
1946     if (!cachedImage || !imageElement.complete())
1947         return nullptr;
1948 
1949     if (cachedImage-&gt;status() == CachedResource::LoadError)
1950         return Exception { InvalidStateError };
1951 
1952     bool originClean = cachedImage-&gt;isOriginClean(canvasBase().securityOrigin());
1953 
1954     // FIXME: SVG images with animations can switch between clean and dirty (leaking cross-origin
1955     // data). We should either:
1956     //   1) Take a fixed snapshot of an SVG image when creating a pattern and determine then whether
1957     //      the origin is clean.
1958     //   2) Dynamically verify the origin checks at draw time, and dirty the canvas accordingly.
1959     // To be on the safe side, taint the origin for all patterns containing SVG images for now.
1960     if (cachedImage-&gt;image()-&gt;isSVGImage())
1961         originClean = false;
1962 
1963     return RefPtr&lt;CanvasPattern&gt; { CanvasPattern::create(*cachedImage-&gt;imageForRenderer(imageElement.renderer()), repeatX, repeatY, originClean) };
1964 }
1965 
1966 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(CanvasBase&amp; canvas, bool repeatX, bool repeatY)
1967 {
1968     if (!canvas.width() || !canvas.height())
1969         return Exception { InvalidStateError };
1970     auto* copiedImage = canvas.copiedImage();
1971 
1972     if (!copiedImage)
1973         return Exception { InvalidStateError };
1974 
1975     return RefPtr&lt;CanvasPattern&gt; { CanvasPattern::create(*copiedImage, repeatX, repeatY, canvas.originClean()) };
1976 }
1977 
1978 #if ENABLE(VIDEO)
1979 
1980 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(HTMLVideoElement&amp; videoElement, bool repeatX, bool repeatY)
1981 {
1982     if (videoElement.readyState() &lt; HTMLMediaElement::HAVE_CURRENT_DATA)
1983         return nullptr;
1984 
1985     checkOrigin(&amp;videoElement);
1986     bool originClean = canvasBase().originClean();
1987 
1988 #if USE(CG) || (ENABLE(ACCELERATED_2D_CANVAS) &amp;&amp; USE(GSTREAMER_GL) &amp;&amp; USE(CAIRO))
1989     if (auto nativeImage = videoElement.nativeImageForCurrentTime())
1990         return RefPtr&lt;CanvasPattern&gt; { CanvasPattern::create(BitmapImage::create(WTFMove(nativeImage)), repeatX, repeatY, originClean) };
1991 #endif
1992 
<a name="48" id="anc48"></a><span class="line-modified">1993     auto imageBuffer = ImageBuffer::create(size(videoElement), drawingContext() ? drawingContext()-&gt;renderingMode() : RenderingMode::Accelerated);</span>
1994     if (!imageBuffer)
1995         return nullptr;
1996 
1997     videoElement.paintCurrentFrameInContext(imageBuffer-&gt;context(), FloatRect(FloatPoint(), size(videoElement)));
1998 
1999     return RefPtr&lt;CanvasPattern&gt; { CanvasPattern::create(ImageBuffer::sinkIntoImage(WTFMove(imageBuffer), PreserveResolution::Yes).releaseNonNull(), repeatX, repeatY, originClean) };
2000 }
2001 
2002 #endif
2003 
2004 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(ImageBitmap&amp;, bool, bool)
2005 {
2006     // FIXME: Implement.
2007     return Exception { TypeError };
2008 }
2009 
2010 #if ENABLE(CSS_TYPED_OM)
2011 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(TypedOMCSSImageValue&amp;, bool, bool)
2012 {
2013     // FIXME: Implement.
2014     return Exception { TypeError };
2015 }
2016 #endif
2017 
2018 void CanvasRenderingContext2DBase::didDrawEntireCanvas()
2019 {
2020     didDraw(FloatRect(FloatPoint::zero(), canvasBase().size()), CanvasDidDrawApplyClip);
2021 }
2022 
2023 void CanvasRenderingContext2DBase::didDraw(const FloatRect&amp; r, unsigned options)
2024 {
2025     auto* c = drawingContext();
2026     if (!c)
2027         return;
2028     if (!state().hasInvertibleTransform)
2029         return;
2030 
2031 #if ENABLE(ACCELERATED_2D_CANVAS)
2032     // If we are drawing to hardware and we have a composited layer, just call contentChanged().
<a name="49" id="anc49"></a><span class="line-modified">2033     if (isAccelerated() &amp;&amp; is&lt;HTMLCanvasElement&gt;(canvasBase())) {</span>
2034         auto&amp; canvas = downcast&lt;HTMLCanvasElement&gt;(canvasBase());
2035         RenderBox* renderBox = canvas.renderBox();
2036         if (renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing()) {
2037             renderBox-&gt;contentChanged(CanvasPixelsChanged);
2038             canvas.clearCopiedImage();
2039             canvas.notifyObserversCanvasChanged(r);
2040             return;
2041         }
2042     }
2043 #endif
2044 
2045     FloatRect dirtyRect = r;
2046     if (options &amp; CanvasDidDrawApplyTransform) {
2047         AffineTransform ctm = state().transform;
2048         dirtyRect = ctm.mapRect(r);
2049     }
2050 
2051     if (options &amp; CanvasDidDrawApplyShadow &amp;&amp; state().shadowColor.isVisible()) {
2052         // The shadow gets applied after transformation
2053         FloatRect shadowRect(dirtyRect);
2054         shadowRect.move(state().shadowOffset);
2055         shadowRect.inflate(state().shadowBlur);
2056         dirtyRect.unite(shadowRect);
2057     }
2058 
2059     if (options &amp; CanvasDidDrawApplyClip) {
2060         // FIXME: apply the current clip to the rectangle. Unfortunately we can&#39;t get the clip
2061         // back out of the GraphicsContext, so to take clip into account for incremental painting,
2062         // we&#39;d have to keep the clip path around.
2063     }
2064 
2065     canvasBase().didDraw(dirtyRect);
2066 }
2067 
2068 void CanvasRenderingContext2DBase::setTracksDisplayListReplay(bool tracksDisplayListReplay)
2069 {
2070     if (tracksDisplayListReplay == m_tracksDisplayListReplay)
2071         return;
2072 
2073     m_tracksDisplayListReplay = tracksDisplayListReplay;
2074     if (!m_tracksDisplayListReplay)
2075         contextDisplayListMap().remove(this);
2076 }
2077 
2078 String CanvasRenderingContext2DBase::displayListAsText(DisplayList::AsTextFlags flags) const
2079 {
2080     if (!m_recordingContext)
2081         return { };
2082     return m_recordingContext-&gt;displayList.asText(flags);
2083 }
2084 
2085 String CanvasRenderingContext2DBase::replayDisplayListAsText(DisplayList::AsTextFlags flags) const
2086 {
2087     auto* displayList = contextDisplayListMap().get(this);
2088     if (!displayList)
2089         return { };
2090     return displayList-&gt;asText(flags);
2091 }
2092 
2093 const Vector&lt;CanvasRenderingContext2DBase::State, 1&gt;&amp; CanvasRenderingContext2DBase::stateStack()
2094 {
2095     realizeSaves();
2096     return m_stateStack;
2097 }
2098 
2099 void CanvasRenderingContext2DBase::paintRenderingResultsToCanvas()
2100 {
2101     if (UNLIKELY(m_usesDisplayListDrawing)) {
2102         if (!m_recordingContext)
2103             return;
2104 
2105         FloatRect clip(FloatPoint::zero(), canvasBase().size());
2106         DisplayList::Replayer replayer(*canvasBase().drawingContext(), m_recordingContext-&gt;displayList);
2107 
2108         if (UNLIKELY(m_tracksDisplayListReplay)) {
2109             auto replayList = replayer.replay(clip, m_tracksDisplayListReplay);
2110             contextDisplayListMap().add(this, WTFMove(replayList));
2111         } else
2112             replayer.replay(clip);
2113 
2114         m_recordingContext-&gt;displayList.clear();
2115     }
2116 }
2117 
2118 GraphicsContext* CanvasRenderingContext2DBase::drawingContext() const
2119 {
2120     if (UNLIKELY(m_usesDisplayListDrawing)) {
2121         if (!m_recordingContext)
2122             m_recordingContext = makeUnique&lt;DisplayListDrawingContext&gt;(GraphicsContextState(), FloatRect(FloatPoint::zero(), canvasBase().size()));
2123         return &amp;m_recordingContext-&gt;context;
2124     }
2125 
2126     return canvasBase().drawingContext();
2127 }
2128 
2129 static RefPtr&lt;ImageData&gt; createEmptyImageData(const IntSize&amp; size)
2130 {
2131     auto data = ImageData::create(size);
2132     if (data)
2133         data-&gt;data()-&gt;zeroFill();
2134     return data;
2135 }
2136 
2137 RefPtr&lt;ImageData&gt; CanvasRenderingContext2DBase::createImageData(ImageData&amp; imageData) const
2138 {
2139     return createEmptyImageData(imageData.size());
2140 }
2141 
2142 ExceptionOr&lt;RefPtr&lt;ImageData&gt;&gt; CanvasRenderingContext2DBase::createImageData(float sw, float sh) const
2143 {
2144     if (!sw || !sh)
2145         return Exception { IndexSizeError };
2146 
2147     FloatSize logicalSize(std::abs(sw), std::abs(sh));
2148     if (!logicalSize.isExpressibleAsIntSize())
2149         return nullptr;
2150 
2151     IntSize size = expandedIntSize(logicalSize);
2152     if (size.width() &lt; 1)
2153         size.setWidth(1);
2154     if (size.height() &lt; 1)
2155         size.setHeight(1);
2156 
2157     return createEmptyImageData(size);
2158 }
2159 
2160 ExceptionOr&lt;RefPtr&lt;ImageData&gt;&gt; CanvasRenderingContext2DBase::getImageData(float sx, float sy, float sw, float sh) const
2161 {
2162     return getImageData(ImageBuffer::LogicalCoordinateSystem, sx, sy, sw, sh);
2163 }
2164 
2165 ExceptionOr&lt;RefPtr&lt;ImageData&gt;&gt; CanvasRenderingContext2DBase::getImageData(ImageBuffer::CoordinateSystem coordinateSystem, float sx, float sy, float sw, float sh) const
2166 {
2167     if (!canvasBase().originClean()) {
2168         static NeverDestroyed&lt;String&gt; consoleMessage(MAKE_STATIC_STRING_IMPL(&quot;Unable to get image data from canvas because the canvas has been tainted by cross-origin data.&quot;));
2169         canvasBase().scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, consoleMessage);
2170         return Exception { SecurityError };
2171     }
2172 
2173     if (!sw || !sh)
2174         return Exception { IndexSizeError };
2175 
2176     if (sw &lt; 0) {
2177         sx += sw;
2178         sw = -sw;
2179     }
2180     if (sh &lt; 0) {
2181         sy += sh;
2182         sh = -sh;
2183     }
2184 
2185     FloatRect logicalRect(sx, sy, sw, sh);
2186     if (logicalRect.width() &lt; 1)
2187         logicalRect.setWidth(1);
2188     if (logicalRect.height() &lt; 1)
2189         logicalRect.setHeight(1);
2190     if (!logicalRect.isExpressibleAsIntRect())
2191         return nullptr;
2192 
2193     IntRect imageDataRect = enclosingIntRect(logicalRect);
<a name="50" id="anc50"></a>
2194 
<a name="51" id="anc51"></a><span class="line-modified">2195     ImageBuffer* buffer = canvasBase().buffer();</span>
2196     if (!buffer)
2197         return createEmptyImageData(imageDataRect.size());
2198 
2199     auto byteArray = buffer-&gt;getUnmultipliedImageData(imageDataRect, nullptr, coordinateSystem);
2200     if (!byteArray) {
2201         StringBuilder consoleMessage;
2202         consoleMessage.appendLiteral(&quot;Unable to get image data from canvas. Requested size was &quot;);
2203         consoleMessage.appendNumber(imageDataRect.width());
2204         consoleMessage.appendLiteral(&quot; x &quot;);
2205         consoleMessage.appendNumber(imageDataRect.height());
2206 
2207         canvasBase().scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::Rendering, MessageLevel::Error, consoleMessage.toString());
2208         return Exception { InvalidStateError };
2209     }
2210 
2211     return ImageData::create(imageDataRect.size(), byteArray.releaseNonNull());
2212 }
2213 
2214 void CanvasRenderingContext2DBase::putImageData(ImageData&amp; data, float dx, float dy)
2215 {
2216     putImageData(data, dx, dy, 0, 0, data.width(), data.height());
2217 }
2218 
2219 void CanvasRenderingContext2DBase::putImageData(ImageData&amp; data, float dx, float dy, float dirtyX, float dirtyY, float dirtyWidth, float dirtyHeight)
2220 {
2221     putImageData(data, ImageBuffer::LogicalCoordinateSystem, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
2222 }
2223 
2224 void CanvasRenderingContext2DBase::putImageData(ImageData&amp; data, ImageBuffer::CoordinateSystem coordinateSystem, float dx, float dy, float dirtyX, float dirtyY, float dirtyWidth, float dirtyHeight)
2225 {
<a name="52" id="anc52"></a><span class="line-modified">2226     ImageBuffer* buffer = canvasBase().buffer();</span>


2227     if (!buffer)
2228         return;
2229 
2230     if (!data.data())
2231         return;
2232 
2233     if (dirtyWidth &lt; 0) {
2234         dirtyX += dirtyWidth;
2235         dirtyWidth = -dirtyWidth;
2236     }
2237 
2238     if (dirtyHeight &lt; 0) {
2239         dirtyY += dirtyHeight;
2240         dirtyHeight = -dirtyHeight;
2241     }
2242 
2243     FloatRect clipRect(dirtyX, dirtyY, dirtyWidth, dirtyHeight);
2244     clipRect.intersect(IntRect(0, 0, data.width(), data.height()));
2245     IntSize destOffset(static_cast&lt;int&gt;(dx), static_cast&lt;int&gt;(dy));
2246     IntRect destRect = enclosingIntRect(clipRect);
2247     destRect.move(destOffset);
2248     destRect.intersect(IntRect(IntPoint(), coordinateSystem == ImageBuffer::LogicalCoordinateSystem ? buffer-&gt;logicalSize() : buffer-&gt;internalSize()));
2249     if (destRect.isEmpty())
2250         return;
2251     IntRect sourceRect(destRect);
2252     sourceRect.move(-destOffset);
2253     sourceRect.intersect(IntRect(0, 0, data.width(), data.height()));
2254 
2255     if (!sourceRect.isEmpty())
2256         buffer-&gt;putByteArray(*data.data(), AlphaPremultiplication::Unpremultiplied, IntSize(data.width(), data.height()), sourceRect, IntPoint(destOffset), coordinateSystem);
2257 
2258     didDraw(destRect, CanvasDidDrawApplyNone); // ignore transform, shadow and clip
2259 }
2260 
2261 void CanvasRenderingContext2DBase::inflateStrokeRect(FloatRect&amp; rect) const
2262 {
2263     // Fast approximation of the stroke&#39;s bounding rect.
2264     // This yields a slightly oversized rect but is very fast
2265     // compared to Path::strokeBoundingRect().
2266     static const float root2 = sqrtf(2);
2267     float delta = state().lineWidth / 2;
2268     if (state().lineJoin == MiterJoin)
2269         delta *= state().miterLimit;
2270     else if (state().lineCap == SquareCap)
2271         delta *= root2;
2272     rect.inflate(delta);
2273 }
2274 
2275 #if ENABLE(ACCELERATED_2D_CANVAS)
2276 
2277 PlatformLayer* CanvasRenderingContext2DBase::platformLayer() const
2278 {
<a name="53" id="anc53"></a><span class="line-modified">2279     if (auto* buffer = canvasBase().buffer())</span>
<span class="line-added">2280         return buffer-&gt;platformLayer();</span>
2281 
<a name="54" id="anc54"></a><span class="line-modified">2282     return nullptr;</span>
2283 }
2284 
2285 #endif
2286 
2287 static inline InterpolationQuality smoothingToInterpolationQuality(ImageSmoothingQuality quality)
2288 {
2289     switch (quality) {
2290     case ImageSmoothingQuality::Low:
<a name="55" id="anc55"></a><span class="line-modified">2291         return InterpolationQuality::Low;</span>
2292     case ImageSmoothingQuality::Medium:
<a name="56" id="anc56"></a><span class="line-modified">2293         return InterpolationQuality::Medium;</span>
2294     case ImageSmoothingQuality::High:
<a name="57" id="anc57"></a><span class="line-modified">2295         return InterpolationQuality::High;</span>
2296     }
2297 
2298     ASSERT_NOT_REACHED();
<a name="58" id="anc58"></a><span class="line-modified">2299     return InterpolationQuality::Low;</span>
2300 };
2301 
2302 auto CanvasRenderingContext2DBase::imageSmoothingQuality() const -&gt; ImageSmoothingQuality
2303 {
2304     return state().imageSmoothingQuality;
2305 }
2306 
2307 void CanvasRenderingContext2DBase::setImageSmoothingQuality(ImageSmoothingQuality quality)
2308 {
2309     if (quality == state().imageSmoothingQuality)
2310         return;
2311 
2312     realizeSaves();
2313     modifiableState().imageSmoothingQuality = quality;
2314 
2315     if (!state().imageSmoothingEnabled)
2316         return;
2317 
2318     if (auto* context = drawingContext())
2319         context-&gt;setImageInterpolationQuality(smoothingToInterpolationQuality(quality));
2320 }
2321 
2322 bool CanvasRenderingContext2DBase::imageSmoothingEnabled() const
2323 {
2324     return state().imageSmoothingEnabled;
2325 }
2326 
2327 void CanvasRenderingContext2DBase::setImageSmoothingEnabled(bool enabled)
2328 {
2329     if (enabled == state().imageSmoothingEnabled)
2330         return;
2331 
2332     realizeSaves();
2333     modifiableState().imageSmoothingEnabled = enabled;
2334     auto* c = drawingContext();
2335     if (c)
<a name="59" id="anc59"></a><span class="line-modified">2336         c-&gt;setImageInterpolationQuality(enabled ? smoothingToInterpolationQuality(state().imageSmoothingQuality) : InterpolationQuality::DoNotInterpolate);</span>
2337 }
2338 
2339 void CanvasRenderingContext2DBase::setPath(Path2D&amp; path)
2340 {
2341     m_path = path.path();
2342 }
2343 
2344 Ref&lt;Path2D&gt; CanvasRenderingContext2DBase::getPath() const
2345 {
2346     return Path2D::create(m_path);
2347 }
2348 
2349 } // namespace WebCore
<a name="60" id="anc60"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="60" type="hidden" />
</body>
</html>
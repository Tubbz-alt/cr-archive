diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DateInstance.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DateInstance.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DateInstance.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DateInstance.h
@@ -18,24 +18,29 @@
  *
  */
 
 #pragma once
 
-#include "JSDestructibleObject.h"
+#include "JSObject.h"
 
 namespace JSC {
 
-class DateInstance final : public JSDestructibleObject {
-protected:
-    JS_EXPORT_PRIVATE DateInstance(VM&, Structure*);
-    void finishCreation(VM&);
-    JS_EXPORT_PRIVATE void finishCreation(VM&, double);
+class DateInstance final : public JSNonFinalObject {
+public:
+    using Base = JSNonFinalObject;
 
-    JS_EXPORT_PRIVATE static void destroy(JSCell*);
+    static constexpr bool needsDestruction = true;
+    static void destroy(JSCell* cell)
+    {
+        static_cast<DateInstance*>(cell)->DateInstance::~DateInstance();
+    }
 
-public:
-    using Base = JSDestructibleObject;
+    template<typename CellType, SubspaceAccess mode>
+    static IsoSubspace* subspaceFor(VM& vm)
+    {
+        return &vm.dateInstanceSpace;
+    }
 
     static DateInstance* create(VM& vm, Structure* structure, double date)
     {
         DateInstance* instance = new (NotNull, allocateCell<DateInstance>(vm.heap)) DateInstance(vm, structure);
         instance->finishCreation(vm, date);
@@ -52,32 +57,38 @@
     double internalNumber() const { return m_internalNumber; }
     void setInternalNumber(double value) { m_internalNumber = value; }
 
     DECLARE_EXPORT_INFO;
 
-    const GregorianDateTime* gregorianDateTime(ExecState* exec) const
+    const GregorianDateTime* gregorianDateTime(VM& vm) const
     {
         if (m_data && m_data->m_gregorianDateTimeCachedForMS == internalNumber())
             return &m_data->m_cachedGregorianDateTime;
-        return calculateGregorianDateTime(exec);
+        return calculateGregorianDateTime(vm);
     }
 
-    const GregorianDateTime* gregorianDateTimeUTC(ExecState* exec) const
+    const GregorianDateTime* gregorianDateTimeUTC(VM& vm) const
     {
         if (m_data && m_data->m_gregorianDateTimeUTCCachedForMS == internalNumber())
             return &m_data->m_cachedGregorianDateTimeUTC;
-        return calculateGregorianDateTimeUTC(exec);
+        return calculateGregorianDateTimeUTC(vm);
     }
 
     static Structure* createStructure(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
     {
-        return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
+        return Structure::create(vm, globalObject, prototype, TypeInfo(JSDateType, StructureFlags), info());
     }
 
+    static ptrdiff_t offsetOfInternalNumber() { return OBJECT_OFFSETOF(DateInstance, m_internalNumber); }
+    static ptrdiff_t offsetOfData() { return OBJECT_OFFSETOF(DateInstance, m_data); }
+
 private:
-    JS_EXPORT_PRIVATE const GregorianDateTime* calculateGregorianDateTime(ExecState*) const;
-    JS_EXPORT_PRIVATE const GregorianDateTime* calculateGregorianDateTimeUTC(ExecState*) const;
+    JS_EXPORT_PRIVATE DateInstance(VM&, Structure*);
+    void finishCreation(VM&);
+    JS_EXPORT_PRIVATE void finishCreation(VM&, double);
+    JS_EXPORT_PRIVATE const GregorianDateTime* calculateGregorianDateTime(VM&) const;
+    JS_EXPORT_PRIVATE const GregorianDateTime* calculateGregorianDateTimeUTC(VM&) const;
 
     double m_internalNumber { PNaN };
     mutable RefPtr<DateInstanceData> m_data;
 };
 

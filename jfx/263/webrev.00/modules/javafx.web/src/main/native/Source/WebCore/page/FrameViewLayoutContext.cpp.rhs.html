<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/FrameViewLayoutContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FrameViewLayoutContext.h&quot;
 28 
 29 #include &quot;CSSAnimationController.h&quot;
 30 #include &quot;DebugPageOverlays.h&quot;
 31 #include &quot;Document.h&quot;
 32 #include &quot;FrameView.h&quot;
 33 #include &quot;InspectorInstrumentation.h&quot;
 34 #include &quot;LayoutDisallowedScope.h&quot;
 35 #include &quot;Logging.h&quot;
 36 #include &quot;RenderElement.h&quot;
 37 #include &quot;RenderLayoutState.h&quot;
 38 #include &quot;RenderView.h&quot;
 39 #include &quot;RuntimeEnabledFeatures.h&quot;
 40 #include &quot;ScriptDisallowedScope.h&quot;
 41 #include &quot;Settings.h&quot;
 42 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
<a name="1" id="anc1"></a><span class="line-added"> 43 #include &quot;DisplayBox.h&quot;</span>
<span class="line-added"> 44 #include &quot;InvalidationContext.h&quot;</span>
<span class="line-added"> 45 #include &quot;InvalidationState.h&quot;</span>
<span class="line-added"> 46 #include &quot;LayoutContext.h&quot;</span>
 47 #include &quot;LayoutState.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 48 #include &quot;LayoutTreeBuilder.h&quot;</span>
<span class="line-added"> 49 #include &quot;RenderDescendantIterator.h&quot;</span>
 50 #endif
 51 
 52 #include &lt;wtf/SetForScope.h&gt;
 53 #include &lt;wtf/SystemTracing.h&gt;
 54 #include &lt;wtf/text/TextStream.h&gt;
 55 
 56 namespace WebCore {
 57 
 58 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
<a name="3" id="anc3"></a><span class="line-modified"> 59 void FrameViewLayoutContext::layoutUsingFormattingContext()</span>
 60 {
 61     if (!RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextEnabled())
 62         return;
<a name="4" id="anc4"></a><span class="line-modified"> 63 </span>
<span class="line-added"> 64     // FrameView::setContentsSize temporary disables layout.</span>
<span class="line-added"> 65     if (m_disableSetNeedsLayoutCount)</span>
<span class="line-added"> 66         return;</span>
<span class="line-added"> 67 </span>
<span class="line-added"> 68     auto&amp; renderView = *this-&gt;renderView();</span>
<span class="line-added"> 69     if (!m_layoutTreeContent) {</span>
<span class="line-added"> 70         m_layoutTreeContent = Layout::TreeBuilder::buildLayoutTree(renderView);</span>
<span class="line-added"> 71         // FIXME: New layout tree requires a new state for now.</span>
<span class="line-added"> 72         m_layoutState = nullptr;</span>
<span class="line-added"> 73     }</span>
<span class="line-added"> 74     if (!m_layoutState)</span>
<span class="line-added"> 75         m_layoutState = makeUnique&lt;Layout::LayoutState&gt;(*document(), m_layoutTreeContent-&gt;rootLayoutBox());</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77     // FIXME: This is not the real invalidation yet.</span>
<span class="line-added"> 78     auto invalidationState = Layout::InvalidationState { };</span>
<span class="line-added"> 79     auto layoutContext = Layout::LayoutContext { *m_layoutState };</span>
<span class="line-added"> 80     layoutContext.layout(view().layoutSize(), invalidationState);</span>
<span class="line-added"> 81 </span>
<span class="line-added"> 82     // Clean up the render tree state when we don&#39;t run RenderView::layout.</span>
<span class="line-added"> 83     if (renderView.needsLayout()) {</span>
<span class="line-added"> 84         auto contentSize = m_layoutState-&gt;displayBoxForLayoutBox(*m_layoutState-&gt;root().firstChild()).size();</span>
<span class="line-added"> 85         renderView.setSize(contentSize);</span>
<span class="line-added"> 86         renderView.repaintViewRectangle({ 0, 0, contentSize.width(), contentSize.height() });</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88         for (auto&amp; descendant : descendantsOfType&lt;RenderObject&gt;(renderView))</span>
<span class="line-added"> 89             descendant.clearNeedsLayout();</span>
<span class="line-added"> 90         renderView.clearNeedsLayout();</span>
<span class="line-added"> 91     }</span>
<span class="line-added"> 92 </span>
<span class="line-added"> 93 #ifndef NDEBUG</span>
<span class="line-added"> 94     Layout::LayoutContext::verifyAndOutputMismatchingLayoutTree(*m_layoutState, renderView);</span>
<span class="line-added"> 95 #endif</span>
<span class="line-added"> 96 }</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98 void FrameViewLayoutContext::invalidateLayoutTreeContent()</span>
<span class="line-added"> 99 {</span>
<span class="line-added">100     m_layoutTreeContent = nullptr;</span>
101 }
102 #endif
103 
104 static bool isObjectAncestorContainerOf(RenderElement&amp; ancestor, RenderElement&amp; descendant)
105 {
106     for (auto* renderer = &amp;descendant; renderer; renderer = renderer-&gt;container()) {
107         if (renderer == &amp;ancestor)
108             return true;
109     }
110     return false;
111 }
112 
113 #ifndef NDEBUG
114 class RenderTreeNeedsLayoutChecker {
115 public :
116     RenderTreeNeedsLayoutChecker(const RenderElement&amp; layoutRoot)
117         : m_layoutRoot(layoutRoot)
118     {
119     }
120 
121     ~RenderTreeNeedsLayoutChecker()
122     {
123         auto reportNeedsLayoutError = [] (const RenderObject&amp; renderer) {
124             WTFReportError(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, &quot;post-layout: dirty renderer(s)&quot;);
125             renderer.showRenderTreeForThis();
126             ASSERT_NOT_REACHED();
127         };
128 
129         if (m_layoutRoot.needsLayout()) {
130             reportNeedsLayoutError(m_layoutRoot);
131             return;
132         }
133 
134         for (auto* descendant = m_layoutRoot.firstChild(); descendant; descendant = descendant-&gt;nextInPreOrder(&amp;m_layoutRoot)) {
135             if (!descendant-&gt;needsLayout())
136                 continue;
137 
138             reportNeedsLayoutError(*descendant);
139             return;
140         }
141     }
142 
143 private:
144     const RenderElement&amp; m_layoutRoot;
145 };
146 #endif
147 
148 class LayoutScope {
149 public:
150     LayoutScope(FrameViewLayoutContext&amp; layoutContext)
151         : m_view(layoutContext.view())
152         , m_nestedState(layoutContext.m_layoutNestedState, layoutContext.m_layoutNestedState == FrameViewLayoutContext::LayoutNestedState::NotInLayout ? FrameViewLayoutContext::LayoutNestedState::NotNested : FrameViewLayoutContext::LayoutNestedState::Nested)
153         , m_schedulingIsEnabled(layoutContext.m_layoutSchedulingIsEnabled, false)
154         , m_previousScrollType(layoutContext.view().currentScrollType())
155     {
156         m_view.setCurrentScrollType(ScrollType::Programmatic);
157     }
158 
159     ~LayoutScope()
160     {
161         m_view.setCurrentScrollType(m_previousScrollType);
162     }
163 
164 private:
165     FrameView&amp; m_view;
166     SetForScope&lt;FrameViewLayoutContext::LayoutNestedState&gt; m_nestedState;
167     SetForScope&lt;bool&gt; m_schedulingIsEnabled;
168     ScrollType m_previousScrollType;
169 };
170 
171 FrameViewLayoutContext::FrameViewLayoutContext(FrameView&amp; frameView)
172     : m_frameView(frameView)
173     , m_layoutTimer(*this, &amp;FrameViewLayoutContext::layoutTimerFired)
174     , m_asynchronousTasksTimer(*this, &amp;FrameViewLayoutContext::runAsynchronousTasks)
175 {
176 }
177 
178 FrameViewLayoutContext::~FrameViewLayoutContext()
179 {
180 }
181 
182 void FrameViewLayoutContext::layout()
183 {
184     LOG_WITH_STREAM(Layout, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; &amp;view() &lt;&lt; &quot; FrameViewLayoutContext::layout() with size &quot; &lt;&lt; view().layoutSize());
185 
186     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!frame().document()-&gt;inRenderTreeUpdate());
187     ASSERT(LayoutDisallowedScope::isLayoutAllowed());
188     ASSERT(!view().isPainting());
189     ASSERT(frame().view() == &amp;view());
190     ASSERT(frame().document());
<a name="5" id="anc5"></a><span class="line-modified">191     ASSERT(frame().document()-&gt;backForwardCacheState() == Document::NotInBackForwardCache</span>
<span class="line-modified">192         || frame().document()-&gt;backForwardCacheState() == Document::AboutToEnterBackForwardCache);</span>
193     if (!canPerformLayout()) {
194         LOG(Layout, &quot;  is not allowed, bailing&quot;);
195         return;
196     }
197 
198     Ref&lt;FrameView&gt; protectView(view());
199     LayoutScope layoutScope(*this);
200     TraceScope tracingScope(LayoutStart, LayoutEnd);
<a name="6" id="anc6"></a><span class="line-modified">201     InspectorInstrumentation::willLayout(view().frame());</span>
202     AnimationUpdateBlock animationUpdateBlock(&amp;view().frame().animation());
203     WeakPtr&lt;RenderElement&gt; layoutRoot;
204 
205     m_layoutTimer.stop();
206     m_delayedLayout = false;
207     m_setNeedsLayoutWasDeferred = false;
208 
209 #if !LOG_DISABLED
210     if (m_firstLayout &amp;&amp; !frame().ownerElement())
211         LOG(Layout, &quot;FrameView %p elapsed time before first layout: %.3fs&quot;, this, document()-&gt;timeSinceDocumentCreation().value());
212 #endif
213 #if PLATFORM(IOS_FAMILY)
214     if (view().updateFixedPositionLayoutRect() &amp;&amp; subtreeLayoutRoot())
215         convertSubtreeLayoutToFullLayout();
216 #endif
217     if (handleLayoutWithFrameFlatteningIfNeeded())
218         return;
219 
220     {
221         SetForScope&lt;LayoutPhase&gt; layoutPhase(m_layoutPhase, LayoutPhase::InPreLayout);
222 
223         // If this is a new top-level layout and there are any remaining tasks from the previous layout, finish them now.
224         if (!isLayoutNested() &amp;&amp; m_asynchronousTasksTimer.isActive() &amp;&amp; !view().isInChildFrameWithFrameFlattening())
225             runAsynchronousTasks();
226 
227         updateStyleForLayout();
228         if (view().hasOneRef())
229             return;
230 
231         view().autoSizeIfEnabled();
232         if (!renderView())
233             return;
234 
235         layoutRoot = makeWeakPtr(subtreeLayoutRoot() ? subtreeLayoutRoot() : renderView());
236         m_needsFullRepaint = is&lt;RenderView&gt;(layoutRoot.get()) &amp;&amp; (m_firstLayout || renderView()-&gt;printing());
237         view().willDoLayout(layoutRoot);
238         m_firstLayout = false;
239     }
240     {
241         SetForScope&lt;LayoutPhase&gt; layoutPhase(m_layoutPhase, LayoutPhase::InRenderTreeLayout);
242         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
243         SubtreeLayoutStateMaintainer subtreeLayoutStateMaintainer(subtreeLayoutRoot());
244         RenderView::RepaintRegionAccumulator repaintRegionAccumulator(renderView());
245 #ifndef NDEBUG
246         RenderTreeNeedsLayoutChecker checker(*layoutRoot);
247 #endif
248         layoutRoot-&gt;layout();
249 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
<a name="7" id="anc7"></a><span class="line-modified">250         layoutUsingFormattingContext();</span>
251 #endif
252         ++m_layoutCount;
253 #if ENABLE(TEXT_AUTOSIZING)
254         applyTextSizingIfNeeded(*layoutRoot.get());
255 #endif
256         clearSubtreeLayoutRoot();
257     }
258     {
259         SetForScope&lt;LayoutPhase&gt; layoutPhase(m_layoutPhase, LayoutPhase::InViewSizeAdjust);
260         if (is&lt;RenderView&gt;(layoutRoot.get()) &amp;&amp; !renderView()-&gt;printing()) {
261             // This is to protect m_needsFullRepaint&#39;s value when layout() is getting re-entered through adjustViewSize().
262             SetForScope&lt;bool&gt; needsFullRepaint(m_needsFullRepaint);
263             view().adjustViewSize();
264             // FIXME: Firing media query callbacks synchronously on nested frames could produced a detached FrameView here by
265             // navigating away from the current document (see webkit.org/b/173329).
266             if (view().hasOneRef())
267                 return;
268         }
269     }
270     {
271         SetForScope&lt;LayoutPhase&gt; layoutPhase(m_layoutPhase, LayoutPhase::InPostLayout);
272         if (m_needsFullRepaint)
273             renderView()-&gt;repaintRootContents();
274         ASSERT(!layoutRoot-&gt;needsLayout());
275         view().didLayout(layoutRoot);
276         runOrScheduleAsynchronousTasks();
277     }
<a name="8" id="anc8"></a><span class="line-modified">278     InspectorInstrumentation::didLayout(view().frame(), *layoutRoot);</span>
279     DebugPageOverlays::didLayout(view().frame());
280 }
281 
282 void FrameViewLayoutContext::runOrScheduleAsynchronousTasks()
283 {
284     if (m_asynchronousTasksTimer.isActive())
285         return;
286 
287     if (view().isInChildFrameWithFrameFlattening()) {
288         // While flattening frames, we defer post layout tasks to avoid getting stuck in a cycle,
289         // except updateWidgetPositions() which is required to kick off subframe layout in certain cases.
290         if (!m_inAsynchronousTasks)
291             view().updateWidgetPositions();
292         m_asynchronousTasksTimer.startOneShot(0_s);
293         return;
294     }
295 
296     // If we are already in performPostLayoutTasks(), defer post layout tasks until after we return
297     // to avoid re-entrancy.
298     if (m_inAsynchronousTasks) {
299         m_asynchronousTasksTimer.startOneShot(0_s);
300         return;
301     }
302 
303     runAsynchronousTasks();
304     if (needsLayout()) {
305         // If runAsynchronousTasks() made us layout again, let&#39;s defer the tasks until after we return.
306         m_asynchronousTasksTimer.startOneShot(0_s);
307         layout();
308     }
309 }
310 
311 void FrameViewLayoutContext::runAsynchronousTasks()
312 {
313     m_asynchronousTasksTimer.stop();
314     if (m_inAsynchronousTasks)
315         return;
316     SetForScope&lt;bool&gt; inAsynchronousTasks(m_inAsynchronousTasks, true);
317     view().performPostLayoutTasks();
318 }
319 
320 void FrameViewLayoutContext::flushAsynchronousTasks()
321 {
322     if (!m_asynchronousTasksTimer.isActive())
323         return;
324     runAsynchronousTasks();
325 }
326 
327 void FrameViewLayoutContext::reset()
328 {
329     m_layoutPhase = LayoutPhase::OutsideLayout;
330     clearSubtreeLayoutRoot();
331     m_layoutCount = 0;
332     m_layoutSchedulingIsEnabled = true;
333     m_delayedLayout = false;
334     m_layoutTimer.stop();
335     m_firstLayout = true;
336     m_asynchronousTasksTimer.stop();
337     m_needsFullRepaint = true;
338 }
339 
340 bool FrameViewLayoutContext::needsLayout() const
341 {
342     // This can return true in cases where the document does not have a body yet.
343     // Document::shouldScheduleLayout takes care of preventing us from scheduling
344     // layout in that case.
345     auto* renderView = this-&gt;renderView();
346     return isLayoutPending()
347         || (renderView &amp;&amp; renderView-&gt;needsLayout())
348         || subtreeLayoutRoot()
349         || (m_disableSetNeedsLayoutCount &amp;&amp; m_setNeedsLayoutWasDeferred);
350 }
351 
352 void FrameViewLayoutContext::setNeedsLayoutAfterViewConfigurationChange()
353 {
354     if (m_disableSetNeedsLayoutCount) {
355         m_setNeedsLayoutWasDeferred = true;
356         return;
357     }
358 
359     if (auto* renderView = this-&gt;renderView()) {
360         ASSERT(!frame().document()-&gt;inHitTesting());
361         renderView-&gt;setNeedsLayout();
362         scheduleLayout();
363     }
364 }
365 
366 void FrameViewLayoutContext::enableSetNeedsLayout()
367 {
368     ASSERT(m_disableSetNeedsLayoutCount);
369     if (!--m_disableSetNeedsLayoutCount)
370         m_setNeedsLayoutWasDeferred = false; // FIXME: Find a way to make the deferred layout actually happen.
371 }
372 
373 void FrameViewLayoutContext::disableSetNeedsLayout()
374 {
375     ++m_disableSetNeedsLayoutCount;
376 }
377 
378 void FrameViewLayoutContext::scheduleLayout()
379 {
<a name="9" id="anc9"></a><span class="line-modified">380     // FIXME: We should assert the page is not in the back/forward cache, but that is causing</span>
381     // too many false assertions. See &lt;rdar://problem/7218118&gt;.
382     ASSERT(frame().view() == &amp;view());
383 
384     if (subtreeLayoutRoot())
385         convertSubtreeLayoutToFullLayout();
386     if (!isLayoutSchedulingEnabled())
387         return;
388     if (!needsLayout())
389         return;
390     if (!frame().document()-&gt;shouldScheduleLayout())
391         return;
392     InspectorInstrumentation::didInvalidateLayout(frame());
393     // When frame flattening is enabled, the contents of the frame could affect the layout of the parent frames.
394     // Also invalidate parent frame starting from the owner element of this frame.
395     if (frame().ownerRenderer() &amp;&amp; view().isInChildFrameWithFrameFlattening())
396         frame().ownerRenderer()-&gt;setNeedsLayout(MarkContainingBlockChain);
397 
398     Seconds delay = frame().document()-&gt;minimumLayoutDelay();
399     if (m_layoutTimer.isActive() &amp;&amp; m_delayedLayout &amp;&amp; !delay)
400         unscheduleLayout();
401 
402     if (m_layoutTimer.isActive())
403         return;
404 
405     m_delayedLayout = delay.value();
406 
407 #if !LOG_DISABLED
408     if (!frame().document()-&gt;ownerElement())
409         LOG(Layout, &quot;FrameView %p scheduling layout for %.3fs&quot;, this, delay.value());
410 #endif
411 
412     m_layoutTimer.startOneShot(delay);
413 }
414 
415 void FrameViewLayoutContext::unscheduleLayout()
416 {
417     if (m_asynchronousTasksTimer.isActive())
418         m_asynchronousTasksTimer.stop();
419 
420     if (!m_layoutTimer.isActive())
421         return;
422 
423 #if !LOG_DISABLED
424     if (!frame().document()-&gt;ownerElement())
425         LOG(Layout, &quot;FrameView %p layout timer unscheduled at %.3fs&quot;, this, frame().document()-&gt;timeSinceDocumentCreation().value());
426 #endif
427 
428     m_layoutTimer.stop();
429     m_delayedLayout = false;
430 }
431 
432 void FrameViewLayoutContext::scheduleSubtreeLayout(RenderElement&amp; layoutRoot)
433 {
434     ASSERT(renderView());
435     auto&amp; renderView = *this-&gt;renderView();
436 
437     // Try to catch unnecessary work during render tree teardown.
438     ASSERT(!renderView.renderTreeBeingDestroyed());
439     ASSERT(frame().view() == &amp;view());
440 
441     if (renderView.needsLayout() &amp;&amp; !subtreeLayoutRoot()) {
442         layoutRoot.markContainingBlocksForLayout(ScheduleRelayout::No);
443         return;
444     }
445 
446     if (!isLayoutPending() &amp;&amp; isLayoutSchedulingEnabled()) {
447         Seconds delay = renderView.document().minimumLayoutDelay();
448         ASSERT(!layoutRoot.container() || is&lt;RenderView&gt;(layoutRoot.container()) || !layoutRoot.container()-&gt;needsLayout());
449         setSubtreeLayoutRoot(layoutRoot);
450         InspectorInstrumentation::didInvalidateLayout(frame());
451         m_delayedLayout = delay.value();
452         m_layoutTimer.startOneShot(delay);
453         return;
454     }
455 
456     auto* subtreeLayoutRoot = this-&gt;subtreeLayoutRoot();
457     if (subtreeLayoutRoot == &amp;layoutRoot)
458         return;
459 
460     if (!subtreeLayoutRoot) {
461         // We already have a pending (full) layout. Just mark the subtree for layout.
462         layoutRoot.markContainingBlocksForLayout(ScheduleRelayout::No);
463         InspectorInstrumentation::didInvalidateLayout(frame());
464         return;
465     }
466 
467     if (isObjectAncestorContainerOf(*subtreeLayoutRoot, layoutRoot)) {
468         // Keep the current root.
469         layoutRoot.markContainingBlocksForLayout(ScheduleRelayout::No, subtreeLayoutRoot);
470         ASSERT(!subtreeLayoutRoot-&gt;container() || is&lt;RenderView&gt;(subtreeLayoutRoot-&gt;container()) || !subtreeLayoutRoot-&gt;container()-&gt;needsLayout());
471         return;
472     }
473 
474     if (isObjectAncestorContainerOf(layoutRoot, *subtreeLayoutRoot)) {
475         // Re-root at newRelayoutRoot.
476         subtreeLayoutRoot-&gt;markContainingBlocksForLayout(ScheduleRelayout::No, &amp;layoutRoot);
477         setSubtreeLayoutRoot(layoutRoot);
478         ASSERT(!layoutRoot.container() || is&lt;RenderView&gt;(layoutRoot.container()) || !layoutRoot.container()-&gt;needsLayout());
479         InspectorInstrumentation::didInvalidateLayout(frame());
480         return;
481     }
482     // Two disjoint subtrees need layout. Mark both of them and issue a full layout instead.
483     convertSubtreeLayoutToFullLayout();
484     layoutRoot.markContainingBlocksForLayout(ScheduleRelayout::No);
485     InspectorInstrumentation::didInvalidateLayout(frame());
486 }
487 
488 void FrameViewLayoutContext::layoutTimerFired()
489 {
490 #if !LOG_DISABLED
491     if (!frame().document()-&gt;ownerElement())
492         LOG(Layout, &quot;FrameView %p layout timer fired at %.3fs&quot;, this, frame().document()-&gt;timeSinceDocumentCreation().value());
493 #endif
494     layout();
495 }
496 
497 RenderElement* FrameViewLayoutContext::subtreeLayoutRoot() const
498 {
499     return m_subtreeLayoutRoot.get();
500 }
501 
502 void FrameViewLayoutContext::convertSubtreeLayoutToFullLayout()
503 {
504     ASSERT(subtreeLayoutRoot());
505     subtreeLayoutRoot()-&gt;markContainingBlocksForLayout(ScheduleRelayout::No);
506     clearSubtreeLayoutRoot();
507 }
508 
509 void FrameViewLayoutContext::setSubtreeLayoutRoot(RenderElement&amp; layoutRoot)
510 {
511     m_subtreeLayoutRoot = makeWeakPtr(layoutRoot);
512 }
513 
514 bool FrameViewLayoutContext::canPerformLayout() const
515 {
516     if (isInRenderTreeLayout())
517         return false;
518 
519     if (layoutDisallowed())
520         return false;
521 
522     if (view().isPainting())
523         return false;
524 
525     if (!subtreeLayoutRoot() &amp;&amp; !frame().document()-&gt;renderView())
526         return false;
527 
528     return true;
529 }
530 
531 #if ENABLE(TEXT_AUTOSIZING)
532 void FrameViewLayoutContext::applyTextSizingIfNeeded(RenderElement&amp; layoutRoot)
533 {
534     auto&amp; settings = layoutRoot.settings();
535     bool idempotentMode = settings.textAutosizingUsesIdempotentMode();
536     if (!settings.textAutosizingEnabled() || idempotentMode || renderView()-&gt;printing())
537         return;
538     auto minimumZoomFontSize = settings.minimumZoomFontSize();
539     if (!idempotentMode &amp;&amp; !minimumZoomFontSize)
540         return;
541     auto textAutosizingWidth = layoutRoot.page().textAutosizingWidth();
542     if (auto overrideWidth = settings.textAutosizingWindowSizeOverride().width())
543         textAutosizingWidth = overrideWidth;
544     if (!idempotentMode &amp;&amp; !textAutosizingWidth)
545         return;
546     layoutRoot.adjustComputedFontSizesOnBlocks(minimumZoomFontSize, textAutosizingWidth);
547     if (!layoutRoot.needsLayout())
548         return;
549     LOG(TextAutosizing, &quot;Text Autosizing: minimumZoomFontSize=%.2f textAutosizingWidth=%.2f&quot;, minimumZoomFontSize, textAutosizingWidth);
550     layoutRoot.layout();
551 }
552 #endif
553 
554 void FrameViewLayoutContext::updateStyleForLayout()
555 {
556     Document&amp; document = *frame().document();
557 
558     // FIXME: This shouldn&#39;t be necessary, but see rdar://problem/36670246.
559     if (!document.styleScope().resolverIfExists())
560         document.styleScope().didChangeStyleSheetEnvironment();
561 
562     // Viewport-dependent media queries may cause us to need completely different style information.
563     document.styleScope().evaluateMediaQueriesForViewportChange();
564 
<a name="10" id="anc10"></a><span class="line-modified">565     document.updateElementsAffectedByMediaQueries();</span>
566     // If there is any pagination to apply, it will affect the RenderView&#39;s style, so we should
567     // take care of that now.
568     view().applyPaginationToViewport();
569     // Always ensure our style info is up-to-date. This can happen in situations where
570     // the layout beats any sort of style recalc update that needs to occur.
571     document.updateStyleIfNeeded();
572 }
573 
574 bool FrameViewLayoutContext::handleLayoutWithFrameFlatteningIfNeeded()
575 {
576     if (!view().isInChildFrameWithFrameFlattening())
577         return false;
578 
579     startLayoutAtMainFrameViewIfNeeded();
580     auto* layoutRoot = subtreeLayoutRoot() ? subtreeLayoutRoot() : frame().document()-&gt;renderView();
581     return !layoutRoot || !layoutRoot-&gt;needsLayout();
582 }
583 
584 void FrameViewLayoutContext::startLayoutAtMainFrameViewIfNeeded()
585 {
586     // When we start a layout at the child level as opposed to the topmost frame view and this child
587     // frame requires flattening, we need to re-initiate the layout at the topmost view. Layout
588     // will hit this view eventually.
589     auto* parentView = view().parentFrameView();
590     if (!parentView)
591         return;
592 
593     // In the middle of parent layout, no need to restart from topmost.
594     if (parentView-&gt;layoutContext().isInLayout())
595         return;
596 
597     // Parent tree is clean. Starting layout from it would have no effect.
598     if (!parentView-&gt;needsLayout())
599         return;
600 
601     while (parentView-&gt;parentFrameView())
602         parentView = parentView-&gt;parentFrameView();
603 
604     LOG(Layout, &quot;  frame flattening, starting from root&quot;);
605     parentView-&gt;layoutContext().layout();
606 }
607 
608 LayoutSize FrameViewLayoutContext::layoutDelta() const
609 {
610     if (auto* layoutState = this-&gt;layoutState())
611         return layoutState-&gt;layoutDelta();
612     return { };
613 }
614 
615 void FrameViewLayoutContext::addLayoutDelta(const LayoutSize&amp; delta)
616 {
617     if (auto* layoutState = this-&gt;layoutState())
618         layoutState-&gt;addLayoutDelta(delta);
619 }
620 
<a name="11" id="anc11"></a><span class="line-modified">621 #if ASSERT_ENABLED</span>
622 bool FrameViewLayoutContext::layoutDeltaMatches(const LayoutSize&amp; delta)
623 {
624     if (auto* layoutState = this-&gt;layoutState())
625         return layoutState-&gt;layoutDeltaMatches(delta);
626     return false;
627 }
628 #endif
629 
630 RenderLayoutState* FrameViewLayoutContext::layoutState() const
631 {
632     if (m_layoutStateStack.isEmpty())
633         return nullptr;
634     return m_layoutStateStack.last().get();
635 }
636 
637 void FrameViewLayoutContext::pushLayoutState(RenderElement&amp; root)
638 {
639     ASSERT(!m_paintOffsetCacheDisableCount);
640     ASSERT(!layoutState());
641 
642     m_layoutStateStack.append(makeUnique&lt;RenderLayoutState&gt;(root));
643 }
644 
645 bool FrameViewLayoutContext::pushLayoutStateForPaginationIfNeeded(RenderBlockFlow&amp; layoutRoot)
646 {
647     if (layoutState())
648         return false;
649     m_layoutStateStack.append(makeUnique&lt;RenderLayoutState&gt;(layoutRoot, RenderLayoutState::IsPaginated::Yes));
650     return true;
651 }
652 
653 bool FrameViewLayoutContext::pushLayoutState(RenderBox&amp; renderer, const LayoutSize&amp; offset, LayoutUnit pageHeight, bool pageHeightChanged)
654 {
655     // We push LayoutState even if layoutState is disabled because it stores layoutDelta too.
656     auto* layoutState = this-&gt;layoutState();
657     if (!layoutState || !needsFullRepaint() || layoutState-&gt;isPaginated() || renderer.enclosingFragmentedFlow()
658         || layoutState-&gt;lineGrid() || (renderer.style().lineGrid() != RenderStyle::initialLineGrid() &amp;&amp; renderer.isRenderBlockFlow())) {
659         m_layoutStateStack.append(makeUnique&lt;RenderLayoutState&gt;(m_layoutStateStack, renderer, offset, pageHeight, pageHeightChanged));
660         return true;
661     }
662     return false;
663 }
664 
665 void FrameViewLayoutContext::popLayoutState()
666 {
667     m_layoutStateStack.removeLast();
668 }
669 
670 #ifndef NDEBUG
671 void FrameViewLayoutContext::checkLayoutState()
672 {
673     ASSERT(layoutDeltaMatches(LayoutSize()));
674     ASSERT(!m_paintOffsetCacheDisableCount);
675 }
676 #endif
677 
678 Frame&amp; FrameViewLayoutContext::frame() const
679 {
680     return view().frame();
681 }
682 
683 FrameView&amp; FrameViewLayoutContext::view() const
684 {
685     return m_frameView;
686 }
687 
688 RenderView* FrameViewLayoutContext::renderView() const
689 {
690     return view().renderView();
691 }
692 
693 Document* FrameViewLayoutContext::document() const
694 {
695     return frame().document();
696 }
697 
698 } // namespace WebCore
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
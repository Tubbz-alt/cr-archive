diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrInterpreter.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrInterpreter.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrInterpreter.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrInterpreter.cpp
@@ -32,10 +32,11 @@
 #include "Yarr.h"
 #include "YarrCanonicalize.h"
 #include <wtf/BumpPointerAllocator.h>
 #include <wtf/CheckedArithmetic.h>
 #include <wtf/DataLog.h>
+#include <wtf/StackCheck.h>
 #include <wtf/text/CString.h>
 #include <wtf/text/WTFString.h>
 
 namespace JSC { namespace Yarr {
 
@@ -1692,10 +1693,15 @@
     {
     }
 
     std::unique_ptr<BytecodePattern> compile(BumpPointerAllocator* allocator, ConcurrentJSLock* lock, ErrorCode& errorCode)
     {
+        if (UNLIKELY(!isSafeToRecurse())) {
+            errorCode = ErrorCode::TooManyDisjunctions;
+            return nullptr;
+        }
+
         regexBegin(m_pattern.m_numSubpatterns, m_pattern.m_body->m_callFrameSize, m_pattern.m_body->m_alternatives[0]->onceThrough());
         if (auto error = emitDisjunction(m_pattern.m_body, 0, 0)) {
             errorCode = error.value();
             return nullptr;
         }
@@ -2026,10 +2032,13 @@
         m_currentAlternativeIndex = newAlternativeIndex;
     }
 
     Optional<ErrorCode> WARN_UNUSED_RETURN emitDisjunction(PatternDisjunction* disjunction, Checked<unsigned, RecordOverflow> inputCountAlreadyChecked, unsigned parenthesesInputCountAlreadyChecked)
     {
+        if (UNLIKELY(!isSafeToRecurse()))
+            return ErrorCode::TooManyDisjunctions;
+
         for (unsigned alt = 0; alt < disjunction->m_alternatives.size(); ++alt) {
             auto currentCountAlreadyChecked = inputCountAlreadyChecked;
 
             PatternAlternative* alternative = disjunction->m_alternatives[alt].get();
 
@@ -2403,12 +2412,15 @@
         }
     }
 #endif
 
 private:
+    inline bool isSafeToRecurse() { return m_stackCheck.isSafeToRecurse(); }
+
     YarrPattern& m_pattern;
     std::unique_ptr<ByteDisjunction> m_bodyDisjunction;
+    StackCheck m_stackCheck;
     unsigned m_currentAlternativeIndex { 0 };
     Vector<ParenthesesStackEntry> m_parenthesesStack;
     Vector<std::unique_ptr<ByteDisjunction>> m_allParenthesesInfo;
 };
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/layout/FormattingContextGeometry.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2018 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;FormattingContext.h&quot;
  28 
  29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  30 
  31 #include &quot;FloatingState.h&quot;
<a name="1" id="anc1"></a>
  32 #include &quot;InlineFormattingState.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  33 #include &quot;LayoutContext.h&quot;</span>
<span class="line-added">  34 #include &quot;Logging.h&quot;</span>
  35 #include &quot;TableFormattingState.h&quot;
<a name="3" id="anc3"></a>
  36 
  37 namespace WebCore {
  38 namespace Layout {
  39 
  40 static inline bool isHeightAuto(const Box&amp; layoutBox)
  41 {
  42     // 10.5 Content height: the &#39;height&#39; property
  43     //
  44     // The percentage is calculated with respect to the height of the generated box&#39;s containing block.
  45     // If the height of the containing block is not specified explicitly (i.e., it depends on content height),
  46     // and this element is not absolutely positioned, the used height is calculated as if &#39;auto&#39; was specified.
  47 
  48     auto height = layoutBox.style().logicalHeight();
  49     if (height.isAuto())
  50         return true;
  51 
  52     if (height.isPercent()) {
  53         if (layoutBox.isOutOfFlowPositioned())
  54             return false;
  55 
  56         return !layoutBox.containingBlock()-&gt;style().logicalHeight().isFixed();
  57     }
  58 
  59     return false;
  60 }
  61 
<a name="4" id="anc4"></a><span class="line-modified">  62 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedHeightValue(const Box&amp; layoutBox, HeightType heightType, Optional&lt;LayoutUnit&gt; containingBlockHeight) const</span>
  63 {
  64     auto&amp; style = layoutBox.style();
  65     auto height = heightType == HeightType::Normal ? style.logicalHeight() : heightType == HeightType::Min ? style.logicalMinHeight() : style.logicalMaxHeight();
  66     if (height.isUndefined() || height.isAuto())
  67         return { };
  68 
  69     if (height.isFixed())
<a name="5" id="anc5"></a><span class="line-modified">  70         return LayoutUnit { height.value() };</span>
  71 
<a name="6" id="anc6"></a><span class="line-modified">  72     if (!containingBlockHeight) {</span>

  73         // Containing block&#39;s height is already computed since we layout the out-of-flow boxes as the last step.
<a name="7" id="anc7"></a><span class="line-modified">  74         ASSERT(!layoutBox.isOutOfFlowPositioned());</span>
<span class="line-modified">  75         if (layoutState().inQuirksMode())</span>
<span class="line-modified">  76             containingBlockHeight = formattingContext().quirks().heightValueOfNearestContainingBlockWithFixedHeight(layoutBox);</span>

  77         else {
<a name="8" id="anc8"></a><span class="line-modified">  78             auto containingBlockHeightFromStyle = layoutBox.containingBlock()-&gt;style().logicalHeight();</span>
<span class="line-modified">  79             if (containingBlockHeightFromStyle.isFixed())</span>
<span class="line-modified">  80                 containingBlockHeight = LayoutUnit { containingBlockHeightFromStyle.value() };</span>
  81         }
  82     }
  83 
<a name="9" id="anc9"></a><span class="line-modified">  84     if (!containingBlockHeight)</span>
  85         return { };
  86 
<a name="10" id="anc10"></a><span class="line-modified">  87     return valueForLength(height, *containingBlockHeight);</span>
<span class="line-added">  88 }</span>
<span class="line-added">  89 </span>
<span class="line-added">  90 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedContentHeight(const Box&amp; layoutBox, Optional&lt;LayoutUnit&gt; containingBlockHeight) const</span>
<span class="line-added">  91 {</span>
<span class="line-added">  92     if (auto height = computedHeightValue(layoutBox, HeightType::Normal, containingBlockHeight)) {</span>
<span class="line-added">  93         if (layoutBox.style().boxSizing() == BoxSizing::ContentBox)</span>
<span class="line-added">  94             return height;</span>
<span class="line-added">  95         auto&amp; boxGeometry = formattingContext().geometryForBox(layoutBox);</span>
<span class="line-added">  96         return *height - (boxGeometry.verticalBorder() + boxGeometry.verticalPadding().valueOr(0));</span>
<span class="line-added">  97     }</span>
<span class="line-added">  98     return { };</span>
<span class="line-added">  99 }</span>
<span class="line-added"> 100 </span>
<span class="line-added"> 101 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedContentWidth(const Box&amp; layoutBox, LayoutUnit containingBlockWidth) const</span>
<span class="line-added"> 102 {</span>
<span class="line-added"> 103     if (auto width = computedValueIfNotAuto(layoutBox.style().logicalWidth(), containingBlockWidth)) {</span>
<span class="line-added"> 104         if (layoutBox.style().boxSizing() == BoxSizing::ContentBox)</span>
<span class="line-added"> 105             return width;</span>
<span class="line-added"> 106         auto&amp; boxGeometry = formattingContext().geometryForBox(layoutBox);</span>
<span class="line-added"> 107         return *width - (boxGeometry.horizontalBorder() + boxGeometry.horizontalPadding().valueOr(0));</span>
<span class="line-added"> 108     }</span>
<span class="line-added"> 109     return { };</span>
 110 }
 111 
<a name="11" id="anc11"></a><span class="line-modified"> 112 LayoutUnit FormattingContext::Geometry::contentHeightForFormattingContextRoot(const Box&amp; layoutBox) const</span>
 113 {
 114     ASSERT(isHeightAuto(layoutBox) &amp;&amp; (layoutBox.establishesFormattingContext() || layoutBox.isDocumentBox()));
 115 
 116     // 10.6.7 &#39;Auto&#39; heights for block formatting context roots
 117 
 118     // If it only has inline-level children, the height is the distance between the top of the topmost line box and the bottom of the bottommost line box.
 119     // If it has block-level children, the height is the distance between the top margin-edge of the topmost block-level
 120     // child box and the bottom margin-edge of the bottommost block-level child box.
 121 
 122     // In addition, if the element has any floating descendants whose bottom margin edge is below the element&#39;s bottom content edge,
 123     // then the height is increased to include those edges. Only floats that participate in this block formatting context are taken
 124     // into account, e.g., floats inside absolutely positioned descendants or other floats are not.
 125     if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild())
 126         return { };
 127 
<a name="12" id="anc12"></a><span class="line-modified"> 128     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-modified"> 129     auto&amp; formattingContext = this-&gt;formattingContext();</span>
<span class="line-added"> 130     auto&amp; boxGeometry = formattingContext.geometryForBox(layoutBox);</span>
<span class="line-added"> 131     auto borderAndPaddingTop = boxGeometry.borderTop() + boxGeometry.paddingTop().valueOr(0);</span>
 132     auto top = borderAndPaddingTop;
 133     auto bottom = borderAndPaddingTop;
 134     auto&amp; formattingRootContainer = downcast&lt;Container&gt;(layoutBox);
 135     if (formattingRootContainer.establishesInlineFormattingContext()) {
<a name="13" id="anc13"></a><span class="line-modified"> 136         auto&amp; lineBoxes = layoutState.establishedInlineFormattingState(formattingRootContainer).displayInlineContent()-&gt;lineBoxes;</span>
 137         // Even empty containers generate one line.
 138         ASSERT(!lineBoxes.isEmpty());
<a name="14" id="anc14"></a><span class="line-modified"> 139         top = lineBoxes.first().top();</span>
<span class="line-modified"> 140         bottom = lineBoxes.last().bottom();</span>
<span class="line-modified"> 141     } else if (formattingRootContainer.establishesBlockFormattingContext() || formattingRootContainer.establishesTableFormattingContext() || formattingRootContainer.isDocumentBox()) {</span>
 142         if (formattingRootContainer.hasInFlowChild()) {
<a name="15" id="anc15"></a><span class="line-modified"> 143             auto&amp; firstBoxGeometry = formattingContext.geometryForBox(*formattingRootContainer.firstInFlowChild(), EscapeReason::NeedsGeometryFromEstablishedFormattingContext);</span>
<span class="line-modified"> 144             auto&amp; lastBoxGeometry = formattingContext.geometryForBox(*formattingRootContainer.lastInFlowChild(), EscapeReason::NeedsGeometryFromEstablishedFormattingContext);</span>
<span class="line-modified"> 145             top = firstBoxGeometry.rectWithMargin().top();</span>
<span class="line-modified"> 146             bottom = lastBoxGeometry.rectWithMargin().bottom();</span>
 147         }
<a name="16" id="anc16"></a>





 148     } else
 149         ASSERT_NOT_REACHED();
 150 
<a name="17" id="anc17"></a><span class="line-modified"> 151     auto* formattingContextRoot = &amp;formattingRootContainer;</span>
 152     // TODO: The document renderer is not a formatting context root by default at all. Need to find out what it is.
 153     if (!layoutBox.establishesFormattingContext()) {
 154         ASSERT(layoutBox.isDocumentBox());
 155         formattingContextRoot = &amp;layoutBox.formattingContextRoot();
 156     }
 157 
 158     auto&amp; floatingState = layoutState.establishedFormattingState(*formattingContextRoot).floatingState();
 159     auto floatBottom = floatingState.bottom(*formattingContextRoot);
 160     if (floatBottom) {
 161         bottom = std::max&lt;LayoutUnit&gt;(*floatBottom, bottom);
 162         auto floatTop = floatingState.top(*formattingContextRoot);
 163         ASSERT(floatTop);
 164         top = std::min&lt;LayoutUnit&gt;(*floatTop, top);
 165     }
 166 
 167     auto computedHeight = bottom - top;
 168     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height] -&gt; content height for formatting context root -&gt; height(&quot; &lt;&lt; computedHeight &lt;&lt; &quot;px) layoutBox(&quot;&lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 169     return computedHeight;
 170 }
 171 
<a name="18" id="anc18"></a><span class="line-modified"> 172 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedValueIfNotAuto(const Length&amp; geometryProperty, LayoutUnit containingBlockWidth) const</span>
 173 {
 174     if (geometryProperty.isUndefined())
 175         return WTF::nullopt;
 176 
 177     if (geometryProperty.isAuto())
 178         return WTF::nullopt;
 179 
 180     return valueForLength(geometryProperty, containingBlockWidth);
 181 }
 182 
<a name="19" id="anc19"></a><span class="line-modified"> 183 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::fixedValue(const Length&amp; geometryProperty) const</span>
 184 {
 185     if (!geometryProperty.isFixed())
 186         return WTF::nullopt;
 187     return LayoutUnit(geometryProperty.value());
 188 }
 189 
 190 // https://www.w3.org/TR/CSS22/visudet.html#min-max-heights
 191 // Specifies a percentage for determining the used value. The percentage is calculated with respect to the height of the generated box&#39;s containing block.
 192 // If the height of the containing block is not specified explicitly (i.e., it depends on content height), and this element is not absolutely positioned,
 193 // the percentage value is treated as &#39;0&#39; (for &#39;min-height&#39;) or &#39;none&#39; (for &#39;max-height&#39;).
<a name="20" id="anc20"></a><span class="line-modified"> 194 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMaxHeight(const Box&amp; layoutBox, Optional&lt;LayoutUnit&gt; containingBlockHeight) const</span>
 195 {
<a name="21" id="anc21"></a><span class="line-modified"> 196     return computedHeightValue(layoutBox, HeightType::Max, containingBlockHeight);</span>
 197 }
 198 
<a name="22" id="anc22"></a><span class="line-modified"> 199 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMinHeight(const Box&amp; layoutBox, Optional&lt;LayoutUnit&gt; containingBlockHeight) const</span>
 200 {
<a name="23" id="anc23"></a><span class="line-modified"> 201     if (auto minHeightValue = computedHeightValue(layoutBox, HeightType::Min, containingBlockHeight))</span>
 202         return minHeightValue;
 203 
<a name="24" id="anc24"></a><span class="line-modified"> 204     return { LayoutUnit { } };</span>
<span class="line-added"> 205 }</span>
<span class="line-added"> 206 </span>
<span class="line-added"> 207 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMinWidth(const Box&amp; layoutBox, LayoutUnit containingBlockWidth) const</span>
<span class="line-added"> 208 {</span>
<span class="line-added"> 209     return computedValueIfNotAuto(layoutBox.style().logicalMinWidth(), containingBlockWidth);</span>
<span class="line-added"> 210 }</span>
<span class="line-added"> 211 </span>
<span class="line-added"> 212 Optional&lt;LayoutUnit&gt; FormattingContext::Geometry::computedMaxWidth(const Box&amp; layoutBox, LayoutUnit containingBlockWidth) const</span>
<span class="line-added"> 213 {</span>
<span class="line-added"> 214     return computedValueIfNotAuto(layoutBox.style().logicalMaxWidth(), containingBlockWidth);</span>
 215 }
 216 
<a name="25" id="anc25"></a><span class="line-modified"> 217 LayoutUnit FormattingContext::Geometry::staticVerticalPositionForOutOfFlowPositioned(const Box&amp; layoutBox, const VerticalConstraints&amp; verticalConstraints) const</span>
 218 {
 219     ASSERT(layoutBox.isOutOfFlowPositioned());
 220 
 221     // For the purposes of this section and the next, the term &quot;static position&quot; (of an element) refers, roughly, to the position an element would have
 222     // had in the normal flow. More precisely, the static position for &#39;top&#39; is the distance from the top edge of the containing block to the top margin
 223     // edge of a hypothetical box that would have been the first box of the element if its specified &#39;position&#39; value had been &#39;static&#39; and its specified
 224     // &#39;float&#39; had been &#39;none&#39; and its specified &#39;clear&#39; had been &#39;none&#39;. (Note that due to the rules in section 9.7 this might require also assuming a different
 225     // computed value for &#39;display&#39;.) The value is negative if the hypothetical box is above the containing block.
 226 
 227     // Start with this box&#39;s border box offset from the parent&#39;s border box.
<a name="26" id="anc26"></a><span class="line-added"> 228     auto&amp; formattingContext = this-&gt;formattingContext();</span>
 229     LayoutUnit top;
 230     if (auto* previousInFlowSibling = layoutBox.previousInFlowSibling()) {
 231         // Add sibling offset
<a name="27" id="anc27"></a><span class="line-modified"> 232         auto&amp; previousInFlowBoxGeometry = formattingContext.geometryForBox(*previousInFlowSibling, EscapeReason::OutOfFlowBoxNeedsInFlowGeometry);</span>
<span class="line-modified"> 233         top += previousInFlowBoxGeometry.bottom() + previousInFlowBoxGeometry.nonCollapsedMarginAfter();</span>
 234     } else {
 235         ASSERT(layoutBox.parent());
<a name="28" id="anc28"></a><span class="line-modified"> 236         top = formattingContext.geometryForBox(*layoutBox.parent(), EscapeReason::OutOfFlowBoxNeedsInFlowGeometry).contentBoxTop();</span>
 237     }
 238 
 239     // Resolve top all the way up to the containing block.
 240     auto&amp; containingBlock = *layoutBox.containingBlock();
 241     // Start with the parent since we pretend that this box is normal flow.
 242     for (auto* container = layoutBox.parent(); container != &amp;containingBlock; container = container-&gt;containingBlock()) {
<a name="29" id="anc29"></a><span class="line-modified"> 243         auto&amp; boxGeometry = formattingContext.geometryForBox(*container, EscapeReason::OutOfFlowBoxNeedsInFlowGeometry);</span>
 244         // Display::Box::top is the border box top position in its containing block&#39;s coordinate system.
<a name="30" id="anc30"></a><span class="line-modified"> 245         top += boxGeometry.top();</span>
 246         ASSERT(!container-&gt;isPositioned() || layoutBox.isFixedPositioned());
 247     }
 248     // Move the static position relative to the padding box. This is very specific to abolutely positioned boxes.
<a name="31" id="anc31"></a><span class="line-modified"> 249     return top - verticalConstraints.logicalTop;</span>

 250 }
 251 
<a name="32" id="anc32"></a><span class="line-modified"> 252 LayoutUnit FormattingContext::Geometry::staticHorizontalPositionForOutOfFlowPositioned(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints) const</span>
 253 {
 254     ASSERT(layoutBox.isOutOfFlowPositioned());
 255     // See staticVerticalPositionForOutOfFlowPositioned for the definition of the static position.
 256 
 257     // Start with this box&#39;s border box offset from the parent&#39;s border box.
<a name="33" id="anc33"></a><span class="line-added"> 258     auto&amp; formattingContext = this-&gt;formattingContext();</span>
 259     ASSERT(layoutBox.parent());
<a name="34" id="anc34"></a><span class="line-modified"> 260     auto left = formattingContext.geometryForBox(*layoutBox.parent(), EscapeReason::OutOfFlowBoxNeedsInFlowGeometry).contentBoxLeft();</span>
 261 
 262     // Resolve left all the way up to the containing block.
 263     auto&amp; containingBlock = *layoutBox.containingBlock();
 264     // Start with the parent since we pretend that this box is normal flow.
 265     for (auto* container = layoutBox.parent(); container != &amp;containingBlock; container = container-&gt;containingBlock()) {
<a name="35" id="anc35"></a><span class="line-modified"> 266         auto&amp; boxGeometry = formattingContext.geometryForBox(*container, EscapeReason::OutOfFlowBoxNeedsInFlowGeometry);</span>
 267         // Display::Box::left is the border box left position in its containing block&#39;s coordinate system.
<a name="36" id="anc36"></a><span class="line-modified"> 268         left += boxGeometry.left();</span>
 269         ASSERT(!container-&gt;isPositioned() || layoutBox.isFixedPositioned());
 270     }
 271     // Move the static position relative to the padding box. This is very specific to abolutely positioned boxes.
<a name="37" id="anc37"></a><span class="line-modified"> 272     return left - horizontalConstraints.logicalLeft;</span>

 273 }
 274 
<a name="38" id="anc38"></a><span class="line-modified"> 275 LayoutUnit FormattingContext::Geometry::shrinkToFitWidth(const Box&amp; formattingRoot, LayoutUnit availableWidth)</span>
 276 {
 277     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width] -&gt; shrink to fit -&gt; unsupported -&gt; width(&quot; &lt;&lt; LayoutUnit { } &lt;&lt; &quot;px) layoutBox: &quot; &lt;&lt; &amp;formattingRoot &lt;&lt; &quot;)&quot;);
 278     ASSERT(formattingRoot.establishesFormattingContext());
<a name="39" id="anc39"></a>
 279 
 280     // Calculation of the shrink-to-fit width is similar to calculating the width of a table cell using the automatic table layout algorithm.
 281     // Roughly: calculate the preferred width by formatting the content without breaking lines other than where explicit line breaks occur,
 282     // and also calculate the preferred minimum width, e.g., by trying all possible line breaks. CSS 2.2 does not define the exact algorithm.
 283     // Thirdly, find the available width: in this case, this is the width of the containing block minus the used values of &#39;margin-left&#39;, &#39;border-left-width&#39;,
 284     // &#39;padding-left&#39;, &#39;padding-right&#39;, &#39;border-right-width&#39;, &#39;margin-right&#39;, and the widths of any relevant scroll bars.
 285 
 286     // Then the shrink-to-fit width is: min(max(preferred minimum width, available width), preferred width).
<a name="40" id="anc40"></a><span class="line-modified"> 287     auto intrinsicWidthConstraints = IntrinsicWidthConstraints { };</span>
<span class="line-modified"> 288     if (is&lt;Container&gt;(formattingRoot) &amp;&amp; downcast&lt;Container&gt;(formattingRoot).hasInFlowOrFloatingChild()) {</span>
<span class="line-modified"> 289         auto&amp; root = downcast&lt;Container&gt;(formattingRoot);</span>
<span class="line-modified"> 290         auto&amp; formattingStateForRoot = layoutState().ensureFormattingState(root);</span>
<span class="line-modified"> 291         auto precomputedIntrinsicWidthConstraints = formattingStateForRoot.intrinsicWidthConstraints();</span>
<span class="line-modified"> 292         if (!precomputedIntrinsicWidthConstraints)</span>
<span class="line-added"> 293             intrinsicWidthConstraints = LayoutContext::createFormattingContext(root, layoutState())-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-added"> 294         else</span>
<span class="line-added"> 295             intrinsicWidthConstraints = *precomputedIntrinsicWidthConstraints;</span>
<span class="line-added"> 296     }</span>
<span class="line-added"> 297     return std::min(std::max(intrinsicWidthConstraints.minimum, availableWidth), intrinsicWidthConstraints.maximum);</span>
 298 }
 299 
<a name="41" id="anc41"></a><span class="line-modified"> 300 VerticalGeometry FormattingContext::Geometry::outOfFlowNonReplacedVerticalGeometry(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp; verticalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
 301 {
 302     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; !layoutBox.replaced());
<a name="42" id="anc42"></a><span class="line-added"> 303     ASSERT(verticalConstraints.logicalHeight);</span>
 304 
 305     // 10.6.4 Absolutely positioned, non-replaced elements
 306     //
 307     // For absolutely positioned elements, the used values of the vertical dimensions must satisfy this constraint:
 308     // &#39;top&#39; + &#39;margin-top&#39; + &#39;border-top-width&#39; + &#39;padding-top&#39; + &#39;height&#39; + &#39;padding-bottom&#39; + &#39;border-bottom-width&#39; + &#39;margin-bottom&#39; + &#39;bottom&#39;
 309     // = height of containing block
 310 
 311     // If all three of &#39;top&#39;, &#39;height&#39;, and &#39;bottom&#39; are auto, set &#39;top&#39; to the static position and apply rule number three below.
 312 
 313     // If none of the three are &#39;auto&#39;: If both &#39;margin-top&#39; and &#39;margin-bottom&#39; are &#39;auto&#39;, solve the equation under the extra
 314     // constraint that the two margins get equal values. If one of &#39;margin-top&#39; or &#39;margin-bottom&#39; is &#39;auto&#39;, solve the equation for that value.
 315     // If the values are over-constrained, ignore the value for &#39;bottom&#39; and solve for that value.
 316 
 317     // Otherwise, pick the one of the following six rules that applies.
 318 
 319     // 1. &#39;top&#39; and &#39;height&#39; are &#39;auto&#39; and &#39;bottom&#39; is not &#39;auto&#39;, then the height is based on the content per 10.6.7,
 320     //     set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;top&#39;
 321     // 2. &#39;top&#39; and &#39;bottom&#39; are &#39;auto&#39; and &#39;height&#39; is not &#39;auto&#39;, then set &#39;top&#39; to the static position, set &#39;auto&#39; values for
 322     //    &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;bottom&#39;
 323     // 3. &#39;height&#39; and &#39;bottom&#39; are &#39;auto&#39; and &#39;top&#39; is not &#39;auto&#39;, then the height is based on the content per 10.6.7, set &#39;auto&#39;
 324     //     values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;bottom&#39;
 325     // 4. &#39;top&#39; is &#39;auto&#39;, &#39;height&#39; and &#39;bottom&#39; are not &#39;auto&#39;, then set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0, and solve for &#39;top&#39;
 326     // 5. &#39;height&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;bottom&#39; are not &#39;auto&#39;, then &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; are set to 0 and solve for &#39;height&#39;
 327     // 6. &#39;bottom&#39; is &#39;auto&#39;, &#39;top&#39; and &#39;height&#39; are not &#39;auto&#39;, then set &#39;auto&#39; values for &#39;margin-top&#39; and &#39;margin-bottom&#39; to 0 and solve for &#39;bottom&#39;
 328 
<a name="43" id="anc43"></a><span class="line-added"> 329     auto&amp; formattingContext = this-&gt;formattingContext();</span>
 330     auto&amp; style = layoutBox.style();
<a name="44" id="anc44"></a><span class="line-modified"> 331     auto&amp; boxGeometry = formattingContext.geometryForBox(layoutBox);</span>
<span class="line-modified"> 332     auto containingBlockHeight = *verticalConstraints.logicalHeight;</span>
<span class="line-modified"> 333     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>

 334 
 335     auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
 336     auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
<a name="45" id="anc45"></a><span class="line-modified"> 337     auto height = overrideVerticalValues.height ? overrideVerticalValues.height.value() : computedContentHeight(layoutBox, containingBlockHeight);</span>
<span class="line-modified"> 338     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, horizontalConstraints);</span>
 339     UsedVerticalMargin::NonCollapsedValues usedVerticalMargin;
<a name="46" id="anc46"></a><span class="line-modified"> 340     auto paddingTop = boxGeometry.paddingTop().valueOr(0);</span>
<span class="line-modified"> 341     auto paddingBottom = boxGeometry.paddingBottom().valueOr(0);</span>
<span class="line-modified"> 342     auto borderTop = boxGeometry.borderTop();</span>
<span class="line-modified"> 343     auto borderBottom = boxGeometry.borderBottom();</span>




 344 
 345     if (!top &amp;&amp; !height &amp;&amp; !bottom)
<a name="47" id="anc47"></a><span class="line-modified"> 346         top = staticVerticalPositionForOutOfFlowPositioned(layoutBox, verticalConstraints);</span>
 347 
 348     if (top &amp;&amp; height &amp;&amp; bottom) {
 349         if (!computedVerticalMargin.before &amp;&amp; !computedVerticalMargin.after) {
<a name="48" id="anc48"></a><span class="line-modified"> 350             auto marginBeforeAndAfter = containingBlockHeight - (*top + borderTop + paddingTop + *height + paddingBottom + borderBottom + *bottom);</span>
 351             usedVerticalMargin = { marginBeforeAndAfter / 2, marginBeforeAndAfter / 2 };
 352         } else if (!computedVerticalMargin.before) {
 353             usedVerticalMargin.after = *computedVerticalMargin.after;
<a name="49" id="anc49"></a><span class="line-modified"> 354             usedVerticalMargin.before = containingBlockHeight - (*top + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);</span>
 355         } else if (!computedVerticalMargin.after) {
 356             usedVerticalMargin.before = *computedVerticalMargin.before;
<a name="50" id="anc50"></a><span class="line-modified"> 357             usedVerticalMargin.after = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + *bottom);</span>
 358         } else
 359             usedVerticalMargin = { *computedVerticalMargin.before, *computedVerticalMargin.after };
 360         // Over-constrained?
<a name="51" id="anc51"></a><span class="line-modified"> 361         auto boxHeight = *top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom;</span>
 362         if (boxHeight != containingBlockHeight)
<a name="52" id="anc52"></a><span class="line-modified"> 363             bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after);</span>
 364     }
 365 
 366     if (!top &amp;&amp; !height &amp;&amp; bottom) {
 367         // #1
<a name="53" id="anc53"></a><span class="line-modified"> 368         height = contentHeightForFormattingContextRoot(layoutBox);</span>
 369         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 370         top = containingBlockHeight - (usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);
 371     }
 372 
 373     if (!top &amp;&amp; !bottom &amp;&amp; height) {
 374         // #2
<a name="54" id="anc54"></a><span class="line-modified"> 375         top = staticVerticalPositionForOutOfFlowPositioned(layoutBox, verticalConstraints);</span>
 376         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<a name="55" id="anc55"></a><span class="line-modified"> 377         bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after);</span>
 378     }
 379 
 380     if (!height &amp;&amp; !bottom &amp;&amp; top) {
 381         // #3
<a name="56" id="anc56"></a><span class="line-modified"> 382         height = contentHeightForFormattingContextRoot(layoutBox);</span>
 383         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 384         bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after);
 385     }
 386 
 387     if (!top &amp;&amp; height &amp;&amp; bottom) {
 388         // #4
 389         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<a name="57" id="anc57"></a><span class="line-modified"> 390         top = containingBlockHeight - (usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);</span>
 391     }
 392 
 393     if (!height &amp;&amp; top &amp;&amp; bottom) {
 394         // #5
 395         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 396         height = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + paddingBottom + borderBottom + usedVerticalMargin.after + *bottom);
 397     }
 398 
 399     if (!bottom &amp;&amp; top &amp;&amp; height) {
 400         // #6
 401         usedVerticalMargin = { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<a name="58" id="anc58"></a><span class="line-modified"> 402         bottom = containingBlockHeight - (*top + usedVerticalMargin.before + borderTop + paddingTop + *height + paddingBottom + borderBottom + usedVerticalMargin.after);</span>
 403     }
 404 
 405     ASSERT(top);
 406     ASSERT(bottom);
 407     ASSERT(height);
 408 
 409     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
 410     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<a name="59" id="anc59"></a><span class="line-modified"> 411     auto containingBlockPaddingVerticalEdge = verticalConstraints.logicalTop;</span>
 412     *top += containingBlockPaddingVerticalEdge;
 413     *bottom += containingBlockPaddingVerticalEdge;
 414 
 415     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Height][Margin] -&gt; out-of-flow non-replaced -&gt; top(&quot; &lt;&lt; *top &lt;&lt; &quot;px) bottom(&quot;  &lt;&lt; *bottom &lt;&lt; &quot;px) height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot;  &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<a name="60" id="anc60"></a><span class="line-modified"> 416     return { *top, *bottom, { *height, usedVerticalMargin } };</span>
 417 }
 418 
<a name="61" id="anc61"></a><span class="line-modified"> 419 HorizontalGeometry FormattingContext::Geometry::outOfFlowNonReplacedHorizontalGeometry(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues)</span>
 420 {
 421     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; !layoutBox.replaced());
 422 
 423     // 10.3.7 Absolutely positioned, non-replaced elements
 424     //
 425     // &#39;left&#39; + &#39;margin-left&#39; + &#39;border-left-width&#39; + &#39;padding-left&#39; + &#39;width&#39; + &#39;padding-right&#39; + &#39;border-right-width&#39; + &#39;margin-right&#39; + &#39;right&#39;
 426     // = width of containing block
 427 
 428     // If all three of &#39;left&#39;, &#39;width&#39;, and &#39;right&#39; are &#39;auto&#39;: First set any &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0.
 429     // Then, if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39; set &#39;left&#39; to the static
 430     // position and apply rule number three below; otherwise, set &#39;right&#39; to the static position and apply rule number one below.
 431     //
 432     // If none of the three is &#39;auto&#39;: If both &#39;margin-left&#39; and &#39;margin-right&#39; are &#39;auto&#39;, solve the equation under the extra constraint that the two margins get equal values,
 433     // unless this would make them negative, in which case when direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
 434     // solve for &#39;margin-right&#39; (&#39;margin-left&#39;). If one of &#39;margin-left&#39; or &#39;margin-right&#39; is &#39;auto&#39;, solve the equation for that value.
 435     // If the values are over-constrained, ignore the value for &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or &#39;right&#39;
 436     // (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
 437     //
 438     // Otherwise, set &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0, and pick the one of the following six rules that applies.
 439     //
 440     // 1. &#39;left&#39; and &#39;width&#39; are &#39;auto&#39; and &#39;right&#39; is not &#39;auto&#39;, then the width is shrink-to-fit. Then solve for &#39;left&#39;
 441     // 2. &#39;left&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;width&#39; is not &#39;auto&#39;, then if the &#39;direction&#39; property of the element establishing the static-position
 442     //    containing block is &#39;ltr&#39; set &#39;left&#39; to the static position, otherwise set &#39;right&#39; to the static position.
 443     //    Then solve for &#39;left&#39; (if &#39;direction is &#39;rtl&#39;) or &#39;right&#39; (if &#39;direction&#39; is &#39;ltr&#39;).
 444     // 3. &#39;width&#39; and &#39;right&#39; are &#39;auto&#39; and &#39;left&#39; is not &#39;auto&#39;, then the width is shrink-to-fit . Then solve for &#39;right&#39;
 445     // 4. &#39;left&#39; is &#39;auto&#39;, &#39;width&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve for &#39;left&#39;
 446     // 5. &#39;width&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;right&#39; are not &#39;auto&#39;, then solve for &#39;width&#39;
 447     // 6. &#39;right&#39; is &#39;auto&#39;, &#39;left&#39; and &#39;width&#39; are not &#39;auto&#39;, then solve for &#39;right&#39;
 448 
<a name="62" id="anc62"></a><span class="line-added"> 449     auto&amp; formattingContext = this-&gt;formattingContext();</span>
 450     auto&amp; style = layoutBox.style();
<a name="63" id="anc63"></a><span class="line-modified"> 451     auto&amp; boxGeometry = formattingContext.geometryForBox(layoutBox);</span>
<span class="line-modified"> 452     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
<span class="line-modified"> 453     auto isLeftToRightDirection = layoutBox.containingBlock()-&gt;style().isLeftToRightDirection();</span>


 454 
 455     auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
 456     auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);
<a name="64" id="anc64"></a><span class="line-modified"> 457     auto width = overrideHorizontalValues.width ? overrideHorizontalValues.width : computedContentWidth(layoutBox, containingBlockWidth);</span>
<span class="line-modified"> 458     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, horizontalConstraints);</span>
 459     UsedHorizontalMargin usedHorizontalMargin;
<a name="65" id="anc65"></a><span class="line-modified"> 460     auto paddingLeft = boxGeometry.paddingLeft().valueOr(0);</span>
<span class="line-modified"> 461     auto paddingRight = boxGeometry.paddingRight().valueOr(0);</span>
<span class="line-modified"> 462     auto borderLeft = boxGeometry.borderLeft();</span>
<span class="line-modified"> 463     auto borderRight = boxGeometry.borderRight();</span>





 464     if (!left &amp;&amp; !width &amp;&amp; !right) {
 465         // If all three of &#39;left&#39;, &#39;width&#39;, and &#39;right&#39; are &#39;auto&#39;: First set any &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0.
 466         // Then, if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39; set &#39;left&#39; to the static
 467         // position and apply rule number three below; otherwise, set &#39;right&#39; to the static position and apply rule number one below.
 468         usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
 469 
<a name="66" id="anc66"></a><span class="line-modified"> 470         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutBox, horizontalConstraints);</span>
 471         if (isLeftToRightDirection)
 472             left = staticHorizontalPosition;
 473         else
 474             right = staticHorizontalPosition;
 475     } else if (left &amp;&amp; width &amp;&amp; right) {
 476         // If none of the three is &#39;auto&#39;: If both &#39;margin-left&#39; and &#39;margin-right&#39; are &#39;auto&#39;, solve the equation under the extra constraint that the two margins get equal values,
 477         // unless this would make them negative, in which case when direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
 478         // solve for &#39;margin-right&#39; (&#39;margin-left&#39;). If one of &#39;margin-left&#39; or &#39;margin-right&#39; is &#39;auto&#39;, solve the equation for that value.
 479         // If the values are over-constrained, ignore the value for &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or &#39;right&#39;
 480         // (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
 481         if (!computedHorizontalMargin.start &amp;&amp; !computedHorizontalMargin.end) {
<a name="67" id="anc67"></a><span class="line-modified"> 482             auto marginStartAndEnd = containingBlockWidth - (*left + borderLeft + paddingLeft + *width + paddingRight + borderRight + *right);</span>
 483             if (marginStartAndEnd &gt;= 0)
 484                 usedHorizontalMargin = { marginStartAndEnd / 2, marginStartAndEnd / 2 };
 485             else {
 486                 if (isLeftToRightDirection) {
 487                     usedHorizontalMargin.start = 0_lu;
<a name="68" id="anc68"></a><span class="line-modified"> 488                     usedHorizontalMargin.end = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + *right);</span>
 489                 } else {
 490                     usedHorizontalMargin.end = 0_lu;
<a name="69" id="anc69"></a><span class="line-modified"> 491                     usedHorizontalMargin.start = containingBlockWidth - (*left + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
 492                 }
 493             }
 494         } else if (!computedHorizontalMargin.start) {
 495             usedHorizontalMargin.end = *computedHorizontalMargin.end;
<a name="70" id="anc70"></a><span class="line-modified"> 496             usedHorizontalMargin.start = containingBlockWidth - (*left + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
 497         } else if (!computedHorizontalMargin.end) {
 498             usedHorizontalMargin.start = *computedHorizontalMargin.start;
<a name="71" id="anc71"></a><span class="line-modified"> 499             usedHorizontalMargin.end = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + *right);</span>
 500         } else {
 501             usedHorizontalMargin = { *computedHorizontalMargin.start, *computedHorizontalMargin.end };
 502             // Overconstrained? Ignore right (left).
 503             if (isLeftToRightDirection)
<a name="72" id="anc72"></a><span class="line-modified"> 504                 right = containingBlockWidth - (usedHorizontalMargin.start + *left + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end);</span>
 505             else
<a name="73" id="anc73"></a><span class="line-modified"> 506                 left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
 507         }
 508     } else {
 509         // Otherwise, set &#39;auto&#39; values for &#39;margin-left&#39; and &#39;margin-right&#39; to 0, and pick the one of the following six rules that applies.
 510         usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
 511     }
 512 
 513     if (!left &amp;&amp; !width &amp;&amp; right) {
 514         // #1
 515         // Calculate the available width by solving for &#39;width&#39; after setting &#39;left&#39; (in case 1) to 0
 516         left = LayoutUnit { 0 };
 517         auto availableWidth = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);
<a name="74" id="anc74"></a><span class="line-modified"> 518         width = shrinkToFitWidth(layoutBox, availableWidth);</span>
 519         left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight  + borderRight + usedHorizontalMargin.end + *right);
 520     } else if (!left &amp;&amp; !right &amp;&amp; width) {
 521         // #2
<a name="75" id="anc75"></a><span class="line-modified"> 522         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutBox, horizontalConstraints);</span>
 523         if (isLeftToRightDirection) {
 524             left = staticHorizontalPosition;
<a name="76" id="anc76"></a><span class="line-modified"> 525             right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end);</span>
 526         } else {
 527             right = staticHorizontalPosition;
<a name="77" id="anc77"></a><span class="line-modified"> 528             left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
 529         }
 530     } else if (!width &amp;&amp; !right &amp;&amp; left) {
 531         // #3
 532         // Calculate the available width by solving for &#39;width&#39; after setting &#39;right&#39; (in case 3) to 0
 533         right = LayoutUnit { 0 };
 534         auto availableWidth = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);
<a name="78" id="anc78"></a><span class="line-modified"> 535         width = shrinkToFitWidth(layoutBox, availableWidth);</span>
 536         right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end);
 537     } else if (!left &amp;&amp; width &amp;&amp; right) {
 538         // #4
<a name="79" id="anc79"></a><span class="line-modified"> 539         left = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end + *right);</span>
 540     } else if (!width &amp;&amp; left &amp;&amp; right) {
 541         // #5
 542         width = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end + *right);
 543     } else if (!right &amp;&amp; left &amp;&amp; width) {
 544         // #6
<a name="80" id="anc80"></a><span class="line-modified"> 545         right = containingBlockWidth - (*left + usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end);</span>
 546     }
 547 
 548     ASSERT(left);
 549     ASSERT(right);
 550     ASSERT(width);
 551 
 552     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
 553     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<a name="81" id="anc81"></a><span class="line-modified"> 554     auto containingBlockPaddingVerticalEdge = horizontalConstraints.logicalLeft;</span>
 555     *left += containingBlockPaddingVerticalEdge;
 556     *right += containingBlockPaddingVerticalEdge;
 557 
 558     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Width][Margin] -&gt; out-of-flow non-replaced -&gt; left(&quot; &lt;&lt; *left &lt;&lt; &quot;px) right(&quot;  &lt;&lt; *right &lt;&lt; &quot;px) width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedHorizontalMargin.start &lt;&lt; &quot;px, &quot;  &lt;&lt; usedHorizontalMargin.end &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<a name="82" id="anc82"></a><span class="line-modified"> 559     return { *left, *right, { *width, usedHorizontalMargin, computedHorizontalMargin } };</span>
 560 }
 561 
<a name="83" id="anc83"></a><span class="line-modified"> 562 VerticalGeometry FormattingContext::Geometry::outOfFlowReplacedVerticalGeometry(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp; verticalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
 563 {
 564     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; layoutBox.replaced());
<a name="84" id="anc84"></a><span class="line-added"> 565     ASSERT(verticalConstraints.logicalHeight);</span>
 566 
 567     // 10.6.5 Absolutely positioned, replaced elements
 568     //
 569     // The used value of &#39;height&#39; is determined as for inline replaced elements.
 570     // If &#39;margin-top&#39; or &#39;margin-bottom&#39; is specified as &#39;auto&#39; its used value is determined by the rules below.
 571     // 1. If both &#39;top&#39; and &#39;bottom&#39; have the value &#39;auto&#39;, replace &#39;top&#39; with the element&#39;s static position.
 572     // 2. If &#39;bottom&#39; is &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-top&#39; or &#39;margin-bottom&#39; with &#39;0&#39;.
 573     // 3. If at this point both &#39;margin-top&#39; and &#39;margin-bottom&#39; are still &#39;auto&#39;, solve the equation under the extra constraint that the two margins must get equal values.
 574     // 4. If at this point there is only one &#39;auto&#39; left, solve the equation for that value.
 575     // 5. If at this point the values are over-constrained, ignore the value for &#39;bottom&#39; and solve for that value.
 576 
<a name="85" id="anc85"></a><span class="line-added"> 577     auto&amp; formattingContext = this-&gt;formattingContext();</span>
 578     auto&amp; style = layoutBox.style();
<a name="86" id="anc86"></a><span class="line-modified"> 579     auto&amp; boxGeometry = formattingContext.geometryForBox(layoutBox);</span>
<span class="line-modified"> 580     auto containingBlockHeight = *verticalConstraints.logicalHeight;</span>
<span class="line-modified"> 581     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>

 582 
 583     auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
 584     auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
<a name="87" id="anc87"></a><span class="line-modified"> 585     auto height = inlineReplacedHeightAndMargin(layoutBox, horizontalConstraints, verticalConstraints, overrideVerticalValues).contentHeight;</span>
<span class="line-modified"> 586     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, horizontalConstraints);</span>
 587     Optional&lt;LayoutUnit&gt; usedMarginBefore = computedVerticalMargin.before;
 588     Optional&lt;LayoutUnit&gt; usedMarginAfter = computedVerticalMargin.after;
<a name="88" id="anc88"></a><span class="line-modified"> 589     auto paddingTop = boxGeometry.paddingTop().valueOr(0);</span>
<span class="line-modified"> 590     auto paddingBottom = boxGeometry.paddingBottom().valueOr(0);</span>
<span class="line-modified"> 591     auto borderTop = boxGeometry.borderTop();</span>
<span class="line-modified"> 592     auto borderBottom = boxGeometry.borderBottom();</span>
 593 
 594     if (!top &amp;&amp; !bottom) {
 595         // #1
<a name="89" id="anc89"></a><span class="line-modified"> 596         top = staticVerticalPositionForOutOfFlowPositioned(layoutBox, verticalConstraints);</span>
 597     }
 598 
 599     if (!bottom) {
 600         // #2
 601         usedMarginBefore = computedVerticalMargin.before.valueOr(0);
 602         usedMarginAfter = usedMarginBefore;
 603     }
 604 
 605     if (!usedMarginBefore &amp;&amp; !usedMarginAfter) {
 606         // #3
 607         auto marginBeforeAndAfter = containingBlockHeight - (*top + borderTop + paddingTop + height + paddingBottom + borderBottom + *bottom);
 608         usedMarginBefore = marginBeforeAndAfter / 2;
 609         usedMarginAfter = usedMarginBefore;
 610     }
 611 
 612     // #4
 613     if (!top)
 614         top = containingBlockHeight - (*usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter + *bottom);
 615 
 616     if (!bottom)
 617         bottom = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter);
 618 
 619     if (!usedMarginBefore)
 620         usedMarginBefore = containingBlockHeight - (*top + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter + *bottom);
 621 
 622     if (!usedMarginAfter)
 623         usedMarginAfter = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *bottom);
 624 
 625     // #5
 626     auto boxHeight = *top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter + *bottom;
 627     if (boxHeight &gt; containingBlockHeight)
 628         bottom = containingBlockHeight - (*top + *usedMarginBefore + borderTop + paddingTop + height + paddingBottom + borderBottom + *usedMarginAfter);
 629 
 630     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
 631     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<a name="90" id="anc90"></a><span class="line-modified"> 632     auto containingBlockPaddingVerticalEdge = verticalConstraints.logicalTop;</span>
 633     *top += containingBlockPaddingVerticalEdge;
 634     *bottom += containingBlockPaddingVerticalEdge;
 635 
 636     ASSERT(top);
 637     ASSERT(bottom);
 638     ASSERT(usedMarginBefore);
 639     ASSERT(usedMarginAfter);
 640     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Height][Margin] -&gt; out-of-flow replaced -&gt; top(&quot; &lt;&lt; *top &lt;&lt; &quot;px) bottom(&quot;  &lt;&lt; *bottom &lt;&lt; &quot;px) height(&quot; &lt;&lt; height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; *usedMarginBefore &lt;&lt; &quot;px, &quot;  &lt;&lt; *usedMarginAfter &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 641     return { *top, *bottom, { height, { *usedMarginBefore, *usedMarginAfter } } };
 642 }
 643 
<a name="91" id="anc91"></a><span class="line-modified"> 644 HorizontalGeometry FormattingContext::Geometry::outOfFlowReplacedHorizontalGeometry(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues) const</span>
 645 {
 646     ASSERT(layoutBox.isOutOfFlowPositioned() &amp;&amp; layoutBox.replaced());
 647 
 648     // 10.3.8 Absolutely positioned, replaced elements
 649     // In this case, section 10.3.7 applies up through and including the constraint equation, but the rest of section 10.3.7 is replaced by the following rules:
 650     //
 651     // The used value of &#39;width&#39; is determined as for inline replaced elements. If &#39;margin-left&#39; or &#39;margin-right&#39; is specified as &#39;auto&#39; its used value is determined by the rules below.
 652     // 1. If both &#39;left&#39; and &#39;right&#39; have the value &#39;auto&#39;, then if the &#39;direction&#39; property of the element establishing the static-position containing block is &#39;ltr&#39;,
 653     //   set &#39;left&#39; to the static position; else if &#39;direction&#39; is &#39;rtl&#39;, set &#39;right&#39; to the static position.
 654     // 2. If &#39;left&#39; or &#39;right&#39; are &#39;auto&#39;, replace any &#39;auto&#39; on &#39;margin-left&#39; or &#39;margin-right&#39; with &#39;0&#39;.
 655     // 3. If at this point both &#39;margin-left&#39; and &#39;margin-right&#39; are still &#39;auto&#39;, solve the equation under the extra constraint that the two margins must get equal values,
 656     //   unless this would make them negative, in which case when the direction of the containing block is &#39;ltr&#39; (&#39;rtl&#39;), set &#39;margin-left&#39; (&#39;margin-right&#39;) to zero and
 657     //   solve for &#39;margin-right&#39; (&#39;margin-left&#39;).
 658     // 4. If at this point there is an &#39;auto&#39; left, solve the equation for that value.
 659     // 5. If at this point the values are over-constrained, ignore the value for either &#39;left&#39; (in case the &#39;direction&#39; property of the containing block is &#39;rtl&#39;) or
 660     //   &#39;right&#39; (in case &#39;direction&#39; is &#39;ltr&#39;) and solve for that value.
 661 
<a name="92" id="anc92"></a><span class="line-added"> 662     auto&amp; formattingContext = this-&gt;formattingContext();</span>
 663     auto&amp; style = layoutBox.style();
<a name="93" id="anc93"></a><span class="line-modified"> 664     auto&amp; boxGeometry = formattingContext.geometryForBox(layoutBox);</span>
<span class="line-modified"> 665     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
<span class="line-modified"> 666     auto isLeftToRightDirection = layoutBox.containingBlock()-&gt;style().isLeftToRightDirection();</span>

 667 
 668     auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
 669     auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);
<a name="94" id="anc94"></a><span class="line-modified"> 670     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, horizontalConstraints);</span>
 671     Optional&lt;LayoutUnit&gt; usedMarginStart = computedHorizontalMargin.start;
 672     Optional&lt;LayoutUnit&gt; usedMarginEnd = computedHorizontalMargin.end;
<a name="95" id="anc95"></a><span class="line-modified"> 673     auto width = inlineReplacedWidthAndMargin(layoutBox, horizontalConstraints, overrideHorizontalValues).contentWidth;</span>
<span class="line-modified"> 674     auto paddingLeft = boxGeometry.paddingLeft().valueOr(0);</span>
<span class="line-modified"> 675     auto paddingRight = boxGeometry.paddingRight().valueOr(0);</span>
<span class="line-modified"> 676     auto borderLeft = boxGeometry.borderLeft();</span>
<span class="line-modified"> 677     auto borderRight = boxGeometry.borderRight();</span>
 678 
 679     if (!left &amp;&amp; !right) {
 680         // #1
<a name="96" id="anc96"></a><span class="line-modified"> 681         auto staticHorizontalPosition = staticHorizontalPositionForOutOfFlowPositioned(layoutBox, horizontalConstraints);</span>
 682         if (isLeftToRightDirection)
 683             left = staticHorizontalPosition;
 684         else
 685             right = staticHorizontalPosition;
 686     }
 687 
 688     if (!left || !right) {
 689         // #2
 690         usedMarginStart = computedHorizontalMargin.start.valueOr(0);
 691         usedMarginEnd = computedHorizontalMargin.end.valueOr(0);
 692     }
 693 
 694     if (!usedMarginStart &amp;&amp; !usedMarginEnd) {
 695         // #3
 696         auto marginStartAndEnd = containingBlockWidth - (*left + borderLeft + paddingLeft + width + paddingRight + borderRight + *right);
 697         if (marginStartAndEnd &gt;= 0) {
 698             usedMarginStart = marginStartAndEnd / 2;
 699             usedMarginEnd = usedMarginStart;
 700         } else {
 701             if (isLeftToRightDirection) {
 702                 usedMarginStart = 0_lu;
 703                 usedMarginEnd = containingBlockWidth - (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *right);
 704             } else {
 705                 usedMarginEnd = 0_lu;
 706                 usedMarginStart = containingBlockWidth - (*left + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 707             }
 708         }
 709     }
 710 
 711     // #4
 712     if (!left)
 713         left = containingBlockWidth - (*usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 714 
 715     if (!right)
 716         right = containingBlockWidth - (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd);
 717 
 718     if (!usedMarginStart)
 719         usedMarginStart = containingBlockWidth - (*left + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 720 
 721     if (!usedMarginEnd)
 722         usedMarginEnd = containingBlockWidth - (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *right);
 723 
 724     auto boxWidth = (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 725     if (boxWidth &gt; containingBlockWidth) {
 726         // #5 Over-constrained?
 727         if (isLeftToRightDirection)
 728             right = containingBlockWidth - (*left + *usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd);
 729         else
 730             left = containingBlockWidth - (*usedMarginStart + borderLeft + paddingLeft + width + paddingRight + borderRight + *usedMarginEnd + *right);
 731     }
 732 
 733     ASSERT(left);
 734     ASSERT(right);
 735     ASSERT(usedMarginStart);
 736     ASSERT(usedMarginEnd);
 737 
 738     // For out-of-flow elements the containing block is formed by the padding edge of the ancestor.
 739     // At this point the positioned value is in the coordinate system of the padding box. Let&#39;s convert it to border box coordinate system.
<a name="97" id="anc97"></a><span class="line-modified"> 740     auto containingBlockPaddingVerticalEdge = horizontalConstraints.logicalLeft;</span>
 741     *left += containingBlockPaddingVerticalEdge;
 742     *right += containingBlockPaddingVerticalEdge;
 743 
 744     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position][Width][Margin] -&gt; out-of-flow replaced -&gt; left(&quot; &lt;&lt; *left &lt;&lt; &quot;px) right(&quot;  &lt;&lt; *right &lt;&lt; &quot;px) width(&quot; &lt;&lt; width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; *usedMarginStart &lt;&lt; &quot;px, &quot;  &lt;&lt; *usedMarginEnd &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 745     return { *left, *right, { width, { *usedMarginStart, *usedMarginEnd }, computedHorizontalMargin } };
 746 }
 747 
<a name="98" id="anc98"></a><span class="line-modified"> 748 ContentHeightAndMargin FormattingContext::Geometry::complicatedCases(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
 749 {
 750     ASSERT(!layoutBox.replaced());
 751     // TODO: Use complicated-case for document renderer for now (see BlockFormattingContext::Geometry::inFlowHeightAndMargin).
<a name="99" id="anc99"></a><span class="line-modified"> 752     ASSERT((layoutBox.isBlockLevelBox() &amp;&amp; layoutBox.isInFlow() &amp;&amp; !layoutBox.isOverflowVisible()) || layoutBox.isInlineBlockBox() || layoutBox.isFloatingPositioned() || layoutBox.isDocumentBox() || layoutBox.isTableBox());</span>
 753 
 754     // 10.6.6 Complicated cases
 755     //
 756     // Block-level, non-replaced elements in normal flow when &#39;overflow&#39; does not compute to &#39;visible&#39; (except if the &#39;overflow&#39; property&#39;s value has been propagated to the viewport).
 757     // &#39;Inline-block&#39;, non-replaced elements.
 758     // Floating, non-replaced elements.
 759     //
 760     // 1. If &#39;margin-top&#39;, or &#39;margin-bottom&#39; are &#39;auto&#39;, their used value is 0.
 761     // 2. If &#39;height&#39; is &#39;auto&#39;, the height depends on the element&#39;s descendants per 10.6.7.
 762 
<a name="100" id="anc100"></a><span class="line-modified"> 763     auto height = overrideVerticalValues.height ? overrideVerticalValues.height.value() : computedContentHeight(layoutBox);</span>
<span class="line-modified"> 764     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, horizontalConstraints);</span>
 765     // #1
 766     auto usedVerticalMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 767     // #2
 768     if (!height) {
 769         ASSERT(isHeightAuto(layoutBox));
<a name="101" id="anc101"></a><span class="line-modified"> 770         height = contentHeightForFormattingContextRoot(layoutBox);</span>
 771     }
 772 
 773     ASSERT(height);
 774 
 775     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; floating non-replaced -&gt; height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot; &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<a name="102" id="anc102"></a><span class="line-modified"> 776     return ContentHeightAndMargin { *height, usedVerticalMargin };</span>
 777 }
 778 
<a name="103" id="anc103"></a><span class="line-modified"> 779 ContentWidthAndMargin FormattingContext::Geometry::floatingNonReplacedWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues)</span>
 780 {
 781     ASSERT(layoutBox.isFloatingPositioned() &amp;&amp; !layoutBox.replaced());
 782 
 783     // 10.3.5 Floating, non-replaced elements
 784     //
 785     // 1. If &#39;margin-left&#39;, or &#39;margin-right&#39; are computed as &#39;auto&#39;, their used value is &#39;0&#39;.
 786     // 2. If &#39;width&#39; is computed as &#39;auto&#39;, the used value is the &quot;shrink-to-fit&quot; width.
 787 
<a name="104" id="anc104"></a><span class="line-modified"> 788     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, horizontalConstraints);</span>
 789 
 790     // #1
 791     auto usedHorizontallMargin = UsedHorizontalMargin { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
 792     // #2
<a name="105" id="anc105"></a><span class="line-modified"> 793     auto width = overrideHorizontalValues.width ? overrideHorizontalValues.width : computedContentWidth(layoutBox, horizontalConstraints.logicalWidth);</span>
 794     if (!width)
<a name="106" id="anc106"></a><span class="line-modified"> 795         width = shrinkToFitWidth(layoutBox, horizontalConstraints.logicalWidth);</span>
 796 
 797     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; floating non-replaced -&gt; width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedHorizontallMargin.start &lt;&lt; &quot;px, &quot; &lt;&lt; usedHorizontallMargin.end &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
<a name="107" id="anc107"></a><span class="line-modified"> 798     return ContentWidthAndMargin { *width, usedHorizontallMargin, computedHorizontalMargin };</span>
 799 }
 800 
<a name="108" id="anc108"></a><span class="line-modified"> 801 ContentHeightAndMargin FormattingContext::Geometry::floatingReplacedHeightAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
 802 {
 803     ASSERT(layoutBox.isFloatingPositioned() &amp;&amp; layoutBox.replaced());
 804 
 805     // 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, &#39;inline-block&#39;
 806     // replaced elements in normal flow and floating replaced elements
 807     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; floating replaced -&gt; redirected to inline replaced&quot;);
<a name="109" id="anc109"></a><span class="line-modified"> 808     return inlineReplacedHeightAndMargin(layoutBox, horizontalConstraints, { }, overrideVerticalValues);</span>
 809 }
 810 
<a name="110" id="anc110"></a><span class="line-modified"> 811 ContentWidthAndMargin FormattingContext::Geometry::floatingReplacedWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues) const</span>
 812 {
 813     ASSERT(layoutBox.isFloatingPositioned() &amp;&amp; layoutBox.replaced());
 814 
 815     // 10.3.6 Floating, replaced elements
 816     //
 817     // 1. If &#39;margin-left&#39; or &#39;margin-right&#39; are computed as &#39;auto&#39;, their used value is &#39;0&#39;.
 818     // 2. The used value of &#39;width&#39; is determined as for inline replaced elements.
<a name="111" id="anc111"></a><span class="line-modified"> 819     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, horizontalConstraints);</span>
 820 
 821     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; floating replaced -&gt; redirected to inline replaced&quot;);
<a name="112" id="anc112"></a><span class="line-modified"> 822     auto usedMargin = UsedHorizontalMargin { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };</span>
<span class="line-modified"> 823     return inlineReplacedWidthAndMargin(layoutBox, horizontalConstraints, { overrideHorizontalValues.width, usedMargin });</span>
 824 }
 825 
<a name="113" id="anc113"></a><span class="line-modified"> 826 VerticalGeometry FormattingContext::Geometry::outOfFlowVerticalGeometry(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp; verticalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
 827 {
 828     ASSERT(layoutBox.isOutOfFlowPositioned());
 829 
 830     if (!layoutBox.replaced())
<a name="114" id="anc114"></a><span class="line-modified"> 831         return outOfFlowNonReplacedVerticalGeometry(layoutBox, horizontalConstraints, verticalConstraints, overrideVerticalValues);</span>
<span class="line-modified"> 832     return outOfFlowReplacedVerticalGeometry(layoutBox, horizontalConstraints, verticalConstraints, overrideVerticalValues);</span>
 833 }
 834 
<a name="115" id="anc115"></a><span class="line-modified"> 835 HorizontalGeometry FormattingContext::Geometry::outOfFlowHorizontalGeometry(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues)</span>
 836 {
 837     ASSERT(layoutBox.isOutOfFlowPositioned());
 838 
 839     if (!layoutBox.replaced())
<a name="116" id="anc116"></a><span class="line-modified"> 840         return outOfFlowNonReplacedHorizontalGeometry(layoutBox, horizontalConstraints, overrideHorizontalValues);</span>
<span class="line-modified"> 841     return outOfFlowReplacedHorizontalGeometry(layoutBox, horizontalConstraints, overrideHorizontalValues);</span>
 842 }
 843 
<a name="117" id="anc117"></a><span class="line-modified"> 844 ContentHeightAndMargin FormattingContext::Geometry::floatingHeightAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
 845 {
 846     ASSERT(layoutBox.isFloatingPositioned());
 847 
 848     if (!layoutBox.replaced())
<a name="118" id="anc118"></a><span class="line-modified"> 849         return complicatedCases(layoutBox, horizontalConstraints, overrideVerticalValues);</span>
<span class="line-modified"> 850     return floatingReplacedHeightAndMargin(layoutBox, horizontalConstraints, overrideVerticalValues);</span>
 851 }
 852 
<a name="119" id="anc119"></a><span class="line-modified"> 853 ContentWidthAndMargin FormattingContext::Geometry::floatingWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues)</span>
 854 {
 855     ASSERT(layoutBox.isFloatingPositioned());
 856 
 857     if (!layoutBox.replaced())
<a name="120" id="anc120"></a><span class="line-modified"> 858         return floatingNonReplacedWidthAndMargin(layoutBox, horizontalConstraints, overrideHorizontalValues);</span>
<span class="line-modified"> 859     return floatingReplacedWidthAndMargin(layoutBox, horizontalConstraints, overrideHorizontalValues);</span>
 860 }
 861 
<a name="121" id="anc121"></a><span class="line-modified"> 862 ContentHeightAndMargin FormattingContext::Geometry::inlineReplacedHeightAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, Optional&lt;VerticalConstraints&gt; verticalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues) const</span>
 863 {
 864     ASSERT((layoutBox.isOutOfFlowPositioned() || layoutBox.isFloatingPositioned() || layoutBox.isInFlow()) &amp;&amp; layoutBox.replaced());
 865 
 866     // 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, &#39;inline-block&#39; replaced elements in normal flow and floating replaced elements
 867     //
 868     // 1. If &#39;margin-top&#39;, or &#39;margin-bottom&#39; are &#39;auto&#39;, their used value is 0.
 869     // 2. If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element also has an intrinsic height, then that intrinsic height is the used value of &#39;height&#39;.
 870     // 3. Otherwise, if &#39;height&#39; has a computed value of &#39;auto&#39;, and the element has an intrinsic ratio then the used value of &#39;height&#39; is:
 871     //    (used width) / (intrinsic ratio)
 872     // 4. Otherwise, if &#39;height&#39; has a computed value of &#39;auto&#39;, and the element has an intrinsic height, then that intrinsic height is the used value of &#39;height&#39;.
 873     // 5. Otherwise, if &#39;height&#39; has a computed value of &#39;auto&#39;, but none of the conditions above are met, then the used value of &#39;height&#39; must be set to
 874     //    the height of the largest rectangle that has a 2:1 ratio, has a height not greater than 150px, and has a width not greater than the device width.
 875 
 876     // #1
<a name="122" id="anc122"></a><span class="line-modified"> 877     auto&amp; formattingContext = this-&gt;formattingContext();</span>
<span class="line-modified"> 878     auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, horizontalConstraints);</span>
 879     auto usedVerticalMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 880     auto&amp; style = layoutBox.style();
 881     auto replaced = layoutBox.replaced();
 882 
<a name="123" id="anc123"></a><span class="line-modified"> 883     auto height = overrideVerticalValues.height ? overrideVerticalValues.height.value() : computedContentHeight(layoutBox, verticalConstraints ? verticalConstraints-&gt;logicalHeight : WTF::nullopt);</span>
<span class="line-modified"> 884     auto heightIsAuto = !overrideVerticalValues.height &amp;&amp; isHeightAuto(layoutBox);</span>
 885     auto widthIsAuto = style.logicalWidth().isAuto();
 886 
 887     if (heightIsAuto &amp;&amp; widthIsAuto &amp;&amp; replaced-&gt;hasIntrinsicHeight()) {
 888         // #2
 889         height = replaced-&gt;intrinsicHeight();
 890     } else if (heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicRatio()) {
 891         // #3
<a name="124" id="anc124"></a><span class="line-modified"> 892         auto usedWidth = formattingContext.geometryForBox(layoutBox).width();</span>
 893         height = usedWidth / replaced-&gt;intrinsicRatio();
 894     } else if (heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicHeight()) {
 895         // #4
 896         height = replaced-&gt;intrinsicHeight();
 897     } else if (heightIsAuto) {
 898         // #5
 899         height = { 150 };
 900     }
 901 
 902     ASSERT(height);
 903 
 904     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; inflow replaced -&gt; height(&quot; &lt;&lt; *height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedVerticalMargin.before &lt;&lt; &quot;px, &quot; &lt;&lt; usedVerticalMargin.after &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 905     return { *height, usedVerticalMargin };
 906 }
 907 
<a name="125" id="anc125"></a><span class="line-modified"> 908 ContentWidthAndMargin FormattingContext::Geometry::inlineReplacedWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues) const</span>
 909 {
 910     ASSERT((layoutBox.isOutOfFlowPositioned() || layoutBox.isFloatingPositioned() || layoutBox.isInFlow()) &amp;&amp; layoutBox.replaced());
 911 
 912     // 10.3.2 Inline, replaced elements
 913     //
 914     // A computed value of &#39;auto&#39; for &#39;margin-left&#39; or &#39;margin-right&#39; becomes a used value of &#39;0&#39;.
 915     //
 916     // 1. If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element also has an intrinsic width, then that intrinsic width is the used value of &#39;width&#39;.
 917     //
 918     // 2. If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element has no intrinsic width, but does have an intrinsic height and intrinsic ratio;
 919     //    or if &#39;width&#39; has a computed value of &#39;auto&#39;, &#39;height&#39; has some other computed value, and the element does have an intrinsic ratio;
 920     //    then the used value of &#39;width&#39; is: (used height) * (intrinsic ratio)
 921     //
 922     // 3. If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element has an intrinsic ratio but no intrinsic height or width,
 923     //    then the used value of &#39;width&#39; is undefined in CSS 2.2. However, it is suggested that, if the containing block&#39;s width does not itself depend on the replaced
 924     //    element&#39;s width, then the used value of &#39;width&#39; is calculated from the constraint equation used for block-level, non-replaced elements in normal flow.
 925     //
 926     // 4. Otherwise, if &#39;width&#39; has a computed value of &#39;auto&#39;, and the element has an intrinsic width, then that intrinsic width is the used value of &#39;width&#39;.
 927     //
 928     // 5. Otherwise, if &#39;width&#39; has a computed value of &#39;auto&#39;, but none of the conditions above are met, then the used value of &#39;width&#39; becomes 300px.
 929     //    If 300px is too wide to fit the device, UAs should use the width of the largest rectangle that has a 2:1 ratio and fits the device instead.
 930 
<a name="126" id="anc126"></a><span class="line-modified"> 931     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, horizontalConstraints);</span>


 932 
 933     auto usedMarginStart = [&amp;] {
<a name="127" id="anc127"></a><span class="line-modified"> 934         if (overrideHorizontalValues.margin)</span>
<span class="line-modified"> 935             return overrideHorizontalValues.margin-&gt;start;</span>
 936         return computedHorizontalMargin.start.valueOr(0_lu);
 937     };
 938 
 939     auto usedMarginEnd = [&amp;] {
<a name="128" id="anc128"></a><span class="line-modified"> 940         if (overrideHorizontalValues.margin)</span>
<span class="line-modified"> 941             return overrideHorizontalValues.margin-&gt;end;</span>
 942         return computedHorizontalMargin.end.valueOr(0_lu);
 943     };
 944 
 945     auto replaced = layoutBox.replaced();
 946     ASSERT(replaced);
 947 
<a name="129" id="anc129"></a><span class="line-modified"> 948     auto width = overrideHorizontalValues.width ? overrideHorizontalValues.width : computedContentWidth(layoutBox, horizontalConstraints.logicalWidth);</span>
 949     auto heightIsAuto = isHeightAuto(layoutBox);
<a name="130" id="anc130"></a><span class="line-modified"> 950     auto height = computedContentHeight(layoutBox);</span>
 951 
 952     if (!width &amp;&amp; heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicWidth()) {
 953         // #1
 954         width = replaced-&gt;intrinsicWidth();
 955     } else if ((!width &amp;&amp; heightIsAuto &amp;&amp; !replaced-&gt;hasIntrinsicWidth() &amp;&amp; replaced-&gt;hasIntrinsicHeight() &amp;&amp; replaced-&gt;hasIntrinsicRatio())
 956         || (!width &amp;&amp; height &amp;&amp; replaced-&gt;hasIntrinsicRatio())) {
 957         // #2
 958         width = height.valueOr(replaced-&gt;hasIntrinsicHeight()) * replaced-&gt;intrinsicRatio();
 959     } else if (!width &amp;&amp; heightIsAuto &amp;&amp; replaced-&gt;hasIntrinsicRatio() &amp;&amp; !replaced-&gt;hasIntrinsicWidth() &amp;&amp; !replaced-&gt;hasIntrinsicHeight()) {
 960         // #3
 961         // FIXME: undefined but surely doable.
 962         ASSERT_NOT_IMPLEMENTED_YET();
 963     } else if (!width &amp;&amp; replaced-&gt;hasIntrinsicWidth()) {
 964         // #4
 965         width = replaced-&gt;intrinsicWidth();
 966     } else if (!width) {
 967         // #5
 968         width = { 300 };
 969     }
 970 
 971     ASSERT(width);
 972 
 973     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; inflow replaced -&gt; width(&quot; &lt;&lt; *width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; usedMarginStart() &lt;&lt; &quot;px, &quot; &lt;&lt; usedMarginEnd() &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
 974     return { *width, { usedMarginStart(), usedMarginEnd() }, computedHorizontalMargin };
 975 }
 976 
<a name="131" id="anc131"></a><span class="line-modified"> 977 LayoutSize FormattingContext::Geometry::inFlowPositionedPositionOffset(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints) const</span>
 978 {
 979     ASSERT(layoutBox.isInFlowPositioned());
 980 
 981     // 9.4.3 Relative positioning
 982     //
 983     // The &#39;top&#39; and &#39;bottom&#39; properties move relatively positioned element(s) up or down without changing their size.
 984     // Top&#39; moves the boxes down, and &#39;bottom&#39; moves them up. Since boxes are not split or stretched as a result of &#39;top&#39; or &#39;bottom&#39;, the used values are always: top = -bottom.
 985     //
 986     // 1. If both are &#39;auto&#39;, their used values are both &#39;0&#39;.
 987     // 2. If one of them is &#39;auto&#39;, it becomes the negative of the other.
 988     // 3. If neither is &#39;auto&#39;, &#39;bottom&#39; is ignored (i.e., the used value of &#39;bottom&#39; will be minus the value of &#39;top&#39;).
 989 
 990     auto&amp; style = layoutBox.style();
<a name="132" id="anc132"></a><span class="line-modified"> 991     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>

 992 
 993     auto top = computedValueIfNotAuto(style.logicalTop(), containingBlockWidth);
 994     auto bottom = computedValueIfNotAuto(style.logicalBottom(), containingBlockWidth);
 995 
 996     if (!top &amp;&amp; !bottom) {
 997         // #1
 998         top = bottom = { 0 };
 999     } else if (!top) {
1000         // #2
1001         top = -*bottom;
1002     } else if (!bottom) {
1003         // #3
1004         bottom = -*top;
1005     } else {
1006         // #4
1007         bottom = WTF::nullopt;
1008     }
1009 
1010     // For relatively positioned elements, &#39;left&#39; and &#39;right&#39; move the box(es) horizontally, without changing their size.
1011     // &#39;Left&#39; moves the boxes to the right, and &#39;right&#39; moves them to the left.
1012     // Since boxes are not split or stretched as a result of &#39;left&#39; or &#39;right&#39;, the used values are always: left = -right.
1013     //
1014     // 1. If both &#39;left&#39; and &#39;right&#39; are &#39;auto&#39; (their initial values), the used values are &#39;0&#39; (i.e., the boxes stay in their original position).
1015     // 2. If &#39;left&#39; is &#39;auto&#39;, its used value is minus the value of &#39;right&#39; (i.e., the boxes move to the left by the value of &#39;right&#39;).
1016     // 3. If &#39;right&#39; is specified as &#39;auto&#39;, its used value is minus the value of &#39;left&#39;.
1017     // 4. If neither &#39;left&#39; nor &#39;right&#39; is &#39;auto&#39;, the position is over-constrained, and one of them has to be ignored.
1018     //    If the &#39;direction&#39; property of the containing block is &#39;ltr&#39;, the value of &#39;left&#39; wins and &#39;right&#39; becomes -&#39;left&#39;.
1019     //    If &#39;direction&#39; of the containing block is &#39;rtl&#39;, &#39;right&#39; wins and &#39;left&#39; is ignored.
1020 
1021     auto left = computedValueIfNotAuto(style.logicalLeft(), containingBlockWidth);
1022     auto right = computedValueIfNotAuto(style.logicalRight(), containingBlockWidth);
1023 
1024     if (!left &amp;&amp; !right) {
1025         // #1
1026         left = right = { 0 };
1027     } else if (!left) {
1028         // #2
1029         left = -*right;
1030     } else if (!right) {
1031         // #3
1032         right = -*left;
1033     } else {
1034         // #4
<a name="133" id="anc133"></a><span class="line-modified">1035         auto isLeftToRightDirection = layoutBox.containingBlock()-&gt;style().isLeftToRightDirection();</span>
1036         if (isLeftToRightDirection)
1037             right = -*left;
1038         else
1039             left = WTF::nullopt;
1040     }
1041 
1042     ASSERT(!bottom || *top == -*bottom);
1043     ASSERT(!left || *left == -*right);
1044 
1045     auto topPositionOffset = *top;
1046     auto leftPositionOffset = left.valueOr(-*right);
1047 
1048     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Position] -&gt; positioned inflow -&gt; top offset(&quot; &lt;&lt; topPositionOffset &lt;&lt; &quot;px) left offset(&quot; &lt;&lt; leftPositionOffset &lt;&lt; &quot;px) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);
1049     return { leftPositionOffset, topPositionOffset };
1050 }
1051 
<a name="134" id="anc134"></a><span class="line-modified">1052 Edges FormattingContext::Geometry::computedBorder(const Box&amp; layoutBox) const</span>
1053 {
1054     auto&amp; style = layoutBox.style();
1055     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Border] -&gt; layoutBox: &quot; &lt;&lt; &amp;layoutBox);
1056     return {
1057         { LayoutUnit(style.borderLeft().boxModelWidth()), LayoutUnit(style.borderRight().boxModelWidth()) },
1058         { LayoutUnit(style.borderTop().boxModelWidth()), LayoutUnit(style.borderBottom().boxModelWidth()) }
1059     };
1060 }
1061 
<a name="135" id="anc135"></a><span class="line-modified">1062 Optional&lt;Edges&gt; FormattingContext::Geometry::computedPadding(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints) const</span>
1063 {
1064     if (!layoutBox.isPaddingApplicable())
1065         return WTF::nullopt;
1066 
1067     auto&amp; style = layoutBox.style();
<a name="136" id="anc136"></a><span class="line-modified">1068     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
1069     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Padding] -&gt; layoutBox: &quot; &lt;&lt; &amp;layoutBox);
1070     return Edges {
1071         { valueForLength(style.paddingLeft(), containingBlockWidth), valueForLength(style.paddingRight(), containingBlockWidth) },
1072         { valueForLength(style.paddingTop(), containingBlockWidth), valueForLength(style.paddingBottom(), containingBlockWidth) }
1073     };
1074 }
1075 
<a name="137" id="anc137"></a><span class="line-modified">1076 ComputedHorizontalMargin FormattingContext::Geometry::computedHorizontalMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints) const</span>
1077 {
1078     auto&amp; style = layoutBox.style();
<a name="138" id="anc138"></a><span class="line-modified">1079     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
1080     return { computedValueIfNotAuto(style.marginStart(), containingBlockWidth), computedValueIfNotAuto(style.marginEnd(), containingBlockWidth) };
1081 }
1082 
<a name="139" id="anc139"></a><span class="line-modified">1083 ComputedVerticalMargin FormattingContext::Geometry::computedVerticalMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints) const</span>
1084 {
1085     auto&amp; style = layoutBox.style();
<a name="140" id="anc140"></a><span class="line-modified">1086     auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
1087     return { computedValueIfNotAuto(style.marginBefore(), containingBlockWidth), computedValueIfNotAuto(style.marginAfter(), containingBlockWidth) };
1088 }
1089 
<a name="141" id="anc141"></a><span class="line-modified">1090 FormattingContext::IntrinsicWidthConstraints FormattingContext::Geometry::constrainByMinMaxWidth(const Box&amp; layoutBox, IntrinsicWidthConstraints intrinsicWidth) const</span>
1091 {
1092     auto&amp; style = layoutBox.style();
1093     auto minWidth = fixedValue(style.logicalMinWidth());
1094     auto maxWidth = fixedValue(style.logicalMaxWidth());
1095     if (!minWidth &amp;&amp; !maxWidth)
1096         return intrinsicWidth;
1097 
1098     if (maxWidth) {
1099         intrinsicWidth.minimum = std::min(*maxWidth, intrinsicWidth.minimum);
1100         intrinsicWidth.maximum = std::min(*maxWidth, intrinsicWidth.maximum);
1101     }
1102 
1103     if (minWidth) {
1104         intrinsicWidth.minimum = std::max(*minWidth, intrinsicWidth.minimum);
1105         intrinsicWidth.maximum = std::max(*minWidth, intrinsicWidth.maximum);
1106     }
1107 
1108     ASSERT(intrinsicWidth.minimum &lt;= intrinsicWidth.maximum);
1109     return intrinsicWidth;
1110 }
1111 
<a name="142" id="anc142"></a><span class="line-added">1112 HorizontalConstraints FormattingContext::Geometry::horizontalConstraintsForOutOfFlow(const Display::Box&amp; containingBlockGeometry)</span>
<span class="line-added">1113 {</span>
<span class="line-added">1114     return HorizontalConstraints { containingBlockGeometry.paddingBoxLeft(), containingBlockGeometry.paddingBoxWidth() };</span>
<span class="line-added">1115 }</span>
<span class="line-added">1116 </span>
<span class="line-added">1117 VerticalConstraints FormattingContext::Geometry::verticalConstraintsForOutOfFlow(const Display::Box&amp; containingBlockGeometry)</span>
<span class="line-added">1118 {</span>
<span class="line-added">1119     return VerticalConstraints { containingBlockGeometry.paddingBoxTop(), containingBlockGeometry.paddingBoxHeight() };</span>
<span class="line-added">1120 }</span>
<span class="line-added">1121 </span>
<span class="line-added">1122 HorizontalConstraints FormattingContext::Geometry::horizontalConstraintsForInFlow(const Display::Box&amp; containingBlockGeometry)</span>
<span class="line-added">1123 {</span>
<span class="line-added">1124     return HorizontalConstraints { containingBlockGeometry.contentBoxLeft(), containingBlockGeometry.contentBoxWidth() };</span>
<span class="line-added">1125 }</span>
<span class="line-added">1126 </span>
<span class="line-added">1127 VerticalConstraints FormattingContext::Geometry::verticalConstraintsForInFlow(const Display::Box&amp; containingBlockGeometry)</span>
<span class="line-added">1128 {</span>
<span class="line-added">1129     return VerticalConstraints { containingBlockGeometry.contentBoxTop(), { } };</span>
<span class="line-added">1130 }</span>
<span class="line-added">1131 </span>
1132 }
1133 }
1134 #endif
<a name="143" id="anc143"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="143" type="hidden" />
</body>
</html>
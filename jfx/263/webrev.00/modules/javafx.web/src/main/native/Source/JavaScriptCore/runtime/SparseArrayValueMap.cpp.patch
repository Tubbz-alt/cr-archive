diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SparseArrayValueMap.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SparseArrayValueMap.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SparseArrayValueMap.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SparseArrayValueMap.cpp
@@ -94,13 +94,13 @@
 {
     auto locker = holdLock(cellLock());
     m_map.remove(i);
 }
 
-bool SparseArrayValueMap::putEntry(ExecState* exec, JSObject* array, unsigned i, JSValue value, bool shouldThrow)
+bool SparseArrayValueMap::putEntry(JSGlobalObject* globalObject, JSObject* array, unsigned i, JSValue value, bool shouldThrow)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     ASSERT(value);
 
     AddResult result = add(array, i);
     SparseArrayEntry& entry = result.iterator->value;
@@ -108,19 +108,19 @@
     // To save a separate find & add, we first always add to the sparse map.
     // In the uncommon case that this is a new property, and the array is not
     // extensible, this is not the right thing to have done - so remove again.
     if (result.isNewEntry && !array->isStructureExtensible(vm)) {
         remove(result.iterator);
-        return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);
+        return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);
     }
 
-    RELEASE_AND_RETURN(scope, entry.put(exec, array, this, value, shouldThrow));
+    RELEASE_AND_RETURN(scope, entry.put(globalObject, array, this, value, shouldThrow));
 }
 
-bool SparseArrayValueMap::putDirect(ExecState* exec, JSObject* array, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode)
+bool SparseArrayValueMap::putDirect(JSGlobalObject* globalObject, JSObject* array, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     ASSERT(value);
 
     bool shouldThrow = (mode == PutDirectIndexShouldThrow);
 
@@ -130,15 +130,15 @@
     // To save a separate find & add, we first always add to the sparse map.
     // In the uncommon case that this is a new property, and the array is not
     // extensible, this is not the right thing to have done - so remove again.
     if (mode != PutDirectIndexLikePutDirect && result.isNewEntry && !array->isStructureExtensible(vm)) {
         remove(result.iterator);
-        return typeError(exec, scope, shouldThrow, NonExtensibleObjectPropertyDefineError);
+        return typeError(globalObject, scope, shouldThrow, NonExtensibleObjectPropertyDefineError);
     }
 
     if (entry.attributes() & PropertyAttribute::ReadOnly)
-        return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);
+        return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);
 
     entry.forceSet(vm, this, value, attributes);
     return true;
 }
 
@@ -188,24 +188,24 @@
         return JSValue();
 
     return attributesDependency.consume(this)->Base::get();
 }
 
-bool SparseArrayEntry::put(ExecState* exec, JSValue thisValue, SparseArrayValueMap* map, JSValue value, bool shouldThrow)
+bool SparseArrayEntry::put(JSGlobalObject* globalObject, JSValue thisValue, SparseArrayValueMap* map, JSValue value, bool shouldThrow)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (!(m_attributes & PropertyAttribute::Accessor)) {
         if (m_attributes & PropertyAttribute::ReadOnly)
-            return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);
+            return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);
 
         set(vm, map, value);
         return true;
     }
 
-    RELEASE_AND_RETURN(scope, callSetter(exec, thisValue, Base::get(), value, shouldThrow ? StrictMode : NotStrictMode));
+    RELEASE_AND_RETURN(scope, callSetter(globalObject, thisValue, Base::get(), value, shouldThrow ? StrictMode : NotStrictMode));
 }
 
 JSValue SparseArrayEntry::getNonSparseMode() const
 {
     ASSERT(!m_attributes);

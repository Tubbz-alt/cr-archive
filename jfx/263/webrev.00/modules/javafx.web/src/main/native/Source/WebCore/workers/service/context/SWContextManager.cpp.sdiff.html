<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/SWContextManager.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../ServiceWorkerTypes.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SWContextManager.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/SWContextManager.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SWContextManager.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 #include &quot;Logging.h&quot;
 31 #include &quot;MessageWithMessagePorts.h&quot;
 32 #include &quot;ServiceWorkerClientIdentifier.h&quot;
 33 #include &quot;ServiceWorkerGlobalScope.h&quot;
 34 
 35 namespace WebCore {
 36 
 37 SWContextManager&amp; SWContextManager::singleton()
 38 {
 39     static SWContextManager* sharedManager = new SWContextManager;
 40     return *sharedManager;
 41 }
 42 
 43 void SWContextManager::setConnection(std::unique_ptr&lt;Connection&gt;&amp;&amp; connection)
 44 {
<span class="line-modified"> 45     ASSERT(!m_connection);</span>
 46     m_connection = WTFMove(connection);
 47 }
 48 
 49 auto SWContextManager::connection() const -&gt; Connection*
 50 {
 51     return m_connection.get();
 52 }
 53 
 54 void SWContextManager::registerServiceWorkerThreadForInstall(Ref&lt;ServiceWorkerThreadProxy&gt;&amp;&amp; serviceWorkerThreadProxy)
 55 {
 56     auto serviceWorkerIdentifier = serviceWorkerThreadProxy-&gt;identifier();
 57     auto jobDataIdentifier = serviceWorkerThreadProxy-&gt;thread().contextData().jobDataIdentifier;
 58     auto* threadProxy = serviceWorkerThreadProxy.ptr();
 59     auto result = m_workerMap.add(serviceWorkerIdentifier, WTFMove(serviceWorkerThreadProxy));
 60     ASSERT_UNUSED(result, result.isNewEntry);
 61 
<span class="line-modified"> 62     threadProxy-&gt;thread().start([jobDataIdentifier, serviceWorkerIdentifier](const String&amp; exceptionMessage) {</span>
<span class="line-modified"> 63         SWContextManager::singleton().startedServiceWorker(jobDataIdentifier, serviceWorkerIdentifier, exceptionMessage);</span>
 64     });
 65 }
 66 
<span class="line-modified"> 67 void SWContextManager::startedServiceWorker(Optional&lt;ServiceWorkerJobDataIdentifier&gt; jobDataIdentifier, ServiceWorkerIdentifier serviceWorkerIdentifier, const String&amp; exceptionMessage)</span>
 68 {
<span class="line-removed"> 69     connection()-&gt;serviceWorkerStartedWithMessage(jobDataIdentifier, serviceWorkerIdentifier, exceptionMessage);</span>
 70     if (m_serviceWorkerCreationCallback)
 71         m_serviceWorkerCreationCallback(serviceWorkerIdentifier.toUInt64());





 72 }
 73 
 74 ServiceWorkerThreadProxy* SWContextManager::serviceWorkerThreadProxy(ServiceWorkerIdentifier identifier) const
 75 {
 76     return m_workerMap.get(identifier);
 77 }
 78 
 79 void SWContextManager::postMessageToServiceWorker(ServiceWorkerIdentifier destination, MessageWithMessagePorts&amp;&amp; message, ServiceWorkerOrClientData&amp;&amp; sourceData)
 80 {
 81     auto* serviceWorker = m_workerMap.get(destination);
 82     ASSERT(serviceWorker);
 83     ASSERT(!serviceWorker-&gt;isTerminatingOrTerminated());
 84 
 85     // FIXME: We should pass valid MessagePortChannels.
<span class="line-modified"> 86     serviceWorker-&gt;thread().postMessageToServiceWorker(WTFMove(message), WTFMove(sourceData));</span>
 87 }
 88 
 89 void SWContextManager::fireInstallEvent(ServiceWorkerIdentifier identifier)
 90 {
 91     auto* serviceWorker = m_workerMap.get(identifier);
 92     if (!serviceWorker)
 93         return;
 94 
<span class="line-modified"> 95     serviceWorker-&gt;thread().fireInstallEvent();</span>
 96 }
 97 
 98 void SWContextManager::fireActivateEvent(ServiceWorkerIdentifier identifier)
 99 {
100     auto* serviceWorker = m_workerMap.get(identifier);
101     if (!serviceWorker)
102         return;
103 
<span class="line-modified">104     serviceWorker-&gt;thread().fireActivateEvent();</span>
105 }
106 
107 void SWContextManager::terminateWorker(ServiceWorkerIdentifier identifier, Seconds timeout, Function&lt;void()&gt;&amp;&amp; completionHandler)
108 {
109     auto serviceWorker = m_workerMap.take(identifier);
110     if (!serviceWorker) {
111         if (completionHandler)
112             completionHandler();
113         return;
114     }


115 
<span class="line-modified">116     serviceWorker-&gt;setAsTerminatingOrTerminated();</span>



117 
118     m_pendingServiceWorkerTerminationRequests.add(identifier, makeUnique&lt;ServiceWorkerTerminationRequest&gt;(*this, identifier, timeout));
119 
<span class="line-modified">120     auto&amp; thread = serviceWorker-&gt;thread();</span>
<span class="line-modified">121     thread.stop([this, identifier, serviceWorker = WTFMove(serviceWorker), completionHandler = WTFMove(completionHandler)]() mutable {</span>
122         m_pendingServiceWorkerTerminationRequests.remove(identifier);
123 
124         if (auto* connection = SWContextManager::singleton().connection())
125             connection-&gt;workerTerminated(identifier);
126 
127         if (completionHandler)
128             completionHandler();
129 
130         // Spin the runloop before releasing the worker thread proxy, as there would otherwise be
131         // a race towards its destruction.
132         callOnMainThread([serviceWorker = WTFMove(serviceWorker)] { });
133     });
134 }
135 
136 void SWContextManager::forEachServiceWorkerThread(const WTF::Function&lt;void(ServiceWorkerThreadProxy&amp;)&gt;&amp; apply)
137 {
138     for (auto&amp; workerThread : m_workerMap.values())
<span class="line-modified">139         apply(*workerThread);</span>
140 }
141 
142 bool SWContextManager::postTaskToServiceWorker(ServiceWorkerIdentifier identifier, WTF::Function&lt;void(ServiceWorkerGlobalScope&amp;)&gt;&amp;&amp; task)
143 {
144     auto* serviceWorker = m_workerMap.get(identifier);
145     if (!serviceWorker)
146         return false;
147 
148     serviceWorker-&gt;thread().runLoop().postTask([task = WTFMove(task)] (auto&amp; context) {
149         task(downcast&lt;ServiceWorkerGlobalScope&gt;(context));
150     });
151     return true;
152 }
153 
154 void SWContextManager::serviceWorkerFailedToTerminate(ServiceWorkerIdentifier serviceWorkerIdentifier)
155 {
156     UNUSED_PARAM(serviceWorkerIdentifier);
157     RELEASE_LOG_ERROR(ServiceWorker, &quot;Failed to terminate service worker with identifier %s, killing the service worker process&quot;, serviceWorkerIdentifier.loggingString().utf8().data());

158     _exit(EXIT_FAILURE);
159 }
160 
161 SWContextManager::ServiceWorkerTerminationRequest::ServiceWorkerTerminationRequest(SWContextManager&amp; manager, ServiceWorkerIdentifier serviceWorkerIdentifier, Seconds timeout)
162     : m_timeoutTimer([&amp;manager, serviceWorkerIdentifier] { manager.serviceWorkerFailedToTerminate(serviceWorkerIdentifier); })
163 {
164     m_timeoutTimer.startOneShot(timeout);
165 }
166 







167 } // namespace WebCore
168 
169 #endif
</pre>
</td>
<td>
<hr />
<pre>
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SWContextManager.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 #include &quot;Logging.h&quot;
 31 #include &quot;MessageWithMessagePorts.h&quot;
 32 #include &quot;ServiceWorkerClientIdentifier.h&quot;
 33 #include &quot;ServiceWorkerGlobalScope.h&quot;
 34 
 35 namespace WebCore {
 36 
 37 SWContextManager&amp; SWContextManager::singleton()
 38 {
 39     static SWContextManager* sharedManager = new SWContextManager;
 40     return *sharedManager;
 41 }
 42 
 43 void SWContextManager::setConnection(std::unique_ptr&lt;Connection&gt;&amp;&amp; connection)
 44 {
<span class="line-modified"> 45     ASSERT(!m_connection || m_connection-&gt;isClosed());</span>
 46     m_connection = WTFMove(connection);
 47 }
 48 
 49 auto SWContextManager::connection() const -&gt; Connection*
 50 {
 51     return m_connection.get();
 52 }
 53 
 54 void SWContextManager::registerServiceWorkerThreadForInstall(Ref&lt;ServiceWorkerThreadProxy&gt;&amp;&amp; serviceWorkerThreadProxy)
 55 {
 56     auto serviceWorkerIdentifier = serviceWorkerThreadProxy-&gt;identifier();
 57     auto jobDataIdentifier = serviceWorkerThreadProxy-&gt;thread().contextData().jobDataIdentifier;
 58     auto* threadProxy = serviceWorkerThreadProxy.ptr();
 59     auto result = m_workerMap.add(serviceWorkerIdentifier, WTFMove(serviceWorkerThreadProxy));
 60     ASSERT_UNUSED(result, result.isNewEntry);
 61 
<span class="line-modified"> 62     threadProxy-&gt;thread().start([jobDataIdentifier, serviceWorkerIdentifier](const String&amp; exceptionMessage, bool doesHandleFetch) {</span>
<span class="line-modified"> 63         SWContextManager::singleton().startedServiceWorker(jobDataIdentifier, serviceWorkerIdentifier, exceptionMessage, doesHandleFetch);</span>
 64     });
 65 }
 66 
<span class="line-modified"> 67 void SWContextManager::startedServiceWorker(Optional&lt;ServiceWorkerJobDataIdentifier&gt; jobDataIdentifier, ServiceWorkerIdentifier serviceWorkerIdentifier, const String&amp; exceptionMessage, bool doesHandleFetch)</span>
 68 {

 69     if (m_serviceWorkerCreationCallback)
 70         m_serviceWorkerCreationCallback(serviceWorkerIdentifier.toUInt64());
<span class="line-added"> 71     if (!exceptionMessage.isEmpty()) {</span>
<span class="line-added"> 72         connection()-&gt;serviceWorkerFailedToStart(jobDataIdentifier, serviceWorkerIdentifier, exceptionMessage);</span>
<span class="line-added"> 73         return;</span>
<span class="line-added"> 74     }</span>
<span class="line-added"> 75     connection()-&gt;serviceWorkerStarted(jobDataIdentifier, serviceWorkerIdentifier, doesHandleFetch);</span>
 76 }
 77 
 78 ServiceWorkerThreadProxy* SWContextManager::serviceWorkerThreadProxy(ServiceWorkerIdentifier identifier) const
 79 {
 80     return m_workerMap.get(identifier);
 81 }
 82 
 83 void SWContextManager::postMessageToServiceWorker(ServiceWorkerIdentifier destination, MessageWithMessagePorts&amp;&amp; message, ServiceWorkerOrClientData&amp;&amp; sourceData)
 84 {
 85     auto* serviceWorker = m_workerMap.get(destination);
 86     ASSERT(serviceWorker);
 87     ASSERT(!serviceWorker-&gt;isTerminatingOrTerminated());
 88 
 89     // FIXME: We should pass valid MessagePortChannels.
<span class="line-modified"> 90     serviceWorker-&gt;postMessageToServiceWorker(WTFMove(message), WTFMove(sourceData));</span>
 91 }
 92 
 93 void SWContextManager::fireInstallEvent(ServiceWorkerIdentifier identifier)
 94 {
 95     auto* serviceWorker = m_workerMap.get(identifier);
 96     if (!serviceWorker)
 97         return;
 98 
<span class="line-modified"> 99     serviceWorker-&gt;fireInstallEvent();</span>
100 }
101 
102 void SWContextManager::fireActivateEvent(ServiceWorkerIdentifier identifier)
103 {
104     auto* serviceWorker = m_workerMap.get(identifier);
105     if (!serviceWorker)
106         return;
107 
<span class="line-modified">108     serviceWorker-&gt;fireActivateEvent();</span>
109 }
110 
111 void SWContextManager::terminateWorker(ServiceWorkerIdentifier identifier, Seconds timeout, Function&lt;void()&gt;&amp;&amp; completionHandler)
112 {
113     auto serviceWorker = m_workerMap.take(identifier);
114     if (!serviceWorker) {
115         if (completionHandler)
116             completionHandler();
117         return;
118     }
<span class="line-added">119     stopWorker(*serviceWorker, timeout, WTFMove(completionHandler));</span>
<span class="line-added">120 }</span>
121 
<span class="line-modified">122 void SWContextManager::stopWorker(ServiceWorkerThreadProxy&amp; serviceWorker, Seconds timeout, Function&lt;void()&gt;&amp;&amp; completionHandler)</span>
<span class="line-added">123 {</span>
<span class="line-added">124     auto identifier = serviceWorker.identifier();</span>
<span class="line-added">125     serviceWorker.setAsTerminatingOrTerminated();</span>
126 
127     m_pendingServiceWorkerTerminationRequests.add(identifier, makeUnique&lt;ServiceWorkerTerminationRequest&gt;(*this, identifier, timeout));
128 
<span class="line-modified">129     auto&amp; thread = serviceWorker.thread();</span>
<span class="line-modified">130     thread.stop([this, identifier, serviceWorker = makeRef(serviceWorker), completionHandler = WTFMove(completionHandler)]() mutable {</span>
131         m_pendingServiceWorkerTerminationRequests.remove(identifier);
132 
133         if (auto* connection = SWContextManager::singleton().connection())
134             connection-&gt;workerTerminated(identifier);
135 
136         if (completionHandler)
137             completionHandler();
138 
139         // Spin the runloop before releasing the worker thread proxy, as there would otherwise be
140         // a race towards its destruction.
141         callOnMainThread([serviceWorker = WTFMove(serviceWorker)] { });
142     });
143 }
144 
145 void SWContextManager::forEachServiceWorkerThread(const WTF::Function&lt;void(ServiceWorkerThreadProxy&amp;)&gt;&amp; apply)
146 {
147     for (auto&amp; workerThread : m_workerMap.values())
<span class="line-modified">148         apply(workerThread);</span>
149 }
150 
151 bool SWContextManager::postTaskToServiceWorker(ServiceWorkerIdentifier identifier, WTF::Function&lt;void(ServiceWorkerGlobalScope&amp;)&gt;&amp;&amp; task)
152 {
153     auto* serviceWorker = m_workerMap.get(identifier);
154     if (!serviceWorker)
155         return false;
156 
157     serviceWorker-&gt;thread().runLoop().postTask([task = WTFMove(task)] (auto&amp; context) {
158         task(downcast&lt;ServiceWorkerGlobalScope&gt;(context));
159     });
160     return true;
161 }
162 
163 void SWContextManager::serviceWorkerFailedToTerminate(ServiceWorkerIdentifier serviceWorkerIdentifier)
164 {
165     UNUSED_PARAM(serviceWorkerIdentifier);
166     RELEASE_LOG_ERROR(ServiceWorker, &quot;Failed to terminate service worker with identifier %s, killing the service worker process&quot;, serviceWorkerIdentifier.loggingString().utf8().data());
<span class="line-added">167     ASSERT_NOT_REACHED();</span>
168     _exit(EXIT_FAILURE);
169 }
170 
171 SWContextManager::ServiceWorkerTerminationRequest::ServiceWorkerTerminationRequest(SWContextManager&amp; manager, ServiceWorkerIdentifier serviceWorkerIdentifier, Seconds timeout)
172     : m_timeoutTimer([&amp;manager, serviceWorkerIdentifier] { manager.serviceWorkerFailedToTerminate(serviceWorkerIdentifier); })
173 {
174     m_timeoutTimer.startOneShot(timeout);
175 }
176 
<span class="line-added">177 void SWContextManager::stopAllServiceWorkers()</span>
<span class="line-added">178 {</span>
<span class="line-added">179     auto serviceWorkers = WTFMove(m_workerMap);</span>
<span class="line-added">180     for (auto&amp; serviceWorker : serviceWorkers.values())</span>
<span class="line-added">181         stopWorker(serviceWorker, workerTerminationTimeout, [] { });</span>
<span class="line-added">182 }</span>
<span class="line-added">183 </span>
184 } // namespace WebCore
185 
186 #endif
</pre>
</td>
</tr>
</table>
<center><a href="../ServiceWorkerTypes.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SWContextManager.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArrayBufferView.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSArrayBufferPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSArrayBufferView.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArrayBufferView.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 40,11 ***</span>
  
  const ClassInfo JSArrayBufferView::s_info = {
      &quot;ArrayBufferView&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSArrayBufferView)
  };
  
<span class="line-modified">! String JSArrayBufferView::toStringName(const JSObject*, ExecState*)</span>
  {
      return &quot;Object&quot;_s;
  }
  
  JSArrayBufferView::ConstructionContext::ConstructionContext(
<span class="line-new-header">--- 40,11 ---</span>
  
  const ClassInfo JSArrayBufferView::s_info = {
      &quot;ArrayBufferView&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSArrayBufferView)
  };
  
<span class="line-modified">! String JSArrayBufferView::toStringName(const JSObject*, JSGlobalObject*)</span>
  {
      return &quot;Object&quot;_s;
  }
  
  JSArrayBufferView::ConstructionContext::ConstructionContext(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,19 ***</span>
          visitor.addOpaqueRoot(buffer);
      }
  }
  
  bool JSArrayBufferView::put(
<span class="line-modified">!     JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value,</span>
      PutPropertySlot&amp; slot)
  {
      JSArrayBufferView* thisObject = jsCast&lt;JSArrayBufferView*&gt;(cell);
  
      if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">!         return ordinarySetSlow(exec, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode());</span>
  
<span class="line-modified">!     return Base::put(thisObject, exec, propertyName, value, slot);</span>
  }
  
  ArrayBuffer* JSArrayBufferView::unsharedBuffer()
  {
      ArrayBuffer* result = possiblySharedBuffer();
<span class="line-new-header">--- 174,19 ---</span>
          visitor.addOpaqueRoot(buffer);
      }
  }
  
  bool JSArrayBufferView::put(
<span class="line-modified">!     JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value,</span>
      PutPropertySlot&amp; slot)
  {
      JSArrayBufferView* thisObject = jsCast&lt;JSArrayBufferView*&gt;(cell);
  
      if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">!         return ordinarySetSlow(globalObject, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode());</span>
  
<span class="line-modified">!     return Base::put(thisObject, globalObject, propertyName, value, slot);</span>
  }
  
  ArrayBuffer* JSArrayBufferView::unsharedBuffer()
  {
      ArrayBuffer* result = possiblySharedBuffer();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 200,20 ***</span>
      ASSERT(thisObject-&gt;m_mode == OversizeTypedArray || thisObject-&gt;m_mode == WastefulTypedArray);
      if (thisObject-&gt;m_mode == OversizeTypedArray)
          Gigacage::free(Gigacage::Primitive, thisObject-&gt;vector());
  }
  
<span class="line-modified">! JSArrayBuffer* JSArrayBufferView::unsharedJSBuffer(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     return vm.m_typedArrayController-&gt;toJS(exec, globalObject(vm), unsharedBuffer());</span>
  }
  
<span class="line-modified">! JSArrayBuffer* JSArrayBufferView::possiblySharedJSBuffer(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     return vm.m_typedArrayController-&gt;toJS(exec, globalObject(vm), possiblySharedBuffer());</span>
  }
  
  void JSArrayBufferView::neuter()
  {
      auto locker = holdLock(cellLock());
<span class="line-new-header">--- 200,20 ---</span>
      ASSERT(thisObject-&gt;m_mode == OversizeTypedArray || thisObject-&gt;m_mode == WastefulTypedArray);
      if (thisObject-&gt;m_mode == OversizeTypedArray)
          Gigacage::free(Gigacage::Primitive, thisObject-&gt;vector());
  }
  
<span class="line-modified">! JSArrayBuffer* JSArrayBufferView::unsharedJSBuffer(JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     return vm.m_typedArrayController-&gt;toJS(globalObject, this-&gt;globalObject(vm), unsharedBuffer());</span>
  }
  
<span class="line-modified">! JSArrayBuffer* JSArrayBufferView::possiblySharedJSBuffer(JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     return vm.m_typedArrayController-&gt;toJS(globalObject, this-&gt;globalObject(vm), possiblySharedBuffer());</span>
  }
  
  void JSArrayBufferView::neuter()
  {
      auto locker = holdLock(cellLock());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 242,11 ***</span>
  ArrayBuffer* JSArrayBufferView::slowDownAndWasteMemory()
  {
      ASSERT(m_mode == FastTypedArray || m_mode == OversizeTypedArray);
  
      // We play this game because we want this to be callable even from places that
<span class="line-modified">!     // don&#39;t have access to ExecState* or the VM, and we only allocate so little</span>
      // memory here that it&#39;s not necessary to trigger a GC - just accounting what
      // we have done is good enough. The sort of bizarre exception to the &quot;allocating
      // little memory&quot; is when we transfer a backing buffer into the C heap; this
      // will temporarily get counted towards heap footprint (incorrectly, in the case
      // of adopting an oversize typed array) but we don&#39;t GC here anyway. That&#39;s
<span class="line-new-header">--- 242,11 ---</span>
  ArrayBuffer* JSArrayBufferView::slowDownAndWasteMemory()
  {
      ASSERT(m_mode == FastTypedArray || m_mode == OversizeTypedArray);
  
      // We play this game because we want this to be callable even from places that
<span class="line-modified">!     // don&#39;t have access to CallFrame* or the VM, and we only allocate so little</span>
      // memory here that it&#39;s not necessary to trigger a GC - just accounting what
      // we have done is good enough. The sort of bizarre exception to the &quot;allocating
      // little memory&quot; is when we transfer a backing buffer into the C heap; this
      // will temporarily get counted towards heap footprint (incorrectly, in the case
      // of adopting an oversize typed array) but we don&#39;t GC here anyway. That&#39;s
</pre>
<center><a href="JSArrayBufferPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSArrayBufferView.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/StochasticSpaceTimeMutatorScheduler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;StochasticSpaceTimeMutatorScheduler.h&quot;
 28 
 29 #include &quot;JSCInlines.h&quot;
 30 
 31 namespace JSC {
 32 
 33 // The scheduler will often make decisions based on state that is in flux. It will be fine so
 34 // long as multiple uses of the same value all see the same value. We wouldn&#39;t get this for free,
 35 // since our need to modularize the calculation results in a tendency to access the same mutable
 36 // field in Heap multiple times, and to access the current time multiple times.
 37 class StochasticSpaceTimeMutatorScheduler::Snapshot {
 38 public:
 39     Snapshot(StochasticSpaceTimeMutatorScheduler&amp; scheduler)
 40     {
 41         m_now = MonotonicTime::now();
 42         m_bytesAllocatedThisCycle = scheduler.bytesAllocatedThisCycleImpl();
 43     }
 44 
 45     MonotonicTime now() const { return m_now; }
 46 
 47     double bytesAllocatedThisCycle() const { return m_bytesAllocatedThisCycle; }
 48 
 49 private:
 50     MonotonicTime m_now;
 51     double m_bytesAllocatedThisCycle;
 52 };
 53 
 54 StochasticSpaceTimeMutatorScheduler::StochasticSpaceTimeMutatorScheduler(Heap&amp; heap)
 55     : m_heap(heap)
 56     , m_minimumPause(Seconds::fromMilliseconds(Options::minimumGCPauseMS()))
 57     , m_pauseScale(Options::gcPauseScale())
 58 {
 59 }
 60 
 61 StochasticSpaceTimeMutatorScheduler::~StochasticSpaceTimeMutatorScheduler()
 62 {
 63 }
 64 
 65 MutatorScheduler::State StochasticSpaceTimeMutatorScheduler::state() const
 66 {
 67     return m_state;
 68 }
 69 
 70 void StochasticSpaceTimeMutatorScheduler::beginCollection()
 71 {
 72     RELEASE_ASSERT(m_state == Normal);
 73     m_state = Stopped;
 74 
 75     m_bytesAllocatedThisCycleAtTheBeginning = m_heap.m_bytesAllocatedThisCycle;
 76     m_bytesAllocatedThisCycleAtTheEnd =
 77         Options::concurrentGCMaxHeadroom() *
 78         std::max&lt;double&gt;(m_bytesAllocatedThisCycleAtTheBeginning, m_heap.m_maxEdenSize);
 79 
 80     if (Options::logGC())
 81         dataLog(&quot;ca=&quot;, m_bytesAllocatedThisCycleAtTheBeginning / 1024, &quot;kb h=&quot;, (m_bytesAllocatedThisCycleAtTheEnd - m_bytesAllocatedThisCycleAtTheBeginning) / 1024, &quot;kb &quot;);
 82 
 83     m_beforeConstraints = MonotonicTime::now();
 84 }
 85 
 86 void StochasticSpaceTimeMutatorScheduler::didStop()
 87 {
 88     RELEASE_ASSERT(m_state == Stopped || m_state == Resumed);
 89     m_state = Stopped;
 90 }
 91 
 92 void StochasticSpaceTimeMutatorScheduler::willResume()
 93 {
 94     RELEASE_ASSERT(m_state == Stopped || m_state == Resumed);
 95     m_state = Resumed;
 96 }
 97 
 98 void StochasticSpaceTimeMutatorScheduler::didReachTermination()
 99 {
100     m_beforeConstraints = MonotonicTime::now();
101 }
102 
103 void StochasticSpaceTimeMutatorScheduler::didExecuteConstraints()
104 {
105     Snapshot snapshot(*this);
106 
107     Seconds constraintExecutionDuration = snapshot.now() - m_beforeConstraints;
108 
109     m_targetPause = std::max(
110         constraintExecutionDuration * m_pauseScale,
111         m_minimumPause);
112 
113     if (Options::logGC())
114         dataLog(&quot;tp=&quot;, m_targetPause.milliseconds(), &quot;ms &quot;);
115 
116     m_plannedResumeTime = snapshot.now() + m_targetPause;
117 }
118 
119 void StochasticSpaceTimeMutatorScheduler::synchronousDrainingDidStall()
120 {
121     Snapshot snapshot(*this);
122 
123     double resumeProbability = mutatorUtilization(snapshot);
124     if (resumeProbability &lt; Options::epsilonMutatorUtilization()) {
125         m_plannedResumeTime = MonotonicTime::infinity();
126         return;
127     }
128 
129     bool shouldResume = m_random.get() &lt; resumeProbability;
130 
131     if (shouldResume) {
132         m_plannedResumeTime = snapshot.now();
133         return;
134     }
135 
136     m_plannedResumeTime = snapshot.now() + m_targetPause;
137 }
138 
139 MonotonicTime StochasticSpaceTimeMutatorScheduler::timeToStop()
140 {
141     switch (m_state) {
142     case Normal:
143         return MonotonicTime::infinity();
144     case Stopped:
145         return MonotonicTime::now();
146     case Resumed: {
147         // Once we&#39;re running, we keep going unless we run out of headroom.
148         Snapshot snapshot(*this);
149         if (mutatorUtilization(snapshot) &lt; Options::epsilonMutatorUtilization())
150             return MonotonicTime::now();
151         return MonotonicTime::infinity();
152     } }
153 
154     RELEASE_ASSERT_NOT_REACHED();
155     return MonotonicTime();
156 }
157 
158 MonotonicTime StochasticSpaceTimeMutatorScheduler::timeToResume()
159 {
160     switch (m_state) {
161     case Normal:
162     case Resumed:
163         return MonotonicTime::now();
164     case Stopped:
165         return m_plannedResumeTime;
166     }
167 
168     RELEASE_ASSERT_NOT_REACHED();
169     return MonotonicTime();
170 }
171 
172 void StochasticSpaceTimeMutatorScheduler::log()
173 {
174     ASSERT(Options::logGC());
175     Snapshot snapshot(*this);
176     dataLog(
177         &quot;a=&quot;, format(&quot;%.0lf&quot;, bytesSinceBeginningOfCycle(snapshot) / 1024), &quot;kb &quot;,
178         &quot;hf=&quot;, format(&quot;%.3lf&quot;, headroomFullness(snapshot)), &quot; &quot;,
179         &quot;mu=&quot;, format(&quot;%.3lf&quot;, mutatorUtilization(snapshot)), &quot; &quot;);
180 }
181 
182 void StochasticSpaceTimeMutatorScheduler::endCollection()
183 {
184     m_state = Normal;
185 }
186 
187 double StochasticSpaceTimeMutatorScheduler::bytesAllocatedThisCycleImpl()
188 {
189     return m_heap.m_bytesAllocatedThisCycle;
190 }
191 
192 double StochasticSpaceTimeMutatorScheduler::bytesSinceBeginningOfCycle(const Snapshot&amp; snapshot)
193 {
194     return snapshot.bytesAllocatedThisCycle() - m_bytesAllocatedThisCycleAtTheBeginning;
195 }
196 
197 double StochasticSpaceTimeMutatorScheduler::maxHeadroom()
198 {
199     return m_bytesAllocatedThisCycleAtTheEnd - m_bytesAllocatedThisCycleAtTheBeginning;
200 }
201 
202 double StochasticSpaceTimeMutatorScheduler::headroomFullness(const Snapshot&amp; snapshot)
203 {
204     double result = bytesSinceBeginningOfCycle(snapshot) / maxHeadroom();
205 
206     // headroomFullness can be NaN and other interesting things if
207     // bytesAllocatedThisCycleAtTheBeginning is zero. We see that in debug tests. This code
208     // defends against all floating point dragons.
209 
210     if (!(result &gt;= 0))
211         result = 0;
212     if (!(result &lt;= 1))
213         result = 1;
214 
215     return result;
216 }
217 
218 double StochasticSpaceTimeMutatorScheduler::mutatorUtilization(const Snapshot&amp; snapshot)
219 {
220     double mutatorUtilization = 1 - headroomFullness(snapshot);
221 
222     // Scale the mutator utilization into the permitted window.
223     mutatorUtilization =
224         Options::minimumMutatorUtilization() +
225         mutatorUtilization * (
226             Options::maximumMutatorUtilization() -
227             Options::minimumMutatorUtilization());
228 
229     return mutatorUtilization;
230 }
231 
232 } // namespace JSC
233 
    </pre>
  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/css/FontFace.cpp b/modules/javafx.web/src/main/native/Source/WebCore/css/FontFace.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/css/FontFace.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/css/FontFace.cpp
@@ -27,18 +27,19 @@
 #include "FontFace.h"
 
 #include "CSSComputedStyleDeclaration.h"
 #include "CSSFontFaceSource.h"
 #include "CSSFontFeatureValue.h"
+#include "CSSFontSelector.h"
 #include "CSSFontStyleValue.h"
 #include "CSSParser.h"
 #include "CSSPrimitiveValueMappings.h"
 #include "CSSUnicodeRangeValue.h"
 #include "CSSValueList.h"
 #include "CSSValuePool.h"
+#include "DOMPromiseProxy.h"
 #include "Document.h"
-#include "FontVariantBuilder.h"
 #include "JSFontFace.h"
 #include "Quirks.h"
 #include "StyleProperties.h"
 #include <JavaScriptCore/ArrayBuffer.h>
 #include <JavaScriptCore/ArrayBufferView.h>
@@ -52,19 +53,28 @@
     auto source = makeUnique<CSSFontFaceSource>(fontFace, String(), nullptr, nullptr, WTFMove(arrayBufferView));
     fontFace.adoptSource(WTFMove(source));
     return false;
 }
 
-ExceptionOr<Ref<FontFace>> FontFace::create(Document& document, const String& family, Source&& source, const Descriptors& descriptors)
+void FontFace::setErrorState()
+{
+    m_loadedPromise->reject(Exception { SyntaxError });
+    m_backing->setErrorState();
+}
+
+Ref<FontFace> FontFace::create(Document& document, const String& family, Source&& source, const Descriptors& descriptors)
 {
     auto result = adoptRef(*new FontFace(document.fontSelector()));
+    result->suspendIfNeeded();
 
     bool dataRequiresAsynchronousLoading = true;
 
     auto setFamilyResult = result->setFamily(document, family);
-    if (setFamilyResult.hasException())
-        return setFamilyResult.releaseException();
+    if (setFamilyResult.hasException()) {
+        result->setErrorState();
+        return result;
+    }
 
     auto sourceConversionResult = WTF::switchOn(source,
         [&] (String& string) -> ExceptionOr<void> {
             auto value = FontFace::parseString(string, CSSPropertySrc);
             if (!is<CSSValueList>(value))
@@ -82,35 +92,46 @@
             dataRequiresAsynchronousLoading = populateFontFaceWithArrayBuffer(result->backing(), WTFMove(arrayBufferView));
             return { };
         }
     );
 
-    if (sourceConversionResult.hasException())
-        return sourceConversionResult.releaseException();
+    if (sourceConversionResult.hasException()) {
+        result->setErrorState();
+        return result;
+    }
 
     // These ternaries match the default strings inside the FontFaceDescriptors dictionary inside FontFace.idl.
     auto setStyleResult = result->setStyle(descriptors.style.isEmpty() ? "normal"_s : descriptors.style);
-    if (setStyleResult.hasException())
-        return setStyleResult.releaseException();
+    if (setStyleResult.hasException()) {
+        result->setErrorState();
+        return result;
+    }
     auto setWeightResult = result->setWeight(descriptors.weight.isEmpty() ? "normal"_s : descriptors.weight);
-    if (setWeightResult.hasException())
-        return setWeightResult.releaseException();
+    if (setWeightResult.hasException()) {
+        result->setErrorState();
+        return result;
+    }
     auto setStretchResult = result->setStretch(descriptors.stretch.isEmpty() ? "normal"_s : descriptors.stretch);
-    if (setStretchResult.hasException())
-        return setStretchResult.releaseException();
+    if (setStretchResult.hasException()) {
+        result->setErrorState();
+        return result;
+    }
     auto setUnicodeRangeResult = result->setUnicodeRange(descriptors.unicodeRange.isEmpty() ? "U+0-10FFFF"_s : descriptors.unicodeRange);
-    if (setUnicodeRangeResult.hasException())
-        return setUnicodeRangeResult.releaseException();
-    auto setVariantResult = result->setVariant(descriptors.variant.isEmpty() ? "normal"_s : descriptors.variant);
-    if (setVariantResult.hasException())
-        return setVariantResult.releaseException();
+    if (setUnicodeRangeResult.hasException()) {
+        result->setErrorState();
+        return result;
+    }
     auto setFeatureSettingsResult = result->setFeatureSettings(descriptors.featureSettings.isEmpty() ? "normal"_s : descriptors.featureSettings);
-    if (setFeatureSettingsResult.hasException())
-        return setFeatureSettingsResult.releaseException();
+    if (setFeatureSettingsResult.hasException()) {
+        result->setErrorState();
+        return result;
+    }
     auto setDisplayResult = result->setDisplay(descriptors.display.isEmpty() ? "auto"_s : descriptors.display);
-    if (setDisplayResult.hasException())
-        return setDisplayResult.releaseException();
+    if (setDisplayResult.hasException()) {
+        result->setErrorState();
+        return result;
+    }
 
     if (!dataRequiresAsynchronousLoading) {
         result->backing().load();
         auto status = result->backing().status();
         ASSERT_UNUSED(status, status == CSSFontFace::Status::Success || status == CSSFontFace::Status::Failure);
@@ -119,23 +140,27 @@
     return result;
 }
 
 Ref<FontFace> FontFace::create(CSSFontFace& face)
 {
-    return adoptRef(*new FontFace(face));
+    auto fontFace = adoptRef(*new FontFace(face));
+    fontFace->suspendIfNeeded();
+    return fontFace;
 }
 
 FontFace::FontFace(CSSFontSelector& fontSelector)
-    : m_backing(CSSFontFace::create(&fontSelector, nullptr, this))
-    , m_loadedPromise(*this, &FontFace::loadedPromiseResolve)
+    : ActiveDOMObject(fontSelector.document())
+    , m_backing(CSSFontFace::create(&fontSelector, nullptr, this))
+    , m_loadedPromise(makeUniqueRef<LoadedPromise>(*this, &FontFace::loadedPromiseResolve))
 {
     m_backing->addClient(*this);
 }
 
 FontFace::FontFace(CSSFontFace& face)
-    : m_backing(face)
-    , m_loadedPromise(*this, &FontFace::loadedPromiseResolve)
+    : ActiveDOMObject(face.document())
+    , m_backing(face)
+    , m_loadedPromise(makeUniqueRef<LoadedPromise>(*this, &FontFace::loadedPromiseResolve))
 {
     m_backing->addClient(*this);
 }
 
 FontFace::~FontFace()
@@ -215,65 +240,10 @@
     if (!success)
         return Exception { SyntaxError };
     return { };
 }
 
-ExceptionOr<void> FontFace::setVariant(const String& variant)
-{
-    if (variant.isEmpty())
-        return Exception { SyntaxError };
-
-    auto style = MutableStyleProperties::create();
-    auto result = CSSParser::parseValue(style, CSSPropertyFontVariant, variant, true, HTMLStandardMode);
-    if (result == CSSParser::ParseResult::Error)
-        return Exception { SyntaxError };
-
-    // FIXME: Would be much better to stage the new settings and set them all at once
-    // instead of this dance where we make a backup and revert to it if something fails.
-    FontVariantSettings backup = m_backing->variantSettings();
-
-    auto normal = CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
-    bool success = true;
-
-    if (auto value = style->getPropertyCSSValue(CSSPropertyFontVariantLigatures))
-        success &= m_backing->setVariantLigatures(*value);
-    else
-        m_backing->setVariantLigatures(normal);
-
-    if (auto value = style->getPropertyCSSValue(CSSPropertyFontVariantPosition))
-        success &= m_backing->setVariantPosition(*value);
-    else
-        m_backing->setVariantPosition(normal);
-
-    if (auto value = style->getPropertyCSSValue(CSSPropertyFontVariantCaps))
-        success &= m_backing->setVariantCaps(*value);
-    else
-        m_backing->setVariantCaps(normal);
-
-    if (auto value = style->getPropertyCSSValue(CSSPropertyFontVariantNumeric))
-        success &= m_backing->setVariantNumeric(*value);
-    else
-        m_backing->setVariantNumeric(normal);
-
-    if (auto value = style->getPropertyCSSValue(CSSPropertyFontVariantAlternates))
-        success &= m_backing->setVariantAlternates(*value);
-    else
-        m_backing->setVariantAlternates(normal);
-
-    if (auto value = style->getPropertyCSSValue(CSSPropertyFontVariantEastAsian))
-        success &= m_backing->setVariantEastAsian(*value);
-    else
-        m_backing->setVariantEastAsian(normal);
-
-    if (!success) {
-        m_backing->setVariantSettings(backup);
-        return Exception { SyntaxError };
-    }
-
-    return { };
-}
-
 ExceptionOr<void> FontFace::setFeatureSettings(const String& featureSettings)
 {
     if (featureSettings.isEmpty())
         return Exception { SyntaxError };
 
@@ -299,32 +269,39 @@
 
 String FontFace::family() const
 {
     m_backing->updateStyleIfNeeded();
 
+    const auto& families = m_backing->families();
+    if (!families.hasValue())
+        return "normal"_s;
+    auto familiesUnrwapped = families.value();
     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=196381 This is only here because CSSFontFace erroneously uses a list of values instead of a single value.
     // See consumeFontFamilyDescriptor() in CSSPropertyParser.cpp.
-    if (m_backing->families()->length() == 1) {
-        if (m_backing->families()->item(0)) {
-            auto& item = *m_backing->families()->item(0);
+    if (familiesUnrwapped->length() == 1) {
+        if (familiesUnrwapped->item(0)) {
+            auto& item = *familiesUnrwapped->item(0);
             if (item.isPrimitiveValue()) {
                 auto& primitiveValue = downcast<CSSPrimitiveValue>(item);
                 if (primitiveValue.isFontFamily()) {
                     auto& fontFamily = primitiveValue.fontFamily();
                     return fontFamily.familyName;
                 }
             }
         }
     }
-    return m_backing->families()->cssText();
+    return familiesUnrwapped->cssText();
 }
 
 String FontFace::style() const
 {
     m_backing->updateStyleIfNeeded();
-    auto style = m_backing->italic();
+    const auto& styleWrapped = m_backing->italic();
 
+    if (!styleWrapped.hasValue())
+        return "normal"_s;
+    auto style = styleWrapped.value();
     auto minimum = ComputedStyleExtractor::fontStyleFromStyleValue(style.minimum, FontStyleAxis::ital);
     auto maximum = ComputedStyleExtractor::fontStyleFromStyleValue(style.maximum, FontStyleAxis::ital);
 
     if (minimum.get().equals(maximum.get()))
         return minimum->cssText();
@@ -344,17 +321,20 @@
         builder.append(minimumNonKeyword->obliqueValue->cssText());
         builder.append(' ');
         builder.append(maximumNonKeyword->obliqueValue->cssText());
     }
     return builder.toString();
+
 }
 
 String FontFace::weight() const
 {
     m_backing->updateStyleIfNeeded();
-    auto weight = m_backing->weight();
-
+    const auto& weightWrapped = m_backing->weight();
+    if (!weightWrapped.hasValue())
+        return "normal"_s;
+    auto weight = weightWrapped.value();
     auto minimum = ComputedStyleExtractor::fontWeightFromStyleValue(weight.minimum);
     auto maximum = ComputedStyleExtractor::fontWeightFromStyleValue(weight.maximum);
 
     if (minimum.get().equals(maximum.get()))
         return minimum->cssText();
@@ -370,12 +350,14 @@
 }
 
 String FontFace::stretch() const
 {
     m_backing->updateStyleIfNeeded();
-    auto stretch = m_backing->stretch();
-
+    const auto& stretchWrapped = m_backing->stretch();
+    if (!stretchWrapped.hasValue())
+        return "normal"_s;
+    auto stretch = stretchWrapped.value();
     auto minimum = ComputedStyleExtractor::fontStretchFromStyleValue(stretch.minimum);
     auto maximum = ComputedStyleExtractor::fontStretchFromStyleValue(stretch.maximum);
 
     if (minimum.get().equals(maximum.get()))
         return minimum->cssText();
@@ -391,39 +373,44 @@
 }
 
 String FontFace::unicodeRange() const
 {
     m_backing->updateStyleIfNeeded();
-    if (!m_backing->ranges().size())
+    const auto& rangesWrapped = m_backing->ranges();
+    if (!rangesWrapped.hasValue())
+        return "U+0-10FFFF";
+    auto ranges = rangesWrapped.value();
+    if (!ranges.size())
         return "U+0-10FFFF"_s;
     auto values = CSSValueList::createCommaSeparated();
-    for (auto& range : m_backing->ranges())
+    for (auto& range : ranges)
         values->append(CSSUnicodeRangeValue::create(range.from, range.to));
     return values->cssText();
 }
 
-String FontFace::variant() const
-{
-    m_backing->updateStyleIfNeeded();
-    return computeFontVariant(m_backing->variantSettings())->cssText();
-}
-
 String FontFace::featureSettings() const
 {
     m_backing->updateStyleIfNeeded();
-    if (!m_backing->featureSettings().size())
+    const auto& featureSettingsWrapped = m_backing->featureSettings();
+    if (!featureSettingsWrapped.hasValue())
+        return "normal"_s;
+    auto featureSettings = featureSettingsWrapped.value();
+    if (!featureSettings.size())
         return "normal"_s;
     auto list = CSSValueList::createCommaSeparated();
-    for (auto& feature : m_backing->featureSettings())
+    for (auto& feature : featureSettings)
         list->append(CSSFontFeatureValue::create(FontTag(feature.tag()), feature.value()));
     return list->cssText();
 }
 
 String FontFace::display() const
 {
     m_backing->updateStyleIfNeeded();
-    return CSSValuePool::singleton().createValue(m_backing->loadingBehavior())->cssText();
+    const auto& loadingBehaviorWrapped = m_backing->loadingBehavior();
+    if (!loadingBehaviorWrapped.hasValue())
+        return "auto"_s;
+    return CSSValuePool::singleton().createValue(loadingBehaviorWrapped.value())->cssText();
 }
 
 auto FontFace::status() const -> LoadStatus
 {
     switch (m_backing->status()) {
@@ -453,42 +440,57 @@
 void FontFace::fontStateChanged(CSSFontFace& face, CSSFontFace::Status, CSSFontFace::Status newState)
 {
     ASSERT_UNUSED(face, &face == m_backing.ptr());
     switch (newState) {
     case CSSFontFace::Status::Loading:
-        // We still need to resolve promises when loading completes, even if all references to use have fallen out of scope.
-        ref();
         break;
     case CSSFontFace::Status::TimedOut:
         break;
     case CSSFontFace::Status::Success:
         // FIXME: This check should not be needed, but because FontFace's are sometimes adopted after they have already
         // gone through a load cycle, we can sometimes come back through here and try to resolve the promise again.
-        if (!m_loadedPromise.isFulfilled())
-            m_loadedPromise.resolve(*this);
-        deref();
+        if (!m_loadedPromise->isFulfilled())
+            m_loadedPromise->resolve(*this);
         return;
     case CSSFontFace::Status::Failure:
         // FIXME: This check should not be needed, but because FontFace's are sometimes adopted after they have already
         // gone through a load cycle, we can sometimes come back through here and try to resolve the promise again.
-        if (!m_loadedPromise.isFulfilled())
-            m_loadedPromise.reject(Exception { NetworkError });
-        deref();
+        if (!m_loadedPromise->isFulfilled())
+            m_loadedPromise->reject(Exception { NetworkError });
         return;
     case CSSFontFace::Status::Pending:
         ASSERT_NOT_REACHED();
         return;
     }
 }
 
-auto FontFace::load() -> LoadedPromise&
+auto FontFace::loadForBindings() -> LoadedPromise&
 {
+    m_mayLoadedPromiseBeScriptObservable = true;
     m_backing->load();
-    return m_loadedPromise;
+    return m_loadedPromise.get();
+}
+
+auto FontFace::loadedForBindings() -> LoadedPromise&
+{
+    m_mayLoadedPromiseBeScriptObservable = true;
+    return m_loadedPromise.get();
 }
 
 FontFace& FontFace::loadedPromiseResolve()
 {
     return *this;
 }
 
+const char* FontFace::activeDOMObjectName() const
+{
+    return "FontFace";
+}
+
+bool FontFace::hasPendingActivity() const
+{
+    if (ActiveDOMObject::hasPendingActivity())
+        return true;
+    return !isContextStopped() && m_mayLoadedPromiseBeScriptObservable && !m_loadedPromise->isFulfilled();
+}
+
 }

diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/MutationObserver.cpp b/modules/javafx.web/src/main/native/Source/WebCore/dom/MutationObserver.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/MutationObserver.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/MutationObserver.cpp
@@ -35,14 +35,14 @@
 
 #include "Document.h"
 #include "GCReachableRef.h"
 #include "HTMLSlotElement.h"
 #include "InspectorInstrumentation.h"
-#include "Microtasks.h"
 #include "MutationCallback.h"
 #include "MutationObserverRegistration.h"
 #include "MutationRecord.h"
+#include "WindowEventLoop.h"
 #include <algorithm>
 #include <wtf/IsoMallocInlines.h>
 #include <wtf/MainThread.h>
 #include <wtf/NeverDestroyed.h>
 
@@ -135,77 +135,40 @@
 {
     ASSERT(m_registrations.contains(&registration));
     m_registrations.remove(&registration);
 }
 
-typedef HashSet<RefPtr<MutationObserver>> MutationObserverSet;
-
-static MutationObserverSet& activeMutationObservers()
-{
-    static NeverDestroyed<MutationObserverSet> activeObservers;
-    return activeObservers;
-}
-
-static MutationObserverSet& suspendedMutationObservers()
-{
-    static NeverDestroyed<MutationObserverSet> suspendedObservers;
-    return suspendedObservers;
-}
-
-// https://dom.spec.whatwg.org/#signal-slot-list
-static Vector<GCReachableRef<HTMLSlotElement>>& signalSlotList()
-{
-    static NeverDestroyed<Vector<GCReachableRef<HTMLSlotElement>>> list;
-    return list;
-}
-
-static bool mutationObserverCompoundMicrotaskQueuedFlag;
-
-class MutationObserverMicrotask final : public Microtask {
-    WTF_MAKE_FAST_ALLOCATED;
-private:
-    Result run() final
-    {
-        MutationObserver::notifyMutationObservers();
-        return Result::Done;
-    }
-};
-
-static void queueMutationObserverCompoundMicrotask()
-{
-    if (mutationObserverCompoundMicrotaskQueuedFlag)
-        return;
-    mutationObserverCompoundMicrotaskQueuedFlag = true;
-    MicrotaskQueue::mainThreadQueue().append(makeUnique<MutationObserverMicrotask>());
-}
-
 void MutationObserver::enqueueMutationRecord(Ref<MutationRecord>&& mutation)
 {
     ASSERT(isMainThread());
     ASSERT(mutation->target());
+    auto document = makeRef(mutation->target()->document());
+
     m_pendingTargets.add(*mutation->target());
     m_records.append(WTFMove(mutation));
-    activeMutationObservers().add(this);
 
-    queueMutationObserverCompoundMicrotask();
+    auto eventLoop = makeRef(document->windowEventLoop());
+    eventLoop->activeMutationObservers().add(this);
+    eventLoop->queueMutationObserverCompoundMicrotask();
 }
 
 void MutationObserver::enqueueSlotChangeEvent(HTMLSlotElement& slot)
 {
     ASSERT(isMainThread());
-    ASSERT(signalSlotList().findMatching([&slot](auto& entry) { return entry.ptr() == &slot; }) == notFound);
-    signalSlotList().append(slot);
+    auto eventLoop = makeRef(slot.document().windowEventLoop());
+    auto& list = eventLoop->signalSlotList();
+    ASSERT(list.findMatching([&slot](auto& entry) { return entry.ptr() == &slot; }) == notFound);
+    list.append(slot);
 
-    queueMutationObserverCompoundMicrotask();
+    eventLoop->queueMutationObserverCompoundMicrotask();
 }
 
-void MutationObserver::setHasTransientRegistration()
+void MutationObserver::setHasTransientRegistration(Document& document)
 {
-    ASSERT(isMainThread());
-    activeMutationObservers().add(this);
-
-    queueMutationObserverCompoundMicrotask();
+    auto eventLoop = makeRef(document.windowEventLoop());
+    eventLoop->activeMutationObservers().add(this);
+    eventLoop->queueMutationObserverCompoundMicrotask();
 }
 
 HashSet<Node*> MutationObserver::observedNodes() const
 {
     HashSet<Node*> observedNodes;
@@ -248,67 +211,56 @@
     if (m_callback->hasCallback()) {
         auto* context = m_callback->scriptExecutionContext();
         if (!context)
             return;
 
-        InspectorInstrumentationCookie cookie = InspectorInstrumentation::willFireObserverCallback(*context, "MutationObserver"_s);
+        InspectorInstrumentation::willFireObserverCallback(*context, "MutationObserver"_s);
         m_callback->handleEvent(*this, records, *this);
-        InspectorInstrumentation::didFireObserverCallback(cookie);
+        InspectorInstrumentation::didFireObserverCallback(*context);
     }
 }
 
-void MutationObserver::notifyMutationObservers()
+// https://dom.spec.whatwg.org/#notify-mutation-observers
+void MutationObserver::notifyMutationObservers(WindowEventLoop& eventLoop)
 {
-    // https://dom.spec.whatwg.org/#notify-mutation-observers
-    // 1. Unset mutation observer compound microtask queued flag.
-    mutationObserverCompoundMicrotaskQueuedFlag = false;
-
-    ASSERT(isMainThread());
-    static bool deliveryInProgress = false;
-    if (deliveryInProgress)
-        return;
-    deliveryInProgress = true;
-
-    if (!suspendedMutationObservers().isEmpty()) {
-        for (auto& observer : copyToVector(suspendedMutationObservers())) {
+    if (!eventLoop.suspendedMutationObservers().isEmpty()) {
+        for (auto& observer : copyToVector(eventLoop.suspendedMutationObservers())) {
             if (!observer->canDeliver())
                 continue;
 
-            suspendedMutationObservers().remove(observer);
-            activeMutationObservers().add(observer);
+            eventLoop.suspendedMutationObservers().remove(observer);
+            eventLoop.activeMutationObservers().add(observer);
         }
     }
 
-    while (!activeMutationObservers().isEmpty() || !signalSlotList().isEmpty()) {
+    while (!eventLoop.activeMutationObservers().isEmpty() || !eventLoop.signalSlotList().isEmpty()) {
         // 2. Let notify list be a copy of unit of related similar-origin browsing contexts' list of MutationObserver objects.
-        auto notifyList = copyToVector(activeMutationObservers());
-        activeMutationObservers().clear();
+        auto notifyList = copyToVector(eventLoop.activeMutationObservers());
+        eventLoop.activeMutationObservers().clear();
         std::sort(notifyList.begin(), notifyList.end(), [](auto& lhs, auto& rhs) {
             return lhs->m_priority < rhs->m_priority;
         });
 
         // 3. Let signalList be a copy of unit of related similar-origin browsing contexts' signal slot list.
         // 4. Empty unit of related similar-origin browsing contexts' signal slot list.
         Vector<GCReachableRef<HTMLSlotElement>> slotList;
-        if (!signalSlotList().isEmpty()) {
-            slotList.swap(signalSlotList());
+        if (!eventLoop.signalSlotList().isEmpty()) {
+            slotList.swap(eventLoop.signalSlotList());
             for (auto& slot : slotList)
                 slot->didRemoveFromSignalSlotList();
         }
 
         // 5. For each MutationObserver object mo in notify list, execute a compound microtask subtask
         for (auto& observer : notifyList) {
             if (observer->canDeliver())
                 observer->deliver();
             else
-                suspendedMutationObservers().add(observer);
+                eventLoop.suspendedMutationObservers().add(observer);
         }
 
         // 6. For each slot slot in signalList, in order, fire an event named slotchange, with its bubbles attribute set to true, at slot.
         for (auto& slot : slotList)
             slot->dispatchSlotChangeEvent();
     }
-
-    deliveryInProgress = false;
 }
 
 } // namespace WebCore

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/page/SecurityPolicy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Google, Inc. (&quot;Google&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY GOOGLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;SecurityPolicy.h&quot;
 31 
 32 #include &quot;OriginAccessEntry.h&quot;
 33 #include &quot;SecurityOrigin.h&quot;
 34 #include &lt;memory&gt;
 35 #include &lt;wtf/HashMap.h&gt;
 36 #include &lt;wtf/MainThread.h&gt;
 37 #include &lt;wtf/NeverDestroyed.h&gt;
 38 #include &lt;wtf/URL.h&gt;
 39 #include &lt;wtf/text/StringHash.h&gt;
 40 
 41 namespace WebCore {
 42 
 43 static SecurityPolicy::LocalLoadPolicy localLoadPolicy = SecurityPolicy::AllowLocalLoadsForLocalOnly;
 44 
 45 typedef Vector&lt;OriginAccessEntry&gt; OriginAccessWhiteList;
 46 typedef HashMap&lt;String, std::unique_ptr&lt;OriginAccessWhiteList&gt;&gt; OriginAccessMap;
 47 
 48 static Lock originAccessMapLock;
 49 static OriginAccessMap&amp; originAccessMap()
 50 {
 51     ASSERT(originAccessMapLock.isHeld());
 52     static NeverDestroyed&lt;OriginAccessMap&gt; originAccessMap;
 53     return originAccessMap;
 54 }
 55 
 56 bool SecurityPolicy::shouldHideReferrer(const URL&amp; url, const String&amp; referrer)
 57 {
 58     bool referrerIsSecureURL = protocolIs(referrer, &quot;https&quot;);
 59     bool referrerIsWebURL = referrerIsSecureURL || protocolIs(referrer, &quot;http&quot;);
 60 
 61     if (!referrerIsWebURL)
 62         return true;
 63 
 64     if (!referrerIsSecureURL)
 65         return false;
 66 
 67     bool URLIsSecureURL = url.protocolIs(&quot;https&quot;);
 68 
 69     return !URLIsSecureURL;
 70 }
 71 
 72 String SecurityPolicy::referrerToOriginString(const String&amp; referrer)
 73 {
 74     String originString = SecurityOrigin::createFromString(referrer)-&gt;toString();
 75     if (originString == &quot;null&quot;)
 76         return String();
 77     // A security origin is not a canonical URL as it lacks a path. Add /
 78     // to turn it into a canonical URL we can use as referrer.
 79     return originString + &quot;/&quot;;
 80 }
 81 
 82 String SecurityPolicy::generateReferrerHeader(ReferrerPolicy referrerPolicy, const URL&amp; url, const String&amp; referrer)
 83 {
 84     ASSERT(referrer == URL(URL(), referrer).strippedForUseAsReferrer());
 85 
 86     if (referrer.isEmpty())
 87         return String();
 88 
 89     if (!protocolIsInHTTPFamily(referrer))
 90         return String();
 91 
 92     switch (referrerPolicy) {
 93     case ReferrerPolicy::EmptyString:
 94         ASSERT_NOT_REACHED();
 95         break;
 96     case ReferrerPolicy::NoReferrer:
 97         return String();
 98     case ReferrerPolicy::NoReferrerWhenDowngrade:
 99         break;
100     case ReferrerPolicy::SameOrigin: {
101         auto origin = SecurityOrigin::createFromString(referrer);
102         if (!origin-&gt;canRequest(url))
103             return String();
104         break;
105     }
106     case ReferrerPolicy::Origin:
107         return referrerToOriginString(referrer);
108     case ReferrerPolicy::StrictOrigin:
109         if (shouldHideReferrer(url, referrer))
110             return String();
111         return referrerToOriginString(referrer);
112     case ReferrerPolicy::OriginWhenCrossOrigin: {
113         auto origin = SecurityOrigin::createFromString(referrer);
114         if (!origin-&gt;canRequest(url))
115             return referrerToOriginString(referrer);
116         break;
117     }
118     case ReferrerPolicy::StrictOriginWhenCrossOrigin: {
119         auto origin = SecurityOrigin::createFromString(referrer);
120         if (!origin-&gt;canRequest(url)) {
121             if (shouldHideReferrer(url, referrer))
122                 return String();
123             return referrerToOriginString(referrer);
124         }
125         break;
126     }
127     case ReferrerPolicy::UnsafeUrl:
128         return referrer;
129     }
130 
131     return shouldHideReferrer(url, referrer) ? String() : referrer;
132 }
133 
134 bool SecurityPolicy::shouldInheritSecurityOriginFromOwner(const URL&amp; url)
135 {
136     // Paraphrased from &lt;https://html.spec.whatwg.org/multipage/browsers.html#origin&gt; (8 July 2016)
137     //
138     // If a Document has the address &quot;about:blank&quot;
139     //      The origin of the document is the origin it was assigned when its browsing context was created.
140     // If a Document has the address &quot;about:srcdoc&quot;
141     //      The origin of the document is the origin of its parent document.
142     //
143     // Note: We generalize this to invalid URLs because we treat such URLs as about:blank.
144     //
145     return url.isEmpty() || equalIgnoringASCIICase(url.string(), WTF::blankURL()) || equalLettersIgnoringASCIICase(url.string(), &quot;about:srcdoc&quot;);
146 }
147 
148 bool SecurityPolicy::isBaseURLSchemeAllowed(const URL&amp; url)
149 {
150     // See &lt;https://github.com/whatwg/html/issues/2249&gt;.
151     return !url.protocolIsData() &amp;&amp; !WTF::protocolIsJavaScript(url);
152 }
153 
154 void SecurityPolicy::setLocalLoadPolicy(LocalLoadPolicy policy)
155 {
156     localLoadPolicy = policy;
157 }
158 
159 bool SecurityPolicy::restrictAccessToLocal()
160 {
161     return localLoadPolicy != SecurityPolicy::AllowLocalLoadsForAll;
162 }
163 
164 bool SecurityPolicy::allowSubstituteDataAccessToLocal()
165 {
166     return localLoadPolicy != SecurityPolicy::AllowLocalLoadsForLocalOnly;
167 }
168 
169 bool SecurityPolicy::isAccessWhiteListed(const SecurityOrigin* activeOrigin, const SecurityOrigin* targetOrigin)
170 {
171     Locker&lt;Lock&gt; locker(originAccessMapLock);
172     if (OriginAccessWhiteList* list = originAccessMap().get(activeOrigin-&gt;toString())) {
173         for (auto&amp; entry : *list) {
174             if (entry.matchesOrigin(*targetOrigin))
175                 return true;
176         }
177     }
178     return false;
179 }
180 
181 bool SecurityPolicy::isAccessToURLWhiteListed(const SecurityOrigin* activeOrigin, const URL&amp; url)
182 {
183     Ref&lt;SecurityOrigin&gt; targetOrigin(SecurityOrigin::create(url));
184     return isAccessWhiteListed(activeOrigin, &amp;targetOrigin.get());
185 }
186 
187 void SecurityPolicy::addOriginAccessWhitelistEntry(const SecurityOrigin&amp; sourceOrigin, const String&amp; destinationProtocol, const String&amp; destinationDomain, bool allowDestinationSubdomains)
188 {
189     ASSERT(!sourceOrigin.isUnique());
190     if (sourceOrigin.isUnique())
191         return;
192 
193     String sourceString = sourceOrigin.toString();
194 
195     Locker&lt;Lock&gt; locker(originAccessMapLock);
196     OriginAccessMap::AddResult result = originAccessMap().add(sourceString, nullptr);
197     if (result.isNewEntry)
198         result.iterator-&gt;value = makeUnique&lt;OriginAccessWhiteList&gt;();
199 
200     OriginAccessWhiteList* list = result.iterator-&gt;value.get();
201     list-&gt;append(OriginAccessEntry(destinationProtocol, destinationDomain, allowDestinationSubdomains ? OriginAccessEntry::AllowSubdomains : OriginAccessEntry::DisallowSubdomains, OriginAccessEntry::TreatIPAddressAsIPAddress));
202 }
203 
204 void SecurityPolicy::removeOriginAccessWhitelistEntry(const SecurityOrigin&amp; sourceOrigin, const String&amp; destinationProtocol, const String&amp; destinationDomain, bool allowDestinationSubdomains)
205 {
206     ASSERT(!sourceOrigin.isUnique());
207     if (sourceOrigin.isUnique())
208         return;
209 
210     String sourceString = sourceOrigin.toString();
211 
212     Locker&lt;Lock&gt; locker(originAccessMapLock);
213     OriginAccessMap&amp; map = originAccessMap();
214     OriginAccessMap::iterator it = map.find(sourceString);
215     if (it == map.end())
216         return;
217 
218     OriginAccessWhiteList&amp; list = *it-&gt;value;
219     OriginAccessEntry originAccessEntry(destinationProtocol, destinationDomain, allowDestinationSubdomains ? OriginAccessEntry::AllowSubdomains : OriginAccessEntry::DisallowSubdomains, OriginAccessEntry::TreatIPAddressAsIPAddress);
220     if (!list.removeFirst(originAccessEntry))
221         return;
222 
223     if (list.isEmpty())
224         map.remove(it);
225 }
226 
227 void SecurityPolicy::resetOriginAccessWhitelists()
228 {
229     Locker&lt;Lock&gt; locker(originAccessMapLock);
230     originAccessMap().clear();
231 }
232 
233 } // namespace WebCore
    </pre>
  </body>
</html>
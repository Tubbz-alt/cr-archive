<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGL2RenderingContext.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(WEBGL2)
 29 
 30 #include &quot;WebGLRenderingContextBase.h&quot;
 31 #include &lt;memory&gt;
 32 
 33 namespace WebCore {
 34 
 35 class WebGLQuery;
 36 class WebGLSampler;
 37 class WebGLSync;
 38 class WebGLTransformFeedback;
 39 class WebGLVertexArrayObject;
 40 
 41 class WebGL2RenderingContext final : public WebGLRenderingContextBase {
 42     WTF_MAKE_ISO_ALLOCATED(WebGL2RenderingContext);
 43 public:
 44     static std::unique_ptr&lt;WebGL2RenderingContext&gt; create(CanvasBase&amp;, GraphicsContextGLAttributes);
 45     static std::unique_ptr&lt;WebGL2RenderingContext&gt; create(CanvasBase&amp;, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp;, GraphicsContextGLAttributes);
 46 
 47     ~WebGL2RenderingContext();
 48 
 49     // Buffer objects
 50     using WebGLRenderingContextBase::bufferData;
 51     using WebGLRenderingContextBase::bufferSubData;
 52     void bufferData(GCGLenum target, const ArrayBufferView&amp; data, GCGLenum usage, GCGLuint srcOffset, GCGLuint length);
 53     void bufferSubData(GCGLenum target, long long offset, const ArrayBufferView&amp; data, GCGLuint srcOffset, GCGLuint length);
 54     void copyBufferSubData(GCGLenum readTarget, GCGLenum writeTarget, GCGLint64 readOffset, GCGLint64 writeOffset, GCGLint64 size);
 55     void getBufferSubData(GCGLenum target, long long srcByteOffset, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; dstData, GCGLuint dstOffset = 0, GCGLuint length = 0);
 56 
 57     // Framebuffer objects
 58     WebGLAny getFramebufferAttachmentParameter(GCGLenum target, GCGLenum attachment, GCGLenum pname) final;
 59     void blitFramebuffer(GCGLint srcX0, GCGLint srcY0, GCGLint srcX1, GCGLint srcY1, GCGLint dstX0, GCGLint dstY0, GCGLint dstX1, GCGLint dstY1, GCGLbitfield mask, GCGLenum filter);
 60     void framebufferTextureLayer(GCGLenum target, GCGLenum attachment, WebGLTexture*, GCGLint level, GCGLint layer);
 61     WebGLAny getInternalformatParameter(GCGLenum target, GCGLenum internalformat, GCGLenum pname);
 62     void invalidateFramebuffer(GCGLenum target, const Vector&lt;GCGLenum&gt;&amp; attachments);
 63     void invalidateSubFramebuffer(GCGLenum target, const Vector&lt;GCGLenum&gt;&amp; attachments, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height);
 64     void readBuffer(GCGLenum src);
 65 
 66     // Renderbuffer objects
 67     void renderbufferStorageMultisample(GCGLenum target, GCGLsizei samples, GCGLenum internalformat, GCGLsizei width, GCGLsizei height);
 68 
 69     // Texture objects
 70     void texStorage2D(GCGLenum target, GCGLsizei levels, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height);
 71     void texStorage3D(GCGLenum target, GCGLsizei levels, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLsizei depth);
 72 
 73 #if ENABLE(VIDEO)
 74     using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;, RefPtr&lt;HTMLVideoElement&gt;&gt;;
 75 #else
 76     using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;&gt;;
 77 #endif
 78 
 79     using WebGLRenderingContextBase::texImage2D;
 80     void texImage2D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, GCGLintptr offset);
 81     ExceptionOr&lt;void&gt; texImage2D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, TexImageSource&amp;&amp;);
 82     void texImage2D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; srcData, GCGLuint srcOffset);
 83 
 84     void texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, GCGLint64 pboOffset);
 85     ExceptionOr&lt;void&gt; texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, TexImageSource&amp;&amp;);
 86     void texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels);
 87     void texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; srcData, GCGLuint srcOffset);
 88 
 89     using WebGLRenderingContextBase::texSubImage2D;
 90     void texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, GCGLintptr pboOffset);
 91     ExceptionOr&lt;void&gt; texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, TexImageSource&amp;&amp;);
 92     void texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; srcData, GCGLuint srcOffset);
 93 
 94     void texSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLenum type, GCGLint64 pboOffset);
 95     void texSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels, GCGLuint srcOffset);
 96     ExceptionOr&lt;void&gt; texSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLenum type, TexImageSource&amp;&amp;);
 97 
 98     void copyTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height);
 99 
100     using WebGLRenderingContextBase::compressedTexImage2D;
101     void compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLsizei imageSize, GCGLint64 offset);
102     void compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, ArrayBufferView&amp; data, GCGLuint srcOffset, GCGLuint srcLengthOverride);
103     void compressedTexImage3D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLsizei imageSize, GCGLint64 offset);
104     void compressedTexImage3D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, ArrayBufferView&amp; srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride);
105 
106     using WebGLRenderingContextBase::compressedTexSubImage2D;
107     void compressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, GLintptr offset);
108     void compressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, ArrayBufferView&amp; srcData, GLuint srcOffset, GLuint srcLengthOverride);
109 
110     void compressedTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLsizei imageSize, GCGLint64 offset);
111     void compressedTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, ArrayBufferView&amp; data, GCGLuint srcOffset, GCGLuint srcLengthOverride);
112 
113     // Programs and shaders
114     GCGLint getFragDataLocation(WebGLProgram&amp;, const String&amp; name);
115 
116     // Uniforms and attributes
117     using Uint32List = TypedList&lt;Uint32Array, uint32_t&gt;;
118     using Float32List = TypedList&lt;Float32Array, float&gt;;
119     void uniform1ui(WebGLUniformLocation*, GCGLuint v0);
120     void uniform2ui(WebGLUniformLocation*, GCGLuint v0, GCGLuint v1);
121     void uniform3ui(WebGLUniformLocation*, GCGLuint v0, GCGLuint v1, GCGLuint v2);
122     void uniform4ui(WebGLUniformLocation*, GCGLuint v0, GCGLuint v1, GCGLuint v2, GCGLuint v3);
123     void uniform1uiv(WebGLUniformLocation*, Uint32List&amp;&amp; data, GCGLuint srcOffset, GCGLuint srcLength);
124     void uniform2uiv(WebGLUniformLocation*, Uint32List&amp;&amp; data, GCGLuint srcOffset, GCGLuint srcLength);
125     void uniform3uiv(WebGLUniformLocation*, Uint32List&amp;&amp; data, GCGLuint srcOffset, GCGLuint srcLength);
126     void uniform4uiv(WebGLUniformLocation*, Uint32List&amp;&amp; data, GCGLuint srcOffset, GCGLuint srcLength);
127     void uniformMatrix2x3fv(WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp; value, GCGLuint srcOffset, GCGLuint srcLength);
128     void uniformMatrix3x2fv(WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp; value, GCGLuint srcOffset, GCGLuint srcLength);
129     void uniformMatrix2x4fv(WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp; value, GCGLuint srcOffset, GCGLuint srcLength);
130     void uniformMatrix4x2fv(WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp; value, GCGLuint srcOffset, GCGLuint srcLength);
131     void uniformMatrix3x4fv(WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp; value, GCGLuint srcOffset, GCGLuint srcLength);
132     void uniformMatrix4x3fv(WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp; value, GCGLuint srcOffset, GCGLuint srcLength);
133     void vertexAttribI4i(GCGLuint index, GCGLint x, GCGLint y, GCGLint z, GCGLint w);
134     void vertexAttribI4iv(GCGLuint index, Int32List&amp;&amp; v);
135     void vertexAttribI4ui(GCGLuint index, GCGLuint x, GCGLuint y, GCGLuint z, GCGLuint w);
136     void vertexAttribI4uiv(GCGLuint index, Uint32List&amp;&amp; v);
137     void vertexAttribIPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLsizei stride, GCGLint64 offset);
138 
139     using WebGLRenderingContextBase::uniform1fv;
140     using WebGLRenderingContextBase::uniform2fv;
141     using WebGLRenderingContextBase::uniform3fv;
142     using WebGLRenderingContextBase::uniform4fv;
143     void uniform1fv(WebGLUniformLocation* location, Float32List data, GLuint srcOffset, GLuint srcLength);
144     void uniform2fv(WebGLUniformLocation* location, Float32List data, GLuint srcOffset, GLuint srcLength);
145     void uniform3fv(WebGLUniformLocation* location, Float32List data, GLuint srcOffset, GLuint srcLength);
146     void uniform4fv(WebGLUniformLocation* location, Float32List data, GLuint srcOffset, GLuint srcLength);
147 
148     using WebGLRenderingContextBase::uniform1iv;
149     using WebGLRenderingContextBase::uniform2iv;
150     using WebGLRenderingContextBase::uniform3iv;
151     using WebGLRenderingContextBase::uniform4iv;
152     void uniform1iv(WebGLUniformLocation* location, Int32List data, GLuint srcOffset, GLuint srcLength);
153     void uniform2iv(WebGLUniformLocation* location, Int32List data, GLuint srcOffset, GLuint srcLength);
154     void uniform3iv(WebGLUniformLocation* location, Int32List data, GLuint srcOffset, GLuint srcLength);
155     void uniform4iv(WebGLUniformLocation* location, Int32List data, GLuint srcOffset, GLuint srcLength);
156 
157     using WebGLRenderingContextBase::uniformMatrix2fv;
158     using WebGLRenderingContextBase::uniformMatrix3fv;
159     using WebGLRenderingContextBase::uniformMatrix4fv;
160     void uniformMatrix2fv(WebGLUniformLocation* location, GLboolean transpose, Float32List data, GLuint srcOffset, GLuint srcLength);
161     void uniformMatrix3fv(WebGLUniformLocation* location, GLboolean transpose, Float32List data, GLuint srcOffset, GLuint srcLength);
162     void uniformMatrix4fv(WebGLUniformLocation* location, GLboolean transpose, Float32List data, GLuint srcOffset, GLuint srcLength);
163 
164     // Writing to the drawing buffer
165     void clear(GCGLbitfield mask) final;
166     void vertexAttribDivisor(GCGLuint index, GCGLuint divisor);
167     void drawArraysInstanced(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei instanceCount);
168     void drawElementsInstanced(GCGLenum mode, GCGLsizei count, GCGLenum type, GCGLint64 offset, GCGLsizei instanceCount);
169     void drawRangeElements(GCGLenum mode, GCGLuint start, GCGLuint end, GCGLsizei count, GCGLenum type, GCGLint64 offset);
170 
171     // Multiple render targets
172     void drawBuffers(const Vector&lt;GCGLenum&gt;&amp; buffers);
173     void clearBufferiv(GCGLenum buffer, GCGLint drawbuffer, Int32List&amp;&amp; values, GCGLuint srcOffset);
174     void clearBufferuiv(GCGLenum buffer, GCGLint drawbuffer, Uint32List&amp;&amp; values, GCGLuint srcOffset);
175     void clearBufferfv(GCGLenum buffer, GCGLint drawbuffer, Float32List&amp;&amp; values, GCGLuint srcOffset);
176     void clearBufferfi(GCGLenum buffer, GCGLint drawbuffer, GCGLfloat depth, GCGLint stencil);
177 
178     // Query objects
179     RefPtr&lt;WebGLQuery&gt; createQuery();
180     void deleteQuery(WebGLQuery*);
181     GCGLboolean isQuery(WebGLQuery*);
182     void beginQuery(GCGLenum target, WebGLQuery&amp;);
183     void endQuery(GCGLenum target);
184     RefPtr&lt;WebGLQuery&gt; getQuery(GCGLenum target, GCGLenum pname);
185     WebGLAny getQueryParameter(WebGLQuery&amp;, GCGLenum pname);
186 
187     // Sampler objects
188     RefPtr&lt;WebGLSampler&gt; createSampler();
189     void deleteSampler(WebGLSampler*);
190     GCGLboolean isSampler(WebGLSampler*);
191     void bindSampler(GCGLuint unit, WebGLSampler*);
192     void samplerParameteri(WebGLSampler&amp;, GCGLenum pname, GCGLint param);
193     void samplerParameterf(WebGLSampler&amp;, GCGLenum pname, GCGLfloat param);
194     WebGLAny getSamplerParameter(WebGLSampler&amp;, GCGLenum pname);
195 
196     // Sync objects
197     RefPtr&lt;WebGLSync&gt; fenceSync(GCGLenum condition, GCGLbitfield flags);
198     GCGLboolean isSync(WebGLSync*);
199     void deleteSync(WebGLSync*);
200     GCGLenum clientWaitSync(WebGLSync&amp;, GCGLbitfield flags, GCGLuint64 timeout);
201     void waitSync(WebGLSync&amp;, GCGLbitfield flags, GCGLint64 timeout);
202     WebGLAny getSyncParameter(WebGLSync&amp;, GCGLenum pname);
203 
204     // Transform feedback
205     RefPtr&lt;WebGLTransformFeedback&gt; createTransformFeedback();
206     void deleteTransformFeedback(WebGLTransformFeedback* id);
207     GCGLboolean isTransformFeedback(WebGLTransformFeedback* id);
208     void bindTransformFeedback(GCGLenum target, WebGLTransformFeedback* id);
209     void beginTransformFeedback(GCGLenum primitiveMode);
210     void endTransformFeedback();
211     void transformFeedbackVaryings(WebGLProgram&amp;, const Vector&lt;String&gt;&amp; varyings, GCGLenum bufferMode);
212     RefPtr&lt;WebGLActiveInfo&gt; getTransformFeedbackVarying(WebGLProgram&amp;, GCGLuint index);
213     void pauseTransformFeedback();
214     void resumeTransformFeedback();
215 
216     // Uniform buffer objects and transform feedback buffers
217     void bindBufferBase(GCGLenum target, GCGLuint index, WebGLBuffer*);
218     void bindBufferRange(GCGLenum target, GCGLuint index, WebGLBuffer*, GCGLint64 offset, GCGLint64 size);
219     WebGLAny getIndexedParameter(GCGLenum target, GCGLuint index);
220     Optional&lt;Vector&lt;GCGLuint&gt;&gt; getUniformIndices(WebGLProgram&amp;, const Vector&lt;String&gt;&amp; uniformNames);
221     WebGLAny getActiveUniforms(WebGLProgram&amp;, const Vector&lt;GCGLuint&gt;&amp; uniformIndices, GCGLenum pname);
222     GCGLuint getUniformBlockIndex(WebGLProgram&amp;, const String&amp; uniformBlockName);
223     WebGLAny getActiveUniformBlockParameter(WebGLProgram&amp;, GCGLuint uniformBlockIndex, GCGLenum pname);
224     WebGLAny getActiveUniformBlockName(WebGLProgram&amp;, GCGLuint uniformBlockIndex);
225     void uniformBlockBinding(WebGLProgram&amp;, GCGLuint uniformBlockIndex, GCGLuint uniformBlockBinding);
226 
227     // Vertex array objects
228     RefPtr&lt;WebGLVertexArrayObject&gt; createVertexArray();
229     void deleteVertexArray(WebGLVertexArrayObject* vertexArray);
230     GCGLboolean isVertexArray(WebGLVertexArrayObject* vertexArray);
231     void bindVertexArray(WebGLVertexArrayObject* vertexArray);
232 
233     WebGLExtension* getExtension(const String&amp;) final;
234     Optional&lt;Vector&lt;String&gt;&gt; getSupportedExtensions() final;
235     WebGLAny getParameter(GCGLenum pname) final;
236 
237     using WebGLRenderingContextBase::readPixels;
238     void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLintptr offset);
239     void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, ArrayBufferView&amp; dstData, GLuint dstOffset);
240 
241     void renderbufferStorage(GCGLenum target, GCGLenum internalformat, GCGLsizei width, GCGLsizei height) final;
242     void hint(GCGLenum target, GCGLenum mode) final;
243 
244 private:
245     WebGL2RenderingContext(CanvasBase&amp;, GraphicsContextGLAttributes);
246     WebGL2RenderingContext(CanvasBase&amp;, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp;, GraphicsContextGLAttributes);
247 
248     bool isWebGL2() const final { return true; }
249 
250     RefPtr&lt;ArrayBufferView&gt; arrayBufferViewSliceFactory(const char* const functionName, const ArrayBufferView&amp; data, unsigned startByte, unsigned bytelength);
251     RefPtr&lt;ArrayBufferView&gt; sliceArrayBufferView(const char* const functionName, const ArrayBufferView&amp; data, GCGLuint srcOffset, GCGLuint length);
252     RefPtr&lt;ArrayBufferView&gt; sliceTypedArrayBufferView(const char* const functionName, RefPtr&lt;ArrayBufferView&gt;&amp;, GCGLuint);
253 
254     void initializeVertexArrayObjects() final;
255     GCGLint getMaxDrawBuffers() final;
256     GCGLint getMaxColorAttachments() final;
257     bool validateIndexArrayConservative(GCGLenum type, unsigned&amp; numElementsRequired) final;
258     bool validateBlendEquation(const char* functionName, GCGLenum mode) final;
259     bool validateCapability(const char* functionName, GCGLenum cap) final;
260     bool validateFramebufferFuncParameters(const char* functionName, GCGLenum target, GCGLenum attachment) final;
261     bool validateFramebufferTarget(const char* functionName, GCGLenum target);
262     bool validateNonDefaultFramebufferAttachment(const char* functionName, GCGLenum attachment);
263 
264     GCGLenum baseInternalFormatFromInternalFormat(GCGLenum internalformat);
265     bool isIntegerFormat(GCGLenum internalformat);
266     void initializeShaderExtensions();
267     void initializeTransformFeedbackBufferCache();
268     void initializeSamplerCache();
269 
270     bool validateTexStorageFuncParameters(GCGLenum target, GCGLsizei levels, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, const char* functionName);
271 
272     void uncacheDeletedBuffer(WebGLBuffer*) final;
273 
274     RefPtr&lt;WebGLTransformFeedback&gt; m_boundTransformFeedback;
275     Vector&lt;RefPtr&lt;WebGLBuffer&gt;&gt; m_boundTransformFeedbackBuffers;
276 
277     HashMap&lt;GCGLenum, RefPtr&lt;WebGLQuery&gt;&gt; m_activeQueries;
278 
279     Vector&lt;RefPtr&lt;WebGLSampler&gt;&gt; m_boundSamplers;
280 };
281 
282 } // namespace WebCore
283 
284 SPECIALIZE_TYPE_TRAITS_CANVASRENDERINGCONTEXT(WebCore::WebGL2RenderingContext, isWebGL2())
285 
286 #endif // WEBGL2
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperShaderProgram.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies)
  3  Copyright (C) 2012 Igalia S.L.
  4  Copyright (C) 2011 Google Inc. All rights reserved.
  5 
  6  This library is free software; you can redistribute it and/or
  7  modify it under the terms of the GNU Library General Public
  8  License as published by the Free Software Foundation; either
  9  version 2 of the License, or (at your option) any later version.
 10 
 11  This library is distributed in the hope that it will be useful,
 12  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  Library General Public License for more details.
 15 
 16  You should have received a copy of the GNU Library General Public License
 17  along with this library; see the file COPYING.LIB.  If not, write to
 18  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;TextureMapperShaderProgram.h&quot;
 24 
 25 #if USE(TEXTURE_MAPPER_GL)
 26 
 27 #include &quot;GLContext.h&quot;
 28 #include &quot;Logging.h&quot;
 29 #include &quot;TextureMapperGL.h&quot;
 30 #include &lt;wtf/text/StringBuilder.h&gt;
 31 
 32 namespace WebCore {
 33 
 34 static inline bool compositingLogEnabled()
 35 {
 36 #if !LOG_DISABLED
 37     return LogCompositing.state == WTFLogChannelState::On;
 38 #else
 39     return false;
 40 #endif
 41 }
 42 
 43 #define STRINGIFY(...) #__VA_ARGS__
 44 
 45 #define GLSL_DIRECTIVE(...) &quot;#&quot;#__VA_ARGS__&quot;\n&quot;
 46 
 47 #define TEXTURE_SPACE_MATRIX_PRECISION_DIRECTIVE \
 48     GLSL_DIRECTIVE(ifdef GL_FRAGMENT_PRECISION_HIGH) \
 49         GLSL_DIRECTIVE(define TextureSpaceMatrixPrecision highp) \
 50     GLSL_DIRECTIVE(else) \
 51         GLSL_DIRECTIVE(define TextureSpaceMatrixPrecision mediump) \
 52     GLSL_DIRECTIVE(endif)
 53 
 54 
 55 // Input/output variables definition for both GLES and OpenGL &lt; 3.2.
 56 // The default precision directive is only needed for GLES.
 57 static const char* vertexTemplateLT320Vars =
 58 #if USE(OPENGL_ES)
 59     TEXTURE_SPACE_MATRIX_PRECISION_DIRECTIVE
 60 #endif
 61 #if USE(OPENGL_ES)
 62     STRINGIFY(
 63         precision TextureSpaceMatrixPrecision float;
 64     )
 65 #endif
 66     STRINGIFY(
 67         attribute vec4 a_vertex;
 68         varying vec2 v_texCoord;
 69         varying vec2 v_transformedTexCoord;
 70         varying float v_antialias;
 71     );
 72 
 73 #if !USE(OPENGL_ES)
 74 // Input/output variables definition for OpenGL &gt;= 3.2.
 75 static const char* vertexTemplateGE320Vars =
 76     STRINGIFY(
 77         in vec4 a_vertex;
 78         out vec2 v_texCoord;
 79         out vec2 v_transformedTexCoord;
 80         out float v_antialias;
 81     );
 82 #endif
 83 
 84 static const char* vertexTemplateCommon =
 85     STRINGIFY(
 86         uniform mat4 u_modelViewMatrix;
 87         uniform mat4 u_projectionMatrix;
 88         uniform mat4 u_textureSpaceMatrix;
 89 
 90         void noop(inout vec2 dummyParameter) { }
 91 
 92         vec4 toViewportSpace(vec2 pos) { return vec4(pos, 0., 1.) * u_modelViewMatrix; }
 93 
 94         // This function relies on the assumption that we get edge triangles with control points,
 95         // a control point being the nearest point to the coordinate that is on the edge.
 96         void applyAntialiasing(inout vec2 position)
 97         {
 98             // We count on the fact that quad passed in is always a unit rect,
 99             // and the transformation matrix applies the real rect.
100             const vec2 center = vec2(0.5, 0.5);
101             const float antialiasInflationDistance = 1.;
102 
103             // We pass the control point as the zw coordinates of the vertex.
104             // The control point is the point on the edge closest to the current position.
105             // The control point is used to compute the antialias value.
106             vec2 controlPoint = a_vertex.zw;
107 
108             // First we calculate the distance in viewport space.
109             vec4 centerInViewportCoordinates = toViewportSpace(center);
110             vec4 controlPointInViewportCoordinates = toViewportSpace(controlPoint);
111             float viewportSpaceDistance = distance(centerInViewportCoordinates, controlPointInViewportCoordinates);
112 
113             // We add the inflation distance to the computed distance, and compute the ratio.
114             float inflationRatio = (viewportSpaceDistance + antialiasInflationDistance) / viewportSpaceDistance;
115 
116             // v_antialias needs to be 0 for the outer edge and 1. for the inner edge.
117             // Since the controlPoint is equal to the position in the edge vertices, the value is always 0 for those.
118             // For the center point, the distance is always 0.5, so we normalize to 1. by multiplying by 2.
119             // By multplying by inflationRatio and dividing by (inflationRatio - 1),
120             // We make sure that the varying interpolates between 0 (outer edge), 1 (inner edge) and n &gt; 1 (center).
121             v_antialias = distance(controlPoint, position) * 2. * inflationRatio / (inflationRatio - 1.);
122 
123             // Now inflate the actual position. By using this formula instead of inflating position directly,
124             // we ensure that the center vertex is never inflated.
125             position = center + (position - center) * inflationRatio;
126         }
127 
128         void main(void)
129         {
130             vec2 position = a_vertex.xy;
131             applyAntialiasingIfNeeded(position);
132 
133             v_texCoord = position;
134             vec4 clampedPosition = clamp(vec4(position, 0., 1.), 0., 1.);
135             v_transformedTexCoord = (u_textureSpaceMatrix * clampedPosition).xy;
136             gl_Position = u_projectionMatrix * u_modelViewMatrix * vec4(position, 0., 1.);
137         }
138     );
139 
140 #define RECT_TEXTURE_DIRECTIVE \
141     GLSL_DIRECTIVE(ifdef ENABLE_Rect) \
142         GLSL_DIRECTIVE(define SamplerType sampler2DRect) \
143         GLSL_DIRECTIVE(define SamplerFunction texture2DRect) \
144     GLSL_DIRECTIVE(else) \
145         GLSL_DIRECTIVE(define SamplerType sampler2D) \
146         GLSL_DIRECTIVE(define SamplerFunction texture2D) \
147     GLSL_DIRECTIVE(endif)
148 
149 #define ANTIALIASING_TEX_COORD_DIRECTIVE \
150     GLSL_DIRECTIVE(if defined(ENABLE_Antialiasing) &amp;&amp; defined(ENABLE_Texture)) \
151         GLSL_DIRECTIVE(define transformTexCoord fragmentTransformTexCoord) \
152     GLSL_DIRECTIVE(else) \
153         GLSL_DIRECTIVE(define transformTexCoord vertexTransformTexCoord) \
154     GLSL_DIRECTIVE(endif)
155 
156 #define ENABLE_APPLIER(Name) &quot;#define ENABLE_&quot;#Name&quot;\n#define apply&quot;#Name&quot;IfNeeded apply&quot;#Name&quot;\n&quot;
157 #define DISABLE_APPLIER(Name) &quot;#define apply&quot;#Name&quot;IfNeeded noop\n&quot;
158 #define BLUR_CONSTANTS \
159     GLSL_DIRECTIVE(define GAUSSIAN_KERNEL_HALF_WIDTH 11) \
160     GLSL_DIRECTIVE(define GAUSSIAN_KERNEL_STEP 0.2)
161 
162 
163 #define OES_EGL_IMAGE_EXTERNAL_DIRECTIVE \
164     GLSL_DIRECTIVE(ifdef ENABLE_TextureExternalOES) \
165         GLSL_DIRECTIVE(extension GL_OES_EGL_image_external : require) \
166         GLSL_DIRECTIVE(define SamplerExternalOESType samplerExternalOES) \
167     GLSL_DIRECTIVE(else) \
168         GLSL_DIRECTIVE(define SamplerExternalOESType sampler2D) \
169     GLSL_DIRECTIVE(endif)
170 
171 // Common header for all versions. We define the matrices variables here to keep the precision
172 // directives scope: the first one applies to the matrices variables and the next one to the
173 // rest of them. The precision is only used in GLES.
174 static const char* fragmentTemplateHeaderCommon =
175     RECT_TEXTURE_DIRECTIVE
176     ANTIALIASING_TEX_COORD_DIRECTIVE
177     BLUR_CONSTANTS
178     OES_EGL_IMAGE_EXTERNAL_DIRECTIVE
179 #if USE(OPENGL_ES)
180     TEXTURE_SPACE_MATRIX_PRECISION_DIRECTIVE
181     STRINGIFY(
182         precision TextureSpaceMatrixPrecision float;
183     )
184 #endif
185     STRINGIFY(
186         uniform mat4 u_textureSpaceMatrix;
187         uniform mat4 u_textureColorSpaceMatrix;
188     )
189 #if USE(OPENGL_ES)
190     STRINGIFY(
191         precision mediump float;
192     )
193 #endif
194     ;
195 
196 // Input/output variables definition for both GLES and OpenGL &lt; 3.2.
197 static const char* fragmentTemplateLT320Vars =
198     STRINGIFY(
199         varying float v_antialias;
200         varying vec2 v_texCoord;
201         varying vec2 v_transformedTexCoord;
202     );
203 
204 #if !USE(OPENGL_ES)
205 // Input/output variables definition for OpenGL &gt;= 3.2.
206 static const char* fragmentTemplateGE320Vars =
207     STRINGIFY(
208         in float v_antialias;
209         in vec2 v_texCoord;
210         in vec2 v_transformedTexCoord;
211     );
212 #endif
213 
214 static const char* fragmentTemplateCommon =
215     STRINGIFY(
216         uniform SamplerType s_sampler;
217         uniform SamplerType s_samplerY;
218         uniform SamplerType s_samplerU;
219         uniform SamplerType s_samplerV;
220         uniform sampler2D s_contentTexture;
221         uniform SamplerExternalOESType s_externalOESTexture;
222         uniform float u_opacity;
223         uniform float u_filterAmount;
224         uniform mat3 u_yuvToRgb;
225         uniform vec2 u_blurRadius;
226         uniform vec2 u_shadowOffset;
227         uniform vec4 u_color;
228         uniform float u_gaussianKernel[GAUSSIAN_KERNEL_HALF_WIDTH];
229 
230         void noop(inout vec4 dummyParameter) { }
231         void noop(inout vec4 dummyParameter, vec2 texCoord) { }
232         void noop(inout vec2 dummyParameter) { }
233 
234         float antialias() { return smoothstep(0., 1., v_antialias); }
235 
236         vec2 fragmentTransformTexCoord()
237         {
238             vec4 clampedPosition = clamp(vec4(v_texCoord, 0., 1.), 0., 1.);
239             return (u_textureSpaceMatrix * clampedPosition).xy;
240         }
241 
242         vec2 vertexTransformTexCoord() { return v_transformedTexCoord; }
243 
244         void applyManualRepeat(inout vec2 pos) { pos = fract(pos); }
245 
246         void applyTextureRGB(inout vec4 color, vec2 texCoord) { color = u_textureColorSpaceMatrix * SamplerFunction(s_sampler, texCoord); }
247 
248         vec3 yuvToRgb(float y, float u, float v)
249         {
250             // yuv is either bt601 or bt709 so the offset is the same
251             vec3 yuv = vec3(y - 0.0625, u - 0.5, v - 0.5);
252             return yuv * u_yuvToRgb;
253         }
254         void applyTextureYUV(inout vec4 color, vec2 texCoord)
255         {
256             float y = SamplerFunction(s_samplerY, texCoord).r;
257             float u = SamplerFunction(s_samplerU, texCoord).r;
258             float v = SamplerFunction(s_samplerV, texCoord).r;
259             vec4 data = vec4(yuvToRgb(y, u, v), 1.0);
260             color = u_textureColorSpaceMatrix * data;
261         }
262         void applyTextureNV12(inout vec4 color, vec2 texCoord)
263         {
264             float y = SamplerFunction(s_samplerY, texCoord).r;
265             vec2 uv = SamplerFunction(s_samplerU, texCoord).rg;
266             vec4 data = vec4(yuvToRgb(y, uv.x, uv.y), 1.0);
267             color = u_textureColorSpaceMatrix * data;
268         }
269         void applyTextureNV21(inout vec4 color, vec2 texCoord)
270         {
271             float y = SamplerFunction(s_samplerY, texCoord).r;
272             vec2 uv = SamplerFunction(s_samplerU, texCoord).gr;
273             vec4 data = vec4(yuvToRgb(y, uv.x, uv.y), 1.0);
274             color = u_textureColorSpaceMatrix * data;
275         }
276         void applyTexturePackedYUV(inout vec4 color, vec2 texCoord)
277         {
278             vec4 data = SamplerFunction(s_sampler, texCoord);
279             color = u_textureColorSpaceMatrix * vec4(yuvToRgb(data.b, data.g, data.r), data.a);
280         }
281         void applyOpacity(inout vec4 color) { color *= u_opacity; }
282         void applyAntialiasing(inout vec4 color) { color *= antialias(); }
283 
284         void applyGrayscaleFilter(inout vec4 color)
285         {
286             float amount = 1.0 - u_filterAmount;
287             color = vec4((0.2126 + 0.7874 * amount) * color.r + (0.7152 - 0.7152 * amount) * color.g + (0.0722 - 0.0722 * amount) * color.b,
288                 (0.2126 - 0.2126 * amount) * color.r + (0.7152 + 0.2848 * amount) * color.g + (0.0722 - 0.0722 * amount) * color.b,
289                 (0.2126 - 0.2126 * amount) * color.r + (0.7152 - 0.7152 * amount) * color.g + (0.0722 + 0.9278 * amount) * color.b,
290                 color.a);
291         }
292 
293         void applySepiaFilter(inout vec4 color)
294         {
295             float amount = 1.0 - u_filterAmount;
296             color = vec4((0.393 + 0.607 * amount) * color.r + (0.769 - 0.769 * amount) * color.g + (0.189 - 0.189 * amount) * color.b,
297                 (0.349 - 0.349 * amount) * color.r + (0.686 + 0.314 * amount) * color.g + (0.168 - 0.168 * amount) * color.b,
298                 (0.272 - 0.272 * amount) * color.r + (0.534 - 0.534 * amount) * color.g + (0.131 + 0.869 * amount) * color.b,
299                 color.a);
300         }
301 
302         void applySaturateFilter(inout vec4 color)
303         {
304             color = vec4((0.213 + 0.787 * u_filterAmount) * color.r + (0.715 - 0.715 * u_filterAmount) * color.g + (0.072 - 0.072 * u_filterAmount) * color.b,
305                 (0.213 - 0.213 * u_filterAmount) * color.r + (0.715 + 0.285 * u_filterAmount) * color.g + (0.072 - 0.072 * u_filterAmount) * color.b,
306                 (0.213 - 0.213 * u_filterAmount) * color.r + (0.715 - 0.715 * u_filterAmount) * color.g + (0.072 + 0.928 * u_filterAmount) * color.b,
307                 color.a);
308         }
309 
310         void applyHueRotateFilter(inout vec4 color)
311         {
312             float pi = 3.14159265358979323846;
313             float c = cos(u_filterAmount * pi / 180.0);
314             float s = sin(u_filterAmount * pi / 180.0);
315             color = vec4(color.r * (0.213 + c * 0.787 - s * 0.213) + color.g * (0.715 - c * 0.715 - s * 0.715) + color.b * (0.072 - c * 0.072 + s * 0.928),
316                 color.r * (0.213 - c * 0.213 + s * 0.143) + color.g * (0.715 + c * 0.285 + s * 0.140) + color.b * (0.072 - c * 0.072 - s * 0.283),
317                 color.r * (0.213 - c * 0.213 - s * 0.787) +  color.g * (0.715 - c * 0.715 + s * 0.715) + color.b * (0.072 + c * 0.928 + s * 0.072),
318                 color.a);
319         }
320 
321         float invert(float n) { return (1.0 - n) * u_filterAmount + n * (1.0 - u_filterAmount); }
322         void applyInvertFilter(inout vec4 color)
323         {
324             color = vec4(invert(color.r), invert(color.g), invert(color.b), color.a);
325         }
326 
327         void applyBrightnessFilter(inout vec4 color)
328         {
329             color = vec4(color.rgb * u_filterAmount, color.a);
330         }
331 
332         float contrast(float n) { return (n - 0.5) * u_filterAmount + 0.5; }
333         void applyContrastFilter(inout vec4 color)
334         {
335             color = vec4(contrast(color.r), contrast(color.g), contrast(color.b), color.a);
336         }
337 
338         void applyOpacityFilter(inout vec4 color)
339         {
340             color = vec4(color.r, color.g, color.b, color.a * u_filterAmount);
341         }
342 
343         vec4 sampleColorAtRadius(float radius, vec2 texCoord)
344         {
345             vec2 coord = texCoord + radius * u_blurRadius;
346             return SamplerFunction(s_sampler, coord) * float(coord.x &gt; 0. &amp;&amp; coord.y &gt; 0. &amp;&amp; coord.x &lt; 1. &amp;&amp; coord.y &lt; 1.);
347         }
348 
349         float sampleAlphaAtRadius(float radius, vec2 texCoord)
350         {
351             vec2 coord = texCoord - u_shadowOffset + radius * u_blurRadius;
352             return SamplerFunction(s_sampler, coord).a * float(coord.x &gt; 0. &amp;&amp; coord.y &gt; 0. &amp;&amp; coord.x &lt; 1. &amp;&amp; coord.y &lt; 1.);
353         }
354 
355         void applyBlurFilter(inout vec4 color, vec2 texCoord)
356         {
357             vec4 total = sampleColorAtRadius(0., texCoord) * u_gaussianKernel[0];
358             for (int i = 1; i &lt; GAUSSIAN_KERNEL_HALF_WIDTH; i++) {
359                 total += sampleColorAtRadius(float(i) * GAUSSIAN_KERNEL_STEP, texCoord) * u_gaussianKernel[i];
360                 total += sampleColorAtRadius(float(-1 * i) * GAUSSIAN_KERNEL_STEP, texCoord) * u_gaussianKernel[i];
361             }
362 
363             color = total;
364         }
365 
366         void applyAlphaBlur(inout vec4 color, vec2 texCoord)
367         {
368             float total = sampleAlphaAtRadius(0., texCoord) * u_gaussianKernel[0];
369             for (int i = 1; i &lt; GAUSSIAN_KERNEL_HALF_WIDTH; i++) {
370                 total += sampleAlphaAtRadius(float(i) * GAUSSIAN_KERNEL_STEP, texCoord) * u_gaussianKernel[i];
371                 total += sampleAlphaAtRadius(float(-1 * i) * GAUSSIAN_KERNEL_STEP, texCoord) * u_gaussianKernel[i];
372             }
373 
374             color *= total;
375         }
376 
377         vec4 sourceOver(vec4 src, vec4 dst) { return src + dst * (1. - dst.a); }
378 
379         void applyContentTexture(inout vec4 color, vec2 texCoord)
380         {
381             vec4 contentColor = texture2D(s_contentTexture, texCoord);
382             color = sourceOver(contentColor, color);
383         }
384 
385         void applyTextureExternalOES(inout vec4 color, vec2 texCoord)
386         {
387             vec4 contentColor = texture2D(s_externalOESTexture, texCoord);
388             color = sourceOver(contentColor, color);
389         }
390 
391         void applySolidColor(inout vec4 color) { color *= u_color; }
392 
393         void main(void)
394         {
395             vec4 color = vec4(1., 1., 1., 1.);
396             vec2 texCoord = transformTexCoord();
397             applyManualRepeatIfNeeded(texCoord);
398             applyTextureRGBIfNeeded(color, texCoord);
399             applyTextureYUVIfNeeded(color, texCoord);
400             applyTextureNV12IfNeeded(color, texCoord);
401             applyTextureNV21IfNeeded(color, texCoord);
402             applyTexturePackedYUVIfNeeded(color, texCoord);
403             applySolidColorIfNeeded(color);
404             applyAntialiasingIfNeeded(color);
405             applyOpacityIfNeeded(color);
406             applyGrayscaleFilterIfNeeded(color);
407             applySepiaFilterIfNeeded(color);
408             applySaturateFilterIfNeeded(color);
409             applyHueRotateFilterIfNeeded(color);
410             applyInvertFilterIfNeeded(color);
411             applyBrightnessFilterIfNeeded(color);
412             applyContrastFilterIfNeeded(color);
413             applyOpacityFilterIfNeeded(color);
414             applyBlurFilterIfNeeded(color, texCoord);
415             applyAlphaBlurIfNeeded(color, texCoord);
416             applyContentTextureIfNeeded(color, texCoord);
417             applyTextureExternalOESIfNeeded(color, texCoord);
418             gl_FragColor = color;
419         }
420     );
421 
422 Ref&lt;TextureMapperShaderProgram&gt; TextureMapperShaderProgram::create(TextureMapperShaderProgram::Options options)
423 {
424 #define SET_APPLIER_FROM_OPTIONS(Applier) \
425     optionsApplierBuilder.append(\
426         (options &amp; TextureMapperShaderProgram::Applier) ? ENABLE_APPLIER(Applier) : DISABLE_APPLIER(Applier))
427 
428     StringBuilder optionsApplierBuilder;
429     SET_APPLIER_FROM_OPTIONS(TextureRGB);
430     SET_APPLIER_FROM_OPTIONS(TextureYUV);
431     SET_APPLIER_FROM_OPTIONS(TextureNV12);
432     SET_APPLIER_FROM_OPTIONS(TextureNV21);
433     SET_APPLIER_FROM_OPTIONS(TexturePackedYUV);
434     SET_APPLIER_FROM_OPTIONS(Rect);
435     SET_APPLIER_FROM_OPTIONS(SolidColor);
436     SET_APPLIER_FROM_OPTIONS(Opacity);
437     SET_APPLIER_FROM_OPTIONS(Antialiasing);
438     SET_APPLIER_FROM_OPTIONS(GrayscaleFilter);
439     SET_APPLIER_FROM_OPTIONS(SepiaFilter);
440     SET_APPLIER_FROM_OPTIONS(SaturateFilter);
441     SET_APPLIER_FROM_OPTIONS(HueRotateFilter);
442     SET_APPLIER_FROM_OPTIONS(BrightnessFilter);
443     SET_APPLIER_FROM_OPTIONS(ContrastFilter);
444     SET_APPLIER_FROM_OPTIONS(InvertFilter);
445     SET_APPLIER_FROM_OPTIONS(OpacityFilter);
446     SET_APPLIER_FROM_OPTIONS(BlurFilter);
447     SET_APPLIER_FROM_OPTIONS(AlphaBlur);
448     SET_APPLIER_FROM_OPTIONS(ContentTexture);
449     SET_APPLIER_FROM_OPTIONS(ManualRepeat);
450     SET_APPLIER_FROM_OPTIONS(TextureExternalOES);
451 
452     StringBuilder vertexShaderBuilder;
453 
454     // OpenGL &gt;= 3.2 requires a #version directive at the beginning of the code.
455 #if !USE(OPENGL_ES)
456     unsigned glVersion = GLContext::current()-&gt;version();
457     if (glVersion &gt;= 320)
458         vertexShaderBuilder.append(GLSL_DIRECTIVE(version 150));
459 #endif
460 
461     // Append the options.
462     vertexShaderBuilder.append(optionsApplierBuilder.toString());
463 
464     // Append the appropriate input/output variable definitions.
465 #if USE(OPENGL_ES)
466     vertexShaderBuilder.append(vertexTemplateLT320Vars);
467 #else
468     if (glVersion &gt;= 320)
469         vertexShaderBuilder.append(vertexTemplateGE320Vars);
470     else
471         vertexShaderBuilder.append(vertexTemplateLT320Vars);
472 #endif
473 
474     // Append the common code.
475     vertexShaderBuilder.append(vertexTemplateCommon);
476 
477     StringBuilder fragmentShaderBuilder;
478 
479     // OpenGL &gt;= 3.2 requires a #version directive at the beginning of the code.
480 #if !USE(OPENGL_ES)
481     if (glVersion &gt;= 320)
482         fragmentShaderBuilder.append(GLSL_DIRECTIVE(version 150));
483 #endif
484 
485     // Append the options.
486     fragmentShaderBuilder.append(optionsApplierBuilder.toString());
487 
488     // Append the common header.
489     fragmentShaderBuilder.append(fragmentTemplateHeaderCommon);
490 
491     // Append the appropriate input/output variable definitions.
492 #if USE(OPENGL_ES)
493     fragmentShaderBuilder.append(fragmentTemplateLT320Vars);
494 #else
495     if (glVersion &gt;= 320)
496         fragmentShaderBuilder.append(fragmentTemplateGE320Vars);
497     else
498         fragmentShaderBuilder.append(fragmentTemplateLT320Vars);
499 #endif
500 
501     // Append the common code.
502     fragmentShaderBuilder.append(fragmentTemplateCommon);
503 
504     return adoptRef(*new TextureMapperShaderProgram(vertexShaderBuilder.toString(), fragmentShaderBuilder.toString()));
505 }
506 
507 #if !LOG_DISABLED
508 static CString getShaderLog(GLuint shader)
509 {
510     GLint logLength = 0;
511     glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;logLength);
512     if (!logLength)
513         return { };
514 
515     Vector&lt;GLchar&gt; info(logLength);
516     GLsizei infoLength = 0;
517     glGetShaderInfoLog(shader, logLength, &amp;infoLength, info.data());
518 
519     size_t stringLength = std::max(infoLength, 0);
520     return { info.data(), stringLength };
521 }
522 
523 static CString getProgramLog(GLuint program)
524 {
525     GLint logLength = 0;
526     glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;logLength);
527     if (!logLength)
528         return { };
529 
530     Vector&lt;GLchar&gt; info(logLength);
531     GLsizei infoLength = 0;
532     glGetProgramInfoLog(program, logLength, &amp;infoLength, info.data());
533 
534     size_t stringLength = std::max(infoLength, 0);
535     return { info.data(), stringLength };
536 }
537 #endif
538 
539 TextureMapperShaderProgram::TextureMapperShaderProgram(const String&amp; vertex, const String&amp; fragment)
540 {
541     m_vertexShader = glCreateShader(GL_VERTEX_SHADER);
542     {
543         CString vertexCString = vertex.utf8();
544         const char* data = vertexCString.data();
545         int length = vertexCString.length();
546         glShaderSource(m_vertexShader, 1, &amp;data, &amp;length);
547     }
548     glCompileShader(m_vertexShader);
549 
550     m_fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
551     {
552         CString fragmentCString = fragment.utf8();
553         const char* data = fragmentCString.data();
554         int length = fragmentCString.length();
555         glShaderSource(m_fragmentShader, 1, &amp;data, &amp;length);
556     }
557     glCompileShader(m_fragmentShader);
558 
559     m_id = glCreateProgram();
560     glAttachShader(m_id, m_vertexShader);
561     glAttachShader(m_id, m_fragmentShader);
562     glLinkProgram(m_id);
563 
564     if (!compositingLogEnabled() || glGetError() == GL_NO_ERROR)
565         return;
566 
567     LOG(Compositing, &quot;Vertex shader log: %s\n&quot;, getShaderLog(m_vertexShader).data());
568     LOG(Compositing, &quot;Fragment shader log: %s\n&quot;, getShaderLog(m_fragmentShader).data());
569     LOG(Compositing, &quot;Program log: %s\n&quot;, getProgramLog(m_id).data());
570 }
571 
572 TextureMapperShaderProgram::~TextureMapperShaderProgram()
573 {
574     if (!m_id)
575         return;
576 
577     glDetachShader(m_id, m_vertexShader);
578     glDeleteShader(m_vertexShader);
579     glDetachShader(m_id, m_fragmentShader);
580     glDeleteShader(m_fragmentShader);
581     glDeleteProgram(m_id);
582 }
583 
584 void TextureMapperShaderProgram::setMatrix(GLuint location, const TransformationMatrix&amp; matrix)
585 {
586     auto floatMatrix = matrix.toColumnMajorFloatArray();
587     glUniformMatrix4fv(location, 1, false, floatMatrix.data());
588 }
589 
590 GLuint TextureMapperShaderProgram::getLocation(const AtomString&amp; name, VariableType type)
591 {
592     auto addResult = m_variables.ensure(name,
593         [this, &amp;name, type] {
594             CString nameCString = name.string().utf8();
595             switch (type) {
596             case UniformVariable:
597                 return glGetUniformLocation(m_id, nameCString.data());
598             case AttribVariable:
599                 return glGetAttribLocation(m_id, nameCString.data());
600             }
601             ASSERT_NOT_REACHED();
602             return 0;
603         });
604     return addResult.iterator-&gt;value;
605 }
606 
607 } // namespace WebCore
608 
609 #endif // USE(TEXTURE_MAPPER_GL)
    </pre>
  </body>
</html>
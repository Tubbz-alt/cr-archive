<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGMovHintRemovalPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGMovHintRemovalPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;BytecodeLivenessAnalysisInlines.h&quot;
 32 #include &quot;DFGEpoch.h&quot;
 33 #include &quot;DFGForAllKills.h&quot;
 34 #include &quot;DFGGraph.h&quot;
 35 #include &quot;DFGInsertionSet.h&quot;
 36 #include &quot;DFGMayExit.h&quot;
 37 #include &quot;DFGPhase.h&quot;
 38 #include &quot;JSCInlines.h&quot;
 39 #include &quot;OperandsInlines.h&quot;
 40 
 41 namespace JSC { namespace DFG {
 42 
 43 namespace {
 44 
 45 namespace DFGMovHintRemovalPhaseInternal {
 46 static const bool verbose = false;
 47 }
 48 
 49 class MovHintRemovalPhase : public Phase {
 50 public:
 51     MovHintRemovalPhase(Graph&amp; graph)
 52         : Phase(graph, &quot;MovHint removal&quot;)
 53         , m_state(OperandsLike, graph.block(0)-&gt;variablesAtHead)
 54         , m_changed(false)
 55     {
 56     }
 57 
 58     bool run()
 59     {
 60         if (DFGMovHintRemovalPhaseInternal::verbose) {
 61             dataLog(&quot;Graph before MovHint removal:\n&quot;);
 62             m_graph.dump();
 63         }
 64 
 65         for (BasicBlock* block : m_graph.blocksInNaturalOrder())
 66             handleBlock(block);
 67 
 68         return m_changed;
 69     }
 70 
 71 private:
 72     void handleBlock(BasicBlock* block)
 73     {
 74         if (DFGMovHintRemovalPhaseInternal::verbose)
 75             dataLog(&quot;Handing block &quot;, pointerDump(block), &quot;\n&quot;);
 76 
 77         // A MovHint is unnecessary if the local dies before it is used. We answer this question by
 78         // maintaining the current exit epoch, and associating an epoch with each local. When a
 79         // local dies, it gets the current exit epoch. If a MovHint occurs in the same epoch as its
 80         // local, then it means there was no exit between the local&#39;s death and the MovHint - i.e.
 81         // the MovHint is unnecessary.
 82 
 83         Epoch currentEpoch = Epoch::first();
 84 
 85         m_state.fill(Epoch());
 86         m_graph.forAllLiveInBytecode(
 87             block-&gt;terminal()-&gt;origin.forExit,
 88             [&amp;] (VirtualRegister reg) {
 89                 m_state.operand(reg) = currentEpoch;
 90             });
 91 
 92         if (DFGMovHintRemovalPhaseInternal::verbose)
 93             dataLog(&quot;    Locals: &quot;, m_state, &quot;\n&quot;);
 94 
 95         // Assume that blocks after us exit.
 96         currentEpoch.bump();
 97 
 98         for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
 99             Node* node = block-&gt;at(nodeIndex);
100 
101             if (node-&gt;op() == MovHint) {
102                 Epoch localEpoch = m_state.operand(node-&gt;unlinkedLocal());
103                 if (DFGMovHintRemovalPhaseInternal::verbose)
104                     dataLog(&quot;    At &quot;, node, &quot;: current = &quot;, currentEpoch, &quot;, local = &quot;, localEpoch, &quot;\n&quot;);
105                 if (!localEpoch || localEpoch == currentEpoch) {
106                     node-&gt;setOpAndDefaultFlags(ZombieHint);
107                     node-&gt;child1() = Edge();
108                     m_changed = true;
109                 }
110                 m_state.operand(node-&gt;unlinkedLocal()) = Epoch();
111             }
112 
113             if (mayExit(m_graph, node) != DoesNotExit)
114                 currentEpoch.bump();
115 
116             if (nodeIndex) {
117                 forAllKilledOperands(
118                     m_graph, block-&gt;at(nodeIndex - 1), node,
119                     [&amp;] (VirtualRegister reg) {
120                         // This function is a bit sloppy - it might claim to kill a local even if
121                         // it&#39;s still live after. We need to protect against that.
122                         if (!!m_state.operand(reg))
123                             return;
124 
125                         if (DFGMovHintRemovalPhaseInternal::verbose)
126                             dataLog(&quot;    Killed operand at &quot;, node, &quot;: &quot;, reg, &quot;\n&quot;);
127                         m_state.operand(reg) = currentEpoch;
128                     });
129             }
130         }
131     }
132 
133     Operands&lt;Epoch&gt; m_state;
134     bool m_changed;
135 };
136 
137 } // anonymous namespace
138 
139 bool performMovHintRemoval(Graph&amp; graph)
140 {
141     return runPhase&lt;MovHintRemovalPhase&gt;(graph);
142 }
143 
144 } } // namespace JSC::DFG
145 
146 #endif // ENABLE(DFG_JIT)
147 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/workers/Worker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DedicatedWorkerThread.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Worker.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/Worker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,10 ***</span>
<span class="line-new-header">--- 26,11 ---</span>
  
  #include &quot;config.h&quot;
  #include &quot;Worker.h&quot;
  
  #include &quot;ContentSecurityPolicy.h&quot;
<span class="line-added">+ #include &quot;ErrorEvent.h&quot;</span>
  #include &quot;Event.h&quot;
  #include &quot;EventNames.h&quot;
  #include &quot;InspectorInstrumentation.h&quot;
  #include &quot;LoaderStrategy.h&quot;
  #include &quot;PlatformStrategies.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 37,10 ***</span>
<span class="line-new-header">--- 38,11 ---</span>
  #include &quot;SecurityOrigin.h&quot;
  #include &quot;WorkerGlobalScopeProxy.h&quot;
  #include &quot;WorkerScriptLoader.h&quot;
  #include &quot;WorkerThread.h&quot;
  #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
<span class="line-added">+ #include &lt;JavaScriptCore/ScriptCallStack.h&gt;</span>
  #include &lt;wtf/HashSet.h&gt;
  #include &lt;wtf/IsoMallocInlines.h&gt;
  #include &lt;wtf/MainThread.h&gt;
  #include &lt;wtf/NeverDestroyed.h&gt;
  #include &lt;wtf/Scope.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 123,14 ***</span>
      ASSERT(scriptExecutionContext()); // The context is protected by worker context proxy, so it cannot be destroyed while a Worker exists.
      allWorkers().remove(this);
      m_contextProxy.workerObjectDestroyed();
  }
  
<span class="line-modified">! ExceptionOr&lt;void&gt; Worker::postMessage(JSC::ExecState&amp; state, JSC::JSValue messageValue, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp; transfer)</span>
  {
      Vector&lt;RefPtr&lt;MessagePort&gt;&gt; ports;
<span class="line-modified">!     auto message = SerializedScriptValue::create(state, messageValue, WTFMove(transfer), ports, SerializationContext::WorkerPostMessage);</span>
      if (message.hasException())
          return message.releaseException();
  
      // Disentangle the port in preparation for sending it to the remote context.
      auto channels = MessagePort::disentanglePorts(WTFMove(ports));
<span class="line-new-header">--- 125,14 ---</span>
      ASSERT(scriptExecutionContext()); // The context is protected by worker context proxy, so it cannot be destroyed while a Worker exists.
      allWorkers().remove(this);
      m_contextProxy.workerObjectDestroyed();
  }
  
<span class="line-modified">! ExceptionOr&lt;void&gt; Worker::postMessage(JSC::JSGlobalObject&amp; state, JSC::JSValue messageValue, PostMessageOptions&amp;&amp; options)</span>
  {
      Vector&lt;RefPtr&lt;MessagePort&gt;&gt; ports;
<span class="line-modified">!     auto message = SerializedScriptValue::create(state, messageValue, WTFMove(options.transfer), ports, SerializationContext::WorkerPostMessage);</span>
      if (message.hasException())
          return message.releaseException();
  
      // Disentangle the port in preparation for sending it to the remote context.
      auto channels = MessagePort::disentanglePorts(WTFMove(ports));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 142,16 ***</span>
  }
  
  void Worker::terminate()
  {
      m_contextProxy.terminateWorkerGlobalScope();
<span class="line-modified">! }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool Worker::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // FIXME: It is not currently possible to suspend a worker, so pages with workers can not go into page cache.</span>
<span class="line-removed">-     return false;</span>
  }
  
  const char* Worker::activeDOMObjectName() const
  {
      return &quot;Worker&quot;;
<span class="line-new-header">--- 144,11 ---</span>
  }
  
  void Worker::terminate()
  {
      m_contextProxy.terminateWorkerGlobalScope();
<span class="line-modified">!     m_wasTerminated = true;</span>
  }
  
  const char* Worker::activeDOMObjectName() const
  {
      return &quot;Worker&quot;;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 160,10 ***</span>
<span class="line-new-header">--- 157,26 ---</span>
  void Worker::stop()
  {
      terminate();
  }
  
<span class="line-added">+ void Worker::suspend(ReasonForSuspension reason)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (reason == ReasonForSuspension::BackForwardCache) {</span>
<span class="line-added">+         m_contextProxy.suspendForBackForwardCache();</span>
<span class="line-added">+         m_isSuspendedForBackForwardCache = true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Worker::resume()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_isSuspendedForBackForwardCache) {</span>
<span class="line-added">+         m_contextProxy.resumeForBackForwardCache();</span>
<span class="line-added">+         m_isSuspendedForBackForwardCache = false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool Worker::hasPendingActivity() const
  {
      return m_contextProxy.hasPendingActivity() || ActiveDOMObject::hasPendingActivity();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 190,16 ***</span>
      auto* context = scriptExecutionContext();
      if (!context)
          return;
  
      if (m_scriptLoader-&gt;failed()) {
<span class="line-modified">!         dispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::Yes));</span>
          return;
      }
  
      bool isOnline = platformStrategies()-&gt;loaderStrategy()-&gt;isOnLine();
      const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicyResponseHeaders = m_contentSecurityPolicyResponseHeaders ? m_contentSecurityPolicyResponseHeaders.value() : context-&gt;contentSecurityPolicy()-&gt;responseHeaders();
<span class="line-modified">!     m_contextProxy.startWorkerGlobalScope(m_scriptLoader-&gt;url(), m_name, context-&gt;userAgent(m_scriptLoader-&gt;url()), isOnline, m_scriptLoader-&gt;script(), contentSecurityPolicyResponseHeaders, m_shouldBypassMainWorldContentSecurityPolicy, m_workerCreationTime, m_runtimeFlags, context-&gt;sessionID());</span>
      InspectorInstrumentation::scriptImported(*context, m_scriptLoader-&gt;identifier(), m_scriptLoader-&gt;script());
  }
  
  } // namespace WebCore
<span class="line-new-header">--- 203,31 ---</span>
      auto* context = scriptExecutionContext();
      if (!context)
          return;
  
      if (m_scriptLoader-&gt;failed()) {
<span class="line-modified">!         queueTaskToDispatchEvent(*this, TaskSource::DOMManipulation, Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::Yes));</span>
          return;
      }
  
      bool isOnline = platformStrategies()-&gt;loaderStrategy()-&gt;isOnLine();
      const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicyResponseHeaders = m_contentSecurityPolicyResponseHeaders ? m_contentSecurityPolicyResponseHeaders.value() : context-&gt;contentSecurityPolicy()-&gt;responseHeaders();
<span class="line-modified">!     ReferrerPolicy referrerPolicy = ReferrerPolicy::EmptyString;</span>
<span class="line-added">+     if (auto policy = parseReferrerPolicy(m_scriptLoader-&gt;referrerPolicy(), ReferrerPolicySource::HTTPHeader))</span>
<span class="line-added">+         referrerPolicy = *policy;</span>
<span class="line-added">+     m_contextProxy.startWorkerGlobalScope(m_scriptLoader-&gt;url(), m_name, context-&gt;userAgent(m_scriptLoader-&gt;url()), isOnline, m_scriptLoader-&gt;script(), contentSecurityPolicyResponseHeaders, m_shouldBypassMainWorldContentSecurityPolicy, m_workerCreationTime, referrerPolicy, m_runtimeFlags);</span>
      InspectorInstrumentation::scriptImported(*context, m_scriptLoader-&gt;identifier(), m_scriptLoader-&gt;script());
  }
  
<span class="line-added">+ void Worker::dispatchEvent(Event&amp; event)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_wasTerminated)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     AbstractWorker::dispatchEvent(event);</span>
<span class="line-added">+     if (is&lt;ErrorEvent&gt;(event) &amp;&amp; !event.defaultPrevented() &amp;&amp; event.isTrusted() &amp;&amp; scriptExecutionContext()) {</span>
<span class="line-added">+         auto&amp; errorEvent = downcast&lt;ErrorEvent&gt;(event);</span>
<span class="line-added">+         scriptExecutionContext()-&gt;reportException(errorEvent.message(), errorEvent.lineno(), errorEvent.colno(), errorEvent.filename(), nullptr, nullptr);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  } // namespace WebCore
</pre>
<center><a href="DedicatedWorkerThread.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Worker.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
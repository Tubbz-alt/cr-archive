<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/svg/SVGToOTFFontConversion.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGTextPositioningElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGTransform.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/SVGToOTFFontConversion.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  85         String codepoints;
  86         const SVGGlyphElement* glyphElement;
  87         float horizontalAdvance;
  88         float verticalAdvance;
  89     };
  90 
  91     class Placeholder {
  92     public:
  93         Placeholder(SVGToOTFFontConverter&amp; converter, size_t baseOfOffset)
  94             : m_converter(converter)
  95             , m_baseOfOffset(baseOfOffset)
  96             , m_location(m_converter.m_result.size())
  97         {
  98             m_converter.append16(0);
  99         }
 100 
 101         Placeholder(Placeholder&amp;&amp; other)
 102             : m_converter(other.m_converter)
 103             , m_baseOfOffset(other.m_baseOfOffset)
 104             , m_location(other.m_location)
<span class="line-modified"> 105 #if !ASSERT_DISABLED</span>
 106             , m_active(other.m_active)
 107 #endif
 108         {
<span class="line-modified"> 109 #if !ASSERT_DISABLED</span>
 110             other.m_active = false;
 111 #endif
 112         }
 113 
 114         void populate()
 115         {
 116             ASSERT(m_active);
 117             size_t delta = m_converter.m_result.size() - m_baseOfOffset;
 118             ASSERT(delta &lt; std::numeric_limits&lt;uint16_t&gt;::max());
 119             m_converter.overwrite16(m_location, delta);
<span class="line-modified"> 120 #if !ASSERT_DISABLED</span>
 121             m_active = false;
 122 #endif
 123         }
 124 
 125         ~Placeholder()
 126         {
 127             ASSERT(!m_active);
 128         }
 129 
 130     private:
 131         SVGToOTFFontConverter&amp; m_converter;
 132         const size_t m_baseOfOffset;
 133         const size_t m_location;
<span class="line-modified"> 134 #if !ASSERT_DISABLED</span>
 135         bool m_active = { true };
 136 #endif
 137     };
 138 
 139     struct KerningData {
 140         KerningData(uint16_t glyph1, uint16_t glyph2, int16_t adjustment)
 141             : glyph1(glyph1)
 142             , glyph2(glyph2)
 143             , adjustment(adjustment)
 144         {
 145         }
 146         uint16_t glyph1;
 147         uint16_t glyph2;
 148         int16_t adjustment;
 149     };
 150 
 151     Placeholder placeholder(size_t baseOfOffset)
 152     {
 153         return Placeholder(*this, baseOfOffset);
 154     }
</pre>
<hr />
<pre>
 620     bool hasWeight = !weight.isNull();
 621 
 622     const char operand32Bit = 29;
 623     const char fullNameKey = 2;
 624     const char familyNameKey = 3;
 625     const char weightKey = 4;
 626     const char fontBBoxKey = 5;
 627     const char charsetIndexKey = 15;
 628     const char charstringsIndexKey = 17;
 629     const char privateDictIndexKey = 18;
 630     const uint32_t userDefinedStringStartIndex = 391;
 631     const unsigned sizeOfTopIndex = 56 + (hasWeight ? 6 : 0);
 632 
 633     // Top DICT INDEX.
 634     append16(1); // INDEX contains 1 element
 635     m_result.append(4); // Offsets in this INDEX are 4 bytes long
 636     append32(1); // 1-index offset of DICT data
 637     append32(1 + sizeOfTopIndex); // 1-index offset just past end of DICT data
 638 
 639     // DICT information
<span class="line-modified"> 640 #if !ASSERT_DISABLED</span>
 641     unsigned topDictStart = m_result.size();
 642 #endif
 643     m_result.append(operand32Bit);
 644     append32(userDefinedStringStartIndex);
 645     m_result.append(fullNameKey);
 646     m_result.append(operand32Bit);
 647     append32(userDefinedStringStartIndex);
 648     m_result.append(familyNameKey);
 649     if (hasWeight) {
 650         m_result.append(operand32Bit);
 651         append32(userDefinedStringStartIndex + 2);
 652         m_result.append(weightKey);
 653     }
 654     m_result.append(operand32Bit);
 655     append32(clampTo&lt;int32_t&gt;(m_boundingBox.x()));
 656     m_result.append(operand32Bit);
 657     append32(clampTo&lt;int32_t&gt;(m_boundingBox.y()));
 658     m_result.append(operand32Bit);
 659     append32(clampTo&lt;int32_t&gt;(m_boundingBox.width()));
 660     m_result.append(operand32Bit);
</pre>
<hr />
<pre>
 700     m_result.append(0);
 701     for (Glyph i = 1; i &lt; m_glyphs.size(); ++i)
 702         append16(userDefinedStringStartIndex + 1);
 703 
 704     // CharStrings INDEX
 705     overwrite32(charstringsOffsetLocation, m_result.size() - startingOffset);
 706     append16(m_glyphs.size());
 707     m_result.append(4); // Offsets in this INDEX are 4 bytes long
 708     offset = 1;
 709     append32(offset);
 710     for (auto&amp; glyph : m_glyphs) {
 711         offset += glyph.charString.size();
 712         append32(offset);
 713     }
 714     for (auto&amp; glyph : m_glyphs)
 715         m_result.appendVector(glyph.charString);
 716 }
 717 
 718 Glyph SVGToOTFFontConverter::firstGlyph(const Vector&lt;Glyph, 1&gt;&amp; v, UChar32 codepoint) const
 719 {
<span class="line-modified"> 720 #if ASSERT_DISABLED</span>
 721     UNUSED_PARAM(codepoint);
 722 #endif
 723     ASSERT(!v.isEmpty());
 724     if (v.isEmpty())
 725         return 0;
<span class="line-modified"> 726 #if !ASSERT_DISABLED</span>
 727     auto codePoints = StringView(m_glyphs[v[0]].codepoints).codePoints();
 728     auto codePointsIterator = codePoints.begin();
 729     ASSERT(codePointsIterator != codePoints.end());
 730     ASSERT(codepoint == *codePointsIterator);
 731 #endif
 732     return v[0];
 733 }
 734 
 735 void SVGToOTFFontConverter::appendLigatureSubtable(size_t subtableRecordLocation)
 736 {
 737     typedef std::pair&lt;Vector&lt;Glyph, 3&gt;, Glyph&gt; LigaturePair;
 738     Vector&lt;LigaturePair&gt; ligaturePairs;
 739     for (Glyph glyphIndex = 0; glyphIndex &lt; m_glyphs.size(); ++glyphIndex) {
 740         ligaturePairs.append(LigaturePair(Vector&lt;Glyph, 3&gt;(), glyphIndex));
 741         Vector&lt;Glyph, 3&gt;&amp; ligatureGlyphs = ligaturePairs.last().first;
 742         auto codePoints = StringView(m_glyphs[glyphIndex].codepoints).codePoints();
 743         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=138592 This needs to be done in codepoint space, not glyph space
 744         for (auto codePoint : codePoints)
 745             ligatureGlyphs.append(firstGlyph(glyphsForCodepoint(codePoint), codePoint));
 746         if (ligatureGlyphs.size() &lt; 2)
</pre>
<hr />
<pre>
1091     append16(kerningData.size());
1092     append16(roundedNumKerningPairs * 6); // searchRange: &quot;The largest power of two less than or equal to the value of nPairs, multiplied by the size in bytes of an entry in the table.&quot;
1093     append16(integralLog2(roundedNumKerningPairs)); // entrySelector: &quot;log2 of the largest power of two less than or equal to the value of nPairs.&quot;
1094     append16((kerningData.size() - roundedNumKerningPairs) * 6); // rangeShift: &quot;The value of nPairs minus the largest power of two less than or equal to nPairs,
1095                                                                         // and then multiplied by the size in bytes of an entry in the table.&quot;
1096 
1097     for (auto&amp; kerningDataElement : kerningData) {
1098         append16(kerningDataElement.glyph1);
1099         append16(kerningDataElement.glyph2);
1100         append16(kerningDataElement.adjustment);
1101     }
1102 
1103     return sizeOfKerningDataTable;
1104 }
1105 
1106 void SVGToOTFFontConverter::appendKERNTable()
1107 {
1108     append16(0); // Version
1109     append16(2); // Number of subtables
1110 
<span class="line-modified">1111 #if !ASSERT_DISABLED</span>
1112     auto subtablesOffset = m_result.size();
1113 #endif
1114 
1115     size_t sizeOfHorizontalSubtable = appendKERNSubtable&lt;SVGHKernElement&gt;(&amp;SVGHKernElement::buildHorizontalKerningPair, 1);
1116     ASSERT_UNUSED(sizeOfHorizontalSubtable, subtablesOffset + sizeOfHorizontalSubtable == m_result.size());
1117     size_t sizeOfVerticalSubtable = appendKERNSubtable&lt;SVGVKernElement&gt;(&amp;SVGVKernElement::buildVerticalKerningPair, 0);
1118     ASSERT_UNUSED(sizeOfVerticalSubtable, subtablesOffset + sizeOfHorizontalSubtable + sizeOfVerticalSubtable == m_result.size());
1119 }
1120 
1121 template &lt;typename V&gt;
1122 static void writeCFFEncodedNumber(V&amp; vector, float number)
1123 {
1124     vector.append(0xFF);
1125     // Convert to 16.16 fixed-point
1126     append32(vector, clampTo&lt;int32_t&gt;(number * 0x10000));
1127 }
1128 
1129 static const char rLineTo = 0x05;
1130 static const char rrCurveTo = 0x08;
1131 static const char endChar = 0x0e;
</pre>
</td>
<td>
<hr />
<pre>
  85         String codepoints;
  86         const SVGGlyphElement* glyphElement;
  87         float horizontalAdvance;
  88         float verticalAdvance;
  89     };
  90 
  91     class Placeholder {
  92     public:
  93         Placeholder(SVGToOTFFontConverter&amp; converter, size_t baseOfOffset)
  94             : m_converter(converter)
  95             , m_baseOfOffset(baseOfOffset)
  96             , m_location(m_converter.m_result.size())
  97         {
  98             m_converter.append16(0);
  99         }
 100 
 101         Placeholder(Placeholder&amp;&amp; other)
 102             : m_converter(other.m_converter)
 103             , m_baseOfOffset(other.m_baseOfOffset)
 104             , m_location(other.m_location)
<span class="line-modified"> 105 #if ASSERT_ENABLED</span>
 106             , m_active(other.m_active)
 107 #endif
 108         {
<span class="line-modified"> 109 #if ASSERT_ENABLED</span>
 110             other.m_active = false;
 111 #endif
 112         }
 113 
 114         void populate()
 115         {
 116             ASSERT(m_active);
 117             size_t delta = m_converter.m_result.size() - m_baseOfOffset;
 118             ASSERT(delta &lt; std::numeric_limits&lt;uint16_t&gt;::max());
 119             m_converter.overwrite16(m_location, delta);
<span class="line-modified"> 120 #if ASSERT_ENABLED</span>
 121             m_active = false;
 122 #endif
 123         }
 124 
 125         ~Placeholder()
 126         {
 127             ASSERT(!m_active);
 128         }
 129 
 130     private:
 131         SVGToOTFFontConverter&amp; m_converter;
 132         const size_t m_baseOfOffset;
 133         const size_t m_location;
<span class="line-modified"> 134 #if ASSERT_ENABLED</span>
 135         bool m_active = { true };
 136 #endif
 137     };
 138 
 139     struct KerningData {
 140         KerningData(uint16_t glyph1, uint16_t glyph2, int16_t adjustment)
 141             : glyph1(glyph1)
 142             , glyph2(glyph2)
 143             , adjustment(adjustment)
 144         {
 145         }
 146         uint16_t glyph1;
 147         uint16_t glyph2;
 148         int16_t adjustment;
 149     };
 150 
 151     Placeholder placeholder(size_t baseOfOffset)
 152     {
 153         return Placeholder(*this, baseOfOffset);
 154     }
</pre>
<hr />
<pre>
 620     bool hasWeight = !weight.isNull();
 621 
 622     const char operand32Bit = 29;
 623     const char fullNameKey = 2;
 624     const char familyNameKey = 3;
 625     const char weightKey = 4;
 626     const char fontBBoxKey = 5;
 627     const char charsetIndexKey = 15;
 628     const char charstringsIndexKey = 17;
 629     const char privateDictIndexKey = 18;
 630     const uint32_t userDefinedStringStartIndex = 391;
 631     const unsigned sizeOfTopIndex = 56 + (hasWeight ? 6 : 0);
 632 
 633     // Top DICT INDEX.
 634     append16(1); // INDEX contains 1 element
 635     m_result.append(4); // Offsets in this INDEX are 4 bytes long
 636     append32(1); // 1-index offset of DICT data
 637     append32(1 + sizeOfTopIndex); // 1-index offset just past end of DICT data
 638 
 639     // DICT information
<span class="line-modified"> 640 #if ASSERT_ENABLED</span>
 641     unsigned topDictStart = m_result.size();
 642 #endif
 643     m_result.append(operand32Bit);
 644     append32(userDefinedStringStartIndex);
 645     m_result.append(fullNameKey);
 646     m_result.append(operand32Bit);
 647     append32(userDefinedStringStartIndex);
 648     m_result.append(familyNameKey);
 649     if (hasWeight) {
 650         m_result.append(operand32Bit);
 651         append32(userDefinedStringStartIndex + 2);
 652         m_result.append(weightKey);
 653     }
 654     m_result.append(operand32Bit);
 655     append32(clampTo&lt;int32_t&gt;(m_boundingBox.x()));
 656     m_result.append(operand32Bit);
 657     append32(clampTo&lt;int32_t&gt;(m_boundingBox.y()));
 658     m_result.append(operand32Bit);
 659     append32(clampTo&lt;int32_t&gt;(m_boundingBox.width()));
 660     m_result.append(operand32Bit);
</pre>
<hr />
<pre>
 700     m_result.append(0);
 701     for (Glyph i = 1; i &lt; m_glyphs.size(); ++i)
 702         append16(userDefinedStringStartIndex + 1);
 703 
 704     // CharStrings INDEX
 705     overwrite32(charstringsOffsetLocation, m_result.size() - startingOffset);
 706     append16(m_glyphs.size());
 707     m_result.append(4); // Offsets in this INDEX are 4 bytes long
 708     offset = 1;
 709     append32(offset);
 710     for (auto&amp; glyph : m_glyphs) {
 711         offset += glyph.charString.size();
 712         append32(offset);
 713     }
 714     for (auto&amp; glyph : m_glyphs)
 715         m_result.appendVector(glyph.charString);
 716 }
 717 
 718 Glyph SVGToOTFFontConverter::firstGlyph(const Vector&lt;Glyph, 1&gt;&amp; v, UChar32 codepoint) const
 719 {
<span class="line-modified"> 720 #if !ASSERT_ENABLED</span>
 721     UNUSED_PARAM(codepoint);
 722 #endif
 723     ASSERT(!v.isEmpty());
 724     if (v.isEmpty())
 725         return 0;
<span class="line-modified"> 726 #if ASSERT_ENABLED</span>
 727     auto codePoints = StringView(m_glyphs[v[0]].codepoints).codePoints();
 728     auto codePointsIterator = codePoints.begin();
 729     ASSERT(codePointsIterator != codePoints.end());
 730     ASSERT(codepoint == *codePointsIterator);
 731 #endif
 732     return v[0];
 733 }
 734 
 735 void SVGToOTFFontConverter::appendLigatureSubtable(size_t subtableRecordLocation)
 736 {
 737     typedef std::pair&lt;Vector&lt;Glyph, 3&gt;, Glyph&gt; LigaturePair;
 738     Vector&lt;LigaturePair&gt; ligaturePairs;
 739     for (Glyph glyphIndex = 0; glyphIndex &lt; m_glyphs.size(); ++glyphIndex) {
 740         ligaturePairs.append(LigaturePair(Vector&lt;Glyph, 3&gt;(), glyphIndex));
 741         Vector&lt;Glyph, 3&gt;&amp; ligatureGlyphs = ligaturePairs.last().first;
 742         auto codePoints = StringView(m_glyphs[glyphIndex].codepoints).codePoints();
 743         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=138592 This needs to be done in codepoint space, not glyph space
 744         for (auto codePoint : codePoints)
 745             ligatureGlyphs.append(firstGlyph(glyphsForCodepoint(codePoint), codePoint));
 746         if (ligatureGlyphs.size() &lt; 2)
</pre>
<hr />
<pre>
1091     append16(kerningData.size());
1092     append16(roundedNumKerningPairs * 6); // searchRange: &quot;The largest power of two less than or equal to the value of nPairs, multiplied by the size in bytes of an entry in the table.&quot;
1093     append16(integralLog2(roundedNumKerningPairs)); // entrySelector: &quot;log2 of the largest power of two less than or equal to the value of nPairs.&quot;
1094     append16((kerningData.size() - roundedNumKerningPairs) * 6); // rangeShift: &quot;The value of nPairs minus the largest power of two less than or equal to nPairs,
1095                                                                         // and then multiplied by the size in bytes of an entry in the table.&quot;
1096 
1097     for (auto&amp; kerningDataElement : kerningData) {
1098         append16(kerningDataElement.glyph1);
1099         append16(kerningDataElement.glyph2);
1100         append16(kerningDataElement.adjustment);
1101     }
1102 
1103     return sizeOfKerningDataTable;
1104 }
1105 
1106 void SVGToOTFFontConverter::appendKERNTable()
1107 {
1108     append16(0); // Version
1109     append16(2); // Number of subtables
1110 
<span class="line-modified">1111 #if ASSERT_ENABLED</span>
1112     auto subtablesOffset = m_result.size();
1113 #endif
1114 
1115     size_t sizeOfHorizontalSubtable = appendKERNSubtable&lt;SVGHKernElement&gt;(&amp;SVGHKernElement::buildHorizontalKerningPair, 1);
1116     ASSERT_UNUSED(sizeOfHorizontalSubtable, subtablesOffset + sizeOfHorizontalSubtable == m_result.size());
1117     size_t sizeOfVerticalSubtable = appendKERNSubtable&lt;SVGVKernElement&gt;(&amp;SVGVKernElement::buildVerticalKerningPair, 0);
1118     ASSERT_UNUSED(sizeOfVerticalSubtable, subtablesOffset + sizeOfHorizontalSubtable + sizeOfVerticalSubtable == m_result.size());
1119 }
1120 
1121 template &lt;typename V&gt;
1122 static void writeCFFEncodedNumber(V&amp; vector, float number)
1123 {
1124     vector.append(0xFF);
1125     // Convert to 16.16 fixed-point
1126     append32(vector, clampTo&lt;int32_t&gt;(number * 0x10000));
1127 }
1128 
1129 static const char rLineTo = 0x05;
1130 static const char rrCurveTo = 0x08;
1131 static const char endChar = 0x0e;
</pre>
</td>
</tr>
</table>
<center><a href="SVGTextPositioningElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGTransform.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
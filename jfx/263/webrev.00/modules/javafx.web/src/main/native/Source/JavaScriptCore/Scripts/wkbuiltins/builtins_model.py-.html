<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/Scripts/wkbuiltins/builtins_model.py</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 #!/usr/bin/env python
  2 #
  3 # Copyright (c) 2015-2016 Apple Inc. All rights reserved.
  4 #
  5 # Redistribution and use in source and binary forms, with or without
  6 # modification, are permitted provided that the following conditions
  7 # are met:
  8 # 1. Redistributions of source code must retain the above copyright
  9 #    notice, this list of conditions and the following disclaimer.
 10 # 2. Redistributions in binary form must reproduce the above copyright
 11 #    notice, this list of conditions and the following disclaimer in the
 12 #    documentation and/or other materials provided with the distribution.
 13 #
 14 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 15 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 16 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 18 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 19 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 20 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 21 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 22 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 23 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 24 # THE POSSIBILITY OF SUCH DAMAGE.
 25 
 26 import logging
 27 import re
 28 import os
 29 
 30 from builtins_templates import BuiltinsGeneratorTemplates as Templates
 31 
 32 log = logging.getLogger(&#39;global&#39;)
 33 
 34 _FRAMEWORK_CONFIG_MAP = {
 35     &quot;JavaScriptCore&quot;: {
 36         &quot;macro_prefix&quot;: &quot;JSC&quot;,
 37         &quot;namespace&quot;: &quot;JSC&quot;,
 38     },
 39     &quot;WebCore&quot;: {
 40         &quot;macro_prefix&quot;: &quot;WEBCORE&quot;,
 41         &quot;namespace&quot;: &quot;WebCore&quot;,
 42     },
 43 }
 44 
 45 functionHeadRegExp = re.compile(r&quot;(?:@[\w|=\[\] \&quot;\.]+\s*\n)*(?:async\s+)?function\s+\w+\s*\(.*?\)&quot;, re.MULTILINE | re.DOTALL)
 46 functionGlobalPrivateRegExp = re.compile(r&quot;.*^@globalPrivate&quot;, re.MULTILINE | re.DOTALL)
 47 functionIntrinsicRegExp = re.compile(r&quot;.*^@intrinsic=(\w+)&quot;, re.MULTILINE | re.DOTALL)
 48 functionIsConstructorRegExp = re.compile(r&quot;.*^@constructor&quot;, re.MULTILINE | re.DOTALL)
 49 functionIsGetterRegExp = re.compile(r&quot;.*^@getter&quot;, re.MULTILINE | re.DOTALL)
 50 functionIsAsyncRegExp = re.compile(r&quot;(async)?\s*function&quot;, re.MULTILINE | re.DOTALL)
 51 functionNameRegExp = re.compile(r&quot;function\s+(\w+)\s*\(&quot;, re.MULTILINE | re.DOTALL)
 52 functionOverriddenNameRegExp = re.compile(r&quot;.*^@overriddenName=(\&quot;.+\&quot;)$&quot;, re.MULTILINE | re.DOTALL)
 53 functionParameterFinder = re.compile(r&quot;^(?:async\s+)?function\s+(?:\w+)\s*\(((?:\s*\w+)?\s*(?:\s*,\s*\w+)*)?\s*\)&quot;, re.MULTILINE | re.DOTALL)
 54 
 55 multilineCommentRegExp = re.compile(r&quot;\/\*.*?\*\/&quot;, re.MULTILINE | re.DOTALL)
 56 singleLineCommentRegExp = re.compile(r&quot;\/\/.*?\n&quot;, re.MULTILINE | re.DOTALL)
 57 keyValueAnnotationCommentRegExp = re.compile(r&quot;^\/\/ @(\w+)=([^=]+?)\n&quot;, re.MULTILINE | re.DOTALL)
 58 flagAnnotationCommentRegExp = re.compile(r&quot;^\/\/ @(\w+)[^=]*?\n&quot;, re.MULTILINE | re.DOTALL)
 59 lineWithOnlySingleLineCommentRegExp = re.compile(r&quot;^\s*\/\/\n&quot;, re.MULTILINE | re.DOTALL)
 60 lineWithTrailingSingleLineCommentRegExp = re.compile(r&quot;\s*\/\/\n&quot;, re.MULTILINE | re.DOTALL)
 61 leadingWhitespaceRegExp = re.compile(r&quot;^ +&quot;, re.MULTILINE | re.DOTALL)
 62 multipleEmptyLinesRegExp = re.compile(r&quot;\n{2,}&quot;, re.MULTILINE | re.DOTALL)
 63 
 64 class ParseException(Exception):
 65     pass
 66 
 67 
 68 class Framework:
 69     def __init__(self, name):
 70         self._settings = _FRAMEWORK_CONFIG_MAP[name]
 71         self.name = name
 72 
 73     def setting(self, key, default=&#39;&#39;):
 74         return self._settings.get(key, default)
 75 
 76     @staticmethod
 77     def fromString(frameworkString):
 78         if frameworkString == &quot;JavaScriptCore&quot;:
 79             return Frameworks.JavaScriptCore
 80 
 81         if frameworkString == &quot;WebCore&quot;:
 82             return Frameworks.WebCore
 83 
 84         raise ParseException(&quot;Unknown framework: %s&quot; % frameworkString)
 85 
 86 
 87 class Frameworks:
 88     JavaScriptCore = Framework(&quot;JavaScriptCore&quot;)
 89     WebCore = Framework(&quot;WebCore&quot;)
 90 
 91 
 92 class BuiltinObject:
 93     def __init__(self, object_name, annotations, functions):
 94         self.object_name = object_name
 95         self.annotations = annotations
 96         self.functions = functions
 97         self.collection = None  # Set by the owning BuiltinsCollection
 98 
 99         for function in self.functions:
100             function.object = self
101 
102 
103 class BuiltinFunction:
104     def __init__(self, function_name, function_source, parameters, is_async, is_constructor, is_global_private, intrinsic, overridden_name):
105         self.function_name = function_name
106         self.function_source = function_source
107         self.parameters = parameters
108         self.is_async = is_async
109         self.is_constructor = is_constructor
110         self.is_global_private = is_global_private
111         self.intrinsic = intrinsic
112         self.overridden_name = overridden_name
113         self.object = None  # Set by the owning BuiltinObject
114 
115     @staticmethod
116     def fromString(function_string):
117         function_source = multilineCommentRegExp.sub(&quot;&quot;, function_string)
118 
119         intrinsic = &quot;NoIntrinsic&quot;
120         intrinsicMatch = functionIntrinsicRegExp.search(function_source)
121         if intrinsicMatch:
122             intrinsic = intrinsicMatch.group(1)
123             function_source = functionIntrinsicRegExp.sub(&quot;&quot;, function_source)
124 
125         overridden_name = None
126         overriddenNameMatch = functionOverriddenNameRegExp.search(function_source)
127         if overriddenNameMatch:
128             overridden_name = overriddenNameMatch.group(1)
129             function_source = functionOverriddenNameRegExp.sub(&quot;&quot;, function_source)
130 
131         if not os.getenv(&quot;CONFIGURATION&quot;, &quot;Debug&quot;).startswith(&quot;Debug&quot;):
132             function_source = lineWithOnlySingleLineCommentRegExp.sub(&quot;&quot;, function_source)
133             function_source = lineWithTrailingSingleLineCommentRegExp.sub(&quot;\n&quot;, function_source)
134             function_source = leadingWhitespaceRegExp.sub(&quot;&quot;, function_source)
135             function_source = multipleEmptyLinesRegExp.sub(&quot;\n&quot;, function_source)
136 
137         function_name = functionNameRegExp.findall(function_source)[0]
138         async_match = functionIsAsyncRegExp.match(function_source)
139         is_async = async_match != None and async_match.group(1) == &quot;async&quot;
140         is_constructor = functionIsConstructorRegExp.match(function_source) != None
141         is_getter = functionIsGetterRegExp.match(function_source) != None
142         is_global_private = functionGlobalPrivateRegExp.match(function_source) != None
143         parameters = [s.strip() for s in functionParameterFinder.findall(function_source)[0].split(&#39;,&#39;)]
144         if len(parameters[0]) == 0:
145             parameters = []
146 
147         if is_getter and not overridden_name:
148             overridden_name = &quot;\&quot;get %s\&quot;&quot; % (function_name)
149 
150         if not overridden_name:
151             overridden_name = &quot;static_cast&lt;const char*&gt;(nullptr)&quot;
152 
153         return BuiltinFunction(function_name, function_source, parameters, is_async, is_constructor, is_global_private, intrinsic, overridden_name)
154 
155     def __str__(self):
156         interface = &quot;%s(%s)&quot; % (self.function_name, &#39;, &#39;.join(self.parameters))
157         if self.is_constructor:
158             interface = interface + &quot; [Constructor]&quot;
159 
160         if self.is_async:
161             interface = &quot;async &quot; + interface
162 
163         return interface
164 
165     def __lt__(self, other):
166         return self.function_name &lt; other.function_name
167 
168 
169 class BuiltinsCollection:
170     def __init__(self, framework_name):
171         self._copyright_lines = set()
172         self.objects = []
173         self.framework = Framework.fromString(framework_name)
174         log.debug(&quot;Created new Builtins collection.&quot;)
175 
176     def parse_builtins_file(self, filename, text):
177         log.debug(&quot;Parsing builtins file: %s&quot; % filename)
178 
179         parsed_copyrights = set(self._parse_copyright_lines(text))
180         self._copyright_lines = self._copyright_lines.union(parsed_copyrights)
181 
182         log.debug(&quot;Found copyright lines:&quot;)
183         for line in self._copyright_lines:
184             log.debug(line)
185         log.debug(&quot;&quot;)
186 
187         object_annotations = self._parse_annotations(text)
188 
189         object_name, ext = os.path.splitext(os.path.basename(filename))
190         log.debug(&quot;Parsing object: %s&quot; % object_name)
191 
192         parsed_functions = self._parse_functions(text)
193         for function in parsed_functions:
194             function.object = object_name
195 
196         log.debug(&quot;Parsed functions:&quot;)
197         for func in parsed_functions:
198             log.debug(func)
199         log.debug(&quot;&quot;)
200 
201         new_object = BuiltinObject(object_name, object_annotations, parsed_functions)
202         new_object.collection = self
203         self.objects.append(new_object)
204 
205     def copyrights(self):
206         owner_to_years = dict()
207         copyrightYearRegExp = re.compile(r&quot;(\d{4})[, ]{0,2}&quot;)
208         ownerStartRegExp = re.compile(r&quot;[^\d, ]&quot;)
209 
210         # Returns deduplicated copyrights keyed on the owner.
211         for line in self._copyright_lines:
212             years = set(copyrightYearRegExp.findall(line))
213             ownerIndex = ownerStartRegExp.search(line).start()
214             owner = line[ownerIndex:]
215             log.debug(&quot;Found years: %s and owner: %s&quot; % (years, owner))
216             if owner not in owner_to_years:
217                 owner_to_years[owner] = set()
218 
219             owner_to_years[owner] = owner_to_years[owner].union(years)
220 
221         result = []
222 
223         for owner, years in list(owner_to_years.items()):
224             sorted_years = list(years)
225             sorted_years.sort()
226             result.append(&quot;%s %s&quot; % (&#39;, &#39;.join(sorted_years), owner))
227 
228         return result
229 
230     def all_functions(self):
231         result = []
232         for object in self.objects:
233             result.extend(object.functions)
234 
235         result.sort()
236         return result
237 
238     def all_internal_functions(self):
239         result = []
240         for object in [o for o in self.objects if &#39;internal&#39; in o.annotations]:
241             result.extend(object.functions)
242 
243         result.sort()
244         return result
245 
246     # Private methods.
247 
248     def _parse_copyright_lines(self, text):
249         licenseBlock = multilineCommentRegExp.findall(text)[0]
250         licenseBlock = licenseBlock[:licenseBlock.index(&quot;Redistribution&quot;)]
251 
252         copyrightLines = [Templates.DefaultCopyright]
253         for line in licenseBlock.split(&quot;\n&quot;):
254             line = line.replace(&quot;/*&quot;, &quot;&quot;)
255             line = line.replace(&quot;*/&quot;, &quot;&quot;)
256             line = line.replace(&quot;*&quot;, &quot;&quot;)
257             line = line.replace(&quot;Copyright&quot;, &quot;&quot;)
258             line = line.replace(&quot;copyright&quot;, &quot;&quot;)
259             line = line.replace(&quot;(C)&quot;, &quot;&quot;)
260             line = line.replace(&quot;(c)&quot;, &quot;&quot;)
261             line = line.strip()
262 
263             if len(line) == 0:
264                 continue
265 
266             copyrightLines.append(line)
267 
268         return copyrightLines
269 
270     def _parse_annotations(self, text):
271         annotations = {}
272 
273         for match in keyValueAnnotationCommentRegExp.finditer(text):
274             (key, value) = match.group(1, 2)
275             log.debug(&quot;Found annotation: &#39;%s&#39; =&gt; &#39;%s&#39;&quot; % (key, value))
276             if key in annotations:
277                 raise ParseException(&quot;Duplicate annotation found: %s&quot; % key)
278 
279             annotations[key] = value
280 
281         for match in flagAnnotationCommentRegExp.finditer(text):
282             key = match.group(1)
283             log.debug(&quot;Found annotation: &#39;%s&#39; =&gt; &#39;TRUE&#39;&quot; % key)
284             if key in annotations:
285                 raise ParseException(&quot;Duplicate annotation found: %s&quot; % key)
286 
287             annotations[key] = True
288 
289         return annotations
290 
291     def _parse_functions(self, text):
292         text = multilineCommentRegExp.sub(&quot;/**/&quot;, singleLineCommentRegExp.sub(&quot;//\n&quot;, text))
293 
294         matches = [func for func in functionHeadRegExp.finditer(text)]
295         functionBounds = []
296         start = 0
297         end = 0
298         for match in matches:
299             start = match.start()
300             if start &lt; end:
301                 continue
302             end = match.end()
303             while text[end] != &#39;{&#39;:
304                 end = end + 1
305             depth = 1
306             end = end + 1
307             while depth &gt; 0:
308                 if text[end] == &#39;{&#39;:
309                     depth = depth + 1
310                 elif text[end] == &#39;}&#39;:
311                     depth = depth - 1
312                 end = end + 1
313             functionBounds.append((start, end))
314 
315         functionStrings = [text[start:end].strip() for (start, end) in functionBounds]
316         return list(map(BuiltinFunction.fromString, functionStrings))
    </pre>
  </body>
</html>
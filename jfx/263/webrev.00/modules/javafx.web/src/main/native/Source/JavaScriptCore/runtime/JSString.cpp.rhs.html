<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSString.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (C) 1999-2002 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
  4  *  Copyright (C) 2004-2019 Apple Inc. All rights reserved.
  5  *
  6  *  This library is free software; you can redistribute it and/or
  7  *  modify it under the terms of the GNU Library General Public
  8  *  License as published by the Free Software Foundation; either
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Library General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Library General Public License
 17  *  along with this library; see the file COPYING.LIB.  If not, write to
 18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  *  Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;JSString.h&quot;
 25 
 26 #include &quot;JSGlobalObject.h&quot;
 27 #include &quot;JSGlobalObjectFunctions.h&quot;
 28 #include &quot;JSObject.h&quot;
 29 #include &quot;JSCInlines.h&quot;
 30 #include &quot;StringObject.h&quot;
 31 #include &quot;StringPrototype.h&quot;
 32 #include &quot;StrongInlines.h&quot;
 33 
 34 namespace JSC {
 35 
 36 const ClassInfo JSString::s_info = { &quot;string&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(JSString) };
 37 
 38 Structure* JSString::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue proto)
 39 {
 40     return Structure::create(vm, globalObject, proto, TypeInfo(StringType, StructureFlags), info());
 41 }
 42 
 43 JSString* JSString::createEmptyString(VM&amp; vm)
 44 {
 45     JSString* newString = new (NotNull, allocateCell&lt;JSString&gt;(vm.heap)) JSString(vm, *StringImpl::empty());
 46     newString-&gt;finishCreation(vm);
 47     return newString;
 48 }
 49 
 50 template&lt;&gt;
 51 void JSRopeString::RopeBuilder&lt;RecordOverflow&gt;::expand()
 52 {
 53     RELEASE_ASSERT(!this-&gt;hasOverflowed());
 54     ASSERT(m_strings.size() == JSRopeString::s_maxInternalRopeLength);
 55     static_assert(3 == JSRopeString::s_maxInternalRopeLength, &quot;&quot;);
 56     ASSERT(m_length);
 57     ASSERT(asString(m_strings.at(0))-&gt;length());
 58     ASSERT(asString(m_strings.at(1))-&gt;length());
 59     ASSERT(asString(m_strings.at(2))-&gt;length());
 60 
 61     JSString* string = JSRopeString::create(m_vm, asString(m_strings.at(0)), asString(m_strings.at(1)), asString(m_strings.at(2)));
 62     ASSERT(string-&gt;length() == m_length);
 63     m_strings.clear();
 64     m_strings.append(string);
 65 }
 66 
<a name="1" id="anc1"></a>




 67 void JSString::dumpToStream(const JSCell* cell, PrintStream&amp; out)
 68 {
 69     VM&amp; vm = cell-&gt;vm();
 70     const JSString* thisObject = jsCast&lt;const JSString*&gt;(cell);
 71     out.printf(&quot;&lt;%p, %s, [%u], &quot;, thisObject, thisObject-&gt;className(vm), thisObject-&gt;length());
 72     uintptr_t pointer = thisObject-&gt;m_fiber;
 73     if (pointer &amp; isRopeInPointer) {
 74         if (pointer &amp; JSRopeString::isSubstringInPointer)
 75             out.printf(&quot;[substring]&quot;);
 76         else
 77             out.printf(&quot;[rope]&quot;);
 78     } else {
 79         if (WTF::StringImpl* ourImpl = bitwise_cast&lt;StringImpl*&gt;(pointer)) {
 80             if (ourImpl-&gt;is8Bit())
 81                 out.printf(&quot;[8 %p]&quot;, ourImpl-&gt;characters8());
 82             else
 83                 out.printf(&quot;[16 %p]&quot;, ourImpl-&gt;characters16());
 84         }
 85     }
 86     out.printf(&quot;&gt;&quot;);
 87 }
 88 
<a name="2" id="anc2"></a><span class="line-modified"> 89 bool JSString::equalSlowCase(JSGlobalObject* globalObject, JSString* other) const</span>
 90 {
<a name="3" id="anc3"></a><span class="line-modified"> 91     VM&amp; vm = globalObject-&gt;vm();</span>
 92     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="4" id="anc4"></a><span class="line-modified"> 93     String str1 = value(globalObject);</span>
 94     RETURN_IF_EXCEPTION(scope, false);
<a name="5" id="anc5"></a><span class="line-modified"> 95     String str2 = other-&gt;value(globalObject);</span>
 96     RETURN_IF_EXCEPTION(scope, false);
 97     return WTF::equal(*str1.impl(), *str2.impl());
 98 }
 99 
100 size_t JSString::estimatedSize(JSCell* cell, VM&amp; vm)
101 {
102     JSString* thisObject = asString(cell);
103     uintptr_t pointer = thisObject-&gt;m_fiber;
104     if (pointer &amp; isRopeInPointer)
105         return Base::estimatedSize(cell, vm);
106     return Base::estimatedSize(cell, vm) + bitwise_cast&lt;StringImpl*&gt;(pointer)-&gt;costDuringGC();
107 }
108 
109 void JSString::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
110 {
111     JSString* thisObject = asString(cell);
112     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
113     Base::visitChildren(thisObject, visitor);
114 
115     uintptr_t pointer = thisObject-&gt;m_fiber;
116     if (pointer &amp; isRopeInPointer) {
117         if (pointer &amp; JSRopeString::isSubstringInPointer) {
118             visitor.appendUnbarriered(static_cast&lt;JSRopeString*&gt;(thisObject)-&gt;fiber1());
119             return;
120         }
121         for (unsigned index = 0; index &lt; JSRopeString::s_maxInternalRopeLength; ++index) {
122             JSString* fiber = nullptr;
123             switch (index) {
124             case 0:
125                 fiber = bitwise_cast&lt;JSString*&gt;(pointer &amp; JSRopeString::stringMask);
126                 break;
127             case 1:
128                 fiber = static_cast&lt;JSRopeString*&gt;(thisObject)-&gt;fiber1();
129                 break;
130             case 2:
131                 fiber = static_cast&lt;JSRopeString*&gt;(thisObject)-&gt;fiber2();
132                 break;
133             default:
134                 ASSERT_NOT_REACHED();
135                 return;
136             }
137             if (!fiber)
138                 break;
139             visitor.appendUnbarriered(fiber);
140         }
141         return;
142     }
143     if (StringImpl* impl = bitwise_cast&lt;StringImpl*&gt;(pointer))
144         visitor.reportExtraMemoryVisited(impl-&gt;costDuringGC());
145 }
146 
<a name="6" id="anc6"></a><span class="line-modified">147 static constexpr unsigned maxLengthForOnStackResolve = 2048;</span>
148 
149 void JSRopeString::resolveRopeInternal8(LChar* buffer) const
150 {
151     if (isSubstring()) {
152         StringImpl::copyCharacters(buffer, substringBase()-&gt;valueInternal().characters8() + substringOffset(), length());
153         return;
154     }
155 
<a name="7" id="anc7"></a><span class="line-modified">156     resolveRopeInternalNoSubstring(buffer);</span>



















157 }
158 
159 void JSRopeString::resolveRopeInternal16(UChar* buffer) const
160 {
161     if (isSubstring()) {
162         StringImpl::copyCharacters(
163             buffer, substringBase()-&gt;valueInternal().characters16() + substringOffset(), length());
164         return;
165     }
166 
<a name="8" id="anc8"></a><span class="line-modified">167     resolveRopeInternalNoSubstring(buffer);</span>
168 }
169 
<a name="9" id="anc9"></a><span class="line-modified">170 template&lt;typename CharacterType&gt;</span>
<span class="line-added">171 void JSRopeString::resolveRopeInternalNoSubstring(CharacterType* buffer) const</span>
172 {
173     for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i) {
174         if (fiber(i)-&gt;isRope()) {
175             resolveRopeSlowCase(buffer);
176             return;
177         }
178     }
179 
<a name="10" id="anc10"></a><span class="line-modified">180     CharacterType* position = buffer;</span>
181     for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i) {
182         const StringImpl&amp; fiberString = *fiber(i)-&gt;valueInternal().impl();
183         unsigned length = fiberString.length();
184         if (fiberString.is8Bit())
185             StringImpl::copyCharacters(position, fiberString.characters8(), length);
186         else
187             StringImpl::copyCharacters(position, fiberString.characters16(), length);
188         position += length;
189     }
190     ASSERT((buffer + length()) == position);
191 }
192 
<a name="11" id="anc11"></a><span class="line-modified">193 AtomString JSRopeString::resolveRopeToAtomString(JSGlobalObject* globalObject) const</span>
194 {
<a name="12" id="anc12"></a><span class="line-modified">195     VM&amp; vm = globalObject-&gt;vm();</span>
196     auto scope = DECLARE_THROW_SCOPE(vm);
197 
198     if (length() &gt; maxLengthForOnStackResolve) {
199         scope.release();
<a name="13" id="anc13"></a><span class="line-modified">200         return resolveRopeWithFunction(globalObject, [&amp;] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) {</span>
201             return AtomStringImpl::add(newImpl.ptr());
202         });
203     }
204 
205     if (is8Bit()) {
206         LChar buffer[maxLengthForOnStackResolve];
207         resolveRopeInternal8(buffer);
208         convertToNonRope(AtomStringImpl::add(buffer, length()));
209     } else {
210         UChar buffer[maxLengthForOnStackResolve];
211         resolveRopeInternal16(buffer);
212         convertToNonRope(AtomStringImpl::add(buffer, length()));
213     }
214 
215     // If we resolved a string that didn&#39;t previously exist, notify the heap that we&#39;ve grown.
216     if (valueInternal().impl()-&gt;hasOneRef())
217         vm.heap.reportExtraMemoryAllocated(valueInternal().impl()-&gt;cost());
218     return valueInternal();
219 }
220 
221 inline void JSRopeString::convertToNonRope(String&amp;&amp; string) const
222 {
223     // Concurrent compiler threads can access String held by JSString. So we always emit
224     // store-store barrier here to ensure concurrent compiler threads see initialized String.
225     ASSERT(JSString::isRope());
226     WTF::storeStoreFence();
227     new (&amp;uninitializedValueInternal()) String(WTFMove(string));
228     static_assert(sizeof(String) == sizeof(RefPtr&lt;StringImpl&gt;), &quot;JSString&#39;s String initialization must be done in one pointer move.&quot;);
229     // We do not clear the trailing fibers and length information (fiber1 and fiber2) because we could be reading the length concurrently.
230     ASSERT(!JSString::isRope());
231 }
232 
<a name="14" id="anc14"></a><span class="line-modified">233 RefPtr&lt;AtomStringImpl&gt; JSRopeString::resolveRopeToExistingAtomString(JSGlobalObject* globalObject) const</span>
234 {
<a name="15" id="anc15"></a><span class="line-modified">235     VM&amp; vm = globalObject-&gt;vm();</span>
236     auto scope = DECLARE_THROW_SCOPE(vm);
237 
238     if (length() &gt; maxLengthForOnStackResolve) {
239         RefPtr&lt;AtomStringImpl&gt; existingAtomString;
<a name="16" id="anc16"></a><span class="line-modified">240         resolveRopeWithFunction(globalObject, [&amp;] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) -&gt; Ref&lt;StringImpl&gt; {</span>
241             existingAtomString = AtomStringImpl::lookUp(newImpl.ptr());
242             if (existingAtomString)
243                 return makeRef(*existingAtomString);
244             return WTFMove(newImpl);
245         });
246         RETURN_IF_EXCEPTION(scope, nullptr);
247         return existingAtomString;
248     }
249 
250     if (is8Bit()) {
251         LChar buffer[maxLengthForOnStackResolve];
252         resolveRopeInternal8(buffer);
253         if (RefPtr&lt;AtomStringImpl&gt; existingAtomString = AtomStringImpl::lookUp(buffer, length())) {
254             convertToNonRope(*existingAtomString);
255             return existingAtomString;
256         }
257     } else {
258         UChar buffer[maxLengthForOnStackResolve];
259         resolveRopeInternal16(buffer);
260         if (RefPtr&lt;AtomStringImpl&gt; existingAtomString = AtomStringImpl::lookUp(buffer, length())) {
261             convertToNonRope(*existingAtomString);
262             return existingAtomString;
263         }
264     }
265 
266     return nullptr;
267 }
268 
269 template&lt;typename Function&gt;
<a name="17" id="anc17"></a><span class="line-modified">270 const String&amp; JSRopeString::resolveRopeWithFunction(JSGlobalObject* nullOrGlobalObjectForOOM, Function&amp;&amp; function) const</span>
271 {
272     ASSERT(isRope());
273 
274     VM&amp; vm = this-&gt;vm();
275     if (isSubstring()) {
276         ASSERT(!substringBase()-&gt;isRope());
277         auto newImpl = substringBase()-&gt;valueInternal().substringSharingImpl(substringOffset(), length());
278         convertToNonRope(function(newImpl.releaseImpl().releaseNonNull()));
279         return valueInternal();
280     }
281 
282     if (is8Bit()) {
283         LChar* buffer;
284         auto newImpl = StringImpl::tryCreateUninitialized(length(), buffer);
285         if (!newImpl) {
<a name="18" id="anc18"></a><span class="line-modified">286             outOfMemory(nullOrGlobalObjectForOOM);</span>
287             return nullString();
288         }
289         vm.heap.reportExtraMemoryAllocated(newImpl-&gt;cost());
290 
<a name="19" id="anc19"></a><span class="line-modified">291         resolveRopeInternalNoSubstring(buffer);</span>
292         convertToNonRope(function(newImpl.releaseNonNull()));
293         return valueInternal();
294     }
295 
296     UChar* buffer;
297     auto newImpl = StringImpl::tryCreateUninitialized(length(), buffer);
298     if (!newImpl) {
<a name="20" id="anc20"></a><span class="line-modified">299         outOfMemory(nullOrGlobalObjectForOOM);</span>
300         return nullString();
301     }
302     vm.heap.reportExtraMemoryAllocated(newImpl-&gt;cost());
303 
<a name="21" id="anc21"></a><span class="line-modified">304     resolveRopeInternalNoSubstring(buffer);</span>
305     convertToNonRope(function(newImpl.releaseNonNull()));
306     return valueInternal();
307 }
308 
<a name="22" id="anc22"></a><span class="line-modified">309 const String&amp; JSRopeString::resolveRope(JSGlobalObject* nullOrGlobalObjectForOOM) const</span>
310 {
<a name="23" id="anc23"></a><span class="line-modified">311     return resolveRopeWithFunction(nullOrGlobalObjectForOOM, [] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) {</span>
312         return WTFMove(newImpl);
313     });
314 }
315 
316 // Overview: These functions convert a JSString from holding a string in rope form
317 // down to a simple String representation. It does so by building up the string
318 // backwards, since we want to avoid recursion, we expect that the tree structure
319 // representing the rope is likely imbalanced with more nodes down the left side
320 // (since appending to the string is likely more common) - and as such resolving
321 // in this fashion should minimize work queue size.  (If we built the queue forwards
322 // we would likely have to place all of the constituent StringImpls into the
323 // Vector before performing any concatenation, but by working backwards we likely
324 // only fill the queue with the number of substrings at any given level in a
325 // rope-of-ropes.)
<a name="24" id="anc24"></a><span class="line-modified">326 template&lt;typename CharacterType&gt;</span>
<span class="line-modified">327 void JSRopeString::resolveRopeSlowCase(CharacterType* buffer) const</span>



































328 {
<a name="25" id="anc25"></a><span class="line-modified">329     CharacterType* position = buffer + length(); // We will be working backwards over the rope.</span>
330     Vector&lt;JSString*, 32, UnsafeVectorOverflow&gt; workQueue; // These strings are kept alive by the parent rope, so using a Vector is OK.
331 
332     for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i)
333         workQueue.append(fiber(i));
334 
335     while (!workQueue.isEmpty()) {
336         JSString* currentFiber = workQueue.last();
337         workQueue.removeLast();
338 
339         if (currentFiber-&gt;isRope()) {
340             JSRopeString* currentFiberAsRope = static_cast&lt;JSRopeString*&gt;(currentFiber);
341             if (currentFiberAsRope-&gt;isSubstring()) {
342                 ASSERT(!currentFiberAsRope-&gt;substringBase()-&gt;isRope());
343                 StringImpl* string = static_cast&lt;StringImpl*&gt;(
344                     currentFiberAsRope-&gt;substringBase()-&gt;valueInternal().impl());
345                 unsigned offset = currentFiberAsRope-&gt;substringOffset();
346                 unsigned length = currentFiberAsRope-&gt;length();
347                 position -= length;
348                 if (string-&gt;is8Bit())
349                     StringImpl::copyCharacters(position, string-&gt;characters8() + offset, length);
350                 else
351                     StringImpl::copyCharacters(position, string-&gt;characters16() + offset, length);
352                 continue;
353             }
354             for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; currentFiberAsRope-&gt;fiber(i); ++i)
355                 workQueue.append(currentFiberAsRope-&gt;fiber(i));
356             continue;
357         }
358 
359         StringImpl* string = static_cast&lt;StringImpl*&gt;(currentFiber-&gt;valueInternal().impl());
360         unsigned length = string-&gt;length();
361         position -= length;
362         if (string-&gt;is8Bit())
363             StringImpl::copyCharacters(position, string-&gt;characters8(), length);
364         else
365             StringImpl::copyCharacters(position, string-&gt;characters16(), length);
366     }
367 
368     ASSERT(buffer == position);
369 }
370 
<a name="26" id="anc26"></a><span class="line-modified">371 void JSRopeString::outOfMemory(JSGlobalObject* nullOrGlobalObjectForOOM) const</span>
372 {
373     ASSERT(isRope());
<a name="27" id="anc27"></a><span class="line-modified">374     if (nullOrGlobalObjectForOOM) {</span>
<span class="line-modified">375         VM&amp; vm = nullOrGlobalObjectForOOM-&gt;vm();</span>
376         auto scope = DECLARE_THROW_SCOPE(vm);
<a name="28" id="anc28"></a><span class="line-modified">377         throwOutOfMemoryError(nullOrGlobalObjectForOOM, scope);</span>
378     }
379 }
380 
<a name="29" id="anc29"></a><span class="line-modified">381 JSValue JSString::toPrimitive(JSGlobalObject*, PreferredPrimitiveType) const</span>
382 {
383     return const_cast&lt;JSString*&gt;(this);
384 }
385 
<a name="30" id="anc30"></a><span class="line-modified">386 bool JSString::getPrimitiveNumber(JSGlobalObject* globalObject, double&amp; number, JSValue&amp; result) const</span>
387 {
<a name="31" id="anc31"></a><span class="line-modified">388     VM&amp; vm = globalObject-&gt;vm();</span>
389     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="32" id="anc32"></a><span class="line-modified">390     StringView view = unsafeView(globalObject);</span>
391     RETURN_IF_EXCEPTION(scope, false);
392     result = this;
393     number = jsToNumber(view);
394     return false;
395 }
396 
<a name="33" id="anc33"></a><span class="line-modified">397 double JSString::toNumber(JSGlobalObject* globalObject) const</span>
398 {
<a name="34" id="anc34"></a><span class="line-modified">399     VM&amp; vm = globalObject-&gt;vm();</span>
400     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="35" id="anc35"></a><span class="line-modified">401     StringView view = unsafeView(globalObject);</span>
402     RETURN_IF_EXCEPTION(scope, 0);
403     return jsToNumber(view);
404 }
405 
406 inline StringObject* StringObject::create(VM&amp; vm, JSGlobalObject* globalObject, JSString* string)
407 {
408     StringObject* object = new (NotNull, allocateCell&lt;StringObject&gt;(vm.heap)) StringObject(vm, globalObject-&gt;stringObjectStructure());
409     object-&gt;finishCreation(vm, string);
410     return object;
411 }
412 
<a name="36" id="anc36"></a><span class="line-modified">413 JSObject* JSString::toObject(JSGlobalObject* globalObject) const</span>
414 {
<a name="37" id="anc37"></a><span class="line-modified">415     return StringObject::create(globalObject-&gt;vm(), globalObject, const_cast&lt;JSString*&gt;(this));</span>
416 }
417 
<a name="38" id="anc38"></a><span class="line-modified">418 JSValue JSString::toThis(JSCell* cell, JSGlobalObject* globalObject, ECMAMode ecmaMode)</span>
419 {
420     if (ecmaMode == StrictMode)
421         return cell;
<a name="39" id="anc39"></a><span class="line-modified">422     return StringObject::create(globalObject-&gt;vm(), globalObject, asString(cell));</span>
423 }
424 
<a name="40" id="anc40"></a><span class="line-modified">425 bool JSString::getStringPropertyDescriptor(JSGlobalObject* globalObject, PropertyName propertyName, PropertyDescriptor&amp; descriptor)</span>
426 {
<a name="41" id="anc41"></a><span class="line-modified">427     VM&amp; vm = globalObject-&gt;vm();</span>
428     if (propertyName == vm.propertyNames-&gt;length) {
429         descriptor.setDescriptor(jsNumber(length()), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
430         return true;
431     }
432 
433     Optional&lt;uint32_t&gt; index = parseIndex(propertyName);
434     if (index &amp;&amp; index.value() &lt; length()) {
<a name="42" id="anc42"></a><span class="line-modified">435         descriptor.setDescriptor(getIndex(globalObject, index.value()), PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);</span>
436         return true;
437     }
438 
439     return false;
440 }
441 
442 JSString* jsStringWithCacheSlowCase(VM&amp; vm, StringImpl&amp; stringImpl)
443 {
444     if (JSString* string = vm.stringCache.get(&amp;stringImpl))
445         return string;
446 
447     JSString* string = jsString(vm, String(stringImpl));
448     vm.lastCachedString.set(vm, string);
449     return string;
450 }
451 
452 } // namespace JSC
<a name="43" id="anc43"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="43" type="hidden" />
</body>
</html>
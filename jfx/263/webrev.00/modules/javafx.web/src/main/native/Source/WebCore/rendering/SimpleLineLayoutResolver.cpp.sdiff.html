<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutResolver.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SimpleLineLayoutFunctions.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SimpleLineLayoutResolver.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutResolver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 50 }
 51 
 52 String RunResolver::Run::textWithHyphen() const
 53 {
 54     auto&amp; run = m_iterator.simpleRun();
 55     ASSERT(run.hasHyphen);
 56     // Empty runs should not have hyphen.
 57     ASSERT(run.start &lt; run.end);
 58     auto&amp; segment = m_iterator.resolver().m_flowContents.segmentForRun(run.start, run.end);
 59     auto text = StringView(segment.text).substring(segment.toSegmentPosition(run.start), run.end - run.start);
 60     return makeString(text, m_iterator.resolver().flow().style().hyphenString());
 61 }
 62 
 63 FloatRect RunResolver::Run::rect() const
 64 {
 65     auto&amp; run = m_iterator.simpleRun();
 66     auto&amp; resolver = m_iterator.resolver();
 67     float baseline = computeBaselinePosition();
 68     FloatPoint position = linePosition(run.logicalLeft, baseline - resolver.m_ascent);
 69     FloatSize size = lineSize(run.logicalLeft, run.logicalRight, resolver.m_ascent + resolver.m_descent + resolver.m_visualOverflowOffset);
<span class="line-modified"> 70     bool moveLineBreakToBaseline = false;</span>
<span class="line-removed"> 71     if (run.start == run.end &amp;&amp; m_iterator != resolver.begin() &amp;&amp; m_iterator.inQuirksMode()) {</span>
<span class="line-removed"> 72         auto previousRun = m_iterator;</span>
<span class="line-removed"> 73         --previousRun;</span>
<span class="line-removed"> 74         moveLineBreakToBaseline = !previousRun.simpleRun().isEndOfLine;</span>
<span class="line-removed"> 75     }</span>
<span class="line-removed"> 76     if (moveLineBreakToBaseline)</span>
<span class="line-removed"> 77         return FloatRect(FloatPoint(position.x(), baseline), FloatSize(size.width(), std::max&lt;float&gt;(0, resolver.m_ascent - resolver.m_baseline.toFloat())));</span>
 78     return FloatRect(position, size);
 79 }
 80 
 81 StringView RunResolver::Run::text() const
 82 {
 83     auto&amp; run = m_iterator.simpleRun();
 84     ASSERT(run.start &lt; run.end);
 85     auto&amp; segment = m_iterator.resolver().m_flowContents.segmentForRun(run.start, run.end);
 86     // We currently split runs on segment boundaries (different RenderObject).
 87     ASSERT(run.end &lt;= segment.end);
 88     return StringView(segment.text).substring(segment.toSegmentPosition(run.start), run.end - run.start);
 89 }
 90 
 91 const RenderObject&amp; RunResolver::Run::renderer() const
 92 {
 93     auto&amp; run = m_iterator.simpleRun();
 94     // FlowContents cannot differentiate empty runs.
 95     ASSERT(run.start != run.end);
 96     return m_iterator.resolver().m_flowContents.segmentForRun(run.start, run.end).renderer;
 97 }
 98 
 99 unsigned RunResolver::Run::localStart() const
100 {
101     auto&amp; run = m_iterator.simpleRun();
102     // FlowContents cannot differentiate empty runs.
103     ASSERT(run.start != run.end);
104     return m_iterator.resolver().m_flowContents.segmentForRun(run.start, run.end).toSegmentPosition(run.start);
105 }
106 
107 unsigned RunResolver::Run::localEnd() const
108 {
109     auto&amp; run = m_iterator.simpleRun();
110     // FlowContents cannot differentiate empty runs.
111     ASSERT(run.start != run.end);
112     return m_iterator.resolver().m_flowContents.segmentForRun(run.start, run.end).toSegmentPosition(run.end);
113 }
114 
115 RunResolver::Iterator::Iterator(const RunResolver&amp; resolver, unsigned runIndex, unsigned lineIndex)
<span class="line-modified">116     : m_resolver(resolver)</span>

117     , m_runIndex(runIndex)
118     , m_lineIndex(lineIndex)
119 {

120 }
121 
122 RunResolver::Iterator&amp; RunResolver::Iterator::advance()
123 {
124     if (simpleRun().isEndOfLine)
125         ++m_lineIndex;
126     ++m_runIndex;
127     return *this;
128 }
129 
130 RunResolver::Iterator&amp; RunResolver::Iterator::advanceLines(unsigned lineCount)
131 {
<span class="line-modified">132     unsigned runCount = m_resolver.m_layout.runCount();</span>
<span class="line-modified">133     if (runCount == m_resolver.m_layout.lineCount()) {</span>
134         m_runIndex = std::min(runCount, m_runIndex + lineCount);
135         m_lineIndex = m_runIndex;
136         return *this;
137     }
138     unsigned target = m_lineIndex + lineCount;
139     while (m_lineIndex &lt; target &amp;&amp; m_runIndex &lt; runCount)
140         advance();
141 
142     return *this;
143 }
144 
145 RunResolver::RunResolver(const RenderBlockFlow&amp; flow, const Layout&amp; layout)
146     : m_flowRenderer(flow)
147     , m_layout(layout)
148     , m_flowContents(flow)
149     , m_lineHeight(lineHeightFromFlow(flow))
150     , m_baseline(baselineFromFlow(flow))
151     , m_borderAndPaddingBefore(flow.borderAndPaddingBefore())
152     , m_ascent(flow.style().fontCascade().fontMetrics().ascent())
153     , m_descent(flow.style().fontCascade().fontMetrics().descent())
154     , m_visualOverflowOffset(visualOverflowForDecorations(flow.style(), nullptr).bottom)
<span class="line-removed">155     , m_inQuirksMode(flow.document().inQuirksMode())</span>
156 {
157 }
158 
159 unsigned RunResolver::adjustLineIndexForStruts(LayoutUnit y, IndexType type, unsigned lineIndexCandidate) const
160 {
161     auto&amp; struts = m_layout.struts();
162     // We need to offset the lineIndex with line struts when there&#39;s an actual strut before the candidate.
163     auto&amp; strut = struts.first();
164     if (strut.lineBreak &gt;= lineIndexCandidate)
165         return lineIndexCandidate;
166     unsigned strutIndex = 0;
167     Optional&lt;unsigned&gt; lastIndexCandidate;
168     auto top = strut.lineBreak * m_lineHeight;
169     auto lineHeightWithOverflow = m_lineHeight;
170     // If font is larger than the line height (glyphs overflow), use the font size when checking line boundaries.
171     if (m_ascent + m_descent &gt; m_lineHeight) {
172         lineHeightWithOverflow = m_ascent + m_descent;
173         top += m_baseline - m_ascent;
174     }
175     auto bottom = top + lineHeightWithOverflow;
</pre>
<hr />
<pre>
286     while (it != end() &amp;&amp; (*it).logicalRight() &lt; x &amp;&amp; lineIndex == it.lineIndex())
287         ++it;
288     // We jumped to the next line so the point is at the right side of the previous line.
289     if (it.lineIndex() &gt; lineIndex)
290         return --it;
291     // Now we have a candidate run.
292     // Find the last run that still contains this point (taking overlapping runs with odd word spacing values into account).
293     while (it != end() &amp;&amp; (*it).logicalLeft() &lt;= x &amp;&amp; lineIndex == it.lineIndex())
294         ++it;
295     return --it;
296 }
297 
298 WTF::IteratorRange&lt;RunResolver::Iterator&gt; RunResolver::rangeForRendererWithOffsets(const RenderObject&amp; renderer, unsigned startOffset, unsigned endOffset) const
299 {
300     ASSERT(startOffset &lt;= endOffset);
301     auto range = rangeForRenderer(renderer);
302     if (range.begin() == range.end())
303         return { end(), end() };
304     auto it = range.begin();
305     auto localEnd = (*it).start() + endOffset;
<span class="line-modified">306     // Advance to the first run with the start offset inside. Only the first node in a range can have a startOffset.</span>
<span class="line-modified">307     while (it != range.end() &amp;&amp; (*it).end() &lt;= startOffset)</span>


308         ++it;
309     if (it == range.end())
310         return { end(), end() };
311     auto rangeBegin = it;
312     // Special case empty ranges that start at the edge of the run. Apparently normal line layout include those.
313     if (localEnd == startOffset &amp;&amp; (*it).start() == localEnd)
314         return { rangeBegin, ++it };
315     // Advance beyond the last run with the end offset.
316     while (it != range.end() &amp;&amp; (*it).start() &lt; localEnd)
317         ++it;
318     return { rangeBegin, it };
319 }
320 
321 LineResolver::Iterator::Iterator(RunResolver::Iterator runIterator)
322     : m_runIterator(runIterator)
323 {
324 }
325 
326 FloatRect LineResolver::Iterator::operator*() const
327 {
</pre>
</td>
<td>
<hr />
<pre>
 50 }
 51 
 52 String RunResolver::Run::textWithHyphen() const
 53 {
 54     auto&amp; run = m_iterator.simpleRun();
 55     ASSERT(run.hasHyphen);
 56     // Empty runs should not have hyphen.
 57     ASSERT(run.start &lt; run.end);
 58     auto&amp; segment = m_iterator.resolver().m_flowContents.segmentForRun(run.start, run.end);
 59     auto text = StringView(segment.text).substring(segment.toSegmentPosition(run.start), run.end - run.start);
 60     return makeString(text, m_iterator.resolver().flow().style().hyphenString());
 61 }
 62 
 63 FloatRect RunResolver::Run::rect() const
 64 {
 65     auto&amp; run = m_iterator.simpleRun();
 66     auto&amp; resolver = m_iterator.resolver();
 67     float baseline = computeBaselinePosition();
 68     FloatPoint position = linePosition(run.logicalLeft, baseline - resolver.m_ascent);
 69     FloatSize size = lineSize(run.logicalLeft, run.logicalRight, resolver.m_ascent + resolver.m_descent + resolver.m_visualOverflowOffset);
<span class="line-modified"> 70 </span>







 71     return FloatRect(position, size);
 72 }
 73 
 74 StringView RunResolver::Run::text() const
 75 {
 76     auto&amp; run = m_iterator.simpleRun();
 77     ASSERT(run.start &lt; run.end);
 78     auto&amp; segment = m_iterator.resolver().m_flowContents.segmentForRun(run.start, run.end);
 79     // We currently split runs on segment boundaries (different RenderObject).
 80     ASSERT(run.end &lt;= segment.end);
 81     return StringView(segment.text).substring(segment.toSegmentPosition(run.start), run.end - run.start);
 82 }
 83 
 84 const RenderObject&amp; RunResolver::Run::renderer() const
 85 {
 86     auto&amp; run = m_iterator.simpleRun();
 87     // FlowContents cannot differentiate empty runs.
 88     ASSERT(run.start != run.end);
 89     return m_iterator.resolver().m_flowContents.segmentForRun(run.start, run.end).renderer;
 90 }
 91 
 92 unsigned RunResolver::Run::localStart() const
 93 {
 94     auto&amp; run = m_iterator.simpleRun();
 95     // FlowContents cannot differentiate empty runs.
 96     ASSERT(run.start != run.end);
 97     return m_iterator.resolver().m_flowContents.segmentForRun(run.start, run.end).toSegmentPosition(run.start);
 98 }
 99 
100 unsigned RunResolver::Run::localEnd() const
101 {
102     auto&amp; run = m_iterator.simpleRun();
103     // FlowContents cannot differentiate empty runs.
104     ASSERT(run.start != run.end);
105     return m_iterator.resolver().m_flowContents.segmentForRun(run.start, run.end).toSegmentPosition(run.end);
106 }
107 
108 RunResolver::Iterator::Iterator(const RunResolver&amp; resolver, unsigned runIndex, unsigned lineIndex)
<span class="line-modified">109     : m_layout(&amp;resolver.m_layout)</span>
<span class="line-added">110     , m_resolver(&amp;resolver)</span>
111     , m_runIndex(runIndex)
112     , m_lineIndex(lineIndex)
113 {
<span class="line-added">114     ASSERT(&amp;resolver == &amp;m_layout-&gt;runResolver());</span>
115 }
116 
117 RunResolver::Iterator&amp; RunResolver::Iterator::advance()
118 {
119     if (simpleRun().isEndOfLine)
120         ++m_lineIndex;
121     ++m_runIndex;
122     return *this;
123 }
124 
125 RunResolver::Iterator&amp; RunResolver::Iterator::advanceLines(unsigned lineCount)
126 {
<span class="line-modified">127     unsigned runCount = layout().runCount();</span>
<span class="line-modified">128     if (runCount == layout().lineCount()) {</span>
129         m_runIndex = std::min(runCount, m_runIndex + lineCount);
130         m_lineIndex = m_runIndex;
131         return *this;
132     }
133     unsigned target = m_lineIndex + lineCount;
134     while (m_lineIndex &lt; target &amp;&amp; m_runIndex &lt; runCount)
135         advance();
136 
137     return *this;
138 }
139 
140 RunResolver::RunResolver(const RenderBlockFlow&amp; flow, const Layout&amp; layout)
141     : m_flowRenderer(flow)
142     , m_layout(layout)
143     , m_flowContents(flow)
144     , m_lineHeight(lineHeightFromFlow(flow))
145     , m_baseline(baselineFromFlow(flow))
146     , m_borderAndPaddingBefore(flow.borderAndPaddingBefore())
147     , m_ascent(flow.style().fontCascade().fontMetrics().ascent())
148     , m_descent(flow.style().fontCascade().fontMetrics().descent())
149     , m_visualOverflowOffset(visualOverflowForDecorations(flow.style(), nullptr).bottom)

150 {
151 }
152 
153 unsigned RunResolver::adjustLineIndexForStruts(LayoutUnit y, IndexType type, unsigned lineIndexCandidate) const
154 {
155     auto&amp; struts = m_layout.struts();
156     // We need to offset the lineIndex with line struts when there&#39;s an actual strut before the candidate.
157     auto&amp; strut = struts.first();
158     if (strut.lineBreak &gt;= lineIndexCandidate)
159         return lineIndexCandidate;
160     unsigned strutIndex = 0;
161     Optional&lt;unsigned&gt; lastIndexCandidate;
162     auto top = strut.lineBreak * m_lineHeight;
163     auto lineHeightWithOverflow = m_lineHeight;
164     // If font is larger than the line height (glyphs overflow), use the font size when checking line boundaries.
165     if (m_ascent + m_descent &gt; m_lineHeight) {
166         lineHeightWithOverflow = m_ascent + m_descent;
167         top += m_baseline - m_ascent;
168     }
169     auto bottom = top + lineHeightWithOverflow;
</pre>
<hr />
<pre>
280     while (it != end() &amp;&amp; (*it).logicalRight() &lt; x &amp;&amp; lineIndex == it.lineIndex())
281         ++it;
282     // We jumped to the next line so the point is at the right side of the previous line.
283     if (it.lineIndex() &gt; lineIndex)
284         return --it;
285     // Now we have a candidate run.
286     // Find the last run that still contains this point (taking overlapping runs with odd word spacing values into account).
287     while (it != end() &amp;&amp; (*it).logicalLeft() &lt;= x &amp;&amp; lineIndex == it.lineIndex())
288         ++it;
289     return --it;
290 }
291 
292 WTF::IteratorRange&lt;RunResolver::Iterator&gt; RunResolver::rangeForRendererWithOffsets(const RenderObject&amp; renderer, unsigned startOffset, unsigned endOffset) const
293 {
294     ASSERT(startOffset &lt;= endOffset);
295     auto range = rangeForRenderer(renderer);
296     if (range.begin() == range.end())
297         return { end(), end() };
298     auto it = range.begin();
299     auto localEnd = (*it).start() + endOffset;
<span class="line-modified">300     // Advance to the first run before the start offset. Only the first node in a range can have a startOffset.</span>
<span class="line-modified">301     // Note that the start offset may coincide with the end of a run. The run is still considered so that we</span>
<span class="line-added">302     // can return an empty rect, which conforms to the behavior of Element.getClientRects().</span>
<span class="line-added">303     while (it != range.end() &amp;&amp; (*it).end() &lt; startOffset)</span>
304         ++it;
305     if (it == range.end())
306         return { end(), end() };
307     auto rangeBegin = it;
308     // Special case empty ranges that start at the edge of the run. Apparently normal line layout include those.
309     if (localEnd == startOffset &amp;&amp; (*it).start() == localEnd)
310         return { rangeBegin, ++it };
311     // Advance beyond the last run with the end offset.
312     while (it != range.end() &amp;&amp; (*it).start() &lt; localEnd)
313         ++it;
314     return { rangeBegin, it };
315 }
316 
317 LineResolver::Iterator::Iterator(RunResolver::Iterator runIterator)
318     : m_runIterator(runIterator)
319 {
320 }
321 
322 FloatRect LineResolver::Iterator::operator*() const
323 {
</pre>
</td>
</tr>
</table>
<center><a href="SimpleLineLayoutFunctions.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SimpleLineLayoutResolver.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
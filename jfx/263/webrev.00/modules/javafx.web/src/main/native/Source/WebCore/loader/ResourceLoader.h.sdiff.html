<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/ResourceLoader.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ResourceLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ResourceLoaderOptions.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/ResourceLoader.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 34 #include &quot;ResourceLoaderTypes.h&quot;
 35 #include &quot;ResourceRequest.h&quot;
 36 #include &quot;ResourceResponse.h&quot;
 37 #include &lt;wtf/Forward.h&gt;
 38 #include &lt;wtf/WeakPtr.h&gt;
 39 
 40 #if ENABLE(CONTENT_EXTENSIONS)
 41 #include &quot;ResourceLoadInfo.h&quot;
 42 #endif
 43 
 44 namespace WTF {
 45 class SchedulePair;
 46 }
 47 
 48 namespace WebCore {
 49 
 50 class AuthenticationChallenge;
 51 class DocumentLoader;
 52 class Frame;
 53 class FrameLoader;

 54 class NetworkLoadMetrics;
<span class="line-removed"> 55 class PreviewLoader;</span>
 56 

 57 class ResourceLoader : public CanMakeWeakPtr&lt;ResourceLoader&gt;, public RefCounted&lt;ResourceLoader&gt;, protected ResourceHandleClient {

 58 public:
 59     virtual ~ResourceLoader() = 0;
 60 
 61     WEBCORE_EXPORT void cancel();
 62 
 63     virtual void init(ResourceRequest&amp;&amp;, CompletionHandler&lt;void(bool)&gt;&amp;&amp;);
 64 
 65     void deliverResponseAndData(const ResourceResponse&amp;, RefPtr&lt;SharedBuffer&gt;&amp;&amp;);
 66 
 67 #if PLATFORM(IOS_FAMILY)
 68     virtual void startLoading()
 69     {
 70         start();
 71     }
 72 
 73     virtual const ResourceRequest&amp; iOSOriginalRequest() const { return request(); }
 74 #endif
 75 
 76     WEBCORE_EXPORT FrameLoader* frameLoader() const;
 77     DocumentLoader* documentLoader() const { return m_documentLoader.get(); }
</pre>
<hr />
<pre>
100     virtual bool isSubresourceLoader() const;
101 
102     virtual void willSendRequest(ResourceRequest&amp;&amp;, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; callback);
103     virtual void didSendData(unsigned long long bytesSent, unsigned long long totalBytesToBeSent);
104     virtual void didReceiveResponse(const ResourceResponse&amp;, CompletionHandler&lt;void()&gt;&amp;&amp; policyCompletionHandler);
105     virtual void didReceiveData(const char*, unsigned, long long encodedDataLength, DataPayloadType);
106     virtual void didReceiveBuffer(Ref&lt;SharedBuffer&gt;&amp;&amp;, long long encodedDataLength, DataPayloadType);
107     virtual void didFinishLoading(const NetworkLoadMetrics&amp;);
108     virtual void didFail(const ResourceError&amp;);
109 
110     WEBCORE_EXPORT void didBlockAuthenticationChallenge();
111 
112     virtual bool shouldUseCredentialStorage();
113 #if USE(PROTECTION_SPACE_AUTH_CALLBACK)
114     virtual bool canAuthenticateAgainstProtectionSpace(const ProtectionSpace&amp;);
115 #endif
116     virtual void receivedCancellation(const AuthenticationChallenge&amp;);
117 
118 #if USE(QUICK_LOOK)
119     bool isQuickLookResource() const;

120 #endif
121 
122     const URL&amp; url() const { return m_request.url(); }
123     ResourceHandle* handle() const { return m_handle.get(); }
124     bool shouldSendResourceLoadCallbacks() const { return m_options.sendLoadCallbacks == SendCallbackPolicy::SendCallbacks; }
125     void setSendCallbackPolicy(SendCallbackPolicy sendLoadCallbacks) { m_options.sendLoadCallbacks = sendLoadCallbacks; }
126     bool shouldSniffContent() const { return m_options.sniffContent == ContentSniffingPolicy::SniffContent; }
127     bool shouldSniffContentEncoding() const { return m_options.sniffContentEncoding == ContentEncodingSniffingPolicy::Sniff; }
128     WEBCORE_EXPORT bool isAllowedToAskUserForCredentials() const;
129     WEBCORE_EXPORT bool shouldIncludeCertificateInfo() const;
130 
131     bool reachedTerminalState() const { return m_reachedTerminalState; }
132 
<span class="line-removed">133 </span>
134     const ResourceRequest&amp; request() const { return m_request; }
135     void setRequest(ResourceRequest&amp;&amp; request) { m_request = WTFMove(request); }
136 
137     void setDataBufferingPolicy(DataBufferingPolicy);
138 
139     void willSwitchToSubstituteResource();
140 
141     const LoadTiming&amp; loadTiming() { return m_loadTiming; }
142 
143 #if PLATFORM(COCOA)
144     void schedule(WTF::SchedulePair&amp;);
145     void unschedule(WTF::SchedulePair&amp;);
146 #endif
147 
148     const Frame* frame() const { return m_frame.get(); }
149     WEBCORE_EXPORT bool isAlwaysOnLoggingAllowed() const;
150 
151     const ResourceLoaderOptions&amp; options() const { return m_options; }
152 
153     const ResourceRequest&amp; deferredRequest() const { return m_deferredRequest; }
</pre>
<hr />
<pre>
161 
162     bool wasCancelled() const { return m_cancellationStatus &gt;= Cancelled; }
163 
164     void didReceiveDataOrBuffer(const char*, unsigned, RefPtr&lt;SharedBuffer&gt;&amp;&amp;, long long encodedDataLength, DataPayloadType);
165 
166     void setReferrerPolicy(ReferrerPolicy referrerPolicy) { m_options.referrerPolicy = referrerPolicy; }
167     ReferrerPolicy referrerPolicy() const { return m_options.referrerPolicy; }
168 
169 #if PLATFORM(COCOA)
170     void willCacheResponseAsync(ResourceHandle*, NSCachedURLResponse*, CompletionHandler&lt;void(NSCachedURLResponse *)&gt;&amp;&amp;) override;
171 #endif
172 
173     virtual void willSendRequestInternal(ResourceRequest&amp;&amp;, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp;);
174 
175     RefPtr&lt;ResourceHandle&gt; m_handle;
176     RefPtr&lt;Frame&gt; m_frame;
177     RefPtr&lt;DocumentLoader&gt; m_documentLoader;
178     ResourceResponse m_response;
179     LoadTiming m_loadTiming;
180 #if USE(QUICK_LOOK)
<span class="line-modified">181     std::unique_ptr&lt;PreviewLoader&gt; m_previewLoader;</span>
182 #endif
183     bool m_canCrossOriginRequestsAskUserForCredentials { true };
184 
185 private:
186     virtual void willCancel(const ResourceError&amp;) = 0;
187     virtual void didCancel(const ResourceError&amp;) = 0;
188 
189     void addDataOrBuffer(const char*, unsigned, SharedBuffer*, DataPayloadType);
190     void loadDataURL();
191     void finishNetworkLoad();
192 
193     bool shouldAllowResourceToAskForCredentials() const;
194 
195     // ResourceHandleClient
196     void didSendData(ResourceHandle*, unsigned long long bytesSent, unsigned long long totalBytesToBeSent) override;
197     void didReceiveResponseAsync(ResourceHandle*, ResourceResponse&amp;&amp;, CompletionHandler&lt;void()&gt;&amp;&amp;) override;
198     void willSendRequestAsync(ResourceHandle*, ResourceRequest&amp;&amp;, ResourceResponse&amp;&amp;, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp;) override;
199     void didReceiveData(ResourceHandle*, const char*, unsigned, int encodedDataLength) override;
200     void didReceiveBuffer(ResourceHandle*, Ref&lt;SharedBuffer&gt;&amp;&amp;, int encodedDataLength) override;
201     void didFinishLoading(ResourceHandle*) override;
</pre>
</td>
<td>
<hr />
<pre>
 34 #include &quot;ResourceLoaderTypes.h&quot;
 35 #include &quot;ResourceRequest.h&quot;
 36 #include &quot;ResourceResponse.h&quot;
 37 #include &lt;wtf/Forward.h&gt;
 38 #include &lt;wtf/WeakPtr.h&gt;
 39 
 40 #if ENABLE(CONTENT_EXTENSIONS)
 41 #include &quot;ResourceLoadInfo.h&quot;
 42 #endif
 43 
 44 namespace WTF {
 45 class SchedulePair;
 46 }
 47 
 48 namespace WebCore {
 49 
 50 class AuthenticationChallenge;
 51 class DocumentLoader;
 52 class Frame;
 53 class FrameLoader;
<span class="line-added"> 54 class LegacyPreviewLoader;</span>
 55 class NetworkLoadMetrics;

 56 
<span class="line-added"> 57 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ResourceLoader);</span>
 58 class ResourceLoader : public CanMakeWeakPtr&lt;ResourceLoader&gt;, public RefCounted&lt;ResourceLoader&gt;, protected ResourceHandleClient {
<span class="line-added"> 59     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(ResourceLoader);</span>
 60 public:
 61     virtual ~ResourceLoader() = 0;
 62 
 63     WEBCORE_EXPORT void cancel();
 64 
 65     virtual void init(ResourceRequest&amp;&amp;, CompletionHandler&lt;void(bool)&gt;&amp;&amp;);
 66 
 67     void deliverResponseAndData(const ResourceResponse&amp;, RefPtr&lt;SharedBuffer&gt;&amp;&amp;);
 68 
 69 #if PLATFORM(IOS_FAMILY)
 70     virtual void startLoading()
 71     {
 72         start();
 73     }
 74 
 75     virtual const ResourceRequest&amp; iOSOriginalRequest() const { return request(); }
 76 #endif
 77 
 78     WEBCORE_EXPORT FrameLoader* frameLoader() const;
 79     DocumentLoader* documentLoader() const { return m_documentLoader.get(); }
</pre>
<hr />
<pre>
102     virtual bool isSubresourceLoader() const;
103 
104     virtual void willSendRequest(ResourceRequest&amp;&amp;, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; callback);
105     virtual void didSendData(unsigned long long bytesSent, unsigned long long totalBytesToBeSent);
106     virtual void didReceiveResponse(const ResourceResponse&amp;, CompletionHandler&lt;void()&gt;&amp;&amp; policyCompletionHandler);
107     virtual void didReceiveData(const char*, unsigned, long long encodedDataLength, DataPayloadType);
108     virtual void didReceiveBuffer(Ref&lt;SharedBuffer&gt;&amp;&amp;, long long encodedDataLength, DataPayloadType);
109     virtual void didFinishLoading(const NetworkLoadMetrics&amp;);
110     virtual void didFail(const ResourceError&amp;);
111 
112     WEBCORE_EXPORT void didBlockAuthenticationChallenge();
113 
114     virtual bool shouldUseCredentialStorage();
115 #if USE(PROTECTION_SPACE_AUTH_CALLBACK)
116     virtual bool canAuthenticateAgainstProtectionSpace(const ProtectionSpace&amp;);
117 #endif
118     virtual void receivedCancellation(const AuthenticationChallenge&amp;);
119 
120 #if USE(QUICK_LOOK)
121     bool isQuickLookResource() const;
<span class="line-added">122     virtual void didReceivePreviewResponse(const ResourceResponse&amp;) { };</span>
123 #endif
124 
125     const URL&amp; url() const { return m_request.url(); }
126     ResourceHandle* handle() const { return m_handle.get(); }
127     bool shouldSendResourceLoadCallbacks() const { return m_options.sendLoadCallbacks == SendCallbackPolicy::SendCallbacks; }
128     void setSendCallbackPolicy(SendCallbackPolicy sendLoadCallbacks) { m_options.sendLoadCallbacks = sendLoadCallbacks; }
129     bool shouldSniffContent() const { return m_options.sniffContent == ContentSniffingPolicy::SniffContent; }
130     bool shouldSniffContentEncoding() const { return m_options.sniffContentEncoding == ContentEncodingSniffingPolicy::Sniff; }
131     WEBCORE_EXPORT bool isAllowedToAskUserForCredentials() const;
132     WEBCORE_EXPORT bool shouldIncludeCertificateInfo() const;
133 
134     bool reachedTerminalState() const { return m_reachedTerminalState; }
135 

136     const ResourceRequest&amp; request() const { return m_request; }
137     void setRequest(ResourceRequest&amp;&amp; request) { m_request = WTFMove(request); }
138 
139     void setDataBufferingPolicy(DataBufferingPolicy);
140 
141     void willSwitchToSubstituteResource();
142 
143     const LoadTiming&amp; loadTiming() { return m_loadTiming; }
144 
145 #if PLATFORM(COCOA)
146     void schedule(WTF::SchedulePair&amp;);
147     void unschedule(WTF::SchedulePair&amp;);
148 #endif
149 
150     const Frame* frame() const { return m_frame.get(); }
151     WEBCORE_EXPORT bool isAlwaysOnLoggingAllowed() const;
152 
153     const ResourceLoaderOptions&amp; options() const { return m_options; }
154 
155     const ResourceRequest&amp; deferredRequest() const { return m_deferredRequest; }
</pre>
<hr />
<pre>
163 
164     bool wasCancelled() const { return m_cancellationStatus &gt;= Cancelled; }
165 
166     void didReceiveDataOrBuffer(const char*, unsigned, RefPtr&lt;SharedBuffer&gt;&amp;&amp;, long long encodedDataLength, DataPayloadType);
167 
168     void setReferrerPolicy(ReferrerPolicy referrerPolicy) { m_options.referrerPolicy = referrerPolicy; }
169     ReferrerPolicy referrerPolicy() const { return m_options.referrerPolicy; }
170 
171 #if PLATFORM(COCOA)
172     void willCacheResponseAsync(ResourceHandle*, NSCachedURLResponse*, CompletionHandler&lt;void(NSCachedURLResponse *)&gt;&amp;&amp;) override;
173 #endif
174 
175     virtual void willSendRequestInternal(ResourceRequest&amp;&amp;, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp;);
176 
177     RefPtr&lt;ResourceHandle&gt; m_handle;
178     RefPtr&lt;Frame&gt; m_frame;
179     RefPtr&lt;DocumentLoader&gt; m_documentLoader;
180     ResourceResponse m_response;
181     LoadTiming m_loadTiming;
182 #if USE(QUICK_LOOK)
<span class="line-modified">183     std::unique_ptr&lt;LegacyPreviewLoader&gt; m_previewLoader;</span>
184 #endif
185     bool m_canCrossOriginRequestsAskUserForCredentials { true };
186 
187 private:
188     virtual void willCancel(const ResourceError&amp;) = 0;
189     virtual void didCancel(const ResourceError&amp;) = 0;
190 
191     void addDataOrBuffer(const char*, unsigned, SharedBuffer*, DataPayloadType);
192     void loadDataURL();
193     void finishNetworkLoad();
194 
195     bool shouldAllowResourceToAskForCredentials() const;
196 
197     // ResourceHandleClient
198     void didSendData(ResourceHandle*, unsigned long long bytesSent, unsigned long long totalBytesToBeSent) override;
199     void didReceiveResponseAsync(ResourceHandle*, ResourceResponse&amp;&amp;, CompletionHandler&lt;void()&gt;&amp;&amp;) override;
200     void willSendRequestAsync(ResourceHandle*, ResourceRequest&amp;&amp;, ResourceResponse&amp;&amp;, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp;) override;
201     void didReceiveData(ResourceHandle*, const char*, unsigned, int encodedDataLength) override;
202     void didReceiveBuffer(ResourceHandle*, Ref&lt;SharedBuffer&gt;&amp;&amp;, int encodedDataLength) override;
203     void didFinishLoading(ResourceHandle*) override;
</pre>
</td>
</tr>
</table>
<center><a href="ResourceLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ResourceLoaderOptions.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
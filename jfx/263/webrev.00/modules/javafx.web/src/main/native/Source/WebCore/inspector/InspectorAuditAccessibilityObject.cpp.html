<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorAuditAccessibilityObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;InspectorAuditAccessibilityObject.h&quot;
 29 
 30 #include &quot;AXObjectCache.h&quot;
 31 #include &quot;AccessibilityNodeObject.h&quot;
 32 #include &quot;AccessibilityObjectInterface.h&quot;
 33 #include &quot;ContainerNode.h&quot;
 34 #include &quot;Document.h&quot;
 35 #include &quot;Element.h&quot;
 36 #include &quot;ElementDescendantIterator.h&quot;
 37 #include &quot;HTMLNames.h&quot;
 38 #include &quot;Node.h&quot;
 39 #include &quot;SpaceSplitString.h&quot;
 40 #include &lt;wtf/Vector.h&gt;
 41 #include &lt;wtf/text/WTFString.h&gt;
 42 
 43 namespace WebCore {
 44 
 45 using namespace Inspector;
 46 
 47 #define ERROR_IF_NO_ACTIVE_AUDIT() \
 48     if (!m_auditAgent.hasActiveAudit()) \
 49         return Exception { NotAllowedError, &quot;Cannot be called outside of a Web Inspector Audit&quot;_s };
 50 
 51 InspectorAuditAccessibilityObject::InspectorAuditAccessibilityObject(InspectorAuditAgent&amp; auditAgent)
 52     : m_auditAgent(auditAgent)
 53 {
 54 }
 55 
 56 static AXCoreObject* accessiblityObjectForNode(Node&amp; node)
 57 {
 58     if (!AXObjectCache::accessibilityEnabled())
 59         AXObjectCache::enableAccessibility();
 60 
 61     if (AXObjectCache* axObjectCache = node.document().axObjectCache())
 62         return axObjectCache-&gt;getOrCreate(&amp;node);
 63 
 64     return nullptr;
 65 }
 66 
 67 ExceptionOr&lt;Vector&lt;Ref&lt;Node&gt;&gt;&gt; InspectorAuditAccessibilityObject::getElementsByComputedRole(Document&amp; document, const String&amp; role, Node* container)
 68 {
 69     ERROR_IF_NO_ACTIVE_AUDIT();
 70 
 71     Vector&lt;Ref&lt;Node&gt;&gt; nodes;
 72 
 73     for (Element&amp; element : elementDescendants(is&lt;ContainerNode&gt;(container) ? downcast&lt;ContainerNode&gt;(*container) : document)) {
 74         if (AXCoreObject* axObject = accessiblityObjectForNode(element)) {
 75             if (axObject-&gt;computedRoleString() == role)
 76                 nodes.append(element);
 77         }
 78     }
 79 
 80     return nodes;
 81 }
 82 
 83 ExceptionOr&lt;RefPtr&lt;Node&gt;&gt; InspectorAuditAccessibilityObject::getActiveDescendant(Node&amp; node)
 84 {
 85     ERROR_IF_NO_ACTIVE_AUDIT();
 86 
 87     if (AXCoreObject* axObject = accessiblityObjectForNode(node)) {
 88         if (AXCoreObject* activeDescendant = axObject-&gt;activeDescendant())
 89             return activeDescendant-&gt;node();
 90     }
 91 
 92     return nullptr;
 93 }
 94 
 95 static void addChildren(AXCoreObject&amp; parentObject, Vector&lt;RefPtr&lt;Node&gt;&gt;&amp; childNodes)
 96 {
 97     for (const auto&amp; childObject : parentObject.children()) {
 98         if (Node* childNode = childObject-&gt;node())
 99             childNodes.append(childNode);
100         else
101             addChildren(*childObject, childNodes);
102     }
103 }
104 
105 ExceptionOr&lt;Optional&lt;Vector&lt;RefPtr&lt;Node&gt;&gt;&gt;&gt; InspectorAuditAccessibilityObject::getChildNodes(Node&amp; node)
106 {
107     ERROR_IF_NO_ACTIVE_AUDIT();
108 
109     Optional&lt;Vector&lt;RefPtr&lt;Node&gt;&gt;&gt; result;
110 
111     if (AXCoreObject* axObject = accessiblityObjectForNode(node)) {
112         Vector&lt;RefPtr&lt;Node&gt;&gt; childNodes;
113         addChildren(*axObject, childNodes);
114         result = WTFMove(childNodes);
115     }
116 
117     return result;
118 }
119 
120 ExceptionOr&lt;Optional&lt;InspectorAuditAccessibilityObject::ComputedProperties&gt;&gt; InspectorAuditAccessibilityObject::getComputedProperties(Node&amp; node)
121 {
122     ERROR_IF_NO_ACTIVE_AUDIT();
123 
124     Optional&lt;InspectorAuditAccessibilityObject::ComputedProperties&gt; result;
125 
126     if (AXCoreObject* axObject = accessiblityObjectForNode(node)) {
127         ComputedProperties computedProperties;
128 
129         AXCoreObject* current = axObject;
130         while (current &amp;&amp; (!computedProperties.busy || !computedProperties.busy.value())) {
131             computedProperties.busy = current-&gt;isBusy();
132             current = current-&gt;parentObject();
133         }
134 
135         if (axObject-&gt;supportsChecked()) {
136             AccessibilityButtonState checkValue = axObject-&gt;checkboxOrRadioValue();
137             if (checkValue == AccessibilityButtonState::On)
138                 computedProperties.checked = &quot;true&quot;_s;
139             else if (checkValue == AccessibilityButtonState::Mixed)
140                 computedProperties.checked = &quot;mixed&quot;_s;
141             else if (axObject-&gt;isChecked())
142                 computedProperties.checked = &quot;true&quot;_s;
143             else
144                 computedProperties.checked = &quot;false&quot;_s;
145         }
146 
147         switch (axObject-&gt;currentState()) {
148         case AccessibilityCurrentState::False:
149             computedProperties.currentState = &quot;false&quot;_s;
150             break;
151         case AccessibilityCurrentState::True:
152             computedProperties.currentState = &quot;true&quot;_s;
153             break;
154         case AccessibilityCurrentState::Page:
155             computedProperties.currentState = &quot;page&quot;_s;
156             break;
157         case AccessibilityCurrentState::Step:
158             computedProperties.currentState = &quot;step&quot;_s;
159             break;
160         case AccessibilityCurrentState::Location:
161             computedProperties.currentState = &quot;location&quot;_s;
162             break;
163         case AccessibilityCurrentState::Date:
164             computedProperties.currentState = &quot;date&quot;_s;
165             break;
166         case AccessibilityCurrentState::Time:
167             computedProperties.currentState = &quot;time&quot;_s;
168             break;
169         }
170 
171         computedProperties.disabled = !axObject-&gt;isEnabled();
172 
173         if (axObject-&gt;supportsExpanded())
174             computedProperties.expanded = axObject-&gt;isExpanded();
175 
176         if (is&lt;Element&gt;(node) &amp;&amp; axObject-&gt;canSetFocusAttribute())
177             computedProperties.focused = axObject-&gt;isFocused();
178 
179         computedProperties.headingLevel = axObject-&gt;headingLevel();
180         computedProperties.hidden = axObject-&gt;isAXHidden() || axObject-&gt;isDOMHidden();
181         computedProperties.hierarchicalLevel = axObject-&gt;hierarchicalLevel();
182         computedProperties.ignored = axObject-&gt;accessibilityIsIgnored();
183         computedProperties.ignoredByDefault = axObject-&gt;accessibilityIsIgnoredByDefault();
184 
185         String invalidValue = axObject-&gt;invalidStatus();
186         if (invalidValue == &quot;false&quot;)
187             computedProperties.invalidStatus = &quot;false&quot;_s;
188         else if (invalidValue == &quot;grammar&quot;)
189             computedProperties.invalidStatus = &quot;grammar&quot;_s;
190         else if (invalidValue == &quot;spelling&quot;)
191             computedProperties.invalidStatus = &quot;spelling&quot;_s;
192         else
193             computedProperties.invalidStatus = &quot;true&quot;_s;
194 
195         computedProperties.isPopUpButton = axObject-&gt;isPopUpButton() || axObject-&gt;hasPopup();
196         computedProperties.label = axObject-&gt;computedLabel();
197 
198         if (axObject-&gt;supportsLiveRegion()) {
199             computedProperties.liveRegionAtomic = axObject-&gt;liveRegionAtomic();
200 
201             String ariaRelevantAttrValue = axObject-&gt;liveRegionRelevant();
202             if (!ariaRelevantAttrValue.isEmpty()) {
203                 Vector&lt;String&gt; liveRegionRelevant;
204                 String ariaRelevantAdditions = &quot;additions&quot;;
205                 String ariaRelevantRemovals = &quot;removals&quot;;
206                 String ariaRelevantText = &quot;text&quot;;
207 
208                 const auto&amp; values = SpaceSplitString(ariaRelevantAttrValue, true);
209                 if (values.contains(&quot;all&quot;)) {
210                     liveRegionRelevant.append(ariaRelevantAdditions);
211                     liveRegionRelevant.append(ariaRelevantRemovals);
212                     liveRegionRelevant.append(ariaRelevantText);
213                 } else {
214                     if (values.contains(ariaRelevantAdditions))
215                         liveRegionRelevant.append(ariaRelevantAdditions);
216                     if (values.contains(ariaRelevantRemovals))
217                         liveRegionRelevant.append(ariaRelevantRemovals);
218                     if (values.contains(ariaRelevantText))
219                         liveRegionRelevant.append(ariaRelevantText);
220                 }
221                 computedProperties.liveRegionRelevant = liveRegionRelevant;
222             }
223 
224             computedProperties.liveRegionStatus = axObject-&gt;liveRegionStatus();
225         }
226 
227         computedProperties.pressed = axObject-&gt;pressedIsPresent() &amp;&amp; axObject-&gt;isPressed();
228 
229         if (axObject-&gt;isTextControl())
230             computedProperties.readonly = !axObject-&gt;canSetValueAttribute();
231 
232         if (axObject-&gt;supportsRequiredAttribute())
233             computedProperties.required = axObject-&gt;isRequired();
234 
235         computedProperties.role = axObject-&gt;computedRoleString();
236         computedProperties.selected = axObject-&gt;isSelected();
237 
238         result = computedProperties;
239     }
240 
241     return result;
242 }
243 
244 ExceptionOr&lt;Optional&lt;Vector&lt;RefPtr&lt;Node&gt;&gt;&gt;&gt; InspectorAuditAccessibilityObject::getControlledNodes(Node&amp; node)
245 {
246     ERROR_IF_NO_ACTIVE_AUDIT();
247 
248     Optional&lt;Vector&lt;RefPtr&lt;Node&gt;&gt;&gt; result;
249 
250     if (AXCoreObject* axObject = accessiblityObjectForNode(node)) {
251         Vector&lt;RefPtr&lt;Node&gt;&gt; controlledNodes;
252 
253         Vector&lt;Element*&gt; controlledElements;
254         axObject-&gt;elementsFromAttribute(controlledElements, HTMLNames::aria_controlsAttr);
255         for (Element* controlledElement : controlledElements) {
256             if (controlledElement)
257                 controlledNodes.append(controlledElement);
258         }
259 
260         result = WTFMove(controlledNodes);
261     }
262 
263     return result;
264 }
265 
266 ExceptionOr&lt;Optional&lt;Vector&lt;RefPtr&lt;Node&gt;&gt;&gt;&gt; InspectorAuditAccessibilityObject::getFlowedNodes(Node&amp; node)
267 {
268     ERROR_IF_NO_ACTIVE_AUDIT();
269 
270     Optional&lt;Vector&lt;RefPtr&lt;Node&gt;&gt;&gt; result;
271 
272     if (AXCoreObject* axObject = accessiblityObjectForNode(node)) {
273         Vector&lt;RefPtr&lt;Node&gt;&gt; flowedNodes;
274 
275         Vector&lt;Element*&gt; flowedElements;
276         axObject-&gt;elementsFromAttribute(flowedElements, HTMLNames::aria_flowtoAttr);
277         for (Element* flowedElement : flowedElements) {
278             if (flowedElement)
279                 flowedNodes.append(flowedElement);
280         }
281 
282         result = WTFMove(flowedNodes);
283     }
284 
285     return result;
286 }
287 
288 ExceptionOr&lt;RefPtr&lt;Node&gt;&gt; InspectorAuditAccessibilityObject::getMouseEventNode(Node&amp; node)
289 {
290     ERROR_IF_NO_ACTIVE_AUDIT();
291 
292     if (AXCoreObject* axObject = accessiblityObjectForNode(node)) {
293         if (is&lt;AccessibilityNodeObject&gt;(axObject))
294             return downcast&lt;AccessibilityNodeObject&gt;(axObject)-&gt;mouseButtonListener(MouseButtonListenerResultFilter::IncludeBodyElement);
295     }
296 
297     return nullptr;
298 }
299 
300 ExceptionOr&lt;Optional&lt;Vector&lt;RefPtr&lt;Node&gt;&gt;&gt;&gt; InspectorAuditAccessibilityObject::getOwnedNodes(Node&amp; node)
301 {
302     ERROR_IF_NO_ACTIVE_AUDIT();
303 
304     Optional&lt;Vector&lt;RefPtr&lt;Node&gt;&gt;&gt; result;
305 
306     if (AXCoreObject* axObject = accessiblityObjectForNode(node)) {
307         if (axObject-&gt;supportsARIAOwns()) {
308             Vector&lt;RefPtr&lt;Node&gt;&gt; ownedNodes;
309 
310             Vector&lt;Element*&gt; ownedElements;
311             axObject-&gt;elementsFromAttribute(ownedElements, HTMLNames::aria_ownsAttr);
312             for (Element* ownedElement : ownedElements) {
313                 if (ownedElement)
314                     ownedNodes.append(ownedElement);
315             }
316 
317             result = WTFMove(ownedNodes);
318         }
319     }
320 
321     return result;
322 }
323 
324 ExceptionOr&lt;RefPtr&lt;Node&gt;&gt; InspectorAuditAccessibilityObject::getParentNode(Node&amp; node)
325 {
326     ERROR_IF_NO_ACTIVE_AUDIT();
327 
328     if (AXCoreObject* axObject = accessiblityObjectForNode(node)) {
329         if (AXCoreObject* parentObject = axObject-&gt;parentObjectUnignored())
330             return parentObject-&gt;node();
331     }
332 
333     return nullptr;
334 }
335 
336 ExceptionOr&lt;Optional&lt;Vector&lt;RefPtr&lt;Node&gt;&gt;&gt;&gt; InspectorAuditAccessibilityObject::getSelectedChildNodes(Node&amp; node)
337 {
338     ERROR_IF_NO_ACTIVE_AUDIT();
339 
340     Optional&lt;Vector&lt;RefPtr&lt;Node&gt;&gt;&gt; result;
341 
342     if (AXCoreObject* axObject = accessiblityObjectForNode(node)) {
343         Vector&lt;RefPtr&lt;Node&gt;&gt; selectedChildNodes;
344 
345         AXCoreObject::AccessibilityChildrenVector selectedChildren;
346         axObject-&gt;selectedChildren(selectedChildren);
347         for (auto&amp; selectedChildObject : selectedChildren) {
348             if (Node* selectedChildNode = selectedChildObject-&gt;node())
349                 selectedChildNodes.append(selectedChildNode);
350         }
351 
352         result = WTFMove(selectedChildNodes);
353     }
354 
355     return result;
356 }
357 
358 } // namespace WebCore
    </pre>
  </body>
</html>
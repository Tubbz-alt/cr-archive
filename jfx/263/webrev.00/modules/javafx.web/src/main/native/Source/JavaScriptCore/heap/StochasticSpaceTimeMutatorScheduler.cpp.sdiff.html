<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/StochasticSpaceTimeMutatorScheduler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SlotVisitorInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Strong.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/StochasticSpaceTimeMutatorScheduler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 60 
 61 StochasticSpaceTimeMutatorScheduler::~StochasticSpaceTimeMutatorScheduler()
 62 {
 63 }
 64 
 65 MutatorScheduler::State StochasticSpaceTimeMutatorScheduler::state() const
 66 {
 67     return m_state;
 68 }
 69 
 70 void StochasticSpaceTimeMutatorScheduler::beginCollection()
 71 {
 72     RELEASE_ASSERT(m_state == Normal);
 73     m_state = Stopped;
 74 
 75     m_bytesAllocatedThisCycleAtTheBeginning = m_heap.m_bytesAllocatedThisCycle;
 76     m_bytesAllocatedThisCycleAtTheEnd =
 77         Options::concurrentGCMaxHeadroom() *
 78         std::max&lt;double&gt;(m_bytesAllocatedThisCycleAtTheBeginning, m_heap.m_maxEdenSize);
 79 
<span class="line-modified"> 80     if (Options::logGC())</span>
<span class="line-removed"> 81         dataLog(&quot;ca=&quot;, m_bytesAllocatedThisCycleAtTheBeginning / 1024, &quot;kb h=&quot;, (m_bytesAllocatedThisCycleAtTheEnd - m_bytesAllocatedThisCycleAtTheBeginning) / 1024, &quot;kb &quot;);</span>
 82 
 83     m_beforeConstraints = MonotonicTime::now();
 84 }
 85 
 86 void StochasticSpaceTimeMutatorScheduler::didStop()
 87 {
 88     RELEASE_ASSERT(m_state == Stopped || m_state == Resumed);
 89     m_state = Stopped;
 90 }
 91 
 92 void StochasticSpaceTimeMutatorScheduler::willResume()
 93 {
 94     RELEASE_ASSERT(m_state == Stopped || m_state == Resumed);
 95     m_state = Resumed;
 96 }
 97 
 98 void StochasticSpaceTimeMutatorScheduler::didReachTermination()
 99 {
100     m_beforeConstraints = MonotonicTime::now();
101 }
102 
103 void StochasticSpaceTimeMutatorScheduler::didExecuteConstraints()
104 {
105     Snapshot snapshot(*this);
106 
107     Seconds constraintExecutionDuration = snapshot.now() - m_beforeConstraints;
108 
109     m_targetPause = std::max(
110         constraintExecutionDuration * m_pauseScale,
111         m_minimumPause);
112 
<span class="line-modified">113     if (Options::logGC())</span>
<span class="line-removed">114         dataLog(&quot;tp=&quot;, m_targetPause.milliseconds(), &quot;ms &quot;);</span>
115 
116     m_plannedResumeTime = snapshot.now() + m_targetPause;
117 }
118 
119 void StochasticSpaceTimeMutatorScheduler::synchronousDrainingDidStall()
120 {
121     Snapshot snapshot(*this);
122 
123     double resumeProbability = mutatorUtilization(snapshot);
124     if (resumeProbability &lt; Options::epsilonMutatorUtilization()) {
125         m_plannedResumeTime = MonotonicTime::infinity();
126         return;
127     }
128 
129     bool shouldResume = m_random.get() &lt; resumeProbability;
130 
131     if (shouldResume) {
132         m_plannedResumeTime = snapshot.now();
133         return;
134     }
</pre>
</td>
<td>
<hr />
<pre>
 60 
 61 StochasticSpaceTimeMutatorScheduler::~StochasticSpaceTimeMutatorScheduler()
 62 {
 63 }
 64 
 65 MutatorScheduler::State StochasticSpaceTimeMutatorScheduler::state() const
 66 {
 67     return m_state;
 68 }
 69 
 70 void StochasticSpaceTimeMutatorScheduler::beginCollection()
 71 {
 72     RELEASE_ASSERT(m_state == Normal);
 73     m_state = Stopped;
 74 
 75     m_bytesAllocatedThisCycleAtTheBeginning = m_heap.m_bytesAllocatedThisCycle;
 76     m_bytesAllocatedThisCycleAtTheEnd =
 77         Options::concurrentGCMaxHeadroom() *
 78         std::max&lt;double&gt;(m_bytesAllocatedThisCycleAtTheBeginning, m_heap.m_maxEdenSize);
 79 
<span class="line-modified"> 80     dataLogIf(Options::logGC(), &quot;ca=&quot;, m_bytesAllocatedThisCycleAtTheBeginning / 1024, &quot;kb h=&quot;, (m_bytesAllocatedThisCycleAtTheEnd - m_bytesAllocatedThisCycleAtTheBeginning) / 1024, &quot;kb &quot;);</span>

 81 
 82     m_beforeConstraints = MonotonicTime::now();
 83 }
 84 
 85 void StochasticSpaceTimeMutatorScheduler::didStop()
 86 {
 87     RELEASE_ASSERT(m_state == Stopped || m_state == Resumed);
 88     m_state = Stopped;
 89 }
 90 
 91 void StochasticSpaceTimeMutatorScheduler::willResume()
 92 {
 93     RELEASE_ASSERT(m_state == Stopped || m_state == Resumed);
 94     m_state = Resumed;
 95 }
 96 
 97 void StochasticSpaceTimeMutatorScheduler::didReachTermination()
 98 {
 99     m_beforeConstraints = MonotonicTime::now();
100 }
101 
102 void StochasticSpaceTimeMutatorScheduler::didExecuteConstraints()
103 {
104     Snapshot snapshot(*this);
105 
106     Seconds constraintExecutionDuration = snapshot.now() - m_beforeConstraints;
107 
108     m_targetPause = std::max(
109         constraintExecutionDuration * m_pauseScale,
110         m_minimumPause);
111 
<span class="line-modified">112     dataLogIf(Options::logGC(), &quot;tp=&quot;, m_targetPause.milliseconds(), &quot;ms &quot;);</span>

113 
114     m_plannedResumeTime = snapshot.now() + m_targetPause;
115 }
116 
117 void StochasticSpaceTimeMutatorScheduler::synchronousDrainingDidStall()
118 {
119     Snapshot snapshot(*this);
120 
121     double resumeProbability = mutatorUtilization(snapshot);
122     if (resumeProbability &lt; Options::epsilonMutatorUtilization()) {
123         m_plannedResumeTime = MonotonicTime::infinity();
124         return;
125     }
126 
127     bool shouldResume = m_random.get() &lt; resumeProbability;
128 
129     if (shouldResume) {
130         m_plannedResumeTime = snapshot.now();
131         return;
132     }
</pre>
</td>
</tr>
</table>
<center><a href="SlotVisitorInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Strong.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LowLevelInterpreter32_64.asm</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LowLevelInterpreter.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LowLevelInterpreter64.asm.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LowLevelInterpreter32_64.asm</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -21,50 +21,35 @@</span>
  # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  # THE POSSIBILITY OF SUCH DAMAGE.
  
  
  # Utilities
<span class="udiff-line-modified-removed">- macro nextInstruction()</span>
<span class="udiff-line-modified-removed">-     loadb [PC], t0</span>
<span class="udiff-line-removed">-     leap _g_opcodeMap, t1</span>
<span class="udiff-line-removed">-     jmp [t1, t0, 4], BytecodePtrTag</span>
<span class="udiff-line-removed">- end</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- macro nextInstructionWide16()</span>
<span class="udiff-line-removed">-     loadh 1[PC], t0</span>
<span class="udiff-line-removed">-     leap _g_opcodeMapWide16, t1</span>
<span class="udiff-line-removed">-     jmp [t1, t0, 4], BytecodePtrTag</span>
<span class="udiff-line-removed">- end</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- macro nextInstructionWide32()</span>
<span class="udiff-line-removed">-     loadi 1[PC], t0</span>
<span class="udiff-line-removed">-     leap _g_opcodeMapWide32, t1</span>
<span class="udiff-line-removed">-     jmp [t1, t0, 4], BytecodePtrTag</span>
<span class="udiff-line-removed">- end</span>
<span class="udiff-line-modified-added">+ # FIXME:  Merge &quot;getOperand&quot; macros on 32 and 64 bits LLInt</span>
<span class="udiff-line-modified-added">+ # https://bugs.webkit.org/show_bug.cgi?id=206342</span>
  
  macro getuOperandNarrow(opcodeStruct, fieldName, dst)
<span class="udiff-line-modified-removed">-     loadb constexpr %opcodeStruct%_%fieldName%_index[PC], dst</span>
<span class="udiff-line-modified-added">+     loadb constexpr %opcodeStruct%_%fieldName%_index + OpcodeIDNarrowSize[PB, PC, 1], dst</span>
  end
  
  macro getOperandNarrow(opcodeStruct, fieldName, dst)
<span class="udiff-line-modified-removed">-     loadbsi constexpr %opcodeStruct%_%fieldName%_index[PC], dst</span>
<span class="udiff-line-modified-added">+     loadbsi constexpr %opcodeStruct%_%fieldName%_index + OpcodeIDNarrowSize[PB, PC, 1], dst</span>
  end
  
  macro getuOperandWide16(opcodeStruct, fieldName, dst)
<span class="udiff-line-modified-removed">-     loadh constexpr %opcodeStruct%_%fieldName%_index * 2 + 1[PC], dst</span>
<span class="udiff-line-modified-added">+     loadh constexpr %opcodeStruct%_%fieldName%_index * 2 + OpcodeIDWide16Size[PB, PC, 1], dst</span>
  end
  
  macro getOperandWide16(opcodeStruct, fieldName, dst)
<span class="udiff-line-modified-removed">-     loadhsi constexpr %opcodeStruct%_%fieldName%_index * 2 + 1[PC], dst</span>
<span class="udiff-line-modified-added">+     loadhsi constexpr %opcodeStruct%_%fieldName%_index * 2 + OpcodeIDWide16Size[PB, PC, 1], dst</span>
  end
  
  macro getuOperandWide32(opcodeStruct, fieldName, dst)
<span class="udiff-line-modified-removed">-     loadi constexpr %opcodeStruct%_%fieldName%_index * 4 + 1[PC], dst</span>
<span class="udiff-line-modified-added">+     loadi constexpr %opcodeStruct%_%fieldName%_index * 4 + OpcodeIDWide32Size[PB, PC, 1], dst</span>
  end
  
  macro getOperandWide32(opcodeStruct, fieldName, dst)
<span class="udiff-line-modified-removed">-     loadis constexpr %opcodeStruct%_%fieldName%_index * 4 + 1[PC], dst</span>
<span class="udiff-line-modified-added">+     loadis constexpr %opcodeStruct%_%fieldName%_index * 4 + OpcodeIDWide32Size[PB, PC, 1], dst</span>
  end
  
  macro makeReturn(get, dispatch, fn)
      fn(macro(tag, payload)
          move tag, t5
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -89,12 +74,15 @@</span>
          dispatch()
      end)
  end
  
  
<span class="udiff-line-added">+ # After calling, calling bytecode is claiming input registers are not used.</span>
  macro dispatchAfterCall(size, opcodeStruct, dispatch)
<span class="udiff-line-modified-removed">-     loadi ArgumentCount + TagOffset[cfr], PC</span>
<span class="udiff-line-modified-added">+     loadi ArgumentCountIncludingThis + TagOffset[cfr], PC</span>
<span class="udiff-line-added">+     loadp CodeBlock[cfr], PB</span>
<span class="udiff-line-added">+     loadp CodeBlock::m_instructionsRawPointer[PB], PB</span>
      get(size, opcodeStruct, m_dst, t3)
      storei r1, TagOffset[cfr, t3, 8]
      storei r0, PayloadOffset[cfr, t3, 8]
      metadata(size, opcodeStruct, t2, t3)
      valueProfile(opcodeStruct, t2, r1, r0)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -140,15 +128,25 @@</span>
      else
          error
      end
  end
  
<span class="udiff-line-added">+ macro prepareStateForCCall()</span>
<span class="udiff-line-added">+     addp PB, PC</span>
<span class="udiff-line-added">+ end</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ macro restoreStateAfterCCall()</span>
<span class="udiff-line-added">+     move r0, PC</span>
<span class="udiff-line-added">+     subp PB, PC</span>
<span class="udiff-line-added">+ end</span>
<span class="udiff-line-added">+ </span>
  macro callSlowPath(slowPath)
<span class="udiff-line-added">+     prepareStateForCCall()</span>
      move cfr, a0
      move PC, a1
      cCall2(slowPath)
<span class="udiff-line-modified-removed">-     move r0, PC</span>
<span class="udiff-line-modified-added">+     restoreStateAfterCCall()</span>
  end
  
  macro doVMEntry(makeCall)
      functionPrologue()
      pushCalleeSaves()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -260,11 +258,11 @@</span>
  
  .copyArgsDone:
      storep sp, VM::topCallFrame[vm]
      storep cfr, VM::topEntryFrame[vm]
  
<span class="udiff-line-modified-removed">-     makeCall(entry, t3, t4)</span>
<span class="udiff-line-modified-added">+     makeCall(entry, protoCallFrame, t3, t4)</span>
  
      if ARMv7
          vmEntryRecord(cfr, t3)
          move t3, sp
      else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -317,48 +315,60 @@</span>
      popCalleeSaves()
      functionEpilogue()
      ret
  end
  
<span class="udiff-line-modified-removed">- macro makeJavaScriptCall(entry, temp, unused)</span>
<span class="udiff-line-modified-added">+ # a0, a2, t3, t4</span>
<span class="udiff-line-added">+ macro makeJavaScriptCall(entry, protoCallFrame, temp1, temp2)</span>
      addp CallerFrameAndPCSize, sp
<span class="udiff-line-modified-removed">-     checkStackPointerAlignment(temp, 0xbad0dc02)</span>
<span class="udiff-line-modified-added">+     checkStackPointerAlignment(temp1, 0xbad0dc02)</span>
      if C_LOOP or C_LOOP_WIN
          cloopCallJSFunction entry
      else
          call entry
      end
<span class="udiff-line-modified-removed">-     checkStackPointerAlignment(temp, 0xbad0dc03)</span>
<span class="udiff-line-modified-added">+     checkStackPointerAlignment(temp1, 0xbad0dc03)</span>
      subp CallerFrameAndPCSize, sp
  end
  
<span class="udiff-line-modified-removed">- macro makeHostFunctionCall(entry, temp1, temp2)</span>
<span class="udiff-line-modified-added">+ # a0, a2, t3, t4</span>
<span class="udiff-line-added">+ macro makeHostFunctionCall(entry, protoCallFrame, temp1, temp2)</span>
      move entry, temp1
      storep cfr, [sp]
      if C_LOOP or C_LOOP_WIN
<span class="udiff-line-modified-removed">-         move sp, a0</span>
<span class="udiff-line-modified-added">+         loadp ProtoCallFrame::globalObject[protoCallFrame], a0</span>
<span class="udiff-line-added">+         move sp, a1</span>
          storep lr, PtrSize[sp]
          cloopCallNative temp1
      elsif X86 or X86_WIN
<span class="udiff-line-modified-removed">-         # Put callee frame pointer on stack as arg0, also put it in ecx for &quot;fastcall&quot; targets</span>
<span class="udiff-line-modified-added">+         # Put callee frame pointer on stack as arg1, also put it in ecx for &quot;fastcall&quot; targets</span>
          move 0, temp2
          move temp2, 4[sp] # put 0 in ReturnPC
<span class="udiff-line-modified-removed">-         move sp, a0 # a0 is ecx</span>
<span class="udiff-line-modified-removed">-         push temp2 # Push dummy arg1</span>
<span class="udiff-line-modified-added">+         move sp, a1 # a1 is edx</span>
<span class="udiff-line-modified-added">+         loadp ProtoCallFrame::globalObject[protoCallFrame], a0</span>
<span class="udiff-line-added">+         push a1</span>
          push a0
          call temp1
          addp 8, sp
<span class="udiff-line-added">+     elsif MIPS</span>
<span class="udiff-line-added">+         move sp, a1</span>
<span class="udiff-line-added">+         # We need to allocate stack space for 16 bytes (8-byte aligned)</span>
<span class="udiff-line-added">+         # for 4 arguments, since callee can use this space.</span>
<span class="udiff-line-added">+         subp 16, sp</span>
<span class="udiff-line-added">+         loadp ProtoCallFrame::globalObject[protoCallFrame], a0</span>
<span class="udiff-line-added">+         call temp1</span>
<span class="udiff-line-added">+         addp 16, sp</span>
      else
<span class="udiff-line-modified-removed">-         move sp, a0</span>
<span class="udiff-line-modified-added">+         loadp ProtoCallFrame::globalObject[protoCallFrame], a0</span>
<span class="udiff-line-added">+         move sp, a1</span>
          call temp1
      end
  end
  
  op(handleUncaughtException, macro()
      loadp Callee + PayloadOffset[cfr], t3
<span class="udiff-line-modified-removed">-     andp MarkedBlockMask, t3</span>
<span class="udiff-line-removed">-     loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t3], t3</span>
<span class="udiff-line-modified-added">+     convertCalleeToVM(t3)</span>
      restoreCalleeSavesFromVMEntryFrameCalleeSavesBuffer(t3, t0)
      storep 0, VM::callFrameForCatch[t3]
  
      loadp VM::topEntryFrame[t3], cfr
      if ARMv7
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -394,86 +404,99 @@</span>
  # Debugging operation if you&#39;d like to print an operand in the instruction stream. fromWhere
  # should be an immediate integer - any integer you like; use it to identify the place you&#39;re
  # debugging from. operand should likewise be an immediate, and should identify the operand
  # in the instruction stream you&#39;d like to print out.
  macro traceOperand(fromWhere, operand)
<span class="udiff-line-added">+     prepareStateForCCall()</span>
      move fromWhere, a2
      move operand, a3
      move cfr, a0
      move PC, a1
      cCall4(_llint_trace_operand)
<span class="udiff-line-modified-removed">-     move r0, PC</span>
<span class="udiff-line-modified-added">+     restoreStateAfterCCall()</span>
      move r1, cfr
  end
  
  # Debugging operation if you&#39;d like to print the value of an operand in the instruction
  # stream. Same as traceOperand(), but assumes that the operand is a register, and prints its
  # value.
  macro traceValue(fromWhere, operand)
<span class="udiff-line-added">+     prepareStateForCCall()</span>
      move fromWhere, a2
      move operand, a3
      move cfr, a0
      move PC, a1
      cCall4(_llint_trace_value)
<span class="udiff-line-modified-removed">-     move r0, PC</span>
<span class="udiff-line-modified-added">+     restoreStateAfterCCall()</span>
      move r1, cfr
  end
  
  # Call a slowPath for call opcodes.
  macro callCallSlowPath(slowPath, action)
<span class="udiff-line-modified-removed">-     storep PC, ArgumentCount + TagOffset[cfr]</span>
<span class="udiff-line-modified-added">+     storep PC, ArgumentCountIncludingThis + TagOffset[cfr]</span>
<span class="udiff-line-added">+     prepareStateForCCall()</span>
      move cfr, a0
      move PC, a1
      cCall2(slowPath)
      action(r0, r1)
  end
  
  macro callTrapHandler(throwHandler)
<span class="udiff-line-modified-removed">-     storei PC, ArgumentCount + TagOffset[cfr]</span>
<span class="udiff-line-modified-added">+     storei PC, ArgumentCountIncludingThis + TagOffset[cfr]</span>
<span class="udiff-line-added">+     prepareStateForCCall()</span>
      move cfr, a0
      move PC, a1
      cCall2(_llint_slow_path_handle_traps)
      btpnz r0, throwHandler
<span class="udiff-line-modified-removed">-     loadi ArgumentCount + TagOffset[cfr], PC</span>
<span class="udiff-line-modified-added">+     loadi ArgumentCountIncludingThis + TagOffset[cfr], PC</span>
  end
  
  macro checkSwitchToJITForLoop()
      checkSwitchToJIT(
          1,
          macro ()
<span class="udiff-line-modified-removed">-             storei PC, ArgumentCount + TagOffset[cfr]</span>
<span class="udiff-line-modified-added">+             storei PC, ArgumentCountIncludingThis + TagOffset[cfr]</span>
<span class="udiff-line-added">+             prepareStateForCCall()</span>
              move cfr, a0
              move PC, a1
              cCall2(_llint_loop_osr)
              btpz r0, .recover
              move r1, sp
              jmp r0
          .recover:
<span class="udiff-line-modified-removed">-             loadi ArgumentCount + TagOffset[cfr], PC</span>
<span class="udiff-line-modified-added">+             loadi ArgumentCountIncludingThis + TagOffset[cfr], PC</span>
          end)
  end
  
  macro loadVariable(get, fieldName, indexReg, tagReg, payloadReg)
      get(fieldName, indexReg)
      loadi TagOffset[cfr, indexReg, 8], tagReg
      loadi PayloadOffset[cfr, indexReg, 8], payloadReg
  end
  
<span class="udiff-line-added">+ # Index, tag, and payload must be different registers. Index is not</span>
<span class="udiff-line-added">+ # changed.</span>
<span class="udiff-line-added">+ macro loadConstant(size, index, tag, payload)</span>
<span class="udiff-line-added">+     size(FirstConstantRegisterIndexNarrow, FirstConstantRegisterIndexWide16, FirstConstantRegisterIndexWide32, macro (FirstConstantRegisterIndex)</span>
<span class="udiff-line-added">+         loadp CodeBlock[cfr], payload</span>
<span class="udiff-line-added">+         loadp CodeBlock::m_constantRegisters + VectorBufferOffset[payload], payload</span>
<span class="udiff-line-added">+         subp FirstConstantRegisterIndex, index</span>
<span class="udiff-line-added">+         loadp TagOffset[payload, index, 8], tag</span>
<span class="udiff-line-added">+         loadp PayloadOffset[payload, index, 8], payload</span>
<span class="udiff-line-added">+     end)</span>
<span class="udiff-line-added">+ end</span>
<span class="udiff-line-added">+ </span>
  # Index, tag, and payload must be different registers. Index is not
  # changed.
  macro loadConstantOrVariable(size, index, tag, payload)
      size(FirstConstantRegisterIndexNarrow, FirstConstantRegisterIndexWide16, FirstConstantRegisterIndexWide32, macro (FirstConstantRegisterIndex)
          bigteq index, FirstConstantRegisterIndex, .constant
          loadi TagOffset[cfr, index, 8], tag
          loadi PayloadOffset[cfr, index, 8], payload
          jmp .done
      .constant:
<span class="udiff-line-modified-removed">-         loadp CodeBlock[cfr], payload</span>
<span class="udiff-line-removed">-         loadp CodeBlock::m_constantRegisters + VectorBufferOffset[payload], payload</span>
<span class="udiff-line-removed">-         subp FirstConstantRegisterIndex, index</span>
<span class="udiff-line-removed">-         loadp TagOffset[payload, index, 8], tag</span>
<span class="udiff-line-removed">-         loadp PayloadOffset[payload, index, 8], payload</span>
<span class="udiff-line-modified-added">+         loadConstant(size, index, tag, payload)</span>
      .done:
      end)
  end
  
  macro loadConstantOrVariableTag(size, index, tag)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -548,18 +571,18 @@</span>
  
  macro writeBarrierOnCellWithReload(cell, reloadAfterSlowPath)
      skipIfIsRememberedOrInEden(
          cell,
          macro()
<span class="udiff-line-modified-removed">-             push cfr, PC</span>
<span class="udiff-line-modified-added">+             push PB, PC</span>
              # We make two extra slots because cCall2 will poke.
              subp 8, sp
              move cell, a1 # cell can be a0
              move cfr, a0
              cCall2Void(_llint_write_barrier_slow)
              addp 8, sp
<span class="udiff-line-modified-removed">-             pop PC, cfr</span>
<span class="udiff-line-modified-added">+             pop PC, PB</span>
              reloadAfterSlowPath()
          end)
  end
  
  macro writeBarrierOnOperand(size, get, cellFieldName)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -614,12 +637,13 @@</span>
  
  # Entrypoints into the interpreter
  
  # Expects that CodeBlock is in t1, which is what prologue() leaves behind.
  macro functionArityCheck(doneLabel, slowPath)
<span class="udiff-line-modified-removed">-     loadi PayloadOffset + ArgumentCount[cfr], t0</span>
<span class="udiff-line-modified-added">+     loadi PayloadOffset + ArgumentCountIncludingThis[cfr], t0</span>
      biaeq t0, CodeBlock::m_numParameters[t1], doneLabel
<span class="udiff-line-added">+     prepareStateForCCall()</span>
      move cfr, a0
      move PC, a1
      cCall2(slowPath)   # This slowPath has a simple protocol: t0 = 0 =&gt; no error, t0 != 0 =&gt; error
      btiz r0, .noError
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -632,11 +656,11 @@</span>
      jmp _llint_throw_from_slow_path_trampoline
  
  .noError:
      move r1, t1 # r1 contains slotsToAdd.
      btiz t1, .continue
<span class="udiff-line-modified-removed">-     loadi PayloadOffset + ArgumentCount[cfr], t2</span>
<span class="udiff-line-modified-added">+     loadi PayloadOffset + ArgumentCountIncludingThis[cfr], t2</span>
      addi CallFrameHeaderSlots, t2
  
      // Check if there are some unaligned slots we can use
      move t1, t3
      andi StackAlignmentSlots - 1, t3
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -680,58 +704,42 @@</span>
      baddinz 1, t2, .fillLoop
  
  .continue:
      # Reload CodeBlock and PC, since the slow_path clobbered it.
      loadp CodeBlock[cfr], t1
<span class="udiff-line-modified-removed">-     loadp CodeBlock::m_instructionsRawPointer[t1], PC</span>
<span class="udiff-line-modified-added">+     loadp CodeBlock::m_instructionsRawPointer[t1], PB</span>
<span class="udiff-line-added">+     move 0, PC</span>
      jmp doneLabel
  end
  
<span class="udiff-line-removed">- macro branchIfException(label)</span>
<span class="udiff-line-removed">-     loadp Callee + PayloadOffset[cfr], t3</span>
<span class="udiff-line-removed">-     andp MarkedBlockMask, t3</span>
<span class="udiff-line-removed">-     loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t3], t3</span>
<span class="udiff-line-removed">-     btpz VM::m_exception[t3], .noException</span>
<span class="udiff-line-removed">-     jmp label</span>
<span class="udiff-line-removed">- .noException:</span>
<span class="udiff-line-removed">- end</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
  # Instruction implementations
  
  _llint_op_enter:
      traceExecution()
      checkStackPointerAlignment(t2, 0xdead00e1)
<span class="udiff-line-modified-removed">-     loadp CodeBlock[cfr], t1                // t1&lt;CodeBlock&gt; = cfr.CodeBlock</span>
<span class="udiff-line-modified-removed">-     loadi CodeBlock::m_numVars[t1], t2      // t2&lt;size_t&gt; = t1&lt;CodeBlock&gt;.m_numVars</span>
<span class="udiff-line-modified-added">+     loadp CodeBlock[cfr], t2                // t2&lt;CodeBlock&gt; = cfr.CodeBlock</span>
<span class="udiff-line-modified-added">+     loadi CodeBlock::m_numVars[t2], t2      // t2&lt;size_t&gt; = t2&lt;CodeBlock&gt;.m_numVars</span>
      subi CalleeSaveSpaceAsVirtualRegisters, t2
      move cfr, t3
      subp CalleeSaveSpaceAsVirtualRegisters * SlotSize, t3
      btiz t2, .opEnterDone
      move UndefinedTag, t0
<span class="udiff-line-added">+     move 0, t1</span>
      negi t2
  .opEnterLoop:
      storei t0, TagOffset[t3, t2, 8]
<span class="udiff-line-modified-removed">-     storei 0, PayloadOffset[t3, t2, 8]</span>
<span class="udiff-line-modified-added">+     storei t1, PayloadOffset[t3, t2, 8]</span>
      addi 1, t2
      btinz t2, .opEnterLoop
  .opEnterDone:
<span class="udiff-line-modified-removed">-     writeBarrierOnCellWithReload(t1, macro ()</span>
<span class="udiff-line-removed">-         loadp CodeBlock[cfr], t1 # Reload CodeBlock</span>
<span class="udiff-line-removed">-     end)</span>
<span class="udiff-line-removed">-     # Checking traps.</span>
<span class="udiff-line-removed">-     loadp CodeBlock::m_vm[t1], t1</span>
<span class="udiff-line-removed">-     btpnz VM::m_traps + VMTraps::m_needTrapHandling[t1], .handleTraps</span>
<span class="udiff-line-removed">- .afterHandlingTraps:</span>
<span class="udiff-line-modified-added">+     callSlowPath(_slow_path_enter)</span>
      dispatchOp(narrow, op_enter)
<span class="udiff-line-modified-removed">- .handleTraps:</span>
<span class="udiff-line-removed">-     callTrapHandler(_llint_throw_from_slow_path_trampoline)</span>
<span class="udiff-line-removed">-     jmp .afterHandlingTraps</span>
<span class="udiff-line-modified-added">+ </span>
  
  llintOpWithProfile(op_get_argument, OpGetArgument, macro (size, get, dispatch, return)
      get(m_index, t2)
<span class="udiff-line-modified-removed">-     loadi PayloadOffset + ArgumentCount[cfr], t0</span>
<span class="udiff-line-modified-added">+     loadi PayloadOffset + ArgumentCountIncludingThis[cfr], t0</span>
      bilteq t0, t2, .opGetArgumentOutOfBounds
      loadi ThisArgumentOffset + TagOffset[cfr, t2, 8], t0
      loadi ThisArgumentOffset + PayloadOffset[cfr, t2, 8], t3
      return (t0, t3)
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -739,11 +747,11 @@</span>
      return (UndefinedTag, 0)
  end)
  
  
  llintOpWithReturn(op_argument_count, OpArgumentCount, macro (size, get, dispatch, return)
<span class="udiff-line-modified-removed">-     loadi PayloadOffset + ArgumentCount[cfr], t0</span>
<span class="udiff-line-modified-added">+     loadi PayloadOffset + ArgumentCountIncludingThis[cfr], t0</span>
      subi 1, t0
      return(Int32Tag, t0)
  end)
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -944,17 +952,24 @@</span>
  
  strictEqualityJumpOp(jnstricteq, OpJnstricteq,
      macro (left, right, target) bineq left, right, target end)
  
  
<span class="udiff-line-modified-removed">- macro preOp(opcodeName, opcodeStruct, operation)</span>
<span class="udiff-line-modified-removed">-     llintOp(op_%opcodeName%, opcodeStruct, macro (size, get, dispatch)</span>
<span class="udiff-line-modified-added">+ macro preOp(opcodeName, opcodeStruct, integerOperation)</span>
<span class="udiff-line-modified-added">+     llintOpWithMetadata(op_%opcodeName%, opcodeStruct, macro (size, get, dispatch, metadata, return)</span>
<span class="udiff-line-added">+         macro updateArithProfile(type)</span>
<span class="udiff-line-added">+             orh type, %opcodeStruct%::Metadata::m_arithProfile + UnaryArithProfile::m_bits[t1]</span>
<span class="udiff-line-added">+         end</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         metadata(t1, t2)</span>
          get(m_srcDst, t0)
          bineq TagOffset[cfr, t0, 8], Int32Tag, .slow
<span class="udiff-line-modified-removed">-         loadi PayloadOffset[cfr, t0, 8], t1</span>
<span class="udiff-line-modified-removed">-         operation(t1, .slow)</span>
<span class="udiff-line-modified-removed">-         storei t1, PayloadOffset[cfr, t0, 8]</span>
<span class="udiff-line-modified-added">+         loadi PayloadOffset[cfr, t0, 8], t2</span>
<span class="udiff-line-modified-added">+         # Metadata in t1, srcDst in t2</span>
<span class="udiff-line-modified-added">+         integerOperation(t2, .slow)</span>
<span class="udiff-line-added">+         storei t2, PayloadOffset[cfr, t0, 8]</span>
<span class="udiff-line-added">+         updateArithProfile(ArithProfileInt)</span>
          dispatch()
  
      .slow:
          callSlowPath(_slow_path_%opcodeName%)
          dispatch()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -973,10 +988,23 @@</span>
  .opToNumberSlow:
      callSlowPath(_slow_path_to_number)
      dispatch()
  end)
  
<span class="udiff-line-added">+ llintOpWithProfile(op_to_numeric, OpToNumeric, macro (size, get, dispatch, return)</span>
<span class="udiff-line-added">+     get(m_operand, t0)</span>
<span class="udiff-line-added">+     loadConstantOrVariable(size, t0, t2, t3)</span>
<span class="udiff-line-added">+     bieq t2, Int32Tag, .opToNumericIsInt</span>
<span class="udiff-line-added">+     biaeq t2, LowestTag, .opToNumericSlow</span>
<span class="udiff-line-added">+ .opToNumericIsInt:</span>
<span class="udiff-line-added">+     return(t2, t3)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ .opToNumericSlow:</span>
<span class="udiff-line-added">+     callSlowPath(_slow_path_to_numeric)</span>
<span class="udiff-line-added">+     dispatch()</span>
<span class="udiff-line-added">+ end)</span>
<span class="udiff-line-added">+ </span>
  
  llintOpWithReturn(op_to_string, OpToString, macro (size, get, dispatch, return)
      get(m_operand, t0)
      loadConstantOrVariable(size, t0, t2, t3)
      bineq t2, CellTag, .opToStringSlow
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1003,26 +1031,26 @@</span>
  end)
  
  
  llintOpWithMetadata(op_negate, OpNegate, macro (size, get, dispatch, metadata, return)
  
<span class="udiff-line-modified-removed">-     macro arithProfile(type)</span>
<span class="udiff-line-modified-removed">-         ori type, OpNegate::Metadata::m_arithProfile + ArithProfile::m_bits[t5]</span>
<span class="udiff-line-modified-added">+     macro updateArithProfile(type)</span>
<span class="udiff-line-modified-added">+         orh type, OpNegate::Metadata::m_arithProfile + UnaryArithProfile::m_bits[t5]</span>
      end
  
      metadata(t5, t0)
      get(m_operand, t0)
      loadConstantOrVariable(size, t0, t1, t2)
      bineq t1, Int32Tag, .opNegateSrcNotInt
      btiz t2, 0x7fffffff, .opNegateSlow
      negi t2
<span class="udiff-line-modified-removed">-     arithProfile(ArithProfileInt)</span>
<span class="udiff-line-modified-added">+     updateArithProfile(ArithProfileInt)</span>
      return (Int32Tag, t2)
  .opNegateSrcNotInt:
      bia t1, LowestTag, .opNegateSlow
      xori 0x80000000, t1
<span class="udiff-line-modified-removed">-     arithProfile(ArithProfileNumber)</span>
<span class="udiff-line-modified-added">+     updateArithProfile(ArithProfileNumber)</span>
      return(t1, t2)
  
  .opNegateSlow:
      callSlowPath(_slow_path_negate)
      dispatch()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1030,11 +1058,11 @@</span>
  
  
  macro binaryOpCustomStore(opcodeName, opcodeStruct, integerOperationAndStore, doubleOperation)
      llintOpWithMetadata(op_%opcodeName%, opcodeStruct, macro (size, get, dispatch, metadata, return)
          macro arithProfile(type)
<span class="udiff-line-modified-removed">-             ori type, %opcodeStruct%::Metadata::m_arithProfile + ArithProfile::m_bits[t5]</span>
<span class="udiff-line-modified-added">+             orh type, %opcodeStruct%::Metadata::m_arithProfile + BinaryArithProfile::m_bits[t5]</span>
          end
  
          metadata(t5, t2)
          get(m_rhs, t2)
          get(m_lhs, t0)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1051,11 +1079,11 @@</span>
          # First operand is definitely not an int, the second operand could be anything.
          bia t2, LowestTag, .slow
          bib t3, LowestTag, .op1NotIntOp2Double
          bineq t3, Int32Tag, .slow
          arithProfile(ArithProfileNumberInt)
<span class="udiff-line-modified-removed">-         ci2d t1, ft1</span>
<span class="udiff-line-modified-added">+         ci2ds t1, ft1</span>
          jmp .op1NotIntReady
      .op1NotIntOp2Double:
          fii2d t1, t3, ft1
          arithProfile(ArithProfileNumberNumber)
      .op1NotIntReady:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1068,11 +1096,11 @@</span>
      .op2NotInt:
          # First operand is definitely an int, the second operand is definitely not.
          get(m_dst, t2)
          bia t3, LowestTag, .slow
          arithProfile(ArithProfileIntNumber)
<span class="udiff-line-modified-removed">-         ci2d t0, ft0</span>
<span class="udiff-line-modified-added">+         ci2ds t0, ft0</span>
          fii2d t1, t3, ft1
          doubleOperation(ft1, ft0)
          stored ft0, [cfr, t2, 8]
          dispatch()
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1117,12 +1145,12 @@</span>
      macro (left, right) subd left, right end)
  
  
  binaryOpCustomStore(div, OpDiv,
      macro (int32Tag, left, right, slow, index)
<span class="udiff-line-modified-removed">-         ci2d left, ft0</span>
<span class="udiff-line-modified-removed">-         ci2d right, ft1</span>
<span class="udiff-line-modified-added">+         ci2ds left, ft0</span>
<span class="udiff-line-modified-added">+         ci2ds right, ft1</span>
          divd ft0, ft1
          bcd2i ft1, right, .notInt
          storei int32Tag, TagOffset[cfr, index, 8]
          storei right, PayloadOffset[cfr, index, 8]
          jmp .done
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1403,10 +1431,17 @@</span>
      return(t0, t1)
  
  .opGetByIdSlow:
      callSlowPath(_llint_slow_path_get_by_id)
      dispatch()
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ .osrReturnPoint:</span>
<span class="udiff-line-added">+     getterSetterOSRExitReturnPoint(op_get_by_id, size)</span>
<span class="udiff-line-added">+     metadata(t2, t3)</span>
<span class="udiff-line-added">+     valueProfile(OpGetById, t2, r1, r0)</span>
<span class="udiff-line-added">+     return(r1, r0)</span>
<span class="udiff-line-added">+ </span>
  end)
  
  
  llintOpWithMetadata(op_put_by_id, OpPutById, macro (size, get, dispatch, metadata, return)
      writeBarrierOnOperands(size, get, m_base, m_value)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1465,10 +1500,15 @@</span>
      dispatch()
  
  .opPutByIdSlow:
      callSlowPath(_llint_slow_path_put_by_id)
      dispatch()
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ .osrReturnPoint:</span>
<span class="udiff-line-added">+     getterSetterOSRExitReturnPoint(op_put_by_id, size)</span>
<span class="udiff-line-added">+     dispatch()</span>
<span class="udiff-line-added">+ </span>
  end)
  
  
  llintOpWithMetadata(op_get_by_val, OpGetByVal, macro (size, get, dispatch, metadata, return)
      metadata(t5, t2)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1516,14 +1556,21 @@</span>
      dispatch()
  
  .opGetByValSlow:
      callSlowPath(_llint_slow_path_get_by_val)
      dispatch()
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ .osrReturnPoint:</span>
<span class="udiff-line-added">+     getterSetterOSRExitReturnPoint(op_get_by_val, size)</span>
<span class="udiff-line-added">+     metadata(t2, t3)</span>
<span class="udiff-line-added">+     valueProfile(OpGetByVal, t2, r1, r0)</span>
<span class="udiff-line-added">+     return(r1, r0)</span>
<span class="udiff-line-added">+ </span>
  end)
  
  
<span class="udiff-line-modified-removed">- macro putByValOp(opcodeName, opcodeStruct)</span>
<span class="udiff-line-modified-added">+ macro putByValOp(opcodeName, opcodeStruct, osrExitPoint)</span>
      llintOpWithMetadata(op_%opcodeName%, opcodeStruct, macro (size, get, dispatch, metadata, return)
          macro contiguousPutByVal(storeCallback)
              biaeq t3, -sizeof IndexingHeader + IndexingHeader::u.lengths.publicLength[t0], .outOfBounds
          .storeResult:
              get(m_value, t2)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1563,11 +1610,11 @@</span>
              macro (operand, scratch, base, index)
                  const tag = scratch
                  const payload = operand
                  loadConstantOrVariable2Reg(size, operand, tag, payload)
                  bineq tag, Int32Tag, .notInt
<span class="udiff-line-modified-removed">-                 ci2d payload, ft0</span>
<span class="udiff-line-modified-added">+                 ci2ds payload, ft0</span>
                  jmp .ready
              .notInt:
                  fii2d payload, tag, ft0
                  bdnequn ft0, ft0, .opPutByValSlow
              .ready:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1607,17 +1654,24 @@</span>
      .opPutByValOutOfBounds:
          storeb 1, %opcodeStruct%::Metadata::m_arrayProfile.m_outOfBounds[t5]
      .opPutByValSlow:
          callSlowPath(_llint_slow_path_%opcodeName%)
          dispatch()
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     .osrExitPoint:</span>
<span class="udiff-line-added">+         osrExitPoint(size, dispatch)</span>
      end)
  end
  
  
<span class="udiff-line-modified-removed">- putByValOp(put_by_val, OpPutByVal)</span>
<span class="udiff-line-modified-added">+ putByValOp(put_by_val, OpPutByVal, macro (size, dispatch)</span>
<span class="udiff-line-added">+ .osrReturnPoint:</span>
<span class="udiff-line-added">+     getterSetterOSRExitReturnPoint(op_put_by_val, size)</span>
<span class="udiff-line-added">+     dispatch()</span>
<span class="udiff-line-added">+ end)</span>
  
<span class="udiff-line-modified-removed">- putByValOp(put_by_val_direct, OpPutByValDirect)</span>
<span class="udiff-line-modified-added">+ putByValOp(put_by_val_direct, OpPutByValDirect, macro (a, b) end)</span>
  
  
  macro llintJumpTrueOrFalseOp(opcodeName, opcodeStruct, conditionOp)
      llintOpWithJump(op_%opcodeName%, opcodeStruct, macro (size, get, jump, dispatch)
          get(m_condition, t1)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1695,21 +1749,19 @@</span>
  undefinedOrNullJumpOp(jnundefined_or_null, OpJnundefinedOrNull,
      macro (value, target) bineq value, NullTag, target end)
  
  llintOpWithMetadata(op_jneq_ptr, OpJneqPtr, macro (size, get, dispatch, metadata, return)
      get(m_value, t0)
<span class="udiff-line-modified-removed">-     getu(size, OpJneqPtr, m_specialPointer, t1)</span>
<span class="udiff-line-modified-removed">-     loadp CodeBlock[cfr], t2</span>
<span class="udiff-line-removed">-     loadp CodeBlock::m_globalObject[t2], t2</span>
<span class="udiff-line-modified-added">+     get(m_specialPointer, t1)</span>
<span class="udiff-line-modified-added">+     loadConstant(size, t1, t3, t2)</span>
      bineq TagOffset[cfr, t0, 8], CellTag, .opJneqPtrBranch
<span class="udiff-line-modified-removed">-     loadp JSGlobalObject::m_specialPointers[t2, t1, 4], t1</span>
<span class="udiff-line-removed">-     bpeq PayloadOffset[cfr, t0, 8], t1, .opJneqPtrFallThrough</span>
<span class="udiff-line-modified-added">+     bpeq PayloadOffset[cfr, t0, 8], t2, .opJneqPtrFallThrough</span>
  .opJneqPtrBranch:
      metadata(t5, t2)
      storeb 1, OpJneqPtr::Metadata::m_hasJumped[t5]
      get(m_targetLabel, t0)
<span class="udiff-line-modified-removed">-     jumpImpl(t0)</span>
<span class="udiff-line-modified-added">+     jumpImpl(dispatchIndirect, t0)</span>
  .opJneqPtrFallThrough:
      dispatch()
  end)
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1753,21 +1805,21 @@</span>
  
      .op1NotInt:
          bia t0, LowestTag, .slow
          bib t2, LowestTag, .op1NotIntOp2Double
          bineq t2, Int32Tag, .slow
<span class="udiff-line-modified-removed">-         ci2d t3, ft1</span>
<span class="udiff-line-modified-added">+         ci2ds t3, ft1</span>
          jmp .op1NotIntReady
      .op1NotIntOp2Double:
          fii2d t3, t2, ft1
      .op1NotIntReady:
          fii2d t1, t0, ft0
          doubleCompare(ft0, ft1, .jumpTarget)
          dispatch()
  
      .op2NotInt:
<span class="udiff-line-modified-removed">-         ci2d t1, ft0</span>
<span class="udiff-line-modified-added">+         ci2ds t1, ft0</span>
          bia t2, LowestTag, .slow
          fii2d t3, t2, ft1
          doubleCompare(ft0, ft1, .jumpTarget)
          dispatch()
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1875,19 +1927,19 @@</span>
          lshifti 3, t3
          negi t3
          addp cfr, t3  # t3 contains the new value of cfr
          storei t2, Callee + PayloadOffset[t3]
          getu(size, opcodeStruct, m_argc, t2)
<span class="udiff-line-modified-removed">-         storei PC, ArgumentCount + TagOffset[cfr]</span>
<span class="udiff-line-modified-removed">-         storei t2, ArgumentCount + PayloadOffset[t3]</span>
<span class="udiff-line-modified-added">+         storei PC, ArgumentCountIncludingThis + TagOffset[cfr]</span>
<span class="udiff-line-modified-added">+         storei t2, ArgumentCountIncludingThis + PayloadOffset[t3]</span>
          storei CellTag, Callee + TagOffset[t3]
          move t3, sp
          prepareCall(%opcodeStruct%::Metadata::m_callLinkInfo.m_machineCodeTarget[t5], t2, t3, t4, JSEntryPtrTag)
<span class="udiff-line-modified-removed">-         callTargetFunction(size, opcodeStruct, dispatch, %opcodeStruct%::Metadata::m_callLinkInfo.m_machineCodeTarget[t5], JSEntryPtrTag)</span>
<span class="udiff-line-modified-added">+         callTargetFunction(opcodeName, size, opcodeStruct, dispatch, %opcodeStruct%::Metadata::m_callLinkInfo.m_machineCodeTarget[t5], JSEntryPtrTag)</span>
  
      .opCallSlow:
<span class="udiff-line-modified-removed">-         slowPathForCall(size, opcodeStruct, dispatch, slowPath, prepareCall)</span>
<span class="udiff-line-modified-added">+         slowPathForCall(opcodeName, size, opcodeStruct, dispatch, slowPath, prepareCall)</span>
      end)
  end
  
  llintOp(op_ret, OpRet, macro (size, get, dispatch)
      checkSwitchToJITForEpilogue()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1909,38 +1961,54 @@</span>
      callSlowPath(_slow_path_to_primitive)
      dispatch()
  end)
  
  
<span class="udiff-line-added">+ llintOpWithReturn(op_to_property_key, OpToPropertyKey, macro (size, get, dispatch, return)</span>
<span class="udiff-line-added">+     get(m_src, t2)</span>
<span class="udiff-line-added">+     loadConstantOrVariable(size, t2, t1, t0)</span>
<span class="udiff-line-added">+     bineq t1, CellTag, .opToPropertyKeySlow</span>
<span class="udiff-line-added">+     bbeq JSCell::m_type[t0], SymbolType, .done</span>
<span class="udiff-line-added">+     bbneq JSCell::m_type[t0], StringType, .opToPropertyKeySlow</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ .done:</span>
<span class="udiff-line-added">+     return(t1, t0)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ .opToPropertyKeySlow:</span>
<span class="udiff-line-added">+     callSlowPath(_slow_path_to_property_key)</span>
<span class="udiff-line-added">+     dispatch()</span>
<span class="udiff-line-added">+ end)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  commonOp(llint_op_catch, macro() end, macro (size)
      # This is where we end up from the JIT&#39;s throw trampoline (because the
      # machine code return address will be set to _llint_op_catch), and from
      # the interpreter&#39;s throw trampoline (see _llint_throw_trampoline).
      # The throwing code must have known that we were throwing to the interpreter,
      # and have set VM::targetInterpreterPCForThrow.
      loadp Callee + PayloadOffset[cfr], t3
<span class="udiff-line-modified-removed">-     andp MarkedBlockMask, t3</span>
<span class="udiff-line-removed">-     loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t3], t3</span>
<span class="udiff-line-modified-added">+     convertCalleeToVM(t3)</span>
      restoreCalleeSavesFromVMEntryFrameCalleeSavesBuffer(t3, t0)
      loadp VM::callFrameForCatch[t3], cfr
      storep 0, VM::callFrameForCatch[t3]
      restoreStackPointerAfterCall()
  
      # restore metadataTable since we don&#39;t restore callee saves for CLoop during unwinding
      loadp CodeBlock[cfr], t1
      loadp CodeBlock::m_metadata[t1], metadataTable
<span class="udiff-line-added">+     loadp CodeBlock::m_instructionsRawPointer[t1], PB</span>
  
<span class="udiff-line-modified-removed">-     loadi VM::targetInterpreterPCForThrow[t3], PC</span>
<span class="udiff-line-modified-added">+     loadp VM::targetInterpreterPCForThrow[t3], PC</span>
<span class="udiff-line-added">+     subp PB, PC</span>
  
      callSlowPath(_llint_slow_path_check_if_exception_is_uncatchable_and_notify_profiler)
      bpeq r1, 0, .isCatchableException
      jmp _llint_throw_from_slow_path_trampoline
  
  .isCatchableException:
<span class="udiff-line-modified-removed">-     loadp Callee + PayloadOffset[cfr], t3</span>
<span class="udiff-line-modified-removed">-     andp MarkedBlockMask, t3</span>
<span class="udiff-line-removed">-     loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t3], t3</span>
<span class="udiff-line-modified-added">+     loadp CodeBlock[cfr], t3</span>
<span class="udiff-line-modified-added">+     loadp CodeBlock::m_vm[t3], t3</span>
  
      loadp VM::m_exception[t3], t0
      storep 0, VM::m_exception[t3]
      get(size, OpCatch, m_exception, t2)
      storei t0, PayloadOffset[cfr, t2, 8]
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1969,22 +2037,20 @@</span>
  end)
  
  
  op(llint_throw_from_slow_path_trampoline, macro()
      loadp Callee[cfr], t1
<span class="udiff-line-modified-removed">-     andp MarkedBlockMask, t1</span>
<span class="udiff-line-removed">-     loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t1], t1</span>
<span class="udiff-line-modified-added">+     convertCalleeToVM(t1)</span>
      copyCalleeSavesToVMEntryFrameCalleeSavesBuffer(t1, t2)
  
      callSlowPath(_llint_slow_path_handle_exception)
  
      # When throwing from the interpreter (i.e. throwing from LLIntSlowPaths), so
      # the throw target is not necessarily interpreted code, we come to here.
      # This essentially emulates the JIT&#39;s throwing protocol.
      loadp Callee[cfr], t1
<span class="udiff-line-modified-removed">-     andp MarkedBlockMask, t1</span>
<span class="udiff-line-removed">-     loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t1], t1</span>
<span class="udiff-line-modified-added">+     convertCalleeToVM(t1)</span>
      jmp VM::targetMachinePCForThrow[t1]
  end)
  
  
  op(llint_throw_during_call_trampoline, macro()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1992,128 +2058,106 @@</span>
      jmp _llint_throw_from_slow_path_trampoline
  end)
  
  
  macro nativeCallTrampoline(executableOffsetToFunction)
<span class="udiff-line-removed">- </span>
      functionPrologue()
      storep 0, CodeBlock[cfr]
<span class="udiff-line-modified-removed">-     loadi Callee + PayloadOffset[cfr], t1</span>
<span class="udiff-line-removed">-     // Callee is still in t1 for code below</span>
<span class="udiff-line-modified-added">+ </span>
      if X86 or X86_WIN
          subp 8, sp # align stack pointer
<span class="udiff-line-modified-removed">-         andp MarkedBlockMask, t1</span>
<span class="udiff-line-modified-removed">-         loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t1], t3</span>
<span class="udiff-line-removed">-         storep cfr, VM::topCallFrame[t3]</span>
<span class="udiff-line-removed">-         move cfr, a0  # a0 = ecx</span>
<span class="udiff-line-removed">-         storep a0, [sp]</span>
<span class="udiff-line-removed">-         loadi Callee + PayloadOffset[cfr], t1</span>
<span class="udiff-line-removed">-         loadp JSFunction::m_executable[t1], t1</span>
<span class="udiff-line-removed">-         checkStackPointerAlignment(t3, 0xdead0001)</span>
<span class="udiff-line-removed">-         call executableOffsetToFunction[t1]</span>
<span class="udiff-line-removed">-         loadp Callee + PayloadOffset[cfr], t3</span>
<span class="udiff-line-removed">-         andp MarkedBlockMask, t3</span>
<span class="udiff-line-removed">-         loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t3], t3</span>
<span class="udiff-line-removed">-         addp 8, sp</span>
<span class="udiff-line-removed">-     elsif ARMv7 or C_LOOP or C_LOOP_WIN or MIPS</span>
<span class="udiff-line-removed">-         if MIPS</span>
<span class="udiff-line-modified-added">+         storep cfr, [sp]</span>
<span class="udiff-line-modified-added">+     elsif MIPS</span>
          # calling convention says to save stack space for 4 first registers in
          # all cases. To match our 16-byte alignment, that means we need to
          # take 24 bytes
<span class="udiff-line-modified-removed">-             subp 24, sp</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             subp 8, sp # align stack pointer</span>
<span class="udiff-line-removed">-         end</span>
<span class="udiff-line-removed">-         # t1 already contains the Callee.</span>
<span class="udiff-line-removed">-         andp MarkedBlockMask, t1</span>
<span class="udiff-line-removed">-         loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t1], t1</span>
<span class="udiff-line-removed">-         storep cfr, VM::topCallFrame[t1]</span>
<span class="udiff-line-removed">-         move cfr, a0</span>
<span class="udiff-line-removed">-         loadi Callee + PayloadOffset[cfr], t1</span>
<span class="udiff-line-removed">-         loadp JSFunction::m_executable[t1], t1</span>
<span class="udiff-line-removed">-         checkStackPointerAlignment(t3, 0xdead0001)</span>
<span class="udiff-line-removed">-         if C_LOOP or C_LOOP_WIN</span>
<span class="udiff-line-removed">-             cloopCallNative executableOffsetToFunction[t1]</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             call executableOffsetToFunction[t1]</span>
<span class="udiff-line-removed">-         end</span>
<span class="udiff-line-removed">-         loadp Callee + PayloadOffset[cfr], t3</span>
<span class="udiff-line-removed">-         andp MarkedBlockMask, t3</span>
<span class="udiff-line-removed">-         loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t3], t3</span>
<span class="udiff-line-removed">-         if MIPS</span>
<span class="udiff-line-removed">-             addp 24, sp</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             addp 8, sp</span>
<span class="udiff-line-removed">-         end</span>
<span class="udiff-line-modified-added">+         subp 24, sp</span>
      else
<span class="udiff-line-modified-removed">-         error</span>
<span class="udiff-line-modified-added">+         subp 8, sp # align stack pointer</span>
      end
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     loadp Callee + PayloadOffset[cfr], a0</span>
<span class="udiff-line-added">+     loadp JSFunction::m_executableOrRareData[a0], a2</span>
<span class="udiff-line-added">+     btpz a2, (constexpr JSFunction::rareDataTag), .isExecutable</span>
<span class="udiff-line-added">+     loadp (FunctionRareData::m_executable - (constexpr JSFunction::rareDataTag))[a2], a2</span>
<span class="udiff-line-added">+ .isExecutable:</span>
<span class="udiff-line-added">+     loadp JSFunction::m_scope[a0], a0</span>
<span class="udiff-line-added">+     loadp JSGlobalObject::m_vm[a0], a1</span>
<span class="udiff-line-added">+     storep cfr, VM::topCallFrame[a1]</span>
<span class="udiff-line-added">+     move cfr, a1</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     checkStackPointerAlignment(t3, 0xdead0001)</span>
<span class="udiff-line-added">+     if C_LOOP or C_LOOP_WIN</span>
<span class="udiff-line-added">+         cloopCallNative executableOffsetToFunction[a2]</span>
<span class="udiff-line-added">+     else</span>
<span class="udiff-line-added">+         call executableOffsetToFunction[a2]</span>
<span class="udiff-line-added">+     end</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     loadp Callee + PayloadOffset[cfr], t3</span>
<span class="udiff-line-added">+     loadp JSFunction::m_scope[t3], t3</span>
<span class="udiff-line-added">+     loadp JSGlobalObject::m_vm[t3], t3</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if MIPS</span>
<span class="udiff-line-added">+         addp 24, sp</span>
<span class="udiff-line-added">+     else</span>
<span class="udiff-line-added">+         addp 8, sp</span>
<span class="udiff-line-added">+     end</span>
<span class="udiff-line-added">+ </span>
      btpnz VM::m_exception[t3], .handleException
  
      functionEpilogue()
      ret
  
  .handleException:
<span class="udiff-line-modified-removed">- if X86 or X86_WIN</span>
<span class="udiff-line-modified-removed">-     subp 8, sp # align stack pointer</span>
<span class="udiff-line-modified-removed">- end</span>
<span class="udiff-line-modified-added">+     if X86 or X86_WIN</span>
<span class="udiff-line-modified-added">+         subp 8, sp # align stack pointer</span>
<span class="udiff-line-modified-added">+     end</span>
      storep cfr, VM::topCallFrame[t3]
      jmp _llint_throw_from_slow_path_trampoline
  end
  
  
  macro internalFunctionCallTrampoline(offsetOfFunction)
      functionPrologue()
      storep 0, CodeBlock[cfr]
<span class="udiff-line-modified-removed">-     loadi Callee + PayloadOffset[cfr], t1</span>
<span class="udiff-line-modified-added">+ </span>
      // Callee is still in t1 for code below
      if X86 or X86_WIN
          subp 8, sp # align stack pointer
<span class="udiff-line-modified-removed">-         andp MarkedBlockMask, t1</span>
<span class="udiff-line-modified-removed">-         loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t1], t3</span>
<span class="udiff-line-removed">-         storep cfr, VM::topCallFrame[t3]</span>
<span class="udiff-line-removed">-         move cfr, a0  # a0 = ecx</span>
<span class="udiff-line-removed">-         storep a0, [sp]</span>
<span class="udiff-line-removed">-         loadi Callee + PayloadOffset[cfr], t1</span>
<span class="udiff-line-removed">-         checkStackPointerAlignment(t3, 0xdead0001)</span>
<span class="udiff-line-removed">-         call offsetOfFunction[t1]</span>
<span class="udiff-line-removed">-         loadp Callee + PayloadOffset[cfr], t3</span>
<span class="udiff-line-removed">-         andp MarkedBlockMask, t3</span>
<span class="udiff-line-removed">-         loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t3], t3</span>
<span class="udiff-line-removed">-         addp 8, sp</span>
<span class="udiff-line-removed">-     elsif ARMv7 or C_LOOP or C_LOOP_WIN or MIPS</span>
<span class="udiff-line-modified-added">+         storep cfr, [sp]</span>
<span class="udiff-line-modified-added">+     else</span>
          subp 8, sp # align stack pointer
<span class="udiff-line-modified-removed">-         # t1 already contains the Callee.</span>
<span class="udiff-line-modified-removed">-         andp MarkedBlockMask, t1</span>
<span class="udiff-line-modified-removed">-         loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t1], t1</span>
<span class="udiff-line-modified-removed">-         storep cfr, VM::topCallFrame[t1]</span>
<span class="udiff-line-modified-removed">-         move cfr, a0</span>
<span class="udiff-line-modified-removed">-         loadi Callee + PayloadOffset[cfr], t1</span>
<span class="udiff-line-modified-removed">-         checkStackPointerAlignment(t3, 0xdead0001)</span>
<span class="udiff-line-modified-removed">-         if C_LOOP or C_LOOP_WIN</span>
<span class="udiff-line-modified-removed">-             cloopCallNative offsetOfFunction[t1]</span>
<span class="udiff-line-modified-removed">-         else</span>
<span class="udiff-line-modified-removed">-             call offsetOfFunction[t1]</span>
<span class="udiff-line-removed">-         end</span>
<span class="udiff-line-removed">-         loadp Callee + PayloadOffset[cfr], t3</span>
<span class="udiff-line-removed">-         andp MarkedBlockMask, t3</span>
<span class="udiff-line-removed">-         loadp MarkedBlockFooterOffset + MarkedBlock::Footer::m_vm[t3], t3</span>
<span class="udiff-line-removed">-         addp 8, sp</span>
<span class="udiff-line-modified-added">+     end</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     loadp Callee + PayloadOffset[cfr], a2</span>
<span class="udiff-line-modified-added">+     loadp InternalFunction::m_globalObject[a2], a0</span>
<span class="udiff-line-modified-added">+     loadp JSGlobalObject::m_vm[a0], a1</span>
<span class="udiff-line-modified-added">+     storep cfr, VM::topCallFrame[a1]</span>
<span class="udiff-line-modified-added">+     move cfr, a1</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     checkStackPointerAlignment(t3, 0xdead0001)</span>
<span class="udiff-line-modified-added">+     if C_LOOP or C_LOOP_WIN</span>
<span class="udiff-line-modified-added">+         cloopCallNative offsetOfFunction[a2]</span>
      else
<span class="udiff-line-modified-removed">-         error</span>
<span class="udiff-line-modified-added">+         call offsetOfFunction[a2]</span>
      end
  
<span class="udiff-line-added">+     loadp Callee + PayloadOffset[cfr], t3</span>
<span class="udiff-line-added">+     loadp InternalFunction::m_globalObject[t3], t3</span>
<span class="udiff-line-added">+     loadp JSGlobalObject::m_vm[t3], t3</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     addp 8, sp</span>
<span class="udiff-line-added">+ </span>
      btpnz VM::m_exception[t3], .handleException
  
      functionEpilogue()
      ret
  
  .handleException:
<span class="udiff-line-modified-removed">- if X86 or X86_WIN</span>
<span class="udiff-line-modified-removed">-     subp 8, sp # align stack pointer</span>
<span class="udiff-line-modified-removed">- end</span>
<span class="udiff-line-modified-added">+     if X86 or X86_WIN</span>
<span class="udiff-line-modified-added">+         subp 8, sp # align stack pointer</span>
<span class="udiff-line-modified-added">+     end</span>
      storep cfr, VM::topCallFrame[t3]
      jmp _llint_throw_from_slow_path_trampoline
  end
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2513,11 +2557,11 @@</span>
      dispatch()
  end)
  
  
  llintOpWithReturn(op_get_rest_length, OpGetRestLength, macro (size, get, dispatch, return)
<span class="udiff-line-modified-removed">-     loadi PayloadOffset + ArgumentCount[cfr], t0</span>
<span class="udiff-line-modified-added">+     loadi PayloadOffset + ArgumentCountIncludingThis[cfr], t0</span>
      subi 1, t0
      getu(size, OpGetRestLength, m_numParametersToSkip, t1)
      bilteq t0, t1, .storeZero
      subi t1, t0
      jmp .finish
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2526,10 +2570,32 @@</span>
  .finish:
      return(Int32Tag, t0)
  end)
  
  
<span class="udiff-line-added">+ llintOpWithProfile(op_get_internal_field, OpGetInternalField, macro (size, get, dispatch, return)</span>
<span class="udiff-line-added">+     get(m_base, t0)</span>
<span class="udiff-line-added">+     loadi PayloadOffset[cfr, t0, 8], t0</span>
<span class="udiff-line-added">+     getu(size, OpGetInternalField, m_index, t1)</span>
<span class="udiff-line-added">+     loadi JSInternalFieldObjectImpl_internalFields + TagOffset[t0, t1, SlotSize], t2</span>
<span class="udiff-line-added">+     loadi JSInternalFieldObjectImpl_internalFields + PayloadOffset[t0, t1, SlotSize], t3</span>
<span class="udiff-line-added">+     return(t2, t3)</span>
<span class="udiff-line-added">+ end)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ llintOp(op_put_internal_field, OpPutInternalField, macro (size, get, dispatch)</span>
<span class="udiff-line-added">+     get(m_base, t0)</span>
<span class="udiff-line-added">+     loadi PayloadOffset[cfr, t0, 8], t0</span>
<span class="udiff-line-added">+     get(m_value, t1)</span>
<span class="udiff-line-added">+     loadConstantOrVariable(size, t1, t2, t3)</span>
<span class="udiff-line-added">+     getu(size, OpPutInternalField, m_index, t1)</span>
<span class="udiff-line-added">+     storei t2, JSInternalFieldObjectImpl_internalFields + TagOffset[t0, t1, SlotSize]</span>
<span class="udiff-line-added">+     storei t3, JSInternalFieldObjectImpl_internalFields + PayloadOffset[t0, t1, SlotSize]</span>
<span class="udiff-line-added">+     writeBarrierOnOperand(size, get, m_base)</span>
<span class="udiff-line-added">+     dispatch()</span>
<span class="udiff-line-added">+ end)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  llintOp(op_log_shadow_chicken_prologue, OpLogShadowChickenPrologue, macro (size, get, dispatch)
      acquireShadowChickenPacket(.opLogShadowChickenPrologueSlow)
      storep cfr, ShadowChicken::Packet::frame[t0]
      loadp CallerFrame[cfr], t1
      storep t1, ShadowChicken::Packet::callerFrame[t0]
</pre>
<center><a href="LowLevelInterpreter.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LowLevelInterpreter64.asm.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
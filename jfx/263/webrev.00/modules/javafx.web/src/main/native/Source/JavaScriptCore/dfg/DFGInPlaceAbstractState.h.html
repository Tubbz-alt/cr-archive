<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGInPlaceAbstractState.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(DFG_JIT)
 29 
 30 #include &quot;DFGAbstractInterpreterClobberState.h&quot;
 31 #include &quot;DFGAbstractValue.h&quot;
 32 #include &quot;DFGBranchDirection.h&quot;
 33 #include &quot;DFGFlowMap.h&quot;
 34 #include &quot;DFGGraph.h&quot;
 35 #include &quot;DFGNode.h&quot;
 36 
 37 namespace JSC { namespace DFG {
 38 
 39 class InPlaceAbstractState {
 40     WTF_MAKE_FAST_ALLOCATED;
 41 public:
 42     InPlaceAbstractState(Graph&amp;);
 43 
 44     ~InPlaceAbstractState();
 45 
 46     explicit operator bool() const { return true; }
 47 
 48     void createValueForNode(NodeFlowProjection) { }
 49 
 50     ALWAYS_INLINE AbstractValue&amp; fastForward(AbstractValue&amp; value)
 51     {
 52         value.fastForwardTo(m_effectEpoch);
 53         return value;
 54     }
 55 
 56     ALWAYS_INLINE void fastForwardAndFilterUnproven(AbstractValue&amp; value, SpeculatedType type)
 57     {
 58         value.fastForwardToAndFilterUnproven(m_effectEpoch, type);
 59     }
 60 
 61     ALWAYS_INLINE AbstractValue&amp; forNodeWithoutFastForward(NodeFlowProjection node)
 62     {
 63         return m_abstractValues.at(node);
 64     }
 65 
 66     ALWAYS_INLINE AbstractValue&amp; forNodeWithoutFastForward(Edge edge)
 67     {
 68         return forNodeWithoutFastForward(edge.node());
 69     }
 70 
 71     ALWAYS_INLINE AbstractValue&amp; forNode(NodeFlowProjection node)
 72     {
 73         return fastForward(m_abstractValues.at(node));
 74     }
 75 
 76     ALWAYS_INLINE AbstractValue&amp; forNode(Edge edge)
 77     {
 78         return forNode(edge.node());
 79     }
 80 
 81     ALWAYS_INLINE void clearForNode(NodeFlowProjection node)
 82     {
 83         AbstractValue&amp; value = m_abstractValues.at(node);
 84         value.clear();
 85         value.m_effectEpoch = m_effectEpoch;
 86     }
 87 
 88     ALWAYS_INLINE void clearForNode(Edge edge)
 89     {
 90         clearForNode(edge.node());
 91     }
 92 
 93     template&lt;typename... Arguments&gt;
 94     ALWAYS_INLINE void setForNode(NodeFlowProjection node, Arguments&amp;&amp;... arguments)
 95     {
 96         AbstractValue&amp; value = m_abstractValues.at(node);
 97         value.set(m_graph, std::forward&lt;Arguments&gt;(arguments)...);
 98         value.m_effectEpoch = m_effectEpoch;
 99     }
100 
101     template&lt;typename... Arguments&gt;
102     ALWAYS_INLINE void setForNode(Edge edge, Arguments&amp;&amp;... arguments)
103     {
104         setForNode(edge.node(), std::forward&lt;Arguments&gt;(arguments)...);
105     }
106 
107     template&lt;typename... Arguments&gt;
108     ALWAYS_INLINE void setTypeForNode(NodeFlowProjection node, Arguments&amp;&amp;... arguments)
109     {
110         AbstractValue&amp; value = m_abstractValues.at(node);
111         value.setType(m_graph, std::forward&lt;Arguments&gt;(arguments)...);
112         value.m_effectEpoch = m_effectEpoch;
113     }
114 
115     template&lt;typename... Arguments&gt;
116     ALWAYS_INLINE void setTypeForNode(Edge edge, Arguments&amp;&amp;... arguments)
117     {
118         setTypeForNode(edge.node(), std::forward&lt;Arguments&gt;(arguments)...);
119     }
120 
121     template&lt;typename... Arguments&gt;
122     ALWAYS_INLINE void setNonCellTypeForNode(NodeFlowProjection node, Arguments&amp;&amp;... arguments)
123     {
124         AbstractValue&amp; value = m_abstractValues.at(node);
125         value.setNonCellType(std::forward&lt;Arguments&gt;(arguments)...);
126         value.m_effectEpoch = m_effectEpoch;
127     }
128 
129     template&lt;typename... Arguments&gt;
130     ALWAYS_INLINE void setNonCellTypeForNode(Edge edge, Arguments&amp;&amp;... arguments)
131     {
132         setNonCellTypeForNode(edge.node(), std::forward&lt;Arguments&gt;(arguments)...);
133     }
134 
135     ALWAYS_INLINE void makeBytecodeTopForNode(NodeFlowProjection node)
136     {
137         AbstractValue&amp; value = m_abstractValues.at(node);
138         value.makeBytecodeTop();
139         value.m_effectEpoch = m_effectEpoch;
140     }
141 
142     ALWAYS_INLINE void makeBytecodeTopForNode(Edge edge)
143     {
144         makeBytecodeTopForNode(edge.node());
145     }
146 
147     ALWAYS_INLINE void makeHeapTopForNode(NodeFlowProjection node)
148     {
149         AbstractValue&amp; value = m_abstractValues.at(node);
150         value.makeHeapTop();
151         value.m_effectEpoch = m_effectEpoch;
152     }
153 
154     ALWAYS_INLINE void makeHeapTopForNode(Edge edge)
155     {
156         makeHeapTopForNode(edge.node());
157     }
158 
159     Operands&lt;AbstractValue&gt;&amp; variablesForDebugging();
160 
161     unsigned numberOfArguments() const { return m_variables.numberOfArguments(); }
162     unsigned numberOfLocals() const { return m_variables.numberOfLocals(); }
163 
164     AbstractValue&amp; variableAt(size_t index)
165     {
166         activateVariableIfNecessary(index);
167         return fastForward(m_variables[index]);
168     }
169 
170     AbstractValue&amp; operand(Operand operand)
171     {
172         return variableAt(m_variables.operandIndex(operand));
173     }
174 
175     AbstractValue&amp; local(size_t index)
176     {
177         return variableAt(m_variables.localIndex(index));
178     }
179 
180     AbstractValue&amp; argument(size_t index)
181     {
182         return variableAt(m_variables.argumentIndex(index));
183     }
184 
185     // Call this before beginning CFA to initialize the abstract values of
186     // arguments, and to indicate which blocks should be listed for CFA
187     // execution.
188     void initialize();
189 
190     // Start abstractly executing the given basic block. Initializes the
191     // notion of abstract state to what we believe it to be at the head
192     // of the basic block, according to the basic block&#39;s data structures.
193     // This method also sets cfaShouldRevisit to false.
194     void beginBasicBlock(BasicBlock*);
195 
196     BasicBlock* block() const { return m_block; }
197 
198     // Finish abstractly executing a basic block. If MergeToTail or
199     // MergeToSuccessors is passed, then this merges everything we have
200     // learned about how the state changes during this block&#39;s execution into
201     // the block&#39;s data structures.
202     //
203     // Returns true if the state of the block at the tail was changed,
204     // and, if the state at the heads of successors was changed.
205     // A true return means that you must revisit (at least) the successor
206     // blocks. This also sets cfaShouldRevisit to true for basic blocks
207     // that must be visited next.
208     bool endBasicBlock();
209 
210     // Reset the AbstractState. This throws away any results, and at this point
211     // you can safely call beginBasicBlock() on any basic block.
212     void reset();
213 
214     AbstractInterpreterClobberState clobberState() const { return m_clobberState; }
215 
216     // Would have the last executed node clobbered things had we not found a way to fold it?
217     bool didClobberOrFolded() const { return clobberState() != AbstractInterpreterClobberState::NotClobbered; }
218 
219     // Did the last executed node clobber the world?
220     bool didClobber() const { return clobberState() == AbstractInterpreterClobberState::ClobberedStructures; }
221 
222     // Are structures currently clobbered?
223     StructureClobberState structureClobberState() const { return m_structureClobberState; }
224 
225     // Is the execution state still valid? This will be false if execute() has
226     // returned false previously.
227     bool isValid() const { return m_isValid; }
228 
229     // Merge the abstract state stored at the first block&#39;s tail into the second
230     // block&#39;s head. Returns true if the second block&#39;s state changed. If so,
231     // that block must be abstractly interpreted again. This also sets
232     // to-&gt;cfaShouldRevisit to true, if it returns true, or if to has not been
233     // visited yet.
234     bool merge(BasicBlock* from, BasicBlock* to);
235 
236     // Merge the abstract state stored at the block&#39;s tail into all of its
237     // successors. Returns true if any of the successors&#39; states changed. Note
238     // that this is automatically called in endBasicBlock() if MergeMode is
239     // MergeToSuccessors.
240     bool mergeToSuccessors(BasicBlock*);
241 
242     void clobberStructures() { m_effectEpoch.clobber(); }
243 
244     void observeInvalidationPoint() { m_effectEpoch.observeInvalidationPoint(); }
245 
246     // Methods intended to be called from AbstractInterpreter.
247     void setClobberState(AbstractInterpreterClobberState state) { m_clobberState = state; }
248     void mergeClobberState(AbstractInterpreterClobberState state) { m_clobberState = mergeClobberStates(m_clobberState, state); }
249     void setStructureClobberState(StructureClobberState value) { m_structureClobberState = value; }
250     void setIsValid(bool isValid) { m_isValid = isValid; }
251     void setBranchDirection(BranchDirection branchDirection) { m_branchDirection = branchDirection; }
252 
253     // This method is evil - it causes a huge maintenance headache and there is a gross amount of
254     // code devoted to it. It would be much nicer to just always run the constant folder on each
255     // block. But, the last time we did it, it was a 1% SunSpider regression:
256     // https://bugs.webkit.org/show_bug.cgi?id=133947
257     // So, we should probably keep this method.
258     void setShouldTryConstantFolding(bool tryConstantFolding) { m_shouldTryConstantFolding = tryConstantFolding; }
259 
260     void setProofStatus(Edge&amp; edge, ProofStatus status)
261     {
262         edge.setProofStatus(status);
263     }
264 
265 private:
266     ALWAYS_INLINE void activateVariableIfNecessary(size_t variableIndex)
267     {
268         if (!m_activeVariables[variableIndex])
269             activateVariable(variableIndex);
270     }
271 
272     void activateVariable(size_t variableIndex);
273     void activateAllVariables();
274 
275     static bool mergeVariableBetweenBlocks(AbstractValue&amp; destination, AbstractValue&amp; source, Node* destinationNode, Node* sourceNode);
276 
277     Graph&amp; m_graph;
278 
279     FlowMap&lt;AbstractValue&gt;&amp; m_abstractValues;
280     Operands&lt;AbstractValue&gt; m_variables;
281     FastBitVector m_activeVariables;
282     BasicBlock* m_block;
283 
284     bool m_shouldTryConstantFolding;
285 
286     bool m_isValid;
287     AbstractInterpreterClobberState m_clobberState;
288     StructureClobberState m_structureClobberState;
289     AbstractValueClobberEpoch m_epochAtHead;
290     AbstractValueClobberEpoch m_effectEpoch;
291 
292     BranchDirection m_branchDirection; // This is only set for blocks that end in Branch and that execute to completion (i.e. m_isValid == true).
293 };
294 
295 } } // namespace JSC::DFG
296 
297 #endif // ENABLE(DFG_JIT)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptModuleLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScriptController.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScriptModuleLoader.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptModuleLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,21 ***</span>
  #include &quot;CachedScript.h&quot;
  #include &quot;CachedScriptFetcher.h&quot;
  #include &quot;Document.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;JSDOMBinding.h&quot;
  #include &quot;LoadableModuleScript.h&quot;
  #include &quot;MIMETypeRegistry.h&quot;
  #include &quot;ModuleFetchFailureKind.h&quot;
  #include &quot;ModuleFetchParameters.h&quot;
  #include &quot;ScriptController.h&quot;
  #include &quot;ScriptSourceCode.h&quot;
  #include &quot;SubresourceIntegrity.h&quot;
  #include &quot;WebCoreJSClientData.h&quot;
  #include &lt;JavaScriptCore/Completion.h&gt;
  #include &lt;JavaScriptCore/JSInternalPromise.h&gt;
<span class="line-removed">- #include &lt;JavaScriptCore/JSInternalPromiseDeferred.h&gt;</span>
  #include &lt;JavaScriptCore/JSModuleRecord.h&gt;
  #include &lt;JavaScriptCore/JSScriptFetchParameters.h&gt;
  #include &lt;JavaScriptCore/JSScriptFetcher.h&gt;
  #include &lt;JavaScriptCore/JSSourceCode.h&gt;
  #include &lt;JavaScriptCore/JSString.h&gt;
<span class="line-new-header">--- 30,21 ---</span>
  #include &quot;CachedScript.h&quot;
  #include &quot;CachedScriptFetcher.h&quot;
  #include &quot;Document.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;JSDOMBinding.h&quot;
<span class="line-added">+ #include &quot;JSDOMPromiseDeferred.h&quot;</span>
  #include &quot;LoadableModuleScript.h&quot;
  #include &quot;MIMETypeRegistry.h&quot;
  #include &quot;ModuleFetchFailureKind.h&quot;
  #include &quot;ModuleFetchParameters.h&quot;
  #include &quot;ScriptController.h&quot;
  #include &quot;ScriptSourceCode.h&quot;
  #include &quot;SubresourceIntegrity.h&quot;
  #include &quot;WebCoreJSClientData.h&quot;
  #include &lt;JavaScriptCore/Completion.h&gt;
  #include &lt;JavaScriptCore/JSInternalPromise.h&gt;
  #include &lt;JavaScriptCore/JSModuleRecord.h&gt;
  #include &lt;JavaScriptCore/JSScriptFetchParameters.h&gt;
  #include &lt;JavaScriptCore/JSScriptFetcher.h&gt;
  #include &lt;JavaScriptCore/JSSourceCode.h&gt;
  #include &lt;JavaScriptCore/JSString.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 83,90 ***</span>
      if (!result.isValid())
          return makeUnexpected(&quot;Module name does not resolve to a valid URL.&quot;_s);
      return result;
  }
  
<span class="line-modified">! JSC::Identifier ScriptModuleLoader::resolve(JSC::JSGlobalObject*, JSC::ExecState* exec, JSC::JSModuleLoader*, JSC::JSValue moduleNameValue, JSC::JSValue importerModuleKey, JSC::JSValue)</span>
  {
<span class="line-modified">!     JSC::VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // We use a Symbol as a special purpose; It means this module is an inline module.
      // So there is no correct URL to retrieve the module source code. If the module name
      // value is a Symbol, it is used directly as a module key.
      if (moduleNameValue.isSymbol())
          return JSC::Identifier::fromUid(asSymbol(moduleNameValue)-&gt;privateName());
  
      if (!moduleNameValue.isString()) {
<span class="line-modified">!         JSC::throwTypeError(exec, scope, &quot;Importer module key is not a Symbol or a String.&quot;_s);</span>
          return { };
      }
  
<span class="line-modified">!     String specifier = asString(moduleNameValue)-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      URL baseURL;
      if (isRootModule(importerModuleKey))
          baseURL = m_document.baseURL();
      else {
          ASSERT(importerModuleKey.isString());
<span class="line-modified">!         URL importerModuleRequestURL(URL(), asString(importerModuleKey)-&gt;value(exec));</span>
          ASSERT_WITH_MESSAGE(importerModuleRequestURL.isValid(), &quot;Invalid module referrer never starts importing dependent modules.&quot;);
  
          auto iterator = m_requestURLToResponseURLMap.find(importerModuleRequestURL);
          ASSERT_WITH_MESSAGE(iterator != m_requestURLToResponseURLMap.end(), &quot;Module referrer must register itself to the map before starting importing dependent modules.&quot;);
          baseURL = iterator-&gt;value;
      }
  
      auto result = resolveModuleSpecifier(m_document, specifier, baseURL);
      if (!result) {
<span class="line-modified">!         JSC::throwTypeError(exec, scope, result.error());</span>
          return { };
      }
  
      return JSC::Identifier::fromString(vm, result-&gt;string());
  }
  
  static void rejectToPropagateNetworkError(DeferredPromise&amp; deferred, ModuleFetchFailureKind failureKind, ASCIILiteral message)
  {
<span class="line-modified">!     deferred.rejectWithCallback([&amp;] (JSC::ExecState&amp; state, JSDOMGlobalObject&amp;) {</span>
          // We annotate exception with special private symbol. It allows us to distinguish these errors from the user thrown ones.
<span class="line-modified">!         JSC::VM&amp; vm = state.vm();</span>
          // FIXME: Propagate more descriptive error.
          // https://bugs.webkit.org/show_bug.cgi?id=167553
<span class="line-modified">!         auto* error = JSC::createTypeError(&amp;state, message);</span>
          ASSERT(error);
          error-&gt;putDirect(vm, static_cast&lt;JSVMClientData&amp;&gt;(*vm.clientData).builtinNames().failureKindPrivateName(), JSC::jsNumber(static_cast&lt;int32_t&gt;(failureKind)));
          return error;
      });
  }
  
<span class="line-modified">! JSC::JSInternalPromise* ScriptModuleLoader::fetch(JSC::JSGlobalObject* jsGlobalObject, JSC::ExecState* exec, JSC::JSModuleLoader*, JSC::JSValue moduleKeyValue, JSC::JSValue parameters, JSC::JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     JSC::VM&amp; vm = exec-&gt;vm();</span>
      ASSERT(JSC::jsDynamicCast&lt;JSC::JSScriptFetcher*&gt;(vm, scriptFetcher));
  
      auto&amp; globalObject = *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(jsGlobalObject);
<span class="line-modified">!     auto* jsPromise = JSC::JSInternalPromiseDeferred::tryCreate(exec, &amp;globalObject);</span>
      RELEASE_ASSERT(jsPromise);
      auto deferred = DeferredPromise::create(globalObject, *jsPromise);
      if (moduleKeyValue.isSymbol()) {
          deferred-&gt;reject(TypeError, &quot;Symbol module key should be already fulfilled with the inlined resource.&quot;_s);
<span class="line-modified">!         return jsPromise-&gt;promise();</span>
      }
  
      if (!moduleKeyValue.isString()) {
          deferred-&gt;reject(TypeError, &quot;Module key is not Symbol or String.&quot;_s);
<span class="line-modified">!         return jsPromise-&gt;promise();</span>
      }
  
      // https://html.spec.whatwg.org/multipage/webappapis.html#fetch-a-single-module-script
  
<span class="line-modified">!     URL completedURL(URL(), asString(moduleKeyValue)-&gt;value(exec));</span>
      if (!completedURL.isValid()) {
          deferred-&gt;reject(TypeError, &quot;Module key is a valid URL.&quot;_s);
<span class="line-modified">!         return jsPromise-&gt;promise();</span>
      }
  
      RefPtr&lt;ModuleFetchParameters&gt; topLevelFetchParameters;
      if (auto* scriptFetchParameters = JSC::jsDynamicCast&lt;JSC::JSScriptFetchParameters*&gt;(vm, parameters))
          topLevelFetchParameters = static_cast&lt;ModuleFetchParameters*&gt;(&amp;scriptFetchParameters-&gt;parameters());
<span class="line-new-header">--- 83,90 ---</span>
      if (!result.isValid())
          return makeUnexpected(&quot;Module name does not resolve to a valid URL.&quot;_s);
      return result;
  }
  
<span class="line-modified">! JSC::Identifier ScriptModuleLoader::resolve(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSValue moduleNameValue, JSC::JSValue importerModuleKey, JSC::JSValue)</span>
  {
<span class="line-modified">!     JSC::VM&amp; vm = jsGlobalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // We use a Symbol as a special purpose; It means this module is an inline module.
      // So there is no correct URL to retrieve the module source code. If the module name
      // value is a Symbol, it is used directly as a module key.
      if (moduleNameValue.isSymbol())
          return JSC::Identifier::fromUid(asSymbol(moduleNameValue)-&gt;privateName());
  
      if (!moduleNameValue.isString()) {
<span class="line-modified">!         JSC::throwTypeError(jsGlobalObject, scope, &quot;Importer module key is not a Symbol or a String.&quot;_s);</span>
          return { };
      }
  
<span class="line-modified">!     String specifier = asString(moduleNameValue)-&gt;value(jsGlobalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      URL baseURL;
      if (isRootModule(importerModuleKey))
          baseURL = m_document.baseURL();
      else {
          ASSERT(importerModuleKey.isString());
<span class="line-modified">!         URL importerModuleRequestURL(URL(), asString(importerModuleKey)-&gt;value(jsGlobalObject));</span>
          ASSERT_WITH_MESSAGE(importerModuleRequestURL.isValid(), &quot;Invalid module referrer never starts importing dependent modules.&quot;);
  
          auto iterator = m_requestURLToResponseURLMap.find(importerModuleRequestURL);
          ASSERT_WITH_MESSAGE(iterator != m_requestURLToResponseURLMap.end(), &quot;Module referrer must register itself to the map before starting importing dependent modules.&quot;);
          baseURL = iterator-&gt;value;
      }
  
      auto result = resolveModuleSpecifier(m_document, specifier, baseURL);
      if (!result) {
<span class="line-modified">!         JSC::throwTypeError(jsGlobalObject, scope, result.error());</span>
          return { };
      }
  
      return JSC::Identifier::fromString(vm, result-&gt;string());
  }
  
  static void rejectToPropagateNetworkError(DeferredPromise&amp; deferred, ModuleFetchFailureKind failureKind, ASCIILiteral message)
  {
<span class="line-modified">!     deferred.rejectWithCallback([&amp;] (JSDOMGlobalObject&amp; jsGlobalObject) {</span>
          // We annotate exception with special private symbol. It allows us to distinguish these errors from the user thrown ones.
<span class="line-modified">!         JSC::VM&amp; vm = jsGlobalObject.vm();</span>
          // FIXME: Propagate more descriptive error.
          // https://bugs.webkit.org/show_bug.cgi?id=167553
<span class="line-modified">!         auto* error = JSC::createTypeError(&amp;jsGlobalObject, message);</span>
          ASSERT(error);
          error-&gt;putDirect(vm, static_cast&lt;JSVMClientData&amp;&gt;(*vm.clientData).builtinNames().failureKindPrivateName(), JSC::jsNumber(static_cast&lt;int32_t&gt;(failureKind)));
          return error;
      });
  }
  
<span class="line-modified">! JSC::JSInternalPromise* ScriptModuleLoader::fetch(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSValue moduleKeyValue, JSC::JSValue parameters, JSC::JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     JSC::VM&amp; vm = jsGlobalObject-&gt;vm();</span>
      ASSERT(JSC::jsDynamicCast&lt;JSC::JSScriptFetcher*&gt;(vm, scriptFetcher));
  
      auto&amp; globalObject = *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(jsGlobalObject);
<span class="line-modified">!     auto* jsPromise = JSC::JSInternalPromise::create(vm, globalObject.internalPromiseStructure());</span>
      RELEASE_ASSERT(jsPromise);
      auto deferred = DeferredPromise::create(globalObject, *jsPromise);
      if (moduleKeyValue.isSymbol()) {
          deferred-&gt;reject(TypeError, &quot;Symbol module key should be already fulfilled with the inlined resource.&quot;_s);
<span class="line-modified">!         return jsPromise;</span>
      }
  
      if (!moduleKeyValue.isString()) {
          deferred-&gt;reject(TypeError, &quot;Module key is not Symbol or String.&quot;_s);
<span class="line-modified">!         return jsPromise;</span>
      }
  
      // https://html.spec.whatwg.org/multipage/webappapis.html#fetch-a-single-module-script
  
<span class="line-modified">!     URL completedURL(URL(), asString(moduleKeyValue)-&gt;value(jsGlobalObject));</span>
      if (!completedURL.isValid()) {
          deferred-&gt;reject(TypeError, &quot;Module key is a valid URL.&quot;_s);
<span class="line-modified">!         return jsPromise;</span>
      }
  
      RefPtr&lt;ModuleFetchParameters&gt; topLevelFetchParameters;
      if (auto* scriptFetchParameters = JSC::jsDynamicCast&lt;JSC::JSScriptFetchParameters*&gt;(vm, parameters))
          topLevelFetchParameters = static_cast&lt;ModuleFetchParameters*&gt;(&amp;scriptFetchParameters-&gt;parameters());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 175,59 ***</span>
      m_loaders.add(loader.copyRef());
      if (!loader-&gt;load(m_document, completedURL)) {
          loader-&gt;clearClient();
          m_loaders.remove(WTFMove(loader));
          rejectToPropagateNetworkError(deferred.get(), ModuleFetchFailureKind::WasErrored, &quot;Importing a module script failed.&quot;_s);
<span class="line-modified">!         return jsPromise-&gt;promise();</span>
      }
  
<span class="line-modified">!     return jsPromise-&gt;promise();</span>
  }
  
<span class="line-modified">! URL ScriptModuleLoader::moduleURL(JSC::ExecState&amp; state, JSC::JSValue moduleKeyValue)</span>
  {
      if (moduleKeyValue.isSymbol())
          return m_document.url();
  
      ASSERT(moduleKeyValue.isString());
<span class="line-modified">!     return URL(URL(), asString(moduleKeyValue)-&gt;value(&amp;state));</span>
  }
  
<span class="line-modified">! JSC::JSValue ScriptModuleLoader::evaluate(JSC::JSGlobalObject*, JSC::ExecState* exec, JSC::JSModuleLoader*, JSC::JSValue moduleKeyValue, JSC::JSValue moduleRecordValue, JSC::JSValue)</span>
  {
<span class="line-modified">!     JSC::VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // FIXME: Currently, we only support JSModuleRecord.
      // Once the reflective part of the module loader is supported, we will handle arbitrary values.
      // https://whatwg.github.io/loader/#registry-prototype-provide
      auto* moduleRecord = JSC::jsDynamicCast&lt;JSC::JSModuleRecord*&gt;(vm, moduleRecordValue);
      if (!moduleRecord)
          return JSC::jsUndefined();
  
<span class="line-modified">!     URL sourceURL = moduleURL(*exec, moduleKeyValue);</span>
      if (!sourceURL.isValid())
<span class="line-modified">!         return JSC::throwTypeError(exec, scope, &quot;Module key is an invalid URL.&quot;_s);</span>
  
      if (auto* frame = m_document.frame())
          return frame-&gt;script().evaluateModule(sourceURL, *moduleRecord);
      return JSC::jsUndefined();
  }
  
<span class="line-modified">! static JSC::JSInternalPromise* rejectPromise(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, ExceptionCode ec, ASCIILiteral message)</span>
  {
<span class="line-modified">!     auto* jsPromise = JSC::JSInternalPromiseDeferred::tryCreate(&amp;state, &amp;globalObject);</span>
      RELEASE_ASSERT(jsPromise);
      auto deferred = DeferredPromise::create(globalObject, *jsPromise);
      deferred-&gt;reject(ec, WTFMove(message));
<span class="line-modified">!     return jsPromise-&gt;promise();</span>
  }
  
<span class="line-modified">! JSC::JSInternalPromise* ScriptModuleLoader::importModule(JSC::JSGlobalObject* jsGlobalObject, JSC::ExecState* exec, JSC::JSModuleLoader*, JSC::JSString* moduleName, JSC::JSValue parameters, const JSC::SourceOrigin&amp; sourceOrigin)</span>
  {
<span class="line-modified">!     auto&amp; state = *exec;</span>
<span class="line-removed">-     JSC::VM&amp; vm = exec-&gt;vm();</span>
      auto&amp; globalObject = *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(jsGlobalObject);
  
      // If SourceOrigin and/or CachedScriptFetcher is null, we import the module with the default fetcher.
      // SourceOrigin can be null if the source code is not coupled with the script file.
      // The examples,
<span class="line-new-header">--- 175,58 ---</span>
      m_loaders.add(loader.copyRef());
      if (!loader-&gt;load(m_document, completedURL)) {
          loader-&gt;clearClient();
          m_loaders.remove(WTFMove(loader));
          rejectToPropagateNetworkError(deferred.get(), ModuleFetchFailureKind::WasErrored, &quot;Importing a module script failed.&quot;_s);
<span class="line-modified">!         return jsPromise;</span>
      }
  
<span class="line-modified">!     return jsPromise;</span>
  }
  
<span class="line-modified">! URL ScriptModuleLoader::moduleURL(JSC::JSGlobalObject&amp; jsGlobalObject, JSC::JSValue moduleKeyValue)</span>
  {
      if (moduleKeyValue.isSymbol())
          return m_document.url();
  
      ASSERT(moduleKeyValue.isString());
<span class="line-modified">!     return URL(URL(), asString(moduleKeyValue)-&gt;value(&amp;jsGlobalObject));</span>
  }
  
<span class="line-modified">! JSC::JSValue ScriptModuleLoader::evaluate(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSValue moduleKeyValue, JSC::JSValue moduleRecordValue, JSC::JSValue)</span>
  {
<span class="line-modified">!     JSC::VM&amp; vm = jsGlobalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // FIXME: Currently, we only support JSModuleRecord.
      // Once the reflective part of the module loader is supported, we will handle arbitrary values.
      // https://whatwg.github.io/loader/#registry-prototype-provide
      auto* moduleRecord = JSC::jsDynamicCast&lt;JSC::JSModuleRecord*&gt;(vm, moduleRecordValue);
      if (!moduleRecord)
          return JSC::jsUndefined();
  
<span class="line-modified">!     URL sourceURL = moduleURL(*jsGlobalObject, moduleKeyValue);</span>
      if (!sourceURL.isValid())
<span class="line-modified">!         return JSC::throwTypeError(jsGlobalObject, scope, &quot;Module key is an invalid URL.&quot;_s);</span>
  
      if (auto* frame = m_document.frame())
          return frame-&gt;script().evaluateModule(sourceURL, *moduleRecord);
      return JSC::jsUndefined();
  }
  
<span class="line-modified">! static JSC::JSInternalPromise* rejectPromise(JSDOMGlobalObject&amp; globalObject, ExceptionCode ec, ASCIILiteral message)</span>
  {
<span class="line-modified">!     auto* jsPromise = JSC::JSInternalPromise::create(globalObject.vm(), globalObject.internalPromiseStructure());</span>
      RELEASE_ASSERT(jsPromise);
      auto deferred = DeferredPromise::create(globalObject, *jsPromise);
      deferred-&gt;reject(ec, WTFMove(message));
<span class="line-modified">!     return jsPromise;</span>
  }
  
<span class="line-modified">! JSC::JSInternalPromise* ScriptModuleLoader::importModule(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSString* moduleName, JSC::JSValue parameters, const JSC::SourceOrigin&amp; sourceOrigin)</span>
  {
<span class="line-modified">!     JSC::VM&amp; vm = jsGlobalObject-&gt;vm();</span>
      auto&amp; globalObject = *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(jsGlobalObject);
  
      // If SourceOrigin and/or CachedScriptFetcher is null, we import the module with the default fetcher.
      // SourceOrigin can be null if the source code is not coupled with the script file.
      // The examples,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 241,37 ***</span>
          baseURL = m_document.baseURL();
          scriptFetcher = CachedScriptFetcher::create(m_document.charset());
      } else {
          baseURL = URL(URL(), sourceOrigin.string());
          if (!baseURL.isValid())
<span class="line-modified">!             return rejectPromise(state, globalObject, TypeError, &quot;Importer module key is not a Symbol or a String.&quot;_s);</span>
  
          if (sourceOrigin.fetcher())
              scriptFetcher = sourceOrigin.fetcher();
          else
              scriptFetcher = CachedScriptFetcher::create(m_document.charset());
      }
      ASSERT(baseURL.isValid());
      ASSERT(scriptFetcher);
  
<span class="line-modified">!     auto specifier = moduleName-&gt;value(exec);</span>
      auto result = resolveModuleSpecifier(m_document, specifier, baseURL);
      if (!result)
<span class="line-modified">!         return rejectPromise(state, globalObject, TypeError, result.error());</span>
  
<span class="line-modified">!     return JSC::importModule(exec, JSC::Identifier::fromString(vm, result-&gt;string()), parameters, JSC::JSScriptFetcher::create(vm, WTFMove(scriptFetcher) ));</span>
  }
  
<span class="line-modified">! JSC::JSObject* ScriptModuleLoader::createImportMetaProperties(JSC::JSGlobalObject* globalObject, JSC::ExecState* exec, JSC::JSModuleLoader*, JSC::JSValue moduleKeyValue, JSC::JSModuleRecord*, JSC::JSValue)</span>
  {
<span class="line-modified">!     auto&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     URL sourceURL = moduleURL(*exec, moduleKeyValue);</span>
      ASSERT(sourceURL.isValid());
  
<span class="line-modified">!     auto* metaProperties = JSC::constructEmptyObject(exec, globalObject-&gt;nullPrototypeObjectStructure());</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      metaProperties-&gt;putDirect(vm, JSC::Identifier::fromString(vm, &quot;url&quot;), JSC::jsString(vm, sourceURL.string()));
      RETURN_IF_EXCEPTION(scope, nullptr);
  
<span class="line-new-header">--- 240,37 ---</span>
          baseURL = m_document.baseURL();
          scriptFetcher = CachedScriptFetcher::create(m_document.charset());
      } else {
          baseURL = URL(URL(), sourceOrigin.string());
          if (!baseURL.isValid())
<span class="line-modified">!             return rejectPromise(globalObject, TypeError, &quot;Importer module key is not a Symbol or a String.&quot;_s);</span>
  
          if (sourceOrigin.fetcher())
              scriptFetcher = sourceOrigin.fetcher();
          else
              scriptFetcher = CachedScriptFetcher::create(m_document.charset());
      }
      ASSERT(baseURL.isValid());
      ASSERT(scriptFetcher);
  
<span class="line-modified">!     auto specifier = moduleName-&gt;value(jsGlobalObject);</span>
      auto result = resolveModuleSpecifier(m_document, specifier, baseURL);
      if (!result)
<span class="line-modified">!         return rejectPromise(globalObject, TypeError, result.error());</span>
  
<span class="line-modified">!     return JSC::importModule(jsGlobalObject, JSC::Identifier::fromString(vm, result-&gt;string()), parameters, JSC::JSScriptFetcher::create(vm, WTFMove(scriptFetcher) ));</span>
  }
  
<span class="line-modified">! JSC::JSObject* ScriptModuleLoader::createImportMetaProperties(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSValue moduleKeyValue, JSC::JSModuleRecord*, JSC::JSValue)</span>
  {
<span class="line-modified">!     auto&amp; vm = jsGlobalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     URL sourceURL = moduleURL(*jsGlobalObject, moduleKeyValue);</span>
      ASSERT(sourceURL.isValid());
  
<span class="line-modified">!     auto* metaProperties = JSC::constructEmptyObject(vm, jsGlobalObject-&gt;nullPrototypeObjectStructure());</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      metaProperties-&gt;putDirect(vm, JSC::Identifier::fromString(vm, &quot;url&quot;), JSC::jsString(vm, sourceURL.string()));
      RETURN_IF_EXCEPTION(scope, nullptr);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 280,10 ***</span>
<span class="line-new-header">--- 279,11 ---</span>
  
  void ScriptModuleLoader::notifyFinished(CachedModuleScriptLoader&amp; loader, RefPtr&lt;DeferredPromise&gt; promise)
  {
      // https://html.spec.whatwg.org/multipage/webappapis.html#fetch-a-single-module-script
  
<span class="line-added">+     URL sourceURL = loader.sourceURL();</span>
      if (!m_loaders.remove(&amp;loader))
          return;
      loader.clearClient();
  
      auto&amp; cachedScript = *loader.cachedScript();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 311,18 ***</span>
          return;
      }
  
      if (auto* parameters = loader.parameters()) {
          if (!matchIntegrityMetadata(cachedScript, parameters-&gt;integrity())) {
<span class="line-modified">!             promise-&gt;reject(TypeError, makeString(&quot;Cannot load script &quot;, cachedScript.url().stringCenterEllipsizedToLength(), &quot;. Failed integrity metadata check.&quot;));</span>
              return;
          }
      }
  
<span class="line-modified">!     m_requestURLToResponseURLMap.add(cachedScript.url(), cachedScript.response().url());</span>
<span class="line-modified">!     promise-&gt;resolveWithCallback([&amp;] (JSC::ExecState&amp; state, JSDOMGlobalObject&amp;) {</span>
<span class="line-modified">!         return JSC::JSSourceCode::create(state.vm(),</span>
              JSC::SourceCode { ScriptSourceCode { &amp;cachedScript, JSC::SourceProviderSourceType::Module, loader.scriptFetcher() }.jsSourceCode() });
      });
  }
  
  }
<span class="line-new-header">--- 311,18 ---</span>
          return;
      }
  
      if (auto* parameters = loader.parameters()) {
          if (!matchIntegrityMetadata(cachedScript, parameters-&gt;integrity())) {
<span class="line-modified">!             promise-&gt;reject(TypeError, makeString(&quot;Cannot load script &quot;, integrityMismatchDescription(cachedScript, parameters-&gt;integrity())));</span>
              return;
          }
      }
  
<span class="line-modified">!     m_requestURLToResponseURLMap.add(WTFMove(sourceURL), cachedScript.response().url());</span>
<span class="line-modified">!     promise-&gt;resolveWithCallback([&amp;] (JSDOMGlobalObject&amp; jsGlobalObject) {</span>
<span class="line-modified">!         return JSC::JSSourceCode::create(jsGlobalObject.vm(),</span>
              JSC::SourceCode { ScriptSourceCode { &amp;cachedScript, JSC::SourceProviderSourceType::Module, loader.scriptFetcher() }.jsSourceCode() });
      });
  }
  
  }
</pre>
<center><a href="ScriptController.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScriptModuleLoader.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
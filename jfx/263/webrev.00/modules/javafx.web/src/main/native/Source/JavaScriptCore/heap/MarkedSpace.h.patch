diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkedSpace.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkedSpace.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkedSpace.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkedSpace.h
@@ -21,13 +21,13 @@
 
 #pragma once
 
 #include "BlockDirectory.h"
 #include "IterationStatus.h"
-#include "LargeAllocation.h"
 #include "MarkedBlock.h"
 #include "MarkedBlockSet.h"
+#include "PreciseAllocation.h"
 #include <array>
 #include <wtf/Bag.h>
 #include <wtf/HashSet.h>
 #include <wtf/Noncopyable.h>
 #include <wtf/RetainPtr.h>
@@ -37,11 +37,13 @@
 
 namespace JSC {
 
 class CompleteSubspace;
 class Heap;
+class HeapCell;
 class HeapIterationScope;
+class IsoSubspace;
 class LLIntOffsetsExtractor;
 class Subspace;
 class WeakSet;
 
 typedef uint32_t HeapVersion;
@@ -91,11 +93,11 @@
     }
 
     MarkedSpace(Heap*);
     ~MarkedSpace();
 
-    Heap* heap() const { return m_heap; }
+    Heap& heap() const;
 
     void lastChanceToFinalize(); // Must call stopAllocatingForGood first.
     void freeMemory();
 
     static size_t optimalSizeFor(size_t);
@@ -136,31 +138,34 @@
 
     void beginMarking();
     void endMarking();
     void snapshotUnswept();
     void clearNewlyAllocated();
-    void sweep();
-    void sweepLargeAllocations();
+    void sweepBlocks();
+    void sweepPreciseAllocations();
     void assertNoUnswept();
     size_t objectCount();
     size_t size();
     size_t capacity();
 
     bool isPagedOut(MonotonicTime deadline);
 
     HeapVersion markingVersion() const { return m_markingVersion; }
     HeapVersion newlyAllocatedVersion() const { return m_newlyAllocatedVersion; }
 
-    const Vector<LargeAllocation*>& largeAllocations() const { return m_largeAllocations; }
-    unsigned largeAllocationsNurseryOffset() const { return m_largeAllocationsNurseryOffset; }
-    unsigned largeAllocationsOffsetForThisCollection() const { return m_largeAllocationsOffsetForThisCollection; }
+    const Vector<PreciseAllocation*>& preciseAllocations() const { return m_preciseAllocations; }
+    unsigned preciseAllocationsNurseryOffset() const { return m_preciseAllocationsNurseryOffset; }
+    unsigned preciseAllocationsOffsetForThisCollection() const { return m_preciseAllocationsOffsetForThisCollection; }
+    HashSet<HeapCell*>* preciseAllocationSet() const { return m_preciseAllocationSet.get(); }
+
+    void enablePreciseAllocationTracking();
 
     // These are cached pointers and offsets for quickly searching the large allocations that are
     // relevant to this collection.
-    LargeAllocation** largeAllocationsForThisCollectionBegin() const { return m_largeAllocationsForThisCollectionBegin; }
-    LargeAllocation** largeAllocationsForThisCollectionEnd() const { return m_largeAllocationsForThisCollectionEnd; }
-    unsigned largeAllocationsForThisCollectionSize() const { return m_largeAllocationsForThisCollectionSize; }
+    PreciseAllocation** preciseAllocationsForThisCollectionBegin() const { return m_preciseAllocationsForThisCollectionBegin; }
+    PreciseAllocation** preciseAllocationsForThisCollectionEnd() const { return m_preciseAllocationsForThisCollectionEnd; }
+    unsigned preciseAllocationsForThisCollectionSize() const { return m_preciseAllocationsForThisCollectionSize; }
 
     BlockDirectory* firstDirectory() const { return m_directories.first(); }
 
     Lock& directoryLock() { return m_directoryLock; }
     void addBlockDirectory(const AbstractLocker&, BlockDirectory*);
@@ -181,10 +186,11 @@
     friend class CompleteSubspace;
     friend class LLIntOffsetsExtractor;
     friend class JIT;
     friend class WeakSet;
     friend class Subspace;
+    friend class IsoSubspace;
 
     // Use this version when calling from within the GC where we know that the directories
     // have already been stopped.
     template<typename Functor> void forEachLiveCell(const Functor&);
 
@@ -196,19 +202,19 @@
 
     void addActiveWeakSet(WeakSet*);
 
     Vector<Subspace*> m_subspaces;
 
-    Vector<LargeAllocation*> m_largeAllocations;
-    unsigned m_largeAllocationsNurseryOffset { 0 };
-    unsigned m_largeAllocationsOffsetForThisCollection { 0 };
-    unsigned m_largeAllocationsNurseryOffsetForSweep { 0 };
-    unsigned m_largeAllocationsForThisCollectionSize { 0 };
-    LargeAllocation** m_largeAllocationsForThisCollectionBegin { nullptr };
-    LargeAllocation** m_largeAllocationsForThisCollectionEnd { nullptr };
+    std::unique_ptr<HashSet<HeapCell*>> m_preciseAllocationSet;
+    Vector<PreciseAllocation*> m_preciseAllocations;
+    unsigned m_preciseAllocationsNurseryOffset { 0 };
+    unsigned m_preciseAllocationsOffsetForThisCollection { 0 };
+    unsigned m_preciseAllocationsNurseryOffsetForSweep { 0 };
+    unsigned m_preciseAllocationsForThisCollectionSize { 0 };
+    PreciseAllocation** m_preciseAllocationsForThisCollectionBegin { nullptr };
+    PreciseAllocation** m_preciseAllocationsForThisCollectionEnd { nullptr };
 
-    Heap* m_heap;
     size_t m_capacity { 0 };
     HeapVersion m_markingVersion { initialVersion };
     HeapVersion m_newlyAllocatedVersion { initialVersion };
     bool m_isIterating { false };
     bool m_isMarking { false };

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/xml/XMLHttpRequest.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (C) 2003, 2006, 2008 Apple Inc. All rights reserved.
  3  *  Copyright (C) 2005, 2006 Alexey Proskuryakov &lt;ap@nypop.com&gt;
  4  *  Copyright (C) 2011 Google Inc. All rights reserved.
  5  *  Copyright (C) 2012 Intel Corporation
  6  *
  7  *  This library is free software; you can redistribute it and/or
  8  *  modify it under the terms of the GNU Lesser General Public
  9  *  License as published by the Free Software Foundation; either
 10  *  version 2 of the License, or (at your option) any later version.
 11  *
 12  *  This library is distributed in the hope that it will be useful,
 13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  *  Lesser General Public License for more details.
 16  *
 17  *  You should have received a copy of the GNU Lesser General Public
 18  *  License along with this library; if not, write to the Free Software
 19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;ActiveDOMObject.h&quot;
 25 #include &quot;ExceptionOr.h&quot;
 26 #include &quot;FormData.h&quot;
 27 #include &quot;ResourceResponse.h&quot;
 28 #include &quot;ThreadableLoaderClient.h&quot;
 29 #include &quot;UserGestureIndicator.h&quot;
 30 #include &lt;wtf/URL.h&gt;
 31 #include &quot;XMLHttpRequestEventTarget.h&quot;
 32 #include &quot;XMLHttpRequestProgressEventThrottle.h&quot;
 33 #include &lt;wtf/Variant.h&gt;
 34 #include &lt;wtf/text/StringBuilder.h&gt;
 35 
 36 namespace JSC {
 37 class ArrayBuffer;
 38 class ArrayBufferView;
 39 }
 40 
 41 namespace WebCore {
 42 
 43 class Blob;
 44 class Document;
 45 class DOMFormData;
 46 class SecurityOrigin;
 47 class SharedBuffer;
 48 class TextResourceDecoder;
 49 class ThreadableLoader;
 50 class XMLHttpRequestUpload;
 51 struct OwnedString;
 52 
 53 class XMLHttpRequest final : public ActiveDOMObject, public RefCounted&lt;XMLHttpRequest&gt;, private ThreadableLoaderClient, public XMLHttpRequestEventTarget {
 54     WTF_MAKE_ISO_ALLOCATED(XMLHttpRequest);
 55 public:
 56     static Ref&lt;XMLHttpRequest&gt; create(ScriptExecutionContext&amp;);
 57     WEBCORE_EXPORT ~XMLHttpRequest();
 58 
 59     // Keep it in 3bits.
 60     enum State : uint8_t {
 61         UNSENT = 0,
 62         OPENED = 1,
 63         HEADERS_RECEIVED = 2,
 64         LOADING = 3,
 65         DONE = 4
 66     };
 67 
 68     virtual void didReachTimeout();
 69 
 70     EventTargetInterface eventTargetInterface() const override { return XMLHttpRequestEventTargetInterfaceType; }
 71     ScriptExecutionContext* scriptExecutionContext() const override { return ActiveDOMObject::scriptExecutionContext(); }
 72 
 73     using SendTypes = Variant&lt;RefPtr&lt;Document&gt;, RefPtr&lt;Blob&gt;, RefPtr&lt;JSC::ArrayBufferView&gt;, RefPtr&lt;JSC::ArrayBuffer&gt;, RefPtr&lt;DOMFormData&gt;, String&gt;;
 74 
 75     const URL&amp; url() const { return m_url; }
 76     String statusText() const;
 77     int status() const;
 78     State readyState() const;
 79     bool withCredentials() const { return m_includeCredentials; }
 80     ExceptionOr&lt;void&gt; setWithCredentials(bool);
 81     ExceptionOr&lt;void&gt; open(const String&amp; method, const String&amp; url);
 82     ExceptionOr&lt;void&gt; open(const String&amp; method, const URL&amp;, bool async);
 83     ExceptionOr&lt;void&gt; open(const String&amp; method, const String&amp;, bool async, const String&amp; user, const String&amp; password);
 84     ExceptionOr&lt;void&gt; send(Optional&lt;SendTypes&gt;&amp;&amp;);
 85     void abort();
 86     ExceptionOr&lt;void&gt; setRequestHeader(const String&amp; name, const String&amp; value);
 87     ExceptionOr&lt;void&gt; overrideMimeType(const String&amp; override);
 88     bool doneWithoutErrors() const { return !m_error &amp;&amp; readyState() == DONE; }
 89     String getAllResponseHeaders() const;
 90     String getResponseHeader(const String&amp; name) const;
 91     ExceptionOr&lt;OwnedString&gt; responseText();
 92     String responseTextIgnoringResponseType() const { return m_responseBuilder.toStringPreserveCapacity(); }
 93     String responseMIMEType() const;
 94 
 95     Document* optionalResponseXML() const { return m_responseDocument.get(); }
 96     ExceptionOr&lt;Document*&gt; responseXML();
 97 
 98     Ref&lt;Blob&gt; createResponseBlob();
 99     RefPtr&lt;JSC::ArrayBuffer&gt; createResponseArrayBuffer();
100 
101     unsigned timeout() const { return m_timeoutMilliseconds; }
102     ExceptionOr&lt;void&gt; setTimeout(unsigned);
103 
104     bool responseCacheIsValid() const { return m_responseCacheIsValid; }
105     void didCacheResponse();
106 
107     // Keep it in 3bits.
108     enum class ResponseType : uint8_t {
109         EmptyString = 0,
110         Arraybuffer = 1,
111         Blob = 2,
112         Document = 3,
113         Json = 4,
114         Text = 5,
115     };
116     ExceptionOr&lt;void&gt; setResponseType(ResponseType);
117     ResponseType responseType() const;
118 
119     String responseURL() const;
120 
121     XMLHttpRequestUpload&amp; upload();
122     XMLHttpRequestUpload* optionalUpload() const { return m_upload.get(); }
123 
124     const ResourceResponse&amp; resourceResponse() const { return m_response; }
125 
126     using RefCounted&lt;XMLHttpRequest&gt;::ref;
127     using RefCounted&lt;XMLHttpRequest&gt;::deref;
128 
129     size_t memoryCost() const;
130 
131     WEBCORE_EXPORT void setMaximumIntervalForUserGestureForwarding(double);
132 
133 private:
134     explicit XMLHttpRequest(ScriptExecutionContext&amp;);
135 
136     TextEncoding finalResponseCharset() const;
137 
138     // ActiveDOMObject
139     void contextDestroyed() override;
140     void suspend(ReasonForSuspension) override;
141     void resume() override;
142     void stop() override;
143     const char* activeDOMObjectName() const override;
144 
145     void refEventTarget() override { ref(); }
146     void derefEventTarget() override { deref(); }
147 
148     Document* document() const;
149     SecurityOrigin* securityOrigin() const;
150 
151     // ThreadableLoaderClient
152     void didSendData(unsigned long long bytesSent, unsigned long long totalBytesToBeSent) override;
153     void didReceiveResponse(unsigned long identifier, const ResourceResponse&amp;) override;
154     void didReceiveData(const char* data, int dataLength) override;
155     void didFinishLoading(unsigned long identifier) override;
156     void didFail(const ResourceError&amp;) override;
157 
158     bool responseIsXML() const;
159 
160     Optional&lt;ExceptionOr&lt;void&gt;&gt; prepareToSend();
161     ExceptionOr&lt;void&gt; send(Document&amp;);
162     ExceptionOr&lt;void&gt; send(const String&amp; = { });
163     ExceptionOr&lt;void&gt; send(Blob&amp;);
164     ExceptionOr&lt;void&gt; send(DOMFormData&amp;);
165     ExceptionOr&lt;void&gt; send(JSC::ArrayBuffer&amp;);
166     ExceptionOr&lt;void&gt; send(JSC::ArrayBufferView&amp;);
167     ExceptionOr&lt;void&gt; sendBytesData(const void*, size_t);
168 
169     void changeState(State);
170     void callReadyStateChangeListener();
171 
172     // Returns false when cancelling the loader within internalAbort() triggers an event whose callback creates a new loader.
173     // In that case, the function calling internalAbort should exit.
174     bool internalAbort();
175 
176     void clearResponse();
177     void clearResponseBuffers();
178     void clearRequest();
179 
180     ExceptionOr&lt;void&gt; createRequest();
181 
182     void genericError();
183     void networkError();
184     void abortError();
185 
186     void dispatchErrorEvents(const AtomString&amp;);
187 
188     using EventTarget::dispatchEvent;
189     void dispatchEvent(Event&amp;) override;
190 
191     Ref&lt;TextResourceDecoder&gt; createDecoder() const;
192 
193     void networkErrorTimerFired();
194 
195     unsigned m_async : 1;
196     unsigned m_includeCredentials : 1;
197     unsigned m_sendFlag : 1;
198     unsigned m_createdDocument : 1;
199     unsigned m_error : 1;
200     unsigned m_uploadListenerFlag : 1;
201     unsigned m_uploadComplete : 1;
202     unsigned m_wasAbortedByClient : 1;
203     unsigned m_responseCacheIsValid : 1;
204     unsigned m_readyState : 3; // State
205     unsigned m_responseType : 3; // ResponseType
206 
207     unsigned m_timeoutMilliseconds { 0 };
208 
209     std::unique_ptr&lt;XMLHttpRequestUpload&gt; m_upload;
210 
211     URL m_url;
212     String m_method;
213     HTTPHeaderMap m_requestHeaders;
214     RefPtr&lt;FormData&gt; m_requestEntityBody;
215     String m_mimeTypeOverride;
216 
217     RefPtr&lt;ThreadableLoader&gt; m_loader;
218 
219     String m_responseEncoding;
220 
221     ResourceResponse m_response;
222 
223     RefPtr&lt;TextResourceDecoder&gt; m_decoder;
224 
225     RefPtr&lt;Document&gt; m_responseDocument;
226 
227     RefPtr&lt;SharedBuffer&gt; m_binaryResponseBuilder;
228 
229     StringBuilder m_responseBuilder;
230 
231     // Used for progress event tracking.
232     long long m_receivedLength { 0 };
233 
234     XMLHttpRequestProgressEventThrottle m_progressEventThrottle;
235 
236     mutable String m_allResponseHeaders;
237 
238     Timer m_networkErrorTimer;
239     Timer m_timeoutTimer;
240 
241     MonotonicTime m_sendingTime;
242 
243     Optional&lt;ExceptionCode&gt; m_exceptionCode;
244     RefPtr&lt;UserGestureToken&gt; m_userGestureToken;
245     Seconds m_maximumIntervalForUserGestureForwarding;
246 };
247 
248 inline auto XMLHttpRequest::responseType() const -&gt; ResponseType
249 {
250     return static_cast&lt;ResponseType&gt;(m_responseType);
251 }
252 
253 inline auto XMLHttpRequest::readyState() const -&gt; State
254 {
255     return static_cast&lt;State&gt;(m_readyState);
256 }
257 
258 } // namespace WebCore
    </pre>
  </body>
</html>
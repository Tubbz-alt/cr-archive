<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerBacking.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerBacking.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerBacking.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 236,10 ***</span>
<span class="line-new-header">--- 236,14 ---</span>
      }
  }
  
  RenderLayerBacking::~RenderLayerBacking()
  {
<span class="line-added">+ #if USE(OWNING_LAYER_BEAR_TRAP)</span>
<span class="line-added">+     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;~RenderLayerBacking: m_owningLayerBearTrap caught the bear (55699292)&quot;);</span>
<span class="line-added">+     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;~RenderLayerBacking: m_owningLayer is null (55699292)&quot;);</span>
<span class="line-added">+ #endif</span>
      // Note that m_owningLayer-&gt;backing() is null here.
      updateAncestorClipping(false, nullptr);
      updateChildClippingStrategy(false);
      updateDescendantClippingLayer(false);
      updateOverflowControlsLayers(false, false, false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 256,10 ***</span>
<span class="line-new-header">--- 260,15 ---</span>
      destroyGraphicsLayers();
  }
  
  void RenderLayerBacking::willBeDestroyed()
  {
<span class="line-added">+ #if USE(OWNING_LAYER_BEAR_TRAP)</span>
<span class="line-added">+     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::willBeDestroyed(): m_owningLayerBearTrap caught the bear (55699292)&quot;);</span>
<span class="line-added">+     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::willBeDestroyed(): m_owningLayer is null (55699292)&quot;);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      ASSERT(m_owningLayer.backing() == this);
      compositor().removeFromScrollCoordinatedLayers(m_owningLayer);
  
      clearBackingSharingLayers();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 268,16 ***</span>
  {
      if (layer &amp;&amp; layer-&gt;type() == GraphicsLayer::Type::Normal &amp;&amp; layer-&gt;tiledBacking())
          compositor().layerTiledBackingUsageChanged(layer, false);
  }
  
<span class="line-modified">! static void clearBackingSharingLayerProviders(Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp; sharingLayers)</span>
  {
      for (auto&amp; layerWeakPtr : sharingLayers) {
          if (!layerWeakPtr)
              continue;
<span class="line-modified">!         layerWeakPtr-&gt;setBackingProviderLayer(nullptr);</span>
      }
  }
  
  void RenderLayerBacking::setBackingSharingLayers(Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp;&amp; sharingLayers)
  {
<span class="line-new-header">--- 277,17 ---</span>
  {
      if (layer &amp;&amp; layer-&gt;type() == GraphicsLayer::Type::Normal &amp;&amp; layer-&gt;tiledBacking())
          compositor().layerTiledBackingUsageChanged(layer, false);
  }
  
<span class="line-modified">! static void clearBackingSharingLayerProviders(Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp; sharingLayers, const RenderLayer&amp; providerLayer)</span>
  {
      for (auto&amp; layerWeakPtr : sharingLayers) {
          if (!layerWeakPtr)
              continue;
<span class="line-modified">!         if (layerWeakPtr-&gt;backingProviderLayer() == &amp;providerLayer)</span>
<span class="line-added">+             layerWeakPtr-&gt;setBackingProviderLayer(nullptr);</span>
      }
  }
  
  void RenderLayerBacking::setBackingSharingLayers(Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp;&amp; sharingLayers)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 290,14 ***</span>
              if (!sharingLayers.contains(oldSharingLayer) &amp;&amp; !oldSharingLayer-&gt;isComposited())
                  oldSharingLayer-&gt;computeRepaintRectsIncludingDescendants();
          }
      }
  
<span class="line-modified">!     clearBackingSharingLayerProviders(m_backingSharingLayers);</span>
  
<span class="line-modified">!     if (sharingLayers != m_backingSharingLayers)</span>
          setContentsNeedDisplay(); // This could be optimized to only repaint rects for changed layers.
  
      auto oldSharingLayers = WTFMove(m_backingSharingLayers);
      m_backingSharingLayers = WTFMove(sharingLayers);
  
      for (auto&amp; layerWeakPtr : m_backingSharingLayers)
<span class="line-new-header">--- 300,17 ---</span>
              if (!sharingLayers.contains(oldSharingLayer) &amp;&amp; !oldSharingLayer-&gt;isComposited())
                  oldSharingLayer-&gt;computeRepaintRectsIncludingDescendants();
          }
      }
  
<span class="line-modified">!     clearBackingSharingLayerProviders(m_backingSharingLayers, m_owningLayer);</span>
  
<span class="line-modified">!     if (sharingLayers != m_backingSharingLayers) {</span>
<span class="line-added">+         if (sharingLayers.size())</span>
<span class="line-added">+             setRequiresOwnBackingStore(true);</span>
          setContentsNeedDisplay(); // This could be optimized to only repaint rects for changed layers.
<span class="line-added">+     }</span>
  
      auto oldSharingLayers = WTFMove(m_backingSharingLayers);
      m_backingSharingLayers = WTFMove(sharingLayers);
  
      for (auto&amp; layerWeakPtr : m_backingSharingLayers)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 318,11 ***</span>
      m_backingSharingLayers.removeAll(&amp;layer);
  }
  
  void RenderLayerBacking::clearBackingSharingLayers()
  {
<span class="line-modified">!     clearBackingSharingLayerProviders(m_backingSharingLayers);</span>
      m_backingSharingLayers.clear();
  }
  
  Ref&lt;GraphicsLayer&gt; RenderLayerBacking::createGraphicsLayer(const String&amp; name, GraphicsLayer::Type layerType)
  {
<span class="line-new-header">--- 331,11 ---</span>
      m_backingSharingLayers.removeAll(&amp;layer);
  }
  
  void RenderLayerBacking::clearBackingSharingLayers()
  {
<span class="line-modified">!     clearBackingSharingLayerProviders(m_backingSharingLayers, m_owningLayer);</span>
      m_backingSharingLayers.clear();
  }
  
  Ref&lt;GraphicsLayer&gt; RenderLayerBacking::createGraphicsLayer(const String&amp; name, GraphicsLayer::Type layerType)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 693,10 ***</span>
<span class="line-new-header">--- 706,15 ---</span>
          || (style.transformOriginY().type() == Fixed &amp;&amp; style.transformOriginY().value());
  }
  
  bool RenderLayerBacking::updateCompositedBounds()
  {
<span class="line-added">+ #if USE(OWNING_LAYER_BEAR_TRAP)</span>
<span class="line-added">+     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::updateCompositedBounds(): m_owningLayerBearTrap caught the bear (55699292)&quot;);</span>
<span class="line-added">+     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::updateCompositedBounds(): m_owningLayer is null (55699292)&quot;);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      LayoutRect layerBounds = m_owningLayer.calculateLayerBounds(&amp;m_owningLayer, { }, RenderLayer::defaultCalculateLayerBoundsFlags() | RenderLayer::ExcludeHiddenDescendants | RenderLayer::DontConstrainForMask);
      // Clip to the size of the document or enclosing overflow-scroll layer.
      // If this or an ancestor is transformed, we can&#39;t currently compute the correct rect to intersect with.
      // We&#39;d need RenderObject::convertContainerToLocalQuad(), which doesn&#39;t yet exist.
      if (shouldClipCompositedBounds()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 784,10 ***</span>
<span class="line-new-header">--- 802,15 ---</span>
      }
  }
  
  void RenderLayerBacking::updateAfterLayout(bool needsClippingUpdate, bool needsFullRepaint)
  {
<span class="line-added">+ #if USE(OWNING_LAYER_BEAR_TRAP)</span>
<span class="line-added">+     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::updateAfterLayout(): m_owningLayerBearTrap caught the bear (55699292)&quot;);</span>
<span class="line-added">+     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::updateAfterLayout(): m_owningLayer is null (55699292)&quot;);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      LOG(Compositing, &quot;RenderLayerBacking %p updateAfterLayout (layer %p)&quot;, this, &amp;m_owningLayer);
  
      // This is the main trigger for layout changing layer geometry, but we have to do the work again in updateBackingAndHierarchy()
      // when we know the final compositing hierarchy. We can&#39;t just set dirty bits from RenderLayer::setSize() because that doesn&#39;t
      // take overflow into account.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 829,11 ***</span>
      updateBlendMode(style);
  #endif
      updateCustomAppearance(style);
  }
  
<span class="line-modified">! bool RenderLayerBacking::updateConfiguration()</span>
  {
      ASSERT(!m_owningLayer.normalFlowListDirty());
      ASSERT(!m_owningLayer.zOrderListsDirty());
      ASSERT(!renderer().view().needsLayout());
  
<span class="line-new-header">--- 852,11 ---</span>
      updateBlendMode(style);
  #endif
      updateCustomAppearance(style);
  }
  
<span class="line-modified">! bool RenderLayerBacking::updateConfiguration(const RenderLayer* compositingAncestor)</span>
  {
      ASSERT(!m_owningLayer.normalFlowListDirty());
      ASSERT(!m_owningLayer.zOrderListsDirty());
      ASSERT(!renderer().view().needsLayout());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 863,11 ***</span>
          layerConfigChanged = true;
  
      if (updateDescendantClippingLayer(needsDescendantsClippingLayer))
          layerConfigChanged = true;
  
<span class="line-modified">!     auto* compositingAncestor = m_owningLayer.ancestorCompositingLayer();</span>
      if (updateAncestorClipping(compositor.clippedByAncestor(m_owningLayer, compositingAncestor), compositingAncestor))
          layerConfigChanged = true;
  
      if (updateOverflowControlsLayers(requiresHorizontalScrollbarLayer(), requiresVerticalScrollbarLayer(), requiresScrollCornerLayer()))
          layerConfigChanged = true;
<span class="line-new-header">--- 886,11 ---</span>
          layerConfigChanged = true;
  
      if (updateDescendantClippingLayer(needsDescendantsClippingLayer))
          layerConfigChanged = true;
  
<span class="line-modified">!     ASSERT(compositingAncestor == m_owningLayer.ancestorCompositingLayer());</span>
      if (updateAncestorClipping(compositor.clippedByAncestor(m_owningLayer, compositingAncestor), compositingAncestor))
          layerConfigChanged = true;
  
      if (updateOverflowControlsLayers(requiresHorizontalScrollbarLayer(), requiresVerticalScrollbarLayer(), requiresScrollCornerLayer()))
          layerConfigChanged = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 949,10 ***</span>
<span class="line-new-header">--- 972,15 ---</span>
      }
  
      if (layerConfigChanged)
          updatePaintingPhases();
  
<span class="line-added">+ #if USE(OWNING_LAYER_BEAR_TRAP)</span>
<span class="line-added">+     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::updateConfiguration(): m_owningLayerBearTrap caught the bear (55699292)&quot;);</span>
<span class="line-added">+     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::updateConfiguration(): m_owningLayer is null (55699292)&quot;);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      return layerConfigChanged;
  }
  
  static LayoutRect clipBox(RenderBox&amp; renderer)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1024,12 ***</span>
      return ancestorRendererOffsetFromAncestorGraphicsLayer + toLayoutSize(location);
  }
  
  class ComputedOffsets {
  public:
<span class="line-modified">!     ComputedOffsets(const RenderLayer&amp; renderLayer, const LayoutRect&amp; localRect, const LayoutRect&amp; parentGraphicsLayerRect, const LayoutRect&amp; primaryGraphicsLayerRect)</span>
          : m_renderLayer(renderLayer)
          , m_location(localRect.location())
          , m_parentGraphicsLayerOffset(toLayoutSize(parentGraphicsLayerRect.location()))
          , m_primaryGraphicsLayerOffset(toLayoutSize(primaryGraphicsLayerRect.location()))
          , m_deviceScaleFactor(renderLayer.renderer().document().deviceScaleFactor())
      {
<span class="line-new-header">--- 1052,13 ---</span>
      return ancestorRendererOffsetFromAncestorGraphicsLayer + toLayoutSize(location);
  }
  
  class ComputedOffsets {
  public:
<span class="line-modified">!     ComputedOffsets(const RenderLayer&amp; renderLayer, const RenderLayer* compositingAncestor, const LayoutRect&amp; localRect, const LayoutRect&amp; parentGraphicsLayerRect, const LayoutRect&amp; primaryGraphicsLayerRect)</span>
          : m_renderLayer(renderLayer)
<span class="line-added">+         , m_compositingAncestor(compositingAncestor)</span>
          , m_location(localRect.location())
          , m_parentGraphicsLayerOffset(toLayoutSize(parentGraphicsLayerRect.location()))
          , m_primaryGraphicsLayerOffset(toLayoutSize(primaryGraphicsLayerRect.location()))
          , m_deviceScaleFactor(renderLayer.renderer().document().deviceScaleFactor())
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1051,32 ***</span>
  
  private:
      LayoutSize fromAncestorGraphicsLayer()
      {
          if (!m_fromAncestorGraphicsLayer) {
<span class="line-modified">!             auto* compositedAncestor = m_renderLayer.ancestorCompositingLayer();</span>
<span class="line-modified">!             LayoutPoint localPointInAncestorRenderLayerCoords = m_renderLayer.convertToLayerCoords(compositedAncestor, m_location, RenderLayer::AdjustForColumns);</span>
<span class="line-removed">-             m_fromAncestorGraphicsLayer = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, localPointInAncestorRenderLayerCoords, m_deviceScaleFactor);</span>
          }
          return m_fromAncestorGraphicsLayer.value();
      }
  
      Optional&lt;LayoutSize&gt; m_fromAncestorGraphicsLayer;
      Optional&lt;LayoutSize&gt; m_fromParentGraphicsLayer;
      Optional&lt;LayoutSize&gt; m_fromPrimaryGraphicsLayer;
  
      const RenderLayer&amp; m_renderLayer;
      // Location is relative to the renderer.
      const LayoutPoint m_location;
      const LayoutSize m_parentGraphicsLayerOffset;
      const LayoutSize m_primaryGraphicsLayerOffset;
      float m_deviceScaleFactor;
  };
  
<span class="line-modified">! LayoutRect RenderLayerBacking::computePrimaryGraphicsLayerRect(const LayoutRect&amp; parentGraphicsLayerRect) const</span>
  {
<span class="line-modified">!     ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedBounds(), parentGraphicsLayerRect, { });</span>
      return LayoutRect(encloseRectToDevicePixels(LayoutRect(toLayoutPoint(compositedBoundsOffset.fromParentGraphicsLayer()), compositedBounds().size()),
          deviceScaleFactor()));
  }
  
  // FIXME: See if we need this now that updateGeometry() is always called in post-order traversal.
<span class="line-new-header">--- 1080,32 ---</span>
  
  private:
      LayoutSize fromAncestorGraphicsLayer()
      {
          if (!m_fromAncestorGraphicsLayer) {
<span class="line-modified">!             LayoutPoint localPointInAncestorRenderLayerCoords = m_renderLayer.convertToLayerCoords(m_compositingAncestor, m_location, RenderLayer::AdjustForColumns);</span>
<span class="line-modified">!             m_fromAncestorGraphicsLayer = computeOffsetFromAncestorGraphicsLayer(m_compositingAncestor, localPointInAncestorRenderLayerCoords, m_deviceScaleFactor);</span>
          }
          return m_fromAncestorGraphicsLayer.value();
      }
  
      Optional&lt;LayoutSize&gt; m_fromAncestorGraphicsLayer;
      Optional&lt;LayoutSize&gt; m_fromParentGraphicsLayer;
      Optional&lt;LayoutSize&gt; m_fromPrimaryGraphicsLayer;
  
      const RenderLayer&amp; m_renderLayer;
<span class="line-added">+     const RenderLayer* m_compositingAncestor;</span>
      // Location is relative to the renderer.
      const LayoutPoint m_location;
      const LayoutSize m_parentGraphicsLayerOffset;
      const LayoutSize m_primaryGraphicsLayerOffset;
      float m_deviceScaleFactor;
  };
  
<span class="line-modified">! LayoutRect RenderLayerBacking::computePrimaryGraphicsLayerRect(const RenderLayer* compositedAncestor, const LayoutRect&amp; parentGraphicsLayerRect) const</span>
  {
<span class="line-modified">!     ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedAncestor, compositedBounds(), parentGraphicsLayerRect, { });</span>
      return LayoutRect(encloseRectToDevicePixels(LayoutRect(toLayoutPoint(compositedBoundsOffset.fromParentGraphicsLayer()), compositedBounds().size()),
          deviceScaleFactor()));
  }
  
  // FIXME: See if we need this now that updateGeometry() is always called in post-order traversal.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1110,11 ***</span>
      }
  
      return parentGraphicsLayerRect;
  }
  
<span class="line-modified">! void RenderLayerBacking::updateGeometry()</span>
  {
      ASSERT(!m_owningLayer.normalFlowListDirty());
      ASSERT(!m_owningLayer.zOrderListsDirty());
      ASSERT(!m_owningLayer.descendantDependentFlagsAreDirty());
      ASSERT(!renderer().view().needsLayout());
<span class="line-new-header">--- 1139,11 ---</span>
      }
  
      return parentGraphicsLayerRect;
  }
  
<span class="line-modified">! void RenderLayerBacking::updateGeometry(const RenderLayer* compositedAncestor)</span>
  {
      ASSERT(!m_owningLayer.normalFlowListDirty());
      ASSERT(!m_owningLayer.zOrderListsDirty());
      ASSERT(!m_owningLayer.descendantDependentFlagsAreDirty());
      ASSERT(!renderer().view().needsLayout());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1136,11 ***</span>
  #endif
  #if ENABLE(CSS_COMPOSITING)
      updateBlendMode(style);
  #endif
  
<span class="line-modified">!     auto* compositedAncestor = m_owningLayer.ancestorCompositingLayer();</span>
      LayoutRect parentGraphicsLayerRect = computeParentGraphicsLayerRect(compositedAncestor);
  
      if (m_ancestorClippingStack) {
          // All clipRects in the stack are computed relative to m_owningLayer, so convert them back to compositedAncestor.
          auto offsetFromCompositedAncestor = toLayoutSize(m_owningLayer.convertToLayerCoords(compositedAncestor, { }, RenderLayer::AdjustForColumns));
<span class="line-new-header">--- 1165,11 ---</span>
  #endif
  #if ENABLE(CSS_COMPOSITING)
      updateBlendMode(style);
  #endif
  
<span class="line-modified">!     ASSERT(compositedAncestor == m_owningLayer.ancestorCompositingLayer());</span>
      LayoutRect parentGraphicsLayerRect = computeParentGraphicsLayerRect(compositedAncestor);
  
      if (m_ancestorClippingStack) {
          // All clipRects in the stack are computed relative to m_owningLayer, so convert them back to compositedAncestor.
          auto offsetFromCompositedAncestor = toLayoutSize(m_owningLayer.convertToLayerCoords(compositedAncestor, { }, RenderLayer::AdjustForColumns));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1166,14 ***</span>
          }
  
          parentGraphicsLayerRect = lastClipLayerRect;
      }
  
<span class="line-modified">!     LayoutRect primaryGraphicsLayerRect = computePrimaryGraphicsLayerRect(parentGraphicsLayerRect);</span>
  
<span class="line-modified">!     ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedBounds(), parentGraphicsLayerRect, primaryGraphicsLayerRect);</span>
<span class="line-modified">!     ComputedOffsets rendererOffset(m_owningLayer, { }, parentGraphicsLayerRect, primaryGraphicsLayerRect);</span>
  
      m_compositedBoundsOffsetFromGraphicsLayer = compositedBoundsOffset.fromPrimaryGraphicsLayer();
  
      auto primaryLayerPosition = primaryGraphicsLayerRect.location();
  
<span class="line-new-header">--- 1195,14 ---</span>
          }
  
          parentGraphicsLayerRect = lastClipLayerRect;
      }
  
<span class="line-modified">!     LayoutRect primaryGraphicsLayerRect = computePrimaryGraphicsLayerRect(compositedAncestor, parentGraphicsLayerRect);</span>
  
<span class="line-modified">!     ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedAncestor, compositedBounds(), parentGraphicsLayerRect, primaryGraphicsLayerRect);</span>
<span class="line-modified">!     ComputedOffsets rendererOffset(m_owningLayer, compositedAncestor, { }, parentGraphicsLayerRect, primaryGraphicsLayerRect);</span>
  
      m_compositedBoundsOffsetFromGraphicsLayer = compositedBoundsOffset.fromPrimaryGraphicsLayer();
  
      auto primaryLayerPosition = primaryGraphicsLayerRect.location();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1279,11 ***</span>
              m_contentsContainmentLayer-&gt;setAnchorPoint(FloatPoint3D(0.5, 0.5, 0));
      }
  
      if (m_owningLayer.reflectionLayer() &amp;&amp; m_owningLayer.reflectionLayer()-&gt;isComposited()) {
          auto* reflectionBacking = m_owningLayer.reflectionLayer()-&gt;backing();
<span class="line-modified">!         reflectionBacking-&gt;updateGeometry();</span>
  
          // The reflection layer has the bounds of m_owningLayer.reflectionLayer(),
          // but the reflected layer is the bounds of this layer, so we need to position it appropriately.
          FloatRect layerBounds = this-&gt;compositedBounds();
          FloatRect reflectionLayerBounds = reflectionBacking-&gt;compositedBounds();
<span class="line-new-header">--- 1308,11 ---</span>
              m_contentsContainmentLayer-&gt;setAnchorPoint(FloatPoint3D(0.5, 0.5, 0));
      }
  
      if (m_owningLayer.reflectionLayer() &amp;&amp; m_owningLayer.reflectionLayer()-&gt;isComposited()) {
          auto* reflectionBacking = m_owningLayer.reflectionLayer()-&gt;backing();
<span class="line-modified">!         reflectionBacking-&gt;updateGeometry(&amp;m_owningLayer);</span>
  
          // The reflection layer has the bounds of m_owningLayer.reflectionLayer(),
          // but the reflected layer is the bounds of this layer, so we need to position it appropriately.
          FloatRect layerBounds = this-&gt;compositedBounds();
          FloatRect reflectionLayerBounds = reflectionBacking-&gt;compositedBounds();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1425,10 ***</span>
<span class="line-new-header">--- 1454,15 ---</span>
      m_graphicsLayer-&gt;setContentsVisible(m_owningLayer.hasVisibleContent() || hasVisibleNonCompositedDescendants());
      if (m_scrollContainerLayer) {
          m_scrollContainerLayer-&gt;setContentsVisible(renderer().style().visibility() == Visibility::Visible);
          m_scrollContainerLayer-&gt;setUserInteractionEnabled(renderer().style().pointerEvents() != PointerEvents::None);
      }
<span class="line-added">+ </span>
<span class="line-added">+ #if USE(OWNING_LAYER_BEAR_TRAP)</span>
<span class="line-added">+     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::updateAfterDescendants(): m_owningLayerBearTrap caught the bear (55699292)&quot;);</span>
<span class="line-added">+     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::updateAfterDescendants(): m_owningLayer is null (55699292)&quot;);</span>
<span class="line-added">+ #endif</span>
  }
  
  // FIXME: Avoid repaints when clip path changes.
  void RenderLayerBacking::updateMaskingLayerGeometry()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1589,29 ***</span>
      hasTouchActionElements = renderer().document().mayHaveElementsWithNonAutoTouchAction();
  #endif
      if (m_owningLayer.isRenderViewLayer() &amp;&amp; !hasTouchActionElements)
          return;
  
<span class="line-modified">!     GraphicsContext nullContext(nullptr);</span>
<span class="line-modified">!     RenderLayer::LayerPaintingInfo paintingInfo(&amp;m_owningLayer, compositedBounds(), { }, LayoutSize());</span>
  
<span class="line-modified">!     EventRegion eventRegion;</span>
<span class="line-modified">!     auto eventRegionContext = eventRegion.makeContext();</span>
<span class="line-modified">!     paintingInfo.eventRegionContext = &amp;eventRegionContext;</span>
  
<span class="line-modified">!     auto paintFlags = RenderLayer::paintLayerPaintingCompositingAllPhasesFlags() | RenderLayer::PaintLayerCollectingEventRegion;</span>
<span class="line-modified">!     m_owningLayer.paintLayerContents(nullContext, paintingInfo, paintFlags);</span>
  
<span class="line-modified">!     for (auto&amp; layer : m_backingSharingLayers)</span>
<span class="line-removed">-         layer-&gt;paintLayerWithEffects(nullContext, paintingInfo, paintFlags);</span>
  
<span class="line-modified">!     GraphicsLayer&amp; layerForEventRegion = m_scrolledContentsLayer ? *m_scrolledContentsLayer : *m_graphicsLayer;</span>
  
<span class="line-modified">!     auto layerOffset = toIntSize(layerForEventRegion.scrollOffset()) - roundedIntSize(layerForEventRegion.offsetFromRenderer());</span>
<span class="line-removed">-     eventRegion.translate(layerOffset);</span>
  
<span class="line-modified">!     layerForEventRegion.setEventRegion(WTFMove(eventRegion));</span>
  #endif
  }
  
  bool RenderLayerBacking::updateAncestorClippingStack(Vector&lt;CompositedClipData&gt;&amp;&amp; clippingData)
  {
<span class="line-new-header">--- 1623,34 ---</span>
      hasTouchActionElements = renderer().document().mayHaveElementsWithNonAutoTouchAction();
  #endif
      if (m_owningLayer.isRenderViewLayer() &amp;&amp; !hasTouchActionElements)
          return;
  
<span class="line-modified">!     auto updateEventRegionForLayer = [&amp;](GraphicsLayer&amp; graphicsLayer) {</span>
<span class="line-modified">!         GraphicsContext nullContext(nullptr);</span>
<span class="line-added">+         EventRegion eventRegion;</span>
<span class="line-added">+         auto eventRegionContext = eventRegion.makeContext();</span>
<span class="line-added">+         auto layerOffset = graphicsLayer.scrollOffset() - roundedIntSize(graphicsLayer.offsetFromRenderer());</span>
  
<span class="line-modified">!         if (&amp;graphicsLayer == m_scrolledContentsLayer &amp;&amp; renderer().visibleToHitTesting()) {</span>
<span class="line-modified">!             // Initialize scrolled contents layer with layer-sized event region as it can all used for scrolling.</span>
<span class="line-modified">!             // This avoids generating unnecessarily complex event regions. We still need to to do the paint to capture touch-action regions.</span>
<span class="line-added">+             eventRegionContext.unite(enclosingIntRect(FloatRect(-layerOffset, graphicsLayer.size())), RenderStyle::defaultStyle());</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         auto dirtyRect = enclosingIntRect(FloatRect(FloatPoint(graphicsLayer.offsetFromRenderer()), graphicsLayer.size()));</span>
<span class="line-modified">!         paintIntoLayer(&amp;graphicsLayer, nullContext, dirtyRect, { }, &amp;eventRegionContext);</span>
  
<span class="line-modified">!         eventRegion.translate(toIntSize(layerOffset));</span>
  
<span class="line-modified">!         graphicsLayer.setEventRegion(WTFMove(eventRegion));</span>
<span class="line-added">+     };</span>
  
<span class="line-modified">!     updateEventRegionForLayer(*m_graphicsLayer);</span>
  
<span class="line-modified">!     if (m_scrolledContentsLayer)</span>
<span class="line-added">+         updateEventRegionForLayer(*m_scrolledContentsLayer);</span>
  #endif
  }
  
  bool RenderLayerBacking::updateAncestorClippingStack(Vector&lt;CompositedClipData&gt;&amp;&amp; clippingData)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1929,11 ***</span>
      if (hasClippingLayer() &amp;&amp; needsDescendantsClippingLayer) {
          if (is&lt;RenderBox&gt;(renderer()) &amp;&amp; (renderer().style().clipPath() || renderer().style().hasBorderRadius())) {
              auto* clipLayer = clippingLayer();
              LayoutRect boxRect(LayoutPoint(), downcast&lt;RenderBox&gt;(renderer()).size());
              FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
<span class="line-modified">!             contentsClippingRect.move(LayoutSize(clipLayer-&gt;offsetFromRenderer()));</span>
              // Note that we have to set this rounded rect again during the geometry update (clipLayer-&gt;offsetFromRenderer() may be stale here).
              if (clipLayer-&gt;setMasksToBoundsRect(contentsClippingRect)) {
                  clipLayer-&gt;setMaskLayer(nullptr);
                  GraphicsLayer::clear(m_childClippingMaskLayer);
                  return;
<span class="line-new-header">--- 1968,11 ---</span>
      if (hasClippingLayer() &amp;&amp; needsDescendantsClippingLayer) {
          if (is&lt;RenderBox&gt;(renderer()) &amp;&amp; (renderer().style().clipPath() || renderer().style().hasBorderRadius())) {
              auto* clipLayer = clippingLayer();
              LayoutRect boxRect(LayoutPoint(), downcast&lt;RenderBox&gt;(renderer()).size());
              FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
<span class="line-modified">!             contentsClippingRect.move(LayoutSize(-clipLayer-&gt;offsetFromRenderer()));</span>
              // Note that we have to set this rounded rect again during the geometry update (clipLayer-&gt;offsetFromRenderer() may be stale here).
              if (clipLayer-&gt;setMasksToBoundsRect(contentsClippingRect)) {
                  clipLayer-&gt;setMaskLayer(nullptr);
                  GraphicsLayer::clear(m_childClippingMaskLayer);
                  return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2095,11 ***</span>
      if (style.visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor).isVisible())
          return false;
  
      // FIXME: support gradients with isGeneratedImage.
      auto* styleImage = fillLayer.image();
<span class="line-modified">!     if (!styleImage-&gt;isCachedImage())</span>
          return false;
  
      auto* image = styleImage-&gt;cachedImage()-&gt;image();
      if (!image-&gt;isBitmapImage())
          return false;
<span class="line-new-header">--- 2134,11 ---</span>
      if (style.visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor).isVisible())
          return false;
  
      // FIXME: support gradients with isGeneratedImage.
      auto* styleImage = fillLayer.image();
<span class="line-modified">!     if (!styleImage-&gt;hasCachedImage())</span>
          return false;
  
      auto* image = styleImage-&gt;cachedImage()-&gt;image();
      if (!image-&gt;isBitmapImage())
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2268,11 ***</span>
      // https://bugs.webkit.org/show_bug.cgi?id=119461
      if (hasPerspectiveOrPreserves3D(style))
          return false;
  
      // FIXME: we should be able to allow backgroundComposite; However since this is not a common use case it has been deferred for now.
<span class="line-modified">!     if (style.backgroundComposite() != CompositeSourceOver)</span>
          return false;
  
      return true;
  }
  
<span class="line-new-header">--- 2307,11 ---</span>
      // https://bugs.webkit.org/show_bug.cgi?id=119461
      if (hasPerspectiveOrPreserves3D(style))
          return false;
  
      // FIXME: we should be able to allow backgroundComposite; However since this is not a common use case it has been deferred for now.
<span class="line-modified">!     if (style.backgroundComposite() != CompositeOperator::SourceOver)</span>
          return false;
  
      return true;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2363,11 ***</span>
  static LayerTraversal traverseVisibleNonCompositedDescendantLayers(RenderLayer&amp; parent, const WTF::Function&lt;LayerTraversal (const RenderLayer&amp;)&gt;&amp; layerFunc)
  {
      // FIXME: We shouldn&#39;t be called with a stale z-order lists. See bug 85512.
      parent.updateLayerListsIfNeeded();
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      LayerListMutationDetector mutationChecker(parent);
  #endif
  
      for (auto* childLayer : parent.normalFlowLayers()) {
          if (compositedWithOwnBackingStore(*childLayer))
<span class="line-new-header">--- 2402,11 ---</span>
  static LayerTraversal traverseVisibleNonCompositedDescendantLayers(RenderLayer&amp; parent, const WTF::Function&lt;LayerTraversal (const RenderLayer&amp;)&gt;&amp; layerFunc)
  {
      // FIXME: We shouldn&#39;t be called with a stale z-order lists. See bug 85512.
      parent.updateLayerListsIfNeeded();
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      LayerListMutationDetector mutationChecker(parent);
  #endif
  
      for (auto* childLayer : parent.normalFlowLayers()) {
          if (compositedWithOwnBackingStore(*childLayer))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2773,70 ***</span>
      }
  }
  
  void RenderLayerBacking::paintIntoLayer(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context,
      const IntRect&amp; paintDirtyRect, // In the coords of rootLayer.
<span class="line-modified">!     OptionSet&lt;PaintBehavior&gt; paintBehavior, OptionSet&lt;GraphicsLayerPaintingPhase&gt; paintingPhase)</span>
  {
<span class="line-modified">!     if ((paintsIntoWindow() || paintsIntoCompositedAncestor()) &amp;&amp; paintingPhase != OptionSet&lt;GraphicsLayerPaintingPhase&gt;(GraphicsLayerPaintingPhase::ChildClippingMask)) {</span>
  #if !PLATFORM(IOS_FAMILY) &amp;&amp; !OS(WINDOWS)
          // FIXME: Looks like the CALayer tree is out of sync with the GraphicsLayer heirarchy
<span class="line-modified">!         // when pages are restored from the PageCache.</span>
<span class="line-modified">!         // &lt;rdar://problem/8712587&gt; ASSERT: When Going Back to Page with Plugins in PageCache</span>
          ASSERT_NOT_REACHED();
  #endif
          return;
      }
  
<span class="line-modified">!     OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags;</span>
<span class="line-removed">-     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Background))</span>
<span class="line-removed">-         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingBackgroundPhase);</span>
<span class="line-removed">-     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Foreground))</span>
<span class="line-removed">-         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingForegroundPhase);</span>
<span class="line-removed">-     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Mask))</span>
<span class="line-removed">-         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingMaskPhase);</span>
<span class="line-removed">-     if (paintingPhase.contains(GraphicsLayerPaintingPhase::ClipPath))</span>
<span class="line-removed">-         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingClipPathPhase);</span>
<span class="line-removed">-     if (paintingPhase.contains(GraphicsLayerPaintingPhase::ChildClippingMask))</span>
<span class="line-removed">-         paintFlags.add(RenderLayer::PaintLayerPaintingChildClippingMaskPhase);</span>
<span class="line-removed">-     if (paintingPhase.contains(GraphicsLayerPaintingPhase::OverflowContents))</span>
<span class="line-removed">-         paintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);</span>
<span class="line-removed">-     if (paintingPhase.contains(GraphicsLayerPaintingPhase::CompositedScroll))</span>
<span class="line-removed">-         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingScrollingPhase);</span>
  
<span class="line-modified">!     if (graphicsLayer == m_backgroundLayer.get() &amp;&amp; m_backgroundLayerPaintsFixedRootBackground)</span>
<span class="line-modified">!         paintFlags.add({ RenderLayer::PaintLayerPaintingRootBackgroundOnly, RenderLayer::PaintLayerPaintingCompositingForegroundPhase }); // Need PaintLayerPaintingCompositingForegroundPhase to walk child layers.</span>
<span class="line-removed">-     else if (compositor().fixedRootBackgroundLayer())</span>
<span class="line-removed">-         paintFlags.add(RenderLayer::PaintLayerPaintingSkipRootBackground);</span>
  
  #ifndef NDEBUG
      RenderElement::SetLayoutNeededForbiddenScope forbidSetNeedsLayout(&amp;renderer());
  #endif
  
      auto paintOneLayer = [&amp;](RenderLayer&amp; layer, OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags) {
<span class="line-removed">-         InspectorInstrumentation::willPaint(layer.renderer());</span>
<span class="line-removed">- </span>
          FrameView::PaintingState paintingState;
<span class="line-modified">!         if (layer.isRenderViewLayer())</span>
<span class="line-modified">!             renderer().view().frameView().willPaintContents(context, paintDirtyRect, paintingState);</span>
  
          RenderLayer::LayerPaintingInfo paintingInfo(&amp;m_owningLayer, paintDirtyRect, paintBehavior, -m_subpixelOffsetFromRenderer);
  
          if (&amp;layer == &amp;m_owningLayer) {
              layer.paintLayerContents(context, paintingInfo, paintFlags);
  
<span class="line-modified">!             if (layer.containsDirtyOverlayScrollbars())</span>
                  layer.paintLayerContents(context, paintingInfo, paintFlags | RenderLayer::PaintLayerPaintingOverlayScrollbars);
          } else
              layer.paintLayerWithEffects(context, paintingInfo, paintFlags);
  
<span class="line-modified">!         if (layer.isRenderViewLayer())</span>
<span class="line-modified">!             renderer().view().frameView().didPaintContents(context, paintDirtyRect, paintingState);</span>
  
<span class="line-modified">!         ASSERT(!m_owningLayer.m_usedTransparency);</span>
  
<span class="line-modified">!         InspectorInstrumentation::didPaint(layer.renderer(), paintDirtyRect);</span>
      };
  
      paintOneLayer(m_owningLayer, paintFlags);
  
      // FIXME: Need to check m_foregroundLayer, masking etc. webkit.org/b/197565.
<span class="line-new-header">--- 2812,64 ---</span>
      }
  }
  
  void RenderLayerBacking::paintIntoLayer(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context,
      const IntRect&amp; paintDirtyRect, // In the coords of rootLayer.
<span class="line-modified">!     OptionSet&lt;PaintBehavior&gt; paintBehavior, EventRegionContext* eventRegionContext)</span>
  {
<span class="line-modified">! #if USE(OWNING_LAYER_BEAR_TRAP)</span>
<span class="line-added">+     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::paintIntoLayer(): m_owningLayerBearTrap caught the bear (55699292)&quot;);</span>
<span class="line-added">+     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::paintIntoLayer(): m_owningLayer is null (55699292)&quot;);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     if ((paintsIntoWindow() || paintsIntoCompositedAncestor()) &amp;&amp; graphicsLayer-&gt;paintingPhase() != OptionSet&lt;GraphicsLayerPaintingPhase&gt;(GraphicsLayerPaintingPhase::ChildClippingMask)) {</span>
  #if !PLATFORM(IOS_FAMILY) &amp;&amp; !OS(WINDOWS)
          // FIXME: Looks like the CALayer tree is out of sync with the GraphicsLayer heirarchy
<span class="line-modified">!         // when pages are restored from the BackForwardCache.</span>
<span class="line-modified">!         // &lt;rdar://problem/8712587&gt; ASSERT: When Going Back to Page with Plugins in BackForwardCache</span>
          ASSERT_NOT_REACHED();
  #endif
          return;
      }
  
<span class="line-modified">!     auto paintFlags = paintFlagsForLayer(*graphicsLayer);</span>
  
<span class="line-modified">!     if (eventRegionContext)</span>
<span class="line-modified">!         paintFlags.add(RenderLayer::PaintLayerCollectingEventRegion);</span>
  
  #ifndef NDEBUG
      RenderElement::SetLayoutNeededForbiddenScope forbidSetNeedsLayout(&amp;renderer());
  #endif
  
      auto paintOneLayer = [&amp;](RenderLayer&amp; layer, OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags) {
          FrameView::PaintingState paintingState;
<span class="line-modified">!         if (!eventRegionContext) {</span>
<span class="line-modified">!             InspectorInstrumentation::willPaint(layer.renderer());</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (layer.isRenderViewLayer())</span>
<span class="line-added">+                 renderer().view().frameView().willPaintContents(context, paintDirtyRect, paintingState);</span>
<span class="line-added">+         }</span>
  
          RenderLayer::LayerPaintingInfo paintingInfo(&amp;m_owningLayer, paintDirtyRect, paintBehavior, -m_subpixelOffsetFromRenderer);
<span class="line-added">+         paintingInfo.eventRegionContext = eventRegionContext;</span>
  
          if (&amp;layer == &amp;m_owningLayer) {
              layer.paintLayerContents(context, paintingInfo, paintFlags);
  
<span class="line-modified">!             if (layer.containsDirtyOverlayScrollbars() &amp;&amp; !eventRegionContext)</span>
                  layer.paintLayerContents(context, paintingInfo, paintFlags | RenderLayer::PaintLayerPaintingOverlayScrollbars);
          } else
              layer.paintLayerWithEffects(context, paintingInfo, paintFlags);
  
<span class="line-modified">!         if (!eventRegionContext) {</span>
<span class="line-modified">!             if (layer.isRenderViewLayer())</span>
<span class="line-added">+                 renderer().view().frameView().didPaintContents(context, paintDirtyRect, paintingState);</span>
  
<span class="line-modified">!             InspectorInstrumentation::didPaint(layer.renderer(), paintDirtyRect);</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         ASSERT(!m_owningLayer.m_usedTransparency);</span>
      };
  
      paintOneLayer(m_owningLayer, paintFlags);
  
      // FIXME: Need to check m_foregroundLayer, masking etc. webkit.org/b/197565.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2845,18 ***</span>
      if (graphicsLayer == destinationForSharingLayers) {
          OptionSet&lt;RenderLayer::PaintLayerFlag&gt; sharingLayerPaintFlags = {
              RenderLayer::PaintLayerPaintingCompositingBackgroundPhase,
              RenderLayer::PaintLayerPaintingCompositingForegroundPhase };
  
<span class="line-modified">!         if (paintingPhase.contains(GraphicsLayerPaintingPhase::OverflowContents))</span>
              sharingLayerPaintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);
  
          for (auto&amp; layerWeakPtr : m_backingSharingLayers)
              paintOneLayer(*layerWeakPtr, sharingLayerPaintFlags);
      }
  
<span class="line-modified">!     compositor().didPaintBacking(this);</span>
  }
  
  #if ENABLE(POINTER_EVENTS)
  static RefPtr&lt;Pattern&gt; patternForTouchAction(TouchAction touchAction, FloatSize contentOffset, GraphicsContext&amp; destContext)
  {
<span class="line-new-header">--- 2878,54 ---</span>
      if (graphicsLayer == destinationForSharingLayers) {
          OptionSet&lt;RenderLayer::PaintLayerFlag&gt; sharingLayerPaintFlags = {
              RenderLayer::PaintLayerPaintingCompositingBackgroundPhase,
              RenderLayer::PaintLayerPaintingCompositingForegroundPhase };
  
<span class="line-modified">!         if (graphicsLayer-&gt;paintingPhase().contains(GraphicsLayerPaintingPhase::OverflowContents))</span>
              sharingLayerPaintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);
<span class="line-added">+         if (eventRegionContext)</span>
<span class="line-added">+             sharingLayerPaintFlags.add(RenderLayer::PaintLayerCollectingEventRegion);</span>
  
          for (auto&amp; layerWeakPtr : m_backingSharingLayers)
              paintOneLayer(*layerWeakPtr, sharingLayerPaintFlags);
      }
  
<span class="line-modified">!     if (!eventRegionContext)</span>
<span class="line-added">+         compositor().didPaintBacking(this);</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if USE(OWNING_LAYER_BEAR_TRAP)</span>
<span class="line-added">+     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::paintIntoLayer() end: m_owningLayerBearTrap caught the bear (55699292)&quot;);</span>
<span class="line-added">+     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::paintIntoLayer() end: m_owningLayer is null (55699292)&quot;);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ OptionSet&lt;RenderLayer::PaintLayerFlag&gt; RenderLayerBacking::paintFlagsForLayer(const GraphicsLayer&amp; graphicsLayer) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto paintingPhase = graphicsLayer.paintingPhase();</span>
<span class="line-added">+     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Background))</span>
<span class="line-added">+         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingBackgroundPhase);</span>
<span class="line-added">+     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Foreground))</span>
<span class="line-added">+         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingForegroundPhase);</span>
<span class="line-added">+     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Mask))</span>
<span class="line-added">+         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingMaskPhase);</span>
<span class="line-added">+     if (paintingPhase.contains(GraphicsLayerPaintingPhase::ClipPath))</span>
<span class="line-added">+         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingClipPathPhase);</span>
<span class="line-added">+     if (paintingPhase.contains(GraphicsLayerPaintingPhase::ChildClippingMask))</span>
<span class="line-added">+         paintFlags.add(RenderLayer::PaintLayerPaintingChildClippingMaskPhase);</span>
<span class="line-added">+     if (paintingPhase.contains(GraphicsLayerPaintingPhase::OverflowContents))</span>
<span class="line-added">+         paintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);</span>
<span class="line-added">+     if (paintingPhase.contains(GraphicsLayerPaintingPhase::CompositedScroll))</span>
<span class="line-added">+         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingScrollingPhase);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (&amp;graphicsLayer == m_backgroundLayer.get() &amp;&amp; m_backgroundLayerPaintsFixedRootBackground)</span>
<span class="line-added">+         paintFlags.add({ RenderLayer::PaintLayerPaintingRootBackgroundOnly, RenderLayer::PaintLayerPaintingCompositingForegroundPhase }); // Need PaintLayerPaintingCompositingForegroundPhase to walk child layers.</span>
<span class="line-added">+     else if (compositor().fixedRootBackgroundLayer())</span>
<span class="line-added">+         paintFlags.add(RenderLayer::PaintLayerPaintingSkipRootBackground);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return paintFlags;</span>
  }
  
  #if ENABLE(POINTER_EVENTS)
  static RefPtr&lt;Pattern&gt; patternForTouchAction(TouchAction touchAction, FloatSize contentOffset, GraphicsContext&amp; destContext)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2896,11 ***</span>
      if (!actionIndex || actionIndex &gt;= ARRAY_SIZE(actionsAndColors))
          return nullptr;
  
      const FloatSize tileSize { 32, 18 };
  
<span class="line-modified">!     auto imageBuffer = ImageBuffer::createCompatibleBuffer(tileSize, ColorSpaceSRGB, destContext);</span>
      if (!imageBuffer)
          return nullptr;
  
      const auto&amp; touchActionData = actionsAndColors[actionIndex];
      {
<span class="line-new-header">--- 2965,11 ---</span>
      if (!actionIndex || actionIndex &gt;= ARRAY_SIZE(actionsAndColors))
          return nullptr;
  
      const FloatSize tileSize { 32, 18 };
  
<span class="line-modified">!     auto imageBuffer = ImageBuffer::createCompatibleBuffer(tileSize, ColorSpace::SRGB, destContext);</span>
      if (!imageBuffer)
          return nullptr;
  
      const auto&amp; touchActionData = actionsAndColors[actionIndex];
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2975,11 ***</span>
      }
  #endif // ENABLE(POINTER_EVENTS)
  }
  
  // Up-call from compositing layer drawing callback.
<span class="line-modified">! void RenderLayerBacking::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, OptionSet&lt;GraphicsLayerPaintingPhase&gt; paintingPhase, const FloatRect&amp; clip, GraphicsLayerPaintBehavior layerPaintBehavior)</span>
  {
  #ifndef NDEBUG
      renderer().page().setIsPainting(true);
  #endif
  
<span class="line-new-header">--- 3044,11 ---</span>
      }
  #endif // ENABLE(POINTER_EVENTS)
  }
  
  // Up-call from compositing layer drawing callback.
<span class="line-modified">! void RenderLayerBacking::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, const FloatRect&amp; clip, GraphicsLayerPaintBehavior layerPaintBehavior)</span>
  {
  #ifndef NDEBUG
      renderer().page().setIsPainting(true);
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3000,22 ***</span>
          || graphicsLayer == m_backgroundLayer.get()
          || graphicsLayer == m_maskLayer.get()
          || graphicsLayer == m_childClippingMaskLayer.get()
          || graphicsLayer == m_scrolledContentsLayer.get()) {
  
<span class="line-modified">!         if (!paintingPhase.contains(GraphicsLayerPaintingPhase::OverflowContents))</span>
              dirtyRect.intersect(enclosingIntRect(compositedBoundsIncludingMargin()));
  
          // We have to use the same root as for hit testing, because both methods can compute and cache clipRects.
          OptionSet&lt;PaintBehavior&gt; behavior = PaintBehavior::Normal;
          if (layerPaintBehavior == GraphicsLayerPaintSnapshotting)
              behavior.add(PaintBehavior::Snapshotting);
  
          if (layerPaintBehavior == GraphicsLayerPaintFirstTilePaint)
              behavior.add(PaintBehavior::TileFirstPaint);
  
<span class="line-modified">!         paintIntoLayer(graphicsLayer, context, dirtyRect, behavior, paintingPhase);</span>
  
          if (renderer().settings().visibleDebugOverlayRegions() &amp; NonFastScrollableRegion) // Piggy-back off the setting that shows touch handler regions.
              paintDebugOverlays(graphicsLayer, context);
  
      } else if (graphicsLayer == layerForHorizontalScrollbar()) {
<span class="line-new-header">--- 3069,22 ---</span>
          || graphicsLayer == m_backgroundLayer.get()
          || graphicsLayer == m_maskLayer.get()
          || graphicsLayer == m_childClippingMaskLayer.get()
          || graphicsLayer == m_scrolledContentsLayer.get()) {
  
<span class="line-modified">!         if (!graphicsLayer-&gt;paintingPhase().contains(GraphicsLayerPaintingPhase::OverflowContents))</span>
              dirtyRect.intersect(enclosingIntRect(compositedBoundsIncludingMargin()));
  
          // We have to use the same root as for hit testing, because both methods can compute and cache clipRects.
          OptionSet&lt;PaintBehavior&gt; behavior = PaintBehavior::Normal;
          if (layerPaintBehavior == GraphicsLayerPaintSnapshotting)
              behavior.add(PaintBehavior::Snapshotting);
  
          if (layerPaintBehavior == GraphicsLayerPaintFirstTilePaint)
              behavior.add(PaintBehavior::TileFirstPaint);
  
<span class="line-modified">!         paintIntoLayer(graphicsLayer, context, dirtyRect, behavior);</span>
  
          if (renderer().settings().visibleDebugOverlayRegions() &amp; NonFastScrollableRegion) // Piggy-back off the setting that shows touch handler regions.
              paintDebugOverlays(graphicsLayer, context);
  
      } else if (graphicsLayer == layerForHorizontalScrollbar()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3212,12 ***</span>
  #if ENABLE(FILTERS_LEVEL_2)
      if (hasBackdropFilter &amp;&amp; m_graphicsLayer-&gt;addAnimation(backdropFilterVector, IntSize { }, &amp;animation, keyframes.animationName(), timeOffset))
          didAnimate = true;
  #endif
  
<span class="line-modified">!     if (didAnimate)</span>
          m_owningLayer.setNeedsPostLayoutCompositingUpdate();
  
      return didAnimate;
  }
  
  void RenderLayerBacking::animationPaused(double timeOffset, const String&amp; animationName)
<span class="line-new-header">--- 3281,14 ---</span>
  #if ENABLE(FILTERS_LEVEL_2)
      if (hasBackdropFilter &amp;&amp; m_graphicsLayer-&gt;addAnimation(backdropFilterVector, IntSize { }, &amp;animation, keyframes.animationName(), timeOffset))
          didAnimate = true;
  #endif
  
<span class="line-modified">!     if (didAnimate) {</span>
          m_owningLayer.setNeedsPostLayoutCompositingUpdate();
<span class="line-added">+         m_owningLayer.setNeedsCompositingGeometryUpdate();</span>
<span class="line-added">+     }</span>
  
      return didAnimate;
  }
  
  void RenderLayerBacking::animationPaused(double timeOffset, const String&amp; animationName)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3232,10 ***</span>
<span class="line-new-header">--- 3303,11 ---</span>
  
  void RenderLayerBacking::animationFinished(const String&amp; animationName)
  {
      m_graphicsLayer-&gt;removeAnimation(animationName);
      m_owningLayer.setNeedsPostLayoutCompositingUpdate();
<span class="line-added">+     m_owningLayer.setNeedsCompositingGeometryUpdate();</span>
  }
  
  bool RenderLayerBacking::startTransition(double timeOffset, CSSPropertyID property, const RenderStyle* fromStyle, const RenderStyle* toStyle)
  {
      bool didAnimate = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3323,11 ***</span>
      }
  }
  
  void RenderLayerBacking::notifyAnimationStarted(const GraphicsLayer*, const String&amp;, MonotonicTime time)
  {
<span class="line-modified">!     renderer().animation().notifyAnimationStarted(renderer(), time);</span>
  }
  
  void RenderLayerBacking::notifyFlushRequired(const GraphicsLayer* layer)
  {
      if (renderer().renderTreeBeingDestroyed())
<span class="line-new-header">--- 3395,12 ---</span>
      }
  }
  
  void RenderLayerBacking::notifyAnimationStarted(const GraphicsLayer*, const String&amp;, MonotonicTime time)
  {
<span class="line-modified">!     if (!RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())</span>
<span class="line-added">+         renderer().animation().notifyAnimationStarted(renderer(), time);</span>
  }
  
  void RenderLayerBacking::notifyFlushRequired(const GraphicsLayer* layer)
  {
      if (renderer().renderTreeBeingDestroyed())
</pre>
<center><a href="RenderLayer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerBacking.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
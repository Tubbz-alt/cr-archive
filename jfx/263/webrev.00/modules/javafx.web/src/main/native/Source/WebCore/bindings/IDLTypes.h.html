<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/bindings/IDLTypes.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;StringAdaptors.h&quot;
 29 #include &lt;JavaScriptCore/HandleTypes.h&gt;
 30 #include &lt;JavaScriptCore/Strong.h&gt;
 31 #include &lt;wtf/Brigand.h&gt;
 32 #include &lt;wtf/HashMap.h&gt;
 33 #include &lt;wtf/StdLibExtras.h&gt;
 34 #include &lt;wtf/text/WTFString.h&gt;
 35 
 36 #if ENABLE(WEBGL)
 37 #include &quot;WebGLAny.h&quot;
 38 #endif
 39 
 40 namespace JSC {
 41 class ArrayBuffer;
 42 class ArrayBufferView;
 43 class DataView;
 44 class JSValue;
 45 class JSObject;
 46 }
 47 
 48 namespace WebCore {
 49 
 50 class IDBKey;
 51 class IDBKeyData;
 52 class IDBValue;
 53 class JSWindowProxy;
 54 class DOMPromise;
 55 class ScheduledAction;
 56 
 57 #if ENABLE(WEBGL)
 58 class WebGLExtension;
 59 #endif
 60 
 61 template&lt;typename T&gt;
 62 struct IDLType {
 63     using ImplementationType = T;
 64     using StorageType = T;
 65 
 66     using ParameterType = T;
 67     using NullableParameterType = Optional&lt;ImplementationType&gt;;
 68 
 69     using InnerParameterType = T;
 70     using NullableInnerParameterType = Optional&lt;ImplementationType&gt;;
 71 
 72     using NullableType = Optional&lt;ImplementationType&gt;;
 73     static NullableType nullValue() { return WTF::nullopt; }
 74     static bool isNullValue(const NullableType&amp; value) { return !value; }
 75     static ImplementationType extractValueFromNullable(const NullableType&amp; value) { return value.value(); }
 76 };
 77 
 78 // IDLUnsupportedType is a special type that serves as a base class for currently unsupported types.
 79 struct IDLUnsupportedType : IDLType&lt;void&gt; { };
 80 
 81 // IDLNull is a special type for use as a subtype in an IDLUnion that is nullable.
 82 struct IDLNull : IDLType&lt;std::nullptr_t&gt; { };
 83 
 84 struct IDLAny : IDLType&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt; {
 85     using ParameterType = JSC::JSValue;
 86     using NullableParameterType = JSC::JSValue;
 87 
 88     using NullableType = JSC::Strong&lt;JSC::Unknown&gt;;
 89     static inline std::nullptr_t nullValue() { return nullptr; }
 90     template&lt;typename U&gt; static inline bool isNullValue(U&amp;&amp; value) { return !value; }
 91     template&lt;typename U&gt; static inline U&amp;&amp; extractValueFromNullable(U&amp;&amp; value) { return std::forward&lt;U&gt;(value); }
 92 };
 93 
 94 struct IDLVoid : IDLType&lt;void&gt; { };
 95 
 96 struct IDLBoolean : IDLType&lt;bool&gt; { };
 97 
 98 template&lt;typename NumericType&gt; struct IDLNumber : IDLType&lt;NumericType&gt; { };
 99 
100 template&lt;typename IntegerType&gt; struct IDLInteger : IDLNumber&lt;IntegerType&gt; { };
101 struct IDLByte : IDLInteger&lt;int8_t&gt; { };
102 struct IDLOctet : IDLInteger&lt;uint8_t&gt; { };
103 struct IDLShort : IDLInteger&lt;int16_t&gt; { };
104 struct IDLUnsignedShort : IDLInteger&lt;uint16_t&gt; { };
105 struct IDLLong : IDLInteger&lt;int32_t&gt; { };
106 struct IDLUnsignedLong : IDLInteger&lt;uint32_t&gt; { };
107 struct IDLLongLong : IDLInteger&lt;int64_t&gt; { };
108 struct IDLUnsignedLongLong : IDLInteger&lt;uint64_t&gt; { };
109 
110 template&lt;typename T&gt; struct IDLClampAdaptor : IDLInteger&lt;typename T::ImplementationType&gt; {
111     using InnerType = T;
112 };
113 
114 template&lt;typename T&gt; struct IDLEnforceRangeAdaptor : IDLInteger&lt;typename T::ImplementationType&gt; {
115     using InnerType = T;
116 };
117 
118 template&lt;typename FloatingPointType&gt; struct IDLFloatingPoint : IDLNumber&lt;FloatingPointType&gt; { };
119 struct IDLFloat : IDLFloatingPoint&lt;float&gt; { };
120 struct IDLUnrestrictedFloat : IDLFloatingPoint&lt;float&gt; { };
121 struct IDLDouble : IDLFloatingPoint&lt;double&gt; { };
122 struct IDLUnrestrictedDouble : IDLFloatingPoint&lt;double&gt; { };
123 
124 template&lt;typename StringType&gt; struct IDLString : IDLType&lt;StringType&gt; {
125     using ParameterType = const StringType&amp;;
126     using NullableParameterType = const StringType&amp;;
127 
128     using NullableType = StringType;
129     static StringType nullValue() { return StringType(); }
130     static bool isNullValue(const StringType&amp; value) { return value.isNull(); }
131     static bool isNullValue(const UncachedString&amp; value) { return value.string.isNull(); }
132     static bool isNullValue(const OwnedString&amp; value) { return value.string.isNull(); }
133     template &lt;typename U&gt; static U&amp;&amp; extractValueFromNullable(U&amp;&amp; value) { return std::forward&lt;U&gt;(value); }
134 };
135 struct IDLDOMString : IDLString&lt;String&gt; { };
136 struct IDLByteString : IDLString&lt;String&gt; { };
137 struct IDLUSVString : IDLString&lt;String&gt; { };
138 
139 template&lt;typename T&gt; struct IDLTreatNullAsEmptyAdaptor : IDLString&lt;String&gt; {
140     using InnerType = T;
141 };
142 
143 template&lt;typename T&gt; struct IDLAtomStringAdaptor : IDLString&lt;AtomString&gt; {
144     using InnerType = T;
145 };
146 
147 template&lt;typename T&gt; struct IDLRequiresExistingAtomStringAdaptor : IDLString&lt;AtomString&gt; {
148     using InnerType = T;
149 };
150 
151 struct IDLObject : IDLType&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt; {
152     using NullableType = JSC::Strong&lt;JSC::JSObject&gt;;
153 
154     static inline NullableType nullValue() { return { }; }
155     template&lt;typename U&gt; static inline bool isNullValue(U&amp;&amp; value) { return !value; }
156     template&lt;typename U&gt; static inline U&amp;&amp; extractValueFromNullable(U&amp;&amp; value) { return std::forward&lt;U&gt;(value); }
157 };
158 
159 template&lt;typename T&gt; struct IDLWrapper : IDLType&lt;RefPtr&lt;T&gt;&gt; {
160     using RawType = T;
161 
162     using StorageType = Ref&lt;T&gt;;
163 
164     using ParameterType = T&amp;;
165     using NullableParameterType = T*;
166 
167     using InnerParameterType = Ref&lt;T&gt;;
168     using NullableInnerParameterType = RefPtr&lt;T&gt;;
169 
170     using NullableType = RefPtr&lt;T&gt;;
171     static inline std::nullptr_t nullValue() { return nullptr; }
172     template&lt;typename U&gt; static inline bool isNullValue(U&amp;&amp; value) { return !value; }
173     template&lt;typename U&gt; static inline U&amp;&amp; extractValueFromNullable(U&amp;&amp; value) { return std::forward&lt;U&gt;(value); }
174 };
175 
176 template&lt;typename T&gt; struct IDLInterface : IDLWrapper&lt;T&gt; { };
177 template&lt;typename T&gt; struct IDLCallbackInterface : IDLWrapper&lt;T&gt; { };
178 template&lt;typename T&gt; struct IDLCallbackFunction : IDLWrapper&lt;T&gt; { };
179 
180 template&lt;typename T&gt; struct IDLDictionary : IDLType&lt;T&gt; {
181     using ParameterType = const T&amp;;
182     using NullableParameterType = const T&amp;;
183 };
184 
185 template&lt;typename T&gt; struct IDLEnumeration : IDLType&lt;T&gt; { };
186 
187 template&lt;typename T&gt; struct IDLNullable : IDLType&lt;typename T::NullableType&gt; {
188     using InnerType = T;
189 
190     using ParameterType = typename T::NullableParameterType;
191     using NullableParameterType = typename T::NullableParameterType;
192 
193     using InnerParameterType = typename T::NullableInnerParameterType;
194     using NullableInnerParameterType = typename T::NullableInnerParameterType;
195 
196     using NullableType = typename T::NullableType;
197     static inline auto nullValue() -&gt; decltype(T::nullValue()) { return T::nullValue(); }
198     template&lt;typename U&gt; static inline bool isNullValue(U&amp;&amp; value) { return T::isNullValue(std::forward&lt;U&gt;(value)); }
199     template&lt;typename U&gt; static inline auto extractValueFromNullable(U&amp;&amp; value) -&gt; decltype(T::extractValueFromNullable(std::forward&lt;U&gt;(value))) { return T::extractValueFromNullable(std::forward&lt;U&gt;(value)); }
200 };
201 
202 template&lt;typename T&gt; struct IDLSequence : IDLType&lt;Vector&lt;typename T::ImplementationType&gt;&gt; {
203     using InnerType = T;
204 
205     using ParameterType = const Vector&lt;typename T::InnerParameterType&gt;&amp;;
206     using NullableParameterType = const Optional&lt;Vector&lt;typename T::InnerParameterType&gt;&gt;&amp;;
207 };
208 
209 template&lt;typename T&gt; struct IDLFrozenArray : IDLType&lt;Vector&lt;typename T::ImplementationType&gt;&gt; {
210     using InnerType = T;
211 
212     using ParameterType = const Vector&lt;typename T::ImplementationType&gt;&amp;;
213     using NullableParameterType = const Optional&lt;Vector&lt;typename T::ImplementationType&gt;&gt;&amp;;
214 };
215 
216 template&lt;typename K, typename V&gt; struct IDLRecord : IDLType&lt;Vector&lt;WTF::KeyValuePair&lt;typename K::ImplementationType, typename V::ImplementationType&gt;&gt;&gt; {
217     using KeyType = K;
218     using ValueType = V;
219 
220     using ParameterType = const Vector&lt;WTF::KeyValuePair&lt;typename K::ImplementationType, typename V::ImplementationType&gt;&gt;&amp;;
221     using NullableParameterType = const Optional&lt;Vector&lt;WTF::KeyValuePair&lt;typename K::ImplementationType, typename V::ImplementationType&gt;&gt;&gt;&amp;;
222 };
223 
224 template&lt;typename T&gt; struct IDLPromise : IDLWrapper&lt;DOMPromise&gt; {
225     using InnerType = T;
226 };
227 
228 struct IDLError : IDLUnsupportedType { };
229 struct IDLDOMException : IDLUnsupportedType { };
230 
231 template&lt;typename... Ts&gt;
232 struct IDLUnion : IDLType&lt;Variant&lt;typename Ts::ImplementationType...&gt;&gt; {
233     using TypeList = brigand::list&lt;Ts...&gt;;
234 
235     using ParameterType = const Variant&lt;typename Ts::ImplementationType...&gt;&amp;;
236     using NullableParameterType = const Optional&lt;Variant&lt;typename Ts::ImplementationType...&gt;&gt;&amp;;
237 };
238 
239 template&lt;typename T&gt; struct IDLBufferSource : IDLWrapper&lt;T&gt; { };
240 
241 struct IDLArrayBuffer : IDLBufferSource&lt;JSC::ArrayBuffer&gt; { };
242 // NOTE: WebIDL defines ArrayBufferView as an IDL union of all the TypedArray types.
243 //       and DataView. For convience in our implementation, we give it a distinct
244 //       type that maps to the shared based class of all those classes.
245 struct IDLArrayBufferView : IDLBufferSource&lt;JSC::ArrayBufferView&gt; { };
246 struct IDLDataView : IDLBufferSource&lt;JSC::DataView&gt; { };
247 
248 template&lt;typename T&gt; struct IDLTypedArray : IDLBufferSource&lt;T&gt; { };
249 // NOTE: The specific typed array types are IDLTypedArray specialized on the typed array
250 //       implementation type, e.g. IDLFloat64Array is IDLTypedArray&lt;JSC::Float64Array&gt;
251 
252 
253 // Non-WebIDL extensions
254 
255 struct IDLDate : IDLType&lt;double&gt; {
256     using NullableType = double;
257     static double nullValue() { return std::numeric_limits&lt;double&gt;::quiet_NaN(); }
258     static bool isNullValue(double value) { return std::isnan(value); }
259     static double extractValueFromNullable(double value) { return value; }
260 };
261 
262 struct IDLJSON : IDLType&lt;String&gt; {
263     using ParameterType = const String&amp;;
264     using NullableParameterType = const String&amp;;
265 
266     using NullableType = String;
267     static String nullValue() { return String(); }
268     static bool isNullValue(const String&amp; value) { return value.isNull(); }
269     template &lt;typename U&gt; static U&amp;&amp; extractValueFromNullable(U&amp;&amp; value) { return std::forward&lt;U&gt;(value); }
270 };
271 
272 struct IDLScheduledAction : IDLType&lt;std::unique_ptr&lt;ScheduledAction&gt;&gt; { };
273 template&lt;typename T&gt; struct IDLSerializedScriptValue : IDLWrapper&lt;T&gt; { };
274 template&lt;typename T&gt; struct IDLEventListener : IDLWrapper&lt;T&gt; { };
275 template&lt;typename T&gt; struct IDLXPathNSResolver : IDLWrapper&lt;T&gt; { };
276 
277 struct IDLIDBKey : IDLWrapper&lt;IDBKey&gt; { };
278 struct IDLIDBKeyData : IDLWrapper&lt;IDBKeyData&gt; { };
279 struct IDLIDBValue : IDLWrapper&lt;IDBValue&gt; { };
280 
281 #if ENABLE(WEBGL)
282 struct IDLWebGLAny : IDLType&lt;WebGLAny&gt; { };
283 struct IDLWebGLExtension : IDLWrapper&lt;WebGLExtension&gt; { };
284 #endif
285 
286 // Helper predicates
287 
288 template&lt;typename T&gt;
289 struct IsIDLInterface : public std::integral_constant&lt;bool, WTF::IsTemplate&lt;T, IDLInterface&gt;::value&gt; { };
290 
291 template&lt;typename T&gt;
292 struct IsIDLDictionary : public std::integral_constant&lt;bool, WTF::IsTemplate&lt;T, IDLDictionary&gt;::value&gt; { };
293 
294 template&lt;typename T&gt;
295 struct IsIDLEnumeration : public std::integral_constant&lt;bool, WTF::IsTemplate&lt;T, IDLEnumeration&gt;::value&gt; { };
296 
297 template&lt;typename T&gt;
298 struct IsIDLSequence : public std::integral_constant&lt;bool, WTF::IsTemplate&lt;T, IDLSequence&gt;::value&gt; { };
299 
300 template&lt;typename T&gt;
301 struct IsIDLFrozenArray : public std::integral_constant&lt;bool, WTF::IsTemplate&lt;T, IDLFrozenArray&gt;::value&gt; { };
302 
303 template&lt;typename T&gt;
304 struct IsIDLRecord : public std::integral_constant&lt;bool, WTF::IsTemplate&lt;T, IDLRecord&gt;::value&gt; { };
305 
306 template&lt;typename T&gt;
307 struct IsIDLString : public std::integral_constant&lt;bool, WTF::IsBaseOfTemplate&lt;IDLString, T&gt;::value&gt; { };
308 
309 template&lt;typename T&gt;
310 struct IsIDLStringOrEnumeration : public std::integral_constant&lt;bool, WTF::IsBaseOfTemplate&lt;IDLString, T&gt;::value || WTF::IsTemplate&lt;T, IDLEnumeration&gt;::value&gt; { };
311 
312 template&lt;typename T&gt;
313 struct IsIDLNumber : public std::integral_constant&lt;bool, WTF::IsBaseOfTemplate&lt;IDLNumber, T&gt;::value&gt; { };
314 
315 template&lt;typename T&gt;
316 struct IsIDLInteger : public std::integral_constant&lt;bool, WTF::IsBaseOfTemplate&lt;IDLInteger, T&gt;::value&gt; { };
317 
318 template&lt;typename T&gt;
319 struct IsIDLFloatingPoint : public std::integral_constant&lt;bool, WTF::IsBaseOfTemplate&lt;IDLFloatingPoint, T&gt;::value&gt; { };
320 
321 template&lt;typename T&gt;
322 struct IsIDLTypedArray : public std::integral_constant&lt;bool, WTF::IsBaseOfTemplate&lt;IDLTypedArray, T&gt;::value&gt; { };
323 
324 } // namespace WebCore
    </pre>
  </body>
</html>
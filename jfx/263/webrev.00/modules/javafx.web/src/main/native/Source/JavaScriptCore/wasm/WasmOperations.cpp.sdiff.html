<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmOpcodeOrigin.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmOperations.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmOperations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmOperations.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 









 31 #include &quot;ProbeContext.h&quot;
 32 #include &quot;WasmCallee.h&quot;

 33 #include &quot;WasmContextInlines.h&quot;
 34 #include &quot;WasmInstance.h&quot;
 35 #include &quot;WasmMemory.h&quot;
 36 #include &quot;WasmNameSection.h&quot;
 37 #include &quot;WasmOMGForOSREntryPlan.h&quot;
 38 #include &quot;WasmOMGPlan.h&quot;
 39 #include &quot;WasmOSREntryData.h&quot;
 40 #include &quot;WasmSignatureInlines.h&quot;
 41 #include &quot;WasmWorklist.h&quot;
 42 #include &lt;wtf/DataLog.h&gt;
 43 #include &lt;wtf/Locker.h&gt;
 44 #include &lt;wtf/MonotonicTime.h&gt;
 45 #include &lt;wtf/StdLibExtras.h&gt;
 46 


 47 namespace JSC { namespace Wasm {
 48 

















 49 static bool shouldTriggerOMGCompile(TierUpCount&amp; tierUp, OMGCallee* replacement, uint32_t functionIndex)
 50 {
 51     if (!replacement &amp;&amp; !tierUp.checkIfOptimizationThresholdReached()) {
 52         dataLogLnIf(Options::verboseOSR(), &quot;delayOMGCompile counter = &quot;, tierUp, &quot; for &quot;, functionIndex);
 53         dataLogLnIf(Options::verboseOSR(), &quot;Choosing not to OMG-optimize &quot;, functionIndex, &quot; yet.&quot;);
 54         return false;
 55     }
 56     return true;
 57 }
 58 
 59 static void triggerOMGReplacementCompile(TierUpCount&amp; tierUp, OMGCallee* replacement, Instance* instance, Wasm::CodeBlock&amp; codeBlock, uint32_t functionIndex)
 60 {
 61     if (replacement) {
 62         tierUp.optimizeSoon(functionIndex);
 63         return;
 64     }
 65 
 66     bool compile = false;
 67     {
 68         auto locker = holdLock(tierUp.getLock());
</pre>
<hr />
<pre>
 81 
 82     if (compile) {
 83         dataLogLnIf(Options::verboseOSR(), &quot;triggerOMGReplacement for &quot;, functionIndex);
 84         // We need to compile the code.
 85         Ref&lt;Plan&gt; plan = adoptRef(*new OMGPlan(instance-&gt;context(), Ref&lt;Wasm::Module&gt;(instance-&gt;module()), functionIndex, codeBlock.mode(), Plan::dontFinalize()));
 86         ensureWorklist().enqueue(plan.copyRef());
 87         if (UNLIKELY(!Options::useConcurrentJIT()))
 88             plan-&gt;waitForCompletion();
 89         else
 90             tierUp.setOptimizationThresholdBasedOnCompilationResult(functionIndex, CompilationDeferred);
 91     }
 92 }
 93 
 94 SUPPRESS_ASAN
 95 static void doOSREntry(Instance* instance, Probe::Context&amp; context, BBQCallee&amp; callee, OMGForOSREntryCallee&amp; osrEntryCallee, OSREntryData&amp; osrEntryData)
 96 {
 97     auto returnWithoutOSREntry = [&amp;] {
 98         context.gpr(GPRInfo::argumentGPR0) = 0;
 99     };
100 


101     uint64_t* buffer = instance-&gt;context()-&gt;scratchBufferForSize(osrEntryCallee.osrEntryScratchBufferSize());
102     if (!buffer)
103         return returnWithoutOSREntry();
104 
105     dataLogLnIf(Options::verboseOSR(), osrEntryData.functionIndex(), &quot;:OMG OSR entry: got entry callee &quot;, RawPointer(&amp;osrEntryCallee));
106 
107     // 1. Place required values in scratch buffer.
108     for (unsigned index = 0; index &lt; osrEntryData.values().size(); ++index) {
109         const OSREntryValue&amp; value = osrEntryData.values()[index];
110         dataLogLnIf(Options::verboseOSR(), &quot;OMG OSR entry values[&quot;, index, &quot;] &quot;, value.type(), &quot; &quot;, value);
111         if (value.isGPR()) {
112             switch (value.type().kind()) {
113             case B3::Float:
114             case B3::Double:
115                 RELEASE_ASSERT_NOT_REACHED();
116             default:
117                 *bitwise_cast&lt;uint64_t*&gt;(buffer + index) = context.gpr(value.gpr());
118             }
119         } else if (value.isFPR()) {
120             switch (value.type().kind()) {
</pre>
<hr />
<pre>
185     static_assert(AssemblyHelpers::prologueStackPointerDelta() == sizeof(void*) * 1);
186 #elif CPU(ARM64E) || CPU(ARM64)
187     // move(framePointerRegister, stackPointerRegister);
188     // popPair(framePointerRegister, linkRegister);
189     context.fp() = bitwise_cast&lt;UCPURegister*&gt;(*framePointer);
190     context.gpr(ARM64Registers::lr) = bitwise_cast&lt;UCPURegister&gt;(*(framePointer + 1));
191     context.sp() = framePointer + 2;
192     static_assert(AssemblyHelpers::prologueStackPointerDelta() == sizeof(void*) * 2);
193 #if CPU(ARM64E)
194     // LR needs to be untagged since OSR entry function prologue will tag it with SP. This is similar to tail-call.
195     context.gpr(ARM64Registers::lr) = bitwise_cast&lt;UCPURegister&gt;(untagCodePtr(context.gpr&lt;void*&gt;(ARM64Registers::lr), bitwise_cast&lt;PtrTag&gt;(context.sp())));
196 #endif
197 #else
198 #error Unsupported architecture.
199 #endif
200     // 4. Configure argument registers to jump to OSR entry from the caller of this runtime function.
201     context.gpr(GPRInfo::argumentGPR0) = bitwise_cast&lt;UCPURegister&gt;(buffer);
202     context.gpr(GPRInfo::argumentGPR1) = bitwise_cast&lt;UCPURegister&gt;(osrEntryCallee.entrypoint().executableAddress&lt;&gt;());
203 }
204 
<span class="line-modified">205 void JIT_OPERATION triggerOSREntryNow(Probe::Context&amp; context)</span>
206 {
207     OSREntryData&amp; osrEntryData = *context.arg&lt;OSREntryData*&gt;();
208     uint32_t functionIndex = osrEntryData.functionIndex();
209     uint32_t loopIndex = osrEntryData.loopIndex();
210     Instance* instance = Wasm::Context::tryLoadInstanceFromTLS();
211     if (!instance)
212         instance = context.gpr&lt;Instance*&gt;(Wasm::PinnedRegisterInfo::get().wasmContextInstancePointer);
213 
214     auto returnWithoutOSREntry = [&amp;] {
215         context.gpr(GPRInfo::argumentGPR0) = 0;
216     };
217 
218     Wasm::CodeBlock&amp; codeBlock = *instance-&gt;codeBlock();
219     ASSERT(instance-&gt;memory()-&gt;mode() == codeBlock.mode());
220 
221     uint32_t functionIndexInSpace = functionIndex + codeBlock.functionImportCount();
222     ASSERT(codeBlock.wasmBBQCalleeFromFunctionIndexSpace(functionIndexInSpace).compilationMode() == Wasm::CompilationMode::BBQMode);
223     BBQCallee&amp; callee = static_cast&lt;BBQCallee&amp;&gt;(codeBlock.wasmBBQCalleeFromFunctionIndexSpace(functionIndexInSpace));
224     TierUpCount&amp; tierUp = *callee.tierUpCount();
225     dataLogLnIf(Options::verboseOSR(), &quot;Consider OMGForOSREntryPlan for [&quot;, functionIndex, &quot;] loopIndex#&quot;, loopIndex, &quot; with executeCounter = &quot;, tierUp, &quot; &quot;, RawPointer(callee.replacement()));
</pre>
<hr />
<pre>
369         ensureWorklist().enqueue(plan.copyRef());
370         if (UNLIKELY(!Options::useConcurrentJIT()))
371             plan-&gt;waitForCompletion();
372         else
373             tierUp.setOptimizationThresholdBasedOnCompilationResult(functionIndex, CompilationDeferred);
374     }
375 
376     OMGForOSREntryCallee* osrEntryCallee = callee.osrEntryCallee();
377     if (!osrEntryCallee) {
378         tierUp.setOptimizationThresholdBasedOnCompilationResult(functionIndex, CompilationDeferred);
379         return returnWithoutOSREntry();
380     }
381 
382     if (osrEntryCallee-&gt;loopIndex() == loopIndex)
383         return doOSREntry(instance, context, callee, *osrEntryCallee, osrEntryData);
384 
385     tierUp.dontOptimizeAnytimeSoon(functionIndex);
386     return returnWithoutOSREntry();
387 }
388 
<span class="line-modified">389 void JIT_OPERATION triggerTierUpNow(Instance* instance, uint32_t functionIndex)</span>
390 {
391     Wasm::CodeBlock&amp; codeBlock = *instance-&gt;codeBlock();
392     ASSERT(instance-&gt;memory()-&gt;mode() == codeBlock.mode());
393 
394     uint32_t functionIndexInSpace = functionIndex + codeBlock.functionImportCount();
395     ASSERT(codeBlock.wasmBBQCalleeFromFunctionIndexSpace(functionIndexInSpace).compilationMode() == Wasm::CompilationMode::BBQMode);
396     BBQCallee&amp; callee = static_cast&lt;BBQCallee&amp;&gt;(codeBlock.wasmBBQCalleeFromFunctionIndexSpace(functionIndexInSpace));
397     TierUpCount&amp; tierUp = *callee.tierUpCount();
398     dataLogLnIf(Options::verboseOSR(), &quot;Consider OMGPlan for [&quot;, functionIndex, &quot;] with executeCounter = &quot;, tierUp, &quot; &quot;, RawPointer(callee.replacement()));
399 
400     if (shouldTriggerOMGCompile(tierUp, callee.replacement(), functionIndex))
401         triggerOMGReplacementCompile(tierUp, callee.replacement(), instance, codeBlock, functionIndex);
402 
403     // We already have an OMG replacement.
404     if (callee.replacement()) {
405         // No OSR entry points. Just defer indefinitely.
406         if (tierUp.osrEntryTriggers().isEmpty()) {
407             dataLogLnIf(Options::verboseOSR(), &quot;delayOMGCompile replacement in place, delaying indefinitely for &quot;, functionIndex);
408             tierUp.dontOptimizeAnytimeSoon(functionIndex);
409             return;
410         }
411 
412         // Found one OSR entry point. Since we do not have a way to jettison Wasm::Callee right now, this means that tierUp function is now meaningless.
413         // Not call it as much as possible.
414         if (callee.osrEntryCallee()) {
415             dataLogLnIf(Options::verboseOSR(), &quot;delayOMGCompile trigger in place, delaying indefinitely for &quot;, functionIndex);
416             tierUp.dontOptimizeAnytimeSoon(functionIndex);
417             return;
418         }
419     }
420 }
421 










































































































































































































































































































422 } } // namespace JSC::Wasm
423 


424 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmOperations.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
<span class="line-added"> 31 #include &quot;ButterflyInlines.h&quot;</span>
<span class="line-added"> 32 #include &quot;FrameTracers.h&quot;</span>
<span class="line-added"> 33 #include &quot;IteratorOperations.h&quot;</span>
<span class="line-added"> 34 #include &quot;JITExceptions.h&quot;</span>
<span class="line-added"> 35 #include &quot;JSCJSValueInlines.h&quot;</span>
<span class="line-added"> 36 #include &quot;JSGlobalObjectInlines.h&quot;</span>
<span class="line-added"> 37 #include &quot;JSWebAssemblyHelpers.h&quot;</span>
<span class="line-added"> 38 #include &quot;JSWebAssemblyInstance.h&quot;</span>
<span class="line-added"> 39 #include &quot;JSWebAssemblyRuntimeError.h&quot;</span>
 40 #include &quot;ProbeContext.h&quot;
 41 #include &quot;WasmCallee.h&quot;
<span class="line-added"> 42 #include &quot;WasmCallingConvention.h&quot;</span>
 43 #include &quot;WasmContextInlines.h&quot;
 44 #include &quot;WasmInstance.h&quot;
 45 #include &quot;WasmMemory.h&quot;
 46 #include &quot;WasmNameSection.h&quot;
 47 #include &quot;WasmOMGForOSREntryPlan.h&quot;
 48 #include &quot;WasmOMGPlan.h&quot;
 49 #include &quot;WasmOSREntryData.h&quot;
 50 #include &quot;WasmSignatureInlines.h&quot;
 51 #include &quot;WasmWorklist.h&quot;
 52 #include &lt;wtf/DataLog.h&gt;
 53 #include &lt;wtf/Locker.h&gt;
 54 #include &lt;wtf/MonotonicTime.h&gt;
 55 #include &lt;wtf/StdLibExtras.h&gt;
 56 
<span class="line-added"> 57 IGNORE_WARNINGS_BEGIN(&quot;frame-address&quot;)</span>
<span class="line-added"> 58 </span>
 59 namespace JSC { namespace Wasm {
 60 
<span class="line-added"> 61 void JIT_OPERATION operationWasmThrowBadI64(JSWebAssemblyInstance* instance)</span>
<span class="line-added"> 62 {</span>
<span class="line-added"> 63     VM&amp; vm = instance-&gt;vm();</span>
<span class="line-added"> 64     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 65     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 66 </span>
<span class="line-added"> 67     {</span>
<span class="line-added"> 68         auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 69         JSGlobalObject* globalObject = instance-&gt;globalObject();</span>
<span class="line-added"> 70         auto* error = ErrorInstance::create(globalObject, vm, globalObject-&gt;errorStructure(ErrorType::TypeError), &quot;i64 not allowed as return type or argument to an imported function&quot;_s);</span>
<span class="line-added"> 71         throwException(globalObject, throwScope, error);</span>
<span class="line-added"> 72     }</span>
<span class="line-added"> 73 </span>
<span class="line-added"> 74     genericUnwind(vm, callFrame);</span>
<span class="line-added"> 75     ASSERT(!!vm.callFrameForCatch);</span>
<span class="line-added"> 76 }</span>
<span class="line-added"> 77 </span>
 78 static bool shouldTriggerOMGCompile(TierUpCount&amp; tierUp, OMGCallee* replacement, uint32_t functionIndex)
 79 {
 80     if (!replacement &amp;&amp; !tierUp.checkIfOptimizationThresholdReached()) {
 81         dataLogLnIf(Options::verboseOSR(), &quot;delayOMGCompile counter = &quot;, tierUp, &quot; for &quot;, functionIndex);
 82         dataLogLnIf(Options::verboseOSR(), &quot;Choosing not to OMG-optimize &quot;, functionIndex, &quot; yet.&quot;);
 83         return false;
 84     }
 85     return true;
 86 }
 87 
 88 static void triggerOMGReplacementCompile(TierUpCount&amp; tierUp, OMGCallee* replacement, Instance* instance, Wasm::CodeBlock&amp; codeBlock, uint32_t functionIndex)
 89 {
 90     if (replacement) {
 91         tierUp.optimizeSoon(functionIndex);
 92         return;
 93     }
 94 
 95     bool compile = false;
 96     {
 97         auto locker = holdLock(tierUp.getLock());
</pre>
<hr />
<pre>
110 
111     if (compile) {
112         dataLogLnIf(Options::verboseOSR(), &quot;triggerOMGReplacement for &quot;, functionIndex);
113         // We need to compile the code.
114         Ref&lt;Plan&gt; plan = adoptRef(*new OMGPlan(instance-&gt;context(), Ref&lt;Wasm::Module&gt;(instance-&gt;module()), functionIndex, codeBlock.mode(), Plan::dontFinalize()));
115         ensureWorklist().enqueue(plan.copyRef());
116         if (UNLIKELY(!Options::useConcurrentJIT()))
117             plan-&gt;waitForCompletion();
118         else
119             tierUp.setOptimizationThresholdBasedOnCompilationResult(functionIndex, CompilationDeferred);
120     }
121 }
122 
123 SUPPRESS_ASAN
124 static void doOSREntry(Instance* instance, Probe::Context&amp; context, BBQCallee&amp; callee, OMGForOSREntryCallee&amp; osrEntryCallee, OSREntryData&amp; osrEntryData)
125 {
126     auto returnWithoutOSREntry = [&amp;] {
127         context.gpr(GPRInfo::argumentGPR0) = 0;
128     };
129 
<span class="line-added">130     RELEASE_ASSERT(osrEntryCallee.osrEntryScratchBufferSize() == osrEntryData.values().size());</span>
<span class="line-added">131 </span>
132     uint64_t* buffer = instance-&gt;context()-&gt;scratchBufferForSize(osrEntryCallee.osrEntryScratchBufferSize());
133     if (!buffer)
134         return returnWithoutOSREntry();
135 
136     dataLogLnIf(Options::verboseOSR(), osrEntryData.functionIndex(), &quot;:OMG OSR entry: got entry callee &quot;, RawPointer(&amp;osrEntryCallee));
137 
138     // 1. Place required values in scratch buffer.
139     for (unsigned index = 0; index &lt; osrEntryData.values().size(); ++index) {
140         const OSREntryValue&amp; value = osrEntryData.values()[index];
141         dataLogLnIf(Options::verboseOSR(), &quot;OMG OSR entry values[&quot;, index, &quot;] &quot;, value.type(), &quot; &quot;, value);
142         if (value.isGPR()) {
143             switch (value.type().kind()) {
144             case B3::Float:
145             case B3::Double:
146                 RELEASE_ASSERT_NOT_REACHED();
147             default:
148                 *bitwise_cast&lt;uint64_t*&gt;(buffer + index) = context.gpr(value.gpr());
149             }
150         } else if (value.isFPR()) {
151             switch (value.type().kind()) {
</pre>
<hr />
<pre>
216     static_assert(AssemblyHelpers::prologueStackPointerDelta() == sizeof(void*) * 1);
217 #elif CPU(ARM64E) || CPU(ARM64)
218     // move(framePointerRegister, stackPointerRegister);
219     // popPair(framePointerRegister, linkRegister);
220     context.fp() = bitwise_cast&lt;UCPURegister*&gt;(*framePointer);
221     context.gpr(ARM64Registers::lr) = bitwise_cast&lt;UCPURegister&gt;(*(framePointer + 1));
222     context.sp() = framePointer + 2;
223     static_assert(AssemblyHelpers::prologueStackPointerDelta() == sizeof(void*) * 2);
224 #if CPU(ARM64E)
225     // LR needs to be untagged since OSR entry function prologue will tag it with SP. This is similar to tail-call.
226     context.gpr(ARM64Registers::lr) = bitwise_cast&lt;UCPURegister&gt;(untagCodePtr(context.gpr&lt;void*&gt;(ARM64Registers::lr), bitwise_cast&lt;PtrTag&gt;(context.sp())));
227 #endif
228 #else
229 #error Unsupported architecture.
230 #endif
231     // 4. Configure argument registers to jump to OSR entry from the caller of this runtime function.
232     context.gpr(GPRInfo::argumentGPR0) = bitwise_cast&lt;UCPURegister&gt;(buffer);
233     context.gpr(GPRInfo::argumentGPR1) = bitwise_cast&lt;UCPURegister&gt;(osrEntryCallee.entrypoint().executableAddress&lt;&gt;());
234 }
235 
<span class="line-modified">236 void JIT_OPERATION operationWasmTriggerOSREntryNow(Probe::Context&amp; context)</span>
237 {
238     OSREntryData&amp; osrEntryData = *context.arg&lt;OSREntryData*&gt;();
239     uint32_t functionIndex = osrEntryData.functionIndex();
240     uint32_t loopIndex = osrEntryData.loopIndex();
241     Instance* instance = Wasm::Context::tryLoadInstanceFromTLS();
242     if (!instance)
243         instance = context.gpr&lt;Instance*&gt;(Wasm::PinnedRegisterInfo::get().wasmContextInstancePointer);
244 
245     auto returnWithoutOSREntry = [&amp;] {
246         context.gpr(GPRInfo::argumentGPR0) = 0;
247     };
248 
249     Wasm::CodeBlock&amp; codeBlock = *instance-&gt;codeBlock();
250     ASSERT(instance-&gt;memory()-&gt;mode() == codeBlock.mode());
251 
252     uint32_t functionIndexInSpace = functionIndex + codeBlock.functionImportCount();
253     ASSERT(codeBlock.wasmBBQCalleeFromFunctionIndexSpace(functionIndexInSpace).compilationMode() == Wasm::CompilationMode::BBQMode);
254     BBQCallee&amp; callee = static_cast&lt;BBQCallee&amp;&gt;(codeBlock.wasmBBQCalleeFromFunctionIndexSpace(functionIndexInSpace));
255     TierUpCount&amp; tierUp = *callee.tierUpCount();
256     dataLogLnIf(Options::verboseOSR(), &quot;Consider OMGForOSREntryPlan for [&quot;, functionIndex, &quot;] loopIndex#&quot;, loopIndex, &quot; with executeCounter = &quot;, tierUp, &quot; &quot;, RawPointer(callee.replacement()));
</pre>
<hr />
<pre>
400         ensureWorklist().enqueue(plan.copyRef());
401         if (UNLIKELY(!Options::useConcurrentJIT()))
402             plan-&gt;waitForCompletion();
403         else
404             tierUp.setOptimizationThresholdBasedOnCompilationResult(functionIndex, CompilationDeferred);
405     }
406 
407     OMGForOSREntryCallee* osrEntryCallee = callee.osrEntryCallee();
408     if (!osrEntryCallee) {
409         tierUp.setOptimizationThresholdBasedOnCompilationResult(functionIndex, CompilationDeferred);
410         return returnWithoutOSREntry();
411     }
412 
413     if (osrEntryCallee-&gt;loopIndex() == loopIndex)
414         return doOSREntry(instance, context, callee, *osrEntryCallee, osrEntryData);
415 
416     tierUp.dontOptimizeAnytimeSoon(functionIndex);
417     return returnWithoutOSREntry();
418 }
419 
<span class="line-modified">420 void JIT_OPERATION operationWasmTriggerTierUpNow(Instance* instance, uint32_t functionIndex)</span>
421 {
422     Wasm::CodeBlock&amp; codeBlock = *instance-&gt;codeBlock();
423     ASSERT(instance-&gt;memory()-&gt;mode() == codeBlock.mode());
424 
425     uint32_t functionIndexInSpace = functionIndex + codeBlock.functionImportCount();
426     ASSERT(codeBlock.wasmBBQCalleeFromFunctionIndexSpace(functionIndexInSpace).compilationMode() == Wasm::CompilationMode::BBQMode);
427     BBQCallee&amp; callee = static_cast&lt;BBQCallee&amp;&gt;(codeBlock.wasmBBQCalleeFromFunctionIndexSpace(functionIndexInSpace));
428     TierUpCount&amp; tierUp = *callee.tierUpCount();
429     dataLogLnIf(Options::verboseOSR(), &quot;Consider OMGPlan for [&quot;, functionIndex, &quot;] with executeCounter = &quot;, tierUp, &quot; &quot;, RawPointer(callee.replacement()));
430 
431     if (shouldTriggerOMGCompile(tierUp, callee.replacement(), functionIndex))
432         triggerOMGReplacementCompile(tierUp, callee.replacement(), instance, codeBlock, functionIndex);
433 
434     // We already have an OMG replacement.
435     if (callee.replacement()) {
436         // No OSR entry points. Just defer indefinitely.
437         if (tierUp.osrEntryTriggers().isEmpty()) {
438             dataLogLnIf(Options::verboseOSR(), &quot;delayOMGCompile replacement in place, delaying indefinitely for &quot;, functionIndex);
439             tierUp.dontOptimizeAnytimeSoon(functionIndex);
440             return;
441         }
442 
443         // Found one OSR entry point. Since we do not have a way to jettison Wasm::Callee right now, this means that tierUp function is now meaningless.
444         // Not call it as much as possible.
445         if (callee.osrEntryCallee()) {
446             dataLogLnIf(Options::verboseOSR(), &quot;delayOMGCompile trigger in place, delaying indefinitely for &quot;, functionIndex);
447             tierUp.dontOptimizeAnytimeSoon(functionIndex);
448             return;
449         }
450     }
451 }
452 
<span class="line-added">453 void JIT_OPERATION operationWasmUnwind(CallFrame* callFrame)</span>
<span class="line-added">454 {</span>
<span class="line-added">455     // FIXME: Consider passing JSWebAssemblyInstance* instead.</span>
<span class="line-added">456     // https://bugs.webkit.org/show_bug.cgi?id=203206</span>
<span class="line-added">457     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
<span class="line-added">458     NativeCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">459     genericUnwind(vm, callFrame);</span>
<span class="line-added">460     ASSERT(!!vm.callFrameForCatch);</span>
<span class="line-added">461 }</span>
<span class="line-added">462 </span>
<span class="line-added">463 double JIT_OPERATION operationConvertToF64(CallFrame* callFrame, JSValue v)</span>
<span class="line-added">464 {</span>
<span class="line-added">465     // FIXME: Consider passing JSWebAssemblyInstance* instead.</span>
<span class="line-added">466     // https://bugs.webkit.org/show_bug.cgi?id=203206</span>
<span class="line-added">467     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
<span class="line-added">468     NativeCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">469     return v.toNumber(callFrame-&gt;lexicalGlobalObject(vm));</span>
<span class="line-added">470 }</span>
<span class="line-added">471 </span>
<span class="line-added">472 int32_t JIT_OPERATION operationConvertToI32(CallFrame* callFrame, JSValue v)</span>
<span class="line-added">473 {</span>
<span class="line-added">474     // FIXME: Consider passing JSWebAssemblyInstance* instead.</span>
<span class="line-added">475     // https://bugs.webkit.org/show_bug.cgi?id=203206</span>
<span class="line-added">476     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
<span class="line-added">477     NativeCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">478     return v.toInt32(callFrame-&gt;lexicalGlobalObject(vm));</span>
<span class="line-added">479 }</span>
<span class="line-added">480 </span>
<span class="line-added">481 float JIT_OPERATION operationConvertToF32(CallFrame* callFrame, JSValue v)</span>
<span class="line-added">482 {</span>
<span class="line-added">483     // FIXME: Consider passing JSWebAssemblyInstance* instead.</span>
<span class="line-added">484     // https://bugs.webkit.org/show_bug.cgi?id=203206</span>
<span class="line-added">485     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
<span class="line-added">486     NativeCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">487     return static_cast&lt;float&gt;(v.toNumber(callFrame-&gt;lexicalGlobalObject(vm)));</span>
<span class="line-added">488 }</span>
<span class="line-added">489 </span>
<span class="line-added">490 void JIT_OPERATION operationIterateResults(CallFrame* callFrame, Instance* instance, const Signature* signature, JSValue result, uint64_t* registerResults, uint64_t* calleeFramePointer)</span>
<span class="line-added">491 {</span>
<span class="line-added">492     // FIXME: Consider passing JSWebAssemblyInstance* instead.</span>
<span class="line-added">493     // https://bugs.webkit.org/show_bug.cgi?id=203206</span>
<span class="line-added">494     JSWebAssemblyInstance* jsInstance = instance-&gt;owner&lt;JSWebAssemblyInstance&gt;();</span>
<span class="line-added">495     JSGlobalObject* globalObject = jsInstance-&gt;globalObject();</span>
<span class="line-added">496     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">497     NativeCallFrameTracer(vm, callFrame);</span>
<span class="line-added">498     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">499 </span>
<span class="line-added">500     auto wasmCallInfo = wasmCallingConvention().callInformationFor(*signature, CallRole::Callee);</span>
<span class="line-added">501     RegisterAtOffsetList registerResultOffsets = wasmCallInfo.computeResultsOffsetList();</span>
<span class="line-added">502 </span>
<span class="line-added">503     unsigned itemsInserted = 0;</span>
<span class="line-added">504     forEachInIterable(globalObject, result, [&amp;] (VM&amp; vm, JSGlobalObject* globalObject, JSValue value) -&gt; void {</span>
<span class="line-added">505         auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">506         if (itemsInserted &lt; signature-&gt;returnCount()) {</span>
<span class="line-added">507             uint64_t unboxedValue;</span>
<span class="line-added">508             switch (signature-&gt;returnType(itemsInserted)) {</span>
<span class="line-added">509             case I32:</span>
<span class="line-added">510                 unboxedValue = value.toInt32(globalObject);</span>
<span class="line-added">511                 break;</span>
<span class="line-added">512             case F32:</span>
<span class="line-added">513                 unboxedValue = bitwise_cast&lt;uint32_t&gt;(value.toFloat(globalObject));</span>
<span class="line-added">514                 break;</span>
<span class="line-added">515             case F64:</span>
<span class="line-added">516                 unboxedValue = bitwise_cast&lt;uint64_t&gt;(value.toNumber(globalObject));</span>
<span class="line-added">517                 break;</span>
<span class="line-added">518             case Funcref:</span>
<span class="line-added">519                 if (!value.isFunction(vm)) {</span>
<span class="line-added">520                     throwTypeError(globalObject, scope, &quot;Funcref value is not a function&quot;_s);</span>
<span class="line-added">521                     return;</span>
<span class="line-added">522                 }</span>
<span class="line-added">523                 FALLTHROUGH;</span>
<span class="line-added">524             case Anyref:</span>
<span class="line-added">525                 unboxedValue = bitwise_cast&lt;uint64_t&gt;(value);</span>
<span class="line-added">526                 RELEASE_ASSERT(Options::useWebAssemblyReferences());</span>
<span class="line-added">527                 break;</span>
<span class="line-added">528             default:</span>
<span class="line-added">529                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">530             }</span>
<span class="line-added">531 </span>
<span class="line-added">532             RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-added">533             auto rep = wasmCallInfo.results[itemsInserted];</span>
<span class="line-added">534             if (rep.isReg())</span>
<span class="line-added">535                 registerResults[registerResultOffsets.find(rep.reg())-&gt;offset() / sizeof(uint64_t)] = unboxedValue;</span>
<span class="line-added">536             else</span>
<span class="line-added">537                 calleeFramePointer[rep.offsetFromFP() / sizeof(uint64_t)] = unboxedValue;</span>
<span class="line-added">538         }</span>
<span class="line-added">539         itemsInserted++;</span>
<span class="line-added">540     });</span>
<span class="line-added">541     RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-added">542     if (itemsInserted != signature-&gt;returnCount())</span>
<span class="line-added">543         throwVMTypeError(globalObject, scope, &quot;Incorrect number of values returned to Wasm from JS&quot;);</span>
<span class="line-added">544 }</span>
<span class="line-added">545 </span>
<span class="line-added">546 // FIXME: It would be much easier to inline this when we have a global GC, which could probably mean we could avoid</span>
<span class="line-added">547 // spilling the results onto the stack.</span>
<span class="line-added">548 // Saved result registers should be placed on the stack just above the last stack result.</span>
<span class="line-added">549 JSArray* JIT_OPERATION operationAllocateResultsArray(CallFrame* callFrame, Wasm::Instance* instance, const Signature* signature, IndexingType indexingType, JSValue* stackPointerFromCallee)</span>
<span class="line-added">550 {</span>
<span class="line-added">551     JSWebAssemblyInstance* jsInstance = instance-&gt;owner&lt;JSWebAssemblyInstance&gt;();</span>
<span class="line-added">552     VM&amp; vm = jsInstance-&gt;vm();</span>
<span class="line-added">553     NativeCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">554 </span>
<span class="line-added">555     JSGlobalObject* globalObject = jsInstance-&gt;globalObject();</span>
<span class="line-added">556     ObjectInitializationScope initializationScope(globalObject-&gt;vm());</span>
<span class="line-added">557     JSArray* result = JSArray::tryCreateUninitializedRestricted(initializationScope, nullptr, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingType), signature-&gt;returnCount());</span>
<span class="line-added">558 </span>
<span class="line-added">559     // FIXME: Handle allocation failure...</span>
<span class="line-added">560     RELEASE_ASSERT(result);</span>
<span class="line-added">561 </span>
<span class="line-added">562     auto wasmCallInfo = wasmCallingConvention().callInformationFor(*signature);</span>
<span class="line-added">563     RegisterAtOffsetList registerResults = wasmCallInfo.computeResultsOffsetList();</span>
<span class="line-added">564 </span>
<span class="line-added">565     static_assert(sizeof(JSValue) == sizeof(CPURegister), &quot;The code below relies on this.&quot;);</span>
<span class="line-added">566     for (unsigned i = 0; i &lt; signature-&gt;returnCount(); ++i) {</span>
<span class="line-added">567         B3::ValueRep rep = wasmCallInfo.results[i];</span>
<span class="line-added">568         JSValue value;</span>
<span class="line-added">569         if (rep.isReg())</span>
<span class="line-added">570             value = stackPointerFromCallee[(registerResults.find(rep.reg())-&gt;offset() + wasmCallInfo.headerAndArgumentStackSizeInBytes) / sizeof(JSValue)];</span>
<span class="line-added">571         else</span>
<span class="line-added">572             value = stackPointerFromCallee[rep.offsetFromSP() / sizeof(JSValue)];</span>
<span class="line-added">573         result-&gt;initializeIndex(initializationScope, i, value);</span>
<span class="line-added">574     }</span>
<span class="line-added">575 </span>
<span class="line-added">576     ASSERT(result-&gt;indexingType() == indexingType);</span>
<span class="line-added">577     return result;</span>
<span class="line-added">578 }</span>
<span class="line-added">579 </span>
<span class="line-added">580 void JIT_OPERATION operationWasmWriteBarrierSlowPath(JSCell* cell, VM* vmPointer)</span>
<span class="line-added">581 {</span>
<span class="line-added">582     ASSERT(cell);</span>
<span class="line-added">583     ASSERT(vmPointer);</span>
<span class="line-added">584     VM&amp; vm = *vmPointer;</span>
<span class="line-added">585     vm.heap.writeBarrierSlowPath(cell);</span>
<span class="line-added">586 }</span>
<span class="line-added">587 </span>
<span class="line-added">588 uint32_t JIT_OPERATION operationPopcount32(int32_t value)</span>
<span class="line-added">589 {</span>
<span class="line-added">590     return __builtin_popcount(value);</span>
<span class="line-added">591 }</span>
<span class="line-added">592 </span>
<span class="line-added">593 uint64_t JIT_OPERATION operationPopcount64(int64_t value)</span>
<span class="line-added">594 {</span>
<span class="line-added">595     return __builtin_popcountll(value);</span>
<span class="line-added">596 }</span>
<span class="line-added">597 </span>
<span class="line-added">598 int32_t JIT_OPERATION operationGrowMemory(void* callFrame, Instance* instance, int32_t delta)</span>
<span class="line-added">599 {</span>
<span class="line-added">600     instance-&gt;storeTopCallFrame(callFrame);</span>
<span class="line-added">601 </span>
<span class="line-added">602     if (delta &lt; 0)</span>
<span class="line-added">603         return -1;</span>
<span class="line-added">604 </span>
<span class="line-added">605     auto grown = instance-&gt;memory()-&gt;grow(PageCount(delta));</span>
<span class="line-added">606     if (!grown) {</span>
<span class="line-added">607         switch (grown.error()) {</span>
<span class="line-added">608         case Memory::GrowFailReason::InvalidDelta:</span>
<span class="line-added">609         case Memory::GrowFailReason::InvalidGrowSize:</span>
<span class="line-added">610         case Memory::GrowFailReason::WouldExceedMaximum:</span>
<span class="line-added">611         case Memory::GrowFailReason::OutOfMemory:</span>
<span class="line-added">612             return -1;</span>
<span class="line-added">613         }</span>
<span class="line-added">614         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">615     }</span>
<span class="line-added">616 </span>
<span class="line-added">617     return grown.value().pageCount();</span>
<span class="line-added">618 }</span>
<span class="line-added">619 </span>
<span class="line-added">620 EncodedJSValue JIT_OPERATION operationGetWasmTableElement(Instance* instance, unsigned tableIndex, int32_t signedIndex)</span>
<span class="line-added">621 {</span>
<span class="line-added">622     ASSERT(tableIndex &lt; instance-&gt;module().moduleInformation().tableCount());</span>
<span class="line-added">623     if (signedIndex &lt; 0)</span>
<span class="line-added">624         return 0;</span>
<span class="line-added">625 </span>
<span class="line-added">626     uint32_t index = signedIndex;</span>
<span class="line-added">627     if (index &gt;= instance-&gt;table(tableIndex)-&gt;length())</span>
<span class="line-added">628         return 0;</span>
<span class="line-added">629 </span>
<span class="line-added">630     return JSValue::encode(instance-&gt;table(tableIndex)-&gt;get(index));</span>
<span class="line-added">631 }</span>
<span class="line-added">632 </span>
<span class="line-added">633 static bool setWasmTableElement(Instance* instance, unsigned tableIndex, int32_t signedIndex, EncodedJSValue encValue)</span>
<span class="line-added">634 {</span>
<span class="line-added">635     ASSERT(tableIndex &lt; instance-&gt;module().moduleInformation().tableCount());</span>
<span class="line-added">636     if (signedIndex &lt; 0)</span>
<span class="line-added">637         return false;</span>
<span class="line-added">638 </span>
<span class="line-added">639     uint32_t index = signedIndex;</span>
<span class="line-added">640     if (index &gt;= instance-&gt;table(tableIndex)-&gt;length())</span>
<span class="line-added">641         return false;</span>
<span class="line-added">642 </span>
<span class="line-added">643     JSValue value = JSValue::decode(encValue);</span>
<span class="line-added">644     if (instance-&gt;table(tableIndex)-&gt;type() == Wasm::TableElementType::Anyref)</span>
<span class="line-added">645         instance-&gt;table(tableIndex)-&gt;set(index, value);</span>
<span class="line-added">646     else if (instance-&gt;table(tableIndex)-&gt;type() == Wasm::TableElementType::Funcref) {</span>
<span class="line-added">647         WebAssemblyFunction* wasmFunction;</span>
<span class="line-added">648         WebAssemblyWrapperFunction* wasmWrapperFunction;</span>
<span class="line-added">649 </span>
<span class="line-added">650         if (isWebAssemblyHostFunction(instance-&gt;owner&lt;JSObject&gt;()-&gt;vm(), value, wasmFunction, wasmWrapperFunction)) {</span>
<span class="line-added">651             ASSERT(!!wasmFunction || !!wasmWrapperFunction);</span>
<span class="line-added">652             if (wasmFunction)</span>
<span class="line-added">653                 instance-&gt;table(tableIndex)-&gt;asFuncrefTable()-&gt;setFunction(index, jsCast&lt;JSObject*&gt;(value), wasmFunction-&gt;importableFunction(), &amp;wasmFunction-&gt;instance()-&gt;instance());</span>
<span class="line-added">654             else</span>
<span class="line-added">655                 instance-&gt;table(tableIndex)-&gt;asFuncrefTable()-&gt;setFunction(index, jsCast&lt;JSObject*&gt;(value), wasmWrapperFunction-&gt;importableFunction(), &amp;wasmWrapperFunction-&gt;instance()-&gt;instance());</span>
<span class="line-added">656         } else if (value.isNull())</span>
<span class="line-added">657             instance-&gt;table(tableIndex)-&gt;clear(index);</span>
<span class="line-added">658         else</span>
<span class="line-added">659             ASSERT_NOT_REACHED();</span>
<span class="line-added">660     } else</span>
<span class="line-added">661         ASSERT_NOT_REACHED();</span>
<span class="line-added">662 </span>
<span class="line-added">663     return true;</span>
<span class="line-added">664 }</span>
<span class="line-added">665 </span>
<span class="line-added">666 bool JIT_OPERATION operationSetWasmTableElement(Instance* instance, unsigned tableIndex, int32_t signedIndex, EncodedJSValue encValue)</span>
<span class="line-added">667 {</span>
<span class="line-added">668     return setWasmTableElement(instance, tableIndex, signedIndex, encValue);</span>
<span class="line-added">669 }</span>
<span class="line-added">670 </span>
<span class="line-added">671 int32_t JIT_OPERATION operationWasmTableGrow(Instance* instance, unsigned tableIndex, EncodedJSValue fill, int32_t delta)</span>
<span class="line-added">672 {</span>
<span class="line-added">673     ASSERT(tableIndex &lt; instance-&gt;module().moduleInformation().tableCount());</span>
<span class="line-added">674     auto oldSize = instance-&gt;table(tableIndex)-&gt;length();</span>
<span class="line-added">675     if (delta &lt; 0)</span>
<span class="line-added">676         return oldSize;</span>
<span class="line-added">677     auto newSize = instance-&gt;table(tableIndex)-&gt;grow(delta);</span>
<span class="line-added">678     if (!newSize || *newSize == oldSize)</span>
<span class="line-added">679         return -1;</span>
<span class="line-added">680 </span>
<span class="line-added">681     for (unsigned i = oldSize; i &lt; instance-&gt;table(tableIndex)-&gt;length(); ++i)</span>
<span class="line-added">682         setWasmTableElement(instance, tableIndex, i, fill);</span>
<span class="line-added">683 </span>
<span class="line-added">684     return oldSize;</span>
<span class="line-added">685 }</span>
<span class="line-added">686 </span>
<span class="line-added">687 bool JIT_OPERATION operationWasmTableFill(Instance* instance, unsigned tableIndex, int32_t unsafeOffset, EncodedJSValue fill, int32_t unsafeCount)</span>
<span class="line-added">688 {</span>
<span class="line-added">689     ASSERT(tableIndex &lt; instance-&gt;module().moduleInformation().tableCount());</span>
<span class="line-added">690     if (unsafeOffset &lt; 0 || unsafeCount &lt; 0)</span>
<span class="line-added">691         return false;</span>
<span class="line-added">692 </span>
<span class="line-added">693     unsigned offset = unsafeOffset;</span>
<span class="line-added">694     unsigned count = unsafeCount;</span>
<span class="line-added">695 </span>
<span class="line-added">696     if (offset &gt;= instance-&gt;table(tableIndex)-&gt;length() || offset + count &gt; instance-&gt;table(tableIndex)-&gt;length())</span>
<span class="line-added">697         return false;</span>
<span class="line-added">698 </span>
<span class="line-added">699     for (unsigned j = 0; j &lt; count; ++j)</span>
<span class="line-added">700         setWasmTableElement(instance, tableIndex, offset + j, fill);</span>
<span class="line-added">701 </span>
<span class="line-added">702     return true;</span>
<span class="line-added">703 }</span>
<span class="line-added">704 </span>
<span class="line-added">705 EncodedJSValue JIT_OPERATION operationWasmRefFunc(Instance* instance, uint32_t index)</span>
<span class="line-added">706 {</span>
<span class="line-added">707     JSValue value = instance-&gt;getFunctionWrapper(index);</span>
<span class="line-added">708     ASSERT(value.isFunction(instance-&gt;owner&lt;JSObject&gt;()-&gt;vm()));</span>
<span class="line-added">709     return JSValue::encode(value);</span>
<span class="line-added">710 }</span>
<span class="line-added">711 </span>
<span class="line-added">712 int32_t JIT_OPERATION operationGetWasmTableSize(Instance* instance, unsigned tableIndex)</span>
<span class="line-added">713 {</span>
<span class="line-added">714     return instance-&gt;table(tableIndex)-&gt;length();</span>
<span class="line-added">715 }</span>
<span class="line-added">716 </span>
<span class="line-added">717 void* JIT_OPERATION operationWasmToJSException(CallFrame* callFrame, Wasm::ExceptionType type, Instance* wasmInstance)</span>
<span class="line-added">718 {</span>
<span class="line-added">719     wasmInstance-&gt;storeTopCallFrame(callFrame);</span>
<span class="line-added">720     JSWebAssemblyInstance* instance = wasmInstance-&gt;owner&lt;JSWebAssemblyInstance&gt;();</span>
<span class="line-added">721     JSGlobalObject* globalObject = instance-&gt;globalObject();</span>
<span class="line-added">722 </span>
<span class="line-added">723     // Do not retrieve VM&amp; from CallFrame since CallFrame&#39;s callee is not a JSCell.</span>
<span class="line-added">724     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">725 </span>
<span class="line-added">726     {</span>
<span class="line-added">727         auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">728 </span>
<span class="line-added">729         JSObject* error;</span>
<span class="line-added">730         if (type == ExceptionType::StackOverflow)</span>
<span class="line-added">731             error = createStackOverflowError(globalObject);</span>
<span class="line-added">732         else</span>
<span class="line-added">733             error = JSWebAssemblyRuntimeError::create(globalObject, vm, globalObject-&gt;webAssemblyRuntimeErrorStructure(), Wasm::errorMessageForExceptionType(type));</span>
<span class="line-added">734         throwException(globalObject, throwScope, error);</span>
<span class="line-added">735     }</span>
<span class="line-added">736 </span>
<span class="line-added">737     genericUnwind(vm, callFrame);</span>
<span class="line-added">738     ASSERT(!!vm.callFrameForCatch);</span>
<span class="line-added">739     ASSERT(!!vm.targetMachinePCForThrow);</span>
<span class="line-added">740     // FIXME: We could make this better:</span>
<span class="line-added">741     // This is a total hack, but the llint (both op_catch and handleUncaughtException)</span>
<span class="line-added">742     // require a cell in the callee field to load the VM. (The baseline JIT does not require</span>
<span class="line-added">743     // this since it is compiled with a constant VM pointer.) We could make the calling convention</span>
<span class="line-added">744     // for exceptions first load callFrameForCatch info call frame register before jumping</span>
<span class="line-added">745     // to the exception handler. If we did this, we could remove this terrible hack.</span>
<span class="line-added">746     // https://bugs.webkit.org/show_bug.cgi?id=170440</span>
<span class="line-added">747     bitwise_cast&lt;uint64_t*&gt;(callFrame)[static_cast&lt;int&gt;(CallFrameSlot::callee)] = bitwise_cast&lt;uint64_t&gt;(instance-&gt;module());</span>
<span class="line-added">748     return vm.targetMachinePCForThrow;</span>
<span class="line-added">749 }</span>
<span class="line-added">750 </span>
751 } } // namespace JSC::Wasm
752 
<span class="line-added">753 IGNORE_WARNINGS_END</span>
<span class="line-added">754 </span>
755 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
</tr>
</table>
<center><a href="WasmOpcodeOrigin.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmOperations.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
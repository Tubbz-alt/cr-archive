<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Lexer.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Lexer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ModuleAnalyzer.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Lexer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,14 ***</span>
  #include &lt;wtf/ASCIICType.h&gt;
  #include &lt;wtf/Vector.h&gt;
  
  namespace JSC {
  
<span class="line-modified">! enum LexerFlags {</span>
<span class="line-modified">!     LexerFlagsIgnoreReservedWords = 1,</span>
<span class="line-modified">!     LexerFlagsDontBuildStrings = 2,</span>
<span class="line-modified">!     LexexFlagsDontBuildKeywords = 4</span>
  };
  
  enum class LexerEscapeParseMode { Template, String };
  
  struct ParsedUnicodeEscapeValue;
<span class="line-new-header">--- 30,14 ---</span>
  #include &lt;wtf/ASCIICType.h&gt;
  #include &lt;wtf/Vector.h&gt;
  
  namespace JSC {
  
<span class="line-modified">! enum class LexerFlags : uint8_t {</span>
<span class="line-modified">!     IgnoreReservedWords = 1 &lt;&lt; 0,</span>
<span class="line-modified">!     DontBuildStrings = 1 &lt;&lt; 1,</span>
<span class="line-modified">!     DontBuildKeywords = 1 &lt;&lt; 2</span>
  };
  
  enum class LexerEscapeParseMode { Template, String };
  
  struct ParsedUnicodeEscapeValue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,12 ***</span>
      // Functions to set up parsing.
      void setCode(const SourceCode&amp;, ParserArena*);
      void setIsReparsingFunction() { m_isReparsingFunction = true; }
      bool isReparsingFunction() const { return m_isReparsingFunction; }
  
<span class="line-modified">!     JSTokenType lex(JSToken*, unsigned, bool strictMode);</span>
<span class="line-modified">!     JSTokenType lexWithoutClearingLineTerminator(JSToken*, unsigned, bool strictMode);</span>
      bool nextTokenIsColon();
      int lineNumber() const { return m_lineNumber; }
      ALWAYS_INLINE int currentOffset() const { return offsetFromSourcePtr(m_code); }
      ALWAYS_INLINE int currentLineStartOffset() const { return offsetFromSourcePtr(m_lineStart); }
      ALWAYS_INLINE JSTextPosition currentPosition() const
<span class="line-new-header">--- 62,12 ---</span>
      // Functions to set up parsing.
      void setCode(const SourceCode&amp;, ParserArena*);
      void setIsReparsingFunction() { m_isReparsingFunction = true; }
      bool isReparsingFunction() const { return m_isReparsingFunction; }
  
<span class="line-modified">!     JSTokenType lex(JSToken*, OptionSet&lt;LexerFlags&gt;, bool strictMode);</span>
<span class="line-modified">!     JSTokenType lexWithoutClearingLineTerminator(JSToken*, OptionSet&lt;LexerFlags&gt;, bool strictMode);</span>
      bool nextTokenIsColon();
      int lineNumber() const { return m_lineNumber; }
      ALWAYS_INLINE int currentOffset() const { return offsetFromSourcePtr(m_code); }
      ALWAYS_INLINE int currentLineStartOffset() const { return offsetFromSourcePtr(m_lineStart); }
      ALWAYS_INLINE JSTextPosition currentPosition() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 107,18 ***</span>
          else
              m_current = 0;
      }
      void setLineNumber(int line)
      {
          m_lineNumber = line;
      }
      void setHasLineTerminatorBeforeToken(bool terminator)
      {
          m_hasLineTerminatorBeforeToken = terminator;
      }
  
<span class="line-modified">!     JSTokenType lexExpectIdentifier(JSToken*, unsigned, bool strictMode);</span>
  
      ALWAYS_INLINE StringView getToken(const JSToken&amp; token)
      {
          SourceProvider* sourceProvider = m_source-&gt;provider();
          ASSERT_WITH_MESSAGE(token.m_location.startOffset &lt;= token.m_location.endOffset, &quot;Calling this function with the baked token.&quot;);
<span class="line-new-header">--- 107,19 ---</span>
          else
              m_current = 0;
      }
      void setLineNumber(int line)
      {
<span class="line-added">+         ASSERT(line &gt;= 0);</span>
          m_lineNumber = line;
      }
      void setHasLineTerminatorBeforeToken(bool terminator)
      {
          m_hasLineTerminatorBeforeToken = terminator;
      }
  
<span class="line-modified">!     JSTokenType lexExpectIdentifier(JSToken*, OptionSet&lt;LexerFlags&gt;, bool strictMode);</span>
  
      ALWAYS_INLINE StringView getToken(const JSToken&amp; token)
      {
          SourceProvider* sourceProvider = m_source-&gt;provider();
          ASSERT_WITH_MESSAGE(token.m_location.startOffset &lt;= token.m_location.endOffset, &quot;Calling this function with the baked token.&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 162,12 ***</span>
  
      ALWAYS_INLINE void skipWhitespace();
  
      template &lt;int shiftAmount&gt; void internalShift();
      template &lt;bool shouldCreateIdentifier&gt; ALWAYS_INLINE JSTokenType parseKeyword(JSTokenData*);
<span class="line-modified">!     template &lt;bool shouldBuildIdentifiers&gt; ALWAYS_INLINE JSTokenType parseIdentifier(JSTokenData*, unsigned lexerFlags, bool strictMode);</span>
<span class="line-modified">!     template &lt;bool shouldBuildIdentifiers&gt; NEVER_INLINE JSTokenType parseIdentifierSlowCase(JSTokenData*, unsigned lexerFlags, bool strictMode);</span>
      enum StringParseResult {
          StringParsedSuccessfully,
          StringUnterminated,
          StringCannotBeParsed
      };
<span class="line-new-header">--- 163,12 ---</span>
  
      ALWAYS_INLINE void skipWhitespace();
  
      template &lt;int shiftAmount&gt; void internalShift();
      template &lt;bool shouldCreateIdentifier&gt; ALWAYS_INLINE JSTokenType parseKeyword(JSTokenData*);
<span class="line-modified">!     template &lt;bool shouldBuildIdentifiers&gt; ALWAYS_INLINE JSTokenType parseIdentifier(JSTokenData*, OptionSet&lt;LexerFlags&gt;, bool strictMode);</span>
<span class="line-modified">!     template &lt;bool shouldBuildIdentifiers&gt; NEVER_INLINE JSTokenType parseIdentifierSlowCase(JSTokenData*, OptionSet&lt;LexerFlags&gt;, bool strictMode);</span>
      enum StringParseResult {
          StringParsedSuccessfully,
          StringUnterminated,
          StringCannotBeParsed
      };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 193,11 ***</span>
      template &lt;unsigned length&gt;
      ALWAYS_INLINE bool consume(const char (&amp;input)[length]);
  
      void fillTokenInfo(JSToken*, JSTokenType, int lineNumber, int endOffset, int lineStartOffset, JSTextPosition endPosition);
  
<span class="line-modified">!     static const size_t initialReadBufferCapacity = 32;</span>
  
      int m_lineNumber;
      int m_lastLineNumber;
  
      Vector&lt;LChar&gt; m_buffer8;
<span class="line-new-header">--- 194,11 ---</span>
      template &lt;unsigned length&gt;
      ALWAYS_INLINE bool consume(const char (&amp;input)[length]);
  
      void fillTokenInfo(JSToken*, JSTokenType, int lineNumber, int endOffset, int lineStartOffset, JSTextPosition endPosition);
  
<span class="line-modified">!     static constexpr size_t initialReadBufferCapacity = 32;</span>
  
      int m_lineNumber;
      int m_lastLineNumber;
  
      Vector&lt;LChar&gt; m_buffer8;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 331,22 ***</span>
  ALWAYS_INLINE const Identifier* Lexer&lt;T&gt;::makeLCharIdentifier(const UChar* characters, size_t length)
  {
      return &amp;m_arena-&gt;makeIdentifierLCharFromUChar(m_vm, characters, length);
  }
  
<span class="line-modified">! #if ASSERT_DISABLED</span>
<span class="line-removed">- ALWAYS_INLINE bool isSafeBuiltinIdentifier(VM&amp;, const Identifier*) { return true; }</span>
<span class="line-removed">- #else</span>
  bool isSafeBuiltinIdentifier(VM&amp;, const Identifier*);
<span class="line-modified">! #endif</span>
  
  template &lt;typename T&gt;
<span class="line-modified">! ALWAYS_INLINE JSTokenType Lexer&lt;T&gt;::lexExpectIdentifier(JSToken* tokenRecord, unsigned lexerFlags, bool strictMode)</span>
  {
      JSTokenData* tokenData = &amp;tokenRecord-&gt;m_data;
      JSTokenLocation* tokenLocation = &amp;tokenRecord-&gt;m_location;
<span class="line-modified">!     ASSERT((lexerFlags &amp; LexerFlagsIgnoreReservedWords));</span>
      const T* start = m_code;
      const T* ptr = start;
      const T* end = m_codeEnd;
      JSTextPosition startPosition = currentPosition();
      if (ptr &gt;= end) {
<span class="line-new-header">--- 332,22 ---</span>
  ALWAYS_INLINE const Identifier* Lexer&lt;T&gt;::makeLCharIdentifier(const UChar* characters, size_t length)
  {
      return &amp;m_arena-&gt;makeIdentifierLCharFromUChar(m_vm, characters, length);
  }
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
  bool isSafeBuiltinIdentifier(VM&amp;, const Identifier*);
<span class="line-modified">! #else</span>
<span class="line-added">+ ALWAYS_INLINE bool isSafeBuiltinIdentifier(VM&amp;, const Identifier*) { return true; }</span>
<span class="line-added">+ #endif // ASSERT_ENABLED</span>
  
  template &lt;typename T&gt;
<span class="line-modified">! ALWAYS_INLINE JSTokenType Lexer&lt;T&gt;::lexExpectIdentifier(JSToken* tokenRecord, OptionSet&lt;LexerFlags&gt; lexerFlags, bool strictMode)</span>
  {
      JSTokenData* tokenData = &amp;tokenRecord-&gt;m_data;
      JSTokenLocation* tokenLocation = &amp;tokenRecord-&gt;m_location;
<span class="line-modified">!     ASSERT(lexerFlags.contains(LexerFlags::IgnoreReservedWords));</span>
      const T* start = m_code;
      const T* ptr = start;
      const T* end = m_codeEnd;
      JSTextPosition startPosition = currentPosition();
      if (ptr &gt;= end) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 372,12 ***</span>
  
      m_code = ptr;
      ASSERT(currentOffset() &gt;= currentLineStartOffset());
  
      // Create the identifier if needed
<span class="line-modified">!     if (lexerFlags &amp; LexexFlagsDontBuildKeywords</span>
<span class="line-modified">! #if !ASSERT_DISABLED</span>
          &amp;&amp; !m_parsingBuiltinFunction
  #endif
          )
          tokenData-&gt;ident = 0;
      else
<span class="line-new-header">--- 373,12 ---</span>
  
      m_code = ptr;
      ASSERT(currentOffset() &gt;= currentLineStartOffset());
  
      // Create the identifier if needed
<span class="line-modified">!     if (lexerFlags.contains(LexerFlags::DontBuildKeywords)</span>
<span class="line-modified">! #if ASSERT_ENABLED</span>
          &amp;&amp; !m_parsingBuiltinFunction
  #endif
          )
          tokenData-&gt;ident = 0;
      else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 388,11 ***</span>
      tokenLocation-&gt;startOffset = offsetFromSourcePtr(start);
      tokenLocation-&gt;endOffset = currentOffset();
      ASSERT(tokenLocation-&gt;startOffset &gt;= tokenLocation-&gt;lineStartOffset);
      tokenRecord-&gt;m_startPosition = startPosition;
      tokenRecord-&gt;m_endPosition = currentPosition();
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      if (m_parsingBuiltinFunction) {
          if (!isSafeBuiltinIdentifier(m_vm, tokenData-&gt;ident))
              return ERRORTOK;
      }
  #endif
<span class="line-new-header">--- 389,11 ---</span>
      tokenLocation-&gt;startOffset = offsetFromSourcePtr(start);
      tokenLocation-&gt;endOffset = currentOffset();
      ASSERT(tokenLocation-&gt;startOffset &gt;= tokenLocation-&gt;lineStartOffset);
      tokenRecord-&gt;m_startPosition = startPosition;
      tokenRecord-&gt;m_endPosition = currentPosition();
<span class="line-modified">! #if ASSERT_ENABLED</span>
      if (m_parsingBuiltinFunction) {
          if (!isSafeBuiltinIdentifier(m_vm, tokenData-&gt;ident))
              return ERRORTOK;
      }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 403,11 ***</span>
  slowCase:
      return lex(tokenRecord, lexerFlags, strictMode);
  }
  
  template &lt;typename T&gt;
<span class="line-modified">! ALWAYS_INLINE JSTokenType Lexer&lt;T&gt;::lex(JSToken* tokenRecord, unsigned lexerFlags, bool strictMode)</span>
  {
      m_hasLineTerminatorBeforeToken = false;
      return lexWithoutClearingLineTerminator(tokenRecord, lexerFlags, strictMode);
  }
  
<span class="line-new-header">--- 404,11 ---</span>
  slowCase:
      return lex(tokenRecord, lexerFlags, strictMode);
  }
  
  template &lt;typename T&gt;
<span class="line-modified">! ALWAYS_INLINE JSTokenType Lexer&lt;T&gt;::lex(JSToken* tokenRecord, OptionSet&lt;LexerFlags&gt; lexerFlags, bool strictMode)</span>
  {
      m_hasLineTerminatorBeforeToken = false;
      return lexWithoutClearingLineTerminator(tokenRecord, lexerFlags, strictMode);
  }
  
</pre>
<center><a href="Lexer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ModuleAnalyzer.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
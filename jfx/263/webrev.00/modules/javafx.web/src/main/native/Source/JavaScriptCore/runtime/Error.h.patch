diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Error.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Error.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Error.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Error.h
@@ -31,74 +31,71 @@
 #include <stdint.h>
 
 
 namespace JSC {
 
-class ExecState;
+class CallFrame;
 class VM;
 class JSGlobalObject;
 class JSObject;
 class SourceCode;
 class Structure;
 
-// ExecState wrappers.
-JSObject* createError(ExecState*, const String&, ErrorInstance::SourceAppender);
-JSObject* createEvalError(ExecState*, const String&, ErrorInstance::SourceAppender);
-JSObject* createRangeError(ExecState*, const String&, ErrorInstance::SourceAppender);
-JSObject* createRangeError(ExecState*, JSGlobalObject*, const String&, ErrorInstance::SourceAppender);
-JSObject* createReferenceError(ExecState*, const String&, ErrorInstance::SourceAppender);
-JSObject* createSyntaxError(ExecState*, const String&, ErrorInstance::SourceAppender);
-JSObject* createTypeError(ExecState*, const String&, ErrorInstance::SourceAppender, RuntimeType);
-JSObject* createNotEnoughArgumentsError(ExecState*, ErrorInstance::SourceAppender);
-JSObject* createURIError(ExecState*, const String&, ErrorInstance::SourceAppender);
-
-
-JS_EXPORT_PRIVATE JSObject* createError(ExecState*, const String&);
-JS_EXPORT_PRIVATE JSObject* createEvalError(ExecState*, const String&);
-JS_EXPORT_PRIVATE JSObject* createRangeError(ExecState*, const String&);
-JS_EXPORT_PRIVATE JSObject* createRangeError(ExecState*, JSGlobalObject*, const String&);
-JS_EXPORT_PRIVATE JSObject* createReferenceError(ExecState*, const String&);
-JS_EXPORT_PRIVATE JSObject* createSyntaxError(ExecState*, const String&);
-JS_EXPORT_PRIVATE JSObject* createTypeError(ExecState*);
-JS_EXPORT_PRIVATE JSObject* createTypeError(ExecState*, const String&);
-JS_EXPORT_PRIVATE JSObject* createNotEnoughArgumentsError(ExecState*);
-JS_EXPORT_PRIVATE JSObject* createURIError(ExecState*, const String&);
-JS_EXPORT_PRIVATE JSObject* createOutOfMemoryError(ExecState*);
-JS_EXPORT_PRIVATE JSObject* createOutOfMemoryError(ExecState*, const String&);
-
-JS_EXPORT_PRIVATE JSObject* createError(ExecState*, ErrorType, const String&);
-
-JSObject* createGetterTypeError(ExecState*, const String&);
-
-std::unique_ptr<Vector<StackFrame>> getStackTrace(ExecState*, VM&, JSObject*, bool useCurrentFrame);
-void getBytecodeOffset(ExecState*, VM&, Vector<StackFrame>*, CallFrame*&, unsigned& bytecodeOffset);
+JSObject* createError(JSGlobalObject*, const String&, ErrorInstance::SourceAppender);
+JSObject* createEvalError(JSGlobalObject*, const String&, ErrorInstance::SourceAppender);
+JSObject* createRangeError(JSGlobalObject*, const String&, ErrorInstance::SourceAppender);
+JSObject* createReferenceError(JSGlobalObject*, const String&, ErrorInstance::SourceAppender);
+JSObject* createSyntaxError(JSGlobalObject*, const String&, ErrorInstance::SourceAppender);
+JSObject* createTypeError(JSGlobalObject*, const String&, ErrorInstance::SourceAppender, RuntimeType);
+JSObject* createNotEnoughArgumentsError(JSGlobalObject*, ErrorInstance::SourceAppender);
+JSObject* createURIError(JSGlobalObject*, const String&, ErrorInstance::SourceAppender);
+
+
+JS_EXPORT_PRIVATE JSObject* createError(JSGlobalObject*, const String&);
+JS_EXPORT_PRIVATE JSObject* createEvalError(JSGlobalObject*, const String&);
+JS_EXPORT_PRIVATE JSObject* createRangeError(JSGlobalObject*, const String&);
+JS_EXPORT_PRIVATE JSObject* createReferenceError(JSGlobalObject*, const String&);
+JS_EXPORT_PRIVATE JSObject* createSyntaxError(JSGlobalObject*, const String&);
+JS_EXPORT_PRIVATE JSObject* createTypeError(JSGlobalObject*);
+JS_EXPORT_PRIVATE JSObject* createTypeError(JSGlobalObject*, const String&);
+JS_EXPORT_PRIVATE JSObject* createNotEnoughArgumentsError(JSGlobalObject*);
+JS_EXPORT_PRIVATE JSObject* createURIError(JSGlobalObject*, const String&);
+JS_EXPORT_PRIVATE JSObject* createOutOfMemoryError(JSGlobalObject*);
+JS_EXPORT_PRIVATE JSObject* createOutOfMemoryError(JSGlobalObject*, const String&);
+
+JS_EXPORT_PRIVATE JSObject* createError(JSGlobalObject*, ErrorType, const String&);
+
+JSObject* createGetterTypeError(JSGlobalObject*, const String&);
+
+std::unique_ptr<Vector<StackFrame>> getStackTrace(JSGlobalObject*, VM&, JSObject*, bool useCurrentFrame);
+void getBytecodeIndex(VM&, CallFrame*, Vector<StackFrame>*, CallFrame*&, BytecodeIndex&);
 bool getLineColumnAndSource(Vector<StackFrame>* stackTrace, unsigned& line, unsigned& column, String& sourceURL);
 bool addErrorInfo(VM&, Vector<StackFrame>*, JSObject*);
-JS_EXPORT_PRIVATE void addErrorInfo(ExecState*, JSObject*, bool);
-JSObject* addErrorInfo(ExecState*, JSObject* error, int line, const SourceCode&);
+JS_EXPORT_PRIVATE void addErrorInfo(JSGlobalObject*, JSObject*, bool);
+JSObject* addErrorInfo(VM&, JSObject* error, int line, const SourceCode&);
 
 // Methods to throw Errors.
 
 // Convenience wrappers, create an throw an exception with a default message.
-JS_EXPORT_PRIVATE Exception* throwConstructorCannotBeCalledAsFunctionTypeError(ExecState*, ThrowScope&, const char* constructorName);
-JS_EXPORT_PRIVATE Exception* throwTypeError(ExecState*, ThrowScope&);
-JS_EXPORT_PRIVATE Exception* throwTypeError(ExecState*, ThrowScope&, ASCIILiteral errorMessage);
-JS_EXPORT_PRIVATE Exception* throwTypeError(ExecState*, ThrowScope&, const String& errorMessage);
-JS_EXPORT_PRIVATE Exception* throwSyntaxError(ExecState*, ThrowScope&);
-JS_EXPORT_PRIVATE Exception* throwSyntaxError(ExecState*, ThrowScope&, const String& errorMessage);
-inline Exception* throwRangeError(ExecState* state, ThrowScope& scope, const String& errorMessage) { return throwException(state, scope, createRangeError(state, errorMessage)); }
+JS_EXPORT_PRIVATE Exception* throwConstructorCannotBeCalledAsFunctionTypeError(JSGlobalObject*, ThrowScope&, const char* constructorName);
+JS_EXPORT_PRIVATE Exception* throwTypeError(JSGlobalObject*, ThrowScope&);
+JS_EXPORT_PRIVATE Exception* throwTypeError(JSGlobalObject*, ThrowScope&, ASCIILiteral errorMessage);
+JS_EXPORT_PRIVATE Exception* throwTypeError(JSGlobalObject*, ThrowScope&, const String& errorMessage);
+JS_EXPORT_PRIVATE Exception* throwSyntaxError(JSGlobalObject*, ThrowScope&);
+JS_EXPORT_PRIVATE Exception* throwSyntaxError(JSGlobalObject*, ThrowScope&, const String& errorMessage);
+inline Exception* throwRangeError(JSGlobalObject* globalObject, ThrowScope& scope, const String& errorMessage) { return throwException(globalObject, scope, createRangeError(globalObject, errorMessage)); }
 
-JS_EXPORT_PRIVATE Exception* throwGetterTypeError(ExecState*, ThrowScope&, const String& errorMessage);
-JS_EXPORT_PRIVATE JSValue throwDOMAttributeGetterTypeError(ExecState*, ThrowScope&, const ClassInfo*, PropertyName);
+JS_EXPORT_PRIVATE Exception* throwGetterTypeError(JSGlobalObject*, ThrowScope&, const String& errorMessage);
+JS_EXPORT_PRIVATE JSValue throwDOMAttributeGetterTypeError(JSGlobalObject*, ThrowScope&, const ClassInfo*, PropertyName);
 
 // Convenience wrappers, wrap result as an EncodedJSValue.
-inline void throwVMError(ExecState* exec, ThrowScope& scope, Exception* exception) { throwException(exec, scope, exception); }
-inline EncodedJSValue throwVMError(ExecState* exec, ThrowScope& scope, JSValue error) { return JSValue::encode(throwException(exec, scope, error)); }
-inline EncodedJSValue throwVMError(ExecState* exec, ThrowScope& scope, const char* errorMessage) { return JSValue::encode(throwException(exec, scope, createError(exec, errorMessage))); }
-inline EncodedJSValue throwVMTypeError(ExecState* exec, ThrowScope& scope) { return JSValue::encode(throwTypeError(exec, scope)); }
-inline EncodedJSValue throwVMTypeError(ExecState* exec, ThrowScope& scope, ASCIILiteral errorMessage) { return JSValue::encode(throwTypeError(exec, scope, errorMessage)); }
-inline EncodedJSValue throwVMTypeError(ExecState* exec, ThrowScope& scope, const String& errorMessage) { return JSValue::encode(throwTypeError(exec, scope, errorMessage)); }
-inline EncodedJSValue throwVMRangeError(ExecState* state, ThrowScope& scope, const String& errorMessage) { return JSValue::encode(throwRangeError(state, scope, errorMessage)); }
-inline EncodedJSValue throwVMGetterTypeError(ExecState* exec, ThrowScope& scope, const String& errorMessage) { return JSValue::encode(throwGetterTypeError(exec, scope, errorMessage)); }
-inline EncodedJSValue throwVMDOMAttributeGetterTypeError(ExecState* state, ThrowScope& scope, const ClassInfo* classInfo, PropertyName propertyName) { return JSValue::encode(throwDOMAttributeGetterTypeError(state, scope, classInfo, propertyName)); }
+inline void throwVMError(JSGlobalObject* globalObject, ThrowScope& scope, Exception* exception) { throwException(globalObject, scope, exception); }
+inline EncodedJSValue throwVMError(JSGlobalObject* globalObject, ThrowScope& scope, JSValue error) { return JSValue::encode(throwException(globalObject, scope, error)); }
+inline EncodedJSValue throwVMError(JSGlobalObject* globalObject, ThrowScope& scope, const char* errorMessage) { return JSValue::encode(throwException(globalObject, scope, createError(globalObject, errorMessage))); }
+inline EncodedJSValue throwVMTypeError(JSGlobalObject* globalObject, ThrowScope& scope) { return JSValue::encode(throwTypeError(globalObject, scope)); }
+inline EncodedJSValue throwVMTypeError(JSGlobalObject* globalObject, ThrowScope& scope, ASCIILiteral errorMessage) { return JSValue::encode(throwTypeError(globalObject, scope, errorMessage)); }
+inline EncodedJSValue throwVMTypeError(JSGlobalObject* globalObject, ThrowScope& scope, const String& errorMessage) { return JSValue::encode(throwTypeError(globalObject, scope, errorMessage)); }
+inline EncodedJSValue throwVMRangeError(JSGlobalObject* globalObject, ThrowScope& scope, const String& errorMessage) { return JSValue::encode(throwRangeError(globalObject, scope, errorMessage)); }
+inline EncodedJSValue throwVMGetterTypeError(JSGlobalObject* globalObject, ThrowScope& scope, const String& errorMessage) { return JSValue::encode(throwGetterTypeError(globalObject, scope, errorMessage)); }
+inline EncodedJSValue throwVMDOMAttributeGetterTypeError(JSGlobalObject* globalObject, ThrowScope& scope, const ClassInfo* classInfo, PropertyName propertyName) { return JSValue::encode(throwDOMAttributeGetterTypeError(globalObject, scope, classInfo, propertyName)); }
 
 } // namespace JSC

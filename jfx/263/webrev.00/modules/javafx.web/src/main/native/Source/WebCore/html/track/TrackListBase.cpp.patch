diff a/modules/javafx.web/src/main/native/Source/WebCore/html/track/TrackListBase.cpp b/modules/javafx.web/src/main/native/Source/WebCore/html/track/TrackListBase.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/track/TrackListBase.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/track/TrackListBase.cpp
@@ -37,17 +37,16 @@
 
 namespace WebCore {
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(TrackListBase);
 
-TrackListBase::TrackListBase(HTMLMediaElement* element, ScriptExecutionContext* context)
-    : ActiveDOMObject(context)
+TrackListBase::TrackListBase(WeakPtr<HTMLMediaElement> element, ScriptExecutionContext* context)
+    : ContextDestructionObserver(context)
     , m_element(element)
-    , m_asyncEventQueue(*this)
+    , m_asyncEventQueue(MainThreadGenericEventQueue::create(*this))
 {
     ASSERT(!context || is<Document>(context));
-    suspendIfNeeded();
 }
 
 TrackListBase::~TrackListBase()
 {
     clearElement();
@@ -62,11 +61,11 @@
     }
 }
 
 Element* TrackListBase::element() const
 {
-    return m_element;
+    return m_element.get();
 }
 
 unsigned TrackListBase::length() const
 {
     return m_inbandTracks.size();
@@ -96,11 +95,11 @@
     return m_inbandTracks.find(&track) != notFound;
 }
 
 void TrackListBase::scheduleTrackEvent(const AtomString& eventName, Ref<TrackBase>&& track)
 {
-    m_asyncEventQueue.enqueueEvent(TrackEvent::create(eventName, Event::CanBubble::No, Event::IsCancelable::No, WTFMove(track)));
+    m_asyncEventQueue->enqueueEvent(TrackEvent::create(eventName, Event::CanBubble::No, Event::IsCancelable::No, WTFMove(track)));
 }
 
 void TrackListBase::scheduleAddTrackEvent(Ref<TrackBase>&& track)
 {
     // 4.8.10.5 Loading the media resource
@@ -159,16 +158,16 @@
     // AudioTrackList object.
     // ...
     // Whenever a track in a VideoTrackList that was previously not selected is
     // selected, the user agent must queue a task to fire a simple event named
     // change at the VideoTrackList object.
-    m_asyncEventQueue.enqueueEvent(Event::create(eventNames().changeEvent, Event::CanBubble::No, Event::IsCancelable::No));
+    m_asyncEventQueue->enqueueEvent(Event::create(eventNames().changeEvent, Event::CanBubble::No, Event::IsCancelable::No));
 }
 
 bool TrackListBase::isChangeEventScheduled() const
 {
-    return m_asyncEventQueue.hasPendingEventsOfType(eventNames().changeEvent);
+    return m_asyncEventQueue->hasPendingEventsOfType(eventNames().changeEvent);
 }
 
 bool TrackListBase::isAnyTrackEnabled() const
 {
     for (auto& track : m_inbandTracks) {
@@ -176,37 +175,8 @@
             return true;
     }
     return false;
 }
 
-bool TrackListBase::canSuspendForDocumentSuspension() const
-{
-    return !m_asyncEventQueue.hasPendingEvents();
-}
-
-void TrackListBase::suspend(ReasonForSuspension reason)
-{
-    switch (reason) {
-    case ReasonForSuspension::PageCache:
-    case ReasonForSuspension::PageWillBeSuspended:
-        m_asyncEventQueue.suspend();
-        break;
-    case ReasonForSuspension::JavaScriptDebuggerPaused:
-    case ReasonForSuspension::WillDeferLoading:
-        // Do nothing, we don't pause media playback in these cases.
-        break;
-    }
-}
-
-void TrackListBase::resume()
-{
-    m_asyncEventQueue.resume();
-}
-
-void TrackListBase::stop()
-{
-    m_asyncEventQueue.close();
-}
-
 } // namespace WebCore
 
 #endif

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmOMGForOSREntryPlan.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmModuleInformation.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmOMGForOSREntryPlan.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmOMGForOSREntryPlan.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 38,25 ***</span>
  #include &quot;WasmInstance.h&quot;
  #include &quot;WasmMachineThreads.h&quot;
  #include &quot;WasmMemory.h&quot;
  #include &quot;WasmNameSection.h&quot;
  #include &quot;WasmSignatureInlines.h&quot;
<span class="line-removed">- #include &quot;WasmValidate.h&quot;</span>
  #include &quot;WasmWorklist.h&quot;
  #include &lt;wtf/DataLog.h&gt;
  #include &lt;wtf/Locker.h&gt;
  #include &lt;wtf/MonotonicTime.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/ThreadMessage.h&gt;
  
  namespace JSC { namespace Wasm {
  
  namespace WasmOMGForOSREntryPlanInternal {
<span class="line-modified">! static const bool verbose = false;</span>
  }
  
<span class="line-modified">! OMGForOSREntryPlan::OMGForOSREntryPlan(Context* context, Ref&lt;Module&gt;&amp;&amp; module, Ref&lt;BBQCallee&gt;&amp;&amp; callee, uint32_t functionIndex, uint32_t loopIndex, MemoryMode mode, CompletionTask&amp;&amp; task)</span>
      : Base(context, makeRef(const_cast&lt;ModuleInformation&amp;&gt;(module-&gt;moduleInformation())), WTFMove(task))
      , m_module(WTFMove(module))
      , m_codeBlock(*m_module-&gt;codeBlockFor(mode))
      , m_callee(WTFMove(callee))
      , m_functionIndex(functionIndex)
<span class="line-new-header">--- 38,24 ---</span>
  #include &quot;WasmInstance.h&quot;
  #include &quot;WasmMachineThreads.h&quot;
  #include &quot;WasmMemory.h&quot;
  #include &quot;WasmNameSection.h&quot;
  #include &quot;WasmSignatureInlines.h&quot;
  #include &quot;WasmWorklist.h&quot;
  #include &lt;wtf/DataLog.h&gt;
  #include &lt;wtf/Locker.h&gt;
  #include &lt;wtf/MonotonicTime.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/ThreadMessage.h&gt;
  
  namespace JSC { namespace Wasm {
  
  namespace WasmOMGForOSREntryPlanInternal {
<span class="line-modified">! static constexpr bool verbose = false;</span>
  }
  
<span class="line-modified">! OMGForOSREntryPlan::OMGForOSREntryPlan(Context* context, Ref&lt;Module&gt;&amp;&amp; module, Ref&lt;Callee&gt;&amp;&amp; callee, uint32_t functionIndex, uint32_t loopIndex, MemoryMode mode, CompletionTask&amp;&amp; task)</span>
      : Base(context, makeRef(const_cast&lt;ModuleInformation&amp;&gt;(module-&gt;moduleInformation())), WTFMove(task))
      , m_module(WTFMove(module))
      , m_codeBlock(*m_module-&gt;codeBlockFor(mode))
      , m_callee(WTFMove(callee))
      , m_functionIndex(functionIndex)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,16 ***</span>
      const uint32_t functionIndexSpace = m_functionIndex + m_module-&gt;moduleInformation().importFunctionCount();
      ASSERT(functionIndexSpace &lt; m_module-&gt;moduleInformation().functionIndexSpaceSize());
  
      SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[m_functionIndex];
      const Signature&amp; signature = SignatureInformation::get(signatureIndex);
<span class="line-removed">-     ASSERT(validateFunction(function.data.data(), function.data.size(), signature, m_moduleInformation.get()));</span>
  
      Vector&lt;UnlinkedWasmToWasmCall&gt; unlinkedCalls;
      CompilationContext context;
      unsigned osrEntryScratchBufferSize = 0;
<span class="line-modified">!     auto parseAndCompileResult = parseAndCompile(context, function.data.data(), function.data.size(), signature, unlinkedCalls, osrEntryScratchBufferSize, m_moduleInformation.get(), m_mode, CompilationMode::OMGForOSREntryMode, m_functionIndex, m_loopIndex);</span>
  
      if (UNLIKELY(!parseAndCompileResult)) {
          fail(holdLock(m_lock), makeString(parseAndCompileResult.error(), &quot;when trying to tier up &quot;, String::number(m_functionIndex)));
          return;
      }
<span class="line-new-header">--- 76,15 ---</span>
      const uint32_t functionIndexSpace = m_functionIndex + m_module-&gt;moduleInformation().importFunctionCount();
      ASSERT(functionIndexSpace &lt; m_module-&gt;moduleInformation().functionIndexSpaceSize());
  
      SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[m_functionIndex];
      const Signature&amp; signature = SignatureInformation::get(signatureIndex);
  
      Vector&lt;UnlinkedWasmToWasmCall&gt; unlinkedCalls;
      CompilationContext context;
      unsigned osrEntryScratchBufferSize = 0;
<span class="line-modified">!     auto parseAndCompileResult = parseAndCompile(context, function, signature, unlinkedCalls, osrEntryScratchBufferSize, m_moduleInformation.get(), m_mode, CompilationMode::OMGForOSREntryMode, m_functionIndex, m_loopIndex);</span>
  
      if (UNLIKELY(!parseAndCompileResult)) {
          fail(holdLock(m_lock), makeString(parseAndCompileResult.error(), &quot;when trying to tier up &quot;, String::number(m_functionIndex)));
          return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 97,11 ***</span>
          Base::fail(holdLock(m_lock), makeString(&quot;Out of executable memory while tiering up function at index &quot;, String::number(m_functionIndex)));
          return;
      }
  
      omgEntrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(
<span class="line-modified">!         FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;WebAssembly OMGForOSREntry function[%i] %s name %s&quot;, m_functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
          WTFMove(context.wasmEntrypointByproducts));
  
      omgEntrypoint.calleeSaveRegisters = WTFMove(parseAndCompileResult.value()-&gt;entrypoint.calleeSaveRegisters);
  
      MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; entrypoint;
<span class="line-new-header">--- 95,11 ---</span>
          Base::fail(holdLock(m_lock), makeString(&quot;Out of executable memory while tiering up function at index &quot;, String::number(m_functionIndex)));
          return;
      }
  
      omgEntrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(
<span class="line-modified">!         FINALIZE_WASM_CODE_FOR_MODE(CompilationMode::OMGForOSREntryMode, linkBuffer, B3CompilationPtrTag, &quot;WebAssembly OMGForOSREntry function[%i] %s name %s&quot;, m_functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
          WTFMove(context.wasmEntrypointByproducts));
  
      omgEntrypoint.calleeSaveRegisters = WTFMove(parseAndCompileResult.value()-&gt;entrypoint.calleeSaveRegisters);
  
      MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; entrypoint;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 125,14 ***</span>
      resetInstructionCacheOnAllThreads();
      WTF::storeStoreFence();
      {
          auto locker = holdLock(m_codeBlock-&gt;m_lock);
          {
<span class="line-modified">!             auto locker = holdLock(m_callee-&gt;tierUpCount()-&gt;getLock());</span>
<span class="line-modified">!             m_callee-&gt;setOSREntryCallee(callee.copyRef());</span>
<span class="line-modified">!             m_callee-&gt;tierUpCount()-&gt;osrEntryTriggers()[m_loopIndex] = TierUpCount::TriggerReason::CompilationDone;</span>
<span class="line-modified">!             m_callee-&gt;tierUpCount()-&gt;m_compilationStatusForOMGForOSREntry = TierUpCount::CompilationStatus::Compiled;</span>
          }
          WTF::storeStoreFence();
          // It is possible that a new OMG callee is added while we release m_codeBlock-&gt;lock.
          // Until we add OMGForOSREntry callee to BBQCallee&#39;s m_osrEntryCallee, this new OMG function linking does not happen for this OMGForOSREntry callee.
          // We re-link this OMGForOSREntry callee again not to miss that chance.
<span class="line-new-header">--- 123,29 ---</span>
      resetInstructionCacheOnAllThreads();
      WTF::storeStoreFence();
      {
          auto locker = holdLock(m_codeBlock-&gt;m_lock);
          {
<span class="line-modified">!             switch (m_callee-&gt;compilationMode()) {</span>
<span class="line-modified">!             case CompilationMode::LLIntMode: {</span>
<span class="line-modified">!                 LLIntCallee* llintCallee = static_cast&lt;LLIntCallee*&gt;(m_callee.ptr());</span>
<span class="line-modified">!                 auto locker = holdLock(llintCallee-&gt;tierUpCounter().m_lock);</span>
<span class="line-added">+                 llintCallee-&gt;setOSREntryCallee(callee.copyRef());</span>
<span class="line-added">+                 llintCallee-&gt;tierUpCounter().m_loopCompilationStatus = LLIntTierUpCounter::CompilationStatus::Compiled;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             case CompilationMode::BBQMode: {</span>
<span class="line-added">+                 BBQCallee* bbqCallee = static_cast&lt;BBQCallee*&gt;(m_callee.ptr());</span>
<span class="line-added">+                 auto locker = holdLock(bbqCallee-&gt;tierUpCount()-&gt;getLock());</span>
<span class="line-added">+                 bbqCallee-&gt;setOSREntryCallee(callee.copyRef());</span>
<span class="line-added">+                 bbqCallee-&gt;tierUpCount()-&gt;osrEntryTriggers()[m_loopIndex] = TierUpCount::TriggerReason::CompilationDone;</span>
<span class="line-added">+                 bbqCallee-&gt;tierUpCount()-&gt;m_compilationStatusForOMGForOSREntry = TierUpCount::CompilationStatus::Compiled;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+             }</span>
          }
          WTF::storeStoreFence();
          // It is possible that a new OMG callee is added while we release m_codeBlock-&gt;lock.
          // Until we add OMGForOSREntry callee to BBQCallee&#39;s m_osrEntryCallee, this new OMG function linking does not happen for this OMGForOSREntry callee.
          // We re-link this OMGForOSREntry callee again not to miss that chance.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 144,11 ***</span>
                  entrypoint = m_codeBlock-&gt;wasmEntrypointCalleeFromFunctionIndexSpace(call.functionIndexSpace).entrypoint().retagged&lt;WasmEntryPtrTag&gt;();
  
              MacroAssembler::repatchNearCall(call.callLocation, CodeLocationLabel&lt;WasmEntryPtrTag&gt;(entrypoint));
          }
      }
<span class="line-modified">!     dataLogLnIf(WasmOMGForOSREntryPlanInternal::verbose, &quot;Finished OMGForOSREntry &quot;, m_functionIndex, &quot; with tier up count at: &quot;, m_callee-&gt;tierUpCount()-&gt;count());</span>
      complete(holdLock(m_lock));
  }
  
  } } // namespace JSC::Wasm
  
<span class="line-new-header">--- 157,11 ---</span>
                  entrypoint = m_codeBlock-&gt;wasmEntrypointCalleeFromFunctionIndexSpace(call.functionIndexSpace).entrypoint().retagged&lt;WasmEntryPtrTag&gt;();
  
              MacroAssembler::repatchNearCall(call.callLocation, CodeLocationLabel&lt;WasmEntryPtrTag&gt;(entrypoint));
          }
      }
<span class="line-modified">!     dataLogLnIf(WasmOMGForOSREntryPlanInternal::verbose, &quot;Finished OMGForOSREntry &quot;, m_functionIndex);</span>
      complete(holdLock(m_lock));
  }
  
  } } // namespace JSC::Wasm
  
</pre>
<center><a href="WasmModuleInformation.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmOMGForOSREntryPlan.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
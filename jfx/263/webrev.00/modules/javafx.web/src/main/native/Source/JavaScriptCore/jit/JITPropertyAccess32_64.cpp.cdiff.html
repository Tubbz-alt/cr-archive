<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITPropertyAccess32_64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITPropertyAccess.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITRightShiftGenerator.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITPropertyAccess32_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 48,219 ***</span>
  namespace JSC {
  
  void JIT::emit_op_put_getter_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterById&gt;();
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
      int property = bytecode.m_property;
      int options = bytecode.m_attributes;
<span class="line-modified">!     int getter = bytecode.m_accessor.offset();</span>
  
      emitLoadPayload(base, regT1);
      emitLoadPayload(getter, regT3);
<span class="line-modified">!     callOperation(operationPutGetterById, regT1, m_codeBlock-&gt;identifier(property).impl(), options, regT3);</span>
  }
  
  void JIT::emit_op_put_setter_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutSetterById&gt;();
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
      int property = bytecode.m_property;
      int options = bytecode.m_attributes;
<span class="line-modified">!     int setter = bytecode.m_accessor.offset();</span>
  
      emitLoadPayload(base, regT1);
      emitLoadPayload(setter, regT3);
<span class="line-modified">!     callOperation(operationPutSetterById, regT1, m_codeBlock-&gt;identifier(property).impl(), options, regT3);</span>
  }
  
  void JIT::emit_op_put_getter_setter_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterSetterById&gt;();
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
      int property = bytecode.m_property;
      int attributes = bytecode.m_attributes;
<span class="line-modified">!     int getter = bytecode.m_getter.offset();</span>
<span class="line-modified">!     int setter = bytecode.m_setter.offset();</span>
  
      emitLoadPayload(base, regT1);
      emitLoadPayload(getter, regT3);
      emitLoadPayload(setter, regT4);
<span class="line-modified">!     callOperation(operationPutGetterSetter, regT1, m_codeBlock-&gt;identifier(property).impl(), attributes, regT3, regT4);</span>
  }
  
  void JIT::emit_op_put_getter_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterByVal&gt;();
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int property = bytecode.m_property.offset();</span>
      int32_t attributes = bytecode.m_attributes;
<span class="line-modified">!     int getter = bytecode.m_accessor.offset();</span>
  
      emitLoadPayload(base, regT2);
      emitLoad(property, regT1, regT0);
      emitLoadPayload(getter, regT3);
<span class="line-modified">!     callOperation(operationPutGetterByVal, regT2, JSValueRegs(regT1, regT0), attributes, regT3);</span>
  }
  
  void JIT::emit_op_put_setter_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutSetterByVal&gt;();
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int property = bytecode.m_property.offset();</span>
      int32_t attributes = bytecode.m_attributes;
<span class="line-modified">!     int setter = bytecode.m_accessor.offset();</span>
  
      emitLoadPayload(base, regT2);
      emitLoad(property, regT1, regT0);
      emitLoadPayload(setter, regT3);
<span class="line-modified">!     callOperation(operationPutSetterByVal, regT2, JSValueRegs(regT1, regT0), attributes, regT3);</span>
  }
  
  void JIT::emit_op_del_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDelById&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
      int property = bytecode.m_property;
      emitLoad(base, regT1, regT0);
<span class="line-modified">!     callOperation(operationDeleteByIdJSResult, dst, JSValueRegs(regT1, regT0), m_codeBlock-&gt;identifier(property).impl());</span>
  }
  
  void JIT::emit_op_del_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDelByVal&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int property = bytecode.m_property.offset();</span>
      emitLoad2(base, regT1, regT0, property, regT3, regT2);
<span class="line-modified">!     callOperation(operationDeleteByValJSResult, dst, JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
  }
  
  void JIT::emit_op_get_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByVal&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int property = bytecode.m_property.offset();</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
<span class="line-removed">-     ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();</span>
  
      emitLoad2(base, regT1, regT0, property, regT3, regT2);
  
<span class="line-modified">!     emitJumpSlowCaseIfNotJSCell(base, regT1);</span>
<span class="line-modified">!     PatchableJump notIndex = patchableBranch32(NotEqual, regT3, TrustedImm32(JSValue::Int32Tag));</span>
<span class="line-modified">!     addSlowCase(notIndex);</span>
<span class="line-modified">!     emitArrayProfilingSiteWithCell(regT0, regT1, profile);</span>
<span class="line-modified">!     and32(TrustedImm32(IndexingShapeMask), regT1);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     PatchableJump badType;</span>
<span class="line-modified">!     JumpList slowCases;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     JITArrayMode mode = chooseArrayMode(profile);</span>
<span class="line-modified">!     switch (mode) {</span>
<span class="line-modified">!     case JITInt32:</span>
<span class="line-modified">!         slowCases = emitInt32GetByVal(currentInstruction, badType);</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!     case JITDouble:</span>
<span class="line-modified">!         slowCases = emitDoubleGetByVal(currentInstruction, badType);</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!     case JITContiguous:</span>
<span class="line-modified">!         slowCases = emitContiguousGetByVal(currentInstruction, badType);</span>
<span class="line-modified">!         break;</span>
<span class="line-removed">-     case JITArrayStorage:</span>
<span class="line-removed">-         slowCases = emitArrayStorageGetByVal(currentInstruction, badType);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-         CRASH();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     addSlowCase(badType);</span>
<span class="line-removed">-     addSlowCase(slowCases);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Label done = label();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!ASSERT_DISABLED) {</span>
<span class="line-removed">-         Jump resultOK = branchIfNotEmpty(regT1);</span>
<span class="line-removed">-         abortWithReason(JITGetByValResultIsNotEmpty);</span>
<span class="line-removed">-         resultOK.link(this);</span>
      }
<span class="line-removed">- </span>
<span class="line-removed">-     emitValueProfilingSite(bytecode.metadata(m_codeBlock));</span>
<span class="line-removed">-     emitStore(dst, regT1, regT0);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Label nextHotPath = label();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_byValCompilationInfo.append(ByValCompilationInfo(byValInfo, m_bytecodeOffset, notIndex, badType, mode, profile, done, nextHotPath));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JITGetByIdGenerator JIT::emitGetByValWithCachedId(ByValInfo* byValInfo, OpGetByVal bytecode, const Identifier&amp; propertyName, Jump&amp; fastDoneCase, Jump&amp; slowDoneCase, JumpList&amp; slowCases)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // base: tag(regT1), payload(regT0)</span>
<span class="line-removed">-     // property: tag(regT3), payload(regT2)</span>
<span class="line-removed">-     // scratch: regT4</span>
<span class="line-removed">- </span>
<span class="line-removed">-     int dst = bytecode.m_dst.offset();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     slowCases.append(branchIfNotCell(regT3));</span>
<span class="line-removed">-     emitByValIdentifierCheck(byValInfo, regT2, regT4, propertyName, slowCases);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     const Instruction* currentInstruction = m_codeBlock-&gt;instructions().at(byValInfo-&gt;bytecodeIndex).ptr();</span>
<span class="line-removed">-     JITGetByIdGenerator gen(</span>
<span class="line-removed">-         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-removed">-         propertyName.impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::Get);</span>
<span class="line-removed">-     gen.generateFastPath(*this);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     fastDoneCase = jump();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Label coldPathBegin = label();</span>
<span class="line-removed">-     gen.slowPathJump().link(this);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdOptimize, dst, gen.stubInfo(), JSValueRegs(regT1, regT0), propertyName.impl());</span>
<span class="line-removed">-     gen.reportSlowPathCall(coldPathBegin, call);</span>
<span class="line-removed">-     slowDoneCase = jump();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return gen;</span>
  }
  
  void JIT::emitSlow_op_get_by_val(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
<span class="line-modified">!     auto bytecode = currentInstruction-&gt;as&lt;OpGetByVal&gt;();</span>
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int property = bytecode.m_property.offset();</span>
<span class="line-modified">!     ByValInfo* byValInfo = m_byValCompilationInfo[m_byValInstructionIndex].byValInfo;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     linkSlowCaseIfNotJSCell(iter, base); // base cell check</span>
<span class="line-removed">-     linkSlowCase(iter); // property int32 check</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Jump nonCell = jump();</span>
<span class="line-removed">-     linkSlowCase(iter); // base array check</span>
<span class="line-removed">-     Jump notString = branchIfNotString(regT0);</span>
<span class="line-removed">-     emitNakedCall(CodeLocationLabel&lt;NoPtrTag&gt;(m_vm-&gt;getCTIStub(stringGetByValGenerator).retaggedCode&lt;NoPtrTag&gt;()));</span>
<span class="line-removed">-     Jump failed = branchTestPtr(Zero, regT0);</span>
<span class="line-removed">-     emitStoreCell(dst, regT0);</span>
<span class="line-removed">-     emitJumpSlowToHot(jump(), currentInstruction-&gt;size());</span>
<span class="line-removed">-     failed.link(this);</span>
<span class="line-removed">-     notString.link(this);</span>
<span class="line-removed">-     nonCell.link(this);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     linkSlowCase(iter); // vector length check</span>
<span class="line-removed">-     linkSlowCase(iter); // empty value</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Label slowPath = label();</span>
  
<span class="line-modified">!     emitLoad(base, regT1, regT0);</span>
<span class="line-modified">!     emitLoad(property, regT3, regT2);</span>
<span class="line-removed">-     Call call = callOperation(operationGetByValOptimize, dst, JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2), byValInfo);</span>
  
<span class="line-modified">!     m_byValCompilationInfo[m_byValInstructionIndex].slowPathTarget = slowPath;</span>
<span class="line-removed">-     m_byValCompilationInfo[m_byValInstructionIndex].returnAddress = call;</span>
<span class="line-removed">-     m_byValInstructionIndex++;</span>
  
<span class="line-modified">!     emitValueProfilingSite(bytecode.metadata(m_codeBlock));</span>
  }
  
  void JIT::emit_op_put_by_val_direct(const Instruction* currentInstruction)
  {
      emit_op_put_by_val&lt;OpPutByValDirect&gt;(currentInstruction);
<span class="line-new-header">--- 48,147 ---</span>
  namespace JSC {
  
  void JIT::emit_op_put_getter_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterById&gt;();
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
      int property = bytecode.m_property;
      int options = bytecode.m_attributes;
<span class="line-modified">!     VirtualRegister getter = bytecode.m_accessor;</span>
  
      emitLoadPayload(base, regT1);
      emitLoadPayload(getter, regT3);
<span class="line-modified">!     callOperation(operationPutGetterById, m_codeBlock-&gt;globalObject(), regT1, m_codeBlock-&gt;identifier(property).impl(), options, regT3);</span>
  }
  
  void JIT::emit_op_put_setter_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutSetterById&gt;();
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
      int property = bytecode.m_property;
      int options = bytecode.m_attributes;
<span class="line-modified">!     VirtualRegister setter = bytecode.m_accessor;</span>
  
      emitLoadPayload(base, regT1);
      emitLoadPayload(setter, regT3);
<span class="line-modified">!     callOperation(operationPutSetterById, m_codeBlock-&gt;globalObject(), regT1, m_codeBlock-&gt;identifier(property).impl(), options, regT3);</span>
  }
  
  void JIT::emit_op_put_getter_setter_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterSetterById&gt;();
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
      int property = bytecode.m_property;
      int attributes = bytecode.m_attributes;
<span class="line-modified">!     VirtualRegister getter = bytecode.m_getter;</span>
<span class="line-modified">!     VirtualRegister setter = bytecode.m_setter;</span>
  
      emitLoadPayload(base, regT1);
      emitLoadPayload(getter, regT3);
      emitLoadPayload(setter, regT4);
<span class="line-modified">!     callOperation(operationPutGetterSetter, m_codeBlock-&gt;globalObject(), regT1, m_codeBlock-&gt;identifier(property).impl(), attributes, regT3, regT4);</span>
  }
  
  void JIT::emit_op_put_getter_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterByVal&gt;();
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister property = bytecode.m_property;</span>
      int32_t attributes = bytecode.m_attributes;
<span class="line-modified">!     VirtualRegister getter = bytecode.m_accessor;</span>
  
      emitLoadPayload(base, regT2);
      emitLoad(property, regT1, regT0);
      emitLoadPayload(getter, regT3);
<span class="line-modified">!     callOperation(operationPutGetterByVal, m_codeBlock-&gt;globalObject(), regT2, JSValueRegs(regT1, regT0), attributes, regT3);</span>
  }
  
  void JIT::emit_op_put_setter_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutSetterByVal&gt;();
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister property = bytecode.m_property;</span>
      int32_t attributes = bytecode.m_attributes;
<span class="line-modified">!     VirtualRegister setter = bytecode.m_accessor;</span>
  
      emitLoadPayload(base, regT2);
      emitLoad(property, regT1, regT0);
      emitLoadPayload(setter, regT3);
<span class="line-modified">!     callOperation(operationPutSetterByVal, m_codeBlock-&gt;globalObject(), regT2, JSValueRegs(regT1, regT0), attributes, regT3);</span>
  }
  
  void JIT::emit_op_del_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDelById&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
      int property = bytecode.m_property;
      emitLoad(base, regT1, regT0);
<span class="line-modified">!     callOperation(operationDeleteByIdJSResult, dst, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0), m_codeBlock-&gt;identifier(property).impl());</span>
  }
  
  void JIT::emit_op_del_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDelByVal&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister property = bytecode.m_property;</span>
      emitLoad2(base, regT1, regT0, property, regT3, regT2);
<span class="line-modified">!     callOperation(operationDeleteByValJSResult, dst, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
  }
  
  void JIT::emit_op_get_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByVal&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister property = bytecode.m_property;</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
  
      emitLoad2(base, regT1, regT0, property, regT3, regT2);
  
<span class="line-modified">!     if (metadata.m_seenIdentifiers.count() &gt; Options::getByValICMaxNumberOfIdentifiers()) {</span>
<span class="line-modified">!         auto notCell = branchIfNotCell(regT1);</span>
<span class="line-modified">!         emitArrayProfilingSiteWithCell(regT0, regT4, profile);</span>
<span class="line-modified">!         notCell.link(this);</span>
<span class="line-modified">!         callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByVal, dst, TrustedImmPtr(m_codeBlock-&gt;globalObject()), JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!         emitJumpSlowCaseIfNotJSCell(base, regT1);</span>
<span class="line-modified">!         emitArrayProfilingSiteWithCell(regT0, regT4, profile);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         JITGetByValGenerator gen(</span>
<span class="line-modified">!             m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified">!             JSValueRegs::payloadOnly(regT0), JSValueRegs(regT3, regT2), JSValueRegs(regT1, regT0));</span>
<span class="line-modified">!         if (isOperandConstantInt(property))</span>
<span class="line-modified">!             gen.stubInfo()-&gt;propertyIsInt32 = true;</span>
<span class="line-modified">!         gen.generateFastPath(*this);</span>
<span class="line-modified">!         addSlowCase(gen.slowPathJump());</span>
<span class="line-modified">!         m_getByVals.append(gen);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         emitValueProfilingSite(bytecode.metadata(m_codeBlock));</span>
<span class="line-modified">!         emitStore(dst, regT1, regT0);</span>
      }
  }
  
  void JIT::emitSlow_op_get_by_val(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
<span class="line-modified">!     if (hasAnySlowCases(iter)) {</span>
<span class="line-modified">!         auto bytecode = currentInstruction-&gt;as&lt;OpGetByVal&gt;();</span>
<span class="line-modified">!         VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!         auto&amp; metadata = bytecode.metadata(m_codeBlock);</span>
<span class="line-modified">!         ArrayProfile* profile = &amp;metadata.m_arrayProfile;</span>
  
<span class="line-modified">!         JITGetByValGenerator&amp; gen = m_getByVals[m_getByValIndex];</span>
<span class="line-modified">!         ++m_getByValIndex;</span>
  
<span class="line-modified">!         linkAllSlowCases(iter);</span>
  
<span class="line-modified">!         Label coldPathBegin = label();</span>
<span class="line-added">+         Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByValOptimize, dst, TrustedImmPtr(m_codeBlock-&gt;globalObject()), gen.stubInfo(), profile, JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
<span class="line-added">+         gen.reportSlowPathCall(coldPathBegin, call);</span>
<span class="line-added">+     }</span>
  }
  
  void JIT::emit_op_put_by_val_direct(const Instruction* currentInstruction)
  {
      emit_op_put_by_val&lt;OpPutByValDirect&gt;(currentInstruction);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 269,12 ***</span>
  template&lt;typename Op&gt;
  void JIT::emit_op_put_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int property = bytecode.m_property.offset();</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
      ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();
  
      emitLoad2(base, regT1, regT0, property, regT3, regT2);
  
<span class="line-new-header">--- 197,12 ---</span>
  template&lt;typename Op&gt;
  void JIT::emit_op_put_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister property = bytecode.m_property;</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
      ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();
  
      emitLoad2(base, regT1, regT0, property, regT3, regT2);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 312,19 ***</span>
      addSlowCase(badType);
      addSlowCase(slowCases);
  
      Label done = label();
  
<span class="line-modified">!     m_byValCompilationInfo.append(ByValCompilationInfo(byValInfo, m_bytecodeOffset, notIndex, badType, mode, profile, done, done));</span>
  }
  
  template &lt;typename Op&gt;
  JIT::JumpList JIT::emitGenericContiguousPutByVal(Op bytecode, PatchableJump&amp; badType, IndexingType indexingShape)
  {
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
  
      JumpList slowCases;
  
      badType = patchableBranch32(NotEqual, regT1, TrustedImm32(ContiguousShape));
<span class="line-new-header">--- 240,19 ---</span>
      addSlowCase(badType);
      addSlowCase(slowCases);
  
      Label done = label();
  
<span class="line-modified">!     m_byValCompilationInfo.append(ByValCompilationInfo(byValInfo, m_bytecodeIndex, notIndex, badType, mode, profile, done, done));</span>
  }
  
  template &lt;typename Op&gt;
  JIT::JumpList JIT::emitGenericContiguousPutByVal(Op bytecode, PatchableJump&amp; badType, IndexingType indexingShape)
  {
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
  
      JumpList slowCases;
  
      badType = patchableBranch32(NotEqual, regT1, TrustedImm32(ContiguousShape));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 380,12 ***</span>
  
  template &lt;typename Op&gt;
  JIT::JumpList JIT::emitArrayStoragePutByVal(Op bytecode, PatchableJump&amp; badType)
  {
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
  
      JumpList slowCases;
  
      badType = patchableBranch32(NotEqual, regT1, TrustedImm32(ArrayStorageShape));
<span class="line-new-header">--- 308,12 ---</span>
  
  template &lt;typename Op&gt;
  JIT::JumpList JIT::emitArrayStoragePutByVal(Op bytecode, PatchableJump&amp; badType)
  {
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
  
      JumpList slowCases;
  
      badType = patchableBranch32(NotEqual, regT1, TrustedImm32(ArrayStorageShape));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 421,53 ***</span>
  JITPutByIdGenerator JIT::emitPutByValWithCachedId(ByValInfo* byValInfo, Op bytecode, PutKind putKind, const Identifier&amp; propertyName, JumpList&amp; doneCases, JumpList&amp; slowCases)
  {
      // base: tag(regT1), payload(regT0)
      // property: tag(regT3), payload(regT2)
  
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
  
      slowCases.append(branchIfNotCell(regT3));
      emitByValIdentifierCheck(byValInfo, regT2, regT2, propertyName, slowCases);
  
      // Write barrier breaks the registers. So after issuing the write barrier,
      // reload the registers.
      emitWriteBarrier(base, value, ShouldFilterBase);
      emitLoadPayload(base, regT0);
      emitLoad(value, regT3, regT2);
  
<span class="line-removed">-     const Instruction* currentInstruction = m_codeBlock-&gt;instructions().at(byValInfo-&gt;bytecodeIndex).ptr();</span>
      JITPutByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
          JSValueRegs::payloadOnly(regT0), JSValueRegs(regT3, regT2), regT1, m_codeBlock-&gt;ecmaMode(), putKind);
      gen.generateFastPath(*this);
      doneCases.append(jump());
  
      Label coldPathBegin = label();
      gen.slowPathJump().link(this);
  
      // JITPutByIdGenerator only preserve the value and the base&#39;s payload, we have to reload the tag.
      emitLoadTag(base, regT1);
  
<span class="line-modified">!     Call call = callOperation(gen.slowPathFunction(), gen.stubInfo(), JSValueRegs(regT3, regT2), JSValueRegs(regT1, regT0), propertyName.impl());</span>
      gen.reportSlowPathCall(coldPathBegin, call);
      doneCases.append(jump());
  
      return gen;
  }
  
  void JIT::emitSlow_op_put_by_val(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      bool isDirect = currentInstruction-&gt;opcodeID() == op_put_by_val_direct;
<span class="line-modified">!     int base;</span>
<span class="line-modified">!     int property;</span>
<span class="line-modified">!     int value;</span>
  
      auto load = [&amp;](auto bytecode) {
<span class="line-modified">!         base = bytecode.m_base.offset();</span>
<span class="line-modified">!         property = bytecode.m_property.offset();</span>
<span class="line-modified">!         value = bytecode.m_value.offset();</span>
      };
  
      if (isDirect)
          load(currentInstruction-&gt;as&lt;OpPutByValDirect&gt;());
      else
<span class="line-new-header">--- 349,52 ---</span>
  JITPutByIdGenerator JIT::emitPutByValWithCachedId(ByValInfo* byValInfo, Op bytecode, PutKind putKind, const Identifier&amp; propertyName, JumpList&amp; doneCases, JumpList&amp; slowCases)
  {
      // base: tag(regT1), payload(regT0)
      // property: tag(regT3), payload(regT2)
  
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
  
      slowCases.append(branchIfNotCell(regT3));
      emitByValIdentifierCheck(byValInfo, regT2, regT2, propertyName, slowCases);
  
      // Write barrier breaks the registers. So after issuing the write barrier,
      // reload the registers.
      emitWriteBarrier(base, value, ShouldFilterBase);
      emitLoadPayload(base, regT0);
      emitLoad(value, regT3, regT2);
  
      JITPutByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
          JSValueRegs::payloadOnly(regT0), JSValueRegs(regT3, regT2), regT1, m_codeBlock-&gt;ecmaMode(), putKind);
      gen.generateFastPath(*this);
      doneCases.append(jump());
  
      Label coldPathBegin = label();
      gen.slowPathJump().link(this);
  
      // JITPutByIdGenerator only preserve the value and the base&#39;s payload, we have to reload the tag.
      emitLoadTag(base, regT1);
  
<span class="line-modified">!     Call call = callOperation(gen.slowPathFunction(), m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT3, regT2), JSValueRegs(regT1, regT0), propertyName.impl());</span>
      gen.reportSlowPathCall(coldPathBegin, call);
      doneCases.append(jump());
  
      return gen;
  }
  
  void JIT::emitSlow_op_put_by_val(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      bool isDirect = currentInstruction-&gt;opcodeID() == op_put_by_val_direct;
<span class="line-modified">!     VirtualRegister base;</span>
<span class="line-modified">!     VirtualRegister property;</span>
<span class="line-modified">!     VirtualRegister value;</span>
  
      auto load = [&amp;](auto bytecode) {
<span class="line-modified">!         base = bytecode.m_base;</span>
<span class="line-modified">!         property = bytecode.m_property;</span>
<span class="line-modified">!         value = bytecode.m_value;</span>
      };
  
      if (isDirect)
          load(currentInstruction-&gt;as&lt;OpPutByValDirect&gt;());
      else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 481,30 ***</span>
      // The register selection below is chosen to reduce register swapping on ARM.
      // Swapping shouldn&#39;t happen on other platforms.
      emitLoad(base, regT2, regT1);
      emitLoad(property, regT3, regT0);
      emitLoad(value, regT5, regT4);
<span class="line-modified">!     Call call = callOperation(isDirect ? operationDirectPutByValOptimize : operationPutByValOptimize, JSValueRegs(regT2, regT1), JSValueRegs(regT3, regT0), JSValueRegs(regT5, regT4), byValInfo);</span>
  
      m_byValCompilationInfo[m_byValInstructionIndex].slowPathTarget = slowPath;
      m_byValCompilationInfo[m_byValInstructionIndex].returnAddress = call;
      m_byValInstructionIndex++;
  }
  
  void JIT::emit_op_try_get_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpTryGetById&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitLoad(base, regT1, regT0);
      emitJumpSlowCaseIfNotJSCell(base, regT1);
  
      JITGetByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified">!         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::TryGet);</span>
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_getByIds.append(gen);
  
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
<span class="line-new-header">--- 408,30 ---</span>
      // The register selection below is chosen to reduce register swapping on ARM.
      // Swapping shouldn&#39;t happen on other platforms.
      emitLoad(base, regT2, regT1);
      emitLoad(property, regT3, regT0);
      emitLoad(value, regT5, regT4);
<span class="line-modified">!     Call call = callOperation(isDirect ? operationDirectPutByValOptimize : operationPutByValOptimize, m_codeBlock-&gt;globalObject(), JSValueRegs(regT2, regT1), JSValueRegs(regT3, regT0), JSValueRegs(regT5, regT4), byValInfo);</span>
  
      m_byValCompilationInfo[m_byValInstructionIndex].slowPathTarget = slowPath;
      m_byValCompilationInfo[m_byValInstructionIndex].returnAddress = call;
      m_byValInstructionIndex++;
  }
  
  void JIT::emit_op_try_get_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpTryGetById&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitLoad(base, regT1, regT0);
      emitJumpSlowCaseIfNotJSCell(base, regT1);
  
      JITGetByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified">!         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::TryGetById);</span>
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_getByIds.append(gen);
  
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 514,36 ***</span>
  void JIT::emitSlow_op_try_get_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpTryGetById&gt;();
<span class="line-modified">!     int resultVReg = bytecode.m_dst.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperation(operationTryGetByIdOptimize, resultVReg, gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  
  void JIT::emit_op_get_by_id_direct(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdDirect&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitLoad(base, regT1, regT0);
      emitJumpSlowCaseIfNotJSCell(base, regT1);
  
      JITGetByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified">!         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::GetDirect);</span>
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_getByIds.append(gen);
  
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
<span class="line-new-header">--- 441,36 ---</span>
  void JIT::emitSlow_op_try_get_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpTryGetById&gt;();
<span class="line-modified">!     VirtualRegister resultVReg = bytecode.m_dst;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperation(operationTryGetByIdOptimize, resultVReg, m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  
  void JIT::emit_op_get_by_id_direct(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdDirect&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitLoad(base, regT1, regT0);
      emitJumpSlowCaseIfNotJSCell(base, regT1);
  
      JITGetByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified">!         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::GetByIdDirect);</span>
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_getByIds.append(gen);
  
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 553,29 ***</span>
  void JIT::emitSlow_op_get_by_id_direct(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdDirect&gt;();
<span class="line-modified">!     int resultVReg = bytecode.m_dst.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdDirectOptimize, resultVReg, gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  
  void JIT::emit_op_get_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetById&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitLoad(base, regT1, regT0);
      emitJumpSlowCaseIfNotJSCell(base, regT1);
  
<span class="line-new-header">--- 480,29 ---</span>
  void JIT::emitSlow_op_get_by_id_direct(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdDirect&gt;();
<span class="line-modified">!     VirtualRegister resultVReg = bytecode.m_dst;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdDirectOptimize, resultVReg, m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  
  void JIT::emit_op_get_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetById&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitLoad(base, regT1, regT0);
      emitJumpSlowCaseIfNotJSCell(base, regT1);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 584,12 ***</span>
          emitArrayProfilingSiteWithCell(regT0, regT2, &amp;metadata.m_modeMetadata.arrayLengthMode.arrayProfile);
          notArrayLengthMode.link(this);
      }
  
      JITGetByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified">!         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::Get);</span>
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_getByIds.append(gen);
  
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
<span class="line-new-header">--- 511,12 ---</span>
          emitArrayProfilingSiteWithCell(regT0, regT2, &amp;metadata.m_modeMetadata.arrayLengthMode.arrayProfile);
          notArrayLengthMode.link(this);
      }
  
      JITGetByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified">!         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::GetById);</span>
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_getByIds.append(gen);
  
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 599,38 ***</span>
  void JIT::emitSlow_op_get_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpGetById&gt;();
<span class="line-modified">!     int resultVReg = bytecode.m_dst.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdOptimize, resultVReg, gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emit_op_get_by_id_with_this(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdWithThis&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int thisVReg = bytecode.m_thisValue.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitLoad(base, regT1, regT0);
      emitLoad(thisVReg, regT4, regT3);
      emitJumpSlowCaseIfNotJSCell(base, regT1);
      emitJumpSlowCaseIfNotJSCell(thisVReg, regT4);
  
      JITGetByIdWithThisGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified">!         ident-&gt;impl(), JSValueRegs(regT1, regT0), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT4, regT3), AccessType::GetWithThis);</span>
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_getByIdsWithThis.append(gen);
  
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
<span class="line-new-header">--- 526,38 ---</span>
  void JIT::emitSlow_op_get_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpGetById&gt;();
<span class="line-modified">!     VirtualRegister resultVReg = bytecode.m_dst;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdOptimize, resultVReg, m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emit_op_get_by_id_with_this(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdWithThis&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister thisVReg = bytecode.m_thisValue;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitLoad(base, regT1, regT0);
      emitLoad(thisVReg, regT4, regT3);
      emitJumpSlowCaseIfNotJSCell(base, regT1);
      emitJumpSlowCaseIfNotJSCell(thisVReg, regT4);
  
      JITGetByIdWithThisGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified">!         ident-&gt;impl(), JSValueRegs(regT1, regT0), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT4, regT3));</span>
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_getByIdsWithThis.append(gen);
  
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 640,18 ***</span>
  void JIT::emitSlow_op_get_by_id_with_this(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdWithThis&gt;();
<span class="line-modified">!     int resultVReg = bytecode.m_dst.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITGetByIdWithThisGenerator&amp; gen = m_getByIdsWithThis[m_getByIdWithThisIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdWithThisOptimize, resultVReg, gen.stubInfo(), JSValueRegs(regT1, regT0), JSValueRegs(regT4, regT3), ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emit_op_put_by_id(const Instruction* currentInstruction)
<span class="line-new-header">--- 567,18 ---</span>
  void JIT::emitSlow_op_get_by_id_with_this(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdWithThis&gt;();
<span class="line-modified">!     VirtualRegister resultVReg = bytecode.m_dst;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITGetByIdWithThisGenerator&amp; gen = m_getByIdsWithThis[m_getByIdWithThisIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdWithThisOptimize, resultVReg, m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT1, regT0), JSValueRegs(regT4, regT3), ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emit_op_put_by_id(const Instruction* currentInstruction)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 659,20 ***</span>
      // In order to be able to patch both the Structure, and the object offset, we store one pointer,
      // to just after the arguments have been loaded into registers &#39;hotPathBegin&#39;, and we generate code
      // such that the Structure &amp; offset are always at the same distance from this.
  
      auto bytecode = currentInstruction-&gt;as&lt;OpPutById&gt;();
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
      bool direct = !!(bytecode.m_flags &amp; PutByIdIsDirect);
  
      emitLoad2(base, regT1, regT0, value, regT3, regT2);
  
      emitJumpSlowCaseIfNotJSCell(base, regT1);
  
      JITPutByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
          JSValueRegs::payloadOnly(regT0), JSValueRegs(regT3, regT2),
          regT1, m_codeBlock-&gt;ecmaMode(), direct ? Direct : NotDirect);
  
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
<span class="line-new-header">--- 586,20 ---</span>
      // In order to be able to patch both the Structure, and the object offset, we store one pointer,
      // to just after the arguments have been loaded into registers &#39;hotPathBegin&#39;, and we generate code
      // such that the Structure &amp; offset are always at the same distance from this.
  
      auto bytecode = currentInstruction-&gt;as&lt;OpPutById&gt;();
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
      bool direct = !!(bytecode.m_flags &amp; PutByIdIsDirect);
  
      emitLoad2(base, regT1, regT0, value, regT3, regT2);
  
      emitJumpSlowCaseIfNotJSCell(base, regT1);
  
      JITPutByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
          JSValueRegs::payloadOnly(regT0), JSValueRegs(regT3, regT2),
          regT1, m_codeBlock-&gt;ecmaMode(), direct ? Direct : NotDirect);
  
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 685,38 ***</span>
  void JIT::emitSlow_op_put_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpPutById&gt;();
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      Label coldPathBegin(this);
  
      // JITPutByIdGenerator only preserve the value and the base&#39;s payload, we have to reload the tag.
      emitLoadTag(base, regT1);
  
      JITPutByIdGenerator&amp; gen = m_putByIds[m_putByIdIndex++];
  
      Call call = callOperation(
<span class="line-modified">!         gen.slowPathFunction(), gen.stubInfo(), JSValueRegs(regT3, regT2), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emit_op_in_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpInById&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitLoad(base, regT1, regT0);
      emitJumpSlowCaseIfNotJSCell(base, regT1);
  
      JITInByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
          ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0));
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_inByIds.append(gen);
  
<span class="line-new-header">--- 612,38 ---</span>
  void JIT::emitSlow_op_put_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpPutById&gt;();
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      Label coldPathBegin(this);
  
      // JITPutByIdGenerator only preserve the value and the base&#39;s payload, we have to reload the tag.
      emitLoadTag(base, regT1);
  
      JITPutByIdGenerator&amp; gen = m_putByIds[m_putByIdIndex++];
  
      Call call = callOperation(
<span class="line-modified">!         gen.slowPathFunction(), m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT3, regT2), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emit_op_in_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpInById&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitLoad(base, regT1, regT0);
      emitJumpSlowCaseIfNotJSCell(base, regT1);
  
      JITInByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
          ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0));
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_inByIds.append(gen);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 726,18 ***</span>
  void JIT::emitSlow_op_in_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpInById&gt;();
<span class="line-modified">!     int resultVReg = bytecode.m_dst.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITInByIdGenerator&amp; gen = m_inByIds[m_inByIdIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperation(operationInByIdOptimize, resultVReg, gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emitVarInjectionCheck(bool needsVarInjectionChecks)
<span class="line-new-header">--- 653,18 ---</span>
  void JIT::emitSlow_op_in_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpInById&gt;();
<span class="line-modified">!     VirtualRegister resultVReg = bytecode.m_dst;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITInByIdGenerator&amp; gen = m_inByIds[m_inByIdIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperation(operationInByIdOptimize, resultVReg, m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emitVarInjectionCheck(bool needsVarInjectionChecks)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 745,11 ***</span>
      if (!needsVarInjectionChecks)
          return;
      addSlowCase(branch8(Equal, AbsoluteAddress(m_codeBlock-&gt;globalObject()-&gt;varInjectionWatchpoint()-&gt;addressOfState()), TrustedImm32(IsInvalidated)));
  }
  
<span class="line-modified">! void JIT::emitResolveClosure(int dst, int scope, bool needsVarInjectionChecks, unsigned depth)</span>
  {
      emitVarInjectionCheck(needsVarInjectionChecks);
      move(TrustedImm32(JSValue::CellTag), regT1);
      emitLoadPayload(scope, regT0);
      for (unsigned i = 0; i &lt; depth; ++i)
<span class="line-new-header">--- 672,11 ---</span>
      if (!needsVarInjectionChecks)
          return;
      addSlowCase(branch8(Equal, AbsoluteAddress(m_codeBlock-&gt;globalObject()-&gt;varInjectionWatchpoint()-&gt;addressOfState()), TrustedImm32(IsInvalidated)));
  }
  
<span class="line-modified">! void JIT::emitResolveClosure(VirtualRegister dst, VirtualRegister scope, bool needsVarInjectionChecks, unsigned depth)</span>
  {
      emitVarInjectionCheck(needsVarInjectionChecks);
      move(TrustedImm32(JSValue::CellTag), regT1);
      emitLoadPayload(scope, regT0);
      for (unsigned i = 0; i &lt; depth; ++i)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 759,12 ***</span>
  
  void JIT::emit_op_resolve_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpResolveScope&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int scope = bytecode.m_scope.offset();</span>
      ResolveType resolveType = metadata.m_resolveType;
      unsigned depth = metadata.m_localScopeDepth;
  
      auto emitCode = [&amp;] (ResolveType resolveType) {
          switch (resolveType) {
<span class="line-new-header">--- 686,12 ---</span>
  
  void JIT::emit_op_resolve_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpResolveScope&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister scope = bytecode.m_scope;</span>
      ResolveType resolveType = metadata.m_resolveType;
      unsigned depth = metadata.m_localScopeDepth;
  
      auto emitCode = [&amp;] (ResolveType resolveType) {
          switch (resolveType) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 861,11 ***</span>
          emitCode(resolveType);
          break;
      }
  }
  
<span class="line-modified">! void JIT::emitLoadWithStructureCheck(int scope, Structure** structureSlot)</span>
  {
      emitLoad(scope, regT1, regT0);
      loadPtr(structureSlot, regT2);
      addSlowCase(branchPtr(NotEqual, Address(regT0, JSCell::structureIDOffset()), regT2));
  }
<span class="line-new-header">--- 788,11 ---</span>
          emitCode(resolveType);
          break;
      }
  }
  
<span class="line-modified">! void JIT::emitLoadWithStructureCheck(VirtualRegister scope, Structure** structureSlot)</span>
  {
      emitLoad(scope, regT1, regT0);
      loadPtr(structureSlot, regT2);
      addSlowCase(branchPtr(NotEqual, Address(regT0, JSCell::structureIDOffset()), regT2));
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 881,23 ***</span>
      loadPtr(operand, payload);
      load32(Address(payload, TagOffset), tag);
      load32(Address(payload, PayloadOffset), payload);
  }
  
<span class="line-modified">! void JIT::emitGetClosureVar(int scope, uintptr_t operand)</span>
  {
      emitLoad(scope, regT1, regT0);
      load32(Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + TagOffset), regT1);
      load32(Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + PayloadOffset), regT0);
  }
  
  void JIT::emit_op_get_from_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetFromScope&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int scope = bytecode.m_scope.offset();</span>
      ResolveType resolveType = metadata.m_getPutInfo.resolveType();
      Structure** structureSlot = metadata.m_structure.slot();
      uintptr_t* operandSlot = reinterpret_cast&lt;uintptr_t*&gt;(&amp;metadata.m_operand);
  
      auto emitCode = [&amp;] (ResolveType resolveType, bool indirectLoadForOperand) {
<span class="line-new-header">--- 808,23 ---</span>
      loadPtr(operand, payload);
      load32(Address(payload, TagOffset), tag);
      load32(Address(payload, PayloadOffset), payload);
  }
  
<span class="line-modified">! void JIT::emitGetClosureVar(VirtualRegister scope, uintptr_t operand)</span>
  {
      emitLoad(scope, regT1, regT0);
      load32(Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + TagOffset), regT1);
      load32(Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + PayloadOffset), regT0);
  }
  
  void JIT::emit_op_get_from_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetFromScope&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister scope = bytecode.m_scope;</span>
      ResolveType resolveType = metadata.m_getPutInfo.resolveType();
      Structure** structureSlot = metadata.m_structure.slot();
      uintptr_t* operandSlot = reinterpret_cast&lt;uintptr_t*&gt;(&amp;metadata.m_operand);
  
      auto emitCode = [&amp;] (ResolveType resolveType, bool indirectLoadForOperand) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 910,11 ***</span>
              GPRReg resultPayload = regT0;
              GPRReg offset = regT3;
  
              move(regT0, base);
              load32(operandSlot, offset);
<span class="line-modified">!             if (!ASSERT_DISABLED) {</span>
                  Jump isOutOfLine = branch32(GreaterThanOrEqual, offset, TrustedImm32(firstOutOfLineOffset));
                  abortWithReason(JITOffsetIsNotOutOfLine);
                  isOutOfLine.link(this);
              }
              loadPtr(Address(base, JSObject::butterflyOffset()), base);
<span class="line-new-header">--- 837,11 ---</span>
              GPRReg resultPayload = regT0;
              GPRReg offset = regT3;
  
              move(regT0, base);
              load32(operandSlot, offset);
<span class="line-modified">!             if (ASSERT_ENABLED) {</span>
                  Jump isOutOfLine = branch32(GreaterThanOrEqual, offset, TrustedImm32(firstOutOfLineOffset));
                  abortWithReason(JITOffsetIsNotOutOfLine);
                  isOutOfLine.link(this);
              }
              loadPtr(Address(base, JSObject::butterflyOffset()), base);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1007,34 ***</span>
  void JIT::emitSlow_op_get_from_scope(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpGetFromScope&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetFromScope, dst, currentInstruction);</span>
  }
  
<span class="line-modified">! void JIT::emitPutGlobalVariable(JSValue* operand, int value, WatchpointSet* set)</span>
  {
      emitLoad(value, regT1, regT0);
      emitNotifyWrite(set);
      uintptr_t rawAddress = bitwise_cast&lt;uintptr_t&gt;(operand);
      store32(regT1, bitwise_cast&lt;void*&gt;(rawAddress + TagOffset));
      store32(regT0, bitwise_cast&lt;void*&gt;(rawAddress + PayloadOffset));
  }
  
<span class="line-modified">! void JIT::emitPutGlobalVariableIndirect(JSValue** addressOfOperand, int value, WatchpointSet** indirectWatchpointSet)</span>
  {
      emitLoad(value, regT1, regT0);
      loadPtr(indirectWatchpointSet, regT2);
      emitNotifyWrite(regT2);
      loadPtr(addressOfOperand, regT2);
      store32(regT1, Address(regT2, TagOffset));
      store32(regT0, Address(regT2, PayloadOffset));
  }
  
<span class="line-modified">! void JIT::emitPutClosureVar(int scope, uintptr_t operand, int value, WatchpointSet* set)</span>
  {
      emitLoad(value, regT3, regT2);
      emitLoad(scope, regT1, regT0);
      emitNotifyWrite(set);
      store32(regT3, Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + TagOffset));
<span class="line-new-header">--- 934,34 ---</span>
  void JIT::emitSlow_op_get_from_scope(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpGetFromScope&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetFromScope, dst, m_codeBlock-&gt;globalObject(), currentInstruction);</span>
  }
  
<span class="line-modified">! void JIT::emitPutGlobalVariable(JSValue* operand, VirtualRegister value, WatchpointSet* set)</span>
  {
      emitLoad(value, regT1, regT0);
      emitNotifyWrite(set);
      uintptr_t rawAddress = bitwise_cast&lt;uintptr_t&gt;(operand);
      store32(regT1, bitwise_cast&lt;void*&gt;(rawAddress + TagOffset));
      store32(regT0, bitwise_cast&lt;void*&gt;(rawAddress + PayloadOffset));
  }
  
<span class="line-modified">! void JIT::emitPutGlobalVariableIndirect(JSValue** addressOfOperand, VirtualRegister value, WatchpointSet** indirectWatchpointSet)</span>
  {
      emitLoad(value, regT1, regT0);
      loadPtr(indirectWatchpointSet, regT2);
      emitNotifyWrite(regT2);
      loadPtr(addressOfOperand, regT2);
      store32(regT1, Address(regT2, TagOffset));
      store32(regT0, Address(regT2, PayloadOffset));
  }
  
<span class="line-modified">! void JIT::emitPutClosureVar(VirtualRegister scope, uintptr_t operand, VirtualRegister value, WatchpointSet* set)</span>
  {
      emitLoad(value, regT3, regT2);
      emitLoad(scope, regT1, regT0);
      emitNotifyWrite(set);
      store32(regT3, Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + TagOffset));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1043,12 ***</span>
  
  void JIT::emit_op_put_to_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutToScope&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int scope = bytecode.m_scope.offset();</span>
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
      GetPutInfo getPutInfo = copiedGetPutInfo(bytecode);
      ResolveType resolveType = getPutInfo.resolveType();
      Structure** structureSlot = metadata.m_structure.slot();
      uintptr_t* operandSlot = reinterpret_cast&lt;uintptr_t*&gt;(&amp;metadata.m_operand);
  
<span class="line-new-header">--- 970,12 ---</span>
  
  void JIT::emit_op_put_to_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutToScope&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister scope = bytecode.m_scope;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
      GetPutInfo getPutInfo = copiedGetPutInfo(bytecode);
      ResolveType resolveType = getPutInfo.resolveType();
      Structure** structureSlot = metadata.m_structure.slot();
      uintptr_t* operandSlot = reinterpret_cast&lt;uintptr_t*&gt;(&amp;metadata.m_operand);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1169,18 ***</span>
      ResolveType resolveType = copiedGetPutInfo(bytecode).resolveType();
      if (resolveType == ModuleVar) {
          JITSlowPathCall slowPathCall(this, currentInstruction, slow_path_throw_strict_mode_readonly_property_write_error);
          slowPathCall.call();
      } else
<span class="line-modified">!         callOperation(operationPutToScope, currentInstruction);</span>
  }
  
  void JIT::emit_op_get_from_arguments(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetFromArguments&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int arguments = bytecode.m_arguments.offset();</span>
      int index = bytecode.m_index;
  
      emitLoadPayload(arguments, regT0);
      load32(Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + TagOffset), regT1);
      load32(Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + PayloadOffset), regT0);
<span class="line-new-header">--- 1096,18 ---</span>
      ResolveType resolveType = copiedGetPutInfo(bytecode).resolveType();
      if (resolveType == ModuleVar) {
          JITSlowPathCall slowPathCall(this, currentInstruction, slow_path_throw_strict_mode_readonly_property_write_error);
          slowPathCall.call();
      } else
<span class="line-modified">!         callOperation(operationPutToScope, m_codeBlock-&gt;globalObject(), currentInstruction);</span>
  }
  
  void JIT::emit_op_get_from_arguments(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetFromArguments&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister arguments = bytecode.m_arguments;</span>
      int index = bytecode.m_index;
  
      emitLoadPayload(arguments, regT0);
      load32(Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + TagOffset), regT1);
      load32(Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + PayloadOffset), regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1189,21 ***</span>
  }
  
  void JIT::emit_op_put_to_arguments(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutToArguments&gt;();
<span class="line-modified">!     int arguments = bytecode.m_arguments.offset();</span>
      int index = bytecode.m_index;
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
  
      emitWriteBarrier(arguments, value, ShouldFilterValue);
  
      emitLoadPayload(arguments, regT0);
      emitLoad(value, regT1, regT2);
      store32(regT1, Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + TagOffset));
      store32(regT2, Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + PayloadOffset));
  }
  
  } // namespace JSC
  
  #endif // USE(JSVALUE32_64)
  #endif // ENABLE(JIT)
<span class="line-new-header">--- 1116,50 ---</span>
  }
  
  void JIT::emit_op_put_to_arguments(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutToArguments&gt;();
<span class="line-modified">!     VirtualRegister arguments = bytecode.m_arguments;</span>
      int index = bytecode.m_index;
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
  
      emitWriteBarrier(arguments, value, ShouldFilterValue);
  
      emitLoadPayload(arguments, regT0);
      emitLoad(value, regT1, regT2);
      store32(regT1, Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + TagOffset));
      store32(regT2, Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + PayloadOffset));
  }
  
<span class="line-added">+ void JIT::emit_op_get_internal_field(const Instruction* currentInstruction)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto bytecode = currentInstruction-&gt;as&lt;OpGetInternalField&gt;();</span>
<span class="line-added">+     auto&amp; metadata = bytecode.metadata(m_codeBlock);</span>
<span class="line-added">+     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-added">+     VirtualRegister base = bytecode.m_base;</span>
<span class="line-added">+     unsigned index = bytecode.m_index;</span>
<span class="line-added">+ </span>
<span class="line-added">+     emitLoadPayload(base, regT2);</span>
<span class="line-added">+     load32(Address(regT2, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index) + TagOffset), regT1);</span>
<span class="line-added">+     load32(Address(regT2, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index) + PayloadOffset), regT0);</span>
<span class="line-added">+     emitValueProfilingSite(metadata);</span>
<span class="line-added">+     emitStore(dst, regT1, regT0);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JIT::emit_op_put_internal_field(const Instruction* currentInstruction)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto bytecode = currentInstruction-&gt;as&lt;OpPutInternalField&gt;();</span>
<span class="line-added">+     VirtualRegister base = bytecode.m_base;</span>
<span class="line-added">+     VirtualRegister value = bytecode.m_value;</span>
<span class="line-added">+     unsigned index = bytecode.m_index;</span>
<span class="line-added">+ </span>
<span class="line-added">+     emitLoadPayload(base, regT0);</span>
<span class="line-added">+     emitLoad(value, regT1, regT2);</span>
<span class="line-added">+     store32(regT1, Address(regT0, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index) + TagOffset));</span>
<span class="line-added">+     store32(regT2, Address(regT0, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index) + PayloadOffset));</span>
<span class="line-added">+     emitWriteBarrier(base, value, ShouldFilterValue);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  } // namespace JSC
  
  #endif // USE(JSVALUE32_64)
  #endif // ENABLE(JIT)
</pre>
<center><a href="JITPropertyAccess.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITRightShiftGenerator.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
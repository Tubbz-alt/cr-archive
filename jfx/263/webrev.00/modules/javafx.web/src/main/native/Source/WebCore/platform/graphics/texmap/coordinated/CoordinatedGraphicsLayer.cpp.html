<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/coordinated/CoordinatedGraphicsLayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
   3  Copyright (C) 2010 Apple Inc. All rights reserved.
   4  Copyright (C) 2012 Company 100, Inc.
   5  Copyright (C) 2012 Intel Corporation. All rights reserved.
   6  Copyright (C) 2017 Sony Interactive Entertainment Inc.
   7 
   8  This library is free software; you can redistribute it and/or
   9  modify it under the terms of the GNU Library General Public
  10  License as published by the Free Software Foundation; either
  11  version 2 of the License, or (at your option) any later version.
  12 
  13  This library is distributed in the hope that it will be useful,
  14  but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  Library General Public License for more details.
  17 
  18  You should have received a copy of the GNU Library General Public License
  19  along with this library; see the file COPYING.LIB.  If not, write to
  20  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  Boston, MA 02110-1301, USA.
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;CoordinatedGraphicsLayer.h&quot;
  26 
  27 #if USE(COORDINATED_GRAPHICS)
  28 
  29 #include &quot;FloatQuad.h&quot;
  30 #include &quot;GraphicsContext.h&quot;
  31 #include &quot;GraphicsLayer.h&quot;
  32 #include &quot;GraphicsLayerFactory.h&quot;
  33 #include &quot;NicosiaBackingStoreTextureMapperImpl.h&quot;
  34 #include &quot;NicosiaCompositionLayerTextureMapperImpl.h&quot;
  35 #include &quot;NicosiaContentLayerTextureMapperImpl.h&quot;
  36 #include &quot;NicosiaImageBackingTextureMapperImpl.h&quot;
  37 #include &quot;NicosiaPaintingContext.h&quot;
  38 #include &quot;NicosiaPaintingEngine.h&quot;
  39 #include &quot;ScrollableArea.h&quot;
  40 #include &quot;TextureMapperPlatformLayerProxyProvider.h&quot;
  41 #include &quot;TiledBackingStore.h&quot;
  42 #ifndef NDEBUG
  43 #include &lt;wtf/SetForScope.h&gt;
  44 #endif
  45 #include &lt;wtf/text/CString.h&gt;
  46 
  47 #if USE(GLIB_EVENT_LOOP)
  48 #include &lt;wtf/glib/RunLoopSourcePriority.h&gt;
  49 #endif
  50 
  51 namespace WebCore {
  52 
  53 Ref&lt;GraphicsLayer&gt; GraphicsLayer::create(GraphicsLayerFactory* factory, GraphicsLayerClient&amp; client, Type layerType)
  54 {
  55     if (!factory)
  56         return adoptRef(*new CoordinatedGraphicsLayer(layerType, client));
  57 
  58     return factory-&gt;createGraphicsLayer(layerType, client);
  59 }
  60 
  61 void CoordinatedGraphicsLayer::notifyFlushRequired()
  62 {
  63     if (!m_coordinator)
  64         return;
  65 
  66     if (m_coordinator-&gt;isFlushingLayerChanges())
  67         return;
  68 
  69     client().notifyFlushRequired(this);
  70 }
  71 
  72 void CoordinatedGraphicsLayer::didChangeAnimations()
  73 {
  74     m_nicosia.delta.animationsChanged = true;
  75     notifyFlushRequired();
  76 }
  77 
  78 void CoordinatedGraphicsLayer::didChangeChildren()
  79 {
  80     m_nicosia.delta.childrenChanged = true;
  81     notifyFlushRequired();
  82 }
  83 
  84 void CoordinatedGraphicsLayer::didChangeFilters()
  85 {
  86     m_nicosia.delta.filtersChanged = true;
  87     notifyFlushRequired();
  88 }
  89 
  90 void CoordinatedGraphicsLayer::didUpdateTileBuffers()
  91 {
  92     if (!isShowingRepaintCounter())
  93         return;
  94 
  95     auto repaintCount = incrementRepaintCount();
  96     m_nicosia.repaintCounter.count = repaintCount;
  97     m_nicosia.delta.repaintCounterChanged = true;
  98 }
  99 
 100 void CoordinatedGraphicsLayer::setShouldUpdateVisibleRect()
 101 {
 102     m_shouldUpdateVisibleRect = true;
 103     for (auto&amp; child : children())
 104         downcast&lt;CoordinatedGraphicsLayer&gt;(child.get()).setShouldUpdateVisibleRect();
 105     if (replicaLayer())
 106         downcast&lt;CoordinatedGraphicsLayer&gt;(*replicaLayer()).setShouldUpdateVisibleRect();
 107 }
 108 
 109 void CoordinatedGraphicsLayer::didChangeGeometry(FlushNotification flushNotification)
 110 {
 111     if (flushNotification == FlushNotification::Required)
 112         notifyFlushRequired();
 113     setShouldUpdateVisibleRect();
 114 }
 115 
 116 CoordinatedGraphicsLayer::CoordinatedGraphicsLayer(Type layerType, GraphicsLayerClient&amp; client)
 117     : GraphicsLayer(layerType, client)
 118 #ifndef NDEBUG
 119     , m_isPurging(false)
 120 #endif
 121     , m_shouldUpdateVisibleRect(true)
 122     , m_movingVisibleRect(false)
 123     , m_pendingContentsScaleAdjustment(false)
 124     , m_pendingVisibleRectAdjustment(false)
 125     , m_shouldUpdatePlatformLayer(false)
 126     , m_coordinator(0)
 127     , m_compositedNativeImagePtr(0)
 128     , m_animationStartedTimer(*this, &amp;CoordinatedGraphicsLayer::animationStartedTimerFired)
 129     , m_requestPendingTileCreationTimer(RunLoop::main(), this, &amp;CoordinatedGraphicsLayer::requestPendingTileCreationTimerFired)
 130 {
 131     static Nicosia::PlatformLayer::LayerID nextLayerID = 1;
 132     m_id = nextLayerID++;
 133 
 134     m_nicosia.layer = Nicosia::CompositionLayer::create(m_id,
 135         Nicosia::CompositionLayerTextureMapperImpl::createFactory());
 136 
 137     // Enforce a complete flush on the first occasion.
 138     m_nicosia.delta.value = UINT_MAX;
 139 
 140 #if USE(GLIB_EVENT_LOOP)
 141     m_requestPendingTileCreationTimer.setPriority(RunLoopSourcePriority::LayerFlushTimer);
 142 #endif
 143 }
 144 
 145 CoordinatedGraphicsLayer::~CoordinatedGraphicsLayer()
 146 {
 147     if (m_coordinator) {
 148         purgeBackingStores();
 149         m_coordinator-&gt;detachLayer(this);
 150     }
 151     ASSERT(!m_nicosia.imageBacking);
 152     ASSERT(!m_nicosia.backingStore);
 153     if (m_animatedBackingStoreHost)
 154         m_animatedBackingStoreHost-&gt;layerWillBeDestroyed();
 155     willBeDestroyed();
 156 }
 157 
 158 bool CoordinatedGraphicsLayer::isCoordinatedGraphicsLayer() const
 159 {
 160     return true;
 161 }
 162 
 163 Nicosia::PlatformLayer::LayerID CoordinatedGraphicsLayer::id() const
 164 {
 165     return m_id;
 166 }
 167 
 168 auto CoordinatedGraphicsLayer::primaryLayerID() const -&gt; PlatformLayerID
 169 {
 170     return id();
 171 }
 172 
 173 bool CoordinatedGraphicsLayer::setChildren(Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp;&amp; children)
 174 {
 175     bool ok = GraphicsLayer::setChildren(WTFMove(children));
 176     if (!ok)
 177         return false;
 178     didChangeChildren();
 179     return true;
 180 }
 181 
 182 void CoordinatedGraphicsLayer::addChild(Ref&lt;GraphicsLayer&gt;&amp;&amp; layer)
 183 {
 184     GraphicsLayer* rawLayer = layer.ptr();
 185     GraphicsLayer::addChild(WTFMove(layer));
 186     downcast&lt;CoordinatedGraphicsLayer&gt;(*rawLayer).setCoordinatorIncludingSubLayersIfNeeded(m_coordinator);
 187     didChangeChildren();
 188 }
 189 
 190 void CoordinatedGraphicsLayer::addChildAtIndex(Ref&lt;GraphicsLayer&gt;&amp;&amp; layer, int index)
 191 {
 192     GraphicsLayer* rawLayer = layer.ptr();
 193     GraphicsLayer::addChildAtIndex(WTFMove(layer), index);
 194     downcast&lt;CoordinatedGraphicsLayer&gt;(*rawLayer).setCoordinatorIncludingSubLayersIfNeeded(m_coordinator);
 195     didChangeChildren();
 196 }
 197 
 198 void CoordinatedGraphicsLayer::addChildAbove(Ref&lt;GraphicsLayer&gt;&amp;&amp; layer, GraphicsLayer* sibling)
 199 {
 200     GraphicsLayer* rawLayer = layer.ptr();
 201     GraphicsLayer::addChildAbove(WTFMove(layer), sibling);
 202     downcast&lt;CoordinatedGraphicsLayer&gt;(*rawLayer).setCoordinatorIncludingSubLayersIfNeeded(m_coordinator);
 203     didChangeChildren();
 204 }
 205 
 206 void CoordinatedGraphicsLayer::addChildBelow(Ref&lt;GraphicsLayer&gt;&amp;&amp; layer, GraphicsLayer* sibling)
 207 {
 208     GraphicsLayer* rawLayer = layer.ptr();
 209     GraphicsLayer::addChildBelow(WTFMove(layer), sibling);
 210     downcast&lt;CoordinatedGraphicsLayer&gt;(*rawLayer).setCoordinatorIncludingSubLayersIfNeeded(m_coordinator);
 211     didChangeChildren();
 212 }
 213 
 214 bool CoordinatedGraphicsLayer::replaceChild(GraphicsLayer* oldChild, Ref&lt;GraphicsLayer&gt;&amp;&amp; newChild)
 215 {
 216     GraphicsLayer* rawLayer = newChild.ptr();
 217     bool ok = GraphicsLayer::replaceChild(oldChild, WTFMove(newChild));
 218     if (!ok)
 219         return false;
 220     downcast&lt;CoordinatedGraphicsLayer&gt;(*rawLayer).setCoordinatorIncludingSubLayersIfNeeded(m_coordinator);
 221     didChangeChildren();
 222     return true;
 223 }
 224 
 225 void CoordinatedGraphicsLayer::removeFromParent()
 226 {
 227     if (CoordinatedGraphicsLayer* parentLayer = downcast&lt;CoordinatedGraphicsLayer&gt;(parent()))
 228         parentLayer-&gt;didChangeChildren();
 229     GraphicsLayer::removeFromParent();
 230 }
 231 
 232 void CoordinatedGraphicsLayer::setPosition(const FloatPoint&amp; p)
 233 {
 234     if (position() == p)
 235         return;
 236 
 237     GraphicsLayer::setPosition(p);
 238     m_nicosia.delta.positionChanged = true;
 239     didChangeGeometry();
 240 }
 241 
 242 void CoordinatedGraphicsLayer::syncPosition(const FloatPoint&amp; p)
 243 {
 244     if (position() == p)
 245         return;
 246 
 247     GraphicsLayer::syncPosition(p);
 248     didChangeGeometry(FlushNotification::NotRequired);
 249 }
 250 
 251 void CoordinatedGraphicsLayer::setAnchorPoint(const FloatPoint3D&amp; p)
 252 {
 253     if (anchorPoint() == p)
 254         return;
 255 
 256     GraphicsLayer::setAnchorPoint(p);
 257     m_nicosia.delta.anchorPointChanged = true;
 258     didChangeGeometry();
 259 }
 260 
 261 void CoordinatedGraphicsLayer::setSize(const FloatSize&amp; size)
 262 {
 263     if (this-&gt;size() == size)
 264         return;
 265 
 266     GraphicsLayer::setSize(size);
 267     m_nicosia.delta.sizeChanged = true;
 268 
 269     if (maskLayer())
 270         maskLayer()-&gt;setSize(size);
 271     didChangeGeometry();
 272 }
 273 
 274 void CoordinatedGraphicsLayer::setBoundsOrigin(const FloatPoint&amp; boundsOrigin)
 275 {
 276     if (this-&gt;boundsOrigin() == boundsOrigin)
 277         return;
 278 
 279     GraphicsLayer::setBoundsOrigin(boundsOrigin);
 280     m_nicosia.delta.boundsOriginChanged = true;
 281     didChangeGeometry();
 282 }
 283 
 284 void CoordinatedGraphicsLayer::syncBoundsOrigin(const FloatPoint&amp; boundsOrigin)
 285 {
 286     if (this-&gt;boundsOrigin() == boundsOrigin)
 287         return;
 288 
 289     GraphicsLayer::syncBoundsOrigin(boundsOrigin);
 290     didChangeGeometry(FlushNotification::NotRequired);
 291 }
 292 
 293 void CoordinatedGraphicsLayer::setTransform(const TransformationMatrix&amp; t)
 294 {
 295     if (transform() == t)
 296         return;
 297 
 298     GraphicsLayer::setTransform(t);
 299     m_nicosia.delta.transformChanged = true;
 300 
 301     didChangeGeometry();
 302 }
 303 
 304 void CoordinatedGraphicsLayer::setChildrenTransform(const TransformationMatrix&amp; t)
 305 {
 306     if (childrenTransform() == t)
 307         return;
 308 
 309     GraphicsLayer::setChildrenTransform(t);
 310     m_nicosia.delta.childrenTransformChanged = true;
 311 
 312     didChangeGeometry();
 313 }
 314 
 315 void CoordinatedGraphicsLayer::setPreserves3D(bool b)
 316 {
 317     if (preserves3D() == b)
 318         return;
 319 
 320     GraphicsLayer::setPreserves3D(b);
 321     m_nicosia.delta.flagsChanged = true;
 322 
 323     didChangeGeometry();
 324 }
 325 
 326 void CoordinatedGraphicsLayer::setMasksToBounds(bool b)
 327 {
 328     if (masksToBounds() == b)
 329         return;
 330     GraphicsLayer::setMasksToBounds(b);
 331     m_nicosia.delta.flagsChanged = true;
 332 
 333     didChangeGeometry();
 334 }
 335 
 336 void CoordinatedGraphicsLayer::setDrawsContent(bool b)
 337 {
 338     if (drawsContent() == b)
 339         return;
 340     GraphicsLayer::setDrawsContent(b);
 341     m_nicosia.delta.flagsChanged = true;
 342 
 343     notifyFlushRequired();
 344 }
 345 
 346 void CoordinatedGraphicsLayer::setContentsVisible(bool b)
 347 {
 348     if (contentsAreVisible() == b)
 349         return;
 350     GraphicsLayer::setContentsVisible(b);
 351     m_nicosia.delta.flagsChanged = true;
 352 
 353     if (maskLayer())
 354         maskLayer()-&gt;setContentsVisible(b);
 355 
 356     notifyFlushRequired();
 357 }
 358 
 359 void CoordinatedGraphicsLayer::setContentsOpaque(bool b)
 360 {
 361     if (contentsOpaque() == b)
 362         return;
 363 
 364     GraphicsLayer::setContentsOpaque(b);
 365     m_nicosia.delta.flagsChanged = true;
 366 
 367     // Demand a repaint of the whole layer.
 368     if (!m_needsDisplay.completeLayer) {
 369         m_needsDisplay.completeLayer = true;
 370         m_needsDisplay.rects.clear();
 371 
 372         addRepaintRect({ { }, m_size });
 373     }
 374 
 375     notifyFlushRequired();
 376 }
 377 
 378 void CoordinatedGraphicsLayer::setBackfaceVisibility(bool b)
 379 {
 380     if (backfaceVisibility() == b)
 381         return;
 382 
 383     GraphicsLayer::setBackfaceVisibility(b);
 384     m_nicosia.delta.flagsChanged = true;
 385 
 386     notifyFlushRequired();
 387 }
 388 
 389 void CoordinatedGraphicsLayer::setOpacity(float opacity)
 390 {
 391     if (this-&gt;opacity() == opacity)
 392         return;
 393 
 394     GraphicsLayer::setOpacity(opacity);
 395     m_nicosia.delta.opacityChanged = true;
 396 
 397     notifyFlushRequired();
 398 }
 399 
 400 void CoordinatedGraphicsLayer::setContentsRect(const FloatRect&amp; r)
 401 {
 402     if (contentsRect() == r)
 403         return;
 404 
 405     GraphicsLayer::setContentsRect(r);
 406     m_nicosia.delta.contentsRectChanged = true;
 407 
 408     notifyFlushRequired();
 409 }
 410 
 411 void CoordinatedGraphicsLayer::setContentsTileSize(const FloatSize&amp; s)
 412 {
 413     if (contentsTileSize() == s)
 414         return;
 415 
 416     GraphicsLayer::setContentsTileSize(s);
 417     m_nicosia.delta.contentsTilingChanged = true;
 418     notifyFlushRequired();
 419 }
 420 
 421 void CoordinatedGraphicsLayer::setContentsTilePhase(const FloatSize&amp; p)
 422 {
 423     if (contentsTilePhase() == p)
 424         return;
 425 
 426     GraphicsLayer::setContentsTilePhase(p);
 427     m_nicosia.delta.contentsTilingChanged = true;
 428     notifyFlushRequired();
 429 }
 430 
 431 bool GraphicsLayer::supportsContentsTiling()
 432 {
 433     return true;
 434 }
 435 
 436 void CoordinatedGraphicsLayer::setContentsNeedsDisplay()
 437 {
 438 #if USE(COORDINATED_GRAPHICS) &amp;&amp; USE(NICOSIA)
 439     if (m_nicosia.contentLayer)
 440         m_shouldUpdatePlatformLayer = true;
 441 #endif
 442 
 443     notifyFlushRequired();
 444     addRepaintRect(contentsRect());
 445 }
 446 
 447 void CoordinatedGraphicsLayer::setContentsToPlatformLayer(PlatformLayer* platformLayer, ContentsLayerPurpose)
 448 {
 449 #if USE(COORDINATED_GRAPHICS) &amp;&amp; USE(NICOSIA)
 450     auto* contentLayer = downcast&lt;Nicosia::ContentLayer&gt;(platformLayer);
 451     if (m_nicosia.contentLayer != contentLayer) {
 452         m_nicosia.contentLayer = contentLayer;
 453         m_nicosia.delta.contentLayerChanged = true;
 454         if (m_nicosia.contentLayer)
 455             m_shouldUpdatePlatformLayer = true;
 456     }
 457     notifyFlushRequired();
 458 #else
 459     UNUSED_PARAM(platformLayer);
 460 #endif
 461 }
 462 
 463 bool CoordinatedGraphicsLayer::filtersCanBeComposited(const FilterOperations&amp; filters) const
 464 {
 465     if (!filters.size())
 466         return false;
 467 
 468     for (const auto&amp; filterOperation : filters.operations()) {
 469         if (filterOperation-&gt;type() == FilterOperation::REFERENCE)
 470             return false;
 471     }
 472 
 473     return true;
 474 }
 475 
 476 bool CoordinatedGraphicsLayer::setFilters(const FilterOperations&amp; newFilters)
 477 {
 478     bool canCompositeFilters = filtersCanBeComposited(newFilters);
 479     if (filters() == newFilters)
 480         return canCompositeFilters;
 481 
 482     if (canCompositeFilters) {
 483         if (!GraphicsLayer::setFilters(newFilters))
 484             return false;
 485         didChangeFilters();
 486     } else if (filters().size()) {
 487         clearFilters();
 488         didChangeFilters();
 489     }
 490 
 491     return canCompositeFilters;
 492 }
 493 
 494 void CoordinatedGraphicsLayer::setContentsToSolidColor(const Color&amp; color)
 495 {
 496     if (m_solidColor == color)
 497         return;
 498 
 499     m_solidColor = color;
 500     m_nicosia.delta.solidColorChanged = true;
 501 
 502     notifyFlushRequired();
 503 }
 504 
 505 void CoordinatedGraphicsLayer::setShowDebugBorder(bool show)
 506 {
 507     if (isShowingDebugBorder() == show)
 508         return;
 509 
 510     GraphicsLayer::setShowDebugBorder(show);
 511     m_nicosia.debugBorder.visible = show;
 512     m_nicosia.delta.debugBorderChanged = true;
 513 
 514     if (m_nicosia.debugBorder.visible)
 515         updateDebugIndicators();
 516 
 517     notifyFlushRequired();
 518 }
 519 
 520 void CoordinatedGraphicsLayer::setShowRepaintCounter(bool show)
 521 {
 522     if (isShowingRepaintCounter() == show)
 523         return;
 524 
 525     GraphicsLayer::setShowRepaintCounter(show);
 526     m_nicosia.repaintCounter.visible = show;
 527     m_nicosia.delta.repaintCounterChanged = true;
 528 
 529     notifyFlushRequired();
 530 }
 531 
 532 void CoordinatedGraphicsLayer::setContentsToImage(Image* image)
 533 {
 534     NativeImagePtr nativeImagePtr = image ? image-&gt;nativeImageForCurrentFrame() : nullptr;
 535     if (m_compositedImage == image &amp;&amp; m_compositedNativeImagePtr == nativeImagePtr)
 536         return;
 537 
 538     m_compositedImage = image;
 539     m_compositedNativeImagePtr = nativeImagePtr;
 540 
 541     GraphicsLayer::setContentsToImage(image);
 542     notifyFlushRequired();
 543 }
 544 
 545 void CoordinatedGraphicsLayer::setMaskLayer(RefPtr&lt;GraphicsLayer&gt;&amp;&amp; layer)
 546 {
 547     if (layer == maskLayer())
 548         return;
 549 
 550     GraphicsLayer* rawLayer = layer.get();
 551     GraphicsLayer::setMaskLayer(WTFMove(layer));
 552 
 553     if (!rawLayer)
 554         return;
 555 
 556     rawLayer-&gt;setSize(size());
 557     rawLayer-&gt;setContentsVisible(contentsAreVisible());
 558 
 559     m_nicosia.delta.maskChanged = true;
 560 
 561     notifyFlushRequired();
 562 }
 563 
 564 bool CoordinatedGraphicsLayer::shouldDirectlyCompositeImage(Image* image) const
 565 {
 566     if (!image || !image-&gt;isBitmapImage())
 567         return false;
 568 
 569     enum { MaxDimenstionForDirectCompositing = 2000 };
 570     if (image-&gt;width() &gt; MaxDimenstionForDirectCompositing || image-&gt;height() &gt; MaxDimenstionForDirectCompositing)
 571         return false;
 572 
 573     return true;
 574 }
 575 
 576 void CoordinatedGraphicsLayer::setReplicatedByLayer(RefPtr&lt;GraphicsLayer&gt;&amp;&amp; layer)
 577 {
 578     if (layer == replicaLayer())
 579         return;
 580 
 581     GraphicsLayer::setReplicatedByLayer(WTFMove(layer));
 582     m_nicosia.delta.replicaChanged = true;
 583     notifyFlushRequired();
 584 }
 585 
 586 void CoordinatedGraphicsLayer::setNeedsDisplay()
 587 {
 588     if (!drawsContent() || !contentsAreVisible() || m_size.isEmpty() || m_needsDisplay.completeLayer)
 589         return;
 590 
 591     m_needsDisplay.completeLayer = true;
 592     m_needsDisplay.rects.clear();
 593 
 594     notifyFlushRequired();
 595     addRepaintRect({ { }, m_size });
 596 }
 597 
 598 void CoordinatedGraphicsLayer::setNeedsDisplayInRect(const FloatRect&amp; initialRect, ShouldClipToLayer shouldClip)
 599 {
 600     if (!drawsContent() || !contentsAreVisible() || m_size.isEmpty() || m_needsDisplay.completeLayer)
 601         return;
 602 
 603     auto rect = initialRect;
 604     if (shouldClip == ClipToLayer)
 605         rect.intersect({ { }, m_size });
 606 
 607     if (rect.isEmpty())
 608         return;
 609 
 610     auto&amp; rects = m_needsDisplay.rects;
 611     bool alreadyRecorded = std::any_of(rects.begin(), rects.end(),
 612         [&amp;](auto&amp; dirtyRect) { return dirtyRect.contains(rect); });
 613     if (alreadyRecorded)
 614         return;
 615 
 616     if (rects.size() &lt; 32)
 617         rects.append(rect);
 618     else
 619         rects[0].unite(rect);
 620 
 621     notifyFlushRequired();
 622     addRepaintRect(rect);
 623 }
 624 
 625 void CoordinatedGraphicsLayer::flushCompositingState(const FloatRect&amp; rect)
 626 {
 627     if (CoordinatedGraphicsLayer* mask = downcast&lt;CoordinatedGraphicsLayer&gt;(maskLayer()))
 628         mask-&gt;flushCompositingStateForThisLayerOnly();
 629 
 630     if (CoordinatedGraphicsLayer* replica = downcast&lt;CoordinatedGraphicsLayer&gt;(replicaLayer()))
 631         replica-&gt;flushCompositingStateForThisLayerOnly();
 632 
 633     flushCompositingStateForThisLayerOnly();
 634 
 635     for (auto&amp; child : children())
 636         child-&gt;flushCompositingState(rect);
 637 }
 638 
 639 void CoordinatedGraphicsLayer::setDebugBorder(const Color&amp; color, float width)
 640 {
 641     ASSERT(m_nicosia.debugBorder.visible);
 642     if (m_nicosia.debugBorder.color != color) {
 643         m_nicosia.debugBorder.color = color;
 644         m_nicosia.delta.debugBorderChanged = true;
 645     }
 646 
 647     if (m_nicosia.debugBorder.width != width) {
 648         m_nicosia.debugBorder.width = width;
 649         m_nicosia.delta.debugBorderChanged = true;
 650     }
 651 }
 652 
 653 void CoordinatedGraphicsLayer::updatePlatformLayer()
 654 {
 655     if (!m_shouldUpdatePlatformLayer)
 656         return;
 657 
 658     m_shouldUpdatePlatformLayer = false;
 659 #if USE(COORDINATED_GRAPHICS) &amp;&amp; USE(NICOSIA)
 660     if (m_nicosia.contentLayer)
 661         downcast&lt;Nicosia::ContentLayerTextureMapperImpl&gt;(m_nicosia.contentLayer-&gt;impl()).swapBuffersIfNeeded();
 662 #endif
 663 }
 664 
 665 static void clampToContentsRectIfRectIsInfinite(FloatRect&amp; rect, const FloatSize&amp; contentsSize)
 666 {
 667     if (rect.width() &gt;= LayoutUnit::nearlyMax() || rect.width() &lt;= LayoutUnit::nearlyMin()) {
 668         rect.setX(0);
 669         rect.setWidth(contentsSize.width());
 670     }
 671 
 672     if (rect.height() &gt;= LayoutUnit::nearlyMax() || rect.height() &lt;= LayoutUnit::nearlyMin()) {
 673         rect.setY(0);
 674         rect.setHeight(contentsSize.height());
 675     }
 676 }
 677 
 678 class CoordinatedAnimatedBackingStoreClient final : public Nicosia::AnimatedBackingStoreClient {
 679 public:
 680     static Ref&lt;CoordinatedAnimatedBackingStoreClient&gt; create(RefPtr&lt;CoordinatedGraphicsLayer::AnimatedBackingStoreHost&gt;&amp;&amp; host, const FloatRect&amp; visibleRect, const FloatRect&amp; coverRect, const FloatSize&amp; size, float contentsScale)
 681     {
 682         return adoptRef(*new CoordinatedAnimatedBackingStoreClient(WTFMove(host), visibleRect, coverRect, size, contentsScale));
 683     }
 684 
 685     ~CoordinatedAnimatedBackingStoreClient() = default;
 686 
 687     void setCoverRect(const IntRect&amp; rect) { m_coverRect = rect; }
 688     void requestBackingStoreUpdateIfNeeded(const TransformationMatrix&amp; transform) final
 689     {
 690         ASSERT(!isMainThread());
 691 
 692         // Calculate the contents rectangle of the layer in backingStore coordinates.
 693         FloatRect contentsRect = { { 0, 0 }, m_size };
 694         contentsRect.scale(m_contentsScale);
 695 
 696         // If the area covered by tiles (the coverRect, already in backingStore coordinates) covers the whole
 697         // layer contents then we don&#39;t need to do anything.
 698         if (m_coverRect.contains(contentsRect))
 699             return;
 700 
 701         // Non-invertible layers are not visible.
 702         if (!transform.isInvertible())
 703             return;
 704 
 705         // Calculate the inverse of the layer transformation. The inverse transform will have the inverse of the
 706         // scaleFactor applied, so we need to scale it back.
 707         TransformationMatrix inverse = transform.inverse().valueOr(TransformationMatrix()).scale(m_contentsScale);
 708 
 709         // Apply the inverse transform to the visible rectangle, so we have the visible rectangle in layer coordinates.
 710         FloatRect rect = inverse.clampedBoundsOfProjectedQuad(FloatQuad(m_visibleRect));
 711         clampToContentsRectIfRectIsInfinite(rect, m_size);
 712         FloatRect transformedVisibleRect = enclosingIntRect(rect);
 713 
 714         // Convert the calculated visible rectangle to backingStore coordinates.
 715         transformedVisibleRect.scale(m_contentsScale);
 716 
 717         // Restrict the calculated visible rect to the contents rectangle of the layer.
 718         transformedVisibleRect.intersect(contentsRect);
 719 
 720         // If the coverRect doesn&#39;t contain the calculated visible rectangle we need to request a backingStore
 721         // update to render more tiles.
 722         if (!m_coverRect.contains(transformedVisibleRect)) {
 723             callOnMainThread([protectedHost = m_host.copyRef()]() {
 724                 protectedHost-&gt;requestBackingStoreUpdate();
 725             });
 726         }
 727     }
 728 
 729 private:
 730     CoordinatedAnimatedBackingStoreClient(RefPtr&lt;CoordinatedGraphicsLayer::AnimatedBackingStoreHost&gt;&amp;&amp; host, const FloatRect&amp; visibleRect, const FloatRect&amp; coverRect, const FloatSize&amp; size, float contentsScale)
 731         : Nicosia::AnimatedBackingStoreClient(Type::Coordinated)
 732         , m_host(WTFMove(host))
 733         , m_visibleRect(visibleRect)
 734         , m_coverRect(coverRect)
 735         , m_size(size)
 736         , m_contentsScale(contentsScale)
 737     { }
 738 
 739     RefPtr&lt;CoordinatedGraphicsLayer::AnimatedBackingStoreHost&gt; m_host;
 740     FloatRect m_visibleRect;
 741     FloatRect m_coverRect;
 742     FloatSize m_size;
 743     float m_contentsScale;
 744 };
 745 
 746 void CoordinatedGraphicsLayer::flushCompositingStateForThisLayerOnly()
 747 {
 748     // Whether it kicked or not, we don&#39;t need this timer running anymore.
 749     m_requestPendingTileCreationTimer.stop();
 750 
 751     // When we have a transform animation, we need to update visible rect every frame to adjust the visible rect of a backing store.
 752     bool hasActiveTransformAnimation = selfOrAncestorHasActiveTransformAnimation();
 753     if (hasActiveTransformAnimation)
 754         m_movingVisibleRect = true;
 755 
 756     // Sets the values.
 757     computePixelAlignment(m_adjustedPosition, m_adjustedSize, m_adjustedAnchorPoint, m_pixelAlignmentOffset);
 758 
 759     computeTransformedVisibleRect();
 760     updatePlatformLayer();
 761 
 762     // Only unset m_movingVisibleRect after we have updated the visible rect after the animation stopped.
 763     if (!hasActiveTransformAnimation)
 764         m_movingVisibleRect = false;
 765 
 766     // Determine the backing store presence. Content is painted later, in the updateContentBuffers() traversal.
 767     if (shouldHaveBackingStore()) {
 768         if (!m_nicosia.backingStore) {
 769             m_nicosia.backingStore = Nicosia::BackingStore::create(Nicosia::BackingStoreTextureMapperImpl::createFactory());
 770             m_nicosia.delta.backingStoreChanged = true;
 771         }
 772     } else if (m_nicosia.backingStore) {
 773         auto&amp; layerState = downcast&lt;Nicosia::BackingStoreTextureMapperImpl&gt;(m_nicosia.backingStore-&gt;impl()).layerState();
 774         layerState.isPurging = true;
 775         layerState.mainBackingStore = nullptr;
 776 
 777         m_nicosia.backingStore = nullptr;
 778         m_nicosia.delta.backingStoreChanged = true;
 779     }
 780 
 781     if (hasActiveTransformAnimation &amp;&amp; m_nicosia.backingStore) {
 782         // The layer has a backingStore and a transformation animation. This means that we need to add an
 783         // AnimatedBackingStoreClient to check whether we need to update the backingStore due to the animation.
 784         // At this point we don&#39;t know the area covered by tiles available, so we just pass an empty rectangle
 785         // for that. The call to updateContentBuffers will calculate the tile coverage and set the appropriate
 786         // rectangle to the client.
 787         if (!m_animatedBackingStoreHost)
 788             m_animatedBackingStoreHost = AnimatedBackingStoreHost::create(*this);
 789         m_nicosia.animatedBackingStoreClient = CoordinatedAnimatedBackingStoreClient::create(m_animatedBackingStoreHost.copyRef(), m_coordinator-&gt;visibleContentsRect(), { }, m_size, effectiveContentsScale());
 790     }
 791     // Each layer flush changes the AnimatedBackingStoreClient, being it null or a real one.
 792     m_nicosia.delta.animatedBackingStoreClientChanged = true;
 793 
 794     // Determine image backing presence according to the composited image source.
 795     if (m_compositedNativeImagePtr) {
 796         ASSERT(m_compositedImage);
 797         auto&amp; image = *m_compositedImage;
 798         uintptr_t imageID = reinterpret_cast&lt;uintptr_t&gt;(&amp;image);
 799         uintptr_t nativeImageID = reinterpret_cast&lt;uintptr_t&gt;(m_compositedNativeImagePtr.get());
 800 
 801         // Respawn the ImageBacking object if the underlying image changed.
 802         if (m_nicosia.imageBacking) {
 803             auto&amp; impl = downcast&lt;Nicosia::ImageBackingTextureMapperImpl&gt;(m_nicosia.imageBacking-&gt;impl());
 804             if (impl.layerState().imageID != imageID) {
 805                 impl.layerState().update = Nicosia::ImageBackingTextureMapperImpl::Update { };
 806                 m_nicosia.imageBacking = nullptr;
 807             }
 808         }
 809         if (!m_nicosia.imageBacking) {
 810             m_nicosia.imageBacking = Nicosia::ImageBacking::create(Nicosia::ImageBackingTextureMapperImpl::createFactory());
 811             m_nicosia.delta.imageBackingChanged = true;
 812         }
 813 
 814         // Update the image contents only when the image layer is visible and the native image changed.
 815         auto&amp; impl = downcast&lt;Nicosia::ImageBackingTextureMapperImpl&gt;(m_nicosia.imageBacking-&gt;impl());
 816         auto&amp; layerState = impl.layerState();
 817         layerState.imageID = imageID;
 818         layerState.update.isVisible = transformedVisibleRect().intersects(IntRect(contentsRect()));
 819         if (layerState.update.isVisible &amp;&amp; layerState.nativeImageID != nativeImageID) {
 820             auto buffer = Nicosia::Buffer::create(IntSize(image.size()),
 821                 !image.currentFrameKnownToBeOpaque() ? Nicosia::Buffer::SupportsAlpha : Nicosia::Buffer::NoFlags);
 822             Nicosia::PaintingContext::paint(buffer,
 823                 [&amp;image](GraphicsContext&amp; context)
 824                 {
 825                     IntRect rect { { }, IntSize { image.size() } };
 826                     context.drawImage(image, rect, rect, ImagePaintingOptions(CompositeOperator::Copy));
 827                 });
 828             layerState.nativeImageID = nativeImageID;
 829             layerState.update.buffer = WTFMove(buffer);
 830             m_nicosia.delta.imageBackingChanged = true;
 831         }
 832     } else if (m_nicosia.imageBacking) {
 833         auto&amp; layerState = downcast&lt;Nicosia::ImageBackingTextureMapperImpl&gt;(m_nicosia.imageBacking-&gt;impl()).layerState();
 834         layerState.update = Nicosia::ImageBackingTextureMapperImpl::Update { };
 835         m_nicosia.imageBacking = nullptr;
 836         m_nicosia.delta.imageBackingChanged = true;
 837     }
 838 
 839     {
 840         m_nicosia.layer-&gt;updateState(
 841             [this](Nicosia::CompositionLayer::LayerState&amp; state)
 842             {
 843                 // OR the local delta value into the layer&#39;s pending state delta. After that,
 844                 // go through each local change and update the pending state accordingly.
 845                 auto&amp; localDelta = m_nicosia.delta;
 846                 state.delta.value |= localDelta.value;
 847 
 848                 if (localDelta.positionChanged)
 849                     state.position = m_adjustedPosition;
 850                 if (localDelta.anchorPointChanged)
 851                     state.anchorPoint = m_adjustedAnchorPoint;
 852                 if (localDelta.sizeChanged)
 853                     state.size = m_adjustedSize;
 854 
 855                 if (localDelta.transformChanged)
 856                     state.transform = transform();
 857                 if (localDelta.childrenTransformChanged)
 858                     state.childrenTransform = childrenTransform();
 859 
 860                 if (localDelta.contentsRectChanged)
 861                     state.contentsRect = contentsRect();
 862                 if (localDelta.contentsTilingChanged) {
 863                     state.contentsTilePhase = contentsTilePhase();
 864                     state.contentsTileSize = contentsTileSize();
 865                 }
 866 
 867                 if (localDelta.opacityChanged)
 868                     state.opacity = opacity();
 869                 if (localDelta.solidColorChanged)
 870                     state.solidColor = m_solidColor;
 871 
 872                 if (localDelta.filtersChanged)
 873                     state.filters = filters();
 874                 if (localDelta.animationsChanged)
 875                     state.animations = m_animations;
 876 
 877                 if (localDelta.childrenChanged) {
 878                     state.children = WTF::map(children(),
 879                         [](auto&amp; child)
 880                         {
 881                             return downcast&lt;CoordinatedGraphicsLayer&gt;(child.get()).m_nicosia.layer;
 882                         });
 883                 }
 884 
 885                 if (localDelta.maskChanged) {
 886                     auto* mask = downcast&lt;CoordinatedGraphicsLayer&gt;(maskLayer());
 887                     state.mask = mask ? mask-&gt;m_nicosia.layer : nullptr;
 888                 }
 889 
 890                 if (localDelta.replicaChanged) {
 891                     auto* replica = downcast&lt;CoordinatedGraphicsLayer&gt;(replicaLayer());
 892                     state.replica = replica ? replica-&gt;m_nicosia.layer : nullptr;
 893                 }
 894 
 895                 if (localDelta.flagsChanged) {
 896                     state.flags.contentsOpaque = contentsOpaque();
 897                     state.flags.drawsContent = drawsContent();
 898                     state.flags.contentsVisible = contentsAreVisible();
 899                     state.flags.backfaceVisible = backfaceVisibility();
 900                     state.flags.masksToBounds = masksToBounds();
 901                     state.flags.preserves3D = preserves3D();
 902                 }
 903 
 904                 if (localDelta.repaintCounterChanged)
 905                     state.repaintCounter = m_nicosia.repaintCounter;
 906                 if (localDelta.debugBorderChanged)
 907                     state.debugBorder = m_nicosia.debugBorder;
 908 
 909                 if (localDelta.backingStoreChanged)
 910                     state.backingStore = m_nicosia.backingStore;
 911                 if (localDelta.contentLayerChanged)
 912                     state.contentLayer = m_nicosia.contentLayer;
 913                 if (localDelta.imageBackingChanged)
 914                     state.imageBacking = m_nicosia.imageBacking;
 915                 if (localDelta.animatedBackingStoreClientChanged)
 916                     state.animatedBackingStoreClient = m_nicosia.animatedBackingStoreClient;
 917             });
 918         m_nicosia.performLayerSync = !!m_nicosia.delta.value;
 919         m_nicosia.delta = { };
 920     }
 921 }
 922 
 923 void CoordinatedGraphicsLayer::syncPendingStateChangesIncludingSubLayers()
 924 {
 925     if (m_nicosia.performLayerSync)
 926         m_coordinator-&gt;syncLayerState();
 927     m_nicosia.performLayerSync = false;
 928 
 929     if (maskLayer())
 930         downcast&lt;CoordinatedGraphicsLayer&gt;(*maskLayer()).syncPendingStateChangesIncludingSubLayers();
 931 
 932     for (auto&amp; child : children())
 933         downcast&lt;CoordinatedGraphicsLayer&gt;(child.get()).syncPendingStateChangesIncludingSubLayers();
 934 }
 935 
 936 void CoordinatedGraphicsLayer::deviceOrPageScaleFactorChanged()
 937 {
 938     if (shouldHaveBackingStore())
 939         m_pendingContentsScaleAdjustment = true;
 940 }
 941 
 942 float CoordinatedGraphicsLayer::effectiveContentsScale()
 943 {
 944     return selfOrAncestorHaveNonAffineTransforms() ? 1 : deviceScaleFactor() * pageScaleFactor();
 945 }
 946 
 947 IntRect CoordinatedGraphicsLayer::transformedVisibleRect()
 948 {
 949     // Non-invertible layers are not visible.
 950     if (!m_layerTransform.combined().isInvertible())
 951         return IntRect();
 952 
 953     // Return a projection of the visible rect (surface coordinates) onto the layer&#39;s plane (layer coordinates).
 954     // The resulting quad might be squewed and the visible rect is the bounding box of this quad,
 955     // so it might spread further than the real visible area (and then even more amplified by the cover rect multiplier).
 956     ASSERT(m_cachedInverseTransform == m_layerTransform.combined().inverse().valueOr(TransformationMatrix()));
 957     FloatRect rect = m_cachedInverseTransform.clampedBoundsOfProjectedQuad(FloatQuad(m_coordinator-&gt;visibleContentsRect()));
 958     clampToContentsRectIfRectIsInfinite(rect, size());
 959     return enclosingIntRect(rect);
 960 }
 961 
 962 void CoordinatedGraphicsLayer::requestBackingStoreUpdate()
 963 {
 964     setNeedsVisibleRectAdjustment();
 965     notifyFlushRequired();
 966 }
 967 
 968 void CoordinatedGraphicsLayer::updateContentBuffersIncludingSubLayers()
 969 {
 970     if (CoordinatedGraphicsLayer* mask = downcast&lt;CoordinatedGraphicsLayer&gt;(maskLayer()))
 971         mask-&gt;updateContentBuffers();
 972 
 973     if (CoordinatedGraphicsLayer* replica = downcast&lt;CoordinatedGraphicsLayer&gt;(replicaLayer()))
 974         replica-&gt;updateContentBuffers();
 975 
 976     updateContentBuffers();
 977 
 978     for (auto&amp; child : children())
 979         downcast&lt;CoordinatedGraphicsLayer&gt;(child.get()).updateContentBuffersIncludingSubLayers();
 980 }
 981 
 982 void CoordinatedGraphicsLayer::updateContentBuffers()
 983 {
 984     if (!m_nicosia.backingStore)
 985         return;
 986 
 987     // Prepare for painting on the impl-contained backing store. isFlushing is used there
 988     // for internal sanity checks.
 989     auto&amp; impl = downcast&lt;Nicosia::BackingStoreTextureMapperImpl&gt;(m_nicosia.backingStore-&gt;impl());
 990     auto&amp; layerState = impl.layerState();
 991     layerState.isFlushing = true;
 992 
 993     // Helper lambda that finished the flush update and determines layer sync necessity.
 994     auto finishUpdate =
 995         [this, &amp;layerState] {
 996             auto&amp; update = layerState.update;
 997             m_nicosia.performLayerSync |= !update.tilesToCreate.isEmpty()
 998                 || !update.tilesToRemove.isEmpty() || !update.tilesToUpdate.isEmpty();
 999             layerState.isFlushing = false;
1000         };
1001 
1002     // Address the content scale adjustment.
1003     if (m_pendingContentsScaleAdjustment) {
1004         if (layerState.mainBackingStore &amp;&amp; layerState.mainBackingStore-&gt;contentsScale() != effectiveContentsScale()) {
1005             // Discard the TiledBackingStore object to reconstruct it with new content scale.
1006             layerState.mainBackingStore = nullptr;
1007         }
1008         m_pendingContentsScaleAdjustment = false;
1009     }
1010 
1011     // Ensure the TiledBackingStore object, and enforce a complete repaint if it&#39;s not been present yet.
1012     if (!layerState.mainBackingStore) {
1013         layerState.mainBackingStore = makeUnique&lt;TiledBackingStore&gt;(impl, effectiveContentsScale());
1014         m_pendingVisibleRectAdjustment = true;
1015     }
1016 
1017     // Bail if there&#39;s no painting recorded or enforced.
1018     if (!m_pendingVisibleRectAdjustment &amp;&amp; !m_needsDisplay.completeLayer &amp;&amp; m_needsDisplay.rects.isEmpty()) {
1019         finishUpdate();
1020         return;
1021     }
1022 
1023     if (!m_needsDisplay.completeLayer) {
1024         for (auto&amp; rect : m_needsDisplay.rects)
1025             layerState.mainBackingStore-&gt;invalidate(enclosingIntRect(rect));
1026     } else
1027         layerState.mainBackingStore-&gt;invalidate({ { }, IntSize { m_size } });
1028 
1029     m_needsDisplay.completeLayer = false;
1030     m_needsDisplay.rects.clear();
1031 
1032     if (m_pendingVisibleRectAdjustment) {
1033         m_pendingVisibleRectAdjustment = false;
1034         layerState.mainBackingStore-&gt;createTilesIfNeeded(transformedVisibleRect(), IntRect(0, 0, m_size.width(), m_size.height()));
1035     }
1036 
1037     if (is&lt;CoordinatedAnimatedBackingStoreClient&gt;(m_nicosia.animatedBackingStoreClient)) {
1038         // Determine the coverRect and set it to the client.
1039         downcast&lt;CoordinatedAnimatedBackingStoreClient&gt;(*m_nicosia.animatedBackingStoreClient).setCoverRect(layerState.mainBackingStore-&gt;coverRect());
1040     }
1041 
1042     ASSERT(m_coordinator &amp;&amp; m_coordinator-&gt;isFlushingLayerChanges());
1043 
1044     // With all the affected tiles created and/or invalidated, we can finally paint them.
1045     auto dirtyTiles = layerState.mainBackingStore-&gt;dirtyTiles();
1046     if (!dirtyTiles.isEmpty()) {
1047         bool didUpdateTiles = false;
1048 
1049         for (auto&amp; tileReference : dirtyTiles) {
1050             auto&amp; tile = tileReference.get();
1051             tile.ensureTileID();
1052 
1053             auto&amp; tileRect = tile.rect();
1054             auto&amp; dirtyRect = tile.dirtyRect();
1055 
1056             auto coordinatedBuffer = Nicosia::Buffer::create(dirtyRect.size(), contentsOpaque() ? Nicosia::Buffer::NoFlags : Nicosia::Buffer::SupportsAlpha);
1057             SurfaceUpdateInfo updateInfo;
1058             updateInfo.updateRect = dirtyRect;
1059             updateInfo.updateRect.move(-tileRect.x(), -tileRect.y());
1060             updateInfo.buffer = coordinatedBuffer.copyRef();
1061 
1062             if (!m_coordinator-&gt;paintingEngine().paint(*this, WTFMove(coordinatedBuffer),
1063                 dirtyRect, layerState.mainBackingStore-&gt;mapToContents(dirtyRect),
1064                 IntRect { { 0, 0 }, dirtyRect.size() }, layerState.mainBackingStore-&gt;contentsScale()))
1065                 continue;
1066 
1067             impl.updateTile(tile.tileID(), updateInfo, tileRect);
1068 
1069             tile.markClean();
1070             didUpdateTiles |= true;
1071         }
1072 
1073         if (didUpdateTiles)
1074             didUpdateTileBuffers();
1075     }
1076 
1077     // Request a new update immediately if some tiles are still pending creation. Do this on a timer
1078     // as we&#39;re in a layer flush and flush requests at this point would be discarded.
1079     if (layerState.hasPendingTileCreation) {
1080         setNeedsVisibleRectAdjustment();
1081         m_requestPendingTileCreationTimer.startOneShot(0_s);
1082     }
1083 
1084     finishUpdate();
1085 }
1086 
1087 void CoordinatedGraphicsLayer::purgeBackingStores()
1088 {
1089 #ifndef NDEBUG
1090     SetForScope&lt;bool&gt; updateModeProtector(m_isPurging, true);
1091 #endif
1092     if (m_nicosia.backingStore) {
1093         auto&amp; layerState = downcast&lt;Nicosia::BackingStoreTextureMapperImpl&gt;(m_nicosia.backingStore-&gt;impl()).layerState();
1094         layerState.isPurging = true;
1095         layerState.mainBackingStore = nullptr;
1096 
1097         m_nicosia.backingStore = nullptr;
1098     }
1099 
1100     if (m_nicosia.imageBacking) {
1101         auto&amp; layerState = downcast&lt;Nicosia::ImageBackingTextureMapperImpl&gt;(m_nicosia.imageBacking-&gt;impl()).layerState();
1102         layerState.imageID = 0;
1103         layerState.nativeImageID = 0;
1104         layerState.update = { };
1105 
1106         m_nicosia.imageBacking = nullptr;
1107     }
1108 
1109     notifyFlushRequired();
1110 }
1111 
1112 void CoordinatedGraphicsLayer::setCoordinator(CoordinatedGraphicsLayerClient* coordinator)
1113 {
1114     m_coordinator = coordinator;
1115 }
1116 
1117 void CoordinatedGraphicsLayer::setCoordinatorIncludingSubLayersIfNeeded(CoordinatedGraphicsLayerClient* coordinator)
1118 {
1119     if (!coordinator || m_coordinator == coordinator)
1120         return;
1121 
1122     // If the coordinators are different it means that we are attaching a layer that was created by a different
1123     // CompositingCoordinator than the current one. This happens because the layer was taken out of the tree
1124     // and then added back after AC was disabled and enabled again. We need to set the new coordinator to the
1125     // layer and its children.
1126     //
1127     // During each layer flush, the state stores the values that have changed since the previous one, and these
1128     // are updated once in the scene. When adding CoordinatedGraphicsLayers back to the tree, the fields that
1129     // are not updated during the next flush won&#39;t be sent to the scene, so they won&#39;t be updated there and the
1130     // rendering will fail.
1131     //
1132     // For example the drawsContent flag. This is set when the layer is created and is not updated anymore (unless
1133     // the content changes). When the layer is added back to the tree, the state won&#39;t reflect any change in the
1134     // flag value, so the scene won&#39;t update it and the layer won&#39;t be rendered.
1135     //
1136     // We need to update here the layer changeMask so the scene gets all the current values.
1137     m_nicosia.delta.value = UINT_MAX;
1138 
1139     coordinator-&gt;attachLayer(this);
1140     for (auto&amp; child : children())
1141         downcast&lt;CoordinatedGraphicsLayer&gt;(child.get()).setCoordinatorIncludingSubLayersIfNeeded(coordinator);
1142 }
1143 
1144 const RefPtr&lt;Nicosia::CompositionLayer&gt;&amp; CoordinatedGraphicsLayer::compositionLayer() const
1145 {
1146     return m_nicosia.layer;
1147 }
1148 
1149 void CoordinatedGraphicsLayer::setNeedsVisibleRectAdjustment()
1150 {
1151     if (shouldHaveBackingStore())
1152         m_pendingVisibleRectAdjustment = true;
1153 }
1154 
1155 static inline bool isIntegral(float value)
1156 {
1157     return static_cast&lt;int&gt;(value) == value;
1158 }
1159 
1160 FloatPoint CoordinatedGraphicsLayer::computePositionRelativeToBase()
1161 {
1162     FloatPoint offset;
1163     for (const GraphicsLayer* currLayer = this; currLayer; currLayer = currLayer-&gt;parent())
1164         offset += (currLayer-&gt;position() - currLayer-&gt;boundsOrigin());
1165 
1166     return offset;
1167 }
1168 
1169 void CoordinatedGraphicsLayer::computePixelAlignment(FloatPoint&amp; position, FloatSize&amp; size, FloatPoint3D&amp; anchorPoint, FloatSize&amp; alignmentOffset)
1170 {
1171     if (isIntegral(effectiveContentsScale())) {
1172         position = m_position;
1173         size = m_size;
1174         anchorPoint = m_anchorPoint;
1175         alignmentOffset = FloatSize();
1176         return;
1177     }
1178 
1179     FloatPoint positionRelativeToBase = computePositionRelativeToBase();
1180 
1181     FloatRect baseRelativeBounds(positionRelativeToBase, m_size);
1182     FloatRect scaledBounds = baseRelativeBounds;
1183 
1184     // Scale by the effective scale factor to compute the screen-relative bounds.
1185     scaledBounds.scale(effectiveContentsScale());
1186 
1187     // Round to integer boundaries.
1188     // NOTE: When using enclosingIntRect (as mac) it will have different sizes depending on position.
1189     FloatRect alignedBounds = enclosingIntRect(scaledBounds);
1190 
1191     // Convert back to layer coordinates.
1192     alignedBounds.scale(1 / effectiveContentsScale());
1193 
1194     // Convert back to layer coordinates.
1195     alignmentOffset = baseRelativeBounds.location() - alignedBounds.location();
1196 
1197     position = m_position - alignmentOffset;
1198     size = alignedBounds.size();
1199 
1200     // Now we have to compute a new anchor point which compensates for rounding.
1201     float anchorPointX = m_anchorPoint.x();
1202     float anchorPointY = m_anchorPoint.y();
1203 
1204     if (alignedBounds.width())
1205         anchorPointX = (baseRelativeBounds.width() * anchorPointX + alignmentOffset.width()) / alignedBounds.width();
1206 
1207     if (alignedBounds.height())
1208         anchorPointY = (baseRelativeBounds.height() * anchorPointY + alignmentOffset.height()) / alignedBounds.height();
1209 
1210     anchorPoint = FloatPoint3D(anchorPointX, anchorPointY, m_anchorPoint.z() * effectiveContentsScale());
1211 }
1212 
1213 void CoordinatedGraphicsLayer::computeTransformedVisibleRect()
1214 {
1215     if (!m_shouldUpdateVisibleRect &amp;&amp; !m_movingVisibleRect)
1216         return;
1217 
1218     m_shouldUpdateVisibleRect = false;
1219     TransformationMatrix currentTransform = transform();
1220     if (m_movingVisibleRect)
1221         client().getCurrentTransform(this, currentTransform);
1222     m_layerTransform.setLocalTransform(currentTransform);
1223 
1224     m_layerTransform.setAnchorPoint(m_adjustedAnchorPoint);
1225     m_layerTransform.setPosition(m_adjustedPosition);
1226     m_layerTransform.setSize(m_adjustedSize);
1227 
1228     m_layerTransform.setFlattening(!preserves3D());
1229     m_layerTransform.setChildrenTransform(childrenTransform());
1230     m_layerTransform.combineTransforms(parent() ? downcast&lt;CoordinatedGraphicsLayer&gt;(*parent()).m_layerTransform.combinedForChildren() : TransformationMatrix());
1231 
1232     m_cachedInverseTransform = m_layerTransform.combined().inverse().valueOr(TransformationMatrix());
1233 
1234     // The combined transform will be used in tiledBackingStoreVisibleRect.
1235     setNeedsVisibleRectAdjustment();
1236 }
1237 
1238 bool CoordinatedGraphicsLayer::shouldHaveBackingStore() const
1239 {
1240     return drawsContent() &amp;&amp; contentsAreVisible() &amp;&amp; !m_size.isEmpty()
1241         &amp;&amp; (!!opacity() || m_animations.hasActiveAnimationsOfType(AnimatedPropertyOpacity));
1242 }
1243 
1244 bool CoordinatedGraphicsLayer::selfOrAncestorHasActiveTransformAnimation() const
1245 {
1246     if (m_animations.hasActiveAnimationsOfType(AnimatedPropertyTransform))
1247         return true;
1248 
1249     if (!parent())
1250         return false;
1251 
1252     return downcast&lt;CoordinatedGraphicsLayer&gt;(*parent()).selfOrAncestorHasActiveTransformAnimation();
1253 }
1254 
1255 bool CoordinatedGraphicsLayer::selfOrAncestorHaveNonAffineTransforms()
1256 {
1257     if (!m_layerTransform.combined().isAffine())
1258         return true;
1259 
1260     if (!parent())
1261         return false;
1262 
1263     return downcast&lt;CoordinatedGraphicsLayer&gt;(*parent()).selfOrAncestorHaveNonAffineTransforms();
1264 }
1265 
1266 bool CoordinatedGraphicsLayer::addAnimation(const KeyframeValueList&amp; valueList, const FloatSize&amp; boxSize, const Animation* anim, const String&amp; keyframesName, double delayAsNegativeTimeOffset)
1267 {
1268     ASSERT(!keyframesName.isEmpty());
1269 
1270     if (!anim || anim-&gt;isEmptyOrZeroDuration() || valueList.size() &lt; 2 || (valueList.property() != AnimatedPropertyTransform &amp;&amp; valueList.property() != AnimatedPropertyOpacity &amp;&amp; valueList.property() != AnimatedPropertyFilter))
1271         return false;
1272 
1273     if (valueList.property() == AnimatedPropertyFilter) {
1274         int listIndex = validateFilterOperations(valueList);
1275         if (listIndex &lt; 0)
1276             return false;
1277 
1278         const auto&amp; filters = static_cast&lt;const FilterAnimationValue&amp;&gt;(valueList.at(listIndex)).value();
1279         if (!filtersCanBeComposited(filters))
1280             return false;
1281     }
1282 
1283     bool listsMatch = false;
1284     bool ignoredHasBigRotation;
1285 
1286     if (valueList.property() == AnimatedPropertyTransform)
1287         listsMatch = validateTransformOperations(valueList, ignoredHasBigRotation) &gt;= 0;
1288 
1289     m_lastAnimationStartTime = MonotonicTime::now() - Seconds(delayAsNegativeTimeOffset);
1290     m_animations.add(Nicosia::Animation(keyframesName, valueList, boxSize, *anim, listsMatch, m_lastAnimationStartTime, 0_s, Nicosia::Animation::AnimationState::Playing));
1291     m_animationStartedTimer.startOneShot(0_s);
1292     didChangeAnimations();
1293     return true;
1294 }
1295 
1296 void CoordinatedGraphicsLayer::pauseAnimation(const String&amp; animationName, double time)
1297 {
1298     m_animations.pause(animationName, Seconds(time));
1299     didChangeAnimations();
1300 }
1301 
1302 void CoordinatedGraphicsLayer::removeAnimation(const String&amp; animationName)
1303 {
1304     m_animations.remove(animationName);
1305     didChangeAnimations();
1306 }
1307 
1308 void CoordinatedGraphicsLayer::suspendAnimations(MonotonicTime time)
1309 {
1310     m_animations.suspend(time);
1311     didChangeAnimations();
1312 }
1313 
1314 void CoordinatedGraphicsLayer::resumeAnimations()
1315 {
1316     m_animations.resume();
1317     didChangeAnimations();
1318 }
1319 
1320 void CoordinatedGraphicsLayer::animationStartedTimerFired()
1321 {
1322     client().notifyAnimationStarted(this, &quot;&quot;, m_lastAnimationStartTime);
1323 }
1324 
1325 void CoordinatedGraphicsLayer::requestPendingTileCreationTimerFired()
1326 {
1327     notifyFlushRequired();
1328 }
1329 
1330 bool CoordinatedGraphicsLayer::usesContentsLayer() const
1331 {
1332     return m_nicosia.contentLayer || m_compositedImage;
1333 }
1334 
1335 #if USE(NICOSIA)
1336 PlatformLayer* CoordinatedGraphicsLayer::platformLayer() const
1337 {
1338     return m_nicosia.layer.get();
1339 }
1340 #endif
1341 
1342 } // namespace WebCore
1343 
1344 SPECIALIZE_TYPE_TRAITS_ANIMATEDBACKINGSTORECLIENT(WebCore::CoordinatedAnimatedBackingStoreClient, type() == Nicosia::AnimatedBackingStoreClient::Type::Coordinated)
1345 
1346 #endif // USE(COORDINATED_GRAPHICS)
    </pre>
  </body>
</html>
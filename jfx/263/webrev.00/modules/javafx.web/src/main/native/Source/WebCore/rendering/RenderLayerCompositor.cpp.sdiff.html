<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerCompositor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayerBacking.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerCompositor.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerCompositor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #include &quot;RenderLayerCompositor.h&quot;
  29 
  30 #include &quot;CSSAnimationController.h&quot;
  31 #include &quot;CSSPropertyNames.h&quot;
  32 #include &quot;CanvasRenderingContext.h&quot;
  33 #include &quot;Chrome.h&quot;
  34 #include &quot;ChromeClient.h&quot;
<span class="line-removed">  35 #include &quot;DocumentTimeline.h&quot;</span>
  36 #include &quot;Frame.h&quot;
  37 #include &quot;FrameView.h&quot;
  38 #include &quot;FullscreenManager.h&quot;
  39 #include &quot;GraphicsLayer.h&quot;
  40 #include &quot;HTMLCanvasElement.h&quot;
  41 #include &quot;HTMLIFrameElement.h&quot;
  42 #include &quot;HTMLNames.h&quot;
  43 #include &quot;HitTestResult.h&quot;
  44 #include &quot;InspectorInstrumentation.h&quot;

  45 #include &quot;LayerAncestorClippingStack.h&quot;
  46 #include &quot;LayerOverlapMap.h&quot;
  47 #include &quot;Logging.h&quot;
  48 #include &quot;NodeList.h&quot;
  49 #include &quot;Page.h&quot;
  50 #include &quot;PageOverlayController.h&quot;
  51 #include &quot;RenderEmbeddedObject.h&quot;
  52 #include &quot;RenderFragmentedFlow.h&quot;
  53 #include &quot;RenderFullScreen.h&quot;
  54 #include &quot;RenderGeometryMap.h&quot;
  55 #include &quot;RenderIFrame.h&quot;
  56 #include &quot;RenderImage.h&quot;
  57 #include &quot;RenderLayerBacking.h&quot;
  58 #include &quot;RenderReplica.h&quot;
  59 #include &quot;RenderVideo.h&quot;
  60 #include &quot;RenderView.h&quot;
  61 #include &quot;RuntimeEnabledFeatures.h&quot;
  62 #include &quot;ScrollingConstraints.h&quot;
  63 #include &quot;ScrollingCoordinator.h&quot;
  64 #include &quot;Settings.h&quot;
  65 #include &quot;TiledBacking.h&quot;
  66 #include &quot;TransformState.h&quot;
  67 #include &lt;wtf/HexNumber.h&gt;
  68 #include &lt;wtf/MemoryPressureHandler.h&gt;
  69 #include &lt;wtf/SetForScope.h&gt;

  70 #include &lt;wtf/text/CString.h&gt;
  71 #include &lt;wtf/text/StringBuilder.h&gt;
  72 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  73 #include &lt;wtf/text/TextStream.h&gt;
  74 
  75 #if PLATFORM(IOS_FAMILY)
  76 #include &quot;LegacyTileCache.h&quot;
  77 #include &quot;RenderScrollbar.h&quot;
  78 #endif
  79 
  80 #if PLATFORM(MAC)
  81 #include &quot;LocalDefaultSystemAppearance.h&quot;
  82 #endif
  83 
  84 #if ENABLE(TREE_DEBUGGING)
  85 #include &quot;RenderTreeAsText.h&quot;
  86 #endif
  87 
  88 #if ENABLE(3D_TRANSFORMS)
  89 // This symbol is used to determine from a script whether 3D rendering is enabled (via &#39;nm&#39;).
</pre>
<hr />
<pre>
 181     {
 182         return compositingAncestor &amp;&amp; !compositingAncestor-&gt;isRenderViewLayer();
 183     }
 184 
 185     RenderLayer* compositingAncestor;
 186     RenderLayer* backingSharingAncestor { nullptr };
 187     RenderLayer* stackingContextAncestor { nullptr };
 188     bool subtreeIsCompositing { false };
 189     bool testingOverlap { true };
 190     bool fullPaintOrderTraversalRequired { false };
 191     bool descendantsRequireCompositingUpdate { false };
 192     bool ancestorHasTransformAnimation { false };
 193 #if ENABLE(CSS_COMPOSITING)
 194     bool hasNotIsolatedCompositedBlendingDescendants { false };
 195 #endif
 196 #if !LOG_DISABLED
 197     unsigned depth { 0 };
 198 #endif
 199 };
 200 






















 201 class RenderLayerCompositor::BackingSharingState {
 202     WTF_MAKE_NONCOPYABLE(BackingSharingState);
 203 public:
 204     BackingSharingState() = default;
 205 
 206     RenderLayer* backingProviderCandidate() const { return m_backingProviderCandidate; };
 207 
 208     void appendSharingLayer(RenderLayer&amp; layer)
 209     {
 210         ASSERT(m_backingProviderCandidate);
 211         m_backingSharingLayers.append(makeWeakPtr(layer));
 212     }
 213 
 214     void updateBeforeDescendantTraversal(RenderLayer&amp;, bool willBeComposited);
 215     void updateAfterDescendantTraversal(RenderLayer&amp;, RenderLayer* stackingContextAncestor);
 216 
 217 private:
 218     void layerWillBeComposited(RenderLayer&amp;);
 219 
 220     void startBackingSharingSequence(RenderLayer&amp; candidateLayer, RenderLayer* candidateStackingContext);
</pre>
<hr />
<pre>
 664     if (!frameRenderer || !is&lt;RenderWidget&gt;(frameRenderer))
 665         return { };
 666 
 667     auto&amp; widgetRenderer = downcast&lt;RenderWidget&gt;(*frameRenderer);
 668     if (!widgetRenderer.hasLayer() || !widgetRenderer.layer()-&gt;isComposited()) {
 669         LOG(Scrolling, &quot;frameHostingNodeForFrame: frame renderer has no layer or is not composited.&quot;);
 670         return { };
 671     }
 672 
 673     if (auto frameHostingNodeID = widgetRenderer.layer()-&gt;backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting))
 674         return frameHostingNodeID;
 675 
 676     return { };
 677 }
 678 
 679 // Returns true on a successful update.
 680 bool RenderLayerCompositor::updateCompositingLayers(CompositingUpdateType updateType, RenderLayer* updateRoot)
 681 {
 682     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; updateCompositingLayers &quot; &lt;&lt; updateType &lt;&lt; &quot; contentLayersCount &quot; &lt;&lt; m_contentLayersCount);
 683 


 684 #if ENABLE(TREE_DEBUGGING)
 685     if (compositingLogEnabled())
 686         showPaintOrderTree(m_renderView.layer());
 687 #endif
 688 
 689     if (updateType == CompositingUpdateType::AfterStyleChange || updateType == CompositingUpdateType::AfterLayout)
 690         cacheAcceleratedCompositingFlagsAfterLayout(); // Some flags (e.g. forceCompositingMode) depend on layout.
 691 
 692     m_updateCompositingLayersTimer.stop();
 693 
<span class="line-modified"> 694     ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache</span>
<span class="line-modified"> 695         || m_renderView.document().pageCacheState() == Document::AboutToEnterPageCache);</span>
 696 
 697     // Compositing layers will be updated in Document::setVisualUpdatesAllowed(bool) if suppressed here.
 698     if (!m_renderView.document().visualUpdatesAllowed())
 699         return false;
 700 
 701     // Avoid updating the layers with old values. Compositing layers will be updated after the layout is finished.
 702     // This happens when m_updateCompositingLayersTimer fires before layout is updated.
 703     if (m_renderView.needsLayout()) {
 704         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; updateCompositingLayers &quot; &lt;&lt; updateType &lt;&lt; &quot; - m_renderView.needsLayout, bailing &quot;);
 705         return false;
 706     }
 707 
 708     if (!m_compositing &amp;&amp; (m_forceCompositingMode || (isMainFrameCompositor() &amp;&amp; page().pageOverlayController().overlayCount())))
 709         enableCompositingMode(true);
 710 
 711     bool isPageScroll = !updateRoot || updateRoot == &amp;rootRenderLayer();
 712     updateRoot = &amp;rootRenderLayer();
 713 
 714     if (updateType == CompositingUpdateType::OnScroll || updateType == CompositingUpdateType::OnCompositedScroll) {
 715         // We only get here if we didn&#39;t scroll on the scrolling thread, so this update needs to re-position viewport-constrained layers.
</pre>
<hr />
<pre>
 771         auto&amp; rootLayer = rootRenderLayer();
 772         CompositingState compositingState(updateRoot);
 773         BackingSharingState backingSharingState;
 774         LayerOverlapMap overlapMap(rootLayer);
 775 
 776         bool descendantHas3DTransform = false;
 777         computeCompositingRequirements(nullptr, rootLayer, overlapMap, compositingState, backingSharingState, descendantHas3DTransform);
 778     }
 779 
 780     LOG(Compositing, &quot;\nRenderLayerCompositor::updateCompositingLayers - mid&quot;);
 781 #if ENABLE(TREE_DEBUGGING)
 782     if (compositingLogEnabled())
 783         showPaintOrderTree(m_renderView.layer());
 784 #endif
 785 
 786     if (updateRoot-&gt;hasDescendantNeedingUpdateBackingOrHierarchyTraversal() || updateRoot-&gt;needsUpdateBackingOrHierarchyTraversal()) {
 787         ScrollingTreeState scrollingTreeState = { 0, 0 };
 788         if (!m_renderView.frame().isMainFrame())
 789             scrollingTreeState.parentNodeID = frameHostingNodeForFrame(m_renderView.frame());
 790 

 791         Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; childList;
<span class="line-modified"> 792         updateBackingAndHierarchy(*updateRoot, childList, scrollingTreeState);</span>
 793 
 794         // Host the document layer in the RenderView&#39;s root layer.
 795         appendDocumentOverlayLayers(childList);
 796         // Even when childList is empty, don&#39;t drop out of compositing mode if there are
 797         // composited layers that we didn&#39;t hit in our traversal (e.g. because of visibility:hidden).
 798         if (childList.isEmpty() &amp;&amp; !needsCompositingForContentOrOverlays())
 799             destroyRootLayer();
 800         else if (m_rootContentsLayer)
 801             m_rootContentsLayer-&gt;setChildren(WTFMove(childList));
 802     }
 803 
 804 #if !LOG_DISABLED
 805     if (compositingLogEnabled()) {
 806         MonotonicTime endTime = MonotonicTime::now();
 807         LOG(Compositing, &quot;Total layers   primary   secondary   obligatory backing (KB)   secondary backing(KB)   total backing (KB)  update time (ms)\n&quot;);
 808 
 809         LOG(Compositing, &quot;%8d %11d %9d %20.2f %22.2f %22.2f %18.2f\n&quot;,
 810             m_obligateCompositedLayerCount + m_secondaryCompositedLayerCount, m_obligateCompositedLayerCount,
 811             m_secondaryCompositedLayerCount, m_obligatoryBackingStoreBytes / 1024, m_secondaryBackingStoreBytes / 1024, (m_obligatoryBackingStoreBytes + m_secondaryBackingStoreBytes) / 1024, (endTime - startTime).milliseconds());
 812     }
</pre>
<hr />
<pre>
 821         showPaintOrderTree(m_renderView.layer());
 822     }
 823 #endif
 824 
 825     InspectorInstrumentation::layerTreeDidChange(&amp;page());
 826 
 827     return true;
 828 }
 829 
 830 static bool backingProviderLayerCanIncludeLayer(const RenderLayer&amp; sharedLayer, const RenderLayer&amp; layer)
 831 {
 832     // Disable sharing when painting shared layers doesn&#39;t work correctly.
 833     if (layer.hasReflection())
 834         return false;
 835 
 836     return layer.ancestorLayerIsInContainingBlockChain(sharedLayer);
 837 }
 838 
 839 void RenderLayerCompositor::computeCompositingRequirements(RenderLayer* ancestorLayer, RenderLayer&amp; layer, LayerOverlapMap&amp; overlapMap, CompositingState&amp; compositingState, BackingSharingState&amp; backingSharingState, bool&amp; descendantHas3DTransform)
 840 {



 841     if (!layer.hasDescendantNeedingCompositingRequirementsTraversal()
 842         &amp;&amp; !layer.needsCompositingRequirementsTraversal()
 843         &amp;&amp; !compositingState.fullPaintOrderTraversalRequired
 844         &amp;&amp; !compositingState.descendantsRequireCompositingUpdate) {
 845         traverseUnchangedSubtree(ancestorLayer, layer, overlapMap, compositingState, backingSharingState, descendantHas3DTransform);
 846         return;
 847     }
 848 
 849     LOG_WITH_STREAM(Compositing, stream &lt;&lt; TextStream::Repeat(compositingState.depth * 2, &#39; &#39;) &lt;&lt; &amp;layer &lt;&lt; (layer.isNormalFlowOnly() ? &quot; n&quot; : &quot; s&quot;) &lt;&lt; &quot; computeCompositingRequirements (backing provider candidate &quot; &lt;&lt; backingSharingState.backingProviderCandidate() &lt;&lt; &quot;)&quot;);
 850 
 851     // FIXME: maybe we can avoid updating all remaining layers in paint order.
 852     compositingState.fullPaintOrderTraversalRequired |= layer.needsCompositingRequirementsTraversal();
 853     compositingState.descendantsRequireCompositingUpdate |= layer.descendantsNeedCompositingRequirementsTraversal();
 854 
<span class="line-removed"> 855     layer.updateDescendantDependentFlags();</span>
<span class="line-removed"> 856     layer.updateLayerListsIfNeeded();</span>
<span class="line-removed"> 857 </span>
 858     layer.setHasCompositingDescendant(false);
 859 
 860     // We updated compositing for direct reasons in layerStyleChanged(). Here, check for compositing that can only be evaluated after layout.
 861     RequiresCompositingData queryData;
 862     bool willBeComposited = layer.isComposited();
 863     bool becameCompositedAfterDescendantTraversal = false;
 864     IndirectCompositingReason compositingReason = compositingState.subtreeIsCompositing ? IndirectCompositingReason::Stacking : IndirectCompositingReason::None;
 865 
 866     if (layer.needsPostLayoutCompositingUpdate() || compositingState.fullPaintOrderTraversalRequired || compositingState.descendantsRequireCompositingUpdate) {
 867         layer.setIndirectCompositingReason(IndirectCompositingReason::None);
 868         willBeComposited = needsToBeComposited(layer, queryData);
 869     }
 870 
 871     bool layerPaintsIntoProvidedBacking = false;
 872     if (!willBeComposited &amp;&amp; compositingState.subtreeIsCompositing &amp;&amp; backingSharingState.backingProviderCandidate() &amp;&amp; canBeComposited(layer) &amp;&amp; backingProviderLayerCanIncludeLayer(*backingSharingState.backingProviderCandidate(), layer)) {
 873         backingSharingState.appendSharingLayer(layer);
 874         LOG(Compositing, &quot; layer %p can share with %p&quot;, &amp;layer, backingSharingState.backingProviderCandidate());
 875         compositingReason = IndirectCompositingReason::None;
 876         layerPaintsIntoProvidedBacking = true;
 877     }
</pre>
<hr />
<pre>
 950         currentState.subtreeIsCompositing = true;
 951         becameCompositedAfterDescendantTraversal = true;
 952     };
 953 
 954     if (willBeComposited) {
 955         layerWillComposite();
 956 
 957         computeExtent(overlapMap, layer, layerExtent);
 958         currentState.ancestorHasTransformAnimation |= layerExtent.hasTransformAnimation;
 959         // Too hard to compute animated bounds if both us and some ancestor is animating transform.
 960         layerExtent.animationCausesExtentUncertainty |= layerExtent.hasTransformAnimation &amp;&amp; compositingState.ancestorHasTransformAnimation;
 961     } else if (layerPaintsIntoProvidedBacking) {
 962         currentState.backingSharingAncestor = &amp;layer;
 963         overlapMap.pushCompositingContainer();
 964         didPushOverlapContainer = true;
 965         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will share, pushed container &quot; &lt;&lt; overlapMap);
 966     }
 967 
 968     backingSharingState.updateBeforeDescendantTraversal(layer, willBeComposited);
 969 
<span class="line-modified"> 970 #if !ASSERT_DISABLED</span>
 971     LayerListMutationDetector mutationChecker(layer);
 972 #endif
 973 
 974     bool anyDescendantHas3DTransform = false;
 975     bool descendantsAddedToOverlap = currentState.hasNonRootCompositedAncestor();
 976 
 977     for (auto* childLayer : layer.negativeZOrderLayers()) {
 978         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
 979 
 980         // If we have to make a layer for this child, make one now so we can have a contents layer
 981         // (since we need to ensure that the -ve z-order child renders underneath our contents).
 982         if (!willBeComposited &amp;&amp; currentState.subtreeIsCompositing) {
 983             layer.setIndirectCompositingReason(IndirectCompositingReason::BackgroundLayer);
 984             layerWillComposite();
 985         }
 986     }
 987 
 988     for (auto* childLayer : layer.normalFlowLayers())
 989         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
 990 
</pre>
<hr />
<pre>
 994     // Set the flag to say that this layer has compositing children.
 995     layer.setHasCompositingDescendant(currentState.subtreeIsCompositing);
 996 
 997     // If we just entered compositing mode, the root will have become composited (as long as accelerated compositing is enabled).
 998     if (layer.isRenderViewLayer()) {
 999         if (usesCompositing() &amp;&amp; m_hasAcceleratedCompositing)
1000             willBeComposited = true;
1001     }
1002 
1003 #if ENABLE(CSS_COMPOSITING)
1004     bool isolatedCompositedBlending = layer.isolatesCompositedBlending();
1005     layer.setHasNotIsolatedCompositedBlendingDescendants(currentState.hasNotIsolatedCompositedBlendingDescendants);
1006     if (layer.isolatesCompositedBlending() != isolatedCompositedBlending) {
1007         // isolatedCompositedBlending affects the result of clippedByAncestor().
1008         layer.setChildrenNeedCompositingGeometryUpdate();
1009     }
1010 
1011     ASSERT(!layer.hasNotIsolatedCompositedBlendingDescendants() || layer.hasNotIsolatedBlendingDescendants());
1012 #endif
1013     // Now check for reasons to become composited that depend on the state of descendant layers.
<span class="line-modified">1014     IndirectCompositingReason indirectCompositingReason;</span>
<span class="line-modified">1015     if (!willBeComposited &amp;&amp; canBeComposited(layer)</span>
<span class="line-modified">1016         &amp;&amp; requiresCompositingForIndirectReason(layer, currentState.subtreeIsCompositing, anyDescendantHas3DTransform, layerPaintsIntoProvidedBacking, indirectCompositingReason)) {</span>
<span class="line-modified">1017         layer.setIndirectCompositingReason(indirectCompositingReason);</span>
<span class="line-modified">1018         layerWillCompositePostDescendants();</span>

1019     }
1020 
1021     if (layer.reflectionLayer()) {
1022         // FIXME: Shouldn&#39;t we call computeCompositingRequirements to handle a reflection overlapping with another renderer?
1023         layer.reflectionLayer()-&gt;setIndirectCompositingReason(willBeComposited ? IndirectCompositingReason::Stacking : IndirectCompositingReason::None);
1024     }
1025 
<span class="line-removed">1026     // setHasCompositingDescendant() may have changed the answer to needsToBeComposited() when clipping, so test that now.</span>
<span class="line-removed">1027     bool isCompositedClippingLayer = canBeComposited(layer) &amp;&amp; clipsCompositingDescendants(layer);</span>
<span class="line-removed">1028     if (isCompositedClippingLayer &amp; !willBeComposited)</span>
<span class="line-removed">1029         layerWillCompositePostDescendants();</span>
<span class="line-removed">1030 </span>
1031     // If we&#39;re back at the root, and no other layers need to be composited, and the root layer itself doesn&#39;t need
1032     // to be composited, then we can drop out of compositing mode altogether. However, don&#39;t drop out of compositing mode
1033     // if there are composited layers that we didn&#39;t hit in our traversal (e.g. because of visibility:hidden).
1034     RequiresCompositingData rootLayerQueryData;
1035     if (layer.isRenderViewLayer() &amp;&amp; !currentState.subtreeIsCompositing &amp;&amp; !requiresCompositingLayer(layer, rootLayerQueryData) &amp;&amp; !m_forceCompositingMode &amp;&amp; !needsCompositingForContentOrOverlays()) {
1036         // Don&#39;t drop out of compositing on iOS, because we may flash. See &lt;rdar://problem/8348337&gt;.
1037 #if !PLATFORM(IOS_FAMILY)
1038         enableCompositingMode(false);
1039         willBeComposited = false;
1040 #endif
1041     }
1042 
1043     ASSERT(willBeComposited == needsToBeComposited(layer, queryData));
1044 
1045     // Create or destroy backing here. However, we can&#39;t update geometry because layers above us may become composited
1046     // during post-order traversal (e.g. for clipping).
1047     if (updateBacking(layer, queryData, CompositingChangeRepaintNow, willBeComposited ? BackingRequired::Yes : BackingRequired::No)) {
1048         layer.setNeedsCompositingLayerConnection();
1049         // Child layers need to get a geometry update to recompute their position.
1050         layer.setChildrenNeedCompositingGeometryUpdate();
1051         // The composited bounds of enclosing layers depends on which descendants are composited, so they need a geometry update.
1052         layer.setNeedsCompositingGeometryUpdateOnAncestors();
1053     }
1054 
1055     // Update layer state bits.
<span class="line-modified">1056     if (layer.reflectionLayer() &amp;&amp; updateLayerCompositingState(*layer.reflectionLayer(), queryData, CompositingChangeRepaintNow))</span>
1057         layer.setNeedsCompositingLayerConnection();
1058 
1059     // FIXME: clarify needsCompositingPaintOrderChildrenUpdate. If a composited layer gets a new ancestor, it needs geometry computations.
1060     if (layer.needsCompositingPaintOrderChildrenUpdate()) {
1061         layer.setChildrenNeedCompositingGeometryUpdate();
1062         layer.setNeedsCompositingLayerConnection();
1063     }
1064 
1065     layer.clearCompositingRequirementsTraversalState();
1066 
1067     // Compute state passed to the caller.
1068     descendantHas3DTransform |= anyDescendantHas3DTransform || layer.has3DTransform();
1069     compositingState.updateWithDescendantStateAndLayer(currentState, layer, layerExtent);
1070     backingSharingState.updateAfterDescendantTraversal(layer, compositingState.stackingContextAncestor);
1071 
1072     bool layerContributesToOverlap = (currentState.compositingAncestor &amp;&amp; !currentState.compositingAncestor-&gt;isRenderViewLayer()) || currentState.backingSharingAncestor;
1073     updateOverlapMap(overlapMap, layer, layerExtent, didPushOverlapContainer, layerContributesToOverlap, becameCompositedAfterDescendantTraversal &amp;&amp; !descendantsAddedToOverlap);
1074 
1075     if (layer.isComposited())
1076         layer.backing()-&gt;updateAllowsBackingStoreDetaching(layerExtent.bounds);
1077 
1078     overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
1079 
1080     LOG_WITH_STREAM(Compositing, stream &lt;&lt; TextStream::Repeat(compositingState.depth * 2, &#39; &#39;) &lt;&lt; &amp;layer &lt;&lt; &quot; computeCompositingRequirements - willBeComposited &quot; &lt;&lt; willBeComposited &lt;&lt; &quot; (backing provider candidate &quot; &lt;&lt; backingSharingState.backingProviderCandidate() &lt;&lt; &quot;)&quot;);
1081 }
1082 
1083 // We have to traverse unchanged layers to fill in the overlap map.
1084 void RenderLayerCompositor::traverseUnchangedSubtree(RenderLayer* ancestorLayer, RenderLayer&amp; layer, LayerOverlapMap&amp; overlapMap, CompositingState&amp; compositingState, BackingSharingState&amp; backingSharingState, bool&amp; descendantHas3DTransform)
1085 {



1086     ASSERT(!compositingState.fullPaintOrderTraversalRequired);
1087     ASSERT(!layer.hasDescendantNeedingCompositingRequirementsTraversal());
1088     ASSERT(!layer.needsCompositingRequirementsTraversal());
1089 
1090     LOG_WITH_STREAM(Compositing, stream &lt;&lt; TextStream::Repeat(compositingState.depth * 2, &#39; &#39;) &lt;&lt; &amp;layer &lt;&lt; (layer.isNormalFlowOnly() ? &quot; n&quot; : &quot; s&quot;) &lt;&lt; &quot; traverseUnchangedSubtree&quot;);
1091 
<span class="line-removed">1092     layer.updateDescendantDependentFlags();</span>
<span class="line-removed">1093     layer.updateLayerListsIfNeeded();</span>
<span class="line-removed">1094 </span>
1095     bool layerIsComposited = layer.isComposited();
1096     bool layerPaintsIntoProvidedBacking = false;
1097     bool didPushOverlapContainer = false;
1098 
1099     OverlapExtent layerExtent;
1100     if (layerIsComposited &amp;&amp; !layer.isRenderViewLayer())
1101         layerExtent.hasTransformAnimation = isRunningTransformAnimation(layer.renderer());
1102 
1103     bool respectTransforms = !layerExtent.hasTransformAnimation;
1104     overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer, respectTransforms);
1105 
1106     // If we know for sure the layer is going to be composited, don&#39;t bother looking it up in the overlap map
1107     if (!layerIsComposited &amp;&amp; !overlapMap.isEmpty() &amp;&amp; compositingState.testingOverlap)
1108         computeExtent(overlapMap, layer, layerExtent);
1109 
1110     if (layer.paintsIntoProvidedBacking()) {
1111         ASSERT(backingSharingState.backingProviderCandidate());
1112         ASSERT(backingProviderLayerCanIncludeLayer(*backingSharingState.backingProviderCandidate(), layer));
1113         backingSharingState.appendSharingLayer(layer);
1114         layerPaintsIntoProvidedBacking = true;
</pre>
<hr />
<pre>
1123         // This layer now acts as the ancestor for kids.
1124         currentState.compositingAncestor = &amp;layer;
1125         currentState.backingSharingAncestor = nullptr;
1126         overlapMap.pushCompositingContainer();
1127         didPushOverlapContainer = true;
1128         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;unchangedSubtree: layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will composite, pushed container &quot; &lt;&lt; overlapMap);
1129 
1130         computeExtent(overlapMap, layer, layerExtent);
1131         currentState.ancestorHasTransformAnimation |= layerExtent.hasTransformAnimation;
1132         // Too hard to compute animated bounds if both us and some ancestor is animating transform.
1133         layerExtent.animationCausesExtentUncertainty |= layerExtent.hasTransformAnimation &amp;&amp; compositingState.ancestorHasTransformAnimation;
1134     } else if (layerPaintsIntoProvidedBacking) {
1135         overlapMap.pushCompositingContainer();
1136         currentState.backingSharingAncestor = &amp;layer;
1137         didPushOverlapContainer = true;
1138         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;unchangedSubtree: layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will share, pushed container &quot; &lt;&lt; overlapMap);
1139     }
1140 
1141     backingSharingState.updateBeforeDescendantTraversal(layer, layerIsComposited);
1142 
<span class="line-modified">1143 #if !ASSERT_DISABLED</span>
1144     LayerListMutationDetector mutationChecker(layer);
1145 #endif
1146 
1147     bool anyDescendantHas3DTransform = false;
1148 
1149     for (auto* childLayer : layer.negativeZOrderLayers()) {
1150         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
1151         if (currentState.subtreeIsCompositing)
1152             ASSERT(layerIsComposited);
1153     }
1154 
1155     for (auto* childLayer : layer.normalFlowLayers())
1156         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
1157 
1158     for (auto* childLayer : layer.positiveZOrderLayers())
1159         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
1160 
1161     // Set the flag to say that this layer has compositing children.
1162     ASSERT(layer.hasCompositingDescendant() == currentState.subtreeIsCompositing);
1163     ASSERT_IMPLIES(canBeComposited(layer) &amp;&amp; clipsCompositingDescendants(layer), layerIsComposited);
1164 
1165     descendantHas3DTransform |= anyDescendantHas3DTransform || layer.has3DTransform();
1166 
1167     ASSERT(!currentState.fullPaintOrderTraversalRequired);
1168     compositingState.updateWithDescendantStateAndLayer(currentState, layer, layerExtent, true);
1169     backingSharingState.updateAfterDescendantTraversal(layer, compositingState.stackingContextAncestor);
1170 
1171     bool layerContributesToOverlap = (currentState.compositingAncestor &amp;&amp; !currentState.compositingAncestor-&gt;isRenderViewLayer()) || currentState.backingSharingAncestor;
1172     updateOverlapMap(overlapMap, layer, layerExtent, didPushOverlapContainer, layerContributesToOverlap);
1173 
1174     overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
1175 
1176     ASSERT(!layer.needsCompositingRequirementsTraversal());
1177 }
1178 
<span class="line-modified">1179 void RenderLayerCompositor::updateBackingAndHierarchy(RenderLayer&amp; layer, Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; childLayersOfEnclosingLayer, ScrollingTreeState&amp; scrollingTreeState, OptionSet&lt;UpdateLevel&gt; updateLevel, int depth)</span>
1180 {
1181     layer.updateDescendantDependentFlags();
1182     layer.updateLayerListsIfNeeded();
1183 
1184     bool layerNeedsUpdate = !updateLevel.isEmpty();
1185     if (layer.descendantsNeedUpdateBackingAndHierarchyTraversal())
1186         updateLevel.add(UpdateLevel::AllDescendants);
1187 
<span class="line-modified">1188     ScrollingTreeState stateForDescendants = scrollingTreeState;</span>

1189 
1190     auto* layerBacking = layer.backing();
1191     if (layerBacking) {
1192         updateLevel.remove(UpdateLevel::CompositedChildren);
1193 
1194         // We updated the composited bounds in RenderLayerBacking::updateAfterLayout(), but it may have changed
1195         // based on which descendants are now composited.
1196         if (layerBacking-&gt;updateCompositedBounds()) {
1197             layer.setNeedsCompositingGeometryUpdate();
1198             // Our geometry can affect descendants.
1199             updateLevel.add(UpdateLevel::CompositedChildren);
1200         }
1201 
1202         if (layerNeedsUpdate || layer.needsCompositingConfigurationUpdate()) {
<span class="line-modified">1203             if (layerBacking-&gt;updateConfiguration()) {</span>
1204                 layerNeedsUpdate = true; // We also need to update geometry.
1205                 layer.setNeedsCompositingLayerConnection();
1206             }
1207 
1208             layerBacking-&gt;updateDebugIndicators(m_showDebugBorders, m_showRepaintCounter);
1209         }
1210 
1211         OptionSet&lt;ScrollingNodeChangeFlags&gt; scrollingNodeChanges = { ScrollingNodeChangeFlags::Layer };
1212         if (layerNeedsUpdate || layer.needsCompositingGeometryUpdate()) {
<span class="line-modified">1213             layerBacking-&gt;updateGeometry();</span>
1214             scrollingNodeChanges.add(ScrollingNodeChangeFlags::LayerGeometry);
1215         } else if (layer.needsScrollingTreeUpdate())
1216             scrollingNodeChanges.add(ScrollingNodeChangeFlags::LayerGeometry);
1217 
1218         // This needs to happen after any geometry update.
1219         // FIXME: Use separate bit for event region invalidation.
1220         if (layerNeedsUpdate || layer.needsCompositingConfigurationUpdate())
1221             layerBacking-&gt;updateEventRegion();
1222 
1223         if (auto* reflection = layer.reflectionLayer()) {
1224             if (auto* reflectionBacking = reflection-&gt;backing()) {
1225                 reflectionBacking-&gt;updateCompositedBounds();
<span class="line-modified">1226                 reflectionBacking-&gt;updateGeometry();</span>
1227                 reflectionBacking-&gt;updateAfterDescendants();
1228             }
1229         }
1230 
1231         if (!layer.parent())
1232             updateRootLayerPosition();
1233 
1234         // FIXME: do based on dirty flags. Need to do this for changes of geometry, configuration and hierarchy.
1235         // Need to be careful to do the right thing when a scroll-coordinated layer loses a scroll-coordinated ancestor.
<span class="line-modified">1236         stateForDescendants.parentNodeID = updateScrollCoordinationForLayer(layer, scrollingTreeState, scrollingNodeChanges);</span>
<span class="line-modified">1237         stateForDescendants.nextChildIndex = 0;</span>


1238 
1239 #if !LOG_DISABLED
<span class="line-modified">1240         logLayerInfo(layer, &quot;updateBackingAndHierarchy&quot;, depth);</span>
<span class="line-removed">1241 #else</span>
<span class="line-removed">1242         UNUSED_PARAM(depth);</span>
1243 #endif
1244     }
1245 
1246     if (layer.childrenNeedCompositingGeometryUpdate())
1247         updateLevel.add(UpdateLevel::CompositedChildren);
1248 
1249     // If this layer has backing, then we are collecting its children, otherwise appending
1250     // to the compositing child list of an enclosing layer.
1251     Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; layerChildren;
1252     auto&amp; childList = layerBacking ? layerChildren : childLayersOfEnclosingLayer;
1253 
1254     bool requireDescendantTraversal = layer.hasDescendantNeedingUpdateBackingOrHierarchyTraversal()
1255         || (layer.hasCompositingDescendant() &amp;&amp; (!layerBacking || layer.needsCompositingLayerConnection() || !updateLevel.isEmpty()));
1256 
1257     bool requiresChildRebuild = layerBacking &amp;&amp; layer.needsCompositingLayerConnection() &amp;&amp; !layer.hasCompositingDescendant();
1258 
<span class="line-modified">1259 #if !ASSERT_DISABLED</span>
1260     LayerListMutationDetector mutationChecker(layer);
1261 #endif
1262 
1263     auto appendForegroundLayerIfNecessary = [&amp;] {
1264         // If a negative z-order child is compositing, we get a foreground layer which needs to get parented.
1265         if (layer.negativeZOrderLayers().size()) {
1266             if (layerBacking &amp;&amp; layerBacking-&gt;foregroundLayer())
1267                 childList.append(*layerBacking-&gt;foregroundLayer());
1268         }
1269     };
1270 
1271     if (requireDescendantTraversal) {
1272         for (auto* renderLayer : layer.negativeZOrderLayers())
<span class="line-modified">1273             updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);</span>
1274 
1275         appendForegroundLayerIfNecessary();
1276 
1277         for (auto* renderLayer : layer.normalFlowLayers())
<span class="line-modified">1278             updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);</span>
1279 
1280         for (auto* renderLayer : layer.positiveZOrderLayers())
<span class="line-modified">1281             updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);</span>
1282     } else if (requiresChildRebuild)
1283         appendForegroundLayerIfNecessary();
1284 
1285     if (layerBacking) {
1286         if (requireDescendantTraversal || requiresChildRebuild) {
1287             bool parented = false;
1288             if (is&lt;RenderWidget&gt;(layer.renderer()))
1289                 parented = parentFrameContentLayers(downcast&lt;RenderWidget&gt;(layer.renderer()));
1290 
1291             if (!parented)
1292                 layerBacking-&gt;parentForSublayers()-&gt;setChildren(WTFMove(layerChildren));
1293 
1294             // If the layer has a clipping layer the overflow controls layers will be siblings of the clipping layer.
1295             // Otherwise, the overflow control layers are normal children.
1296             if (!layerBacking-&gt;hasClippingLayer() &amp;&amp; !layerBacking-&gt;hasScrollingLayer()) {
1297                 if (auto* overflowControlLayer = layerBacking-&gt;layerForHorizontalScrollbar())
1298                     layerBacking-&gt;parentForSublayers()-&gt;addChild(*overflowControlLayer);
1299 
1300                 if (auto* overflowControlLayer = layerBacking-&gt;layerForVerticalScrollbar())
1301                     layerBacking-&gt;parentForSublayers()-&gt;addChild(*overflowControlLayer);
</pre>
<hr />
<pre>
1351 #if !LOG_DISABLED
1352 void RenderLayerCompositor::logLayerInfo(const RenderLayer&amp; layer, const char* phase, int depth)
1353 {
1354     if (!compositingLogEnabled())
1355         return;
1356 
1357     auto* backing = layer.backing();
1358     RequiresCompositingData queryData;
1359     if (requiresCompositingLayer(layer, queryData) || layer.isRenderViewLayer()) {
1360         ++m_obligateCompositedLayerCount;
1361         m_obligatoryBackingStoreBytes += backing-&gt;backingStoreMemoryEstimate();
1362     } else {
1363         ++m_secondaryCompositedLayerCount;
1364         m_secondaryBackingStoreBytes += backing-&gt;backingStoreMemoryEstimate();
1365     }
1366 
1367     LayoutRect absoluteBounds = backing-&gt;compositedBounds();
1368     absoluteBounds.move(layer.offsetFromAncestor(m_renderView.layer()));
1369 
1370     StringBuilder logString;
<span class="line-modified">1371     logString.append(pad(&#39; &#39;, 12 + depth * 2, hex(reinterpret_cast&lt;uintptr_t&gt;(&amp;layer))), &quot; id &quot;, backing-&gt;graphicsLayer()-&gt;primaryLayerID(), &quot; (&quot;, FormattedNumber::fixedWidth(absoluteBounds.x().toFloat(), 3), &#39;,&#39;, FormattedNumber::fixedWidth(absoluteBounds.y().toFloat(), 3), &#39;-&#39;, FormattedNumber::fixedWidth(absoluteBounds.maxX().toFloat(), 3), &#39;,&#39;, FormattedNumber::fixedWidth(absoluteBounds.maxY().toFloat(), 3), &quot;) &quot;, FormattedNumber::fixedWidth(backing-&gt;backingStoreMemoryEstimate() / 1024, 2), &quot;KB&quot;);</span>
1372 
<span class="line-modified">1373     if (!layer.renderer().style().hasAutoZIndex())</span>
<span class="line-modified">1374         logString.append(&quot; z-index: &quot;, layer.renderer().style().zIndex());</span>
1375 
1376     logString.append(&quot; (&quot;, logReasonsForCompositing(layer), &quot;) &quot;);
1377 
1378     if (backing-&gt;graphicsLayer()-&gt;contentsOpaque() || backing-&gt;paintsIntoCompositedAncestor() || backing-&gt;foregroundLayer() || backing-&gt;backgroundLayer()) {
1379         logString.append(&#39;[&#39;);
1380         bool prependSpace = false;
1381         if (backing-&gt;graphicsLayer()-&gt;contentsOpaque()) {
1382             logString.appendLiteral(&quot;opaque&quot;);
1383             prependSpace = true;
1384         }
1385 
1386         if (backing-&gt;paintsIntoCompositedAncestor()) {
1387             if (prependSpace)
1388                 logString.appendLiteral(&quot;, &quot;);
1389             logString.appendLiteral(&quot;paints into ancestor&quot;);
1390             prependSpace = true;
1391         }
1392 
1393         if (backing-&gt;foregroundLayer() || backing-&gt;backgroundLayer()) {
1394             if (prependSpace)
</pre>
<hr />
<pre>
1673     // If a fixed position layer gained/lost a backing or the reason not compositing it changed,
1674     // the scrolling coordinator needs to recalculate whether it can do fast scrolling.
1675     if (layer.renderer().isFixedPositioned()) {
1676         if (layer.viewportConstrainedNotCompositedReason() != queryData.nonCompositedForPositionReason) {
1677             layer.setViewportConstrainedNotCompositedReason(queryData.nonCompositedForPositionReason);
1678             layerChanged = true;
1679         }
1680         if (layerChanged) {
1681             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
1682                 scrollingCoordinator-&gt;frameViewFixedObjectsDidChange(m_renderView.frameView());
1683         }
1684     } else
1685         layer.setViewportConstrainedNotCompositedReason(RenderLayer::NoNotCompositedReason);
1686 
1687     if (layer.backing())
1688         layer.backing()-&gt;updateDebugIndicators(m_showDebugBorders, m_showRepaintCounter);
1689 
1690     return layerChanged;
1691 }
1692 
<span class="line-modified">1693 bool RenderLayerCompositor::updateLayerCompositingState(RenderLayer&amp; layer, RequiresCompositingData&amp; queryData, CompositingChangeRepaint shouldRepaint)</span>
1694 {
1695     bool layerChanged = updateBacking(layer, queryData, shouldRepaint);
1696 
1697     // See if we need content or clipping layers. Methods called here should assume
1698     // that the compositing state of descendant layers has not been updated yet.
<span class="line-modified">1699     if (layer.backing() &amp;&amp; layer.backing()-&gt;updateConfiguration())</span>
1700         layerChanged = true;
1701 
1702     return layerChanged;
1703 }
1704 
1705 void RenderLayerCompositor::repaintOnCompositingChange(RenderLayer&amp; layer)
1706 {
1707     // If the renderer is not attached yet, no need to repaint.
1708     if (&amp;layer.renderer() != &amp;m_renderView &amp;&amp; !layer.renderer().parent())
1709         return;
1710 
1711     auto* repaintContainer = layer.renderer().containerForRepaint();
1712     if (!repaintContainer)
1713         repaintContainer = &amp;m_renderView;
1714 
1715     layer.repaintIncludingNonCompositingDescendants(repaintContainer);
1716     if (repaintContainer == &amp;m_renderView) {
1717         // The contents of this layer may be moving between the window
1718         // and a GraphicsLayer, so we need to make sure the window system
1719         // synchronizes those changes on the screen.
</pre>
<hr />
<pre>
1867     if (layer.isRenderViewLayer())
1868         return;
1869 
1870     computeExtent(overlapMap, layer, extent);
1871 
1872     // FIXME: constrain the scopes (by composited stacking context ancestor I think).
1873     auto clippingScopes = enclosingClippingScopes(layer, rootRenderLayer());
1874 
1875     LayoutRect clipRect;
1876     if (layer.hasCompositedScrollingAncestor()) {
1877         // Compute a clip up to the composited scrolling ancestor, then convert it to absolute coordinates.
1878         auto&amp; scrollingScope = clippingScopes.last();
1879         clipRect = layer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;scrollingScope.layer, TemporaryClipRects, IgnoreOverlayScrollbarSize, IgnoreOverflowClip)).rect();
1880         if (!clipRect.isInfinite())
1881             clipRect.setLocation(layer.convertToLayerCoords(&amp;rootRenderLayer(), clipRect.location()));
1882     } else
1883         clipRect = layer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;rootRenderLayer(), AbsoluteClipRects)).rect(); // FIXME: Incorrect for CSS regions.
1884 
1885     auto clippedBounds = extent.bounds;
1886     if (!clipRect.isInfinite()) {
<span class="line-modified">1887         // On iOS, pageScaleFactor() is not applied by RenderView, so we should not scale here.</span>
<span class="line-modified">1888         if (!m_renderView.settings().delegatesPageScaling())</span>
1889             clipRect.scale(pageScaleFactor());
1890 
1891         clippedBounds.intersect(clipRect);
1892     }
1893 
1894     overlapMap.add(layer, clippedBounds, clippingScopes);
1895 }
1896 
1897 void RenderLayerCompositor::addDescendantsToOverlapMapRecursive(LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, const RenderLayer* ancestorLayer) const
1898 {
1899     if (!canBeComposited(layer))
1900         return;
1901 
1902     // A null ancestorLayer is an indication that &#39;layer&#39; has already been pushed.
1903     if (ancestorLayer) {
1904         overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer);
1905 
1906         OverlapExtent layerExtent;
1907         addToOverlapMap(overlapMap, layer, layerExtent);
1908     }
1909 
<span class="line-modified">1910 #if !ASSERT_DISABLED</span>
1911     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(layer));
1912 #endif
1913 
1914     for (auto* renderLayer : layer.negativeZOrderLayers())
1915         addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);
1916 
1917     for (auto* renderLayer : layer.normalFlowLayers())
1918         addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);
1919 
1920     for (auto* renderLayer : layer.positiveZOrderLayers())
1921         addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);
1922 
1923     if (ancestorLayer)
1924         overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
1925 }
1926 
1927 void RenderLayerCompositor::updateOverlapMap(LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; layerExtent, bool didPushContainer, bool addLayerToOverlap, bool addDescendantsToOverlap) const
1928 {
1929     if (addLayerToOverlap) {
1930         addToOverlapMap(overlapMap, layer, layerExtent);
</pre>
<hr />
<pre>
2066     updateOverflowControlsLayers();
2067 }
2068 
2069 void RenderLayerCompositor::frameViewDidLayout()
2070 {
2071     if (auto* renderViewBacking = m_renderView.layer()-&gt;backing())
2072         renderViewBacking-&gt;adjustTiledBackingCoverage();
2073 }
2074 
2075 void RenderLayerCompositor::rootLayerConfigurationChanged()
2076 {
2077     auto* renderViewBacking = m_renderView.layer()-&gt;backing();
2078     if (renderViewBacking &amp;&amp; renderViewBacking-&gt;isFrameLayerWithTiledBacking()) {
2079         m_renderView.layer()-&gt;setNeedsCompositingConfigurationUpdate();
2080         scheduleCompositingLayerUpdate();
2081     }
2082 }
2083 
2084 String RenderLayerCompositor::layerTreeAsText(LayerTreeFlags flags)
2085 {

2086     updateCompositingLayers(CompositingUpdateType::AfterLayout);
2087 
2088     if (!m_rootContentsLayer)
2089         return String();
2090 
2091     flushPendingLayerChanges(true);
2092     page().renderingUpdateScheduler().scheduleImmediateRenderingUpdate();
2093 
2094     LayerTreeAsTextBehavior layerTreeBehavior = LayerTreeAsTextBehaviorNormal;
2095     if (flags &amp; LayerTreeFlagsIncludeDebugInfo)
2096         layerTreeBehavior |= LayerTreeAsTextDebug;
2097     if (flags &amp; LayerTreeFlagsIncludeVisibleRects)
2098         layerTreeBehavior |= LayerTreeAsTextIncludeVisibleRects;
2099     if (flags &amp; LayerTreeFlagsIncludeTileCaches)
2100         layerTreeBehavior |= LayerTreeAsTextIncludeTileCaches;
2101     if (flags &amp; LayerTreeFlagsIncludeRepaintRects)
2102         layerTreeBehavior |= LayerTreeAsTextIncludeRepaintRects;
2103     if (flags &amp; LayerTreeFlagsIncludePaintingPhases)
2104         layerTreeBehavior |= LayerTreeAsTextIncludePaintingPhases;
2105     if (flags &amp; LayerTreeFlagsIncludeContentLayers)
2106         layerTreeBehavior |= LayerTreeAsTextIncludeContentLayers;
2107     if (flags &amp; LayerTreeFlagsIncludeAcceleratesDrawing)
2108         layerTreeBehavior |= LayerTreeAsTextIncludeAcceleratesDrawing;
2109     if (flags &amp; LayerTreeFlagsIncludeClipping)
2110         layerTreeBehavior |= LayerTreeAsTextIncludeClipping;
2111     if (flags &amp; LayerTreeFlagsIncludeBackingStoreAttached)
2112         layerTreeBehavior |= LayerTreeAsTextIncludeBackingStoreAttached;
2113     if (flags &amp; LayerTreeFlagsIncludeRootLayerProperties)
2114         layerTreeBehavior |= LayerTreeAsTextIncludeRootLayerProperties;
2115     if (flags &amp; LayerTreeFlagsIncludeEventRegion)
2116         layerTreeBehavior |= LayerTreeAsTextIncludeEventRegion;


2117 
2118     // We skip dumping the scroll and clip layers to keep layerTreeAsText output
2119     // similar between platforms.
2120     String layerTreeText = m_rootContentsLayer-&gt;layerTreeAsText(layerTreeBehavior);
2121 
2122     // Dump an empty layer tree only if the only composited layer is the main frame&#39;s tiled backing,
2123     // so that tests expecting us to drop out of accelerated compositing when there are no layers succeed.
2124     if (!hasContentCompositingLayers() &amp;&amp; documentUsesTiledBacking() &amp;&amp; !(layerTreeBehavior &amp; LayerTreeAsTextIncludeTileCaches) &amp;&amp; !(layerTreeBehavior &amp; LayerTreeAsTextIncludeRootLayerProperties))
2125         layerTreeText = emptyString();
2126 
2127     // The true root layer is not included in the dump, so if we want to report
2128     // its repaint rects, they must be included here.
2129     if (flags &amp; LayerTreeFlagsIncludeRepaintRects)
2130         return m_renderView.frameView().trackedRepaintRectsAsText() + layerTreeText;
2131 
2132     return layerTreeText;
2133 }
2134 
2135 static RenderView* frameContentsRenderView(RenderWidget&amp; renderer)
2136 {
</pre>
<hr />
<pre>
2174         }
2175     }
2176 
2177     // FIXME: Why always return true and not just when the layers changed?
2178     return true;
2179 }
2180 
2181 void RenderLayerCompositor::repaintCompositedLayers()
2182 {
2183     recursiveRepaintLayer(rootRenderLayer());
2184 }
2185 
2186 void RenderLayerCompositor::recursiveRepaintLayer(RenderLayer&amp; layer)
2187 {
2188     layer.updateLayerListsIfNeeded();
2189 
2190     // FIXME: This method does not work correctly with transforms.
2191     if (layer.isComposited() &amp;&amp; !layer.backing()-&gt;paintsIntoCompositedAncestor())
2192         layer.setBackingNeedsRepaint();
2193 
<span class="line-modified">2194 #if !ASSERT_DISABLED</span>
2195     LayerListMutationDetector mutationChecker(layer);
2196 #endif
2197 
2198     if (layer.hasCompositingDescendant()) {
2199         for (auto* renderLayer : layer.negativeZOrderLayers())
2200             recursiveRepaintLayer(*renderLayer);
2201 
2202         for (auto* renderLayer : layer.positiveZOrderLayers())
2203             recursiveRepaintLayer(*renderLayer);
2204     }
2205 
2206     for (auto* renderLayer : layer.normalFlowLayers())
2207         recursiveRepaintLayer(*renderLayer);
2208 }
2209 
2210 RenderLayer&amp; RenderLayerCompositor::rootRenderLayer() const
2211 {
2212     return *m_renderView.layer();
2213 }
2214 
</pre>
<hr />
<pre>
2301 }
2302 
2303 bool RenderLayerCompositor::needsToBeComposited(const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
2304 {
2305     if (!canBeComposited(layer))
2306         return false;
2307 
2308     return requiresCompositingLayer(layer, queryData) || layer.mustCompositeForIndirectReasons() || (usesCompositing() &amp;&amp; layer.isRenderViewLayer());
2309 }
2310 
2311 // Note: this specifies whether the RL needs a compositing layer for intrinsic reasons.
2312 // Use needsToBeComposited() to determine if a RL actually needs a compositing layer.
2313 // FIXME: is clipsCompositingDescendants() an intrinsic reason?
2314 bool RenderLayerCompositor::requiresCompositingLayer(const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
2315 {
2316     auto&amp; renderer = rendererForCompositingTests(layer);
2317 
2318     // The root layer always has a compositing layer, but it may not have backing.
2319     return requiresCompositingForTransform(renderer)
2320         || requiresCompositingForAnimation(renderer)
<span class="line-removed">2321         || clipsCompositingDescendants(*renderer.layer())</span>
2322         || requiresCompositingForPosition(renderer, *renderer.layer(), queryData)
2323         || requiresCompositingForCanvas(renderer)
2324         || requiresCompositingForFilters(renderer)
2325         || requiresCompositingForWillChange(renderer)
2326         || requiresCompositingForBackfaceVisibility(renderer)
2327         || requiresCompositingForVideo(renderer)
2328         || requiresCompositingForFrame(renderer, queryData)
2329         || requiresCompositingForPlugin(renderer, queryData)
2330         || requiresCompositingForEditableImage(renderer)
2331         || requiresCompositingForOverflowScrolling(*renderer.layer(), queryData);
2332 }
2333 
2334 bool RenderLayerCompositor::canBeComposited(const RenderLayer&amp; layer) const
2335 {
2336     if (m_hasAcceleratedCompositing &amp;&amp; layer.isSelfPaintingLayer()) {
2337         if (!layer.isInsideFragmentedFlow())
2338             return true;
2339 
2340         // CSS Regions flow threads do not need to be composited as we use composited RenderFragmentContainers
2341         // to render the background of the RenderFragmentedFlow.
</pre>
<hr />
<pre>
2381         || layer.transform() // note: excludes perspective and transformStyle3D.
2382         || requiresCompositingForAnimation(renderer)
2383         || requiresCompositingForPosition(renderer, layer, queryData)
2384         || requiresCompositingForCanvas(renderer)
2385         || requiresCompositingForFilters(renderer)
2386         || requiresCompositingForWillChange(renderer)
2387         || requiresCompositingForBackfaceVisibility(renderer)
2388         || requiresCompositingForVideo(renderer)
2389         || requiresCompositingForFrame(renderer, queryData)
2390         || requiresCompositingForPlugin(renderer, queryData)
2391         || requiresCompositingForEditableImage(renderer)
2392         || requiresCompositingForOverflowScrolling(layer, queryData)
2393         || needsContentsCompositingLayer(layer)
2394         || renderer.isTransparent()
2395         || renderer.hasMask()
2396         || renderer.hasReflection()
2397         || renderer.hasFilter()
2398         || renderer.hasBackdropFilter())
2399         return true;
2400 







2401     if (layer.mustCompositeForIndirectReasons()) {
2402         IndirectCompositingReason reason = layer.indirectCompositingReason();
2403         return reason == IndirectCompositingReason::Overlap
2404             || reason == IndirectCompositingReason::OverflowScrollPositioning
2405             || reason == IndirectCompositingReason::Stacking
2406             || reason == IndirectCompositingReason::BackgroundLayer
2407             || reason == IndirectCompositingReason::GraphicalEffect
2408             || reason == IndirectCompositingReason::Preserve3D; // preserve-3d has to create backing store to ensure that 3d-transformed elements intersect.
2409     }
2410 
<span class="line-removed">2411     if (!ancestorCompositedBounds.contains(layerCompositedBoundsInAncestor))</span>
<span class="line-removed">2412         return true;</span>
<span class="line-removed">2413 </span>
<span class="line-removed">2414     if (layer.isComposited() &amp;&amp; layer.backing()-&gt;hasBackingSharingLayers())</span>
<span class="line-removed">2415         return true;</span>
<span class="line-removed">2416 </span>
2417     return false;
2418 }
2419 
2420 OptionSet&lt;CompositingReason&gt; RenderLayerCompositor::reasonsForCompositing(const RenderLayer&amp; layer) const
2421 {
2422     OptionSet&lt;CompositingReason&gt; reasons;
2423 
2424     if (!layer.isComposited())
2425         return reasons;
2426 
2427     RequiresCompositingData queryData;
2428 
2429     auto&amp; renderer = rendererForCompositingTests(layer);
2430 
2431     if (requiresCompositingForTransform(renderer))
2432         reasons.add(CompositingReason::Transform3D);
2433 
2434     if (requiresCompositingForVideo(renderer))
2435         reasons.add(CompositingReason::Video);
2436     else if (requiresCompositingForCanvas(renderer))
2437         reasons.add(CompositingReason::Canvas);
2438     else if (requiresCompositingForPlugin(renderer, queryData))
2439         reasons.add(CompositingReason::Plugin);
2440     else if (requiresCompositingForFrame(renderer, queryData))
2441         reasons.add(CompositingReason::IFrame);
2442     else if (requiresCompositingForEditableImage(renderer))
2443         reasons.add(CompositingReason::EmbeddedView);
2444 
2445     if ((canRender3DTransforms() &amp;&amp; renderer.style().backfaceVisibility() == BackfaceVisibility::Hidden))
2446         reasons.add(CompositingReason::BackfaceVisibilityHidden);
2447 
<span class="line-removed">2448     if (clipsCompositingDescendants(*renderer.layer()))</span>
<span class="line-removed">2449         reasons.add(CompositingReason::ClipsCompositingDescendants);</span>
<span class="line-removed">2450 </span>
2451     if (requiresCompositingForAnimation(renderer))
2452         reasons.add(CompositingReason::Animation);
2453 
2454     if (requiresCompositingForFilters(renderer))
2455         reasons.add(CompositingReason::Filters);
2456 
2457     if (requiresCompositingForWillChange(renderer))
2458         reasons.add(CompositingReason::WillChange);
2459 
2460     if (requiresCompositingForPosition(renderer, *renderer.layer(), queryData))
2461         reasons.add(renderer.isFixedPositioned() ? CompositingReason::PositionFixed : CompositingReason::PositionSticky);
2462 
2463     if (requiresCompositingForOverflowScrolling(*renderer.layer(), queryData))
2464         reasons.add(CompositingReason::OverflowScrolling);
2465 
2466     switch (renderer.layer()-&gt;indirectCompositingReason()) {
2467     case IndirectCompositingReason::None:
2468         break;



2469     case IndirectCompositingReason::Stacking:
2470         reasons.add(CompositingReason::Stacking);
2471         break;
2472     case IndirectCompositingReason::OverflowScrollPositioning:
2473         reasons.add(CompositingReason::OverflowScrollPositioning);
2474         break;
2475     case IndirectCompositingReason::Overlap:
2476         reasons.add(CompositingReason::Overlap);
2477         break;
2478     case IndirectCompositingReason::BackgroundLayer:
2479         reasons.add(CompositingReason::NegativeZIndexChildren);
2480         break;
2481     case IndirectCompositingReason::GraphicalEffect:
2482         if (renderer.hasTransform())
2483             reasons.add(CompositingReason::TransformWithCompositedDescendants);
2484 
2485         if (renderer.isTransparent())
2486             reasons.add(CompositingReason::OpacityWithCompositedDescendants);
2487 
2488         if (renderer.hasMask())
</pre>
<hr />
<pre>
2735         return AncestorTraversal::Continue;
2736     });
2737 
2738     return containerScrollingNodeID;
2739 }
2740 
2741 // Return true if the given layer is a stacking context and has compositing child
2742 // layers that it needs to clip. In this case we insert a clipping GraphicsLayer
2743 // into the hierarchy between this layer and its children in the z-order hierarchy.
2744 bool RenderLayerCompositor::clipsCompositingDescendants(const RenderLayer&amp; layer)
2745 {
2746     return layer.hasCompositingDescendant() &amp;&amp; layer.renderer().hasClipOrOverflowClip() &amp;&amp; !layer.isolatesCompositedBlending();
2747 }
2748 
2749 bool RenderLayerCompositor::requiresCompositingForAnimation(RenderLayerModelObject&amp; renderer) const
2750 {
2751     if (!(m_compositingTriggers &amp; ChromeClient::AnimationTrigger))
2752         return false;
2753 
2754     if (auto* element = renderer.element()) {
<span class="line-modified">2755         if (auto* timeline = element-&gt;document().existingTimeline()) {</span>
<span class="line-modified">2756             if (timeline-&gt;runningAnimationsForElementAreAllAccelerated(*element))</span>
<span class="line-modified">2757                 return true;</span>





2758         }
2759     }
2760 
2761     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
2762         return false;
2763 
2764     auto&amp; animController = renderer.animation();
2765     return (animController.isRunningAnimationOnRenderer(renderer, CSSPropertyOpacity)
2766         &amp;&amp; (usesCompositing() || (m_compositingTriggers &amp; ChromeClient::AnimatedOpacityTrigger)))
2767         || animController.isRunningAnimationOnRenderer(renderer, CSSPropertyFilter)
2768 #if ENABLE(FILTERS_LEVEL_2)
2769         || animController.isRunningAnimationOnRenderer(renderer, CSSPropertyWebkitBackdropFilter)
2770 #endif
2771         || animController.isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
2772 }
2773 
2774 bool RenderLayerCompositor::requiresCompositingForTransform(RenderLayerModelObject&amp; renderer) const
2775 {
2776     if (!(m_compositingTriggers &amp; ChromeClient::ThreeDTransformTrigger))
2777         return false;
</pre>
<hr />
<pre>
2933     if (frameRenderer.style().visibility() != Visibility::Visible)
2934         return false;
2935 
2936     if (!frameRenderer.requiresAcceleratedCompositing())
2937         return false;
2938 
2939     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
2940         queryData.reevaluateAfterLayout = true;
2941         return frameRenderer.isComposited();
2942     }
2943 
2944     // Don&#39;t go into compositing mode if height or width are zero.
2945     return !snappedIntRect(frameRenderer.contentBoxRect()).isEmpty();
2946 }
2947 
2948 bool RenderLayerCompositor::requiresCompositingForScrollableFrame(RequiresCompositingData&amp; queryData) const
2949 {
2950     if (isMainFrameCompositor())
2951         return false;
2952 
<span class="line-modified">2953 #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)</span>
2954     if (!m_renderView.settings().asyncFrameScrollingEnabled())
2955         return false;
2956 #endif
2957 
2958     if (!(m_compositingTriggers &amp; ChromeClient::ScrollableNonMainFrameTrigger))
2959         return false;
2960 
2961     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
2962         queryData.reevaluateAfterLayout = true;
2963         return m_renderView.isComposited();
2964     }
2965 
2966     return m_renderView.frameView().isScrollable();
2967 }
2968 
2969 bool RenderLayerCompositor::requiresCompositingForPosition(RenderLayerModelObject&amp; renderer, const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
2970 {
2971     // position:fixed elements that create their own stacking context (e.g. have an explicit z-index,
2972     // opacity, transform) can get their own composited layer. A stacking context is required otherwise
2973     // z-index and clipping will be broken.
</pre>
<hr />
<pre>
3022         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; is outside the viewport&quot;);
3023         return false;
3024     }
3025 
3026     return true;
3027 }
3028 
3029 bool RenderLayerCompositor::requiresCompositingForOverflowScrolling(const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
3030 {
3031     if (!layer.canUseCompositedScrolling())
3032         return false;
3033 
3034     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
3035         queryData.reevaluateAfterLayout = true;
3036         return layer.isComposited();
3037     }
3038 
3039     return layer.hasCompositedScrollableOverflow();
3040 }
3041 
<span class="line-modified">3042 // FIXME: why doesn&#39;t this handle the clipping cases?</span>
<span class="line-removed">3043 bool RenderLayerCompositor::requiresCompositingForIndirectReason(const RenderLayer&amp; layer, bool hasCompositedDescendants, bool has3DTransformedDescendants, bool paintsIntoProvidedBacking, IndirectCompositingReason&amp; reason) const</span>
3044 {
3045     // When a layer has composited descendants, some effects, like 2d transforms, filters, masks etc must be implemented
3046     // via compositing so that they also apply to those composited descendants.
3047     auto&amp; renderer = layer.renderer();
<span class="line-modified">3048     if (hasCompositedDescendants &amp;&amp; (layer.isolatesCompositedBlending() || layer.transform() || renderer.createsGroup() || renderer.hasReflection())) {</span>
<span class="line-modified">3049         reason = IndirectCompositingReason::GraphicalEffect;</span>
<span class="line-removed">3050         return true;</span>
<span class="line-removed">3051     }</span>
3052 
3053     // A layer with preserve-3d or perspective only needs to be composited if there are descendant layers that
3054     // will be affected by the preserve-3d or perspective.
3055     if (has3DTransformedDescendants) {
<span class="line-modified">3056         if (renderer.style().transformStyle3D() == TransformStyle3D::Preserve3D) {</span>
<span class="line-modified">3057             reason = IndirectCompositingReason::Preserve3D;</span>
<span class="line-removed">3058             return true;</span>
<span class="line-removed">3059         }</span>
3060 
<span class="line-modified">3061         if (renderer.style().hasPerspective()) {</span>
<span class="line-modified">3062             reason = IndirectCompositingReason::Perspective;</span>
<span class="line-removed">3063             return true;</span>
<span class="line-removed">3064         }</span>
3065     }
3066 
3067     // If this layer scrolls independently from the layer that it would paint into, it needs to get composited.
3068     if (!paintsIntoProvidedBacking &amp;&amp; layer.hasCompositedScrollingAncestor()) {
3069         auto* paintDestination = layer.paintOrderParent();
<span class="line-modified">3070         if (paintDestination &amp;&amp; layerScrollBehahaviorRelativeToCompositedAncestor(layer, *paintDestination) != ScrollPositioningBehavior::None) {</span>
<span class="line-modified">3071             reason = IndirectCompositingReason::OverflowScrollPositioning;</span>
<span class="line-removed">3072             return true;</span>
<span class="line-removed">3073         }</span>
3074     }
3075 
<span class="line-modified">3076     reason = IndirectCompositingReason::None;</span>
<span class="line-modified">3077     return false;</span>



3078 }
3079 
3080 bool RenderLayerCompositor::styleChangeMayAffectIndirectCompositingReasons(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
3081 {
3082     if (RenderElement::createsGroupForStyle(newStyle) != RenderElement::createsGroupForStyle(oldStyle))
3083         return true;
3084     if (newStyle.isolation() != oldStyle.isolation())
3085         return true;
3086     if (newStyle.hasTransform() != oldStyle.hasTransform())
3087         return true;
3088     if (newStyle.boxReflect() != oldStyle.boxReflect())
3089         return true;
3090     if (newStyle.transformStyle3D() != oldStyle.transformStyle3D())
3091         return true;
3092     if (newStyle.hasPerspective() != oldStyle.hasPerspective())
3093         return true;
3094 
3095     return false;
3096 }
3097 
</pre>
<hr />
<pre>
3232         if (scrollingNodeID)
3233             scrollingNodes.append(scrollingNodeID);
3234         else
3235             LOG(Scrolling, &quot;Layer %p doesn&#39;t have scrolling node ID yet&quot;, &amp;overflowLayer);
3236     };
3237 
3238     // Collect all the composited scrollers which affect the position of this layer relative to its compositing ancestor (which might be inside the scroller or the scroller itself).
3239     bool seenPaintOrderAncestor = false;
3240     traverseAncestorLayers(layer, [&amp;](const RenderLayer&amp; ancestorLayer, bool isContainingBlockChain, bool isPaintOrderAncestor) {
3241         seenPaintOrderAncestor |= isPaintOrderAncestor;
3242         if (isContainingBlockChain &amp;&amp; isPaintOrderAncestor)
3243             return AncestorTraversal::Stop;
3244 
3245         if (seenPaintOrderAncestor &amp;&amp; !isContainingBlockChain &amp;&amp; ancestorLayer.hasCompositedScrollableOverflow())
3246             appendOverflowLayerNodeID(ancestorLayer);
3247 
3248         return AncestorTraversal::Continue;
3249     });
3250 }
3251 
<span class="line-modified">3252 ScrollPositioningBehavior RenderLayerCompositor::computeCoordinatedPositioningForLayer(const RenderLayer&amp; layer) const</span>
3253 {
3254     if (layer.isRenderViewLayer())
3255         return ScrollPositioningBehavior::None;
3256 
3257     if (layer.renderer().isFixedPositioned())
3258         return ScrollPositioningBehavior::None;
3259 
3260     if (!layer.hasCompositedScrollingAncestor())
3261         return ScrollPositioningBehavior::None;
3262 
3263     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
3264     if (!scrollingCoordinator)
3265         return ScrollPositioningBehavior::None;
3266 
<span class="line-removed">3267     auto* compositedAncestor = layer.ancestorCompositingLayer();</span>
3268     if (!compositedAncestor) {
3269         ASSERT_NOT_REACHED();
3270         return ScrollPositioningBehavior::None;
3271     }
3272 
3273     return layerScrollBehahaviorRelativeToCompositedAncestor(layer, *compositedAncestor);
3274 }
3275 
3276 static Vector&lt;ScrollingNodeID&gt; collectRelatedCoordinatedScrollingNodes(const RenderLayer&amp; layer, ScrollPositioningBehavior positioningBehavior)
3277 {
3278     Vector&lt;ScrollingNodeID&gt; overflowNodeIDs;
3279 
3280     switch (positioningBehavior) {
3281     case ScrollPositioningBehavior::Stationary: {
3282         auto* compositedAncestor = layer.ancestorCompositingLayer();
3283         if (!compositedAncestor)
3284             return overflowNodeIDs;
3285         collectStationaryLayerRelatedOverflowNodes(layer, *compositedAncestor, overflowNodeIDs);
3286         break;
3287     }
</pre>
<hr />
<pre>
3301 
3302     auto* contentDocument = downcast&lt;RenderWidget&gt;(layer.renderer()).frameOwnerElement().contentDocument();
3303     if (!contentDocument)
3304         return false;
3305 
3306     auto* view = contentDocument-&gt;renderView();
3307     if (!view)
3308         return false;
3309 
3310     if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3311         return scrollingCoordinator-&gt;coordinatesScrollingForFrameView(view-&gt;frameView());
3312 
3313     return false;
3314 }
3315 
3316 bool RenderLayerCompositor::isRunningTransformAnimation(RenderLayerModelObject&amp; renderer) const
3317 {
3318     if (!(m_compositingTriggers &amp; ChromeClient::AnimationTrigger))
3319         return false;
3320 
<span class="line-modified">3321     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {</span>
<span class="line-modified">3322         if (auto* element = renderer.element()) {</span>
<span class="line-modified">3323             if (auto* timeline = element-&gt;document().existingTimeline())</span>
<span class="line-removed">3324                 return timeline-&gt;isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);</span>
<span class="line-removed">3325         }</span>
<span class="line-removed">3326         return false;</span>
3327     }




3328     return renderer.animation().isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
3329 }
3330 
3331 // If an element has composited negative z-index children, those children render in front of the
3332 // layer background, so we need an extra &#39;contents&#39; layer for the foreground of the layer object.
3333 bool RenderLayerCompositor::needsContentsCompositingLayer(const RenderLayer&amp; layer) const
3334 {
3335     for (auto* layer : layer.negativeZOrderLayers()) {
3336         if (layer-&gt;isComposited() || layer-&gt;hasCompositingDescendant())
3337             return true;
3338     }
3339 
3340     return false;
3341 }
3342 
3343 bool RenderLayerCompositor::requiresScrollLayer(RootLayerAttachment attachment) const
3344 {
3345     auto&amp; frameView = m_renderView.frameView();
3346 
3347     // This applies when the application UI handles scrolling, in which case RenderLayerCompositor doesn&#39;t need to manage it.
</pre>
<hr />
<pre>
3350 
3351     // We need to handle our own scrolling if we&#39;re:
3352     return !m_renderView.frameView().platformWidget() // viewless (i.e. non-Mac, or Mac in WebKit2)
3353         || attachment == RootLayerAttachedViaEnclosingFrame; // a composited frame on Mac
3354 }
3355 
3356 void paintScrollbar(Scrollbar* scrollbar, GraphicsContext&amp; context, const IntRect&amp; clip)
3357 {
3358     if (!scrollbar)
3359         return;
3360 
3361     context.save();
3362     const IntRect&amp; scrollbarRect = scrollbar-&gt;frameRect();
3363     context.translate(-scrollbarRect.location());
3364     IntRect transformedClip = clip;
3365     transformedClip.moveBy(scrollbarRect.location());
3366     scrollbar-&gt;paint(context, transformedClip);
3367     context.restore();
3368 }
3369 
<span class="line-modified">3370 void RenderLayerCompositor::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, OptionSet&lt;GraphicsLayerPaintingPhase&gt;, const FloatRect&amp; clip, GraphicsLayerPaintBehavior)</span>
3371 {
3372 #if PLATFORM(MAC)
3373     LocalDefaultSystemAppearance localAppearance(m_renderView.useDarkAppearance());
3374 #endif
3375 
3376     IntRect pixelSnappedRectForIntegralPositionedItems = snappedIntRect(LayoutRect(clip));
3377     if (graphicsLayer == layerForHorizontalScrollbar())
3378         paintScrollbar(m_renderView.frameView().horizontalScrollbar(), context, pixelSnappedRectForIntegralPositionedItems);
3379     else if (graphicsLayer == layerForVerticalScrollbar())
3380         paintScrollbar(m_renderView.frameView().verticalScrollbar(), context, pixelSnappedRectForIntegralPositionedItems);
3381     else if (graphicsLayer == layerForScrollCorner()) {
3382         const IntRect&amp; scrollCorner = m_renderView.frameView().scrollCornerRect();
3383         context.save();
3384         context.translate(-scrollCorner.location());
3385         IntRect transformedClip = pixelSnappedRectForIntegralPositionedItems;
3386         transformedClip.moveBy(scrollCorner.location());
3387         m_renderView.frameView().paintScrollCorner(context, transformedClip);
3388         context.restore();
3389     }
3390 }
</pre>
<hr />
<pre>
4077     m_rootContentsLayer-&gt;addChild(WTFMove(overlayHost));
4078 }
4079 
4080 void RenderLayerCompositor::notifyIFramesOfCompositingChange()
4081 {
4082     // Compositing affects the answer to RenderIFrame::requiresAcceleratedCompositing(), so
4083     // we need to schedule a style recalc in our parent document.
4084     if (auto* ownerElement = m_renderView.document().ownerElement())
4085         ownerElement-&gt;scheduleInvalidateStyleAndLayerComposition();
4086 }
4087 
4088 bool RenderLayerCompositor::layerHas3DContent(const RenderLayer&amp; layer) const
4089 {
4090     const RenderStyle&amp; style = layer.renderer().style();
4091 
4092     if (style.transformStyle3D() == TransformStyle3D::Preserve3D || style.hasPerspective() || style.transform().has3DOperation())
4093         return true;
4094 
4095     const_cast&lt;RenderLayer&amp;&gt;(layer).updateLayerListsIfNeeded();
4096 
<span class="line-modified">4097 #if !ASSERT_DISABLED</span>
4098     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(layer));
4099 #endif
4100 
4101     for (auto* renderLayer : layer.negativeZOrderLayers()) {
4102         if (layerHas3DContent(*renderLayer))
4103             return true;
4104     }
4105 
4106     for (auto* renderLayer : layer.positiveZOrderLayers()) {
4107         if (layerHas3DContent(*renderLayer))
4108             return true;
4109     }
4110 
4111     for (auto* renderLayer : layer.normalFlowLayers()) {
4112         if (layerHas3DContent(*renderLayer))
4113             return true;
4114     }
4115 
4116     return false;
4117 }
</pre>
<hr />
<pre>
4302     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4303 
4304     if (roles.contains(ScrollCoordinationRole::Scrolling))
4305         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::Scrolling);
4306 
4307     if (roles.contains(ScrollCoordinationRole::ScrollingProxy))
4308         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::ScrollingProxy);
4309 
4310     if (roles.contains(ScrollCoordinationRole::FrameHosting))
4311         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::FrameHosting);
4312 
4313     if (roles.contains(ScrollCoordinationRole::ViewportConstrained))
4314         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::ViewportConstrained);
4315 
4316     if (roles.contains(ScrollCoordinationRole::Positioning))
4317         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::Positioning);
4318 
4319     backing-&gt;detachFromScrollingCoordinator(roles);
4320 }
4321 
<span class="line-modified">4322 OptionSet&lt;ScrollCoordinationRole&gt; RenderLayerCompositor::coordinatedScrollingRolesForLayer(const RenderLayer&amp; layer) const</span>
4323 {
4324     OptionSet&lt;ScrollCoordinationRole&gt; coordinationRoles;
4325     if (isViewportConstrainedFixedOrStickyLayer(layer))
4326         coordinationRoles.add(ScrollCoordinationRole::ViewportConstrained);
4327 
4328     if (useCoordinatedScrollingForLayer(layer))
4329         coordinationRoles.add(ScrollCoordinationRole::Scrolling);
4330 
<span class="line-modified">4331     auto coordinatedPositioning = computeCoordinatedPositioningForLayer(layer);</span>
4332     switch (coordinatedPositioning) {
4333     case ScrollPositioningBehavior::Moves:
4334         coordinationRoles.add(ScrollCoordinationRole::ScrollingProxy);
4335         break;
4336     case ScrollPositioningBehavior::Stationary:
4337         coordinationRoles.add(ScrollCoordinationRole::Positioning);
4338         break;
4339     case ScrollPositioningBehavior::None:
4340         break;
4341     }
4342 
4343     if (isLayerForIFrameWithScrollCoordinatedContents(layer))
4344         coordinationRoles.add(ScrollCoordinationRole::FrameHosting);
4345 
4346     return coordinationRoles;
4347 }
4348 
<span class="line-modified">4349 ScrollingNodeID RenderLayerCompositor::updateScrollCoordinationForLayer(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)</span>
4350 {
<span class="line-modified">4351     auto roles = coordinatedScrollingRolesForLayer(layer);</span>
4352 
4353 #if PLATFORM(IOS_FAMILY)
4354     if (m_legacyScrollingLayerCoordinator) {
4355         if (roles.contains(ScrollCoordinationRole::ViewportConstrained))
4356             m_legacyScrollingLayerCoordinator-&gt;addViewportConstrainedLayer(layer);
4357         else
4358             m_legacyScrollingLayerCoordinator-&gt;removeViewportConstrainedLayer(layer);
4359     }
4360 #endif
4361 
4362     if (!hasCoordinatedScrolling()) {
4363         // If this frame isn&#39;t coordinated, it cannot contain any scrolling tree nodes.
4364         return 0;
4365     }
4366 
4367     auto newNodeID = treeState.parentNodeID.valueOr(0);
4368 
4369     ScrollingTreeState childTreeState;
4370     ScrollingTreeState* currentTreeState = &amp;treeState;
4371 
4372     // If there&#39;s a positioning node, it&#39;s the parent scrolling node for fixed/sticky/scrolling/frame hosting.
4373     if (roles.contains(ScrollCoordinationRole::Positioning)) {
<span class="line-modified">4374         newNodeID = updateScrollingNodeForPositioningRole(layer, *currentTreeState, changes);</span>
4375         childTreeState.parentNodeID = newNodeID;
4376         currentTreeState = &amp;childTreeState;
4377     } else
4378         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::Positioning);
4379 
4380     // If there&#39;s a scrolling proxy node, it&#39;s the parent scrolling node for fixed/sticky/scrolling/frame hosting.
4381     if (roles.contains(ScrollCoordinationRole::ScrollingProxy)) {
4382         newNodeID = updateScrollingNodeForScrollingProxyRole(layer, *currentTreeState, changes);
4383         childTreeState.parentNodeID = newNodeID;
4384         currentTreeState = &amp;childTreeState;
4385     } else
4386         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::ScrollingProxy);
4387 
4388     // If is fixed or sticky, it&#39;s the parent scrolling node for scrolling/frame hosting.
4389     if (roles.contains(ScrollCoordinationRole::ViewportConstrained)) {
4390         newNodeID = updateScrollingNodeForViewportConstrainedRole(layer, *currentTreeState, changes);
4391         // ViewportConstrained nodes are the parent of same-layer scrolling nodes, so adjust the ScrollingTreeState.
4392         childTreeState.parentNodeID = newNodeID;
4393         currentTreeState = &amp;childTreeState;
4394     } else
</pre>
<hr />
<pre>
4580 {
4581     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4582 
4583     auto newNodeID = attachScrollingNode(layer, ScrollingNodeType::FrameHosting, treeState);
4584     if (!newNodeID) {
4585         ASSERT_NOT_REACHED();
4586         return treeState.parentNodeID.valueOr(0);
4587     }
4588 
4589     if (changes &amp; ScrollingNodeChangeFlags::Layer)
4590         scrollingCoordinator-&gt;setNodeLayers(newNodeID, { layer.backing()-&gt;graphicsLayer() });
4591 
4592     if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
4593         RenderLayer* scrollingAncestorLayer = m_scrollingNodeToLayerMap.get(treeState.parentNodeID.value());
4594         scrollingCoordinator-&gt;setRectRelativeToParentNode(newNodeID, parentRelativeScrollableRect(layer, scrollingAncestorLayer));
4595     }
4596 
4597     return newNodeID;
4598 }
4599 
<span class="line-modified">4600 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForPositioningRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)</span>
4601 {
4602     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4603 
4604     auto newNodeID = attachScrollingNode(layer, ScrollingNodeType::Positioned, treeState);
4605     if (!newNodeID) {
4606         ASSERT_NOT_REACHED();
4607         return treeState.parentNodeID.valueOr(0);
4608     }
4609 
4610     if (changes &amp; ScrollingNodeChangeFlags::Layer) {
4611         auto&amp; backing = *layer.backing();
4612         scrollingCoordinator-&gt;setNodeLayers(newNodeID, { backing.graphicsLayer() });
4613     }
4614 
4615     if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
4616         // Would be nice to avoid calling computeCoordinatedPositioningForLayer() again.
<span class="line-modified">4617         auto positioningBehavior = computeCoordinatedPositioningForLayer(layer);</span>
4618         auto relatedNodeIDs = collectRelatedCoordinatedScrollingNodes(layer, positioningBehavior);
4619         scrollingCoordinator-&gt;setRelatedOverflowScrollingNodes(newNodeID, WTFMove(relatedNodeIDs));
4620 
4621         auto* graphicsLayer = layer.backing()-&gt;graphicsLayer();
4622         AbsolutePositionConstraints constraints;
4623         constraints.setAlignmentOffset(graphicsLayer-&gt;pixelAlignmentOffset());
4624         constraints.setLayerPositionAtLastLayout(graphicsLayer-&gt;position());
4625         scrollingCoordinator-&gt;setPositionedNodeConstraints(newNodeID, constraints);
4626     }
4627 
4628     return newNodeID;
4629 }
4630 
4631 ScrollableArea* RenderLayerCompositor::scrollableAreaForScrollLayerID(ScrollingNodeID nodeID) const
4632 {
4633     if (!nodeID)
4634         return nullptr;
4635 
4636     return m_scrollingNodeToLayerMap.get(nodeID);
4637 }
4638 
4639 void RenderLayerCompositor::willRemoveScrollingLayerWithBacking(RenderLayer&amp; layer, RenderLayerBacking&amp; backing)
4640 {
4641     if (scrollingCoordinator())
4642         return;
4643 
4644 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">4645     ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache);</span>
4646     if (m_legacyScrollingLayerCoordinator)
4647         m_legacyScrollingLayerCoordinator-&gt;removeScrollingLayer(layer, backing);
4648 #else
4649     UNUSED_PARAM(layer);
4650     UNUSED_PARAM(backing);
4651 #endif
4652 }
4653 
4654 // FIXME: This should really be called from the updateBackingAndHierarchy.
4655 void RenderLayerCompositor::didAddScrollingLayer(RenderLayer&amp; layer)
4656 {
4657     if (scrollingCoordinator())
4658         return;
4659 
4660 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">4661     ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache);</span>
4662     if (m_legacyScrollingLayerCoordinator)
4663         m_legacyScrollingLayerCoordinator-&gt;addScrollingLayer(layer);
4664 #else
4665     UNUSED_PARAM(layer);
4666 #endif
4667 }
4668 
4669 void RenderLayerCompositor::windowScreenDidChange(PlatformDisplayID displayID)
4670 {
4671     if (m_layerUpdater)
4672         m_layerUpdater-&gt;screenDidChange(displayID);
4673 }
4674 
4675 ScrollingCoordinator* RenderLayerCompositor::scrollingCoordinator() const
4676 {
4677     return page().scrollingCoordinator();
4678 }
4679 
4680 GraphicsLayerFactory* RenderLayerCompositor::graphicsLayerFactory() const
4681 {
</pre>
</td>
<td>
<hr />
<pre>
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #include &quot;RenderLayerCompositor.h&quot;
  29 
  30 #include &quot;CSSAnimationController.h&quot;
  31 #include &quot;CSSPropertyNames.h&quot;
  32 #include &quot;CanvasRenderingContext.h&quot;
  33 #include &quot;Chrome.h&quot;
  34 #include &quot;ChromeClient.h&quot;

  35 #include &quot;Frame.h&quot;
  36 #include &quot;FrameView.h&quot;
  37 #include &quot;FullscreenManager.h&quot;
  38 #include &quot;GraphicsLayer.h&quot;
  39 #include &quot;HTMLCanvasElement.h&quot;
  40 #include &quot;HTMLIFrameElement.h&quot;
  41 #include &quot;HTMLNames.h&quot;
  42 #include &quot;HitTestResult.h&quot;
  43 #include &quot;InspectorInstrumentation.h&quot;
<span class="line-added">  44 #include &quot;KeyframeEffectStack.h&quot;</span>
  45 #include &quot;LayerAncestorClippingStack.h&quot;
  46 #include &quot;LayerOverlapMap.h&quot;
  47 #include &quot;Logging.h&quot;
  48 #include &quot;NodeList.h&quot;
  49 #include &quot;Page.h&quot;
  50 #include &quot;PageOverlayController.h&quot;
  51 #include &quot;RenderEmbeddedObject.h&quot;
  52 #include &quot;RenderFragmentedFlow.h&quot;
  53 #include &quot;RenderFullScreen.h&quot;
  54 #include &quot;RenderGeometryMap.h&quot;
  55 #include &quot;RenderIFrame.h&quot;
  56 #include &quot;RenderImage.h&quot;
  57 #include &quot;RenderLayerBacking.h&quot;
  58 #include &quot;RenderReplica.h&quot;
  59 #include &quot;RenderVideo.h&quot;
  60 #include &quot;RenderView.h&quot;
  61 #include &quot;RuntimeEnabledFeatures.h&quot;
  62 #include &quot;ScrollingConstraints.h&quot;
  63 #include &quot;ScrollingCoordinator.h&quot;
  64 #include &quot;Settings.h&quot;
  65 #include &quot;TiledBacking.h&quot;
  66 #include &quot;TransformState.h&quot;
  67 #include &lt;wtf/HexNumber.h&gt;
  68 #include &lt;wtf/MemoryPressureHandler.h&gt;
  69 #include &lt;wtf/SetForScope.h&gt;
<span class="line-added">  70 #include &lt;wtf/SystemTracing.h&gt;</span>
  71 #include &lt;wtf/text/CString.h&gt;
  72 #include &lt;wtf/text/StringBuilder.h&gt;
  73 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  74 #include &lt;wtf/text/TextStream.h&gt;
  75 
  76 #if PLATFORM(IOS_FAMILY)
  77 #include &quot;LegacyTileCache.h&quot;
  78 #include &quot;RenderScrollbar.h&quot;
  79 #endif
  80 
  81 #if PLATFORM(MAC)
  82 #include &quot;LocalDefaultSystemAppearance.h&quot;
  83 #endif
  84 
  85 #if ENABLE(TREE_DEBUGGING)
  86 #include &quot;RenderTreeAsText.h&quot;
  87 #endif
  88 
  89 #if ENABLE(3D_TRANSFORMS)
  90 // This symbol is used to determine from a script whether 3D rendering is enabled (via &#39;nm&#39;).
</pre>
<hr />
<pre>
 182     {
 183         return compositingAncestor &amp;&amp; !compositingAncestor-&gt;isRenderViewLayer();
 184     }
 185 
 186     RenderLayer* compositingAncestor;
 187     RenderLayer* backingSharingAncestor { nullptr };
 188     RenderLayer* stackingContextAncestor { nullptr };
 189     bool subtreeIsCompositing { false };
 190     bool testingOverlap { true };
 191     bool fullPaintOrderTraversalRequired { false };
 192     bool descendantsRequireCompositingUpdate { false };
 193     bool ancestorHasTransformAnimation { false };
 194 #if ENABLE(CSS_COMPOSITING)
 195     bool hasNotIsolatedCompositedBlendingDescendants { false };
 196 #endif
 197 #if !LOG_DISABLED
 198     unsigned depth { 0 };
 199 #endif
 200 };
 201 
<span class="line-added"> 202 struct RenderLayerCompositor::UpdateBackingTraversalState {</span>
<span class="line-added"> 203 </span>
<span class="line-added"> 204     UpdateBackingTraversalState(RenderLayer* compAncestor = nullptr)</span>
<span class="line-added"> 205         : compositingAncestor(compAncestor)</span>
<span class="line-added"> 206     {</span>
<span class="line-added"> 207     }</span>
<span class="line-added"> 208 </span>
<span class="line-added"> 209     UpdateBackingTraversalState stateForDescendants() const</span>
<span class="line-added"> 210     {</span>
<span class="line-added"> 211         UpdateBackingTraversalState state(compositingAncestor);</span>
<span class="line-added"> 212 #if !LOG_DISABLED</span>
<span class="line-added"> 213         state.depth = depth + 1;</span>
<span class="line-added"> 214 #endif</span>
<span class="line-added"> 215         return state;</span>
<span class="line-added"> 216     }</span>
<span class="line-added"> 217 </span>
<span class="line-added"> 218     RenderLayer* compositingAncestor;</span>
<span class="line-added"> 219 #if !LOG_DISABLED</span>
<span class="line-added"> 220     unsigned depth { 0 };</span>
<span class="line-added"> 221 #endif</span>
<span class="line-added"> 222 };</span>
<span class="line-added"> 223 </span>
 224 class RenderLayerCompositor::BackingSharingState {
 225     WTF_MAKE_NONCOPYABLE(BackingSharingState);
 226 public:
 227     BackingSharingState() = default;
 228 
 229     RenderLayer* backingProviderCandidate() const { return m_backingProviderCandidate; };
 230 
 231     void appendSharingLayer(RenderLayer&amp; layer)
 232     {
 233         ASSERT(m_backingProviderCandidate);
 234         m_backingSharingLayers.append(makeWeakPtr(layer));
 235     }
 236 
 237     void updateBeforeDescendantTraversal(RenderLayer&amp;, bool willBeComposited);
 238     void updateAfterDescendantTraversal(RenderLayer&amp;, RenderLayer* stackingContextAncestor);
 239 
 240 private:
 241     void layerWillBeComposited(RenderLayer&amp;);
 242 
 243     void startBackingSharingSequence(RenderLayer&amp; candidateLayer, RenderLayer* candidateStackingContext);
</pre>
<hr />
<pre>
 687     if (!frameRenderer || !is&lt;RenderWidget&gt;(frameRenderer))
 688         return { };
 689 
 690     auto&amp; widgetRenderer = downcast&lt;RenderWidget&gt;(*frameRenderer);
 691     if (!widgetRenderer.hasLayer() || !widgetRenderer.layer()-&gt;isComposited()) {
 692         LOG(Scrolling, &quot;frameHostingNodeForFrame: frame renderer has no layer or is not composited.&quot;);
 693         return { };
 694     }
 695 
 696     if (auto frameHostingNodeID = widgetRenderer.layer()-&gt;backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting))
 697         return frameHostingNodeID;
 698 
 699     return { };
 700 }
 701 
 702 // Returns true on a successful update.
 703 bool RenderLayerCompositor::updateCompositingLayers(CompositingUpdateType updateType, RenderLayer* updateRoot)
 704 {
 705     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; updateCompositingLayers &quot; &lt;&lt; updateType &lt;&lt; &quot; contentLayersCount &quot; &lt;&lt; m_contentLayersCount);
 706 
<span class="line-added"> 707     TraceScope tracingScope(CompositingUpdateStart, CompositingUpdateEnd);</span>
<span class="line-added"> 708 </span>
 709 #if ENABLE(TREE_DEBUGGING)
 710     if (compositingLogEnabled())
 711         showPaintOrderTree(m_renderView.layer());
 712 #endif
 713 
 714     if (updateType == CompositingUpdateType::AfterStyleChange || updateType == CompositingUpdateType::AfterLayout)
 715         cacheAcceleratedCompositingFlagsAfterLayout(); // Some flags (e.g. forceCompositingMode) depend on layout.
 716 
 717     m_updateCompositingLayersTimer.stop();
 718 
<span class="line-modified"> 719     ASSERT(m_renderView.document().backForwardCacheState() == Document::NotInBackForwardCache</span>
<span class="line-modified"> 720         || m_renderView.document().backForwardCacheState() == Document::AboutToEnterBackForwardCache);</span>
 721 
 722     // Compositing layers will be updated in Document::setVisualUpdatesAllowed(bool) if suppressed here.
 723     if (!m_renderView.document().visualUpdatesAllowed())
 724         return false;
 725 
 726     // Avoid updating the layers with old values. Compositing layers will be updated after the layout is finished.
 727     // This happens when m_updateCompositingLayersTimer fires before layout is updated.
 728     if (m_renderView.needsLayout()) {
 729         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; updateCompositingLayers &quot; &lt;&lt; updateType &lt;&lt; &quot; - m_renderView.needsLayout, bailing &quot;);
 730         return false;
 731     }
 732 
 733     if (!m_compositing &amp;&amp; (m_forceCompositingMode || (isMainFrameCompositor() &amp;&amp; page().pageOverlayController().overlayCount())))
 734         enableCompositingMode(true);
 735 
 736     bool isPageScroll = !updateRoot || updateRoot == &amp;rootRenderLayer();
 737     updateRoot = &amp;rootRenderLayer();
 738 
 739     if (updateType == CompositingUpdateType::OnScroll || updateType == CompositingUpdateType::OnCompositedScroll) {
 740         // We only get here if we didn&#39;t scroll on the scrolling thread, so this update needs to re-position viewport-constrained layers.
</pre>
<hr />
<pre>
 796         auto&amp; rootLayer = rootRenderLayer();
 797         CompositingState compositingState(updateRoot);
 798         BackingSharingState backingSharingState;
 799         LayerOverlapMap overlapMap(rootLayer);
 800 
 801         bool descendantHas3DTransform = false;
 802         computeCompositingRequirements(nullptr, rootLayer, overlapMap, compositingState, backingSharingState, descendantHas3DTransform);
 803     }
 804 
 805     LOG(Compositing, &quot;\nRenderLayerCompositor::updateCompositingLayers - mid&quot;);
 806 #if ENABLE(TREE_DEBUGGING)
 807     if (compositingLogEnabled())
 808         showPaintOrderTree(m_renderView.layer());
 809 #endif
 810 
 811     if (updateRoot-&gt;hasDescendantNeedingUpdateBackingOrHierarchyTraversal() || updateRoot-&gt;needsUpdateBackingOrHierarchyTraversal()) {
 812         ScrollingTreeState scrollingTreeState = { 0, 0 };
 813         if (!m_renderView.frame().isMainFrame())
 814             scrollingTreeState.parentNodeID = frameHostingNodeForFrame(m_renderView.frame());
 815 
<span class="line-added"> 816         UpdateBackingTraversalState traversalState;</span>
 817         Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; childList;
<span class="line-modified"> 818         updateBackingAndHierarchy(*updateRoot, childList, traversalState, scrollingTreeState);</span>
 819 
 820         // Host the document layer in the RenderView&#39;s root layer.
 821         appendDocumentOverlayLayers(childList);
 822         // Even when childList is empty, don&#39;t drop out of compositing mode if there are
 823         // composited layers that we didn&#39;t hit in our traversal (e.g. because of visibility:hidden).
 824         if (childList.isEmpty() &amp;&amp; !needsCompositingForContentOrOverlays())
 825             destroyRootLayer();
 826         else if (m_rootContentsLayer)
 827             m_rootContentsLayer-&gt;setChildren(WTFMove(childList));
 828     }
 829 
 830 #if !LOG_DISABLED
 831     if (compositingLogEnabled()) {
 832         MonotonicTime endTime = MonotonicTime::now();
 833         LOG(Compositing, &quot;Total layers   primary   secondary   obligatory backing (KB)   secondary backing(KB)   total backing (KB)  update time (ms)\n&quot;);
 834 
 835         LOG(Compositing, &quot;%8d %11d %9d %20.2f %22.2f %22.2f %18.2f\n&quot;,
 836             m_obligateCompositedLayerCount + m_secondaryCompositedLayerCount, m_obligateCompositedLayerCount,
 837             m_secondaryCompositedLayerCount, m_obligatoryBackingStoreBytes / 1024, m_secondaryBackingStoreBytes / 1024, (m_obligatoryBackingStoreBytes + m_secondaryBackingStoreBytes) / 1024, (endTime - startTime).milliseconds());
 838     }
</pre>
<hr />
<pre>
 847         showPaintOrderTree(m_renderView.layer());
 848     }
 849 #endif
 850 
 851     InspectorInstrumentation::layerTreeDidChange(&amp;page());
 852 
 853     return true;
 854 }
 855 
 856 static bool backingProviderLayerCanIncludeLayer(const RenderLayer&amp; sharedLayer, const RenderLayer&amp; layer)
 857 {
 858     // Disable sharing when painting shared layers doesn&#39;t work correctly.
 859     if (layer.hasReflection())
 860         return false;
 861 
 862     return layer.ancestorLayerIsInContainingBlockChain(sharedLayer);
 863 }
 864 
 865 void RenderLayerCompositor::computeCompositingRequirements(RenderLayer* ancestorLayer, RenderLayer&amp; layer, LayerOverlapMap&amp; overlapMap, CompositingState&amp; compositingState, BackingSharingState&amp; backingSharingState, bool&amp; descendantHas3DTransform)
 866 {
<span class="line-added"> 867     layer.updateDescendantDependentFlags();</span>
<span class="line-added"> 868     layer.updateLayerListsIfNeeded();</span>
<span class="line-added"> 869 </span>
 870     if (!layer.hasDescendantNeedingCompositingRequirementsTraversal()
 871         &amp;&amp; !layer.needsCompositingRequirementsTraversal()
 872         &amp;&amp; !compositingState.fullPaintOrderTraversalRequired
 873         &amp;&amp; !compositingState.descendantsRequireCompositingUpdate) {
 874         traverseUnchangedSubtree(ancestorLayer, layer, overlapMap, compositingState, backingSharingState, descendantHas3DTransform);
 875         return;
 876     }
 877 
 878     LOG_WITH_STREAM(Compositing, stream &lt;&lt; TextStream::Repeat(compositingState.depth * 2, &#39; &#39;) &lt;&lt; &amp;layer &lt;&lt; (layer.isNormalFlowOnly() ? &quot; n&quot; : &quot; s&quot;) &lt;&lt; &quot; computeCompositingRequirements (backing provider candidate &quot; &lt;&lt; backingSharingState.backingProviderCandidate() &lt;&lt; &quot;)&quot;);
 879 
 880     // FIXME: maybe we can avoid updating all remaining layers in paint order.
 881     compositingState.fullPaintOrderTraversalRequired |= layer.needsCompositingRequirementsTraversal();
 882     compositingState.descendantsRequireCompositingUpdate |= layer.descendantsNeedCompositingRequirementsTraversal();
 883 



 884     layer.setHasCompositingDescendant(false);
 885 
 886     // We updated compositing for direct reasons in layerStyleChanged(). Here, check for compositing that can only be evaluated after layout.
 887     RequiresCompositingData queryData;
 888     bool willBeComposited = layer.isComposited();
 889     bool becameCompositedAfterDescendantTraversal = false;
 890     IndirectCompositingReason compositingReason = compositingState.subtreeIsCompositing ? IndirectCompositingReason::Stacking : IndirectCompositingReason::None;
 891 
 892     if (layer.needsPostLayoutCompositingUpdate() || compositingState.fullPaintOrderTraversalRequired || compositingState.descendantsRequireCompositingUpdate) {
 893         layer.setIndirectCompositingReason(IndirectCompositingReason::None);
 894         willBeComposited = needsToBeComposited(layer, queryData);
 895     }
 896 
 897     bool layerPaintsIntoProvidedBacking = false;
 898     if (!willBeComposited &amp;&amp; compositingState.subtreeIsCompositing &amp;&amp; backingSharingState.backingProviderCandidate() &amp;&amp; canBeComposited(layer) &amp;&amp; backingProviderLayerCanIncludeLayer(*backingSharingState.backingProviderCandidate(), layer)) {
 899         backingSharingState.appendSharingLayer(layer);
 900         LOG(Compositing, &quot; layer %p can share with %p&quot;, &amp;layer, backingSharingState.backingProviderCandidate());
 901         compositingReason = IndirectCompositingReason::None;
 902         layerPaintsIntoProvidedBacking = true;
 903     }
</pre>
<hr />
<pre>
 976         currentState.subtreeIsCompositing = true;
 977         becameCompositedAfterDescendantTraversal = true;
 978     };
 979 
 980     if (willBeComposited) {
 981         layerWillComposite();
 982 
 983         computeExtent(overlapMap, layer, layerExtent);
 984         currentState.ancestorHasTransformAnimation |= layerExtent.hasTransformAnimation;
 985         // Too hard to compute animated bounds if both us and some ancestor is animating transform.
 986         layerExtent.animationCausesExtentUncertainty |= layerExtent.hasTransformAnimation &amp;&amp; compositingState.ancestorHasTransformAnimation;
 987     } else if (layerPaintsIntoProvidedBacking) {
 988         currentState.backingSharingAncestor = &amp;layer;
 989         overlapMap.pushCompositingContainer();
 990         didPushOverlapContainer = true;
 991         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will share, pushed container &quot; &lt;&lt; overlapMap);
 992     }
 993 
 994     backingSharingState.updateBeforeDescendantTraversal(layer, willBeComposited);
 995 
<span class="line-modified"> 996 #if ASSERT_ENABLED</span>
 997     LayerListMutationDetector mutationChecker(layer);
 998 #endif
 999 
1000     bool anyDescendantHas3DTransform = false;
1001     bool descendantsAddedToOverlap = currentState.hasNonRootCompositedAncestor();
1002 
1003     for (auto* childLayer : layer.negativeZOrderLayers()) {
1004         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
1005 
1006         // If we have to make a layer for this child, make one now so we can have a contents layer
1007         // (since we need to ensure that the -ve z-order child renders underneath our contents).
1008         if (!willBeComposited &amp;&amp; currentState.subtreeIsCompositing) {
1009             layer.setIndirectCompositingReason(IndirectCompositingReason::BackgroundLayer);
1010             layerWillComposite();
1011         }
1012     }
1013 
1014     for (auto* childLayer : layer.normalFlowLayers())
1015         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
1016 
</pre>
<hr />
<pre>
1020     // Set the flag to say that this layer has compositing children.
1021     layer.setHasCompositingDescendant(currentState.subtreeIsCompositing);
1022 
1023     // If we just entered compositing mode, the root will have become composited (as long as accelerated compositing is enabled).
1024     if (layer.isRenderViewLayer()) {
1025         if (usesCompositing() &amp;&amp; m_hasAcceleratedCompositing)
1026             willBeComposited = true;
1027     }
1028 
1029 #if ENABLE(CSS_COMPOSITING)
1030     bool isolatedCompositedBlending = layer.isolatesCompositedBlending();
1031     layer.setHasNotIsolatedCompositedBlendingDescendants(currentState.hasNotIsolatedCompositedBlendingDescendants);
1032     if (layer.isolatesCompositedBlending() != isolatedCompositedBlending) {
1033         // isolatedCompositedBlending affects the result of clippedByAncestor().
1034         layer.setChildrenNeedCompositingGeometryUpdate();
1035     }
1036 
1037     ASSERT(!layer.hasNotIsolatedCompositedBlendingDescendants() || layer.hasNotIsolatedBlendingDescendants());
1038 #endif
1039     // Now check for reasons to become composited that depend on the state of descendant layers.
<span class="line-modified">1040     if (!willBeComposited &amp;&amp; canBeComposited(layer)) {</span>
<span class="line-modified">1041         auto indirectReason = computeIndirectCompositingReason(layer, currentState.subtreeIsCompositing, anyDescendantHas3DTransform, layerPaintsIntoProvidedBacking);</span>
<span class="line-modified">1042         if (indirectReason != IndirectCompositingReason::None) {</span>
<span class="line-modified">1043             layer.setIndirectCompositingReason(indirectReason);</span>
<span class="line-modified">1044             layerWillCompositePostDescendants();</span>
<span class="line-added">1045         }</span>
1046     }
1047 
1048     if (layer.reflectionLayer()) {
1049         // FIXME: Shouldn&#39;t we call computeCompositingRequirements to handle a reflection overlapping with another renderer?
1050         layer.reflectionLayer()-&gt;setIndirectCompositingReason(willBeComposited ? IndirectCompositingReason::Stacking : IndirectCompositingReason::None);
1051     }
1052 





1053     // If we&#39;re back at the root, and no other layers need to be composited, and the root layer itself doesn&#39;t need
1054     // to be composited, then we can drop out of compositing mode altogether. However, don&#39;t drop out of compositing mode
1055     // if there are composited layers that we didn&#39;t hit in our traversal (e.g. because of visibility:hidden).
1056     RequiresCompositingData rootLayerQueryData;
1057     if (layer.isRenderViewLayer() &amp;&amp; !currentState.subtreeIsCompositing &amp;&amp; !requiresCompositingLayer(layer, rootLayerQueryData) &amp;&amp; !m_forceCompositingMode &amp;&amp; !needsCompositingForContentOrOverlays()) {
1058         // Don&#39;t drop out of compositing on iOS, because we may flash. See &lt;rdar://problem/8348337&gt;.
1059 #if !PLATFORM(IOS_FAMILY)
1060         enableCompositingMode(false);
1061         willBeComposited = false;
1062 #endif
1063     }
1064 
1065     ASSERT(willBeComposited == needsToBeComposited(layer, queryData));
1066 
1067     // Create or destroy backing here. However, we can&#39;t update geometry because layers above us may become composited
1068     // during post-order traversal (e.g. for clipping).
1069     if (updateBacking(layer, queryData, CompositingChangeRepaintNow, willBeComposited ? BackingRequired::Yes : BackingRequired::No)) {
1070         layer.setNeedsCompositingLayerConnection();
1071         // Child layers need to get a geometry update to recompute their position.
1072         layer.setChildrenNeedCompositingGeometryUpdate();
1073         // The composited bounds of enclosing layers depends on which descendants are composited, so they need a geometry update.
1074         layer.setNeedsCompositingGeometryUpdateOnAncestors();
1075     }
1076 
1077     // Update layer state bits.
<span class="line-modified">1078     if (layer.reflectionLayer() &amp;&amp; updateLayerCompositingState(*layer.reflectionLayer(), &amp;layer, queryData, CompositingChangeRepaintNow))</span>
1079         layer.setNeedsCompositingLayerConnection();
1080 
1081     // FIXME: clarify needsCompositingPaintOrderChildrenUpdate. If a composited layer gets a new ancestor, it needs geometry computations.
1082     if (layer.needsCompositingPaintOrderChildrenUpdate()) {
1083         layer.setChildrenNeedCompositingGeometryUpdate();
1084         layer.setNeedsCompositingLayerConnection();
1085     }
1086 
1087     layer.clearCompositingRequirementsTraversalState();
1088 
1089     // Compute state passed to the caller.
1090     descendantHas3DTransform |= anyDescendantHas3DTransform || layer.has3DTransform();
1091     compositingState.updateWithDescendantStateAndLayer(currentState, layer, layerExtent);
1092     backingSharingState.updateAfterDescendantTraversal(layer, compositingState.stackingContextAncestor);
1093 
1094     bool layerContributesToOverlap = (currentState.compositingAncestor &amp;&amp; !currentState.compositingAncestor-&gt;isRenderViewLayer()) || currentState.backingSharingAncestor;
1095     updateOverlapMap(overlapMap, layer, layerExtent, didPushOverlapContainer, layerContributesToOverlap, becameCompositedAfterDescendantTraversal &amp;&amp; !descendantsAddedToOverlap);
1096 
1097     if (layer.isComposited())
1098         layer.backing()-&gt;updateAllowsBackingStoreDetaching(layerExtent.bounds);
1099 
1100     overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
1101 
1102     LOG_WITH_STREAM(Compositing, stream &lt;&lt; TextStream::Repeat(compositingState.depth * 2, &#39; &#39;) &lt;&lt; &amp;layer &lt;&lt; &quot; computeCompositingRequirements - willBeComposited &quot; &lt;&lt; willBeComposited &lt;&lt; &quot; (backing provider candidate &quot; &lt;&lt; backingSharingState.backingProviderCandidate() &lt;&lt; &quot;)&quot;);
1103 }
1104 
1105 // We have to traverse unchanged layers to fill in the overlap map.
1106 void RenderLayerCompositor::traverseUnchangedSubtree(RenderLayer* ancestorLayer, RenderLayer&amp; layer, LayerOverlapMap&amp; overlapMap, CompositingState&amp; compositingState, BackingSharingState&amp; backingSharingState, bool&amp; descendantHas3DTransform)
1107 {
<span class="line-added">1108     layer.updateDescendantDependentFlags();</span>
<span class="line-added">1109     layer.updateLayerListsIfNeeded();</span>
<span class="line-added">1110 </span>
1111     ASSERT(!compositingState.fullPaintOrderTraversalRequired);
1112     ASSERT(!layer.hasDescendantNeedingCompositingRequirementsTraversal());
1113     ASSERT(!layer.needsCompositingRequirementsTraversal());
1114 
1115     LOG_WITH_STREAM(Compositing, stream &lt;&lt; TextStream::Repeat(compositingState.depth * 2, &#39; &#39;) &lt;&lt; &amp;layer &lt;&lt; (layer.isNormalFlowOnly() ? &quot; n&quot; : &quot; s&quot;) &lt;&lt; &quot; traverseUnchangedSubtree&quot;);
1116 



1117     bool layerIsComposited = layer.isComposited();
1118     bool layerPaintsIntoProvidedBacking = false;
1119     bool didPushOverlapContainer = false;
1120 
1121     OverlapExtent layerExtent;
1122     if (layerIsComposited &amp;&amp; !layer.isRenderViewLayer())
1123         layerExtent.hasTransformAnimation = isRunningTransformAnimation(layer.renderer());
1124 
1125     bool respectTransforms = !layerExtent.hasTransformAnimation;
1126     overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer, respectTransforms);
1127 
1128     // If we know for sure the layer is going to be composited, don&#39;t bother looking it up in the overlap map
1129     if (!layerIsComposited &amp;&amp; !overlapMap.isEmpty() &amp;&amp; compositingState.testingOverlap)
1130         computeExtent(overlapMap, layer, layerExtent);
1131 
1132     if (layer.paintsIntoProvidedBacking()) {
1133         ASSERT(backingSharingState.backingProviderCandidate());
1134         ASSERT(backingProviderLayerCanIncludeLayer(*backingSharingState.backingProviderCandidate(), layer));
1135         backingSharingState.appendSharingLayer(layer);
1136         layerPaintsIntoProvidedBacking = true;
</pre>
<hr />
<pre>
1145         // This layer now acts as the ancestor for kids.
1146         currentState.compositingAncestor = &amp;layer;
1147         currentState.backingSharingAncestor = nullptr;
1148         overlapMap.pushCompositingContainer();
1149         didPushOverlapContainer = true;
1150         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;unchangedSubtree: layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will composite, pushed container &quot; &lt;&lt; overlapMap);
1151 
1152         computeExtent(overlapMap, layer, layerExtent);
1153         currentState.ancestorHasTransformAnimation |= layerExtent.hasTransformAnimation;
1154         // Too hard to compute animated bounds if both us and some ancestor is animating transform.
1155         layerExtent.animationCausesExtentUncertainty |= layerExtent.hasTransformAnimation &amp;&amp; compositingState.ancestorHasTransformAnimation;
1156     } else if (layerPaintsIntoProvidedBacking) {
1157         overlapMap.pushCompositingContainer();
1158         currentState.backingSharingAncestor = &amp;layer;
1159         didPushOverlapContainer = true;
1160         LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;unchangedSubtree: layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will share, pushed container &quot; &lt;&lt; overlapMap);
1161     }
1162 
1163     backingSharingState.updateBeforeDescendantTraversal(layer, layerIsComposited);
1164 
<span class="line-modified">1165 #if ASSERT_ENABLED</span>
1166     LayerListMutationDetector mutationChecker(layer);
1167 #endif
1168 
1169     bool anyDescendantHas3DTransform = false;
1170 
1171     for (auto* childLayer : layer.negativeZOrderLayers()) {
1172         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
1173         if (currentState.subtreeIsCompositing)
1174             ASSERT(layerIsComposited);
1175     }
1176 
1177     for (auto* childLayer : layer.normalFlowLayers())
1178         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
1179 
1180     for (auto* childLayer : layer.positiveZOrderLayers())
1181         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, currentState, backingSharingState, anyDescendantHas3DTransform);
1182 
1183     // Set the flag to say that this layer has compositing children.
1184     ASSERT(layer.hasCompositingDescendant() == currentState.subtreeIsCompositing);
1185     ASSERT_IMPLIES(canBeComposited(layer) &amp;&amp; clipsCompositingDescendants(layer), layerIsComposited);
1186 
1187     descendantHas3DTransform |= anyDescendantHas3DTransform || layer.has3DTransform();
1188 
1189     ASSERT(!currentState.fullPaintOrderTraversalRequired);
1190     compositingState.updateWithDescendantStateAndLayer(currentState, layer, layerExtent, true);
1191     backingSharingState.updateAfterDescendantTraversal(layer, compositingState.stackingContextAncestor);
1192 
1193     bool layerContributesToOverlap = (currentState.compositingAncestor &amp;&amp; !currentState.compositingAncestor-&gt;isRenderViewLayer()) || currentState.backingSharingAncestor;
1194     updateOverlapMap(overlapMap, layer, layerExtent, didPushOverlapContainer, layerContributesToOverlap);
1195 
1196     overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
1197 
1198     ASSERT(!layer.needsCompositingRequirementsTraversal());
1199 }
1200 
<span class="line-modified">1201 void RenderLayerCompositor::updateBackingAndHierarchy(RenderLayer&amp; layer, Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; childLayersOfEnclosingLayer, UpdateBackingTraversalState&amp; traversalState, ScrollingTreeState&amp; scrollingTreeState, OptionSet&lt;UpdateLevel&gt; updateLevel)</span>
1202 {
1203     layer.updateDescendantDependentFlags();
1204     layer.updateLayerListsIfNeeded();
1205 
1206     bool layerNeedsUpdate = !updateLevel.isEmpty();
1207     if (layer.descendantsNeedUpdateBackingAndHierarchyTraversal())
1208         updateLevel.add(UpdateLevel::AllDescendants);
1209 
<span class="line-modified">1210     ScrollingTreeState scrollingStateForDescendants = scrollingTreeState;</span>
<span class="line-added">1211     UpdateBackingTraversalState traversalStateForDescendants = traversalState.stateForDescendants();</span>
1212 
1213     auto* layerBacking = layer.backing();
1214     if (layerBacking) {
1215         updateLevel.remove(UpdateLevel::CompositedChildren);
1216 
1217         // We updated the composited bounds in RenderLayerBacking::updateAfterLayout(), but it may have changed
1218         // based on which descendants are now composited.
1219         if (layerBacking-&gt;updateCompositedBounds()) {
1220             layer.setNeedsCompositingGeometryUpdate();
1221             // Our geometry can affect descendants.
1222             updateLevel.add(UpdateLevel::CompositedChildren);
1223         }
1224 
1225         if (layerNeedsUpdate || layer.needsCompositingConfigurationUpdate()) {
<span class="line-modified">1226             if (layerBacking-&gt;updateConfiguration(traversalState.compositingAncestor)) {</span>
1227                 layerNeedsUpdate = true; // We also need to update geometry.
1228                 layer.setNeedsCompositingLayerConnection();
1229             }
1230 
1231             layerBacking-&gt;updateDebugIndicators(m_showDebugBorders, m_showRepaintCounter);
1232         }
1233 
1234         OptionSet&lt;ScrollingNodeChangeFlags&gt; scrollingNodeChanges = { ScrollingNodeChangeFlags::Layer };
1235         if (layerNeedsUpdate || layer.needsCompositingGeometryUpdate()) {
<span class="line-modified">1236             layerBacking-&gt;updateGeometry(traversalState.compositingAncestor);</span>
1237             scrollingNodeChanges.add(ScrollingNodeChangeFlags::LayerGeometry);
1238         } else if (layer.needsScrollingTreeUpdate())
1239             scrollingNodeChanges.add(ScrollingNodeChangeFlags::LayerGeometry);
1240 
1241         // This needs to happen after any geometry update.
1242         // FIXME: Use separate bit for event region invalidation.
1243         if (layerNeedsUpdate || layer.needsCompositingConfigurationUpdate())
1244             layerBacking-&gt;updateEventRegion();
1245 
1246         if (auto* reflection = layer.reflectionLayer()) {
1247             if (auto* reflectionBacking = reflection-&gt;backing()) {
1248                 reflectionBacking-&gt;updateCompositedBounds();
<span class="line-modified">1249                 reflectionBacking-&gt;updateGeometry(&amp;layer);</span>
1250                 reflectionBacking-&gt;updateAfterDescendants();
1251             }
1252         }
1253 
1254         if (!layer.parent())
1255             updateRootLayerPosition();
1256 
1257         // FIXME: do based on dirty flags. Need to do this for changes of geometry, configuration and hierarchy.
1258         // Need to be careful to do the right thing when a scroll-coordinated layer loses a scroll-coordinated ancestor.
<span class="line-modified">1259         scrollingStateForDescendants.parentNodeID = updateScrollCoordinationForLayer(layer, traversalState.compositingAncestor, scrollingTreeState, scrollingNodeChanges);</span>
<span class="line-modified">1260         scrollingStateForDescendants.nextChildIndex = 0;</span>
<span class="line-added">1261 </span>
<span class="line-added">1262         traversalStateForDescendants.compositingAncestor = &amp;layer;</span>
1263 
1264 #if !LOG_DISABLED
<span class="line-modified">1265         logLayerInfo(layer, &quot;updateBackingAndHierarchy&quot;, traversalState.depth);</span>


1266 #endif
1267     }
1268 
1269     if (layer.childrenNeedCompositingGeometryUpdate())
1270         updateLevel.add(UpdateLevel::CompositedChildren);
1271 
1272     // If this layer has backing, then we are collecting its children, otherwise appending
1273     // to the compositing child list of an enclosing layer.
1274     Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; layerChildren;
1275     auto&amp; childList = layerBacking ? layerChildren : childLayersOfEnclosingLayer;
1276 
1277     bool requireDescendantTraversal = layer.hasDescendantNeedingUpdateBackingOrHierarchyTraversal()
1278         || (layer.hasCompositingDescendant() &amp;&amp; (!layerBacking || layer.needsCompositingLayerConnection() || !updateLevel.isEmpty()));
1279 
1280     bool requiresChildRebuild = layerBacking &amp;&amp; layer.needsCompositingLayerConnection() &amp;&amp; !layer.hasCompositingDescendant();
1281 
<span class="line-modified">1282 #if ASSERT_ENABLED</span>
1283     LayerListMutationDetector mutationChecker(layer);
1284 #endif
1285 
1286     auto appendForegroundLayerIfNecessary = [&amp;] {
1287         // If a negative z-order child is compositing, we get a foreground layer which needs to get parented.
1288         if (layer.negativeZOrderLayers().size()) {
1289             if (layerBacking &amp;&amp; layerBacking-&gt;foregroundLayer())
1290                 childList.append(*layerBacking-&gt;foregroundLayer());
1291         }
1292     };
1293 
1294     if (requireDescendantTraversal) {
1295         for (auto* renderLayer : layer.negativeZOrderLayers())
<span class="line-modified">1296             updateBackingAndHierarchy(*renderLayer, childList, traversalStateForDescendants, scrollingStateForDescendants, updateLevel);</span>
1297 
1298         appendForegroundLayerIfNecessary();
1299 
1300         for (auto* renderLayer : layer.normalFlowLayers())
<span class="line-modified">1301             updateBackingAndHierarchy(*renderLayer, childList, traversalStateForDescendants, scrollingStateForDescendants, updateLevel);</span>
1302 
1303         for (auto* renderLayer : layer.positiveZOrderLayers())
<span class="line-modified">1304             updateBackingAndHierarchy(*renderLayer, childList, traversalStateForDescendants, scrollingStateForDescendants, updateLevel);</span>
1305     } else if (requiresChildRebuild)
1306         appendForegroundLayerIfNecessary();
1307 
1308     if (layerBacking) {
1309         if (requireDescendantTraversal || requiresChildRebuild) {
1310             bool parented = false;
1311             if (is&lt;RenderWidget&gt;(layer.renderer()))
1312                 parented = parentFrameContentLayers(downcast&lt;RenderWidget&gt;(layer.renderer()));
1313 
1314             if (!parented)
1315                 layerBacking-&gt;parentForSublayers()-&gt;setChildren(WTFMove(layerChildren));
1316 
1317             // If the layer has a clipping layer the overflow controls layers will be siblings of the clipping layer.
1318             // Otherwise, the overflow control layers are normal children.
1319             if (!layerBacking-&gt;hasClippingLayer() &amp;&amp; !layerBacking-&gt;hasScrollingLayer()) {
1320                 if (auto* overflowControlLayer = layerBacking-&gt;layerForHorizontalScrollbar())
1321                     layerBacking-&gt;parentForSublayers()-&gt;addChild(*overflowControlLayer);
1322 
1323                 if (auto* overflowControlLayer = layerBacking-&gt;layerForVerticalScrollbar())
1324                     layerBacking-&gt;parentForSublayers()-&gt;addChild(*overflowControlLayer);
</pre>
<hr />
<pre>
1374 #if !LOG_DISABLED
1375 void RenderLayerCompositor::logLayerInfo(const RenderLayer&amp; layer, const char* phase, int depth)
1376 {
1377     if (!compositingLogEnabled())
1378         return;
1379 
1380     auto* backing = layer.backing();
1381     RequiresCompositingData queryData;
1382     if (requiresCompositingLayer(layer, queryData) || layer.isRenderViewLayer()) {
1383         ++m_obligateCompositedLayerCount;
1384         m_obligatoryBackingStoreBytes += backing-&gt;backingStoreMemoryEstimate();
1385     } else {
1386         ++m_secondaryCompositedLayerCount;
1387         m_secondaryBackingStoreBytes += backing-&gt;backingStoreMemoryEstimate();
1388     }
1389 
1390     LayoutRect absoluteBounds = backing-&gt;compositedBounds();
1391     absoluteBounds.move(layer.offsetFromAncestor(m_renderView.layer()));
1392 
1393     StringBuilder logString;
<span class="line-modified">1394     logString.append(pad(&#39; &#39;, 12 + depth * 2, hex(reinterpret_cast&lt;uintptr_t&gt;(&amp;layer), Lowercase)), &quot; id &quot;, backing-&gt;graphicsLayer()-&gt;primaryLayerID(), &quot; (&quot;, absoluteBounds.x().toFloat(), &#39;,&#39;, absoluteBounds.y().toFloat(), &#39;-&#39;, absoluteBounds.maxX().toFloat(), &#39;,&#39;, absoluteBounds.maxY().toFloat(), &quot;) &quot;, FormattedNumber::fixedWidth(backing-&gt;backingStoreMemoryEstimate() / 1024, 2), &quot;KB&quot;);</span>
1395 
<span class="line-modified">1396     if (!layer.renderer().style().hasAutoUsedZIndex())</span>
<span class="line-modified">1397         logString.append(&quot; z-index: &quot;, layer.renderer().style().usedZIndex());</span>
1398 
1399     logString.append(&quot; (&quot;, logReasonsForCompositing(layer), &quot;) &quot;);
1400 
1401     if (backing-&gt;graphicsLayer()-&gt;contentsOpaque() || backing-&gt;paintsIntoCompositedAncestor() || backing-&gt;foregroundLayer() || backing-&gt;backgroundLayer()) {
1402         logString.append(&#39;[&#39;);
1403         bool prependSpace = false;
1404         if (backing-&gt;graphicsLayer()-&gt;contentsOpaque()) {
1405             logString.appendLiteral(&quot;opaque&quot;);
1406             prependSpace = true;
1407         }
1408 
1409         if (backing-&gt;paintsIntoCompositedAncestor()) {
1410             if (prependSpace)
1411                 logString.appendLiteral(&quot;, &quot;);
1412             logString.appendLiteral(&quot;paints into ancestor&quot;);
1413             prependSpace = true;
1414         }
1415 
1416         if (backing-&gt;foregroundLayer() || backing-&gt;backgroundLayer()) {
1417             if (prependSpace)
</pre>
<hr />
<pre>
1696     // If a fixed position layer gained/lost a backing or the reason not compositing it changed,
1697     // the scrolling coordinator needs to recalculate whether it can do fast scrolling.
1698     if (layer.renderer().isFixedPositioned()) {
1699         if (layer.viewportConstrainedNotCompositedReason() != queryData.nonCompositedForPositionReason) {
1700             layer.setViewportConstrainedNotCompositedReason(queryData.nonCompositedForPositionReason);
1701             layerChanged = true;
1702         }
1703         if (layerChanged) {
1704             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
1705                 scrollingCoordinator-&gt;frameViewFixedObjectsDidChange(m_renderView.frameView());
1706         }
1707     } else
1708         layer.setViewportConstrainedNotCompositedReason(RenderLayer::NoNotCompositedReason);
1709 
1710     if (layer.backing())
1711         layer.backing()-&gt;updateDebugIndicators(m_showDebugBorders, m_showRepaintCounter);
1712 
1713     return layerChanged;
1714 }
1715 
<span class="line-modified">1716 bool RenderLayerCompositor::updateLayerCompositingState(RenderLayer&amp; layer, const RenderLayer* compositingAncestor, RequiresCompositingData&amp; queryData, CompositingChangeRepaint shouldRepaint)</span>
1717 {
1718     bool layerChanged = updateBacking(layer, queryData, shouldRepaint);
1719 
1720     // See if we need content or clipping layers. Methods called here should assume
1721     // that the compositing state of descendant layers has not been updated yet.
<span class="line-modified">1722     if (layer.backing() &amp;&amp; layer.backing()-&gt;updateConfiguration(compositingAncestor))</span>
1723         layerChanged = true;
1724 
1725     return layerChanged;
1726 }
1727 
1728 void RenderLayerCompositor::repaintOnCompositingChange(RenderLayer&amp; layer)
1729 {
1730     // If the renderer is not attached yet, no need to repaint.
1731     if (&amp;layer.renderer() != &amp;m_renderView &amp;&amp; !layer.renderer().parent())
1732         return;
1733 
1734     auto* repaintContainer = layer.renderer().containerForRepaint();
1735     if (!repaintContainer)
1736         repaintContainer = &amp;m_renderView;
1737 
1738     layer.repaintIncludingNonCompositingDescendants(repaintContainer);
1739     if (repaintContainer == &amp;m_renderView) {
1740         // The contents of this layer may be moving between the window
1741         // and a GraphicsLayer, so we need to make sure the window system
1742         // synchronizes those changes on the screen.
</pre>
<hr />
<pre>
1890     if (layer.isRenderViewLayer())
1891         return;
1892 
1893     computeExtent(overlapMap, layer, extent);
1894 
1895     // FIXME: constrain the scopes (by composited stacking context ancestor I think).
1896     auto clippingScopes = enclosingClippingScopes(layer, rootRenderLayer());
1897 
1898     LayoutRect clipRect;
1899     if (layer.hasCompositedScrollingAncestor()) {
1900         // Compute a clip up to the composited scrolling ancestor, then convert it to absolute coordinates.
1901         auto&amp; scrollingScope = clippingScopes.last();
1902         clipRect = layer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;scrollingScope.layer, TemporaryClipRects, IgnoreOverlayScrollbarSize, IgnoreOverflowClip)).rect();
1903         if (!clipRect.isInfinite())
1904             clipRect.setLocation(layer.convertToLayerCoords(&amp;rootRenderLayer(), clipRect.location()));
1905     } else
1906         clipRect = layer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;rootRenderLayer(), AbsoluteClipRects)).rect(); // FIXME: Incorrect for CSS regions.
1907 
1908     auto clippedBounds = extent.bounds;
1909     if (!clipRect.isInfinite()) {
<span class="line-modified">1910         // With delegated page scaling, pageScaleFactor() is not applied by RenderView, so we should not scale here.</span>
<span class="line-modified">1911         if (!page().delegatesScaling())</span>
1912             clipRect.scale(pageScaleFactor());
1913 
1914         clippedBounds.intersect(clipRect);
1915     }
1916 
1917     overlapMap.add(layer, clippedBounds, clippingScopes);
1918 }
1919 
1920 void RenderLayerCompositor::addDescendantsToOverlapMapRecursive(LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, const RenderLayer* ancestorLayer) const
1921 {
1922     if (!canBeComposited(layer))
1923         return;
1924 
1925     // A null ancestorLayer is an indication that &#39;layer&#39; has already been pushed.
1926     if (ancestorLayer) {
1927         overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer);
1928 
1929         OverlapExtent layerExtent;
1930         addToOverlapMap(overlapMap, layer, layerExtent);
1931     }
1932 
<span class="line-modified">1933 #if ASSERT_ENABLED</span>
1934     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(layer));
1935 #endif
1936 
1937     for (auto* renderLayer : layer.negativeZOrderLayers())
1938         addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);
1939 
1940     for (auto* renderLayer : layer.normalFlowLayers())
1941         addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);
1942 
1943     for (auto* renderLayer : layer.positiveZOrderLayers())
1944         addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);
1945 
1946     if (ancestorLayer)
1947         overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
1948 }
1949 
1950 void RenderLayerCompositor::updateOverlapMap(LayerOverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; layerExtent, bool didPushContainer, bool addLayerToOverlap, bool addDescendantsToOverlap) const
1951 {
1952     if (addLayerToOverlap) {
1953         addToOverlapMap(overlapMap, layer, layerExtent);
</pre>
<hr />
<pre>
2089     updateOverflowControlsLayers();
2090 }
2091 
2092 void RenderLayerCompositor::frameViewDidLayout()
2093 {
2094     if (auto* renderViewBacking = m_renderView.layer()-&gt;backing())
2095         renderViewBacking-&gt;adjustTiledBackingCoverage();
2096 }
2097 
2098 void RenderLayerCompositor::rootLayerConfigurationChanged()
2099 {
2100     auto* renderViewBacking = m_renderView.layer()-&gt;backing();
2101     if (renderViewBacking &amp;&amp; renderViewBacking-&gt;isFrameLayerWithTiledBacking()) {
2102         m_renderView.layer()-&gt;setNeedsCompositingConfigurationUpdate();
2103         scheduleCompositingLayerUpdate();
2104     }
2105 }
2106 
2107 String RenderLayerCompositor::layerTreeAsText(LayerTreeFlags flags)
2108 {
<span class="line-added">2109     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; layerTreeAsText&quot;);</span>
2110     updateCompositingLayers(CompositingUpdateType::AfterLayout);
2111 
2112     if (!m_rootContentsLayer)
2113         return String();
2114 
2115     flushPendingLayerChanges(true);
2116     page().renderingUpdateScheduler().scheduleImmediateRenderingUpdate();
2117 
2118     LayerTreeAsTextBehavior layerTreeBehavior = LayerTreeAsTextBehaviorNormal;
2119     if (flags &amp; LayerTreeFlagsIncludeDebugInfo)
2120         layerTreeBehavior |= LayerTreeAsTextDebug;
2121     if (flags &amp; LayerTreeFlagsIncludeVisibleRects)
2122         layerTreeBehavior |= LayerTreeAsTextIncludeVisibleRects;
2123     if (flags &amp; LayerTreeFlagsIncludeTileCaches)
2124         layerTreeBehavior |= LayerTreeAsTextIncludeTileCaches;
2125     if (flags &amp; LayerTreeFlagsIncludeRepaintRects)
2126         layerTreeBehavior |= LayerTreeAsTextIncludeRepaintRects;
2127     if (flags &amp; LayerTreeFlagsIncludePaintingPhases)
2128         layerTreeBehavior |= LayerTreeAsTextIncludePaintingPhases;
2129     if (flags &amp; LayerTreeFlagsIncludeContentLayers)
2130         layerTreeBehavior |= LayerTreeAsTextIncludeContentLayers;
2131     if (flags &amp; LayerTreeFlagsIncludeAcceleratesDrawing)
2132         layerTreeBehavior |= LayerTreeAsTextIncludeAcceleratesDrawing;
2133     if (flags &amp; LayerTreeFlagsIncludeClipping)
2134         layerTreeBehavior |= LayerTreeAsTextIncludeClipping;
2135     if (flags &amp; LayerTreeFlagsIncludeBackingStoreAttached)
2136         layerTreeBehavior |= LayerTreeAsTextIncludeBackingStoreAttached;
2137     if (flags &amp; LayerTreeFlagsIncludeRootLayerProperties)
2138         layerTreeBehavior |= LayerTreeAsTextIncludeRootLayerProperties;
2139     if (flags &amp; LayerTreeFlagsIncludeEventRegion)
2140         layerTreeBehavior |= LayerTreeAsTextIncludeEventRegion;
<span class="line-added">2141     if (flags &amp; LayerTreeFlagsIncludeDeepColor)</span>
<span class="line-added">2142         layerTreeBehavior |= LayerTreeAsTextIncludeDeepColor;</span>
2143 
2144     // We skip dumping the scroll and clip layers to keep layerTreeAsText output
2145     // similar between platforms.
2146     String layerTreeText = m_rootContentsLayer-&gt;layerTreeAsText(layerTreeBehavior);
2147 
2148     // Dump an empty layer tree only if the only composited layer is the main frame&#39;s tiled backing,
2149     // so that tests expecting us to drop out of accelerated compositing when there are no layers succeed.
2150     if (!hasContentCompositingLayers() &amp;&amp; documentUsesTiledBacking() &amp;&amp; !(layerTreeBehavior &amp; LayerTreeAsTextIncludeTileCaches) &amp;&amp; !(layerTreeBehavior &amp; LayerTreeAsTextIncludeRootLayerProperties))
2151         layerTreeText = emptyString();
2152 
2153     // The true root layer is not included in the dump, so if we want to report
2154     // its repaint rects, they must be included here.
2155     if (flags &amp; LayerTreeFlagsIncludeRepaintRects)
2156         return m_renderView.frameView().trackedRepaintRectsAsText() + layerTreeText;
2157 
2158     return layerTreeText;
2159 }
2160 
2161 static RenderView* frameContentsRenderView(RenderWidget&amp; renderer)
2162 {
</pre>
<hr />
<pre>
2200         }
2201     }
2202 
2203     // FIXME: Why always return true and not just when the layers changed?
2204     return true;
2205 }
2206 
2207 void RenderLayerCompositor::repaintCompositedLayers()
2208 {
2209     recursiveRepaintLayer(rootRenderLayer());
2210 }
2211 
2212 void RenderLayerCompositor::recursiveRepaintLayer(RenderLayer&amp; layer)
2213 {
2214     layer.updateLayerListsIfNeeded();
2215 
2216     // FIXME: This method does not work correctly with transforms.
2217     if (layer.isComposited() &amp;&amp; !layer.backing()-&gt;paintsIntoCompositedAncestor())
2218         layer.setBackingNeedsRepaint();
2219 
<span class="line-modified">2220 #if ASSERT_ENABLED</span>
2221     LayerListMutationDetector mutationChecker(layer);
2222 #endif
2223 
2224     if (layer.hasCompositingDescendant()) {
2225         for (auto* renderLayer : layer.negativeZOrderLayers())
2226             recursiveRepaintLayer(*renderLayer);
2227 
2228         for (auto* renderLayer : layer.positiveZOrderLayers())
2229             recursiveRepaintLayer(*renderLayer);
2230     }
2231 
2232     for (auto* renderLayer : layer.normalFlowLayers())
2233         recursiveRepaintLayer(*renderLayer);
2234 }
2235 
2236 RenderLayer&amp; RenderLayerCompositor::rootRenderLayer() const
2237 {
2238     return *m_renderView.layer();
2239 }
2240 
</pre>
<hr />
<pre>
2327 }
2328 
2329 bool RenderLayerCompositor::needsToBeComposited(const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
2330 {
2331     if (!canBeComposited(layer))
2332         return false;
2333 
2334     return requiresCompositingLayer(layer, queryData) || layer.mustCompositeForIndirectReasons() || (usesCompositing() &amp;&amp; layer.isRenderViewLayer());
2335 }
2336 
2337 // Note: this specifies whether the RL needs a compositing layer for intrinsic reasons.
2338 // Use needsToBeComposited() to determine if a RL actually needs a compositing layer.
2339 // FIXME: is clipsCompositingDescendants() an intrinsic reason?
2340 bool RenderLayerCompositor::requiresCompositingLayer(const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
2341 {
2342     auto&amp; renderer = rendererForCompositingTests(layer);
2343 
2344     // The root layer always has a compositing layer, but it may not have backing.
2345     return requiresCompositingForTransform(renderer)
2346         || requiresCompositingForAnimation(renderer)

2347         || requiresCompositingForPosition(renderer, *renderer.layer(), queryData)
2348         || requiresCompositingForCanvas(renderer)
2349         || requiresCompositingForFilters(renderer)
2350         || requiresCompositingForWillChange(renderer)
2351         || requiresCompositingForBackfaceVisibility(renderer)
2352         || requiresCompositingForVideo(renderer)
2353         || requiresCompositingForFrame(renderer, queryData)
2354         || requiresCompositingForPlugin(renderer, queryData)
2355         || requiresCompositingForEditableImage(renderer)
2356         || requiresCompositingForOverflowScrolling(*renderer.layer(), queryData);
2357 }
2358 
2359 bool RenderLayerCompositor::canBeComposited(const RenderLayer&amp; layer) const
2360 {
2361     if (m_hasAcceleratedCompositing &amp;&amp; layer.isSelfPaintingLayer()) {
2362         if (!layer.isInsideFragmentedFlow())
2363             return true;
2364 
2365         // CSS Regions flow threads do not need to be composited as we use composited RenderFragmentContainers
2366         // to render the background of the RenderFragmentedFlow.
</pre>
<hr />
<pre>
2406         || layer.transform() // note: excludes perspective and transformStyle3D.
2407         || requiresCompositingForAnimation(renderer)
2408         || requiresCompositingForPosition(renderer, layer, queryData)
2409         || requiresCompositingForCanvas(renderer)
2410         || requiresCompositingForFilters(renderer)
2411         || requiresCompositingForWillChange(renderer)
2412         || requiresCompositingForBackfaceVisibility(renderer)
2413         || requiresCompositingForVideo(renderer)
2414         || requiresCompositingForFrame(renderer, queryData)
2415         || requiresCompositingForPlugin(renderer, queryData)
2416         || requiresCompositingForEditableImage(renderer)
2417         || requiresCompositingForOverflowScrolling(layer, queryData)
2418         || needsContentsCompositingLayer(layer)
2419         || renderer.isTransparent()
2420         || renderer.hasMask()
2421         || renderer.hasReflection()
2422         || renderer.hasFilter()
2423         || renderer.hasBackdropFilter())
2424         return true;
2425 
<span class="line-added">2426     if (layer.isComposited() &amp;&amp; layer.backing()-&gt;hasBackingSharingLayers())</span>
<span class="line-added">2427         return true;</span>
<span class="line-added">2428 </span>
<span class="line-added">2429     // FIXME: We really need to keep track of the ancestor layer that has its own backing store.</span>
<span class="line-added">2430     if (!ancestorCompositedBounds.contains(layerCompositedBoundsInAncestor))</span>
<span class="line-added">2431         return true;</span>
<span class="line-added">2432 </span>
2433     if (layer.mustCompositeForIndirectReasons()) {
2434         IndirectCompositingReason reason = layer.indirectCompositingReason();
2435         return reason == IndirectCompositingReason::Overlap
2436             || reason == IndirectCompositingReason::OverflowScrollPositioning
2437             || reason == IndirectCompositingReason::Stacking
2438             || reason == IndirectCompositingReason::BackgroundLayer
2439             || reason == IndirectCompositingReason::GraphicalEffect
2440             || reason == IndirectCompositingReason::Preserve3D; // preserve-3d has to create backing store to ensure that 3d-transformed elements intersect.
2441     }
2442 






2443     return false;
2444 }
2445 
2446 OptionSet&lt;CompositingReason&gt; RenderLayerCompositor::reasonsForCompositing(const RenderLayer&amp; layer) const
2447 {
2448     OptionSet&lt;CompositingReason&gt; reasons;
2449 
2450     if (!layer.isComposited())
2451         return reasons;
2452 
2453     RequiresCompositingData queryData;
2454 
2455     auto&amp; renderer = rendererForCompositingTests(layer);
2456 
2457     if (requiresCompositingForTransform(renderer))
2458         reasons.add(CompositingReason::Transform3D);
2459 
2460     if (requiresCompositingForVideo(renderer))
2461         reasons.add(CompositingReason::Video);
2462     else if (requiresCompositingForCanvas(renderer))
2463         reasons.add(CompositingReason::Canvas);
2464     else if (requiresCompositingForPlugin(renderer, queryData))
2465         reasons.add(CompositingReason::Plugin);
2466     else if (requiresCompositingForFrame(renderer, queryData))
2467         reasons.add(CompositingReason::IFrame);
2468     else if (requiresCompositingForEditableImage(renderer))
2469         reasons.add(CompositingReason::EmbeddedView);
2470 
2471     if ((canRender3DTransforms() &amp;&amp; renderer.style().backfaceVisibility() == BackfaceVisibility::Hidden))
2472         reasons.add(CompositingReason::BackfaceVisibilityHidden);
2473 



2474     if (requiresCompositingForAnimation(renderer))
2475         reasons.add(CompositingReason::Animation);
2476 
2477     if (requiresCompositingForFilters(renderer))
2478         reasons.add(CompositingReason::Filters);
2479 
2480     if (requiresCompositingForWillChange(renderer))
2481         reasons.add(CompositingReason::WillChange);
2482 
2483     if (requiresCompositingForPosition(renderer, *renderer.layer(), queryData))
2484         reasons.add(renderer.isFixedPositioned() ? CompositingReason::PositionFixed : CompositingReason::PositionSticky);
2485 
2486     if (requiresCompositingForOverflowScrolling(*renderer.layer(), queryData))
2487         reasons.add(CompositingReason::OverflowScrolling);
2488 
2489     switch (renderer.layer()-&gt;indirectCompositingReason()) {
2490     case IndirectCompositingReason::None:
2491         break;
<span class="line-added">2492     case IndirectCompositingReason::Clipping:</span>
<span class="line-added">2493         reasons.add(CompositingReason::ClipsCompositingDescendants);</span>
<span class="line-added">2494         break;</span>
2495     case IndirectCompositingReason::Stacking:
2496         reasons.add(CompositingReason::Stacking);
2497         break;
2498     case IndirectCompositingReason::OverflowScrollPositioning:
2499         reasons.add(CompositingReason::OverflowScrollPositioning);
2500         break;
2501     case IndirectCompositingReason::Overlap:
2502         reasons.add(CompositingReason::Overlap);
2503         break;
2504     case IndirectCompositingReason::BackgroundLayer:
2505         reasons.add(CompositingReason::NegativeZIndexChildren);
2506         break;
2507     case IndirectCompositingReason::GraphicalEffect:
2508         if (renderer.hasTransform())
2509             reasons.add(CompositingReason::TransformWithCompositedDescendants);
2510 
2511         if (renderer.isTransparent())
2512             reasons.add(CompositingReason::OpacityWithCompositedDescendants);
2513 
2514         if (renderer.hasMask())
</pre>
<hr />
<pre>
2761         return AncestorTraversal::Continue;
2762     });
2763 
2764     return containerScrollingNodeID;
2765 }
2766 
2767 // Return true if the given layer is a stacking context and has compositing child
2768 // layers that it needs to clip. In this case we insert a clipping GraphicsLayer
2769 // into the hierarchy between this layer and its children in the z-order hierarchy.
2770 bool RenderLayerCompositor::clipsCompositingDescendants(const RenderLayer&amp; layer)
2771 {
2772     return layer.hasCompositingDescendant() &amp;&amp; layer.renderer().hasClipOrOverflowClip() &amp;&amp; !layer.isolatesCompositedBlending();
2773 }
2774 
2775 bool RenderLayerCompositor::requiresCompositingForAnimation(RenderLayerModelObject&amp; renderer) const
2776 {
2777     if (!(m_compositingTriggers &amp; ChromeClient::AnimationTrigger))
2778         return false;
2779 
2780     if (auto* element = renderer.element()) {
<span class="line-modified">2781         if (auto* effectsStack = element-&gt;keyframeEffectStack()) {</span>
<span class="line-modified">2782             return (effectsStack-&gt;isCurrentlyAffectingProperty(CSSPropertyOpacity)</span>
<span class="line-modified">2783                 &amp;&amp; (usesCompositing() || (m_compositingTriggers &amp; ChromeClient::AnimatedOpacityTrigger)))</span>
<span class="line-added">2784                 || effectsStack-&gt;isCurrentlyAffectingProperty(CSSPropertyFilter)</span>
<span class="line-added">2785 #if ENABLE(FILTERS_LEVEL_2)</span>
<span class="line-added">2786                 || effectsStack-&gt;isCurrentlyAffectingProperty(CSSPropertyWebkitBackdropFilter)</span>
<span class="line-added">2787 #endif</span>
<span class="line-added">2788                 || effectsStack-&gt;isCurrentlyAffectingProperty(CSSPropertyTransform);</span>
2789         }
2790     }
2791 
2792     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
2793         return false;
2794 
2795     auto&amp; animController = renderer.animation();
2796     return (animController.isRunningAnimationOnRenderer(renderer, CSSPropertyOpacity)
2797         &amp;&amp; (usesCompositing() || (m_compositingTriggers &amp; ChromeClient::AnimatedOpacityTrigger)))
2798         || animController.isRunningAnimationOnRenderer(renderer, CSSPropertyFilter)
2799 #if ENABLE(FILTERS_LEVEL_2)
2800         || animController.isRunningAnimationOnRenderer(renderer, CSSPropertyWebkitBackdropFilter)
2801 #endif
2802         || animController.isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
2803 }
2804 
2805 bool RenderLayerCompositor::requiresCompositingForTransform(RenderLayerModelObject&amp; renderer) const
2806 {
2807     if (!(m_compositingTriggers &amp; ChromeClient::ThreeDTransformTrigger))
2808         return false;
</pre>
<hr />
<pre>
2964     if (frameRenderer.style().visibility() != Visibility::Visible)
2965         return false;
2966 
2967     if (!frameRenderer.requiresAcceleratedCompositing())
2968         return false;
2969 
2970     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
2971         queryData.reevaluateAfterLayout = true;
2972         return frameRenderer.isComposited();
2973     }
2974 
2975     // Don&#39;t go into compositing mode if height or width are zero.
2976     return !snappedIntRect(frameRenderer.contentBoxRect()).isEmpty();
2977 }
2978 
2979 bool RenderLayerCompositor::requiresCompositingForScrollableFrame(RequiresCompositingData&amp; queryData) const
2980 {
2981     if (isMainFrameCompositor())
2982         return false;
2983 
<span class="line-modified">2984 #if PLATFORM(COCOA) || USE(NICOSIA)</span>
2985     if (!m_renderView.settings().asyncFrameScrollingEnabled())
2986         return false;
2987 #endif
2988 
2989     if (!(m_compositingTriggers &amp; ChromeClient::ScrollableNonMainFrameTrigger))
2990         return false;
2991 
2992     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
2993         queryData.reevaluateAfterLayout = true;
2994         return m_renderView.isComposited();
2995     }
2996 
2997     return m_renderView.frameView().isScrollable();
2998 }
2999 
3000 bool RenderLayerCompositor::requiresCompositingForPosition(RenderLayerModelObject&amp; renderer, const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
3001 {
3002     // position:fixed elements that create their own stacking context (e.g. have an explicit z-index,
3003     // opacity, transform) can get their own composited layer. A stacking context is required otherwise
3004     // z-index and clipping will be broken.
</pre>
<hr />
<pre>
3053         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; is outside the viewport&quot;);
3054         return false;
3055     }
3056 
3057     return true;
3058 }
3059 
3060 bool RenderLayerCompositor::requiresCompositingForOverflowScrolling(const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
3061 {
3062     if (!layer.canUseCompositedScrolling())
3063         return false;
3064 
3065     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
3066         queryData.reevaluateAfterLayout = true;
3067         return layer.isComposited();
3068     }
3069 
3070     return layer.hasCompositedScrollableOverflow();
3071 }
3072 
<span class="line-modified">3073 IndirectCompositingReason RenderLayerCompositor::computeIndirectCompositingReason(const RenderLayer&amp; layer, bool hasCompositedDescendants, bool has3DTransformedDescendants, bool paintsIntoProvidedBacking) const</span>

3074 {
3075     // When a layer has composited descendants, some effects, like 2d transforms, filters, masks etc must be implemented
3076     // via compositing so that they also apply to those composited descendants.
3077     auto&amp; renderer = layer.renderer();
<span class="line-modified">3078     if (hasCompositedDescendants &amp;&amp; (layer.isolatesCompositedBlending() || layer.transform() || renderer.createsGroup() || renderer.hasReflection()))</span>
<span class="line-modified">3079         return IndirectCompositingReason::GraphicalEffect;</span>


3080 
3081     // A layer with preserve-3d or perspective only needs to be composited if there are descendant layers that
3082     // will be affected by the preserve-3d or perspective.
3083     if (has3DTransformedDescendants) {
<span class="line-modified">3084         if (renderer.style().transformStyle3D() == TransformStyle3D::Preserve3D)</span>
<span class="line-modified">3085             return IndirectCompositingReason::Preserve3D;</span>


3086 
<span class="line-modified">3087         if (renderer.style().hasPerspective())</span>
<span class="line-modified">3088             return IndirectCompositingReason::Perspective;</span>


3089     }
3090 
3091     // If this layer scrolls independently from the layer that it would paint into, it needs to get composited.
3092     if (!paintsIntoProvidedBacking &amp;&amp; layer.hasCompositedScrollingAncestor()) {
3093         auto* paintDestination = layer.paintOrderParent();
<span class="line-modified">3094         if (paintDestination &amp;&amp; layerScrollBehahaviorRelativeToCompositedAncestor(layer, *paintDestination) != ScrollPositioningBehavior::None)</span>
<span class="line-modified">3095             return IndirectCompositingReason::OverflowScrollPositioning;</span>


3096     }
3097 
<span class="line-modified">3098     // Check for clipping last; if compositing just for clipping, the layer doesn&#39;t need its own backing store.</span>
<span class="line-modified">3099     if (hasCompositedDescendants &amp;&amp; clipsCompositingDescendants(layer))</span>
<span class="line-added">3100         return IndirectCompositingReason::Clipping;</span>
<span class="line-added">3101 </span>
<span class="line-added">3102     return IndirectCompositingReason::None;</span>
3103 }
3104 
3105 bool RenderLayerCompositor::styleChangeMayAffectIndirectCompositingReasons(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
3106 {
3107     if (RenderElement::createsGroupForStyle(newStyle) != RenderElement::createsGroupForStyle(oldStyle))
3108         return true;
3109     if (newStyle.isolation() != oldStyle.isolation())
3110         return true;
3111     if (newStyle.hasTransform() != oldStyle.hasTransform())
3112         return true;
3113     if (newStyle.boxReflect() != oldStyle.boxReflect())
3114         return true;
3115     if (newStyle.transformStyle3D() != oldStyle.transformStyle3D())
3116         return true;
3117     if (newStyle.hasPerspective() != oldStyle.hasPerspective())
3118         return true;
3119 
3120     return false;
3121 }
3122 
</pre>
<hr />
<pre>
3257         if (scrollingNodeID)
3258             scrollingNodes.append(scrollingNodeID);
3259         else
3260             LOG(Scrolling, &quot;Layer %p doesn&#39;t have scrolling node ID yet&quot;, &amp;overflowLayer);
3261     };
3262 
3263     // Collect all the composited scrollers which affect the position of this layer relative to its compositing ancestor (which might be inside the scroller or the scroller itself).
3264     bool seenPaintOrderAncestor = false;
3265     traverseAncestorLayers(layer, [&amp;](const RenderLayer&amp; ancestorLayer, bool isContainingBlockChain, bool isPaintOrderAncestor) {
3266         seenPaintOrderAncestor |= isPaintOrderAncestor;
3267         if (isContainingBlockChain &amp;&amp; isPaintOrderAncestor)
3268             return AncestorTraversal::Stop;
3269 
3270         if (seenPaintOrderAncestor &amp;&amp; !isContainingBlockChain &amp;&amp; ancestorLayer.hasCompositedScrollableOverflow())
3271             appendOverflowLayerNodeID(ancestorLayer);
3272 
3273         return AncestorTraversal::Continue;
3274     });
3275 }
3276 
<span class="line-modified">3277 ScrollPositioningBehavior RenderLayerCompositor::computeCoordinatedPositioningForLayer(const RenderLayer&amp; layer, const RenderLayer* compositedAncestor) const</span>
3278 {
3279     if (layer.isRenderViewLayer())
3280         return ScrollPositioningBehavior::None;
3281 
3282     if (layer.renderer().isFixedPositioned())
3283         return ScrollPositioningBehavior::None;
3284 
3285     if (!layer.hasCompositedScrollingAncestor())
3286         return ScrollPositioningBehavior::None;
3287 
3288     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
3289     if (!scrollingCoordinator)
3290         return ScrollPositioningBehavior::None;
3291 

3292     if (!compositedAncestor) {
3293         ASSERT_NOT_REACHED();
3294         return ScrollPositioningBehavior::None;
3295     }
3296 
3297     return layerScrollBehahaviorRelativeToCompositedAncestor(layer, *compositedAncestor);
3298 }
3299 
3300 static Vector&lt;ScrollingNodeID&gt; collectRelatedCoordinatedScrollingNodes(const RenderLayer&amp; layer, ScrollPositioningBehavior positioningBehavior)
3301 {
3302     Vector&lt;ScrollingNodeID&gt; overflowNodeIDs;
3303 
3304     switch (positioningBehavior) {
3305     case ScrollPositioningBehavior::Stationary: {
3306         auto* compositedAncestor = layer.ancestorCompositingLayer();
3307         if (!compositedAncestor)
3308             return overflowNodeIDs;
3309         collectStationaryLayerRelatedOverflowNodes(layer, *compositedAncestor, overflowNodeIDs);
3310         break;
3311     }
</pre>
<hr />
<pre>
3325 
3326     auto* contentDocument = downcast&lt;RenderWidget&gt;(layer.renderer()).frameOwnerElement().contentDocument();
3327     if (!contentDocument)
3328         return false;
3329 
3330     auto* view = contentDocument-&gt;renderView();
3331     if (!view)
3332         return false;
3333 
3334     if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3335         return scrollingCoordinator-&gt;coordinatesScrollingForFrameView(view-&gt;frameView());
3336 
3337     return false;
3338 }
3339 
3340 bool RenderLayerCompositor::isRunningTransformAnimation(RenderLayerModelObject&amp; renderer) const
3341 {
3342     if (!(m_compositingTriggers &amp; ChromeClient::AnimationTrigger))
3343         return false;
3344 
<span class="line-modified">3345     if (auto* element = renderer.element()) {</span>
<span class="line-modified">3346         if (auto* effectsStack = element-&gt;keyframeEffectStack())</span>
<span class="line-modified">3347             return effectsStack-&gt;isCurrentlyAffectingProperty(CSSPropertyTransform);</span>



3348     }
<span class="line-added">3349 </span>
<span class="line-added">3350     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())</span>
<span class="line-added">3351         return false;</span>
<span class="line-added">3352 </span>
3353     return renderer.animation().isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
3354 }
3355 
3356 // If an element has composited negative z-index children, those children render in front of the
3357 // layer background, so we need an extra &#39;contents&#39; layer for the foreground of the layer object.
3358 bool RenderLayerCompositor::needsContentsCompositingLayer(const RenderLayer&amp; layer) const
3359 {
3360     for (auto* layer : layer.negativeZOrderLayers()) {
3361         if (layer-&gt;isComposited() || layer-&gt;hasCompositingDescendant())
3362             return true;
3363     }
3364 
3365     return false;
3366 }
3367 
3368 bool RenderLayerCompositor::requiresScrollLayer(RootLayerAttachment attachment) const
3369 {
3370     auto&amp; frameView = m_renderView.frameView();
3371 
3372     // This applies when the application UI handles scrolling, in which case RenderLayerCompositor doesn&#39;t need to manage it.
</pre>
<hr />
<pre>
3375 
3376     // We need to handle our own scrolling if we&#39;re:
3377     return !m_renderView.frameView().platformWidget() // viewless (i.e. non-Mac, or Mac in WebKit2)
3378         || attachment == RootLayerAttachedViaEnclosingFrame; // a composited frame on Mac
3379 }
3380 
3381 void paintScrollbar(Scrollbar* scrollbar, GraphicsContext&amp; context, const IntRect&amp; clip)
3382 {
3383     if (!scrollbar)
3384         return;
3385 
3386     context.save();
3387     const IntRect&amp; scrollbarRect = scrollbar-&gt;frameRect();
3388     context.translate(-scrollbarRect.location());
3389     IntRect transformedClip = clip;
3390     transformedClip.moveBy(scrollbarRect.location());
3391     scrollbar-&gt;paint(context, transformedClip);
3392     context.restore();
3393 }
3394 
<span class="line-modified">3395 void RenderLayerCompositor::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, const FloatRect&amp; clip, GraphicsLayerPaintBehavior)</span>
3396 {
3397 #if PLATFORM(MAC)
3398     LocalDefaultSystemAppearance localAppearance(m_renderView.useDarkAppearance());
3399 #endif
3400 
3401     IntRect pixelSnappedRectForIntegralPositionedItems = snappedIntRect(LayoutRect(clip));
3402     if (graphicsLayer == layerForHorizontalScrollbar())
3403         paintScrollbar(m_renderView.frameView().horizontalScrollbar(), context, pixelSnappedRectForIntegralPositionedItems);
3404     else if (graphicsLayer == layerForVerticalScrollbar())
3405         paintScrollbar(m_renderView.frameView().verticalScrollbar(), context, pixelSnappedRectForIntegralPositionedItems);
3406     else if (graphicsLayer == layerForScrollCorner()) {
3407         const IntRect&amp; scrollCorner = m_renderView.frameView().scrollCornerRect();
3408         context.save();
3409         context.translate(-scrollCorner.location());
3410         IntRect transformedClip = pixelSnappedRectForIntegralPositionedItems;
3411         transformedClip.moveBy(scrollCorner.location());
3412         m_renderView.frameView().paintScrollCorner(context, transformedClip);
3413         context.restore();
3414     }
3415 }
</pre>
<hr />
<pre>
4102     m_rootContentsLayer-&gt;addChild(WTFMove(overlayHost));
4103 }
4104 
4105 void RenderLayerCompositor::notifyIFramesOfCompositingChange()
4106 {
4107     // Compositing affects the answer to RenderIFrame::requiresAcceleratedCompositing(), so
4108     // we need to schedule a style recalc in our parent document.
4109     if (auto* ownerElement = m_renderView.document().ownerElement())
4110         ownerElement-&gt;scheduleInvalidateStyleAndLayerComposition();
4111 }
4112 
4113 bool RenderLayerCompositor::layerHas3DContent(const RenderLayer&amp; layer) const
4114 {
4115     const RenderStyle&amp; style = layer.renderer().style();
4116 
4117     if (style.transformStyle3D() == TransformStyle3D::Preserve3D || style.hasPerspective() || style.transform().has3DOperation())
4118         return true;
4119 
4120     const_cast&lt;RenderLayer&amp;&gt;(layer).updateLayerListsIfNeeded();
4121 
<span class="line-modified">4122 #if ASSERT_ENABLED</span>
4123     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(layer));
4124 #endif
4125 
4126     for (auto* renderLayer : layer.negativeZOrderLayers()) {
4127         if (layerHas3DContent(*renderLayer))
4128             return true;
4129     }
4130 
4131     for (auto* renderLayer : layer.positiveZOrderLayers()) {
4132         if (layerHas3DContent(*renderLayer))
4133             return true;
4134     }
4135 
4136     for (auto* renderLayer : layer.normalFlowLayers()) {
4137         if (layerHas3DContent(*renderLayer))
4138             return true;
4139     }
4140 
4141     return false;
4142 }
</pre>
<hr />
<pre>
4327     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4328 
4329     if (roles.contains(ScrollCoordinationRole::Scrolling))
4330         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::Scrolling);
4331 
4332     if (roles.contains(ScrollCoordinationRole::ScrollingProxy))
4333         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::ScrollingProxy);
4334 
4335     if (roles.contains(ScrollCoordinationRole::FrameHosting))
4336         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::FrameHosting);
4337 
4338     if (roles.contains(ScrollCoordinationRole::ViewportConstrained))
4339         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::ViewportConstrained);
4340 
4341     if (roles.contains(ScrollCoordinationRole::Positioning))
4342         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::Positioning);
4343 
4344     backing-&gt;detachFromScrollingCoordinator(roles);
4345 }
4346 
<span class="line-modified">4347 OptionSet&lt;ScrollCoordinationRole&gt; RenderLayerCompositor::coordinatedScrollingRolesForLayer(const RenderLayer&amp; layer, const RenderLayer* compositingAncestor) const</span>
4348 {
4349     OptionSet&lt;ScrollCoordinationRole&gt; coordinationRoles;
4350     if (isViewportConstrainedFixedOrStickyLayer(layer))
4351         coordinationRoles.add(ScrollCoordinationRole::ViewportConstrained);
4352 
4353     if (useCoordinatedScrollingForLayer(layer))
4354         coordinationRoles.add(ScrollCoordinationRole::Scrolling);
4355 
<span class="line-modified">4356     auto coordinatedPositioning = computeCoordinatedPositioningForLayer(layer, compositingAncestor);</span>
4357     switch (coordinatedPositioning) {
4358     case ScrollPositioningBehavior::Moves:
4359         coordinationRoles.add(ScrollCoordinationRole::ScrollingProxy);
4360         break;
4361     case ScrollPositioningBehavior::Stationary:
4362         coordinationRoles.add(ScrollCoordinationRole::Positioning);
4363         break;
4364     case ScrollPositioningBehavior::None:
4365         break;
4366     }
4367 
4368     if (isLayerForIFrameWithScrollCoordinatedContents(layer))
4369         coordinationRoles.add(ScrollCoordinationRole::FrameHosting);
4370 
4371     return coordinationRoles;
4372 }
4373 
<span class="line-modified">4374 ScrollingNodeID RenderLayerCompositor::updateScrollCoordinationForLayer(RenderLayer&amp; layer, const RenderLayer* compositingAncestor, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)</span>
4375 {
<span class="line-modified">4376     auto roles = coordinatedScrollingRolesForLayer(layer, compositingAncestor);</span>
4377 
4378 #if PLATFORM(IOS_FAMILY)
4379     if (m_legacyScrollingLayerCoordinator) {
4380         if (roles.contains(ScrollCoordinationRole::ViewportConstrained))
4381             m_legacyScrollingLayerCoordinator-&gt;addViewportConstrainedLayer(layer);
4382         else
4383             m_legacyScrollingLayerCoordinator-&gt;removeViewportConstrainedLayer(layer);
4384     }
4385 #endif
4386 
4387     if (!hasCoordinatedScrolling()) {
4388         // If this frame isn&#39;t coordinated, it cannot contain any scrolling tree nodes.
4389         return 0;
4390     }
4391 
4392     auto newNodeID = treeState.parentNodeID.valueOr(0);
4393 
4394     ScrollingTreeState childTreeState;
4395     ScrollingTreeState* currentTreeState = &amp;treeState;
4396 
4397     // If there&#39;s a positioning node, it&#39;s the parent scrolling node for fixed/sticky/scrolling/frame hosting.
4398     if (roles.contains(ScrollCoordinationRole::Positioning)) {
<span class="line-modified">4399         newNodeID = updateScrollingNodeForPositioningRole(layer, compositingAncestor, *currentTreeState, changes);</span>
4400         childTreeState.parentNodeID = newNodeID;
4401         currentTreeState = &amp;childTreeState;
4402     } else
4403         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::Positioning);
4404 
4405     // If there&#39;s a scrolling proxy node, it&#39;s the parent scrolling node for fixed/sticky/scrolling/frame hosting.
4406     if (roles.contains(ScrollCoordinationRole::ScrollingProxy)) {
4407         newNodeID = updateScrollingNodeForScrollingProxyRole(layer, *currentTreeState, changes);
4408         childTreeState.parentNodeID = newNodeID;
4409         currentTreeState = &amp;childTreeState;
4410     } else
4411         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::ScrollingProxy);
4412 
4413     // If is fixed or sticky, it&#39;s the parent scrolling node for scrolling/frame hosting.
4414     if (roles.contains(ScrollCoordinationRole::ViewportConstrained)) {
4415         newNodeID = updateScrollingNodeForViewportConstrainedRole(layer, *currentTreeState, changes);
4416         // ViewportConstrained nodes are the parent of same-layer scrolling nodes, so adjust the ScrollingTreeState.
4417         childTreeState.parentNodeID = newNodeID;
4418         currentTreeState = &amp;childTreeState;
4419     } else
</pre>
<hr />
<pre>
4605 {
4606     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4607 
4608     auto newNodeID = attachScrollingNode(layer, ScrollingNodeType::FrameHosting, treeState);
4609     if (!newNodeID) {
4610         ASSERT_NOT_REACHED();
4611         return treeState.parentNodeID.valueOr(0);
4612     }
4613 
4614     if (changes &amp; ScrollingNodeChangeFlags::Layer)
4615         scrollingCoordinator-&gt;setNodeLayers(newNodeID, { layer.backing()-&gt;graphicsLayer() });
4616 
4617     if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
4618         RenderLayer* scrollingAncestorLayer = m_scrollingNodeToLayerMap.get(treeState.parentNodeID.value());
4619         scrollingCoordinator-&gt;setRectRelativeToParentNode(newNodeID, parentRelativeScrollableRect(layer, scrollingAncestorLayer));
4620     }
4621 
4622     return newNodeID;
4623 }
4624 
<span class="line-modified">4625 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForPositioningRole(RenderLayer&amp; layer, const RenderLayer* compositingAncestor, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)</span>
4626 {
4627     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4628 
4629     auto newNodeID = attachScrollingNode(layer, ScrollingNodeType::Positioned, treeState);
4630     if (!newNodeID) {
4631         ASSERT_NOT_REACHED();
4632         return treeState.parentNodeID.valueOr(0);
4633     }
4634 
4635     if (changes &amp; ScrollingNodeChangeFlags::Layer) {
4636         auto&amp; backing = *layer.backing();
4637         scrollingCoordinator-&gt;setNodeLayers(newNodeID, { backing.graphicsLayer() });
4638     }
4639 
4640     if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
4641         // Would be nice to avoid calling computeCoordinatedPositioningForLayer() again.
<span class="line-modified">4642         auto positioningBehavior = computeCoordinatedPositioningForLayer(layer, compositingAncestor);</span>
4643         auto relatedNodeIDs = collectRelatedCoordinatedScrollingNodes(layer, positioningBehavior);
4644         scrollingCoordinator-&gt;setRelatedOverflowScrollingNodes(newNodeID, WTFMove(relatedNodeIDs));
4645 
4646         auto* graphicsLayer = layer.backing()-&gt;graphicsLayer();
4647         AbsolutePositionConstraints constraints;
4648         constraints.setAlignmentOffset(graphicsLayer-&gt;pixelAlignmentOffset());
4649         constraints.setLayerPositionAtLastLayout(graphicsLayer-&gt;position());
4650         scrollingCoordinator-&gt;setPositionedNodeConstraints(newNodeID, constraints);
4651     }
4652 
4653     return newNodeID;
4654 }
4655 
4656 ScrollableArea* RenderLayerCompositor::scrollableAreaForScrollLayerID(ScrollingNodeID nodeID) const
4657 {
4658     if (!nodeID)
4659         return nullptr;
4660 
4661     return m_scrollingNodeToLayerMap.get(nodeID);
4662 }
4663 
4664 void RenderLayerCompositor::willRemoveScrollingLayerWithBacking(RenderLayer&amp; layer, RenderLayerBacking&amp; backing)
4665 {
4666     if (scrollingCoordinator())
4667         return;
4668 
4669 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">4670     ASSERT(m_renderView.document().backForwardCacheState() == Document::NotInBackForwardCache);</span>
4671     if (m_legacyScrollingLayerCoordinator)
4672         m_legacyScrollingLayerCoordinator-&gt;removeScrollingLayer(layer, backing);
4673 #else
4674     UNUSED_PARAM(layer);
4675     UNUSED_PARAM(backing);
4676 #endif
4677 }
4678 
4679 // FIXME: This should really be called from the updateBackingAndHierarchy.
4680 void RenderLayerCompositor::didAddScrollingLayer(RenderLayer&amp; layer)
4681 {
4682     if (scrollingCoordinator())
4683         return;
4684 
4685 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">4686     ASSERT(m_renderView.document().backForwardCacheState() == Document::NotInBackForwardCache);</span>
4687     if (m_legacyScrollingLayerCoordinator)
4688         m_legacyScrollingLayerCoordinator-&gt;addScrollingLayer(layer);
4689 #else
4690     UNUSED_PARAM(layer);
4691 #endif
4692 }
4693 
4694 void RenderLayerCompositor::windowScreenDidChange(PlatformDisplayID displayID)
4695 {
4696     if (m_layerUpdater)
4697         m_layerUpdater-&gt;screenDidChange(displayID);
4698 }
4699 
4700 ScrollingCoordinator* RenderLayerCompositor::scrollingCoordinator() const
4701 {
4702     return page().scrollingCoordinator();
4703 }
4704 
4705 GraphicsLayerFactory* RenderLayerCompositor::graphicsLayerFactory() const
4706 {
</pre>
</td>
</tr>
</table>
<center><a href="RenderLayerBacking.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerCompositor.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
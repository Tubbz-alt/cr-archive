diff a/modules/javafx.web/src/main/native/Source/WebCore/loader/ContentFilter.cpp b/modules/javafx.web/src/main/native/Source/WebCore/loader/ContentFilter.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/loader/ContentFilter.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/loader/ContentFilter.cpp
@@ -27,10 +27,11 @@
 #include "ContentFilter.h"
 
 #if ENABLE(CONTENT_FILTERING)
 
 #include "CachedRawResource.h"
+#include "ContentFilterClient.h"
 #include "ContentFilterUnblockHandler.h"
 #include "DocumentLoader.h"
 #include "Frame.h"
 #include "FrameLoadRequest.h"
 #include "FrameLoader.h"
@@ -52,40 +53,39 @@
 namespace WebCore {
 
 Vector<ContentFilter::Type>& ContentFilter::types()
 {
     static NeverDestroyed<Vector<ContentFilter::Type>> types {
-        Vector<ContentFilter::Type> {
+        Vector<ContentFilter::Type>::from(
 #if HAVE(PARENTAL_CONTROLS)
             type<ParentalControlsContentFilter>(),
 #endif
 #if HAVE(NETWORK_EXTENSION)
             type<NetworkExtensionContentFilter>()
 #endif
-        }
+        )
     };
     return types;
 }
 
-std::unique_ptr<ContentFilter> ContentFilter::create(DocumentLoader& documentLoader)
+std::unique_ptr<ContentFilter> ContentFilter::create(ContentFilterClient& client)
 {
     Container filters;
     for (auto& type : types()) {
         auto filter = type.create();
-        ASSERT(filter);
         filters.append(WTFMove(filter));
     }
 
     if (filters.isEmpty())
         return nullptr;
 
-    return makeUnique<ContentFilter>(WTFMove(filters), documentLoader);
+    return makeUnique<ContentFilter>(WTFMove(filters), client);
 }
 
-ContentFilter::ContentFilter(Container&& contentFilters, DocumentLoader& documentLoader)
-    : m_contentFilters { WTFMove(contentFilters) }
-    , m_documentLoader { documentLoader }
+ContentFilter::ContentFilter(Container&& contentFilters, ContentFilterClient& client)
+    : m_contentFilters(WTFMove(contentFilters))
+    , m_client(client)
 {
     LOG(ContentFiltering, "Creating ContentFilter with %zu platform content filter(s).\n", m_contentFilters.size());
     ASSERT(!m_contentFilters.isEmpty());
 }
 
@@ -94,11 +94,11 @@
     LOG(ContentFiltering, "Destroying ContentFilter.\n");
 }
 
 bool ContentFilter::continueAfterWillSendRequest(ResourceRequest& request, const ResourceResponse& redirectResponse)
 {
-    Ref<DocumentLoader> protectedDocumentLoader { m_documentLoader };
+    Ref<ContentFilterClient> protectedClient { m_client };
 
     LOG(ContentFiltering, "ContentFilter received request for <%s> with redirect response from <%s>.\n", request.url().string().ascii().data(), redirectResponse.url().string().ascii().data());
 #if !LOG_DISABLED
     ResourceRequest originalRequest { request };
 #endif
@@ -133,11 +133,11 @@
     m_mainResource = nullptr;
 }
 
 bool ContentFilter::continueAfterResponseReceived(const ResourceResponse& response)
 {
-    Ref<DocumentLoader> protectedDocumentLoader { m_documentLoader };
+    Ref<ContentFilterClient> protectedClient { m_client };
 
     if (m_state == State::Filtering) {
         LOG(ContentFiltering, "ContentFilter received response from <%s>.\n", response.url().string().ascii().data());
         forEachContentFilterUntilBlocked([&response](PlatformContentFilter& contentFilter) {
             contentFilter.responseReceived(response);
@@ -147,11 +147,11 @@
     return m_state != State::Blocked;
 }
 
 bool ContentFilter::continueAfterDataReceived(const char* data, int length)
 {
-    Ref<DocumentLoader> protectedDocumentLoader { m_documentLoader };
+    Ref<ContentFilterClient> protectedClient { m_client };
 
     if (m_state == State::Filtering) {
         LOG(ContentFiltering, "ContentFilter received %d bytes of data from <%s>.\n", length, m_mainResource->url().string().ascii().data());
         forEachContentFilterUntilBlocked([data, length](PlatformContentFilter& contentFilter) {
             contentFilter.addData(data, length);
@@ -166,11 +166,11 @@
 }
 
 bool ContentFilter::continueAfterNotifyFinished(CachedResource& resource)
 {
     ASSERT_UNUSED(resource, &resource == m_mainResource);
-    Ref<DocumentLoader> protectedDocumentLoader { m_documentLoader };
+    Ref<ContentFilterClient> protectedClient { m_client };
 
     if (m_mainResource->errorOccurred())
         return true;
 
     if (m_state == State::Filtering) {
@@ -199,15 +199,15 @@
         if (!contentFilter->needsMoreData()) {
             ASSERT(!contentFilter->didBlockData());
             continue;
         }
 
-        function(*contentFilter);
+        function(contentFilter.get());
 
         if (contentFilter->didBlockData()) {
             ASSERT(!m_blockingContentFilter);
-            m_blockingContentFilter = contentFilter.get();
+            m_blockingContentFilter = &contentFilter;
             didDecide(State::Blocked);
             return;
         } else if (contentFilter->needsMoreData())
             allFiltersAllowedLoad = false;
     }
@@ -224,32 +224,20 @@
     LOG(ContentFiltering, "ContentFilter decided load should be %s for main resource at <%s>.\n", state == State::Allowed ? "allowed" : "blocked", m_mainResource ? m_mainResource->url().string().ascii().data() : "");
     m_state = state;
     if (m_state != State::Blocked)
         return;
 
-    ContentFilterUnblockHandler unblockHandler { m_blockingContentFilter->unblockHandler() };
-    unblockHandler.setUnreachableURL(m_documentLoader.documentURL());
-    auto frame { m_documentLoader.frame() };
-    String unblockRequestDeniedScript { m_blockingContentFilter->unblockRequestDeniedScript() };
-    if (!unblockRequestDeniedScript.isEmpty() && frame) {
-        unblockHandler.wrapWithDecisionHandler([scriptController = makeWeakPtr(frame->script()), script = unblockRequestDeniedScript.isolatedCopy()](bool unblocked) {
-            if (!unblocked && scriptController)
-                scriptController->executeScript(script);
-        });
-    }
-    m_documentLoader.frameLoader()->client().contentFilterDidBlockLoad(WTFMove(unblockHandler));
-
-    m_blockedError = m_documentLoader.frameLoader()->blockedByContentFilterError(m_documentLoader.request());
-    m_documentLoader.cancelMainResourceLoad(m_blockedError);
+    m_blockedError = m_client.contentFilterDidBlock(m_blockingContentFilter->unblockHandler(), m_blockingContentFilter->unblockRequestDeniedScript());
+    m_client.cancelMainResourceLoadForContentFilter(m_blockedError);
 }
 
 void ContentFilter::deliverResourceData(CachedResource& resource)
 {
     ASSERT(m_state == State::Allowed);
     ASSERT(resource.dataBufferingPolicy() == DataBufferingPolicy::BufferData);
     if (auto* resourceBuffer = resource.resourceBuffer())
-        m_documentLoader.dataReceived(resource, resourceBuffer->data(), resourceBuffer->size());
+        m_client.dataReceivedThroughContentFilter(resourceBuffer->data(), resourceBuffer->size());
 }
 
 static const URL& blockedPageURL()
 {
     static const auto blockedPageURL = makeNeverDestroyed([] () -> URL {
@@ -292,11 +280,11 @@
 
     RefPtr<SharedBuffer> replacementData { m_blockingContentFilter->replacementData() };
     ResourceResponse response { URL(), "text/html"_s, static_cast<long long>(replacementData->size()), "UTF-8"_s };
     SubstituteData substituteData { WTFMove(replacementData), error.failingURL(), response, SubstituteData::SessionHistoryVisibility::Hidden };
     SetForScope<bool> loadingBlockedPage { m_isLoadingBlockedPage, true };
-    m_documentLoader.frameLoader()->load(FrameLoadRequest(*m_documentLoader.frame(), blockedPageURL(), ShouldOpenExternalURLsPolicy::ShouldNotAllow, substituteData));
+    m_client.handleProvisionalLoadFailureFromContentFilter(blockedPageURL(), substituteData);
 }
 
 } // namespace WebCore
 
 #endif // ENABLE(CONTENT_FILTERING)

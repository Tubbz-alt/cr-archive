diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/HashMapImpl.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/HashMapImpl.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/HashMapImpl.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/HashMapImpl.h
@@ -51,12 +51,12 @@
     WriteBarrier<Unknown> key;
     WriteBarrier<Unknown> value;
 };
 
 template <typename Data>
-class HashMapBucket : public JSCell {
-    typedef JSCell Base;
+class HashMapBucket final : public JSCell {
+    using Base = JSCell;
 
     template <typename T = Data>
     static typename std::enable_if<std::is_same<T, HashMapBucketDataKey>::value, Structure*>::type selectStructure(VM& vm)
     {
         return vm.hashMapBucketSetStructure.get();
@@ -70,20 +70,25 @@
 
 public:
     static const HashTableType Type = Data::Type;
     static const ClassInfo s_info; // This is never accessed directly, since that would break linkage on some compilers.
 
+    template<typename CellType, SubspaceAccess mode>
+    static IsoSubspace* subspaceFor(VM& vm)
+    {
+        if constexpr (Type == HashTableType::Key)
+            return vm.setBucketSpace<mode>();
+        else
+            return vm.mapBucketSpace<mode>();
+    }
 
     static const ClassInfo* info()
     {
-        switch (Type) {
-        case HashTableType::Key:
+        if constexpr (Type == HashTableType::Key)
             return getHashMapBucketKeyClassInfo();
-        case HashTableType::KeyValue:
+        else
             return getHashMapBucketKeyValueClassInfo();
-        }
-        RELEASE_ASSERT_NOT_REACHED();
     }
 
     static Structure* createStructure(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
     {
         return Structure::create(vm, globalObject, prototype, TypeInfo(CellType, StructureFlags), info());
@@ -202,17 +207,17 @@
     ALWAYS_INLINE BucketType** buffer() const
     {
         return bitwise_cast<BucketType**>(this);
     }
 
-    static HashMapBuffer* create(ExecState* exec, VM& vm, JSCell*, uint32_t capacity)
+    static HashMapBuffer* create(JSGlobalObject* globalObject, VM& vm, JSCell*, uint32_t capacity)
     {
         auto scope = DECLARE_THROW_SCOPE(vm);
         size_t allocationSize = HashMapBuffer::allocationSize(capacity);
         void* data = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(vm, allocationSize, nullptr, AllocationFailureMode::ReturnNull);
         if (!data) {
-            throwOutOfMemoryError(exec, scope);
+            throwOutOfMemoryError(globalObject, scope);
             return nullptr;
         }
 
         HashMapBuffer* buffer = static_cast<HashMapBuffer*>(data);
         buffer->reset(capacity);
@@ -223,17 +228,17 @@
     {
         memset(this, -1, allocationSize(capacity));
     }
 };
 
-ALWAYS_INLINE static bool areKeysEqual(ExecState* exec, JSValue a, JSValue b)
+ALWAYS_INLINE static bool areKeysEqual(JSGlobalObject* globalObject, JSValue a, JSValue b)
 {
     // We want +0 and -0 to be compared to true here. sameValue() itself doesn't
     // guarantee that, however, we normalize all keys before comparing and storing
     // them in the map. The normalization will convert -0.0 and 0.0 to the integer
     // representation for 0.
-    return sameValue(exec, a, b);
+    return sameValue(globalObject, a, b);
 }
 
 // Note that normalization is inlined in DFG's NormalizeMapKey.
 // Keep in sync with the implementation of DFG and FTL normalization.
 ALWAYS_INLINE JSValue normalizeMapKey(JSValue key)
@@ -269,17 +274,17 @@
     key += ~(key << 27);
     key ^= (key >> 31);
     return static_cast<unsigned>(key);
 }
 
-ALWAYS_INLINE uint32_t jsMapHash(ExecState* exec, VM& vm, JSValue value)
+ALWAYS_INLINE uint32_t jsMapHash(JSGlobalObject* globalObject, VM& vm, JSValue value)
 {
     ASSERT_WITH_MESSAGE(normalizeMapKey(value) == value, "We expect normalized values flowing into this function.");
 
     if (value.isString()) {
         auto scope = DECLARE_THROW_SCOPE(vm);
-        const String& wtfString = asString(value)->value(exec);
+        const String& wtfString = asString(value)->value(globalObject);
         RETURN_IF_EXCEPTION(scope, UINT_MAX);
         return wtfString.impl()->hash();
     }
 
     return wangsInt64Hash(JSValue::encode(value));
@@ -370,42 +375,42 @@
     ALWAYS_INLINE HashMapBucketType** buffer() const
     {
         return m_buffer->buffer();
     }
 
-    void finishCreation(ExecState* exec, VM& vm)
+    void finishCreation(JSGlobalObject* globalObject, VM& vm)
     {
         ASSERT_WITH_MESSAGE(HashMapBucket<HashMapBucketDataKey>::offsetOfKey() == HashMapBucket<HashMapBucketDataKeyValue>::offsetOfKey(), "We assume this to be true in the DFG and FTL JIT.");
 
         auto scope = DECLARE_THROW_SCOPE(vm);
         Base::finishCreation(vm);
 
-        makeAndSetNewBuffer(exec, vm);
+        makeAndSetNewBuffer(globalObject, vm);
         RETURN_IF_EXCEPTION(scope, void());
 
-        setUpHeadAndTail(exec, vm);
+        setUpHeadAndTail(globalObject, vm);
     }
 
-    void finishCreation(ExecState* exec, VM& vm, HashMapImpl* base)
+    void finishCreation(JSGlobalObject* globalObject, VM& vm, HashMapImpl* base)
     {
         auto scope = DECLARE_THROW_SCOPE(vm);
         Base::finishCreation(vm);
 
         // This size should be the same to the case when you clone the map by calling add() repeatedly.
         uint32_t capacity = ((Checked<uint32_t>(base->m_keyCount) * 2) + 1).unsafeGet();
         RELEASE_ASSERT(capacity <= (1U << 31));
         capacity = std::max<uint32_t>(WTF::roundUpToPowerOfTwo(capacity), 4U);
         m_capacity = capacity;
-        makeAndSetNewBuffer(exec, vm);
+        makeAndSetNewBuffer(globalObject, vm);
         RETURN_IF_EXCEPTION(scope, void());
 
-        setUpHeadAndTail(exec, vm);
+        setUpHeadAndTail(globalObject, vm);
 
         HashMapBucketType* bucket = base->m_head.get()->next();
         while (bucket) {
             if (!bucket->deleted()) {
-                addNormalizedNonExistingForCloning(exec, bucket->key(), HashMapBucketType::extractValue(*bucket));
+                addNormalizedNonExistingForCloning(globalObject, bucket->key(), HashMapBucketType::extractValue(*bucket));
                 RETURN_IF_EXCEPTION(scope, void());
             }
             bucket = bucket->next();
         }
         checkConsistency();
@@ -429,69 +434,69 @@
     static ALWAYS_INLINE bool isDeleted(HashMapBucketType* bucket)
     {
         return bucket == deletedValue();
     }
 
-    ALWAYS_INLINE HashMapBucketType** findBucket(ExecState* exec, JSValue key)
+    ALWAYS_INLINE HashMapBucketType** findBucket(JSGlobalObject* globalObject, JSValue key)
     {
-        VM& vm = exec->vm();
+        VM& vm = getVM(globalObject);
         auto scope = DECLARE_THROW_SCOPE(vm);
         key = normalizeMapKey(key);
-        uint32_t hash = jsMapHash(exec, vm, key);
+        uint32_t hash = jsMapHash(globalObject, vm, key);
         RETURN_IF_EXCEPTION(scope, nullptr);
-        return findBucket(exec, key, hash);
+        return findBucket(globalObject, key, hash);
     }
 
-    ALWAYS_INLINE HashMapBucketType** findBucket(ExecState* exec, JSValue key, uint32_t hash)
+    ALWAYS_INLINE HashMapBucketType** findBucket(JSGlobalObject* globalObject, JSValue key, uint32_t hash)
     {
         ASSERT_WITH_MESSAGE(normalizeMapKey(key) == key, "We expect normalized values flowing into this function.");
-        return findBucketAlreadyHashedAndNormalized(exec, key, hash);
+        return findBucketAlreadyHashedAndNormalized(globalObject, key, hash);
     }
 
     template <typename T = HashMapBucketType>
-    ALWAYS_INLINE typename std::enable_if<std::is_same<T, HashMapBucket<HashMapBucketDataKeyValue>>::value, JSValue>::type get(ExecState* exec, JSValue key)
+    ALWAYS_INLINE typename std::enable_if<std::is_same<T, HashMapBucket<HashMapBucketDataKeyValue>>::value, JSValue>::type get(JSGlobalObject* globalObject, JSValue key)
     {
-        if (HashMapBucketType** bucket = findBucket(exec, key))
+        if (HashMapBucketType** bucket = findBucket(globalObject, key))
             return (*bucket)->value();
         return jsUndefined();
     }
 
-    ALWAYS_INLINE bool has(ExecState* exec, JSValue key)
+    ALWAYS_INLINE bool has(JSGlobalObject* globalObject, JSValue key)
     {
-        return !!findBucket(exec, key);
+        return !!findBucket(globalObject, key);
     }
 
-    ALWAYS_INLINE void add(ExecState* exec, JSValue key, JSValue value = JSValue())
+    ALWAYS_INLINE void add(JSGlobalObject* globalObject, JSValue key, JSValue value = JSValue())
     {
         key = normalizeMapKey(key);
-        addNormalizedInternal(exec, key, value, [&] (HashMapBucketType* bucket) {
-            return !isDeleted(bucket) && areKeysEqual(exec, key, bucket->key());
+        addNormalizedInternal(globalObject, key, value, [&] (HashMapBucketType* bucket) {
+            return !isDeleted(bucket) && areKeysEqual(globalObject, key, bucket->key());
         });
         if (shouldRehashAfterAdd())
-            rehash(exec);
+            rehash(globalObject);
     }
 
-    ALWAYS_INLINE HashMapBucketType* addNormalized(ExecState* exec, JSValue key, JSValue value, uint32_t hash)
+    ALWAYS_INLINE HashMapBucketType* addNormalized(JSGlobalObject* globalObject, JSValue key, JSValue value, uint32_t hash)
     {
         ASSERT_WITH_MESSAGE(normalizeMapKey(key) == key, "We expect normalized values flowing into this function.");
-        ASSERT_WITH_MESSAGE(jsMapHash(exec, exec->vm(), key) == hash, "We expect hash value is what we expect.");
+        ASSERT_WITH_MESSAGE(jsMapHash(globalObject, getVM(globalObject), key) == hash, "We expect hash value is what we expect.");
 
-        auto* bucket = addNormalizedInternal(exec->vm(), key, value, hash, [&] (HashMapBucketType* bucket) {
-            return !isDeleted(bucket) && areKeysEqual(exec, key, bucket->key());
+        auto* bucket = addNormalizedInternal(getVM(globalObject), key, value, hash, [&] (HashMapBucketType* bucket) {
+            return !isDeleted(bucket) && areKeysEqual(globalObject, key, bucket->key());
         });
         if (shouldRehashAfterAdd())
-            rehash(exec);
+            rehash(globalObject);
         return bucket;
     }
 
-    ALWAYS_INLINE bool remove(ExecState* exec, JSValue key)
+    ALWAYS_INLINE bool remove(JSGlobalObject* globalObject, JSValue key)
     {
-        HashMapBucketType** bucket = findBucket(exec, key);
+        HashMapBucketType** bucket = findBucket(globalObject, key);
         if (!bucket)
             return false;
 
-        VM& vm = exec->vm();
+        VM& vm = getVM(globalObject);
         HashMapBucketType* impl = *bucket;
         impl->next()->setPrev(vm, impl->prev());
         impl->prev()->setNext(vm, impl->next());
         impl->makeDeleted(vm);
 
@@ -500,23 +505,23 @@
         ++m_deleteCount;
         ASSERT(m_keyCount > 0);
         --m_keyCount;
 
         if (shouldShrink())
-            rehash(exec);
+            rehash(globalObject);
 
         return true;
     }
 
     ALWAYS_INLINE uint32_t size() const
     {
         return m_keyCount;
     }
 
-    ALWAYS_INLINE void clear(ExecState* exec)
+    ALWAYS_INLINE void clear(JSGlobalObject* globalObject)
     {
-        VM& vm = exec->vm();
+        VM& vm = getVM(globalObject);
         m_keyCount = 0;
         m_deleteCount = 0;
         HashMapBucketType* head = m_head.get();
         HashMapBucketType* bucket = m_head->next();
         HashMapBucketType* tail = m_tail.get();
@@ -528,11 +533,11 @@
             bucket = next;
         }
         m_head->setNext(vm, m_tail.get());
         m_tail->setPrev(vm, m_head.get());
         m_capacity = 4;
-        makeAndSetNewBuffer(exec, vm);
+        makeAndSetNewBuffer(globalObject, vm);
         checkConsistency();
     }
 
     ALWAYS_INLINE size_t bufferSizeInBytes() const
     {
@@ -575,35 +580,35 @@
     ALWAYS_INLINE uint32_t shouldShrink() const
     {
         return JSC::shouldShrink(m_capacity, m_keyCount);
     }
 
-    ALWAYS_INLINE void setUpHeadAndTail(ExecState*, VM& vm)
+    ALWAYS_INLINE void setUpHeadAndTail(JSGlobalObject*, VM& vm)
     {
         m_head.set(vm, this, HashMapBucketType::create(vm));
         m_tail.set(vm, this, HashMapBucketType::create(vm));
 
         m_head->setNext(vm, m_tail.get());
         m_tail->setPrev(vm, m_head.get());
         ASSERT(m_head->deleted());
         ASSERT(m_tail->deleted());
     }
 
-    ALWAYS_INLINE void addNormalizedNonExistingForCloning(ExecState* exec, JSValue key, JSValue value = JSValue())
+    ALWAYS_INLINE void addNormalizedNonExistingForCloning(JSGlobalObject* globalObject, JSValue key, JSValue value = JSValue())
     {
-        addNormalizedInternal(exec, key, value, [&] (HashMapBucketType*) {
+        addNormalizedInternal(globalObject, key, value, [&] (HashMapBucketType*) {
             return false;
         });
     }
 
     template<typename CanUseBucket>
-    ALWAYS_INLINE void addNormalizedInternal(ExecState* exec, JSValue key, JSValue value, const CanUseBucket& canUseBucket)
+    ALWAYS_INLINE void addNormalizedInternal(JSGlobalObject* globalObject, JSValue key, JSValue value, const CanUseBucket& canUseBucket)
     {
-        VM& vm = exec->vm();
+        VM& vm = getVM(globalObject);
         auto scope = DECLARE_THROW_SCOPE(vm);
 
-        uint32_t hash = jsMapHash(exec, vm, key);
+        uint32_t hash = jsMapHash(globalObject, vm, key);
         RETURN_IF_EXCEPTION(scope, void());
         scope.release();
         addNormalizedInternal(vm, key, value, hash, canUseBucket);
     }
 
@@ -638,36 +643,36 @@
 
         ++m_keyCount;
         return newEntry;
     }
 
-    ALWAYS_INLINE HashMapBucketType** findBucketAlreadyHashedAndNormalized(ExecState* exec, JSValue key, uint32_t hash)
+    ALWAYS_INLINE HashMapBucketType** findBucketAlreadyHashedAndNormalized(JSGlobalObject* globalObject, JSValue key, uint32_t hash)
     {
         const uint32_t mask = m_capacity - 1;
         uint32_t index = hash & mask;
         HashMapBucketType** buffer = this->buffer();
         HashMapBucketType* bucket = buffer[index];
 
         while (!isEmpty(bucket)) {
-            if (!isDeleted(bucket) && areKeysEqual(exec, key, bucket->key()))
+            if (!isDeleted(bucket) && areKeysEqual(globalObject, key, bucket->key()))
                 return buffer + index;
             index = (index + 1) & mask;
             bucket = buffer[index];
         }
         return nullptr;
     }
 
-    void rehash(ExecState* exec)
+    void rehash(JSGlobalObject* globalObject)
     {
-        VM& vm = exec->vm();
+        VM& vm = getVM(globalObject);
         auto scope = DECLARE_THROW_SCOPE(vm);
 
         uint32_t oldCapacity = m_capacity;
         m_capacity = nextCapacity(m_capacity, m_keyCount);
 
         if (m_capacity != oldCapacity) {
-            makeAndSetNewBuffer(exec, vm);
+            makeAndSetNewBuffer(globalObject, vm);
             RETURN_IF_EXCEPTION(scope, void());
         } else {
             m_buffer->reset(m_capacity);
             assertBufferIsEmpty();
         }
@@ -676,11 +681,11 @@
         HashMapBucketType* end = m_tail.get();
         const uint32_t mask = m_capacity - 1;
         RELEASE_ASSERT(!(m_capacity & (m_capacity - 1)));
         HashMapBucketType** buffer = this->buffer();
         while (iter != end) {
-            uint32_t index = jsMapHash(exec, vm, iter->key()) & mask;
+            uint32_t index = jsMapHash(globalObject, vm, iter->key()) & mask;
             EXCEPTION_ASSERT_WITH_MESSAGE(!scope.exception(), "All keys should already be hashed before, so this should not throw because it won't resolve ropes.");
             {
                 HashMapBucketType* bucket = buffer[index];
                 while (!isEmpty(bucket)) {
                     index = (index + 1) & mask;
@@ -696,11 +701,11 @@
         checkConsistency();
     }
 
     ALWAYS_INLINE void checkConsistency() const
     {
-        if (!ASSERT_DISABLED) {
+        if (ASSERT_ENABLED) {
             HashMapBucketType* iter = m_head->next();
             HashMapBucketType* end = m_tail.get();
             uint32_t size = 0;
             while (iter != end) {
                 ++size;
@@ -708,25 +713,25 @@
             }
             ASSERT(size == m_keyCount);
         }
     }
 
-    void makeAndSetNewBuffer(ExecState* exec, VM& vm)
+    void makeAndSetNewBuffer(JSGlobalObject* globalObject, VM& vm)
     {
         ASSERT(!(m_capacity & (m_capacity - 1)));
 
-        HashMapBufferType* buffer = HashMapBufferType::create(exec, vm, this, m_capacity);
+        HashMapBufferType* buffer = HashMapBufferType::create(globalObject, vm, this, m_capacity);
         if (UNLIKELY(!buffer))
             return;
 
         m_buffer.set(vm, this, buffer);
         assertBufferIsEmpty();
     }
 
     ALWAYS_INLINE void assertBufferIsEmpty() const
     {
-        if (!ASSERT_DISABLED) {
+        if (ASSERT_ENABLED) {
             for (unsigned i = 0; i < m_capacity; i++)
                 ASSERT(isEmpty(buffer()[i]));
         }
     }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InlineAccess.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InlineAccess.h&quot;
 28 
 29 #if ENABLE(JIT)
 30 
 31 #include &quot;CCallHelpers.h&quot;
 32 #include &quot;JSArray.h&quot;
 33 #include &quot;JSCellInlines.h&quot;
 34 #include &quot;LinkBuffer.h&quot;
 35 #include &quot;ScratchRegisterAllocator.h&quot;
 36 #include &quot;Structure.h&quot;
 37 #include &quot;StructureStubInfo.h&quot;
 38 
 39 namespace JSC {
 40 
 41 void InlineAccess::dumpCacheSizesAndCrash()
 42 {
 43     GPRReg base = GPRInfo::regT0;
 44     GPRReg value = GPRInfo::regT1;
 45 #if USE(JSVALUE32_64)
 46     JSValueRegs regs(base, value);
 47 #else
 48     JSValueRegs regs(base);
 49 #endif
 50     {
 51         CCallHelpers jit;
 52 
 53         GPRReg scratchGPR = value;
 54         jit.patchableBranch8(
 55             CCallHelpers::NotEqual,
 56             CCallHelpers::Address(base, JSCell::typeInfoTypeOffset()),
 57             CCallHelpers::TrustedImm32(StringType));
 58 
 59         jit.loadPtr(CCallHelpers::Address(base, JSString::offsetOfValue()), scratchGPR);
 60         auto isRope = jit.branchIfRopeStringImpl(scratchGPR);
 61         jit.load32(CCallHelpers::Address(scratchGPR, StringImpl::lengthMemoryOffset()), regs.payloadGPR());
 62         auto done = jit.jump();
 63 
 64         isRope.link(&amp;jit);
 65         jit.load32(CCallHelpers::Address(base, JSRopeString::offsetOfLength()), regs.payloadGPR());
 66 
 67         done.link(&amp;jit);
 68         jit.boxInt32(regs.payloadGPR(), regs);
 69 
 70         dataLog(&quot;string length size: &quot;, jit.m_assembler.buffer().codeSize(), &quot;\n&quot;);
 71     }
 72 
 73     {
 74         CCallHelpers jit;
 75 
 76         GPRReg scratchGPR = value;
 77         jit.load8(CCallHelpers::Address(base, JSCell::indexingTypeAndMiscOffset()), value);
 78         jit.and32(CCallHelpers::TrustedImm32(IsArray | IndexingShapeMask), value);
 79         jit.patchableBranch32(
 80             CCallHelpers::NotEqual, value, CCallHelpers::TrustedImm32(IsArray | ContiguousShape));
 81         jit.loadPtr(CCallHelpers::Address(base, JSObject::butterflyOffset()), value);
 82         jit.load32(CCallHelpers::Address(value, ArrayStorage::lengthOffset()), value);
 83         jit.boxInt32(scratchGPR, regs);
 84 
 85         dataLog(&quot;array length size: &quot;, jit.m_assembler.buffer().codeSize(), &quot;\n&quot;);
 86     }
 87 
 88     {
 89         CCallHelpers jit;
 90 
 91         jit.patchableBranch32(
 92             MacroAssembler::NotEqual,
 93             MacroAssembler::Address(base, JSCell::structureIDOffset()),
 94             MacroAssembler::TrustedImm32(0x000ab21ca));
 95         jit.loadPtr(
 96             CCallHelpers::Address(base, JSObject::butterflyOffset()),
 97             value);
 98         GPRReg storageGPR = value;
 99         jit.loadValue(
100             CCallHelpers::Address(storageGPR, 0x000ab21ca), regs);
101 
102         dataLog(&quot;out of line offset cache size: &quot;, jit.m_assembler.buffer().codeSize(), &quot;\n&quot;);
103     }
104 
105     {
106         CCallHelpers jit;
107 
108         jit.patchableBranch32(
109             MacroAssembler::NotEqual,
110             MacroAssembler::Address(base, JSCell::structureIDOffset()),
111             MacroAssembler::TrustedImm32(0x000ab21ca));
112         jit.loadValue(
113             MacroAssembler::Address(base, 0x000ab21ca), regs);
114 
115         dataLog(&quot;inline offset cache size: &quot;, jit.m_assembler.buffer().codeSize(), &quot;\n&quot;);
116     }
117 
118     {
119         CCallHelpers jit;
120 
121         jit.patchableBranch32(
122             MacroAssembler::NotEqual,
123             MacroAssembler::Address(base, JSCell::structureIDOffset()),
124             MacroAssembler::TrustedImm32(0x000ab21ca));
125 
126         jit.storeValue(
127             regs, MacroAssembler::Address(base, 0x000ab21ca));
128 
129         dataLog(&quot;replace cache size: &quot;, jit.m_assembler.buffer().codeSize(), &quot;\n&quot;);
130     }
131 
132     {
133         CCallHelpers jit;
134 
135         jit.patchableBranch32(
136             MacroAssembler::NotEqual,
137             MacroAssembler::Address(base, JSCell::structureIDOffset()),
138             MacroAssembler::TrustedImm32(0x000ab21ca));
139 
140         jit.loadPtr(MacroAssembler::Address(base, JSObject::butterflyOffset()), value);
141         jit.storeValue(
142             regs,
143             MacroAssembler::Address(base, 120342));
144 
145         dataLog(&quot;replace out of line cache size: &quot;, jit.m_assembler.buffer().codeSize(), &quot;\n&quot;);
146     }
147 
148     CRASH();
149 }
150 
151 
152 template &lt;typename Function&gt;
153 ALWAYS_INLINE static bool linkCodeInline(const char* name, CCallHelpers&amp; jit, StructureStubInfo&amp; stubInfo, const Function&amp; function)
154 {
<a name="1" id="anc1"></a><span class="line-modified">155     if (jit.m_assembler.buffer().codeSize() &lt;= stubInfo.patch.inlineSize()) {</span>
156         bool needsBranchCompaction = true;
<a name="2" id="anc2"></a><span class="line-modified">157         LinkBuffer linkBuffer(jit, stubInfo.patch.start, stubInfo.patch.inlineSize(), JITCompilationMustSucceed, needsBranchCompaction);</span>
158         ASSERT(linkBuffer.isValid());
159         function(linkBuffer);
160         FINALIZE_CODE(linkBuffer, NoPtrTag, &quot;InlineAccessType: &#39;%s&#39;&quot;, name);
161         return true;
162     }
163 
164     // This is helpful when determining the size for inline ICs on various
165     // platforms. You want to choose a size that usually succeeds, but sometimes
166     // there may be variability in the length of the code we generate just because
167     // of randomness. It&#39;s helpful to flip this on when running tests or browsing
168     // the web just to see how often it fails. You don&#39;t want an IC size that always fails.
169     constexpr bool failIfCantInline = false;
170     if (failIfCantInline) {
171         dataLog(&quot;Failure for: &quot;, name, &quot;\n&quot;);
<a name="3" id="anc3"></a><span class="line-modified">172         dataLog(&quot;real size: &quot;, jit.m_assembler.buffer().codeSize(), &quot; inline size:&quot;, stubInfo.patch.inlineSize(), &quot;\n&quot;);</span>
173         CRASH();
174     }
175 
176     return false;
177 }
178 
179 bool InlineAccess::generateSelfPropertyAccess(StructureStubInfo&amp; stubInfo, Structure* structure, PropertyOffset offset)
180 {
<a name="4" id="anc4"></a>


181     CCallHelpers jit;
182 
<a name="5" id="anc5"></a><span class="line-modified">183     GPRReg base = stubInfo.baseGPR();</span>
184     JSValueRegs value = stubInfo.valueRegs();
185 
186     auto branchToSlowPath = jit.patchableBranch32(
187         MacroAssembler::NotEqual,
188         MacroAssembler::Address(base, JSCell::structureIDOffset()),
189         MacroAssembler::TrustedImm32(bitwise_cast&lt;uint32_t&gt;(structure-&gt;id())));
190     GPRReg storage;
191     if (isInlineOffset(offset))
192         storage = base;
193     else {
194         jit.loadPtr(CCallHelpers::Address(base, JSObject::butterflyOffset()), value.payloadGPR());
195         storage = value.payloadGPR();
196     }
197 
198     jit.loadValue(
199         MacroAssembler::Address(storage, offsetRelativeToBase(offset)), value);
200 
201     bool linkedCodeInline = linkCodeInline(&quot;property access&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<a name="6" id="anc6"></a><span class="line-modified">202         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation());</span>
203     });
204     return linkedCodeInline;
205 }
206 
207 ALWAYS_INLINE static GPRReg getScratchRegister(StructureStubInfo&amp; stubInfo)
208 {
<a name="7" id="anc7"></a><span class="line-modified">209     ScratchRegisterAllocator allocator(stubInfo.patch.usedRegisters);</span>
<span class="line-modified">210     allocator.lock(stubInfo.baseGPR());</span>
<span class="line-modified">211     allocator.lock(stubInfo.patch.valueGPR);</span>
212 #if USE(JSVALUE32_64)
<a name="8" id="anc8"></a><span class="line-modified">213     allocator.lock(stubInfo.patch.baseTagGPR);</span>
<span class="line-modified">214     allocator.lock(stubInfo.patch.valueTagGPR);</span>
215 #endif
216     GPRReg scratch = allocator.allocateScratchGPR();
217     if (allocator.didReuseRegisters())
218         return InvalidGPRReg;
219     return scratch;
220 }
221 
222 ALWAYS_INLINE static bool hasFreeRegister(StructureStubInfo&amp; stubInfo)
223 {
224     return getScratchRegister(stubInfo) != InvalidGPRReg;
225 }
226 
227 bool InlineAccess::canGenerateSelfPropertyReplace(StructureStubInfo&amp; stubInfo, PropertyOffset offset)
228 {
<a name="9" id="anc9"></a>


229     if (isInlineOffset(offset))
230         return true;
231 
232     return hasFreeRegister(stubInfo);
233 }
234 
235 bool InlineAccess::generateSelfPropertyReplace(StructureStubInfo&amp; stubInfo, Structure* structure, PropertyOffset offset)
236 {
<a name="10" id="anc10"></a>


237     ASSERT(canGenerateSelfPropertyReplace(stubInfo, offset));
238 
239     CCallHelpers jit;
240 
<a name="11" id="anc11"></a><span class="line-modified">241     GPRReg base = stubInfo.baseGPR();</span>
242     JSValueRegs value = stubInfo.valueRegs();
243 
244     auto branchToSlowPath = jit.patchableBranch32(
245         MacroAssembler::NotEqual,
246         MacroAssembler::Address(base, JSCell::structureIDOffset()),
247         MacroAssembler::TrustedImm32(bitwise_cast&lt;uint32_t&gt;(structure-&gt;id())));
248 
249     GPRReg storage;
250     if (isInlineOffset(offset))
251         storage = base;
252     else {
253         storage = getScratchRegister(stubInfo);
254         ASSERT(storage != InvalidGPRReg);
255         jit.loadPtr(CCallHelpers::Address(base, JSObject::butterflyOffset()), storage);
256     }
257 
258     jit.storeValue(
259         value, MacroAssembler::Address(storage, offsetRelativeToBase(offset)));
260 
261     bool linkedCodeInline = linkCodeInline(&quot;property replace&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<a name="12" id="anc12"></a><span class="line-modified">262         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation());</span>
263     });
264     return linkedCodeInline;
265 }
266 
267 bool InlineAccess::isCacheableArrayLength(StructureStubInfo&amp; stubInfo, JSArray* array)
268 {
269     ASSERT(array-&gt;indexingType() &amp; IsArray);
270 
<a name="13" id="anc13"></a>


271     if (!hasFreeRegister(stubInfo))
272         return false;
273 
274     return !hasAnyArrayStorage(array-&gt;indexingType()) &amp;&amp; array-&gt;indexingType() != ArrayClass;
275 }
276 
277 bool InlineAccess::generateArrayLength(StructureStubInfo&amp; stubInfo, JSArray* array)
278 {
279     ASSERT(isCacheableArrayLength(stubInfo, array));
280 
<a name="14" id="anc14"></a>


281     CCallHelpers jit;
282 
<a name="15" id="anc15"></a><span class="line-modified">283     GPRReg base = stubInfo.baseGPR();</span>
284     JSValueRegs value = stubInfo.valueRegs();
285     GPRReg scratch = getScratchRegister(stubInfo);
286 
287     jit.load8(CCallHelpers::Address(base, JSCell::indexingTypeAndMiscOffset()), scratch);
288     jit.and32(CCallHelpers::TrustedImm32(IndexingTypeMask), scratch);
289     auto branchToSlowPath = jit.patchableBranch32(
290         CCallHelpers::NotEqual, scratch, CCallHelpers::TrustedImm32(array-&gt;indexingType()));
291     jit.loadPtr(CCallHelpers::Address(base, JSObject::butterflyOffset()), value.payloadGPR());
292     jit.load32(CCallHelpers::Address(value.payloadGPR(), ArrayStorage::lengthOffset()), value.payloadGPR());
293     jit.boxInt32(value.payloadGPR(), value);
294 
295     bool linkedCodeInline = linkCodeInline(&quot;array length&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<a name="16" id="anc16"></a><span class="line-modified">296         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation());</span>
297     });
298     return linkedCodeInline;
299 }
300 
301 bool InlineAccess::isCacheableStringLength(StructureStubInfo&amp; stubInfo)
302 {
<a name="17" id="anc17"></a>


303     return hasFreeRegister(stubInfo);
304 }
305 
306 bool InlineAccess::generateStringLength(StructureStubInfo&amp; stubInfo)
307 {
308     ASSERT(isCacheableStringLength(stubInfo));
309 
<a name="18" id="anc18"></a>


310     CCallHelpers jit;
311 
<a name="19" id="anc19"></a><span class="line-modified">312     GPRReg base = stubInfo.baseGPR();</span>
313     JSValueRegs value = stubInfo.valueRegs();
314     GPRReg scratch = getScratchRegister(stubInfo);
315 
316     auto branchToSlowPath = jit.patchableBranch8(
317         CCallHelpers::NotEqual,
318         CCallHelpers::Address(base, JSCell::typeInfoTypeOffset()),
319         CCallHelpers::TrustedImm32(StringType));
320 
321     jit.loadPtr(CCallHelpers::Address(base, JSString::offsetOfValue()), scratch);
322     auto isRope = jit.branchIfRopeStringImpl(scratch);
323     jit.load32(CCallHelpers::Address(scratch, StringImpl::lengthMemoryOffset()), value.payloadGPR());
324     auto done = jit.jump();
325 
326     isRope.link(&amp;jit);
327     jit.load32(CCallHelpers::Address(base, JSRopeString::offsetOfLength()), value.payloadGPR());
328 
329     done.link(&amp;jit);
330     jit.boxInt32(value.payloadGPR(), value);
331 
332     bool linkedCodeInline = linkCodeInline(&quot;string length&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<a name="20" id="anc20"></a><span class="line-modified">333         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation());</span>
334     });
335     return linkedCodeInline;
336 }
337 
338 
339 bool InlineAccess::generateSelfInAccess(StructureStubInfo&amp; stubInfo, Structure* structure)
340 {
341     CCallHelpers jit;
342 
<a name="21" id="anc21"></a><span class="line-modified">343     GPRReg base = stubInfo.baseGPR();</span>



344     JSValueRegs value = stubInfo.valueRegs();
345 
346     auto branchToSlowPath = jit.patchableBranch32(
347         MacroAssembler::NotEqual,
348         MacroAssembler::Address(base, JSCell::structureIDOffset()),
349         MacroAssembler::TrustedImm32(bitwise_cast&lt;uint32_t&gt;(structure-&gt;id())));
350     jit.boxBoolean(true, value);
351 
352     bool linkedCodeInline = linkCodeInline(&quot;in access&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<a name="22" id="anc22"></a><span class="line-modified">353         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation());</span>
354     });
355     return linkedCodeInline;
356 }
357 
358 void InlineAccess::rewireStubAsJump(StructureStubInfo&amp; stubInfo, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt; target)
359 {
360     CCallHelpers jit;
361 
362     auto jump = jit.jump();
363 
364     // We don&#39;t need a nop sled here because nobody should be jumping into the middle of an IC.
365     bool needsBranchCompaction = false;
<a name="23" id="anc23"></a><span class="line-modified">366     LinkBuffer linkBuffer(jit, stubInfo.patch.start, jit.m_assembler.buffer().codeSize(), JITCompilationMustSucceed, needsBranchCompaction);</span>
367     RELEASE_ASSERT(linkBuffer.isValid());
368     linkBuffer.link(jump, target);
369 
370     FINALIZE_CODE(linkBuffer, NoPtrTag, &quot;InlineAccess: linking constant jump&quot;);
371 }
372 
373 } // namespace JSC
374 
375 #endif // ENABLE(JIT)
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITCall32_64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITCall.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITCode.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITCall32_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 47,17 ***</span>
  
  template&lt;typename Op&gt;
  void JIT::emitPutCallResult(const Op&amp; bytecode)
  {
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
<span class="line-modified">!     emitStore(bytecode.m_dst.offset(), regT1, regT0);</span>
  }
  
  void JIT::emit_op_ret(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpRet&gt;();
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
  
      emitLoad(value, regT1, regT0);
  
      checkStackPointerAlignment();
      emitRestoreCalleeSaves();
<span class="line-new-header">--- 47,17 ---</span>
  
  template&lt;typename Op&gt;
  void JIT::emitPutCallResult(const Op&amp; bytecode)
  {
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
<span class="line-modified">!     emitStore(bytecode.m_dst, regT1, regT0);</span>
  }
  
  void JIT::emit_op_ret(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpRet&gt;();
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
  
      emitLoad(value, regT1, regT0);
  
      checkStackPointerAlignment();
      emitRestoreCalleeSaves();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,58 ***</span>
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
      int argCount = bytecode.m_argc;
      int registerOffset = -static_cast&lt;int&gt;(bytecode.m_argv);
  
      if (Op::opcodeID == op_call &amp;&amp; shouldEmitProfiling()) {
<span class="line-modified">!         emitLoad(registerOffset + CallFrame::argumentOffsetIncludingThis(0), regT0, regT1);</span>
          Jump done = branchIfNotCell(regT0);
          load32(Address(regT1, JSCell::structureIDOffset()), regT1);
          store32(regT1, metadata.m_callLinkInfo.m_arrayProfile.addressOfLastSeenStructureID());
          done.link(this);
      }
  
      addPtr(TrustedImm32(registerOffset * sizeof(Register) + sizeof(CallerFrameAndPC)), callFrameRegister, stackPointerRegister);
<span class="line-modified">!     store32(TrustedImm32(argCount), Address(stackPointerRegister, CallFrameSlot::argumentCount * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset - sizeof(CallerFrameAndPC)));</span>
  }
  
  template&lt;typename Op&gt;
  std::enable_if_t&lt;
      Op::opcodeID == op_call_varargs || Op::opcodeID == op_construct_varargs
      || Op::opcodeID == op_tail_call_varargs || Op::opcodeID == op_tail_call_forward_arguments
  , void&gt;
  JIT::compileSetupFrame(const Op&amp; bytecode, CallLinkInfo* info)
  {
      OpcodeID opcodeID = Op::opcodeID;
<span class="line-modified">!     int thisValue = bytecode.m_thisValue.offset();</span>
<span class="line-modified">!     int arguments = bytecode.m_arguments.offset();</span>
      int firstFreeRegister = bytecode.m_firstFree.offset();
      int firstVarArgOffset = bytecode.m_firstVarArg;
  
      emitLoad(arguments, regT1, regT0);
<span class="line-modified">!     Z_JITOperation_EJZZ sizeOperation;</span>
      if (Op::opcodeID == op_tail_call_forward_arguments)
          sizeOperation = operationSizeFrameForForwardArguments;
      else
          sizeOperation = operationSizeFrameForVarargs;
<span class="line-modified">!     callOperation(sizeOperation, JSValueRegs(regT1, regT0), -firstFreeRegister, firstVarArgOffset);</span>
      move(TrustedImm32(-firstFreeRegister), regT1);
      emitSetVarargsFrame(*this, returnValueGPR, false, regT1, regT1);
      addPtr(TrustedImm32(-(sizeof(CallerFrameAndPC) + WTF::roundUpToMultipleOf(stackAlignmentBytes(), 6 * sizeof(void*)))), regT1, stackPointerRegister);
      emitLoad(arguments, regT2, regT4);
<span class="line-modified">!     F_JITOperation_EFJZZ setupOperation;</span>
      if (opcodeID == op_tail_call_forward_arguments)
          setupOperation = operationSetupForwardArgumentsFrame;
      else
          setupOperation = operationSetupVarargsFrame;
<span class="line-modified">!     callOperation(setupOperation, regT1, JSValueRegs(regT2, regT4), firstVarArgOffset, regT0);</span>
      move(returnValueGPR, regT1);
  
      // Profile the argument count.
<span class="line-modified">!     load32(Address(regT1, CallFrameSlot::argumentCount * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset), regT2);</span>
<span class="line-modified">!     load32(info-&gt;addressOfMaxNumArguments(), regT0);</span>
      Jump notBiggest = branch32(Above, regT0, regT2);
<span class="line-modified">!     store32(regT2, info-&gt;addressOfMaxNumArguments());</span>
      notBiggest.link(this);
  
      // Initialize &#39;this&#39;.
      emitLoad(thisValue, regT2, regT0);
      store32(regT0, Address(regT1, PayloadOffset + (CallFrame::thisArgumentOffset() * static_cast&lt;int&gt;(sizeof(Register)))));
<span class="line-new-header">--- 155,58 ---</span>
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
      int argCount = bytecode.m_argc;
      int registerOffset = -static_cast&lt;int&gt;(bytecode.m_argv);
  
      if (Op::opcodeID == op_call &amp;&amp; shouldEmitProfiling()) {
<span class="line-modified">!         emitLoad(VirtualRegister(registerOffset + CallFrame::argumentOffsetIncludingThis(0)), regT0, regT1);</span>
          Jump done = branchIfNotCell(regT0);
          load32(Address(regT1, JSCell::structureIDOffset()), regT1);
          store32(regT1, metadata.m_callLinkInfo.m_arrayProfile.addressOfLastSeenStructureID());
          done.link(this);
      }
  
      addPtr(TrustedImm32(registerOffset * sizeof(Register) + sizeof(CallerFrameAndPC)), callFrameRegister, stackPointerRegister);
<span class="line-modified">!     store32(TrustedImm32(argCount), Address(stackPointerRegister, CallFrameSlot::argumentCountIncludingThis * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset - sizeof(CallerFrameAndPC)));</span>
  }
  
  template&lt;typename Op&gt;
  std::enable_if_t&lt;
      Op::opcodeID == op_call_varargs || Op::opcodeID == op_construct_varargs
      || Op::opcodeID == op_tail_call_varargs || Op::opcodeID == op_tail_call_forward_arguments
  , void&gt;
  JIT::compileSetupFrame(const Op&amp; bytecode, CallLinkInfo* info)
  {
      OpcodeID opcodeID = Op::opcodeID;
<span class="line-modified">!     VirtualRegister thisValue = bytecode.m_thisValue;</span>
<span class="line-modified">!     VirtualRegister arguments = bytecode.m_arguments;</span>
      int firstFreeRegister = bytecode.m_firstFree.offset();
      int firstVarArgOffset = bytecode.m_firstVarArg;
  
      emitLoad(arguments, regT1, regT0);
<span class="line-modified">!     Z_JITOperation_GJZZ sizeOperation;</span>
      if (Op::opcodeID == op_tail_call_forward_arguments)
          sizeOperation = operationSizeFrameForForwardArguments;
      else
          sizeOperation = operationSizeFrameForVarargs;
<span class="line-modified">!     callOperation(sizeOperation, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0), -firstFreeRegister, firstVarArgOffset);</span>
      move(TrustedImm32(-firstFreeRegister), regT1);
      emitSetVarargsFrame(*this, returnValueGPR, false, regT1, regT1);
      addPtr(TrustedImm32(-(sizeof(CallerFrameAndPC) + WTF::roundUpToMultipleOf(stackAlignmentBytes(), 6 * sizeof(void*)))), regT1, stackPointerRegister);
      emitLoad(arguments, regT2, regT4);
<span class="line-modified">!     F_JITOperation_GFJZZ setupOperation;</span>
      if (opcodeID == op_tail_call_forward_arguments)
          setupOperation = operationSetupForwardArgumentsFrame;
      else
          setupOperation = operationSetupVarargsFrame;
<span class="line-modified">!     callOperation(setupOperation, m_codeBlock-&gt;globalObject(), regT1, JSValueRegs(regT2, regT4), firstVarArgOffset, regT0);</span>
      move(returnValueGPR, regT1);
  
      // Profile the argument count.
<span class="line-modified">!     load32(Address(regT1, CallFrameSlot::argumentCountIncludingThis * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset), regT2);</span>
<span class="line-modified">!     load32(info-&gt;addressOfMaxArgumentCountIncludingThis(), regT0);</span>
      Jump notBiggest = branch32(Above, regT0, regT2);
<span class="line-modified">!     store32(regT2, info-&gt;addressOfMaxArgumentCountIncludingThis());</span>
      notBiggest.link(this);
  
      // Initialize &#39;this&#39;.
      emitLoad(thisValue, regT2, regT0);
      store32(regT0, Address(regT1, PayloadOffset + (CallFrame::thisArgumentOffset() * static_cast&lt;int&gt;(sizeof(Register)))));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 227,11 ***</span>
      addPtr(TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), stackPointerRegister, regT1);
      storePtr(callFrameRegister, Address(regT1, CallFrame::callerFrameOffset()));
  
      addPtr(TrustedImm32(stackPointerOffsetFor(m_codeBlock) * sizeof(Register)), callFrameRegister, stackPointerRegister);
  
<span class="line-modified">!     callOperation(operationCallEval, regT1);</span>
  
      addSlowCase(branchIfEmpty(regT1));
  
      sampleCodeBlock(m_codeBlock);
  
<span class="line-new-header">--- 227,11 ---</span>
      addPtr(TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), stackPointerRegister, regT1);
      storePtr(callFrameRegister, Address(regT1, CallFrame::callerFrameOffset()));
  
      addPtr(TrustedImm32(stackPointerOffsetFor(m_codeBlock) * sizeof(Register)), callFrameRegister, stackPointerRegister);
  
<span class="line-modified">!     callOperation(operationCallEval, m_codeBlock-&gt;globalObject(), regT1);</span>
  
      addSlowCase(branchIfEmpty(regT1));
  
      sampleCodeBlock(m_codeBlock);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,19 ***</span>
  {
      linkAllSlowCases(iter);
  
      auto bytecode = instruction-&gt;as&lt;OpCallEval&gt;();
      CallLinkInfo* info = m_codeBlock-&gt;addCallLinkInfo();
<span class="line-modified">!     info-&gt;setUpCall(CallLinkInfo::Call, CodeOrigin(m_bytecodeOffset), regT0);</span>
  
      int registerOffset = -bytecode.m_argv;
<span class="line-modified">!     int callee = bytecode.m_callee.offset();</span>
  
      addPtr(TrustedImm32(registerOffset * sizeof(Register) + sizeof(CallerFrameAndPC)), callFrameRegister, stackPointerRegister);
  
      emitLoad(callee, regT1, regT0);
<span class="line-modified">!     emitDumbVirtualCall(vm(), info);</span>
      addPtr(TrustedImm32(stackPointerOffsetFor(m_codeBlock) * sizeof(Register)), callFrameRegister, stackPointerRegister);
      checkStackPointerAlignment();
  
      sampleCodeBlock(m_codeBlock);
  
<span class="line-new-header">--- 244,19 ---</span>
  {
      linkAllSlowCases(iter);
  
      auto bytecode = instruction-&gt;as&lt;OpCallEval&gt;();
      CallLinkInfo* info = m_codeBlock-&gt;addCallLinkInfo();
<span class="line-modified">!     info-&gt;setUpCall(CallLinkInfo::Call, CodeOrigin(m_bytecodeIndex), regT0);</span>
  
      int registerOffset = -bytecode.m_argv;
<span class="line-modified">!     VirtualRegister callee = bytecode.m_callee;</span>
  
      addPtr(TrustedImm32(registerOffset * sizeof(Register) + sizeof(CallerFrameAndPC)), callFrameRegister, stackPointerRegister);
  
      emitLoad(callee, regT1, regT0);
<span class="line-modified">!     emitDumbVirtualCall(vm(), m_codeBlock-&gt;globalObject(), info);</span>
      addPtr(TrustedImm32(stackPointerOffsetFor(m_codeBlock) * sizeof(Register)), callFrameRegister, stackPointerRegister);
      checkStackPointerAlignment();
  
      sampleCodeBlock(m_codeBlock);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 266,11 ***</span>
  template &lt;typename Op&gt;
  void JIT::compileOpCall(const Instruction* instruction, unsigned callLinkInfoIndex)
  {
      OpcodeID opcodeID = Op::opcodeID;
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     int callee = bytecode.m_callee.offset();</span>
  
      /* Caller always:
          - Updates callFrameRegister to callee callFrame.
          - Initializes ArgumentCount; CallerFrame; Callee.
  
<span class="line-new-header">--- 266,11 ---</span>
  template &lt;typename Op&gt;
  void JIT::compileOpCall(const Instruction* instruction, unsigned callLinkInfoIndex)
  {
      OpcodeID opcodeID = Op::opcodeID;
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     VirtualRegister callee = bytecode.m_callee;</span>
  
      /* Caller always:
          - Updates callFrameRegister to callee callFrame.
          - Initializes ArgumentCount; CallerFrame; Callee.
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 286,12 ***</span>
      if (opcodeID != op_call_eval)
          info = m_codeBlock-&gt;addCallLinkInfo();
      compileSetupFrame(bytecode, info);
      // SP holds newCallFrame + sizeof(CallerFrameAndPC), with ArgumentCount initialized.
  
<span class="line-modified">!     uint32_t locationBits = CallSiteIndex(instruction).bits();</span>
<span class="line-modified">!     store32(TrustedImm32(locationBits), tagFor(CallFrameSlot::argumentCount));</span>
      emitLoad(callee, regT1, regT0); // regT1, regT0 holds callee.
  
      store32(regT0, Address(stackPointerRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset - sizeof(CallerFrameAndPC)));
      store32(regT1, Address(stackPointerRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register)) + TagOffset - sizeof(CallerFrameAndPC)));
  
<span class="line-new-header">--- 286,13 ---</span>
      if (opcodeID != op_call_eval)
          info = m_codeBlock-&gt;addCallLinkInfo();
      compileSetupFrame(bytecode, info);
      // SP holds newCallFrame + sizeof(CallerFrameAndPC), with ArgumentCount initialized.
  
<span class="line-modified">!     auto bytecodeIndex = m_codeBlock-&gt;bytecodeIndex(instruction);</span>
<span class="line-modified">!     uint32_t locationBits = CallSiteIndex(bytecodeIndex).bits();</span>
<span class="line-added">+     store32(TrustedImm32(locationBits), tagFor(CallFrameSlot::argumentCountIncludingThis));</span>
      emitLoad(callee, regT1, regT0); // regT1, regT0 holds callee.
  
      store32(regT0, Address(stackPointerRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset - sizeof(CallerFrameAndPC)));
      store32(regT1, Address(stackPointerRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register)) + TagOffset - sizeof(CallerFrameAndPC)));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 307,11 ***</span>
      Jump slowCase = branchPtrWithPatch(NotEqual, regT0, addressOfLinkedFunctionCheck, TrustedImmPtr(nullptr));
  
      addSlowCase(slowCase);
  
      ASSERT(m_callCompilationInfo.size() == callLinkInfoIndex);
<span class="line-modified">!     info-&gt;setUpCall(CallLinkInfo::callTypeFor(opcodeID), CodeOrigin(m_bytecodeOffset), regT0);</span>
      m_callCompilationInfo.append(CallCompilationInfo());
      m_callCompilationInfo[callLinkInfoIndex].hotPathBegin = addressOfLinkedFunctionCheck;
      m_callCompilationInfo[callLinkInfoIndex].callLinkInfo = info;
  
      checkStackPointerAlignment();
<span class="line-new-header">--- 308,11 ---</span>
      Jump slowCase = branchPtrWithPatch(NotEqual, regT0, addressOfLinkedFunctionCheck, TrustedImmPtr(nullptr));
  
      addSlowCase(slowCase);
  
      ASSERT(m_callCompilationInfo.size() == callLinkInfoIndex);
<span class="line-modified">!     info-&gt;setUpCall(CallLinkInfo::callTypeFor(opcodeID), CodeOrigin(m_bytecodeIndex), regT0);</span>
      m_callCompilationInfo.append(CallCompilationInfo());
      m_callCompilationInfo[callLinkInfoIndex].hotPathBegin = addressOfLinkedFunctionCheck;
      m_callCompilationInfo[callLinkInfoIndex].callLinkInfo = info;
  
      checkStackPointerAlignment();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 340,10 ***</span>
<span class="line-new-header">--- 341,11 ---</span>
          return;
      }
  
      linkAllSlowCases(iter);
  
<span class="line-added">+     move(TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT3);</span>
      move(TrustedImmPtr(m_callCompilationInfo[callLinkInfoIndex].callLinkInfo), regT2);
  
      if (opcodeID == op_tail_call || opcodeID == op_tail_call_varargs || opcodeID == op_tail_call_forward_arguments)
          emitRestoreCalleeSaves();
  
</pre>
<center><a href="JITCall.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITCode.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
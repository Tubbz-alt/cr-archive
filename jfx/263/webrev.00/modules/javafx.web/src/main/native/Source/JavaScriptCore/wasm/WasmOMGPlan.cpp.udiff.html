<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmOMGPlan.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmOMGForOSREntryPlan.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmOpcodeOrigin.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmOMGPlan.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (C) 2017-2018 Apple Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -38,22 +38,21 @@</span>
  #include &quot;WasmInstance.h&quot;
  #include &quot;WasmMachineThreads.h&quot;
  #include &quot;WasmMemory.h&quot;
  #include &quot;WasmNameSection.h&quot;
  #include &quot;WasmSignatureInlines.h&quot;
<span class="udiff-line-removed">- #include &quot;WasmValidate.h&quot;</span>
  #include &quot;WasmWorklist.h&quot;
  #include &lt;wtf/DataLog.h&gt;
  #include &lt;wtf/Locker.h&gt;
  #include &lt;wtf/MonotonicTime.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/ThreadMessage.h&gt;
  
  namespace JSC { namespace Wasm {
  
  namespace WasmOMGPlanInternal {
<span class="udiff-line-modified-removed">- static const bool verbose = false;</span>
<span class="udiff-line-modified-added">+ static constexpr bool verbose = false;</span>
  }
  
  OMGPlan::OMGPlan(Context* context, Ref&lt;Module&gt;&amp;&amp; module, uint32_t functionIndex, MemoryMode mode, CompletionTask&amp;&amp; task)
      : Base(context, makeRef(const_cast&lt;ModuleInformation&amp;&gt;(module-&gt;moduleInformation())), WTFMove(task))
      , m_module(WTFMove(module))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -75,16 +74,15 @@</span>
      const uint32_t functionIndexSpace = m_functionIndex + m_module-&gt;moduleInformation().importFunctionCount();
      ASSERT(functionIndexSpace &lt; m_module-&gt;moduleInformation().functionIndexSpaceSize());
  
      SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[m_functionIndex];
      const Signature&amp; signature = SignatureInformation::get(signatureIndex);
<span class="udiff-line-removed">-     ASSERT(validateFunction(function.data.data(), function.data.size(), signature, m_moduleInformation.get()));</span>
  
      Vector&lt;UnlinkedWasmToWasmCall&gt; unlinkedCalls;
      unsigned osrEntryScratchBufferSize;
      CompilationContext context;
<span class="udiff-line-modified-removed">-     auto parseAndCompileResult = parseAndCompile(context, function.data.data(), function.data.size(), signature, unlinkedCalls, osrEntryScratchBufferSize, m_moduleInformation.get(), m_mode, CompilationMode::OMGMode, m_functionIndex, UINT32_MAX);</span>
<span class="udiff-line-modified-added">+     auto parseAndCompileResult = parseAndCompile(context, function, signature, unlinkedCalls, osrEntryScratchBufferSize, m_moduleInformation.get(), m_mode, CompilationMode::OMGMode, m_functionIndex, UINT32_MAX);</span>
  
      if (UNLIKELY(!parseAndCompileResult)) {
          fail(holdLock(m_lock), makeString(parseAndCompileResult.error(), &quot;when trying to tier up &quot;, String::number(m_functionIndex)));
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -95,34 +93,41 @@</span>
          Base::fail(holdLock(m_lock), makeString(&quot;Out of executable memory while tiering up function at index &quot;, String::number(m_functionIndex)));
          return;
      }
  
      omgEntrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(
<span class="udiff-line-modified-removed">-         FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;WebAssembly OMG function[%i] %s name %s&quot;, m_functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
<span class="udiff-line-modified-added">+         FINALIZE_WASM_CODE_FOR_MODE(CompilationMode::OMGMode, linkBuffer, B3CompilationPtrTag, &quot;WebAssembly OMG function[%i] %s name %s&quot;, m_functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
          WTFMove(context.wasmEntrypointByproducts));
  
      omgEntrypoint.calleeSaveRegisters = WTFMove(parseAndCompileResult.value()-&gt;entrypoint.calleeSaveRegisters);
  
      MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; entrypoint;
      {
          ASSERT(m_codeBlock.ptr() == m_module-&gt;codeBlockFor(mode()));
          Ref&lt;OMGCallee&gt; callee = OMGCallee::create(WTFMove(omgEntrypoint), functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace), WTFMove(unlinkedCalls));
          MacroAssembler::repatchPointer(parseAndCompileResult.value()-&gt;calleeMoveLocation, CalleeBits::boxWasm(callee.ptr()));
<span class="udiff-line-modified-removed">-         ASSERT(!m_codeBlock-&gt;m_optimizedCallees[m_functionIndex]);</span>
<span class="udiff-line-modified-added">+         ASSERT(!m_codeBlock-&gt;m_omgCallees[m_functionIndex]);</span>
          entrypoint = callee-&gt;entrypoint();
  
          // We want to make sure we publish our callee at the same time as we link our callsites. This enables us to ensure we
          // always call the fastest code. Any function linked after us will see our new code and the new callsites, which they
          // will update. It&#39;s also ok if they publish their code before we reset the instruction caches because after we release
          // the lock our code is ready to be published too.
          LockHolder holder(m_codeBlock-&gt;m_lock);
<span class="udiff-line-modified-removed">-         m_codeBlock-&gt;m_optimizedCallees[m_functionIndex] = callee.copyRef();</span>
<span class="udiff-line-modified-added">+         m_codeBlock-&gt;m_omgCallees[m_functionIndex] = callee.copyRef();</span>
          {
<span class="udiff-line-modified-removed">-             BBQCallee&amp; bbqCallee = *static_cast&lt;BBQCallee*&gt;(m_codeBlock-&gt;m_callees[m_functionIndex].get());</span>
<span class="udiff-line-modified-removed">-             auto locker = holdLock(bbqCallee.tierUpCount()-&gt;getLock());</span>
<span class="udiff-line-modified-removed">-             bbqCallee.setReplacement(callee.copyRef());</span>
<span class="udiff-line-modified-removed">-             bbqCallee.tierUpCount()-&gt;m_compilationStatusForOMG = TierUpCount::CompilationStatus::Compiled;</span>
<span class="udiff-line-modified-added">+             if (BBQCallee* bbqCallee = m_codeBlock-&gt;m_bbqCallees[m_functionIndex].get()) {</span>
<span class="udiff-line-modified-added">+                 auto locker = holdLock(bbqCallee-&gt;tierUpCount()-&gt;getLock());</span>
<span class="udiff-line-modified-added">+                 bbqCallee-&gt;setReplacement(callee.copyRef());</span>
<span class="udiff-line-modified-added">+                 bbqCallee-&gt;tierUpCount()-&gt;m_compilationStatusForOMG = TierUpCount::CompilationStatus::Compiled;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (m_codeBlock-&gt;m_llintCallees) {</span>
<span class="udiff-line-added">+                 LLIntCallee&amp; llintCallee = m_codeBlock-&gt;m_llintCallees-&gt;at(m_functionIndex).get();</span>
<span class="udiff-line-added">+                 auto locker = holdLock(llintCallee.tierUpCounter().m_lock);</span>
<span class="udiff-line-added">+                 llintCallee.setReplacement(callee.copyRef());</span>
<span class="udiff-line-added">+                 llintCallee.tierUpCounter().m_compilationStatus = LLIntTierUpCounter::CompilationStatus::Compiled;</span>
<span class="udiff-line-added">+             }</span>
          }
          for (auto&amp; call : callee-&gt;wasmToWasmCallsites()) {
              MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; entrypoint;
              if (call.functionIndexSpace &lt; m_module-&gt;moduleInformation().importFunctionCount())
                  entrypoint = m_codeBlock-&gt;m_wasmToWasmExitStubs[call.functionIndexSpace].code();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -153,18 +158,27 @@</span>
              }
          };
  
          for (unsigned i = 0; i &lt; m_codeBlock-&gt;m_wasmToWasmCallsites.size(); ++i) {
              repatchCalls(m_codeBlock-&gt;m_wasmToWasmCallsites[i]);
<span class="udiff-line-modified-removed">-             if (OMGCallee* replacementCallee = static_cast&lt;BBQCallee*&gt;(m_codeBlock-&gt;m_callees[i].get())-&gt;replacement())</span>
<span class="udiff-line-modified-removed">-                 repatchCalls(replacementCallee-&gt;wasmToWasmCallsites());</span>
<span class="udiff-line-modified-removed">-             if (OMGForOSREntryCallee* osrEntryCallee = static_cast&lt;BBQCallee*&gt;(m_codeBlock-&gt;m_callees[i].get())-&gt;osrEntryCallee())</span>
<span class="udiff-line-modified-removed">-                 repatchCalls(osrEntryCallee-&gt;wasmToWasmCallsites());</span>
<span class="udiff-line-modified-added">+             if (m_codeBlock-&gt;m_llintCallees) {</span>
<span class="udiff-line-modified-added">+                 LLIntCallee&amp; llintCallee = m_codeBlock-&gt;m_llintCallees-&gt;at(i).get();</span>
<span class="udiff-line-modified-added">+                 if (JITCallee* replacementCallee = llintCallee.replacement())</span>
<span class="udiff-line-modified-added">+                     repatchCalls(replacementCallee-&gt;wasmToWasmCallsites());</span>
<span class="udiff-line-added">+                 if (OMGForOSREntryCallee* osrEntryCallee = llintCallee.osrEntryCallee())</span>
<span class="udiff-line-added">+                     repatchCalls(osrEntryCallee-&gt;wasmToWasmCallsites());</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (BBQCallee* bbqCallee = m_codeBlock-&gt;m_bbqCallees[i].get()) {</span>
<span class="udiff-line-added">+                 if (OMGCallee* replacementCallee = bbqCallee-&gt;replacement())</span>
<span class="udiff-line-added">+                     repatchCalls(replacementCallee-&gt;wasmToWasmCallsites());</span>
<span class="udiff-line-added">+                 if (OMGForOSREntryCallee* osrEntryCallee = bbqCallee-&gt;osrEntryCallee())</span>
<span class="udiff-line-added">+                     repatchCalls(osrEntryCallee-&gt;wasmToWasmCallsites());</span>
<span class="udiff-line-added">+             }</span>
          }
      }
  
<span class="udiff-line-modified-removed">-     dataLogLnIf(WasmOMGPlanInternal::verbose, &quot;Finished OMG &quot;, m_functionIndex, &quot; with tier up count at: &quot;, static_cast&lt;BBQCallee*&gt;(m_codeBlock-&gt;m_callees[m_functionIndex].get())-&gt;tierUpCount()-&gt;count());</span>
<span class="udiff-line-modified-added">+     dataLogLnIf(WasmOMGPlanInternal::verbose, &quot;Finished OMG &quot;, m_functionIndex);</span>
      complete(holdLock(m_lock));
  }
  
  } } // namespace JSC::Wasm
  
</pre>
<center><a href="WasmOMGForOSREntryPlan.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmOpcodeOrigin.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
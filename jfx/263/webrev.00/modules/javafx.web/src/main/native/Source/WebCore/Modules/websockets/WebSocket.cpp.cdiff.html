<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/websockets/WebSocket.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ThreadableWebSocketChannel.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebSocket.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/websockets/WebSocket.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 101,11 ***</span>
  {
      StringBuilder builder;
      for (size_t i = 0; i &lt; protocol.length(); i++) {
          if (protocol[i] &lt; 0x20 || protocol[i] &gt; 0x7E) {
              builder.appendLiteral(&quot;\\u&quot;);
<span class="line-modified">!             appendUnsignedAsHexFixedSize(protocol[i], builder, 4);</span>
          } else if (protocol[i] == 0x5c)
              builder.appendLiteral(&quot;\\\\&quot;);
          else
              builder.append(protocol[i]);
      }
<span class="line-new-header">--- 101,11 ---</span>
  {
      StringBuilder builder;
      for (size_t i = 0; i &lt; protocol.length(); i++) {
          if (protocol[i] &lt; 0x20 || protocol[i] &gt; 0x7E) {
              builder.appendLiteral(&quot;\\u&quot;);
<span class="line-modified">!             builder.append(hex(protocol[i], 4));</span>
          } else if (protocol[i] == 0x5c)
              builder.appendLiteral(&quot;\\\\&quot;);
          else
              builder.append(protocol[i]);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 296,17 ***</span>
              m_state = CLOSED;
              return Exception { SyntaxError };
          }
      }
  
<span class="line-modified">!     RunLoop::main().dispatch([targetURL = m_url.isolatedCopy(), mainFrameURL = context.url().isolatedCopy(), sessionID = context.sessionID()]() {</span>
<span class="line-modified">!         ResourceLoadObserver::shared().logWebSocketLoading(targetURL, mainFrameURL, sessionID);</span>
      });
  
      if (is&lt;Document&gt;(context)) {
          Document&amp; document = downcast&lt;Document&gt;(context);
          RefPtr&lt;Frame&gt; frame = document.frame();
          if (!frame || !frame-&gt;loader().mixedContentChecker().canRunInsecureContent(document.securityOrigin(), m_url)) {
              failAsynchronously();
              return { };
          }
      }
<span class="line-new-header">--- 296,18 ---</span>
              m_state = CLOSED;
              return Exception { SyntaxError };
          }
      }
  
<span class="line-modified">!     RunLoop::main().dispatch([targetURL = m_url.isolatedCopy(), mainFrameURL = context.url().isolatedCopy()]() {</span>
<span class="line-modified">!         ResourceLoadObserver::shared().logWebSocketLoading(targetURL, mainFrameURL);</span>
      });
  
      if (is&lt;Document&gt;(context)) {
          Document&amp; document = downcast&lt;Document&gt;(context);
          RefPtr&lt;Frame&gt; frame = document.frame();
<span class="line-added">+         // FIXME: make the mixed content check equivalent to the non-document mixed content check currently in WorkerThreadableWebSocketChannel::Bridge::connect()</span>
          if (!frame || !frame-&gt;loader().mixedContentChecker().canRunInsecureContent(document.securityOrigin(), m_url)) {
              failAsynchronously();
              return { };
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 492,24 ***</span>
      ASSERT(!m_channel);
      ASSERT(m_state == CLOSED);
      ActiveDOMObject::contextDestroyed();
  }
  
<span class="line-removed">- bool WebSocket::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void WebSocket::suspend(ReasonForSuspension reason)
  {
      if (m_resumeTimer.isActive())
          m_resumeTimer.stop();
  
      m_shouldDelayEventFiring = true;
  
      if (m_channel) {
<span class="line-modified">!         if (reason == ReasonForSuspension::PageCache) {</span>
              // This will cause didClose() to be called.
              m_channel-&gt;fail(&quot;WebSocket is closed due to suspension.&quot;);
          } else
              m_channel-&gt;suspend();
      }
<span class="line-new-header">--- 493,19 ---</span>
      ASSERT(!m_channel);
      ASSERT(m_state == CLOSED);
      ActiveDOMObject::contextDestroyed();
  }
  
  void WebSocket::suspend(ReasonForSuspension reason)
  {
      if (m_resumeTimer.isActive())
          m_resumeTimer.stop();
  
      m_shouldDelayEventFiring = true;
  
      if (m_channel) {
<span class="line-modified">!         if (reason == ReasonForSuspension::BackForwardCache) {</span>
              // This will cause didClose() to be called.
              m_channel-&gt;fail(&quot;WebSocket is closed due to suspension.&quot;);
          } else
              m_channel-&gt;suspend();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 582,11 ***</span>
  {
      LOG(Network, &quot;WebSocket %p didReceiveBinaryData() %u byte binary message&quot;, this, static_cast&lt;unsigned&gt;(binaryData.size()));
      switch (m_binaryType) {
      case BinaryType::Blob:
          // FIXME: We just received the data from NetworkProcess, and are sending it back. This is inefficient.
<span class="line-modified">!         dispatchEvent(MessageEvent::create(Blob::create(scriptExecutionContext()-&gt;sessionID(), WTFMove(binaryData), emptyString()), SecurityOrigin::create(m_url)-&gt;toString()));</span>
          break;
      case BinaryType::ArrayBuffer:
          dispatchEvent(MessageEvent::create(ArrayBuffer::create(binaryData.data(), binaryData.size()), SecurityOrigin::create(m_url)-&gt;toString()));
          break;
      }
<span class="line-new-header">--- 578,11 ---</span>
  {
      LOG(Network, &quot;WebSocket %p didReceiveBinaryData() %u byte binary message&quot;, this, static_cast&lt;unsigned&gt;(binaryData.size()));
      switch (m_binaryType) {
      case BinaryType::Blob:
          // FIXME: We just received the data from NetworkProcess, and are sending it back. This is inefficient.
<span class="line-modified">!         dispatchEvent(MessageEvent::create(Blob::create(WTFMove(binaryData), emptyString()), SecurityOrigin::create(m_url)-&gt;toString()));</span>
          break;
      case BinaryType::ArrayBuffer:
          dispatchEvent(MessageEvent::create(ArrayBuffer::create(binaryData.data(), binaryData.size()), SecurityOrigin::create(m_url)-&gt;toString()));
          break;
      }
</pre>
<center><a href="ThreadableWebSocketChannel.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebSocket.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
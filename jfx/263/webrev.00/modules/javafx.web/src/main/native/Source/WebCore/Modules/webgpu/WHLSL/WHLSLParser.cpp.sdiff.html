<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLLiteralTypeChecker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLPrepare.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 386 
 387     switch (type-&gt;type) {
 388     case Token::Type::IntLiteral: {
 389         auto value = intLiteralToInt(type-&gt;stringView(m_lexer));
 390         if (!value)
 391             return makeUnexpected(value.error());
 392         return {{ AST::IntegerLiteral({ *type }, *value) }};
 393     }
 394     case Token::Type::UintLiteral: {
 395         auto value = uintLiteralToUint(type-&gt;stringView(m_lexer));
 396         if (!value)
 397             return makeUnexpected(value.error());
 398         return {{ AST::UnsignedIntegerLiteral({ *type }, *value) }};
 399     }
 400     case Token::Type::FloatLiteral: {
 401         auto value = floatLiteralToFloat(type-&gt;stringView(m_lexer));
 402         if (!value)
 403             return makeUnexpected(value.error());
 404         return {{ AST::FloatLiteral({ *type }, *value) }};
 405     }
<span class="line-removed"> 406     case Token::Type::Null:</span>
<span class="line-removed"> 407         return { AST::NullLiteral(WTFMove(*type)) };</span>
 408     case Token::Type::True:
 409         return { AST::BooleanLiteral(WTFMove(*type), true) };
 410     case Token::Type::False:
 411         return { AST::BooleanLiteral(WTFMove(*type), false) };
 412     default: {
 413         ASSERT(type-&gt;type == Token::Type::Identifier);
 414         CONSUME_TYPE(fullStop, FullStop);
 415         CONSUME_TYPE(next, Identifier);
 416         return { AST::EnumerationMemberLiteral({ *type, *next }, type-&gt;stringView(m_lexer).toString(), next-&gt;stringView(m_lexer).toString()) };
 417     }
 418     }
 419 }
 420 
 421 auto Parser::parseTypeArgument() -&gt; Expected&lt;AST::TypeArgument, Error&gt;
 422 {
 423     PEEK(nextToken);
 424     PEEK_FURTHER(furtherToken);
 425     if (nextToken-&gt;type != Token::Type::Identifier || furtherToken-&gt;type == Token::Type::FullStop) {
 426         PARSE(constantExpression, ConstantExpression);
 427         return AST::TypeArgument(WTFMove(*constantExpression));
</pre>
<hr />
<pre>
 681     if (infoStringView.length() &lt; 2 || (infoStringView[0] != &#39;u&#39;
 682         &amp;&amp; infoStringView[0] != &#39;t&#39;
 683         &amp;&amp; infoStringView[0] != &#39;b&#39;
 684         &amp;&amp; infoStringView[0] != &#39;s&#39;))
 685         return makeUnexpected(Error(makeString(infoStringView.substring(0, 1), &quot; is not a known resource type (&#39;u&#39;, &#39;t&#39;, &#39;b&#39;, or &#39;s&#39;)&quot;)));
 686 
 687     AST::ResourceSemantic::Mode mode;
 688     switch (infoStringView[0]) {
 689     case &#39;u&#39;:
 690         mode = AST::ResourceSemantic::Mode::UnorderedAccessView;
 691         break;
 692     case &#39;t&#39;:
 693         mode = AST::ResourceSemantic::Mode::Texture;
 694         break;
 695     case &#39;b&#39;:
 696         mode = AST::ResourceSemantic::Mode::Buffer;
 697         break;
 698     case &#39;s&#39;:
 699         mode = AST::ResourceSemantic::Mode::Sampler;
 700         break;


 701     }
 702 
 703     auto index = recognizeSimpleUnsignedInteger(infoStringView.substring(1));
 704     if (!index)
 705         return makeUnexpected(index.error());
 706 
 707     unsigned space = 0;
 708     if (tryType(Token::Type::Comma)) {
 709         CONSUME_TYPE(spaceToken, Identifier);
 710         auto spaceTokenStringView = spaceToken-&gt;stringView(m_lexer);
 711         StringView prefix { &quot;space&quot; };
 712         if (!spaceTokenStringView.startsWith(prefix))
 713             return makeUnexpected(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceTokenStringView, &quot; needs be of the form &#39;space0&#39;&quot;)));
 714         if (spaceTokenStringView.length() &lt;= prefix.length())
 715             return makeUnexpected(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceTokenStringView, &quot; needs be of the form &#39;space0&#39;&quot;)));
 716         auto spaceValue = recognizeSimpleUnsignedInteger(spaceTokenStringView.substring(prefix.length()));
 717         if (!spaceValue)
 718             return makeUnexpected(spaceValue.error());
 719         space = *spaceValue;
 720     }
</pre>
<hr />
<pre>
 858     CONSUME_TYPE(rightCurlyBracket, RightCurlyBracket);
 859     result.updateCodeLocation({ *origin, *rightCurlyBracket});
 860 
 861     return WTFMove(result);
 862 }
 863 
 864 auto Parser::parseEnumerationMember(int64_t defaultValue) -&gt; Expected&lt;AST::EnumerationMember, Error&gt;
 865 {
 866     CONSUME_TYPE(identifier, Identifier);
 867     auto name = identifier-&gt;stringView(m_lexer).toString();
 868 
 869     if (tryType(Token::Type::EqualsSign)) {
 870         PARSE(constantExpression, ConstantExpression);
 871 
 872         Optional&lt;int64_t&gt; value;
 873         constantExpression-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {
 874             value = integerLiteral.value();
 875         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {
 876             value = unsignedIntegerLiteral.value();
 877         }, [&amp;](AST::FloatLiteral&amp;) {
<span class="line-removed"> 878         }, [&amp;](AST::NullLiteral&amp;) {</span>
 879         }, [&amp;](AST::BooleanLiteral&amp;) {
 880         }, [&amp;](AST::EnumerationMemberLiteral&amp;) {
 881         }));
 882 
 883         if (!value)
 884             return makeUnexpected(Error(&quot;enum initialization values can only be an int or uint constant.&quot;));
 885         return AST::EnumerationMember(*identifier, WTFMove(name), *value);
 886     }
 887     return AST::EnumerationMember(*identifier, WTFMove(name), defaultValue);
 888 }
 889 
 890 auto Parser::parseNativeTypeDeclaration() -&gt; Expected&lt;AST::NativeTypeDeclaration, Error&gt;
 891 {
 892     CONSUME_TYPE(origin, Native);
 893     CONSUME_TYPE(parsedTypedef, Typedef);
 894     CONSUME_TYPE(name, Identifier);
 895     PARSE(typeArguments, TypeArguments);
 896     CONSUME_TYPE(semicolon, Semicolon);
 897 
 898     return AST::NativeTypeDeclaration({ *origin, *semicolon }, name-&gt;stringView(m_lexer).toString(), WTFMove(*typeArguments));
</pre>
<hr />
<pre>
2046     switch (type-&gt;type) {
2047     case Token::Type::IntLiteral: {
2048         auto value = intLiteralToInt(type-&gt;stringView(m_lexer));
2049         if (!value)
2050             return makeUnexpected(value.error());
2051         return { makeUniqueRef&lt;AST::IntegerLiteral&gt;(*type, *value) };
2052     }
2053     case Token::Type::UintLiteral: {
2054         auto value = uintLiteralToUint(type-&gt;stringView(m_lexer));
2055         if (!value)
2056             return makeUnexpected(value.error());
2057         return { makeUniqueRef&lt;AST::UnsignedIntegerLiteral&gt;(*type, *value) };
2058     }
2059     case Token::Type::FloatLiteral: {
2060         auto value = floatLiteralToFloat(type-&gt;stringView(m_lexer));
2061         if (!value)
2062             return makeUnexpected(value.error());
2063         return { makeUniqueRef&lt;AST::FloatLiteral&gt;(*type, *value) };
2064     }
2065     case Token::Type::Null:
<span class="line-modified">2066         return { makeUniqueRef&lt;AST::NullLiteral&gt;(*type) };</span>
2067     case Token::Type::True:
2068         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(*type, true) };
2069     case Token::Type::False:
2070         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(*type, false) };
2071     case Token::Type::Identifier: {
2072         auto name = type-&gt;stringView(m_lexer).toString();
2073         return { makeUniqueRef&lt;AST::VariableReference&gt;(*type, WTFMove(name)) };
2074     }
2075     default: {
2076         ASSERT(type-&gt;type == Token::Type::LeftParenthesis);
2077         PARSE(expression, Expression);
2078         CONSUME_TYPE(rightParenthesis, RightParenthesis);
2079 
2080         return { WTFMove(*expression) };
2081     }
2082     }
2083 }
2084 
2085 } // namespace WHLSL
2086 
</pre>
</td>
<td>
<hr />
<pre>
 386 
 387     switch (type-&gt;type) {
 388     case Token::Type::IntLiteral: {
 389         auto value = intLiteralToInt(type-&gt;stringView(m_lexer));
 390         if (!value)
 391             return makeUnexpected(value.error());
 392         return {{ AST::IntegerLiteral({ *type }, *value) }};
 393     }
 394     case Token::Type::UintLiteral: {
 395         auto value = uintLiteralToUint(type-&gt;stringView(m_lexer));
 396         if (!value)
 397             return makeUnexpected(value.error());
 398         return {{ AST::UnsignedIntegerLiteral({ *type }, *value) }};
 399     }
 400     case Token::Type::FloatLiteral: {
 401         auto value = floatLiteralToFloat(type-&gt;stringView(m_lexer));
 402         if (!value)
 403             return makeUnexpected(value.error());
 404         return {{ AST::FloatLiteral({ *type }, *value) }};
 405     }


 406     case Token::Type::True:
 407         return { AST::BooleanLiteral(WTFMove(*type), true) };
 408     case Token::Type::False:
 409         return { AST::BooleanLiteral(WTFMove(*type), false) };
 410     default: {
 411         ASSERT(type-&gt;type == Token::Type::Identifier);
 412         CONSUME_TYPE(fullStop, FullStop);
 413         CONSUME_TYPE(next, Identifier);
 414         return { AST::EnumerationMemberLiteral({ *type, *next }, type-&gt;stringView(m_lexer).toString(), next-&gt;stringView(m_lexer).toString()) };
 415     }
 416     }
 417 }
 418 
 419 auto Parser::parseTypeArgument() -&gt; Expected&lt;AST::TypeArgument, Error&gt;
 420 {
 421     PEEK(nextToken);
 422     PEEK_FURTHER(furtherToken);
 423     if (nextToken-&gt;type != Token::Type::Identifier || furtherToken-&gt;type == Token::Type::FullStop) {
 424         PARSE(constantExpression, ConstantExpression);
 425         return AST::TypeArgument(WTFMove(*constantExpression));
</pre>
<hr />
<pre>
 679     if (infoStringView.length() &lt; 2 || (infoStringView[0] != &#39;u&#39;
 680         &amp;&amp; infoStringView[0] != &#39;t&#39;
 681         &amp;&amp; infoStringView[0] != &#39;b&#39;
 682         &amp;&amp; infoStringView[0] != &#39;s&#39;))
 683         return makeUnexpected(Error(makeString(infoStringView.substring(0, 1), &quot; is not a known resource type (&#39;u&#39;, &#39;t&#39;, &#39;b&#39;, or &#39;s&#39;)&quot;)));
 684 
 685     AST::ResourceSemantic::Mode mode;
 686     switch (infoStringView[0]) {
 687     case &#39;u&#39;:
 688         mode = AST::ResourceSemantic::Mode::UnorderedAccessView;
 689         break;
 690     case &#39;t&#39;:
 691         mode = AST::ResourceSemantic::Mode::Texture;
 692         break;
 693     case &#39;b&#39;:
 694         mode = AST::ResourceSemantic::Mode::Buffer;
 695         break;
 696     case &#39;s&#39;:
 697         mode = AST::ResourceSemantic::Mode::Sampler;
 698         break;
<span class="line-added"> 699     default:</span>
<span class="line-added"> 700         RELEASE_ASSERT_NOT_REACHED();</span>
 701     }
 702 
 703     auto index = recognizeSimpleUnsignedInteger(infoStringView.substring(1));
 704     if (!index)
 705         return makeUnexpected(index.error());
 706 
 707     unsigned space = 0;
 708     if (tryType(Token::Type::Comma)) {
 709         CONSUME_TYPE(spaceToken, Identifier);
 710         auto spaceTokenStringView = spaceToken-&gt;stringView(m_lexer);
 711         StringView prefix { &quot;space&quot; };
 712         if (!spaceTokenStringView.startsWith(prefix))
 713             return makeUnexpected(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceTokenStringView, &quot; needs be of the form &#39;space0&#39;&quot;)));
 714         if (spaceTokenStringView.length() &lt;= prefix.length())
 715             return makeUnexpected(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceTokenStringView, &quot; needs be of the form &#39;space0&#39;&quot;)));
 716         auto spaceValue = recognizeSimpleUnsignedInteger(spaceTokenStringView.substring(prefix.length()));
 717         if (!spaceValue)
 718             return makeUnexpected(spaceValue.error());
 719         space = *spaceValue;
 720     }
</pre>
<hr />
<pre>
 858     CONSUME_TYPE(rightCurlyBracket, RightCurlyBracket);
 859     result.updateCodeLocation({ *origin, *rightCurlyBracket});
 860 
 861     return WTFMove(result);
 862 }
 863 
 864 auto Parser::parseEnumerationMember(int64_t defaultValue) -&gt; Expected&lt;AST::EnumerationMember, Error&gt;
 865 {
 866     CONSUME_TYPE(identifier, Identifier);
 867     auto name = identifier-&gt;stringView(m_lexer).toString();
 868 
 869     if (tryType(Token::Type::EqualsSign)) {
 870         PARSE(constantExpression, ConstantExpression);
 871 
 872         Optional&lt;int64_t&gt; value;
 873         constantExpression-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {
 874             value = integerLiteral.value();
 875         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {
 876             value = unsignedIntegerLiteral.value();
 877         }, [&amp;](AST::FloatLiteral&amp;) {

 878         }, [&amp;](AST::BooleanLiteral&amp;) {
 879         }, [&amp;](AST::EnumerationMemberLiteral&amp;) {
 880         }));
 881 
 882         if (!value)
 883             return makeUnexpected(Error(&quot;enum initialization values can only be an int or uint constant.&quot;));
 884         return AST::EnumerationMember(*identifier, WTFMove(name), *value);
 885     }
 886     return AST::EnumerationMember(*identifier, WTFMove(name), defaultValue);
 887 }
 888 
 889 auto Parser::parseNativeTypeDeclaration() -&gt; Expected&lt;AST::NativeTypeDeclaration, Error&gt;
 890 {
 891     CONSUME_TYPE(origin, Native);
 892     CONSUME_TYPE(parsedTypedef, Typedef);
 893     CONSUME_TYPE(name, Identifier);
 894     PARSE(typeArguments, TypeArguments);
 895     CONSUME_TYPE(semicolon, Semicolon);
 896 
 897     return AST::NativeTypeDeclaration({ *origin, *semicolon }, name-&gt;stringView(m_lexer).toString(), WTFMove(*typeArguments));
</pre>
<hr />
<pre>
2045     switch (type-&gt;type) {
2046     case Token::Type::IntLiteral: {
2047         auto value = intLiteralToInt(type-&gt;stringView(m_lexer));
2048         if (!value)
2049             return makeUnexpected(value.error());
2050         return { makeUniqueRef&lt;AST::IntegerLiteral&gt;(*type, *value) };
2051     }
2052     case Token::Type::UintLiteral: {
2053         auto value = uintLiteralToUint(type-&gt;stringView(m_lexer));
2054         if (!value)
2055             return makeUnexpected(value.error());
2056         return { makeUniqueRef&lt;AST::UnsignedIntegerLiteral&gt;(*type, *value) };
2057     }
2058     case Token::Type::FloatLiteral: {
2059         auto value = floatLiteralToFloat(type-&gt;stringView(m_lexer));
2060         if (!value)
2061             return makeUnexpected(value.error());
2062         return { makeUniqueRef&lt;AST::FloatLiteral&gt;(*type, *value) };
2063     }
2064     case Token::Type::Null:
<span class="line-modified">2065         return makeUnexpected(Error(&quot;&#39;null&#39; is a reserved keyword.&quot;, type-&gt;codeLocation));</span>
2066     case Token::Type::True:
2067         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(*type, true) };
2068     case Token::Type::False:
2069         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(*type, false) };
2070     case Token::Type::Identifier: {
2071         auto name = type-&gt;stringView(m_lexer).toString();
2072         return { makeUniqueRef&lt;AST::VariableReference&gt;(*type, WTFMove(name)) };
2073     }
2074     default: {
2075         ASSERT(type-&gt;type == Token::Type::LeftParenthesis);
2076         PARSE(expression, Expression);
2077         CONSUME_TYPE(rightParenthesis, RightParenthesis);
2078 
2079         return { WTFMove(*expression) };
2080     }
2081     }
2082 }
2083 
2084 } // namespace WHLSL
2085 
</pre>
</td>
</tr>
</table>
<center><a href="WHLSLLiteralTypeChecker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLPrepare.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
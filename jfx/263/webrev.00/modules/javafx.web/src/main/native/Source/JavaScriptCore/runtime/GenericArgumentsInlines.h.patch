diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/GenericArgumentsInlines.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/GenericArgumentsInlines.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/GenericArgumentsInlines.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/GenericArgumentsInlines.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
+ * Copyright (C) 2015-2020 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -40,14 +40,14 @@
     if (thisObject->m_modifiedArgumentsDescriptor)
         visitor.markAuxiliary(thisObject->m_modifiedArgumentsDescriptor.getUnsafe());
 }
 
 template<typename Type>
-bool GenericArguments<Type>::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName ident, PropertySlot& slot)
+bool GenericArguments<Type>::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName ident, PropertySlot& slot)
 {
     Type* thisObject = jsCast<Type*>(object);
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
 
     if (!thisObject->overrodeThings()) {
         if (ident == vm.propertyNames->length) {
             slot.setValue(thisObject, static_cast<unsigned>(PropertyAttribute::DontEnum), jsNumber(thisObject->internalLength()));
             return true;
@@ -61,26 +61,26 @@
             return true;
         }
     }
 
     if (Optional<uint32_t> index = parseIndex(ident))
-        return GenericArguments<Type>::getOwnPropertySlotByIndex(thisObject, exec, *index, slot);
+        return GenericArguments<Type>::getOwnPropertySlotByIndex(thisObject, globalObject, *index, slot);
 
-    return Base::getOwnPropertySlot(thisObject, exec, ident, slot);
+    return Base::getOwnPropertySlot(thisObject, globalObject, ident, slot);
 }
 
 template<typename Type>
-bool GenericArguments<Type>::getOwnPropertySlotByIndex(JSObject* object, ExecState* exec, unsigned index, PropertySlot& slot)
+bool GenericArguments<Type>::getOwnPropertySlotByIndex(JSObject* object, JSGlobalObject* globalObject, unsigned index, PropertySlot& slot)
 {
     Type* thisObject = jsCast<Type*>(object);
 
     if (!thisObject->isModifiedArgumentDescriptor(index) && thisObject->isMappedArgument(index)) {
         slot.setValue(thisObject, static_cast<unsigned>(PropertyAttribute::None), thisObject->getIndexQuickly(index));
         return true;
     }
 
-    bool result = Base::getOwnPropertySlotByIndex(object, exec, index, slot);
+    bool result = Base::getOwnPropertySlotByIndex(object, globalObject, index, slot);
 
     if (thisObject->isMappedArgument(index)) {
         ASSERT(result);
         slot.setValue(thisObject, slot.attributes(), thisObject->getIndexQuickly(index));
         return true;
@@ -88,13 +88,13 @@
 
     return result;
 }
 
 template<typename Type>
-void GenericArguments<Type>::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray& array, EnumerationMode mode)
+void GenericArguments<Type>::getOwnPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray& array, EnumerationMode mode)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     Type* thisObject = jsCast<Type*>(object);
 
     if (array.includeStringProperties()) {
         for (unsigned i = 0; i < thisObject->internalLength(); ++i) {
             if (!thisObject->isMappedArgument(i))
@@ -107,109 +107,121 @@
         array.add(vm.propertyNames->length);
         array.add(vm.propertyNames->callee);
         if (array.includeSymbolProperties())
             array.add(vm.propertyNames->iteratorSymbol);
     }
-    Base::getOwnPropertyNames(thisObject, exec, array, mode);
+    Base::getOwnPropertyNames(thisObject, globalObject, array, mode);
 }
 
 template<typename Type>
-bool GenericArguments<Type>::put(JSCell* cell, ExecState* exec, PropertyName ident, JSValue value, PutPropertySlot& slot)
+bool GenericArguments<Type>::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName ident, JSValue value, PutPropertySlot& slot)
 {
     Type* thisObject = jsCast<Type*>(cell);
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
+    auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (!thisObject->overrodeThings()
         && (ident == vm.propertyNames->length
             || ident == vm.propertyNames->callee
             || ident == vm.propertyNames->iteratorSymbol)) {
-        thisObject->overrideThings(vm);
+        thisObject->overrideThings(globalObject);
+        RETURN_IF_EXCEPTION(scope, false);
         PutPropertySlot dummy = slot; // This put is not cacheable, so we shadow the slot that was given to us.
-        return Base::put(thisObject, exec, ident, value, dummy);
+        RELEASE_AND_RETURN(scope, Base::put(thisObject, globalObject, ident, value, dummy));
     }
 
     // https://tc39.github.io/ecma262/#sec-arguments-exotic-objects-set-p-v-receiver
     // Fall back to the OrdinarySet when the receiver is altered from the thisObject.
     if (UNLIKELY(isThisValueAltered(slot, thisObject)))
-        return ordinarySetSlow(exec, thisObject, ident, value, slot.thisValue(), slot.isStrictMode());
+        RELEASE_AND_RETURN(scope, ordinarySetSlow(globalObject, thisObject, ident, value, slot.thisValue(), slot.isStrictMode()));
 
     Optional<uint32_t> index = parseIndex(ident);
     if (index && thisObject->isMappedArgument(index.value())) {
         thisObject->setIndexQuickly(vm, index.value(), value);
         return true;
     }
 
-    return Base::put(thisObject, exec, ident, value, slot);
+    RELEASE_AND_RETURN(scope, Base::put(thisObject, globalObject, ident, value, slot));
 }
 
 template<typename Type>
-bool GenericArguments<Type>::putByIndex(JSCell* cell, ExecState* exec, unsigned index, JSValue value, bool shouldThrow)
+bool GenericArguments<Type>::putByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned index, JSValue value, bool shouldThrow)
 {
     Type* thisObject = jsCast<Type*>(cell);
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
 
     if (thisObject->isMappedArgument(index)) {
         thisObject->setIndexQuickly(vm, index, value);
         return true;
     }
 
-    return Base::putByIndex(cell, exec, index, value, shouldThrow);
+    return Base::putByIndex(cell, globalObject, index, value, shouldThrow);
 }
 
 template<typename Type>
-bool GenericArguments<Type>::deleteProperty(JSCell* cell, ExecState* exec, PropertyName ident)
+bool GenericArguments<Type>::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName ident)
 {
     Type* thisObject = jsCast<Type*>(cell);
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
+    auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (!thisObject->overrodeThings()
         && (ident == vm.propertyNames->length
             || ident == vm.propertyNames->callee
-            || ident == vm.propertyNames->iteratorSymbol))
-        thisObject->overrideThings(vm);
+            || ident == vm.propertyNames->iteratorSymbol)) {
+        thisObject->overrideThings(globalObject);
+        RETURN_IF_EXCEPTION(scope, false);
+    }
 
     if (Optional<uint32_t> index = parseIndex(ident))
-        return GenericArguments<Type>::deletePropertyByIndex(thisObject, exec, *index);
+        RELEASE_AND_RETURN(scope, GenericArguments<Type>::deletePropertyByIndex(thisObject, globalObject, *index));
 
-    return Base::deleteProperty(thisObject, exec, ident);
+    RELEASE_AND_RETURN(scope, Base::deleteProperty(thisObject, globalObject, ident));
 }
 
 template<typename Type>
-bool GenericArguments<Type>::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned index)
+bool GenericArguments<Type>::deletePropertyByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned index)
 {
+    VM& vm = globalObject->vm();
+    auto scope = DECLARE_THROW_SCOPE(vm);
+
     Type* thisObject = jsCast<Type*>(cell);
-    VM& vm = exec->vm();
 
     bool propertyMightBeInJSObjectStorage = thisObject->isModifiedArgumentDescriptor(index) || !thisObject->isMappedArgument(index);
     bool deletedProperty = true;
-    if (propertyMightBeInJSObjectStorage)
-        deletedProperty = Base::deletePropertyByIndex(cell, exec, index);
+    if (propertyMightBeInJSObjectStorage) {
+        deletedProperty = Base::deletePropertyByIndex(cell, globalObject, index);
+        RETURN_IF_EXCEPTION(scope, true);
+    }
 
     if (deletedProperty) {
         // Deleting an indexed property unconditionally unmaps it.
         if (thisObject->isMappedArgument(index)) {
             // We need to check that the property was mapped so we don't write to random memory.
-            thisObject->unmapArgument(vm, index);
+            thisObject->unmapArgument(globalObject, index);
+            RETURN_IF_EXCEPTION(scope, true);
         }
-        thisObject->setModifiedArgumentDescriptor(vm, index);
+        thisObject->setModifiedArgumentDescriptor(globalObject, index);
+        RETURN_IF_EXCEPTION(scope, true);
     }
 
     return deletedProperty;
 }
 
 template<typename Type>
-bool GenericArguments<Type>::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName ident, const PropertyDescriptor& descriptor, bool shouldThrow)
+bool GenericArguments<Type>::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName ident, const PropertyDescriptor& descriptor, bool shouldThrow)
 {
     Type* thisObject = jsCast<Type*>(object);
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (ident == vm.propertyNames->length
         || ident == vm.propertyNames->callee
-        || ident == vm.propertyNames->iteratorSymbol)
-        thisObject->overrideThingsIfNecessary(vm);
-    else {
+        || ident == vm.propertyNames->iteratorSymbol) {
+        thisObject->overrideThingsIfNecessary(globalObject);
+        RETURN_IF_EXCEPTION(scope, false);
+    } else {
         Optional<uint32_t> optionalIndex = parseIndex(ident);
         if (optionalIndex) {
             uint32_t index = optionalIndex.value();
             if (!descriptor.isAccessorDescriptor() && thisObject->isMappedArgument(optionalIndex.value())) {
                 // If the property is not deleted and we are using a non-accessor descriptor, then
@@ -225,14 +237,15 @@
 
                 if (!thisObject->isModifiedArgumentDescriptor(index)) {
                     // If it is a new entry, we need to put direct to initialize argument[i] descriptor properly
                     JSValue value = thisObject->getIndexQuickly(index);
                     ASSERT(value);
-                    object->putDirectMayBeIndex(exec, ident, value);
+                    object->putDirectMayBeIndex(globalObject, ident, value);
                     scope.assertNoException();
 
-                    thisObject->setModifiedArgumentDescriptor(vm, index);
+                    thisObject->setModifiedArgumentDescriptor(globalObject, index);
+                    RETURN_IF_EXCEPTION(scope, false);
                 }
             }
 
             if (thisObject->isMappedArgument(index)) {
                 // Just unmap arguments if its descriptor contains {writable: false}.
@@ -241,49 +254,62 @@
                 // property from arguments object are {writable: true, configurable: true, enumerable: true} by default
                 if ((descriptor.writablePresent() && !descriptor.writable()) || descriptor.isAccessorDescriptor()) {
                     if (!descriptor.isAccessorDescriptor()) {
                         JSValue value = thisObject->getIndexQuickly(index);
                         ASSERT(value);
-                        object->putDirectMayBeIndex(exec, ident, value);
+                        object->putDirectMayBeIndex(globalObject, ident, value);
                         scope.assertNoException();
                     }
-                    thisObject->unmapArgument(vm, index);
-                    thisObject->setModifiedArgumentDescriptor(vm, index);
+                    thisObject->unmapArgument(globalObject, index);
+                    RETURN_IF_EXCEPTION(scope, false);
+                    thisObject->setModifiedArgumentDescriptor(globalObject, index);
+                    RETURN_IF_EXCEPTION(scope, false);
                 }
             }
         }
     }
 
     // Now just let the normal object machinery do its thing.
-    RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, exec, ident, descriptor, shouldThrow));
+    RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, globalObject, ident, descriptor, shouldThrow));
 }
 
 template<typename Type>
-void GenericArguments<Type>::initModifiedArgumentsDescriptor(VM& vm, unsigned argsLength)
+void GenericArguments<Type>::initModifiedArgumentsDescriptor(JSGlobalObject* globalObject, unsigned argsLength)
 {
+    VM& vm = globalObject->vm();
+    auto scope = DECLARE_THROW_SCOPE(vm);
+
     RELEASE_ASSERT(!m_modifiedArgumentsDescriptor);
 
     if (argsLength) {
-        void* backingStore = vm.gigacageAuxiliarySpace(m_modifiedArgumentsDescriptor.kind).allocateNonVirtual(vm, WTF::roundUpToMultipleOf<8>(argsLength), nullptr, AllocationFailureMode::Assert);
+        void* backingStore = vm.gigacageAuxiliarySpace(m_modifiedArgumentsDescriptor.kind).allocateNonVirtual(vm, WTF::roundUpToMultipleOf<8>(argsLength), nullptr, AllocationFailureMode::ReturnNull);
+        if (UNLIKELY(!backingStore)) {
+            throwOutOfMemoryError(globalObject, scope);
+            return;
+        }
         bool* modifiedArguments = static_cast<bool*>(backingStore);
         m_modifiedArgumentsDescriptor.set(vm, this, modifiedArguments, argsLength);
         for (unsigned i = argsLength; i--;)
             modifiedArguments[i] = false;
     }
 }
 
 template<typename Type>
-void GenericArguments<Type>::initModifiedArgumentsDescriptorIfNecessary(VM& vm, unsigned argsLength)
+void GenericArguments<Type>::initModifiedArgumentsDescriptorIfNecessary(JSGlobalObject* globalObject, unsigned argsLength)
 {
     if (!m_modifiedArgumentsDescriptor)
-        initModifiedArgumentsDescriptor(vm, argsLength);
+        initModifiedArgumentsDescriptor(globalObject, argsLength);
 }
 
 template<typename Type>
-void GenericArguments<Type>::setModifiedArgumentDescriptor(VM& vm, unsigned index, unsigned length)
+void GenericArguments<Type>::setModifiedArgumentDescriptor(JSGlobalObject* globalObject, unsigned index, unsigned length)
 {
-    initModifiedArgumentsDescriptorIfNecessary(vm, length);
+    VM& vm = globalObject->vm();
+    auto scope = DECLARE_THROW_SCOPE(vm);
+
+    initModifiedArgumentsDescriptorIfNecessary(globalObject, length);
+    RETURN_IF_EXCEPTION(scope, void());
     if (index < length)
         m_modifiedArgumentsDescriptor.at(index, length) = true;
 }
 
 template<typename Type>
@@ -295,21 +321,21 @@
         return m_modifiedArgumentsDescriptor.at(index, length);
     return false;
 }
 
 template<typename Type>
-void GenericArguments<Type>::copyToArguments(ExecState* exec, VirtualRegister firstElementDest, unsigned offset, unsigned length)
+void GenericArguments<Type>::copyToArguments(JSGlobalObject* globalObject, JSValue* firstElementDest, unsigned offset, unsigned length)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     Type* thisObject = static_cast<Type*>(this);
     for (unsigned i = 0; i < length; ++i) {
         if (thisObject->isMappedArgument(i + offset))
-            exec->r(firstElementDest + i) = thisObject->getIndexQuickly(i + offset);
+            firstElementDest[i] = thisObject->getIndexQuickly(i + offset);
         else {
-            exec->r(firstElementDest + i) = get(exec, i + offset);
+            firstElementDest[i] = get(globalObject, i + offset);
             RETURN_IF_EXCEPTION(scope, void());
         }
     }
 }
 

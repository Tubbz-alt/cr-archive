<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/arm64.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="arm.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="asm.rb.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/arm64.rb</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  30 #
  31 # x&lt;number&gt;  =&gt; GPR. This is both the generic name of the register, and the name used
  32 #               to indicate that the register is used in 64-bit mode.
  33 # w&lt;number&gt;  =&gt; GPR in 32-bit mode. This is the low 32-bits of the GPR. If it is
  34 #               mutated then the high 32-bit part of the register is zero filled.
  35 # q&lt;number&gt;  =&gt; FPR. This is the generic name of the register.
  36 # d&lt;number&gt;  =&gt; FPR used as an IEEE 64-bit binary floating point number (i.e. double).
  37 #
  38 # GPR conventions, to match the baseline JIT:
  39 #
  40 #  x0  =&gt; t0, a0, r0
  41 #  x1  =&gt; t1, a1, r1
  42 #  x2  =&gt; t2, a2
  43 #  x3  =&gt; t3, a3
  44 #  x4  =&gt; t4
  45 #  x5  =&gt; t5
  46 # x13  =&gt;                  (scratch)
  47 # x16  =&gt;                  (scratch)
  48 # x17  =&gt;                  (scratch)
  49 # x26  =&gt;             csr0 (PB)
<span class="line-modified">  50 # x27  =&gt;             csr1 (tagTypeNumber)</span>
<span class="line-modified">  51 # x28  =&gt;             csr2 (tagMask)</span>
  52 # x29  =&gt; cfr
  53 #  sp  =&gt; sp
  54 #  lr  =&gt; lr
  55 #
  56 # FPR conventions, to match the baseline JIT:
  57 #
  58 #  q0  =&gt; ft0, fa0, fr
  59 #  q1  =&gt; ft1, fa1
  60 #  q2  =&gt; ft2, fa2
  61 #  q3  =&gt; ft3, fa3
  62 #  q4  =&gt; ft4          (unused in baseline)
  63 #  q5  =&gt; ft5          (unused in baseline)
  64 #  q8  =&gt; csfr0        (Only the lower 64 bits)
  65 #  q9  =&gt; csfr1        (Only the lower 64 bits)
  66 # q10  =&gt; csfr2        (Only the lower 64 bits)
  67 # q11  =&gt; csfr3        (Only the lower 64 bits)
  68 # q12  =&gt; csfr4        (Only the lower 64 bits)
  69 # q13  =&gt; csfr5        (Only the lower 64 bits)
  70 # q14  =&gt; csfr6        (Only the lower 64 bits)
  71 # q15  =&gt; csfr7        (Only the lower 64 bits)
  72 # q31  =&gt; scratch
  73 
  74 def arm64GPRName(name, kind)
  75     raise &quot;bad GPR name #{name}&quot; unless name =~ /^x/
  76     number = name[1..-1]
  77     case kind
  78     when :word
  79         &quot;w&quot; + number
  80     when :ptr
  81         prefix = $currentSettings[&quot;ADDRESS64&quot;] ? &quot;x&quot; : &quot;w&quot;
  82         prefix + number
  83     when :quad
  84         &quot;x&quot; + number
  85     else
  86         raise &quot;Wrong kind: #{kind}&quot;
  87     end
  88 end
  89 
  90 def arm64FPRName(name, kind)
<span class="line-removed">  91     raise &quot;bad FPR kind #{kind}&quot; unless kind == :double</span>
  92     raise &quot;bad FPR name #{name}&quot; unless name =~ /^q/
<span class="line-modified">  93     &quot;d&quot; + name[1..-1]</span>









  94 end
  95 
  96 class SpecialRegister
  97     def arm64Operand(kind)
  98         case @name
  99         when /^x/
 100             arm64GPRName(@name, kind)
 101         when /^q/
 102             arm64FPRName(@name, kind)
 103         else
 104             raise &quot;Bad name: #{@name}&quot;
 105         end
 106     end
 107 end
 108 
 109 ARM64_EXTRA_GPRS = [SpecialRegister.new(&quot;x16&quot;), SpecialRegister.new(&quot;x17&quot;), SpecialRegister.new(&quot;x13&quot;)]
 110 ARM64_EXTRA_FPRS = [SpecialRegister.new(&quot;q31&quot;)]
 111 
 112 class RegisterID
 113     def arm64Operand(kind)
 114         case @name
<span class="line-modified"> 115         when &#39;t0&#39;, &#39;a0&#39;, &#39;r0&#39;</span>
 116             arm64GPRName(&#39;x0&#39;, kind)
<span class="line-modified"> 117         when &#39;t1&#39;, &#39;a1&#39;, &#39;r1&#39;</span>
 118             arm64GPRName(&#39;x1&#39;, kind)
<span class="line-modified"> 119         when &#39;t2&#39;, &#39;a2&#39;</span>
 120             arm64GPRName(&#39;x2&#39;, kind)
<span class="line-modified"> 121         when &#39;t3&#39;, &#39;a3&#39;</span>
 122             arm64GPRName(&#39;x3&#39;, kind)
<span class="line-modified"> 123         when &#39;t4&#39;</span>
 124             arm64GPRName(&#39;x4&#39;, kind)
<span class="line-modified"> 125         when &#39;t5&#39;</span>
 126           arm64GPRName(&#39;x5&#39;, kind)
<span class="line-modified"> 127         when &#39;t6&#39;</span>
 128           arm64GPRName(&#39;x6&#39;, kind)
<span class="line-modified"> 129         when &#39;t7&#39;</span>
 130           arm64GPRName(&#39;x7&#39;, kind)




 131         when &#39;cfr&#39;
 132             arm64GPRName(&#39;x29&#39;, kind)
 133         when &#39;csr0&#39;
 134             arm64GPRName(&#39;x19&#39;, kind)
 135         when &#39;csr1&#39;
 136             arm64GPRName(&#39;x20&#39;, kind)
 137         when &#39;csr2&#39;
 138             arm64GPRName(&#39;x21&#39;, kind)
 139         when &#39;csr3&#39;
 140             arm64GPRName(&#39;x22&#39;, kind)
 141         when &#39;csr4&#39;
 142             arm64GPRName(&#39;x23&#39;, kind)
 143         when &#39;csr5&#39;
 144             arm64GPRName(&#39;x24&#39;, kind)
 145         when &#39;csr6&#39;
 146             arm64GPRName(&#39;x25&#39;, kind)
 147         when &#39;csr7&#39;
 148             arm64GPRName(&#39;x26&#39;, kind)
 149         when &#39;csr8&#39;
 150             arm64GPRName(&#39;x27&#39;, kind)
 151         when &#39;csr9&#39;
 152             arm64GPRName(&#39;x28&#39;, kind)
 153         when &#39;sp&#39;
 154             &#39;sp&#39;
 155         when &#39;lr&#39;
 156             &#39;x30&#39;
 157         else
 158             raise &quot;Bad register name #{@name} at #{codeOriginString}&quot;
 159         end
 160     end
 161 end
 162 
 163 class FPRegisterID
 164     def arm64Operand(kind)
 165         case @name
<span class="line-modified"> 166         when &#39;ft0&#39;, &#39;fr&#39;, &#39;fa0&#39;</span>
 167             arm64FPRName(&#39;q0&#39;, kind)
<span class="line-modified"> 168         when &#39;ft1&#39;, &#39;fa1&#39;</span>
 169             arm64FPRName(&#39;q1&#39;, kind)
<span class="line-modified"> 170         when &#39;ft2&#39;, &#39;fa2&#39;</span>
 171             arm64FPRName(&#39;q2&#39;, kind)
<span class="line-modified"> 172         when &#39;ft3&#39;, &#39;fa3&#39;</span>
 173             arm64FPRName(&#39;q3&#39;, kind)
<span class="line-modified"> 174         when &#39;ft4&#39;</span>
 175             arm64FPRName(&#39;q4&#39;, kind)
<span class="line-modified"> 176         when &#39;ft5&#39;</span>
 177             arm64FPRName(&#39;q5&#39;, kind)




 178         when &#39;csfr0&#39;
 179             arm64FPRName(&#39;q8&#39;, kind)
 180         when &#39;csfr1&#39;
 181             arm64FPRName(&#39;q9&#39;, kind)
 182         when &#39;csfr2&#39;
 183             arm64FPRName(&#39;q10&#39;, kind)
 184         when &#39;csfr3&#39;
 185             arm64FPRName(&#39;q11&#39;, kind)
 186         when &#39;csfr4&#39;
 187             arm64FPRName(&#39;q12&#39;, kind)
 188         when &#39;csfr5&#39;
 189             arm64FPRName(&#39;q13&#39;, kind)
 190         when &#39;csfr6&#39;
 191             arm64FPRName(&#39;q14&#39;, kind)
 192         when &#39;csfr7&#39;
 193             arm64FPRName(&#39;q15&#39;, kind)
 194         else &quot;Bad register name #{@name} at #{codeOriginString}&quot;
 195         end
 196     end
 197 end
 198 
 199 class Immediate
 200     def arm64Operand(kind)
<span class="line-removed"> 201         raise &quot;Invalid immediate #{value} at #{codeOriginString}&quot; if value &lt; 0 or value &gt; 4095</span>
 202         &quot;\##{value}&quot;
 203     end
 204 end
 205 
 206 class Address
 207     def arm64Operand(kind)
 208         raise &quot;Invalid offset #{offset.value} at #{codeOriginString}&quot; if offset.value &lt; -255 or offset.value &gt; 4095
 209         &quot;[#{base.arm64Operand(:quad)}, \##{offset.value}]&quot;
 210     end
 211     
 212     def arm64EmitLea(destination, kind)
 213         $asm.puts &quot;add #{destination.arm64Operand(kind)}, #{base.arm64Operand(kind)}, \##{offset.value}&quot;
 214     end
 215 end
 216 
 217 class BaseIndex
 218     def arm64Operand(kind)
 219         raise &quot;Invalid offset #{offset.value} at #{codeOriginString}&quot; if offset.value != 0
 220         &quot;[#{base.arm64Operand(:quad)}, #{index.arm64Operand(:quad)}, lsl \##{scaleShift}]&quot;
 221     end
</pre>
<hr />
<pre>
 361         end
 362         newList &lt;&lt; node
 363     }
 364     newList
 365 end
 366 
 367 class Sequence
 368     def getModifiedListARM64(result = @list)
 369         result = riscLowerNot(result)
 370         result = riscLowerSimpleBranchOps(result)
 371 
 372         result = $currentSettings[&quot;ADDRESS64&quot;] ? riscLowerHardBranchOps64(result) : riscLowerHardBranchOps(result)
 373         result = riscLowerShiftOps(result)
 374         result = arm64LowerMalformedLoadStoreAddresses(result)
 375         result = arm64LowerLabelReferences(result)
 376         result = riscLowerMalformedAddresses(result) {
 377             | node, address |
 378             case node.opcode
 379             when &quot;loadb&quot;, &quot;loadbsi&quot;, &quot;loadbsq&quot;, &quot;storeb&quot;, /^bb/, /^btb/, /^cb/, /^tb/
 380                 size = 1
<span class="line-modified"> 381             when &quot;loadh&quot;, &quot;loadhsi&quot;, &quot;loadhsq&quot;</span>
 382                 size = 2
 383             when &quot;loadi&quot;, &quot;loadis&quot;, &quot;storei&quot;, &quot;addi&quot;, &quot;andi&quot;, &quot;lshifti&quot;, &quot;muli&quot;, &quot;negi&quot;,
 384                 &quot;noti&quot;, &quot;ori&quot;, &quot;rshifti&quot;, &quot;urshifti&quot;, &quot;subi&quot;, &quot;xori&quot;, /^bi/, /^bti/,
<span class="line-modified"> 385                 /^ci/, /^ti/, &quot;addis&quot;, &quot;subis&quot;, &quot;mulis&quot;, &quot;smulli&quot;, &quot;leai&quot;</span>
 386                 size = 4
 387             when &quot;loadp&quot;, &quot;storep&quot;, &quot;loadq&quot;, &quot;storeq&quot;, &quot;loadd&quot;, &quot;stored&quot;, &quot;lshiftp&quot;, &quot;lshiftq&quot;, &quot;negp&quot;, &quot;negq&quot;, &quot;rshiftp&quot;, &quot;rshiftq&quot;,
 388                 &quot;urshiftp&quot;, &quot;urshiftq&quot;, &quot;addp&quot;, &quot;addq&quot;, &quot;mulp&quot;, &quot;mulq&quot;, &quot;andp&quot;, &quot;andq&quot;, &quot;orp&quot;, &quot;orq&quot;, &quot;subp&quot;, &quot;subq&quot;, &quot;xorp&quot;, &quot;xorq&quot;, &quot;addd&quot;,
 389                 &quot;divd&quot;, &quot;subd&quot;, &quot;muld&quot;, &quot;sqrtd&quot;, /^bp/, /^bq/, /^btp/, /^btq/, /^cp/, /^cq/, /^tp/, /^tq/, /^bd/,
 390                 &quot;jmp&quot;, &quot;call&quot;, &quot;leap&quot;, &quot;leaq&quot;
 391                 size = $currentSettings[&quot;ADDRESS64&quot;] ? 8 : 4
 392             else
 393                 raise &quot;Bad instruction #{node.opcode} for heap access at #{node.codeOriginString}: #{node.dump}&quot;
 394             end
 395             
 396             if address.is_a? BaseIndex
 397                 address.offset.value == 0 and
 398                     (node.opcode =~ /^lea/ or address.scale == 1 or address.scale == size)
 399             elsif address.is_a? Address
 400                 (-255..4095).include? address.offset.value
 401             else
 402                 false
 403             end
 404         }
<span class="line-modified"> 405         result = riscLowerMisplacedImmediates(result, [&quot;storeb&quot;, &quot;storei&quot;, &quot;storep&quot;, &quot;storeq&quot;])</span>
<span class="line-modified"> 406         result = riscLowerMalformedImmediates(result, 0..4095)</span>

































 407         result = riscLowerMisplacedAddresses(result)
 408         result = riscLowerMalformedAddresses(result) {
 409             | node, address |
 410             case node.opcode
 411             when /^load/
 412                 true
 413             when /^store/
 414                 not (address.is_a? Address and address.offset.value &lt; 0)
 415             when /^lea/
 416                 true
 417             else
 418                 raise &quot;Bad instruction #{node.opcode} for heap access at #{node.codeOriginString}&quot;
 419             end
 420         }
 421         result = riscLowerTest(result)
 422         result = arm64FixSpecialRegisterArithmeticMode(result)
 423         result = assignRegistersToTemporaries(result, :gpr, ARM64_EXTRA_GPRS)
 424         result = assignRegistersToTemporaries(result, :fpr, ARM64_EXTRA_FPRS)
 425         result = arm64CortexA53Fix835769(result)
 426         return result
</pre>
<hr />
<pre>
 514         end
 515     end
 516 
 517     if operands.size == 2
 518         if operands[0].immediate? and operands[0].value == 0 and opcode !~ /s$/
 519             return
 520         end
 521     end
 522 
 523     emitARM64TAC(opcode, operands, kind)
 524 end
 525 
 526 def emitARM64Unflipped(opcode, operands, kind)
 527     $asm.puts &quot;#{opcode} #{arm64Operands(operands, kind)}&quot;
 528 end
 529 
 530 def emitARM64TAC(opcode, operands, kind)
 531     $asm.puts &quot;#{opcode} #{arm64TACOperands(operands, kind)}&quot;
 532 end
 533 



























 534 def emitARM64(opcode, operands, kind)
 535     $asm.puts &quot;#{opcode} #{arm64FlippedOperands(operands, kind)}&quot;
 536 end
 537 
 538 def emitARM64Access(opcode, opcodeNegativeOffset, register, memory, kind)
 539     if memory.is_a? Address and memory.offset.value &lt; 0
 540         raise unless -256 &lt;= memory.offset.value
 541         $asm.puts &quot;#{opcodeNegativeOffset} #{register.arm64Operand(kind)}, #{memory.arm64Operand(kind)}&quot;
 542         return
 543     end
 544 
 545     $asm.puts &quot;#{opcode} #{register.arm64Operand(kind)}, #{memory.arm64Operand(kind)}&quot;
 546 end
 547 
 548 def emitARM64Shift(opcodeRegs, opcodeImmediate, operands, kind)
 549     if operands.size == 3 and operands[1].immediate?
 550         magicNumbers = yield operands[1].value
 551         $asm.puts &quot;#{opcodeImmediate} #{operands[2].arm64Operand(kind)}, #{operands[0].arm64Operand(kind)}, \##{magicNumbers[0]}, \##{magicNumbers[1]}&quot;
 552         return
 553     end
</pre>
<hr />
<pre>
 564 def emitARM64LShift(operands, kind)
 565     emitARM64Shift(&quot;lslv&quot;, &quot;ubfm&quot;, operands, kind) {
 566         | value |
 567         case kind
 568         when :word
 569             [32 - value, 31 - value]
 570         when :ptr
 571             bitSize = $currentSettings[&quot;ADDRESS64&quot;] ? 64 : 32
 572             [bitSize - value, bitSize - 1 - value]
 573         when :quad
 574             [64 - value, 63 - value]
 575         end
 576     }
 577 end
 578 
 579 def emitARM64Branch(opcode, operands, kind, branchOpcode)
 580     emitARM64Unflipped(opcode, operands[0..-2], kind)
 581     $asm.puts &quot;#{branchOpcode} #{operands[-1].asmLabel}&quot;
 582 end
 583 





 584 def emitARM64Compare(operands, kind, compareCode)
 585     emitARM64Unflipped(&quot;subs #{arm64GPRName(&#39;xzr&#39;, kind)}, &quot;, operands[0..-2], kind)
 586     $asm.puts &quot;csinc #{operands[-1].arm64Operand(:word)}, wzr, wzr, #{compareCode}&quot;
 587 end
 588 
 589 def emitARM64MoveImmediate(value, target)
 590     first = true
 591     isNegative = value &lt; 0
 592     [48, 32, 16, 0].each {
 593         | shift |
 594         currentValue = (value &gt;&gt; shift) &amp; 0xffff
 595         next if currentValue == (isNegative ? 0xffff : 0) and (shift != 0 or !first)
 596         if first
 597             if isNegative
 598                 $asm.puts &quot;movn #{target.arm64Operand(:quad)}, \##{(~currentValue) &amp; 0xffff}, lsl \##{shift}&quot;
 599             else
 600                 $asm.puts &quot;movz #{target.arm64Operand(:quad)}, \##{currentValue}, lsl \##{shift}&quot;
 601             end
 602             first = false
 603         else
</pre>
<hr />
<pre>
 614         when &#39;addis&#39;
 615             emitARM64Add(&quot;adds&quot;, operands, :word)
 616         when &#39;addp&#39;
 617             emitARM64Add(&quot;add&quot;, operands, :ptr)
 618         when &#39;addps&#39;
 619             emitARM64Add(&quot;adds&quot;, operands, :ptr)
 620         when &#39;addq&#39;
 621             emitARM64Add(&quot;add&quot;, operands, :quad)
 622         when &quot;andi&quot;
 623             emitARM64TAC(&quot;and&quot;, operands, :word)
 624         when &quot;andp&quot;
 625             emitARM64TAC(&quot;and&quot;, operands, :ptr)
 626         when &quot;andq&quot;
 627             emitARM64TAC(&quot;and&quot;, operands, :quad)
 628         when &quot;ori&quot;
 629             emitARM64TAC(&quot;orr&quot;, operands, :word)
 630         when &quot;orp&quot;
 631             emitARM64TAC(&quot;orr&quot;, operands, :ptr)
 632         when &quot;orq&quot;
 633             emitARM64TAC(&quot;orr&quot;, operands, :quad)


 634         when &quot;xori&quot;
 635             emitARM64TAC(&quot;eor&quot;, operands, :word)
 636         when &quot;xorp&quot;
 637             emitARM64TAC(&quot;eor&quot;, operands, :ptr)
 638         when &quot;xorq&quot;
 639             emitARM64TAC(&quot;eor&quot;, operands, :quad)








 640         when &quot;lshifti&quot;
 641             emitARM64LShift(operands, :word)
 642         when &quot;lshiftp&quot;
 643             emitARM64LShift(operands, :ptr)
 644         when &quot;lshiftq&quot;
 645             emitARM64LShift(operands, :quad)
 646         when &quot;rshifti&quot;
 647             emitARM64Shift(&quot;asrv&quot;, &quot;sbfm&quot;, operands, :word) {
 648                 | value |
 649                 [value, 31]
 650             }
 651         when &quot;rshiftp&quot;
 652             emitARM64Shift(&quot;asrv&quot;, &quot;sbfm&quot;, operands, :ptr) {
 653                 | value |
 654                 bitSize = $currentSettings[&quot;ADDRESS64&quot;] ? 64 : 32
 655                 [value, bitSize - 1]
 656             }
 657         when &quot;rshiftq&quot;
 658             emitARM64Shift(&quot;asrv&quot;, &quot;sbfm&quot;, operands, :quad) {
 659                 | value |
</pre>
<hr />
<pre>
 722         when &quot;loadhsi&quot;
 723             emitARM64Access(&quot;ldrsh&quot;, &quot;ldursh&quot;, operands[1], operands[0], :word)
 724         when &quot;loadhsq&quot;
 725             emitARM64Access(&quot;ldrsh&quot;, &quot;ldursh&quot;, operands[1], operands[0], :quad)
 726         when &quot;storeh&quot;
 727             emitARM64Unflipped(&quot;strh&quot;, operands, :word)
 728         when &quot;loadd&quot;
 729             emitARM64Access(&quot;ldr&quot;, &quot;ldur&quot;, operands[1], operands[0], :double)
 730         when &quot;stored&quot;
 731             emitARM64Unflipped(&quot;str&quot;, operands, :double)
 732         when &quot;addd&quot;
 733             emitARM64TAC(&quot;fadd&quot;, operands, :double)
 734         when &quot;divd&quot;
 735             emitARM64TAC(&quot;fdiv&quot;, operands, :double)
 736         when &quot;subd&quot;
 737             emitARM64TAC(&quot;fsub&quot;, operands, :double)
 738         when &quot;muld&quot;
 739             emitARM64TAC(&quot;fmul&quot;, operands, :double)
 740         when &quot;sqrtd&quot;
 741             emitARM64(&quot;fsqrt&quot;, operands, :double)
<span class="line-removed"> 742         when &quot;ci2d&quot;</span>
<span class="line-removed"> 743             emitARM64(&quot;scvtf&quot;, operands, [:word, :double])</span>
 744         when &quot;bdeq&quot;
 745             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.eq&quot;)
 746         when &quot;bdneq&quot;
 747             emitARM64Unflipped(&quot;fcmp&quot;, operands[0..1], :double)
 748             isUnordered = LocalLabel.unique(&quot;bdneq&quot;)
 749             $asm.puts &quot;b.vs #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
 750             $asm.puts &quot;b.ne #{operands[2].asmLabel}&quot;
<span class="line-modified"> 751             isUnordered.lower(&quot;ARM64&quot;)</span>
 752         when &quot;bdgt&quot;
 753             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.gt&quot;)
 754         when &quot;bdgteq&quot;
 755             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.ge&quot;)
 756         when &quot;bdlt&quot;
 757             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.mi&quot;)
 758         when &quot;bdlteq&quot;
 759             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.ls&quot;)
 760         when &quot;bdequn&quot;
 761             emitARM64Unflipped(&quot;fcmp&quot;, operands[0..1], :double)
 762             $asm.puts &quot;b.vs #{operands[2].asmLabel}&quot;
 763             $asm.puts &quot;b.eq #{operands[2].asmLabel}&quot;
 764         when &quot;bdnequn&quot;
 765             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.ne&quot;)
 766         when &quot;bdgtun&quot;
 767             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.hi&quot;)
 768         when &quot;bdgtequn&quot;
 769             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.pl&quot;)
 770         when &quot;bdltun&quot;
 771             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.lt&quot;)
</pre>
<hr />
<pre>
 792                 # on platforms that only push/pop one slot at a time they pop their 
 793                 # arguments in the reverse order that they were pushed. In order to remain 
 794                 # compatible with those platforms we assume here that that&#39;s what has been done.
 795 
 796                 # So for example, if we did push(A, B, C, D), we would then pop(D, C, B, A).
 797                 # But since the ordering of arguments doesn&#39;t change on arm64 between the stp and ldp 
 798                 # instructions we need to flip flop the argument positions that were passed to us.
 799                 $asm.puts &quot;ldp #{ops[1].arm64Operand(:quad)}, #{ops[0].arm64Operand(:quad)}, [sp], #16&quot;
 800             }
 801         when &quot;push&quot;
 802             operands.each_slice(2) {
 803                 | ops |
 804                 $asm.puts &quot;stp #{ops[0].arm64Operand(:quad)}, #{ops[1].arm64Operand(:quad)}, [sp, #-16]!&quot;
 805             }
 806         when &quot;move&quot;
 807             if operands[0].immediate?
 808                 emitARM64MoveImmediate(operands[0].value, operands[1])
 809             else
 810                 emitARM64(&quot;mov&quot;, operands, :quad)
 811             end


 812         when &quot;sxi2p&quot;
 813             emitARM64(&quot;sxtw&quot;, operands, [:word, :ptr])
 814         when &quot;sxi2q&quot;
 815             emitARM64(&quot;sxtw&quot;, operands, [:word, :quad])
 816         when &quot;zxi2p&quot;
 817             emitARM64(&quot;uxtw&quot;, operands, [:word, :ptr])
 818         when &quot;zxi2q&quot;
 819             emitARM64(&quot;uxtw&quot;, operands, [:word, :quad])
 820         when &quot;nop&quot;
 821             $asm.puts &quot;nop&quot;
 822         when &quot;bieq&quot;, &quot;bbeq&quot;
 823             if operands[0].immediate? and operands[0].value == 0
 824                 $asm.puts &quot;cbz #{operands[1].arm64Operand(:word)}, #{operands[2].asmLabel}&quot;
 825             elsif operands[1].immediate? and operands[1].value == 0
 826                 $asm.puts &quot;cbz #{operands[0].arm64Operand(:word)}, #{operands[2].asmLabel}&quot;
 827             else
 828                 emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.eq&quot;)
 829             end
 830         when &quot;bpeq&quot;
 831             if operands[0].immediate? and operands[0].value == 0
</pre>
<hr />
<pre>
1039             $asm.puts &quot;adrp #{operands[1].arm64Operand(:quad)}, #{operands[0].asmLabel}@GOTPAGE&quot;
1040             $asm.puts &quot;L_offlineasm_loh_ldr_#{uid}:&quot;
1041             $asm.puts &quot;ldr #{operands[1].arm64Operand(:quad)}, [#{operands[1].arm64Operand(:quad)}, #{operands[0].asmLabel}@GOTPAGEOFF]&quot;
1042 
1043             # On Linux, use ELF GOT relocation specifiers.
1044             $asm.putStr(&quot;#elif OS(LINUX)&quot;)
1045             $asm.puts &quot;adrp #{operands[1].arm64Operand(:quad)}, :got:#{operands[0].asmLabel}&quot;
1046             $asm.puts &quot;ldr #{operands[1].arm64Operand(:quad)}, [#{operands[1].arm64Operand(:quad)}, :got_lo12:#{operands[0].asmLabel}]&quot;
1047 
1048             # Throw a compiler error everywhere else.
1049             $asm.putStr(&quot;#else&quot;)
1050             $asm.putStr(&quot;#error Missing globaladdr implementation&quot;)
1051             $asm.putStr(&quot;#endif&quot;)
1052 
1053             $asm.deferAction {
1054                 # On Darwin, also include the .loh directive using the generated labels.
1055                 $asm.putStr(&quot;#if OS(DARWIN)&quot;)
1056                 $asm.puts &quot;.loh AdrpLdrGot L_offlineasm_loh_adrp_#{uid}, L_offlineasm_loh_ldr_#{uid}&quot;
1057                 $asm.putStr(&quot;#endif&quot;)
1058             }























































































































































































1059         else
1060             lowerDefault
1061         end
1062     end
1063 end
1064 
</pre>
</td>
<td>
<hr />
<pre>
  30 #
  31 # x&lt;number&gt;  =&gt; GPR. This is both the generic name of the register, and the name used
  32 #               to indicate that the register is used in 64-bit mode.
  33 # w&lt;number&gt;  =&gt; GPR in 32-bit mode. This is the low 32-bits of the GPR. If it is
  34 #               mutated then the high 32-bit part of the register is zero filled.
  35 # q&lt;number&gt;  =&gt; FPR. This is the generic name of the register.
  36 # d&lt;number&gt;  =&gt; FPR used as an IEEE 64-bit binary floating point number (i.e. double).
  37 #
  38 # GPR conventions, to match the baseline JIT:
  39 #
  40 #  x0  =&gt; t0, a0, r0
  41 #  x1  =&gt; t1, a1, r1
  42 #  x2  =&gt; t2, a2
  43 #  x3  =&gt; t3, a3
  44 #  x4  =&gt; t4
  45 #  x5  =&gt; t5
  46 # x13  =&gt;                  (scratch)
  47 # x16  =&gt;                  (scratch)
  48 # x17  =&gt;                  (scratch)
  49 # x26  =&gt;             csr0 (PB)
<span class="line-modified">  50 # x27  =&gt;             csr1 (numberTag)</span>
<span class="line-modified">  51 # x28  =&gt;             csr2 (notCellMask)</span>
  52 # x29  =&gt; cfr
  53 #  sp  =&gt; sp
  54 #  lr  =&gt; lr
  55 #
  56 # FPR conventions, to match the baseline JIT:
  57 #
  58 #  q0  =&gt; ft0, fa0, fr
  59 #  q1  =&gt; ft1, fa1
  60 #  q2  =&gt; ft2, fa2
  61 #  q3  =&gt; ft3, fa3
  62 #  q4  =&gt; ft4          (unused in baseline)
  63 #  q5  =&gt; ft5          (unused in baseline)
  64 #  q8  =&gt; csfr0        (Only the lower 64 bits)
  65 #  q9  =&gt; csfr1        (Only the lower 64 bits)
  66 # q10  =&gt; csfr2        (Only the lower 64 bits)
  67 # q11  =&gt; csfr3        (Only the lower 64 bits)
  68 # q12  =&gt; csfr4        (Only the lower 64 bits)
  69 # q13  =&gt; csfr5        (Only the lower 64 bits)
  70 # q14  =&gt; csfr6        (Only the lower 64 bits)
  71 # q15  =&gt; csfr7        (Only the lower 64 bits)
  72 # q31  =&gt; scratch
  73 
  74 def arm64GPRName(name, kind)
  75     raise &quot;bad GPR name #{name}&quot; unless name =~ /^x/
  76     number = name[1..-1]
  77     case kind
  78     when :word
  79         &quot;w&quot; + number
  80     when :ptr
  81         prefix = $currentSettings[&quot;ADDRESS64&quot;] ? &quot;x&quot; : &quot;w&quot;
  82         prefix + number
  83     when :quad
  84         &quot;x&quot; + number
  85     else
  86         raise &quot;Wrong kind: #{kind}&quot;
  87     end
  88 end
  89 
  90 def arm64FPRName(name, kind)

  91     raise &quot;bad FPR name #{name}&quot; unless name =~ /^q/
<span class="line-modified">  92     case kind</span>
<span class="line-added">  93     when :double</span>
<span class="line-added">  94         &quot;d&quot; + name[1..-1]</span>
<span class="line-added">  95     when :float</span>
<span class="line-added">  96         &quot;s&quot; + name[1..-1]</span>
<span class="line-added">  97     when :vector</span>
<span class="line-added">  98         &quot;v&quot; + name[1..-1]</span>
<span class="line-added">  99     else</span>
<span class="line-added"> 100         raise &quot;bad FPR kind #{kind}&quot;</span>
<span class="line-added"> 101     end</span>
 102 end
 103 
 104 class SpecialRegister
 105     def arm64Operand(kind)
 106         case @name
 107         when /^x/
 108             arm64GPRName(@name, kind)
 109         when /^q/
 110             arm64FPRName(@name, kind)
 111         else
 112             raise &quot;Bad name: #{@name}&quot;
 113         end
 114     end
 115 end
 116 
 117 ARM64_EXTRA_GPRS = [SpecialRegister.new(&quot;x16&quot;), SpecialRegister.new(&quot;x17&quot;), SpecialRegister.new(&quot;x13&quot;)]
 118 ARM64_EXTRA_FPRS = [SpecialRegister.new(&quot;q31&quot;)]
 119 
 120 class RegisterID
 121     def arm64Operand(kind)
 122         case @name
<span class="line-modified"> 123         when &#39;t0&#39;, &#39;a0&#39;, &#39;r0&#39;, &#39;wa0&#39;</span>
 124             arm64GPRName(&#39;x0&#39;, kind)
<span class="line-modified"> 125         when &#39;t1&#39;, &#39;a1&#39;, &#39;r1&#39;, &#39;wa1&#39;</span>
 126             arm64GPRName(&#39;x1&#39;, kind)
<span class="line-modified"> 127         when &#39;t2&#39;, &#39;a2&#39;, &#39;wa2&#39;</span>
 128             arm64GPRName(&#39;x2&#39;, kind)
<span class="line-modified"> 129         when &#39;t3&#39;, &#39;a3&#39;, &#39;wa3&#39;</span>
 130             arm64GPRName(&#39;x3&#39;, kind)
<span class="line-modified"> 131         when &#39;t4&#39;, &#39;wa4&#39;</span>
 132             arm64GPRName(&#39;x4&#39;, kind)
<span class="line-modified"> 133         when &#39;t5&#39;, &#39;wa5&#39;</span>
 134           arm64GPRName(&#39;x5&#39;, kind)
<span class="line-modified"> 135         when &#39;t6&#39;, &#39;wa6&#39;</span>
 136           arm64GPRName(&#39;x6&#39;, kind)
<span class="line-modified"> 137         when &#39;t7&#39;, &#39;wa7&#39;</span>
 138           arm64GPRName(&#39;x7&#39;, kind)
<span class="line-added"> 139         when &#39;ws0&#39;</span>
<span class="line-added"> 140           arm64GPRName(&#39;x9&#39;, kind)</span>
<span class="line-added"> 141         when &#39;ws1&#39;</span>
<span class="line-added"> 142           arm64GPRName(&#39;x10&#39;, kind)</span>
 143         when &#39;cfr&#39;
 144             arm64GPRName(&#39;x29&#39;, kind)
 145         when &#39;csr0&#39;
 146             arm64GPRName(&#39;x19&#39;, kind)
 147         when &#39;csr1&#39;
 148             arm64GPRName(&#39;x20&#39;, kind)
 149         when &#39;csr2&#39;
 150             arm64GPRName(&#39;x21&#39;, kind)
 151         when &#39;csr3&#39;
 152             arm64GPRName(&#39;x22&#39;, kind)
 153         when &#39;csr4&#39;
 154             arm64GPRName(&#39;x23&#39;, kind)
 155         when &#39;csr5&#39;
 156             arm64GPRName(&#39;x24&#39;, kind)
 157         when &#39;csr6&#39;
 158             arm64GPRName(&#39;x25&#39;, kind)
 159         when &#39;csr7&#39;
 160             arm64GPRName(&#39;x26&#39;, kind)
 161         when &#39;csr8&#39;
 162             arm64GPRName(&#39;x27&#39;, kind)
 163         when &#39;csr9&#39;
 164             arm64GPRName(&#39;x28&#39;, kind)
 165         when &#39;sp&#39;
 166             &#39;sp&#39;
 167         when &#39;lr&#39;
 168             &#39;x30&#39;
 169         else
 170             raise &quot;Bad register name #{@name} at #{codeOriginString}&quot;
 171         end
 172     end
 173 end
 174 
 175 class FPRegisterID
 176     def arm64Operand(kind)
 177         case @name
<span class="line-modified"> 178         when &#39;ft0&#39;, &#39;fr&#39;, &#39;fa0&#39;, &#39;wfa0&#39;</span>
 179             arm64FPRName(&#39;q0&#39;, kind)
<span class="line-modified"> 180         when &#39;ft1&#39;, &#39;fa1&#39;, &#39;wfa1&#39;</span>
 181             arm64FPRName(&#39;q1&#39;, kind)
<span class="line-modified"> 182         when &#39;ft2&#39;, &#39;fa2&#39;, &#39;wfa2&#39;</span>
 183             arm64FPRName(&#39;q2&#39;, kind)
<span class="line-modified"> 184         when &#39;ft3&#39;, &#39;fa3&#39;, &#39;wfa3&#39;</span>
 185             arm64FPRName(&#39;q3&#39;, kind)
<span class="line-modified"> 186         when &#39;ft4&#39;, &#39;wfa4&#39;</span>
 187             arm64FPRName(&#39;q4&#39;, kind)
<span class="line-modified"> 188         when &#39;ft5&#39;, &#39;wfa5&#39;</span>
 189             arm64FPRName(&#39;q5&#39;, kind)
<span class="line-added"> 190         when &#39;wfa6&#39;</span>
<span class="line-added"> 191             arm64FPRName(&#39;q6&#39;, kind)</span>
<span class="line-added"> 192         when &#39;wfa7&#39;</span>
<span class="line-added"> 193             arm64FPRName(&#39;q7&#39;, kind)</span>
 194         when &#39;csfr0&#39;
 195             arm64FPRName(&#39;q8&#39;, kind)
 196         when &#39;csfr1&#39;
 197             arm64FPRName(&#39;q9&#39;, kind)
 198         when &#39;csfr2&#39;
 199             arm64FPRName(&#39;q10&#39;, kind)
 200         when &#39;csfr3&#39;
 201             arm64FPRName(&#39;q11&#39;, kind)
 202         when &#39;csfr4&#39;
 203             arm64FPRName(&#39;q12&#39;, kind)
 204         when &#39;csfr5&#39;
 205             arm64FPRName(&#39;q13&#39;, kind)
 206         when &#39;csfr6&#39;
 207             arm64FPRName(&#39;q14&#39;, kind)
 208         when &#39;csfr7&#39;
 209             arm64FPRName(&#39;q15&#39;, kind)
 210         else &quot;Bad register name #{@name} at #{codeOriginString}&quot;
 211         end
 212     end
 213 end
 214 
 215 class Immediate
 216     def arm64Operand(kind)

 217         &quot;\##{value}&quot;
 218     end
 219 end
 220 
 221 class Address
 222     def arm64Operand(kind)
 223         raise &quot;Invalid offset #{offset.value} at #{codeOriginString}&quot; if offset.value &lt; -255 or offset.value &gt; 4095
 224         &quot;[#{base.arm64Operand(:quad)}, \##{offset.value}]&quot;
 225     end
 226     
 227     def arm64EmitLea(destination, kind)
 228         $asm.puts &quot;add #{destination.arm64Operand(kind)}, #{base.arm64Operand(kind)}, \##{offset.value}&quot;
 229     end
 230 end
 231 
 232 class BaseIndex
 233     def arm64Operand(kind)
 234         raise &quot;Invalid offset #{offset.value} at #{codeOriginString}&quot; if offset.value != 0
 235         &quot;[#{base.arm64Operand(:quad)}, #{index.arm64Operand(:quad)}, lsl \##{scaleShift}]&quot;
 236     end
</pre>
<hr />
<pre>
 376         end
 377         newList &lt;&lt; node
 378     }
 379     newList
 380 end
 381 
 382 class Sequence
 383     def getModifiedListARM64(result = @list)
 384         result = riscLowerNot(result)
 385         result = riscLowerSimpleBranchOps(result)
 386 
 387         result = $currentSettings[&quot;ADDRESS64&quot;] ? riscLowerHardBranchOps64(result) : riscLowerHardBranchOps(result)
 388         result = riscLowerShiftOps(result)
 389         result = arm64LowerMalformedLoadStoreAddresses(result)
 390         result = arm64LowerLabelReferences(result)
 391         result = riscLowerMalformedAddresses(result) {
 392             | node, address |
 393             case node.opcode
 394             when &quot;loadb&quot;, &quot;loadbsi&quot;, &quot;loadbsq&quot;, &quot;storeb&quot;, /^bb/, /^btb/, /^cb/, /^tb/
 395                 size = 1
<span class="line-modified"> 396             when &quot;loadh&quot;, &quot;loadhsi&quot;, &quot;loadhsq&quot;, &quot;orh&quot;, &quot;storeh&quot;</span>
 397                 size = 2
 398             when &quot;loadi&quot;, &quot;loadis&quot;, &quot;storei&quot;, &quot;addi&quot;, &quot;andi&quot;, &quot;lshifti&quot;, &quot;muli&quot;, &quot;negi&quot;,
 399                 &quot;noti&quot;, &quot;ori&quot;, &quot;rshifti&quot;, &quot;urshifti&quot;, &quot;subi&quot;, &quot;xori&quot;, /^bi/, /^bti/,
<span class="line-modified"> 400                 /^ci/, /^ti/, &quot;addis&quot;, &quot;subis&quot;, &quot;mulis&quot;, &quot;smulli&quot;, &quot;leai&quot;, &quot;loadf&quot;, &quot;storef&quot;</span>
 401                 size = 4
 402             when &quot;loadp&quot;, &quot;storep&quot;, &quot;loadq&quot;, &quot;storeq&quot;, &quot;loadd&quot;, &quot;stored&quot;, &quot;lshiftp&quot;, &quot;lshiftq&quot;, &quot;negp&quot;, &quot;negq&quot;, &quot;rshiftp&quot;, &quot;rshiftq&quot;,
 403                 &quot;urshiftp&quot;, &quot;urshiftq&quot;, &quot;addp&quot;, &quot;addq&quot;, &quot;mulp&quot;, &quot;mulq&quot;, &quot;andp&quot;, &quot;andq&quot;, &quot;orp&quot;, &quot;orq&quot;, &quot;subp&quot;, &quot;subq&quot;, &quot;xorp&quot;, &quot;xorq&quot;, &quot;addd&quot;,
 404                 &quot;divd&quot;, &quot;subd&quot;, &quot;muld&quot;, &quot;sqrtd&quot;, /^bp/, /^bq/, /^btp/, /^btq/, /^cp/, /^cq/, /^tp/, /^tq/, /^bd/,
 405                 &quot;jmp&quot;, &quot;call&quot;, &quot;leap&quot;, &quot;leaq&quot;
 406                 size = $currentSettings[&quot;ADDRESS64&quot;] ? 8 : 4
 407             else
 408                 raise &quot;Bad instruction #{node.opcode} for heap access at #{node.codeOriginString}: #{node.dump}&quot;
 409             end
 410             
 411             if address.is_a? BaseIndex
 412                 address.offset.value == 0 and
 413                     (node.opcode =~ /^lea/ or address.scale == 1 or address.scale == size)
 414             elsif address.is_a? Address
 415                 (-255..4095).include? address.offset.value
 416             else
 417                 false
 418             end
 419         }
<span class="line-modified"> 420 </span>
<span class="line-modified"> 421         result = riscLowerMisplacedImmediates(result, [&quot;storeb&quot;, &quot;storeh&quot;, &quot;storei&quot;, &quot;storep&quot;, &quot;storeq&quot;])</span>
<span class="line-added"> 422 </span>
<span class="line-added"> 423         # The rules for which immediates are valid for and/or/xor instructions are fairly involved, see https://dinfuehr.github.io/blog/encoding-of-immediate-values-on-aarch64/</span>
<span class="line-added"> 424         validLogicalImmediates = []</span>
<span class="line-added"> 425         def rotate(value, n, size)</span>
<span class="line-added"> 426             mask = (1 &lt;&lt; size) - 1</span>
<span class="line-added"> 427             shiftedValue = value &lt;&lt; n</span>
<span class="line-added"> 428             result = (shiftedValue &amp; mask) | ((shiftedValue &amp; ~mask) &gt;&gt; size)</span>
<span class="line-added"> 429             return result</span>
<span class="line-added"> 430         end</span>
<span class="line-added"> 431         def replicate(value, size)</span>
<span class="line-added"> 432             until size == 64 do</span>
<span class="line-added"> 433                 value = value | (value &lt;&lt; size)</span>
<span class="line-added"> 434                 size *= 2</span>
<span class="line-added"> 435             end</span>
<span class="line-added"> 436             return value</span>
<span class="line-added"> 437         end</span>
<span class="line-added"> 438         size = 2</span>
<span class="line-added"> 439         until size &gt; 64 do</span>
<span class="line-added"> 440             for numberOfOnes in 1..(size-1) do</span>
<span class="line-added"> 441                 for rotation in 0..(size-1) do</span>
<span class="line-added"> 442                     immediate = 0;</span>
<span class="line-added"> 443                     for i in 0..(numberOfOnes-1) do</span>
<span class="line-added"> 444                         immediate = immediate*2 + 1</span>
<span class="line-added"> 445                     end</span>
<span class="line-added"> 446                     immediate = rotate(immediate, rotation, size)</span>
<span class="line-added"> 447                     immediate = replicate(immediate, size)</span>
<span class="line-added"> 448                     validLogicalImmediates &lt;&lt; immediate</span>
<span class="line-added"> 449                 end</span>
<span class="line-added"> 450             end</span>
<span class="line-added"> 451             size *= 2</span>
<span class="line-added"> 452         end</span>
<span class="line-added"> 453         result = riscLowerMalformedImmediates(result, 0..4095, validLogicalImmediates)</span>
<span class="line-added"> 454 </span>
 455         result = riscLowerMisplacedAddresses(result)
 456         result = riscLowerMalformedAddresses(result) {
 457             | node, address |
 458             case node.opcode
 459             when /^load/
 460                 true
 461             when /^store/
 462                 not (address.is_a? Address and address.offset.value &lt; 0)
 463             when /^lea/
 464                 true
 465             else
 466                 raise &quot;Bad instruction #{node.opcode} for heap access at #{node.codeOriginString}&quot;
 467             end
 468         }
 469         result = riscLowerTest(result)
 470         result = arm64FixSpecialRegisterArithmeticMode(result)
 471         result = assignRegistersToTemporaries(result, :gpr, ARM64_EXTRA_GPRS)
 472         result = assignRegistersToTemporaries(result, :fpr, ARM64_EXTRA_FPRS)
 473         result = arm64CortexA53Fix835769(result)
 474         return result
</pre>
<hr />
<pre>
 562         end
 563     end
 564 
 565     if operands.size == 2
 566         if operands[0].immediate? and operands[0].value == 0 and opcode !~ /s$/
 567             return
 568         end
 569     end
 570 
 571     emitARM64TAC(opcode, operands, kind)
 572 end
 573 
 574 def emitARM64Unflipped(opcode, operands, kind)
 575     $asm.puts &quot;#{opcode} #{arm64Operands(operands, kind)}&quot;
 576 end
 577 
 578 def emitARM64TAC(opcode, operands, kind)
 579     $asm.puts &quot;#{opcode} #{arm64TACOperands(operands, kind)}&quot;
 580 end
 581 
<span class="line-added"> 582 def emitARM64Div(opcode, operands, kind)</span>
<span class="line-added"> 583     if operands.size == 2</span>
<span class="line-added"> 584         operands = [operands[1], operands[1], operands[0]]</span>
<span class="line-added"> 585     elsif operands.size == 3</span>
<span class="line-added"> 586         operands = [operands[2], operands[1], operands[0]]</span>
<span class="line-added"> 587     else</span>
<span class="line-added"> 588         raise</span>
<span class="line-added"> 589     end</span>
<span class="line-added"> 590     $asm.puts &quot;#{opcode} #{arm64Operands(operands, kind)}&quot;</span>
<span class="line-added"> 591 end</span>
<span class="line-added"> 592 </span>
<span class="line-added"> 593 def emitARM64TACWithOperandSuffix(opcode, operands, kind)</span>
<span class="line-added"> 594     raise unless [:float, :double].include? kind</span>
<span class="line-added"> 595     size = kind == :float ? 8 : 16</span>
<span class="line-added"> 596     operands = operands.map { |operand|</span>
<span class="line-added"> 597         raise unless operand.is_a? FPRegisterID</span>
<span class="line-added"> 598         &quot;#{operand.arm64Operand(:vector)}.#{size}b&quot;</span>
<span class="line-added"> 599     }</span>
<span class="line-added"> 600     if operands.length == 2</span>
<span class="line-added"> 601       operands = [operands[1], operands[1], operands[0]]</span>
<span class="line-added"> 602     else</span>
<span class="line-added"> 603       raise unless operands.length == 3</span>
<span class="line-added"> 604       operands = [operands[2], operands[0], operands[1]]</span>
<span class="line-added"> 605     end</span>
<span class="line-added"> 606     $asm.puts &quot;#{opcode} #{operands.join(&quot;, &quot;)}&quot;</span>
<span class="line-added"> 607 end</span>
<span class="line-added"> 608 </span>
 609 def emitARM64(opcode, operands, kind)
 610     $asm.puts &quot;#{opcode} #{arm64FlippedOperands(operands, kind)}&quot;
 611 end
 612 
 613 def emitARM64Access(opcode, opcodeNegativeOffset, register, memory, kind)
 614     if memory.is_a? Address and memory.offset.value &lt; 0
 615         raise unless -256 &lt;= memory.offset.value
 616         $asm.puts &quot;#{opcodeNegativeOffset} #{register.arm64Operand(kind)}, #{memory.arm64Operand(kind)}&quot;
 617         return
 618     end
 619 
 620     $asm.puts &quot;#{opcode} #{register.arm64Operand(kind)}, #{memory.arm64Operand(kind)}&quot;
 621 end
 622 
 623 def emitARM64Shift(opcodeRegs, opcodeImmediate, operands, kind)
 624     if operands.size == 3 and operands[1].immediate?
 625         magicNumbers = yield operands[1].value
 626         $asm.puts &quot;#{opcodeImmediate} #{operands[2].arm64Operand(kind)}, #{operands[0].arm64Operand(kind)}, \##{magicNumbers[0]}, \##{magicNumbers[1]}&quot;
 627         return
 628     end
</pre>
<hr />
<pre>
 639 def emitARM64LShift(operands, kind)
 640     emitARM64Shift(&quot;lslv&quot;, &quot;ubfm&quot;, operands, kind) {
 641         | value |
 642         case kind
 643         when :word
 644             [32 - value, 31 - value]
 645         when :ptr
 646             bitSize = $currentSettings[&quot;ADDRESS64&quot;] ? 64 : 32
 647             [bitSize - value, bitSize - 1 - value]
 648         when :quad
 649             [64 - value, 63 - value]
 650         end
 651     }
 652 end
 653 
 654 def emitARM64Branch(opcode, operands, kind, branchOpcode)
 655     emitARM64Unflipped(opcode, operands[0..-2], kind)
 656     $asm.puts &quot;#{branchOpcode} #{operands[-1].asmLabel}&quot;
 657 end
 658 
<span class="line-added"> 659 def emitARM64CompareFP(operands, kind, compareCode)</span>
<span class="line-added"> 660     emitARM64Unflipped(&quot;fcmp&quot;, operands[0..-2], kind)</span>
<span class="line-added"> 661     $asm.puts &quot;cset #{operands[-1].arm64Operand(:word)}, #{compareCode}&quot;</span>
<span class="line-added"> 662 end</span>
<span class="line-added"> 663 </span>
 664 def emitARM64Compare(operands, kind, compareCode)
 665     emitARM64Unflipped(&quot;subs #{arm64GPRName(&#39;xzr&#39;, kind)}, &quot;, operands[0..-2], kind)
 666     $asm.puts &quot;csinc #{operands[-1].arm64Operand(:word)}, wzr, wzr, #{compareCode}&quot;
 667 end
 668 
 669 def emitARM64MoveImmediate(value, target)
 670     first = true
 671     isNegative = value &lt; 0
 672     [48, 32, 16, 0].each {
 673         | shift |
 674         currentValue = (value &gt;&gt; shift) &amp; 0xffff
 675         next if currentValue == (isNegative ? 0xffff : 0) and (shift != 0 or !first)
 676         if first
 677             if isNegative
 678                 $asm.puts &quot;movn #{target.arm64Operand(:quad)}, \##{(~currentValue) &amp; 0xffff}, lsl \##{shift}&quot;
 679             else
 680                 $asm.puts &quot;movz #{target.arm64Operand(:quad)}, \##{currentValue}, lsl \##{shift}&quot;
 681             end
 682             first = false
 683         else
</pre>
<hr />
<pre>
 694         when &#39;addis&#39;
 695             emitARM64Add(&quot;adds&quot;, operands, :word)
 696         when &#39;addp&#39;
 697             emitARM64Add(&quot;add&quot;, operands, :ptr)
 698         when &#39;addps&#39;
 699             emitARM64Add(&quot;adds&quot;, operands, :ptr)
 700         when &#39;addq&#39;
 701             emitARM64Add(&quot;add&quot;, operands, :quad)
 702         when &quot;andi&quot;
 703             emitARM64TAC(&quot;and&quot;, operands, :word)
 704         when &quot;andp&quot;
 705             emitARM64TAC(&quot;and&quot;, operands, :ptr)
 706         when &quot;andq&quot;
 707             emitARM64TAC(&quot;and&quot;, operands, :quad)
 708         when &quot;ori&quot;
 709             emitARM64TAC(&quot;orr&quot;, operands, :word)
 710         when &quot;orp&quot;
 711             emitARM64TAC(&quot;orr&quot;, operands, :ptr)
 712         when &quot;orq&quot;
 713             emitARM64TAC(&quot;orr&quot;, operands, :quad)
<span class="line-added"> 714         when &quot;orh&quot;</span>
<span class="line-added"> 715             emitARM64TAC(&quot;orr&quot;, operands, :word) # not :half because 16-bit registers don&#39;t exist on ARM.</span>
 716         when &quot;xori&quot;
 717             emitARM64TAC(&quot;eor&quot;, operands, :word)
 718         when &quot;xorp&quot;
 719             emitARM64TAC(&quot;eor&quot;, operands, :ptr)
 720         when &quot;xorq&quot;
 721             emitARM64TAC(&quot;eor&quot;, operands, :quad)
<span class="line-added"> 722         when &#39;divi&#39;</span>
<span class="line-added"> 723             emitARM64Div(&quot;udiv&quot;, operands, :word)</span>
<span class="line-added"> 724         when &#39;divis&#39;</span>
<span class="line-added"> 725             emitARM64Div(&quot;sdiv&quot;, operands, :word)</span>
<span class="line-added"> 726         when &#39;divq&#39;</span>
<span class="line-added"> 727             emitARM64Div(&quot;udiv&quot;, operands, :quad)</span>
<span class="line-added"> 728         when &#39;divqs&#39;</span>
<span class="line-added"> 729             emitARM64Div(&quot;sdiv&quot;, operands, :quad)</span>
 730         when &quot;lshifti&quot;
 731             emitARM64LShift(operands, :word)
 732         when &quot;lshiftp&quot;
 733             emitARM64LShift(operands, :ptr)
 734         when &quot;lshiftq&quot;
 735             emitARM64LShift(operands, :quad)
 736         when &quot;rshifti&quot;
 737             emitARM64Shift(&quot;asrv&quot;, &quot;sbfm&quot;, operands, :word) {
 738                 | value |
 739                 [value, 31]
 740             }
 741         when &quot;rshiftp&quot;
 742             emitARM64Shift(&quot;asrv&quot;, &quot;sbfm&quot;, operands, :ptr) {
 743                 | value |
 744                 bitSize = $currentSettings[&quot;ADDRESS64&quot;] ? 64 : 32
 745                 [value, bitSize - 1]
 746             }
 747         when &quot;rshiftq&quot;
 748             emitARM64Shift(&quot;asrv&quot;, &quot;sbfm&quot;, operands, :quad) {
 749                 | value |
</pre>
<hr />
<pre>
 812         when &quot;loadhsi&quot;
 813             emitARM64Access(&quot;ldrsh&quot;, &quot;ldursh&quot;, operands[1], operands[0], :word)
 814         when &quot;loadhsq&quot;
 815             emitARM64Access(&quot;ldrsh&quot;, &quot;ldursh&quot;, operands[1], operands[0], :quad)
 816         when &quot;storeh&quot;
 817             emitARM64Unflipped(&quot;strh&quot;, operands, :word)
 818         when &quot;loadd&quot;
 819             emitARM64Access(&quot;ldr&quot;, &quot;ldur&quot;, operands[1], operands[0], :double)
 820         when &quot;stored&quot;
 821             emitARM64Unflipped(&quot;str&quot;, operands, :double)
 822         when &quot;addd&quot;
 823             emitARM64TAC(&quot;fadd&quot;, operands, :double)
 824         when &quot;divd&quot;
 825             emitARM64TAC(&quot;fdiv&quot;, operands, :double)
 826         when &quot;subd&quot;
 827             emitARM64TAC(&quot;fsub&quot;, operands, :double)
 828         when &quot;muld&quot;
 829             emitARM64TAC(&quot;fmul&quot;, operands, :double)
 830         when &quot;sqrtd&quot;
 831             emitARM64(&quot;fsqrt&quot;, operands, :double)


 832         when &quot;bdeq&quot;
 833             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.eq&quot;)
 834         when &quot;bdneq&quot;
 835             emitARM64Unflipped(&quot;fcmp&quot;, operands[0..1], :double)
 836             isUnordered = LocalLabel.unique(&quot;bdneq&quot;)
 837             $asm.puts &quot;b.vs #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
 838             $asm.puts &quot;b.ne #{operands[2].asmLabel}&quot;
<span class="line-modified"> 839             isUnordered.lower($activeBackend)</span>
 840         when &quot;bdgt&quot;
 841             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.gt&quot;)
 842         when &quot;bdgteq&quot;
 843             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.ge&quot;)
 844         when &quot;bdlt&quot;
 845             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.mi&quot;)
 846         when &quot;bdlteq&quot;
 847             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.ls&quot;)
 848         when &quot;bdequn&quot;
 849             emitARM64Unflipped(&quot;fcmp&quot;, operands[0..1], :double)
 850             $asm.puts &quot;b.vs #{operands[2].asmLabel}&quot;
 851             $asm.puts &quot;b.eq #{operands[2].asmLabel}&quot;
 852         when &quot;bdnequn&quot;
 853             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.ne&quot;)
 854         when &quot;bdgtun&quot;
 855             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.hi&quot;)
 856         when &quot;bdgtequn&quot;
 857             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.pl&quot;)
 858         when &quot;bdltun&quot;
 859             emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.lt&quot;)
</pre>
<hr />
<pre>
 880                 # on platforms that only push/pop one slot at a time they pop their 
 881                 # arguments in the reverse order that they were pushed. In order to remain 
 882                 # compatible with those platforms we assume here that that&#39;s what has been done.
 883 
 884                 # So for example, if we did push(A, B, C, D), we would then pop(D, C, B, A).
 885                 # But since the ordering of arguments doesn&#39;t change on arm64 between the stp and ldp 
 886                 # instructions we need to flip flop the argument positions that were passed to us.
 887                 $asm.puts &quot;ldp #{ops[1].arm64Operand(:quad)}, #{ops[0].arm64Operand(:quad)}, [sp], #16&quot;
 888             }
 889         when &quot;push&quot;
 890             operands.each_slice(2) {
 891                 | ops |
 892                 $asm.puts &quot;stp #{ops[0].arm64Operand(:quad)}, #{ops[1].arm64Operand(:quad)}, [sp, #-16]!&quot;
 893             }
 894         when &quot;move&quot;
 895             if operands[0].immediate?
 896                 emitARM64MoveImmediate(operands[0].value, operands[1])
 897             else
 898                 emitARM64(&quot;mov&quot;, operands, :quad)
 899             end
<span class="line-added"> 900         when &quot;moved&quot;</span>
<span class="line-added"> 901             emitARM64(&quot;fmov&quot;, operands, :double)</span>
 902         when &quot;sxi2p&quot;
 903             emitARM64(&quot;sxtw&quot;, operands, [:word, :ptr])
 904         when &quot;sxi2q&quot;
 905             emitARM64(&quot;sxtw&quot;, operands, [:word, :quad])
 906         when &quot;zxi2p&quot;
 907             emitARM64(&quot;uxtw&quot;, operands, [:word, :ptr])
 908         when &quot;zxi2q&quot;
 909             emitARM64(&quot;uxtw&quot;, operands, [:word, :quad])
 910         when &quot;nop&quot;
 911             $asm.puts &quot;nop&quot;
 912         when &quot;bieq&quot;, &quot;bbeq&quot;
 913             if operands[0].immediate? and operands[0].value == 0
 914                 $asm.puts &quot;cbz #{operands[1].arm64Operand(:word)}, #{operands[2].asmLabel}&quot;
 915             elsif operands[1].immediate? and operands[1].value == 0
 916                 $asm.puts &quot;cbz #{operands[0].arm64Operand(:word)}, #{operands[2].asmLabel}&quot;
 917             else
 918                 emitARM64Branch(&quot;subs wzr, &quot;, operands, :word, &quot;b.eq&quot;)
 919             end
 920         when &quot;bpeq&quot;
 921             if operands[0].immediate? and operands[0].value == 0
</pre>
<hr />
<pre>
1129             $asm.puts &quot;adrp #{operands[1].arm64Operand(:quad)}, #{operands[0].asmLabel}@GOTPAGE&quot;
1130             $asm.puts &quot;L_offlineasm_loh_ldr_#{uid}:&quot;
1131             $asm.puts &quot;ldr #{operands[1].arm64Operand(:quad)}, [#{operands[1].arm64Operand(:quad)}, #{operands[0].asmLabel}@GOTPAGEOFF]&quot;
1132 
1133             # On Linux, use ELF GOT relocation specifiers.
1134             $asm.putStr(&quot;#elif OS(LINUX)&quot;)
1135             $asm.puts &quot;adrp #{operands[1].arm64Operand(:quad)}, :got:#{operands[0].asmLabel}&quot;
1136             $asm.puts &quot;ldr #{operands[1].arm64Operand(:quad)}, [#{operands[1].arm64Operand(:quad)}, :got_lo12:#{operands[0].asmLabel}]&quot;
1137 
1138             # Throw a compiler error everywhere else.
1139             $asm.putStr(&quot;#else&quot;)
1140             $asm.putStr(&quot;#error Missing globaladdr implementation&quot;)
1141             $asm.putStr(&quot;#endif&quot;)
1142 
1143             $asm.deferAction {
1144                 # On Darwin, also include the .loh directive using the generated labels.
1145                 $asm.putStr(&quot;#if OS(DARWIN)&quot;)
1146                 $asm.puts &quot;.loh AdrpLdrGot L_offlineasm_loh_adrp_#{uid}, L_offlineasm_loh_ldr_#{uid}&quot;
1147                 $asm.putStr(&quot;#endif&quot;)
1148             }
<span class="line-added">1149 </span>
<span class="line-added">1150         when &quot;andf&quot;, &quot;andd&quot;</span>
<span class="line-added">1151             emitARM64TACWithOperandSuffix(&quot;and&quot;, operands, :double)</span>
<span class="line-added">1152         when &quot;orf&quot;, &quot;ord&quot;</span>
<span class="line-added">1153             emitARM64TACWithOperandSuffix(&quot;orr&quot;, operands, :double)</span>
<span class="line-added">1154         when &quot;lrotatei&quot;</span>
<span class="line-added">1155             tmp = Tmp.new(codeOrigin, :gpr)</span>
<span class="line-added">1156             Sequence.new(codeOrigin, [</span>
<span class="line-added">1157                 Instruction.new(codeOrigin, &quot;move&quot;, [operands[0], tmp]),</span>
<span class="line-added">1158                 Instruction.new(codeOrigin, &quot;negq&quot;, [tmp]),</span>
<span class="line-added">1159                 Instruction.new(codeOrigin, &quot;rrotatei&quot;, [tmp, operands[1]]),</span>
<span class="line-added">1160             ]).lower($activeBackend)</span>
<span class="line-added">1161         when &quot;lrotateq&quot;</span>
<span class="line-added">1162             tmp = Tmp.new(codeOrigin, :gpr)</span>
<span class="line-added">1163             Sequence.new(codeOrigin, [</span>
<span class="line-added">1164                 Instruction.new(codeOrigin, &quot;move&quot;, [operands[0], tmp]),</span>
<span class="line-added">1165                 Instruction.new(codeOrigin, &quot;negq&quot;, [tmp]),</span>
<span class="line-added">1166                 Instruction.new(codeOrigin, &quot;rrotateq&quot;, [tmp, operands[1]]),</span>
<span class="line-added">1167             ]).lower($activeBackend)</span>
<span class="line-added">1168         when &quot;rrotatei&quot;</span>
<span class="line-added">1169             emitARM64TAC(&quot;ror&quot;, operands, :word)</span>
<span class="line-added">1170         when &quot;rrotateq&quot;</span>
<span class="line-added">1171             emitARM64TAC(&quot;ror&quot;, operands, :quad)</span>
<span class="line-added">1172         when &quot;loadf&quot;</span>
<span class="line-added">1173             emitARM64Access(&quot;ldr&quot;, &quot;ldur&quot;, operands[1], operands[0], :float)</span>
<span class="line-added">1174         when &quot;storef&quot;</span>
<span class="line-added">1175             emitARM64Unflipped(&quot;str&quot;, operands, :float)</span>
<span class="line-added">1176         when &quot;addf&quot;</span>
<span class="line-added">1177             emitARM64TAC(&quot;fadd&quot;, operands, :float)</span>
<span class="line-added">1178         when &quot;divf&quot;</span>
<span class="line-added">1179             emitARM64TAC(&quot;fdiv&quot;, operands, :float)</span>
<span class="line-added">1180         when &quot;subf&quot;</span>
<span class="line-added">1181             emitARM64TAC(&quot;fsub&quot;, operands, :float)</span>
<span class="line-added">1182         when &quot;mulf&quot;</span>
<span class="line-added">1183             emitARM64TAC(&quot;fmul&quot;, operands, :float)</span>
<span class="line-added">1184         when &quot;sqrtf&quot;</span>
<span class="line-added">1185             emitARM64(&quot;fsqrt&quot;, operands, :float)</span>
<span class="line-added">1186         when &quot;floorf&quot;</span>
<span class="line-added">1187             emitARM64(&quot;frintm&quot;, operands, :float)</span>
<span class="line-added">1188         when &quot;floord&quot;</span>
<span class="line-added">1189             emitARM64(&quot;frintm&quot;, operands, :double)</span>
<span class="line-added">1190         when &quot;roundf&quot;</span>
<span class="line-added">1191             emitARM64(&quot;frintn&quot;, operands, :float)</span>
<span class="line-added">1192         when &quot;roundd&quot;</span>
<span class="line-added">1193             emitARM64(&quot;frintn&quot;, operands, :double)</span>
<span class="line-added">1194         when &quot;truncatef&quot;</span>
<span class="line-added">1195             emitARM64(&quot;frintz&quot;, operands, :float)</span>
<span class="line-added">1196         when &quot;truncated&quot;</span>
<span class="line-added">1197             emitARM64(&quot;frintz&quot;, operands, :double)</span>
<span class="line-added">1198         when &quot;truncatef2i&quot;</span>
<span class="line-added">1199             emitARM64(&quot;fcvtzu&quot;, operands, [:float, :word])</span>
<span class="line-added">1200         when &quot;truncatef2q&quot;</span>
<span class="line-added">1201             emitARM64(&quot;fcvtzu&quot;, operands, [:float, :quad])</span>
<span class="line-added">1202         when &quot;truncated2q&quot;</span>
<span class="line-added">1203             emitARM64(&quot;fcvtzu&quot;, operands, [:double, :quad])</span>
<span class="line-added">1204         when &quot;truncated2i&quot;</span>
<span class="line-added">1205             emitARM64(&quot;fcvtzu&quot;, operands, [:double, :word])</span>
<span class="line-added">1206         when &quot;truncatef2is&quot;</span>
<span class="line-added">1207             emitARM64(&quot;fcvtzs&quot;, operands, [:float, :word])</span>
<span class="line-added">1208         when &quot;truncated2is&quot;</span>
<span class="line-added">1209             emitARM64(&quot;fcvtzs&quot;, operands, [:double, :word])</span>
<span class="line-added">1210         when &quot;truncatef2qs&quot;</span>
<span class="line-added">1211             emitARM64(&quot;fcvtzs&quot;, operands, [:float, :quad])</span>
<span class="line-added">1212         when &quot;truncated2qs&quot;</span>
<span class="line-added">1213             emitARM64(&quot;fcvtzs&quot;, operands, [:double, :quad])</span>
<span class="line-added">1214         when &quot;ci2d&quot;</span>
<span class="line-added">1215             emitARM64(&quot;ucvtf&quot;, operands, [:word, :double])</span>
<span class="line-added">1216         when &quot;ci2ds&quot;</span>
<span class="line-added">1217             emitARM64(&quot;scvtf&quot;, operands, [:word, :double])</span>
<span class="line-added">1218         when &quot;ci2f&quot;</span>
<span class="line-added">1219             emitARM64(&quot;ucvtf&quot;, operands, [:word, :float])</span>
<span class="line-added">1220         when &quot;ci2fs&quot;</span>
<span class="line-added">1221             emitARM64(&quot;scvtf&quot;, operands, [:word, :float])</span>
<span class="line-added">1222         when &quot;cq2f&quot;</span>
<span class="line-added">1223             emitARM64(&quot;ucvtf&quot;, operands, [:quad, :float])</span>
<span class="line-added">1224         when &quot;cq2fs&quot;</span>
<span class="line-added">1225             emitARM64(&quot;scvtf&quot;, operands, [:quad, :float])</span>
<span class="line-added">1226         when &quot;cq2d&quot;</span>
<span class="line-added">1227             emitARM64(&quot;ucvtf&quot;, operands, [:quad, :double])</span>
<span class="line-added">1228         when &quot;cq2ds&quot;</span>
<span class="line-added">1229             emitARM64(&quot;scvtf&quot;, operands, [:quad, :double])</span>
<span class="line-added">1230         when &quot;cd2f&quot;</span>
<span class="line-added">1231             emitARM64(&quot;fcvt&quot;, operands, [:double, :float])</span>
<span class="line-added">1232         when &quot;cf2d&quot;</span>
<span class="line-added">1233             emitARM64(&quot;fcvt&quot;, operands, [:float, :double])</span>
<span class="line-added">1234         when &quot;bfeq&quot;</span>
<span class="line-added">1235             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.eq&quot;)</span>
<span class="line-added">1236         when &quot;bfgt&quot;</span>
<span class="line-added">1237             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.gt&quot;)</span>
<span class="line-added">1238         when &quot;bflt&quot;</span>
<span class="line-added">1239             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.mi&quot;)</span>
<span class="line-added">1240         when &quot;bfgtun&quot;</span>
<span class="line-added">1241             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.hi&quot;)</span>
<span class="line-added">1242         when &quot;bfgtequn&quot;</span>
<span class="line-added">1243             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.pl&quot;)</span>
<span class="line-added">1244         when &quot;bfltun&quot;</span>
<span class="line-added">1245             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.lt&quot;)</span>
<span class="line-added">1246         when &quot;bfltequn&quot;</span>
<span class="line-added">1247             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.le&quot;)</span>
<span class="line-added">1248         when &quot;tzcnti&quot;</span>
<span class="line-added">1249             emitARM64(&quot;rbit&quot;, operands, :word)</span>
<span class="line-added">1250             emitARM64(&quot;clz&quot;, [operands[1], operands[1]], :word)</span>
<span class="line-added">1251         when &quot;tzcntq&quot;</span>
<span class="line-added">1252             emitARM64(&quot;rbit&quot;, operands, :quad)</span>
<span class="line-added">1253             emitARM64(&quot;clz&quot;, [operands[1], operands[1]], :quad)</span>
<span class="line-added">1254         when &quot;lzcnti&quot;</span>
<span class="line-added">1255             emitARM64(&quot;clz&quot;, operands, :word)</span>
<span class="line-added">1256         when &quot;lzcntq&quot;</span>
<span class="line-added">1257             emitARM64(&quot;clz&quot;, operands, :quad)</span>
<span class="line-added">1258         when &quot;absf&quot;</span>
<span class="line-added">1259             emitARM64(&quot;fabs&quot;, operands, :float)</span>
<span class="line-added">1260         when &quot;absd&quot;</span>
<span class="line-added">1261             emitARM64(&quot;fabs&quot;, operands, :double)</span>
<span class="line-added">1262         when &quot;negf&quot;</span>
<span class="line-added">1263             emitARM64(&quot;fneg&quot;, operands, :float)</span>
<span class="line-added">1264         when &quot;negd&quot;</span>
<span class="line-added">1265             emitARM64(&quot;fneg&quot;, operands, :double)</span>
<span class="line-added">1266         when &quot;ceilf&quot;</span>
<span class="line-added">1267             emitARM64(&quot;frintp&quot;, operands, :float)</span>
<span class="line-added">1268         when &quot;ceild&quot;</span>
<span class="line-added">1269             emitARM64(&quot;frintp&quot;, operands, :double)</span>
<span class="line-added">1270         when &quot;cfeq&quot;</span>
<span class="line-added">1271             emitARM64CompareFP(operands, :float, &quot;eq&quot;)</span>
<span class="line-added">1272         when &quot;cdeq&quot;</span>
<span class="line-added">1273             emitARM64CompareFP(operands, :double, &quot;eq&quot;)</span>
<span class="line-added">1274         when &quot;cfneq&quot;</span>
<span class="line-added">1275             $asm.puts &quot;move $0, #{operands[2].arm64Operand(:word)}&quot;</span>
<span class="line-added">1276             emitARM64Unflipped(&quot;fcmp&quot;, operands[0..1], :float)</span>
<span class="line-added">1277             isUnordered = LocalLabel.unique(&quot;cdneq&quot;)</span>
<span class="line-added">1278             $asm.puts &quot;b.vs #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;</span>
<span class="line-added">1279             $asm.puts &quot;cset #{operands[2].arm64Operand(:word)}, ne&quot;</span>
<span class="line-added">1280             isUnordered.lower($activeBackend)</span>
<span class="line-added">1281         when &quot;cdneq&quot;</span>
<span class="line-added">1282             $asm.puts &quot;move $0, #{operands[2].arm64Operand(:word)}&quot;</span>
<span class="line-added">1283             emitARM64Unflipped(&quot;fcmp&quot;, operands[0..1], :double)</span>
<span class="line-added">1284             isUnordered = LocalLabel.unique(&quot;cdneq&quot;)</span>
<span class="line-added">1285             $asm.puts &quot;b.vs #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;</span>
<span class="line-added">1286             $asm.puts &quot;cset #{operands[2].arm64Operand(:word)}, ne&quot;</span>
<span class="line-added">1287             isUnordered.lower($activeBackend)</span>
<span class="line-added">1288         when &quot;cfnequn&quot;</span>
<span class="line-added">1289             emitARM64CompareFP(operands, :float, &quot;ne&quot;)</span>
<span class="line-added">1290         when &quot;cdnequn&quot;</span>
<span class="line-added">1291             emitARM64CompareFP(operands, :double, &quot;ne&quot;)</span>
<span class="line-added">1292         when &quot;cflt&quot;</span>
<span class="line-added">1293             emitARM64CompareFP(operands, :float, &quot;mi&quot;)</span>
<span class="line-added">1294         when &quot;cdlt&quot;</span>
<span class="line-added">1295             emitARM64CompareFP(operands, :double, &quot;mi&quot;)</span>
<span class="line-added">1296         when &quot;cflteq&quot;</span>
<span class="line-added">1297             emitARM64CompareFP(operands, :float, &quot;ls&quot;)</span>
<span class="line-added">1298         when &quot;cdlteq&quot;</span>
<span class="line-added">1299             emitARM64CompareFP(operands, :double, &quot;ls&quot;)</span>
<span class="line-added">1300         when &quot;cfgt&quot;</span>
<span class="line-added">1301             emitARM64CompareFP(operands, :float, &quot;gt&quot;)</span>
<span class="line-added">1302         when &quot;cdgt&quot;</span>
<span class="line-added">1303             emitARM64CompareFP(operands, :double, &quot;gt&quot;)</span>
<span class="line-added">1304         when &quot;cfgteq&quot;</span>
<span class="line-added">1305             emitARM64CompareFP(operands, :float, &quot;ge&quot;)</span>
<span class="line-added">1306         when &quot;cdgteq&quot;</span>
<span class="line-added">1307             emitARM64CompareFP(operands, :double, &quot;ge&quot;)</span>
<span class="line-added">1308         when &quot;fi2f&quot;</span>
<span class="line-added">1309             emitARM64(&quot;fmov&quot;, operands, [:word, :float])</span>
<span class="line-added">1310         when &quot;ff2i&quot;</span>
<span class="line-added">1311             emitARM64(&quot;fmov&quot;, operands, [:float, :word])</span>
<span class="line-added">1312         when &quot;tls_loadp&quot;</span>
<span class="line-added">1313             tmp = ARM64_EXTRA_GPRS[0].arm64Operand(:ptr)</span>
<span class="line-added">1314             if operands[0].immediate?</span>
<span class="line-added">1315               offset = &quot;\##{operands[0].value * 8}&quot;</span>
<span class="line-added">1316             else</span>
<span class="line-added">1317               offset = operands[0].arm64Operand(:word)</span>
<span class="line-added">1318             end</span>
<span class="line-added">1319             $asm.puts &quot;mrs #{tmp}, tpidrro_el0&quot;</span>
<span class="line-added">1320             $asm.puts &quot;bic #{tmp}, #{tmp}, #7&quot;</span>
<span class="line-added">1321             $asm.puts &quot;ldr #{operands[1].arm64Operand(:ptr)}, [#{tmp}, #{offset}]&quot;</span>
<span class="line-added">1322         when &quot;tls_storep&quot;</span>
<span class="line-added">1323             tmp = ARM64_EXTRA_GPRS[0].arm64Operand(:ptr)</span>
<span class="line-added">1324             if operands[1].immediate?</span>
<span class="line-added">1325               offset = &quot;\##{operands[1].value * 8}&quot;</span>
<span class="line-added">1326             else</span>
<span class="line-added">1327               offset = operands[1].arm64Operand(:word)</span>
<span class="line-added">1328             end</span>
<span class="line-added">1329             $asm.puts &quot;mrs #{tmp}, tpidrro_el0&quot;</span>
<span class="line-added">1330             $asm.puts &quot;bic #{tmp}, #{tmp}, #7&quot;</span>
<span class="line-added">1331             $asm.puts &quot;str #{operands[0].arm64Operand(:ptr)}, [#{tmp}, #{offset}]&quot;</span>
1332         else
1333             lowerDefault
1334         end
1335     end
1336 end
1337 
</pre>
</td>
</tr>
</table>
<center><a href="arm.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="asm.rb.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
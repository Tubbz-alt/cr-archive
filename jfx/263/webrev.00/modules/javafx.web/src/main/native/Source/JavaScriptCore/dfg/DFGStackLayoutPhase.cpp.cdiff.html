<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGStackLayoutPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGSpeculativeJIT64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGStoreBarrierInsertionPhase.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGStackLayoutPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 34,11 ***</span>
  #include &quot;JSCInlines.h&quot;
  
  namespace JSC { namespace DFG {
  
  class StackLayoutPhase : public Phase {
<span class="line-modified">!     static const bool verbose = false;</span>
  
  public:
      StackLayoutPhase(Graph&amp; graph)
          : Phase(graph, &quot;stack layout&quot;)
      {
<span class="line-new-header">--- 34,11 ---</span>
  #include &quot;JSCInlines.h&quot;
  
  namespace JSC { namespace DFG {
  
  class StackLayoutPhase : public Phase {
<span class="line-modified">!     static constexpr bool verbose = false;</span>
  
  public:
      StackLayoutPhase(Graph&amp; graph)
          : Phase(graph, &quot;stack layout&quot;)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 49,11 ***</span>
          // This enumerates the locals that we actually care about and packs them. So for example
          // if we use local 1, 3, 4, 5, 7, then we remap them: 1-&gt;0, 3-&gt;1, 4-&gt;2, 5-&gt;3, 7-&gt;4. We
          // treat a variable as being &quot;used&quot; if there exists an access to it (SetLocal, GetLocal,
          // Flush, PhantomLocal).
  
<span class="line-modified">!         BitVector usedLocals;</span>
  
          // Collect those variables that are used from IR.
          bool hasNodesThatNeedFixup = false;
          for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
              BasicBlock* block = m_graph.block(blockIndex);
<span class="line-new-header">--- 49,11 ---</span>
          // This enumerates the locals that we actually care about and packs them. So for example
          // if we use local 1, 3, 4, 5, 7, then we remap them: 1-&gt;0, 3-&gt;1, 4-&gt;2, 5-&gt;3, 7-&gt;4. We
          // treat a variable as being &quot;used&quot; if there exists an access to it (SetLocal, GetLocal,
          // Flush, PhantomLocal).
  
<span class="line-modified">!         Operands&lt;bool&gt; usedOperands(0, graph().m_localVars, graph().m_tmps, false);</span>
  
          // Collect those variables that are used from IR.
          bool hasNodesThatNeedFixup = false;
          for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
              BasicBlock* block = m_graph.block(blockIndex);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 65,38 ***</span>
                  case GetLocal:
                  case SetLocal:
                  case Flush:
                  case PhantomLocal: {
                      VariableAccessData* variable = node-&gt;variableAccessData();
<span class="line-modified">!                     if (variable-&gt;local().isArgument())</span>
                          break;
<span class="line-modified">!                     usedLocals.set(variable-&gt;local().toLocal());</span>
                      break;
                  }
  
                  case LoadVarargs:
                  case ForwardVarargs: {
                      LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified">!                     if (data-&gt;count.isLocal())</span>
<span class="line-removed">-                         usedLocals.set(data-&gt;count.toLocal());</span>
                      if (data-&gt;start.isLocal()) {
                          // This part really relies on the contiguity of stack layout
                          // assignments.
                          ASSERT(VirtualRegister(data-&gt;start.offset() + data-&gt;limit - 1).isLocal());
                          for (unsigned i = data-&gt;limit; i--;)
<span class="line-modified">!                             usedLocals.set(VirtualRegister(data-&gt;start.offset() + i).toLocal());</span>
                      } // the else case shouldn&#39;t happen.
                      hasNodesThatNeedFixup = true;
                      break;
                  }
  
                  case PutStack:
                  case GetStack: {
                      StackAccessData* stack = node-&gt;stackAccessData();
<span class="line-modified">!                     if (stack-&gt;local.isArgument())</span>
                          break;
<span class="line-modified">!                     usedLocals.set(stack-&gt;local.toLocal());</span>
                      break;
                  }
  
                  default:
                      break;
<span class="line-new-header">--- 65,37 ---</span>
                  case GetLocal:
                  case SetLocal:
                  case Flush:
                  case PhantomLocal: {
                      VariableAccessData* variable = node-&gt;variableAccessData();
<span class="line-modified">!                     if (variable-&gt;operand().isArgument())</span>
                          break;
<span class="line-modified">!                     usedOperands.setOperand(variable-&gt;operand(), true);</span>
                      break;
                  }
  
                  case LoadVarargs:
                  case ForwardVarargs: {
                      LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified">!                     usedOperands.setOperand(data-&gt;count, true);</span>
                      if (data-&gt;start.isLocal()) {
                          // This part really relies on the contiguity of stack layout
                          // assignments.
                          ASSERT(VirtualRegister(data-&gt;start.offset() + data-&gt;limit - 1).isLocal());
                          for (unsigned i = data-&gt;limit; i--;)
<span class="line-modified">!                             usedOperands.setOperand(VirtualRegister(data-&gt;start.offset() + i), true);</span>
                      } // the else case shouldn&#39;t happen.
                      hasNodesThatNeedFixup = true;
                      break;
                  }
  
                  case PutStack:
                  case GetStack: {
                      StackAccessData* stack = node-&gt;stackAccessData();
<span class="line-modified">!                     if (stack-&gt;operand.isArgument())</span>
                          break;
<span class="line-modified">!                     usedOperands.setOperand(stack-&gt;operand, true);</span>
                      break;
                  }
  
                  default:
                      break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 106,25 ***</span>
  
          for (InlineCallFrameSet::iterator iter = m_graph.m_plan.inlineCallFrames()-&gt;begin(); !!iter; ++iter) {
              InlineCallFrame* inlineCallFrame = *iter;
  
              if (inlineCallFrame-&gt;isVarargs()) {
<span class="line-modified">!                 usedLocals.set(VirtualRegister(</span>
<span class="line-modified">!                     CallFrameSlot::argumentCount + inlineCallFrame-&gt;stackOffset).toLocal());</span>
              }
  
              for (unsigned argument = inlineCallFrame-&gt;argumentsWithFixup.size(); argument--;) {
<span class="line-modified">!                 usedLocals.set(VirtualRegister(</span>
<span class="line-modified">!                     virtualRegisterForArgument(argument).offset() +</span>
<span class="line-modified">!                     inlineCallFrame-&gt;stackOffset).toLocal());</span>
              }
          }
  
<span class="line-modified">!         Vector&lt;unsigned&gt; allocation(usedLocals.size());</span>
          m_graph.m_nextMachineLocal = codeBlock()-&gt;calleeSaveSpaceAsVirtualRegisters();
<span class="line-modified">!         for (unsigned i = 0; i &lt; usedLocals.size(); ++i) {</span>
<span class="line-modified">!             if (!usedLocals.get(i)) {</span>
                  allocation[i] = UINT_MAX;
                  continue;
              }
  
              allocation[i] = m_graph.m_nextMachineLocal++;
<span class="line-new-header">--- 105,25 ---</span>
  
          for (InlineCallFrameSet::iterator iter = m_graph.m_plan.inlineCallFrames()-&gt;begin(); !!iter; ++iter) {
              InlineCallFrame* inlineCallFrame = *iter;
  
              if (inlineCallFrame-&gt;isVarargs()) {
<span class="line-modified">!                 usedOperands.setOperand(VirtualRegister(</span>
<span class="line-modified">!                     CallFrameSlot::argumentCountIncludingThis + inlineCallFrame-&gt;stackOffset), true);</span>
              }
  
              for (unsigned argument = inlineCallFrame-&gt;argumentsWithFixup.size(); argument--;) {
<span class="line-modified">!                 usedOperands.setOperand(VirtualRegister(</span>
<span class="line-modified">!                     virtualRegisterForArgumentIncludingThis(argument).offset() +</span>
<span class="line-modified">!                     inlineCallFrame-&gt;stackOffset), true);</span>
              }
          }
  
<span class="line-modified">!         Vector&lt;unsigned&gt; allocation(usedOperands.size());</span>
          m_graph.m_nextMachineLocal = codeBlock()-&gt;calleeSaveSpaceAsVirtualRegisters();
<span class="line-modified">!         for (unsigned i = 0; i &lt; usedOperands.size(); ++i) {</span>
<span class="line-modified">!             if (!usedOperands.getForOperandIndex(i)) {</span>
                  allocation[i] = UINT_MAX;
                  continue;
              }
  
              allocation[i] = m_graph.m_nextMachineLocal++;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,52 ***</span>
          for (unsigned i = m_graph.m_variableAccessData.size(); i--;) {
              VariableAccessData* variable = &amp;m_graph.m_variableAccessData[i];
              if (!variable-&gt;isRoot())
                  continue;
  
<span class="line-modified">!             if (variable-&gt;local().isArgument()) {</span>
<span class="line-modified">!                 variable-&gt;machineLocal() = variable-&gt;local();</span>
                  continue;
              }
  
<span class="line-modified">!             size_t local = variable-&gt;local().toLocal();</span>
<span class="line-modified">!             if (local &gt;= allocation.size())</span>
                  continue;
  
<span class="line-modified">!             if (allocation[local] == UINT_MAX)</span>
                  continue;
  
<span class="line-modified">!             variable-&gt;machineLocal() = assign(allocation, variable-&gt;local());</span>
          }
  
          for (StackAccessData* data : m_graph.m_stackAccessData) {
<span class="line-modified">!             if (!data-&gt;local.isLocal()) {</span>
<span class="line-modified">!                 data-&gt;machineLocal = data-&gt;local;</span>
                  continue;
              }
  
<span class="line-modified">!             if (static_cast&lt;size_t&gt;(data-&gt;local.toLocal()) &gt;= allocation.size())</span>
<span class="line-modified">!                 continue;</span>
<span class="line-modified">!             if (allocation[data-&gt;local.toLocal()] == UINT_MAX)</span>
<span class="line-modified">!                 continue;</span>
  
<span class="line-modified">!             data-&gt;machineLocal = assign(allocation, data-&gt;local);</span>
          }
  
          if (!m_graph.needsScopeRegister())
              codeBlock()-&gt;setScopeRegister(VirtualRegister());
          else
<span class="line-modified">!             codeBlock()-&gt;setScopeRegister(assign(allocation, codeBlock()-&gt;scopeRegister()));</span>
  
          for (unsigned i = m_graph.m_inlineVariableData.size(); i--;) {
              InlineVariableData data = m_graph.m_inlineVariableData[i];
              InlineCallFrame* inlineCallFrame = data.inlineCallFrame;
  
<span class="line-modified">!             if (inlineCallFrame-&gt;isVarargs()) {</span>
<span class="line-modified">!                 inlineCallFrame-&gt;argumentCountRegister = assign(</span>
<span class="line-removed">-                     allocation, VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount));</span>
<span class="line-removed">-             }</span>
  
              for (unsigned argument = inlineCallFrame-&gt;argumentsWithFixup.size(); argument--;) {
                  ArgumentPosition&amp; position = m_graph.m_argumentPositions[
                      data.argumentPositionStart + argument];
                  VariableAccessData* variable = position.someVariable();
<span class="line-new-header">--- 132,53 ---</span>
          for (unsigned i = m_graph.m_variableAccessData.size(); i--;) {
              VariableAccessData* variable = &amp;m_graph.m_variableAccessData[i];
              if (!variable-&gt;isRoot())
                  continue;
  
<span class="line-modified">!             if (variable-&gt;operand().isArgument()) {</span>
<span class="line-modified">!                 variable-&gt;machineLocal() = variable-&gt;operand().virtualRegister();</span>
                  continue;
              }
  
<span class="line-modified">!             Operand operand = variable-&gt;operand();</span>
<span class="line-modified">!             size_t index = usedOperands.operandIndex(operand);</span>
<span class="line-added">+             if (index &gt;= allocation.size())</span>
                  continue;
  
<span class="line-modified">!             if (allocation[index] == UINT_MAX)</span>
                  continue;
  
<span class="line-modified">!             variable-&gt;machineLocal() = assign(usedOperands, allocation, variable-&gt;operand());</span>
          }
  
          for (StackAccessData* data : m_graph.m_stackAccessData) {
<span class="line-modified">!             if (data-&gt;operand.isArgument()) {</span>
<span class="line-modified">!                 data-&gt;machineLocal = data-&gt;operand.virtualRegister();</span>
                  continue;
              }
  
<span class="line-modified">!             if (data-&gt;operand.isLocal()) {</span>
<span class="line-modified">!                 if (static_cast&lt;size_t&gt;(data-&gt;operand.toLocal()) &gt;= allocation.size())</span>
<span class="line-modified">!                     continue;</span>
<span class="line-modified">!                 if (allocation[data-&gt;operand.toLocal()] == UINT_MAX)</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             data-&gt;machineLocal = assign(usedOperands, allocation, data-&gt;operand);</span>
          }
  
          if (!m_graph.needsScopeRegister())
              codeBlock()-&gt;setScopeRegister(VirtualRegister());
          else
<span class="line-modified">!             codeBlock()-&gt;setScopeRegister(assign(usedOperands, allocation, codeBlock()-&gt;scopeRegister()));</span>
  
          for (unsigned i = m_graph.m_inlineVariableData.size(); i--;) {
              InlineVariableData data = m_graph.m_inlineVariableData[i];
              InlineCallFrame* inlineCallFrame = data.inlineCallFrame;
  
<span class="line-modified">!             if (inlineCallFrame-&gt;isVarargs())</span>
<span class="line-modified">!                 inlineCallFrame-&gt;argumentCountRegister = assign(usedOperands, allocation, VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCountIncludingThis));</span>
  
              for (unsigned argument = inlineCallFrame-&gt;argumentsWithFixup.size(); argument--;) {
                  ArgumentPosition&amp; position = m_graph.m_argumentPositions[
                      data.argumentPositionStart + argument];
                  VariableAccessData* variable = position.someVariable();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 213,12 ***</span>
                      Node* node = block-&gt;at(nodeIndex);
                      switch (node-&gt;op()) {
                      case LoadVarargs:
                      case ForwardVarargs: {
                          LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified">!                         data-&gt;machineCount = assign(allocation, data-&gt;count);</span>
<span class="line-modified">!                         data-&gt;machineStart = assign(allocation, data-&gt;start);</span>
                          break;
                      }
  
                      default:
                          break;
<span class="line-new-header">--- 213,12 ---</span>
                      Node* node = block-&gt;at(nodeIndex);
                      switch (node-&gt;op()) {
                      case LoadVarargs:
                      case ForwardVarargs: {
                          LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified">!                         data-&gt;machineCount = assign(usedOperands, allocation, data-&gt;count);</span>
<span class="line-modified">!                         data-&gt;machineStart = assign(usedOperands, allocation, data-&gt;start);</span>
                          break;
                      }
  
                      default:
                          break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 229,21 ***</span>
  
          return true;
      }
  
  private:
<span class="line-modified">!     VirtualRegister assign(const Vector&lt;unsigned&gt;&amp; allocation, VirtualRegister src)</span>
      {
<span class="line-modified">!         VirtualRegister result = src;</span>
<span class="line-modified">!         if (result.isLocal()) {</span>
<span class="line-modified">!             unsigned myAllocation = allocation[result.toLocal()];</span>
<span class="line-modified">!             if (myAllocation == UINT_MAX)</span>
<span class="line-modified">!                 result = VirtualRegister();</span>
<span class="line-modified">!             else</span>
<span class="line-modified">!                 result = virtualRegisterForLocal(myAllocation);</span>
<span class="line-modified">!         }</span>
<span class="line-removed">-         return result;</span>
      }
  };
  
  bool performStackLayout(Graph&amp; graph)
  {
<span class="line-new-header">--- 229,20 ---</span>
  
          return true;
      }
  
  private:
<span class="line-modified">!     VirtualRegister assign(const Operands&lt;bool&gt;&amp; usedOperands, const Vector&lt;unsigned&gt;&amp; allocation, Operand operand)</span>
      {
<span class="line-modified">!         if (operand.isArgument())</span>
<span class="line-modified">!             return operand.virtualRegister();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         size_t operandIndex = usedOperands.operandIndex(operand);</span>
<span class="line-modified">!         unsigned myAllocation = allocation[operandIndex];</span>
<span class="line-modified">!         if (myAllocation == UINT_MAX)</span>
<span class="line-modified">!             return VirtualRegister();</span>
<span class="line-modified">!         return virtualRegisterForLocal(myAllocation);</span>
      }
  };
  
  bool performStackLayout(Graph&amp; graph)
  {
</pre>
<center><a href="DFGSpeculativeJIT64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGStoreBarrierInsertionPhase.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
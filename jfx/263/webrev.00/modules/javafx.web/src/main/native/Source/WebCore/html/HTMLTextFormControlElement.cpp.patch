diff a/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLTextFormControlElement.cpp b/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLTextFormControlElement.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLTextFormControlElement.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLTextFormControlElement.cpp
@@ -63,10 +63,11 @@
 HTMLTextFormControlElement::HTMLTextFormControlElement(const QualifiedName& tagName, Document& document, HTMLFormElement* form)
     : HTMLFormControlElementWithState(tagName, document, form)
     , m_cachedSelectionDirection(SelectionHasNoDirection)
     , m_lastChangeWasUserEdit(false)
     , m_isPlaceholderVisible(false)
+    , m_canShowPlaceholder(true)
     , m_cachedSelectionStart(-1)
     , m_cachedSelectionEnd(-1)
 {
 }
 
@@ -156,11 +157,11 @@
 
 bool HTMLTextFormControlElement::placeholderShouldBeVisible() const
 {
     // This function is used by the style resolver to match the :placeholder-shown pseudo class.
     // Since it is used for styling, it must not use any value depending on the style.
-    return supportsPlaceholder() && isEmptyValue() && !isPlaceholderEmpty();
+    return supportsPlaceholder() && isEmptyValue() && !isPlaceholderEmpty() && m_canShowPlaceholder;
 }
 
 void HTMLTextFormControlElement::updatePlaceholderVisibility()
 {
     bool placeHolderWasVisible = m_isPlaceholderVisible;
@@ -170,10 +171,16 @@
         return;
 
     invalidateStyleForSubtree();
 }
 
+void HTMLTextFormControlElement::setCanShowPlaceholder(bool canShowPlaceholder)
+{
+    m_canShowPlaceholder = canShowPlaceholder;
+    updatePlaceholderVisibility();
+}
+
 void HTMLTextFormControlElement::setSelectionStart(int start)
 {
     setSelectionRange(start, std::max(start, selectionEnd()), selectionDirection());
 }
 
@@ -287,13 +294,21 @@
     start = std::min(std::max(start, 0), end);
 
     auto innerText = innerTextElement();
     bool hasFocus = document().focusedElement() == this;
     if (!hasFocus && innerText) {
+        if (!isConnected()) {
+            cacheSelection(start, end, direction);
+            return;
+        }
+
         // FIXME: Removing this synchronous layout requires fixing setSelectionWithoutUpdatingAppearance not needing up-to-date style.
         document().updateLayoutIgnorePendingStylesheets();
 
+        if (!isTextField())
+            return;
+
         // Double-check the state of innerTextElement after the layout.
         innerText = innerTextElement();
         auto* rendererTextControl = renderer();
 
         if (innerText && rendererTextControl) {
@@ -641,16 +656,20 @@
             ++index;
     }
 
     unsigned length = innerTextValue().length();
     index = std::min(index, length); // FIXME: We shouldn't have to call innerTextValue() just to ignore the last LF. See finishText.
-#ifndef ASSERT_DISABLED
+#if 0
+    // FIXME: This assertion code was never built, has bit rotted, and needs to be fixed before it can be enabled:
+    // https://bugs.webkit.org/show_bug.cgi?id=205706.
+#if ASSERT_ENABLED
     VisiblePosition visiblePosition = passedPosition;
     unsigned indexComputedByVisiblePosition = 0;
     if (visiblePosition.isNotNull())
         indexComputedByVisiblePosition = WebCore::indexForVisiblePosition(innerText, visiblePosition, false /* forSelectionPreservation */);
     ASSERT(index == indexComputedByVisiblePosition);
+#endif
 #endif
     return index;
 }
 
 #if PLATFORM(IOS_FAMILY)

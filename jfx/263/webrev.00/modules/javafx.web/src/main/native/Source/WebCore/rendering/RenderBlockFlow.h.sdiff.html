<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlockFlow.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderBlockFlow.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBox.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlockFlow.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #pragma once
 24 
 25 #include &quot;ComplexLineLayout.h&quot;
 26 #include &quot;FloatingObjects.h&quot;
 27 #include &quot;LineWidth.h&quot;
 28 #include &quot;RenderBlock.h&quot;
 29 #include &quot;RenderLineBoxList.h&quot;
 30 #include &quot;SimpleLineLayout.h&quot;
 31 #include &quot;TrailingObjects.h&quot;
 32 #include &lt;memory&gt;
 33 
 34 namespace WebCore {
 35 
 36 class LineBreaker;
 37 class RenderMultiColumnFlow;
 38 class RenderRubyRun;
 39 






 40 #if ENABLE(TEXT_AUTOSIZING)
 41 enum LineCount {
 42     NOT_SET = 0, NO_LINE = 1, ONE_LINE = 2, MULTI_LINE = 3
 43 };
 44 #endif
 45 
 46 class RenderBlockFlow : public RenderBlock {
 47     WTF_MAKE_ISO_ALLOCATED(RenderBlockFlow);
 48 public:
 49     RenderBlockFlow(Element&amp;, RenderStyle&amp;&amp;);
 50     RenderBlockFlow(Document&amp;, RenderStyle&amp;&amp;);
 51     virtual ~RenderBlockFlow();
 52 
 53     void layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeight = 0_lu) override;
 54 
 55 protected:
 56     void willBeDestroyed() override;
 57 
 58     // This method is called at the start of layout to wipe away all of the floats in our floating objects list. It also
 59     // repopulates the list with any floats that intrude from previous siblings or parents. Floats that were added by
 60     // descendants are gone when this call completes and will get added back later on after the children have gotten
 61     // a relayout.
 62     void rebuildFloatingObjectSetFromIntrudingFloats();
 63 
 64     // RenderBlockFlow always contains either lines or paragraphs. When the children are all blocks (e.g. paragraphs), we call layoutBlockChildren.
 65     // When the children are all inline (e.g., lines), we call layoutInlineChildren.
 66     void layoutBlockChildren(bool relayoutChildren, LayoutUnit&amp; maxFloatLogicalBottom);
 67     void layoutInlineChildren(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom);
 68 
 69     // RenderBlockFlows override these methods, since they are the only class that supports margin collapsing.
 70     LayoutUnit collapsedMarginBefore() const final { return maxPositiveMarginBefore() - maxNegativeMarginBefore(); }
 71     LayoutUnit collapsedMarginAfter() const final { return maxPositiveMarginAfter() - maxNegativeMarginAfter(); }
 72 
 73     void dirtyLinesFromChangedChild(RenderObject&amp; child) final
 74     {
<span class="line-modified"> 75         if (m_complexLineLayout)</span>
<span class="line-modified"> 76             m_complexLineLayout-&gt;lineBoxes().dirtyLinesFromChangedChild(*this, child);</span>
 77     }
 78 
 79     void paintColumnRules(PaintInfo&amp;, const LayoutPoint&amp;) override;
 80 
 81 public:
 82     class MarginValues {
 83     public:
 84         MarginValues(LayoutUnit beforePos, LayoutUnit beforeNeg, LayoutUnit afterPos, LayoutUnit afterNeg)
 85             : m_positiveMarginBefore(beforePos)
 86             , m_negativeMarginBefore(beforeNeg)
 87             , m_positiveMarginAfter(afterPos)
 88             , m_negativeMarginAfter(afterNeg)
 89         {
 90         }
 91 
 92         LayoutUnit positiveMarginBefore() const { return m_positiveMarginBefore; }
 93         LayoutUnit negativeMarginBefore() const { return m_negativeMarginBefore; }
 94         LayoutUnit positiveMarginAfter() const { return m_positiveMarginAfter; }
 95         LayoutUnit negativeMarginAfter() const { return m_negativeMarginAfter; }
 96 
</pre>
<hr />
<pre>
315         else
316             floatingObject.setWidth(logicalHeight);
317     }
318     void setLogicalWidthForFloat(FloatingObject&amp; floatingObject, LayoutUnit logicalWidth)
319     {
320         if (isHorizontalWritingMode())
321             floatingObject.setWidth(logicalWidth);
322         else
323             floatingObject.setHeight(logicalWidth);
324     }
325     void setLogicalMarginsForFloat(FloatingObject&amp; floatingObject, LayoutUnit logicalLeftMargin, LayoutUnit logicalBeforeMargin)
326     {
327         if (isHorizontalWritingMode())
328             floatingObject.setMarginOffset(LayoutSize(logicalLeftMargin, logicalBeforeMargin));
329         else
330             floatingObject.setMarginOffset(LayoutSize(logicalBeforeMargin, logicalLeftMargin));
331     }
332 
333     LayoutPoint flipFloatForWritingModeForChild(const FloatingObject&amp;, const LayoutPoint&amp;) const;
334 
<span class="line-modified">335     RootInlineBox* firstRootBox() const { return m_complexLineLayout ? m_complexLineLayout-&gt;firstRootBox() : nullptr; }</span>
<span class="line-modified">336     RootInlineBox* lastRootBox() const { return m_complexLineLayout ? m_complexLineLayout-&gt;lastRootBox() : nullptr; }</span>
337 
338     bool hasLines() const;
339     void invalidateLineLayoutPath() final;
340 
<span class="line-modified">341     enum LineLayoutPath { UndeterminedPath = 0, SimpleLinesPath, LineBoxesPath, ForceLineBoxesPath };</span>
342     LineLayoutPath lineLayoutPath() const { return static_cast&lt;LineLayoutPath&gt;(renderBlockFlowLineLayoutPath()); }
343     void setLineLayoutPath(LineLayoutPath path) { setRenderBlockFlowLineLayoutPath(path); }
344 
345     // Helper methods for computing line counts and heights for line counts.
346     RootInlineBox* lineAtIndex(int) const;
<span class="line-modified">347     int lineCount(const RootInlineBox* = nullptr, bool* = nullptr) const;</span>
348     int heightForLineCount(int);
349     void clearTruncation();
350 
351     void setHasMarkupTruncation(bool b) { setRenderBlockFlowHasMarkupTruncation(b); }
352     bool hasMarkupTruncation() const { return renderBlockFlowHasMarkupTruncation(); }
353 
354     bool containsNonZeroBidiLevel() const;
355 
356     const SimpleLineLayout::Layout* simpleLineLayout() const;
<span class="line-modified">357     void deleteLineBoxesBeforeSimpleLineLayout();</span>







358     void ensureLineBoxes();
359     void generateLineBoxTree();
360 
361 #if ENABLE(TREE_DEBUGGING)
362     void outputLineTreeAndMark(WTF::TextStream&amp;, const InlineBox* markedBox, int depth) const;
363 #endif
364 
365     // Returns the logicalOffset at the top of the next page. If the offset passed in is already at the top of the current page,
366     // then nextPageLogicalTop with ExcludePageBoundary will still move to the top of the next page. nextPageLogicalTop with
367     // IncludePageBoundary set will not.
368     //
369     // For a page height of 800px, the first rule will return 800 if the value passed in is 0. The second rule will simply return 0.
370     enum PageBoundaryRule { ExcludePageBoundary, IncludePageBoundary };
371     LayoutUnit nextPageLogicalTop(LayoutUnit logicalOffset, PageBoundaryRule = ExcludePageBoundary) const;
372     LayoutUnit pageLogicalTopForOffset(LayoutUnit offset) const;
373     LayoutUnit pageLogicalHeightForOffset(LayoutUnit offset) const;
374     LayoutUnit pageRemainingLogicalHeightForOffset(LayoutUnit offset, PageBoundaryRule = IncludePageBoundary) const;
375     LayoutUnit logicalHeightForChildForFragmentation(const RenderBox&amp; child) const;
376     bool hasNextPage(LayoutUnit logicalOffset, PageBoundaryRule = ExcludePageBoundary) const;
377 
378     void updateColumnProgressionFromStyle(RenderStyle&amp;);
379     void updateStylesForColumnChildren();
380 
381     bool needsLayoutAfterFragmentRangeChange() const override;
382     WEBCORE_EXPORT RenderText* findClosestTextAtAbsolutePoint(const FloatPoint&amp;);
383 
384     // A page break is required at some offset due to space shortage in the current fragmentainer.
385     void setPageBreak(LayoutUnit offset, LayoutUnit spaceShortage);
386     // Update minimum page height required to avoid fragmentation where it shouldn&#39;t occur (inside
387     // unbreakable content, between orphans and widows, etc.). This will be used as a hint to the
388     // column balancer to help set a good minimum column height.
389     void updateMinimumPageHeight(LayoutUnit offset, LayoutUnit minHeight);
390 
391     void addFloatsToNewParent(RenderBlockFlow&amp; toBlockFlow) const;
392 
393 protected:


394     void computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const override;
395 
396     bool pushToNextPageWithMinimumLogicalHeight(LayoutUnit&amp; adjustment, LayoutUnit logicalOffset, LayoutUnit minimumLogicalHeight) const;
397 
398     // If the child is unsplittable and can&#39;t fit on the current page, return the top of the next page/column.
399     LayoutUnit adjustForUnsplittableChild(RenderBox&amp; child, LayoutUnit logicalOffset, LayoutUnit beforeMargin = 0_lu, LayoutUnit afterMargin = 0_lu);
400     LayoutUnit adjustBlockChildForPagination(LayoutUnit logicalTopAfterClear, LayoutUnit estimateWithoutPagination, RenderBox&amp; child, bool atBeforeSideOfBlock);
401     LayoutUnit applyBeforeBreak(RenderBox&amp; child, LayoutUnit logicalOffset); // If the child has a before break, then return a new yPos that shifts to the top of the next page/column.
402     LayoutUnit applyAfterBreak(RenderBox&amp; child, LayoutUnit logicalOffset, MarginInfo&amp;); // If the child has an after break, then return a new offset that shifts to the top of the next page/column.
403 
404     LayoutUnit maxPositiveMarginBefore() const { return hasRareBlockFlowData() ? rareBlockFlowData()-&gt;m_margins.positiveMarginBefore() : RenderBlockFlowRareData::positiveMarginBeforeDefault(*this); }
405     LayoutUnit maxNegativeMarginBefore() const { return hasRareBlockFlowData() ? rareBlockFlowData()-&gt;m_margins.negativeMarginBefore() : RenderBlockFlowRareData::negativeMarginBeforeDefault(*this); }
406     LayoutUnit maxPositiveMarginAfter() const { return hasRareBlockFlowData() ? rareBlockFlowData()-&gt;m_margins.positiveMarginAfter() : RenderBlockFlowRareData::positiveMarginAfterDefault(*this); }
407     LayoutUnit maxNegativeMarginAfter() const { return hasRareBlockFlowData() ? rareBlockFlowData()-&gt;m_margins.negativeMarginAfter() : RenderBlockFlowRareData::negativeMarginAfterDefault(*this); }
408 
409     void initMaxMarginValues()
410     {
411         if (!hasRareBlockFlowData())
412             return;
413 
</pre>
<hr />
<pre>
504     void determineLogicalLeftPositionForChild(RenderBox&amp; child, ApplyLayoutDeltaMode = DoNotApplyLayoutDelta);
505 
506     bool hitTestFloats(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset) override;
507     bool hitTestInlineChildren(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction) override;
508 
509     void addOverflowFromInlineChildren() override;
510 
511     void fitBorderToLinesIfNeeded(); // Shrink the box in which the border paints if border-fit is set.
512     void adjustForBorderFit(LayoutUnit x, LayoutUnit&amp; left, LayoutUnit&amp; right) const;
513 
514     void markLinesDirtyInBlockRange(LayoutUnit logicalTop, LayoutUnit logicalBottom, RootInlineBox* highest = 0);
515 
516     GapRects inlineSelectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
517         LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp;, const PaintInfo*) override;
518 
519     Position positionForBox(InlineBox*, bool start = true) const;
520     VisiblePosition positionForPointWithInlineChildren(const LayoutPoint&amp; pointInLogicalContents, const RenderFragmentContainer*) override;
521     void addFocusRingRectsForInlineChildren(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject*) override;
522 
523 public:
<span class="line-removed">524     ComplexLineLayout* complexLineLayout() { return m_complexLineLayout.get(); }</span>
<span class="line-removed">525 </span>
526     virtual Optional&lt;TextAlignMode&gt; overrideTextAlignmentForLine(bool /* endsWithSoftBreak */) const { return { }; }
527     virtual void adjustInlineDirectionLineBounds(int /* expansionOpportunityCount */, float&amp; /* logicalLeft */, float&amp; /* logicalWidth */) const { }
528 
529 private:




530     void layoutSimpleLines(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom);
531 





532     void adjustIntrinsicLogicalWidthsForColumns(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const;
533     void computeInlinePreferredLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const;
534     void adjustInitialLetterPosition(RenderBox&amp; childBox, LayoutUnit&amp; logicalTopOffset, LayoutUnit&amp; marginBeforeOffset);
535 
536 #if ENABLE(TEXT_AUTOSIZING)
537     int m_widthForTextAutosizing;
538     unsigned m_lineCountForTextAutosizing : 2;
539 #endif
540     void setSelectionState(SelectionState) final;
541 
542 public:
543     // FIXME-BLOCKFLOW: These can be made protected again once all callers have been moved here.
544     void adjustLinePositionForPagination(RootInlineBox*, LayoutUnit&amp; deltaOffset, bool&amp; overflowsFragment, RenderFragmentedFlow*); // Computes a deltaOffset value that put a line at the top of the next page if it doesn&#39;t fit on the current page.
545 
546     // Pagination routines.
547     bool relayoutForPagination();
548 
549     bool hasRareBlockFlowData() const { return m_rareBlockFlowData.get(); }
550     RenderBlockFlowRareData* rareBlockFlowData() const { ASSERT_WITH_SECURITY_IMPLICATION(hasRareBlockFlowData()); return m_rareBlockFlowData.get(); }
551     RenderBlockFlowRareData&amp; ensureRareBlockFlowData();
552     void materializeRareBlockFlowData();
553 
554 #if ENABLE(TEXT_AUTOSIZING)
555     int lineCountForTextAutosizing();
556     void adjustComputedFontSizes(float size, float visibleWidth);
557     void resetComputedFontSize()
558     {
559         m_widthForTextAutosizing = -1;
560         m_lineCountForTextAutosizing = NOT_SET;
561     }
562 #endif
563 
564 protected:
565     std::unique_ptr&lt;FloatingObjects&gt; m_floatingObjects;
566     std::unique_ptr&lt;RenderBlockFlowRareData&gt; m_rareBlockFlowData;
567 
<span class="line-modified">568     // FIXME: Only one of these should be needed at any given time.</span>
<span class="line-modified">569     std::unique_ptr&lt;ComplexLineLayout&gt; m_complexLineLayout;</span>
<span class="line-modified">570     std::unique_ptr&lt;SimpleLineLayout::Layout&gt; m_simpleLineLayout;</span>






571 
572     friend class LineBreaker;
573     friend class LineWidth; // Needs to know FloatingObject
574     friend class ComplexLineLayout;
575 };
576 

























577 inline const SimpleLineLayout::Layout* RenderBlockFlow::simpleLineLayout() const
578 {
<span class="line-modified">579     ASSERT(lineLayoutPath() == SimpleLinesPath || !m_simpleLineLayout);</span>
<span class="line-modified">580     return m_simpleLineLayout.get();</span>




581 }
582 

















583 } // namespace WebCore
584 
585 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderBlockFlow, isRenderBlockFlow())
</pre>
</td>
<td>
<hr />
<pre>
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #pragma once
 24 
 25 #include &quot;ComplexLineLayout.h&quot;
 26 #include &quot;FloatingObjects.h&quot;
 27 #include &quot;LineWidth.h&quot;
 28 #include &quot;RenderBlock.h&quot;
 29 #include &quot;RenderLineBoxList.h&quot;
 30 #include &quot;SimpleLineLayout.h&quot;
 31 #include &quot;TrailingObjects.h&quot;
 32 #include &lt;memory&gt;
 33 
 34 namespace WebCore {
 35 
 36 class LineBreaker;
 37 class RenderMultiColumnFlow;
 38 class RenderRubyRun;
 39 
<span class="line-added"> 40 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added"> 41 namespace LayoutIntegration {</span>
<span class="line-added"> 42 class LineLayout;</span>
<span class="line-added"> 43 }</span>
<span class="line-added"> 44 #endif</span>
<span class="line-added"> 45 </span>
 46 #if ENABLE(TEXT_AUTOSIZING)
 47 enum LineCount {
 48     NOT_SET = 0, NO_LINE = 1, ONE_LINE = 2, MULTI_LINE = 3
 49 };
 50 #endif
 51 
 52 class RenderBlockFlow : public RenderBlock {
 53     WTF_MAKE_ISO_ALLOCATED(RenderBlockFlow);
 54 public:
 55     RenderBlockFlow(Element&amp;, RenderStyle&amp;&amp;);
 56     RenderBlockFlow(Document&amp;, RenderStyle&amp;&amp;);
 57     virtual ~RenderBlockFlow();
 58 
 59     void layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeight = 0_lu) override;
 60 
 61 protected:
 62     void willBeDestroyed() override;
 63 
 64     // This method is called at the start of layout to wipe away all of the floats in our floating objects list. It also
 65     // repopulates the list with any floats that intrude from previous siblings or parents. Floats that were added by
 66     // descendants are gone when this call completes and will get added back later on after the children have gotten
 67     // a relayout.
 68     void rebuildFloatingObjectSetFromIntrudingFloats();
 69 
 70     // RenderBlockFlow always contains either lines or paragraphs. When the children are all blocks (e.g. paragraphs), we call layoutBlockChildren.
 71     // When the children are all inline (e.g., lines), we call layoutInlineChildren.
 72     void layoutBlockChildren(bool relayoutChildren, LayoutUnit&amp; maxFloatLogicalBottom);
 73     void layoutInlineChildren(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom);
 74 
 75     // RenderBlockFlows override these methods, since they are the only class that supports margin collapsing.
 76     LayoutUnit collapsedMarginBefore() const final { return maxPositiveMarginBefore() - maxNegativeMarginBefore(); }
 77     LayoutUnit collapsedMarginAfter() const final { return maxPositiveMarginAfter() - maxNegativeMarginAfter(); }
 78 
 79     void dirtyLinesFromChangedChild(RenderObject&amp; child) final
 80     {
<span class="line-modified"> 81         if (complexLineLayout())</span>
<span class="line-modified"> 82             complexLineLayout()-&gt;lineBoxes().dirtyLinesFromChangedChild(*this, child);</span>
 83     }
 84 
 85     void paintColumnRules(PaintInfo&amp;, const LayoutPoint&amp;) override;
 86 
 87 public:
 88     class MarginValues {
 89     public:
 90         MarginValues(LayoutUnit beforePos, LayoutUnit beforeNeg, LayoutUnit afterPos, LayoutUnit afterNeg)
 91             : m_positiveMarginBefore(beforePos)
 92             , m_negativeMarginBefore(beforeNeg)
 93             , m_positiveMarginAfter(afterPos)
 94             , m_negativeMarginAfter(afterNeg)
 95         {
 96         }
 97 
 98         LayoutUnit positiveMarginBefore() const { return m_positiveMarginBefore; }
 99         LayoutUnit negativeMarginBefore() const { return m_negativeMarginBefore; }
100         LayoutUnit positiveMarginAfter() const { return m_positiveMarginAfter; }
101         LayoutUnit negativeMarginAfter() const { return m_negativeMarginAfter; }
102 
</pre>
<hr />
<pre>
321         else
322             floatingObject.setWidth(logicalHeight);
323     }
324     void setLogicalWidthForFloat(FloatingObject&amp; floatingObject, LayoutUnit logicalWidth)
325     {
326         if (isHorizontalWritingMode())
327             floatingObject.setWidth(logicalWidth);
328         else
329             floatingObject.setHeight(logicalWidth);
330     }
331     void setLogicalMarginsForFloat(FloatingObject&amp; floatingObject, LayoutUnit logicalLeftMargin, LayoutUnit logicalBeforeMargin)
332     {
333         if (isHorizontalWritingMode())
334             floatingObject.setMarginOffset(LayoutSize(logicalLeftMargin, logicalBeforeMargin));
335         else
336             floatingObject.setMarginOffset(LayoutSize(logicalBeforeMargin, logicalLeftMargin));
337     }
338 
339     LayoutPoint flipFloatForWritingModeForChild(const FloatingObject&amp;, const LayoutPoint&amp;) const;
340 
<span class="line-modified">341     RootInlineBox* firstRootBox() const { return complexLineLayout() ? complexLineLayout()-&gt;firstRootBox() : nullptr; }</span>
<span class="line-modified">342     RootInlineBox* lastRootBox() const { return complexLineLayout() ? complexLineLayout()-&gt;lastRootBox() : nullptr; }</span>
343 
344     bool hasLines() const;
345     void invalidateLineLayoutPath() final;
346 
<span class="line-modified">347     enum LineLayoutPath { UndeterminedPath = 0, SimpleLinesPath, LineBoxesPath, LayoutFormattingContextPath, ForceLineBoxesPath };</span>
348     LineLayoutPath lineLayoutPath() const { return static_cast&lt;LineLayoutPath&gt;(renderBlockFlowLineLayoutPath()); }
349     void setLineLayoutPath(LineLayoutPath path) { setRenderBlockFlowLineLayoutPath(path); }
350 
351     // Helper methods for computing line counts and heights for line counts.
352     RootInlineBox* lineAtIndex(int) const;
<span class="line-modified">353     int lineCount() const;</span>
354     int heightForLineCount(int);
355     void clearTruncation();
356 
357     void setHasMarkupTruncation(bool b) { setRenderBlockFlowHasMarkupTruncation(b); }
358     bool hasMarkupTruncation() const { return renderBlockFlowHasMarkupTruncation(); }
359 
360     bool containsNonZeroBidiLevel() const;
361 
362     const SimpleLineLayout::Layout* simpleLineLayout() const;
<span class="line-modified">363     SimpleLineLayout::Layout* simpleLineLayout();</span>
<span class="line-added">364     const ComplexLineLayout* complexLineLayout() const;</span>
<span class="line-added">365     ComplexLineLayout* complexLineLayout();</span>
<span class="line-added">366 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">367     const LayoutIntegration::LineLayout* layoutFormattingContextLineLayout() const;</span>
<span class="line-added">368     LayoutIntegration::LineLayout* layoutFormattingContextLineLayout();</span>
<span class="line-added">369 #endif</span>
<span class="line-added">370 </span>
371     void ensureLineBoxes();
372     void generateLineBoxTree();
373 
374 #if ENABLE(TREE_DEBUGGING)
375     void outputLineTreeAndMark(WTF::TextStream&amp;, const InlineBox* markedBox, int depth) const;
376 #endif
377 
378     // Returns the logicalOffset at the top of the next page. If the offset passed in is already at the top of the current page,
379     // then nextPageLogicalTop with ExcludePageBoundary will still move to the top of the next page. nextPageLogicalTop with
380     // IncludePageBoundary set will not.
381     //
382     // For a page height of 800px, the first rule will return 800 if the value passed in is 0. The second rule will simply return 0.
383     enum PageBoundaryRule { ExcludePageBoundary, IncludePageBoundary };
384     LayoutUnit nextPageLogicalTop(LayoutUnit logicalOffset, PageBoundaryRule = ExcludePageBoundary) const;
385     LayoutUnit pageLogicalTopForOffset(LayoutUnit offset) const;
386     LayoutUnit pageLogicalHeightForOffset(LayoutUnit offset) const;
387     LayoutUnit pageRemainingLogicalHeightForOffset(LayoutUnit offset, PageBoundaryRule = IncludePageBoundary) const;
388     LayoutUnit logicalHeightForChildForFragmentation(const RenderBox&amp; child) const;
389     bool hasNextPage(LayoutUnit logicalOffset, PageBoundaryRule = ExcludePageBoundary) const;
390 
391     void updateColumnProgressionFromStyle(RenderStyle&amp;);
392     void updateStylesForColumnChildren();
393 
394     bool needsLayoutAfterFragmentRangeChange() const override;
395     WEBCORE_EXPORT RenderText* findClosestTextAtAbsolutePoint(const FloatPoint&amp;);
396 
397     // A page break is required at some offset due to space shortage in the current fragmentainer.
398     void setPageBreak(LayoutUnit offset, LayoutUnit spaceShortage);
399     // Update minimum page height required to avoid fragmentation where it shouldn&#39;t occur (inside
400     // unbreakable content, between orphans and widows, etc.). This will be used as a hint to the
401     // column balancer to help set a good minimum column height.
402     void updateMinimumPageHeight(LayoutUnit offset, LayoutUnit minHeight);
403 
404     void addFloatsToNewParent(RenderBlockFlow&amp; toBlockFlow) const;
405 
406 protected:
<span class="line-added">407     bool shouldResetLogicalHeightBeforeLayout() const override { return true; }</span>
<span class="line-added">408 </span>
409     void computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const override;
410 
411     bool pushToNextPageWithMinimumLogicalHeight(LayoutUnit&amp; adjustment, LayoutUnit logicalOffset, LayoutUnit minimumLogicalHeight) const;
412 
413     // If the child is unsplittable and can&#39;t fit on the current page, return the top of the next page/column.
414     LayoutUnit adjustForUnsplittableChild(RenderBox&amp; child, LayoutUnit logicalOffset, LayoutUnit beforeMargin = 0_lu, LayoutUnit afterMargin = 0_lu);
415     LayoutUnit adjustBlockChildForPagination(LayoutUnit logicalTopAfterClear, LayoutUnit estimateWithoutPagination, RenderBox&amp; child, bool atBeforeSideOfBlock);
416     LayoutUnit applyBeforeBreak(RenderBox&amp; child, LayoutUnit logicalOffset); // If the child has a before break, then return a new yPos that shifts to the top of the next page/column.
417     LayoutUnit applyAfterBreak(RenderBox&amp; child, LayoutUnit logicalOffset, MarginInfo&amp;); // If the child has an after break, then return a new offset that shifts to the top of the next page/column.
418 
419     LayoutUnit maxPositiveMarginBefore() const { return hasRareBlockFlowData() ? rareBlockFlowData()-&gt;m_margins.positiveMarginBefore() : RenderBlockFlowRareData::positiveMarginBeforeDefault(*this); }
420     LayoutUnit maxNegativeMarginBefore() const { return hasRareBlockFlowData() ? rareBlockFlowData()-&gt;m_margins.negativeMarginBefore() : RenderBlockFlowRareData::negativeMarginBeforeDefault(*this); }
421     LayoutUnit maxPositiveMarginAfter() const { return hasRareBlockFlowData() ? rareBlockFlowData()-&gt;m_margins.positiveMarginAfter() : RenderBlockFlowRareData::positiveMarginAfterDefault(*this); }
422     LayoutUnit maxNegativeMarginAfter() const { return hasRareBlockFlowData() ? rareBlockFlowData()-&gt;m_margins.negativeMarginAfter() : RenderBlockFlowRareData::negativeMarginAfterDefault(*this); }
423 
424     void initMaxMarginValues()
425     {
426         if (!hasRareBlockFlowData())
427             return;
428 
</pre>
<hr />
<pre>
519     void determineLogicalLeftPositionForChild(RenderBox&amp; child, ApplyLayoutDeltaMode = DoNotApplyLayoutDelta);
520 
521     bool hitTestFloats(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset) override;
522     bool hitTestInlineChildren(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction) override;
523 
524     void addOverflowFromInlineChildren() override;
525 
526     void fitBorderToLinesIfNeeded(); // Shrink the box in which the border paints if border-fit is set.
527     void adjustForBorderFit(LayoutUnit x, LayoutUnit&amp; left, LayoutUnit&amp; right) const;
528 
529     void markLinesDirtyInBlockRange(LayoutUnit logicalTop, LayoutUnit logicalBottom, RootInlineBox* highest = 0);
530 
531     GapRects inlineSelectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
532         LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp;, const PaintInfo*) override;
533 
534     Position positionForBox(InlineBox*, bool start = true) const;
535     VisiblePosition positionForPointWithInlineChildren(const LayoutPoint&amp; pointInLogicalContents, const RenderFragmentContainer*) override;
536     void addFocusRingRectsForInlineChildren(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject*) override;
537 
538 public:


539     virtual Optional&lt;TextAlignMode&gt; overrideTextAlignmentForLine(bool /* endsWithSoftBreak */) const { return { }; }
540     virtual void adjustInlineDirectionLineBounds(int /* expansionOpportunityCount */, float&amp; /* logicalLeft */, float&amp; /* logicalWidth */) const { }
541 
542 private:
<span class="line-added">543     bool hasLineLayout() const;</span>
<span class="line-added">544     bool hasSimpleLineLayout() const;</span>
<span class="line-added">545     bool hasComplexLineLayout() const;</span>
<span class="line-added">546 </span>
547     void layoutSimpleLines(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom);
548 
<span class="line-added">549 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">550     bool hasLayoutFormattingContextLineLayout() const;</span>
<span class="line-added">551     void layoutLFCLines(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom);</span>
<span class="line-added">552 #endif</span>
<span class="line-added">553 </span>
554     void adjustIntrinsicLogicalWidthsForColumns(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const;
555     void computeInlinePreferredLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const;
556     void adjustInitialLetterPosition(RenderBox&amp; childBox, LayoutUnit&amp; logicalTopOffset, LayoutUnit&amp; marginBeforeOffset);
557 
558 #if ENABLE(TEXT_AUTOSIZING)
559     int m_widthForTextAutosizing;
560     unsigned m_lineCountForTextAutosizing : 2;
561 #endif
562     void setSelectionState(SelectionState) final;
563 
564 public:
565     // FIXME-BLOCKFLOW: These can be made protected again once all callers have been moved here.
566     void adjustLinePositionForPagination(RootInlineBox*, LayoutUnit&amp; deltaOffset, bool&amp; overflowsFragment, RenderFragmentedFlow*); // Computes a deltaOffset value that put a line at the top of the next page if it doesn&#39;t fit on the current page.
567 
568     // Pagination routines.
569     bool relayoutForPagination();
570 
571     bool hasRareBlockFlowData() const { return m_rareBlockFlowData.get(); }
572     RenderBlockFlowRareData* rareBlockFlowData() const { ASSERT_WITH_SECURITY_IMPLICATION(hasRareBlockFlowData()); return m_rareBlockFlowData.get(); }
573     RenderBlockFlowRareData&amp; ensureRareBlockFlowData();
574     void materializeRareBlockFlowData();
575 
576 #if ENABLE(TEXT_AUTOSIZING)
577     int lineCountForTextAutosizing();
578     void adjustComputedFontSizes(float size, float visibleWidth);
579     void resetComputedFontSize()
580     {
581         m_widthForTextAutosizing = -1;
582         m_lineCountForTextAutosizing = NOT_SET;
583     }
584 #endif
585 
586 protected:
587     std::unique_ptr&lt;FloatingObjects&gt; m_floatingObjects;
588     std::unique_ptr&lt;RenderBlockFlowRareData&gt; m_rareBlockFlowData;
589 
<span class="line-modified">590 private:</span>
<span class="line-modified">591     Variant&lt;</span>
<span class="line-modified">592         WTF::Monostate,</span>
<span class="line-added">593         Ref&lt;SimpleLineLayout::Layout&gt;,</span>
<span class="line-added">594 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">595         std::unique_ptr&lt;LayoutIntegration::LineLayout&gt;,</span>
<span class="line-added">596 #endif</span>
<span class="line-added">597         std::unique_ptr&lt;ComplexLineLayout&gt;</span>
<span class="line-added">598     &gt; m_lineLayout;</span>
599 
600     friend class LineBreaker;
601     friend class LineWidth; // Needs to know FloatingObject
602     friend class ComplexLineLayout;
603 };
604 
<span class="line-added">605 inline bool RenderBlockFlow::hasLineLayout() const</span>
<span class="line-added">606 {</span>
<span class="line-added">607     return !WTF::holds_alternative&lt;WTF::Monostate&gt;(m_lineLayout);</span>
<span class="line-added">608 }</span>
<span class="line-added">609 </span>
<span class="line-added">610 inline bool RenderBlockFlow::hasComplexLineLayout() const</span>
<span class="line-added">611 {</span>
<span class="line-added">612     return WTF::holds_alternative&lt;std::unique_ptr&lt;ComplexLineLayout&gt;&gt;(m_lineLayout);</span>
<span class="line-added">613 }</span>
<span class="line-added">614 </span>
<span class="line-added">615 inline const ComplexLineLayout* RenderBlockFlow::complexLineLayout() const</span>
<span class="line-added">616 {</span>
<span class="line-added">617     return hasComplexLineLayout() ? WTF::get&lt;std::unique_ptr&lt;ComplexLineLayout&gt;&gt;(m_lineLayout).get() : nullptr;</span>
<span class="line-added">618 }</span>
<span class="line-added">619 </span>
<span class="line-added">620 inline ComplexLineLayout* RenderBlockFlow::complexLineLayout()</span>
<span class="line-added">621 {</span>
<span class="line-added">622     return hasComplexLineLayout() ? WTF::get&lt;std::unique_ptr&lt;ComplexLineLayout&gt;&gt;(m_lineLayout).get() : nullptr;</span>
<span class="line-added">623 }</span>
<span class="line-added">624 </span>
<span class="line-added">625 inline bool RenderBlockFlow::hasSimpleLineLayout() const</span>
<span class="line-added">626 {</span>
<span class="line-added">627     return WTF::holds_alternative&lt;Ref&lt;SimpleLineLayout::Layout&gt;&gt;(m_lineLayout);</span>
<span class="line-added">628 }</span>
<span class="line-added">629 </span>
630 inline const SimpleLineLayout::Layout* RenderBlockFlow::simpleLineLayout() const
631 {
<span class="line-modified">632     return hasSimpleLineLayout() ? WTF::get&lt;Ref&lt;SimpleLineLayout::Layout&gt;&gt;(m_lineLayout).ptr() : nullptr;</span>
<span class="line-modified">633 }</span>
<span class="line-added">634 </span>
<span class="line-added">635 inline SimpleLineLayout::Layout* RenderBlockFlow::simpleLineLayout()</span>
<span class="line-added">636 {</span>
<span class="line-added">637     return hasSimpleLineLayout() ? WTF::get&lt;Ref&lt;SimpleLineLayout::Layout&gt;&gt;(m_lineLayout).ptr() : nullptr;</span>
638 }
639 
<span class="line-added">640 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">641 inline bool RenderBlockFlow::hasLayoutFormattingContextLineLayout() const</span>
<span class="line-added">642 {</span>
<span class="line-added">643     return WTF::holds_alternative&lt;std::unique_ptr&lt;LayoutIntegration::LineLayout&gt;&gt;(m_lineLayout);</span>
<span class="line-added">644 }</span>
<span class="line-added">645 </span>
<span class="line-added">646 inline const LayoutIntegration::LineLayout* RenderBlockFlow::layoutFormattingContextLineLayout() const</span>
<span class="line-added">647 {</span>
<span class="line-added">648     return hasLayoutFormattingContextLineLayout() ? WTF::get&lt;std::unique_ptr&lt;LayoutIntegration::LineLayout&gt;&gt;(m_lineLayout).get() : nullptr;</span>
<span class="line-added">649 }</span>
<span class="line-added">650 </span>
<span class="line-added">651 inline LayoutIntegration::LineLayout* RenderBlockFlow::layoutFormattingContextLineLayout()</span>
<span class="line-added">652 {</span>
<span class="line-added">653     return hasLayoutFormattingContextLineLayout() ? WTF::get&lt;std::unique_ptr&lt;LayoutIntegration::LineLayout&gt;&gt;(m_lineLayout).get() : nullptr;</span>
<span class="line-added">654 }</span>
<span class="line-added">655 #endif</span>
<span class="line-added">656 </span>
657 } // namespace WebCore
658 
659 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderBlockFlow, isRenderBlockFlow())
</pre>
</td>
</tr>
</table>
<center><a href="RenderBlockFlow.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBox.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
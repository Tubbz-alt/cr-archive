<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPreciseLocalClobberize.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGPlan.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGPredictionInjectionPhase.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPreciseLocalClobberize.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 51,11 ***</span>
              if (heap.payload().isTop()) {
                  readTop();
                  return;
              }
  
<span class="line-modified">!             callIfAppropriate(m_read, VirtualRegister(heap.payload().value32()));</span>
              return;
          }
  
          if (heap.overlaps(Stack)) {
              readTop();
<span class="line-new-header">--- 51,11 ---</span>
              if (heap.payload().isTop()) {
                  readTop();
                  return;
              }
  
<span class="line-modified">!             callIfAppropriate(m_read, heap.operand());</span>
              return;
          }
  
          if (heap.overlaps(Stack)) {
              readTop();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,11 ***</span>
      void write(AbstractHeap heap)
      {
          // We expect stack writes to already be precisely characterized by DFG::clobberize().
          if (heap.kind() == Stack) {
              RELEASE_ASSERT(!heap.payload().isTop());
<span class="line-modified">!             callIfAppropriate(m_unconditionalWrite, VirtualRegister(heap.payload().value32()));</span>
              return;
          }
  
          RELEASE_ASSERT(!heap.overlaps(Stack));
      }
<span class="line-new-header">--- 66,11 ---</span>
      void write(AbstractHeap heap)
      {
          // We expect stack writes to already be precisely characterized by DFG::clobberize().
          if (heap.kind() == Stack) {
              RELEASE_ASSERT(!heap.payload().isTop());
<span class="line-modified">!             callIfAppropriate(m_unconditionalWrite, heap.operand());</span>
              return;
          }
  
          RELEASE_ASSERT(!heap.overlaps(Stack));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 85,16 ***</span>
          if (location.kind() != StackLoc)
              return;
  
          RELEASE_ASSERT(location.heap().kind() == Stack);
  
<span class="line-modified">!         m_def(VirtualRegister(location.heap().payload().value32()), node);</span>
      }
  
  private:
      template&lt;typename Functor&gt;
<span class="line-modified">!     void callIfAppropriate(const Functor&amp; functor, VirtualRegister operand)</span>
      {
          if (operand.isLocal() &amp;&amp; static_cast&lt;unsigned&gt;(operand.toLocal()) &gt;= m_graph.block(0)-&gt;variablesAtHead.numberOfLocals())
              return;
  
          if (operand.isArgument() &amp;&amp; !operand.isHeader() &amp;&amp; static_cast&lt;unsigned&gt;(operand.toArgument()) &gt;= m_graph.block(0)-&gt;variablesAtHead.numberOfArguments())
<span class="line-new-header">--- 85,16 ---</span>
          if (location.kind() != StackLoc)
              return;
  
          RELEASE_ASSERT(location.heap().kind() == Stack);
  
<span class="line-modified">!         m_def(location.heap().operand(), node);</span>
      }
  
  private:
      template&lt;typename Functor&gt;
<span class="line-modified">!     void callIfAppropriate(const Functor&amp; functor, Operand operand)</span>
      {
          if (operand.isLocal() &amp;&amp; static_cast&lt;unsigned&gt;(operand.toLocal()) &gt;= m_graph.block(0)-&gt;variablesAtHead.numberOfLocals())
              return;
  
          if (operand.isArgument() &amp;&amp; !operand.isHeader() &amp;&amp; static_cast&lt;unsigned&gt;(operand.toArgument()) &gt;= m_graph.block(0)-&gt;variablesAtHead.numberOfArguments())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 107,19 ***</span>
      {
          auto readFrame = [&amp;] (InlineCallFrame* inlineCallFrame, unsigned numberOfArgumentsToSkip) {
              if (!inlineCallFrame) {
                  // Read the outermost arguments and argument count.
                  for (unsigned i = numberOfArgumentsToSkip; i &lt; static_cast&lt;unsigned&gt;(m_graph.m_codeBlock-&gt;numParameters()); i++)
<span class="line-modified">!                     m_read(virtualRegisterForArgument(i));</span>
<span class="line-modified">!                 m_read(VirtualRegister(CallFrameSlot::argumentCount));</span>
                  return;
              }
  
              for (unsigned i = numberOfArgumentsToSkip; i &lt; inlineCallFrame-&gt;argumentsWithFixup.size(); i++)
<span class="line-modified">!                 m_read(VirtualRegister(inlineCallFrame-&gt;stackOffset + virtualRegisterForArgument(i).offset()));</span>
              if (inlineCallFrame-&gt;isVarargs())
<span class="line-modified">!                 m_read(VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount));</span>
          };
  
          auto readSpread = [&amp;] (Node* spread) {
              ASSERT(spread-&gt;op() == Spread || spread-&gt;op() == PhantomSpread);
              if (!spread-&gt;child1()-&gt;isPhantomAllocation())
<span class="line-new-header">--- 107,19 ---</span>
      {
          auto readFrame = [&amp;] (InlineCallFrame* inlineCallFrame, unsigned numberOfArgumentsToSkip) {
              if (!inlineCallFrame) {
                  // Read the outermost arguments and argument count.
                  for (unsigned i = numberOfArgumentsToSkip; i &lt; static_cast&lt;unsigned&gt;(m_graph.m_codeBlock-&gt;numParameters()); i++)
<span class="line-modified">!                     m_read(virtualRegisterForArgumentIncludingThis(i));</span>
<span class="line-modified">!                 m_read(VirtualRegister(CallFrameSlot::argumentCountIncludingThis));</span>
                  return;
              }
  
              for (unsigned i = numberOfArgumentsToSkip; i &lt; inlineCallFrame-&gt;argumentsWithFixup.size(); i++)
<span class="line-modified">!                 m_read(VirtualRegister(inlineCallFrame-&gt;stackOffset + virtualRegisterForArgumentIncludingThis(i).offset()));</span>
              if (inlineCallFrame-&gt;isVarargs())
<span class="line-modified">!                 m_read(VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCountIncludingThis));</span>
          };
  
          auto readSpread = [&amp;] (Node* spread) {
              ASSERT(spread-&gt;op() == Spread || spread-&gt;op() == PhantomSpread);
              if (!spread-&gt;child1()-&gt;isPhantomAllocation())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 156,10 ***</span>
<span class="line-new-header">--- 156,11 ---</span>
          case GetMyArgumentByVal:
          case GetMyArgumentByValOutOfBounds:
          case CreateDirectArguments:
          case CreateScopedArguments:
          case CreateClonedArguments:
<span class="line-added">+         case CreateArgumentsButterfly:</span>
          case PhantomDirectArguments:
          case PhantomClonedArguments:
          case GetRestLength:
          case CreateRest: {
              bool isForwardingNode = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 222,43 ***</span>
          case GetArgument: {
              InlineCallFrame* inlineCallFrame = m_node-&gt;origin.semantic.inlineCallFrame();
              unsigned indexIncludingThis = m_node-&gt;argumentIndex();
              if (!inlineCallFrame) {
                  if (indexIncludingThis &lt; static_cast&lt;unsigned&gt;(m_graph.m_codeBlock-&gt;numParameters()))
<span class="line-modified">!                     m_read(virtualRegisterForArgument(indexIncludingThis));</span>
<span class="line-modified">!                 m_read(VirtualRegister(CallFrameSlot::argumentCount));</span>
                  break;
              }
  
              ASSERT_WITH_MESSAGE(inlineCallFrame-&gt;isVarargs(), &quot;GetArgument is only used for InlineCallFrame if the call frame is varargs.&quot;);
              if (indexIncludingThis &lt; inlineCallFrame-&gt;argumentsWithFixup.size())
<span class="line-modified">!                 m_read(VirtualRegister(inlineCallFrame-&gt;stackOffset + virtualRegisterForArgument(indexIncludingThis).offset()));</span>
<span class="line-modified">!             m_read(VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount));</span>
              break;
          }
  
          default: {
              // All of the outermost arguments, except this, are read in sloppy mode.
              if (!m_graph.m_codeBlock-&gt;isStrictMode()) {
                  for (unsigned i = m_graph.m_codeBlock-&gt;numParameters(); i--;)
<span class="line-modified">!                     m_read(virtualRegisterForArgument(i));</span>
              }
  
              // The stack header is read.
              for (unsigned i = 0; i &lt; CallFrameSlot::thisArgument; ++i)
                  m_read(VirtualRegister(i));
  
              // Read all of the inline arguments and call frame headers that we didn&#39;t already capture.
              for (InlineCallFrame* inlineCallFrame = m_node-&gt;origin.semantic.inlineCallFrame(); inlineCallFrame; inlineCallFrame = inlineCallFrame-&gt;getCallerInlineFrameSkippingTailCalls()) {
                  if (!inlineCallFrame-&gt;isStrictMode()) {
                      for (unsigned i = inlineCallFrame-&gt;argumentsWithFixup.size(); i--;)
<span class="line-modified">!                         m_read(VirtualRegister(inlineCallFrame-&gt;stackOffset + virtualRegisterForArgument(i).offset()));</span>
                  }
                  if (inlineCallFrame-&gt;isClosureCall)
                      m_read(VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee));
                  if (inlineCallFrame-&gt;isVarargs())
<span class="line-modified">!                     m_read(VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount));</span>
              }
              break;
          } }
      }
  
<span class="line-new-header">--- 223,43 ---</span>
          case GetArgument: {
              InlineCallFrame* inlineCallFrame = m_node-&gt;origin.semantic.inlineCallFrame();
              unsigned indexIncludingThis = m_node-&gt;argumentIndex();
              if (!inlineCallFrame) {
                  if (indexIncludingThis &lt; static_cast&lt;unsigned&gt;(m_graph.m_codeBlock-&gt;numParameters()))
<span class="line-modified">!                     m_read(virtualRegisterForArgumentIncludingThis(indexIncludingThis));</span>
<span class="line-modified">!                 m_read(VirtualRegister(CallFrameSlot::argumentCountIncludingThis));</span>
                  break;
              }
  
              ASSERT_WITH_MESSAGE(inlineCallFrame-&gt;isVarargs(), &quot;GetArgument is only used for InlineCallFrame if the call frame is varargs.&quot;);
              if (indexIncludingThis &lt; inlineCallFrame-&gt;argumentsWithFixup.size())
<span class="line-modified">!                 m_read(VirtualRegister(inlineCallFrame-&gt;stackOffset + virtualRegisterForArgumentIncludingThis(indexIncludingThis).offset()));</span>
<span class="line-modified">!             m_read(VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCountIncludingThis));</span>
              break;
          }
  
          default: {
              // All of the outermost arguments, except this, are read in sloppy mode.
              if (!m_graph.m_codeBlock-&gt;isStrictMode()) {
                  for (unsigned i = m_graph.m_codeBlock-&gt;numParameters(); i--;)
<span class="line-modified">!                     m_read(virtualRegisterForArgumentIncludingThis(i));</span>
              }
  
              // The stack header is read.
              for (unsigned i = 0; i &lt; CallFrameSlot::thisArgument; ++i)
                  m_read(VirtualRegister(i));
  
              // Read all of the inline arguments and call frame headers that we didn&#39;t already capture.
              for (InlineCallFrame* inlineCallFrame = m_node-&gt;origin.semantic.inlineCallFrame(); inlineCallFrame; inlineCallFrame = inlineCallFrame-&gt;getCallerInlineFrameSkippingTailCalls()) {
                  if (!inlineCallFrame-&gt;isStrictMode()) {
                      for (unsigned i = inlineCallFrame-&gt;argumentsWithFixup.size(); i--;)
<span class="line-modified">!                         m_read(VirtualRegister(inlineCallFrame-&gt;stackOffset + virtualRegisterForArgumentIncludingThis(i).offset()));</span>
                  }
                  if (inlineCallFrame-&gt;isClosureCall)
                      m_read(VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee));
                  if (inlineCallFrame-&gt;isVarargs())
<span class="line-modified">!                     m_read(VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCountIncludingThis));</span>
              }
              break;
          } }
      }
  
</pre>
<center><a href="DFGPlan.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGPredictionInjectionPhase.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
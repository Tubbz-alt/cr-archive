<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DirectArguments.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DirectArguments.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DirectEvalExecutable.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DirectArguments.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 48,11 ***</span>
  public:
      template&lt;typename CellType, SubspaceAccess&gt;
      static CompleteSubspace* subspaceFor(VM&amp; vm)
      {
          static_assert(!CellType::needsDestruction, &quot;&quot;);
<span class="line-modified">!         return &amp;vm.jsValueGigacageCellSpace;</span>
      }
  
      // Creates an arguments object but leaves it uninitialized. This is dangerous if we GC right
      // after allocation.
      static DirectArguments* createUninitialized(VM&amp;, Structure*, unsigned length, unsigned capacity);
<span class="line-new-header">--- 48,11 ---</span>
  public:
      template&lt;typename CellType, SubspaceAccess&gt;
      static CompleteSubspace* subspaceFor(VM&amp; vm)
      {
          static_assert(!CellType::needsDestruction, &quot;&quot;);
<span class="line-modified">!         return &amp;vm.variableSizedCellSpace;</span>
      }
  
      // Creates an arguments object but leaves it uninitialized. This is dangerous if we GC right
      // after allocation.
      static DirectArguments* createUninitialized(VM&amp;, Structure*, unsigned length, unsigned capacity);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 60,28 ***</span>
      // Creates an arguments object and initializes everything to the empty value. Use this if you
      // cannot guarantee that you&#39;ll immediately initialize all of the elements.
      static DirectArguments* create(VM&amp;, Structure*, unsigned length, unsigned capacity);
  
      // Creates an arguments object by copying the argumnets from the stack.
<span class="line-modified">!     static DirectArguments* createByCopying(ExecState*);</span>
  
      static size_t estimatedSize(JSCell*, VM&amp;);
      static void visitChildren(JSCell*, SlotVisitor&amp;);
  
      uint32_t internalLength() const
      {
          return m_length;
      }
  
<span class="line-modified">!     uint32_t length(ExecState* exec) const</span>
      {
          if (UNLIKELY(m_mappedArguments)) {
<span class="line-modified">!             VM&amp; vm = exec-&gt;vm();</span>
              auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!             JSValue value = get(exec, vm.propertyNames-&gt;length);</span>
              RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">!             RELEASE_AND_RETURN(scope, value.toUInt32(exec));</span>
          }
          return m_length;
      }
  
      bool isMappedArgument(uint32_t i) const
<span class="line-new-header">--- 60,28 ---</span>
      // Creates an arguments object and initializes everything to the empty value. Use this if you
      // cannot guarantee that you&#39;ll immediately initialize all of the elements.
      static DirectArguments* create(VM&amp;, Structure*, unsigned length, unsigned capacity);
  
      // Creates an arguments object by copying the argumnets from the stack.
<span class="line-modified">!     static DirectArguments* createByCopying(JSGlobalObject*, CallFrame*);</span>
  
      static size_t estimatedSize(JSCell*, VM&amp;);
      static void visitChildren(JSCell*, SlotVisitor&amp;);
  
      uint32_t internalLength() const
      {
          return m_length;
      }
  
<span class="line-modified">!     uint32_t length(JSGlobalObject* globalObject) const</span>
      {
          if (UNLIKELY(m_mappedArguments)) {
<span class="line-modified">!             VM&amp; vm = getVM(globalObject);</span>
              auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!             JSValue value = get(globalObject, vm.propertyNames-&gt;length);</span>
              RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">!             RELEASE_AND_RETURN(scope, value.toUInt32(globalObject));</span>
          }
          return m_length;
      }
  
      bool isMappedArgument(uint32_t i) const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 123,30 ***</span>
          return storage()[offset.offset()];
      }
  
      // Methods intended for use by the GenericArguments mixin.
      bool overrodeThings() const { return !!m_mappedArguments; }
<span class="line-modified">!     void overrideThings(VM&amp;);</span>
<span class="line-modified">!     void overrideThingsIfNecessary(VM&amp;);</span>
<span class="line-modified">!     void unmapArgument(VM&amp;, unsigned index);</span>
  
<span class="line-modified">!     void initModifiedArgumentsDescriptorIfNecessary(VM&amp; vm)</span>
      {
<span class="line-modified">!         GenericArguments&lt;DirectArguments&gt;::initModifiedArgumentsDescriptorIfNecessary(vm, m_length);</span>
      }
  
<span class="line-modified">!     void setModifiedArgumentDescriptor(VM&amp; vm, unsigned index)</span>
      {
<span class="line-modified">!         GenericArguments&lt;DirectArguments&gt;::setModifiedArgumentDescriptor(vm, index, m_length);</span>
      }
  
      bool isModifiedArgumentDescriptor(unsigned index)
      {
          return GenericArguments&lt;DirectArguments&gt;::isModifiedArgumentDescriptor(index, m_length);
      }
  
<span class="line-modified">!     void copyToArguments(ExecState*, VirtualRegister firstElementDest, unsigned offset, unsigned length);</span>
  
      DECLARE_INFO;
  
      static Structure* createStructure(VM&amp;, JSGlobalObject*, JSValue prototype);
  
<span class="line-new-header">--- 123,30 ---</span>
          return storage()[offset.offset()];
      }
  
      // Methods intended for use by the GenericArguments mixin.
      bool overrodeThings() const { return !!m_mappedArguments; }
<span class="line-modified">!     void overrideThings(JSGlobalObject*);</span>
<span class="line-modified">!     void overrideThingsIfNecessary(JSGlobalObject*);</span>
<span class="line-modified">!     void unmapArgument(JSGlobalObject*, unsigned index);</span>
  
<span class="line-modified">!     void initModifiedArgumentsDescriptorIfNecessary(JSGlobalObject* globalObject)</span>
      {
<span class="line-modified">!         GenericArguments&lt;DirectArguments&gt;::initModifiedArgumentsDescriptorIfNecessary(globalObject, m_length);</span>
      }
  
<span class="line-modified">!     void setModifiedArgumentDescriptor(JSGlobalObject* globalObject, unsigned index)</span>
      {
<span class="line-modified">!         GenericArguments&lt;DirectArguments&gt;::setModifiedArgumentDescriptor(globalObject, index, m_length);</span>
      }
  
      bool isModifiedArgumentDescriptor(unsigned index)
      {
          return GenericArguments&lt;DirectArguments&gt;::isModifiedArgumentDescriptor(index, m_length);
      }
  
<span class="line-modified">!     void copyToArguments(JSGlobalObject*, JSValue* firstElementDest, unsigned offset, unsigned length);</span>
  
      DECLARE_INFO;
  
      static Structure* createStructure(VM&amp;, JSGlobalObject*, JSValue prototype);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 182,8 ***</span>
<span class="line-new-header">--- 182,10 ---</span>
      WriteBarrier&lt;JSFunction&gt; m_callee;
      uint32_t m_length; // Always the actual length of captured arguments and never what was stored into the length property.
      uint32_t m_minCapacity; // The max of this and length determines the capacity of this object. It may be the actual capacity, or maybe something smaller. We arrange it this way to be kind to the JITs.
      using MappedArguments = CagedBarrierPtr&lt;Gigacage::Primitive, bool&gt;;
      MappedArguments m_mappedArguments; // If non-null, it means that length, callee, and caller are fully materialized properties.
<span class="line-added">+ </span>
<span class="line-added">+     friend size_t cellSize(VM&amp;, JSCell*);</span>
  };
  
  } // namespace JSC
</pre>
<center><a href="DirectArguments.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DirectEvalExecutable.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
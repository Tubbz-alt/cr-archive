<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/bridge/runtime_object.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2003, 2008-2009, 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;runtime_object.h&quot;
 28 
 29 #include &quot;JSDOMBinding.h&quot;
 30 #include &quot;WebCoreJSClientData.h&quot;
 31 #include &quot;runtime_method.h&quot;
 32 #include &lt;JavaScriptCore/Error.h&gt;
 33 
 34 using namespace WebCore;
 35 
 36 namespace JSC {
 37 namespace Bindings {
 38 
 39 WEBCORE_EXPORT const ClassInfo RuntimeObject::s_info = { &quot;RuntimeObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(RuntimeObject) };
 40 
 41 RuntimeObject::RuntimeObject(VM&amp; vm, Structure* structure, RefPtr&lt;Instance&gt;&amp;&amp; instance)
 42     : Base(vm, structure)
 43     , m_instance(WTFMove(instance))
 44 {
 45 }
 46 
 47 void RuntimeObject::finishCreation(VM&amp; vm)
 48 {
 49     Base::finishCreation(vm);
 50     ASSERT(inherits(vm, info()));
 51 }
 52 
 53 void RuntimeObject::destroy(JSCell* cell)
 54 {
 55     static_cast&lt;RuntimeObject*&gt;(cell)-&gt;RuntimeObject::~RuntimeObject();
 56 }
 57 
 58 void RuntimeObject::invalidate()
 59 {
 60     ASSERT(m_instance);
 61     if (m_instance)
 62         m_instance-&gt;willInvalidateRuntimeObject();
 63     m_instance = nullptr;
 64 }
 65 
 66 EncodedJSValue RuntimeObject::fallbackObjectGetter(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName propertyName)
 67 {
 68     VM&amp; vm = lexicalGlobalObject-&gt;vm();
 69     auto scope = DECLARE_THROW_SCOPE(vm);
 70 
 71     RuntimeObject* thisObj = jsCast&lt;RuntimeObject*&gt;(JSValue::decode(thisValue));
 72     RefPtr&lt;Instance&gt; instance = thisObj-&gt;m_instance;
 73 
 74     if (!instance)
 75         return JSValue::encode(throwInvalidAccessError(lexicalGlobalObject, scope));
 76 
 77     instance-&gt;begin();
 78 
 79     Class *aClass = instance-&gt;getClass();
 80     JSValue result = aClass-&gt;fallbackObject(lexicalGlobalObject, instance.get(), propertyName);
 81 
 82     instance-&gt;end();
 83 
 84     return JSValue::encode(result);
 85 }
 86 
 87 EncodedJSValue RuntimeObject::fieldGetter(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName propertyName)
 88 {
 89     VM&amp; vm = lexicalGlobalObject-&gt;vm();
 90     auto scope = DECLARE_THROW_SCOPE(vm);
 91 
 92     RuntimeObject* thisObj = jsCast&lt;RuntimeObject*&gt;(JSValue::decode(thisValue));
 93     RefPtr&lt;Instance&gt; instance = thisObj-&gt;m_instance;
 94 
 95     if (!instance)
 96         return JSValue::encode(throwInvalidAccessError(lexicalGlobalObject, scope));
 97 
 98     instance-&gt;begin();
 99 
100     Class *aClass = instance-&gt;getClass();
101     Field* aField = aClass-&gt;fieldNamed(propertyName, instance.get());
102     JSValue result = aField-&gt;valueFromInstance(lexicalGlobalObject, instance.get());
103 
104     instance-&gt;end();
105 
106     return JSValue::encode(result);
107 }
108 
109 EncodedJSValue RuntimeObject::methodGetter(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName propertyName)
110 {
111     VM&amp; vm = lexicalGlobalObject-&gt;vm();
112     auto scope = DECLARE_THROW_SCOPE(vm);
113 
114     RuntimeObject* thisObj = jsCast&lt;RuntimeObject*&gt;(JSValue::decode(thisValue));
115     RefPtr&lt;Instance&gt; instance = thisObj-&gt;m_instance;
116 
117     if (!instance)
118         return JSValue::encode(throwInvalidAccessError(lexicalGlobalObject, scope));
119 
120     instance-&gt;begin();
121 
122     JSValue method = instance-&gt;getMethod(lexicalGlobalObject, propertyName);
123 
124     instance-&gt;end();
125 
126     return JSValue::encode(method);
127 }
128 
129 bool RuntimeObject::getOwnPropertySlot(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, PropertySlot&amp; slot)
130 {
131     VM&amp; vm = lexicalGlobalObject-&gt;vm();
132     auto scope = DECLARE_THROW_SCOPE(vm);
133 
134     RuntimeObject* thisObject = jsCast&lt;RuntimeObject*&gt;(object);
135     if (!thisObject-&gt;m_instance) {
136         throwInvalidAccessError(lexicalGlobalObject, scope);
137         return false;
138     }
139 
140     RefPtr&lt;Instance&gt; instance = thisObject-&gt;m_instance;
141 
142     instance-&gt;begin();
143 
144     Class *aClass = instance-&gt;getClass();
145 
146     if (aClass) {
147         // See if the instance has a field with the specified name.
148         Field *aField = aClass-&gt;fieldNamed(propertyName, instance.get());
149         if (aField) {
150             slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontDelete), thisObject-&gt;fieldGetter);
151             instance-&gt;end();
152             return true;
153         } else {
154             // Now check if a method with specified name exists, if so return a function object for
155             // that method.
156             if (aClass-&gt;methodNamed(propertyName, instance.get())) {
157                 slot.setCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, thisObject-&gt;methodGetter);
158 
159                 instance-&gt;end();
160                 return true;
161             }
162         }
163 
164         // Try a fallback object.
165         if (!aClass-&gt;fallbackObject(lexicalGlobalObject, instance.get(), propertyName).isUndefined()) {
166             slot.setCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;fallbackObjectGetter);
167             instance-&gt;end();
168             return true;
169         }
170     }
171 
172     instance-&gt;end();
173 
174     return instance-&gt;getOwnPropertySlot(thisObject, lexicalGlobalObject, propertyName, slot);
175 }
176 
177 bool RuntimeObject::put(JSCell* cell, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
178 {
179     VM&amp; vm = lexicalGlobalObject-&gt;vm();
180     auto scope = DECLARE_THROW_SCOPE(vm);
181 
182     RuntimeObject* thisObject = jsCast&lt;RuntimeObject*&gt;(cell);
183     if (!thisObject-&gt;m_instance) {
184         throwInvalidAccessError(lexicalGlobalObject, scope);
185         return false;
186     }
187 
188     RefPtr&lt;Instance&gt; instance = thisObject-&gt;m_instance;
189     instance-&gt;begin();
190 
191     // Set the value of the property.
192     bool result = false;
193     Field *aField = instance-&gt;getClass()-&gt;fieldNamed(propertyName, instance.get());
194     if (aField)
195         result = aField-&gt;setValueToInstance(lexicalGlobalObject, instance.get(), value);
196     else if (!instance-&gt;setValueOfUndefinedField(lexicalGlobalObject, propertyName, value))
197         result = instance-&gt;put(thisObject, lexicalGlobalObject, propertyName, value, slot);
198 
199     instance-&gt;end();
200     return result;
201 }
202 
203 bool RuntimeObject::deleteProperty(JSCell*, JSGlobalObject*, PropertyName)
204 {
205     // Can never remove a property of a RuntimeObject.
206     return false;
207 }
208 
209 JSValue RuntimeObject::defaultValue(const JSObject* object, JSGlobalObject* lexicalGlobalObject, PreferredPrimitiveType hint)
210 {
211     VM&amp; vm = lexicalGlobalObject-&gt;vm();
212     auto scope = DECLARE_THROW_SCOPE(vm);
213 
214     const RuntimeObject* thisObject = jsCast&lt;const RuntimeObject*&gt;(object);
215     if (!thisObject-&gt;m_instance)
216         return throwInvalidAccessError(lexicalGlobalObject, scope);
217 
218     RefPtr&lt;Instance&gt; instance = thisObject-&gt;m_instance;
219 
220     instance-&gt;begin();
221     JSValue result = instance-&gt;defaultValue(lexicalGlobalObject, hint);
222     instance-&gt;end();
223     return result;
224 }
225 
226 static EncodedJSValue JSC_HOST_CALL callRuntimeObject(JSGlobalObject* globalObject, CallFrame* callFrame)
227 {
228     ASSERT_UNUSED(globalObject, callFrame-&gt;jsCallee()-&gt;inherits&lt;RuntimeObject&gt;(globalObject-&gt;vm()));
229     RefPtr&lt;Instance&gt; instance(static_cast&lt;RuntimeObject*&gt;(callFrame-&gt;jsCallee())-&gt;getInternalInstance());
230     instance-&gt;begin();
231     JSValue result = instance-&gt;invokeDefaultMethod(globalObject, callFrame);
232     instance-&gt;end();
233     return JSValue::encode(result);
234 }
235 
236 CallType RuntimeObject::getCallData(JSCell* cell, CallData&amp; callData)
237 {
238     RuntimeObject* thisObject = jsCast&lt;RuntimeObject*&gt;(cell);
239     if (!thisObject-&gt;m_instance)
240         return CallType::None;
241 
242     RefPtr&lt;Instance&gt; instance = thisObject-&gt;m_instance;
243     if (!instance-&gt;supportsInvokeDefaultMethod())
244         return CallType::None;
245 
246     callData.native.function = callRuntimeObject;
247     return CallType::Host;
248 }
249 
250 static EncodedJSValue JSC_HOST_CALL callRuntimeConstructor(JSGlobalObject* globalObject, CallFrame* callFrame)
251 {
252     JSObject* constructor = callFrame-&gt;jsCallee();
253     ASSERT_UNUSED(globalObject, constructor-&gt;inherits&lt;RuntimeObject&gt;(globalObject-&gt;vm()));
254     RefPtr&lt;Instance&gt; instance(static_cast&lt;RuntimeObject*&gt;(callFrame-&gt;jsCallee())-&gt;getInternalInstance());
255     instance-&gt;begin();
256     ArgList args(callFrame);
257     JSValue result = instance-&gt;invokeConstruct(globalObject, callFrame, args);
258     instance-&gt;end();
259 
260     ASSERT(result);
261     return JSValue::encode(result.isObject() ? jsCast&lt;JSObject*&gt;(result.asCell()) : constructor);
262 }
263 
264 ConstructType RuntimeObject::getConstructData(JSCell* cell, ConstructData&amp; constructData)
265 {
266     RuntimeObject* thisObject = jsCast&lt;RuntimeObject*&gt;(cell);
267     if (!thisObject-&gt;m_instance)
268         return ConstructType::None;
269 
270     RefPtr&lt;Instance&gt; instance = thisObject-&gt;m_instance;
271     if (!instance-&gt;supportsConstruct())
272         return ConstructType::None;
273 
274     constructData.native.function = callRuntimeConstructor;
275     return ConstructType::Host;
276 }
277 
278 void RuntimeObject::getOwnPropertyNames(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyNameArray&amp; propertyNames, EnumerationMode)
279 {
280     VM&amp; vm = lexicalGlobalObject-&gt;vm();
281     auto scope = DECLARE_THROW_SCOPE(vm);
282 
283     RuntimeObject* thisObject = jsCast&lt;RuntimeObject*&gt;(object);
284     if (!thisObject-&gt;m_instance) {
285         throwInvalidAccessError(lexicalGlobalObject, scope);
286         return;
287     }
288 
289     RefPtr&lt;Instance&gt; instance = thisObject-&gt;m_instance;
290 
291     instance-&gt;begin();
292     instance-&gt;getPropertyNames(lexicalGlobalObject, propertyNames);
293     instance-&gt;end();
294 }
295 
296 Exception* RuntimeObject::throwInvalidAccessError(JSGlobalObject* lexicalGlobalObject, ThrowScope&amp; scope)
297 {
298     return throwException(lexicalGlobalObject, scope, createReferenceError(lexicalGlobalObject, &quot;Trying to access object from destroyed plug-in.&quot;));
299 }
300 
301 JSC::IsoSubspace* RuntimeObject::subspaceForImpl(JSC::VM&amp; vm)
302 {
303     return &amp;static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;runtimeObjectSpace();
304 }
305 
306 }
307 }
    </pre>
  </body>
</html>
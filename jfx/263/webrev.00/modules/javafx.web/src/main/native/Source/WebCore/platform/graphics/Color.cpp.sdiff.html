<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Color.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BitmapImage.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Color.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Color.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2003, 2004, 2005, 2006, 2008 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;Color.h&quot;
 28 
 29 #include &quot;AnimationUtilities.h&quot;

 30 #include &quot;HashTools.h&quot;
 31 #include &lt;wtf/Assertions.h&gt;
 32 #include &lt;wtf/HexNumber.h&gt;
 33 #include &lt;wtf/MathExtras.h&gt;
 34 #include &lt;wtf/text/StringBuilder.h&gt;
 35 #include &lt;wtf/text/TextStream.h&gt;
 36 
 37 namespace WebCore {
 38 
<span class="line-modified"> 39 #if !COMPILER(MSVC)</span>
<span class="line-modified"> 40 const RGBA32 Color::black;</span>
<span class="line-removed"> 41 const RGBA32 Color::white;</span>
<span class="line-removed"> 42 const RGBA32 Color::darkGray;</span>
<span class="line-removed"> 43 const RGBA32 Color::gray;</span>
<span class="line-removed"> 44 const RGBA32 Color::lightGray;</span>
<span class="line-removed"> 45 const RGBA32 Color::transparent;</span>
<span class="line-removed"> 46 #endif</span>
<span class="line-removed"> 47 </span>
<span class="line-removed"> 48 static const RGBA32 lightenedBlack = 0xFF545454;</span>
<span class="line-removed"> 49 static const RGBA32 darkenedWhite = 0xFFABABAB;</span>
 50 
 51 static inline unsigned premultipliedChannel(unsigned c, unsigned a, bool ceiling = true)
 52 {
 53     return fastDivideBy255(ceiling ? c * a + 254 : c * a);
 54 }
 55 
 56 static inline unsigned unpremultipliedChannel(unsigned c, unsigned a)
 57 {
 58     return (fastMultiplyBy255(c) + a - 1) / a;
 59 }
 60 
 61 RGBA32 makeRGB(int r, int g, int b)
 62 {
<span class="line-modified"> 63     return 0xFF000000 | std::max(0, std::min(r, 255)) &lt;&lt; 16 | std::max(0, std::min(g, 255)) &lt;&lt; 8 | std::max(0, std::min(b, 255));</span>
 64 }
 65 
 66 RGBA32 makeRGBA(int r, int g, int b, int a)
 67 {
<span class="line-modified"> 68     return std::max(0, std::min(a, 255)) &lt;&lt; 24 | std::max(0, std::min(r, 255)) &lt;&lt; 16 | std::max(0, std::min(g, 255)) &lt;&lt; 8 | std::max(0, std::min(b, 255));</span>
 69 }
 70 
 71 RGBA32 makePremultipliedRGBA(int r, int g, int b, int a, bool ceiling)
 72 {
 73     return makeRGBA(premultipliedChannel(r, a, ceiling), premultipliedChannel(g, a, ceiling), premultipliedChannel(b, a, ceiling), a);
 74 }
 75 
 76 RGBA32 makeUnPremultipliedRGBA(int r, int g, int b, int a)
 77 {
 78     return makeRGBA(unpremultipliedChannel(r, a), unpremultipliedChannel(g, a), unpremultipliedChannel(b, a), a);
 79 }
 80 
 81 static int colorFloatToRGBAByte(float f)
 82 {
 83     // We use lroundf and 255 instead of nextafterf(256, 0) to match CG&#39;s rounding
 84     return std::max(0, std::min(static_cast&lt;int&gt;(lroundf(255.0f * f)), 255));
 85 }
 86 
 87 RGBA32 makeRGBA32FromFloats(float r, float g, float b, float a)
 88 {
<span class="line-modified"> 89     return colorFloatToRGBAByte(a) &lt;&lt; 24 | colorFloatToRGBAByte(r) &lt;&lt; 16 | colorFloatToRGBAByte(g) &lt;&lt; 8 | colorFloatToRGBAByte(b);</span>
 90 }
 91 
 92 RGBA32 colorWithOverrideAlpha(RGBA32 color, float overrideAlpha)
 93 {
<span class="line-modified"> 94     RGBA32 rgbOnly = color &amp; 0x00FFFFFF;</span>
<span class="line-removed"> 95     RGBA32 rgba = rgbOnly | colorFloatToRGBAByte(overrideAlpha) &lt;&lt; 24;</span>
<span class="line-removed"> 96     return rgba;</span>
 97 }
 98 
<span class="line-modified"> 99 static double calcHue(double temp1, double temp2, double hueVal)</span>
<span class="line-removed">100 {</span>
<span class="line-removed">101     if (hueVal &lt; 0.0)</span>
<span class="line-removed">102         hueVal += 6.0;</span>
<span class="line-removed">103     else if (hueVal &gt;= 6.0)</span>
<span class="line-removed">104         hueVal -= 6.0;</span>
<span class="line-removed">105     if (hueVal &lt; 1.0)</span>
<span class="line-removed">106         return temp1 + (temp2 - temp1) * hueVal;</span>
<span class="line-removed">107     if (hueVal &lt; 3.0)</span>
<span class="line-removed">108         return temp2;</span>
<span class="line-removed">109     if (hueVal &lt; 4.0)</span>
<span class="line-removed">110         return temp1 + (temp2 - temp1) * (4.0 - hueVal);</span>
<span class="line-removed">111     return temp1;</span>
<span class="line-removed">112 }</span>
<span class="line-removed">113 </span>
<span class="line-removed">114 // Explanation of this algorithm can be found in the CSS Color 4 Module</span>
<span class="line-removed">115 // specification at https://drafts.csswg.org/css-color-4/#hsl-to-rgb with</span>
<span class="line-removed">116 // further explanation available at http://en.wikipedia.org/wiki/HSL_color_space</span>
<span class="line-removed">117 </span>
<span class="line-removed">118 // Hue is in the range of 0 to 6.0, the remainder are in the range 0 to 1.0</span>
<span class="line-removed">119 // FIXME: Use HSLToSRGB().</span>
<span class="line-removed">120 RGBA32 makeRGBAFromHSLA(double hue, double saturation, double lightness, double alpha)</span>
121 {
<span class="line-modified">122     const double scaleFactor = nextafter(256.0, 0.0);</span>
<span class="line-modified">123 </span>
<span class="line-modified">124     if (!saturation) {</span>
<span class="line-modified">125         int greyValue = static_cast&lt;int&gt;(lightness * scaleFactor);</span>
<span class="line-modified">126         return makeRGBA(greyValue, greyValue, greyValue, static_cast&lt;int&gt;(alpha * scaleFactor));</span>
<span class="line-modified">127     }</span>
<span class="line-modified">128 </span>
<span class="line-removed">129     double temp2 = lightness &lt;= 0.5 ? lightness * (1.0 + saturation) : lightness + saturation - lightness * saturation;</span>
<span class="line-removed">130     double temp1 = 2.0 * lightness - temp2;</span>
<span class="line-removed">131 </span>
<span class="line-removed">132     return makeRGBA(static_cast&lt;int&gt;(calcHue(temp1, temp2, hue + 2.0) * scaleFactor),</span>
<span class="line-removed">133                     static_cast&lt;int&gt;(calcHue(temp1, temp2, hue) * scaleFactor),</span>
<span class="line-removed">134                     static_cast&lt;int&gt;(calcHue(temp1, temp2, hue - 2.0) * scaleFactor),</span>
<span class="line-removed">135                     static_cast&lt;int&gt;(alpha * scaleFactor));</span>
136 }
137 
138 RGBA32 makeRGBAFromCMYKA(float c, float m, float y, float k, float a)
139 {
140     double colors = 1 - k;
141     int r = static_cast&lt;int&gt;(nextafter(256, 0) * (colors * (1 - c)));
142     int g = static_cast&lt;int&gt;(nextafter(256, 0) * (colors * (1 - m)));
143     int b = static_cast&lt;int&gt;(nextafter(256, 0) * (colors * (1 - y)));
144     return makeRGBA(r, g, b, static_cast&lt;float&gt;(nextafter(256, 0) * a));
145 }
146 
147 // originally moved here from the CSS parser
148 template &lt;typename CharacterType&gt;
149 static inline bool parseHexColorInternal(const CharacterType* name, unsigned length, RGBA32&amp; rgb)
150 {
151     if (length != 3 &amp;&amp; length != 4 &amp;&amp; length != 6 &amp;&amp; length != 8)
152         return false;
153     unsigned value = 0;
154     for (unsigned i = 0; i &lt; length; ++i) {
155         if (!isASCIIHexDigit(name[i]))
156             return false;
157         value &lt;&lt;= 4;
158         value |= toASCIIHexValue(name[i]);
159     }
160     if (length == 6) {
<span class="line-modified">161         rgb = 0xFF000000 | value;</span>
162         return true;
163     }
164     if (length == 8) {
165         // We parsed the values into RGBA order, but the RGBA32 type
166         // expects them to be in ARGB order, so we right rotate eight bits.
<span class="line-modified">167         rgb = value &lt;&lt; 24 | value &gt;&gt; 8;</span>
168         return true;
169     }
170     if (length == 4) {
171         // #abcd converts to ddaabbcc in RGBA32.
<span class="line-modified">172         rgb = (value &amp; 0xF) &lt;&lt; 28 | (value &amp; 0xF) &lt;&lt; 24</span>
173             | (value &amp; 0xF000) &lt;&lt; 8 | (value &amp; 0xF000) &lt;&lt; 4
174             | (value &amp; 0xF00) &lt;&lt; 4 | (value &amp; 0xF00)
<span class="line-modified">175             | (value &amp; 0xF0) | (value &amp; 0xF0) &gt;&gt; 4;</span>
176         return true;
177     }
178     // #abc converts to #aabbcc
<span class="line-modified">179     rgb = 0xFF000000</span>
180         | (value &amp; 0xF00) &lt;&lt; 12 | (value &amp; 0xF00) &lt;&lt; 8
181         | (value &amp; 0xF0) &lt;&lt; 8 | (value &amp; 0xF0) &lt;&lt; 4
<span class="line-modified">182         | (value &amp; 0xF) &lt;&lt; 4 | (value &amp; 0xF);</span>
183     return true;
184 }
185 
186 bool Color::parseHexColor(const LChar* name, unsigned length, RGBA32&amp; rgb)
187 {
188     return parseHexColorInternal(name, length, rgb);
189 }
190 
191 bool Color::parseHexColor(const UChar* name, unsigned length, RGBA32&amp; rgb)
192 {
193     return parseHexColorInternal(name, length, rgb);
194 }
195 
196 bool Color::parseHexColor(const String&amp; name, RGBA32&amp; rgb)
197 {
198     unsigned length = name.length();
<span class="line-removed">199 </span>
200     if (!length)
201         return false;
202     if (name.is8Bit())
203         return parseHexColor(name.characters8(), name.length(), rgb);
204     return parseHexColor(name.characters16(), name.length(), rgb);
205 }
206 
207 bool Color::parseHexColor(const StringView&amp; name, RGBA32&amp; rgb)
208 {
209     unsigned length = name.length();
210     if (!length)
211         return false;
212     if (name.is8Bit())
213         return parseHexColor(name.characters8(), name.length(), rgb);
214     return parseHexColor(name.characters16(), name.length(), rgb);
215 }
216 
217 int differenceSquared(const Color&amp; c1, const Color&amp; c2)
218 {
219     // FIXME: This is assuming that the colors are in the same colorspace.
</pre>
<hr />
<pre>
246     }
247     buffer[length] = &#39;\0&#39;;
248     return findColor(buffer, length);
249 }
250 
251 Color::Color(const String&amp; name)
252 {
253     if (name[0] == &#39;#&#39;) {
254         RGBA32 color;
255         bool valid;
256 
257         if (name.is8Bit())
258             valid = parseHexColor(name.characters8() + 1, name.length() - 1, color);
259         else
260             valid = parseHexColor(name.characters16() + 1, name.length() - 1, color);
261 
262         if (valid)
263             setRGB(color);
264     } else {
265         if (auto* foundColor = findNamedColor(name))
<span class="line-modified">266             setRGB(foundColor-&gt;ARGBValue);</span>
<span class="line-removed">267         else</span>
<span class="line-removed">268             m_colorData.rgbaAndFlags = invalidRGBAColor;</span>
269     }
270 }
271 
272 Color::Color(const char* name)
273 {
<span class="line-modified">274     RGBA32 color;</span>
<span class="line-modified">275     bool valid;</span>
<span class="line-modified">276     if (name[0] == &#39;#&#39;)</span>
<span class="line-modified">277         valid = parseHexColor((String)&amp;name[1], color);</span>
<span class="line-modified">278     else {</span>
<span class="line-modified">279         const NamedColor* foundColor = findColor(name, strlen(name));</span>
<span class="line-removed">280         color = foundColor ? foundColor-&gt;ARGBValue : 0;</span>
<span class="line-removed">281         valid = foundColor;</span>
<span class="line-removed">282     }</span>
<span class="line-removed">283 </span>
<span class="line-removed">284     if (valid)</span>
<span class="line-removed">285         setRGB(color);</span>
286 }
287 
288 Color::Color(const Color&amp; other)
289     : m_colorData(other.m_colorData)
290 {
291     if (isExtended())
292         m_colorData.extendedColor-&gt;ref();
293 }
294 
295 Color::Color(Color&amp;&amp; other)
296 {
297     *this = WTFMove(other);
298 }
299 
300 Color::Color(float r, float g, float b, float a, ColorSpace colorSpace)
301 {
302     // Zero the union, just in case a 32-bit system only assigns the
303     // top 32 bits when copying the extendedColor pointer below.
304     m_colorData.rgbaAndFlags = 0;
305     auto extendedColorRef = ExtendedColor::create(r, g, b, a, colorSpace);
</pre>
<hr />
<pre>
319 
320     if (isExtended())
321         m_colorData.extendedColor-&gt;ref();
322     return *this;
323 }
324 
325 Color&amp; Color::operator=(Color&amp;&amp; other)
326 {
327     if (*this == other)
328         return *this;
329 
330     if (isExtended())
331         m_colorData.extendedColor-&gt;deref();
332 
333     m_colorData = other.m_colorData;
334     other.m_colorData.rgbaAndFlags = invalidRGBAColor;
335 
336     return *this;
337 }
338 







339 String Color::serialized() const
340 {
341     if (isExtended())
342         return asExtended().cssText();


343 
<span class="line-modified">344     if (isOpaque()) {</span>
<span class="line-modified">345         StringBuilder builder;</span>
<span class="line-modified">346         builder.reserveCapacity(7);</span>
<span class="line-modified">347         builder.append(&#39;#&#39;);</span>
<span class="line-modified">348         appendByteAsHex(red(), builder, Lowercase);</span>
<span class="line-removed">349         appendByteAsHex(green(), builder, Lowercase);</span>
<span class="line-removed">350         appendByteAsHex(blue(), builder, Lowercase);</span>
<span class="line-removed">351         return builder.toString();</span>
<span class="line-removed">352     }</span>
353 
<span class="line-modified">354     return cssText();</span>




















355 }
356 
357 String Color::cssText() const
358 {
359     if (isExtended())
360         return asExtended().cssText();


361 
<span class="line-modified">362     StringBuilder builder;</span>
<span class="line-modified">363     builder.reserveCapacity(28);</span>
<span class="line-modified">364     bool colorHasAlpha = !isOpaque();</span>
<span class="line-modified">365     if (colorHasAlpha)</span>
<span class="line-modified">366         builder.appendLiteral(&quot;rgba(&quot;);</span>
<span class="line-removed">367     else</span>
<span class="line-removed">368         builder.appendLiteral(&quot;rgb(&quot;);</span>
<span class="line-removed">369 </span>
<span class="line-removed">370     builder.appendNumber(static_cast&lt;unsigned char&gt;(red()));</span>
<span class="line-removed">371     builder.appendLiteral(&quot;, &quot;);</span>
<span class="line-removed">372 </span>
<span class="line-removed">373     builder.appendNumber(static_cast&lt;unsigned char&gt;(green()));</span>
<span class="line-removed">374     builder.appendLiteral(&quot;, &quot;);</span>
<span class="line-removed">375 </span>
<span class="line-removed">376 </span>
<span class="line-removed">377     builder.appendNumber(static_cast&lt;unsigned char&gt;(blue()));</span>
<span class="line-removed">378     if (colorHasAlpha) {</span>
<span class="line-removed">379         builder.appendLiteral(&quot;, &quot;);</span>
<span class="line-removed">380         builder.appendFixedPrecisionNumber(alpha() / 255.0f);</span>
<span class="line-removed">381     }</span>
<span class="line-removed">382 </span>
<span class="line-removed">383     builder.append(&#39;)&#39;);</span>
<span class="line-removed">384     return builder.toString();</span>
385 }
386 
387 String Color::nameForRenderTreeAsText() const
388 {
<span class="line-modified">389     // FIXME: Handle ExtendedColors.</span>
<span class="line-modified">390     if (alpha() &lt; 0xFF)</span>
<span class="line-removed">391         return makeString(&#39;#&#39;, hex(red(), 2), hex(green(), 2), hex(blue(), 2), hex(alpha(), 2));</span>
<span class="line-removed">392     return makeString(&#39;#&#39;, hex(red(), 2), hex(green(), 2), hex(blue(), 2));</span>
393 }
394 
395 Color Color::light() const
396 {
397     // Hardcode this common case for speed.
398     if (rgb() == black)
399         return lightenedBlack;
400 
401     const float scaleFactor = nextafterf(256.0f, 0.0f);
402 
403     float r, g, b, a;
404     getRGBA(r, g, b, a);
405 
406     float v = std::max(r, std::max(g, b));
407 
408     if (v == 0.0f)
409         // Lightened black with alpha.
410         return Color(0x54, 0x54, 0x54, alpha());
411 
412     float multiplier = std::min(1.0f, v + 0.33f) / v;
</pre>
<hr />
<pre>
590     else if (max == g)
591         hue = (60.0 * ((b - r) / chroma)) + 120.0;
592     else
593         hue = (60.0 * ((r - g) / chroma)) + 240.0;
594 
595     if (hue &gt;= 360.0)
596         hue -= 360.0;
597 
598     hue /= 360.0;
599 
600     if (!max)
601         saturation = 0;
602     else
603         saturation = chroma / max;
604 
605     value = max;
606 }
607 
608 Color colorFromPremultipliedARGB(RGBA32 pixelColor)
609 {
<span class="line-modified">610     int alpha = alphaChannel(pixelColor);</span>
<span class="line-modified">611     if (alpha &amp;&amp; alpha &lt; 255)</span>
<span class="line-modified">612         pixelColor = makeUnPremultipliedRGBA(redChannel(pixelColor), greenChannel(pixelColor), blueChannel(pixelColor), alpha);</span>
<span class="line-removed">613     return Color(pixelColor);</span>
614 }
615 
616 RGBA32 premultipliedARGBFromColor(const Color&amp; color)
617 {
618     if (color.isOpaque()) {
619         if (color.isExtended())
620             return makeRGB(color.asExtended().red() * 255, color.asExtended().green() * 255, color.asExtended().blue() * 255);
621         return color.rgb();
622     }
623 
624     if (color.isExtended())
625         return makePremultipliedRGBA(color.asExtended().red() * 255, color.asExtended().green() * 255, color.asExtended().blue() * 255, color.asExtended().alpha() * 255);
626 
627     return makePremultipliedRGBA(color.red(), color.green(), color.blue(), color.alpha());
628 }
629 
630 Color blend(const Color&amp; from, const Color&amp; to, double progress, bool blendPremultiplied)
631 {
632     // FIXME: ExtendedColor - needs to handle color spaces.
633     // We need to preserve the state of the valid flag at the end of the animation
634     if (progress == 1 &amp;&amp; !to.isValid())
635         return Color();
636 
637     if (blendPremultiplied) {
<span class="line-modified">638         // Contrary to the name, RGBA32 actually stores ARGB, so we can initialize Color directly from premultipliedARGBFromColor().</span>
<span class="line-modified">639         // Also, premultipliedARGBFromColor() bails on zero alpha, so special-case that.</span>
<span class="line-modified">640         Color premultFrom = from.alpha() ? premultipliedARGBFromColor(from) : 0;</span>
<span class="line-removed">641         Color premultTo = to.alpha() ? premultipliedARGBFromColor(to) : 0;</span>
642 
643         Color premultBlended(blend(premultFrom.red(), premultTo.red(), progress),
644             blend(premultFrom.green(), premultTo.green(), progress),
645             blend(premultFrom.blue(), premultTo.blue(), progress),
646             blend(premultFrom.alpha(), premultTo.alpha(), progress));
647 
648         return Color(colorFromPremultipliedARGB(premultBlended.rgb()));
649     }
650 
651     return Color(blend(from.red(), to.red(), progress),
652         blend(from.green(), to.green(), progress),
653         blend(from.blue(), to.blue(), progress),
654         blend(from.alpha(), to.alpha(), progress));
655 }
656 
657 void Color::tagAsValid()
658 {
659     m_colorData.rgbaAndFlags |= validRGBAColor;
660 }
661 
662 ExtendedColor&amp; Color::asExtended() const
663 {
664     ASSERT(isExtended());
665     return *m_colorData.extendedColor;
666 }
667 
668 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Color&amp; color)
669 {
670     return ts &lt;&lt; color.nameForRenderTreeAsText();
671 }
672 
673 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, ColorSpace colorSpace)
674 {
675     switch (colorSpace) {
<span class="line-modified">676     case ColorSpaceSRGB:</span>
677         ts &lt;&lt; &quot;sRGB&quot;;
678         break;
<span class="line-modified">679     case ColorSpaceLinearRGB:</span>
680         ts &lt;&lt; &quot;LinearRGB&quot;;
681         break;
<span class="line-modified">682     case ColorSpaceDisplayP3:</span>
683         ts &lt;&lt; &quot;DisplayP3&quot;;
684         break;
685     }
686     return ts;
687 }
688 
689 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2003-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;Color.h&quot;
 28 
 29 #include &quot;AnimationUtilities.h&quot;
<span class="line-added"> 30 #include &quot;ColorUtilities.h&quot;</span>
 31 #include &quot;HashTools.h&quot;
 32 #include &lt;wtf/Assertions.h&gt;
 33 #include &lt;wtf/HexNumber.h&gt;
 34 #include &lt;wtf/MathExtras.h&gt;
 35 #include &lt;wtf/text/StringBuilder.h&gt;
 36 #include &lt;wtf/text/TextStream.h&gt;
 37 
 38 namespace WebCore {
 39 
<span class="line-modified"> 40 static constexpr SimpleColor lightenedBlack { 0xFF545454 };</span>
<span class="line-modified"> 41 static constexpr SimpleColor darkenedWhite { 0xFFABABAB };</span>









 42 
 43 static inline unsigned premultipliedChannel(unsigned c, unsigned a, bool ceiling = true)
 44 {
 45     return fastDivideBy255(ceiling ? c * a + 254 : c * a);
 46 }
 47 
 48 static inline unsigned unpremultipliedChannel(unsigned c, unsigned a)
 49 {
 50     return (fastMultiplyBy255(c) + a - 1) / a;
 51 }
 52 
 53 RGBA32 makeRGB(int r, int g, int b)
 54 {
<span class="line-modified"> 55     return makeRGBA(r, g, b, 0xFF);</span>
 56 }
 57 
 58 RGBA32 makeRGBA(int r, int g, int b, int a)
 59 {
<span class="line-modified"> 60     return { static_cast&lt;unsigned&gt;(std::max(0, std::min(a, 0xFF)) &lt;&lt; 24 | std::max(0, std::min(r, 0xFF)) &lt;&lt; 16 | std::max(0, std::min(g, 0xFF)) &lt;&lt; 8 | std::max(0, std::min(b, 0xFF))) };</span>
 61 }
 62 
 63 RGBA32 makePremultipliedRGBA(int r, int g, int b, int a, bool ceiling)
 64 {
 65     return makeRGBA(premultipliedChannel(r, a, ceiling), premultipliedChannel(g, a, ceiling), premultipliedChannel(b, a, ceiling), a);
 66 }
 67 
 68 RGBA32 makeUnPremultipliedRGBA(int r, int g, int b, int a)
 69 {
 70     return makeRGBA(unpremultipliedChannel(r, a), unpremultipliedChannel(g, a), unpremultipliedChannel(b, a), a);
 71 }
 72 
 73 static int colorFloatToRGBAByte(float f)
 74 {
 75     // We use lroundf and 255 instead of nextafterf(256, 0) to match CG&#39;s rounding
 76     return std::max(0, std::min(static_cast&lt;int&gt;(lroundf(255.0f * f)), 255));
 77 }
 78 
 79 RGBA32 makeRGBA32FromFloats(float r, float g, float b, float a)
 80 {
<span class="line-modified"> 81     return makeRGBA(colorFloatToRGBAByte(r), colorFloatToRGBAByte(g), colorFloatToRGBAByte(b), colorFloatToRGBAByte(a));</span>
 82 }
 83 
 84 RGBA32 colorWithOverrideAlpha(RGBA32 color, float overrideAlpha)
 85 {
<span class="line-modified"> 86     return { (color.value() &amp; 0x00FFFFFF) | colorFloatToRGBAByte(overrideAlpha) &lt;&lt; 24 };</span>


 87 }
 88 
<span class="line-modified"> 89 RGBA32 makeRGBAFromHSLA(float hue, float saturation, float lightness, float alpha)</span>





















 90 {
<span class="line-modified"> 91     const float scaleFactor = 255.0;</span>
<span class="line-modified"> 92     FloatComponents floatResult = HSLToSRGB({ hue, saturation, lightness, alpha });</span>
<span class="line-modified"> 93     return makeRGBA(</span>
<span class="line-modified"> 94         round(floatResult.components[0] * scaleFactor),</span>
<span class="line-modified"> 95         round(floatResult.components[1] * scaleFactor),</span>
<span class="line-modified"> 96         round(floatResult.components[2] * scaleFactor),</span>
<span class="line-modified"> 97         round(floatResult.components[3] * scaleFactor));</span>







 98 }
 99 
100 RGBA32 makeRGBAFromCMYKA(float c, float m, float y, float k, float a)
101 {
102     double colors = 1 - k;
103     int r = static_cast&lt;int&gt;(nextafter(256, 0) * (colors * (1 - c)));
104     int g = static_cast&lt;int&gt;(nextafter(256, 0) * (colors * (1 - m)));
105     int b = static_cast&lt;int&gt;(nextafter(256, 0) * (colors * (1 - y)));
106     return makeRGBA(r, g, b, static_cast&lt;float&gt;(nextafter(256, 0) * a));
107 }
108 
109 // originally moved here from the CSS parser
110 template &lt;typename CharacterType&gt;
111 static inline bool parseHexColorInternal(const CharacterType* name, unsigned length, RGBA32&amp; rgb)
112 {
113     if (length != 3 &amp;&amp; length != 4 &amp;&amp; length != 6 &amp;&amp; length != 8)
114         return false;
115     unsigned value = 0;
116     for (unsigned i = 0; i &lt; length; ++i) {
117         if (!isASCIIHexDigit(name[i]))
118             return false;
119         value &lt;&lt;= 4;
120         value |= toASCIIHexValue(name[i]);
121     }
122     if (length == 6) {
<span class="line-modified">123         rgb = { 0xFF000000 | value };</span>
124         return true;
125     }
126     if (length == 8) {
127         // We parsed the values into RGBA order, but the RGBA32 type
128         // expects them to be in ARGB order, so we right rotate eight bits.
<span class="line-modified">129         rgb = { value &lt;&lt; 24 | value &gt;&gt; 8 };</span>
130         return true;
131     }
132     if (length == 4) {
133         // #abcd converts to ddaabbcc in RGBA32.
<span class="line-modified">134         rgb = { (value &amp; 0xF) &lt;&lt; 28 | (value &amp; 0xF) &lt;&lt; 24</span>
135             | (value &amp; 0xF000) &lt;&lt; 8 | (value &amp; 0xF000) &lt;&lt; 4
136             | (value &amp; 0xF00) &lt;&lt; 4 | (value &amp; 0xF00)
<span class="line-modified">137             | (value &amp; 0xF0) | (value &amp; 0xF0) &gt;&gt; 4 };</span>
138         return true;
139     }
140     // #abc converts to #aabbcc
<span class="line-modified">141     rgb = { 0xFF000000</span>
142         | (value &amp; 0xF00) &lt;&lt; 12 | (value &amp; 0xF00) &lt;&lt; 8
143         | (value &amp; 0xF0) &lt;&lt; 8 | (value &amp; 0xF0) &lt;&lt; 4
<span class="line-modified">144         | (value &amp; 0xF) &lt;&lt; 4 | (value &amp; 0xF) };</span>
145     return true;
146 }
147 
148 bool Color::parseHexColor(const LChar* name, unsigned length, RGBA32&amp; rgb)
149 {
150     return parseHexColorInternal(name, length, rgb);
151 }
152 
153 bool Color::parseHexColor(const UChar* name, unsigned length, RGBA32&amp; rgb)
154 {
155     return parseHexColorInternal(name, length, rgb);
156 }
157 
158 bool Color::parseHexColor(const String&amp; name, RGBA32&amp; rgb)
159 {
160     unsigned length = name.length();

161     if (!length)
162         return false;
163     if (name.is8Bit())
164         return parseHexColor(name.characters8(), name.length(), rgb);
165     return parseHexColor(name.characters16(), name.length(), rgb);
166 }
167 
168 bool Color::parseHexColor(const StringView&amp; name, RGBA32&amp; rgb)
169 {
170     unsigned length = name.length();
171     if (!length)
172         return false;
173     if (name.is8Bit())
174         return parseHexColor(name.characters8(), name.length(), rgb);
175     return parseHexColor(name.characters16(), name.length(), rgb);
176 }
177 
178 int differenceSquared(const Color&amp; c1, const Color&amp; c2)
179 {
180     // FIXME: This is assuming that the colors are in the same colorspace.
</pre>
<hr />
<pre>
207     }
208     buffer[length] = &#39;\0&#39;;
209     return findColor(buffer, length);
210 }
211 
212 Color::Color(const String&amp; name)
213 {
214     if (name[0] == &#39;#&#39;) {
215         RGBA32 color;
216         bool valid;
217 
218         if (name.is8Bit())
219             valid = parseHexColor(name.characters8() + 1, name.length() - 1, color);
220         else
221             valid = parseHexColor(name.characters16() + 1, name.length() - 1, color);
222 
223         if (valid)
224             setRGB(color);
225     } else {
226         if (auto* foundColor = findNamedColor(name))
<span class="line-modified">227             setRGB({ foundColor-&gt;ARGBValue });</span>


228     }
229 }
230 
231 Color::Color(const char* name)
232 {
<span class="line-modified">233     if (name[0] == &#39;#&#39;) {</span>
<span class="line-modified">234         SimpleColor color;</span>
<span class="line-modified">235         if (parseHexColor(reinterpret_cast&lt;const LChar*&gt;(&amp;name[1]), std::strlen(&amp;name[1]), color))</span>
<span class="line-modified">236             setRGB(color);</span>
<span class="line-modified">237     } else if (auto* foundColor = findColor(name, strlen(name)))</span>
<span class="line-modified">238         setRGB({ foundColor-&gt;ARGBValue });</span>






239 }
240 
241 Color::Color(const Color&amp; other)
242     : m_colorData(other.m_colorData)
243 {
244     if (isExtended())
245         m_colorData.extendedColor-&gt;ref();
246 }
247 
248 Color::Color(Color&amp;&amp; other)
249 {
250     *this = WTFMove(other);
251 }
252 
253 Color::Color(float r, float g, float b, float a, ColorSpace colorSpace)
254 {
255     // Zero the union, just in case a 32-bit system only assigns the
256     // top 32 bits when copying the extendedColor pointer below.
257     m_colorData.rgbaAndFlags = 0;
258     auto extendedColorRef = ExtendedColor::create(r, g, b, a, colorSpace);
</pre>
<hr />
<pre>
272 
273     if (isExtended())
274         m_colorData.extendedColor-&gt;ref();
275     return *this;
276 }
277 
278 Color&amp; Color::operator=(Color&amp;&amp; other)
279 {
280     if (*this == other)
281         return *this;
282 
283     if (isExtended())
284         m_colorData.extendedColor-&gt;deref();
285 
286     m_colorData = other.m_colorData;
287     other.m_colorData.rgbaAndFlags = invalidRGBAColor;
288 
289     return *this;
290 }
291 
<span class="line-added">292 String SimpleColor::serializationForHTML() const</span>
<span class="line-added">293 {</span>
<span class="line-added">294     if (isOpaque())</span>
<span class="line-added">295         return makeString(&#39;#&#39;, hex(redComponent(), 2, Lowercase), hex(greenComponent(), 2, Lowercase), hex(blueComponent(), 2, Lowercase));</span>
<span class="line-added">296     return serializationForCSS();</span>
<span class="line-added">297 }</span>
<span class="line-added">298 </span>
299 String Color::serialized() const
300 {
301     if (isExtended())
302         return asExtended().cssText();
<span class="line-added">303     return rgb().serializationForHTML();</span>
<span class="line-added">304 }</span>
305 
<span class="line-modified">306 static char decimalDigit(unsigned number)</span>
<span class="line-modified">307 {</span>
<span class="line-modified">308     ASSERT(number &lt; 10);</span>
<span class="line-modified">309     return &#39;0&#39; + number;</span>
<span class="line-modified">310 }</span>




311 
<span class="line-modified">312 static std::array&lt;char, 4&gt; fractionDigitsForFractionalAlphaValue(uint8_t alpha)</span>
<span class="line-added">313 {</span>
<span class="line-added">314     ASSERT(alpha &gt; 0);</span>
<span class="line-added">315     ASSERT(alpha &lt; 0xFF);</span>
<span class="line-added">316     if (((alpha * 100 + 0x7F) / 0xFF * 0xFF + 50) / 100 != alpha)</span>
<span class="line-added">317         return { { decimalDigit(alpha * 10 / 0xFF % 10), decimalDigit(alpha * 100 / 0xFF % 10), decimalDigit((alpha * 1000 + 0x7F) / 0xFF % 10), &#39;\0&#39; } };</span>
<span class="line-added">318     if (int thirdDigit = (alpha * 100 + 0x7F) / 0xFF % 10)</span>
<span class="line-added">319         return { { decimalDigit(alpha * 10 / 0xFF), decimalDigit(thirdDigit), &#39;\0&#39;, &#39;\0&#39; } };</span>
<span class="line-added">320     return { { decimalDigit((alpha * 10 + 0x7F) / 0xFF), &#39;\0&#39;, &#39;\0&#39;, &#39;\0&#39; } };</span>
<span class="line-added">321 }</span>
<span class="line-added">322 </span>
<span class="line-added">323 String SimpleColor::serializationForCSS() const</span>
<span class="line-added">324 {</span>
<span class="line-added">325     switch (alphaComponent()) {</span>
<span class="line-added">326     case 0:</span>
<span class="line-added">327         return makeString(&quot;rgba(&quot;, redComponent(), &quot;, &quot;, greenComponent(), &quot;, &quot;, blueComponent(), &quot;, 0)&quot;);</span>
<span class="line-added">328     case 0xFF:</span>
<span class="line-added">329         return makeString(&quot;rgb(&quot;, redComponent(), &quot;, &quot;, greenComponent(), &quot;, &quot;, blueComponent(), &#39;)&#39;);</span>
<span class="line-added">330     default:</span>
<span class="line-added">331         return makeString(&quot;rgba(&quot;, redComponent(), &quot;, &quot;, greenComponent(), &quot;, &quot;, blueComponent(), &quot;, 0.&quot;, fractionDigitsForFractionalAlphaValue(alphaComponent()).data(), &#39;)&#39;);</span>
<span class="line-added">332     }</span>
333 }
334 
335 String Color::cssText() const
336 {
337     if (isExtended())
338         return asExtended().cssText();
<span class="line-added">339     return rgb().serializationForCSS();</span>
<span class="line-added">340 }</span>
341 
<span class="line-modified">342 String RGBA32::serializationForRenderTreeAsText() const</span>
<span class="line-modified">343 {</span>
<span class="line-modified">344     if (alphaComponent() &lt; 0xFF)</span>
<span class="line-modified">345         return makeString(&#39;#&#39;, hex(redComponent(), 2), hex(greenComponent(), 2), hex(blueComponent(), 2), hex(alphaComponent(), 2));</span>
<span class="line-modified">346     return makeString(&#39;#&#39;, hex(redComponent(), 2), hex(greenComponent(), 2), hex(blueComponent(), 2));</span>


















347 }
348 
349 String Color::nameForRenderTreeAsText() const
350 {
<span class="line-modified">351     // FIXME: Handle extended colors.</span>
<span class="line-modified">352     return rgb().serializationForRenderTreeAsText();</span>


353 }
354 
355 Color Color::light() const
356 {
357     // Hardcode this common case for speed.
358     if (rgb() == black)
359         return lightenedBlack;
360 
361     const float scaleFactor = nextafterf(256.0f, 0.0f);
362 
363     float r, g, b, a;
364     getRGBA(r, g, b, a);
365 
366     float v = std::max(r, std::max(g, b));
367 
368     if (v == 0.0f)
369         // Lightened black with alpha.
370         return Color(0x54, 0x54, 0x54, alpha());
371 
372     float multiplier = std::min(1.0f, v + 0.33f) / v;
</pre>
<hr />
<pre>
550     else if (max == g)
551         hue = (60.0 * ((b - r) / chroma)) + 120.0;
552     else
553         hue = (60.0 * ((r - g) / chroma)) + 240.0;
554 
555     if (hue &gt;= 360.0)
556         hue -= 360.0;
557 
558     hue /= 360.0;
559 
560     if (!max)
561         saturation = 0;
562     else
563         saturation = chroma / max;
564 
565     value = max;
566 }
567 
568 Color colorFromPremultipliedARGB(RGBA32 pixelColor)
569 {
<span class="line-modified">570     if (pixelColor.isVisible() &amp;&amp; !pixelColor.isOpaque())</span>
<span class="line-modified">571         return makeUnPremultipliedRGBA(pixelColor.redComponent(), pixelColor.greenComponent(), pixelColor.blueComponent(), pixelColor.alphaComponent());</span>
<span class="line-modified">572     return pixelColor;</span>

573 }
574 
575 RGBA32 premultipliedARGBFromColor(const Color&amp; color)
576 {
577     if (color.isOpaque()) {
578         if (color.isExtended())
579             return makeRGB(color.asExtended().red() * 255, color.asExtended().green() * 255, color.asExtended().blue() * 255);
580         return color.rgb();
581     }
582 
583     if (color.isExtended())
584         return makePremultipliedRGBA(color.asExtended().red() * 255, color.asExtended().green() * 255, color.asExtended().blue() * 255, color.asExtended().alpha() * 255);
585 
586     return makePremultipliedRGBA(color.red(), color.green(), color.blue(), color.alpha());
587 }
588 
589 Color blend(const Color&amp; from, const Color&amp; to, double progress, bool blendPremultiplied)
590 {
591     // FIXME: ExtendedColor - needs to handle color spaces.
592     // We need to preserve the state of the valid flag at the end of the animation
593     if (progress == 1 &amp;&amp; !to.isValid())
594         return Color();
595 
596     if (blendPremultiplied) {
<span class="line-modified">597         // Since premultipliedARGBFromColor() bails on zero alpha, special-case that.</span>
<span class="line-modified">598         Color premultFrom = from.alpha() ? premultipliedARGBFromColor(from) : Color::transparent;</span>
<span class="line-modified">599         Color premultTo = to.alpha() ? premultipliedARGBFromColor(to) : Color::transparent;</span>

600 
601         Color premultBlended(blend(premultFrom.red(), premultTo.red(), progress),
602             blend(premultFrom.green(), premultTo.green(), progress),
603             blend(premultFrom.blue(), premultTo.blue(), progress),
604             blend(premultFrom.alpha(), premultTo.alpha(), progress));
605 
606         return Color(colorFromPremultipliedARGB(premultBlended.rgb()));
607     }
608 
609     return Color(blend(from.red(), to.red(), progress),
610         blend(from.green(), to.green(), progress),
611         blend(from.blue(), to.blue(), progress),
612         blend(from.alpha(), to.alpha(), progress));
613 }
614 
615 void Color::tagAsValid()
616 {
617     m_colorData.rgbaAndFlags |= validRGBAColor;
618 }
619 
620 ExtendedColor&amp; Color::asExtended() const
621 {
622     ASSERT(isExtended());
623     return *m_colorData.extendedColor;
624 }
625 
626 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Color&amp; color)
627 {
628     return ts &lt;&lt; color.nameForRenderTreeAsText();
629 }
630 
631 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, ColorSpace colorSpace)
632 {
633     switch (colorSpace) {
<span class="line-modified">634     case ColorSpace::SRGB:</span>
635         ts &lt;&lt; &quot;sRGB&quot;;
636         break;
<span class="line-modified">637     case ColorSpace::LinearRGB:</span>
638         ts &lt;&lt; &quot;LinearRGB&quot;;
639         break;
<span class="line-modified">640     case ColorSpace::DisplayP3:</span>
641         ts &lt;&lt; &quot;DisplayP3&quot;;
642         break;
643     }
644     return ts;
645 }
646 
647 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="BitmapImage.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Color.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
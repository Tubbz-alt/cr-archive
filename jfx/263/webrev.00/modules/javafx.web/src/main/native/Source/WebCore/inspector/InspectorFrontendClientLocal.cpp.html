<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorFrontendClientLocal.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2010 Google Inc. All rights reserved.
  3  * Copyright (C) 2015 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;InspectorFrontendClientLocal.h&quot;
 34 
 35 #include &quot;Chrome.h&quot;
 36 #include &quot;DOMWrapperWorld.h&quot;
 37 #include &quot;Document.h&quot;
 38 #include &quot;FloatRect.h&quot;
 39 #include &quot;Frame.h&quot;
 40 #include &quot;FrameLoadRequest.h&quot;
 41 #include &quot;FrameLoader.h&quot;
 42 #include &quot;FrameView.h&quot;
 43 #include &quot;InspectorController.h&quot;
 44 #include &quot;InspectorFrontendHost.h&quot;
 45 #include &quot;InspectorPageAgent.h&quot;
 46 #include &quot;Page.h&quot;
 47 #include &quot;ScriptController.h&quot;
 48 #include &quot;ScriptSourceCode.h&quot;
 49 #include &quot;ScriptState.h&quot;
 50 #include &quot;Settings.h&quot;
 51 #include &quot;Timer.h&quot;
 52 #include &quot;UserGestureIndicator.h&quot;
 53 #include &quot;WindowFeatures.h&quot;
 54 #include &lt;JavaScriptCore/FrameTracers.h&gt;
 55 #include &lt;JavaScriptCore/InspectorBackendDispatchers.h&gt;
 56 #include &lt;wtf/Deque.h&gt;
 57 #include &lt;wtf/text/CString.h&gt;
 58 
 59 
 60 namespace WebCore {
 61 
 62 using namespace Inspector;
 63 
 64 static const char* inspectorAttachedHeightSetting = &quot;inspectorAttachedHeight&quot;;
 65 static const unsigned defaultAttachedHeight = 300;
 66 static const float minimumAttachedHeight = 250.0f;
 67 static const float maximumAttachedHeightRatio = 0.75f;
 68 static const float minimumAttachedWidth = 500.0f;
 69 static const float minimumAttachedInspectedWidth = 320.0f;
 70 
 71 class InspectorBackendDispatchTask : public RefCounted&lt;InspectorBackendDispatchTask&gt; {
 72     WTF_MAKE_FAST_ALLOCATED;
 73 public:
 74     static Ref&lt;InspectorBackendDispatchTask&gt; create(InspectorController* inspectedPageController)
 75     {
 76         return adoptRef(*new InspectorBackendDispatchTask(inspectedPageController));
 77     }
 78 
 79     void dispatch(const String&amp; message)
 80     {
 81         ASSERT_ARG(message, !message.isEmpty());
 82 
 83         m_messages.append(message);
 84         scheduleOneShot();
 85     }
 86 
 87     void reset()
 88     {
 89         m_messages.clear();
 90         m_inspectedPageController = nullptr;
 91     }
 92 
 93 private:
 94     InspectorBackendDispatchTask(InspectorController* inspectedPageController)
 95         : m_inspectedPageController(inspectedPageController)
 96     {
 97         ASSERT_ARG(inspectedPageController, inspectedPageController);
 98     }
 99 
100     void scheduleOneShot()
101     {
102         if (m_hasScheduledTask)
103             return;
104         m_hasScheduledTask = true;
105 
106         // The frontend can be closed and destroy the owning frontend client before or in the
107         // process of dispatching the task, so keep a protector reference here.
108         RunLoop::current().dispatch([this, protectedThis = makeRef(*this)] {
109             m_hasScheduledTask = false;
110             dispatchOneMessage();
111         });
112     }
113 
114     void dispatchOneMessage()
115     {
116         // Owning frontend client may have been destroyed after the task was scheduled.
117         if (!m_inspectedPageController) {
118             ASSERT(m_messages.isEmpty());
119             return;
120         }
121 
122         if (!m_messages.isEmpty())
123             m_inspectedPageController-&gt;dispatchMessageFromFrontend(m_messages.takeFirst());
124 
125         if (!m_messages.isEmpty() &amp;&amp; m_inspectedPageController)
126             scheduleOneShot();
127     }
128 
129     InspectorController* m_inspectedPageController { nullptr };
130     Deque&lt;String&gt; m_messages;
131     bool m_hasScheduledTask { false };
132 };
133 
134 String InspectorFrontendClientLocal::Settings::getProperty(const String&amp;)
135 {
136     return String();
137 }
138 
139 void InspectorFrontendClientLocal::Settings::setProperty(const String&amp;, const String&amp;)
140 {
141 }
142 
143 void InspectorFrontendClientLocal::Settings::deleteProperty(const String&amp;)
144 {
145 }
146 
147 InspectorFrontendClientLocal::InspectorFrontendClientLocal(InspectorController* inspectedPageController, Page* frontendPage, std::unique_ptr&lt;Settings&gt; settings)
148     : m_inspectedPageController(inspectedPageController)
149     , m_frontendPage(frontendPage)
150     , m_settings(WTFMove(settings))
151     , m_dockSide(DockSide::Undocked)
152     , m_dispatchTask(InspectorBackendDispatchTask::create(inspectedPageController))
153 {
154     m_frontendPage-&gt;settings().setAllowFileAccessFromFileURLs(true);
155 }
156 
157 InspectorFrontendClientLocal::~InspectorFrontendClientLocal()
158 {
159     if (m_frontendHost)
160         m_frontendHost-&gt;disconnectClient();
161     m_frontendPage = nullptr;
162     m_inspectedPageController = nullptr;
163     m_dispatchTask-&gt;reset();
164 }
165 
166 void InspectorFrontendClientLocal::resetState()
167 {
168     m_settings-&gt;deleteProperty(inspectorAttachedHeightSetting);
169 }
170 
171 void InspectorFrontendClientLocal::windowObjectCleared()
172 {
173     if (m_frontendHost)
174         m_frontendHost-&gt;disconnectClient();
175 
176     m_frontendHost = InspectorFrontendHost::create(this, m_frontendPage);
177     m_frontendHost-&gt;addSelfToGlobalObjectInWorld(debuggerWorld());
178 }
179 
180 void InspectorFrontendClientLocal::frontendLoaded()
181 {
182     // Call setDockingUnavailable before bringToFront. If we display the inspector window via bringToFront first it causes
183     // the call to canAttachWindow to return the wrong result on Windows.
184     // Calling bringToFront first causes the visibleHeight of the inspected page to always return 0 immediately after.
185     // Thus if we call canAttachWindow first we can avoid this problem. This change does not cause any regressions on Mac.
186     setDockingUnavailable(!canAttachWindow());
187     bringToFront();
188     m_frontendLoaded = true;
189     for (auto&amp; evaluate : m_evaluateOnLoad)
190         evaluateOnLoad(evaluate);
191     m_evaluateOnLoad.clear();
192 }
193 
194 UserInterfaceLayoutDirection InspectorFrontendClientLocal::userInterfaceLayoutDirection() const
195 {
196     return m_frontendPage-&gt;userInterfaceLayoutDirection();
197 }
198 
199 void InspectorFrontendClientLocal::requestSetDockSide(DockSide dockSide)
200 {
201     if (dockSide == DockSide::Undocked) {
202         detachWindow();
203         setAttachedWindow(dockSide);
204     } else if (canAttachWindow()) {
205         attachWindow(dockSide);
206         setAttachedWindow(dockSide);
207     }
208 }
209 
210 bool InspectorFrontendClientLocal::canAttachWindow()
211 {
212     // Don&#39;t allow attaching to another inspector -- two inspectors in one window is too much!
213     bool isInspectorPage = m_inspectedPageController-&gt;inspectionLevel() &gt; 0;
214     if (isInspectorPage)
215         return false;
216 
217     // If we are already attached, allow attaching again to allow switching sides.
218     if (m_dockSide != DockSide::Undocked)
219         return true;
220 
221     // Don&#39;t allow the attach if the window would be too small to accommodate the minimum inspector size.
222     unsigned inspectedPageHeight = m_inspectedPageController-&gt;inspectedPage().mainFrame().view()-&gt;visibleHeight();
223     unsigned inspectedPageWidth = m_inspectedPageController-&gt;inspectedPage().mainFrame().view()-&gt;visibleWidth();
224     unsigned maximumAttachedHeight = inspectedPageHeight * maximumAttachedHeightRatio;
225     return minimumAttachedHeight &lt;= maximumAttachedHeight &amp;&amp; minimumAttachedWidth &lt;= inspectedPageWidth;
226 }
227 
228 void InspectorFrontendClientLocal::setDockingUnavailable(bool unavailable)
229 {
230     dispatch(makeString(&quot;[\&quot;setDockingUnavailable\&quot;, &quot;, unavailable ? &quot;true&quot; : &quot;false&quot;, &#39;]&#39;));
231 }
232 
233 void InspectorFrontendClientLocal::changeAttachedWindowHeight(unsigned height)
234 {
235     unsigned totalHeight = m_frontendPage-&gt;mainFrame().view()-&gt;visibleHeight() + m_inspectedPageController-&gt;inspectedPage().mainFrame().view()-&gt;visibleHeight();
236     unsigned attachedHeight = constrainedAttachedWindowHeight(height, totalHeight);
237     m_settings-&gt;setProperty(inspectorAttachedHeightSetting, String::number(attachedHeight));
238     setAttachedWindowHeight(attachedHeight);
239 }
240 
241 void InspectorFrontendClientLocal::changeAttachedWindowWidth(unsigned width)
242 {
243     unsigned totalWidth = m_frontendPage-&gt;mainFrame().view()-&gt;visibleWidth() + m_inspectedPageController-&gt;inspectedPage().mainFrame().view()-&gt;visibleWidth();
244     unsigned attachedWidth = constrainedAttachedWindowWidth(width, totalWidth);
245     setAttachedWindowWidth(attachedWidth);
246 }
247 
248 void InspectorFrontendClientLocal::changeSheetRect(const FloatRect&amp; rect)
249 {
250     setSheetRect(rect);
251 }
252 
253 void InspectorFrontendClientLocal::openInNewTab(const String&amp; url)
254 {
255     UserGestureIndicator indicator { ProcessingUserGesture };
256     Frame&amp; mainFrame = m_inspectedPageController-&gt;inspectedPage().mainFrame();
257     FrameLoadRequest frameLoadRequest { *mainFrame.document(), mainFrame.document()-&gt;securityOrigin(), { }, &quot;_blank&quot;_s, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Allow, ShouldOpenExternalURLsPolicy::ShouldNotAllow, InitiatedByMainFrame::Unknown };
258 
259     bool created;
260     auto frame = WebCore::createWindow(mainFrame, mainFrame, WTFMove(frameLoadRequest), { }, created);
261     if (!frame)
262         return;
263 
264     frame-&gt;loader().setOpener(&amp;mainFrame);
265     frame-&gt;page()-&gt;setOpenedByDOM();
266 
267     // FIXME: Why do we compute the absolute URL with respect to |frame| instead of |mainFrame|?
268     ResourceRequest resourceRequest { frame-&gt;document()-&gt;completeURL(url) };
269     FrameLoadRequest frameLoadRequest2 { *mainFrame.document(), mainFrame.document()-&gt;securityOrigin(), resourceRequest, &quot;_self&quot;_s, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Allow, ShouldOpenExternalURLsPolicy::ShouldNotAllow, InitiatedByMainFrame::Unknown };
270     frame-&gt;loader().changeLocation(WTFMove(frameLoadRequest2));
271 }
272 
273 void InspectorFrontendClientLocal::moveWindowBy(float x, float y)
274 {
275     FloatRect frameRect = m_frontendPage-&gt;chrome().windowRect();
276     frameRect.move(x, y);
277     m_frontendPage-&gt;chrome().setWindowRect(frameRect);
278 }
279 
280 void InspectorFrontendClientLocal::setAttachedWindow(DockSide dockSide)
281 {
282     const char* side = &quot;undocked&quot;;
283     switch (dockSide) {
284     case DockSide::Undocked:
285         side = &quot;undocked&quot;;
286         break;
287     case DockSide::Right:
288         side = &quot;right&quot;;
289         break;
290     case DockSide::Left:
291         side = &quot;left&quot;;
292         break;
293     case DockSide::Bottom:
294         side = &quot;bottom&quot;;
295         break;
296     }
297 
298     m_dockSide = dockSide;
299 
300     dispatch(makeString(&quot;[\&quot;setDockSide\&quot;, \&quot;&quot;, side, &quot;\&quot;]&quot;));
301 }
302 
303 void InspectorFrontendClientLocal::restoreAttachedWindowHeight()
304 {
305     unsigned inspectedPageHeight = m_inspectedPageController-&gt;inspectedPage().mainFrame().view()-&gt;visibleHeight();
306     String value = m_settings-&gt;getProperty(inspectorAttachedHeightSetting);
307     unsigned preferredHeight = value.isEmpty() ? defaultAttachedHeight : value.toUInt();
308 
309     // This call might not go through (if the window starts out detached), but if the window is initially created attached,
310     // InspectorController::attachWindow is never called, so we need to make sure to set the attachedWindowHeight.
311     // FIXME: Clean up code so we only have to call setAttachedWindowHeight in InspectorController::attachWindow
312     setAttachedWindowHeight(constrainedAttachedWindowHeight(preferredHeight, inspectedPageHeight));
313 }
314 
315 bool InspectorFrontendClientLocal::isDebuggingEnabled()
316 {
317     if (m_frontendLoaded)
318         return evaluateAsBoolean(&quot;[\&quot;isDebuggingEnabled\&quot;]&quot;);
319     return false;
320 }
321 
322 void InspectorFrontendClientLocal::setDebuggingEnabled(bool enabled)
323 {
324     dispatch(makeString(&quot;[\&quot;setDebuggingEnabled\&quot;, &quot;, enabled ? &quot;true&quot; : &quot;false&quot;, &#39;]&#39;));
325 }
326 
327 bool InspectorFrontendClientLocal::isTimelineProfilingEnabled()
328 {
329     if (m_frontendLoaded)
330         return evaluateAsBoolean(&quot;[\&quot;isTimelineProfilingEnabled\&quot;]&quot;);
331     return false;
332 }
333 
334 void InspectorFrontendClientLocal::setTimelineProfilingEnabled(bool enabled)
335 {
336     dispatch(makeString(&quot;[\&quot;setTimelineProfilingEnabled\&quot;, &quot;, enabled ? &quot;true&quot; : &quot;false&quot;, &#39;]&#39;));
337 }
338 
339 bool InspectorFrontendClientLocal::isProfilingJavaScript()
340 {
341     if (m_frontendLoaded)
342         return evaluateAsBoolean(&quot;[\&quot;isProfilingJavaScript\&quot;]&quot;);
343     return false;
344 }
345 
346 void InspectorFrontendClientLocal::startProfilingJavaScript()
347 {
348     dispatch(&quot;[\&quot;startProfilingJavaScript\&quot;]&quot;);
349 }
350 
351 void InspectorFrontendClientLocal::stopProfilingJavaScript()
352 {
353     dispatch(&quot;[\&quot;stopProfilingJavaScript\&quot;]&quot;);
354 }
355 
356 void InspectorFrontendClientLocal::showConsole()
357 {
358     dispatch(&quot;[\&quot;showConsole\&quot;]&quot;);
359 }
360 
361 void InspectorFrontendClientLocal::showResources()
362 {
363     dispatch(&quot;[\&quot;showResources\&quot;]&quot;);
364 }
365 
366 void InspectorFrontendClientLocal::showMainResourceForFrame(Frame* frame)
367 {
368     String frameId = m_inspectedPageController-&gt;ensurePageAgent().frameId(frame);
369     dispatch(makeString(&quot;[\&quot;showMainResourceForFrame\&quot;, \&quot;&quot;, frameId, &quot;\&quot;]&quot;));
370 }
371 
372 unsigned InspectorFrontendClientLocal::constrainedAttachedWindowHeight(unsigned preferredHeight, unsigned totalWindowHeight)
373 {
374     return roundf(std::max(minimumAttachedHeight, std::min&lt;float&gt;(preferredHeight, totalWindowHeight * maximumAttachedHeightRatio)));
375 }
376 
377 unsigned InspectorFrontendClientLocal::constrainedAttachedWindowWidth(unsigned preferredWidth, unsigned totalWindowWidth)
378 {
379     return roundf(std::max(minimumAttachedWidth, std::min&lt;float&gt;(preferredWidth, totalWindowWidth - minimumAttachedInspectedWidth)));
380 }
381 
382 void InspectorFrontendClientLocal::sendMessageToBackend(const String&amp; message)
383 {
384     m_dispatchTask-&gt;dispatch(message);
385 }
386 
387 bool InspectorFrontendClientLocal::isUnderTest()
388 {
389     return m_inspectedPageController-&gt;isUnderTest();
390 }
391 
392 unsigned InspectorFrontendClientLocal::inspectionLevel() const
393 {
394     return m_inspectedPageController-&gt;inspectionLevel() + 1;
395 }
396 
397 void InspectorFrontendClientLocal::dispatch(const String&amp; signature)
398 {
399     ASSERT(!signature.isEmpty());
400     ASSERT(signature.startsWith(&#39;[&#39;));
401     ASSERT(signature.endsWith(&#39;]&#39;));
402 
403     evaluateOnLoad(&quot;InspectorFrontendAPI.dispatch(&quot; + signature + &quot;)&quot;);
404 }
405 
406 void InspectorFrontendClientLocal::dispatchMessage(const String&amp; messageObject)
407 {
408     ASSERT(!messageObject.isEmpty());
409 
410     evaluateOnLoad(&quot;InspectorFrontendAPI.dispatchMessage(&quot; + messageObject + &quot;)&quot;);
411 }
412 
413 void InspectorFrontendClientLocal::dispatchMessageAsync(const String&amp; messageObject)
414 {
415     ASSERT(!messageObject.isEmpty());
416 
417     evaluateOnLoad(&quot;InspectorFrontendAPI.dispatchMessageAsync(&quot; + messageObject + &quot;)&quot;);
418 }
419 
420 bool InspectorFrontendClientLocal::evaluateAsBoolean(const String&amp; expression)
421 {
422     auto&amp; state = *mainWorldExecState(&amp;m_frontendPage-&gt;mainFrame());
423     return m_frontendPage-&gt;mainFrame().script().executeScriptIgnoringException(expression).toWTFString(&amp;state) == &quot;true&quot;;
424 }
425 
426 void InspectorFrontendClientLocal::evaluateOnLoad(const String&amp; expression)
427 {
428     if (!m_frontendLoaded) {
429         m_evaluateOnLoad.append(expression);
430         return;
431     }
432 
433     JSC::SuspendExceptionScope scope(&amp;m_frontendPage-&gt;inspectorController().vm());
434     m_frontendPage-&gt;mainFrame().script().evaluateIgnoringException(ScriptSourceCode(expression));
435 }
436 
437 Page* InspectorFrontendClientLocal::inspectedPage() const
438 {
439     if (!m_inspectedPageController)
440         return nullptr;
441 
442     return &amp;m_inspectedPageController-&gt;inspectedPage();
443 }
444 
445 } // namespace WebCore
    </pre>
  </body>
</html>
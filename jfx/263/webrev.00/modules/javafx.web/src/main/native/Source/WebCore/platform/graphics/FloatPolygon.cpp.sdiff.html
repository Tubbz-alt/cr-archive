<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FloatPolygon.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FloatPoint3D.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FloatPolygon.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FloatPolygon.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
118         m_edges[edgeIndex].m_edgeIndex = edgeIndex;
119         ++edgeIndex;
120         vertexIndex1 = vertexIndex2;
121     } while (vertexIndex1);
122 
123     if (edgeIndex &gt; 3) {
124         const FloatPolygonEdge&amp; firstEdge = m_edges[0];
125         const FloatPolygonEdge&amp; lastEdge = m_edges[edgeIndex - 1];
126         if (areCollinearPoints(lastEdge.vertex1(), lastEdge.vertex2(), firstEdge.vertex2())) {
127             m_edges[0].m_vertexIndex1 = lastEdge.m_vertexIndex1;
128             edgeIndex--;
129         }
130     }
131 
132     m_edges.resize(edgeIndex);
133     m_empty = m_edges.size() &lt; 3;
134 
135     if (m_empty)
136         return;
137 
<span class="line-modified">138     for (unsigned i = 0; i &lt; m_edges.size(); ++i) {</span>
<span class="line-modified">139         FloatPolygonEdge* edge = &amp;m_edges[i];</span>
<span class="line-removed">140         m_edgeTree.add(EdgeInterval(edge-&gt;minY(), edge-&gt;maxY(), edge));</span>
<span class="line-removed">141     }</span>
142 }
143 
<span class="line-modified">144 bool FloatPolygon::overlappingEdges(float minY, float maxY, Vector&lt;const FloatPolygonEdge*&gt;&amp; result) const</span>
145 {
<span class="line-modified">146     Vector&lt;FloatPolygon::EdgeInterval&gt; overlappingEdgeIntervals;</span>
<span class="line-modified">147     m_edgeTree.allOverlaps(FloatPolygon::EdgeInterval(minY, maxY, 0), overlappingEdgeIntervals);</span>
<span class="line-modified">148     unsigned overlappingEdgeIntervalsSize = overlappingEdgeIntervals.size();</span>
<span class="line-modified">149     result.resize(overlappingEdgeIntervalsSize);</span>
<span class="line-modified">150     for (unsigned i = 0; i &lt; overlappingEdgeIntervalsSize; ++i) {</span>
<span class="line-modified">151         const FloatPolygonEdge* edge = static_cast&lt;const FloatPolygonEdge*&gt;(overlappingEdgeIntervals[i].data());</span>
<span class="line-removed">152         ASSERT(edge);</span>
<span class="line-removed">153         result[i] = edge;</span>
<span class="line-removed">154     }</span>
<span class="line-removed">155     return overlappingEdgeIntervalsSize &gt; 0;</span>
156 }
157 
158 static inline float leftSide(const FloatPoint&amp; vertex1, const FloatPoint&amp; vertex2, const FloatPoint&amp; point)
159 {
160     return ((point.x() - vertex1.x()) * (vertex2.y() - vertex1.y())) - ((vertex2.x() - vertex1.x()) * (point.y() - vertex1.y()));
161 }
162 
163 bool FloatPolygon::containsEvenOdd(const FloatPoint&amp; point) const
164 {
165     unsigned crossingCount = 0;
166     for (unsigned i = 0; i &lt; numberOfEdges(); ++i) {
167         const FloatPoint&amp; vertex1 = edgeAt(i).vertex1();
168         const FloatPoint&amp; vertex2 = edgeAt(i).vertex2();
169         if (isPointOnLineSegment(vertex1, vertex2, point))
170             return true;
171         if ((vertex1.y() &lt;= point.y() &amp;&amp; vertex2.y() &gt; point.y()) || (vertex1.y() &gt; point.y() &amp;&amp; vertex2.y() &lt;= point.y())) {
172             float vt = (point.y()  - vertex1.y()) / (vertex2.y() - vertex1.y());
173             if (point.x() &lt; vertex1.x() + vt * (vertex2.x() - vertex1.x()))
174                 ++crossingCount;
175         }
</pre>
<hr />
<pre>
240     if (!denominator)
241         return false;
242 
243     // The two line segments: &quot;this&quot; vertex1,vertex2 and &quot;other&quot; vertex1,vertex2, have been defined
244     // in parametric form. Each point on the line segment is: vertex1 + u * (vertex2 - vertex1),
245     // when 0 &lt;= u &lt;= 1. We&#39;re computing the values of u for each line at their intersection point.
246 
247     const FloatSize&amp; vertex1Delta = vertex1() - other.vertex1();
248     float uThisLine = FloatPolygonInternal::determinant(otherDelta, vertex1Delta) / denominator;
249     float uOtherLine = FloatPolygonInternal::determinant(thisDelta, vertex1Delta) / denominator;
250 
251     if (uThisLine &lt; 0 || uOtherLine &lt; 0 || uThisLine &gt; 1 || uOtherLine &gt; 1)
252         return false;
253 
254     point = vertex1() + uThisLine * thisDelta;
255     return true;
256 }
257 
258 #ifndef NDEBUG
259 
<span class="line-modified">260 String FloatPolygonEdge::debugString() const</span>
261 {
<span class="line-modified">262     return makeString(&quot;0x&quot;, hex(reinterpret_cast&lt;uintptr_t&gt;(this)), &quot; (&quot;, vertex1().x(), &#39;,&#39;, vertex1().y(), &#39; &#39;, vertex2().x(), &#39;,&#39;, vertex2().y(), &#39;)&#39;);</span>
263 }
264 
265 #endif
266 
267 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
118         m_edges[edgeIndex].m_edgeIndex = edgeIndex;
119         ++edgeIndex;
120         vertexIndex1 = vertexIndex2;
121     } while (vertexIndex1);
122 
123     if (edgeIndex &gt; 3) {
124         const FloatPolygonEdge&amp; firstEdge = m_edges[0];
125         const FloatPolygonEdge&amp; lastEdge = m_edges[edgeIndex - 1];
126         if (areCollinearPoints(lastEdge.vertex1(), lastEdge.vertex2(), firstEdge.vertex2())) {
127             m_edges[0].m_vertexIndex1 = lastEdge.m_vertexIndex1;
128             edgeIndex--;
129         }
130     }
131 
132     m_edges.resize(edgeIndex);
133     m_empty = m_edges.size() &lt; 3;
134 
135     if (m_empty)
136         return;
137 
<span class="line-modified">138     for (auto&amp; edge : m_edges)</span>
<span class="line-modified">139         m_edgeTree.add({ edge.minY(), edge.maxY(), &amp;edge });</span>


140 }
141 
<span class="line-modified">142 Vector&lt;std::reference_wrapper&lt;const FloatPolygonEdge&gt;&gt; FloatPolygon::overlappingEdges(float minY, float maxY) const</span>
143 {
<span class="line-modified">144     auto overlappingEdgeIntervals = m_edgeTree.allOverlaps({ minY, maxY });</span>
<span class="line-modified">145     Vector&lt;std::reference_wrapper&lt;const FloatPolygonEdge&gt;&gt; result;</span>
<span class="line-modified">146     result.reserveInitialCapacity(overlappingEdgeIntervals.size());</span>
<span class="line-modified">147     for (auto&amp; interval : overlappingEdgeIntervals)</span>
<span class="line-modified">148         result.uncheckedAppend(*interval.data());</span>
<span class="line-modified">149     return result;</span>




150 }
151 
152 static inline float leftSide(const FloatPoint&amp; vertex1, const FloatPoint&amp; vertex2, const FloatPoint&amp; point)
153 {
154     return ((point.x() - vertex1.x()) * (vertex2.y() - vertex1.y())) - ((vertex2.x() - vertex1.x()) * (point.y() - vertex1.y()));
155 }
156 
157 bool FloatPolygon::containsEvenOdd(const FloatPoint&amp; point) const
158 {
159     unsigned crossingCount = 0;
160     for (unsigned i = 0; i &lt; numberOfEdges(); ++i) {
161         const FloatPoint&amp; vertex1 = edgeAt(i).vertex1();
162         const FloatPoint&amp; vertex2 = edgeAt(i).vertex2();
163         if (isPointOnLineSegment(vertex1, vertex2, point))
164             return true;
165         if ((vertex1.y() &lt;= point.y() &amp;&amp; vertex2.y() &gt; point.y()) || (vertex1.y() &gt; point.y() &amp;&amp; vertex2.y() &lt;= point.y())) {
166             float vt = (point.y()  - vertex1.y()) / (vertex2.y() - vertex1.y());
167             if (point.x() &lt; vertex1.x() + vt * (vertex2.x() - vertex1.x()))
168                 ++crossingCount;
169         }
</pre>
<hr />
<pre>
234     if (!denominator)
235         return false;
236 
237     // The two line segments: &quot;this&quot; vertex1,vertex2 and &quot;other&quot; vertex1,vertex2, have been defined
238     // in parametric form. Each point on the line segment is: vertex1 + u * (vertex2 - vertex1),
239     // when 0 &lt;= u &lt;= 1. We&#39;re computing the values of u for each line at their intersection point.
240 
241     const FloatSize&amp; vertex1Delta = vertex1() - other.vertex1();
242     float uThisLine = FloatPolygonInternal::determinant(otherDelta, vertex1Delta) / denominator;
243     float uOtherLine = FloatPolygonInternal::determinant(thisDelta, vertex1Delta) / denominator;
244 
245     if (uThisLine &lt; 0 || uOtherLine &lt; 0 || uThisLine &gt; 1 || uOtherLine &gt; 1)
246         return false;
247 
248     point = vertex1() + uThisLine * thisDelta;
249     return true;
250 }
251 
252 #ifndef NDEBUG
253 
<span class="line-modified">254 TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, const FloatPolygonEdge&amp; edge)</span>
255 {
<span class="line-modified">256     return stream &lt;&lt; &amp;edge &lt;&lt; &quot; (&quot; &lt;&lt; edge.vertex1().x() &lt;&lt; &#39;,&#39; &lt;&lt; edge.vertex1().y() &lt;&lt; &#39; &#39; &lt;&lt; edge.vertex2().x() &lt;&lt; &#39;,&#39; &lt;&lt; edge.vertex2().y() &lt;&lt; &#39;)&#39;;</span>
257 }
258 
259 #endif
260 
261 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="FloatPoint3D.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FloatPolygon.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
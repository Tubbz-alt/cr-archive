<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/Modules/modern-media-controls/gesture-recognizers/gesture-recognizer.js</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 
  2 class GestureRecognizer
  3 {
  4 
  5     constructor(target = null, delegate = null)
  6     {
  7         this._targetTouches = [];
  8 
  9         this.modifierKeys = {
 10             alt : false,
 11             ctrl : false,
 12             meta : false,
 13             shift : false
 14         };
 15 
 16         this._state = GestureRecognizer.States.Possible;
 17         this._enabled = true;
 18 
 19         this.target = target;
 20         this.delegate = delegate;
 21     }
 22 
 23     // Public
 24 
 25     get state()
 26     {
 27         return this._state;
 28     }
 29 
 30     set state(state)
 31     {
 32         if (this._state === state &amp;&amp; state !== GestureRecognizer.States.Changed)
 33             return;
 34 
 35         this._state = state;
 36         if (this.delegate &amp;&amp; typeof this.delegate.gestureRecognizerStateDidChange === &quot;function&quot;)
 37             this.delegate.gestureRecognizerStateDidChange(this);
 38     }
 39 
 40     get target()
 41     {
 42         return this._target;
 43     }
 44 
 45     set target(target)
 46     {
 47         if (!target || this._target === target)
 48             return;
 49 
 50         this._target = target;
 51         this._initRecognizer();
 52     }
 53 
 54     get numberOfTouches()
 55     {
 56         return this._targetTouches.length;
 57     }
 58 
 59     get enabled()
 60     {
 61         return this._enabled;
 62     }
 63 
 64     set enabled(enabled)
 65     {
 66         if (this._enabled === enabled)
 67             return;
 68 
 69         this._enabled = enabled;
 70 
 71         if (!enabled) {
 72             if (this.numberOfTouches === 0) {
 73                 this._removeTrackingListeners();
 74                 this.reset();
 75             } else
 76                 this.enterCancelledState();
 77         }
 78 
 79         this._updateBaseListeners();
 80     }
 81 
 82     reset()
 83     {
 84         // Implemented by subclasses.
 85     }
 86 
 87     locationInElement(element)
 88     {
 89         const p = new DOMPoint;
 90         const touches = this._targetTouches;
 91         const count = touches.length;
 92         for (let i = 0; i &lt; count; ++i) {
 93             const touch = touches[i];
 94             p.x += touch.pageX;
 95             p.y += touch.pageY;
 96         }
 97         p.x /= count;
 98         p.y /= count;
 99 
100         if (!element)
101             return p;
102 
103         // FIXME: are WebKitPoint and DOMPoint interchangeable?
104         const wkPoint = window.webkitConvertPointFromPageToNode(element, new WebKitPoint(p.x, p.y));
105         return new DOMPoint(wkPoint.x, wkPoint.y);
106     }
107 
108     locationInClient()
109     {
110         const p = new DOMPoint;
111         const touches = this._targetTouches;
112         const count = touches.length;
113         for (let i = 0; i &lt; count; ++i) {
114             const touch = touches[i];
115             p.x += touch.clientX;
116             p.y += touch.clientY;
117         }
118         p.x /= count;
119         p.y /= count;
120 
121         return p;
122     }
123 
124     locationOfTouchInElement(touchIndex, element)
125     {
126         const touch = this._targetTouches[touchIndex];
127         if (!touch)
128             return new DOMPoint;
129 
130         const touchLocation = new DOMPoint(touch.pageX, touch.pageY);
131         if (!element)
132             return touchLocation;
133 
134         // FIXME: are WebKitPoint and DOMPoint interchangeable?
135         const wkPoint = window.webkitConvertPointFromPageToNode(element, new WebKitPoint(touchLocation.x, touchLocation.y));
136         return new DOMPoint(wkPoint.x, wkPoint.y);
137     }
138 
139     touchesBegan(event)
140     {
141         if (event.currentTarget !== this._target)
142             return;
143 
144         window.addEventListener(GestureRecognizer.Events.TouchMove, this, true);
145         window.addEventListener(GestureRecognizer.Events.TouchEnd, this, true);
146         window.addEventListener(GestureRecognizer.Events.TouchCancel, this, true);
147         this.enterPossibleState();
148     }
149 
150     touchesMoved(event)
151     {
152         // Implemented by subclasses.
153     }
154 
155     touchesEnded(event)
156     {
157         // Implemented by subclasses.
158     }
159 
160     touchesCancelled(event)
161     {
162         // Implemented by subclasses.
163     }
164 
165     gestureBegan(event)
166     {
167         if (event.currentTarget !== this._target)
168             return;
169 
170         this._target.addEventListener(GestureRecognizer.Events.GestureChange, this, true);
171         this._target.addEventListener(GestureRecognizer.Events.GestureEnd, this, true);
172         this.enterPossibleState();
173     }
174 
175     gestureChanged(event)
176     {
177         // Implemented by subclasses.
178     }
179 
180     gestureEnded(event)
181     {
182         // Implemented by subclasses.
183     }
184 
185     enterPossibleState()
186     {
187         this.state = GestureRecognizer.States.Possible;
188     }
189 
190     enterBeganState()
191     {
192         if (this.delegate &amp;&amp; typeof this.delegate.gestureRecognizerShouldBegin === &quot;function&quot; &amp;&amp; !this.delegate.gestureRecognizerShouldBegin(this)) {
193             this.enterFailedState();
194             return;
195         }
196         this.state = GestureRecognizer.States.Began;
197     }
198 
199     enterEndedState()
200     {
201         this.state = GestureRecognizer.States.Ended;
202         this._removeTrackingListeners();
203         this.reset();
204     }
205 
206     enterCancelledState()
207     {
208         this.state = GestureRecognizer.States.Cancelled;
209         this._removeTrackingListeners();
210         this.reset();
211     }
212 
213     enterFailedState()
214     {
215         this.state = GestureRecognizer.States.Failed;
216         this._removeTrackingListeners();
217         this.reset();
218     }
219 
220     enterChangedState()
221     {
222         this.state = GestureRecognizer.States.Changed;
223     }
224 
225     enterRecognizedState()
226     {
227         this.state = GestureRecognizer.States.Recognized;
228     }
229 
230     // Protected
231 
232     handleEvent(event)
233     {
234         this._updateTargetTouches(event);
235         this._updateKeyboardModifiers(event);
236 
237         switch (event.type) {
238         case GestureRecognizer.Events.TouchStart:
239             this.touchesBegan(event);
240             break;
241         case GestureRecognizer.Events.TouchMove:
242             this.touchesMoved(event);
243             break;
244         case GestureRecognizer.Events.TouchEnd:
245             this.touchesEnded(event);
246             break;
247         case GestureRecognizer.Events.TouchCancel:
248             this.touchesCancelled(event);
249             break;
250         case GestureRecognizer.Events.GestureStart:
251             this.gestureBegan(event);
252             break;
253         case GestureRecognizer.Events.GestureChange:
254             this.gestureChanged(event);
255             break;
256         case GestureRecognizer.Events.GestureEnd:
257             this.gestureEnded(event);
258             break;
259         }
260     }
261 
262     // Private
263 
264     _initRecognizer()
265     {
266         this.reset();
267         this.state = GestureRecognizer.States.Possible;
268 
269         this._updateBaseListeners();
270     }
271 
272     _updateBaseListeners()
273     {
274         if (!this._target)
275             return;
276 
277         if (this._enabled) {
278             this._target.addEventListener(GestureRecognizer.Events.TouchStart, this);
279             if (GestureRecognizer.SupportsGestures)
280                 this._target.addEventListener(GestureRecognizer.Events.GestureStart, this);
281         } else {
282             this._target.removeEventListener(GestureRecognizer.Events.TouchStart, this);
283             if (GestureRecognizer.SupportsGestures)
284                 this._target.removeEventListener(GestureRecognizer.Events.GestureStart, this);
285         }
286     }
287 
288     _removeTrackingListeners()
289     {
290         window.removeEventListener(GestureRecognizer.Events.TouchMove, this, true);
291         window.removeEventListener(GestureRecognizer.Events.TouchEnd, this, true);
292         this._target.removeEventListener(GestureRecognizer.Events.GestureChange, this, true);
293         this._target.removeEventListener(GestureRecognizer.Events.GestureEnd, this, true);
294     }
295 
296     _updateTargetTouches(event)
297     {
298         if (!GestureRecognizer.SupportsTouches) {
299             if (event.type === GestureRecognizer.Events.TouchEnd)
300                 this._targetTouches = [];
301             else
302                 this._targetTouches = [event];
303             return;
304         }
305 
306         if (!(event instanceof TouchEvent))
307             return;
308 
309         // With a touchstart event, event.targetTouches is accurate so
310         // we simply add all of those.
311         if (event.type === GestureRecognizer.Events.TouchStart) {
312             this._targetTouches = [];
313             let touches = event.targetTouches;
314             for (let i = 0, count = touches.length; i &lt; count; ++i)
315                 this._targetTouches.push(touches[i]);
316             return;
317         }
318 
319         // With a touchmove event, the target is window so event.targetTouches is
320         // inaccurate so we add all touches that we knew about previously.
321         if (event.type === GestureRecognizer.Events.TouchMove) {
322             let targetIdentifiers = this._targetTouches.map(function(touch) {
323                 return touch.identifier;
324             });
325 
326             this._targetTouches = [];
327             let touches = event.touches;
328             for (let i = 0, count = touches.length; i &lt; count; ++i) {
329                 let touch = touches[i];
330                 if (targetIdentifiers.indexOf(touch.identifier) !== -1)
331                     this._targetTouches.push(touch);
332             }
333             return;
334         }
335 
336         // With a touchend or touchcancel event, we only keep the existing touches
337         // that are also found in event.touches.
338         let allTouches = event.touches;
339         let existingIdentifiers = [];
340         for (let i = 0, count = allTouches.length; i &lt; count; ++i)
341             existingIdentifiers.push(allTouches[i].identifier);
342 
343         this._targetTouches = this._targetTouches.filter(function(touch) {
344             return existingIdentifiers.indexOf(touch.identifier) !== -1;
345         });
346     }
347 
348     _updateKeyboardModifiers(event)
349     {
350         this.modifierKeys.alt = event.altKey;
351         this.modifierKeys.ctrl = event.ctrlKey;
352         this.modifierKeys.meta = event.metaKey;
353         this.modifierKeys.shift = event.shiftKey;
354     }
355 
356 }
357 
358 GestureRecognizer.SupportsTouches = &quot;createTouch&quot; in document;
359 GestureRecognizer.SupportsGestures = !!window.GestureEvent;
360 
361 GestureRecognizer.States = {
362     Possible   : &quot;possible&quot;,
363     Began      : &quot;began&quot;,
364     Changed    : &quot;changed&quot;,
365     Ended      : &quot;ended&quot;,
366     Cancelled  : &quot;cancelled&quot;,
367     Failed     : &quot;failed&quot;,
368     Recognized : &quot;ended&quot;
369 };
370 
371 GestureRecognizer.Events = {
372     TouchStart     : GestureRecognizer.SupportsTouches ? &quot;touchstart&quot; : &quot;mousedown&quot;,
373     TouchMove      : GestureRecognizer.SupportsTouches ? &quot;touchmove&quot; : &quot;mousemove&quot;,
374     TouchEnd       : GestureRecognizer.SupportsTouches ? &quot;touchend&quot; : &quot;mouseup&quot;,
375     TouchCancel    : &quot;touchcancel&quot;,
376     GestureStart   : &quot;gesturestart&quot;,
377     GestureChange  : &quot;gesturechange&quot;,
378     GestureEnd     : &quot;gestureend&quot;
379 };
    </pre>
  </body>
</html>
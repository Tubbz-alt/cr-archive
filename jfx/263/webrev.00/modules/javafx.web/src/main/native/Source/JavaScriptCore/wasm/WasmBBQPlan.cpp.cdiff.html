<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmBBQPlan.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmB3IRGenerator.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmBBQPlan.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmBBQPlan.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,366 ***</span>
  #include &quot;WasmBBQPlan.h&quot;
  
  #if ENABLE(WEBASSEMBLY)
  
  #include &quot;B3Compilation.h&quot;
  #include &quot;WasmAirIRGenerator.h&quot;
  #include &quot;WasmB3IRGenerator.h&quot;
  #include &quot;WasmBinding.h&quot;
  #include &quot;WasmCallee.h&quot;
  #include &quot;WasmCallingConvention.h&quot;
  #include &quot;WasmFaultSignalHandler.h&quot;
  #include &quot;WasmMemory.h&quot;
<span class="line-removed">- #include &quot;WasmModuleParser.h&quot;</span>
  #include &quot;WasmSignatureInlines.h&quot;
  #include &quot;WasmTierUpCount.h&quot;
<span class="line-removed">- #include &quot;WasmValidate.h&quot;</span>
  #include &lt;wtf/DataLog.h&gt;
  #include &lt;wtf/Locker.h&gt;
  #include &lt;wtf/MonotonicTime.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/SystemTracing.h&gt;
  #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  
  namespace JSC { namespace Wasm {
  
  namespace WasmBBQPlanInternal {
<span class="line-modified">! static const bool verbose = false;</span>
  }
  
<span class="line-modified">! BBQPlan::BBQPlan(Context* context, Ref&lt;ModuleInformation&gt; info, AsyncWork work, CompletionTask&amp;&amp; task, CreateEmbedderWrapper&amp;&amp; createEmbedderWrapper, ThrowWasmException throwWasmException)</span>
<span class="line-modified">!     : Base(context, WTFMove(info), WTFMove(task), WTFMove(createEmbedderWrapper), throwWasmException)</span>
<span class="line-modified">!     , m_state(State::Validated)</span>
<span class="line-modified">!     , m_asyncWork(work)</span>
  {
  }
  
<span class="line-modified">! BBQPlan::BBQPlan(Context* context, Vector&lt;uint8_t&gt;&amp;&amp; source, AsyncWork work, CompletionTask&amp;&amp; task, CreateEmbedderWrapper&amp;&amp; createEmbedderWrapper, ThrowWasmException throwWasmException)</span>
<span class="line-removed">-     : Base(context, ModuleInformation::create(), WTFMove(task), WTFMove(createEmbedderWrapper), throwWasmException)</span>
<span class="line-removed">-     , m_source(WTFMove(source))</span>
<span class="line-removed">-     , m_state(State::Initial)</span>
<span class="line-removed">-     , m_asyncWork(work)</span>
  {
<span class="line-modified">! }</span>
  
<span class="line-modified">! BBQPlan::BBQPlan(Context* context, AsyncWork work, CompletionTask&amp;&amp; task)</span>
<span class="line-modified">!     : Base(context, WTFMove(task))</span>
<span class="line-modified">!     , m_state(State::Initial)</span>
<span class="line-modified">!     , m_asyncWork(work)</span>
<span class="line-modified">! {</span>
  }
  
<span class="line-modified">! const char* BBQPlan::stateString(State state)</span>
  {
<span class="line-modified">!     switch (state) {</span>
<span class="line-modified">!     case State::Initial: return &quot;Initial&quot;;</span>
<span class="line-modified">!     case State::Validated: return &quot;Validated&quot;;</span>
<span class="line-modified">!     case State::Prepared: return &quot;Prepared&quot;;</span>
<span class="line-modified">!     case State::Compiled: return &quot;Compiled&quot;;</span>
<span class="line-modified">!     case State::Completed: return &quot;Completed&quot;;</span>
      }
<span class="line-removed">-     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void BBQPlan::moveToState(State state)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     ASSERT(state &gt;= m_state);</span>
<span class="line-modified">!     dataLogLnIf(WasmBBQPlanInternal::verbose &amp;&amp; state != m_state, &quot;moving to state: &quot;, stateString(state), &quot; from state: &quot;, stateString(m_state));</span>
<span class="line-removed">-     m_state = state;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! bool BBQPlan::parseAndValidateModule(const uint8_t* source, size_t sourceLength)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (m_state != State::Initial)</span>
<span class="line-modified">!         return true;</span>
  
<span class="line-modified">!     dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;starting validation&quot;);</span>
<span class="line-modified">!     MonotonicTime startTime;</span>
<span class="line-modified">!     if (WasmBBQPlanInternal::verbose || Options::reportCompileTimes())</span>
<span class="line-modified">!         startTime = MonotonicTime::now();</span>
  
      {
<span class="line-modified">!         ModuleParser moduleParser(source, sourceLength, m_moduleInformation);</span>
<span class="line-modified">!         auto parseResult = moduleParser.parse();</span>
<span class="line-modified">!         if (!parseResult) {</span>
<span class="line-modified">!             Base::fail(holdLock(m_lock), WTFMove(parseResult.error()));</span>
<span class="line-modified">!             return false;</span>
          }
      }
  
<span class="line-modified">!     const auto&amp; functions = m_moduleInformation-&gt;functions;</span>
<span class="line-modified">!     for (unsigned functionIndex = 0; functionIndex &lt; functions.size(); ++functionIndex) {</span>
<span class="line-modified">!         const auto&amp; function = functions[functionIndex];</span>
<span class="line-modified">!         dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Processing function starting at: &quot;, function.start, &quot; and ending at: &quot;, function.end);</span>
<span class="line-modified">!         size_t functionLength = function.end - function.start;</span>
<span class="line-removed">-         ASSERT(functionLength &lt;= sourceLength);</span>
<span class="line-removed">-         ASSERT(functionLength == function.data.size());</span>
<span class="line-removed">-         SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];</span>
<span class="line-removed">-         const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
  
<span class="line-modified">!         auto validationResult = validateFunction(function.data.data(), function.data.size(), signature, m_moduleInformation.get());</span>
<span class="line-modified">!         if (!validationResult) {</span>
<span class="line-modified">!             if (WasmBBQPlanInternal::verbose) {</span>
<span class="line-modified">!                 for (unsigned i = 0; i &lt; functionLength; ++i)</span>
<span class="line-modified">!                     dataLog(RawPointer(reinterpret_cast&lt;void*&gt;(function.data[i])), &quot;, &quot;);</span>
<span class="line-modified">!                 dataLogLn();</span>
              }
<span class="line-removed">-             Base::fail(holdLock(m_lock), makeString(validationResult.error(), &quot;, in function at index &quot;, String::number(functionIndex))); // FIXME make this an Expected.</span>
<span class="line-removed">-             return false;</span>
          }
      }
  
<span class="line-modified">!     if (WasmBBQPlanInternal::verbose || Options::reportCompileTimes())</span>
<span class="line-removed">-         dataLogLn(&quot;Took &quot;, (MonotonicTime::now() - startTime).microseconds(), &quot; us to validate module&quot;);</span>
  
<span class="line-modified">!     moveToState(State::Validated);</span>
<span class="line-modified">!     if (m_asyncWork == Validation)</span>
<span class="line-modified">!         complete(holdLock(m_lock));</span>
<span class="line-modified">!     return true;</span>
  }
  
<span class="line-modified">! void BBQPlan::prepare()</span>
  {
<span class="line-modified">!     ASSERT(m_state == State::Validated);</span>
<span class="line-removed">-     dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Starting preparation&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto tryReserveCapacity = [this] (auto&amp; vector, size_t size, const char* what) {</span>
<span class="line-removed">-         if (UNLIKELY(!vector.tryReserveCapacity(size))) {</span>
<span class="line-removed">-             fail(holdLock(m_lock), WTF::makeString(&quot;Failed allocating enough space for &quot;, size, what));</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">-     };</span>
  
<span class="line-modified">!     const auto&amp; functions = m_moduleInformation-&gt;functions;</span>
<span class="line-modified">!     if (!tryReserveCapacity(m_wasmToWasmExitStubs, m_moduleInformation-&gt;importFunctionSignatureIndices.size(), &quot; WebAssembly to JavaScript stubs&quot;)</span>
<span class="line-modified">!         || !tryReserveCapacity(m_unlinkedWasmToWasmCalls, functions.size(), &quot; unlinked WebAssembly to WebAssembly calls&quot;)</span>
<span class="line-modified">!         || !tryReserveCapacity(m_wasmInternalFunctions, functions.size(), &quot; WebAssembly functions&quot;)</span>
<span class="line-removed">-         || !tryReserveCapacity(m_compilationContexts, functions.size(), &quot; compilation contexts&quot;)</span>
<span class="line-removed">-         || !tryReserveCapacity(m_tierUpCounts, functions.size(), &quot; tier-up counts&quot;))</span>
<span class="line-removed">-         return;</span>
  
<span class="line-modified">!     m_unlinkedWasmToWasmCalls.resize(functions.size());</span>
<span class="line-removed">-     m_wasmInternalFunctions.resize(functions.size());</span>
<span class="line-removed">-     m_compilationContexts.resize(functions.size());</span>
<span class="line-removed">-     m_tierUpCounts.resize(functions.size());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (unsigned importIndex = 0; importIndex &lt; m_moduleInformation-&gt;imports.size(); ++importIndex) {</span>
<span class="line-removed">-         Import* import = &amp;m_moduleInformation-&gt;imports[importIndex];</span>
<span class="line-removed">-         if (import-&gt;kind != ExternalKind::Function)</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">-         unsigned importFunctionIndex = m_wasmToWasmExitStubs.size();</span>
<span class="line-removed">-         dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Processing import function number &quot;, importFunctionIndex, &quot;: &quot;, makeString(import-&gt;module), &quot;: &quot;, makeString(import-&gt;field));</span>
<span class="line-removed">-         auto binding = wasmToWasm(importFunctionIndex);</span>
<span class="line-removed">-         if (UNLIKELY(!binding)) {</span>
<span class="line-removed">-             switch (binding.error()) {</span>
<span class="line-removed">-             case BindingFailure::OutOfMemory:</span>
<span class="line-removed">-                 return fail(holdLock(m_lock), makeString(&quot;Out of executable memory at import &quot;, String::number(importIndex)));</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         m_wasmToWasmExitStubs.uncheckedAppend(binding.value());</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     const uint32_t importFunctionCount = m_moduleInformation-&gt;importFunctionCount();</span>
<span class="line-modified">!     for (const auto&amp; exp : m_moduleInformation-&gt;exports) {</span>
<span class="line-modified">!         if (exp.kindIndex &gt;= importFunctionCount)</span>
<span class="line-modified">!             m_exportedFunctionIndices.add(exp.kindIndex - importFunctionCount);</span>
      }
  
<span class="line-modified">!     for (const auto&amp; element : m_moduleInformation-&gt;elements) {</span>
<span class="line-modified">!         for (const uint32_t elementIndex : element.functionIndices) {</span>
<span class="line-modified">!             if (elementIndex &gt;= importFunctionCount)</span>
<span class="line-modified">!                 m_exportedFunctionIndices.add(elementIndex - importFunctionCount);</span>
          }
      }
  
<span class="line-modified">!     if (m_moduleInformation-&gt;startFunctionIndexSpace &amp;&amp; m_moduleInformation-&gt;startFunctionIndexSpace &gt;= importFunctionCount)</span>
<span class="line-removed">-         m_exportedFunctionIndices.add(*m_moduleInformation-&gt;startFunctionIndexSpace - importFunctionCount);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     moveToState(State::Prepared);</span>
  }
  
<span class="line-modified">! // We don&#39;t have a semaphore class... and this does kinda interesting things.</span>
<span class="line-removed">- class BBQPlan::ThreadCountHolder {</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-     ThreadCountHolder(BBQPlan&amp; plan)</span>
<span class="line-removed">-         : m_plan(plan)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         LockHolder locker(m_plan.m_lock);</span>
<span class="line-removed">-         m_plan.m_numberOfActiveThreads++;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ~ThreadCountHolder()</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         LockHolder locker(m_plan.m_lock);</span>
<span class="line-removed">-         m_plan.m_numberOfActiveThreads--;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (!m_plan.m_numberOfActiveThreads &amp;&amp; !m_plan.hasWork())</span>
<span class="line-removed">-             m_plan.complete(locker);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     BBQPlan&amp; m_plan;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- void BBQPlan::compileFunctions(CompilationEffort effort)</span>
  {
<span class="line-modified">!     ASSERT(m_state &gt;= State::Prepared);</span>
<span class="line-modified">!     dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Starting compilation&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (!hasWork())</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">! </span>
<span class="line-removed">-     Optional&lt;TraceScope&gt; traceScope;</span>
<span class="line-removed">-     if (Options::useTracePoints())</span>
<span class="line-removed">-         traceScope.emplace(WebAssemblyCompileStart, WebAssemblyCompileEnd);</span>
<span class="line-removed">-     ThreadCountHolder holder(*this);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     size_t bytesCompiled = 0;</span>
<span class="line-removed">-     const auto&amp; functions = m_moduleInformation-&gt;functions;</span>
<span class="line-removed">-     while (true) {</span>
<span class="line-removed">-         if (effort == Partial &amp;&amp; bytesCompiled &gt;= Options::webAssemblyPartialCompileLimit())</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         uint32_t functionIndex;</span>
          {
<span class="line-modified">!             auto locker = holdLock(m_lock);</span>
<span class="line-modified">!             if (m_currentIndex &gt;= functions.size()) {</span>
<span class="line-modified">!                 if (hasWork())</span>
<span class="line-removed">-                     moveToState(State::Compiled);</span>
                  return;
              }
<span class="line-removed">-             functionIndex = m_currentIndex;</span>
<span class="line-removed">-             ++m_currentIndex;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         const auto&amp; function = functions[functionIndex];</span>
<span class="line-modified">!         SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];</span>
<span class="line-modified">!         const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-removed">-         unsigned functionIndexSpace = m_wasmToWasmExitStubs.size() + functionIndex;</span>
<span class="line-removed">-         ASSERT_UNUSED(functionIndexSpace, m_moduleInformation-&gt;signatureIndexFromFunctionIndexSpace(functionIndexSpace) == signatureIndex);</span>
<span class="line-removed">-         ASSERT(validateFunction(function.data.data(), function.data.size(), signature, m_moduleInformation.get()));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         m_unlinkedWasmToWasmCalls[functionIndex] = Vector&lt;UnlinkedWasmToWasmCall&gt;();</span>
<span class="line-removed">-         if (Options::useBBQTierUpChecks())</span>
<span class="line-removed">-             m_tierUpCounts[functionIndex] = makeUnique&lt;TierUpCount&gt;();</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             m_tierUpCounts[functionIndex] = nullptr;</span>
<span class="line-removed">-         TierUpCount* tierUp = m_tierUpCounts[functionIndex].get();</span>
<span class="line-removed">-         Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, String&gt; parseAndCompileResult;</span>
<span class="line-removed">-         unsigned osrEntryScratchBufferSize = 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // FIXME: Some webpages use very large Wasm module, and it exhausts all executable memory in ARM64 devices since the size of executable memory region is only limited to 128MB.</span>
<span class="line-removed">-         // The long term solution should be to introduce a Wasm interpreter. But as a short term solution, we introduce heuristics to switch back to BBQ B3 at the sacrifice of start-up time,</span>
<span class="line-removed">-         // as BBQ Air bloats such lengthy Wasm code and will consume a large amount of executable memory.</span>
<span class="line-removed">-         bool forceUsingB3 = false;</span>
<span class="line-removed">-         if (Options::webAssemblyBBQAirModeThreshold() &amp;&amp; m_moduleInformation-&gt;codeSectionSize &gt;= Options::webAssemblyBBQAirModeThreshold())</span>
<span class="line-removed">-             forceUsingB3 = true;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (!forceUsingB3 &amp;&amp; Options::wasmBBQUsesAir())</span>
<span class="line-removed">-             parseAndCompileResult = parseAndCompileAir(m_compilationContexts[functionIndex], function.data.data(), function.data.size(), signature, m_unlinkedWasmToWasmCalls[functionIndex], m_moduleInformation.get(), m_mode, functionIndex, tierUp, m_throwWasmException);</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             parseAndCompileResult = parseAndCompile(m_compilationContexts[functionIndex], function.data.data(), function.data.size(), signature, m_unlinkedWasmToWasmCalls[functionIndex], osrEntryScratchBufferSize, m_moduleInformation.get(), m_mode, CompilationMode::BBQMode, functionIndex, UINT32_MAX, tierUp, m_throwWasmException);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (UNLIKELY(!parseAndCompileResult)) {</span>
<span class="line-removed">-             auto locker = holdLock(m_lock);</span>
<span class="line-removed">-             if (!m_errorMessage) {</span>
<span class="line-removed">-                 // Multiple compiles could fail simultaneously. We arbitrarily choose the first.</span>
<span class="line-removed">-                 fail(locker, makeString(parseAndCompileResult.error(), &quot;, in function at index &quot;, String::number(functionIndex))); // FIXME make this an Expected.</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             m_currentIndex = functions.size();</span>
<span class="line-removed">-             return;</span>
          }
  
<span class="line-modified">!         m_wasmInternalFunctions[functionIndex] = WTFMove(*parseAndCompileResult);</span>
  
<span class="line-modified">!         if (m_exportedFunctionIndices.contains(functionIndex) || m_moduleInformation-&gt;referencedFunctions().contains(functionIndex)) {</span>
<span class="line-modified">!             auto locker = holdLock(m_lock);</span>
<span class="line-modified">!             auto result = m_embedderToWasmInternalFunctions.add(functionIndex, m_createEmbedderWrapper(m_compilationContexts[functionIndex], signature, &amp;m_unlinkedWasmToWasmCalls[functionIndex], m_moduleInformation.get(), m_mode, functionIndex));</span>
<span class="line-removed">-             ASSERT_UNUSED(result, result.isNewEntry);</span>
          }
  
<span class="line-modified">!         bytesCompiled += function.data.size();</span>
      }
  }
  
<span class="line-modified">! void BBQPlan::complete(const AbstractLocker&amp; locker)</span>
  {
<span class="line-modified">!     ASSERT(m_state != State::Compiled || m_currentIndex &gt;= m_moduleInformation-&gt;functions.size());</span>
<span class="line-modified">!     dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Starting Completion&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!failed() &amp;&amp; m_state == State::Compiled) {</span>
<span class="line-removed">-         for (uint32_t functionIndex = 0; functionIndex &lt; m_moduleInformation-&gt;functions.size(); functionIndex++) {</span>
<span class="line-removed">-             CompilationContext&amp; context = m_compilationContexts[functionIndex];</span>
<span class="line-removed">-             SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];</span>
<span class="line-removed">-             const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-removed">-             const uint32_t functionIndexSpace = functionIndex + m_moduleInformation-&gt;importFunctionCount();</span>
<span class="line-removed">-             ASSERT(functionIndexSpace &lt; m_moduleInformation-&gt;functionIndexSpaceSize());</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 LinkBuffer linkBuffer(*context.wasmEntrypointJIT, nullptr, JITCompilationCanFail);</span>
<span class="line-removed">-                 if (UNLIKELY(linkBuffer.didFailToAllocate())) {</span>
<span class="line-removed">-                     Base::fail(locker, makeString(&quot;Out of executable memory in function at index &quot;, String::number(functionIndex)));</span>
<span class="line-removed">-                     return;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 m_wasmInternalFunctions[functionIndex]-&gt;entrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(</span>
<span class="line-removed">-                     FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;WebAssembly BBQ function[%i] %s name %s&quot;, functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
<span class="line-removed">-                     WTFMove(context.wasmEntrypointByproducts));</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (auto embedderToWasmInternalFunction = m_embedderToWasmInternalFunctions.get(functionIndex)) {</span>
<span class="line-removed">-                 LinkBuffer linkBuffer(*context.embedderEntrypointJIT, nullptr, JITCompilationCanFail);</span>
<span class="line-removed">-                 if (UNLIKELY(linkBuffer.didFailToAllocate())) {</span>
<span class="line-removed">-                     Base::fail(locker, makeString(&quot;Out of executable memory in function entrypoint at index &quot;, String::number(functionIndex)));</span>
<span class="line-removed">-                     return;</span>
<span class="line-removed">-                 }</span>
  
<span class="line-modified">!                 embedderToWasmInternalFunction-&gt;entrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(</span>
<span class="line-modified">!                     FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;Embedder-&gt;WebAssembly entrypoint[%i] %s name %s&quot;, functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
<span class="line-modified">!                     WTFMove(context.embedderEntrypointByproducts));</span>
<span class="line-modified">!             }</span>
          }
  
<span class="line-modified">!         for (auto&amp; unlinked : m_unlinkedWasmToWasmCalls) {</span>
<span class="line-modified">!             for (auto&amp; call : unlinked) {</span>
<span class="line-modified">!                 MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; executableAddress;</span>
<span class="line-modified">!                 if (m_moduleInformation-&gt;isImportedFunctionFromFunctionIndexSpace(call.functionIndexSpace)) {</span>
<span class="line-removed">-                     // FIXME imports could have been linked in B3, instead of generating a patchpoint. This condition should be replaced by a RELEASE_ASSERT. https://bugs.webkit.org/show_bug.cgi?id=166462</span>
<span class="line-removed">-                     executableAddress = m_wasmToWasmExitStubs.at(call.functionIndexSpace).code();</span>
<span class="line-removed">-                 } else</span>
<span class="line-removed">-                     executableAddress = m_wasmInternalFunctions.at(call.functionIndexSpace - m_moduleInformation-&gt;importFunctionCount())-&gt;entrypoint.compilation-&gt;code().retagged&lt;WasmEntryPtrTag&gt;();</span>
<span class="line-removed">-                 MacroAssembler::repatchNearCall(call.callLocation, CodeLocationLabel&lt;WasmEntryPtrTag&gt;(executableAddress));</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     if (!isComplete()) {</span>
<span class="line-removed">-         moveToState(State::Completed);</span>
<span class="line-removed">-         runCompletionTasks(locker);</span>
      }
  }
  
<span class="line-modified">! void BBQPlan::work(CompilationEffort effort)</span>
  {
<span class="line-modified">!     switch (m_state) {</span>
<span class="line-removed">-     case State::Initial:</span>
<span class="line-removed">-         parseAndValidateModule(m_source.data(), m_source.size());</span>
<span class="line-removed">-         if (!hasWork()) {</span>
<span class="line-removed">-             ASSERT(isComplete());</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         FALLTHROUGH;</span>
<span class="line-removed">-     case State::Validated:</span>
<span class="line-removed">-         prepare();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     case State::Prepared:</span>
<span class="line-removed">-         compileFunctions(effort);</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return;</span>
  }
  
  } } // namespace JSC::Wasm
  
  #endif // ENABLE(WEBASSEMBLY)
<span class="line-new-header">--- 27,299 ---</span>
  #include &quot;WasmBBQPlan.h&quot;
  
  #if ENABLE(WEBASSEMBLY)
  
  #include &quot;B3Compilation.h&quot;
<span class="line-added">+ #include &quot;JSToWasm.h&quot;</span>
  #include &quot;WasmAirIRGenerator.h&quot;
  #include &quot;WasmB3IRGenerator.h&quot;
  #include &quot;WasmBinding.h&quot;
  #include &quot;WasmCallee.h&quot;
  #include &quot;WasmCallingConvention.h&quot;
  #include &quot;WasmFaultSignalHandler.h&quot;
<span class="line-added">+ #include &quot;WasmMachineThreads.h&quot;</span>
  #include &quot;WasmMemory.h&quot;
  #include &quot;WasmSignatureInlines.h&quot;
  #include &quot;WasmTierUpCount.h&quot;
  #include &lt;wtf/DataLog.h&gt;
  #include &lt;wtf/Locker.h&gt;
  #include &lt;wtf/MonotonicTime.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/SystemTracing.h&gt;
  #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  
  namespace JSC { namespace Wasm {
  
  namespace WasmBBQPlanInternal {
<span class="line-modified">! static constexpr bool verbose = false;</span>
  }
  
<span class="line-modified">! BBQPlan::BBQPlan(Context* context, Ref&lt;ModuleInformation&gt; moduleInformation, uint32_t functionIndex, CodeBlock* codeBlock, CompletionTask&amp;&amp; completionTask)</span>
<span class="line-modified">!     : EntryPlan(context, WTFMove(moduleInformation), AsyncWork::FullCompile, WTFMove(completionTask))</span>
<span class="line-modified">!     , m_codeBlock(codeBlock)</span>
<span class="line-modified">!     , m_functionIndex(functionIndex)</span>
  {
<span class="line-added">+     setMode(m_codeBlock-&gt;mode());</span>
  }
  
<span class="line-modified">! bool BBQPlan::prepareImpl()</span>
  {
<span class="line-modified">!     const auto&amp; functions = m_moduleInformation-&gt;functions;</span>
<span class="line-added">+     if (!tryReserveCapacity(m_wasmInternalFunctions, functions.size(), &quot; WebAssembly functions&quot;)</span>
<span class="line-added">+         || !tryReserveCapacity(m_compilationContexts, functions.size(), &quot; compilation contexts&quot;)</span>
<span class="line-added">+         || !tryReserveCapacity(m_tierUpCounts, functions.size(), &quot; tier-up counts&quot;))</span>
<span class="line-added">+         return false;</span>
  
<span class="line-modified">!     m_wasmInternalFunctions.resize(functions.size());</span>
<span class="line-modified">!     m_compilationContexts.resize(functions.size());</span>
<span class="line-modified">!     m_tierUpCounts.resize(functions.size());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     return true;</span>
  }
  
<span class="line-modified">! void BBQPlan::work(CompilationEffort effort)</span>
  {
<span class="line-modified">!     if (!m_codeBlock) {</span>
<span class="line-modified">!         switch (m_state) {</span>
<span class="line-modified">!         case State::Initial:</span>
<span class="line-modified">!             parseAndValidateModule();</span>
<span class="line-modified">!             if (!hasWork()) {</span>
<span class="line-modified">!                 ASSERT(m_state == State::Validated);</span>
<span class="line-added">+                 complete(holdLock(m_lock));</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             FALLTHROUGH;</span>
<span class="line-added">+         case State::Validated:</span>
<span class="line-added">+             prepare();</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case State::Prepared:</span>
<span class="line-added">+             compileFunctions(effort);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return;</span>
      }
  
<span class="line-modified">!     CompilationContext context;</span>
<span class="line-modified">!     Vector&lt;UnlinkedWasmToWasmCall&gt; unlinkedWasmToWasmCalls;</span>
<span class="line-modified">!     std::unique_ptr&lt;TierUpCount&gt; tierUp = makeUnique&lt;TierUpCount&gt;();</span>
<span class="line-modified">!     std::unique_ptr&lt;InternalFunction&gt; function = compileFunction(m_functionIndex, context, unlinkedWasmToWasmCalls, tierUp.get());</span>
  
<span class="line-modified">!     LinkBuffer linkBuffer(*context.wasmEntrypointJIT, nullptr, JITCompilationCanFail);</span>
<span class="line-modified">!     if (UNLIKELY(linkBuffer.didFailToAllocate())) {</span>
<span class="line-modified">!         Base::fail(holdLock(m_lock), makeString(&quot;Out of executable memory while tiering up function at index &quot;, String::number(m_functionIndex)));</span>
<span class="line-modified">!         return;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     size_t functionIndexSpace = m_functionIndex + m_moduleInformation-&gt;importFunctionCount();</span>
<span class="line-modified">!     SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[m_functionIndex];</span>
<span class="line-modified">!     const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-modified">!     function-&gt;entrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(</span>
<span class="line-added">+         FINALIZE_WASM_CODE_FOR_MODE(CompilationMode::BBQMode, linkBuffer, B3CompilationPtrTag, &quot;WebAssembly BBQ function[%i] %s name %s&quot;, m_functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
<span class="line-added">+         WTFMove(context.wasmEntrypointByproducts));</span>
  
<span class="line-added">+     MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; entrypoint;</span>
      {
<span class="line-modified">!         Ref&lt;BBQCallee&gt; callee = BBQCallee::create(WTFMove(function-&gt;entrypoint), functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace), WTFMove(tierUp), WTFMove(unlinkedWasmToWasmCalls));</span>
<span class="line-modified">!         MacroAssembler::repatchPointer(function-&gt;calleeMoveLocation, CalleeBits::boxWasm(callee.ptr()));</span>
<span class="line-modified">!         ASSERT(!m_codeBlock-&gt;m_bbqCallees[m_functionIndex]);</span>
<span class="line-modified">!         entrypoint = callee-&gt;entrypoint();</span>
<span class="line-modified">! </span>
<span class="line-added">+         // We want to make sure we publish our callee at the same time as we link our callsites. This enables us to ensure we</span>
<span class="line-added">+         // always call the fastest code. Any function linked after us will see our new code and the new callsites, which they</span>
<span class="line-added">+         // will update. It&#39;s also ok if they publish their code before we reset the instruction caches because after we release</span>
<span class="line-added">+         // the lock our code is ready to be published too.</span>
<span class="line-added">+         LockHolder holder(m_codeBlock-&gt;m_lock);</span>
<span class="line-added">+         m_codeBlock-&gt;m_bbqCallees[m_functionIndex] = callee.copyRef();</span>
<span class="line-added">+         {</span>
<span class="line-added">+             LLIntCallee&amp; llintCallee = m_codeBlock-&gt;m_llintCallees-&gt;at(m_functionIndex).get();</span>
<span class="line-added">+             auto locker = holdLock(llintCallee.tierUpCounter().m_lock);</span>
<span class="line-added">+             llintCallee.setReplacement(callee.copyRef());</span>
<span class="line-added">+             llintCallee.tierUpCounter().m_compilationStatus = LLIntTierUpCounter::CompilationStatus::Compiled;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         for (auto&amp; call : callee-&gt;wasmToWasmCallsites()) {</span>
<span class="line-added">+             MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; entrypoint;</span>
<span class="line-added">+             if (call.functionIndexSpace &lt; m_moduleInformation-&gt;importFunctionCount())</span>
<span class="line-added">+                 entrypoint = m_codeBlock-&gt;m_wasmToWasmExitStubs[call.functionIndexSpace].code();</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 entrypoint = m_codeBlock-&gt;wasmEntrypointCalleeFromFunctionIndexSpace(call.functionIndexSpace).entrypoint().retagged&lt;WasmEntryPtrTag&gt;();</span>
<span class="line-added">+ </span>
<span class="line-added">+             MacroAssembler::repatchNearCall(call.callLocation, CodeLocationLabel&lt;WasmEntryPtrTag&gt;(entrypoint));</span>
          }
      }
  
<span class="line-modified">!     // It&#39;s important to make sure we do this before we make any of the code we just compiled visible. If we didn&#39;t, we could end up</span>
<span class="line-modified">!     // where we are tiering up some function A to A&#39; and we repatch some function B to call A&#39; instead of A. Another CPU could see</span>
<span class="line-modified">!     // the updates to B but still not have reset its cache of A&#39;, which would lead to all kinds of badness.</span>
<span class="line-modified">!     resetInstructionCacheOnAllThreads();</span>
<span class="line-modified">!     WTF::storeStoreFence(); // This probably isn&#39;t necessary but it&#39;s good to be paranoid.</span>
  
<span class="line-modified">!     m_codeBlock-&gt;m_wasmIndirectCallEntryPoints[m_functionIndex] = entrypoint;</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         LockHolder holder(m_codeBlock-&gt;m_lock);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         auto repatchCalls = [&amp;] (const Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; callsites) {</span>
<span class="line-modified">!             for (auto&amp; call : callsites) {</span>
<span class="line-added">+                 dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Considering repatching call at: &quot;, RawPointer(call.callLocation.dataLocation()), &quot; that targets &quot;, call.functionIndexSpace);</span>
<span class="line-added">+                 if (call.functionIndexSpace == functionIndexSpace) {</span>
<span class="line-added">+                     dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Repatching call at: &quot;, RawPointer(call.callLocation.dataLocation()), &quot; to &quot;, RawPointer(entrypoint.executableAddress()));</span>
<span class="line-added">+                     MacroAssembler::repatchNearCall(call.callLocation, CodeLocationLabel&lt;WasmEntryPtrTag&gt;(entrypoint));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         };</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (unsigned i = 0; i &lt; m_codeBlock-&gt;m_wasmToWasmCallsites.size(); ++i) {</span>
<span class="line-added">+             repatchCalls(m_codeBlock-&gt;m_wasmToWasmCallsites[i]);</span>
<span class="line-added">+             if (m_codeBlock-&gt;m_llintCallees) {</span>
<span class="line-added">+                 LLIntCallee&amp; llintCallee = m_codeBlock-&gt;m_llintCallees-&gt;at(i).get();</span>
<span class="line-added">+                 if (JITCallee* replacementCallee = llintCallee.replacement())</span>
<span class="line-added">+                     repatchCalls(replacementCallee-&gt;wasmToWasmCallsites());</span>
<span class="line-added">+                 if (OMGForOSREntryCallee* osrEntryCallee = llintCallee.osrEntryCallee())</span>
<span class="line-added">+                     repatchCalls(osrEntryCallee-&gt;wasmToWasmCallsites());</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (BBQCallee* bbqCallee = m_codeBlock-&gt;m_bbqCallees[i].get()) {</span>
<span class="line-added">+                 if (OMGCallee* replacementCallee = bbqCallee-&gt;replacement())</span>
<span class="line-added">+                     repatchCalls(replacementCallee-&gt;wasmToWasmCallsites());</span>
<span class="line-added">+                 if (OMGForOSREntryCallee* osrEntryCallee = bbqCallee-&gt;osrEntryCallee())</span>
<span class="line-added">+                     repatchCalls(osrEntryCallee-&gt;wasmToWasmCallsites());</span>
              }
          }
      }
  
<span class="line-modified">!     dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Finished BBQ &quot;, m_functionIndex);</span>
  
<span class="line-modified">! </span>
<span class="line-modified">!     auto locker = holdLock(m_lock);</span>
<span class="line-modified">!     moveToState(State::Completed);</span>
<span class="line-modified">!     runCompletionTasks(locker);</span>
  }
  
<span class="line-modified">! void BBQPlan::compileFunction(uint32_t functionIndex)</span>
  {
<span class="line-modified">!     m_unlinkedWasmToWasmCalls[functionIndex] = Vector&lt;UnlinkedWasmToWasmCall&gt;();</span>
  
<span class="line-modified">!     if (Options::useBBQTierUpChecks())</span>
<span class="line-modified">!         m_tierUpCounts[functionIndex] = makeUnique&lt;TierUpCount&gt;();</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!         m_tierUpCounts[functionIndex] = nullptr;</span>
  
<span class="line-modified">!     m_wasmInternalFunctions[functionIndex] = compileFunction(functionIndex, m_compilationContexts[functionIndex], m_unlinkedWasmToWasmCalls[functionIndex], m_tierUpCounts[functionIndex].get());</span>
  
<span class="line-modified">!     if (m_exportedFunctionIndices.contains(functionIndex) || m_moduleInformation-&gt;referencedFunctions().contains(functionIndex)) {</span>
<span class="line-modified">!         auto locker = holdLock(m_lock);</span>
<span class="line-modified">!         SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];</span>
<span class="line-modified">!         const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-added">+         auto result = m_embedderToWasmInternalFunctions.add(functionIndex, createJSToWasmWrapper(*m_compilationContexts[functionIndex].embedderEntrypointJIT, signature, &amp;m_unlinkedWasmToWasmCalls[functionIndex], m_moduleInformation.get(), m_mode, functionIndex));</span>
<span class="line-added">+         ASSERT_UNUSED(result, result.isNewEntry);</span>
      }
<span class="line-added">+ }</span>
  
<span class="line-modified">! std::unique_ptr&lt;InternalFunction&gt; BBQPlan::compileFunction(uint32_t functionIndex, CompilationContext&amp; context, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, TierUpCount* tierUp)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     const auto&amp; function = m_moduleInformation-&gt;functions[functionIndex];</span>
<span class="line-modified">!     SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];</span>
<span class="line-added">+     const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-added">+     unsigned functionIndexSpace = m_moduleInformation-&gt;importFunctionCount() + functionIndex;</span>
<span class="line-added">+     ASSERT_UNUSED(functionIndexSpace, m_moduleInformation-&gt;signatureIndexFromFunctionIndexSpace(functionIndexSpace) == signatureIndex);</span>
<span class="line-added">+     Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, String&gt; parseAndCompileResult;</span>
<span class="line-added">+     unsigned osrEntryScratchBufferSize = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // FIXME: Some webpages use very large Wasm module, and it exhausts all executable memory in ARM64 devices since the size of executable memory region is only limited to 128MB.</span>
<span class="line-added">+     // The long term solution should be to introduce a Wasm interpreter. But as a short term solution, we introduce heuristics to switch back to BBQ B3 at the sacrifice of start-up time,</span>
<span class="line-added">+     // as BBQ Air bloats such lengthy Wasm code and will consume a large amount of executable memory.</span>
<span class="line-added">+     bool forceUsingB3 = false;</span>
<span class="line-added">+     if (Options::webAssemblyBBQAirModeThreshold() &amp;&amp; m_moduleInformation-&gt;codeSectionSize &gt;= Options::webAssemblyBBQAirModeThreshold())</span>
<span class="line-added">+         forceUsingB3 = true;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!forceUsingB3 &amp;&amp; Options::wasmBBQUsesAir())</span>
<span class="line-added">+         parseAndCompileResult = parseAndCompileAir(context, function, signature, unlinkedWasmToWasmCalls, m_moduleInformation.get(), m_mode, functionIndex, tierUp);</span>
<span class="line-added">+     else</span>
<span class="line-added">+         parseAndCompileResult = parseAndCompile(context, function, signature, unlinkedWasmToWasmCalls, osrEntryScratchBufferSize, m_moduleInformation.get(), m_mode, CompilationMode::BBQMode, functionIndex, UINT32_MAX, tierUp);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (UNLIKELY(!parseAndCompileResult)) {</span>
<span class="line-added">+         auto locker = holdLock(m_lock);</span>
<span class="line-added">+         if (!m_errorMessage) {</span>
<span class="line-added">+             // Multiple compiles could fail simultaneously. We arbitrarily choose the first.</span>
<span class="line-added">+             fail(locker, makeString(parseAndCompileResult.error(), &quot;, in function at index &quot;, String::number(functionIndex))); // FIXME make this an Expected.</span>
          }
<span class="line-added">+         m_currentIndex = m_moduleInformation-&gt;functions.size();</span>
<span class="line-added">+         return nullptr;</span>
      }
  
<span class="line-modified">!     return WTFMove(*parseAndCompileResult);</span>
  }
  
<span class="line-modified">! void BBQPlan::didCompleteCompilation(const AbstractLocker&amp; locker)</span>
  {
<span class="line-modified">!     for (uint32_t functionIndex = 0; functionIndex &lt; m_moduleInformation-&gt;functions.size(); functionIndex++) {</span>
<span class="line-modified">!         CompilationContext&amp; context = m_compilationContexts[functionIndex];</span>
<span class="line-modified">!         SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];</span>
<span class="line-modified">!         const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-modified">!         const uint32_t functionIndexSpace = functionIndex + m_moduleInformation-&gt;importFunctionCount();</span>
<span class="line-modified">!         ASSERT(functionIndexSpace &lt; m_moduleInformation-&gt;functionIndexSpaceSize());</span>
          {
<span class="line-modified">!             LinkBuffer linkBuffer(*context.wasmEntrypointJIT, nullptr, JITCompilationCanFail);</span>
<span class="line-modified">!             if (UNLIKELY(linkBuffer.didFailToAllocate())) {</span>
<span class="line-modified">!                 Base::fail(locker, makeString(&quot;Out of executable memory in function at index &quot;, String::number(functionIndex)));</span>
                  return;
              }
  
<span class="line-modified">!             m_wasmInternalFunctions[functionIndex]-&gt;entrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(</span>
<span class="line-modified">!                 FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;WebAssembly BBQ function[%i] %s name %s&quot;, functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
<span class="line-modified">!                 WTFMove(context.wasmEntrypointByproducts));</span>
          }
  
<span class="line-modified">!         if (const auto&amp; embedderToWasmInternalFunction = m_embedderToWasmInternalFunctions.get(functionIndex)) {</span>
<span class="line-added">+             LinkBuffer linkBuffer(*context.embedderEntrypointJIT, nullptr, JITCompilationCanFail);</span>
<span class="line-added">+             if (UNLIKELY(linkBuffer.didFailToAllocate())) {</span>
<span class="line-added">+                 Base::fail(locker, makeString(&quot;Out of executable memory in function entrypoint at index &quot;, String::number(functionIndex)));</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             embedderToWasmInternalFunction-&gt;entrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(</span>
<span class="line-modified">!                 FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;Embedder-&gt;WebAssembly entrypoint[%i] %s name %s&quot;, functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
<span class="line-modified">!                 WTFMove(context.embedderEntrypointByproducts));</span>
          }
<span class="line-added">+     }</span>
  
<span class="line-modified">!     for (auto&amp; unlinked : m_unlinkedWasmToWasmCalls) {</span>
<span class="line-added">+         for (auto&amp; call : unlinked) {</span>
<span class="line-added">+             MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; executableAddress;</span>
<span class="line-added">+             if (m_moduleInformation-&gt;isImportedFunctionFromFunctionIndexSpace(call.functionIndexSpace)) {</span>
<span class="line-added">+                 // FIXME imports could have been linked in B3, instead of generating a patchpoint. This condition should be replaced by a RELEASE_ASSERT. https://bugs.webkit.org/show_bug.cgi?id=166462</span>
<span class="line-added">+                 executableAddress = m_wasmToWasmExitStubs.at(call.functionIndexSpace).code();</span>
<span class="line-added">+             } else</span>
<span class="line-added">+                 executableAddress = m_wasmInternalFunctions.at(call.functionIndexSpace - m_moduleInformation-&gt;importFunctionCount())-&gt;entrypoint.compilation-&gt;code().retagged&lt;WasmEntryPtrTag&gt;();</span>
<span class="line-added">+             MacroAssembler::repatchNearCall(call.callLocation, CodeLocationLabel&lt;WasmEntryPtrTag&gt;(executableAddress));</span>
<span class="line-added">+         }</span>
      }
  }
  
<span class="line-modified">! void BBQPlan::initializeCallees(const CalleeInitializer&amp; callback)</span>
  {
<span class="line-modified">!     ASSERT(!failed());</span>
<span class="line-modified">!     for (unsigned internalFunctionIndex = 0; internalFunctionIndex &lt; m_wasmInternalFunctions.size(); ++internalFunctionIndex) {</span>
  
<span class="line-modified">!         RefPtr&lt;EmbedderEntrypointCallee&gt; embedderEntrypointCallee;</span>
<span class="line-modified">!         if (auto embedderToWasmFunction = m_embedderToWasmInternalFunctions.get(internalFunctionIndex)) {</span>
<span class="line-modified">!             embedderEntrypointCallee = EmbedderEntrypointCallee::create(WTFMove(embedderToWasmFunction-&gt;entrypoint));</span>
<span class="line-modified">!             MacroAssembler::repatchPointer(embedderToWasmFunction-&gt;calleeMoveLocation, CalleeBits::boxWasm(embedderEntrypointCallee.get()));</span>
          }
  
<span class="line-modified">!         InternalFunction* function = m_wasmInternalFunctions[internalFunctionIndex].get();</span>
<span class="line-modified">!         size_t functionIndexSpace = internalFunctionIndex + m_moduleInformation-&gt;importFunctionCount();</span>
<span class="line-modified">!         Ref&lt;BBQCallee&gt; wasmEntrypointCallee = BBQCallee::create(WTFMove(function-&gt;entrypoint), functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace), WTFMove(m_tierUpCounts[internalFunctionIndex]), WTFMove(m_unlinkedWasmToWasmCalls[internalFunctionIndex]));</span>
<span class="line-modified">!         MacroAssembler::repatchPointer(function-&gt;calleeMoveLocation, CalleeBits::boxWasm(wasmEntrypointCallee.ptr()));</span>
  
<span class="line-modified">!         callback(internalFunctionIndex, WTFMove(embedderEntrypointCallee), WTFMove(wasmEntrypointCallee));</span>
      }
  }
  
<span class="line-modified">! bool BBQPlan::didReceiveFunctionData(unsigned, const FunctionData&amp;)</span>
  {
<span class="line-modified">!     return true;</span>
  }
  
  } } // namespace JSC::Wasm
  
  #endif // ENABLE(WEBASSEMBLY)
</pre>
<center><a href="WasmB3IRGenerator.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmBBQPlan.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGInPlaceAbstractState.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGInPlaceAbstractState.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGInPlaceAbstractState.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGInPlaceAbstractState.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -28,27 +28,27 @@
 
 #if ENABLE(DFG_JIT)
 
 #include "CodeBlock.h"
 #include "DFGBasicBlock.h"
-#include "GetByIdStatus.h"
+#include "GetByStatus.h"
 #include "JSCInlines.h"
 #include "PutByIdStatus.h"
 #include "StringObject.h"
 #include "SuperSampler.h"
 
 namespace JSC { namespace DFG {
 
 namespace DFGInPlaceAbstractStateInternal {
-static const bool verbose = false;
+static constexpr bool verbose = false;
 }
 
 InPlaceAbstractState::InPlaceAbstractState(Graph& graph)
     : m_graph(graph)
     , m_abstractValues(*graph.m_abstractValuesCache)
-    , m_variables(m_graph.m_codeBlock->numParameters(), graph.m_localVars)
-    , m_block(0)
+    , m_variables(OperandsLike, graph.block(0)->variablesAtHead)
+    , m_block(nullptr)
 {
 }
 
 InPlaceAbstractState::~InPlaceAbstractState() { }
 
@@ -82,11 +82,11 @@
         }
     }
     basicBlock->cfaShouldRevisit = false;
     basicBlock->cfaHasVisited = true;
     m_isValid = true;
-    m_foundConstants = false;
+    m_shouldTryConstantFolding = false;
     m_branchDirection = InvalidBranchDirection;
     m_structureClobberState = basicBlock->cfaStructureClobberStateAtHead;
 }
 
 static void setLiveValues(Vector<NodeAbstractValuePair>& values, const Vector<NodeFlowProjection>& live)
@@ -112,11 +112,11 @@
 void InPlaceAbstractState::initialize()
 {
     for (BasicBlock* entrypoint : m_graph.m_roots) {
         entrypoint->cfaShouldRevisit = true;
         entrypoint->cfaHasVisited = false;
-        entrypoint->cfaFoundConstants = false;
+        entrypoint->cfaThinksShouldTryConstantFolding = false;
         entrypoint->cfaStructureClobberStateAtHead = StructuresAreWatched;
         entrypoint->cfaStructureClobberStateAtTail = StructuresAreWatched;
 
         if (m_graph.m_form == SSA)  {
             for (size_t i = 0; i < entrypoint->valuesAtHead.numberOfArguments(); ++i) {
@@ -170,11 +170,11 @@
         }
 
         ASSERT(block->isReachable);
         block->cfaShouldRevisit = false;
         block->cfaHasVisited = false;
-        block->cfaFoundConstants = false;
+        block->cfaThinksShouldTryConstantFolding = false;
         block->cfaStructureClobberStateAtHead = StructuresAreWatched;
         block->cfaStructureClobberStateAtTail = StructuresAreWatched;
         for (size_t i = 0; i < block->valuesAtHead.numberOfArguments(); ++i) {
             block->valuesAtHead.argument(i).clear();
             block->valuesAtTail.argument(i).clear();
@@ -200,11 +200,11 @@
 {
     ASSERT(m_block);
 
     BasicBlock* block = m_block; // Save the block for successor merging.
 
-    block->cfaFoundConstants = m_foundConstants;
+    block->cfaThinksShouldTryConstantFolding = m_shouldTryConstantFolding;
     block->cfaDidFinish = m_isValid;
     block->cfaBranchDirection = m_branchDirection;
 
     if (!m_isValid) {
         reset();

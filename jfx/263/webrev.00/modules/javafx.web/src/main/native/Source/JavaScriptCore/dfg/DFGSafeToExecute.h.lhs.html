<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSafeToExecute.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(DFG_JIT)
 29 
 30 #include &quot;DFGGraph.h&quot;
 31 
 32 namespace JSC { namespace DFG {
 33 
<a name="1" id="anc1"></a>





 34 template&lt;typename AbstractStateType&gt;
 35 class SafeToExecuteEdge {
 36 public:
 37     SafeToExecuteEdge(AbstractStateType&amp; state)
 38         : m_state(state)
 39     {
 40     }
 41 
 42     void operator()(Node*, Edge edge)
 43     {
 44         m_maySeeEmptyChild |= !!(m_state.forNode(edge).m_type &amp; SpecEmpty);
 45 
 46         switch (edge.useKind()) {
 47         case UntypedUse:
 48         case Int32Use:
 49         case DoubleRepUse:
 50         case DoubleRepRealUse:
 51         case Int52RepUse:
 52         case NumberUse:
 53         case RealNumberUse:
 54         case BooleanUse:
 55         case CellUse:
 56         case CellOrOtherUse:
 57         case ObjectUse:
 58         case ArrayUse:
 59         case FunctionUse:
 60         case FinalObjectUse:
 61         case RegExpObjectUse:
<a name="2" id="anc2"></a>
 62         case ProxyObjectUse:
 63         case DerivedArrayUse:
<a name="3" id="anc3"></a>
 64         case MapObjectUse:
 65         case SetObjectUse:
 66         case WeakMapObjectUse:
 67         case WeakSetObjectUse:
 68         case DataViewObjectUse:
 69         case ObjectOrOtherUse:
 70         case StringIdentUse:
 71         case StringUse:
 72         case StringOrOtherUse:
 73         case SymbolUse:
 74         case BigIntUse:
 75         case StringObjectUse:
 76         case StringOrStringObjectUse:
 77         case NotStringVarUse:
 78         case NotSymbolUse:
 79         case NotCellUse:
 80         case OtherUse:
 81         case MiscUse:
 82         case AnyIntUse:
 83         case DoubleRepAnyIntUse:
 84             return;
 85 
 86         case KnownInt32Use:
 87             if (m_state.forNode(edge).m_type &amp; ~SpecInt32Only)
 88                 m_result = false;
 89             return;
 90 
 91         case KnownBooleanUse:
 92             if (m_state.forNode(edge).m_type &amp; ~SpecBoolean)
 93                 m_result = false;
 94             return;
 95 
 96         case KnownCellUse:
 97             if (m_state.forNode(edge).m_type &amp; ~SpecCell)
 98                 m_result = false;
 99             return;
100 
101         case KnownStringUse:
102             if (m_state.forNode(edge).m_type &amp; ~SpecString)
103                 m_result = false;
104             return;
105 
106         case KnownPrimitiveUse:
107             if (m_state.forNode(edge).m_type &amp; ~(SpecHeapTop &amp; ~SpecObject))
108                 m_result = false;
109             return;
110 
111         case KnownOtherUse:
112             if (m_state.forNode(edge).m_type &amp; ~SpecOther)
113                 m_result = false;
114             return;
115 
116         case LastUseKind:
117             RELEASE_ASSERT_NOT_REACHED();
118             break;
119         }
120         RELEASE_ASSERT_NOT_REACHED();
121     }
122 
123     bool result() const { return m_result; }
124     bool maySeeEmptyChild() const { return m_maySeeEmptyChild; }
125 private:
126     AbstractStateType&amp; m_state;
127     bool m_result { true };
128     bool m_maySeeEmptyChild { false };
129 };
130 
131 // Determines if it&#39;s safe to execute a node within the given abstract state. This may
132 // return false conservatively. If it returns true, then you can hoist the given node
133 // up to the given point and expect that it will not crash. It also guarantees that the
134 // node will not produce a malformed JSValue or object pointer when executed in the
135 // given state. But this doesn&#39;t guarantee that the node will produce the result you
136 // wanted. For example, you may have a GetByOffset from a prototype that only makes
137 // semantic sense if you&#39;ve also checked that some nearer prototype doesn&#39;t also have
138 // a property of the same name. This could still return true even if that check hadn&#39;t
139 // been performed in the given abstract state. That&#39;s fine though: the load can still
140 // safely execute before that check, so long as that check continues to guard any
141 // user-observable things done to the loaded value.
142 template&lt;typename AbstractStateType&gt;
143 bool safeToExecute(AbstractStateType&amp; state, Graph&amp; graph, Node* node, bool ignoreEmptyChildren = false)
144 {
145     SafeToExecuteEdge&lt;AbstractStateType&gt; safeToExecuteEdge(state);
146     DFG_NODE_DO_TO_CHILDREN(graph, node, safeToExecuteEdge);
147     if (!safeToExecuteEdge.result())
148         return false;
149 
150     if (!ignoreEmptyChildren &amp;&amp; safeToExecuteEdge.maySeeEmptyChild()) {
151         // We conservatively assume if the empty value flows into a node,
152         // it might not be able to handle it (e.g, crash). In general, the bytecode generator
153         // emits code in such a way that most node types don&#39;t need to worry about the empty value
154         // because they will never see it. However, code motion has to consider the empty
155         // value so it does not insert/move nodes to a place where they will crash. E.g, the
156         // type check hoisting phase needs to insert CheckStructureOrEmpty instead of CheckStructure
157         // for hoisted structure checks because it can not guarantee that a particular local is not
158         // the empty value.
159         switch (node-&gt;op()) {
160         case CheckNotEmpty:
161         case CheckStructureOrEmpty:
<a name="4" id="anc4"></a>
162             break;
163         default:
164             return false;
165         }
166     }
167 
<a name="5" id="anc5"></a><span class="line-modified">168     // NOTE: This tends to lie when it comes to effectful nodes, because it knows that they aren&#39;t going to</span>
<span class="line-modified">169     // get hoisted anyway.</span>


170 
171     switch (node-&gt;op()) {
<a name="6" id="anc6"></a>

172     case JSConstant:
173     case DoubleConstant:
174     case Int52Constant:
175     case LazyJSConstant:
176     case Identity:
177     case IdentityWithProfile:
<a name="7" id="anc7"></a><span class="line-removed">178     case ToThis:</span>
<span class="line-removed">179     case CreateThis:</span>
<span class="line-removed">180     case ObjectCreate:</span>
<span class="line-removed">181     case ObjectKeys:</span>
182     case GetCallee:
<a name="8" id="anc8"></a><span class="line-removed">183     case SetCallee:</span>
184     case GetArgumentCountIncludingThis:
<a name="9" id="anc9"></a><span class="line-removed">185     case SetArgumentCountIncludingThis:</span>
186     case GetRestLength:
187     case GetLocal:
<a name="10" id="anc10"></a><span class="line-removed">188     case SetLocal:</span>
<span class="line-removed">189     case PutStack:</span>
<span class="line-removed">190     case KillStack:</span>
191     case GetStack:
<a name="11" id="anc11"></a><span class="line-removed">192     case MovHint:</span>
<span class="line-removed">193     case ZombieHint:</span>
194     case ExitOK:
195     case Phantom:
<a name="12" id="anc12"></a><span class="line-removed">196     case Upsilon:</span>
<span class="line-removed">197     case Phi:</span>
<span class="line-removed">198     case Flush:</span>
<span class="line-removed">199     case PhantomLocal:</span>
<span class="line-removed">200     case SetArgumentDefinitely:</span>
<span class="line-removed">201     case SetArgumentMaybe:</span>
202     case ArithBitNot:
203     case ArithBitAnd:
204     case ArithBitOr:
205     case ArithBitXor:
206     case ArithBitLShift:
<a name="13" id="anc13"></a><span class="line-modified">207     case BitRShift:</span>
208     case BitURShift:
209     case ValueToInt32:
210     case UInt32ToNumber:
211     case DoubleAsInt32:
212     case ArithAdd:
213     case ArithClz32:
214     case ArithSub:
215     case ArithNegate:
216     case ArithMul:
217     case ArithIMul:
218     case ArithDiv:
219     case ArithMod:
220     case ArithAbs:
221     case ArithMin:
222     case ArithMax:
223     case ArithPow:
224     case ArithRandom:
225     case ArithSqrt:
226     case ArithFRound:
227     case ArithRound:
228     case ArithFloor:
229     case ArithCeil:
230     case ArithTrunc:
231     case ArithUnary:
<a name="14" id="anc14"></a><span class="line-modified">232     case ValueBitAnd:</span>
<span class="line-removed">233     case ValueBitXor:</span>
<span class="line-removed">234     case ValueBitOr:</span>
<span class="line-removed">235     case ValueBitNot:</span>
<span class="line-removed">236     case ValueBitLShift:</span>
<span class="line-removed">237     case ValueNegate:</span>
<span class="line-removed">238     case ValueAdd:</span>
<span class="line-removed">239     case ValueSub:</span>
<span class="line-removed">240     case ValueMul:</span>
<span class="line-removed">241     case ValueDiv:</span>
<span class="line-removed">242     case ValueMod:</span>
<span class="line-removed">243     case ValuePow:</span>
<span class="line-removed">244     case TryGetById:</span>
<span class="line-removed">245     case DeleteById:</span>
<span class="line-removed">246     case DeleteByVal:</span>
<span class="line-removed">247     case GetById:</span>
<span class="line-removed">248     case GetByIdWithThis:</span>
<span class="line-removed">249     case GetByValWithThis:</span>
<span class="line-removed">250     case GetByIdFlush:</span>
<span class="line-removed">251     case GetByIdDirect:</span>
<span class="line-removed">252     case GetByIdDirectFlush:</span>
<span class="line-removed">253     case PutById:</span>
<span class="line-removed">254     case PutByIdFlush:</span>
<span class="line-removed">255     case PutByIdWithThis:</span>
<span class="line-removed">256     case PutByValWithThis:</span>
<span class="line-removed">257     case PutByIdDirect:</span>
<span class="line-removed">258     case PutGetterById:</span>
<span class="line-removed">259     case PutSetterById:</span>
<span class="line-removed">260     case PutGetterSetterById:</span>
<span class="line-removed">261     case PutGetterByVal:</span>
<span class="line-removed">262     case PutSetterByVal:</span>
<span class="line-removed">263     case DefineDataProperty:</span>
<span class="line-removed">264     case DefineAccessorProperty:</span>
265     case CheckStructure:
266     case CheckStructureOrEmpty:
267     case GetExecutable:
<a name="15" id="anc15"></a><span class="line-removed">268     case GetButterfly:</span>
269     case CallDOMGetter:
270     case CallDOM:
271     case CheckSubClass:
272     case CheckArray:
<a name="16" id="anc16"></a><span class="line-modified">273     case Arrayify:</span>
<span class="line-removed">274     case ArrayifyToStructure:</span>
275     case GetScope:
276     case SkipScope:
277     case GetGlobalObject:
278     case GetGlobalThis:
279     case GetClosureVar:
<a name="17" id="anc17"></a><span class="line-removed">280     case PutClosureVar:</span>
281     case GetGlobalVar:
282     case GetGlobalLexicalVariable:
<a name="18" id="anc18"></a><span class="line-removed">283     case PutGlobalVariable:</span>
284     case CheckCell:
<a name="19" id="anc19"></a><span class="line-removed">285     case CheckBadCell:</span>
286     case CheckNotEmpty:
287     case AssertNotEmpty:
<a name="20" id="anc20"></a><span class="line-modified">288     case CheckStringIdent:</span>
<span class="line-removed">289     case RegExpExec:</span>
<span class="line-removed">290     case RegExpExecNonGlobalOrSticky:</span>
<span class="line-removed">291     case RegExpTest:</span>
<span class="line-removed">292     case RegExpMatchFast:</span>
<span class="line-removed">293     case RegExpMatchFastGlobal:</span>
294     case CompareLess:
295     case CompareLessEq:
296     case CompareGreater:
297     case CompareGreaterEq:
298     case CompareBelow:
299     case CompareBelowEq:
300     case CompareEq:
301     case CompareStrictEq:
302     case CompareEqPtr:
303     case SameValue:
<a name="21" id="anc21"></a><span class="line-removed">304     case Call:</span>
<span class="line-removed">305     case DirectCall:</span>
<span class="line-removed">306     case TailCallInlinedCaller:</span>
<span class="line-removed">307     case DirectTailCallInlinedCaller:</span>
<span class="line-removed">308     case Construct:</span>
<span class="line-removed">309     case DirectConstruct:</span>
<span class="line-removed">310     case CallVarargs:</span>
<span class="line-removed">311     case CallEval:</span>
<span class="line-removed">312     case TailCallVarargsInlinedCaller:</span>
<span class="line-removed">313     case TailCallForwardVarargsInlinedCaller:</span>
<span class="line-removed">314     case ConstructVarargs:</span>
<span class="line-removed">315     case LoadVarargs:</span>
<span class="line-removed">316     case CallForwardVarargs:</span>
<span class="line-removed">317     case ConstructForwardVarargs:</span>
<span class="line-removed">318     case NewObject:</span>
<span class="line-removed">319     case NewArray:</span>
<span class="line-removed">320     case NewArrayWithSize:</span>
<span class="line-removed">321     case NewArrayBuffer:</span>
<span class="line-removed">322     case NewArrayWithSpread:</span>
<span class="line-removed">323     case Spread:</span>
<span class="line-removed">324     case NewRegexp:</span>
<span class="line-removed">325     case NewSymbol:</span>
<span class="line-removed">326     case ProfileType:</span>
<span class="line-removed">327     case ProfileControlFlow:</span>
328     case CheckTypeInfoFlags:
329     case ParseInt:
330     case OverridesHasInstance:
<a name="22" id="anc22"></a><span class="line-removed">331     case InstanceOf:</span>
<span class="line-removed">332     case InstanceOfCustom:</span>
333     case IsEmpty:
334     case IsUndefined:
335     case IsUndefinedOrNull:
336     case IsBoolean:
337     case IsNumber:
338     case NumberIsInteger:
339     case IsObject:
340     case IsObjectOrNull:
341     case IsFunction:
342     case IsCellWithType:
343     case IsTypedArrayView:
344     case TypeOf:
345     case LogicalNot:
<a name="23" id="anc23"></a><span class="line-removed">346     case CallObjectConstructor:</span>
<span class="line-removed">347     case ToPrimitive:</span>
348     case ToString:
<a name="24" id="anc24"></a><span class="line-removed">349     case ToNumber:</span>
<span class="line-removed">350     case ToObject:</span>
<span class="line-removed">351     case NumberToStringWithRadix:</span>
352     case NumberToStringWithValidRadixConstant:
<a name="25" id="anc25"></a><span class="line-removed">353     case SetFunctionName:</span>
354     case StrCat:
355     case CallStringConstructor:
<a name="26" id="anc26"></a><span class="line-removed">356     case NewStringObject:</span>
357     case MakeRope:
<a name="27" id="anc27"></a><span class="line-removed">358     case InByVal:</span>
<span class="line-removed">359     case InById:</span>
<span class="line-removed">360     case HasOwnProperty:</span>
<span class="line-removed">361     case PushWithScope:</span>
<span class="line-removed">362     case CreateActivation:</span>
<span class="line-removed">363     case CreateDirectArguments:</span>
<span class="line-removed">364     case CreateScopedArguments:</span>
<span class="line-removed">365     case CreateClonedArguments:</span>
366     case GetFromArguments:
367     case GetArgument:
<a name="28" id="anc28"></a><span class="line-removed">368     case PutToArguments:</span>
<span class="line-removed">369     case NewFunction:</span>
<span class="line-removed">370     case NewGeneratorFunction:</span>
<span class="line-removed">371     case NewAsyncGeneratorFunction:</span>
<span class="line-removed">372     case NewAsyncFunction:</span>
<span class="line-removed">373     case Jump:</span>
<span class="line-removed">374     case Branch:</span>
<span class="line-removed">375     case Switch:</span>
<span class="line-removed">376     case EntrySwitch:</span>
<span class="line-removed">377     case Return:</span>
<span class="line-removed">378     case TailCall:</span>
<span class="line-removed">379     case DirectTailCall:</span>
<span class="line-removed">380     case TailCallVarargs:</span>
<span class="line-removed">381     case TailCallForwardVarargs:</span>
<span class="line-removed">382     case Throw:</span>
<span class="line-removed">383     case ThrowStaticError:</span>
<span class="line-removed">384     case CountExecution:</span>
<span class="line-removed">385     case SuperSamplerBegin:</span>
<span class="line-removed">386     case SuperSamplerEnd:</span>
<span class="line-removed">387     case ForceOSRExit:</span>
<span class="line-removed">388     case CPUIntrinsic:</span>
<span class="line-removed">389     case CheckTraps:</span>
<span class="line-removed">390     case LogShadowChickenPrologue:</span>
<span class="line-removed">391     case LogShadowChickenTail:</span>
392     case StringFromCharCode:
<a name="29" id="anc29"></a><span class="line-removed">393     case NewTypedArray:</span>
<span class="line-removed">394     case Unreachable:</span>
395     case ExtractOSREntryLocal:
396     case ExtractCatchLocal:
<a name="30" id="anc30"></a><span class="line-removed">397     case ClearCatchLocals:</span>
<span class="line-removed">398     case CheckTierUpInLoop:</span>
<span class="line-removed">399     case CheckTierUpAtReturn:</span>
<span class="line-removed">400     case CheckTierUpAndOSREnter:</span>
<span class="line-removed">401     case LoopHint:</span>
<span class="line-removed">402     case InvalidationPoint:</span>
<span class="line-removed">403     case NotifyWrite:</span>
404     case CheckInBounds:
405     case ConstantStoragePointer:
406     case Check:
407     case CheckVarargs:
<a name="31" id="anc31"></a><span class="line-removed">408     case MultiPutByOffset:</span>
409     case ValueRep:
410     case DoubleRep:
411     case Int52Rep:
412     case BooleanToNumber:
413     case FiatInt52:
<a name="32" id="anc32"></a><span class="line-removed">414     case GetGetter:</span>
<span class="line-removed">415     case GetSetter:</span>
<span class="line-removed">416     case GetEnumerableLength:</span>
<span class="line-removed">417     case HasGenericProperty:</span>
<span class="line-removed">418     case HasStructureProperty:</span>
419     case HasIndexedProperty:
<a name="33" id="anc33"></a><span class="line-removed">420     case GetDirectPname:</span>
<span class="line-removed">421     case GetPropertyEnumerator:</span>
422     case GetEnumeratorStructurePname:
423     case GetEnumeratorGenericPname:
424     case ToIndexString:
<a name="34" id="anc34"></a><span class="line-removed">425     case PhantomNewObject:</span>
<span class="line-removed">426     case PhantomNewFunction:</span>
<span class="line-removed">427     case PhantomNewGeneratorFunction:</span>
<span class="line-removed">428     case PhantomNewAsyncGeneratorFunction:</span>
<span class="line-removed">429     case PhantomNewAsyncFunction:</span>
<span class="line-removed">430     case PhantomCreateActivation:</span>
<span class="line-removed">431     case PhantomNewRegexp:</span>
<span class="line-removed">432     case PutHint:</span>
433     case CheckStructureImmediate:
<a name="35" id="anc35"></a><span class="line-removed">434     case MaterializeNewObject:</span>
<span class="line-removed">435     case MaterializeCreateActivation:</span>
<span class="line-removed">436     case PhantomDirectArguments:</span>
<span class="line-removed">437     case PhantomCreateRest:</span>
<span class="line-removed">438     case PhantomSpread:</span>
<span class="line-removed">439     case PhantomNewArrayWithSpread:</span>
<span class="line-removed">440     case PhantomNewArrayBuffer:</span>
<span class="line-removed">441     case PhantomClonedArguments:</span>
442     case GetMyArgumentByVal:
443     case GetMyArgumentByValOutOfBounds:
<a name="36" id="anc36"></a><span class="line-removed">444     case ForwardVarargs:</span>
<span class="line-removed">445     case CreateRest:</span>
446     case GetPrototypeOf:
447     case StringReplace:
448     case StringReplaceRegExp:
449     case GetRegExpObjectLastIndex:
<a name="37" id="anc37"></a><span class="line-removed">450     case SetRegExpObjectLastIndex:</span>
<span class="line-removed">451     case RecordRegExpCachedResult:</span>
<span class="line-removed">452     case GetDynamicVar:</span>
<span class="line-removed">453     case PutDynamicVar:</span>
<span class="line-removed">454     case ResolveScopeForHoistingFuncDeclInEval:</span>
<span class="line-removed">455     case ResolveScope:</span>
456     case MapHash:
457     case NormalizeMapKey:
<a name="38" id="anc38"></a><span class="line-removed">458     case StringValueOf:</span>
459     case StringSlice:
460     case ToLowerCase:
461     case GetMapBucket:
462     case GetMapBucketHead:
463     case GetMapBucketNext:
464     case LoadKeyFromMapBucket:
465     case LoadValueFromMapBucket:
466     case ExtractValueFromWeakMapGet:
467     case WeakMapGet:
<a name="39" id="anc39"></a><span class="line-removed">468     case WeakSetAdd:</span>
<span class="line-removed">469     case WeakMapSet:</span>
<span class="line-removed">470     case AtomicsAdd:</span>
<span class="line-removed">471     case AtomicsAnd:</span>
<span class="line-removed">472     case AtomicsCompareExchange:</span>
<span class="line-removed">473     case AtomicsExchange:</span>
<span class="line-removed">474     case AtomicsLoad:</span>
<span class="line-removed">475     case AtomicsOr:</span>
<span class="line-removed">476     case AtomicsStore:</span>
<span class="line-removed">477     case AtomicsSub:</span>
<span class="line-removed">478     case AtomicsXor:</span>
479     case AtomicsIsLockFree:
<a name="40" id="anc40"></a><span class="line-removed">480     case InitializeEntrypointArguments:</span>
481     case MatchStructure:
<a name="41" id="anc41"></a>

482     case DataViewGetInt:
483     case DataViewGetFloat:
484         return true;
485 
<a name="42" id="anc42"></a>


486     case ArraySlice:
487     case ArrayIndexOf: {
488         // You could plausibly move this code around as long as you proved the
489         // incoming array base structure is an original array at the hoisted location.
490         // Instead of doing that extra work, we just conservatively return false.
491         return false;
492     }
493 
<a name="43" id="anc43"></a>










494     case BottomValue:
495         // If in doubt, assume that this isn&#39;t safe to execute, just because we have no way of
496         // compiling this node.
497         return false;
498 
499     case StoreBarrier:
500     case FencedStoreBarrier:
501     case PutStructure:
502     case NukeStructureAndSetButterfly:
503         // We conservatively assume that these cannot be put anywhere, which forces the compiler to
504         // keep them exactly where they were. This is sort of overkill since the clobberize effects
505         // already force these things to be ordered precisely. I&#39;m just not confident enough in my
506         // effect based memory model to rely solely on that right now.
507         return false;
508 
509     case FilterCallLinkStatus:
<a name="44" id="anc44"></a><span class="line-modified">510     case FilterGetByIdStatus:</span>
511     case FilterPutByIdStatus:
512     case FilterInByIdStatus:
513         // We don&#39;t want these to be moved anywhere other than where we put them, since we want them
514         // to capture &quot;profiling&quot; at the point in control flow here the user put them.
515         return false;
516 
517     case GetByVal:
518     case GetIndexedPropertyStorage:
519     case GetArrayLength:
520     case GetVectorLength:
521     case ArrayPop:
522     case StringCharAt:
523     case StringCharCodeAt:
<a name="45" id="anc45"></a>
524         return node-&gt;arrayMode().alreadyChecked(graph, node, state.forNode(graph.child(node, 0)));
525 
526     case ArrayPush:
527         return node-&gt;arrayMode().alreadyChecked(graph, node, state.forNode(graph.varArgChild(node, 1)));
528 
<a name="46" id="anc46"></a>
529     case GetTypedArrayByteOffset:
530         return !(state.forNode(node-&gt;child1()).m_type &amp; ~(SpecTypedArrayView));
531 
532     case PutByValDirect:
533     case PutByVal:
534     case PutByValAlias:
535         return node-&gt;arrayMode().modeForPut().alreadyChecked(
536             graph, node, state.forNode(graph.varArgChild(node, 0)));
537 
538     case AllocatePropertyStorage:
539     case ReallocatePropertyStorage:
540         return state.forNode(node-&gt;child1()).m_structure.isSubsetOf(
541             RegisteredStructureSet(node-&gt;transition()-&gt;previous));
542 
<a name="47" id="anc47"></a>






















543     case GetByOffset:
<a name="48" id="anc48"></a><span class="line-removed">544     case GetGetterSetterByOffset:</span>
545     case PutByOffset: {
<a name="49" id="anc49"></a>



546         StorageAccessData&amp; data = node-&gt;storageAccessData();
547         PropertyOffset offset = data.offset;
548         // Graph::isSafeToLoad() is all about proofs derived from PropertyConditions. Those don&#39;t
549         // know anything about inferred types. But if we have a proof derived from watching a
550         // structure that has a type proof, then the next case below will deal with it.
551         if (state.structureClobberState() == StructuresAreWatched) {
552             if (JSObject* knownBase = node-&gt;child2()-&gt;dynamicCastConstant&lt;JSObject*&gt;(graph.m_vm)) {
553                 if (graph.isSafeToLoad(knownBase, offset))
554                     return true;
555             }
556         }
557 
558         StructureAbstractValue&amp; value = state.forNode(node-&gt;child2()).m_structure;
559         if (value.isInfinite())
560             return false;
561         for (unsigned i = value.size(); i--;) {
562             Structure* thisStructure = value[i].get();
<a name="50" id="anc50"></a>

563             if (!thisStructure-&gt;isValidOffset(offset))
564                 return false;
565         }
566         return true;
567     }
568 
569     case MultiGetByOffset: {
570         // We can&#39;t always guarantee that the MultiGetByOffset is safe to execute if it
571         // contains loads from prototypes. If the load requires a check in IR, which is rare, then
572         // we currently claim that we don&#39;t know if it&#39;s safe to execute because finding that
573         // check in the abstract state would be hard. If the load requires watchpoints, we just
574         // check if we&#39;re not in a clobbered state (i.e. in between a side effect and an
575         // invalidation point).
576         for (const MultiGetByOffsetCase&amp; getCase : node-&gt;multiGetByOffsetData().cases) {
577             GetByOffsetMethod method = getCase.method();
578             switch (method.kind()) {
579             case GetByOffsetMethod::Invalid:
580                 RELEASE_ASSERT_NOT_REACHED();
581                 break;
582             case GetByOffsetMethod::Constant: // OK because constants are always safe to execute.
583             case GetByOffsetMethod::Load: // OK because the MultiGetByOffset has its own checks for loading from self.
584                 break;
585             case GetByOffsetMethod::LoadFromPrototype:
586                 // Only OK if the state isn&#39;t clobbered. That&#39;s almost always the case.
587                 if (state.structureClobberState() != StructuresAreWatched)
588                     return false;
589                 if (!graph.isSafeToLoad(method.prototype()-&gt;cast&lt;JSObject*&gt;(), method.offset()))
590                     return false;
591                 break;
592             }
593         }
594         return true;
595     }
596 
<a name="51" id="anc51"></a>



















































































































































































597     case DataViewSet:
<a name="52" id="anc52"></a><span class="line-removed">598         return false;</span>
<span class="line-removed">599 </span>
600     case SetAdd:
601     case MapSet:
602         return false;
603 
<a name="53" id="anc53"></a>



















604     case LastNodeType:
605         RELEASE_ASSERT_NOT_REACHED();
606         return false;
607     }
608 
609     RELEASE_ASSERT_NOT_REACHED();
610     return false;
611 }
612 
613 } } // namespace JSC::DFG
614 
615 #endif // ENABLE(DFG_JIT)
<a name="54" id="anc54"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="54" type="hidden" />
</body>
</html>
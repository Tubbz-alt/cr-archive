diff a/modules/javafx.web/src/main/native/Source/WebCore/accessibility/atk/AXObjectCacheAtk.cpp b/modules/javafx.web/src/main/native/Source/WebCore/accessibility/atk/AXObjectCacheAtk.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/accessibility/atk/AXObjectCacheAtk.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/accessibility/atk/AXObjectCacheAtk.cpp
@@ -46,11 +46,11 @@
     AtkObject* atkParent = ATK_OBJECT_CLASS(atkObjectClass)->get_parent(ATK_OBJECT(wrapper));
     // We don't want to emit any signal from an object outside WebKit's world.
     return WEBKIT_IS_ACCESSIBLE(atkParent) ? atkParent : nullptr;
 }
 
-void AXObjectCache::detachWrapper(AccessibilityObject* obj, AccessibilityDetachmentType detachmentType)
+void AXObjectCache::detachWrapper(AXCoreObject* obj, AccessibilityDetachmentType detachmentType)
 {
     auto* wrapper = obj->wrapper();
     ASSERT(wrapper);
 
     // If an object is being detached NOT because of the AXObjectCache being destroyed,
@@ -59,34 +59,39 @@
         m_deferredDetachedWrapperList.add(wrapper);
 
     webkitAccessibleDetach(WEBKIT_ACCESSIBLE(wrapper));
 }
 
-void AXObjectCache::attachWrapper(AccessibilityObject* obj)
+void AXObjectCache::attachWrapper(AXCoreObject* obj)
 {
-    GRefPtr<WebKitAccessible> wrapper = adoptGRef(webkitAccessibleNew(obj));
-    obj->setWrapper(wrapper.get());
+    // FIXME: at the moment, only allow to attach AccessibilityObjects.
+    if (!is<AccessibilityObject>(obj))
+        return;
+    AccessibilityObject* accessibilityObject = downcast<AccessibilityObject>(obj);
+
+    GRefPtr<WebKitAccessible> wrapper = adoptGRef(webkitAccessibleNew(accessibilityObject));
+    accessibilityObject->setWrapper(wrapper.get());
 
     // If an object is being attached and we are not in the middle of a layout update, then
     // we should report ATs by emitting the children-changed::add signal from the parent.
-    Document* document = obj->document();
+    Document* document = accessibilityObject->document();
     if (!document || document->childNeedsStyleRecalc())
         return;
 
     // Don't emit the signal when the actual object being added is not going to be exposed.
-    if (obj->accessibilityIsIgnoredByDefault())
+    if (accessibilityObject->accessibilityIsIgnoredByDefault())
         return;
 
     // Don't emit the signal if the object being added is not -- or not yet -- rendered,
     // which can occur in nested iframes. In these instances we don't want to ignore the
     // child. But if an assistive technology is listening, AT-SPI2 will attempt to create
     // and cache the state set for the child upon emission of the signal. If the object
     // has not yet been rendered, this will result in a crash.
-    if (!obj->renderer())
+    if (!accessibilityObject->renderer())
         return;
 
-    m_deferredAttachedWrapperObjectList.add(obj);
+    m_deferredAttachedWrapperObjectList.add(accessibilityObject);
 }
 
 void AXObjectCache::platformPerformDeferredCacheUpdate()
 {
     for (auto& coreObject : m_deferredAttachedWrapperObjectList) {
@@ -117,11 +122,11 @@
         }
     }
     m_deferredDetachedWrapperList.clear();
 }
 
-static AccessibilityObject* getListObject(AccessibilityObject* object)
+static AXCoreObject* getListObject(AXCoreObject* object)
 {
     // Only list boxes and menu lists supported so far.
     if (!object->isListBox() && !object->isMenuList())
         return 0;
 
@@ -134,25 +139,25 @@
     // of items with role MenuListOptionRole.
     const AccessibilityObject::AccessibilityChildrenVector& children = object->children();
     if (!children.size())
         return 0;
 
-    AccessibilityObject* listObject = children.at(0).get();
+    AXCoreObject* listObject = children.at(0).get();
     if (!listObject->isMenuListPopup())
         return 0;
 
     return listObject;
 }
 
-static void notifyChildrenSelectionChange(AccessibilityObject* object)
+static void notifyChildrenSelectionChange(AXCoreObject* object)
 {
     // This static variables are needed to keep track of the old
     // focused object and its associated list object, as per previous
     // calls to this function, in order to properly decide whether to
     // emit some signals or not.
-    static NeverDestroyed<RefPtr<AccessibilityObject>> oldListObject;
-    static NeverDestroyed<RefPtr<AccessibilityObject>> oldFocusedObject;
+    static NeverDestroyed<RefPtr<AXCoreObject>> oldListObject;
+    static NeverDestroyed<RefPtr<AXCoreObject>> oldFocusedObject;
 
     // Only list boxes and menu lists supported so far.
     if (!object || !(object->isListBox() || object->isMenuList()))
         return;
 
@@ -166,20 +171,20 @@
 
     // Find the item where the selection change was triggered from.
     HTMLSelectElement& select = downcast<HTMLSelectElement>(*node);
     int changedItemIndex = select.activeSelectionStartListIndex();
 
-    AccessibilityObject* listObject = getListObject(object);
+    AXCoreObject* listObject = getListObject(object);
     if (!listObject) {
         oldListObject.get() = nullptr;
         return;
     }
 
     const AccessibilityObject::AccessibilityChildrenVector& items = listObject->children();
     if (changedItemIndex < 0 || changedItemIndex >= static_cast<int>(items.size()))
         return;
-    AccessibilityObject* item = items.at(changedItemIndex).get();
+    AXCoreObject* item = items.at(changedItemIndex).get();
 
     // Ensure the current list object is the same than the old one so
     // further comparisons make sense. Otherwise, just reset
     // oldFocusedObject so it won't be taken into account.
     if (oldListObject.get() != listObject)
@@ -209,11 +214,11 @@
     // Update pointers to the previously involved objects.
     oldListObject.get() = listObject;
     oldFocusedObject.get() = item;
 }
 
-void AXObjectCache::postPlatformNotification(AccessibilityObject* coreObject, AXNotification notification)
+void AXObjectCache::postPlatformNotification(AXCoreObject* coreObject, AXNotification notification)
 {
     auto* axObject = ATK_OBJECT(coreObject->wrapper());
     if (!axObject)
         return;
 
@@ -291,11 +296,11 @@
     case AXRequiredStatusChanged:
         atk_object_notify_state_change(axObject, ATK_STATE_REQUIRED, coreObject->isRequired());
         break;
 
     case AXActiveDescendantChanged:
-        if (AccessibilityObject* descendant = coreObject->activeDescendant())
+        if (AXCoreObject* descendant = coreObject->activeDescendant())
             platformHandleFocusedUIElementChanged(nullptr, descendant->node());
         break;
 
     default:
         break;
@@ -305,11 +310,11 @@
 void AXObjectCache::nodeTextChangePlatformNotification(AccessibilityObject* object, AXTextChange textChange, unsigned offset, const String& text)
 {
     if (!object || text.isEmpty())
         return;
 
-    AccessibilityObject* parentObject = object->isNonNativeTextControl() ? object : object->parentObjectUnignored();
+    AXCoreObject* parentObject = object->isNonNativeTextControl() ? object : object->parentObjectUnignored();
     if (!parentObject)
         return;
 
     auto* wrapper = parentObject->wrapper();
     if (!wrapper || !ATK_IS_TEXT(wrapper))

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/MediaStreamTrack.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MediaStream.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaStreamTrack.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/MediaStreamTrack.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 18  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 19  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 20  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 21  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 22  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 23  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 25  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;MediaStreamTrack.h&quot;
 30 
 31 #if ENABLE(MEDIA_STREAM)
 32 
 33 #include &quot;Document.h&quot;
 34 #include &quot;Event.h&quot;
 35 #include &quot;EventNames.h&quot;



 36 #include &quot;JSOverconstrainedError.h&quot;

 37 #include &quot;MediaConstraints.h&quot;
 38 #include &quot;MediaStream.h&quot;
 39 #include &quot;MediaStreamPrivate.h&quot;

 40 #include &quot;NotImplemented.h&quot;
 41 #include &quot;OverconstrainedError.h&quot;
 42 #include &quot;Page.h&quot;
 43 #include &quot;RealtimeMediaSourceCenter.h&quot;
 44 #include &quot;ScriptExecutionContext.h&quot;
 45 #include &lt;wtf/CompletionHandler.h&gt;
 46 #include &lt;wtf/IsoMallocInlines.h&gt;
 47 #include &lt;wtf/NeverDestroyed.h&gt;
 48 
 49 namespace WebCore {
 50 
 51 static HashSet&lt;MediaStreamTrack*&gt;&amp; allCaptureTracks()
 52 {
 53     static NeverDestroyed&lt;HashSet&lt;MediaStreamTrack*&gt;&gt; captureTracks;
 54     return captureTracks;
 55 }
 56 
 57 static MediaProducer::MediaStateFlags sourceCaptureState(RealtimeMediaSource&amp;);
 58 
 59 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaStreamTrack);
 60 
 61 Ref&lt;MediaStreamTrack&gt; MediaStreamTrack::create(ScriptExecutionContext&amp; context, Ref&lt;MediaStreamTrackPrivate&gt;&amp;&amp; privateTrack)
 62 {
<span class="line-modified"> 63     return adoptRef(*new MediaStreamTrack(context, WTFMove(privateTrack)));</span>


 64 }
 65 
 66 MediaStreamTrack::MediaStreamTrack(ScriptExecutionContext&amp; context, Ref&lt;MediaStreamTrackPrivate&gt;&amp;&amp; privateTrack)
 67     : ActiveDOMObject(&amp;context)
 68     , m_private(WTFMove(privateTrack))
<span class="line-removed"> 69     , m_taskQueue(context)</span>
 70     , m_isCaptureTrack(m_private-&gt;isCaptureTrack())

 71 {
 72     ALWAYS_LOG(LOGIDENTIFIER);
<span class="line-removed"> 73     suspendIfNeeded();</span>
 74 
 75     m_private-&gt;addObserver(*this);
 76 
 77     if (!isCaptureTrack())
 78         return;
 79 
 80     allCaptureTracks().add(this);
 81 
 82     if (auto document = this-&gt;document()) {
 83         if (document-&gt;page() &amp;&amp; document-&gt;page()-&gt;mutedState())
 84             setMuted(true);
<span class="line-removed"> 85 #if !PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 86         document-&gt;addAudioProducer(*this);</span>
<span class="line-removed"> 87 #endif</span>
 88     }
 89 }
 90 
 91 MediaStreamTrack::~MediaStreamTrack()
 92 {
 93     m_private-&gt;removeObserver(*this);
 94 
 95     if (!isCaptureTrack())
 96         return;
 97 
 98     allCaptureTracks().remove(this);
<span class="line-removed"> 99 </span>
<span class="line-removed">100 #if !PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">101     if (auto document = this-&gt;document())</span>
<span class="line-removed">102         document-&gt;removeAudioProducer(*this);</span>
<span class="line-removed">103 #endif</span>
104 }
105 
106 const AtomString&amp; MediaStreamTrack::kind() const
107 {
108     static NeverDestroyed&lt;AtomString&gt; audioKind(&quot;audio&quot;, AtomString::ConstructFromLiteral);
109     static NeverDestroyed&lt;AtomString&gt; videoKind(&quot;video&quot;, AtomString::ConstructFromLiteral);
110 
111     if (m_private-&gt;type() == RealtimeMediaSource::Type::Audio)
112         return audioKind;
113     return videoKind;
114 }
115 
116 const String&amp; MediaStreamTrack::id() const
117 {
118     return m_private-&gt;id();
119 }
120 
121 const String&amp; MediaStreamTrack::label() const
122 {
123     return m_private-&gt;label();
</pre>
<hr />
<pre>
180 {
181     return m_private-&gt;enabled();
182 }
183 
184 void MediaStreamTrack::setEnabled(bool enabled)
185 {
186     m_private-&gt;setEnabled(enabled);
187 }
188 
189 bool MediaStreamTrack::muted() const
190 {
191     return m_private-&gt;muted();
192 }
193 
194 void MediaStreamTrack::setMuted(MediaProducer::MutedStateFlags state)
195 {
196     bool trackMuted = false;
197     switch (source().deviceType()) {
198     case CaptureDevice::DeviceType::Microphone:
199     case CaptureDevice::DeviceType::Camera:
<span class="line-modified">200         trackMuted = state &amp; AudioAndVideoCaptureIsMuted;</span>
201         break;
202     case CaptureDevice::DeviceType::Screen:
203     case CaptureDevice::DeviceType::Window:
<span class="line-modified">204         trackMuted = state &amp; ScreenCaptureIsMuted;</span>
205         break;
206     case CaptureDevice::DeviceType::Unknown:
207         ASSERT_NOT_REACHED();
208         break;
209     }
210 
211     m_private-&gt;setMuted(trackMuted);
212 }
213 
214 auto MediaStreamTrack::readyState() const -&gt; State
215 {
216     return ended() ? State::Ended : State::Live;
217 }
218 
219 bool MediaStreamTrack::ended() const
220 {
221     return m_ended || m_private-&gt;ended();
222 }
223 
224 RefPtr&lt;MediaStreamTrack&gt; MediaStreamTrack::clone()
</pre>
<hr />
<pre>
306     switch (value.type()) {
307     case CapabilityValueOrRange::ULong:
308         range.min = value.value().asInt;
309         range.max = range.min;
310         break;
311     case CapabilityValueOrRange::ULongRange:
312         range.min = value.rangeMin().asInt;
313         range.max = value.rangeMax().asInt;
314         break;
315     case CapabilityValueOrRange::Undefined:
316     case CapabilityValueOrRange::Double:
317     case CapabilityValueOrRange::DoubleRange:
318         ASSERT_NOT_REACHED();
319     }
320     return range;
321 }
322 
323 static Vector&lt;String&gt; capabilityStringVector(const Vector&lt;RealtimeMediaSourceSettings::VideoFacingMode&gt;&amp; modes)
324 {
325     Vector&lt;String&gt; result;
<span class="line-modified">326     result.reserveCapacity(modes.size());</span>
327     for (auto&amp; mode : modes)
328         result.uncheckedAppend(RealtimeMediaSourceSettings::facingMode(mode));
329     return result;
330 }
331 
332 static Vector&lt;bool&gt; capabilityBooleanVector(RealtimeMediaSourceCapabilities::EchoCancellation cancellation)
333 {
334     Vector&lt;bool&gt; result;
<span class="line-modified">335     result.reserveCapacity(2);</span>
336     result.uncheckedAppend(true);
<span class="line-modified">337     result.uncheckedAppend(cancellation == RealtimeMediaSourceCapabilities::EchoCancellation::ReadWrite);</span>

338     return result;
339 }
340 
341 MediaStreamTrack::TrackCapabilities MediaStreamTrack::getCapabilities() const
342 {
343     auto capabilities = m_private-&gt;capabilities();
344     TrackCapabilities result;
345     if (capabilities.supportsWidth())
346         result.width = capabilityIntRange(capabilities.width());
347     if (capabilities.supportsHeight())
348         result.height = capabilityIntRange(capabilities.height());
349     if (capabilities.supportsAspectRatio())
350         result.aspectRatio = capabilityDoubleRange(capabilities.aspectRatio());
351     if (capabilities.supportsFrameRate())
352         result.frameRate = capabilityDoubleRange(capabilities.frameRate());
353     if (capabilities.supportsFacingMode())
354         result.facingMode = capabilityStringVector(capabilities.facingMode());
355     if (capabilities.supportsVolume())
356         result.volume = capabilityDoubleRange(capabilities.volume());
357     if (capabilities.supportsSampleRate())
</pre>
<hr />
<pre>
362         result.echoCancellation = capabilityBooleanVector(capabilities.echoCancellation());
363     if (capabilities.supportsDeviceId())
364         result.deviceId = capabilities.deviceId();
365     if (capabilities.supportsGroupId())
366         result.groupId = capabilities.groupId();
367     return result;
368 }
369 
370 static MediaConstraints createMediaConstraints(const Optional&lt;MediaTrackConstraints&gt;&amp; constraints)
371 {
372     if (!constraints) {
373         MediaConstraints validConstraints;
374         validConstraints.isValid = true;
375         return validConstraints;
376     }
377     return createMediaConstraints(constraints.value());
378 }
379 
380 void MediaStreamTrack::applyConstraints(const Optional&lt;MediaTrackConstraints&gt;&amp; constraints, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
381 {
<span class="line-modified">382     m_promise = WTFMove(promise);</span>
383 
<span class="line-modified">384     auto completionHandler = [this, weakThis = makeWeakPtr(*this), constraints](auto&amp;&amp; error) mutable {</span>
<span class="line-modified">385         if (!weakThis || !m_promise)</span>
386             return;
387         if (error) {
388             m_promise-&gt;rejectType&lt;IDLInterface&lt;OverconstrainedError&gt;&gt;(OverconstrainedError::create(WTFMove(error-&gt;badConstraint), WTFMove(error-&gt;message)));
389             return;
390         }
391         m_promise-&gt;resolve();
392         m_constraints = constraints.valueOr(MediaTrackConstraints { });
393     };
394     m_private-&gt;applyConstraints(createMediaConstraints(constraints), WTFMove(completionHandler));
395 }
396 
397 void MediaStreamTrack::addObserver(Observer&amp; observer)
398 {
399     m_observers.append(&amp;observer);
400 }
401 
402 void MediaStreamTrack::removeObserver(Observer&amp; observer)
403 {
404     m_observers.removeFirst(&amp;observer);
405 }
406 
<span class="line-removed">407 void MediaStreamTrack::pageMutedStateDidChange()</span>
<span class="line-removed">408 {</span>
<span class="line-removed">409     if (m_ended || !isCaptureTrack())</span>
<span class="line-removed">410         return;</span>
<span class="line-removed">411 </span>
<span class="line-removed">412     Document* document = this-&gt;document();</span>
<span class="line-removed">413     if (!document || !document-&gt;page())</span>
<span class="line-removed">414         return;</span>
<span class="line-removed">415 </span>
<span class="line-removed">416     setMuted(document-&gt;page()-&gt;mutedState());</span>
<span class="line-removed">417 }</span>
<span class="line-removed">418 </span>
419 MediaProducer::MediaStateFlags MediaStreamTrack::mediaState() const
420 {
421     if (m_ended || !isCaptureTrack())
<span class="line-modified">422         return IsNotPlaying;</span>
423 
<span class="line-modified">424     Document* document = this-&gt;document();</span>
425     if (!document || !document-&gt;page())
<span class="line-modified">426         return IsNotPlaying;</span>
427 
428     return sourceCaptureState(source());
429 }
430 
431 MediaProducer::MediaStateFlags sourceCaptureState(RealtimeMediaSource&amp; source)
432 {
433     switch (source.deviceType()) {
434     case CaptureDevice::DeviceType::Microphone:
435         if (source.muted())
436             return MediaProducer::HasMutedAudioCaptureDevice;
437         if (source.interrupted())
438             return MediaProducer::HasInterruptedAudioCaptureDevice;
439         if (source.isProducingData())
440             return MediaProducer::HasActiveAudioCaptureDevice;
441         break;
442     case CaptureDevice::DeviceType::Camera:
443         if (source.muted())
444             return MediaProducer::HasMutedVideoCaptureDevice;
445         if (source.interrupted())
446             return MediaProducer::HasInterruptedVideoCaptureDevice;
447         if (source.isProducingData())
448             return MediaProducer::HasActiveVideoCaptureDevice;
449         break;
450     case CaptureDevice::DeviceType::Screen:
451     case CaptureDevice::DeviceType::Window:
452         if (source.muted())
453             return MediaProducer::HasMutedDisplayCaptureDevice;
454         if (source.interrupted())
455             return MediaProducer::HasInterruptedDisplayCaptureDevice;
456         if (source.isProducingData())
457             return MediaProducer::HasActiveDisplayCaptureDevice;
458         break;
459     case CaptureDevice::DeviceType::Unknown:
460         ASSERT_NOT_REACHED();
461     }
462 
463     return MediaProducer::IsNotPlaying;
464 }
465 
<span class="line-modified">466 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">467 MediaProducer::MediaStateFlags MediaStreamTrack::captureState()</span>
468 {
469     MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
<span class="line-modified">470     if (auto* source = RealtimeMediaSourceCenter::singleton().audioCaptureFactory().activeSource())</span>
<span class="line-modified">471         state |= sourceCaptureState(*source);</span>
<span class="line-modified">472     if (auto* source = RealtimeMediaSourceCenter::singleton().videoCaptureFactory().activeSource())</span>
<span class="line-modified">473         state |= sourceCaptureState(*source);</span>

474     return state;
475 }
476 
<span class="line-modified">477 void MediaStreamTrack::muteCapture()</span>
478 {
<span class="line-modified">479     if (auto* source = RealtimeMediaSourceCenter::singleton().audioCaptureFactory().activeSource())</span>
<span class="line-modified">480         source-&gt;setMuted(true);</span>
<span class="line-modified">481     if (auto* source = RealtimeMediaSourceCenter::singleton().videoCaptureFactory().activeSource())</span>
<span class="line-modified">482         source-&gt;setMuted(true);</span>

483 }
<span class="line-removed">484 #endif</span>
485 
486 void MediaStreamTrack::endCapture(Document&amp; document)
487 {

488     for (auto* captureTrack : allCaptureTracks()) {
489         if (captureTrack-&gt;document() != &amp;document)
490             continue;
491         captureTrack-&gt;stopTrack(MediaStreamTrack::StopMode::PostEvent);

492     }


493 }
494 
495 void MediaStreamTrack::trackStarted(MediaStreamTrackPrivate&amp;)
496 {
497     configureTrackRendering();
498 }
499 
500 void MediaStreamTrack::trackEnded(MediaStreamTrackPrivate&amp;)
501 {
502     // http://w3c.github.io/mediacapture-main/#life-cycle
503     // When a MediaStreamTrack track ends for any reason other than the stop() method being invoked, the User Agent must queue a task that runs the following steps:
504     // 1. If the track&#39;s readyState attribute has the value ended already, then abort these steps.
505     if (m_ended)
506         return;
507 
508     // 2. Set track&#39;s readyState attribute to ended.
509     m_ended = true;
510 
511     if (scriptExecutionContext()-&gt;activeDOMObjectsAreSuspended() || scriptExecutionContext()-&gt;activeDOMObjectsAreStopped())
512         return;
513 
514     // 3. Notify track&#39;s source that track is ended so that the source may be stopped, unless other MediaStreamTrack objects depend on it.
515     // 4. Fire a simple event named ended at the object.
516     dispatchEvent(Event::create(eventNames().endedEvent, Event::CanBubble::No, Event::IsCancelable::No));
517 
518     for (auto&amp; observer : m_observers)
519         observer-&gt;trackDidEnd();
520 
521     configureTrackRendering();
522 }
523 
524 void MediaStreamTrack::trackMutedChanged(MediaStreamTrackPrivate&amp;)
525 {
<span class="line-modified">526     if (scriptExecutionContext()-&gt;activeDOMObjectsAreSuspended() || scriptExecutionContext()-&gt;activeDOMObjectsAreStopped() || m_ended)</span>
527         return;
528 
<span class="line-modified">529     m_eventTaskQueue.enqueueTask([this, muted = this-&gt;muted()] {</span>
<span class="line-modified">530         AtomString eventType = muted ? eventNames().muteEvent : eventNames().unmuteEvent;</span>
<span class="line-removed">531         dispatchEvent(Event::create(eventType, Event::CanBubble::No, Event::IsCancelable::No));</span>
<span class="line-removed">532     });</span>
533 
534     configureTrackRendering();
535 }
536 
537 void MediaStreamTrack::trackSettingsChanged(MediaStreamTrackPrivate&amp;)
538 {
539     configureTrackRendering();
540 }
541 
542 void MediaStreamTrack::trackEnabledChanged(MediaStreamTrackPrivate&amp;)
543 {
544     configureTrackRendering();
545 }
546 
547 void MediaStreamTrack::configureTrackRendering()
548 {
<span class="line-modified">549     m_taskQueue.enqueueTask([this] {</span>
<span class="line-modified">550         if (auto document = this-&gt;document())</span>
<span class="line-modified">551             document-&gt;updateIsPlayingMedia();</span>
<span class="line-modified">552     });</span>

553 
554     // 4.3.1
555     // ... media from the source only flows when a MediaStreamTrack object is both unmuted and enabled
556 }
557 
<span class="line-removed">558 void MediaStreamTrack::stop()</span>
<span class="line-removed">559 {</span>
<span class="line-removed">560     stopTrack();</span>
<span class="line-removed">561     m_taskQueue.close();</span>
<span class="line-removed">562 }</span>
<span class="line-removed">563 </span>
564 const char* MediaStreamTrack::activeDOMObjectName() const
565 {
566     return &quot;MediaStreamTrack&quot;;
567 }
568 
<span class="line-modified">569 bool MediaStreamTrack::canSuspendForDocumentSuspension() const</span>
570 {
<span class="line-modified">571     return !hasPendingActivity();</span>









572 }
573 
574 bool MediaStreamTrack::hasPendingActivity() const
575 {
<span class="line-modified">576     return !m_ended;</span>
577 }
578 
579 AudioSourceProvider* MediaStreamTrack::audioSourceProvider()
580 {
581     return m_private-&gt;audioSourceProvider();
582 }
583 
584 Document* MediaStreamTrack::document() const
585 {
586     return downcast&lt;Document&gt;(scriptExecutionContext());
587 }
588 

















































589 #if !RELEASE_LOG_DISABLED
590 WTFLogChannel&amp; MediaStreamTrack::logChannel() const
591 {
592     return LogWebRTC;
593 }
594 #endif
595 
596 } // namespace WebCore
597 
598 #endif // ENABLE(MEDIA_STREAM)
</pre>
</td>
<td>
<hr />
<pre>
 16  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 18  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 19  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 20  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 21  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 22  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 23  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 25  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;MediaStreamTrack.h&quot;
 30 
 31 #if ENABLE(MEDIA_STREAM)
 32 
 33 #include &quot;Document.h&quot;
 34 #include &quot;Event.h&quot;
 35 #include &quot;EventNames.h&quot;
<span class="line-added"> 36 #include &quot;Frame.h&quot;</span>
<span class="line-added"> 37 #include &quot;FrameLoader.h&quot;</span>
<span class="line-added"> 38 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 39 #include &quot;JSOverconstrainedError.h&quot;
<span class="line-added"> 40 #include &quot;Logging.h&quot;</span>
 41 #include &quot;MediaConstraints.h&quot;
 42 #include &quot;MediaStream.h&quot;
 43 #include &quot;MediaStreamPrivate.h&quot;
<span class="line-added"> 44 #include &quot;NetworkingContext.h&quot;</span>
 45 #include &quot;NotImplemented.h&quot;
 46 #include &quot;OverconstrainedError.h&quot;
 47 #include &quot;Page.h&quot;
 48 #include &quot;RealtimeMediaSourceCenter.h&quot;
 49 #include &quot;ScriptExecutionContext.h&quot;
 50 #include &lt;wtf/CompletionHandler.h&gt;
 51 #include &lt;wtf/IsoMallocInlines.h&gt;
 52 #include &lt;wtf/NeverDestroyed.h&gt;
 53 
 54 namespace WebCore {
 55 
 56 static HashSet&lt;MediaStreamTrack*&gt;&amp; allCaptureTracks()
 57 {
 58     static NeverDestroyed&lt;HashSet&lt;MediaStreamTrack*&gt;&gt; captureTracks;
 59     return captureTracks;
 60 }
 61 
 62 static MediaProducer::MediaStateFlags sourceCaptureState(RealtimeMediaSource&amp;);
 63 
 64 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaStreamTrack);
 65 
 66 Ref&lt;MediaStreamTrack&gt; MediaStreamTrack::create(ScriptExecutionContext&amp; context, Ref&lt;MediaStreamTrackPrivate&gt;&amp;&amp; privateTrack)
 67 {
<span class="line-modified"> 68     auto track = adoptRef(*new MediaStreamTrack(context, WTFMove(privateTrack)));</span>
<span class="line-added"> 69     track-&gt;suspendIfNeeded();</span>
<span class="line-added"> 70     return track;</span>
 71 }
 72 
 73 MediaStreamTrack::MediaStreamTrack(ScriptExecutionContext&amp; context, Ref&lt;MediaStreamTrackPrivate&gt;&amp;&amp; privateTrack)
 74     : ActiveDOMObject(&amp;context)
 75     , m_private(WTFMove(privateTrack))

 76     , m_isCaptureTrack(m_private-&gt;isCaptureTrack())
<span class="line-added"> 77     , m_mediaSession(PlatformMediaSession::create(*this))</span>
 78 {
 79     ALWAYS_LOG(LOGIDENTIFIER);

 80 
 81     m_private-&gt;addObserver(*this);
 82 
 83     if (!isCaptureTrack())
 84         return;
 85 
 86     allCaptureTracks().add(this);
 87 
 88     if (auto document = this-&gt;document()) {
 89         if (document-&gt;page() &amp;&amp; document-&gt;page()-&gt;mutedState())
 90             setMuted(true);



 91     }
 92 }
 93 
 94 MediaStreamTrack::~MediaStreamTrack()
 95 {
 96     m_private-&gt;removeObserver(*this);
 97 
 98     if (!isCaptureTrack())
 99         return;
100 
101     allCaptureTracks().remove(this);





102 }
103 
104 const AtomString&amp; MediaStreamTrack::kind() const
105 {
106     static NeverDestroyed&lt;AtomString&gt; audioKind(&quot;audio&quot;, AtomString::ConstructFromLiteral);
107     static NeverDestroyed&lt;AtomString&gt; videoKind(&quot;video&quot;, AtomString::ConstructFromLiteral);
108 
109     if (m_private-&gt;type() == RealtimeMediaSource::Type::Audio)
110         return audioKind;
111     return videoKind;
112 }
113 
114 const String&amp; MediaStreamTrack::id() const
115 {
116     return m_private-&gt;id();
117 }
118 
119 const String&amp; MediaStreamTrack::label() const
120 {
121     return m_private-&gt;label();
</pre>
<hr />
<pre>
178 {
179     return m_private-&gt;enabled();
180 }
181 
182 void MediaStreamTrack::setEnabled(bool enabled)
183 {
184     m_private-&gt;setEnabled(enabled);
185 }
186 
187 bool MediaStreamTrack::muted() const
188 {
189     return m_private-&gt;muted();
190 }
191 
192 void MediaStreamTrack::setMuted(MediaProducer::MutedStateFlags state)
193 {
194     bool trackMuted = false;
195     switch (source().deviceType()) {
196     case CaptureDevice::DeviceType::Microphone:
197     case CaptureDevice::DeviceType::Camera:
<span class="line-modified">198         trackMuted = state &amp; MediaProducer::AudioAndVideoCaptureIsMuted;</span>
199         break;
200     case CaptureDevice::DeviceType::Screen:
201     case CaptureDevice::DeviceType::Window:
<span class="line-modified">202         trackMuted = state &amp; MediaProducer::ScreenCaptureIsMuted;</span>
203         break;
204     case CaptureDevice::DeviceType::Unknown:
205         ASSERT_NOT_REACHED();
206         break;
207     }
208 
209     m_private-&gt;setMuted(trackMuted);
210 }
211 
212 auto MediaStreamTrack::readyState() const -&gt; State
213 {
214     return ended() ? State::Ended : State::Live;
215 }
216 
217 bool MediaStreamTrack::ended() const
218 {
219     return m_ended || m_private-&gt;ended();
220 }
221 
222 RefPtr&lt;MediaStreamTrack&gt; MediaStreamTrack::clone()
</pre>
<hr />
<pre>
304     switch (value.type()) {
305     case CapabilityValueOrRange::ULong:
306         range.min = value.value().asInt;
307         range.max = range.min;
308         break;
309     case CapabilityValueOrRange::ULongRange:
310         range.min = value.rangeMin().asInt;
311         range.max = value.rangeMax().asInt;
312         break;
313     case CapabilityValueOrRange::Undefined:
314     case CapabilityValueOrRange::Double:
315     case CapabilityValueOrRange::DoubleRange:
316         ASSERT_NOT_REACHED();
317     }
318     return range;
319 }
320 
321 static Vector&lt;String&gt; capabilityStringVector(const Vector&lt;RealtimeMediaSourceSettings::VideoFacingMode&gt;&amp; modes)
322 {
323     Vector&lt;String&gt; result;
<span class="line-modified">324     result.reserveInitialCapacity(modes.size());</span>
325     for (auto&amp; mode : modes)
326         result.uncheckedAppend(RealtimeMediaSourceSettings::facingMode(mode));
327     return result;
328 }
329 
330 static Vector&lt;bool&gt; capabilityBooleanVector(RealtimeMediaSourceCapabilities::EchoCancellation cancellation)
331 {
332     Vector&lt;bool&gt; result;
<span class="line-modified">333     result.reserveInitialCapacity(2);</span>
334     result.uncheckedAppend(true);
<span class="line-modified">335     if (cancellation == RealtimeMediaSourceCapabilities::EchoCancellation::ReadWrite)</span>
<span class="line-added">336         result.uncheckedAppend(false);</span>
337     return result;
338 }
339 
340 MediaStreamTrack::TrackCapabilities MediaStreamTrack::getCapabilities() const
341 {
342     auto capabilities = m_private-&gt;capabilities();
343     TrackCapabilities result;
344     if (capabilities.supportsWidth())
345         result.width = capabilityIntRange(capabilities.width());
346     if (capabilities.supportsHeight())
347         result.height = capabilityIntRange(capabilities.height());
348     if (capabilities.supportsAspectRatio())
349         result.aspectRatio = capabilityDoubleRange(capabilities.aspectRatio());
350     if (capabilities.supportsFrameRate())
351         result.frameRate = capabilityDoubleRange(capabilities.frameRate());
352     if (capabilities.supportsFacingMode())
353         result.facingMode = capabilityStringVector(capabilities.facingMode());
354     if (capabilities.supportsVolume())
355         result.volume = capabilityDoubleRange(capabilities.volume());
356     if (capabilities.supportsSampleRate())
</pre>
<hr />
<pre>
361         result.echoCancellation = capabilityBooleanVector(capabilities.echoCancellation());
362     if (capabilities.supportsDeviceId())
363         result.deviceId = capabilities.deviceId();
364     if (capabilities.supportsGroupId())
365         result.groupId = capabilities.groupId();
366     return result;
367 }
368 
369 static MediaConstraints createMediaConstraints(const Optional&lt;MediaTrackConstraints&gt;&amp; constraints)
370 {
371     if (!constraints) {
372         MediaConstraints validConstraints;
373         validConstraints.isValid = true;
374         return validConstraints;
375     }
376     return createMediaConstraints(constraints.value());
377 }
378 
379 void MediaStreamTrack::applyConstraints(const Optional&lt;MediaTrackConstraints&gt;&amp; constraints, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
380 {
<span class="line-modified">381     m_promise = WTF::makeUnique&lt;DOMPromiseDeferred&lt;void&gt;&gt;(WTFMove(promise));</span>
382 
<span class="line-modified">383     auto completionHandler = [this, protectedThis = makeRef(*this), constraints](auto&amp;&amp; error) mutable {</span>
<span class="line-modified">384         if (!m_promise)</span>
385             return;
386         if (error) {
387             m_promise-&gt;rejectType&lt;IDLInterface&lt;OverconstrainedError&gt;&gt;(OverconstrainedError::create(WTFMove(error-&gt;badConstraint), WTFMove(error-&gt;message)));
388             return;
389         }
390         m_promise-&gt;resolve();
391         m_constraints = constraints.valueOr(MediaTrackConstraints { });
392     };
393     m_private-&gt;applyConstraints(createMediaConstraints(constraints), WTFMove(completionHandler));
394 }
395 
396 void MediaStreamTrack::addObserver(Observer&amp; observer)
397 {
398     m_observers.append(&amp;observer);
399 }
400 
401 void MediaStreamTrack::removeObserver(Observer&amp; observer)
402 {
403     m_observers.removeFirst(&amp;observer);
404 }
405 












406 MediaProducer::MediaStateFlags MediaStreamTrack::mediaState() const
407 {
408     if (m_ended || !isCaptureTrack())
<span class="line-modified">409         return MediaProducer::IsNotPlaying;</span>
410 
<span class="line-modified">411     auto* document = this-&gt;document();</span>
412     if (!document || !document-&gt;page())
<span class="line-modified">413         return MediaProducer::IsNotPlaying;</span>
414 
415     return sourceCaptureState(source());
416 }
417 
418 MediaProducer::MediaStateFlags sourceCaptureState(RealtimeMediaSource&amp; source)
419 {
420     switch (source.deviceType()) {
421     case CaptureDevice::DeviceType::Microphone:
422         if (source.muted())
423             return MediaProducer::HasMutedAudioCaptureDevice;
424         if (source.interrupted())
425             return MediaProducer::HasInterruptedAudioCaptureDevice;
426         if (source.isProducingData())
427             return MediaProducer::HasActiveAudioCaptureDevice;
428         break;
429     case CaptureDevice::DeviceType::Camera:
430         if (source.muted())
431             return MediaProducer::HasMutedVideoCaptureDevice;
432         if (source.interrupted())
433             return MediaProducer::HasInterruptedVideoCaptureDevice;
434         if (source.isProducingData())
435             return MediaProducer::HasActiveVideoCaptureDevice;
436         break;
437     case CaptureDevice::DeviceType::Screen:
438     case CaptureDevice::DeviceType::Window:
439         if (source.muted())
440             return MediaProducer::HasMutedDisplayCaptureDevice;
441         if (source.interrupted())
442             return MediaProducer::HasInterruptedDisplayCaptureDevice;
443         if (source.isProducingData())
444             return MediaProducer::HasActiveDisplayCaptureDevice;
445         break;
446     case CaptureDevice::DeviceType::Unknown:
447         ASSERT_NOT_REACHED();
448     }
449 
450     return MediaProducer::IsNotPlaying;
451 }
452 
<span class="line-modified">453 MediaProducer::MediaStateFlags MediaStreamTrack::captureState(Document&amp; document)</span>

454 {
455     MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
<span class="line-modified">456     for (auto* captureTrack : allCaptureTracks()) {</span>
<span class="line-modified">457         if (captureTrack-&gt;document() != &amp;document || captureTrack-&gt;ended())</span>
<span class="line-modified">458             continue;</span>
<span class="line-modified">459         state |= sourceCaptureState(captureTrack-&gt;source());</span>
<span class="line-added">460     }</span>
461     return state;
462 }
463 
<span class="line-modified">464 void MediaStreamTrack::updateCaptureAccordingToMutedState(Document&amp; document)</span>
465 {
<span class="line-modified">466     for (auto* captureTrack : allCaptureTracks()) {</span>
<span class="line-modified">467         if (captureTrack-&gt;document() != &amp;document || captureTrack-&gt;ended())</span>
<span class="line-modified">468             continue;</span>
<span class="line-modified">469         captureTrack-&gt;setMuted(document.page()-&gt;mutedState());</span>
<span class="line-added">470     }</span>
471 }

472 
473 void MediaStreamTrack::endCapture(Document&amp; document)
474 {
<span class="line-added">475     bool didEndCapture = false;</span>
476     for (auto* captureTrack : allCaptureTracks()) {
477         if (captureTrack-&gt;document() != &amp;document)
478             continue;
479         captureTrack-&gt;stopTrack(MediaStreamTrack::StopMode::PostEvent);
<span class="line-added">480         didEndCapture = true;</span>
481     }
<span class="line-added">482     if (didEndCapture)</span>
<span class="line-added">483         document.updateIsPlayingMedia();</span>
484 }
485 
486 void MediaStreamTrack::trackStarted(MediaStreamTrackPrivate&amp;)
487 {
488     configureTrackRendering();
489 }
490 
491 void MediaStreamTrack::trackEnded(MediaStreamTrackPrivate&amp;)
492 {
493     // http://w3c.github.io/mediacapture-main/#life-cycle
494     // When a MediaStreamTrack track ends for any reason other than the stop() method being invoked, the User Agent must queue a task that runs the following steps:
495     // 1. If the track&#39;s readyState attribute has the value ended already, then abort these steps.
496     if (m_ended)
497         return;
498 
499     // 2. Set track&#39;s readyState attribute to ended.
500     m_ended = true;
501 
502     if (scriptExecutionContext()-&gt;activeDOMObjectsAreSuspended() || scriptExecutionContext()-&gt;activeDOMObjectsAreStopped())
503         return;
504 
505     // 3. Notify track&#39;s source that track is ended so that the source may be stopped, unless other MediaStreamTrack objects depend on it.
506     // 4. Fire a simple event named ended at the object.
507     dispatchEvent(Event::create(eventNames().endedEvent, Event::CanBubble::No, Event::IsCancelable::No));
508 
509     for (auto&amp; observer : m_observers)
510         observer-&gt;trackDidEnd();
511 
512     configureTrackRendering();
513 }
514 
515 void MediaStreamTrack::trackMutedChanged(MediaStreamTrackPrivate&amp;)
516 {
<span class="line-modified">517     if (scriptExecutionContext()-&gt;activeDOMObjectsAreStopped() || m_ended)</span>
518         return;
519 
<span class="line-modified">520     AtomString eventType = muted() ? eventNames().muteEvent : eventNames().unmuteEvent;</span>
<span class="line-modified">521     queueTaskToDispatchEvent(*this, TaskSource::Networking, Event::create(eventType, Event::CanBubble::No, Event::IsCancelable::No));</span>


522 
523     configureTrackRendering();
524 }
525 
526 void MediaStreamTrack::trackSettingsChanged(MediaStreamTrackPrivate&amp;)
527 {
528     configureTrackRendering();
529 }
530 
531 void MediaStreamTrack::trackEnabledChanged(MediaStreamTrackPrivate&amp;)
532 {
533     configureTrackRendering();
534 }
535 
536 void MediaStreamTrack::configureTrackRendering()
537 {
<span class="line-modified">538     if (m_mediaSession &amp;&amp; m_private-&gt;type() == RealtimeMediaSource::Type::Audio)</span>
<span class="line-modified">539         m_mediaSession-&gt;canProduceAudioChanged();</span>
<span class="line-modified">540 </span>
<span class="line-modified">541     if (auto document = this-&gt;document())</span>
<span class="line-added">542         document-&gt;updateIsPlayingMedia();</span>
543 
544     // 4.3.1
545     // ... media from the source only flows when a MediaStreamTrack object is both unmuted and enabled
546 }
547 






548 const char* MediaStreamTrack::activeDOMObjectName() const
549 {
550     return &quot;MediaStreamTrack&quot;;
551 }
552 
<span class="line-modified">553 void MediaStreamTrack::suspend(ReasonForSuspension reason)</span>
554 {
<span class="line-modified">555     if (reason != ReasonForSuspension::BackForwardCache)</span>
<span class="line-added">556         return;</span>
<span class="line-added">557 </span>
<span class="line-added">558     // We only end capture tracks, other tracks (capture canvas, remote tracks) can still continue working.</span>
<span class="line-added">559     if (m_ended || !isCaptureTrack())</span>
<span class="line-added">560         return;</span>
<span class="line-added">561 </span>
<span class="line-added">562     stopTrack();</span>
<span class="line-added">563 </span>
<span class="line-added">564     queueTaskToDispatchEvent(*this, TaskSource::Networking, Event::create(eventNames().endedEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
565 }
566 
567 bool MediaStreamTrack::hasPendingActivity() const
568 {
<span class="line-modified">569     return !m_ended || ActiveDOMObject::hasPendingActivity();</span>
570 }
571 
572 AudioSourceProvider* MediaStreamTrack::audioSourceProvider()
573 {
574     return m_private-&gt;audioSourceProvider();
575 }
576 
577 Document* MediaStreamTrack::document() const
578 {
579     return downcast&lt;Document&gt;(scriptExecutionContext());
580 }
581 
<span class="line-added">582 PlatformMediaSession::MediaType MediaStreamTrack::mediaType() const</span>
<span class="line-added">583 {</span>
<span class="line-added">584     return (isCaptureTrack() &amp;&amp; canProduceAudio()) ? PlatformMediaSession::MediaStreamCapturingAudio : PlatformMediaSession::None;</span>
<span class="line-added">585 }</span>
<span class="line-added">586 </span>
<span class="line-added">587 PlatformMediaSession::MediaType MediaStreamTrack::presentationType() const</span>
<span class="line-added">588 {</span>
<span class="line-added">589     return mediaType();</span>
<span class="line-added">590 }</span>
<span class="line-added">591 </span>
<span class="line-added">592 PlatformMediaSession::CharacteristicsFlags MediaStreamTrack::characteristics() const</span>
<span class="line-added">593 {</span>
<span class="line-added">594     if (!m_private-&gt;isActive())</span>
<span class="line-added">595         return PlatformMediaSession::HasNothing;</span>
<span class="line-added">596 </span>
<span class="line-added">597     return m_private-&gt;type() == RealtimeMediaSource::Type::Audio ? PlatformMediaSession::HasAudio : PlatformMediaSession::HasVideo;</span>
<span class="line-added">598 }</span>
<span class="line-added">599 </span>
<span class="line-added">600 void MediaStreamTrack::mayResumePlayback(bool)</span>
<span class="line-added">601 {</span>
<span class="line-added">602     // FIXME: should a media stream track pay attention to this directly, or only when attached to a media element?</span>
<span class="line-added">603 }</span>
<span class="line-added">604 </span>
<span class="line-added">605 void MediaStreamTrack::suspendPlayback()</span>
<span class="line-added">606 {</span>
<span class="line-added">607     // FIXME: should a media stream track pay attention to this directly, or only when attached to a media element?</span>
<span class="line-added">608 }</span>
<span class="line-added">609 </span>
<span class="line-added">610 String MediaStreamTrack::sourceApplicationIdentifier() const</span>
<span class="line-added">611 {</span>
<span class="line-added">612     auto* document = this-&gt;document();</span>
<span class="line-added">613     if (document &amp;&amp; document-&gt;frame()) {</span>
<span class="line-added">614         if (auto* networkingContext = document-&gt;frame()-&gt;loader().networkingContext())</span>
<span class="line-added">615             return networkingContext-&gt;sourceApplicationIdentifier();</span>
<span class="line-added">616     }</span>
<span class="line-added">617 </span>
<span class="line-added">618     return emptyString();</span>
<span class="line-added">619 }</span>
<span class="line-added">620 </span>
<span class="line-added">621 bool MediaStreamTrack::canProduceAudio() const</span>
<span class="line-added">622 {</span>
<span class="line-added">623     return m_private-&gt;type() == RealtimeMediaSource::Type::Audio &amp;&amp; !ended() &amp;&amp; !muted();</span>
<span class="line-added">624 }</span>
<span class="line-added">625 </span>
<span class="line-added">626 bool MediaStreamTrack::processingUserGestureForMedia() const</span>
<span class="line-added">627 {</span>
<span class="line-added">628     return document() ? document()-&gt;processingUserGestureForMedia() : false;</span>
<span class="line-added">629 }</span>
<span class="line-added">630 </span>
631 #if !RELEASE_LOG_DISABLED
632 WTFLogChannel&amp; MediaStreamTrack::logChannel() const
633 {
634     return LogWebRTC;
635 }
636 #endif
637 
638 } // namespace WebCore
639 
640 #endif // ENABLE(MEDIA_STREAM)
</pre>
</td>
</tr>
</table>
<center><a href="MediaStream.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaStreamTrack.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
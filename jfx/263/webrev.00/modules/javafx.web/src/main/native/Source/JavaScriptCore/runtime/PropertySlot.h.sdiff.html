<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/PropertySlot.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PropertySlot.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PropertyTable.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/PropertySlot.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  3  *
  4  *  This library is free software; you can redistribute it and/or
  5  *  modify it under the terms of the GNU Library General Public
  6  *  License as published by the Free Software Foundation; either
  7  *  version 2 of the License, or (at your option) any later version.
  8  *
  9  *  This library is distributed in the hope that it will be useful,
 10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  *  Library General Public License for more details.
 13  *
 14  *  You should have received a copy of the GNU Library General Public License
 15  *  along with this library; see the file COPYING.LIB.  If not, write to
 16  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  *  Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #pragma once
 22 
<span class="line-removed"> 23 #include &quot;CallFrame.h&quot;</span>
 24 #include &quot;DOMAnnotation.h&quot;

 25 #include &quot;JSCJSValue.h&quot;
 26 #include &quot;PropertyName.h&quot;
 27 #include &quot;PropertyOffset.h&quot;
 28 #include &quot;ScopeOffset.h&quot;
 29 #include &lt;wtf/Assertions.h&gt;
 30 #include &lt;wtf/ForbidHeapAllocation.h&gt;
 31 
 32 namespace JSC {
 33 class GetterSetter;
 34 class JSObject;
 35 class JSModuleEnvironment;
 36 
 37 // ECMA 262-3 8.6.1
 38 // Property attributes
 39 enum class PropertyAttribute : unsigned {
 40     None              = 0,
 41     ReadOnly          = 1 &lt;&lt; 1,  // property can be only read, not written
 42     DontEnum          = 1 &lt;&lt; 2,  // property doesn&#39;t appear in (for .. in ..)
 43     DontDelete        = 1 &lt;&lt; 3,  // property can&#39;t be deleted
 44     Accessor          = 1 &lt;&lt; 4,  // property is a getter/setter
</pre>
<hr />
<pre>
100 
101 public:
102     enum class InternalMethodType : uint8_t {
103         Get, // [[Get]] internal method in the spec.
104         HasProperty, // [[HasProperty]] internal method in the spec.
105         GetOwnProperty, // [[GetOwnProperty]] internal method in the spec.
106         VMInquiry, // Our VM is just poking around. When this is the InternalMethodType, getOwnPropertySlot is not allowed to do user observable actions.
107     };
108 
109     enum class AdditionalDataType : uint8_t {
110         None,
111         DOMAttribute, // Annotated with DOMAttribute information.
112         ModuleNamespace, // ModuleNamespaceObject&#39;s environment access.
113     };
114 
115     explicit PropertySlot(const JSValue thisValue, InternalMethodType internalMethodType)
116         : m_offset(invalidOffset)
117         , m_thisValue(thisValue)
118         , m_slotBase(nullptr)
119         , m_watchpointSet(nullptr)
<span class="line-modified">120         , m_cacheability(CachingAllowed)</span>
121         , m_propertyType(TypeUnset)
122         , m_internalMethodType(internalMethodType)
123         , m_additionalDataType(AdditionalDataType::None)
124         , m_isTaintedByOpaqueObject(false)
125     {
126     }
127 
128     // FIXME: Remove this slotBase / receiver behavior difference in custom values and custom accessors.
129     // https://bugs.webkit.org/show_bug.cgi?id=158014
<span class="line-modified">130     typedef EncodedJSValue (*GetValueFunc)(ExecState*, EncodedJSValue thisValue, PropertyName);</span>
131 
<span class="line-modified">132     JSValue getValue(ExecState*, PropertyName) const;</span>
<span class="line-modified">133     JSValue getValue(ExecState*, unsigned propertyName) const;</span>
134     JSValue getPureResult() const;
135 
<span class="line-modified">136     bool isCacheable() const { return m_cacheability == CachingAllowed &amp;&amp; m_offset != invalidOffset; }</span>
137     bool isUnset() const { return m_propertyType == TypeUnset; }
138     bool isValue() const { return m_propertyType == TypeValue; }
139     bool isAccessor() const { return m_propertyType == TypeGetter; }
140     bool isCustom() const { return m_propertyType == TypeCustom; }
141     bool isCustomAccessor() const { return m_propertyType == TypeCustomAccessor; }
142     bool isCacheableValue() const { return isCacheable() &amp;&amp; isValue(); }
143     bool isCacheableGetter() const { return isCacheable() &amp;&amp; isAccessor(); }
144     bool isCacheableCustom() const { return isCacheable() &amp;&amp; isCustom(); }
145     void setIsTaintedByOpaqueObject() { m_isTaintedByOpaqueObject = true; }
146     bool isTaintedByOpaqueObject() const { return m_isTaintedByOpaqueObject; }
147 
148     InternalMethodType internalMethodType() const { return m_internalMethodType; }
149 
150     void disableCaching()
151     {
152         m_cacheability = CachingDisallowed;
153     }
154 
155     unsigned attributes() const { return m_attributes; }
156 
</pre>
<hr />
<pre>
200         unsigned scopeOffset;
201     };
202 
203     Optional&lt;ModuleNamespaceSlot&gt; moduleNamespaceSlot() const
204     {
205         if (m_additionalDataType == AdditionalDataType::ModuleNamespace)
206             return m_additionalData.moduleNamespaceSlot;
207         return WTF::nullopt;
208     }
209 
210     void setValue(JSObject* slotBase, unsigned attributes, JSValue value)
211     {
212         ASSERT(attributes == attributesForStructure(attributes));
213 
214         m_data.value = JSValue::encode(value);
215         m_attributes = attributes;
216 
217         ASSERT(slotBase);
218         m_slotBase = slotBase;
219         m_propertyType = TypeValue;
<span class="line-modified">220         m_offset = invalidOffset;</span>

221     }
222 
223     void setValue(JSObject* slotBase, unsigned attributes, JSValue value, PropertyOffset offset)
224     {
225         ASSERT(attributes == attributesForStructure(attributes));
226 
227         ASSERT(value);
228         m_data.value = JSValue::encode(value);
229         m_attributes = attributes;
230 
231         ASSERT(slotBase);
232         m_slotBase = slotBase;
233         m_propertyType = TypeValue;
234         m_offset = offset;


235     }
236 
237     void setValue(JSString*, unsigned attributes, JSValue value)
238     {
239         ASSERT(attributes == attributesForStructure(attributes));
240 
241         ASSERT(value);
242         m_data.value = JSValue::encode(value);
243         m_attributes = attributes;
244 
245         m_slotBase = 0;
246         m_propertyType = TypeValue;
<span class="line-modified">247         m_offset = invalidOffset;</span>

248     }
249 
250     void setValueModuleNamespace(JSObject* slotBase, unsigned attributes, JSValue value, JSModuleEnvironment* environment, ScopeOffset scopeOffset)
251     {
252         setValue(slotBase, attributes, value);
253         m_additionalDataType = AdditionalDataType::ModuleNamespace;
254         m_additionalData.moduleNamespaceSlot.environment = environment;
255         m_additionalData.moduleNamespaceSlot.scopeOffset = scopeOffset.offset();
256     }
257 
258     void setCustom(JSObject* slotBase, unsigned attributes, GetValueFunc getValue)
259     {
260         ASSERT(attributes == attributesForStructure(attributes));
261 
262         ASSERT(getValue);
263         assertIsCFunctionPtr(getValue);
264         m_data.custom.getValue = getValue;
265         m_attributes = attributes;
266 
267         ASSERT(slotBase);
268         m_slotBase = slotBase;
269         m_propertyType = TypeCustom;
<span class="line-modified">270         m_offset = invalidOffset;</span>
271     }
272 
273     void setCustom(JSObject* slotBase, unsigned attributes, GetValueFunc getValue, DOMAttributeAnnotation domAttribute)
274     {
275         setCustom(slotBase, attributes, getValue);
276         m_additionalDataType = AdditionalDataType::DOMAttribute;
277         m_additionalData.domAttribute = domAttribute;
278     }
279 
280     void setCacheableCustom(JSObject* slotBase, unsigned attributes, GetValueFunc getValue)
281     {
282         ASSERT(attributes == attributesForStructure(attributes));
283 
284         ASSERT(getValue);
285         assertIsCFunctionPtr(getValue);
286         m_data.custom.getValue = getValue;
287         m_attributes = attributes;
288 
289         ASSERT(slotBase);
290         m_slotBase = slotBase;
291         m_propertyType = TypeCustom;
<span class="line-modified">292         m_offset = !invalidOffset;</span>

293     }
294 
295     void setCacheableCustom(JSObject* slotBase, unsigned attributes, GetValueFunc getValue, DOMAttributeAnnotation domAttribute)
296     {
297         setCacheableCustom(slotBase, attributes, getValue);
298         m_additionalDataType = AdditionalDataType::DOMAttribute;
299         m_additionalData.domAttribute = domAttribute;
300     }
301 
302     void setCustomGetterSetter(JSObject* slotBase, unsigned attributes, CustomGetterSetter* getterSetter)
303     {
304         ASSERT(attributes == attributesForStructure(attributes));
305         ASSERT(attributes &amp; PropertyAttribute::CustomAccessor);
306 
307         disableCaching();
308 
309         ASSERT(getterSetter);
310         m_data.customAccessor.getterSetter = getterSetter;
311         m_attributes = attributes;
312 
313         ASSERT(slotBase);
314         m_slotBase = slotBase;
315         m_propertyType = TypeCustomAccessor;
<span class="line-modified">316         m_offset = invalidOffset;</span>

317     }
318 
319     void setGetterSlot(JSObject* slotBase, unsigned attributes, GetterSetter* getterSetter)
320     {
321         ASSERT(attributes == attributesForStructure(attributes));
322 
323         ASSERT(getterSetter);
324         m_data.getter.getterSetter = getterSetter;
325         m_attributes = attributes;
326 
327         ASSERT(slotBase);
328         m_slotBase = slotBase;
329         m_propertyType = TypeGetter;
<span class="line-modified">330         m_offset = invalidOffset;</span>

331     }
332 
333     void setCacheableGetterSlot(JSObject* slotBase, unsigned attributes, GetterSetter* getterSetter, PropertyOffset offset)
334     {
335         ASSERT(attributes == attributesForStructure(attributes));
336 
337         ASSERT(getterSetter);
338         m_data.getter.getterSetter = getterSetter;
339         m_attributes = attributes;
340 
341         ASSERT(slotBase);
342         m_slotBase = slotBase;
343         m_propertyType = TypeGetter;
344         m_offset = offset;


345     }
346 
347     JSValue thisValue() const
348     {
349         return m_thisValue;
350     }
351 
352     void setThisValue(JSValue thisValue)
353     {
354         m_thisValue = thisValue;
355     }
356 
357     void setUndefined()
358     {
359         m_data.value = JSValue::encode(jsUndefined());
360         m_attributes = PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::DontEnum;
361 
362         m_slotBase = 0;
363         m_propertyType = TypeValue;
<span class="line-removed">364         m_offset = invalidOffset;</span>
365     }
366 
367     void setWatchpointSet(WatchpointSet&amp; set)
368     {
369         m_watchpointSet = &amp;set;
370     }
371 
372 private:
<span class="line-modified">373     JS_EXPORT_PRIVATE JSValue functionGetter(ExecState*) const;</span>
<span class="line-modified">374     JS_EXPORT_PRIVATE JSValue customGetter(ExecState*, PropertyName) const;</span>
<span class="line-modified">375     JS_EXPORT_PRIVATE JSValue customAccessorGetter(ExecState*, PropertyName) const;</span>
376 
377     union {
378         EncodedJSValue value;
379         struct {
380             GetterSetter* getterSetter;
381         } getter;
382         struct {
383             GetValueFunc getValue;
384         } custom;
385         struct {
386             CustomGetterSetter* getterSetter;
387         } customAccessor;
388     } m_data;
389 
390     unsigned m_attributes;
391     PropertyOffset m_offset;
392     JSValue m_thisValue;
393     JSObject* m_slotBase;
394     WatchpointSet* m_watchpointSet;
395     CacheabilityType m_cacheability;
396     PropertyType m_propertyType;
397     InternalMethodType m_internalMethodType;
398     AdditionalDataType m_additionalDataType;
399     bool m_isTaintedByOpaqueObject;
400     union {
401         DOMAttributeAnnotation domAttribute;
402         ModuleNamespaceSlot moduleNamespaceSlot;
403     } m_additionalData;
404 };
405 
<span class="line-modified">406 ALWAYS_INLINE JSValue PropertySlot::getValue(ExecState* exec, PropertyName propertyName) const</span>
407 {
408     if (m_propertyType == TypeValue)
409         return JSValue::decode(m_data.value);
410     if (m_propertyType == TypeGetter)
<span class="line-modified">411         return functionGetter(exec);</span>
412     if (m_propertyType == TypeCustomAccessor)
<span class="line-modified">413         return customAccessorGetter(exec, propertyName);</span>
<span class="line-modified">414     return customGetter(exec, propertyName);</span>
415 }
416 
<span class="line-modified">417 ALWAYS_INLINE JSValue PropertySlot::getValue(ExecState* exec, unsigned propertyName) const</span>
418 {
<span class="line-modified">419     VM&amp; vm = exec-&gt;vm();</span>
420     if (m_propertyType == TypeValue)
421         return JSValue::decode(m_data.value);
422     if (m_propertyType == TypeGetter)
<span class="line-modified">423         return functionGetter(exec);</span>
424     if (m_propertyType == TypeCustomAccessor)
<span class="line-modified">425         return customAccessorGetter(exec, Identifier::from(vm, propertyName));</span>
<span class="line-modified">426     return customGetter(exec, Identifier::from(vm, propertyName));</span>
427 }
428 
429 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  3  *
  4  *  This library is free software; you can redistribute it and/or
  5  *  modify it under the terms of the GNU Library General Public
  6  *  License as published by the Free Software Foundation; either
  7  *  version 2 of the License, or (at your option) any later version.
  8  *
  9  *  This library is distributed in the hope that it will be useful,
 10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  *  Library General Public License for more details.
 13  *
 14  *  You should have received a copy of the GNU Library General Public License
 15  *  along with this library; see the file COPYING.LIB.  If not, write to
 16  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  *  Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #pragma once
 22 

 23 #include &quot;DOMAnnotation.h&quot;
<span class="line-added"> 24 #include &quot;GetVM.h&quot;</span>
 25 #include &quot;JSCJSValue.h&quot;
 26 #include &quot;PropertyName.h&quot;
 27 #include &quot;PropertyOffset.h&quot;
 28 #include &quot;ScopeOffset.h&quot;
 29 #include &lt;wtf/Assertions.h&gt;
 30 #include &lt;wtf/ForbidHeapAllocation.h&gt;
 31 
 32 namespace JSC {
 33 class GetterSetter;
 34 class JSObject;
 35 class JSModuleEnvironment;
 36 
 37 // ECMA 262-3 8.6.1
 38 // Property attributes
 39 enum class PropertyAttribute : unsigned {
 40     None              = 0,
 41     ReadOnly          = 1 &lt;&lt; 1,  // property can be only read, not written
 42     DontEnum          = 1 &lt;&lt; 2,  // property doesn&#39;t appear in (for .. in ..)
 43     DontDelete        = 1 &lt;&lt; 3,  // property can&#39;t be deleted
 44     Accessor          = 1 &lt;&lt; 4,  // property is a getter/setter
</pre>
<hr />
<pre>
100 
101 public:
102     enum class InternalMethodType : uint8_t {
103         Get, // [[Get]] internal method in the spec.
104         HasProperty, // [[HasProperty]] internal method in the spec.
105         GetOwnProperty, // [[GetOwnProperty]] internal method in the spec.
106         VMInquiry, // Our VM is just poking around. When this is the InternalMethodType, getOwnPropertySlot is not allowed to do user observable actions.
107     };
108 
109     enum class AdditionalDataType : uint8_t {
110         None,
111         DOMAttribute, // Annotated with DOMAttribute information.
112         ModuleNamespace, // ModuleNamespaceObject&#39;s environment access.
113     };
114 
115     explicit PropertySlot(const JSValue thisValue, InternalMethodType internalMethodType)
116         : m_offset(invalidOffset)
117         , m_thisValue(thisValue)
118         , m_slotBase(nullptr)
119         , m_watchpointSet(nullptr)
<span class="line-modified">120         , m_cacheability(CachingDisallowed)</span>
121         , m_propertyType(TypeUnset)
122         , m_internalMethodType(internalMethodType)
123         , m_additionalDataType(AdditionalDataType::None)
124         , m_isTaintedByOpaqueObject(false)
125     {
126     }
127 
128     // FIXME: Remove this slotBase / receiver behavior difference in custom values and custom accessors.
129     // https://bugs.webkit.org/show_bug.cgi?id=158014
<span class="line-modified">130     typedef EncodedJSValue (*GetValueFunc)(JSGlobalObject*, EncodedJSValue thisValue, PropertyName);</span>
131 
<span class="line-modified">132     JSValue getValue(JSGlobalObject*, PropertyName) const;</span>
<span class="line-modified">133     JSValue getValue(JSGlobalObject*, unsigned propertyName) const;</span>
134     JSValue getPureResult() const;
135 
<span class="line-modified">136     bool isCacheable() const { return isUnset() || m_cacheability == CachingAllowed; }</span>
137     bool isUnset() const { return m_propertyType == TypeUnset; }
138     bool isValue() const { return m_propertyType == TypeValue; }
139     bool isAccessor() const { return m_propertyType == TypeGetter; }
140     bool isCustom() const { return m_propertyType == TypeCustom; }
141     bool isCustomAccessor() const { return m_propertyType == TypeCustomAccessor; }
142     bool isCacheableValue() const { return isCacheable() &amp;&amp; isValue(); }
143     bool isCacheableGetter() const { return isCacheable() &amp;&amp; isAccessor(); }
144     bool isCacheableCustom() const { return isCacheable() &amp;&amp; isCustom(); }
145     void setIsTaintedByOpaqueObject() { m_isTaintedByOpaqueObject = true; }
146     bool isTaintedByOpaqueObject() const { return m_isTaintedByOpaqueObject; }
147 
148     InternalMethodType internalMethodType() const { return m_internalMethodType; }
149 
150     void disableCaching()
151     {
152         m_cacheability = CachingDisallowed;
153     }
154 
155     unsigned attributes() const { return m_attributes; }
156 
</pre>
<hr />
<pre>
200         unsigned scopeOffset;
201     };
202 
203     Optional&lt;ModuleNamespaceSlot&gt; moduleNamespaceSlot() const
204     {
205         if (m_additionalDataType == AdditionalDataType::ModuleNamespace)
206             return m_additionalData.moduleNamespaceSlot;
207         return WTF::nullopt;
208     }
209 
210     void setValue(JSObject* slotBase, unsigned attributes, JSValue value)
211     {
212         ASSERT(attributes == attributesForStructure(attributes));
213 
214         m_data.value = JSValue::encode(value);
215         m_attributes = attributes;
216 
217         ASSERT(slotBase);
218         m_slotBase = slotBase;
219         m_propertyType = TypeValue;
<span class="line-modified">220 </span>
<span class="line-added">221         ASSERT(m_cacheability == CachingDisallowed);</span>
222     }
223 
224     void setValue(JSObject* slotBase, unsigned attributes, JSValue value, PropertyOffset offset)
225     {
226         ASSERT(attributes == attributesForStructure(attributes));
227 
228         ASSERT(value);
229         m_data.value = JSValue::encode(value);
230         m_attributes = attributes;
231 
232         ASSERT(slotBase);
233         m_slotBase = slotBase;
234         m_propertyType = TypeValue;
235         m_offset = offset;
<span class="line-added">236 </span>
<span class="line-added">237         m_cacheability = CachingAllowed;</span>
238     }
239 
240     void setValue(JSString*, unsigned attributes, JSValue value)
241     {
242         ASSERT(attributes == attributesForStructure(attributes));
243 
244         ASSERT(value);
245         m_data.value = JSValue::encode(value);
246         m_attributes = attributes;
247 
248         m_slotBase = 0;
249         m_propertyType = TypeValue;
<span class="line-modified">250 </span>
<span class="line-added">251         ASSERT(m_cacheability == CachingDisallowed);</span>
252     }
253 
254     void setValueModuleNamespace(JSObject* slotBase, unsigned attributes, JSValue value, JSModuleEnvironment* environment, ScopeOffset scopeOffset)
255     {
256         setValue(slotBase, attributes, value);
257         m_additionalDataType = AdditionalDataType::ModuleNamespace;
258         m_additionalData.moduleNamespaceSlot.environment = environment;
259         m_additionalData.moduleNamespaceSlot.scopeOffset = scopeOffset.offset();
260     }
261 
262     void setCustom(JSObject* slotBase, unsigned attributes, GetValueFunc getValue)
263     {
264         ASSERT(attributes == attributesForStructure(attributes));
265 
266         ASSERT(getValue);
267         assertIsCFunctionPtr(getValue);
268         m_data.custom.getValue = getValue;
269         m_attributes = attributes;
270 
271         ASSERT(slotBase);
272         m_slotBase = slotBase;
273         m_propertyType = TypeCustom;
<span class="line-modified">274         ASSERT(m_cacheability == CachingDisallowed);</span>
275     }
276 
277     void setCustom(JSObject* slotBase, unsigned attributes, GetValueFunc getValue, DOMAttributeAnnotation domAttribute)
278     {
279         setCustom(slotBase, attributes, getValue);
280         m_additionalDataType = AdditionalDataType::DOMAttribute;
281         m_additionalData.domAttribute = domAttribute;
282     }
283 
284     void setCacheableCustom(JSObject* slotBase, unsigned attributes, GetValueFunc getValue)
285     {
286         ASSERT(attributes == attributesForStructure(attributes));
287 
288         ASSERT(getValue);
289         assertIsCFunctionPtr(getValue);
290         m_data.custom.getValue = getValue;
291         m_attributes = attributes;
292 
293         ASSERT(slotBase);
294         m_slotBase = slotBase;
295         m_propertyType = TypeCustom;
<span class="line-modified">296 </span>
<span class="line-added">297         m_cacheability = CachingAllowed;</span>
298     }
299 
300     void setCacheableCustom(JSObject* slotBase, unsigned attributes, GetValueFunc getValue, DOMAttributeAnnotation domAttribute)
301     {
302         setCacheableCustom(slotBase, attributes, getValue);
303         m_additionalDataType = AdditionalDataType::DOMAttribute;
304         m_additionalData.domAttribute = domAttribute;
305     }
306 
307     void setCustomGetterSetter(JSObject* slotBase, unsigned attributes, CustomGetterSetter* getterSetter)
308     {
309         ASSERT(attributes == attributesForStructure(attributes));
310         ASSERT(attributes &amp; PropertyAttribute::CustomAccessor);
311 
312         disableCaching();
313 
314         ASSERT(getterSetter);
315         m_data.customAccessor.getterSetter = getterSetter;
316         m_attributes = attributes;
317 
318         ASSERT(slotBase);
319         m_slotBase = slotBase;
320         m_propertyType = TypeCustomAccessor;
<span class="line-modified">321 </span>
<span class="line-added">322         ASSERT(m_cacheability == CachingDisallowed);</span>
323     }
324 
325     void setGetterSlot(JSObject* slotBase, unsigned attributes, GetterSetter* getterSetter)
326     {
327         ASSERT(attributes == attributesForStructure(attributes));
328 
329         ASSERT(getterSetter);
330         m_data.getter.getterSetter = getterSetter;
331         m_attributes = attributes;
332 
333         ASSERT(slotBase);
334         m_slotBase = slotBase;
335         m_propertyType = TypeGetter;
<span class="line-modified">336 </span>
<span class="line-added">337         ASSERT(m_cacheability == CachingDisallowed);</span>
338     }
339 
340     void setCacheableGetterSlot(JSObject* slotBase, unsigned attributes, GetterSetter* getterSetter, PropertyOffset offset)
341     {
342         ASSERT(attributes == attributesForStructure(attributes));
343 
344         ASSERT(getterSetter);
345         m_data.getter.getterSetter = getterSetter;
346         m_attributes = attributes;
347 
348         ASSERT(slotBase);
349         m_slotBase = slotBase;
350         m_propertyType = TypeGetter;
351         m_offset = offset;
<span class="line-added">352 </span>
<span class="line-added">353         m_cacheability = CachingAllowed;</span>
354     }
355 
356     JSValue thisValue() const
357     {
358         return m_thisValue;
359     }
360 
361     void setThisValue(JSValue thisValue)
362     {
363         m_thisValue = thisValue;
364     }
365 
366     void setUndefined()
367     {
368         m_data.value = JSValue::encode(jsUndefined());
369         m_attributes = PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::DontEnum;
370 
371         m_slotBase = 0;
372         m_propertyType = TypeValue;

373     }
374 
375     void setWatchpointSet(WatchpointSet&amp; set)
376     {
377         m_watchpointSet = &amp;set;
378     }
379 
380 private:
<span class="line-modified">381     JS_EXPORT_PRIVATE JSValue functionGetter(JSGlobalObject*) const;</span>
<span class="line-modified">382     JS_EXPORT_PRIVATE JSValue customGetter(JSGlobalObject*, PropertyName) const;</span>
<span class="line-modified">383     JS_EXPORT_PRIVATE JSValue customAccessorGetter(JSGlobalObject*, PropertyName) const;</span>
384 
385     union {
386         EncodedJSValue value;
387         struct {
388             GetterSetter* getterSetter;
389         } getter;
390         struct {
391             GetValueFunc getValue;
392         } custom;
393         struct {
394             CustomGetterSetter* getterSetter;
395         } customAccessor;
396     } m_data;
397 
398     unsigned m_attributes;
399     PropertyOffset m_offset;
400     JSValue m_thisValue;
401     JSObject* m_slotBase;
402     WatchpointSet* m_watchpointSet;
403     CacheabilityType m_cacheability;
404     PropertyType m_propertyType;
405     InternalMethodType m_internalMethodType;
406     AdditionalDataType m_additionalDataType;
407     bool m_isTaintedByOpaqueObject;
408     union {
409         DOMAttributeAnnotation domAttribute;
410         ModuleNamespaceSlot moduleNamespaceSlot;
411     } m_additionalData;
412 };
413 
<span class="line-modified">414 ALWAYS_INLINE JSValue PropertySlot::getValue(JSGlobalObject* globalObject, PropertyName propertyName) const</span>
415 {
416     if (m_propertyType == TypeValue)
417         return JSValue::decode(m_data.value);
418     if (m_propertyType == TypeGetter)
<span class="line-modified">419         return functionGetter(globalObject);</span>
420     if (m_propertyType == TypeCustomAccessor)
<span class="line-modified">421         return customAccessorGetter(globalObject, propertyName);</span>
<span class="line-modified">422     return customGetter(globalObject, propertyName);</span>
423 }
424 
<span class="line-modified">425 ALWAYS_INLINE JSValue PropertySlot::getValue(JSGlobalObject* globalObject, unsigned propertyName) const</span>
426 {
<span class="line-modified">427     VM&amp; vm = getVM(globalObject);</span>
428     if (m_propertyType == TypeValue)
429         return JSValue::decode(m_data.value);
430     if (m_propertyType == TypeGetter)
<span class="line-modified">431         return functionGetter(globalObject);</span>
432     if (m_propertyType == TypeCustomAccessor)
<span class="line-modified">433         return customAccessorGetter(globalObject, Identifier::from(vm, propertyName));</span>
<span class="line-modified">434     return customGetter(globalObject, Identifier::from(vm, propertyName));</span>
435 }
436 
437 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="PropertySlot.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PropertyTable.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/MessagePort.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MessageEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MessagePort.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/MessagePort.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  *
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;MessagePort.h&quot;
 29 
 30 #include &quot;Document.h&quot;
 31 #include &quot;EventNames.h&quot;
 32 #include &quot;Logging.h&quot;
 33 #include &quot;MessageEvent.h&quot;
 34 #include &quot;MessagePortChannelProvider.h&quot;
 35 #include &quot;MessageWithMessagePorts.h&quot;
 36 #include &quot;WorkerGlobalScope.h&quot;
 37 #include &quot;WorkerThread.h&quot;
 38 #include &lt;wtf/CompletionHandler.h&gt;
 39 #include &lt;wtf/IsoMallocInlines.h&gt;

 40 
 41 namespace WebCore {
 42 
 43 WTF_MAKE_ISO_ALLOCATED_IMPL(MessagePort);
 44 
 45 static Lock allMessagePortsLock;
 46 static HashMap&lt;MessagePortIdentifier, MessagePort*&gt;&amp; allMessagePorts()
 47 {
 48     static NeverDestroyed&lt;HashMap&lt;MessagePortIdentifier, MessagePort*&gt;&gt; map;
 49     return map;
 50 }
 51 
 52 void MessagePort::ref() const
 53 {
 54     ++m_refCount;
 55 }
 56 
 57 void MessagePort::deref() const
 58 {
 59     // This custom deref() function ensures that as long as the lock to allMessagePortsLock is taken, no MessagePort will be destroyed.
</pre>
<hr />
<pre>
107     suspendIfNeeded();
108 
109     // Don&#39;t need to call processMessageWithMessagePortsSoon() here, because the port will not be opened until start() is invoked.
110 }
111 
112 MessagePort::~MessagePort()
113 {
114     LOG(MessagePorts, &quot;Destroyed MessagePort %s (%p) in process %&quot; PRIu64, m_identifier.logString().utf8().data(), this, Process::identifier().toUInt64());
115 
116     ASSERT(allMessagePortsLock.isLocked());
117 
118     if (m_entangled)
119         close();
120 
121     if (m_scriptExecutionContext)
122         m_scriptExecutionContext-&gt;destroyedMessagePort(*this);
123 }
124 
125 void MessagePort::entangle()
126 {
<span class="line-modified">127     MessagePortChannelProvider::singleton().entangleLocalPortInThisProcessToRemote(m_identifier, m_remoteIdentifier);</span>
128 }
129 
<span class="line-modified">130 ExceptionOr&lt;void&gt; MessagePort::postMessage(JSC::ExecState&amp; state, JSC::JSValue messageValue, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp; transfer)</span>
131 {
132     LOG(MessagePorts, &quot;Attempting to post message to port %s (to be received by port %s)&quot;, m_identifier.logString().utf8().data(), m_remoteIdentifier.logString().utf8().data());
133 
134     registerLocalActivity();
135 
136     Vector&lt;RefPtr&lt;MessagePort&gt;&gt; ports;
<span class="line-modified">137     auto messageData = SerializedScriptValue::create(state, messageValue, WTFMove(transfer), ports);</span>
138     if (messageData.hasException())
139         return messageData.releaseException();
140 
141     if (!isEntangled())
142         return { };
143     ASSERT(m_scriptExecutionContext);
144 
145     TransferredMessagePortArray transferredPorts;
146     // Make sure we aren&#39;t connected to any of the passed-in ports.
147     if (!ports.isEmpty()) {
148         for (auto&amp; port : ports) {
149             if (port-&gt;identifier() == m_identifier || port-&gt;identifier() == m_remoteIdentifier)
150                 return Exception { DataCloneError };
151         }
152 
153         auto disentangleResult = MessagePort::disentanglePorts(WTFMove(ports));
154         if (disentangleResult.hasException())
155             return disentangleResult.releaseException();
156         transferredPorts = disentangleResult.releaseReturnValue();
157     }
158 
159     MessageWithMessagePorts message { messageData.releaseReturnValue(), WTFMove(transferredPorts) };
160 
161     LOG(MessagePorts, &quot;Actually posting message to port %s (to be received by port %s)&quot;, m_identifier.logString().utf8().data(), m_remoteIdentifier.logString().utf8().data());
162 
<span class="line-modified">163     MessagePortChannelProvider::singleton().postMessageToRemote(WTFMove(message), m_remoteIdentifier);</span>
164     return { };
165 }
166 
167 void MessagePort::disentangle()
168 {
169     ASSERT(m_entangled);
170     m_entangled = false;
171 
172     registerLocalActivity();
173 
<span class="line-modified">174     MessagePortChannelProvider::singleton().messagePortDisentangled(m_identifier);</span>
175 
176     // We can&#39;t receive any messages or generate any events after this, so remove ourselves from the list of active ports.
<span class="line-removed">177     ASSERT(m_scriptExecutionContext);</span>
178     m_scriptExecutionContext-&gt;destroyedMessagePort(*this);
179     m_scriptExecutionContext-&gt;willDestroyActiveDOMObject(*this);
180     m_scriptExecutionContext-&gt;willDestroyDestructionObserver(*this);
181 
182     m_scriptExecutionContext = nullptr;
183 }
184 
185 void MessagePort::registerLocalActivity()
186 {
187     // Any time certain local operations happen, we dirty our own state to delay GC.
188     m_hasHadLocalActivitySinceLastCheck = true;
189     m_mightBeEligibleForGC = false;
190 }
191 
192 // Invoked to notify us that there are messages available for this port.
193 // This code may be called from another thread, and so should not call any non-threadsafe APIs (i.e. should not call into the entangled channel or access mutable variables).
194 void MessagePort::messageAvailable()
195 {
196     // This MessagePort object might be disentangled because the port is being transferred,
197     // in which case we&#39;ll notify it that messages are available once a new end point is created.
</pre>
<hr />
<pre>
208         return;
209 
210     registerLocalActivity();
211 
212     ASSERT(m_scriptExecutionContext);
213     if (m_started)
214         return;
215 
216     m_started = true;
217     m_scriptExecutionContext-&gt;processMessageWithMessagePortsSoon();
218 }
219 
220 void MessagePort::close()
221 {
222     m_mightBeEligibleForGC = true;
223 
224     if (m_closed)
225         return;
226     m_closed = true;
227 
<span class="line-modified">228     MessagePortChannelProvider::singleton().messagePortClosed(m_identifier);</span>







229     removeAllEventListeners();
230 }
231 
232 void MessagePort::contextDestroyed()
233 {
234     ASSERT(m_scriptExecutionContext);
235 
236     close();
237     m_scriptExecutionContext = nullptr;
238 }
239 
240 void MessagePort::dispatchMessages()
241 {
242     // Messages for contexts that are not fully active get dispatched too, but JSAbstractEventListener::handleEvent() doesn&#39;t call handlers for these.
243     // The HTML5 spec specifies that any messages sent to a document that is not fully active should be dropped, so this behavior is OK.
244     ASSERT(started());
245 
246     if (!m_scriptExecutionContext || m_scriptExecutionContext-&gt;activeDOMObjectsAreSuspended() || !isEntangled())
247         return;
248 
<span class="line-modified">249     RefPtr&lt;WorkerThread&gt; workerThread;</span>
<span class="line-modified">250     if (is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext))</span>
<span class="line-removed">251         workerThread = &amp;downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).thread();</span>
252 
<span class="line-modified">253     auto messagesTakenHandler = [this, weakThis = makeWeakPtr(this), workerThread = WTFMove(workerThread)](Vector&lt;MessageWithMessagePorts&gt;&amp;&amp; messages, Function&lt;void()&gt;&amp;&amp; completionCallback) mutable {</span>
<span class="line-modified">254         ASSERT(isMainThread());</span>
<span class="line-removed">255         auto innerHandler = [this, weakThis = WTFMove(weakThis)](auto&amp;&amp; messages) {</span>
<span class="line-removed">256             if (!weakThis)</span>
<span class="line-removed">257                 return;</span>
258 
<span class="line-modified">259             LOG(MessagePorts, &quot;MessagePort %s (%p) dispatching %zu messages&quot;, m_identifier.logString().utf8().data(), this, messages.size());</span>
260 
<span class="line-modified">261             if (!m_scriptExecutionContext)</span>
<span class="line-modified">262                 return;</span>
263 
<span class="line-modified">264             if (!messages.isEmpty())</span>
<span class="line-modified">265                 registerLocalActivity();</span>
266 
<span class="line-modified">267             ASSERT(m_scriptExecutionContext-&gt;isContextThread());</span>
268 
<span class="line-modified">269             bool contextIsWorker = is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext);</span>
<span class="line-modified">270             for (auto&amp; message : messages) {</span>
<span class="line-modified">271                 // close() in Worker onmessage handler should prevent next message from dispatching.</span>
<span class="line-modified">272                 if (contextIsWorker &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).isClosing())</span>
<span class="line-modified">273                     return;</span>
<span class="line-modified">274                 auto ports = MessagePort::entanglePorts(*m_scriptExecutionContext, WTFMove(message.transferredPorts));</span>
<span class="line-modified">275                 dispatchEvent(MessageEvent::create(WTFMove(ports), message.message.releaseNonNull()));</span>
<span class="line-modified">276             }</span>
<span class="line-removed">277         };</span>
<span class="line-removed">278 </span>
<span class="line-removed">279         if (!workerThread) {</span>
<span class="line-removed">280             innerHandler(WTFMove(messages));</span>
<span class="line-removed">281             completionCallback();</span>
<span class="line-removed">282             return;</span>
283         }
<span class="line-removed">284         workerThread-&gt;runLoop().postTaskForMode([innerHandler = WTFMove(innerHandler), messages = WTFMove(messages), completionCallback = WTFMove(completionCallback)](auto&amp;) mutable {</span>
<span class="line-removed">285             innerHandler(WTFMove(messages));</span>
<span class="line-removed">286             callOnMainThread([completionCallback = WTFMove(completionCallback)] {</span>
<span class="line-removed">287                 completionCallback();</span>
<span class="line-removed">288             });</span>
<span class="line-removed">289         }, WorkerRunLoop::defaultMode());</span>
290     };
291 
<span class="line-modified">292     MessagePortChannelProvider::singleton().takeAllMessagesForPort(m_identifier, WTFMove(messagesTakenHandler));</span>











293 }
294 
295 void MessagePort::updateActivity(MessagePortChannelProvider::HasActivity hasActivity)
296 {
297     bool hasHadLocalActivity = m_hasHadLocalActivitySinceLastCheck;
298     m_hasHadLocalActivitySinceLastCheck = false;
299 
300     if (hasActivity == MessagePortChannelProvider::HasActivity::No &amp;&amp; !hasHadLocalActivity)
301         m_isRemoteEligibleForGC = true;
302 
303     if (hasActivity == MessagePortChannelProvider::HasActivity::Yes)
304         m_isRemoteEligibleForGC = false;
305 
306     m_isAskingRemoteAboutGC = false;
307 }
308 
309 bool MessagePort::hasPendingActivity() const
310 {
311     m_mightBeEligibleForGC = true;
312 
313     // If the ScriptExecutionContext has been shut down on this object close()&#39;ed, we can GC.
314     if (!m_scriptExecutionContext || m_closed)
315         return false;
316 
317     // If this object has been idle since the remote port declared itself elgibile for GC, we can GC.
318     if (!m_hasHadLocalActivitySinceLastCheck &amp;&amp; m_isRemoteEligibleForGC)
319         return false;
320 
321     // If this MessagePort has no message event handler then the existence of remote activity cannot keep it alive.
322     if (!m_hasMessageEventListener)
323         return false;
324 
325     // If we&#39;re not in the middle of asking the remote port about collectability, do so now.
326     if (!m_isAskingRemoteAboutGC) {
327         RefPtr&lt;WorkerThread&gt; workerThread;
328         if (is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext))
329             workerThread = &amp;downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).thread();
330 
<span class="line-modified">331         MessagePortChannelProvider::singleton().checkRemotePortForActivity(m_remoteIdentifier, [weakThis = makeWeakPtr(const_cast&lt;MessagePort*&gt;(this)), workerThread = WTFMove(workerThread)](MessagePortChannelProvider::HasActivity hasActivity) mutable {</span>
<span class="line-modified">332 </span>
<span class="line-modified">333             ASSERT(isMainThread());</span>
<span class="line-modified">334             if (!workerThread) {</span>
<span class="line-modified">335                 if (weakThis)</span>
<span class="line-modified">336                     weakThis-&gt;updateActivity(hasActivity);</span>
<span class="line-modified">337                 return;</span>
<span class="line-removed">338             }</span>
339 
<span class="line-modified">340             workerThread-&gt;runLoop().postTaskForMode([weakThis = WTFMove(weakThis), hasActivity](auto&amp;) mutable {</span>
<span class="line-modified">341                 if (weakThis)</span>
<span class="line-modified">342                     weakThis-&gt;updateActivity(hasActivity);</span>
<span class="line-modified">343             }, WorkerRunLoop::defaultMode());</span>

344         });
345         m_isAskingRemoteAboutGC = true;
346     }
347 
348     // Since we need an answer from the remote object, we have to pretend we have pending activity for now.
349     return true;
350 }
351 
352 bool MessagePort::isLocallyReachable() const
353 {
354     return !m_mightBeEligibleForGC;
355 }
356 
357 MessagePort* MessagePort::locallyEntangledPort() const
358 {
359     // FIXME: As the header describes, this is an optional optimization.
360     // Even in the new async model we should be able to get it right.
361     return nullptr;
362 }
363 
</pre>
<hr />
<pre>
411     }
412 
413     return EventTargetWithInlineData::addEventListener(eventType, WTFMove(listener), options);
414 }
415 
416 bool MessagePort::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)
417 {
418     auto result = EventTargetWithInlineData::removeEventListener(eventType, listener, options);
419 
420     if (!hasEventListeners(eventNames().messageEvent))
421         m_hasMessageEventListener = false;
422 
423     return result;
424 }
425 
426 const char* MessagePort::activeDOMObjectName() const
427 {
428     return &quot;MessagePort&quot;;
429 }
430 
<span class="line-removed">431 bool MessagePort::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">432 {</span>
<span class="line-removed">433     return true;</span>
<span class="line-removed">434 }</span>
<span class="line-removed">435 </span>
436 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  *
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;MessagePort.h&quot;
 29 
 30 #include &quot;Document.h&quot;
 31 #include &quot;EventNames.h&quot;
 32 #include &quot;Logging.h&quot;
 33 #include &quot;MessageEvent.h&quot;
 34 #include &quot;MessagePortChannelProvider.h&quot;
 35 #include &quot;MessageWithMessagePorts.h&quot;
 36 #include &quot;WorkerGlobalScope.h&quot;
 37 #include &quot;WorkerThread.h&quot;
 38 #include &lt;wtf/CompletionHandler.h&gt;
 39 #include &lt;wtf/IsoMallocInlines.h&gt;
<span class="line-added"> 40 #include &lt;wtf/Scope.h&gt;</span>
 41 
 42 namespace WebCore {
 43 
 44 WTF_MAKE_ISO_ALLOCATED_IMPL(MessagePort);
 45 
 46 static Lock allMessagePortsLock;
 47 static HashMap&lt;MessagePortIdentifier, MessagePort*&gt;&amp; allMessagePorts()
 48 {
 49     static NeverDestroyed&lt;HashMap&lt;MessagePortIdentifier, MessagePort*&gt;&gt; map;
 50     return map;
 51 }
 52 
 53 void MessagePort::ref() const
 54 {
 55     ++m_refCount;
 56 }
 57 
 58 void MessagePort::deref() const
 59 {
 60     // This custom deref() function ensures that as long as the lock to allMessagePortsLock is taken, no MessagePort will be destroyed.
</pre>
<hr />
<pre>
108     suspendIfNeeded();
109 
110     // Don&#39;t need to call processMessageWithMessagePortsSoon() here, because the port will not be opened until start() is invoked.
111 }
112 
113 MessagePort::~MessagePort()
114 {
115     LOG(MessagePorts, &quot;Destroyed MessagePort %s (%p) in process %&quot; PRIu64, m_identifier.logString().utf8().data(), this, Process::identifier().toUInt64());
116 
117     ASSERT(allMessagePortsLock.isLocked());
118 
119     if (m_entangled)
120         close();
121 
122     if (m_scriptExecutionContext)
123         m_scriptExecutionContext-&gt;destroyedMessagePort(*this);
124 }
125 
126 void MessagePort::entangle()
127 {
<span class="line-modified">128     MessagePortChannelProvider::fromContext(*m_scriptExecutionContext).entangleLocalPortInThisProcessToRemote(m_identifier, m_remoteIdentifier);</span>
129 }
130 
<span class="line-modified">131 ExceptionOr&lt;void&gt; MessagePort::postMessage(JSC::JSGlobalObject&amp; state, JSC::JSValue messageValue, PostMessageOptions&amp;&amp; options)</span>
132 {
133     LOG(MessagePorts, &quot;Attempting to post message to port %s (to be received by port %s)&quot;, m_identifier.logString().utf8().data(), m_remoteIdentifier.logString().utf8().data());
134 
135     registerLocalActivity();
136 
137     Vector&lt;RefPtr&lt;MessagePort&gt;&gt; ports;
<span class="line-modified">138     auto messageData = SerializedScriptValue::create(state, messageValue, WTFMove(options.transfer), ports);</span>
139     if (messageData.hasException())
140         return messageData.releaseException();
141 
142     if (!isEntangled())
143         return { };
144     ASSERT(m_scriptExecutionContext);
145 
146     TransferredMessagePortArray transferredPorts;
147     // Make sure we aren&#39;t connected to any of the passed-in ports.
148     if (!ports.isEmpty()) {
149         for (auto&amp; port : ports) {
150             if (port-&gt;identifier() == m_identifier || port-&gt;identifier() == m_remoteIdentifier)
151                 return Exception { DataCloneError };
152         }
153 
154         auto disentangleResult = MessagePort::disentanglePorts(WTFMove(ports));
155         if (disentangleResult.hasException())
156             return disentangleResult.releaseException();
157         transferredPorts = disentangleResult.releaseReturnValue();
158     }
159 
160     MessageWithMessagePorts message { messageData.releaseReturnValue(), WTFMove(transferredPorts) };
161 
162     LOG(MessagePorts, &quot;Actually posting message to port %s (to be received by port %s)&quot;, m_identifier.logString().utf8().data(), m_remoteIdentifier.logString().utf8().data());
163 
<span class="line-modified">164     MessagePortChannelProvider::fromContext(*m_scriptExecutionContext).postMessageToRemote(WTFMove(message), m_remoteIdentifier);</span>
165     return { };
166 }
167 
168 void MessagePort::disentangle()
169 {
170     ASSERT(m_entangled);
171     m_entangled = false;
172 
173     registerLocalActivity();
174 
<span class="line-modified">175     MessagePortChannelProvider::fromContext(*m_scriptExecutionContext).messagePortDisentangled(m_identifier);</span>
176 
177     // We can&#39;t receive any messages or generate any events after this, so remove ourselves from the list of active ports.

178     m_scriptExecutionContext-&gt;destroyedMessagePort(*this);
179     m_scriptExecutionContext-&gt;willDestroyActiveDOMObject(*this);
180     m_scriptExecutionContext-&gt;willDestroyDestructionObserver(*this);
181 
182     m_scriptExecutionContext = nullptr;
183 }
184 
185 void MessagePort::registerLocalActivity()
186 {
187     // Any time certain local operations happen, we dirty our own state to delay GC.
188     m_hasHadLocalActivitySinceLastCheck = true;
189     m_mightBeEligibleForGC = false;
190 }
191 
192 // Invoked to notify us that there are messages available for this port.
193 // This code may be called from another thread, and so should not call any non-threadsafe APIs (i.e. should not call into the entangled channel or access mutable variables).
194 void MessagePort::messageAvailable()
195 {
196     // This MessagePort object might be disentangled because the port is being transferred,
197     // in which case we&#39;ll notify it that messages are available once a new end point is created.
</pre>
<hr />
<pre>
208         return;
209 
210     registerLocalActivity();
211 
212     ASSERT(m_scriptExecutionContext);
213     if (m_started)
214         return;
215 
216     m_started = true;
217     m_scriptExecutionContext-&gt;processMessageWithMessagePortsSoon();
218 }
219 
220 void MessagePort::close()
221 {
222     m_mightBeEligibleForGC = true;
223 
224     if (m_closed)
225         return;
226     m_closed = true;
227 
<span class="line-modified">228     if (isMainThread())</span>
<span class="line-added">229         MessagePortChannelProvider::singleton().messagePortClosed(m_identifier);</span>
<span class="line-added">230     else {</span>
<span class="line-added">231         callOnMainThread([identifier = m_identifier] {</span>
<span class="line-added">232             MessagePortChannelProvider::singleton().messagePortClosed(identifier);</span>
<span class="line-added">233         });</span>
<span class="line-added">234     }</span>
<span class="line-added">235 </span>
236     removeAllEventListeners();
237 }
238 
239 void MessagePort::contextDestroyed()
240 {
241     ASSERT(m_scriptExecutionContext);
242 
243     close();
244     m_scriptExecutionContext = nullptr;
245 }
246 
247 void MessagePort::dispatchMessages()
248 {
249     // Messages for contexts that are not fully active get dispatched too, but JSAbstractEventListener::handleEvent() doesn&#39;t call handlers for these.
250     // The HTML5 spec specifies that any messages sent to a document that is not fully active should be dropped, so this behavior is OK.
251     ASSERT(started());
252 
253     if (!m_scriptExecutionContext || m_scriptExecutionContext-&gt;activeDOMObjectsAreSuspended() || !isEntangled())
254         return;
255 
<span class="line-modified">256     auto messagesTakenHandler = [this, weakThis = makeWeakPtr(this)](Vector&lt;MessageWithMessagePorts&gt;&amp;&amp; messages, Function&lt;void()&gt;&amp;&amp; completionCallback) mutable {</span>
<span class="line-modified">257         auto scopeExit = makeScopeExit(WTFMove(completionCallback));</span>

258 
<span class="line-modified">259         if (!weakThis)</span>
<span class="line-modified">260             return;</span>



261 
<span class="line-modified">262         LOG(MessagePorts, &quot;MessagePort %s (%p) dispatching %zu messages&quot;, m_identifier.logString().utf8().data(), this, messages.size());</span>
263 
<span class="line-modified">264         if (!m_scriptExecutionContext)</span>
<span class="line-modified">265             return;</span>
266 
<span class="line-modified">267         if (!messages.isEmpty())</span>
<span class="line-modified">268             registerLocalActivity();</span>
269 
<span class="line-modified">270         ASSERT(m_scriptExecutionContext-&gt;isContextThread());</span>
271 
<span class="line-modified">272         bool contextIsWorker = is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext);</span>
<span class="line-modified">273         for (auto&amp; message : messages) {</span>
<span class="line-modified">274             // close() in Worker onmessage handler should prevent next message from dispatching.</span>
<span class="line-modified">275             if (contextIsWorker &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).isClosing())</span>
<span class="line-modified">276                 return;</span>
<span class="line-modified">277             auto ports = MessagePort::entanglePorts(*m_scriptExecutionContext, WTFMove(message.transferredPorts));</span>
<span class="line-modified">278             // Per specification, each MessagePort object has a task source called the port message queue.</span>
<span class="line-modified">279             queueTaskToDispatchEvent(*this, TaskSource::PostedMessageQueue, MessageEvent::create(WTFMove(ports), message.message.releaseNonNull()));</span>






280         }






281     };
282 
<span class="line-modified">283     MessagePortChannelProvider::fromContext(*m_scriptExecutionContext).takeAllMessagesForPort(m_identifier, WTFMove(messagesTakenHandler));</span>
<span class="line-added">284 }</span>
<span class="line-added">285 </span>
<span class="line-added">286 void MessagePort::dispatchEvent(Event&amp; event)</span>
<span class="line-added">287 {</span>
<span class="line-added">288     if (m_closed)</span>
<span class="line-added">289         return;</span>
<span class="line-added">290 </span>
<span class="line-added">291     if (is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext) &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).isClosing())</span>
<span class="line-added">292         return;</span>
<span class="line-added">293 </span>
<span class="line-added">294     EventTarget::dispatchEvent(event);</span>
295 }
296 
297 void MessagePort::updateActivity(MessagePortChannelProvider::HasActivity hasActivity)
298 {
299     bool hasHadLocalActivity = m_hasHadLocalActivitySinceLastCheck;
300     m_hasHadLocalActivitySinceLastCheck = false;
301 
302     if (hasActivity == MessagePortChannelProvider::HasActivity::No &amp;&amp; !hasHadLocalActivity)
303         m_isRemoteEligibleForGC = true;
304 
305     if (hasActivity == MessagePortChannelProvider::HasActivity::Yes)
306         m_isRemoteEligibleForGC = false;
307 
308     m_isAskingRemoteAboutGC = false;
309 }
310 
311 bool MessagePort::hasPendingActivity() const
312 {
313     m_mightBeEligibleForGC = true;
314 
315     // If the ScriptExecutionContext has been shut down on this object close()&#39;ed, we can GC.
316     if (!m_scriptExecutionContext || m_closed)
317         return false;
318 
319     // If this object has been idle since the remote port declared itself elgibile for GC, we can GC.
320     if (!m_hasHadLocalActivitySinceLastCheck &amp;&amp; m_isRemoteEligibleForGC)
321         return false;
322 
323     // If this MessagePort has no message event handler then the existence of remote activity cannot keep it alive.
324     if (!m_hasMessageEventListener)
325         return false;
326 
327     // If we&#39;re not in the middle of asking the remote port about collectability, do so now.
328     if (!m_isAskingRemoteAboutGC) {
329         RefPtr&lt;WorkerThread&gt; workerThread;
330         if (is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext))
331             workerThread = &amp;downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).thread();
332 
<span class="line-modified">333         callOnMainThread([remoteIdentifier = m_remoteIdentifier, weakThis = makeWeakPtr(const_cast&lt;MessagePort*&gt;(this)), workerThread = WTFMove(workerThread)]() mutable {</span>
<span class="line-modified">334             MessagePortChannelProvider::singleton().checkRemotePortForActivity(remoteIdentifier, [weakThis = WTFMove(weakThis), workerThread = WTFMove(workerThread)](auto hasActivity) mutable {</span>
<span class="line-modified">335                 if (!workerThread) {</span>
<span class="line-modified">336                     if (weakThis)</span>
<span class="line-modified">337                         weakThis-&gt;updateActivity(hasActivity);</span>
<span class="line-modified">338                     return;</span>
<span class="line-modified">339                 }</span>

340 
<span class="line-modified">341                 workerThread-&gt;runLoop().postTaskForMode([weakThis = WTFMove(weakThis), hasActivity](auto&amp;) mutable {</span>
<span class="line-modified">342                     if (weakThis)</span>
<span class="line-modified">343                         weakThis-&gt;updateActivity(hasActivity);</span>
<span class="line-modified">344                 }, WorkerRunLoop::defaultMode());</span>
<span class="line-added">345             });</span>
346         });
347         m_isAskingRemoteAboutGC = true;
348     }
349 
350     // Since we need an answer from the remote object, we have to pretend we have pending activity for now.
351     return true;
352 }
353 
354 bool MessagePort::isLocallyReachable() const
355 {
356     return !m_mightBeEligibleForGC;
357 }
358 
359 MessagePort* MessagePort::locallyEntangledPort() const
360 {
361     // FIXME: As the header describes, this is an optional optimization.
362     // Even in the new async model we should be able to get it right.
363     return nullptr;
364 }
365 
</pre>
<hr />
<pre>
413     }
414 
415     return EventTargetWithInlineData::addEventListener(eventType, WTFMove(listener), options);
416 }
417 
418 bool MessagePort::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)
419 {
420     auto result = EventTargetWithInlineData::removeEventListener(eventType, listener, options);
421 
422     if (!hasEventListeners(eventNames().messageEvent))
423         m_hasMessageEventListener = false;
424 
425     return result;
426 }
427 
428 const char* MessagePort::activeDOMObjectName() const
429 {
430     return &quot;MessagePort&quot;;
431 }
432 





433 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="MessageEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MessagePort.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
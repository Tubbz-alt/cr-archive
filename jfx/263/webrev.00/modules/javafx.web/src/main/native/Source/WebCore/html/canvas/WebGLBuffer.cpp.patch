diff a/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLBuffer.cpp b/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLBuffer.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLBuffer.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLBuffer.cpp
@@ -28,10 +28,11 @@
 
 #if ENABLE(WEBGL)
 
 #include "WebGLContextGroup.h"
 #include "WebGLRenderingContextBase.h"
+#include <JavaScriptCore/ArrayBuffer.h>
 
 namespace WebCore {
 
 Ref<WebGLBuffer> WebGLBuffer::create(WebGLRenderingContextBase& ctx)
 {
@@ -39,31 +40,31 @@
 }
 
 WebGLBuffer::WebGLBuffer(WebGLRenderingContextBase& ctx)
     : WebGLSharedObject(ctx)
 {
-    setObject(ctx.graphicsContext3D()->createBuffer());
+    setObject(ctx.graphicsContextGL()->createBuffer());
     clearCachedMaxIndices();
 }
 
 WebGLBuffer::~WebGLBuffer()
 {
     deleteObject(0);
 }
 
-void WebGLBuffer::deleteObjectImpl(GraphicsContext3D* context3d, Platform3DObject object)
+void WebGLBuffer::deleteObjectImpl(GraphicsContextGLOpenGL* context3d, PlatformGLObject object)
 {
     context3d->deleteBuffer(object);
 }
 
-bool WebGLBuffer::associateBufferDataImpl(const void* data, GC3Dsizeiptr byteLength)
+bool WebGLBuffer::associateBufferDataImpl(const void* data, GCGLsizeiptr byteLength)
 {
     if (byteLength < 0)
         return false;
 
     switch (m_target) {
-    case GraphicsContext3D::ELEMENT_ARRAY_BUFFER:
+    case GraphicsContextGL::ELEMENT_ARRAY_BUFFER:
         if (byteLength > std::numeric_limits<unsigned>::max())
             return false;
         m_byteLength = byteLength;
         clearCachedMaxIndices();
         if (byteLength) {
@@ -79,31 +80,31 @@
                 memcpy(m_elementArrayBuffer->data(), data, byteLength);
             }
         } else
             m_elementArrayBuffer = nullptr;
         return true;
-    case GraphicsContext3D::ARRAY_BUFFER:
+    case GraphicsContextGL::ARRAY_BUFFER:
         m_byteLength = byteLength;
         return true;
     default:
 #if ENABLE(WEBGL2)
         switch (m_target) {
-        case GraphicsContext3D::COPY_READ_BUFFER:
-        case GraphicsContext3D::COPY_WRITE_BUFFER:
-        case GraphicsContext3D::PIXEL_PACK_BUFFER:
-        case GraphicsContext3D::PIXEL_UNPACK_BUFFER:
-        case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:
-        case GraphicsContext3D::UNIFORM_BUFFER:
+        case GraphicsContextGL::COPY_READ_BUFFER:
+        case GraphicsContextGL::COPY_WRITE_BUFFER:
+        case GraphicsContextGL::PIXEL_PACK_BUFFER:
+        case GraphicsContextGL::PIXEL_UNPACK_BUFFER:
+        case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:
+        case GraphicsContextGL::UNIFORM_BUFFER:
             m_byteLength = byteLength;
             return true;
         }
 #endif
         return false;
     }
 }
 
-bool WebGLBuffer::associateBufferData(GC3Dsizeiptr size)
+bool WebGLBuffer::associateBufferData(GCGLsizeiptr size)
 {
     return associateBufferDataImpl(nullptr, size);
 }
 
 bool WebGLBuffer::associateBufferData(ArrayBuffer* array)
@@ -118,102 +119,102 @@
     if (!array)
         return false;
     return associateBufferDataImpl(array->baseAddress(), array->byteLength());
 }
 
-bool WebGLBuffer::associateBufferSubDataImpl(GC3Dintptr offset, const void* data, GC3Dsizeiptr byteLength)
+bool WebGLBuffer::associateBufferSubDataImpl(GCGLintptr offset, const void* data, GCGLsizeiptr byteLength)
 {
     if (!data || offset < 0 || byteLength < 0)
         return false;
 
     if (byteLength) {
-        Checked<GC3Dintptr, RecordOverflow> checkedBufferOffset(offset);
-        Checked<GC3Dsizeiptr, RecordOverflow> checkedDataLength(byteLength);
-        Checked<GC3Dintptr, RecordOverflow> checkedBufferMax = checkedBufferOffset + checkedDataLength;
+        Checked<GCGLintptr, RecordOverflow> checkedBufferOffset(offset);
+        Checked<GCGLsizeiptr, RecordOverflow> checkedDataLength(byteLength);
+        Checked<GCGLintptr, RecordOverflow> checkedBufferMax = checkedBufferOffset + checkedDataLength;
         if (checkedBufferMax.hasOverflowed() || offset > m_byteLength || checkedBufferMax.unsafeGet() > m_byteLength)
             return false;
     }
 
     switch (m_target) {
-    case GraphicsContext3D::ELEMENT_ARRAY_BUFFER:
+    case GraphicsContextGL::ELEMENT_ARRAY_BUFFER:
         clearCachedMaxIndices();
         if (byteLength) {
             if (!m_elementArrayBuffer)
                 return false;
             memcpy(static_cast<unsigned char*>(m_elementArrayBuffer->data()) + offset, data, byteLength);
         }
         return true;
-    case GraphicsContext3D::ARRAY_BUFFER:
+    case GraphicsContextGL::ARRAY_BUFFER:
         return true;
     default:
 #if ENABLE(WEBGL2)
         switch (m_target) {
-        case GraphicsContext3D::COPY_READ_BUFFER:
-        case GraphicsContext3D::COPY_WRITE_BUFFER:
-        case GraphicsContext3D::PIXEL_PACK_BUFFER:
-        case GraphicsContext3D::PIXEL_UNPACK_BUFFER:
-        case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:
-        case GraphicsContext3D::UNIFORM_BUFFER:
+        case GraphicsContextGL::COPY_READ_BUFFER:
+        case GraphicsContextGL::COPY_WRITE_BUFFER:
+        case GraphicsContextGL::PIXEL_PACK_BUFFER:
+        case GraphicsContextGL::PIXEL_UNPACK_BUFFER:
+        case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:
+        case GraphicsContextGL::UNIFORM_BUFFER:
             return true;
         }
 #endif
         return false;
     }
 }
 
-bool WebGLBuffer::associateBufferSubData(GC3Dintptr offset, ArrayBuffer* array)
+bool WebGLBuffer::associateBufferSubData(GCGLintptr offset, ArrayBuffer* array)
 {
     if (!array)
         return false;
     return associateBufferSubDataImpl(offset, array->data(), array->byteLength());
 }
 
-bool WebGLBuffer::associateBufferSubData(GC3Dintptr offset, ArrayBufferView* array)
+bool WebGLBuffer::associateBufferSubData(GCGLintptr offset, ArrayBufferView* array)
 {
     if (!array)
         return false;
     return associateBufferSubDataImpl(offset, array->baseAddress(), array->byteLength());
 }
 
-bool WebGLBuffer::associateCopyBufferSubData(const WebGLBuffer& readBuffer, GC3Dintptr readOffset, GC3Dintptr writeOffset, GC3Dsizeiptr size)
+bool WebGLBuffer::associateCopyBufferSubData(const WebGLBuffer& readBuffer, GCGLintptr readOffset, GCGLintptr writeOffset, GCGLsizeiptr size)
 {
     if (readOffset < 0 || writeOffset < 0 || size < 0)
         return false;
 
     if (size) {
-        Checked<GC3Dintptr, RecordOverflow> checkedReadBufferOffset(readOffset);
-        Checked<GC3Dsizeiptr, RecordOverflow> checkedDataLength(size);
-        Checked<GC3Dintptr, RecordOverflow> checkedReadBufferMax = checkedReadBufferOffset + checkedDataLength;
+        Checked<GCGLintptr, RecordOverflow> checkedReadBufferOffset(readOffset);
+        Checked<GCGLsizeiptr, RecordOverflow> checkedDataLength(size);
+        Checked<GCGLintptr, RecordOverflow> checkedReadBufferMax = checkedReadBufferOffset + checkedDataLength;
         if (checkedReadBufferMax.hasOverflowed() || readOffset > readBuffer.byteLength() || checkedReadBufferMax.unsafeGet() > readBuffer.byteLength())
             return false;
 
-        Checked<GC3Dintptr, RecordOverflow> checkedWriteBufferOffset(writeOffset);
-        Checked<GC3Dintptr, RecordOverflow> checkedWriteBufferMax = checkedWriteBufferOffset + checkedDataLength;
+        Checked<GCGLintptr, RecordOverflow> checkedWriteBufferOffset(writeOffset);
+        Checked<GCGLintptr, RecordOverflow> checkedWriteBufferMax = checkedWriteBufferOffset + checkedDataLength;
         if (checkedWriteBufferMax.hasOverflowed() || writeOffset > m_byteLength || checkedWriteBufferMax.unsafeGet() > m_byteLength)
             return false;
     }
 
     switch (m_target) {
-    case GraphicsContext3D::ELEMENT_ARRAY_BUFFER:
+    case GraphicsContextGL::ELEMENT_ARRAY_BUFFER:
         clearCachedMaxIndices();
         if (size) {
             if (!m_elementArrayBuffer)
                 return false;
             memcpy(static_cast<unsigned char*>(m_elementArrayBuffer->data()) + writeOffset, static_cast<const unsigned char*>(readBuffer.elementArrayBuffer()->data()) + readOffset, size);
         }
         return true;
-    case GraphicsContext3D::ARRAY_BUFFER:
+    case GraphicsContextGL::ARRAY_BUFFER:
         return true;
     default:
 #if ENABLE(WEBGL2)
         switch (m_target) {
-        case GraphicsContext3D::COPY_READ_BUFFER:
-        case GraphicsContext3D::COPY_WRITE_BUFFER:
-        case GraphicsContext3D::PIXEL_PACK_BUFFER:
-        case GraphicsContext3D::PIXEL_UNPACK_BUFFER:
-        case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:
-        case GraphicsContext3D::UNIFORM_BUFFER:
+        case GraphicsContextGL::COPY_READ_BUFFER:
+        case GraphicsContextGL::COPY_WRITE_BUFFER:
+        case GraphicsContextGL::PIXEL_PACK_BUFFER:
+        case GraphicsContextGL::PIXEL_UNPACK_BUFFER:
+        case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:
+        case GraphicsContextGL::UNIFORM_BUFFER:
             return true;
         }
 #endif
         return false;
     }
@@ -223,25 +224,25 @@
 {
     m_byteLength = 0;
     clearCachedMaxIndices();
 }
 
-GC3Dsizeiptr WebGLBuffer::byteLength() const
+GCGLsizeiptr WebGLBuffer::byteLength() const
 {
     return m_byteLength;
 }
 
-Optional<unsigned> WebGLBuffer::getCachedMaxIndex(GC3Denum type)
+Optional<unsigned> WebGLBuffer::getCachedMaxIndex(GCGLenum type)
 {
     for (auto& cache : m_maxIndexCache) {
         if (cache.type == type)
             return cache.maxIndex;
     }
     return WTF::nullopt;
 }
 
-void WebGLBuffer::setCachedMaxIndex(GC3Denum type, unsigned value)
+void WebGLBuffer::setCachedMaxIndex(GCGLenum type, unsigned value)
 {
     for (auto& cache : m_maxIndexCache) {
         if (cache.type == type) {
             cache.maxIndex = value;
             return;
@@ -250,29 +251,17 @@
     m_maxIndexCache[m_nextAvailableCacheEntry].type = type;
     m_maxIndexCache[m_nextAvailableCacheEntry].maxIndex = value;
     m_nextAvailableCacheEntry = (m_nextAvailableCacheEntry + 1) % WTF_ARRAY_LENGTH(m_maxIndexCache);
 }
 
-void WebGLBuffer::setTarget(GC3Denum target, bool forWebGL2)
+void WebGLBuffer::setTarget(GCGLenum target)
 {
-    // In WebGL, a buffer is bound to one target in its lifetime
-    if (m_target)
-        return;
-    if (target == GraphicsContext3D::ARRAY_BUFFER || target == GraphicsContext3D::ELEMENT_ARRAY_BUFFER)
-        m_target = target;
-    else if (forWebGL2) {
-#if ENABLE(WEBGL2)
-        switch (target) {
-        case GraphicsContext3D::COPY_READ_BUFFER:
-        case GraphicsContext3D::COPY_WRITE_BUFFER:
-        case GraphicsContext3D::PIXEL_PACK_BUFFER:
-        case GraphicsContext3D::PIXEL_UNPACK_BUFFER:
-        case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:
-        case GraphicsContext3D::UNIFORM_BUFFER:
-            m_target = target;
-        }
-#endif
+    m_target = target;
+
+    if (target == GraphicsContextGL::ARRAY_BUFFER || target == GraphicsContextGL::ELEMENT_ARRAY_BUFFER) {
+        ASSERT(!m_arrayBufferOrElementArrayBuffer || target == m_arrayBufferOrElementArrayBuffer);
+        m_arrayBufferOrElementArrayBuffer = target;
     }
 }
 
 void WebGLBuffer::clearCachedMaxIndices()
 {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTheme.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderTextLineBoxes.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderTheme.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTheme.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  61 #endif
  62 
  63 #if USE(NEW_THEME)
  64 #include &quot;Theme.h&quot;
  65 #endif
  66 
  67 namespace WebCore {
  68 
  69 using namespace HTMLNames;
  70 
  71 static Color&amp; customFocusRingColor()
  72 {
  73     static NeverDestroyed&lt;Color&gt; color;
  74     return color;
  75 }
  76 
  77 RenderTheme::RenderTheme()
  78 {
  79 }
  80 
<span class="line-modified">  81 void RenderTheme::adjustStyle(StyleResolver&amp; styleResolver, RenderStyle&amp; style, const Element* element, bool UAHasAppearance, const BorderData&amp; border, const FillLayer&amp; background, const Color&amp; backgroundColor)</span>
  82 {
  83     // Force inline and table display styles to be inline-block (except for table- which is block)
  84     ControlPart part = style.appearance();
  85     if (style.display() == DisplayType::Inline || style.display() == DisplayType::InlineTable || style.display() == DisplayType::TableRowGroup
  86         || style.display() == DisplayType::TableHeaderGroup || style.display() == DisplayType::TableFooterGroup
  87         || style.display() == DisplayType::TableRow || style.display() == DisplayType::TableColumnGroup || style.display() == DisplayType::TableColumn
  88         || style.display() == DisplayType::TableCell || style.display() == DisplayType::TableCaption)
  89         style.setDisplay(DisplayType::InlineBlock);
<span class="line-modified">  90     else if (style.display() == DisplayType::Compact || style.display() == DisplayType::ListItem || style.display() == DisplayType::Table)</span>
  91         style.setDisplay(DisplayType::Block);
  92 
<span class="line-modified">  93     if (UAHasAppearance &amp;&amp; isControlStyled(style, border, background, backgroundColor)) {</span>
  94         switch (part) {
  95         case MenulistPart:
  96             style.setAppearance(MenulistButtonPart);
  97             part = MenulistButtonPart;
  98             break;
  99         case TextFieldPart:
<span class="line-modified"> 100             adjustTextFieldStyle(styleResolver, style, element);</span>
 101             FALLTHROUGH;
 102         default:
 103             style.setAppearance(NoControlPart);
 104             break;
 105         }
 106     }
 107 
 108     if (!style.hasAppearance())
 109         return;
 110 
 111     // Never support box-shadow on native controls.
 112     style.setBoxShadow(nullptr);
 113 
 114 #if USE(NEW_THEME)
 115     switch (part) {
 116     case CheckboxPart:
 117     case InnerSpinButtonPart:
 118     case RadioPart:
 119     case PushButtonPart:
 120     case SquareButtonPart:
</pre>
<hr />
<pre>
 183             // If overriding the specified font with the theme font, also override the line height with the standard line height.
 184             style.setLineHeight(RenderStyle::initialLineHeight());
 185             if (style.setFontDescription(WTFMove(themeFont.value())))
 186                 style.fontCascade().update(nullptr);
 187         }
 188 
 189         // Special style that tells enabled default buttons in active windows to use the ActiveButtonText color.
 190         // The active window part of the test has to be done at paint time since it&#39;s not triggered by a style change.
 191         style.setInsideDefaultButton(part == DefaultButtonPart &amp;&amp; element &amp;&amp; !element-&gt;isDisabledFormControl());
 192         break;
 193     }
 194     default:
 195         break;
 196     }
 197 #endif
 198 
 199     // Call the appropriate style adjustment method based off the appearance value.
 200     switch (style.appearance()) {
 201 #if !USE(NEW_THEME)
 202     case CheckboxPart:
<span class="line-modified"> 203         return adjustCheckboxStyle(styleResolver, style, element);</span>
 204     case RadioPart:
<span class="line-modified"> 205         return adjustRadioStyle(styleResolver, style, element);</span>
 206     case PushButtonPart:
 207     case SquareButtonPart:
 208 #if ENABLE(INPUT_TYPE_COLOR)
 209     case ColorWellPart:
 210 #endif
 211     case DefaultButtonPart:
 212     case ButtonPart:
<span class="line-modified"> 213         return adjustButtonStyle(styleResolver, style, element);</span>
 214     case InnerSpinButtonPart:
<span class="line-modified"> 215         return adjustInnerSpinButtonStyle(styleResolver, style, element);</span>
 216 #endif
 217     case TextFieldPart:
<span class="line-modified"> 218         return adjustTextFieldStyle(styleResolver, style, element);</span>
 219     case TextAreaPart:
<span class="line-modified"> 220         return adjustTextAreaStyle(styleResolver, style, element);</span>
 221     case MenulistPart:
<span class="line-modified"> 222         return adjustMenuListStyle(styleResolver, style, element);</span>
 223     case MenulistButtonPart:
<span class="line-modified"> 224         return adjustMenuListButtonStyle(styleResolver, style, element);</span>
 225     case MediaPlayButtonPart:
 226     case MediaCurrentTimePart:
 227     case MediaTimeRemainingPart:
 228     case MediaEnterFullscreenButtonPart:
 229     case MediaExitFullscreenButtonPart:
 230     case MediaMuteButtonPart:
 231     case MediaVolumeSliderContainerPart:
<span class="line-modified"> 232         return adjustMediaControlStyle(styleResolver, style, element);</span>
 233     case MediaSliderPart:
 234     case MediaVolumeSliderPart:
 235     case MediaFullScreenVolumeSliderPart:
 236     case SliderHorizontalPart:
 237     case SliderVerticalPart:
<span class="line-modified"> 238         return adjustSliderTrackStyle(styleResolver, style, element);</span>
 239     case SliderThumbHorizontalPart:
 240     case SliderThumbVerticalPart:
<span class="line-modified"> 241         return adjustSliderThumbStyle(styleResolver, style, element);</span>
 242     case SearchFieldPart:
<span class="line-modified"> 243         return adjustSearchFieldStyle(styleResolver, style, element);</span>
 244     case SearchFieldCancelButtonPart:
<span class="line-modified"> 245         return adjustSearchFieldCancelButtonStyle(styleResolver, style, element);</span>
 246     case SearchFieldDecorationPart:
<span class="line-modified"> 247         return adjustSearchFieldDecorationPartStyle(styleResolver, style, element);</span>
 248     case SearchFieldResultsDecorationPart:
<span class="line-modified"> 249         return adjustSearchFieldResultsDecorationPartStyle(styleResolver, style, element);</span>
 250     case SearchFieldResultsButtonPart:
<span class="line-modified"> 251         return adjustSearchFieldResultsButtonStyle(styleResolver, style, element);</span>
 252     case ProgressBarPart:
<span class="line-modified"> 253         return adjustProgressBarStyle(styleResolver, style, element);</span>
 254 #if ENABLE(METER_ELEMENT)
 255     case MeterPart:
 256     case RelevancyLevelIndicatorPart:
 257     case ContinuousCapacityLevelIndicatorPart:
 258     case DiscreteCapacityLevelIndicatorPart:
 259     case RatingLevelIndicatorPart:
<span class="line-modified"> 260         return adjustMeterStyle(styleResolver, style, element);</span>
 261 #endif
 262 #if ENABLE(SERVICE_CONTROLS)
 263     case ImageControlsButtonPart:
 264         break;
 265 #endif
 266     case CapsLockIndicatorPart:
<span class="line-modified"> 267         return adjustCapsLockIndicatorStyle(styleResolver, style, element);</span>
 268 #if ENABLE(APPLE_PAY)
 269     case ApplePayButtonPart:
<span class="line-modified"> 270         return adjustApplePayButtonStyle(styleResolver, style, element);</span>
 271 #endif
 272 #if ENABLE(ATTACHMENT_ELEMENT)
 273     case AttachmentPart:
 274     case BorderlessAttachmentPart:
<span class="line-modified"> 275         return adjustAttachmentStyle(styleResolver, style, element);</span>
 276 #endif
 277 #if ENABLE(DATALIST_ELEMENT)
 278     case ListButtonPart:
<span class="line-modified"> 279         return adjustListButtonStyle(styleResolver, style, element);</span>
 280 #endif
 281     default:
 282         break;
 283     }
 284 }
 285 
 286 bool RenderTheme::paint(const RenderBox&amp; box, ControlStates&amp; controlStates, const PaintInfo&amp; paintInfo, const LayoutRect&amp; rect)
 287 {
 288     // If painting is disabled, but we aren&#39;t updating control tints, then just bail.
 289     // If we are updating control tints, just schedule a repaint if the theme supports tinting
 290     // for that control.
 291     if (paintInfo.context().invalidatingControlTints()) {
 292         if (controlSupportsTints(box))
 293             box.repaint();
 294         return false;
 295     }
 296     if (paintInfo.context().paintingDisabled())
 297         return false;
 298 
 299     if (UNLIKELY(!paintInfo.context().hasPlatformContext()))
</pre>
<hr />
<pre>
 713 {
 714     return platformInactiveSelectionForegroundColor(options);
 715 }
 716 
 717 int RenderTheme::baselinePosition(const RenderBox&amp; box) const
 718 {
 719 #if USE(NEW_THEME)
 720     return box.height() + box.marginTop() + Theme::singleton().baselinePositionAdjustment(box.style().appearance()) * box.style().effectiveZoom();
 721 #else
 722     return box.height() + box.marginTop();
 723 #endif
 724 }
 725 
 726 bool RenderTheme::isControlContainer(ControlPart appearance) const
 727 {
 728     // There are more leaves than this, but we&#39;ll patch this function as we add support for
 729     // more controls.
 730     return appearance != CheckboxPart &amp;&amp; appearance != RadioPart;
 731 }
 732 
<span class="line-modified"> 733 bool RenderTheme::isControlStyled(const RenderStyle&amp; style, const BorderData&amp; border, const FillLayer&amp; background, const Color&amp; backgroundColor) const</span>
 734 {
 735     switch (style.appearance()) {
 736     case PushButtonPart:
 737     case SquareButtonPart:
 738 #if ENABLE(INPUT_TYPE_COLOR)
 739     case ColorWellPart:
 740 #endif
 741     case DefaultButtonPart:
 742     case ButtonPart:
 743     case ListboxPart:
 744     case MenulistPart:
 745     case ProgressBarPart:
 746     case MeterPart:
 747     case RelevancyLevelIndicatorPart:
 748     case ContinuousCapacityLevelIndicatorPart:
 749     case DiscreteCapacityLevelIndicatorPart:
 750     case RatingLevelIndicatorPart:
 751     // FIXME: SearchFieldPart should be included here when making search fields style-able.
 752     case TextFieldPart:
 753     case TextAreaPart:
 754         // Test the style to see if the UA border and background match.
<span class="line-modified"> 755         return style.border() != border</span>
<span class="line-modified"> 756             || style.backgroundLayers() != background</span>
<span class="line-modified"> 757             || !style.backgroundColorEqualsToColorIgnoringVisited(backgroundColor);</span>
 758     default:
 759         return false;
 760     }
 761 }
 762 
 763 void RenderTheme::adjustRepaintRect(const RenderObject&amp; renderer, FloatRect&amp; rect)
 764 {
 765 #if USE(NEW_THEME)
 766     ControlStates states(extractControlStatesForRenderer(renderer));
 767     Theme::singleton().inflateControlPaintRect(renderer.style().appearance(), states, rect, renderer.style().effectiveZoom());
 768 #else
 769     UNUSED_PARAM(renderer);
 770     UNUSED_PARAM(rect);
 771 #endif
 772 }
 773 
 774 bool RenderTheme::supportsFocusRing(const RenderStyle&amp; style) const
 775 {
 776     return (style.hasAppearance() &amp;&amp; style.appearance() != TextFieldPart &amp;&amp; style.appearance() != TextAreaPart &amp;&amp; style.appearance() != MenulistButtonPart &amp;&amp; style.appearance() != ListboxPart);
 777 }
</pre>
<hr />
<pre>
 909         return false;
 910     return downcast&lt;SpinButtonElement&gt;(*node).upDownState() == SpinButtonElement::Up;
 911 }
 912 
 913 bool RenderTheme::isPresenting(const RenderObject&amp; o) const
 914 {
 915     return is&lt;HTMLInputElement&gt;(o.node()) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*o.node()).isPresentingAttachedView();
 916 }
 917 
 918 bool RenderTheme::isDefault(const RenderObject&amp; o) const
 919 {
 920     // A button should only have the default appearance if the page is active
 921     if (!isActive(o))
 922         return false;
 923 
 924     return o.style().appearance() == DefaultButtonPart;
 925 }
 926 
 927 #if !USE(NEW_THEME)
 928 
<span class="line-modified"> 929 void RenderTheme::adjustCheckboxStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const</span>
 930 {
 931     // A summary of the rules for checkbox designed to match WinIE:
 932     // width/height - honored (WinIE actually scales its control for small widths, but lets it overflow for small heights.)
 933     // font-size - not honored (control has no text), but we use it to decide which control size to use.
 934     setCheckboxSize(style);
 935 
 936     // padding - not honored by WinIE, needs to be removed.
 937     style.resetPadding();
 938 
 939     // border - honored by WinIE, but looks terrible (just paints in the control box and turns off the Windows XP theme)
 940     // for now, we will not honor it.
 941     style.resetBorder();
 942 
 943     style.setBoxShadow(nullptr);
 944 }
 945 
<span class="line-modified"> 946 void RenderTheme::adjustRadioStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const</span>
 947 {
 948     // A summary of the rules for checkbox designed to match WinIE:
 949     // width/height - honored (WinIE actually scales its control for small widths, but lets it overflow for small heights.)
 950     // font-size - not honored (control has no text), but we use it to decide which control size to use.
 951     setRadioSize(style);
 952 
 953     // padding - not honored by WinIE, needs to be removed.
 954     style.resetPadding();
 955 
 956     // border - honored by WinIE, but looks terrible (just paints in the control box and turns off the Windows XP theme)
 957     // for now, we will not honor it.
 958     style.resetBorder();
 959 
 960     style.setBoxShadow(nullptr);
 961 }
 962 
<span class="line-modified"> 963 void RenderTheme::adjustButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const</span>
 964 {
 965     // Most platforms will completely honor all CSS, and so we have no need to
 966     // adjust the style at all by default. We will still allow the theme a crack
 967     // at setting up a desired vertical size.
 968     setButtonSize(style);
 969 }
 970 
<span class="line-modified"> 971 void RenderTheme::adjustInnerSpinButtonStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
 972 {
 973 }
 974 #endif
 975 
<span class="line-modified"> 976 void RenderTheme::adjustTextFieldStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
 977 {
 978 }
 979 
<span class="line-modified"> 980 void RenderTheme::adjustTextAreaStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
 981 {
 982 }
 983 
<span class="line-modified"> 984 void RenderTheme::adjustMenuListStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
 985 {
 986 }
 987 
 988 #if ENABLE(METER_ELEMENT)
 989 
<span class="line-modified"> 990 void RenderTheme::adjustMeterStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const</span>
 991 {
 992     style.setBoxShadow(nullptr);
 993 }
 994 
 995 IntSize RenderTheme::meterSizeForBounds(const RenderMeter&amp;, const IntRect&amp; bounds) const
 996 {
 997     return bounds.size();
 998 }
 999 
1000 bool RenderTheme::supportsMeter(ControlPart) const
1001 {
1002     return false;
1003 }
1004 
1005 bool RenderTheme::paintMeter(const RenderObject&amp;, const PaintInfo&amp;, const IntRect&amp;)
1006 {
1007     return true;
1008 }
1009 
1010 #endif // METER_ELEMENT
1011 
<span class="line-modified">1012 void RenderTheme::adjustCapsLockIndicatorStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
1013 {
1014 }
1015 
1016 bool RenderTheme::paintCapsLockIndicator(const RenderObject&amp;, const PaintInfo&amp;, const IntRect&amp;)
1017 {
1018     return false;
1019 }
1020 
1021 #if ENABLE(ATTACHMENT_ELEMENT)
1022 
<span class="line-modified">1023 void RenderTheme::adjustAttachmentStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
1024 {
1025 }
1026 
1027 bool RenderTheme::paintAttachment(const RenderObject&amp;, const PaintInfo&amp;, const IntRect&amp;)
1028 {
1029     return false;
1030 }
1031 
1032 #endif
1033 
1034 #if ENABLE(INPUT_TYPE_COLOR)
1035 
1036 String RenderTheme::colorInputStyleSheet() const
1037 {
1038     ASSERT(RuntimeEnabledFeatures::sharedFeatures().inputTypeColorEnabled());
1039     return &quot;input[type=\&quot;color\&quot;] { -webkit-appearance: color-well; width: 44px; height: 23px; outline: none; } &quot;_s;
1040 }
1041 
1042 #endif // ENABLE(INPUT_TYPE_COLOR)
1043 
1044 #if ENABLE(DATALIST_ELEMENT)
1045 
1046 String RenderTheme::dataListStyleSheet() const
1047 {
1048     ASSERT(RuntimeEnabledFeatures::sharedFeatures().dataListElementEnabled());
1049     return &quot;datalist { display: none; }&quot;_s;
1050 }
1051 
<span class="line-modified">1052 void RenderTheme::adjustListButtonStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
1053 {
1054 }
1055 
1056 LayoutUnit RenderTheme::sliderTickSnappingThreshold() const
1057 {
1058     return 0;
1059 }
1060 
1061 void RenderTheme::paintSliderTicks(const RenderObject&amp; o, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1062 {
1063     if (!is&lt;HTMLInputElement&gt;(o.node()))
1064         return;
1065 
1066     auto&amp; input = downcast&lt;HTMLInputElement&gt;(*o.node());
1067 
1068     if (!input.list())
1069         return;
1070 
1071     auto&amp; dataList = downcast&lt;HTMLDataListElement&gt;(*input.list());
1072 
</pre>
<hr />
<pre>
1133         if (isHorizontal)
1134             tickRect.setX(tickPosition);
1135         else
1136             tickRect.setY(tickPosition);
1137         paintInfo.context().fillRect(tickRect);
1138     }
1139 }
1140 
1141 #endif
1142 
1143 Seconds RenderTheme::animationRepeatIntervalForProgressBar(RenderProgress&amp;) const
1144 {
1145     return 0_s;
1146 }
1147 
1148 Seconds RenderTheme::animationDurationForProgressBar(RenderProgress&amp;) const
1149 {
1150     return 0_s;
1151 }
1152 
<span class="line-modified">1153 void RenderTheme::adjustProgressBarStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
1154 {
1155 }
1156 
1157 IntRect RenderTheme::progressBarRectForBounds(const RenderObject&amp;, const IntRect&amp; bounds) const
1158 {
1159     return bounds;
1160 }
1161 
1162 bool RenderTheme::shouldHaveSpinButton(const HTMLInputElement&amp; inputElement) const
1163 {
1164     return inputElement.isSteppable() &amp;&amp; !inputElement.isRangeControl();
1165 }
1166 
1167 bool RenderTheme::shouldHaveCapsLockIndicator(const HTMLInputElement&amp;) const
1168 {
1169     return false;
1170 }
1171 
<span class="line-modified">1172 void RenderTheme::adjustMenuListButtonStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
1173 {
1174 }
1175 
<span class="line-modified">1176 void RenderTheme::adjustMediaControlStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
1177 {
1178 }
1179 
<span class="line-modified">1180 void RenderTheme::adjustSliderTrackStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
1181 {
1182 }
1183 
<span class="line-modified">1184 void RenderTheme::adjustSliderThumbStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element* element) const</span>
1185 {
1186     adjustSliderThumbSize(style, element);
1187 }
1188 
1189 void RenderTheme::adjustSliderThumbSize(RenderStyle&amp;, const Element*) const
1190 {
1191 }
1192 
<span class="line-modified">1193 void RenderTheme::adjustSearchFieldStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
1194 {
1195 }
1196 
<span class="line-modified">1197 void RenderTheme::adjustSearchFieldCancelButtonStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
1198 {
1199 }
1200 
<span class="line-modified">1201 void RenderTheme::adjustSearchFieldDecorationPartStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
1202 {
1203 }
1204 
<span class="line-modified">1205 void RenderTheme::adjustSearchFieldResultsDecorationPartStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
1206 {
1207 }
1208 
<span class="line-modified">1209 void RenderTheme::adjustSearchFieldResultsButtonStyle(StyleResolver&amp;, RenderStyle&amp;, const Element*) const</span>
1210 {
1211 }
1212 
1213 void RenderTheme::purgeCaches()
1214 {
1215     m_colorCacheMap.clear();
1216 }
1217 
1218 void RenderTheme::platformColorsDidChange()
1219 {
1220     m_colorCacheMap.clear();
1221 
1222     Page::updateStyleForAllPagesAfterGlobalChangeInEnvironment();
1223 }
1224 
1225 auto RenderTheme::colorCache(OptionSet&lt;StyleColor::Options&gt; options) const -&gt; ColorCache&amp;
1226 {
1227     auto optionsIgnoringVisitedLink = options;
1228     optionsIgnoringVisitedLink.remove(StyleColor::Options::ForVisitedLink);
1229 
</pre>
<hr />
<pre>
1268         return defaultDescription;
1269     default:
1270         ASSERT_NOT_REACHED();
1271         return defaultDescription;
1272     }
1273 }
1274 
1275 void RenderTheme::systemFont(CSSValueID systemFontID, FontCascadeDescription&amp; fontDescription) const
1276 {
1277     fontDescription = cachedSystemFontDescription(systemFontID);
1278     if (fontDescription.isAbsoluteSize())
1279         return;
1280 
1281     updateCachedSystemFontDescription(systemFontID, fontDescription);
1282 }
1283 
1284 Color RenderTheme::systemColor(CSSValueID cssValueId, OptionSet&lt;StyleColor::Options&gt; options) const
1285 {
1286     switch (cssValueId) {
1287     case CSSValueWebkitLink:
<span class="line-modified">1288         return options.contains(StyleColor::Options::ForVisitedLink) ? 0xFF551A8B : 0xFF0000EE;</span>
1289     case CSSValueWebkitActivelink:
<span class="line-modified">1290         return 0xFFFF0000;</span>
1291     case CSSValueActiveborder:
<span class="line-modified">1292         return 0xFFFFFFFF;</span>
1293     case CSSValueActivebuttontext:
<span class="line-modified">1294         return 0xFF000000;</span>
1295     case CSSValueActivecaption:
<span class="line-modified">1296         return 0xFFCCCCCC;</span>
1297     case CSSValueAppworkspace:
<span class="line-modified">1298         return 0xFFFFFFFF;</span>
1299     case CSSValueBackground:
<span class="line-modified">1300         return 0xFF6363CE;</span>
1301     case CSSValueButtonface:
<span class="line-modified">1302         return 0xFFC0C0C0;</span>
1303     case CSSValueButtonhighlight:
<span class="line-modified">1304         return 0xFFDDDDDD;</span>
1305     case CSSValueButtonshadow:
<span class="line-modified">1306         return 0xFF888888;</span>
1307     case CSSValueButtontext:
<span class="line-modified">1308         return 0xFF000000;</span>
1309     case CSSValueCaptiontext:
<span class="line-modified">1310         return 0xFF000000;</span>
1311     case CSSValueGraytext:
<span class="line-modified">1312         return 0xFF808080;</span>
1313     case CSSValueHighlight:
<span class="line-modified">1314         return 0xFFB5D5FF;</span>
1315     case CSSValueHighlighttext:
<span class="line-modified">1316         return 0xFF000000;</span>
1317     case CSSValueInactiveborder:
<span class="line-modified">1318         return 0xFFFFFFFF;</span>
1319     case CSSValueInactivecaption:
<span class="line-modified">1320         return 0xFFFFFFFF;</span>
1321     case CSSValueInactivecaptiontext:
<span class="line-modified">1322         return 0xFF7F7F7F;</span>
1323     case CSSValueInfobackground:
<span class="line-modified">1324         return 0xFFFBFCC5;</span>
1325     case CSSValueInfotext:
<span class="line-modified">1326         return 0xFF000000;</span>
1327     case CSSValueMenu:
<span class="line-modified">1328         return 0xFFC0C0C0;</span>
1329     case CSSValueMenutext:
<span class="line-modified">1330         return 0xFF000000;</span>
1331     case CSSValueScrollbar:
<span class="line-modified">1332         return 0xFFFFFFFF;</span>
1333     case CSSValueText:
<span class="line-modified">1334         return 0xFF000000;</span>
1335     case CSSValueThreeddarkshadow:
<span class="line-modified">1336         return 0xFF666666;</span>
1337     case CSSValueThreedface:
<span class="line-modified">1338         return 0xFFC0C0C0;</span>
1339     case CSSValueThreedhighlight:
<span class="line-modified">1340         return 0xFFDDDDDD;</span>
1341     case CSSValueThreedlightshadow:
<span class="line-modified">1342         return 0xFFC0C0C0;</span>
1343     case CSSValueThreedshadow:
<span class="line-modified">1344         return 0xFF888888;</span>
1345     case CSSValueWindow:
<span class="line-modified">1346         return 0xFFFFFFFF;</span>
1347     case CSSValueWindowframe:
<span class="line-modified">1348         return 0xFFCCCCCC;</span>
1349     case CSSValueWindowtext:
<span class="line-modified">1350         return 0xFF000000;</span>
1351     default:
<span class="line-modified">1352         break;</span>
1353     }
<span class="line-removed">1354     return Color();</span>
1355 }
1356 
1357 Color RenderTheme::activeTextSearchHighlightColor(OptionSet&lt;StyleColor::Options&gt; options) const
1358 {
1359     auto&amp; cache = colorCache(options);
1360     if (!cache.activeTextSearchHighlightColor.isValid())
1361         cache.activeTextSearchHighlightColor = platformActiveTextSearchHighlightColor(options);
1362     return cache.activeTextSearchHighlightColor;
1363 }
1364 
1365 Color RenderTheme::inactiveTextSearchHighlightColor(OptionSet&lt;StyleColor::Options&gt; options) const
1366 {
1367     auto&amp; cache = colorCache(options);
1368     if (!cache.inactiveTextSearchHighlightColor.isValid())
1369         cache.inactiveTextSearchHighlightColor = platformInactiveTextSearchHighlightColor(options);
1370     return cache.inactiveTextSearchHighlightColor;
1371 }
1372 
1373 Color RenderTheme::platformActiveTextSearchHighlightColor(OptionSet&lt;StyleColor::Options&gt;) const
1374 {
</pre>
</td>
<td>
<hr />
<pre>
  61 #endif
  62 
  63 #if USE(NEW_THEME)
  64 #include &quot;Theme.h&quot;
  65 #endif
  66 
  67 namespace WebCore {
  68 
  69 using namespace HTMLNames;
  70 
  71 static Color&amp; customFocusRingColor()
  72 {
  73     static NeverDestroyed&lt;Color&gt; color;
  74     return color;
  75 }
  76 
  77 RenderTheme::RenderTheme()
  78 {
  79 }
  80 
<span class="line-modified">  81 void RenderTheme::adjustStyle(RenderStyle&amp; style, const Element* element, const RenderStyle* userAgentAppearanceStyle)</span>
  82 {
  83     // Force inline and table display styles to be inline-block (except for table- which is block)
  84     ControlPart part = style.appearance();
  85     if (style.display() == DisplayType::Inline || style.display() == DisplayType::InlineTable || style.display() == DisplayType::TableRowGroup
  86         || style.display() == DisplayType::TableHeaderGroup || style.display() == DisplayType::TableFooterGroup
  87         || style.display() == DisplayType::TableRow || style.display() == DisplayType::TableColumnGroup || style.display() == DisplayType::TableColumn
  88         || style.display() == DisplayType::TableCell || style.display() == DisplayType::TableCaption)
  89         style.setDisplay(DisplayType::InlineBlock);
<span class="line-modified">  90     else if (style.display() == DisplayType::ListItem || style.display() == DisplayType::Table)</span>
  91         style.setDisplay(DisplayType::Block);
  92 
<span class="line-modified">  93     if (userAgentAppearanceStyle &amp;&amp; isControlStyled(style, *userAgentAppearanceStyle)) {</span>
  94         switch (part) {
  95         case MenulistPart:
  96             style.setAppearance(MenulistButtonPart);
  97             part = MenulistButtonPart;
  98             break;
  99         case TextFieldPart:
<span class="line-modified"> 100             adjustTextFieldStyle(style, element);</span>
 101             FALLTHROUGH;
 102         default:
 103             style.setAppearance(NoControlPart);
 104             break;
 105         }
 106     }
 107 
 108     if (!style.hasAppearance())
 109         return;
 110 
 111     // Never support box-shadow on native controls.
 112     style.setBoxShadow(nullptr);
 113 
 114 #if USE(NEW_THEME)
 115     switch (part) {
 116     case CheckboxPart:
 117     case InnerSpinButtonPart:
 118     case RadioPart:
 119     case PushButtonPart:
 120     case SquareButtonPart:
</pre>
<hr />
<pre>
 183             // If overriding the specified font with the theme font, also override the line height with the standard line height.
 184             style.setLineHeight(RenderStyle::initialLineHeight());
 185             if (style.setFontDescription(WTFMove(themeFont.value())))
 186                 style.fontCascade().update(nullptr);
 187         }
 188 
 189         // Special style that tells enabled default buttons in active windows to use the ActiveButtonText color.
 190         // The active window part of the test has to be done at paint time since it&#39;s not triggered by a style change.
 191         style.setInsideDefaultButton(part == DefaultButtonPart &amp;&amp; element &amp;&amp; !element-&gt;isDisabledFormControl());
 192         break;
 193     }
 194     default:
 195         break;
 196     }
 197 #endif
 198 
 199     // Call the appropriate style adjustment method based off the appearance value.
 200     switch (style.appearance()) {
 201 #if !USE(NEW_THEME)
 202     case CheckboxPart:
<span class="line-modified"> 203         return adjustCheckboxStyle(style, element);</span>
 204     case RadioPart:
<span class="line-modified"> 205         return adjustRadioStyle(style, element);</span>
 206     case PushButtonPart:
 207     case SquareButtonPart:
 208 #if ENABLE(INPUT_TYPE_COLOR)
 209     case ColorWellPart:
 210 #endif
 211     case DefaultButtonPart:
 212     case ButtonPart:
<span class="line-modified"> 213         return adjustButtonStyle(style, element);</span>
 214     case InnerSpinButtonPart:
<span class="line-modified"> 215         return adjustInnerSpinButtonStyle(style, element);</span>
 216 #endif
 217     case TextFieldPart:
<span class="line-modified"> 218         return adjustTextFieldStyle(style, element);</span>
 219     case TextAreaPart:
<span class="line-modified"> 220         return adjustTextAreaStyle(style, element);</span>
 221     case MenulistPart:
<span class="line-modified"> 222         return adjustMenuListStyle(style, element);</span>
 223     case MenulistButtonPart:
<span class="line-modified"> 224         return adjustMenuListButtonStyle(style, element);</span>
 225     case MediaPlayButtonPart:
 226     case MediaCurrentTimePart:
 227     case MediaTimeRemainingPart:
 228     case MediaEnterFullscreenButtonPart:
 229     case MediaExitFullscreenButtonPart:
 230     case MediaMuteButtonPart:
 231     case MediaVolumeSliderContainerPart:
<span class="line-modified"> 232         return adjustMediaControlStyle(style, element);</span>
 233     case MediaSliderPart:
 234     case MediaVolumeSliderPart:
 235     case MediaFullScreenVolumeSliderPart:
 236     case SliderHorizontalPart:
 237     case SliderVerticalPart:
<span class="line-modified"> 238         return adjustSliderTrackStyle(style, element);</span>
 239     case SliderThumbHorizontalPart:
 240     case SliderThumbVerticalPart:
<span class="line-modified"> 241         return adjustSliderThumbStyle(style, element);</span>
 242     case SearchFieldPart:
<span class="line-modified"> 243         return adjustSearchFieldStyle(style, element);</span>
 244     case SearchFieldCancelButtonPart:
<span class="line-modified"> 245         return adjustSearchFieldCancelButtonStyle(style, element);</span>
 246     case SearchFieldDecorationPart:
<span class="line-modified"> 247         return adjustSearchFieldDecorationPartStyle(style, element);</span>
 248     case SearchFieldResultsDecorationPart:
<span class="line-modified"> 249         return adjustSearchFieldResultsDecorationPartStyle(style, element);</span>
 250     case SearchFieldResultsButtonPart:
<span class="line-modified"> 251         return adjustSearchFieldResultsButtonStyle(style, element);</span>
 252     case ProgressBarPart:
<span class="line-modified"> 253         return adjustProgressBarStyle(style, element);</span>
 254 #if ENABLE(METER_ELEMENT)
 255     case MeterPart:
 256     case RelevancyLevelIndicatorPart:
 257     case ContinuousCapacityLevelIndicatorPart:
 258     case DiscreteCapacityLevelIndicatorPart:
 259     case RatingLevelIndicatorPart:
<span class="line-modified"> 260         return adjustMeterStyle(style, element);</span>
 261 #endif
 262 #if ENABLE(SERVICE_CONTROLS)
 263     case ImageControlsButtonPart:
 264         break;
 265 #endif
 266     case CapsLockIndicatorPart:
<span class="line-modified"> 267         return adjustCapsLockIndicatorStyle(style, element);</span>
 268 #if ENABLE(APPLE_PAY)
 269     case ApplePayButtonPart:
<span class="line-modified"> 270         return adjustApplePayButtonStyle(style, element);</span>
 271 #endif
 272 #if ENABLE(ATTACHMENT_ELEMENT)
 273     case AttachmentPart:
 274     case BorderlessAttachmentPart:
<span class="line-modified"> 275         return adjustAttachmentStyle(style, element);</span>
 276 #endif
 277 #if ENABLE(DATALIST_ELEMENT)
 278     case ListButtonPart:
<span class="line-modified"> 279         return adjustListButtonStyle(style, element);</span>
 280 #endif
 281     default:
 282         break;
 283     }
 284 }
 285 
 286 bool RenderTheme::paint(const RenderBox&amp; box, ControlStates&amp; controlStates, const PaintInfo&amp; paintInfo, const LayoutRect&amp; rect)
 287 {
 288     // If painting is disabled, but we aren&#39;t updating control tints, then just bail.
 289     // If we are updating control tints, just schedule a repaint if the theme supports tinting
 290     // for that control.
 291     if (paintInfo.context().invalidatingControlTints()) {
 292         if (controlSupportsTints(box))
 293             box.repaint();
 294         return false;
 295     }
 296     if (paintInfo.context().paintingDisabled())
 297         return false;
 298 
 299     if (UNLIKELY(!paintInfo.context().hasPlatformContext()))
</pre>
<hr />
<pre>
 713 {
 714     return platformInactiveSelectionForegroundColor(options);
 715 }
 716 
 717 int RenderTheme::baselinePosition(const RenderBox&amp; box) const
 718 {
 719 #if USE(NEW_THEME)
 720     return box.height() + box.marginTop() + Theme::singleton().baselinePositionAdjustment(box.style().appearance()) * box.style().effectiveZoom();
 721 #else
 722     return box.height() + box.marginTop();
 723 #endif
 724 }
 725 
 726 bool RenderTheme::isControlContainer(ControlPart appearance) const
 727 {
 728     // There are more leaves than this, but we&#39;ll patch this function as we add support for
 729     // more controls.
 730     return appearance != CheckboxPart &amp;&amp; appearance != RadioPart;
 731 }
 732 
<span class="line-modified"> 733 bool RenderTheme::isControlStyled(const RenderStyle&amp; style, const RenderStyle&amp; userAgentStyle) const</span>
 734 {
 735     switch (style.appearance()) {
 736     case PushButtonPart:
 737     case SquareButtonPart:
 738 #if ENABLE(INPUT_TYPE_COLOR)
 739     case ColorWellPart:
 740 #endif
 741     case DefaultButtonPart:
 742     case ButtonPart:
 743     case ListboxPart:
 744     case MenulistPart:
 745     case ProgressBarPart:
 746     case MeterPart:
 747     case RelevancyLevelIndicatorPart:
 748     case ContinuousCapacityLevelIndicatorPart:
 749     case DiscreteCapacityLevelIndicatorPart:
 750     case RatingLevelIndicatorPart:
 751     // FIXME: SearchFieldPart should be included here when making search fields style-able.
 752     case TextFieldPart:
 753     case TextAreaPart:
 754         // Test the style to see if the UA border and background match.
<span class="line-modified"> 755         return style.border() != userAgentStyle.border()</span>
<span class="line-modified"> 756             || style.backgroundLayers() != userAgentStyle.backgroundLayers()</span>
<span class="line-modified"> 757             || !style.backgroundColorEqualsToColorIgnoringVisited(userAgentStyle.backgroundColor());</span>
 758     default:
 759         return false;
 760     }
 761 }
 762 
 763 void RenderTheme::adjustRepaintRect(const RenderObject&amp; renderer, FloatRect&amp; rect)
 764 {
 765 #if USE(NEW_THEME)
 766     ControlStates states(extractControlStatesForRenderer(renderer));
 767     Theme::singleton().inflateControlPaintRect(renderer.style().appearance(), states, rect, renderer.style().effectiveZoom());
 768 #else
 769     UNUSED_PARAM(renderer);
 770     UNUSED_PARAM(rect);
 771 #endif
 772 }
 773 
 774 bool RenderTheme::supportsFocusRing(const RenderStyle&amp; style) const
 775 {
 776     return (style.hasAppearance() &amp;&amp; style.appearance() != TextFieldPart &amp;&amp; style.appearance() != TextAreaPart &amp;&amp; style.appearance() != MenulistButtonPart &amp;&amp; style.appearance() != ListboxPart);
 777 }
</pre>
<hr />
<pre>
 909         return false;
 910     return downcast&lt;SpinButtonElement&gt;(*node).upDownState() == SpinButtonElement::Up;
 911 }
 912 
 913 bool RenderTheme::isPresenting(const RenderObject&amp; o) const
 914 {
 915     return is&lt;HTMLInputElement&gt;(o.node()) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*o.node()).isPresentingAttachedView();
 916 }
 917 
 918 bool RenderTheme::isDefault(const RenderObject&amp; o) const
 919 {
 920     // A button should only have the default appearance if the page is active
 921     if (!isActive(o))
 922         return false;
 923 
 924     return o.style().appearance() == DefaultButtonPart;
 925 }
 926 
 927 #if !USE(NEW_THEME)
 928 
<span class="line-modified"> 929 void RenderTheme::adjustCheckboxStyle(RenderStyle&amp; style, const Element*) const</span>
 930 {
 931     // A summary of the rules for checkbox designed to match WinIE:
 932     // width/height - honored (WinIE actually scales its control for small widths, but lets it overflow for small heights.)
 933     // font-size - not honored (control has no text), but we use it to decide which control size to use.
 934     setCheckboxSize(style);
 935 
 936     // padding - not honored by WinIE, needs to be removed.
 937     style.resetPadding();
 938 
 939     // border - honored by WinIE, but looks terrible (just paints in the control box and turns off the Windows XP theme)
 940     // for now, we will not honor it.
 941     style.resetBorder();
 942 
 943     style.setBoxShadow(nullptr);
 944 }
 945 
<span class="line-modified"> 946 void RenderTheme::adjustRadioStyle(RenderStyle&amp; style, const Element*) const</span>
 947 {
 948     // A summary of the rules for checkbox designed to match WinIE:
 949     // width/height - honored (WinIE actually scales its control for small widths, but lets it overflow for small heights.)
 950     // font-size - not honored (control has no text), but we use it to decide which control size to use.
 951     setRadioSize(style);
 952 
 953     // padding - not honored by WinIE, needs to be removed.
 954     style.resetPadding();
 955 
 956     // border - honored by WinIE, but looks terrible (just paints in the control box and turns off the Windows XP theme)
 957     // for now, we will not honor it.
 958     style.resetBorder();
 959 
 960     style.setBoxShadow(nullptr);
 961 }
 962 
<span class="line-modified"> 963 void RenderTheme::adjustButtonStyle(RenderStyle&amp; style, const Element*) const</span>
 964 {
 965     // Most platforms will completely honor all CSS, and so we have no need to
 966     // adjust the style at all by default. We will still allow the theme a crack
 967     // at setting up a desired vertical size.
 968     setButtonSize(style);
 969 }
 970 
<span class="line-modified"> 971 void RenderTheme::adjustInnerSpinButtonStyle(RenderStyle&amp;, const Element*) const</span>
 972 {
 973 }
 974 #endif
 975 
<span class="line-modified"> 976 void RenderTheme::adjustTextFieldStyle(RenderStyle&amp;, const Element*) const</span>
 977 {
 978 }
 979 
<span class="line-modified"> 980 void RenderTheme::adjustTextAreaStyle(RenderStyle&amp;, const Element*) const</span>
 981 {
 982 }
 983 
<span class="line-modified"> 984 void RenderTheme::adjustMenuListStyle(RenderStyle&amp;, const Element*) const</span>
 985 {
 986 }
 987 
 988 #if ENABLE(METER_ELEMENT)
 989 
<span class="line-modified"> 990 void RenderTheme::adjustMeterStyle(RenderStyle&amp; style, const Element*) const</span>
 991 {
 992     style.setBoxShadow(nullptr);
 993 }
 994 
 995 IntSize RenderTheme::meterSizeForBounds(const RenderMeter&amp;, const IntRect&amp; bounds) const
 996 {
 997     return bounds.size();
 998 }
 999 
1000 bool RenderTheme::supportsMeter(ControlPart) const
1001 {
1002     return false;
1003 }
1004 
1005 bool RenderTheme::paintMeter(const RenderObject&amp;, const PaintInfo&amp;, const IntRect&amp;)
1006 {
1007     return true;
1008 }
1009 
1010 #endif // METER_ELEMENT
1011 
<span class="line-modified">1012 void RenderTheme::adjustCapsLockIndicatorStyle(RenderStyle&amp;, const Element*) const</span>
1013 {
1014 }
1015 
1016 bool RenderTheme::paintCapsLockIndicator(const RenderObject&amp;, const PaintInfo&amp;, const IntRect&amp;)
1017 {
1018     return false;
1019 }
1020 
1021 #if ENABLE(ATTACHMENT_ELEMENT)
1022 
<span class="line-modified">1023 void RenderTheme::adjustAttachmentStyle(RenderStyle&amp;, const Element*) const</span>
1024 {
1025 }
1026 
1027 bool RenderTheme::paintAttachment(const RenderObject&amp;, const PaintInfo&amp;, const IntRect&amp;)
1028 {
1029     return false;
1030 }
1031 
1032 #endif
1033 
1034 #if ENABLE(INPUT_TYPE_COLOR)
1035 
1036 String RenderTheme::colorInputStyleSheet() const
1037 {
1038     ASSERT(RuntimeEnabledFeatures::sharedFeatures().inputTypeColorEnabled());
1039     return &quot;input[type=\&quot;color\&quot;] { -webkit-appearance: color-well; width: 44px; height: 23px; outline: none; } &quot;_s;
1040 }
1041 
1042 #endif // ENABLE(INPUT_TYPE_COLOR)
1043 
1044 #if ENABLE(DATALIST_ELEMENT)
1045 
1046 String RenderTheme::dataListStyleSheet() const
1047 {
1048     ASSERT(RuntimeEnabledFeatures::sharedFeatures().dataListElementEnabled());
1049     return &quot;datalist { display: none; }&quot;_s;
1050 }
1051 
<span class="line-modified">1052 void RenderTheme::adjustListButtonStyle(RenderStyle&amp;, const Element*) const</span>
1053 {
1054 }
1055 
1056 LayoutUnit RenderTheme::sliderTickSnappingThreshold() const
1057 {
1058     return 0;
1059 }
1060 
1061 void RenderTheme::paintSliderTicks(const RenderObject&amp; o, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1062 {
1063     if (!is&lt;HTMLInputElement&gt;(o.node()))
1064         return;
1065 
1066     auto&amp; input = downcast&lt;HTMLInputElement&gt;(*o.node());
1067 
1068     if (!input.list())
1069         return;
1070 
1071     auto&amp; dataList = downcast&lt;HTMLDataListElement&gt;(*input.list());
1072 
</pre>
<hr />
<pre>
1133         if (isHorizontal)
1134             tickRect.setX(tickPosition);
1135         else
1136             tickRect.setY(tickPosition);
1137         paintInfo.context().fillRect(tickRect);
1138     }
1139 }
1140 
1141 #endif
1142 
1143 Seconds RenderTheme::animationRepeatIntervalForProgressBar(RenderProgress&amp;) const
1144 {
1145     return 0_s;
1146 }
1147 
1148 Seconds RenderTheme::animationDurationForProgressBar(RenderProgress&amp;) const
1149 {
1150     return 0_s;
1151 }
1152 
<span class="line-modified">1153 void RenderTheme::adjustProgressBarStyle(RenderStyle&amp;, const Element*) const</span>
1154 {
1155 }
1156 
1157 IntRect RenderTheme::progressBarRectForBounds(const RenderObject&amp;, const IntRect&amp; bounds) const
1158 {
1159     return bounds;
1160 }
1161 
1162 bool RenderTheme::shouldHaveSpinButton(const HTMLInputElement&amp; inputElement) const
1163 {
1164     return inputElement.isSteppable() &amp;&amp; !inputElement.isRangeControl();
1165 }
1166 
1167 bool RenderTheme::shouldHaveCapsLockIndicator(const HTMLInputElement&amp;) const
1168 {
1169     return false;
1170 }
1171 
<span class="line-modified">1172 void RenderTheme::adjustMenuListButtonStyle(RenderStyle&amp;, const Element*) const</span>
1173 {
1174 }
1175 
<span class="line-modified">1176 void RenderTheme::adjustMediaControlStyle(RenderStyle&amp;, const Element*) const</span>
1177 {
1178 }
1179 
<span class="line-modified">1180 void RenderTheme::adjustSliderTrackStyle(RenderStyle&amp;, const Element*) const</span>
1181 {
1182 }
1183 
<span class="line-modified">1184 void RenderTheme::adjustSliderThumbStyle(RenderStyle&amp; style, const Element* element) const</span>
1185 {
1186     adjustSliderThumbSize(style, element);
1187 }
1188 
1189 void RenderTheme::adjustSliderThumbSize(RenderStyle&amp;, const Element*) const
1190 {
1191 }
1192 
<span class="line-modified">1193 void RenderTheme::adjustSearchFieldStyle(RenderStyle&amp;, const Element*) const</span>
1194 {
1195 }
1196 
<span class="line-modified">1197 void RenderTheme::adjustSearchFieldCancelButtonStyle(RenderStyle&amp;, const Element*) const</span>
1198 {
1199 }
1200 
<span class="line-modified">1201 void RenderTheme::adjustSearchFieldDecorationPartStyle(RenderStyle&amp;, const Element*) const</span>
1202 {
1203 }
1204 
<span class="line-modified">1205 void RenderTheme::adjustSearchFieldResultsDecorationPartStyle(RenderStyle&amp;, const Element*) const</span>
1206 {
1207 }
1208 
<span class="line-modified">1209 void RenderTheme::adjustSearchFieldResultsButtonStyle(RenderStyle&amp;, const Element*) const</span>
1210 {
1211 }
1212 
1213 void RenderTheme::purgeCaches()
1214 {
1215     m_colorCacheMap.clear();
1216 }
1217 
1218 void RenderTheme::platformColorsDidChange()
1219 {
1220     m_colorCacheMap.clear();
1221 
1222     Page::updateStyleForAllPagesAfterGlobalChangeInEnvironment();
1223 }
1224 
1225 auto RenderTheme::colorCache(OptionSet&lt;StyleColor::Options&gt; options) const -&gt; ColorCache&amp;
1226 {
1227     auto optionsIgnoringVisitedLink = options;
1228     optionsIgnoringVisitedLink.remove(StyleColor::Options::ForVisitedLink);
1229 
</pre>
<hr />
<pre>
1268         return defaultDescription;
1269     default:
1270         ASSERT_NOT_REACHED();
1271         return defaultDescription;
1272     }
1273 }
1274 
1275 void RenderTheme::systemFont(CSSValueID systemFontID, FontCascadeDescription&amp; fontDescription) const
1276 {
1277     fontDescription = cachedSystemFontDescription(systemFontID);
1278     if (fontDescription.isAbsoluteSize())
1279         return;
1280 
1281     updateCachedSystemFontDescription(systemFontID, fontDescription);
1282 }
1283 
1284 Color RenderTheme::systemColor(CSSValueID cssValueId, OptionSet&lt;StyleColor::Options&gt; options) const
1285 {
1286     switch (cssValueId) {
1287     case CSSValueWebkitLink:
<span class="line-modified">1288         return options.contains(StyleColor::Options::ForVisitedLink) ? SimpleColor { 0xFF551A8B } : SimpleColor { 0xFF0000EE };</span>
1289     case CSSValueWebkitActivelink:
<span class="line-modified">1290         return SimpleColor { 0xFFFF0000 };</span>
1291     case CSSValueActiveborder:
<span class="line-modified">1292         return Color::white;</span>
1293     case CSSValueActivebuttontext:
<span class="line-modified">1294         return Color::black;</span>
1295     case CSSValueActivecaption:
<span class="line-modified">1296         return SimpleColor { 0xFFCCCCCC };</span>
1297     case CSSValueAppworkspace:
<span class="line-modified">1298         return Color::white;</span>
1299     case CSSValueBackground:
<span class="line-modified">1300         return SimpleColor { 0xFF6363CE };</span>
1301     case CSSValueButtonface:
<span class="line-modified">1302         return Color::lightGray;</span>
1303     case CSSValueButtonhighlight:
<span class="line-modified">1304         return SimpleColor { 0xFFDDDDDD };</span>
1305     case CSSValueButtonshadow:
<span class="line-modified">1306         return SimpleColor { 0xFF888888 };</span>
1307     case CSSValueButtontext:
<span class="line-modified">1308         return Color::black;</span>
1309     case CSSValueCaptiontext:
<span class="line-modified">1310         return Color::black;</span>
1311     case CSSValueGraytext:
<span class="line-modified">1312         return SimpleColor { 0xFF808080 };</span>
1313     case CSSValueHighlight:
<span class="line-modified">1314         return SimpleColor { 0xFFB5D5FF };</span>
1315     case CSSValueHighlighttext:
<span class="line-modified">1316         return Color::black;</span>
1317     case CSSValueInactiveborder:
<span class="line-modified">1318         return Color::white;</span>
1319     case CSSValueInactivecaption:
<span class="line-modified">1320         return Color::white;</span>
1321     case CSSValueInactivecaptiontext:
<span class="line-modified">1322         return SimpleColor { 0xFF7F7F7F };</span>
1323     case CSSValueInfobackground:
<span class="line-modified">1324         return SimpleColor { 0xFFFBFCC5 };</span>
1325     case CSSValueInfotext:
<span class="line-modified">1326         return Color::black;</span>
1327     case CSSValueMenu:
<span class="line-modified">1328         return Color::lightGray;</span>
1329     case CSSValueMenutext:
<span class="line-modified">1330         return Color::black;</span>
1331     case CSSValueScrollbar:
<span class="line-modified">1332         return Color::white;</span>
1333     case CSSValueText:
<span class="line-modified">1334         return Color::black;</span>
1335     case CSSValueThreeddarkshadow:
<span class="line-modified">1336         return SimpleColor { 0xFF666666 };</span>
1337     case CSSValueThreedface:
<span class="line-modified">1338         return Color::lightGray;</span>
1339     case CSSValueThreedhighlight:
<span class="line-modified">1340         return SimpleColor { 0xFFDDDDDD };</span>
1341     case CSSValueThreedlightshadow:
<span class="line-modified">1342         return Color::lightGray;</span>
1343     case CSSValueThreedshadow:
<span class="line-modified">1344         return SimpleColor { 0xFF888888 };</span>
1345     case CSSValueWindow:
<span class="line-modified">1346         return Color::white;</span>
1347     case CSSValueWindowframe:
<span class="line-modified">1348         return SimpleColor { 0xFFCCCCCC };</span>
1349     case CSSValueWindowtext:
<span class="line-modified">1350         return Color::black;</span>
1351     default:
<span class="line-modified">1352         return { };</span>
1353     }

1354 }
1355 
1356 Color RenderTheme::activeTextSearchHighlightColor(OptionSet&lt;StyleColor::Options&gt; options) const
1357 {
1358     auto&amp; cache = colorCache(options);
1359     if (!cache.activeTextSearchHighlightColor.isValid())
1360         cache.activeTextSearchHighlightColor = platformActiveTextSearchHighlightColor(options);
1361     return cache.activeTextSearchHighlightColor;
1362 }
1363 
1364 Color RenderTheme::inactiveTextSearchHighlightColor(OptionSet&lt;StyleColor::Options&gt; options) const
1365 {
1366     auto&amp; cache = colorCache(options);
1367     if (!cache.inactiveTextSearchHighlightColor.isValid())
1368         cache.inactiveTextSearchHighlightColor = platformInactiveTextSearchHighlightColor(options);
1369     return cache.inactiveTextSearchHighlightColor;
1370 }
1371 
1372 Color RenderTheme::platformActiveTextSearchHighlightColor(OptionSet&lt;StyleColor::Options&gt;) const
1373 {
</pre>
</td>
</tr>
</table>
<center><a href="RenderTextLineBoxes.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderTheme.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
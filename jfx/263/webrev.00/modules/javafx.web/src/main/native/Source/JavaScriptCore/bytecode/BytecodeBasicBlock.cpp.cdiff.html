<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeBasicBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ByValInfo.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeBasicBlock.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeBasicBlock.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,16 ***</span>
  
  #include &quot;CodeBlock.h&quot;
  #include &quot;InterpreterInlines.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;PreciseJumpTargets.h&quot;
  
  namespace JSC {
  
  void BytecodeBasicBlock::shrinkToFit()
  {
<span class="line-modified">!     m_offsets.shrinkToFit();</span>
      m_successors.shrinkToFit();
  }
  
  static bool isJumpTarget(OpcodeID opcodeID, const Vector&lt;InstructionStream::Offset, 32&gt;&amp; jumpTargets, unsigned bytecodeOffset)
  {
<span class="line-new-header">--- 28,40 ---</span>
  
  #include &quot;CodeBlock.h&quot;
  #include &quot;InterpreterInlines.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;PreciseJumpTargets.h&quot;
<span class="line-added">+ #include &quot;UnlinkedCodeBlockGenerator.h&quot;</span>
  
  namespace JSC {
  
<span class="line-added">+ DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(BytecodeBasicBlock);</span>
<span class="line-added">+ </span>
<span class="line-added">+ BytecodeBasicBlock::BytecodeBasicBlock(const InstructionStream::Ref&amp; instruction, unsigned blockIndex)</span>
<span class="line-added">+     : m_leaderOffset(instruction.offset())</span>
<span class="line-added">+     , m_totalLength(0)</span>
<span class="line-added">+     , m_index(blockIndex)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     addLength(instruction-&gt;size());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ BytecodeBasicBlock::BytecodeBasicBlock(BytecodeBasicBlock::SpecialBlockType blockType, unsigned blockIndex)</span>
<span class="line-added">+     : m_leaderOffset(blockType == BytecodeBasicBlock::EntryBlock ? 0 : UINT_MAX)</span>
<span class="line-added">+     , m_totalLength(blockType == BytecodeBasicBlock::EntryBlock ? 0 : UINT_MAX)</span>
<span class="line-added">+     , m_index(blockIndex)</span>
<span class="line-added">+ {</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void BytecodeBasicBlock::addLength(unsigned bytecodeLength)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_delta.append(bytecodeLength);</span>
<span class="line-added">+     m_totalLength += bytecodeLength;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void BytecodeBasicBlock::shrinkToFit()
  {
<span class="line-modified">!     m_delta.shrinkToFit();</span>
      m_successors.shrinkToFit();
  }
  
  static bool isJumpTarget(OpcodeID opcodeID, const Vector&lt;InstructionStream::Offset, 32&gt;&amp; jumpTargets, unsigned bytecodeOffset)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,116 ***</span>
  
      return std::binary_search(jumpTargets.begin(), jumpTargets.end(), bytecodeOffset);
  }
  
  template&lt;typename Block&gt;
<span class="line-modified">! void BytecodeBasicBlock::computeImpl(Block* codeBlock, const InstructionStream&amp; instructions, Vector&lt;std::unique_ptr&lt;BytecodeBasicBlock&gt;&gt;&amp; basicBlocks)</span>
  {
      Vector&lt;InstructionStream::Offset, 32&gt; jumpTargets;
      computePreciseJumpTargets(codeBlock, instructions, jumpTargets);
  
<span class="line-modified">!     auto appendBlock = [&amp;] (std::unique_ptr&lt;BytecodeBasicBlock&gt;&amp;&amp; block) {</span>
<span class="line-modified">!         block-&gt;m_index = basicBlocks.size();</span>
<span class="line-removed">-         basicBlocks.append(WTFMove(block));</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto linkBlocks = [&amp;] (BytecodeBasicBlock* from, BytecodeBasicBlock* to) {</span>
<span class="line-removed">-         from-&gt;addSuccessor(to);</span>
      };
  
<span class="line-modified">!     // Create the entry and exit basic blocks.</span>
<span class="line-modified">!     basicBlocks.reserveCapacity(jumpTargets.size() + 2);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto entry = makeUnique&lt;BytecodeBasicBlock&gt;(BytecodeBasicBlock::EntryBlock);</span>
<span class="line-modified">!     auto firstBlock = makeUnique&lt;BytecodeBasicBlock&gt;(BytecodeBasicBlock::EntryBlock);</span>
<span class="line-modified">!     linkBlocks(entry.get(), firstBlock.get());</span>
  
<span class="line-modified">!     appendBlock(WTFMove(entry));</span>
<span class="line-modified">!     BytecodeBasicBlock* current = firstBlock.get();</span>
<span class="line-modified">!     appendBlock(WTFMove(firstBlock));</span>
  
<span class="line-modified">!     auto exit = makeUnique&lt;BytecodeBasicBlock&gt;(BytecodeBasicBlock::ExitBlock);</span>
  
<span class="line-modified">!     bool nextInstructionIsLeader = false;</span>
  
<span class="line-modified">!     for (const auto&amp; instruction : instructions) {</span>
<span class="line-modified">!         auto bytecodeOffset = instruction.offset();</span>
<span class="line-removed">-         OpcodeID opcodeID = instruction-&gt;opcodeID();</span>
  
<span class="line-modified">!         bool createdBlock = false;</span>
<span class="line-modified">!         // If the current bytecode is a jump target, then it&#39;s the leader of its own basic block.</span>
<span class="line-removed">-         if (isJumpTarget(opcodeID, jumpTargets, bytecodeOffset) || nextInstructionIsLeader) {</span>
<span class="line-removed">-             auto newBlock = makeUnique&lt;BytecodeBasicBlock&gt;(instruction);</span>
<span class="line-removed">-             current = newBlock.get();</span>
<span class="line-removed">-             appendBlock(WTFMove(newBlock));</span>
<span class="line-removed">-             createdBlock = true;</span>
<span class="line-removed">-             nextInstructionIsLeader = false;</span>
          }
<span class="line-modified">! </span>
<span class="line-modified">!         // If the current bytecode is a branch or a return, then the next instruction is the leader of its own basic block.</span>
<span class="line-modified">!         if (isBranch(opcodeID) || isTerminal(opcodeID) || isThrow(opcodeID))</span>
<span class="line-modified">!             nextInstructionIsLeader = true;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (createdBlock)</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Otherwise, just add to the length of the current block.</span>
<span class="line-removed">-         current-&gt;addLength(instruction-&gt;size());</span>
      }
  
      // Link basic blocks together.
      for (unsigned i = 0; i &lt; basicBlocks.size(); i++) {
<span class="line-modified">!         BytecodeBasicBlock* block = basicBlocks[i].get();</span>
  
<span class="line-modified">!         if (block-&gt;isEntryBlock() || block-&gt;isExitBlock())</span>
              continue;
  
          bool fallsThrough = true;
<span class="line-modified">!         for (auto bytecodeOffset : block-&gt;offsets()) {</span>
<span class="line-modified">!             auto instruction = instructions.at(bytecodeOffset);</span>
              OpcodeID opcodeID = instruction-&gt;opcodeID();
  
              // If we found a terminal bytecode, link to the exit block.
              if (isTerminal(opcodeID)) {
<span class="line-modified">!                 ASSERT(bytecodeOffset + instruction-&gt;size() == block-&gt;leaderOffset() + block-&gt;totalLength());</span>
<span class="line-modified">!                 linkBlocks(block, exit.get());</span>
                  fallsThrough = false;
                  break;
              }
  
              // If we found a throw, get the HandlerInfo for this instruction to see where we will jump.
              // If there isn&#39;t one, treat this throw as a terminal. This is true even if we have a finally
              // block because the finally block will create its own catch, which will generate a HandlerInfo.
              if (isThrow(opcodeID)) {
<span class="line-modified">!                 ASSERT(bytecodeOffset + instruction-&gt;size() == block-&gt;leaderOffset() + block-&gt;totalLength());</span>
<span class="line-modified">!                 auto* handler = codeBlock-&gt;handlerForBytecodeOffset(instruction.offset());</span>
                  fallsThrough = false;
                  if (!handler) {
<span class="line-modified">!                     linkBlocks(block, exit.get());</span>
                      break;
                  }
<span class="line-modified">!                 for (unsigned i = 0; i &lt; basicBlocks.size(); i++) {</span>
<span class="line-modified">!                     BytecodeBasicBlock* otherBlock = basicBlocks[i].get();</span>
<span class="line-removed">-                     if (handler-&gt;target == otherBlock-&gt;leaderOffset()) {</span>
                          linkBlocks(block, otherBlock);
                          break;
                      }
                  }
                  break;
              }
  
              // If we found a branch, link to the block(s) that we jump to.
              if (isBranch(opcodeID)) {
<span class="line-modified">!                 ASSERT(bytecodeOffset + instruction-&gt;size() == block-&gt;leaderOffset() + block-&gt;totalLength());</span>
                  Vector&lt;InstructionStream::Offset, 1&gt; bytecodeOffsetsJumpedTo;
                  findJumpTargetsForInstruction(codeBlock, instruction, bytecodeOffsetsJumpedTo);
  
                  size_t numberOfJumpTargets = bytecodeOffsetsJumpedTo.size();
                  ASSERT(numberOfJumpTargets);
<span class="line-modified">!                 for (unsigned i = 0; i &lt; basicBlocks.size(); i++) {</span>
<span class="line-modified">!                     BytecodeBasicBlock* otherBlock = basicBlocks[i].get();</span>
<span class="line-removed">-                     if (bytecodeOffsetsJumpedTo.contains(otherBlock-&gt;leaderOffset())) {</span>
                          linkBlocks(block, otherBlock);
                          --numberOfJumpTargets;
                          if (!numberOfJumpTargets)
                              break;
                      }
<span class="line-new-header">--- 70,118 ---</span>
  
      return std::binary_search(jumpTargets.begin(), jumpTargets.end(), bytecodeOffset);
  }
  
  template&lt;typename Block&gt;
<span class="line-modified">! auto BytecodeBasicBlock::computeImpl(Block* codeBlock, const InstructionStream&amp; instructions) -&gt; BasicBlockVector</span>
  {
<span class="line-added">+     BasicBlockVector basicBlocks;</span>
      Vector&lt;InstructionStream::Offset, 32&gt; jumpTargets;
      computePreciseJumpTargets(codeBlock, instructions, jumpTargets);
  
<span class="line-modified">!     auto linkBlocks = [&amp;] (BytecodeBasicBlock&amp; from, BytecodeBasicBlock&amp; to) {</span>
<span class="line-modified">!         from.addSuccessor(to);</span>
      };
  
<span class="line-modified">!     {</span>
<span class="line-modified">!         // Create the entry and exit basic blocks.</span>
<span class="line-modified">!         basicBlocks.reserveCapacity(jumpTargets.size() + 2);</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             // Entry block.</span>
<span class="line-modified">!             basicBlocks.constructAndAppend(BytecodeBasicBlock::EntryBlock, basicBlocks.size());</span>
<span class="line-added">+             // First block.</span>
<span class="line-added">+             basicBlocks.constructAndAppend(BytecodeBasicBlock::EntryBlock, basicBlocks.size());</span>
<span class="line-added">+             linkBlocks(basicBlocks[0], basicBlocks[1]);</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         BytecodeBasicBlock* current = &amp;basicBlocks.last();</span>
<span class="line-modified">!         auto appendBlock = [&amp;] (const InstructionStream::Ref&amp; instruction) -&gt; BytecodeBasicBlock* {</span>
<span class="line-modified">!             basicBlocks.constructAndAppend(instruction, basicBlocks.size());</span>
<span class="line-added">+             return &amp;basicBlocks.last();</span>
<span class="line-added">+         };</span>
<span class="line-added">+         bool nextInstructionIsLeader = false;</span>
<span class="line-added">+         for (const auto&amp; instruction : instructions) {</span>
<span class="line-added">+             auto bytecodeOffset = instruction.offset();</span>
<span class="line-added">+             OpcodeID opcodeID = instruction-&gt;opcodeID();</span>
  
<span class="line-modified">!             bool createdBlock = false;</span>
<span class="line-added">+             // If the current bytecode is a jump target, then it&#39;s the leader of its own basic block.</span>
<span class="line-added">+             if (nextInstructionIsLeader || isJumpTarget(opcodeID, jumpTargets, bytecodeOffset)) {</span>
<span class="line-added">+                 current = appendBlock(instruction);</span>
<span class="line-added">+                 createdBlock = true;</span>
<span class="line-added">+                 nextInstructionIsLeader = false;</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             // If the current bytecode is a branch or a return, then the next instruction is the leader of its own basic block.</span>
<span class="line-added">+             if (isBranch(opcodeID) || isTerminal(opcodeID) || isThrow(opcodeID))</span>
<span class="line-added">+                 nextInstructionIsLeader = true;</span>
  
<span class="line-modified">!             if (createdBlock)</span>
<span class="line-modified">!                 continue;</span>
  
<span class="line-modified">!             // Otherwise, just add to the length of the current block.</span>
<span class="line-modified">!             current-&gt;addLength(instruction-&gt;size());</span>
          }
<span class="line-modified">!         // Exit block.</span>
<span class="line-modified">!         basicBlocks.constructAndAppend(BytecodeBasicBlock::ExitBlock, basicBlocks.size());</span>
<span class="line-modified">!         basicBlocks.shrinkToFit();</span>
<span class="line-modified">!         ASSERT(basicBlocks.last().isExitBlock());</span>
      }
<span class="line-added">+     // After this point, we never change basicBlocks.</span>
  
      // Link basic blocks together.
      for (unsigned i = 0; i &lt; basicBlocks.size(); i++) {
<span class="line-modified">!         BytecodeBasicBlock&amp; block = basicBlocks[i];</span>
  
<span class="line-modified">!         if (block.isEntryBlock() || block.isExitBlock())</span>
              continue;
  
          bool fallsThrough = true;
<span class="line-modified">!         for (unsigned visitedLength = 0; visitedLength &lt; block.totalLength();) {</span>
<span class="line-modified">!             InstructionStream::Ref instruction = instructions.at(block.leaderOffset() + visitedLength);</span>
              OpcodeID opcodeID = instruction-&gt;opcodeID();
  
<span class="line-added">+             visitedLength += instruction-&gt;size();</span>
<span class="line-added">+ </span>
              // If we found a terminal bytecode, link to the exit block.
              if (isTerminal(opcodeID)) {
<span class="line-modified">!                 ASSERT(instruction.offset() + instruction-&gt;size() == block.leaderOffset() + block.totalLength());</span>
<span class="line-modified">!                 linkBlocks(block, basicBlocks.last());</span>
                  fallsThrough = false;
                  break;
              }
  
              // If we found a throw, get the HandlerInfo for this instruction to see where we will jump.
              // If there isn&#39;t one, treat this throw as a terminal. This is true even if we have a finally
              // block because the finally block will create its own catch, which will generate a HandlerInfo.
              if (isThrow(opcodeID)) {
<span class="line-modified">!                 ASSERT(instruction.offset() + instruction-&gt;size() == block.leaderOffset() + block.totalLength());</span>
<span class="line-modified">!                 auto* handler = codeBlock-&gt;handlerForBytecodeIndex(BytecodeIndex(instruction.offset()));</span>
                  fallsThrough = false;
                  if (!handler) {
<span class="line-modified">!                     linkBlocks(block, basicBlocks.last());</span>
                      break;
                  }
<span class="line-modified">!                 for (auto&amp; otherBlock : basicBlocks) {</span>
<span class="line-modified">!                     if (handler-&gt;target == otherBlock.leaderOffset()) {</span>
                          linkBlocks(block, otherBlock);
                          break;
                      }
                  }
                  break;
              }
  
              // If we found a branch, link to the block(s) that we jump to.
              if (isBranch(opcodeID)) {
<span class="line-modified">!                 ASSERT(instruction.offset() + instruction-&gt;size() == block.leaderOffset() + block.totalLength());</span>
                  Vector&lt;InstructionStream::Offset, 1&gt; bytecodeOffsetsJumpedTo;
                  findJumpTargetsForInstruction(codeBlock, instruction, bytecodeOffsetsJumpedTo);
  
                  size_t numberOfJumpTargets = bytecodeOffsetsJumpedTo.size();
                  ASSERT(numberOfJumpTargets);
<span class="line-modified">!                 for (auto&amp; otherBlock : basicBlocks) {</span>
<span class="line-modified">!                     if (bytecodeOffsetsJumpedTo.contains(otherBlock.leaderOffset())) {</span>
                          linkBlocks(block, otherBlock);
                          --numberOfJumpTargets;
                          if (!numberOfJumpTargets)
                              break;
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,27 ***</span>
          }
  
          // If we fall through then link to the next block in program order.
          if (fallsThrough) {
              ASSERT(i + 1 &lt; basicBlocks.size());
<span class="line-modified">!             BytecodeBasicBlock* nextBlock = basicBlocks[i + 1].get();</span>
              linkBlocks(block, nextBlock);
          }
      }
  
<span class="line-modified">!     appendBlock(WTFMove(exit));</span>
  
<span class="line-modified">!     for (auto&amp; basicBlock : basicBlocks)</span>
<span class="line-removed">-         basicBlock-&gt;shrinkToFit();</span>
  }
  
<span class="line-modified">! void BytecodeBasicBlock::compute(CodeBlock* codeBlock, const InstructionStream&amp; instructions, Vector&lt;std::unique_ptr&lt;BytecodeBasicBlock&gt;&gt;&amp; basicBlocks)</span>
  {
<span class="line-modified">!     computeImpl(codeBlock, instructions, basicBlocks);</span>
  }
  
<span class="line-modified">! void BytecodeBasicBlock::compute(UnlinkedCodeBlock* codeBlock, const InstructionStream&amp; instructions, Vector&lt;std::unique_ptr&lt;BytecodeBasicBlock&gt;&gt;&amp; basicBlocks)</span>
  {
<span class="line-modified">!     computeImpl(codeBlock, instructions, basicBlocks);</span>
  }
  
  } // namespace JSC
<span class="line-new-header">--- 200,30 ---</span>
          }
  
          // If we fall through then link to the next block in program order.
          if (fallsThrough) {
              ASSERT(i + 1 &lt; basicBlocks.size());
<span class="line-modified">!             BytecodeBasicBlock&amp; nextBlock = basicBlocks[i + 1];</span>
              linkBlocks(block, nextBlock);
          }
      }
  
<span class="line-modified">!     unsigned index = 0;</span>
<span class="line-added">+     for (auto&amp; basicBlock : basicBlocks) {</span>
<span class="line-added">+         basicBlock.shrinkToFit();</span>
<span class="line-added">+         ASSERT_UNUSED(index, basicBlock.index() == index++);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     return basicBlocks;</span>
  }
  
<span class="line-modified">! auto BytecodeBasicBlock::compute(CodeBlock* codeBlock, const InstructionStream&amp; instructions) -&gt; BasicBlockVector</span>
  {
<span class="line-modified">!     return computeImpl(codeBlock, instructions);</span>
  }
  
<span class="line-modified">! auto BytecodeBasicBlock::compute(UnlinkedCodeBlockGenerator* codeBlock, const InstructionStream&amp; instructions) -&gt; BasicBlockVector</span>
  {
<span class="line-modified">!     return computeImpl(codeBlock, instructions);</span>
  }
  
  } // namespace JSC
</pre>
<center><a href="ByValInfo.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeBasicBlock.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
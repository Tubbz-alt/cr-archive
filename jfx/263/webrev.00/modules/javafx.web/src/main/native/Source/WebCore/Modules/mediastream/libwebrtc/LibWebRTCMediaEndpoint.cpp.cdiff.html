<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCMediaEndpoint.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LibWebRTCDataChannelHandler.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LibWebRTCMediaEndpoint.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCMediaEndpoint.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,10 ***</span>
<span class="line-new-header">--- 26,11 ---</span>
  #include &quot;LibWebRTCMediaEndpoint.h&quot;
  
  #if USE(LIBWEBRTC)
  
  #include &quot;EventNames.h&quot;
<span class="line-added">+ #include &quot;JSDOMPromiseDeferred.h&quot;</span>
  #include &quot;JSRTCStatsReport.h&quot;
  #include &quot;LibWebRTCDataChannelHandler.h&quot;
  #include &quot;LibWebRTCPeerConnectionBackend.h&quot;
  #include &quot;LibWebRTCProvider.h&quot;
  #include &quot;LibWebRTCRtpReceiverBackend.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 50,14 ***</span>
  #include &quot;RealtimeIncomingAudioSource.h&quot;
  #include &quot;RealtimeIncomingVideoSource.h&quot;
  #include &quot;RealtimeOutgoingAudioSource.h&quot;
  #include &quot;RealtimeOutgoingVideoSource.h&quot;
  #include &quot;RuntimeEnabledFeatures.h&quot;
<span class="line-modified">! #include &lt;webrtc/rtc_base/physicalsocketserver.h&gt;</span>
<span class="line-modified">! #include &lt;webrtc/p2p/base/basicpacketsocketfactory.h&gt;</span>
<span class="line-modified">! #include &lt;webrtc/p2p/client/basicportallocator.h&gt;</span>
<span class="line-modified">! #include &lt;webrtc/pc/peerconnectionfactory.h&gt;</span>
  #include &lt;webrtc/system_wrappers/include/field_trial.h&gt;
  #include &lt;wtf/MainThread.h&gt;
  
  namespace WebCore {
  
<span class="line-new-header">--- 51,14 ---</span>
  #include &quot;RealtimeIncomingAudioSource.h&quot;
  #include &quot;RealtimeIncomingVideoSource.h&quot;
  #include &quot;RealtimeOutgoingAudioSource.h&quot;
  #include &quot;RealtimeOutgoingVideoSource.h&quot;
  #include &quot;RuntimeEnabledFeatures.h&quot;
<span class="line-modified">! #include &lt;webrtc/rtc_base/physical_socket_server.h&gt;</span>
<span class="line-modified">! #include &lt;webrtc/p2p/base/basic_packet_socket_factory.h&gt;</span>
<span class="line-modified">! #include &lt;webrtc/p2p/client/basic_port_allocator.h&gt;</span>
<span class="line-modified">! #include &lt;webrtc/pc/peer_connection_factory.h&gt;</span>
  #include &lt;webrtc/system_wrappers/include/field_trial.h&gt;
  #include &lt;wtf/MainThread.h&gt;
  
  namespace WebCore {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 80,24 ***</span>
          webrtc::field_trial::InitFieldTrialsFromString(&quot;WebRTC-H264Simulcast/Enabled/&quot;);
  }
  
  bool LibWebRTCMediaEndpoint::setConfiguration(LibWebRTCProvider&amp; client, webrtc::PeerConnectionInterface::RTCConfiguration&amp;&amp; configuration)
  {
<span class="line-modified">!     if (RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())</span>
<span class="line-removed">-         configuration.sdp_semantics = webrtc::SdpSemantics::kUnifiedPlan;</span>
  
      if (!m_backend) {
          if (!m_rtcSocketFactory) {
              auto&amp; document = downcast&lt;Document&gt;(*m_peerConnectionBackend.connection().scriptExecutionContext());
<span class="line-modified">!             m_rtcSocketFactory = client.createSocketFactory(document.sessionID(), document.userAgent(document.url()));</span>
          }
          m_backend = client.createPeerConnection(*this, m_rtcSocketFactory.get(), WTFMove(configuration));
          return !!m_backend;
      }
      auto oldConfiguration = m_backend-&gt;GetConfiguration();
      configuration.certificates = oldConfiguration.certificates;
<span class="line-modified">!     return m_backend-&gt;SetConfiguration(WTFMove(configuration));</span>
  }
  
  static inline const char* sessionDescriptionType(RTCSdpType sdpType)
  {
      switch (sdpType) {
<span class="line-new-header">--- 81,35 ---</span>
          webrtc::field_trial::InitFieldTrialsFromString(&quot;WebRTC-H264Simulcast/Enabled/&quot;);
  }
  
  bool LibWebRTCMediaEndpoint::setConfiguration(LibWebRTCProvider&amp; client, webrtc::PeerConnectionInterface::RTCConfiguration&amp;&amp; configuration)
  {
<span class="line-modified">!     configuration.sdp_semantics = webrtc::SdpSemantics::kUnifiedPlan;</span>
  
      if (!m_backend) {
          if (!m_rtcSocketFactory) {
              auto&amp; document = downcast&lt;Document&gt;(*m_peerConnectionBackend.connection().scriptExecutionContext());
<span class="line-modified">!             m_rtcSocketFactory = client.createSocketFactory(document.userAgent(document.url()));</span>
          }
          m_backend = client.createPeerConnection(*this, m_rtcSocketFactory.get(), WTFMove(configuration));
          return !!m_backend;
      }
      auto oldConfiguration = m_backend-&gt;GetConfiguration();
      configuration.certificates = oldConfiguration.certificates;
<span class="line-modified">!     return m_backend-&gt;SetConfiguration(WTFMove(configuration)).ok();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void LibWebRTCMediaEndpoint::suspend()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_rtcSocketFactory)</span>
<span class="line-added">+         m_rtcSocketFactory-&gt;suspend();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void LibWebRTCMediaEndpoint::resume()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_rtcSocketFactory)</span>
<span class="line-added">+         m_rtcSocketFactory-&gt;resume();</span>
  }
  
  static inline const char* sessionDescriptionType(RTCSdpType sdpType)
  {
      switch (sdpType) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 206,19 ***</span>
  
  bool LibWebRTCMediaEndpoint::addTrack(LibWebRTCRtpSenderBackend&amp; sender, MediaStreamTrack&amp; track, const Vector&lt;String&gt;&amp; mediaStreamIds)
  {
      ASSERT(m_backend);
  
<span class="line-removed">-     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled()) {</span>
<span class="line-removed">-         String mediaStreamId = mediaStreamIds.isEmpty() ? createCanonicalUUIDString() : mediaStreamIds[0];</span>
<span class="line-removed">-         m_localStreams.ensure(mediaStreamId, [&amp;] {</span>
<span class="line-removed">-             auto mediaStream = m_peerConnectionFactory.CreateLocalMediaStream(mediaStreamId.utf8().data());</span>
<span class="line-removed">-             m_backend-&gt;AddStream(mediaStream);</span>
<span class="line-removed">-             return mediaStream;</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      LibWebRTCRtpSenderBackend::Source source;
      rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt; rtcTrack;
      switch (track.privateTrack().type()) {
      case RealtimeMediaSource::Type::Audio: {
          auto audioSource = RealtimeOutgoingAudioSource::create(track.privateTrack());
<span class="line-new-header">--- 218,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 268,16 ***</span>
      m_isInitiator = true;
      webrtc::PeerConnectionInterface::RTCOfferAnswerOptions rtcOptions;
      rtcOptions.ice_restart = options.iceRestart;
      rtcOptions.voice_activity_detection = options.voiceActivityDetection;
  
<span class="line-removed">-     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled()) {</span>
<span class="line-removed">-         if (m_peerConnectionBackend.shouldOfferAllowToReceive(&quot;audio&quot;_s))</span>
<span class="line-removed">-             rtcOptions.offer_to_receive_audio = webrtc::PeerConnectionInterface::RTCOfferAnswerOptions::kOfferToReceiveMediaTrue;</span>
<span class="line-removed">-         if (m_peerConnectionBackend.shouldOfferAllowToReceive(&quot;video&quot;_s))</span>
<span class="line-removed">-             rtcOptions.offer_to_receive_video = webrtc::PeerConnectionInterface::RTCOfferAnswerOptions::kOfferToReceiveMediaTrue;</span>
<span class="line-removed">-     }</span>
      m_backend-&gt;CreateOffer(&amp;m_createSessionDescriptionObserver, rtcOptions);
  }
  
  void LibWebRTCMediaEndpoint::doCreateAnswer()
  {
<span class="line-new-header">--- 271,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 287,23 ***</span>
      m_backend-&gt;CreateAnswer(&amp;m_createSessionDescriptionObserver, { });
  }
  
  rtc::scoped_refptr&lt;LibWebRTCStatsCollector&gt; LibWebRTCMediaEndpoint::createStatsCollector(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
  {
<span class="line-modified">!     return LibWebRTCStatsCollector::create([promise = WTFMove(promise), protectedThis = makeRef(*this)]() mutable -&gt; RefPtr&lt;RTCStatsReport&gt; {</span>
          ASSERT(isMainThread());
<span class="line-modified">!         if (protectedThis-&gt;isStopped())</span>
<span class="line-modified">!             return nullptr;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto report = RTCStatsReport::create();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         promise-&gt;resolve&lt;IDLInterface&lt;RTCStatsReport&gt;&gt;(report.copyRef());</span>
  
<span class="line-modified">!         // The promise resolution might fail in which case no backing map will be created.</span>
<span class="line-removed">-         if (!report-&gt;backingMap())</span>
<span class="line-removed">-             return nullptr;</span>
<span class="line-removed">-         return report;</span>
      });
  }
  
  void LibWebRTCMediaEndpoint::getStats(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
  {
<span class="line-new-header">--- 284,16 ---</span>
      m_backend-&gt;CreateAnswer(&amp;m_createSessionDescriptionObserver, { });
  }
  
  rtc::scoped_refptr&lt;LibWebRTCStatsCollector&gt; LibWebRTCMediaEndpoint::createStatsCollector(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
  {
<span class="line-modified">!     return LibWebRTCStatsCollector::create([promise = WTFMove(promise), protectedThis = makeRef(*this)](auto&amp;&amp; report) mutable {</span>
          ASSERT(isMainThread());
<span class="line-modified">!         if (protectedThis-&gt;isStopped() || !report)</span>
<span class="line-modified">!             return;</span>
  
<span class="line-modified">!         promise-&gt;resolve&lt;IDLInterface&lt;RTCStatsReport&gt;&gt;(report.releaseNonNull());</span>
      });
  }
  
  void LibWebRTCMediaEndpoint::getStats(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 461,13 ***</span>
  void LibWebRTCMediaEndpoint::collectTransceivers()
  {
      if (!m_backend)
          return;
  
<span class="line-removed">-     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
      for (auto&amp; rtcTransceiver : m_backend-&gt;GetTransceivers()) {
          auto* existingTransceiver = m_peerConnectionBackend.existingTransceiver([&amp;](auto&amp; transceiverBackend) {
              return rtcTransceiver.get() == transceiverBackend.rtcTransceiver();
          });
          if (existingTransceiver)
<span class="line-new-header">--- 451,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 504,14 ***</span>
      addPendingTrackEvent(makeRef(newTransceiver.receiver()), newTransceiver.receiver().track(), rtcReceiver-&gt;streams(), makeRef(newTransceiver));
  }
  
  void LibWebRTCMediaEndpoint::removeRemoteTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;&amp;&amp; receiver)
  {
<span class="line-removed">-     // FIXME: Support plan B code path.</span>
<span class="line-removed">-     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
      auto* transceiver = m_peerConnectionBackend.existingTransceiver([&amp;receiver](auto&amp; transceiverBackend) {
          auto* rtcTransceiver = transceiverBackend.rtcTransceiver();
          return rtcTransceiver &amp;&amp; receiver.get() == rtcTransceiver-&gt;receiver().get();
      });
      if (!transceiver)
<span class="line-new-header">--- 491,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 615,27 ***</span>
          ASSERT(stream);
          protectedThis-&gt;removeRemoteStream(*stream.get());
      });
  }
  
<span class="line-removed">- void LibWebRTCMediaEndpoint::OnAddTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt; receiver, const std::vector&lt;rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;&gt;&amp; streams)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     callOnMainThread([protectedThis = makeRef(*this), receiver = WTFMove(receiver), streams]() mutable {</span>
<span class="line-removed">-         if (protectedThis-&gt;isStopped())</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         protectedThis-&gt;addRemoteTrack(WTFMove(receiver), streams);</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void LibWebRTCMediaEndpoint::OnTrack(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt; transceiver)
  {
<span class="line-removed">-     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
      callOnMainThread([protectedThis = makeRef(*this), transceiver = WTFMove(transceiver)]() mutable {
          if (protectedThis-&gt;isStopped())
              return;
          protectedThis-&gt;newTransceiver(WTFMove(transceiver));
      });
<span class="line-new-header">--- 598,12 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 661,14 ***</span>
  {
      callOnMainThread([protectedThis = makeRef(*this), dataChannel = WTFMove(dataChannel)]() mutable {
          if (protectedThis-&gt;isStopped())
              return;
          auto&amp; connection = protectedThis-&gt;m_peerConnectionBackend.connection();
<span class="line-modified">!         connection.fireEvent(LibWebRTCDataChannelHandler::channelEvent(*connection.scriptExecutionContext(), WTFMove(dataChannel)));</span>
      });
  }
  
  void LibWebRTCMediaEndpoint::stop()
  {
      if (!m_backend)
          return;
  
<span class="line-new-header">--- 629,20 ---</span>
  {
      callOnMainThread([protectedThis = makeRef(*this), dataChannel = WTFMove(dataChannel)]() mutable {
          if (protectedThis-&gt;isStopped())
              return;
          auto&amp; connection = protectedThis-&gt;m_peerConnectionBackend.connection();
<span class="line-modified">!         connection.dispatchEventWhenFeasible(LibWebRTCDataChannelHandler::channelEvent(*connection.document(), WTFMove(dataChannel)));</span>
      });
  }
  
<span class="line-added">+ void LibWebRTCMediaEndpoint::close()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_backend-&gt;Close();</span>
<span class="line-added">+     stopLoggingStats();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void LibWebRTCMediaEndpoint::stop()
  {
      if (!m_backend)
          return;
  
</pre>
<center><a href="LibWebRTCDataChannelHandler.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LibWebRTCMediaEndpoint.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
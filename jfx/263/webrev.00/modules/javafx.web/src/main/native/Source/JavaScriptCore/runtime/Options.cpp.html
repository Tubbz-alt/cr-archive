<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Options.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Options.h&quot;
  28 
  29 #include &quot;AssemblerCommon.h&quot;
  30 #include &quot;CPU.h&quot;
  31 #include &quot;LLIntCommon.h&quot;
  32 #include &quot;MinimumReservedZoneSize.h&quot;
  33 #include &quot;SigillCrashAnalyzer.h&quot;
  34 #include &lt;algorithm&gt;
  35 #include &lt;limits&gt;
  36 #include &lt;math.h&gt;
  37 #include &lt;mutex&gt;
  38 #include &lt;stdlib.h&gt;
  39 #include &lt;string.h&gt;
  40 #include &lt;wtf/ASCIICType.h&gt;
  41 #include &lt;wtf/Compiler.h&gt;
  42 #include &lt;wtf/DataLog.h&gt;
  43 #include &lt;wtf/NumberOfCores.h&gt;
  44 #include &lt;wtf/Optional.h&gt;
  45 #include &lt;wtf/PointerPreparations.h&gt;
  46 #include &lt;wtf/StdLibExtras.h&gt;
  47 #include &lt;wtf/text/StringBuilder.h&gt;
  48 #include &lt;wtf/threads/Signals.h&gt;
  49 
  50 #if PLATFORM(COCOA)
  51 #include &lt;crt_externs.h&gt;
  52 #endif
  53 
  54 #if ENABLE(JIT)
  55 #include &quot;MacroAssembler.h&quot;
  56 #endif
  57 
  58 namespace JSC {
  59 
  60 template&lt;typename T&gt;
  61 Optional&lt;T&gt; parse(const char* string);
  62 
  63 template&lt;&gt;
  64 Optional&lt;OptionsStorage::Bool&gt; parse(const char* string)
  65 {
  66     if (equalLettersIgnoringASCIICase(string, &quot;true&quot;) || equalLettersIgnoringASCIICase(string, &quot;yes&quot;) || !strcmp(string, &quot;1&quot;))
  67         return true;
  68     if (equalLettersIgnoringASCIICase(string, &quot;false&quot;) || equalLettersIgnoringASCIICase(string, &quot;no&quot;) || !strcmp(string, &quot;0&quot;))
  69         return false;
  70     return WTF::nullopt;
  71 }
  72 
  73 template&lt;&gt;
  74 Optional&lt;OptionsStorage::Int32&gt; parse(const char* string)
  75 {
  76     int32_t value;
  77     if (sscanf(string, &quot;%d&quot;, &amp;value) == 1)
  78         return value;
  79     return WTF::nullopt;
  80 }
  81 
  82 template&lt;&gt;
  83 Optional&lt;OptionsStorage::Unsigned&gt; parse(const char* string)
  84 {
  85     unsigned value;
  86     if (sscanf(string, &quot;%u&quot;, &amp;value) == 1)
  87         return value;
  88     return WTF::nullopt;
  89 }
  90 
  91 #if CPU(ADDRESS64) || OS(DARWIN)
  92 template&lt;&gt;
  93 Optional&lt;OptionsStorage::Size&gt; parse(const char* string)
  94 {
  95     size_t value;
  96     if (sscanf(string, &quot;%zu&quot;, &amp;value) == 1)
  97         return value;
  98     return WTF::nullopt;
  99 }
 100 #endif // CPU(ADDRESS64) || OS(DARWIN)
 101 
 102 template&lt;&gt;
 103 Optional&lt;OptionsStorage::Double&gt; parse(const char* string)
 104 {
 105     double value;
 106     if (sscanf(string, &quot;%lf&quot;, &amp;value) == 1)
 107         return value;
 108     return WTF::nullopt;
 109 }
 110 
 111 template&lt;&gt;
 112 Optional&lt;OptionsStorage::OptionRange&gt; parse(const char* string)
 113 {
 114     OptionRange range;
 115     if (range.init(string))
 116         return range;
 117     return WTF::nullopt;
 118 }
 119 
 120 template&lt;&gt;
 121 Optional&lt;OptionsStorage::OptionString&gt; parse(const char* string)
 122 {
 123     const char* value = nullptr;
 124     if (!strlen(string))
 125         return value;
 126 
 127     // FIXME &lt;https://webkit.org/b/169057&gt;: This could leak if this option is set more than once.
 128     // Given that Options are typically used for testing, this isn&#39;t considered to be a problem.
 129     value = WTF::fastStrDup(string);
 130     return value;
 131 }
 132 
 133 template&lt;&gt;
 134 Optional&lt;OptionsStorage::GCLogLevel&gt; parse(const char* string)
 135 {
 136     if (equalLettersIgnoringASCIICase(string, &quot;none&quot;) || equalLettersIgnoringASCIICase(string, &quot;no&quot;) || equalLettersIgnoringASCIICase(string, &quot;false&quot;) || !strcmp(string, &quot;0&quot;))
 137         return GCLogging::None;
 138 
 139     if (equalLettersIgnoringASCIICase(string, &quot;basic&quot;) || equalLettersIgnoringASCIICase(string, &quot;yes&quot;) || equalLettersIgnoringASCIICase(string, &quot;true&quot;) || !strcmp(string, &quot;1&quot;))
 140         return GCLogging::Basic;
 141 
 142     if (equalLettersIgnoringASCIICase(string, &quot;verbose&quot;) || !strcmp(string, &quot;2&quot;))
 143         return GCLogging::Verbose;
 144 
 145     return WTF::nullopt;
 146 }
 147 
 148 bool Options::isAvailable(Options::ID id, Options::Availability availability)
 149 {
 150     if (availability == Availability::Restricted)
 151         return g_jscConfig.restrictedOptionsEnabled;
 152     ASSERT(availability == Availability::Configurable);
 153 
 154     UNUSED_PARAM(id);
 155 #if !defined(NDEBUG)
 156     if (id == maxSingleAllocationSizeID)
 157         return true;
 158 #endif
 159 #if OS(DARWIN)
 160     if (id == useSigillCrashAnalyzerID)
 161         return true;
 162 #endif
 163 #if ENABLE(ASSEMBLER) &amp;&amp; OS(LINUX)
 164     if (id == logJITCodeForPerfID)
 165         return true;
 166 #endif
 167     if (id == traceLLIntExecutionID)
 168         return !!LLINT_TRACING;
 169     if (id == traceLLIntSlowPathID)
 170         return !!LLINT_TRACING;
 171     return false;
 172 }
 173 
 174 template&lt;typename T&gt;
 175 bool overrideOptionWithHeuristic(T&amp; variable, Options::ID id, const char* name, Options::Availability availability)
 176 {
 177     bool available = (availability == Options::Availability::Normal)
 178         || Options::isAvailable(id, availability);
 179 
 180     const char* stringValue = getenv(name);
 181     if (!stringValue)
 182         return false;
 183 
 184     if (available) {
 185         Optional&lt;T&gt; value = parse&lt;T&gt;(stringValue);
 186         if (value) {
 187             variable = value.value();
 188             return true;
 189         }
 190     }
 191 
 192     fprintf(stderr, &quot;WARNING: failed to parse %s=%s\n&quot;, name, stringValue);
 193     return false;
 194 }
 195 
 196 bool Options::overrideAliasedOptionWithHeuristic(const char* name)
 197 {
 198     const char* stringValue = getenv(name);
 199     if (!stringValue)
 200         return false;
 201 
 202     String aliasedOption;
 203     aliasedOption = String(&amp;name[4]) + &quot;=&quot; + stringValue;
 204     if (Options::setOption(aliasedOption.utf8().data()))
 205         return true;
 206 
 207     fprintf(stderr, &quot;WARNING: failed to parse %s=%s\n&quot;, name, stringValue);
 208     return false;
 209 }
 210 
 211 static unsigned computeNumberOfWorkerThreads(int maxNumberOfWorkerThreads, int minimum = 1)
 212 {
 213     int cpusToUse = std::min(kernTCSMAwareNumberOfProcessorCores(), maxNumberOfWorkerThreads);
 214 
 215     // Be paranoid, it is the OS we&#39;re dealing with, after all.
 216     ASSERT(cpusToUse &gt;= 1);
 217     return std::max(cpusToUse, minimum);
 218 }
 219 
 220 static int32_t computePriorityDeltaOfWorkerThreads(int32_t twoCorePriorityDelta, int32_t multiCorePriorityDelta)
 221 {
 222     if (kernTCSMAwareNumberOfProcessorCores() &lt;= 2)
 223         return twoCorePriorityDelta;
 224 
 225     return multiCorePriorityDelta;
 226 }
 227 
 228 static bool jitEnabledByDefault()
 229 {
 230     return is32Bit() || isAddress64Bit();
 231 }
 232 
 233 static unsigned computeNumberOfGCMarkers(unsigned maxNumberOfGCMarkers)
 234 {
 235     return computeNumberOfWorkerThreads(maxNumberOfGCMarkers);
 236 }
 237 
 238 const char* const OptionRange::s_nullRangeStr = &quot;&lt;null&gt;&quot;;
 239 
 240 bool OptionRange::init(const char* rangeString)
 241 {
 242     // rangeString should be in the form of [!]&lt;low&gt;[:&lt;high&gt;]
 243     // where low and high are unsigned
 244 
 245     bool invert = false;
 246 
 247     if (!rangeString) {
 248         m_state = InitError;
 249         return false;
 250     }
 251 
 252     if (!strcmp(rangeString, s_nullRangeStr)) {
 253         m_state = Uninitialized;
 254         return true;
 255     }
 256 
 257     const char* p = rangeString;
 258 
 259     if (*p == &#39;!&#39;) {
 260         invert = true;
 261         p++;
 262     }
 263 
 264     int scanResult = sscanf(p, &quot; %u:%u&quot;, &amp;m_lowLimit, &amp;m_highLimit);
 265 
 266     if (!scanResult || scanResult == EOF) {
 267         m_state = InitError;
 268         return false;
 269     }
 270 
 271     if (scanResult == 1)
 272         m_highLimit = m_lowLimit;
 273 
 274     if (m_lowLimit &gt; m_highLimit) {
 275         m_state = InitError;
 276         return false;
 277     }
 278 
 279     // FIXME &lt;https://webkit.org/b/169057&gt;: This could leak if this particular option is set more than once.
 280     // Given that these options are used for testing, this isn&#39;t considered to be problem.
 281     m_rangeString = WTF::fastStrDup(rangeString);
 282     m_state = invert ? Inverted : Normal;
 283 
 284     return true;
 285 }
 286 
 287 bool OptionRange::isInRange(unsigned count)
 288 {
 289     if (m_state &lt; Normal)
 290         return true;
 291 
 292     if ((m_lowLimit &lt;= count) &amp;&amp; (count &lt;= m_highLimit))
 293         return m_state == Normal ? true : false;
 294 
 295     return m_state == Normal ? false : true;
 296 }
 297 
 298 void OptionRange::dump(PrintStream&amp; out) const
 299 {
 300     out.print(m_rangeString);
 301 }
 302 
 303 // Realize the names for each of the options:
 304 const Options::ConstMetaData Options::s_constMetaData[NumberOfOptions] = {
 305 #define FILL_OPTION_INFO(type_, name_, defaultValue_, availability_, description_) \
 306     { #name_, description_, Options::Type::type_, Availability::availability_, offsetof(OptionsStorage, name_), offsetof(OptionsStorage, name_##Default) },
 307     FOR_EACH_JSC_OPTION(FILL_OPTION_INFO)
 308 #undef FILL_OPTION_INFO
 309 };
 310 
 311 static void scaleJITPolicy()
 312 {
 313     auto&amp; scaleFactor = Options::jitPolicyScale();
 314     if (scaleFactor &gt; 1.0)
 315         scaleFactor = 1.0;
 316     else if (scaleFactor &lt; 0.0)
 317         scaleFactor = 0.0;
 318 
 319     auto scaleOption = [&amp;] (int32_t&amp; optionValue, int32_t minValue) {
 320         optionValue *= scaleFactor;
 321         optionValue = std::max(optionValue, minValue);
 322     };
 323 
 324     scaleOption(Options::thresholdForJITAfterWarmUp(), 0);
 325     scaleOption(Options::thresholdForJITSoon(), 0);
 326     scaleOption(Options::thresholdForOptimizeAfterWarmUp(), 1);
 327     scaleOption(Options::thresholdForOptimizeAfterLongWarmUp(), 1);
 328     scaleOption(Options::thresholdForOptimizeSoon(), 1);
 329     scaleOption(Options::thresholdForFTLOptimizeSoon(), 2);
 330     scaleOption(Options::thresholdForFTLOptimizeAfterWarmUp(), 2);
 331 }
 332 
 333 static void overrideDefaults()
 334 {
 335 #if !PLATFORM(IOS_FAMILY)
 336     if (WTF::numberOfProcessorCores() &lt; 4)
 337 #endif
 338     {
 339         Options::maximumMutatorUtilization() = 0.6;
 340         Options::concurrentGCMaxHeadroom() = 1.4;
 341         Options::minimumGCPauseMS() = 1;
 342         Options::useStochasticMutatorScheduler() = false;
 343         if (WTF::numberOfProcessorCores() &lt;= 1)
 344             Options::gcIncrementScale() = 1;
 345         else
 346             Options::gcIncrementScale() = 0;
 347     }
 348 
 349 #if USE(BMALLOC_MEMORY_FOOTPRINT_API)
 350     // On iOS and conditionally Linux, we control heap growth using process memory footprint. Therefore these values can be agressive.
 351     Options::smallHeapRAMFraction() = 0.8;
 352     Options::mediumHeapRAMFraction() = 0.9;
 353 #endif
 354 
 355 #if PLATFORM(IOS_FAMILY) &amp;&amp; !PLATFORM(WATCHOS) &amp;&amp; defined(__LP64__)
 356     Options::useSigillCrashAnalyzer() = true;
 357 #endif
 358 
 359 #if !ENABLE(SIGNAL_BASED_VM_TRAPS)
 360     Options::usePollingTraps() = true;
 361 #endif
 362 
 363 #if !ENABLE(WEBASSEMBLY_FAST_MEMORY)
 364     Options::useWebAssemblyFastMemory() = false;
 365 #endif
 366 
 367 #if !HAVE(MACH_EXCEPTIONS)
 368     Options::useMachForExceptions() = false;
 369 #endif
 370 
 371     if (Options::useWasmLLInt() &amp;&amp; !Options::wasmLLIntTiersUpToBBQ()) {
 372         Options::thresholdForOMGOptimizeAfterWarmUp() = 1500;
 373         Options::thresholdForOMGOptimizeSoon() = 100;
 374     }
 375 }
 376 
 377 static void correctOptions()
 378 {
 379     unsigned thresholdForGlobalLexicalBindingEpoch = Options::thresholdForGlobalLexicalBindingEpoch();
 380     if (thresholdForGlobalLexicalBindingEpoch == 0 || thresholdForGlobalLexicalBindingEpoch == 1)
 381         Options::thresholdForGlobalLexicalBindingEpoch() = UINT_MAX;
 382 }
 383 
 384 static void recomputeDependentOptions()
 385 {
 386 #if !defined(NDEBUG)
 387     Options::validateDFGExceptionHandling() = true;
 388 #endif
 389 #if !ENABLE(JIT)
 390     Options::useLLInt() = true;
 391     Options::useJIT() = false;
 392     Options::useBaselineJIT() = false;
 393     Options::useDFGJIT() = false;
 394     Options::useFTLJIT() = false;
 395     Options::useDOMJIT() = false;
 396     Options::useRegExpJIT() = false;
 397 #endif
 398 #if !ENABLE(CONCURRENT_JS)
 399     Options::useConcurrentJIT() = false;
 400 #endif
 401 #if !ENABLE(YARR_JIT)
 402     Options::useRegExpJIT() = false;
 403 #endif
 404 #if !ENABLE(DFG_JIT)
 405     Options::useDFGJIT() = false;
 406     Options::useFTLJIT() = false;
 407 #endif
 408 #if !ENABLE(FTL_JIT)
 409     Options::useFTLJIT() = false;
 410 #endif
 411 
 412 #if !CPU(X86_64) &amp;&amp; !CPU(ARM64)
 413     Options::useConcurrentGC() = false;
 414 #endif
 415 
 416     if (!Options::useJIT()) {
 417         Options::useSigillCrashAnalyzer() = false;
 418         Options::useWebAssembly() = false;
 419     }
 420 
 421     if (!jitEnabledByDefault() &amp;&amp; !Options::useJIT())
 422         Options::useLLInt() = true;
 423 
 424     if (!Options::useWebAssembly())
 425         Options::useFastTLSForWasmContext() = false;
 426 
 427     if (Options::dumpDisassembly()
 428         || Options::dumpDFGDisassembly()
 429         || Options::dumpFTLDisassembly()
 430         || Options::dumpBytecodeAtDFGTime()
 431         || Options::dumpGraphAtEachPhase()
 432         || Options::dumpDFGGraphAtEachPhase()
 433         || Options::dumpDFGFTLGraphAtEachPhase()
 434         || Options::dumpB3GraphAtEachPhase()
 435         || Options::dumpAirGraphAtEachPhase()
 436         || Options::verboseCompilation()
 437         || Options::verboseFTLCompilation()
 438         || Options::logCompilationChanges()
 439         || Options::validateGraph()
 440         || Options::validateGraphAtEachPhase()
 441         || Options::verboseOSR()
 442         || Options::verboseCompilationQueue()
 443         || Options::reportCompileTimes()
 444         || Options::reportBaselineCompileTimes()
 445         || Options::reportDFGCompileTimes()
 446         || Options::reportFTLCompileTimes()
 447         || Options::logPhaseTimes()
 448         || Options::verboseCFA()
 449         || Options::verboseDFGFailure()
 450         || Options::verboseFTLFailure()
 451         || Options::dumpFuzzerAgentPredictions())
 452         Options::alwaysComputeHash() = true;
 453 
 454     if (!Options::useConcurrentGC())
 455         Options::collectContinuously() = false;
 456 
 457     if (Options::jitPolicyScale() != Options::jitPolicyScaleDefault())
 458         scaleJITPolicy();
 459 
 460     if (Options::forceEagerCompilation()) {
 461         Options::thresholdForJITAfterWarmUp() = 10;
 462         Options::thresholdForJITSoon() = 10;
 463         Options::thresholdForOptimizeAfterWarmUp() = 20;
 464         Options::thresholdForOptimizeAfterLongWarmUp() = 20;
 465         Options::thresholdForOptimizeSoon() = 20;
 466         Options::thresholdForFTLOptimizeAfterWarmUp() = 20;
 467         Options::thresholdForFTLOptimizeSoon() = 20;
 468         Options::maximumEvalCacheableSourceLength() = 150000;
 469         Options::useConcurrentJIT() = false;
 470     }
 471 #if ENABLE(SEPARATED_WX_HEAP)
 472     // Override globally for now. Longer term we&#39;ll just make the default
 473     // be to have this option enabled, and have platforms that don&#39;t support
 474     // it just silently use a single mapping.
 475     Options::useSeparatedWXHeap() = true;
 476 #else
 477     Options::useSeparatedWXHeap() = false;
 478 #endif
 479 
 480     if (Options::alwaysUseShadowChicken())
 481         Options::maximumInliningDepth() = 1;
 482 
 483     // Compute the maximum value of the reoptimization retry counter. This is simply
 484     // the largest value at which we don&#39;t overflow the execute counter, when using it
 485     // to left-shift the execution counter by this amount. Currently the value ends
 486     // up being 18, so this loop is not so terrible; it probably takes up ~100 cycles
 487     // total on a 32-bit processor.
 488     Options::reoptimizationRetryCounterMax() = 0;
 489     while ((static_cast&lt;int64_t&gt;(Options::thresholdForOptimizeAfterLongWarmUp()) &lt;&lt; (Options::reoptimizationRetryCounterMax() + 1)) &lt;= static_cast&lt;int64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max()))
 490         Options::reoptimizationRetryCounterMax()++;
 491 
 492     ASSERT((static_cast&lt;int64_t&gt;(Options::thresholdForOptimizeAfterLongWarmUp()) &lt;&lt; Options::reoptimizationRetryCounterMax()) &gt; 0);
 493     ASSERT((static_cast&lt;int64_t&gt;(Options::thresholdForOptimizeAfterLongWarmUp()) &lt;&lt; Options::reoptimizationRetryCounterMax()) &lt;= static_cast&lt;int64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max()));
 494 
 495 #if !defined(NDEBUG)
 496     if (Options::maxSingleAllocationSize())
 497         fastSetMaxSingleAllocationSize(Options::maxSingleAllocationSize());
 498     else
 499         fastSetMaxSingleAllocationSize(std::numeric_limits&lt;size_t&gt;::max());
 500 #endif
 501 
 502     if (Options::useZombieMode()) {
 503         Options::sweepSynchronously() = true;
 504         Options::scribbleFreeCells() = true;
 505     }
 506 
 507     if (Options::reservedZoneSize() &lt; minimumReservedZoneSize)
 508         Options::reservedZoneSize() = minimumReservedZoneSize;
 509     if (Options::softReservedZoneSize() &lt; Options::reservedZoneSize() + minimumReservedZoneSize)
 510         Options::softReservedZoneSize() = Options::reservedZoneSize() + minimumReservedZoneSize;
 511 
 512     // FIXME: Make probe OSR exit work on 32-bit:
 513     // https://bugs.webkit.org/show_bug.cgi?id=177956
 514     Options::useProbeOSRExit() = false;
 515 
 516     if (!Options::useCodeCache())
 517         Options::diskCachePath() = nullptr;
 518 
 519     if (Options::randomIntegrityAuditRate() &lt; 0)
 520         Options::randomIntegrityAuditRate() = 0;
 521     else if (Options::randomIntegrityAuditRate() &gt; 1.0)
 522         Options::randomIntegrityAuditRate() = 1.0;
 523 }
 524 
 525 inline void* Options::addressOfOption(Options::ID id)
 526 {
 527     auto offset = Options::s_constMetaData[id].offsetOfOption;
 528     return reinterpret_cast&lt;uint8_t*&gt;(&amp;g_jscConfig.options) + offset;
 529 }
 530 
 531 inline void* Options::addressOfOptionDefault(Options::ID id)
 532 {
 533     auto offset = Options::s_constMetaData[id].offsetOfOptionDefault;
 534     return reinterpret_cast&lt;uint8_t*&gt;(&amp;g_jscConfig.options) + offset;
 535 }
 536 
 537 void Options::initialize()
 538 {
 539     static std::once_flag initializeOptionsOnceFlag;
 540 
 541     std::call_once(
 542         initializeOptionsOnceFlag,
 543         [] {
 544             // Sanity check that options address computation is working.
 545             RELEASE_ASSERT(Options::addressOfOption(useKernTCSMID) ==  &amp;Options::useKernTCSM());
 546             RELEASE_ASSERT(Options::addressOfOptionDefault(useKernTCSMID) ==  &amp;Options::useKernTCSMDefault());
 547             RELEASE_ASSERT(Options::addressOfOption(gcMaxHeapSizeID) ==  &amp;Options::gcMaxHeapSize());
 548             RELEASE_ASSERT(Options::addressOfOptionDefault(gcMaxHeapSizeID) ==  &amp;Options::gcMaxHeapSizeDefault());
 549             RELEASE_ASSERT(Options::addressOfOption(forceOSRExitToLLIntID) ==  &amp;Options::forceOSRExitToLLInt());
 550             RELEASE_ASSERT(Options::addressOfOptionDefault(forceOSRExitToLLIntID) ==  &amp;Options::forceOSRExitToLLIntDefault());
 551 
 552 #ifndef NDEBUG
 553             Config::enableRestrictedOptions();
 554 #endif
 555             // Initialize each of the options with their default values:
 556 #define INIT_OPTION(type_, name_, defaultValue_, availability_, description_) { \
 557                 auto value = defaultValue_; \
 558                 name_() = value; \
 559                 name_##Default() = value; \
 560             }
 561             FOR_EACH_JSC_OPTION(INIT_OPTION)
 562 #undef INIT_OPTION
 563 
 564             overrideDefaults();
 565 
 566             // Allow environment vars to override options if applicable.
 567             // The evn var should be the name of the option prefixed with
 568             // &quot;JSC_&quot;.
 569 #if PLATFORM(COCOA)
 570             bool hasBadOptions = false;
 571             for (char** envp = *_NSGetEnviron(); *envp; envp++) {
 572                 const char* env = *envp;
 573                 if (!strncmp(&quot;JSC_&quot;, env, 4)) {
 574                     if (!Options::setOption(&amp;env[4])) {
 575                         dataLog(&quot;ERROR: invalid option: &quot;, *envp, &quot;\n&quot;);
 576                         hasBadOptions = true;
 577                     }
 578                 }
 579             }
 580             if (hasBadOptions &amp;&amp; Options::validateOptions())
 581                 CRASH();
 582 #else // PLATFORM(COCOA)
 583 #define OVERRIDE_OPTION_WITH_HEURISTICS(type_, name_, defaultValue_, availability_, description_) \
 584             overrideOptionWithHeuristic(name_(), name_##ID, &quot;JSC_&quot; #name_, Availability::availability_);
 585             FOR_EACH_JSC_OPTION(OVERRIDE_OPTION_WITH_HEURISTICS)
 586 #undef OVERRIDE_OPTION_WITH_HEURISTICS
 587 #endif // PLATFORM(COCOA)
 588 
 589 #define OVERRIDE_ALIASED_OPTION_WITH_HEURISTICS(aliasedName_, unaliasedName_, equivalence_) \
 590             overrideAliasedOptionWithHeuristic(&quot;JSC_&quot; #aliasedName_);
 591             FOR_EACH_JSC_ALIASED_OPTION(OVERRIDE_ALIASED_OPTION_WITH_HEURISTICS)
 592 #undef OVERRIDE_ALIASED_OPTION_WITH_HEURISTICS
 593 
 594 #if 0
 595                 ; // Deconfuse editors that do auto indentation
 596 #endif
 597 
 598             correctOptions();
 599 
 600             recomputeDependentOptions();
 601 
 602             // Do range checks where needed and make corrections to the options:
 603             ASSERT(Options::thresholdForOptimizeAfterLongWarmUp() &gt;= Options::thresholdForOptimizeAfterWarmUp());
 604             ASSERT(Options::thresholdForOptimizeAfterWarmUp() &gt;= Options::thresholdForOptimizeSoon());
 605             ASSERT(Options::thresholdForOptimizeAfterWarmUp() &gt;= 0);
 606             ASSERT(Options::criticalGCMemoryThreshold() &gt; 0.0 &amp;&amp; Options::criticalGCMemoryThreshold() &lt; 1.0);
 607 
 608             dumpOptionsIfNeeded();
 609             ensureOptionsAreCoherent();
 610 
 611 #if HAVE(MACH_EXCEPTIONS)
 612             if (Options::useMachForExceptions())
 613                 handleSignalsWithMach();
 614 #endif
 615 
 616 #if ASAN_ENABLED &amp;&amp; OS(LINUX) &amp;&amp; ENABLE(WEBASSEMBLY_FAST_MEMORY)
 617             if (Options::useWebAssemblyFastMemory()) {
 618                 const char* asanOptions = getenv(&quot;ASAN_OPTIONS&quot;);
 619                 bool okToUseWebAssemblyFastMemory = asanOptions
 620                     &amp;&amp; (strstr(asanOptions, &quot;allow_user_segv_handler=1&quot;) || strstr(asanOptions, &quot;handle_segv=0&quot;));
 621                 if (!okToUseWebAssemblyFastMemory) {
 622                     dataLogLn(&quot;WARNING: ASAN interferes with JSC signal handlers; useWebAssemblyFastMemory will be disabled.&quot;);
 623                     Options::useWebAssemblyFastMemory() = false;
 624                 }
 625             }
 626 #endif
 627 
 628 #if CPU(X86_64) &amp;&amp; OS(DARWIN)
 629             Options::dumpZappedCellCrashData() =
 630                 (hwPhysicalCPUMax() &gt;= 4) &amp;&amp; (hwL3CacheSize() &gt;= static_cast&lt;int64_t&gt;(6 * MB));
 631 #endif
 632         });
 633 }
 634 
 635 void Options::dumpOptionsIfNeeded()
 636 {
 637     if (Options::dumpOptions()) {
 638         DumpLevel level = static_cast&lt;DumpLevel&gt;(Options::dumpOptions());
 639         if (level &gt; DumpLevel::Verbose)
 640             level = DumpLevel::Verbose;
 641 
 642         const char* title = nullptr;
 643         switch (level) {
 644         case DumpLevel::None:
 645             break;
 646         case DumpLevel::Overridden:
 647             title = &quot;Overridden JSC options:&quot;;
 648             break;
 649         case DumpLevel::All:
 650             title = &quot;All JSC options:&quot;;
 651             break;
 652         case DumpLevel::Verbose:
 653             title = &quot;All JSC options with descriptions:&quot;;
 654             break;
 655         }
 656 
 657         StringBuilder builder;
 658         dumpAllOptions(builder, level, title, nullptr, &quot;   &quot;, &quot;\n&quot;, DumpDefaults);
 659         dataLog(builder.toString());
 660     }
 661 }
 662 
 663 static bool isSeparator(char c)
 664 {
 665     return isASCIISpace(c) || (c == &#39;,&#39;);
 666 }
 667 
 668 bool Options::setOptions(const char* optionsStr)
 669 {
 670     RELEASE_ASSERT(!g_jscConfig.isPermanentlyFrozen);
 671     Vector&lt;char*&gt; options;
 672 
 673     size_t length = strlen(optionsStr);
 674     char* optionsStrCopy = WTF::fastStrDup(optionsStr);
 675     char* end = optionsStrCopy + length;
 676     char* p = optionsStrCopy;
 677 
 678     while (p &lt; end) {
 679         // Skip separators (white space or commas).
 680         while (p &lt; end &amp;&amp; isSeparator(*p))
 681             p++;
 682         if (p == end)
 683             break;
 684 
 685         char* optionStart = p;
 686         p = strstr(p, &quot;=&quot;);
 687         if (!p) {
 688             dataLogF(&quot;&#39;=&#39; not found in option string: %p\n&quot;, optionStart);
 689             WTF::fastFree(optionsStrCopy);
 690             return false;
 691         }
 692         p++;
 693 
 694         char* valueBegin = p;
 695         bool hasStringValue = false;
 696         const int minStringLength = 2; // The min is an empty string i.e. 2 double quotes.
 697         if ((p + minStringLength &lt; end) &amp;&amp; (*p == &#39;&quot;&#39;)) {
 698             p = strstr(p + 1, &quot;\&quot;&quot;);
 699             if (!p) {
 700                 dataLogF(&quot;Missing trailing &#39;\&quot;&#39; in option string: %p\n&quot;, optionStart);
 701                 WTF::fastFree(optionsStrCopy);
 702                 return false; // End of string not found.
 703             }
 704             hasStringValue = true;
 705         }
 706 
 707         // Find next separator (white space or commas).
 708         while (p &lt; end &amp;&amp; !isSeparator(*p))
 709             p++;
 710         if (!p)
 711             p = end; // No more &quot; &quot; separator. Hence, this is the last arg.
 712 
 713         // If we have a well-formed string value, strip the quotes.
 714         if (hasStringValue) {
 715             char* valueEnd = p;
 716             ASSERT((*valueBegin == &#39;&quot;&#39;) &amp;&amp; ((valueEnd - valueBegin) &gt;= minStringLength) &amp;&amp; (valueEnd[-1] == &#39;&quot;&#39;));
 717             memmove(valueBegin, valueBegin + 1, valueEnd - valueBegin - minStringLength);
 718             valueEnd[-minStringLength] = &#39;\0&#39;;
 719         }
 720 
 721         // Strip leading -- if present.
 722         if ((p -  optionStart &gt; 2) &amp;&amp; optionStart[0] == &#39;-&#39; &amp;&amp; optionStart[1] == &#39;-&#39;)
 723             optionStart += 2;
 724 
 725         *p++ = &#39;\0&#39;;
 726         options.append(optionStart);
 727     }
 728 
 729     bool success = true;
 730     for (auto&amp; option : options) {
 731         bool optionSuccess = setOption(option);
 732         if (!optionSuccess) {
 733             dataLogF(&quot;Failed to set option : %s\n&quot;, option);
 734             success = false;
 735         }
 736     }
 737 
 738     correctOptions();
 739 
 740     recomputeDependentOptions();
 741 
 742     dumpOptionsIfNeeded();
 743 
 744     ensureOptionsAreCoherent();
 745 
 746     WTF::fastFree(optionsStrCopy);
 747 
 748     return success;
 749 }
 750 
 751 // Parses a single command line option in the format &quot;&lt;optionName&gt;=&lt;value&gt;&quot;
 752 // (no spaces allowed) and set the specified option if appropriate.
 753 bool Options::setOptionWithoutAlias(const char* arg)
 754 {
 755     // arg should look like this:
 756     //   &lt;jscOptionName&gt;=&lt;appropriate value&gt;
 757     const char* equalStr = strchr(arg, &#39;=&#39;);
 758     if (!equalStr)
 759         return false;
 760 
 761     const char* valueStr = equalStr + 1;
 762 
 763     // For each option, check if the specified arg is a match. If so, set the arg
 764     // if the value makes sense. Otherwise, move on to checking the next option.
 765 #define SET_OPTION_IF_MATCH(type_, name_, defaultValue_, availability_, description_) \
 766     if (strlen(#name_) == static_cast&lt;size_t&gt;(equalStr - arg)      \
 767         &amp;&amp; !strncmp(arg, #name_, equalStr - arg)) {                \
 768         if (Availability::availability_ != Availability::Normal     \
 769             &amp;&amp; !isAvailable(name_##ID, Availability::availability_)) \
 770             return false;                                          \
 771         Optional&lt;OptionsStorage::type_&gt; value;                     \
 772         value = parse&lt;OptionsStorage::type_&gt;(valueStr);            \
 773         if (value) {                                               \
 774             name_() = value.value();                               \
 775             correctOptions();                                      \
 776             recomputeDependentOptions();                           \
 777             return true;                                           \
 778         }                                                          \
 779         return false;                                              \
 780     }
 781 
 782     FOR_EACH_JSC_OPTION(SET_OPTION_IF_MATCH)
 783 #undef SET_OPTION_IF_MATCH
 784 
 785     return false; // No option matched.
 786 }
 787 
 788 static const char* invertBoolOptionValue(const char* valueStr)
 789 {
 790     Optional&lt;OptionsStorage::Bool&gt; value = parse&lt;OptionsStorage::Bool&gt;(valueStr);
 791     if (!value)
 792         return nullptr;
 793     return value.value() ? &quot;false&quot; : &quot;true&quot;;
 794 }
 795 
 796 
 797 bool Options::setAliasedOption(const char* arg)
 798 {
 799     // arg should look like this:
 800     //   &lt;jscOptionName&gt;=&lt;appropriate value&gt;
 801     const char* equalStr = strchr(arg, &#39;=&#39;);
 802     if (!equalStr)
 803         return false;
 804 
 805     IGNORE_WARNINGS_BEGIN(&quot;tautological-compare&quot;)
 806 
 807     // For each option, check if the specify arg is a match. If so, set the arg
 808     // if the value makes sense. Otherwise, move on to checking the next option.
 809 #define FOR_EACH_OPTION(aliasedName_, unaliasedName_, equivalence) \
 810     if (strlen(#aliasedName_) == static_cast&lt;size_t&gt;(equalStr - arg)    \
 811         &amp;&amp; !strncmp(arg, #aliasedName_, equalStr - arg)) {              \
 812         String unaliasedOption(#unaliasedName_);                        \
 813         if (equivalence == SameOption)                                  \
 814             unaliasedOption = unaliasedOption + equalStr;               \
 815         else {                                                          \
 816             ASSERT(equivalence == InvertedOption);                      \
 817             auto* invertedValueStr = invertBoolOptionValue(equalStr + 1); \
 818             if (!invertedValueStr)                                      \
 819                 return false;                                           \
 820             unaliasedOption = unaliasedOption + &quot;=&quot; + invertedValueStr; \
 821         }                                                               \
 822         return setOptionWithoutAlias(unaliasedOption.utf8().data());   \
 823     }
 824 
 825     FOR_EACH_JSC_ALIASED_OPTION(FOR_EACH_OPTION)
 826 #undef FOR_EACH_OPTION
 827 
 828     IGNORE_WARNINGS_END
 829 
 830     return false; // No option matched.
 831 }
 832 
 833 bool Options::setOption(const char* arg)
 834 {
 835     bool success = setOptionWithoutAlias(arg);
 836     if (success)
 837         return true;
 838     return setAliasedOption(arg);
 839 }
 840 
 841 
 842 void Options::dumpAllOptions(StringBuilder&amp; builder, DumpLevel level, const char* title,
 843     const char* separator, const char* optionHeader, const char* optionFooter, DumpDefaultsOption dumpDefaultsOption)
 844 {
 845     if (title) {
 846         builder.append(title);
 847         builder.append(&#39;\n&#39;);
 848     }
 849 
 850     for (size_t id = 0; id &lt; NumberOfOptions; id++) {
 851         if (separator &amp;&amp; id)
 852             builder.append(separator);
 853         dumpOption(builder, level, static_cast&lt;ID&gt;(id), optionHeader, optionFooter, dumpDefaultsOption);
 854     }
 855 }
 856 
 857 void Options::dumpAllOptionsInALine(StringBuilder&amp; builder)
 858 {
 859     dumpAllOptions(builder, DumpLevel::All, nullptr, &quot; &quot;, nullptr, nullptr, DontDumpDefaults);
 860 }
 861 
 862 void Options::dumpAllOptions(FILE* stream, DumpLevel level, const char* title)
 863 {
 864     StringBuilder builder;
 865     dumpAllOptions(builder, level, title, nullptr, &quot;   &quot;, &quot;\n&quot;, DumpDefaults);
 866     fprintf(stream, &quot;%s&quot;, builder.toString().utf8().data());
 867 }
 868 
 869 struct OptionReader {
 870     class Option {
 871     public:
 872         void dump(StringBuilder&amp;) const;
 873 
 874         bool operator==(const Option&amp; other) const;
 875         bool operator!=(const Option&amp; other) const { return !(*this == other); }
 876 
 877         const char* name() const { return Options::s_constMetaData[m_id].name; }
 878         const char* description() const { return Options::s_constMetaData[m_id].description; }
 879         Options::Type type() const { return Options::s_constMetaData[m_id].type; }
 880         Options::Availability availability() const { return Options::s_constMetaData[m_id].availability; }
 881         bool isOverridden() const { return *this != OptionReader::defaultFor(m_id); }
 882 
 883     private:
 884         Option(Options::ID id, void* addressOfValue)
 885             : m_id(id)
 886         {
 887             initValue(addressOfValue);
 888         }
 889 
 890         void initValue(void* addressOfValue);
 891 
 892         Options::ID m_id;
 893         union {
 894             bool m_bool;
 895             unsigned m_unsigned;
 896             double m_double;
 897             int32_t m_int32;
 898             size_t m_size;
 899             OptionRange m_optionRange;
 900             const char* m_optionString;
 901             GCLogging::Level m_gcLogLevel;
 902         };
 903 
 904         friend struct OptionReader;
 905     };
 906 
 907     static const Option optionFor(Options::ID);
 908     static const Option defaultFor(Options::ID);
 909 };
 910 
 911 void Options::dumpOption(StringBuilder&amp; builder, DumpLevel level, Options::ID id,
 912     const char* header, const char* footer, DumpDefaultsOption dumpDefaultsOption)
 913 {
 914     RELEASE_ASSERT(static_cast&lt;size_t&gt;(id) &lt; NumberOfOptions);
 915 
 916     auto option = OptionReader::optionFor(id);
 917     Availability availability = option.availability();
 918     if (availability != Availability::Normal &amp;&amp; !isAvailable(id, availability))
 919         return;
 920 
 921     bool wasOverridden = option.isOverridden();
 922     bool needsDescription = (level == DumpLevel::Verbose &amp;&amp; option.description());
 923 
 924     if (level == DumpLevel::Overridden &amp;&amp; !wasOverridden)
 925         return;
 926 
 927     if (header)
 928         builder.append(header);
 929     builder.append(option.name(), &#39;=&#39;);
 930     option.dump(builder);
 931 
 932     if (wasOverridden &amp;&amp; (dumpDefaultsOption == DumpDefaults)) {
 933         auto defaultOption = OptionReader::defaultFor(id);
 934         builder.appendLiteral(&quot; (default: &quot;);
 935         defaultOption.dump(builder);
 936         builder.appendLiteral(&quot;)&quot;);
 937     }
 938 
 939     if (needsDescription)
 940         builder.append(&quot;   ... &quot;, option.description());
 941 
 942     builder.append(footer);
 943 }
 944 
 945 void Options::ensureOptionsAreCoherent()
 946 {
 947     bool coherent = true;
 948     if (!(useLLInt() || useJIT())) {
 949         coherent = false;
 950         dataLog(&quot;INCOHERENT OPTIONS: at least one of useLLInt or useJIT must be true\n&quot;);
 951     }
 952     if (!coherent)
 953         CRASH();
 954 }
 955 
 956 const OptionReader::Option OptionReader::optionFor(Options::ID id)
 957 {
 958     return Option(id, Options::addressOfOption(id));
 959 }
 960 
 961 const OptionReader::Option OptionReader::defaultFor(Options::ID id)
 962 {
 963     return Option(id, Options::addressOfOptionDefault(id));
 964 }
 965 
 966 void OptionReader::Option::initValue(void* addressOfValue)
 967 {
 968     Options::Type type = Options::s_constMetaData[m_id].type;
 969     switch (type) {
 970     case Options::Type::Bool:
 971         memcpy(&amp;m_bool, addressOfValue, sizeof(OptionsStorage::Bool));
 972         break;
 973     case Options::Type::Unsigned:
 974         memcpy(&amp;m_unsigned, addressOfValue, sizeof(OptionsStorage::Unsigned));
 975         break;
 976     case Options::Type::Double:
 977         memcpy(&amp;m_double, addressOfValue, sizeof(OptionsStorage::Double));
 978         break;
 979     case Options::Type::Int32:
 980         memcpy(&amp;m_int32, addressOfValue, sizeof(OptionsStorage::Int32));
 981         break;
 982     case Options::Type::Size:
 983         memcpy(&amp;m_size, addressOfValue, sizeof(OptionsStorage::Size));
 984         break;
 985     case Options::Type::OptionRange:
 986         memcpy(&amp;m_optionRange, addressOfValue, sizeof(OptionsStorage::OptionRange));
 987         break;
 988     case Options::Type::OptionString:
 989         memcpy(&amp;m_optionString, addressOfValue, sizeof(OptionsStorage::OptionString));
 990         break;
 991     case Options::Type::GCLogLevel:
 992         memcpy(&amp;m_gcLogLevel, addressOfValue, sizeof(OptionsStorage::GCLogLevel));
 993         break;
 994     }
 995 }
 996 
 997 void OptionReader::Option::dump(StringBuilder&amp; builder) const
 998 {
 999     switch (type()) {
1000     case Options::Type::Bool:
1001         builder.append(m_bool ? &quot;true&quot; : &quot;false&quot;);
1002         break;
1003     case Options::Type::Unsigned:
1004         builder.appendNumber(m_unsigned);
1005         break;
1006     case Options::Type::Size:
1007         builder.appendNumber(m_size);
1008         break;
1009     case Options::Type::Double:
1010         builder.append(m_double);
1011         break;
1012     case Options::Type::Int32:
1013         builder.appendNumber(m_int32);
1014         break;
1015     case Options::Type::OptionRange:
1016         builder.append(m_optionRange.rangeString());
1017         break;
1018     case Options::Type::OptionString: {
1019         const char* option = m_optionString;
1020         if (!option)
1021             option = &quot;&quot;;
1022         builder.append(&#39;&quot;&#39;);
1023         builder.append(option);
1024         builder.append(&#39;&quot;&#39;);
1025         break;
1026     }
1027     case Options::Type::GCLogLevel: {
1028         builder.append(GCLogging::levelAsString(m_gcLogLevel));
1029         break;
1030     }
1031     }
1032 }
1033 
1034 bool OptionReader::Option::operator==(const Option&amp; other) const
1035 {
1036     ASSERT(type() == other.type());
1037     switch (type()) {
1038     case Options::Type::Bool:
1039         return m_bool == other.m_bool;
1040     case Options::Type::Unsigned:
1041         return m_unsigned == other.m_unsigned;
1042     case Options::Type::Size:
1043         return m_size == other.m_size;
1044     case Options::Type::Double:
1045         return (m_double == other.m_double) || (std::isnan(m_double) &amp;&amp; std::isnan(other.m_double));
1046     case Options::Type::Int32:
1047         return m_int32 == other.m_int32;
1048     case Options::Type::OptionRange:
1049         return m_optionRange.rangeString() == other.m_optionRange.rangeString();
1050     case Options::Type::OptionString:
1051         return (m_optionString == other.m_optionString)
1052             || (m_optionString &amp;&amp; other.m_optionString &amp;&amp; !strcmp(m_optionString, other.m_optionString));
1053     case Options::Type::GCLogLevel:
1054         return m_gcLogLevel == other.m_gcLogLevel;
1055     }
1056     return false;
1057 }
1058 
1059 } // namespace JSC
    </pre>
  </body>
</html>
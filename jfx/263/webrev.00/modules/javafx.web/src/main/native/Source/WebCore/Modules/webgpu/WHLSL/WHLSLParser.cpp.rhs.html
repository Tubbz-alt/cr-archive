<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WHLSLParser.h&quot;
  28 
  29 #if ENABLE(WEBGPU)
  30 
  31 #include &quot;WHLSLAddressSpace.h&quot;
  32 #include &quot;WHLSLEntryPointType.h&quot;
  33 #include &quot;WHLSLProgram.h&quot;
  34 #include &lt;wtf/dtoa.h&gt;
  35 #include &lt;wtf/text/StringBuilder.h&gt;
  36 #include &lt;wtf/text/StringConcatenate.h&gt;
  37 
  38 namespace WebCore {
  39 
  40 namespace WHLSL {
  41 
  42 #define PARSE(name, element, ...) \
  43     auto name = parse##element(__VA_ARGS__); \
  44     if (!name) \
  45         return makeUnexpected(name.error()); \
  46 
  47 #define CONSUME_TYPE(name, type) \
  48     auto name = consumeType(Token::Type::type); \
  49     if (!name) \
  50         return makeUnexpected(name.error());
  51 
  52 #define PEEK(name) \
  53     auto name = peek(); \
  54     if (!name) \
  55         return makeUnexpected(name.error());
  56 
  57 #define PEEK_FURTHER(name) \
  58     auto name = peekFurther(); \
  59     if (!name) \
  60         return makeUnexpected(name.error());
  61 
  62 auto Parser::parse(Program&amp; program, StringView stringView, ParsingMode mode, AST::NameSpace nameSpace) -&gt; Expected&lt;void, Error&gt;
  63 {
  64     m_lexer = Lexer(stringView, nameSpace);
  65     m_mode = mode;
  66 
  67     while (!m_lexer.isFullyConsumed()) {
  68         auto token = m_lexer.peek();
  69         switch (token.type) {
  70         case Token::Type::Invalid:
  71             return { };
  72         case Token::Type::Semicolon:
  73             m_lexer.consumeToken();
  74             continue;
  75         case Token::Type::Typedef: {
  76             auto typeDefinition = parseTypeDefinition();
  77             if (!typeDefinition)
  78                 return makeUnexpected(typeDefinition.error());
  79             auto appendResult = program.append(WTFMove(*typeDefinition));
  80             if (!appendResult)
  81                 return makeUnexpected(appendResult.error());
  82             continue;
  83         }
  84         case Token::Type::Struct: {
  85             auto structureDefinition = parseStructureDefinition();
  86             if (!structureDefinition)
  87                 return makeUnexpected(structureDefinition.error());
  88             auto appendResult = program.append(WTFMove(*structureDefinition));
  89             if (!appendResult)
  90                 return makeUnexpected(appendResult.error());
  91             continue;
  92         }
  93         case Token::Type::Enum: {
  94             auto enumerationDefinition = parseEnumerationDefinition();
  95             if (!enumerationDefinition)
  96                 return makeUnexpected(enumerationDefinition.error());
  97             auto appendResult = program.append(WTFMove(*enumerationDefinition));
  98             if (!appendResult)
  99                 return makeUnexpected(appendResult.error());
 100             continue;
 101         }
 102         case Token::Type::Native: {
 103             if (m_mode != ParsingMode::StandardLibrary)
 104                 return fail(makeString(&quot;&#39;native&#39; can&#39;t exist outside of the standard library.&quot;));
 105             auto furtherToken = peekFurther();
 106             if (!furtherToken)
 107                 return { };
 108             if (furtherToken-&gt;type == Token::Type::Typedef) {
 109                 auto nativeTypeDeclaration = parseNativeTypeDeclaration();
 110                 if (!nativeTypeDeclaration)
 111                     return makeUnexpected(nativeTypeDeclaration.error());
 112                 auto appendResult = program.append(WTFMove(*nativeTypeDeclaration));
 113                 if (!appendResult)
 114                     return makeUnexpected(appendResult.error());
 115                 continue;
 116             }
 117             auto nativeFunctionDeclaration = parseNativeFunctionDeclaration();
 118             if (!nativeFunctionDeclaration)
 119                 return makeUnexpected(nativeFunctionDeclaration.error());
 120             auto appendResult = program.append(WTFMove(*nativeFunctionDeclaration));
 121             if (!appendResult)
 122                 return makeUnexpected(appendResult.error());
 123             continue;
 124         }
 125         default: {
 126             auto functionDefinition = parseFunctionDefinition();
 127             if (!functionDefinition)
 128                 return makeUnexpected(functionDefinition.error());
 129             auto appendResult = program.append(WTFMove(*functionDefinition));
 130             if (!appendResult)
 131                 return makeUnexpected(appendResult.error());
 132             continue;
 133         }
 134         }
 135     }
 136 
 137     return { };
 138 }
 139 
 140 auto Parser::fail(const String&amp; message, TryToPeek tryToPeek) -&gt; Unexpected&lt;Error&gt;
 141 {
 142     if (tryToPeek == TryToPeek::Yes) {
 143         if (auto nextToken = peek())
 144             return makeUnexpected(Error(m_lexer.errorString(*nextToken, message)));
 145     }
 146     return makeUnexpected(Error(makeString(&quot;Cannot lex: &quot;, message)));
 147 }
 148 
 149 auto Parser::peek() -&gt; Expected&lt;Token, Error&gt;
 150 {
 151     auto token = m_lexer.peek();
 152     if (token.type != Token::Type::Invalid &amp;&amp; token.type != Token::Type::EndOfFile)
 153         return { token };
 154     return fail(&quot;Cannot consume token&quot;_str, TryToPeek::No);
 155 }
 156 
 157 auto Parser::peekFurther() -&gt; Expected&lt;Token, Error&gt;
 158 {
 159     auto token = m_lexer.peekFurther();
 160     if (token.type != Token::Type::Invalid &amp;&amp; token.type != Token::Type::EndOfFile)
 161         return { token };
 162     return fail(&quot;Cannot consume two tokens&quot;_str, TryToPeek::No);
 163 }
 164 
 165 template &lt;Token::Type t, Token::Type... ts&gt;
 166 struct Types {
 167     static bool includes(Token::Type type)
 168     {
 169         return t == type || Types&lt;ts...&gt;::includes(type);
 170     }
 171 
 172     static void appendNameTo(StringBuilder&amp; builder)
 173     {
 174         builder.append(Token::typeName(t), &quot;, &quot;);
 175         Types&lt;ts...&gt;::appendNameTo(builder);
 176     }
 177 };
 178 template &lt;Token::Type t&gt;
 179 struct Types&lt;t&gt; {
 180     static bool includes(Token::Type type)
 181     {
 182         return t == type;
 183     }
 184 
 185     static void appendNameTo(StringBuilder&amp; builder)
 186     {
 187         builder.append(Token::typeName(t));
 188     }
 189 };
 190 
 191 
 192 bool Parser::peekType(Token::Type type)
 193 {
 194     auto token = m_lexer.peek();
 195     return token.type == type;
 196 }
 197 
 198 template &lt;Token::Type... types&gt;
 199 bool Parser::peekTypes()
 200 {
 201     auto token = m_lexer.peek();
 202     return Types&lt;types...&gt;::includes(token.type);
 203 }
 204 
 205 Optional&lt;Token&gt; Parser::tryType(Token::Type type)
 206 {
 207     auto token = m_lexer.peek();
 208     if (token.type == type)
 209         return { m_lexer.consumeToken() };
 210     return WTF::nullopt;
 211 }
 212 
 213 template &lt;Token::Type... types&gt;
 214 Optional&lt;Token&gt; Parser::tryTypes()
 215 {
 216     auto token = m_lexer.peek();
 217     if (Types&lt;types...&gt;::includes(token.type))
 218         return { m_lexer.consumeToken() };
 219     return WTF::nullopt;
 220 }
 221 
 222 auto Parser::consumeType(Token::Type type) -&gt; Expected&lt;Token, Error&gt;
 223 {
 224     auto token = m_lexer.consumeToken();
 225     if (token.type == type)
 226         return { token };
 227     return fail(makeString(&quot;Unexpected token (expected &quot;, Token::typeName(type), &quot; got &quot;, Token::typeName(token.type), &quot;)&quot;));
 228 }
 229 
 230 template &lt;Token::Type... types&gt;
 231 auto Parser::consumeTypes() -&gt; Expected&lt;Token, Error&gt;
 232 {
 233     auto buildExpectedString = [&amp;]() -&gt; String {
 234         StringBuilder builder;
 235         builder.append(&quot;[&quot;);
 236         Types&lt;types...&gt;::appendNameTo(builder);
 237         builder.append(&quot;]&quot;);
 238         return builder.toString();
 239     };
 240 
 241     auto token = m_lexer.consumeToken();
 242     if (Types&lt;types...&gt;::includes(token.type))
 243         return { token };
 244     return fail(makeString(&quot;Unexpected token (expected one of &quot;, buildExpectedString(), &quot; got &quot;, Token::typeName(token.type), &quot;)&quot;));
 245 }
 246 
 247 static int digitValue(UChar character)
 248 {
 249     if (character &gt;= &#39;0&#39; &amp;&amp; character &lt;= &#39;9&#39;)
 250         return character - &#39;0&#39;;
 251     if (character &gt;= &#39;a&#39; &amp;&amp; character &lt;= &#39;f&#39;)
 252         return character - &#39;a&#39; + 10;
 253     return character - &#39;A&#39; + 10;
 254 }
 255 
 256 static Expected&lt;int, Error&gt; intLiteralToInt(StringView text)
 257 {
 258     bool negate = false;
 259     if (text.startsWith(&quot;-&quot;_str)) {
 260         negate = true;
 261         text = text.substring(1);
 262     }
 263     int base = 10;
 264     if (text.startsWith(&quot;0x&quot;_str)) {
 265         text = text.substring(2);
 266         base = 16;
 267     }
 268 
 269     unsigned result = 0;
 270     for (auto codePoint : text.codePoints()) {
 271         unsigned digit = digitValue(codePoint);
 272         auto previous = result;
 273         result = result * base + digit;
 274         if (result &lt; previous)
 275             return makeUnexpected(Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));
 276     }
 277     if (negate) {
 278         static_assert(sizeof(int64_t) &gt; sizeof(unsigned) &amp;&amp; sizeof(int64_t) &gt; sizeof(int), &quot;This code would be wrong otherwise&quot;);
 279         int64_t intResult = -static_cast&lt;int64_t&gt;(result);
 280         if (intResult &lt; static_cast&lt;int64_t&gt;(std::numeric_limits&lt;int&gt;::min()))
 281             return makeUnexpected(Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));
 282         return { static_cast&lt;int&gt;(intResult) };
 283     }
 284     if (result &gt; static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()))
 285         return makeUnexpected(Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));
 286     return { static_cast&lt;int&gt;(result) };
 287 }
 288 
 289 static Expected&lt;unsigned, Error&gt; uintLiteralToUint(StringView text)
 290 {
 291     unsigned base = 10;
 292     if (text.startsWith(&quot;0x&quot;_str)) {
 293         text = text.substring(2);
 294         base = 16;
 295     }
 296     ASSERT(text.endsWith(&quot;u&quot;));
 297     text = text.substring(0, text.length() - 1);
 298     unsigned result = 0;
 299     for (auto codePoint : text.codePoints()) {
 300         unsigned digit = digitValue(codePoint);
 301         auto previous = result;
 302         result = result * base + digit;
 303         if (result &lt; previous)
 304             return makeUnexpected(Error(makeString(&quot;uint literal &quot;, text, &quot; is out of bounds&quot;)));
 305     }
 306     return { result };
 307 }
 308 
 309 static Expected&lt;float, Error&gt; floatLiteralToFloat(StringView text)
 310 {
 311     size_t parsedLength;
 312     auto result = parseDouble(text, parsedLength);
 313     if (parsedLength != text.length())
 314         return makeUnexpected(Error(makeString(&quot;Cannot parse float &quot;, text)));
 315     return static_cast&lt;float&gt;(result);
 316 }
 317 
 318 auto Parser::consumeIntegralLiteral() -&gt; Expected&lt;Variant&lt;int, unsigned&gt;, Error&gt;
 319 {
 320     auto integralLiteralToken = consumeTypes&lt;Token::Type::IntLiteral, Token::Type::UintLiteral&gt;();
 321     if (!integralLiteralToken)
 322         return makeUnexpected(integralLiteralToken.error());
 323 
 324     switch (integralLiteralToken-&gt;type) {
 325     case Token::Type::IntLiteral: {
 326         auto result = intLiteralToInt(integralLiteralToken-&gt;stringView(m_lexer));
 327         if (result)
 328             return {{ *result }};
 329         return makeUnexpected(result.error());
 330     }
 331     default: {
 332         ASSERT(integralLiteralToken-&gt;type == Token::Type::UintLiteral);
 333         auto result = uintLiteralToUint(integralLiteralToken-&gt;stringView(m_lexer));
 334         if (result)
 335             return {{ *result }};
 336         return makeUnexpected(result.error());
 337     }
 338     }
 339 }
 340 
 341 auto Parser::consumeNonNegativeIntegralLiteral() -&gt; Expected&lt;unsigned, Error&gt;
 342 {
 343     auto integralLiteral = consumeIntegralLiteral();
 344     if (!integralLiteral)
 345         return makeUnexpected(integralLiteral.error());
 346     auto result = WTF::visit(WTF::makeVisitor([](int x) -&gt; Optional&lt;unsigned&gt; {
 347         if (x &lt; 0)
 348             return WTF::nullopt;
 349         return x;
 350     }, [](unsigned x) -&gt; Optional&lt;unsigned&gt; {
 351         return x;
 352     }), *integralLiteral);
 353     if (result)
 354         return *result;
 355     return fail(&quot;int literal is negative&quot;_str);
 356 }
 357 
 358 static Expected&lt;unsigned, Error&gt; recognizeSimpleUnsignedInteger(StringView stringView)
 359 {
 360     unsigned result = 0;
 361     if (stringView.length() &lt; 1)
 362         return makeUnexpected(Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; is too short&quot;)));
 363     for (auto codePoint : stringView.codePoints()) {
 364         if (codePoint &lt; &#39;0&#39; || codePoint &gt; &#39;9&#39;)
 365             return makeUnexpected(Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; isn&#39;t of the form [0-9]+&quot;)));
 366         auto previous = result;
 367         result = result * 10 + (codePoint - &#39;0&#39;);
 368         if (result &lt; previous)
 369             return makeUnexpected(Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; is out of bounds&quot;)));
 370     }
 371     return result;
 372 }
 373 
 374 auto Parser::parseConstantExpression() -&gt; Expected&lt;AST::ConstantExpression, Error&gt;
 375 {
 376     auto type = consumeTypes&lt;
 377         Token::Type::IntLiteral,
 378         Token::Type::UintLiteral,
 379         Token::Type::FloatLiteral,
 380         Token::Type::Null,
 381         Token::Type::True,
 382         Token::Type::False,
 383         Token::Type::Identifier&gt;();
 384     if (!type)
 385         return makeUnexpected(type.error());
 386 
 387     switch (type-&gt;type) {
 388     case Token::Type::IntLiteral: {
 389         auto value = intLiteralToInt(type-&gt;stringView(m_lexer));
 390         if (!value)
 391             return makeUnexpected(value.error());
 392         return {{ AST::IntegerLiteral({ *type }, *value) }};
 393     }
 394     case Token::Type::UintLiteral: {
 395         auto value = uintLiteralToUint(type-&gt;stringView(m_lexer));
 396         if (!value)
 397             return makeUnexpected(value.error());
 398         return {{ AST::UnsignedIntegerLiteral({ *type }, *value) }};
 399     }
 400     case Token::Type::FloatLiteral: {
 401         auto value = floatLiteralToFloat(type-&gt;stringView(m_lexer));
 402         if (!value)
 403             return makeUnexpected(value.error());
 404         return {{ AST::FloatLiteral({ *type }, *value) }};
 405     }
<a name="1" id="anc1"></a>

 406     case Token::Type::True:
 407         return { AST::BooleanLiteral(WTFMove(*type), true) };
 408     case Token::Type::False:
 409         return { AST::BooleanLiteral(WTFMove(*type), false) };
 410     default: {
 411         ASSERT(type-&gt;type == Token::Type::Identifier);
 412         CONSUME_TYPE(fullStop, FullStop);
 413         CONSUME_TYPE(next, Identifier);
 414         return { AST::EnumerationMemberLiteral({ *type, *next }, type-&gt;stringView(m_lexer).toString(), next-&gt;stringView(m_lexer).toString()) };
 415     }
 416     }
 417 }
 418 
 419 auto Parser::parseTypeArgument() -&gt; Expected&lt;AST::TypeArgument, Error&gt;
 420 {
 421     PEEK(nextToken);
 422     PEEK_FURTHER(furtherToken);
 423     if (nextToken-&gt;type != Token::Type::Identifier || furtherToken-&gt;type == Token::Type::FullStop) {
 424         PARSE(constantExpression, ConstantExpression);
 425         return AST::TypeArgument(WTFMove(*constantExpression));
 426     }
 427     CONSUME_TYPE(result, Identifier);
 428     CodeLocation location(*result);
 429     return AST::TypeArgument(AST::TypeReference::create(location, result-&gt;stringView(m_lexer).toString(), AST::TypeArguments()));
 430 }
 431 
 432 auto Parser::parseTypeArguments() -&gt; Expected&lt;AST::TypeArguments, Error&gt;
 433 {
 434     AST::TypeArguments typeArguments;
 435     auto lessThanSign = tryType(Token::Type::LessThanSign);
 436     if (!lessThanSign)
 437         return typeArguments;
 438 
 439     auto greaterThanSign = tryType(Token::Type::GreaterThanSign);
 440     if (greaterThanSign)
 441         return typeArguments;
 442 
 443     PARSE(typeArgument, TypeArgument);
 444     typeArguments.append(WTFMove(*typeArgument));
 445 
 446     while (true) {
 447         auto greaterThanSign = tryType(Token::Type::GreaterThanSign);
 448         if (greaterThanSign)
 449             break;
 450 
 451         CONSUME_TYPE(comma, Comma);
 452         PARSE(typeArgument, TypeArgument);
 453         typeArguments.append(WTFMove(*typeArgument));
 454     }
 455 
 456     return typeArguments;
 457 }
 458 
 459 auto Parser::parseTypeSuffixAbbreviated() -&gt; Expected&lt;TypeSuffixAbbreviated, Error&gt;
 460 {
 461     auto token = consumeTypes&lt;
 462         Token::Type::Star,
 463         Token::Type::SquareBracketPair,
 464         Token::Type::LeftSquareBracket&gt;();
 465     if (!token)
 466         return makeUnexpected(token.error());
 467     if (token-&gt;type == Token::Type::LeftSquareBracket) {
 468         auto numElements = consumeNonNegativeIntegralLiteral();
 469         if (!numElements)
 470             return makeUnexpected(numElements.error());
 471         CONSUME_TYPE(rightSquareBracket, RightSquareBracket);
 472         return {{ { *token, *rightSquareBracket }, *token, *numElements }};
 473     }
 474     return {{ { *token }, *token, WTF::nullopt }};
 475 }
 476 
 477 auto Parser::parseTypeSuffixNonAbbreviated() -&gt; Expected&lt;TypeSuffixNonAbbreviated, Error&gt;
 478 {
 479     auto token = consumeTypes&lt;
 480         Token::Type::Star,
 481         Token::Type::SquareBracketPair,
 482         Token::Type::LeftSquareBracket&gt;();
 483     if (!token)
 484         return makeUnexpected(token.error());
 485     if (token-&gt;type == Token::Type::LeftSquareBracket) {
 486         auto numElements = consumeNonNegativeIntegralLiteral();
 487         if (!numElements)
 488             return makeUnexpected(numElements.error());
 489         CONSUME_TYPE(rightSquareBracket, RightSquareBracket);
 490         return {{ { *token, *rightSquareBracket }, *token, WTF::nullopt, *numElements }};
 491     }
 492     auto addressSpaceToken = consumeTypes&lt;
 493         Token::Type::Constant,
 494         Token::Type::Device,
 495         Token::Type::Threadgroup,
 496         Token::Type::Thread&gt;();
 497     if (!addressSpaceToken)
 498         return makeUnexpected(addressSpaceToken.error());
 499     AST::AddressSpace addressSpace;
 500     switch (addressSpaceToken-&gt;type) {
 501     case Token::Type::Constant:
 502         addressSpace = AST::AddressSpace::Constant;
 503         break;
 504     case Token::Type::Device:
 505         addressSpace = AST::AddressSpace::Device;
 506         break;
 507     case Token::Type::Threadgroup:
 508         addressSpace = AST::AddressSpace::Threadgroup;
 509         break;
 510     default:
 511         ASSERT(addressSpaceToken-&gt;type == Token::Type::Thread);
 512         addressSpace = AST::AddressSpace::Thread;
 513         break;
 514     }
 515     return {{ { *token }, *token, { addressSpace }, WTF::nullopt }};
 516 }
 517 
 518 auto Parser::parseType() -&gt; Expected&lt;Ref&lt;AST::UnnamedType&gt;, Error&gt;
 519 {
 520     auto addressSpaceToken = tryTypes&lt;
 521         Token::Type::Constant,
 522         Token::Type::Device,
 523         Token::Type::Threadgroup,
 524         Token::Type::Thread&gt;();
 525 
 526     CONSUME_TYPE(name, Identifier);
 527     PARSE(typeArguments, TypeArguments);
 528 
 529     if (addressSpaceToken) {
 530         AST::AddressSpace addressSpace;
 531         switch (addressSpaceToken-&gt;type) {
 532         case Token::Type::Constant:
 533             addressSpace = AST::AddressSpace::Constant;
 534             break;
 535         case Token::Type::Device:
 536             addressSpace = AST::AddressSpace::Device;
 537             break;
 538         case Token::Type::Threadgroup:
 539             addressSpace = AST::AddressSpace::Threadgroup;
 540             break;
 541         default:
 542             ASSERT(addressSpaceToken-&gt;type == Token::Type::Thread);
 543             addressSpace = AST::AddressSpace::Thread;
 544             break;
 545         }
 546         auto constructTypeFromSuffixAbbreviated = [&amp;](const TypeSuffixAbbreviated&amp; typeSuffixAbbreviated, Ref&lt;AST::UnnamedType&gt;&amp;&amp; previous) -&gt; Ref&lt;AST::UnnamedType&gt; {
 547             CodeLocation location(*addressSpaceToken, typeSuffixAbbreviated.location);
 548             switch (typeSuffixAbbreviated.token.type) {
 549             case Token::Type::Star:
 550                 return { AST::PointerType::create(location, addressSpace, WTFMove(previous)) };
 551             case Token::Type::SquareBracketPair:
 552                 return { AST::ArrayReferenceType::create(location, addressSpace, WTFMove(previous)) };
 553             default:
 554                 ASSERT(typeSuffixAbbreviated.token.type == Token::Type::LeftSquareBracket);
 555                 return { AST::ArrayType::create(location, WTFMove(previous), *typeSuffixAbbreviated.numElements) };
 556             }
 557         };
 558         PARSE(firstTypeSuffixAbbreviated, TypeSuffixAbbreviated);
 559         Ref&lt;AST::UnnamedType&gt; result = AST::TypeReference::create(WTFMove(*addressSpaceToken), name-&gt;stringView(m_lexer).toString(), WTFMove(*typeArguments));
 560         auto next = constructTypeFromSuffixAbbreviated(*firstTypeSuffixAbbreviated, WTFMove(result));
 561         result = WTFMove(next);
 562         while (true) {
 563             PEEK(nextToken);
 564             if (nextToken-&gt;type != Token::Type::Star
 565                 &amp;&amp; nextToken-&gt;type != Token::Type::SquareBracketPair
 566                 &amp;&amp; nextToken-&gt;type != Token::Type::LeftSquareBracket) {
 567                 break;
 568             }
 569             PARSE(typeSuffixAbbreviated, TypeSuffixAbbreviated);
 570             // FIXME: The nesting here might be in the wrong order.
 571             next = constructTypeFromSuffixAbbreviated(*typeSuffixAbbreviated, WTFMove(result));
 572             result = WTFMove(next);
 573         }
 574         return WTFMove(result);
 575     }
 576 
 577     auto constructTypeFromSuffixNonAbbreviated = [&amp;](const TypeSuffixNonAbbreviated&amp; typeSuffixNonAbbreviated, Ref&lt;AST::UnnamedType&gt;&amp;&amp; previous) -&gt; Ref&lt;AST::UnnamedType&gt; {
 578         CodeLocation location(*name, typeSuffixNonAbbreviated.location);
 579         switch (typeSuffixNonAbbreviated.token.type) {
 580         case Token::Type::Star:
 581             return { AST::PointerType::create(location, *typeSuffixNonAbbreviated.addressSpace, WTFMove(previous)) };
 582         case Token::Type::SquareBracketPair:
 583             return { AST::ArrayReferenceType::create(location, *typeSuffixNonAbbreviated.addressSpace, WTFMove(previous)) };
 584         default:
 585             ASSERT(typeSuffixNonAbbreviated.token.type == Token::Type::LeftSquareBracket);
 586             return { AST::ArrayType::create(location, WTFMove(previous), *typeSuffixNonAbbreviated.numElements) };
 587         }
 588     };
 589     Ref&lt;AST::UnnamedType&gt; result = AST::TypeReference::create(*name, name-&gt;stringView(m_lexer).toString(), WTFMove(*typeArguments));
 590     while (true) {
 591         PEEK(nextToken);
 592         if (nextToken-&gt;type != Token::Type::Star
 593             &amp;&amp; nextToken-&gt;type != Token::Type::SquareBracketPair
 594             &amp;&amp; nextToken-&gt;type != Token::Type::LeftSquareBracket) {
 595             break;
 596         }
 597         PARSE(typeSuffixNonAbbreviated, TypeSuffixNonAbbreviated);
 598         // FIXME: The nesting here might be in the wrong order.
 599         auto next = constructTypeFromSuffixNonAbbreviated(*typeSuffixNonAbbreviated, WTFMove(result));
 600         result = WTFMove(next);
 601     }
 602     return WTFMove(result);
 603 }
 604 
 605 auto Parser::parseTypeDefinition() -&gt; Expected&lt;AST::TypeDefinition, Error&gt;
 606 {
 607     CONSUME_TYPE(origin, Typedef);
 608     CONSUME_TYPE(name, Identifier);
 609     CONSUME_TYPE(equals, EqualsSign);
 610     PARSE(type, Type);
 611     CONSUME_TYPE(semicolon, Semicolon);
 612     return AST::TypeDefinition({ *origin, *semicolon }, name-&gt;stringView(m_lexer).toString(), WTFMove(*type));
 613 }
 614 
 615 auto Parser::parseBuiltInSemantic() -&gt; Expected&lt;AST::BuiltInSemantic, Error&gt;
 616 {
 617     auto origin = consumeTypes&lt;
 618         Token::Type::SVInstanceID,
 619         Token::Type::SVVertexID,
 620         Token::Type::PSize,
 621         Token::Type::SVPosition,
 622         Token::Type::SVIsFrontFace,
 623         Token::Type::SVSampleIndex,
 624         Token::Type::SVInnerCoverage,
 625         Token::Type::SVTarget,
 626         Token::Type::SVDepth,
 627         Token::Type::SVCoverage,
 628         Token::Type::SVDispatchThreadID,
 629         Token::Type::SVGroupID,
 630         Token::Type::SVGroupIndex,
 631         Token::Type::SVGroupThreadID&gt;();
 632     if (!origin)
 633         return makeUnexpected(origin.error());
 634 
 635     switch (origin-&gt;type) {
 636     case Token::Type::SVInstanceID:
 637         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVInstanceID);
 638     case Token::Type::SVVertexID:
 639         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVVertexID);
 640     case Token::Type::PSize:
 641         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::PSize);
 642     case Token::Type::SVPosition:
 643         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVPosition);
 644     case Token::Type::SVIsFrontFace:
 645         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVIsFrontFace);
 646     case Token::Type::SVSampleIndex:
 647         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVSampleIndex);
 648     case Token::Type::SVInnerCoverage:
 649         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVInnerCoverage);
 650     case Token::Type::SVTarget: {
 651         auto target = consumeNonNegativeIntegralLiteral(); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195807 Make this work with strings like &quot;SV_Target0&quot;.
 652         if (!target)
 653             return makeUnexpected(target.error());
 654         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVTarget, *target);
 655     }
 656     case Token::Type::SVDepth:
 657         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVDepth);
 658     case Token::Type::SVCoverage:
 659         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVCoverage);
 660     case Token::Type::SVDispatchThreadID:
 661         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVDispatchThreadID);
 662     case Token::Type::SVGroupID:
 663         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVGroupID);
 664     case Token::Type::SVGroupIndex:
 665         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVGroupIndex);
 666     default:
 667         ASSERT(origin-&gt;type == Token::Type::SVGroupThreadID);
 668         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVGroupThreadID);
 669     }
 670 }
 671 
 672 auto Parser::parseResourceSemantic() -&gt; Expected&lt;AST::ResourceSemantic, Error&gt;
 673 {
 674     CONSUME_TYPE(origin, Register);
 675     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
 676 
 677     CONSUME_TYPE(info, Identifier);
 678     auto infoStringView = info-&gt;stringView(m_lexer);
 679     if (infoStringView.length() &lt; 2 || (infoStringView[0] != &#39;u&#39;
 680         &amp;&amp; infoStringView[0] != &#39;t&#39;
 681         &amp;&amp; infoStringView[0] != &#39;b&#39;
 682         &amp;&amp; infoStringView[0] != &#39;s&#39;))
 683         return makeUnexpected(Error(makeString(infoStringView.substring(0, 1), &quot; is not a known resource type (&#39;u&#39;, &#39;t&#39;, &#39;b&#39;, or &#39;s&#39;)&quot;)));
 684 
 685     AST::ResourceSemantic::Mode mode;
 686     switch (infoStringView[0]) {
 687     case &#39;u&#39;:
 688         mode = AST::ResourceSemantic::Mode::UnorderedAccessView;
 689         break;
 690     case &#39;t&#39;:
 691         mode = AST::ResourceSemantic::Mode::Texture;
 692         break;
 693     case &#39;b&#39;:
 694         mode = AST::ResourceSemantic::Mode::Buffer;
 695         break;
 696     case &#39;s&#39;:
 697         mode = AST::ResourceSemantic::Mode::Sampler;
 698         break;
<a name="2" id="anc2"></a><span class="line-added"> 699     default:</span>
<span class="line-added"> 700         RELEASE_ASSERT_NOT_REACHED();</span>
 701     }
 702 
 703     auto index = recognizeSimpleUnsignedInteger(infoStringView.substring(1));
 704     if (!index)
 705         return makeUnexpected(index.error());
 706 
 707     unsigned space = 0;
 708     if (tryType(Token::Type::Comma)) {
 709         CONSUME_TYPE(spaceToken, Identifier);
 710         auto spaceTokenStringView = spaceToken-&gt;stringView(m_lexer);
 711         StringView prefix { &quot;space&quot; };
 712         if (!spaceTokenStringView.startsWith(prefix))
 713             return makeUnexpected(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceTokenStringView, &quot; needs be of the form &#39;space0&#39;&quot;)));
 714         if (spaceTokenStringView.length() &lt;= prefix.length())
 715             return makeUnexpected(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceTokenStringView, &quot; needs be of the form &#39;space0&#39;&quot;)));
 716         auto spaceValue = recognizeSimpleUnsignedInteger(spaceTokenStringView.substring(prefix.length()));
 717         if (!spaceValue)
 718             return makeUnexpected(spaceValue.error());
 719         space = *spaceValue;
 720     }
 721 
 722     CONSUME_TYPE(rightParenthesis, RightParenthesis);
 723 
 724     return AST::ResourceSemantic({ *origin, *rightParenthesis }, mode, *index, space);
 725 }
 726 
 727 auto Parser::parseSpecializationConstantSemantic() -&gt; Expected&lt;AST::SpecializationConstantSemantic, Error&gt;
 728 {
 729     CONSUME_TYPE(origin, Specialized);
 730     return AST::SpecializationConstantSemantic(*origin);
 731 }
 732 
 733 auto Parser::parseStageInOutSemantic() -&gt; Expected&lt;AST::StageInOutSemantic, Error&gt;
 734 {
 735     CONSUME_TYPE(origin, Attribute);
 736     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
 737 
 738     auto index = consumeNonNegativeIntegralLiteral();
 739     if (!index)
 740         return makeUnexpected(index.error());
 741 
 742     CONSUME_TYPE(rightParenthesis, RightParenthesis);
 743 
 744     return AST::StageInOutSemantic({ *origin, *rightParenthesis }, *index);
 745 }
 746 
 747 auto Parser::parseSemantic() -&gt; Expected&lt;std::unique_ptr&lt;AST::Semantic&gt;, Error&gt;
 748 {
 749     if (!tryType(Token::Type::Colon))
 750         return { nullptr };
 751 
 752     PEEK(token);
 753     switch (token-&gt;type) {
 754     case Token::Type::Attribute: {
 755         PARSE(result, StageInOutSemantic);
 756         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };
 757     }
 758     case Token::Type::Specialized:  {
 759         PARSE(result, SpecializationConstantSemantic);
 760         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };
 761     }
 762     case Token::Type::Register:  {
 763         PARSE(result, ResourceSemantic);
 764         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };
 765     }
 766     default:  {
 767         PARSE(result, BuiltInSemantic);
 768         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };
 769     }
 770     }
 771 }
 772 AST::Qualifiers Parser::parseQualifiers()
 773 {
 774     AST::Qualifiers qualifiers;
 775     while (auto next = tryType(Token::Type::Qualifier)) {
 776         auto nextStringView = next-&gt;stringView(m_lexer);
 777         if (&quot;nointerpolation&quot; == nextStringView)
 778             qualifiers.append(AST::Qualifier::Nointerpolation);
 779         else if (&quot;noperspective&quot; == nextStringView)
 780             qualifiers.append(AST::Qualifier::Noperspective);
 781         else if (&quot;uniform&quot; == nextStringView)
 782             qualifiers.append(AST::Qualifier::Uniform);
 783         else if (&quot;centroid&quot; == nextStringView)
 784             qualifiers.append(AST::Qualifier::Centroid);
 785         else {
 786             ASSERT(&quot;sample&quot; == nextStringView);
 787             qualifiers.append(AST::Qualifier::Sample);
 788         }
 789     }
 790     return qualifiers;
 791 }
 792 
 793 auto Parser::parseStructureElement() -&gt; Expected&lt;AST::StructureElement, Error&gt;
 794 {
 795     PEEK(origin);
 796 
 797     AST::Qualifiers qualifiers = parseQualifiers();
 798 
 799     PARSE(type, Type);
 800     CONSUME_TYPE(name, Identifier);
 801     PARSE(semantic, Semantic);
 802     CONSUME_TYPE(semicolon, Semicolon);
 803 
 804     return AST::StructureElement({ *origin, *semicolon }, WTFMove(qualifiers), WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*semantic));
 805 }
 806 
 807 auto Parser::parseStructureDefinition() -&gt; Expected&lt;AST::StructureDefinition, Error&gt;
 808 {
 809     CONSUME_TYPE(origin, Struct);
 810     CONSUME_TYPE(name, Identifier);
 811     CONSUME_TYPE(leftCurlyBracket, LeftCurlyBracket);
 812 
 813     AST::StructureElements structureElements;
 814     while (!peekType(Token::Type::RightCurlyBracket)) {
 815         PARSE(structureElement, StructureElement);
 816         structureElements.append(WTFMove(*structureElement));
 817     }
 818 
 819     auto rightCurlyBracket = m_lexer.consumeToken();
 820 
 821     return AST::StructureDefinition({ *origin, rightCurlyBracket }, name-&gt;stringView(m_lexer).toString(), WTFMove(structureElements));
 822 }
 823 
 824 auto Parser::parseEnumerationDefinition() -&gt; Expected&lt;AST::EnumerationDefinition, Error&gt;
 825 {
 826     CONSUME_TYPE(origin, Enum);
 827     CONSUME_TYPE(name, Identifier);
 828 
 829     auto type = ([&amp;]() -&gt; Expected&lt;Ref&lt;AST::UnnamedType&gt;, Error&gt; {
 830         if (tryType(Token::Type::Colon)) {
 831             PARSE(parsedType, Type);
 832             return WTFMove(*parsedType);
 833         }
 834         return { AST::TypeReference::create(*origin, &quot;int&quot;_str, AST::TypeArguments()) };
 835     })();
 836     if (!type)
 837         return makeUnexpected(type.error());
 838 
 839     CONSUME_TYPE(leftCurlyBracket, LeftCurlyBracket);
 840 
 841     int64_t nextValue = 0;
 842     PARSE(firstEnumerationMember, EnumerationMember, nextValue);
 843     nextValue = firstEnumerationMember-&gt;value() + 1;
 844 
 845     AST::EnumerationDefinition result({ }, name-&gt;stringView(m_lexer).toString(), WTFMove(*type));
 846     auto success = result.add(WTFMove(*firstEnumerationMember));
 847     if (!success)
 848         return fail(&quot;Cannot add enumeration member&quot;_str);
 849 
 850     while (tryType(Token::Type::Comma)) {
 851         PARSE(member, EnumerationMember, nextValue);
 852         nextValue = member-&gt;value() + 1;
 853         success = result.add(WTFMove(*member));
 854         if (!success)
 855             return fail(&quot;Cannot add enumeration member&quot;_str);
 856     }
 857 
 858     CONSUME_TYPE(rightCurlyBracket, RightCurlyBracket);
 859     result.updateCodeLocation({ *origin, *rightCurlyBracket});
 860 
 861     return WTFMove(result);
 862 }
 863 
 864 auto Parser::parseEnumerationMember(int64_t defaultValue) -&gt; Expected&lt;AST::EnumerationMember, Error&gt;
 865 {
 866     CONSUME_TYPE(identifier, Identifier);
 867     auto name = identifier-&gt;stringView(m_lexer).toString();
 868 
 869     if (tryType(Token::Type::EqualsSign)) {
 870         PARSE(constantExpression, ConstantExpression);
 871 
 872         Optional&lt;int64_t&gt; value;
 873         constantExpression-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {
 874             value = integerLiteral.value();
 875         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {
 876             value = unsignedIntegerLiteral.value();
 877         }, [&amp;](AST::FloatLiteral&amp;) {
<a name="3" id="anc3"></a>
 878         }, [&amp;](AST::BooleanLiteral&amp;) {
 879         }, [&amp;](AST::EnumerationMemberLiteral&amp;) {
 880         }));
 881 
 882         if (!value)
 883             return makeUnexpected(Error(&quot;enum initialization values can only be an int or uint constant.&quot;));
 884         return AST::EnumerationMember(*identifier, WTFMove(name), *value);
 885     }
 886     return AST::EnumerationMember(*identifier, WTFMove(name), defaultValue);
 887 }
 888 
 889 auto Parser::parseNativeTypeDeclaration() -&gt; Expected&lt;AST::NativeTypeDeclaration, Error&gt;
 890 {
 891     CONSUME_TYPE(origin, Native);
 892     CONSUME_TYPE(parsedTypedef, Typedef);
 893     CONSUME_TYPE(name, Identifier);
 894     PARSE(typeArguments, TypeArguments);
 895     CONSUME_TYPE(semicolon, Semicolon);
 896 
 897     return AST::NativeTypeDeclaration({ *origin, *semicolon }, name-&gt;stringView(m_lexer).toString(), WTFMove(*typeArguments));
 898 }
 899 
 900 auto Parser::parseNumThreadsFunctionAttribute() -&gt; Expected&lt;AST::NumThreadsFunctionAttribute, Error&gt;
 901 {
 902     CONSUME_TYPE(origin, NumThreads);
 903     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
 904 
 905     auto width = consumeNonNegativeIntegralLiteral();
 906     if (!width)
 907         return makeUnexpected(width.error());
 908 
 909     CONSUME_TYPE(comma, Comma);
 910 
 911     auto height = consumeNonNegativeIntegralLiteral();
 912     if (!height)
 913         return makeUnexpected(height.error());
 914 
 915     CONSUME_TYPE(secondComma, Comma);
 916 
 917     auto depth = consumeNonNegativeIntegralLiteral();
 918     if (!depth)
 919         return makeUnexpected(depth.error());
 920 
 921     CONSUME_TYPE(rightParenthesis, RightParenthesis);
 922 
 923     return AST::NumThreadsFunctionAttribute({ *origin, *rightParenthesis }, *width, *height, *depth);
 924 }
 925 
 926 auto Parser::parseAttributeBlock() -&gt; Expected&lt;AST::AttributeBlock, Error&gt;
 927 {
 928     CONSUME_TYPE(leftSquareBracket, LeftSquareBracket);
 929 
 930     AST::AttributeBlock result;
 931 
 932     while (!tryType(Token::Type::RightSquareBracket)) {
 933         PARSE(numThreadsFunctionAttribute, NumThreadsFunctionAttribute);
 934         result.append(WTFMove(*numThreadsFunctionAttribute));
 935     }
 936 
 937     return WTFMove(result);
 938 }
 939 
 940 auto Parser::parseParameter() -&gt; Expected&lt;AST::VariableDeclaration, Error&gt;
 941 {
 942     auto startOffset = m_lexer.peek().startOffset();
 943 
 944     AST::Qualifiers qualifiers = parseQualifiers();
 945     PARSE(type, Type);
 946 
 947     String name;
 948     if (auto token = tryType(Token::Type::Identifier))
 949         name = token-&gt;stringView(m_lexer).toString();
 950 
 951     PARSE(semantic, Semantic);
 952 
 953     auto endOffset = m_lexer.peek().startOffset();
 954 
 955     return AST::VariableDeclaration({ startOffset, endOffset, m_lexer.nameSpace() }, WTFMove(qualifiers), { WTFMove(*type) }, WTFMove(name), WTFMove(*semantic), nullptr);
 956 }
 957 
 958 auto Parser::parseParameters() -&gt; Expected&lt;AST::VariableDeclarations, Error&gt;
 959 {
 960     AST::VariableDeclarations parameters;
 961 
 962     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
 963 
 964     if (tryType(Token::Type::RightParenthesis))
 965         return WTFMove(parameters);
 966 
 967     PARSE(firstParameter, Parameter);
 968     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*firstParameter)));
 969 
 970     while (tryType(Token::Type::Comma)) {
 971         PARSE(parameter, Parameter);
 972         parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*parameter)));
 973     }
 974 
 975     CONSUME_TYPE(rightParenthesis, RightParenthesis);
 976 
 977     return WTFMove(parameters);
 978 }
 979 
 980 auto Parser::parseFunctionDefinition() -&gt; Expected&lt;AST::FunctionDefinition, Error&gt;
 981 {
 982     PARSE(functionDeclaration, FunctionDeclaration);
 983     PARSE(block, Block);
 984     return AST::FunctionDefinition(WTFMove(*functionDeclaration), WTFMove(*block));
 985 }
 986 
 987 auto Parser::parseComputeFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
 988 {
 989     PEEK(origin);
 990 
 991     PARSE(attributeBlock, AttributeBlock);
 992     CONSUME_TYPE(compute, Compute);
 993     PARSE(type, Type);
 994     CONSUME_TYPE(name, Identifier);
 995     PARSE(parameters, Parameters);
 996     PARSE(semantic, Semantic);
 997 
 998     auto endOffset = m_lexer.peek().startOffset();
 999 
1000     bool isOperator = false;
1001     return AST::FunctionDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(*attributeBlock), AST::EntryPointType::Compute, WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);
1002 }
1003 
1004 auto Parser::parseVertexOrFragmentFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1005 {
1006     auto entryPoint = consumeTypes&lt;Token::Type::Vertex, Token::Type::Fragment&gt;();
1007     if (!entryPoint)
1008         return makeUnexpected(entryPoint.error());
1009     auto entryPointType = (entryPoint-&gt;type == Token::Type::Vertex) ? AST::EntryPointType::Vertex : AST::EntryPointType::Fragment;
1010 
1011     PARSE(type, Type);
1012     CONSUME_TYPE(name, Identifier);
1013     PARSE(parameters, Parameters);
1014     PARSE(semantic, Semantic);
1015 
1016     auto endOffset = m_lexer.peek().startOffset();
1017 
1018     bool isOperator = false;
1019     return AST::FunctionDeclaration({ entryPoint-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, { }, entryPointType, WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);
1020 }
1021 
1022 auto Parser::parseRegularFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1023 {
1024     PEEK(origin);
1025 
1026     PARSE(type, Type);
1027 
1028     auto name = consumeTypes&lt;Token::Type::Identifier, Token::Type::OperatorName&gt;();
1029     if (!name)
1030         return makeUnexpected(name.error());
1031     auto isOperator = name-&gt;type == Token::Type::OperatorName;
1032 
1033     PARSE(parameters, Parameters);
1034     PARSE(semantic, Semantic);
1035 
1036     auto endOffset = m_lexer.peek().startOffset();
1037 
1038     return AST::FunctionDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, { }, WTF::nullopt, WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);
1039 }
1040 
1041 auto Parser::parseOperatorFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1042 {
1043     CONSUME_TYPE(origin, Operator);
1044     PARSE(type, Type);
1045     PARSE(parameters, Parameters);
1046     PARSE(semantic, Semantic);
1047 
1048     auto endOffset = m_lexer.peek().startOffset();
1049 
1050     bool isOperator = true;
1051     return AST::FunctionDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, { }, WTF::nullopt, WTFMove(*type), &quot;operator cast&quot;_str, WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);
1052 }
1053 
1054 auto Parser::parseFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1055 {
1056     PEEK(token);
1057     switch (token-&gt;type) {
1058     case Token::Type::Operator:
1059         return parseOperatorFunctionDeclaration();
1060     case Token::Type::Vertex:
1061     case Token::Type::Fragment:
1062         return parseVertexOrFragmentFunctionDeclaration();
1063     case Token::Type::LeftSquareBracket:
1064         return parseComputeFunctionDeclaration();
1065     default:
1066         return parseRegularFunctionDeclaration();
1067     }
1068 }
1069 
1070 auto Parser::parseNativeFunctionDeclaration() -&gt; Expected&lt;AST::NativeFunctionDeclaration, Error&gt;
1071 {
1072     CONSUME_TYPE(native, Native);
1073     PARSE(functionDeclaration, FunctionDeclaration);
1074     CONSUME_TYPE(semicolon, Semicolon);
1075 
1076     return AST::NativeFunctionDeclaration(WTFMove(*functionDeclaration));
1077 }
1078 
1079 auto Parser::parseBlock() -&gt; Expected&lt;AST::Block, Error&gt;
1080 {
1081     CONSUME_TYPE(origin, LeftCurlyBracket);
1082     PARSE(result, BlockBody);
1083     CONSUME_TYPE(rightCurlyBracket, RightCurlyBracket);
1084     result-&gt;updateCodeLocation({ *origin, *rightCurlyBracket });
1085     return WTFMove(*result);
1086 }
1087 
1088 auto Parser::parseBlockBody() -&gt; Expected&lt;AST::Block, Error&gt;
1089 {
1090     auto startOffset = m_lexer.peek().startOffset();
1091 
1092     AST::Statements statements;
1093     while (!peekTypes&lt;Token::Type::RightCurlyBracket, Token::Type::Case, Token::Type::Default&gt;()) {
1094         PARSE(statement, Statement);
1095         statements.append(WTFMove(*statement));
1096     }
1097 
1098     auto endOffset = m_lexer.peek().startOffset();
1099 
1100     return AST::Block({ startOffset, endOffset, m_lexer.nameSpace() }, WTFMove(statements));
1101 }
1102 
1103 auto Parser::parseIfStatement() -&gt; Expected&lt;AST::IfStatement, Error&gt;
1104 {
1105     CONSUME_TYPE(origin, If);
1106     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
1107     PARSE(conditional, Expression);
1108     CONSUME_TYPE(rightParenthesis, RightParenthesis);
1109     PARSE(body, Statement);
1110 
1111     std::unique_ptr&lt;AST::Statement&gt; elseBody(nullptr);
1112     if (tryType(Token::Type::Else)) {
1113         PARSE(parsedElseBody, Statement);
1114         elseBody = (*parsedElseBody).moveToUniquePtr();
1115     }
1116 
1117     auto endOffset = m_lexer.peek().startOffset();
1118 
1119     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
1120     castArguments.append(WTFMove(*conditional));
1121     auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(Token(*origin), &quot;bool&quot;_str, WTFMove(castArguments));
1122     return AST::IfStatement({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(boolCast), WTFMove(*body), WTFMove(elseBody));
1123 }
1124 
1125 auto Parser::parseSwitchStatement() -&gt; Expected&lt;AST::SwitchStatement, Error&gt;
1126 {
1127     CONSUME_TYPE(origin, Switch);
1128     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
1129     PARSE(value, Expression);
1130     CONSUME_TYPE(rightParenthesis, RightParenthesis);
1131     CONSUME_TYPE(leftCurlyBracket, LeftCurlyBracket);
1132 
1133     Vector&lt;AST::SwitchCase&gt; switchCases;
1134     PEEK(nextToken);
1135     while (nextToken-&gt;type != Token::Type::RightCurlyBracket) {
1136         PARSE(switchCase, SwitchCase);
1137         switchCases.append(WTFMove(*switchCase));
1138         PEEK(nextTokenInLoop);
1139         nextToken = nextTokenInLoop;
1140     }
1141 
1142     auto endToken = m_lexer.consumeToken();
1143 
1144     return AST::SwitchStatement({ *origin, endToken }, WTFMove(*value), WTFMove(switchCases));
1145 }
1146 
1147 auto Parser::parseSwitchCase() -&gt; Expected&lt;AST::SwitchCase, Error&gt;
1148 {
1149     auto origin = consumeTypes&lt;Token::Type::Case, Token::Type::Default&gt;();
1150     if (!origin)
1151         return makeUnexpected(origin.error());
1152 
1153     switch (origin-&gt;type) {
1154     case Token::Type::Case: {
1155         PARSE(value, ConstantExpression);
1156         CONSUME_TYPE(colon, Colon);
1157 
1158         PARSE(block, BlockBody);
1159 
1160         return AST::SwitchCase({ origin-&gt;codeLocation,  block-&gt;codeLocation()}, WTFMove(*value), WTFMove(*block));
1161     }
1162     default: {
1163         ASSERT(origin-&gt;type == Token::Type::Default);
1164         CONSUME_TYPE(colon, Colon);
1165 
1166         PARSE(block, BlockBody);
1167 
1168         return AST::SwitchCase({ origin-&gt;codeLocation,  block-&gt;codeLocation()}, WTF::nullopt, WTFMove(*block));
1169     }
1170     }
1171 }
1172 
1173 auto Parser::parseForLoop() -&gt; Expected&lt;AST::ForLoop, Error&gt;
1174 {
1175     CONSUME_TYPE(origin, For);
1176     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
1177 
1178     auto parseRemainder = [&amp;](UniqueRef&lt;AST::Statement&gt;&amp;&amp; initialization) -&gt; Expected&lt;AST::ForLoop, Error&gt; {
1179         CONSUME_TYPE(semicolon, Semicolon);
1180 
1181         std::unique_ptr&lt;AST::Expression&gt; condition(nullptr);
1182         if (!tryType(Token::Type::Semicolon)) {
1183             if (auto expression = parseExpression())
1184                 condition = (*expression).moveToUniquePtr();
1185             else
1186                 return makeUnexpected(expression.error());
1187             CONSUME_TYPE(secondSemicolon, Semicolon);
1188         }
1189 
1190         std::unique_ptr&lt;AST::Expression&gt; increment(nullptr);
1191         if (!tryType(Token::Type::RightParenthesis)) {
1192             if (auto expression = parseExpression())
1193                 increment = (*expression).moveToUniquePtr();
1194             else
1195                 return makeUnexpected(expression.error());
1196             CONSUME_TYPE(rightParenthesis, RightParenthesis);
1197         }
1198 
1199         PARSE(body, Statement);
1200         CodeLocation location(origin-&gt;codeLocation, (*body)-&gt;codeLocation());
1201         return AST::ForLoop(location, WTFMove(initialization), WTFMove(condition), WTFMove(increment), WTFMove(*body));
1202     };
1203 
1204     auto variableDeclarations = backtrackingScope&lt;Expected&lt;AST::VariableDeclarationsStatement, Error&gt;&gt;([&amp;]() {
1205         return parseVariableDeclarations();
1206     });
1207     if (variableDeclarations) {
1208         UniqueRef&lt;AST::Statement&gt; declarationStatement = makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations));
1209         return parseRemainder(WTFMove(declarationStatement));
1210     }
1211 
1212     PARSE(effectfulExpression, EffectfulExpression);
1213 
1214     return parseRemainder(WTFMove(*effectfulExpression));
1215 }
1216 
1217 auto Parser::parseWhileLoop() -&gt; Expected&lt;AST::WhileLoop, Error&gt;
1218 {
1219     CONSUME_TYPE(origin, While);
1220     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
1221     PARSE(conditional, Expression);
1222     CONSUME_TYPE(rightParenthesis, RightParenthesis);
1223     PARSE(body, Statement);
1224 
1225     CodeLocation location(origin-&gt;codeLocation,  (*body)-&gt;codeLocation());
1226     return AST::WhileLoop(location, WTFMove(*conditional), WTFMove(*body));
1227 }
1228 
1229 auto Parser::parseDoWhileLoop() -&gt; Expected&lt;AST::DoWhileLoop, Error&gt;
1230 {
1231     CONSUME_TYPE(origin, Do);
1232     PARSE(body, Statement);
1233     CONSUME_TYPE(whileKeyword, While);
1234     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
1235     PARSE(conditional, Expression);
1236     CONSUME_TYPE(rightParenthesis, RightParenthesis);
1237     CONSUME_TYPE(semicolon, Semicolon);
1238 
1239     return AST::DoWhileLoop({ *origin, *semicolon}, WTFMove(*body), WTFMove(*conditional));
1240 }
1241 
1242 auto Parser::parseVariableDeclaration(Ref&lt;AST::UnnamedType&gt;&amp;&amp; type) -&gt; Expected&lt;AST::VariableDeclaration, Error&gt;
1243 {
1244     PEEK(origin);
1245 
1246     auto qualifiers = parseQualifiers();
1247 
1248     CONSUME_TYPE(name, Identifier);
1249     PARSE(semantic, Semantic);
1250 
1251     std::unique_ptr&lt;AST::Expression&gt; initializer = nullptr;
1252     if (tryType(Token::Type::EqualsSign)) {
1253         PARSE(initializingExpression, PossibleTernaryConditional);
1254         initializer = initializingExpression.value().moveToUniquePtr();
1255     }
1256 
1257     auto endOffset = m_lexer.peek().startOffset();
1258     return AST::VariableDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView(m_lexer).toString(), WTFMove(*semantic), WTFMove(initializer));
1259 }
1260 
1261 auto Parser::parseVariableDeclarations() -&gt; Expected&lt;AST::VariableDeclarationsStatement, Error&gt;
1262 {
1263     PEEK(origin);
1264 
1265     PARSE(type, Type);
1266 
1267     auto firstVariableDeclaration = parseVariableDeclaration(type-&gt;copyRef());
1268     if (!firstVariableDeclaration)
1269         return makeUnexpected(firstVariableDeclaration.error());
1270 
1271     Vector&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt; result;
1272     result.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*firstVariableDeclaration)));
1273 
1274     while (tryType(Token::Type::Comma)) {
1275         auto variableDeclaration = parseVariableDeclaration(type-&gt;copyRef());
1276         if (!variableDeclaration)
1277             return makeUnexpected(variableDeclaration.error());
1278         result.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*variableDeclaration)));
1279     }
1280 
1281     auto endOffset = m_lexer.peek().startOffset();
1282     return AST::VariableDeclarationsStatement({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(result));
1283 }
1284 
1285 auto Parser::parseStatement() -&gt; Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;
1286 {
1287     PEEK(token);
1288     switch (token-&gt;type) {
1289     case Token::Type::LeftCurlyBracket: {
1290         PARSE(block, Block);
1291         return { makeUniqueRef&lt;AST::Block&gt;(WTFMove(*block)) };
1292     }
1293     case Token::Type::If: {
1294         PARSE(ifStatement, IfStatement);
1295         return { makeUniqueRef&lt;AST::IfStatement&gt;(WTFMove(*ifStatement)) };
1296     }
1297     case Token::Type::Switch: {
1298         PARSE(switchStatement, SwitchStatement);
1299         return { makeUniqueRef&lt;AST::SwitchStatement&gt;(WTFMove(*switchStatement)) };
1300     }
1301     case Token::Type::For: {
1302         PARSE(forLoop, ForLoop);
1303         return { makeUniqueRef&lt;AST::ForLoop&gt;(WTFMove(*forLoop)) };
1304     }
1305     case Token::Type::While: {
1306         PARSE(whileLoop, WhileLoop);
1307         return { makeUniqueRef&lt;AST::WhileLoop&gt;(WTFMove(*whileLoop)) };
1308     }
1309     case Token::Type::Do: {
1310         PARSE(doWhileLoop, DoWhileLoop);
1311         return { makeUniqueRef&lt;AST::DoWhileLoop&gt;(WTFMove(*doWhileLoop)) };
1312     }
1313     case Token::Type::Break: {
1314         auto breakToken = m_lexer.consumeToken();
1315         CONSUME_TYPE(semicolon, Semicolon);
1316         auto breakObject = AST::Break(WTFMove(breakToken));
1317         return { makeUniqueRef&lt;AST::Break&gt;(WTFMove(breakObject)) };
1318     }
1319     case Token::Type::Continue: {
1320         auto continueToken = m_lexer.consumeToken();
1321         CONSUME_TYPE(semicolon, Semicolon);
1322         auto continueObject = AST::Continue(WTFMove(continueToken));
1323         return { makeUniqueRef&lt;AST::Continue&gt;(WTFMove(continueObject)) };
1324     }
1325     case Token::Type::Fallthrough: {
1326         auto fallthroughToken = m_lexer.consumeToken();
1327         CONSUME_TYPE(semicolon, Semicolon);
1328         auto fallthroughObject = AST::Fallthrough(WTFMove(fallthroughToken));
1329         return { makeUniqueRef&lt;AST::Fallthrough&gt;(WTFMove(fallthroughObject)) };
1330     }
1331     case Token::Type::Return: {
1332         auto returnToken = m_lexer.consumeToken();
1333         if (auto semicolon = tryType(Token::Type::Semicolon)) {
1334             auto returnObject = AST::Return(WTFMove(returnToken), nullptr);
1335             return { makeUniqueRef&lt;AST::Return&gt;(WTFMove(returnObject)) };
1336         }
1337         PARSE(expression, Expression);
1338         CONSUME_TYPE(finalSemicolon, Semicolon);
1339         auto returnObject = AST::Return(WTFMove(returnToken), (*expression).moveToUniquePtr());
1340         return { makeUniqueRef&lt;AST::Return&gt;(WTFMove(returnObject)) };
1341     }
1342     case Token::Type::Constant:
1343     case Token::Type::Device:
1344     case Token::Type::Threadgroup:
1345     case Token::Type::Thread: {
1346         PARSE(variableDeclarations, VariableDeclarations);
1347         CONSUME_TYPE(semicolon, Semicolon);
1348         return { makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations)) };
1349     }
1350     case Token::Type::Identifier: {
1351         PEEK_FURTHER(nextToken);
1352         switch (nextToken-&gt;type) {
1353         case Token::Type::Identifier:
1354         case Token::Type::LessThanSign:
1355         case Token::Type::Star:
1356         case Token::Type::Qualifier: {
1357             PARSE(variableDeclarations, VariableDeclarations);
1358             CONSUME_TYPE(semicolon, Semicolon);
1359             return { makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations)) };
1360         }
1361         default:
1362             break;
1363         }
1364         break;
1365     }
1366     default:
1367         break;
1368     }
1369 
1370     {
1371         auto effectfulExpression = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt; {
1372             PARSE(result, EffectfulExpression);
1373             CONSUME_TYPE(semicolon, Semicolon);
1374             return result;
1375         });
1376         if (effectfulExpression)
1377             return WTFMove(*effectfulExpression);
1378     }
1379 
1380     PARSE(variableDeclarations, VariableDeclarations);
1381     CONSUME_TYPE(semicolon, Semicolon);
1382     return { makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations)) };
1383 }
1384 
1385 auto Parser::parseEffectfulExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;
1386 {
1387     PEEK(origin);
1388     if (origin-&gt;type == Token::Type::Semicolon)
1389         return { makeUniqueRef&lt;AST::Block&gt;(*origin, Vector&lt;UniqueRef&lt;AST::Statement&gt;&gt;()) };
1390 
1391     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
1392     PARSE(effectfulExpression, EffectfulAssignment);
1393     expressions.append(WTFMove(*effectfulExpression));
1394 
1395     while (tryType(Token::Type::Comma)) {
1396         PARSE(expression, EffectfulAssignment);
1397         expressions.append(WTFMove(*expression));
1398     }
1399 
1400     if (expressions.size() == 1)
1401         return { makeUniqueRef&lt;AST::EffectfulExpressionStatement&gt;(WTFMove(expressions[0])) };
1402     unsigned endOffset = m_lexer.peek().startOffset();
1403     CodeLocation location(origin-&gt;startOffset(), endOffset, m_lexer.nameSpace());
1404     auto commaExpression = makeUniqueRef&lt;AST::CommaExpression&gt;(location, WTFMove(expressions));
1405     return { makeUniqueRef&lt;AST::EffectfulExpressionStatement&gt;(WTFMove(commaExpression)) };
1406 }
1407 
1408 auto Parser::parseEffectfulAssignment() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1409 {
1410     PEEK(origin);
1411 
1412     bool isEffectful = false;
1413     PARSE(expression, PossiblePrefix, &amp;isEffectful);
1414 
1415     if (!isEffectful || peekTypes&lt;
1416         Token::Type::EqualsSign,
1417         Token::Type::PlusEquals,
1418         Token::Type::MinusEquals,
1419         Token::Type::TimesEquals,
1420         Token::Type::DivideEquals,
1421         Token::Type::ModEquals,
1422         Token::Type::XorEquals,
1423         Token::Type::AndEquals,
1424         Token::Type::OrEquals,
1425         Token::Type::RightShiftEquals,
1426         Token::Type::LeftShiftEquals
1427     &gt;()) {
1428         return completeAssignment(WTFMove(*expression));
1429     }
1430 
1431     return expression;
1432 }
1433 
1434 auto Parser::parseLimitedSuffixOperator(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; SuffixExpression
1435 {
1436     auto type = consumeTypes&lt;
1437         Token::Type::FullStop,
1438         Token::Type::Arrow,
1439         Token::Type::LeftSquareBracket&gt;();
1440     if (!type)
1441         return SuffixExpression(WTFMove(previous), false);
1442 
1443     switch (type-&gt;type) {
1444     case Token::Type::FullStop: {
1445         auto identifier = consumeType(Token::Type::Identifier);
1446         if (!identifier)
1447             return SuffixExpression(WTFMove(previous), false);
1448         CodeLocation location(previous-&gt;codeLocation(), *identifier);
1449         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, WTFMove(previous), identifier-&gt;stringView(m_lexer).toString()), true);
1450     }
1451     case Token::Type::Arrow: {
1452         auto identifier = consumeType(Token::Type::Identifier);
1453         if (!identifier)
1454             return SuffixExpression(WTFMove(previous), false);
1455         CodeLocation location(previous-&gt;codeLocation(), *identifier);
1456         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(previous)), identifier-&gt;stringView(m_lexer).toString()), true);
1457     }
1458     default: {
1459         ASSERT(type-&gt;type == Token::Type::LeftSquareBracket);
1460         auto expression = parseExpression();
1461         if (!expression)
1462             return SuffixExpression(WTFMove(previous), false);
1463         if (auto rightSquareBracket = consumeType(Token::Type::RightSquareBracket)) {
1464             CodeLocation location(previous-&gt;codeLocation(), *rightSquareBracket);
1465             return SuffixExpression(makeUniqueRef&lt;AST::IndexExpression&gt;(location, WTFMove(previous), WTFMove(*expression)), true);
1466         }
1467         return SuffixExpression(WTFMove(previous), false);
1468     }
1469     }
1470 }
1471 
1472 auto Parser::parseSuffixOperator(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; SuffixExpression
1473 {
1474     auto suffix = consumeTypes&lt;
1475         Token::Type::FullStop,
1476         Token::Type::Arrow,
1477         Token::Type::LeftSquareBracket,
1478         Token::Type::PlusPlus,
1479         Token::Type::MinusMinus&gt;();
1480     if (!suffix)
1481         return SuffixExpression(WTFMove(previous), false);
1482 
1483     switch (suffix-&gt;type) {
1484     case Token::Type::FullStop: {
1485         auto identifier = consumeType(Token::Type::Identifier);
1486         if (!identifier)
1487             return SuffixExpression(WTFMove(previous), false);
1488         CodeLocation location(previous-&gt;codeLocation(), *identifier);
1489         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, WTFMove(previous), identifier-&gt;stringView(m_lexer).toString()), true);
1490     }
1491     case Token::Type::Arrow: {
1492         auto identifier = consumeType(Token::Type::Identifier);
1493         if (!identifier)
1494             return SuffixExpression(WTFMove(previous), false);
1495         CodeLocation location(previous-&gt;codeLocation(), *identifier);
1496         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, makeUniqueRef&lt;AST::DereferenceExpression&gt;(WTFMove(*suffix), WTFMove(previous)), identifier-&gt;stringView(m_lexer).toString()), true);
1497     }
1498     case Token::Type::LeftSquareBracket: {
1499         auto expression = parseExpression();
1500         if (!expression)
1501             return SuffixExpression(WTFMove(previous), false);
1502         if (auto rightSquareBracket = consumeType(Token::Type::RightSquareBracket)) {
1503             CodeLocation location(previous-&gt;codeLocation(), *rightSquareBracket);
1504             return SuffixExpression(makeUniqueRef&lt;AST::IndexExpression&gt;(location, WTFMove(previous), WTFMove(*expression)), true);
1505         }
1506         return SuffixExpression(WTFMove(previous), false);
1507     }
1508     case Token::Type::PlusPlus: {
1509         CodeLocation location(previous-&gt;codeLocation(), *suffix);
1510         auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(previous));
1511         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1512         callArguments.append(result-&gt;oldVariableReference());
1513         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator++&quot;_str, WTFMove(callArguments)));
1514         result-&gt;setResultExpression(result-&gt;oldVariableReference());
1515         return SuffixExpression(WTFMove(result), true);
1516     }
1517     default: {
1518         ASSERT(suffix-&gt;type == Token::Type::MinusMinus);
1519         CodeLocation location(previous-&gt;codeLocation(), *suffix);
1520         auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(previous));
1521         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1522         callArguments.append(result-&gt;oldVariableReference());
1523         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator--&quot;_str, WTFMove(callArguments)));
1524         result-&gt;setResultExpression(result-&gt;oldVariableReference());
1525         return SuffixExpression(WTFMove(result), true);
1526     }
1527     }
1528 }
1529 
1530 auto Parser::parseExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1531 {
1532     PARSE(first, PossibleTernaryConditional);
1533     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
1534     unsigned startOffset = (*first)-&gt;codeLocation().startOffset();
1535     expressions.append(WTFMove(*first));
1536 
1537     while (tryType(Token::Type::Comma)) {
1538         PARSE(expression, PossibleTernaryConditional);
1539         expressions.append(WTFMove(*expression));
1540     }
1541 
1542     if (expressions.size() == 1)
1543         return WTFMove(expressions[0]);
1544     auto endOffset = m_lexer.peek().startOffset();
1545     CodeLocation location(startOffset, endOffset, m_lexer.nameSpace());
1546     return { makeUniqueRef&lt;AST::CommaExpression&gt;(location, WTFMove(expressions)) };
1547 }
1548 
1549 auto Parser::completeTernaryConditional(UniqueRef&lt;AST::Expression&gt;&amp;&amp; predicate) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1550 {
1551     CONSUME_TYPE(questionMark, QuestionMark);
1552     PARSE(bodyExpression, Expression);
1553     CONSUME_TYPE(colon, Colon);
1554     PARSE(elseExpression, PossibleTernaryConditional);
1555 
1556     CodeLocation predicateLocation = predicate-&gt;codeLocation();
1557     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
1558     castArguments.append(WTFMove(predicate));
1559     auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(predicateLocation, &quot;bool&quot;_str, WTFMove(castArguments));
1560     CodeLocation location(predicateLocation, (*elseExpression)-&gt;codeLocation());
1561     return { makeUniqueRef&lt;AST::TernaryExpression&gt;(location, WTFMove(boolCast), WTFMove(*bodyExpression), WTFMove(*elseExpression)) };
1562 }
1563 
1564 auto Parser::completeAssignment(UniqueRef&lt;AST::Expression&gt;&amp;&amp; left) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1565 {
1566     auto assignmentOperator = consumeTypes&lt;
1567         Token::Type::EqualsSign,
1568         Token::Type::PlusEquals,
1569         Token::Type::MinusEquals,
1570         Token::Type::TimesEquals,
1571         Token::Type::DivideEquals,
1572         Token::Type::ModEquals,
1573         Token::Type::XorEquals,
1574         Token::Type::AndEquals,
1575         Token::Type::OrEquals,
1576         Token::Type::RightShiftEquals,
1577         Token::Type::LeftShiftEquals&gt;();
1578     if (!assignmentOperator)
1579         return makeUnexpected(assignmentOperator.error());
1580 
1581     PARSE(right, PossibleTernaryConditional);
1582     CodeLocation location = { left-&gt;codeLocation(), (*right)-&gt;codeLocation() };
1583 
1584     if (assignmentOperator-&gt;type == Token::Type::EqualsSign)
1585         return { makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(left), WTFMove(*right))};
1586 
1587     String name;
1588     switch (assignmentOperator-&gt;type) {
1589     case Token::Type::PlusEquals:
1590         name = &quot;operator+&quot;_str;
1591         break;
1592     case Token::Type::MinusEquals:
1593         name = &quot;operator-&quot;_str;
1594         break;
1595     case Token::Type::TimesEquals:
1596         name = &quot;operator*&quot;_str;
1597         break;
1598     case Token::Type::DivideEquals:
1599         name = &quot;operator/&quot;_str;
1600         break;
1601     case Token::Type::ModEquals:
1602         name = &quot;operator%&quot;_str;
1603         break;
1604     case Token::Type::XorEquals:
1605         name = &quot;operator^&quot;_str;
1606         break;
1607     case Token::Type::AndEquals:
1608         name = &quot;operator&amp;&quot;_str;
1609         break;
1610     case Token::Type::OrEquals:
1611         name = &quot;operator|&quot;_str;
1612         break;
1613     case Token::Type::RightShiftEquals:
1614         name = &quot;operator&gt;&gt;&quot;_str;
1615         break;
1616     default:
1617         ASSERT(assignmentOperator-&gt;type == Token::Type::LeftShiftEquals);
1618         name = &quot;operator&lt;&lt;&quot;_str;
1619         break;
1620     }
1621 
1622     auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(left));
1623     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1624     callArguments.append(result-&gt;oldVariableReference());
1625     callArguments.append(WTFMove(*right));
1626     result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, WTFMove(name), WTFMove(callArguments)));
1627     result-&gt;setResultExpression(result-&gt;newVariableReference());
1628     return { WTFMove(result) };
1629 }
1630 
1631 auto Parser::parsePossibleTernaryConditional() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1632 {
1633     PARSE(expression, PossiblePrefix);
1634 
1635     if (peekTypes&lt;Token::Type::EqualsSign,
1636         Token::Type::PlusEquals,
1637         Token::Type::MinusEquals,
1638         Token::Type::TimesEquals,
1639         Token::Type::DivideEquals,
1640         Token::Type::ModEquals,
1641         Token::Type::XorEquals,
1642         Token::Type::AndEquals,
1643         Token::Type::OrEquals,
1644         Token::Type::RightShiftEquals,
1645         Token::Type::LeftShiftEquals&gt;()) {
1646         return completeAssignment(WTFMove(*expression));
1647     }
1648 
1649     expression = completePossibleShift(WTFMove(*expression));
1650     if (!expression)
1651         return makeUnexpected(expression.error());
1652 
1653     expression = completePossibleMultiply(WTFMove(*expression));
1654     if (!expression)
1655         return makeUnexpected(expression.error());
1656 
1657     expression = completePossibleAdd(WTFMove(*expression));
1658     if (!expression)
1659         return makeUnexpected(expression.error());
1660 
1661     expression = completePossibleRelationalBinaryOperation(WTFMove(*expression));
1662     if (!expression)
1663         return makeUnexpected(expression.error());
1664 
1665     expression = completePossibleLogicalBinaryOperation(WTFMove(*expression));
1666     if (!expression)
1667         return makeUnexpected(expression.error());
1668 
1669     PEEK(nextToken);
1670     if (nextToken-&gt;type == Token::Type::QuestionMark)
1671         return completeTernaryConditional(WTFMove(*expression));
1672     return expression;
1673 }
1674 
1675 auto Parser::parsePossibleLogicalBinaryOperation() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1676 {
1677     PARSE(parsedPrevious, PossibleRelationalBinaryOperation);
1678     return completePossibleLogicalBinaryOperation(WTFMove(*parsedPrevious));
1679 }
1680 
1681 auto Parser::completePossibleLogicalBinaryOperation(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1682 {
1683     while (auto logicalBinaryOperation = tryTypes&lt;
1684         Token::Type::OrOr,
1685         Token::Type::AndAnd,
1686         Token::Type::Or,
1687         Token::Type::Xor,
1688         Token::Type::And
1689         &gt;()) {
1690         PARSE(next, PossibleRelationalBinaryOperation);
1691         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());
1692 
1693         switch (logicalBinaryOperation-&gt;type) {
1694         case Token::Type::OrOr:
1695             previous = makeUniqueRef&lt;AST::LogicalExpression&gt;(location, AST::LogicalExpression::Type::Or, WTFMove(previous), WTFMove(*next));
1696             break;
1697         case Token::Type::AndAnd:
1698             previous = makeUniqueRef&lt;AST::LogicalExpression&gt;(location, AST::LogicalExpression::Type::And, WTFMove(previous), WTFMove(*next));
1699             break;
1700         case Token::Type::Or: {
1701             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1702             callArguments.append(WTFMove(previous));
1703             callArguments.append(WTFMove(*next));
1704             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator|&quot;_str, WTFMove(callArguments));
1705             break;
1706         }
1707         case Token::Type::Xor: {
1708             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1709             callArguments.append(WTFMove(previous));
1710             callArguments.append(WTFMove(*next));
1711             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator^&quot;_str, WTFMove(callArguments));
1712             break;
1713         }
1714         default: {
1715             ASSERT(logicalBinaryOperation-&gt;type == Token::Type::And);
1716             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1717             callArguments.append(WTFMove(previous));
1718             callArguments.append(WTFMove(*next));
1719             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&amp;&quot;_str, WTFMove(callArguments));
1720             break;
1721         }
1722         }
1723     }
1724 
1725     return { WTFMove(previous) };
1726 }
1727 
1728 auto Parser::parsePossibleRelationalBinaryOperation() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1729 {
1730     PARSE(parsedPrevious, PossibleShift);
1731     return completePossibleRelationalBinaryOperation(WTFMove(*parsedPrevious));
1732 }
1733 
1734 auto Parser::completePossibleRelationalBinaryOperation(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1735 {
1736     while (auto relationalBinaryOperation = tryTypes&lt;
1737         Token::Type::LessThanSign,
1738         Token::Type::GreaterThanSign,
1739         Token::Type::LessThanOrEqualTo,
1740         Token::Type::GreaterThanOrEqualTo,
1741         Token::Type::EqualComparison,
1742         Token::Type::NotEqual
1743         &gt;()) {
1744         PARSE(next, PossibleShift);
1745         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());
1746 
1747         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1748         callArguments.append(WTFMove(previous));
1749         callArguments.append(WTFMove(*next));
1750 
1751         switch (relationalBinaryOperation-&gt;type) {
1752         case Token::Type::LessThanSign: {
1753             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&lt;&quot;_str, WTFMove(callArguments));
1754             break;
1755         }
1756         case Token::Type::GreaterThanSign: {
1757             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&gt;&quot;_str, WTFMove(callArguments));
1758             break;
1759         }
1760         case Token::Type::LessThanOrEqualTo: {
1761             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&lt;=&quot;_str, WTFMove(callArguments));
1762             break;
1763         }
1764         case Token::Type::GreaterThanOrEqualTo: {
1765             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&gt;=&quot;_str, WTFMove(callArguments));
1766             break;
1767         }
1768         case Token::Type::EqualComparison: {
1769             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator==&quot;_str, WTFMove(callArguments));
1770             break;
1771         }
1772         default: {
1773             ASSERT(relationalBinaryOperation-&gt;type == Token::Type::NotEqual);
1774             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator==&quot;_str, WTFMove(callArguments));
1775             previous = makeUniqueRef&lt;AST::LogicalNotExpression&gt;(location, WTFMove(previous));
1776             break;
1777         }
1778         }
1779     }
1780 
1781     return WTFMove(previous);
1782 }
1783 
1784 auto Parser::parsePossibleShift() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1785 {
1786     PARSE(parsedPrevious, PossibleAdd);
1787     return completePossibleShift(WTFMove(*parsedPrevious));
1788 }
1789 
1790 auto Parser::completePossibleShift(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1791 {
1792     while (auto shift = tryTypes&lt;
1793         Token::Type::LeftShift,
1794         Token::Type::RightShift
1795         &gt;()) {
1796         PARSE(next, PossibleAdd);
1797         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());
1798 
1799         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1800         callArguments.append(WTFMove(previous));
1801         callArguments.append(WTFMove(*next));
1802 
1803         switch (shift-&gt;type) {
1804         case Token::Type::LeftShift: {
1805             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&lt;&lt;&quot;_str, WTFMove(callArguments));
1806             break;
1807         }
1808         default: {
1809             ASSERT(shift-&gt;type == Token::Type::RightShift);
1810             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&gt;&gt;&quot;_str, WTFMove(callArguments));
1811             break;
1812         }
1813         }
1814     }
1815 
1816     return WTFMove(previous);
1817 }
1818 
1819 auto Parser::parsePossibleAdd() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1820 {
1821     PARSE(parsedPrevious, PossibleMultiply);
1822     return completePossibleAdd(WTFMove(*parsedPrevious));
1823 }
1824 
1825 auto Parser::completePossibleAdd(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1826 {
1827     while (auto add = tryTypes&lt;
1828         Token::Type::Plus,
1829         Token::Type::Minus
1830         &gt;()) {
1831         PARSE(next, PossibleMultiply);
1832         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());
1833 
1834         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1835         callArguments.append(WTFMove(previous));
1836         callArguments.append(WTFMove(*next));
1837 
1838         switch (add-&gt;type) {
1839         case Token::Type::Plus: {
1840             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator+&quot;_str, WTFMove(callArguments));
1841             break;
1842         }
1843         default: {
1844             ASSERT(add-&gt;type == Token::Type::Minus);
1845             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator-&quot;_str, WTFMove(callArguments));
1846             break;
1847         }
1848         }
1849     }
1850 
1851     return WTFMove(previous);
1852 }
1853 
1854 auto Parser::parsePossibleMultiply() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1855 {
1856     PARSE(parsedPrevious, PossiblePrefix);
1857     return completePossibleMultiply(WTFMove(*parsedPrevious));
1858 }
1859 
1860 auto Parser::completePossibleMultiply(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1861 {
1862     while (auto multiply = tryTypes&lt;
1863         Token::Type::Star,
1864         Token::Type::Divide,
1865         Token::Type::Mod
1866         &gt;()) {
1867         PARSE(next, PossiblePrefix);
1868         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());
1869 
1870         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1871         callArguments.append(WTFMove(previous));
1872         callArguments.append(WTFMove(*next));
1873 
1874         switch (multiply-&gt;type) {
1875         case Token::Type::Star: {
1876             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator*&quot;_str, WTFMove(callArguments));
1877             break;
1878         }
1879         case Token::Type::Divide: {
1880             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator/&quot;_str, WTFMove(callArguments));
1881             break;
1882         }
1883         default: {
1884             ASSERT(multiply-&gt;type == Token::Type::Mod);
1885             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator%&quot;_str, WTFMove(callArguments));
1886             break;
1887         }
1888         }
1889     }
1890 
1891     return WTFMove(previous);
1892 }
1893 
1894 auto Parser::parsePossiblePrefix(bool *isEffectful) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1895 {
1896     if (auto prefix = tryTypes&lt;
1897         Token::Type::PlusPlus,
1898         Token::Type::MinusMinus,
1899         Token::Type::Plus,
1900         Token::Type::Minus,
1901         Token::Type::Tilde,
1902         Token::Type::ExclamationPoint,
1903         Token::Type::And,
1904         Token::Type::At,
1905         Token::Type::Star
1906     &gt;()) {
1907         PARSE(next, PossiblePrefix);
1908         CodeLocation location(*prefix, (*next)-&gt;codeLocation());
1909 
1910         switch (prefix-&gt;type) {
1911         case Token::Type::PlusPlus: {
1912             if (isEffectful)
1913                 *isEffectful = true;
1914             auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(*next));
1915             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1916             callArguments.append(result-&gt;oldVariableReference());
1917             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator++&quot;_str, WTFMove(callArguments)));
1918             result-&gt;setResultExpression(result-&gt;newVariableReference());
1919             return { WTFMove(result) };
1920         }
1921         case Token::Type::MinusMinus: {
1922             if (isEffectful)
1923                 *isEffectful = true;
1924             auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(*next));
1925             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1926             callArguments.append(result-&gt;oldVariableReference());
1927             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator--&quot;_str, WTFMove(callArguments)));
1928             result-&gt;setResultExpression(result-&gt;newVariableReference());
1929             return { WTFMove(result) };
1930         }
1931         case Token::Type::Plus: {
1932             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1933             callArguments.append(WTFMove(*next));
1934             return { makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator+&quot;_str, WTFMove(callArguments)) };
1935         }
1936         case Token::Type::Minus: {
1937             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1938             callArguments.append(WTFMove(*next));
1939             return { makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator-&quot;_str, WTFMove(callArguments)) };
1940         }
1941         case Token::Type::Tilde: {
1942             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1943             callArguments.append(WTFMove(*next));
1944             return { makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator~&quot;_str, WTFMove(callArguments)) };
1945         }
1946         case Token::Type::ExclamationPoint: {
1947             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
1948             castArguments.append(WTFMove(*next));
1949             auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;bool&quot;_str, WTFMove(castArguments));
1950             return { makeUniqueRef&lt;AST::LogicalNotExpression&gt;(location, WTFMove(boolCast)) };
1951         }
1952         case Token::Type::And:
1953             return { makeUniqueRef&lt;AST::MakePointerExpression&gt;(location, WTFMove(*next), AST::AddressEscapeMode::Escapes) };
1954         case Token::Type::At:
1955             return { makeUniqueRef&lt;AST::MakeArrayReferenceExpression&gt;(location, WTFMove(*next), AST::AddressEscapeMode::Escapes) };
1956         default:
1957             ASSERT(prefix-&gt;type == Token::Type::Star);
1958             return { makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(*next)) };
1959         }
1960     }
1961 
1962     return parsePossibleSuffix(isEffectful);
1963 }
1964 
1965 auto Parser::parsePossibleSuffix(bool *isEffectful) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1966 {
1967     PEEK(token);
1968     PEEK_FURTHER(nextToken);
1969 
1970     if (token-&gt;type == Token::Type::Identifier &amp;&amp; nextToken-&gt;type == Token::Type::LeftParenthesis) {
1971         PARSE(expression, CallExpression);
1972         if (isEffectful)
1973             *isEffectful = true;
1974         while (true) {
1975             PEEK(suffixToken);
1976             if (suffixToken-&gt;type != Token::Type::FullStop &amp;&amp; suffixToken-&gt;type != Token::Type::Arrow &amp;&amp; suffixToken-&gt;type != Token::Type::LeftSquareBracket)
1977                 break;
1978             auto result = parseLimitedSuffixOperator(WTFMove(*expression));
1979             expression = WTFMove(result.result);
1980         }
1981         return expression;
1982     }
1983 
1984     if (token-&gt;type == Token::Type::LeftParenthesis &amp;&amp; isEffectful)
1985         *isEffectful = true;
1986 
1987     PARSE(expression, Term);
1988     bool isLastSuffixTokenEffectful = false;
1989     while (true) {
1990         PEEK(suffixToken);
1991         if (suffixToken-&gt;type != Token::Type::FullStop
1992             &amp;&amp; suffixToken-&gt;type != Token::Type::Arrow
1993             &amp;&amp; suffixToken-&gt;type != Token::Type::LeftSquareBracket
1994             &amp;&amp; suffixToken-&gt;type != Token::Type::PlusPlus
1995             &amp;&amp; suffixToken-&gt;type != Token::Type::MinusMinus) {
1996             break;
1997         }
1998         isLastSuffixTokenEffectful = suffixToken-&gt;type == Token::Type::PlusPlus || suffixToken-&gt;type == Token::Type::MinusMinus;
1999         auto result = parseSuffixOperator(WTFMove(*expression));
2000         expression = WTFMove(result.result);
2001     }
2002     if (isLastSuffixTokenEffectful &amp;&amp; isEffectful)
2003         *isEffectful = true;
2004     return expression;
2005 }
2006 
2007 auto Parser::parseCallExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2008 {
2009     CONSUME_TYPE(name, Identifier);
2010     auto callName = name-&gt;stringView(m_lexer).toString();
2011 
2012     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
2013 
2014     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;
2015     if (tryType(Token::Type::RightParenthesis))
2016         return { makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*name), WTFMove(callName), WTFMove(arguments)) };
2017 
2018     PARSE(firstArgument, PossibleTernaryConditional);
2019     arguments.append(WTFMove(*firstArgument));
2020     while (tryType(Token::Type::Comma)) {
2021         PARSE(argument, PossibleTernaryConditional);
2022         arguments.append(WTFMove(*argument));
2023     }
2024 
2025     CONSUME_TYPE(rightParenthesis, RightParenthesis);
2026     CodeLocation location(*name, *rightParenthesis);
2027 
2028     return { makeUniqueRef&lt;AST::CallExpression&gt;(location, WTFMove(callName), WTFMove(arguments)) };
2029 }
2030 
2031 auto Parser::parseTerm() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2032 {
2033     auto type = consumeTypes&lt;
2034         Token::Type::IntLiteral,
2035         Token::Type::UintLiteral,
2036         Token::Type::FloatLiteral,
2037         Token::Type::Null,
2038         Token::Type::True,
2039         Token::Type::False,
2040         Token::Type::Identifier,
2041         Token::Type::LeftParenthesis&gt;();
2042     if (!type)
2043         return makeUnexpected(type.error());
2044 
2045     switch (type-&gt;type) {
2046     case Token::Type::IntLiteral: {
2047         auto value = intLiteralToInt(type-&gt;stringView(m_lexer));
2048         if (!value)
2049             return makeUnexpected(value.error());
2050         return { makeUniqueRef&lt;AST::IntegerLiteral&gt;(*type, *value) };
2051     }
2052     case Token::Type::UintLiteral: {
2053         auto value = uintLiteralToUint(type-&gt;stringView(m_lexer));
2054         if (!value)
2055             return makeUnexpected(value.error());
2056         return { makeUniqueRef&lt;AST::UnsignedIntegerLiteral&gt;(*type, *value) };
2057     }
2058     case Token::Type::FloatLiteral: {
2059         auto value = floatLiteralToFloat(type-&gt;stringView(m_lexer));
2060         if (!value)
2061             return makeUnexpected(value.error());
2062         return { makeUniqueRef&lt;AST::FloatLiteral&gt;(*type, *value) };
2063     }
2064     case Token::Type::Null:
<a name="4" id="anc4"></a><span class="line-modified">2065         return makeUnexpected(Error(&quot;&#39;null&#39; is a reserved keyword.&quot;, type-&gt;codeLocation));</span>
2066     case Token::Type::True:
2067         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(*type, true) };
2068     case Token::Type::False:
2069         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(*type, false) };
2070     case Token::Type::Identifier: {
2071         auto name = type-&gt;stringView(m_lexer).toString();
2072         return { makeUniqueRef&lt;AST::VariableReference&gt;(*type, WTFMove(name)) };
2073     }
2074     default: {
2075         ASSERT(type-&gt;type == Token::Type::LeftParenthesis);
2076         PARSE(expression, Expression);
2077         CONSUME_TYPE(rightParenthesis, RightParenthesis);
2078 
2079         return { WTFMove(*expression) };
2080     }
2081     }
2082 }
2083 
2084 } // namespace WHLSL
2085 
2086 } // namespace WebCore
2087 
2088 #endif // ENABLE(WEBGPU)
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
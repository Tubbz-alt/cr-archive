diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/coordinated/CoordinatedGraphicsLayer.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/coordinated/CoordinatedGraphicsLayer.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/coordinated/CoordinatedGraphicsLayer.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/coordinated/CoordinatedGraphicsLayer.cpp
@@ -104,13 +104,14 @@
         downcast<CoordinatedGraphicsLayer>(child.get()).setShouldUpdateVisibleRect();
     if (replicaLayer())
         downcast<CoordinatedGraphicsLayer>(*replicaLayer()).setShouldUpdateVisibleRect();
 }
 
-void CoordinatedGraphicsLayer::didChangeGeometry()
+void CoordinatedGraphicsLayer::didChangeGeometry(FlushNotification flushNotification)
 {
-    notifyFlushRequired();
+    if (flushNotification == FlushNotification::Required)
+        notifyFlushRequired();
     setShouldUpdateVisibleRect();
 }
 
 CoordinatedGraphicsLayer::CoordinatedGraphicsLayer(Type layerType, GraphicsLayerClient& client)
     : GraphicsLayer(layerType, client)
@@ -236,10 +237,19 @@
     GraphicsLayer::setPosition(p);
     m_nicosia.delta.positionChanged = true;
     didChangeGeometry();
 }
 
+void CoordinatedGraphicsLayer::syncPosition(const FloatPoint& p)
+{
+    if (position() == p)
+        return;
+
+    GraphicsLayer::syncPosition(p);
+    didChangeGeometry(FlushNotification::NotRequired);
+}
+
 void CoordinatedGraphicsLayer::setAnchorPoint(const FloatPoint3D& p)
 {
     if (anchorPoint() == p)
         return;
 
@@ -259,10 +269,29 @@
     if (maskLayer())
         maskLayer()->setSize(size);
     didChangeGeometry();
 }
 
+void CoordinatedGraphicsLayer::setBoundsOrigin(const FloatPoint& boundsOrigin)
+{
+    if (this->boundsOrigin() == boundsOrigin)
+        return;
+
+    GraphicsLayer::setBoundsOrigin(boundsOrigin);
+    m_nicosia.delta.boundsOriginChanged = true;
+    didChangeGeometry();
+}
+
+void CoordinatedGraphicsLayer::syncBoundsOrigin(const FloatPoint& boundsOrigin)
+{
+    if (this->boundsOrigin() == boundsOrigin)
+        return;
+
+    GraphicsLayer::syncBoundsOrigin(boundsOrigin);
+    didChangeGeometry(FlushNotification::NotRequired);
+}
+
 void CoordinatedGraphicsLayer::setTransform(const TransformationMatrix& t)
 {
     if (transform() == t)
         return;
 
@@ -792,11 +821,11 @@
                 !image.currentFrameKnownToBeOpaque() ? Nicosia::Buffer::SupportsAlpha : Nicosia::Buffer::NoFlags);
             Nicosia::PaintingContext::paint(buffer,
                 [&image](GraphicsContext& context)
                 {
                     IntRect rect { { }, IntSize { image.size() } };
-                    context.drawImage(image, rect, rect, ImagePaintingOptions(CompositeCopy));
+                    context.drawImage(image, rect, rect, ImagePaintingOptions(CompositeOperator::Copy));
                 });
             layerState.nativeImageID = nativeImageID;
             layerState.update.buffer = WTFMove(buffer);
             m_nicosia.delta.imageBackingChanged = true;
         }
@@ -841,11 +870,11 @@
                     state.solidColor = m_solidColor;
 
                 if (localDelta.filtersChanged)
                     state.filters = filters();
                 if (localDelta.animationsChanged)
-                    state.animations = m_animations.getActiveAnimations();
+                    state.animations = m_animations;
 
                 if (localDelta.childrenChanged) {
                     state.children = WTF::map(children(),
                         [](auto& child)
                         {
@@ -1130,11 +1159,11 @@
 
 FloatPoint CoordinatedGraphicsLayer::computePositionRelativeToBase()
 {
     FloatPoint offset;
     for (const GraphicsLayer* currLayer = this; currLayer; currLayer = currLayer->parent())
-        offset += currLayer->position();
+        offset += (currLayer->position() - currLayer->boundsOrigin());
 
     return offset;
 }
 
 void CoordinatedGraphicsLayer::computePixelAlignment(FloatPoint& position, FloatSize& size, FloatPoint3D& anchorPoint, FloatSize& alignmentOffset)
@@ -1206,11 +1235,12 @@
     setNeedsVisibleRectAdjustment();
 }
 
 bool CoordinatedGraphicsLayer::shouldHaveBackingStore() const
 {
-    return drawsContent() && contentsAreVisible() && !m_size.isEmpty();
+    return drawsContent() && contentsAreVisible() && !m_size.isEmpty()
+        && (!!opacity() || m_animations.hasActiveAnimationsOfType(AnimatedPropertyOpacity));
 }
 
 bool CoordinatedGraphicsLayer::selfOrAncestorHasActiveTransformAnimation() const
 {
     if (m_animations.hasActiveAnimationsOfType(AnimatedPropertyTransform))
@@ -1300,10 +1330,17 @@
 bool CoordinatedGraphicsLayer::usesContentsLayer() const
 {
     return m_nicosia.contentLayer || m_compositedImage;
 }
 
+#if USE(NICOSIA)
+PlatformLayer* CoordinatedGraphicsLayer::platformLayer() const
+{
+    return m_nicosia.layer.get();
+}
+#endif
+
 } // namespace WebCore
 
 SPECIALIZE_TYPE_TRAITS_ANIMATEDBACKINGSTORECLIENT(WebCore::CoordinatedAnimatedBackingStoreClient, type() == Nicosia::AnimatedBackingStoreClient::Type::Coordinated)
 
 #endif // USE(COORDINATED_GRAPHICS)

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Gigacage.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;Algorithm.h&quot;
 29 #include &quot;BAssert.h&quot;
 30 #include &quot;BExport.h&quot;
 31 #include &quot;BInline.h&quot;
 32 #include &quot;BPlatform.h&quot;
 33 #include &quot;Sizes.h&quot;
 34 #include &lt;cstddef&gt;
 35 #include &lt;inttypes.h&gt;
 36 
 37 #if ((BOS(DARWIN) || BOS(LINUX)) &amp;&amp; \
 38     (BCPU(X86_64) || (BCPU(ARM64) &amp;&amp; !defined(__ILP32__) &amp;&amp; (!BPLATFORM(IOS_FAMILY) || BPLATFORM(IOS)))))
 39 #define GIGACAGE_ENABLED 1
 40 #else
 41 #define GIGACAGE_ENABLED 0
 42 #endif
 43 
 44 
 45 namespace Gigacage {
 46 
 47 enum Kind {
<a name="1" id="anc1"></a><span class="line-removed"> 48     ReservedForFlagsAndNotABasePtr = 0,</span>
 49     Primitive,
 50     JSValue,
<a name="2" id="anc2"></a>
 51 };
 52 
 53 BINLINE const char* name(Kind kind)
 54 {
 55     switch (kind) {
<a name="3" id="anc3"></a><span class="line-removed"> 56     case ReservedForFlagsAndNotABasePtr:</span>
<span class="line-removed"> 57         RELEASE_BASSERT_NOT_REACHED();</span>
 58     case Primitive:
 59         return &quot;Primitive&quot;;
 60     case JSValue:
 61         return &quot;JSValue&quot;;
<a name="4" id="anc4"></a>

 62     }
 63     BCRASH();
 64     return nullptr;
 65 }
 66 
 67 #if GIGACAGE_ENABLED
 68 
<a name="5" id="anc5"></a><span class="line-modified"> 69 #if BCPU(ARM64)</span>


 70 constexpr size_t primitiveGigacageSize = 2 * bmalloc::Sizes::GB;
 71 constexpr size_t jsValueGigacageSize = 2 * bmalloc::Sizes::GB;
<a name="6" id="anc6"></a><span class="line-removed"> 72 constexpr size_t gigacageBasePtrsSize = 16 * bmalloc::Sizes::kB;</span>
 73 constexpr size_t maximumCageSizeReductionForSlide = bmalloc::Sizes::GB / 4;
<a name="7" id="anc7"></a><span class="line-removed"> 74 #define GIGACAGE_ALLOCATION_CAN_FAIL 1</span>
 75 #else
 76 constexpr size_t primitiveGigacageSize = 32 * bmalloc::Sizes::GB;
 77 constexpr size_t jsValueGigacageSize = 16 * bmalloc::Sizes::GB;
<a name="8" id="anc8"></a><span class="line-removed"> 78 constexpr size_t gigacageBasePtrsSize = 4 * bmalloc::Sizes::kB;</span>
 79 constexpr size_t maximumCageSizeReductionForSlide = 4 * bmalloc::Sizes::GB;
<a name="9" id="anc9"></a><span class="line-removed"> 80 #define GIGACAGE_ALLOCATION_CAN_FAIL 0</span>
 81 #endif
 82 
 83 // In Linux, if `vm.overcommit_memory = 2` is specified, mmap with large size can fail if it exceeds the size of RAM.
 84 // So we specify GIGACAGE_ALLOCATION_CAN_FAIL = 1.
 85 #if BOS(LINUX)
<a name="10" id="anc10"></a><span class="line-removed"> 86 #undef GIGACAGE_ALLOCATION_CAN_FAIL</span>
 87 #define GIGACAGE_ALLOCATION_CAN_FAIL 1
<a name="11" id="anc11"></a>

 88 #endif
 89 
 90 
 91 static_assert(bmalloc::isPowerOfTwo(primitiveGigacageSize), &quot;&quot;);
 92 static_assert(bmalloc::isPowerOfTwo(jsValueGigacageSize), &quot;&quot;);
 93 static_assert(primitiveGigacageSize &gt; maximumCageSizeReductionForSlide, &quot;&quot;);
 94 static_assert(jsValueGigacageSize &gt; maximumCageSizeReductionForSlide, &quot;&quot;);
 95 
 96 constexpr size_t gigacageSizeToMask(size_t size) { return size - 1; }
 97 
 98 constexpr size_t primitiveGigacageMask = gigacageSizeToMask(primitiveGigacageSize);
 99 constexpr size_t jsValueGigacageMask = gigacageSizeToMask(jsValueGigacageSize);
100 
<a name="12" id="anc12"></a><span class="line-modified">101 extern &quot;C&quot; alignas(gigacageBasePtrsSize) BEXPORT char g_gigacageBasePtrs[gigacageBasePtrsSize];</span>





102 
<a name="13" id="anc13"></a><span class="line-modified">103 BINLINE bool wasEnabled() { return g_gigacageBasePtrs[0]; }</span>
<span class="line-modified">104 BINLINE void setWasEnabled() { g_gigacageBasePtrs[0] = true; }</span>



105 
<a name="14" id="anc14"></a><span class="line-modified">106 struct BasePtrs {</span>
<span class="line-modified">107     uintptr_t reservedForFlags;</span>
<span class="line-modified">108     void* primitive;</span>
<span class="line-modified">109     void* jsValue;</span>



















110 };
<a name="15" id="anc15"></a>


111 
<a name="16" id="anc16"></a><span class="line-modified">112 static_assert(offsetof(BasePtrs, primitive) == Kind::Primitive * sizeof(void*), &quot;&quot;);</span>
<span class="line-modified">113 static_assert(offsetof(BasePtrs, jsValue) == Kind::JSValue * sizeof(void*), &quot;&quot;);</span>

114 
<a name="17" id="anc17"></a><span class="line-modified">115 constexpr unsigned numKinds = 2;</span>

116 
117 BEXPORT void ensureGigacage();
118 
119 BEXPORT void disablePrimitiveGigacage();
120 
121 // This will call the disable callback immediately if the Primitive Gigacage is currently disabled.
122 BEXPORT void addPrimitiveDisableCallback(void (*)(void*), void*);
123 BEXPORT void removePrimitiveDisableCallback(void (*)(void*), void*);
124 
<a name="18" id="anc18"></a><span class="line-modified">125 BEXPORT void disableDisablingPrimitiveGigacageIfShouldBeEnabled();</span>
<span class="line-removed">126 </span>
<span class="line-removed">127 BEXPORT bool isDisablingPrimitiveGigacageDisabled();</span>
<span class="line-removed">128 inline bool isPrimitiveGigacagePermanentlyEnabled() { return isDisablingPrimitiveGigacageDisabled(); }</span>
<span class="line-removed">129 inline bool canPrimitiveGigacageBeDisabled() { return !isDisablingPrimitiveGigacageDisabled(); }</span>
130 
<a name="19" id="anc19"></a><span class="line-modified">131 BINLINE void*&amp; basePtr(BasePtrs&amp; basePtrs, Kind kind)</span>
<span class="line-modified">132 {</span>
<span class="line-modified">133     switch (kind) {</span>
<span class="line-removed">134     case ReservedForFlagsAndNotABasePtr:</span>
<span class="line-removed">135         RELEASE_BASSERT_NOT_REACHED();</span>
<span class="line-removed">136     case Primitive:</span>
<span class="line-removed">137         return basePtrs.primitive;</span>
<span class="line-removed">138     case JSValue:</span>
<span class="line-removed">139         return basePtrs.jsValue;</span>
<span class="line-removed">140     }</span>
<span class="line-removed">141     BCRASH();</span>
<span class="line-removed">142     return basePtrs.primitive;</span>
<span class="line-removed">143 }</span>
144 
<a name="20" id="anc20"></a><span class="line-modified">145 BINLINE BasePtrs&amp; basePtrs()</span>
146 {
<a name="21" id="anc21"></a><span class="line-modified">147     return *reinterpret_cast&lt;BasePtrs*&gt;(reinterpret_cast&lt;void*&gt;(g_gigacageBasePtrs));</span>
148 }
149 
<a name="22" id="anc22"></a><span class="line-modified">150 BINLINE void*&amp; basePtr(Kind kind)</span>
151 {
<a name="23" id="anc23"></a><span class="line-modified">152     return basePtr(basePtrs(), kind);</span>

153 }
154 
155 BINLINE bool isEnabled(Kind kind)
156 {
<a name="24" id="anc24"></a><span class="line-modified">157     return !!basePtr(kind);</span>
158 }
159 
160 BINLINE size_t size(Kind kind)
161 {
162     switch (kind) {
<a name="25" id="anc25"></a><span class="line-removed">163     case ReservedForFlagsAndNotABasePtr:</span>
<span class="line-removed">164         RELEASE_BASSERT_NOT_REACHED();</span>
165     case Primitive:
166         return static_cast&lt;size_t&gt;(primitiveGigacageSize);
167     case JSValue:
168         return static_cast&lt;size_t&gt;(jsValueGigacageSize);
<a name="26" id="anc26"></a>

169     }
170     BCRASH();
171     return 0;
172 }
173 
174 BINLINE size_t alignment(Kind kind)
175 {
176     return size(kind);
177 }
178 
179 BINLINE size_t mask(Kind kind)
180 {
181     return gigacageSizeToMask(size(kind));
182 }
183 
184 template&lt;typename Func&gt;
185 void forEachKind(const Func&amp; func)
186 {
187     func(Primitive);
188     func(JSValue);
189 }
190 
191 template&lt;typename T&gt;
192 BINLINE T* caged(Kind kind, T* ptr)
193 {
194     BASSERT(ptr);
<a name="27" id="anc27"></a><span class="line-modified">195     void* gigacageBasePtr = basePtr(kind);</span>
196     if (!gigacageBasePtr)
197         return ptr;
198     return reinterpret_cast&lt;T*&gt;(
199         reinterpret_cast&lt;uintptr_t&gt;(gigacageBasePtr) + (
200             reinterpret_cast&lt;uintptr_t&gt;(ptr) &amp; mask(kind)));
201 }
202 
203 template&lt;typename T&gt;
204 BINLINE T* cagedMayBeNull(Kind kind, T* ptr)
205 {
206     if (!ptr)
207         return ptr;
208     return caged(kind, ptr);
209 }
210 
211 BINLINE bool isCaged(Kind kind, const void* ptr)
212 {
213     return caged(kind, ptr) == ptr;
214 }
215 
<a name="28" id="anc28"></a>






216 BEXPORT bool shouldBeEnabled();
217 
218 #else // GIGACAGE_ENABLED
219 
<a name="29" id="anc29"></a><span class="line-modified">220 BINLINE void*&amp; basePtr(Kind)</span>
221 {
222     BCRASH();
223     static void* unreachable;
224     return unreachable;
225 }
226 BINLINE size_t size(Kind) { BCRASH(); return 0; }
227 BINLINE void ensureGigacage() { }
<a name="30" id="anc30"></a><span class="line-modified">228 BINLINE bool wasEnabled() { return false; }</span>

229 BINLINE bool isCaged(Kind, const void*) { return true; }
230 BINLINE bool isEnabled(Kind) { return false; }
231 template&lt;typename T&gt; BINLINE T* caged(Kind, T* ptr) { return ptr; }
232 template&lt;typename T&gt; BINLINE T* cagedMayBeNull(Kind, T* ptr) { return ptr; }
<a name="31" id="anc31"></a><span class="line-modified">233 BINLINE void disableDisablingPrimitiveGigacageIfShouldBeEnabled() { }</span>
234 BINLINE bool canPrimitiveGigacageBeDisabled() { return false; }
235 BINLINE void disablePrimitiveGigacage() { }
236 BINLINE void addPrimitiveDisableCallback(void (*)(void*), void*) { }
237 BINLINE void removePrimitiveDisableCallback(void (*)(void*), void*) { }
238 
239 #endif // GIGACAGE_ENABLED
240 
241 } // namespace Gigacage
242 
243 
244 
<a name="32" id="anc32"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="32" type="hidden" />
</body>
</html>
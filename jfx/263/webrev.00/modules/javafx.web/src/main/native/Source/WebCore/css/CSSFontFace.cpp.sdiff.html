<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSFontFace.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSFilterImageValue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSFontFace.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSFontFace.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CSSFontFace.h&quot;
 28 
 29 #include &quot;CSSFontFaceSource.h&quot;
 30 #include &quot;CSSFontFaceSrcValue.h&quot;
 31 #include &quot;CSSFontFeatureValue.h&quot;
 32 #include &quot;CSSFontSelector.h&quot;
 33 #include &quot;CSSFontStyleRangeValue.h&quot;
 34 #include &quot;CSSPrimitiveValueMappings.h&quot;
 35 #include &quot;CSSUnicodeRangeValue.h&quot;
 36 #include &quot;CSSValue.h&quot;
 37 #include &quot;CSSValueList.h&quot;

 38 #include &quot;Document.h&quot;
 39 #include &quot;Font.h&quot;
 40 #include &quot;FontCache.h&quot;
 41 #include &quot;FontDescription.h&quot;
 42 #include &quot;FontFace.h&quot;
<span class="line-removed"> 43 #include &quot;FontVariantBuilder.h&quot;</span>
 44 #include &quot;Settings.h&quot;

 45 #include &quot;StyleBuilderConverter.h&quot;
 46 #include &quot;StyleProperties.h&quot;
 47 #include &quot;StyleRule.h&quot;
 48 
 49 namespace WebCore {
 50 


 51 template&lt;typename T&gt; void iterateClients(HashSet&lt;CSSFontFace::Client*&gt;&amp; clients, T callback)
 52 {
 53     Vector&lt;Ref&lt;CSSFontFace::Client&gt;&gt; clientsCopy;
 54     clientsCopy.reserveInitialCapacity(clients.size());
 55     for (auto* client : clients)
 56         clientsCopy.uncheckedAppend(*client);
 57 
 58     for (auto* client : clients)
 59         callback(*client);
 60 }
 61 
 62 void CSSFontFace::appendSources(CSSFontFace&amp; fontFace, CSSValueList&amp; srcList, Document* document, bool isInitiatingElementInUserAgentShadowTree)
 63 {
 64     for (auto&amp; src : srcList) {
 65         // An item in the list either specifies a string (local font name) or a URL (remote font to download).
 66         CSSFontFaceSrcValue&amp; item = downcast&lt;CSSFontFaceSrcValue&gt;(src.get());
 67         std::unique_ptr&lt;CSSFontFaceSource&gt; source;
 68         SVGFontFaceElement* fontFaceElement = nullptr;
 69         bool foundSVGFont = false;
 70 
</pre>
<hr />
<pre>
 72         foundSVGFont = item.isSVGFontFaceSrc() || item.svgFontFaceElement();
 73         fontFaceElement = item.svgFontFaceElement();
 74 #endif
 75         if (!item.isLocal()) {
 76             const Settings* settings = document ? &amp;document-&gt;settings() : nullptr;
 77             bool allowDownloading = foundSVGFont || (settings &amp;&amp; settings-&gt;downloadableBinaryFontsEnabled());
 78             if (allowDownloading &amp;&amp; item.isSupportedFormat() &amp;&amp; document) {
 79                 if (CachedFont* cachedFont = item.cachedFont(document, foundSVGFont, isInitiatingElementInUserAgentShadowTree))
 80                     source = makeUnique&lt;CSSFontFaceSource&gt;(fontFace, item.resource(), cachedFont);
 81             }
 82         } else
 83             source = makeUnique&lt;CSSFontFaceSource&gt;(fontFace, item.resource(), nullptr, fontFaceElement);
 84 
 85         if (source)
 86             fontFace.adoptSource(WTFMove(source));
 87     }
 88     fontFace.sourcesPopulated();
 89 }
 90 
 91 CSSFontFace::CSSFontFace(CSSFontSelector* fontSelector, StyleRuleFontFace* cssConnection, FontFace* wrapper, bool isLocalFallback)
<span class="line-modified"> 92     : m_fontSelector(fontSelector)</span>
 93     , m_cssConnection(cssConnection)
 94     , m_wrapper(makeWeakPtr(wrapper))
 95     , m_isLocalFallback(isLocalFallback)
 96     , m_mayBePurged(!wrapper)
 97     , m_timeoutTimer(*this, &amp;CSSFontFace::timeoutFired)
 98 {
 99 }
100 
101 CSSFontFace::~CSSFontFace() = default;
102 
103 bool CSSFontFace::setFamilies(CSSValue&amp; family)
104 {
105     if (!is&lt;CSSValueList&gt;(family))
106         return false;
107 
108     CSSValueList&amp; familyList = downcast&lt;CSSValueList&gt;(family);
109     if (!familyList.length())
110         return false;
111 
112     RefPtr&lt;CSSValueList&gt; oldFamilies = m_families;
</pre>
<hr />
<pre>
121 
122     return true;
123 }
124 
125 FontFace* CSSFontFace::existingWrapper()
126 {
127     return m_wrapper.get();
128 }
129 
130 static FontSelectionRange calculateWeightRange(CSSValue&amp; value)
131 {
132     if (value.isValueList()) {
133         auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
134         ASSERT(valueList.length() == 2);
135         if (valueList.length() != 2)
136             return { normalWeightValue(), normalWeightValue() };
137         ASSERT(valueList.item(0)-&gt;isPrimitiveValue());
138         ASSERT(valueList.item(1)-&gt;isPrimitiveValue());
139         auto&amp; value0 = downcast&lt;CSSPrimitiveValue&gt;(*valueList.item(0));
140         auto&amp; value1 = downcast&lt;CSSPrimitiveValue&gt;(*valueList.item(1));
<span class="line-modified">141         auto result0 = StyleBuilderConverter::convertFontWeightFromValue(value0);</span>
<span class="line-modified">142         auto result1 = StyleBuilderConverter::convertFontWeightFromValue(value1);</span>
143         return { result0, result1 };
144     }
145 
146     ASSERT(is&lt;CSSPrimitiveValue&gt;(value));
147     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
<span class="line-modified">148     FontSelectionValue result = StyleBuilderConverter::convertFontWeightFromValue(primitiveValue);</span>
149     return { result, result };
150 }
151 
152 void CSSFontFace::setWeight(CSSValue&amp; weight)
153 {
154     auto range = calculateWeightRange(weight);
155     if (m_fontSelectionCapabilities.weight == range)
156         return;
157 
158     setWeight(range);
159 
160     if (m_cssConnection)
161         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyFontWeight, &amp;weight);
162 
163     iterateClients(m_clients, [&amp;](Client&amp; client) {
164         client.fontPropertyChanged(*this);
165     });
166 }
167 
168 static FontSelectionRange calculateStretchRange(CSSValue&amp; value)
169 {
170     if (value.isValueList()) {
171         auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
172         ASSERT(valueList.length() == 2);
173         if (valueList.length() != 2)
174             return { normalStretchValue(), normalStretchValue() };
175         ASSERT(valueList.item(0)-&gt;isPrimitiveValue());
176         ASSERT(valueList.item(1)-&gt;isPrimitiveValue());
177         auto&amp; value0 = downcast&lt;CSSPrimitiveValue&gt;(*valueList.item(0));
178         auto&amp; value1 = downcast&lt;CSSPrimitiveValue&gt;(*valueList.item(1));
<span class="line-modified">179         auto result0 = StyleBuilderConverter::convertFontStretchFromValue(value0);</span>
<span class="line-modified">180         auto result1 = StyleBuilderConverter::convertFontStretchFromValue(value1);</span>
181         return { result0, result1 };
182     }
183 
184     ASSERT(is&lt;CSSPrimitiveValue&gt;(value));
185     const auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
<span class="line-modified">186     FontSelectionValue result = StyleBuilderConverter::convertFontStretchFromValue(primitiveValue);</span>
187     return { result, result };
188 }
189 
190 void CSSFontFace::setStretch(CSSValue&amp; style)
191 {
192     auto range = calculateStretchRange(style);
193     if (m_fontSelectionCapabilities.width == range)
194         return;
195 
196     setStretch(range);
197 
198     if (m_cssConnection)
199         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyFontStretch, &amp;style);
200 
201     iterateClients(m_clients, [&amp;](Client&amp; client) {
202         client.fontPropertyChanged(*this);
203     });
204 }
205 
206 static FontSelectionRange calculateItalicRange(CSSValue&amp; value)
207 {
208     if (value.isFontStyleValue()) {
<span class="line-modified">209         auto result = StyleBuilderConverter::convertFontStyleFromValue(value);</span>
210         return { result.valueOr(normalItalicValue()), result.valueOr(normalItalicValue()) };
211     }
212 
213     ASSERT(value.isFontStyleRangeValue());
214     auto&amp; rangeValue = downcast&lt;CSSFontStyleRangeValue&gt;(value);
215     ASSERT(rangeValue.fontStyleValue-&gt;isValueID());
216     auto valueID = rangeValue.fontStyleValue-&gt;valueID();
217     if (!rangeValue.obliqueValues) {
218         if (valueID == CSSValueNormal)
219             return { normalItalicValue(), normalItalicValue() };
220         ASSERT(valueID == CSSValueItalic || valueID == CSSValueOblique);
221         return { italicValue(), italicValue() };
222     }
223     ASSERT(valueID == CSSValueOblique);
224     auto length = rangeValue.obliqueValues-&gt;length();
225     if (length == 1) {
226         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*rangeValue.obliqueValues-&gt;item(0));
<span class="line-modified">227         FontSelectionValue result(primitiveValue.value&lt;float&gt;(CSSPrimitiveValue::CSS_DEG));</span>
228         return { result, result };
229     }
230     ASSERT(length == 2);
231     auto&amp; primitiveValue1 = downcast&lt;CSSPrimitiveValue&gt;(*rangeValue.obliqueValues-&gt;item(0));
232     auto&amp; primitiveValue2 = downcast&lt;CSSPrimitiveValue&gt;(*rangeValue.obliqueValues-&gt;item(1));
<span class="line-modified">233     FontSelectionValue result1(primitiveValue1.value&lt;float&gt;(CSSPrimitiveValue::CSS_DEG));</span>
<span class="line-modified">234     FontSelectionValue result2(primitiveValue2.value&lt;float&gt;(CSSPrimitiveValue::CSS_DEG));</span>
235     return { result1, result2 };
236 }
237 
238 void CSSFontFace::setStyle(CSSValue&amp; style)
239 {
240     auto range = calculateItalicRange(style);
241     if (m_fontSelectionCapabilities.slope == range)
242         return;
243 
244     setStyle(range);
245 
246     if (m_cssConnection)
247         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyFontStyle, &amp;style);
248 
249     iterateClients(m_clients, [&amp;](Client&amp; client) {
250         client.fontPropertyChanged(*this);
251     });
252 }
253 
254 bool CSSFontFace::setUnicodeRange(CSSValue&amp; unicodeRange)
</pre>
<hr />
<pre>
261     for (auto&amp; rangeValue : list) {
262         auto&amp; range = downcast&lt;CSSUnicodeRangeValue&gt;(rangeValue.get());
263         ranges.append({ range.from(), range.to() });
264     }
265 
266     if (ranges == m_ranges)
267         return true;
268 
269     m_ranges = WTFMove(ranges);
270 
271     if (m_cssConnection)
272         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyUnicodeRange, &amp;unicodeRange);
273 
274     iterateClients(m_clients, [&amp;](Client&amp; client) {
275         client.fontPropertyChanged(*this);
276     });
277 
278     return true;
279 }
280 
<span class="line-removed">281 bool CSSFontFace::setVariantLigatures(CSSValue&amp; variantLigatures)</span>
<span class="line-removed">282 {</span>
<span class="line-removed">283     auto ligatures = extractFontVariantLigatures(variantLigatures);</span>
<span class="line-removed">284 </span>
<span class="line-removed">285     if (m_variantSettings.commonLigatures == ligatures.commonLigatures</span>
<span class="line-removed">286         &amp;&amp; m_variantSettings.discretionaryLigatures == ligatures.discretionaryLigatures</span>
<span class="line-removed">287         &amp;&amp; m_variantSettings.historicalLigatures == ligatures.historicalLigatures</span>
<span class="line-removed">288         &amp;&amp; m_variantSettings.contextualAlternates == ligatures.contextualAlternates)</span>
<span class="line-removed">289         return true;</span>
<span class="line-removed">290 </span>
<span class="line-removed">291     m_variantSettings.commonLigatures = ligatures.commonLigatures;</span>
<span class="line-removed">292     m_variantSettings.discretionaryLigatures = ligatures.discretionaryLigatures;</span>
<span class="line-removed">293     m_variantSettings.historicalLigatures = ligatures.historicalLigatures;</span>
<span class="line-removed">294     m_variantSettings.contextualAlternates = ligatures.contextualAlternates;</span>
<span class="line-removed">295 </span>
<span class="line-removed">296     if (m_cssConnection)</span>
<span class="line-removed">297         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyFontVariantLigatures, &amp;variantLigatures);</span>
<span class="line-removed">298 </span>
<span class="line-removed">299     iterateClients(m_clients, [&amp;](Client&amp; client) {</span>
<span class="line-removed">300         client.fontPropertyChanged(*this);</span>
<span class="line-removed">301     });</span>
<span class="line-removed">302 </span>
<span class="line-removed">303     return true;</span>
<span class="line-removed">304 }</span>
<span class="line-removed">305 </span>
<span class="line-removed">306 bool CSSFontFace::setVariantPosition(CSSValue&amp; variantPosition)</span>
<span class="line-removed">307 {</span>
<span class="line-removed">308     if (!is&lt;CSSPrimitiveValue&gt;(variantPosition))</span>
<span class="line-removed">309         return false;</span>
<span class="line-removed">310 </span>
<span class="line-removed">311     FontVariantPosition position = downcast&lt;CSSPrimitiveValue&gt;(variantPosition);</span>
<span class="line-removed">312 </span>
<span class="line-removed">313     if (m_variantSettings.position == position)</span>
<span class="line-removed">314         return true;</span>
<span class="line-removed">315 </span>
<span class="line-removed">316     m_variantSettings.position = position;</span>
<span class="line-removed">317 </span>
<span class="line-removed">318     if (m_cssConnection)</span>
<span class="line-removed">319         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyFontVariantPosition, &amp;variantPosition);</span>
<span class="line-removed">320 </span>
<span class="line-removed">321     iterateClients(m_clients, [&amp;](Client&amp; client) {</span>
<span class="line-removed">322         client.fontPropertyChanged(*this);</span>
<span class="line-removed">323     });</span>
<span class="line-removed">324 </span>
<span class="line-removed">325     return true;</span>
<span class="line-removed">326 }</span>
<span class="line-removed">327 </span>
<span class="line-removed">328 bool CSSFontFace::setVariantCaps(CSSValue&amp; variantCaps)</span>
<span class="line-removed">329 {</span>
<span class="line-removed">330     if (!is&lt;CSSPrimitiveValue&gt;(variantCaps))</span>
<span class="line-removed">331         return false;</span>
<span class="line-removed">332 </span>
<span class="line-removed">333     FontVariantCaps caps = downcast&lt;CSSPrimitiveValue&gt;(variantCaps);</span>
<span class="line-removed">334 </span>
<span class="line-removed">335     if (m_variantSettings.caps == caps)</span>
<span class="line-removed">336         return true;</span>
<span class="line-removed">337 </span>
<span class="line-removed">338     m_variantSettings.caps = caps;</span>
<span class="line-removed">339 </span>
<span class="line-removed">340     if (m_cssConnection)</span>
<span class="line-removed">341         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyFontVariantCaps, &amp;variantCaps);</span>
<span class="line-removed">342 </span>
<span class="line-removed">343     iterateClients(m_clients, [&amp;](Client&amp; client) {</span>
<span class="line-removed">344         client.fontPropertyChanged(*this);</span>
<span class="line-removed">345     });</span>
<span class="line-removed">346 </span>
<span class="line-removed">347     return true;</span>
<span class="line-removed">348 }</span>
<span class="line-removed">349 </span>
<span class="line-removed">350 bool CSSFontFace::setVariantNumeric(CSSValue&amp; variantNumeric)</span>
<span class="line-removed">351 {</span>
<span class="line-removed">352     auto numeric = extractFontVariantNumeric(variantNumeric);</span>
<span class="line-removed">353 </span>
<span class="line-removed">354     if (m_variantSettings.numericFigure == numeric.figure</span>
<span class="line-removed">355         &amp;&amp; m_variantSettings.numericSpacing == numeric.spacing</span>
<span class="line-removed">356         &amp;&amp; m_variantSettings.numericFraction == numeric.fraction</span>
<span class="line-removed">357         &amp;&amp; m_variantSettings.numericOrdinal == numeric.ordinal</span>
<span class="line-removed">358         &amp;&amp; m_variantSettings.numericSlashedZero == numeric.slashedZero)</span>
<span class="line-removed">359         return true;</span>
<span class="line-removed">360 </span>
<span class="line-removed">361     m_variantSettings.numericFigure = numeric.figure;</span>
<span class="line-removed">362     m_variantSettings.numericSpacing = numeric.spacing;</span>
<span class="line-removed">363     m_variantSettings.numericFraction = numeric.fraction;</span>
<span class="line-removed">364     m_variantSettings.numericOrdinal = numeric.ordinal;</span>
<span class="line-removed">365     m_variantSettings.numericSlashedZero = numeric.slashedZero;</span>
<span class="line-removed">366 </span>
<span class="line-removed">367     if (m_cssConnection)</span>
<span class="line-removed">368         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyFontVariantNumeric, &amp;variantNumeric);</span>
<span class="line-removed">369 </span>
<span class="line-removed">370     iterateClients(m_clients, [&amp;](Client&amp; client) {</span>
<span class="line-removed">371         client.fontPropertyChanged(*this);</span>
<span class="line-removed">372     });</span>
<span class="line-removed">373 </span>
<span class="line-removed">374     return true;</span>
<span class="line-removed">375 }</span>
<span class="line-removed">376 </span>
<span class="line-removed">377 bool CSSFontFace::setVariantAlternates(CSSValue&amp; variantAlternates)</span>
<span class="line-removed">378 {</span>
<span class="line-removed">379     if (!is&lt;CSSPrimitiveValue&gt;(variantAlternates))</span>
<span class="line-removed">380         return false;</span>
<span class="line-removed">381 </span>
<span class="line-removed">382     FontVariantAlternates alternates = downcast&lt;CSSPrimitiveValue&gt;(variantAlternates);</span>
<span class="line-removed">383 </span>
<span class="line-removed">384     if (m_variantSettings.alternates == alternates)</span>
<span class="line-removed">385         return true;</span>
<span class="line-removed">386 </span>
<span class="line-removed">387     m_variantSettings.alternates = alternates;</span>
<span class="line-removed">388 </span>
<span class="line-removed">389     if (m_cssConnection)</span>
<span class="line-removed">390         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyFontVariantAlternates, &amp;variantAlternates);</span>
<span class="line-removed">391 </span>
<span class="line-removed">392     iterateClients(m_clients, [&amp;](Client&amp; client) {</span>
<span class="line-removed">393         client.fontPropertyChanged(*this);</span>
<span class="line-removed">394     });</span>
<span class="line-removed">395 </span>
<span class="line-removed">396     return true;</span>
<span class="line-removed">397 }</span>
<span class="line-removed">398 </span>
<span class="line-removed">399 bool CSSFontFace::setVariantEastAsian(CSSValue&amp; variantEastAsian)</span>
<span class="line-removed">400 {</span>
<span class="line-removed">401     auto eastAsian = extractFontVariantEastAsian(variantEastAsian);</span>
<span class="line-removed">402 </span>
<span class="line-removed">403     if (m_variantSettings.eastAsianVariant == eastAsian.variant</span>
<span class="line-removed">404         &amp;&amp; m_variantSettings.eastAsianWidth == eastAsian.width</span>
<span class="line-removed">405         &amp;&amp; m_variantSettings.eastAsianRuby == eastAsian.ruby)</span>
<span class="line-removed">406         return true;</span>
<span class="line-removed">407 </span>
<span class="line-removed">408     m_variantSettings.eastAsianVariant = eastAsian.variant;</span>
<span class="line-removed">409     m_variantSettings.eastAsianWidth = eastAsian.width;</span>
<span class="line-removed">410     m_variantSettings.eastAsianRuby = eastAsian.ruby;</span>
<span class="line-removed">411 </span>
<span class="line-removed">412     if (m_cssConnection)</span>
<span class="line-removed">413         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyFontVariantEastAsian, &amp;variantEastAsian);</span>
<span class="line-removed">414 </span>
<span class="line-removed">415     iterateClients(m_clients, [&amp;](Client&amp; client) {</span>
<span class="line-removed">416         client.fontPropertyChanged(*this);</span>
<span class="line-removed">417     });</span>
<span class="line-removed">418 </span>
<span class="line-removed">419     return true;</span>
<span class="line-removed">420 }</span>
<span class="line-removed">421 </span>
422 void CSSFontFace::setFeatureSettings(CSSValue&amp; featureSettings)
423 {
424     // Can only call this with a primitive value of normal, or a value list containing font feature values.
425     ASSERT(is&lt;CSSPrimitiveValue&gt;(featureSettings) || is&lt;CSSValueList&gt;(featureSettings));
426 
427     FontFeatureSettings settings;
428 
429     if (is&lt;CSSValueList&gt;(featureSettings)) {
430         auto&amp; list = downcast&lt;CSSValueList&gt;(featureSettings);
431         for (auto&amp; rangeValue : list) {
432             auto&amp; feature = downcast&lt;CSSFontFeatureValue&gt;(rangeValue.get());
433             settings.insert({ feature.tag(), feature.value() });
434         }
435     }
436 
437     if (m_featureSettings == settings)
438         return;
439 
440     m_featureSettings = WTFMove(settings);
441 
</pre>
<hr />
<pre>
467 bool CSSFontFace::rangesMatchCodePoint(UChar32 character) const
468 {
469     if (m_ranges.isEmpty())
470         return true;
471 
472     for (auto&amp; range : m_ranges) {
473         if (range.from &lt;= character &amp;&amp; character &lt;= range.to)
474             return true;
475     }
476     return false;
477 }
478 
479 void CSSFontFace::fontLoadEventOccurred()
480 {
481     // If the font is already in the cache, CSSFontFaceSource may report it&#39;s loaded before it is added here as a source.
482     // Let&#39;s not pump the state machine until we&#39;ve got all our sources. font() and load() are smart enough to act correctly
483     // when a source is failed or succeeded before we have asked it to load.
484     if (m_sourcesPopulated)
485         pump(ExternalResourceDownloadPolicy::Forbid);
486 
<span class="line-modified">487     ASSERT(m_fontSelector);</span>
<span class="line-modified">488     m_fontSelector-&gt;fontLoaded();</span>
489 
490     iterateClients(m_clients, [&amp;](Client&amp; client) {
491         client.fontLoaded(*this);
492     });
493 }
494 
495 void CSSFontFace::timeoutFired()
496 {
497     Ref&lt;CSSFontFace&gt; protectedThis(*this);
498 
499     switch (status()) {
500     case Status::Loading:
501         setStatus(Status::TimedOut);
502         break;
503     case Status::TimedOut:
504         // Cancelling the network request here could lead to a situation where a site&#39;s font never gets
505         // shown as the user navigates around to different pages on the site. This would occur if the
506         // download always takes longer than the timeout (even though the user may spend substantial time
507         // on each page). Therefore, we shouldn&#39;t cancel the network request here, but should use the
508         // loading infrastructure&#39;s timeout policies instead.
</pre>
<hr />
<pre>
570     auto wrapper = FontFace::create(*this);
571     m_wrapper = makeWeakPtr(wrapper.get());
572     initializeWrapper();
573     return wrapper;
574 }
575 
576 void CSSFontFace::setWrapper(FontFace&amp; newWrapper)
577 {
578     m_wrapper = makeWeakPtr(newWrapper);
579     initializeWrapper();
580 }
581 
582 void CSSFontFace::adoptSource(std::unique_ptr&lt;CSSFontFaceSource&gt;&amp;&amp; source)
583 {
584     m_sources.append(WTFMove(source));
585 
586     // We should never add sources in the middle of loading.
587     ASSERT(!m_sourcesPopulated);
588 }
589 
<span class="line-modified">590 AllowUserInstalledFonts CSSFontFace::allowUserInstalledFonts() const</span>
591 {
<span class="line-modified">592     if (m_fontSelector &amp;&amp; m_fontSelector-&gt;document())</span>
<span class="line-removed">593         return m_fontSelector-&gt;document()-&gt;settings().shouldAllowUserInstalledFonts() ? AllowUserInstalledFonts::Yes : AllowUserInstalledFonts::No;</span>
<span class="line-removed">594     return AllowUserInstalledFonts::Yes;</span>
595 }
596 
<span class="line-modified">597 bool CSSFontFace::shouldAllowDesignSystemUIFonts() const</span>
598 {
599     if (m_fontSelector &amp;&amp; m_fontSelector-&gt;document())
<span class="line-modified">600         return m_fontSelector-&gt;document()-&gt;settings().shouldAllowDesignSystemUIFonts();</span>
<span class="line-modified">601     return false;</span>
602 }
603 
604 static Settings::FontLoadTimingOverride fontLoadTimingOverride(CSSFontSelector* fontSelector)
605 {
606     auto overrideValue = Settings::FontLoadTimingOverride::None;
607     if (fontSelector &amp;&amp; fontSelector-&gt;document())
608         overrideValue = fontSelector-&gt;document()-&gt;settings().fontLoadTimingOverride();
609     return overrideValue;
610 }
611 
612 auto CSSFontFace::fontLoadTiming() const -&gt; FontLoadTiming
613 {
614     switch (fontLoadTimingOverride(m_fontSelector.get())) {
615     case Settings::FontLoadTimingOverride::None:
616         switch (m_loadingBehavior) {
617         case FontLoadingBehavior::Auto:
618         case FontLoadingBehavior::Block:
619             return { 3_s, Seconds::infinity() };
620         case FontLoadingBehavior::Swap:
621             return { 0_s, Seconds::infinity() };
</pre>
<hr />
<pre>
720     if (status() == Status::Failure)
721         return 0;
722 
723     size_t i;
724     for (i = 0; i &lt; m_sources.size(); ++i) {
725         auto&amp; source = m_sources[i];
726 
727         if (source-&gt;status() == CSSFontFaceSource::Status::Pending) {
728             ASSERT(m_status == Status::Pending || m_status == Status::Loading || m_status == Status::TimedOut);
729             // This is a little tricky. After calling CSSFontFace::font(Forbid), a font must never fail later in
730             // this turn of the runloop because the return value of CSSFontFace::font() shouldn&#39;t get nulled out
731             // from under an existing FontRanges object. Remote fonts are all downloaded asynchronously, so this
732             // isn&#39;t a problem for them because CSSFontFace::font() will always return the interstitial font.
733             // However, local fonts may synchronously fail when you call load() on them. Therefore, we have to call
734             // load() here in order to guarantee that, if the font synchronously fails, it happens now during the
735             // first call to CSSFontFace::font() and the FontRanges object sees a consistent view of the
736             // CSSFontFace. This means we eagerly create some internal font objects when they may not be needed,
737             // but it seems that this behavior is a requirement of the design of FontRanges. FIXME: Perhaps rethink
738             // this design.
739             if (policy == ExternalResourceDownloadPolicy::Allow || !source-&gt;requiresExternalResource()) {
<span class="line-modified">740                 if (m_status == Status::Pending)</span>
741                     setStatus(Status::Loading);
742                 source-&gt;load(m_fontSelector.get());
743             }
744         }
745 
746         switch (source-&gt;status()) {
747         case CSSFontFaceSource::Status::Pending:
748             ASSERT(policy == ExternalResourceDownloadPolicy::Forbid);
749             return i;
750         case CSSFontFaceSource::Status::Loading:
751             ASSERT(m_status == Status::Pending || m_status == Status::Loading || m_status == Status::TimedOut || m_status == Status::Failure);
<span class="line-modified">752             if (m_status == Status::Pending)</span>
753                 setStatus(Status::Loading);
754             return i;
755         case CSSFontFaceSource::Status::Success:
756             ASSERT(m_status == Status::Pending || m_status == Status::Loading || m_status == Status::TimedOut || m_status == Status::Success || m_status == Status::Failure);
757             if (m_status == Status::Pending)
758                 setStatus(Status::Loading);
759             if (m_status == Status::Loading || m_status == Status::TimedOut)
760                 setStatus(Status::Success);
761             return i;
762         case CSSFontFaceSource::Status::Failure:
<span class="line-modified">763             if (m_status == Status::Pending)</span>
764                 setStatus(Status::Loading);
765             break;
766         }
767     }
768     if (m_sources.isEmpty() &amp;&amp; m_status == Status::Pending)
769         setStatus(Status::Loading);
770     if (m_status == Status::Loading || m_status == Status::TimedOut)
771         setStatus(Status::Failure);
772     return m_sources.size();
773 }
774 
775 void CSSFontFace::load()
776 {
777     pump(ExternalResourceDownloadPolicy::Allow);
778 }
779 
780 static Font::Visibility visibility(CSSFontFace::Status status, CSSFontFace::FontLoadTiming timing)
781 {
782     switch (status) {
783     case CSSFontFace::Status::Pending:
</pre>
<hr />
<pre>
803     // return null from font(), which means we need to continue looping through the remainder
804     // of the sources to try to find a font to use. These subsequent tries should not affect
805     // our own state, though.
806     size_t startIndex = pump(policy);
807 
808     if (computeFailureState())
809         return nullptr;
810 
811     for (size_t i = startIndex; i &lt; m_sources.size(); ++i) {
812         auto&amp; source = m_sources[i];
813         if (source-&gt;status() == CSSFontFaceSource::Status::Pending &amp;&amp; (policy == ExternalResourceDownloadPolicy::Allow || !source-&gt;requiresExternalResource()))
814             source-&gt;load(m_fontSelector.get());
815 
816         switch (source-&gt;status()) {
817         case CSSFontFaceSource::Status::Pending:
818         case CSSFontFaceSource::Status::Loading: {
819             Font::Visibility visibility = WebCore::visibility(status(), fontLoadTiming());
820             return Font::create(FontCache::singleton().lastResortFallbackFont(fontDescription)-&gt;platformData(), Font::Origin::Local, Font::Interstitial::Yes, visibility);
821         }
822         case CSSFontFaceSource::Status::Success:
<span class="line-modified">823             if (RefPtr&lt;Font&gt; result = source-&gt;font(fontDescription, syntheticBold, syntheticItalic, m_featureSettings, m_variantSettings, m_fontSelectionCapabilities))</span>


824                 return result;

825             break;
826         case CSSFontFaceSource::Status::Failure:
827             break;
828         }
829     }
830 
831     return nullptr;
832 }
833 
834 bool CSSFontFace::purgeable() const
835 {
836     return cssConnection() &amp;&amp; m_mayBePurged;
837 }
838 
839 void CSSFontFace::updateStyleIfNeeded()
840 {
841     if (m_fontSelector &amp;&amp; m_fontSelector-&gt;document())
842         m_fontSelector-&gt;document()-&gt;updateStyleIfNeeded();
843 }
844 
845 #if ENABLE(SVG_FONTS)
846 bool CSSFontFace::hasSVGFontFaceSource() const
847 {
848     size_t size = m_sources.size();
849     for (size_t i = 0; i &lt; size; i++) {
850         if (m_sources[i]-&gt;isSVGFontFaceSource())
851             return true;
852     }
853     return false;
854 }
855 #endif
856 


















857 }
</pre>
</td>
<td>
<hr />
<pre>
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CSSFontFace.h&quot;
 28 
 29 #include &quot;CSSFontFaceSource.h&quot;
 30 #include &quot;CSSFontFaceSrcValue.h&quot;
 31 #include &quot;CSSFontFeatureValue.h&quot;
 32 #include &quot;CSSFontSelector.h&quot;
 33 #include &quot;CSSFontStyleRangeValue.h&quot;
 34 #include &quot;CSSPrimitiveValueMappings.h&quot;
 35 #include &quot;CSSUnicodeRangeValue.h&quot;
 36 #include &quot;CSSValue.h&quot;
 37 #include &quot;CSSValueList.h&quot;
<span class="line-added"> 38 #include &quot;CachedFont.h&quot;</span>
 39 #include &quot;Document.h&quot;
 40 #include &quot;Font.h&quot;
 41 #include &quot;FontCache.h&quot;
 42 #include &quot;FontDescription.h&quot;
 43 #include &quot;FontFace.h&quot;

 44 #include &quot;Settings.h&quot;
<span class="line-added"> 45 #include &quot;SharedBuffer.h&quot;</span>
 46 #include &quot;StyleBuilderConverter.h&quot;
 47 #include &quot;StyleProperties.h&quot;
 48 #include &quot;StyleRule.h&quot;
 49 
 50 namespace WebCore {
 51 
<span class="line-added"> 52 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(CSSFontFace);</span>
<span class="line-added"> 53 </span>
 54 template&lt;typename T&gt; void iterateClients(HashSet&lt;CSSFontFace::Client*&gt;&amp; clients, T callback)
 55 {
 56     Vector&lt;Ref&lt;CSSFontFace::Client&gt;&gt; clientsCopy;
 57     clientsCopy.reserveInitialCapacity(clients.size());
 58     for (auto* client : clients)
 59         clientsCopy.uncheckedAppend(*client);
 60 
 61     for (auto* client : clients)
 62         callback(*client);
 63 }
 64 
 65 void CSSFontFace::appendSources(CSSFontFace&amp; fontFace, CSSValueList&amp; srcList, Document* document, bool isInitiatingElementInUserAgentShadowTree)
 66 {
 67     for (auto&amp; src : srcList) {
 68         // An item in the list either specifies a string (local font name) or a URL (remote font to download).
 69         CSSFontFaceSrcValue&amp; item = downcast&lt;CSSFontFaceSrcValue&gt;(src.get());
 70         std::unique_ptr&lt;CSSFontFaceSource&gt; source;
 71         SVGFontFaceElement* fontFaceElement = nullptr;
 72         bool foundSVGFont = false;
 73 
</pre>
<hr />
<pre>
 75         foundSVGFont = item.isSVGFontFaceSrc() || item.svgFontFaceElement();
 76         fontFaceElement = item.svgFontFaceElement();
 77 #endif
 78         if (!item.isLocal()) {
 79             const Settings* settings = document ? &amp;document-&gt;settings() : nullptr;
 80             bool allowDownloading = foundSVGFont || (settings &amp;&amp; settings-&gt;downloadableBinaryFontsEnabled());
 81             if (allowDownloading &amp;&amp; item.isSupportedFormat() &amp;&amp; document) {
 82                 if (CachedFont* cachedFont = item.cachedFont(document, foundSVGFont, isInitiatingElementInUserAgentShadowTree))
 83                     source = makeUnique&lt;CSSFontFaceSource&gt;(fontFace, item.resource(), cachedFont);
 84             }
 85         } else
 86             source = makeUnique&lt;CSSFontFaceSource&gt;(fontFace, item.resource(), nullptr, fontFaceElement);
 87 
 88         if (source)
 89             fontFace.adoptSource(WTFMove(source));
 90     }
 91     fontFace.sourcesPopulated();
 92 }
 93 
 94 CSSFontFace::CSSFontFace(CSSFontSelector* fontSelector, StyleRuleFontFace* cssConnection, FontFace* wrapper, bool isLocalFallback)
<span class="line-modified"> 95     : m_fontSelector(makeWeakPtr(fontSelector))</span>
 96     , m_cssConnection(cssConnection)
 97     , m_wrapper(makeWeakPtr(wrapper))
 98     , m_isLocalFallback(isLocalFallback)
 99     , m_mayBePurged(!wrapper)
100     , m_timeoutTimer(*this, &amp;CSSFontFace::timeoutFired)
101 {
102 }
103 
104 CSSFontFace::~CSSFontFace() = default;
105 
106 bool CSSFontFace::setFamilies(CSSValue&amp; family)
107 {
108     if (!is&lt;CSSValueList&gt;(family))
109         return false;
110 
111     CSSValueList&amp; familyList = downcast&lt;CSSValueList&gt;(family);
112     if (!familyList.length())
113         return false;
114 
115     RefPtr&lt;CSSValueList&gt; oldFamilies = m_families;
</pre>
<hr />
<pre>
124 
125     return true;
126 }
127 
128 FontFace* CSSFontFace::existingWrapper()
129 {
130     return m_wrapper.get();
131 }
132 
133 static FontSelectionRange calculateWeightRange(CSSValue&amp; value)
134 {
135     if (value.isValueList()) {
136         auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
137         ASSERT(valueList.length() == 2);
138         if (valueList.length() != 2)
139             return { normalWeightValue(), normalWeightValue() };
140         ASSERT(valueList.item(0)-&gt;isPrimitiveValue());
141         ASSERT(valueList.item(1)-&gt;isPrimitiveValue());
142         auto&amp; value0 = downcast&lt;CSSPrimitiveValue&gt;(*valueList.item(0));
143         auto&amp; value1 = downcast&lt;CSSPrimitiveValue&gt;(*valueList.item(1));
<span class="line-modified">144         auto result0 = Style::BuilderConverter::convertFontWeightFromValue(value0);</span>
<span class="line-modified">145         auto result1 = Style::BuilderConverter::convertFontWeightFromValue(value1);</span>
146         return { result0, result1 };
147     }
148 
149     ASSERT(is&lt;CSSPrimitiveValue&gt;(value));
150     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
<span class="line-modified">151     FontSelectionValue result = Style::BuilderConverter::convertFontWeightFromValue(primitiveValue);</span>
152     return { result, result };
153 }
154 
155 void CSSFontFace::setWeight(CSSValue&amp; weight)
156 {
157     auto range = calculateWeightRange(weight);
158     if (m_fontSelectionCapabilities.weight == range)
159         return;
160 
161     setWeight(range);
162 
163     if (m_cssConnection)
164         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyFontWeight, &amp;weight);
165 
166     iterateClients(m_clients, [&amp;](Client&amp; client) {
167         client.fontPropertyChanged(*this);
168     });
169 }
170 
171 static FontSelectionRange calculateStretchRange(CSSValue&amp; value)
172 {
173     if (value.isValueList()) {
174         auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
175         ASSERT(valueList.length() == 2);
176         if (valueList.length() != 2)
177             return { normalStretchValue(), normalStretchValue() };
178         ASSERT(valueList.item(0)-&gt;isPrimitiveValue());
179         ASSERT(valueList.item(1)-&gt;isPrimitiveValue());
180         auto&amp; value0 = downcast&lt;CSSPrimitiveValue&gt;(*valueList.item(0));
181         auto&amp; value1 = downcast&lt;CSSPrimitiveValue&gt;(*valueList.item(1));
<span class="line-modified">182         auto result0 = Style::BuilderConverter::convertFontStretchFromValue(value0);</span>
<span class="line-modified">183         auto result1 = Style::BuilderConverter::convertFontStretchFromValue(value1);</span>
184         return { result0, result1 };
185     }
186 
187     ASSERT(is&lt;CSSPrimitiveValue&gt;(value));
188     const auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
<span class="line-modified">189     FontSelectionValue result = Style::BuilderConverter::convertFontStretchFromValue(primitiveValue);</span>
190     return { result, result };
191 }
192 
193 void CSSFontFace::setStretch(CSSValue&amp; style)
194 {
195     auto range = calculateStretchRange(style);
196     if (m_fontSelectionCapabilities.width == range)
197         return;
198 
199     setStretch(range);
200 
201     if (m_cssConnection)
202         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyFontStretch, &amp;style);
203 
204     iterateClients(m_clients, [&amp;](Client&amp; client) {
205         client.fontPropertyChanged(*this);
206     });
207 }
208 
209 static FontSelectionRange calculateItalicRange(CSSValue&amp; value)
210 {
211     if (value.isFontStyleValue()) {
<span class="line-modified">212         auto result = Style::BuilderConverter::convertFontStyleFromValue(value);</span>
213         return { result.valueOr(normalItalicValue()), result.valueOr(normalItalicValue()) };
214     }
215 
216     ASSERT(value.isFontStyleRangeValue());
217     auto&amp; rangeValue = downcast&lt;CSSFontStyleRangeValue&gt;(value);
218     ASSERT(rangeValue.fontStyleValue-&gt;isValueID());
219     auto valueID = rangeValue.fontStyleValue-&gt;valueID();
220     if (!rangeValue.obliqueValues) {
221         if (valueID == CSSValueNormal)
222             return { normalItalicValue(), normalItalicValue() };
223         ASSERT(valueID == CSSValueItalic || valueID == CSSValueOblique);
224         return { italicValue(), italicValue() };
225     }
226     ASSERT(valueID == CSSValueOblique);
227     auto length = rangeValue.obliqueValues-&gt;length();
228     if (length == 1) {
229         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*rangeValue.obliqueValues-&gt;item(0));
<span class="line-modified">230         FontSelectionValue result(primitiveValue.value&lt;float&gt;(CSSUnitType::CSS_DEG));</span>
231         return { result, result };
232     }
233     ASSERT(length == 2);
234     auto&amp; primitiveValue1 = downcast&lt;CSSPrimitiveValue&gt;(*rangeValue.obliqueValues-&gt;item(0));
235     auto&amp; primitiveValue2 = downcast&lt;CSSPrimitiveValue&gt;(*rangeValue.obliqueValues-&gt;item(1));
<span class="line-modified">236     FontSelectionValue result1(primitiveValue1.value&lt;float&gt;(CSSUnitType::CSS_DEG));</span>
<span class="line-modified">237     FontSelectionValue result2(primitiveValue2.value&lt;float&gt;(CSSUnitType::CSS_DEG));</span>
238     return { result1, result2 };
239 }
240 
241 void CSSFontFace::setStyle(CSSValue&amp; style)
242 {
243     auto range = calculateItalicRange(style);
244     if (m_fontSelectionCapabilities.slope == range)
245         return;
246 
247     setStyle(range);
248 
249     if (m_cssConnection)
250         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyFontStyle, &amp;style);
251 
252     iterateClients(m_clients, [&amp;](Client&amp; client) {
253         client.fontPropertyChanged(*this);
254     });
255 }
256 
257 bool CSSFontFace::setUnicodeRange(CSSValue&amp; unicodeRange)
</pre>
<hr />
<pre>
264     for (auto&amp; rangeValue : list) {
265         auto&amp; range = downcast&lt;CSSUnicodeRangeValue&gt;(rangeValue.get());
266         ranges.append({ range.from(), range.to() });
267     }
268 
269     if (ranges == m_ranges)
270         return true;
271 
272     m_ranges = WTFMove(ranges);
273 
274     if (m_cssConnection)
275         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyUnicodeRange, &amp;unicodeRange);
276 
277     iterateClients(m_clients, [&amp;](Client&amp; client) {
278         client.fontPropertyChanged(*this);
279     });
280 
281     return true;
282 }
283 













































































































































284 void CSSFontFace::setFeatureSettings(CSSValue&amp; featureSettings)
285 {
286     // Can only call this with a primitive value of normal, or a value list containing font feature values.
287     ASSERT(is&lt;CSSPrimitiveValue&gt;(featureSettings) || is&lt;CSSValueList&gt;(featureSettings));
288 
289     FontFeatureSettings settings;
290 
291     if (is&lt;CSSValueList&gt;(featureSettings)) {
292         auto&amp; list = downcast&lt;CSSValueList&gt;(featureSettings);
293         for (auto&amp; rangeValue : list) {
294             auto&amp; feature = downcast&lt;CSSFontFeatureValue&gt;(rangeValue.get());
295             settings.insert({ feature.tag(), feature.value() });
296         }
297     }
298 
299     if (m_featureSettings == settings)
300         return;
301 
302     m_featureSettings = WTFMove(settings);
303 
</pre>
<hr />
<pre>
329 bool CSSFontFace::rangesMatchCodePoint(UChar32 character) const
330 {
331     if (m_ranges.isEmpty())
332         return true;
333 
334     for (auto&amp; range : m_ranges) {
335         if (range.from &lt;= character &amp;&amp; character &lt;= range.to)
336             return true;
337     }
338     return false;
339 }
340 
341 void CSSFontFace::fontLoadEventOccurred()
342 {
343     // If the font is already in the cache, CSSFontFaceSource may report it&#39;s loaded before it is added here as a source.
344     // Let&#39;s not pump the state machine until we&#39;ve got all our sources. font() and load() are smart enough to act correctly
345     // when a source is failed or succeeded before we have asked it to load.
346     if (m_sourcesPopulated)
347         pump(ExternalResourceDownloadPolicy::Forbid);
348 
<span class="line-modified">349     if (m_fontSelector)</span>
<span class="line-modified">350         m_fontSelector-&gt;fontLoaded();</span>
351 
352     iterateClients(m_clients, [&amp;](Client&amp; client) {
353         client.fontLoaded(*this);
354     });
355 }
356 
357 void CSSFontFace::timeoutFired()
358 {
359     Ref&lt;CSSFontFace&gt; protectedThis(*this);
360 
361     switch (status()) {
362     case Status::Loading:
363         setStatus(Status::TimedOut);
364         break;
365     case Status::TimedOut:
366         // Cancelling the network request here could lead to a situation where a site&#39;s font never gets
367         // shown as the user navigates around to different pages on the site. This would occur if the
368         // download always takes longer than the timeout (even though the user may spend substantial time
369         // on each page). Therefore, we shouldn&#39;t cancel the network request here, but should use the
370         // loading infrastructure&#39;s timeout policies instead.
</pre>
<hr />
<pre>
432     auto wrapper = FontFace::create(*this);
433     m_wrapper = makeWeakPtr(wrapper.get());
434     initializeWrapper();
435     return wrapper;
436 }
437 
438 void CSSFontFace::setWrapper(FontFace&amp; newWrapper)
439 {
440     m_wrapper = makeWeakPtr(newWrapper);
441     initializeWrapper();
442 }
443 
444 void CSSFontFace::adoptSource(std::unique_ptr&lt;CSSFontFaceSource&gt;&amp;&amp; source)
445 {
446     m_sources.append(WTFMove(source));
447 
448     // We should never add sources in the middle of loading.
449     ASSERT(!m_sourcesPopulated);
450 }
451 
<span class="line-modified">452 Document* CSSFontFace::document() const</span>
453 {
<span class="line-modified">454     return m_fontSelector ? m_fontSelector-&gt;document() : nullptr;</span>


455 }
456 
<span class="line-modified">457 AllowUserInstalledFonts CSSFontFace::allowUserInstalledFonts() const</span>
458 {
459     if (m_fontSelector &amp;&amp; m_fontSelector-&gt;document())
<span class="line-modified">460         return m_fontSelector-&gt;document()-&gt;settings().shouldAllowUserInstalledFonts() ? AllowUserInstalledFonts::Yes : AllowUserInstalledFonts::No;</span>
<span class="line-modified">461     return AllowUserInstalledFonts::Yes;</span>
462 }
463 
464 static Settings::FontLoadTimingOverride fontLoadTimingOverride(CSSFontSelector* fontSelector)
465 {
466     auto overrideValue = Settings::FontLoadTimingOverride::None;
467     if (fontSelector &amp;&amp; fontSelector-&gt;document())
468         overrideValue = fontSelector-&gt;document()-&gt;settings().fontLoadTimingOverride();
469     return overrideValue;
470 }
471 
472 auto CSSFontFace::fontLoadTiming() const -&gt; FontLoadTiming
473 {
474     switch (fontLoadTimingOverride(m_fontSelector.get())) {
475     case Settings::FontLoadTimingOverride::None:
476         switch (m_loadingBehavior) {
477         case FontLoadingBehavior::Auto:
478         case FontLoadingBehavior::Block:
479             return { 3_s, Seconds::infinity() };
480         case FontLoadingBehavior::Swap:
481             return { 0_s, Seconds::infinity() };
</pre>
<hr />
<pre>
580     if (status() == Status::Failure)
581         return 0;
582 
583     size_t i;
584     for (i = 0; i &lt; m_sources.size(); ++i) {
585         auto&amp; source = m_sources[i];
586 
587         if (source-&gt;status() == CSSFontFaceSource::Status::Pending) {
588             ASSERT(m_status == Status::Pending || m_status == Status::Loading || m_status == Status::TimedOut);
589             // This is a little tricky. After calling CSSFontFace::font(Forbid), a font must never fail later in
590             // this turn of the runloop because the return value of CSSFontFace::font() shouldn&#39;t get nulled out
591             // from under an existing FontRanges object. Remote fonts are all downloaded asynchronously, so this
592             // isn&#39;t a problem for them because CSSFontFace::font() will always return the interstitial font.
593             // However, local fonts may synchronously fail when you call load() on them. Therefore, we have to call
594             // load() here in order to guarantee that, if the font synchronously fails, it happens now during the
595             // first call to CSSFontFace::font() and the FontRanges object sees a consistent view of the
596             // CSSFontFace. This means we eagerly create some internal font objects when they may not be needed,
597             // but it seems that this behavior is a requirement of the design of FontRanges. FIXME: Perhaps rethink
598             // this design.
599             if (policy == ExternalResourceDownloadPolicy::Allow || !source-&gt;requiresExternalResource()) {
<span class="line-modified">600                 if (policy == ExternalResourceDownloadPolicy::Allow &amp;&amp; m_status == Status::Pending)</span>
601                     setStatus(Status::Loading);
602                 source-&gt;load(m_fontSelector.get());
603             }
604         }
605 
606         switch (source-&gt;status()) {
607         case CSSFontFaceSource::Status::Pending:
608             ASSERT(policy == ExternalResourceDownloadPolicy::Forbid);
609             return i;
610         case CSSFontFaceSource::Status::Loading:
611             ASSERT(m_status == Status::Pending || m_status == Status::Loading || m_status == Status::TimedOut || m_status == Status::Failure);
<span class="line-modified">612             if (policy == ExternalResourceDownloadPolicy::Allow &amp;&amp; m_status == Status::Pending)</span>
613                 setStatus(Status::Loading);
614             return i;
615         case CSSFontFaceSource::Status::Success:
616             ASSERT(m_status == Status::Pending || m_status == Status::Loading || m_status == Status::TimedOut || m_status == Status::Success || m_status == Status::Failure);
617             if (m_status == Status::Pending)
618                 setStatus(Status::Loading);
619             if (m_status == Status::Loading || m_status == Status::TimedOut)
620                 setStatus(Status::Success);
621             return i;
622         case CSSFontFaceSource::Status::Failure:
<span class="line-modified">623             if (policy == ExternalResourceDownloadPolicy::Allow &amp;&amp; m_status == Status::Pending)</span>
624                 setStatus(Status::Loading);
625             break;
626         }
627     }
628     if (m_sources.isEmpty() &amp;&amp; m_status == Status::Pending)
629         setStatus(Status::Loading);
630     if (m_status == Status::Loading || m_status == Status::TimedOut)
631         setStatus(Status::Failure);
632     return m_sources.size();
633 }
634 
635 void CSSFontFace::load()
636 {
637     pump(ExternalResourceDownloadPolicy::Allow);
638 }
639 
640 static Font::Visibility visibility(CSSFontFace::Status status, CSSFontFace::FontLoadTiming timing)
641 {
642     switch (status) {
643     case CSSFontFace::Status::Pending:
</pre>
<hr />
<pre>
663     // return null from font(), which means we need to continue looping through the remainder
664     // of the sources to try to find a font to use. These subsequent tries should not affect
665     // our own state, though.
666     size_t startIndex = pump(policy);
667 
668     if (computeFailureState())
669         return nullptr;
670 
671     for (size_t i = startIndex; i &lt; m_sources.size(); ++i) {
672         auto&amp; source = m_sources[i];
673         if (source-&gt;status() == CSSFontFaceSource::Status::Pending &amp;&amp; (policy == ExternalResourceDownloadPolicy::Allow || !source-&gt;requiresExternalResource()))
674             source-&gt;load(m_fontSelector.get());
675 
676         switch (source-&gt;status()) {
677         case CSSFontFaceSource::Status::Pending:
678         case CSSFontFaceSource::Status::Loading: {
679             Font::Visibility visibility = WebCore::visibility(status(), fontLoadTiming());
680             return Font::create(FontCache::singleton().lastResortFallbackFont(fontDescription)-&gt;platformData(), Font::Origin::Local, Font::Interstitial::Yes, visibility);
681         }
682         case CSSFontFaceSource::Status::Success:
<span class="line-modified">683             if (auto result = source-&gt;font(fontDescription, syntheticBold, syntheticItalic, m_featureSettings, m_fontSelectionCapabilities)) {</span>
<span class="line-added">684                 auto* cachedFont = source-&gt;cachedFont();</span>
<span class="line-added">685                 result-&gt;setFontFaceData(cachedFont ? cachedFont-&gt;resourceBuffer() : nullptr);</span>
686                 return result;
<span class="line-added">687             }</span>
688             break;
689         case CSSFontFaceSource::Status::Failure:
690             break;
691         }
692     }
693 
694     return nullptr;
695 }
696 
697 bool CSSFontFace::purgeable() const
698 {
699     return cssConnection() &amp;&amp; m_mayBePurged;
700 }
701 
702 void CSSFontFace::updateStyleIfNeeded()
703 {
704     if (m_fontSelector &amp;&amp; m_fontSelector-&gt;document())
705         m_fontSelector-&gt;document()-&gt;updateStyleIfNeeded();
706 }
707 
708 #if ENABLE(SVG_FONTS)
709 bool CSSFontFace::hasSVGFontFaceSource() const
710 {
711     size_t size = m_sources.size();
712     for (size_t i = 0; i &lt; size; i++) {
713         if (m_sources[i]-&gt;isSVGFontFaceSource())
714             return true;
715     }
716     return false;
717 }
718 #endif
719 
<span class="line-added">720 void CSSFontFace::setErrorState()</span>
<span class="line-added">721 {</span>
<span class="line-added">722     switch (m_status) {</span>
<span class="line-added">723     case Status::Pending:</span>
<span class="line-added">724         setStatus(Status::Loading);</span>
<span class="line-added">725         break;</span>
<span class="line-added">726     case Status::Success:</span>
<span class="line-added">727         ASSERT_NOT_REACHED();</span>
<span class="line-added">728         break;</span>
<span class="line-added">729     case Status::Failure:</span>
<span class="line-added">730         return;</span>
<span class="line-added">731     default:</span>
<span class="line-added">732         break;</span>
<span class="line-added">733     }</span>
<span class="line-added">734 </span>
<span class="line-added">735     setStatus(Status::Failure);</span>
<span class="line-added">736 }</span>
<span class="line-added">737 </span>
738 }
</pre>
</td>
</tr>
</table>
<center><a href="CSSFilterImageValue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSFontFace.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
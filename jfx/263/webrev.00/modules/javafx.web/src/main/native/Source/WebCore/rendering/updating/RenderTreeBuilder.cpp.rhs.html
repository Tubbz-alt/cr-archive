<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTreeBuilder.h&quot;
 28 
 29 #include &quot;AXObjectCache.h&quot;
 30 #include &quot;Frame.h&quot;
 31 #include &quot;FrameSelection.h&quot;
 32 #include &quot;RenderButton.h&quot;
 33 #include &quot;RenderCounter.h&quot;
 34 #include &quot;RenderElement.h&quot;
 35 #include &quot;RenderFullScreen.h&quot;
 36 #include &quot;RenderGrid.h&quot;
 37 #include &quot;RenderLineBreak.h&quot;
 38 #include &quot;RenderMathMLFenced.h&quot;
 39 #include &quot;RenderMenuList.h&quot;
 40 #include &quot;RenderMultiColumnFlow.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 41 #include &quot;RenderMultiColumnSpannerPlaceholder.h&quot;</span>
 42 #include &quot;RenderRuby.h&quot;
 43 #include &quot;RenderRubyBase.h&quot;
 44 #include &quot;RenderRubyRun.h&quot;
 45 #include &quot;RenderSVGContainer.h&quot;
 46 #include &quot;RenderSVGInline.h&quot;
 47 #include &quot;RenderSVGRoot.h&quot;
 48 #include &quot;RenderSVGText.h&quot;
 49 #include &quot;RenderTable.h&quot;
 50 #include &quot;RenderTableRow.h&quot;
 51 #include &quot;RenderTableSection.h&quot;
 52 #include &quot;RenderText.h&quot;
 53 #include &quot;RenderTextFragment.h&quot;
 54 #include &quot;RenderTreeBuilderBlock.h&quot;
 55 #include &quot;RenderTreeBuilderBlockFlow.h&quot;
 56 #include &quot;RenderTreeBuilderContinuation.h&quot;
 57 #include &quot;RenderTreeBuilderFirstLetter.h&quot;
 58 #include &quot;RenderTreeBuilderFormControls.h&quot;
 59 #include &quot;RenderTreeBuilderFullScreen.h&quot;
 60 #include &quot;RenderTreeBuilderInline.h&quot;
 61 #include &quot;RenderTreeBuilderList.h&quot;
 62 #include &quot;RenderTreeBuilderMathML.h&quot;
 63 #include &quot;RenderTreeBuilderMultiColumn.h&quot;
 64 #include &quot;RenderTreeBuilderRuby.h&quot;
 65 #include &quot;RenderTreeBuilderSVG.h&quot;
 66 #include &quot;RenderTreeBuilderTable.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 67 #include &quot;RenderView.h&quot;</span>
<span class="line-added"> 68 </span>
<span class="line-added"> 69 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added"> 70 #include &quot;FrameView.h&quot;</span>
<span class="line-added"> 71 #include &quot;FrameViewLayoutContext.h&quot;</span>
<span class="line-added"> 72 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
<span class="line-added"> 73 #endif</span>
 74 
 75 namespace WebCore {
 76 
 77 RenderTreeBuilder* RenderTreeBuilder::s_current;
 78 
 79 static void markBoxForRelayoutAfterSplit(RenderBox&amp; box)
 80 {
 81     // FIXME: The table code should handle that automatically. If not,
 82     // we should fix it and remove the table part checks.
 83     if (is&lt;RenderTable&gt;(box)) {
 84         // Because we may have added some sections with already computed column structures, we need to
 85         // sync the table structure with them now. This avoids crashes when adding new cells to the table.
 86         downcast&lt;RenderTable&gt;(box).forceSectionsRecalc();
 87     } else if (is&lt;RenderTableSection&gt;(box))
 88         downcast&lt;RenderTableSection&gt;(box).setNeedsCellRecalc();
 89 
 90     box.setNeedsLayoutAndPrefWidthsRecalc();
 91 }
 92 
 93 static void getInlineRun(RenderObject* start, RenderObject* boundary, RenderObject*&amp; inlineRunStart, RenderObject*&amp; inlineRunEnd)
 94 {
 95     // Beginning at |start| we find the largest contiguous run of inlines that
 96     // we can. We denote the run with start and end points, |inlineRunStart|
 97     // and |inlineRunEnd|. Note that these two values may be the same if
 98     // we encounter only one inline.
 99     //
100     // We skip any non-inlines we encounter as long as we haven&#39;t found any
101     // inlines yet.
102     //
103     // |boundary| indicates a non-inclusive boundary point. Regardless of whether |boundary|
104     // is inline or not, we will not include it in a run with inlines before it. It&#39;s as though we encountered
105     // a non-inline.
106 
107     // Start by skipping as many non-inlines as we can.
108     auto* curr = start;
109     bool sawInline;
110     do {
111         while (curr &amp;&amp; !(curr-&gt;isInline() || curr-&gt;isFloatingOrOutOfFlowPositioned()))
112             curr = curr-&gt;nextSibling();
113 
114         inlineRunStart = inlineRunEnd = curr;
115 
116         if (!curr)
117             return; // No more inline children to be found.
118 
119         sawInline = curr-&gt;isInline();
120 
121         curr = curr-&gt;nextSibling();
122         while (curr &amp;&amp; (curr-&gt;isInline() || curr-&gt;isFloatingOrOutOfFlowPositioned()) &amp;&amp; (curr != boundary)) {
123             inlineRunEnd = curr;
124             if (curr-&gt;isInline())
125                 sawInline = true;
126             curr = curr-&gt;nextSibling();
127         }
128     } while (!sawInline);
129 }
130 
131 RenderTreeBuilder::RenderTreeBuilder(RenderView&amp; view)
132     : m_view(view)
133     , m_firstLetterBuilder(makeUnique&lt;FirstLetter&gt;(*this))
134     , m_listBuilder(makeUnique&lt;List&gt;(*this))
135     , m_multiColumnBuilder(makeUnique&lt;MultiColumn&gt;(*this))
136     , m_tableBuilder(makeUnique&lt;Table&gt;(*this))
137     , m_rubyBuilder(makeUnique&lt;Ruby&gt;(*this))
138     , m_formControlsBuilder(makeUnique&lt;FormControls&gt;(*this))
139     , m_blockBuilder(makeUnique&lt;Block&gt;(*this))
140     , m_blockFlowBuilder(makeUnique&lt;BlockFlow&gt;(*this))
141     , m_inlineBuilder(makeUnique&lt;Inline&gt;(*this))
142     , m_svgBuilder(makeUnique&lt;SVG&gt;(*this))
143 #if ENABLE(MATHML)
144     , m_mathMLBuilder(makeUnique&lt;MathML&gt;(*this))
145 #endif
146     , m_continuationBuilder(makeUnique&lt;Continuation&gt;(*this))
147 #if ENABLE(FULLSCREEN_API)
148     , m_fullScreenBuilder(makeUnique&lt;FullScreen&gt;(*this))
149 #endif
150 {
151     RELEASE_ASSERT(!s_current || &amp;m_view != &amp;s_current-&gt;m_view);
152     m_previous = s_current;
153     s_current = this;
154 }
155 
156 RenderTreeBuilder::~RenderTreeBuilder()
157 {
158     s_current = m_previous;
159 }
160 
161 void RenderTreeBuilder::destroy(RenderObject&amp; renderer)
162 {
163     ASSERT(renderer.parent());
164     auto toDestroy = detach(*renderer.parent(), renderer);
165 
166 #if ENABLE(FULLSCREEN_API)
167     if (is&lt;RenderFullScreen&gt;(renderer))
168         fullScreenBuilder().cleanupOnDestroy(downcast&lt;RenderFullScreen&gt;(renderer));
169 #endif
170 
171     if (is&lt;RenderTextFragment&gt;(renderer))
172         firstLetterBuilder().cleanupOnDestroy(downcast&lt;RenderTextFragment&gt;(renderer));
173 
174     if (is&lt;RenderBoxModelObject&gt;(renderer))
175         continuationBuilder().cleanupOnDestroy(downcast&lt;RenderBoxModelObject&gt;(renderer));
176 
177     // We need to detach the subtree first so that the descendants don&#39;t have
178     // access to previous/next sublings at detach().
179     // FIXME: webkit.org/b/182909.
180     if (!is&lt;RenderElement&gt;(toDestroy.get()))
181         return;
182 
183     auto&amp; childToDestroy = downcast&lt;RenderElement&gt;(*toDestroy.get());
184     while (childToDestroy.firstChild()) {
185         auto&amp; firstChild = *childToDestroy.firstChild();
186         if (auto* node = firstChild.node())
187             node-&gt;setRenderer(nullptr);
188         destroy(firstChild);
189     }
190 }
191 
192 void RenderTreeBuilder::attach(RenderElement&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
193 {
194     auto insertRecursiveIfNeeded = [&amp;](RenderElement&amp; parentCandidate) {
195         if (&amp;parent == &amp;parentCandidate) {
<a name="3" id="anc3"></a><span class="line-added">196             // Parents inside multicols can&#39;t call internal attach directly.</span>
<span class="line-added">197             if (is&lt;RenderBlockFlow&gt;(parent) &amp;&amp; downcast&lt;RenderBlockFlow&gt;(parent).multiColumnFlow()) {</span>
<span class="line-added">198                 blockFlowBuilder().attach(downcast&lt;RenderBlockFlow&gt;(parent), WTFMove(child), beforeChild);</span>
<span class="line-added">199                 return;</span>
<span class="line-added">200             }</span>
201             attachToRenderElement(parent, WTFMove(child), beforeChild);
202             return;
203         }
204         attach(parentCandidate, WTFMove(child), beforeChild);
205     };
206 
207     ASSERT(&amp;parent.view() == &amp;m_view);
208 
209     if (is&lt;RenderText&gt;(beforeChild)) {
210         if (auto* wrapperInline = downcast&lt;RenderText&gt;(*beforeChild).inlineWrapperForDisplayContents())
211             beforeChild = wrapperInline;
<a name="4" id="anc4"></a><span class="line-added">212     } else if (is&lt;RenderBox&gt;(beforeChild)) {</span>
<span class="line-added">213         // Adjust the beforeChild if it happens to be a spanner and the its actual location is inside the fragmented flow.</span>
<span class="line-added">214         auto&amp; beforeChildBox = downcast&lt;RenderBox&gt;(*beforeChild);</span>
<span class="line-added">215         if (auto* enclosingFragmentedFlow = parent.enclosingFragmentedFlow()) {</span>
<span class="line-added">216             auto columnSpannerPlaceholderForBeforeChild = [&amp;]() -&gt; RenderMultiColumnSpannerPlaceholder* {</span>
<span class="line-added">217                 if (!is&lt;RenderMultiColumnFlow&gt;(enclosingFragmentedFlow))</span>
<span class="line-added">218                     return nullptr;</span>
<span class="line-added">219                 auto&amp; multiColumnFlow = downcast&lt;RenderMultiColumnFlow&gt;(*enclosingFragmentedFlow);</span>
<span class="line-added">220                 return multiColumnFlow.findColumnSpannerPlaceholder(&amp;beforeChildBox);</span>
<span class="line-added">221             };</span>
<span class="line-added">222 </span>
<span class="line-added">223             if (auto* spannerPlaceholder = columnSpannerPlaceholderForBeforeChild())</span>
<span class="line-added">224                 beforeChild = spannerPlaceholder;</span>
<span class="line-added">225         }</span>
226     }
227 
228     if (is&lt;RenderTableRow&gt;(parent)) {
229         auto&amp; parentCandidate = tableBuilder().findOrCreateParentForChild(downcast&lt;RenderTableRow&gt;(parent), *child, beforeChild);
230         if (&amp;parentCandidate == &amp;parent) {
231             tableBuilder().attach(downcast&lt;RenderTableRow&gt;(parentCandidate), WTFMove(child), beforeChild);
232             return;
233         }
234         insertRecursiveIfNeeded(parentCandidate);
235         return;
236     }
237 
238     if (is&lt;RenderTableSection&gt;(parent)) {
239         auto&amp; parentCandidate = tableBuilder().findOrCreateParentForChild(downcast&lt;RenderTableSection&gt;(parent), *child, beforeChild);
240         if (&amp;parent == &amp;parentCandidate) {
241             tableBuilder().attach(downcast&lt;RenderTableSection&gt;(parent), WTFMove(child), beforeChild);
242             return;
243         }
244         insertRecursiveIfNeeded(parentCandidate);
245         return;
246     }
247 
248     if (is&lt;RenderTable&gt;(parent)) {
249         auto&amp; parentCandidate = tableBuilder().findOrCreateParentForChild(downcast&lt;RenderTable&gt;(parent), *child, beforeChild);
250         if (&amp;parentCandidate == &amp;parent) {
251             tableBuilder().attach(downcast&lt;RenderTable&gt;(parentCandidate), WTFMove(child), beforeChild);
252             return;
253         }
254         insertRecursiveIfNeeded(parentCandidate);
255         return;
256     }
257 
258     if (is&lt;RenderRubyAsBlock&gt;(parent)) {
259         insertRecursiveIfNeeded(rubyBuilder().findOrCreateParentForChild(downcast&lt;RenderRubyAsBlock&gt;(parent), *child, beforeChild));
260         return;
261     }
262 
263     if (is&lt;RenderRubyAsInline&gt;(parent)) {
264         insertRecursiveIfNeeded(rubyBuilder().findOrCreateParentForChild(downcast&lt;RenderRubyAsInline&gt;(parent), *child, beforeChild));
265         return;
266     }
267 
268     if (is&lt;RenderRubyRun&gt;(parent)) {
269         rubyBuilder().attach(downcast&lt;RenderRubyRun&gt;(parent), WTFMove(child), beforeChild);
270         return;
271     }
272 
273     if (is&lt;RenderButton&gt;(parent)) {
274         formControlsBuilder().attach(downcast&lt;RenderButton&gt;(parent), WTFMove(child), beforeChild);
275         return;
276     }
277 
278     if (is&lt;RenderMenuList&gt;(parent)) {
279         formControlsBuilder().attach(downcast&lt;RenderMenuList&gt;(parent), WTFMove(child), beforeChild);
280         return;
281     }
282 
283     if (is&lt;RenderSVGContainer&gt;(parent)) {
284         svgBuilder().attach(downcast&lt;RenderSVGContainer&gt;(parent), WTFMove(child), beforeChild);
285         return;
286     }
287 
288     if (is&lt;RenderSVGInline&gt;(parent)) {
289         svgBuilder().attach(downcast&lt;RenderSVGInline&gt;(parent), WTFMove(child), beforeChild);
290         return;
291     }
292 
293     if (is&lt;RenderSVGRoot&gt;(parent)) {
294         svgBuilder().attach(downcast&lt;RenderSVGRoot&gt;(parent), WTFMove(child), beforeChild);
295         return;
296     }
297 
298     if (is&lt;RenderSVGText&gt;(parent)) {
299         svgBuilder().attach(downcast&lt;RenderSVGText&gt;(parent), WTFMove(child), beforeChild);
300         return;
301     }
302 
303 #if ENABLE(MATHML)
304     if (is&lt;RenderMathMLFenced&gt;(parent)) {
305         mathMLBuilder().attach(downcast&lt;RenderMathMLFenced&gt;(parent), WTFMove(child), beforeChild);
306         return;
307     }
308 #endif
309 
310     if (is&lt;RenderGrid&gt;(parent)) {
311         attachToRenderGrid(downcast&lt;RenderGrid&gt;(parent), WTFMove(child), beforeChild);
312         return;
313     }
314 
315     if (is&lt;RenderBlockFlow&gt;(parent)) {
316         blockFlowBuilder().attach(downcast&lt;RenderBlockFlow&gt;(parent), WTFMove(child), beforeChild);
317         return;
318     }
319 
320     if (is&lt;RenderBlock&gt;(parent)) {
321         blockBuilder().attach(downcast&lt;RenderBlock&gt;(parent), WTFMove(child), beforeChild);
322         return;
323     }
324 
325     if (is&lt;RenderInline&gt;(parent)) {
326         inlineBuilder().attach(downcast&lt;RenderInline&gt;(parent), WTFMove(child), beforeChild);
327         return;
328     }
329 
330     attachToRenderElement(parent, WTFMove(child), beforeChild);
331 }
332 
333 void RenderTreeBuilder::attachIgnoringContinuation(RenderElement&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
334 {
335     if (is&lt;RenderInline&gt;(parent)) {
336         inlineBuilder().attachIgnoringContinuation(downcast&lt;RenderInline&gt;(parent), WTFMove(child), beforeChild);
337         return;
338     }
339 
340     if (is&lt;RenderBlock&gt;(parent)) {
341         blockBuilder().attachIgnoringContinuation(downcast&lt;RenderBlock&gt;(parent), WTFMove(child), beforeChild);
342         return;
343     }
344 
345     attach(parent, WTFMove(child), beforeChild);
346 }
347 
348 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::detach(RenderElement&amp; parent, RenderObject&amp; child, CanCollapseAnonymousBlock canCollapseAnonymousBlock)
349 {
350     if (is&lt;RenderRubyAsInline&gt;(parent))
351         return rubyBuilder().detach(downcast&lt;RenderRubyAsInline&gt;(parent), child);
352 
353     if (is&lt;RenderRubyAsBlock&gt;(parent))
354         return rubyBuilder().detach(downcast&lt;RenderRubyAsBlock&gt;(parent), child);
355 
356     if (is&lt;RenderRubyRun&gt;(parent))
357         return rubyBuilder().detach(downcast&lt;RenderRubyRun&gt;(parent), child);
358 
359     if (is&lt;RenderMenuList&gt;(parent))
360         return formControlsBuilder().detach(downcast&lt;RenderMenuList&gt;(parent), child);
361 
362     if (is&lt;RenderButton&gt;(parent))
363         return formControlsBuilder().detach(downcast&lt;RenderButton&gt;(parent), child);
364 
365     if (is&lt;RenderGrid&gt;(parent))
366         return detachFromRenderGrid(downcast&lt;RenderGrid&gt;(parent), child);
367 
368     if (is&lt;RenderSVGText&gt;(parent))
369         return svgBuilder().detach(downcast&lt;RenderSVGText&gt;(parent), child);
370 
371     if (is&lt;RenderSVGInline&gt;(parent))
372         return svgBuilder().detach(downcast&lt;RenderSVGInline&gt;(parent), child);
373 
374     if (is&lt;RenderSVGContainer&gt;(parent))
375         return svgBuilder().detach(downcast&lt;RenderSVGContainer&gt;(parent), child);
376 
377     if (is&lt;RenderSVGRoot&gt;(parent))
378         return svgBuilder().detach(downcast&lt;RenderSVGRoot&gt;(parent), child);
379 
380     if (is&lt;RenderBlockFlow&gt;(parent))
381         return blockBuilder().detach(downcast&lt;RenderBlockFlow&gt;(parent), child, canCollapseAnonymousBlock);
382 
383     if (is&lt;RenderBlock&gt;(parent))
384         return blockBuilder().detach(downcast&lt;RenderBlock&gt;(parent), child, canCollapseAnonymousBlock);
385 
386     return detachFromRenderElement(parent, child);
387 }
388 
389 void RenderTreeBuilder::attach(RenderTreePosition&amp; position, RenderPtr&lt;RenderObject&gt; child)
390 {
391     attach(position.parent(), WTFMove(child), position.nextSibling());
392 }
393 
394 #if ENABLE(FULLSCREEN_API)
395 void RenderTreeBuilder::createPlaceholderForFullScreen(RenderFullScreen&amp; renderer, std::unique_ptr&lt;RenderStyle&gt; style, const LayoutRect&amp; frameRect)
396 {
397     fullScreenBuilder().createPlaceholder(renderer, WTFMove(style), frameRect);
398 }
399 #endif
400 
401 void RenderTreeBuilder::attachToRenderElement(RenderElement&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
402 {
403     if (tableBuilder().childRequiresTable(parent, *child)) {
404         RenderTable* table;
405         RenderObject* afterChild = beforeChild ? beforeChild-&gt;previousSibling() : parent.lastChild();
406         if (afterChild &amp;&amp; afterChild-&gt;isAnonymous() &amp;&amp; is&lt;RenderTable&gt;(*afterChild) &amp;&amp; !afterChild-&gt;isBeforeContent())
407             table = downcast&lt;RenderTable&gt;(afterChild);
408         else {
409             auto newTable = RenderTable::createAnonymousWithParentRenderer(parent);
410             table = newTable.get();
411             attach(parent, WTFMove(newTable), beforeChild);
412         }
413 
414         attach(*table, WTFMove(child));
415         return;
416     }
417     auto&amp; newChild = *child.get();
418     attachToRenderElementInternal(parent, WTFMove(child), beforeChild);
419     parent.didAttachChild(newChild, beforeChild);
420 }
421 
422 void RenderTreeBuilder::attachToRenderElementInternal(RenderElement&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
423 {
424     RELEASE_ASSERT_WITH_MESSAGE(!parent.view().frameView().layoutContext().layoutState(), &quot;Layout must not mutate render tree&quot;);
425     ASSERT(parent.canHaveChildren() || parent.canHaveGeneratedChildren());
426     ASSERT(!child-&gt;parent());
427     ASSERT(!parent.isRenderBlockFlow() || (!child-&gt;isTableSection() &amp;&amp; !child-&gt;isTableRow() &amp;&amp; !child-&gt;isTableCell()));
428 
429     while (beforeChild &amp;&amp; beforeChild-&gt;parent() &amp;&amp; beforeChild-&gt;parent() != &amp;parent)
430         beforeChild = beforeChild-&gt;parent();
431 
432     ASSERT(!beforeChild || beforeChild-&gt;parent() == &amp;parent);
433     ASSERT(!is&lt;RenderText&gt;(beforeChild) || !downcast&lt;RenderText&gt;(*beforeChild).inlineWrapperForDisplayContents());
434 
435     // Take the ownership.
436     auto* newChild = parent.attachRendererInternal(WTFMove(child), beforeChild);
437 
438     newChild-&gt;initializeFragmentedFlowStateOnInsertion();
439     if (!parent.renderTreeBeingDestroyed()) {
440         newChild-&gt;insertedIntoTree();
441 
442         auto* fragmentedFlow = newChild-&gt;enclosingFragmentedFlow();
443         if (is&lt;RenderMultiColumnFlow&gt;(fragmentedFlow))
444             multiColumnBuilder().multiColumnDescendantInserted(downcast&lt;RenderMultiColumnFlow&gt;(*fragmentedFlow), *newChild);
445 
446         if (is&lt;RenderElement&gt;(*newChild))
447             RenderCounter::rendererSubtreeAttached(downcast&lt;RenderElement&gt;(*newChild));
448     }
449 
450     newChild-&gt;setNeedsLayoutAndPrefWidthsRecalc();
451     parent.setPreferredLogicalWidthsDirty(true);
452     if (!parent.normalChildNeedsLayout())
453         parent.setChildNeedsLayout(); // We may supply the static position for an absolute positioned child.
454 
455     if (AXObjectCache* cache = parent.document().axObjectCache())
456         cache-&gt;childrenChanged(&amp;parent, newChild);
457     if (is&lt;RenderBlockFlow&gt;(parent))
458         downcast&lt;RenderBlockFlow&gt;(parent).invalidateLineLayoutPath();
459     if (parent.hasOutlineAutoAncestor() || parent.outlineStyleForRepaint().outlineStyleIsAuto() == OutlineIsAuto::On)
460         newChild-&gt;setHasOutlineAutoAncestor();
<a name="5" id="anc5"></a><span class="line-added">461 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">462     if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextEnabled()) {</span>
<span class="line-added">463         if (parent.document().view())</span>
<span class="line-added">464             parent.document().view()-&gt;layoutContext().invalidateLayoutTreeContent();</span>
<span class="line-added">465 </span>
<span class="line-added">466     }</span>
<span class="line-added">467 #endif</span>
468 }
469 
470 void RenderTreeBuilder::move(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, RenderObject&amp; child, RenderObject* beforeChild, NormalizeAfterInsertion normalizeAfterInsertion)
471 {
472     // We assume that callers have cleared their positioned objects list for child moves so the
473     // positioned renderer maps don&#39;t become stale. It would be too slow to do the map lookup on each call.
474     ASSERT(normalizeAfterInsertion == NormalizeAfterInsertion::No || !is&lt;RenderBlock&gt;(from) || !downcast&lt;RenderBlock&gt;(from).hasPositionedObjects());
475 
476     ASSERT(&amp;from == child.parent());
477     ASSERT(!beforeChild || &amp;to == beforeChild-&gt;parent());
478     if (normalizeAfterInsertion == NormalizeAfterInsertion::Yes &amp;&amp; (to.isRenderBlock() || to.isRenderInline())) {
479         // Takes care of adding the new child correctly if toBlock and fromBlock
480         // have different kind of children (block vs inline).
481         auto childToMove = detachFromRenderElement(from, child);
482         attach(to, WTFMove(childToMove), beforeChild);
483     } else {
484         auto childToMove = detachFromRenderElement(from, child);
485         attachToRenderElementInternal(to, WTFMove(childToMove), beforeChild);
486     }
487 }
488 
489 void RenderTreeBuilder::move(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, RenderObject&amp; child, NormalizeAfterInsertion normalizeAfterInsertion)
490 {
491     move(from, to, child, nullptr, normalizeAfterInsertion);
492 }
493 
494 void RenderTreeBuilder::moveAllChildren(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, NormalizeAfterInsertion normalizeAfterInsertion)
495 {
496     moveAllChildren(from, to, nullptr, normalizeAfterInsertion);
497 }
498 
499 void RenderTreeBuilder::moveAllChildren(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, RenderObject* beforeChild, NormalizeAfterInsertion normalizeAfterInsertion)
500 {
501     moveChildren(from, to, from.firstChild(), nullptr, beforeChild, normalizeAfterInsertion);
502 }
503 
504 void RenderTreeBuilder::moveChildren(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, RenderObject* startChild, RenderObject* endChild, NormalizeAfterInsertion normalizeAfterInsertion)
505 {
506     moveChildren(from, to, startChild, endChild, nullptr, normalizeAfterInsertion);
507 }
508 
509 void RenderTreeBuilder::moveChildren(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, RenderObject* startChild, RenderObject* endChild, RenderObject* beforeChild, NormalizeAfterInsertion normalizeAfterInsertion)
510 {
511     // This condition is rarely hit since this function is usually called on
512     // anonymous blocks which can no longer carry positioned objects (see r120761)
513     // or when fullRemoveInsert is false.
514     if (normalizeAfterInsertion == NormalizeAfterInsertion::Yes &amp;&amp; is&lt;RenderBlock&gt;(from)) {
515         downcast&lt;RenderBlock&gt;(from).removePositionedObjects(nullptr);
516         if (is&lt;RenderBlockFlow&gt;(from))
517             downcast&lt;RenderBlockFlow&gt;(from).removeFloatingObjects();
518     }
519 
520     ASSERT(!beforeChild || &amp;to == beforeChild-&gt;parent());
521     for (RenderObject* child = startChild; child &amp;&amp; child != endChild; ) {
522         // Save our next sibling as moveChildTo will clear it.
523         RenderObject* nextSibling = child-&gt;nextSibling();
524 
525         // FIXME: This logic here fails to detect the first letter in certain cases
526         // and skips a valid sibling renderer (see webkit.org/b/163737).
527         // Check to make sure we&#39;re not saving the firstLetter as the nextSibling.
528         // When the |child| object will be moved, its firstLetter will be recreated,
529         // so saving it now in nextSibling would leave us with a stale object.
530         if (is&lt;RenderTextFragment&gt;(*child) &amp;&amp; is&lt;RenderText&gt;(nextSibling)) {
531             RenderObject* firstLetterObj = nullptr;
532             if (RenderBlock* block = downcast&lt;RenderTextFragment&gt;(*child).blockForAccompanyingFirstLetter()) {
533                 RenderElement* firstLetterContainer = nullptr;
534                 block-&gt;getFirstLetter(firstLetterObj, firstLetterContainer, child);
535             }
536 
537             // This is the first letter, skip it.
538             if (firstLetterObj == nextSibling)
539                 nextSibling = nextSibling-&gt;nextSibling();
540         }
541 
542         move(from, to, *child, beforeChild, normalizeAfterInsertion);
543         child = nextSibling;
544     }
545 }
546 
547 void RenderTreeBuilder::moveAllChildrenIncludingFloats(RenderBlock&amp; from, RenderBlock&amp; to, RenderTreeBuilder::NormalizeAfterInsertion normalizeAfterInsertion)
548 {
549     if (is&lt;RenderBlockFlow&gt;(from)) {
550         blockFlowBuilder().moveAllChildrenIncludingFloats(downcast&lt;RenderBlockFlow&gt;(from), to, normalizeAfterInsertion);
551         return;
552     }
553     moveAllChildren(from, to, normalizeAfterInsertion);
554 }
555 
556 void RenderTreeBuilder::normalizeTreeAfterStyleChange(RenderElement&amp; renderer, RenderStyle&amp; oldStyle)
557 {
558     if (!renderer.parent())
559         return;
560 
561     auto&amp; parent = *renderer.parent();
562 
563     bool wasFloating = oldStyle.isFloating();
564     bool wasOufOfFlowPositioned = oldStyle.hasOutOfFlowPosition();
565     bool isFloating = renderer.style().isFloating();
566     bool isOutOfFlowPositioned = renderer.style().hasOutOfFlowPosition();
567     bool startsAffectingParent = false;
568     bool noLongerAffectsParent = false;
569 
570     if (is&lt;RenderBlock&gt;(parent))
571         noLongerAffectsParent = (!wasFloating &amp;&amp; isFloating) || (!wasOufOfFlowPositioned &amp;&amp; isOutOfFlowPositioned);
572 
573     if (is&lt;RenderBlockFlow&gt;(parent) || is&lt;RenderInline&gt;(parent)) {
574         startsAffectingParent = (wasFloating || wasOufOfFlowPositioned) &amp;&amp; !isFloating &amp;&amp; !isOutOfFlowPositioned;
575         ASSERT(!startsAffectingParent || !noLongerAffectsParent);
576     }
577 
578     if (startsAffectingParent) {
579         // We have gone from not affecting the inline status of the parent flow to suddenly
580         // having an impact. See if there is a mismatch between the parent flow&#39;s
581         // childrenInline() state and our state.
582         // FIXME(186894): startsAffectingParent has clearly nothing to do with resetting the inline state.
583         if (!is&lt;RenderSVGInline&gt;(renderer))
584             renderer.setInline(renderer.style().isDisplayInlineType());
585         if (renderer.isInline() != renderer.parent()-&gt;childrenInline())
586             childFlowStateChangesAndAffectsParentBlock(renderer);
587         return;
588     }
589 
590     if (noLongerAffectsParent) {
591         childFlowStateChangesAndNoLongerAffectsParentBlock(renderer);
592 
593         if (is&lt;RenderBlockFlow&gt;(renderer)) {
594             // Fresh floats need to be reparented if they actually belong to the previous anonymous block.
595             // It copies the logic of RenderBlock::addChildIgnoringContinuation
596             if (isFloating &amp;&amp; renderer.previousSibling() &amp;&amp; renderer.previousSibling()-&gt;isAnonymousBlock())
597                 move(downcast&lt;RenderBoxModelObject&gt;(parent), downcast&lt;RenderBoxModelObject&gt;(*renderer.previousSibling()), renderer, RenderTreeBuilder::NormalizeAfterInsertion::No);
598         }
599     }
600 }
601 
602 void RenderTreeBuilder::makeChildrenNonInline(RenderBlock&amp; parent, RenderObject* insertionPoint)
603 {
604     // makeChildrenNonInline takes a block whose children are *all* inline and it
605     // makes sure that inline children are coalesced under anonymous
606     // blocks. If |insertionPoint| is defined, then it represents the insertion point for
607     // the new block child that is causing us to have to wrap all the inlines. This
608     // means that we cannot coalesce inlines before |insertionPoint| with inlines following
609     // |insertionPoint|, because the new child is going to be inserted in between the inlines,
610     // splitting them.
611     ASSERT(parent.isInlineBlockOrInlineTable() || !parent.isInline());
612     ASSERT(!insertionPoint || insertionPoint-&gt;parent() == &amp;parent);
613 
614     parent.setChildrenInline(false);
615 
616     auto* child = parent.firstChild();
617     if (!child)
618         return;
619 
620     parent.deleteLines();
621 
622     while (child) {
623         RenderObject* inlineRunStart = nullptr;
624         RenderObject* inlineRunEnd = nullptr;
625         getInlineRun(child, insertionPoint, inlineRunStart, inlineRunEnd);
626 
627         if (!inlineRunStart)
628             break;
629 
630         child = inlineRunEnd-&gt;nextSibling();
631 
632         auto newBlock = parent.createAnonymousBlock();
633         auto&amp; block = *newBlock;
634         attachToRenderElementInternal(parent, WTFMove(newBlock), inlineRunStart);
635         moveChildren(parent, block, inlineRunStart, child, RenderTreeBuilder::NormalizeAfterInsertion::No);
636     }
637 #ifndef NDEBUG
638     for (RenderObject* c = parent.firstChild(); c; c = c-&gt;nextSibling())
639         ASSERT(!c-&gt;isInline());
640 #endif
641     parent.repaint();
642 }
643 
644 RenderObject* RenderTreeBuilder::splitAnonymousBoxesAroundChild(RenderBox&amp; parent, RenderObject&amp; originalBeforeChild)
645 {
646     // Adjust beforeChild if it is a column spanner and has been moved out of its original position.
647     auto* beforeChild = RenderTreeBuilder::MultiColumn::adjustBeforeChildForMultiColumnSpannerIfNeeded(originalBeforeChild);
648     bool didSplitParentAnonymousBoxes = false;
649 
650     while (beforeChild-&gt;parent() != &amp;parent) {
651         auto&amp; boxToSplit = downcast&lt;RenderBox&gt;(*beforeChild-&gt;parent());
652         if (boxToSplit.firstChild() != beforeChild &amp;&amp; boxToSplit.isAnonymous()) {
653             didSplitParentAnonymousBoxes = true;
654 
655             // We have to split the parent box into two boxes and move children
656             // from |beforeChild| to end into the new post box.
657             auto newPostBox = boxToSplit.createAnonymousBoxWithSameTypeAs(parent);
658             auto&amp; postBox = *newPostBox;
659             postBox.setChildrenInline(boxToSplit.childrenInline());
660             RenderBox* parentBox = downcast&lt;RenderBox&gt;(boxToSplit.parent());
661             // We need to invalidate the |parentBox| before inserting the new node
662             // so that the table repainting logic knows the structure is dirty.
663             // See for example RenderTableCell:clippedOverflowRectForRepaint.
664             markBoxForRelayoutAfterSplit(*parentBox);
665             attachToRenderElementInternal(*parentBox, WTFMove(newPostBox), boxToSplit.nextSibling());
666             moveChildren(boxToSplit, postBox, beforeChild, nullptr, RenderTreeBuilder::NormalizeAfterInsertion::Yes);
667 
668             markBoxForRelayoutAfterSplit(boxToSplit);
669             markBoxForRelayoutAfterSplit(postBox);
670 
671             beforeChild = &amp;postBox;
672         } else
673             beforeChild = &amp;boxToSplit;
674     }
675 
676     if (didSplitParentAnonymousBoxes)
677         markBoxForRelayoutAfterSplit(parent);
678 
679     ASSERT(beforeChild-&gt;parent() == &amp;parent);
680     return beforeChild;
681 }
682 
683 void RenderTreeBuilder::childFlowStateChangesAndAffectsParentBlock(RenderElement&amp; child)
684 {
685     auto* parent = child.parent();
686     if (!child.isInline()) {
687         if (is&lt;RenderBlock&gt;(parent))
688             blockBuilder().childBecameNonInline(downcast&lt;RenderBlock&gt;(*parent), child);
689         else if (is&lt;RenderInline&gt;(*parent))
690             inlineBuilder().childBecameNonInline(downcast&lt;RenderInline&gt;(*parent), child);
691 
692         // childBecameNonInline might have re-parented us.
693         if (auto* newParent = child.parent()) {
694             // We need to re-run the grid items placement if it had gained a new item.
695             if (newParent != parent &amp;&amp; is&lt;RenderGrid&gt;(*newParent))
696                 downcast&lt;RenderGrid&gt;(*newParent).dirtyGrid();
<a name="6" id="anc6"></a><span class="line-added">697             else if (auto* enclosingFragmentedFlow = newParent-&gt;enclosingFragmentedFlow()) {</span>
<span class="line-added">698                 if (is&lt;RenderMultiColumnFlow&gt;(*enclosingFragmentedFlow)) {</span>
<span class="line-added">699                     // Let the fragmented flow know that it has a new in-flow descendant.</span>
<span class="line-added">700                     multiColumnBuilder().multiColumnDescendantInserted(downcast&lt;RenderMultiColumnFlow&gt;(*enclosingFragmentedFlow), child);</span>
<span class="line-added">701                 }</span>
<span class="line-added">702             }</span>
703         }
704     } else {
705         // An anonymous block must be made to wrap this inline.
706         auto newBlock = downcast&lt;RenderBlock&gt;(*parent).createAnonymousBlock();
707         auto&amp; block = *newBlock;
708         attachToRenderElementInternal(*parent, WTFMove(newBlock), &amp;child);
709         auto thisToMove = detachFromRenderElement(*parent, child);
710         attachToRenderElementInternal(block, WTFMove(thisToMove));
711     }
712 }
713 
714 void RenderTreeBuilder::removeAnonymousWrappersForInlineChildrenIfNeeded(RenderElement&amp; parent)
715 {
716     if (!is&lt;RenderBlock&gt;(parent))
717         return;
718     auto&amp; blockParent = downcast&lt;RenderBlock&gt;(parent);
719     if (!blockParent.canDropAnonymousBlockChild())
720         return;
721 
722     // We have changed to floated or out-of-flow positioning so maybe all our parent&#39;s
723     // children can be inline now. Bail if there are any block children left on the line,
724     // otherwise we can proceed to stripping solitary anonymous wrappers from the inlines.
725     // FIXME: We should also handle split inlines here - we exclude them at the moment by returning
726     // if we find a continuation.
727     Optional&lt;bool&gt; shouldAllChildrenBeInline;
728     for (auto* current = blockParent.firstChild(); current; current = current-&gt;nextSibling()) {
729         if (current-&gt;style().isFloating() || current-&gt;style().hasOutOfFlowPosition())
730             continue;
731         if (!current-&gt;isAnonymousBlock() || downcast&lt;RenderBlock&gt;(*current).isContinuation())
732             return;
733         // Anonymous block not in continuation. Check if it holds a set of inline or block children and try not to mix them.
734         auto* firstChild = current-&gt;firstChildSlow();
735         if (!firstChild)
736             continue;
737         auto isInlineLevelBox = firstChild-&gt;isInline();
738         if (!shouldAllChildrenBeInline.hasValue()) {
739             shouldAllChildrenBeInline = isInlineLevelBox;
740             continue;
741         }
742         // Mixing inline and block level boxes?
743         if (*shouldAllChildrenBeInline != isInlineLevelBox)
744             return;
745     }
746 
747     RenderObject* next = nullptr;
748     for (auto* current = blockParent.firstChild(); current; current = next) {
749         next = current-&gt;nextSibling();
750         if (current-&gt;isAnonymousBlock())
751             blockBuilder().dropAnonymousBoxChild(blockParent, downcast&lt;RenderBlock&gt;(*current));
752     }
753 }
754 
755 void RenderTreeBuilder::childFlowStateChangesAndNoLongerAffectsParentBlock(RenderElement&amp; child)
756 {
757     ASSERT(child.parent());
758     removeAnonymousWrappersForInlineChildrenIfNeeded(*child.parent());
759 }
760 
761 static bool isAnonymousAndSafeToDelete(RenderElement&amp; element)
762 {
763     if (!element.isAnonymous())
764         return false;
765     if (element.isRenderView() || element.isRenderFragmentedFlow())
766         return false;
767     return true;
768 }
769 
770 static RenderObject&amp; findDestroyRootIncludingAnonymous(RenderObject&amp; renderer)
771 {
772     auto* destroyRoot = &amp;renderer;
773     while (true) {
774         auto&amp; destroyRootParent = *destroyRoot-&gt;parent();
775         if (!isAnonymousAndSafeToDelete(destroyRootParent))
776             break;
777         bool destroyingOnlyChild = destroyRootParent.firstChild() == destroyRoot &amp;&amp; destroyRootParent.lastChild() == destroyRoot;
778         if (!destroyingOnlyChild)
779             break;
780         destroyRoot = &amp;destroyRootParent;
781     }
782     return *destroyRoot;
783 }
784 
785 void RenderTreeBuilder::destroyAndCleanUpAnonymousWrappers(RenderObject&amp; child)
786 {
787     // If the tree is destroyed, there is no need for a clean-up phase.
788     if (child.renderTreeBeingDestroyed()) {
789         destroy(child);
790         return;
791     }
792 
793     // Remove intruding floats from sibling blocks before detaching.
794     if (is&lt;RenderBox&gt;(child) &amp;&amp; child.isFloatingOrOutOfFlowPositioned())
795         downcast&lt;RenderBox&gt;(child).removeFloatingOrPositionedChildFromBlockLists();
796     auto&amp; destroyRoot = findDestroyRootIncludingAnonymous(child);
797     if (is&lt;RenderTableRow&gt;(destroyRoot))
798         tableBuilder().collapseAndDestroyAnonymousSiblingRows(downcast&lt;RenderTableRow&gt;(destroyRoot));
799 
800     // FIXME: Do not try to collapse/cleanup the anonymous wrappers inside destroy (see webkit.org/b/186746).
801     auto destroyRootParent = makeWeakPtr(*destroyRoot.parent());
802     destroy(destroyRoot);
803     if (!destroyRootParent)
804         return;
805     removeAnonymousWrappersForInlineChildrenIfNeeded(*destroyRootParent);
806 
807     // Anonymous parent might have become empty, try to delete it too.
808     if (isAnonymousAndSafeToDelete(*destroyRootParent) &amp;&amp; !destroyRootParent-&gt;firstChild())
809         destroyAndCleanUpAnonymousWrappers(*destroyRootParent);
810     // WARNING: child is deleted here.
811 }
812 
813 void RenderTreeBuilder::updateAfterDescendants(RenderElement&amp; renderer)
814 {
815     if (is&lt;RenderBlock&gt;(renderer))
816         firstLetterBuilder().updateAfterDescendants(downcast&lt;RenderBlock&gt;(renderer));
817     if (is&lt;RenderListItem&gt;(renderer))
818         listBuilder().updateItemMarker(downcast&lt;RenderListItem&gt;(renderer));
819     if (is&lt;RenderBlockFlow&gt;(renderer))
820         multiColumnBuilder().updateAfterDescendants(downcast&lt;RenderBlockFlow&gt;(renderer));
821 }
822 
823 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::detachFromRenderGrid(RenderGrid&amp; parent, RenderObject&amp; child)
824 {
825     auto takenChild = blockBuilder().detach(parent, child);
826     // Positioned grid items do not take up space or otherwise participate in the layout of the grid,
827     // for that reason we don&#39;t need to mark the grid as dirty when they are removed.
828     if (child.isOutOfFlowPositioned())
829         return takenChild;
830 
831     // The grid needs to be recomputed as it might contain auto-placed items that will change their position.
832     parent.dirtyGrid();
833     return takenChild;
834 }
835 
836 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::detachFromRenderElement(RenderElement&amp; parent, RenderObject&amp; child)
837 {
838     RELEASE_ASSERT_WITH_MESSAGE(!parent.view().frameView().layoutContext().layoutState(), &quot;Layout must not mutate render tree&quot;);
839 
840     ASSERT(parent.canHaveChildren() || parent.canHaveGeneratedChildren());
841     ASSERT(child.parent() == &amp;parent);
842 
843     if (child.isFloatingOrOutOfFlowPositioned())
844         downcast&lt;RenderBox&gt;(child).removeFloatingOrPositionedChildFromBlockLists();
845 
846     // So that we&#39;ll get the appropriate dirty bit set (either that a normal flow child got yanked or
847     // that a positioned child got yanked). We also repaint, so that the area exposed when the child
848     // disappears gets repainted properly.
849     if (!parent.renderTreeBeingDestroyed() &amp;&amp; child.everHadLayout()) {
850         child.setNeedsLayoutAndPrefWidthsRecalc();
851         // We only repaint |child| if we have a RenderLayer as its visual overflow may not be tracked by its parent.
852         if (child.isBody())
853             parent.view().repaintRootContents();
854         else
855             child.repaint();
856     }
857 
858     // If we have a line box wrapper, delete it.
859     if (is&lt;RenderBox&gt;(child))
860         downcast&lt;RenderBox&gt;(child).deleteLineBoxWrapper();
861     else if (is&lt;RenderLineBreak&gt;(child))
862         downcast&lt;RenderLineBreak&gt;(child).deleteInlineBoxWrapper();
863 
864     if (!parent.renderTreeBeingDestroyed() &amp;&amp; is&lt;RenderFlexibleBox&gt;(parent) &amp;&amp; !child.isFloatingOrOutOfFlowPositioned() &amp;&amp; child.isBox())
865         downcast&lt;RenderFlexibleBox&gt;(parent).clearCachedChildIntrinsicContentLogicalHeight(downcast&lt;RenderBox&gt;(child));
866 
867     // If child is the start or end of the selection, then clear the selection to
868     // avoid problems of invalid pointers.
869     if (!parent.renderTreeBeingDestroyed() &amp;&amp; child.isSelectionBorder())
870         parent.frame().selection().setNeedsSelectionUpdate();
871 
872     if (!parent.renderTreeBeingDestroyed())
873         child.willBeRemovedFromTree();
874 
875     child.resetFragmentedFlowStateOnRemoval();
876 
877     // WARNING: There should be no code running between willBeRemovedFromTree() and the actual removal below.
878     // This is needed to avoid race conditions where willBeRemovedFromTree() would dirty the tree&#39;s structure
879     // and the code running here would force an untimely rebuilding, leaving |child| dangling.
880     auto childToTake = parent.detachRendererInternal(child);
881 
882     // rendererRemovedFromTree() walks the whole subtree. We can improve performance
883     // by skipping this step when destroying the entire tree.
884     if (!parent.renderTreeBeingDestroyed() &amp;&amp; is&lt;RenderElement&gt;(*childToTake))
885         RenderCounter::rendererRemovedFromTree(downcast&lt;RenderElement&gt;(*childToTake));
886 
887     if (!parent.renderTreeBeingDestroyed()) {
888         if (AXObjectCache* cache = parent.document().existingAXObjectCache())
889             cache-&gt;childrenChanged(&amp;parent);
890     }
<a name="7" id="anc7"></a><span class="line-added">891 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">892     if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextEnabled()) {</span>
<span class="line-added">893         if (parent.document().view())</span>
<span class="line-added">894             parent.document().view()-&gt;layoutContext().invalidateLayoutTreeContent();</span>
895 
<a name="8" id="anc8"></a><span class="line-added">896     }</span>
<span class="line-added">897 #endif</span>
898     return childToTake;
899 }
900 
901 void RenderTreeBuilder::attachToRenderGrid(RenderGrid&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
902 {
903     auto&amp; newChild = *child;
904     blockBuilder().attach(parent, WTFMove(child), beforeChild);
905 
906     // Positioned grid items do not take up space or otherwise participate in the layout of the grid,
907     // for that reason we don&#39;t need to mark the grid as dirty when they are added.
908     if (newChild.isOutOfFlowPositioned())
909         return;
910 
911     // The grid needs to be recomputed as it might contain auto-placed items that
912     // will change their position.
913     parent.dirtyGrid();
914 }
915 
916 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
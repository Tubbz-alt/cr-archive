<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderTable.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderTreeBuilderRuby.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderTreePosition.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 90         return parent;
 91 
 92     auto* lastChild = beforeChild ? beforeChild : parent.lastRow();
 93     if (is&lt;RenderTableRow&gt;(lastChild) &amp;&amp; lastChild-&gt;isAnonymous() &amp;&amp; !lastChild-&gt;isBeforeOrAfterContent()) {
 94         if (beforeChild == lastChild)
 95             beforeChild = downcast&lt;RenderTableRow&gt;(*lastChild).firstCell();
 96         return downcast&lt;RenderElement&gt;(*lastChild);
 97     }
 98 
 99     if (beforeChild &amp;&amp; !beforeChild-&gt;isAnonymous() &amp;&amp; beforeChild-&gt;parent() == &amp;parent) {
100         auto* row = beforeChild-&gt;previousSibling();
101         if (is&lt;RenderTableRow&gt;(row) &amp;&amp; row-&gt;isAnonymous()) {
102             beforeChild = nullptr;
103             return downcast&lt;RenderElement&gt;(*row);
104         }
105     }
106 
107     // If beforeChild is inside an anonymous cell/row, insert into the cell or into
108     // the anonymous row containing it, if there is one.
109     auto* parentCandidate = lastChild;
<span class="line-modified">110     while (parentCandidate &amp;&amp; parentCandidate-&gt;parent()-&gt;isAnonymous() &amp;&amp; !is&lt;RenderTableRow&gt;(*parentCandidate))</span>
111         parentCandidate = parentCandidate-&gt;parent();
112     if (is&lt;RenderTableRow&gt;(parentCandidate) &amp;&amp; parentCandidate-&gt;isAnonymous() &amp;&amp; !parentCandidate-&gt;isBeforeOrAfterContent())
113         return downcast&lt;RenderElement&gt;(*parentCandidate);
114 
115     auto newRow = RenderTableRow::createAnonymousWithParentRenderer(parent);
116     auto&amp; row = *newRow;
117     m_builder.attach(parent, WTFMove(newRow), beforeChild);
118     beforeChild = nullptr;
119     return row;
120 }
121 
122 RenderElement&amp; RenderTreeBuilder::Table::findOrCreateParentForChild(RenderTable&amp; parent, const RenderObject&amp; child, RenderObject*&amp; beforeChild)
123 {
124     if (is&lt;RenderTableCaption&gt;(child) || is&lt;RenderTableCol&gt;(child) || is&lt;RenderTableSection&gt;(child))
125         return parent;
126 
127     auto* lastChild = parent.lastChild();
128     if (!beforeChild &amp;&amp; is&lt;RenderTableSection&gt;(lastChild) &amp;&amp; lastChild-&gt;isAnonymous() &amp;&amp; !lastChild-&gt;isBeforeContent())
129         return downcast&lt;RenderElement&gt;(*lastChild);
130 
</pre>
</td>
<td>
<hr />
<pre>
 90         return parent;
 91 
 92     auto* lastChild = beforeChild ? beforeChild : parent.lastRow();
 93     if (is&lt;RenderTableRow&gt;(lastChild) &amp;&amp; lastChild-&gt;isAnonymous() &amp;&amp; !lastChild-&gt;isBeforeOrAfterContent()) {
 94         if (beforeChild == lastChild)
 95             beforeChild = downcast&lt;RenderTableRow&gt;(*lastChild).firstCell();
 96         return downcast&lt;RenderElement&gt;(*lastChild);
 97     }
 98 
 99     if (beforeChild &amp;&amp; !beforeChild-&gt;isAnonymous() &amp;&amp; beforeChild-&gt;parent() == &amp;parent) {
100         auto* row = beforeChild-&gt;previousSibling();
101         if (is&lt;RenderTableRow&gt;(row) &amp;&amp; row-&gt;isAnonymous()) {
102             beforeChild = nullptr;
103             return downcast&lt;RenderElement&gt;(*row);
104         }
105     }
106 
107     // If beforeChild is inside an anonymous cell/row, insert into the cell or into
108     // the anonymous row containing it, if there is one.
109     auto* parentCandidate = lastChild;
<span class="line-modified">110     while (parentCandidate &amp;&amp; parentCandidate-&gt;parent() &amp;&amp; parentCandidate-&gt;parent()-&gt;isAnonymous() &amp;&amp; !is&lt;RenderTableRow&gt;(*parentCandidate))</span>
111         parentCandidate = parentCandidate-&gt;parent();
112     if (is&lt;RenderTableRow&gt;(parentCandidate) &amp;&amp; parentCandidate-&gt;isAnonymous() &amp;&amp; !parentCandidate-&gt;isBeforeOrAfterContent())
113         return downcast&lt;RenderElement&gt;(*parentCandidate);
114 
115     auto newRow = RenderTableRow::createAnonymousWithParentRenderer(parent);
116     auto&amp; row = *newRow;
117     m_builder.attach(parent, WTFMove(newRow), beforeChild);
118     beforeChild = nullptr;
119     return row;
120 }
121 
122 RenderElement&amp; RenderTreeBuilder::Table::findOrCreateParentForChild(RenderTable&amp; parent, const RenderObject&amp; child, RenderObject*&amp; beforeChild)
123 {
124     if (is&lt;RenderTableCaption&gt;(child) || is&lt;RenderTableCol&gt;(child) || is&lt;RenderTableSection&gt;(child))
125         return parent;
126 
127     auto* lastChild = parent.lastChild();
128     if (!beforeChild &amp;&amp; is&lt;RenderTableSection&gt;(lastChild) &amp;&amp; lastChild-&gt;isAnonymous() &amp;&amp; !lastChild-&gt;isBeforeContent())
129         return downcast&lt;RenderElement&gt;(*lastChild);
130 
</pre>
</td>
</tr>
</table>
<center><a href="RenderTreeBuilderRuby.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderTreePosition.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
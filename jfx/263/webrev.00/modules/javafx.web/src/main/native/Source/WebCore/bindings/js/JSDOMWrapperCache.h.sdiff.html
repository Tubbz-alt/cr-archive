<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWrapperCache.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMWrapper.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDeprecatedCSSOMValueCustom.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWrapperCache.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 23 
 24 #pragma once
 25 
 26 #include &quot;DOMWrapperWorld.h&quot;
 27 #include &quot;JSDOMGlobalObject.h&quot;
 28 #include &quot;JSDOMWrapper.h&quot;
 29 #include &quot;ScriptWrappable.h&quot;
 30 #include &quot;ScriptWrappableInlines.h&quot;
 31 #include &quot;WebCoreTypedArrayController.h&quot;
 32 #include &lt;JavaScriptCore/JSArrayBuffer.h&gt;
 33 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
 34 #include &lt;JavaScriptCore/Weak.h&gt;
 35 #include &lt;JavaScriptCore/WeakInlines.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 WEBCORE_EXPORT JSC::Structure* getCachedDOMStructure(JSDOMGlobalObject&amp;, const JSC::ClassInfo*);
 40 WEBCORE_EXPORT JSC::Structure* cacheDOMStructure(JSDOMGlobalObject&amp;, JSC::Structure*, const JSC::ClassInfo*);
 41 
 42 template&lt;typename WrapperClass&gt; JSC::Structure* getDOMStructure(JSC::VM&amp;, JSDOMGlobalObject&amp;);
<span class="line-modified"> 43 template&lt;typename WrapperClass&gt; JSC::Structure* deprecatedGetDOMStructure(JSC::ExecState*);</span>
 44 template&lt;typename WrapperClass&gt; JSC::JSObject* getDOMPrototype(JSC::VM&amp;, JSC::JSGlobalObject*);
 45 
 46 JSC::WeakHandleOwner* wrapperOwner(DOMWrapperWorld&amp;, JSC::ArrayBuffer*);
 47 void* wrapperKey(JSC::ArrayBuffer*);
 48 
 49 JSDOMObject* getInlineCachedWrapper(DOMWrapperWorld&amp;, void*);
 50 JSDOMObject* getInlineCachedWrapper(DOMWrapperWorld&amp;, ScriptWrappable*);
 51 JSC::JSArrayBuffer* getInlineCachedWrapper(DOMWrapperWorld&amp;, JSC::ArrayBuffer*);
 52 
 53 bool setInlineCachedWrapper(DOMWrapperWorld&amp;, void*, JSDOMObject*, JSC::WeakHandleOwner*);
 54 bool setInlineCachedWrapper(DOMWrapperWorld&amp;, ScriptWrappable*, JSDOMObject* wrapper, JSC::WeakHandleOwner* wrapperOwner);
 55 bool setInlineCachedWrapper(DOMWrapperWorld&amp;, JSC::ArrayBuffer*, JSC::JSArrayBuffer* wrapper, JSC::WeakHandleOwner* wrapperOwner);
 56 
 57 bool clearInlineCachedWrapper(DOMWrapperWorld&amp;, void*, JSDOMObject*);
 58 bool clearInlineCachedWrapper(DOMWrapperWorld&amp;, ScriptWrappable*, JSDOMObject* wrapper);
 59 bool clearInlineCachedWrapper(DOMWrapperWorld&amp;, JSC::ArrayBuffer*, JSC::JSArrayBuffer* wrapper);
 60 
 61 template&lt;typename DOMClass&gt; JSC::JSObject* getCachedWrapper(DOMWrapperWorld&amp;, DOMClass&amp;);
 62 template&lt;typename DOMClass&gt; inline JSC::JSObject* getCachedWrapper(DOMWrapperWorld&amp; world, Ref&lt;DOMClass&gt;&amp; object) { return getCachedWrapper(world, object.get()); }
 63 template&lt;typename DOMClass, typename WrapperClass&gt; void cacheWrapper(DOMWrapperWorld&amp;, DOMClass*, WrapperClass*);
 64 template&lt;typename DOMClass, typename WrapperClass&gt; void uncacheWrapper(DOMWrapperWorld&amp;, DOMClass*, WrapperClass*);
 65 template&lt;typename DOMClass, typename T&gt; auto createWrapper(JSDOMGlobalObject*, Ref&lt;T&gt;&amp;&amp;) -&gt; typename std::enable_if&lt;std::is_same&lt;DOMClass, T&gt;::value, typename JSDOMWrapperConverterTraits&lt;DOMClass&gt;::WrapperClass*&gt;::type;
 66 template&lt;typename DOMClass, typename T&gt; auto createWrapper(JSDOMGlobalObject*, Ref&lt;T&gt;&amp;&amp;) -&gt; typename std::enable_if&lt;!std::is_same&lt;DOMClass, T&gt;::value, typename JSDOMWrapperConverterTraits&lt;DOMClass&gt;::WrapperClass*&gt;::type;
 67 
<span class="line-modified"> 68 template&lt;typename DOMClass&gt; JSC::JSValue wrap(JSC::ExecState*, JSDOMGlobalObject*, DOMClass&amp;);</span>
 69 
 70 
 71 // Inline functions and template definitions.
 72 
<span class="line-modified"> 73 inline JSDOMGlobalObject* deprecatedGlobalObjectForPrototype(JSC::ExecState* exec)</span>
 74 {
 75     // FIXME: Callers to this function should be using the global object
 76     // from which the object is being created, instead of assuming the lexical one.
 77     // e.g. subframe.document.body should use the subframe&#39;s global object, not the lexical one.
<span class="line-modified"> 78     return JSC::jsCast&lt;JSDOMGlobalObject*&gt;(exec-&gt;lexicalGlobalObject());</span>
 79 }
 80 
 81 template&lt;typename WrapperClass&gt; inline JSC::Structure* getDOMStructure(JSC::VM&amp; vm, JSDOMGlobalObject&amp; globalObject)
 82 {
 83     if (JSC::Structure* structure = getCachedDOMStructure(globalObject, WrapperClass::info()))
 84         return structure;
 85     return cacheDOMStructure(globalObject, WrapperClass::createStructure(vm, &amp;globalObject, WrapperClass::createPrototype(vm, globalObject)), WrapperClass::info());
 86 }
 87 
<span class="line-modified"> 88 template&lt;typename WrapperClass&gt; inline JSC::Structure* deprecatedGetDOMStructure(JSC::ExecState* exec)</span>
 89 {
 90     // FIXME: This function is wrong. It uses the wrong global object for creating the prototype structure.
<span class="line-modified"> 91     return getDOMStructure&lt;WrapperClass&gt;(exec-&gt;vm(), *deprecatedGlobalObjectForPrototype(exec));</span>
 92 }
 93 
 94 template&lt;typename WrapperClass&gt; inline JSC::JSObject* getDOMPrototype(JSC::VM&amp; vm, JSDOMGlobalObject&amp; globalObject)
 95 {
 96     return JSC::jsCast&lt;JSC::JSObject*&gt;(asObject(getDOMStructure&lt;WrapperClass&gt;(vm, globalObject)-&gt;storedPrototype()));
 97 }
 98 
 99 inline JSC::WeakHandleOwner* wrapperOwner(DOMWrapperWorld&amp; world, JSC::ArrayBuffer*)
100 {
101     return static_cast&lt;WebCoreTypedArrayController*&gt;(world.vm().m_typedArrayController.get())-&gt;wrapperOwner();
102 }
103 
104 inline void* wrapperKey(JSC::ArrayBuffer* domObject)
105 {
106     return domObject;
107 }
108 
109 inline JSDOMObject* getInlineCachedWrapper(DOMWrapperWorld&amp;, void*) { return nullptr; }
110 inline bool setInlineCachedWrapper(DOMWrapperWorld&amp;, void*, JSDOMObject*, JSC::WeakHandleOwner*) { return false; }
111 inline bool clearInlineCachedWrapper(DOMWrapperWorld&amp;, void*, JSDOMObject*) { return false; }
</pre>
<hr />
<pre>
177         return;
178     weakRemove(world.wrappers(), wrapperKey(domObject), wrapper);
179 }
180 
181 template&lt;typename DOMClass, typename T&gt; inline auto createWrapper(JSDOMGlobalObject* globalObject, Ref&lt;T&gt;&amp;&amp; domObject) -&gt; typename std::enable_if&lt;std::is_same&lt;DOMClass, T&gt;::value, typename JSDOMWrapperConverterTraits&lt;DOMClass&gt;::WrapperClass*&gt;::type
182 {
183     using WrapperClass = typename JSDOMWrapperConverterTraits&lt;DOMClass&gt;::WrapperClass;
184 
185     ASSERT(!getCachedWrapper(globalObject-&gt;world(), domObject));
186     auto* domObjectPtr = domObject.ptr();
187     auto* wrapper = WrapperClass::create(getDOMStructure&lt;WrapperClass&gt;(globalObject-&gt;vm(), *globalObject), globalObject, WTFMove(domObject));
188     cacheWrapper(globalObject-&gt;world(), domObjectPtr, wrapper);
189     return wrapper;
190 }
191 
192 template&lt;typename DOMClass, typename T&gt; inline auto createWrapper(JSDOMGlobalObject* globalObject, Ref&lt;T&gt;&amp;&amp; domObject) -&gt; typename std::enable_if&lt;!std::is_same&lt;DOMClass, T&gt;::value, typename JSDOMWrapperConverterTraits&lt;DOMClass&gt;::WrapperClass*&gt;::type
193 {
194     return createWrapper&lt;DOMClass&gt;(globalObject, static_reference_cast&lt;DOMClass&gt;(WTFMove(domObject)));
195 }
196 
<span class="line-modified">197 template&lt;typename DOMClass&gt; inline JSC::JSValue wrap(JSC::ExecState* state, JSDOMGlobalObject* globalObject, DOMClass&amp; domObject)</span>
198 {
199     if (auto* wrapper = getCachedWrapper(globalObject-&gt;world(), domObject))
200         return wrapper;
<span class="line-modified">201     return toJSNewlyCreated(state, globalObject, Ref&lt;DOMClass&gt;(domObject));</span>
202 }
203 
204 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 23 
 24 #pragma once
 25 
 26 #include &quot;DOMWrapperWorld.h&quot;
 27 #include &quot;JSDOMGlobalObject.h&quot;
 28 #include &quot;JSDOMWrapper.h&quot;
 29 #include &quot;ScriptWrappable.h&quot;
 30 #include &quot;ScriptWrappableInlines.h&quot;
 31 #include &quot;WebCoreTypedArrayController.h&quot;
 32 #include &lt;JavaScriptCore/JSArrayBuffer.h&gt;
 33 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
 34 #include &lt;JavaScriptCore/Weak.h&gt;
 35 #include &lt;JavaScriptCore/WeakInlines.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 WEBCORE_EXPORT JSC::Structure* getCachedDOMStructure(JSDOMGlobalObject&amp;, const JSC::ClassInfo*);
 40 WEBCORE_EXPORT JSC::Structure* cacheDOMStructure(JSDOMGlobalObject&amp;, JSC::Structure*, const JSC::ClassInfo*);
 41 
 42 template&lt;typename WrapperClass&gt; JSC::Structure* getDOMStructure(JSC::VM&amp;, JSDOMGlobalObject&amp;);
<span class="line-modified"> 43 template&lt;typename WrapperClass&gt; JSC::Structure* deprecatedGetDOMStructure(JSC::JSGlobalObject*);</span>
 44 template&lt;typename WrapperClass&gt; JSC::JSObject* getDOMPrototype(JSC::VM&amp;, JSC::JSGlobalObject*);
 45 
 46 JSC::WeakHandleOwner* wrapperOwner(DOMWrapperWorld&amp;, JSC::ArrayBuffer*);
 47 void* wrapperKey(JSC::ArrayBuffer*);
 48 
 49 JSDOMObject* getInlineCachedWrapper(DOMWrapperWorld&amp;, void*);
 50 JSDOMObject* getInlineCachedWrapper(DOMWrapperWorld&amp;, ScriptWrappable*);
 51 JSC::JSArrayBuffer* getInlineCachedWrapper(DOMWrapperWorld&amp;, JSC::ArrayBuffer*);
 52 
 53 bool setInlineCachedWrapper(DOMWrapperWorld&amp;, void*, JSDOMObject*, JSC::WeakHandleOwner*);
 54 bool setInlineCachedWrapper(DOMWrapperWorld&amp;, ScriptWrappable*, JSDOMObject* wrapper, JSC::WeakHandleOwner* wrapperOwner);
 55 bool setInlineCachedWrapper(DOMWrapperWorld&amp;, JSC::ArrayBuffer*, JSC::JSArrayBuffer* wrapper, JSC::WeakHandleOwner* wrapperOwner);
 56 
 57 bool clearInlineCachedWrapper(DOMWrapperWorld&amp;, void*, JSDOMObject*);
 58 bool clearInlineCachedWrapper(DOMWrapperWorld&amp;, ScriptWrappable*, JSDOMObject* wrapper);
 59 bool clearInlineCachedWrapper(DOMWrapperWorld&amp;, JSC::ArrayBuffer*, JSC::JSArrayBuffer* wrapper);
 60 
 61 template&lt;typename DOMClass&gt; JSC::JSObject* getCachedWrapper(DOMWrapperWorld&amp;, DOMClass&amp;);
 62 template&lt;typename DOMClass&gt; inline JSC::JSObject* getCachedWrapper(DOMWrapperWorld&amp; world, Ref&lt;DOMClass&gt;&amp; object) { return getCachedWrapper(world, object.get()); }
 63 template&lt;typename DOMClass, typename WrapperClass&gt; void cacheWrapper(DOMWrapperWorld&amp;, DOMClass*, WrapperClass*);
 64 template&lt;typename DOMClass, typename WrapperClass&gt; void uncacheWrapper(DOMWrapperWorld&amp;, DOMClass*, WrapperClass*);
 65 template&lt;typename DOMClass, typename T&gt; auto createWrapper(JSDOMGlobalObject*, Ref&lt;T&gt;&amp;&amp;) -&gt; typename std::enable_if&lt;std::is_same&lt;DOMClass, T&gt;::value, typename JSDOMWrapperConverterTraits&lt;DOMClass&gt;::WrapperClass*&gt;::type;
 66 template&lt;typename DOMClass, typename T&gt; auto createWrapper(JSDOMGlobalObject*, Ref&lt;T&gt;&amp;&amp;) -&gt; typename std::enable_if&lt;!std::is_same&lt;DOMClass, T&gt;::value, typename JSDOMWrapperConverterTraits&lt;DOMClass&gt;::WrapperClass*&gt;::type;
 67 
<span class="line-modified"> 68 template&lt;typename DOMClass&gt; JSC::JSValue wrap(JSC::JSGlobalObject*, JSDOMGlobalObject*, DOMClass&amp;);</span>
 69 
 70 
 71 // Inline functions and template definitions.
 72 
<span class="line-modified"> 73 inline JSDOMGlobalObject* deprecatedGlobalObjectForPrototype(JSC::JSGlobalObject* lexicalGlobalObject)</span>
 74 {
 75     // FIXME: Callers to this function should be using the global object
 76     // from which the object is being created, instead of assuming the lexical one.
 77     // e.g. subframe.document.body should use the subframe&#39;s global object, not the lexical one.
<span class="line-modified"> 78     return JSC::jsCast&lt;JSDOMGlobalObject*&gt;(lexicalGlobalObject);</span>
 79 }
 80 
 81 template&lt;typename WrapperClass&gt; inline JSC::Structure* getDOMStructure(JSC::VM&amp; vm, JSDOMGlobalObject&amp; globalObject)
 82 {
 83     if (JSC::Structure* structure = getCachedDOMStructure(globalObject, WrapperClass::info()))
 84         return structure;
 85     return cacheDOMStructure(globalObject, WrapperClass::createStructure(vm, &amp;globalObject, WrapperClass::createPrototype(vm, globalObject)), WrapperClass::info());
 86 }
 87 
<span class="line-modified"> 88 template&lt;typename WrapperClass&gt; inline JSC::Structure* deprecatedGetDOMStructure(JSC::JSGlobalObject* lexicalGlobalObject)</span>
 89 {
 90     // FIXME: This function is wrong. It uses the wrong global object for creating the prototype structure.
<span class="line-modified"> 91     return getDOMStructure&lt;WrapperClass&gt;(JSC::getVM(lexicalGlobalObject), *deprecatedGlobalObjectForPrototype(lexicalGlobalObject));</span>
 92 }
 93 
 94 template&lt;typename WrapperClass&gt; inline JSC::JSObject* getDOMPrototype(JSC::VM&amp; vm, JSDOMGlobalObject&amp; globalObject)
 95 {
 96     return JSC::jsCast&lt;JSC::JSObject*&gt;(asObject(getDOMStructure&lt;WrapperClass&gt;(vm, globalObject)-&gt;storedPrototype()));
 97 }
 98 
 99 inline JSC::WeakHandleOwner* wrapperOwner(DOMWrapperWorld&amp; world, JSC::ArrayBuffer*)
100 {
101     return static_cast&lt;WebCoreTypedArrayController*&gt;(world.vm().m_typedArrayController.get())-&gt;wrapperOwner();
102 }
103 
104 inline void* wrapperKey(JSC::ArrayBuffer* domObject)
105 {
106     return domObject;
107 }
108 
109 inline JSDOMObject* getInlineCachedWrapper(DOMWrapperWorld&amp;, void*) { return nullptr; }
110 inline bool setInlineCachedWrapper(DOMWrapperWorld&amp;, void*, JSDOMObject*, JSC::WeakHandleOwner*) { return false; }
111 inline bool clearInlineCachedWrapper(DOMWrapperWorld&amp;, void*, JSDOMObject*) { return false; }
</pre>
<hr />
<pre>
177         return;
178     weakRemove(world.wrappers(), wrapperKey(domObject), wrapper);
179 }
180 
181 template&lt;typename DOMClass, typename T&gt; inline auto createWrapper(JSDOMGlobalObject* globalObject, Ref&lt;T&gt;&amp;&amp; domObject) -&gt; typename std::enable_if&lt;std::is_same&lt;DOMClass, T&gt;::value, typename JSDOMWrapperConverterTraits&lt;DOMClass&gt;::WrapperClass*&gt;::type
182 {
183     using WrapperClass = typename JSDOMWrapperConverterTraits&lt;DOMClass&gt;::WrapperClass;
184 
185     ASSERT(!getCachedWrapper(globalObject-&gt;world(), domObject));
186     auto* domObjectPtr = domObject.ptr();
187     auto* wrapper = WrapperClass::create(getDOMStructure&lt;WrapperClass&gt;(globalObject-&gt;vm(), *globalObject), globalObject, WTFMove(domObject));
188     cacheWrapper(globalObject-&gt;world(), domObjectPtr, wrapper);
189     return wrapper;
190 }
191 
192 template&lt;typename DOMClass, typename T&gt; inline auto createWrapper(JSDOMGlobalObject* globalObject, Ref&lt;T&gt;&amp;&amp; domObject) -&gt; typename std::enable_if&lt;!std::is_same&lt;DOMClass, T&gt;::value, typename JSDOMWrapperConverterTraits&lt;DOMClass&gt;::WrapperClass*&gt;::type
193 {
194     return createWrapper&lt;DOMClass&gt;(globalObject, static_reference_cast&lt;DOMClass&gt;(WTFMove(domObject)));
195 }
196 
<span class="line-modified">197 template&lt;typename DOMClass&gt; inline JSC::JSValue wrap(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, DOMClass&amp; domObject)</span>
198 {
199     if (auto* wrapper = getCachedWrapper(globalObject-&gt;world(), domObject))
200         return wrapper;
<span class="line-modified">201     return toJSNewlyCreated(lexicalGlobalObject, globalObject, Ref&lt;DOMClass&gt;(domObject));</span>
202 }
203 
204 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="JSDOMWrapper.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDeprecatedCSSOMValueCustom.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
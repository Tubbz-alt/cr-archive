diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGTierUpCheckInjectionPhase.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGTierUpCheckInjectionPhase.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGTierUpCheckInjectionPhase.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGTierUpCheckInjectionPhase.cpp
@@ -83,13 +83,13 @@
         if (!Options::useOSREntryToFTL())
             level = FTL::CanCompile;
 
         m_graph.ensureCPSNaturalLoops();
         CPSNaturalLoops& naturalLoops = *m_graph.m_cpsNaturalLoops;
-        HashMap<const NaturalLoop*, unsigned> naturalLoopToLoopHint = buildNaturalLoopToLoopHintMap(naturalLoops);
+        HashMap<const NaturalLoop*, BytecodeIndex> naturalLoopToLoopHint = buildNaturalLoopToLoopHintMap(naturalLoops);
 
-        HashMap<unsigned, LoopHintDescriptor> tierUpHierarchy;
+        HashMap<BytecodeIndex, LoopHintDescriptor> tierUpHierarchy;
 
         InsertionSet insertionSet(m_graph);
         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
             BasicBlock* block = m_graph.block(blockIndex);
             if (!block)
@@ -106,11 +106,11 @@
                 NodeType tierUpType = CheckTierUpAndOSREnter;
                 if (!canOSREnter)
                     tierUpType = CheckTierUpInLoop;
                 insertionSet.insertNode(nodeIndex + 1, SpecNone, tierUpType, origin);
 
-                unsigned bytecodeIndex = origin.semantic.bytecodeIndex();
+                auto bytecodeIndex = origin.semantic.bytecodeIndex();
                 if (canOSREnter)
                     m_graph.m_plan.tierUpAndOSREnterBytecodes().append(bytecodeIndex);
 
                 if (const NaturalLoop* loop = naturalLoops.innerMostLoopOf(block)) {
                     LoopHintDescriptor descriptor;
@@ -136,12 +136,12 @@
             insertionSet.execute(block);
         }
 
         // Add all the candidates that can be OSR Entered.
         for (auto entry : tierUpHierarchy) {
-            Vector<unsigned> tierUpCandidates;
-            for (unsigned bytecodeIndex : entry.value.osrEntryCandidates) {
+            Vector<BytecodeIndex> tierUpCandidates;
+            for (BytecodeIndex bytecodeIndex : entry.value.osrEntryCandidates) {
                 auto descriptorIt = tierUpHierarchy.find(bytecodeIndex);
                 if (descriptorIt != tierUpHierarchy.end()
                     && descriptorIt->value.canOSREnter)
                     tierUpCandidates.append(bytecodeIndex);
             }
@@ -158,11 +158,11 @@
     }
 
 private:
 #if ENABLE(FTL_JIT)
     struct LoopHintDescriptor {
-        Vector<unsigned> osrEntryCandidates;
+        Vector<BytecodeIndex> osrEntryCandidates;
         bool canOSREnter;
     };
 
     bool canOSREnterAtLoopHint(FTL::CapabilityLevel level, const BasicBlock* block, unsigned nodeIndex)
     {
@@ -181,22 +181,22 @@
                 return false;
         }
         return true;
     }
 
-    HashMap<const NaturalLoop*, unsigned> buildNaturalLoopToLoopHintMap(const CPSNaturalLoops& naturalLoops)
+    HashMap<const NaturalLoop*, BytecodeIndex> buildNaturalLoopToLoopHintMap(const CPSNaturalLoops& naturalLoops)
     {
-        HashMap<const NaturalLoop*, unsigned> naturalLoopsToLoopHint;
+        HashMap<const NaturalLoop*, BytecodeIndex> naturalLoopsToLoopHint;
 
         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
             for (unsigned nodeIndex = 0; nodeIndex < block->size(); ++nodeIndex) {
                 Node* node = block->at(nodeIndex);
                 if (node->op() != LoopHint)
                     continue;
 
                 if (const NaturalLoop* loop = naturalLoops.innerMostLoopOf(block)) {
-                    unsigned bytecodeIndex = node->origin.semantic.bytecodeIndex();
+                    BytecodeIndex bytecodeIndex = node->origin.semantic.bytecodeIndex();
                     naturalLoopsToLoopHint.add(loop, bytecodeIndex);
                 }
                 break;
             }
         }

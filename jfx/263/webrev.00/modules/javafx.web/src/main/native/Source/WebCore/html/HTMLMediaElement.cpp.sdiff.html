<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLMarqueeElement.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLMediaElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  55 #include &quot;FullscreenManager.h&quot;
  56 #include &quot;HTMLParserIdioms.h&quot;
  57 #include &quot;HTMLSourceElement.h&quot;
  58 #include &quot;HTMLVideoElement.h&quot;
  59 #include &quot;InspectorInstrumentation.h&quot;
  60 #include &quot;JSDOMException.h&quot;
  61 #include &quot;JSDOMPromiseDeferred.h&quot;
  62 #include &quot;JSHTMLMediaElement.h&quot;
  63 #include &quot;Logging.h&quot;
  64 #include &quot;MIMETypeRegistry.h&quot;
  65 #include &quot;MediaController.h&quot;
  66 #include &quot;MediaControls.h&quot;
  67 #include &quot;MediaDocument.h&quot;
  68 #include &quot;MediaError.h&quot;
  69 #include &quot;MediaFragmentURIParser.h&quot;
  70 #include &quot;MediaList.h&quot;
  71 #include &quot;MediaPlayer.h&quot;
  72 #include &quot;MediaQueryEvaluator.h&quot;
  73 #include &quot;MediaResourceLoader.h&quot;
  74 #include &quot;NetworkingContext.h&quot;

  75 #include &quot;Page.h&quot;
  76 #include &quot;PageGroup.h&quot;

  77 #include &quot;PlatformMediaSessionManager.h&quot;
  78 #include &quot;ProgressTracker.h&quot;
  79 #include &quot;Quirks.h&quot;
  80 #include &quot;RegistrableDomain.h&quot;
  81 #include &quot;RenderLayerCompositor.h&quot;
  82 #include &quot;RenderTheme.h&quot;
  83 #include &quot;RenderVideo.h&quot;
  84 #include &quot;RenderView.h&quot;
  85 #include &quot;ResourceLoadInfo.h&quot;
  86 #include &quot;ScriptController.h&quot;
  87 #include &quot;ScriptDisallowedScope.h&quot;
  88 #include &quot;ScriptSourceCode.h&quot;
  89 #include &quot;SecurityOriginData.h&quot;
  90 #include &quot;SecurityPolicy.h&quot;
  91 #include &quot;Settings.h&quot;
  92 #include &quot;ShadowRoot.h&quot;
  93 #include &quot;TimeRanges.h&quot;
  94 #include &quot;UserContentController.h&quot;
  95 #include &quot;UserGestureIndicator.h&quot;
  96 #include &quot;VideoPlaybackQuality.h&quot;
</pre>
<hr />
<pre>
 112 #include &quot;InbandGenericTextTrack.h&quot;
 113 #include &quot;InbandTextTrackPrivate.h&quot;
 114 #include &quot;InbandWebVTTTextTrack.h&quot;
 115 #include &quot;RuntimeEnabledFeatures.h&quot;
 116 #include &quot;TextTrackCueList.h&quot;
 117 #include &quot;TextTrackList.h&quot;
 118 #include &quot;VideoTrackList.h&quot;
 119 #endif
 120 
 121 #if ENABLE(WEB_AUDIO)
 122 #include &quot;AudioSourceProvider.h&quot;
 123 #include &quot;MediaElementAudioSourceNode.h&quot;
 124 #endif
 125 
 126 #if PLATFORM(IOS_FAMILY)
 127 #include &quot;RuntimeApplicationChecks.h&quot;
 128 #include &quot;VideoFullscreenInterfaceAVKit.h&quot;
 129 #endif
 130 
 131 #if ENABLE(WIRELESS_PLAYBACK_TARGET)

 132 #include &quot;WebKitPlaybackTargetAvailabilityEvent.h&quot;
 133 #endif
 134 
 135 #if ENABLE(MEDIA_SESSION)
 136 #include &quot;MediaSession.h&quot;
 137 #endif
 138 
 139 #if ENABLE(MEDIA_SOURCE)
 140 #include &quot;DOMWindow.h&quot;
 141 #include &quot;MediaSource.h&quot;
 142 #endif
 143 
 144 #if ENABLE(MEDIA_STREAM)
 145 #include &quot;DOMURL.h&quot;
 146 #include &quot;MediaStream.h&quot;
 147 #endif
 148 
 149 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 150 #include &quot;WebKitMediaKeyNeededEvent.h&quot;
 151 #include &quot;WebKitMediaKeys.h&quot;
</pre>
<hr />
<pre>
 254     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
 255     return values[static_cast&lt;size_t&gt;(enumerationValue)];
 256 }
 257 
 258 String convertEnumerationToString(HTMLMediaElement::AutoplayEventPlaybackState enumerationValue)
 259 {
 260     static const NeverDestroyed&lt;String&gt; values[] = {
 261         MAKE_STATIC_STRING_IMPL(&quot;None&quot;),
 262         MAKE_STATIC_STRING_IMPL(&quot;PreventedAutoplay&quot;),
 263         MAKE_STATIC_STRING_IMPL(&quot;StartedWithUserGesture&quot;),
 264         MAKE_STATIC_STRING_IMPL(&quot;StartedWithoutUserGesture&quot;),
 265     };
 266     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::None) == 0, &quot;AutoplayEventPlaybackState::None is not 0 as expected&quot;);
 267     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::PreventedAutoplay) == 1, &quot;AutoplayEventPlaybackState::PreventedAutoplay is not 1 as expected&quot;);
 268     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::StartedWithUserGesture) == 2, &quot;AutoplayEventPlaybackState::StartedWithUserGesture is not 2 as expected&quot;);
 269     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::StartedWithoutUserGesture) == 3, &quot;AutoplayEventPlaybackState::StartedWithoutUserGesture is not 3 as expected&quot;);
 270     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
 271     return values[static_cast&lt;size_t&gt;(enumerationValue)];
 272 }
 273 
<span class="line-removed"> 274 typedef HashMap&lt;Document*, HashSet&lt;HTMLMediaElement*&gt;&gt; DocumentElementSetMap;</span>
<span class="line-removed"> 275 static DocumentElementSetMap&amp; documentToElementSetMap()</span>
<span class="line-removed"> 276 {</span>
<span class="line-removed"> 277     static NeverDestroyed&lt;DocumentElementSetMap&gt; map;</span>
<span class="line-removed"> 278     return map;</span>
<span class="line-removed"> 279 }</span>
<span class="line-removed"> 280 </span>
<span class="line-removed"> 281 static void addElementToDocumentMap(HTMLMediaElement&amp; element, Document&amp; document)</span>
<span class="line-removed"> 282 {</span>
<span class="line-removed"> 283     DocumentElementSetMap&amp; map = documentToElementSetMap();</span>
<span class="line-removed"> 284     HashSet&lt;HTMLMediaElement*&gt; set = map.take(&amp;document);</span>
<span class="line-removed"> 285     set.add(&amp;element);</span>
<span class="line-removed"> 286     map.add(&amp;document, set);</span>
<span class="line-removed"> 287 }</span>
<span class="line-removed"> 288 </span>
<span class="line-removed"> 289 static void removeElementFromDocumentMap(HTMLMediaElement&amp; element, Document&amp; document)</span>
<span class="line-removed"> 290 {</span>
<span class="line-removed"> 291     DocumentElementSetMap&amp; map = documentToElementSetMap();</span>
<span class="line-removed"> 292     HashSet&lt;HTMLMediaElement*&gt; set = map.take(&amp;document);</span>
<span class="line-removed"> 293     set.remove(&amp;element);</span>
<span class="line-removed"> 294     if (!set.isEmpty())</span>
<span class="line-removed"> 295         map.add(&amp;document, set);</span>
<span class="line-removed"> 296 }</span>
<span class="line-removed"> 297 </span>
 298 #if ENABLE(VIDEO_TRACK)
 299 
 300 class TrackDisplayUpdateScope {
 301 public:
 302     TrackDisplayUpdateScope(HTMLMediaElement&amp; element)
 303         : m_element(element)
 304     {
 305         m_element.beginIgnoringTrackDisplayUpdateRequests();
 306     }
 307     ~TrackDisplayUpdateScope()
 308     {
 309         m_element.endIgnoringTrackDisplayUpdateRequests();
 310     }
 311 
 312 private:
 313     HTMLMediaElement&amp; m_element;
 314 };
 315 
<span class="line-removed"> 316 #endif</span>
 317 
 318 struct HTMLMediaElement::TrackGroup {
 319     enum GroupKind { CaptionsAndSubtitles, Description, Chapter, Metadata, Other };
 320 
 321     TrackGroup(GroupKind kind)
 322         : kind(kind)
 323     {
 324     }
 325 
 326     Vector&lt;RefPtr&lt;TextTrack&gt;&gt; tracks;
 327     RefPtr&lt;TextTrack&gt; visibleTrack;
 328     RefPtr&lt;TextTrack&gt; defaultTrack;
 329     GroupKind kind;
 330     bool hasSrcLang { false };
 331 };

 332 
 333 HashSet&lt;HTMLMediaElement*&gt;&amp; HTMLMediaElement::allMediaElements()
 334 {
 335     static NeverDestroyed&lt;HashSet&lt;HTMLMediaElement*&gt;&gt; elements;
 336     return elements;
 337 }
 338 
 339 #if ENABLE(MEDIA_SESSION)
 340 typedef HashMap&lt;uint64_t, HTMLMediaElement*&gt; IDToElementMap;
 341 
 342 static IDToElementMap&amp; elementIDsToElements()
 343 {
 344     static NeverDestroyed&lt;IDToElementMap&gt; map;
 345     return map;
 346 }
 347 
 348 HTMLMediaElement* HTMLMediaElement::elementWithID(uint64_t id)
 349 {
 350     if (id == HTMLMediaElementInvalidID)
 351         return nullptr;
</pre>
<hr />
<pre>
 409 
 410     if (!session.isVisibleInViewportOrFullscreen)
 411         return false;
 412 
 413     if (!session.isLargeEnoughForMainContent)
 414         return false;
 415 
 416     // Even if this video is not a candidate, if it is visible to the user and large enough
 417     // to be main content, it poses a risk for being confused with main content.
 418     return true;
 419 }
 420 
 421 HTMLMediaElement::HTMLMediaElement(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
 422     : HTMLElement(tagName, document)
 423     , ActiveDOMObject(document)
 424     , m_progressEventTimer(*this, &amp;HTMLMediaElement::progressEventTimerFired)
 425     , m_playbackProgressTimer(*this, &amp;HTMLMediaElement::playbackProgressTimerFired)
 426     , m_scanTimer(*this, &amp;HTMLMediaElement::scanTimerFired)
 427     , m_playbackControlsManagerBehaviorRestrictionsTimer(*this, &amp;HTMLMediaElement::playbackControlsManagerBehaviorRestrictionsTimerFired)
 428     , m_seekToPlaybackPositionEndedTimer(*this, &amp;HTMLMediaElement::seekToPlaybackPositionEndedTimerFired)
<span class="line-modified"> 429     , m_asyncEventQueue(*this)</span>

 430     , m_lastTimeUpdateEventMovieTime(MediaTime::positiveInfiniteTime())
 431     , m_firstTimePlaying(true)
 432     , m_playing(false)
 433     , m_isWaitingUntilMediaCanStart(false)
 434     , m_shouldDelayLoadEvent(false)
 435     , m_haveFiredLoadedData(false)
 436     , m_inActiveDocument(true)
 437     , m_autoplaying(true)
 438     , m_muted(false)
 439     , m_explicitlyMuted(false)
 440     , m_initiallyMuted(false)
 441     , m_paused(true)
 442     , m_seeking(false)
 443     , m_seekRequested(false)
 444     , m_sentStalledEvent(false)
 445     , m_sentEndEvent(false)
 446     , m_pausedInternal(false)
 447     , m_closedCaptionsVisible(false)
 448     , m_webkitLegacyClosedCaptionOverride(false)
 449     , m_completelyLoaded(false)
 450     , m_havePreparedToPlay(false)
 451     , m_parsingInProgress(createdByParser)
 452     , m_elementIsHidden(document.hidden())
 453     , m_creatingControls(false)
 454     , m_receivedLayoutSizeChanged(false)
 455     , m_hasEverNotifiedAboutPlaying(false)
 456     , m_hasEverHadAudio(false)
 457     , m_hasEverHadVideo(false)
 458 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 459     , m_mediaControlsDependOnPageScaleFactor(false)
 460     , m_haveSetUpCaptionContainer(false)
 461 #endif
 462     , m_isScrubbingRemotely(false)
 463 #if ENABLE(VIDEO_TRACK)
 464     , m_tracksAreReady(true)
 465     , m_haveVisibleTextTrack(false)
 466     , m_processingPreferenceChange(false)
 467 #endif



 468 #if !RELEASE_LOG_DISABLED
 469     , m_logger(&amp;document.logger())
 470     , m_logIdentifier(uniqueLogIdentifier())
 471 #endif
 472 {
 473     allMediaElements().add(this);
 474 
 475     ALWAYS_LOG(LOGIDENTIFIER);
 476 
 477     setHasCustomStyleResolveCallbacks();
 478 
 479     InspectorInstrumentation::addEventListenersToNode(*this);
 480 }
 481 
 482 void HTMLMediaElement::finishInitialization()
 483 {
 484     m_mediaSession = makeUnique&lt;MediaElementSession&gt;(*this);
 485 
 486     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForFullscreen);
 487     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToLoadMedia);
</pre>
<hr />
<pre>
 503         const bool shouldAudioPlaybackRequireUserGesture = topDocument.audioPlaybackRequiresUserGesture() &amp;&amp; !isProcessingUserGesture;
 504         const bool shouldVideoPlaybackRequireUserGesture = topDocument.videoPlaybackRequiresUserGesture() &amp;&amp; !isProcessingUserGesture;
 505 
 506         if (shouldVideoPlaybackRequireUserGesture) {
 507             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoRateChange);
 508             if (document.settings().requiresUserGestureToLoadVideo())
 509                 m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForLoad);
 510         }
 511 
 512         if (page &amp;&amp; page-&gt;isLowPowerModeEnabled())
 513             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoDueToLowPowerMode);
 514 
 515         if (shouldAudioPlaybackRequireUserGesture)
 516             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForAudioRateChange);
 517 
 518 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 519         if (shouldVideoPlaybackRequireUserGesture || shouldAudioPlaybackRequireUserGesture)
 520             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToShowPlaybackTargetPicker);
 521 #endif
 522 
<span class="line-modified"> 523         if (!document.settings().mediaDataLoadsAutomatically())</span>
 524             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::AutoPreloadingNotPermitted);
 525 
 526         if (document.settings().mainContentUserGestureOverrideEnabled())
 527             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::OverrideUserGestureRequirementForMainContent);
 528     }
 529 
 530 #if PLATFORM(IOS_FAMILY)
 531     if (!document.settings().videoPlaybackRequiresUserGesture() &amp;&amp; !document.settings().audioPlaybackRequiresUserGesture()) {
 532         // Relax RequireUserGestureForFullscreen when videoPlaybackRequiresUserGesture and audioPlaybackRequiresUserGesture is not set:
 533         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureForFullscreen);
 534     }
 535 #endif
 536 
 537 #if ENABLE(MEDIA_SESSION)
 538     m_elementID = nextElementID();
 539     elementIDsToElements().add(m_elementID, this);
 540 
 541     setSessionInternal(document.defaultMediaSession());
 542 #endif
 543 
 544     registerWithDocument(document);
 545 
 546 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 547     AudioSession::sharedSession().addMutedStateObserver(this);
 548 #endif
 549 
 550     mediaSession().clientWillBeginAutoplaying();
 551 }
 552 
<span class="line-removed"> 553 // FIXME: Remove this code once https://webkit.org/b/185284 is fixed.</span>
<span class="line-removed"> 554 static unsigned s_destructorCount = 0;</span>
<span class="line-removed"> 555 </span>
<span class="line-removed"> 556 bool HTMLMediaElement::isRunningDestructor()</span>
<span class="line-removed"> 557 {</span>
<span class="line-removed"> 558     return !!s_destructorCount;</span>
<span class="line-removed"> 559 }</span>
<span class="line-removed"> 560 </span>
<span class="line-removed"> 561 class HTMLMediaElementDestructorScope {</span>
<span class="line-removed"> 562 public:</span>
<span class="line-removed"> 563     HTMLMediaElementDestructorScope() { ++s_destructorCount; }</span>
<span class="line-removed"> 564     ~HTMLMediaElementDestructorScope() { --s_destructorCount; }</span>
<span class="line-removed"> 565 };</span>
<span class="line-removed"> 566 </span>
 567 HTMLMediaElement::~HTMLMediaElement()
 568 {
<span class="line-removed"> 569     HTMLMediaElementDestructorScope destructorScope;</span>
 570     ALWAYS_LOG(LOGIDENTIFIER);
 571 
 572     beginIgnoringTrackDisplayUpdateRequests();
 573     allMediaElements().remove(this);
 574 
<span class="line-modified"> 575     m_asyncEventQueue.close();</span>
 576 
 577     setShouldDelayLoadEvent(false);
 578     unregisterWithDocument(document());
 579 
 580 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 581     AudioSession::sharedSession().removeMutedStateObserver(this);
 582 #endif
 583 
 584 #if ENABLE(VIDEO_TRACK)
 585     if (m_audioTracks)
 586         m_audioTracks-&gt;clearElement();
 587     if (m_textTracks)
 588         m_textTracks-&gt;clearElement();
 589     if (m_videoTracks)
 590         m_videoTracks-&gt;clearElement();
 591 #endif
 592 
 593 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified"> 594     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent)) {</span>
 595         m_hasPlaybackTargetAvailabilityListeners = false;
 596         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
 597         updateMediaState();
 598     }
 599 #endif
 600 
 601     if (m_mediaController) {
 602         m_mediaController-&gt;removeMediaElement(*this);
 603         m_mediaController = nullptr;
 604     }
 605 
 606 #if ENABLE(MEDIA_SOURCE)
 607     detachMediaSource();
 608 #endif
 609 
 610 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 611     webkitSetMediaKeys(nullptr);
 612 #endif
 613 
 614 #if ENABLE(ENCRYPTED_MEDIA)
</pre>
<hr />
<pre>
 664         auto mediaElementSessionInfo = mediaElementSessionInfoForSession(downcast&lt;MediaElementSession&gt;(session), purpose);
 665         if (mediaElementSessionInfo.canShowControlsManager)
 666             candidateSessions.append(mediaElementSessionInfo);
 667         else if (mediaSessionMayBeConfusedWithMainContent(mediaElementSessionInfo, purpose))
 668             atLeastOneNonCandidateMayBeConfusedForMainContent = true;
 669     });
 670 
 671     if (!candidateSessions.size())
 672         return nullptr;
 673 
 674     std::sort(candidateSessions.begin(), candidateSessions.end(), preferMediaControlsForCandidateSessionOverOtherCandidateSession);
 675     auto strongestSessionCandidate = candidateSessions.first();
 676     if (!strongestSessionCandidate.isVisibleInViewportOrFullscreen &amp;&amp; !strongestSessionCandidate.isPlayingAudio &amp;&amp; atLeastOneNonCandidateMayBeConfusedForMainContent)
 677         return nullptr;
 678 
 679     return &amp;strongestSessionCandidate.session-&gt;element();
 680 }
 681 
 682 void HTMLMediaElement::registerWithDocument(Document&amp; document)
 683 {


 684     m_mediaSession-&gt;registerWithDocument(document);
 685 
 686     if (m_isWaitingUntilMediaCanStart)
 687         document.addMediaCanStartListener(*this);
 688 
<span class="line-removed"> 689 #if !PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 690     document.registerForMediaVolumeCallbacks(*this);</span>
<span class="line-removed"> 691     document.registerForPrivateBrowsingStateChangedCallbacks(*this);</span>
<span class="line-removed"> 692 #endif</span>
<span class="line-removed"> 693 </span>
 694     document.registerForVisibilityStateChangedCallbacks(*this);
 695 
 696 #if ENABLE(VIDEO_TRACK)
 697     if (m_requireCaptionPreferencesChangedCallbacks)
 698         document.registerForCaptionPreferencesChangedCallbacks(*this);
 699 #endif
 700 
<span class="line-removed"> 701 #if ENABLE(MEDIA_CONTROLS_SCRIPT)</span>
<span class="line-removed"> 702     if (m_mediaControlsDependOnPageScaleFactor)</span>
<span class="line-removed"> 703         document.registerForPageScaleFactorChangedCallbacks(*this);</span>
<span class="line-removed"> 704     document.registerForUserInterfaceLayoutDirectionChangedCallbacks(*this);</span>
<span class="line-removed"> 705 #endif</span>
<span class="line-removed"> 706 </span>
 707 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 708     document.registerForDocumentSuspensionCallbacks(*this);
 709 #endif
 710 
<span class="line-removed"> 711     document.registerForAllowsMediaDocumentInlinePlaybackChangedCallbacks(*this);</span>
<span class="line-removed"> 712 </span>
 713     document.addAudioProducer(*this);
<span class="line-removed"> 714     addElementToDocumentMap(*this, document);</span>
<span class="line-removed"> 715 </span>
<span class="line-removed"> 716 #if ENABLE(MEDIA_STREAM)</span>
<span class="line-removed"> 717     document.registerForMediaStreamStateChangeCallbacks(*this);</span>
<span class="line-removed"> 718 #endif</span>
<span class="line-removed"> 719 </span>
<span class="line-removed"> 720     document.addApplicationStateChangeListener(*this);</span>
 721 }
 722 
 723 void HTMLMediaElement::unregisterWithDocument(Document&amp; document)
 724 {


 725     m_mediaSession-&gt;unregisterWithDocument(document);
 726 
 727     if (m_isWaitingUntilMediaCanStart)
 728         document.removeMediaCanStartListener(*this);
 729 
<span class="line-removed"> 730 #if !PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 731     document.unregisterForMediaVolumeCallbacks(*this);</span>
<span class="line-removed"> 732     document.unregisterForPrivateBrowsingStateChangedCallbacks(*this);</span>
<span class="line-removed"> 733 #endif</span>
<span class="line-removed"> 734 </span>
 735     document.unregisterForVisibilityStateChangedCallbacks(*this);
 736 
 737 #if ENABLE(VIDEO_TRACK)
 738     if (m_requireCaptionPreferencesChangedCallbacks)
 739         document.unregisterForCaptionPreferencesChangedCallbacks(*this);
 740 #endif
 741 
<span class="line-removed"> 742 #if ENABLE(MEDIA_CONTROLS_SCRIPT)</span>
<span class="line-removed"> 743     if (m_mediaControlsDependOnPageScaleFactor)</span>
<span class="line-removed"> 744         document.unregisterForPageScaleFactorChangedCallbacks(*this);</span>
<span class="line-removed"> 745     document.unregisterForUserInterfaceLayoutDirectionChangedCallbacks(*this);</span>
<span class="line-removed"> 746 #endif</span>
<span class="line-removed"> 747 </span>
 748 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 749     document.unregisterForDocumentSuspensionCallbacks(*this);
 750 #endif
 751 
<span class="line-removed"> 752     document.unregisterForAllowsMediaDocumentInlinePlaybackChangedCallbacks(*this);</span>
<span class="line-removed"> 753 </span>
 754     document.removeAudioProducer(*this);
<span class="line-removed"> 755     removeElementFromDocumentMap(*this, document);</span>
<span class="line-removed"> 756 </span>
<span class="line-removed"> 757 #if ENABLE(MEDIA_STREAM)</span>
<span class="line-removed"> 758     document.unregisterForMediaStreamStateChangeCallbacks(*this);</span>
<span class="line-removed"> 759 #endif</span>
<span class="line-removed"> 760 </span>
<span class="line-removed"> 761     document.removeApplicationStateChangeListener(*this);</span>
 762 }
 763 
 764 void HTMLMediaElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
 765 {
 766     ASSERT_WITH_SECURITY_IMPLICATION(&amp;document() == &amp;newDocument);
 767     if (m_shouldDelayLoadEvent) {
 768         oldDocument.decrementLoadEventDelayCount();
 769         newDocument.incrementLoadEventDelayCount();
 770     }
 771 
 772     unregisterWithDocument(oldDocument);
 773     registerWithDocument(newDocument);
 774 
 775     HTMLElement::didMoveToNewDocument(oldDocument, newDocument);
 776     updateShouldAutoplay();
 777 }
 778 
 779 #if ENABLE(WIRELESS_PLAYBACK_TARGET)

 780 void HTMLMediaElement::prepareForDocumentSuspension()
 781 {
 782     m_mediaSession-&gt;unregisterWithDocument(document());
 783 }
 784 
 785 void HTMLMediaElement::resumeFromDocumentSuspension()
 786 {
 787     m_mediaSession-&gt;registerWithDocument(document());
 788     updateShouldAutoplay();
 789 }

 790 #endif
 791 
 792 bool HTMLMediaElement::supportsFocus() const
 793 {
 794     if (document().isMediaDocument())
 795         return false;
 796 
 797     // If no controls specified, we should still be able to focus the element if it has tabIndex.
 798     return controls() ||  HTMLElement::supportsFocus();
 799 }
 800 
 801 bool HTMLMediaElement::isMouseFocusable() const
 802 {
 803     return false;
 804 }
 805 
 806 bool HTMLMediaElement::isInteractiveContent() const
 807 {
 808     return controls();
 809 }
 810 
 811 void HTMLMediaElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 812 {
 813     if (name == srcAttr) {
 814         // https://html.spec.whatwg.org/multipage/embedded-content.html#location-of-the-media-resource
 815         // Location of the Media Resource
 816         // 12 February 2017
 817 
 818         // If a src attribute of a media element is set or changed, the user
 819         // agent must invoke the media element&#39;s media element load algorithm.
 820         if (!value.isNull())
 821             prepareForLoad();
 822     } else if (name == controlsAttr)
 823         configureMediaControls();
 824     else if (name == loopAttr)
 825         updateSleepDisabling();
 826     else if (name == preloadAttr) {
 827         if (equalLettersIgnoringASCIICase(value, &quot;none&quot;))
<span class="line-modified"> 828             m_preload = MediaPlayer::None;</span>
 829         else if (equalLettersIgnoringASCIICase(value, &quot;metadata&quot;))
<span class="line-modified"> 830             m_preload = MediaPlayer::MetaData;</span>
 831         else {
 832             // The spec does not define an &quot;invalid value default&quot; but &quot;auto&quot; is suggested as the
 833             // &quot;missing value default&quot;, so use it for everything except &quot;none&quot; and &quot;metadata&quot;
<span class="line-modified"> 834             m_preload = MediaPlayer::Auto;</span>
 835         }
 836 
 837         // The attribute must be ignored if the autoplay attribute is present
 838         if (!autoplay() &amp;&amp; !m_havePreparedToPlay &amp;&amp; m_player)
 839             m_player-&gt;setPreload(m_mediaSession-&gt;effectivePreloadForElement());
 840 
 841     } else if (name == mediagroupAttr)
 842         setMediaGroup(value);
 843     else if (name == autoplayAttr) {
 844         if (processingUserGestureForMedia())
 845             removeBehaviorRestrictionsAfterFirstUserGesture();
 846     } else if (name == titleAttr) {
 847         if (m_mediaSession)
 848             m_mediaSession-&gt;clientCharacteristicsChanged();
 849     }
 850     else
 851         HTMLElement::parseAttribute(name, value);
 852 }
 853 
 854 void HTMLMediaElement::finishParsingChildren()
</pre>
<hr />
<pre>
 955     if (removalType.disconnectedFromDocument) {
 956         // Pause asynchronously to let the operation that removed us finish, in case we get inserted back into a document.
 957         m_pauseAfterDetachedTaskQueue.enqueueTask(std::bind(&amp;HTMLMediaElement::pauseAfterDetachedTask, this));
 958     }
 959 
 960     if (m_mediaSession)
 961         m_mediaSession-&gt;clientCharacteristicsChanged();
 962 
 963     HTMLElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
 964 }
 965 
 966 void HTMLMediaElement::willAttachRenderers()
 967 {
 968     ASSERT(!renderer());
 969 }
 970 
 971 inline void HTMLMediaElement::updateRenderer()
 972 {
 973     if (auto* renderer = this-&gt;renderer())
 974         renderer-&gt;updateFromElement();





 975 }
 976 
 977 void HTMLMediaElement::didAttachRenderers()
 978 {
 979     if (auto* renderer = this-&gt;renderer()) {
 980         renderer-&gt;updateFromElement();
 981         if (m_mediaSession &amp;&amp; m_mediaSession-&gt;wantsToObserveViewportVisibilityForAutoplay())
 982             renderer-&gt;registerForVisibleInViewportCallback();
 983     }
 984     updateShouldAutoplay();
 985 }
 986 
 987 void HTMLMediaElement::willDetachRenderers()
 988 {
 989     if (auto* renderer = this-&gt;renderer())
 990         renderer-&gt;unregisterForVisibleInViewportCallback();
 991 }
 992 
 993 void HTMLMediaElement::didDetachRenderers()
 994 {
 995     updateShouldAutoplay();
 996 }
 997 
 998 void HTMLMediaElement::didRecalcStyle(Style::Change)
 999 {
1000     updateRenderer();
1001 }
1002 
1003 void HTMLMediaElement::scheduleNextSourceChild()
1004 {
1005     // Schedule the timer to try the next &lt;source&gt; element WITHOUT resetting state ala prepareForLoad.
1006     m_resourceSelectionTaskQueue.enqueueTask([this] {
1007         loadNextSourceChild();
1008     });
1009 }
1010 
<span class="line-modified">1011 void HTMLMediaElement::mediaPlayerActiveSourceBuffersChanged(const MediaPlayer*)</span>
1012 {
1013     m_hasEverHadAudio |= hasAudio();
1014     m_hasEverHadVideo |= hasVideo();
1015 }
1016 
1017 void HTMLMediaElement::scheduleEvent(const AtomString&amp; eventName)
1018 {
1019     auto event = Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::Yes);
1020 
1021     // Don&#39;t set the event target, the event queue will set it in GenericEventQueue::timerFired and setting it here
1022     // will trigger an ASSERT if this element has been marked for deletion.
1023 
<span class="line-modified">1024     m_asyncEventQueue.enqueueEvent(WTFMove(event));</span>






1025 }

1026 
1027 void HTMLMediaElement::scheduleResolvePendingPlayPromises()
1028 {
1029     m_promiseTaskQueue.enqueueTask([this, pendingPlayPromises = WTFMove(m_pendingPlayPromises)] () mutable {
1030         resolvePendingPlayPromises(WTFMove(pendingPlayPromises));
1031     });
1032 }
1033 
1034 void HTMLMediaElement::scheduleRejectPendingPlayPromises(Ref&lt;DOMException&gt;&amp;&amp; error)
1035 {
1036     m_promiseTaskQueue.enqueueTask([this, error = WTFMove(error), pendingPlayPromises = WTFMove(m_pendingPlayPromises)] () mutable {
1037         rejectPendingPlayPromises(WTFMove(pendingPlayPromises), WTFMove(error));
1038     });
1039 }
1040 
1041 void HTMLMediaElement::rejectPendingPlayPromises(PlayPromiseVector&amp;&amp; pendingPlayPromises, Ref&lt;DOMException&gt;&amp;&amp; error)
1042 {
1043     for (auto&amp; promise : pendingPlayPromises)
1044         promise.rejectType&lt;IDLInterface&lt;DOMException&gt;&gt;(error);
1045 }
</pre>
<hr />
<pre>
1135     return parseCORSSettingsAttribute(attributeWithoutSynchronization(crossoriginAttr));
1136 }
1137 
1138 HTMLMediaElement::NetworkState HTMLMediaElement::networkState() const
1139 {
1140     return m_networkState;
1141 }
1142 
1143 String HTMLMediaElement::canPlayType(const String&amp; mimeType) const
1144 {
1145     MediaEngineSupportParameters parameters;
1146     ContentType contentType(mimeType);
1147     parameters.type = contentType;
1148     parameters.contentTypesRequiringHardwareSupport = mediaContentTypesRequiringHardwareSupport();
1149     MediaPlayer::SupportsType support = MediaPlayer::supportsType(parameters);
1150     String canPlay;
1151 
1152     // 4.8.10.3
1153     switch (support)
1154     {
<span class="line-modified">1155         case MediaPlayer::IsNotSupported:</span>
1156             canPlay = emptyString();
1157             break;
<span class="line-modified">1158         case MediaPlayer::MayBeSupported:</span>
1159             canPlay = &quot;maybe&quot;_s;
1160             break;
<span class="line-modified">1161         case MediaPlayer::IsSupported:</span>
1162             canPlay = &quot;probably&quot;_s;
1163             break;
1164     }
1165 
1166     INFO_LOG(LOGIDENTIFIER, mimeType, &quot;: &quot;, canPlay);
1167 
1168     return canPlay;
1169 }
1170 
1171 double HTMLMediaElement::getStartDate() const
1172 {
1173     if (!m_player)
1174         return std::numeric_limits&lt;double&gt;::quiet_NaN();
1175     return m_player-&gt;getStartDate().toDouble();
1176 }
1177 
1178 void HTMLMediaElement::load()
1179 {
1180     Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // prepareForLoad may result in a &#39;beforeload&#39; event, which can make arbitrary DOM mutations.
1181 
</pre>
<hr />
<pre>
1229     cancelPendingEventsAndCallbacks();
1230 
1231     // 5 - If the media element&#39;s networkState is set to NETWORK_LOADING or NETWORK_IDLE, queue
1232     // a task to fire a simple event named abort at the media element.
1233     if (m_networkState == NETWORK_LOADING || m_networkState == NETWORK_IDLE)
1234         scheduleEvent(eventNames().abortEvent);
1235 
1236     // 6 - If the media element&#39;s networkState is not set to NETWORK_EMPTY, then run these substeps
1237     if (m_networkState != NETWORK_EMPTY) {
1238         // 6.1 - Queue a task to fire a simple event named emptied at the media element.
1239         scheduleEvent(eventNames().emptiedEvent);
1240 
1241         // 6.2 - If a fetching process is in progress for the media element, the user agent should stop it.
1242         m_networkState = NETWORK_EMPTY;
1243 
1244         // 6.3 - If the media element’s assigned media provider object is a MediaSource object, then detach it.
1245 #if ENABLE(MEDIA_SOURCE)
1246         detachMediaSource();
1247 #endif
1248 

1249         // 6.4 - Forget the media element&#39;s media-resource-specific tracks.
1250         forgetResourceSpecificTracks();

1251 
1252         // 6.5 - If readyState is not set to HAVE_NOTHING, then set it to that state.
1253         m_readyState = HAVE_NOTHING;
1254         m_readyStateMaximum = HAVE_NOTHING;
1255 
1256         // 6.6 - If the paused attribute is false, then set it to true.
1257         m_paused = true;
1258 
1259         // 6.7 - If seeking is true, set it to false.
1260         clearSeeking();
1261 
1262         // 6.8 - Set the current playback position to 0.
1263         //       Set the official playback position to 0.
1264         //       If this changed the official playback position, then queue a task to fire a simple event named timeupdate at the media element.
1265         m_lastSeekTime = MediaTime::zeroTime();
1266         m_playedTimeRanges = TimeRanges::create();
1267         // FIXME: Add support for firing this event. e.g., scheduleEvent(eventNames().timeUpdateEvent);
1268 
1269         // 4.9 - Set the initial playback position to 0.
1270         // FIXME: Make this less subtle. The position only becomes 0 because of the createMediaPlayer() call
</pre>
<hr />
<pre>
1426             //    If that algorithm returns without aborting this one, then the load failed.
1427             // 4. Failed with media provider: Reaching this step indicates that the media resource
1428             //    failed to load. Queue a task to run the dedicated media source failure steps.
1429             // 5. Wait for the task queued by the previous step to have executed.
1430             // 6. Abort these steps. The element won’t attempt to load another resource until this
1431             //    algorithm is triggered again.
1432             return;
1433         }
1434 
1435         // ↳ If mode is attribute
1436         if (mode == Attribute) {
1437             m_loadState = LoadingFromSrcAttr;
1438 
1439             // 1. If the src attribute’s value is the empty string, then end the synchronous section,
1440             //    and jump down to the failed with attribute step below.
1441             // 2. Let absolute URL be the absolute URL that would have resulted from parsing the URL
1442             //    specified by the src attribute’s value relative to the media element when the src
1443             //    attribute was last changed.
1444             URL absoluteURL = getNonEmptyURLAttribute(srcAttr);
1445             if (absoluteURL.isEmpty()) {
<span class="line-modified">1446                 mediaLoadingFailed(MediaPlayer::FormatError);</span>
1447                 ALWAYS_LOG(logSiteIdentifier, &quot;empty &#39;src&#39;&quot;);
1448                 return;
1449             }
1450 
1451             if (!isSafeToLoadURL(absoluteURL, Complain) || !dispatchBeforeLoadEvent(absoluteURL.string())) {
<span class="line-modified">1452                 mediaLoadingFailed(MediaPlayer::FormatError);</span>
1453                 return;
1454             }
1455 
1456             // 3. If absolute URL was obtained successfully, set the currentSrc attribute to absolute URL.
1457             m_currentSrc = absoluteURL;
1458 
1459             // 4. End the synchronous section, continuing the remaining steps in parallel.
1460             // 5. If absolute URL was obtained successfully, run the resource fetch algorithm with absolute
1461             //    URL. If that algorithm returns without aborting this one, then the load failed.
1462 
1463             // No type or key system information is available when the url comes
1464             // from the &#39;src&#39; attribute so MediaPlayer
1465             // will have to pick a media engine based on the file extension.
1466             ContentType contentType;
1467             loadResource(absoluteURL, contentType, String());
1468             ALWAYS_LOG(logSiteIdentifier, &quot;using &#39;src&#39; attribute url&quot;);
1469 
1470             // 6. Failed with attribute: Reaching this step indicates that the media resource failed to load
1471             //    or that the given URL could not be resolved. Queue a task to run the dedicated media source failure steps.
1472             // 7. Wait for the task queued by the previous step to have executed.
</pre>
<hr />
<pre>
1488     if (!mediaURL.isValid()) {
1489         waitForSourceChange();
1490         return;
1491     }
1492 
1493     // Recreate the media player for the new url
1494     createMediaPlayer();
1495 
1496     m_loadState = LoadingFromSourceElement;
1497     loadResource(mediaURL, contentType, keySystem);
1498 }
1499 
1500 void HTMLMediaElement::loadResource(const URL&amp; initialURL, ContentType&amp; contentType, const String&amp; keySystem)
1501 {
1502     ASSERT(initialURL.isEmpty() || isSafeToLoadURL(initialURL, Complain));
1503 
1504     INFO_LOG(LOGIDENTIFIER, initialURL, contentType, keySystem);
1505 
1506     RefPtr&lt;Frame&gt; frame = document().frame();
1507     if (!frame) {
<span class="line-modified">1508         mediaLoadingFailed(MediaPlayer::FormatError);</span>
1509         return;
1510     }
1511 
1512     Page* page = frame-&gt;page();
1513     if (!page) {
<span class="line-modified">1514         mediaLoadingFailed(MediaPlayer::FormatError);</span>
1515         return;
1516     }
1517 
1518     URL url = initialURL;
1519     if (!url.isEmpty() &amp;&amp; !frame-&gt;loader().willLoadMediaElementURL(url, *this)) {
<span class="line-modified">1520         mediaLoadingFailed(MediaPlayer::FormatError);</span>
1521         return;
1522     }
1523 
1524 #if ENABLE(CONTENT_EXTENSIONS)
1525     if (auto documentLoader = makeRefPtr(frame-&gt;loader().documentLoader())) {
1526         if (page-&gt;userContentProvider().processContentRuleListsForLoad(url, ContentExtensions::ResourceType::Media, *documentLoader).summary.blockedLoad) {
<span class="line-modified">1527             mediaLoadingFailed(MediaPlayer::FormatError);</span>
1528             return;
1529         }
1530     }
1531 #endif
1532 
1533     // The resource fetch algorithm
1534     m_networkState = NETWORK_LOADING;
1535 
1536     // If the URL should be loaded from the application cache, pass the URL of the cached file to the media engine.
1537     ApplicationCacheResource* resource = nullptr;
1538     if (!url.isEmpty() &amp;&amp; frame-&gt;loader().documentLoader()-&gt;applicationCacheHost().shouldLoadResourceFromApplicationCache(ResourceRequest(url), resource)) {
1539         // Resources that are not present in the manifest will always fail to load (at least, after the
1540         // cache has been primed the first time), making the testing of offline applications simpler.
1541         if (!resource || resource-&gt;path().isEmpty()) {
<span class="line-modified">1542             mediaLoadingFailed(MediaPlayer::NetworkError);</span>
1543             return;
1544         }
1545     }
1546 
1547     // Log that we started loading a media element.
1548     page-&gt;diagnosticLoggingClient().logDiagnosticMessage(isVideo() ? DiagnosticLoggingKeys::videoKey() : DiagnosticLoggingKeys::audioKey(), DiagnosticLoggingKeys::loadingKey(), ShouldSample::No);
1549 
1550     m_firstTimePlaying = true;
1551 
1552     // Set m_currentSrc *before* changing to the cache URL, the fact that we are loading from the app
1553     // cache is an internal detail not exposed through the media element API.
1554     m_currentSrc = url;
1555 
1556     if (resource) {
1557         url = ApplicationCacheHost::createFileURL(resource-&gt;path());
1558         INFO_LOG(LOGIDENTIFIER, &quot;will load from app cache &quot;, url);
1559     }
1560 
1561     INFO_LOG(LOGIDENTIFIER, &quot;m_currentSrc is &quot;, m_currentSrc);
1562 
</pre>
<hr />
<pre>
1572         m_player-&gt;setPreload(m_mediaSession-&gt;effectivePreloadForElement());
1573     m_player-&gt;setPreservesPitch(m_webkitPreservesPitch);
1574 
1575     if (!m_explicitlyMuted) {
1576         m_explicitlyMuted = true;
1577         m_muted = hasAttributeWithoutSynchronization(mutedAttr);
1578         m_mediaSession-&gt;canProduceAudioChanged();
1579     }
1580 
1581     updateVolume();
1582 
1583     bool loadAttempted = false;
1584 #if ENABLE(MEDIA_SOURCE)
1585     if (!m_mediaSource &amp;&amp; url.protocolIs(mediaSourceBlobProtocol))
1586         m_mediaSource = MediaSource::lookup(url.string());
1587 
1588     if (m_mediaSource) {
1589         loadAttempted = true;
1590 
1591         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading MSE blob&quot;);
<span class="line-modified">1592         if (!m_mediaSource-&gt;attachToElement(*this) || !m_player-&gt;load(url, contentType, m_mediaSource.get())) {</span>
1593             // Forget our reference to the MediaSource, so we leave it alone
1594             // while processing remainder of load failure.
1595             m_mediaSource = nullptr;
<span class="line-modified">1596             mediaLoadingFailed(MediaPlayer::FormatError);</span>





1597         }
1598     }
1599 #endif
1600 #if ENABLE(MEDIA_STREAM)
1601     if (!loadAttempted &amp;&amp; m_mediaStreamSrcObject) {
1602         loadAttempted = true;
1603         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading media stream blob&quot;);
1604         if (!m_player-&gt;load(m_mediaStreamSrcObject-&gt;privateStream()))
<span class="line-modified">1605             mediaLoadingFailed(MediaPlayer::FormatError);</span>
1606     }
1607 #endif
1608 
1609     if (!loadAttempted &amp;&amp; m_blob) {
1610         loadAttempted = true;
1611         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading generic blob&quot;);
1612         if (!m_player-&gt;load(m_blob-&gt;url(), contentType, keySystem))
<span class="line-modified">1613             mediaLoadingFailed(MediaPlayer::FormatError);</span>
1614     }
1615 
1616     if (!loadAttempted &amp;&amp; !m_player-&gt;load(url, contentType, keySystem))
<span class="line-modified">1617         mediaLoadingFailed(MediaPlayer::FormatError);</span>
1618 
1619     // If there is no poster to display, allow the media engine to render video frames as soon as
1620     // they are available.
1621     updateDisplayState();
1622 
1623     updateRenderer();
1624 }
1625 
1626 #if ENABLE(VIDEO_TRACK)
1627 






1628 static bool trackIndexCompare(TextTrack* a, TextTrack* b)
1629 {
1630     return a-&gt;trackIndex() - b-&gt;trackIndex() &lt; 0;
1631 }
1632 
1633 static bool eventTimeCueCompare(const std::pair&lt;MediaTime, TextTrackCue*&gt;&amp; a, const std::pair&lt;MediaTime, TextTrackCue*&gt;&amp; b)
1634 {
1635     // 12 - Sort the tasks in events in ascending time order (tasks with earlier
1636     // times first).
1637     if (a.first != b.first)
1638         return a.first - b.first &lt; MediaTime::zeroTime();
1639 
1640     // If the cues belong to different text tracks, it doesn&#39;t make sense to
1641     // compare the two tracks by the relative cue order, so return the relative
1642     // track order.
1643     if (a.second-&gt;track() != b.second-&gt;track())
1644         return trackIndexCompare(a.second-&gt;track(), b.second-&gt;track());
1645 
1646     // 12 - Further sort tasks in events that have the same time by the
1647     // relative text track cue order of the text track cues associated
1648     // with these tasks.
1649     return a.second-&gt;isOrderedBefore(b.second);
1650 }
1651 
1652 static bool compareCueInterval(const CueInterval&amp; one, const CueInterval&amp; two)
1653 {
1654     return one.data()-&gt;isOrderedBefore(two.data());
1655 }
1656 
1657 static bool compareCueIntervalEndTime(const CueInterval&amp; one, const CueInterval&amp; two)
1658 {
1659     return one.data()-&gt;endMediaTime() &gt; two.data()-&gt;endMediaTime();
1660 }
1661 





1662 void HTMLMediaElement::updateActiveTextTrackCues(const MediaTime&amp; movieTime)
1663 {
1664     // 4.8.10.8 Playing the media resource
1665 
1666     //  If the current playback position changes while the steps are running,
1667     //  then the user agent must wait for the steps to complete, and then must
1668     //  immediately rerun the steps.
1669     if (ignoreTrackDisplayUpdateRequests())
1670         return;
1671 
1672     // 1 - Let current cues be a list of cues, initialized to contain all the
1673     // cues of all the hidden, showing, or showing by default text tracks of the
1674     // media element (not the disabled ones) whose start times are less than or
1675     // equal to the current playback position and whose end times are greater
1676     // than the current playback position.
1677     CueList currentCues;
1678 
1679     // The user agent must synchronously unset [the text track cue active] flag
1680     // whenever ... the media element&#39;s readyState is changed back to HAVE_NOTHING.
<span class="line-removed">1681     auto movieTimeInterval = m_cueTree.createInterval(movieTime, movieTime);</span>
1682     if (m_readyState != HAVE_NOTHING &amp;&amp; m_player) {
<span class="line-modified">1683         currentCues = m_cueTree.allOverlaps(movieTimeInterval);</span>
1684         if (currentCues.size() &gt; 1)
1685             std::sort(currentCues.begin(), currentCues.end(), &amp;compareCueInterval);
1686     }
1687 
1688     CueList previousCues;
1689     CueList missedCues;
1690 
1691     // 2 - Let other cues be a list of cues, initialized to contain all the cues
1692     // of hidden, showing, and showing by default text tracks of the media
1693     // element that are not present in current cues.
<span class="line-modified">1694     previousCues = m_currentlyActiveCues;</span>
1695 
1696     // 3 - Let last time be the current playback position at the time this
1697     // algorithm was last run for this media element, if this is not the first
1698     // time it has run.
1699     MediaTime lastTime = m_lastTextTrackUpdateTime;
1700 
1701     // 4 - If the current playback position has, since the last time this
1702     // algorithm was run, only changed through its usual monotonic increase
1703     // during normal playback, then let missed cues be the list of cues in other
1704     // cues whose start times are greater than or equal to last time and whose
1705     // end times are less than or equal to the current playback position.
1706     // Otherwise, let missed cues be an empty list.
1707     if (lastTime &gt;= MediaTime::zeroTime() &amp;&amp; m_lastSeekTime &lt; movieTime) {
<span class="line-modified">1708         for (auto&amp; cue : m_cueTree.allOverlaps(m_cueTree.createInterval(lastTime, movieTime))) {</span>
1709             // Consider cues that may have been missed since the last seek time.
1710             if (cue.low() &gt; std::max(m_lastSeekTime, lastTime) &amp;&amp; cue.high() &lt; movieTime)
1711                 missedCues.append(cue);
1712         }
1713     }
1714 
1715     m_lastTextTrackUpdateTime = movieTime;
1716 
1717     // 5 - If the time was reached through the usual monotonic increase of the
1718     // current playback position during normal playback, and if the user agent
1719     // has not fired a timeupdate event at the element in the past 15 to 250ms
1720     // and is not still running event handlers for such an event, then the user
1721     // agent must queue a task to fire a simple event named timeupdate at the
1722     // element. (In the other cases, such as explicit seeks, relevant events get
1723     // fired as part of the overall process of changing the current playback
1724     // position.)
1725     if (!m_paused &amp;&amp; m_lastSeekTime &lt;= lastTime)
1726         scheduleTimeupdateEvent(false);
1727 
1728     // Explicitly cache vector sizes, as their content is constant from here.
1729     size_t currentCuesSize = currentCues.size();
1730     size_t missedCuesSize = missedCues.size();
1731     size_t previousCuesSize = previousCues.size();
1732 
1733     // 6 - If all of the cues in current cues have their text track cue active
1734     // flag set, none of the cues in other cues have their text track cue active
1735     // flag set, and missed cues is empty, then abort these steps.
1736     bool activeSetChanged = missedCuesSize;
1737 
1738     for (size_t i = 0; !activeSetChanged &amp;&amp; i &lt; previousCuesSize; ++i)
1739         if (!currentCues.contains(previousCues[i]) &amp;&amp; previousCues[i].data()-&gt;isActive())
1740             activeSetChanged = true;
1741 
1742     for (size_t i = 0; i &lt; currentCuesSize; ++i) {
1743         RefPtr&lt;TextTrackCue&gt; cue = currentCues[i].data();
<span class="line-modified">1744 </span>
<span class="line-removed">1745         if (cue-&gt;isRenderable())</span>
<span class="line-removed">1746             toVTTCue(cue.get())-&gt;updateDisplayTree(movieTime);</span>
<span class="line-removed">1747 </span>
1748         if (!cue-&gt;isActive())
1749             activeSetChanged = true;
1750     }
1751 
1752     MediaTime nextInterestingTime = MediaTime::invalidTime();
1753     if (auto nearestEndingCue = std::min_element(currentCues.begin(), currentCues.end(), compareCueIntervalEndTime))
1754         nextInterestingTime = nearestEndingCue-&gt;data()-&gt;endMediaTime();
1755 
<span class="line-modified">1756     Optional&lt;CueInterval&gt; nextCue = m_cueTree.nextIntervalAfter(movieTimeInterval);</span>
1757     if (nextCue)
1758         nextInterestingTime = std::min(nextInterestingTime, nextCue-&gt;low());
1759 
1760     INFO_LOG(LOGIDENTIFIER, &quot;nextInterestingTime:&quot;, nextInterestingTime);
1761 
1762     if (nextInterestingTime.isValid() &amp;&amp; m_player) {
1763         m_player-&gt;performTaskAtMediaTime([this, weakThis = makeWeakPtr(this), nextInterestingTime] {
1764             if (!weakThis)
1765                 return;
1766 
1767             auto currentMediaTime = this-&gt;currentMediaTime();
1768             INFO_LOG(LOGIDENTIFIER, &quot; lambda, currentMediaTime: &quot;, currentMediaTime);
1769             this-&gt;updateActiveTextTrackCues(currentMediaTime);
1770         }, nextInterestingTime);
1771     }
1772 
1773     if (!activeSetChanged)
1774         return;
1775 
1776     // 7 - If the time was reached through the usual monotonic increase of the
</pre>
<hr />
<pre>
1832             eventTasks.append({ currentCues[i].data()-&gt;startMediaTime(), currentCues[i].data() });
1833     }
1834 
1835     // 12 - Sort the tasks in events in ascending time order (tasks with earlier
1836     // times first).
1837     std::sort(eventTasks.begin(), eventTasks.end(), eventTimeCueCompare);
1838 
1839     for (auto&amp; eventTask : eventTasks) {
1840         if (!affectedTracks.contains(eventTask.second-&gt;track()))
1841             affectedTracks.append(eventTask.second-&gt;track());
1842 
1843         // 13 - Queue each task in events, in list order.
1844 
1845         // Each event in eventTasks may be either an enterEvent or an exitEvent,
1846         // depending on the time that is associated with the event. This
1847         // correctly identifies the type of the event, if the startTime is
1848         // less than the endTime in the cue.
1849         if (eventTask.second-&gt;startTime() &gt;= eventTask.second-&gt;endTime()) {
1850             auto enterEvent = Event::create(eventNames().enterEvent, Event::CanBubble::No, Event::IsCancelable::No);
1851             enterEvent-&gt;setTarget(eventTask.second);
<span class="line-modified">1852             m_asyncEventQueue.enqueueEvent(WTFMove(enterEvent));</span>
1853 
1854             auto exitEvent = Event::create(eventNames().exitEvent, Event::CanBubble::No, Event::IsCancelable::No);
1855             exitEvent-&gt;setTarget(eventTask.second);
<span class="line-modified">1856             m_asyncEventQueue.enqueueEvent(WTFMove(exitEvent));</span>
1857         } else {
1858             RefPtr&lt;Event&gt; event;
1859             if (eventTask.first == eventTask.second-&gt;startMediaTime())
1860                 event = Event::create(eventNames().enterEvent, Event::CanBubble::No, Event::IsCancelable::No);
1861             else
1862                 event = Event::create(eventNames().exitEvent, Event::CanBubble::No, Event::IsCancelable::No);
1863             event-&gt;setTarget(eventTask.second);
<span class="line-modified">1864             m_asyncEventQueue.enqueueEvent(WTFMove(event));</span>
1865         }
1866     }
1867 
1868     // 14 - Sort affected tracks in the same order as the text tracks appear in
1869     // the media element&#39;s list of text tracks, and remove duplicates.
1870     std::sort(affectedTracks.begin(), affectedTracks.end(), trackIndexCompare);
1871 
1872     // 15 - For each text track in affected tracks, in the list order, queue a
1873     // task to fire a simple event named cuechange at the TextTrack object, and, ...
1874     for (auto&amp; affectedTrack : affectedTracks) {
1875         auto event = Event::create(eventNames().cuechangeEvent, Event::CanBubble::No, Event::IsCancelable::No);
1876         event-&gt;setTarget(affectedTrack);
<span class="line-modified">1877         m_asyncEventQueue.enqueueEvent(WTFMove(event));</span>
1878 
1879         // ... if the text track has a corresponding track element, to then fire a
1880         // simple event named cuechange at the track element as well.
1881         if (is&lt;LoadableTextTrack&gt;(*affectedTrack)) {
1882             auto event = Event::create(eventNames().cuechangeEvent, Event::CanBubble::No, Event::IsCancelable::No);
1883             auto trackElement = makeRefPtr(downcast&lt;LoadableTextTrack&gt;(*affectedTrack).trackElement());
1884             ASSERT(trackElement);
1885             event-&gt;setTarget(trackElement);
<span class="line-modified">1886             m_asyncEventQueue.enqueueEvent(WTFMove(event));</span>
1887         }
1888     }
1889 
1890     // 16 - Set the text track cue active flag of all the cues in the current
1891     // cues, and unset the text track cue active flag of all the cues in the
1892     // other cues.
1893     for (size_t i = 0; i &lt; currentCuesSize; ++i)
1894         currentCues[i].data()-&gt;setIsActive(true);
1895 
1896     for (size_t i = 0; i &lt; previousCuesSize; ++i)
1897         if (!currentCues.contains(previousCues[i]))
1898             previousCues[i].data()-&gt;setIsActive(false);
1899 
1900     // Update the current active cues.
<span class="line-modified">1901     m_currentlyActiveCues = currentCues;</span>
1902 
1903     if (activeSetChanged)
1904         updateTextTrackDisplay();
1905 }
1906 
1907 bool HTMLMediaElement::textTracksAreReady() const
1908 {
1909     // 4.8.10.12.1 Text track model
1910     // ...
1911     // The text tracks of a media element are ready if all the text tracks whose mode was not
1912     // in the disabled state when the element&#39;s resource selection algorithm last started now
1913     // have a text track readiness state of loaded or failed to load.
1914     for (unsigned i = 0; i &lt; m_textTracksWhenResourceSelectionBegan.size(); ++i) {
1915         if (m_textTracksWhenResourceSelectionBegan[i]-&gt;readinessState() == TextTrack::Loading
1916             || m_textTracksWhenResourceSelectionBegan[i]-&gt;readinessState() == TextTrack::NotLoaded)
1917             return false;
1918     }
1919 
1920     return true;
1921 }
</pre>
<hr />
<pre>
1950     if (processingUserGestureForMedia())
1951         removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);
1952 }
1953 
1954 void HTMLMediaElement::textTrackModeChanged(TextTrack&amp; track)
1955 {
1956     bool trackIsLoaded = true;
1957     if (track.trackType() == TextTrack::TrackElement) {
1958         trackIsLoaded = false;
1959         for (auto&amp; trackElement : childrenOfType&lt;HTMLTrackElement&gt;(*this)) {
1960             if (&amp;trackElement.track() == &amp;track) {
1961                 if (trackElement.readyState() == HTMLTrackElement::LOADING || trackElement.readyState() == HTMLTrackElement::LOADED)
1962                     trackIsLoaded = true;
1963                 break;
1964             }
1965         }
1966     }
1967 
1968     // If this is the first added track, create the list of text tracks.
1969     if (!m_textTracks)
<span class="line-modified">1970         m_textTracks = TextTrackList::create(this, ActiveDOMObject::scriptExecutionContext());</span>
1971 
1972     // Mark this track as &quot;configured&quot; so configureTextTracks won&#39;t change the mode again.
1973     track.setHasBeenConfigured(true);
1974 
1975     if (track.mode() != TextTrack::Mode::Disabled &amp;&amp; trackIsLoaded)
1976         textTrackAddCues(track, *track.cues());
1977 
1978     configureTextTrackDisplay(AssumeTextTrackVisibilityChanged);
1979 
1980     if (m_textTracks &amp;&amp; m_textTracks-&gt;contains(track))
1981         m_textTracks-&gt;scheduleChangeEvent();
1982 
1983 #if ENABLE(AVF_CAPTIONS)
1984     if (track.trackType() == TextTrack::TrackElement &amp;&amp; m_player)
1985         m_player-&gt;notifyTrackModeChanged();
1986 #endif
1987 }
1988 
1989 void HTMLMediaElement::videoTrackSelectedChanged(VideoTrack&amp; track)
1990 {
</pre>
<hr />
<pre>
2018 
2019     TrackDisplayUpdateScope scope { *this };
2020     for (unsigned i = 0; i &lt; cues.length(); ++i)
2021         textTrackAddCue(track, *cues.item(i));
2022 }
2023 
2024 void HTMLMediaElement::textTrackRemoveCues(TextTrack&amp;, const TextTrackCueList&amp; cues)
2025 {
2026     TrackDisplayUpdateScope scope { *this };
2027     for (unsigned i = 0; i &lt; cues.length(); ++i) {
2028         auto&amp; cue = *cues.item(i);
2029         textTrackRemoveCue(*cue.track(), cue);
2030     }
2031 }
2032 
2033 void HTMLMediaElement::textTrackAddCue(TextTrack&amp; track, TextTrackCue&amp; cue)
2034 {
2035     if (track.mode() == TextTrack::Mode::Disabled)
2036         return;
2037 



2038     // Negative duration cues need be treated in the interval tree as
2039     // zero-length cues.
2040     MediaTime endTime = std::max(cue.startMediaTime(), cue.endMediaTime());
2041 
<span class="line-modified">2042     CueInterval interval = m_cueTree.createInterval(cue.startMediaTime(), endTime, &amp;cue);</span>
<span class="line-modified">2043     if (!m_cueTree.contains(interval))</span>
<span class="line-modified">2044         m_cueTree.add(interval);</span>
2045     updateActiveTextTrackCues(currentMediaTime());
2046 }
2047 
2048 void HTMLMediaElement::textTrackRemoveCue(TextTrack&amp;, TextTrackCue&amp; cue)
2049 {



2050     // Negative duration cues need to be treated in the interval tree as
2051     // zero-length cues.
2052     MediaTime endTime = std::max(cue.startMediaTime(), cue.endMediaTime());
2053 
<span class="line-modified">2054     CueInterval interval = m_cueTree.createInterval(cue.startMediaTime(), endTime, &amp;cue);</span>
<span class="line-modified">2055     m_cueTree.remove(interval);</span>
2056 
2057     // Since the cue will be removed from the media element and likely the
2058     // TextTrack might also be destructed, notifying the region of the cue
2059     // removal shouldn&#39;t be done.
<span class="line-modified">2060     if (cue.isRenderable())</span>

2061         toVTTCue(&amp;cue)-&gt;notifyRegionWhenRemovingDisplayTree(false);
2062 
<span class="line-modified">2063     size_t index = m_currentlyActiveCues.find(interval);</span>
2064     if (index != notFound) {
2065         cue.setIsActive(false);
<span class="line-modified">2066         m_currentlyActiveCues.remove(index);</span>
2067     }
2068 
<span class="line-modified">2069     if (cue.isRenderable())</span>
<span class="line-removed">2070         toVTTCue(&amp;cue)-&gt;removeDisplayTree();</span>
2071     updateActiveTextTrackCues(currentMediaTime());
2072 
<span class="line-modified">2073     if (cue.isRenderable())</span>
2074         toVTTCue(&amp;cue)-&gt;notifyRegionWhenRemovingDisplayTree(true);
2075 }
2076 







2077 #endif
2078 
2079 static inline bool isAllowedToLoadMediaURL(HTMLMediaElement&amp; element, const URL&amp; url, bool isInUserAgentShadowTree)
2080 {
2081     // Elements in user agent show tree should load whatever the embedding document policy is.
2082     if (isInUserAgentShadowTree)
2083         return true;
2084 
2085     ASSERT(element.document().contentSecurityPolicy());
2086     return element.document().contentSecurityPolicy()-&gt;allowMediaFromSource(url);
2087 }
2088 
2089 bool HTMLMediaElement::isSafeToLoadURL(const URL&amp; url, InvalidURLAction actionIfInvalid)
2090 {
2091     if (!url.isValid()) {
2092         ERROR_LOG(LOGIDENTIFIER, url, &quot; is invalid&quot;);
2093         return false;
2094     }
2095 
2096     RefPtr&lt;Frame&gt; frame = document().frame();
</pre>
<hr />
<pre>
2139 
2140 void HTMLMediaElement::noneSupported()
2141 {
2142     if (m_error)
2143         return;
2144 
2145     INFO_LOG(LOGIDENTIFIER);
2146 
2147     stopPeriodicTimers();
2148     m_loadState = WaitingForSource;
2149     m_currentSourceNode = nullptr;
2150 
2151     // 4.8.10.5
2152     // 6 - Reaching this step indicates that the media resource failed to load or that the given
2153     // URL could not be resolved. In one atomic operation, run the following steps:
2154 
2155     // 6.1 - Set the error attribute to a new MediaError object whose code attribute is set to
2156     // MEDIA_ERR_SRC_NOT_SUPPORTED.
2157     m_error = MediaError::create(MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED);
2158 

2159     // 6.2 - Forget the media element&#39;s media-resource-specific text tracks.
2160     forgetResourceSpecificTracks();

2161 
2162     // 6.3 - Set the element&#39;s networkState attribute to the NETWORK_NO_SOURCE value.
2163     m_networkState = NETWORK_NO_SOURCE;
2164 
2165     // 7 - Queue a task to fire a simple event named error at the media element.
2166     scheduleEvent(eventNames().errorEvent);
2167 
2168     rejectPendingPlayPromises(WTFMove(m_pendingPlayPromises), DOMException::create(NotSupportedError));
2169 
2170 #if ENABLE(MEDIA_SOURCE)
2171     detachMediaSource();
2172 #endif
2173 
2174     // 8 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
2175     setShouldDelayLoadEvent(false);
2176 
2177     // 9 - Abort these steps. Until the load() method is invoked or the src attribute is changed,
2178     // the element won&#39;t attempt to load another resource.
2179 
2180     updateDisplayState();
2181     updateRenderer();
2182 }
2183 
2184 void HTMLMediaElement::mediaLoadingFailedFatally(MediaPlayer::NetworkState error)
2185 {
2186     // 1 - The user agent should cancel the fetching process.
2187     stopPeriodicTimers();
2188     m_loadState = WaitingForSource;
2189 
2190     // 2 - Set the error attribute to a new MediaError object whose code attribute is
2191     // set to MEDIA_ERR_NETWORK/MEDIA_ERR_DECODE.
<span class="line-modified">2192     if (error == MediaPlayer::NetworkError)</span>
2193         m_error = MediaError::create(MediaError::MEDIA_ERR_NETWORK);
<span class="line-modified">2194     else if (error == MediaPlayer::DecodeError)</span>
2195         m_error = MediaError::create(MediaError::MEDIA_ERR_DECODE);
2196     else
2197         ASSERT_NOT_REACHED();
2198 
2199     // 3 - Queue a task to fire a simple event named error at the media element.
2200     scheduleEvent(eventNames().errorEvent);
2201 
2202 #if ENABLE(MEDIA_SOURCE)
2203     detachMediaSource();
2204 #endif
2205 
2206     // 4 - Set the element&#39;s networkState attribute to the NETWORK_EMPTY value and queue a
2207     // task to fire a simple event called emptied at the element.
2208     m_networkState = NETWORK_EMPTY;
2209     scheduleEvent(eventNames().emptiedEvent);
2210 
2211     // 5 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
2212     setShouldDelayLoadEvent(false);
2213 
2214     // 6 - Abort the overall resource selection algorithm.
2215     m_currentSourceNode = nullptr;
<span class="line-removed">2216 </span>
<span class="line-removed">2217 #if PLATFORM(COCOA)</span>
<span class="line-removed">2218     if (is&lt;MediaDocument&gt;(document()))</span>
<span class="line-removed">2219         downcast&lt;MediaDocument&gt;(document()).mediaElementSawUnsupportedTracks();</span>
<span class="line-removed">2220 #endif</span>
2221 }
2222 
2223 void HTMLMediaElement::cancelPendingEventsAndCallbacks()
2224 {
2225     INFO_LOG(LOGIDENTIFIER);
<span class="line-modified">2226     m_asyncEventQueue.cancelAllEvents();</span>
2227 
2228     for (auto&amp; source : childrenOfType&lt;HTMLSourceElement&gt;(*this))
2229         source.cancelPendingErrorEvent();
2230 
2231     rejectPendingPlayPromises(WTFMove(m_pendingPlayPromises), DOMException::create(AbortError));
2232 }
2233 
<span class="line-modified">2234 void HTMLMediaElement::mediaPlayerNetworkStateChanged(MediaPlayer*)</span>
2235 {
2236     beginProcessingMediaPlayerCallback();
2237     setNetworkState(m_player-&gt;networkState());
2238     endProcessingMediaPlayerCallback();
2239 }
2240 
2241 static void logMediaLoadRequest(Page* page, const String&amp; mediaEngine, const String&amp; errorMessage, bool succeeded)
2242 {
2243     if (!page)
2244         return;
2245 
2246     DiagnosticLoggingClient&amp; diagnosticLoggingClient = page-&gt;diagnosticLoggingClient();
2247     if (!succeeded) {
2248         diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::mediaLoadingFailedKey(), errorMessage, DiagnosticLoggingResultFail, ShouldSample::No);
2249         return;
2250     }
2251 
2252     diagnosticLoggingClient.logDiagnosticMessage(DiagnosticLoggingKeys::mediaLoadedKey(), mediaEngine, ShouldSample::No);
2253 
2254     if (!page-&gt;hasSeenAnyMediaEngine())
2255         diagnosticLoggingClient.logDiagnosticMessage(DiagnosticLoggingKeys::pageContainsAtLeastOneMediaEngineKey(), emptyString(), ShouldSample::No);
2256 
2257     if (!page-&gt;hasSeenMediaEngine(mediaEngine))
2258         diagnosticLoggingClient.logDiagnosticMessage(DiagnosticLoggingKeys::pageContainsMediaEngineKey(), mediaEngine, ShouldSample::No);
2259 
2260     page-&gt;sawMediaEngine(mediaEngine);
2261 }
2262 
<span class="line-removed">2263 static String stringForNetworkState(MediaPlayer::NetworkState state)</span>
<span class="line-removed">2264 {</span>
<span class="line-removed">2265     switch (state) {</span>
<span class="line-removed">2266     case MediaPlayer::Empty: return &quot;Empty&quot;_s;</span>
<span class="line-removed">2267     case MediaPlayer::Idle: return &quot;Idle&quot;_s;</span>
<span class="line-removed">2268     case MediaPlayer::Loading: return &quot;Loading&quot;_s;</span>
<span class="line-removed">2269     case MediaPlayer::Loaded: return &quot;Loaded&quot;_s;</span>
<span class="line-removed">2270     case MediaPlayer::FormatError: return &quot;FormatError&quot;_s;</span>
<span class="line-removed">2271     case MediaPlayer::NetworkError: return &quot;NetworkError&quot;_s;</span>
<span class="line-removed">2272     case MediaPlayer::DecodeError: return &quot;DecodeError&quot;_s;</span>
<span class="line-removed">2273     default: return emptyString();</span>
<span class="line-removed">2274     }</span>
<span class="line-removed">2275 }</span>
<span class="line-removed">2276 </span>
2277 void HTMLMediaElement::mediaLoadingFailed(MediaPlayer::NetworkState error)
2278 {
2279     stopPeriodicTimers();
2280 
2281     // If we failed while trying to load a &lt;source&gt; element, the movie was never parsed, and there are more
2282     // &lt;source&gt; children, schedule the next one
2283     if (m_readyState &lt; HAVE_METADATA &amp;&amp; m_loadState == LoadingFromSourceElement) {
2284 
2285         // resource selection algorithm
2286         // Step 9.Otherwise.9 - Failed with elements: Queue a task, using the DOM manipulation task source, to fire a simple event named error at the candidate element.
2287         if (m_currentSourceNode)
2288             m_currentSourceNode-&gt;scheduleErrorEvent();
2289         else
2290             INFO_LOG(LOGIDENTIFIER, &quot;error event not sent, &lt;source&gt; was removed&quot;);
2291 
2292         // 9.Otherwise.10 - Asynchronously await a stable state. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended.
2293 

2294         // 9.Otherwise.11 - Forget the media element&#39;s media-resource-specific tracks.
2295         forgetResourceSpecificTracks();

2296 
2297         if (havePotentialSourceChild()) {
2298             INFO_LOG(LOGIDENTIFIER, &quot;scheduling next &lt;source&gt;&quot;);
2299             scheduleNextSourceChild();
2300         } else {
2301             INFO_LOG(LOGIDENTIFIER, &quot;no more &lt;source&gt; elements, waiting&quot;);
2302             waitForSourceChange();
2303         }
2304 
2305         return;
2306     }
2307 
<span class="line-modified">2308     if ((error == MediaPlayer::NetworkError &amp;&amp; m_readyState &gt;= HAVE_METADATA) || error == MediaPlayer::DecodeError)</span>
2309         mediaLoadingFailedFatally(error);
<span class="line-modified">2310     else if ((error == MediaPlayer::FormatError || error == MediaPlayer::NetworkError) &amp;&amp; m_loadState == LoadingFromSrcAttr)</span>
2311         noneSupported();
2312 
2313     updateDisplayState();
2314     if (hasMediaControls()) {
2315         mediaControls()-&gt;reset();
2316         mediaControls()-&gt;reportedError();
2317     }
2318 
2319     ERROR_LOG(LOGIDENTIFIER, &quot;error = &quot;, static_cast&lt;int&gt;(error));
2320 
<span class="line-modified">2321     logMediaLoadRequest(document().page(), String(), stringForNetworkState(error), false);</span>
2322 
2323     m_mediaSession-&gt;clientCharacteristicsChanged();
2324 }
2325 
2326 void HTMLMediaElement::setNetworkState(MediaPlayer::NetworkState state)
2327 {
2328     if (static_cast&lt;int&gt;(state) != static_cast&lt;int&gt;(m_networkState))
2329         ALWAYS_LOG(LOGIDENTIFIER, &quot;new state = &quot;, state, &quot;, current state = &quot;, m_networkState);
2330 
<span class="line-modified">2331     if (state == MediaPlayer::Empty) {</span>
2332         // Just update the cached state and leave, we can&#39;t do anything.
2333         m_networkState = NETWORK_EMPTY;
2334         return;
2335     }
2336 
<span class="line-modified">2337     if (state == MediaPlayer::FormatError || state == MediaPlayer::NetworkError || state == MediaPlayer::DecodeError) {</span>
2338         mediaLoadingFailed(state);
2339         return;
2340     }
2341 
<span class="line-modified">2342     if (state == MediaPlayer::Idle) {</span>
2343         if (m_networkState &gt; NETWORK_IDLE) {
2344             changeNetworkStateFromLoadingToIdle();
2345             setShouldDelayLoadEvent(false);
2346         } else {
2347             m_networkState = NETWORK_IDLE;
2348         }
2349     }
2350 
<span class="line-modified">2351     if (state == MediaPlayer::Loading) {</span>
2352         if (m_networkState &lt; NETWORK_LOADING || m_networkState == NETWORK_NO_SOURCE)
2353             startProgressEventTimer();
2354         m_networkState = NETWORK_LOADING;
2355     }
2356 
<span class="line-modified">2357     if (state == MediaPlayer::Loaded) {</span>
2358         if (m_networkState != NETWORK_IDLE)
2359             changeNetworkStateFromLoadingToIdle();
2360         m_completelyLoaded = true;
2361     }
2362 
2363     if (hasMediaControls())
2364         mediaControls()-&gt;updateStatusDisplay();
2365 }
2366 
2367 void HTMLMediaElement::changeNetworkStateFromLoadingToIdle()
2368 {
2369     m_progressEventTimer.stop();
2370     if (hasMediaControls() &amp;&amp; m_player-&gt;didLoadingProgress())
2371         mediaControls()-&gt;bufferingProgressed();
2372 
2373     // Schedule one last progress event so we guarantee that at least one is fired
2374     // for files that load very quickly.
2375     scheduleEvent(eventNames().progressEvent);
2376     scheduleEvent(eventNames().suspendEvent);
2377     m_networkState = NETWORK_IDLE;
2378 }
2379 
<span class="line-modified">2380 void HTMLMediaElement::mediaPlayerReadyStateChanged(MediaPlayer*)</span>
2381 {







2382     beginProcessingMediaPlayerCallback();
2383 
2384     setReadyState(m_player-&gt;readyState());
2385 
2386     endProcessingMediaPlayerCallback();
2387 }
2388 
2389 SuccessOr&lt;MediaPlaybackDenialReason&gt; HTMLMediaElement::canTransitionFromAutoplayToPlay() const
2390 {
2391     if (m_readyState != HAVE_ENOUGH_DATA) {
2392         ALWAYS_LOG(LOGIDENTIFIER, &quot;m_readyState != HAVE_ENOUGH_DATA&quot;);
2393         return MediaPlaybackDenialReason::PageConsentRequired;
2394     }
2395     if (!isAutoplaying()) {
2396         ALWAYS_LOG(LOGIDENTIFIER, &quot;!isAutoplaying&quot;);
2397         return MediaPlaybackDenialReason::PageConsentRequired;
2398     }
2399     if (!mediaSession().autoplayPermitted()) {
2400         ALWAYS_LOG(LOGIDENTIFIER, &quot;!mediaSession().autoplayPermitted&quot;);
2401         return MediaPlaybackDenialReason::PageConsentRequired;
</pre>
<hr />
<pre>
2578         updateDisplayState();
2579         if (hasMediaControls()) {
2580             mediaControls()-&gt;refreshClosedCaptionsButtonVisibility();
2581             mediaControls()-&gt;updateStatusDisplay();
2582         }
2583     }
2584 
2585     updatePlayState();
2586     updateMediaController();
2587 #if ENABLE(VIDEO_TRACK)
2588     updateActiveTextTrackCues(currentMediaTime());
2589 #endif
2590 }
2591 
2592 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
2593 RefPtr&lt;ArrayBuffer&gt; HTMLMediaElement::mediaPlayerCachedKeyForKeyId(const String&amp; keyId) const
2594 {
2595     return m_webKitMediaKeys ? m_webKitMediaKeys-&gt;cachedKeyForKeyId(keyId) : nullptr;
2596 }
2597 
<span class="line-modified">2598 bool HTMLMediaElement::mediaPlayerKeyNeeded(MediaPlayer*, Uint8Array* initData)</span>
2599 {
2600     if (!RuntimeEnabledFeatures::sharedFeatures().legacyEncryptedMediaAPIEnabled())
2601         return false;
2602 
2603     if (!hasEventListeners(&quot;webkitneedkey&quot;)
2604 #if ENABLE(ENCRYPTED_MEDIA)
2605         // Only fire an error if ENCRYPTED_MEDIA is not enabled, to give clients of the
2606         // &quot;encrypted&quot; event a chance to handle it without resulting in a synthetic error.
2607         &amp;&amp; (!RuntimeEnabledFeatures::sharedFeatures().encryptedMediaAPIEnabled() || document().quirks().hasBrokenEncryptedMediaAPISupportQuirk())
2608 #endif
2609         ) {
2610         m_error = MediaError::create(MediaError::MEDIA_ERR_ENCRYPTED);
2611         scheduleEvent(eventNames().errorEvent);
2612         return false;
2613     }
2614 
2615     auto event = WebKitMediaKeyNeededEvent::create(eventNames().webkitneedkeyEvent, initData);
2616     event-&gt;setTarget(this);
<span class="line-modified">2617     m_asyncEventQueue.enqueueEvent(WTFMove(event));</span>
2618 
2619     return true;
2620 }
2621 
2622 String HTMLMediaElement::mediaPlayerMediaKeysStorageDirectory() const
2623 {
2624     auto* page = document().page();
2625     if (!page || page-&gt;usesEphemeralSession())
2626         return emptyString();
2627 
2628     String storageDirectory = document().settings().mediaKeysStorageDirectory();
2629     if (storageDirectory.isEmpty())
2630         return emptyString();
2631 
2632     return FileSystem::pathByAppendingComponent(storageDirectory, document().securityOrigin().data().databaseIdentifier());
2633 }
2634 
2635 void HTMLMediaElement::webkitSetMediaKeys(WebKitMediaKeys* mediaKeys)
2636 {
2637     if (!RuntimeEnabledFeatures::sharedFeatures().legacyEncryptedMediaAPIEnabled())
</pre>
<hr />
<pre>
2744         return;
2745 
2746     // https://w3c.github.io/encrypted-media/#initdata-encountered
2747     // W3C Editor&#39;s Draft 23 June 2017
2748 
2749     // 1. Let the media element be the specified HTMLMediaElement object.
2750     // 2. Let initDataType be the empty string.
2751     // 3. Let initData be null.
2752     // 4. If the media data is CORS-same-origin and not mixed content, run the following steps:
2753     //   4.1. Let initDataType be the string representing the Initialization Data Type of the Initialization Data.
2754     //   4.2. Let initData be the Initialization Data.
2755     // FIXME: ^
2756 
2757     // 5. Queue a task to create an event named encrypted that does not bubble and is not cancellable using the
2758     //    MediaEncryptedEvent interface with its type attribute set to encrypted and its isTrusted attribute
2759     //    initialized to true, and dispatch it at the media element.
2760     //    The event interface MediaEncryptedEvent has:
2761     //      initDataType = initDataType
2762     //      initData = initData
2763     MediaEncryptedEventInit initializer { initDataType, WTFMove(initData) };
<span class="line-modified">2764     m_asyncEventQueue.enqueueEvent(MediaEncryptedEvent::create(eventNames().encryptedEvent, initializer, Event::IsTrusted::Yes));</span>
2765 }
2766 
2767 void HTMLMediaElement::mediaPlayerWaitingForKeyChanged()
2768 {
2769     if (!m_player)
2770         return;
2771 
2772     if (!m_player-&gt;waitingForKey() &amp;&amp; m_playbackBlockedWaitingForKey) {
2773         // https://w3c.github.io/encrypted-media/#resume-playback
2774         // W3C Editor&#39;s Draft 23 June 2017
2775 
2776         // NOTE: continued from HTMLMediaElement::attemptToDecrypt().
2777         // 4. If the user agent can advance the current playback position in the direction of playback:
2778         //   4.1. Set the media element&#39;s decryption blocked waiting for key value to false.
2779         // FIXME: ^
2780         //   4.2. Set the media element&#39;s playback blocked waiting for key value to false.
2781         m_playbackBlockedWaitingForKey = false;
2782 
2783         //   4.3. Set the media element&#39;s readyState value to HAVE_CURRENT_DATA, HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA as appropriate.
2784         setReadyState(m_player-&gt;readyState());
</pre>
<hr />
<pre>
2984 
2985 void HTMLMediaElement::seekInternal(const MediaTime&amp; time)
2986 {
2987     INFO_LOG(LOGIDENTIFIER, time);
2988     seekWithTolerance(time, MediaTime::zeroTime(), MediaTime::zeroTime(), false);
2989 }
2990 
2991 void HTMLMediaElement::seekWithTolerance(const MediaTime&amp; inTime, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance, bool fromDOM)
2992 {
2993     // 4.8.10.9 Seeking
2994     MediaTime time = inTime;
2995 
2996     // 1 - Set the media element&#39;s show poster flag to false.
2997     setDisplayMode(Video);
2998 
2999     // 2 - If the media element&#39;s readyState is HAVE_NOTHING, abort these steps.
3000     if (m_readyState == HAVE_NOTHING || !m_player)
3001         return;
3002 
3003     // If the media engine has been told to postpone loading data, let it go ahead now.
<span class="line-modified">3004     if (m_preload &lt; MediaPlayer::Auto &amp;&amp; m_readyState &lt; HAVE_FUTURE_DATA)</span>
3005         prepareToPlay();
3006 
3007     // Get the current time before setting m_seeking, m_lastSeekTime is returned once it is set.
3008     refreshCachedTime();
3009     MediaTime now = currentMediaTime();
3010 
3011     // 3 - If the element&#39;s seeking IDL attribute is true, then another instance of this algorithm is
3012     // already running. Abort that other instance of the algorithm without waiting for the step that
3013     // it is running to complete.
3014     if (m_seekTaskQueue.hasPendingTask()) {
3015         INFO_LOG(LOGIDENTIFIER, &quot;cancelling pending seeks&quot;);
3016         m_seekTaskQueue.cancelTask();
3017         if (m_pendingSeek) {
3018             now = m_pendingSeek-&gt;now;
3019             m_pendingSeek = nullptr;
3020         }
3021         m_pendingSeekType = NoSeek;
3022     }
3023 
3024     // 4 - Set the seeking IDL attribute to true.
</pre>
<hr />
<pre>
3156 
3157     // 17 - Queue a task to fire a simple event named seeked at the element.
3158     scheduleEvent(eventNames().seekedEvent);
3159 
3160     if (m_mediaSession)
3161         m_mediaSession-&gt;clientCharacteristicsChanged();
3162 
3163 #if ENABLE(MEDIA_SOURCE)
3164     if (m_mediaSource)
3165         m_mediaSource-&gt;monitorSourceBuffers();
3166 #endif
3167 }
3168 
3169 HTMLMediaElement::ReadyState HTMLMediaElement::readyState() const
3170 {
3171     return m_readyState;
3172 }
3173 
3174 MediaPlayer::MovieLoadType HTMLMediaElement::movieLoadType() const
3175 {
<span class="line-modified">3176     return m_player ? m_player-&gt;movieLoadType() : MediaPlayer::Unknown;</span>
3177 }
3178 
3179 bool HTMLMediaElement::hasAudio() const
3180 {
3181     return m_player ? m_player-&gt;hasAudio() : false;
3182 }
3183 
3184 bool HTMLMediaElement::seeking() const
3185 {
3186     return m_seeking;
3187 }
3188 
3189 void HTMLMediaElement::refreshCachedTime() const
3190 {
3191     if (!m_player)
3192         return;
3193 
3194     m_cachedTime = m_player-&gt;currentTime();
3195     if (!m_cachedTime) {
3196         // Do not use m_cachedTime until the media engine returns a non-zero value because we can&#39;t
</pre>
<hr />
<pre>
3452     // The ended attribute must return true if the media element has ended
3453     // playback and the direction of playback is forwards, and false otherwise.
3454     return endedPlayback() &amp;&amp; requestedPlaybackRate() &gt; 0;
3455 }
3456 
3457 bool HTMLMediaElement::autoplay() const
3458 {
3459     return hasAttributeWithoutSynchronization(autoplayAttr);
3460 }
3461 
3462 String HTMLMediaElement::preload() const
3463 {
3464 #if ENABLE(MEDIA_STREAM)
3465     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3466     // &quot;preload&quot; - On getting: none. On setting: ignored.
3467     if (m_mediaStreamSrcObject)
3468         return &quot;none&quot;_s;
3469 #endif
3470 
3471     switch (m_preload) {
<span class="line-modified">3472     case MediaPlayer::None:</span>
3473         return &quot;none&quot;_s;
<span class="line-modified">3474     case MediaPlayer::MetaData:</span>
3475         return &quot;metadata&quot;_s;
<span class="line-modified">3476     case MediaPlayer::Auto:</span>
3477         return &quot;auto&quot;_s;
3478     }
3479 
3480     ASSERT_NOT_REACHED();
3481     return String();
3482 }
3483 
3484 void HTMLMediaElement::setPreload(const String&amp; preload)
3485 {
3486     INFO_LOG(LOGIDENTIFIER, preload);
3487 #if ENABLE(MEDIA_STREAM)
3488     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3489     // &quot;preload&quot; - On getting: none. On setting: ignored.
3490     if (m_mediaStreamSrcObject)
3491         return;
3492 #endif
3493 
3494     setAttributeWithoutSynchronization(preloadAttr, preload);
3495 }
3496 
</pre>
<hr />
<pre>
3796                 if (hasMediaControls())
3797                     mediaControls()-&gt;changedMute();
3798             }
3799         }
3800 
3801         if (mutedStateChanged)
3802             scheduleEvent(eventNames().volumechangeEvent);
3803 
3804         updateShouldPlay();
3805 
3806 #if ENABLE(MEDIA_SESSION)
3807         document().updateIsPlayingMedia(m_elementID);
3808 #else
3809         document().updateIsPlayingMedia();
3810 #endif
3811 
3812 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
3813         scheduleUpdateMediaState();
3814 #endif
3815         m_mediaSession-&gt;canProduceAudioChanged();

3816     }
3817 
3818     schedulePlaybackControlsManagerUpdate();
3819 }
3820 
3821 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
3822 void HTMLMediaElement::hardwareMutedStateDidChange(AudioSession* session)
3823 {
3824     if (!session-&gt;isMuted())
3825         return;
3826 
3827     if (!hasAudio())
3828         return;
3829 
3830     if (effectiveMuted() || !volume())
3831         return;
3832 
3833     INFO_LOG(LOGIDENTIFIER);
3834     userDidInterfereWithAutoplay();
3835 }
</pre>
<hr />
<pre>
4023     return buffered.toDouble() / duration.toDouble();
4024 }
4025 
4026 #if ENABLE(VIDEO_TRACK)
4027 
4028 void HTMLMediaElement::mediaPlayerDidAddAudioTrack(AudioTrackPrivate&amp; track)
4029 {
4030     if (isPlaying() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
4031         pauseInternal();
4032         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
4033     }
4034 
4035     addAudioTrack(AudioTrack::create(*this, track));
4036 }
4037 
4038 void HTMLMediaElement::mediaPlayerDidAddTextTrack(InbandTextTrackPrivate&amp; track)
4039 {
4040     // 4.8.10.12.2 Sourcing in-band text tracks
4041     // 1. Associate the relevant data with a new text track and its corresponding new TextTrack object.
4042     auto textTrack = InbandTextTrack::create(*ActiveDOMObject::scriptExecutionContext(), *this, track);
<span class="line-modified">4043     textTrack-&gt;setMediaElement(this);</span>
4044 
4045     // 2. Set the new text track&#39;s kind, label, and language based on the semantics of the relevant data,
4046     // as defined by the relevant specification. If there is no label in that data, then the label must
4047     // be set to the empty string.
4048     // 3. Associate the text track list of cues with the rules for updating the text track rendering appropriate
4049     // for the format in question.
4050     // 4. If the new text track&#39;s kind is metadata, then set the text track in-band metadata track dispatch type
4051     // as follows, based on the type of the media resource:
4052     // 5. Populate the new text track&#39;s list of cues with the cues parsed so far, folllowing the guidelines for exposing
4053     // cues, and begin updating it dynamically as necessary.
4054     //   - Thess are all done by the media engine.
4055 
4056     // 6. Set the new text track&#39;s readiness state to loaded.
4057     textTrack-&gt;setReadinessState(TextTrack::Loaded);
4058 
4059     // 7. Set the new text track&#39;s mode to the mode consistent with the user&#39;s preferences and the requirements of
4060     // the relevant specification for the data.
4061     //  - This will happen in configureTextTracks()
4062     scheduleConfigureTextTracks();
4063 
</pre>
<hr />
<pre>
4180     auto&amp; trackReference = track.get();
4181 
4182     // Note, due to side effects when changing track parameters, we have to
4183     // first append the track to the text track list.
4184 
4185     // 6. Add the new text track to the media element&#39;s list of text tracks.
4186     addTextTrack(WTFMove(track));
4187 
4188     // ... its text track readiness state to the text track loaded state ...
4189     trackReference.setReadinessState(TextTrack::Loaded);
4190 
4191     // ... its text track mode to the text track hidden mode, and its text track list of cues to an empty list ...
4192     trackReference.setMode(TextTrack::Mode::Hidden);
4193 
4194     return trackReference;
4195 }
4196 
4197 AudioTrackList&amp; HTMLMediaElement::ensureAudioTracks()
4198 {
4199     if (!m_audioTracks)
<span class="line-modified">4200         m_audioTracks = AudioTrackList::create(this, ActiveDOMObject::scriptExecutionContext());</span>
4201 
4202     return *m_audioTracks;
4203 }
4204 
4205 TextTrackList&amp; HTMLMediaElement::ensureTextTracks()
4206 {
4207     if (!m_textTracks)
<span class="line-modified">4208         m_textTracks = TextTrackList::create(this, ActiveDOMObject::scriptExecutionContext());</span>
4209 
4210     return *m_textTracks;
4211 }
4212 
4213 VideoTrackList&amp; HTMLMediaElement::ensureVideoTracks()
4214 {
4215     if (!m_videoTracks)
<span class="line-modified">4216         m_videoTracks = VideoTrackList::create(this, ActiveDOMObject::scriptExecutionContext());</span>
4217 
4218     return *m_videoTracks;
4219 }
4220 
4221 void HTMLMediaElement::didAddTextTrack(HTMLTrackElement&amp; trackElement)
4222 {
4223     ASSERT(trackElement.hasTagName(trackTag));
4224 
4225     // 4.8.10.12.3 Sourcing out-of-band text tracks
4226     // When a track element&#39;s parent element changes and the new parent is a media element,
4227     // then the user agent must add the track element&#39;s corresponding text track to the
4228     // media element&#39;s list of text tracks ... [continues in TextTrackList::append]
4229     addTextTrack(trackElement.track());
4230 
4231     // Do not schedule the track loading until parsing finishes so we don&#39;t start before all tracks
4232     // in the markup have been added.
4233     if (!m_parsingInProgress)
4234         scheduleConfigureTextTracks();
4235 
4236     if (hasMediaControls())
</pre>
<hr />
<pre>
4353     if (currentlyEnabledTracks.size()) {
4354         for (size_t i = 0; i &lt; currentlyEnabledTracks.size(); ++i) {
4355             RefPtr&lt;TextTrack&gt; textTrack = currentlyEnabledTracks[i];
4356             if (textTrack != trackToEnable)
4357                 textTrack-&gt;setMode(TextTrack::Mode::Disabled);
4358         }
4359     }
4360 
4361     if (trackToEnable) {
4362         trackToEnable-&gt;setMode(TextTrack::Mode::Showing);
4363 
4364         // If user preferences indicate we should always display captions, make sure we reflect the
4365         // proper status via the webkitClosedCaptionsVisible API call:
4366         if (!webkitClosedCaptionsVisible() &amp;&amp; closedCaptionsVisible() &amp;&amp; displayMode == CaptionUserPreferences::AlwaysOn)
4367             m_webkitLegacyClosedCaptionOverride = true;
4368     }
4369 
4370     m_processingPreferenceChange = false;
4371 }
4372 
<span class="line-modified">4373 static JSC::JSValue controllerJSValue(JSC::ExecState&amp; exec, JSDOMGlobalObject&amp; globalObject, HTMLMediaElement&amp; media)</span>
4374 {
4375     JSC::VM&amp; vm = globalObject.vm();
4376     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">4377     auto mediaJSWrapper = toJS(&amp;exec, &amp;globalObject, media);</span>
4378 
4379     // Retrieve the controller through the JS object graph
4380     JSC::JSObject* mediaJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaJSWrapper);
4381     if (!mediaJSWrapperObject)
4382         return JSC::jsNull();
4383 
4384     JSC::Identifier controlsHost = JSC::Identifier::fromString(vm, &quot;controlsHost&quot;);
<span class="line-modified">4385     JSC::JSValue controlsHostJSWrapper = mediaJSWrapperObject-&gt;get(&amp;exec, controlsHost);</span>
4386     RETURN_IF_EXCEPTION(scope, JSC::jsNull());
4387 
4388     JSC::JSObject* controlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controlsHostJSWrapper);
4389     if (!controlsHostJSWrapperObject)
4390         return JSC::jsNull();
4391 
4392     JSC::Identifier controllerID = JSC::Identifier::fromString(vm, &quot;controller&quot;);
<span class="line-modified">4393     JSC::JSValue controllerJSWrapper = controlsHostJSWrapperObject-&gt;get(&amp;exec, controllerID);</span>
4394     RETURN_IF_EXCEPTION(scope, JSC::jsNull());
4395 
4396     return controllerJSWrapper;
4397 }
4398 
4399 void HTMLMediaElement::ensureMediaControlsShadowRoot()
4400 {
4401     ASSERT(!m_creatingControls);
4402     m_creatingControls = true;
4403     ensureUserAgentShadowRoot();
4404     m_creatingControls = false;
4405 }
4406 
4407 bool HTMLMediaElement::setupAndCallJS(const JSSetupFunction&amp; task)
4408 {
4409     Page* page = document().page();
4410     if (!page)
4411         return false;
4412 
4413     auto pendingActivity = makePendingActivity(*this);
4414     auto&amp; world = ensureIsolatedWorld();
4415     auto&amp; scriptController = document().frame()-&gt;script();
4416     auto* globalObject = JSC::jsCast&lt;JSDOMGlobalObject*&gt;(scriptController.globalObject(world));
4417     auto&amp; vm = globalObject-&gt;vm();
4418     JSC::JSLockHolder lock(vm);
4419     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">4420     auto* exec = globalObject-&gt;globalExec();</span>
4421 
4422     RETURN_IF_EXCEPTION(scope, false);
4423 
<span class="line-modified">4424     return task(*globalObject, *exec, scriptController, world);</span>
4425 }
4426 
4427 void HTMLMediaElement::updateCaptionContainer()
4428 {
4429 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
4430     if (m_haveSetUpCaptionContainer)
4431         return;
4432 
4433     if (!ensureMediaControlsInjectedScript())
4434         return;
4435 
4436     ensureMediaControlsShadowRoot();
4437 
4438     if (!m_mediaControlsHost)
4439         m_mediaControlsHost = MediaControlsHost::create(this);
4440 
<span class="line-modified">4441     setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
4442         auto&amp; vm = globalObject.vm();
4443         auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">4444         auto controllerValue = controllerJSValue(exec, globalObject, *this);</span>
4445         auto* controllerObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controllerValue);
4446         if (!controllerObject)
4447             return false;
4448 
4449         // The media controls script must provide a method on the Controller object with the following details.
4450         // Name: updateCaptionContainer
4451         // Parameters:
4452         //     None
4453         // Return value:
4454         //     None
<span class="line-modified">4455         auto methodValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;updateCaptionContainer&quot;));</span>
4456         auto* methodObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, methodValue);
4457         if (!methodObject)
4458             return false;
4459 
4460         JSC::CallData callData;
4461         auto callType = methodObject-&gt;methodTable(vm)-&gt;getCallData(methodObject, callData);
4462         if (callType == JSC::CallType::None)
4463             return false;
4464 
4465         JSC::MarkedArgumentBuffer noArguments;
4466         ASSERT(!noArguments.hasOverflowed());
<span class="line-modified">4467         JSC::call(&amp;exec, methodObject, callType, callData, controllerObject, noArguments);</span>
4468         scope.clearException();
4469 
4470         m_haveSetUpCaptionContainer = true;
4471 
4472         return true;
4473     });
4474 
4475 #endif
4476 }
4477 
4478 void HTMLMediaElement::layoutSizeChanged()
4479 {
4480 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
4481     if (auto frameView = makeRefPtr(document().view())) {
4482         auto task = [this, protectedThis = makeRef(*this)] {
4483             if (auto root = userAgentShadowRoot())
4484                 root-&gt;dispatchEvent(Event::create(&quot;resize&quot;, Event::CanBubble::No, Event::IsCancelable::No));
4485         };
4486         frameView-&gt;queuePostLayoutCallback(WTFMove(task));
4487     }
</pre>
<hr />
<pre>
4690         }
4691 
4692         type = source-&gt;attributeWithoutSynchronization(typeAttr);
4693         if (type.isEmpty() &amp;&amp; mediaURL.protocolIsData())
4694             type = mimeTypeFromDataURL(mediaURL);
4695         if (!type.isEmpty()) {
4696             if (shouldLog)
4697                 INFO_LOG(LOGIDENTIFIER, &quot;&#39;type&#39; is &quot;, type);
4698             MediaEngineSupportParameters parameters;
4699             parameters.type = ContentType(type);
4700             parameters.url = mediaURL;
4701 #if ENABLE(MEDIA_SOURCE)
4702             parameters.isMediaSource = mediaURL.protocolIs(mediaSourceBlobProtocol);
4703 #endif
4704 #if ENABLE(MEDIA_STREAM)
4705             parameters.isMediaStream = mediaURL.protocolIs(mediaStreamBlobProtocol);
4706 #endif
4707             if (!document().settings().allowMediaContentTypesRequiringHardwareSupportAsFallback() || Traversal&lt;HTMLSourceElement&gt;::nextSkippingChildren(source))
4708                 parameters.contentTypesRequiringHardwareSupport = mediaContentTypesRequiringHardwareSupport();
4709 
<span class="line-modified">4710             if (!MediaPlayer::supportsType(parameters))</span>
4711                 goto CheckAgain;
4712         }
4713 
4714         // Is it safe to load this url?
4715         if (!isSafeToLoadURL(mediaURL, actionIfInvalid) || !dispatchBeforeLoadEvent(mediaURL.string()))
4716             goto CheckAgain;
4717 
4718         // A &#39;beforeload&#39; event handler can mutate the DOM, so check to see if the source element is still a child node.
4719         if (source-&gt;parentNode() != this) {
4720             INFO_LOG(LOGIDENTIFIER, &quot;&#39;beforeload&#39; removed current element&quot;);
4721             continue;
4722         }
4723 
4724         // Making it this far means the &lt;source&gt; looks reasonable.
4725         if (contentType)
4726             *contentType = ContentType(type);
4727         m_nextChildNodeToConsider = Traversal&lt;HTMLSourceElement&gt;::nextSkippingChildren(source);
4728         m_currentSourceNode = WTFMove(source);
4729 
4730         if (shouldLog)
</pre>
<hr />
<pre>
4804     if (willLog(WTFLogLevel::Info) &amp;&amp; source.hasTagName(sourceTag)) {
4805         URL url = source.getNonEmptyURLAttribute(srcAttr);
4806         INFO_LOG(LOGIDENTIFIER, &quot;&#39;src&#39; is &quot;, url);
4807     }
4808 
4809     if (&amp;source != m_currentSourceNode &amp;&amp; &amp;source != m_nextChildNodeToConsider)
4810         return;
4811 
4812     if (&amp;source == m_nextChildNodeToConsider) {
4813         m_nextChildNodeToConsider = m_currentSourceNode ? Traversal&lt;HTMLSourceElement&gt;::nextSibling(*m_currentSourceNode) : nullptr;
4814         INFO_LOG(LOGIDENTIFIER);
4815     } else if (&amp;source == m_currentSourceNode) {
4816         // Clear the current source node pointer, but don&#39;t change the movie as the spec says:
4817         // 4.8.8 - Dynamically modifying a source element and its attribute when the element is already
4818         // inserted in a video or audio element will have no effect.
4819         m_currentSourceNode = nullptr;
4820         INFO_LOG(LOGIDENTIFIER, &quot;m_currentSourceNode cleared&quot;);
4821     }
4822 }
4823 
<span class="line-modified">4824 void HTMLMediaElement::mediaPlayerTimeChanged(MediaPlayer*)</span>
4825 {
4826     INFO_LOG(LOGIDENTIFIER);
4827 
4828 #if ENABLE(VIDEO_TRACK)
4829     updateActiveTextTrackCues(currentMediaTime());
4830 #endif
4831 
4832     beginProcessingMediaPlayerCallback();
4833 
4834     invalidateCachedTime();
4835     bool wasSeeking = seeking();
4836 
4837     // 4.8.10.9 step 14 &amp; 15.  Needed if no ReadyState change is associated with the seek.
4838     if (m_seekRequested &amp;&amp; m_readyState &gt;= HAVE_CURRENT_DATA &amp;&amp; !m_player-&gt;seeking())
4839         finishSeek();
4840 
4841     // Always call scheduleTimeupdateEvent when the media engine reports a time discontinuity,
4842     // it will only queue a &#39;timeupdate&#39; event if we haven&#39;t already posted one at the current
4843     // movie time.
4844     else
</pre>
<hr />
<pre>
4932         if (!paused())
4933             pauseInternal();
4934     }
4935 #else
4936     fastSeek(position);
4937 #endif
4938 }
4939 
4940 void HTMLMediaElement::seekToPlaybackPositionEndedTimerFired()
4941 {
4942 #if PLATFORM(MAC)
4943     if (!m_isScrubbingRemotely)
4944         return;
4945 
4946     PlatformMediaSessionManager::sharedManager().sessionDidEndRemoteScrubbing(*m_mediaSession);
4947     m_isScrubbingRemotely = false;
4948     m_seekToPlaybackPositionEndedTimer.stop();
4949 #endif
4950 }
4951 
<span class="line-modified">4952 void HTMLMediaElement::mediaPlayerVolumeChanged(MediaPlayer*)</span>
4953 {
4954     INFO_LOG(LOGIDENTIFIER);
4955 
4956     beginProcessingMediaPlayerCallback();
4957     if (m_player) {
4958         double vol = m_player-&gt;volume();
4959         if (vol != m_volume) {
4960             m_volume = vol;
4961             updateVolume();
4962             scheduleEvent(eventNames().volumechangeEvent);
4963         }
4964     }
4965     endProcessingMediaPlayerCallback();
4966 }
4967 
<span class="line-modified">4968 void HTMLMediaElement::mediaPlayerMuteChanged(MediaPlayer*)</span>
4969 {
4970     INFO_LOG(LOGIDENTIFIER);
4971 
4972     beginProcessingMediaPlayerCallback();
4973     if (m_player)
4974         setMuted(m_player-&gt;muted());
4975     endProcessingMediaPlayerCallback();
4976 }
4977 
<span class="line-modified">4978 void HTMLMediaElement::mediaPlayerDurationChanged(MediaPlayer* player)</span>
4979 {
4980     INFO_LOG(LOGIDENTIFIER);
4981 
4982     beginProcessingMediaPlayerCallback();
4983 
4984     scheduleEvent(eventNames().durationchangeEvent);
<span class="line-modified">4985     mediaPlayerCharacteristicChanged(player);</span>
4986 
4987     MediaTime now = currentMediaTime();
4988     MediaTime dur = durationMediaTime();
4989     if (now &gt; dur)
4990         seekInternal(dur);
4991 
4992     endProcessingMediaPlayerCallback();
4993 }
4994 
<span class="line-modified">4995 void HTMLMediaElement::mediaPlayerRateChanged(MediaPlayer*)</span>
4996 {
4997     beginProcessingMediaPlayerCallback();
4998 
4999     // Stash the rate in case the one we tried to set isn&#39;t what the engine is
5000     // using (eg. it can&#39;t handle the rate we set)
5001     m_reportedPlaybackRate = m_player-&gt;rate();
5002 
5003     INFO_LOG(LOGIDENTIFIER, &quot;rate: &quot;, m_reportedPlaybackRate);
5004 
5005     if (m_playing)
5006         invalidateCachedTime();
5007 
5008     updateSleepDisabling();
5009 
5010     endProcessingMediaPlayerCallback();
5011 }
5012 
<span class="line-modified">5013 void HTMLMediaElement::mediaPlayerPlaybackStateChanged(MediaPlayer*)</span>
5014 {
5015     INFO_LOG(LOGIDENTIFIER);
5016 
5017     if (!m_player || m_pausedInternal)
5018         return;
5019 
5020     beginProcessingMediaPlayerCallback();
5021     if (m_player-&gt;paused())
5022         pauseInternal();
5023     else
5024         playInternal();
5025 
5026     updateSleepDisabling();
5027 
5028     endProcessingMediaPlayerCallback();
5029 }
5030 
<span class="line-modified">5031 void HTMLMediaElement::mediaPlayerSawUnsupportedTracks(MediaPlayer*)</span>
<span class="line-removed">5032 {</span>
<span class="line-removed">5033     INFO_LOG(LOGIDENTIFIER);</span>
<span class="line-removed">5034 </span>
<span class="line-removed">5035     // The MediaPlayer came across content it cannot completely handle.</span>
<span class="line-removed">5036     // This is normally acceptable except when we are in a standalone</span>
<span class="line-removed">5037     // MediaDocument. If so, tell the document what has happened.</span>
<span class="line-removed">5038     if (is&lt;MediaDocument&gt;(document()))</span>
<span class="line-removed">5039         downcast&lt;MediaDocument&gt;(document()).mediaElementSawUnsupportedTracks();</span>
<span class="line-removed">5040 }</span>
<span class="line-removed">5041 </span>
<span class="line-removed">5042 void HTMLMediaElement::mediaPlayerResourceNotSupported(MediaPlayer*)</span>
5043 {
5044     INFO_LOG(LOGIDENTIFIER);
5045 
5046     // The MediaPlayer came across content which no installed engine supports.
<span class="line-modified">5047     mediaLoadingFailed(MediaPlayer::FormatError);</span>
5048 }
5049 
5050 // MediaPlayerPresentation methods
<span class="line-modified">5051 void HTMLMediaElement::mediaPlayerRepaint(MediaPlayer*)</span>
5052 {
5053     beginProcessingMediaPlayerCallback();
5054     updateDisplayState();
5055     if (auto* renderer = this-&gt;renderer())
5056         renderer-&gt;repaint();
5057     endProcessingMediaPlayerCallback();
5058 }
5059 
<span class="line-modified">5060 void HTMLMediaElement::mediaPlayerSizeChanged(MediaPlayer*)</span>
5061 {
5062     INFO_LOG(LOGIDENTIFIER);
5063 
5064     if (is&lt;MediaDocument&gt;(document()) &amp;&amp; m_player)
5065         downcast&lt;MediaDocument&gt;(document()).mediaElementNaturalSizeChanged(expandedIntSize(m_player-&gt;naturalSize()));
5066 
5067     beginProcessingMediaPlayerCallback();
5068     if (m_readyState &gt; HAVE_NOTHING)
5069         scheduleResizeEventIfSizeChanged();
5070     updateRenderer();
5071     endProcessingMediaPlayerCallback();
5072 }
5073 
<span class="line-modified">5074 bool HTMLMediaElement::mediaPlayerRenderingCanBeAccelerated(MediaPlayer*)</span>
5075 {
5076     auto* renderer = this-&gt;renderer();
5077     return is&lt;RenderVideo&gt;(renderer)
5078         &amp;&amp; downcast&lt;RenderVideo&gt;(*renderer).view().compositor().canAccelerateVideoRendering(downcast&lt;RenderVideo&gt;(*renderer));
5079 }
5080 
<span class="line-modified">5081 void HTMLMediaElement::mediaPlayerRenderingModeChanged(MediaPlayer*)</span>
5082 {
5083     INFO_LOG(LOGIDENTIFIER);
5084 
5085     // Kick off a fake recalcStyle that will update the compositing tree.
5086     invalidateStyleAndLayerComposition();
5087 }
5088 
5089 bool HTMLMediaElement::mediaPlayerAcceleratedCompositingEnabled()
5090 {
5091     return document().settings().acceleratedCompositingEnabled();
5092 }
5093 
5094 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
5095 
<span class="line-modified">5096 GraphicsDeviceAdapter* HTMLMediaElement::mediaPlayerGraphicsDeviceAdapter(const MediaPlayer*) const</span>
5097 {
5098     auto* page = document().page();
5099     if (!page)
5100         return nullptr;
5101     return page-&gt;chrome().client().graphicsDeviceAdapter();
5102 }
5103 
5104 #endif
5105 
5106 void HTMLMediaElement::scheduleMediaEngineWasUpdated()
5107 {
5108     if (m_mediaEngineUpdatedTask.hasPendingTask())
5109         return;
5110 
5111     auto logSiteIdentifier = LOGIDENTIFIER;
5112     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
5113     m_mediaEngineUpdatedTask.scheduleTask([this, logSiteIdentifier] {
5114         UNUSED_PARAM(logSiteIdentifier);
5115         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
5116         Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // mediaEngineWasUpdated calls methods that can trigger arbitrary DOM mutations.
</pre>
<hr />
<pre>
5136 #endif
5137 
5138 #if ENABLE(ENCRYPTED_MEDIA)
5139     if (m_player &amp;&amp; m_mediaKeys)
5140         m_player-&gt;cdmInstanceAttached(m_mediaKeys-&gt;cdmInstance());
5141 #endif
5142 
5143 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
5144     if (!m_player)
5145         return;
5146     m_player-&gt;setVideoFullscreenFrame(m_videoFullscreenFrame);
5147     m_player-&gt;setVideoFullscreenGravity(m_videoFullscreenGravity);
5148     m_player-&gt;setVideoFullscreenLayer(m_videoFullscreenLayer.get());
5149 #endif
5150 
5151 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5152     scheduleUpdateMediaState();
5153 #endif
5154 }
5155 
<span class="line-modified">5156 void HTMLMediaElement::mediaPlayerEngineUpdated(MediaPlayer*)</span>
5157 {
5158     INFO_LOG(LOGIDENTIFIER);
5159 
5160 #if ENABLE(MEDIA_SOURCE)
5161     m_droppedVideoFrames = 0;
5162 #endif
5163 
5164     m_havePreparedToPlay = false;
5165 
5166     scheduleMediaEngineWasUpdated();
5167 }
5168 
<span class="line-modified">5169 void HTMLMediaElement::mediaPlayerFirstVideoFrameAvailable(MediaPlayer*)</span>
5170 {
5171     INFO_LOG(LOGIDENTIFIER, &quot;current display mode = &quot;, (int)displayMode());
5172 
5173     beginProcessingMediaPlayerCallback();
5174     if (displayMode() == PosterWaitingForVideo) {
5175         setDisplayMode(Video);
<span class="line-modified">5176         mediaPlayerRenderingModeChanged(m_player.get());</span>
5177     }
5178     endProcessingMediaPlayerCallback();
5179 }
5180 
<span class="line-modified">5181 void HTMLMediaElement::mediaPlayerCharacteristicChanged(MediaPlayer*)</span>
5182 {
5183     INFO_LOG(LOGIDENTIFIER);
5184 
5185     beginProcessingMediaPlayerCallback();
5186 
5187 #if ENABLE(VIDEO_TRACK)
5188     if (captionDisplayMode() == CaptionUserPreferences::Automatic &amp;&amp; m_subtitleTrackLanguage != m_player-&gt;languageOfPrimaryAudioTrack())
5189         markCaptionAndSubtitleTracksAsUnconfigured(AfterDelay);
5190 #endif
5191 
5192     if (potentiallyPlaying() &amp;&amp; displayMode() == PosterWaitingForVideo) {
5193         setDisplayMode(Video);
<span class="line-modified">5194         mediaPlayerRenderingModeChanged(m_player.get());</span>
5195     }
5196 
5197     if (hasMediaControls())
5198         mediaControls()-&gt;reset();
5199     updateRenderer();
5200 
5201     if (!paused() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
5202         pauseInternal();
5203         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
5204     }
5205 
5206 #if ENABLE(MEDIA_SESSION)
5207     document().updateIsPlayingMedia(m_elementID);
5208 #else
5209     document().updateIsPlayingMedia();
5210 #endif
5211 
5212     m_hasEverHadAudio |= hasAudio();
5213     m_hasEverHadVideo |= hasVideo();
5214 
</pre>
<hr />
<pre>
5510     if (m_playing)
5511         scheduleNotifyAboutPlaying();
5512 
5513 #if ENABLE(MEDIA_SESSION)
5514     document().updateIsPlayingMedia(m_elementID);
5515 #else
5516     document().updateIsPlayingMedia();
5517 #endif
5518 
5519 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5520     scheduleUpdateMediaState();
5521 #endif
5522 }
5523 
5524 void HTMLMediaElement::setPausedInternal(bool b)
5525 {
5526     m_pausedInternal = b;
5527     scheduleUpdatePlayState();
5528 }
5529 






5530 void HTMLMediaElement::stopPeriodicTimers()
5531 {
5532     m_progressEventTimer.stop();
5533     m_playbackProgressTimer.stop();
5534 }
5535 
5536 void HTMLMediaElement::cancelPendingTasks()
5537 {
5538     m_configureTextTracksTask.cancelTask();
5539     m_checkPlaybackTargetCompatablityTask.cancelTask();
5540     m_updateMediaStateTask.cancelTask();
5541     m_mediaEngineUpdatedTask.cancelTask();
5542     m_updatePlayStateTask.cancelTask();
5543 #if PLATFORM(IOS_FAMILY)
5544     m_volumeRevertTaskQueue.cancelTask();
5545 #endif
5546 }
5547 
5548 void HTMLMediaElement::userCancelledLoad()
5549 {
</pre>
<hr />
<pre>
5604 }
5605 
5606 void HTMLMediaElement::clearMediaPlayer()
5607 {
5608 #if ENABLE(MEDIA_STREAM)
5609     if (!m_settingMediaStreamSrcObject)
5610         m_mediaStreamSrcObject = nullptr;
5611 #endif
5612 
5613 #if ENABLE(MEDIA_SOURCE)
5614     detachMediaSource();
5615 #endif
5616 
5617     m_blob = nullptr;
5618 
5619 #if ENABLE(VIDEO_TRACK)
5620     forgetResourceSpecificTracks();
5621 #endif
5622 
5623 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified">5624     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent)) {</span>
5625         m_hasPlaybackTargetAvailabilityListeners = false;
5626         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
5627 
5628         // Send an availability event in case scripts want to hide the picker when the element
5629         // doesn&#39;t support playback to a target.
5630         enqueuePlaybackTargetAvailabilityChangedEvent();
5631     }
5632 
5633     if (m_isPlayingToWirelessTarget)
5634         setIsPlayingToWirelessTarget(false);
5635 #endif
5636 
5637     if (m_isWaitingUntilMediaCanStart) {
5638         m_isWaitingUntilMediaCanStart = false;
5639         document().removeMediaCanStartListener(*this);
5640     }
5641 
5642     if (m_player) {
5643         m_player-&gt;invalidate();
5644         m_player = nullptr;
</pre>
<hr />
<pre>
5646     schedulePlaybackControlsManagerUpdate();
5647 
5648     stopPeriodicTimers();
5649     cancelPendingTasks();
5650 
5651     m_loadState = WaitingForSource;
5652 
5653 #if ENABLE(VIDEO_TRACK)
5654     if (m_textTracks)
5655         configureTextTrackDisplay();
5656 #endif
5657 
5658     m_mediaSession-&gt;clientCharacteristicsChanged();
5659     m_mediaSession-&gt;canProduceAudioChanged();
5660 
5661     m_resourceSelectionTaskQueue.cancelAllTasks();
5662 
5663     updateSleepDisabling();
5664 }
5665 
<span class="line-removed">5666 bool HTMLMediaElement::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">5667 {</span>
<span class="line-removed">5668     return true;</span>
<span class="line-removed">5669 }</span>
<span class="line-removed">5670 </span>
5671 const char* HTMLMediaElement::activeDOMObjectName() const
5672 {
5673     return &quot;HTMLMediaElement&quot;;
5674 }
5675 
5676 void HTMLMediaElement::stopWithoutDestroyingMediaPlayer()
5677 {
5678     INFO_LOG(LOGIDENTIFIER);
5679 
5680     if (m_videoFullscreenMode != VideoFullscreenModeNone)
5681         exitFullscreen();
5682 
5683     setPreparedToReturnVideoLayerToInline(true);
5684 
5685     schedulePlaybackControlsManagerUpdate();
5686     setInActiveDocument(false);
5687 
5688     // Stop the playback without generating events
5689     setPlaying(false);
<span class="line-modified">5690     setPausedInternal(true);</span>
<span class="line-modified">5691     m_mediaSession-&gt;stopSession();</span>
5692 
5693     setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
5694 
5695     userCancelledLoad();
5696 
5697     updateRenderer();
5698 
5699     stopPeriodicTimers();
5700 
5701     updateSleepDisabling();
5702 }
5703 
5704 void HTMLMediaElement::closeTaskQueues()
5705 {
5706     m_configureTextTracksTask.close();
5707     m_checkPlaybackTargetCompatablityTask.close();
5708     m_updateMediaStateTask.close();
5709     m_mediaEngineUpdatedTask.close();
5710     m_updatePlayStateTask.close();
5711     m_resumeTaskQueue.close();
5712     m_seekTaskQueue.close();
5713     m_playbackControlsManagerBehaviorRestrictionsQueue.close();
5714     m_seekTaskQueue.close();
5715     m_resumeTaskQueue.close();
5716     m_promiseTaskQueue.close();
5717     m_pauseAfterDetachedTaskQueue.close();
5718     m_resourceSelectionTaskQueue.close();
5719     m_visibilityChangeTaskQueue.close();
5720 #if ENABLE(ENCRYPTED_MEDIA)
5721     m_encryptedMediaQueue.close();
5722 #endif
<span class="line-modified">5723     m_asyncEventQueue.close();</span>
5724 #if PLATFORM(IOS_FAMILY)
5725     m_volumeRevertTaskQueue.close();
5726 #endif
5727 }
5728 
5729 void HTMLMediaElement::contextDestroyed()
5730 {
5731     closeTaskQueues();
5732     m_pendingPlayPromises.clear();
5733 
5734     ActiveDOMObject::contextDestroyed();
5735 }
5736 
5737 void HTMLMediaElement::stop()
5738 {
5739     INFO_LOG(LOGIDENTIFIER);
5740 
5741     Ref&lt;HTMLMediaElement&gt; protectedThis(*this);
5742     stopWithoutDestroyingMediaPlayer();
5743     closeTaskQueues();
5744 
5745     // Once an active DOM object has been stopped it can not be restarted, so we can deallocate
5746     // the media player now. Note that userCancelledLoad will already called clearMediaPlayer
5747     // if the media was not fully loaded, but we need the same cleanup if the file was completely
5748     // loaded and calling it again won&#39;t cause any problems.
5749     clearMediaPlayer();
5750 
5751     m_mediaSession-&gt;stopSession();
5752 }
5753 
5754 void HTMLMediaElement::suspend(ReasonForSuspension reason)
5755 {
5756     INFO_LOG(LOGIDENTIFIER);
5757     Ref&lt;HTMLMediaElement&gt; protectedThis(*this);
5758 
5759     m_resumeTaskQueue.cancelTask();
5760 
5761     switch (reason) {
<span class="line-modified">5762     case ReasonForSuspension::PageCache:</span>
5763         stopWithoutDestroyingMediaPlayer();
<span class="line-removed">5764         m_asyncEventQueue.suspend();</span>
5765         setBufferingPolicy(BufferingPolicy::MakeResourcesPurgeable);
5766         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
5767         break;
5768     case ReasonForSuspension::PageWillBeSuspended:
5769     case ReasonForSuspension::JavaScriptDebuggerPaused:
5770     case ReasonForSuspension::WillDeferLoading:
5771         // Do nothing, we don&#39;t pause media playback in these cases.
5772         break;
5773     }
5774 }
5775 
5776 void HTMLMediaElement::resume()
5777 {
5778     INFO_LOG(LOGIDENTIFIER);
5779 
5780     setInActiveDocument(true);
5781 
<span class="line-removed">5782     m_asyncEventQueue.resume();</span>
<span class="line-removed">5783 </span>
5784     if (!m_mediaSession-&gt;pageAllowsPlaybackAfterResuming())
5785         document().addMediaCanStartListener(*this);
5786     else
5787         setPausedInternal(false);
5788 
5789     m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
5790     m_mediaSession-&gt;updateBufferingPolicy();
5791 
5792     if (m_error &amp;&amp; m_error-&gt;code() == MediaError::MEDIA_ERR_ABORTED &amp;&amp; !m_resumeTaskQueue.hasPendingTask()) {
<span class="line-modified">5793         // Restart the load if it was aborted in the middle by moving the document to the page cache.</span>
5794         // m_error is only left at MEDIA_ERR_ABORTED when the document becomes inactive (it is set to
5795         //  MEDIA_ERR_ABORTED while the abortEvent is being sent, but cleared immediately afterwards).
5796         // This behavior is not specified but it seems like a sensible thing to do.
5797         // As it is not safe to immedately start loading now, let&#39;s schedule a load.
5798         m_resumeTaskQueue.scheduleTask(std::bind(&amp;HTMLMediaElement::prepareForLoad, this));
5799     }
5800 
5801     updateRenderer();
5802 }
5803 
5804 bool HTMLMediaElement::hasPendingActivity() const
5805 {
<span class="line-modified">5806     return (hasAudio() &amp;&amp; isPlaying()) || m_asyncEventQueue.hasPendingEvents() || m_creatingControls;</span>
5807 }
5808 
5809 void HTMLMediaElement::mediaVolumeDidChange()
5810 {


5811     INFO_LOG(LOGIDENTIFIER);
5812     updateVolume();

5813 }
5814 
5815 void HTMLMediaElement::visibilityStateChanged()
5816 {
5817     bool elementIsHidden = document().hidden() &amp;&amp; m_videoFullscreenMode != VideoFullscreenModePictureInPicture;
5818     if (elementIsHidden == m_elementIsHidden)
5819         return;
5820 
5821     m_elementIsHidden = elementIsHidden;
5822     INFO_LOG(LOGIDENTIFIER, &quot;visible = &quot;, !m_elementIsHidden);
5823 
5824     updateSleepDisabling();
5825     m_mediaSession-&gt;visibilityChanged();
5826     if (m_player)
5827         m_player-&gt;setVisible(!m_elementIsHidden);
5828 
5829     bool isPlayingAudio = isPlaying() &amp;&amp; hasAudio() &amp;&amp; !muted() &amp;&amp; volume();
5830     if (!isPlayingAudio) {
5831         if (m_elementIsHidden) {
5832             ALWAYS_LOG(LOGIDENTIFIER, &quot;Suspending playback after going to the background&quot;);
</pre>
<hr />
<pre>
5851 }
5852 
5853 void HTMLMediaElement::syncTextTrackBounds()
5854 {
5855     if (m_player)
5856         m_player-&gt;syncTextTrackBounds();
5857 }
5858 #endif // ENABLE(VIDEO_TRACK)
5859 
5860 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5861 void HTMLMediaElement::webkitShowPlaybackTargetPicker()
5862 {
5863     ALWAYS_LOG(LOGIDENTIFIER);
5864     if (processingUserGestureForMedia())
5865         removeBehaviorRestrictionsAfterFirstUserGesture();
5866     m_mediaSession-&gt;showPlaybackTargetPicker();
5867 }
5868 
5869 void HTMLMediaElement::wirelessRoutesAvailableDidChange()
5870 {



5871     enqueuePlaybackTargetAvailabilityChangedEvent();
5872 }
5873 
<span class="line-modified">5874 void HTMLMediaElement::mediaPlayerCurrentPlaybackTargetIsWirelessChanged(MediaPlayer*)</span>
5875 {
<span class="line-modified">5876     setIsPlayingToWirelessTarget(m_player &amp;&amp; m_player-&gt;isCurrentPlaybackTargetWireless());</span>
5877 }
5878 
5879 void HTMLMediaElement::setIsPlayingToWirelessTarget(bool isPlayingToWirelessTarget)
5880 {
5881     m_playbackTargetIsWirelessQueue.enqueueTask([this, isPlayingToWirelessTarget] {
5882         if (isPlayingToWirelessTarget == m_isPlayingToWirelessTarget)
5883             return;
5884         m_isPlayingToWirelessTarget = m_player &amp;&amp; m_player-&gt;isCurrentPlaybackTargetWireless();
<span class="line-modified">5885 </span>
5886         ALWAYS_LOG(LOGIDENTIFIER, m_isPlayingToWirelessTarget);
5887         configureMediaControls();
5888         m_mediaSession-&gt;isPlayingToWirelessPlaybackTargetChanged(m_isPlayingToWirelessTarget);
5889         m_mediaSession-&gt;canProduceAudioChanged();
5890         scheduleUpdateMediaState();
5891         updateSleepDisabling();
5892 
5893         m_failedToPlayToWirelessTarget = false;
5894         scheduleCheckPlaybackTargetCompatability();
5895 
5896         dispatchEvent(Event::create(eventNames().webkitcurrentplaybacktargetiswirelesschangedEvent, Event::CanBubble::No, Event::IsCancelable::Yes));
5897     });
5898 }
5899 
5900 void HTMLMediaElement::dispatchEvent(Event&amp; event)
5901 {
5902     DEBUG_LOG(LOGIDENTIFIER, event.type());
5903 
5904     if (m_removedBehaviorRestrictionsAfterFirstUserGesture &amp;&amp; event.type() == eventNames().endedEvent)
5905         document().userActivatedMediaFinishedPlaying();
5906 
5907     HTMLElement::dispatchEvent(event);
5908 }
5909 
5910 bool HTMLMediaElement::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)
5911 {
5912     if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
5913         return Node::addEventListener(eventType, WTFMove(listener), options);
5914 
<span class="line-modified">5915     bool isFirstAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent);</span>

5916     if (!Node::addEventListener(eventType, WTFMove(listener), options))
5917         return false;
5918 
5919     if (isFirstAvailabilityChangedListener) {
5920         m_hasPlaybackTargetAvailabilityListeners = true;
5921         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(true);
5922     }
5923 
5924     INFO_LOG(LOGIDENTIFIER, &quot;&#39;webkitplaybacktargetavailabilitychanged&#39;&quot;);
5925 
5926     enqueuePlaybackTargetAvailabilityChangedEvent(); // Ensure the event listener gets at least one event.
5927     return true;
5928 }
5929 
5930 bool HTMLMediaElement::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)
5931 {
5932     if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
5933         return Node::removeEventListener(eventType, listener, options);
5934 
5935     if (!Node::removeEventListener(eventType, listener, options))
5936         return false;
5937 
<span class="line-modified">5938     bool didRemoveLastAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent);</span>
5939     INFO_LOG(LOGIDENTIFIER, &quot;removed last listener = &quot;, didRemoveLastAvailabilityChangedListener);
5940     if (didRemoveLastAvailabilityChangedListener) {
5941         m_hasPlaybackTargetAvailabilityListeners = false;
5942         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
5943         scheduleUpdateMediaState();
5944     }
5945 
5946     return true;
5947 }
5948 
5949 void HTMLMediaElement::enqueuePlaybackTargetAvailabilityChangedEvent()
5950 {
5951     bool hasTargets = m_mediaSession-&gt;hasWirelessPlaybackTargets();
5952     INFO_LOG(LOGIDENTIFIER, &quot;hasTargets = &quot;, hasTargets);
5953     auto event = WebKitPlaybackTargetAvailabilityEvent::create(eventNames().webkitplaybacktargetavailabilitychangedEvent, hasTargets);
5954     event-&gt;setTarget(this);
<span class="line-modified">5955     m_asyncEventQueue.enqueueEvent(WTFMove(event));</span>
5956     scheduleUpdateMediaState();
5957 }
5958 
5959 void HTMLMediaElement::setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; device)
5960 {
5961     ALWAYS_LOG(LOGIDENTIFIER);

5962     if (m_player)
5963         m_player-&gt;setWirelessPlaybackTarget(WTFMove(device));


5964 }
5965 
5966 void HTMLMediaElement::setShouldPlayToPlaybackTarget(bool shouldPlay)
5967 {
5968     ALWAYS_LOG(LOGIDENTIFIER, shouldPlay);
5969 
5970     if (m_player)
5971         m_player-&gt;setShouldPlayToPlaybackTarget(shouldPlay);
5972 }
5973 
















5974 #endif // ENABLE(WIRELESS_PLAYBACK_TARGET)
5975 
5976 bool HTMLMediaElement::webkitCurrentPlaybackTargetIsWireless() const
5977 {
5978     INFO_LOG(LOGIDENTIFIER, m_isPlayingToWirelessTarget);
5979     return m_isPlayingToWirelessTarget;
5980 }
5981 
5982 void HTMLMediaElement::setPlayingOnSecondScreen(bool value)
5983 {
5984     if (value == m_playingOnSecondScreen)
5985         return;
5986 
5987     m_playingOnSecondScreen = value;
5988 
5989 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5990     scheduleUpdateMediaState();
5991 #endif
5992 }
5993 
</pre>
<hr />
<pre>
6017 bool HTMLMediaElement::isStandardFullscreen() const
6018 {
6019 #if ENABLE(FULLSCREEN_API)
6020     if (document().fullscreenManager().isFullscreen() &amp;&amp; document().fullscreenManager().currentFullscreenElement() == this)
6021         return true;
6022 #endif
6023 
6024     return m_videoFullscreenMode == VideoFullscreenModeStandard;
6025 }
6026 
6027 void HTMLMediaElement::toggleStandardFullscreenState()
6028 {
6029     if (isStandardFullscreen())
6030         exitFullscreen();
6031     else
6032         enterFullscreen();
6033 }
6034 
6035 void HTMLMediaElement::enterFullscreen(VideoFullscreenMode mode)
6036 {
<span class="line-modified">6037     INFO_LOG(LOGIDENTIFIER);</span>
6038     ASSERT(mode != VideoFullscreenModeNone);
6039 
6040     if (m_videoFullscreenMode == mode)
6041         return;
6042 
6043     m_temporarilyAllowingInlinePlaybackAfterFullscreen = false;
6044     m_waitingToEnterFullscreen = true;
6045 
6046 #if ENABLE(FULLSCREEN_API) &amp;&amp; ENABLE(VIDEO_USES_ELEMENT_FULLSCREEN)
6047     if (document().settings().fullScreenEnabled() &amp;&amp; mode == VideoFullscreenModeStandard) {
6048         document().fullscreenManager().requestFullscreenForElement(this, FullscreenManager::ExemptIFrameAllowFullscreenRequirement);
6049         return;
6050     }
6051 #endif
6052 
6053     m_fullscreenTaskQueue.enqueueTask([this, mode] {
6054         if (document().hidden()) {
6055             ALWAYS_LOG(LOGIDENTIFIER, &quot;  returning because document is hidden&quot;);
6056             return;
6057         }
6058 
6059         fullscreenModeChanged(mode);
6060         configureMediaControls();
6061         if (hasMediaControls())
6062             mediaControls()-&gt;enteredFullscreen();
6063         if (is&lt;HTMLVideoElement&gt;(*this)) {
6064             HTMLVideoElement&amp; asVideo = downcast&lt;HTMLVideoElement&gt;(*this);
6065             if (document().page()-&gt;chrome().client().supportsVideoFullscreen(m_videoFullscreenMode)) {

6066                 document().page()-&gt;chrome().client().enterVideoFullscreenForVideoElement(asVideo, m_videoFullscreenMode, m_videoFullscreenStandby);
6067                 scheduleEvent(eventNames().webkitbeginfullscreenEvent);
6068             }
6069         }
6070     });
6071 }
6072 
6073 void HTMLMediaElement::enterFullscreen()
6074 {
6075     enterFullscreen(VideoFullscreenModeStandard);
6076 }
6077 
6078 void HTMLMediaElement::exitFullscreen()
6079 {
6080     INFO_LOG(LOGIDENTIFIER);
6081 
6082     m_waitingToEnterFullscreen = false;
6083 
6084 #if ENABLE(FULLSCREEN_API)
6085     if (document().settings().fullScreenEnabled() &amp;&amp; document().fullscreenManager().currentFullscreenElement() == this) {
</pre>
<hr />
<pre>
6164 
6165 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
6166     switch (oldVideoFullscreenMode) {
6167     case VideoFullscreenModeNone:
6168     case VideoFullscreenModeStandard:
6169         // Don&#39;t need to do anything if we are not in any special fullscreen mode or it&#39;s already
6170         // in standard fullscreen mode.
6171         break;
6172     case VideoFullscreenModePictureInPicture:
6173         if (is&lt;HTMLVideoElement&gt;(*this))
6174             downcast&lt;HTMLVideoElement&gt;(this)-&gt;exitToFullscreenModeWithoutAnimationIfPossible(oldVideoFullscreenMode, VideoFullscreenModeStandard);
6175         break;
6176     }
6177 #endif
6178 
6179     Element::willBecomeFullscreenElement();
6180 }
6181 
6182 void HTMLMediaElement::didBecomeFullscreenElement()
6183 {

6184     m_waitingToEnterFullscreen = false;
6185     if (hasMediaControls())
6186         mediaControls()-&gt;enteredFullscreen();
6187     scheduleUpdatePlayState();
6188 }
6189 
6190 void HTMLMediaElement::willStopBeingFullscreenElement()
6191 {
6192     if (hasMediaControls())
6193         mediaControls()-&gt;exitedFullscreen();
6194 
6195     if (fullscreenMode() == VideoFullscreenModeStandard)
6196         fullscreenModeChanged(VideoFullscreenModeNone);
6197 }
6198 
6199 PlatformLayer* HTMLMediaElement::platformLayer() const
6200 {
6201     return m_player ? m_player-&gt;platformLayer() : nullptr;
6202 }
6203 
6204 void HTMLMediaElement::setPreparedToReturnVideoLayerToInline(bool value)
6205 {
6206     m_preparedForInline = value;
6207     if (m_preparedForInline &amp;&amp; m_preparedForInlineCompletionHandler) {
6208         m_preparedForInlineCompletionHandler();
6209         m_preparedForInlineCompletionHandler = nullptr;
6210     }
6211 }
6212 
6213 void HTMLMediaElement::waitForPreparedForInlineThen(WTF::Function&lt;void()&gt;&amp;&amp; completionHandler)
6214 {

6215     ASSERT(!m_preparedForInlineCompletionHandler);
6216     if (m_preparedForInline)  {
6217         completionHandler();
6218         return;
6219     }
6220 
6221     m_preparedForInlineCompletionHandler = WTFMove(completionHandler);
6222 }
6223 
6224 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
6225 
6226 void HTMLMediaElement::willExitFullscreen()
6227 {
6228     if (m_player)
6229         m_player-&gt;updateVideoFullscreenInlineImage();
6230 }
6231 
6232 bool HTMLMediaElement::isVideoLayerInline()
6233 {
6234     return !m_videoFullscreenLayer;
6235 };
6236 
6237 void HTMLMediaElement::setVideoFullscreenLayer(PlatformLayer* platformLayer, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler)
6238 {

6239     m_videoFullscreenLayer = platformLayer;
6240     if (!m_player) {
6241         completionHandler();
6242         return;
6243     }
6244 
6245     m_player-&gt;setVideoFullscreenLayer(platformLayer, WTFMove(completionHandler));
6246     invalidateStyleAndLayerComposition();
6247 #if ENABLE(VIDEO_TRACK)
6248     updateTextTrackDisplay();
6249 #endif
6250 }
6251 
6252 void HTMLMediaElement::setVideoFullscreenFrame(FloatRect frame)
6253 {
6254     m_videoFullscreenFrame = frame;
6255     if (m_player)
6256         m_player-&gt;setVideoFullscreenFrame(frame);
6257 }
6258 
</pre>
<hr />
<pre>
6425     return MediaPlayer::originsInMediaCache(path);
6426 }
6427 
6428 void HTMLMediaElement::clearMediaCache(const String&amp; path, WallTime modifiedSince)
6429 {
6430     MediaPlayer::clearMediaCache(path, modifiedSince);
6431 }
6432 
6433 void HTMLMediaElement::clearMediaCacheForOrigins(const String&amp; path, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp; origins)
6434 {
6435     MediaPlayer::clearMediaCacheForOrigins(path, origins);
6436 }
6437 
6438 void HTMLMediaElement::resetMediaEngines()
6439 {
6440     MediaPlayer::resetMediaEngines();
6441 }
6442 
6443 void HTMLMediaElement::privateBrowsingStateDidChange(PAL::SessionID sessionID)
6444 {




6445     if (!m_player)
6446         return;
6447 
6448     m_player-&gt;setPrivateBrowsingMode(sessionID.isEphemeral());

6449 }
6450 
6451 MediaControls* HTMLMediaElement::mediaControls() const
6452 {
6453 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6454     return nullptr;
6455 #else
6456     auto root = userAgentShadowRoot();
6457     if (!root)
6458         return nullptr;
6459 
6460     return childrenOfType&lt;MediaControls&gt;(*root).first();
6461 #endif
6462 }
6463 
6464 bool HTMLMediaElement::hasMediaControls() const
6465 {
6466 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6467     return false;
6468 #else
</pre>
<hr />
<pre>
6565     for (unsigned i = 0; i &lt; m_textTracks-&gt;length(); ++i) {
6566         if (m_textTracks-&gt;item(i)-&gt;mode() == TextTrack::Mode::Showing) {
6567             haveVisibleTextTrack = true;
6568             break;
6569         }
6570     }
6571 
6572     if (checkType == CheckTextTrackVisibility &amp;&amp; m_haveVisibleTextTrack == haveVisibleTextTrack) {
6573         updateActiveTextTrackCues(currentMediaTime());
6574         return;
6575     }
6576 
6577     m_haveVisibleTextTrack = haveVisibleTextTrack;
6578     m_closedCaptionsVisible = m_haveVisibleTextTrack;
6579 
6580 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6581     if (!m_haveVisibleTextTrack)
6582         return;
6583 
6584     ensureMediaControlsShadowRoot();

6585 #else
6586     if (!m_haveVisibleTextTrack &amp;&amp; !hasMediaControls())
6587         return;
6588     if (!hasMediaControls() &amp;&amp; !createMediaControls())
6589         return;
6590 
6591     mediaControls()-&gt;changedClosedCaptionsVisibility();
6592 
6593     updateTextTrackDisplay();
6594     updateActiveTextTrackCues(currentMediaTime());
6595 #endif
6596 }
6597 
6598 void HTMLMediaElement::captionPreferencesChanged()
6599 {
6600     if (!isVideo())
6601         return;
6602 
6603     if (hasMediaControls())
6604         mediaControls()-&gt;textTrackPreferencesChanged();
6605 
6606 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6607     if (m_mediaControlsHost)
<span class="line-modified">6608         m_mediaControlsHost-&gt;updateCaptionDisplaySizes();</span>
6609 #endif
6610 
6611     if (m_player)
6612         m_player-&gt;tracksChanged();
6613 
6614     if (!document().page())
6615         return;
6616 
6617     CaptionUserPreferences::CaptionDisplayMode displayMode = document().page()-&gt;group().captionPreferences().captionDisplayMode();
6618     if (captionDisplayMode() == displayMode)
6619         return;
6620 
6621     m_captionDisplayMode = displayMode;
6622     setWebkitClosedCaptionsVisible(captionDisplayMode() == CaptionUserPreferences::AlwaysOn);
6623 }
6624 
6625 CaptionUserPreferences::CaptionDisplayMode HTMLMediaElement::captionDisplayMode()
6626 {
6627     if (!m_captionDisplayMode.hasValue()) {
6628         if (document().page())
</pre>
<hr />
<pre>
6685 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
6686     if (m_isPlayingToWirelessTarget)
6687         setIsPlayingToWirelessTarget(false);
6688 #endif
6689 
6690     m_player = MediaPlayer::create(*this);
6691     m_player-&gt;setBufferingPolicy(m_bufferingPolicy);
6692     schedulePlaybackControlsManagerUpdate();
6693 
6694 #if ENABLE(WEB_AUDIO)
6695     if (m_audioSourceNode) {
6696         // When creating the player, make sure its AudioSourceProvider knows about the MediaElementAudioSourceNode.
6697         if (audioSourceProvider())
6698             audioSourceProvider()-&gt;setClient(m_audioSourceNode);
6699 
6700         m_audioSourceNode-&gt;unlock();
6701     }
6702 #endif
6703 
6704 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified">6705     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent)) {</span>
6706         m_hasPlaybackTargetAvailabilityListeners = true;
6707         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(true);
6708         enqueuePlaybackTargetAvailabilityChangedEvent(); // Ensure the event listener gets at least one event.
6709     }
6710 #endif
6711 
6712     updateSleepDisabling();
6713 }
6714 
6715 #if ENABLE(WEB_AUDIO)

6716 void HTMLMediaElement::setAudioSourceNode(MediaElementAudioSourceNode* sourceNode)
6717 {
6718     m_audioSourceNode = sourceNode;
6719 
6720     if (audioSourceProvider())
6721         audioSourceProvider()-&gt;setClient(m_audioSourceNode);
6722 }
6723 
6724 AudioSourceProvider* HTMLMediaElement::audioSourceProvider()
6725 {
6726     if (m_player)
6727         return m_player-&gt;audioSourceProvider();
6728 
<span class="line-modified">6729     return 0;</span>
6730 }

6731 #endif
6732 
6733 const String&amp; HTMLMediaElement::mediaGroup() const
6734 {
6735     return m_mediaGroup;
6736 }
6737 
6738 void HTMLMediaElement::setMediaGroup(const String&amp; group)
6739 {
6740     if (m_mediaGroup == group)
6741         return;
6742     m_mediaGroup = group;
6743 
6744     // When a media element is created with a mediagroup attribute, and when a media element&#39;s mediagroup
6745     // attribute is set, changed, or removed, the user agent must run the following steps:
6746     // 1. Let m [this] be the media element in question.
6747     // 2. Let m have no current media controller, if it currently has one.
6748     setController(nullptr);
6749 
6750     // 3. If m&#39;s mediagroup attribute is being removed, then abort these steps.
6751     if (group.isEmpty())
6752         return;
6753 
6754     // 4. If there is another media element whose Document is the same as m&#39;s Document (even if one or both
6755     // of these elements are not actually in the Document),
<span class="line-modified">6756     HashSet&lt;HTMLMediaElement*&gt; elements = documentToElementSetMap().get(&amp;document());</span>
<span class="line-modified">6757     for (auto&amp; element : elements) {</span>
<span class="line-removed">6758         if (element == this)</span>
<span class="line-removed">6759             continue;</span>
<span class="line-removed">6760 </span>
6761         // and which also has a mediagroup attribute, and whose mediagroup attribute has the same value as
6762         // the new value of m&#39;s mediagroup attribute,
<span class="line-modified">6763         if (element-&gt;mediaGroup() == group) {</span>
6764             //  then let controller be that media element&#39;s current media controller.
<span class="line-modified">6765             setController(element-&gt;controller());</span>
<span class="line-removed">6766             return;</span>
6767         }
<span class="line-modified">6768     }</span>
6769 
6770     // Otherwise, let controller be a newly created MediaController.
<span class="line-modified">6771     setController(MediaController::create(document()));</span>

6772 }
6773 
6774 MediaController* HTMLMediaElement::controller() const
6775 {
6776     return m_mediaController.get();
6777 }
6778 
6779 void HTMLMediaElement::setController(RefPtr&lt;MediaController&gt;&amp;&amp; controller)
6780 {
6781     if (m_mediaController)
6782         m_mediaController-&gt;removeMediaElement(*this);
6783 
6784     m_mediaController = WTFMove(controller);
6785 
6786     if (m_mediaController)
6787         m_mediaController-&gt;addMediaElement(*this);
6788 
6789     if (hasMediaControls())
6790         mediaControls()-&gt;setMediaController(m_mediaController ? m_mediaController.get() : static_cast&lt;MediaControllerInterface*&gt;(this));
6791 }
</pre>
<hr />
<pre>
7037 bool HTMLMediaElement::mediaPlayerIsVideo() const
7038 {
7039     return isVideo();
7040 }
7041 
7042 LayoutRect HTMLMediaElement::mediaPlayerContentBoxRect() const
7043 {
7044     auto* renderer = this-&gt;renderer();
7045     if (!renderer)
7046         return { };
7047     return renderer-&gt;enclosingBox().contentBoxRect();
7048 }
7049 
7050 float HTMLMediaElement::mediaPlayerContentsScale() const
7051 {
7052     if (auto page = document().page())
7053         return page-&gt;pageScaleFactor() * page-&gt;deviceScaleFactor();
7054     return 1;
7055 }
7056 
<span class="line-removed">7057 void HTMLMediaElement::mediaPlayerSetSize(const IntSize&amp; size)</span>
<span class="line-removed">7058 {</span>
<span class="line-removed">7059     setIntegralAttribute(widthAttr, size.width());</span>
<span class="line-removed">7060     setIntegralAttribute(heightAttr, size.height());</span>
<span class="line-removed">7061 }</span>
<span class="line-removed">7062 </span>
7063 void HTMLMediaElement::mediaPlayerPause()
7064 {
7065     pause();
7066 }
7067 
7068 void HTMLMediaElement::mediaPlayerPlay()
7069 {
7070     play();
7071 }
7072 
7073 bool HTMLMediaElement::mediaPlayerPlatformVolumeConfigurationRequired() const
7074 {
7075     return !m_volumeInitialized;
7076 }
7077 
<span class="line-removed">7078 bool HTMLMediaElement::mediaPlayerIsPaused() const</span>
<span class="line-removed">7079 {</span>
<span class="line-removed">7080     return paused();</span>
<span class="line-removed">7081 }</span>
<span class="line-removed">7082 </span>
7083 bool HTMLMediaElement::mediaPlayerIsLooping() const
7084 {
7085     return loop();
7086 }
7087 
7088 CachedResourceLoader* HTMLMediaElement::mediaPlayerCachedResourceLoader()
7089 {
7090     return &amp;document().cachedResourceLoader();
7091 }
7092 
7093 RefPtr&lt;PlatformMediaResourceLoader&gt; HTMLMediaElement::mediaPlayerCreateResourceLoader()
7094 {
7095     auto mediaResourceLoader = adoptRef(*new MediaResourceLoader(document(), *this, crossOrigin()));
7096 
7097     m_lastMediaResourceLoaderForTesting = makeWeakPtr(mediaResourceLoader.get());
7098 
7099     return mediaResourceLoader;
7100 }
7101 
7102 const MediaResourceLoader* HTMLMediaElement::lastMediaResourceLoaderForTesting() const
7103 {
7104     return m_lastMediaResourceLoaderForTesting.get();
7105 }
7106 
7107 bool HTMLMediaElement::mediaPlayerShouldUsePersistentCache() const
7108 {
7109     if (Page* page = document().page())
<span class="line-modified">7110         return !page-&gt;usesEphemeralSession() &amp;&amp; !page-&gt;isResourceCachingDisabled();</span>
7111 
7112     return false;
7113 }
7114 
7115 const String&amp; HTMLMediaElement::mediaPlayerMediaCacheDirectory() const
7116 {
7117     return mediaCacheDirectory();
7118 }
7119 
7120 String HTMLMediaElement::sourceApplicationIdentifier() const
7121 {
7122     if (RefPtr&lt;Frame&gt; frame = document().frame()) {
7123         if (NetworkingContext* networkingContext = frame-&gt;loader().networkingContext())
7124             return networkingContext-&gt;sourceApplicationIdentifier();
7125     }
7126     return emptyString();
7127 }
7128 
7129 Vector&lt;String&gt; HTMLMediaElement::mediaPlayerPreferredAudioCharacteristics() const
7130 {

7131     if (Page* page = document().page())
7132         return page-&gt;group().captionPreferences().preferredAudioCharacteristics();

7133     return Vector&lt;String&gt;();
7134 }
7135 
7136 #if PLATFORM(IOS_FAMILY)

7137 String HTMLMediaElement::mediaPlayerNetworkInterfaceName() const
7138 {
7139     return DeprecatedGlobalSettings::networkInterfaceName();
7140 }
7141 
7142 bool HTMLMediaElement::mediaPlayerGetRawCookies(const URL&amp; url, Vector&lt;Cookie&gt;&amp; cookies) const
7143 {
7144     if (auto* page = document().page())
7145         return page-&gt;cookieJar().getRawCookies(document(), url, cookies);
7146     return false;
7147 }
<span class="line-removed">7148 #endif</span>
7149 
<span class="line-modified">7150 bool HTMLMediaElement::mediaPlayerIsInMediaDocument() const</span>
<span class="line-removed">7151 {</span>
<span class="line-removed">7152     return document().isMediaDocument();</span>
<span class="line-removed">7153 }</span>
7154 
7155 void HTMLMediaElement::mediaPlayerEngineFailedToLoad() const
7156 {
7157     if (!m_player)
7158         return;
7159 
7160     if (auto* page = document().page())
7161         page-&gt;diagnosticLoggingClient().logDiagnosticMessageWithValue(DiagnosticLoggingKeys::engineFailedToLoadKey(), m_player-&gt;engineDescription(), m_player-&gt;platformErrorCode(), 4, ShouldSample::No);
7162 }
7163 
7164 double HTMLMediaElement::mediaPlayerRequestedPlaybackRate() const
7165 {
7166     return potentiallyPlaying() ? requestedPlaybackRate() : 0;
7167 }
7168 
7169 const Vector&lt;ContentType&gt;&amp; HTMLMediaElement::mediaContentTypesRequiringHardwareSupport() const
7170 {
7171     return document().settings().mediaContentTypesRequiringHardwareSupport();
7172 }
7173 
</pre>
<hr />
<pre>
7238 {
7239     RefPtr&lt;DOMWindow&gt; domWindow = document().domWindow();
7240     double timestamp = domWindow ? 1000 * domWindow-&gt;nowTimestamp() : 0;
7241 
7242     auto metrics = m_player ? m_player-&gt;videoPlaybackQualityMetrics() : WTF::nullopt;
7243     if (!metrics)
7244         return VideoPlaybackQuality::create(timestamp, { });
7245 
7246 #if ENABLE(MEDIA_SOURCE)
7247     metrics.value().totalVideoFrames += m_droppedVideoFrames;
7248     metrics.value().droppedVideoFrames += m_droppedVideoFrames;
7249 #endif
7250 
7251     return VideoPlaybackQuality::create(timestamp, metrics.value());
7252 }
7253 
7254 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
7255 DOMWrapperWorld&amp; HTMLMediaElement::ensureIsolatedWorld()
7256 {
7257     if (!m_isolatedWorld)
<span class="line-modified">7258         m_isolatedWorld = DOMWrapperWorld::create(commonVM());</span>
7259     return *m_isolatedWorld;
7260 }
7261 
7262 bool HTMLMediaElement::ensureMediaControlsInjectedScript()
7263 {
7264     INFO_LOG(LOGIDENTIFIER);
7265 
7266     Page* page = document().page();
7267     if (!page)
7268         return false;
7269 
7270     String mediaControlsScript = RenderTheme::singleton().mediaControlsScript();
7271     if (!mediaControlsScript.length())
7272         return false;
7273 
<span class="line-modified">7274     return setupAndCallJS([mediaControlsScript](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp; scriptController, DOMWrapperWorld&amp; world) {</span>
7275         auto&amp; vm = globalObject.vm();
7276         auto scope = DECLARE_CATCH_SCOPE(vm);
7277 
<span class="line-modified">7278         auto functionValue = globalObject.get(&amp;exec, JSC::Identifier::fromString(vm, &quot;createControls&quot;));</span>
7279         if (functionValue.isFunction(vm))
7280             return true;
7281 
7282 #ifndef NDEBUG
7283         // Setting a scriptURL allows the source to be debuggable in the inspector.
7284         URL scriptURL = URL({ }, &quot;mediaControlsScript&quot;_s);
7285 #else
7286         URL scriptURL;
7287 #endif
<span class="line-modified">7288         scriptController.evaluateInWorld(ScriptSourceCode(mediaControlsScript, WTFMove(scriptURL)), world);</span>
7289         if (UNLIKELY(scope.exception())) {
7290             scope.clearException();
7291             return false;
7292         }
7293 
7294         return true;
7295     });
7296 }
7297 
7298 void HTMLMediaElement::updatePageScaleFactorJSProperty()
7299 {
7300     Page* page = document().page();
7301     if (!page)
7302         return;
7303 
7304     setControllerJSProperty(&quot;pageScaleFactor&quot;, JSC::jsNumber(page-&gt;pageScaleFactor()));
7305 }
7306 
7307 void HTMLMediaElement::updateUsesLTRUserInterfaceLayoutDirectionJSProperty()
7308 {
7309     Page* page = document().page();
7310     if (!page)
7311         return;
7312 
7313     bool usesLTRUserInterfaceLayoutDirectionProperty = page-&gt;userInterfaceLayoutDirection() == UserInterfaceLayoutDirection::LTR;
7314     setControllerJSProperty(&quot;usesLTRUserInterfaceLayoutDirection&quot;, JSC::jsBoolean(usesLTRUserInterfaceLayoutDirectionProperty));
7315 }
7316 
7317 void HTMLMediaElement::setControllerJSProperty(const char* propertyName, JSC::JSValue propertyValue)
7318 {
<span class="line-modified">7319     setupAndCallJS([this, propertyName, propertyValue](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
7320         auto&amp; vm = globalObject.vm();
<span class="line-modified">7321         auto controllerValue = controllerJSValue(exec, globalObject, *this);</span>
7322         if (controllerValue.isNull())
7323             return false;
7324 
7325         JSC::PutPropertySlot propertySlot(controllerValue);
<span class="line-modified">7326         auto* controllerObject = controllerValue.toObject(&amp;exec);</span>
7327         if (!controllerObject)
7328             return false;
7329 
<span class="line-modified">7330         controllerObject-&gt;methodTable(vm)-&gt;put(controllerObject, &amp;exec, JSC::Identifier::fromString(vm, propertyName), propertyValue, propertySlot);</span>
7331 
7332         return true;
7333     });
7334 }
7335 
7336 void HTMLMediaElement::didAddUserAgentShadowRoot(ShadowRoot&amp; root)
7337 {
7338     INFO_LOG(LOGIDENTIFIER);
7339 
7340     if (!ensureMediaControlsInjectedScript())
7341         return;
7342 
<span class="line-modified">7343     setupAndCallJS([this, &amp;root](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
7344         auto&amp; vm = globalObject.vm();
7345         auto scope = DECLARE_CATCH_SCOPE(vm);
7346 
7347         // The media controls script must provide a method with the following details.
7348         // Name: createControls
7349         // Parameters:
7350         //     1. The ShadowRoot element that will hold the controls.
7351         //     2. This object (and HTMLMediaElement).
7352         //     3. The MediaControlsHost object.
7353         // Return value:
7354         //     A reference to the created media controller instance.
7355 
<span class="line-modified">7356         auto functionValue = globalObject.get(&amp;exec, JSC::Identifier::fromString(vm, &quot;createControls&quot;));</span>
7357         if (functionValue.isUndefinedOrNull())
7358             return false;
7359 
7360         if (!m_mediaControlsHost)
7361             m_mediaControlsHost = MediaControlsHost::create(this);
7362 
<span class="line-modified">7363         auto mediaJSWrapper = toJS(&amp;exec, &amp;globalObject, *this);</span>
<span class="line-modified">7364         auto mediaControlsHostJSWrapper = toJS(&amp;exec, &amp;globalObject, *m_mediaControlsHost);</span>
7365 
7366         JSC::MarkedArgumentBuffer argList;
<span class="line-modified">7367         argList.append(toJS(&amp;exec, &amp;globalObject, root));</span>
7368         argList.append(mediaJSWrapper);
7369         argList.append(mediaControlsHostJSWrapper);
7370         ASSERT(!argList.hasOverflowed());
7371 
<span class="line-modified">7372         auto* function = functionValue.toObject(&amp;exec);</span>
7373         scope.assertNoException();
7374         JSC::CallData callData;
7375         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7376         if (callType == JSC::CallType::None)
7377             return false;
7378 
<span class="line-modified">7379         auto controllerValue = JSC::call(&amp;exec, function, callType, callData, &amp;globalObject, argList);</span>
7380         scope.clearException();
7381         auto* controllerObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controllerValue);
7382         if (!controllerObject)
7383             return false;
7384 
7385         // Connect the Media, MediaControllerHost, and Controller so the GC knows about their relationship
<span class="line-modified">7386         auto* mediaJSWrapperObject = mediaJSWrapper.toObject(&amp;exec);</span>
7387         scope.assertNoException();
7388         auto controlsHost = JSC::Identifier::fromString(vm, &quot;controlsHost&quot;);
7389 
<span class="line-modified">7390         ASSERT(!mediaJSWrapperObject-&gt;hasProperty(&amp;exec, controlsHost));</span>
7391 
7392         mediaJSWrapperObject-&gt;putDirect(vm, controlsHost, mediaControlsHostJSWrapper, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);
7393 
7394         auto* mediaControlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaControlsHostJSWrapper);
7395         if (!mediaControlsHostJSWrapperObject)
7396             return false;
7397 
7398         auto controller = JSC::Identifier::fromString(vm, &quot;controller&quot;);
7399 
<span class="line-modified">7400         ASSERT(!controllerObject-&gt;hasProperty(&amp;exec, controller));</span>
7401 
7402         mediaControlsHostJSWrapperObject-&gt;putDirect(vm, controller, controllerValue, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);
7403 
7404         updatePageScaleFactorJSProperty();
7405         updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
7406 
7407         if (UNLIKELY(scope.exception()))
7408             scope.clearException();
7409 
7410         return true;
7411     });
7412 }
7413 
7414 void HTMLMediaElement::setMediaControlsDependOnPageScaleFactor(bool dependsOnPageScale)
7415 {
7416     INFO_LOG(LOGIDENTIFIER, dependsOnPageScale);
7417 
7418     if (document().settings().mediaControlsScaleWithPageZoom()) {
7419         INFO_LOG(LOGIDENTIFIER, &quot;forced to false by Settings value&quot;);
7420         m_mediaControlsDependOnPageScaleFactor = false;
7421         return;
7422     }
7423 
<span class="line-removed">7424     if (m_mediaControlsDependOnPageScaleFactor == dependsOnPageScale)</span>
<span class="line-removed">7425         return;</span>
<span class="line-removed">7426 </span>
7427     m_mediaControlsDependOnPageScaleFactor = dependsOnPageScale;
<span class="line-removed">7428 </span>
<span class="line-removed">7429     if (m_mediaControlsDependOnPageScaleFactor)</span>
<span class="line-removed">7430         document().registerForPageScaleFactorChangedCallbacks(*this);</span>
<span class="line-removed">7431     else</span>
<span class="line-removed">7432         document().unregisterForPageScaleFactorChangedCallbacks(*this);</span>
7433 }
7434 
7435 void HTMLMediaElement::updateMediaControlsAfterPresentationModeChange()
7436 {
7437     // Don&#39;t execute script if the controls script hasn&#39;t been injected yet, or we have
7438     // stopped/suspended the object.
7439     if (!m_mediaControlsHost || document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped())
7440         return;
7441 
7442     if (RuntimeEnabledFeatures::sharedFeatures().modernMediaControlsEnabled())
7443         return;
7444 
<span class="line-modified">7445     setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
7446         auto&amp; vm = globalObject.vm();
7447         auto scope = DECLARE_THROW_SCOPE(vm);
7448 
<span class="line-modified">7449         auto controllerValue = controllerJSValue(exec, globalObject, *this);</span>
<span class="line-modified">7450         auto* controllerObject = controllerValue.toObject(&amp;exec);</span>
7451 
7452         RETURN_IF_EXCEPTION(scope, false);
7453 
<span class="line-modified">7454         auto functionValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;handlePresentationModeChange&quot;));</span>
7455         if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
7456             return false;
7457 
<span class="line-modified">7458         auto* function = functionValue.toObject(&amp;exec);</span>
7459         scope.assertNoException();
7460         JSC::CallData callData;
7461         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7462         if (callType == JSC::CallType::None)
7463             return false;
7464 
7465         JSC::MarkedArgumentBuffer argList;
7466         ASSERT(!argList.hasOverflowed());
<span class="line-modified">7467         JSC::call(&amp;exec, function, callType, callData, controllerObject, argList);</span>
7468 
7469         return true;
7470     });
7471 }
7472 
7473 void HTMLMediaElement::pageScaleFactorChanged()
7474 {
<span class="line-modified">7475     updatePageScaleFactorJSProperty();</span>

7476 }
7477 
7478 void HTMLMediaElement::userInterfaceLayoutDirectionChanged()
7479 {
7480     updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
7481 }
7482 
7483 String HTMLMediaElement::getCurrentMediaControlsStatus()
7484 {
7485     ensureMediaControlsShadowRoot();
7486 
7487     String status;
<span class="line-modified">7488     setupAndCallJS([this, &amp;status](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
7489         auto&amp; vm = globalObject.vm();
7490         auto scope = DECLARE_THROW_SCOPE(vm);
7491 
<span class="line-modified">7492         auto controllerValue = controllerJSValue(exec, globalObject, *this);</span>
<span class="line-modified">7493         auto* controllerObject = controllerValue.toObject(&amp;exec);</span>
7494 
7495         RETURN_IF_EXCEPTION(scope, false);
7496 
<span class="line-modified">7497         auto functionValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;getCurrentControlsStatus&quot;));</span>
7498         if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
7499             return false;
7500 
<span class="line-modified">7501         auto* function = functionValue.toObject(&amp;exec);</span>
7502         scope.assertNoException();
7503         JSC::CallData callData;
7504         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7505         JSC::MarkedArgumentBuffer argList;
7506         ASSERT(!argList.hasOverflowed());
7507         if (callType == JSC::CallType::None)
7508             return false;
7509 
<span class="line-modified">7510         auto outputValue = JSC::call(&amp;exec, function, callType, callData, controllerObject, argList);</span>
7511 
7512         RETURN_IF_EXCEPTION(scope, false);
7513 
<span class="line-modified">7514         status = outputValue.getString(&amp;exec);</span>
7515         return true;
7516     });
7517 
7518     return status;
7519 }
7520 #endif // ENABLE(MEDIA_CONTROLS_SCRIPT)
7521 
7522 unsigned long long HTMLMediaElement::fileSize() const
7523 {
7524     if (m_player)
7525         return m_player-&gt;fileSize();
7526 
7527     return 0;
7528 }
7529 
7530 PlatformMediaSession::MediaType HTMLMediaElement::mediaType() const
7531 {
7532     if (m_player &amp;&amp; m_readyState &gt;= HAVE_METADATA) {
7533         if (hasVideo() &amp;&amp; hasAudio() &amp;&amp; !muted())
7534             return PlatformMediaSession::VideoAudio;
</pre>
<hr />
<pre>
7568     if (isVideo() &amp;&amp; hasVideo())
7569         state |= PlatformMediaSession::HasVideo;
7570     if (this-&gt;hasAudio())
7571         state |= PlatformMediaSession::HasAudio;
7572 
7573     return state;
7574 }
7575 
7576 bool HTMLMediaElement::canProduceAudio() const
7577 {
7578 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7579     // Because the remote target could unmute playback without notifying us, we must assume
7580     // that we may be playing audio.
7581     if (m_isPlayingToWirelessTarget)
7582         return true;
7583 #endif
7584 
7585     if (muted())
7586         return false;
7587 
<span class="line-modified">7588     return m_player &amp;&amp; m_readyState &gt;= HAVE_METADATA &amp;&amp; hasAudio();</span>



7589 }
7590 
7591 bool HTMLMediaElement::isSuspended() const
7592 {
7593     return document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped();
7594 }
7595 
7596 #if ENABLE(MEDIA_SOURCE)
7597 size_t HTMLMediaElement::maximumSourceBufferSize(const SourceBuffer&amp; buffer) const
7598 {
7599     return m_mediaSession-&gt;maximumMediaSourceBufferSize(buffer);
7600 }
7601 #endif
7602 
7603 void HTMLMediaElement::suspendPlayback()
7604 {
7605     INFO_LOG(LOGIDENTIFIER, &quot;paused = &quot;, paused());
7606     if (!paused())
7607         pause();
7608 }
</pre>
<hr />
<pre>
7620 {
7621     INFO_LOG(LOGIDENTIFIER, &quot;paused = &quot;, paused());
7622     if (paused() &amp;&amp; shouldResume)
7623         play();
7624 }
7625 
7626 String HTMLMediaElement::mediaSessionTitle() const
7627 {
7628     if (!document().page() || document().page()-&gt;usesEphemeralSession())
7629         return emptyString();
7630 
7631     auto title = String(attributeWithoutSynchronization(titleAttr)).stripWhiteSpace().simplifyWhiteSpace();
7632     if (!title.isEmpty())
7633         return title;
7634 
7635     title = document().title().stripWhiteSpace().simplifyWhiteSpace();
7636     if (!title.isEmpty())
7637         return title;
7638 
7639     title = m_currentSrc.host().toString();
<span class="line-modified">7640 #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)</span>
7641     if (!title.isEmpty())
7642         title = decodeHostName(title);
7643 #endif
7644     if (!title.isEmpty()) {
7645         auto domain = RegistrableDomain { m_currentSrc };
7646         if (!domain.isEmpty())
7647             title = domain.string();
7648     }
7649 
7650     return title;
7651 }
7652 
7653 uint64_t HTMLMediaElement::mediaSessionUniqueIdentifier() const
7654 {
7655     auto&amp; url = m_currentSrc.string();
7656     return url.impl() ? url.impl()-&gt;hash() : 0;
7657 }
7658 
7659 void HTMLMediaElement::didReceiveRemoteControlCommand(PlatformMediaSession::RemoteControlCommandType command, const PlatformMediaSession::RemoteCommandArgument* argument)
7660 {
</pre>
<hr />
<pre>
7920     if (!MemoryPressureHandler::singleton().isUnderMemoryPressure() &amp;&amp; m_mediaSession-&gt;preferredBufferingPolicy() == BufferingPolicy::Default)
7921         return;
7922 
7923     if (isPlayingToExternalTarget()) {
7924         INFO_LOG(LOGIDENTIFIER, &quot;early return because playing to wireless target&quot;);
7925         return;
7926     }
7927 
7928     setBufferingPolicy(BufferingPolicy::PurgeResources);
7929 }
7930 
7931 bool HTMLMediaElement::canSaveMediaData() const
7932 {
7933     if (m_player)
7934         return m_player-&gt;canSaveMediaData();
7935 
7936     return false;
7937 }
7938 
7939 #if ENABLE(MEDIA_SESSION)

7940 double HTMLMediaElement::playerVolume() const
7941 {
7942     return m_player ? m_player-&gt;volume() : 0;
7943 }
7944 
7945 MediaSession* HTMLMediaElement::session() const
7946 {
7947     RefPtr&lt;MediaSession&gt; session = m_session.get();
7948     if (session &amp;&amp; session == &amp;document().defaultMediaSession())
7949         return nullptr;
7950 
7951     return session.get();
7952 }
7953 
7954 void HTMLMediaElement::setSession(MediaSession* session)
7955 {
7956     // 6.1. Extensions to the HTMLMediaElement interface
7957     // 1. Let m be the media element in question.
7958     // 2. Let old media session be m’s current media session, if it has one, and null otherwise.
7959     // 3. Let m’s current media session be the new value or the top-level browsing context’s media session if the new value is null.
</pre>
<hr />
<pre>
8144         return;
8145 
8146     m_inActiveDocument = inActiveDocument;
8147     m_mediaSession-&gt;inActiveDocumentChanged();
8148 }
8149 
8150 HTMLMediaElementEnums::BufferingPolicy HTMLMediaElement::bufferingPolicy() const
8151 {
8152     return m_bufferingPolicy;
8153 }
8154 
8155 bool HTMLMediaElement::hasMediaStreamSource() const
8156 {
8157 #if ENABLE(MEDIA_STREAM)
8158     return hasMediaStreamSrcObject();
8159 #else
8160     return false;
8161 #endif
8162 }
8163 
























8164 }
8165 
8166 #endif
</pre>
</td>
<td>
<hr />
<pre>
  55 #include &quot;FullscreenManager.h&quot;
  56 #include &quot;HTMLParserIdioms.h&quot;
  57 #include &quot;HTMLSourceElement.h&quot;
  58 #include &quot;HTMLVideoElement.h&quot;
  59 #include &quot;InspectorInstrumentation.h&quot;
  60 #include &quot;JSDOMException.h&quot;
  61 #include &quot;JSDOMPromiseDeferred.h&quot;
  62 #include &quot;JSHTMLMediaElement.h&quot;
  63 #include &quot;Logging.h&quot;
  64 #include &quot;MIMETypeRegistry.h&quot;
  65 #include &quot;MediaController.h&quot;
  66 #include &quot;MediaControls.h&quot;
  67 #include &quot;MediaDocument.h&quot;
  68 #include &quot;MediaError.h&quot;
  69 #include &quot;MediaFragmentURIParser.h&quot;
  70 #include &quot;MediaList.h&quot;
  71 #include &quot;MediaPlayer.h&quot;
  72 #include &quot;MediaQueryEvaluator.h&quot;
  73 #include &quot;MediaResourceLoader.h&quot;
  74 #include &quot;NetworkingContext.h&quot;
<span class="line-added">  75 #include &quot;PODIntervalTree.h&quot;</span>
  76 #include &quot;Page.h&quot;
  77 #include &quot;PageGroup.h&quot;
<span class="line-added">  78 #include &quot;PictureInPictureSupport.h&quot;</span>
  79 #include &quot;PlatformMediaSessionManager.h&quot;
  80 #include &quot;ProgressTracker.h&quot;
  81 #include &quot;Quirks.h&quot;
  82 #include &quot;RegistrableDomain.h&quot;
  83 #include &quot;RenderLayerCompositor.h&quot;
  84 #include &quot;RenderTheme.h&quot;
  85 #include &quot;RenderVideo.h&quot;
  86 #include &quot;RenderView.h&quot;
  87 #include &quot;ResourceLoadInfo.h&quot;
  88 #include &quot;ScriptController.h&quot;
  89 #include &quot;ScriptDisallowedScope.h&quot;
  90 #include &quot;ScriptSourceCode.h&quot;
  91 #include &quot;SecurityOriginData.h&quot;
  92 #include &quot;SecurityPolicy.h&quot;
  93 #include &quot;Settings.h&quot;
  94 #include &quot;ShadowRoot.h&quot;
  95 #include &quot;TimeRanges.h&quot;
  96 #include &quot;UserContentController.h&quot;
  97 #include &quot;UserGestureIndicator.h&quot;
  98 #include &quot;VideoPlaybackQuality.h&quot;
</pre>
<hr />
<pre>
 114 #include &quot;InbandGenericTextTrack.h&quot;
 115 #include &quot;InbandTextTrackPrivate.h&quot;
 116 #include &quot;InbandWebVTTTextTrack.h&quot;
 117 #include &quot;RuntimeEnabledFeatures.h&quot;
 118 #include &quot;TextTrackCueList.h&quot;
 119 #include &quot;TextTrackList.h&quot;
 120 #include &quot;VideoTrackList.h&quot;
 121 #endif
 122 
 123 #if ENABLE(WEB_AUDIO)
 124 #include &quot;AudioSourceProvider.h&quot;
 125 #include &quot;MediaElementAudioSourceNode.h&quot;
 126 #endif
 127 
 128 #if PLATFORM(IOS_FAMILY)
 129 #include &quot;RuntimeApplicationChecks.h&quot;
 130 #include &quot;VideoFullscreenInterfaceAVKit.h&quot;
 131 #endif
 132 
 133 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-added"> 134 #include &quot;RemotePlayback.h&quot;</span>
 135 #include &quot;WebKitPlaybackTargetAvailabilityEvent.h&quot;
 136 #endif
 137 
 138 #if ENABLE(MEDIA_SESSION)
 139 #include &quot;MediaSession.h&quot;
 140 #endif
 141 
 142 #if ENABLE(MEDIA_SOURCE)
 143 #include &quot;DOMWindow.h&quot;
 144 #include &quot;MediaSource.h&quot;
 145 #endif
 146 
 147 #if ENABLE(MEDIA_STREAM)
 148 #include &quot;DOMURL.h&quot;
 149 #include &quot;MediaStream.h&quot;
 150 #endif
 151 
 152 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 153 #include &quot;WebKitMediaKeyNeededEvent.h&quot;
 154 #include &quot;WebKitMediaKeys.h&quot;
</pre>
<hr />
<pre>
 257     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
 258     return values[static_cast&lt;size_t&gt;(enumerationValue)];
 259 }
 260 
 261 String convertEnumerationToString(HTMLMediaElement::AutoplayEventPlaybackState enumerationValue)
 262 {
 263     static const NeverDestroyed&lt;String&gt; values[] = {
 264         MAKE_STATIC_STRING_IMPL(&quot;None&quot;),
 265         MAKE_STATIC_STRING_IMPL(&quot;PreventedAutoplay&quot;),
 266         MAKE_STATIC_STRING_IMPL(&quot;StartedWithUserGesture&quot;),
 267         MAKE_STATIC_STRING_IMPL(&quot;StartedWithoutUserGesture&quot;),
 268     };
 269     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::None) == 0, &quot;AutoplayEventPlaybackState::None is not 0 as expected&quot;);
 270     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::PreventedAutoplay) == 1, &quot;AutoplayEventPlaybackState::PreventedAutoplay is not 1 as expected&quot;);
 271     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::StartedWithUserGesture) == 2, &quot;AutoplayEventPlaybackState::StartedWithUserGesture is not 2 as expected&quot;);
 272     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::StartedWithoutUserGesture) == 3, &quot;AutoplayEventPlaybackState::StartedWithoutUserGesture is not 3 as expected&quot;);
 273     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
 274     return values[static_cast&lt;size_t&gt;(enumerationValue)];
 275 }
 276 
























 277 #if ENABLE(VIDEO_TRACK)
 278 
 279 class TrackDisplayUpdateScope {
 280 public:
 281     TrackDisplayUpdateScope(HTMLMediaElement&amp; element)
 282         : m_element(element)
 283     {
 284         m_element.beginIgnoringTrackDisplayUpdateRequests();
 285     }
 286     ~TrackDisplayUpdateScope()
 287     {
 288         m_element.endIgnoringTrackDisplayUpdateRequests();
 289     }
 290 
 291 private:
 292     HTMLMediaElement&amp; m_element;
 293 };
 294 

 295 
 296 struct HTMLMediaElement::TrackGroup {
 297     enum GroupKind { CaptionsAndSubtitles, Description, Chapter, Metadata, Other };
 298 
 299     TrackGroup(GroupKind kind)
 300         : kind(kind)
 301     {
 302     }
 303 
 304     Vector&lt;RefPtr&lt;TextTrack&gt;&gt; tracks;
 305     RefPtr&lt;TextTrack&gt; visibleTrack;
 306     RefPtr&lt;TextTrack&gt; defaultTrack;
 307     GroupKind kind;
 308     bool hasSrcLang { false };
 309 };
<span class="line-added"> 310 #endif</span>
 311 
 312 HashSet&lt;HTMLMediaElement*&gt;&amp; HTMLMediaElement::allMediaElements()
 313 {
 314     static NeverDestroyed&lt;HashSet&lt;HTMLMediaElement*&gt;&gt; elements;
 315     return elements;
 316 }
 317 
 318 #if ENABLE(MEDIA_SESSION)
 319 typedef HashMap&lt;uint64_t, HTMLMediaElement*&gt; IDToElementMap;
 320 
 321 static IDToElementMap&amp; elementIDsToElements()
 322 {
 323     static NeverDestroyed&lt;IDToElementMap&gt; map;
 324     return map;
 325 }
 326 
 327 HTMLMediaElement* HTMLMediaElement::elementWithID(uint64_t id)
 328 {
 329     if (id == HTMLMediaElementInvalidID)
 330         return nullptr;
</pre>
<hr />
<pre>
 388 
 389     if (!session.isVisibleInViewportOrFullscreen)
 390         return false;
 391 
 392     if (!session.isLargeEnoughForMainContent)
 393         return false;
 394 
 395     // Even if this video is not a candidate, if it is visible to the user and large enough
 396     // to be main content, it poses a risk for being confused with main content.
 397     return true;
 398 }
 399 
 400 HTMLMediaElement::HTMLMediaElement(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
 401     : HTMLElement(tagName, document)
 402     , ActiveDOMObject(document)
 403     , m_progressEventTimer(*this, &amp;HTMLMediaElement::progressEventTimerFired)
 404     , m_playbackProgressTimer(*this, &amp;HTMLMediaElement::playbackProgressTimerFired)
 405     , m_scanTimer(*this, &amp;HTMLMediaElement::scanTimerFired)
 406     , m_playbackControlsManagerBehaviorRestrictionsTimer(*this, &amp;HTMLMediaElement::playbackControlsManagerBehaviorRestrictionsTimerFired)
 407     , m_seekToPlaybackPositionEndedTimer(*this, &amp;HTMLMediaElement::seekToPlaybackPositionEndedTimerFired)
<span class="line-modified"> 408     , m_updatePlayStateTask(*this)</span>
<span class="line-added"> 409     , m_asyncEventQueue(MainThreadGenericEventQueue::create(*this))</span>
 410     , m_lastTimeUpdateEventMovieTime(MediaTime::positiveInfiniteTime())
 411     , m_firstTimePlaying(true)
 412     , m_playing(false)
 413     , m_isWaitingUntilMediaCanStart(false)
 414     , m_shouldDelayLoadEvent(false)
 415     , m_haveFiredLoadedData(false)
 416     , m_inActiveDocument(true)
 417     , m_autoplaying(true)
 418     , m_muted(false)
 419     , m_explicitlyMuted(false)
 420     , m_initiallyMuted(false)
 421     , m_paused(true)
 422     , m_seeking(false)
 423     , m_seekRequested(false)
 424     , m_sentStalledEvent(false)
 425     , m_sentEndEvent(false)
 426     , m_pausedInternal(false)
 427     , m_closedCaptionsVisible(false)
 428     , m_webkitLegacyClosedCaptionOverride(false)
 429     , m_completelyLoaded(false)
 430     , m_havePreparedToPlay(false)
 431     , m_parsingInProgress(createdByParser)
 432     , m_elementIsHidden(document.hidden())
 433     , m_creatingControls(false)
 434     , m_receivedLayoutSizeChanged(false)
 435     , m_hasEverNotifiedAboutPlaying(false)
 436     , m_hasEverHadAudio(false)
 437     , m_hasEverHadVideo(false)
 438 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 439     , m_mediaControlsDependOnPageScaleFactor(false)
 440     , m_haveSetUpCaptionContainer(false)
 441 #endif
 442     , m_isScrubbingRemotely(false)
 443 #if ENABLE(VIDEO_TRACK)
 444     , m_tracksAreReady(true)
 445     , m_haveVisibleTextTrack(false)
 446     , m_processingPreferenceChange(false)
 447 #endif
<span class="line-added"> 448 #if ENABLE(WIRELESS_PLAYBACK_TARGET)</span>
<span class="line-added"> 449     , m_remote(RemotePlayback::create(*this))</span>
<span class="line-added"> 450 #endif</span>
 451 #if !RELEASE_LOG_DISABLED
 452     , m_logger(&amp;document.logger())
 453     , m_logIdentifier(uniqueLogIdentifier())
 454 #endif
 455 {
 456     allMediaElements().add(this);
 457 
 458     ALWAYS_LOG(LOGIDENTIFIER);
 459 
 460     setHasCustomStyleResolveCallbacks();
 461 
 462     InspectorInstrumentation::addEventListenersToNode(*this);
 463 }
 464 
 465 void HTMLMediaElement::finishInitialization()
 466 {
 467     m_mediaSession = makeUnique&lt;MediaElementSession&gt;(*this);
 468 
 469     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForFullscreen);
 470     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToLoadMedia);
</pre>
<hr />
<pre>
 486         const bool shouldAudioPlaybackRequireUserGesture = topDocument.audioPlaybackRequiresUserGesture() &amp;&amp; !isProcessingUserGesture;
 487         const bool shouldVideoPlaybackRequireUserGesture = topDocument.videoPlaybackRequiresUserGesture() &amp;&amp; !isProcessingUserGesture;
 488 
 489         if (shouldVideoPlaybackRequireUserGesture) {
 490             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoRateChange);
 491             if (document.settings().requiresUserGestureToLoadVideo())
 492                 m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForLoad);
 493         }
 494 
 495         if (page &amp;&amp; page-&gt;isLowPowerModeEnabled())
 496             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoDueToLowPowerMode);
 497 
 498         if (shouldAudioPlaybackRequireUserGesture)
 499             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForAudioRateChange);
 500 
 501 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 502         if (shouldVideoPlaybackRequireUserGesture || shouldAudioPlaybackRequireUserGesture)
 503             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToShowPlaybackTargetPicker);
 504 #endif
 505 
<span class="line-modified"> 506         if (!document.mediaDataLoadsAutomatically() &amp;&amp; !document.quirks().needsPreloadAutoQuirk())</span>
 507             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::AutoPreloadingNotPermitted);
 508 
 509         if (document.settings().mainContentUserGestureOverrideEnabled())
 510             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::OverrideUserGestureRequirementForMainContent);
 511     }
 512 
 513 #if PLATFORM(IOS_FAMILY)
 514     if (!document.settings().videoPlaybackRequiresUserGesture() &amp;&amp; !document.settings().audioPlaybackRequiresUserGesture()) {
 515         // Relax RequireUserGestureForFullscreen when videoPlaybackRequiresUserGesture and audioPlaybackRequiresUserGesture is not set:
 516         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureForFullscreen);
 517     }
 518 #endif
 519 
 520 #if ENABLE(MEDIA_SESSION)
 521     m_elementID = nextElementID();
 522     elementIDsToElements().add(m_elementID, this);
 523 
 524     setSessionInternal(document.defaultMediaSession());
 525 #endif
 526 
 527     registerWithDocument(document);
 528 
 529 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 530     AudioSession::sharedSession().addMutedStateObserver(this);
 531 #endif
 532 
 533     mediaSession().clientWillBeginAutoplaying();
 534 }
 535 














 536 HTMLMediaElement::~HTMLMediaElement()
 537 {

 538     ALWAYS_LOG(LOGIDENTIFIER);
 539 
 540     beginIgnoringTrackDisplayUpdateRequests();
 541     allMediaElements().remove(this);
 542 
<span class="line-modified"> 543     m_asyncEventQueue-&gt;close();</span>
 544 
 545     setShouldDelayLoadEvent(false);
 546     unregisterWithDocument(document());
 547 
 548 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 549     AudioSession::sharedSession().removeMutedStateObserver(this);
 550 #endif
 551 
 552 #if ENABLE(VIDEO_TRACK)
 553     if (m_audioTracks)
 554         m_audioTracks-&gt;clearElement();
 555     if (m_textTracks)
 556         m_textTracks-&gt;clearElement();
 557     if (m_videoTracks)
 558         m_videoTracks-&gt;clearElement();
 559 #endif
 560 
 561 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified"> 562     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent) || m_remote-&gt;hasAvailabilityCallbacks()) {</span>
 563         m_hasPlaybackTargetAvailabilityListeners = false;
 564         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
 565         updateMediaState();
 566     }
 567 #endif
 568 
 569     if (m_mediaController) {
 570         m_mediaController-&gt;removeMediaElement(*this);
 571         m_mediaController = nullptr;
 572     }
 573 
 574 #if ENABLE(MEDIA_SOURCE)
 575     detachMediaSource();
 576 #endif
 577 
 578 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 579     webkitSetMediaKeys(nullptr);
 580 #endif
 581 
 582 #if ENABLE(ENCRYPTED_MEDIA)
</pre>
<hr />
<pre>
 632         auto mediaElementSessionInfo = mediaElementSessionInfoForSession(downcast&lt;MediaElementSession&gt;(session), purpose);
 633         if (mediaElementSessionInfo.canShowControlsManager)
 634             candidateSessions.append(mediaElementSessionInfo);
 635         else if (mediaSessionMayBeConfusedWithMainContent(mediaElementSessionInfo, purpose))
 636             atLeastOneNonCandidateMayBeConfusedForMainContent = true;
 637     });
 638 
 639     if (!candidateSessions.size())
 640         return nullptr;
 641 
 642     std::sort(candidateSessions.begin(), candidateSessions.end(), preferMediaControlsForCandidateSessionOverOtherCandidateSession);
 643     auto strongestSessionCandidate = candidateSessions.first();
 644     if (!strongestSessionCandidate.isVisibleInViewportOrFullscreen &amp;&amp; !strongestSessionCandidate.isPlayingAudio &amp;&amp; atLeastOneNonCandidateMayBeConfusedForMainContent)
 645         return nullptr;
 646 
 647     return &amp;strongestSessionCandidate.session-&gt;element();
 648 }
 649 
 650 void HTMLMediaElement::registerWithDocument(Document&amp; document)
 651 {
<span class="line-added"> 652     document.registerMediaElement(*this);</span>
<span class="line-added"> 653 </span>
 654     m_mediaSession-&gt;registerWithDocument(document);
 655 
 656     if (m_isWaitingUntilMediaCanStart)
 657         document.addMediaCanStartListener(*this);
 658 





 659     document.registerForVisibilityStateChangedCallbacks(*this);
 660 
 661 #if ENABLE(VIDEO_TRACK)
 662     if (m_requireCaptionPreferencesChangedCallbacks)
 663         document.registerForCaptionPreferencesChangedCallbacks(*this);
 664 #endif
 665 






 666 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 667     document.registerForDocumentSuspensionCallbacks(*this);
 668 #endif
 669 


 670     document.addAudioProducer(*this);







 671 }
 672 
 673 void HTMLMediaElement::unregisterWithDocument(Document&amp; document)
 674 {
<span class="line-added"> 675     document.unregisterMediaElement(*this);</span>
<span class="line-added"> 676 </span>
 677     m_mediaSession-&gt;unregisterWithDocument(document);
 678 
 679     if (m_isWaitingUntilMediaCanStart)
 680         document.removeMediaCanStartListener(*this);
 681 





 682     document.unregisterForVisibilityStateChangedCallbacks(*this);
 683 
 684 #if ENABLE(VIDEO_TRACK)
 685     if (m_requireCaptionPreferencesChangedCallbacks)
 686         document.unregisterForCaptionPreferencesChangedCallbacks(*this);
 687 #endif
 688 






 689 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 690     document.unregisterForDocumentSuspensionCallbacks(*this);
 691 #endif
 692 


 693     document.removeAudioProducer(*this);







 694 }
 695 
 696 void HTMLMediaElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
 697 {
 698     ASSERT_WITH_SECURITY_IMPLICATION(&amp;document() == &amp;newDocument);
 699     if (m_shouldDelayLoadEvent) {
 700         oldDocument.decrementLoadEventDelayCount();
 701         newDocument.incrementLoadEventDelayCount();
 702     }
 703 
 704     unregisterWithDocument(oldDocument);
 705     registerWithDocument(newDocument);
 706 
 707     HTMLElement::didMoveToNewDocument(oldDocument, newDocument);
 708     updateShouldAutoplay();
 709 }
 710 
 711 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-added"> 712 </span>
 713 void HTMLMediaElement::prepareForDocumentSuspension()
 714 {
 715     m_mediaSession-&gt;unregisterWithDocument(document());
 716 }
 717 
 718 void HTMLMediaElement::resumeFromDocumentSuspension()
 719 {
 720     m_mediaSession-&gt;registerWithDocument(document());
 721     updateShouldAutoplay();
 722 }
<span class="line-added"> 723 </span>
 724 #endif
 725 
 726 bool HTMLMediaElement::supportsFocus() const
 727 {
 728     if (document().isMediaDocument())
 729         return false;
 730 
 731     // If no controls specified, we should still be able to focus the element if it has tabIndex.
 732     return controls() ||  HTMLElement::supportsFocus();
 733 }
 734 
 735 bool HTMLMediaElement::isMouseFocusable() const
 736 {
 737     return false;
 738 }
 739 
 740 bool HTMLMediaElement::isInteractiveContent() const
 741 {
 742     return controls();
 743 }
 744 
 745 void HTMLMediaElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 746 {
 747     if (name == srcAttr) {
 748         // https://html.spec.whatwg.org/multipage/embedded-content.html#location-of-the-media-resource
 749         // Location of the Media Resource
 750         // 12 February 2017
 751 
 752         // If a src attribute of a media element is set or changed, the user
 753         // agent must invoke the media element&#39;s media element load algorithm.
 754         if (!value.isNull())
 755             prepareForLoad();
 756     } else if (name == controlsAttr)
 757         configureMediaControls();
 758     else if (name == loopAttr)
 759         updateSleepDisabling();
 760     else if (name == preloadAttr) {
 761         if (equalLettersIgnoringASCIICase(value, &quot;none&quot;))
<span class="line-modified"> 762             m_preload = MediaPlayer::Preload::None;</span>
 763         else if (equalLettersIgnoringASCIICase(value, &quot;metadata&quot;))
<span class="line-modified"> 764             m_preload = MediaPlayer::Preload::MetaData;</span>
 765         else {
 766             // The spec does not define an &quot;invalid value default&quot; but &quot;auto&quot; is suggested as the
 767             // &quot;missing value default&quot;, so use it for everything except &quot;none&quot; and &quot;metadata&quot;
<span class="line-modified"> 768             m_preload = MediaPlayer::Preload::Auto;</span>
 769         }
 770 
 771         // The attribute must be ignored if the autoplay attribute is present
 772         if (!autoplay() &amp;&amp; !m_havePreparedToPlay &amp;&amp; m_player)
 773             m_player-&gt;setPreload(m_mediaSession-&gt;effectivePreloadForElement());
 774 
 775     } else if (name == mediagroupAttr)
 776         setMediaGroup(value);
 777     else if (name == autoplayAttr) {
 778         if (processingUserGestureForMedia())
 779             removeBehaviorRestrictionsAfterFirstUserGesture();
 780     } else if (name == titleAttr) {
 781         if (m_mediaSession)
 782             m_mediaSession-&gt;clientCharacteristicsChanged();
 783     }
 784     else
 785         HTMLElement::parseAttribute(name, value);
 786 }
 787 
 788 void HTMLMediaElement::finishParsingChildren()
</pre>
<hr />
<pre>
 889     if (removalType.disconnectedFromDocument) {
 890         // Pause asynchronously to let the operation that removed us finish, in case we get inserted back into a document.
 891         m_pauseAfterDetachedTaskQueue.enqueueTask(std::bind(&amp;HTMLMediaElement::pauseAfterDetachedTask, this));
 892     }
 893 
 894     if (m_mediaSession)
 895         m_mediaSession-&gt;clientCharacteristicsChanged();
 896 
 897     HTMLElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
 898 }
 899 
 900 void HTMLMediaElement::willAttachRenderers()
 901 {
 902     ASSERT(!renderer());
 903 }
 904 
 905 inline void HTMLMediaElement::updateRenderer()
 906 {
 907     if (auto* renderer = this-&gt;renderer())
 908         renderer-&gt;updateFromElement();
<span class="line-added"> 909 </span>
<span class="line-added"> 910 #if ENABLE(MEDIA_CONTROLS_SCRIPT)</span>
<span class="line-added"> 911     if (m_mediaControlsHost)</span>
<span class="line-added"> 912         m_mediaControlsHost-&gt;updateCaptionDisplaySizes();</span>
<span class="line-added"> 913 #endif</span>
 914 }
 915 
 916 void HTMLMediaElement::didAttachRenderers()
 917 {
 918     if (auto* renderer = this-&gt;renderer()) {
 919         renderer-&gt;updateFromElement();
 920         if (m_mediaSession &amp;&amp; m_mediaSession-&gt;wantsToObserveViewportVisibilityForAutoplay())
 921             renderer-&gt;registerForVisibleInViewportCallback();
 922     }
 923     updateShouldAutoplay();
 924 }
 925 
 926 void HTMLMediaElement::willDetachRenderers()
 927 {
 928     if (auto* renderer = this-&gt;renderer())
 929         renderer-&gt;unregisterForVisibleInViewportCallback();
 930 }
 931 
 932 void HTMLMediaElement::didDetachRenderers()
 933 {
 934     updateShouldAutoplay();
 935 }
 936 
 937 void HTMLMediaElement::didRecalcStyle(Style::Change)
 938 {
 939     updateRenderer();
 940 }
 941 
 942 void HTMLMediaElement::scheduleNextSourceChild()
 943 {
 944     // Schedule the timer to try the next &lt;source&gt; element WITHOUT resetting state ala prepareForLoad.
 945     m_resourceSelectionTaskQueue.enqueueTask([this] {
 946         loadNextSourceChild();
 947     });
 948 }
 949 
<span class="line-modified"> 950 void HTMLMediaElement::mediaPlayerActiveSourceBuffersChanged()</span>
 951 {
 952     m_hasEverHadAudio |= hasAudio();
 953     m_hasEverHadVideo |= hasVideo();
 954 }
 955 
 956 void HTMLMediaElement::scheduleEvent(const AtomString&amp; eventName)
 957 {
 958     auto event = Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::Yes);
 959 
 960     // Don&#39;t set the event target, the event queue will set it in GenericEventQueue::timerFired and setting it here
 961     // will trigger an ASSERT if this element has been marked for deletion.
 962 
<span class="line-modified"> 963     m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
<span class="line-added"> 964 }</span>
<span class="line-added"> 965 </span>
<span class="line-added"> 966 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added"> 967 void HTMLMediaElement::scheduleEvent(Ref&lt;Event&gt;&amp;&amp; event)</span>
<span class="line-added"> 968 {</span>
<span class="line-added"> 969     m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
 970 }
<span class="line-added"> 971 #endif</span>
 972 
 973 void HTMLMediaElement::scheduleResolvePendingPlayPromises()
 974 {
 975     m_promiseTaskQueue.enqueueTask([this, pendingPlayPromises = WTFMove(m_pendingPlayPromises)] () mutable {
 976         resolvePendingPlayPromises(WTFMove(pendingPlayPromises));
 977     });
 978 }
 979 
 980 void HTMLMediaElement::scheduleRejectPendingPlayPromises(Ref&lt;DOMException&gt;&amp;&amp; error)
 981 {
 982     m_promiseTaskQueue.enqueueTask([this, error = WTFMove(error), pendingPlayPromises = WTFMove(m_pendingPlayPromises)] () mutable {
 983         rejectPendingPlayPromises(WTFMove(pendingPlayPromises), WTFMove(error));
 984     });
 985 }
 986 
 987 void HTMLMediaElement::rejectPendingPlayPromises(PlayPromiseVector&amp;&amp; pendingPlayPromises, Ref&lt;DOMException&gt;&amp;&amp; error)
 988 {
 989     for (auto&amp; promise : pendingPlayPromises)
 990         promise.rejectType&lt;IDLInterface&lt;DOMException&gt;&gt;(error);
 991 }
</pre>
<hr />
<pre>
1081     return parseCORSSettingsAttribute(attributeWithoutSynchronization(crossoriginAttr));
1082 }
1083 
1084 HTMLMediaElement::NetworkState HTMLMediaElement::networkState() const
1085 {
1086     return m_networkState;
1087 }
1088 
1089 String HTMLMediaElement::canPlayType(const String&amp; mimeType) const
1090 {
1091     MediaEngineSupportParameters parameters;
1092     ContentType contentType(mimeType);
1093     parameters.type = contentType;
1094     parameters.contentTypesRequiringHardwareSupport = mediaContentTypesRequiringHardwareSupport();
1095     MediaPlayer::SupportsType support = MediaPlayer::supportsType(parameters);
1096     String canPlay;
1097 
1098     // 4.8.10.3
1099     switch (support)
1100     {
<span class="line-modified">1101         case MediaPlayer::SupportsType::IsNotSupported:</span>
1102             canPlay = emptyString();
1103             break;
<span class="line-modified">1104         case MediaPlayer::SupportsType::MayBeSupported:</span>
1105             canPlay = &quot;maybe&quot;_s;
1106             break;
<span class="line-modified">1107         case MediaPlayer::SupportsType::IsSupported:</span>
1108             canPlay = &quot;probably&quot;_s;
1109             break;
1110     }
1111 
1112     INFO_LOG(LOGIDENTIFIER, mimeType, &quot;: &quot;, canPlay);
1113 
1114     return canPlay;
1115 }
1116 
1117 double HTMLMediaElement::getStartDate() const
1118 {
1119     if (!m_player)
1120         return std::numeric_limits&lt;double&gt;::quiet_NaN();
1121     return m_player-&gt;getStartDate().toDouble();
1122 }
1123 
1124 void HTMLMediaElement::load()
1125 {
1126     Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // prepareForLoad may result in a &#39;beforeload&#39; event, which can make arbitrary DOM mutations.
1127 
</pre>
<hr />
<pre>
1175     cancelPendingEventsAndCallbacks();
1176 
1177     // 5 - If the media element&#39;s networkState is set to NETWORK_LOADING or NETWORK_IDLE, queue
1178     // a task to fire a simple event named abort at the media element.
1179     if (m_networkState == NETWORK_LOADING || m_networkState == NETWORK_IDLE)
1180         scheduleEvent(eventNames().abortEvent);
1181 
1182     // 6 - If the media element&#39;s networkState is not set to NETWORK_EMPTY, then run these substeps
1183     if (m_networkState != NETWORK_EMPTY) {
1184         // 6.1 - Queue a task to fire a simple event named emptied at the media element.
1185         scheduleEvent(eventNames().emptiedEvent);
1186 
1187         // 6.2 - If a fetching process is in progress for the media element, the user agent should stop it.
1188         m_networkState = NETWORK_EMPTY;
1189 
1190         // 6.3 - If the media element’s assigned media provider object is a MediaSource object, then detach it.
1191 #if ENABLE(MEDIA_SOURCE)
1192         detachMediaSource();
1193 #endif
1194 
<span class="line-added">1195 #if ENABLE(VIDEO_TRACK)</span>
1196         // 6.4 - Forget the media element&#39;s media-resource-specific tracks.
1197         forgetResourceSpecificTracks();
<span class="line-added">1198 #endif</span>
1199 
1200         // 6.5 - If readyState is not set to HAVE_NOTHING, then set it to that state.
1201         m_readyState = HAVE_NOTHING;
1202         m_readyStateMaximum = HAVE_NOTHING;
1203 
1204         // 6.6 - If the paused attribute is false, then set it to true.
1205         m_paused = true;
1206 
1207         // 6.7 - If seeking is true, set it to false.
1208         clearSeeking();
1209 
1210         // 6.8 - Set the current playback position to 0.
1211         //       Set the official playback position to 0.
1212         //       If this changed the official playback position, then queue a task to fire a simple event named timeupdate at the media element.
1213         m_lastSeekTime = MediaTime::zeroTime();
1214         m_playedTimeRanges = TimeRanges::create();
1215         // FIXME: Add support for firing this event. e.g., scheduleEvent(eventNames().timeUpdateEvent);
1216 
1217         // 4.9 - Set the initial playback position to 0.
1218         // FIXME: Make this less subtle. The position only becomes 0 because of the createMediaPlayer() call
</pre>
<hr />
<pre>
1374             //    If that algorithm returns without aborting this one, then the load failed.
1375             // 4. Failed with media provider: Reaching this step indicates that the media resource
1376             //    failed to load. Queue a task to run the dedicated media source failure steps.
1377             // 5. Wait for the task queued by the previous step to have executed.
1378             // 6. Abort these steps. The element won’t attempt to load another resource until this
1379             //    algorithm is triggered again.
1380             return;
1381         }
1382 
1383         // ↳ If mode is attribute
1384         if (mode == Attribute) {
1385             m_loadState = LoadingFromSrcAttr;
1386 
1387             // 1. If the src attribute’s value is the empty string, then end the synchronous section,
1388             //    and jump down to the failed with attribute step below.
1389             // 2. Let absolute URL be the absolute URL that would have resulted from parsing the URL
1390             //    specified by the src attribute’s value relative to the media element when the src
1391             //    attribute was last changed.
1392             URL absoluteURL = getNonEmptyURLAttribute(srcAttr);
1393             if (absoluteURL.isEmpty()) {
<span class="line-modified">1394                 mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1395                 ALWAYS_LOG(logSiteIdentifier, &quot;empty &#39;src&#39;&quot;);
1396                 return;
1397             }
1398 
1399             if (!isSafeToLoadURL(absoluteURL, Complain) || !dispatchBeforeLoadEvent(absoluteURL.string())) {
<span class="line-modified">1400                 mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1401                 return;
1402             }
1403 
1404             // 3. If absolute URL was obtained successfully, set the currentSrc attribute to absolute URL.
1405             m_currentSrc = absoluteURL;
1406 
1407             // 4. End the synchronous section, continuing the remaining steps in parallel.
1408             // 5. If absolute URL was obtained successfully, run the resource fetch algorithm with absolute
1409             //    URL. If that algorithm returns without aborting this one, then the load failed.
1410 
1411             // No type or key system information is available when the url comes
1412             // from the &#39;src&#39; attribute so MediaPlayer
1413             // will have to pick a media engine based on the file extension.
1414             ContentType contentType;
1415             loadResource(absoluteURL, contentType, String());
1416             ALWAYS_LOG(logSiteIdentifier, &quot;using &#39;src&#39; attribute url&quot;);
1417 
1418             // 6. Failed with attribute: Reaching this step indicates that the media resource failed to load
1419             //    or that the given URL could not be resolved. Queue a task to run the dedicated media source failure steps.
1420             // 7. Wait for the task queued by the previous step to have executed.
</pre>
<hr />
<pre>
1436     if (!mediaURL.isValid()) {
1437         waitForSourceChange();
1438         return;
1439     }
1440 
1441     // Recreate the media player for the new url
1442     createMediaPlayer();
1443 
1444     m_loadState = LoadingFromSourceElement;
1445     loadResource(mediaURL, contentType, keySystem);
1446 }
1447 
1448 void HTMLMediaElement::loadResource(const URL&amp; initialURL, ContentType&amp; contentType, const String&amp; keySystem)
1449 {
1450     ASSERT(initialURL.isEmpty() || isSafeToLoadURL(initialURL, Complain));
1451 
1452     INFO_LOG(LOGIDENTIFIER, initialURL, contentType, keySystem);
1453 
1454     RefPtr&lt;Frame&gt; frame = document().frame();
1455     if (!frame) {
<span class="line-modified">1456         mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1457         return;
1458     }
1459 
1460     Page* page = frame-&gt;page();
1461     if (!page) {
<span class="line-modified">1462         mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1463         return;
1464     }
1465 
1466     URL url = initialURL;
1467     if (!url.isEmpty() &amp;&amp; !frame-&gt;loader().willLoadMediaElementURL(url, *this)) {
<span class="line-modified">1468         mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1469         return;
1470     }
1471 
1472 #if ENABLE(CONTENT_EXTENSIONS)
1473     if (auto documentLoader = makeRefPtr(frame-&gt;loader().documentLoader())) {
1474         if (page-&gt;userContentProvider().processContentRuleListsForLoad(url, ContentExtensions::ResourceType::Media, *documentLoader).summary.blockedLoad) {
<span class="line-modified">1475             mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1476             return;
1477         }
1478     }
1479 #endif
1480 
1481     // The resource fetch algorithm
1482     m_networkState = NETWORK_LOADING;
1483 
1484     // If the URL should be loaded from the application cache, pass the URL of the cached file to the media engine.
1485     ApplicationCacheResource* resource = nullptr;
1486     if (!url.isEmpty() &amp;&amp; frame-&gt;loader().documentLoader()-&gt;applicationCacheHost().shouldLoadResourceFromApplicationCache(ResourceRequest(url), resource)) {
1487         // Resources that are not present in the manifest will always fail to load (at least, after the
1488         // cache has been primed the first time), making the testing of offline applications simpler.
1489         if (!resource || resource-&gt;path().isEmpty()) {
<span class="line-modified">1490             mediaLoadingFailed(MediaPlayer::NetworkState::NetworkError);</span>
1491             return;
1492         }
1493     }
1494 
1495     // Log that we started loading a media element.
1496     page-&gt;diagnosticLoggingClient().logDiagnosticMessage(isVideo() ? DiagnosticLoggingKeys::videoKey() : DiagnosticLoggingKeys::audioKey(), DiagnosticLoggingKeys::loadingKey(), ShouldSample::No);
1497 
1498     m_firstTimePlaying = true;
1499 
1500     // Set m_currentSrc *before* changing to the cache URL, the fact that we are loading from the app
1501     // cache is an internal detail not exposed through the media element API.
1502     m_currentSrc = url;
1503 
1504     if (resource) {
1505         url = ApplicationCacheHost::createFileURL(resource-&gt;path());
1506         INFO_LOG(LOGIDENTIFIER, &quot;will load from app cache &quot;, url);
1507     }
1508 
1509     INFO_LOG(LOGIDENTIFIER, &quot;m_currentSrc is &quot;, m_currentSrc);
1510 
</pre>
<hr />
<pre>
1520         m_player-&gt;setPreload(m_mediaSession-&gt;effectivePreloadForElement());
1521     m_player-&gt;setPreservesPitch(m_webkitPreservesPitch);
1522 
1523     if (!m_explicitlyMuted) {
1524         m_explicitlyMuted = true;
1525         m_muted = hasAttributeWithoutSynchronization(mutedAttr);
1526         m_mediaSession-&gt;canProduceAudioChanged();
1527     }
1528 
1529     updateVolume();
1530 
1531     bool loadAttempted = false;
1532 #if ENABLE(MEDIA_SOURCE)
1533     if (!m_mediaSource &amp;&amp; url.protocolIs(mediaSourceBlobProtocol))
1534         m_mediaSource = MediaSource::lookup(url.string());
1535 
1536     if (m_mediaSource) {
1537         loadAttempted = true;
1538 
1539         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading MSE blob&quot;);
<span class="line-modified">1540         if (!m_mediaSource-&gt;attachToElement(*this)) {</span>
1541             // Forget our reference to the MediaSource, so we leave it alone
1542             // while processing remainder of load failure.
1543             m_mediaSource = nullptr;
<span class="line-modified">1544             mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
<span class="line-added">1545         } else if (!m_player-&gt;load(url, contentType, m_mediaSource.get())) {</span>
<span class="line-added">1546             // We have to detach the MediaSource before we forget the reference to it.</span>
<span class="line-added">1547             m_mediaSource-&gt;detachFromElement(*this);</span>
<span class="line-added">1548             m_mediaSource = nullptr;</span>
<span class="line-added">1549             mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1550         }
1551     }
1552 #endif
1553 #if ENABLE(MEDIA_STREAM)
1554     if (!loadAttempted &amp;&amp; m_mediaStreamSrcObject) {
1555         loadAttempted = true;
1556         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading media stream blob&quot;);
1557         if (!m_player-&gt;load(m_mediaStreamSrcObject-&gt;privateStream()))
<span class="line-modified">1558             mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1559     }
1560 #endif
1561 
1562     if (!loadAttempted &amp;&amp; m_blob) {
1563         loadAttempted = true;
1564         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading generic blob&quot;);
1565         if (!m_player-&gt;load(m_blob-&gt;url(), contentType, keySystem))
<span class="line-modified">1566             mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1567     }
1568 
1569     if (!loadAttempted &amp;&amp; !m_player-&gt;load(url, contentType, keySystem))
<span class="line-modified">1570         mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1571 
1572     // If there is no poster to display, allow the media engine to render video frames as soon as
1573     // they are available.
1574     updateDisplayState();
1575 
1576     updateRenderer();
1577 }
1578 
1579 #if ENABLE(VIDEO_TRACK)
1580 
<span class="line-added">1581 struct HTMLMediaElement::CueData {</span>
<span class="line-added">1582     WTF_MAKE_STRUCT_FAST_ALLOCATED;</span>
<span class="line-added">1583     PODIntervalTree&lt;MediaTime, TextTrackCue*&gt; cueTree;</span>
<span class="line-added">1584     CueList currentlyActiveCues;</span>
<span class="line-added">1585 };</span>
<span class="line-added">1586 </span>
1587 static bool trackIndexCompare(TextTrack* a, TextTrack* b)
1588 {
1589     return a-&gt;trackIndex() - b-&gt;trackIndex() &lt; 0;
1590 }
1591 
1592 static bool eventTimeCueCompare(const std::pair&lt;MediaTime, TextTrackCue*&gt;&amp; a, const std::pair&lt;MediaTime, TextTrackCue*&gt;&amp; b)
1593 {
1594     // 12 - Sort the tasks in events in ascending time order (tasks with earlier
1595     // times first).
1596     if (a.first != b.first)
1597         return a.first - b.first &lt; MediaTime::zeroTime();
1598 
1599     // If the cues belong to different text tracks, it doesn&#39;t make sense to
1600     // compare the two tracks by the relative cue order, so return the relative
1601     // track order.
1602     if (a.second-&gt;track() != b.second-&gt;track())
1603         return trackIndexCompare(a.second-&gt;track(), b.second-&gt;track());
1604 
1605     // 12 - Further sort tasks in events that have the same time by the
1606     // relative text track cue order of the text track cues associated
1607     // with these tasks.
1608     return a.second-&gt;isOrderedBefore(b.second);
1609 }
1610 
1611 static bool compareCueInterval(const CueInterval&amp; one, const CueInterval&amp; two)
1612 {
1613     return one.data()-&gt;isOrderedBefore(two.data());
1614 }
1615 
1616 static bool compareCueIntervalEndTime(const CueInterval&amp; one, const CueInterval&amp; two)
1617 {
1618     return one.data()-&gt;endMediaTime() &gt; two.data()-&gt;endMediaTime();
1619 }
1620 
<span class="line-added">1621 bool HTMLMediaElement::ignoreTrackDisplayUpdateRequests() const</span>
<span class="line-added">1622 {</span>
<span class="line-added">1623     return m_ignoreTrackDisplayUpdate &gt; 0 || !m_textTracks || !m_cueData || m_cueData-&gt;cueTree.isEmpty();</span>
<span class="line-added">1624 }</span>
<span class="line-added">1625 </span>
1626 void HTMLMediaElement::updateActiveTextTrackCues(const MediaTime&amp; movieTime)
1627 {
1628     // 4.8.10.8 Playing the media resource
1629 
1630     //  If the current playback position changes while the steps are running,
1631     //  then the user agent must wait for the steps to complete, and then must
1632     //  immediately rerun the steps.
1633     if (ignoreTrackDisplayUpdateRequests())
1634         return;
1635 
1636     // 1 - Let current cues be a list of cues, initialized to contain all the
1637     // cues of all the hidden, showing, or showing by default text tracks of the
1638     // media element (not the disabled ones) whose start times are less than or
1639     // equal to the current playback position and whose end times are greater
1640     // than the current playback position.
1641     CueList currentCues;
1642 
1643     // The user agent must synchronously unset [the text track cue active] flag
1644     // whenever ... the media element&#39;s readyState is changed back to HAVE_NOTHING.

1645     if (m_readyState != HAVE_NOTHING &amp;&amp; m_player) {
<span class="line-modified">1646         currentCues = m_cueData-&gt;cueTree.allOverlaps({ movieTime, movieTime });</span>
1647         if (currentCues.size() &gt; 1)
1648             std::sort(currentCues.begin(), currentCues.end(), &amp;compareCueInterval);
1649     }
1650 
1651     CueList previousCues;
1652     CueList missedCues;
1653 
1654     // 2 - Let other cues be a list of cues, initialized to contain all the cues
1655     // of hidden, showing, and showing by default text tracks of the media
1656     // element that are not present in current cues.
<span class="line-modified">1657     previousCues = m_cueData-&gt;currentlyActiveCues;</span>
1658 
1659     // 3 - Let last time be the current playback position at the time this
1660     // algorithm was last run for this media element, if this is not the first
1661     // time it has run.
1662     MediaTime lastTime = m_lastTextTrackUpdateTime;
1663 
1664     // 4 - If the current playback position has, since the last time this
1665     // algorithm was run, only changed through its usual monotonic increase
1666     // during normal playback, then let missed cues be the list of cues in other
1667     // cues whose start times are greater than or equal to last time and whose
1668     // end times are less than or equal to the current playback position.
1669     // Otherwise, let missed cues be an empty list.
1670     if (lastTime &gt;= MediaTime::zeroTime() &amp;&amp; m_lastSeekTime &lt; movieTime) {
<span class="line-modified">1671         for (auto&amp; cue : m_cueData-&gt;cueTree.allOverlaps({ lastTime, movieTime })) {</span>
1672             // Consider cues that may have been missed since the last seek time.
1673             if (cue.low() &gt; std::max(m_lastSeekTime, lastTime) &amp;&amp; cue.high() &lt; movieTime)
1674                 missedCues.append(cue);
1675         }
1676     }
1677 
1678     m_lastTextTrackUpdateTime = movieTime;
1679 
1680     // 5 - If the time was reached through the usual monotonic increase of the
1681     // current playback position during normal playback, and if the user agent
1682     // has not fired a timeupdate event at the element in the past 15 to 250ms
1683     // and is not still running event handlers for such an event, then the user
1684     // agent must queue a task to fire a simple event named timeupdate at the
1685     // element. (In the other cases, such as explicit seeks, relevant events get
1686     // fired as part of the overall process of changing the current playback
1687     // position.)
1688     if (!m_paused &amp;&amp; m_lastSeekTime &lt;= lastTime)
1689         scheduleTimeupdateEvent(false);
1690 
1691     // Explicitly cache vector sizes, as their content is constant from here.
1692     size_t currentCuesSize = currentCues.size();
1693     size_t missedCuesSize = missedCues.size();
1694     size_t previousCuesSize = previousCues.size();
1695 
1696     // 6 - If all of the cues in current cues have their text track cue active
1697     // flag set, none of the cues in other cues have their text track cue active
1698     // flag set, and missed cues is empty, then abort these steps.
1699     bool activeSetChanged = missedCuesSize;
1700 
1701     for (size_t i = 0; !activeSetChanged &amp;&amp; i &lt; previousCuesSize; ++i)
1702         if (!currentCues.contains(previousCues[i]) &amp;&amp; previousCues[i].data()-&gt;isActive())
1703             activeSetChanged = true;
1704 
1705     for (size_t i = 0; i &lt; currentCuesSize; ++i) {
1706         RefPtr&lt;TextTrackCue&gt; cue = currentCues[i].data();
<span class="line-modified">1707         cue-&gt;updateDisplayTree(movieTime);</span>



1708         if (!cue-&gt;isActive())
1709             activeSetChanged = true;
1710     }
1711 
1712     MediaTime nextInterestingTime = MediaTime::invalidTime();
1713     if (auto nearestEndingCue = std::min_element(currentCues.begin(), currentCues.end(), compareCueIntervalEndTime))
1714         nextInterestingTime = nearestEndingCue-&gt;data()-&gt;endMediaTime();
1715 
<span class="line-modified">1716     Optional&lt;CueInterval&gt; nextCue = m_cueData-&gt;cueTree.nextIntervalAfter(movieTime);</span>
1717     if (nextCue)
1718         nextInterestingTime = std::min(nextInterestingTime, nextCue-&gt;low());
1719 
1720     INFO_LOG(LOGIDENTIFIER, &quot;nextInterestingTime:&quot;, nextInterestingTime);
1721 
1722     if (nextInterestingTime.isValid() &amp;&amp; m_player) {
1723         m_player-&gt;performTaskAtMediaTime([this, weakThis = makeWeakPtr(this), nextInterestingTime] {
1724             if (!weakThis)
1725                 return;
1726 
1727             auto currentMediaTime = this-&gt;currentMediaTime();
1728             INFO_LOG(LOGIDENTIFIER, &quot; lambda, currentMediaTime: &quot;, currentMediaTime);
1729             this-&gt;updateActiveTextTrackCues(currentMediaTime);
1730         }, nextInterestingTime);
1731     }
1732 
1733     if (!activeSetChanged)
1734         return;
1735 
1736     // 7 - If the time was reached through the usual monotonic increase of the
</pre>
<hr />
<pre>
1792             eventTasks.append({ currentCues[i].data()-&gt;startMediaTime(), currentCues[i].data() });
1793     }
1794 
1795     // 12 - Sort the tasks in events in ascending time order (tasks with earlier
1796     // times first).
1797     std::sort(eventTasks.begin(), eventTasks.end(), eventTimeCueCompare);
1798 
1799     for (auto&amp; eventTask : eventTasks) {
1800         if (!affectedTracks.contains(eventTask.second-&gt;track()))
1801             affectedTracks.append(eventTask.second-&gt;track());
1802 
1803         // 13 - Queue each task in events, in list order.
1804 
1805         // Each event in eventTasks may be either an enterEvent or an exitEvent,
1806         // depending on the time that is associated with the event. This
1807         // correctly identifies the type of the event, if the startTime is
1808         // less than the endTime in the cue.
1809         if (eventTask.second-&gt;startTime() &gt;= eventTask.second-&gt;endTime()) {
1810             auto enterEvent = Event::create(eventNames().enterEvent, Event::CanBubble::No, Event::IsCancelable::No);
1811             enterEvent-&gt;setTarget(eventTask.second);
<span class="line-modified">1812             m_asyncEventQueue-&gt;enqueueEvent(WTFMove(enterEvent));</span>
1813 
1814             auto exitEvent = Event::create(eventNames().exitEvent, Event::CanBubble::No, Event::IsCancelable::No);
1815             exitEvent-&gt;setTarget(eventTask.second);
<span class="line-modified">1816             m_asyncEventQueue-&gt;enqueueEvent(WTFMove(exitEvent));</span>
1817         } else {
1818             RefPtr&lt;Event&gt; event;
1819             if (eventTask.first == eventTask.second-&gt;startMediaTime())
1820                 event = Event::create(eventNames().enterEvent, Event::CanBubble::No, Event::IsCancelable::No);
1821             else
1822                 event = Event::create(eventNames().exitEvent, Event::CanBubble::No, Event::IsCancelable::No);
1823             event-&gt;setTarget(eventTask.second);
<span class="line-modified">1824             m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
1825         }
1826     }
1827 
1828     // 14 - Sort affected tracks in the same order as the text tracks appear in
1829     // the media element&#39;s list of text tracks, and remove duplicates.
1830     std::sort(affectedTracks.begin(), affectedTracks.end(), trackIndexCompare);
1831 
1832     // 15 - For each text track in affected tracks, in the list order, queue a
1833     // task to fire a simple event named cuechange at the TextTrack object, and, ...
1834     for (auto&amp; affectedTrack : affectedTracks) {
1835         auto event = Event::create(eventNames().cuechangeEvent, Event::CanBubble::No, Event::IsCancelable::No);
1836         event-&gt;setTarget(affectedTrack);
<span class="line-modified">1837         m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
1838 
1839         // ... if the text track has a corresponding track element, to then fire a
1840         // simple event named cuechange at the track element as well.
1841         if (is&lt;LoadableTextTrack&gt;(*affectedTrack)) {
1842             auto event = Event::create(eventNames().cuechangeEvent, Event::CanBubble::No, Event::IsCancelable::No);
1843             auto trackElement = makeRefPtr(downcast&lt;LoadableTextTrack&gt;(*affectedTrack).trackElement());
1844             ASSERT(trackElement);
1845             event-&gt;setTarget(trackElement);
<span class="line-modified">1846             m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
1847         }
1848     }
1849 
1850     // 16 - Set the text track cue active flag of all the cues in the current
1851     // cues, and unset the text track cue active flag of all the cues in the
1852     // other cues.
1853     for (size_t i = 0; i &lt; currentCuesSize; ++i)
1854         currentCues[i].data()-&gt;setIsActive(true);
1855 
1856     for (size_t i = 0; i &lt; previousCuesSize; ++i)
1857         if (!currentCues.contains(previousCues[i]))
1858             previousCues[i].data()-&gt;setIsActive(false);
1859 
1860     // Update the current active cues.
<span class="line-modified">1861     m_cueData-&gt;currentlyActiveCues = currentCues;</span>
1862 
1863     if (activeSetChanged)
1864         updateTextTrackDisplay();
1865 }
1866 
1867 bool HTMLMediaElement::textTracksAreReady() const
1868 {
1869     // 4.8.10.12.1 Text track model
1870     // ...
1871     // The text tracks of a media element are ready if all the text tracks whose mode was not
1872     // in the disabled state when the element&#39;s resource selection algorithm last started now
1873     // have a text track readiness state of loaded or failed to load.
1874     for (unsigned i = 0; i &lt; m_textTracksWhenResourceSelectionBegan.size(); ++i) {
1875         if (m_textTracksWhenResourceSelectionBegan[i]-&gt;readinessState() == TextTrack::Loading
1876             || m_textTracksWhenResourceSelectionBegan[i]-&gt;readinessState() == TextTrack::NotLoaded)
1877             return false;
1878     }
1879 
1880     return true;
1881 }
</pre>
<hr />
<pre>
1910     if (processingUserGestureForMedia())
1911         removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);
1912 }
1913 
1914 void HTMLMediaElement::textTrackModeChanged(TextTrack&amp; track)
1915 {
1916     bool trackIsLoaded = true;
1917     if (track.trackType() == TextTrack::TrackElement) {
1918         trackIsLoaded = false;
1919         for (auto&amp; trackElement : childrenOfType&lt;HTMLTrackElement&gt;(*this)) {
1920             if (&amp;trackElement.track() == &amp;track) {
1921                 if (trackElement.readyState() == HTMLTrackElement::LOADING || trackElement.readyState() == HTMLTrackElement::LOADED)
1922                     trackIsLoaded = true;
1923                 break;
1924             }
1925         }
1926     }
1927 
1928     // If this is the first added track, create the list of text tracks.
1929     if (!m_textTracks)
<span class="line-modified">1930         m_textTracks = TextTrackList::create(makeWeakPtr(this), ActiveDOMObject::scriptExecutionContext());</span>
1931 
1932     // Mark this track as &quot;configured&quot; so configureTextTracks won&#39;t change the mode again.
1933     track.setHasBeenConfigured(true);
1934 
1935     if (track.mode() != TextTrack::Mode::Disabled &amp;&amp; trackIsLoaded)
1936         textTrackAddCues(track, *track.cues());
1937 
1938     configureTextTrackDisplay(AssumeTextTrackVisibilityChanged);
1939 
1940     if (m_textTracks &amp;&amp; m_textTracks-&gt;contains(track))
1941         m_textTracks-&gt;scheduleChangeEvent();
1942 
1943 #if ENABLE(AVF_CAPTIONS)
1944     if (track.trackType() == TextTrack::TrackElement &amp;&amp; m_player)
1945         m_player-&gt;notifyTrackModeChanged();
1946 #endif
1947 }
1948 
1949 void HTMLMediaElement::videoTrackSelectedChanged(VideoTrack&amp; track)
1950 {
</pre>
<hr />
<pre>
1978 
1979     TrackDisplayUpdateScope scope { *this };
1980     for (unsigned i = 0; i &lt; cues.length(); ++i)
1981         textTrackAddCue(track, *cues.item(i));
1982 }
1983 
1984 void HTMLMediaElement::textTrackRemoveCues(TextTrack&amp;, const TextTrackCueList&amp; cues)
1985 {
1986     TrackDisplayUpdateScope scope { *this };
1987     for (unsigned i = 0; i &lt; cues.length(); ++i) {
1988         auto&amp; cue = *cues.item(i);
1989         textTrackRemoveCue(*cue.track(), cue);
1990     }
1991 }
1992 
1993 void HTMLMediaElement::textTrackAddCue(TextTrack&amp; track, TextTrackCue&amp; cue)
1994 {
1995     if (track.mode() == TextTrack::Mode::Disabled)
1996         return;
1997 
<span class="line-added">1998     if (!m_cueData)</span>
<span class="line-added">1999         m_cueData = makeUnique&lt;CueData&gt;();</span>
<span class="line-added">2000 </span>
2001     // Negative duration cues need be treated in the interval tree as
2002     // zero-length cues.
2003     MediaTime endTime = std::max(cue.startMediaTime(), cue.endMediaTime());
2004 
<span class="line-modified">2005     CueInterval interval(cue.startMediaTime(), endTime, &amp;cue);</span>
<span class="line-modified">2006     if (!m_cueData-&gt;cueTree.contains(interval))</span>
<span class="line-modified">2007         m_cueData-&gt;cueTree.add(interval);</span>
2008     updateActiveTextTrackCues(currentMediaTime());
2009 }
2010 
2011 void HTMLMediaElement::textTrackRemoveCue(TextTrack&amp;, TextTrackCue&amp; cue)
2012 {
<span class="line-added">2013     if (!m_cueData)</span>
<span class="line-added">2014         m_cueData = makeUnique&lt;CueData&gt;();</span>
<span class="line-added">2015 </span>
2016     // Negative duration cues need to be treated in the interval tree as
2017     // zero-length cues.
2018     MediaTime endTime = std::max(cue.startMediaTime(), cue.endMediaTime());
2019 
<span class="line-modified">2020     CueInterval interval(cue.startMediaTime(), endTime, &amp;cue);</span>
<span class="line-modified">2021     m_cueData-&gt;cueTree.remove(interval);</span>
2022 
2023     // Since the cue will be removed from the media element and likely the
2024     // TextTrack might also be destructed, notifying the region of the cue
2025     // removal shouldn&#39;t be done.
<span class="line-modified">2026     auto isVTT = is&lt;VTTCue&gt;(cue);</span>
<span class="line-added">2027     if (isVTT)</span>
2028         toVTTCue(&amp;cue)-&gt;notifyRegionWhenRemovingDisplayTree(false);
2029 
<span class="line-modified">2030     size_t index = m_cueData-&gt;currentlyActiveCues.find(interval);</span>
2031     if (index != notFound) {
2032         cue.setIsActive(false);
<span class="line-modified">2033         m_cueData-&gt;currentlyActiveCues.remove(index);</span>
2034     }
2035 
<span class="line-modified">2036     cue.removeDisplayTree();</span>

2037     updateActiveTextTrackCues(currentMediaTime());
2038 
<span class="line-modified">2039     if (isVTT)</span>
2040         toVTTCue(&amp;cue)-&gt;notifyRegionWhenRemovingDisplayTree(true);
2041 }
2042 
<span class="line-added">2043 CueList HTMLMediaElement::currentlyActiveCues() const</span>
<span class="line-added">2044 {</span>
<span class="line-added">2045     if (!m_cueData)</span>
<span class="line-added">2046         return { };</span>
<span class="line-added">2047     return m_cueData-&gt;currentlyActiveCues;</span>
<span class="line-added">2048 }</span>
<span class="line-added">2049 </span>
2050 #endif
2051 
2052 static inline bool isAllowedToLoadMediaURL(HTMLMediaElement&amp; element, const URL&amp; url, bool isInUserAgentShadowTree)
2053 {
2054     // Elements in user agent show tree should load whatever the embedding document policy is.
2055     if (isInUserAgentShadowTree)
2056         return true;
2057 
2058     ASSERT(element.document().contentSecurityPolicy());
2059     return element.document().contentSecurityPolicy()-&gt;allowMediaFromSource(url);
2060 }
2061 
2062 bool HTMLMediaElement::isSafeToLoadURL(const URL&amp; url, InvalidURLAction actionIfInvalid)
2063 {
2064     if (!url.isValid()) {
2065         ERROR_LOG(LOGIDENTIFIER, url, &quot; is invalid&quot;);
2066         return false;
2067     }
2068 
2069     RefPtr&lt;Frame&gt; frame = document().frame();
</pre>
<hr />
<pre>
2112 
2113 void HTMLMediaElement::noneSupported()
2114 {
2115     if (m_error)
2116         return;
2117 
2118     INFO_LOG(LOGIDENTIFIER);
2119 
2120     stopPeriodicTimers();
2121     m_loadState = WaitingForSource;
2122     m_currentSourceNode = nullptr;
2123 
2124     // 4.8.10.5
2125     // 6 - Reaching this step indicates that the media resource failed to load or that the given
2126     // URL could not be resolved. In one atomic operation, run the following steps:
2127 
2128     // 6.1 - Set the error attribute to a new MediaError object whose code attribute is set to
2129     // MEDIA_ERR_SRC_NOT_SUPPORTED.
2130     m_error = MediaError::create(MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED);
2131 
<span class="line-added">2132 #if ENABLE(VIDEO_TRACK)</span>
2133     // 6.2 - Forget the media element&#39;s media-resource-specific text tracks.
2134     forgetResourceSpecificTracks();
<span class="line-added">2135 #endif</span>
2136 
2137     // 6.3 - Set the element&#39;s networkState attribute to the NETWORK_NO_SOURCE value.
2138     m_networkState = NETWORK_NO_SOURCE;
2139 
2140     // 7 - Queue a task to fire a simple event named error at the media element.
2141     scheduleEvent(eventNames().errorEvent);
2142 
2143     rejectPendingPlayPromises(WTFMove(m_pendingPlayPromises), DOMException::create(NotSupportedError));
2144 
2145 #if ENABLE(MEDIA_SOURCE)
2146     detachMediaSource();
2147 #endif
2148 
2149     // 8 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
2150     setShouldDelayLoadEvent(false);
2151 
2152     // 9 - Abort these steps. Until the load() method is invoked or the src attribute is changed,
2153     // the element won&#39;t attempt to load another resource.
2154 
2155     updateDisplayState();
2156     updateRenderer();
2157 }
2158 
2159 void HTMLMediaElement::mediaLoadingFailedFatally(MediaPlayer::NetworkState error)
2160 {
2161     // 1 - The user agent should cancel the fetching process.
2162     stopPeriodicTimers();
2163     m_loadState = WaitingForSource;
2164 
2165     // 2 - Set the error attribute to a new MediaError object whose code attribute is
2166     // set to MEDIA_ERR_NETWORK/MEDIA_ERR_DECODE.
<span class="line-modified">2167     if (error == MediaPlayer::NetworkState::NetworkError)</span>
2168         m_error = MediaError::create(MediaError::MEDIA_ERR_NETWORK);
<span class="line-modified">2169     else if (error == MediaPlayer::NetworkState::DecodeError)</span>
2170         m_error = MediaError::create(MediaError::MEDIA_ERR_DECODE);
2171     else
2172         ASSERT_NOT_REACHED();
2173 
2174     // 3 - Queue a task to fire a simple event named error at the media element.
2175     scheduleEvent(eventNames().errorEvent);
2176 
2177 #if ENABLE(MEDIA_SOURCE)
2178     detachMediaSource();
2179 #endif
2180 
2181     // 4 - Set the element&#39;s networkState attribute to the NETWORK_EMPTY value and queue a
2182     // task to fire a simple event called emptied at the element.
2183     m_networkState = NETWORK_EMPTY;
2184     scheduleEvent(eventNames().emptiedEvent);
2185 
2186     // 5 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
2187     setShouldDelayLoadEvent(false);
2188 
2189     // 6 - Abort the overall resource selection algorithm.
2190     m_currentSourceNode = nullptr;





2191 }
2192 
2193 void HTMLMediaElement::cancelPendingEventsAndCallbacks()
2194 {
2195     INFO_LOG(LOGIDENTIFIER);
<span class="line-modified">2196     m_asyncEventQueue-&gt;cancelAllEvents();</span>
2197 
2198     for (auto&amp; source : childrenOfType&lt;HTMLSourceElement&gt;(*this))
2199         source.cancelPendingErrorEvent();
2200 
2201     rejectPendingPlayPromises(WTFMove(m_pendingPlayPromises), DOMException::create(AbortError));
2202 }
2203 
<span class="line-modified">2204 void HTMLMediaElement::mediaPlayerNetworkStateChanged()</span>
2205 {
2206     beginProcessingMediaPlayerCallback();
2207     setNetworkState(m_player-&gt;networkState());
2208     endProcessingMediaPlayerCallback();
2209 }
2210 
2211 static void logMediaLoadRequest(Page* page, const String&amp; mediaEngine, const String&amp; errorMessage, bool succeeded)
2212 {
2213     if (!page)
2214         return;
2215 
2216     DiagnosticLoggingClient&amp; diagnosticLoggingClient = page-&gt;diagnosticLoggingClient();
2217     if (!succeeded) {
2218         diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::mediaLoadingFailedKey(), errorMessage, DiagnosticLoggingResultFail, ShouldSample::No);
2219         return;
2220     }
2221 
2222     diagnosticLoggingClient.logDiagnosticMessage(DiagnosticLoggingKeys::mediaLoadedKey(), mediaEngine, ShouldSample::No);
2223 
2224     if (!page-&gt;hasSeenAnyMediaEngine())
2225         diagnosticLoggingClient.logDiagnosticMessage(DiagnosticLoggingKeys::pageContainsAtLeastOneMediaEngineKey(), emptyString(), ShouldSample::No);
2226 
2227     if (!page-&gt;hasSeenMediaEngine(mediaEngine))
2228         diagnosticLoggingClient.logDiagnosticMessage(DiagnosticLoggingKeys::pageContainsMediaEngineKey(), mediaEngine, ShouldSample::No);
2229 
2230     page-&gt;sawMediaEngine(mediaEngine);
2231 }
2232 














2233 void HTMLMediaElement::mediaLoadingFailed(MediaPlayer::NetworkState error)
2234 {
2235     stopPeriodicTimers();
2236 
2237     // If we failed while trying to load a &lt;source&gt; element, the movie was never parsed, and there are more
2238     // &lt;source&gt; children, schedule the next one
2239     if (m_readyState &lt; HAVE_METADATA &amp;&amp; m_loadState == LoadingFromSourceElement) {
2240 
2241         // resource selection algorithm
2242         // Step 9.Otherwise.9 - Failed with elements: Queue a task, using the DOM manipulation task source, to fire a simple event named error at the candidate element.
2243         if (m_currentSourceNode)
2244             m_currentSourceNode-&gt;scheduleErrorEvent();
2245         else
2246             INFO_LOG(LOGIDENTIFIER, &quot;error event not sent, &lt;source&gt; was removed&quot;);
2247 
2248         // 9.Otherwise.10 - Asynchronously await a stable state. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended.
2249 
<span class="line-added">2250 #if ENABLE(VIDEO_TRACK)</span>
2251         // 9.Otherwise.11 - Forget the media element&#39;s media-resource-specific tracks.
2252         forgetResourceSpecificTracks();
<span class="line-added">2253 #endif</span>
2254 
2255         if (havePotentialSourceChild()) {
2256             INFO_LOG(LOGIDENTIFIER, &quot;scheduling next &lt;source&gt;&quot;);
2257             scheduleNextSourceChild();
2258         } else {
2259             INFO_LOG(LOGIDENTIFIER, &quot;no more &lt;source&gt; elements, waiting&quot;);
2260             waitForSourceChange();
2261         }
2262 
2263         return;
2264     }
2265 
<span class="line-modified">2266     if ((error == MediaPlayer::NetworkState::NetworkError &amp;&amp; m_readyState &gt;= HAVE_METADATA) || error == MediaPlayer::NetworkState::DecodeError)</span>
2267         mediaLoadingFailedFatally(error);
<span class="line-modified">2268     else if ((error == MediaPlayer::NetworkState::FormatError || error == MediaPlayer::NetworkState::NetworkError) &amp;&amp; m_loadState == LoadingFromSrcAttr)</span>
2269         noneSupported();
2270 
2271     updateDisplayState();
2272     if (hasMediaControls()) {
2273         mediaControls()-&gt;reset();
2274         mediaControls()-&gt;reportedError();
2275     }
2276 
2277     ERROR_LOG(LOGIDENTIFIER, &quot;error = &quot;, static_cast&lt;int&gt;(error));
2278 
<span class="line-modified">2279     logMediaLoadRequest(document().page(), String(), convertEnumerationToString(error), false);</span>
2280 
2281     m_mediaSession-&gt;clientCharacteristicsChanged();
2282 }
2283 
2284 void HTMLMediaElement::setNetworkState(MediaPlayer::NetworkState state)
2285 {
2286     if (static_cast&lt;int&gt;(state) != static_cast&lt;int&gt;(m_networkState))
2287         ALWAYS_LOG(LOGIDENTIFIER, &quot;new state = &quot;, state, &quot;, current state = &quot;, m_networkState);
2288 
<span class="line-modified">2289     if (state == MediaPlayer::NetworkState::Empty) {</span>
2290         // Just update the cached state and leave, we can&#39;t do anything.
2291         m_networkState = NETWORK_EMPTY;
2292         return;
2293     }
2294 
<span class="line-modified">2295     if (state == MediaPlayer::NetworkState::FormatError || state == MediaPlayer::NetworkState::NetworkError || state == MediaPlayer::NetworkState::DecodeError) {</span>
2296         mediaLoadingFailed(state);
2297         return;
2298     }
2299 
<span class="line-modified">2300     if (state == MediaPlayer::NetworkState::Idle) {</span>
2301         if (m_networkState &gt; NETWORK_IDLE) {
2302             changeNetworkStateFromLoadingToIdle();
2303             setShouldDelayLoadEvent(false);
2304         } else {
2305             m_networkState = NETWORK_IDLE;
2306         }
2307     }
2308 
<span class="line-modified">2309     if (state == MediaPlayer::NetworkState::Loading) {</span>
2310         if (m_networkState &lt; NETWORK_LOADING || m_networkState == NETWORK_NO_SOURCE)
2311             startProgressEventTimer();
2312         m_networkState = NETWORK_LOADING;
2313     }
2314 
<span class="line-modified">2315     if (state == MediaPlayer::NetworkState::Loaded) {</span>
2316         if (m_networkState != NETWORK_IDLE)
2317             changeNetworkStateFromLoadingToIdle();
2318         m_completelyLoaded = true;
2319     }
2320 
2321     if (hasMediaControls())
2322         mediaControls()-&gt;updateStatusDisplay();
2323 }
2324 
2325 void HTMLMediaElement::changeNetworkStateFromLoadingToIdle()
2326 {
2327     m_progressEventTimer.stop();
2328     if (hasMediaControls() &amp;&amp; m_player-&gt;didLoadingProgress())
2329         mediaControls()-&gt;bufferingProgressed();
2330 
2331     // Schedule one last progress event so we guarantee that at least one is fired
2332     // for files that load very quickly.
2333     scheduleEvent(eventNames().progressEvent);
2334     scheduleEvent(eventNames().suspendEvent);
2335     m_networkState = NETWORK_IDLE;
2336 }
2337 
<span class="line-modified">2338 void HTMLMediaElement::mediaPlayerReadyStateChanged()</span>
2339 {
<span class="line-added">2340     if (isSuspended()) {</span>
<span class="line-added">2341         queueTaskKeepingObjectAlive(*this, TaskSource::MediaElement, [this] {</span>
<span class="line-added">2342             mediaPlayerReadyStateChanged();</span>
<span class="line-added">2343         });</span>
<span class="line-added">2344         return;</span>
<span class="line-added">2345     }</span>
<span class="line-added">2346 </span>
2347     beginProcessingMediaPlayerCallback();
2348 
2349     setReadyState(m_player-&gt;readyState());
2350 
2351     endProcessingMediaPlayerCallback();
2352 }
2353 
2354 SuccessOr&lt;MediaPlaybackDenialReason&gt; HTMLMediaElement::canTransitionFromAutoplayToPlay() const
2355 {
2356     if (m_readyState != HAVE_ENOUGH_DATA) {
2357         ALWAYS_LOG(LOGIDENTIFIER, &quot;m_readyState != HAVE_ENOUGH_DATA&quot;);
2358         return MediaPlaybackDenialReason::PageConsentRequired;
2359     }
2360     if (!isAutoplaying()) {
2361         ALWAYS_LOG(LOGIDENTIFIER, &quot;!isAutoplaying&quot;);
2362         return MediaPlaybackDenialReason::PageConsentRequired;
2363     }
2364     if (!mediaSession().autoplayPermitted()) {
2365         ALWAYS_LOG(LOGIDENTIFIER, &quot;!mediaSession().autoplayPermitted&quot;);
2366         return MediaPlaybackDenialReason::PageConsentRequired;
</pre>
<hr />
<pre>
2543         updateDisplayState();
2544         if (hasMediaControls()) {
2545             mediaControls()-&gt;refreshClosedCaptionsButtonVisibility();
2546             mediaControls()-&gt;updateStatusDisplay();
2547         }
2548     }
2549 
2550     updatePlayState();
2551     updateMediaController();
2552 #if ENABLE(VIDEO_TRACK)
2553     updateActiveTextTrackCues(currentMediaTime());
2554 #endif
2555 }
2556 
2557 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
2558 RefPtr&lt;ArrayBuffer&gt; HTMLMediaElement::mediaPlayerCachedKeyForKeyId(const String&amp; keyId) const
2559 {
2560     return m_webKitMediaKeys ? m_webKitMediaKeys-&gt;cachedKeyForKeyId(keyId) : nullptr;
2561 }
2562 
<span class="line-modified">2563 bool HTMLMediaElement::mediaPlayerKeyNeeded(Uint8Array* initData)</span>
2564 {
2565     if (!RuntimeEnabledFeatures::sharedFeatures().legacyEncryptedMediaAPIEnabled())
2566         return false;
2567 
2568     if (!hasEventListeners(&quot;webkitneedkey&quot;)
2569 #if ENABLE(ENCRYPTED_MEDIA)
2570         // Only fire an error if ENCRYPTED_MEDIA is not enabled, to give clients of the
2571         // &quot;encrypted&quot; event a chance to handle it without resulting in a synthetic error.
2572         &amp;&amp; (!RuntimeEnabledFeatures::sharedFeatures().encryptedMediaAPIEnabled() || document().quirks().hasBrokenEncryptedMediaAPISupportQuirk())
2573 #endif
2574         ) {
2575         m_error = MediaError::create(MediaError::MEDIA_ERR_ENCRYPTED);
2576         scheduleEvent(eventNames().errorEvent);
2577         return false;
2578     }
2579 
2580     auto event = WebKitMediaKeyNeededEvent::create(eventNames().webkitneedkeyEvent, initData);
2581     event-&gt;setTarget(this);
<span class="line-modified">2582     m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
2583 
2584     return true;
2585 }
2586 
2587 String HTMLMediaElement::mediaPlayerMediaKeysStorageDirectory() const
2588 {
2589     auto* page = document().page();
2590     if (!page || page-&gt;usesEphemeralSession())
2591         return emptyString();
2592 
2593     String storageDirectory = document().settings().mediaKeysStorageDirectory();
2594     if (storageDirectory.isEmpty())
2595         return emptyString();
2596 
2597     return FileSystem::pathByAppendingComponent(storageDirectory, document().securityOrigin().data().databaseIdentifier());
2598 }
2599 
2600 void HTMLMediaElement::webkitSetMediaKeys(WebKitMediaKeys* mediaKeys)
2601 {
2602     if (!RuntimeEnabledFeatures::sharedFeatures().legacyEncryptedMediaAPIEnabled())
</pre>
<hr />
<pre>
2709         return;
2710 
2711     // https://w3c.github.io/encrypted-media/#initdata-encountered
2712     // W3C Editor&#39;s Draft 23 June 2017
2713 
2714     // 1. Let the media element be the specified HTMLMediaElement object.
2715     // 2. Let initDataType be the empty string.
2716     // 3. Let initData be null.
2717     // 4. If the media data is CORS-same-origin and not mixed content, run the following steps:
2718     //   4.1. Let initDataType be the string representing the Initialization Data Type of the Initialization Data.
2719     //   4.2. Let initData be the Initialization Data.
2720     // FIXME: ^
2721 
2722     // 5. Queue a task to create an event named encrypted that does not bubble and is not cancellable using the
2723     //    MediaEncryptedEvent interface with its type attribute set to encrypted and its isTrusted attribute
2724     //    initialized to true, and dispatch it at the media element.
2725     //    The event interface MediaEncryptedEvent has:
2726     //      initDataType = initDataType
2727     //      initData = initData
2728     MediaEncryptedEventInit initializer { initDataType, WTFMove(initData) };
<span class="line-modified">2729     m_asyncEventQueue-&gt;enqueueEvent(MediaEncryptedEvent::create(eventNames().encryptedEvent, initializer, Event::IsTrusted::Yes));</span>
2730 }
2731 
2732 void HTMLMediaElement::mediaPlayerWaitingForKeyChanged()
2733 {
2734     if (!m_player)
2735         return;
2736 
2737     if (!m_player-&gt;waitingForKey() &amp;&amp; m_playbackBlockedWaitingForKey) {
2738         // https://w3c.github.io/encrypted-media/#resume-playback
2739         // W3C Editor&#39;s Draft 23 June 2017
2740 
2741         // NOTE: continued from HTMLMediaElement::attemptToDecrypt().
2742         // 4. If the user agent can advance the current playback position in the direction of playback:
2743         //   4.1. Set the media element&#39;s decryption blocked waiting for key value to false.
2744         // FIXME: ^
2745         //   4.2. Set the media element&#39;s playback blocked waiting for key value to false.
2746         m_playbackBlockedWaitingForKey = false;
2747 
2748         //   4.3. Set the media element&#39;s readyState value to HAVE_CURRENT_DATA, HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA as appropriate.
2749         setReadyState(m_player-&gt;readyState());
</pre>
<hr />
<pre>
2949 
2950 void HTMLMediaElement::seekInternal(const MediaTime&amp; time)
2951 {
2952     INFO_LOG(LOGIDENTIFIER, time);
2953     seekWithTolerance(time, MediaTime::zeroTime(), MediaTime::zeroTime(), false);
2954 }
2955 
2956 void HTMLMediaElement::seekWithTolerance(const MediaTime&amp; inTime, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance, bool fromDOM)
2957 {
2958     // 4.8.10.9 Seeking
2959     MediaTime time = inTime;
2960 
2961     // 1 - Set the media element&#39;s show poster flag to false.
2962     setDisplayMode(Video);
2963 
2964     // 2 - If the media element&#39;s readyState is HAVE_NOTHING, abort these steps.
2965     if (m_readyState == HAVE_NOTHING || !m_player)
2966         return;
2967 
2968     // If the media engine has been told to postpone loading data, let it go ahead now.
<span class="line-modified">2969     if (m_preload &lt; MediaPlayer::Preload::Auto &amp;&amp; m_readyState &lt; HAVE_FUTURE_DATA)</span>
2970         prepareToPlay();
2971 
2972     // Get the current time before setting m_seeking, m_lastSeekTime is returned once it is set.
2973     refreshCachedTime();
2974     MediaTime now = currentMediaTime();
2975 
2976     // 3 - If the element&#39;s seeking IDL attribute is true, then another instance of this algorithm is
2977     // already running. Abort that other instance of the algorithm without waiting for the step that
2978     // it is running to complete.
2979     if (m_seekTaskQueue.hasPendingTask()) {
2980         INFO_LOG(LOGIDENTIFIER, &quot;cancelling pending seeks&quot;);
2981         m_seekTaskQueue.cancelTask();
2982         if (m_pendingSeek) {
2983             now = m_pendingSeek-&gt;now;
2984             m_pendingSeek = nullptr;
2985         }
2986         m_pendingSeekType = NoSeek;
2987     }
2988 
2989     // 4 - Set the seeking IDL attribute to true.
</pre>
<hr />
<pre>
3121 
3122     // 17 - Queue a task to fire a simple event named seeked at the element.
3123     scheduleEvent(eventNames().seekedEvent);
3124 
3125     if (m_mediaSession)
3126         m_mediaSession-&gt;clientCharacteristicsChanged();
3127 
3128 #if ENABLE(MEDIA_SOURCE)
3129     if (m_mediaSource)
3130         m_mediaSource-&gt;monitorSourceBuffers();
3131 #endif
3132 }
3133 
3134 HTMLMediaElement::ReadyState HTMLMediaElement::readyState() const
3135 {
3136     return m_readyState;
3137 }
3138 
3139 MediaPlayer::MovieLoadType HTMLMediaElement::movieLoadType() const
3140 {
<span class="line-modified">3141     return m_player ? m_player-&gt;movieLoadType() : MediaPlayer::MovieLoadType::Unknown;</span>
3142 }
3143 
3144 bool HTMLMediaElement::hasAudio() const
3145 {
3146     return m_player ? m_player-&gt;hasAudio() : false;
3147 }
3148 
3149 bool HTMLMediaElement::seeking() const
3150 {
3151     return m_seeking;
3152 }
3153 
3154 void HTMLMediaElement::refreshCachedTime() const
3155 {
3156     if (!m_player)
3157         return;
3158 
3159     m_cachedTime = m_player-&gt;currentTime();
3160     if (!m_cachedTime) {
3161         // Do not use m_cachedTime until the media engine returns a non-zero value because we can&#39;t
</pre>
<hr />
<pre>
3417     // The ended attribute must return true if the media element has ended
3418     // playback and the direction of playback is forwards, and false otherwise.
3419     return endedPlayback() &amp;&amp; requestedPlaybackRate() &gt; 0;
3420 }
3421 
3422 bool HTMLMediaElement::autoplay() const
3423 {
3424     return hasAttributeWithoutSynchronization(autoplayAttr);
3425 }
3426 
3427 String HTMLMediaElement::preload() const
3428 {
3429 #if ENABLE(MEDIA_STREAM)
3430     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3431     // &quot;preload&quot; - On getting: none. On setting: ignored.
3432     if (m_mediaStreamSrcObject)
3433         return &quot;none&quot;_s;
3434 #endif
3435 
3436     switch (m_preload) {
<span class="line-modified">3437     case MediaPlayer::Preload::None:</span>
3438         return &quot;none&quot;_s;
<span class="line-modified">3439     case MediaPlayer::Preload::MetaData:</span>
3440         return &quot;metadata&quot;_s;
<span class="line-modified">3441     case MediaPlayer::Preload::Auto:</span>
3442         return &quot;auto&quot;_s;
3443     }
3444 
3445     ASSERT_NOT_REACHED();
3446     return String();
3447 }
3448 
3449 void HTMLMediaElement::setPreload(const String&amp; preload)
3450 {
3451     INFO_LOG(LOGIDENTIFIER, preload);
3452 #if ENABLE(MEDIA_STREAM)
3453     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3454     // &quot;preload&quot; - On getting: none. On setting: ignored.
3455     if (m_mediaStreamSrcObject)
3456         return;
3457 #endif
3458 
3459     setAttributeWithoutSynchronization(preloadAttr, preload);
3460 }
3461 
</pre>
<hr />
<pre>
3761                 if (hasMediaControls())
3762                     mediaControls()-&gt;changedMute();
3763             }
3764         }
3765 
3766         if (mutedStateChanged)
3767             scheduleEvent(eventNames().volumechangeEvent);
3768 
3769         updateShouldPlay();
3770 
3771 #if ENABLE(MEDIA_SESSION)
3772         document().updateIsPlayingMedia(m_elementID);
3773 #else
3774         document().updateIsPlayingMedia();
3775 #endif
3776 
3777 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
3778         scheduleUpdateMediaState();
3779 #endif
3780         m_mediaSession-&gt;canProduceAudioChanged();
<span class="line-added">3781         updateSleepDisabling();</span>
3782     }
3783 
3784     schedulePlaybackControlsManagerUpdate();
3785 }
3786 
3787 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
3788 void HTMLMediaElement::hardwareMutedStateDidChange(AudioSession* session)
3789 {
3790     if (!session-&gt;isMuted())
3791         return;
3792 
3793     if (!hasAudio())
3794         return;
3795 
3796     if (effectiveMuted() || !volume())
3797         return;
3798 
3799     INFO_LOG(LOGIDENTIFIER);
3800     userDidInterfereWithAutoplay();
3801 }
</pre>
<hr />
<pre>
3989     return buffered.toDouble() / duration.toDouble();
3990 }
3991 
3992 #if ENABLE(VIDEO_TRACK)
3993 
3994 void HTMLMediaElement::mediaPlayerDidAddAudioTrack(AudioTrackPrivate&amp; track)
3995 {
3996     if (isPlaying() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
3997         pauseInternal();
3998         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
3999     }
4000 
4001     addAudioTrack(AudioTrack::create(*this, track));
4002 }
4003 
4004 void HTMLMediaElement::mediaPlayerDidAddTextTrack(InbandTextTrackPrivate&amp; track)
4005 {
4006     // 4.8.10.12.2 Sourcing in-band text tracks
4007     // 1. Associate the relevant data with a new text track and its corresponding new TextTrack object.
4008     auto textTrack = InbandTextTrack::create(*ActiveDOMObject::scriptExecutionContext(), *this, track);
<span class="line-modified">4009     textTrack-&gt;setMediaElement(makeWeakPtr(this));</span>
4010 
4011     // 2. Set the new text track&#39;s kind, label, and language based on the semantics of the relevant data,
4012     // as defined by the relevant specification. If there is no label in that data, then the label must
4013     // be set to the empty string.
4014     // 3. Associate the text track list of cues with the rules for updating the text track rendering appropriate
4015     // for the format in question.
4016     // 4. If the new text track&#39;s kind is metadata, then set the text track in-band metadata track dispatch type
4017     // as follows, based on the type of the media resource:
4018     // 5. Populate the new text track&#39;s list of cues with the cues parsed so far, folllowing the guidelines for exposing
4019     // cues, and begin updating it dynamically as necessary.
4020     //   - Thess are all done by the media engine.
4021 
4022     // 6. Set the new text track&#39;s readiness state to loaded.
4023     textTrack-&gt;setReadinessState(TextTrack::Loaded);
4024 
4025     // 7. Set the new text track&#39;s mode to the mode consistent with the user&#39;s preferences and the requirements of
4026     // the relevant specification for the data.
4027     //  - This will happen in configureTextTracks()
4028     scheduleConfigureTextTracks();
4029 
</pre>
<hr />
<pre>
4146     auto&amp; trackReference = track.get();
4147 
4148     // Note, due to side effects when changing track parameters, we have to
4149     // first append the track to the text track list.
4150 
4151     // 6. Add the new text track to the media element&#39;s list of text tracks.
4152     addTextTrack(WTFMove(track));
4153 
4154     // ... its text track readiness state to the text track loaded state ...
4155     trackReference.setReadinessState(TextTrack::Loaded);
4156 
4157     // ... its text track mode to the text track hidden mode, and its text track list of cues to an empty list ...
4158     trackReference.setMode(TextTrack::Mode::Hidden);
4159 
4160     return trackReference;
4161 }
4162 
4163 AudioTrackList&amp; HTMLMediaElement::ensureAudioTracks()
4164 {
4165     if (!m_audioTracks)
<span class="line-modified">4166         m_audioTracks = AudioTrackList::create(makeWeakPtr(this), ActiveDOMObject::scriptExecutionContext());</span>
4167 
4168     return *m_audioTracks;
4169 }
4170 
4171 TextTrackList&amp; HTMLMediaElement::ensureTextTracks()
4172 {
4173     if (!m_textTracks)
<span class="line-modified">4174         m_textTracks = TextTrackList::create(makeWeakPtr(this), ActiveDOMObject::scriptExecutionContext());</span>
4175 
4176     return *m_textTracks;
4177 }
4178 
4179 VideoTrackList&amp; HTMLMediaElement::ensureVideoTracks()
4180 {
4181     if (!m_videoTracks)
<span class="line-modified">4182         m_videoTracks = VideoTrackList::create(makeWeakPtr(this), ActiveDOMObject::scriptExecutionContext());</span>
4183 
4184     return *m_videoTracks;
4185 }
4186 
4187 void HTMLMediaElement::didAddTextTrack(HTMLTrackElement&amp; trackElement)
4188 {
4189     ASSERT(trackElement.hasTagName(trackTag));
4190 
4191     // 4.8.10.12.3 Sourcing out-of-band text tracks
4192     // When a track element&#39;s parent element changes and the new parent is a media element,
4193     // then the user agent must add the track element&#39;s corresponding text track to the
4194     // media element&#39;s list of text tracks ... [continues in TextTrackList::append]
4195     addTextTrack(trackElement.track());
4196 
4197     // Do not schedule the track loading until parsing finishes so we don&#39;t start before all tracks
4198     // in the markup have been added.
4199     if (!m_parsingInProgress)
4200         scheduleConfigureTextTracks();
4201 
4202     if (hasMediaControls())
</pre>
<hr />
<pre>
4319     if (currentlyEnabledTracks.size()) {
4320         for (size_t i = 0; i &lt; currentlyEnabledTracks.size(); ++i) {
4321             RefPtr&lt;TextTrack&gt; textTrack = currentlyEnabledTracks[i];
4322             if (textTrack != trackToEnable)
4323                 textTrack-&gt;setMode(TextTrack::Mode::Disabled);
4324         }
4325     }
4326 
4327     if (trackToEnable) {
4328         trackToEnable-&gt;setMode(TextTrack::Mode::Showing);
4329 
4330         // If user preferences indicate we should always display captions, make sure we reflect the
4331         // proper status via the webkitClosedCaptionsVisible API call:
4332         if (!webkitClosedCaptionsVisible() &amp;&amp; closedCaptionsVisible() &amp;&amp; displayMode == CaptionUserPreferences::AlwaysOn)
4333             m_webkitLegacyClosedCaptionOverride = true;
4334     }
4335 
4336     m_processingPreferenceChange = false;
4337 }
4338 
<span class="line-modified">4339 static JSC::JSValue controllerJSValue(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, HTMLMediaElement&amp; media)</span>
4340 {
4341     JSC::VM&amp; vm = globalObject.vm();
4342     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">4343     auto mediaJSWrapper = toJS(&amp;lexicalGlobalObject, &amp;globalObject, media);</span>
4344 
4345     // Retrieve the controller through the JS object graph
4346     JSC::JSObject* mediaJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaJSWrapper);
4347     if (!mediaJSWrapperObject)
4348         return JSC::jsNull();
4349 
4350     JSC::Identifier controlsHost = JSC::Identifier::fromString(vm, &quot;controlsHost&quot;);
<span class="line-modified">4351     JSC::JSValue controlsHostJSWrapper = mediaJSWrapperObject-&gt;get(&amp;lexicalGlobalObject, controlsHost);</span>
4352     RETURN_IF_EXCEPTION(scope, JSC::jsNull());
4353 
4354     JSC::JSObject* controlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controlsHostJSWrapper);
4355     if (!controlsHostJSWrapperObject)
4356         return JSC::jsNull();
4357 
4358     JSC::Identifier controllerID = JSC::Identifier::fromString(vm, &quot;controller&quot;);
<span class="line-modified">4359     JSC::JSValue controllerJSWrapper = controlsHostJSWrapperObject-&gt;get(&amp;lexicalGlobalObject, controllerID);</span>
4360     RETURN_IF_EXCEPTION(scope, JSC::jsNull());
4361 
4362     return controllerJSWrapper;
4363 }
4364 
4365 void HTMLMediaElement::ensureMediaControlsShadowRoot()
4366 {
4367     ASSERT(!m_creatingControls);
4368     m_creatingControls = true;
4369     ensureUserAgentShadowRoot();
4370     m_creatingControls = false;
4371 }
4372 
4373 bool HTMLMediaElement::setupAndCallJS(const JSSetupFunction&amp; task)
4374 {
4375     Page* page = document().page();
4376     if (!page)
4377         return false;
4378 
4379     auto pendingActivity = makePendingActivity(*this);
4380     auto&amp; world = ensureIsolatedWorld();
4381     auto&amp; scriptController = document().frame()-&gt;script();
4382     auto* globalObject = JSC::jsCast&lt;JSDOMGlobalObject*&gt;(scriptController.globalObject(world));
4383     auto&amp; vm = globalObject-&gt;vm();
4384     JSC::JSLockHolder lock(vm);
4385     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">4386     auto* lexicalGlobalObject = globalObject;</span>
4387 
4388     RETURN_IF_EXCEPTION(scope, false);
4389 
<span class="line-modified">4390     return task(*globalObject, *lexicalGlobalObject, scriptController, world);</span>
4391 }
4392 
4393 void HTMLMediaElement::updateCaptionContainer()
4394 {
4395 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
4396     if (m_haveSetUpCaptionContainer)
4397         return;
4398 
4399     if (!ensureMediaControlsInjectedScript())
4400         return;
4401 
4402     ensureMediaControlsShadowRoot();
4403 
4404     if (!m_mediaControlsHost)
4405         m_mediaControlsHost = MediaControlsHost::create(this);
4406 
<span class="line-modified">4407     setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::JSGlobalObject&amp; lexicalGlobalObject, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
4408         auto&amp; vm = globalObject.vm();
4409         auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">4410         auto controllerValue = controllerJSValue(lexicalGlobalObject, globalObject, *this);</span>
4411         auto* controllerObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controllerValue);
4412         if (!controllerObject)
4413             return false;
4414 
4415         // The media controls script must provide a method on the Controller object with the following details.
4416         // Name: updateCaptionContainer
4417         // Parameters:
4418         //     None
4419         // Return value:
4420         //     None
<span class="line-modified">4421         auto methodValue = controllerObject-&gt;get(&amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, &quot;updateCaptionContainer&quot;));</span>
4422         auto* methodObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, methodValue);
4423         if (!methodObject)
4424             return false;
4425 
4426         JSC::CallData callData;
4427         auto callType = methodObject-&gt;methodTable(vm)-&gt;getCallData(methodObject, callData);
4428         if (callType == JSC::CallType::None)
4429             return false;
4430 
4431         JSC::MarkedArgumentBuffer noArguments;
4432         ASSERT(!noArguments.hasOverflowed());
<span class="line-modified">4433         JSC::call(&amp;lexicalGlobalObject, methodObject, callType, callData, controllerObject, noArguments);</span>
4434         scope.clearException();
4435 
4436         m_haveSetUpCaptionContainer = true;
4437 
4438         return true;
4439     });
4440 
4441 #endif
4442 }
4443 
4444 void HTMLMediaElement::layoutSizeChanged()
4445 {
4446 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
4447     if (auto frameView = makeRefPtr(document().view())) {
4448         auto task = [this, protectedThis = makeRef(*this)] {
4449             if (auto root = userAgentShadowRoot())
4450                 root-&gt;dispatchEvent(Event::create(&quot;resize&quot;, Event::CanBubble::No, Event::IsCancelable::No));
4451         };
4452         frameView-&gt;queuePostLayoutCallback(WTFMove(task));
4453     }
</pre>
<hr />
<pre>
4656         }
4657 
4658         type = source-&gt;attributeWithoutSynchronization(typeAttr);
4659         if (type.isEmpty() &amp;&amp; mediaURL.protocolIsData())
4660             type = mimeTypeFromDataURL(mediaURL);
4661         if (!type.isEmpty()) {
4662             if (shouldLog)
4663                 INFO_LOG(LOGIDENTIFIER, &quot;&#39;type&#39; is &quot;, type);
4664             MediaEngineSupportParameters parameters;
4665             parameters.type = ContentType(type);
4666             parameters.url = mediaURL;
4667 #if ENABLE(MEDIA_SOURCE)
4668             parameters.isMediaSource = mediaURL.protocolIs(mediaSourceBlobProtocol);
4669 #endif
4670 #if ENABLE(MEDIA_STREAM)
4671             parameters.isMediaStream = mediaURL.protocolIs(mediaStreamBlobProtocol);
4672 #endif
4673             if (!document().settings().allowMediaContentTypesRequiringHardwareSupportAsFallback() || Traversal&lt;HTMLSourceElement&gt;::nextSkippingChildren(source))
4674                 parameters.contentTypesRequiringHardwareSupport = mediaContentTypesRequiringHardwareSupport();
4675 
<span class="line-modified">4676             if (MediaPlayer::supportsType(parameters) == MediaPlayer::SupportsType::IsNotSupported)</span>
4677                 goto CheckAgain;
4678         }
4679 
4680         // Is it safe to load this url?
4681         if (!isSafeToLoadURL(mediaURL, actionIfInvalid) || !dispatchBeforeLoadEvent(mediaURL.string()))
4682             goto CheckAgain;
4683 
4684         // A &#39;beforeload&#39; event handler can mutate the DOM, so check to see if the source element is still a child node.
4685         if (source-&gt;parentNode() != this) {
4686             INFO_LOG(LOGIDENTIFIER, &quot;&#39;beforeload&#39; removed current element&quot;);
4687             continue;
4688         }
4689 
4690         // Making it this far means the &lt;source&gt; looks reasonable.
4691         if (contentType)
4692             *contentType = ContentType(type);
4693         m_nextChildNodeToConsider = Traversal&lt;HTMLSourceElement&gt;::nextSkippingChildren(source);
4694         m_currentSourceNode = WTFMove(source);
4695 
4696         if (shouldLog)
</pre>
<hr />
<pre>
4770     if (willLog(WTFLogLevel::Info) &amp;&amp; source.hasTagName(sourceTag)) {
4771         URL url = source.getNonEmptyURLAttribute(srcAttr);
4772         INFO_LOG(LOGIDENTIFIER, &quot;&#39;src&#39; is &quot;, url);
4773     }
4774 
4775     if (&amp;source != m_currentSourceNode &amp;&amp; &amp;source != m_nextChildNodeToConsider)
4776         return;
4777 
4778     if (&amp;source == m_nextChildNodeToConsider) {
4779         m_nextChildNodeToConsider = m_currentSourceNode ? Traversal&lt;HTMLSourceElement&gt;::nextSibling(*m_currentSourceNode) : nullptr;
4780         INFO_LOG(LOGIDENTIFIER);
4781     } else if (&amp;source == m_currentSourceNode) {
4782         // Clear the current source node pointer, but don&#39;t change the movie as the spec says:
4783         // 4.8.8 - Dynamically modifying a source element and its attribute when the element is already
4784         // inserted in a video or audio element will have no effect.
4785         m_currentSourceNode = nullptr;
4786         INFO_LOG(LOGIDENTIFIER, &quot;m_currentSourceNode cleared&quot;);
4787     }
4788 }
4789 
<span class="line-modified">4790 void HTMLMediaElement::mediaPlayerTimeChanged()</span>
4791 {
4792     INFO_LOG(LOGIDENTIFIER);
4793 
4794 #if ENABLE(VIDEO_TRACK)
4795     updateActiveTextTrackCues(currentMediaTime());
4796 #endif
4797 
4798     beginProcessingMediaPlayerCallback();
4799 
4800     invalidateCachedTime();
4801     bool wasSeeking = seeking();
4802 
4803     // 4.8.10.9 step 14 &amp; 15.  Needed if no ReadyState change is associated with the seek.
4804     if (m_seekRequested &amp;&amp; m_readyState &gt;= HAVE_CURRENT_DATA &amp;&amp; !m_player-&gt;seeking())
4805         finishSeek();
4806 
4807     // Always call scheduleTimeupdateEvent when the media engine reports a time discontinuity,
4808     // it will only queue a &#39;timeupdate&#39; event if we haven&#39;t already posted one at the current
4809     // movie time.
4810     else
</pre>
<hr />
<pre>
4898         if (!paused())
4899             pauseInternal();
4900     }
4901 #else
4902     fastSeek(position);
4903 #endif
4904 }
4905 
4906 void HTMLMediaElement::seekToPlaybackPositionEndedTimerFired()
4907 {
4908 #if PLATFORM(MAC)
4909     if (!m_isScrubbingRemotely)
4910         return;
4911 
4912     PlatformMediaSessionManager::sharedManager().sessionDidEndRemoteScrubbing(*m_mediaSession);
4913     m_isScrubbingRemotely = false;
4914     m_seekToPlaybackPositionEndedTimer.stop();
4915 #endif
4916 }
4917 
<span class="line-modified">4918 void HTMLMediaElement::mediaPlayerVolumeChanged()</span>
4919 {
4920     INFO_LOG(LOGIDENTIFIER);
4921 
4922     beginProcessingMediaPlayerCallback();
4923     if (m_player) {
4924         double vol = m_player-&gt;volume();
4925         if (vol != m_volume) {
4926             m_volume = vol;
4927             updateVolume();
4928             scheduleEvent(eventNames().volumechangeEvent);
4929         }
4930     }
4931     endProcessingMediaPlayerCallback();
4932 }
4933 
<span class="line-modified">4934 void HTMLMediaElement::mediaPlayerMuteChanged()</span>
4935 {
4936     INFO_LOG(LOGIDENTIFIER);
4937 
4938     beginProcessingMediaPlayerCallback();
4939     if (m_player)
4940         setMuted(m_player-&gt;muted());
4941     endProcessingMediaPlayerCallback();
4942 }
4943 
<span class="line-modified">4944 void HTMLMediaElement::mediaPlayerDurationChanged()</span>
4945 {
4946     INFO_LOG(LOGIDENTIFIER);
4947 
4948     beginProcessingMediaPlayerCallback();
4949 
4950     scheduleEvent(eventNames().durationchangeEvent);
<span class="line-modified">4951     mediaPlayerCharacteristicChanged();</span>
4952 
4953     MediaTime now = currentMediaTime();
4954     MediaTime dur = durationMediaTime();
4955     if (now &gt; dur)
4956         seekInternal(dur);
4957 
4958     endProcessingMediaPlayerCallback();
4959 }
4960 
<span class="line-modified">4961 void HTMLMediaElement::mediaPlayerRateChanged()</span>
4962 {
4963     beginProcessingMediaPlayerCallback();
4964 
4965     // Stash the rate in case the one we tried to set isn&#39;t what the engine is
4966     // using (eg. it can&#39;t handle the rate we set)
4967     m_reportedPlaybackRate = m_player-&gt;rate();
4968 
4969     INFO_LOG(LOGIDENTIFIER, &quot;rate: &quot;, m_reportedPlaybackRate);
4970 
4971     if (m_playing)
4972         invalidateCachedTime();
4973 
4974     updateSleepDisabling();
4975 
4976     endProcessingMediaPlayerCallback();
4977 }
4978 
<span class="line-modified">4979 void HTMLMediaElement::mediaPlayerPlaybackStateChanged()</span>
4980 {
4981     INFO_LOG(LOGIDENTIFIER);
4982 
4983     if (!m_player || m_pausedInternal)
4984         return;
4985 
4986     beginProcessingMediaPlayerCallback();
4987     if (m_player-&gt;paused())
4988         pauseInternal();
4989     else
4990         playInternal();
4991 
4992     updateSleepDisabling();
4993 
4994     endProcessingMediaPlayerCallback();
4995 }
4996 
<span class="line-modified">4997 void HTMLMediaElement::mediaPlayerResourceNotSupported()</span>











4998 {
4999     INFO_LOG(LOGIDENTIFIER);
5000 
5001     // The MediaPlayer came across content which no installed engine supports.
<span class="line-modified">5002     mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
5003 }
5004 
5005 // MediaPlayerPresentation methods
<span class="line-modified">5006 void HTMLMediaElement::mediaPlayerRepaint()</span>
5007 {
5008     beginProcessingMediaPlayerCallback();
5009     updateDisplayState();
5010     if (auto* renderer = this-&gt;renderer())
5011         renderer-&gt;repaint();
5012     endProcessingMediaPlayerCallback();
5013 }
5014 
<span class="line-modified">5015 void HTMLMediaElement::mediaPlayerSizeChanged()</span>
5016 {
5017     INFO_LOG(LOGIDENTIFIER);
5018 
5019     if (is&lt;MediaDocument&gt;(document()) &amp;&amp; m_player)
5020         downcast&lt;MediaDocument&gt;(document()).mediaElementNaturalSizeChanged(expandedIntSize(m_player-&gt;naturalSize()));
5021 
5022     beginProcessingMediaPlayerCallback();
5023     if (m_readyState &gt; HAVE_NOTHING)
5024         scheduleResizeEventIfSizeChanged();
5025     updateRenderer();
5026     endProcessingMediaPlayerCallback();
5027 }
5028 
<span class="line-modified">5029 bool HTMLMediaElement::mediaPlayerRenderingCanBeAccelerated()</span>
5030 {
5031     auto* renderer = this-&gt;renderer();
5032     return is&lt;RenderVideo&gt;(renderer)
5033         &amp;&amp; downcast&lt;RenderVideo&gt;(*renderer).view().compositor().canAccelerateVideoRendering(downcast&lt;RenderVideo&gt;(*renderer));
5034 }
5035 
<span class="line-modified">5036 void HTMLMediaElement::mediaPlayerRenderingModeChanged()</span>
5037 {
5038     INFO_LOG(LOGIDENTIFIER);
5039 
5040     // Kick off a fake recalcStyle that will update the compositing tree.
5041     invalidateStyleAndLayerComposition();
5042 }
5043 
5044 bool HTMLMediaElement::mediaPlayerAcceleratedCompositingEnabled()
5045 {
5046     return document().settings().acceleratedCompositingEnabled();
5047 }
5048 
5049 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
5050 
<span class="line-modified">5051 GraphicsDeviceAdapter* HTMLMediaElement::mediaPlayerGraphicsDeviceAdapter() const</span>
5052 {
5053     auto* page = document().page();
5054     if (!page)
5055         return nullptr;
5056     return page-&gt;chrome().client().graphicsDeviceAdapter();
5057 }
5058 
5059 #endif
5060 
5061 void HTMLMediaElement::scheduleMediaEngineWasUpdated()
5062 {
5063     if (m_mediaEngineUpdatedTask.hasPendingTask())
5064         return;
5065 
5066     auto logSiteIdentifier = LOGIDENTIFIER;
5067     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
5068     m_mediaEngineUpdatedTask.scheduleTask([this, logSiteIdentifier] {
5069         UNUSED_PARAM(logSiteIdentifier);
5070         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
5071         Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // mediaEngineWasUpdated calls methods that can trigger arbitrary DOM mutations.
</pre>
<hr />
<pre>
5091 #endif
5092 
5093 #if ENABLE(ENCRYPTED_MEDIA)
5094     if (m_player &amp;&amp; m_mediaKeys)
5095         m_player-&gt;cdmInstanceAttached(m_mediaKeys-&gt;cdmInstance());
5096 #endif
5097 
5098 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
5099     if (!m_player)
5100         return;
5101     m_player-&gt;setVideoFullscreenFrame(m_videoFullscreenFrame);
5102     m_player-&gt;setVideoFullscreenGravity(m_videoFullscreenGravity);
5103     m_player-&gt;setVideoFullscreenLayer(m_videoFullscreenLayer.get());
5104 #endif
5105 
5106 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5107     scheduleUpdateMediaState();
5108 #endif
5109 }
5110 
<span class="line-modified">5111 void HTMLMediaElement::mediaPlayerEngineUpdated()</span>
5112 {
5113     INFO_LOG(LOGIDENTIFIER);
5114 
5115 #if ENABLE(MEDIA_SOURCE)
5116     m_droppedVideoFrames = 0;
5117 #endif
5118 
5119     m_havePreparedToPlay = false;
5120 
5121     scheduleMediaEngineWasUpdated();
5122 }
5123 
<span class="line-modified">5124 void HTMLMediaElement::mediaPlayerFirstVideoFrameAvailable()</span>
5125 {
5126     INFO_LOG(LOGIDENTIFIER, &quot;current display mode = &quot;, (int)displayMode());
5127 
5128     beginProcessingMediaPlayerCallback();
5129     if (displayMode() == PosterWaitingForVideo) {
5130         setDisplayMode(Video);
<span class="line-modified">5131         mediaPlayerRenderingModeChanged();</span>
5132     }
5133     endProcessingMediaPlayerCallback();
5134 }
5135 
<span class="line-modified">5136 void HTMLMediaElement::mediaPlayerCharacteristicChanged()</span>
5137 {
5138     INFO_LOG(LOGIDENTIFIER);
5139 
5140     beginProcessingMediaPlayerCallback();
5141 
5142 #if ENABLE(VIDEO_TRACK)
5143     if (captionDisplayMode() == CaptionUserPreferences::Automatic &amp;&amp; m_subtitleTrackLanguage != m_player-&gt;languageOfPrimaryAudioTrack())
5144         markCaptionAndSubtitleTracksAsUnconfigured(AfterDelay);
5145 #endif
5146 
5147     if (potentiallyPlaying() &amp;&amp; displayMode() == PosterWaitingForVideo) {
5148         setDisplayMode(Video);
<span class="line-modified">5149         mediaPlayerRenderingModeChanged();</span>
5150     }
5151 
5152     if (hasMediaControls())
5153         mediaControls()-&gt;reset();
5154     updateRenderer();
5155 
5156     if (!paused() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
5157         pauseInternal();
5158         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
5159     }
5160 
5161 #if ENABLE(MEDIA_SESSION)
5162     document().updateIsPlayingMedia(m_elementID);
5163 #else
5164     document().updateIsPlayingMedia();
5165 #endif
5166 
5167     m_hasEverHadAudio |= hasAudio();
5168     m_hasEverHadVideo |= hasVideo();
5169 
</pre>
<hr />
<pre>
5465     if (m_playing)
5466         scheduleNotifyAboutPlaying();
5467 
5468 #if ENABLE(MEDIA_SESSION)
5469     document().updateIsPlayingMedia(m_elementID);
5470 #else
5471     document().updateIsPlayingMedia();
5472 #endif
5473 
5474 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5475     scheduleUpdateMediaState();
5476 #endif
5477 }
5478 
5479 void HTMLMediaElement::setPausedInternal(bool b)
5480 {
5481     m_pausedInternal = b;
5482     scheduleUpdatePlayState();
5483 }
5484 
<span class="line-added">5485 void HTMLMediaElement::pauseAndUpdatePlayStateImmediately()</span>
<span class="line-added">5486 {</span>
<span class="line-added">5487     m_pausedInternal = true;</span>
<span class="line-added">5488     updatePlayState();</span>
<span class="line-added">5489 }</span>
<span class="line-added">5490 </span>
5491 void HTMLMediaElement::stopPeriodicTimers()
5492 {
5493     m_progressEventTimer.stop();
5494     m_playbackProgressTimer.stop();
5495 }
5496 
5497 void HTMLMediaElement::cancelPendingTasks()
5498 {
5499     m_configureTextTracksTask.cancelTask();
5500     m_checkPlaybackTargetCompatablityTask.cancelTask();
5501     m_updateMediaStateTask.cancelTask();
5502     m_mediaEngineUpdatedTask.cancelTask();
5503     m_updatePlayStateTask.cancelTask();
5504 #if PLATFORM(IOS_FAMILY)
5505     m_volumeRevertTaskQueue.cancelTask();
5506 #endif
5507 }
5508 
5509 void HTMLMediaElement::userCancelledLoad()
5510 {
</pre>
<hr />
<pre>
5565 }
5566 
5567 void HTMLMediaElement::clearMediaPlayer()
5568 {
5569 #if ENABLE(MEDIA_STREAM)
5570     if (!m_settingMediaStreamSrcObject)
5571         m_mediaStreamSrcObject = nullptr;
5572 #endif
5573 
5574 #if ENABLE(MEDIA_SOURCE)
5575     detachMediaSource();
5576 #endif
5577 
5578     m_blob = nullptr;
5579 
5580 #if ENABLE(VIDEO_TRACK)
5581     forgetResourceSpecificTracks();
5582 #endif
5583 
5584 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified">5585     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent) || m_remote-&gt;hasAvailabilityCallbacks()) {</span>
5586         m_hasPlaybackTargetAvailabilityListeners = false;
5587         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
5588 
5589         // Send an availability event in case scripts want to hide the picker when the element
5590         // doesn&#39;t support playback to a target.
5591         enqueuePlaybackTargetAvailabilityChangedEvent();
5592     }
5593 
5594     if (m_isPlayingToWirelessTarget)
5595         setIsPlayingToWirelessTarget(false);
5596 #endif
5597 
5598     if (m_isWaitingUntilMediaCanStart) {
5599         m_isWaitingUntilMediaCanStart = false;
5600         document().removeMediaCanStartListener(*this);
5601     }
5602 
5603     if (m_player) {
5604         m_player-&gt;invalidate();
5605         m_player = nullptr;
</pre>
<hr />
<pre>
5607     schedulePlaybackControlsManagerUpdate();
5608 
5609     stopPeriodicTimers();
5610     cancelPendingTasks();
5611 
5612     m_loadState = WaitingForSource;
5613 
5614 #if ENABLE(VIDEO_TRACK)
5615     if (m_textTracks)
5616         configureTextTrackDisplay();
5617 #endif
5618 
5619     m_mediaSession-&gt;clientCharacteristicsChanged();
5620     m_mediaSession-&gt;canProduceAudioChanged();
5621 
5622     m_resourceSelectionTaskQueue.cancelAllTasks();
5623 
5624     updateSleepDisabling();
5625 }
5626 





5627 const char* HTMLMediaElement::activeDOMObjectName() const
5628 {
5629     return &quot;HTMLMediaElement&quot;;
5630 }
5631 
5632 void HTMLMediaElement::stopWithoutDestroyingMediaPlayer()
5633 {
5634     INFO_LOG(LOGIDENTIFIER);
5635 
5636     if (m_videoFullscreenMode != VideoFullscreenModeNone)
5637         exitFullscreen();
5638 
5639     setPreparedToReturnVideoLayerToInline(true);
5640 
5641     schedulePlaybackControlsManagerUpdate();
5642     setInActiveDocument(false);
5643 
5644     // Stop the playback without generating events
5645     setPlaying(false);
<span class="line-modified">5646     pauseAndUpdatePlayStateImmediately();</span>
<span class="line-modified">5647     m_mediaSession-&gt;clientWillBeDOMSuspended();</span>
5648 
5649     setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
5650 
5651     userCancelledLoad();
5652 
5653     updateRenderer();
5654 
5655     stopPeriodicTimers();
5656 
5657     updateSleepDisabling();
5658 }
5659 
5660 void HTMLMediaElement::closeTaskQueues()
5661 {
5662     m_configureTextTracksTask.close();
5663     m_checkPlaybackTargetCompatablityTask.close();
5664     m_updateMediaStateTask.close();
5665     m_mediaEngineUpdatedTask.close();
5666     m_updatePlayStateTask.close();
5667     m_resumeTaskQueue.close();
5668     m_seekTaskQueue.close();
5669     m_playbackControlsManagerBehaviorRestrictionsQueue.close();
5670     m_seekTaskQueue.close();
5671     m_resumeTaskQueue.close();
5672     m_promiseTaskQueue.close();
5673     m_pauseAfterDetachedTaskQueue.close();
5674     m_resourceSelectionTaskQueue.close();
5675     m_visibilityChangeTaskQueue.close();
5676 #if ENABLE(ENCRYPTED_MEDIA)
5677     m_encryptedMediaQueue.close();
5678 #endif
<span class="line-modified">5679     m_asyncEventQueue-&gt;close();</span>
5680 #if PLATFORM(IOS_FAMILY)
5681     m_volumeRevertTaskQueue.close();
5682 #endif
5683 }
5684 
5685 void HTMLMediaElement::contextDestroyed()
5686 {
5687     closeTaskQueues();
5688     m_pendingPlayPromises.clear();
5689 
5690     ActiveDOMObject::contextDestroyed();
5691 }
5692 
5693 void HTMLMediaElement::stop()
5694 {
5695     INFO_LOG(LOGIDENTIFIER);
5696 
5697     Ref&lt;HTMLMediaElement&gt; protectedThis(*this);
5698     stopWithoutDestroyingMediaPlayer();
5699     closeTaskQueues();
5700 
5701     // Once an active DOM object has been stopped it can not be restarted, so we can deallocate
5702     // the media player now. Note that userCancelledLoad will already called clearMediaPlayer
5703     // if the media was not fully loaded, but we need the same cleanup if the file was completely
5704     // loaded and calling it again won&#39;t cause any problems.
5705     clearMediaPlayer();
5706 
5707     m_mediaSession-&gt;stopSession();
5708 }
5709 
5710 void HTMLMediaElement::suspend(ReasonForSuspension reason)
5711 {
5712     INFO_LOG(LOGIDENTIFIER);
5713     Ref&lt;HTMLMediaElement&gt; protectedThis(*this);
5714 
5715     m_resumeTaskQueue.cancelTask();
5716 
5717     switch (reason) {
<span class="line-modified">5718     case ReasonForSuspension::BackForwardCache:</span>
5719         stopWithoutDestroyingMediaPlayer();

5720         setBufferingPolicy(BufferingPolicy::MakeResourcesPurgeable);
5721         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
5722         break;
5723     case ReasonForSuspension::PageWillBeSuspended:
5724     case ReasonForSuspension::JavaScriptDebuggerPaused:
5725     case ReasonForSuspension::WillDeferLoading:
5726         // Do nothing, we don&#39;t pause media playback in these cases.
5727         break;
5728     }
5729 }
5730 
5731 void HTMLMediaElement::resume()
5732 {
5733     INFO_LOG(LOGIDENTIFIER);
5734 
5735     setInActiveDocument(true);
5736 


5737     if (!m_mediaSession-&gt;pageAllowsPlaybackAfterResuming())
5738         document().addMediaCanStartListener(*this);
5739     else
5740         setPausedInternal(false);
5741 
5742     m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
5743     m_mediaSession-&gt;updateBufferingPolicy();
5744 
5745     if (m_error &amp;&amp; m_error-&gt;code() == MediaError::MEDIA_ERR_ABORTED &amp;&amp; !m_resumeTaskQueue.hasPendingTask()) {
<span class="line-modified">5746         // Restart the load if it was aborted in the middle by moving the document to the back/forward cache.</span>
5747         // m_error is only left at MEDIA_ERR_ABORTED when the document becomes inactive (it is set to
5748         //  MEDIA_ERR_ABORTED while the abortEvent is being sent, but cleared immediately afterwards).
5749         // This behavior is not specified but it seems like a sensible thing to do.
5750         // As it is not safe to immedately start loading now, let&#39;s schedule a load.
5751         m_resumeTaskQueue.scheduleTask(std::bind(&amp;HTMLMediaElement::prepareForLoad, this));
5752     }
5753 
5754     updateRenderer();
5755 }
5756 
5757 bool HTMLMediaElement::hasPendingActivity() const
5758 {
<span class="line-modified">5759     return (hasAudio() &amp;&amp; isPlaying()) || m_asyncEventQueue-&gt;hasPendingEvents() || m_creatingControls;</span>
5760 }
5761 
5762 void HTMLMediaElement::mediaVolumeDidChange()
5763 {
<span class="line-added">5764     // FIXME: We should try to reconcile this so there&#39;s no difference for PLATFORM(IOS_FAMILY).</span>
<span class="line-added">5765 #if !PLATFORM(IOS_FAMILY)</span>
5766     INFO_LOG(LOGIDENTIFIER);
5767     updateVolume();
<span class="line-added">5768 #endif</span>
5769 }
5770 
5771 void HTMLMediaElement::visibilityStateChanged()
5772 {
5773     bool elementIsHidden = document().hidden() &amp;&amp; m_videoFullscreenMode != VideoFullscreenModePictureInPicture;
5774     if (elementIsHidden == m_elementIsHidden)
5775         return;
5776 
5777     m_elementIsHidden = elementIsHidden;
5778     INFO_LOG(LOGIDENTIFIER, &quot;visible = &quot;, !m_elementIsHidden);
5779 
5780     updateSleepDisabling();
5781     m_mediaSession-&gt;visibilityChanged();
5782     if (m_player)
5783         m_player-&gt;setVisible(!m_elementIsHidden);
5784 
5785     bool isPlayingAudio = isPlaying() &amp;&amp; hasAudio() &amp;&amp; !muted() &amp;&amp; volume();
5786     if (!isPlayingAudio) {
5787         if (m_elementIsHidden) {
5788             ALWAYS_LOG(LOGIDENTIFIER, &quot;Suspending playback after going to the background&quot;);
</pre>
<hr />
<pre>
5807 }
5808 
5809 void HTMLMediaElement::syncTextTrackBounds()
5810 {
5811     if (m_player)
5812         m_player-&gt;syncTextTrackBounds();
5813 }
5814 #endif // ENABLE(VIDEO_TRACK)
5815 
5816 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5817 void HTMLMediaElement::webkitShowPlaybackTargetPicker()
5818 {
5819     ALWAYS_LOG(LOGIDENTIFIER);
5820     if (processingUserGestureForMedia())
5821         removeBehaviorRestrictionsAfterFirstUserGesture();
5822     m_mediaSession-&gt;showPlaybackTargetPicker();
5823 }
5824 
5825 void HTMLMediaElement::wirelessRoutesAvailableDidChange()
5826 {
<span class="line-added">5827     bool hasTargets = m_mediaSession-&gt;hasWirelessPlaybackTargets();</span>
<span class="line-added">5828     m_remote-&gt;availabilityChanged(hasTargets);</span>
<span class="line-added">5829 </span>
5830     enqueuePlaybackTargetAvailabilityChangedEvent();
5831 }
5832 
<span class="line-modified">5833 void HTMLMediaElement::mediaPlayerCurrentPlaybackTargetIsWirelessChanged(bool isCurrentPlayBackTargetWireless)</span>
5834 {
<span class="line-modified">5835     setIsPlayingToWirelessTarget(m_player &amp;&amp; isCurrentPlayBackTargetWireless);</span>
5836 }
5837 
5838 void HTMLMediaElement::setIsPlayingToWirelessTarget(bool isPlayingToWirelessTarget)
5839 {
5840     m_playbackTargetIsWirelessQueue.enqueueTask([this, isPlayingToWirelessTarget] {
5841         if (isPlayingToWirelessTarget == m_isPlayingToWirelessTarget)
5842             return;
5843         m_isPlayingToWirelessTarget = m_player &amp;&amp; m_player-&gt;isCurrentPlaybackTargetWireless();
<span class="line-modified">5844         m_remote-&gt;isPlayingToRemoteTargetChanged(m_isPlayingToWirelessTarget);</span>
5845         ALWAYS_LOG(LOGIDENTIFIER, m_isPlayingToWirelessTarget);
5846         configureMediaControls();
5847         m_mediaSession-&gt;isPlayingToWirelessPlaybackTargetChanged(m_isPlayingToWirelessTarget);
5848         m_mediaSession-&gt;canProduceAudioChanged();
5849         scheduleUpdateMediaState();
5850         updateSleepDisabling();
5851 
5852         m_failedToPlayToWirelessTarget = false;
5853         scheduleCheckPlaybackTargetCompatability();
5854 
5855         dispatchEvent(Event::create(eventNames().webkitcurrentplaybacktargetiswirelesschangedEvent, Event::CanBubble::No, Event::IsCancelable::Yes));
5856     });
5857 }
5858 
5859 void HTMLMediaElement::dispatchEvent(Event&amp; event)
5860 {
5861     DEBUG_LOG(LOGIDENTIFIER, event.type());
5862 
5863     if (m_removedBehaviorRestrictionsAfterFirstUserGesture &amp;&amp; event.type() == eventNames().endedEvent)
5864         document().userActivatedMediaFinishedPlaying();
5865 
5866     HTMLElement::dispatchEvent(event);
5867 }
5868 
5869 bool HTMLMediaElement::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)
5870 {
5871     if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
5872         return Node::addEventListener(eventType, WTFMove(listener), options);
5873 
<span class="line-modified">5874     bool isFirstAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent) &amp;&amp; !m_remote-&gt;hasAvailabilityCallbacks();</span>
<span class="line-added">5875 </span>
5876     if (!Node::addEventListener(eventType, WTFMove(listener), options))
5877         return false;
5878 
5879     if (isFirstAvailabilityChangedListener) {
5880         m_hasPlaybackTargetAvailabilityListeners = true;
5881         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(true);
5882     }
5883 
5884     INFO_LOG(LOGIDENTIFIER, &quot;&#39;webkitplaybacktargetavailabilitychanged&#39;&quot;);
5885 
5886     enqueuePlaybackTargetAvailabilityChangedEvent(); // Ensure the event listener gets at least one event.
5887     return true;
5888 }
5889 
5890 bool HTMLMediaElement::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)
5891 {
5892     if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
5893         return Node::removeEventListener(eventType, listener, options);
5894 
5895     if (!Node::removeEventListener(eventType, listener, options))
5896         return false;
5897 
<span class="line-modified">5898     bool didRemoveLastAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent) &amp;&amp; !m_remote-&gt;hasAvailabilityCallbacks();</span>
5899     INFO_LOG(LOGIDENTIFIER, &quot;removed last listener = &quot;, didRemoveLastAvailabilityChangedListener);
5900     if (didRemoveLastAvailabilityChangedListener) {
5901         m_hasPlaybackTargetAvailabilityListeners = false;
5902         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
5903         scheduleUpdateMediaState();
5904     }
5905 
5906     return true;
5907 }
5908 
5909 void HTMLMediaElement::enqueuePlaybackTargetAvailabilityChangedEvent()
5910 {
5911     bool hasTargets = m_mediaSession-&gt;hasWirelessPlaybackTargets();
5912     INFO_LOG(LOGIDENTIFIER, &quot;hasTargets = &quot;, hasTargets);
5913     auto event = WebKitPlaybackTargetAvailabilityEvent::create(eventNames().webkitplaybacktargetavailabilitychangedEvent, hasTargets);
5914     event-&gt;setTarget(this);
<span class="line-modified">5915     m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
5916     scheduleUpdateMediaState();
5917 }
5918 
5919 void HTMLMediaElement::setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; device)
5920 {
5921     ALWAYS_LOG(LOGIDENTIFIER);
<span class="line-added">5922     bool hasActiveRoute = device-&gt;hasActiveRoute();</span>
5923     if (m_player)
5924         m_player-&gt;setWirelessPlaybackTarget(WTFMove(device));
<span class="line-added">5925 </span>
<span class="line-added">5926     m_remote-&gt;shouldPlayToRemoteTargetChanged(hasActiveRoute);</span>
5927 }
5928 
5929 void HTMLMediaElement::setShouldPlayToPlaybackTarget(bool shouldPlay)
5930 {
5931     ALWAYS_LOG(LOGIDENTIFIER, shouldPlay);
5932 
5933     if (m_player)
5934         m_player-&gt;setShouldPlayToPlaybackTarget(shouldPlay);
5935 }
5936 
<span class="line-added">5937 void HTMLMediaElement::playbackTargetPickerWasDismissed()</span>
<span class="line-added">5938 {</span>
<span class="line-added">5939     m_remote-&gt;playbackTargetPickerWasDismissed();</span>
<span class="line-added">5940 }</span>
<span class="line-added">5941 </span>
<span class="line-added">5942 void HTMLMediaElement::remoteHasAvailabilityCallbacksChanged()</span>
<span class="line-added">5943 {</span>
<span class="line-added">5944     bool hasListeners = hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent) || m_remote-&gt;hasAvailabilityCallbacks();</span>
<span class="line-added">5945     if (m_hasPlaybackTargetAvailabilityListeners == hasListeners)</span>
<span class="line-added">5946         return;</span>
<span class="line-added">5947 </span>
<span class="line-added">5948     INFO_LOG(LOGIDENTIFIER, &quot;hasListeners: &quot;, hasListeners);</span>
<span class="line-added">5949     m_hasPlaybackTargetAvailabilityListeners = hasListeners;</span>
<span class="line-added">5950     m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(hasListeners);</span>
<span class="line-added">5951     scheduleUpdateMediaState();</span>
<span class="line-added">5952 }</span>
5953 #endif // ENABLE(WIRELESS_PLAYBACK_TARGET)
5954 
5955 bool HTMLMediaElement::webkitCurrentPlaybackTargetIsWireless() const
5956 {
5957     INFO_LOG(LOGIDENTIFIER, m_isPlayingToWirelessTarget);
5958     return m_isPlayingToWirelessTarget;
5959 }
5960 
5961 void HTMLMediaElement::setPlayingOnSecondScreen(bool value)
5962 {
5963     if (value == m_playingOnSecondScreen)
5964         return;
5965 
5966     m_playingOnSecondScreen = value;
5967 
5968 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5969     scheduleUpdateMediaState();
5970 #endif
5971 }
5972 
</pre>
<hr />
<pre>
5996 bool HTMLMediaElement::isStandardFullscreen() const
5997 {
5998 #if ENABLE(FULLSCREEN_API)
5999     if (document().fullscreenManager().isFullscreen() &amp;&amp; document().fullscreenManager().currentFullscreenElement() == this)
6000         return true;
6001 #endif
6002 
6003     return m_videoFullscreenMode == VideoFullscreenModeStandard;
6004 }
6005 
6006 void HTMLMediaElement::toggleStandardFullscreenState()
6007 {
6008     if (isStandardFullscreen())
6009         exitFullscreen();
6010     else
6011         enterFullscreen();
6012 }
6013 
6014 void HTMLMediaElement::enterFullscreen(VideoFullscreenMode mode)
6015 {
<span class="line-modified">6016     INFO_LOG(LOGIDENTIFIER, &quot;, m_videoFullscreenMode = &quot;, m_videoFullscreenMode, &quot;, mode = &quot;, mode);</span>
6017     ASSERT(mode != VideoFullscreenModeNone);
6018 
6019     if (m_videoFullscreenMode == mode)
6020         return;
6021 
6022     m_temporarilyAllowingInlinePlaybackAfterFullscreen = false;
6023     m_waitingToEnterFullscreen = true;
6024 
6025 #if ENABLE(FULLSCREEN_API) &amp;&amp; ENABLE(VIDEO_USES_ELEMENT_FULLSCREEN)
6026     if (document().settings().fullScreenEnabled() &amp;&amp; mode == VideoFullscreenModeStandard) {
6027         document().fullscreenManager().requestFullscreenForElement(this, FullscreenManager::ExemptIFrameAllowFullscreenRequirement);
6028         return;
6029     }
6030 #endif
6031 
6032     m_fullscreenTaskQueue.enqueueTask([this, mode] {
6033         if (document().hidden()) {
6034             ALWAYS_LOG(LOGIDENTIFIER, &quot;  returning because document is hidden&quot;);
6035             return;
6036         }
6037 
6038         fullscreenModeChanged(mode);
6039         configureMediaControls();
6040         if (hasMediaControls())
6041             mediaControls()-&gt;enteredFullscreen();
6042         if (is&lt;HTMLVideoElement&gt;(*this)) {
6043             HTMLVideoElement&amp; asVideo = downcast&lt;HTMLVideoElement&gt;(*this);
6044             if (document().page()-&gt;chrome().client().supportsVideoFullscreen(m_videoFullscreenMode)) {
<span class="line-added">6045                 INFO_LOG(LOGIDENTIFIER, &quot;Entering fullscreen mode &quot;, m_videoFullscreenMode, &quot;, m_videoFullscreenStandby = &quot;, m_videoFullscreenStandby);</span>
6046                 document().page()-&gt;chrome().client().enterVideoFullscreenForVideoElement(asVideo, m_videoFullscreenMode, m_videoFullscreenStandby);
6047                 scheduleEvent(eventNames().webkitbeginfullscreenEvent);
6048             }
6049         }
6050     });
6051 }
6052 
6053 void HTMLMediaElement::enterFullscreen()
6054 {
6055     enterFullscreen(VideoFullscreenModeStandard);
6056 }
6057 
6058 void HTMLMediaElement::exitFullscreen()
6059 {
6060     INFO_LOG(LOGIDENTIFIER);
6061 
6062     m_waitingToEnterFullscreen = false;
6063 
6064 #if ENABLE(FULLSCREEN_API)
6065     if (document().settings().fullScreenEnabled() &amp;&amp; document().fullscreenManager().currentFullscreenElement() == this) {
</pre>
<hr />
<pre>
6144 
6145 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
6146     switch (oldVideoFullscreenMode) {
6147     case VideoFullscreenModeNone:
6148     case VideoFullscreenModeStandard:
6149         // Don&#39;t need to do anything if we are not in any special fullscreen mode or it&#39;s already
6150         // in standard fullscreen mode.
6151         break;
6152     case VideoFullscreenModePictureInPicture:
6153         if (is&lt;HTMLVideoElement&gt;(*this))
6154             downcast&lt;HTMLVideoElement&gt;(this)-&gt;exitToFullscreenModeWithoutAnimationIfPossible(oldVideoFullscreenMode, VideoFullscreenModeStandard);
6155         break;
6156     }
6157 #endif
6158 
6159     Element::willBecomeFullscreenElement();
6160 }
6161 
6162 void HTMLMediaElement::didBecomeFullscreenElement()
6163 {
<span class="line-added">6164     INFO_LOG(LOGIDENTIFIER, &quot;, fullscreen mode = &quot;, fullscreenMode());</span>
6165     m_waitingToEnterFullscreen = false;
6166     if (hasMediaControls())
6167         mediaControls()-&gt;enteredFullscreen();
6168     scheduleUpdatePlayState();
6169 }
6170 
6171 void HTMLMediaElement::willStopBeingFullscreenElement()
6172 {
6173     if (hasMediaControls())
6174         mediaControls()-&gt;exitedFullscreen();
6175 
6176     if (fullscreenMode() == VideoFullscreenModeStandard)
6177         fullscreenModeChanged(VideoFullscreenModeNone);
6178 }
6179 
6180 PlatformLayer* HTMLMediaElement::platformLayer() const
6181 {
6182     return m_player ? m_player-&gt;platformLayer() : nullptr;
6183 }
6184 
6185 void HTMLMediaElement::setPreparedToReturnVideoLayerToInline(bool value)
6186 {
6187     m_preparedForInline = value;
6188     if (m_preparedForInline &amp;&amp; m_preparedForInlineCompletionHandler) {
6189         m_preparedForInlineCompletionHandler();
6190         m_preparedForInlineCompletionHandler = nullptr;
6191     }
6192 }
6193 
6194 void HTMLMediaElement::waitForPreparedForInlineThen(WTF::Function&lt;void()&gt;&amp;&amp; completionHandler)
6195 {
<span class="line-added">6196     INFO_LOG(LOGIDENTIFIER);</span>
6197     ASSERT(!m_preparedForInlineCompletionHandler);
6198     if (m_preparedForInline)  {
6199         completionHandler();
6200         return;
6201     }
6202 
6203     m_preparedForInlineCompletionHandler = WTFMove(completionHandler);
6204 }
6205 
6206 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
6207 
6208 void HTMLMediaElement::willExitFullscreen()
6209 {
6210     if (m_player)
6211         m_player-&gt;updateVideoFullscreenInlineImage();
6212 }
6213 
6214 bool HTMLMediaElement::isVideoLayerInline()
6215 {
6216     return !m_videoFullscreenLayer;
6217 };
6218 
6219 void HTMLMediaElement::setVideoFullscreenLayer(PlatformLayer* platformLayer, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler)
6220 {
<span class="line-added">6221     INFO_LOG(LOGIDENTIFIER);</span>
6222     m_videoFullscreenLayer = platformLayer;
6223     if (!m_player) {
6224         completionHandler();
6225         return;
6226     }
6227 
6228     m_player-&gt;setVideoFullscreenLayer(platformLayer, WTFMove(completionHandler));
6229     invalidateStyleAndLayerComposition();
6230 #if ENABLE(VIDEO_TRACK)
6231     updateTextTrackDisplay();
6232 #endif
6233 }
6234 
6235 void HTMLMediaElement::setVideoFullscreenFrame(FloatRect frame)
6236 {
6237     m_videoFullscreenFrame = frame;
6238     if (m_player)
6239         m_player-&gt;setVideoFullscreenFrame(frame);
6240 }
6241 
</pre>
<hr />
<pre>
6408     return MediaPlayer::originsInMediaCache(path);
6409 }
6410 
6411 void HTMLMediaElement::clearMediaCache(const String&amp; path, WallTime modifiedSince)
6412 {
6413     MediaPlayer::clearMediaCache(path, modifiedSince);
6414 }
6415 
6416 void HTMLMediaElement::clearMediaCacheForOrigins(const String&amp; path, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp; origins)
6417 {
6418     MediaPlayer::clearMediaCacheForOrigins(path, origins);
6419 }
6420 
6421 void HTMLMediaElement::resetMediaEngines()
6422 {
6423     MediaPlayer::resetMediaEngines();
6424 }
6425 
6426 void HTMLMediaElement::privateBrowsingStateDidChange(PAL::SessionID sessionID)
6427 {
<span class="line-added">6428     // FIXME: We should try to reconcile this so there&#39;s no difference for PLATFORM(IOS_FAMILY).</span>
<span class="line-added">6429 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">6430     UNUSED_PARAM(sessionID);</span>
<span class="line-added">6431 #else</span>
6432     if (!m_player)
6433         return;
6434 
6435     m_player-&gt;setPrivateBrowsingMode(sessionID.isEphemeral());
<span class="line-added">6436 #endif</span>
6437 }
6438 
6439 MediaControls* HTMLMediaElement::mediaControls() const
6440 {
6441 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6442     return nullptr;
6443 #else
6444     auto root = userAgentShadowRoot();
6445     if (!root)
6446         return nullptr;
6447 
6448     return childrenOfType&lt;MediaControls&gt;(*root).first();
6449 #endif
6450 }
6451 
6452 bool HTMLMediaElement::hasMediaControls() const
6453 {
6454 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6455     return false;
6456 #else
</pre>
<hr />
<pre>
6553     for (unsigned i = 0; i &lt; m_textTracks-&gt;length(); ++i) {
6554         if (m_textTracks-&gt;item(i)-&gt;mode() == TextTrack::Mode::Showing) {
6555             haveVisibleTextTrack = true;
6556             break;
6557         }
6558     }
6559 
6560     if (checkType == CheckTextTrackVisibility &amp;&amp; m_haveVisibleTextTrack == haveVisibleTextTrack) {
6561         updateActiveTextTrackCues(currentMediaTime());
6562         return;
6563     }
6564 
6565     m_haveVisibleTextTrack = haveVisibleTextTrack;
6566     m_closedCaptionsVisible = m_haveVisibleTextTrack;
6567 
6568 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6569     if (!m_haveVisibleTextTrack)
6570         return;
6571 
6572     ensureMediaControlsShadowRoot();
<span class="line-added">6573     updateTextTrackDisplay();</span>
6574 #else
6575     if (!m_haveVisibleTextTrack &amp;&amp; !hasMediaControls())
6576         return;
6577     if (!hasMediaControls() &amp;&amp; !createMediaControls())
6578         return;
6579 
6580     mediaControls()-&gt;changedClosedCaptionsVisibility();
6581 
6582     updateTextTrackDisplay();
6583     updateActiveTextTrackCues(currentMediaTime());
6584 #endif
6585 }
6586 
6587 void HTMLMediaElement::captionPreferencesChanged()
6588 {
6589     if (!isVideo())
6590         return;
6591 
6592     if (hasMediaControls())
6593         mediaControls()-&gt;textTrackPreferencesChanged();
6594 
6595 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6596     if (m_mediaControlsHost)
<span class="line-modified">6597         m_mediaControlsHost-&gt;updateCaptionDisplaySizes(MediaControlsHost::ForceUpdate::Yes);</span>
6598 #endif
6599 
6600     if (m_player)
6601         m_player-&gt;tracksChanged();
6602 
6603     if (!document().page())
6604         return;
6605 
6606     CaptionUserPreferences::CaptionDisplayMode displayMode = document().page()-&gt;group().captionPreferences().captionDisplayMode();
6607     if (captionDisplayMode() == displayMode)
6608         return;
6609 
6610     m_captionDisplayMode = displayMode;
6611     setWebkitClosedCaptionsVisible(captionDisplayMode() == CaptionUserPreferences::AlwaysOn);
6612 }
6613 
6614 CaptionUserPreferences::CaptionDisplayMode HTMLMediaElement::captionDisplayMode()
6615 {
6616     if (!m_captionDisplayMode.hasValue()) {
6617         if (document().page())
</pre>
<hr />
<pre>
6674 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
6675     if (m_isPlayingToWirelessTarget)
6676         setIsPlayingToWirelessTarget(false);
6677 #endif
6678 
6679     m_player = MediaPlayer::create(*this);
6680     m_player-&gt;setBufferingPolicy(m_bufferingPolicy);
6681     schedulePlaybackControlsManagerUpdate();
6682 
6683 #if ENABLE(WEB_AUDIO)
6684     if (m_audioSourceNode) {
6685         // When creating the player, make sure its AudioSourceProvider knows about the MediaElementAudioSourceNode.
6686         if (audioSourceProvider())
6687             audioSourceProvider()-&gt;setClient(m_audioSourceNode);
6688 
6689         m_audioSourceNode-&gt;unlock();
6690     }
6691 #endif
6692 
6693 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified">6694     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent) || m_remote-&gt;hasAvailabilityCallbacks()) {</span>
6695         m_hasPlaybackTargetAvailabilityListeners = true;
6696         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(true);
6697         enqueuePlaybackTargetAvailabilityChangedEvent(); // Ensure the event listener gets at least one event.
6698     }
6699 #endif
6700 
6701     updateSleepDisabling();
6702 }
6703 
6704 #if ENABLE(WEB_AUDIO)
<span class="line-added">6705 </span>
6706 void HTMLMediaElement::setAudioSourceNode(MediaElementAudioSourceNode* sourceNode)
6707 {
6708     m_audioSourceNode = sourceNode;
6709 
6710     if (audioSourceProvider())
6711         audioSourceProvider()-&gt;setClient(m_audioSourceNode);
6712 }
6713 
6714 AudioSourceProvider* HTMLMediaElement::audioSourceProvider()
6715 {
6716     if (m_player)
6717         return m_player-&gt;audioSourceProvider();
6718 
<span class="line-modified">6719     return nullptr;</span>
6720 }
<span class="line-added">6721 </span>
6722 #endif
6723 
6724 const String&amp; HTMLMediaElement::mediaGroup() const
6725 {
6726     return m_mediaGroup;
6727 }
6728 
6729 void HTMLMediaElement::setMediaGroup(const String&amp; group)
6730 {
6731     if (m_mediaGroup == group)
6732         return;
6733     m_mediaGroup = group;
6734 
6735     // When a media element is created with a mediagroup attribute, and when a media element&#39;s mediagroup
6736     // attribute is set, changed, or removed, the user agent must run the following steps:
6737     // 1. Let m [this] be the media element in question.
6738     // 2. Let m have no current media controller, if it currently has one.
6739     setController(nullptr);
6740 
6741     // 3. If m&#39;s mediagroup attribute is being removed, then abort these steps.
6742     if (group.isEmpty())
6743         return;
6744 
6745     // 4. If there is another media element whose Document is the same as m&#39;s Document (even if one or both
6746     // of these elements are not actually in the Document),
<span class="line-modified">6747     // FIXME: It does not seem OK that this algorithm iterates the media elements in a random order.</span>
<span class="line-modified">6748     document().forEachMediaElement([&amp;] (HTMLMediaElement&amp; element) {</span>



6749         // and which also has a mediagroup attribute, and whose mediagroup attribute has the same value as
6750         // the new value of m&#39;s mediagroup attribute,
<span class="line-modified">6751         if (&amp;element != this &amp;&amp; !controller() &amp;&amp; element.mediaGroup() == group) {</span>
6752             //  then let controller be that media element&#39;s current media controller.
<span class="line-modified">6753             setController(element.controller());</span>

6754         }
<span class="line-modified">6755     });</span>
6756 
6757     // Otherwise, let controller be a newly created MediaController.
<span class="line-modified">6758     if (!controller())</span>
<span class="line-added">6759         setController(MediaController::create(document()));</span>
6760 }
6761 
6762 MediaController* HTMLMediaElement::controller() const
6763 {
6764     return m_mediaController.get();
6765 }
6766 
6767 void HTMLMediaElement::setController(RefPtr&lt;MediaController&gt;&amp;&amp; controller)
6768 {
6769     if (m_mediaController)
6770         m_mediaController-&gt;removeMediaElement(*this);
6771 
6772     m_mediaController = WTFMove(controller);
6773 
6774     if (m_mediaController)
6775         m_mediaController-&gt;addMediaElement(*this);
6776 
6777     if (hasMediaControls())
6778         mediaControls()-&gt;setMediaController(m_mediaController ? m_mediaController.get() : static_cast&lt;MediaControllerInterface*&gt;(this));
6779 }
</pre>
<hr />
<pre>
7025 bool HTMLMediaElement::mediaPlayerIsVideo() const
7026 {
7027     return isVideo();
7028 }
7029 
7030 LayoutRect HTMLMediaElement::mediaPlayerContentBoxRect() const
7031 {
7032     auto* renderer = this-&gt;renderer();
7033     if (!renderer)
7034         return { };
7035     return renderer-&gt;enclosingBox().contentBoxRect();
7036 }
7037 
7038 float HTMLMediaElement::mediaPlayerContentsScale() const
7039 {
7040     if (auto page = document().page())
7041         return page-&gt;pageScaleFactor() * page-&gt;deviceScaleFactor();
7042     return 1;
7043 }
7044 






7045 void HTMLMediaElement::mediaPlayerPause()
7046 {
7047     pause();
7048 }
7049 
7050 void HTMLMediaElement::mediaPlayerPlay()
7051 {
7052     play();
7053 }
7054 
7055 bool HTMLMediaElement::mediaPlayerPlatformVolumeConfigurationRequired() const
7056 {
7057     return !m_volumeInitialized;
7058 }
7059 





7060 bool HTMLMediaElement::mediaPlayerIsLooping() const
7061 {
7062     return loop();
7063 }
7064 
7065 CachedResourceLoader* HTMLMediaElement::mediaPlayerCachedResourceLoader()
7066 {
7067     return &amp;document().cachedResourceLoader();
7068 }
7069 
7070 RefPtr&lt;PlatformMediaResourceLoader&gt; HTMLMediaElement::mediaPlayerCreateResourceLoader()
7071 {
7072     auto mediaResourceLoader = adoptRef(*new MediaResourceLoader(document(), *this, crossOrigin()));
7073 
7074     m_lastMediaResourceLoaderForTesting = makeWeakPtr(mediaResourceLoader.get());
7075 
7076     return mediaResourceLoader;
7077 }
7078 
7079 const MediaResourceLoader* HTMLMediaElement::lastMediaResourceLoaderForTesting() const
7080 {
7081     return m_lastMediaResourceLoaderForTesting.get();
7082 }
7083 
7084 bool HTMLMediaElement::mediaPlayerShouldUsePersistentCache() const
7085 {
7086     if (Page* page = document().page())
<span class="line-modified">7087         return !page-&gt;usesEphemeralSession() &amp;&amp; !page-&gt;isResourceCachingDisabledByWebInspector();</span>
7088 
7089     return false;
7090 }
7091 
7092 const String&amp; HTMLMediaElement::mediaPlayerMediaCacheDirectory() const
7093 {
7094     return mediaCacheDirectory();
7095 }
7096 
7097 String HTMLMediaElement::sourceApplicationIdentifier() const
7098 {
7099     if (RefPtr&lt;Frame&gt; frame = document().frame()) {
7100         if (NetworkingContext* networkingContext = frame-&gt;loader().networkingContext())
7101             return networkingContext-&gt;sourceApplicationIdentifier();
7102     }
7103     return emptyString();
7104 }
7105 
7106 Vector&lt;String&gt; HTMLMediaElement::mediaPlayerPreferredAudioCharacteristics() const
7107 {
<span class="line-added">7108 #if ENABLE(VIDEO_TRACK)</span>
7109     if (Page* page = document().page())
7110         return page-&gt;group().captionPreferences().preferredAudioCharacteristics();
<span class="line-added">7111 #endif</span>
7112     return Vector&lt;String&gt;();
7113 }
7114 
7115 #if PLATFORM(IOS_FAMILY)
<span class="line-added">7116 </span>
7117 String HTMLMediaElement::mediaPlayerNetworkInterfaceName() const
7118 {
7119     return DeprecatedGlobalSettings::networkInterfaceName();
7120 }
7121 
7122 bool HTMLMediaElement::mediaPlayerGetRawCookies(const URL&amp; url, Vector&lt;Cookie&gt;&amp; cookies) const
7123 {
7124     if (auto* page = document().page())
7125         return page-&gt;cookieJar().getRawCookies(document(), url, cookies);
7126     return false;
7127 }

7128 
<span class="line-modified">7129 #endif</span>



7130 
7131 void HTMLMediaElement::mediaPlayerEngineFailedToLoad() const
7132 {
7133     if (!m_player)
7134         return;
7135 
7136     if (auto* page = document().page())
7137         page-&gt;diagnosticLoggingClient().logDiagnosticMessageWithValue(DiagnosticLoggingKeys::engineFailedToLoadKey(), m_player-&gt;engineDescription(), m_player-&gt;platformErrorCode(), 4, ShouldSample::No);
7138 }
7139 
7140 double HTMLMediaElement::mediaPlayerRequestedPlaybackRate() const
7141 {
7142     return potentiallyPlaying() ? requestedPlaybackRate() : 0;
7143 }
7144 
7145 const Vector&lt;ContentType&gt;&amp; HTMLMediaElement::mediaContentTypesRequiringHardwareSupport() const
7146 {
7147     return document().settings().mediaContentTypesRequiringHardwareSupport();
7148 }
7149 
</pre>
<hr />
<pre>
7214 {
7215     RefPtr&lt;DOMWindow&gt; domWindow = document().domWindow();
7216     double timestamp = domWindow ? 1000 * domWindow-&gt;nowTimestamp() : 0;
7217 
7218     auto metrics = m_player ? m_player-&gt;videoPlaybackQualityMetrics() : WTF::nullopt;
7219     if (!metrics)
7220         return VideoPlaybackQuality::create(timestamp, { });
7221 
7222 #if ENABLE(MEDIA_SOURCE)
7223     metrics.value().totalVideoFrames += m_droppedVideoFrames;
7224     metrics.value().droppedVideoFrames += m_droppedVideoFrames;
7225 #endif
7226 
7227     return VideoPlaybackQuality::create(timestamp, metrics.value());
7228 }
7229 
7230 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
7231 DOMWrapperWorld&amp; HTMLMediaElement::ensureIsolatedWorld()
7232 {
7233     if (!m_isolatedWorld)
<span class="line-modified">7234         m_isolatedWorld = DOMWrapperWorld::create(commonVM(), DOMWrapperWorld::Type::Internal, makeString(&quot;Media Controls (&quot;, localName(), &#39;)&#39;));</span>
7235     return *m_isolatedWorld;
7236 }
7237 
7238 bool HTMLMediaElement::ensureMediaControlsInjectedScript()
7239 {
7240     INFO_LOG(LOGIDENTIFIER);
7241 
7242     Page* page = document().page();
7243     if (!page)
7244         return false;
7245 
7246     String mediaControlsScript = RenderTheme::singleton().mediaControlsScript();
7247     if (!mediaControlsScript.length())
7248         return false;
7249 
<span class="line-modified">7250     return setupAndCallJS([mediaControlsScript](JSDOMGlobalObject&amp; globalObject, JSC::JSGlobalObject&amp; lexicalGlobalObject, ScriptController&amp; scriptController, DOMWrapperWorld&amp; world) {</span>
7251         auto&amp; vm = globalObject.vm();
7252         auto scope = DECLARE_CATCH_SCOPE(vm);
7253 
<span class="line-modified">7254         auto functionValue = globalObject.get(&amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, &quot;createControls&quot;));</span>
7255         if (functionValue.isFunction(vm))
7256             return true;
7257 
7258 #ifndef NDEBUG
7259         // Setting a scriptURL allows the source to be debuggable in the inspector.
7260         URL scriptURL = URL({ }, &quot;mediaControlsScript&quot;_s);
7261 #else
7262         URL scriptURL;
7263 #endif
<span class="line-modified">7264         scriptController.evaluateInWorldIgnoringException(ScriptSourceCode(mediaControlsScript, WTFMove(scriptURL)), world);</span>
7265         if (UNLIKELY(scope.exception())) {
7266             scope.clearException();
7267             return false;
7268         }
7269 
7270         return true;
7271     });
7272 }
7273 
7274 void HTMLMediaElement::updatePageScaleFactorJSProperty()
7275 {
7276     Page* page = document().page();
7277     if (!page)
7278         return;
7279 
7280     setControllerJSProperty(&quot;pageScaleFactor&quot;, JSC::jsNumber(page-&gt;pageScaleFactor()));
7281 }
7282 
7283 void HTMLMediaElement::updateUsesLTRUserInterfaceLayoutDirectionJSProperty()
7284 {
7285     Page* page = document().page();
7286     if (!page)
7287         return;
7288 
7289     bool usesLTRUserInterfaceLayoutDirectionProperty = page-&gt;userInterfaceLayoutDirection() == UserInterfaceLayoutDirection::LTR;
7290     setControllerJSProperty(&quot;usesLTRUserInterfaceLayoutDirection&quot;, JSC::jsBoolean(usesLTRUserInterfaceLayoutDirectionProperty));
7291 }
7292 
7293 void HTMLMediaElement::setControllerJSProperty(const char* propertyName, JSC::JSValue propertyValue)
7294 {
<span class="line-modified">7295     setupAndCallJS([this, propertyName, propertyValue](JSDOMGlobalObject&amp; globalObject, JSC::JSGlobalObject&amp; lexicalGlobalObject, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
7296         auto&amp; vm = globalObject.vm();
<span class="line-modified">7297         auto controllerValue = controllerJSValue(lexicalGlobalObject, globalObject, *this);</span>
7298         if (controllerValue.isNull())
7299             return false;
7300 
7301         JSC::PutPropertySlot propertySlot(controllerValue);
<span class="line-modified">7302         auto* controllerObject = controllerValue.toObject(&amp;lexicalGlobalObject);</span>
7303         if (!controllerObject)
7304             return false;
7305 
<span class="line-modified">7306         controllerObject-&gt;methodTable(vm)-&gt;put(controllerObject, &amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, propertyName), propertyValue, propertySlot);</span>
7307 
7308         return true;
7309     });
7310 }
7311 
7312 void HTMLMediaElement::didAddUserAgentShadowRoot(ShadowRoot&amp; root)
7313 {
7314     INFO_LOG(LOGIDENTIFIER);
7315 
7316     if (!ensureMediaControlsInjectedScript())
7317         return;
7318 
<span class="line-modified">7319     setupAndCallJS([this, &amp;root](JSDOMGlobalObject&amp; globalObject, JSC::JSGlobalObject&amp; lexicalGlobalObject, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
7320         auto&amp; vm = globalObject.vm();
7321         auto scope = DECLARE_CATCH_SCOPE(vm);
7322 
7323         // The media controls script must provide a method with the following details.
7324         // Name: createControls
7325         // Parameters:
7326         //     1. The ShadowRoot element that will hold the controls.
7327         //     2. This object (and HTMLMediaElement).
7328         //     3. The MediaControlsHost object.
7329         // Return value:
7330         //     A reference to the created media controller instance.
7331 
<span class="line-modified">7332         auto functionValue = globalObject.get(&amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, &quot;createControls&quot;));</span>
7333         if (functionValue.isUndefinedOrNull())
7334             return false;
7335 
7336         if (!m_mediaControlsHost)
7337             m_mediaControlsHost = MediaControlsHost::create(this);
7338 
<span class="line-modified">7339         auto mediaJSWrapper = toJS(&amp;lexicalGlobalObject, &amp;globalObject, *this);</span>
<span class="line-modified">7340         auto mediaControlsHostJSWrapper = toJS(&amp;lexicalGlobalObject, &amp;globalObject, *m_mediaControlsHost);</span>
7341 
7342         JSC::MarkedArgumentBuffer argList;
<span class="line-modified">7343         argList.append(toJS(&amp;lexicalGlobalObject, &amp;globalObject, root));</span>
7344         argList.append(mediaJSWrapper);
7345         argList.append(mediaControlsHostJSWrapper);
7346         ASSERT(!argList.hasOverflowed());
7347 
<span class="line-modified">7348         auto* function = functionValue.toObject(&amp;lexicalGlobalObject);</span>
7349         scope.assertNoException();
7350         JSC::CallData callData;
7351         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7352         if (callType == JSC::CallType::None)
7353             return false;
7354 
<span class="line-modified">7355         auto controllerValue = JSC::call(&amp;lexicalGlobalObject, function, callType, callData, &amp;globalObject, argList);</span>
7356         scope.clearException();
7357         auto* controllerObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controllerValue);
7358         if (!controllerObject)
7359             return false;
7360 
7361         // Connect the Media, MediaControllerHost, and Controller so the GC knows about their relationship
<span class="line-modified">7362         auto* mediaJSWrapperObject = mediaJSWrapper.toObject(&amp;lexicalGlobalObject);</span>
7363         scope.assertNoException();
7364         auto controlsHost = JSC::Identifier::fromString(vm, &quot;controlsHost&quot;);
7365 
<span class="line-modified">7366         ASSERT(!mediaJSWrapperObject-&gt;hasProperty(&amp;lexicalGlobalObject, controlsHost));</span>
7367 
7368         mediaJSWrapperObject-&gt;putDirect(vm, controlsHost, mediaControlsHostJSWrapper, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);
7369 
7370         auto* mediaControlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaControlsHostJSWrapper);
7371         if (!mediaControlsHostJSWrapperObject)
7372             return false;
7373 
7374         auto controller = JSC::Identifier::fromString(vm, &quot;controller&quot;);
7375 
<span class="line-modified">7376         ASSERT(!controllerObject-&gt;hasProperty(&amp;lexicalGlobalObject, controller));</span>
7377 
7378         mediaControlsHostJSWrapperObject-&gt;putDirect(vm, controller, controllerValue, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);
7379 
7380         updatePageScaleFactorJSProperty();
7381         updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
7382 
7383         if (UNLIKELY(scope.exception()))
7384             scope.clearException();
7385 
7386         return true;
7387     });
7388 }
7389 
7390 void HTMLMediaElement::setMediaControlsDependOnPageScaleFactor(bool dependsOnPageScale)
7391 {
7392     INFO_LOG(LOGIDENTIFIER, dependsOnPageScale);
7393 
7394     if (document().settings().mediaControlsScaleWithPageZoom()) {
7395         INFO_LOG(LOGIDENTIFIER, &quot;forced to false by Settings value&quot;);
7396         m_mediaControlsDependOnPageScaleFactor = false;
7397         return;
7398     }
7399 



7400     m_mediaControlsDependOnPageScaleFactor = dependsOnPageScale;





7401 }
7402 
7403 void HTMLMediaElement::updateMediaControlsAfterPresentationModeChange()
7404 {
7405     // Don&#39;t execute script if the controls script hasn&#39;t been injected yet, or we have
7406     // stopped/suspended the object.
7407     if (!m_mediaControlsHost || document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped())
7408         return;
7409 
7410     if (RuntimeEnabledFeatures::sharedFeatures().modernMediaControlsEnabled())
7411         return;
7412 
<span class="line-modified">7413     setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::JSGlobalObject&amp; lexicalGlobalObject, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
7414         auto&amp; vm = globalObject.vm();
7415         auto scope = DECLARE_THROW_SCOPE(vm);
7416 
<span class="line-modified">7417         auto controllerValue = controllerJSValue(lexicalGlobalObject, globalObject, *this);</span>
<span class="line-modified">7418         auto* controllerObject = controllerValue.toObject(&amp;lexicalGlobalObject);</span>
7419 
7420         RETURN_IF_EXCEPTION(scope, false);
7421 
<span class="line-modified">7422         auto functionValue = controllerObject-&gt;get(&amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, &quot;handlePresentationModeChange&quot;));</span>
7423         if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
7424             return false;
7425 
<span class="line-modified">7426         auto* function = functionValue.toObject(&amp;lexicalGlobalObject);</span>
7427         scope.assertNoException();
7428         JSC::CallData callData;
7429         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7430         if (callType == JSC::CallType::None)
7431             return false;
7432 
7433         JSC::MarkedArgumentBuffer argList;
7434         ASSERT(!argList.hasOverflowed());
<span class="line-modified">7435         JSC::call(&amp;lexicalGlobalObject, function, callType, callData, controllerObject, argList);</span>
7436 
7437         return true;
7438     });
7439 }
7440 
7441 void HTMLMediaElement::pageScaleFactorChanged()
7442 {
<span class="line-modified">7443     if (m_mediaControlsDependOnPageScaleFactor)</span>
<span class="line-added">7444         updatePageScaleFactorJSProperty();</span>
7445 }
7446 
7447 void HTMLMediaElement::userInterfaceLayoutDirectionChanged()
7448 {
7449     updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
7450 }
7451 
7452 String HTMLMediaElement::getCurrentMediaControlsStatus()
7453 {
7454     ensureMediaControlsShadowRoot();
7455 
7456     String status;
<span class="line-modified">7457     setupAndCallJS([this, &amp;status](JSDOMGlobalObject&amp; globalObject, JSC::JSGlobalObject&amp; lexicalGlobalObject, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
7458         auto&amp; vm = globalObject.vm();
7459         auto scope = DECLARE_THROW_SCOPE(vm);
7460 
<span class="line-modified">7461         auto controllerValue = controllerJSValue(lexicalGlobalObject, globalObject, *this);</span>
<span class="line-modified">7462         auto* controllerObject = controllerValue.toObject(&amp;lexicalGlobalObject);</span>
7463 
7464         RETURN_IF_EXCEPTION(scope, false);
7465 
<span class="line-modified">7466         auto functionValue = controllerObject-&gt;get(&amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, &quot;getCurrentControlsStatus&quot;));</span>
7467         if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
7468             return false;
7469 
<span class="line-modified">7470         auto* function = functionValue.toObject(&amp;lexicalGlobalObject);</span>
7471         scope.assertNoException();
7472         JSC::CallData callData;
7473         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7474         JSC::MarkedArgumentBuffer argList;
7475         ASSERT(!argList.hasOverflowed());
7476         if (callType == JSC::CallType::None)
7477             return false;
7478 
<span class="line-modified">7479         auto outputValue = JSC::call(&amp;lexicalGlobalObject, function, callType, callData, controllerObject, argList);</span>
7480 
7481         RETURN_IF_EXCEPTION(scope, false);
7482 
<span class="line-modified">7483         status = outputValue.getString(&amp;lexicalGlobalObject);</span>
7484         return true;
7485     });
7486 
7487     return status;
7488 }
7489 #endif // ENABLE(MEDIA_CONTROLS_SCRIPT)
7490 
7491 unsigned long long HTMLMediaElement::fileSize() const
7492 {
7493     if (m_player)
7494         return m_player-&gt;fileSize();
7495 
7496     return 0;
7497 }
7498 
7499 PlatformMediaSession::MediaType HTMLMediaElement::mediaType() const
7500 {
7501     if (m_player &amp;&amp; m_readyState &gt;= HAVE_METADATA) {
7502         if (hasVideo() &amp;&amp; hasAudio() &amp;&amp; !muted())
7503             return PlatformMediaSession::VideoAudio;
</pre>
<hr />
<pre>
7537     if (isVideo() &amp;&amp; hasVideo())
7538         state |= PlatformMediaSession::HasVideo;
7539     if (this-&gt;hasAudio())
7540         state |= PlatformMediaSession::HasAudio;
7541 
7542     return state;
7543 }
7544 
7545 bool HTMLMediaElement::canProduceAudio() const
7546 {
7547 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7548     // Because the remote target could unmute playback without notifying us, we must assume
7549     // that we may be playing audio.
7550     if (m_isPlayingToWirelessTarget)
7551         return true;
7552 #endif
7553 
7554     if (muted())
7555         return false;
7556 
<span class="line-modified">7557     if (m_player &amp;&amp; m_readyState &gt;= HAVE_METADATA)</span>
<span class="line-added">7558         return hasAudio();</span>
<span class="line-added">7559 </span>
<span class="line-added">7560     return hasEverHadAudio();</span>
7561 }
7562 
7563 bool HTMLMediaElement::isSuspended() const
7564 {
7565     return document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped();
7566 }
7567 
7568 #if ENABLE(MEDIA_SOURCE)
7569 size_t HTMLMediaElement::maximumSourceBufferSize(const SourceBuffer&amp; buffer) const
7570 {
7571     return m_mediaSession-&gt;maximumMediaSourceBufferSize(buffer);
7572 }
7573 #endif
7574 
7575 void HTMLMediaElement::suspendPlayback()
7576 {
7577     INFO_LOG(LOGIDENTIFIER, &quot;paused = &quot;, paused());
7578     if (!paused())
7579         pause();
7580 }
</pre>
<hr />
<pre>
7592 {
7593     INFO_LOG(LOGIDENTIFIER, &quot;paused = &quot;, paused());
7594     if (paused() &amp;&amp; shouldResume)
7595         play();
7596 }
7597 
7598 String HTMLMediaElement::mediaSessionTitle() const
7599 {
7600     if (!document().page() || document().page()-&gt;usesEphemeralSession())
7601         return emptyString();
7602 
7603     auto title = String(attributeWithoutSynchronization(titleAttr)).stripWhiteSpace().simplifyWhiteSpace();
7604     if (!title.isEmpty())
7605         return title;
7606 
7607     title = document().title().stripWhiteSpace().simplifyWhiteSpace();
7608     if (!title.isEmpty())
7609         return title;
7610 
7611     title = m_currentSrc.host().toString();
<span class="line-modified">7612 #if PLATFORM(COCOA)</span>
7613     if (!title.isEmpty())
7614         title = decodeHostName(title);
7615 #endif
7616     if (!title.isEmpty()) {
7617         auto domain = RegistrableDomain { m_currentSrc };
7618         if (!domain.isEmpty())
7619             title = domain.string();
7620     }
7621 
7622     return title;
7623 }
7624 
7625 uint64_t HTMLMediaElement::mediaSessionUniqueIdentifier() const
7626 {
7627     auto&amp; url = m_currentSrc.string();
7628     return url.impl() ? url.impl()-&gt;hash() : 0;
7629 }
7630 
7631 void HTMLMediaElement::didReceiveRemoteControlCommand(PlatformMediaSession::RemoteControlCommandType command, const PlatformMediaSession::RemoteCommandArgument* argument)
7632 {
</pre>
<hr />
<pre>
7892     if (!MemoryPressureHandler::singleton().isUnderMemoryPressure() &amp;&amp; m_mediaSession-&gt;preferredBufferingPolicy() == BufferingPolicy::Default)
7893         return;
7894 
7895     if (isPlayingToExternalTarget()) {
7896         INFO_LOG(LOGIDENTIFIER, &quot;early return because playing to wireless target&quot;);
7897         return;
7898     }
7899 
7900     setBufferingPolicy(BufferingPolicy::PurgeResources);
7901 }
7902 
7903 bool HTMLMediaElement::canSaveMediaData() const
7904 {
7905     if (m_player)
7906         return m_player-&gt;canSaveMediaData();
7907 
7908     return false;
7909 }
7910 
7911 #if ENABLE(MEDIA_SESSION)
<span class="line-added">7912 </span>
7913 double HTMLMediaElement::playerVolume() const
7914 {
7915     return m_player ? m_player-&gt;volume() : 0;
7916 }
7917 
7918 MediaSession* HTMLMediaElement::session() const
7919 {
7920     RefPtr&lt;MediaSession&gt; session = m_session.get();
7921     if (session &amp;&amp; session == &amp;document().defaultMediaSession())
7922         return nullptr;
7923 
7924     return session.get();
7925 }
7926 
7927 void HTMLMediaElement::setSession(MediaSession* session)
7928 {
7929     // 6.1. Extensions to the HTMLMediaElement interface
7930     // 1. Let m be the media element in question.
7931     // 2. Let old media session be m’s current media session, if it has one, and null otherwise.
7932     // 3. Let m’s current media session be the new value or the top-level browsing context’s media session if the new value is null.
</pre>
<hr />
<pre>
8117         return;
8118 
8119     m_inActiveDocument = inActiveDocument;
8120     m_mediaSession-&gt;inActiveDocumentChanged();
8121 }
8122 
8123 HTMLMediaElementEnums::BufferingPolicy HTMLMediaElement::bufferingPolicy() const
8124 {
8125     return m_bufferingPolicy;
8126 }
8127 
8128 bool HTMLMediaElement::hasMediaStreamSource() const
8129 {
8130 #if ENABLE(MEDIA_STREAM)
8131     return hasMediaStreamSrcObject();
8132 #else
8133     return false;
8134 #endif
8135 }
8136 
<span class="line-added">8137 #if ENABLE(MEDIA_STREAM)</span>
<span class="line-added">8138 void HTMLMediaElement::mediaStreamCaptureStarted()</span>
<span class="line-added">8139 {</span>
<span class="line-added">8140     if (canTransitionFromAutoplayToPlay())</span>
<span class="line-added">8141         play();</span>
<span class="line-added">8142 }</span>
<span class="line-added">8143 #endif</span>
<span class="line-added">8144 </span>
<span class="line-added">8145 void HTMLMediaElement::enqueueTaskForDispatcher(Function&lt;void()&gt;&amp;&amp; function)</span>
<span class="line-added">8146 {</span>
<span class="line-added">8147     if (!isMainThread()) {</span>
<span class="line-added">8148         callOnMainThread([this, weakThis = makeWeakPtr(*this), function = WTFMove(function)]() mutable {</span>
<span class="line-added">8149             if (!weakThis)</span>
<span class="line-added">8150                 return;</span>
<span class="line-added">8151             enqueueTaskForDispatcher(WTFMove(function));</span>
<span class="line-added">8152         });</span>
<span class="line-added">8153         return;</span>
<span class="line-added">8154     }</span>
<span class="line-added">8155 </span>
<span class="line-added">8156     if (!scriptExecutionContext())</span>
<span class="line-added">8157         return;</span>
<span class="line-added">8158     scriptExecutionContext()-&gt;eventLoop().queueTask(TaskSource::MediaElement, WTFMove(function));</span>
<span class="line-added">8159 }</span>
<span class="line-added">8160 </span>
8161 }
8162 
8163 #endif
</pre>
</td>
</tr>
</table>
<center><a href="HTMLMarqueeElement.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLMediaElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
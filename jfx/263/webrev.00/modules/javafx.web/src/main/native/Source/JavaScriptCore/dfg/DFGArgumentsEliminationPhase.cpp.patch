diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArgumentsEliminationPhase.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArgumentsEliminationPhase.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArgumentsEliminationPhase.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArgumentsEliminationPhase.cpp
@@ -50,11 +50,11 @@
 namespace JSC { namespace DFG {
 
 namespace {
 
 namespace DFGArgumentsEliminationPhaseInternal {
-static const bool verbose = false;
+static constexpr bool verbose = false;
 }
 
 class ArgumentsEliminationPhase : public Phase {
 public:
     ArgumentsEliminationPhase(Graph& graph)
@@ -356,13 +356,16 @@
                 }
 
                 case NewArrayBuffer:
                     break;
 
+                case VarargsLength:
+                    break;
+
                 case LoadVarargs:
-                    if (node->loadVarargsData()->offset && (node->child1()->op() == NewArrayWithSpread || node->child1()->op() == Spread || node->child1()->op() == NewArrayBuffer))
-                        escape(node->child1(), node);
+                    if (node->loadVarargsData()->offset && (node->argumentsChild()->op() == NewArrayWithSpread || node->argumentsChild()->op() == Spread || node->argumentsChild()->op() == NewArrayBuffer))
+                        escape(node->argumentsChild(), node);
                     break;
 
                 case CallVarargs:
                 case ConstructVarargs:
                 case TailCallVarargs:
@@ -398,16 +401,17 @@
                     // that we exempt here also use the candidate directly. If there ever was a
                     // butterfly-using op that we wanted to exempt, then we'd have to look at the
                     // butterfly's child and check if it's a candidate.
                     break;
 
-                case FilterGetByIdStatus:
+                case FilterGetByStatus:
                 case FilterPutByIdStatus:
                 case FilterCallLinkStatus:
                 case FilterInByIdStatus:
                     break;
 
+                case CheckArrayOrEmpty:
                 case CheckArray:
                     escapeBasedOnArrayMode(node->arrayMode(), node->child1(), node);
                     break;
 
                 case CheckStructureOrEmpty:
@@ -491,14 +495,14 @@
                         if (heap.kind() != Stack) {
                             ASSERT(!heap.overlaps(Stack));
                             return;
                         }
                         ASSERT(!heap.payload().isTop());
-                        VirtualRegister reg(heap.payload().value32());
+                        Operand operand = heap.operand();
                         // The register may not point to an argument or local, for example if we are looking at SetArgumentCountIncludingThis.
-                        if (!reg.isHeader())
-                            clobberedByThisBlock.operand(reg) = true;
+                        if (!operand.isHeader())
+                            clobberedByThisBlock.operand(operand) = true;
                     },
                     NoOpClobberize());
             }
         }
 
@@ -558,20 +562,20 @@
                         Operands<bool>& clobberedByThisBlock = clobberedByBlock[block];
 
                         if (inlineCallFrame) {
                             if (inlineCallFrame->isVarargs()) {
                                 isClobberedByBlock |= clobberedByThisBlock.operand(
-                                    inlineCallFrame->stackOffset + CallFrameSlot::argumentCount);
+                                    VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::argumentCountIncludingThis));
                             }
 
                             if (!isClobberedByBlock || inlineCallFrame->isClosureCall) {
                                 isClobberedByBlock |= clobberedByThisBlock.operand(
-                                    inlineCallFrame->stackOffset + CallFrameSlot::callee);
+                                    VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::callee));
                             }
 
                             if (!isClobberedByBlock) {
-                                for (unsigned i = 0; i < inlineCallFrame->argumentCountIncludingThis - 1; ++i) {
+                                for (unsigned i = 0; i < static_cast<unsigned>(inlineCallFrame->argumentCountIncludingThis - 1); ++i) {
                                     VirtualRegister reg =
                                         VirtualRegister(inlineCallFrame->stackOffset) +
                                         CallFrame::argumentOffset(i);
                                     if (clobberedByThisBlock.operand(reg)) {
                                         isClobberedByBlock = true;
@@ -625,11 +629,11 @@
                             bool found = false;
                             clobberize(
                                 m_graph, node, NoOpClobberize(),
                                 [&] (AbstractHeap heap) {
                                     if (heap.kind() == Stack && !heap.payload().isTop()) {
-                                        if (argumentsInvolveStackSlot(inlineCallFrame, VirtualRegister(heap.payload().value32())))
+                                        if (argumentsInvolveStackSlot(inlineCallFrame, heap.operand()))
                                             found = true;
                                         return;
                                     }
                                     if (heap.overlaps(Stack))
                                         found = true;
@@ -750,11 +754,11 @@
                         break;
 
                     DFG_ASSERT(
                         m_graph, node, node->child1()->op() == PhantomDirectArguments, node->child1()->op());
                     VirtualRegister reg =
-                        virtualRegisterForArgument(node->capturedArgumentsOffset().offset() + 1) +
+                        virtualRegisterForArgumentIncludingThis(node->capturedArgumentsOffset().offset() + 1) +
                         node->origin.semantic.stackOffset();
                     StackAccessData* data = m_graph.m_stackAccessData.add(reg, FlushedJSValue);
                     node->convertToGetStack(data);
                     break;
                 }
@@ -804,18 +808,18 @@
                         InlineCallFrame* inlineCallFrame = candidate->origin.semantic.inlineCallFrame();
                         index += numberOfArgumentsToSkip;
 
                         bool safeToGetStack = index >= numberOfArgumentsToSkip;
                         if (inlineCallFrame)
-                            safeToGetStack &= index < inlineCallFrame->argumentCountIncludingThis - 1;
+                            safeToGetStack &= index < static_cast<unsigned>(inlineCallFrame->argumentCountIncludingThis - 1);
                         else {
                             safeToGetStack &=
                                 index < static_cast<unsigned>(codeBlock()->numParameters()) - 1;
                         }
                         if (safeToGetStack) {
                             StackAccessData* data;
-                            VirtualRegister arg = virtualRegisterForArgument(index + 1);
+                            VirtualRegister arg = virtualRegisterForArgumentIncludingThis(index + 1);
                             if (inlineCallFrame)
                                 arg += inlineCallFrame->stackOffset;
                             data = m_graph.m_stackAccessData.add(arg, FlushedJSValue);
 
                             Node* check = nullptr;
@@ -844,12 +848,26 @@
                     // Need to do this because we may have a data format conversion here.
                     node->convertToIdentityOn(result);
                     break;
                 }
 
+                case VarargsLength: {
+                    Node* candidate = node->argumentsChild().node();
+                    if (!isEliminatedAllocation(candidate))
+                        break;
+
+                    // VarargsLength can exit, so it better be exitOK.
+                    DFG_ASSERT(m_graph, node, node->origin.exitOK);
+                    NodeOrigin origin = node->origin.withExitOK(true);
+
+
+                    node->convertToIdentityOn(emitCodeToGetArgumentsArrayLength(insertionSet, candidate, nodeIndex, origin, /* addThis = */ true));
+                    break;
+                }
+
                 case LoadVarargs: {
-                    Node* candidate = node->child1().node();
+                    Node* candidate = node->argumentsChild().node();
                     if (!isEliminatedAllocation(candidate))
                         break;
 
                     // LoadVarargs can exit, so it better be exitOK.
                     DFG_ASSERT(m_graph, node, node->origin.exitOK);
@@ -860,30 +878,31 @@
                         Node* argumentCountIncludingThisNode = insertionSet.insertConstant(
                             nodeIndex, node->origin.withExitOK(canExit),
                             jsNumber(argumentCountIncludingThis));
                         insertionSet.insertNode(
                             nodeIndex, SpecNone, KillStack, node->origin.takeValidExit(canExit),
-                            OpInfo(varargsData->count.offset()));
+                            OpInfo(varargsData->count));
                         insertionSet.insertNode(
                             nodeIndex, SpecNone, MovHint, node->origin.takeValidExit(canExit),
-                            OpInfo(varargsData->count.offset()), Edge(argumentCountIncludingThisNode));
+                            OpInfo(varargsData->count), Edge(argumentCountIncludingThisNode));
                         insertionSet.insertNode(
                             nodeIndex, SpecNone, PutStack, node->origin.withExitOK(canExit),
                             OpInfo(m_graph.m_stackAccessData.add(varargsData->count, FlushedInt32)),
                             Edge(argumentCountIncludingThisNode, KnownInt32Use));
                     };
 
                     auto storeValue = [&] (Node* value, unsigned storeIndex) {
                         VirtualRegister reg = varargsData->start + storeIndex;
+                        ASSERT(reg.isLocal());
                         StackAccessData* data =
                             m_graph.m_stackAccessData.add(reg, FlushedJSValue);
 
                         insertionSet.insertNode(
-                            nodeIndex, SpecNone, KillStack, node->origin.takeValidExit(canExit), OpInfo(reg.offset()));
+                            nodeIndex, SpecNone, KillStack, node->origin.takeValidExit(canExit), OpInfo(reg));
                         insertionSet.insertNode(
                             nodeIndex, SpecNone, MovHint, node->origin.takeValidExit(canExit),
-                            OpInfo(reg.offset()), Edge(value));
+                            OpInfo(reg), Edge(value));
                         insertionSet.insertNode(
                             nodeIndex, SpecNone, PutStack, node->origin.withExitOK(canExit),
                             OpInfo(data), Edge(value));
                     };
 
@@ -933,11 +952,11 @@
                                     return candidate->castOperand<JSImmutableButterfly*>()->length();
 
                                 ASSERT(candidate->op() == PhantomCreateRest);
                                 unsigned numberOfArgumentsToSkip = candidate->numberOfArgumentsToSkip();
                                 InlineCallFrame* inlineCallFrame = candidate->origin.semantic.inlineCallFrame();
-                                unsigned frameArgumentCount = inlineCallFrame->argumentCountIncludingThis - 1;
+                                unsigned frameArgumentCount = static_cast<unsigned>(inlineCallFrame->argumentCountIncludingThis - 1);
                                 if (frameArgumentCount >= numberOfArgumentsToSkip)
                                     return frameArgumentCount - numberOfArgumentsToSkip;
                                 return 0;
                             });
 
@@ -981,13 +1000,13 @@
                                     }
 
                                     ASSERT(candidate->op() == PhantomCreateRest);
                                     unsigned numberOfArgumentsToSkip = candidate->numberOfArgumentsToSkip();
                                     InlineCallFrame* inlineCallFrame = candidate->origin.semantic.inlineCallFrame();
-                                    unsigned frameArgumentCount = inlineCallFrame->argumentCountIncludingThis - 1;
+                                    unsigned frameArgumentCount = static_cast<unsigned>(inlineCallFrame->argumentCountIncludingThis - 1);
                                     for (unsigned loadIndex = numberOfArgumentsToSkip; loadIndex < frameArgumentCount; ++loadIndex) {
-                                        VirtualRegister reg = virtualRegisterForArgument(loadIndex + 1) + inlineCallFrame->stackOffset;
+                                        VirtualRegister reg = virtualRegisterForArgumentIncludingThis(loadIndex + 1) + inlineCallFrame->stackOffset;
                                         StackAccessData* data = m_graph.m_stackAccessData.add(reg, FlushedJSValue);
                                         Node* value = insertionSet.insertNode(
                                             nodeIndex, SpecNone, GetStack, node->origin.withExitOK(canExit),
                                             OpInfo(data));
                                         storeValue(value, storeIndex++);
@@ -1017,22 +1036,19 @@
                             numberOfArgumentsToSkip = candidate->numberOfArgumentsToSkip();
                         varargsData->offset += numberOfArgumentsToSkip;
 
                         InlineCallFrame* inlineCallFrame = candidate->origin.semantic.inlineCallFrame();
 
-                        if (inlineCallFrame
-                            && !inlineCallFrame->isVarargs()) {
-
+                        if (inlineCallFrame && !inlineCallFrame->isVarargs()) {
                             unsigned argumentCountIncludingThis = inlineCallFrame->argumentCountIncludingThis;
                             if (argumentCountIncludingThis > varargsData->offset)
                                 argumentCountIncludingThis -= varargsData->offset;
                             else
                                 argumentCountIncludingThis = 1;
                             RELEASE_ASSERT(argumentCountIncludingThis >= 1);
 
                             if (argumentCountIncludingThis <= varargsData->limit) {
-
                                 storeArgumentCountIncludingThis(argumentCountIncludingThis);
 
                                 DFG_ASSERT(m_graph, node, varargsData->limit - 1 >= varargsData->mandatoryMinimum, varargsData->limit, varargsData->mandatoryMinimum);
                                 // Define our limit to exclude "this", since that's a bit easier to reason about.
                                 unsigned limit = varargsData->limit - 1;
@@ -1043,11 +1059,11 @@
 
                                     Node* value = nullptr;
                                     unsigned loadIndex = storeIndex + varargsData->offset;
 
                                     if (loadIndex + 1 < inlineCallFrame->argumentCountIncludingThis) {
-                                        VirtualRegister reg = virtualRegisterForArgument(loadIndex + 1) + inlineCallFrame->stackOffset;
+                                        VirtualRegister reg = virtualRegisterForArgumentIncludingThis(loadIndex + 1) + inlineCallFrame->stackOffset;
                                         StackAccessData* data = m_graph.m_stackAccessData.add(
                                             reg, FlushedJSValue);
 
                                         value = insertionSet.insertNode(
                                             nodeIndex, SpecNone, GetStack, node->origin.withExitOK(canExit),
@@ -1199,11 +1215,11 @@
                                 ASSERT(candidate->op() == PhantomCreateRest);
                                 InlineCallFrame* inlineCallFrame = candidate->origin.semantic.inlineCallFrame();
                                 unsigned numberOfArgumentsToSkip = candidate->numberOfArgumentsToSkip();
                                 for (unsigned i = 1 + numberOfArgumentsToSkip; i < inlineCallFrame->argumentCountIncludingThis; ++i) {
                                     StackAccessData* data = m_graph.m_stackAccessData.add(
-                                        virtualRegisterForArgument(i) + inlineCallFrame->stackOffset,
+                                        virtualRegisterForArgumentIncludingThis(i) + inlineCallFrame->stackOffset,
                                         FlushedJSValue);
 
                                     Node* value = insertionSet.insertNode(
                                         nodeIndex, SpecNone, GetStack, node->origin, OpInfo(data));
 
@@ -1225,11 +1241,11 @@
                         InlineCallFrame* inlineCallFrame = candidate->origin.semantic.inlineCallFrame();
                         if (inlineCallFrame && !inlineCallFrame->isVarargs()) {
                             Vector<Node*> arguments;
                             for (unsigned i = 1 + varargsData->firstVarArgOffset; i < inlineCallFrame->argumentCountIncludingThis; ++i) {
                                 StackAccessData* data = m_graph.m_stackAccessData.add(
-                                    virtualRegisterForArgument(i) + inlineCallFrame->stackOffset,
+                                    virtualRegisterForArgumentIncludingThis(i) + inlineCallFrame->stackOffset,
                                     FlushedJSValue);
 
                                 Node* value = insertionSet.insertNode(
                                     nodeIndex, SpecNone, GetStack, node->origin, OpInfo(data));
 
@@ -1242,13 +1258,14 @@
                     }
 
                     break;
                 }
 
+                case CheckArrayOrEmpty:
                 case CheckArray:
                 case GetButterfly:
-                case FilterGetByIdStatus:
+                case FilterGetByStatus:
                 case FilterPutByIdStatus:
                 case FilterCallLinkStatus:
                 case FilterInByIdStatus: {
                     if (!isEliminatedAllocation(node->child1().node()))
                         break;

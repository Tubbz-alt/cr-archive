<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IntlNumberFormatPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IntlObject.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,9 ***</span>
  /*
   * Copyright (C) 2015 Andy VanWagoner (andy@vanwagoner.family)
   * Copyright (C) 2015 Sukolsak Sakshuwong (sukolsak@gmail.com)
<span class="line-modified">!  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,9 ---</span>
  /*
   * Copyright (C) 2015 Andy VanWagoner (andy@vanwagoner.family)
   * Copyright (C) 2015 Sukolsak Sakshuwong (sukolsak@gmail.com)
<span class="line-modified">!  * Copyright (C) 2016-2020 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,22 ***</span>
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSCJSValueInlines.h&quot;
  #include &quot;Lookup.h&quot;
  #include &quot;ObjectPrototype.h&quot;
  #include &quot;Options.h&quot;
  #include &lt;unicode/uloc.h&gt;
  #include &lt;unicode/unumsys.h&gt;
  #include &lt;wtf/Assertions.h&gt;
  #include &lt;wtf/Language.h&gt;
  #include &lt;wtf/NeverDestroyed.h&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace JSC {
  
  STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(IntlObject);
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL intlObjectFuncGetCanonicalLocales(ExecState*);</span>
  
  static JSValue createCollatorConstructor(VM&amp; vm, JSObject* object)
  {
      IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
      JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
<span class="line-new-header">--- 44,26 ---</span>
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSCJSValueInlines.h&quot;
  #include &quot;Lookup.h&quot;
  #include &quot;ObjectPrototype.h&quot;
  #include &quot;Options.h&quot;
<span class="line-added">+ #include &lt;unicode/ucol.h&gt;</span>
<span class="line-added">+ #include &lt;unicode/udat.h&gt;</span>
  #include &lt;unicode/uloc.h&gt;
<span class="line-added">+ #include &lt;unicode/unum.h&gt;</span>
  #include &lt;unicode/unumsys.h&gt;
  #include &lt;wtf/Assertions.h&gt;
  #include &lt;wtf/Language.h&gt;
  #include &lt;wtf/NeverDestroyed.h&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
<span class="line-added">+ #include &lt;wtf/text/StringImpl.h&gt;</span>
  
  namespace JSC {
  
  STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(IntlObject);
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL intlObjectFuncGetCanonicalLocales(JSGlobalObject*, CallFrame*);</span>
  
  static JSValue createCollatorConstructor(VM&amp; vm, JSObject* object)
  {
      IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
      JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 126,109 ***</span>
  Structure* IntlObject::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  {
      return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
  }
  
<span class="line-modified">! String convertICULocaleToBCP47LanguageTag(const char* localeID)</span>
  {
      UErrorCode status = U_ZERO_ERROR;
      Vector&lt;char, 32&gt; buffer(32);
      auto length = uloc_toLanguageTag(localeID, buffer.data(), buffer.size(), false, &amp;status);
      if (status == U_BUFFER_OVERFLOW_ERROR) {
          buffer.grow(length);
          status = U_ZERO_ERROR;
          uloc_toLanguageTag(localeID, buffer.data(), buffer.size(), false, &amp;status);
      }
      if (!U_FAILURE(status))
<span class="line-modified">!         return String(buffer.data(), length);</span>
      return String();
  }
  
<span class="line-modified">! bool intlBooleanOption(ExecState&amp; state, JSValue options, PropertyName property, bool&amp; usesFallback)</span>
  {
      // GetOption (options, property, type=&quot;boolean&quot;, values, fallback)
      // https://tc39.github.io/ecma402/#sec-getoption
  
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* opts = options.toObject(&amp;state);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     JSValue value = opts-&gt;get(&amp;state, property);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (!value.isUndefined()) {
<span class="line-modified">!         bool booleanValue = value.toBoolean(&amp;state);</span>
          usesFallback = false;
          return booleanValue;
      }
  
      // Because fallback can be undefined, we let the caller handle it instead.
      usesFallback = true;
      return false;
  }
  
<span class="line-modified">! String intlStringOption(ExecState&amp; state, JSValue options, PropertyName property, std::initializer_list&lt;const char*&gt; values, const char* notFound, const char* fallback)</span>
  {
      // GetOption (options, property, type=&quot;string&quot;, values, fallback)
      // https://tc39.github.io/ecma402/#sec-getoption
  
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* opts = options.toObject(&amp;state);</span>
      RETURN_IF_EXCEPTION(scope, String());
  
<span class="line-modified">!     JSValue value = opts-&gt;get(&amp;state, property);</span>
      RETURN_IF_EXCEPTION(scope, String());
  
      if (!value.isUndefined()) {
<span class="line-modified">!         String stringValue = value.toWTFString(&amp;state);</span>
          RETURN_IF_EXCEPTION(scope, String());
  
          if (values.size() &amp;&amp; std::find(values.begin(), values.end(), stringValue) == values.end()) {
<span class="line-modified">!             throwException(&amp;state, scope, createRangeError(&amp;state, notFound));</span>
              return { };
          }
          return stringValue;
      }
  
      return fallback;
  }
  
<span class="line-modified">! unsigned intlNumberOption(ExecState&amp; state, JSValue options, PropertyName property, unsigned minimum, unsigned maximum, unsigned fallback)</span>
  {
      // GetNumberOption (options, property, minimum, maximum, fallback)
      // https://tc39.github.io/ecma402/#sec-getnumberoption
  
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* opts = options.toObject(&amp;state);</span>
      RETURN_IF_EXCEPTION(scope, 0);
  
<span class="line-modified">!     JSValue value = opts-&gt;get(&amp;state, property);</span>
      RETURN_IF_EXCEPTION(scope, 0);
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, intlDefaultNumberOption(state, value, property, minimum, maximum, fallback));</span>
  }
  
<span class="line-modified">! unsigned intlDefaultNumberOption(ExecState&amp; state, JSValue value, PropertyName property, unsigned minimum, unsigned maximum, unsigned fallback)</span>
  {
      // DefaultNumberOption (value, minimum, maximum, fallback)
      // https://tc39.github.io/ecma402/#sec-defaultnumberoption
  
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!value.isUndefined()) {
<span class="line-modified">!         double doubleValue = value.toNumber(&amp;state);</span>
          RETURN_IF_EXCEPTION(scope, 0);
  
          if (!(doubleValue &gt;= minimum &amp;&amp; doubleValue &lt;= maximum)) {
<span class="line-modified">!             throwException(&amp;state, scope, createRangeError(&amp;state, *property.publicName() + &quot; is out of range&quot;));</span>
              return 0;
          }
          return static_cast&lt;unsigned&gt;(doubleValue);
      }
      return fallback;
<span class="line-new-header">--- 130,196 ---</span>
  Structure* IntlObject::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  {
      return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
  }
  
<span class="line-modified">! static String convertICULocaleToBCP47LanguageTag(const char* localeID)</span>
  {
      UErrorCode status = U_ZERO_ERROR;
      Vector&lt;char, 32&gt; buffer(32);
      auto length = uloc_toLanguageTag(localeID, buffer.data(), buffer.size(), false, &amp;status);
      if (status == U_BUFFER_OVERFLOW_ERROR) {
          buffer.grow(length);
          status = U_ZERO_ERROR;
          uloc_toLanguageTag(localeID, buffer.data(), buffer.size(), false, &amp;status);
      }
      if (!U_FAILURE(status))
<span class="line-modified">!         return String(StringImpl::createStaticStringImpl(buffer.data(), length));</span>
      return String();
  }
  
<span class="line-modified">! static void addMissingScriptLocales(HashSet&lt;String&gt;&amp; availableLocales)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     static const NeverDestroyed&lt;String&gt; pa_PK_String(MAKE_STATIC_STRING_IMPL(&quot;pa-PK&quot;));</span>
<span class="line-added">+     static const NeverDestroyed&lt;String&gt; zh_CN_String(MAKE_STATIC_STRING_IMPL(&quot;zh-CN&quot;));</span>
<span class="line-added">+     static const NeverDestroyed&lt;String&gt; zh_HK_String(MAKE_STATIC_STRING_IMPL(&quot;zh-HK&quot;));</span>
<span class="line-added">+     static const NeverDestroyed&lt;String&gt; zh_SG_String(MAKE_STATIC_STRING_IMPL(&quot;zh-SG&quot;));</span>
<span class="line-added">+     static const NeverDestroyed&lt;String&gt; zh_TW_String(MAKE_STATIC_STRING_IMPL(&quot;zh-TW&quot;));</span>
<span class="line-added">+     if (availableLocales.contains(&quot;pa-Arab-PK&quot;))</span>
<span class="line-added">+         availableLocales.add(pa_PK_String.get());</span>
<span class="line-added">+     if (availableLocales.contains(&quot;zh-Hans-CN&quot;))</span>
<span class="line-added">+         availableLocales.add(zh_CN_String.get());</span>
<span class="line-added">+     if (availableLocales.contains(&quot;zh-Hant-HK&quot;))</span>
<span class="line-added">+         availableLocales.add(zh_HK_String.get());</span>
<span class="line-added">+     if (availableLocales.contains(&quot;zh-Hans-SG&quot;))</span>
<span class="line-added">+         availableLocales.add(zh_SG_String.get());</span>
<span class="line-added">+     if (availableLocales.contains(&quot;zh-Hant-TW&quot;))</span>
<span class="line-added">+         availableLocales.add(zh_TW_String.get());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ const HashSet&lt;String&gt;&amp; intlCollatorAvailableLocales()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     static NeverDestroyed&lt;HashSet&lt;String&gt;&gt; cachedAvailableLocales;</span>
<span class="line-added">+     HashSet&lt;String&gt;&amp; availableLocales = cachedAvailableLocales.get();</span>
<span class="line-added">+ </span>
<span class="line-added">+     static std::once_flag initializeOnce;</span>
<span class="line-added">+     std::call_once(initializeOnce, [&amp;] {</span>
<span class="line-added">+         ASSERT(availableLocales.isEmpty());</span>
<span class="line-added">+         int32_t count = ucol_countAvailable();</span>
<span class="line-added">+         for (int32_t i = 0; i &lt; count; ++i) {</span>
<span class="line-added">+             String locale = convertICULocaleToBCP47LanguageTag(ucol_getAvailable(i));</span>
<span class="line-added">+             if (!locale.isEmpty())</span>
<span class="line-added">+                 availableLocales.add(locale);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         addMissingScriptLocales(availableLocales);</span>
<span class="line-added">+     });</span>
<span class="line-added">+     return availableLocales;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ const HashSet&lt;String&gt;&amp; intlDateTimeFormatAvailableLocales()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     static NeverDestroyed&lt;HashSet&lt;String&gt;&gt; cachedAvailableLocales;</span>
<span class="line-added">+     HashSet&lt;String&gt;&amp; availableLocales = cachedAvailableLocales.get();</span>
<span class="line-added">+ </span>
<span class="line-added">+     static std::once_flag initializeOnce;</span>
<span class="line-added">+     std::call_once(initializeOnce, [&amp;] {</span>
<span class="line-added">+         ASSERT(availableLocales.isEmpty());</span>
<span class="line-added">+         int32_t count = udat_countAvailable();</span>
<span class="line-added">+         for (int32_t i = 0; i &lt; count; ++i) {</span>
<span class="line-added">+             String locale = convertICULocaleToBCP47LanguageTag(udat_getAvailable(i));</span>
<span class="line-added">+             if (!locale.isEmpty())</span>
<span class="line-added">+                 availableLocales.add(locale);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         addMissingScriptLocales(availableLocales);</span>
<span class="line-added">+     });</span>
<span class="line-added">+     return availableLocales;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ const HashSet&lt;String&gt;&amp; intlNumberFormatAvailableLocales()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     static NeverDestroyed&lt;HashSet&lt;String&gt;&gt; cachedAvailableLocales;</span>
<span class="line-added">+     HashSet&lt;String&gt;&amp; availableLocales = cachedAvailableLocales.get();</span>
<span class="line-added">+ </span>
<span class="line-added">+     static std::once_flag initializeOnce;</span>
<span class="line-added">+     std::call_once(initializeOnce, [&amp;] {</span>
<span class="line-added">+         ASSERT(availableLocales.isEmpty());</span>
<span class="line-added">+         int32_t count = unum_countAvailable();</span>
<span class="line-added">+         for (int32_t i = 0; i &lt; count; ++i) {</span>
<span class="line-added">+             String locale = convertICULocaleToBCP47LanguageTag(unum_getAvailable(i));</span>
<span class="line-added">+             if (!locale.isEmpty())</span>
<span class="line-added">+                 availableLocales.add(locale);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         addMissingScriptLocales(availableLocales);</span>
<span class="line-added">+     });</span>
<span class="line-added">+     return availableLocales;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool intlBooleanOption(JSGlobalObject* globalObject, JSValue options, PropertyName property, bool&amp; usesFallback)</span>
  {
      // GetOption (options, property, type=&quot;boolean&quot;, values, fallback)
      // https://tc39.github.io/ecma402/#sec-getoption
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (options.isUndefined()) {</span>
<span class="line-added">+         usesFallback = true;</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSObject* opts = options.toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     JSValue value = opts-&gt;get(globalObject, property);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      if (!value.isUndefined()) {
<span class="line-modified">!         bool booleanValue = value.toBoolean(globalObject);</span>
          usesFallback = false;
          return booleanValue;
      }
  
      // Because fallback can be undefined, we let the caller handle it instead.
      usesFallback = true;
      return false;
  }
  
<span class="line-modified">! String intlStringOption(JSGlobalObject* globalObject, JSValue options, PropertyName property, std::initializer_list&lt;const char*&gt; values, const char* notFound, const char* fallback)</span>
  {
      // GetOption (options, property, type=&quot;string&quot;, values, fallback)
      // https://tc39.github.io/ecma402/#sec-getoption
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (options.isUndefined())</span>
<span class="line-added">+         return fallback;</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSObject* opts = options.toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, String());
  
<span class="line-modified">!     JSValue value = opts-&gt;get(globalObject, property);</span>
      RETURN_IF_EXCEPTION(scope, String());
  
      if (!value.isUndefined()) {
<span class="line-modified">!         String stringValue = value.toWTFString(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, String());
  
          if (values.size() &amp;&amp; std::find(values.begin(), values.end(), stringValue) == values.end()) {
<span class="line-modified">!             throwException(globalObject, scope, createRangeError(globalObject, notFound));</span>
              return { };
          }
          return stringValue;
      }
  
      return fallback;
  }
  
<span class="line-modified">! unsigned intlNumberOption(JSGlobalObject* globalObject, JSValue options, PropertyName property, unsigned minimum, unsigned maximum, unsigned fallback)</span>
  {
      // GetNumberOption (options, property, minimum, maximum, fallback)
      // https://tc39.github.io/ecma402/#sec-getnumberoption
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (options.isUndefined())</span>
<span class="line-added">+         return fallback;</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSObject* opts = options.toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, 0);
  
<span class="line-modified">!     JSValue value = opts-&gt;get(globalObject, property);</span>
      RETURN_IF_EXCEPTION(scope, 0);
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, intlDefaultNumberOption(globalObject, value, property, minimum, maximum, fallback));</span>
  }
  
<span class="line-modified">! unsigned intlDefaultNumberOption(JSGlobalObject* globalObject, JSValue value, PropertyName property, unsigned minimum, unsigned maximum, unsigned fallback)</span>
  {
      // DefaultNumberOption (value, minimum, maximum, fallback)
      // https://tc39.github.io/ecma402/#sec-defaultnumberoption
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!value.isUndefined()) {
<span class="line-modified">!         double doubleValue = value.toNumber(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, 0);
  
          if (!(doubleValue &gt;= minimum &amp;&amp; doubleValue &lt;= maximum)) {
<span class="line-modified">!             throwException(globalObject, scope, createRangeError(globalObject, *property.publicName() + &quot; is out of range&quot;));</span>
              return 0;
          }
          return static_cast&lt;unsigned&gt;(doubleValue);
      }
      return fallback;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 493,70 ***</span>
      }
  
      return String();
  }
  
<span class="line-modified">! Vector&lt;String&gt; canonicalizeLocaleList(ExecState&amp; state, JSValue locales)</span>
  {
      // CanonicalizeLocaleList (locales)
      // https://tc39.github.io/ecma402/#sec-canonicalizelocalelist
  
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-removed">-     JSGlobalObject* globalObject = state.jsCallee()-&gt;globalObject(vm);</span>
      Vector&lt;String&gt; seen;
  
      if (locales.isUndefined())
          return seen;
  
      JSObject* localesObject;
      if (locales.isString()) {
          JSArray* localesArray = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous));
          if (!localesArray) {
<span class="line-modified">!             throwOutOfMemoryError(&amp;state, scope);</span>
              RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
          }
<span class="line-modified">!         localesArray-&gt;push(&amp;state, locales);</span>
          RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
  
          localesObject = localesArray;
      } else {
<span class="line-modified">!         localesObject = locales.toObject(&amp;state);</span>
          RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
      }
  
      // 6. Let len be ToLength(Get(O, &quot;length&quot;)).
<span class="line-modified">!     JSValue lengthProperty = localesObject-&gt;get(&amp;state, vm.propertyNames-&gt;length);</span>
      RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
  
<span class="line-modified">!     double length = lengthProperty.toLength(&amp;state);</span>
      RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
  
      HashSet&lt;String&gt; seenSet;
      for (double k = 0; k &lt; length; ++k) {
<span class="line-modified">!         bool kPresent = localesObject-&gt;hasProperty(&amp;state, k);</span>
          RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
  
          if (kPresent) {
<span class="line-modified">!             JSValue kValue = localesObject-&gt;get(&amp;state, k);</span>
              RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
  
              if (!kValue.isString() &amp;&amp; !kValue.isObject()) {
<span class="line-modified">!                 throwTypeError(&amp;state, scope, &quot;locale value must be a string or object&quot;_s);</span>
                  return Vector&lt;String&gt;();
              }
  
<span class="line-modified">!             JSString* tag = kValue.toString(&amp;state);</span>
              RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
  
<span class="line-modified">!             auto tagValue = tag-&gt;value(&amp;state);</span>
              RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
  
              String canonicalizedTag = canonicalizeLanguageTag(tagValue);
              if (canonicalizedTag.isNull()) {
<span class="line-modified">!                 throwException(&amp;state, scope, createRangeError(&amp;state, &quot;invalid language tag: &quot; + tagValue));</span>
                  return Vector&lt;String&gt;();
              }
  
              if (seenSet.add(canonicalizedTag).isNewEntry)
                  seen.append(canonicalizedTag);
<span class="line-new-header">--- 584,69 ---</span>
      }
  
      return String();
  }
  
<span class="line-modified">! Vector&lt;String&gt; canonicalizeLocaleList(JSGlobalObject* globalObject, JSValue locales)</span>
  {
      // CanonicalizeLocaleList (locales)
      // https://tc39.github.io/ecma402/#sec-canonicalizelocalelist
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Vector&lt;String&gt; seen;
  
      if (locales.isUndefined())
          return seen;
  
      JSObject* localesObject;
      if (locales.isString()) {
          JSArray* localesArray = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous));
          if (!localesArray) {
<span class="line-modified">!             throwOutOfMemoryError(globalObject, scope);</span>
              RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
          }
<span class="line-modified">!         localesArray-&gt;push(globalObject, locales);</span>
          RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
  
          localesObject = localesArray;
      } else {
<span class="line-modified">!         localesObject = locales.toObject(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
      }
  
      // 6. Let len be ToLength(Get(O, &quot;length&quot;)).
<span class="line-modified">!     JSValue lengthProperty = localesObject-&gt;get(globalObject, vm.propertyNames-&gt;length);</span>
      RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
  
<span class="line-modified">!     double length = lengthProperty.toLength(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
  
      HashSet&lt;String&gt; seenSet;
      for (double k = 0; k &lt; length; ++k) {
<span class="line-modified">!         bool kPresent = localesObject-&gt;hasProperty(globalObject, k);</span>
          RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
  
          if (kPresent) {
<span class="line-modified">!             JSValue kValue = localesObject-&gt;get(globalObject, k);</span>
              RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
  
              if (!kValue.isString() &amp;&amp; !kValue.isObject()) {
<span class="line-modified">!                 throwTypeError(globalObject, scope, &quot;locale value must be a string or object&quot;_s);</span>
                  return Vector&lt;String&gt;();
              }
  
<span class="line-modified">!             JSString* tag = kValue.toString(globalObject);</span>
              RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
  
<span class="line-modified">!             auto tagValue = tag-&gt;value(globalObject);</span>
              RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
  
              String canonicalizedTag = canonicalizeLanguageTag(tagValue);
              if (canonicalizedTag.isNull()) {
<span class="line-modified">!                 throwException(globalObject, scope, createRangeError(globalObject, &quot;invalid language tag: &quot; + tagValue));</span>
                  return Vector&lt;String&gt;();
              }
  
              if (seenSet.add(canonicalizedTag).isNewEntry)
                  seen.append(canonicalizedTag);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 587,20 ***</span>
      }
  
      return String();
  }
  
<span class="line-modified">! String defaultLocale(ExecState&amp; state)</span>
  {
      // DefaultLocale ()
      // https://tc39.github.io/ecma402/#sec-defaultlocale
  
      // WebCore&#39;s global objects will have their own ideas of how to determine the language. It may
      // be determined by WebCore-specific logic like some WK settings. Usually this will return the
      // same thing as userPreferredLanguages()[0].
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
<span class="line-removed">-     if (auto defaultLanguage = state.jsCallee()-&gt;globalObject(vm)-&gt;globalObjectMethodTable()-&gt;defaultLanguage) {</span>
          String locale = canonicalizeLanguageTag(defaultLanguage());
          if (!locale.isEmpty())
              return locale;
      }
  
<span class="line-new-header">--- 677,19 ---</span>
      }
  
      return String();
  }
  
<span class="line-modified">! String defaultLocale(JSGlobalObject* globalObject)</span>
  {
      // DefaultLocale ()
      // https://tc39.github.io/ecma402/#sec-defaultlocale
  
      // WebCore&#39;s global objects will have their own ideas of how to determine the language. It may
      // be determined by WebCore-specific logic like some WK settings. Usually this will return the
      // same thing as userPreferredLanguages()[0].
<span class="line-modified">!     if (auto defaultLanguage = globalObject-&gt;globalObjectMethodTable()-&gt;defaultLanguage) {</span>
          String locale = canonicalizeLanguageTag(defaultLanguage());
          if (!locale.isEmpty())
              return locale;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 611,13 ***</span>
              return locale;
      }
  
      // If all else fails, ask ICU. It will probably say something bogus like en_us even if the user
      // has configured some other language, but being wrong is better than crashing.
<span class="line-modified">!     String locale = convertICULocaleToBCP47LanguageTag(uloc_getDefault());</span>
<span class="line-modified">!     if (!locale.isEmpty())</span>
<span class="line-modified">!         return locale;</span>
  
      return &quot;en&quot;_s;
  }
  
  String removeUnicodeLocaleExtension(const String&amp; locale)
<span class="line-new-header">--- 700,17 ---</span>
              return locale;
      }
  
      // If all else fails, ask ICU. It will probably say something bogus like en_us even if the user
      // has configured some other language, but being wrong is better than crashing.
<span class="line-modified">!     static NeverDestroyed&lt;String&gt; icuDefaultLocalString;</span>
<span class="line-modified">!     static std::once_flag initializeOnce;</span>
<span class="line-modified">!     std::call_once(initializeOnce, [&amp;] {</span>
<span class="line-added">+         icuDefaultLocalString.get() = convertICULocaleToBCP47LanguageTag(uloc_getDefault());</span>
<span class="line-added">+     });</span>
<span class="line-added">+     if (!icuDefaultLocalString-&gt;isEmpty())</span>
<span class="line-added">+         return icuDefaultLocalString.get();</span>
  
      return &quot;en&quot;_s;
  }
  
  String removeUnicodeLocaleExtension(const String&amp; locale)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 642,11 ***</span>
          }
      }
      return builder.toString();
  }
  
<span class="line-modified">! static MatcherResult lookupMatcher(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)</span>
  {
      // LookupMatcher (availableLocales, requestedLocales)
      // https://tc39.github.io/ecma402/#sec-lookupmatcher
  
      String locale;
<span class="line-new-header">--- 735,11 ---</span>
          }
      }
      return builder.toString();
  }
  
<span class="line-modified">! static MatcherResult lookupMatcher(JSGlobalObject* globalObject, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)</span>
  {
      // LookupMatcher (availableLocales, requestedLocales)
      // https://tc39.github.io/ecma402/#sec-lookupmatcher
  
      String locale;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 679,21 ***</span>
              }
              result.extension = locale.substring(extensionIndex, extensionLength);
              result.extensionIndex = extensionIndex;
          }
      } else
<span class="line-modified">!         result.locale = defaultLocale(state);</span>
      return result;
  }
  
<span class="line-modified">! static MatcherResult bestFitMatcher(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)</span>
  {
      // BestFitMatcher (availableLocales, requestedLocales)
      // https://tc39.github.io/ecma402/#sec-bestfitmatcher
  
      // FIXME: Implement something better than lookup.
<span class="line-modified">!     return lookupMatcher(state, availableLocales, requestedLocales);</span>
  }
  
  static void unicodeExtensionSubTags(const String&amp; extension, Vector&lt;String&gt;&amp; subtags)
  {
      // UnicodeExtensionSubtags (extension)
<span class="line-new-header">--- 772,21 ---</span>
              }
              result.extension = locale.substring(extensionIndex, extensionLength);
              result.extensionIndex = extensionIndex;
          }
      } else
<span class="line-modified">!         result.locale = defaultLocale(globalObject);</span>
      return result;
  }
  
<span class="line-modified">! static MatcherResult bestFitMatcher(JSGlobalObject* globalObject, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)</span>
  {
      // BestFitMatcher (availableLocales, requestedLocales)
      // https://tc39.github.io/ecma402/#sec-bestfitmatcher
  
      // FIXME: Implement something better than lookup.
<span class="line-modified">!     return lookupMatcher(globalObject, availableLocales, requestedLocales);</span>
  }
  
  static void unicodeExtensionSubTags(const String&amp; extension, Vector&lt;String&gt;&amp; subtags)
  {
      // UnicodeExtensionSubtags (extension)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 731,19 ***</span>
      }
      // Append final key&#39;s value.
      subtags.append(extension.substring(valueStart, extensionLength - valueStart));
  }
  
<span class="line-modified">! HashMap&lt;String, String&gt; resolveLocale(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales, const HashMap&lt;String, String&gt;&amp; options, const char* const relevantExtensionKeys[], size_t relevantExtensionKeyCount, Vector&lt;String&gt; (*localeData)(const String&amp;, size_t))</span>
  {
      // ResolveLocale (availableLocales, requestedLocales, options, relevantExtensionKeys, localeData)
      // https://tc39.github.io/ecma402/#sec-resolvelocale
  
      const String&amp; matcher = options.get(&quot;localeMatcher&quot;_s);
      MatcherResult matcherResult = (matcher == &quot;lookup&quot;)
<span class="line-modified">!         ? lookupMatcher(state, availableLocales, requestedLocales)</span>
<span class="line-modified">!         : bestFitMatcher(state, availableLocales, requestedLocales);</span>
  
      String foundLocale = matcherResult.locale;
  
      Vector&lt;String&gt; extensionSubtags;
      if (!matcherResult.extension.isNull())
<span class="line-new-header">--- 824,19 ---</span>
      }
      // Append final key&#39;s value.
      subtags.append(extension.substring(valueStart, extensionLength - valueStart));
  }
  
<span class="line-modified">! HashMap&lt;String, String&gt; resolveLocale(JSGlobalObject* globalObject, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales, const HashMap&lt;String, String&gt;&amp; options, const char* const relevantExtensionKeys[], size_t relevantExtensionKeyCount, Vector&lt;String&gt; (*localeData)(const String&amp;, size_t))</span>
  {
      // ResolveLocale (availableLocales, requestedLocales, options, relevantExtensionKeys, localeData)
      // https://tc39.github.io/ecma402/#sec-resolvelocale
  
      const String&amp; matcher = options.get(&quot;localeMatcher&quot;_s);
      MatcherResult matcherResult = (matcher == &quot;lookup&quot;)
<span class="line-modified">!         ? lookupMatcher(globalObject, availableLocales, requestedLocales)</span>
<span class="line-modified">!         : bestFitMatcher(globalObject, availableLocales, requestedLocales);</span>
  
      String foundLocale = matcherResult.locale;
  
      Vector&lt;String&gt; extensionSubtags;
      if (!matcherResult.extension.isNull())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 798,115 ***</span>
  
      result.add(&quot;locale&quot;_s, foundLocale);
      return result;
  }
  
<span class="line-modified">! static JSArray* lookupSupportedLocales(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)</span>
  {
      // LookupSupportedLocales (availableLocales, requestedLocales)
      // https://tc39.github.io/ecma402/#sec-lookupsupportedlocales
  
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      size_t len = requestedLocales.size();
<span class="line-removed">-     JSGlobalObject* globalObject = state.jsCallee()-&gt;globalObject(vm);</span>
      JSArray* subset = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithUndecided), 0);
      if (!subset) {
<span class="line-modified">!         throwOutOfMemoryError(&amp;state, scope);</span>
          return nullptr;
      }
  
      unsigned index = 0;
      for (size_t k = 0; k &lt; len; ++k) {
          const String&amp; locale = requestedLocales[k];
          String noExtensionsLocale = removeUnicodeLocaleExtension(locale);
          String availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);
          if (!availableLocale.isNull()) {
<span class="line-modified">!             subset-&gt;putDirectIndex(&amp;state, index++, jsString(vm, locale));</span>
              RETURN_IF_EXCEPTION(scope, nullptr);
          }
      }
  
      return subset;
  }
  
<span class="line-modified">! static JSArray* bestFitSupportedLocales(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)</span>
  {
      // BestFitSupportedLocales (availableLocales, requestedLocales)
      // https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales
  
      // FIXME: Implement something better than lookup.
<span class="line-modified">!     return lookupSupportedLocales(state, availableLocales, requestedLocales);</span>
  }
  
<span class="line-modified">! JSValue supportedLocales(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales, JSValue options)</span>
  {
      // SupportedLocales (availableLocales, requestedLocales, options)
      // https://tc39.github.io/ecma402/#sec-supportedlocales
  
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      String matcher;
  
      if (!options.isUndefined()) {
<span class="line-modified">!         matcher = intlStringOption(state, options, vm.propertyNames-&gt;localeMatcher, { &quot;lookup&quot;, &quot;best fit&quot; }, &quot;localeMatcher must be either \&quot;lookup\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
      } else
          matcher = &quot;best fit&quot;_s;
  
      JSArray* supportedLocales = (matcher == &quot;best fit&quot;)
<span class="line-modified">!         ? bestFitSupportedLocales(state, availableLocales, requestedLocales)</span>
<span class="line-modified">!         : lookupSupportedLocales(state, availableLocales, requestedLocales);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
      PropertyNameArray keys(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
<span class="line-modified">!     supportedLocales-&gt;getOwnPropertyNames(supportedLocales, &amp;state, keys, EnumerationMode());</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
      PropertyDescriptor desc;
      desc.setConfigurable(false);
      desc.setWritable(false);
  
      size_t len = keys.size();
      for (size_t i = 0; i &lt; len; ++i) {
<span class="line-modified">!         supportedLocales-&gt;defineOwnProperty(supportedLocales, &amp;state, keys[i], desc, true);</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
      }
<span class="line-modified">!     supportedLocales-&gt;defineOwnProperty(supportedLocales, &amp;state, vm.propertyNames-&gt;length, desc, true);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
      return supportedLocales;
  }
  
  Vector&lt;String&gt; numberingSystemsForLocale(const String&amp; locale)
  {
      static NeverDestroyed&lt;Vector&lt;String&gt;&gt; cachedNumberingSystems;
      Vector&lt;String&gt;&amp; availableNumberingSystems = cachedNumberingSystems.get();
  
<span class="line-modified">!     if (UNLIKELY(availableNumberingSystems.isEmpty())) {</span>
<span class="line-modified">!         static Lock cachedNumberingSystemsMutex;</span>
<span class="line-modified">!         std::lock_guard&lt;Lock&gt; lock(cachedNumberingSystemsMutex);</span>
<span class="line-modified">!         if (availableNumberingSystems.isEmpty()) {</span>
<span class="line-modified">!             UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified">!             UEnumeration* numberingSystemNames = unumsys_openAvailableNames(&amp;status);</span>
<span class="line-removed">-             ASSERT(U_SUCCESS(status));</span>
  
<span class="line-modified">!             int32_t resultLength;</span>
<span class="line-modified">!             // Numbering system names are always ASCII, so use char[].</span>
<span class="line-modified">!             while (const char* result = uenum_next(numberingSystemNames, &amp;resultLength, &amp;status)) {</span>
<span class="line-modified">!                 ASSERT(U_SUCCESS(status));</span>
<span class="line-modified">!                 auto numsys = unumsys_openByName(result, &amp;status);</span>
<span class="line-modified">!                 ASSERT(U_SUCCESS(status));</span>
<span class="line-modified">!                 // Only support algorithmic if it is the default fot the locale, handled below.</span>
<span class="line-modified">!                 if (!unumsys_isAlgorithmic(numsys))</span>
<span class="line-modified">!                     availableNumberingSystems.append(String(result, resultLength));</span>
<span class="line-modified">!                 unumsys_close(numsys);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             uenum_close(numberingSystemNames);</span>
          }
<span class="line-modified">!     }</span>
  
      UErrorCode status = U_ZERO_ERROR;
      UNumberingSystem* defaultSystem = unumsys_open(locale.utf8().data(), &amp;status);
      ASSERT(U_SUCCESS(status));
      String defaultSystemName(unumsys_getName(defaultSystem));
<span class="line-new-header">--- 891,112 ---</span>
  
      result.add(&quot;locale&quot;_s, foundLocale);
      return result;
  }
  
<span class="line-modified">! static JSArray* lookupSupportedLocales(JSGlobalObject* globalObject, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)</span>
  {
      // LookupSupportedLocales (availableLocales, requestedLocales)
      // https://tc39.github.io/ecma402/#sec-lookupsupportedlocales
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      size_t len = requestedLocales.size();
      JSArray* subset = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithUndecided), 0);
      if (!subset) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
  
      unsigned index = 0;
      for (size_t k = 0; k &lt; len; ++k) {
          const String&amp; locale = requestedLocales[k];
          String noExtensionsLocale = removeUnicodeLocaleExtension(locale);
          String availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);
          if (!availableLocale.isNull()) {
<span class="line-modified">!             subset-&gt;putDirectIndex(globalObject, index++, jsString(vm, locale));</span>
              RETURN_IF_EXCEPTION(scope, nullptr);
          }
      }
  
      return subset;
  }
  
<span class="line-modified">! static JSArray* bestFitSupportedLocales(JSGlobalObject* globalObject, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)</span>
  {
      // BestFitSupportedLocales (availableLocales, requestedLocales)
      // https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales
  
      // FIXME: Implement something better than lookup.
<span class="line-modified">!     return lookupSupportedLocales(globalObject, availableLocales, requestedLocales);</span>
  }
  
<span class="line-modified">! JSValue supportedLocales(JSGlobalObject* globalObject, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales, JSValue options)</span>
  {
      // SupportedLocales (availableLocales, requestedLocales, options)
      // https://tc39.github.io/ecma402/#sec-supportedlocales
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      String matcher;
  
      if (!options.isUndefined()) {
<span class="line-modified">!         matcher = intlStringOption(globalObject, options, vm.propertyNames-&gt;localeMatcher, { &quot;lookup&quot;, &quot;best fit&quot; }, &quot;localeMatcher must be either \&quot;lookup\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
      } else
          matcher = &quot;best fit&quot;_s;
  
      JSArray* supportedLocales = (matcher == &quot;best fit&quot;)
<span class="line-modified">!         ? bestFitSupportedLocales(globalObject, availableLocales, requestedLocales)</span>
<span class="line-modified">!         : lookupSupportedLocales(globalObject, availableLocales, requestedLocales);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
      PropertyNameArray keys(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
<span class="line-modified">!     supportedLocales-&gt;getOwnPropertyNames(supportedLocales, globalObject, keys, EnumerationMode());</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
      PropertyDescriptor desc;
      desc.setConfigurable(false);
      desc.setWritable(false);
  
      size_t len = keys.size();
      for (size_t i = 0; i &lt; len; ++i) {
<span class="line-modified">!         supportedLocales-&gt;defineOwnProperty(supportedLocales, globalObject, keys[i], desc, true);</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
      }
<span class="line-modified">!     supportedLocales-&gt;defineOwnProperty(supportedLocales, globalObject, vm.propertyNames-&gt;length, desc, true);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
      return supportedLocales;
  }
  
  Vector&lt;String&gt; numberingSystemsForLocale(const String&amp; locale)
  {
      static NeverDestroyed&lt;Vector&lt;String&gt;&gt; cachedNumberingSystems;
      Vector&lt;String&gt;&amp; availableNumberingSystems = cachedNumberingSystems.get();
  
<span class="line-modified">!     static std::once_flag initializeOnce;</span>
<span class="line-modified">!     std::call_once(initializeOnce, [&amp;] {</span>
<span class="line-modified">!         ASSERT(availableNumberingSystems.isEmpty());</span>
<span class="line-modified">!         UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified">!         UEnumeration* numberingSystemNames = unumsys_openAvailableNames(&amp;status);</span>
<span class="line-modified">!         ASSERT(U_SUCCESS(status));</span>
  
<span class="line-modified">!         int32_t resultLength;</span>
<span class="line-modified">!         // Numbering system names are always ASCII, so use char[].</span>
<span class="line-modified">!         while (const char* result = uenum_next(numberingSystemNames, &amp;resultLength, &amp;status)) {</span>
<span class="line-modified">!             ASSERT(U_SUCCESS(status));</span>
<span class="line-modified">!             auto numsys = unumsys_openByName(result, &amp;status);</span>
<span class="line-modified">!             ASSERT(U_SUCCESS(status));</span>
<span class="line-modified">!             // Only support algorithmic if it is the default fot the locale, handled below.</span>
<span class="line-modified">!             if (!unumsys_isAlgorithmic(numsys))</span>
<span class="line-modified">!                 availableNumberingSystems.append(String(StringImpl::createStaticStringImpl(result, resultLength)));</span>
<span class="line-modified">!             unumsys_close(numsys);</span>
          }
<span class="line-modified">!         uenum_close(numberingSystemNames);</span>
<span class="line-added">+     });</span>
  
      UErrorCode status = U_ZERO_ERROR;
      UNumberingSystem* defaultSystem = unumsys_open(locale.utf8().data(), &amp;status);
      ASSERT(U_SUCCESS(status));
      String defaultSystemName(unumsys_getName(defaultSystem));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 915,31 ***</span>
      Vector&lt;String&gt; numberingSystems({ defaultSystemName });
      numberingSystems.appendVector(availableNumberingSystems);
      return numberingSystems;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL intlObjectFuncGetCanonicalLocales(ExecState* state)</span>
  {
      // Intl.getCanonicalLocales(locales)
      // https://tc39.github.io/ecma402/#sec-intl.getcanonicallocales
  
<span class="line-modified">!     VM&amp; vm = state-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Vector&lt;String&gt; localeList = canonicalizeLocaleList(*state, state-&gt;argument(0));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      auto length = localeList.size();
  
<span class="line-removed">-     JSGlobalObject* globalObject = state-&gt;jsCallee()-&gt;globalObject(vm);</span>
      JSArray* localeArray = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), length);
      if (!localeArray) {
<span class="line-modified">!         throwOutOfMemoryError(state, scope);</span>
          return encodedJSValue();
      }
  
      for (size_t i = 0; i &lt; length; ++i) {
<span class="line-modified">!         localeArray-&gt;putDirectIndex(state, i, jsString(vm, localeList[i]));</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
      return JSValue::encode(localeArray);
  }
  
<span class="line-new-header">--- 1005,30 ---</span>
      Vector&lt;String&gt; numberingSystems({ defaultSystemName });
      numberingSystems.appendVector(availableNumberingSystems);
      return numberingSystems;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL intlObjectFuncGetCanonicalLocales(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      // Intl.getCanonicalLocales(locales)
      // https://tc39.github.io/ecma402/#sec-intl.getcanonicallocales
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Vector&lt;String&gt; localeList = canonicalizeLocaleList(globalObject, callFrame-&gt;argument(0));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      auto length = localeList.size();
  
      JSArray* localeArray = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), length);
      if (!localeArray) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return encodedJSValue();
      }
  
      for (size_t i = 0; i &lt; length; ++i) {
<span class="line-modified">!         localeArray-&gt;putDirectIndex(globalObject, i, jsString(vm, localeList[i]));</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
      return JSValue::encode(localeArray);
  }
  
</pre>
<center><a href="IntlNumberFormatPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IntlObject.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
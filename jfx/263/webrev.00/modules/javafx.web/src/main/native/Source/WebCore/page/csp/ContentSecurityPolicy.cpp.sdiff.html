<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/csp/ContentSecurityPolicy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../animation/KeyframeAnimation.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ContentSecurityPolicy.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/csp/ContentSecurityPolicy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 28 #include &quot;ContentSecurityPolicy.h&quot;
 29 
 30 #include &quot;ContentSecurityPolicyClient.h&quot;
 31 #include &quot;ContentSecurityPolicyDirective.h&quot;
 32 #include &quot;ContentSecurityPolicyDirectiveList.h&quot;
 33 #include &quot;ContentSecurityPolicyDirectiveNames.h&quot;
 34 #include &quot;ContentSecurityPolicyHash.h&quot;
 35 #include &quot;ContentSecurityPolicySource.h&quot;
 36 #include &quot;ContentSecurityPolicySourceList.h&quot;
 37 #include &quot;CustomHeaderFields.h&quot;
 38 #include &quot;DOMStringList.h&quot;
 39 #include &quot;Document.h&quot;
 40 #include &quot;DocumentLoader.h&quot;
 41 #include &quot;EventNames.h&quot;
 42 #include &quot;FormData.h&quot;
 43 #include &quot;Frame.h&quot;
 44 #include &quot;HTMLParserIdioms.h&quot;
 45 #include &quot;InspectorInstrumentation.h&quot;
 46 #include &quot;JSExecState.h&quot;
 47 #include &quot;JSWindowProxy.h&quot;

 48 #include &quot;ParsingUtilities.h&quot;
 49 #include &quot;PingLoader.h&quot;
 50 #include &quot;ResourceRequest.h&quot;
<span class="line-removed"> 51 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
<span class="line-removed"> 52 #include &quot;SchemeRegistry.h&quot;</span>
 53 #include &quot;SecurityOrigin.h&quot;
 54 #include &quot;SecurityPolicyViolationEvent.h&quot;
 55 #include &quot;Settings.h&quot;
 56 #include &quot;TextEncoding.h&quot;
 57 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 58 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
 59 #include &lt;pal/crypto/CryptoDigest.h&gt;
 60 #include &lt;wtf/JSONValues.h&gt;
 61 #include &lt;wtf/SetForScope.h&gt;
 62 #include &lt;wtf/text/StringBuilder.h&gt;
 63 #include &lt;wtf/text/TextPosition.h&gt;
 64 
 65 
 66 namespace WebCore {
 67 using namespace Inspector;
 68 
 69 static String consoleMessageForViolation(const char* effectiveViolatedDirective, const ContentSecurityPolicyDirective&amp; violatedDirective, const URL&amp; blockedURL, const char* prefix, const char* subject = &quot;it&quot;)
 70 {
 71     StringBuilder result;
 72     if (violatedDirective.directiveList().isReportOnly())
</pre>
<hr />
<pre>
448 bool ContentSecurityPolicy::allowInlineStyle(const String&amp; contextURL, const WTF::OrdinalNumber&amp; contextLine, const String&amp; styleContent, bool overrideContentSecurityPolicy) const
449 {
450     if (overrideContentSecurityPolicy)
451         return true;
452     if (m_overrideInlineStyleAllowed)
453         return true;
454     auto [foundHashInEnforcedPolicies, foundHashInReportOnlyPolicies] = findHashOfContentInPolicies(&amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForStyleHash, styleContent, m_hashAlgorithmsForInlineStylesheets);
455     if (foundHashInEnforcedPolicies &amp;&amp; foundHashInReportOnlyPolicies)
456         return true;
457     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
458         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::styleSrc, violatedDirective, URL(), &quot;Refused to apply a stylesheet&quot;, &quot;its hash, its nonce, or &#39;unsafe-inline&#39;&quot;);
459         reportViolation(ContentSecurityPolicyDirectiveNames::styleSrc, violatedDirective, URL(), consoleMessage, contextURL, TextPosition(contextLine, WTF::OrdinalNumber()));
460     };
461     // FIXME: We should not report that the inline stylesheet violated a policy when its hash matched a source
462     // expression in the policy and the page has more than one policy. See &lt;https://bugs.webkit.org/show_bug.cgi?id=159832&gt;.
463     if (!foundHashInReportOnlyPolicies)
464         allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::ReportOnly, handleViolatedDirective, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineStyle);
465     return foundHashInEnforcedPolicies || allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::Enforce, handleViolatedDirective, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineStyle);
466 }
467 
<span class="line-modified">468 bool ContentSecurityPolicy::allowEval(JSC::ExecState* state, bool overrideContentSecurityPolicy) const</span>
469 {
470     if (overrideContentSecurityPolicy)
471         return true;
472     bool didNotifyInspector = false;
473     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
474         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), &quot;Refused to execute a script&quot;, &quot;&#39;unsafe-eval&#39;&quot;);
475         reportViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), consoleMessage, state);
476         if (!didNotifyInspector &amp;&amp; !violatedDirective.directiveList().isReportOnly()) {
477             reportBlockedScriptExecutionToInspector(violatedDirective.text());
478             didNotifyInspector = true;
479         }
480     };
481     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeEval);
482 }
483 
484 bool ContentSecurityPolicy::allowFrameAncestors(const Frame&amp; frame, const URL&amp; url, bool overrideContentSecurityPolicy) const
485 {
486     if (overrideContentSecurityPolicy)
487         return true;
488     Frame&amp; topFrame = frame.tree().top();
</pre>
<hr />
<pre>
523         reportViolation(ContentSecurityPolicyDirectiveNames::frameAncestors, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
524     };
525     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFrameAncestorOrigins, ancestorOrigins);
526 }
527 
528 bool ContentSecurityPolicy::allowPluginType(const String&amp; type, const String&amp; typeAttribute, const URL&amp; url, bool overrideContentSecurityPolicy) const
529 {
530     if (overrideContentSecurityPolicy)
531         return true;
532     String sourceURL;
533     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
534     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
535         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::pluginTypes, violatedDirective, url, &quot;Refused to load&quot;, &quot;its MIME type&quot;);
536         reportViolation(ContentSecurityPolicyDirectiveNames::pluginTypes, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
537     };
538     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForPluginType, type, typeAttribute);
539 }
540 
541 bool ContentSecurityPolicy::allowObjectFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
542 {
<span class="line-modified">543     if (SchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))</span>
544         return true;
545     // As per section object-src of the Content Security Policy Level 3 spec., &lt;http://w3c.github.io/webappsec-csp&gt; (Editor&#39;s Draft, 29 February 2016),
546     // &quot;If plugin content is loaded without an associated URL (perhaps an object element lacks a data attribute, but loads some default plugin based
547     // on the specified type), it MUST be blocked if object-src&#39;s value is &#39;none&#39;, but will otherwise be allowed&quot;.
548     String sourceURL;
549     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
550     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
551         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::objectSrc, violatedDirective, url, &quot;Refused to load&quot;);
552         reportViolation(ContentSecurityPolicyDirectiveNames::objectSrc, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
553     };
554     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForObjectSource, url, redirectResponseReceived == RedirectResponseReceived::Yes, ContentSecurityPolicySourceListDirective::ShouldAllowEmptyURLIfSourceListIsNotNone::Yes);
555 }
556 
557 bool ContentSecurityPolicy::allowChildFrameFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
558 {
<span class="line-modified">559     if (SchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))</span>
560         return true;
561     String sourceURL;
562     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
563     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
564         const char* effectiveViolatedDirective = violatedDirective.name() == ContentSecurityPolicyDirectiveNames::frameSrc ? ContentSecurityPolicyDirectiveNames::frameSrc : ContentSecurityPolicyDirectiveNames::childSrc;
565         String consoleMessage = consoleMessageForViolation(effectiveViolatedDirective, violatedDirective, url, &quot;Refused to load&quot;);
566         reportViolation(effectiveViolatedDirective, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
567     };
568     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFrame, url, redirectResponseReceived == RedirectResponseReceived::Yes);
569 }
570 
571 bool ContentSecurityPolicy::allowResourceFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived, const char* name, ResourcePredicate resourcePredicate) const
572 {
<span class="line-modified">573     if (SchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))</span>
574         return true;
575     String sourceURL;
576     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
577     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
578         String consoleMessage = consoleMessageForViolation(name, violatedDirective, url, &quot;Refused to load&quot;);
579         reportViolation(name, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
580     };
581     return allPoliciesAllow(WTFMove(handleViolatedDirective), resourcePredicate, url, redirectResponseReceived == RedirectResponseReceived::Yes);
582 }
583 
584 bool ContentSecurityPolicy::allowChildContextFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
585 {
586     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::childSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForChildContext);
587 }
588 
589 bool ContentSecurityPolicy::allowScriptFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
590 {
591     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::scriptSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForScript);
592 }
593 
</pre>
<hr />
<pre>
603 
604 bool ContentSecurityPolicy::allowFontFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
605 {
606     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::fontSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFont);
607 }
608 
609 #if ENABLE(APPLICATION_MANIFEST)
610 bool ContentSecurityPolicy::allowManifestFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
611 {
612     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::manifestSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForManifest);
613 }
614 #endif // ENABLE(APPLICATION_MANIFEST)
615 
616 bool ContentSecurityPolicy::allowMediaFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
617 {
618     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::mediaSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForMedia);
619 }
620 
621 bool ContentSecurityPolicy::allowConnectToSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
622 {
<span class="line-modified">623     if (SchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))</span>
624         return true;
625     String sourceURL;
626     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
627     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
628         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::connectSrc, violatedDirective, url, &quot;Refused to connect to&quot;);
629         reportViolation(ContentSecurityPolicyDirectiveNames::connectSrc, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
630     };
631     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForConnectSource, url, redirectResponseReceived == RedirectResponseReceived::Yes);
632 }
633 
634 bool ContentSecurityPolicy::allowFormAction(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
635 {
636     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::formAction, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFormAction);
637 }
638 
639 bool ContentSecurityPolicy::allowBaseURI(const URL&amp; url, bool overrideContentSecurityPolicy) const
640 {
641     if (overrideContentSecurityPolicy)
642         return true;
<span class="line-modified">643     if (SchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))</span>
644         return true;
645     String sourceURL;
646     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
647     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
648         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::baseURI, violatedDirective, url, &quot;Refused to change the document base URL to&quot;);
649         reportViolation(ContentSecurityPolicyDirectiveNames::baseURI, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
650     };
651     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForBaseURI, url);
652 }
653 
654 String ContentSecurityPolicy::deprecatedURLForReporting(const URL&amp; url) const
655 {
656     if (!url.isValid())
657         return { };
658     if (!url.isHierarchical() || url.protocolIs(&quot;file&quot;))
659         return url.protocol().toString();
660     return static_cast&lt;SecurityOriginData&gt;(*m_selfSource).securityOrigin()-&gt;canRequest(url) ? url.strippedForUseAsReferrer() : SecurityOrigin::create(url)-&gt;toString();
661 }
662 
<span class="line-modified">663 void ContentSecurityPolicy::reportViolation(const String&amp; violatedDirective, const ContentSecurityPolicyDirective&amp; effectiveViolatedDirective, const URL&amp; blockedURL, const String&amp; consoleMessage, JSC::ExecState* state) const</span>
664 {
665     // FIXME: Extract source file and source position from JSC::ExecState.
666     return reportViolation(violatedDirective, effectiveViolatedDirective.text(), effectiveViolatedDirective.directiveList(), blockedURL, consoleMessage, String(), TextPosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber::beforeFirst()), state);
667 }
668 
<span class="line-modified">669 void ContentSecurityPolicy::reportViolation(const String&amp; effectiveViolatedDirective, const String&amp; violatedDirective, const ContentSecurityPolicyDirectiveList&amp; violatedDirectiveList, const URL&amp; blockedURL, const String&amp; consoleMessage, JSC::ExecState* state) const</span>
670 {
671     // FIXME: Extract source file and source position from JSC::ExecState.
672     return reportViolation(effectiveViolatedDirective, violatedDirective, violatedDirectiveList, blockedURL, consoleMessage, String(), TextPosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber::beforeFirst()), state);
673 }
674 
<span class="line-modified">675 void ContentSecurityPolicy::reportViolation(const String&amp; effectiveViolatedDirective, const ContentSecurityPolicyDirective&amp; violatedDirective, const URL&amp; blockedURL, const String&amp; consoleMessage, const String&amp; sourceURL, const TextPosition&amp; sourcePosition, JSC::ExecState* state) const</span>
676 {
677     return reportViolation(effectiveViolatedDirective, violatedDirective.text(), violatedDirective.directiveList(), blockedURL, consoleMessage, sourceURL, sourcePosition, state);
678 }
679 
<span class="line-modified">680 void ContentSecurityPolicy::reportViolation(const String&amp; effectiveViolatedDirective, const String&amp; violatedDirective, const ContentSecurityPolicyDirectiveList&amp; violatedDirectiveList, const URL&amp; blockedURL, const String&amp; consoleMessage, const String&amp; sourceURL, const TextPosition&amp; sourcePosition, JSC::ExecState* state) const</span>
681 {
682     logToConsole(consoleMessage, sourceURL, sourcePosition.m_line, sourcePosition.m_column, state);
683 
684     if (!m_isReportingEnabled)
685         return;
686 
687     // FIXME: Support sending reports from worker.
688     CSPInfo info;
689     info.documentURI = blockedURL;
690     if (m_client)
691         m_client-&gt;willSendCSPViolationReport(info);
692     else {
693         if (!is&lt;Document&gt;(m_scriptExecutionContext))
694             return;
695 
696         auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
697         auto* frame = document.frame();
698         if (!frame)
699             return;
700 
</pre>
<hr />
<pre>
841     else
842         ignoring = &quot;The fragment identifier, including the &#39;#&#39;, will be ignored.&quot;;
843 
844     String message = makeString(&quot;The source list for Content Security Policy directive &#39;&quot;, directiveName, &quot;&#39; contains a source with an invalid path: &#39;&quot;, value, &quot;&#39;. &quot;, ignoring);
845     logToConsole(message);
846 }
847 
848 void ContentSecurityPolicy::reportInvalidSourceExpression(const String&amp; directiveName, const String&amp; source) const
849 {
850     String message = makeString(&quot;The source list for Content Security Policy directive &#39;&quot;, directiveName, &quot;&#39; contains an invalid source: &#39;&quot;, source, &quot;&#39;. It will be ignored.&quot;);
851     if (equalLettersIgnoringASCIICase(source, &quot;&#39;none&#39;&quot;))
852         message = makeString(message, &quot; Note that &#39;none&#39; has no effect unless it is the only expression in the source list.&quot;);
853     logToConsole(message);
854 }
855 
856 void ContentSecurityPolicy::reportMissingReportURI(const String&amp; policy) const
857 {
858     logToConsole(&quot;The Content Security Policy &#39;&quot; + policy + &quot;&#39; was delivered in report-only mode, but does not specify a &#39;report-uri&#39;; the policy will have no effect. Please either add a &#39;report-uri&#39; directive, or deliver the policy via the &#39;Content-Security-Policy&#39; header.&quot;);
859 }
860 
<span class="line-modified">861 void ContentSecurityPolicy::logToConsole(const String&amp; message, const String&amp; contextURL, const WTF::OrdinalNumber&amp; contextLine, const WTF::OrdinalNumber&amp; contextColumn, JSC::ExecState* state) const</span>
862 {
863     if (!m_isReportingEnabled)
864         return;
865 
866     if (m_client)
867         m_client-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message, 0);
868     else if (m_scriptExecutionContext)
869         m_scriptExecutionContext-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message, contextURL, contextLine.oneBasedInt(), contextColumn.oneBasedInt(), state);
870 }
871 
872 void ContentSecurityPolicy::reportBlockedScriptExecutionToInspector(const String&amp; directiveText) const
873 {
874     if (m_scriptExecutionContext)
875         InspectorInstrumentation::scriptExecutionBlockedByCSP(m_scriptExecutionContext, directiveText);
876 }
877 
878 void ContentSecurityPolicy::upgradeInsecureRequestIfNeeded(ResourceRequest&amp; request, InsecureRequestType requestType) const
879 {
880     URL url = request.url();
881     upgradeInsecureRequestIfNeeded(url, requestType);
</pre>
</td>
<td>
<hr />
<pre>
 28 #include &quot;ContentSecurityPolicy.h&quot;
 29 
 30 #include &quot;ContentSecurityPolicyClient.h&quot;
 31 #include &quot;ContentSecurityPolicyDirective.h&quot;
 32 #include &quot;ContentSecurityPolicyDirectiveList.h&quot;
 33 #include &quot;ContentSecurityPolicyDirectiveNames.h&quot;
 34 #include &quot;ContentSecurityPolicyHash.h&quot;
 35 #include &quot;ContentSecurityPolicySource.h&quot;
 36 #include &quot;ContentSecurityPolicySourceList.h&quot;
 37 #include &quot;CustomHeaderFields.h&quot;
 38 #include &quot;DOMStringList.h&quot;
 39 #include &quot;Document.h&quot;
 40 #include &quot;DocumentLoader.h&quot;
 41 #include &quot;EventNames.h&quot;
 42 #include &quot;FormData.h&quot;
 43 #include &quot;Frame.h&quot;
 44 #include &quot;HTMLParserIdioms.h&quot;
 45 #include &quot;InspectorInstrumentation.h&quot;
 46 #include &quot;JSExecState.h&quot;
 47 #include &quot;JSWindowProxy.h&quot;
<span class="line-added"> 48 #include &quot;LegacySchemeRegistry.h&quot;</span>
 49 #include &quot;ParsingUtilities.h&quot;
 50 #include &quot;PingLoader.h&quot;
 51 #include &quot;ResourceRequest.h&quot;


 52 #include &quot;SecurityOrigin.h&quot;
 53 #include &quot;SecurityPolicyViolationEvent.h&quot;
 54 #include &quot;Settings.h&quot;
 55 #include &quot;TextEncoding.h&quot;
 56 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 57 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
 58 #include &lt;pal/crypto/CryptoDigest.h&gt;
 59 #include &lt;wtf/JSONValues.h&gt;
 60 #include &lt;wtf/SetForScope.h&gt;
 61 #include &lt;wtf/text/StringBuilder.h&gt;
 62 #include &lt;wtf/text/TextPosition.h&gt;
 63 
 64 
 65 namespace WebCore {
 66 using namespace Inspector;
 67 
 68 static String consoleMessageForViolation(const char* effectiveViolatedDirective, const ContentSecurityPolicyDirective&amp; violatedDirective, const URL&amp; blockedURL, const char* prefix, const char* subject = &quot;it&quot;)
 69 {
 70     StringBuilder result;
 71     if (violatedDirective.directiveList().isReportOnly())
</pre>
<hr />
<pre>
447 bool ContentSecurityPolicy::allowInlineStyle(const String&amp; contextURL, const WTF::OrdinalNumber&amp; contextLine, const String&amp; styleContent, bool overrideContentSecurityPolicy) const
448 {
449     if (overrideContentSecurityPolicy)
450         return true;
451     if (m_overrideInlineStyleAllowed)
452         return true;
453     auto [foundHashInEnforcedPolicies, foundHashInReportOnlyPolicies] = findHashOfContentInPolicies(&amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForStyleHash, styleContent, m_hashAlgorithmsForInlineStylesheets);
454     if (foundHashInEnforcedPolicies &amp;&amp; foundHashInReportOnlyPolicies)
455         return true;
456     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
457         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::styleSrc, violatedDirective, URL(), &quot;Refused to apply a stylesheet&quot;, &quot;its hash, its nonce, or &#39;unsafe-inline&#39;&quot;);
458         reportViolation(ContentSecurityPolicyDirectiveNames::styleSrc, violatedDirective, URL(), consoleMessage, contextURL, TextPosition(contextLine, WTF::OrdinalNumber()));
459     };
460     // FIXME: We should not report that the inline stylesheet violated a policy when its hash matched a source
461     // expression in the policy and the page has more than one policy. See &lt;https://bugs.webkit.org/show_bug.cgi?id=159832&gt;.
462     if (!foundHashInReportOnlyPolicies)
463         allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::ReportOnly, handleViolatedDirective, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineStyle);
464     return foundHashInEnforcedPolicies || allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::Enforce, handleViolatedDirective, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineStyle);
465 }
466 
<span class="line-modified">467 bool ContentSecurityPolicy::allowEval(JSC::JSGlobalObject* state, bool overrideContentSecurityPolicy) const</span>
468 {
469     if (overrideContentSecurityPolicy)
470         return true;
471     bool didNotifyInspector = false;
472     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
473         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), &quot;Refused to execute a script&quot;, &quot;&#39;unsafe-eval&#39;&quot;);
474         reportViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), consoleMessage, state);
475         if (!didNotifyInspector &amp;&amp; !violatedDirective.directiveList().isReportOnly()) {
476             reportBlockedScriptExecutionToInspector(violatedDirective.text());
477             didNotifyInspector = true;
478         }
479     };
480     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeEval);
481 }
482 
483 bool ContentSecurityPolicy::allowFrameAncestors(const Frame&amp; frame, const URL&amp; url, bool overrideContentSecurityPolicy) const
484 {
485     if (overrideContentSecurityPolicy)
486         return true;
487     Frame&amp; topFrame = frame.tree().top();
</pre>
<hr />
<pre>
522         reportViolation(ContentSecurityPolicyDirectiveNames::frameAncestors, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
523     };
524     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFrameAncestorOrigins, ancestorOrigins);
525 }
526 
527 bool ContentSecurityPolicy::allowPluginType(const String&amp; type, const String&amp; typeAttribute, const URL&amp; url, bool overrideContentSecurityPolicy) const
528 {
529     if (overrideContentSecurityPolicy)
530         return true;
531     String sourceURL;
532     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
533     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
534         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::pluginTypes, violatedDirective, url, &quot;Refused to load&quot;, &quot;its MIME type&quot;);
535         reportViolation(ContentSecurityPolicyDirectiveNames::pluginTypes, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
536     };
537     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForPluginType, type, typeAttribute);
538 }
539 
540 bool ContentSecurityPolicy::allowObjectFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
541 {
<span class="line-modified">542     if (LegacySchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))</span>
543         return true;
544     // As per section object-src of the Content Security Policy Level 3 spec., &lt;http://w3c.github.io/webappsec-csp&gt; (Editor&#39;s Draft, 29 February 2016),
545     // &quot;If plugin content is loaded without an associated URL (perhaps an object element lacks a data attribute, but loads some default plugin based
546     // on the specified type), it MUST be blocked if object-src&#39;s value is &#39;none&#39;, but will otherwise be allowed&quot;.
547     String sourceURL;
548     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
549     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
550         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::objectSrc, violatedDirective, url, &quot;Refused to load&quot;);
551         reportViolation(ContentSecurityPolicyDirectiveNames::objectSrc, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
552     };
553     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForObjectSource, url, redirectResponseReceived == RedirectResponseReceived::Yes, ContentSecurityPolicySourceListDirective::ShouldAllowEmptyURLIfSourceListIsNotNone::Yes);
554 }
555 
556 bool ContentSecurityPolicy::allowChildFrameFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
557 {
<span class="line-modified">558     if (LegacySchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))</span>
559         return true;
560     String sourceURL;
561     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
562     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
563         const char* effectiveViolatedDirective = violatedDirective.name() == ContentSecurityPolicyDirectiveNames::frameSrc ? ContentSecurityPolicyDirectiveNames::frameSrc : ContentSecurityPolicyDirectiveNames::childSrc;
564         String consoleMessage = consoleMessageForViolation(effectiveViolatedDirective, violatedDirective, url, &quot;Refused to load&quot;);
565         reportViolation(effectiveViolatedDirective, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
566     };
567     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFrame, url, redirectResponseReceived == RedirectResponseReceived::Yes);
568 }
569 
570 bool ContentSecurityPolicy::allowResourceFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived, const char* name, ResourcePredicate resourcePredicate) const
571 {
<span class="line-modified">572     if (LegacySchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))</span>
573         return true;
574     String sourceURL;
575     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
576     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
577         String consoleMessage = consoleMessageForViolation(name, violatedDirective, url, &quot;Refused to load&quot;);
578         reportViolation(name, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
579     };
580     return allPoliciesAllow(WTFMove(handleViolatedDirective), resourcePredicate, url, redirectResponseReceived == RedirectResponseReceived::Yes);
581 }
582 
583 bool ContentSecurityPolicy::allowChildContextFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
584 {
585     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::childSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForChildContext);
586 }
587 
588 bool ContentSecurityPolicy::allowScriptFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
589 {
590     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::scriptSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForScript);
591 }
592 
</pre>
<hr />
<pre>
602 
603 bool ContentSecurityPolicy::allowFontFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
604 {
605     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::fontSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFont);
606 }
607 
608 #if ENABLE(APPLICATION_MANIFEST)
609 bool ContentSecurityPolicy::allowManifestFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
610 {
611     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::manifestSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForManifest);
612 }
613 #endif // ENABLE(APPLICATION_MANIFEST)
614 
615 bool ContentSecurityPolicy::allowMediaFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
616 {
617     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::mediaSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForMedia);
618 }
619 
620 bool ContentSecurityPolicy::allowConnectToSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
621 {
<span class="line-modified">622     if (LegacySchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))</span>
623         return true;
624     String sourceURL;
625     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
626     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
627         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::connectSrc, violatedDirective, url, &quot;Refused to connect to&quot;);
628         reportViolation(ContentSecurityPolicyDirectiveNames::connectSrc, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
629     };
630     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForConnectSource, url, redirectResponseReceived == RedirectResponseReceived::Yes);
631 }
632 
633 bool ContentSecurityPolicy::allowFormAction(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
634 {
635     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::formAction, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFormAction);
636 }
637 
638 bool ContentSecurityPolicy::allowBaseURI(const URL&amp; url, bool overrideContentSecurityPolicy) const
639 {
640     if (overrideContentSecurityPolicy)
641         return true;
<span class="line-modified">642     if (LegacySchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))</span>
643         return true;
644     String sourceURL;
645     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
646     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
647         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::baseURI, violatedDirective, url, &quot;Refused to change the document base URL to&quot;);
648         reportViolation(ContentSecurityPolicyDirectiveNames::baseURI, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
649     };
650     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForBaseURI, url);
651 }
652 
653 String ContentSecurityPolicy::deprecatedURLForReporting(const URL&amp; url) const
654 {
655     if (!url.isValid())
656         return { };
657     if (!url.isHierarchical() || url.protocolIs(&quot;file&quot;))
658         return url.protocol().toString();
659     return static_cast&lt;SecurityOriginData&gt;(*m_selfSource).securityOrigin()-&gt;canRequest(url) ? url.strippedForUseAsReferrer() : SecurityOrigin::create(url)-&gt;toString();
660 }
661 
<span class="line-modified">662 void ContentSecurityPolicy::reportViolation(const String&amp; violatedDirective, const ContentSecurityPolicyDirective&amp; effectiveViolatedDirective, const URL&amp; blockedURL, const String&amp; consoleMessage, JSC::JSGlobalObject* state) const</span>
663 {
664     // FIXME: Extract source file and source position from JSC::ExecState.
665     return reportViolation(violatedDirective, effectiveViolatedDirective.text(), effectiveViolatedDirective.directiveList(), blockedURL, consoleMessage, String(), TextPosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber::beforeFirst()), state);
666 }
667 
<span class="line-modified">668 void ContentSecurityPolicy::reportViolation(const String&amp; effectiveViolatedDirective, const String&amp; violatedDirective, const ContentSecurityPolicyDirectiveList&amp; violatedDirectiveList, const URL&amp; blockedURL, const String&amp; consoleMessage, JSC::JSGlobalObject* state) const</span>
669 {
670     // FIXME: Extract source file and source position from JSC::ExecState.
671     return reportViolation(effectiveViolatedDirective, violatedDirective, violatedDirectiveList, blockedURL, consoleMessage, String(), TextPosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber::beforeFirst()), state);
672 }
673 
<span class="line-modified">674 void ContentSecurityPolicy::reportViolation(const String&amp; effectiveViolatedDirective, const ContentSecurityPolicyDirective&amp; violatedDirective, const URL&amp; blockedURL, const String&amp; consoleMessage, const String&amp; sourceURL, const TextPosition&amp; sourcePosition, JSC::JSGlobalObject* state) const</span>
675 {
676     return reportViolation(effectiveViolatedDirective, violatedDirective.text(), violatedDirective.directiveList(), blockedURL, consoleMessage, sourceURL, sourcePosition, state);
677 }
678 
<span class="line-modified">679 void ContentSecurityPolicy::reportViolation(const String&amp; effectiveViolatedDirective, const String&amp; violatedDirective, const ContentSecurityPolicyDirectiveList&amp; violatedDirectiveList, const URL&amp; blockedURL, const String&amp; consoleMessage, const String&amp; sourceURL, const TextPosition&amp; sourcePosition, JSC::JSGlobalObject* state) const</span>
680 {
681     logToConsole(consoleMessage, sourceURL, sourcePosition.m_line, sourcePosition.m_column, state);
682 
683     if (!m_isReportingEnabled)
684         return;
685 
686     // FIXME: Support sending reports from worker.
687     CSPInfo info;
688     info.documentURI = blockedURL;
689     if (m_client)
690         m_client-&gt;willSendCSPViolationReport(info);
691     else {
692         if (!is&lt;Document&gt;(m_scriptExecutionContext))
693             return;
694 
695         auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
696         auto* frame = document.frame();
697         if (!frame)
698             return;
699 
</pre>
<hr />
<pre>
840     else
841         ignoring = &quot;The fragment identifier, including the &#39;#&#39;, will be ignored.&quot;;
842 
843     String message = makeString(&quot;The source list for Content Security Policy directive &#39;&quot;, directiveName, &quot;&#39; contains a source with an invalid path: &#39;&quot;, value, &quot;&#39;. &quot;, ignoring);
844     logToConsole(message);
845 }
846 
847 void ContentSecurityPolicy::reportInvalidSourceExpression(const String&amp; directiveName, const String&amp; source) const
848 {
849     String message = makeString(&quot;The source list for Content Security Policy directive &#39;&quot;, directiveName, &quot;&#39; contains an invalid source: &#39;&quot;, source, &quot;&#39;. It will be ignored.&quot;);
850     if (equalLettersIgnoringASCIICase(source, &quot;&#39;none&#39;&quot;))
851         message = makeString(message, &quot; Note that &#39;none&#39; has no effect unless it is the only expression in the source list.&quot;);
852     logToConsole(message);
853 }
854 
855 void ContentSecurityPolicy::reportMissingReportURI(const String&amp; policy) const
856 {
857     logToConsole(&quot;The Content Security Policy &#39;&quot; + policy + &quot;&#39; was delivered in report-only mode, but does not specify a &#39;report-uri&#39;; the policy will have no effect. Please either add a &#39;report-uri&#39; directive, or deliver the policy via the &#39;Content-Security-Policy&#39; header.&quot;);
858 }
859 
<span class="line-modified">860 void ContentSecurityPolicy::logToConsole(const String&amp; message, const String&amp; contextURL, const WTF::OrdinalNumber&amp; contextLine, const WTF::OrdinalNumber&amp; contextColumn, JSC::JSGlobalObject* state) const</span>
861 {
862     if (!m_isReportingEnabled)
863         return;
864 
865     if (m_client)
866         m_client-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message, 0);
867     else if (m_scriptExecutionContext)
868         m_scriptExecutionContext-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message, contextURL, contextLine.oneBasedInt(), contextColumn.oneBasedInt(), state);
869 }
870 
871 void ContentSecurityPolicy::reportBlockedScriptExecutionToInspector(const String&amp; directiveText) const
872 {
873     if (m_scriptExecutionContext)
874         InspectorInstrumentation::scriptExecutionBlockedByCSP(m_scriptExecutionContext, directiveText);
875 }
876 
877 void ContentSecurityPolicy::upgradeInsecureRequestIfNeeded(ResourceRequest&amp; request, InsecureRequestType requestType) const
878 {
879     URL url = request.url();
880     upgradeInsecureRequestIfNeeded(url, requestType);
</pre>
</td>
</tr>
</table>
<center><a href="../animation/KeyframeAnimation.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ContentSecurityPolicy.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
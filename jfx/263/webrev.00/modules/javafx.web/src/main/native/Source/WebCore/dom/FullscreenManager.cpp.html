<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/dom/FullscreenManager.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FullscreenManager.h&quot;
 28 
 29 #if ENABLE(FULLSCREEN_API)
 30 
 31 #include &quot;Chrome.h&quot;
 32 #include &quot;ChromeClient.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;Frame.h&quot;
 35 #include &quot;HTMLIFrameElement.h&quot;
 36 #include &quot;HTMLMediaElement.h&quot;
 37 #include &quot;Page.h&quot;
 38 #include &quot;QualifiedName.h&quot;
 39 #include &quot;RenderFullScreen.h&quot;
 40 #include &quot;RenderTreeBuilder.h&quot;
 41 #include &quot;Settings.h&quot;
 42 
 43 namespace WebCore {
 44 
 45 using namespace HTMLNames;
 46 
 47 FullscreenManager::FullscreenManager(Document&amp; document)
 48     : m_document { document }
 49 {
 50 }
 51 
 52 FullscreenManager::~FullscreenManager() = default;
 53 
 54 void FullscreenManager::requestFullscreenForElement(Element* element, FullscreenCheckType checkType)
 55 {
 56     if (!element)
 57         element = documentElement();
 58 
 59     auto failedPreflights = [this](auto element) mutable {
 60         m_fullscreenErrorEventTargetQueue.append(WTFMove(element));
 61         m_fullscreenTaskQueue.enqueueTask([this] {
 62             dispatchFullscreenChangeEvents();
 63         });
 64     };
 65 
 66     // 1. If any of the following conditions are true, terminate these steps and queue a task to fire
 67     // an event named fullscreenerror with its bubbles attribute set to true on the context object&#39;s
 68     // node document:
 69 
 70     // This algorithm is not allowed to show a pop-up:
 71     //   An algorithm is allowed to show a pop-up if, in the task in which the algorithm is running, either:
 72     //   - an activation behavior is currently being processed whose click event was trusted, or
 73     //   - the event listener for a trusted click event is being handled.
 74     if (!UserGestureIndicator::processingUserGesture()) {
 75         failedPreflights(WTFMove(element));
 76         return;
 77     }
 78 
 79     // We do not allow pressing the Escape key as a user gesture to enter fullscreen since this is the key
 80     // to exit fullscreen.
 81     if (UserGestureIndicator::currentUserGesture()-&gt;gestureType() == UserGestureType::EscapeKey) {
 82         document().addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;The Escape key may not be used as a user gesture to enter fullscreen&quot;_s);
 83         failedPreflights(WTFMove(element));
 84         return;
 85     }
 86 
 87     // There is a previously-established user preference, security risk, or platform limitation.
 88     if (!page() || !page()-&gt;settings().fullScreenEnabled()) {
 89         failedPreflights(WTFMove(element));
 90         return;
 91     }
 92 
 93     bool hasKeyboardAccess = true;
 94     if (!page()-&gt;chrome().client().supportsFullScreenForElement(*element, hasKeyboardAccess)) {
 95         // The new full screen API does not accept a &quot;flags&quot; parameter, so fall back to disallowing
 96         // keyboard input if the chrome client refuses to allow keyboard input.
 97         hasKeyboardAccess = false;
 98 
 99         if (!page()-&gt;chrome().client().supportsFullScreenForElement(*element, hasKeyboardAccess)) {
100             failedPreflights(WTFMove(element));
101             return;
102         }
103     }
104 
105     m_pendingFullscreenElement = element;
106 
107     m_fullscreenTaskQueue.enqueueTask([this, element = makeRefPtr(element), checkType, hasKeyboardAccess, failedPreflights] () mutable {
108         // Don&#39;t allow fullscreen if it has been cancelled or a different fullscreen element
109         // has requested fullscreen.
110         if (m_pendingFullscreenElement != element) {
111             failedPreflights(WTFMove(element));
112             return;
113         }
114 
115         // Don&#39;t allow fullscreen if document is hidden.
116         if (document().hidden()) {
117             failedPreflights(WTFMove(element));
118             return;
119         }
120 
121         // The context object is not in a document.
122         if (!element-&gt;isConnected()) {
123             failedPreflights(WTFMove(element));
124             return;
125         }
126 
127         // The context object&#39;s node document, or an ancestor browsing context&#39;s document does not have
128         // the fullscreen enabled flag set.
129         if (checkType == EnforceIFrameAllowFullscreenRequirement &amp;&amp; !isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::Fullscreen, document())) {
130             failedPreflights(WTFMove(element));
131             return;
132         }
133 
134         // The context object&#39;s node document fullscreen element stack is not empty and its top element
135         // is not an ancestor of the context object.
136         if (!m_fullscreenElementStack.isEmpty() &amp;&amp; !m_fullscreenElementStack.last()-&gt;contains(element.get())) {
137             failedPreflights(WTFMove(element));
138             return;
139         }
140 
141         // A descendant browsing context&#39;s document has a non-empty fullscreen element stack.
142         bool descendentHasNonEmptyStack = false;
143         for (Frame* descendant = frame() ? frame()-&gt;tree().traverseNext() : nullptr; descendant; descendant = descendant-&gt;tree().traverseNext()) {
144             if (descendant-&gt;document()-&gt;fullscreenManager().fullscreenElement()) {
145                 descendentHasNonEmptyStack = true;
146                 break;
147             }
148         }
149         if (descendentHasNonEmptyStack) {
150             failedPreflights(WTFMove(element));
151             return;
152         }
153 
154         // 2. Let doc be element&#39;s node document. (i.e. &quot;this&quot;)
155         Document* currentDoc = &amp;document();
156 
157         // 3. Let docs be all doc&#39;s ancestor browsing context&#39;s documents (if any) and doc.
158         Deque&lt;Document*&gt; docs;
159 
160         do {
161             docs.prepend(currentDoc);
162             currentDoc = currentDoc-&gt;ownerElement() ? &amp;currentDoc-&gt;ownerElement()-&gt;document() : nullptr;
163         } while (currentDoc);
164 
165         // 4. For each document in docs, run these substeps:
166         Deque&lt;Document*&gt;::iterator current = docs.begin(), following = docs.begin();
167 
168         do {
169             ++following;
170 
171             // 1. Let following document be the document after document in docs, or null if there is no
172             // such document.
173             Document* currentDoc = *current;
174             Document* followingDoc = following != docs.end() ? *following : nullptr;
175 
176             // 2. If following document is null, push context object on document&#39;s fullscreen element
177             // stack, and queue a task to fire an event named fullscreenchange with its bubbles attribute
178             // set to true on the document.
179             if (!followingDoc) {
180                 currentDoc-&gt;fullscreenManager().pushFullscreenElementStack(*element);
181                 addDocumentToFullscreenChangeEventQueue(*currentDoc);
182                 continue;
183             }
184 
185             // 3. Otherwise, if document&#39;s fullscreen element stack is either empty or its top element
186             // is not following document&#39;s browsing context container,
187             Element* topElement = currentDoc-&gt;fullscreenManager().fullscreenElement();
188             if (!topElement || topElement != followingDoc-&gt;ownerElement()) {
189                 // ...push following document&#39;s browsing context container on document&#39;s fullscreen element
190                 // stack, and queue a task to fire an event named fullscreenchange with its bubbles attribute
191                 // set to true on document.
192                 currentDoc-&gt;fullscreenManager().pushFullscreenElementStack(*followingDoc-&gt;ownerElement());
193                 addDocumentToFullscreenChangeEventQueue(*currentDoc);
194                 continue;
195             }
196 
197             // 4. Otherwise, do nothing for this document. It stays the same.
198         } while (++current != docs.end());
199 
200         // 5. Return, and run the remaining steps asynchronously.
201         // 6. Optionally, perform some animation.
202         m_areKeysEnabledInFullscreen = hasKeyboardAccess;
203         m_fullscreenTaskQueue.enqueueTask([this, element = WTFMove(element), failedPreflights = WTFMove(failedPreflights)] () mutable {
204             auto page = this-&gt;page();
205             if (!page || document().hidden() || m_pendingFullscreenElement != element || !element-&gt;isConnected()) {
206                 failedPreflights(element);
207                 return;
208             }
209             page-&gt;chrome().client().enterFullScreenForElement(*element.get());
210         });
211 
212         // 7. Optionally, display a message indicating how the user can exit displaying the context object fullscreen.
213     });
214 }
215 
216 void FullscreenManager::cancelFullscreen()
217 {
218     // The Mozilla &quot;cancelFullscreen()&quot; API behaves like the W3C &quot;fully exit fullscreen&quot; behavior, which
219     // is defined as:
220     // &quot;To fully exit fullscreen act as if the exitFullscreen() method was invoked on the top-level browsing
221     // context&#39;s document and subsequently empty that document&#39;s fullscreen element stack.&quot;
222     Document&amp; topDocument = document().topDocument();
223     if (!topDocument.fullscreenManager().fullscreenElement()) {
224         // If there is a pending fullscreen element but no top document fullscreen element,
225         // there is a pending task in enterFullscreen(). Cause it to cancel and fire an error
226         // by clearing the pending fullscreen element.
227         m_pendingFullscreenElement = nullptr;
228         return;
229     }
230 
231     // To achieve that aim, remove all the elements from the top document&#39;s stack except for the first before
232     // calling webkitExitFullscreen():
233     Vector&lt;RefPtr&lt;Element&gt;&gt; replacementFullscreenElementStack;
234     replacementFullscreenElementStack.append(topDocument.fullscreenManager().fullscreenElement());
235     topDocument.fullscreenManager().m_fullscreenElementStack.swap(replacementFullscreenElementStack);
236 
237     topDocument.fullscreenManager().exitFullscreen();
238 }
239 
240 void FullscreenManager::exitFullscreen()
241 {
242     // The exitFullscreen() method must run these steps:
243 
244     // 1. Let doc be the context object. (i.e. &quot;this&quot;)
245     Document* currentDoc = &amp;document();
246 
247     // 2. If doc&#39;s fullscreen element stack is empty, terminate these steps.
248     if (m_fullscreenElementStack.isEmpty()) {
249         // If there is a pending fullscreen element but an empty fullscreen element stack,
250         // there is a pending task in requestFullscreenForElement(). Cause it to cancel and fire an error
251         // by clearing the pending fullscreen element.
252         m_pendingFullscreenElement = nullptr;
253         return;
254     }
255 
256     // 3. Let descendants be all the doc&#39;s descendant browsing context&#39;s documents with a non-empty fullscreen
257     // element stack (if any), ordered so that the child of the doc is last and the document furthest
258     // away from the doc is first.
259     Deque&lt;RefPtr&lt;Document&gt;&gt; descendants;
260     for (Frame* descendant = frame() ? frame()-&gt;tree().traverseNext() : nullptr; descendant; descendant = descendant-&gt;tree().traverseNext()) {
261         if (descendant-&gt;document()-&gt;fullscreenManager().fullscreenElement())
262             descendants.prepend(descendant-&gt;document());
263     }
264 
265     // 4. For each descendant in descendants, empty descendant&#39;s fullscreen element stack, and queue a
266     // task to fire an event named fullscreenchange with its bubbles attribute set to true on descendant.
267     for (auto&amp; document : descendants) {
268         document-&gt;fullscreenManager().clearFullscreenElementStack();
269         addDocumentToFullscreenChangeEventQueue(*document);
270     }
271 
272     // 5. While doc is not null, run these substeps:
273     Element* newTop = nullptr;
274     while (currentDoc) {
275         // 1. Pop the top element of doc&#39;s fullscreen element stack.
276         currentDoc-&gt;fullscreenManager().popFullscreenElementStack();
277 
278         //    If doc&#39;s fullscreen element stack is non-empty and the element now at the top is either
279         //    not in a document or its node document is not doc, repeat this substep.
280         newTop = currentDoc-&gt;fullscreenManager().fullscreenElement();
281         if (newTop &amp;&amp; (!newTop-&gt;isConnected() || &amp;newTop-&gt;document() != currentDoc))
282             continue;
283 
284         // 2. Queue a task to fire an event named fullscreenchange with its bubbles attribute set to true
285         // on doc.
286         addDocumentToFullscreenChangeEventQueue(*currentDoc);
287 
288         // 3. If doc&#39;s fullscreen element stack is empty and doc&#39;s browsing context has a browsing context
289         // container, set doc to that browsing context container&#39;s node document.
290         if (!newTop &amp;&amp; currentDoc-&gt;ownerElement()) {
291             currentDoc = &amp;currentDoc-&gt;ownerElement()-&gt;document();
292             continue;
293         }
294 
295         // 4. Otherwise, set doc to null.
296         currentDoc = nullptr;
297     }
298 
299     // 6. Return, and run the remaining steps asynchronously.
300     // 7. Optionally, perform some animation.
301     m_fullscreenTaskQueue.enqueueTask([this, newTop = makeRefPtr(newTop), fullscreenElement = m_fullscreenElement] {
302         auto* page = this-&gt;page();
303         if (!page)
304             return;
305 
306         // If there is a pending fullscreen element but no fullscreen element
307         // there is a pending task in requestFullscreenForElement(). Cause it to cancel and fire an error
308         // by clearing the pending fullscreen element.
309         if (!fullscreenElement &amp;&amp; m_pendingFullscreenElement) {
310             m_pendingFullscreenElement = nullptr;
311             return;
312         }
313 
314         // Only exit out of full screen window mode if there are no remaining elements in the
315         // full screen stack.
316         if (!newTop) {
317             page-&gt;chrome().client().exitFullScreenForElement(fullscreenElement.get());
318             return;
319         }
320 
321         // Otherwise, notify the chrome of the new full screen element.
322         page-&gt;chrome().client().enterFullScreenForElement(*newTop);
323     });
324 }
325 
326 bool FullscreenManager::isFullscreenEnabled() const
327 {
328     // 4. The fullscreenEnabled attribute must return true if the context object and all ancestor
329     // browsing context&#39;s documents have their fullscreen enabled flag set, or false otherwise.
330 
331     // Top-level browsing contexts are implied to have their allowFullscreen attribute set.
332     return isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::Fullscreen, document());
333 }
334 
335 static void unwrapFullscreenRenderer(RenderFullScreen* fullscreenRenderer, Element* fullscreenElement)
336 {
337     if (!fullscreenRenderer)
338         return;
339     bool requiresRenderTreeRebuild;
340     fullscreenRenderer-&gt;unwrapRenderer(requiresRenderTreeRebuild);
341 
342     if (requiresRenderTreeRebuild &amp;&amp; fullscreenElement &amp;&amp; fullscreenElement-&gt;parentElement())
343         fullscreenElement-&gt;parentElement()-&gt;invalidateStyleAndRenderersForSubtree();
344 }
345 
346 void FullscreenManager::willEnterFullscreen(Element&amp; element)
347 {
348     if (!document().hasLivingRenderTree() || document().backForwardCacheState() != Document::NotInBackForwardCache)
349         return;
350 
351     // Protect against being called after the document has been removed from the page.
352     if (!page())
353         return;
354 
355     // If pending fullscreen element is unset or another element&#39;s was requested,
356     // issue a cancel fullscreen request to the client
357     if (m_pendingFullscreenElement != &amp;element) {
358         page()-&gt;chrome().client().exitFullScreenForElement(&amp;element);
359         return;
360     }
361 
362     ASSERT(page()-&gt;settings().fullScreenEnabled());
363 
364     unwrapFullscreenRenderer(m_fullscreenRenderer.get(), m_fullscreenElement.get());
365 
366     element.willBecomeFullscreenElement();
367 
368     ASSERT(&amp;element == m_pendingFullscreenElement);
369     m_pendingFullscreenElement = nullptr;
370     m_fullscreenElement = &amp;element;
371 
372 #if USE(NATIVE_FULLSCREEN_VIDEO)
373     if (is&lt;HTMLMediaElement&gt;(element))
374         return;
375 #endif
376 
377     // Create a placeholder block for a the full-screen element, to keep the page from reflowing
378     // when the element is removed from the normal flow. Only do this for a RenderBox, as only
379     // a box will have a frameRect. The placeholder will be created in setFullscreenRenderer()
380     // during layout.
381     auto renderer = m_fullscreenElement-&gt;renderer();
382     bool shouldCreatePlaceholder = is&lt;RenderBox&gt;(renderer);
383     if (shouldCreatePlaceholder) {
384         m_savedPlaceholderFrameRect = downcast&lt;RenderBox&gt;(*renderer).frameRect();
385         m_savedPlaceholderRenderStyle = RenderStyle::clonePtr(renderer-&gt;style());
386     }
387 
388     if (m_fullscreenElement != documentElement() &amp;&amp; renderer)
389         RenderFullScreen::wrapExistingRenderer(*renderer, document());
390 
391     m_fullscreenElement-&gt;setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(true);
392 
393     document().resolveStyle(Document::ResolveStyleType::Rebuild);
394     dispatchFullscreenChangeEvents();
395 }
396 
397 void FullscreenManager::didEnterFullscreen()
398 {
399     if (!m_fullscreenElement)
400         return;
401 
402     if (!hasLivingRenderTree() || backForwardCacheState() != Document::NotInBackForwardCache)
403         return;
404 
405     m_fullscreenElement-&gt;didBecomeFullscreenElement();
406 }
407 
408 void FullscreenManager::willExitFullscreen()
409 {
410     auto fullscreenElement = fullscreenOrPendingElement();
411     if (!fullscreenElement)
412         return;
413 
414     if (!hasLivingRenderTree() || backForwardCacheState() != Document::NotInBackForwardCache)
415         return;
416 
417     fullscreenElement-&gt;willStopBeingFullscreenElement();
418 }
419 
420 void FullscreenManager::didExitFullscreen()
421 {
422     auto fullscreenElement = fullscreenOrPendingElement();
423     if (!fullscreenElement)
424         return;
425 
426     if (!hasLivingRenderTree() || backForwardCacheState() != Document::NotInBackForwardCache)
427         return;
428     fullscreenElement-&gt;setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(false);
429 
430     m_areKeysEnabledInFullscreen = false;
431 
432     unwrapFullscreenRenderer(m_fullscreenRenderer.get(), m_fullscreenElement.get());
433 
434     m_fullscreenElement = nullptr;
435     m_pendingFullscreenElement = nullptr;
436     scheduleFullStyleRebuild();
437 
438     // When webkitCancelFullscreen is called, we call webkitExitFullscreen on the topDocument(). That
439     // means that the events will be queued there. So if we have no events here, start the timer on
440     // the exiting document.
441     bool eventTargetQueuesEmpty = m_fullscreenChangeEventTargetQueue.isEmpty() &amp;&amp; m_fullscreenErrorEventTargetQueue.isEmpty();
442     Document&amp; exitingDocument = eventTargetQueuesEmpty ? topDocument() : document();
443 
444     exitingDocument.fullscreenManager().dispatchFullscreenChangeEvents();
445 }
446 
447 void FullscreenManager::setFullscreenRenderer(RenderTreeBuilder&amp; builder, RenderFullScreen&amp; renderer)
448 {
449     if (&amp;renderer == m_fullscreenRenderer)
450         return;
451 
452     if (m_savedPlaceholderRenderStyle)
453         builder.createPlaceholderForFullScreen(renderer, WTFMove(m_savedPlaceholderRenderStyle), m_savedPlaceholderFrameRect);
454     else if (m_fullscreenRenderer &amp;&amp; m_fullscreenRenderer-&gt;placeholder()) {
455         auto* placeholder = m_fullscreenRenderer-&gt;placeholder();
456         builder.createPlaceholderForFullScreen(renderer, RenderStyle::clonePtr(placeholder-&gt;style()), placeholder-&gt;frameRect());
457     }
458 
459     if (m_fullscreenRenderer)
460         builder.destroy(*m_fullscreenRenderer);
461     ASSERT(!m_fullscreenRenderer);
462 
463     m_fullscreenRenderer = makeWeakPtr(renderer);
464 }
465 
466 RenderFullScreen* FullscreenManager::fullscreenRenderer() const
467 {
468     return m_fullscreenRenderer.get();
469 }
470 
471 void FullscreenManager::dispatchFullscreenChangeEvents()
472 {
473     // Since we dispatch events in this function, it&#39;s possible that the
474     // document will be detached and GC&#39;d. We protect it here to make sure we
475     // can finish the function successfully.
476     Ref&lt;Document&gt; protectedDocument(document());
477     Deque&lt;RefPtr&lt;Node&gt;&gt; changeQueue;
478     m_fullscreenChangeEventTargetQueue.swap(changeQueue);
479     Deque&lt;RefPtr&lt;Node&gt;&gt; errorQueue;
480     m_fullscreenErrorEventTargetQueue.swap(errorQueue);
481     dispatchFullscreenChangeOrErrorEvent(changeQueue, eventNames().webkitfullscreenchangeEvent, /* shouldNotifyMediaElement */ true);
482     dispatchFullscreenChangeOrErrorEvent(errorQueue, eventNames().webkitfullscreenerrorEvent, /* shouldNotifyMediaElement */ false);
483 }
484 
485 void FullscreenManager::dispatchFullscreenChangeOrErrorEvent(Deque&lt;RefPtr&lt;Node&gt;&gt;&amp; queue, const AtomString&amp; eventName, bool shouldNotifyMediaElement)
486 {
487     while (!queue.isEmpty()) {
488         RefPtr&lt;Node&gt; node = queue.takeFirst();
489         if (!node)
490             node = documentElement();
491         // The dispatchEvent below may have blown away our documentElement.
492         if (!node)
493             continue;
494 
495         // If the element was removed from our tree, also message the documentElement. Since we may
496         // have a document hierarchy, check that node isn&#39;t in another document.
497         if (!node-&gt;isConnected())
498             queue.append(documentElement());
499 
500 #if ENABLE(VIDEO)
501         if (shouldNotifyMediaElement &amp;&amp; is&lt;HTMLMediaElement&gt;(*node))
502             downcast&lt;HTMLMediaElement&gt;(*node).enteredOrExitedFullscreen();
503 #else
504         UNUSED_PARAM(shouldNotifyMediaElement);
505 #endif
506         node-&gt;dispatchEvent(Event::create(eventName, Event::CanBubble::Yes, Event::IsCancelable::No));
507     }
508 }
509 
510 void FullscreenManager::adjustFullscreenElementOnNodeRemoval(Node&amp; node, Document::NodeRemoval nodeRemoval)
511 {
512     auto fullscreenElement = fullscreenOrPendingElement();
513     if (!fullscreenElement)
514         return;
515 
516     bool elementInSubtree = false;
517     if (nodeRemoval == Document::NodeRemoval::ChildrenOfNode)
518         elementInSubtree = fullscreenElement-&gt;isDescendantOf(node);
519     else
520         elementInSubtree = (fullscreenElement == &amp;node) || fullscreenElement-&gt;isDescendantOf(node);
521 
522     if (elementInSubtree) {
523         fullscreenElement-&gt;setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(false);
524         cancelFullscreen();
525     }
526 }
527 
528 bool FullscreenManager::isAnimatingFullscreen() const
529 {
530     return m_isAnimatingFullscreen;
531 }
532 
533 void FullscreenManager::setAnimatingFullscreen(bool flag)
534 {
535     if (m_isAnimatingFullscreen == flag)
536         return;
537     m_isAnimatingFullscreen = flag;
538 
539     if (m_fullscreenElement &amp;&amp; m_fullscreenElement-&gt;isDescendantOf(document())) {
540         m_fullscreenElement-&gt;invalidateStyleForSubtree();
541         scheduleFullStyleRebuild();
542     }
543 }
544 
545 bool FullscreenManager::areFullscreenControlsHidden() const
546 {
547     return m_areFullscreenControlsHidden;
548 }
549 
550 void FullscreenManager::setFullscreenControlsHidden(bool flag)
551 {
552     if (m_areFullscreenControlsHidden == flag)
553         return;
554     m_areFullscreenControlsHidden = flag;
555 
556     if (m_fullscreenElement &amp;&amp; m_fullscreenElement-&gt;isDescendantOf(document())) {
557         m_fullscreenElement-&gt;invalidateStyleForSubtree();
558         scheduleFullStyleRebuild();
559     }
560 }
561 
562 void FullscreenManager::clear()
563 {
564     m_fullscreenElement = nullptr;
565     m_pendingFullscreenElement = nullptr;
566     m_fullscreenElementStack.clear();
567 }
568 
569 void FullscreenManager::emptyEventQueue()
570 {
571     m_fullscreenChangeEventTargetQueue.clear();
572     m_fullscreenErrorEventTargetQueue.clear();
573 }
574 
575 void FullscreenManager::clearFullscreenElementStack()
576 {
577     m_fullscreenElementStack.clear();
578 }
579 
580 void FullscreenManager::popFullscreenElementStack()
581 {
582     if (m_fullscreenElementStack.isEmpty())
583         return;
584 
585     m_fullscreenElementStack.removeLast();
586 }
587 
588 void FullscreenManager::pushFullscreenElementStack(Element&amp; element)
589 {
590     m_fullscreenElementStack.append(&amp;element);
591 }
592 
593 void FullscreenManager::addDocumentToFullscreenChangeEventQueue(Document&amp; document)
594 {
595     Node* target = document.fullscreenManager().fullscreenElement();
596     if (!target)
597         target = document.fullscreenManager().currentFullscreenElement();
598     if (!target)
599         target = &amp;document;
600     m_fullscreenChangeEventTargetQueue.append(target);
601 }
602 
603 }
604 
605 #endif
    </pre>
  </body>
</html>
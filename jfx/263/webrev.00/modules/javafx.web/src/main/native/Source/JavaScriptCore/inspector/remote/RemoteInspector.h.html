<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/remote/RemoteInspector.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013, 2015, 2016 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(REMOTE_INSPECTOR)
 29 
 30 #include &quot;RemoteControllableTarget.h&quot;
 31 
 32 #include &lt;utility&gt;
 33 #include &lt;wtf/Forward.h&gt;
 34 #include &lt;wtf/HashMap.h&gt;
 35 #include &lt;wtf/Lock.h&gt;
 36 #include &lt;wtf/ProcessID.h&gt;
 37 #include &lt;wtf/text/WTFString.h&gt;
 38 
 39 #if PLATFORM(COCOA)
 40 #include &quot;RemoteInspectorXPCConnection.h&quot;
 41 #include &lt;wtf/RetainPtr.h&gt;
 42 
 43 OBJC_CLASS NSDictionary;
 44 OBJC_CLASS NSString;
 45 typedef RetainPtr&lt;NSDictionary&gt; TargetListing;
 46 #endif
 47 
 48 #if USE(GLIB)
 49 #include &lt;wtf/glib/GRefPtr.h&gt;
 50 #include &lt;wtf/glib/SocketConnection.h&gt;
 51 typedef GRefPtr&lt;GVariant&gt; TargetListing;
 52 typedef struct _GCancellable GCancellable;
 53 #endif
 54 
 55 #if USE(INSPECTOR_SOCKET_SERVER)
 56 #include &quot;RemoteConnectionToTarget.h&quot;
 57 #include &quot;RemoteInspectorConnectionClient.h&quot;
 58 #include &lt;wtf/JSONValues.h&gt;
 59 #include &lt;wtf/RefPtr.h&gt;
 60 
 61 namespace Inspector {
 62 using TargetListing = RefPtr&lt;JSON::Object&gt;;
 63 }
 64 #endif
 65 
 66 namespace Inspector {
 67 
 68 class RemoteAutomationTarget;
 69 class RemoteConnectionToTarget;
 70 class RemoteControllableTarget;
 71 class RemoteInspectionTarget;
 72 class RemoteInspectorClient;
 73 
 74 class JS_EXPORT_PRIVATE RemoteInspector final
 75 #if PLATFORM(COCOA)
 76     : public RemoteInspectorXPCConnection::Client
 77 #elif USE(INSPECTOR_SOCKET_SERVER)
 78     : public RemoteInspectorConnectionClient
 79 #endif
 80 {
 81 public:
 82     class Client {
 83     public:
 84         struct Capabilities {
 85             bool remoteAutomationAllowed : 1;
 86             String browserName;
 87             String browserVersion;
 88         };
 89 
 90         struct SessionCapabilities {
 91             bool acceptInsecureCertificates { false };
 92 #if USE(GLIB)
 93             Vector&lt;std::pair&lt;String, String&gt;&gt; certificates;
 94             struct Proxy {
 95                 String type;
 96                 Optional&lt;String&gt; ftpURL;
 97                 Optional&lt;String&gt; httpURL;
 98                 Optional&lt;String&gt; httpsURL;
 99                 Optional&lt;String&gt; socksURL;
100                 Vector&lt;String&gt; ignoreAddressList;
101             };
102             Optional&lt;Proxy&gt; proxy;
103 #endif
104 #if PLATFORM(COCOA)
105             Optional&lt;bool&gt; allowInsecureMediaCapture;
106             Optional&lt;bool&gt; suppressICECandidateFiltering;
107 #endif
108         };
109 
110         virtual ~Client();
111         virtual bool remoteAutomationAllowed() const = 0;
112         virtual String browserName() const { return { }; }
113         virtual String browserVersion() const { return { }; }
114         virtual void requestAutomationSession(const String&amp; sessionIdentifier, const SessionCapabilities&amp;) = 0;
115     };
116 
117     static void startDisabled();
118     static RemoteInspector&amp; singleton();
119     friend class NeverDestroyed&lt;RemoteInspector&gt;;
120 
121     void registerTarget(RemoteControllableTarget*);
122     void unregisterTarget(RemoteControllableTarget*);
123     void updateTarget(RemoteControllableTarget*);
124     void sendMessageToRemote(TargetID, const String&amp; message);
125 
126     RemoteInspector::Client* client() const { return m_client; }
127     void setClient(RemoteInspector::Client*);
128     void clientCapabilitiesDidChange();
129     Optional&lt;RemoteInspector::Client::Capabilities&gt; clientCapabilities() const { return m_clientCapabilities; }
130 
131     void setupFailed(TargetID);
132     void setupCompleted(TargetID);
133     bool waitingForAutomaticInspection(TargetID);
134     void updateAutomaticInspectionCandidate(RemoteInspectionTarget*);
135 
136     bool enabled() const { return m_enabled; }
137     bool hasActiveDebugSession() const { return m_hasActiveDebugSession; }
138 
139     void start();
140     void stop();
141 
142 #if PLATFORM(COCOA)
143     bool hasParentProcessInformation() const { return m_parentProcessIdentifier != 0; }
144     ProcessID parentProcessIdentifier() const { return m_parentProcessIdentifier; }
145     RetainPtr&lt;CFDataRef&gt; parentProcessAuditData() const { return m_parentProcessAuditData; }
146     void setParentProcessInformation(ProcessID, RetainPtr&lt;CFDataRef&gt; auditData);
147     void setParentProcessInfomationIsDelayed();
148 #endif
149 
150     void updateTargetListing(TargetID);
151 
152 #if USE(GLIB)
153     void requestAutomationSession(const char* sessionID, const Client::SessionCapabilities&amp;);
154 #endif
155 #if USE(GLIB) || USE(INSPECTOR_SOCKET_SERVER)
156     void setup(TargetID);
157     void sendMessageToTarget(TargetID, const char* message);
158 #endif
159 #if USE(INSPECTOR_SOCKET_SERVER)
160     void requestAutomationSession(const String&amp; sessionID, const Client::SessionCapabilities&amp;);
161 
162     bool isConnected() const { return !!m_clientConnection; }
163     void connect(ConnectionID);
164 
165     void setBackendCommandsPath(const String&amp; backendCommandsPath) { m_backendCommandsPath = backendCommandsPath; }
166 #endif
167 
168 private:
169     RemoteInspector();
170 
171     TargetID nextAvailableTargetIdentifier();
172 
173     enum class StopSource { API, XPCMessage };
174     void stopInternal(StopSource);
175 
176 #if PLATFORM(COCOA)
177     void setupXPCConnectionIfNeeded();
178 #endif
179 #if USE(GLIB)
180     void setupConnection(Ref&lt;SocketConnection&gt;&amp;&amp;);
181     static const SocketConnection::MessageHandlers&amp; messageHandlers();
182 
183     void receivedGetTargetListMessage();
184     void receivedSetupMessage(TargetID);
185     void receivedDataMessage(TargetID, const char* message);
186     void receivedCloseMessage(TargetID);
187     void receivedAutomationSessionRequestMessage(const char* sessionID);
188 #endif
189 
190     TargetListing listingForTarget(const RemoteControllableTarget&amp;) const;
191     TargetListing listingForInspectionTarget(const RemoteInspectionTarget&amp;) const;
192     TargetListing listingForAutomationTarget(const RemoteAutomationTarget&amp;) const;
193 
194     bool updateTargetMap(RemoteControllableTarget*);
195 
196     void pushListingsNow();
197     void pushListingsSoon();
198 
199     void updateTargetListing(const RemoteControllableTarget&amp;);
200 
201     void updateHasActiveDebugSession();
202     void updateClientCapabilities();
203 
204     void sendAutomaticInspectionCandidateMessage();
205 
206 #if PLATFORM(COCOA)
207     void xpcConnectionReceivedMessage(RemoteInspectorXPCConnection*, NSString *messageName, NSDictionary *userInfo) override;
208     void xpcConnectionFailed(RemoteInspectorXPCConnection*) override;
209     void xpcConnectionUnhandledMessage(RemoteInspectorXPCConnection*, xpc_object_t) override;
210 
211     void receivedSetupMessage(NSDictionary *userInfo);
212     void receivedDataMessage(NSDictionary *userInfo);
213     void receivedDidCloseMessage(NSDictionary *userInfo);
214     void receivedGetListingMessage(NSDictionary *userInfo);
215     void receivedIndicateMessage(NSDictionary *userInfo);
216     void receivedProxyApplicationSetupMessage(NSDictionary *userInfo);
217     void receivedConnectionDiedMessage(NSDictionary *userInfo);
218     void receivedAutomaticInspectionConfigurationMessage(NSDictionary *userInfo);
219     void receivedAutomaticInspectionRejectMessage(NSDictionary *userInfo);
220     void receivedAutomationSessionRequestMessage(NSDictionary *userInfo);
221 #endif
222 #if USE(INSPECTOR_SOCKET_SERVER)
223     HashMap&lt;String, CallHandler&gt;&amp; dispatchMap() override;
224     void didClose(ConnectionID) override;
225 
226     void sendWebInspectorEvent(const String&amp;);
227 
228     void setupInspectorClient(const Event&amp;);
229     void setupTarget(const Event&amp;);
230     void frontendDidClose(const Event&amp;);
231     void sendMessageToBackend(const Event&amp;);
232     void startAutomationSession(const Event&amp;);
233 
234     void receivedAutomationSessionRequestMessage(const Event&amp;);
235 
236     String backendCommands() const;
237 #endif
238     static bool startEnabled;
239 
240     // Targets can be registered from any thread at any time.
241     // Any target can send messages over the XPC connection.
242     // So lock access to all maps and state as they can change
243     // from any thread.
244     Lock m_mutex;
245 
246     HashMap&lt;TargetID, RemoteControllableTarget*&gt; m_targetMap;
247     HashMap&lt;TargetID, RefPtr&lt;RemoteConnectionToTarget&gt;&gt; m_targetConnectionMap;
248     HashMap&lt;TargetID, TargetListing&gt; m_targetListingMap;
249 
250 #if PLATFORM(COCOA)
251     RefPtr&lt;RemoteInspectorXPCConnection&gt; m_relayConnection;
252 #endif
253 #if USE(GLIB)
254     RefPtr&lt;SocketConnection&gt; m_socketConnection;
255     GRefPtr&lt;GCancellable&gt; m_cancellable;
256 #endif
257 
258 #if USE(INSPECTOR_SOCKET_SERVER)
259     // Connection from RemoteInspectorClient or WebDriver.
260     Optional&lt;ConnectionID&gt; m_clientConnection;
261     bool m_readyToPushListings { false };
262 
263     String m_backendCommandsPath;
264 #endif
265 
266     RemoteInspector::Client* m_client { nullptr };
267     Optional&lt;RemoteInspector::Client::Capabilities&gt; m_clientCapabilities;
268 
269 #if PLATFORM(COCOA)
270     dispatch_queue_t m_xpcQueue;
271 #endif
272     TargetID m_nextAvailableTargetIdentifier { 1 };
273     int m_notifyToken { 0 };
274     bool m_enabled { false };
275     bool m_hasActiveDebugSession { false };
276     bool m_pushScheduled { false };
277 
278     ProcessID m_parentProcessIdentifier { 0 };
279 #if PLATFORM(COCOA)
280     RetainPtr&lt;CFDataRef&gt; m_parentProcessAuditData;
281 #endif
282     bool m_shouldSendParentProcessInformation { false };
283     bool m_automaticInspectionEnabled { false };
284     bool m_automaticInspectionPaused { false };
285     TargetID m_automaticInspectionCandidateTargetIdentifier { 0 };
286 };
287 
288 } // namespace Inspector
289 
290 #endif // ENABLE(REMOTE_INSPECTOR)
    </pre>
  </body>
</html>
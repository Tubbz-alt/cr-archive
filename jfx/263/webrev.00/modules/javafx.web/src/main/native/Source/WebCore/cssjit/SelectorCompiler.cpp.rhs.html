<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/cssjit/SelectorCompiler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
   3  * Copyright (C) 2014 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  15  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  16  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  24  * THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;SelectorCompiler.h&quot;
  29 
  30 #if ENABLE(CSS_SELECTOR_JIT)
  31 
  32 #include &quot;CSSSelector.h&quot;
  33 #include &quot;CSSSelectorList.h&quot;
  34 #include &quot;DOMJITHelpers.h&quot;
  35 #include &quot;Element.h&quot;
  36 #include &quot;ElementData.h&quot;
  37 #include &quot;ElementRareData.h&quot;
  38 #include &quot;FunctionCall.h&quot;
  39 #include &quot;HTMLDocument.h&quot;
  40 #include &quot;HTMLNames.h&quot;
  41 #include &quot;HTMLParserIdioms.h&quot;
  42 #include &quot;InspectorInstrumentation.h&quot;
  43 #include &quot;NodeRenderStyle.h&quot;
  44 #include &quot;QualifiedName.h&quot;
  45 #include &quot;RegisterAllocator.h&quot;
  46 #include &quot;RenderElement.h&quot;
  47 #include &quot;RenderStyle.h&quot;
  48 #include &quot;SVGElement.h&quot;
  49 #include &quot;SelectorCheckerTestFunctions.h&quot;
  50 #include &quot;StackAllocator.h&quot;
  51 #include &quot;StyleRelations.h&quot;
  52 #include &quot;StyledElement.h&quot;
  53 #include &lt;JavaScriptCore/GPRInfo.h&gt;
  54 #include &lt;JavaScriptCore/LinkBuffer.h&gt;
  55 #include &lt;JavaScriptCore/MacroAssembler.h&gt;
  56 #include &lt;JavaScriptCore/VM.h&gt;
  57 #include &lt;limits&gt;
  58 #include &lt;wtf/Deque.h&gt;
  59 #include &lt;wtf/HashMap.h&gt;
  60 #include &lt;wtf/HashSet.h&gt;
  61 #include &lt;wtf/Vector.h&gt;
  62 #include &lt;wtf/text/CString.h&gt;
  63 
  64 namespace WebCore {
  65 namespace SelectorCompiler {
  66 
  67 #define CSS_SELECTOR_JIT_DEBUGGING 0
  68 
  69 enum class BacktrackingAction {
  70     NoBacktracking,
  71     JumpToDescendantEntryPoint,
  72     JumpToIndirectAdjacentEntryPoint,
  73     JumpToDescendantTreeWalkerEntryPoint,
  74     JumpToIndirectAdjacentTreeWalkerEntryPoint,
  75     JumpToDescendantTail,
  76     JumpToDirectAdjacentTail
  77 };
  78 
  79 struct BacktrackingFlag {
  80     enum {
  81         DescendantEntryPoint = 1,
  82         IndirectAdjacentEntryPoint = 1 &lt;&lt; 1,
  83         SaveDescendantBacktrackingStart = 1 &lt;&lt; 2,
  84         SaveAdjacentBacktrackingStart = 1 &lt;&lt; 3,
  85         DirectAdjacentTail = 1 &lt;&lt; 4,
  86         DescendantTail = 1 &lt;&lt; 5,
  87         InChainWithDescendantTail = 1 &lt;&lt; 6,
  88         InChainWithAdjacentTail = 1 &lt;&lt; 7
  89     };
  90 };
  91 
  92 enum class FragmentRelation {
  93     Rightmost,
  94     Descendant,
  95     Child,
  96     DirectAdjacent,
  97     IndirectAdjacent
  98 };
  99 
 100 enum class FunctionType {
 101     SimpleSelectorChecker,
 102     SelectorCheckerWithCheckingContext,
 103     CannotMatchAnything,
 104     CannotCompile
 105 };
 106 
 107 enum class FragmentPositionInRootFragments {
 108     Rightmost,
 109     AdjacentToRightmost,
 110     Other
 111 };
 112 
 113 enum class VisitedMode {
 114     None,
 115     Visited
 116 };
 117 
 118 enum class AttributeCaseSensitivity {
 119     CaseSensitive,
 120     // Some values are matched case-insensitively for HTML elements.
 121     // That is a legacy behavior decided by HTMLDocument::isCaseSensitiveAttribute().
 122     HTMLLegacyCaseInsensitive,
 123     CaseInsensitive
 124 };
 125 
 126 static AttributeCaseSensitivity attributeSelectorCaseSensitivity(const CSSSelector&amp; selector)
 127 {
 128     ASSERT(selector.isAttributeSelector());
 129 
 130     // This is by convention, the case is irrelevant for Set.
 131     if (selector.match() == CSSSelector::Set)
 132         return AttributeCaseSensitivity::CaseSensitive;
 133 
 134     if (selector.attributeValueMatchingIsCaseInsensitive())
 135         return AttributeCaseSensitivity::CaseInsensitive;
 136     if (HTMLDocument::isCaseSensitiveAttribute(selector.attribute()))
 137         return AttributeCaseSensitivity::CaseSensitive;
 138     return AttributeCaseSensitivity::HTMLLegacyCaseInsensitive;
 139 }
 140 
 141 class AttributeMatchingInfo {
 142 public:
 143     explicit AttributeMatchingInfo(const CSSSelector&amp; selector)
 144         : m_selector(&amp;selector)
 145         , m_attributeCaseSensitivity(attributeSelectorCaseSensitivity(selector))
 146     {
 147         ASSERT(!(m_attributeCaseSensitivity == AttributeCaseSensitivity::CaseInsensitive &amp;&amp; !selector.attributeValueMatchingIsCaseInsensitive()));
 148         ASSERT(!(selector.match() == CSSSelector::Set &amp;&amp; m_attributeCaseSensitivity != AttributeCaseSensitivity::CaseSensitive));
 149     }
 150 
 151     AttributeCaseSensitivity attributeCaseSensitivity() const { return m_attributeCaseSensitivity; }
 152     const CSSSelector&amp; selector() const { return *m_selector; }
 153 
 154 private:
 155     const CSSSelector* m_selector;
 156     AttributeCaseSensitivity m_attributeCaseSensitivity;
 157 };
 158 
 159 static const unsigned invalidHeight = std::numeric_limits&lt;unsigned&gt;::max();
 160 static const unsigned invalidWidth = std::numeric_limits&lt;unsigned&gt;::max();
 161 
 162 struct SelectorFragment;
 163 class SelectorFragmentList;
 164 
 165 class SelectorList : public Vector&lt;SelectorFragmentList&gt; {
 166 public:
 167     unsigned registerRequirements = std::numeric_limits&lt;unsigned&gt;::max();
 168     unsigned stackRequirements = std::numeric_limits&lt;unsigned&gt;::max();
 169     bool clobberElementAddressRegister = true;
 170 };
 171 
 172 struct NthChildOfSelectorInfo {
 173     int a;
 174     int b;
 175     SelectorList selectorList;
 176 };
 177 
 178 struct SelectorFragment {
 179     FragmentRelation relationToLeftFragment;
 180     FragmentRelation relationToRightFragment;
 181     FragmentPositionInRootFragments positionInRootFragments;
 182     bool isRightmostOrAdjacent { false };
 183 
 184     BacktrackingAction traversalBacktrackingAction = BacktrackingAction::NoBacktracking;
 185     BacktrackingAction matchingTagNameBacktrackingAction = BacktrackingAction::NoBacktracking;
 186     BacktrackingAction matchingPostTagNameBacktrackingAction = BacktrackingAction::NoBacktracking;
 187     unsigned char backtrackingFlags = 0;
 188     unsigned tagNameMatchedBacktrackingStartHeightFromDescendant = invalidHeight;
 189     unsigned tagNameNotMatchedBacktrackingStartHeightFromDescendant = invalidHeight;
 190     unsigned heightFromDescendant = 0;
 191     unsigned tagNameMatchedBacktrackingStartWidthFromIndirectAdjacent = invalidWidth;
 192     unsigned tagNameNotMatchedBacktrackingStartWidthFromIndirectAdjacent = invalidWidth;
 193     unsigned widthFromIndirectAdjacent = 0;
 194 
 195     FunctionType appendUnoptimizedPseudoClassWithContext(bool (*matcher)(const SelectorChecker::CheckingContext&amp;));
 196 
 197     // FIXME: the large stack allocation caused by the inline capacity causes memory inefficiency. We should dump
 198     // the min/max/average of the vectors and pick better inline capacity.
 199     const CSSSelector* tagNameSelector = nullptr;
 200     const AtomString* id = nullptr;
 201     Vector&lt;const Vector&lt;AtomString&gt;*&gt; languageArgumentsList;
 202     Vector&lt;const AtomStringImpl*, 8&gt; classNames;
 203     HashSet&lt;unsigned&gt; pseudoClasses;
 204     Vector&lt;JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;, 4&gt; unoptimizedPseudoClasses;
 205     Vector&lt;JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;, 4&gt; unoptimizedPseudoClassesWithContext;
 206     Vector&lt;AttributeMatchingInfo, 4&gt; attributes;
 207     Vector&lt;std::pair&lt;int, int&gt;, 2&gt; nthChildFilters;
 208     Vector&lt;NthChildOfSelectorInfo&gt; nthChildOfFilters;
 209     Vector&lt;std::pair&lt;int, int&gt;, 2&gt; nthLastChildFilters;
 210     Vector&lt;NthChildOfSelectorInfo&gt; nthLastChildOfFilters;
 211     SelectorList notFilters;
 212     Vector&lt;SelectorList&gt; matchesFilters;
 213     Vector&lt;Vector&lt;SelectorFragment&gt;&gt; anyFilters;
 214     const CSSSelector* pseudoElementSelector = nullptr;
 215 
 216     // For quirks mode, follow this: http://quirks.spec.whatwg.org/#the-:active-and-:hover-quirk
 217     // In quirks mode, a compound selector &#39;selector&#39; that matches the following conditions must not match elements that would not also match the &#39;:any-link&#39; selector.
 218     //
 219     //    selector uses the &#39;:active&#39; or &#39;:hover&#39; pseudo-classes.
 220     //    selector does not use a type selector.
 221     //    selector does not use an attribute selector.
 222     //    selector does not use an ID selector.
 223     //    selector does not use a class selector.
 224     //    selector does not use a pseudo-class selector other than &#39;:active&#39; and &#39;:hover&#39;.
 225     //    selector does not use a pseudo-element selector.
 226     //    selector is not part of an argument to a functional pseudo-class or pseudo-element.
 227     bool onlyMatchesLinksInQuirksMode = true;
 228 };
 229 
 230 class SelectorFragmentList : public Vector&lt;SelectorFragment, 4&gt; {
 231 public:
 232     unsigned registerRequirements = std::numeric_limits&lt;unsigned&gt;::max();
 233     unsigned stackRequirements = std::numeric_limits&lt;unsigned&gt;::max();
 234     unsigned staticSpecificity = 0;
 235     bool clobberElementAddressRegister = true;
 236 };
 237 
 238 struct TagNamePattern {
 239     const CSSSelector* tagNameSelector = nullptr;
 240     bool inverted = false;
 241 };
 242 
 243 typedef JSC::MacroAssembler Assembler;
 244 typedef Vector&lt;TagNamePattern, 32&gt; TagNameList;
 245 
 246 struct BacktrackingLevel {
 247     Assembler::Label descendantEntryPoint;
 248     Assembler::Label indirectAdjacentEntryPoint;
 249     Assembler::Label descendantTreeWalkerBacktrackingPoint;
 250     Assembler::Label indirectAdjacentTreeWalkerBacktrackingPoint;
 251 
 252     StackAllocator::StackReference descendantBacktrackingStart;
 253     Assembler::JumpList descendantBacktrackingFailureCases;
 254     StackAllocator::StackReference adjacentBacktrackingStart;
 255     Assembler::JumpList adjacentBacktrackingFailureCases;
 256 };
 257 
 258 class SelectorCodeGenerator {
 259 public:
 260     SelectorCodeGenerator(const CSSSelector*, SelectorContext);
 261     SelectorCompilationStatus compile(JSC::MacroAssemblerCodeRef&lt;CSSSelectorPtrTag&gt;&amp;);
 262 
 263 private:
 264     static const Assembler::RegisterID returnRegister;
 265     static const Assembler::RegisterID elementAddressRegister;
 266     static const Assembler::RegisterID checkingContextRegister;
 267     static const Assembler::RegisterID callFrameRegister;
 268 
 269     void generateSelectorChecker();
 270     void generateSelectorCheckerExcludingPseudoElements(Assembler::JumpList&amp; failureCases, const SelectorFragmentList&amp;);
 271     void generateElementMatchesSelectorList(Assembler::JumpList&amp; failureCases, Assembler::RegisterID elementToMatch, const SelectorList&amp;);
 272 
 273     // Element relations tree walker.
 274     void generateRightmostTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 275     void generateWalkToParentNode(Assembler::RegisterID targetRegister);
 276     void generateWalkToParentElement(Assembler::JumpList&amp; failureCases, Assembler::RegisterID targetRegister);
 277     void generateWalkToParentElementOrShadowRoot(Assembler::JumpList&amp; failureCases, Assembler::RegisterID targetRegister);
 278     void generateParentElementTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 279     void generateAncestorTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 280 
 281     void generateWalkToNextAdjacentElement(Assembler::JumpList&amp; failureCases, Assembler::RegisterID);
 282     void generateWalkToPreviousAdjacentElement(Assembler::JumpList&amp; failureCases, Assembler::RegisterID);
 283     void generateWalkToPreviousAdjacent(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 284     void generateDirectAdjacentTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 285     void generateIndirectAdjacentTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 286 
 287     void linkFailures(Assembler::JumpList&amp; globalFailureCases, BacktrackingAction, Assembler::JumpList&amp; localFailureCases);
 288     void generateAdjacentBacktrackingTail();
 289     void generateDescendantBacktrackingTail();
 290     void generateBacktrackingTailsIfNeeded(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 291 
 292     // Element properties matchers.
 293     void generateElementMatching(Assembler::JumpList&amp; matchingTagNameFailureCases, Assembler::JumpList&amp; matchingPostTagNameFailureCases, const SelectorFragment&amp;);
 294     void generateElementDataMatching(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 295     void generateElementLinkMatching(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 296     void generateElementFunctionCallTest(Assembler::JumpList&amp; failureCases, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;);
 297     void generateContextFunctionCallTest(Assembler::JumpList&amp; failureCases, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;);
 298     void generateElementIsActive(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 299     void generateElementIsEmpty(Assembler::JumpList&amp; failureCases);
 300     void generateElementIsFirstChild(Assembler::JumpList&amp; failureCases);
 301     void generateElementIsHovered(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 302     void generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 303     void generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const Vector&lt;AtomString&gt;*);
 304     void generateElementIsLastChild(Assembler::JumpList&amp; failureCases);
 305     void generateElementIsOnlyChild(Assembler::JumpList&amp; failureCases);
 306     void generateElementHasPlaceholderShown(Assembler::JumpList&amp; failureCases);
 307     void generateSynchronizeStyleAttribute(Assembler::RegisterID elementDataArraySizeAndFlags);
 308     void generateSynchronizeAllAnimatedSVGAttribute(Assembler::RegisterID elementDataArraySizeAndFlags);
 309     void generateElementAttributesMatching(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const SelectorFragment&amp;);
 310     void generateElementAttributeMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, Assembler::RegisterID decIndexRegister, const AttributeMatchingInfo&amp; attributeInfo);
 311     void generateElementAttributeValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AttributeMatchingInfo&amp; attributeInfo);
 312     void generateElementAttributeValueExactMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity);
 313     void generateElementAttributeFunctionCallValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseSensitiveTest, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseInsensitiveTest);
 314     void generateElementHasTagName(Assembler::JumpList&amp; failureCases, const CSSSelector&amp; tagMatchingSelector);
 315     void generateElementHasId(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const AtomString&amp; idToMatch);
 316     void generateElementHasClasses(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const Vector&lt;const AtomStringImpl*, 8&gt;&amp; classNames);
 317     void generateElementIsLink(Assembler::JumpList&amp; failureCases);
 318     void generateElementIsNthChild(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 319     void generateElementIsNthChildOf(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 320     void generateElementIsNthLastChild(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 321     void generateElementIsNthLastChildOf(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 322     void generateElementMatchesNotPseudoClass(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 323     void generateElementMatchesAnyPseudoClass(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 324     void generateElementMatchesMatchesPseudoClass(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 325     void generateElementHasPseudoElement(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 326     void generateElementIsRoot(Assembler::JumpList&amp; failureCases);
 327     void generateElementIsScopeRoot(Assembler::JumpList&amp; failureCases);
 328     void generateElementIsTarget(Assembler::JumpList&amp; failureCases);
 329     void generateElementHasFocusWithin(Assembler::JumpList&amp; failureCases);
 330 
 331     // Helpers.
 332     void generateAddStyleRelationIfResolvingStyle(Assembler::RegisterID element, Style::Relation::Type, Optional&lt;Assembler::RegisterID&gt; value = { });
 333     void generateAddStyleRelation(Assembler::RegisterID checkingContext, Assembler::RegisterID element, Style::Relation::Type, Optional&lt;Assembler::RegisterID&gt; value = { });
 334     Assembler::Jump branchOnResolvingModeWithCheckingContext(Assembler::RelationalCondition, SelectorChecker::Mode, Assembler::RegisterID checkingContext);
 335     Assembler::Jump branchOnResolvingMode(Assembler::RelationalCondition, SelectorChecker::Mode, Assembler::RegisterID checkingContext);
 336     void generateElementIsFirstLink(Assembler::JumpList&amp; failureCases, Assembler::RegisterID element);
 337     void generateStoreLastVisitedElement(Assembler::RegisterID element);
 338     void generateMarkPseudoStyleForPseudoElement(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 339     void generateNthFilterTest(Assembler::JumpList&amp; failureCases, Assembler::RegisterID counter, int a, int b);
 340     void generateRequestedPseudoElementEqualsToSelectorPseudoElement(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;, Assembler::RegisterID checkingContext);
 341     void generateSpecialFailureInQuirksModeForActiveAndHoverIfNeeded(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 342     Assembler::JumpList jumpIfNoPreviousAdjacentElement();
 343     Assembler::JumpList jumpIfNoNextAdjacentElement();
 344     Assembler::Jump jumpIfNotResolvingStyle(Assembler::RegisterID checkingContextRegister);
 345     void loadCheckingContext(Assembler::RegisterID checkingContext);
 346     Assembler::Jump modulo(JSC::MacroAssembler::ResultCondition, Assembler::RegisterID inputDividend, int divisor);
 347     void moduloIsZero(Assembler::JumpList&amp; failureCases, Assembler::RegisterID inputDividend, int divisor);
 348 
 349     void generateNthChildParentCheckAndRelationUpdate(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 350     void generateNthLastChildParentCheckAndRelationUpdate(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 351 
 352     void pushMacroAssemblerRegisters();
 353     void popMacroAssemblerRegisters(StackAllocator&amp;);
 354     bool generatePrologue();
 355     void generateEpilogue(StackAllocator&amp;);
 356     StackAllocator::StackReferenceVector m_macroAssemblerRegistersStackReferences;
 357     StackAllocator::StackReferenceVector m_prologueStackReferences;
 358 
 359     Assembler m_assembler;
 360     RegisterAllocator m_registerAllocator;
 361     StackAllocator m_stackAllocator;
 362     Vector&lt;std::pair&lt;Assembler::Call, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;&gt;, 32&gt; m_functionCalls;
 363 
 364     SelectorContext m_selectorContext;
 365     FunctionType m_functionType;
 366     SelectorFragmentList m_selectorFragments;
 367     VisitedMode m_visitedMode;
 368 
 369     StackAllocator::StackReference m_checkingContextStackReference;
 370 
 371     bool m_descendantBacktrackingStartInUse;
 372     Assembler::RegisterID m_descendantBacktrackingStart;
 373     StackAllocator::StackReferenceVector m_backtrackingStack;
 374     Deque&lt;BacktrackingLevel, 32&gt; m_backtrackingLevels;
 375     StackAllocator::StackReference m_lastVisitedElement;
 376     StackAllocator::StackReference m_startElement;
 377 
 378 #if CSS_SELECTOR_JIT_DEBUGGING
 379     const CSSSelector* m_originalSelector;
 380 #endif
 381 };
 382 
 383 const Assembler::RegisterID SelectorCodeGenerator::returnRegister = JSC::GPRInfo::returnValueGPR;
 384 const Assembler::RegisterID SelectorCodeGenerator::elementAddressRegister = JSC::GPRInfo::argumentGPR0;
 385 const Assembler::RegisterID SelectorCodeGenerator::checkingContextRegister = JSC::GPRInfo::argumentGPR1;
 386 const Assembler::RegisterID SelectorCodeGenerator::callFrameRegister = JSC::GPRInfo::callFrameRegister;
 387 
 388 enum class FragmentsLevel {
 389     Root = 0,
 390     InFunctionalPseudoType = 1
 391 };
 392 
 393 enum class PseudoElementMatchingBehavior { CanMatch, NeverMatch };
 394 
 395 static FunctionType constructFragments(const CSSSelector* rootSelector, SelectorContext, SelectorFragmentList&amp; selectorFragments, FragmentsLevel, FragmentPositionInRootFragments, bool visitedMatchEnabled, VisitedMode&amp;, PseudoElementMatchingBehavior);
 396 
 397 static void computeBacktrackingInformation(SelectorFragmentList&amp; selectorFragments, unsigned level = 0);
 398 
<a name="1" id="anc1"></a><span class="line-modified"> 399 void compileSelector(CompiledSelector&amp; compiledSelector, const CSSSelector* selector, SelectorContext selectorContext)</span>
 400 {
<a name="2" id="anc2"></a><span class="line-modified"> 401     ASSERT(compiledSelector.status == SelectorCompilationStatus::NotCompiled);</span>
<span class="line-modified"> 402 </span>
<span class="line-modified"> 403     if (!JSC::VM::canUseJIT()) {</span>
<span class="line-modified"> 404         compiledSelector.status = SelectorCompilationStatus::CannotCompile;</span>
<span class="line-added"> 405         return;</span>
<span class="line-added"> 406     }</span>
<span class="line-added"> 407 </span>
<span class="line-added"> 408     SelectorCodeGenerator codeGenerator(selector, selectorContext);</span>
<span class="line-added"> 409     compiledSelector.status = codeGenerator.compile(compiledSelector.codeRef);</span>
<span class="line-added"> 410 </span>
<span class="line-added"> 411 #if defined(CSS_SELECTOR_JIT_PROFILING) &amp;&amp; CSS_SELECTOR_JIT_PROFILING</span>
<span class="line-added"> 412     compiledSelector.selector = selector;</span>
<span class="line-added"> 413 #endif</span>
<span class="line-added"> 414 </span>
<span class="line-added"> 415     ASSERT(compiledSelector.status != SelectorCompilationStatus::NotCompiled);</span>
 416 }
 417 
 418 static inline FragmentRelation fragmentRelationForSelectorRelation(CSSSelector::RelationType relation)
 419 {
 420     switch (relation) {
 421     case CSSSelector::DescendantSpace:
 422         return FragmentRelation::Descendant;
 423     case CSSSelector::Child:
 424         return FragmentRelation::Child;
 425     case CSSSelector::DirectAdjacent:
 426         return FragmentRelation::DirectAdjacent;
 427     case CSSSelector::IndirectAdjacent:
 428         return FragmentRelation::IndirectAdjacent;
 429     case CSSSelector::Subselector:
 430     case CSSSelector::ShadowDescendant:
 431         ASSERT_NOT_REACHED();
 432     }
 433     ASSERT_NOT_REACHED();
 434     return FragmentRelation::Descendant;
 435 }
 436 
 437 static inline FunctionType mostRestrictiveFunctionType(FunctionType a, FunctionType b)
 438 {
 439     return std::max(a, b);
 440 }
 441 
 442 static inline bool fragmentMatchesTheRightmostElement(const SelectorFragment&amp; fragment)
 443 {
 444     return fragment.relationToRightFragment == FragmentRelation::Rightmost &amp;&amp; fragment.positionInRootFragments == FragmentPositionInRootFragments::Rightmost;
 445 }
 446 
 447 static inline bool fragmentMatchesRightmostOrAdjacentElement(const SelectorFragment&amp; fragment)
 448 {
 449     return fragment.isRightmostOrAdjacent &amp;&amp; fragment.positionInRootFragments != FragmentPositionInRootFragments::Other;
 450 }
 451 
 452 FunctionType SelectorFragment::appendUnoptimizedPseudoClassWithContext(bool (*matcher)(const SelectorChecker::CheckingContext&amp;))
 453 {
 454     unoptimizedPseudoClassesWithContext.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matcher));
 455     return FunctionType::SelectorCheckerWithCheckingContext;
 456 }
 457 
 458 static inline FunctionType addScrollbarPseudoClassType(const CSSSelector&amp;, SelectorFragment&amp;)
 459 {
 460     // FIXME: scrollbar pseudoclass interaction with :not doesn&#39;t behave correctly.
 461     // Compile them when they are fixed and tested.
 462     // https://bugs.webkit.org/show_bug.cgi?id=146221
 463     return FunctionType::CannotCompile;
 464 }
 465 
 466 // Handle the forward :nth-child() and backward :nth-last-child().
 467 static FunctionType addNthChildType(const CSSSelector&amp; selector, SelectorContext selectorContext, FragmentPositionInRootFragments positionInRootFragments, CSSSelector::PseudoClassType firstMatchAlternative, bool visitedMatchEnabled, Vector&lt;std::pair&lt;int, int&gt;, 2&gt;&amp; simpleCases, Vector&lt;NthChildOfSelectorInfo&gt;&amp; filteredCases, HashSet&lt;unsigned&gt;&amp; pseudoClasses, unsigned&amp; internalSpecificity)
 468 {
 469     int a = selector.nthA();
 470     int b = selector.nthB();
 471 
 472     // The element count is always positive.
 473     if (a &lt;= 0 &amp;&amp; b &lt; 1)
 474         return FunctionType::CannotMatchAnything;
 475 
 476     if (const CSSSelectorList* selectorList = selector.selectorList()) {
 477         NthChildOfSelectorInfo nthChildOfSelectorInfo;
 478         nthChildOfSelectorInfo.a = a;
 479         nthChildOfSelectorInfo.b = b;
 480 
 481         FunctionType globalFunctionType = FunctionType::SimpleSelectorChecker;
 482         if (selectorContext != SelectorContext::QuerySelector)
 483             globalFunctionType = FunctionType::SelectorCheckerWithCheckingContext;
 484 
 485         unsigned firstFragmentListSpecificity = 0;
 486         bool firstFragmentListSpecificitySet = false;
 487 
 488         SelectorFragmentList* selectorFragments = nullptr;
 489         for (const CSSSelector* subselector = selectorList-&gt;first(); subselector; subselector = CSSSelectorList::next(subselector)) {
 490             if (!selectorFragments) {
 491                 nthChildOfSelectorInfo.selectorList.append(SelectorFragmentList());
 492                 selectorFragments = &amp;nthChildOfSelectorInfo.selectorList.last();
 493             }
 494 
 495             VisitedMode ignoreVisitedMode = VisitedMode::None;
 496             FunctionType functionType = constructFragments(subselector, selectorContext, *selectorFragments, FragmentsLevel::InFunctionalPseudoType, positionInRootFragments, visitedMatchEnabled, ignoreVisitedMode, PseudoElementMatchingBehavior::NeverMatch);
 497             ASSERT_WITH_MESSAGE(ignoreVisitedMode == VisitedMode::None, &quot;:visited is disabled in the functional pseudo classes&quot;);
 498             switch (functionType) {
 499             case FunctionType::SimpleSelectorChecker:
 500             case FunctionType::SelectorCheckerWithCheckingContext:
 501                 break;
 502             case FunctionType::CannotMatchAnything:
 503                 continue;
 504             case FunctionType::CannotCompile:
 505                 return FunctionType::CannotCompile;
 506             }
 507 
 508             if (firstFragmentListSpecificitySet) {
 509                 // The CSS JIT does not handle dynamic specificity yet.
 510                 if (selectorContext == SelectorContext::RuleCollector &amp;&amp; selectorFragments-&gt;staticSpecificity != firstFragmentListSpecificity)
 511                     return FunctionType::CannotCompile;
 512             } else {
 513                 firstFragmentListSpecificitySet = true;
 514                 firstFragmentListSpecificity = selectorFragments-&gt;staticSpecificity;
 515             }
 516 
 517             globalFunctionType = mostRestrictiveFunctionType(globalFunctionType, functionType);
 518             selectorFragments = nullptr;
 519         }
 520 
 521         // If there is still a SelectorFragmentList open, the last Fragment(s) cannot match anything,
 522         // we have one FragmentList too many in our selector list.
 523         if (selectorFragments)
 524             nthChildOfSelectorInfo.selectorList.removeLast();
 525 
 526         if (nthChildOfSelectorInfo.selectorList.isEmpty())
 527             return FunctionType::CannotMatchAnything;
 528 
 529         internalSpecificity = firstFragmentListSpecificity;
 530         filteredCases.append(nthChildOfSelectorInfo);
 531         return globalFunctionType;
 532     }
 533 
 534     if (b == 1 &amp;&amp; a &lt;= 0)
 535         pseudoClasses.add(firstMatchAlternative);
 536     else
 537         simpleCases.append(std::pair&lt;int, int&gt;(a, b));
 538     if (selectorContext == SelectorContext::QuerySelector)
 539         return FunctionType::SimpleSelectorChecker;
 540     return FunctionType::SelectorCheckerWithCheckingContext;
 541 }
 542 
 543 static inline FunctionType addPseudoClassType(const CSSSelector&amp; selector, SelectorFragment&amp; fragment, unsigned&amp; internalSpecificity, SelectorContext selectorContext, FragmentsLevel fragmentLevel, FragmentPositionInRootFragments positionInRootFragments, bool visitedMatchEnabled, VisitedMode&amp; visitedMode, PseudoElementMatchingBehavior pseudoElementMatchingBehavior)
 544 {
 545     CSSSelector::PseudoClassType type = selector.pseudoClassType();
 546     switch (type) {
 547     // Unoptimized pseudo selector. They are just function call to a simple testing function.
 548     case CSSSelector::PseudoClassAutofill:
 549         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isAutofilled));
 550         return FunctionType::SimpleSelectorChecker;
 551     case CSSSelector::PseudoClassAutofillStrongPassword:
 552         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isAutofilledStrongPassword));
 553         return FunctionType::SimpleSelectorChecker;
 554     case CSSSelector::PseudoClassAutofillStrongPasswordViewable:
 555         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isAutofilledStrongPasswordViewable));
 556         return FunctionType::SimpleSelectorChecker;
 557     case CSSSelector::PseudoClassChecked:
 558         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isChecked));
 559         return FunctionType::SimpleSelectorChecker;
 560     case CSSSelector::PseudoClassDefault:
 561         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesDefaultPseudoClass));
 562         return FunctionType::SimpleSelectorChecker;
 563     case CSSSelector::PseudoClassDisabled:
 564         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesDisabledPseudoClass));
 565         return FunctionType::SimpleSelectorChecker;
 566     case CSSSelector::PseudoClassEnabled:
 567         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesEnabledPseudoClass));
 568         return FunctionType::SimpleSelectorChecker;
 569     case CSSSelector::PseudoClassDefined:
 570         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isDefinedElement));
 571         return FunctionType::SimpleSelectorChecker;
<a name="3" id="anc3"></a><span class="line-added"> 572     case CSSSelector::PseudoClassDirectFocus:</span>
<span class="line-added"> 573         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(SelectorChecker::matchesDirectFocusPseudoClass));</span>
<span class="line-added"> 574         return FunctionType::SimpleSelectorChecker;</span>
 575     case CSSSelector::PseudoClassFocus:
 576         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(SelectorChecker::matchesFocusPseudoClass));
 577         return FunctionType::SimpleSelectorChecker;
 578     case CSSSelector::PseudoClassFullPageMedia:
 579         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isMediaDocument));
 580         return FunctionType::SimpleSelectorChecker;
 581     case CSSSelector::PseudoClassInRange:
 582         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isInRange));
 583         return FunctionType::SimpleSelectorChecker;
 584     case CSSSelector::PseudoClassIndeterminate:
 585         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesIndeterminatePseudoClass));
 586         return FunctionType::SimpleSelectorChecker;
 587     case CSSSelector::PseudoClassInvalid:
 588         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isInvalid));
 589         return FunctionType::SimpleSelectorChecker;
 590     case CSSSelector::PseudoClassOptional:
 591         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isOptionalFormControl));
 592         return FunctionType::SimpleSelectorChecker;
 593     case CSSSelector::PseudoClassOutOfRange:
 594         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isOutOfRange));
 595         return FunctionType::SimpleSelectorChecker;
 596     case CSSSelector::PseudoClassReadOnly:
 597         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesReadOnlyPseudoClass));
 598         return FunctionType::SimpleSelectorChecker;
 599     case CSSSelector::PseudoClassReadWrite:
 600         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesReadWritePseudoClass));
 601         return FunctionType::SimpleSelectorChecker;
 602     case CSSSelector::PseudoClassRequired:
 603         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isRequiredFormControl));
 604         return FunctionType::SimpleSelectorChecker;
 605     case CSSSelector::PseudoClassValid:
 606         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isValid));
 607         return FunctionType::SimpleSelectorChecker;
 608     case CSSSelector::PseudoClassWindowInactive:
 609         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isWindowInactive));
 610         return FunctionType::SimpleSelectorChecker;
 611 
 612 #if ENABLE(FULLSCREEN_API)
 613     case CSSSelector::PseudoClassFullScreen:
 614         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenPseudoClass));
 615         return FunctionType::SimpleSelectorChecker;
 616     case CSSSelector::PseudoClassFullScreenDocument:
 617         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenDocumentPseudoClass));
 618         return FunctionType::SimpleSelectorChecker;
 619     case CSSSelector::PseudoClassFullScreenAncestor:
 620         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenAncestorPseudoClass));
 621         return FunctionType::SimpleSelectorChecker;
 622     case CSSSelector::PseudoClassAnimatingFullScreenTransition:
 623         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenAnimatingFullScreenTransitionPseudoClass));
 624         return FunctionType::SimpleSelectorChecker;
 625 
 626     case CSSSelector::PseudoClassFullScreenControlsHidden:
 627         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFullScreenControlsHiddenPseudoClass));
 628         return FunctionType::SimpleSelectorChecker;
 629 #endif
<a name="4" id="anc4"></a><span class="line-added"> 630 </span>
<span class="line-added"> 631 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added"> 632     case CSSSelector::PseudoClassPictureInPicture:</span>
<span class="line-added"> 633         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesPictureInPicturePseudoClass));</span>
<span class="line-added"> 634         return FunctionType::SimpleSelectorChecker;</span>
<span class="line-added"> 635 #endif</span>
<span class="line-added"> 636 </span>
 637 #if ENABLE(VIDEO_TRACK)
 638     case CSSSelector::PseudoClassFuture:
 639         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesFutureCuePseudoClass));
 640         return FunctionType::SimpleSelectorChecker;
 641     case CSSSelector::PseudoClassPast:
 642         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesPastCuePseudoClass));
 643         return FunctionType::SimpleSelectorChecker;
 644 #endif
 645 
 646 #if ENABLE(ATTACHMENT_ELEMENT)
 647     case CSSSelector::PseudoClassHasAttachment:
 648         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(hasAttachment));
 649         return FunctionType::SimpleSelectorChecker;
 650 #endif
 651 
 652     // These pseudo-classes only have meaning with scrollbars.
 653     case CSSSelector::PseudoClassHorizontal:
 654     case CSSSelector::PseudoClassVertical:
 655     case CSSSelector::PseudoClassDecrement:
 656     case CSSSelector::PseudoClassIncrement:
 657     case CSSSelector::PseudoClassStart:
 658     case CSSSelector::PseudoClassEnd:
 659     case CSSSelector::PseudoClassDoubleButton:
 660     case CSSSelector::PseudoClassSingleButton:
 661     case CSSSelector::PseudoClassNoButton:
 662     case CSSSelector::PseudoClassCornerPresent:
 663         return FunctionType::CannotMatchAnything;
 664 
 665     // FIXME: Compile these pseudoclasses, too!
 666     case CSSSelector::PseudoClassFirstOfType:
 667     case CSSSelector::PseudoClassLastOfType:
 668     case CSSSelector::PseudoClassOnlyOfType:
 669     case CSSSelector::PseudoClassNthOfType:
 670     case CSSSelector::PseudoClassNthLastOfType:
 671     case CSSSelector::PseudoClassDrag:
 672 #if ENABLE(CSS_SELECTORS_LEVEL4)
 673     case CSSSelector::PseudoClassDir:
 674     case CSSSelector::PseudoClassRole:
 675 #endif
 676         return FunctionType::CannotCompile;
 677 
 678     // Optimized pseudo selectors.
 679     case CSSSelector::PseudoClassAnyLink:
 680     case CSSSelector::PseudoClassLink:
 681     case CSSSelector::PseudoClassRoot:
 682     case CSSSelector::PseudoClassTarget:
 683         fragment.pseudoClasses.add(type);
 684         return FunctionType::SimpleSelectorChecker;
 685     case CSSSelector::PseudoClassAnyLinkDeprecated:
 686         fragment.pseudoClasses.add(CSSSelector::PseudoClassAnyLink);
 687         return FunctionType::SimpleSelectorChecker;
 688 
 689     case CSSSelector::PseudoClassVisited:
 690         // Determine this :visited cannot match anything statically.
 691         if (!visitedMatchEnabled)
 692             return FunctionType::CannotMatchAnything;
 693 
 694         // Inside functional pseudo class except for :not, :visited never matches.
 695         // And in the case inside :not, returning CannotMatchAnything indicates that :not(:visited) can match over anything.
 696         if (fragmentLevel == FragmentsLevel::InFunctionalPseudoType)
 697             return FunctionType::CannotMatchAnything;
 698 
 699         fragment.pseudoClasses.add(type);
 700         visitedMode = VisitedMode::Visited;
 701         return FunctionType::SimpleSelectorChecker;
 702 
 703     case CSSSelector::PseudoClassScope:
 704         if (selectorContext != SelectorContext::QuerySelector) {
 705             fragment.pseudoClasses.add(CSSSelector::PseudoClassRoot);
 706             return FunctionType::SimpleSelectorChecker;
 707         }
 708         fragment.pseudoClasses.add(CSSSelector::PseudoClassScope);
 709         return FunctionType::SelectorCheckerWithCheckingContext;
 710 
 711     case CSSSelector::PseudoClassActive:
 712     case CSSSelector::PseudoClassEmpty:
 713     case CSSSelector::PseudoClassFirstChild:
 714     case CSSSelector::PseudoClassHover:
 715     case CSSSelector::PseudoClassLastChild:
 716     case CSSSelector::PseudoClassOnlyChild:
 717     case CSSSelector::PseudoClassPlaceholderShown:
 718     case CSSSelector::PseudoClassFocusWithin:
 719         fragment.pseudoClasses.add(type);
 720         if (selectorContext == SelectorContext::QuerySelector)
 721             return FunctionType::SimpleSelectorChecker;
 722         return FunctionType::SelectorCheckerWithCheckingContext;
 723 
 724     case CSSSelector::PseudoClassNthChild:
 725         return addNthChildType(selector, selectorContext, positionInRootFragments, CSSSelector::PseudoClassFirstChild, visitedMatchEnabled, fragment.nthChildFilters, fragment.nthChildOfFilters, fragment.pseudoClasses, internalSpecificity);
 726 
 727     case CSSSelector::PseudoClassNthLastChild:
 728         return addNthChildType(selector, selectorContext, positionInRootFragments, CSSSelector::PseudoClassLastChild, visitedMatchEnabled, fragment.nthLastChildFilters, fragment.nthLastChildOfFilters, fragment.pseudoClasses, internalSpecificity);
 729 
 730     case CSSSelector::PseudoClassNot:
 731         {
 732             const CSSSelectorList* selectorList = selector.selectorList();
 733 
 734             ASSERT_WITH_MESSAGE(selectorList, &quot;The CSS Parser should never produce valid :not() CSSSelector with an empty selectorList.&quot;);
 735             if (!selectorList)
 736                 return FunctionType::CannotMatchAnything;
 737 
 738             FunctionType functionType = FunctionType::SimpleSelectorChecker;
 739             SelectorFragmentList* selectorFragments = nullptr;
 740             for (const CSSSelector* subselector = selectorList-&gt;first(); subselector; subselector = CSSSelectorList::next(subselector)) {
 741                 if (!selectorFragments) {
 742                     fragment.notFilters.append(SelectorFragmentList());
 743                     selectorFragments = &amp;fragment.notFilters.last();
 744                 }
 745 
 746                 VisitedMode ignoreVisitedMode = VisitedMode::None;
 747                 FunctionType localFunctionType = constructFragments(subselector, selectorContext, *selectorFragments, FragmentsLevel::InFunctionalPseudoType, positionInRootFragments, visitedMatchEnabled, ignoreVisitedMode, PseudoElementMatchingBehavior::NeverMatch);
 748                 ASSERT_WITH_MESSAGE(ignoreVisitedMode == VisitedMode::None, &quot;:visited is disabled in the functional pseudo classes&quot;);
 749 
 750                 // Since this is not pseudo class filter, CannotMatchAnything implies this filter always passes.
 751                 if (localFunctionType == FunctionType::CannotMatchAnything)
 752                     continue;
 753 
 754                 if (localFunctionType == FunctionType::CannotCompile)
 755                     return FunctionType::CannotCompile;
 756 
 757                 functionType = mostRestrictiveFunctionType(functionType, localFunctionType);
 758                 selectorFragments = nullptr;
 759             }
 760 
 761             // If there is still a SelectorFragmentList open, the last Fragment(s) cannot match anything,
 762             // we have one FragmentList too many in our selector list.
 763             if (selectorFragments)
 764                 fragment.notFilters.removeLast();
 765 
 766             return functionType;
 767         }
 768 
 769     case CSSSelector::PseudoClassAny:
 770         {
 771             Vector&lt;SelectorFragment, 32&gt; anyFragments;
 772             FunctionType functionType = FunctionType::SimpleSelectorChecker;
 773             for (const CSSSelector* rootSelector = selector.selectorList()-&gt;first(); rootSelector; rootSelector = CSSSelectorList::next(rootSelector)) {
 774                 SelectorFragmentList fragmentList;
 775                 VisitedMode ignoreVisitedMode = VisitedMode::None;
 776                 FunctionType subFunctionType = constructFragments(rootSelector, selectorContext, fragmentList, FragmentsLevel::InFunctionalPseudoType, positionInRootFragments, visitedMatchEnabled, ignoreVisitedMode, PseudoElementMatchingBehavior::NeverMatch);
 777                 ASSERT_WITH_MESSAGE(ignoreVisitedMode == VisitedMode::None, &quot;:visited is disabled in the functional pseudo classes&quot;);
 778 
 779                 // Since this fragment always unmatch against the element, don&#39;t insert it to anyFragments.
 780                 if (subFunctionType == FunctionType::CannotMatchAnything)
 781                     continue;
 782 
 783                 if (subFunctionType == FunctionType::CannotCompile)
 784                     return FunctionType::CannotCompile;
 785 
 786                 // :any() may not contain complex selectors which have combinators.
 787                 ASSERT(fragmentList.size() == 1);
 788                 if (fragmentList.size() != 1)
 789                     return FunctionType::CannotCompile;
 790 
 791                 const SelectorFragment&amp; subFragment = fragmentList.first();
 792                 anyFragments.append(subFragment);
 793                 functionType = mostRestrictiveFunctionType(functionType, subFunctionType);
 794             }
 795 
 796             // Since all fragments in :any() cannot match anything, this :any() filter cannot match anything.
 797             if (anyFragments.isEmpty())
 798                 return FunctionType::CannotMatchAnything;
 799 
 800             ASSERT(!anyFragments.isEmpty());
 801             fragment.anyFilters.append(anyFragments);
 802 
 803             return functionType;
 804         }
 805 
 806     case CSSSelector::PseudoClassLang:
 807         {
<a name="5" id="anc5"></a><span class="line-modified"> 808             const Vector&lt;AtomString&gt;* selectorLangArgumentList = selector.argumentList();</span>
 809             ASSERT(selectorLangArgumentList &amp;&amp; !selectorLangArgumentList-&gt;isEmpty());
 810             fragment.languageArgumentsList.append(selectorLangArgumentList);
 811             return FunctionType::SimpleSelectorChecker;
 812         }
 813 
 814     case CSSSelector::PseudoClassMatches:
 815         {
 816             SelectorList matchesList;
 817             const CSSSelectorList* selectorList = selector.selectorList();
 818             FunctionType functionType = FunctionType::SimpleSelectorChecker;
 819             unsigned firstFragmentListSpecificity = 0;
 820             bool firstFragmentListSpecificitySet = false;
 821             SelectorFragmentList* selectorFragments = nullptr;
 822             for (const CSSSelector* subselector = selectorList-&gt;first(); subselector; subselector = CSSSelectorList::next(subselector)) {
 823                 if (!selectorFragments) {
 824                     matchesList.append(SelectorFragmentList());
 825                     selectorFragments = &amp;matchesList.last();
 826                 }
 827 
 828                 VisitedMode ignoreVisitedMode = VisitedMode::None;
 829                 FunctionType localFunctionType = constructFragments(subselector, selectorContext, *selectorFragments, FragmentsLevel::InFunctionalPseudoType, positionInRootFragments, visitedMatchEnabled, ignoreVisitedMode, pseudoElementMatchingBehavior);
 830                 ASSERT_WITH_MESSAGE(ignoreVisitedMode == VisitedMode::None, &quot;:visited is disabled in the functional pseudo classes&quot;);
 831 
 832                 // Since this fragment never matches against the element, don&#39;t insert it to matchesList.
 833                 if (localFunctionType == FunctionType::CannotMatchAnything)
 834                     continue;
 835 
 836                 if (localFunctionType == FunctionType::CannotCompile)
 837                     return FunctionType::CannotCompile;
 838 
 839                 // FIXME: Currently pseudo elements inside :matches are supported in non-JIT code.
 840                 if (selectorFragments-&gt;first().pseudoElementSelector)
 841                     return FunctionType::CannotCompile;
 842 
 843                 if (firstFragmentListSpecificitySet) {
 844                     // The CSS JIT does not handle dynamic specificity yet.
 845                     if (selectorContext == SelectorContext::RuleCollector &amp;&amp; selectorFragments-&gt;staticSpecificity != firstFragmentListSpecificity)
 846                         return FunctionType::CannotCompile;
 847                 } else {
 848                     firstFragmentListSpecificitySet = true;
 849                     firstFragmentListSpecificity = selectorFragments-&gt;staticSpecificity;
 850                 }
 851 
 852                 functionType = mostRestrictiveFunctionType(functionType, localFunctionType);
 853                 selectorFragments = nullptr;
 854             }
 855 
 856             // If there is still a SelectorFragmentList open, the last Fragment(s) cannot match anything,
 857             // we have one FragmentList too many in our selector list.
 858             if (selectorFragments)
 859                 matchesList.removeLast();
 860 
 861             // Since all selector list in :matches() cannot match anything, the whole :matches() filter cannot match anything.
 862             if (matchesList.isEmpty())
 863                 return FunctionType::CannotMatchAnything;
 864 
 865             internalSpecificity = firstFragmentListSpecificity;
 866 
 867             fragment.matchesFilters.append(matchesList);
 868 
 869             return functionType;
 870         }
 871     case CSSSelector::PseudoClassHost:
 872         return FunctionType::CannotCompile;
 873     case CSSSelector::PseudoClassUnknown:
 874         ASSERT_NOT_REACHED();
 875         return FunctionType::CannotMatchAnything;
 876     }
 877 
 878     ASSERT_NOT_REACHED();
 879     return FunctionType::CannotCompile;
 880 }
 881 
 882 inline SelectorCodeGenerator::SelectorCodeGenerator(const CSSSelector* rootSelector, SelectorContext selectorContext)
 883     : m_stackAllocator(m_assembler)
 884     , m_selectorContext(selectorContext)
 885     , m_functionType(FunctionType::SimpleSelectorChecker)
 886     , m_visitedMode(VisitedMode::None)
 887     , m_descendantBacktrackingStartInUse(false)
 888 #if CSS_SELECTOR_JIT_DEBUGGING
 889     , m_originalSelector(rootSelector)
 890 #endif
 891 {
 892 #if CSS_SELECTOR_JIT_DEBUGGING
 893     dataLogF(&quot;Compiling \&quot;%s\&quot;\n&quot;, m_originalSelector-&gt;selectorText().utf8().data());
 894 #endif
 895 
 896     // In QuerySelector context, :visited always has no effect due to security issues.
 897     bool visitedMatchEnabled = selectorContext != SelectorContext::QuerySelector;
 898 
 899     m_functionType = constructFragments(rootSelector, m_selectorContext, m_selectorFragments, FragmentsLevel::Root, FragmentPositionInRootFragments::Rightmost, visitedMatchEnabled, m_visitedMode, PseudoElementMatchingBehavior::CanMatch);
 900     if (m_functionType != FunctionType::CannotCompile &amp;&amp; m_functionType != FunctionType::CannotMatchAnything)
 901         computeBacktrackingInformation(m_selectorFragments);
 902 }
 903 
 904 static bool pseudoClassOnlyMatchesLinksInQuirksMode(const CSSSelector&amp; selector)
 905 {
 906     CSSSelector::PseudoClassType pseudoClassType = selector.pseudoClassType();
 907     return pseudoClassType == CSSSelector::PseudoClassHover || pseudoClassType == CSSSelector::PseudoClassActive;
 908 }
 909 
 910 static bool isScrollbarPseudoElement(CSSSelector::PseudoElementType type)
 911 {
 912     return type &gt;= CSSSelector::PseudoElementScrollbar &amp;&amp; type &lt;= CSSSelector::PseudoElementScrollbarTrackPiece;
 913 }
 914 
 915 static FunctionType constructFragmentsInternal(const CSSSelector* rootSelector, SelectorContext selectorContext, SelectorFragmentList&amp; selectorFragments, FragmentsLevel fragmentLevel, FragmentPositionInRootFragments positionInRootFragments, bool visitedMatchEnabled, VisitedMode&amp; visitedMode, PseudoElementMatchingBehavior pseudoElementMatchingBehavior)
 916 {
 917     FragmentRelation relationToPreviousFragment = FragmentRelation::Rightmost;
 918     bool isRightmostOrAdjacent = positionInRootFragments != FragmentPositionInRootFragments::Other;
 919     FunctionType functionType = FunctionType::SimpleSelectorChecker;
 920     SelectorFragment* fragment = nullptr;
 921     unsigned specificity = 0;
 922     for (const CSSSelector* selector = rootSelector; selector; selector = selector-&gt;tagHistory()) {
 923         if (!fragment) {
 924             selectorFragments.append(SelectorFragment());
 925             fragment = &amp;selectorFragments.last();
 926         }
 927 
 928         specificity = CSSSelector::addSpecificities(specificity, selector-&gt;simpleSelectorSpecificity());
 929 
 930         // A selector is invalid if something follows a pseudo-element.
 931         // We make an exception for scrollbar pseudo elements and allow a set of pseudo classes (but nothing else)
 932         // to follow the pseudo elements.
 933         if (fragment-&gt;pseudoElementSelector &amp;&amp; !isScrollbarPseudoElement(fragment-&gt;pseudoElementSelector-&gt;pseudoElementType()))
 934             return FunctionType::CannotMatchAnything;
 935 
 936         switch (selector-&gt;match()) {
 937         case CSSSelector::Tag:
 938             ASSERT(!fragment-&gt;tagNameSelector);
 939             fragment-&gt;tagNameSelector = selector;
 940             if (fragment-&gt;tagNameSelector-&gt;tagQName() != anyQName())
 941                 fragment-&gt;onlyMatchesLinksInQuirksMode = false;
 942             break;
 943         case CSSSelector::Id: {
 944             const AtomString&amp; id = selector-&gt;value();
 945             if (fragment-&gt;id) {
 946                 if (id != *fragment-&gt;id)
 947                     return FunctionType::CannotMatchAnything;
 948             } else
 949                 fragment-&gt;id = &amp;(selector-&gt;value());
 950             fragment-&gt;onlyMatchesLinksInQuirksMode = false;
 951             break;
 952         }
 953         case CSSSelector::Class:
 954             fragment-&gt;classNames.append(selector-&gt;value().impl());
 955             fragment-&gt;onlyMatchesLinksInQuirksMode = false;
 956             break;
 957         case CSSSelector::PseudoClass: {
 958             FragmentPositionInRootFragments subPosition = positionInRootFragments;
 959             if (relationToPreviousFragment != FragmentRelation::Rightmost)
 960                 subPosition = isRightmostOrAdjacent ? FragmentPositionInRootFragments::AdjacentToRightmost : FragmentPositionInRootFragments::Other;
 961             if (fragment-&gt;pseudoElementSelector &amp;&amp; isScrollbarPseudoElement(fragment-&gt;pseudoElementSelector-&gt;pseudoElementType()))
 962                 functionType = mostRestrictiveFunctionType(functionType, addScrollbarPseudoClassType(*selector, *fragment));
 963             else {
 964                 unsigned internalSpecificity = 0;
 965                 functionType = mostRestrictiveFunctionType(functionType, addPseudoClassType(*selector, *fragment, internalSpecificity, selectorContext, fragmentLevel, subPosition, visitedMatchEnabled, visitedMode, pseudoElementMatchingBehavior));
 966                 specificity = CSSSelector::addSpecificities(specificity, internalSpecificity);
 967             }
 968             if (!pseudoClassOnlyMatchesLinksInQuirksMode(*selector))
 969                 fragment-&gt;onlyMatchesLinksInQuirksMode = false;
 970             if (functionType == FunctionType::CannotCompile || functionType == FunctionType::CannotMatchAnything)
 971                 return functionType;
 972             break;
 973         }
 974         case CSSSelector::PseudoElement: {
 975             fragment-&gt;onlyMatchesLinksInQuirksMode = false;
 976 
 977             // In the QuerySelector context, PseudoElement selectors always fail.
 978             if (selectorContext == SelectorContext::QuerySelector)
 979                 return FunctionType::CannotMatchAnything;
 980 
 981             switch (selector-&gt;pseudoElementType()) {
 982             case CSSSelector::PseudoElementAfter:
 983             case CSSSelector::PseudoElementBefore:
 984             case CSSSelector::PseudoElementFirstLetter:
 985             case CSSSelector::PseudoElementFirstLine:
 986             case CSSSelector::PseudoElementScrollbar:
 987             case CSSSelector::PseudoElementScrollbarButton:
 988             case CSSSelector::PseudoElementScrollbarCorner:
 989             case CSSSelector::PseudoElementScrollbarThumb:
 990             case CSSSelector::PseudoElementScrollbarTrack:
 991             case CSSSelector::PseudoElementScrollbarTrackPiece:
 992                 ASSERT(!fragment-&gt;pseudoElementSelector);
 993                 fragment-&gt;pseudoElementSelector = selector;
 994                 break;
 995             case CSSSelector::PseudoElementUnknown:
 996                 ASSERT_NOT_REACHED();
 997                 return FunctionType::CannotMatchAnything;
 998             // FIXME: Support PseudoId::Resizer, PseudoId::Selection etc.
 999             default:
1000                 // This branch includes custom pseudo elements.
1001                 return FunctionType::CannotCompile;
1002             }
1003 
1004             if (pseudoElementMatchingBehavior == PseudoElementMatchingBehavior::NeverMatch)
1005                 return FunctionType::CannotMatchAnything;
1006 
1007             functionType = FunctionType::SelectorCheckerWithCheckingContext;
1008             break;
1009         }
1010         case CSSSelector::List:
1011             if (selector-&gt;value().find(isHTMLSpace&lt;UChar&gt;) != notFound)
1012                 return FunctionType::CannotMatchAnything;
1013             FALLTHROUGH;
1014         case CSSSelector::Begin:
1015         case CSSSelector::End:
1016         case CSSSelector::Contain:
1017             if (selector-&gt;value().isEmpty())
1018                 return FunctionType::CannotMatchAnything;
1019             FALLTHROUGH;
1020         case CSSSelector::Exact:
1021         case CSSSelector::Hyphen:
1022             fragment-&gt;onlyMatchesLinksInQuirksMode = false;
1023             fragment-&gt;attributes.append(AttributeMatchingInfo(*selector));
1024             break;
1025 
1026         case CSSSelector::Set:
1027             fragment-&gt;onlyMatchesLinksInQuirksMode = false;
1028             fragment-&gt;attributes.append(AttributeMatchingInfo(*selector));
1029             break;
1030         case CSSSelector::PagePseudoClass:
1031             fragment-&gt;onlyMatchesLinksInQuirksMode = false;
1032             // Pseudo page class are only relevant for style resolution, they are ignored for matching.
1033             break;
1034         case CSSSelector::Unknown:
1035             ASSERT_NOT_REACHED();
1036             return FunctionType::CannotMatchAnything;
1037         }
1038 
1039         auto relation = selector-&gt;relation();
1040         if (relation == CSSSelector::Subselector)
1041             continue;
1042 
1043         if (relation == CSSSelector::ShadowDescendant &amp;&amp; !selector-&gt;isLastInTagHistory())
1044             return FunctionType::CannotCompile;
1045 
1046         if (relation == CSSSelector::DirectAdjacent || relation == CSSSelector::IndirectAdjacent) {
1047             FunctionType relationFunctionType = FunctionType::SelectorCheckerWithCheckingContext;
1048             if (selectorContext == SelectorContext::QuerySelector)
1049                 relationFunctionType = FunctionType::SimpleSelectorChecker;
1050             functionType = mostRestrictiveFunctionType(functionType, relationFunctionType);
1051 
1052             // When the relation is adjacent, disable :visited match.
1053             visitedMatchEnabled = false;
1054         }
1055 
1056         // Virtual pseudo element is only effective in the rightmost fragment.
1057         pseudoElementMatchingBehavior = PseudoElementMatchingBehavior::NeverMatch;
1058 
1059         fragment-&gt;relationToLeftFragment = fragmentRelationForSelectorRelation(relation);
1060         fragment-&gt;relationToRightFragment = relationToPreviousFragment;
1061         fragment-&gt;positionInRootFragments = positionInRootFragments;
1062         fragment-&gt;isRightmostOrAdjacent = isRightmostOrAdjacent;
1063         relationToPreviousFragment = fragment-&gt;relationToLeftFragment;
1064         if (relationToPreviousFragment != FragmentRelation::Rightmost &amp;&amp; relationToPreviousFragment != FragmentRelation::DirectAdjacent &amp;&amp; relationToPreviousFragment != FragmentRelation::IndirectAdjacent)
1065             isRightmostOrAdjacent = false;
1066 
1067         if (fragmentLevel != FragmentsLevel::Root)
1068             fragment-&gt;onlyMatchesLinksInQuirksMode = false;
1069 
1070         fragment = nullptr;
1071     }
1072 
1073     ASSERT(!fragment);
1074 
1075     selectorFragments.staticSpecificity = specificity;
1076 
1077     return functionType;
1078 }
1079 
1080 static FunctionType constructFragments(const CSSSelector* rootSelector, SelectorContext selectorContext, SelectorFragmentList&amp; selectorFragments, FragmentsLevel fragmentLevel, FragmentPositionInRootFragments positionInRootFragments, bool visitedMatchEnabled, VisitedMode&amp; visitedMode, PseudoElementMatchingBehavior pseudoElementMatchingBehavior)
1081 {
1082     ASSERT(selectorFragments.isEmpty());
1083 
1084     FunctionType functionType = constructFragmentsInternal(rootSelector, selectorContext, selectorFragments, fragmentLevel, positionInRootFragments, visitedMatchEnabled, visitedMode, pseudoElementMatchingBehavior);
1085     if (functionType != FunctionType::SimpleSelectorChecker &amp;&amp; functionType != FunctionType::SelectorCheckerWithCheckingContext)
1086         selectorFragments.clear();
1087     return functionType;
1088 }
1089 
1090 static inline bool attributeNameTestingRequiresNamespaceRegister(const CSSSelector&amp; attributeSelector)
1091 {
1092     return attributeSelector.attribute().prefix() != starAtom() &amp;&amp; !attributeSelector.attribute().namespaceURI().isNull();
1093 }
1094 
1095 static inline bool attributeValueTestingRequiresExtraRegister(const AttributeMatchingInfo&amp; attributeInfo)
1096 {
1097     switch (attributeInfo.attributeCaseSensitivity()) {
1098     case AttributeCaseSensitivity::CaseSensitive:
1099         return false;
1100     case AttributeCaseSensitivity::HTMLLegacyCaseInsensitive:
1101         return true;
1102     case AttributeCaseSensitivity::CaseInsensitive:
1103         return attributeInfo.selector().match() == CSSSelector::Exact;
1104     }
1105     return true;
1106 }
1107 
1108 // Element + ElementData + a pointer to values + an index on that pointer + the value we expect;
1109 static const unsigned minimumRequiredRegisterCount = 5;
1110 // Element + ElementData + scratchRegister + attributeArrayPointer + expectedLocalName + (qualifiedNameImpl &amp;&amp; expectedValue).
1111 static const unsigned minimumRequiredRegisterCountForAttributeFilter = 6;
1112 // On x86, we always need 6 registers: Element + SiblingCounter + SiblingCounterCopy + divisor + dividend + remainder.
1113 // On other architectures, we need 6 registers for style resolution:
1114 //     Element + elementCounter + previousSibling + checkingContext + lastRelation + nextSiblingElement.
1115 static const unsigned minimumRequiredRegisterCountForNthChildFilter = 6;
1116 
1117 static unsigned minimumRegisterRequirements(const SelectorFragment&amp; selectorFragment)
1118 {
1119     unsigned minimum = minimumRequiredRegisterCount;
1120     const auto&amp; attributes = selectorFragment.attributes;
1121 
1122     // Attributes cause some register pressure.
1123     unsigned attributeCount = attributes.size();
1124     for (unsigned attributeIndex = 0; attributeIndex &lt; attributeCount; ++attributeIndex) {
1125         unsigned attributeMinimum = minimumRequiredRegisterCountForAttributeFilter;
1126 
1127         if (attributeIndex + 1 &lt; attributeCount)
1128             attributeMinimum += 2; // For the local copy of the counter and attributeArrayPointer.
1129 
1130         const AttributeMatchingInfo&amp; attributeInfo = attributes[attributeIndex];
1131         const CSSSelector&amp; attributeSelector = attributeInfo.selector();
1132         if (attributeNameTestingRequiresNamespaceRegister(attributeSelector)
1133             || attributeValueTestingRequiresExtraRegister(attributeInfo))
1134             attributeMinimum += 1;
1135 
1136         minimum = std::max(minimum, attributeMinimum);
1137     }
1138 
1139     if (!selectorFragment.nthChildFilters.isEmpty() || !selectorFragment.nthChildOfFilters.isEmpty() || !selectorFragment.nthLastChildFilters.isEmpty() || !selectorFragment.nthLastChildOfFilters.isEmpty())
1140         minimum = std::max(minimum, minimumRequiredRegisterCountForNthChildFilter);
1141 
1142     // :any pseudo class filters cause some register pressure.
1143     for (const auto&amp; subFragments : selectorFragment.anyFilters) {
1144         for (const SelectorFragment&amp; subFragment : subFragments) {
1145             unsigned anyFilterMinimum = minimumRegisterRequirements(subFragment);
1146             minimum = std::max(minimum, anyFilterMinimum);
1147         }
1148     }
1149 
1150     return minimum;
1151 }
1152 
1153 bool hasAnyCombinators(const Vector&lt;SelectorFragmentList&gt;&amp; selectorList);
1154 template &lt;size_t inlineCapacity&gt;
1155 bool hasAnyCombinators(const Vector&lt;SelectorFragment, inlineCapacity&gt;&amp; selectorFragmentList);
1156 
1157 bool hasAnyCombinators(const Vector&lt;SelectorFragmentList&gt;&amp; selectorList)
1158 {
1159     for (const SelectorFragmentList&amp; selectorFragmentList : selectorList) {
1160         if (hasAnyCombinators(selectorFragmentList))
1161             return true;
1162     }
1163     return false;
1164 }
1165 
1166 template &lt;size_t inlineCapacity&gt;
1167 bool hasAnyCombinators(const Vector&lt;SelectorFragment, inlineCapacity&gt;&amp; selectorFragmentList)
1168 {
1169     if (selectorFragmentList.isEmpty())
1170         return false;
1171     if (selectorFragmentList.size() != 1)
1172         return true;
1173     if (hasAnyCombinators(selectorFragmentList.first().notFilters))
1174         return true;
1175     for (const SelectorList&amp; matchesList : selectorFragmentList.first().matchesFilters) {
1176         if (hasAnyCombinators(matchesList))
1177             return true;
1178     }
1179     for (const NthChildOfSelectorInfo&amp; nthChildOfSelectorInfo : selectorFragmentList.first().nthChildOfFilters) {
1180         if (hasAnyCombinators(nthChildOfSelectorInfo.selectorList))
1181             return true;
1182     }
1183     for (const NthChildOfSelectorInfo&amp; nthLastChildOfSelectorInfo : selectorFragmentList.first().nthLastChildOfFilters) {
1184         if (hasAnyCombinators(nthLastChildOfSelectorInfo.selectorList))
1185             return true;
1186     }
1187     return false;
1188 }
1189 
1190 // The CSS JIT has only been validated with a strict minimum of 6 allocated registers.
1191 const unsigned minimumRegisterRequirement = 6;
1192 
1193 void computeBacktrackingMemoryRequirements(SelectorFragmentList&amp; selectorFragments, bool backtrackingRegisterReserved = false);
1194 
1195 static void computeBacktrackingMemoryRequirements(SelectorList&amp; selectorList, unsigned&amp; totalRegisterRequirements, unsigned&amp; totalStackRequirements, bool backtrackingRegisterReservedForFragment = false)
1196 {
1197     unsigned selectorListRegisterRequirements = 0;
1198     unsigned selectorListStackRequirements = 0;
1199     bool clobberElementAddressRegister = false;
1200 
1201     for (SelectorFragmentList&amp; selectorFragmentList : selectorList) {
1202         computeBacktrackingMemoryRequirements(selectorFragmentList, backtrackingRegisterReservedForFragment);
1203 
1204         selectorListRegisterRequirements = std::max(selectorListRegisterRequirements, selectorFragmentList.registerRequirements);
1205         selectorListStackRequirements = std::max(selectorListStackRequirements, selectorFragmentList.stackRequirements);
1206         clobberElementAddressRegister = clobberElementAddressRegister || selectorFragmentList.clobberElementAddressRegister;
1207     }
1208 
1209     totalRegisterRequirements = std::max(totalRegisterRequirements, selectorListRegisterRequirements);
1210     totalStackRequirements = std::max(totalStackRequirements, selectorListStackRequirements);
1211 
1212     selectorList.registerRequirements = std::max(selectorListRegisterRequirements, minimumRegisterRequirement);
1213     selectorList.stackRequirements = selectorListStackRequirements;
1214     selectorList.clobberElementAddressRegister = clobberElementAddressRegister;
1215 }
1216 
1217 void computeBacktrackingMemoryRequirements(SelectorFragmentList&amp; selectorFragments, bool backtrackingRegisterReserved)
1218 {
1219     selectorFragments.registerRequirements = minimumRegisterRequirement;
1220     selectorFragments.stackRequirements = 0;
1221     selectorFragments.clobberElementAddressRegister = hasAnyCombinators(selectorFragments);
1222 
1223     for (SelectorFragment&amp; selectorFragment : selectorFragments) {
1224         unsigned fragmentRegisterRequirements = minimumRegisterRequirements(selectorFragment);
1225         unsigned fragmentStackRequirements = 0;
1226 
1227         bool backtrackingRegisterReservedForFragment = backtrackingRegisterReserved || selectorFragment.backtrackingFlags &amp; BacktrackingFlag::InChainWithDescendantTail;
1228 
1229         computeBacktrackingMemoryRequirements(selectorFragment.notFilters, fragmentRegisterRequirements, fragmentStackRequirements, backtrackingRegisterReservedForFragment);
1230 
1231         for (SelectorList&amp; matchesList : selectorFragment.matchesFilters)
1232             computeBacktrackingMemoryRequirements(matchesList, fragmentRegisterRequirements, fragmentStackRequirements, backtrackingRegisterReservedForFragment);
1233 
1234         for (NthChildOfSelectorInfo&amp; nthChildOfSelectorInfo : selectorFragment.nthChildOfFilters)
1235             computeBacktrackingMemoryRequirements(nthChildOfSelectorInfo.selectorList, fragmentRegisterRequirements, fragmentStackRequirements, backtrackingRegisterReservedForFragment);
1236 
1237         for (NthChildOfSelectorInfo&amp; nthLastChildOfSelectorInfo : selectorFragment.nthLastChildOfFilters)
1238             computeBacktrackingMemoryRequirements(nthLastChildOfSelectorInfo.selectorList, fragmentRegisterRequirements, fragmentStackRequirements, backtrackingRegisterReservedForFragment);
1239 
1240         if (selectorFragment.backtrackingFlags &amp; BacktrackingFlag::InChainWithDescendantTail) {
1241             if (!backtrackingRegisterReserved)
1242                 ++fragmentRegisterRequirements;
1243             else
1244                 ++fragmentStackRequirements;
1245         }
1246         if (selectorFragment.backtrackingFlags &amp; BacktrackingFlag::InChainWithAdjacentTail)
1247             ++fragmentStackRequirements;
1248 
1249         selectorFragments.registerRequirements = std::max(selectorFragments.registerRequirements, fragmentRegisterRequirements);
1250         selectorFragments.stackRequirements = std::max(selectorFragments.stackRequirements, fragmentStackRequirements);
1251     }
1252 }
1253 
1254 inline SelectorCompilationStatus SelectorCodeGenerator::compile(JSC::MacroAssemblerCodeRef&lt;CSSSelectorPtrTag&gt;&amp; codeRef)
1255 {
1256     switch (m_functionType) {
1257     case FunctionType::SimpleSelectorChecker:
1258     case FunctionType::SelectorCheckerWithCheckingContext:
1259         generateSelectorChecker();
1260         break;
1261     case FunctionType::CannotMatchAnything:
1262         m_assembler.tagReturnAddress();
1263         m_assembler.move(Assembler::TrustedImm32(0), returnRegister);
1264         m_assembler.ret();
1265         break;
1266     case FunctionType::CannotCompile:
1267         return SelectorCompilationStatus::CannotCompile;
1268     }
1269 
1270     JSC::LinkBuffer linkBuffer(m_assembler, CSS_CODE_ID, JSC::JITCompilationCanFail);
1271     if (!linkBuffer.isValid()) {
1272         // This could be SelectorCompilationStatus::NotCompiled but that would cause us to re-enter
1273         // the CSS JIT every time we evaluate that selector.
1274         // If we failed to allocate the buffer, we have bigger problems than CSS performance, it is fine
1275         // to be slower.
1276         return SelectorCompilationStatus::CannotCompile;
1277     }
1278 
1279     for (unsigned i = 0; i &lt; m_functionCalls.size(); i++)
1280         linkBuffer.link(m_functionCalls[i].first, m_functionCalls[i].second);
1281 
1282 #if CSS_SELECTOR_JIT_DEBUGGING
1283     codeRef = linkBuffer.finalizeCodeWithDisassembly(CSSSelectorPtrTag, &quot;CSS Selector JIT for \&quot;%s\&quot;&quot;, m_originalSelector-&gt;selectorText().utf8().data());
1284 #else
1285     codeRef = FINALIZE_CODE(linkBuffer, CSSSelectorPtrTag, &quot;CSS Selector JIT&quot;);
1286 #endif
1287 
1288     if (m_functionType == FunctionType::SimpleSelectorChecker || m_functionType == FunctionType::CannotMatchAnything)
1289         return SelectorCompilationStatus::SimpleSelectorChecker;
1290     return SelectorCompilationStatus::SelectorCheckerWithCheckingContext;
1291 }
1292 
1293 
1294 static inline void updateChainStates(const SelectorFragment&amp; fragment, bool&amp; hasDescendantRelationOnTheRight, unsigned&amp; ancestorPositionSinceDescendantRelation, bool&amp; hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain, unsigned&amp; adjacentPositionSinceIndirectAdjacentTreeWalk)
1295 {
1296     switch (fragment.relationToRightFragment) {
1297     case FragmentRelation::Rightmost:
1298         break;
1299     case FragmentRelation::Descendant:
1300         hasDescendantRelationOnTheRight = true;
1301         ancestorPositionSinceDescendantRelation = 0;
1302         hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain = false;
1303         break;
1304     case FragmentRelation::Child:
1305         if (hasDescendantRelationOnTheRight)
1306             ++ancestorPositionSinceDescendantRelation;
1307         hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain = false;
1308         break;
1309     case FragmentRelation::DirectAdjacent:
1310         if (hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain)
1311             ++adjacentPositionSinceIndirectAdjacentTreeWalk;
1312         break;
1313     case FragmentRelation::IndirectAdjacent:
1314         hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain = true;
1315         adjacentPositionSinceIndirectAdjacentTreeWalk = 0;
1316         break;
1317     }
1318 }
1319 
1320 static inline bool isFirstAncestor(unsigned ancestorPositionSinceDescendantRelation)
1321 {
1322     return ancestorPositionSinceDescendantRelation == 1;
1323 }
1324 
1325 static inline bool isFirstAdjacent(unsigned adjacentPositionSinceIndirectAdjacentTreeWalk)
1326 {
1327     return adjacentPositionSinceIndirectAdjacentTreeWalk == 1;
1328 }
1329 
1330 static inline BacktrackingAction solveDescendantBacktrackingActionForChild(const SelectorFragment&amp; fragment, unsigned backtrackingStartHeightFromDescendant)
1331 {
1332     // If height is invalid (e.g. There&#39;s no tag name).
1333     if (backtrackingStartHeightFromDescendant == invalidHeight)
1334         return BacktrackingAction::NoBacktracking;
1335 
1336     // Start backtracking from the current element.
1337     if (backtrackingStartHeightFromDescendant == fragment.heightFromDescendant)
1338         return BacktrackingAction::JumpToDescendantEntryPoint;
1339 
1340     // Start backtracking from the parent of current element.
1341     if (backtrackingStartHeightFromDescendant == (fragment.heightFromDescendant + 1))
1342         return BacktrackingAction::JumpToDescendantTreeWalkerEntryPoint;
1343 
1344     return BacktrackingAction::JumpToDescendantTail;
1345 }
1346 
1347 static inline BacktrackingAction solveAdjacentBacktrackingActionForDirectAdjacent(const SelectorFragment&amp; fragment, unsigned backtrackingStartWidthFromIndirectAdjacent)
1348 {
1349     // If width is invalid (e.g. There&#39;s no tag name).
1350     if (backtrackingStartWidthFromIndirectAdjacent == invalidWidth)
1351         return BacktrackingAction::NoBacktracking;
1352 
1353     // Start backtracking from the current element.
1354     if (backtrackingStartWidthFromIndirectAdjacent == fragment.widthFromIndirectAdjacent)
1355         return BacktrackingAction::JumpToIndirectAdjacentEntryPoint;
1356 
1357     // Start backtracking from the previous adjacent of current element.
1358     if (backtrackingStartWidthFromIndirectAdjacent == (fragment.widthFromIndirectAdjacent + 1))
1359         return BacktrackingAction::JumpToIndirectAdjacentTreeWalkerEntryPoint;
1360 
1361     return BacktrackingAction::JumpToDirectAdjacentTail;
1362 }
1363 
1364 static inline BacktrackingAction solveAdjacentTraversalBacktrackingAction(const SelectorFragment&amp; fragment, bool hasDescendantRelationOnTheRight)
1365 {
1366     if (!hasDescendantRelationOnTheRight)
1367         return BacktrackingAction::NoBacktracking;
1368 
1369     if (fragment.tagNameMatchedBacktrackingStartHeightFromDescendant == (fragment.heightFromDescendant + 1))
1370         return BacktrackingAction::JumpToDescendantTreeWalkerEntryPoint;
1371 
1372     return BacktrackingAction::JumpToDescendantTail;
1373 }
1374 
1375 static inline void solveBacktrackingAction(SelectorFragment&amp; fragment, bool hasDescendantRelationOnTheRight, bool hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain)
1376 {
1377     switch (fragment.relationToRightFragment) {
1378     case FragmentRelation::Rightmost:
1379     case FragmentRelation::Descendant:
1380         break;
1381     case FragmentRelation::Child:
1382         // Failure to match the element should resume matching at the nearest ancestor/descendant entry point.
1383         if (hasDescendantRelationOnTheRight) {
1384             fragment.matchingTagNameBacktrackingAction = solveDescendantBacktrackingActionForChild(fragment, fragment.tagNameNotMatchedBacktrackingStartHeightFromDescendant);
1385             fragment.matchingPostTagNameBacktrackingAction = solveDescendantBacktrackingActionForChild(fragment, fragment.tagNameMatchedBacktrackingStartHeightFromDescendant);
1386         }
1387         break;
1388     case FragmentRelation::DirectAdjacent:
1389         // Failure on traversal implies no other sibling traversal can match. Matching should resume at the
1390         // nearest ancestor/descendant traversal.
1391         fragment.traversalBacktrackingAction = solveAdjacentTraversalBacktrackingAction(fragment, hasDescendantRelationOnTheRight);
1392 
1393         // If the rightmost relation is a indirect adjacent, matching sould resume from there.
1394         // Otherwise, we resume from the latest ancestor/descendant if any.
1395         if (hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain) {
1396             fragment.matchingTagNameBacktrackingAction = solveAdjacentBacktrackingActionForDirectAdjacent(fragment, fragment.tagNameNotMatchedBacktrackingStartWidthFromIndirectAdjacent);
1397             fragment.matchingPostTagNameBacktrackingAction = solveAdjacentBacktrackingActionForDirectAdjacent(fragment, fragment.tagNameMatchedBacktrackingStartWidthFromIndirectAdjacent);
1398         } else if (hasDescendantRelationOnTheRight) {
1399             // Since we resume from the latest ancestor/descendant, the action is the same as the traversal action.
1400             fragment.matchingTagNameBacktrackingAction = fragment.traversalBacktrackingAction;
1401             fragment.matchingPostTagNameBacktrackingAction = fragment.traversalBacktrackingAction;
1402         }
1403         break;
1404     case FragmentRelation::IndirectAdjacent:
1405         // Failure on traversal implies no other sibling matching will succeed. Matching can resume
1406         // from the latest ancestor/descendant.
1407         fragment.traversalBacktrackingAction = solveAdjacentTraversalBacktrackingAction(fragment, hasDescendantRelationOnTheRight);
1408         break;
1409     }
1410 }
1411 
1412 enum class TagNameEquality {
1413     StrictlyNotEqual,
1414     MaybeEqual,
1415     StrictlyEqual
1416 };
1417 
1418 static inline TagNameEquality equalTagNames(const CSSSelector* lhs, const CSSSelector* rhs)
1419 {
1420     if (!lhs || !rhs)
1421         return TagNameEquality::MaybeEqual;
1422 
1423     const QualifiedName&amp; lhsQualifiedName = lhs-&gt;tagQName();
1424     if (lhsQualifiedName == anyQName())
1425         return TagNameEquality::MaybeEqual;
1426 
1427     const QualifiedName&amp; rhsQualifiedName = rhs-&gt;tagQName();
1428     if (rhsQualifiedName == anyQName())
1429         return TagNameEquality::MaybeEqual;
1430 
1431     const AtomString&amp; lhsLocalName = lhsQualifiedName.localName();
1432     const AtomString&amp; rhsLocalName = rhsQualifiedName.localName();
1433     if (lhsLocalName != starAtom() &amp;&amp; rhsLocalName != starAtom()) {
1434         const AtomString&amp; lhsLowercaseLocalName = lhs-&gt;tagLowercaseLocalName();
1435         const AtomString&amp; rhsLowercaseLocalName = rhs-&gt;tagLowercaseLocalName();
1436 
1437         if (lhsLowercaseLocalName != rhsLowercaseLocalName)
1438             return TagNameEquality::StrictlyNotEqual;
1439 
1440         if (lhsLocalName == lhsLowercaseLocalName &amp;&amp; rhsLocalName == rhsLowercaseLocalName)
1441             return TagNameEquality::StrictlyEqual;
1442         return TagNameEquality::MaybeEqual;
1443     }
1444 
1445     const AtomString&amp; lhsNamespaceURI = lhsQualifiedName.namespaceURI();
1446     const AtomString&amp; rhsNamespaceURI = rhsQualifiedName.namespaceURI();
1447     if (lhsNamespaceURI != starAtom() &amp;&amp; rhsNamespaceURI != starAtom()) {
1448         if (lhsNamespaceURI != rhsNamespaceURI)
1449             return TagNameEquality::StrictlyNotEqual;
1450         return TagNameEquality::StrictlyEqual;
1451     }
1452 
1453     return TagNameEquality::MaybeEqual;
1454 }
1455 
1456 static inline bool equalTagNamePatterns(const TagNamePattern&amp; lhs, const TagNamePattern&amp; rhs)
1457 {
1458     TagNameEquality result = equalTagNames(lhs.tagNameSelector, rhs.tagNameSelector);
1459     if (result == TagNameEquality::MaybeEqual)
1460         return true;
1461 
1462     // If both rhs &amp; lhs have actual localName (or NamespaceURI),
1463     // TagNameEquality result becomes StrictlyEqual or StrictlyNotEqual Since inverted lhs never matches on rhs.
1464     bool equal = result == TagNameEquality::StrictlyEqual;
1465     if (lhs.inverted)
1466         return !equal;
1467     return equal;
1468 }
1469 
1470 // Find the largest matching prefix from already known tagNames.
1471 // And by using this, compute an appropriate height of backtracking start element from the closest base element in the chain.
1472 static inline unsigned computeBacktrackingStartOffsetInChain(const TagNameList&amp; tagNames, unsigned maxPrefixSize)
1473 {
1474     RELEASE_ASSERT(!tagNames.isEmpty());
1475     RELEASE_ASSERT(maxPrefixSize &lt; tagNames.size());
1476 
1477     for (unsigned largestPrefixSize = maxPrefixSize; largestPrefixSize &gt; 0; --largestPrefixSize) {
1478         unsigned offsetToLargestPrefix = tagNames.size() - largestPrefixSize;
1479         bool matched = true;
1480         // Since TagNamePatterns are pushed to a tagNames, check tagNames with reverse order.
1481         for (unsigned i = 0; i &lt; largestPrefixSize; ++i) {
1482             unsigned lastIndex = tagNames.size() - 1;
1483             unsigned currentIndex = lastIndex - i;
1484             if (!equalTagNamePatterns(tagNames[currentIndex], tagNames[currentIndex - offsetToLargestPrefix])) {
1485                 matched = false;
1486                 break;
1487             }
1488         }
1489         if (matched)
1490             return offsetToLargestPrefix;
1491     }
1492     return tagNames.size();
1493 }
1494 
1495 static inline void computeBacktrackingHeightFromDescendant(SelectorFragment&amp; fragment, TagNameList&amp; tagNamesForChildChain, bool hasDescendantRelationOnTheRight, const SelectorFragment*&amp; previousChildFragmentInChildChain)
1496 {
1497     if (!hasDescendantRelationOnTheRight)
1498         return;
1499 
1500     if (fragment.relationToRightFragment == FragmentRelation::Descendant) {
1501         tagNamesForChildChain.clear();
1502 
1503         TagNamePattern pattern;
1504         pattern.tagNameSelector = fragment.tagNameSelector;
1505         tagNamesForChildChain.append(pattern);
1506         fragment.heightFromDescendant = 0;
1507         previousChildFragmentInChildChain = nullptr;
1508     } else if (fragment.relationToRightFragment == FragmentRelation::Child) {
1509         TagNamePattern pattern;
1510         pattern.tagNameSelector = fragment.tagNameSelector;
1511         tagNamesForChildChain.append(pattern);
1512 
1513         unsigned maxPrefixSize = tagNamesForChildChain.size() - 1;
1514         if (previousChildFragmentInChildChain) {
1515             RELEASE_ASSERT(tagNamesForChildChain.size() &gt;= previousChildFragmentInChildChain-&gt;tagNameMatchedBacktrackingStartHeightFromDescendant);
1516             maxPrefixSize = tagNamesForChildChain.size() - previousChildFragmentInChildChain-&gt;tagNameMatchedBacktrackingStartHeightFromDescendant;
1517         }
1518 
1519         if (pattern.tagNameSelector) {
1520             // Compute height from descendant in the case that tagName is not matched.
1521             tagNamesForChildChain.last().inverted = true;
1522             fragment.tagNameNotMatchedBacktrackingStartHeightFromDescendant = computeBacktrackingStartOffsetInChain(tagNamesForChildChain, maxPrefixSize);
1523         }
1524 
1525         // Compute height from descendant in the case that tagName is matched.
1526         tagNamesForChildChain.last().inverted = false;
1527         fragment.tagNameMatchedBacktrackingStartHeightFromDescendant = computeBacktrackingStartOffsetInChain(tagNamesForChildChain, maxPrefixSize);
1528         fragment.heightFromDescendant = tagNamesForChildChain.size() - 1;
1529         previousChildFragmentInChildChain = &amp;fragment;
1530     } else {
1531         if (previousChildFragmentInChildChain) {
1532             fragment.tagNameNotMatchedBacktrackingStartHeightFromDescendant = previousChildFragmentInChildChain-&gt;tagNameNotMatchedBacktrackingStartHeightFromDescendant;
1533             fragment.tagNameMatchedBacktrackingStartHeightFromDescendant = previousChildFragmentInChildChain-&gt;tagNameMatchedBacktrackingStartHeightFromDescendant;
1534             fragment.heightFromDescendant = previousChildFragmentInChildChain-&gt;heightFromDescendant;
1535         } else {
1536             fragment.tagNameNotMatchedBacktrackingStartHeightFromDescendant = tagNamesForChildChain.size();
1537             fragment.tagNameMatchedBacktrackingStartHeightFromDescendant = tagNamesForChildChain.size();
1538             fragment.heightFromDescendant = 0;
1539         }
1540     }
1541 }
1542 
1543 static inline void computeBacktrackingWidthFromIndirectAdjacent(SelectorFragment&amp; fragment, TagNameList&amp; tagNamesForDirectAdjacentChain, bool hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain, const SelectorFragment*&amp; previousDirectAdjacentFragmentInDirectAdjacentChain)
1544 {
1545     if (!hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain)
1546         return;
1547 
1548     if (fragment.relationToRightFragment == FragmentRelation::IndirectAdjacent) {
1549         tagNamesForDirectAdjacentChain.clear();
1550 
1551         TagNamePattern pattern;
1552         pattern.tagNameSelector = fragment.tagNameSelector;
1553         tagNamesForDirectAdjacentChain.append(pattern);
1554         fragment.widthFromIndirectAdjacent = 0;
1555         previousDirectAdjacentFragmentInDirectAdjacentChain = nullptr;
1556     } else if (fragment.relationToRightFragment == FragmentRelation::DirectAdjacent) {
1557         TagNamePattern pattern;
1558         pattern.tagNameSelector = fragment.tagNameSelector;
1559         tagNamesForDirectAdjacentChain.append(pattern);
1560 
1561         unsigned maxPrefixSize = tagNamesForDirectAdjacentChain.size() - 1;
1562         if (previousDirectAdjacentFragmentInDirectAdjacentChain) {
1563             RELEASE_ASSERT(tagNamesForDirectAdjacentChain.size() &gt;= previousDirectAdjacentFragmentInDirectAdjacentChain-&gt;tagNameMatchedBacktrackingStartWidthFromIndirectAdjacent);
1564             maxPrefixSize = tagNamesForDirectAdjacentChain.size() - previousDirectAdjacentFragmentInDirectAdjacentChain-&gt;tagNameMatchedBacktrackingStartWidthFromIndirectAdjacent;
1565         }
1566 
1567         if (pattern.tagNameSelector) {
1568             // Compute height from descendant in the case that tagName is not matched.
1569             tagNamesForDirectAdjacentChain.last().inverted = true;
1570             fragment.tagNameNotMatchedBacktrackingStartWidthFromIndirectAdjacent = computeBacktrackingStartOffsetInChain(tagNamesForDirectAdjacentChain, maxPrefixSize);
1571         }
1572 
1573         // Compute height from descendant in the case that tagName is matched.
1574         tagNamesForDirectAdjacentChain.last().inverted = false;
1575         fragment.tagNameMatchedBacktrackingStartWidthFromIndirectAdjacent = computeBacktrackingStartOffsetInChain(tagNamesForDirectAdjacentChain, maxPrefixSize);
1576         fragment.widthFromIndirectAdjacent = tagNamesForDirectAdjacentChain.size() - 1;
1577         previousDirectAdjacentFragmentInDirectAdjacentChain = &amp;fragment;
1578     }
1579 }
1580 
1581 static bool requiresAdjacentTail(const SelectorFragment&amp; fragment)
1582 {
1583     ASSERT(fragment.traversalBacktrackingAction != BacktrackingAction::JumpToDirectAdjacentTail);
1584     return fragment.matchingTagNameBacktrackingAction == BacktrackingAction::JumpToDirectAdjacentTail || fragment.matchingPostTagNameBacktrackingAction == BacktrackingAction::JumpToDirectAdjacentTail;
1585 }
1586 
1587 static bool requiresDescendantTail(const SelectorFragment&amp; fragment)
1588 {
1589     return fragment.matchingTagNameBacktrackingAction == BacktrackingAction::JumpToDescendantTail || fragment.matchingPostTagNameBacktrackingAction == BacktrackingAction::JumpToDescendantTail || fragment.traversalBacktrackingAction == BacktrackingAction::JumpToDescendantTail;
1590 }
1591 
1592 void computeBacktrackingInformation(SelectorFragmentList&amp; selectorFragments, unsigned level)
1593 {
1594     bool hasDescendantRelationOnTheRight = false;
1595     unsigned ancestorPositionSinceDescendantRelation = 0;
1596     bool hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain = false;
1597     unsigned adjacentPositionSinceIndirectAdjacentTreeWalk = 0;
1598 
1599     bool needsAdjacentTail = false;
1600     bool needsDescendantTail = false;
1601     unsigned saveDescendantBacktrackingStartFragmentIndex = std::numeric_limits&lt;unsigned&gt;::max();
1602     unsigned saveIndirectAdjacentBacktrackingStartFragmentIndex = std::numeric_limits&lt;unsigned&gt;::max();
1603 
1604     TagNameList tagNamesForChildChain;
1605     TagNameList tagNamesForDirectAdjacentChain;
1606     const SelectorFragment* previousChildFragmentInChildChain = nullptr;
1607     const SelectorFragment* previousDirectAdjacentFragmentInDirectAdjacentChain = nullptr;
1608 
1609     for (unsigned i = 0; i &lt; selectorFragments.size(); ++i) {
1610         SelectorFragment&amp; fragment = selectorFragments[i];
1611 
1612         updateChainStates(fragment, hasDescendantRelationOnTheRight, ancestorPositionSinceDescendantRelation, hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain, adjacentPositionSinceIndirectAdjacentTreeWalk);
1613 
1614         computeBacktrackingHeightFromDescendant(fragment, tagNamesForChildChain, hasDescendantRelationOnTheRight, previousChildFragmentInChildChain);
1615 
1616         computeBacktrackingWidthFromIndirectAdjacent(fragment, tagNamesForDirectAdjacentChain, hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain, previousDirectAdjacentFragmentInDirectAdjacentChain);
1617 
1618 #if CSS_SELECTOR_JIT_DEBUGGING
1619         dataLogF(&quot;%*sComputing fragment[%d] backtracking height %u. NotMatched %u / Matched %u | width %u. NotMatched %u / Matched %u\n&quot;, level * 4, &quot;&quot;, i, fragment.heightFromDescendant, fragment.tagNameNotMatchedBacktrackingStartHeightFromDescendant, fragment.tagNameMatchedBacktrackingStartHeightFromDescendant, fragment.widthFromIndirectAdjacent, fragment.tagNameNotMatchedBacktrackingStartWidthFromIndirectAdjacent, fragment.tagNameMatchedBacktrackingStartWidthFromIndirectAdjacent);
1620 #endif
1621 
1622         solveBacktrackingAction(fragment, hasDescendantRelationOnTheRight, hasIndirectAdjacentRelationOnTheRightOfDirectAdjacentChain);
1623 
1624         needsAdjacentTail |= requiresAdjacentTail(fragment);
1625         needsDescendantTail |= requiresDescendantTail(fragment);
1626 
1627         // Add code generation flags.
1628         if (fragment.relationToLeftFragment != FragmentRelation::Descendant &amp;&amp; fragment.relationToRightFragment == FragmentRelation::Descendant)
1629             fragment.backtrackingFlags |= BacktrackingFlag::DescendantEntryPoint;
1630         if (fragment.relationToLeftFragment == FragmentRelation::DirectAdjacent &amp;&amp; fragment.relationToRightFragment == FragmentRelation::IndirectAdjacent)
1631             fragment.backtrackingFlags |= BacktrackingFlag::IndirectAdjacentEntryPoint;
1632         if (fragment.relationToLeftFragment != FragmentRelation::Descendant &amp;&amp; fragment.relationToRightFragment == FragmentRelation::Child &amp;&amp; isFirstAncestor(ancestorPositionSinceDescendantRelation)) {
1633             ASSERT(saveDescendantBacktrackingStartFragmentIndex == std::numeric_limits&lt;unsigned&gt;::max());
1634             saveDescendantBacktrackingStartFragmentIndex = i;
1635         }
1636         if (fragment.relationToLeftFragment == FragmentRelation::DirectAdjacent &amp;&amp; fragment.relationToRightFragment == FragmentRelation::DirectAdjacent &amp;&amp; isFirstAdjacent(adjacentPositionSinceIndirectAdjacentTreeWalk)) {
1637             ASSERT(saveIndirectAdjacentBacktrackingStartFragmentIndex == std::numeric_limits&lt;unsigned&gt;::max());
1638             saveIndirectAdjacentBacktrackingStartFragmentIndex = i;
1639         }
1640         if (fragment.relationToLeftFragment != FragmentRelation::DirectAdjacent) {
1641             if (needsAdjacentTail) {
1642                 ASSERT(fragment.relationToRightFragment == FragmentRelation::DirectAdjacent);
1643                 ASSERT(saveIndirectAdjacentBacktrackingStartFragmentIndex != std::numeric_limits&lt;unsigned&gt;::max());
1644                 fragment.backtrackingFlags |= BacktrackingFlag::DirectAdjacentTail;
1645                 selectorFragments[saveIndirectAdjacentBacktrackingStartFragmentIndex].backtrackingFlags |= BacktrackingFlag::SaveAdjacentBacktrackingStart;
1646                 needsAdjacentTail = false;
1647                 for (unsigned j = saveIndirectAdjacentBacktrackingStartFragmentIndex; j &lt;= i; ++j)
1648                     selectorFragments[j].backtrackingFlags |= BacktrackingFlag::InChainWithAdjacentTail;
1649             }
1650             saveIndirectAdjacentBacktrackingStartFragmentIndex = std::numeric_limits&lt;unsigned&gt;::max();
1651         }
1652         if (fragment.relationToLeftFragment == FragmentRelation::Descendant) {
1653             if (needsDescendantTail) {
1654                 ASSERT(saveDescendantBacktrackingStartFragmentIndex != std::numeric_limits&lt;unsigned&gt;::max());
1655                 fragment.backtrackingFlags |= BacktrackingFlag::DescendantTail;
1656                 selectorFragments[saveDescendantBacktrackingStartFragmentIndex].backtrackingFlags |= BacktrackingFlag::SaveDescendantBacktrackingStart;
1657                 needsDescendantTail = false;
1658                 for (unsigned j = saveDescendantBacktrackingStartFragmentIndex; j &lt;= i; ++j)
1659                     selectorFragments[j].backtrackingFlags |= BacktrackingFlag::InChainWithDescendantTail;
1660             }
1661             saveDescendantBacktrackingStartFragmentIndex = std::numeric_limits&lt;unsigned&gt;::max();
1662         }
1663     }
1664 
1665     for (SelectorFragment&amp; fragment : selectorFragments) {
1666         if (!fragment.notFilters.isEmpty()) {
1667 #if CSS_SELECTOR_JIT_DEBUGGING
1668             dataLogF(&quot;%*s  Subselectors for :not():\n&quot;, level * 4, &quot;&quot;);
1669 #endif
1670 
1671             for (SelectorFragmentList&amp; selectorList : fragment.notFilters)
1672                 computeBacktrackingInformation(selectorList, level + 1);
1673         }
1674 
1675         if (!fragment.matchesFilters.isEmpty()) {
1676             for (SelectorList&amp; matchesList : fragment.matchesFilters) {
1677 #if CSS_SELECTOR_JIT_DEBUGGING
1678                 dataLogF(&quot;%*s  Subselectors for :matches():\n&quot;, level * 4, &quot;&quot;);
1679 #endif
1680 
1681                 for (SelectorFragmentList&amp; selectorList : matchesList)
1682                     computeBacktrackingInformation(selectorList, level + 1);
1683             }
1684         }
1685 
1686         for (NthChildOfSelectorInfo&amp; nthChildOfSelectorInfo : fragment.nthChildOfFilters) {
1687 #if CSS_SELECTOR_JIT_DEBUGGING
1688             dataLogF(&quot;%*s  Subselectors for %dn+%d:\n&quot;, level * 4, &quot;&quot;, nthChildOfSelectorInfo.a, nthChildOfSelectorInfo.b);
1689 #endif
1690 
1691             for (SelectorFragmentList&amp; selectorList : nthChildOfSelectorInfo.selectorList)
1692                 computeBacktrackingInformation(selectorList, level + 1);
1693         }
1694 
1695         for (NthChildOfSelectorInfo&amp; nthLastChildOfSelectorInfo : fragment.nthLastChildOfFilters) {
1696 #if CSS_SELECTOR_JIT_DEBUGGING
1697             dataLogF(&quot;%*s  Subselectors for %dn+%d:\n&quot;, level * 4, &quot;&quot;, nthLastChildOfSelectorInfo.a, nthLastChildOfSelectorInfo.b);
1698 #endif
1699 
1700             for (SelectorFragmentList&amp; selectorList : nthLastChildOfSelectorInfo.selectorList)
1701                 computeBacktrackingInformation(selectorList, level + 1);
1702         }
1703     }
1704 }
1705 
1706 inline void SelectorCodeGenerator::pushMacroAssemblerRegisters()
1707 {
1708 #if CPU(ARM_THUMB2)
1709     // r6 is tempRegister in RegisterAllocator.h and addressTempRegister in MacroAssemblerARMv7.h and must be preserved by the callee.
1710     Vector&lt;JSC::MacroAssembler::RegisterID, 1&gt; macroAssemblerRegisters({ JSC::ARMRegisters::r6 });
1711     m_macroAssemblerRegistersStackReferences = m_stackAllocator.push(macroAssemblerRegisters);
1712 #endif
1713 }
1714 
1715 inline void SelectorCodeGenerator::popMacroAssemblerRegisters(StackAllocator&amp; stackAllocator)
1716 {
1717 #if CPU(ARM_THUMB2)
1718     Vector&lt;JSC::MacroAssembler::RegisterID, 1&gt; macroAssemblerRegisters({ JSC::ARMRegisters::r6 });
1719     stackAllocator.pop(m_macroAssemblerRegistersStackReferences, macroAssemblerRegisters);
1720 #else
1721     UNUSED_PARAM(stackAllocator);
1722 #endif
1723 }
1724 
1725 inline bool SelectorCodeGenerator::generatePrologue()
1726 {
1727 #if CPU(ARM64)
1728     Vector&lt;JSC::MacroAssembler::RegisterID, 2&gt; prologueRegisters;
1729     prologueRegisters.append(JSC::ARM64Registers::lr);
1730     prologueRegisters.append(JSC::ARM64Registers::fp);
1731     m_prologueStackReferences = m_stackAllocator.push(prologueRegisters);
1732     return true;
1733 #elif CPU(ARM_THUMB2)
1734     Vector&lt;JSC::MacroAssembler::RegisterID, 1&gt; prologueRegisters;
1735     prologueRegisters.append(JSC::ARMRegisters::lr);
1736     m_prologueStackReferences = m_stackAllocator.push(prologueRegisters);
1737     return true;
1738 #elif CPU(X86_64) &amp;&amp; CSS_SELECTOR_JIT_DEBUGGING
1739     Vector&lt;JSC::MacroAssembler::RegisterID, 1&gt; prologueRegister;
1740     prologueRegister.append(callFrameRegister);
1741     m_prologueStackReferences = m_stackAllocator.push(prologueRegister);
1742     return true;
1743 #endif
1744     return false;
1745 }
1746 
1747 inline void SelectorCodeGenerator::generateEpilogue(StackAllocator&amp; stackAllocator)
1748 {
1749 #if CPU(ARM64)
1750     Vector&lt;JSC::MacroAssembler::RegisterID, 2&gt; prologueRegisters({ JSC::ARM64Registers::lr, JSC::ARM64Registers::fp });
1751     stackAllocator.pop(m_prologueStackReferences, prologueRegisters);
1752 #elif CPU(ARM_THUMB2)
1753     Vector&lt;JSC::MacroAssembler::RegisterID, 1&gt; prologueRegister({ JSC::ARMRegisters::lr });
1754     stackAllocator.pop(m_prologueStackReferences, prologueRegister);
1755 #elif CPU(X86_64) &amp;&amp; CSS_SELECTOR_JIT_DEBUGGING
1756     Vector&lt;JSC::MacroAssembler::RegisterID, 1&gt; prologueRegister({ callFrameRegister });
1757     stackAllocator.pop(m_prologueStackReferences, prologueRegister);
1758 #else
1759     UNUSED_PARAM(stackAllocator);
1760 #endif
1761 }
1762 
1763 static bool isAdjacentRelation(FragmentRelation relation)
1764 {
1765     return relation == FragmentRelation::DirectAdjacent || relation == FragmentRelation::IndirectAdjacent;
1766 }
1767 
1768 static bool shouldMarkStyleIsAffectedByPreviousSibling(const SelectorFragment&amp; fragment)
1769 {
1770     return isAdjacentRelation(fragment.relationToLeftFragment) &amp;&amp; !isAdjacentRelation(fragment.relationToRightFragment);
1771 }
1772 
1773 void SelectorCodeGenerator::generateSelectorChecker()
1774 {
1775     m_assembler.tagReturnAddress();
1776     pushMacroAssemblerRegisters();
1777     StackAllocator earlyFailureStack = m_stackAllocator;
1778 
1779     Assembler::JumpList failureOnFunctionEntry;
1780     // Test selector&#39;s pseudo element equals to requested PseudoId.
1781     if (m_selectorContext != SelectorContext::QuerySelector &amp;&amp; m_functionType == FunctionType::SelectorCheckerWithCheckingContext) {
1782         ASSERT_WITH_MESSAGE(fragmentMatchesTheRightmostElement(m_selectorFragments.first()), &quot;Matching pseudo elements only make sense for the rightmost fragment.&quot;);
1783         generateRequestedPseudoElementEqualsToSelectorPseudoElement(failureOnFunctionEntry, m_selectorFragments.first(), checkingContextRegister);
1784     }
1785 
1786     if (m_selectorContext == SelectorContext::RuleCollector) {
1787         unsigned specificity = m_selectorFragments.staticSpecificity;
1788         if (m_functionType == FunctionType::SelectorCheckerWithCheckingContext)
1789             m_assembler.store32(Assembler::TrustedImm32(specificity), JSC::GPRInfo::argumentGPR2);
1790         else
1791             m_assembler.store32(Assembler::TrustedImm32(specificity), JSC::GPRInfo::argumentGPR1);
1792     }
1793 
1794     computeBacktrackingMemoryRequirements(m_selectorFragments);
1795     unsigned availableRegisterCount = m_registerAllocator.reserveCallerSavedRegisters(m_selectorFragments.registerRequirements);
1796 
1797 #if CSS_SELECTOR_JIT_DEBUGGING
1798     dataLogF(&quot;Compiling with minimum required register count %u, minimum stack space %u\n&quot;, m_selectorFragments.registerRequirements, m_selectorFragments.stackRequirements);
1799 #endif
1800 
1801     // We do not want unbounded stack allocation for backtracking. Going down 8 enry points would already be incredibly inefficient.
1802     unsigned maximumBacktrackingAllocations = 8;
1803     if (m_selectorFragments.stackRequirements &gt; maximumBacktrackingAllocations) {
1804         m_assembler.move(Assembler::TrustedImm32(0), returnRegister);
1805         popMacroAssemblerRegisters(m_stackAllocator);
1806         m_assembler.ret();
1807         return;
1808     }
1809 
1810     bool needsEpilogue = generatePrologue();
1811 
1812     StackAllocator::StackReferenceVector calleeSavedRegisterStackReferences;
1813     bool reservedCalleeSavedRegisters = false;
1814     ASSERT(m_selectorFragments.registerRequirements &lt;= maximumRegisterCount);
1815     if (availableRegisterCount &lt; m_selectorFragments.registerRequirements) {
1816         reservedCalleeSavedRegisters = true;
1817         calleeSavedRegisterStackReferences = m_stackAllocator.push(m_registerAllocator.reserveCalleeSavedRegisters(m_selectorFragments.registerRequirements - availableRegisterCount));
1818     }
1819 
1820     m_registerAllocator.allocateRegister(elementAddressRegister);
1821 
1822     StackAllocator::StackReference temporaryStackBase = m_stackAllocator.stackTop();
1823 
1824     if (m_functionType == FunctionType::SelectorCheckerWithCheckingContext)
1825         m_checkingContextStackReference = m_stackAllocator.push(checkingContextRegister);
1826 
1827     unsigned stackRequirementCount = m_selectorFragments.stackRequirements;
1828     if (m_visitedMode == VisitedMode::Visited)
1829         stackRequirementCount += 2;
1830 
1831     StackAllocator::StackReferenceVector temporaryStack;
1832     if (stackRequirementCount)
1833         temporaryStack = m_stackAllocator.allocateUninitialized(stackRequirementCount);
1834 
1835     if (m_visitedMode == VisitedMode::Visited) {
1836         m_lastVisitedElement = temporaryStack.takeLast();
1837         m_startElement = temporaryStack.takeLast();
1838         m_assembler.storePtr(elementAddressRegister, m_stackAllocator.addressOf(m_startElement));
1839         m_assembler.storePtr(Assembler::TrustedImmPtr(nullptr), m_stackAllocator.addressOf(m_lastVisitedElement));
1840     }
1841 
1842     m_backtrackingStack = temporaryStack;
1843 
1844     Assembler::JumpList failureCases;
1845     generateSelectorCheckerExcludingPseudoElements(failureCases, m_selectorFragments);
1846 
1847     if (m_selectorContext != SelectorContext::QuerySelector &amp;&amp; m_functionType == FunctionType::SelectorCheckerWithCheckingContext) {
1848         ASSERT(!m_selectorFragments.isEmpty());
1849         generateMarkPseudoStyleForPseudoElement(failureCases, m_selectorFragments.first());
1850     }
1851 
1852     if (m_visitedMode == VisitedMode::Visited) {
1853         LocalRegister lastVisitedElement(m_registerAllocator);
1854         m_assembler.loadPtr(m_stackAllocator.addressOf(m_lastVisitedElement), lastVisitedElement);
1855         Assembler::Jump noLastVisitedElement = m_assembler.branchTestPtr(Assembler::Zero, lastVisitedElement);
1856         generateElementIsFirstLink(failureCases, lastVisitedElement);
1857         noLastVisitedElement.link(&amp;m_assembler);
1858     }
1859 
1860     m_registerAllocator.deallocateRegister(elementAddressRegister);
1861 
1862     if (m_functionType == FunctionType::SimpleSelectorChecker) {
1863         if (temporaryStackBase == m_stackAllocator.stackTop() &amp;&amp; !reservedCalleeSavedRegisters &amp;&amp; !needsEpilogue) {
1864             StackAllocator successStack = m_stackAllocator;
1865             StackAllocator failureStack = m_stackAllocator;
1866 
1867             ASSERT(!m_selectorFragments.stackRequirements);
1868             // Success.
1869             m_assembler.move(Assembler::TrustedImm32(1), returnRegister);
1870             popMacroAssemblerRegisters(successStack);
1871             m_assembler.ret();
1872 
1873             // Failure.
1874             ASSERT_WITH_MESSAGE(failureOnFunctionEntry.empty(), &quot;Early failure on function entry is used for pseudo element. When early failure is used, function type is SelectorCheckerWithCheckingContext.&quot;);
1875             if (!failureCases.empty()) {
1876                 failureCases.link(&amp;m_assembler);
1877                 m_assembler.move(Assembler::TrustedImm32(0), returnRegister);
1878                 popMacroAssemblerRegisters(failureStack);
1879                 m_assembler.ret();
1880             } else
1881                 failureStack = successStack;
1882 
1883             m_stackAllocator.merge(WTFMove(successStack), WTFMove(failureStack));
1884             return;
1885         }
1886     }
1887 
1888     // Success.
1889     m_assembler.move(Assembler::TrustedImm32(1), returnRegister);
1890 
1891     // Failure.
1892     if (!failureCases.empty()) {
1893         Assembler::Jump skipFailureCase = m_assembler.jump();
1894         failureCases.link(&amp;m_assembler);
1895         m_assembler.move(Assembler::TrustedImm32(0), returnRegister);
1896         skipFailureCase.link(&amp;m_assembler);
1897     }
1898 
1899     if (temporaryStackBase != m_stackAllocator.stackTop())
1900         m_stackAllocator.popAndDiscardUpTo(temporaryStackBase);
1901     if (reservedCalleeSavedRegisters)
1902         m_stackAllocator.pop(calleeSavedRegisterStackReferences, m_registerAllocator.restoreCalleeSavedRegisters());
1903 
1904     StackAllocator successStack = m_stackAllocator;
1905     if (needsEpilogue)
1906         generateEpilogue(successStack);
1907     popMacroAssemblerRegisters(successStack);
1908     m_assembler.ret();
1909 
1910     // Early failure on function entry case.
1911     if (!failureOnFunctionEntry.empty()) {
1912         failureOnFunctionEntry.link(&amp;m_assembler);
1913         m_assembler.move(Assembler::TrustedImm32(0), returnRegister);
1914         popMacroAssemblerRegisters(earlyFailureStack);
1915         m_assembler.ret();
1916     } else
1917         earlyFailureStack = successStack;
1918     m_stackAllocator.merge(WTFMove(successStack), WTFMove(earlyFailureStack));
1919 }
1920 
1921 void SelectorCodeGenerator::generateSelectorCheckerExcludingPseudoElements(Assembler::JumpList&amp; failureCases, const SelectorFragmentList&amp; selectorFragmentList)
1922 {
1923     m_backtrackingLevels.append(BacktrackingLevel());
1924 
1925     for (const SelectorFragment&amp; fragment : selectorFragmentList) {
1926         switch (fragment.relationToRightFragment) {
1927         case FragmentRelation::Rightmost:
1928             generateRightmostTreeWalker(failureCases, fragment);
1929             break;
1930         case FragmentRelation::Descendant:
1931             generateAncestorTreeWalker(failureCases, fragment);
1932             break;
1933         case FragmentRelation::Child:
1934             generateParentElementTreeWalker(failureCases, fragment);
1935             break;
1936         case FragmentRelation::DirectAdjacent:
1937             generateDirectAdjacentTreeWalker(failureCases, fragment);
1938             break;
1939         case FragmentRelation::IndirectAdjacent:
1940             generateIndirectAdjacentTreeWalker(failureCases, fragment);
1941             break;
1942         }
1943         if (shouldMarkStyleIsAffectedByPreviousSibling(fragment)) {
1944             if (fragmentMatchesTheRightmostElement(fragment))
1945                 generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::AffectedByPreviousSibling);
1946             else
1947                 generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::DescendantsAffectedByPreviousSibling);
1948         }
1949         generateBacktrackingTailsIfNeeded(failureCases, fragment);
1950     }
1951 
1952     ASSERT(!m_backtrackingLevels.last().descendantBacktrackingStart.isValid());
1953     ASSERT(!m_backtrackingLevels.last().adjacentBacktrackingStart.isValid());
1954     m_backtrackingLevels.takeLast();
1955 }
1956 
1957 void SelectorCodeGenerator::generateElementMatchesSelectorList(Assembler::JumpList&amp; failingCases, Assembler::RegisterID elementToMatch, const SelectorList&amp; selectorList)
1958 {
1959     ASSERT(!selectorList.isEmpty());
1960 
1961     RegisterVector registersToSave;
1962 
1963     // The contract is that existing registers are preserved. Two special cases are elementToMatch and elementAddressRegister
1964     // because they are used by the matcher itself.
1965     // To simplify things for now, we just always preserve them on the stack.
1966     unsigned elementToTestIndex = std::numeric_limits&lt;unsigned&gt;::max();
1967     bool isElementToMatchOnStack = false;
1968     if (selectorList.clobberElementAddressRegister) {
1969         if (elementToMatch != elementAddressRegister) {
1970             registersToSave.append(elementAddressRegister);
1971             registersToSave.append(elementToMatch);
1972             elementToTestIndex = 1;
1973             isElementToMatchOnStack = true;
1974         } else {
1975             registersToSave.append(elementAddressRegister);
1976             elementToTestIndex = 0;
1977         }
1978     } else if (elementToMatch != elementAddressRegister)
1979         registersToSave.append(elementAddressRegister);
1980 
1981     // Next, we need to free as many registers as needed by the nested selector list.
1982     unsigned availableRegisterCount = m_registerAllocator.availableRegisterCount();
1983 
1984     // Do not count elementAddressRegister, it will remain allocated.
1985     ++availableRegisterCount;
1986 
1987     if (isElementToMatchOnStack)
1988         ++availableRegisterCount;
1989 
1990     if (selectorList.registerRequirements &gt; availableRegisterCount) {
1991         unsigned registerToPushCount = selectorList.registerRequirements - availableRegisterCount;
1992         for (Assembler::RegisterID registerId : m_registerAllocator.allocatedRegisters()) {
1993             if (registerId == elementAddressRegister)
1994                 continue; // Handled separately above.
1995             if (isElementToMatchOnStack &amp;&amp; registerId == elementToMatch)
1996                 continue; // Do not push the element twice to the stack!
1997 
1998             registersToSave.append(registerId);
1999 
2000             --registerToPushCount;
2001             if (!registerToPushCount)
2002                 break;
2003         }
2004     }
2005 
2006     StackAllocator::StackReferenceVector allocatedRegistersOnStack = m_stackAllocator.push(registersToSave);
2007     for (Assembler::RegisterID registerID : registersToSave) {
2008         if (registerID != elementAddressRegister)
2009             m_registerAllocator.deallocateRegister(registerID);
2010     }
2011 
2012 
2013     if (elementToMatch != elementAddressRegister)
2014         m_assembler.move(elementToMatch, elementAddressRegister);
2015 
2016     Assembler::JumpList localFailureCases;
2017     if (selectorList.size() == 1) {
2018         const SelectorFragmentList&amp; nestedSelectorFragmentList = selectorList.first();
2019         generateSelectorCheckerExcludingPseudoElements(localFailureCases, nestedSelectorFragmentList);
2020     } else {
2021         Assembler::JumpList matchFragmentList;
2022 
2023         unsigned selectorListSize = selectorList.size();
2024         unsigned selectorListLastIndex = selectorListSize - 1;
2025         for (unsigned i = 0; i &lt; selectorList.size(); ++i) {
2026             const SelectorFragmentList&amp; nestedSelectorFragmentList = selectorList[i];
2027             Assembler::JumpList localSelectorFailureCases;
2028             generateSelectorCheckerExcludingPseudoElements(localSelectorFailureCases, nestedSelectorFragmentList);
2029             if (i != selectorListLastIndex) {
2030                 matchFragmentList.append(m_assembler.jump());
2031                 localSelectorFailureCases.link(&amp;m_assembler);
2032 
2033                 if (nestedSelectorFragmentList.clobberElementAddressRegister) {
2034                     RELEASE_ASSERT(elementToTestIndex != std::numeric_limits&lt;unsigned&gt;::max());
2035                     m_assembler.loadPtr(m_stackAllocator.addressOf(allocatedRegistersOnStack[elementToTestIndex]), elementAddressRegister);
2036                 }
2037             } else
2038                 localFailureCases.append(localSelectorFailureCases);
2039         }
2040         matchFragmentList.link(&amp;m_assembler);
2041     }
2042 
2043     // Finally, restore all the registers in the state they were before this selector checker.
2044     for (Assembler::RegisterID registerID : registersToSave) {
2045         if (registerID != elementAddressRegister)
2046             m_registerAllocator.allocateRegister(registerID);
2047     }
2048 
2049     if (allocatedRegistersOnStack.isEmpty()) {
2050         failingCases.append(localFailureCases);
2051         return;
2052     }
2053 
2054     if (localFailureCases.empty())
2055         m_stackAllocator.pop(allocatedRegistersOnStack, registersToSave);
2056     else {
2057         StackAllocator successStack = m_stackAllocator;
2058         StackAllocator failureStack = m_stackAllocator;
2059 
2060         successStack.pop(allocatedRegistersOnStack, registersToSave);
2061 
2062         Assembler::Jump skipFailureCase = m_assembler.jump();
2063         localFailureCases.link(&amp;m_assembler);
2064         failureStack.pop(allocatedRegistersOnStack, registersToSave);
2065         failingCases.append(m_assembler.jump());
2066 
2067         skipFailureCase.link(&amp;m_assembler);
2068 
2069         m_stackAllocator.merge(WTFMove(successStack), WTFMove(failureStack));
2070     }
2071 }
2072 
2073 void SelectorCodeGenerator::generateRightmostTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2074 {
2075     generateElementMatching(failureCases, failureCases, fragment);
2076 }
2077 
2078 void SelectorCodeGenerator::generateWalkToParentNode(Assembler::RegisterID targetRegister)
2079 {
2080     m_assembler.loadPtr(Assembler::Address(elementAddressRegister, Node::parentNodeMemoryOffset()), targetRegister);
2081 }
2082 
2083 void SelectorCodeGenerator::generateWalkToParentElement(Assembler::JumpList&amp; failureCases, Assembler::RegisterID targetRegister)
2084 {
2085     //    ContainerNode* parent = parentNode()
2086     //    if (!parent || !parent-&gt;isElementNode())
2087     //         failure
2088     generateWalkToParentNode(targetRegister);
2089     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, targetRegister));
2090     failureCases.append(DOMJIT::branchTestIsElementFlagOnNode(m_assembler, Assembler::Zero, targetRegister));
2091 }
2092 
2093 void SelectorCodeGenerator::generateWalkToParentElementOrShadowRoot(Assembler::JumpList&amp; failureCases, Assembler::RegisterID targetRegister)
2094 {
2095     //    ContainerNode* parent = parentNode()
2096     //    if (!parent || !(parent-&gt;isElementNode() || parent-&gt;isShadowRoot()))
2097     //         failure
2098     generateWalkToParentNode(targetRegister);
2099     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, targetRegister));
2100     failureCases.append(DOMJIT::branchTestIsElementOrShadowRootFlagOnNode(m_assembler, Assembler::Zero, targetRegister));
2101 }
2102 
2103 void SelectorCodeGenerator::generateParentElementTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2104 {
2105     Assembler::JumpList traversalFailureCases;
2106     generateWalkToParentElement(traversalFailureCases, elementAddressRegister);
2107     linkFailures(failureCases, fragment.traversalBacktrackingAction, traversalFailureCases);
2108 
2109     Assembler::JumpList matchingTagNameFailureCases;
2110     Assembler::JumpList matchingPostTagNameFailureCases;
2111     generateElementMatching(matchingTagNameFailureCases, matchingPostTagNameFailureCases, fragment);
2112     linkFailures(failureCases, fragment.matchingTagNameBacktrackingAction, matchingTagNameFailureCases);
2113     linkFailures(failureCases, fragment.matchingPostTagNameBacktrackingAction, matchingPostTagNameFailureCases);
2114 
2115     if (fragment.backtrackingFlags &amp; BacktrackingFlag::SaveDescendantBacktrackingStart) {
2116         if (!m_descendantBacktrackingStartInUse) {
2117             m_descendantBacktrackingStart = m_registerAllocator.allocateRegister();
2118             m_assembler.move(elementAddressRegister, m_descendantBacktrackingStart);
2119             m_descendantBacktrackingStartInUse = true;
2120         } else {
2121             BacktrackingLevel&amp; currentBacktrackingLevel = m_backtrackingLevels.last();
2122             ASSERT(!currentBacktrackingLevel.descendantBacktrackingStart.isValid());
2123             currentBacktrackingLevel.descendantBacktrackingStart = m_backtrackingStack.takeLast();
2124 
2125             m_assembler.storePtr(elementAddressRegister, m_stackAllocator.addressOf(currentBacktrackingLevel.descendantBacktrackingStart));
2126         }
2127     }
2128 }
2129 
2130 void SelectorCodeGenerator::generateAncestorTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2131 {
2132     // Loop over the ancestors until one of them matches the fragment.
2133     Assembler::Label loopStart(m_assembler.label());
2134 
2135     if (fragment.backtrackingFlags &amp; BacktrackingFlag::DescendantEntryPoint)
2136         m_backtrackingLevels.last().descendantTreeWalkerBacktrackingPoint = m_assembler.label();
2137 
2138     generateWalkToParentElement(failureCases, elementAddressRegister);
2139 
2140     if (fragment.backtrackingFlags &amp; BacktrackingFlag::DescendantEntryPoint)
2141         m_backtrackingLevels.last().descendantEntryPoint = m_assembler.label();
2142 
2143     Assembler::JumpList matchingFailureCases;
2144     generateElementMatching(matchingFailureCases, matchingFailureCases, fragment);
2145     matchingFailureCases.linkTo(loopStart, &amp;m_assembler);
2146 }
2147 
2148 inline void SelectorCodeGenerator::generateWalkToNextAdjacentElement(Assembler::JumpList&amp; failureCases, Assembler::RegisterID workRegister)
2149 {
2150     Assembler::Label loopStart = m_assembler.label();
2151     m_assembler.loadPtr(Assembler::Address(workRegister, Node::nextSiblingMemoryOffset()), workRegister);
2152     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, workRegister));
2153     DOMJIT::branchTestIsElementFlagOnNode(m_assembler, Assembler::Zero, workRegister).linkTo(loopStart, &amp;m_assembler);
2154 }
2155 
2156 inline void SelectorCodeGenerator::generateWalkToPreviousAdjacentElement(Assembler::JumpList&amp; failureCases, Assembler::RegisterID workRegister)
2157 {
2158     Assembler::Label loopStart = m_assembler.label();
2159     m_assembler.loadPtr(Assembler::Address(workRegister, Node::previousSiblingMemoryOffset()), workRegister);
2160     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, workRegister));
2161     DOMJIT::branchTestIsElementFlagOnNode(m_assembler, Assembler::Zero, workRegister).linkTo(loopStart, &amp;m_assembler);
2162 }
2163 
2164 void SelectorCodeGenerator::generateWalkToPreviousAdjacent(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2165 {
2166     //    do {
2167     //        previousSibling = previousSibling-&gt;previousSibling();
2168     //        if (!previousSibling)
2169     //            failure!
2170     //    while (!previousSibling-&gt;isElement());
2171     Assembler::RegisterID previousSibling;
2172     bool useTailOnTraversalFailure = fragment.traversalBacktrackingAction &gt;= BacktrackingAction::JumpToDescendantTail;
2173     if (!useTailOnTraversalFailure) {
2174         // If the current fragment is not dependant on a previously saved elementAddressRegister, a fast recover
2175         // from a failure would resume with elementAddressRegister.
2176         // When walking to the previous sibling, the failure can be that previousSibling is null. We cannot backtrack
2177         // with a null elementAddressRegister so we do the traversal on a copy.
2178         previousSibling = m_registerAllocator.allocateRegister();
2179         m_assembler.move(elementAddressRegister, previousSibling);
2180     } else
2181         previousSibling = elementAddressRegister;
2182 
2183     Assembler::JumpList traversalFailureCases;
2184     generateWalkToPreviousAdjacentElement(traversalFailureCases, previousSibling);
2185     linkFailures(failureCases, fragment.traversalBacktrackingAction, traversalFailureCases);
2186 
2187     // On success, move previousSibling over to elementAddressRegister if we could not work on elementAddressRegister directly.
2188     if (!useTailOnTraversalFailure) {
2189         m_assembler.move(previousSibling, elementAddressRegister);
2190         m_registerAllocator.deallocateRegister(previousSibling);
2191     }
2192 }
2193 
2194 void SelectorCodeGenerator::generateDirectAdjacentTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2195 {
2196     generateWalkToPreviousAdjacent(failureCases, fragment);
2197     generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::AffectsNextSibling);
2198 
2199     Assembler::JumpList matchingTagNameFailureCases;
2200     Assembler::JumpList matchingPostTagNameFailureCases;
2201     generateElementMatching(matchingTagNameFailureCases, matchingPostTagNameFailureCases, fragment);
2202     linkFailures(failureCases, fragment.matchingTagNameBacktrackingAction, matchingTagNameFailureCases);
2203     linkFailures(failureCases, fragment.matchingPostTagNameBacktrackingAction, matchingPostTagNameFailureCases);
2204 
2205     if (fragment.backtrackingFlags &amp; BacktrackingFlag::SaveAdjacentBacktrackingStart) {
2206         BacktrackingLevel&amp; currentBacktrackingLevel = m_backtrackingLevels.last();
2207         ASSERT(!currentBacktrackingLevel.adjacentBacktrackingStart.isValid());
2208         currentBacktrackingLevel.adjacentBacktrackingStart = m_backtrackingStack.takeLast();
2209 
2210         m_assembler.storePtr(elementAddressRegister, m_stackAllocator.addressOf(currentBacktrackingLevel.adjacentBacktrackingStart));
2211     }
2212 }
2213 
2214 void SelectorCodeGenerator::generateIndirectAdjacentTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2215 {
2216     Assembler::Label loopStart(m_assembler.label());
2217 
2218     if (fragment.backtrackingFlags &amp; BacktrackingFlag::IndirectAdjacentEntryPoint)
2219         m_backtrackingLevels.last().indirectAdjacentTreeWalkerBacktrackingPoint = m_assembler.label();
2220 
2221     generateWalkToPreviousAdjacent(failureCases, fragment);
2222     generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::AffectsNextSibling);
2223 
2224     if (fragment.backtrackingFlags &amp; BacktrackingFlag::IndirectAdjacentEntryPoint)
2225         m_backtrackingLevels.last().indirectAdjacentEntryPoint = m_assembler.label();
2226 
2227     Assembler::JumpList localFailureCases;
2228     generateElementMatching(localFailureCases, localFailureCases, fragment);
2229     localFailureCases.linkTo(loopStart, &amp;m_assembler);
2230 }
2231 
2232 void SelectorCodeGenerator::generateAddStyleRelationIfResolvingStyle(Assembler::RegisterID element, Style::Relation::Type relationType, Optional&lt;Assembler::RegisterID&gt; value)
2233 {
2234     if (m_selectorContext == SelectorContext::QuerySelector)
2235         return;
2236 
2237     LocalRegister checkingContext(m_registerAllocator);
2238     Assembler::Jump notResolvingStyle = jumpIfNotResolvingStyle(checkingContext);
2239 
2240     generateAddStyleRelation(checkingContext, element, relationType, value);
2241 
2242     notResolvingStyle.link(&amp;m_assembler);
2243 }
2244 
2245 static void addStyleRelationFunction(SelectorChecker::CheckingContext* checkingContext, const Element* element)
2246 {
2247     checkingContext-&gt;styleRelations.append({ *element, Style::Relation::AffectedByActive, 1 });
2248 }
2249 
2250 void SelectorCodeGenerator::generateAddStyleRelation(Assembler::RegisterID checkingContext, Assembler::RegisterID element, Style::Relation::Type relationType, Optional&lt;Assembler::RegisterID&gt; value)
2251 {
2252     ASSERT(m_selectorContext != SelectorContext::QuerySelector);
2253 
2254     Assembler::Address vectorAddress(checkingContext, OBJECT_OFFSETOF(SelectorChecker::CheckingContext, styleRelations));
2255     auto dataAddress = vectorAddress.withOffset(Style::Relations::dataMemoryOffset());
2256     auto sizeAddress = vectorAddress.withOffset(Style::Relations::sizeMemoryOffset());
2257 
2258     auto getLastRelationPointer = [&amp;] (Assembler::RegisterID sizeAndTarget) {
2259         m_assembler.sub32(Assembler::TrustedImm32(1), sizeAndTarget);
2260 #if CPU(ADDRESS64)
2261         static_assert(sizeof(Style::Relation) == 16, &quot;&quot;);
2262         static_assert(1 &lt;&lt; 4 == 16, &quot;&quot;);
2263         m_assembler.lshiftPtr(Assembler::TrustedImm32(4), sizeAndTarget);
2264 #else
2265         m_assembler.mul32(Assembler::TrustedImm32(sizeof(Style::Relation)), sizeAndTarget, sizeAndTarget);
2266 #endif
2267         m_assembler.addPtr(dataAddress, sizeAndTarget);
2268     };
2269 
2270     // For AffectsNextSibling we just increment the count if the previous added relation was in the same sibling chain.
2271     Assembler::JumpList mergeSuccess;
2272     if (relationType == Style::Relation::AffectsNextSibling) {
2273         Assembler::JumpList mergeFailure;
2274 
2275         LocalRegister lastRelation(m_registerAllocator);
2276         m_assembler.load32(sizeAddress, lastRelation);
2277 
2278         // if (!checkingContext.styleRelations.isEmpty())
2279         mergeFailure.append(m_assembler.branchTest32(Assembler::Zero, lastRelation));
2280 
2281         // Style::Relation&amp; lastRelation = checkingContext.styleRelations.last();
2282         getLastRelationPointer(lastRelation);
2283 
2284         // if (lastRelation.type == Style::Relation::AffectsNextSibling)
2285         Assembler::Address typeAddress(lastRelation, OBJECT_OFFSETOF(Style::Relation, type));
2286         mergeFailure.append(m_assembler.branch32(Assembler::NotEqual, typeAddress, Assembler::TrustedImm32(Style::Relation::AffectsNextSibling)));
2287 
2288         Assembler::Address elementAddress(lastRelation, OBJECT_OFFSETOF(Style::Relation, element));
2289         {
2290             // if (element.nextSiblingElement() == lastRelation.element)
2291             LocalRegister nextSiblingElement(m_registerAllocator);
2292             m_assembler.move(element, nextSiblingElement);
2293             generateWalkToNextAdjacentElement(mergeFailure, nextSiblingElement);
2294             mergeFailure.append(m_assembler.branchPtr(Assembler::NotEqual, nextSiblingElement, elementAddress));
2295         }
2296 
2297         // ++lastRelation.value;
2298         Assembler::Address valueAddress(lastRelation, OBJECT_OFFSETOF(Style::Relation, value));
2299         m_assembler.add32(Assembler::TrustedImm32(1), valueAddress);
2300 
2301         // lastRelation.element = &amp;element;
2302         m_assembler.storePtr(element, elementAddress);
2303 
2304         mergeSuccess.append(m_assembler.jump());
2305         mergeFailure.link(&amp;m_assembler);
2306     }
2307 
2308     // FIXME: Append to vector without a function call at least when there is sufficient capacity.
2309     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
2310     functionCall.setFunctionAddress(addStyleRelationFunction);
2311     functionCall.setTwoArguments(checkingContext, element);
2312     functionCall.call();
2313 
2314     LocalRegister relationPointer(m_registerAllocator);
2315     m_assembler.load32(sizeAddress, relationPointer);
2316     getLastRelationPointer(relationPointer);
2317 
2318     Assembler::Address typeAddress(relationPointer, OBJECT_OFFSETOF(Style::Relation, type));
2319     m_assembler.store32(Assembler::TrustedImm32(relationType), typeAddress);
2320 
2321     if (value) {
2322         Assembler::Address valueAddress(relationPointer, OBJECT_OFFSETOF(Style::Relation, value));
2323         m_assembler.store32(*value, valueAddress);
2324     }
2325 
2326     mergeSuccess.link(&amp;m_assembler);
2327 }
2328 
2329 Assembler::JumpList SelectorCodeGenerator::jumpIfNoPreviousAdjacentElement()
2330 {
2331     Assembler::JumpList successCase;
2332     LocalRegister previousSibling(m_registerAllocator);
2333     m_assembler.move(elementAddressRegister, previousSibling);
2334     generateWalkToPreviousAdjacentElement(successCase, previousSibling);
2335     return successCase;
2336 }
2337 
2338 Assembler::JumpList SelectorCodeGenerator::jumpIfNoNextAdjacentElement()
2339 {
2340     Assembler::JumpList successCase;
2341     LocalRegister nextSibling(m_registerAllocator);
2342     m_assembler.move(elementAddressRegister, nextSibling);
2343     generateWalkToNextAdjacentElement(successCase, nextSibling);
2344     return successCase;
2345 }
2346 
2347 
2348 void SelectorCodeGenerator::loadCheckingContext(Assembler::RegisterID checkingContext)
2349 {
2350     // Get the checking context.
2351     RELEASE_ASSERT(m_functionType == FunctionType::SelectorCheckerWithCheckingContext);
2352     m_assembler.loadPtr(m_stackAllocator.addressOf(m_checkingContextStackReference), checkingContext);
2353 }
2354 
2355 Assembler::Jump SelectorCodeGenerator::branchOnResolvingModeWithCheckingContext(Assembler::RelationalCondition condition, SelectorChecker::Mode mode, Assembler::RegisterID checkingContext)
2356 {
2357     // Depend on the specified resolving mode and our current mode, branch.
2358     static_assert(sizeof(SelectorChecker::Mode) == 1, &quot;We generate a byte load/test for the SelectorChecker::Mode.&quot;);
2359     return m_assembler.branch8(condition, Assembler::Address(checkingContext, OBJECT_OFFSETOF(SelectorChecker::CheckingContext, resolvingMode)), Assembler::TrustedImm32(static_cast&lt;std::underlying_type&lt;SelectorChecker::Mode&gt;::type&gt;(mode)));
2360 
2361 }
2362 
2363 Assembler::Jump SelectorCodeGenerator::branchOnResolvingMode(Assembler::RelationalCondition condition, SelectorChecker::Mode mode, Assembler::RegisterID checkingContext)
2364 {
2365     loadCheckingContext(checkingContext);
2366     return branchOnResolvingModeWithCheckingContext(condition, mode, checkingContext);
2367 }
2368 
2369 Assembler::Jump SelectorCodeGenerator::jumpIfNotResolvingStyle(Assembler::RegisterID checkingContext)
2370 {
2371     return branchOnResolvingMode(Assembler::NotEqual, SelectorChecker::Mode::ResolvingStyle, checkingContext);
2372 }
2373 
2374 void SelectorCodeGenerator::generateSpecialFailureInQuirksModeForActiveAndHoverIfNeeded(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2375 {
2376     if (fragment.onlyMatchesLinksInQuirksMode) {
2377         // If the element is a link, it can always match :hover or :active.
2378         Assembler::Jump isLink = m_assembler.branchTest32(Assembler::NonZero, Assembler::Address(elementAddressRegister, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagIsLink()));
2379 
2380         // Only quirks mode restrict :hover and :active.
2381         static_assert(sizeof(DocumentCompatibilityMode) == 1, &quot;We generate a byte load/test for the compatibility mode.&quot;);
2382         LocalRegister documentAddress(m_registerAllocator);
2383         DOMJIT::loadDocument(m_assembler, elementAddressRegister, documentAddress);
2384         failureCases.append(m_assembler.branchTest8(Assembler::NonZero, Assembler::Address(documentAddress, Document::compatibilityModeMemoryOffset()), Assembler::TrustedImm32(static_cast&lt;std::underlying_type&lt;DocumentCompatibilityMode&gt;::type&gt;(DocumentCompatibilityMode::QuirksMode))));
2385 
2386         isLink.link(&amp;m_assembler);
2387     }
2388 }
2389 
2390 #if CPU(ARM_THUMB2) &amp;&amp; !CPU(APPLE_ARMV7S)
2391 // FIXME: This could be implemented in assembly to avoid a function call, and we know the divisor at jit-compile time.
2392 static int moduloHelper(int dividend, int divisor)
2393 {
2394     return dividend % divisor;
2395 }
2396 #endif
2397 
2398 // The value in inputDividend is destroyed by the modulo operation.
2399 Assembler::Jump SelectorCodeGenerator::modulo(Assembler::ResultCondition condition, Assembler::RegisterID inputDividend, int divisor)
2400 {
2401     RELEASE_ASSERT(divisor);
2402 #if CPU(ARM64) || CPU(APPLE_ARMV7S)
2403     LocalRegister divisorRegister(m_registerAllocator);
2404     m_assembler.move(Assembler::TrustedImm32(divisor), divisorRegister);
2405 
2406     LocalRegister resultRegister(m_registerAllocator);
2407     m_assembler.m_assembler.sdiv&lt;32&gt;(resultRegister, inputDividend, divisorRegister);
2408     m_assembler.mul32(divisorRegister, resultRegister);
2409     return m_assembler.branchSub32(condition, inputDividend, resultRegister, resultRegister);
2410 #elif CPU(ARM_THUMB2) &amp;&amp; !CPU(APPLE_ARMV7S)
2411     LocalRegisterWithPreference divisorRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
2412     m_assembler.move(Assembler::TrustedImm32(divisor), divisorRegister);
2413     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
2414     functionCall.setFunctionAddress(moduloHelper);
2415     functionCall.setTwoArguments(inputDividend, divisorRegister);
2416     return functionCall.callAndBranchOnBooleanReturnValue(condition);
2417 #elif CPU(X86_64)
2418     // idiv takes RAX + an arbitrary register, and return RAX + RDX. Most of this code is about doing
2419     // an efficient allocation of those registers. If a register is already in use and is not the inputDividend,
2420     // we first try to copy it to a temporary register, it that is not possible we fall back to the stack.
2421     enum class RegisterAllocationType {
2422         External,
2423         AllocatedLocally,
2424         CopiedToTemporary,
2425         PushedToStack
2426     };
2427 
2428     // 1) Get RAX and RDX.
2429     // If they are already used, push them to the stack.
2430     Assembler::RegisterID dividend = JSC::X86Registers::eax;
2431     RegisterAllocationType dividendAllocation = RegisterAllocationType::External;
2432     StackAllocator::StackReference temporaryDividendStackReference;
2433     Assembler::RegisterID temporaryDividendCopy = JSC::InvalidGPRReg;
2434     if (inputDividend != dividend) {
2435         bool registerIsInUse = m_registerAllocator.allocatedRegisters().contains(dividend);
2436         if (registerIsInUse) {
2437             if (m_registerAllocator.availableRegisterCount() &gt; 1) {
2438                 temporaryDividendCopy = m_registerAllocator.allocateRegister();
2439                 m_assembler.move(dividend, temporaryDividendCopy);
2440                 dividendAllocation = RegisterAllocationType::CopiedToTemporary;
2441             } else {
2442                 temporaryDividendStackReference = m_stackAllocator.push(dividend);
2443                 dividendAllocation = RegisterAllocationType::PushedToStack;
2444             }
2445         } else {
2446             m_registerAllocator.allocateRegister(dividend);
2447             dividendAllocation = RegisterAllocationType::AllocatedLocally;
2448         }
2449         m_assembler.move(inputDividend, dividend);
2450     }
2451 
2452     Assembler::RegisterID remainder = JSC::X86Registers::edx;
2453     RegisterAllocationType remainderAllocation = RegisterAllocationType::External;
2454     StackAllocator::StackReference temporaryRemainderStackReference;
2455     Assembler::RegisterID temporaryRemainderCopy = JSC::InvalidGPRReg;
2456     if (inputDividend != remainder) {
2457         bool registerIsInUse = m_registerAllocator.allocatedRegisters().contains(remainder);
2458         if (registerIsInUse) {
2459             if (m_registerAllocator.availableRegisterCount() &gt; 1) {
2460                 temporaryRemainderCopy = m_registerAllocator.allocateRegister();
2461                 m_assembler.move(remainder, temporaryRemainderCopy);
2462                 remainderAllocation = RegisterAllocationType::CopiedToTemporary;
2463             } else {
2464                 temporaryRemainderStackReference = m_stackAllocator.push(remainder);
2465                 remainderAllocation = RegisterAllocationType::PushedToStack;
2466             }
2467         } else {
2468             m_registerAllocator.allocateRegister(remainder);
2469             remainderAllocation = RegisterAllocationType::AllocatedLocally;
2470         }
2471     }
2472 
2473     // If the input register is used by idiv, save its value to restore it after the operation.
<a name="6" id="anc6"></a><span class="line-modified">2474     Assembler::RegisterID inputDividendCopy = JSC::InvalidGPRReg;</span>
2475     StackAllocator::StackReference pushedInputDividendStackReference;
2476     RegisterAllocationType savedInputDividendAllocationType = RegisterAllocationType::External;
2477     if (inputDividend == dividend || inputDividend == remainder) {
2478         if (m_registerAllocator.availableRegisterCount() &gt; 1) {
2479             inputDividendCopy = m_registerAllocator.allocateRegister();
2480             m_assembler.move(inputDividend, inputDividendCopy);
2481             savedInputDividendAllocationType = RegisterAllocationType::CopiedToTemporary;
2482         } else {
2483             pushedInputDividendStackReference = m_stackAllocator.push(inputDividend);
2484             savedInputDividendAllocationType = RegisterAllocationType::PushedToStack;
2485         }
2486     }
2487 
2488     m_assembler.m_assembler.cdq();
2489 
2490     // 2) Perform the division with idiv.
2491     {
2492         LocalRegister divisorRegister(m_registerAllocator);
2493         m_assembler.move(Assembler::TrustedImm64(divisor), divisorRegister);
2494         m_assembler.m_assembler.idivl_r(divisorRegister);
2495         m_assembler.test32(remainder);
2496     }
2497 
2498     // 3) Return RAX and RDX.
2499     if (remainderAllocation == RegisterAllocationType::AllocatedLocally)
2500         m_registerAllocator.deallocateRegister(remainder);
2501     else if (remainderAllocation == RegisterAllocationType::CopiedToTemporary) {
2502         m_assembler.move(temporaryRemainderCopy, remainder);
2503         m_registerAllocator.deallocateRegister(temporaryRemainderCopy);
2504     } else if (remainderAllocation == RegisterAllocationType::PushedToStack)
2505         m_stackAllocator.pop(temporaryRemainderStackReference, remainder);
2506 
2507     if (dividendAllocation == RegisterAllocationType::AllocatedLocally)
2508         m_registerAllocator.deallocateRegister(dividend);
2509     else if (dividendAllocation == RegisterAllocationType::CopiedToTemporary) {
2510         m_assembler.move(temporaryDividendCopy, dividend);
2511         m_registerAllocator.deallocateRegister(temporaryDividendCopy);
2512     } else if (dividendAllocation == RegisterAllocationType::PushedToStack)
2513         m_stackAllocator.pop(temporaryDividendStackReference, dividend);
2514 
2515     if (savedInputDividendAllocationType != RegisterAllocationType::External) {
2516         if (savedInputDividendAllocationType == RegisterAllocationType::CopiedToTemporary) {
2517             m_assembler.move(inputDividendCopy, inputDividend);
2518             m_registerAllocator.deallocateRegister(inputDividendCopy);
2519         } else if (savedInputDividendAllocationType == RegisterAllocationType::PushedToStack)
2520             m_stackAllocator.pop(pushedInputDividendStackReference, inputDividend);
2521     }
2522 
2523     // 4) Branch on the test.
2524     return m_assembler.branch(condition);
2525 #else
2526 #error Modulo is not implemented for this architecture.
2527 #endif
2528 }
2529 
2530 void SelectorCodeGenerator::moduloIsZero(Assembler::JumpList&amp; failureCases, Assembler::RegisterID inputDividend, int divisor)
2531 {
2532     if (divisor == 1 || divisor == -1)
2533         return;
2534     if (divisor == 2 || divisor == -2) {
2535         failureCases.append(m_assembler.branchTest32(Assembler::NonZero, inputDividend, Assembler::TrustedImm32(1)));
2536         return;
2537     }
2538 
2539     failureCases.append(modulo(Assembler::NonZero, inputDividend, divisor));
2540 }
2541 
2542 void SelectorCodeGenerator::linkFailures(Assembler::JumpList&amp; globalFailureCases, BacktrackingAction backtrackingAction, Assembler::JumpList&amp; localFailureCases)
2543 {
2544     switch (backtrackingAction) {
2545     case BacktrackingAction::NoBacktracking:
2546         globalFailureCases.append(localFailureCases);
2547         break;
2548     case BacktrackingAction::JumpToDescendantEntryPoint:
2549         localFailureCases.linkTo(m_backtrackingLevels.last().descendantEntryPoint, &amp;m_assembler);
2550         break;
2551     case BacktrackingAction::JumpToDescendantTreeWalkerEntryPoint:
2552         localFailureCases.linkTo(m_backtrackingLevels.last().descendantTreeWalkerBacktrackingPoint, &amp;m_assembler);
2553         break;
2554     case BacktrackingAction::JumpToDescendantTail:
2555         m_backtrackingLevels.last().descendantBacktrackingFailureCases.append(localFailureCases);
2556         break;
2557     case BacktrackingAction::JumpToIndirectAdjacentEntryPoint:
2558         localFailureCases.linkTo(m_backtrackingLevels.last().indirectAdjacentEntryPoint, &amp;m_assembler);
2559         break;
2560     case BacktrackingAction::JumpToIndirectAdjacentTreeWalkerEntryPoint:
2561         localFailureCases.linkTo(m_backtrackingLevels.last().indirectAdjacentTreeWalkerBacktrackingPoint, &amp;m_assembler);
2562         break;
2563     case BacktrackingAction::JumpToDirectAdjacentTail:
2564         m_backtrackingLevels.last().adjacentBacktrackingFailureCases.append(localFailureCases);
2565         break;
2566     }
2567 }
2568 
2569 void SelectorCodeGenerator::generateAdjacentBacktrackingTail()
2570 {
2571     // Recovering tail.
2572     m_backtrackingLevels.last().adjacentBacktrackingFailureCases.link(&amp;m_assembler);
2573     m_backtrackingLevels.last().adjacentBacktrackingFailureCases.clear();
2574 
2575     BacktrackingLevel&amp; currentBacktrackingLevel = m_backtrackingLevels.last();
2576     m_assembler.loadPtr(m_stackAllocator.addressOf(currentBacktrackingLevel.adjacentBacktrackingStart), elementAddressRegister);
2577     m_backtrackingStack.append(currentBacktrackingLevel.adjacentBacktrackingStart);
2578     currentBacktrackingLevel.adjacentBacktrackingStart = StackAllocator::StackReference();
2579 
2580     m_assembler.jump(m_backtrackingLevels.last().indirectAdjacentEntryPoint);
2581 }
2582 
2583 void SelectorCodeGenerator::generateDescendantBacktrackingTail()
2584 {
2585     m_backtrackingLevels.last().descendantBacktrackingFailureCases.link(&amp;m_assembler);
2586     m_backtrackingLevels.last().descendantBacktrackingFailureCases.clear();
2587 
2588     BacktrackingLevel&amp; currentBacktrackingLevel = m_backtrackingLevels.last();
2589     if (!currentBacktrackingLevel.descendantBacktrackingStart.isValid()) {
2590         m_assembler.move(m_descendantBacktrackingStart, elementAddressRegister);
2591         m_registerAllocator.deallocateRegister(m_descendantBacktrackingStart);
2592         m_descendantBacktrackingStartInUse = false;
2593     } else {
2594         m_assembler.loadPtr(m_stackAllocator.addressOf(currentBacktrackingLevel.descendantBacktrackingStart), elementAddressRegister);
2595         m_backtrackingStack.append(currentBacktrackingLevel.descendantBacktrackingStart);
2596         currentBacktrackingLevel.descendantBacktrackingStart = StackAllocator::StackReference();
2597     }
2598 
2599     m_assembler.jump(m_backtrackingLevels.last().descendantEntryPoint);
2600 }
2601 
2602 void SelectorCodeGenerator::generateBacktrackingTailsIfNeeded(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2603 {
2604     if (fragment.backtrackingFlags &amp; BacktrackingFlag::DirectAdjacentTail &amp;&amp; fragment.backtrackingFlags &amp; BacktrackingFlag::DescendantTail) {
2605         Assembler::Jump normalCase = m_assembler.jump();
2606         generateAdjacentBacktrackingTail();
2607         generateDescendantBacktrackingTail();
2608         normalCase.link(&amp;m_assembler);
2609     } else if (fragment.backtrackingFlags &amp; BacktrackingFlag::DirectAdjacentTail) {
2610         Assembler::Jump normalCase = m_assembler.jump();
2611         generateAdjacentBacktrackingTail();
2612         failureCases.append(m_assembler.jump());
2613         normalCase.link(&amp;m_assembler);
2614     } else if (fragment.backtrackingFlags &amp; BacktrackingFlag::DescendantTail) {
2615         Assembler::Jump normalCase = m_assembler.jump();
2616         generateDescendantBacktrackingTail();
2617         normalCase.link(&amp;m_assembler);
2618     }
2619 }
2620 
2621 void SelectorCodeGenerator::generateElementMatching(Assembler::JumpList&amp; matchingTagNameFailureCases, Assembler::JumpList&amp; matchingPostTagNameFailureCases, const SelectorFragment&amp; fragment)
2622 {
2623     if (fragment.tagNameSelector)
2624         generateElementHasTagName(matchingTagNameFailureCases, *(fragment.tagNameSelector));
2625 
2626     generateElementLinkMatching(matchingPostTagNameFailureCases, fragment);
2627 
2628     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassRoot))
2629         generateElementIsRoot(matchingPostTagNameFailureCases);
2630 
2631     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassScope))
2632         generateElementIsScopeRoot(matchingPostTagNameFailureCases);
2633 
2634     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassTarget))
2635         generateElementIsTarget(matchingPostTagNameFailureCases);
2636 
2637     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassFocusWithin))
2638         generateElementHasFocusWithin(matchingPostTagNameFailureCases);
2639 
2640     for (unsigned i = 0; i &lt; fragment.unoptimizedPseudoClasses.size(); ++i)
2641         generateElementFunctionCallTest(matchingPostTagNameFailureCases, fragment.unoptimizedPseudoClasses[i]);
2642 
2643     for (unsigned i = 0; i &lt; fragment.unoptimizedPseudoClassesWithContext.size(); ++i)
2644         generateContextFunctionCallTest(matchingPostTagNameFailureCases, fragment.unoptimizedPseudoClassesWithContext[i]);
2645 
2646     generateElementDataMatching(matchingPostTagNameFailureCases, fragment);
2647 
2648     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassActive))
2649         generateElementIsActive(matchingPostTagNameFailureCases, fragment);
2650     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassEmpty))
2651         generateElementIsEmpty(matchingPostTagNameFailureCases);
2652     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassHover))
2653         generateElementIsHovered(matchingPostTagNameFailureCases, fragment);
2654     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassOnlyChild))
2655         generateElementIsOnlyChild(matchingPostTagNameFailureCases);
2656     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassPlaceholderShown))
2657         generateElementHasPlaceholderShown(matchingPostTagNameFailureCases);
2658     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassFirstChild))
2659         generateElementIsFirstChild(matchingPostTagNameFailureCases);
2660     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassLastChild))
2661         generateElementIsLastChild(matchingPostTagNameFailureCases);
2662     if (!fragment.nthChildFilters.isEmpty())
2663         generateElementIsNthChild(matchingPostTagNameFailureCases, fragment);
2664     if (!fragment.nthLastChildFilters.isEmpty())
2665         generateElementIsNthLastChild(matchingPostTagNameFailureCases, fragment);
2666     if (!fragment.notFilters.isEmpty())
2667         generateElementMatchesNotPseudoClass(matchingPostTagNameFailureCases, fragment);
2668     if (!fragment.anyFilters.isEmpty())
2669         generateElementMatchesAnyPseudoClass(matchingPostTagNameFailureCases, fragment);
2670     if (!fragment.matchesFilters.isEmpty())
2671         generateElementMatchesMatchesPseudoClass(matchingPostTagNameFailureCases, fragment);
2672     if (!fragment.languageArgumentsList.isEmpty())
2673         generateElementIsInLanguage(matchingPostTagNameFailureCases, fragment);
2674     if (!fragment.nthChildOfFilters.isEmpty())
2675         generateElementIsNthChildOf(matchingPostTagNameFailureCases, fragment);
2676     if (!fragment.nthLastChildOfFilters.isEmpty())
2677         generateElementIsNthLastChildOf(matchingPostTagNameFailureCases, fragment);
2678     if (fragment.pseudoElementSelector)
2679         generateElementHasPseudoElement(matchingPostTagNameFailureCases, fragment);
2680 
2681     // Reach here when the generateElementMatching matching succeeded.
2682     // Only when the matching succeeeded, the last visited element should be stored and checked at the end of the whole matching.
2683     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassVisited))
2684         generateStoreLastVisitedElement(elementAddressRegister);
2685 }
2686 
2687 void SelectorCodeGenerator::generateElementDataMatching(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2688 {
2689     if (!fragment.id &amp;&amp; fragment.classNames.isEmpty() &amp;&amp; fragment.attributes.isEmpty())
2690         return;
2691 
2692     //  Generate:
2693     //     elementDataAddress = element-&gt;elementData();
2694     //     if (!elementDataAddress)
2695     //         failure!
2696     LocalRegister elementDataAddress(m_registerAllocator);
2697     m_assembler.loadPtr(Assembler::Address(elementAddressRegister, Element::elementDataMemoryOffset()), elementDataAddress);
2698     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, elementDataAddress));
2699 
2700     if (fragment.id)
2701         generateElementHasId(failureCases, elementDataAddress, *fragment.id);
2702     if (!fragment.classNames.isEmpty())
2703         generateElementHasClasses(failureCases, elementDataAddress, fragment.classNames);
2704     if (!fragment.attributes.isEmpty())
2705         generateElementAttributesMatching(failureCases, elementDataAddress, fragment);
2706 }
2707 
2708 void SelectorCodeGenerator::generateElementLinkMatching(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2709 {
2710     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassLink)
2711         || fragment.pseudoClasses.contains(CSSSelector::PseudoClassAnyLink)
2712         || fragment.pseudoClasses.contains(CSSSelector::PseudoClassVisited))
2713         generateElementIsLink(failureCases);
2714 }
2715 
2716 static inline bool canMatchStyleAttribute(const SelectorFragment&amp; fragment)
2717 {
2718     for (unsigned i = 0; i &lt; fragment.attributes.size(); ++i) {
2719         const CSSSelector&amp; attributeSelector = fragment.attributes[i].selector();
2720         const QualifiedName&amp; attributeName = attributeSelector.attribute();
2721         if (Attribute::nameMatchesFilter(HTMLNames::styleAttr, attributeName.prefix(), attributeName.localName(), attributeName.namespaceURI()))
2722             return true;
2723 
2724         const AtomString&amp; canonicalLocalName = attributeSelector.attributeCanonicalLocalName();
2725         if (attributeName.localName() != canonicalLocalName
2726             &amp;&amp; Attribute::nameMatchesFilter(HTMLNames::styleAttr, attributeName.prefix(), attributeSelector.attributeCanonicalLocalName(), attributeName.namespaceURI())) {
2727             return true;
2728         }
2729     }
2730     return false;
2731 }
2732 
2733 void SelectorCodeGenerator::generateSynchronizeStyleAttribute(Assembler::RegisterID elementDataArraySizeAndFlags)
2734 {
2735     // The style attribute is updated lazily based on the flag styleAttributeIsDirty.
2736     Assembler::Jump styleAttributeNotDirty = m_assembler.branchTest32(Assembler::Zero, elementDataArraySizeAndFlags, Assembler::TrustedImm32(ElementData::styleAttributeIsDirtyFlag()));
2737 
2738     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
2739     functionCall.setFunctionAddress(StyledElement::synchronizeStyleAttributeInternal);
2740     Assembler::RegisterID elementAddress = elementAddressRegister;
2741     functionCall.setOneArgument(elementAddress);
2742     functionCall.call();
2743 
2744     styleAttributeNotDirty.link(&amp;m_assembler);
2745 }
2746 
2747 static inline bool canMatchAnimatableSVGAttribute(const SelectorFragment&amp; fragment)
2748 {
2749     for (unsigned i = 0; i &lt; fragment.attributes.size(); ++i) {
2750         const CSSSelector&amp; attributeSelector = fragment.attributes[i].selector();
2751         const QualifiedName&amp; selectorAttributeName = attributeSelector.attribute();
2752 
2753         const QualifiedName&amp; candidateForLocalName = SVGElement::animatableAttributeForName(selectorAttributeName.localName());
2754         if (Attribute::nameMatchesFilter(candidateForLocalName, selectorAttributeName.prefix(), selectorAttributeName.localName(), selectorAttributeName.namespaceURI()))
2755             return true;
2756 
2757         const AtomString&amp; canonicalLocalName = attributeSelector.attributeCanonicalLocalName();
2758         if (selectorAttributeName.localName() != canonicalLocalName) {
2759             const QualifiedName&amp; candidateForCanonicalLocalName = SVGElement::animatableAttributeForName(selectorAttributeName.localName());
2760             if (Attribute::nameMatchesFilter(candidateForCanonicalLocalName, selectorAttributeName.prefix(), selectorAttributeName.localName(), selectorAttributeName.namespaceURI()))
2761                 return true;
2762         }
2763     }
2764     return false;
2765 }
2766 
2767 void SelectorCodeGenerator::generateSynchronizeAllAnimatedSVGAttribute(Assembler::RegisterID elementDataArraySizeAndFlags)
2768 {
2769     // SVG attributes can be updated lazily depending on the flag AnimatedSVGAttributesAreDirty. We need to check
2770     // that first.
2771     Assembler::Jump animatedSVGAttributesNotDirty = m_assembler.branchTest32(Assembler::Zero, elementDataArraySizeAndFlags, Assembler::TrustedImm32(ElementData::animatedSVGAttributesAreDirtyFlag()));
2772 
2773     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
2774     functionCall.setFunctionAddress(SVGElement::synchronizeAllAnimatedSVGAttribute);
2775     Assembler::RegisterID elementAddress = elementAddressRegister;
2776     functionCall.setOneArgument(elementAddress);
2777     functionCall.call();
2778 
2779     animatedSVGAttributesNotDirty.link(&amp;m_assembler);
2780 }
2781 
2782 void SelectorCodeGenerator::generateElementAttributesMatching(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const SelectorFragment&amp; fragment)
2783 {
2784     LocalRegister scratchRegister(m_registerAllocator);
2785     Assembler::RegisterID elementDataArraySizeAndFlags = scratchRegister;
2786     Assembler::RegisterID attributeArrayLength = scratchRegister;
2787 
2788     m_assembler.load32(Assembler::Address(elementDataAddress, ElementData::arraySizeAndFlagsMemoryOffset()), elementDataArraySizeAndFlags);
2789 
2790     if (canMatchStyleAttribute(fragment))
2791         generateSynchronizeStyleAttribute(elementDataArraySizeAndFlags);
2792 
2793     if (canMatchAnimatableSVGAttribute(fragment))
2794         generateSynchronizeAllAnimatedSVGAttribute(elementDataArraySizeAndFlags);
2795 
2796     // Attributes can be stored either in a separate vector for UniqueElementData, or after the elementData itself
2797     // for ShareableElementData.
2798     LocalRegister attributeArrayPointer(m_registerAllocator);
2799     Assembler::Jump isShareableElementData  = m_assembler.branchTest32(Assembler::Zero, elementDataArraySizeAndFlags, Assembler::TrustedImm32(ElementData::isUniqueFlag()));
2800     {
2801         ptrdiff_t attributeVectorOffset = UniqueElementData::attributeVectorMemoryOffset();
2802         m_assembler.loadPtr(Assembler::Address(elementDataAddress, attributeVectorOffset + UniqueElementData::AttributeVector::dataMemoryOffset()), attributeArrayPointer);
2803         m_assembler.load32(Assembler::Address(elementDataAddress, attributeVectorOffset + UniqueElementData::AttributeVector::sizeMemoryOffset()), attributeArrayLength);
2804     }
2805     Assembler::Jump skipShareable = m_assembler.jump();
2806 
2807     {
2808         isShareableElementData.link(&amp;m_assembler);
2809         m_assembler.urshift32(elementDataArraySizeAndFlags, Assembler::TrustedImm32(ElementData::arraySizeOffset()), attributeArrayLength);
2810         m_assembler.addPtr(Assembler::TrustedImm32(ShareableElementData::attributeArrayMemoryOffset()), elementDataAddress, attributeArrayPointer);
2811     }
2812 
2813     skipShareable.link(&amp;m_assembler);
2814 
2815     // If there are no attributes, fail immediately.
2816     failureCases.append(m_assembler.branchTest32(Assembler::Zero, attributeArrayLength));
2817 
2818     unsigned attributeCount = fragment.attributes.size();
2819     for (unsigned i = 0; i &lt; attributeCount; ++i) {
2820         Assembler::RegisterID decIndexRegister;
2821         Assembler::RegisterID currentAttributeAddress;
2822 
2823         bool isLastAttribute = i == (attributeCount - 1);
2824         if (!isLastAttribute) {
2825             // We need to make a copy to let the next iterations use the values.
2826             currentAttributeAddress = m_registerAllocator.allocateRegister();
2827             decIndexRegister = m_registerAllocator.allocateRegister();
2828             m_assembler.move(attributeArrayPointer, currentAttributeAddress);
2829             m_assembler.move(attributeArrayLength, decIndexRegister);
2830         } else {
2831             currentAttributeAddress = attributeArrayPointer;
2832             decIndexRegister = attributeArrayLength;
2833         }
2834 
2835         generateElementAttributeMatching(failureCases, currentAttributeAddress, decIndexRegister, fragment.attributes[i]);
2836 
2837         if (!isLastAttribute) {
2838             m_registerAllocator.deallocateRegister(decIndexRegister);
2839             m_registerAllocator.deallocateRegister(currentAttributeAddress);
2840         }
2841     }
2842 }
2843 
2844 void SelectorCodeGenerator::generateElementAttributeMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, Assembler::RegisterID decIndexRegister, const AttributeMatchingInfo&amp; attributeInfo)
2845 {
2846     // Get the localName used for comparison. HTML elements use a lowercase local name known in selectors as canonicalLocalName.
2847     LocalRegister localNameToMatch(m_registerAllocator);
2848 
2849     // In general, canonicalLocalName and localName are the same. When they differ, we have to check if the node is HTML to know
2850     // which one to use.
2851     const CSSSelector&amp; attributeSelector = attributeInfo.selector();
2852     const AtomStringImpl* canonicalLocalName = attributeSelector.attributeCanonicalLocalName().impl();
2853     const AtomStringImpl* localName = attributeSelector.attribute().localName().impl();
2854     if (canonicalLocalName == localName)
2855         m_assembler.move(Assembler::TrustedImmPtr(canonicalLocalName), localNameToMatch);
2856     else {
2857         m_assembler.move(Assembler::TrustedImmPtr(canonicalLocalName), localNameToMatch);
2858         Assembler::Jump elementIsHTML = DOMJIT::branchTestIsHTMLFlagOnNode(m_assembler, Assembler::NonZero, elementAddressRegister);
2859         m_assembler.move(Assembler::TrustedImmPtr(localName), localNameToMatch);
2860         elementIsHTML.link(&amp;m_assembler);
2861     }
2862 
2863     Assembler::JumpList successCases;
2864     Assembler::Label loopStart(m_assembler.label());
2865 
2866     {
2867         LocalRegister qualifiedNameImpl(m_registerAllocator);
2868         m_assembler.loadPtr(Assembler::Address(currentAttributeAddress, Attribute::nameMemoryOffset()), qualifiedNameImpl);
2869 
2870         bool shouldCheckNamespace = attributeSelector.attribute().prefix() != starAtom();
2871         if (shouldCheckNamespace) {
2872             Assembler::Jump nameDoesNotMatch = m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), localNameToMatch);
2873 
2874             const AtomStringImpl* namespaceURI = attributeSelector.attribute().namespaceURI().impl();
2875             if (namespaceURI) {
2876                 LocalRegister namespaceToMatch(m_registerAllocator);
2877                 m_assembler.move(Assembler::TrustedImmPtr(namespaceURI), namespaceToMatch);
2878                 successCases.append(m_assembler.branchPtr(Assembler::Equal, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::namespaceMemoryOffset()), namespaceToMatch));
2879             } else
2880                 successCases.append(m_assembler.branchTestPtr(Assembler::Zero, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::namespaceMemoryOffset())));
2881             nameDoesNotMatch.link(&amp;m_assembler);
2882         } else
2883             successCases.append(m_assembler.branchPtr(Assembler::Equal, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), localNameToMatch));
2884     }
2885 
2886     Assembler::Label loopReEntry(m_assembler.label());
2887 
2888     // If we reached the last element -&gt; failure.
2889     failureCases.append(m_assembler.branchSub32(Assembler::Zero, Assembler::TrustedImm32(1), decIndexRegister));
2890 
2891     // Otherwise just loop over.
2892     m_assembler.addPtr(Assembler::TrustedImm32(sizeof(Attribute)), currentAttributeAddress);
2893     m_assembler.jump().linkTo(loopStart, &amp;m_assembler);
2894 
2895     successCases.link(&amp;m_assembler);
2896 
2897     if (attributeSelector.match() != CSSSelector::Set) {
2898         // We make the assumption that name matching fails in most cases and we keep value matching outside
2899         // of the loop. We re-enter the loop if needed.
2900         // FIXME: exact case sensitive value matching is so simple that it should be done in the loop.
2901         Assembler::JumpList localFailureCases;
2902         generateElementAttributeValueMatching(localFailureCases, currentAttributeAddress, attributeInfo);
2903         localFailureCases.linkTo(loopReEntry, &amp;m_assembler);
2904     }
2905 }
2906 
2907 enum CaseSensitivity {
2908     CaseSensitive,
2909     CaseInsensitive
2910 };
2911 
2912 template&lt;CaseSensitivity caseSensitivity&gt;
2913 static bool attributeValueBeginsWith(const Attribute* attribute, AtomStringImpl* expectedString)
2914 {
2915     ASSERT(expectedString);
2916 
2917     AtomStringImpl&amp; valueImpl = *attribute-&gt;value().impl();
2918     if (caseSensitivity == CaseSensitive)
2919         return valueImpl.startsWith(*expectedString);
2920     return valueImpl.startsWithIgnoringASCIICase(*expectedString);
2921 }
2922 
2923 template&lt;CaseSensitivity caseSensitivity&gt;
2924 static bool attributeValueContains(const Attribute* attribute, AtomStringImpl* expectedString)
2925 {
2926     AtomStringImpl&amp; valueImpl = *attribute-&gt;value().impl();
2927     if (caseSensitivity == CaseSensitive)
2928         return valueImpl.find(expectedString) != notFound;
2929     return valueImpl.findIgnoringASCIICase(expectedString) != notFound;
2930 }
2931 
2932 template&lt;CaseSensitivity caseSensitivity&gt;
2933 static bool attributeValueEndsWith(const Attribute* attribute, AtomStringImpl* expectedString)
2934 {
2935     ASSERT(expectedString);
2936 
2937     AtomStringImpl&amp; valueImpl = *attribute-&gt;value().impl();
2938     if (caseSensitivity == CaseSensitive)
2939         return valueImpl.endsWith(*expectedString);
2940     return valueImpl.endsWithIgnoringASCIICase(*expectedString);
2941 }
2942 
2943 template&lt;CaseSensitivity caseSensitivity&gt;
2944 static bool attributeValueMatchHyphenRule(const Attribute* attribute, AtomStringImpl* expectedString)
2945 {
2946     ASSERT(expectedString);
2947 
2948     AtomStringImpl&amp; valueImpl = *attribute-&gt;value().impl();
2949     if (valueImpl.length() &lt; expectedString-&gt;length())
2950         return false;
2951 
2952     bool valueStartsWithExpectedString;
2953     if (caseSensitivity == CaseSensitive)
2954         valueStartsWithExpectedString = valueImpl.startsWith(*expectedString);
2955     else
2956         valueStartsWithExpectedString = valueImpl.startsWithIgnoringASCIICase(*expectedString);
2957 
2958     if (!valueStartsWithExpectedString)
2959         return false;
2960 
2961     return valueImpl.length() == expectedString-&gt;length() || valueImpl[expectedString-&gt;length()] == &#39;-&#39;;
2962 }
2963 
2964 template&lt;CaseSensitivity caseSensitivity&gt;
2965 static bool attributeValueSpaceSeparetedListContains(const Attribute* attribute, AtomStringImpl* expectedString)
2966 {
2967     AtomStringImpl&amp; value = *attribute-&gt;value().impl();
2968 
2969     unsigned startSearchAt = 0;
2970     while (true) {
2971         size_t foundPos;
2972         if (caseSensitivity == CaseSensitive)
2973             foundPos = value.find(expectedString, startSearchAt);
2974         else
2975             foundPos = value.findIgnoringASCIICase(expectedString, startSearchAt);
2976         if (foundPos == notFound)
2977             return false;
2978         if (!foundPos || isHTMLSpace(value[foundPos - 1])) {
2979             unsigned endStr = foundPos + expectedString-&gt;length();
2980             if (endStr == value.length() || isHTMLSpace(value[endStr]))
2981                 return true;
2982         }
2983         startSearchAt = foundPos + 1;
2984     }
2985     return false;
2986 }
2987 
2988 void SelectorCodeGenerator::generateElementAttributeValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AttributeMatchingInfo&amp; attributeInfo)
2989 {
2990     const CSSSelector&amp; attributeSelector = attributeInfo.selector();
2991     const AtomString&amp; expectedValue = attributeSelector.value();
2992     ASSERT(!expectedValue.isNull());
2993     AttributeCaseSensitivity valueCaseSensitivity = attributeInfo.attributeCaseSensitivity();
2994 
2995     switch (attributeSelector.match()) {
2996     case CSSSelector::Begin:
2997         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueBeginsWith&lt;CaseSensitive&gt;, attributeValueBeginsWith&lt;CaseInsensitive&gt;);
2998         break;
2999     case CSSSelector::Contain:
3000         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueContains&lt;CaseSensitive&gt;, attributeValueContains&lt;CaseInsensitive&gt;);
3001         break;
3002     case CSSSelector::End:
3003         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueEndsWith&lt;CaseSensitive&gt;, attributeValueEndsWith&lt;CaseInsensitive&gt;);
3004         break;
3005     case CSSSelector::Exact:
3006         generateElementAttributeValueExactMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity);
3007         break;
3008     case CSSSelector::Hyphen:
3009         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueMatchHyphenRule&lt;CaseSensitive&gt;, attributeValueMatchHyphenRule&lt;CaseInsensitive&gt;);
3010         break;
3011     case CSSSelector::List:
3012         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueSpaceSeparetedListContains&lt;CaseSensitive&gt;, attributeValueSpaceSeparetedListContains&lt;CaseInsensitive&gt;);
3013         break;
3014     default:
3015         ASSERT_NOT_REACHED();
3016     }
3017 }
3018 
3019 static inline Assembler::Jump testIsHTMLClassOnDocument(Assembler::ResultCondition condition, Assembler&amp; assembler, Assembler::RegisterID documentAddress)
3020 {
3021     return assembler.branchTest32(condition, Assembler::Address(documentAddress, Document::documentClassesMemoryOffset()), Assembler::TrustedImm32(Document::isHTMLDocumentClassFlag()));
3022 }
3023 
3024 void SelectorCodeGenerator::generateElementAttributeValueExactMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity)
3025 {
3026     LocalRegisterWithPreference expectedValueRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3027     m_assembler.move(Assembler::TrustedImmPtr(expectedValue.impl()), expectedValueRegister);
3028 
3029     switch (valueCaseSensitivity) {
3030     case AttributeCaseSensitivity::CaseSensitive: {
3031         failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(currentAttributeAddress, Attribute::valueMemoryOffset()), expectedValueRegister));
3032         break;
3033     }
3034     case AttributeCaseSensitivity::HTMLLegacyCaseInsensitive: {
3035         Assembler::Jump skipCaseInsensitiveComparison = m_assembler.branchPtr(Assembler::Equal, Assembler::Address(currentAttributeAddress, Attribute::valueMemoryOffset()), expectedValueRegister);
3036 
3037         // If the element is an HTML element, in a HTML dcoument (not including XHTML), value matching is case insensitive.
3038         // Taking the contrapositive, if we find the element is not HTML or is not in a HTML document, the condition above
3039         // sould be sufficient and we can fail early.
3040         failureCases.append(DOMJIT::branchTestIsHTMLFlagOnNode(m_assembler, Assembler::Zero, elementAddressRegister));
3041 
3042         {
3043             LocalRegister document(m_registerAllocator);
3044             DOMJIT::loadDocument(m_assembler, elementAddressRegister, document);
3045             failureCases.append(testIsHTMLClassOnDocument(Assembler::Zero, m_assembler, document));
3046         }
3047 
3048         LocalRegister valueStringImpl(m_registerAllocator);
3049         m_assembler.loadPtr(Assembler::Address(currentAttributeAddress, Attribute::valueMemoryOffset()), valueStringImpl);
3050 
3051         FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3052         functionCall.setFunctionAddress(WTF::equalIgnoringASCIICaseNonNull);
3053         functionCall.setTwoArguments(valueStringImpl, expectedValueRegister);
3054         failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3055 
3056         skipCaseInsensitiveComparison.link(&amp;m_assembler);
3057         break;
3058     }
3059     case AttributeCaseSensitivity::CaseInsensitive: {
3060         LocalRegister valueStringImpl(m_registerAllocator);
3061         m_assembler.loadPtr(Assembler::Address(currentAttributeAddress, Attribute::valueMemoryOffset()), valueStringImpl);
3062 
3063         Assembler::Jump skipCaseInsensitiveComparison = m_assembler.branchPtr(Assembler::Equal, valueStringImpl, expectedValueRegister);
3064         FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3065         functionCall.setFunctionAddress(WTF::equalIgnoringASCIICaseNonNull);
3066         functionCall.setTwoArguments(valueStringImpl, expectedValueRegister);
3067         failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3068         skipCaseInsensitiveComparison.link(&amp;m_assembler);
3069         break;
3070     }
3071     }
3072 }
3073 
3074 void SelectorCodeGenerator::generateElementAttributeFunctionCallValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseSensitiveTest, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseInsensitiveTest)
3075 {
3076     LocalRegisterWithPreference expectedValueRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3077     m_assembler.move(Assembler::TrustedImmPtr(expectedValue.impl()), expectedValueRegister);
3078 
3079 
3080     switch (valueCaseSensitivity) {
3081     case AttributeCaseSensitivity::CaseSensitive: {
3082         FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3083         functionCall.setFunctionAddress(caseSensitiveTest);
3084         functionCall.setTwoArguments(currentAttributeAddress, expectedValueRegister);
3085         failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3086         break;
3087     }
3088     case AttributeCaseSensitivity::HTMLLegacyCaseInsensitive: {
3089         Assembler::JumpList shouldUseCaseSensitiveComparison;
3090         shouldUseCaseSensitiveComparison.append(DOMJIT::branchTestIsHTMLFlagOnNode(m_assembler, Assembler::Zero, elementAddressRegister));
3091         {
3092             LocalRegister scratchRegister(m_registerAllocator);
3093             // scratchRegister = pointer to treeScope.
3094             m_assembler.loadPtr(Assembler::Address(elementAddressRegister, Node::treeScopeMemoryOffset()), scratchRegister);
3095             // scratchRegister = pointer to document.
3096             m_assembler.loadPtr(Assembler::Address(scratchRegister, TreeScope::documentScopeMemoryOffset()), scratchRegister);
3097             shouldUseCaseSensitiveComparison.append(testIsHTMLClassOnDocument(Assembler::Zero, m_assembler, scratchRegister));
3098         }
3099 
3100         {
3101             FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3102             functionCall.setFunctionAddress(caseInsensitiveTest);
3103             functionCall.setTwoArguments(currentAttributeAddress, expectedValueRegister);
3104             failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3105         }
3106 
3107         Assembler::Jump skipCaseSensitiveCase = m_assembler.jump();
3108 
3109         {
3110             shouldUseCaseSensitiveComparison.link(&amp;m_assembler);
3111             FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3112             functionCall.setFunctionAddress(caseSensitiveTest);
3113             functionCall.setTwoArguments(currentAttributeAddress, expectedValueRegister);
3114             failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3115         }
3116 
3117         skipCaseSensitiveCase.link(&amp;m_assembler);
3118         break;
3119     }
3120     case AttributeCaseSensitivity::CaseInsensitive: {
3121         FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3122         functionCall.setFunctionAddress(caseInsensitiveTest);
3123         functionCall.setTwoArguments(currentAttributeAddress, expectedValueRegister);
3124         failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3125         break;
3126     }
3127     }
3128 }
3129 
3130 void SelectorCodeGenerator::generateElementFunctionCallTest(Assembler::JumpList&amp; failureCases, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; testFunction)
3131 {
3132     Assembler::RegisterID elementAddress = elementAddressRegister;
3133     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3134     functionCall.setFunctionAddress(testFunction);
3135     functionCall.setOneArgument(elementAddress);
3136     failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3137 }
3138 
3139 void SelectorCodeGenerator::generateContextFunctionCallTest(Assembler::JumpList&amp; failureCases, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; testFunction)
3140 {
3141     Assembler::RegisterID checkingContext = m_registerAllocator.allocateRegister();
3142     loadCheckingContext(checkingContext);
3143     m_registerAllocator.deallocateRegister(checkingContext);
3144 
3145     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3146     functionCall.setFunctionAddress(testFunction);
3147     functionCall.setOneArgument(checkingContext);
3148     failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3149 }
3150 
3151 static bool elementIsActive(const Element* element)
3152 {
3153     return element-&gt;active() || InspectorInstrumentation::forcePseudoState(*element, CSSSelector::PseudoClassActive);
3154 }
3155 
3156 void SelectorCodeGenerator::generateElementIsActive(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3157 {
3158     generateSpecialFailureInQuirksModeForActiveAndHoverIfNeeded(failureCases, fragment);
3159 
3160     generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::AffectedByActive);
3161 
3162     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3163     functionCall.setFunctionAddress(elementIsActive);
3164     functionCall.setOneArgument(elementAddressRegister);
3165     failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3166 }
3167 
3168 static void jumpIfElementIsNotEmpty(Assembler&amp; assembler, RegisterAllocator&amp; registerAllocator, Assembler::JumpList&amp; notEmptyCases, Assembler::RegisterID element)
3169 {
3170     LocalRegister currentChild(registerAllocator);
3171     assembler.loadPtr(Assembler::Address(element, ContainerNode::firstChildMemoryOffset()), currentChild);
3172 
3173     Assembler::Label loopStart(assembler.label());
3174     Assembler::Jump noMoreChildren = assembler.branchTestPtr(Assembler::Zero, currentChild);
3175 
3176     notEmptyCases.append(DOMJIT::branchTestIsElementFlagOnNode(assembler, Assembler::NonZero, currentChild));
3177 
3178     {
3179         Assembler::Jump skipTextNodeCheck = assembler.branchTest32(Assembler::Zero, Assembler::Address(currentChild, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagIsText()));
3180 
3181         LocalRegister textStringImpl(registerAllocator);
3182         assembler.loadPtr(Assembler::Address(currentChild, CharacterData::dataMemoryOffset()), textStringImpl);
3183         notEmptyCases.append(assembler.branchTest32(Assembler::NonZero, Assembler::Address(textStringImpl, StringImpl::lengthMemoryOffset())));
3184 
3185         skipTextNodeCheck.link(&amp;assembler);
3186     }
3187 
3188     assembler.loadPtr(Assembler::Address(currentChild, Node::nextSiblingMemoryOffset()), currentChild);
3189     assembler.jump().linkTo(loopStart, &amp;assembler);
3190 
3191     noMoreChildren.link(&amp;assembler);
3192 }
3193 
3194 void SelectorCodeGenerator::generateElementIsEmpty(Assembler::JumpList&amp; failureCases)
3195 {
3196     if (m_selectorContext == SelectorContext::QuerySelector) {
3197         jumpIfElementIsNotEmpty(m_assembler, m_registerAllocator, failureCases, elementAddressRegister);
3198         return;
3199     }
3200 
3201     LocalRegisterWithPreference isEmptyResults(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3202     m_assembler.move(Assembler::TrustedImm32(0), isEmptyResults);
3203 
3204     Assembler::JumpList notEmpty;
3205     jumpIfElementIsNotEmpty(m_assembler, m_registerAllocator, notEmpty, elementAddressRegister);
3206     m_assembler.move(Assembler::TrustedImm32(1), isEmptyResults);
3207     notEmpty.link(&amp;m_assembler);
3208 
3209     generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::AffectedByEmpty, Assembler::RegisterID(isEmptyResults));
3210 
3211     failureCases.append(m_assembler.branchTest32(Assembler::Zero, isEmptyResults));
3212 }
3213 
3214 void SelectorCodeGenerator::generateElementIsFirstChild(Assembler::JumpList&amp; failureCases)
3215 {
3216     if (m_selectorContext == SelectorContext::QuerySelector) {
3217         Assembler::JumpList successCase = jumpIfNoPreviousAdjacentElement();
3218         failureCases.append(m_assembler.jump());
3219         successCase.link(&amp;m_assembler);
3220         LocalRegister parent(m_registerAllocator);
3221         generateWalkToParentElementOrShadowRoot(failureCases, parent);
3222         return;
3223     }
3224 
3225     // Zero in isFirstChildRegister is the success case. The register is set to non-zero if a sibling if found.
3226     LocalRegister isFirstChildRegister(m_registerAllocator);
3227     m_assembler.move(Assembler::TrustedImm32(0), isFirstChildRegister);
3228 
3229     {
3230         Assembler::JumpList successCase = jumpIfNoPreviousAdjacentElement();
3231 
3232         // If there was a sibling element, the element was not the first child -&gt; failure case.
3233         m_assembler.move(Assembler::TrustedImm32(1), isFirstChildRegister);
3234 
3235         successCase.link(&amp;m_assembler);
3236     }
3237 
3238     LocalRegister parentNode(m_registerAllocator);
3239     generateWalkToParentNode(parentNode);
3240     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, parentNode));
3241     Assembler::Jump notElement = DOMJIT::branchTestIsElementFlagOnNode(m_assembler, Assembler::Zero, parentNode);
3242 
3243     LocalRegister checkingContext(m_registerAllocator);
3244     Assembler::Jump notResolvingStyle = jumpIfNotResolvingStyle(checkingContext);
3245 
3246     generateAddStyleRelation(checkingContext, parentNode, Style::Relation::ChildrenAffectedByFirstChildRules);
3247     // The parent marking is unconditional. If the matching is not a success, we can now fail.
3248     // Otherwise we need to apply setFirstChildState() on the RenderStyle.
3249     Assembler::Label checkWithRelation(m_assembler.label());
3250     failureCases.append(m_assembler.branchTest32(Assembler::NonZero, isFirstChildRegister));
3251     generateAddStyleRelation(checkingContext, elementAddressRegister, Style::Relation::FirstChild);
3252     Assembler::Jump successCase = m_assembler.jump();
3253 
3254     notElement.link(&amp;m_assembler);
3255     failureCases.append(DOMJIT::branchTestIsShadowRootFlagOnNode(m_assembler, Assembler::Zero, parentNode));
3256     jumpIfNotResolvingStyle(checkingContext).linkTo(checkWithRelation, &amp;m_assembler);
3257 
3258     notResolvingStyle.link(&amp;m_assembler);
3259     failureCases.append(m_assembler.branchTest32(Assembler::NonZero, isFirstChildRegister));
3260 
3261     successCase.link(&amp;m_assembler);
3262 }
3263 
3264 static bool elementIsHovered(const Element* element)
3265 {
3266     return element-&gt;hovered() || InspectorInstrumentation::forcePseudoState(*element, CSSSelector::PseudoClassHover);
3267 }
3268 
3269 void SelectorCodeGenerator::generateElementIsHovered(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3270 {
3271     generateSpecialFailureInQuirksModeForActiveAndHoverIfNeeded(failureCases, fragment);
3272 
3273     generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::AffectedByHover);
3274 
3275     Assembler::JumpList successCases;
3276     if (m_selectorContext != SelectorContext::QuerySelector &amp;&amp; fragment.relationToRightFragment != FragmentRelation::Rightmost) {
3277         // :hover always matches when not in rightmost position when collecting rules for descendant style invalidation optimization.
3278         // Resolving style for a matching descendant will set parent childrenAffectedByHover bit even when the element is not currently hovered.
3279         // This bit has to be set for the event based :hover invalidation to work.
3280         // FIXME: We should just collect style relation bits and apply them as needed when computing style invalidation optimization.
3281         LocalRegister checkingContext(m_registerAllocator);
3282         successCases.append(branchOnResolvingMode(Assembler::Equal, SelectorChecker::Mode::CollectingRulesIgnoringVirtualPseudoElements, checkingContext));
3283     }
3284 
3285     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3286     functionCall.setFunctionAddress(elementIsHovered);
3287     functionCall.setOneArgument(elementAddressRegister);
3288     failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3289 
3290     successCases.link(&amp;m_assembler);
3291 }
3292 
3293 void SelectorCodeGenerator::generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3294 {
3295     for (const Vector&lt;AtomString&gt;* languageArguments : fragment.languageArgumentsList)
3296         generateElementIsInLanguage(failureCases, languageArguments);
3297 }
3298 
3299 void SelectorCodeGenerator::generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const Vector&lt;AtomString&gt;* languageArguments)
3300 {
3301     LocalRegisterWithPreference langRangeRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3302     m_assembler.move(Assembler::TrustedImmPtr(languageArguments), langRangeRegister);
3303 
3304     Assembler::RegisterID elementAddress = elementAddressRegister;
3305     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3306     functionCall.setFunctionAddress(matchesLangPseudoClass);
3307     functionCall.setTwoArguments(elementAddress, langRangeRegister);
3308     failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3309 }
3310 
3311 void SelectorCodeGenerator::generateElementIsLastChild(Assembler::JumpList&amp; failureCases)
3312 {
3313     if (m_selectorContext == SelectorContext::QuerySelector) {
3314         Assembler::JumpList successCase = jumpIfNoNextAdjacentElement();
3315         failureCases.append(m_assembler.jump());
3316 
3317         successCase.link(&amp;m_assembler);
3318         LocalRegister parent(m_registerAllocator);
3319         generateWalkToParentElementOrShadowRoot(failureCases, parent);
3320 
3321         failureCases.append(m_assembler.branchTest32(Assembler::Zero, Assembler::Address(parent, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagIsParsingChildrenFinished())));
3322 
3323         return;
3324     }
3325 
3326     LocalRegister parentNode(m_registerAllocator);
3327     generateWalkToParentNode(parentNode);
3328     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, parentNode));
3329 
3330     // Zero in isLastChildRegister is the success case. The register is set to non-zero if a sibling if found.
3331     LocalRegister isLastChildRegister(m_registerAllocator);
3332     m_assembler.move(Assembler::TrustedImm32(0), isLastChildRegister);
3333 
3334     {
3335         Assembler::Jump notFinishedParsingChildren = m_assembler.branchTest32(Assembler::Zero, Assembler::Address(parentNode, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagIsParsingChildrenFinished()));
3336 
3337         Assembler::JumpList successCase = jumpIfNoNextAdjacentElement();
3338 
3339         notFinishedParsingChildren.link(&amp;m_assembler);
3340         m_assembler.move(Assembler::TrustedImm32(1), isLastChildRegister);
3341 
3342         successCase.link(&amp;m_assembler);
3343     }
3344 
3345     Assembler::Jump notElement = DOMJIT::branchTestIsElementFlagOnNode(m_assembler, Assembler::Zero, parentNode);
3346 
3347     LocalRegister checkingContext(m_registerAllocator);
3348     Assembler::Jump notResolvingStyle = jumpIfNotResolvingStyle(checkingContext);
3349 
3350     generateAddStyleRelation(checkingContext, parentNode, Style::Relation::ChildrenAffectedByLastChildRules);
3351     // The parent marking is unconditional. If the matching is not a success, we can now fail.
3352     // Otherwise we need to apply setLastChildState() on the RenderStyle.
3353     Assembler::Label checkWithRelation(m_assembler.label());
3354     failureCases.append(m_assembler.branchTest32(Assembler::NonZero, isLastChildRegister));
3355     generateAddStyleRelation(checkingContext, elementAddressRegister, Style::Relation::LastChild);
3356     Assembler::Jump successCase = m_assembler.jump();
3357 
3358     notElement.link(&amp;m_assembler);
3359     failureCases.append(DOMJIT::branchTestIsShadowRootFlagOnNode(m_assembler, Assembler::Zero, parentNode));
3360     jumpIfNotResolvingStyle(checkingContext).linkTo(checkWithRelation, &amp;m_assembler);
3361 
3362     notResolvingStyle.link(&amp;m_assembler);
3363     failureCases.append(m_assembler.branchTest32(Assembler::NonZero, isLastChildRegister));
3364 
3365     successCase.link(&amp;m_assembler);
3366 }
3367 
3368 void SelectorCodeGenerator::generateElementIsOnlyChild(Assembler::JumpList&amp; failureCases)
3369 {
3370     // Is Only child is pretty much a combination of isFirstChild + isLastChild. The main difference is that tree marking is combined.
3371     if (m_selectorContext == SelectorContext::QuerySelector) {
3372         Assembler::JumpList previousSuccessCase = jumpIfNoPreviousAdjacentElement();
3373         failureCases.append(m_assembler.jump());
3374         previousSuccessCase.link(&amp;m_assembler);
3375 
3376         Assembler::JumpList nextSuccessCase = jumpIfNoNextAdjacentElement();
3377         failureCases.append(m_assembler.jump());
3378         nextSuccessCase.link(&amp;m_assembler);
3379 
3380         LocalRegister parent(m_registerAllocator);
3381         generateWalkToParentElementOrShadowRoot(failureCases, parent);
3382 
3383         failureCases.append(m_assembler.branchTest32(Assembler::Zero, Assembler::Address(parent, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagIsParsingChildrenFinished())));
3384 
3385         return;
3386     }
3387 
3388     LocalRegister parentNode(m_registerAllocator);
3389     generateWalkToParentNode(parentNode);
3390     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, parentNode));
3391 
3392     // Zero in isOnlyChildRegister is the success case. The register is set to non-zero if a sibling if found.
3393     LocalRegister isOnlyChildRegister(m_registerAllocator);
3394     m_assembler.move(Assembler::TrustedImm32(0), isOnlyChildRegister);
3395 
3396     {
3397         Assembler::JumpList localFailureCases;
3398         {
3399             Assembler::JumpList successCase = jumpIfNoPreviousAdjacentElement();
3400             localFailureCases.append(m_assembler.jump());
3401             successCase.link(&amp;m_assembler);
3402         }
3403         localFailureCases.append(m_assembler.branchTest32(Assembler::Zero, Assembler::Address(parentNode, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagIsParsingChildrenFinished())));
3404         Assembler::JumpList successCase = jumpIfNoNextAdjacentElement();
3405 
3406         localFailureCases.link(&amp;m_assembler);
3407         m_assembler.move(Assembler::TrustedImm32(1), isOnlyChildRegister);
3408 
3409         successCase.link(&amp;m_assembler);
3410     }
3411 
3412     Assembler::Jump notElement = DOMJIT::branchTestIsElementFlagOnNode(m_assembler, Assembler::Zero, parentNode);
3413 
3414     LocalRegister checkingContext(m_registerAllocator);
3415     Assembler::Jump notResolvingStyle = jumpIfNotResolvingStyle(checkingContext);
3416 
3417     generateAddStyleRelation(checkingContext, parentNode, Style::Relation::ChildrenAffectedByFirstChildRules);
3418     generateAddStyleRelation(checkingContext, parentNode, Style::Relation::ChildrenAffectedByLastChildRules);
3419     // The parent marking is unconditional. If the matching is not a success, we can now fail.
3420     // Otherwise we need to apply setLastChildState() on the RenderStyle.
3421     Assembler::Label checkWithRelation(m_assembler.label());
3422     failureCases.append(m_assembler.branchTest32(Assembler::NonZero, isOnlyChildRegister));
3423     generateAddStyleRelation(checkingContext, elementAddressRegister, Style::Relation::FirstChild);
3424     generateAddStyleRelation(checkingContext, elementAddressRegister, Style::Relation::LastChild);
3425     Assembler::Jump successCase = m_assembler.jump();
3426 
3427     notElement.link(&amp;m_assembler);
3428     failureCases.append(DOMJIT::branchTestIsShadowRootFlagOnNode(m_assembler, Assembler::Zero, parentNode));
3429     jumpIfNotResolvingStyle(checkingContext).linkTo(checkWithRelation, &amp;m_assembler);
3430 
3431     notResolvingStyle.link(&amp;m_assembler);
3432     failureCases.append(m_assembler.branchTest32(Assembler::NonZero, isOnlyChildRegister));
3433 
3434     successCase.link(&amp;m_assembler);
3435 }
3436 
3437 static bool makeContextStyleUniqueIfNecessaryAndTestIsPlaceholderShown(const Element* element, SelectorChecker::CheckingContext* checkingContext)
3438 {
3439     if (is&lt;HTMLTextFormControlElement&gt;(*element) &amp;&amp; element-&gt;isTextField()) {
3440         if (checkingContext-&gt;resolvingMode == SelectorChecker::Mode::ResolvingStyle)
3441             checkingContext-&gt;styleRelations.append({ *element, Style::Relation::Unique, 1 });
3442         return downcast&lt;HTMLTextFormControlElement&gt;(*element).isPlaceholderVisible();
3443     }
3444     return false;
3445 }
3446 
3447 static bool isPlaceholderShown(const Element* element)
3448 {
3449     return is&lt;HTMLTextFormControlElement&gt;(*element) &amp;&amp; downcast&lt;HTMLTextFormControlElement&gt;(*element).isPlaceholderVisible();
3450 }
3451 
3452 void SelectorCodeGenerator::generateElementHasPlaceholderShown(Assembler::JumpList&amp; failureCases)
3453 {
3454     if (m_selectorContext == SelectorContext::QuerySelector) {
3455         FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3456         functionCall.setFunctionAddress(isPlaceholderShown);
3457         functionCall.setOneArgument(elementAddressRegister);
3458         failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3459         return;
3460     }
3461 
3462     Assembler::RegisterID checkingContext = m_registerAllocator.allocateRegisterWithPreference(JSC::GPRInfo::argumentGPR1);
3463     loadCheckingContext(checkingContext);
3464     m_registerAllocator.deallocateRegister(checkingContext);
3465 
3466     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3467     functionCall.setFunctionAddress(makeContextStyleUniqueIfNecessaryAndTestIsPlaceholderShown);
3468     functionCall.setTwoArguments(elementAddressRegister, checkingContext);
3469     failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3470 }
3471 
3472 inline void SelectorCodeGenerator::generateElementHasTagName(Assembler::JumpList&amp; failureCases, const CSSSelector&amp; tagMatchingSelector)
3473 {
3474     const QualifiedName&amp; nameToMatch = tagMatchingSelector.tagQName();
3475     if (nameToMatch == anyQName())
3476         return;
3477 
3478     // Load the QualifiedNameImpl from the input.
3479     LocalRegister qualifiedNameImpl(m_registerAllocator);
3480     m_assembler.loadPtr(Assembler::Address(elementAddressRegister, Element::tagQNameMemoryOffset() + QualifiedName::implMemoryOffset()), qualifiedNameImpl);
3481 
3482     const AtomString&amp; selectorLocalName = nameToMatch.localName();
3483     if (selectorLocalName != starAtom()) {
3484         const AtomString&amp; lowercaseLocalName = tagMatchingSelector.tagLowercaseLocalName();
3485 
3486         if (selectorLocalName == lowercaseLocalName) {
3487             // Generate localName == element-&gt;localName().
3488             LocalRegister constantRegister(m_registerAllocator);
3489             m_assembler.move(Assembler::TrustedImmPtr(selectorLocalName.impl()), constantRegister);
3490             failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), constantRegister));
3491         } else {
3492             Assembler::JumpList caseSensitiveCases;
3493             caseSensitiveCases.append(DOMJIT::branchTestIsHTMLFlagOnNode(m_assembler, Assembler::Zero, elementAddressRegister));
3494             {
3495                 LocalRegister document(m_registerAllocator);
3496                 DOMJIT::loadDocument(m_assembler, elementAddressRegister, document);
3497                 caseSensitiveCases.append(testIsHTMLClassOnDocument(Assembler::Zero, m_assembler, document));
3498             }
3499 
3500             LocalRegister constantRegister(m_registerAllocator);
3501             m_assembler.move(Assembler::TrustedImmPtr(lowercaseLocalName.impl()), constantRegister);
3502             Assembler::Jump skipCaseSensitiveCase = m_assembler.jump();
3503 
3504             caseSensitiveCases.link(&amp;m_assembler);
3505             m_assembler.move(Assembler::TrustedImmPtr(selectorLocalName.impl()), constantRegister);
3506             skipCaseSensitiveCase.link(&amp;m_assembler);
3507 
3508             failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), constantRegister));
3509         }
3510     }
3511 
3512     const AtomString&amp; selectorNamespaceURI = nameToMatch.namespaceURI();
3513     if (selectorNamespaceURI != starAtom()) {
3514         // Generate namespaceURI == element-&gt;namespaceURI().
3515         LocalRegister constantRegister(m_registerAllocator);
3516         m_assembler.move(Assembler::TrustedImmPtr(selectorNamespaceURI.impl()), constantRegister);
3517         failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::namespaceMemoryOffset()), constantRegister));
3518     }
3519 }
3520 
3521 void SelectorCodeGenerator::generateElementHasId(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const AtomString&amp; idToMatch)
3522 {
3523     // Compare the pointers of the AtomStringImpl from idForStyleResolution with the reference idToMatch.
3524     LocalRegister idToMatchRegister(m_registerAllocator);
3525     m_assembler.move(Assembler::TrustedImmPtr(idToMatch.impl()), idToMatchRegister);
3526     failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(elementDataAddress, ElementData::idForStyleResolutionMemoryOffset()), idToMatchRegister));
3527 }
3528 
3529 void SelectorCodeGenerator::generateElementHasClasses(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const Vector&lt;const AtomStringImpl*, 8&gt;&amp; classNames)
3530 {
3531     // Load m_classNames.
3532     LocalRegister spaceSplitStringData(m_registerAllocator);
3533     m_assembler.loadPtr(Assembler::Address(elementDataAddress, ElementData::classNamesMemoryOffset()), spaceSplitStringData);
3534 
3535     // If SpaceSplitString does not have a SpaceSplitStringData pointer, it is empty -&gt; failure case.
3536     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, spaceSplitStringData));
3537 
3538     // We loop over the classes of SpaceSplitStringData for each class name we need to match.
3539     LocalRegister indexRegister(m_registerAllocator);
3540     for (unsigned i = 0; i &lt; classNames.size(); ++i) {
3541         LocalRegister classNameToMatch(m_registerAllocator);
3542         m_assembler.move(Assembler::TrustedImmPtr(classNames[i]), classNameToMatch);
3543         m_assembler.move(Assembler::TrustedImm32(0), indexRegister);
3544 
3545         // Beginning of a loop over all the class name of element to find the one we are looking for.
3546         Assembler::Label loopStart(m_assembler.label());
3547 
3548         // If the pointers match, proceed to the next matcher.
3549         Assembler::Jump classFound = m_assembler.branchPtr(Assembler::Equal, Assembler::BaseIndex(spaceSplitStringData, indexRegister, Assembler::timesPtr(), SpaceSplitStringData::tokensMemoryOffset()), classNameToMatch);
3550 
3551         // Increment the index.
3552         m_assembler.add32(Assembler::TrustedImm32(1), indexRegister);
3553 
3554         // If we reached the last element -&gt; failure.
3555         failureCases.append(m_assembler.branch32(Assembler::Equal, Assembler::Address(spaceSplitStringData, SpaceSplitStringData::sizeMemoryOffset()), indexRegister));
3556         // Otherwise just loop over.
3557         m_assembler.jump().linkTo(loopStart, &amp;m_assembler);
3558 
3559         // Success case.
3560         classFound.link(&amp;m_assembler);
3561     }
3562 }
3563 
3564 void SelectorCodeGenerator::generateElementIsLink(Assembler::JumpList&amp; failureCases)
3565 {
3566     failureCases.append(m_assembler.branchTest32(Assembler::Zero, Assembler::Address(elementAddressRegister, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagIsLink())));
3567 }
3568 
3569 static bool nthFilterIsAlwaysSatisified(int a, int b)
3570 {
3571     // Anything modulo 1 is zero. Unless b restricts the range, this does not filter anything out.
3572     if (a == 1 &amp;&amp; (!b || (b == 1)))
3573         return true;
3574     return false;
3575 }
3576 
3577 void SelectorCodeGenerator::generateNthChildParentCheckAndRelationUpdate(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3578 {
3579     LocalRegister parentNode(m_registerAllocator);
3580     generateWalkToParentNode(parentNode);
3581     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, parentNode));
3582     Assembler::Jump notElement = DOMJIT::branchTestIsElementFlagOnNode(m_assembler, Assembler::Zero, parentNode);
3583 
3584     auto relation = fragmentMatchesRightmostOrAdjacentElement(fragment)
3585         ? Style::Relation::ChildrenAffectedByForwardPositionalRules
3586         : Style::Relation::DescendantsAffectedByForwardPositionalRules;
3587     generateAddStyleRelationIfResolvingStyle(parentNode, relation);
3588     Assembler::Jump parentNodeCheckEnd = m_assembler.jump();
3589 
3590     notElement.link(&amp;m_assembler);
3591     failureCases.append(DOMJIT::branchTestIsShadowRootFlagOnNode(m_assembler, Assembler::Zero, parentNode));
3592 
3593     parentNodeCheckEnd.link(&amp;m_assembler);
3594 }
3595 
3596 void SelectorCodeGenerator::generateElementIsNthChild(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3597 {
3598     generateNthChildParentCheckAndRelationUpdate(failureCases, fragment);
3599 
3600     Vector&lt;std::pair&lt;int, int&gt;, 32&gt; validSubsetFilters;
3601     validSubsetFilters.reserveInitialCapacity(fragment.nthChildFilters.size());
3602     for (const auto&amp; slot : fragment.nthChildFilters) {
3603         if (nthFilterIsAlwaysSatisified(slot.first, slot.second))
3604             continue;
3605         validSubsetFilters.uncheckedAppend(slot);
3606     }
3607     if (validSubsetFilters.isEmpty())
3608         return;
3609 
3610     // Setup the counter at 1.
3611     LocalRegisterWithPreference elementCounter(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3612     m_assembler.move(Assembler::TrustedImm32(1), elementCounter);
3613 
3614     // Loop over the previous adjacent elements and increment the counter.
3615     {
3616         LocalRegister previousSibling(m_registerAllocator);
3617         m_assembler.move(elementAddressRegister, previousSibling);
3618 
3619         // Getting the child index is very efficient when it works. When there is no child index,
3620         // querying at every iteration is very inefficient. We solve this by only testing the child
3621         // index on the first direct adjacent.
3622         Assembler::JumpList noMoreSiblingsCases;
3623 
3624         Assembler::JumpList noCachedChildIndexCases;
3625         generateWalkToPreviousAdjacentElement(noMoreSiblingsCases, previousSibling);
3626 
3627         LocalRegister elementRareData(m_registerAllocator);
3628         m_assembler.loadPtr(Assembler::Address(previousSibling, Node::rareDataMemoryOffset()), elementRareData);
3629 
3630         noCachedChildIndexCases.append(m_assembler.branchTestPtr(Assembler::Zero, elementRareData));
3631         {
3632             LocalRegister cachedChildIndex(m_registerAllocator);
3633             m_assembler.load16(Assembler::Address(elementRareData, ElementRareData::childIndexMemoryOffset()), cachedChildIndex);
3634             noCachedChildIndexCases.append(m_assembler.branchTest32(Assembler::Zero, cachedChildIndex));
3635             m_assembler.add32(cachedChildIndex, elementCounter);
3636             noMoreSiblingsCases.append(m_assembler.jump());
3637         }
3638         noCachedChildIndexCases.link(&amp;m_assembler);
3639         m_assembler.add32(Assembler::TrustedImm32(1), elementCounter);
3640 
3641         Assembler::Label loopStart = m_assembler.label();
3642         generateWalkToPreviousAdjacentElement(noMoreSiblingsCases, previousSibling);
3643         m_assembler.add32(Assembler::TrustedImm32(1), elementCounter);
3644         m_assembler.jump().linkTo(loopStart, &amp;m_assembler);
3645         noMoreSiblingsCases.link(&amp;m_assembler);
3646     }
3647 
3648     generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::NthChildIndex, Assembler::RegisterID(elementCounter));
3649 
3650     for (const auto&amp; slot : validSubsetFilters)
3651         generateNthFilterTest(failureCases, elementCounter, slot.first, slot.second);
3652 }
3653 
3654 void SelectorCodeGenerator::generateElementIsNthChildOf(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3655 {
3656     generateNthChildParentCheckAndRelationUpdate(failureCases, fragment);
3657 
3658     // The initial element must match the selector list.
3659     for (const NthChildOfSelectorInfo&amp; nthChildOfSelectorInfo : fragment.nthChildOfFilters)
3660         generateElementMatchesSelectorList(failureCases, elementAddressRegister, nthChildOfSelectorInfo.selectorList);
3661 
3662     Vector&lt;const NthChildOfSelectorInfo*&gt; validSubsetFilters;
3663     for (const NthChildOfSelectorInfo&amp; nthChildOfSelectorInfo : fragment.nthChildOfFilters) {
3664         if (nthFilterIsAlwaysSatisified(nthChildOfSelectorInfo.a, nthChildOfSelectorInfo.b))
3665             continue;
3666         validSubsetFilters.append(&amp;nthChildOfSelectorInfo);
3667     }
3668     if (validSubsetFilters.isEmpty())
3669         return;
3670 
3671     for (const NthChildOfSelectorInfo* nthChildOfSelectorInfo : validSubsetFilters) {
3672         // Setup the counter at 1.
3673         LocalRegisterWithPreference elementCounter(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3674         m_assembler.move(Assembler::TrustedImm32(1), elementCounter);
3675 
3676         // Loop over the previous adjacent elements and increment the counter.
3677         {
3678             LocalRegister previousSibling(m_registerAllocator);
3679             m_assembler.move(elementAddressRegister, previousSibling);
3680 
3681             Assembler::JumpList noMoreSiblingsCases;
3682 
3683             Assembler::Label loopStart = m_assembler.label();
3684 
3685             generateWalkToPreviousAdjacentElement(noMoreSiblingsCases, previousSibling);
3686 
3687             Assembler::JumpList localFailureCases;
3688             generateElementMatchesSelectorList(localFailureCases, previousSibling, nthChildOfSelectorInfo-&gt;selectorList);
3689             localFailureCases.linkTo(loopStart, &amp;m_assembler);
3690             m_assembler.add32(Assembler::TrustedImm32(1), elementCounter);
3691             m_assembler.jump().linkTo(loopStart, &amp;m_assembler);
3692 
3693             noMoreSiblingsCases.link(&amp;m_assembler);
3694         }
3695 
3696         generateNthFilterTest(failureCases, elementCounter, nthChildOfSelectorInfo-&gt;a, nthChildOfSelectorInfo-&gt;b);
3697     }
3698 }
3699 
3700 void SelectorCodeGenerator::generateNthLastChildParentCheckAndRelationUpdate(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3701 {
3702     LocalRegister parentNode(m_registerAllocator);
3703     generateWalkToParentNode(parentNode);
3704     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, parentNode));
3705     Assembler::Jump notElement = DOMJIT::branchTestIsElementFlagOnNode(m_assembler, Assembler::Zero, parentNode);
3706 
3707     auto relation = fragmentMatchesRightmostOrAdjacentElement(fragment)
3708         ? Style::Relation::ChildrenAffectedByBackwardPositionalRules
3709         : Style::Relation::DescendantsAffectedByBackwardPositionalRules;
3710     generateAddStyleRelationIfResolvingStyle(parentNode, relation);
3711     failureCases.append(m_assembler.branchTest32(Assembler::Zero, Assembler::Address(parentNode, Node::nodeFlagsMemoryOffset()),
3712         Assembler::TrustedImm32(Node::flagIsParsingChildrenFinished())));
3713     Assembler::Jump parentNodeCheckEnd = m_assembler.jump();
3714 
3715     notElement.link(&amp;m_assembler);
3716     failureCases.append(DOMJIT::branchTestIsShadowRootFlagOnNode(m_assembler, Assembler::Zero, parentNode));
3717 
3718     parentNodeCheckEnd.link(&amp;m_assembler);
3719 }
3720 
3721 void SelectorCodeGenerator::generateElementIsNthLastChild(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3722 {
3723     generateNthLastChildParentCheckAndRelationUpdate(failureCases, fragment);
3724 
3725     Vector&lt;std::pair&lt;int, int&gt;, 32&gt; validSubsetFilters;
3726     validSubsetFilters.reserveInitialCapacity(fragment.nthLastChildFilters.size());
3727     for (const auto&amp; slot : fragment.nthLastChildFilters) {
3728         if (nthFilterIsAlwaysSatisified(slot.first, slot.second))
3729             continue;
3730         validSubsetFilters.uncheckedAppend(slot);
3731     }
3732     if (validSubsetFilters.isEmpty())
3733         return;
3734 
3735     LocalRegister elementCounter(m_registerAllocator);
3736     { // Loop over the following sibling elements and increment the counter.
3737         LocalRegister nextSibling(m_registerAllocator);
3738         m_assembler.move(elementAddressRegister, nextSibling);
3739         // Setup the counter at 1.
3740         m_assembler.move(Assembler::TrustedImm32(1), elementCounter);
3741 
3742         Assembler::JumpList noMoreSiblingsCases;
3743 
3744         generateWalkToNextAdjacentElement(noMoreSiblingsCases, nextSibling);
3745 
3746         Assembler::Label loopStart = m_assembler.label();
3747         m_assembler.add32(Assembler::TrustedImm32(1), elementCounter);
3748         generateWalkToNextAdjacentElement(noMoreSiblingsCases, nextSibling);
3749         m_assembler.jump().linkTo(loopStart, &amp;m_assembler);
3750         noMoreSiblingsCases.link(&amp;m_assembler);
3751     }
3752 
3753     for (const auto&amp; slot : validSubsetFilters)
3754         generateNthFilterTest(failureCases, elementCounter, slot.first, slot.second);
3755 }
3756 
3757 void SelectorCodeGenerator::generateElementIsNthLastChildOf(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3758 {
3759     generateNthLastChildParentCheckAndRelationUpdate(failureCases, fragment);
3760 
3761     Vector&lt;const NthChildOfSelectorInfo*&gt; validSubsetFilters;
3762     validSubsetFilters.reserveInitialCapacity(fragment.nthLastChildOfFilters.size());
3763 
3764     // The initial element must match the selector list.
3765     for (const NthChildOfSelectorInfo&amp; nthLastChildOfSelectorInfo : fragment.nthLastChildOfFilters)
3766         generateElementMatchesSelectorList(failureCases, elementAddressRegister, nthLastChildOfSelectorInfo.selectorList);
3767 
3768     for (const NthChildOfSelectorInfo&amp; nthLastChildOfSelectorInfo : fragment.nthLastChildOfFilters) {
3769         if (nthFilterIsAlwaysSatisified(nthLastChildOfSelectorInfo.a, nthLastChildOfSelectorInfo.b))
3770             continue;
3771         validSubsetFilters.uncheckedAppend(&amp;nthLastChildOfSelectorInfo);
3772     }
3773     if (validSubsetFilters.isEmpty())
3774         return;
3775 
3776     for (const NthChildOfSelectorInfo* nthLastChildOfSelectorInfo : validSubsetFilters) {
3777         // Setup the counter at 1.
3778         LocalRegisterWithPreference elementCounter(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3779         m_assembler.move(Assembler::TrustedImm32(1), elementCounter);
3780 
3781         // Loop over the following adjacent elements and increment the counter.
3782         {
3783             LocalRegister nextSibling(m_registerAllocator);
3784             m_assembler.move(elementAddressRegister, nextSibling);
3785 
3786             Assembler::JumpList noMoreSiblingsCases;
3787 
3788             Assembler::Label loopStart = m_assembler.label();
3789 
3790             generateWalkToNextAdjacentElement(noMoreSiblingsCases, nextSibling);
3791 
3792             Assembler::JumpList localFailureCases;
3793             generateElementMatchesSelectorList(localFailureCases, nextSibling, nthLastChildOfSelectorInfo-&gt;selectorList);
3794             localFailureCases.linkTo(loopStart, &amp;m_assembler);
3795             m_assembler.add32(Assembler::TrustedImm32(1), elementCounter);
3796             m_assembler.jump().linkTo(loopStart, &amp;m_assembler);
3797 
3798             noMoreSiblingsCases.link(&amp;m_assembler);
3799         }
3800 
3801         generateNthFilterTest(failureCases, elementCounter, nthLastChildOfSelectorInfo-&gt;a, nthLastChildOfSelectorInfo-&gt;b);
3802     }
3803 }
3804 
3805 void SelectorCodeGenerator::generateElementMatchesNotPseudoClass(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3806 {
3807     Assembler::JumpList localFailureCases;
3808     generateElementMatchesSelectorList(localFailureCases, elementAddressRegister, fragment.notFilters);
3809     // Since this is a not pseudo class filter, reaching here is a failure.
3810     failureCases.append(m_assembler.jump());
3811     localFailureCases.link(&amp;m_assembler);
3812 }
3813 
3814 void SelectorCodeGenerator::generateElementMatchesAnyPseudoClass(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3815 {
3816     for (const auto&amp; subFragments : fragment.anyFilters) {
3817         RELEASE_ASSERT(!subFragments.isEmpty());
3818 
3819         // Don&#39;t handle the last fragment in this loop.
3820         Assembler::JumpList successCases;
3821         for (unsigned i = 0; i &lt; subFragments.size() - 1; ++i) {
3822             Assembler::JumpList localFailureCases;
3823             generateElementMatching(localFailureCases, localFailureCases, subFragments[i]);
3824             successCases.append(m_assembler.jump());
3825             localFailureCases.link(&amp;m_assembler);
3826         }
3827 
3828         // At the last fragment, optimize the failure jump to jump to the non-local failure directly.
3829         generateElementMatching(failureCases, failureCases, subFragments.last());
3830         successCases.link(&amp;m_assembler);
3831     }
3832 }
3833 
3834 void SelectorCodeGenerator::generateElementMatchesMatchesPseudoClass(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3835 {
3836     for (const SelectorList&amp; matchesList : fragment.matchesFilters)
3837         generateElementMatchesSelectorList(failureCases, elementAddressRegister, matchesList);
3838 }
3839 
3840 void SelectorCodeGenerator::generateElementHasPseudoElement(Assembler::JumpList&amp;, const SelectorFragment&amp; fragment)
3841 {
3842     ASSERT_UNUSED(fragment, fragment.pseudoElementSelector);
3843     ASSERT_WITH_MESSAGE(m_selectorContext != SelectorContext::QuerySelector, &quot;When the fragment has pseudo element, the selector becomes CannotMatchAnything for QuerySelector and this test function is not called.&quot;);
3844     ASSERT_WITH_MESSAGE_UNUSED(fragment, fragmentMatchesTheRightmostElement(fragment), &quot;Virtual pseudo elements handling is only effective in the rightmost fragment. If the current fragment is not rightmost fragment, CSS JIT compiler makes it CannotMatchAnything in fragment construction phase, so never reach here.&quot;);
3845 }
3846 
3847 void SelectorCodeGenerator::generateRequestedPseudoElementEqualsToSelectorPseudoElement(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment, Assembler::RegisterID checkingContext)
3848 {
3849     ASSERT(m_selectorContext != SelectorContext::QuerySelector);
3850 
3851     // Make sure that the requested pseudoId equals to the pseudo element of the rightmost fragment.
3852     // If the rightmost fragment doesn&#39;t have a pseudo element, the requested pseudoId need to be PseudoId::None to succeed the matching.
3853     // Otherwise, if the requested pseudoId is not PseudoId::None, the requested pseudoId need to equal to the pseudo element of the rightmost fragment.
3854     if (fragmentMatchesTheRightmostElement(fragment)) {
3855         if (!fragment.pseudoElementSelector)
3856             failureCases.append(m_assembler.branch8(Assembler::NotEqual, Assembler::Address(checkingContext, OBJECT_OFFSETOF(SelectorChecker::CheckingContext, pseudoId)), Assembler::TrustedImm32(static_cast&lt;unsigned&gt;(PseudoId::None))));
3857         else {
3858             Assembler::Jump skip = m_assembler.branch8(Assembler::Equal, Assembler::Address(checkingContext, OBJECT_OFFSETOF(SelectorChecker::CheckingContext, pseudoId)), Assembler::TrustedImm32(static_cast&lt;unsigned&gt;(PseudoId::None)));
3859             failureCases.append(m_assembler.branch8(Assembler::NotEqual, Assembler::Address(checkingContext, OBJECT_OFFSETOF(SelectorChecker::CheckingContext, pseudoId)), Assembler::TrustedImm32(static_cast&lt;unsigned&gt;(CSSSelector::pseudoId(fragment.pseudoElementSelector-&gt;pseudoElementType())))));
3860             skip.link(&amp;m_assembler);
3861         }
3862     }
3863 }
3864 
3865 void SelectorCodeGenerator::generateElementIsRoot(Assembler::JumpList&amp; failureCases)
3866 {
3867     LocalRegister document(m_registerAllocator);
3868     DOMJIT::loadDocument(m_assembler, elementAddressRegister, document);
3869     failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(document, Document::documentElementMemoryOffset()), elementAddressRegister));
3870 }
3871 
3872 void SelectorCodeGenerator::generateElementIsScopeRoot(Assembler::JumpList&amp; failureCases)
3873 {
3874     ASSERT(m_selectorContext == SelectorContext::QuerySelector);
3875 
3876     LocalRegister scope(m_registerAllocator);
3877     loadCheckingContext(scope);
3878     m_assembler.loadPtr(Assembler::Address(scope, OBJECT_OFFSETOF(SelectorChecker::CheckingContext, scope)), scope);
3879 
3880     Assembler::Jump scopeIsNotNull = m_assembler.branchTestPtr(Assembler::NonZero, scope);
3881 
3882     DOMJIT::loadDocument(m_assembler, elementAddressRegister, scope);
3883     DOMJIT::loadDocumentElement(m_assembler, scope, scope);
3884 
3885     scopeIsNotNull.link(&amp;m_assembler);
3886     failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, scope, elementAddressRegister));
3887 }
3888 
3889 void SelectorCodeGenerator::generateElementIsTarget(Assembler::JumpList&amp; failureCases)
3890 {
3891     LocalRegister document(m_registerAllocator);
3892     DOMJIT::loadDocument(m_assembler, elementAddressRegister, document);
3893     failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(document, Document::cssTargetMemoryOffset()), elementAddressRegister));
3894 }
3895 
3896 void SelectorCodeGenerator::generateElementHasFocusWithin(Assembler::JumpList&amp; failureCases)
3897 {
3898     generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::AffectedByFocusWithin);
3899     failureCases.append(m_assembler.branchTest32(Assembler::Zero, Assembler::Address(elementAddressRegister, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagHasFocusWithin())));
3900 }
3901 
3902 void SelectorCodeGenerator::generateElementIsFirstLink(Assembler::JumpList&amp; failureCases, Assembler::RegisterID element)
3903 {
3904     LocalRegister currentElement(m_registerAllocator);
3905     m_assembler.loadPtr(m_stackAllocator.addressOf(m_startElement), currentElement);
3906 
3907     // Tree walking up to the provided element until link node is found.
3908     Assembler::Label loopStart(m_assembler.label());
3909 
3910     // The target element is always in the ancestors from the start element to the root node.
3911     // So the tree walking doesn&#39;t loop infinitely and it will be stopped with the following `currentElement == element` condition.
3912     Assembler::Jump reachedToElement = m_assembler.branchPtr(Assembler::Equal, currentElement, element);
3913 
3914     failureCases.append(m_assembler.branchTest32(Assembler::NonZero, Assembler::Address(currentElement, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagIsLink())));
3915 
3916     // And these ancestors are guaranteed that they are element nodes.
3917     // So there&#39;s no need to check whether it is an element node and whether it is not a nullptr.
3918     m_assembler.loadPtr(Assembler::Address(currentElement, Node::parentNodeMemoryOffset()), currentElement);
3919     m_assembler.jump(loopStart);
3920 
3921     reachedToElement.link(&amp;m_assembler);
3922 }
3923 
3924 void SelectorCodeGenerator::generateStoreLastVisitedElement(Assembler::RegisterID element)
3925 {
3926     m_assembler.storePtr(element, m_stackAllocator.addressOf(m_lastVisitedElement));
3927 }
3928 
3929 void SelectorCodeGenerator::generateMarkPseudoStyleForPseudoElement(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3930 {
3931     ASSERT(m_selectorContext != SelectorContext::QuerySelector);
3932 
3933     // When fragment doesn&#39;t have a pseudo element, there&#39;s no need to mark the pseudo element style.
3934     if (!fragment.pseudoElementSelector)
3935         return;
3936 
3937     LocalRegister checkingContext(m_registerAllocator);
3938     loadCheckingContext(checkingContext);
3939 
3940     Assembler::JumpList successCases;
3941 
3942     // When the requested pseudoId isn&#39;t PseudoId::None, there&#39;s no need to mark the pseudo element style.
3943     successCases.append(m_assembler.branch8(Assembler::NotEqual, Assembler::Address(checkingContext, OBJECT_OFFSETOF(SelectorChecker::CheckingContext, pseudoId)), Assembler::TrustedImm32(static_cast&lt;unsigned&gt;(PseudoId::None))));
3944 
3945     // When resolving mode is CollectingRulesIgnoringVirtualPseudoElements, there&#39;s no need to mark the pseudo element style.
3946     successCases.append(branchOnResolvingModeWithCheckingContext(Assembler::Equal, SelectorChecker::Mode::CollectingRulesIgnoringVirtualPseudoElements, checkingContext));
3947 
3948     // When resolving mode is ResolvingStyle, mark the pseudo style for pseudo element.
3949     PseudoId dynamicPseudo = CSSSelector::pseudoId(fragment.pseudoElementSelector-&gt;pseudoElementType());
3950     if (dynamicPseudo &lt; PseudoId::FirstInternalPseudoId) {
3951         failureCases.append(branchOnResolvingModeWithCheckingContext(Assembler::NotEqual, SelectorChecker::Mode::ResolvingStyle, checkingContext));
3952 
3953         Assembler::Address pseudoIDSetAddress(checkingContext, OBJECT_OFFSETOF(SelectorChecker::CheckingContext, pseudoIDSet));
3954         auto pseudoIDSetDataAddress = pseudoIDSetAddress.withOffset(PseudoIdSet::dataMemoryOffset());
3955         PseudoIdSet value { dynamicPseudo };
3956         m_assembler.store32(Assembler::TrustedImm32(value.data()), pseudoIDSetDataAddress);
3957     }
3958 
3959     // We have a pseudoElementSelector, we are not in CollectingRulesIgnoringVirtualPseudoElements so
3960     // we must match that pseudo element. Since the context&#39;s pseudo selector is PseudoId::None, we fail matching
3961     // after the marking.
3962     failureCases.append(m_assembler.jump());
3963 
3964     successCases.link(&amp;m_assembler);
3965 }
3966 
3967 void SelectorCodeGenerator::generateNthFilterTest(Assembler::JumpList&amp; failureCases, Assembler::RegisterID counter, int a, int b)
3968 {
3969     if (!a)
3970         failureCases.append(m_assembler.branch32(Assembler::NotEqual, Assembler::TrustedImm32(b), counter));
3971     else if (a &gt; 0) {
3972         if (a == 2 &amp;&amp; b == 1) {
3973             // This is the common case 2n+1 (or &quot;odd&quot;), we can test for odd values without doing the arithmetic.
3974             failureCases.append(m_assembler.branchTest32(Assembler::Zero, counter, Assembler::TrustedImm32(1)));
3975         } else {
3976             if (b) {
3977                 LocalRegister counterCopy(m_registerAllocator);
3978                 m_assembler.move(counter, counterCopy);
3979                 failureCases.append(m_assembler.branchSub32(Assembler::Signed, Assembler::TrustedImm32(b), counterCopy));
3980                 moduloIsZero(failureCases, counterCopy, a);
3981             } else
3982                 moduloIsZero(failureCases, counter, a);
3983         }
3984     } else {
3985         LocalRegister bRegister(m_registerAllocator);
3986         m_assembler.move(Assembler::TrustedImm32(b), bRegister);
3987 
3988         failureCases.append(m_assembler.branchSub32(Assembler::Signed, counter, bRegister));
3989         moduloIsZero(failureCases, bRegister, a);
3990     }
3991 }
3992 
3993 }; // namespace SelectorCompiler.
3994 }; // namespace WebCore.
3995 
3996 #endif // ENABLE(CSS_SELECTOR_JIT)
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
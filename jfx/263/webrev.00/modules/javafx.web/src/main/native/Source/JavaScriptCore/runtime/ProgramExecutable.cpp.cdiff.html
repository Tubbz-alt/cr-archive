<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ProgramExecutable.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ParseInt.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProgramExecutable.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ProgramExecutable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 41,15 ***</span>
  
  namespace JSC {
  
  const ClassInfo ProgramExecutable::s_info = { &quot;ProgramExecutable&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ProgramExecutable) };
  
<span class="line-modified">! ProgramExecutable::ProgramExecutable(ExecState* exec, const SourceCode&amp; source)</span>
<span class="line-modified">!     : Base(exec-&gt;vm().programExecutableStructure.get(), exec-&gt;vm(), source, false, DerivedContextType::None, false, EvalContextType::None, NoIntrinsic)</span>
  {
      ASSERT(source.provider()-&gt;sourceType() == SourceProviderSourceType::Program);
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      if (vm.typeProfiler() || vm.controlFlowProfiler())
          vm.functionHasExecutedCache()-&gt;insertUnexecutedRange(sourceID(), typeProfilingStartOffset(vm), typeProfilingEndOffset(vm));
  }
  
  void ProgramExecutable::destroy(JSCell* cell)
<span class="line-new-header">--- 41,15 ---</span>
  
  namespace JSC {
  
  const ClassInfo ProgramExecutable::s_info = { &quot;ProgramExecutable&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ProgramExecutable) };
  
<span class="line-modified">! ProgramExecutable::ProgramExecutable(JSGlobalObject* globalObject, const SourceCode&amp; source)</span>
<span class="line-modified">!     : Base(globalObject-&gt;vm().programExecutableStructure.get(), globalObject-&gt;vm(), source, false, DerivedContextType::None, false, EvalContextType::None, NoIntrinsic)</span>
  {
      ASSERT(source.provider()-&gt;sourceType() == SourceProviderSourceType::Program);
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      if (vm.typeProfiler() || vm.controlFlowProfiler())
          vm.functionHasExecutedCache()-&gt;insertUnexecutedRange(sourceID(), typeProfilingStartOffset(vm), typeProfilingEndOffset(vm));
  }
  
  void ProgramExecutable::destroy(JSCell* cell)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 61,71 ***</span>
  enum class GlobalPropertyLookUpStatus {
      NotFound,
      Configurable,
      NonConfigurable,
  };
<span class="line-modified">! static GlobalPropertyLookUpStatus hasRestrictedGlobalProperty(ExecState* exec, JSGlobalObject* globalObject, PropertyName propertyName)</span>
  {
      PropertyDescriptor descriptor;
<span class="line-modified">!     if (!globalObject-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor))</span>
          return GlobalPropertyLookUpStatus::NotFound;
      if (descriptor.configurable())
          return GlobalPropertyLookUpStatus::Configurable;
      return GlobalPropertyLookUpStatus::NonConfigurable;
  }
  
<span class="line-modified">! JSObject* ProgramExecutable::initializeGlobalProperties(VM&amp; vm, CallFrame* callFrame, JSScope* scope)</span>
  {
      auto throwScope = DECLARE_THROW_SCOPE(vm);
      RELEASE_ASSERT(scope);
<span class="line-modified">!     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);</span>
      RELEASE_ASSERT(globalObject);
      ASSERT(&amp;globalObject-&gt;vm() == &amp;vm);
  
      ParserError error;
      JSParserStrictMode strictMode = isStrictMode() ? JSParserStrictMode::Strict : JSParserStrictMode::NotStrict;
      OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode = globalObject-&gt;defaultCodeGenerationMode();
      UnlinkedProgramCodeBlock* unlinkedCodeBlock = vm.codeCache()-&gt;getUnlinkedProgramCodeBlock(
          vm, this, source(), strictMode, codeGenerationMode, error);
  
      if (globalObject-&gt;hasDebugger())
<span class="line-modified">!         globalObject-&gt;debugger()-&gt;sourceParsed(callFrame, source().provider(), error.line(), error.message());</span>
  
      if (error.isValid())
          return error.toErrorObject(globalObject, source());
  
      JSValue nextPrototype = globalObject-&gt;getPrototypeDirect(vm);
      while (nextPrototype &amp;&amp; nextPrototype.isObject()) {
<span class="line-modified">!         if (UNLIKELY(asObject(nextPrototype)-&gt;type() == ProxyObjectType)) {</span>
<span class="line-modified">!             ExecState* exec = globalObject-&gt;globalExec();</span>
<span class="line-removed">-             return createTypeError(exec, &quot;Proxy is not allowed in the global prototype chain.&quot;_s);</span>
<span class="line-removed">-         }</span>
          nextPrototype = asObject(nextPrototype)-&gt;getPrototypeDirect(vm);
      }
  
      JSGlobalLexicalEnvironment* globalLexicalEnvironment = globalObject-&gt;globalLexicalEnvironment();
      const VariableEnvironment&amp; variableDeclarations = unlinkedCodeBlock-&gt;variableDeclarations();
      const VariableEnvironment&amp; lexicalDeclarations = unlinkedCodeBlock-&gt;lexicalDeclarations();
      // The ES6 spec says that no vars/global properties/let/const can be duplicated in the global scope.
      // This carried out section 15.1.8 of the ES6 spec: http://www.ecma-international.org/ecma-262/6.0/index.html#sec-globaldeclarationinstantiation
      {
<span class="line-removed">-         ExecState* exec = globalObject-&gt;globalExec();</span>
          // Check for intersection of &quot;var&quot; and &quot;let&quot;/&quot;const&quot;/&quot;class&quot;
          for (auto&amp; entry : lexicalDeclarations) {
              if (variableDeclarations.contains(entry.key))
<span class="line-modified">!                 return createSyntaxError(exec, makeString(&quot;Can&#39;t create duplicate variable: &#39;&quot;, String(entry.key.get()), &quot;&#39;&quot;));</span>
          }
  
          // Check if any new &quot;let&quot;/&quot;const&quot;/&quot;class&quot; will shadow any pre-existing global property names (with configurable = false), or &quot;var&quot;/&quot;let&quot;/&quot;const&quot; variables.
          // It&#39;s an error to introduce a shadow.
          for (auto&amp; entry : lexicalDeclarations) {
              // The ES6 spec says that RestrictedGlobalProperty can&#39;t be shadowed.
<span class="line-modified">!             GlobalPropertyLookUpStatus status = hasRestrictedGlobalProperty(exec, globalObject, entry.key.get());</span>
              RETURN_IF_EXCEPTION(throwScope, nullptr);
              switch (status) {
              case GlobalPropertyLookUpStatus::NonConfigurable:
<span class="line-modified">!                 return createSyntaxError(exec, makeString(&quot;Can&#39;t create duplicate variable that shadows a global property: &#39;&quot;, String(entry.key.get()), &quot;&#39;&quot;));</span>
              case GlobalPropertyLookUpStatus::Configurable:
                  // Lexical bindings can shadow global properties if the given property&#39;s attribute is configurable.
                  // https://tc39.github.io/ecma262/#sec-globaldeclarationinstantiation step 5-c, `hasRestrictedGlobal` becomes false
                  // However we may emit GlobalProperty look up in bytecodes already and it may cache the value for the global scope.
                  // To make it invalid,
<span class="line-new-header">--- 61,68 ---</span>
  enum class GlobalPropertyLookUpStatus {
      NotFound,
      Configurable,
      NonConfigurable,
  };
<span class="line-modified">! static GlobalPropertyLookUpStatus hasRestrictedGlobalProperty(JSGlobalObject* globalObject, PropertyName propertyName)</span>
  {
      PropertyDescriptor descriptor;
<span class="line-modified">!     if (!globalObject-&gt;getOwnPropertyDescriptor(globalObject, propertyName, descriptor))</span>
          return GlobalPropertyLookUpStatus::NotFound;
      if (descriptor.configurable())
          return GlobalPropertyLookUpStatus::Configurable;
      return GlobalPropertyLookUpStatus::NonConfigurable;
  }
  
<span class="line-modified">! JSObject* ProgramExecutable::initializeGlobalProperties(VM&amp; vm, JSGlobalObject* globalObject, JSScope* scope)</span>
  {
      auto throwScope = DECLARE_THROW_SCOPE(vm);
      RELEASE_ASSERT(scope);
<span class="line-modified">!     ASSERT(globalObject == scope-&gt;globalObject(vm));</span>
      RELEASE_ASSERT(globalObject);
      ASSERT(&amp;globalObject-&gt;vm() == &amp;vm);
  
      ParserError error;
      JSParserStrictMode strictMode = isStrictMode() ? JSParserStrictMode::Strict : JSParserStrictMode::NotStrict;
      OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode = globalObject-&gt;defaultCodeGenerationMode();
      UnlinkedProgramCodeBlock* unlinkedCodeBlock = vm.codeCache()-&gt;getUnlinkedProgramCodeBlock(
          vm, this, source(), strictMode, codeGenerationMode, error);
  
      if (globalObject-&gt;hasDebugger())
<span class="line-modified">!         globalObject-&gt;debugger()-&gt;sourceParsed(globalObject, source().provider(), error.line(), error.message());</span>
  
      if (error.isValid())
          return error.toErrorObject(globalObject, source());
  
      JSValue nextPrototype = globalObject-&gt;getPrototypeDirect(vm);
      while (nextPrototype &amp;&amp; nextPrototype.isObject()) {
<span class="line-modified">!         if (UNLIKELY(asObject(nextPrototype)-&gt;type() == ProxyObjectType))</span>
<span class="line-modified">!             return createTypeError(globalObject, &quot;Proxy is not allowed in the global prototype chain.&quot;_s);</span>
          nextPrototype = asObject(nextPrototype)-&gt;getPrototypeDirect(vm);
      }
  
      JSGlobalLexicalEnvironment* globalLexicalEnvironment = globalObject-&gt;globalLexicalEnvironment();
      const VariableEnvironment&amp; variableDeclarations = unlinkedCodeBlock-&gt;variableDeclarations();
      const VariableEnvironment&amp; lexicalDeclarations = unlinkedCodeBlock-&gt;lexicalDeclarations();
      // The ES6 spec says that no vars/global properties/let/const can be duplicated in the global scope.
      // This carried out section 15.1.8 of the ES6 spec: http://www.ecma-international.org/ecma-262/6.0/index.html#sec-globaldeclarationinstantiation
      {
          // Check for intersection of &quot;var&quot; and &quot;let&quot;/&quot;const&quot;/&quot;class&quot;
          for (auto&amp; entry : lexicalDeclarations) {
              if (variableDeclarations.contains(entry.key))
<span class="line-modified">!                 return createSyntaxError(globalObject, makeString(&quot;Can&#39;t create duplicate variable: &#39;&quot;, String(entry.key.get()), &quot;&#39;&quot;));</span>
          }
  
          // Check if any new &quot;let&quot;/&quot;const&quot;/&quot;class&quot; will shadow any pre-existing global property names (with configurable = false), or &quot;var&quot;/&quot;let&quot;/&quot;const&quot; variables.
          // It&#39;s an error to introduce a shadow.
          for (auto&amp; entry : lexicalDeclarations) {
              // The ES6 spec says that RestrictedGlobalProperty can&#39;t be shadowed.
<span class="line-modified">!             GlobalPropertyLookUpStatus status = hasRestrictedGlobalProperty(globalObject, entry.key.get());</span>
              RETURN_IF_EXCEPTION(throwScope, nullptr);
              switch (status) {
              case GlobalPropertyLookUpStatus::NonConfigurable:
<span class="line-modified">!                 return createSyntaxError(globalObject, makeString(&quot;Can&#39;t create duplicate variable that shadows a global property: &#39;&quot;, String(entry.key.get()), &quot;&#39;&quot;));</span>
              case GlobalPropertyLookUpStatus::Configurable:
                  // Lexical bindings can shadow global properties if the given property&#39;s attribute is configurable.
                  // https://tc39.github.io/ecma262/#sec-globaldeclarationinstantiation step 5-c, `hasRestrictedGlobal` becomes false
                  // However we may emit GlobalProperty look up in bytecodes already and it may cache the value for the global scope.
                  // To make it invalid,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 134,31 ***</span>
                  break;
              case GlobalPropertyLookUpStatus::NotFound:
                  break;
              }
  
<span class="line-modified">!             bool hasProperty = globalLexicalEnvironment-&gt;hasProperty(exec, entry.key.get());</span>
              RETURN_IF_EXCEPTION(throwScope, nullptr);
              if (hasProperty) {
                  if (UNLIKELY(entry.value.isConst() &amp;&amp; !vm.globalConstRedeclarationShouldThrow() &amp;&amp; !isStrictMode())) {
                      // We only allow &quot;const&quot; duplicate declarations under this setting.
                      // For example, we don&#39;t &quot;let&quot; variables to be overridden by &quot;const&quot; variables.
                      if (globalLexicalEnvironment-&gt;isConstVariable(entry.key.get()))
                          continue;
                  }
<span class="line-modified">!                 return createSyntaxError(exec, makeString(&quot;Can&#39;t create duplicate variable: &#39;&quot;, String(entry.key.get()), &quot;&#39;&quot;));</span>
              }
          }
  
          // Check if any new &quot;var&quot;s will shadow any previous &quot;let&quot;/&quot;const&quot;/&quot;class&quot; names.
          // It&#39;s an error to introduce a shadow.
          if (!globalLexicalEnvironment-&gt;isEmpty()) {
              for (auto&amp; entry : variableDeclarations) {
<span class="line-modified">!                 bool hasProperty = globalLexicalEnvironment-&gt;hasProperty(exec, entry.key.get());</span>
                  RETURN_IF_EXCEPTION(throwScope, nullptr);
                  if (hasProperty)
<span class="line-modified">!                     return createSyntaxError(exec, makeString(&quot;Can&#39;t create duplicate variable: &#39;&quot;, String(entry.key.get()), &quot;&#39;&quot;));</span>
              }
          }
      }
  
  
<span class="line-new-header">--- 131,31 ---</span>
                  break;
              case GlobalPropertyLookUpStatus::NotFound:
                  break;
              }
  
<span class="line-modified">!             bool hasProperty = globalLexicalEnvironment-&gt;hasProperty(globalObject, entry.key.get());</span>
              RETURN_IF_EXCEPTION(throwScope, nullptr);
              if (hasProperty) {
                  if (UNLIKELY(entry.value.isConst() &amp;&amp; !vm.globalConstRedeclarationShouldThrow() &amp;&amp; !isStrictMode())) {
                      // We only allow &quot;const&quot; duplicate declarations under this setting.
                      // For example, we don&#39;t &quot;let&quot; variables to be overridden by &quot;const&quot; variables.
                      if (globalLexicalEnvironment-&gt;isConstVariable(entry.key.get()))
                          continue;
                  }
<span class="line-modified">!                 return createSyntaxError(globalObject, makeString(&quot;Can&#39;t create duplicate variable: &#39;&quot;, String(entry.key.get()), &quot;&#39;&quot;));</span>
              }
          }
  
          // Check if any new &quot;var&quot;s will shadow any previous &quot;let&quot;/&quot;const&quot;/&quot;class&quot; names.
          // It&#39;s an error to introduce a shadow.
          if (!globalLexicalEnvironment-&gt;isEmpty()) {
              for (auto&amp; entry : variableDeclarations) {
<span class="line-modified">!                 bool hasProperty = globalLexicalEnvironment-&gt;hasProperty(globalObject, entry.key.get());</span>
                  RETURN_IF_EXCEPTION(throwScope, nullptr);
                  if (hasProperty)
<span class="line-modified">!                     return createSyntaxError(globalObject, makeString(&quot;Can&#39;t create duplicate variable: &#39;&quot;, String(entry.key.get()), &quot;&#39;&quot;));</span>
              }
          }
      }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 167,21 ***</span>
      BatchedTransitionOptimizer optimizer(vm, globalObject);
  
      for (size_t i = 0, numberOfFunctions = unlinkedCodeBlock-&gt;numberOfFunctionDecls(); i &lt; numberOfFunctions; ++i) {
          UnlinkedFunctionExecutable* unlinkedFunctionExecutable = unlinkedCodeBlock-&gt;functionDecl(i);
          ASSERT(!unlinkedFunctionExecutable-&gt;name().isEmpty());
<span class="line-modified">!         globalObject-&gt;addFunction(callFrame, unlinkedFunctionExecutable-&gt;name());</span>
          if (vm.typeProfiler() || vm.controlFlowProfiler()) {
              vm.functionHasExecutedCache()-&gt;insertUnexecutedRange(sourceID(),
                  unlinkedFunctionExecutable-&gt;typeProfilingStartOffset(),
                  unlinkedFunctionExecutable-&gt;typeProfilingEndOffset());
          }
      }
  
      for (auto&amp; entry : variableDeclarations) {
          ASSERT(entry.value.isVar());
<span class="line-modified">!         globalObject-&gt;addVar(callFrame, Identifier::fromUid(vm, entry.key.get()));</span>
          throwScope.assertNoException();
      }
  
      {
          JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(globalObject-&gt;globalScope());
<span class="line-new-header">--- 164,21 ---</span>
      BatchedTransitionOptimizer optimizer(vm, globalObject);
  
      for (size_t i = 0, numberOfFunctions = unlinkedCodeBlock-&gt;numberOfFunctionDecls(); i &lt; numberOfFunctions; ++i) {
          UnlinkedFunctionExecutable* unlinkedFunctionExecutable = unlinkedCodeBlock-&gt;functionDecl(i);
          ASSERT(!unlinkedFunctionExecutable-&gt;name().isEmpty());
<span class="line-modified">!         globalObject-&gt;addFunction(globalObject, unlinkedFunctionExecutable-&gt;name());</span>
          if (vm.typeProfiler() || vm.controlFlowProfiler()) {
              vm.functionHasExecutedCache()-&gt;insertUnexecutedRange(sourceID(),
                  unlinkedFunctionExecutable-&gt;typeProfilingStartOffset(),
                  unlinkedFunctionExecutable-&gt;typeProfilingEndOffset());
          }
      }
  
      for (auto&amp; entry : variableDeclarations) {
          ASSERT(entry.value.isVar());
<span class="line-modified">!         globalObject-&gt;addVar(globalObject, Identifier::fromUid(vm, entry.key.get()));</span>
          throwScope.assertNoException();
      }
  
      {
          JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(globalObject-&gt;globalScope());
</pre>
<center><a href="ParseInt.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProgramExecutable.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
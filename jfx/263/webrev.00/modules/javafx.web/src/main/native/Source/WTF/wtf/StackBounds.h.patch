diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/StackBounds.h b/modules/javafx.web/src/main/native/Source/WTF/wtf/StackBounds.h
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/StackBounds.h
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/StackBounds.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2010-2017 Apple Inc. All Rights Reserved.
+ * Copyright (C) 2010-2019 Apple Inc. All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -32,20 +32,18 @@
 
 namespace WTF {
 
 class StackBounds {
     WTF_MAKE_FAST_ALLOCATED;
+public:
 
     // This 64k number was picked because a sampling of stack usage differences
     // between consecutive entries into one of the Interpreter::execute...()
     // functions was seen to be as high as 27k. Hence, 64k is chosen as a
     // conservative availability value that is not too large but comfortably
     // exceeds 27k with some buffer for error.
-    const static size_t s_defaultAvailabilityDelta = 64 * 1024;
-
-public:
-    enum class StackDirection { Upward, Downward };
+    static constexpr size_t DefaultReservedZone = 64 * 1024;
 
     static constexpr StackBounds emptyBounds() { return StackBounds(); }
 
 #if HAVE(STACK_BOUNDS_FOR_NEW_THREAD)
     // This function is only effective for newly created threads. In some platform, it returns a bogus value for the main thread.
@@ -70,96 +68,72 @@
         return m_bound;
     }
 
     size_t size() const
     {
-        if (isGrowingDownward())
-            return static_cast<char*>(m_origin) - static_cast<char*>(m_bound);
-        return static_cast<char*>(m_bound) - static_cast<char*>(m_origin);
+        return static_cast<char*>(m_origin) - static_cast<char*>(m_bound);
     }
 
     bool isEmpty() const { return !m_origin; }
 
     bool contains(void* p) const
     {
         if (isEmpty())
             return false;
-        if (isGrowingDownward())
-            return (m_origin >= p) && (p > m_bound);
-        return (m_bound > p) && (p >= m_origin);
+        return (m_origin >= p) && (p > m_bound);
     }
 
-    void* recursionLimit(size_t minAvailableDelta = s_defaultAvailabilityDelta) const
+    void* recursionLimit(size_t minReservedZone = DefaultReservedZone) const
     {
         checkConsistency();
-        if (isGrowingDownward())
-            return static_cast<char*>(m_bound) + minAvailableDelta;
-        return static_cast<char*>(m_bound) - minAvailableDelta;
+        return static_cast<char*>(m_bound) + minReservedZone;
     }
 
     void* recursionLimit(char* startOfUserStack, size_t maxUserStack, size_t reservedZoneSize) const
     {
         checkConsistency();
         if (maxUserStack < reservedZoneSize)
             reservedZoneSize = maxUserStack;
         size_t maxUserStackWithReservedZone = maxUserStack - reservedZoneSize;
 
-        if (isGrowingDownward()) {
-            char* endOfStackWithReservedZone = reinterpret_cast<char*>(m_bound) + reservedZoneSize;
-            if (startOfUserStack < endOfStackWithReservedZone)
-                return endOfStackWithReservedZone;
-            size_t availableUserStack = startOfUserStack - endOfStackWithReservedZone;
-            if (maxUserStackWithReservedZone > availableUserStack)
-                maxUserStackWithReservedZone = availableUserStack;
-            return startOfUserStack - maxUserStackWithReservedZone;
-        }
-
-        char* endOfStackWithReservedZone = reinterpret_cast<char*>(m_bound) - reservedZoneSize;
-        if (startOfUserStack > endOfStackWithReservedZone)
+        char* endOfStackWithReservedZone = reinterpret_cast<char*>(m_bound) + reservedZoneSize;
+        if (startOfUserStack < endOfStackWithReservedZone)
             return endOfStackWithReservedZone;
-        size_t availableUserStack = endOfStackWithReservedZone - startOfUserStack;
+        size_t availableUserStack = startOfUserStack - endOfStackWithReservedZone;
         if (maxUserStackWithReservedZone > availableUserStack)
             maxUserStackWithReservedZone = availableUserStack;
-        return startOfUserStack + maxUserStackWithReservedZone;
-    }
-
-    bool isGrowingDownward() const
-    {
-#if PLATFORM(JAVA)
-        //that is OK to have m_bound==0 on the main thread.
-        ASSERT(m_origin);
-#else
-        ASSERT(m_origin && m_bound);
-#endif
-        return m_bound <= m_origin;
+        return startOfUserStack - maxUserStackWithReservedZone;
     }
 
 private:
     StackBounds(void* origin, void* end)
         : m_origin(origin)
         , m_bound(end)
     {
+        ASSERT(isGrowingDownwards());
     }
 
     constexpr StackBounds()
         : m_origin(nullptr)
         , m_bound(nullptr)
     {
     }
 
-    static StackDirection stackDirection();
+    inline bool isGrowingDownwards() const
+    {
+        ASSERT(m_origin && m_bound);
+        return m_bound <= m_origin;
+    }
 
     WTF_EXPORT_PRIVATE static StackBounds currentThreadStackBoundsInternal();
 
     void checkConsistency() const
     {
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
         void* currentPosition = currentStackPointer();
         ASSERT(m_origin != m_bound);
-        ASSERT(isGrowingDownward()
-            ? (currentPosition < m_origin && currentPosition > m_bound)
-            : (currentPosition > m_origin && currentPosition < m_bound));
+        ASSERT(currentPosition < m_origin && currentPosition > m_bound);
 #endif
     }
 
     void* m_origin;
     void* m_bound;

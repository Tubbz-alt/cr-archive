<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/AssemblyHelpers.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AssemblyHelpers.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BinarySwitch.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/AssemblyHelpers.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,10 ***</span>
<span class="line-new-header">--- 33,11 ---</span>
  #include &quot;GPRInfo.h&quot;
  #include &quot;Heap.h&quot;
  #include &quot;InlineCallFrame.h&quot;
  #include &quot;JITAllocator.h&quot;
  #include &quot;JITCode.h&quot;
<span class="line-added">+ #include &quot;JSCellInlines.h&quot;</span>
  #include &quot;MacroAssembler.h&quot;
  #include &quot;MarkedSpace.h&quot;
  #include &quot;RegisterAtOffsetList.h&quot;
  #include &quot;RegisterSet.h&quot;
  #include &quot;StackAlignment.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,11 ***</span>
  #include &quot;TypeofType.h&quot;
  #include &quot;VM.h&quot;
  
  namespace JSC {
  
<span class="line-modified">! typedef void (*V_DebugOperation_EPP)(ExecState*, void*, void*);</span>
  
  class AssemblyHelpers : public MacroAssembler {
  public:
      AssemblyHelpers(CodeBlock* codeBlock)
          : m_codeBlock(codeBlock)
<span class="line-new-header">--- 45,11 ---</span>
  #include &quot;TypeofType.h&quot;
  #include &quot;VM.h&quot;
  
  namespace JSC {
  
<span class="line-modified">! typedef void (*V_DebugOperation_EPP)(CallFrame*, void*, void*);</span>
  
  class AssemblyHelpers : public MacroAssembler {
  public:
      AssemblyHelpers(CodeBlock* codeBlock)
          : m_codeBlock(codeBlock)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 63,20 ***</span>
<span class="line-new-header">--- 64,64 ---</span>
  
      CodeBlock* codeBlock() { return m_codeBlock; }
      VM&amp; vm() { return m_codeBlock-&gt;vm(); }
      AssemblerType_T&amp; assembler() { return m_assembler; }
  
<span class="line-added">+     void prepareCallOperation(VM&amp; vm)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         UNUSED_PARAM(vm);</span>
<span class="line-added">+ #if !USE(BUILTIN_FRAME_ADDRESS) || ASSERT_ENABLED</span>
<span class="line-added">+         storePtr(GPRInfo::callFrameRegister, &amp;vm.topCallFrame);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void checkStackPointerAlignment()
      {
          // This check is both unneeded and harder to write correctly for ARM64
  #if !defined(NDEBUG) &amp;&amp; !CPU(ARM64)
          Jump stackPointerAligned = branchTestPtr(Zero, stackPointerRegister, TrustedImm32(0xf));
          abortWithReason(AHStackPointerMisaligned);
          stackPointerAligned.link(this);
  #endif
      }
  
<span class="line-added">+ #if USE(JSVALUE64)</span>
<span class="line-added">+     void store64FromReg(Reg src, Address dst)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (src.isFPR())</span>
<span class="line-added">+             storeDouble(src.fpr(), dst);</span>
<span class="line-added">+         else</span>
<span class="line-added">+             store64(src.gpr(), dst);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     void store32FromReg(Reg src, Address dst)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (src.isFPR())</span>
<span class="line-added">+             storeFloat(src.fpr(), dst);</span>
<span class="line-added">+         else</span>
<span class="line-added">+             store32(src.gpr(), dst);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if USE(JSVALUE64)</span>
<span class="line-added">+     void load64ToReg(Address src, Reg dst)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (dst.isFPR())</span>
<span class="line-added">+             loadDouble(src, dst.fpr());</span>
<span class="line-added">+         else</span>
<span class="line-added">+             load64(src, dst.gpr());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     void load32ToReg(Address src, Reg dst)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (dst.isFPR())</span>
<span class="line-added">+             loadFloat(src, dst.fpr());</span>
<span class="line-added">+         else</span>
<span class="line-added">+             load32(src, dst.gpr());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      template&lt;typename T&gt;
      void storeCell(T cell, Address address)
      {
  #if USE(JSVALUE64)
          store64(cell, address);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 332,14 ***</span>
  
      void emitSaveThenMaterializeTagRegisters()
      {
  #if USE(JSVALUE64)
  #if CPU(ARM64)
<span class="line-modified">!         pushPair(GPRInfo::tagTypeNumberRegister, GPRInfo::tagMaskRegister);</span>
  #else
<span class="line-modified">!         push(GPRInfo::tagTypeNumberRegister);</span>
<span class="line-modified">!         push(GPRInfo::tagMaskRegister);</span>
  #endif
          emitMaterializeTagCheckRegisters();
  #endif
      }
  
<span class="line-new-header">--- 377,14 ---</span>
  
      void emitSaveThenMaterializeTagRegisters()
      {
  #if USE(JSVALUE64)
  #if CPU(ARM64)
<span class="line-modified">!         pushPair(GPRInfo::numberTagRegister, GPRInfo::notCellMaskRegister);</span>
  #else
<span class="line-modified">!         push(GPRInfo::numberTagRegister);</span>
<span class="line-modified">!         push(GPRInfo::notCellMaskRegister);</span>
  #endif
          emitMaterializeTagCheckRegisters();
  #endif
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 350,14 ***</span>
  
      void emitRestoreSavedTagRegisters()
      {
  #if USE(JSVALUE64)
  #if CPU(ARM64)
<span class="line-modified">!         popPair(GPRInfo::tagTypeNumberRegister, GPRInfo::tagMaskRegister);</span>
  #else
<span class="line-modified">!         pop(GPRInfo::tagMaskRegister);</span>
<span class="line-modified">!         pop(GPRInfo::tagTypeNumberRegister);</span>
  #endif
  #endif
      }
  
      // If you use this, be aware that vmGPR will get trashed.
<span class="line-new-header">--- 395,14 ---</span>
  
      void emitRestoreSavedTagRegisters()
      {
  #if USE(JSVALUE64)
  #if CPU(ARM64)
<span class="line-modified">!         popPair(GPRInfo::numberTagRegister, GPRInfo::notCellMaskRegister);</span>
  #else
<span class="line-modified">!         pop(GPRInfo::notCellMaskRegister);</span>
<span class="line-modified">!         pop(GPRInfo::numberTagRegister);</span>
  #endif
  #endif
      }
  
      // If you use this, be aware that vmGPR will get trashed.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 450,40 ***</span>
      }
  
      void emitMaterializeTagCheckRegisters()
      {
  #if USE(JSVALUE64)
<span class="line-modified">!         move(MacroAssembler::TrustedImm64(TagTypeNumber), GPRInfo::tagTypeNumberRegister);</span>
<span class="line-modified">!         orPtr(MacroAssembler::TrustedImm32(TagBitTypeOther), GPRInfo::tagTypeNumberRegister, GPRInfo::tagMaskRegister);</span>
  #endif
      }
  
<span class="line-modified">!     void clearStackFrame(GPRReg currentTop, GPRReg newTop, GPRReg temp, unsigned frameSize)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         ASSERT(frameSize % stackAlignmentBytes() == 0);</span>
<span class="line-removed">-         if (frameSize &lt;= 128) {</span>
<span class="line-removed">-             for (unsigned offset = 0; offset &lt; frameSize; offset += sizeof(CPURegister))</span>
<span class="line-removed">-                 storePtr(TrustedImm32(0), Address(currentTop, -8 - offset));</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             constexpr unsigned storeBytesPerIteration = stackAlignmentBytes();</span>
<span class="line-removed">-             constexpr unsigned storesPerIteration = storeBytesPerIteration / sizeof(CPURegister);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             move(currentTop, temp);</span>
<span class="line-removed">-             Label zeroLoop = label();</span>
<span class="line-removed">-             subPtr(TrustedImm32(storeBytesPerIteration), temp);</span>
<span class="line-removed">- #if CPU(ARM64)</span>
<span class="line-removed">-             static_assert(storesPerIteration == 2, &quot;clearStackFrame() for ARM64 assumes stack is 16 byte aligned&quot;);</span>
<span class="line-removed">-             storePair64(ARM64Registers::zr, ARM64Registers::zr, temp);</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-             for (unsigned i = storesPerIteration; i-- != 0;)</span>
<span class="line-removed">-                 storePtr(TrustedImm32(0), Address(temp, sizeof(CPURegister) * i));</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-             branchPtr(NotEqual, temp, newTop).linkTo(zeroLoop, this);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if CPU(X86_64) || CPU(X86)</span>
      static constexpr size_t prologueStackPointerDelta()
      {
          // Prologue only saves the framePointerRegister
          return sizeof(void*);
      }
<span class="line-new-header">--- 495,16 ---</span>
      }
  
      void emitMaterializeTagCheckRegisters()
      {
  #if USE(JSVALUE64)
<span class="line-modified">!         move(MacroAssembler::TrustedImm64(JSValue::NumberTag), GPRInfo::numberTagRegister);</span>
<span class="line-modified">!         orPtr(MacroAssembler::TrustedImm32(JSValue::OtherTag), GPRInfo::numberTagRegister, GPRInfo::notCellMaskRegister);</span>
  #endif
      }
  
<span class="line-modified">! #if CPU(X86_64)</span>
      static constexpr size_t prologueStackPointerDelta()
      {
          // Prologue only saves the framePointerRegister
          return sizeof(void*);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 517,11 ***</span>
  
      void restoreReturnAddressBeforeReturn(Address address)
      {
          push(address);
      }
<span class="line-modified">! #endif // CPU(X86_64) || CPU(X86)</span>
  
  #if CPU(ARM_THUMB2) || CPU(ARM64)
      static constexpr size_t prologueStackPointerDelta()
      {
          // Prologue saves the framePointerRegister and linkRegister
<span class="line-new-header">--- 538,11 ---</span>
  
      void restoreReturnAddressBeforeReturn(Address address)
      {
          push(address);
      }
<span class="line-modified">! #endif // CPU(X86_64)</span>
  
  #if CPU(ARM_THUMB2) || CPU(ARM64)
      static constexpr size_t prologueStackPointerDelta()
      {
          // Prologue saves the framePointerRegister and linkRegister
</pre>
<hr />
<pre>
<span class="line-old-header">*** 600,32 ***</span>
      {
          loadPtr(address, returnAddressRegister);
      }
  #endif
  
<span class="line-modified">!     void emitGetFromCallFrameHeaderPtr(int entry, GPRReg to, GPRReg from = GPRInfo::callFrameRegister)</span>
      {
<span class="line-modified">!         loadPtr(Address(from, entry * sizeof(Register)), to);</span>
      }
<span class="line-modified">!     void emitGetFromCallFrameHeader32(int entry, GPRReg to, GPRReg from = GPRInfo::callFrameRegister)</span>
      {
<span class="line-modified">!         load32(Address(from, entry * sizeof(Register)), to);</span>
      }
  #if USE(JSVALUE64)
<span class="line-modified">!     void emitGetFromCallFrameHeader64(int entry, GPRReg to, GPRReg from = GPRInfo::callFrameRegister)</span>
      {
<span class="line-modified">!         load64(Address(from, entry * sizeof(Register)), to);</span>
      }
  #endif // USE(JSVALUE64)
<span class="line-modified">!     void emitPutToCallFrameHeader(GPRReg from, int entry)</span>
      {
<span class="line-modified">!         storePtr(from, Address(GPRInfo::callFrameRegister, entry * sizeof(Register)));</span>
      }
  
<span class="line-modified">!     void emitPutToCallFrameHeader(void* value, int entry)</span>
      {
<span class="line-modified">!         storePtr(TrustedImmPtr(value), Address(GPRInfo::callFrameRegister, entry * sizeof(Register)));</span>
      }
  
      void emitGetCallerFrameFromCallFrameHeaderPtr(RegisterID to)
      {
          loadPtr(Address(GPRInfo::callFrameRegister, CallFrame::callerFrameOffset()), to);
<span class="line-new-header">--- 621,32 ---</span>
      {
          loadPtr(address, returnAddressRegister);
      }
  #endif
  
<span class="line-modified">!     void emitGetFromCallFrameHeaderPtr(VirtualRegister entry, GPRReg to, GPRReg from = GPRInfo::callFrameRegister)</span>
      {
<span class="line-modified">!         loadPtr(Address(from, entry.offset() * sizeof(Register)), to);</span>
      }
<span class="line-modified">!     void emitGetFromCallFrameHeader32(VirtualRegister entry, GPRReg to, GPRReg from = GPRInfo::callFrameRegister)</span>
      {
<span class="line-modified">!         load32(Address(from, entry.offset() * sizeof(Register)), to);</span>
      }
  #if USE(JSVALUE64)
<span class="line-modified">!     void emitGetFromCallFrameHeader64(VirtualRegister entry, GPRReg to, GPRReg from = GPRInfo::callFrameRegister)</span>
      {
<span class="line-modified">!         load64(Address(from, entry.offset() * sizeof(Register)), to);</span>
      }
  #endif // USE(JSVALUE64)
<span class="line-modified">!     void emitPutToCallFrameHeader(GPRReg from, VirtualRegister entry)</span>
      {
<span class="line-modified">!         storePtr(from, Address(GPRInfo::callFrameRegister, entry.offset() * sizeof(Register)));</span>
      }
  
<span class="line-modified">!     void emitPutToCallFrameHeader(void* value, VirtualRegister entry)</span>
      {
<span class="line-modified">!         storePtr(TrustedImmPtr(value), Address(GPRInfo::callFrameRegister, entry.offset() * sizeof(Register)));</span>
      }
  
      void emitGetCallerFrameFromCallFrameHeaderPtr(RegisterID to)
      {
          loadPtr(Address(GPRInfo::callFrameRegister, CallFrame::callerFrameOffset()), to);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 649,23 ***</span>
      // First, the access is via the stack pointer. Second, the address calculation must also take
      // into account that the stack pointer may not have been adjusted down for the return PC and/or
      // caller&#39;s frame pointer. On some platforms, the callee is responsible for pushing the
      // &quot;link register&quot; containing the return address in the function prologue.
  #if USE(JSVALUE64)
<span class="line-modified">!     void emitPutToCallFrameHeaderBeforePrologue(GPRReg from, int entry)</span>
      {
<span class="line-modified">!         storePtr(from, Address(stackPointerRegister, entry * static_cast&lt;ptrdiff_t&gt;(sizeof(Register)) - prologueStackPointerDelta()));</span>
      }
  #else
<span class="line-modified">!     void emitPutPayloadToCallFrameHeaderBeforePrologue(GPRReg from, int entry)</span>
      {
<span class="line-modified">!         storePtr(from, Address(stackPointerRegister, entry * static_cast&lt;ptrdiff_t&gt;(sizeof(Register)) - prologueStackPointerDelta() + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.payload)));</span>
      }
  
<span class="line-modified">!     void emitPutTagToCallFrameHeaderBeforePrologue(TrustedImm32 tag, int entry)</span>
      {
<span class="line-modified">!         storePtr(tag, Address(stackPointerRegister, entry * static_cast&lt;ptrdiff_t&gt;(sizeof(Register)) - prologueStackPointerDelta() + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.tag)));</span>
      }
  #endif
  
      JumpList branchIfNotEqual(JSValueRegs regs, JSValue value)
      {
<span class="line-new-header">--- 670,23 ---</span>
      // First, the access is via the stack pointer. Second, the address calculation must also take
      // into account that the stack pointer may not have been adjusted down for the return PC and/or
      // caller&#39;s frame pointer. On some platforms, the callee is responsible for pushing the
      // &quot;link register&quot; containing the return address in the function prologue.
  #if USE(JSVALUE64)
<span class="line-modified">!     void emitPutToCallFrameHeaderBeforePrologue(GPRReg from, VirtualRegister entry)</span>
      {
<span class="line-modified">!         storePtr(from, Address(stackPointerRegister, entry.offset() * static_cast&lt;ptrdiff_t&gt;(sizeof(Register)) - prologueStackPointerDelta()));</span>
      }
  #else
<span class="line-modified">!     void emitPutPayloadToCallFrameHeaderBeforePrologue(GPRReg from, VirtualRegister entry)</span>
      {
<span class="line-modified">!         storePtr(from, Address(stackPointerRegister, entry.offset() * static_cast&lt;ptrdiff_t&gt;(sizeof(Register)) - prologueStackPointerDelta() + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.payload)));</span>
      }
  
<span class="line-modified">!     void emitPutTagToCallFrameHeaderBeforePrologue(TrustedImm32 tag, VirtualRegister entry)</span>
      {
<span class="line-modified">!         storePtr(tag, Address(stackPointerRegister, entry.offset() * static_cast&lt;ptrdiff_t&gt;(sizeof(Register)) - prologueStackPointerDelta() + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.tag)));</span>
      }
  #endif
  
      JumpList branchIfNotEqual(JSValueRegs regs, JSValue value)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 699,12 ***</span>
  
      Jump branchIfNotCell(GPRReg reg, TagRegistersMode mode = HaveTagRegisters)
      {
  #if USE(JSVALUE64)
          if (mode == HaveTagRegisters)
<span class="line-modified">!             return branchTest64(NonZero, reg, GPRInfo::tagMaskRegister);</span>
<span class="line-modified">!         return branchTest64(NonZero, reg, TrustedImm64(TagMask));</span>
  #else
          UNUSED_PARAM(mode);
          return branch32(MacroAssembler::NotEqual, reg, TrustedImm32(JSValue::CellTag));
  #endif
      }
<span class="line-new-header">--- 720,12 ---</span>
  
      Jump branchIfNotCell(GPRReg reg, TagRegistersMode mode = HaveTagRegisters)
      {
  #if USE(JSVALUE64)
          if (mode == HaveTagRegisters)
<span class="line-modified">!             return branchTest64(NonZero, reg, GPRInfo::notCellMaskRegister);</span>
<span class="line-modified">!         return branchTest64(NonZero, reg, TrustedImm64(JSValue::NotCellMask));</span>
  #else
          UNUSED_PARAM(mode);
          return branch32(MacroAssembler::NotEqual, reg, TrustedImm32(JSValue::CellTag));
  #endif
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 720,12 ***</span>
  
      Jump branchIfCell(GPRReg reg, TagRegistersMode mode = HaveTagRegisters)
      {
  #if USE(JSVALUE64)
          if (mode == HaveTagRegisters)
<span class="line-modified">!             return branchTest64(Zero, reg, GPRInfo::tagMaskRegister);</span>
<span class="line-modified">!         return branchTest64(Zero, reg, TrustedImm64(TagMask));</span>
  #else
          UNUSED_PARAM(mode);
          return branch32(MacroAssembler::Equal, reg, TrustedImm32(JSValue::CellTag));
  #endif
      }
<span class="line-new-header">--- 741,12 ---</span>
  
      Jump branchIfCell(GPRReg reg, TagRegistersMode mode = HaveTagRegisters)
      {
  #if USE(JSVALUE64)
          if (mode == HaveTagRegisters)
<span class="line-modified">!             return branchTest64(Zero, reg, GPRInfo::notCellMaskRegister);</span>
<span class="line-modified">!         return branchTest64(Zero, reg, TrustedImm64(JSValue::NotCellMask));</span>
  #else
          UNUSED_PARAM(mode);
          return branch32(MacroAssembler::Equal, reg, TrustedImm32(JSValue::CellTag));
  #endif
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 740,36 ***</span>
  
      Jump branchIfOther(JSValueRegs regs, GPRReg tempGPR)
      {
  #if USE(JSVALUE64)
          move(regs.gpr(), tempGPR);
<span class="line-modified">!         and64(TrustedImm32(~TagBitUndefined), tempGPR);</span>
<span class="line-modified">!         return branch64(Equal, tempGPR, TrustedImm64(ValueNull));</span>
  #else
          or32(TrustedImm32(1), regs.tagGPR(), tempGPR);
          return branch32(Equal, tempGPR, TrustedImm32(JSValue::NullTag));
  #endif
      }
  
      Jump branchIfNotOther(JSValueRegs regs, GPRReg tempGPR)
      {
  #if USE(JSVALUE64)
          move(regs.gpr(), tempGPR);
<span class="line-modified">!         and64(TrustedImm32(~TagBitUndefined), tempGPR);</span>
<span class="line-modified">!         return branch64(NotEqual, tempGPR, TrustedImm64(ValueNull));</span>
  #else
          or32(TrustedImm32(1), regs.tagGPR(), tempGPR);
          return branch32(NotEqual, tempGPR, TrustedImm32(JSValue::NullTag));
  #endif
      }
  
      Jump branchIfInt32(GPRReg gpr, TagRegistersMode mode = HaveTagRegisters)
      {
  #if USE(JSVALUE64)
          if (mode == HaveTagRegisters)
<span class="line-modified">!             return branch64(AboveOrEqual, gpr, GPRInfo::tagTypeNumberRegister);</span>
<span class="line-modified">!         return branch64(AboveOrEqual, gpr, TrustedImm64(TagTypeNumber));</span>
  #else
          UNUSED_PARAM(mode);
          return branch32(Equal, gpr, TrustedImm32(JSValue::Int32Tag));
  #endif
      }
<span class="line-new-header">--- 761,36 ---</span>
  
      Jump branchIfOther(JSValueRegs regs, GPRReg tempGPR)
      {
  #if USE(JSVALUE64)
          move(regs.gpr(), tempGPR);
<span class="line-modified">!         and64(TrustedImm32(~JSValue::UndefinedTag), tempGPR);</span>
<span class="line-modified">!         return branch64(Equal, tempGPR, TrustedImm64(JSValue::ValueNull));</span>
  #else
          or32(TrustedImm32(1), regs.tagGPR(), tempGPR);
          return branch32(Equal, tempGPR, TrustedImm32(JSValue::NullTag));
  #endif
      }
  
      Jump branchIfNotOther(JSValueRegs regs, GPRReg tempGPR)
      {
  #if USE(JSVALUE64)
          move(regs.gpr(), tempGPR);
<span class="line-modified">!         and64(TrustedImm32(~JSValue::UndefinedTag), tempGPR);</span>
<span class="line-modified">!         return branch64(NotEqual, tempGPR, TrustedImm64(JSValue::ValueNull));</span>
  #else
          or32(TrustedImm32(1), regs.tagGPR(), tempGPR);
          return branch32(NotEqual, tempGPR, TrustedImm32(JSValue::NullTag));
  #endif
      }
  
      Jump branchIfInt32(GPRReg gpr, TagRegistersMode mode = HaveTagRegisters)
      {
  #if USE(JSVALUE64)
          if (mode == HaveTagRegisters)
<span class="line-modified">!             return branch64(AboveOrEqual, gpr, GPRInfo::numberTagRegister);</span>
<span class="line-modified">!         return branch64(AboveOrEqual, gpr, TrustedImm64(JSValue::NumberTag));</span>
  #else
          UNUSED_PARAM(mode);
          return branch32(Equal, gpr, TrustedImm32(JSValue::Int32Tag));
  #endif
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 785,12 ***</span>
  
      Jump branchIfNotInt32(GPRReg gpr, TagRegistersMode mode = HaveTagRegisters)
      {
  #if USE(JSVALUE64)
          if (mode == HaveTagRegisters)
<span class="line-modified">!             return branch64(Below, gpr, GPRInfo::tagTypeNumberRegister);</span>
<span class="line-modified">!         return branch64(Below, gpr, TrustedImm64(TagTypeNumber));</span>
  #else
          UNUSED_PARAM(mode);
          return branch32(NotEqual, gpr, TrustedImm32(JSValue::Int32Tag));
  #endif
      }
<span class="line-new-header">--- 806,12 ---</span>
  
      Jump branchIfNotInt32(GPRReg gpr, TagRegistersMode mode = HaveTagRegisters)
      {
  #if USE(JSVALUE64)
          if (mode == HaveTagRegisters)
<span class="line-modified">!             return branch64(Below, gpr, GPRInfo::numberTagRegister);</span>
<span class="line-modified">!         return branch64(Below, gpr, TrustedImm64(JSValue::NumberTag));</span>
  #else
          UNUSED_PARAM(mode);
          return branch32(NotEqual, gpr, TrustedImm32(JSValue::Int32Tag));
  #endif
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 820,12 ***</span>
  
  #if USE(JSVALUE64)
      Jump branchIfNumber(GPRReg gpr, TagRegistersMode mode = HaveTagRegisters)
      {
          if (mode == HaveTagRegisters)
<span class="line-modified">!             return branchTest64(NonZero, gpr, GPRInfo::tagTypeNumberRegister);</span>
<span class="line-modified">!         return branchTest64(NonZero, gpr, TrustedImm64(TagTypeNumber));</span>
      }
  #endif
  
      // Note that the tempGPR is not used in 64-bit mode.
      Jump branchIfNotNumber(JSValueRegs regs, GPRReg tempGPR, TagRegistersMode mode = HaveTagRegisters)
<span class="line-new-header">--- 841,12 ---</span>
  
  #if USE(JSVALUE64)
      Jump branchIfNumber(GPRReg gpr, TagRegistersMode mode = HaveTagRegisters)
      {
          if (mode == HaveTagRegisters)
<span class="line-modified">!             return branchTest64(NonZero, gpr, GPRInfo::numberTagRegister);</span>
<span class="line-modified">!         return branchTest64(NonZero, gpr, TrustedImm64(JSValue::NumberTag));</span>
      }
  #endif
  
      // Note that the tempGPR is not used in 64-bit mode.
      Jump branchIfNotNumber(JSValueRegs regs, GPRReg tempGPR, TagRegistersMode mode = HaveTagRegisters)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 842,21 ***</span>
  
  #if USE(JSVALUE64)
      Jump branchIfNotNumber(GPRReg gpr, TagRegistersMode mode = HaveTagRegisters)
      {
          if (mode == HaveTagRegisters)
<span class="line-modified">!             return branchTest64(Zero, gpr, GPRInfo::tagTypeNumberRegister);</span>
<span class="line-modified">!         return branchTest64(Zero, gpr, TrustedImm64(TagTypeNumber));</span>
      }
  #endif
  
      Jump branchIfNotDoubleKnownNotInt32(JSValueRegs regs, TagRegistersMode mode = HaveTagRegisters)
      {
  #if USE(JSVALUE64)
          if (mode == HaveTagRegisters)
<span class="line-modified">!             return branchTest64(Zero, regs.gpr(), GPRInfo::tagTypeNumberRegister);</span>
<span class="line-modified">!         return branchTest64(Zero, regs.gpr(), TrustedImm64(TagTypeNumber));</span>
  #else
          UNUSED_PARAM(mode);
          return branch32(AboveOrEqual, regs.tagGPR(), TrustedImm32(JSValue::LowestTag));
  #endif
      }
<span class="line-new-header">--- 863,21 ---</span>
  
  #if USE(JSVALUE64)
      Jump branchIfNotNumber(GPRReg gpr, TagRegistersMode mode = HaveTagRegisters)
      {
          if (mode == HaveTagRegisters)
<span class="line-modified">!             return branchTest64(Zero, gpr, GPRInfo::numberTagRegister);</span>
<span class="line-modified">!         return branchTest64(Zero, gpr, TrustedImm64(JSValue::NumberTag));</span>
      }
  #endif
  
      Jump branchIfNotDoubleKnownNotInt32(JSValueRegs regs, TagRegistersMode mode = HaveTagRegisters)
      {
  #if USE(JSVALUE64)
          if (mode == HaveTagRegisters)
<span class="line-modified">!             return branchTest64(Zero, regs.gpr(), GPRInfo::numberTagRegister);</span>
<span class="line-modified">!         return branchTest64(Zero, regs.gpr(), TrustedImm64(JSValue::NumberTag));</span>
  #else
          UNUSED_PARAM(mode);
          return branch32(AboveOrEqual, regs.tagGPR(), TrustedImm32(JSValue::LowestTag));
  #endif
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 865,11 ***</span>
      Jump branchIfBoolean(GPRReg gpr, GPRReg tempGPR)
      {
  #if USE(JSVALUE64)
          ASSERT(tempGPR != InvalidGPRReg);
          move(gpr, tempGPR);
<span class="line-modified">!         xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), tempGPR);</span>
          return branchTest64(Zero, tempGPR, TrustedImm32(static_cast&lt;int32_t&gt;(~1)));
  #else
          UNUSED_PARAM(tempGPR);
          return branch32(Equal, gpr, TrustedImm32(JSValue::BooleanTag));
  #endif
<span class="line-new-header">--- 886,11 ---</span>
      Jump branchIfBoolean(GPRReg gpr, GPRReg tempGPR)
      {
  #if USE(JSVALUE64)
          ASSERT(tempGPR != InvalidGPRReg);
          move(gpr, tempGPR);
<span class="line-modified">!         xor64(TrustedImm32(JSValue::ValueFalse), tempGPR);</span>
          return branchTest64(Zero, tempGPR, TrustedImm32(static_cast&lt;int32_t&gt;(~1)));
  #else
          UNUSED_PARAM(tempGPR);
          return branch32(Equal, gpr, TrustedImm32(JSValue::BooleanTag));
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 889,11 ***</span>
      Jump branchIfNotBoolean(GPRReg gpr, GPRReg tempGPR)
      {
  #if USE(JSVALUE64)
          ASSERT(tempGPR != InvalidGPRReg);
          move(gpr, tempGPR);
<span class="line-modified">!         xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), tempGPR);</span>
          return branchTest64(NonZero, tempGPR, TrustedImm32(static_cast&lt;int32_t&gt;(~1)));
  #else
          UNUSED_PARAM(tempGPR);
          return branch32(NotEqual, gpr, TrustedImm32(JSValue::BooleanTag));
  #endif
<span class="line-new-header">--- 910,11 ---</span>
      Jump branchIfNotBoolean(GPRReg gpr, GPRReg tempGPR)
      {
  #if USE(JSVALUE64)
          ASSERT(tempGPR != InvalidGPRReg);
          move(gpr, tempGPR);
<span class="line-modified">!         xor64(TrustedImm32(JSValue::ValueFalse), tempGPR);</span>
          return branchTest64(NonZero, tempGPR, TrustedImm32(static_cast&lt;int32_t&gt;(~1)));
  #else
          UNUSED_PARAM(tempGPR);
          return branch32(NotEqual, gpr, TrustedImm32(JSValue::BooleanTag));
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1101,13 ***</span>
          // cannot do this. We use this in places where the stack pointer has been moved to some
          // unpredictable location.
          ASSERT(virtualRegister.isValid());
          return Address(GPRInfo::callFrameRegister, virtualRegister.offset() * sizeof(Register));
      }
<span class="line-modified">!     static Address addressFor(int operand)</span>
      {
<span class="line-modified">!         return addressFor(static_cast&lt;VirtualRegister&gt;(operand));</span>
      }
  
      static Address tagFor(VirtualRegister virtualRegister, GPRReg baseGPR)
      {
          ASSERT(virtualRegister.isValid());
<span class="line-new-header">--- 1122,14 ---</span>
          // cannot do this. We use this in places where the stack pointer has been moved to some
          // unpredictable location.
          ASSERT(virtualRegister.isValid());
          return Address(GPRInfo::callFrameRegister, virtualRegister.offset() * sizeof(Register));
      }
<span class="line-modified">!     static Address addressFor(Operand operand)</span>
      {
<span class="line-modified">!         ASSERT(!operand.isTmp());</span>
<span class="line-added">+         return addressFor(operand.virtualRegister());</span>
      }
  
      static Address tagFor(VirtualRegister virtualRegister, GPRReg baseGPR)
      {
          ASSERT(virtualRegister.isValid());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1116,13 ***</span>
      static Address tagFor(VirtualRegister virtualRegister)
      {
          ASSERT(virtualRegister.isValid());
          return Address(GPRInfo::callFrameRegister, virtualRegister.offset() * sizeof(Register) + TagOffset);
      }
<span class="line-modified">!     static Address tagFor(int operand)</span>
      {
<span class="line-modified">!         return tagFor(static_cast&lt;VirtualRegister&gt;(operand));</span>
      }
  
      static Address payloadFor(VirtualRegister virtualRegister, GPRReg baseGPR)
      {
          ASSERT(virtualRegister.isValid());
<span class="line-new-header">--- 1138,14 ---</span>
      static Address tagFor(VirtualRegister virtualRegister)
      {
          ASSERT(virtualRegister.isValid());
          return Address(GPRInfo::callFrameRegister, virtualRegister.offset() * sizeof(Register) + TagOffset);
      }
<span class="line-modified">!     static Address tagFor(Operand operand)</span>
      {
<span class="line-modified">!         ASSERT(!operand.isTmp());</span>
<span class="line-added">+         return tagFor(operand.virtualRegister());</span>
      }
  
      static Address payloadFor(VirtualRegister virtualRegister, GPRReg baseGPR)
      {
          ASSERT(virtualRegister.isValid());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1131,34 ***</span>
      static Address payloadFor(VirtualRegister virtualRegister)
      {
          ASSERT(virtualRegister.isValid());
          return Address(GPRInfo::callFrameRegister, virtualRegister.offset() * sizeof(Register) + PayloadOffset);
      }
<span class="line-modified">!     static Address payloadFor(int operand)</span>
      {
<span class="line-modified">!         return payloadFor(static_cast&lt;VirtualRegister&gt;(operand));</span>
      }
  
      // Access to our fixed callee CallFrame.
<span class="line-modified">!     static Address calleeFrameSlot(int slot)</span>
      {
<span class="line-modified">!         ASSERT(slot &gt;= CallerFrameAndPC::sizeInRegisters);</span>
<span class="line-modified">!         return Address(stackPointerRegister, sizeof(Register) * (slot - CallerFrameAndPC::sizeInRegisters));</span>
      }
  
      // Access to our fixed callee CallFrame.
      static Address calleeArgumentSlot(int argument)
      {
<span class="line-modified">!         return calleeFrameSlot(virtualRegisterForArgument(argument).offset());</span>
      }
  
<span class="line-modified">!     static Address calleeFrameTagSlot(int slot)</span>
      {
          return calleeFrameSlot(slot).withOffset(TagOffset);
      }
  
<span class="line-modified">!     static Address calleeFramePayloadSlot(int slot)</span>
      {
          return calleeFrameSlot(slot).withOffset(PayloadOffset);
      }
  
      static Address calleeArgumentTagSlot(int argument)
<span class="line-new-header">--- 1154,35 ---</span>
      static Address payloadFor(VirtualRegister virtualRegister)
      {
          ASSERT(virtualRegister.isValid());
          return Address(GPRInfo::callFrameRegister, virtualRegister.offset() * sizeof(Register) + PayloadOffset);
      }
<span class="line-modified">!     static Address payloadFor(Operand operand)</span>
      {
<span class="line-modified">!         ASSERT(!operand.isTmp());</span>
<span class="line-added">+         return payloadFor(operand.virtualRegister());</span>
      }
  
      // Access to our fixed callee CallFrame.
<span class="line-modified">!     static Address calleeFrameSlot(VirtualRegister slot)</span>
      {
<span class="line-modified">!         ASSERT(slot.offset() &gt;= CallerFrameAndPC::sizeInRegisters);</span>
<span class="line-modified">!         return Address(stackPointerRegister, sizeof(Register) * (slot - CallerFrameAndPC::sizeInRegisters).offset());</span>
      }
  
      // Access to our fixed callee CallFrame.
      static Address calleeArgumentSlot(int argument)
      {
<span class="line-modified">!         return calleeFrameSlot(virtualRegisterForArgumentIncludingThis(argument));</span>
      }
  
<span class="line-modified">!     static Address calleeFrameTagSlot(VirtualRegister slot)</span>
      {
          return calleeFrameSlot(slot).withOffset(TagOffset);
      }
  
<span class="line-modified">!     static Address calleeFramePayloadSlot(VirtualRegister slot)</span>
      {
          return calleeFrameSlot(slot).withOffset(PayloadOffset);
      }
  
      static Address calleeArgumentTagSlot(int argument)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1171,11 ***</span>
          return calleeArgumentSlot(argument).withOffset(PayloadOffset);
      }
  
      static Address calleeFrameCallerFrame()
      {
<span class="line-modified">!         return calleeFrameSlot(0).withOffset(CallFrame::callerFrameOffset());</span>
      }
  
      static GPRReg selectScratchGPR(RegisterSet preserved)
      {
          GPRReg registers[] = {
<span class="line-new-header">--- 1195,11 ---</span>
          return calleeArgumentSlot(argument).withOffset(PayloadOffset);
      }
  
      static Address calleeFrameCallerFrame()
      {
<span class="line-modified">!         return calleeFrameSlot(VirtualRegister(0)).withOffset(CallFrame::callerFrameOffset());</span>
      }
  
      static GPRReg selectScratchGPR(RegisterSet preserved)
      {
          GPRReg registers[] = {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1227,11 ***</span>
  
      // Add a debug call. This call has no effect on JIT code execution state.
      void debugCall(VM&amp;, V_DebugOperation_EPP function, void* argument);
  
      // These methods JIT generate dynamic, debug-only checks - akin to ASSERTs.
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      void jitAssertIsInt32(GPRReg);
      void jitAssertIsJSInt32(GPRReg);
      void jitAssertIsJSNumber(GPRReg);
      void jitAssertIsJSDouble(GPRReg);
      void jitAssertIsCell(GPRReg);
<span class="line-new-header">--- 1251,11 ---</span>
  
      // Add a debug call. This call has no effect on JIT code execution state.
      void debugCall(VM&amp;, V_DebugOperation_EPP function, void* argument);
  
      // These methods JIT generate dynamic, debug-only checks - akin to ASSERTs.
<span class="line-modified">! #if ASSERT_ENABLED</span>
      void jitAssertIsInt32(GPRReg);
      void jitAssertIsJSInt32(GPRReg);
      void jitAssertIsJSNumber(GPRReg);
      void jitAssertIsJSDouble(GPRReg);
      void jitAssertIsCell(GPRReg);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1262,20 ***</span>
  #if USE(JSVALUE64)
      GPRReg boxDouble(FPRReg fpr, GPRReg gpr, TagRegistersMode mode = HaveTagRegisters)
      {
          moveDoubleTo64(fpr, gpr);
          if (mode == DoNotHaveTagRegisters)
<span class="line-modified">!             sub64(TrustedImm64(TagTypeNumber), gpr);</span>
          else {
<span class="line-modified">!             sub64(GPRInfo::tagTypeNumberRegister, gpr);</span>
              jitAssertIsJSDouble(gpr);
          }
          return gpr;
      }
      FPRReg unboxDoubleWithoutAssertions(GPRReg gpr, GPRReg resultGPR, FPRReg fpr)
      {
<span class="line-modified">!         add64(GPRInfo::tagTypeNumberRegister, gpr, resultGPR);</span>
          move64ToDouble(resultGPR, fpr);
          return fpr;
      }
      FPRReg unboxDouble(GPRReg gpr, GPRReg resultGPR, FPRReg fpr)
      {
<span class="line-new-header">--- 1286,20 ---</span>
  #if USE(JSVALUE64)
      GPRReg boxDouble(FPRReg fpr, GPRReg gpr, TagRegistersMode mode = HaveTagRegisters)
      {
          moveDoubleTo64(fpr, gpr);
          if (mode == DoNotHaveTagRegisters)
<span class="line-modified">!             sub64(TrustedImm64(JSValue::NumberTag), gpr);</span>
          else {
<span class="line-modified">!             sub64(GPRInfo::numberTagRegister, gpr);</span>
              jitAssertIsJSDouble(gpr);
          }
          return gpr;
      }
      FPRReg unboxDoubleWithoutAssertions(GPRReg gpr, GPRReg resultGPR, FPRReg fpr)
      {
<span class="line-modified">!         add64(GPRInfo::numberTagRegister, gpr, resultGPR);</span>
          move64ToDouble(resultGPR, fpr);
          return fpr;
      }
      FPRReg unboxDouble(GPRReg gpr, GPRReg resultGPR, FPRReg fpr)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1308,11 ***</span>
          boxDouble(fpScratch, target);
          Jump done = jump();
  
          isInt32.link(this);
          zeroExtend32ToPtr(source, target);
<span class="line-modified">!         or64(GPRInfo::tagTypeNumberRegister, target);</span>
  
          done.link(this);
      }
  #endif
  
<span class="line-new-header">--- 1332,11 ---</span>
          boxDouble(fpScratch, target);
          Jump done = jump();
  
          isInt32.link(this);
          zeroExtend32ToPtr(source, target);
<span class="line-modified">!         or64(GPRInfo::numberTagRegister, target);</span>
  
          done.link(this);
      }
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1342,20 ***</span>
  #endif
  
      void boxBooleanPayload(GPRReg boolGPR, GPRReg payloadGPR)
      {
  #if USE(JSVALUE64)
<span class="line-modified">!         add32(TrustedImm32(ValueFalse), boolGPR, payloadGPR);</span>
  #else
          move(boolGPR, payloadGPR);
  #endif
      }
  
      void boxBooleanPayload(bool value, GPRReg payloadGPR)
      {
  #if USE(JSVALUE64)
<span class="line-modified">!         move(TrustedImm32(ValueFalse + value), payloadGPR);</span>
  #else
          move(TrustedImm32(value), payloadGPR);
  #endif
      }
  
<span class="line-new-header">--- 1366,20 ---</span>
  #endif
  
      void boxBooleanPayload(GPRReg boolGPR, GPRReg payloadGPR)
      {
  #if USE(JSVALUE64)
<span class="line-modified">!         add32(TrustedImm32(JSValue::ValueFalse), boolGPR, payloadGPR);</span>
  #else
          move(boolGPR, payloadGPR);
  #endif
      }
  
      void boxBooleanPayload(bool value, GPRReg payloadGPR)
      {
  #if USE(JSVALUE64)
<span class="line-modified">!         move(TrustedImm32(JSValue::ValueFalse + value), payloadGPR);</span>
  #else
          move(TrustedImm32(value), payloadGPR);
  #endif
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1378,13 ***</span>
      void boxInt32(GPRReg intGPR, JSValueRegs boxedRegs, TagRegistersMode mode = HaveTagRegisters)
      {
  #if USE(JSVALUE64)
          if (mode == DoNotHaveTagRegisters) {
              move(intGPR, boxedRegs.gpr());
<span class="line-modified">!             or64(TrustedImm64(TagTypeNumber), boxedRegs.gpr());</span>
          } else
<span class="line-modified">!             or64(GPRInfo::tagTypeNumberRegister, intGPR, boxedRegs.gpr());</span>
  #else
          UNUSED_PARAM(mode);
          move(intGPR, boxedRegs.payloadGPR());
          move(TrustedImm32(JSValue::Int32Tag), boxedRegs.tagGPR());
  #endif
<span class="line-new-header">--- 1402,13 ---</span>
      void boxInt32(GPRReg intGPR, JSValueRegs boxedRegs, TagRegistersMode mode = HaveTagRegisters)
      {
  #if USE(JSVALUE64)
          if (mode == DoNotHaveTagRegisters) {
              move(intGPR, boxedRegs.gpr());
<span class="line-modified">!             or64(TrustedImm64(JSValue::NumberTag), boxedRegs.gpr());</span>
          } else
<span class="line-modified">!             or64(GPRInfo::numberTagRegister, intGPR, boxedRegs.gpr());</span>
  #else
          UNUSED_PARAM(mode);
          move(intGPR, boxedRegs.payloadGPR());
          move(TrustedImm32(JSValue::Int32Tag), boxedRegs.tagGPR());
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1480,11 ***</span>
  
      static VirtualRegister argumentCount(InlineCallFrame* inlineCallFrame)
      {
          ASSERT(!inlineCallFrame || inlineCallFrame-&gt;isVarargs());
          if (!inlineCallFrame)
<span class="line-modified">!             return VirtualRegister(CallFrameSlot::argumentCount);</span>
          return inlineCallFrame-&gt;argumentCountRegister;
      }
  
      static VirtualRegister argumentCount(const CodeOrigin&amp; codeOrigin)
      {
<span class="line-new-header">--- 1504,11 ---</span>
  
      static VirtualRegister argumentCount(InlineCallFrame* inlineCallFrame)
      {
          ASSERT(!inlineCallFrame || inlineCallFrame-&gt;isVarargs());
          if (!inlineCallFrame)
<span class="line-modified">!             return CallFrameSlot::argumentCountIncludingThis;</span>
          return inlineCallFrame-&gt;argumentCountRegister;
      }
  
      static VirtualRegister argumentCount(const CodeOrigin&amp; codeOrigin)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1586,18 ***</span>
      // length may be the same register as scratch.
      void cageConditionally(Gigacage::Kind kind, GPRReg storage, GPRReg length, GPRReg scratch)
      {
  #if GIGACAGE_ENABLED
          if (Gigacage::isEnabled(kind)) {
<span class="line-modified">!             if (kind != Gigacage::Primitive || Gigacage::isDisablingPrimitiveGigacageDisabled())</span>
                  cageWithoutUntagging(kind, storage);
              else {
  #if CPU(ARM64E)
                  if (length == scratch)
                      scratch = getCachedMemoryTempRegisterIDAndInvalidate();
  #endif
<span class="line-modified">!                 loadPtr(&amp;Gigacage::basePtr(kind), scratch);</span>
                  Jump done = branchTest64(Zero, scratch);
  #if CPU(ARM64E)
                  GPRReg tempReg = getCachedDataTempRegisterIDAndInvalidate();
                  move(storage, tempReg);
                  ASSERT(LogicalImmediate::create64(Gigacage::mask(kind)).isValid());
<span class="line-new-header">--- 1610,18 ---</span>
      // length may be the same register as scratch.
      void cageConditionally(Gigacage::Kind kind, GPRReg storage, GPRReg length, GPRReg scratch)
      {
  #if GIGACAGE_ENABLED
          if (Gigacage::isEnabled(kind)) {
<span class="line-modified">!             if (kind != Gigacage::Primitive || Gigacage::isDisablingPrimitiveGigacageForbidden())</span>
                  cageWithoutUntagging(kind, storage);
              else {
  #if CPU(ARM64E)
                  if (length == scratch)
                      scratch = getCachedMemoryTempRegisterIDAndInvalidate();
  #endif
<span class="line-modified">!                 loadPtr(Gigacage::addressOfBasePtr(kind), scratch);</span>
                  Jump done = branchTest64(Zero, scratch);
  #if CPU(ARM64E)
                  GPRReg tempReg = getCachedDataTempRegisterIDAndInvalidate();
                  move(storage, tempReg);
                  ASSERT(LogicalImmediate::create64(Gigacage::mask(kind)).isValid());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1625,16 ***</span>
  
      void emitComputeButterflyIndexingMask(GPRReg vectorLengthGPR, GPRReg scratchGPR, GPRReg resultGPR)
      {
          ASSERT(scratchGPR != resultGPR);
          Jump done;
<span class="line-removed">-         if (isX86() &amp;&amp; !isX86_64()) {</span>
<span class="line-removed">-             Jump nonZero = branchTest32(NonZero, vectorLengthGPR);</span>
<span class="line-removed">-             move(TrustedImm32(0), resultGPR);</span>
<span class="line-removed">-             done = jump();</span>
<span class="line-removed">-             nonZero.link(this);</span>
<span class="line-removed">-         }</span>
          // If vectorLength == 0 then clz will return 32 on both ARM and x86. On 64-bit systems, we can then do a 64-bit right shift on a 32-bit -1 to get a 0 mask for zero vectorLength. On 32-bit ARM, shift masks with 0xff, which means it will still create a 0 mask.
          countLeadingZeros32(vectorLengthGPR, scratchGPR);
          move(TrustedImm32(-1), resultGPR);
          urshiftPtr(scratchGPR, resultGPR);
          if (done.isSet())
<span class="line-new-header">--- 1649,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1755,11 ***</span>
          notBoolean.link(this);
  
          functor(TypeofType::Undefined, true);
      }
  
<span class="line-modified">!     void emitDumbVirtualCall(VM&amp;, CallLinkInfo*);</span>
  
      void makeSpaceOnStackForCCall();
      void reclaimSpaceOnStackForCCall();
  
  #if USE(JSVALUE64)
<span class="line-new-header">--- 1773,11 ---</span>
          notBoolean.link(this);
  
          functor(TypeofType::Undefined, true);
      }
  
<span class="line-modified">!     void emitDumbVirtualCall(VM&amp;, JSGlobalObject*, CallLinkInfo*);</span>
  
      void makeSpaceOnStackForCCall();
      void reclaimSpaceOnStackForCCall();
  
  #if USE(JSVALUE64)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1867,15 ***</span>
  
  #if USE(JSVALUE64)
      void wangsInt64Hash(GPRReg inputAndResult, GPRReg scratch);
  #endif
  
<span class="line-removed">-     // This assumes that index and length are 32-bit. This also assumes that they are already</span>
<span class="line-removed">-     // zero-extended. Also this does not clobber index, which is useful in the baseline JIT. This</span>
<span class="line-removed">-     // permits length and result to be in the same register.</span>
<span class="line-removed">-     void emitPreparePreciseIndexMask32(GPRReg index, GPRReg length, GPRReg result);</span>
<span class="line-removed">- </span>
  #if ENABLE(WEBASSEMBLY)
      void loadWasmContextInstance(GPRReg dst);
      void storeWasmContextInstance(GPRReg src);
      static bool loadWasmContextInstanceNeedsMacroScratchRegister();
      static bool storeWasmContextInstanceNeedsMacroScratchRegister();
<span class="line-new-header">--- 1885,10 ---</span>
</pre>
<center><a href="AssemblyHelpers.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BinarySwitch.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
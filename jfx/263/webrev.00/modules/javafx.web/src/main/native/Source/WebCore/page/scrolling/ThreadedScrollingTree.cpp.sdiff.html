<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ThreadedScrollingTree.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScrollingTreeScrollingNode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ThreadedScrollingTree.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ThreadedScrollingTree.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 93     decrementPendingCommitCount();
 94 }
 95 
 96 void ThreadedScrollingTree::scrollingTreeNodeDidScroll(ScrollingTreeScrollingNode&amp; node, ScrollingLayerPositionAction scrollingLayerPositionAction)
 97 {
 98     if (!m_scrollingCoordinator)
 99         return;
100 
101     auto scrollPosition = node.currentScrollPosition();
102 
103     if (node.isRootNode())
104         setMainFrameScrollPosition(scrollPosition);
105 
106     if (isHandlingProgrammaticScroll())
107         return;
108 
109     Optional&lt;FloatPoint&gt; layoutViewportOrigin;
110     if (is&lt;ScrollingTreeFrameScrollingNode&gt;(node))
111         layoutViewportOrigin = downcast&lt;ScrollingTreeFrameScrollingNode&gt;(node).layoutViewport().location();
112 
<span class="line-modified">113     RunLoop::main().dispatch([scrollingCoordinator = m_scrollingCoordinator, nodeID = node.scrollingNodeID(), scrollPosition, layoutViewportOrigin, scrollingLayerPositionAction] {</span>






114         scrollingCoordinator-&gt;scheduleUpdateScrollPositionAfterAsyncScroll(nodeID, scrollPosition, layoutViewportOrigin, scrollingLayerPositionAction);






115     });
116 }
117 
118 void ThreadedScrollingTree::reportSynchronousScrollingReasonsChanged(MonotonicTime timestamp, SynchronousScrollingReasons reasons)
119 {
120     RunLoop::main().dispatch([scrollingCoordinator = m_scrollingCoordinator, timestamp, reasons] {
121         scrollingCoordinator-&gt;reportSynchronousScrollingReasonsChanged(timestamp, reasons);
122     });
123 }
124 
125 void ThreadedScrollingTree::reportExposedUnfilledArea(MonotonicTime timestamp, unsigned unfilledArea)
126 {
127     RunLoop::main().dispatch([scrollingCoordinator = m_scrollingCoordinator, timestamp, unfilledArea] {
128         scrollingCoordinator-&gt;reportExposedUnfilledArea(timestamp, unfilledArea);
129     });
130 }
131 
132 void ThreadedScrollingTree::incrementPendingCommitCount()
133 {
134     LockHolder commitLocker(m_pendingCommitCountMutex);
</pre>
<hr />
<pre>
174 void ThreadedScrollingTree::handleWheelEventPhase(PlatformWheelEventPhase phase)
175 {
176     if (!m_scrollingCoordinator)
177         return;
178 
179     RunLoop::main().dispatch([scrollingCoordinator = m_scrollingCoordinator, phase] {
180         scrollingCoordinator-&gt;handleWheelEventPhase(phase);
181     });
182 }
183 
184 void ThreadedScrollingTree::setActiveScrollSnapIndices(ScrollingNodeID nodeID, unsigned horizontalIndex, unsigned verticalIndex)
185 {
186     if (!m_scrollingCoordinator)
187         return;
188 
189     RunLoop::main().dispatch([scrollingCoordinator = m_scrollingCoordinator, nodeID, horizontalIndex, verticalIndex] {
190         scrollingCoordinator-&gt;setActiveScrollSnapIndices(nodeID, horizontalIndex, verticalIndex);
191     });
192 }
193 
<span class="line-modified">194 void ThreadedScrollingTree::deferTestsForReason(WheelEventTestTrigger::ScrollableAreaIdentifier identifier, WheelEventTestTrigger::DeferTestTriggerReason reason)</span>
195 {
196     if (!m_scrollingCoordinator)
197         return;
198 
199     RunLoop::main().dispatch([scrollingCoordinator = m_scrollingCoordinator, identifier, reason] {
<span class="line-modified">200         scrollingCoordinator-&gt;deferTestsForReason(identifier, reason);</span>
201     });
202 }
203 
<span class="line-modified">204 void ThreadedScrollingTree::removeTestDeferralForReason(WheelEventTestTrigger::ScrollableAreaIdentifier identifier, WheelEventTestTrigger::DeferTestTriggerReason reason)</span>
205 {
206     if (!m_scrollingCoordinator)
207         return;
208 
209     RunLoop::main().dispatch([scrollingCoordinator = m_scrollingCoordinator, identifier, reason] {
<span class="line-modified">210         scrollingCoordinator-&gt;removeTestDeferralForReason(identifier, reason);</span>
211     });
212 }
213 
214 #endif
215 
216 } // namespace WebCore
217 
218 #endif // ENABLE(ASYNC_SCROLLING)
</pre>
</td>
<td>
<hr />
<pre>
 93     decrementPendingCommitCount();
 94 }
 95 
 96 void ThreadedScrollingTree::scrollingTreeNodeDidScroll(ScrollingTreeScrollingNode&amp; node, ScrollingLayerPositionAction scrollingLayerPositionAction)
 97 {
 98     if (!m_scrollingCoordinator)
 99         return;
100 
101     auto scrollPosition = node.currentScrollPosition();
102 
103     if (node.isRootNode())
104         setMainFrameScrollPosition(scrollPosition);
105 
106     if (isHandlingProgrammaticScroll())
107         return;
108 
109     Optional&lt;FloatPoint&gt; layoutViewportOrigin;
110     if (is&lt;ScrollingTreeFrameScrollingNode&gt;(node))
111         layoutViewportOrigin = downcast&lt;ScrollingTreeFrameScrollingNode&gt;(node).layoutViewport().location();
112 
<span class="line-modified">113     bool monitoringWheelEvents = false;</span>
<span class="line-added">114 #if PLATFORM(MAC)</span>
<span class="line-added">115     monitoringWheelEvents = isMonitoringWheelEvents();</span>
<span class="line-added">116     if (monitoringWheelEvents)</span>
<span class="line-added">117         deferWheelEventTestCompletionForReason(reinterpret_cast&lt;WheelEventTestMonitor::ScrollableAreaIdentifier&gt;(node.scrollingNodeID()), WheelEventTestMonitor::ScrollingThreadSyncNeeded);</span>
<span class="line-added">118 #endif</span>
<span class="line-added">119     RunLoop::main().dispatch([scrollingCoordinator = m_scrollingCoordinator, nodeID = node.scrollingNodeID(), scrollPosition, layoutViewportOrigin, scrollingLayerPositionAction, monitoringWheelEvents] {</span>
120         scrollingCoordinator-&gt;scheduleUpdateScrollPositionAfterAsyncScroll(nodeID, scrollPosition, layoutViewportOrigin, scrollingLayerPositionAction);
<span class="line-added">121 #if PLATFORM(MAC)</span>
<span class="line-added">122         if (monitoringWheelEvents)</span>
<span class="line-added">123             scrollingCoordinator-&gt;removeWheelEventTestCompletionDeferralForReason(reinterpret_cast&lt;WheelEventTestMonitor::ScrollableAreaIdentifier&gt;(nodeID), WheelEventTestMonitor::ScrollingThreadSyncNeeded);</span>
<span class="line-added">124 #else</span>
<span class="line-added">125         UNUSED_PARAM(monitoringWheelEvents);</span>
<span class="line-added">126 #endif</span>
127     });
128 }
129 
130 void ThreadedScrollingTree::reportSynchronousScrollingReasonsChanged(MonotonicTime timestamp, SynchronousScrollingReasons reasons)
131 {
132     RunLoop::main().dispatch([scrollingCoordinator = m_scrollingCoordinator, timestamp, reasons] {
133         scrollingCoordinator-&gt;reportSynchronousScrollingReasonsChanged(timestamp, reasons);
134     });
135 }
136 
137 void ThreadedScrollingTree::reportExposedUnfilledArea(MonotonicTime timestamp, unsigned unfilledArea)
138 {
139     RunLoop::main().dispatch([scrollingCoordinator = m_scrollingCoordinator, timestamp, unfilledArea] {
140         scrollingCoordinator-&gt;reportExposedUnfilledArea(timestamp, unfilledArea);
141     });
142 }
143 
144 void ThreadedScrollingTree::incrementPendingCommitCount()
145 {
146     LockHolder commitLocker(m_pendingCommitCountMutex);
</pre>
<hr />
<pre>
186 void ThreadedScrollingTree::handleWheelEventPhase(PlatformWheelEventPhase phase)
187 {
188     if (!m_scrollingCoordinator)
189         return;
190 
191     RunLoop::main().dispatch([scrollingCoordinator = m_scrollingCoordinator, phase] {
192         scrollingCoordinator-&gt;handleWheelEventPhase(phase);
193     });
194 }
195 
196 void ThreadedScrollingTree::setActiveScrollSnapIndices(ScrollingNodeID nodeID, unsigned horizontalIndex, unsigned verticalIndex)
197 {
198     if (!m_scrollingCoordinator)
199         return;
200 
201     RunLoop::main().dispatch([scrollingCoordinator = m_scrollingCoordinator, nodeID, horizontalIndex, verticalIndex] {
202         scrollingCoordinator-&gt;setActiveScrollSnapIndices(nodeID, horizontalIndex, verticalIndex);
203     });
204 }
205 
<span class="line-modified">206 void ThreadedScrollingTree::deferWheelEventTestCompletionForReason(WheelEventTestMonitor::ScrollableAreaIdentifier identifier, WheelEventTestMonitor::DeferReason reason)</span>
207 {
208     if (!m_scrollingCoordinator)
209         return;
210 
211     RunLoop::main().dispatch([scrollingCoordinator = m_scrollingCoordinator, identifier, reason] {
<span class="line-modified">212         scrollingCoordinator-&gt;deferWheelEventTestCompletionForReason(identifier, reason);</span>
213     });
214 }
215 
<span class="line-modified">216 void ThreadedScrollingTree::removeWheelEventTestCompletionDeferralForReason(WheelEventTestMonitor::ScrollableAreaIdentifier identifier, WheelEventTestMonitor::DeferReason reason)</span>
217 {
218     if (!m_scrollingCoordinator)
219         return;
220 
221     RunLoop::main().dispatch([scrollingCoordinator = m_scrollingCoordinator, identifier, reason] {
<span class="line-modified">222         scrollingCoordinator-&gt;removeWheelEventTestCompletionDeferralForReason(identifier, reason);</span>
223     });
224 }
225 
226 #endif
227 
228 } // namespace WebCore
229 
230 #endif // ENABLE(ASYNC_SCROLLING)
</pre>
</td>
</tr>
</table>
<center><a href="ScrollingTreeScrollingNode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ThreadedScrollingTree.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
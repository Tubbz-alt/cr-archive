<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTextLineBoxes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2013 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTextLineBoxes.h&quot;
 28 
 29 #include &quot;EllipsisBox.h&quot;
 30 #include &quot;InlineTextBox.h&quot;
 31 #include &quot;RenderBlock.h&quot;
 32 #include &quot;RenderStyle.h&quot;
 33 #include &quot;RenderView.h&quot;
 34 #include &quot;RootInlineBox.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 RenderTextLineBoxes::RenderTextLineBoxes()
 39     : m_first(nullptr)
 40     , m_last(nullptr)
 41 {
 42 }
 43 
 44 InlineTextBox* RenderTextLineBoxes::createAndAppendLineBox(RenderText&amp; renderText)
 45 {
 46     auto textBox = renderText.createTextBox();
 47     if (!m_first) {
 48         m_first = textBox.get();
 49         m_last = textBox.get();
 50     } else {
 51         m_last-&gt;setNextTextBox(textBox.get());
 52         textBox-&gt;setPreviousTextBox(m_last);
 53         m_last = textBox.get();
 54     }
 55     return textBox.release();
 56 }
 57 
 58 void RenderTextLineBoxes::extract(InlineTextBox&amp; box)
 59 {
 60     checkConsistency();
 61 
 62     m_last = box.prevTextBox();
 63     if (&amp;box == m_first)
 64         m_first = nullptr;
 65     if (box.prevTextBox())
 66         box.prevTextBox()-&gt;setNextTextBox(nullptr);
 67     box.setPreviousTextBox(nullptr);
 68     for (auto* current = &amp;box; current; current = current-&gt;nextTextBox())
 69         current-&gt;setExtracted();
 70 
 71     checkConsistency();
 72 }
 73 
 74 void RenderTextLineBoxes::attach(InlineTextBox&amp; box)
 75 {
 76     checkConsistency();
 77 
 78     if (m_last) {
 79         m_last-&gt;setNextTextBox(&amp;box);
 80         box.setPreviousTextBox(m_last);
 81     } else
 82         m_first = &amp;box;
 83     InlineTextBox* last = nullptr;
 84     for (auto* current = &amp;box; current; current = current-&gt;nextTextBox()) {
 85         current-&gt;setExtracted(false);
 86         last = current;
 87     }
 88     m_last = last;
 89 
 90     checkConsistency();
 91 }
 92 
 93 void RenderTextLineBoxes::remove(InlineTextBox&amp; box)
 94 {
 95     checkConsistency();
 96 
 97     if (&amp;box == m_first)
 98         m_first = box.nextTextBox();
 99     if (&amp;box == m_last)
100         m_last = box.prevTextBox();
101     if (box.nextTextBox())
102         box.nextTextBox()-&gt;setPreviousTextBox(box.prevTextBox());
103     if (box.prevTextBox())
104         box.prevTextBox()-&gt;setNextTextBox(box.nextTextBox());
105 
106     checkConsistency();
107 }
108 
109 void RenderTextLineBoxes::removeAllFromParent(RenderText&amp; renderer)
110 {
111     if (!m_first) {
112         if (renderer.parent())
113             renderer.parent()-&gt;dirtyLinesFromChangedChild(renderer);
114         return;
115     }
116     for (auto* box = m_first; box; box = box-&gt;nextTextBox())
117         box-&gt;removeFromParent();
118 }
119 
120 void RenderTextLineBoxes::deleteAll()
121 {
122     if (!m_first)
123         return;
124     InlineTextBox* next;
125     for (auto* current = m_first; current; current = next) {
126         next = current-&gt;nextTextBox();
127         delete current;
128     }
129     m_first = nullptr;
130     m_last = nullptr;
131 }
132 
133 InlineTextBox* RenderTextLineBoxes::findNext(int offset, int&amp; position) const
134 {
135     if (!m_first)
136         return nullptr;
137     // FIXME: This looks buggy. The function is only used for debugging purposes.
138     auto current = m_first;
139     int currentOffset = current-&gt;len();
140     while (offset &gt; currentOffset &amp;&amp; current-&gt;nextTextBox()) {
141         current = current-&gt;nextTextBox();
142         currentOffset = current-&gt;start() + current-&gt;len();
143     }
144     // we are now in the correct text run
145     position = (offset &gt; currentOffset ? current-&gt;len() : current-&gt;len() - (currentOffset - offset));
146     return current;
147 }
148 
<a name="1" id="anc1"></a>






























149 LayoutRect RenderTextLineBoxes::visualOverflowBoundingBox(const RenderText&amp; renderer) const
150 {
151     if (!m_first)
152         return LayoutRect();
153 
154     // Return the width of the minimal left side and the maximal right side.
155     auto logicalLeftSide = LayoutUnit::max();
156     auto logicalRightSide = LayoutUnit::min();
157     for (auto* current = m_first; current; current = current-&gt;nextTextBox()) {
158         logicalLeftSide = std::min(logicalLeftSide, current-&gt;logicalLeftVisualOverflow());
159         logicalRightSide = std::max(logicalRightSide, current-&gt;logicalRightVisualOverflow());
160     }
161 
162     auto logicalTop = m_first-&gt;logicalTopVisualOverflow();
163     auto logicalWidth = logicalRightSide - logicalLeftSide;
164     auto logicalHeight = m_last-&gt;logicalBottomVisualOverflow() - logicalTop;
165 
166     LayoutRect rect(logicalLeftSide, logicalTop, logicalWidth, logicalHeight);
167     if (!renderer.style().isHorizontalWritingMode())
168         rect = rect.transposedRect();
169     return rect;
170 }
171 
<a name="2" id="anc2"></a>
































































172 enum ShouldAffinityBeDownstream { AlwaysDownstream, AlwaysUpstream, UpstreamIfPositionIsNotAtStart };
173 
174 static bool lineDirectionPointFitsInBox(int pointLineDirection, const InlineTextBox&amp; box, ShouldAffinityBeDownstream&amp; shouldAffinityBeDownstream)
175 {
176     shouldAffinityBeDownstream = AlwaysDownstream;
177 
178     // the x coordinate is equal to the left edge of this box
179     // the affinity must be downstream so the position doesn&#39;t jump back to the previous line
180     // except when box is the first box in the line
181     if (pointLineDirection &lt;= box.logicalLeft()) {
<a name="3" id="anc3"></a><span class="line-modified">182         shouldAffinityBeDownstream = !box.previousLeafOnLine() ? UpstreamIfPositionIsNotAtStart : AlwaysDownstream;</span>
183         return true;
184     }
185 
186 #if !PLATFORM(IOS_FAMILY)
187     // and the x coordinate is to the left of the right edge of this box
188     // check to see if position goes in this box
189     if (pointLineDirection &lt; box.logicalRight()) {
190         shouldAffinityBeDownstream = UpstreamIfPositionIsNotAtStart;
191         return true;
192     }
193 #endif
194 
195     // box is first on line
196     // and the x coordinate is to the left of the first text box left edge
<a name="4" id="anc4"></a><span class="line-modified">197     if (!box.previousLeafOnLineIgnoringLineBreak() &amp;&amp; pointLineDirection &lt; box.logicalLeft())</span>
198         return true;
199 
<a name="5" id="anc5"></a><span class="line-modified">200     if (!box.nextLeafOnLineIgnoringLineBreak()) {</span>
201         // box is last on line
202         // and the x coordinate is to the right of the last text box right edge
203         // generate VisiblePosition, use UPSTREAM affinity if possible
204         shouldAffinityBeDownstream = UpstreamIfPositionIsNotAtStart;
205         return true;
206     }
207 
208     return false;
209 }
210 
211 static VisiblePosition createVisiblePositionForBox(const InlineBox&amp; box, int offset, ShouldAffinityBeDownstream shouldAffinityBeDownstream)
212 {
213     EAffinity affinity = VP_DEFAULT_AFFINITY;
214     switch (shouldAffinityBeDownstream) {
215     case AlwaysDownstream:
216         affinity = DOWNSTREAM;
217         break;
218     case AlwaysUpstream:
219         affinity = VP_UPSTREAM_IF_POSSIBLE;
220         break;
221     case UpstreamIfPositionIsNotAtStart:
222         affinity = offset &gt; box.caretMinOffset() ? VP_UPSTREAM_IF_POSSIBLE : DOWNSTREAM;
223         break;
224     }
225     return box.renderer().createVisiblePosition(offset, affinity);
226 }
227 
228 static VisiblePosition createVisiblePositionAfterAdjustingOffsetForBiDi(const InlineTextBox&amp; box, int offset, ShouldAffinityBeDownstream shouldAffinityBeDownstream)
229 {
230     ASSERT(offset &gt;= 0);
231 
232     if (offset &amp;&amp; static_cast&lt;unsigned&gt;(offset) &lt; box.len())
233         return createVisiblePositionForBox(box, box.start() + offset, shouldAffinityBeDownstream);
234 
235     bool positionIsAtStartOfBox = !offset;
236     if (positionIsAtStartOfBox == box.isLeftToRightDirection()) {
237         // offset is on the left edge
238 
<a name="6" id="anc6"></a><span class="line-modified">239         const InlineBox* prevBox = box.previousLeafOnLineIgnoringLineBreak();</span>
240         if ((prevBox &amp;&amp; prevBox-&gt;bidiLevel() == box.bidiLevel())
241             || box.renderer().containingBlock()-&gt;style().direction() == box.direction()) // FIXME: left on 12CBA
242             return createVisiblePositionForBox(box, box.caretLeftmostOffset(), shouldAffinityBeDownstream);
243 
244         if (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; box.bidiLevel()) {
245             // e.g. left of B in aDC12BAb
246             const InlineBox* leftmostBox;
247             do {
248                 leftmostBox = prevBox;
<a name="7" id="anc7"></a><span class="line-modified">249                 prevBox = leftmostBox-&gt;previousLeafOnLineIgnoringLineBreak();</span>
250             } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; box.bidiLevel());
251             return createVisiblePositionForBox(*leftmostBox, leftmostBox-&gt;caretRightmostOffset(), shouldAffinityBeDownstream);
252         }
253 
254         if (!prevBox || prevBox-&gt;bidiLevel() &lt; box.bidiLevel()) {
255             // e.g. left of D in aDC12BAb
256             const InlineBox* rightmostBox;
257             const InlineBox* nextBox = &amp;box;
258             do {
259                 rightmostBox = nextBox;
<a name="8" id="anc8"></a><span class="line-modified">260                 nextBox = rightmostBox-&gt;nextLeafOnLineIgnoringLineBreak();</span>
261             } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt;= box.bidiLevel());
262             return createVisiblePositionForBox(*rightmostBox,
263                 box.isLeftToRightDirection() ? rightmostBox-&gt;caretMaxOffset() : rightmostBox-&gt;caretMinOffset(), shouldAffinityBeDownstream);
264         }
265 
266         return createVisiblePositionForBox(box, box.caretRightmostOffset(), shouldAffinityBeDownstream);
267     }
268 
<a name="9" id="anc9"></a><span class="line-modified">269     const InlineBox* nextBox = box.nextLeafOnLineIgnoringLineBreak();</span>
270     if ((nextBox &amp;&amp; nextBox-&gt;bidiLevel() == box.bidiLevel())
271         || box.renderer().containingBlock()-&gt;style().direction() == box.direction())
272         return createVisiblePositionForBox(box, box.caretRightmostOffset(), shouldAffinityBeDownstream);
273 
274     // offset is on the right edge
275     if (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; box.bidiLevel()) {
276         // e.g. right of C in aDC12BAb
277         const InlineBox* rightmostBox;
278         do {
279             rightmostBox = nextBox;
<a name="10" id="anc10"></a><span class="line-modified">280             nextBox = rightmostBox-&gt;nextLeafOnLineIgnoringLineBreak();</span>
281         } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; box.bidiLevel());
282         return createVisiblePositionForBox(*rightmostBox, rightmostBox-&gt;caretLeftmostOffset(), shouldAffinityBeDownstream);
283     }
284 
285     if (!nextBox || nextBox-&gt;bidiLevel() &lt; box.bidiLevel()) {
286         // e.g. right of A in aDC12BAb
287         const InlineBox* leftmostBox;
288         const InlineBox* prevBox = &amp;box;
289         do {
290             leftmostBox = prevBox;
<a name="11" id="anc11"></a><span class="line-modified">291             prevBox = leftmostBox-&gt;previousLeafOnLineIgnoringLineBreak();</span>
292         } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt;= box.bidiLevel());
293         return createVisiblePositionForBox(*leftmostBox,
294             box.isLeftToRightDirection() ? leftmostBox-&gt;caretMinOffset() : leftmostBox-&gt;caretMaxOffset(), shouldAffinityBeDownstream);
295     }
296 
297     return createVisiblePositionForBox(box, box.caretLeftmostOffset(), shouldAffinityBeDownstream);
298 }
299 
300 VisiblePosition RenderTextLineBoxes::positionForPoint(const RenderText&amp; renderer, const LayoutPoint&amp; point) const
301 {
302     if (!m_first || !renderer.text().length())
303         return renderer.createVisiblePosition(0, DOWNSTREAM);
304 
305     LayoutUnit pointLineDirection = m_first-&gt;isHorizontal() ? point.x() : point.y();
306     LayoutUnit pointBlockDirection = m_first-&gt;isHorizontal() ? point.y() : point.x();
307     bool blocksAreFlipped = renderer.style().isFlippedBlocksWritingMode();
308 
309     InlineTextBox* lastBox = nullptr;
310     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
<a name="12" id="anc12"></a><span class="line-modified">311         if (box-&gt;isLineBreak() &amp;&amp; !box-&gt;previousLeafOnLine() &amp;&amp; box-&gt;nextLeafOnLine() &amp;&amp; !box-&gt;nextLeafOnLine()-&gt;isLineBreak())</span>
312             box = box-&gt;nextTextBox();
313 
314         auto&amp; rootBox = box-&gt;root();
315         LayoutUnit top = std::min(rootBox.selectionTop(), rootBox.lineTop());
316         if (pointBlockDirection &gt; top || (!blocksAreFlipped &amp;&amp; pointBlockDirection == top)) {
317             LayoutUnit bottom = rootBox.selectionBottom();
318             if (rootBox.nextRootBox())
319                 bottom = std::min(bottom, rootBox.nextRootBox()-&gt;lineTop());
320 
321             if (pointBlockDirection &lt; bottom || (blocksAreFlipped &amp;&amp; pointBlockDirection == bottom)) {
322                 ShouldAffinityBeDownstream shouldAffinityBeDownstream;
323 #if PLATFORM(IOS_FAMILY)
324                 if (pointLineDirection != box-&gt;logicalLeft() &amp;&amp; point.x() &lt; box-&gt;x() + box-&gt;logicalWidth()) {
325                     int half = box-&gt;x() + box-&gt;logicalWidth() / 2;
326                     EAffinity affinity = point.x() &lt; half ? DOWNSTREAM : VP_UPSTREAM_IF_POSSIBLE;
327                     return renderer.createVisiblePosition(box-&gt;offsetForPosition(pointLineDirection) + box-&gt;start(), affinity);
328                 }
329 #endif
330                 if (lineDirectionPointFitsInBox(pointLineDirection, *box, shouldAffinityBeDownstream))
331                     return createVisiblePositionAfterAdjustingOffsetForBiDi(*box, box-&gt;offsetForPosition(pointLineDirection), shouldAffinityBeDownstream);
332             }
333         }
334         lastBox = box;
335     }
336 
337     if (lastBox) {
338         ShouldAffinityBeDownstream shouldAffinityBeDownstream;
339         lineDirectionPointFitsInBox(pointLineDirection, *lastBox, shouldAffinityBeDownstream);
340         return createVisiblePositionAfterAdjustingOffsetForBiDi(*lastBox, lastBox-&gt;offsetForPosition(pointLineDirection) + lastBox-&gt;start(), shouldAffinityBeDownstream);
341     }
342     return renderer.createVisiblePosition(0, DOWNSTREAM);
343 }
344 
345 void RenderTextLineBoxes::setSelectionState(RenderText&amp; renderer, RenderObject::SelectionState state)
346 {
347     if (state == RenderObject::SelectionInside || state == RenderObject::SelectionNone) {
348         for (auto* box = m_first; box; box = box-&gt;nextTextBox())
349             box-&gt;root().setHasSelectedChildren(state == RenderObject::SelectionInside);
350         return;
351     }
352 
<a name="13" id="anc13"></a><span class="line-modified">353     auto start = renderer.view().selection().startOffset();</span>
<span class="line-modified">354     auto end = renderer.view().selection().endOffset();</span>
355     if (state == RenderObject::SelectionStart) {
356         end = renderer.text().length();
357         // to handle selection from end of text to end of line
358         if (start &amp;&amp; start == end)
359             start = end - 1;
360     } else if (state == RenderObject::SelectionEnd)
361         start = 0;
362 
363     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
364         if (box-&gt;isSelected(start, end))
365             box-&gt;root().setHasSelectedChildren(true);
366     }
367 }
368 
369 static IntRect ellipsisRectForBox(const InlineTextBox&amp; box, unsigned start, unsigned end)
370 {
371     unsigned short truncation = box.truncation();
372     if (truncation == cNoTruncation)
373         return IntRect();
374 
375     auto ellipsis = box.root().ellipsisBox();
376     if (!ellipsis)
377         return IntRect();
378 
379     IntRect rect;
380     int ellipsisStartPosition = std::max&lt;int&gt;(start - box.start(), 0);
381     int ellipsisEndPosition = std::min&lt;int&gt;(end - box.start(), box.len());
382 
383     // The ellipsis should be considered to be selected if the end of
384     // the selection is past the beginning of the truncation and the
385     // beginning of the selection is before or at the beginning of the truncation.
386     if (ellipsisEndPosition &lt; truncation &amp;&amp; ellipsisStartPosition &gt; truncation)
387         return IntRect();
388     return ellipsis-&gt;selectionRect();
389 }
390 
391 LayoutRect RenderTextLineBoxes::selectionRectForRange(unsigned start, unsigned end)
392 {
393     LayoutRect rect;
394     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
395         rect.unite(box-&gt;localSelectionRect(start, end));
396         rect.unite(ellipsisRectForBox(*box, start, end));
397     }
398     return rect;
399 }
400 
401 void RenderTextLineBoxes::collectSelectionRectsForRange(unsigned start, unsigned end, Vector&lt;LayoutRect&gt;&amp; rects)
402 {
403     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
404         LayoutRect rect;
405         rect.unite(box-&gt;localSelectionRect(start, end));
406         rect.unite(ellipsisRectForBox(*box, start, end));
407         if (!rect.size().isEmpty())
408             rects.append(rect);
409     }
410 }
411 
<a name="14" id="anc14"></a>







412 static FloatRect localQuadForTextBox(const InlineTextBox&amp; box, unsigned start, unsigned end, bool useSelectionHeight)
413 {
<a name="15" id="anc15"></a><span class="line-modified">414     unsigned realEnd = std::min(box.end(), end);</span>
415     LayoutRect boxSelectionRect = box.localSelectionRect(start, realEnd);
416     if (!boxSelectionRect.height())
417         return FloatRect();
418     if (useSelectionHeight)
419         return boxSelectionRect;
420     // Change the height and y position (or width and x for vertical text)
421     // because selectionRect uses selection-specific values.
422     if (box.isHorizontal()) {
423         boxSelectionRect.setHeight(box.height());
424         boxSelectionRect.setY(box.y());
425     } else {
426         boxSelectionRect.setWidth(box.width());
427         boxSelectionRect.setX(box.x());
428     }
429     return boxSelectionRect;
430 }
431 
<a name="16" id="anc16"></a><span class="line-modified">432 Vector&lt;FloatQuad&gt; RenderTextLineBoxes::absoluteQuadsForRange(const RenderText&amp; renderer, unsigned start, unsigned end, bool useSelectionHeight, bool ignoreEmptyTextSelections, bool* wasFixed) const</span>
433 {
<a name="17" id="anc17"></a><span class="line-modified">434     Vector&lt;FloatQuad&gt; quads;</span>
435     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
<a name="18" id="anc18"></a><span class="line-modified">436         if (ignoreEmptyTextSelections &amp;&amp; !box-&gt;isSelected(start, end))</span>
<span class="line-modified">437             continue;</span>
<span class="line-added">438         if (start &lt;= box-&gt;start() &amp;&amp; box-&gt;end() &lt;= end) {</span>
439             FloatRect boundaries = box-&gt;calculateBoundaries();
440             if (useSelectionHeight) {
441                 LayoutRect selectionRect = box-&gt;localSelectionRect(start, end);
442                 if (box-&gt;isHorizontal()) {
443                     boundaries.setHeight(selectionRect.height());
444                     boundaries.setY(selectionRect.y());
445                 } else {
446                     boundaries.setWidth(selectionRect.width());
447                     boundaries.setX(selectionRect.x());
448                 }
449             }
<a name="19" id="anc19"></a><span class="line-modified">450             quads.append(renderer.localToAbsoluteQuad(boundaries, UseTransforms, wasFixed));</span>
451             continue;
452         }
453         FloatRect rect = localQuadForTextBox(*box, start, end, useSelectionHeight);
454         if (!rect.isZero())
<a name="20" id="anc20"></a><span class="line-modified">455             quads.append(renderer.localToAbsoluteQuad(rect, UseTransforms, wasFixed));</span>
456     }
<a name="21" id="anc21"></a><span class="line-modified">457     return quads;</span>
<span class="line-added">458 }</span>
<span class="line-added">459 </span>
<span class="line-added">460 Vector&lt;IntRect&gt; RenderTextLineBoxes::absoluteRectsForRange(const RenderText&amp; renderer, unsigned start, unsigned end, bool useSelectionHeight, bool* wasFixed) const</span>
<span class="line-added">461 {</span>
<span class="line-added">462     return absoluteQuadsForRange(renderer, start, end, useSelectionHeight, false /* ignoreEmptyTextSelections */, wasFixed).map([](auto&amp; quad) { return quad.enclosingBoundingBox(); });</span>
463 }
464 
465 Vector&lt;FloatQuad&gt; RenderTextLineBoxes::absoluteQuads(const RenderText&amp; renderer, bool* wasFixed, ClippingOption option) const
466 {
467     Vector&lt;FloatQuad&gt; quads;
468     for (auto* box = m_first; box; box = box-&gt;nextTextBox()) {
469         FloatRect boundaries = box-&gt;calculateBoundaries();
470 
471         // Shorten the width of this text box if it ends in an ellipsis.
472         // FIXME: ellipsisRectForBox should switch to return FloatRect soon with the subpixellayout branch.
473         IntRect ellipsisRect = (option == ClipToEllipsis) ? ellipsisRectForBox(*box, 0, renderer.text().length()) : IntRect();
474         if (!ellipsisRect.isEmpty()) {
475             if (renderer.style().isHorizontalWritingMode())
476                 boundaries.setWidth(ellipsisRect.maxX() - boundaries.x());
477             else
478                 boundaries.setHeight(ellipsisRect.maxY() - boundaries.y());
479         }
480         quads.append(renderer.localToAbsoluteQuad(boundaries, UseTransforms, wasFixed));
481     }
482     return quads;
483 }
484 
<a name="22" id="anc22"></a>


























485 void RenderTextLineBoxes::dirtyAll()
486 {
487     for (auto* box = m_first; box; box = box-&gt;nextTextBox())
488         box-&gt;dirtyLineBoxes();
489 }
490 
491 bool RenderTextLineBoxes::dirtyRange(RenderText&amp; renderer, unsigned start, unsigned end, int lengthDelta)
492 {
493     RootInlineBox* firstRootBox = nullptr;
494     RootInlineBox* lastRootBox = nullptr;
495 
496     // Dirty all text boxes that include characters in between offset and offset+len.
497     bool dirtiedLines = false;
498     for (auto* current = m_first; current; current = current-&gt;nextTextBox()) {
499         // FIXME: This shouldn&#39;t rely on the end of a dirty line box. See https://bugs.webkit.org/show_bug.cgi?id=97264
500         // Text run is entirely before the affected range.
<a name="23" id="anc23"></a><span class="line-modified">501         if (current-&gt;end() &lt;= start)</span>
502             continue;
503         // Text run is entirely after the affected range.
<a name="24" id="anc24"></a><span class="line-modified">504         if (current-&gt;start() &gt;= end) {</span>
505             current-&gt;offsetRun(lengthDelta);
506             auto&amp; rootBox = current-&gt;root();
507             if (!firstRootBox) {
508                 firstRootBox = &amp;rootBox;
509                 if (!dirtiedLines) {
510                     // The affected area was in between two runs. Mark the root box of the run after the affected area as dirty.
511                     firstRootBox-&gt;markDirty();
512                     dirtiedLines = true;
513                 }
514             }
515             lastRootBox = &amp;rootBox;
516             continue;
517         }
<a name="25" id="anc25"></a><span class="line-modified">518         if (current-&gt;end() &gt; start &amp;&amp; current-&gt;end() &lt;= end) {</span>
519             // Text run overlaps with the left end of the affected range.
520             current-&gt;dirtyLineBoxes();
521             dirtiedLines = true;
522             continue;
523         }
524         if (current-&gt;start() &lt;= start &amp;&amp; current-&gt;end() &gt;= end) {
525             // Text run subsumes the affected range.
526             current-&gt;dirtyLineBoxes();
527             dirtiedLines = true;
528             continue;
529         }
<a name="26" id="anc26"></a><span class="line-modified">530         if (current-&gt;start() &lt; end &amp;&amp; current-&gt;end() &gt;= end) {</span>
531             // Text run overlaps with right end of the affected range.
532             current-&gt;dirtyLineBoxes();
533             dirtiedLines = true;
534             continue;
535         }
536     }
537 
538     // Now we have to walk all of the clean lines and adjust their cached line break information
539     // to reflect our updated offsets.
540     if (lastRootBox)
541         lastRootBox = lastRootBox-&gt;nextRootBox();
542     if (firstRootBox) {
543         auto previousRootBox = firstRootBox-&gt;prevRootBox();
544         if (previousRootBox)
545             firstRootBox = previousRootBox;
546     } else if (m_last) {
547         ASSERT(!lastRootBox);
548         firstRootBox = &amp;m_last-&gt;root();
549         firstRootBox-&gt;markDirty();
550         dirtiedLines = true;
551     }
552     for (auto* current = firstRootBox; current &amp;&amp; current != lastRootBox; current = current-&gt;nextRootBox()) {
553         if (current-&gt;lineBreakObj() == &amp;renderer &amp;&amp; current-&gt;lineBreakPos() &gt; end)
554             current-&gt;setLineBreakPos(current-&gt;lineBreakPos() + lengthDelta);
555     }
556 
557     // If the text node is empty, dirty the line where new text will be inserted.
558     if (!m_first &amp;&amp; renderer.parent()) {
559         renderer.parent()-&gt;dirtyLinesFromChangedChild(renderer);
560         dirtiedLines = true;
561     }
562     return dirtiedLines;
563 }
564 
565 inline void RenderTextLineBoxes::checkConsistency() const
566 {
<a name="27" id="anc27"></a><span class="line-modified">567 #if ASSERT_ENABLED</span>
568 #ifdef CHECK_CONSISTENCY
569     const InlineTextBox* prev = nullptr;
570     for (auto* child = m_first; child; child = child-&gt;nextTextBox()) {
571         ASSERT(child-&gt;renderer() == this);
572         ASSERT(child-&gt;prevTextBox() == prev);
573         prev = child;
574     }
575     ASSERT(prev == m_last);
576 #endif
<a name="28" id="anc28"></a><span class="line-modified">577 #endif // ASSERT_ENABLED</span>
578 }
579 
<a name="29" id="anc29"></a><span class="line-modified">580 #if ASSERT_ENABLED</span>
581 RenderTextLineBoxes::~RenderTextLineBoxes()
582 {
583     ASSERT(!m_first);
584     ASSERT(!m_last);
585 }
586 #endif
587 
588 #if !ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
589 void RenderTextLineBoxes::invalidateParentChildLists()
590 {
591     for (auto* box = m_first; box; box = box-&gt;nextTextBox())
592         box-&gt;invalidateParentChildList();
593 }
594 #endif
595 
596 }
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>
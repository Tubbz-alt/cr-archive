<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2005 Allan Sandfeld Jensen (kde@carewolf.com)
   5  *           (C) 2005, 2006 Samuel Weinig (sam.weinig@gmail.com)
   6  * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2013, 2015 Apple Inc. All rights reserved.
   7  * Copyright (C) 2010, 2012 Google Inc. All rights reserved.
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public License
  20  * along with this library; see the file COPYING.LIB.  If not, write to
  21  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;RenderElement.h&quot;
  27 
  28 #include &quot;AXObjectCache.h&quot;
  29 #if PLATFORM(IOS_FAMILY)
  30 #include &quot;ContentChangeObserver.h&quot;
  31 #endif
  32 #include &quot;ContentData.h&quot;
  33 #include &quot;CursorList.h&quot;
  34 #include &quot;ElementChildIterator.h&quot;
  35 #include &quot;EventHandler.h&quot;
  36 #include &quot;FocusController.h&quot;
  37 #include &quot;Frame.h&quot;
  38 #include &quot;FrameSelection.h&quot;
  39 #include &quot;HTMLAnchorElement.h&quot;
  40 #include &quot;HTMLBodyElement.h&quot;
  41 #include &quot;HTMLHtmlElement.h&quot;
  42 #include &quot;HTMLImageElement.h&quot;
  43 #include &quot;HTMLNames.h&quot;
  44 #include &quot;LengthFunctions.h&quot;
  45 #include &quot;Logging.h&quot;
  46 #include &quot;Page.h&quot;
  47 #include &quot;PathUtilities.h&quot;
  48 #include &quot;RenderBlock.h&quot;
  49 #include &quot;RenderChildIterator.h&quot;
  50 #include &quot;RenderCounter.h&quot;
  51 #include &quot;RenderDeprecatedFlexibleBox.h&quot;
  52 #include &quot;RenderDescendantIterator.h&quot;
  53 #include &quot;RenderFlexibleBox.h&quot;
  54 #include &quot;RenderFragmentedFlow.h&quot;
  55 #include &quot;RenderGrid.h&quot;
  56 #include &quot;RenderImage.h&quot;
  57 #include &quot;RenderImageResourceStyleImage.h&quot;
  58 #include &quot;RenderInline.h&quot;
  59 #include &quot;RenderIterator.h&quot;
  60 #include &quot;RenderLayer.h&quot;
  61 #include &quot;RenderLayerCompositor.h&quot;
  62 #include &quot;RenderLineBreak.h&quot;
  63 #include &quot;RenderListItem.h&quot;
<a name="1" id="anc1"></a><span class="line-modified">  64 #if ASSERT_ENABLED</span>
  65 #include &quot;RenderListMarker.h&quot;
  66 #endif
  67 #include &quot;RenderFragmentContainer.h&quot;
  68 #include &quot;RenderTableCaption.h&quot;
  69 #include &quot;RenderTableCell.h&quot;
  70 #include &quot;RenderTableCol.h&quot;
  71 #include &quot;RenderTableRow.h&quot;
  72 #include &quot;RenderText.h&quot;
  73 #include &quot;RenderTheme.h&quot;
  74 #include &quot;RenderTreeBuilder.h&quot;
  75 #include &quot;RenderView.h&quot;
  76 #include &quot;SVGImage.h&quot;
  77 #include &quot;SVGRenderSupport.h&quot;
  78 #include &quot;Settings.h&quot;
  79 #include &quot;ShadowRoot.h&quot;
  80 #include &quot;StylePendingResources.h&quot;
  81 #include &quot;StyleResolver.h&quot;
  82 #include &quot;TextAutoSizing.h&quot;
  83 #include &lt;wtf/IsoMallocInlines.h&gt;
  84 #include &lt;wtf/MathExtras.h&gt;
  85 #include &lt;wtf/StackStats.h&gt;
  86 
  87 namespace WebCore {
  88 
  89 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderElement);
  90 
  91 struct SameSizeAsRenderElement : public RenderObject {
  92     unsigned bitfields : 25;
  93     void* firstChild;
  94     void* lastChild;
  95     RenderStyle style;
  96 };
  97 
  98 static_assert(sizeof(RenderElement) == sizeof(SameSizeAsRenderElement), &quot;RenderElement should stay small&quot;);
  99 
 100 inline RenderElement::RenderElement(ContainerNode&amp; elementOrDocument, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 101     : RenderObject(elementOrDocument)
 102     , m_baseTypeFlags(baseTypeFlags)
 103     , m_ancestorLineBoxDirty(false)
 104     , m_hasInitializedStyle(false)
 105     , m_renderInlineAlwaysCreatesLineBoxes(false)
 106     , m_renderBoxNeedsLazyRepaint(false)
 107     , m_hasPausedImageAnimations(false)
 108     , m_hasCounterNodeMap(false)
 109     , m_hasContinuationChainNode(false)
 110     , m_isContinuation(false)
 111     , m_isFirstLetter(false)
 112     , m_hasValidCachedFirstLineStyle(false)
 113     , m_renderBlockHasMarginBeforeQuirk(false)
 114     , m_renderBlockHasMarginAfterQuirk(false)
 115     , m_renderBlockShouldForceRelayoutChildren(false)
 116     , m_renderBlockFlowHasMarkupTruncation(false)
 117     , m_renderBlockFlowLineLayoutPath(RenderBlockFlow::UndeterminedPath)
 118     , m_isRegisteredForVisibleInViewportCallback(false)
 119     , m_visibleInViewportState(static_cast&lt;unsigned&gt;(VisibleInViewportState::Unknown))
 120     , m_firstChild(nullptr)
 121     , m_lastChild(nullptr)
 122     , m_style(WTFMove(style))
 123 {
 124 }
 125 
 126 RenderElement::RenderElement(Element&amp; element, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 127     : RenderElement(static_cast&lt;ContainerNode&amp;&gt;(element), WTFMove(style), baseTypeFlags)
 128 {
 129 }
 130 
 131 RenderElement::RenderElement(Document&amp; document, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 132     : RenderElement(static_cast&lt;ContainerNode&amp;&gt;(document), WTFMove(style), baseTypeFlags)
 133 {
 134 }
 135 
 136 RenderElement::~RenderElement()
 137 {
 138     // Do not add any code here. Add it to willBeDestroyed() instead.
 139     ASSERT(!m_firstChild);
 140 }
 141 
 142 RenderPtr&lt;RenderElement&gt; RenderElement::createFor(Element&amp; element, RenderStyle&amp;&amp; style, RendererCreationType creationType)
 143 {
 144     // Minimal support for content properties replacing an entire element.
 145     // Works only if we have exactly one piece of content and it&#39;s a URL.
 146     // Otherwise acts as if we didn&#39;t support this feature.
 147     const ContentData* contentData = style.contentData();
 148     if (creationType == CreateAllRenderers &amp;&amp; contentData &amp;&amp; !contentData-&gt;next() &amp;&amp; is&lt;ImageContentData&gt;(*contentData) &amp;&amp; !element.isPseudoElement()) {
 149         Style::loadPendingResources(style, element.document(), &amp;element);
 150         auto&amp; styleImage = downcast&lt;ImageContentData&gt;(*contentData).image();
 151         auto image = createRenderer&lt;RenderImage&gt;(element, WTFMove(style), const_cast&lt;StyleImage*&gt;(&amp;styleImage));
 152         image-&gt;setIsGeneratedContent();
 153         return image;
 154     }
 155 
 156     switch (style.display()) {
 157     case DisplayType::None:
 158     case DisplayType::Contents:
 159         return nullptr;
 160     case DisplayType::Inline:
 161         if (creationType == CreateAllRenderers)
 162             return createRenderer&lt;RenderInline&gt;(element, WTFMove(style));
 163         FALLTHROUGH; // Fieldsets should make a block flow if display:inline is set.
 164     case DisplayType::Block:
 165     case DisplayType::FlowRoot:
 166     case DisplayType::InlineBlock:
<a name="2" id="anc2"></a>
 167         return createRenderer&lt;RenderBlockFlow&gt;(element, WTFMove(style));
 168     case DisplayType::ListItem:
 169         return createRenderer&lt;RenderListItem&gt;(element, WTFMove(style));
 170     case DisplayType::Flex:
 171     case DisplayType::InlineFlex:
 172     case DisplayType::WebKitFlex:
 173     case DisplayType::WebKitInlineFlex:
 174         return createRenderer&lt;RenderFlexibleBox&gt;(element, WTFMove(style));
 175     case DisplayType::Grid:
 176     case DisplayType::InlineGrid:
 177         return createRenderer&lt;RenderGrid&gt;(element, WTFMove(style));
 178     case DisplayType::Box:
 179     case DisplayType::InlineBox:
 180         return createRenderer&lt;RenderDeprecatedFlexibleBox&gt;(element, WTFMove(style));
 181     default: {
 182         if (creationType == OnlyCreateBlockAndFlexboxRenderers)
 183             return createRenderer&lt;RenderBlockFlow&gt;(element, WTFMove(style));
 184         switch (style.display()) {
 185         case DisplayType::Table:
 186         case DisplayType::InlineTable:
 187             return createRenderer&lt;RenderTable&gt;(element, WTFMove(style));
 188         case DisplayType::TableCell:
 189             return createRenderer&lt;RenderTableCell&gt;(element, WTFMove(style));
 190         case DisplayType::TableCaption:
 191             return createRenderer&lt;RenderTableCaption&gt;(element, WTFMove(style));
 192         case DisplayType::TableRowGroup:
 193         case DisplayType::TableHeaderGroup:
 194         case DisplayType::TableFooterGroup:
 195             return createRenderer&lt;RenderTableSection&gt;(element, WTFMove(style));
 196         case DisplayType::TableRow:
 197             return createRenderer&lt;RenderTableRow&gt;(element, WTFMove(style));
 198         case DisplayType::TableColumnGroup:
 199         case DisplayType::TableColumn:
 200             return createRenderer&lt;RenderTableCol&gt;(element, WTFMove(style));
 201         default:
 202             break;
 203         }
 204         break;
 205     }
 206     }
 207     ASSERT_NOT_REACHED();
 208     return nullptr;
 209 }
 210 
 211 std::unique_ptr&lt;RenderStyle&gt; RenderElement::computeFirstLineStyle() const
 212 {
 213     ASSERT(view().usesFirstLineRules());
 214 
 215     RenderElement&amp; rendererForFirstLineStyle = isBeforeOrAfterContent() ? *parent() : const_cast&lt;RenderElement&amp;&gt;(*this);
 216 
 217     if (rendererForFirstLineStyle.isRenderBlockFlow() || rendererForFirstLineStyle.isRenderButton()) {
 218         RenderBlock* firstLineBlock = rendererForFirstLineStyle.firstLineBlock();
 219         if (!firstLineBlock)
 220             return nullptr;
 221         auto* firstLineStyle = firstLineBlock-&gt;getCachedPseudoStyle(PseudoId::FirstLine, &amp;style());
 222         if (!firstLineStyle)
 223             return nullptr;
 224         return RenderStyle::clonePtr(*firstLineStyle);
 225     }
 226 
 227     if (!rendererForFirstLineStyle.isRenderInline())
 228         return nullptr;
 229 
 230     auto&amp; parentStyle = rendererForFirstLineStyle.parent()-&gt;firstLineStyle();
 231     if (&amp;parentStyle == &amp;rendererForFirstLineStyle.parent()-&gt;style())
 232         return nullptr;
 233 
 234     if (rendererForFirstLineStyle.isAnonymous()) {
 235         auto* textRendererWithDisplayContentsParent = RenderText::findByDisplayContentsInlineWrapperCandidate(rendererForFirstLineStyle);
 236         if (!textRendererWithDisplayContentsParent)
 237             return nullptr;
 238         auto* composedTreeParentElement = textRendererWithDisplayContentsParent-&gt;textNode()-&gt;parentElementInComposedTree();
 239         if (!composedTreeParentElement)
 240             return nullptr;
 241 
 242         auto style = composedTreeParentElement-&gt;styleResolver().styleForElement(*composedTreeParentElement, &amp;parentStyle).renderStyle;
 243         ASSERT(style-&gt;display() == DisplayType::Contents);
 244 
 245         // We act as if there was an unstyled &lt;span&gt; around the text node. Only styling happens via inheritance.
 246         auto firstLineStyle = RenderStyle::createPtr();
 247         firstLineStyle-&gt;inheritFrom(*style);
 248         return firstLineStyle;
 249     }
 250 
 251     return rendererForFirstLineStyle.element()-&gt;styleResolver().styleForElement(*element(), &amp;parentStyle).renderStyle;
 252 }
 253 
 254 const RenderStyle&amp; RenderElement::firstLineStyle() const
 255 {
 256     if (!view().usesFirstLineRules())
 257         return style();
 258 
 259     if (!m_hasValidCachedFirstLineStyle) {
 260         auto firstLineStyle = computeFirstLineStyle();
 261         if (firstLineStyle || hasRareData())
 262             const_cast&lt;RenderElement&amp;&gt;(*this).ensureRareData().cachedFirstLineStyle = WTFMove(firstLineStyle);
 263         m_hasValidCachedFirstLineStyle = true;
 264     }
 265 
 266     return (hasRareData() &amp;&amp; rareData().cachedFirstLineStyle) ? *rareData().cachedFirstLineStyle : style();
 267 }
 268 
 269 StyleDifference RenderElement::adjustStyleDifference(StyleDifference diff, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt; contextSensitiveProperties) const
 270 {
 271     // If transform changed, and we are not composited, need to do a layout.
 272     if (contextSensitiveProperties &amp; StyleDifferenceContextSensitiveProperty::Transform) {
 273         // FIXME: when transforms are taken into account for overflow, we will need to do a layout.
 274         if (!hasLayer() || !downcast&lt;RenderLayerModelObject&gt;(*this).layer()-&gt;isComposited()) {
 275             if (!hasLayer())
 276                 diff = std::max(diff, StyleDifference::Layout);
 277             else {
 278                 // We need to set at least SimplifiedLayout, but if PositionedMovementOnly is already set
 279                 // then we actually need SimplifiedLayoutAndPositionedMovement.
 280                 diff = std::max(diff, (diff == StyleDifference::LayoutPositionedMovementOnly) ? StyleDifference::SimplifiedLayoutAndPositionedMovement : StyleDifference::SimplifiedLayout);
 281             }
 282 
 283         } else
 284             diff = std::max(diff, StyleDifference::RecompositeLayer);
 285     }
 286 
 287     if (contextSensitiveProperties &amp; StyleDifferenceContextSensitiveProperty::Opacity) {
 288         if (!hasLayer() || !downcast&lt;RenderLayerModelObject&gt;(*this).layer()-&gt;isComposited())
 289             diff = std::max(diff, StyleDifference::RepaintLayer);
 290         else
 291             diff = std::max(diff, StyleDifference::RecompositeLayer);
 292     }
 293 
 294     if (contextSensitiveProperties &amp; StyleDifferenceContextSensitiveProperty::ClipPath) {
 295         if (hasLayer()
 296             &amp;&amp; downcast&lt;RenderLayerModelObject&gt;(*this).layer()-&gt;isComposited()
 297             &amp;&amp; hasClipPath()
 298             &amp;&amp; RenderLayerCompositor::canCompositeClipPath(*downcast&lt;RenderLayerModelObject&gt;(*this).layer()))
 299             diff = std::max(diff, StyleDifference::RecompositeLayer);
 300         else
 301             diff = std::max(diff, StyleDifference::Repaint);
 302     }
 303 
 304     if (contextSensitiveProperties &amp; StyleDifferenceContextSensitiveProperty::WillChange) {
 305         if (style().willChange() &amp;&amp; style().willChange()-&gt;canTriggerCompositing())
 306             diff = std::max(diff, StyleDifference::RecompositeLayer);
 307     }
 308 
 309     if ((contextSensitiveProperties &amp; StyleDifferenceContextSensitiveProperty::Filter) &amp;&amp; hasLayer()) {
 310         auto&amp; layer = *downcast&lt;RenderLayerModelObject&gt;(*this).layer();
 311         if (!layer.isComposited() || layer.paintsWithFilters())
 312             diff = std::max(diff, StyleDifference::RepaintLayer);
 313         else
 314             diff = std::max(diff, StyleDifference::RecompositeLayer);
 315     }
 316 
 317     // The answer to requiresLayer() for plugins, iframes, and canvas can change without the actual
 318     // style changing, since it depends on whether we decide to composite these elements. When the
 319     // layer status of one of these elements changes, we need to force a layout.
 320     if (diff &lt; StyleDifference::Layout &amp;&amp; isRenderLayerModelObject()) {
 321         if (hasLayer() != downcast&lt;RenderLayerModelObject&gt;(*this).requiresLayer())
 322             diff = StyleDifference::Layout;
 323     }
 324 
 325     // If we have no layer(), just treat a RepaintLayer hint as a normal Repaint.
 326     if (diff == StyleDifference::RepaintLayer &amp;&amp; !hasLayer())
 327         diff = StyleDifference::Repaint;
 328 
 329     return diff;
 330 }
 331 
 332 inline bool RenderElement::hasImmediateNonWhitespaceTextChildOrBorderOrOutline() const
 333 {
 334     for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(*this)) {
 335         if (is&lt;RenderText&gt;(child) &amp;&amp; !downcast&lt;RenderText&gt;(child).isAllCollapsibleWhitespace())
 336             return true;
 337         if (child.style().hasOutline() || child.style().hasBorder())
 338             return true;
 339     }
 340     return false;
 341 }
 342 
 343 inline bool RenderElement::shouldRepaintForStyleDifference(StyleDifference diff) const
 344 {
 345     return diff == StyleDifference::Repaint || (diff == StyleDifference::RepaintIfTextOrBorderOrOutline &amp;&amp; hasImmediateNonWhitespaceTextChildOrBorderOrOutline());
 346 }
 347 
 348 void RenderElement::updateFillImages(const FillLayer* oldLayers, const FillLayer&amp; newLayers)
 349 {
 350     // Optimize the common case.
 351     if (FillLayer::imagesIdentical(oldLayers, &amp;newLayers))
 352         return;
 353 
 354     // Add before removing, to avoid removing all clients of an image that is in both sets.
 355     for (auto* layer = &amp;newLayers; layer; layer = layer-&gt;next()) {
 356         if (layer-&gt;image())
 357             layer-&gt;image()-&gt;addClient(this);
 358     }
 359     for (auto* layer = oldLayers; layer; layer = layer-&gt;next()) {
 360         if (layer-&gt;image())
 361             layer-&gt;image()-&gt;removeClient(this);
 362     }
 363 }
 364 
 365 void RenderElement::updateImage(StyleImage* oldImage, StyleImage* newImage)
 366 {
 367     if (oldImage == newImage)
 368         return;
 369     if (oldImage)
 370         oldImage-&gt;removeClient(this);
 371     if (newImage)
 372         newImage-&gt;addClient(this);
 373 }
 374 
 375 void RenderElement::updateShapeImage(const ShapeValue* oldShapeValue, const ShapeValue* newShapeValue)
 376 {
 377     if (oldShapeValue || newShapeValue)
 378         updateImage(oldShapeValue ? oldShapeValue-&gt;image() : nullptr, newShapeValue ? newShapeValue-&gt;image() : nullptr);
 379 }
 380 
 381 void RenderElement::initializeStyle()
 382 {
 383     Style::loadPendingResources(m_style, document(), element());
 384 
 385     styleWillChange(StyleDifference::NewStyle, style());
 386     m_hasInitializedStyle = true;
 387     styleDidChange(StyleDifference::NewStyle, nullptr);
 388 
 389     // We shouldn&#39;t have any text children that would need styleDidChange at this point.
 390     ASSERT(!childrenOfType&lt;RenderText&gt;(*this).first());
 391 
 392     // It would be nice to assert that !parent() here, but some RenderLayer subrenderers
 393     // have their parent set before getting a call to initializeStyle() :|
 394 }
 395 
 396 void RenderElement::setStyle(RenderStyle&amp;&amp; style, StyleDifference minimalStyleDifference)
 397 {
 398     // FIXME: Should change RenderView so it can use initializeStyle too.
 399     // If we do that, we can assert m_hasInitializedStyle unconditionally,
 400     // and remove the check of m_hasInitializedStyle below too.
 401     ASSERT(m_hasInitializedStyle || isRenderView());
 402 
 403     StyleDifference diff = StyleDifference::Equal;
 404     OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt; contextSensitiveProperties;
 405     if (m_hasInitializedStyle)
 406         diff = m_style.diff(style, contextSensitiveProperties);
 407 
 408     diff = std::max(diff, minimalStyleDifference);
 409 
 410     diff = adjustStyleDifference(diff, contextSensitiveProperties);
 411 
 412     Style::loadPendingResources(style, document(), element());
 413 
 414     styleWillChange(diff, style);
 415     auto oldStyle = m_style.replace(WTFMove(style));
 416     bool detachedFromParent = !parent();
 417 
 418     // Make sure we invalidate the containing block cache for flows when the contianing block context changes
 419     // so that styleDidChange can safely use RenderBlock::locateEnclosingFragmentedFlow()
 420     if (oldStyle.position() != m_style.position())
 421         adjustFragmentedFlowStateOnContainingBlockChangeIfNeeded();
 422 
 423     styleDidChange(diff, &amp;oldStyle);
 424 
 425     // Text renderers use their parent style. Notify them about the change.
 426     for (auto&amp; child : childrenOfType&lt;RenderText&gt;(*this))
 427         child.styleDidChange(diff, &amp;oldStyle);
 428 
 429     // FIXME: |this| might be destroyed here. This can currently happen for a RenderTextFragment when
 430     // its first-letter block gets an update in RenderTextFragment::styleDidChange. For RenderTextFragment(s),
 431     // we will safely bail out with the detachedFromParent flag. We might want to broaden this condition
 432     // in the future as we move renderer changes out of layout and into style changes.
 433     if (detachedFromParent)
 434         return;
 435 
 436     // Now that the layer (if any) has been updated, we need to adjust the diff again,
 437     // check whether we should layout now, and decide if we need to repaint.
 438     StyleDifference updatedDiff = adjustStyleDifference(diff, contextSensitiveProperties);
 439 
 440     if (diff &lt;= StyleDifference::LayoutPositionedMovementOnly) {
 441         if (updatedDiff == StyleDifference::Layout)
 442             setNeedsLayoutAndPrefWidthsRecalc();
 443         else if (updatedDiff == StyleDifference::LayoutPositionedMovementOnly)
 444             setNeedsPositionedMovementLayout(&amp;oldStyle);
 445         else if (updatedDiff == StyleDifference::SimplifiedLayoutAndPositionedMovement) {
 446             setNeedsPositionedMovementLayout(&amp;oldStyle);
 447             setNeedsSimplifiedNormalFlowLayout();
 448         } else if (updatedDiff == StyleDifference::SimplifiedLayout)
 449             setNeedsSimplifiedNormalFlowLayout();
 450     }
 451 
 452     if (updatedDiff == StyleDifference::RepaintLayer || shouldRepaintForStyleDifference(updatedDiff)) {
 453         // Do a repaint with the new style now, e.g., for example if we go from
 454         // not having an outline to having an outline.
 455         repaint();
 456     }
 457 }
 458 
 459 void RenderElement::didAttachChild(RenderObject&amp; child, RenderObject*)
 460 {
 461     if (is&lt;RenderText&gt;(child))
 462         downcast&lt;RenderText&gt;(child).styleDidChange(StyleDifference::Equal, nullptr);
 463     // SVG creates renderers for &lt;g display=&quot;none&quot;&gt;, as SVG requires children of hidden
 464     // &lt;g&gt;s to have renderers - at least that&#39;s how our implementation works. Consider:
 465     // &lt;g display=&quot;none&quot;&gt;&lt;foreignObject&gt;&lt;body style=&quot;position: relative&quot;&gt;FOO...
 466     // - requiresLayer() would return true for the &lt;body&gt;, creating a new RenderLayer
 467     // - when the document is painted, both layers are painted. The &lt;body&gt; layer doesn&#39;t
 468     //   know that it&#39;s inside a &quot;hidden SVG subtree&quot;, and thus paints, even if it shouldn&#39;t.
 469     // To avoid the problem alltogether, detect early if we&#39;re inside a hidden SVG subtree
 470     // and stop creating layers at all for these cases - they&#39;re not used anyways.
 471     if (child.hasLayer() &amp;&amp; !layerCreationAllowedForSubtree())
<a name="3" id="anc3"></a><span class="line-modified"> 472         downcast&lt;RenderLayerModelObject&gt;(child).layer()-&gt;removeOnlyThisLayer(RenderLayer::LayerChangeTiming::RenderTreeConstruction);</span>
 473 }
 474 
 475 RenderObject* RenderElement::attachRendererInternal(RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
 476 {
 477     child-&gt;setParent(this);
 478 
 479     if (m_firstChild == beforeChild)
 480         m_firstChild = child.get();
 481 
 482     if (beforeChild) {
 483         auto* previousSibling = beforeChild-&gt;previousSibling();
 484         if (previousSibling)
 485             previousSibling-&gt;setNextSibling(child.get());
 486         child-&gt;setPreviousSibling(previousSibling);
 487         child-&gt;setNextSibling(beforeChild);
 488         beforeChild-&gt;setPreviousSibling(child.get());
 489         return child.release();
 490     }
 491     if (m_lastChild)
 492         m_lastChild-&gt;setNextSibling(child.get());
 493     child-&gt;setPreviousSibling(m_lastChild);
 494     m_lastChild = child.get();
 495     return child.release();
 496 }
 497 
 498 RenderPtr&lt;RenderObject&gt; RenderElement::detachRendererInternal(RenderObject&amp; renderer)
 499 {
 500     auto* parent = renderer.parent();
 501     ASSERT(parent);
 502     auto* nextSibling = renderer.nextSibling();
 503 
 504     if (renderer.previousSibling())
 505         renderer.previousSibling()-&gt;setNextSibling(nextSibling);
 506     if (nextSibling)
 507         nextSibling-&gt;setPreviousSibling(renderer.previousSibling());
 508 
 509     if (parent-&gt;firstChild() == &amp;renderer)
 510         parent-&gt;m_firstChild = nextSibling;
 511     if (parent-&gt;lastChild() == &amp;renderer)
 512         parent-&gt;m_lastChild = renderer.previousSibling();
 513 
 514     renderer.setPreviousSibling(nullptr);
 515     renderer.setNextSibling(nullptr);
 516     renderer.setParent(nullptr);
 517     return RenderPtr&lt;RenderObject&gt;(&amp;renderer);
 518 }
 519 
 520 RenderBlock* RenderElement::containingBlockForFixedPosition() const
 521 {
 522     auto* renderer = parent();
 523     while (renderer &amp;&amp; !renderer-&gt;canContainFixedPositionObjects())
 524         renderer = renderer-&gt;parent();
 525 
 526     ASSERT(!renderer || !renderer-&gt;isAnonymousBlock());
 527     return downcast&lt;RenderBlock&gt;(renderer);
 528 }
 529 
 530 RenderBlock* RenderElement::containingBlockForAbsolutePosition() const
 531 {
 532     // A relatively positioned RenderInline forwards its absolute positioned descendants to
 533     // its nearest non-anonymous containing block (to avoid having a positioned objects list in all RenderInlines).
 534     auto* renderer = isRenderInline() ? const_cast&lt;RenderElement*&gt;(downcast&lt;RenderElement&gt;(this)) : parent();
 535     while (renderer &amp;&amp; !renderer-&gt;canContainAbsolutelyPositionedObjects())
 536         renderer = renderer-&gt;parent();
 537     // Make sure we only return non-anonymous RenderBlock as containing block.
 538     while (renderer &amp;&amp; (!is&lt;RenderBlock&gt;(*renderer) || renderer-&gt;isAnonymousBlock()))
 539         renderer = renderer-&gt;containingBlock();
 540     return downcast&lt;RenderBlock&gt;(renderer);
 541 }
 542 
 543 static void addLayers(RenderElement&amp; renderer, RenderLayer* parentLayer, RenderElement*&amp; newObject, RenderLayer*&amp; beforeChild)
 544 {
 545     if (renderer.hasLayer()) {
 546         if (!beforeChild &amp;&amp; newObject) {
 547             // We need to figure out the layer that follows newObject. We only do
 548             // this the first time we find a child layer, and then we update the
 549             // pointer values for newObject and beforeChild used by everyone else.
 550             beforeChild = newObject-&gt;parent()-&gt;findNextLayer(parentLayer, newObject);
 551             newObject = nullptr;
 552         }
 553         parentLayer-&gt;addChild(*downcast&lt;RenderLayerModelObject&gt;(renderer).layer(), beforeChild);
 554         return;
 555     }
 556 
 557     for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(renderer))
 558         addLayers(child, parentLayer, newObject, beforeChild);
 559 }
 560 
 561 void RenderElement::addLayers(RenderLayer* parentLayer)
 562 {
 563     if (!parentLayer)
 564         return;
 565 
 566     RenderElement* renderer = this;
 567     RenderLayer* beforeChild = nullptr;
 568     WebCore::addLayers(*this, parentLayer, renderer, beforeChild);
 569 }
 570 
 571 void RenderElement::removeLayers(RenderLayer* parentLayer)
 572 {
 573     if (!parentLayer)
 574         return;
 575 
 576     if (hasLayer()) {
 577         parentLayer-&gt;removeChild(*downcast&lt;RenderLayerModelObject&gt;(*this).layer());
 578         return;
 579     }
 580 
 581     for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(*this))
 582         child.removeLayers(parentLayer);
 583 }
 584 
 585 void RenderElement::moveLayers(RenderLayer* oldParent, RenderLayer* newParent)
 586 {
 587     if (!newParent)
 588         return;
 589 
 590     if (hasLayer()) {
 591         RenderLayer* layer = downcast&lt;RenderLayerModelObject&gt;(*this).layer();
 592         ASSERT(oldParent == layer-&gt;parent());
 593         if (oldParent)
 594             oldParent-&gt;removeChild(*layer);
 595         newParent-&gt;addChild(*layer);
 596         return;
 597     }
 598 
 599     for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(*this))
 600         child.moveLayers(oldParent, newParent);
 601 }
 602 
 603 RenderLayer* RenderElement::findNextLayer(RenderLayer* parentLayer, RenderObject* startPoint, bool checkParent)
 604 {
 605     // Error check the parent layer passed in. If it&#39;s null, we can&#39;t find anything.
 606     if (!parentLayer)
 607         return nullptr;
 608 
 609     // Step 1: If our layer is a child of the desired parent, then return our layer.
 610     RenderLayer* ourLayer = hasLayer() ? downcast&lt;RenderLayerModelObject&gt;(*this).layer() : nullptr;
 611     if (ourLayer &amp;&amp; ourLayer-&gt;parent() == parentLayer)
 612         return ourLayer;
 613 
 614     // Step 2: If we don&#39;t have a layer, or our layer is the desired parent, then descend
 615     // into our siblings trying to find the next layer whose parent is the desired parent.
 616     if (!ourLayer || ourLayer == parentLayer) {
 617         for (RenderObject* child = startPoint ? startPoint-&gt;nextSibling() : firstChild(); child; child = child-&gt;nextSibling()) {
 618             if (!is&lt;RenderElement&gt;(*child))
 619                 continue;
 620             RenderLayer* nextLayer = downcast&lt;RenderElement&gt;(*child).findNextLayer(parentLayer, nullptr, false);
 621             if (nextLayer)
 622                 return nextLayer;
 623         }
 624     }
 625 
 626     // Step 3: If our layer is the desired parent layer, then we&#39;re finished. We didn&#39;t
 627     // find anything.
 628     if (parentLayer == ourLayer)
 629         return nullptr;
 630 
 631     // Step 4: If |checkParent| is set, climb up to our parent and check its siblings that
 632     // follow us to see if we can locate a layer.
 633     if (checkParent &amp;&amp; parent())
 634         return parent()-&gt;findNextLayer(parentLayer, this, true);
 635 
 636     return nullptr;
 637 }
 638 
 639 bool RenderElement::layerCreationAllowedForSubtree() const
 640 {
 641     RenderElement* parentRenderer = parent();
 642     while (parentRenderer) {
 643         if (parentRenderer-&gt;isSVGHiddenContainer())
 644             return false;
 645         parentRenderer = parentRenderer-&gt;parent();
 646     }
 647 
 648     return true;
 649 }
 650 
 651 void RenderElement::propagateStyleToAnonymousChildren(StylePropagationType propagationType)
 652 {
 653     // FIXME: We could save this call when the change only affected non-inherited properties.
 654     for (auto&amp; elementChild : childrenOfType&lt;RenderElement&gt;(*this)) {
 655         if (!elementChild.isAnonymous() || elementChild.style().styleType() != PseudoId::None)
 656             continue;
 657 
 658         if (propagationType == PropagateToBlockChildrenOnly &amp;&amp; !is&lt;RenderBlock&gt;(elementChild))
 659             continue;
 660 
 661 #if ENABLE(FULLSCREEN_API)
 662         if (elementChild.isRenderFullScreen() || elementChild.isRenderFullScreenPlaceholder())
 663             continue;
 664 #endif
 665 
 666         // RenderFragmentedFlows are updated through the RenderView::styleDidChange function.
 667         if (is&lt;RenderFragmentedFlow&gt;(elementChild))
 668             continue;
 669 
 670         auto newStyle = RenderStyle::createAnonymousStyleWithDisplay(style(), elementChild.style().display());
 671         if (style().specifiesColumns()) {
 672             if (elementChild.style().specifiesColumns())
 673                 newStyle.inheritColumnPropertiesFrom(style());
 674             if (elementChild.style().columnSpan() == ColumnSpan::All)
 675                 newStyle.setColumnSpan(ColumnSpan::All);
 676         }
 677 
 678         // Preserve the position style of anonymous block continuations as they can have relative or sticky position when
 679         // they contain block descendants of relative or sticky positioned inlines.
 680         if (elementChild.isInFlowPositioned() &amp;&amp; elementChild.isContinuation())
 681             newStyle.setPosition(elementChild.style().position());
 682 
 683         updateAnonymousChildStyle(newStyle);
 684 
 685         elementChild.setStyle(WTFMove(newStyle));
 686     }
 687 }
 688 
 689 static inline bool rendererHasBackground(const RenderElement* renderer)
 690 {
 691     return renderer &amp;&amp; renderer-&gt;hasBackground();
 692 }
 693 
 694 void RenderElement::invalidateCachedFirstLineStyle()
 695 {
 696     if (!m_hasValidCachedFirstLineStyle)
 697         return;
 698     m_hasValidCachedFirstLineStyle = false;
 699     // Invalidate the subtree as descendant&#39;s first line style may depend on ancestor&#39;s.
 700     for (auto&amp; descendant : descendantsOfType&lt;RenderElement&gt;(*this))
 701         descendant.m_hasValidCachedFirstLineStyle = false;
 702 }
 703 
 704 void RenderElement::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
 705 {
 706     ASSERT(settings().shouldAllowUserInstalledFonts() || newStyle.fontDescription().shouldAllowUserInstalledFonts() == AllowUserInstalledFonts::No);
 707 
 708     auto* oldStyle = hasInitializedStyle() ? &amp;style() : nullptr;
 709     if (oldStyle) {
 710         // If our z-index changes value or our visibility changes,
 711         // we need to dirty our stacking context&#39;s z-order list.
 712         bool visibilityChanged = m_style.visibility() != newStyle.visibility()
<a name="4" id="anc4"></a><span class="line-modified"> 713             || m_style.usedZIndex() != newStyle.usedZIndex()</span>
<span class="line-modified"> 714             || m_style.hasAutoUsedZIndex() != newStyle.hasAutoUsedZIndex();</span>
 715 
 716         if (visibilityChanged)
 717             document().invalidateRenderingDependentRegions();
 718 
 719         if (visibilityChanged) {
 720             if (AXObjectCache* cache = document().existingAXObjectCache())
 721                 cache-&gt;childrenChanged(parent(), this);
 722         }
 723 
 724         // Keep layer hierarchy visibility bits up to date if visibility changes.
 725         if (m_style.visibility() != newStyle.visibility()) {
 726             if (RenderLayer* layer = enclosingLayer()) {
 727                 if (newStyle.visibility() == Visibility::Visible)
 728                     layer-&gt;setHasVisibleContent();
 729                 else if (layer-&gt;hasVisibleContent() &amp;&amp; (this == &amp;layer-&gt;renderer() || layer-&gt;renderer().style().visibility() != Visibility::Visible)) {
 730                     layer-&gt;dirtyVisibleContentStatus();
 731                     if (diff &gt; StyleDifference::RepaintLayer)
 732                         repaint();
 733                 }
 734             }
 735         }
 736 
 737         auto needsInvalidateEventRegion = [&amp;] {
 738             if (m_style.pointerEvents() != newStyle.pointerEvents())
 739                 return true;
 740 #if ENABLE(POINTER_EVENTS)
 741             if (m_style.effectiveTouchActions() != newStyle.effectiveTouchActions())
 742                 return true;
 743 #endif
 744             return false;
 745         };
 746 
 747         if (needsInvalidateEventRegion()) {
 748             // Usually the event region gets updated as a result of paint invalidation. Here we need to request an update explicitly.
 749             if (auto* layer = enclosingLayer())
 750                 layer-&gt;invalidateEventRegion();
 751         }
 752 
 753         if (m_parent &amp;&amp; (newStyle.outlineSize() &lt; m_style.outlineSize() || shouldRepaintForStyleDifference(diff)))
 754             repaint();
 755 
 756         if (isFloating() &amp;&amp; m_style.floating() != newStyle.floating()) {
 757             // For changes in float styles, we need to conceivably remove ourselves
 758             // from the floating objects list.
 759             downcast&lt;RenderBox&gt;(*this).removeFloatingOrPositionedChildFromBlockLists();
 760         } else if (isOutOfFlowPositioned() &amp;&amp; m_style.position() != newStyle.position()) {
 761             // For changes in positioning styles, we need to conceivably remove ourselves
 762             // from the positioned objects list.
 763             downcast&lt;RenderBox&gt;(*this).removeFloatingOrPositionedChildFromBlockLists();
 764         }
 765 
 766         // reset style flags
 767         if (diff == StyleDifference::Layout || diff == StyleDifference::LayoutPositionedMovementOnly) {
 768             setFloating(false);
 769             clearPositionedState();
 770         }
 771 
 772         if (newStyle.hasPseudoStyle(PseudoId::FirstLine) || oldStyle-&gt;hasPseudoStyle(PseudoId::FirstLine))
 773             invalidateCachedFirstLineStyle();
 774 
 775         setHorizontalWritingMode(true);
 776         setHasVisibleBoxDecorations(false);
 777         setHasOverflowClip(false);
 778         setHasTransformRelatedProperty(false);
 779         setHasReflection(false);
 780     }
 781 
 782     bool hadOutline = oldStyle &amp;&amp; oldStyle-&gt;hasOutline();
 783     bool hasOutline = newStyle.hasOutline();
 784     if (hadOutline != hasOutline) {
 785         if (hasOutline)
 786             view().incrementRendersWithOutline();
 787         else
 788             view().decrementRendersWithOutline();
 789     }
 790 
 791     bool newStyleSlowScroll = false;
 792     if (newStyle.hasFixedBackgroundImage() &amp;&amp; !settings().fixedBackgroundsPaintRelativeToDocument()) {
 793         newStyleSlowScroll = true;
 794         bool drawsRootBackground = isDocumentElementRenderer() || (isBody() &amp;&amp; !rendererHasBackground(document().documentElement()-&gt;renderer()));
 795         if (drawsRootBackground &amp;&amp; newStyle.hasEntirelyFixedBackground() &amp;&amp; view().compositor().supportsFixedRootBackgroundCompositing())
 796             newStyleSlowScroll = false;
 797     }
 798 
 799     if (view().frameView().hasSlowRepaintObject(*this)) {
 800         if (!newStyleSlowScroll)
 801             view().frameView().removeSlowRepaintObject(*this);
 802     } else if (newStyleSlowScroll)
 803         view().frameView().addSlowRepaintObject(*this);
 804 
 805     if (isDocumentElementRenderer() || isBody())
 806         view().frameView().updateExtendBackgroundIfNecessary();
 807 }
 808 
 809 #if !PLATFORM(IOS_FAMILY)
 810 static bool areNonIdenticalCursorListsEqual(const RenderStyle* a, const RenderStyle* b)
 811 {
 812     ASSERT(a-&gt;cursors() != b-&gt;cursors());
 813     return a-&gt;cursors() &amp;&amp; b-&gt;cursors() &amp;&amp; *a-&gt;cursors() == *b-&gt;cursors();
 814 }
 815 
 816 static inline bool areCursorsEqual(const RenderStyle* a, const RenderStyle* b)
 817 {
 818     return a-&gt;cursor() == b-&gt;cursor() &amp;&amp; (a-&gt;cursors() == b-&gt;cursors() || areNonIdenticalCursorListsEqual(a, b));
 819 }
 820 #endif
 821 
 822 void RenderElement::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
 823 {
 824     updateFillImages(oldStyle ? &amp;oldStyle-&gt;backgroundLayers() : nullptr, m_style.backgroundLayers());
 825     updateFillImages(oldStyle ? &amp;oldStyle-&gt;maskLayers() : nullptr, m_style.maskLayers());
 826     updateImage(oldStyle ? oldStyle-&gt;borderImage().image() : nullptr, m_style.borderImage().image());
 827     updateImage(oldStyle ? oldStyle-&gt;maskBoxImage().image() : nullptr, m_style.maskBoxImage().image());
 828     updateShapeImage(oldStyle ? oldStyle-&gt;shapeOutside() : nullptr, m_style.shapeOutside());
 829 
 830     SVGRenderSupport::styleChanged(*this, oldStyle);
 831 
 832     if (!m_parent)
 833         return;
 834 
 835     if (diff == StyleDifference::Layout || diff == StyleDifference::SimplifiedLayout) {
 836         RenderCounter::rendererStyleChanged(*this, oldStyle, &amp;m_style);
 837 
 838         // If the object already needs layout, then setNeedsLayout won&#39;t do
 839         // any work. But if the containing block has changed, then we may need
 840         // to mark the new containing blocks for layout. The change that can
 841         // directly affect the containing block of this object is a change to
 842         // the position style.
 843         if (needsLayout() &amp;&amp; oldStyle-&gt;position() != m_style.position())
 844             markContainingBlocksForLayout();
 845 
 846         if (diff == StyleDifference::Layout)
 847             setNeedsLayoutAndPrefWidthsRecalc();
 848         else
 849             setNeedsSimplifiedNormalFlowLayout();
 850     } else if (diff == StyleDifference::SimplifiedLayoutAndPositionedMovement) {
 851         setNeedsPositionedMovementLayout(oldStyle);
 852         setNeedsSimplifiedNormalFlowLayout();
 853     } else if (diff == StyleDifference::LayoutPositionedMovementOnly)
 854         setNeedsPositionedMovementLayout(oldStyle);
 855 
 856     // Don&#39;t check for repaint here; we need to wait until the layer has been
 857     // updated by subclasses before we know if we have to repaint (in setStyle()).
 858 
 859 #if !PLATFORM(IOS_FAMILY)
 860     if (oldStyle &amp;&amp; !areCursorsEqual(oldStyle, &amp;style()))
 861         frame().eventHandler().scheduleCursorUpdate();
 862 #endif
 863 
 864     bool hadOutlineAuto = oldStyle &amp;&amp; oldStyle-&gt;outlineStyleIsAuto() == OutlineIsAuto::On;
 865     bool hasOutlineAuto = outlineStyleForRepaint().outlineStyleIsAuto() == OutlineIsAuto::On;
 866     if (hasOutlineAuto != hadOutlineAuto) {
 867         updateOutlineAutoAncestor(hasOutlineAuto);
 868         issueRepaintForOutlineAuto(hasOutlineAuto ? outlineStyleForRepaint().outlineSize() : oldStyle-&gt;outlineSize());
 869     }
 870 }
 871 
 872 void RenderElement::insertedIntoTree()
 873 {
 874     // Keep our layer hierarchy updated. Optimize for the common case where we don&#39;t have any children
 875     // and don&#39;t have a layer attached to ourselves.
 876     RenderLayer* layer = nullptr;
 877     if (firstChild() || hasLayer()) {
 878         layer = parent()-&gt;enclosingLayer();
 879         addLayers(layer);
 880     }
 881 
 882     // If |this| is visible but this object was not, tell the layer it has some visible content
 883     // that needs to be drawn and layer visibility optimization can&#39;t be used
 884     if (parent()-&gt;style().visibility() != Visibility::Visible &amp;&amp; style().visibility() == Visibility::Visible &amp;&amp; !hasLayer()) {
 885         if (!layer)
 886             layer = parent()-&gt;enclosingLayer();
 887         if (layer)
<a name="5" id="anc5"></a><span class="line-modified"> 888             layer-&gt;dirtyVisibleContentStatus();</span>
 889     }
 890 
 891     RenderObject::insertedIntoTree();
 892 }
 893 
 894 void RenderElement::willBeRemovedFromTree()
 895 {
 896     // If we remove a visible child from an invisible parent, we don&#39;t know the layer visibility any more.
 897     RenderLayer* layer = nullptr;
 898     if (parent()-&gt;style().visibility() != Visibility::Visible &amp;&amp; style().visibility() == Visibility::Visible &amp;&amp; !hasLayer()) {
 899         if ((layer = parent()-&gt;enclosingLayer()))
 900             layer-&gt;dirtyVisibleContentStatus();
 901     }
 902     // Keep our layer hierarchy updated.
 903     if (firstChild() || hasLayer()) {
 904         if (!layer)
 905             layer = parent()-&gt;enclosingLayer();
 906         removeLayers(layer);
 907     }
 908 
 909     if (isOutOfFlowPositioned() &amp;&amp; parent()-&gt;childrenInline())
 910         parent()-&gt;dirtyLinesFromChangedChild(*this);
 911 
 912     RenderObject::willBeRemovedFromTree();
 913 }
 914 
 915 inline void RenderElement::clearSubtreeLayoutRootIfNeeded() const
 916 {
 917     if (renderTreeBeingDestroyed())
 918         return;
 919 
 920     if (view().frameView().layoutContext().subtreeLayoutRoot() != this)
 921         return;
 922 
 923     // Normally when a renderer is detached from the tree, the appropriate dirty bits get set
 924     // which ensures that this renderer is no longer the layout root.
 925     ASSERT_NOT_REACHED();
 926 
 927     // This indicates a failure to layout the child, which is why
 928     // the layout root is still set to |this|. Make sure to clear it
 929     // since we are getting destroyed.
 930     view().frameView().layoutContext().clearSubtreeLayoutRoot();
 931 }
 932 
 933 void RenderElement::willBeDestroyed()
 934 {
 935 #if PLATFORM(IOS_FAMILY)
 936     if (!renderTreeBeingDestroyed() &amp;&amp; element())
 937         document().contentChangeObserver().rendererWillBeDestroyed(*element());
 938 #endif
 939     if (m_style.hasFixedBackgroundImage() &amp;&amp; !settings().fixedBackgroundsPaintRelativeToDocument())
 940         view().frameView().removeSlowRepaintObject(*this);
 941 
 942     unregisterForVisibleInViewportCallback();
 943 
 944     if (hasCounterNodeMap())
 945         RenderCounter::destroyCounterNodes(*this);
 946 
 947     if (style().hasOutline())
 948         view().decrementRendersWithOutline();
 949 
 950     RenderObject::willBeDestroyed();
 951 
 952     clearSubtreeLayoutRootIfNeeded();
 953 
 954     if (hasInitializedStyle()) {
 955         for (auto* bgLayer = &amp;m_style.backgroundLayers(); bgLayer; bgLayer = bgLayer-&gt;next()) {
 956             if (auto* backgroundImage = bgLayer-&gt;image())
 957                 backgroundImage-&gt;removeClient(this);
 958         }
 959         for (auto* maskLayer = &amp;m_style.maskLayers(); maskLayer; maskLayer = maskLayer-&gt;next()) {
 960             if (auto* maskImage = maskLayer-&gt;image())
 961                 maskImage-&gt;removeClient(this);
 962         }
 963         if (auto* borderImage = m_style.borderImage().image())
 964             borderImage-&gt;removeClient(this);
 965         if (auto* maskBoxImage = m_style.maskBoxImage().image())
 966             maskBoxImage-&gt;removeClient(this);
 967         if (auto shapeValue = m_style.shapeOutside()) {
 968             if (auto shapeImage = shapeValue-&gt;image())
 969                 shapeImage-&gt;removeClient(this);
 970         }
 971     }
 972     if (m_hasPausedImageAnimations)
 973         view().removeRendererWithPausedImageAnimations(*this);
 974 }
 975 
 976 void RenderElement::setNeedsPositionedMovementLayout(const RenderStyle* oldStyle)
 977 {
 978     ASSERT(!isSetNeedsLayoutForbidden());
 979     if (needsPositionedMovementLayout())
 980         return;
 981     setNeedsPositionedMovementLayoutBit(true);
 982     markContainingBlocksForLayout();
 983     if (hasLayer()) {
 984         if (oldStyle &amp;&amp; style().diffRequiresLayerRepaint(*oldStyle, downcast&lt;RenderLayerModelObject&gt;(*this).layer()-&gt;isComposited()))
 985             setLayerNeedsFullRepaint();
 986         else
 987             setLayerNeedsFullRepaintForPositionedMovementLayout();
 988     }
 989 }
 990 
 991 void RenderElement::clearChildNeedsLayout()
 992 {
 993     setNormalChildNeedsLayoutBit(false);
 994     setPosChildNeedsLayoutBit(false);
 995     setNeedsSimplifiedNormalFlowLayoutBit(false);
 996     setNormalChildNeedsLayoutBit(false);
 997     setNeedsPositionedMovementLayoutBit(false);
 998 }
 999 
1000 void RenderElement::setNeedsSimplifiedNormalFlowLayout()
1001 {
1002     ASSERT(!isSetNeedsLayoutForbidden());
1003     if (needsSimplifiedNormalFlowLayout())
1004         return;
1005     setNeedsSimplifiedNormalFlowLayoutBit(true);
1006     markContainingBlocksForLayout();
1007     if (hasLayer())
1008         setLayerNeedsFullRepaint();
1009 }
1010 
1011 static inline void paintPhase(RenderElement&amp; element, PaintPhase phase, PaintInfo&amp; paintInfo, const LayoutPoint&amp; childPoint)
1012 {
1013     paintInfo.phase = phase;
1014     element.paint(paintInfo, childPoint);
1015 }
1016 
1017 void RenderElement::paintAsInlineBlock(PaintInfo&amp; paintInfo, const LayoutPoint&amp; childPoint)
1018 {
1019     // Paint all phases atomically, as though the element established its own stacking context.
1020     // (See Appendix E.2, section 6.4 on inline block/table/replaced elements in the CSS2.1 specification.)
1021     // This is also used by other elements (e.g. flex items and grid items).
1022     PaintPhase paintPhaseToUse = isExcludedAndPlacedInBorder() ? paintInfo.phase : PaintPhase::Foreground;
1023     if (paintInfo.phase == PaintPhase::Selection || paintInfo.phase == PaintPhase::EventRegion)
1024         paint(paintInfo, childPoint);
1025     else if (paintInfo.phase == paintPhaseToUse) {
1026         paintPhase(*this, PaintPhase::BlockBackground, paintInfo, childPoint);
1027         paintPhase(*this, PaintPhase::ChildBlockBackgrounds, paintInfo, childPoint);
1028         paintPhase(*this, PaintPhase::Float, paintInfo, childPoint);
1029         paintPhase(*this, PaintPhase::Foreground, paintInfo, childPoint);
1030         paintPhase(*this, PaintPhase::Outline, paintInfo, childPoint);
1031 
1032         // Reset |paintInfo| to the original phase.
1033         paintInfo.phase = paintPhaseToUse;
1034     }
1035 }
1036 
1037 void RenderElement::layout()
1038 {
1039     StackStats::LayoutCheckPoint layoutCheckPoint;
1040     ASSERT(needsLayout());
1041     for (auto* child = firstChild(); child; child = child-&gt;nextSibling()) {
1042         if (child-&gt;needsLayout())
1043             downcast&lt;RenderElement&gt;(*child).layout();
1044         ASSERT(!child-&gt;needsLayout());
1045     }
1046     clearNeedsLayout();
1047 }
1048 
1049 static bool mustRepaintFillLayers(const RenderElement&amp; renderer, const FillLayer&amp; layer)
1050 {
1051     // Nobody will use multiple layers without wanting fancy positioning.
1052     if (layer.next())
1053         return true;
1054 
1055     // Make sure we have a valid image.
1056     auto* image = layer.image();
1057     if (!image || !image-&gt;canRender(&amp;renderer, renderer.style().effectiveZoom()))
1058         return false;
1059 
1060     if (!layer.xPosition().isZero() || !layer.yPosition().isZero())
1061         return true;
1062 
1063     auto sizeType = layer.sizeType();
1064 
1065     if (sizeType == FillSizeType::Contain || sizeType == FillSizeType::Cover)
1066         return true;
1067 
1068     if (sizeType == FillSizeType::Size) {
1069         auto size = layer.sizeLength();
1070         if (size.width.isPercentOrCalculated() || size.height.isPercentOrCalculated())
1071             return true;
1072         // If the image has neither an intrinsic width nor an intrinsic height, its size is determined as for &#39;contain&#39;.
1073         if ((size.width.isAuto() || size.height.isAuto()) &amp;&amp; image-&gt;isGeneratedImage())
1074             return true;
1075     } else if (image-&gt;usesImageContainerSize())
1076         return true;
1077 
1078     return false;
1079 }
1080 
1081 static bool mustRepaintBackgroundOrBorder(const RenderElement&amp; renderer)
1082 {
1083     if (renderer.hasMask() &amp;&amp; mustRepaintFillLayers(renderer, renderer.style().maskLayers()))
1084         return true;
1085 
1086     // If we don&#39;t have a background/border/mask, then nothing to do.
1087     if (!renderer.hasVisibleBoxDecorations())
1088         return false;
1089 
1090     if (mustRepaintFillLayers(renderer, renderer.style().backgroundLayers()))
1091         return true;
1092 
1093     // Our fill layers are ok. Let&#39;s check border.
1094     if (renderer.style().hasBorder() &amp;&amp; renderer.borderImageIsLoadedAndCanBeRendered())
1095         return true;
1096 
1097     return false;
1098 }
1099 
1100 bool RenderElement::repaintAfterLayoutIfNeeded(const RenderLayerModelObject* repaintContainer, const LayoutRect&amp; oldBounds, const LayoutRect&amp; oldOutlineBox, const LayoutRect* newBoundsPtr, const LayoutRect* newOutlineBoxRectPtr)
1101 {
1102     if (view().printing())
1103         return false; // Don&#39;t repaint if we&#39;re printing.
1104 
1105     // This ASSERT fails due to animations. See https://bugs.webkit.org/show_bug.cgi?id=37048
1106     // ASSERT(!newBoundsPtr || *newBoundsPtr == clippedOverflowRectForRepaint(repaintContainer));
1107     LayoutRect newBounds = newBoundsPtr ? *newBoundsPtr : clippedOverflowRectForRepaint(repaintContainer);
1108     LayoutRect newOutlineBox;
1109 
1110     bool fullRepaint = selfNeedsLayout();
1111     // Presumably a background or a border exists if border-fit:lines was specified.
1112     if (!fullRepaint &amp;&amp; style().borderFit() == BorderFit::Lines)
1113         fullRepaint = true;
1114     if (!fullRepaint) {
1115         // This ASSERT fails due to animations. See https://bugs.webkit.org/show_bug.cgi?id=37048
1116         // ASSERT(!newOutlineBoxRectPtr || *newOutlineBoxRectPtr == outlineBoundsForRepaint(repaintContainer));
1117         newOutlineBox = newOutlineBoxRectPtr ? *newOutlineBoxRectPtr : outlineBoundsForRepaint(repaintContainer);
1118         fullRepaint = (newOutlineBox.location() != oldOutlineBox.location() || (mustRepaintBackgroundOrBorder(*this) &amp;&amp; (newBounds != oldBounds || newOutlineBox != oldOutlineBox)));
1119     }
1120 
1121     if (!repaintContainer)
1122         repaintContainer = &amp;view();
1123 
1124     if (fullRepaint) {
1125         repaintUsingContainer(repaintContainer, oldBounds);
1126         if (newBounds != oldBounds)
1127             repaintUsingContainer(repaintContainer, newBounds);
1128         return true;
1129     }
1130 
1131     if (newBounds == oldBounds &amp;&amp; newOutlineBox == oldOutlineBox)
1132         return false;
1133 
1134     LayoutUnit deltaLeft = newBounds.x() - oldBounds.x();
1135     if (deltaLeft &gt; 0)
1136         repaintUsingContainer(repaintContainer, LayoutRect(oldBounds.x(), oldBounds.y(), deltaLeft, oldBounds.height()));
1137     else if (deltaLeft &lt; 0)
1138         repaintUsingContainer(repaintContainer, LayoutRect(newBounds.x(), newBounds.y(), -deltaLeft, newBounds.height()));
1139 
1140     LayoutUnit deltaRight = newBounds.maxX() - oldBounds.maxX();
1141     if (deltaRight &gt; 0)
1142         repaintUsingContainer(repaintContainer, LayoutRect(oldBounds.maxX(), newBounds.y(), deltaRight, newBounds.height()));
1143     else if (deltaRight &lt; 0)
1144         repaintUsingContainer(repaintContainer, LayoutRect(newBounds.maxX(), oldBounds.y(), -deltaRight, oldBounds.height()));
1145 
1146     LayoutUnit deltaTop = newBounds.y() - oldBounds.y();
1147     if (deltaTop &gt; 0)
1148         repaintUsingContainer(repaintContainer, LayoutRect(oldBounds.x(), oldBounds.y(), oldBounds.width(), deltaTop));
1149     else if (deltaTop &lt; 0)
1150         repaintUsingContainer(repaintContainer, LayoutRect(newBounds.x(), newBounds.y(), newBounds.width(), -deltaTop));
1151 
1152     LayoutUnit deltaBottom = newBounds.maxY() - oldBounds.maxY();
1153     if (deltaBottom &gt; 0)
1154         repaintUsingContainer(repaintContainer, LayoutRect(newBounds.x(), oldBounds.maxY(), newBounds.width(), deltaBottom));
1155     else if (deltaBottom &lt; 0)
1156         repaintUsingContainer(repaintContainer, LayoutRect(oldBounds.x(), newBounds.maxY(), oldBounds.width(), -deltaBottom));
1157 
1158     if (newOutlineBox == oldOutlineBox)
1159         return false;
1160 
1161     // We didn&#39;t move, but we did change size. Invalidate the delta, which will consist of possibly
1162     // two rectangles (but typically only one).
1163     const RenderStyle&amp; outlineStyle = outlineStyleForRepaint();
1164     LayoutUnit outlineWidth { outlineStyle.outlineSize() };
1165     LayoutBoxExtent insetShadowExtent = style().getBoxShadowInsetExtent();
1166     LayoutUnit width = absoluteValue(newOutlineBox.width() - oldOutlineBox.width());
1167     if (width) {
1168         LayoutUnit shadowLeft;
1169         LayoutUnit shadowRight;
1170         style().getBoxShadowHorizontalExtent(shadowLeft, shadowRight);
1171         LayoutUnit borderRight = is&lt;RenderBox&gt;(*this) ? downcast&lt;RenderBox&gt;(*this).borderRight() : 0_lu;
1172         LayoutUnit boxWidth = is&lt;RenderBox&gt;(*this) ? downcast&lt;RenderBox&gt;(*this).width() : 0_lu;
1173         LayoutUnit minInsetRightShadowExtent = std::min&lt;LayoutUnit&gt;(-insetShadowExtent.right(), std::min(newBounds.width(), oldBounds.width()));
1174         LayoutUnit borderWidth = std::max(borderRight, std::max(valueForLength(style().borderTopRightRadius().width, boxWidth), valueForLength(style().borderBottomRightRadius().width, boxWidth)));
1175         LayoutUnit decorationsWidth = std::max(LayoutUnit(-outlineStyle.outlineOffset()), borderWidth + minInsetRightShadowExtent) + std::max(outlineWidth, shadowRight);
1176         LayoutRect rightRect(newOutlineBox.x() + std::min(newOutlineBox.width(), oldOutlineBox.width()) - decorationsWidth,
1177             newOutlineBox.y(),
1178             width + decorationsWidth,
1179             std::max(newOutlineBox.height(), oldOutlineBox.height()));
1180         LayoutUnit right = std::min(newBounds.maxX(), oldBounds.maxX());
1181         if (rightRect.x() &lt; right) {
1182             rightRect.setWidth(std::min(rightRect.width(), right - rightRect.x()));
1183             repaintUsingContainer(repaintContainer, rightRect);
1184         }
1185     }
1186     LayoutUnit height = absoluteValue(newOutlineBox.height() - oldOutlineBox.height());
1187     if (height) {
1188         LayoutUnit shadowTop;
1189         LayoutUnit shadowBottom;
1190         style().getBoxShadowVerticalExtent(shadowTop, shadowBottom);
1191         LayoutUnit borderBottom = is&lt;RenderBox&gt;(*this) ? downcast&lt;RenderBox&gt;(*this).borderBottom() : 0_lu;
1192         LayoutUnit boxHeight = is&lt;RenderBox&gt;(*this) ? downcast&lt;RenderBox&gt;(*this).height() : 0_lu;
1193         LayoutUnit minInsetBottomShadowExtent = std::min&lt;LayoutUnit&gt;(-insetShadowExtent.bottom(), std::min(newBounds.height(), oldBounds.height()));
1194         LayoutUnit borderHeight = std::max(borderBottom, std::max(valueForLength(style().borderBottomLeftRadius().height, boxHeight),
1195             valueForLength(style().borderBottomRightRadius().height, boxHeight)));
1196         LayoutUnit decorationsHeight = std::max(LayoutUnit(-outlineStyle.outlineOffset()), borderHeight + minInsetBottomShadowExtent) + std::max(outlineWidth, shadowBottom);
1197         LayoutRect bottomRect(newOutlineBox.x(),
1198             std::min(newOutlineBox.maxY(), oldOutlineBox.maxY()) - decorationsHeight,
1199             std::max(newOutlineBox.width(), oldOutlineBox.width()),
1200             height + decorationsHeight);
1201         LayoutUnit bottom = std::min(newBounds.maxY(), oldBounds.maxY());
1202         if (bottomRect.y() &lt; bottom) {
1203             bottomRect.setHeight(std::min(bottomRect.height(), bottom - bottomRect.y()));
1204             repaintUsingContainer(repaintContainer, bottomRect);
1205         }
1206     }
1207     return false;
1208 }
1209 
1210 bool RenderElement::borderImageIsLoadedAndCanBeRendered() const
1211 {
1212     ASSERT(style().hasBorder());
1213 
1214     StyleImage* borderImage = style().borderImage().image();
1215     return borderImage &amp;&amp; borderImage-&gt;canRender(this, style().effectiveZoom()) &amp;&amp; borderImage-&gt;isLoaded();
1216 }
1217 
1218 bool RenderElement::mayCauseRepaintInsideViewport(const IntRect* optionalViewportRect) const
1219 {
1220     auto&amp; frameView = view().frameView();
1221     if (frameView.isOffscreen())
1222         return false;
1223 
1224     if (!hasOverflowClip()) {
1225         // FIXME: Computing the overflow rect is expensive if any descendant has
1226         // its own self-painting layer. As a result, we prefer to abort early in
1227         // this case and assume it may cause us to repaint inside the viewport.
1228         if (!hasLayer() || downcast&lt;RenderLayerModelObject&gt;(*this).layer()-&gt;firstChild())
1229             return true;
1230     }
1231 
1232     // Compute viewport rect if it was not provided.
1233     const IntRect&amp; visibleRect = optionalViewportRect ? *optionalViewportRect : frameView.windowToContents(frameView.windowClipRect());
1234     return visibleRect.intersects(enclosingIntRect(absoluteClippedOverflowRect()));
1235 }
1236 
1237 bool RenderElement::isVisibleInDocumentRect(const IntRect&amp; documentRect) const
1238 {
1239     if (document().activeDOMObjectsAreSuspended())
1240         return false;
1241     if (style().visibility() != Visibility::Visible)
1242         return false;
1243     if (view().frameView().isOffscreen())
1244         return false;
1245 
1246     // Use background rect if we are the root or if we are the body and the background is propagated to the root.
1247     // FIXME: This is overly conservative as the image may not be a background-image, in which case it will not
1248     // be propagated to the root. At this point, we unfortunately don&#39;t have access to the image anymore so we
1249     // can no longer check if it is a background image.
1250     bool backgroundIsPaintedByRoot = isDocumentElementRenderer();
1251     if (isBody()) {
1252         auto&amp; rootRenderer = *parent(); // If &lt;body&gt; has a renderer then &lt;html&gt; does too.
1253         ASSERT(rootRenderer.isDocumentElementRenderer());
1254         ASSERT(is&lt;HTMLHtmlElement&gt;(rootRenderer.element()));
1255         // FIXME: Should share body background propagation code.
1256         backgroundIsPaintedByRoot = !rootRenderer.hasBackground();
1257 
1258     }
1259 
1260     LayoutRect backgroundPaintingRect = backgroundIsPaintedByRoot ? view().backgroundRect() : absoluteClippedOverflowRect();
1261     if (!documentRect.intersects(enclosingIntRect(backgroundPaintingRect)))
1262         return false;
1263 
1264     return true;
1265 }
1266 
1267 void RenderElement::registerForVisibleInViewportCallback()
1268 {
1269     if (m_isRegisteredForVisibleInViewportCallback)
1270         return;
1271     m_isRegisteredForVisibleInViewportCallback = true;
1272 
1273     view().registerForVisibleInViewportCallback(*this);
1274 }
1275 
1276 void RenderElement::unregisterForVisibleInViewportCallback()
1277 {
1278     if (!m_isRegisteredForVisibleInViewportCallback)
1279         return;
1280     m_isRegisteredForVisibleInViewportCallback = false;
1281 
1282     view().unregisterForVisibleInViewportCallback(*this);
1283 }
1284 
1285 void RenderElement::setVisibleInViewportState(VisibleInViewportState state)
1286 {
1287     if (state == visibleInViewportState())
1288         return;
1289     m_visibleInViewportState = static_cast&lt;unsigned&gt;(state);
1290     visibleInViewportStateChanged();
1291 }
1292 
1293 void RenderElement::visibleInViewportStateChanged()
1294 {
1295     ASSERT_NOT_REACHED();
1296 }
1297 
1298 bool RenderElement::isVisibleInViewport() const
1299 {
1300     auto&amp; frameView = view().frameView();
1301     auto visibleRect = frameView.windowToContents(frameView.windowClipRect());
1302     return isVisibleInDocumentRect(visibleRect);
1303 }
1304 
1305 VisibleInViewportState RenderElement::imageFrameAvailable(CachedImage&amp; image, ImageAnimatingState animatingState, const IntRect* changeRect)
1306 {
1307     bool isVisible = isVisibleInViewport();
1308 
1309     if (!isVisible &amp;&amp; animatingState == ImageAnimatingState::Yes)
1310         view().addRendererWithPausedImageAnimations(*this, image);
1311 
1312     // Static images should repaint even if they are outside the viewport rectangle
1313     // because they should be inside the TileCoverageRect.
1314     if (isVisible || animatingState == ImageAnimatingState::No)
1315         imageChanged(&amp;image, changeRect);
1316 
1317     if (element() &amp;&amp; image.image()-&gt;isBitmapImage())
1318         element()-&gt;dispatchWebKitImageReadyEventForTesting();
1319 
1320     return isVisible ? VisibleInViewportState::Yes : VisibleInViewportState::No;
1321 }
1322 
1323 void RenderElement::didRemoveCachedImageClient(CachedImage&amp; cachedImage)
1324 {
1325     if (hasPausedImageAnimations())
1326         view().removeRendererWithPausedImageAnimations(*this, cachedImage);
1327 }
1328 
1329 bool RenderElement::repaintForPausedImageAnimationsIfNeeded(const IntRect&amp; visibleRect, CachedImage&amp; cachedImage)
1330 {
1331     ASSERT(m_hasPausedImageAnimations);
1332     if (!isVisibleInDocumentRect(visibleRect))
1333         return false;
1334 
1335     repaint();
1336 
1337     if (auto* image = cachedImage.image()) {
1338         if (is&lt;SVGImage&gt;(image))
1339             downcast&lt;SVGImage&gt;(image)-&gt;scheduleStartAnimation();
1340         else
1341             image-&gt;startAnimation();
1342     }
1343 
1344     // For directly-composited animated GIFs it does not suffice to call repaint() to resume animation. We need to mark the image as changed.
1345     if (is&lt;RenderBoxModelObject&gt;(*this))
1346         downcast&lt;RenderBoxModelObject&gt;(*this).contentChanged(ImageChanged);
1347 
1348     return true;
1349 }
1350 
1351 const RenderStyle* RenderElement::getCachedPseudoStyle(PseudoId pseudo, const RenderStyle* parentStyle) const
1352 {
1353     if (pseudo &lt; PseudoId::FirstInternalPseudoId &amp;&amp; !style().hasPseudoStyle(pseudo))
1354         return nullptr;
1355 
1356     RenderStyle* cachedStyle = style().getCachedPseudoStyle(pseudo);
1357     if (cachedStyle)
1358         return cachedStyle;
1359 
<a name="6" id="anc6"></a><span class="line-modified">1360     std::unique_ptr&lt;RenderStyle&gt; result = getUncachedPseudoStyle({ pseudo }, parentStyle);</span>
1361     if (result)
1362         return const_cast&lt;RenderStyle&amp;&gt;(m_style).addCachedPseudoStyle(WTFMove(result));
1363     return nullptr;
1364 }
1365 
<a name="7" id="anc7"></a><span class="line-modified">1366 std::unique_ptr&lt;RenderStyle&gt; RenderElement::getUncachedPseudoStyle(const Style::PseudoElementRequest&amp; pseudoElementRequest, const RenderStyle* parentStyle, const RenderStyle* ownStyle) const</span>
1367 {
<a name="8" id="anc8"></a><span class="line-modified">1368     if (pseudoElementRequest.pseudoId &lt; PseudoId::FirstInternalPseudoId &amp;&amp; !ownStyle &amp;&amp; !style().hasPseudoStyle(pseudoElementRequest.pseudoId))</span>
1369         return nullptr;
1370 
1371     if (!parentStyle) {
1372         ASSERT(!ownStyle);
1373         parentStyle = &amp;style();
1374     }
1375 
1376     if (isAnonymous())
1377         return nullptr;
1378 
1379     auto&amp; styleResolver = element()-&gt;styleResolver();
1380 
<a name="9" id="anc9"></a><span class="line-modified">1381     std::unique_ptr&lt;RenderStyle&gt; style = styleResolver.pseudoStyleForElement(*element(), pseudoElementRequest, *parentStyle);</span>
1382 
1383     if (style)
1384         Style::loadPendingResources(*style, document(), element());
1385 
1386     return style;
1387 }
1388 
1389 Color RenderElement::selectionColor(CSSPropertyID colorProperty) const
1390 {
1391     // If the element is unselectable, or we are only painting the selection,
1392     // don&#39;t override the foreground color with the selection foreground color.
1393     if (style().userSelect() == UserSelect::None
1394         || (view().frameView().paintBehavior().containsAny({ PaintBehavior::SelectionOnly, PaintBehavior::SelectionAndBackgroundsOnly })))
1395         return Color();
1396 
1397     if (std::unique_ptr&lt;RenderStyle&gt; pseudoStyle = selectionPseudoStyle()) {
1398         Color color = pseudoStyle-&gt;visitedDependentColorWithColorFilter(colorProperty);
1399         if (!color.isValid())
1400             color = pseudoStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyColor);
1401         return color;
1402     }
1403 
1404     if (frame().selection().isFocusedAndActive())
1405         return theme().activeSelectionForegroundColor(styleColorOptions());
1406     return theme().inactiveSelectionForegroundColor(styleColorOptions());
1407 }
1408 
1409 std::unique_ptr&lt;RenderStyle&gt; RenderElement::selectionPseudoStyle() const
1410 {
1411     if (isAnonymous())
1412         return nullptr;
1413 
1414     if (ShadowRoot* root = element()-&gt;containingShadowRoot()) {
1415         if (root-&gt;mode() == ShadowRootMode::UserAgent) {
<a name="10" id="anc10"></a><span class="line-modified">1416             auto* currentElement = element()-&gt;shadowHost();</span>
<span class="line-modified">1417             // When an element has display: contents, this element doesn&#39;t have a renderer</span>
<span class="line-added">1418             // and its children will render as children of the parent element.</span>
<span class="line-added">1419             while (currentElement &amp;&amp; currentElement-&gt;hasDisplayContents())</span>
<span class="line-added">1420                 currentElement = currentElement-&gt;parentElement();</span>
<span class="line-added">1421             if (currentElement &amp;&amp; currentElement-&gt;renderer())</span>
<span class="line-added">1422                 return currentElement-&gt;renderer()-&gt;getUncachedPseudoStyle({ PseudoId::Selection });</span>
1423         }
1424     }
1425 
<a name="11" id="anc11"></a><span class="line-modified">1426     return getUncachedPseudoStyle({ PseudoId::Selection });</span>
1427 }
1428 
1429 Color RenderElement::selectionForegroundColor() const
1430 {
1431     return selectionColor(CSSPropertyWebkitTextFillColor);
1432 }
1433 
1434 Color RenderElement::selectionEmphasisMarkColor() const
1435 {
1436     return selectionColor(CSSPropertyWebkitTextEmphasisColor);
1437 }
1438 
1439 Color RenderElement::selectionBackgroundColor() const
1440 {
1441     if (style().userSelect() == UserSelect::None)
1442         return Color();
1443 
1444     if (frame().selection().shouldShowBlockCursor() &amp;&amp; frame().selection().isCaret())
1445         return theme().transformSelectionBackgroundColor(style().visitedDependentColorWithColorFilter(CSSPropertyColor), styleColorOptions());
1446 
1447     std::unique_ptr&lt;RenderStyle&gt; pseudoStyle = selectionPseudoStyle();
1448     if (pseudoStyle &amp;&amp; pseudoStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor).isValid())
1449         return theme().transformSelectionBackgroundColor(pseudoStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor), styleColorOptions());
1450 
1451     if (frame().selection().isFocusedAndActive())
1452         return theme().activeSelectionBackgroundColor(styleColorOptions());
1453     return theme().inactiveSelectionBackgroundColor(styleColorOptions());
1454 }
1455 
1456 bool RenderElement::getLeadingCorner(FloatPoint&amp; point, bool&amp; insideFixed) const
1457 {
1458     if (!isInline() || isReplaced()) {
1459         point = localToAbsolute(FloatPoint(), UseTransforms, &amp;insideFixed);
1460         return true;
1461     }
1462 
1463     // find the next text/image child, to get a position
1464     const RenderObject* o = this;
1465     while (o) {
1466         const RenderObject* p = o;
1467         if (RenderObject* child = o-&gt;firstChildSlow())
1468             o = child;
1469         else if (o-&gt;nextSibling())
1470             o = o-&gt;nextSibling();
1471         else {
1472             RenderObject* next = 0;
1473             while (!next &amp;&amp; o-&gt;parent()) {
1474                 o = o-&gt;parent();
1475                 next = o-&gt;nextSibling();
1476             }
1477             o = next;
1478 
1479             if (!o)
1480                 break;
1481         }
1482         ASSERT(o);
1483 
1484         if (!o-&gt;isInline() || o-&gt;isReplaced()) {
1485             point = o-&gt;localToAbsolute(FloatPoint(), UseTransforms, &amp;insideFixed);
1486             return true;
1487         }
1488 
1489         if (p-&gt;node() &amp;&amp; p-&gt;node() == element() &amp;&amp; is&lt;RenderText&gt;(*o) &amp;&amp; !downcast&lt;RenderText&gt;(*o).firstTextBox()) {
1490             // do nothing - skip unrendered whitespace that is a child or next sibling of the anchor
1491         } else if (is&lt;RenderText&gt;(*o) || o-&gt;isReplaced()) {
1492             point = FloatPoint();
1493             if (is&lt;RenderText&gt;(*o) &amp;&amp; downcast&lt;RenderText&gt;(*o).firstTextBox())
1494                 point.move(downcast&lt;RenderText&gt;(*o).linesBoundingBox().x(), downcast&lt;RenderText&gt;(*o).topOfFirstText());
1495             else if (is&lt;RenderBox&gt;(*o))
1496                 point.moveBy(downcast&lt;RenderBox&gt;(*o).location());
1497             point = o-&gt;container()-&gt;localToAbsolute(point, UseTransforms, &amp;insideFixed);
1498             return true;
1499         }
1500     }
1501 
1502     // If the target doesn&#39;t have any children or siblings that could be used to calculate the scroll position, we must be
1503     // at the end of the document. Scroll to the bottom. FIXME: who said anything about scrolling?
1504     if (!o &amp;&amp; document().view()) {
1505         point = FloatPoint(0, document().view()-&gt;contentsHeight());
1506         return true;
1507     }
1508     return false;
1509 }
1510 
1511 bool RenderElement::getTrailingCorner(FloatPoint&amp; point, bool&amp; insideFixed) const
1512 {
1513     if (!isInline() || isReplaced()) {
1514         point = localToAbsolute(LayoutPoint(downcast&lt;RenderBox&gt;(*this).size()), UseTransforms, &amp;insideFixed);
1515         return true;
1516     }
1517 
1518     // find the last text/image child, to get a position
1519     const RenderObject* o = this;
1520     while (o) {
1521         if (RenderObject* child = o-&gt;lastChildSlow())
1522             o = child;
1523         else if (o-&gt;previousSibling())
1524             o = o-&gt;previousSibling();
1525         else {
1526             RenderObject* prev = 0;
1527             while (!prev) {
1528                 o = o-&gt;parent();
1529                 if (!o)
1530                     return false;
1531                 prev = o-&gt;previousSibling();
1532             }
1533             o = prev;
1534         }
1535         ASSERT(o);
1536         if (is&lt;RenderText&gt;(*o) || o-&gt;isReplaced()) {
1537             point = FloatPoint();
1538             if (is&lt;RenderText&gt;(*o)) {
1539                 LayoutRect linesBox = downcast&lt;RenderText&gt;(*o).linesBoundingBox();
1540                 if (!linesBox.maxX() &amp;&amp; !linesBox.maxY())
1541                     continue;
1542                 point.moveBy(linesBox.maxXMaxYCorner());
1543             } else
1544                 point.moveBy(downcast&lt;RenderBox&gt;(*o).frameRect().maxXMaxYCorner());
1545             point = o-&gt;container()-&gt;localToAbsolute(point, UseTransforms, &amp;insideFixed);
1546             return true;
1547         }
1548     }
1549     return true;
1550 }
1551 
1552 LayoutRect RenderElement::absoluteAnchorRect(bool* insideFixed) const
1553 {
1554     FloatPoint leading, trailing;
1555     bool leadingInFixed = false;
1556     bool trailingInFixed = false;
1557     getLeadingCorner(leading, leadingInFixed);
1558     getTrailingCorner(trailing, trailingInFixed);
1559 
1560     FloatPoint upperLeft = leading;
1561     FloatPoint lowerRight = trailing;
1562 
1563     // Vertical writing modes might mean the leading point is not in the top left
1564     if (!isInline() || isReplaced()) {
1565         upperLeft = FloatPoint(std::min(leading.x(), trailing.x()), std::min(leading.y(), trailing.y()));
1566         lowerRight = FloatPoint(std::max(leading.x(), trailing.x()), std::max(leading.y(), trailing.y()));
1567     } // Otherwise, it&#39;s not obvious what to do.
1568 
1569     if (insideFixed) {
1570         // For now, just look at the leading corner. Handling one inside fixed and one not would be tricky.
1571         *insideFixed = leadingInFixed;
1572     }
1573 
1574     return enclosingLayoutRect(FloatRect(upperLeft, lowerRight.expandedTo(upperLeft) - upperLeft));
1575 }
1576 
1577 const RenderElement* RenderElement::enclosingRendererWithTextDecoration(OptionSet&lt;TextDecoration&gt; textDecoration, bool firstLine) const
1578 {
1579     const RenderElement* current = this;
1580     do {
1581         if (current-&gt;isRenderBlock())
1582             return current;
1583         if (!current-&gt;isRenderInline() || current-&gt;isRubyText())
1584             return nullptr;
1585 
1586         const RenderStyle&amp; styleToUse = firstLine ? current-&gt;firstLineStyle() : current-&gt;style();
1587         if (styleToUse.textDecoration() &amp; textDecoration)
1588             return current;
1589         current = current-&gt;parent();
1590     } while (current &amp;&amp; (!current-&gt;element() || (!is&lt;HTMLAnchorElement&gt;(*current-&gt;element()) &amp;&amp; !current-&gt;element()-&gt;hasTagName(HTMLNames::fontTag))));
1591 
1592     return current;
1593 }
1594 
1595 void RenderElement::drawLineForBoxSide(GraphicsContext&amp; graphicsContext, const FloatRect&amp; rect, BoxSide side, Color color, BorderStyle borderStyle, float adjacentWidth1, float adjacentWidth2, bool antialias) const
1596 {
1597     auto drawBorderRect = [&amp;graphicsContext] (const FloatRect&amp; rect)
1598     {
1599         if (rect.isEmpty())
1600             return;
1601         graphicsContext.drawRect(rect);
1602     };
1603 
1604     auto drawLineFor = [this, &amp;graphicsContext, color, antialias] (const FloatRect&amp; rect, BoxSide side, BorderStyle borderStyle, const FloatSize&amp; adjacent)
1605     {
1606         if (rect.isEmpty())
1607             return;
1608         drawLineForBoxSide(graphicsContext, rect, side, color, borderStyle, adjacent.width(), adjacent.height(), antialias);
1609     };
1610 
1611     float x1 = rect.x();
1612     float x2 = rect.maxX();
1613     float y1 = rect.y();
1614     float y2 = rect.maxY();
1615     float thickness;
1616     float length;
1617     if (side == BSTop || side == BSBottom) {
1618         thickness = y2 - y1;
1619         length = x2 - x1;
1620     } else {
1621         thickness = x2 - x1;
1622         length = y2 - y1;
1623     }
1624     // FIXME: We really would like this check to be an ASSERT as we don&#39;t want to draw empty borders. However
1625     // nothing guarantees that the following recursive calls to drawLineForBoxSide will have non-null dimensions.
1626     if (!thickness || !length)
1627         return;
1628 
1629     float deviceScaleFactor = document().deviceScaleFactor();
1630     if (borderStyle == BorderStyle::Double &amp;&amp; (thickness * deviceScaleFactor) &lt; 3)
1631         borderStyle = BorderStyle::Solid;
1632 
1633     switch (borderStyle) {
1634     case BorderStyle::None:
1635     case BorderStyle::Hidden:
1636         return;
1637     case BorderStyle::Dotted:
1638     case BorderStyle::Dashed: {
1639         bool wasAntialiased = graphicsContext.shouldAntialias();
1640         StrokeStyle oldStrokeStyle = graphicsContext.strokeStyle();
1641         graphicsContext.setShouldAntialias(antialias);
1642         graphicsContext.setStrokeColor(color);
1643         graphicsContext.setStrokeThickness(thickness);
1644         graphicsContext.setStrokeStyle(borderStyle == BorderStyle::Dashed ? DashedStroke : DottedStroke);
1645         graphicsContext.drawLine(roundPointToDevicePixels(LayoutPoint(x1, y1), deviceScaleFactor), roundPointToDevicePixels(LayoutPoint(x2, y2), deviceScaleFactor));
1646         graphicsContext.setShouldAntialias(wasAntialiased);
1647         graphicsContext.setStrokeStyle(oldStrokeStyle);
1648         break;
1649     }
1650     case BorderStyle::Double: {
1651         float thirdOfThickness = ceilToDevicePixel(thickness / 3, deviceScaleFactor);
1652         ASSERT(thirdOfThickness);
1653 
1654         if (!adjacentWidth1 &amp;&amp; !adjacentWidth2) {
1655             StrokeStyle oldStrokeStyle = graphicsContext.strokeStyle();
1656             graphicsContext.setStrokeStyle(NoStroke);
1657             graphicsContext.setFillColor(color);
1658 
1659             bool wasAntialiased = graphicsContext.shouldAntialias();
1660             graphicsContext.setShouldAntialias(antialias);
1661 
1662             switch (side) {
1663             case BSTop:
1664             case BSBottom:
1665                 drawBorderRect(snapRectToDevicePixels(LayoutRect(x1, y1, length, thirdOfThickness), deviceScaleFactor));
1666                 drawBorderRect(snapRectToDevicePixels(LayoutRect(x1, y2 - thirdOfThickness, length, thirdOfThickness), deviceScaleFactor));
1667                 break;
1668             case BSLeft:
1669             case BSRight:
1670                 drawBorderRect(snapRectToDevicePixels(LayoutRect(x1, y1, thirdOfThickness, length), deviceScaleFactor));
1671                 drawBorderRect(snapRectToDevicePixels(LayoutRect(x2 - thirdOfThickness, y1, thirdOfThickness, length), deviceScaleFactor));
1672                 break;
1673             }
1674 
1675             graphicsContext.setShouldAntialias(wasAntialiased);
1676             graphicsContext.setStrokeStyle(oldStrokeStyle);
1677         } else {
1678             float adjacent1BigThird = ceilToDevicePixel(adjacentWidth1 / 3, deviceScaleFactor);
1679             float adjacent2BigThird = ceilToDevicePixel(adjacentWidth2 / 3, deviceScaleFactor);
1680 
1681             float offset1 = floorToDevicePixel(fabs(adjacentWidth1) * 2 / 3, deviceScaleFactor);
1682             float offset2 = floorToDevicePixel(fabs(adjacentWidth2) * 2 / 3, deviceScaleFactor);
1683 
1684             float mitreOffset1 = adjacentWidth1 &lt; 0 ? offset1 : 0;
1685             float mitreOffset2 = adjacentWidth1 &gt; 0 ? offset1 : 0;
1686             float mitreOffset3 = adjacentWidth2 &lt; 0 ? offset2 : 0;
1687             float mitreOffset4 = adjacentWidth2 &gt; 0 ? offset2 : 0;
1688 
1689             FloatRect paintBorderRect;
1690             switch (side) {
1691             case BSTop:
1692                 paintBorderRect = snapRectToDevicePixels(LayoutRect(x1 + mitreOffset1, y1, (x2 - mitreOffset3) - (x1 + mitreOffset1), thirdOfThickness), deviceScaleFactor);
1693                 drawLineFor(paintBorderRect, side, BorderStyle::Solid, FloatSize(adjacent1BigThird, adjacent2BigThird));
1694 
1695                 paintBorderRect = snapRectToDevicePixels(LayoutRect(x1 + mitreOffset2, y2 - thirdOfThickness, (x2 - mitreOffset4) - (x1 + mitreOffset2), thirdOfThickness), deviceScaleFactor);
1696                 drawLineFor(paintBorderRect, side, BorderStyle::Solid, FloatSize(adjacent1BigThird, adjacent2BigThird));
1697                 break;
1698             case BSLeft:
1699                 paintBorderRect = snapRectToDevicePixels(LayoutRect(x1, y1 + mitreOffset1, thirdOfThickness, (y2 - mitreOffset3) - (y1 + mitreOffset1)), deviceScaleFactor);
1700                 drawLineFor(paintBorderRect, side, BorderStyle::Solid, FloatSize(adjacent1BigThird, adjacent2BigThird));
1701 
1702                 paintBorderRect = snapRectToDevicePixels(LayoutRect(x2 - thirdOfThickness, y1 + mitreOffset2, thirdOfThickness, (y2 - mitreOffset4) - (y1 + mitreOffset2)), deviceScaleFactor);
1703                 drawLineFor(paintBorderRect, side, BorderStyle::Solid, FloatSize(adjacent1BigThird, adjacent2BigThird));
1704                 break;
1705             case BSBottom:
1706                 paintBorderRect = snapRectToDevicePixels(LayoutRect(x1 + mitreOffset2, y1, (x2 - mitreOffset4) - (x1 + mitreOffset2), thirdOfThickness), deviceScaleFactor);
1707                 drawLineFor(paintBorderRect, side, BorderStyle::Solid, FloatSize(adjacent1BigThird, adjacent2BigThird));
1708 
1709                 paintBorderRect = snapRectToDevicePixels(LayoutRect(x1 + mitreOffset1, y2 - thirdOfThickness, (x2 - mitreOffset3) - (x1 + mitreOffset1), thirdOfThickness), deviceScaleFactor);
1710                 drawLineFor(paintBorderRect, side, BorderStyle::Solid, FloatSize(adjacent1BigThird, adjacent2BigThird));
1711                 break;
1712             case BSRight:
1713                 paintBorderRect = snapRectToDevicePixels(LayoutRect(x1, y1 + mitreOffset2, thirdOfThickness, (y2 - mitreOffset4) - (y1 + mitreOffset2)), deviceScaleFactor);
1714                 drawLineFor(paintBorderRect, side, BorderStyle::Solid, FloatSize(adjacent1BigThird, adjacent2BigThird));
1715 
1716                 paintBorderRect = snapRectToDevicePixels(LayoutRect(x2 - thirdOfThickness, y1 + mitreOffset1, thirdOfThickness, (y2 - mitreOffset3) - (y1 + mitreOffset1)), deviceScaleFactor);
1717                 drawLineFor(paintBorderRect, side, BorderStyle::Solid, FloatSize(adjacent1BigThird, adjacent2BigThird));
1718                 break;
1719             default:
1720                 break;
1721             }
1722         }
1723         break;
1724     }
1725     case BorderStyle::Ridge:
1726     case BorderStyle::Groove: {
1727         BorderStyle s1;
1728         BorderStyle s2;
1729         if (borderStyle == BorderStyle::Groove) {
1730             s1 = BorderStyle::Inset;
1731             s2 = BorderStyle::Outset;
1732         } else {
1733             s1 = BorderStyle::Outset;
1734             s2 = BorderStyle::Inset;
1735         }
1736 
1737         float adjacent1BigHalf = ceilToDevicePixel(adjacentWidth1 / 2, deviceScaleFactor);
1738         float adjacent2BigHalf = ceilToDevicePixel(adjacentWidth2 / 2, deviceScaleFactor);
1739 
1740         float adjacent1SmallHalf = floorToDevicePixel(adjacentWidth1 / 2, deviceScaleFactor);
1741         float adjacent2SmallHalf = floorToDevicePixel(adjacentWidth2 / 2, deviceScaleFactor);
1742 
1743         float offset1 = 0;
1744         float offset2 = 0;
1745         float offset3 = 0;
1746         float offset4 = 0;
1747 
1748         if (((side == BSTop || side == BSLeft) &amp;&amp; adjacentWidth1 &lt; 0) || ((side == BSBottom || side == BSRight) &amp;&amp; adjacentWidth1 &gt; 0))
1749             offset1 = floorToDevicePixel(adjacentWidth1 / 2, deviceScaleFactor);
1750 
1751         if (((side == BSTop || side == BSLeft) &amp;&amp; adjacentWidth2 &lt; 0) || ((side == BSBottom || side == BSRight) &amp;&amp; adjacentWidth2 &gt; 0))
1752             offset2 = ceilToDevicePixel(adjacentWidth2 / 2, deviceScaleFactor);
1753 
1754         if (((side == BSTop || side == BSLeft) &amp;&amp; adjacentWidth1 &gt; 0) || ((side == BSBottom || side == BSRight) &amp;&amp; adjacentWidth1 &lt; 0))
1755             offset3 = floorToDevicePixel(fabs(adjacentWidth1) / 2, deviceScaleFactor);
1756 
1757         if (((side == BSTop || side == BSLeft) &amp;&amp; adjacentWidth2 &gt; 0) || ((side == BSBottom || side == BSRight) &amp;&amp; adjacentWidth2 &lt; 0))
1758             offset4 = ceilToDevicePixel(adjacentWidth2 / 2, deviceScaleFactor);
1759 
1760         float adjustedX = ceilToDevicePixel((x1 + x2) / 2, deviceScaleFactor);
1761         float adjustedY = ceilToDevicePixel((y1 + y2) / 2, deviceScaleFactor);
1762         // Quads can&#39;t use the default snapping rect functions.
1763         x1 = roundToDevicePixel(x1, deviceScaleFactor);
1764         x2 = roundToDevicePixel(x2, deviceScaleFactor);
1765         y1 = roundToDevicePixel(y1, deviceScaleFactor);
1766         y2 = roundToDevicePixel(y2, deviceScaleFactor);
1767 
1768         switch (side) {
1769         case BSTop:
1770             drawLineFor(FloatRect(FloatPoint(x1 + offset1, y1), FloatPoint(x2 - offset2, adjustedY)), side, s1, FloatSize(adjacent1BigHalf, adjacent2BigHalf));
1771             drawLineFor(FloatRect(FloatPoint(x1 + offset3, adjustedY), FloatPoint(x2 - offset4, y2)), side, s2, FloatSize(adjacent1SmallHalf, adjacent2SmallHalf));
1772             break;
1773         case BSLeft:
1774             drawLineFor(FloatRect(FloatPoint(x1, y1 + offset1), FloatPoint(adjustedX, y2 - offset2)), side, s1, FloatSize(adjacent1BigHalf, adjacent2BigHalf));
1775             drawLineFor(FloatRect(FloatPoint(adjustedX, y1 + offset3), FloatPoint(x2, y2 - offset4)), side, s2, FloatSize(adjacent1SmallHalf, adjacent2SmallHalf));
1776             break;
1777         case BSBottom:
1778             drawLineFor(FloatRect(FloatPoint(x1 + offset1, y1), FloatPoint(x2 - offset2, adjustedY)), side, s2, FloatSize(adjacent1BigHalf, adjacent2BigHalf));
1779             drawLineFor(FloatRect(FloatPoint(x1 + offset3, adjustedY), FloatPoint(x2 - offset4, y2)), side, s1, FloatSize(adjacent1SmallHalf, adjacent2SmallHalf));
1780             break;
1781         case BSRight:
1782             drawLineFor(FloatRect(FloatPoint(x1, y1 + offset1), FloatPoint(adjustedX, y2 - offset2)), side, s2, FloatSize(adjacent1BigHalf, adjacent2BigHalf));
1783             drawLineFor(FloatRect(FloatPoint(adjustedX, y1 + offset3), FloatPoint(x2, y2 - offset4)), side, s1, FloatSize(adjacent1SmallHalf, adjacent2SmallHalf));
1784             break;
1785         }
1786         break;
1787     }
1788     case BorderStyle::Inset:
1789     case BorderStyle::Outset:
1790         calculateBorderStyleColor(borderStyle, side, color);
1791         FALLTHROUGH;
1792     case BorderStyle::Solid: {
1793         StrokeStyle oldStrokeStyle = graphicsContext.strokeStyle();
1794         ASSERT(x2 &gt;= x1);
1795         ASSERT(y2 &gt;= y1);
1796         if (!adjacentWidth1 &amp;&amp; !adjacentWidth2) {
1797             graphicsContext.setStrokeStyle(NoStroke);
1798             graphicsContext.setFillColor(color);
1799             bool wasAntialiased = graphicsContext.shouldAntialias();
1800             graphicsContext.setShouldAntialias(antialias);
1801             drawBorderRect(snapRectToDevicePixels(LayoutRect(x1, y1, x2 - x1, y2 - y1), deviceScaleFactor));
1802             graphicsContext.setShouldAntialias(wasAntialiased);
1803             graphicsContext.setStrokeStyle(oldStrokeStyle);
1804             return;
1805         }
1806 
1807         // FIXME: These roundings should be replaced by ASSERT(device pixel positioned) when all the callers have transitioned to device pixels.
1808         x1 = roundToDevicePixel(x1, deviceScaleFactor);
1809         y1 = roundToDevicePixel(y1, deviceScaleFactor);
1810         x2 = roundToDevicePixel(x2, deviceScaleFactor);
1811         y2 = roundToDevicePixel(y2, deviceScaleFactor);
1812 
1813         Vector&lt;FloatPoint&gt; quad;
1814         quad.reserveInitialCapacity(4);
1815         switch (side) {
1816         case BSTop:
1817             quad.uncheckedAppend({ x1 + std::max&lt;float&gt;(-adjacentWidth1, 0), y1 });
1818             quad.uncheckedAppend({ x1 + std::max&lt;float&gt;( adjacentWidth1, 0), y2 });
1819             quad.uncheckedAppend({ x2 - std::max&lt;float&gt;( adjacentWidth2, 0), y2 });
1820             quad.uncheckedAppend({ x2 - std::max&lt;float&gt;(-adjacentWidth2, 0), y1 });
1821             break;
1822         case BSBottom:
1823             quad.uncheckedAppend({ x1 + std::max&lt;float&gt;( adjacentWidth1, 0), y1 });
1824             quad.uncheckedAppend({ x1 + std::max&lt;float&gt;(-adjacentWidth1, 0), y2 });
1825             quad.uncheckedAppend({ x2 - std::max&lt;float&gt;(-adjacentWidth2, 0), y2 });
1826             quad.uncheckedAppend({ x2 - std::max&lt;float&gt;( adjacentWidth2, 0), y1 });
1827             break;
1828         case BSLeft:
1829             quad.uncheckedAppend({ x1, y1 + std::max&lt;float&gt;(-adjacentWidth1, 0) });
1830             quad.uncheckedAppend({ x1, y2 - std::max&lt;float&gt;(-adjacentWidth2, 0) });
1831             quad.uncheckedAppend({ x2, y2 - std::max&lt;float&gt;( adjacentWidth2, 0) });
1832             quad.uncheckedAppend({ x2, y1 + std::max&lt;float&gt;( adjacentWidth1, 0) });
1833             break;
1834         case BSRight:
1835             quad.uncheckedAppend({ x1, y1 + std::max&lt;float&gt;( adjacentWidth1, 0) });
1836             quad.uncheckedAppend({ x1, y2 - std::max&lt;float&gt;( adjacentWidth2, 0) });
1837             quad.uncheckedAppend({ x2, y2 - std::max&lt;float&gt;(-adjacentWidth2, 0) });
1838             quad.uncheckedAppend({ x2, y1 + std::max&lt;float&gt;(-adjacentWidth1, 0) });
1839             break;
1840         }
1841 
1842         graphicsContext.setStrokeStyle(NoStroke);
1843         graphicsContext.setFillColor(color);
1844         bool wasAntialiased = graphicsContext.shouldAntialias();
1845         graphicsContext.setShouldAntialias(antialias);
1846         graphicsContext.fillPath(Path::polygonPathFromPoints(quad));
1847         graphicsContext.setShouldAntialias(wasAntialiased);
1848 
1849         graphicsContext.setStrokeStyle(oldStrokeStyle);
1850         break;
1851     }
1852     }
1853 }
1854 
1855 static bool usePlatformFocusRingColorForOutlineStyleAuto()
1856 {
1857 #if PLATFORM(COCOA)
1858     return true;
1859 #else
1860     return false;
1861 #endif
1862 }
1863 
1864 static bool useShrinkWrappedFocusRingForOutlineStyleAuto()
1865 {
1866 #if PLATFORM(COCOA)
1867     return true;
1868 #else
1869     return false;
1870 #endif
1871 }
1872 
1873 static bool drawFocusRing(GraphicsContext&amp; context, Page&amp; page, const Path&amp; path, const RenderStyle&amp; style, Color focusRingColor)
1874 {
1875     bool needsRepaint = false;
1876 #if PLATFORM(MAC)
1877     context.drawFocusRing(path, page.focusController().timeSinceFocusWasSet().seconds(), needsRepaint, focusRingColor);
1878     UNUSED_PARAM(style);
1879 #else
1880     context.drawFocusRing(path, style.outlineWidth(), style.outlineOffset(), focusRingColor);
1881     UNUSED_PARAM(page);
1882 #endif
1883     return needsRepaint;
1884 }
1885 
1886 static bool drawFocusRing(GraphicsContext&amp; context, Page&amp; page, Vector&lt;FloatRect&gt; rects, const RenderStyle&amp; style, Color focusRingColor)
1887 {
1888     bool needsRepaint = false;
1889 #if PLATFORM(MAC)
1890     context.drawFocusRing(rects, page.focusController().timeSinceFocusWasSet().seconds(), needsRepaint, focusRingColor);
1891     UNUSED_PARAM(style);
1892 #else
1893     context.drawFocusRing(rects, style.outlineWidth(), style.outlineOffset(), focusRingColor);
1894     UNUSED_PARAM(page);
1895 #endif
1896     return needsRepaint;
1897 }
1898 
1899 
1900 void RenderElement::paintFocusRing(PaintInfo&amp; paintInfo, const RenderStyle&amp; style, const Vector&lt;LayoutRect&gt;&amp; focusRingRects)
1901 {
1902     ASSERT(style.outlineStyleIsAuto() == OutlineIsAuto::On);
1903     float outlineOffset = style.outlineOffset();
1904     Vector&lt;FloatRect&gt; pixelSnappedFocusRingRects;
1905     float deviceScaleFactor = document().deviceScaleFactor();
1906     for (auto rect : focusRingRects) {
1907         rect.inflate(outlineOffset);
1908         pixelSnappedFocusRingRects.append(snapRectToDevicePixels(rect, deviceScaleFactor));
1909     }
1910     Color focusRingColor = usePlatformFocusRingColorForOutlineStyleAuto() ? RenderTheme::singleton().focusRingColor(styleColorOptions()) : style.visitedDependentColorWithColorFilter(CSSPropertyOutlineColor);
1911     bool needsRepaint;
1912     if (useShrinkWrappedFocusRingForOutlineStyleAuto() &amp;&amp; style.hasBorderRadius()) {
1913         Path path = PathUtilities::pathWithShrinkWrappedRectsForOutline(pixelSnappedFocusRingRects, style.border(), outlineOffset, style.direction(), style.writingMode(),
1914             document().deviceScaleFactor());
1915         if (path.isEmpty()) {
1916             for (auto rect : pixelSnappedFocusRingRects)
1917                 path.addRect(rect);
1918         }
1919         needsRepaint = drawFocusRing(paintInfo.context(), page(), path, style, focusRingColor);
1920     } else
1921         needsRepaint = drawFocusRing(paintInfo.context(), page(), pixelSnappedFocusRingRects, style, focusRingColor);
1922     if (needsRepaint)
1923         page().focusController().setFocusedElementNeedsRepaint();
1924 }
1925 
1926 void RenderElement::paintOutline(PaintInfo&amp; paintInfo, const LayoutRect&amp; paintRect)
1927 {
1928     GraphicsContext&amp; graphicsContext = paintInfo.context();
1929     if (graphicsContext.paintingDisabled())
1930         return;
1931 
1932     if (!hasOutline())
1933         return;
1934 
1935     auto&amp; styleToUse = style();
1936     float outlineWidth = floorToDevicePixel(styleToUse.outlineWidth(), document().deviceScaleFactor());
1937     float outlineOffset = floorToDevicePixel(styleToUse.outlineOffset(), document().deviceScaleFactor());
1938 
1939     // Only paint the focus ring by hand if the theme isn&#39;t able to draw it.
1940     if (styleToUse.outlineStyleIsAuto() == OutlineIsAuto::On &amp;&amp; !theme().supportsFocusRing(styleToUse)) {
1941         Vector&lt;LayoutRect&gt; focusRingRects;
1942         LayoutRect paintRectToUse { paintRect };
1943 #if PLATFORM(IOS_FAMILY)
1944         // Workaround for &lt;rdar://problem/6209763&gt;. Force the painting bounds of checkboxes and radio controls to be square.
1945         // FIXME: Consolidate this code with the same code in RenderBox::paintBoxDecorations(). See &lt;https://bugs.webkit.org/show_bug.cgi?id=194781&gt;.
1946         if (style().appearance() == CheckboxPart || style().appearance() == RadioPart) {
1947             int width = std::min(paintRect.width(), paintRect.height());
1948             int height = width;
1949             paintRectToUse = IntRect { paintRect.x(), paintRect.y() + (downcast&lt;RenderBox&gt;(*this).height() - height) / 2, width, height }; // Vertically center the checkbox, like on desktop
1950         }
1951 #endif
1952         addFocusRingRects(focusRingRects, paintRectToUse.location(), paintInfo.paintContainer);
1953         paintFocusRing(paintInfo, styleToUse, focusRingRects);
1954     }
1955 
1956     if (hasOutlineAnnotation() &amp;&amp; styleToUse.outlineStyleIsAuto() == OutlineIsAuto::Off &amp;&amp; !theme().supportsFocusRing(styleToUse))
1957         addPDFURLRect(paintInfo, paintRect.location());
1958 
1959     if (styleToUse.outlineStyleIsAuto() == OutlineIsAuto::On || styleToUse.outlineStyle() == BorderStyle::None)
1960         return;
1961 
1962     FloatRect outer = paintRect;
1963     outer.inflate(outlineOffset + outlineWidth);
1964     FloatRect inner = outer;
1965     inner.inflate(-outlineWidth);
1966 
1967     // FIXME: This prevents outlines from painting inside the object. See bug 12042
1968     if (outer.isEmpty())
1969         return;
1970 
1971     BorderStyle outlineStyle = styleToUse.outlineStyle();
1972     Color outlineColor = styleToUse.visitedDependentColorWithColorFilter(CSSPropertyOutlineColor);
1973 
1974     bool useTransparencyLayer = !outlineColor.isOpaque();
1975     if (useTransparencyLayer) {
1976         if (outlineStyle == BorderStyle::Solid) {
1977             Path path;
1978             path.addRect(outer);
1979             path.addRect(inner);
1980             graphicsContext.setFillRule(WindRule::EvenOdd);
1981             graphicsContext.setFillColor(outlineColor);
1982             graphicsContext.fillPath(path);
1983             return;
1984         }
1985         graphicsContext.beginTransparencyLayer(outlineColor.alphaAsFloat());
1986         outlineColor = outlineColor.opaqueColor();
1987     }
1988 
1989     float leftOuter = outer.x();
1990     float leftInner = inner.x();
1991     float rightOuter = outer.maxX();
1992     float rightInner = std::min(inner.maxX(), rightOuter);
1993     float topOuter = outer.y();
1994     float topInner = inner.y();
1995     float bottomOuter = outer.maxY();
1996     float bottomInner = std::min(inner.maxY(), bottomOuter);
1997 
1998     drawLineForBoxSide(graphicsContext, FloatRect(FloatPoint(leftOuter, topOuter), FloatPoint(leftInner, bottomOuter)), BSLeft, outlineColor, outlineStyle, outlineWidth, outlineWidth);
1999     drawLineForBoxSide(graphicsContext, FloatRect(FloatPoint(leftOuter, topOuter), FloatPoint(rightOuter, topInner)), BSTop, outlineColor, outlineStyle, outlineWidth, outlineWidth);
2000     drawLineForBoxSide(graphicsContext, FloatRect(FloatPoint(rightInner, topOuter), FloatPoint(rightOuter, bottomOuter)), BSRight, outlineColor, outlineStyle, outlineWidth, outlineWidth);
2001     drawLineForBoxSide(graphicsContext, FloatRect(FloatPoint(leftOuter, bottomInner), FloatPoint(rightOuter, bottomOuter)), BSBottom, outlineColor, outlineStyle, outlineWidth, outlineWidth);
2002 
2003     if (useTransparencyLayer)
2004         graphicsContext.endTransparencyLayer();
2005 }
2006 
2007 void RenderElement::issueRepaintForOutlineAuto(float outlineSize)
2008 {
2009     LayoutRect repaintRect;
2010     Vector&lt;LayoutRect&gt; focusRingRects;
2011     addFocusRingRects(focusRingRects, LayoutPoint(), containerForRepaint());
2012     for (auto rect : focusRingRects) {
2013         rect.inflate(outlineSize);
2014         repaintRect.unite(rect);
2015     }
2016     repaintRectangle(repaintRect);
2017 }
2018 
2019 void RenderElement::updateOutlineAutoAncestor(bool hasOutlineAuto)
2020 {
2021     for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(*this)) {
2022         if (hasOutlineAuto == child.hasOutlineAutoAncestor())
2023             continue;
2024         child.setHasOutlineAutoAncestor(hasOutlineAuto);
2025         bool childHasOutlineAuto = child.outlineStyleForRepaint().outlineStyleIsAuto() == OutlineIsAuto::On;
2026         if (childHasOutlineAuto)
2027             continue;
2028         if (!is&lt;RenderElement&gt;(child))
2029             continue;
2030         downcast&lt;RenderElement&gt;(child).updateOutlineAutoAncestor(hasOutlineAuto);
2031     }
2032     if (is&lt;RenderBoxModelObject&gt;(*this)) {
2033         if (auto* continuation = downcast&lt;RenderBoxModelObject&gt;(*this).continuation())
2034             continuation-&gt;updateOutlineAutoAncestor(hasOutlineAuto);
2035     }
2036 }
2037 
2038 bool RenderElement::hasOutlineAnnotation() const
2039 {
<a name="12" id="anc12"></a><span class="line-modified">2040     return element() &amp;&amp; element()-&gt;isLink() &amp;&amp; (document().printing() || (view().frameView().paintBehavior() &amp; PaintBehavior::AnnotateLinks));</span>
2041 }
2042 
2043 bool RenderElement::hasSelfPaintingLayer() const
2044 {
2045     if (!hasLayer())
2046         return false;
2047     auto&amp; layerModelObject = downcast&lt;RenderLayerModelObject&gt;(*this);
2048     return layerModelObject.hasSelfPaintingLayer();
2049 }
2050 
2051 bool RenderElement::checkForRepaintDuringLayout() const
2052 {
2053     if (document().view()-&gt;layoutContext().needsFullRepaint() || !everHadLayout() || hasSelfPaintingLayer())
2054         return false;
2055     return !settings().repaintOutsideLayoutEnabled();
2056 }
2057 
2058 ImageOrientation RenderElement::imageOrientation() const
2059 {
<a name="13" id="anc13"></a>








2060     return style().imageOrientation();
2061 }
2062 
2063 void RenderElement::adjustFragmentedFlowStateOnContainingBlockChangeIfNeeded()
2064 {
2065     if (fragmentedFlowState() == NotInsideFragmentedFlow)
2066         return;
2067 
2068     // Invalidate the containing block caches.
2069     if (is&lt;RenderBlock&gt;(*this))
2070         downcast&lt;RenderBlock&gt;(*this).resetEnclosingFragmentedFlowAndChildInfoIncludingDescendants();
2071 
2072     // Adjust the flow tread state on the subtree.
2073     setFragmentedFlowState(RenderObject::computedFragmentedFlowState(*this));
2074     for (auto&amp; descendant : descendantsOfType&lt;RenderObject&gt;(*this))
2075         descendant.setFragmentedFlowState(RenderObject::computedFragmentedFlowState(descendant));
2076 }
2077 
2078 void RenderElement::removeFromRenderFragmentedFlow()
2079 {
2080     ASSERT(fragmentedFlowState() != NotInsideFragmentedFlow);
2081     // Sometimes we remove the element from the flow, but it&#39;s not destroyed at that time.
2082     // It&#39;s only until later when we actually destroy it and remove all the children from it.
2083     // Currently, that happens for firstLetter elements and list markers.
2084     // Pass in the flow thread so that we don&#39;t have to look it up for all the children.
2085     removeFromRenderFragmentedFlowIncludingDescendants(true);
2086 }
2087 
2088 void RenderElement::removeFromRenderFragmentedFlowIncludingDescendants(bool shouldUpdateState)
2089 {
2090     // Once we reach another flow thread we don&#39;t need to update the flow thread state
2091     // but we have to continue cleanup the flow thread info.
2092     if (isRenderFragmentedFlow())
2093         shouldUpdateState = false;
2094 
2095     for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(*this)) {
2096         if (is&lt;RenderElement&gt;(child)) {
2097             downcast&lt;RenderElement&gt;(child).removeFromRenderFragmentedFlowIncludingDescendants(shouldUpdateState);
2098             continue;
2099         }
2100         if (shouldUpdateState)
2101             child.setFragmentedFlowState(NotInsideFragmentedFlow);
2102     }
2103 
2104     // We have to ask for our containing flow thread as it may be above the removed sub-tree.
2105     RenderFragmentedFlow* enclosingFragmentedFlow = this-&gt;enclosingFragmentedFlow();
2106     while (enclosingFragmentedFlow) {
2107         enclosingFragmentedFlow-&gt;removeFlowChildInfo(*this);
2108 
2109         if (enclosingFragmentedFlow-&gt;fragmentedFlowState() == NotInsideFragmentedFlow)
2110             break;
2111         auto* parent = enclosingFragmentedFlow-&gt;parent();
2112         if (!parent)
2113             break;
2114         enclosingFragmentedFlow = parent-&gt;enclosingFragmentedFlow();
2115     }
2116     if (is&lt;RenderBlock&gt;(*this))
2117         downcast&lt;RenderBlock&gt;(*this).setCachedEnclosingFragmentedFlowNeedsUpdate();
2118 
2119     if (shouldUpdateState)
2120         setFragmentedFlowState(NotInsideFragmentedFlow);
2121 }
2122 
2123 void RenderElement::resetEnclosingFragmentedFlowAndChildInfoIncludingDescendants(RenderFragmentedFlow* fragmentedFlow)
2124 {
2125     if (fragmentedFlow)
2126         fragmentedFlow-&gt;removeFlowChildInfo(*this);
2127 
2128     for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(*this))
2129         child.resetEnclosingFragmentedFlowAndChildInfoIncludingDescendants(fragmentedFlow);
2130 }
2131 
2132 #if ENABLE(TEXT_AUTOSIZING)
2133 static RenderObject::BlockContentHeightType includeNonFixedHeight(const RenderObject&amp; renderer)
2134 {
2135     const RenderStyle&amp; style = renderer.style();
2136     if (style.height().type() == Fixed) {
2137         if (is&lt;RenderBlock&gt;(renderer)) {
2138             // For fixed height styles, if the overflow size of the element spills out of the specified
2139             // height, assume we can apply text auto-sizing.
2140             if (style.overflowY() == Overflow::Visible
2141                 &amp;&amp; style.height().value() &lt; downcast&lt;RenderBlock&gt;(renderer).layoutOverflowRect().maxY())
2142                 return RenderObject::OverflowHeight;
2143         }
2144         return RenderObject::FixedHeight;
2145     }
2146     return RenderObject::FlexibleHeight;
2147 }
2148 
2149 void RenderElement::adjustComputedFontSizesOnBlocks(float size, float visibleWidth)
2150 {
2151     Document* document = view().frameView().frame().document();
2152     if (!document)
2153         return;
2154 
2155     Vector&lt;int&gt; depthStack;
2156     int currentDepth = 0;
2157     int newFixedDepth = 0;
2158 
2159     // We don&#39;t apply autosizing to nodes with fixed height normally.
2160     // But we apply it to nodes which are located deep enough
2161     // (nesting depth is greater than some const) inside of a parent block
2162     // which has fixed height but its content overflows intentionally.
2163     for (RenderObject* descendent = traverseNext(this, includeNonFixedHeight, currentDepth, newFixedDepth); descendent; descendent = descendent-&gt;traverseNext(this, includeNonFixedHeight, currentDepth, newFixedDepth)) {
2164         while (depthStack.size() &gt; 0 &amp;&amp; currentDepth &lt;= depthStack[depthStack.size() - 1])
2165             depthStack.remove(depthStack.size() - 1);
2166         if (newFixedDepth)
2167             depthStack.append(newFixedDepth);
2168 
2169         int stackSize = depthStack.size();
2170         if (is&lt;RenderBlockFlow&gt;(*descendent) &amp;&amp; !descendent-&gt;isListItem() &amp;&amp; (!stackSize || currentDepth - depthStack[stackSize - 1] &gt; TextAutoSizingFixedHeightDepth))
2171             downcast&lt;RenderBlockFlow&gt;(*descendent).adjustComputedFontSizes(size, visibleWidth);
2172         newFixedDepth = 0;
2173     }
2174 
2175     // Remove style from auto-sizing table that are no longer valid.
2176     document-&gt;textAutoSizing().updateRenderTree();
2177 }
2178 
2179 void RenderElement::resetTextAutosizing()
2180 {
2181     Document* document = view().frameView().frame().document();
2182     if (!document)
2183         return;
2184 
2185     LOG(TextAutosizing, &quot;RenderElement::resetTextAutosizing()&quot;);
2186 
2187     document-&gt;textAutoSizing().reset();
2188 
2189     Vector&lt;int&gt; depthStack;
2190     int currentDepth = 0;
2191     int newFixedDepth = 0;
2192 
2193     for (RenderObject* descendent = traverseNext(this, includeNonFixedHeight, currentDepth, newFixedDepth); descendent; descendent = descendent-&gt;traverseNext(this, includeNonFixedHeight, currentDepth, newFixedDepth)) {
2194         while (depthStack.size() &gt; 0 &amp;&amp; currentDepth &lt;= depthStack[depthStack.size() - 1])
2195             depthStack.remove(depthStack.size() - 1);
2196         if (newFixedDepth)
2197             depthStack.append(newFixedDepth);
2198 
2199         int stackSize = depthStack.size();
2200         if (is&lt;RenderBlockFlow&gt;(*descendent) &amp;&amp; !descendent-&gt;isListItem() &amp;&amp; (!stackSize || currentDepth - depthStack[stackSize - 1] &gt; TextAutoSizingFixedHeightDepth))
2201             downcast&lt;RenderBlockFlow&gt;(*descendent).resetComputedFontSize();
2202         newFixedDepth = 0;
2203     }
2204 }
2205 #endif // ENABLE(TEXT_AUTOSIZING)
2206 
2207 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOutput.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOutput.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOutput.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOutput.h
@@ -37,10 +37,11 @@
 #include "B3SwitchValue.h"
 #include "B3Width.h"
 #include "FTLAbbreviatedTypes.h"
 #include "FTLAbstractHeapRepository.h"
 #include "FTLCommonValues.h"
+#include "FTLSelectPredictability.h"
 #include "FTLState.h"
 #include "FTLSwitchCase.h"
 #include "FTLTypedPointer.h"
 #include "FTLValueFromBlock.h"
 #include "FTLWeight.h"
@@ -102,18 +103,18 @@
     B3::SlotBaseValue* lockedStackSlot(size_t bytes);
 
     LValue constBool(bool value);
     LValue constInt32(int32_t value);
 
-    LValue weakPointer(DFG::Graph& graph, JSCell* cell)
+    LValue alreadyRegisteredWeakPointer(DFG::Graph& graph, JSCell* cell)
     {
         ASSERT(graph.m_plan.weakReferences().contains(cell));
 
         return constIntPtr(bitwise_cast<intptr_t>(cell));
     }
 
-    LValue weakPointer(DFG::FrozenValue* value)
+    LValue alreadyRegisteredFrozenPointer(DFG::FrozenValue* value)
     {
         RELEASE_ASSERT(value->value().isCell());
 
         return constIntPtr(bitwise_cast<intptr_t>(value->cell()));
     }
@@ -186,10 +187,11 @@
     LValue doubleSqrt(LValue);
 
     LValue doubleLog(LValue);
 
     LValue doubleToInt(LValue);
+    LValue doubleToInt64(LValue);
     LValue doubleToUInt(LValue);
 
     LValue signExt32To64(LValue);
     LValue signExt32ToPtr(LValue);
     LValue zeroExt(LValue, LType);
@@ -362,11 +364,11 @@
     LValue testIsZero64(LValue value, LValue mask) { return isZero64(bitAnd(value, mask)); }
     LValue testNonZero64(LValue value, LValue mask) { return notZero64(bitAnd(value, mask)); }
     LValue testIsZeroPtr(LValue value, LValue mask) { return isNull(bitAnd(value, mask)); }
     LValue testNonZeroPtr(LValue value, LValue mask) { return notNull(bitAnd(value, mask)); }
 
-    LValue select(LValue value, LValue taken, LValue notTaken);
+    LValue select(LValue value, LValue taken, LValue notTaken, SelectPredictability = SelectPredictability::NotPredictable);
 
     // These are relaxed atomics by default. Use AbstractHeapRepository::decorateFencedAccess() with a
     // non-null heap to make them seq_cst fenced.
     LValue atomicXchgAdd(LValue operand, TypedPointer pointer, B3::Width);
     LValue atomicXchgAnd(LValue operand, TypedPointer pointer, B3::Width);
@@ -389,10 +391,11 @@
     LValue call(LType type, LValue function, LValue arg1, Args... args) { return m_block->appendNew<B3::CCallValue>(m_proc, type, origin(), function, arg1, args...); }
 
     template<typename Function, typename... Args>
     LValue callWithoutSideEffects(B3::Type type, Function function, LValue arg1, Args... args)
     {
+        static_assert(!std::is_same<Function, LValue>::value);
         return m_block->appendNew<B3::CCallValue>(m_proc, type, origin(), B3::Effects::none(),
             constIntPtr(tagCFunctionPtr<void*>(function, B3CCallPtrTag)), arg1, args...);
     }
 
     // FIXME: Consider enhancing this to allow the client to choose the target PtrTag to use.

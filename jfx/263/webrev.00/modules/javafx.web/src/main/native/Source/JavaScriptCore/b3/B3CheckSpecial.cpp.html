<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3CheckSpecial.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;B3CheckSpecial.h&quot;
 28 
 29 #if ENABLE(B3_JIT)
 30 
 31 #include &quot;AirCode.h&quot;
 32 #include &quot;AirGenerationContext.h&quot;
 33 #include &quot;AirInstInlines.h&quot;
 34 #include &quot;B3StackmapGenerationParams.h&quot;
 35 #include &quot;B3ValueInlines.h&quot;
 36 #include &quot;CCallHelpers.h&quot;
 37 
 38 namespace JSC { namespace B3 {
 39 
 40 using Inst = Air::Inst;
 41 using Arg = Air::Arg;
 42 using GenerationContext = Air::GenerationContext;
 43 
 44 namespace {
 45 
 46 unsigned numB3Args(Kind kind)
 47 {
 48     switch (kind.opcode()) {
 49     case CheckAdd:
 50     case CheckSub:
 51     case CheckMul:
 52         return 2;
 53     case Check:
 54         return 1;
 55     default:
 56         RELEASE_ASSERT_NOT_REACHED();
 57         return 0;
 58     }
 59 }
 60 
 61 unsigned numB3Args(Value* value)
 62 {
 63     return numB3Args(value-&gt;kind());
 64 }
 65 
 66 unsigned numB3Args(Inst&amp; inst)
 67 {
 68     return numB3Args(inst.origin);
 69 }
 70 
 71 } // anonymous namespace
 72 
 73 CheckSpecial::Key::Key(const Inst&amp; inst)
 74 {
 75     m_kind = inst.kind;
 76     m_numArgs = inst.args.size();
 77     m_stackmapRole = SameAsRep;
 78 }
 79 
 80 void CheckSpecial::Key::dump(PrintStream&amp; out) const
 81 {
 82     out.print(m_kind, &quot;(&quot;, m_numArgs, &quot;,&quot;, m_stackmapRole, &quot;)&quot;);
 83 }
 84 
 85 CheckSpecial::CheckSpecial(Air::Kind kind, unsigned numArgs, RoleMode stackmapRole)
 86     : m_checkKind(kind)
 87     , m_stackmapRole(stackmapRole)
 88     , m_numCheckArgs(numArgs)
 89 {
 90     ASSERT(isDefinitelyTerminal(kind.opcode));
 91 }
 92 
 93 CheckSpecial::CheckSpecial(const CheckSpecial::Key&amp; key)
 94     : CheckSpecial(key.kind(), key.numArgs(), key.stackmapRole())
 95 {
 96 }
 97 
 98 CheckSpecial::~CheckSpecial()
 99 {
100 }
101 
102 Inst CheckSpecial::hiddenBranch(const Inst&amp; inst) const
103 {
104     Inst hiddenBranch(m_checkKind, inst.origin);
105     hiddenBranch.args.reserveInitialCapacity(m_numCheckArgs);
106     for (unsigned i = 0; i &lt; m_numCheckArgs; ++i)
107         hiddenBranch.args.append(inst.args[i + 1]);
108     ASSERT(hiddenBranch.isTerminal());
109     return hiddenBranch;
110 }
111 
112 void CheckSpecial::forEachArg(Inst&amp; inst, const ScopedLambda&lt;Inst::EachArgCallback&gt;&amp; callback)
113 {
114     using namespace Air;
115     Optional&lt;Width&gt; optionalDefArgWidth;
116     Inst hidden = hiddenBranch(inst);
117     hidden.forEachArg(
118         [&amp;] (Arg&amp; arg, Arg::Role role, Bank bank, Width width) {
119             if (Arg::isAnyDef(role) &amp;&amp; role != Arg::Scratch) {
120                 ASSERT(!optionalDefArgWidth); // There can only be one Def&#39;ed arg.
121                 optionalDefArgWidth = width;
122             }
123             unsigned index = &amp;arg - &amp;hidden.args[0];
124             callback(inst.args[1 + index], role, bank, width);
125         });
126 
127     Optional&lt;unsigned&gt; firstRecoverableIndex;
128     if (m_checkKind.opcode == BranchAdd32 || m_checkKind.opcode == BranchAdd64)
129         firstRecoverableIndex = 1;
130     forEachArgImpl(numB3Args(inst), m_numCheckArgs + 1, inst, m_stackmapRole, firstRecoverableIndex, callback, optionalDefArgWidth);
131 }
132 
133 bool CheckSpecial::isValid(Inst&amp; inst)
134 {
135     return hiddenBranch(inst).isValidForm()
136         &amp;&amp; isValidImpl(numB3Args(inst), m_numCheckArgs + 1, inst)
137         &amp;&amp; inst.args.size() - m_numCheckArgs - 1 == inst.origin-&gt;numChildren() - numB3Args(inst);
138 }
139 
140 bool CheckSpecial::admitsStack(Inst&amp; inst, unsigned argIndex)
141 {
142     if (argIndex &gt;= 1 &amp;&amp; argIndex &lt; 1 + m_numCheckArgs)
143         return hiddenBranch(inst).admitsStack(argIndex - 1);
144     return admitsStackImpl(numB3Args(inst), m_numCheckArgs + 1, inst, argIndex);
145 }
146 
147 bool CheckSpecial::admitsExtendedOffsetAddr(Inst&amp; inst, unsigned argIndex)
148 {
149     if (argIndex &gt;= 1 &amp;&amp; argIndex &lt; 1 + m_numCheckArgs)
150         return false;
151     return admitsStack(inst, argIndex);
152 }
153 
154 Optional&lt;unsigned&gt; CheckSpecial::shouldTryAliasingDef(Inst&amp; inst)
155 {
156     if (Optional&lt;unsigned&gt; branchDef = hiddenBranch(inst).shouldTryAliasingDef())
157         return *branchDef + 1;
158     return WTF::nullopt;
159 }
160 
161 CCallHelpers::Jump CheckSpecial::generate(Inst&amp; inst, CCallHelpers&amp; jit, GenerationContext&amp; context)
162 {
163     using namespace Air;
164     CCallHelpers::Jump fail = hiddenBranch(inst).generate(jit, context);
165     ASSERT(fail.isSet());
166 
167     StackmapValue* value = inst.origin-&gt;as&lt;StackmapValue&gt;();
168     ASSERT(value);
169 
170     Vector&lt;ValueRep&gt; reps = repsImpl(context, numB3Args(inst), m_numCheckArgs + 1, inst);
171 
172     // Set aside the args that are relevant to undoing the operation. This is because we don&#39;t want to
173     // capture all of inst in the closure below.
174     Vector&lt;Arg, 3&gt; args;
175     for (unsigned i = 0; i &lt; m_numCheckArgs; ++i)
176         args.append(inst.args[1 + i]);
177 
178     context.latePaths.append(
179         createSharedTask&lt;GenerationContext::LatePathFunction&gt;(
180             [=] (CCallHelpers&amp; jit, GenerationContext&amp; context) {
181                 fail.link(&amp;jit);
182 
183                 // If necessary, undo the operation.
184                 switch (m_checkKind.opcode) {
185                 case BranchAdd32:
186                     if ((m_numCheckArgs == 4 &amp;&amp; args[1] == args[2] &amp;&amp; args[2] == args[3])
187                         || (m_numCheckArgs == 3 &amp;&amp; args[1] == args[2])) {
188                         // This is ugly, but that&#39;s fine - we won&#39;t have to do this very often.
189                         ASSERT(args[1].isGPR());
190                         GPRReg valueGPR = args[1].gpr();
191                         GPRReg scratchGPR = CCallHelpers::selectScratchGPR(valueGPR);
192                         jit.pushToSave(scratchGPR);
193                         jit.setCarry(scratchGPR);
194                         jit.lshift32(CCallHelpers::TrustedImm32(31), scratchGPR);
195                         jit.urshift32(CCallHelpers::TrustedImm32(1), valueGPR);
196                         jit.or32(scratchGPR, valueGPR);
197                         jit.popToRestore(scratchGPR);
198                         break;
199                     }
200                     if (m_numCheckArgs == 4) {
201                         if (args[1] == args[3])
202                             Inst(Sub32, nullptr, args[2], args[3]).generate(jit, context);
203                         else if (args[2] == args[3])
204                             Inst(Sub32, nullptr, args[1], args[3]).generate(jit, context);
205                     } else if (m_numCheckArgs == 3)
206                         Inst(Sub32, nullptr, args[1], args[2]).generate(jit, context);
207                     break;
208                 case BranchAdd64:
209                     if ((m_numCheckArgs == 4 &amp;&amp; args[1] == args[2] &amp;&amp; args[2] == args[3])
210                         || (m_numCheckArgs == 3 &amp;&amp; args[1] == args[2])) {
211                         // This is ugly, but that&#39;s fine - we won&#39;t have to do this very often.
212                         ASSERT(args[1].isGPR());
213                         GPRReg valueGPR = args[1].gpr();
214                         GPRReg scratchGPR = CCallHelpers::selectScratchGPR(valueGPR);
215                         jit.pushToSave(scratchGPR);
216                         jit.setCarry(scratchGPR);
217                         jit.lshift64(CCallHelpers::TrustedImm32(63), scratchGPR);
218                         jit.urshift64(CCallHelpers::TrustedImm32(1), valueGPR);
219                         jit.or64(scratchGPR, valueGPR);
220                         jit.popToRestore(scratchGPR);
221                         break;
222                     }
223                     if (m_numCheckArgs == 4) {
224                         if (args[1] == args[3])
225                             Inst(Sub64, nullptr, args[2], args[3]).generate(jit, context);
226                         else if (args[2] == args[3])
227                             Inst(Sub64, nullptr, args[1], args[3]).generate(jit, context);
228                     } else if (m_numCheckArgs == 3)
229                         Inst(Sub64, nullptr, args[1], args[2]).generate(jit, context);
230                     break;
231                 case BranchSub32:
232                     Inst(Add32, nullptr, args[1], args[2]).generate(jit, context);
233                     break;
234                 case BranchSub64:
235                     Inst(Add64, nullptr, args[1], args[2]).generate(jit, context);
236                     break;
237                 case BranchNeg32:
238                     Inst(Neg32, nullptr, args[1]).generate(jit, context);
239                     break;
240                 case BranchNeg64:
241                     Inst(Neg64, nullptr, args[1]).generate(jit, context);
242                     break;
243                 default:
244                     break;
245                 }
246 
247                 value-&gt;m_generator-&gt;run(jit, StackmapGenerationParams(value, reps, context));
248             }));
249 
250     return CCallHelpers::Jump(); // As far as Air thinks, we are not a terminal.
251 }
252 
253 void CheckSpecial::dumpImpl(PrintStream&amp; out) const
254 {
255     out.print(m_checkKind, &quot;(&quot;, m_numCheckArgs, &quot;,&quot;, m_stackmapRole, &quot;)&quot;);
256 }
257 
258 void CheckSpecial::deepDumpImpl(PrintStream&amp; out) const
259 {
260     out.print(&quot;B3::CheckValue lowered to &quot;, m_checkKind, &quot; with &quot;, m_numCheckArgs, &quot; args.&quot;);
261 }
262 
263 } } // namespace JSC::B3
264 
265 #endif // ENABLE(B3_JIT)
    </pre>
  </body>
</html>
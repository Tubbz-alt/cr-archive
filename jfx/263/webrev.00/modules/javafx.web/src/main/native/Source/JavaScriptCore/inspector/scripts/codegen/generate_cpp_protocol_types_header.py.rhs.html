<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/scripts/codegen/generate_cpp_protocol_types_header.py</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 #!/usr/bin/env python
  2 #
  3 # Copyright (c) 2014-2018 Apple Inc. All rights reserved.
  4 # Copyright (c) 2014 University of Washington. All rights reserved.
  5 #
  6 # Redistribution and use in source and binary forms, with or without
  7 # modification, are permitted provided that the following conditions
  8 # are met:
  9 # 1. Redistributions of source code must retain the above copyright
 10 #    notice, this list of conditions and the following disclaimer.
 11 # 2. Redistributions in binary form must reproduce the above copyright
 12 #    notice, this list of conditions and the following disclaimer in the
 13 #    documentation and/or other materials provided with the distribution.
 14 #
 15 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 16 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 17 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 19 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 20 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 21 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 22 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 23 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 24 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 25 # THE POSSIBILITY OF SUCH DAMAGE.
 26 
 27 
 28 import logging
 29 import re
 30 import string
 31 from operator import methodcaller
 32 from string import Template
 33 
 34 try:
 35     from .cpp_generator import CppGenerator
 36     from .cpp_generator_templates import CppGeneratorTemplates as CppTemplates
 37     from .generator import Generator, ucfirst
 38     from .models import EnumType, ObjectType, PrimitiveType, AliasedType, ArrayType, Frameworks
 39 except ValueError:
 40     from cpp_generator import CppGenerator
 41     from cpp_generator_templates import CppGeneratorTemplates as CppTemplates
 42     from generator import Generator, ucfirst
 43     from models import EnumType, ObjectType, PrimitiveType, AliasedType, ArrayType, Frameworks
 44 
 45 log = logging.getLogger(&#39;global&#39;)
 46 
 47 
 48 class CppProtocolTypesHeaderGenerator(CppGenerator):
 49     def __init__(self, *args, **kwargs):
 50         CppGenerator.__init__(self, *args, **kwargs)
 51 
 52     def output_filename(self):
 53         return &quot;%sProtocolObjects.h&quot; % self.protocol_name()
 54 
 55     def generate_output(self):
 56         domains = self.domains_to_generate()
 57         self.calculate_types_requiring_shape_assertions(domains)
 58 
 59         header_args = {
 60             &#39;includes&#39;: self._generate_secondary_header_includes(),
 61             &#39;typedefs&#39;: &#39;&#39;,
 62         }
 63 
 64         sections = []
 65         sections.append(self.generate_license())
 66         sections.append(Template(CppTemplates.HeaderPrelude).substitute(None, **header_args))
 67         sections.append(&#39;namespace Protocol {&#39;)
 68         sections.append(self._generate_versions(domains))
 69         sections.append(self._generate_forward_declarations(domains))
 70         sections.append(self._generate_typedefs(domains))
 71         sections.extend(self._generate_enum_constant_value_conversion_methods())
 72         builder_sections = list(map(self._generate_builders_for_domain, domains))
 73         sections.extend([section for section in builder_sections if len(section) &gt; 0])
 74         sections.append(self._generate_forward_declarations_for_binding_traits(domains))
 75         sections.extend(self._generate_declarations_for_enum_conversion_methods(domains))
 76         sections.append(&#39;} // namespace Protocol&#39;)
 77         sections.append(Template(CppTemplates.HeaderPostlude).substitute(None, **header_args))
 78         sections.extend(self._generate_hash_declarations(domains))
 79         return &quot;\n\n&quot;.join(sections)
 80 
 81     # Private methods.
 82 
 83     # FIXME: move builders out of classes, uncomment forward declaration
 84 
 85     def _generate_secondary_header_includes(self):
 86         header_includes = [
 87             ([&quot;JavaScriptCore&quot;, &quot;WebKit&quot;], (&quot;JavaScriptCore&quot;, &quot;inspector/InspectorProtocolTypes.h&quot;)),
 88             ([&quot;JavaScriptCore&quot;, &quot;WebKit&quot;], (&quot;WTF&quot;, &quot;wtf/Assertions.h&quot;))
 89         ]
 90 
 91         return &#39;\n&#39;.join(self.generate_includes_from_entries(header_includes))
 92 
 93     def _generate_versions(self, domains):
 94         sections = []
 95 
 96         for domain in domains:
 97             version = self.version_for_domain(domain)
 98             if not version:
 99                 continue
100 
101             domain_lines = []
102             domain_lines.append(&#39;namespace %s {&#39; % domain.domain_name)
103 
104             if isinstance(version, int):
<a name="1" id="anc1"></a><span class="line-modified">105                 domain_lines.append(&#39;static constexpr unsigned VERSION = %s;&#39; % version)</span>
106 
107             domain_lines.append(&#39;} // %s&#39; % domain.domain_name)
108             sections.append(self.wrap_with_guard_for_domain(domain, &#39;\n&#39;.join(domain_lines)))
109 
110         if len(sections) == 0:
111             return &#39;&#39;
112 
113         return &quot;&quot;&quot;// Versions.
114 %s
115 // End of versions.
116 &quot;&quot;&quot; % &#39;\n\n&#39;.join(sections)
117 
118     def _generate_forward_declarations(self, domains):
119         sections = []
120 
121         for domain in domains:
122             declaration_types = [decl.type for decl in self.type_declarations_for_domain(domain)]
123             object_types = [_type for _type in declaration_types if isinstance(_type, ObjectType)]
124             enum_types = [_type for _type in declaration_types if isinstance(_type, EnumType)]
125             sorted(object_types, key=methodcaller(&#39;raw_name&#39;))
126             sorted(enum_types, key=methodcaller(&#39;raw_name&#39;))
127 
128             if len(object_types) + len(enum_types) == 0:
129                 continue
130 
131             domain_lines = []
132             domain_lines.append(&#39;namespace %s {&#39; % domain.domain_name)
133 
134             # Forward-declare all classes so the type builders won&#39;t break if rearranged.
135             domain_lines.extend(&#39;class %s;&#39; % object_type.raw_name() for object_type in object_types)
136             domain_lines.extend(&#39;enum class %s;&#39; % enum_type.raw_name() for enum_type in enum_types)
137             domain_lines.append(&#39;} // %s&#39; % domain.domain_name)
138             sections.append(self.wrap_with_guard_for_domain(domain, &#39;\n&#39;.join(domain_lines)))
139 
140         if len(sections) == 0:
141             return &#39;&#39;
142         else:
143             return &quot;&quot;&quot;// Forward declarations.
144 %s
145 // End of forward declarations.
146 &quot;&quot;&quot; % &#39;\n\n&#39;.join(sections)
147 
148     def _generate_typedefs(self, domains):
149         sections = list(map(self._generate_typedefs_for_domain, domains))
150         sections = [text for text in sections if len(text) &gt; 0]
151 
152         if len(sections) == 0:
153             return &#39;&#39;
154         else:
155             return &quot;&quot;&quot;// Typedefs.
156 %s
157 // End of typedefs.&quot;&quot;&quot; % &#39;\n\n&#39;.join(sections)
158 
159     def _generate_typedefs_for_domain(self, domain):
160         type_declarations = self.type_declarations_for_domain(domain)
161         primitive_declarations = [decl for decl in type_declarations if isinstance(decl.type, AliasedType)]
162         array_declarations = [decl for decl in type_declarations if isinstance(decl.type, ArrayType)]
163         if len(primitive_declarations) == 0 and len(array_declarations) == 0:
164             return &#39;&#39;
165 
166         sections = []
167         for declaration in primitive_declarations:
168             primitive_name = CppGenerator.cpp_name_for_primitive_type(declaration.type.aliased_type)
169             typedef_lines = []
170             if len(declaration.description) &gt; 0:
171                 typedef_lines.append(&#39;/* %s */&#39; % declaration.description)
172             typedef_lines.append(&#39;typedef %s %s;&#39; % (primitive_name, declaration.type_name))
173             sections.append(&#39;\n&#39;.join(typedef_lines))
174 
175         for declaration in array_declarations:
176             element_type = CppGenerator.cpp_protocol_type_for_type(declaration.type.element_type)
177             typedef_lines = []
178             if len(declaration.description) &gt; 0:
179                 typedef_lines.append(&#39;/* %s */&#39; % declaration.description)
180             typedef_lines.append(&#39;typedef JSON::ArrayOf&lt;%s&gt; %s;&#39; % (element_type, declaration.type_name))
181             sections.append(&#39;\n&#39;.join(typedef_lines))
182 
183         lines = []
184         lines.append(&#39;namespace %s {&#39; % domain.domain_name)
185         lines.append(&#39;\n&#39;.join(sections))
186         lines.append(&#39;} // %s&#39; % domain.domain_name)
187         return self.wrap_with_guard_for_domain(domain, &#39;\n&#39;.join(lines))
188 
189     def _generate_enum_constant_value_conversion_methods(self):
190         if not self.assigned_enum_values():
191             return []
192 
193         return_type = &#39;String&#39;
194         return_type_with_export_macro = [return_type]
195         export_macro = self.model().framework.setting(&#39;export_macro&#39;, None)
196         if export_macro is not None:
197             return_type_with_export_macro[:0] = [export_macro]
198 
199         lines = []
200         lines.append(&#39;namespace %s {&#39; % self.helpers_namespace())
201         lines.append(&#39;\n&#39;.join([
202             &#39;%s getEnumConstantValue(int code);&#39; % &#39; &#39;.join(return_type_with_export_macro),
203             &#39;&#39;,
204             &#39;template&lt;typename T&gt; %s getEnumConstantValue(T enumValue)&#39; % return_type,
205             &#39;{&#39;,
206             &#39;    return getEnumConstantValue(static_cast&lt;int&gt;(enumValue));&#39;,
207             &#39;}&#39;,
208         ]))
209         lines.append(&#39;} // namespace %s&#39; % self.helpers_namespace())
210         return lines
211 
212     def _generate_builders_for_domain(self, domain):
213         sections = []
214 
215         type_declarations = self.type_declarations_for_domain(domain)
216         for type_declaration in type_declarations:
217             if isinstance(type_declaration.type, EnumType):
218                 sections.append(self._generate_struct_for_enum_declaration(type_declaration))
219             elif isinstance(type_declaration.type, ObjectType):
220                 sections.append(self._generate_class_for_object_declaration(type_declaration, domain))
221 
222         sections = [section for section in sections if len(section) &gt; 0]
223         if len(sections) == 0:
224             return &#39;&#39;
225 
226         lines = []
227         lines.append(&#39;namespace %s {&#39; % domain.domain_name)
228         lines.append(&#39;\n&#39;.join(sections))
229         lines.append(&#39;} // %s&#39; % domain.domain_name)
230         return self.wrap_with_guard_for_domain(domain, &#39;\n&#39;.join(lines))
231 
232     def _generate_class_for_object_declaration(self, type_declaration, domain):
233         if len(type_declaration.type_members) == 0:
234             return &#39;&#39;
235 
236         enum_members = [member for member in type_declaration.type_members if isinstance(member.type, EnumType) and member.type.is_anonymous]
237         required_members = [member for member in type_declaration.type_members if not member.is_optional]
238         optional_members = [member for member in type_declaration.type_members if member.is_optional]
239         object_name = type_declaration.type_name
240 
241         lines = []
242         if len(type_declaration.description) &gt; 0:
243             lines.append(&#39;/* %s */&#39; % type_declaration.description)
244         base_class = &#39;JSON::Object&#39;
245         if not Generator.type_has_open_fields(type_declaration.type):
246             base_class = base_class + &#39;Base&#39;
247         lines.append(&#39;class %s : public %s {&#39; % (object_name, base_class))
248         lines.append(&#39;public:&#39;)
249         for enum_member in enum_members:
250             lines.append(&#39;    // Named after property name \&#39;%s\&#39; while generating %s.&#39; % (enum_member.member_name, object_name))
251             lines.append(self._generate_struct_for_anonymous_enum_member(enum_member))
252         lines.append(self._generate_builder_state_enum(type_declaration))
253 
254         constructor_example = []
255         constructor_example.append(&#39;     * Ref&lt;%s&gt; result = %s::create()&#39; % (object_name, object_name))
256         for member in required_members:
257             constructor_example.append(&#39;     *     .set%s(...)&#39; % ucfirst(member.member_name))
258         constructor_example.append(&#39;     *     .release()&#39;)
259 
260         builder_args = {
261             &#39;objectType&#39;: object_name,
262             &#39;constructorExample&#39;: &#39;\n&#39;.join(constructor_example) + &#39;;&#39;,
263         }
264 
265         lines.append(Template(CppTemplates.ProtocolObjectBuilderDeclarationPrelude).substitute(None, **builder_args))
266         for type_member in required_members:
267             lines.append(self._generate_builder_setter_for_member(type_member, domain))
268         lines.append(Template(CppTemplates.ProtocolObjectBuilderDeclarationPostlude).substitute(None, **builder_args))
269         for member in optional_members:
270             lines.append(self._generate_unchecked_setter_for_member(member, domain))
271 
272         if Generator.type_has_open_fields(type_declaration.type):
273             lines.append(&#39;&#39;)
274             lines.append(&#39;    // Property names for type generated as open.&#39;)
275             open_members = Generator.open_fields(type_declaration)
276             for type_member in open_members:
277                 export_macro = self.model().framework.setting(&#39;export_macro&#39;, None)
278                 lines.append(&#39;    %s static const char* %s;&#39; % (export_macro, ucfirst(type_member.member_name)))
279 
280         lines.append(&#39;};&#39;)
281         lines.append(&#39;&#39;)
282         return &#39;\n&#39;.join(lines)
283 
284     def _generate_struct_for_enum_declaration(self, enum_declaration):
285         lines = []
286         lines.append(&#39;/* %s */&#39; % enum_declaration.description)
287         lines.extend(self._generate_struct_for_enum_type(enum_declaration.type_name, enum_declaration.type))
288         return &#39;\n&#39;.join(lines)
289 
290     def _generate_struct_for_anonymous_enum_member(self, enum_member):
291         def apply_indentation(line):
292             if line.startswith((&#39;#&#39;, &#39;/*&#39;, &#39;*/&#39;, &#39;//&#39;)) or len(line) is 0:
293                 return line
294             else:
295                 return &#39;    &#39; + line
296 
297         indented_lines = list(map(apply_indentation, self._generate_struct_for_enum_type(enum_member.member_name, enum_member.type)))
298         return &#39;\n&#39;.join(indented_lines)
299 
300     def _generate_struct_for_enum_type(self, enum_name, enum_type):
301         lines = []
302         enum_name = ucfirst(enum_name)
303         lines.append(&#39;enum class %s {&#39; % enum_name)
304         for enum_value in enum_type.enum_values():
305             lines.append(&#39;    %s = %s,&#39; % (Generator.stylized_name_for_enum_value(enum_value), self.encoding_for_enum_value(enum_value)))
306         lines.append(&#39;}; // enum class %s&#39; % enum_name)
307         return lines  # The caller may want to adjust indentation, so don&#39;t join these lines.
308 
309     def _generate_builder_state_enum(self, type_declaration):
310         lines = []
311         required_members = [member for member in type_declaration.type_members if not member.is_optional]
312         enum_values = []
313 
314         lines.append(&#39;    enum {&#39;)
315         lines.append(&#39;        NoFieldsSet = 0,&#39;)
316         for i in range(len(required_members)):
317             enum_value = &quot;%sSet&quot; % ucfirst(required_members[i].member_name)
318             enum_values.append(enum_value)
319             lines.append(&#39;        %s = 1 &lt;&lt; %d,&#39; % (enum_value, i))
320         if len(enum_values) &gt; 0:
321             lines.append(&#39;        AllFieldsSet = (%s)&#39; % &#39; | &#39;.join(enum_values))
322         else:
323             lines.append(&#39;        AllFieldsSet = 0&#39;)
324         lines.append(&#39;    };&#39;)
325         lines.append(&#39;&#39;)
326         return &#39;\n&#39;.join(lines)
327 
328     def _generate_builder_setter_for_member(self, type_member, domain):
329         setter_args = {
330             &#39;camelName&#39;: ucfirst(type_member.member_name),
331             &#39;keyedSet&#39;: CppGenerator.cpp_setter_method_for_type(type_member.type),
332             &#39;name&#39;: type_member.member_name,
333             &#39;parameterType&#39;: CppGenerator.cpp_type_for_type_member(type_member),
334             &#39;helpersNamespace&#39;: self.helpers_namespace(),
335         }
336 
337         lines = []
338         lines.append(&#39;&#39;)
339         lines.append(&#39;        Builder&lt;STATE | %(camelName)sSet&gt;&amp; set%(camelName)s(%(parameterType)s value)&#39; % setter_args)
340         lines.append(&#39;        {&#39;)
341         lines.append(&#39;            COMPILE_ASSERT(!(STATE &amp; %(camelName)sSet), property_%(name)s_already_set);&#39; % setter_args)
342 
343         if isinstance(type_member.type, EnumType):
344             lines.append(&#39;            m_result-&gt;%(keyedSet)s(&quot;%(name)s&quot;_s, Inspector::Protocol::%(helpersNamespace)s::getEnumConstantValue(value));&#39; % setter_args)
345         else:
346             lines.append(&#39;            m_result-&gt;%(keyedSet)s(&quot;%(name)s&quot;_s, value);&#39; % setter_args)
347         lines.append(&#39;            return castState&lt;%(camelName)sSet&gt;();&#39; % setter_args)
348         lines.append(&#39;        }&#39;)
349         return &#39;\n&#39;.join(lines)
350 
351     def _generate_unchecked_setter_for_member(self, type_member, domain):
352         setter_args = {
353             &#39;camelName&#39;: ucfirst(type_member.member_name),
354             &#39;keyedSet&#39;: CppGenerator.cpp_setter_method_for_type(type_member.type),
355             &#39;name&#39;: type_member.member_name,
356             &#39;parameterType&#39;: CppGenerator.cpp_type_for_type_member(type_member),
357             &#39;helpersNamespace&#39;: self.helpers_namespace(),
358         }
359 
360         lines = []
361         lines.append(&#39;&#39;)
362         lines.append(&#39;    void set%(camelName)s(%(parameterType)s value)&#39; % setter_args)
363         lines.append(&#39;    {&#39;)
364         if isinstance(type_member.type, EnumType):
365             lines.append(&#39;        JSON::ObjectBase::%(keyedSet)s(&quot;%(name)s&quot;_s, Inspector::Protocol::%(helpersNamespace)s::getEnumConstantValue(value));&#39; % setter_args)
366         elif CppGenerator.should_use_references_for_type(type_member.type):
367             lines.append(&#39;        JSON::ObjectBase::%(keyedSet)s(&quot;%(name)s&quot;_s, WTFMove(value));&#39; % setter_args)
368         else:
369             lines.append(&#39;        JSON::ObjectBase::%(keyedSet)s(&quot;%(name)s&quot;_s, value);&#39; % setter_args)
370         lines.append(&#39;    }&#39;)
371         return &#39;\n&#39;.join(lines)
372 
373     def _generate_forward_declarations_for_binding_traits(self, domains):
374         # A list of (builder_type, needs_runtime_cast)
375         type_arguments = []
376 
377         for domain in domains:
378             type_declarations = self.type_declarations_for_domain(domain)
379             declarations_to_generate = [decl for decl in type_declarations if self.type_needs_shape_assertions(decl.type)]
380 
381             for type_declaration in declarations_to_generate:
382                 for type_member in type_declaration.type_members:
383                     if isinstance(type_member.type, EnumType):
384                         type_arguments.append((CppGenerator.cpp_protocol_type_for_type_member(type_member, type_declaration), False))
385 
386                 if isinstance(type_declaration.type, ObjectType):
387                     type_arguments.append((CppGenerator.cpp_protocol_type_for_type(type_declaration.type), Generator.type_needs_runtime_casts(type_declaration.type)))
388 
389         struct_keywords = [&#39;struct&#39;]
390         function_keywords = [&#39;static void&#39;]
391         export_macro = self.model().framework.setting(&#39;export_macro&#39;, None)
392         if export_macro is not None:
393             struct_keywords.append(export_macro)
394             #function_keywords[1:1] = [export_macro]
395 
396         lines = []
397         for argument in type_arguments:
398             lines.append(&#39;template&lt;&gt; %s BindingTraits&lt;%s&gt; {&#39; % (&#39; &#39;.join(struct_keywords), argument[0]))
399             if argument[1]:
400                 lines.append(&#39;static RefPtr&lt;%s&gt; runtimeCast(RefPtr&lt;JSON::Value&gt;&amp;&amp; value);&#39; % argument[0])
401             lines.append(&#39;%s assertValueHasExpectedType(JSON::Value*);&#39; % &#39; &#39;.join(function_keywords))
402             lines.append(&#39;};&#39;)
403         return &#39;\n&#39;.join(lines)
404 
405     def _generate_declarations_for_enum_conversion_methods(self, domains):
406         sections = []
407         sections.append(&#39;\n&#39;.join([
408             &#39;namespace %s {&#39; % self.helpers_namespace(),
409             &#39;&#39;,
410             &#39;template&lt;typename ProtocolEnumType&gt;&#39;,
411             &#39;Optional&lt;ProtocolEnumType&gt; parseEnumValueFromString(const String&amp;);&#39;,
412         ]))
413 
414         def return_type_with_export_macro(cpp_protocol_type):
415             enum_return_type = &#39;Optional&lt;%s&gt;&#39; % cpp_protocol_type
416             result_terms = [enum_return_type]
417             export_macro = self.model().framework.setting(&#39;export_macro&#39;, None)
418             if export_macro is not None:
419                 result_terms[:0] = [export_macro]
420             return &#39; &#39;.join(result_terms)
421 
422         def type_member_is_anonymous_enum_type(type_member):
423             return isinstance(type_member.type, EnumType) and type_member.type.is_anonymous
424 
425         for domain in domains:
426             type_declarations = self.type_declarations_for_domain(domain)
427             declaration_types = [decl.type for decl in type_declarations]
428             object_types = [_type for _type in declaration_types if isinstance(_type, ObjectType)]
429             enum_types = [_type for _type in declaration_types if isinstance(_type, EnumType)]
430             if len(object_types) + len(enum_types) == 0:
431                 continue
432 
433             sorted(object_types, key=methodcaller(&#39;raw_name&#39;))
434             sorted(enum_types, key=methodcaller(&#39;raw_name&#39;))
435 
436             domain_lines = []
437             domain_lines.append(&quot;// Enums in the &#39;%s&#39; Domain&quot; % domain.domain_name)
438             for enum_type in enum_types:
439                 cpp_protocol_type = CppGenerator.cpp_protocol_type_for_type(enum_type)
440                 domain_lines.append(&#39;template&lt;&gt;&#39;)
441                 domain_lines.append(&#39;%s parseEnumValueFromString&lt;%s&gt;(const String&amp;);&#39; % (return_type_with_export_macro(cpp_protocol_type), cpp_protocol_type))
442 
443             for object_type in object_types:
444                 for enum_member in filter(type_member_is_anonymous_enum_type, object_type.members):
445                     cpp_protocol_type = CppGenerator.cpp_protocol_type_for_type_member(enum_member, object_type.declaration())
446                     domain_lines.append(&#39;template&lt;&gt;&#39;)
447                     domain_lines.append(&#39;%s parseEnumValueFromString&lt;%s&gt;(const String&amp;);&#39; % (return_type_with_export_macro(cpp_protocol_type), cpp_protocol_type))
448 
449             if len(domain_lines) == 1:
450                 continue  # No real declarations to emit, just the domain comment. Skip.
451 
452             sections.append(self.wrap_with_guard_for_domain(domain, &#39;\n&#39;.join(domain_lines)))
453 
454         if len(sections) == 1:
455             return [] # No real sections to emit, just the namespace and template declaration. Skip.
456 
457         sections.append(&#39;} // namespace %s&#39; % self.helpers_namespace())
458 
459         return [&#39;\n\n&#39;.join(sections)]
460 
461     def _generate_hash_declarations(self, domains):
462         lines = []
463 
464         for domain in domains:
465             type_declarations = self.type_declarations_for_domain(domain)
466             declaration_types = [decl.type for decl in type_declarations]
467             enum_types = list(filter(lambda _type: isinstance(_type, EnumType), declaration_types))
468 
469             if len(enum_types) == 0:
470                 continue
471 
472             if len(lines) == 0:
473                 lines.append(&#39;namespace WTF {&#39;)
474                 lines.append(&#39;&#39;)
475                 lines.append(&#39;template&lt;typename T&gt; struct DefaultHash;&#39;)
476 
477             lines.append(&#39;&#39;)
478             lines.append(&quot;// Hash declarations in the &#39;%s&#39; Domain&quot; % domain.domain_name)
479 
480             for enum_type in enum_types:
481                 lines.append(&#39;template&lt;&gt;&#39;)
482                 lines.append(&#39;struct DefaultHash&lt;Inspector::Protocol::%s::%s&gt; {&#39; % (domain.domain_name, enum_type.raw_name()))
483                 lines.append(&#39;    typedef IntHash&lt;Inspector::Protocol::%s::%s&gt; Hash;&#39; % (domain.domain_name, enum_type.raw_name()))
484                 lines.append(&#39;};&#39;)
485 
486         if len(lines) == 0:
487             return []
488 
489         lines.append(&#39;&#39;)
490         lines.append(&#39;} // namespace WTF&#39;)
491         return [&#39;\n&#39;.join(lines)]
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InstructionStream.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 
 27 #pragma once
 28 
<a name="1" id="anc1"></a><span class="line-added"> 29 #include &quot;BytecodeIndex.h&quot;</span>
 30 #include &quot;Instruction.h&quot;
 31 #include &lt;wtf/Vector.h&gt;
 32 
 33 namespace JSC {
 34 
<a name="2" id="anc2"></a><span class="line-modified"> 35 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(InstructionStream);</span>
 36 
 37 class InstructionStream {
 38     WTF_MAKE_FAST_ALLOCATED;
 39 
<a name="3" id="anc3"></a><span class="line-modified"> 40     using InstructionBuffer = Vector&lt;uint8_t, 0, UnsafeVectorOverflow, 16, InstructionStreamMalloc&gt;;</span>
 41 
 42     friend class InstructionStreamWriter;
 43     friend class CachedInstructionStream;
 44 public:
 45     size_t sizeInBytes() const;
 46 
 47     using Offset = unsigned;
 48 
 49 private:
 50     template&lt;class InstructionBuffer&gt;
 51     class BaseRef {
 52         WTF_MAKE_FAST_ALLOCATED;
 53 
 54         friend class InstructionStream;
 55 
 56     public:
 57         BaseRef(const BaseRef&lt;InstructionBuffer&gt;&amp; other)
 58             : m_instructions(other.m_instructions)
 59             ,  m_index(other.m_index)
 60         { }
 61 
 62         void operator=(const BaseRef&lt;InstructionBuffer&gt;&amp; other)
 63         {
 64             m_instructions = other.m_instructions;
 65             m_index = other.m_index;
 66         }
 67 
 68         inline const Instruction* operator-&gt;() const { return unwrap(); }
 69         inline const Instruction* ptr() const { return unwrap(); }
 70 
 71         bool operator!=(const BaseRef&lt;InstructionBuffer&gt;&amp; other) const
 72         {
 73             return &amp;m_instructions != &amp;other.m_instructions || m_index != other.m_index;
 74         }
 75 
 76         BaseRef next() const
 77         {
 78             return BaseRef { m_instructions, m_index + ptr()-&gt;size() };
 79         }
 80 
<a name="4" id="anc4"></a><span class="line-modified"> 81         inline Offset offset() const { return m_index; }</span>
<span class="line-modified"> 82         inline BytecodeIndex index() const { return BytecodeIndex(offset()); }</span>


 83 
 84         bool isValid() const
 85         {
 86             return m_index &lt; m_instructions.size();
 87         }
 88 
 89     private:
 90         inline const Instruction* unwrap() const { return reinterpret_cast&lt;const Instruction*&gt;(&amp;m_instructions[m_index]); }
 91 
 92     protected:
 93         BaseRef(InstructionBuffer&amp; instructions, size_t index)
 94             : m_instructions(instructions)
 95             , m_index(index)
 96         { }
 97 
 98         InstructionBuffer&amp; m_instructions;
 99         Offset m_index;
100     };
101 
102 public:
103     using Ref = BaseRef&lt;const InstructionBuffer&gt;;
104 
105     class MutableRef : public BaseRef&lt;InstructionBuffer&gt; {
106         friend class InstructionStreamWriter;
107 
108     protected:
109         using BaseRef&lt;InstructionBuffer&gt;::BaseRef;
110 
111     public:
112         Ref freeze() const  { return Ref { m_instructions, m_index }; }
113         inline Instruction* operator-&gt;() { return unwrap(); }
<a name="5" id="anc5"></a><span class="line-added">114         inline const Instruction* operator-&gt;() const { return unwrap(); }</span>
115         inline Instruction* ptr() { return unwrap(); }
<a name="6" id="anc6"></a><span class="line-added">116         inline const Instruction* ptr() const { return unwrap(); }</span>
117         inline operator Ref()
118         {
119             return Ref { m_instructions, m_index };
120         }
121 
122     private:
123         inline Instruction* unwrap() { return reinterpret_cast&lt;Instruction*&gt;(&amp;m_instructions[m_index]); }
<a name="7" id="anc7"></a><span class="line-added">124         inline const Instruction* unwrap() const { return reinterpret_cast&lt;const Instruction*&gt;(&amp;m_instructions[m_index]); }</span>
125     };
126 
127 private:
128     class iterator : public Ref {
129         friend class InstructionStream;
130 
131     public:
132         using Ref::Ref;
133 
134         Ref&amp; operator*()
135         {
136             return *this;
137         }
138 
<a name="8" id="anc8"></a><span class="line-modified">139         iterator&amp; operator+=(size_t size)</span>
140         {
<a name="9" id="anc9"></a><span class="line-modified">141             m_index += size;</span>
142             return *this;
143         }
<a name="10" id="anc10"></a><span class="line-added">144 </span>
<span class="line-added">145         iterator&amp; operator++()</span>
<span class="line-added">146         {</span>
<span class="line-added">147             return *this += ptr()-&gt;size();</span>
<span class="line-added">148         }</span>
149     };
150 
151 public:
152     inline iterator begin() const
153     {
154         return iterator { m_instructions, 0 };
155     }
156 
157     inline iterator end() const
158     {
159         return iterator { m_instructions, m_instructions.size() };
160     }
161 
<a name="11" id="anc11"></a><span class="line-added">162     inline const Ref at(BytecodeIndex index) const { return at(index.offset()); }</span>
163     inline const Ref at(Offset offset) const
164     {
165         ASSERT(offset &lt; m_instructions.size());
166         return Ref { m_instructions, offset };
167     }
168 
169     inline size_t size() const
170     {
171         return m_instructions.size();
172     }
173 
174     const void* rawPointer() const
175     {
176         return m_instructions.data();
177     }
178 
179     bool contains(Instruction *) const;
180 
181 protected:
182     explicit InstructionStream(InstructionBuffer&amp;&amp;);
183 
184     InstructionBuffer m_instructions;
185 };
186 
187 class InstructionStreamWriter : public InstructionStream {
188     friend class BytecodeRewriter;
189 public:
190     InstructionStreamWriter()
191         : InstructionStream({ })
192     { }
193 
194     inline MutableRef ref(Offset offset)
195     {
196         ASSERT(offset &lt; m_instructions.size());
197         return MutableRef { m_instructions, offset };
198     }
199 
200     void seek(unsigned position)
201     {
202         ASSERT(position &lt;= m_instructions.size());
203         m_position = position;
204     }
205 
206     unsigned position()
207     {
208         return m_position;
209     }
210 
211     void write(uint8_t byte)
212     {
213         ASSERT(!m_finalized);
214         if (m_position &lt; m_instructions.size())
215             m_instructions[m_position++] = byte;
216         else {
217             m_instructions.append(byte);
218             m_position++;
219         }
220     }
221 
222     void write(uint16_t h)
223     {
224         ASSERT(!m_finalized);
225         uint8_t bytes[2];
226         std::memcpy(bytes, &amp;h, sizeof(h));
227 
228         // Though not always obvious, we don&#39;t have to invert the order of the
229         // bytes written here for CPU(BIG_ENDIAN). This is because the incoming
230         // i value is already ordered in big endian on CPU(BIG_EDNDIAN) platforms.
231         write(bytes[0]);
232         write(bytes[1]);
233     }
234 
235     void write(uint32_t i)
236     {
237         ASSERT(!m_finalized);
238         uint8_t bytes[4];
239         std::memcpy(bytes, &amp;i, sizeof(i));
240 
241         // Though not always obvious, we don&#39;t have to invert the order of the
242         // bytes written here for CPU(BIG_ENDIAN). This is because the incoming
243         // i value is already ordered in big endian on CPU(BIG_EDNDIAN) platforms.
244         write(bytes[0]);
245         write(bytes[1]);
246         write(bytes[2]);
247         write(bytes[3]);
248     }
249 
250     void rewind(MutableRef&amp; ref)
251     {
252         ASSERT(ref.offset() &lt; m_instructions.size());
253         m_instructions.shrink(ref.offset());
254         m_position = ref.offset();
255     }
256 
257     std::unique_ptr&lt;InstructionStream&gt; finalize()
258     {
259         m_finalized = true;
260         m_instructions.shrinkToFit();
261         return std::unique_ptr&lt;InstructionStream&gt; { new InstructionStream(WTFMove(m_instructions)) };
262     }
263 
264     MutableRef ref()
265     {
266         return MutableRef { m_instructions, m_position };
267     }
268 
269     void swap(InstructionStreamWriter&amp; other)
270     {
271         std::swap(m_finalized, other.m_finalized);
272         std::swap(m_position, other.m_position);
273         m_instructions.swap(other.m_instructions);
274     }
275 
276 private:
277     class iterator : public MutableRef {
278         friend class InstructionStreamWriter;
279 
280     protected:
281         using MutableRef::MutableRef;
282 
283     public:
284         MutableRef&amp; operator*()
285         {
286             return *this;
287         }
288 
<a name="12" id="anc12"></a><span class="line-modified">289         iterator&amp; operator+=(size_t size)</span>
290         {
<a name="13" id="anc13"></a><span class="line-modified">291             m_index += size;</span>
292             return *this;
293         }
<a name="14" id="anc14"></a><span class="line-added">294 </span>
<span class="line-added">295         iterator&amp; operator++()</span>
<span class="line-added">296         {</span>
<span class="line-added">297             return *this += ptr()-&gt;size();</span>
<span class="line-added">298         }</span>
299     };
300 
301 public:
302     iterator begin()
303     {
304         return iterator { m_instructions, 0 };
305     }
306 
307     iterator end()
308     {
309         return iterator { m_instructions, m_instructions.size() };
310     }
311 
312 private:
313     unsigned m_position { 0 };
314     bool m_finalized { false };
315 };
316 
317 
318 } // namespace JSC
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
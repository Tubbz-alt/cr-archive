<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageBackingStore.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Image.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ImageBuffer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageBackingStore.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 43     WTF_MAKE_FAST_ALLOCATED;
 44 public:
 45     static std::unique_ptr&lt;ImageBackingStore&gt; create(const IntSize&amp; size, bool premultiplyAlpha = true)
 46     {
 47         return std::unique_ptr&lt;ImageBackingStore&gt;(new ImageBackingStore(size, premultiplyAlpha));
 48     }
 49 
 50     static std::unique_ptr&lt;ImageBackingStore&gt; create(const ImageBackingStore&amp; other)
 51     {
 52         return std::unique_ptr&lt;ImageBackingStore&gt;(new ImageBackingStore(other));
 53     }
 54 
 55     NativeImagePtr image() const;
 56 
 57     bool setSize(const IntSize&amp; size)
 58     {
 59         if (size.isEmpty())
 60             return false;
 61 
 62         Vector&lt;char&gt; buffer;
<span class="line-modified"> 63         size_t bufferSize = size.area().unsafeGet() * sizeof(RGBA32);</span>
 64 
 65         if (!buffer.tryReserveCapacity(bufferSize))
 66             return false;
 67 
 68         buffer.grow(bufferSize);
 69         m_pixels = SharedBuffer::DataSegment::create(WTFMove(buffer));
<span class="line-modified"> 70         m_pixelsPtr = reinterpret_cast&lt;RGBA32*&gt;(const_cast&lt;char*&gt;(m_pixels-&gt;data()));</span>
 71         m_size = size;
 72         m_frameRect = IntRect(IntPoint(), m_size);
 73         clear();
 74         return true;
 75     }
 76 
 77     void setFrameRect(const IntRect&amp; frameRect)
 78     {
 79         ASSERT(!m_size.isEmpty());
 80         ASSERT(inBounds(frameRect));
 81         m_frameRect = frameRect;
 82     }
 83 
 84     const IntSize&amp; size() const { return m_size; }
 85     const IntRect&amp; frameRect() const { return m_frameRect; }
 86 
 87     void clear()
 88     {
<span class="line-modified"> 89         memset(m_pixelsPtr, 0, (m_size.area() * sizeof(RGBA32)).unsafeGet());</span>
 90     }
 91 
 92     void clearRect(const IntRect&amp; rect)
 93     {
 94         if (rect.isEmpty() || !inBounds(rect))
 95             return;
 96 
<span class="line-modified"> 97         size_t rowBytes = rect.width() * sizeof(RGBA32);</span>
<span class="line-modified"> 98         RGBA32* start = pixelAt(rect.x(), rect.y());</span>
 99         for (int i = 0; i &lt; rect.height(); ++i) {
100             memset(start, 0, rowBytes);
101             start += m_size.width();
102         }
103     }
104 
105     void fillRect(const IntRect &amp;rect, unsigned r, unsigned g, unsigned b, unsigned a)
106     {
107         if (rect.isEmpty() || !inBounds(rect))
108             return;
109 
<span class="line-modified">110         RGBA32* start = pixelAt(rect.x(), rect.y());</span>
<span class="line-modified">111         RGBA32 pixelValue = this-&gt;pixelValue(r, g, b, a);</span>
112         for (int i = 0; i &lt; rect.height(); ++i) {
113             for (int j = 0; j &lt; rect.width(); ++j)
114                 start[j] = pixelValue;
115             start += m_size.width();
116         }
117     }
118 
119     void repeatFirstRow(const IntRect&amp; rect)
120     {
121         if (rect.isEmpty() || !inBounds(rect))
122             return;
123 
<span class="line-modified">124         size_t rowBytes = rect.width() * sizeof(RGBA32);</span>
<span class="line-modified">125         RGBA32* src = pixelAt(rect.x(), rect.y());</span>
<span class="line-modified">126         RGBA32* dest = src + m_size.width();</span>
127         for (int i = 1; i &lt; rect.height(); ++i) {
128             memcpy(dest, src, rowBytes);
129             dest += m_size.width();
130         }
131     }
132 
<span class="line-modified">133     RGBA32* pixelAt(int x, int y) const</span>
134     {
135         ASSERT(inBounds(IntPoint(x, y)));
136         return m_pixelsPtr + y * m_size.width() + x;
137     }
138 
<span class="line-modified">139     void setPixel(RGBA32* dest, unsigned r, unsigned g, unsigned b, unsigned a)</span>
140     {
141         ASSERT(dest);
142         *dest = pixelValue(r, g, b, a);
143     }
144 
145     void setPixel(int x, int y, unsigned r, unsigned g, unsigned b, unsigned a)
146     {
147         setPixel(pixelAt(x, y), r, g, b, a);
148     }
149 
<span class="line-modified">150     void blendPixel(RGBA32* dest, unsigned r, unsigned g, unsigned b, unsigned a)</span>
151     {
152         if (!a)
153             return;
154 
<span class="line-modified">155         if (a &gt;= 255 || !alphaChannel(*dest)) {</span>


156             setPixel(dest, r, g, b, a);
157             return;
158         }
159 
160         if (!m_premultiplyAlpha)
<span class="line-modified">161             *dest = makePremultipliedRGBA(redChannel(*dest), greenChannel(*dest), blueChannel(*dest), alphaChannel(*dest), false);</span>
162 
163         unsigned d = 255 - a;
164 
<span class="line-modified">165         r = fastDivideBy255(r * a + redChannel(*dest) * d);</span>
<span class="line-modified">166         g = fastDivideBy255(g * a + greenChannel(*dest) * d);</span>
<span class="line-modified">167         b = fastDivideBy255(b * a + blueChannel(*dest) * d);</span>
<span class="line-modified">168         a += fastDivideBy255(d * alphaChannel(*dest));</span>
169 
170         if (m_premultiplyAlpha)
<span class="line-modified">171             *dest = makeRGBA(r, g, b, a);</span>
172         else
<span class="line-modified">173             *dest = makeUnPremultipliedRGBA(r, g, b, a);</span>
174     }
175 
176     static bool isOverSize(const IntSize&amp; size)
177     {
178 #if USE(CAIRO)
179         // FIXME: this is a workaround to avoid the cairo image size limit, but we should implement support for
180         // bigger images. See https://bugs.webkit.org/show_bug.cgi?id=177227.
181         //
182         // If the image is bigger than the cairo limit it can&#39;t be displayed, so we don&#39;t even try to decode it.
183         if (size.width() &gt; cairoMaxImageSize || size.height() &gt; cairoMaxImageSize)
184             return true;
185 #endif
186         static unsigned long long MaxPixels = ((1 &lt;&lt; 29) - 1);
187         unsigned long long pixels = static_cast&lt;unsigned long long&gt;(size.width()) * static_cast&lt;unsigned long long&gt;(size.height());
188         return pixels &gt; MaxPixels;
189     }
190 
191 private:
192     ImageBackingStore(const IntSize&amp; size, bool premultiplyAlpha = true)
193         : m_premultiplyAlpha(premultiplyAlpha)
194     {
195         ASSERT(!size.isEmpty() &amp;&amp; !isOverSize(size));
196         setSize(size);
197     }
198 
199     ImageBackingStore(const ImageBackingStore&amp; other)
200         : m_size(other.m_size)
201         , m_premultiplyAlpha(other.m_premultiplyAlpha)
202     {
203         ASSERT(!m_size.isEmpty() &amp;&amp; !isOverSize(m_size));
204         Vector&lt;char&gt; buffer;
205         buffer.append(other.m_pixels-&gt;data(), other.m_pixels-&gt;size());
206         m_pixels = SharedBuffer::DataSegment::create(WTFMove(buffer));
<span class="line-modified">207         m_pixelsPtr = reinterpret_cast&lt;RGBA32*&gt;(const_cast&lt;char*&gt;(m_pixels-&gt;data()));</span>
208     }
209 
210     bool inBounds(const IntPoint&amp; point) const
211     {
212         return IntRect(IntPoint(), m_size).contains(point);
213     }
214 
215     bool inBounds(const IntRect&amp; rect) const
216     {
217         return IntRect(IntPoint(), m_size).contains(rect);
218     }
219 
<span class="line-modified">220     RGBA32 pixelValue(unsigned r, unsigned g, unsigned b, unsigned a) const</span>
221     {
222         if (m_premultiplyAlpha &amp;&amp; !a)
223             return 0;
224 
225         if (m_premultiplyAlpha &amp;&amp; a &lt; 255)
<span class="line-modified">226             return makePremultipliedRGBA(r, g, b, a, false);</span>
227 
<span class="line-modified">228         return makeRGBA(r, g, b, a);</span>
229     }
230 
231     RefPtr&lt;SharedBuffer::DataSegment&gt; m_pixels;
<span class="line-modified">232     RGBA32* m_pixelsPtr { nullptr };</span>
233     IntSize m_size;
234     IntRect m_frameRect; // This will always just be the entire buffer except for GIF and PNG frames
235     bool m_premultiplyAlpha { true };
236 };
237 
238 }
</pre>
</td>
<td>
<hr />
<pre>
 43     WTF_MAKE_FAST_ALLOCATED;
 44 public:
 45     static std::unique_ptr&lt;ImageBackingStore&gt; create(const IntSize&amp; size, bool premultiplyAlpha = true)
 46     {
 47         return std::unique_ptr&lt;ImageBackingStore&gt;(new ImageBackingStore(size, premultiplyAlpha));
 48     }
 49 
 50     static std::unique_ptr&lt;ImageBackingStore&gt; create(const ImageBackingStore&amp; other)
 51     {
 52         return std::unique_ptr&lt;ImageBackingStore&gt;(new ImageBackingStore(other));
 53     }
 54 
 55     NativeImagePtr image() const;
 56 
 57     bool setSize(const IntSize&amp; size)
 58     {
 59         if (size.isEmpty())
 60             return false;
 61 
 62         Vector&lt;char&gt; buffer;
<span class="line-modified"> 63         size_t bufferSize = size.area().unsafeGet() * sizeof(uint32_t);</span>
 64 
 65         if (!buffer.tryReserveCapacity(bufferSize))
 66             return false;
 67 
 68         buffer.grow(bufferSize);
 69         m_pixels = SharedBuffer::DataSegment::create(WTFMove(buffer));
<span class="line-modified"> 70         m_pixelsPtr = reinterpret_cast&lt;uint32_t*&gt;(const_cast&lt;char*&gt;(m_pixels-&gt;data()));</span>
 71         m_size = size;
 72         m_frameRect = IntRect(IntPoint(), m_size);
 73         clear();
 74         return true;
 75     }
 76 
 77     void setFrameRect(const IntRect&amp; frameRect)
 78     {
 79         ASSERT(!m_size.isEmpty());
 80         ASSERT(inBounds(frameRect));
 81         m_frameRect = frameRect;
 82     }
 83 
 84     const IntSize&amp; size() const { return m_size; }
 85     const IntRect&amp; frameRect() const { return m_frameRect; }
 86 
 87     void clear()
 88     {
<span class="line-modified"> 89         memset(m_pixelsPtr, 0, (m_size.area() * sizeof(uint32_t)).unsafeGet());</span>
 90     }
 91 
 92     void clearRect(const IntRect&amp; rect)
 93     {
 94         if (rect.isEmpty() || !inBounds(rect))
 95             return;
 96 
<span class="line-modified"> 97         size_t rowBytes = rect.width() * sizeof(uint32_t);</span>
<span class="line-modified"> 98         uint32_t* start = pixelAt(rect.x(), rect.y());</span>
 99         for (int i = 0; i &lt; rect.height(); ++i) {
100             memset(start, 0, rowBytes);
101             start += m_size.width();
102         }
103     }
104 
105     void fillRect(const IntRect &amp;rect, unsigned r, unsigned g, unsigned b, unsigned a)
106     {
107         if (rect.isEmpty() || !inBounds(rect))
108             return;
109 
<span class="line-modified">110         uint32_t* start = pixelAt(rect.x(), rect.y());</span>
<span class="line-modified">111         uint32_t pixelValue = this-&gt;pixelValue(r, g, b, a);</span>
112         for (int i = 0; i &lt; rect.height(); ++i) {
113             for (int j = 0; j &lt; rect.width(); ++j)
114                 start[j] = pixelValue;
115             start += m_size.width();
116         }
117     }
118 
119     void repeatFirstRow(const IntRect&amp; rect)
120     {
121         if (rect.isEmpty() || !inBounds(rect))
122             return;
123 
<span class="line-modified">124         size_t rowBytes = rect.width() * sizeof(uint32_t);</span>
<span class="line-modified">125         uint32_t* src = pixelAt(rect.x(), rect.y());</span>
<span class="line-modified">126         uint32_t* dest = src + m_size.width();</span>
127         for (int i = 1; i &lt; rect.height(); ++i) {
128             memcpy(dest, src, rowBytes);
129             dest += m_size.width();
130         }
131     }
132 
<span class="line-modified">133     uint32_t* pixelAt(int x, int y) const</span>
134     {
135         ASSERT(inBounds(IntPoint(x, y)));
136         return m_pixelsPtr + y * m_size.width() + x;
137     }
138 
<span class="line-modified">139     void setPixel(uint32_t* dest, unsigned r, unsigned g, unsigned b, unsigned a)</span>
140     {
141         ASSERT(dest);
142         *dest = pixelValue(r, g, b, a);
143     }
144 
145     void setPixel(int x, int y, unsigned r, unsigned g, unsigned b, unsigned a)
146     {
147         setPixel(pixelAt(x, y), r, g, b, a);
148     }
149 
<span class="line-modified">150     void blendPixel(uint32_t* dest, unsigned r, unsigned g, unsigned b, unsigned a)</span>
151     {
152         if (!a)
153             return;
154 
<span class="line-modified">155         SimpleColor pixel { *dest };</span>
<span class="line-added">156 </span>
<span class="line-added">157         if (a &gt;= 255 || !pixel.isVisible()) {</span>
158             setPixel(dest, r, g, b, a);
159             return;
160         }
161 
162         if (!m_premultiplyAlpha)
<span class="line-modified">163             pixel = makePremultipliedRGBA(pixel.redComponent(), pixel.greenComponent(), pixel.blueComponent(), pixel.alphaComponent(), false);</span>
164 
165         unsigned d = 255 - a;
166 
<span class="line-modified">167         r = fastDivideBy255(r * a + pixel.redComponent() * d);</span>
<span class="line-modified">168         g = fastDivideBy255(g * a + pixel.greenComponent() * d);</span>
<span class="line-modified">169         b = fastDivideBy255(b * a + pixel.blueComponent() * d);</span>
<span class="line-modified">170         a += fastDivideBy255(d * pixel.alphaComponent());</span>
171 
172         if (m_premultiplyAlpha)
<span class="line-modified">173             *dest = makeRGBA(r, g, b, a).value();</span>
174         else
<span class="line-modified">175             *dest = makeUnPremultipliedRGBA(r, g, b, a).value();</span>
176     }
177 
178     static bool isOverSize(const IntSize&amp; size)
179     {
180 #if USE(CAIRO)
181         // FIXME: this is a workaround to avoid the cairo image size limit, but we should implement support for
182         // bigger images. See https://bugs.webkit.org/show_bug.cgi?id=177227.
183         //
184         // If the image is bigger than the cairo limit it can&#39;t be displayed, so we don&#39;t even try to decode it.
185         if (size.width() &gt; cairoMaxImageSize || size.height() &gt; cairoMaxImageSize)
186             return true;
187 #endif
188         static unsigned long long MaxPixels = ((1 &lt;&lt; 29) - 1);
189         unsigned long long pixels = static_cast&lt;unsigned long long&gt;(size.width()) * static_cast&lt;unsigned long long&gt;(size.height());
190         return pixels &gt; MaxPixels;
191     }
192 
193 private:
194     ImageBackingStore(const IntSize&amp; size, bool premultiplyAlpha = true)
195         : m_premultiplyAlpha(premultiplyAlpha)
196     {
197         ASSERT(!size.isEmpty() &amp;&amp; !isOverSize(size));
198         setSize(size);
199     }
200 
201     ImageBackingStore(const ImageBackingStore&amp; other)
202         : m_size(other.m_size)
203         , m_premultiplyAlpha(other.m_premultiplyAlpha)
204     {
205         ASSERT(!m_size.isEmpty() &amp;&amp; !isOverSize(m_size));
206         Vector&lt;char&gt; buffer;
207         buffer.append(other.m_pixels-&gt;data(), other.m_pixels-&gt;size());
208         m_pixels = SharedBuffer::DataSegment::create(WTFMove(buffer));
<span class="line-modified">209         m_pixelsPtr = reinterpret_cast&lt;uint32_t*&gt;(const_cast&lt;char*&gt;(m_pixels-&gt;data()));</span>
210     }
211 
212     bool inBounds(const IntPoint&amp; point) const
213     {
214         return IntRect(IntPoint(), m_size).contains(point);
215     }
216 
217     bool inBounds(const IntRect&amp; rect) const
218     {
219         return IntRect(IntPoint(), m_size).contains(rect);
220     }
221 
<span class="line-modified">222     uint32_t pixelValue(unsigned r, unsigned g, unsigned b, unsigned a) const</span>
223     {
224         if (m_premultiplyAlpha &amp;&amp; !a)
225             return 0;
226 
227         if (m_premultiplyAlpha &amp;&amp; a &lt; 255)
<span class="line-modified">228             return makePremultipliedRGBA(r, g, b, a, false).value();</span>
229 
<span class="line-modified">230         return makeRGBA(r, g, b, a).value();</span>
231     }
232 
233     RefPtr&lt;SharedBuffer::DataSegment&gt; m_pixels;
<span class="line-modified">234     uint32_t* m_pixelsPtr { nullptr };</span>
235     IntSize m_size;
236     IntRect m_frameRect; // This will always just be the entire buffer except for GIF and PNG frames
237     bool m_premultiplyAlpha { true };
238 };
239 
240 }
</pre>
</td>
</tr>
</table>
<center><a href="Image.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ImageBuffer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
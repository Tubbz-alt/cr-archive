<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/HeapUtil.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 namespace JSC {
 29 
 30 // Are you tired of waiting for all of WebKit to build because you changed the implementation of a
 31 // function in HeapInlines.h?  Does it bother you that you&#39;re waiting on rebuilding the JS DOM
 32 // bindings even though your change is in a function called from only 2 .cpp files?  Then HeapUtil.h
 33 // is for you!  Everything in this class should be a static method that takes a Heap&amp; if needed.
 34 // This is a friend of Heap, so you can access all of Heap&#39;s privates.
 35 //
 36 // This ends up being an issue because Heap exposes a lot of methods that ought to be inline for
 37 // performance or that must be inline because they are templates.  This class ought to contain
 38 // methods that are used for the implementation of the collector, or for unusual clients that need
 39 // to reach deep into the collector for some reason.  Don&#39;t put things in here that would cause you
 40 // to have to include it from more than a handful of places, since that would defeat the purpose.
 41 // This class isn&#39;t here to look pretty.  It&#39;s to let us hack the GC more easily!
 42 
 43 class HeapUtil {
 44 public:
 45     // This function must be run after stopAllocation() is called and
 46     // before liveness data is cleared to be accurate.
 47     template&lt;typename Func&gt;
 48     static void findGCObjectPointersForMarking(
 49         Heap&amp; heap, HeapVersion markingVersion, HeapVersion newlyAllocatedVersion, TinyBloomFilter filter,
 50         void* passedPointer, const Func&amp; func)
 51     {
 52         const HashSet&lt;MarkedBlock*&gt;&amp; set = heap.objectSpace().blocks().set();
 53 
 54         ASSERT(heap.objectSpace().isMarking());
 55         static constexpr bool isMarking = true;
 56 
 57         char* pointer = static_cast&lt;char*&gt;(passedPointer);
 58 
 59         // It could point to a large allocation.
 60         if (heap.objectSpace().preciseAllocationsForThisCollectionSize()) {
 61             if (heap.objectSpace().preciseAllocationsForThisCollectionBegin()[0]-&gt;aboveLowerBound(pointer)
 62                 &amp;&amp; heap.objectSpace().preciseAllocationsForThisCollectionEnd()[-1]-&gt;belowUpperBound(pointer)) {
 63                 PreciseAllocation** result = approximateBinarySearch&lt;PreciseAllocation*&gt;(
 64                     heap.objectSpace().preciseAllocationsForThisCollectionBegin(),
 65                     heap.objectSpace().preciseAllocationsForThisCollectionSize(),
 66                     PreciseAllocation::fromCell(pointer),
 67                     [] (PreciseAllocation** ptr) -&gt; PreciseAllocation* { return *ptr; });
 68                 if (result) {
 69                     auto attemptLarge = [&amp;] (PreciseAllocation* allocation) {
 70                         if (allocation-&gt;contains(pointer) &amp;&amp; allocation-&gt;hasValidCell())
 71                             func(allocation-&gt;cell(), allocation-&gt;attributes().cellKind);
 72                     };
 73 
 74                     if (result &gt; heap.objectSpace().preciseAllocationsForThisCollectionBegin())
 75                         attemptLarge(result[-1]);
 76                     attemptLarge(result[0]);
 77                     if (result + 1 &lt; heap.objectSpace().preciseAllocationsForThisCollectionEnd())
 78                         attemptLarge(result[1]);
 79                 }
 80             }
 81         }
 82 
 83         MarkedBlock* candidate = MarkedBlock::blockFor(pointer);
 84         // It&#39;s possible for a butterfly pointer to point past the end of a butterfly. Check this now.
 85         if (pointer &lt;= bitwise_cast&lt;char*&gt;(candidate) + sizeof(IndexingHeader)) {
 86             // We may be interested in the last cell of the previous MarkedBlock.
 87             char* previousPointer = bitwise_cast&lt;char*&gt;(bitwise_cast&lt;uintptr_t&gt;(pointer) - sizeof(IndexingHeader) - 1);
 88             MarkedBlock* previousCandidate = MarkedBlock::blockFor(previousPointer);
 89             if (!filter.ruleOut(bitwise_cast&lt;Bits&gt;(previousCandidate))
 90                 &amp;&amp; set.contains(previousCandidate)
 91                 &amp;&amp; hasInteriorPointers(previousCandidate-&gt;handle().cellKind())) {
 92                 previousPointer = static_cast&lt;char*&gt;(previousCandidate-&gt;handle().cellAlign(previousPointer));
 93                 if (previousCandidate-&gt;handle().isLiveCell(markingVersion, newlyAllocatedVersion, isMarking, previousPointer))
 94                     func(previousPointer, previousCandidate-&gt;handle().cellKind());
 95             }
 96         }
 97 
 98         if (filter.ruleOut(bitwise_cast&lt;Bits&gt;(candidate))) {
 99             ASSERT(!candidate || !set.contains(candidate));
100             return;
101         }
102 
103         if (!set.contains(candidate))
104             return;
105 
106         HeapCell::Kind cellKind = candidate-&gt;handle().cellKind();
107 
108         auto tryPointer = [&amp;] (void* pointer) {
109             if (candidate-&gt;handle().isLiveCell(markingVersion, newlyAllocatedVersion, isMarking, pointer))
110                 func(pointer, cellKind);
111         };
112 
113         if (isJSCellKind(cellKind)) {
114             if (MarkedBlock::isAtomAligned(pointer))
115                 tryPointer(pointer);
116             if (!hasInteriorPointers(cellKind))
117                 return;
118         }
119 
120         // A butterfly could point into the middle of an object.
121         char* alignedPointer = static_cast&lt;char*&gt;(candidate-&gt;handle().cellAlign(pointer));
122         tryPointer(alignedPointer);
123 
124         // Also, a butterfly could point at the end of an object plus sizeof(IndexingHeader). In that
125         // case, this is pointing to the object to the right of the one we should be marking.
126         if (candidate-&gt;candidateAtomNumber(alignedPointer) &gt; 0
127             &amp;&amp; pointer &lt;= alignedPointer + sizeof(IndexingHeader))
128             tryPointer(alignedPointer - candidate-&gt;cellSize());
129     }
130 
131     static bool isPointerGCObjectJSCell(Heap&amp; heap, TinyBloomFilter filter, JSCell* pointer)
132     {
133         // It could point to a large allocation.
134         if (pointer-&gt;isPreciseAllocation()) {
135             auto* set = heap.objectSpace().preciseAllocationSet();
136             ASSERT(set);
137             if (set-&gt;isEmpty())
138                 return false;
139             return set-&gt;contains(pointer);
140         }
141 
142         const HashSet&lt;MarkedBlock*&gt;&amp; set = heap.objectSpace().blocks().set();
143 
144         MarkedBlock* candidate = MarkedBlock::blockFor(pointer);
145         if (filter.ruleOut(bitwise_cast&lt;Bits&gt;(candidate))) {
146             ASSERT(!candidate || !set.contains(candidate));
147             return false;
148         }
149 
150         if (!MarkedBlock::isAtomAligned(pointer))
151             return false;
152 
153         if (!set.contains(candidate))
154             return false;
155 
156         if (candidate-&gt;handle().cellKind() != HeapCell::JSCell)
157             return false;
158 
159         if (!candidate-&gt;handle().isLiveCell(pointer))
160             return false;
161 
162         return true;
163     }
164 
165     // This does not find the cell if the pointer is pointing at the middle of a JSCell.
166     static bool isValueGCObject(
167         Heap&amp; heap, TinyBloomFilter filter, JSValue value)
168     {
169         ASSERT(heap.objectSpace().preciseAllocationSet());
170         if (!value.isCell())
171             return false;
172         return isPointerGCObjectJSCell(heap, filter, value.asCell());
173     }
174 };
175 
176 } // namespace JSC
177 
    </pre>
  </body>
</html>
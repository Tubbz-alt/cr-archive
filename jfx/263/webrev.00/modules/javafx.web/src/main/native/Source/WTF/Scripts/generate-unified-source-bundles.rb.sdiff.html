<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/Scripts/generate-unified-source-bundles.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../JavaScriptCore/yarr/generateYarrCanonicalizeUnicode.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../wtf/AggregateLogger.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/Scripts/generate-unified-source-bundles.rb</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 38     puts &quot;usage: #{SCRIPT_NAME} [options] &lt;sources-list-file&gt;...&quot;
 39     puts &quot;&lt;sources-list-file&gt; may be separate arguments or one semicolon separated string&quot;
 40     puts &quot;--help                          (-h) Print this message&quot;
 41     puts &quot;--verbose                       (-v) Adds extra logging to stderr.&quot;
 42     puts
 43     puts &quot;Required arguments:&quot;
 44     puts &quot;--source-tree-path              (-s) Path to the root of the source directory.&quot;
 45     puts &quot;--derived-sources-path          (-d) Path to the directory where the unified source files should be placed.&quot;
 46     puts
 47     puts &quot;Optional arguments:&quot;
 48     puts &quot;--print-bundled-sources              Print bundled sources rather than generating sources&quot;
 49     puts &quot;--print-all-sources                  Print all sources rather than generating sources&quot;
 50     puts &quot;--generate-xcfilelists               Generate .xcfilelist files&quot;
 51     puts &quot;--input-xcfilelist-path              Path of the generated input .xcfilelist file&quot;
 52     puts &quot;--output-xcfilelist-path             Path of the generated output .xcfilelist file&quot;
 53     puts &quot;--feature-flags                 (-f) Space or semicolon separated list of enabled feature flags&quot;
 54     puts
 55     puts &quot;Generation options:&quot;
 56     puts &quot;--max-cpp-bundle-count               Use global sequential numbers for cpp bundle filenames and set the limit on the number&quot;
 57     puts &quot;--max-obj-c-bundle-count             Use global sequential numbers for Obj-C bundle filenames and set the limit on the number&quot;

 58     exit 1
 59 end
 60 
 61 MAX_BUNDLE_SIZE = 8

 62 $derivedSourcesPath = nil
 63 $unifiedSourceOutputPath = nil
 64 $sourceTreePath = nil
 65 $featureFlags = {}
 66 $verbose = false
 67 $mode = :GenerateBundles
 68 $inputXCFilelistPath = nil
 69 $outputXCFilelistPath = nil
 70 $maxCppBundleCount = nil
 71 $maxObjCBundleCount = nil

 72 
 73 def log(text)
 74     $stderr.puts text if $verbose
 75 end
 76 
 77 GetoptLong.new([&#39;--help&#39;, &#39;-h&#39;, GetoptLong::NO_ARGUMENT],
 78                [&#39;--verbose&#39;, &#39;-v&#39;, GetoptLong::NO_ARGUMENT],
 79                [&#39;--derived-sources-path&#39;, &#39;-d&#39;, GetoptLong::REQUIRED_ARGUMENT],
 80                [&#39;--source-tree-path&#39;, &#39;-s&#39;, GetoptLong::REQUIRED_ARGUMENT],
 81                [&#39;--feature-flags&#39;, &#39;-f&#39;, GetoptLong::REQUIRED_ARGUMENT],
 82                [&#39;--print-bundled-sources&#39;, GetoptLong::NO_ARGUMENT],
 83                [&#39;--print-all-sources&#39;, GetoptLong::NO_ARGUMENT],
 84                [&#39;--generate-xcfilelists&#39;, GetoptLong::NO_ARGUMENT],
 85                [&#39;--input-xcfilelist-path&#39;, GetoptLong::REQUIRED_ARGUMENT],
 86                [&#39;--output-xcfilelist-path&#39;, GetoptLong::REQUIRED_ARGUMENT],
 87                [&#39;--max-cpp-bundle-count&#39;, GetoptLong::REQUIRED_ARGUMENT],
<span class="line-modified"> 88                [&#39;--max-obj-c-bundle-count&#39;, GetoptLong::REQUIRED_ARGUMENT]).each {</span>

 89     | opt, arg |
 90     case opt
 91     when &#39;--help&#39;
 92         usage(nil)
 93     when &#39;--verbose&#39;
 94         $verbose = true
 95     when &#39;--derived-sources-path&#39;
 96         $derivedSourcesPath = Pathname.new(arg)
 97     when &#39;--source-tree-path&#39;
 98         $sourceTreePath = Pathname.new(arg)
 99         usage(&quot;Source tree #{arg} does not exist.&quot;) if !$sourceTreePath.exist?
100     when &#39;--feature-flags&#39;
101         arg.gsub(/\s+/, &quot;;&quot;).split(&quot;;&quot;).map { |x| $featureFlags[x] = true }
102     when &#39;--print-bundled-sources&#39;
103         $mode = :PrintBundledSources
104     when &#39;--print-all-sources&#39;
105         $mode = :PrintAllSources
106     when &#39;--generate-xcfilelists&#39;
107         $mode = :GenerateXCFilelists
108     when &#39;--input-xcfilelist-path&#39;
109         $inputXCFilelistPath = arg
110     when &#39;--output-xcfilelist-path&#39;
111         $outputXCFilelistPath = arg
112     when &#39;--max-cpp-bundle-count&#39;
113         $maxCppBundleCount = arg.to_i
114     when &#39;--max-obj-c-bundle-count&#39;
115         $maxObjCBundleCount = arg.to_i


116     end
117 }
118 
119 $unifiedSourceOutputPath = $derivedSourcesPath + Pathname.new(&quot;unified-sources&quot;)
120 FileUtils.mkpath($unifiedSourceOutputPath) if !$unifiedSourceOutputPath.exist? &amp;&amp; $mode != :GenerateXCFilelists
121 
122 usage(&quot;--derived-sources-path must be specified.&quot;) if !$unifiedSourceOutputPath
123 usage(&quot;--source-tree-path must be specified.&quot;) if !$sourceTreePath
124 log(&quot;Putting unified sources in #{$unifiedSourceOutputPath}&quot;)
125 log(&quot;Active Feature flags: #{$featureFlags.keys.inspect}&quot;)
126 
127 usage(&quot;At least one source list file must be specified.&quot;) if ARGV.length == 0
128 # Even though CMake will only pass us a single semicolon separated arguemnts, we separate all the arguments for simplicity.
129 sourceListFiles = ARGV.to_a.map { | sourceFileList | sourceFileList.split(&quot;;&quot;) }.flatten
130 log(&quot;Source files: #{sourceListFiles}&quot;)
131 $generatedSources = []
132 $inputSources = []
133 $outputSources = []
134 
135 class SourceFile
</pre>
<hr />
<pre>
177             end
178         elsif $mode == :GenerateBundles || !derived?
179             @path.to_s
180         else
181             ($derivedSourcesPath + @path).to_s
182         end
183     end
184 end
185 
186 class BundleManager
187     attr_reader :bundleCount, :extension, :fileCount, :currentBundleText, :maxCount, :extraFiles
188 
189     def initialize(extension, max)
190         @extension = extension
191         @fileCount = 0
192         @bundleCount = 0
193         @currentBundleText = &quot;&quot;
194         @maxCount = max
195         @extraFiles = []
196         @currentDirectory = nil

197     end
198 
199     def writeFile(file, text)
200         bundleFile = $unifiedSourceOutputPath + file
201         if $mode == :GenerateXCFilelists
202             $outputSources &lt;&lt; bundleFile
203             return
204         end
205         if (!bundleFile.exist? || IO::read(bundleFile) != @currentBundleText)
206             log(&quot;Writing bundle #{bundleFile} with: \n#{@currentBundleText}&quot;)
207             IO::write(bundleFile, @currentBundleText)
208         end
209     end
210 
211     def bundleFileName()
212         id =
213             if @maxCount
214                 @bundleCount.to_s
215             else
216                 # The dash makes the filenames more clear when using a hash.
</pre>
<hr />
<pre>
224         @bundleCount += 1
225         bundleFile = bundleFileName
226         $generatedSources &lt;&lt; $unifiedSourceOutputPath + bundleFile
227         @extraFiles &lt;&lt; bundleFile if @maxCount and @bundleCount &gt; @maxCount
228 
229         writeFile(bundleFile, @currentBundleText)
230         @currentBundleText = &quot;&quot;
231         @fileCount = 0
232     end
233 
234     def flushToMax
235         raise if !@maxCount
236         while @bundleCount &lt; @maxCount
237             flush
238         end
239     end
240 
241     def addFile(sourceFile)
242         path = sourceFile.path
243         raise &quot;wrong extension: #{path.extname} expected #{@extension}&quot; unless path.extname == &quot;.#{@extension}&quot;
<span class="line-modified">244         if (TopLevelDirectoryForPath(@currentDirectory) != TopLevelDirectoryForPath(path.dirname))</span>

245             log(&quot;Flushing because new top level directory; old: #{@currentDirectory}, new: #{path.dirname}&quot;)
246             flush

247             @currentDirectory = path.dirname
248             @bundleCount = 0 unless @maxCount
249         end
<span class="line-modified">250         if @fileCount == MAX_BUNDLE_SIZE</span>
251             log(&quot;Flushing because new bundle is full (#{@fileCount} sources)&quot;)
252             flush
253         end
254         @currentBundleText += &quot;#include \&quot;#{sourceFile}\&quot;\n&quot;
255         @fileCount += 1
256     end
257 end
258 










259 def TopLevelDirectoryForPath(path)
260     if !path
261         return nil
262     end
263     while path.dirname != path.dirname.dirname
264         path = path.dirname
265     end
266     return path
267 end
268 
269 def ProcessFileForUnifiedSourceGeneration(sourceFile)
270     path = sourceFile.path
271     $inputSources &lt;&lt; sourceFile.to_s
272 
273     bundle = $bundleManagers[path.extname]
274     if !bundle
275         log(&quot;No bundle for #{path.extname} files, building #{path} standalone&quot;)
276         $generatedSources &lt;&lt; sourceFile
277     elsif !sourceFile.unifiable
278         log(&quot;Not allowed to unify #{path}, building standalone&quot;)
</pre>
</td>
<td>
<hr />
<pre>
 38     puts &quot;usage: #{SCRIPT_NAME} [options] &lt;sources-list-file&gt;...&quot;
 39     puts &quot;&lt;sources-list-file&gt; may be separate arguments or one semicolon separated string&quot;
 40     puts &quot;--help                          (-h) Print this message&quot;
 41     puts &quot;--verbose                       (-v) Adds extra logging to stderr.&quot;
 42     puts
 43     puts &quot;Required arguments:&quot;
 44     puts &quot;--source-tree-path              (-s) Path to the root of the source directory.&quot;
 45     puts &quot;--derived-sources-path          (-d) Path to the directory where the unified source files should be placed.&quot;
 46     puts
 47     puts &quot;Optional arguments:&quot;
 48     puts &quot;--print-bundled-sources              Print bundled sources rather than generating sources&quot;
 49     puts &quot;--print-all-sources                  Print all sources rather than generating sources&quot;
 50     puts &quot;--generate-xcfilelists               Generate .xcfilelist files&quot;
 51     puts &quot;--input-xcfilelist-path              Path of the generated input .xcfilelist file&quot;
 52     puts &quot;--output-xcfilelist-path             Path of the generated output .xcfilelist file&quot;
 53     puts &quot;--feature-flags                 (-f) Space or semicolon separated list of enabled feature flags&quot;
 54     puts
 55     puts &quot;Generation options:&quot;
 56     puts &quot;--max-cpp-bundle-count               Use global sequential numbers for cpp bundle filenames and set the limit on the number&quot;
 57     puts &quot;--max-obj-c-bundle-count             Use global sequential numbers for Obj-C bundle filenames and set the limit on the number&quot;
<span class="line-added"> 58     puts &quot;--dense-bundle-filter                Densely bundle files matching the given path glob&quot;</span>
 59     exit 1
 60 end
 61 
 62 MAX_BUNDLE_SIZE = 8
<span class="line-added"> 63 MAX_DENSE_BUNDLE_SIZE = 64</span>
 64 $derivedSourcesPath = nil
 65 $unifiedSourceOutputPath = nil
 66 $sourceTreePath = nil
 67 $featureFlags = {}
 68 $verbose = false
 69 $mode = :GenerateBundles
 70 $inputXCFilelistPath = nil
 71 $outputXCFilelistPath = nil
 72 $maxCppBundleCount = nil
 73 $maxObjCBundleCount = nil
<span class="line-added"> 74 $denseBundleFilters = []</span>
 75 
 76 def log(text)
 77     $stderr.puts text if $verbose
 78 end
 79 
 80 GetoptLong.new([&#39;--help&#39;, &#39;-h&#39;, GetoptLong::NO_ARGUMENT],
 81                [&#39;--verbose&#39;, &#39;-v&#39;, GetoptLong::NO_ARGUMENT],
 82                [&#39;--derived-sources-path&#39;, &#39;-d&#39;, GetoptLong::REQUIRED_ARGUMENT],
 83                [&#39;--source-tree-path&#39;, &#39;-s&#39;, GetoptLong::REQUIRED_ARGUMENT],
 84                [&#39;--feature-flags&#39;, &#39;-f&#39;, GetoptLong::REQUIRED_ARGUMENT],
 85                [&#39;--print-bundled-sources&#39;, GetoptLong::NO_ARGUMENT],
 86                [&#39;--print-all-sources&#39;, GetoptLong::NO_ARGUMENT],
 87                [&#39;--generate-xcfilelists&#39;, GetoptLong::NO_ARGUMENT],
 88                [&#39;--input-xcfilelist-path&#39;, GetoptLong::REQUIRED_ARGUMENT],
 89                [&#39;--output-xcfilelist-path&#39;, GetoptLong::REQUIRED_ARGUMENT],
 90                [&#39;--max-cpp-bundle-count&#39;, GetoptLong::REQUIRED_ARGUMENT],
<span class="line-modified"> 91                [&#39;--max-obj-c-bundle-count&#39;, GetoptLong::REQUIRED_ARGUMENT],</span>
<span class="line-added"> 92                [&#39;--dense-bundle-filter&#39;, GetoptLong::REQUIRED_ARGUMENT]).each {</span>
 93     | opt, arg |
 94     case opt
 95     when &#39;--help&#39;
 96         usage(nil)
 97     when &#39;--verbose&#39;
 98         $verbose = true
 99     when &#39;--derived-sources-path&#39;
100         $derivedSourcesPath = Pathname.new(arg)
101     when &#39;--source-tree-path&#39;
102         $sourceTreePath = Pathname.new(arg)
103         usage(&quot;Source tree #{arg} does not exist.&quot;) if !$sourceTreePath.exist?
104     when &#39;--feature-flags&#39;
105         arg.gsub(/\s+/, &quot;;&quot;).split(&quot;;&quot;).map { |x| $featureFlags[x] = true }
106     when &#39;--print-bundled-sources&#39;
107         $mode = :PrintBundledSources
108     when &#39;--print-all-sources&#39;
109         $mode = :PrintAllSources
110     when &#39;--generate-xcfilelists&#39;
111         $mode = :GenerateXCFilelists
112     when &#39;--input-xcfilelist-path&#39;
113         $inputXCFilelistPath = arg
114     when &#39;--output-xcfilelist-path&#39;
115         $outputXCFilelistPath = arg
116     when &#39;--max-cpp-bundle-count&#39;
117         $maxCppBundleCount = arg.to_i
118     when &#39;--max-obj-c-bundle-count&#39;
119         $maxObjCBundleCount = arg.to_i
<span class="line-added">120     when &#39;--dense-bundle-filter&#39;</span>
<span class="line-added">121         $denseBundleFilters.push(arg)</span>
122     end
123 }
124 
125 $unifiedSourceOutputPath = $derivedSourcesPath + Pathname.new(&quot;unified-sources&quot;)
126 FileUtils.mkpath($unifiedSourceOutputPath) if !$unifiedSourceOutputPath.exist? &amp;&amp; $mode != :GenerateXCFilelists
127 
128 usage(&quot;--derived-sources-path must be specified.&quot;) if !$unifiedSourceOutputPath
129 usage(&quot;--source-tree-path must be specified.&quot;) if !$sourceTreePath
130 log(&quot;Putting unified sources in #{$unifiedSourceOutputPath}&quot;)
131 log(&quot;Active Feature flags: #{$featureFlags.keys.inspect}&quot;)
132 
133 usage(&quot;At least one source list file must be specified.&quot;) if ARGV.length == 0
134 # Even though CMake will only pass us a single semicolon separated arguemnts, we separate all the arguments for simplicity.
135 sourceListFiles = ARGV.to_a.map { | sourceFileList | sourceFileList.split(&quot;;&quot;) }.flatten
136 log(&quot;Source files: #{sourceListFiles}&quot;)
137 $generatedSources = []
138 $inputSources = []
139 $outputSources = []
140 
141 class SourceFile
</pre>
<hr />
<pre>
183             end
184         elsif $mode == :GenerateBundles || !derived?
185             @path.to_s
186         else
187             ($derivedSourcesPath + @path).to_s
188         end
189     end
190 end
191 
192 class BundleManager
193     attr_reader :bundleCount, :extension, :fileCount, :currentBundleText, :maxCount, :extraFiles
194 
195     def initialize(extension, max)
196         @extension = extension
197         @fileCount = 0
198         @bundleCount = 0
199         @currentBundleText = &quot;&quot;
200         @maxCount = max
201         @extraFiles = []
202         @currentDirectory = nil
<span class="line-added">203         @lastBundlingPrefix = nil</span>
204     end
205 
206     def writeFile(file, text)
207         bundleFile = $unifiedSourceOutputPath + file
208         if $mode == :GenerateXCFilelists
209             $outputSources &lt;&lt; bundleFile
210             return
211         end
212         if (!bundleFile.exist? || IO::read(bundleFile) != @currentBundleText)
213             log(&quot;Writing bundle #{bundleFile} with: \n#{@currentBundleText}&quot;)
214             IO::write(bundleFile, @currentBundleText)
215         end
216     end
217 
218     def bundleFileName()
219         id =
220             if @maxCount
221                 @bundleCount.to_s
222             else
223                 # The dash makes the filenames more clear when using a hash.
</pre>
<hr />
<pre>
231         @bundleCount += 1
232         bundleFile = bundleFileName
233         $generatedSources &lt;&lt; $unifiedSourceOutputPath + bundleFile
234         @extraFiles &lt;&lt; bundleFile if @maxCount and @bundleCount &gt; @maxCount
235 
236         writeFile(bundleFile, @currentBundleText)
237         @currentBundleText = &quot;&quot;
238         @fileCount = 0
239     end
240 
241     def flushToMax
242         raise if !@maxCount
243         while @bundleCount &lt; @maxCount
244             flush
245         end
246     end
247 
248     def addFile(sourceFile)
249         path = sourceFile.path
250         raise &quot;wrong extension: #{path.extname} expected #{@extension}&quot; unless path.extname == &quot;.#{@extension}&quot;
<span class="line-modified">251         bundlePrefix, bundleSize = BundlePrefixAndSizeForPath(path)</span>
<span class="line-added">252         if (@lastBundlingPrefix != bundlePrefix)</span>
253             log(&quot;Flushing because new top level directory; old: #{@currentDirectory}, new: #{path.dirname}&quot;)
254             flush
<span class="line-added">255             @lastBundlingPrefix = bundlePrefix</span>
256             @currentDirectory = path.dirname
257             @bundleCount = 0 unless @maxCount
258         end
<span class="line-modified">259         if @fileCount &gt;= bundleSize</span>
260             log(&quot;Flushing because new bundle is full (#{@fileCount} sources)&quot;)
261             flush
262         end
263         @currentBundleText += &quot;#include \&quot;#{sourceFile}\&quot;\n&quot;
264         @fileCount += 1
265     end
266 end
267 
<span class="line-added">268 def BundlePrefixAndSizeForPath(path)</span>
<span class="line-added">269     topLevelDirectory = TopLevelDirectoryForPath(path.dirname)</span>
<span class="line-added">270     $denseBundleFilters.each { |filter|</span>
<span class="line-added">271         if path.fnmatch(filter)</span>
<span class="line-added">272             return filter, MAX_DENSE_BUNDLE_SIZE</span>
<span class="line-added">273         end</span>
<span class="line-added">274     }</span>
<span class="line-added">275     return topLevelDirectory, MAX_BUNDLE_SIZE</span>
<span class="line-added">276 end</span>
<span class="line-added">277 </span>
278 def TopLevelDirectoryForPath(path)
279     if !path
280         return nil
281     end
282     while path.dirname != path.dirname.dirname
283         path = path.dirname
284     end
285     return path
286 end
287 
288 def ProcessFileForUnifiedSourceGeneration(sourceFile)
289     path = sourceFile.path
290     $inputSources &lt;&lt; sourceFile.to_s
291 
292     bundle = $bundleManagers[path.extname]
293     if !bundle
294         log(&quot;No bundle for #{path.extname} files, building #{path} standalone&quot;)
295         $generatedSources &lt;&lt; sourceFile
296     elsif !sourceFile.unifiable
297         log(&quot;Not allowed to unify #{path}, building standalone&quot;)
</pre>
</td>
</tr>
</table>
<center><a href="../../JavaScriptCore/yarr/generateYarrCanonicalizeUnicode.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../wtf/AggregateLogger.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
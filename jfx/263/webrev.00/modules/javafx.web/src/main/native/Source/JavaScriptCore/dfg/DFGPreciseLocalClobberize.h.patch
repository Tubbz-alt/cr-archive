diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPreciseLocalClobberize.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPreciseLocalClobberize.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPreciseLocalClobberize.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPreciseLocalClobberize.h
@@ -51,11 +51,11 @@
             if (heap.payload().isTop()) {
                 readTop();
                 return;
             }
 
-            callIfAppropriate(m_read, VirtualRegister(heap.payload().value32()));
+            callIfAppropriate(m_read, heap.operand());
             return;
         }
 
         if (heap.overlaps(Stack)) {
             readTop();
@@ -66,11 +66,11 @@
     void write(AbstractHeap heap)
     {
         // We expect stack writes to already be precisely characterized by DFG::clobberize().
         if (heap.kind() == Stack) {
             RELEASE_ASSERT(!heap.payload().isTop());
-            callIfAppropriate(m_unconditionalWrite, VirtualRegister(heap.payload().value32()));
+            callIfAppropriate(m_unconditionalWrite, heap.operand());
             return;
         }
 
         RELEASE_ASSERT(!heap.overlaps(Stack));
     }
@@ -85,16 +85,16 @@
         if (location.kind() != StackLoc)
             return;
 
         RELEASE_ASSERT(location.heap().kind() == Stack);
 
-        m_def(VirtualRegister(location.heap().payload().value32()), node);
+        m_def(location.heap().operand(), node);
     }
 
 private:
     template<typename Functor>
-    void callIfAppropriate(const Functor& functor, VirtualRegister operand)
+    void callIfAppropriate(const Functor& functor, Operand operand)
     {
         if (operand.isLocal() && static_cast<unsigned>(operand.toLocal()) >= m_graph.block(0)->variablesAtHead.numberOfLocals())
             return;
 
         if (operand.isArgument() && !operand.isHeader() && static_cast<unsigned>(operand.toArgument()) >= m_graph.block(0)->variablesAtHead.numberOfArguments())
@@ -107,19 +107,19 @@
     {
         auto readFrame = [&] (InlineCallFrame* inlineCallFrame, unsigned numberOfArgumentsToSkip) {
             if (!inlineCallFrame) {
                 // Read the outermost arguments and argument count.
                 for (unsigned i = numberOfArgumentsToSkip; i < static_cast<unsigned>(m_graph.m_codeBlock->numParameters()); i++)
-                    m_read(virtualRegisterForArgument(i));
-                m_read(VirtualRegister(CallFrameSlot::argumentCount));
+                    m_read(virtualRegisterForArgumentIncludingThis(i));
+                m_read(VirtualRegister(CallFrameSlot::argumentCountIncludingThis));
                 return;
             }
 
             for (unsigned i = numberOfArgumentsToSkip; i < inlineCallFrame->argumentsWithFixup.size(); i++)
-                m_read(VirtualRegister(inlineCallFrame->stackOffset + virtualRegisterForArgument(i).offset()));
+                m_read(VirtualRegister(inlineCallFrame->stackOffset + virtualRegisterForArgumentIncludingThis(i).offset()));
             if (inlineCallFrame->isVarargs())
-                m_read(VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::argumentCount));
+                m_read(VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::argumentCountIncludingThis));
         };
 
         auto readSpread = [&] (Node* spread) {
             ASSERT(spread->op() == Spread || spread->op() == PhantomSpread);
             if (!spread->child1()->isPhantomAllocation())
@@ -156,10 +156,11 @@
         case GetMyArgumentByVal:
         case GetMyArgumentByValOutOfBounds:
         case CreateDirectArguments:
         case CreateScopedArguments:
         case CreateClonedArguments:
+        case CreateArgumentsButterfly:
         case PhantomDirectArguments:
         case PhantomClonedArguments:
         case GetRestLength:
         case CreateRest: {
             bool isForwardingNode = false;
@@ -222,43 +223,43 @@
         case GetArgument: {
             InlineCallFrame* inlineCallFrame = m_node->origin.semantic.inlineCallFrame();
             unsigned indexIncludingThis = m_node->argumentIndex();
             if (!inlineCallFrame) {
                 if (indexIncludingThis < static_cast<unsigned>(m_graph.m_codeBlock->numParameters()))
-                    m_read(virtualRegisterForArgument(indexIncludingThis));
-                m_read(VirtualRegister(CallFrameSlot::argumentCount));
+                    m_read(virtualRegisterForArgumentIncludingThis(indexIncludingThis));
+                m_read(VirtualRegister(CallFrameSlot::argumentCountIncludingThis));
                 break;
             }
 
             ASSERT_WITH_MESSAGE(inlineCallFrame->isVarargs(), "GetArgument is only used for InlineCallFrame if the call frame is varargs.");
             if (indexIncludingThis < inlineCallFrame->argumentsWithFixup.size())
-                m_read(VirtualRegister(inlineCallFrame->stackOffset + virtualRegisterForArgument(indexIncludingThis).offset()));
-            m_read(VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::argumentCount));
+                m_read(VirtualRegister(inlineCallFrame->stackOffset + virtualRegisterForArgumentIncludingThis(indexIncludingThis).offset()));
+            m_read(VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::argumentCountIncludingThis));
             break;
         }
 
         default: {
             // All of the outermost arguments, except this, are read in sloppy mode.
             if (!m_graph.m_codeBlock->isStrictMode()) {
                 for (unsigned i = m_graph.m_codeBlock->numParameters(); i--;)
-                    m_read(virtualRegisterForArgument(i));
+                    m_read(virtualRegisterForArgumentIncludingThis(i));
             }
 
             // The stack header is read.
             for (unsigned i = 0; i < CallFrameSlot::thisArgument; ++i)
                 m_read(VirtualRegister(i));
 
             // Read all of the inline arguments and call frame headers that we didn't already capture.
             for (InlineCallFrame* inlineCallFrame = m_node->origin.semantic.inlineCallFrame(); inlineCallFrame; inlineCallFrame = inlineCallFrame->getCallerInlineFrameSkippingTailCalls()) {
                 if (!inlineCallFrame->isStrictMode()) {
                     for (unsigned i = inlineCallFrame->argumentsWithFixup.size(); i--;)
-                        m_read(VirtualRegister(inlineCallFrame->stackOffset + virtualRegisterForArgument(i).offset()));
+                        m_read(VirtualRegister(inlineCallFrame->stackOffset + virtualRegisterForArgumentIncludingThis(i).offset()));
                 }
                 if (inlineCallFrame->isClosureCall)
                     m_read(VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::callee));
                 if (inlineCallFrame->isVarargs())
-                    m_read(VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::argumentCount));
+                    m_read(VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::argumentCountIncludingThis));
             }
             break;
         } }
     }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSPopStateEventCustom.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSPluginElementFunctions.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSReadableStreamSourceCustom.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSPopStateEventCustom.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 37,57 ***</span>
  #include &lt;JavaScriptCore/JSCJSValueInlines.h&gt;
  
  namespace WebCore {
  using namespace JSC;
  
<span class="line-modified">! JSValue JSPopStateEvent::state(ExecState&amp; state) const</span>
  {
      if (m_state) {
          // We cannot use a cached object if we are in a different world than the one it was created in.
<span class="line-modified">!         if (isWorldCompatible(state, m_state.get()))</span>
              return m_state.get();
          ASSERT_NOT_REACHED();
      }
  
<span class="line-modified">!     // Save the state value to the m_state member of a JSPopStateEvent, and return it, for convenience.</span>
<span class="line-modified">!     auto cacheState = [&amp;state, this] (JSC::JSValue eventState) {</span>
<span class="line-modified">!         m_state.set(state.vm(), this, eventState);</span>
          return eventState;
      };
  
      PopStateEvent&amp; event = wrapped();
  
      if (JSC::JSValue eventState = event.state()) {
<span class="line-modified">!         // We need to make sure a PopStateEvent does not leak objects in its state property across isolated DOM worlds.</span>
          // Ideally, we would check that the worlds have different privileges but that&#39;s not possible yet.
<span class="line-modified">!         if (!isWorldCompatible(state, eventState)) {</span>
<span class="line-modified">!             if (auto serializedValue = event.trySerializeState(state))</span>
<span class="line-modified">!                 eventState = serializedValue-&gt;deserialize(state, globalObject());</span>
              else
                  eventState = jsNull();
          }
          return cacheState(eventState);
      }
  
      History* history = event.history();
      if (!history || !event.serializedState())
          return cacheState(jsNull());
  
<span class="line-modified">!     // There&#39;s no cached value from a previous invocation, nor a state value was provided by the</span>
<span class="line-modified">!     // event, but there is a history object, so first we need to see if the state object has been</span>
      // deserialized through the history object already.
<span class="line-modified">!     // The current history state object might&#39;ve changed in the meantime, so we need to take care</span>
<span class="line-modified">!     // of using the correct one, and always share the same deserialization with history.state.</span>
  
      bool isSameState = history-&gt;isSameAsCurrentState(event.serializedState());
      JSValue result;
  
      if (isSameState) {
<span class="line-modified">!         JSHistory* jsHistory = jsCast&lt;JSHistory*&gt;(toJS(&amp;state, globalObject(), *history).asCell());</span>
<span class="line-modified">!         result = jsHistory-&gt;state(state);</span>
      } else
<span class="line-modified">!         result = event.serializedState()-&gt;deserialize(state, globalObject());</span>
  
      return cacheState(result);
  }
  
  void JSPopStateEvent::visitAdditionalChildren(JSC::SlotVisitor&amp; visitor)
<span class="line-new-header">--- 37,57 ---</span>
  #include &lt;JavaScriptCore/JSCJSValueInlines.h&gt;
  
  namespace WebCore {
  using namespace JSC;
  
<span class="line-modified">! JSValue JSPopStateEvent::state(JSGlobalObject&amp; lexicalGlobalObject) const</span>
  {
      if (m_state) {
          // We cannot use a cached object if we are in a different world than the one it was created in.
<span class="line-modified">!         if (isWorldCompatible(lexicalGlobalObject, m_state.get()))</span>
              return m_state.get();
          ASSERT_NOT_REACHED();
      }
  
<span class="line-modified">!     // Save the lexicalGlobalObject value to the m_state member of a JSPopStateEvent, and return it, for convenience.</span>
<span class="line-modified">!     auto cacheState = [&amp;lexicalGlobalObject, this] (JSC::JSValue eventState) {</span>
<span class="line-modified">!         m_state.set(lexicalGlobalObject.vm(), this, eventState);</span>
          return eventState;
      };
  
      PopStateEvent&amp; event = wrapped();
  
      if (JSC::JSValue eventState = event.state()) {
<span class="line-modified">!         // We need to make sure a PopStateEvent does not leak objects in its lexicalGlobalObject property across isolated DOM worlds.</span>
          // Ideally, we would check that the worlds have different privileges but that&#39;s not possible yet.
<span class="line-modified">!         if (!isWorldCompatible(lexicalGlobalObject, eventState)) {</span>
<span class="line-modified">!             if (auto serializedValue = event.trySerializeState(lexicalGlobalObject))</span>
<span class="line-modified">!                 eventState = serializedValue-&gt;deserialize(lexicalGlobalObject, globalObject());</span>
              else
                  eventState = jsNull();
          }
          return cacheState(eventState);
      }
  
      History* history = event.history();
      if (!history || !event.serializedState())
          return cacheState(jsNull());
  
<span class="line-modified">!     // There&#39;s no cached value from a previous invocation, nor a lexicalGlobalObject value was provided by the</span>
<span class="line-modified">!     // event, but there is a history object, so first we need to see if the lexicalGlobalObject object has been</span>
      // deserialized through the history object already.
<span class="line-modified">!     // The current history lexicalGlobalObject object might&#39;ve changed in the meantime, so we need to take care</span>
<span class="line-modified">!     // of using the correct one, and always share the same deserialization with history.lexicalGlobalObject.</span>
  
      bool isSameState = history-&gt;isSameAsCurrentState(event.serializedState());
      JSValue result;
  
      if (isSameState) {
<span class="line-modified">!         JSHistory* jsHistory = jsCast&lt;JSHistory*&gt;(toJS(&amp;lexicalGlobalObject, globalObject(), *history).asCell());</span>
<span class="line-modified">!         result = jsHistory-&gt;state(lexicalGlobalObject);</span>
      } else
<span class="line-modified">!         result = event.serializedState()-&gt;deserialize(lexicalGlobalObject, globalObject());</span>
  
      return cacheState(result);
  }
  
  void JSPopStateEvent::visitAdditionalChildren(JSC::SlotVisitor&amp; visitor)
</pre>
<center><a href="JSPluginElementFunctions.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSReadableStreamSourceCustom.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
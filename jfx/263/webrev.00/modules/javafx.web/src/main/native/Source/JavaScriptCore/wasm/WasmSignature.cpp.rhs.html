<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSignature.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmSignature.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;WasmSignatureInlines.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 32 #include &lt;wtf/CommaPrinter.h&gt;</span>
 33 #include &lt;wtf/FastMalloc.h&gt;
 34 #include &lt;wtf/HashFunctions.h&gt;
 35 #include &lt;wtf/PrintStream.h&gt;
<a name="3" id="anc3"></a><span class="line-added"> 36 #include &lt;wtf/StringPrintStream.h&gt;</span>
 37 #include &lt;wtf/text/WTFString.h&gt;
 38 
 39 namespace JSC { namespace Wasm {
 40 
 41 namespace {
 42 namespace WasmSignatureInternal {
<a name="4" id="anc4"></a><span class="line-modified"> 43 static constexpr bool verbose = false;</span>
 44 }
 45 }
 46 
 47 SignatureInformation* SignatureInformation::theOne { nullptr };
 48 std::once_flag SignatureInformation::signatureInformationFlag;
 49 
 50 String Signature::toString() const
 51 {
<a name="5" id="anc5"></a><span class="line-modified"> 52     return WTF::toString(*this);</span>








 53 }
 54 
 55 void Signature::dump(PrintStream&amp; out) const
 56 {
<a name="6" id="anc6"></a><span class="line-modified"> 57     {</span>
<span class="line-added"> 58         out.print(&quot;(&quot;);</span>
<span class="line-added"> 59         CommaPrinter comma;</span>
<span class="line-added"> 60         for (SignatureArgCount arg = 0; arg &lt; argumentCount(); ++arg)</span>
<span class="line-added"> 61             out.print(comma, makeString(argument(arg)));</span>
<span class="line-added"> 62         out.print(&quot;)&quot;);</span>
<span class="line-added"> 63     }</span>
<span class="line-added"> 64 </span>
<span class="line-added"> 65     {</span>
<span class="line-added"> 66         CommaPrinter comma;</span>
<span class="line-added"> 67         out.print(&quot; -&gt; [&quot;);</span>
<span class="line-added"> 68         for (SignatureArgCount ret = 0; ret &lt; returnCount(); ++ret)</span>
<span class="line-added"> 69             out.print(comma, makeString(returnType(ret)));</span>
<span class="line-added"> 70         out.print(&quot;]&quot;);</span>
<span class="line-added"> 71     }</span>
 72 }
 73 
<a name="7" id="anc7"></a><span class="line-modified"> 74 static unsigned computeHash(size_t returnCount, const Type* returnTypes, size_t argumentCount, const Type* argumentTypes)</span>
 75 {
 76     unsigned accumulator = 0xa1bcedd8u;
<a name="8" id="anc8"></a><span class="line-modified"> 77     for (uint32_t i = 0; i &lt; argumentCount; ++i)</span>
<span class="line-modified"> 78         accumulator = WTF::pairIntHash(accumulator, WTF::IntHash&lt;uint8_t&gt;::hash(static_cast&lt;uint8_t&gt;(argumentTypes[i])));</span>
<span class="line-modified"> 79     for (uint32_t i = 0; i &lt; returnCount; ++i)</span>
<span class="line-added"> 80         accumulator = WTF::pairIntHash(accumulator, WTF::IntHash&lt;uint8_t&gt;::hash(static_cast&lt;uint8_t&gt;(returnTypes[i])));</span>
 81     return accumulator;
 82 }
 83 
<a name="9" id="anc9"></a><span class="line-modified"> 84 unsigned Signature::hash() const</span>
<span class="line-added"> 85 {</span>
<span class="line-added"> 86     return computeHash(returnCount(), storage(0), argumentCount(), storage(returnCount()));</span>
<span class="line-added"> 87 }</span>
<span class="line-added"> 88 </span>
<span class="line-added"> 89 RefPtr&lt;Signature&gt; Signature::tryCreate(SignatureArgCount returnCount, SignatureArgCount argumentCount)</span>
 90 {
 91     // We use WTF_MAKE_FAST_ALLOCATED for this class.
<a name="10" id="anc10"></a><span class="line-modified"> 92     auto result = tryFastMalloc(allocatedSize(returnCount, argumentCount));</span>
 93     void* memory = nullptr;
 94     if (!result.getValue(memory))
 95         return nullptr;
<a name="11" id="anc11"></a><span class="line-modified"> 96     Signature* signature = new (NotNull, memory) Signature(returnCount, argumentCount);</span>
 97     return adoptRef(signature);
 98 }
 99 
100 SignatureInformation::SignatureInformation()
101 {
<a name="12" id="anc12"></a><span class="line-added">102 #define MAKE_THUNK_SIGNATURE(type, enc, str, val)                          \</span>
<span class="line-added">103     do {                                                                   \</span>
<span class="line-added">104         if (type != Void) {                                                \</span>
<span class="line-added">105             RefPtr&lt;Signature&gt; sig = Signature::tryCreate(1, 0);            \</span>
<span class="line-added">106             sig-&gt;ref();                                                    \</span>
<span class="line-added">107             sig-&gt;getReturnType(0) = type;                                  \</span>
<span class="line-added">108             thunkSignatures[linearizeType(type)] = sig.get();              \</span>
<span class="line-added">109             m_signatureSet.add(SignatureHash { sig.releaseNonNull() });    \</span>
<span class="line-added">110         }                                                                  \</span>
<span class="line-added">111     } while (false);</span>
<span class="line-added">112 </span>
<span class="line-added">113     FOR_EACH_WASM_TYPE(MAKE_THUNK_SIGNATURE);</span>
<span class="line-added">114 </span>
<span class="line-added">115     // Make Void again because we don&#39;t use the one that has void in it.</span>
<span class="line-added">116     {</span>
<span class="line-added">117         RefPtr&lt;Signature&gt; sig = Signature::tryCreate(0, 0);</span>
<span class="line-added">118         sig-&gt;ref();</span>
<span class="line-added">119         thunkSignatures[linearizeType(Void)] = sig.get();</span>
<span class="line-added">120         m_signatureSet.add(SignatureHash { sig.releaseNonNull() });</span>
<span class="line-added">121     }</span>
122 }
123 
<a name="13" id="anc13"></a><span class="line-modified">124 </span>
<span class="line-added">125 </span>
<span class="line-added">126 struct ParameterTypes {</span>
<span class="line-added">127     const Vector&lt;Type, 1&gt;&amp; returnTypes;</span>
<span class="line-added">128     const Vector&lt;Type&gt;&amp; argumentTypes;</span>
<span class="line-added">129 </span>
<span class="line-added">130     static unsigned hash(const ParameterTypes&amp; params)</span>
<span class="line-added">131     {</span>
<span class="line-added">132         return computeHash(params.returnTypes.size(), params.returnTypes.data(), params.argumentTypes.size(), params.argumentTypes.data());</span>
<span class="line-added">133     }</span>
<span class="line-added">134 </span>
<span class="line-added">135     static bool equal(const SignatureHash&amp; sig, const ParameterTypes&amp; params)</span>
<span class="line-added">136     {</span>
<span class="line-added">137         if (sig.key-&gt;argumentCount() != params.argumentTypes.size())</span>
<span class="line-added">138             return false;</span>
<span class="line-added">139         if (sig.key-&gt;returnCount() != params.returnTypes.size())</span>
<span class="line-added">140             return false;</span>
<span class="line-added">141 </span>
<span class="line-added">142         for (unsigned i = 0; i &lt; sig.key-&gt;argumentCount(); ++i) {</span>
<span class="line-added">143             if (sig.key-&gt;argument(i) != params.argumentTypes[i])</span>
<span class="line-added">144                 return false;</span>
<span class="line-added">145         }</span>
<span class="line-added">146 </span>
<span class="line-added">147         for (unsigned i = 0; i &lt; sig.key-&gt;returnCount(); ++i) {</span>
<span class="line-added">148             if (sig.key-&gt;returnType(i) != params.returnTypes[i])</span>
<span class="line-added">149                 return false;</span>
<span class="line-added">150         }</span>
<span class="line-added">151         return true;</span>
<span class="line-added">152     }</span>
<span class="line-added">153 </span>
<span class="line-added">154     static void translate(SignatureHash&amp; entry, const ParameterTypes&amp; params, unsigned)</span>
<span class="line-added">155     {</span>
<span class="line-added">156         RefPtr&lt;Signature&gt; signature = Signature::tryCreate(params.returnTypes.size(), params.argumentTypes.size());</span>
<span class="line-added">157         RELEASE_ASSERT(signature);</span>
<span class="line-added">158 </span>
<span class="line-added">159         for (unsigned i = 0; i &lt; params.returnTypes.size(); ++i)</span>
<span class="line-added">160             signature-&gt;getReturnType(i) = params.returnTypes[i];</span>
<span class="line-added">161 </span>
<span class="line-added">162         for (unsigned i = 0; i &lt; params.argumentTypes.size(); ++i)</span>
<span class="line-added">163             signature-&gt;getArgument(i) = params.argumentTypes[i];</span>
<span class="line-added">164 </span>
<span class="line-added">165         entry.key = WTFMove(signature);</span>
<span class="line-added">166     }</span>
<span class="line-added">167 };</span>
<span class="line-added">168 </span>
<span class="line-added">169 RefPtr&lt;Signature&gt; SignatureInformation::signatureFor(const Vector&lt;Type, 1&gt;&amp; results, const Vector&lt;Type&gt;&amp; args)</span>
170 {
171     SignatureInformation&amp; info = singleton();
172     LockHolder lock(info.m_lock);
173 
<a name="14" id="anc14"></a><span class="line-modified">174     auto addResult = info.m_signatureSet.template add&lt;ParameterTypes&gt;(ParameterTypes { results, args });</span>
<span class="line-modified">175     return makeRef(*addResult.iterator-&gt;key);</span>









176 }
177 
178 void SignatureInformation::tryCleanup()
179 {
180     SignatureInformation&amp; info = singleton();
181     LockHolder lock(info.m_lock);
182 
183     info.m_signatureSet.removeIf([&amp;] (auto&amp; hash) {
184         const auto&amp; signature = hash.key;
185         return signature-&gt;refCount() == 1;
186     });
187 }
188 
189 } } // namespace JSC::Wasm
190 
191 #endif // ENABLE(WEBASSEMBLY)
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
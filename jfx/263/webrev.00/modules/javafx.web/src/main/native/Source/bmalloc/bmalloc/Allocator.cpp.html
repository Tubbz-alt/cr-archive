<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Allocator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;Allocator.h&quot;
 27 #include &quot;BAssert.h&quot;
 28 #include &quot;Chunk.h&quot;
 29 #include &quot;Deallocator.h&quot;
 30 #include &quot;Environment.h&quot;
 31 #include &quot;Heap.h&quot;
 32 #include &quot;PerProcess.h&quot;
 33 #include &quot;Sizes.h&quot;
 34 #include &lt;algorithm&gt;
 35 #include &lt;cstdlib&gt;
 36 
 37 namespace bmalloc {
 38 
 39 Allocator::Allocator(Heap&amp; heap, Deallocator&amp; deallocator)
 40     : m_heap(heap)
 41     , m_deallocator(deallocator)
 42 {
 43     BASSERT(!Environment::get()-&gt;isDebugHeapEnabled());
 44     for (size_t sizeClass = 0; sizeClass &lt; sizeClassCount; ++sizeClass)
 45         m_bumpAllocators[sizeClass].init(objectSize(sizeClass));
 46 }
 47 
 48 Allocator::~Allocator()
 49 {
 50     scavenge();
 51 }
 52 
 53 void* Allocator::allocateImpl(size_t alignment, size_t size, FailureAction action)
 54 {
 55     BASSERT(isPowerOfTwo(alignment));
 56 
 57     if (!size)
 58         size = alignment;
 59 
 60     if (size &lt;= smallMax &amp;&amp; alignment &lt;= smallMax)
 61         return allocateImpl(roundUpToMultipleOf(alignment, size), action);
 62 
 63     return allocateLarge(size, action);
 64 }
 65 
 66 void* Allocator::reallocateImpl(void* object, size_t newSize, FailureAction action)
 67 {
 68     if (!object)
 69         return allocateImpl(newSize, action);
 70 
 71     size_t oldSize = 0;
 72     switch (objectType(m_heap, object)) {
 73     case ObjectType::Small: {
 74         size_t sizeClass = Object(object).page()-&gt;sizeClass();
 75         oldSize = objectSize(sizeClass);
 76         break;
 77     }
 78     case ObjectType::Large: {
 79         UniqueLockHolder lock(Heap::mutex());
 80         oldSize = m_heap.largeSize(lock, object);
 81 
 82         if (newSize &lt; oldSize &amp;&amp; newSize &gt; smallMax) {
 83             m_heap.shrinkLarge(lock, Range(object, oldSize), newSize);
 84             return object;
 85         }
 86         break;
 87     }
 88     }
 89 
 90     void* result = nullptr;
 91     result = allocateImpl(newSize, action);
 92     if (!result) {
 93         BASSERT(action == FailureAction::ReturnNull);
 94         return nullptr;
 95     }
 96     size_t copySize = std::min(oldSize, newSize);
 97     memcpy(result, object, copySize);
 98     m_deallocator.deallocate(object);
 99     return result;
100 }
101 
102 void Allocator::scavenge()
103 {
104     for (size_t sizeClass = 0; sizeClass &lt; sizeClassCount; ++sizeClass) {
105         BumpAllocator&amp; allocator = m_bumpAllocators[sizeClass];
106         BumpRangeCache&amp; bumpRangeCache = m_bumpRangeCaches[sizeClass];
107 
108         while (allocator.canAllocate())
109             m_deallocator.deallocate(allocator.allocate());
110 
111         while (bumpRangeCache.size()) {
112             allocator.refill(bumpRangeCache.pop());
113             while (allocator.canAllocate())
114                 m_deallocator.deallocate(allocator.allocate());
115         }
116 
117         allocator.clear();
118     }
119 }
120 
121 BNO_INLINE void Allocator::refillAllocatorSlowCase(BumpAllocator&amp; allocator, size_t sizeClass, FailureAction action)
122 {
123     BumpRangeCache&amp; bumpRangeCache = m_bumpRangeCaches[sizeClass];
124 
125     UniqueLockHolder lock(Heap::mutex());
126     m_deallocator.processObjectLog(lock);
127     m_heap.allocateSmallBumpRanges(lock, sizeClass, allocator, bumpRangeCache, m_deallocator.lineCache(lock), action);
128 }
129 
130 BINLINE void Allocator::refillAllocator(BumpAllocator&amp; allocator, size_t sizeClass, FailureAction action)
131 {
132     BumpRangeCache&amp; bumpRangeCache = m_bumpRangeCaches[sizeClass];
133     if (!bumpRangeCache.size())
134         return refillAllocatorSlowCase(allocator, sizeClass, action);
135     return allocator.refill(bumpRangeCache.pop());
136 }
137 
138 BNO_INLINE void* Allocator::allocateLarge(size_t size, FailureAction action)
139 {
140     UniqueLockHolder lock(Heap::mutex());
141     return m_heap.allocateLarge(lock, alignment, size, action);
142 }
143 
144 BNO_INLINE void* Allocator::allocateLogSizeClass(size_t size, FailureAction action)
145 {
146     size_t sizeClass = bmalloc::sizeClass(size);
147     BumpAllocator&amp; allocator = m_bumpAllocators[sizeClass];
148     if (!allocator.canAllocate())
149         refillAllocator(allocator, sizeClass, action);
150     if (action == FailureAction::ReturnNull &amp;&amp; !allocator.canAllocate())
151         return nullptr;
152     return allocator.allocate();
153 }
154 
155 void* Allocator::allocateSlowCase(size_t size, FailureAction action)
156 {
157     if (size &lt;= maskSizeClassMax) {
158         size_t sizeClass = bmalloc::maskSizeClass(size);
159         BumpAllocator&amp; allocator = m_bumpAllocators[sizeClass];
160         refillAllocator(allocator, sizeClass, action);
161         if (action == FailureAction::ReturnNull &amp;&amp; !allocator.canAllocate())
162             return nullptr;
163         return allocator.allocate();
164     }
165 
166     if (size &lt;= smallMax)
167         return allocateLogSizeClass(size, action);
168 
169     return allocateLarge(size, action);
170 }
171 
172 } // namespace bmalloc
    </pre>
  </body>
</html>
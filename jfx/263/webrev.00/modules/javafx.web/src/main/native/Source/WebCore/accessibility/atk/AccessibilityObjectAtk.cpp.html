<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/accessibility/atk/AccessibilityObjectAtk.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008 Apple Ltd.
  3  * Copyright (C) 2008 Alp Toker &lt;alp@atoker.com&gt;
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;AccessibilityObject.h&quot;
 23 
 24 #include &quot;AXObjectCache.h&quot;
 25 #include &quot;HTMLSpanElement.h&quot;
 26 #include &quot;RenderBlock.h&quot;
 27 #include &quot;RenderInline.h&quot;
 28 #include &quot;RenderIterator.h&quot;
 29 #include &quot;RenderTableCell.h&quot;
 30 #include &quot;RenderText.h&quot;
 31 #include &quot;TextControlInnerElements.h&quot;
 32 #include &quot;WebKitAccessible.h&quot;
 33 #include &lt;glib-object.h&gt;
 34 
 35 #if ENABLE(ACCESSIBILITY)
 36 
 37 namespace WebCore {
 38 
 39 void AccessibilityObject::detachPlatformWrapper(AccessibilityDetachmentType detachmentType)
 40 {
 41     if (detachmentType != AccessibilityDetachmentType::CacheDestroyed) {
 42         if (auto* cache = axObjectCache()) {
 43             cache-&gt;detachWrapper(this, detachmentType);
 44             return;
 45         }
 46     }
 47 
 48     auto* wrapper = this-&gt;wrapper();
 49     ASSERT(wrapper);
 50     webkitAccessibleDetach(WEBKIT_ACCESSIBLE(wrapper));
 51 }
 52 
 53 bool AccessibilityObject::accessibilityIgnoreAttachment() const
 54 {
 55     return false;
 56 }
 57 
 58 AccessibilityObjectInclusion AccessibilityObject::accessibilityPlatformIncludesObject() const
 59 {
 60     AccessibilityObject* parent = parentObject();
 61     if (!parent)
 62         return AccessibilityObjectInclusion::DefaultBehavior;
 63 
 64     // If the author has provided a role, platform-specific inclusion likely doesn&#39;t apply.
 65     if (ariaRoleAttribute() != AccessibilityRole::Unknown)
 66         return AccessibilityObjectInclusion::DefaultBehavior;
 67 
 68     AccessibilityRole role = roleValue();
 69     // We expose the slider as a whole but not its value indicator.
 70     if (role == AccessibilityRole::SliderThumb)
 71         return AccessibilityObjectInclusion::IgnoreObject;
 72 
 73     // When a list item is made up entirely of children (e.g. paragraphs)
 74     // the list item gets ignored. We need it.
 75     if (isGroup() &amp;&amp; parent-&gt;isList())
 76         return AccessibilityObjectInclusion::IncludeObject;
 77 
 78     // Entries and password fields have extraneous children which we want to ignore.
 79     if (parent-&gt;isPasswordField() || parent-&gt;isTextControl())
 80         return AccessibilityObjectInclusion::IgnoreObject;
 81 
 82     // Include all tables, even layout tables. The AT can decide what to do with each.
 83     if (role == AccessibilityRole::Cell || role == AccessibilityRole::Table || role == AccessibilityRole::ColumnHeader || role == AccessibilityRole::RowHeader)
 84         return AccessibilityObjectInclusion::IncludeObject;
 85 
 86     // The object containing the text should implement AtkText itself.
 87     // However, WebCore also maps ARIA&#39;s &quot;text&quot; role to the StaticTextRole.
 88     if (role == AccessibilityRole::StaticText)
 89         return ariaRoleAttribute() != AccessibilityRole::Unknown ? AccessibilityObjectInclusion::DefaultBehavior : AccessibilityObjectInclusion::IgnoreObject;
 90 
 91     // Include all list items, regardless they have or not inline children
 92     if (role == AccessibilityRole::ListItem)
 93         return AccessibilityObjectInclusion::IncludeObject;
 94 
 95     // Bullets/numbers for list items shouldn&#39;t be exposed as AtkObjects.
 96     if (role == AccessibilityRole::ListMarker)
 97         return AccessibilityObjectInclusion::IgnoreObject;
 98 
 99     // Never expose an unknown object, since AT&#39;s won&#39;t know what to
100     // do with them. This is what is done on the Mac as well.
101     if (role == AccessibilityRole::Unknown)
102         return AccessibilityObjectInclusion::IgnoreObject;
103 
104     if (role == AccessibilityRole::Inline)
105         return AccessibilityObjectInclusion::IncludeObject;
106 
107     // Lines past this point only make sense for AccessibilityRenderObjects.
108     RenderObject* renderObject = renderer();
109     if (!renderObject)
110         return AccessibilityObjectInclusion::DefaultBehavior;
111 
112     // We always want to include paragraphs that have rendered content.
113     // WebCore Accessibility does so unless there is a RenderBlock child.
114     if (role == AccessibilityRole::Paragraph) {
115         auto child = childrenOfType&lt;RenderBlock&gt;(downcast&lt;RenderElement&gt;(*renderObject)).first();
116         return child ? AccessibilityObjectInclusion::IncludeObject : AccessibilityObjectInclusion::DefaultBehavior;
117     }
118 
119     // We always want to include table cells (layout and CSS) that have rendered text content.
120     if (is&lt;RenderTableCell&gt;(renderObject)) {
121         for (const auto&amp; child : childrenOfType&lt;RenderObject&gt;(downcast&lt;RenderElement&gt;(*renderObject))) {
122             if (is&lt;RenderInline&gt;(child) || is&lt;RenderText&gt;(child) || is&lt;HTMLSpanElement&gt;(child.node()))
123                 return AccessibilityObjectInclusion::IncludeObject;
124         }
125         return AccessibilityObjectInclusion::DefaultBehavior;
126     }
127 
128     if (renderObject-&gt;isAnonymousBlock()) {
129         // The text displayed by an ARIA menu item is exposed through the accessible name.
130         if (parent-&gt;isMenuItem())
131             return AccessibilityObjectInclusion::IgnoreObject;
132 
133         // The text displayed in headings is typically exposed in the heading itself.
134         if (parent-&gt;isHeading())
135             return AccessibilityObjectInclusion::IgnoreObject;
136 
137         // The text displayed in list items is typically exposed in the list item itself.
138         if (parent-&gt;isListItem())
139             return AccessibilityObjectInclusion::IgnoreObject;
140 
141         // The text displayed in links is typically exposed in the link itself.
142         if (parent-&gt;isLink())
143             return AccessibilityObjectInclusion::IgnoreObject;
144 
145         // FIXME: This next one needs some further consideration. But paragraphs are not
146         // typically huge (like divs). And ignoring anonymous block children of paragraphs
147         // will preserve existing behavior.
148         if (parent-&gt;roleValue() == AccessibilityRole::Paragraph)
149             return AccessibilityObjectInclusion::IgnoreObject;
150 
151         return AccessibilityObjectInclusion::DefaultBehavior;
152     }
153 
154     Node* node = renderObject-&gt;node();
155     if (!node)
156         return AccessibilityObjectInclusion::DefaultBehavior;
157 
158     // We don&#39;t want &lt;span&gt; elements to show up in the accessibility hierarchy unless
159     // we have good reasons for that (e.g. focusable or visible because of containing
160     // a meaningful accessible name, maybe set through ARIA), so we can use
161     // atk_component_grab_focus() to set the focus to it.
162     if (is&lt;HTMLSpanElement&gt;(node) &amp;&amp; !canSetFocusAttribute() &amp;&amp; !hasAttributesRequiredForInclusion() &amp;&amp; !supportsARIAAttributes())
163         return AccessibilityObjectInclusion::IgnoreObject;
164 
165     // If we include TextControlInnerTextElement children, changes to those children
166     // will result in focus and text notifications that suggest the user is no longer
167     // in the control. This can be especially problematic for screen reader users with
168     // key echo enabled when typing in a password input.
169     if (is&lt;TextControlInnerTextElement&gt;(node))
170         return AccessibilityObjectInclusion::IgnoreObject;
171 
172     return AccessibilityObjectInclusion::DefaultBehavior;
173 }
174 
175 bool AccessibilityObject::allowsTextRanges() const
176 {
177     // Check type for the AccessibilityObject.
178     if (isTextControl() || isWebArea() || isGroup() || isLink() || isHeading() || isListItem() || isTableCell())
179         return true;
180 
181     // Check roles as the last fallback mechanism.
182     AccessibilityRole role = roleValue();
183     return role == AccessibilityRole::Paragraph || role == AccessibilityRole::Label || role == AccessibilityRole::Div || role == AccessibilityRole::Form || role == AccessibilityRole::Pre;
184 }
185 
186 unsigned AccessibilityObject::getLengthForTextRange() const
187 {
188     unsigned textLength = text().length();
189 
190     if (textLength)
191         return textLength;
192 
193     // Gtk ATs need this for all text objects; not just text controls.
194     Node* node = this-&gt;node();
195     RenderObject* renderer = node ? node-&gt;renderer() : nullptr;
196     if (is&lt;RenderText&gt;(renderer))
197         textLength = downcast&lt;RenderText&gt;(*renderer).text().length();
198 
199     // Get the text length from the elements under the
200     // accessibility object if the value is still zero.
201     if (!textLength &amp;&amp; allowsTextRanges())
202         textLength = textUnderElement(AccessibilityTextUnderElementMode(AccessibilityTextUnderElementMode::TextUnderElementModeIncludeAllChildren)).length();
203 
204     return textLength;
205 }
206 
207 } // namespace WebCore
208 
209 #endif // ENABLE(ACCESSIBILITY)
    </pre>
  </body>
</html>
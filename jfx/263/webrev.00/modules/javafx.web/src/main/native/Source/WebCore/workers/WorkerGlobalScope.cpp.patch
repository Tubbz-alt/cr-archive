diff a/modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerGlobalScope.cpp b/modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerGlobalScope.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerGlobalScope.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerGlobalScope.cpp
@@ -26,29 +26,33 @@
  */
 
 #include "config.h"
 #include "WorkerGlobalScope.h"
 
+#include "CSSValueList.h"
+#include "CSSValuePool.h"
 #include "ContentSecurityPolicy.h"
 #include "Crypto.h"
 #include "IDBConnectionProxy.h"
 #include "ImageBitmapOptions.h"
 #include "InspectorInstrumentation.h"
-#include "Microtasks.h"
 #include "Performance.h"
 #include "RuntimeEnabledFeatures.h"
 #include "ScheduledAction.h"
 #include "ScriptSourceCode.h"
 #include "SecurityOrigin.h"
 #include "SecurityOriginPolicy.h"
 #include "ServiceWorkerGlobalScope.h"
 #include "SocketProvider.h"
+#include "WorkerEventLoop.h"
 #include "WorkerInspectorController.h"
 #include "WorkerLoaderProxy.h"
 #include "WorkerLocation.h"
+#include "WorkerMessagingProxy.h"
 #include "WorkerNavigator.h"
 #include "WorkerReportingProxy.h"
+#include "WorkerSWClientConnection.h"
 #include "WorkerScriptLoader.h"
 #include "WorkerThread.h"
 #include <JavaScriptCore/ScriptArguments.h>
 #include <JavaScriptCore/ScriptCallStack.h>
 #include <wtf/IsoMallocInlines.h>
@@ -56,28 +60,26 @@
 namespace WebCore {
 using namespace Inspector;
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(WorkerGlobalScope);
 
-WorkerGlobalScope::WorkerGlobalScope(const URL& url, Ref<SecurityOrigin>&& origin, const String& identifier, const String& userAgent, bool isOnline, WorkerThread& thread, bool shouldBypassMainWorldContentSecurityPolicy, Ref<SecurityOrigin>&& topOrigin, MonotonicTime timeOrigin, IDBClient::IDBConnectionProxy* connectionProxy, SocketProvider* socketProvider, PAL::SessionID sessionID)
-    : m_url(url)
-    , m_identifier(identifier)
-    , m_userAgent(userAgent)
+WorkerGlobalScope::WorkerGlobalScope(const WorkerParameters& params, Ref<SecurityOrigin>&& origin, WorkerThread& thread, Ref<SecurityOrigin>&& topOrigin, IDBClient::IDBConnectionProxy* connectionProxy, SocketProvider* socketProvider)
+    : m_url(params.scriptURL)
+    , m_identifier(params.identifier)
+    , m_userAgent(params.userAgent)
     , m_thread(thread)
     , m_script(makeUnique<WorkerScriptController>(this))
     , m_inspectorController(makeUnique<WorkerInspectorController>(*this))
-    , m_microtaskQueue(makeUnique<MicrotaskQueue>(m_script->vm()))
-    , m_isOnline(isOnline)
-    , m_shouldBypassMainWorldContentSecurityPolicy(shouldBypassMainWorldContentSecurityPolicy)
-    , m_eventQueue(*this)
+    , m_isOnline(params.isOnline)
+    , m_shouldBypassMainWorldContentSecurityPolicy(params.shouldBypassMainWorldContentSecurityPolicy)
     , m_topOrigin(WTFMove(topOrigin))
 #if ENABLE(INDEXED_DATABASE)
     , m_connectionProxy(connectionProxy)
 #endif
     , m_socketProvider(socketProvider)
-    , m_performance(Performance::create(this, timeOrigin))
-    , m_sessionID(sessionID)
+    , m_performance(Performance::create(this, params.timeOrigin))
+    , m_referrerPolicy(params.referrerPolicy)
 {
 #if !ENABLE(INDEXED_DATABASE)
     UNUSED_PARAM(connectionProxy);
 #endif
 
@@ -101,10 +103,22 @@
 
     // Notify proxy that we are going away. This can free the WorkerThread object, so do not access it after this.
     thread().workerReportingProxy().workerGlobalScopeDestroyed();
 }
 
+EventLoopTaskGroup& WorkerGlobalScope::eventLoop()
+{
+    ASSERT(isContextThread());
+    if (UNLIKELY(!m_defaultTaskGroup)) {
+        m_eventLoop = WorkerEventLoop::create(*this);
+        m_defaultTaskGroup = makeUnique<EventLoopTaskGroup>(*m_eventLoop);
+        if (activeDOMObjectsAreStopped())
+            m_defaultTaskGroup->stopAndDiscardAllTasks();
+    }
+    return *m_defaultTaskGroup;
+}
+
 String WorkerGlobalScope::origin() const
 {
     auto* securityOrigin = this->securityOrigin();
     return securityOrigin ? securityOrigin->toString() : emptyString();
 }
@@ -113,10 +127,12 @@
 {
 #if ENABLE(INDEXED_DATABASE)
     stopIndexedDatabase();
 #endif
 
+    if (m_defaultTaskGroup)
+        m_defaultTaskGroup->stopAndDiscardAllTasks();
     stopActiveDOMObjects();
 
     if (m_cacheStorageConnection)
         m_cacheStorageConnection->clearPendingRequests();
 
@@ -125,11 +141,12 @@
     // Event listeners would keep DOMWrapperWorld objects alive for too long. Also, they have references to JS objects,
     // which become dangling once Heap is destroyed.
     removeAllEventListeners();
 
     // MicrotaskQueue and RejectedPromiseTracker reference Heap.
-    m_microtaskQueue = nullptr;
+    if (m_eventLoop)
+        m_eventLoop->clearMicrotaskQueue();
     removeRejectedPromiseTracker();
 }
 
 void WorkerGlobalScope::removeAllEventListeners()
 {
@@ -149,11 +166,11 @@
 void WorkerGlobalScope::applyContentSecurityPolicyResponseHeaders(const ContentSecurityPolicyResponseHeaders& contentSecurityPolicyResponseHeaders)
 {
     contentSecurityPolicy()->didReceiveHeaders(contentSecurityPolicyResponseHeaders, String { });
 }
 
-URL WorkerGlobalScope::completeURL(const String& url) const
+URL WorkerGlobalScope::completeURL(const String& url, ForceUTF8) const
 {
     // Always return a null URL when passed a null string.
     // FIXME: Should we change the URL constructor to have this behavior?
     if (url.isNull())
         return URL();
@@ -198,10 +215,26 @@
     if (m_connectionProxy)
         m_connectionProxy->forgetActivityForCurrentThread();
 #endif
 }
 
+void WorkerGlobalScope::suspend()
+{
+#if ENABLE(INDEXED_DATABASE_IN_WORKERS)
+    if (m_connectionProxy)
+        m_connectionProxy->setContextSuspended(*scriptExecutionContext(), true);
+#endif
+}
+
+void WorkerGlobalScope::resume()
+{
+#if ENABLE(INDEXED_DATABASE_IN_WORKERS)
+    if (m_connectionProxy)
+        m_connectionProxy->setContextSuspended(*scriptExecutionContext(), false);
+#endif
+}
+
 #endif // ENABLE(INDEXED_DATABASE)
 
 WorkerLocation& WorkerGlobalScope::location() const
 {
     if (!m_location)
@@ -243,11 +276,11 @@
 void WorkerGlobalScope::postTask(Task&& task)
 {
     thread().runLoop().postTask(WTFMove(task));
 }
 
-ExceptionOr<int> WorkerGlobalScope::setTimeout(JSC::ExecState& state, std::unique_ptr<ScheduledAction> action, int timeout, Vector<JSC::Strong<JSC::Unknown>>&& arguments)
+ExceptionOr<int> WorkerGlobalScope::setTimeout(JSC::JSGlobalObject& state, std::unique_ptr<ScheduledAction> action, int timeout, Vector<JSC::Strong<JSC::Unknown>>&& arguments)
 {
     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
     if (action->type() == ScheduledAction::Type::Code) {
         if (!contentSecurityPolicy()->allowEval(&state))
             return 0;
@@ -261,11 +294,11 @@
 void WorkerGlobalScope::clearTimeout(int timeoutId)
 {
     DOMTimer::removeById(*this, timeoutId);
 }
 
-ExceptionOr<int> WorkerGlobalScope::setInterval(JSC::ExecState& state, std::unique_ptr<ScheduledAction> action, int timeout, Vector<JSC::Strong<JSC::Unknown>>&& arguments)
+ExceptionOr<int> WorkerGlobalScope::setInterval(JSC::JSGlobalObject& state, std::unique_ptr<ScheduledAction> action, int timeout, Vector<JSC::Strong<JSC::Unknown>>&& arguments)
 {
     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
     if (action->type() == ScheduledAction::Type::Code) {
         if (!contentSecurityPolicy()->allowEval(&state))
             return 0;
@@ -355,11 +388,11 @@
 void WorkerGlobalScope::addConsoleMessage(MessageSource source, MessageLevel level, const String& message, unsigned long requestIdentifier)
 {
     addMessage(source, level, message, { }, 0, 0, nullptr, nullptr, requestIdentifier);
 }
 
-void WorkerGlobalScope::addMessage(MessageSource source, MessageLevel level, const String& messageText, const String& sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr<ScriptCallStack>&& callStack, JSC::ExecState* state, unsigned long requestIdentifier)
+void WorkerGlobalScope::addMessage(MessageSource source, MessageLevel level, const String& messageText, const String& sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr<ScriptCallStack>&& callStack, JSC::JSGlobalObject* state, unsigned long requestIdentifier)
 {
     if (!isContextThread()) {
         postTask(AddConsoleMessageTask(source, level, messageText));
         return;
     }
@@ -380,15 +413,10 @@
 bool WorkerGlobalScope::isJSExecutionForbidden() const
 {
     return m_script->isExecutionForbidden();
 }
 
-WorkerEventQueue& WorkerGlobalScope::eventQueue() const
-{
-    return m_eventQueue;
-}
-
 #if ENABLE(WEB_CRYPTO)
 
 class CryptoBufferContainer : public ThreadSafeRefCounted<CryptoBufferContainer> {
 public:
     static Ref<CryptoBufferContainer> create() { return adoptRef(*new CryptoBufferContainer); }
@@ -396,52 +424,64 @@
 
 private:
     Vector<uint8_t> m_buffer;
 };
 
+class CryptoBooleanContainer : public ThreadSafeRefCounted<CryptoBooleanContainer> {
+public:
+    static Ref<CryptoBooleanContainer> create() { return adoptRef(*new CryptoBooleanContainer); }
+    bool boolean() const { return m_boolean; }
+    void setBoolean(bool boolean) { m_boolean = boolean; }
+
+private:
+    std::atomic<bool> m_boolean { false };
+};
+
 bool WorkerGlobalScope::wrapCryptoKey(const Vector<uint8_t>& key, Vector<uint8_t>& wrappedKey)
 {
-    bool result = false;
-    std::atomic<bool> done = false;
-    auto container = CryptoBufferContainer::create();
-    m_thread.workerLoaderProxy().postTaskToLoader([&result, key, containerRef = container.copyRef(), &done, workerGlobalScope = this](ScriptExecutionContext& context) {
-        result = context.wrapCryptoKey(key, containerRef->buffer());
-        done = true;
-        workerGlobalScope->postTask([](ScriptExecutionContext& context) {
+    Ref<WorkerGlobalScope> protectedThis(*this);
+    auto resultContainer = CryptoBooleanContainer::create();
+    auto doneContainer = CryptoBooleanContainer::create();
+    auto wrappedKeyContainer = CryptoBufferContainer::create();
+    m_thread.workerLoaderProxy().postTaskToLoader([resultContainer = resultContainer.copyRef(), key, wrappedKeyContainer = wrappedKeyContainer.copyRef(), doneContainer = doneContainer.copyRef(), workerMessagingProxy = makeRef(downcast<WorkerMessagingProxy>(m_thread.workerLoaderProxy()))](ScriptExecutionContext& context) {
+        resultContainer->setBoolean(context.wrapCryptoKey(key, wrappedKeyContainer->buffer()));
+        doneContainer->setBoolean(true);
+        workerMessagingProxy->postTaskForModeToWorkerGlobalScope([](ScriptExecutionContext& context) {
             ASSERT_UNUSED(context, context.isWorkerGlobalScope());
-        });
+        }, WorkerRunLoop::defaultMode());
     });
 
     auto waitResult = MessageQueueMessageReceived;
-    while (!done && waitResult != MessageQueueTerminated)
+    while (!doneContainer->boolean() && waitResult != MessageQueueTerminated)
         waitResult = m_thread.runLoop().runInMode(this, WorkerRunLoop::defaultMode());
 
-    if (done)
-        wrappedKey.swap(container->buffer());
-    return result;
+    if (doneContainer->boolean())
+        wrappedKey.swap(wrappedKeyContainer->buffer());
+    return resultContainer->boolean();
 }
 
 bool WorkerGlobalScope::unwrapCryptoKey(const Vector<uint8_t>& wrappedKey, Vector<uint8_t>& key)
 {
-    bool result = false;
-    std::atomic<bool> done = false;
-    auto container = CryptoBufferContainer::create();
-    m_thread.workerLoaderProxy().postTaskToLoader([&result, wrappedKey, containerRef = container.copyRef(), &done, workerGlobalScope = this](ScriptExecutionContext& context) {
-        result = context.unwrapCryptoKey(wrappedKey, containerRef->buffer());
-        done = true;
-        workerGlobalScope->postTask([](ScriptExecutionContext& context) {
+    Ref<WorkerGlobalScope> protectedThis(*this);
+    auto resultContainer = CryptoBooleanContainer::create();
+    auto doneContainer = CryptoBooleanContainer::create();
+    auto keyContainer = CryptoBufferContainer::create();
+    m_thread.workerLoaderProxy().postTaskToLoader([resultContainer = resultContainer.copyRef(), wrappedKey, keyContainer = keyContainer.copyRef(), doneContainer = doneContainer.copyRef(), workerMessagingProxy = makeRef(downcast<WorkerMessagingProxy>(m_thread.workerLoaderProxy()))](ScriptExecutionContext& context) {
+        resultContainer->setBoolean(context.unwrapCryptoKey(wrappedKey, keyContainer->buffer()));
+        doneContainer->setBoolean(true);
+        workerMessagingProxy->postTaskForModeToWorkerGlobalScope([](ScriptExecutionContext& context) {
             ASSERT_UNUSED(context, context.isWorkerGlobalScope());
-        });
+        }, WorkerRunLoop::defaultMode());
     });
 
     auto waitResult = MessageQueueMessageReceived;
-    while (!done && waitResult != MessageQueueTerminated)
+    while (!doneContainer->boolean() && waitResult != MessageQueueTerminated)
         waitResult = m_thread.runLoop().runInMode(this, WorkerRunLoop::defaultMode());
 
-    if (done)
-        key.swap(container->buffer());
-    return result;
+    if (doneContainer->boolean())
+        key.swap(keyContainer->buffer());
+    return resultContainer->boolean();
 }
 
 #endif // ENABLE(WEB_CRYPTO)
 
 Crypto& WorkerGlobalScope::crypto()
@@ -461,16 +501,44 @@
     if (!m_cacheStorageConnection)
         m_cacheStorageConnection = WorkerCacheStorageConnection::create(*this);
     return *m_cacheStorageConnection;
 }
 
+MessagePortChannelProvider& WorkerGlobalScope::messagePortChannelProvider()
+{
+    if (!m_messagePortChannelProvider)
+        m_messagePortChannelProvider = makeUnique<WorkerMessagePortChannelProvider>(*this);
+    return *m_messagePortChannelProvider;
+}
+
+#if ENABLE(SERVICE_WORKER)
+WorkerSWClientConnection& WorkerGlobalScope::swClientConnection()
+{
+    if (!m_swClientConnection)
+        m_swClientConnection = WorkerSWClientConnection::create(*this);
+    return *m_swClientConnection;
+}
+#endif
+
 void WorkerGlobalScope::createImageBitmap(ImageBitmap::Source&& source, ImageBitmapOptions&& options, ImageBitmap::Promise&& promise)
 {
     ImageBitmap::createPromise(*this, WTFMove(source), WTFMove(options), WTFMove(promise));
 }
 
 void WorkerGlobalScope::createImageBitmap(ImageBitmap::Source&& source, int sx, int sy, int sw, int sh, ImageBitmapOptions&& options, ImageBitmap::Promise&& promise)
 {
     ImageBitmap::createPromise(*this, WTFMove(source), WTFMove(options), sx, sy, sw, sh, WTFMove(promise));
 }
 
+CSSValuePool& WorkerGlobalScope::cssValuePool()
+{
+    if (!m_cssValuePool)
+        m_cssValuePool = makeUnique<CSSValuePool>();
+    return *m_cssValuePool;
+}
+
+ReferrerPolicy WorkerGlobalScope::referrerPolicy() const
+{
+    return m_referrerPolicy;
+}
+
 } // namespace WebCore

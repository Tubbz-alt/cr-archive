<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCPeerConnectionBackend.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LibWebRTCObservers.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LibWebRTCPeerConnectionBackend.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCPeerConnectionBackend.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 28 #if USE(LIBWEBRTC)
 29 
 30 #include &quot;Document.h&quot;
 31 #include &quot;IceCandidate.h&quot;
 32 #include &quot;LibWebRTCDataChannelHandler.h&quot;
 33 #include &quot;LibWebRTCMediaEndpoint.h&quot;
 34 #include &quot;LibWebRTCRtpReceiverBackend.h&quot;
 35 #include &quot;LibWebRTCRtpSenderBackend.h&quot;
 36 #include &quot;LibWebRTCRtpTransceiverBackend.h&quot;
 37 #include &quot;MediaEndpointConfiguration.h&quot;
 38 #include &quot;Page.h&quot;
 39 #include &quot;RTCIceCandidate.h&quot;
 40 #include &quot;RTCPeerConnection.h&quot;
 41 #include &quot;RTCRtpCapabilities.h&quot;
 42 #include &quot;RTCRtpReceiver.h&quot;
 43 #include &quot;RTCSessionDescription.h&quot;
 44 #include &quot;RealtimeIncomingAudioSource.h&quot;
 45 #include &quot;RealtimeIncomingVideoSource.h&quot;
 46 #include &quot;RealtimeOutgoingAudioSource.h&quot;
 47 #include &quot;RealtimeOutgoingVideoSource.h&quot;
<span class="line-removed"> 48 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
 49 #include &quot;Settings.h&quot;
 50 
 51 namespace WebCore {
 52 
 53 static std::unique_ptr&lt;PeerConnectionBackend&gt; createLibWebRTCPeerConnectionBackend(RTCPeerConnection&amp; peerConnection)
 54 {
 55     if (!LibWebRTCProvider::webRTCAvailable())
 56         return nullptr;
 57 
 58     auto* page = downcast&lt;Document&gt;(*peerConnection.scriptExecutionContext()).page();
 59     if (!page)
 60         return nullptr;
 61 
 62     page-&gt;libWebRTCProvider().setEnableWebRTCEncryption(page-&gt;settings().webRTCEncryptionEnabled());
 63 
 64     return makeUnique&lt;LibWebRTCPeerConnectionBackend&gt;(peerConnection, page-&gt;libWebRTCProvider());
 65 }
 66 
 67 CreatePeerConnectionBackend PeerConnectionBackend::create = createLibWebRTCPeerConnectionBackend;
 68 
</pre>
<hr />
<pre>
 73         return { };
 74     return page-&gt;libWebRTCProvider().receiverCapabilities(kind);
 75 }
 76 
 77 Optional&lt;RTCRtpCapabilities&gt; PeerConnectionBackend::senderCapabilities(ScriptExecutionContext&amp; context, const String&amp; kind)
 78 {
 79     auto* page = downcast&lt;Document&gt;(context).page();
 80     if (!page)
 81         return { };
 82     return page-&gt;libWebRTCProvider().senderCapabilities(kind);
 83 }
 84 
 85 LibWebRTCPeerConnectionBackend::LibWebRTCPeerConnectionBackend(RTCPeerConnection&amp; peerConnection, LibWebRTCProvider&amp; provider)
 86     : PeerConnectionBackend(peerConnection)
 87     , m_endpoint(LibWebRTCMediaEndpoint::create(*this, provider))
 88 {
 89 }
 90 
 91 LibWebRTCPeerConnectionBackend::~LibWebRTCPeerConnectionBackend() = default;
 92 










 93 static inline webrtc::PeerConnectionInterface::BundlePolicy bundlePolicyfromConfiguration(const MediaEndpointConfiguration&amp; configuration)
 94 {
 95     switch (configuration.bundlePolicy) {
 96     case RTCBundlePolicy::MaxCompat:
 97         return webrtc::PeerConnectionInterface::kBundlePolicyMaxCompat;
 98     case RTCBundlePolicy::MaxBundle:
 99         return webrtc::PeerConnectionInterface::kBundlePolicyMaxBundle;
100     case RTCBundlePolicy::Balanced:
101         return webrtc::PeerConnectionInterface::kBundlePolicyBalanced;
102     }
103 
104     ASSERT_NOT_REACHED();
105     return webrtc::PeerConnectionInterface::kBundlePolicyMaxCompat;
106 }
107 
108 static inline webrtc::PeerConnectionInterface::RtcpMuxPolicy rtcpMuxPolicyfromConfiguration(const MediaEndpointConfiguration&amp; configuration)
109 {
110     switch (configuration.rtcpMuxPolicy) {
111     case RTCPMuxPolicy::Negotiate:
112         return webrtc::PeerConnectionInterface::kRtcpMuxPolicyNegotiate;
</pre>
<hr />
<pre>
225                 m_endpoint-&gt;addIceCandidate(*candidate);
226         }
227         m_isRemoteDescriptionSet = true;
228     }
229 }
230 
231 void LibWebRTCPeerConnectionBackend::doCreateOffer(RTCOfferOptions&amp;&amp; options)
232 {
233     m_endpoint-&gt;doCreateOffer(options);
234 }
235 
236 void LibWebRTCPeerConnectionBackend::doCreateAnswer(RTCAnswerOptions&amp;&amp;)
237 {
238     if (!m_isRemoteDescriptionSet) {
239         createAnswerFailed(Exception { InvalidStateError, &quot;No remote description set&quot; });
240         return;
241     }
242     m_endpoint-&gt;doCreateAnswer();
243 }
244 





245 void LibWebRTCPeerConnectionBackend::doStop()
246 {
247     m_endpoint-&gt;stop();
248     m_pendingReceivers.clear();
249 }
250 
251 void LibWebRTCPeerConnectionBackend::doAddIceCandidate(RTCIceCandidate&amp; candidate)
252 {
253     webrtc::SdpParseError error;
254     int sdpMLineIndex = candidate.sdpMLineIndex() ? candidate.sdpMLineIndex().value() : 0;
255     std::unique_ptr&lt;webrtc::IceCandidateInterface&gt; rtcCandidate(webrtc::CreateIceCandidate(candidate.sdpMid().utf8().data(), sdpMLineIndex, candidate.candidate().utf8().data(), &amp;error));
256 
257     if (!rtcCandidate) {
258         addIceCandidateFailed(Exception { OperationError, String::fromUTF8(error.description.data(), error.description.length()) });
259         return;
260     }
261 
262     // libwebrtc does not like that ice candidates are set before the description.
263     if (!m_isLocalDescriptionSet || !m_isRemoteDescriptionSet)
264         m_pendingCandidates.append(WTFMove(rtcCandidate));
</pre>
<hr />
<pre>
382 }
383 
384 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCPeerConnectionBackend::remoteDescription() const
385 {
386     return m_endpoint-&gt;remoteDescription();
387 }
388 
389 static inline RefPtr&lt;RTCRtpSender&gt; findExistingSender(const Vector&lt;RefPtr&lt;RTCRtpTransceiver&gt;&gt;&amp; transceivers, LibWebRTCRtpSenderBackend&amp; senderBackend)
390 {
391     ASSERT(senderBackend.rtcSender());
392     for (auto&amp; transceiver : transceivers) {
393         auto&amp; sender = transceiver-&gt;sender();
394         if (!sender.isStopped() &amp;&amp; senderBackend.rtcSender() == backendFromRTPSender(sender).rtcSender())
395             return makeRef(sender);
396     }
397     return nullptr;
398 }
399 
400 ExceptionOr&lt;Ref&lt;RTCRtpSender&gt;&gt; LibWebRTCPeerConnectionBackend::addTrack(MediaStreamTrack&amp; track, Vector&lt;String&gt;&amp;&amp; mediaStreamIds)
401 {
<span class="line-modified">402     if (RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled()) {</span>
<span class="line-modified">403         auto senderBackend = makeUnique&lt;LibWebRTCRtpSenderBackend&gt;(*this, nullptr);</span>
<span class="line-modified">404         if (!m_endpoint-&gt;addTrack(*senderBackend, track, mediaStreamIds))</span>
<span class="line-removed">405             return Exception { TypeError, &quot;Unable to add track&quot;_s };</span>
<span class="line-removed">406 </span>
<span class="line-removed">407         if (auto sender = findExistingSender(m_peerConnection.currentTransceivers(), *senderBackend)) {</span>
<span class="line-removed">408             backendFromRTPSender(*sender).takeSource(*senderBackend);</span>
<span class="line-removed">409             sender-&gt;setTrack(makeRef(track));</span>
<span class="line-removed">410             sender-&gt;setMediaStreamIds(WTFMove(mediaStreamIds));</span>
<span class="line-removed">411             return sender.releaseNonNull();</span>
<span class="line-removed">412         }</span>
<span class="line-removed">413 </span>
<span class="line-removed">414         auto transceiverBackend = m_endpoint-&gt;transceiverBackendFromSender(*senderBackend);</span>
<span class="line-removed">415 </span>
<span class="line-removed">416         auto sender = RTCRtpSender::create(*this, makeRef(track), WTFMove(mediaStreamIds), WTFMove(senderBackend));</span>
<span class="line-removed">417         auto receiver = createReceiverForSource(createEmptySource(track.kind(), createCanonicalUUIDString()), transceiverBackend-&gt;createReceiverBackend());</span>
<span class="line-removed">418         auto transceiver = RTCRtpTransceiver::create(sender.copyRef(), WTFMove(receiver), WTFMove(transceiverBackend));</span>
<span class="line-removed">419         m_peerConnection.addInternalTransceiver(WTFMove(transceiver));</span>
<span class="line-removed">420         return sender;</span>
<span class="line-removed">421     }</span>
<span class="line-removed">422 </span>
<span class="line-removed">423     RTCRtpSender* sender = nullptr;</span>
<span class="line-removed">424     // Reuse an existing sender with the same track kind if it has never been used to send before.</span>
<span class="line-removed">425     for (auto&amp; transceiver : m_peerConnection.currentTransceivers()) {</span>
<span class="line-removed">426         auto&amp; existingSender = transceiver-&gt;sender();</span>
<span class="line-removed">427         if (!existingSender.isStopped() &amp;&amp; existingSender.trackKind() == track.kind() &amp;&amp; existingSender.trackId().isNull() &amp;&amp; !transceiver-&gt;hasSendingDirection()) {</span>
<span class="line-removed">428             existingSender.setTrack(makeRef(track));</span>
<span class="line-removed">429             existingSender.setMediaStreamIds(WTFMove(mediaStreamIds));</span>
<span class="line-removed">430             transceiver-&gt;enableSendingDirection();</span>
<span class="line-removed">431             sender = &amp;existingSender;</span>
<span class="line-removed">432 </span>
<span class="line-removed">433             break;</span>
<span class="line-removed">434         }</span>
<span class="line-removed">435     }</span>
<span class="line-removed">436 </span>
<span class="line-removed">437     if (!sender) {</span>
<span class="line-removed">438         const String&amp; trackKind = track.kind();</span>
<span class="line-removed">439         String trackId = createCanonicalUUIDString();</span>
<span class="line-removed">440 </span>
<span class="line-removed">441         auto senderBackend = makeUnique&lt;LibWebRTCRtpSenderBackend&gt;(*this, nullptr);</span>
<span class="line-removed">442         auto newSender = RTCRtpSender::create(*this, makeRef(track), Vector&lt;String&gt; { mediaStreamIds }, WTFMove(senderBackend));</span>
<span class="line-removed">443         auto receiver = createReceiver(trackKind, trackId);</span>
<span class="line-removed">444         auto transceiver = RTCRtpTransceiver::create(WTFMove(newSender), WTFMove(receiver), nullptr);</span>
445 
<span class="line-modified">446         sender = &amp;transceiver-&gt;sender();</span>
<span class="line-modified">447         m_peerConnection.addInternalTransceiver(WTFMove(transceiver));</span>



448     }
449 
<span class="line-modified">450     if (!m_endpoint-&gt;addTrack(backendFromRTPSender(*sender), track, mediaStreamIds))</span>
<span class="line-removed">451         return Exception { TypeError, &quot;Unable to add track&quot;_s };</span>
452 
<span class="line-modified">453     return makeRef(*sender);</span>




454 }
455 
456 template&lt;typename T&gt;
<span class="line-modified">457 ExceptionOr&lt;Ref&lt;RTCRtpTransceiver&gt;&gt; LibWebRTCPeerConnectionBackend::addUnifiedPlanTransceiver(T&amp;&amp; trackOrKind, const RTCRtpTransceiverInit&amp; init)</span>
458 {
459     auto backends = m_endpoint-&gt;addTransceiver(trackOrKind, init);
460     if (!backends)
461         return Exception { InvalidAccessError, &quot;Unable to add transceiver&quot;_s };
462 
463     auto sender = RTCRtpSender::create(*this, WTFMove(trackOrKind), Vector&lt;String&gt; { }, WTFMove(backends-&gt;senderBackend));
464     auto receiver = createReceiverForSource(createEmptySource(sender-&gt;trackKind(), createCanonicalUUIDString()), WTFMove(backends-&gt;receiverBackend));
465     auto transceiver = RTCRtpTransceiver::create(WTFMove(sender), WTFMove(receiver), WTFMove(backends-&gt;transceiverBackend));
466     m_peerConnection.addInternalTransceiver(transceiver.copyRef());
467     return transceiver;
468 }
469 
470 ExceptionOr&lt;Ref&lt;RTCRtpTransceiver&gt;&gt; LibWebRTCPeerConnectionBackend::addTransceiver(const String&amp; trackKind, const RTCRtpTransceiverInit&amp; init)
471 {
<span class="line-modified">472     if (RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())</span>
<span class="line-removed">473         return addUnifiedPlanTransceiver(String { trackKind }, init);</span>
<span class="line-removed">474 </span>
<span class="line-removed">475     auto senderBackend = makeUnique&lt;LibWebRTCRtpSenderBackend&gt;(*this, nullptr);</span>
<span class="line-removed">476     auto newSender = RTCRtpSender::create(*this, String(trackKind), Vector&lt;String&gt;(), WTFMove(senderBackend));</span>
<span class="line-removed">477     return completeAddTransceiver(WTFMove(newSender), init, createCanonicalUUIDString(), trackKind);</span>
478 }
479 
480 ExceptionOr&lt;Ref&lt;RTCRtpTransceiver&gt;&gt; LibWebRTCPeerConnectionBackend::addTransceiver(Ref&lt;MediaStreamTrack&gt;&amp;&amp; track, const RTCRtpTransceiverInit&amp; init)
481 {
<span class="line-modified">482     if (RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())</span>
<span class="line-removed">483         return addUnifiedPlanTransceiver(WTFMove(track), init);</span>
<span class="line-removed">484 </span>
<span class="line-removed">485     auto senderBackend = makeUnique&lt;LibWebRTCRtpSenderBackend&gt;(*this, nullptr);</span>
<span class="line-removed">486     auto&amp; backend = *senderBackend;</span>
<span class="line-removed">487     auto sender = RTCRtpSender::create(*this, track.copyRef(), Vector&lt;String&gt;(), WTFMove(senderBackend));</span>
<span class="line-removed">488     if (!m_endpoint-&gt;addTrack(backend, track, Vector&lt;String&gt; { }))</span>
<span class="line-removed">489         return Exception { InvalidAccessError, &quot;Unable to add track&quot;_s };</span>
<span class="line-removed">490 </span>
<span class="line-removed">491     return completeAddTransceiver(WTFMove(sender), init, track-&gt;id(), track-&gt;kind());</span>
492 }
493 
494 void LibWebRTCPeerConnectionBackend::setSenderSourceFromTrack(LibWebRTCRtpSenderBackend&amp; sender, MediaStreamTrack&amp; track)
495 {
496     m_endpoint-&gt;setSenderSourceFromTrack(sender, track);
497 }
498 
499 static inline LibWebRTCRtpTransceiverBackend&amp; backendFromRTPTransceiver(RTCRtpTransceiver&amp; transceiver)
500 {
501     return static_cast&lt;LibWebRTCRtpTransceiverBackend&amp;&gt;(*transceiver.backend());
502 }
503 
504 RTCRtpTransceiver* LibWebRTCPeerConnectionBackend::existingTransceiver(WTF::Function&lt;bool(LibWebRTCRtpTransceiverBackend&amp;)&gt;&amp;&amp; matchingFunction)
505 {
506     for (auto&amp; transceiver : m_peerConnection.currentTransceivers()) {
507         if (matchingFunction(backendFromRTPTransceiver(*transceiver)))
508             return transceiver.get();
509     }
510     return nullptr;
511 }
</pre>
<hr />
<pre>
532 void LibWebRTCPeerConnectionBackend::collectTransceivers()
533 {
534     m_endpoint-&gt;collectTransceivers();
535 }
536 
537 void LibWebRTCPeerConnectionBackend::removeTrack(RTCRtpSender&amp; sender)
538 {
539     m_endpoint-&gt;removeTrack(backendFromRTPSender(sender));
540 }
541 
542 void LibWebRTCPeerConnectionBackend::applyRotationForOutgoingVideoSources()
543 {
544     for (auto&amp; transceiver : m_peerConnection.currentTransceivers()) {
545         if (!transceiver-&gt;sender().isStopped()) {
546             if (auto* videoSource = backendFromRTPSender(transceiver-&gt;sender()).videoSource())
547                 videoSource-&gt;setApplyRotation(true);
548         }
549     }
550 }
551 
<span class="line-removed">552 bool LibWebRTCPeerConnectionBackend::shouldOfferAllowToReceive(const char* kind) const</span>
<span class="line-removed">553 {</span>
<span class="line-removed">554     ASSERT(!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled());</span>
<span class="line-removed">555     for (const auto&amp; transceiver : m_peerConnection.currentTransceivers()) {</span>
<span class="line-removed">556         if (transceiver-&gt;sender().trackKind() != kind)</span>
<span class="line-removed">557             continue;</span>
<span class="line-removed">558 </span>
<span class="line-removed">559         if (transceiver-&gt;direction() == RTCRtpTransceiverDirection::Recvonly)</span>
<span class="line-removed">560             return true;</span>
<span class="line-removed">561 </span>
<span class="line-removed">562         if (transceiver-&gt;direction() != RTCRtpTransceiverDirection::Sendrecv)</span>
<span class="line-removed">563             continue;</span>
<span class="line-removed">564 </span>
<span class="line-removed">565         auto* backend = static_cast&lt;LibWebRTCRtpSenderBackend*&gt;(transceiver-&gt;sender().backend());</span>
<span class="line-removed">566         if (backend &amp;&amp; !backend-&gt;rtcSender())</span>
<span class="line-removed">567             return true;</span>
<span class="line-removed">568     }</span>
<span class="line-removed">569     return false;</span>
<span class="line-removed">570 }</span>
<span class="line-removed">571 </span>
572 } // namespace WebCore
573 
574 #endif // USE(LIBWEBRTC)
</pre>
</td>
<td>
<hr />
<pre>
 28 #if USE(LIBWEBRTC)
 29 
 30 #include &quot;Document.h&quot;
 31 #include &quot;IceCandidate.h&quot;
 32 #include &quot;LibWebRTCDataChannelHandler.h&quot;
 33 #include &quot;LibWebRTCMediaEndpoint.h&quot;
 34 #include &quot;LibWebRTCRtpReceiverBackend.h&quot;
 35 #include &quot;LibWebRTCRtpSenderBackend.h&quot;
 36 #include &quot;LibWebRTCRtpTransceiverBackend.h&quot;
 37 #include &quot;MediaEndpointConfiguration.h&quot;
 38 #include &quot;Page.h&quot;
 39 #include &quot;RTCIceCandidate.h&quot;
 40 #include &quot;RTCPeerConnection.h&quot;
 41 #include &quot;RTCRtpCapabilities.h&quot;
 42 #include &quot;RTCRtpReceiver.h&quot;
 43 #include &quot;RTCSessionDescription.h&quot;
 44 #include &quot;RealtimeIncomingAudioSource.h&quot;
 45 #include &quot;RealtimeIncomingVideoSource.h&quot;
 46 #include &quot;RealtimeOutgoingAudioSource.h&quot;
 47 #include &quot;RealtimeOutgoingVideoSource.h&quot;

 48 #include &quot;Settings.h&quot;
 49 
 50 namespace WebCore {
 51 
 52 static std::unique_ptr&lt;PeerConnectionBackend&gt; createLibWebRTCPeerConnectionBackend(RTCPeerConnection&amp; peerConnection)
 53 {
 54     if (!LibWebRTCProvider::webRTCAvailable())
 55         return nullptr;
 56 
 57     auto* page = downcast&lt;Document&gt;(*peerConnection.scriptExecutionContext()).page();
 58     if (!page)
 59         return nullptr;
 60 
 61     page-&gt;libWebRTCProvider().setEnableWebRTCEncryption(page-&gt;settings().webRTCEncryptionEnabled());
 62 
 63     return makeUnique&lt;LibWebRTCPeerConnectionBackend&gt;(peerConnection, page-&gt;libWebRTCProvider());
 64 }
 65 
 66 CreatePeerConnectionBackend PeerConnectionBackend::create = createLibWebRTCPeerConnectionBackend;
 67 
</pre>
<hr />
<pre>
 72         return { };
 73     return page-&gt;libWebRTCProvider().receiverCapabilities(kind);
 74 }
 75 
 76 Optional&lt;RTCRtpCapabilities&gt; PeerConnectionBackend::senderCapabilities(ScriptExecutionContext&amp; context, const String&amp; kind)
 77 {
 78     auto* page = downcast&lt;Document&gt;(context).page();
 79     if (!page)
 80         return { };
 81     return page-&gt;libWebRTCProvider().senderCapabilities(kind);
 82 }
 83 
 84 LibWebRTCPeerConnectionBackend::LibWebRTCPeerConnectionBackend(RTCPeerConnection&amp; peerConnection, LibWebRTCProvider&amp; provider)
 85     : PeerConnectionBackend(peerConnection)
 86     , m_endpoint(LibWebRTCMediaEndpoint::create(*this, provider))
 87 {
 88 }
 89 
 90 LibWebRTCPeerConnectionBackend::~LibWebRTCPeerConnectionBackend() = default;
 91 
<span class="line-added"> 92 void LibWebRTCPeerConnectionBackend::suspend()</span>
<span class="line-added"> 93 {</span>
<span class="line-added"> 94     m_endpoint-&gt;suspend();</span>
<span class="line-added"> 95 }</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97 void LibWebRTCPeerConnectionBackend::resume()</span>
<span class="line-added"> 98 {</span>
<span class="line-added"> 99     m_endpoint-&gt;resume();</span>
<span class="line-added">100 }</span>
<span class="line-added">101 </span>
102 static inline webrtc::PeerConnectionInterface::BundlePolicy bundlePolicyfromConfiguration(const MediaEndpointConfiguration&amp; configuration)
103 {
104     switch (configuration.bundlePolicy) {
105     case RTCBundlePolicy::MaxCompat:
106         return webrtc::PeerConnectionInterface::kBundlePolicyMaxCompat;
107     case RTCBundlePolicy::MaxBundle:
108         return webrtc::PeerConnectionInterface::kBundlePolicyMaxBundle;
109     case RTCBundlePolicy::Balanced:
110         return webrtc::PeerConnectionInterface::kBundlePolicyBalanced;
111     }
112 
113     ASSERT_NOT_REACHED();
114     return webrtc::PeerConnectionInterface::kBundlePolicyMaxCompat;
115 }
116 
117 static inline webrtc::PeerConnectionInterface::RtcpMuxPolicy rtcpMuxPolicyfromConfiguration(const MediaEndpointConfiguration&amp; configuration)
118 {
119     switch (configuration.rtcpMuxPolicy) {
120     case RTCPMuxPolicy::Negotiate:
121         return webrtc::PeerConnectionInterface::kRtcpMuxPolicyNegotiate;
</pre>
<hr />
<pre>
234                 m_endpoint-&gt;addIceCandidate(*candidate);
235         }
236         m_isRemoteDescriptionSet = true;
237     }
238 }
239 
240 void LibWebRTCPeerConnectionBackend::doCreateOffer(RTCOfferOptions&amp;&amp; options)
241 {
242     m_endpoint-&gt;doCreateOffer(options);
243 }
244 
245 void LibWebRTCPeerConnectionBackend::doCreateAnswer(RTCAnswerOptions&amp;&amp;)
246 {
247     if (!m_isRemoteDescriptionSet) {
248         createAnswerFailed(Exception { InvalidStateError, &quot;No remote description set&quot; });
249         return;
250     }
251     m_endpoint-&gt;doCreateAnswer();
252 }
253 
<span class="line-added">254 void LibWebRTCPeerConnectionBackend::close()</span>
<span class="line-added">255 {</span>
<span class="line-added">256     m_endpoint-&gt;close();</span>
<span class="line-added">257 }</span>
<span class="line-added">258 </span>
259 void LibWebRTCPeerConnectionBackend::doStop()
260 {
261     m_endpoint-&gt;stop();
262     m_pendingReceivers.clear();
263 }
264 
265 void LibWebRTCPeerConnectionBackend::doAddIceCandidate(RTCIceCandidate&amp; candidate)
266 {
267     webrtc::SdpParseError error;
268     int sdpMLineIndex = candidate.sdpMLineIndex() ? candidate.sdpMLineIndex().value() : 0;
269     std::unique_ptr&lt;webrtc::IceCandidateInterface&gt; rtcCandidate(webrtc::CreateIceCandidate(candidate.sdpMid().utf8().data(), sdpMLineIndex, candidate.candidate().utf8().data(), &amp;error));
270 
271     if (!rtcCandidate) {
272         addIceCandidateFailed(Exception { OperationError, String::fromUTF8(error.description.data(), error.description.length()) });
273         return;
274     }
275 
276     // libwebrtc does not like that ice candidates are set before the description.
277     if (!m_isLocalDescriptionSet || !m_isRemoteDescriptionSet)
278         m_pendingCandidates.append(WTFMove(rtcCandidate));
</pre>
<hr />
<pre>
396 }
397 
398 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCPeerConnectionBackend::remoteDescription() const
399 {
400     return m_endpoint-&gt;remoteDescription();
401 }
402 
403 static inline RefPtr&lt;RTCRtpSender&gt; findExistingSender(const Vector&lt;RefPtr&lt;RTCRtpTransceiver&gt;&gt;&amp; transceivers, LibWebRTCRtpSenderBackend&amp; senderBackend)
404 {
405     ASSERT(senderBackend.rtcSender());
406     for (auto&amp; transceiver : transceivers) {
407         auto&amp; sender = transceiver-&gt;sender();
408         if (!sender.isStopped() &amp;&amp; senderBackend.rtcSender() == backendFromRTPSender(sender).rtcSender())
409             return makeRef(sender);
410     }
411     return nullptr;
412 }
413 
414 ExceptionOr&lt;Ref&lt;RTCRtpSender&gt;&gt; LibWebRTCPeerConnectionBackend::addTrack(MediaStreamTrack&amp; track, Vector&lt;String&gt;&amp;&amp; mediaStreamIds)
415 {
<span class="line-modified">416     auto senderBackend = makeUnique&lt;LibWebRTCRtpSenderBackend&gt;(*this, nullptr);</span>
<span class="line-modified">417     if (!m_endpoint-&gt;addTrack(*senderBackend, track, mediaStreamIds))</span>
<span class="line-modified">418         return Exception { TypeError, &quot;Unable to add track&quot;_s };</span>








































419 
<span class="line-modified">420     if (auto sender = findExistingSender(m_peerConnection.currentTransceivers(), *senderBackend)) {</span>
<span class="line-modified">421         backendFromRTPSender(*sender).takeSource(*senderBackend);</span>
<span class="line-added">422         sender-&gt;setTrack(makeRef(track));</span>
<span class="line-added">423         sender-&gt;setMediaStreamIds(WTFMove(mediaStreamIds));</span>
<span class="line-added">424         return sender.releaseNonNull();</span>
425     }
426 
<span class="line-modified">427     auto transceiverBackend = m_endpoint-&gt;transceiverBackendFromSender(*senderBackend);</span>

428 
<span class="line-modified">429     auto sender = RTCRtpSender::create(*this, makeRef(track), WTFMove(mediaStreamIds), WTFMove(senderBackend));</span>
<span class="line-added">430     auto receiver = createReceiverForSource(createEmptySource(track.kind(), createCanonicalUUIDString()), transceiverBackend-&gt;createReceiverBackend());</span>
<span class="line-added">431     auto transceiver = RTCRtpTransceiver::create(sender.copyRef(), WTFMove(receiver), WTFMove(transceiverBackend));</span>
<span class="line-added">432     m_peerConnection.addInternalTransceiver(WTFMove(transceiver));</span>
<span class="line-added">433     return sender;</span>
434 }
435 
436 template&lt;typename T&gt;
<span class="line-modified">437 ExceptionOr&lt;Ref&lt;RTCRtpTransceiver&gt;&gt; LibWebRTCPeerConnectionBackend::addTransceiverFromTrackOrKind(T&amp;&amp; trackOrKind, const RTCRtpTransceiverInit&amp; init)</span>
438 {
439     auto backends = m_endpoint-&gt;addTransceiver(trackOrKind, init);
440     if (!backends)
441         return Exception { InvalidAccessError, &quot;Unable to add transceiver&quot;_s };
442 
443     auto sender = RTCRtpSender::create(*this, WTFMove(trackOrKind), Vector&lt;String&gt; { }, WTFMove(backends-&gt;senderBackend));
444     auto receiver = createReceiverForSource(createEmptySource(sender-&gt;trackKind(), createCanonicalUUIDString()), WTFMove(backends-&gt;receiverBackend));
445     auto transceiver = RTCRtpTransceiver::create(WTFMove(sender), WTFMove(receiver), WTFMove(backends-&gt;transceiverBackend));
446     m_peerConnection.addInternalTransceiver(transceiver.copyRef());
447     return transceiver;
448 }
449 
450 ExceptionOr&lt;Ref&lt;RTCRtpTransceiver&gt;&gt; LibWebRTCPeerConnectionBackend::addTransceiver(const String&amp; trackKind, const RTCRtpTransceiverInit&amp; init)
451 {
<span class="line-modified">452     return addTransceiverFromTrackOrKind(String { trackKind }, init);</span>





453 }
454 
455 ExceptionOr&lt;Ref&lt;RTCRtpTransceiver&gt;&gt; LibWebRTCPeerConnectionBackend::addTransceiver(Ref&lt;MediaStreamTrack&gt;&amp;&amp; track, const RTCRtpTransceiverInit&amp; init)
456 {
<span class="line-modified">457     return addTransceiverFromTrackOrKind(WTFMove(track), init);</span>









458 }
459 
460 void LibWebRTCPeerConnectionBackend::setSenderSourceFromTrack(LibWebRTCRtpSenderBackend&amp; sender, MediaStreamTrack&amp; track)
461 {
462     m_endpoint-&gt;setSenderSourceFromTrack(sender, track);
463 }
464 
465 static inline LibWebRTCRtpTransceiverBackend&amp; backendFromRTPTransceiver(RTCRtpTransceiver&amp; transceiver)
466 {
467     return static_cast&lt;LibWebRTCRtpTransceiverBackend&amp;&gt;(*transceiver.backend());
468 }
469 
470 RTCRtpTransceiver* LibWebRTCPeerConnectionBackend::existingTransceiver(WTF::Function&lt;bool(LibWebRTCRtpTransceiverBackend&amp;)&gt;&amp;&amp; matchingFunction)
471 {
472     for (auto&amp; transceiver : m_peerConnection.currentTransceivers()) {
473         if (matchingFunction(backendFromRTPTransceiver(*transceiver)))
474             return transceiver.get();
475     }
476     return nullptr;
477 }
</pre>
<hr />
<pre>
498 void LibWebRTCPeerConnectionBackend::collectTransceivers()
499 {
500     m_endpoint-&gt;collectTransceivers();
501 }
502 
503 void LibWebRTCPeerConnectionBackend::removeTrack(RTCRtpSender&amp; sender)
504 {
505     m_endpoint-&gt;removeTrack(backendFromRTPSender(sender));
506 }
507 
508 void LibWebRTCPeerConnectionBackend::applyRotationForOutgoingVideoSources()
509 {
510     for (auto&amp; transceiver : m_peerConnection.currentTransceivers()) {
511         if (!transceiver-&gt;sender().isStopped()) {
512             if (auto* videoSource = backendFromRTPSender(transceiver-&gt;sender()).videoSource())
513                 videoSource-&gt;setApplyRotation(true);
514         }
515     }
516 }
517 




















518 } // namespace WebCore
519 
520 #endif // USE(LIBWEBRTC)
</pre>
</td>
</tr>
</table>
<center><a href="LibWebRTCObservers.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LibWebRTCPeerConnectionBackend.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
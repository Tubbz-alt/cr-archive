<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringBuilder.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StringBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="StringCommon.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringBuilder.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
125             appendCharacters(other.characters8(), other.m_length.unsafeGet());
126         else
127             appendCharacters(other.characters16(), other.m_length.unsafeGet());
128     }
129 
130     void append(StringView stringView)
131     {
132         if (stringView.is8Bit())
133             appendCharacters(stringView.characters8(), stringView.length());
134         else
135             appendCharacters(stringView.characters16(), stringView.length());
136     }
137 
138 #if USE(CF)
139     WTF_EXPORT_PRIVATE void append(CFStringRef);
140 #endif
141 #if USE(CF) &amp;&amp; defined(__OBJC__)
142     void append(NSString *string) { append((__bridge CFStringRef)string); }
143 #endif
144 
<span class="line-modified">145     void appendSubstring(const String&amp; string, unsigned offset, unsigned length)</span>
146     {
<span class="line-modified">147         if (!string.length())</span>
<span class="line-removed">148             return;</span>
<span class="line-removed">149 </span>
<span class="line-removed">150         if ((offset + length) &gt; string.length())</span>
151             return;
152 

153         if (string.is8Bit())
<span class="line-modified">154             appendCharacters(string.characters8() + offset, length);</span>
155         else
<span class="line-modified">156             appendCharacters(string.characters16() + offset, length);</span>
157     }
158 
159     void append(const char* characters)
160     {
161         if (characters)
162             appendCharacters(characters, strlen(characters));
163     }
164 
165     void appendCharacter(UChar) = delete;
166     void append(UChar c)
167     {
168         if (hasOverflowed())
169             return;
170         unsigned length = m_length.unsafeGet&lt;unsigned&gt;();
171         if (m_buffer &amp;&amp; length &lt; m_buffer-&gt;length() &amp;&amp; m_string.isNull()) {
172             if (!m_is8Bit) {
173                 m_bufferCharacters16[length] = c;
174                 m_length++;
175                 return;
176             }
</pre>
<hr />
<pre>
213             return;
214         }
215         append(U16_LEAD(c));
216         append(U16_TRAIL(c));
217     }
218 
219     WTF_EXPORT_PRIVATE void appendQuotedJSONString(const String&amp;);
220 
221     template&lt;unsigned characterCount&gt;
222     ALWAYS_INLINE void appendLiteral(const char (&amp;characters)[characterCount]) { appendCharacters(characters, characterCount - 1); }
223 
224     WTF_EXPORT_PRIVATE void appendNumber(int);
225     WTF_EXPORT_PRIVATE void appendNumber(unsigned);
226     WTF_EXPORT_PRIVATE void appendNumber(long);
227     WTF_EXPORT_PRIVATE void appendNumber(unsigned long);
228     WTF_EXPORT_PRIVATE void appendNumber(long long);
229     WTF_EXPORT_PRIVATE void appendNumber(unsigned long long);
230     WTF_EXPORT_PRIVATE void appendNumber(float);
231     WTF_EXPORT_PRIVATE void appendNumber(double);
232 
<span class="line-removed">233     WTF_EXPORT_PRIVATE void appendFixedPrecisionNumber(float, unsigned precision = 6, TrailingZerosTruncatingPolicy = TruncateTrailingZeros);</span>
<span class="line-removed">234     WTF_EXPORT_PRIVATE void appendFixedPrecisionNumber(double, unsigned precision = 6, TrailingZerosTruncatingPolicy = TruncateTrailingZeros);</span>
<span class="line-removed">235     WTF_EXPORT_PRIVATE void appendFixedWidthNumber(float, unsigned decimalPlaces);</span>
<span class="line-removed">236     WTF_EXPORT_PRIVATE void appendFixedWidthNumber(double, unsigned decimalPlaces);</span>
<span class="line-removed">237 </span>
238     template&lt;typename... StringTypes&gt; void append(StringTypes...);
239 
240     String toString()
241     {
242         if (!m_string.isNull()) {
243             ASSERT(!m_buffer || m_isReified);
244             ASSERT(!hasOverflowed());
245             return m_string;
246         }
247 
248         RELEASE_ASSERT(!hasOverflowed());
249         shrinkToFit();
250         reifyString();
251         return m_string;
252     }
253 
254     const String&amp; toStringPreserveCapacity() const
255     {
256         RELEASE_ASSERT(!hasOverflowed());
257         if (m_string.isNull())
</pre>
<hr />
<pre>
360     template&lt;typename CharacterType&gt; ALWAYS_INLINE CharacterType* extendBufferForAppending(unsigned additionalLength);
361     template&lt;typename CharacterType&gt; ALWAYS_INLINE CharacterType* extendBufferForAppendingWithoutOverflowCheck(CheckedInt32 requiredLength);
362     template&lt;typename CharacterType&gt; CharacterType* extendBufferForAppendingSlowCase(unsigned requiredLength);
363     WTF_EXPORT_PRIVATE LChar* extendBufferForAppending8(CheckedInt32 requiredLength);
364     WTF_EXPORT_PRIVATE UChar* extendBufferForAppending16(CheckedInt32 requiredLength);
365 
366     template&lt;typename CharacterType&gt; ALWAYS_INLINE CharacterType* getBufferCharacters();
367     WTF_EXPORT_PRIVATE void reifyString() const;
368 
369     template&lt;typename... StringTypeAdapters&gt; void appendFromAdapters(StringTypeAdapters...);
370 
371     mutable String m_string;
372     RefPtr&lt;StringImpl&gt; m_buffer;
373     union {
374         LChar* m_bufferCharacters8;
375         UChar* m_bufferCharacters16;
376     };
377     static_assert(String::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
378     Checked&lt;int32_t, ConditionalCrashOnOverflow&gt; m_length;
379     bool m_is8Bit { true };
<span class="line-modified">380 #if !ASSERT_DISABLED</span>
381     mutable bool m_isReified { false };
382 #endif
383 };
384 
385 template&lt;&gt;
386 ALWAYS_INLINE LChar* StringBuilder::getBufferCharacters&lt;LChar&gt;()
387 {
388     ASSERT(m_is8Bit);
389     return m_bufferCharacters8;
390 }
391 
392 template&lt;&gt;
393 ALWAYS_INLINE UChar* StringBuilder::getBufferCharacters&lt;UChar&gt;()
394 {
395     ASSERT(!m_is8Bit);
396     return m_bufferCharacters16;
397 }
398 
399 template&lt;typename... StringTypeAdapters&gt;
400 void StringBuilder::appendFromAdapters(StringTypeAdapters... adapters)
</pre>
</td>
<td>
<hr />
<pre>
125             appendCharacters(other.characters8(), other.m_length.unsafeGet());
126         else
127             appendCharacters(other.characters16(), other.m_length.unsafeGet());
128     }
129 
130     void append(StringView stringView)
131     {
132         if (stringView.is8Bit())
133             appendCharacters(stringView.characters8(), stringView.length());
134         else
135             appendCharacters(stringView.characters16(), stringView.length());
136     }
137 
138 #if USE(CF)
139     WTF_EXPORT_PRIVATE void append(CFStringRef);
140 #endif
141 #if USE(CF) &amp;&amp; defined(__OBJC__)
142     void append(NSString *string) { append((__bridge CFStringRef)string); }
143 #endif
144 
<span class="line-modified">145     void appendSubstring(const String&amp; string, unsigned offset, unsigned length = String::MaxLength)</span>
146     {
<span class="line-modified">147         if (offset &gt;= string.length())</span>



148             return;
149 
<span class="line-added">150         unsigned clampedLength = std::min(length, string.length() - offset);</span>
151         if (string.is8Bit())
<span class="line-modified">152             appendCharacters(string.characters8() + offset, clampedLength);</span>
153         else
<span class="line-modified">154             appendCharacters(string.characters16() + offset, clampedLength);</span>
155     }
156 
157     void append(const char* characters)
158     {
159         if (characters)
160             appendCharacters(characters, strlen(characters));
161     }
162 
163     void appendCharacter(UChar) = delete;
164     void append(UChar c)
165     {
166         if (hasOverflowed())
167             return;
168         unsigned length = m_length.unsafeGet&lt;unsigned&gt;();
169         if (m_buffer &amp;&amp; length &lt; m_buffer-&gt;length() &amp;&amp; m_string.isNull()) {
170             if (!m_is8Bit) {
171                 m_bufferCharacters16[length] = c;
172                 m_length++;
173                 return;
174             }
</pre>
<hr />
<pre>
211             return;
212         }
213         append(U16_LEAD(c));
214         append(U16_TRAIL(c));
215     }
216 
217     WTF_EXPORT_PRIVATE void appendQuotedJSONString(const String&amp;);
218 
219     template&lt;unsigned characterCount&gt;
220     ALWAYS_INLINE void appendLiteral(const char (&amp;characters)[characterCount]) { appendCharacters(characters, characterCount - 1); }
221 
222     WTF_EXPORT_PRIVATE void appendNumber(int);
223     WTF_EXPORT_PRIVATE void appendNumber(unsigned);
224     WTF_EXPORT_PRIVATE void appendNumber(long);
225     WTF_EXPORT_PRIVATE void appendNumber(unsigned long);
226     WTF_EXPORT_PRIVATE void appendNumber(long long);
227     WTF_EXPORT_PRIVATE void appendNumber(unsigned long long);
228     WTF_EXPORT_PRIVATE void appendNumber(float);
229     WTF_EXPORT_PRIVATE void appendNumber(double);
230 





231     template&lt;typename... StringTypes&gt; void append(StringTypes...);
232 
233     String toString()
234     {
235         if (!m_string.isNull()) {
236             ASSERT(!m_buffer || m_isReified);
237             ASSERT(!hasOverflowed());
238             return m_string;
239         }
240 
241         RELEASE_ASSERT(!hasOverflowed());
242         shrinkToFit();
243         reifyString();
244         return m_string;
245     }
246 
247     const String&amp; toStringPreserveCapacity() const
248     {
249         RELEASE_ASSERT(!hasOverflowed());
250         if (m_string.isNull())
</pre>
<hr />
<pre>
353     template&lt;typename CharacterType&gt; ALWAYS_INLINE CharacterType* extendBufferForAppending(unsigned additionalLength);
354     template&lt;typename CharacterType&gt; ALWAYS_INLINE CharacterType* extendBufferForAppendingWithoutOverflowCheck(CheckedInt32 requiredLength);
355     template&lt;typename CharacterType&gt; CharacterType* extendBufferForAppendingSlowCase(unsigned requiredLength);
356     WTF_EXPORT_PRIVATE LChar* extendBufferForAppending8(CheckedInt32 requiredLength);
357     WTF_EXPORT_PRIVATE UChar* extendBufferForAppending16(CheckedInt32 requiredLength);
358 
359     template&lt;typename CharacterType&gt; ALWAYS_INLINE CharacterType* getBufferCharacters();
360     WTF_EXPORT_PRIVATE void reifyString() const;
361 
362     template&lt;typename... StringTypeAdapters&gt; void appendFromAdapters(StringTypeAdapters...);
363 
364     mutable String m_string;
365     RefPtr&lt;StringImpl&gt; m_buffer;
366     union {
367         LChar* m_bufferCharacters8;
368         UChar* m_bufferCharacters16;
369     };
370     static_assert(String::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
371     Checked&lt;int32_t, ConditionalCrashOnOverflow&gt; m_length;
372     bool m_is8Bit { true };
<span class="line-modified">373 #if ASSERT_ENABLED</span>
374     mutable bool m_isReified { false };
375 #endif
376 };
377 
378 template&lt;&gt;
379 ALWAYS_INLINE LChar* StringBuilder::getBufferCharacters&lt;LChar&gt;()
380 {
381     ASSERT(m_is8Bit);
382     return m_bufferCharacters8;
383 }
384 
385 template&lt;&gt;
386 ALWAYS_INLINE UChar* StringBuilder::getBufferCharacters&lt;UChar&gt;()
387 {
388     ASSERT(!m_is8Bit);
389     return m_bufferCharacters16;
390 }
391 
392 template&lt;typename... StringTypeAdapters&gt;
393 void StringBuilder::appendFromAdapters(StringTypeAdapters... adapters)
</pre>
</td>
</tr>
</table>
<center><a href="StringBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="StringCommon.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
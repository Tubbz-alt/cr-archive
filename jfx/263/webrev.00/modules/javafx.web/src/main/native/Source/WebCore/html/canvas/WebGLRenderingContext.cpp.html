<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGLRenderingContext.h&quot;
 28 
 29 #if ENABLE(WEBGL)
 30 
 31 #include &quot;ANGLEInstancedArrays.h&quot;
 32 #include &quot;CachedImage.h&quot;
 33 #include &quot;EXTBlendMinMax.h&quot;
 34 #include &quot;EXTFragDepth.h&quot;
 35 #include &quot;EXTShaderTextureLOD.h&quot;
 36 #include &quot;EXTTextureFilterAnisotropic.h&quot;
 37 #include &quot;EXTsRGB.h&quot;
 38 #include &quot;ExtensionsGL.h&quot;
 39 #include &quot;HTMLCanvasElement.h&quot;
 40 #include &quot;HTMLImageElement.h&quot;
 41 #include &quot;HTMLVideoElement.h&quot;
 42 #include &quot;ImageData.h&quot;
 43 #include &quot;InspectorInstrumentation.h&quot;
 44 #include &quot;OESElementIndexUint.h&quot;
 45 #include &quot;OESStandardDerivatives.h&quot;
 46 #include &quot;OESTextureFloat.h&quot;
 47 #include &quot;OESTextureFloatLinear.h&quot;
 48 #include &quot;OESTextureHalfFloat.h&quot;
 49 #include &quot;OESTextureHalfFloatLinear.h&quot;
 50 #include &quot;OESVertexArrayObject.h&quot;
 51 #include &quot;RenderBox.h&quot;
 52 #include &quot;WebGLCompressedTextureASTC.h&quot;
 53 #include &quot;WebGLCompressedTextureATC.h&quot;
 54 #include &quot;WebGLCompressedTextureETC.h&quot;
 55 #include &quot;WebGLCompressedTextureETC1.h&quot;
 56 #include &quot;WebGLCompressedTexturePVRTC.h&quot;
 57 #include &quot;WebGLCompressedTextureS3TC.h&quot;
 58 #include &quot;WebGLDebugRendererInfo.h&quot;
 59 #include &quot;WebGLDebugShaders.h&quot;
 60 #include &quot;WebGLDepthTexture.h&quot;
 61 #include &quot;WebGLDrawBuffers.h&quot;
 62 #include &quot;WebGLLoseContext.h&quot;
 63 #include &quot;WebGLVertexArrayObjectOES.h&quot;
 64 #include &lt;JavaScriptCore/GenericTypedArrayViewInlines.h&gt;
 65 #include &lt;JavaScriptCore/HeapInlines.h&gt;
 66 #include &lt;JavaScriptCore/JSCJSValueInlines.h&gt;
 67 #include &lt;JavaScriptCore/JSCellInlines.h&gt;
 68 #include &lt;JavaScriptCore/JSGenericTypedArrayViewInlines.h&gt;
 69 #include &lt;wtf/IsoMallocInlines.h&gt;
 70 
 71 namespace WebCore {
 72 
 73 WTF_MAKE_ISO_ALLOCATED_IMPL(WebGLRenderingContext);
 74 
 75 std::unique_ptr&lt;WebGLRenderingContext&gt; WebGLRenderingContext::create(CanvasBase&amp; canvas, GraphicsContextGLAttributes attributes)
 76 {
 77     auto renderingContext = std::unique_ptr&lt;WebGLRenderingContext&gt;(new WebGLRenderingContext(canvas, attributes));
 78 
 79     InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
 80 
 81     return renderingContext;
 82 }
 83 
 84 std::unique_ptr&lt;WebGLRenderingContext&gt; WebGLRenderingContext::create(CanvasBase&amp; canvas, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp; context, GraphicsContextGLAttributes attributes)
 85 {
 86     auto renderingContext = std::unique_ptr&lt;WebGLRenderingContext&gt;(new WebGLRenderingContext(canvas, WTFMove(context), attributes));
 87 
 88     InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
 89 
 90     return renderingContext;
 91 }
 92 
 93 WebGLRenderingContext::WebGLRenderingContext(CanvasBase&amp; canvas, GraphicsContextGLAttributes attributes)
 94     : WebGLRenderingContextBase(canvas, attributes)
 95 {
 96 }
 97 
 98 WebGLRenderingContext::WebGLRenderingContext(CanvasBase&amp; canvas, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp; context, GraphicsContextGLAttributes attributes)
 99     : WebGLRenderingContextBase(canvas, WTFMove(context), attributes)
100 {
101     initializeVertexArrayObjects();
102 }
103 
104 void WebGLRenderingContext::initializeVertexArrayObjects()
105 {
106     m_defaultVertexArrayObject = WebGLVertexArrayObjectOES::create(*this, WebGLVertexArrayObjectOES::Type::Default);
107     addContextObject(*m_defaultVertexArrayObject);
108     m_boundVertexArrayObject = m_defaultVertexArrayObject;
109     if (!isGLES2Compliant())
110         initVertexAttrib0();
111 }
112 
113 WebGLExtension* WebGLRenderingContext::getExtension(const String&amp; name)
114 {
115     if (isContextLostOrPending())
116         return nullptr;
117 
118 #define ENABLE_IF_REQUESTED(type, variable, nameLiteral, canEnable) \
119     if (equalIgnoringASCIICase(name, nameLiteral)) { \
120         if (!variable) { \
121             variable = (canEnable) ? makeUnique&lt;type&gt;(*this) : nullptr; \
122             if (variable != nullptr) \
123                 InspectorInstrumentation::didEnableExtension(*this, name); \
124         } \
125         return variable.get(); \
126     }
127 
128     ENABLE_IF_REQUESTED(EXTBlendMinMax, m_extBlendMinMax, &quot;EXT_blend_minmax&quot;, enableSupportedExtension(&quot;GL_EXT_blend_minmax&quot;_s));
129     ENABLE_IF_REQUESTED(EXTsRGB, m_extsRGB, &quot;EXT_sRGB&quot;, enableSupportedExtension(&quot;GL_EXT_sRGB&quot;_s));
130     ENABLE_IF_REQUESTED(EXTFragDepth, m_extFragDepth, &quot;EXT_frag_depth&quot;, enableSupportedExtension(&quot;GL_EXT_frag_depth&quot;_s));
131     if (equalIgnoringASCIICase(name, &quot;EXT_shader_texture_lod&quot;)) {
132         if (!m_extShaderTextureLOD) {
133             if (!(m_context-&gt;getExtensions().supports(&quot;GL_EXT_shader_texture_lod&quot;_s) || m_context-&gt;getExtensions().supports(&quot;GL_ARB_shader_texture_lod&quot;_s)))
134                 m_extShaderTextureLOD = nullptr;
135             else {
136                 m_context-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_shader_texture_lod&quot;_s);
137                 m_extShaderTextureLOD = makeUnique&lt;EXTShaderTextureLOD&gt;(*this);
138                 InspectorInstrumentation::didEnableExtension(*this, name);
139             }
140         }
141         return m_extShaderTextureLOD.get();
142     }
143     ENABLE_IF_REQUESTED(EXTTextureFilterAnisotropic, m_extTextureFilterAnisotropic, &quot;EXT_texture_filter_anisotropic&quot;, enableSupportedExtension(&quot;GL_EXT_texture_filter_anisotropic&quot;_s));
144     ENABLE_IF_REQUESTED(OESStandardDerivatives, m_oesStandardDerivatives, &quot;OES_standard_derivatives&quot;, enableSupportedExtension(&quot;GL_OES_standard_derivatives&quot;_s));
145     ENABLE_IF_REQUESTED(OESTextureFloat, m_oesTextureFloat, &quot;OES_texture_float&quot;, enableSupportedExtension(&quot;GL_OES_texture_float&quot;_s));
146     ENABLE_IF_REQUESTED(OESTextureFloatLinear, m_oesTextureFloatLinear, &quot;OES_texture_float_linear&quot;, enableSupportedExtension(&quot;GL_OES_texture_float_linear&quot;_s));
147     ENABLE_IF_REQUESTED(OESTextureHalfFloat, m_oesTextureHalfFloat, &quot;OES_texture_half_float&quot;, enableSupportedExtension(&quot;GL_OES_texture_half_float&quot;_s));
148     ENABLE_IF_REQUESTED(OESTextureHalfFloatLinear, m_oesTextureHalfFloatLinear, &quot;OES_texture_half_float_linear&quot;, enableSupportedExtension(&quot;GL_OES_texture_half_float_linear&quot;_s));
149     ENABLE_IF_REQUESTED(OESVertexArrayObject, m_oesVertexArrayObject, &quot;OES_vertex_array_object&quot;, enableSupportedExtension(&quot;GL_OES_vertex_array_object&quot;_s));
150     ENABLE_IF_REQUESTED(OESElementIndexUint, m_oesElementIndexUint, &quot;OES_element_index_uint&quot;, enableSupportedExtension(&quot;GL_OES_element_index_uint&quot;_s));
151     ENABLE_IF_REQUESTED(WebGLLoseContext, m_webglLoseContext, &quot;WEBGL_lose_context&quot;, true);
152     ENABLE_IF_REQUESTED(WebGLCompressedTextureASTC, m_webglCompressedTextureASTC, &quot;WEBGL_compressed_texture_astc&quot;, WebGLCompressedTextureASTC::supported(*this));
153     ENABLE_IF_REQUESTED(WebGLCompressedTextureATC, m_webglCompressedTextureATC, &quot;WEBKIT_WEBGL_compressed_texture_atc&quot;, WebGLCompressedTextureATC::supported(*this));
154     ENABLE_IF_REQUESTED(WebGLCompressedTextureETC, m_webglCompressedTextureETC, &quot;WEBGL_compressed_texture_etc&quot;, WebGLCompressedTextureETC::supported(*this));
155     ENABLE_IF_REQUESTED(WebGLCompressedTextureETC1, m_webglCompressedTextureETC1, &quot;WEBGL_compressed_texture_etc1&quot;, WebGLCompressedTextureETC1::supported(*this));
156     ENABLE_IF_REQUESTED(WebGLCompressedTexturePVRTC, m_webglCompressedTexturePVRTC, &quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;, WebGLCompressedTexturePVRTC::supported(*this));
157     ENABLE_IF_REQUESTED(WebGLCompressedTextureS3TC, m_webglCompressedTextureS3TC, &quot;WEBGL_compressed_texture_s3tc&quot;, WebGLCompressedTextureS3TC::supported(*this));
158     ENABLE_IF_REQUESTED(WebGLDepthTexture, m_webglDepthTexture, &quot;WEBGL_depth_texture&quot;, WebGLDepthTexture::supported(*m_context));
159     if (equalIgnoringASCIICase(name, &quot;WEBGL_draw_buffers&quot;)) {
160         if (!m_webglDrawBuffers) {
161             if (!supportsDrawBuffers())
162                 m_webglDrawBuffers = nullptr;
163             else {
164                 m_context-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_draw_buffers&quot;_s);
165                 m_webglDrawBuffers = makeUnique&lt;WebGLDrawBuffers&gt;(*this);
166                 InspectorInstrumentation::didEnableExtension(*this, name);
167             }
168         }
169         return m_webglDrawBuffers.get();
170     }
171     if (equalIgnoringASCIICase(name, &quot;ANGLE_instanced_arrays&quot;)) {
172         if (!m_angleInstancedArrays) {
173             if (!ANGLEInstancedArrays::supported(*this))
174                 m_angleInstancedArrays = nullptr;
175             else {
176                 m_context-&gt;getExtensions().ensureEnabled(&quot;GL_ANGLE_instanced_arrays&quot;_s);
177                 m_angleInstancedArrays = makeUnique&lt;ANGLEInstancedArrays&gt;(*this);
178                 InspectorInstrumentation::didEnableExtension(*this, name);
179             }
180         }
181         return m_angleInstancedArrays.get();
182     }
183     ENABLE_IF_REQUESTED(WebGLDebugRendererInfo, m_webglDebugRendererInfo, &quot;WEBGL_debug_renderer_info&quot;, true);
184     ENABLE_IF_REQUESTED(WebGLDebugShaders, m_webglDebugShaders, &quot;WEBGL_debug_shaders&quot;, m_context-&gt;getExtensions().supports(&quot;GL_ANGLE_translated_shader_source&quot;_s));
185     return nullptr;
186 }
187 
188 Optional&lt;Vector&lt;String&gt;&gt; WebGLRenderingContext::getSupportedExtensions()
189 {
190     if (isContextLost())
191         return WTF::nullopt;
192 
193     Vector&lt;String&gt; result;
194 
195     if (m_isPendingPolicyResolution)
196         return result;
197 
198     if (m_context-&gt;getExtensions().supports(&quot;GL_EXT_blend_minmax&quot;_s))
199         result.append(&quot;EXT_blend_minmax&quot;_s);
200     if (m_context-&gt;getExtensions().supports(&quot;GL_EXT_sRGB&quot;_s))
201         result.append(&quot;EXT_sRGB&quot;_s);
202     if (m_context-&gt;getExtensions().supports(&quot;GL_EXT_frag_depth&quot;_s))
203         result.append(&quot;EXT_frag_depth&quot;_s);
204     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_texture_float&quot;_s))
205         result.append(&quot;OES_texture_float&quot;_s);
206     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_texture_float_linear&quot;_s))
207         result.append(&quot;OES_texture_float_linear&quot;_s);
208     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_texture_half_float&quot;_s))
209         result.append(&quot;OES_texture_half_float&quot;_s);
210     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_texture_half_float_linear&quot;_s))
211         result.append(&quot;OES_texture_half_float_linear&quot;_s);
212     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_standard_derivatives&quot;_s))
213         result.append(&quot;OES_standard_derivatives&quot;_s);
214     if (m_context-&gt;getExtensions().supports(&quot;GL_EXT_shader_texture_lod&quot;_s) || m_context-&gt;getExtensions().supports(&quot;GL_ARB_shader_texture_lod&quot;_s))
215         result.append(&quot;EXT_shader_texture_lod&quot;_s);
216     if (m_context-&gt;getExtensions().supports(&quot;GL_EXT_texture_filter_anisotropic&quot;_s))
217         result.append(&quot;EXT_texture_filter_anisotropic&quot;_s);
218     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_vertex_array_object&quot;_s))
219         result.append(&quot;OES_vertex_array_object&quot;_s);
220     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_element_index_uint&quot;_s))
221         result.append(&quot;OES_element_index_uint&quot;_s);
222     result.append(&quot;WEBGL_lose_context&quot;_s);
223     if (WebGLCompressedTextureASTC::supported(*this))
224         result.append(&quot;WEBGL_compressed_texture_astc&quot;_s);
225     if (WebGLCompressedTextureATC::supported(*this))
226         result.append(&quot;WEBKIT_WEBGL_compressed_texture_atc&quot;_s);
227     if (WebGLCompressedTextureETC::supported(*this))
228         result.append(&quot;WEBGL_compressed_texture_etc&quot;_s);
229     if (WebGLCompressedTextureETC1::supported(*this))
230         result.append(&quot;WEBGL_compressed_texture_etc1&quot;_s);
231     if (WebGLCompressedTexturePVRTC::supported(*this))
232         result.append(&quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;_s);
233     if (WebGLCompressedTextureS3TC::supported(*this))
234         result.append(&quot;WEBGL_compressed_texture_s3tc&quot;_s);
235     if (WebGLDepthTexture::supported(*m_context))
236         result.append(&quot;WEBGL_depth_texture&quot;_s);
237     if (supportsDrawBuffers())
238         result.append(&quot;WEBGL_draw_buffers&quot;_s);
239     if (ANGLEInstancedArrays::supported(*this))
240         result.append(&quot;ANGLE_instanced_arrays&quot;_s);
241     if (m_context-&gt;getExtensions().supports(&quot;GL_ANGLE_translated_shader_source&quot;_s))
242         result.append(&quot;WEBGL_debug_shaders&quot;_s);
243     result.append(&quot;WEBGL_debug_renderer_info&quot;_s);
244 
245     return result;
246 }
247 
248 WebGLAny WebGLRenderingContext::getFramebufferAttachmentParameter(GCGLenum target, GCGLenum attachment, GCGLenum pname)
249 {
250     if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;getFramebufferAttachmentParameter&quot;, target, attachment))
251         return nullptr;
252 
253     if (!m_framebufferBinding || !m_framebufferBinding-&gt;object()) {
254         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getFramebufferAttachmentParameter&quot;, &quot;no framebuffer bound&quot;);
255         return nullptr;
256     }
257 
258     auto object = makeRefPtr(m_framebufferBinding-&gt;getAttachmentObject(attachment));
259     if (!object) {
260         if (pname == GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE)
261             return static_cast&lt;unsigned&gt;(GraphicsContextGL::NONE);
262         // OpenGL ES 2.0 specifies INVALID_ENUM in this case, while desktop GL
263         // specifies INVALID_OPERATION.
264         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name&quot;);
265         return nullptr;
266     }
267 
268     if (object-&gt;isTexture()) {
269         switch (pname) {
270         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
271             return static_cast&lt;unsigned&gt;(GraphicsContextGL::TEXTURE);
272         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:
273             return makeRefPtr(reinterpret_cast&lt;WebGLTexture&amp;&gt;(*object));
274         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:
275         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:
276         case ExtensionsGL::FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: {
277             GCGLint value = 0;
278             m_context-&gt;getFramebufferAttachmentParameteriv(target, attachment, pname, &amp;value);
279             return value;
280         }
281         default:
282             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name for texture attachment&quot;);
283             return nullptr;
284         }
285     } else {
286         ASSERT(object-&gt;isRenderbuffer());
287         switch (pname) {
288         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
289             return static_cast&lt;unsigned&gt;(GraphicsContextGL::RENDERBUFFER);
290         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:
291             return makeRefPtr(reinterpret_cast&lt;WebGLRenderbuffer&amp;&gt;(*object));
292         case ExtensionsGL::FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: {
293             if (!m_extsRGB) {
294                 synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name for renderbuffer attachment&quot;);
295                 return nullptr;
296             }
297             RefPtr&lt;WebGLRenderbuffer&gt; renderBuffer = reinterpret_cast&lt;WebGLRenderbuffer*&gt;(object.get());
298             GCGLenum renderBufferFormat = renderBuffer-&gt;getInternalFormat();
299             ASSERT(renderBufferFormat != ExtensionsGL::SRGB_EXT &amp;&amp; renderBufferFormat != ExtensionsGL::SRGB_ALPHA_EXT);
300             if (renderBufferFormat == ExtensionsGL::SRGB8_ALPHA8_EXT)
301                 return static_cast&lt;unsigned&gt;(ExtensionsGL::SRGB_EXT);
302             return static_cast&lt;unsigned&gt;(GraphicsContextGL::LINEAR);
303         }
304         default:
305             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name for renderbuffer attachment&quot;);
306             return nullptr;
307         }
308     }
309 }
310 
311 bool WebGLRenderingContext::validateFramebufferFuncParameters(const char* functionName, GCGLenum target, GCGLenum attachment)
312 {
313     if (target != GraphicsContextGL::FRAMEBUFFER) {
314         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid target&quot;);
315         return false;
316     }
317     // FIXME: Why does this return true unconditionally for COLOR_ATTACHMENT0,
318     // but false for other COLOR_ATTACHMENT values if m_webglDrawBuffers is false?
319     switch (attachment) {
320     case GraphicsContextGL::COLOR_ATTACHMENT0:
321     case GraphicsContextGL::DEPTH_ATTACHMENT:
322     case GraphicsContextGL::STENCIL_ATTACHMENT:
323     case GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT:
324         return true;
325     default:
326         if (m_webglDrawBuffers
327             &amp;&amp; attachment &gt;= GraphicsContextGL::COLOR_ATTACHMENT0
328             &amp;&amp; attachment &lt; static_cast&lt;GCGLenum&gt;(GraphicsContextGL::COLOR_ATTACHMENT0 + getMaxColorAttachments()))
329             return true;
330         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid attachment&quot;);
331         return false;
332     }
333 }
334 
335 void WebGLRenderingContext::renderbufferStorage(GCGLenum target, GCGLenum internalformat, GCGLsizei width, GCGLsizei height)
336 {
337     if (isContextLostOrPending())
338         return;
339     if (target != GraphicsContextGL::RENDERBUFFER) {
340         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid target&quot;);
341         return;
342     }
343     if (!m_renderbufferBinding || !m_renderbufferBinding-&gt;object()) {
344         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;renderbufferStorage&quot;, &quot;no bound renderbuffer&quot;);
345         return;
346     }
347     if (!validateSize(&quot;renderbufferStorage&quot;, width, height))
348         return;
349     switch (internalformat) {
350     case GraphicsContextGL::DEPTH_COMPONENT16:
351     case GraphicsContextGL::RGBA4:
352     case GraphicsContextGL::RGB5_A1:
353     case GraphicsContextGL::RGB565:
354     case GraphicsContextGL::STENCIL_INDEX8:
355     case ExtensionsGL::SRGB8_ALPHA8_EXT:
356         if (internalformat == ExtensionsGL::SRGB8_ALPHA8_EXT &amp;&amp; !m_extsRGB) {
357             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);
358             return;
359         }
360         m_context-&gt;renderbufferStorage(target, internalformat, width, height);
361         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
362         m_renderbufferBinding-&gt;setIsValid(true);
363         m_renderbufferBinding-&gt;setSize(width, height);
364         break;
365     case GraphicsContextGL::DEPTH_STENCIL:
366         if (isDepthStencilSupported())
367             m_context-&gt;renderbufferStorage(target, ExtensionsGL::DEPTH24_STENCIL8, width, height);
368         m_renderbufferBinding-&gt;setSize(width, height);
369         m_renderbufferBinding-&gt;setIsValid(isDepthStencilSupported());
370         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
371         break;
372     default:
373         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);
374         return;
375     }
376     applyStencilTest();
377 }
378 
379 void WebGLRenderingContext::hint(GCGLenum target, GCGLenum mode)
380 {
381     if (isContextLostOrPending())
382         return;
383     bool isValid = false;
384     switch (target) {
385     case GraphicsContextGL::GENERATE_MIPMAP_HINT:
386         isValid = true;
387         break;
388     case ExtensionsGL::FRAGMENT_SHADER_DERIVATIVE_HINT_OES: // OES_standard_derivatives
389         if (m_oesStandardDerivatives)
390             isValid = true;
391         break;
392     }
393     if (!isValid) {
394         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;hint&quot;, &quot;invalid target&quot;);
395         return;
396     }
397     m_context-&gt;hint(target, mode);
398 }
399 
400 void WebGLRenderingContext::clear(GCGLbitfield mask)
401 {
402     if (isContextLostOrPending())
403         return;
404     if (mask &amp; ~(GraphicsContextGL::COLOR_BUFFER_BIT | GraphicsContextGL::DEPTH_BUFFER_BIT | GraphicsContextGL::STENCIL_BUFFER_BIT)) {
405         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;clear&quot;, &quot;invalid mask&quot;);
406         return;
407     }
408     const char* reason = &quot;framebuffer incomplete&quot;;
409     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(m_context.get(), &amp;reason)) {
410         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, &quot;clear&quot;, reason);
411         return;
412     }
413     if (!clearIfComposited(mask))
414         m_context-&gt;clear(mask);
415     markContextChangedAndNotifyCanvasObserver();
416 }
417 
418 WebGLAny WebGLRenderingContext::getParameter(GCGLenum pname)
419 {
420     if (isContextLostOrPending())
421         return nullptr;
422 
423     switch (pname) {
424     case GraphicsContextGL::ACTIVE_TEXTURE:
425         return getUnsignedIntParameter(pname);
426     case GraphicsContextGL::ALIASED_LINE_WIDTH_RANGE:
427         return getWebGLFloatArrayParameter(pname);
428     case GraphicsContextGL::ALIASED_POINT_SIZE_RANGE:
429         return getWebGLFloatArrayParameter(pname);
430     case GraphicsContextGL::ALPHA_BITS:
431         if (!m_framebufferBinding &amp;&amp; !m_attributes.alpha)
432             return 0;
433         return getIntParameter(pname);
434     case GraphicsContextGL::ARRAY_BUFFER_BINDING:
435         return m_boundArrayBuffer;
436     case GraphicsContextGL::BLEND:
437         return getBooleanParameter(pname);
438     case GraphicsContextGL::BLEND_COLOR:
439         return getWebGLFloatArrayParameter(pname);
440     case GraphicsContextGL::BLEND_DST_ALPHA:
441         return getUnsignedIntParameter(pname);
442     case GraphicsContextGL::BLEND_DST_RGB:
443         return getUnsignedIntParameter(pname);
444     case GraphicsContextGL::BLEND_EQUATION_ALPHA:
445         return getUnsignedIntParameter(pname);
446     case GraphicsContextGL::BLEND_EQUATION_RGB:
447         return getUnsignedIntParameter(pname);
448     case GraphicsContextGL::BLEND_SRC_ALPHA:
449         return getUnsignedIntParameter(pname);
450     case GraphicsContextGL::BLEND_SRC_RGB:
451         return getUnsignedIntParameter(pname);
452     case GraphicsContextGL::BLUE_BITS:
453         return getIntParameter(pname);
454     case GraphicsContextGL::COLOR_CLEAR_VALUE:
455         return getWebGLFloatArrayParameter(pname);
456     case GraphicsContextGL::COLOR_WRITEMASK:
457         return getBooleanArrayParameter(pname);
458     case GraphicsContextGL::COMPRESSED_TEXTURE_FORMATS:
459         return Uint32Array::tryCreate(m_compressedTextureFormats.data(), m_compressedTextureFormats.size());
460     case GraphicsContextGL::CULL_FACE:
461         return getBooleanParameter(pname);
462     case GraphicsContextGL::CULL_FACE_MODE:
463         return getUnsignedIntParameter(pname);
464     case GraphicsContextGL::CURRENT_PROGRAM:
465         return m_currentProgram;
466     case GraphicsContextGL::DEPTH_BITS:
467         if (!m_framebufferBinding &amp;&amp; !m_attributes.depth)
468             return 0;
469         return getIntParameter(pname);
470     case GraphicsContextGL::DEPTH_CLEAR_VALUE:
471         return getFloatParameter(pname);
472     case GraphicsContextGL::DEPTH_FUNC:
473         return getUnsignedIntParameter(pname);
474     case GraphicsContextGL::DEPTH_RANGE:
475         return getWebGLFloatArrayParameter(pname);
476     case GraphicsContextGL::DEPTH_TEST:
477         return getBooleanParameter(pname);
478     case GraphicsContextGL::DEPTH_WRITEMASK:
479         return getBooleanParameter(pname);
480     case GraphicsContextGL::DITHER:
481         return getBooleanParameter(pname);
482     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER_BINDING:
483         return makeRefPtr(m_boundVertexArrayObject-&gt;getElementArrayBuffer());
484     case GraphicsContextGL::FRAMEBUFFER_BINDING:
485         return m_framebufferBinding;
486     case GraphicsContextGL::FRONT_FACE:
487         return getUnsignedIntParameter(pname);
488     case GraphicsContextGL::GENERATE_MIPMAP_HINT:
489         return getUnsignedIntParameter(pname);
490     case GraphicsContextGL::GREEN_BITS:
491         return getIntParameter(pname);
492     case GraphicsContextGL::IMPLEMENTATION_COLOR_READ_FORMAT:
493         return getIntParameter(pname);
494     case GraphicsContextGL::IMPLEMENTATION_COLOR_READ_TYPE:
495         return getIntParameter(pname);
496     case GraphicsContextGL::LINE_WIDTH:
497         return getFloatParameter(pname);
498     case GraphicsContextGL::MAX_COMBINED_TEXTURE_IMAGE_UNITS:
499         return getIntParameter(pname);
500     case GraphicsContextGL::MAX_CUBE_MAP_TEXTURE_SIZE:
501         return getIntParameter(pname);
502     case GraphicsContextGL::MAX_FRAGMENT_UNIFORM_VECTORS:
503         return getIntParameter(pname);
504     case GraphicsContextGL::MAX_RENDERBUFFER_SIZE:
505         return getIntParameter(pname);
506     case GraphicsContextGL::MAX_TEXTURE_IMAGE_UNITS:
507         return getIntParameter(pname);
508     case GraphicsContextGL::MAX_TEXTURE_SIZE:
509         return getIntParameter(pname);
510     case GraphicsContextGL::MAX_VARYING_VECTORS:
511         return getIntParameter(pname);
512     case GraphicsContextGL::MAX_VERTEX_ATTRIBS:
513         return getIntParameter(pname);
514     case GraphicsContextGL::MAX_VERTEX_TEXTURE_IMAGE_UNITS:
515         return getIntParameter(pname);
516     case GraphicsContextGL::MAX_VERTEX_UNIFORM_VECTORS:
517         return getIntParameter(pname);
518     case GraphicsContextGL::MAX_VIEWPORT_DIMS:
519         return getWebGLIntArrayParameter(pname);
520     case GraphicsContextGL::NUM_SHADER_BINARY_FORMATS:
521         return getIntParameter(pname);
522     case GraphicsContextGL::PACK_ALIGNMENT:
523         return getIntParameter(pname);
524     case GraphicsContextGL::POLYGON_OFFSET_FACTOR:
525         return getFloatParameter(pname);
526     case GraphicsContextGL::POLYGON_OFFSET_FILL:
527         return getBooleanParameter(pname);
528     case GraphicsContextGL::POLYGON_OFFSET_UNITS:
529         return getFloatParameter(pname);
530     case GraphicsContextGL::RED_BITS:
531         return getIntParameter(pname);
532     case GraphicsContextGL::RENDERBUFFER_BINDING:
533         return m_renderbufferBinding;
534     case GraphicsContextGL::RENDERER:
535         return &quot;WebKit WebGL&quot;_str;
536     case GraphicsContextGL::SAMPLE_BUFFERS:
537         return getIntParameter(pname);
538     case GraphicsContextGL::SAMPLE_COVERAGE_INVERT:
539         return getBooleanParameter(pname);
540     case GraphicsContextGL::SAMPLE_COVERAGE_VALUE:
541         return getFloatParameter(pname);
542     case GraphicsContextGL::SAMPLES:
543         return getIntParameter(pname);
544     case GraphicsContextGL::SCISSOR_BOX:
545         return getWebGLIntArrayParameter(pname);
546     case GraphicsContextGL::SCISSOR_TEST:
547         return getBooleanParameter(pname);
548     case GraphicsContextGL::SHADING_LANGUAGE_VERSION:
549         return &quot;WebGL GLSL ES 1.0 (&quot; + m_context-&gt;getString(GraphicsContextGL::SHADING_LANGUAGE_VERSION) + &quot;)&quot;;
550     case GraphicsContextGL::STENCIL_BACK_FAIL:
551         return getUnsignedIntParameter(pname);
552     case GraphicsContextGL::STENCIL_BACK_FUNC:
553         return getUnsignedIntParameter(pname);
554     case GraphicsContextGL::STENCIL_BACK_PASS_DEPTH_FAIL:
555         return getUnsignedIntParameter(pname);
556     case GraphicsContextGL::STENCIL_BACK_PASS_DEPTH_PASS:
557         return getUnsignedIntParameter(pname);
558     case GraphicsContextGL::STENCIL_BACK_REF:
559         return getIntParameter(pname);
560     case GraphicsContextGL::STENCIL_BACK_VALUE_MASK:
561         return getUnsignedIntParameter(pname);
562     case GraphicsContextGL::STENCIL_BACK_WRITEMASK:
563         return getUnsignedIntParameter(pname);
564     case GraphicsContextGL::STENCIL_BITS:
565         if (!m_framebufferBinding &amp;&amp; !m_attributes.stencil)
566             return 0;
567         return getIntParameter(pname);
568     case GraphicsContextGL::STENCIL_CLEAR_VALUE:
569         return getIntParameter(pname);
570     case GraphicsContextGL::STENCIL_FAIL:
571         return getUnsignedIntParameter(pname);
572     case GraphicsContextGL::STENCIL_FUNC:
573         return getUnsignedIntParameter(pname);
574     case GraphicsContextGL::STENCIL_PASS_DEPTH_FAIL:
575         return getUnsignedIntParameter(pname);
576     case GraphicsContextGL::STENCIL_PASS_DEPTH_PASS:
577         return getUnsignedIntParameter(pname);
578     case GraphicsContextGL::STENCIL_REF:
579         return getIntParameter(pname);
580     case GraphicsContextGL::STENCIL_TEST:
581         return getBooleanParameter(pname);
582     case GraphicsContextGL::STENCIL_VALUE_MASK:
583         return getUnsignedIntParameter(pname);
584     case GraphicsContextGL::STENCIL_WRITEMASK:
585         return getUnsignedIntParameter(pname);
586     case GraphicsContextGL::SUBPIXEL_BITS:
587         return getIntParameter(pname);
588     case GraphicsContextGL::TEXTURE_BINDING_2D:
589         return m_textureUnits[m_activeTextureUnit].texture2DBinding;
590     case GraphicsContextGL::TEXTURE_BINDING_CUBE_MAP:
591         return m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
592     case GraphicsContextGL::UNPACK_ALIGNMENT:
593         return getIntParameter(pname);
594     case GraphicsContextGL::UNPACK_FLIP_Y_WEBGL:
595         return m_unpackFlipY;
596     case GraphicsContextGL::UNPACK_PREMULTIPLY_ALPHA_WEBGL:
597         return m_unpackPremultiplyAlpha;
598     case GraphicsContextGL::UNPACK_COLORSPACE_CONVERSION_WEBGL:
599         return m_unpackColorspaceConversion;
600     case GraphicsContextGL::VENDOR:
601         return &quot;WebKit&quot;_str;
602     case GraphicsContextGL::VERSION:
603         return &quot;WebGL 1.0&quot;_str;
604     case GraphicsContextGL::VIEWPORT:
605         return getWebGLIntArrayParameter(pname);
606     case ExtensionsGL::FRAGMENT_SHADER_DERIVATIVE_HINT_OES: // OES_standard_derivatives
607         if (m_oesStandardDerivatives)
608             return getUnsignedIntParameter(ExtensionsGL::FRAGMENT_SHADER_DERIVATIVE_HINT_OES);
609         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, OES_standard_derivatives not enabled&quot;);
610         return nullptr;
611     case WebGLDebugRendererInfo::UNMASKED_RENDERER_WEBGL:
612         if (m_webglDebugRendererInfo) {
613 #if PLATFORM(IOS_FAMILY)
614             return &quot;Apple GPU&quot;_str;
615 #else
616             return m_context-&gt;getString(GraphicsContextGL::RENDERER);
617 #endif
618         }
619         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_debug_renderer_info not enabled&quot;);
620         return nullptr;
621     case WebGLDebugRendererInfo::UNMASKED_VENDOR_WEBGL:
622         if (m_webglDebugRendererInfo)
623             return m_context-&gt;getString(GraphicsContextGL::VENDOR);
624         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_debug_renderer_info not enabled&quot;);
625         return nullptr;
626     case ExtensionsGL::VERTEX_ARRAY_BINDING_OES: // OES_vertex_array_object
627         if (m_oesVertexArrayObject) {
628             if (m_boundVertexArrayObject-&gt;isDefaultObject())
629                 return nullptr;
630             return makeRefPtr(static_cast&lt;WebGLVertexArrayObjectOES&amp;&gt;(*m_boundVertexArrayObject));
631         }
632         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, OES_vertex_array_object not enabled&quot;);
633         return nullptr;
634     case ExtensionsGL::MAX_TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic
635         if (m_extTextureFilterAnisotropic)
636             return getUnsignedIntParameter(ExtensionsGL::MAX_TEXTURE_MAX_ANISOTROPY_EXT);
637         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, EXT_texture_filter_anisotropic not enabled&quot;);
638         return nullptr;
639     case ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT: // EXT_draw_buffers BEGIN
640         if (m_webglDrawBuffers)
641             return getMaxColorAttachments();
642         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_draw_buffers not enabled&quot;);
643         return nullptr;
644     case ExtensionsGL::MAX_DRAW_BUFFERS_EXT:
645         if (m_webglDrawBuffers)
646             return getMaxDrawBuffers();
647         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_draw_buffers not enabled&quot;);
648         return nullptr;
649     default:
650         if (m_webglDrawBuffers
651             &amp;&amp; pname &gt;= ExtensionsGL::DRAW_BUFFER0_EXT
652             &amp;&amp; pname &lt; static_cast&lt;GCGLenum&gt;(ExtensionsGL::DRAW_BUFFER0_EXT + getMaxDrawBuffers())) {
653             GCGLint value = GraphicsContextGL::NONE;
654             if (m_framebufferBinding)
655                 value = m_framebufferBinding-&gt;getDrawBuffer(pname);
656             else // emulated backbuffer
657                 value = m_backDrawBuffer;
658             return value;
659         }
660         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name&quot;);
661         return nullptr;
662     }
663 }
664 
665 GCGLint WebGLRenderingContext::getMaxDrawBuffers()
666 {
667     if (!supportsDrawBuffers())
668         return 0;
669     if (!m_maxDrawBuffers)
670         m_context-&gt;getIntegerv(ExtensionsGL::MAX_DRAW_BUFFERS_EXT, &amp;m_maxDrawBuffers);
671     if (!m_maxColorAttachments)
672         m_context-&gt;getIntegerv(ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);
673     // WEBGL_draw_buffers requires MAX_COLOR_ATTACHMENTS &gt;= MAX_DRAW_BUFFERS.
674     return std::min(m_maxDrawBuffers, m_maxColorAttachments);
675 }
676 
677 GCGLint WebGLRenderingContext::getMaxColorAttachments()
678 {
679     if (!supportsDrawBuffers())
680         return 0;
681     if (!m_maxColorAttachments)
682         m_context-&gt;getIntegerv(ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);
683     return m_maxColorAttachments;
684 }
685 
686 bool WebGLRenderingContext::validateIndexArrayConservative(GCGLenum type, unsigned&amp; numElementsRequired)
687 {
688     // Performs conservative validation by caching a maximum index of
689     // the given type per element array buffer. If all of the bound
690     // array buffers have enough elements to satisfy that maximum
691     // index, skips the expensive per-draw-call iteration in
692     // validateIndexArrayPrecise.
693 
694     RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
695 
696     if (!elementArrayBuffer)
697         return false;
698 
699     GCGLsizeiptr numElements = elementArrayBuffer-&gt;byteLength();
700     // The case count==0 is already dealt with in drawElements before validateIndexArrayConservative.
701     if (!numElements)
702         return false;
703     auto buffer = elementArrayBuffer-&gt;elementArrayBuffer();
704     ASSERT(buffer);
705 
706     Optional&lt;unsigned&gt; maxIndex = elementArrayBuffer-&gt;getCachedMaxIndex(type);
707     if (!maxIndex) {
708         // Compute the maximum index in the entire buffer for the given type of index.
709         switch (type) {
710         case GraphicsContextGL::UNSIGNED_BYTE: {
711             const GCGLubyte* p = static_cast&lt;const GCGLubyte*&gt;(buffer-&gt;data());
712             for (GCGLsizeiptr i = 0; i &lt; numElements; i++)
713                 maxIndex = maxIndex ? std::max(maxIndex.value(), static_cast&lt;unsigned&gt;(p[i])) : static_cast&lt;unsigned&gt;(p[i]);
714             break;
715         }
716         case GraphicsContextGL::UNSIGNED_SHORT: {
717             numElements /= sizeof(GCGLushort);
718             const GCGLushort* p = static_cast&lt;const GCGLushort*&gt;(buffer-&gt;data());
719             for (GCGLsizeiptr i = 0; i &lt; numElements; i++)
720                 maxIndex = maxIndex ? std::max(maxIndex.value(), static_cast&lt;unsigned&gt;(p[i])) : static_cast&lt;unsigned&gt;(p[i]);
721             break;
722         }
723         case GraphicsContextGL::UNSIGNED_INT: {
724             if (!m_oesElementIndexUint)
725                 return false;
726             numElements /= sizeof(GCGLuint);
727             const GCGLuint* p = static_cast&lt;const GCGLuint*&gt;(buffer-&gt;data());
728             for (GCGLsizeiptr i = 0; i &lt; numElements; i++)
729                 maxIndex = maxIndex ? std::max(maxIndex.value(), static_cast&lt;unsigned&gt;(p[i])) : static_cast&lt;unsigned&gt;(p[i]);
730             break;
731         }
732         default:
733             return false;
734         }
735         if (maxIndex)
736             elementArrayBuffer-&gt;setCachedMaxIndex(type, maxIndex.value());
737     }
738 
739     if (!maxIndex)
740         return false;
741 
742     // The number of required elements is one more than the maximum index that will be accessed.
743     auto checkedNumElementsRequired = checkedAddAndMultiply&lt;unsigned&gt;(maxIndex.value(), 1, 1);
744     if (!checkedNumElementsRequired)
745         return false;
746     numElementsRequired = checkedNumElementsRequired.value();
747 
748     return true;
749 }
750 
751 bool WebGLRenderingContext::validateBlendEquation(const char* functionName, GCGLenum mode)
752 {
753     switch (mode) {
754     case GraphicsContextGL::FUNC_ADD:
755     case GraphicsContextGL::FUNC_SUBTRACT:
756     case GraphicsContextGL::FUNC_REVERSE_SUBTRACT:
757     case ExtensionsGL::MIN_EXT:
758     case ExtensionsGL::MAX_EXT:
759         if ((mode == ExtensionsGL::MIN_EXT || mode == ExtensionsGL::MAX_EXT) &amp;&amp; !m_extBlendMinMax) {
760             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid mode&quot;);
761             return false;
762         }
763         return true;
764         break;
765     default:
766         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid mode&quot;);
767         return false;
768     }
769 }
770 
771 bool WebGLRenderingContext::validateCapability(const char* functionName, GCGLenum cap)
772 {
773     switch (cap) {
774     case GraphicsContextGL::BLEND:
775     case GraphicsContextGL::CULL_FACE:
776     case GraphicsContextGL::DEPTH_TEST:
777     case GraphicsContextGL::DITHER:
778     case GraphicsContextGL::POLYGON_OFFSET_FILL:
779     case GraphicsContextGL::SAMPLE_ALPHA_TO_COVERAGE:
780     case GraphicsContextGL::SAMPLE_COVERAGE:
781     case GraphicsContextGL::SCISSOR_TEST:
782     case GraphicsContextGL::STENCIL_TEST:
783         return true;
784     default:
785         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid capability&quot;);
786         return false;
787     }
788 }
789 
790 } // namespace WebCore
791 
792 #endif // ENABLE(WEBGL)
    </pre>
  </body>
</html>
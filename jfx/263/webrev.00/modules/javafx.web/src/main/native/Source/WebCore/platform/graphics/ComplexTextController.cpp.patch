diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ComplexTextController.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ComplexTextController.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ComplexTextController.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ComplexTextController.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2007, 2008, 2009, 2010, 2011 Apple Inc. All rights reserved.
+ * Copyright (C) 2007-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -41,32 +41,10 @@
 #include <CoreText/CoreText.h>
 #endif
 
 namespace WebCore {
 
-#if PLATFORM(WIN)
-
-class TextLayout {
-};
-
-void TextLayoutDeleter::operator()(TextLayout*) const
-{
-}
-
-std::unique_ptr<TextLayout, TextLayoutDeleter> FontCascade::createLayout(RenderText&, float, bool) const
-{
-    return nullptr;
-}
-
-float FontCascade::width(TextLayout&, unsigned, unsigned, HashSet<const Font*>*)
-{
-    ASSERT_NOT_REACHED();
-    return 0;
-}
-
-#else
-
 class TextLayout {
     WTF_MAKE_FAST_ALLOCATED;
 public:
     static bool isNeeded(RenderText& text, const FontCascade& font)
     {
@@ -144,14 +122,10 @@
     , m_end(run.length())
     , m_expansion(run.expansion())
     , m_mayUseNaturalWritingDirection(mayUseNaturalWritingDirection)
     , m_forTextEmphasis(forTextEmphasis)
 {
-#if PLATFORM(WIN)
-    ASSERT_NOT_REACHED();
-#endif
-
     computeExpansionOpportunity();
 
     collectComplexTextRuns();
 
     finishConstruction();
@@ -187,11 +161,11 @@
     }
 }
 
 unsigned ComplexTextController::offsetForPosition(float h, bool includePartialGlyphs)
 {
-    if (h >= m_totalWidth)
+    if (h >= m_totalAdvance.width())
         return m_run.ltr() ? m_end : 0;
 
     if (h < 0)
         return m_run.ltr() ? 0 : m_end;
 
@@ -757,11 +731,11 @@
             bool treatAsSpace = FontCascade::treatAsSpace(ch);
             CGGlyph glyph = treatAsSpace ? font.spaceGlyph() : glyphs[i];
             FloatSize advance = treatAsSpace ? FloatSize(spaceWidth, advances[i].height()) : advances[i];
 
             if (ch == '\t' && m_run.allowTabs())
-                advance.setWidth(m_font.tabWidth(font, m_run.tabSize(), m_run.xPos() + m_totalWidth));
+                advance.setWidth(m_font.tabWidth(font, m_run.tabSize(), m_run.xPos() + m_totalAdvance.width()));
             else if (FontCascade::treatAsZeroWidthSpace(ch) && !treatAsSpace) {
                 advance.setWidth(0);
                 glyph = font.spaceGlyph();
             }
 
@@ -794,11 +768,12 @@
                 if (runForbidsLeadingExpansion)
                     forbidLeadingExpansion = m_run.ltr() ? isFirstCharacter : isLastCharacter;
                 if (runForbidsTrailingExpansion)
                     forbidTrailingExpansion = m_run.ltr() ? isLastCharacter : isFirstCharacter;
                 // Handle justification and word-spacing.
-                bool ideograph = FontCascade::isCJKIdeographOrSymbol(ch);
+                static bool expandAroundIdeographs = FontCascade::canExpandAroundIdeographsInComplexText();
+                bool ideograph = expandAroundIdeographs && FontCascade::isCJKIdeographOrSymbol(ch);
                 if (treatAsSpace || ideograph || forceLeadingExpansion || forceTrailingExpansion) {
                     // Distribute the run's total expansion evenly over all expansion opportunities in the run.
                     if (m_expansion) {
                         auto [expandLeft, expandRight] = expansionLocation(ideograph, treatAsSpace, m_run.ltr(), afterExpansion, forbidLeadingExpansion, forbidTrailingExpansion, forceLeadingExpansion, forceTrailingExpansion);
                         if (expandLeft) {
@@ -807,11 +782,11 @@
                             if (m_adjustedBaseAdvances.isEmpty()) {
                                 advance.expand(m_expansionPerOpportunity, 0);
                                 complexTextRun.growInitialAdvanceHorizontally(m_expansionPerOpportunity);
                             } else {
                                 m_adjustedBaseAdvances.last().expand(m_expansionPerOpportunity, 0);
-                                m_totalWidth += m_expansionPerOpportunity;
+                                m_totalAdvance.expand(m_expansionPerOpportunity, 0);
                             }
                         }
                         if (expandRight) {
                             m_expansion -= m_expansionPerOpportunity;
                             advance.expand(m_expansionPerOpportunity, 0);
@@ -825,11 +800,11 @@
                         advance.expand(m_font.wordSpacing(), 0);
                 } else
                     afterExpansion = false;
             }
 
-            m_totalWidth += advance.width();
+            m_totalAdvance += advance;
 
             // FIXME: Combining marks should receive a text emphasis mark if they are combine with a space.
             if (m_forTextEmphasis && (!FontCascade::canReceiveTextEmphasis(ch) || (U_GET_GC_MASK(ch) & U_GC_M_MASK)))
                 glyph = 0;
 
@@ -902,8 +877,6 @@
     , m_stringLocation(stringLocation)
     , m_isLTR(ltr)
 {
 }
 
-#endif
-
 } // namespace WebCore

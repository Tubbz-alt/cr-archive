<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/workers/Worker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DedicatedWorkerThread.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Worker.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/Worker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;Worker.h&quot;
 29 
 30 #include &quot;ContentSecurityPolicy.h&quot;

 31 #include &quot;Event.h&quot;
 32 #include &quot;EventNames.h&quot;
 33 #include &quot;InspectorInstrumentation.h&quot;
 34 #include &quot;LoaderStrategy.h&quot;
 35 #include &quot;PlatformStrategies.h&quot;
 36 #include &quot;ResourceResponse.h&quot;
 37 #include &quot;SecurityOrigin.h&quot;
 38 #include &quot;WorkerGlobalScopeProxy.h&quot;
 39 #include &quot;WorkerScriptLoader.h&quot;
 40 #include &quot;WorkerThread.h&quot;
 41 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;

 42 #include &lt;wtf/HashSet.h&gt;
 43 #include &lt;wtf/IsoMallocInlines.h&gt;
 44 #include &lt;wtf/MainThread.h&gt;
 45 #include &lt;wtf/NeverDestroyed.h&gt;
 46 #include &lt;wtf/Scope.h&gt;
 47 
 48 namespace WebCore {
 49 
 50 WTF_MAKE_ISO_ALLOCATED_IMPL(Worker);
 51 
 52 static HashSet&lt;Worker*&gt;&amp; allWorkers()
 53 {
 54     static NeverDestroyed&lt;HashSet&lt;Worker*&gt;&gt; set;
 55     return set;
 56 }
 57 
 58 void Worker::networkStateChanged(bool isOnLine)
 59 {
 60     for (auto* worker : allWorkers())
 61         worker-&gt;notifyNetworkStateChange(isOnLine);
</pre>
<hr />
<pre>
108     ResourceRequest request { scriptURL.releaseReturnValue() };
109     request.setInitiatorIdentifier(worker-&gt;m_identifier);
110 
111     FetchOptions fetchOptions;
112     fetchOptions.mode = FetchOptions::Mode::SameOrigin;
113     fetchOptions.cache = FetchOptions::Cache::Default;
114     fetchOptions.redirect = FetchOptions::Redirect::Follow;
115     fetchOptions.destination = FetchOptions::Destination::Worker;
116     worker-&gt;m_scriptLoader-&gt;loadAsynchronously(context, WTFMove(request), WTFMove(fetchOptions), contentSecurityPolicyEnforcement, ServiceWorkersMode::All, worker);
117     return worker;
118 }
119 
120 Worker::~Worker()
121 {
122     ASSERT(isMainThread());
123     ASSERT(scriptExecutionContext()); // The context is protected by worker context proxy, so it cannot be destroyed while a Worker exists.
124     allWorkers().remove(this);
125     m_contextProxy.workerObjectDestroyed();
126 }
127 
<span class="line-modified">128 ExceptionOr&lt;void&gt; Worker::postMessage(JSC::ExecState&amp; state, JSC::JSValue messageValue, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp; transfer)</span>
129 {
130     Vector&lt;RefPtr&lt;MessagePort&gt;&gt; ports;
<span class="line-modified">131     auto message = SerializedScriptValue::create(state, messageValue, WTFMove(transfer), ports, SerializationContext::WorkerPostMessage);</span>
132     if (message.hasException())
133         return message.releaseException();
134 
135     // Disentangle the port in preparation for sending it to the remote context.
136     auto channels = MessagePort::disentanglePorts(WTFMove(ports));
137     if (channels.hasException())
138         return channels.releaseException();
139 
140     m_contextProxy.postMessageToWorkerGlobalScope({ message.releaseReturnValue(), channels.releaseReturnValue() });
141     return { };
142 }
143 
144 void Worker::terminate()
145 {
146     m_contextProxy.terminateWorkerGlobalScope();
<span class="line-modified">147 }</span>
<span class="line-removed">148 </span>
<span class="line-removed">149 bool Worker::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">150 {</span>
<span class="line-removed">151     // FIXME: It is not currently possible to suspend a worker, so pages with workers can not go into page cache.</span>
<span class="line-removed">152     return false;</span>
153 }
154 
155 const char* Worker::activeDOMObjectName() const
156 {
157     return &quot;Worker&quot;;
158 }
159 
160 void Worker::stop()
161 {
162     terminate();
163 }
164 
















165 bool Worker::hasPendingActivity() const
166 {
167     return m_contextProxy.hasPendingActivity() || ActiveDOMObject::hasPendingActivity();
168 }
169 
170 void Worker::notifyNetworkStateChange(bool isOnLine)
171 {
172     m_contextProxy.notifyNetworkStateChange(isOnLine);
173 }
174 
175 void Worker::didReceiveResponse(unsigned long identifier, const ResourceResponse&amp; response)
176 {
177     const URL&amp; responseURL = response.url();
178     if (!responseURL.protocolIsBlob() &amp;&amp; !responseURL.protocolIs(&quot;file&quot;) &amp;&amp; !SecurityOrigin::create(responseURL)-&gt;isUnique())
179         m_contentSecurityPolicyResponseHeaders = ContentSecurityPolicyResponseHeaders(response);
180     InspectorInstrumentation::didReceiveScriptResponse(scriptExecutionContext(), identifier);
181 }
182 
183 void Worker::notifyFinished()
184 {
185     auto clearLoader = makeScopeExit([this] {
186         m_scriptLoader = nullptr;
187         unsetPendingActivity(*this);
188     });
189 
190     auto* context = scriptExecutionContext();
191     if (!context)
192         return;
193 
194     if (m_scriptLoader-&gt;failed()) {
<span class="line-modified">195         dispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::Yes));</span>
196         return;
197     }
198 
199     bool isOnline = platformStrategies()-&gt;loaderStrategy()-&gt;isOnLine();
200     const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicyResponseHeaders = m_contentSecurityPolicyResponseHeaders ? m_contentSecurityPolicyResponseHeaders.value() : context-&gt;contentSecurityPolicy()-&gt;responseHeaders();
<span class="line-modified">201     m_contextProxy.startWorkerGlobalScope(m_scriptLoader-&gt;url(), m_name, context-&gt;userAgent(m_scriptLoader-&gt;url()), isOnline, m_scriptLoader-&gt;script(), contentSecurityPolicyResponseHeaders, m_shouldBypassMainWorldContentSecurityPolicy, m_workerCreationTime, m_runtimeFlags, context-&gt;sessionID());</span>



202     InspectorInstrumentation::scriptImported(*context, m_scriptLoader-&gt;identifier(), m_scriptLoader-&gt;script());
203 }
204 












205 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;Worker.h&quot;
 29 
 30 #include &quot;ContentSecurityPolicy.h&quot;
<span class="line-added"> 31 #include &quot;ErrorEvent.h&quot;</span>
 32 #include &quot;Event.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;InspectorInstrumentation.h&quot;
 35 #include &quot;LoaderStrategy.h&quot;
 36 #include &quot;PlatformStrategies.h&quot;
 37 #include &quot;ResourceResponse.h&quot;
 38 #include &quot;SecurityOrigin.h&quot;
 39 #include &quot;WorkerGlobalScopeProxy.h&quot;
 40 #include &quot;WorkerScriptLoader.h&quot;
 41 #include &quot;WorkerThread.h&quot;
 42 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
<span class="line-added"> 43 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;</span>
 44 #include &lt;wtf/HashSet.h&gt;
 45 #include &lt;wtf/IsoMallocInlines.h&gt;
 46 #include &lt;wtf/MainThread.h&gt;
 47 #include &lt;wtf/NeverDestroyed.h&gt;
 48 #include &lt;wtf/Scope.h&gt;
 49 
 50 namespace WebCore {
 51 
 52 WTF_MAKE_ISO_ALLOCATED_IMPL(Worker);
 53 
 54 static HashSet&lt;Worker*&gt;&amp; allWorkers()
 55 {
 56     static NeverDestroyed&lt;HashSet&lt;Worker*&gt;&gt; set;
 57     return set;
 58 }
 59 
 60 void Worker::networkStateChanged(bool isOnLine)
 61 {
 62     for (auto* worker : allWorkers())
 63         worker-&gt;notifyNetworkStateChange(isOnLine);
</pre>
<hr />
<pre>
110     ResourceRequest request { scriptURL.releaseReturnValue() };
111     request.setInitiatorIdentifier(worker-&gt;m_identifier);
112 
113     FetchOptions fetchOptions;
114     fetchOptions.mode = FetchOptions::Mode::SameOrigin;
115     fetchOptions.cache = FetchOptions::Cache::Default;
116     fetchOptions.redirect = FetchOptions::Redirect::Follow;
117     fetchOptions.destination = FetchOptions::Destination::Worker;
118     worker-&gt;m_scriptLoader-&gt;loadAsynchronously(context, WTFMove(request), WTFMove(fetchOptions), contentSecurityPolicyEnforcement, ServiceWorkersMode::All, worker);
119     return worker;
120 }
121 
122 Worker::~Worker()
123 {
124     ASSERT(isMainThread());
125     ASSERT(scriptExecutionContext()); // The context is protected by worker context proxy, so it cannot be destroyed while a Worker exists.
126     allWorkers().remove(this);
127     m_contextProxy.workerObjectDestroyed();
128 }
129 
<span class="line-modified">130 ExceptionOr&lt;void&gt; Worker::postMessage(JSC::JSGlobalObject&amp; state, JSC::JSValue messageValue, PostMessageOptions&amp;&amp; options)</span>
131 {
132     Vector&lt;RefPtr&lt;MessagePort&gt;&gt; ports;
<span class="line-modified">133     auto message = SerializedScriptValue::create(state, messageValue, WTFMove(options.transfer), ports, SerializationContext::WorkerPostMessage);</span>
134     if (message.hasException())
135         return message.releaseException();
136 
137     // Disentangle the port in preparation for sending it to the remote context.
138     auto channels = MessagePort::disentanglePorts(WTFMove(ports));
139     if (channels.hasException())
140         return channels.releaseException();
141 
142     m_contextProxy.postMessageToWorkerGlobalScope({ message.releaseReturnValue(), channels.releaseReturnValue() });
143     return { };
144 }
145 
146 void Worker::terminate()
147 {
148     m_contextProxy.terminateWorkerGlobalScope();
<span class="line-modified">149     m_wasTerminated = true;</span>





150 }
151 
152 const char* Worker::activeDOMObjectName() const
153 {
154     return &quot;Worker&quot;;
155 }
156 
157 void Worker::stop()
158 {
159     terminate();
160 }
161 
<span class="line-added">162 void Worker::suspend(ReasonForSuspension reason)</span>
<span class="line-added">163 {</span>
<span class="line-added">164     if (reason == ReasonForSuspension::BackForwardCache) {</span>
<span class="line-added">165         m_contextProxy.suspendForBackForwardCache();</span>
<span class="line-added">166         m_isSuspendedForBackForwardCache = true;</span>
<span class="line-added">167     }</span>
<span class="line-added">168 }</span>
<span class="line-added">169 </span>
<span class="line-added">170 void Worker::resume()</span>
<span class="line-added">171 {</span>
<span class="line-added">172     if (m_isSuspendedForBackForwardCache) {</span>
<span class="line-added">173         m_contextProxy.resumeForBackForwardCache();</span>
<span class="line-added">174         m_isSuspendedForBackForwardCache = false;</span>
<span class="line-added">175     }</span>
<span class="line-added">176 }</span>
<span class="line-added">177 </span>
178 bool Worker::hasPendingActivity() const
179 {
180     return m_contextProxy.hasPendingActivity() || ActiveDOMObject::hasPendingActivity();
181 }
182 
183 void Worker::notifyNetworkStateChange(bool isOnLine)
184 {
185     m_contextProxy.notifyNetworkStateChange(isOnLine);
186 }
187 
188 void Worker::didReceiveResponse(unsigned long identifier, const ResourceResponse&amp; response)
189 {
190     const URL&amp; responseURL = response.url();
191     if (!responseURL.protocolIsBlob() &amp;&amp; !responseURL.protocolIs(&quot;file&quot;) &amp;&amp; !SecurityOrigin::create(responseURL)-&gt;isUnique())
192         m_contentSecurityPolicyResponseHeaders = ContentSecurityPolicyResponseHeaders(response);
193     InspectorInstrumentation::didReceiveScriptResponse(scriptExecutionContext(), identifier);
194 }
195 
196 void Worker::notifyFinished()
197 {
198     auto clearLoader = makeScopeExit([this] {
199         m_scriptLoader = nullptr;
200         unsetPendingActivity(*this);
201     });
202 
203     auto* context = scriptExecutionContext();
204     if (!context)
205         return;
206 
207     if (m_scriptLoader-&gt;failed()) {
<span class="line-modified">208         queueTaskToDispatchEvent(*this, TaskSource::DOMManipulation, Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::Yes));</span>
209         return;
210     }
211 
212     bool isOnline = platformStrategies()-&gt;loaderStrategy()-&gt;isOnLine();
213     const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicyResponseHeaders = m_contentSecurityPolicyResponseHeaders ? m_contentSecurityPolicyResponseHeaders.value() : context-&gt;contentSecurityPolicy()-&gt;responseHeaders();
<span class="line-modified">214     ReferrerPolicy referrerPolicy = ReferrerPolicy::EmptyString;</span>
<span class="line-added">215     if (auto policy = parseReferrerPolicy(m_scriptLoader-&gt;referrerPolicy(), ReferrerPolicySource::HTTPHeader))</span>
<span class="line-added">216         referrerPolicy = *policy;</span>
<span class="line-added">217     m_contextProxy.startWorkerGlobalScope(m_scriptLoader-&gt;url(), m_name, context-&gt;userAgent(m_scriptLoader-&gt;url()), isOnline, m_scriptLoader-&gt;script(), contentSecurityPolicyResponseHeaders, m_shouldBypassMainWorldContentSecurityPolicy, m_workerCreationTime, referrerPolicy, m_runtimeFlags);</span>
218     InspectorInstrumentation::scriptImported(*context, m_scriptLoader-&gt;identifier(), m_scriptLoader-&gt;script());
219 }
220 
<span class="line-added">221 void Worker::dispatchEvent(Event&amp; event)</span>
<span class="line-added">222 {</span>
<span class="line-added">223     if (m_wasTerminated)</span>
<span class="line-added">224         return;</span>
<span class="line-added">225 </span>
<span class="line-added">226     AbstractWorker::dispatchEvent(event);</span>
<span class="line-added">227     if (is&lt;ErrorEvent&gt;(event) &amp;&amp; !event.defaultPrevented() &amp;&amp; event.isTrusted() &amp;&amp; scriptExecutionContext()) {</span>
<span class="line-added">228         auto&amp; errorEvent = downcast&lt;ErrorEvent&gt;(event);</span>
<span class="line-added">229         scriptExecutionContext()-&gt;reportException(errorEvent.message(), errorEvent.lineno(), errorEvent.colno(), errorEvent.filename(), nullptr, nullptr);</span>
<span class="line-added">230     }</span>
<span class="line-added">231 }</span>
<span class="line-added">232 </span>
233 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="DedicatedWorkerThread.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Worker.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
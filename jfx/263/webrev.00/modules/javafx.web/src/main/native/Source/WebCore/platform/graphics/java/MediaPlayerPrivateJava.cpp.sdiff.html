<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/java/MediaPlayerPrivateJava.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ImageBufferJava.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="MediaPlayerPrivateJava.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/java/MediaPlayerPrivateJava.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 55 
 56     #define LOG_ERROR0(szFormat)                    ((void)0)
 57     #define LOG_ERROR1(szFormat, p1)                ((void)0)
 58 
 59     #define PLOG_TRACE0(szFormat)                    ((void)0)
 60     #define PLOG_TRACE1(szFormat, p1)                ((void)0)
 61     #define PLOG_TRACE2(szFormat, p1, p2)            ((void)0)
 62     #define PLOG_TRACE3(szFormat, p1, p2, p3)        ((void)0)
 63     #define PLOG_TRACE4(szFormat, p1, p2, p3, p4)    ((void)0)
 64 
 65     #define PLOG_ERROR0(szFormat)                    ((void)0)
 66     #define PLOG_ERROR1(szFormat, p1)                ((void)0)
 67 
 68 #else
 69 
 70     #include &lt;stdio.h&gt;
 71     #include &lt;wtf/Threading.h&gt;
 72 
 73     const char* networkStateStr(MediaPlayer::NetworkState networkState) {
 74         switch (networkState) {
<span class="line-modified"> 75         case MediaPlayer::Empty:</span>
 76             return &quot;Empty&quot;;
<span class="line-modified"> 77         case MediaPlayer::Idle:</span>
 78             return &quot;Idle&quot;;
<span class="line-modified"> 79         case MediaPlayer::Loading:</span>
 80             return &quot;Loading&quot;;
<span class="line-modified"> 81         case MediaPlayer::Loaded:</span>
 82             return &quot;Loaded&quot;;
<span class="line-modified"> 83         case MediaPlayer::FormatError:</span>
 84             return &quot;FormatError&quot;;
<span class="line-modified"> 85         case MediaPlayer::NetworkError:</span>
 86             return &quot;NetworkError&quot;;
<span class="line-modified"> 87         case MediaPlayer::DecodeError:</span>
 88             return &quot;DecodeError&quot;;
 89         }
 90         return &quot;&lt;unknown network state&gt;&quot;;
 91     }
 92 
 93     const char* readyStateStr(MediaPlayer::ReadyState readyState) {
 94         switch (readyState) {
<span class="line-modified"> 95         case MediaPlayer::HaveNothing:</span>
 96             return &quot;HaveNothing&quot;;
<span class="line-modified"> 97         case MediaPlayer::HaveMetadata:</span>
 98             return &quot;HaveMetadata&quot;;
<span class="line-modified"> 99         case MediaPlayer::HaveCurrentData:</span>
100             return &quot;HaveCurrentData&quot;;
<span class="line-modified">101         case MediaPlayer::HaveFutureData:</span>
102             return &quot;HaveFutureData&quot;;
<span class="line-modified">103         case MediaPlayer::HaveEnoughData:</span>
104             return &quot;HaveEnoughData&quot;;
105         }
106         return &quot;&lt;unknown ready state&gt;&quot;;
107     }
108 
109     namespace Logger {
110 
111         FILE* getLogStream() {
112             FILE *stream = stderr;
113             //FILE *stream = fopen(&quot;webVideo.log&quot;, &quot;a&quot;);
114             return stream;
115         }
116 
117         void releaseLogStream(FILE *stream) {
118             fflush(stream);
119             //fclose(stream);
120         }
121 
122         void AMLogf(const char* szLevel, const char* szFormat, ...) {
123             FILE *stream = getLogStream();
</pre>
<hr />
<pre>
146     #define LOG_TRACE2(szFormat, p1, p2)            Logger::AMLogf(&quot;INFO&quot;, szFormat, p1, p2)
147     #define LOG_TRACE3(szFormat, p1, p2, p3)        Logger::AMLogf(&quot;INFO&quot;, szFormat, p1, p2, p3)
148     #define LOG_TRACE4(szFormat, p1, p2, p3, p4)    Logger::AMLogf(&quot;INFO&quot;, szFormat, p1, p2, p3, p4)
149 
150     #define LOG_ERROR0(szFormat)                    Logger::AMLogf(&quot;SEVERE&quot;, szFormat)
151     #define LOG_ERROR1(szFormat, p1)                Logger::AMLogf(&quot;SEVERE&quot;, szFormat, p1)
152 
153     #define PLOG_TRACE0(szFormat)                   Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat)
154     #define PLOG_TRACE1(szFormat, p1)               Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat, p1)
155     #define PLOG_TRACE2(szFormat, p1, p2)           Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat, p1, p2)
156     #define PLOG_TRACE3(szFormat, p1, p2, p3)       Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat, p1, p2, p3)
157     #define PLOG_TRACE4(szFormat, p1, p2, p3, p4)   Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat, p1, p2, p3, p4)
158 
159     #define PLOG_ERROR0(szFormat)                   Logger::AMLogf_p(this, &quot;SEVERE&quot;, szFormat)
160     #define PLOG_ERROR1(szFormat, p1)               Logger::AMLogf_p(this, &quot;SEVERE&quot;, szFormat, p1)
161 
162 #endif
163 
164 ////////////////////////
165 



166 




167 










168 
169 void MediaPlayerPrivate::registerMediaEngine(MediaEngineRegistrar registrar)
170 {
171     LOG_TRACE0(&quot;&gt;&gt;registerMediaEngine\n&quot;);
172     JNIEnv* env = WTF::GetJavaEnv();
173     jclass playerCls = PG_GetMediaPlayerClass(env);
174     if (!playerCls) {
175         LOG_ERROR0(&quot;&lt;&lt;registerMediaEngine ERROR: MediaPlayer class is unavailable\n&quot;);
176         return;
177     }
<span class="line-modified">178     //CreateMediaEnginePlayer, MediaEngineSupportedTypes, MediaEngineSupportsType,</span>
<span class="line-modified">179     //MediaEngineGetSitesInMediaCache, MediaEngineClearMediaCache, MediaEngineClearMediaCacheForSite</span>
<span class="line-removed">180     registrar([] (MediaPlayer* player) { return std::unique_ptr&lt;MediaPlayerPrivate&gt;(new MediaPlayerPrivate(player)); },</span>
<span class="line-removed">181         MediaEngineSupportedTypes, MediaEngineSupportsType, 0, 0, 0, 0);</span>
182 }
183 
184 void MediaPlayerPrivate::MediaEngineSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; types)
185 {
186     LOG_TRACE0(&quot;&gt;&gt;MediaEngineSupportedTypes\n&quot;);
187     HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; supportedTypes = GetSupportedTypes();
188     for (const auto&amp; type : supportedTypes) {
189         types.add(type);
190     }
191     LOG_TRACE0(&quot;&lt;&lt;MediaEngineSupportedTypes\n&quot;);
192 }
193 
194 MediaPlayer::SupportsType MediaPlayerPrivate::MediaEngineSupportsType(const MediaEngineSupportParameters&amp; parameters)
195 {
196     for (const auto&amp; codecValue: parameters.type.codecs()) {
197         UNUSED_PARAM(codecValue);
198         LOG_TRACE2(&quot;&gt;&gt;MediaEngineSupportsType, type=%s, codecs=%s\n&quot;, parameters.type.raw().utf8().data(), codecValue.utf8().data());
199     }
200 
201     if (parameters.type.isEmpty()) {
202         LOG_TRACE0(&quot;&lt;&lt;MediaEngineSupportsType: NOT supported (type is empty)\n&quot;);
<span class="line-modified">203         return MediaPlayer::IsNotSupported;</span>
204     }
205 
206     if (GetSupportedTypes().contains(parameters.type.containerType())) {
207         LOG_TRACE0(&quot;&lt;&lt;MediaEngineSupportsType: MayBeSupported/IsSupported\n&quot;);
208         auto codecs = parameters.type.parameter(ContentType::codecsParameter());
<span class="line-modified">209         return codecs.isEmpty() ? MediaPlayer::MayBeSupported : MediaPlayer::IsSupported;</span>
210     }
211     LOG_TRACE0(&quot;&lt;&lt;MediaEngineSupportsType: NOT supported\n&quot;);
<span class="line-modified">212     return MediaPlayer::IsNotSupported;</span>
213 }
214 
215 HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; MediaPlayerPrivate::GetSupportedTypes()
216 {
217     static HashSet&lt;String, ASCIICaseInsensitiveHash&gt; supportedTypes;
218     // TODO: refresh after change
219 
220     if (!supportedTypes.isEmpty()) {
221         return supportedTypes;
222     }
223 
224     JNIEnv* env = WTF::GetJavaEnv();
225     static jmethodID s_mID = env-&gt;GetMethodID(PG_GetGraphicsManagerClass(env),
226         &quot;getSupportedMediaTypes&quot;, &quot;()[Ljava/lang/String;&quot;);
227     ASSERT(s_mID);
228 
229     JLocalRef&lt;jobjectArray&gt; jArray(
230         (jobjectArray)env-&gt;CallObjectMethod(PL_GetGraphicsManager(env), s_mID));
231     ASSERT(jArray);
232     WTF::CheckAndClearException(env);
233 
234     jsize len = env-&gt;GetArrayLength(jArray);
235     for (jsize  i=0; i&lt;len; i++) {
236         JLString jStr((jstring)env-&gt;GetObjectArrayElement(jArray, i));
237         String s(env, jStr);
238         supportedTypes.add(s);
239     }
240 
241     return supportedTypes;
242 }
243 
244 
245 // *********************************************************
246 // MediaPlayerPrivate
247 // *********************************************************
248 MediaPlayerPrivate::MediaPlayerPrivate(MediaPlayer *player)
249     : m_player(player)
<span class="line-modified">250     , m_networkState(MediaPlayer::Empty)</span>
<span class="line-modified">251     , m_readyState(MediaPlayer::HaveNothing)</span>
252     , m_isVisible(false)
253     , m_hasVideo(false)
254     , m_hasAudio(false)
255     , m_paused(true)
256     , m_seeking(false)
257     , m_seekTime(0)
258     , m_duration(0)
259     , m_bytesLoaded(0)
260     , m_didLoadingProgress(false)
261 {
262     JNIEnv* env = WTF::GetJavaEnv();
263     static jmethodID mid = env-&gt;GetMethodID(PG_GetGraphicsManagerClass(env),
264         &quot;fwkCreateMediaPlayer&quot;, &quot;(J)Lcom/sun/webkit/graphics/WCMediaPlayer;&quot;);
265     ASSERT(mid);
266 
267     JLocalRef&lt;jobject&gt; obj(env-&gt;CallObjectMethod(PL_GetGraphicsManager(env),
268         mid, ptr_to_jlong(this)));
269     ASSERT(obj);
270     WTF::CheckAndClearException(env);
271 
272     m_buffered = std::make_unique&lt;PlatformTimeRanges&gt;();
273     m_jPlayer = RQRef::create(obj);
274 }
275 
276 MediaPlayerPrivate::~MediaPlayerPrivate()
277 {
278     WC_GETJAVAENV_CHKRET(env);
279     static jmethodID s_mID
280         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkDispose&quot;, &quot;()V&quot;);
281     ASSERT(s_mID);
282 
283     env-&gt;CallVoidMethod(*m_jPlayer, s_mID);
284     WTF::CheckAndClearException(env);
285 }
286 
287 void MediaPlayerPrivate::load(const String&amp; url)
288 {
<span class="line-modified">289     if (m_networkState == MediaPlayer::Loading) {</span>
290         cancelLoad();
291     }
292 
293     String userAgent;
294     // MediaPlayerClient mpClient = m_player-&gt;client();
295     // Document* doc = mpClient.mediaPlayerOwningDocument(); //XXX: mediaPlayerOwningDocument removed
296     // if (doc != NULL &amp;&amp; doc-&gt;settings() != NULL) {
297     //     userAgent = doc-&gt;settings()-&gt;userAgent();
298     // }
299 
300     JNIEnv* env = WTF::GetJavaEnv();
301     static jmethodID s_mID
302         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkLoad&quot;, &quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;);
303     ASSERT(s_mID);
304 
305     env-&gt;CallVoidMethod(*m_jPlayer, s_mID,
306         (jstring)url.toJavaString(env),
307         userAgent.isEmpty() ? NULL : (jstring)userAgent.toJavaString(env));
308     WTF::CheckAndClearException(env);
309 }
</pre>
<hr />
<pre>
569     if (!m_isVisible) {
570         PLOG_TRACE0(&quot;&lt;&lt;MediaPlayerPrivate paint (!visible)\n&quot;);
571         return;
572     }
573 
574     gc.platformContext()-&gt;rq().freeSpace(24)
575     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_RENDERMEDIAPLAYER
576     &lt;&lt; m_jPlayer &lt;&lt; (jint)r.x() &lt;&lt;  (jint)r.y()
577     &lt;&lt; (jint)r.width() &lt;&lt; (jint)r.height();
578 
579 //    PLOG_TRACE0(&quot;&lt;&lt;MediaPlayerPrivate paint (OK)\n&quot;);
580 }
581 
582 //void MediaPlayerPrivate::paintCurrentFrameInContext(GraphicsContext* c, const IntRect&amp; r) { paint(c, r); }
583 
584 void MediaPlayerPrivate::setPreload(MediaPlayer::Preload preload)
585 {
586     // enum Preload { None, MetaData, Auto };
587     PLOG_TRACE1(&quot;MediaPlayerPrivate setPreload, preload=%u\n&quot;, (int)preload);
588     jint jPreload =
<span class="line-modified">589         (preload == MediaPlayer::None) ? com_sun_webkit_graphics_WCMediaPlayer_PRELOAD_NONE</span>
<span class="line-modified">590         : (preload == MediaPlayer::MetaData) ? com_sun_webkit_graphics_WCMediaPlayer_PRELOAD_METADATA</span>
<span class="line-modified">591         : (preload == MediaPlayer::Auto) ? com_sun_webkit_graphics_WCMediaPlayer_PRELOAD_AUTO</span>
592         : -1;
593     if (jPreload &lt; 0) {
594         // unexpected preload value
595         return;
596     }
597     JNIEnv* env = WTF::GetJavaEnv();
598     static jmethodID s_mID
599         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkSetPreload&quot;, &quot;(I)V&quot;);
600     ASSERT(s_mID);
601 
602     env-&gt;CallVoidMethod(*m_jPlayer, s_mID, jPreload);
603     WTF::CheckAndClearException(env);
604 }
605 
<span class="line-modified">606 //bool MediaPlayerPrivate::hasAvailableVideoFrame() const { return readyState() &gt;= MediaPlayer::HaveCurrentData; }</span>
607 
608 //bool MediaPlayerPrivate::canLoadPoster() const { return false; }
609 //void MediaPlayerPrivate::setPoster(const String&amp;) { }
610 
611 //#if ENABLE(PLUGIN_PROXY_FOR_VIDEO)
612 //        virtual void deliverNotification(MediaPlayerProxyNotificationType) = 0;
613 //        virtual void setMediaPlayerProxy(WebMediaPlayerProxy*) = 0;
614 //#endif
615 
616 //#if USE(ACCELERATED_COMPOSITING)
617 //        // whether accelerated rendering is supported by the media engine for the current media.
618 //        virtual bool supportsAcceleratedRendering() const { return false; }
619 //        // called when the rendering system flips the into or out of accelerated rendering mode.
620 //        virtual void acceleratedRenderingStateChanged() { }
621 //#endif
622 
623 //bool MediaPlayerPrivate::hasSingleSecurityOrigin() const { return false; }
624 
<span class="line-modified">625 //MediaPlayer::MovieLoadType MediaPlayerPrivate::movieLoadType() const { return MediaPlayer::Unknown; }</span>
626 
627 void MediaPlayerPrivate::setNetworkState(MediaPlayer::NetworkState networkState)
628 {
629     if (m_networkState != networkState) {
630         PLOG_TRACE4(&quot;MediaPlayerPrivate NetworkState: %s (%d) =&gt; %s (%d)\n&quot;,
631             networkStateStr(m_networkState), (int)m_networkState, networkStateStr(networkState), (int)networkState);
632         m_networkState = networkState;
633         m_player-&gt;networkStateChanged();
634     }
635 }
636 
637 void MediaPlayerPrivate::setReadyState(MediaPlayer::ReadyState readyState)
638 {
639     if (m_readyState != readyState) {
640         PLOG_TRACE4(&quot;MediaPlayerPrivate ReadyState: %s (%d) =&gt; %s (%d)\n&quot;,
641             readyStateStr(m_readyState), (int)m_readyState, readyStateStr(readyState), (int)readyState);
642         m_readyState = readyState;
643         m_player-&gt;readyStateChanged();
644     }
645 }
646 
647 
648 MediaPlayerPrivate* MediaPlayerPrivate::getPlayer(jlong ptr)
649 {
650     return reinterpret_cast&lt;MediaPlayerPrivate *&gt;(jlong_to_ptr(ptr));
651 }
652 
653 void MediaPlayerPrivate::notifyNetworkStateChanged(int networkState)
654 {
655     switch (networkState) {
656     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_EMPTY:
<span class="line-modified">657         setNetworkState(MediaPlayer::Empty);</span>
658         break;
659     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_IDLE:
<span class="line-modified">660         setNetworkState(MediaPlayer::Idle);</span>
661         break;
662     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_LOADING:
<span class="line-modified">663         setNetworkState(MediaPlayer::Loading);</span>
664         break;
665     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_LOADED:
<span class="line-modified">666         setNetworkState(MediaPlayer::Loaded);</span>
667         break;
668     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_FORMAT_ERROR:
<span class="line-modified">669         setNetworkState(MediaPlayer::FormatError);</span>
670         break;
671     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_NETWORK_ERROR:
<span class="line-modified">672         setNetworkState(MediaPlayer::NetworkError);</span>
673         break;
674     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_DECODE_ERROR:
<span class="line-modified">675         setNetworkState(MediaPlayer::DecodeError);</span>
676         break;
677     }
678 }
679 
680 void MediaPlayerPrivate::notifyReadyStateChanged(int readyState)
681 {
682     switch (readyState) {
683     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_NOTHING:
<span class="line-modified">684         setReadyState(MediaPlayer::HaveNothing);</span>
685         break;
686     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_METADATA:
<span class="line-modified">687         setReadyState(MediaPlayer::HaveMetadata);</span>
688         break;
689     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_CURRENT_DATA:
<span class="line-modified">690         setReadyState(MediaPlayer::HaveCurrentData);</span>
691         break;
692     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_FUTURE_DATA:
<span class="line-modified">693         setReadyState(MediaPlayer::HaveFutureData);</span>
694         break;
695     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_ENOUGH_DATA:
<span class="line-modified">696         setReadyState(MediaPlayer::HaveEnoughData);</span>
697         break;
698     }
699 }
700 
701 void MediaPlayerPrivate::notifyPaused(bool paused)
702 {
703     PLOG_TRACE2(&quot;&gt;&gt;MediaPlayerPrivate notifyPaused: %d =&gt; %d\n&quot;, m_paused ? 1 : 0, paused ? 1 : 0);
704 
705     if (m_paused != paused) {
706         m_paused = paused;
707         m_player-&gt;playbackStateChanged();
708     }
709 }
710 
711 void MediaPlayerPrivate::notifySeeking(bool seeking)
712 {
713     PLOG_TRACE2(&quot;&gt;&gt;MediaPlayerPrivate notifySeeking: %d =&gt; %d\n&quot;, m_seeking ? 1 : 0, seeking ? 1 : 0);
714     if (m_seeking != seeking) {
715         m_seeking = seeking;
716         if (!seeking) {
</pre>
</td>
<td>
<hr />
<pre>
 55 
 56     #define LOG_ERROR0(szFormat)                    ((void)0)
 57     #define LOG_ERROR1(szFormat, p1)                ((void)0)
 58 
 59     #define PLOG_TRACE0(szFormat)                    ((void)0)
 60     #define PLOG_TRACE1(szFormat, p1)                ((void)0)
 61     #define PLOG_TRACE2(szFormat, p1, p2)            ((void)0)
 62     #define PLOG_TRACE3(szFormat, p1, p2, p3)        ((void)0)
 63     #define PLOG_TRACE4(szFormat, p1, p2, p3, p4)    ((void)0)
 64 
 65     #define PLOG_ERROR0(szFormat)                    ((void)0)
 66     #define PLOG_ERROR1(szFormat, p1)                ((void)0)
 67 
 68 #else
 69 
 70     #include &lt;stdio.h&gt;
 71     #include &lt;wtf/Threading.h&gt;
 72 
 73     const char* networkStateStr(MediaPlayer::NetworkState networkState) {
 74         switch (networkState) {
<span class="line-modified"> 75         case MediaPlayer::NetworkState::Empty:</span>
 76             return &quot;Empty&quot;;
<span class="line-modified"> 77         case MediaPlayer::NetworkState::Idle:</span>
 78             return &quot;Idle&quot;;
<span class="line-modified"> 79         case MediaPlayer::NetworkState::Loading:</span>
 80             return &quot;Loading&quot;;
<span class="line-modified"> 81         case MediaPlayer::NetworkState::Loaded:</span>
 82             return &quot;Loaded&quot;;
<span class="line-modified"> 83         case MediaPlayer::NetworkState::FormatError:</span>
 84             return &quot;FormatError&quot;;
<span class="line-modified"> 85         case MediaPlayer::NetworkState::NetworkError:</span>
 86             return &quot;NetworkError&quot;;
<span class="line-modified"> 87         case MediaPlayer::NetworkState::DecodeError:</span>
 88             return &quot;DecodeError&quot;;
 89         }
 90         return &quot;&lt;unknown network state&gt;&quot;;
 91     }
 92 
 93     const char* readyStateStr(MediaPlayer::ReadyState readyState) {
 94         switch (readyState) {
<span class="line-modified"> 95         case MediaPlayer::ReadyState::HaveNothing:</span>
 96             return &quot;HaveNothing&quot;;
<span class="line-modified"> 97         case MediaPlayer::ReadyState::HaveMetadata:</span>
 98             return &quot;HaveMetadata&quot;;
<span class="line-modified"> 99         case MediaPlayer::ReadyState::HaveCurrentData:</span>
100             return &quot;HaveCurrentData&quot;;
<span class="line-modified">101         case MediaPlayer::ReadyState::HaveFutureData:</span>
102             return &quot;HaveFutureData&quot;;
<span class="line-modified">103         case MediaPlayer::ReadyState::HaveEnoughData:</span>
104             return &quot;HaveEnoughData&quot;;
105         }
106         return &quot;&lt;unknown ready state&gt;&quot;;
107     }
108 
109     namespace Logger {
110 
111         FILE* getLogStream() {
112             FILE *stream = stderr;
113             //FILE *stream = fopen(&quot;webVideo.log&quot;, &quot;a&quot;);
114             return stream;
115         }
116 
117         void releaseLogStream(FILE *stream) {
118             fflush(stream);
119             //fclose(stream);
120         }
121 
122         void AMLogf(const char* szLevel, const char* szFormat, ...) {
123             FILE *stream = getLogStream();
</pre>
<hr />
<pre>
146     #define LOG_TRACE2(szFormat, p1, p2)            Logger::AMLogf(&quot;INFO&quot;, szFormat, p1, p2)
147     #define LOG_TRACE3(szFormat, p1, p2, p3)        Logger::AMLogf(&quot;INFO&quot;, szFormat, p1, p2, p3)
148     #define LOG_TRACE4(szFormat, p1, p2, p3, p4)    Logger::AMLogf(&quot;INFO&quot;, szFormat, p1, p2, p3, p4)
149 
150     #define LOG_ERROR0(szFormat)                    Logger::AMLogf(&quot;SEVERE&quot;, szFormat)
151     #define LOG_ERROR1(szFormat, p1)                Logger::AMLogf(&quot;SEVERE&quot;, szFormat, p1)
152 
153     #define PLOG_TRACE0(szFormat)                   Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat)
154     #define PLOG_TRACE1(szFormat, p1)               Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat, p1)
155     #define PLOG_TRACE2(szFormat, p1, p2)           Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat, p1, p2)
156     #define PLOG_TRACE3(szFormat, p1, p2, p3)       Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat, p1, p2, p3)
157     #define PLOG_TRACE4(szFormat, p1, p2, p3, p4)   Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat, p1, p2, p3, p4)
158 
159     #define PLOG_ERROR0(szFormat)                   Logger::AMLogf_p(this, &quot;SEVERE&quot;, szFormat)
160     #define PLOG_ERROR1(szFormat, p1)               Logger::AMLogf_p(this, &quot;SEVERE&quot;, szFormat, p1)
161 
162 #endif
163 
164 ////////////////////////
165 
<span class="line-added">166 class MediaPlayerFactoryJava final : public MediaPlayerFactory {</span>
<span class="line-added">167 private:</span>
<span class="line-added">168     MediaPlayerEnums::MediaEngineIdentifier identifier() const final { return MediaPlayerEnums::MediaEngineIdentifier::MediaFoundation; };</span>
169 
<span class="line-added">170     std::unique_ptr&lt;MediaPlayerPrivateInterface&gt; createMediaEnginePlayer(MediaPlayer* player) const final</span>
<span class="line-added">171     {</span>
<span class="line-added">172         return makeUnique&lt;MediaPlayerPrivate&gt;(player);</span>
<span class="line-added">173     }</span>
174 
<span class="line-added">175     void getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; types) const final</span>
<span class="line-added">176     {</span>
<span class="line-added">177         return MediaPlayerPrivate::MediaEngineSupportedTypes(types);</span>
<span class="line-added">178     }</span>
<span class="line-added">179 </span>
<span class="line-added">180     MediaPlayer::SupportsType supportsTypeAndCodecs(const MediaEngineSupportParameters&amp; parameters) const final</span>
<span class="line-added">181     {</span>
<span class="line-added">182         return MediaPlayerPrivate::MediaEngineSupportsType(parameters);</span>
<span class="line-added">183     }</span>
<span class="line-added">184 };</span>
185 
186 void MediaPlayerPrivate::registerMediaEngine(MediaEngineRegistrar registrar)
187 {
188     LOG_TRACE0(&quot;&gt;&gt;registerMediaEngine\n&quot;);
189     JNIEnv* env = WTF::GetJavaEnv();
190     jclass playerCls = PG_GetMediaPlayerClass(env);
191     if (!playerCls) {
192         LOG_ERROR0(&quot;&lt;&lt;registerMediaEngine ERROR: MediaPlayer class is unavailable\n&quot;);
193         return;
194     }
<span class="line-modified">195 </span>
<span class="line-modified">196     registrar(makeUnique&lt;MediaPlayerFactoryJava&gt;());</span>


197 }
198 
199 void MediaPlayerPrivate::MediaEngineSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; types)
200 {
201     LOG_TRACE0(&quot;&gt;&gt;MediaEngineSupportedTypes\n&quot;);
202     HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; supportedTypes = GetSupportedTypes();
203     for (const auto&amp; type : supportedTypes) {
204         types.add(type);
205     }
206     LOG_TRACE0(&quot;&lt;&lt;MediaEngineSupportedTypes\n&quot;);
207 }
208 
209 MediaPlayer::SupportsType MediaPlayerPrivate::MediaEngineSupportsType(const MediaEngineSupportParameters&amp; parameters)
210 {
211     for (const auto&amp; codecValue: parameters.type.codecs()) {
212         UNUSED_PARAM(codecValue);
213         LOG_TRACE2(&quot;&gt;&gt;MediaEngineSupportsType, type=%s, codecs=%s\n&quot;, parameters.type.raw().utf8().data(), codecValue.utf8().data());
214     }
215 
216     if (parameters.type.isEmpty()) {
217         LOG_TRACE0(&quot;&lt;&lt;MediaEngineSupportsType: NOT supported (type is empty)\n&quot;);
<span class="line-modified">218         return MediaPlayer::SupportsType::IsNotSupported;</span>
219     }
220 
221     if (GetSupportedTypes().contains(parameters.type.containerType())) {
222         LOG_TRACE0(&quot;&lt;&lt;MediaEngineSupportsType: MayBeSupported/IsSupported\n&quot;);
223         auto codecs = parameters.type.parameter(ContentType::codecsParameter());
<span class="line-modified">224         return codecs.isEmpty() ? MediaPlayer::SupportsType::MayBeSupported : MediaPlayer::SupportsType::IsSupported;</span>
225     }
226     LOG_TRACE0(&quot;&lt;&lt;MediaEngineSupportsType: NOT supported\n&quot;);
<span class="line-modified">227     return MediaPlayer::SupportsType::IsNotSupported;</span>
228 }
229 
230 HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; MediaPlayerPrivate::GetSupportedTypes()
231 {
232     static HashSet&lt;String, ASCIICaseInsensitiveHash&gt; supportedTypes;
233     // TODO: refresh after change
234 
235     if (!supportedTypes.isEmpty()) {
236         return supportedTypes;
237     }
238 
239     JNIEnv* env = WTF::GetJavaEnv();
240     static jmethodID s_mID = env-&gt;GetMethodID(PG_GetGraphicsManagerClass(env),
241         &quot;getSupportedMediaTypes&quot;, &quot;()[Ljava/lang/String;&quot;);
242     ASSERT(s_mID);
243 
244     JLocalRef&lt;jobjectArray&gt; jArray(
245         (jobjectArray)env-&gt;CallObjectMethod(PL_GetGraphicsManager(env), s_mID));
246     ASSERT(jArray);
247     WTF::CheckAndClearException(env);
248 
249     jsize len = env-&gt;GetArrayLength(jArray);
250     for (jsize  i=0; i&lt;len; i++) {
251         JLString jStr((jstring)env-&gt;GetObjectArrayElement(jArray, i));
252         String s(env, jStr);
253         supportedTypes.add(s);
254     }
255 
256     return supportedTypes;
257 }
258 
259 
260 // *********************************************************
261 // MediaPlayerPrivate
262 // *********************************************************
263 MediaPlayerPrivate::MediaPlayerPrivate(MediaPlayer *player)
264     : m_player(player)
<span class="line-modified">265     , m_networkState(MediaPlayer::NetworkState::Empty)</span>
<span class="line-modified">266     , m_readyState(MediaPlayer::ReadyState::HaveNothing)</span>
267     , m_isVisible(false)
268     , m_hasVideo(false)
269     , m_hasAudio(false)
270     , m_paused(true)
271     , m_seeking(false)
272     , m_seekTime(0)
273     , m_duration(0)
274     , m_bytesLoaded(0)
275     , m_didLoadingProgress(false)
276 {
277     JNIEnv* env = WTF::GetJavaEnv();
278     static jmethodID mid = env-&gt;GetMethodID(PG_GetGraphicsManagerClass(env),
279         &quot;fwkCreateMediaPlayer&quot;, &quot;(J)Lcom/sun/webkit/graphics/WCMediaPlayer;&quot;);
280     ASSERT(mid);
281 
282     JLocalRef&lt;jobject&gt; obj(env-&gt;CallObjectMethod(PL_GetGraphicsManager(env),
283         mid, ptr_to_jlong(this)));
284     ASSERT(obj);
285     WTF::CheckAndClearException(env);
286 
287     m_buffered = std::make_unique&lt;PlatformTimeRanges&gt;();
288     m_jPlayer = RQRef::create(obj);
289 }
290 
291 MediaPlayerPrivate::~MediaPlayerPrivate()
292 {
293     WC_GETJAVAENV_CHKRET(env);
294     static jmethodID s_mID
295         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkDispose&quot;, &quot;()V&quot;);
296     ASSERT(s_mID);
297 
298     env-&gt;CallVoidMethod(*m_jPlayer, s_mID);
299     WTF::CheckAndClearException(env);
300 }
301 
302 void MediaPlayerPrivate::load(const String&amp; url)
303 {
<span class="line-modified">304     if (m_networkState == MediaPlayer::NetworkState::Loading) {</span>
305         cancelLoad();
306     }
307 
308     String userAgent;
309     // MediaPlayerClient mpClient = m_player-&gt;client();
310     // Document* doc = mpClient.mediaPlayerOwningDocument(); //XXX: mediaPlayerOwningDocument removed
311     // if (doc != NULL &amp;&amp; doc-&gt;settings() != NULL) {
312     //     userAgent = doc-&gt;settings()-&gt;userAgent();
313     // }
314 
315     JNIEnv* env = WTF::GetJavaEnv();
316     static jmethodID s_mID
317         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkLoad&quot;, &quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;);
318     ASSERT(s_mID);
319 
320     env-&gt;CallVoidMethod(*m_jPlayer, s_mID,
321         (jstring)url.toJavaString(env),
322         userAgent.isEmpty() ? NULL : (jstring)userAgent.toJavaString(env));
323     WTF::CheckAndClearException(env);
324 }
</pre>
<hr />
<pre>
584     if (!m_isVisible) {
585         PLOG_TRACE0(&quot;&lt;&lt;MediaPlayerPrivate paint (!visible)\n&quot;);
586         return;
587     }
588 
589     gc.platformContext()-&gt;rq().freeSpace(24)
590     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_RENDERMEDIAPLAYER
591     &lt;&lt; m_jPlayer &lt;&lt; (jint)r.x() &lt;&lt;  (jint)r.y()
592     &lt;&lt; (jint)r.width() &lt;&lt; (jint)r.height();
593 
594 //    PLOG_TRACE0(&quot;&lt;&lt;MediaPlayerPrivate paint (OK)\n&quot;);
595 }
596 
597 //void MediaPlayerPrivate::paintCurrentFrameInContext(GraphicsContext* c, const IntRect&amp; r) { paint(c, r); }
598 
599 void MediaPlayerPrivate::setPreload(MediaPlayer::Preload preload)
600 {
601     // enum Preload { None, MetaData, Auto };
602     PLOG_TRACE1(&quot;MediaPlayerPrivate setPreload, preload=%u\n&quot;, (int)preload);
603     jint jPreload =
<span class="line-modified">604         (preload == MediaPlayer::Preload::None) ? com_sun_webkit_graphics_WCMediaPlayer_PRELOAD_NONE</span>
<span class="line-modified">605         : (preload == MediaPlayer::Preload::MetaData) ? com_sun_webkit_graphics_WCMediaPlayer_PRELOAD_METADATA</span>
<span class="line-modified">606         : (preload == MediaPlayer::Preload::Auto) ? com_sun_webkit_graphics_WCMediaPlayer_PRELOAD_AUTO</span>
607         : -1;
608     if (jPreload &lt; 0) {
609         // unexpected preload value
610         return;
611     }
612     JNIEnv* env = WTF::GetJavaEnv();
613     static jmethodID s_mID
614         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkSetPreload&quot;, &quot;(I)V&quot;);
615     ASSERT(s_mID);
616 
617     env-&gt;CallVoidMethod(*m_jPlayer, s_mID, jPreload);
618     WTF::CheckAndClearException(env);
619 }
620 
<span class="line-modified">621 //bool MediaPlayerPrivate::hasAvailableVideoFrame() const { return readyState() &gt;= MediaPlayer::ReadyState::HaveCurrentData; }</span>
622 
623 //bool MediaPlayerPrivate::canLoadPoster() const { return false; }
624 //void MediaPlayerPrivate::setPoster(const String&amp;) { }
625 
626 //#if ENABLE(PLUGIN_PROXY_FOR_VIDEO)
627 //        virtual void deliverNotification(MediaPlayerProxyNotificationType) = 0;
628 //        virtual void setMediaPlayerProxy(WebMediaPlayerProxy*) = 0;
629 //#endif
630 
631 //#if USE(ACCELERATED_COMPOSITING)
632 //        // whether accelerated rendering is supported by the media engine for the current media.
633 //        virtual bool supportsAcceleratedRendering() const { return false; }
634 //        // called when the rendering system flips the into or out of accelerated rendering mode.
635 //        virtual void acceleratedRenderingStateChanged() { }
636 //#endif
637 
638 //bool MediaPlayerPrivate::hasSingleSecurityOrigin() const { return false; }
639 
<span class="line-modified">640 //MediaPlayer::MovieLoadType MediaPlayerPrivate::movieLoadType() const { return MediaPlayer::MovieLoadType::Unknown; }</span>
641 
642 void MediaPlayerPrivate::setNetworkState(MediaPlayer::NetworkState networkState)
643 {
644     if (m_networkState != networkState) {
645         PLOG_TRACE4(&quot;MediaPlayerPrivate NetworkState: %s (%d) =&gt; %s (%d)\n&quot;,
646             networkStateStr(m_networkState), (int)m_networkState, networkStateStr(networkState), (int)networkState);
647         m_networkState = networkState;
648         m_player-&gt;networkStateChanged();
649     }
650 }
651 
652 void MediaPlayerPrivate::setReadyState(MediaPlayer::ReadyState readyState)
653 {
654     if (m_readyState != readyState) {
655         PLOG_TRACE4(&quot;MediaPlayerPrivate ReadyState: %s (%d) =&gt; %s (%d)\n&quot;,
656             readyStateStr(m_readyState), (int)m_readyState, readyStateStr(readyState), (int)readyState);
657         m_readyState = readyState;
658         m_player-&gt;readyStateChanged();
659     }
660 }
661 
662 
663 MediaPlayerPrivate* MediaPlayerPrivate::getPlayer(jlong ptr)
664 {
665     return reinterpret_cast&lt;MediaPlayerPrivate *&gt;(jlong_to_ptr(ptr));
666 }
667 
668 void MediaPlayerPrivate::notifyNetworkStateChanged(int networkState)
669 {
670     switch (networkState) {
671     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_EMPTY:
<span class="line-modified">672         setNetworkState(MediaPlayer::NetworkState::Empty);</span>
673         break;
674     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_IDLE:
<span class="line-modified">675         setNetworkState(MediaPlayer::NetworkState::Idle);</span>
676         break;
677     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_LOADING:
<span class="line-modified">678         setNetworkState(MediaPlayer::NetworkState::Loading);</span>
679         break;
680     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_LOADED:
<span class="line-modified">681         setNetworkState(MediaPlayer::NetworkState::Loaded);</span>
682         break;
683     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_FORMAT_ERROR:
<span class="line-modified">684         setNetworkState(MediaPlayer::NetworkState::FormatError);</span>
685         break;
686     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_NETWORK_ERROR:
<span class="line-modified">687         setNetworkState(MediaPlayer::NetworkState::NetworkError);</span>
688         break;
689     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_DECODE_ERROR:
<span class="line-modified">690         setNetworkState(MediaPlayer::NetworkState::DecodeError);</span>
691         break;
692     }
693 }
694 
695 void MediaPlayerPrivate::notifyReadyStateChanged(int readyState)
696 {
697     switch (readyState) {
698     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_NOTHING:
<span class="line-modified">699         setReadyState(MediaPlayer::ReadyState::HaveNothing);</span>
700         break;
701     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_METADATA:
<span class="line-modified">702         setReadyState(MediaPlayer::ReadyState::HaveMetadata);</span>
703         break;
704     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_CURRENT_DATA:
<span class="line-modified">705         setReadyState(MediaPlayer::ReadyState::HaveCurrentData);</span>
706         break;
707     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_FUTURE_DATA:
<span class="line-modified">708         setReadyState(MediaPlayer::ReadyState::HaveFutureData);</span>
709         break;
710     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_ENOUGH_DATA:
<span class="line-modified">711         setReadyState(MediaPlayer::ReadyState::HaveEnoughData);</span>
712         break;
713     }
714 }
715 
716 void MediaPlayerPrivate::notifyPaused(bool paused)
717 {
718     PLOG_TRACE2(&quot;&gt;&gt;MediaPlayerPrivate notifyPaused: %d =&gt; %d\n&quot;, m_paused ? 1 : 0, paused ? 1 : 0);
719 
720     if (m_paused != paused) {
721         m_paused = paused;
722         m_player-&gt;playbackStateChanged();
723     }
724 }
725 
726 void MediaPlayerPrivate::notifySeeking(bool seeking)
727 {
728     PLOG_TRACE2(&quot;&gt;&gt;MediaPlayerPrivate notifySeeking: %d =&gt; %d\n&quot;, m_seeking ? 1 : 0, seeking ? 1 : 0);
729     if (m_seeking != seeking) {
730         m_seeking = seeking;
731         if (!seeking) {
</pre>
</td>
</tr>
</table>
<center><a href="ImageBufferJava.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="MediaPlayerPrivateJava.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
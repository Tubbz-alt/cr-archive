diff a/modules/javafx.web/src/main/native/Source/WebCore/page/SuspendableTimer.cpp b/modules/javafx.web/src/main/native/Source/WebCore/page/SuspendableTimer.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/page/SuspendableTimer.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/page/SuspendableTimer.cpp
@@ -29,23 +29,23 @@
 
 #include "ScriptExecutionContext.h"
 
 namespace WebCore {
 
-SuspendableTimer::SuspendableTimer(ScriptExecutionContext& context)
-    : ActiveDOMObject(&context)
+SuspendableTimerBase::SuspendableTimerBase(ScriptExecutionContext* context)
+    : ActiveDOMObject(context)
 {
 }
 
-SuspendableTimer::~SuspendableTimer() = default;
+SuspendableTimerBase::~SuspendableTimerBase() = default;
 
-bool SuspendableTimer::hasPendingActivity() const
+bool SuspendableTimerBase::hasPendingActivity() const
 {
     return isActive();
 }
 
-void SuspendableTimer::stop()
+void SuspendableTimerBase::stop()
 {
     if (!m_suspended)
         TimerBase::stop();
 
     // Make it less likely that SuspendableTimer is accidentally revived and fires after being stopped.
@@ -54,11 +54,11 @@
     m_savedIsActive = false;
 
     didStop();
 }
 
-void SuspendableTimer::suspend(ReasonForSuspension)
+void SuspendableTimerBase::suspend(ReasonForSuspension)
 {
     ASSERT(!m_suspended);
     m_suspended = true;
 
     m_savedIsActive = TimerBase::isActive();
@@ -67,68 +67,63 @@
         m_savedRepeatInterval = TimerBase::repeatInterval();
         TimerBase::stop();
     }
 }
 
-void SuspendableTimer::resume()
+void SuspendableTimerBase::resume()
 {
     ASSERT(m_suspended);
     m_suspended = false;
 
     if (m_savedIsActive)
         start(m_savedNextFireInterval, m_savedRepeatInterval);
 }
 
-bool SuspendableTimer::canSuspendForDocumentSuspension() const
+void SuspendableTimerBase::didStop()
 {
-    return true;
 }
 
-void SuspendableTimer::didStop()
-{
-}
-
-void SuspendableTimer::cancel()
+void SuspendableTimerBase::cancel()
 {
     if (!m_suspended)
         TimerBase::stop();
     else
         m_suspended = false;
 }
 
-void SuspendableTimer::startRepeating(Seconds repeatInterval)
+void SuspendableTimerBase::startRepeating(Seconds repeatInterval)
 {
     if (!m_suspended)
         TimerBase::startRepeating(repeatInterval);
     else {
         m_savedIsActive = true;
         m_savedNextFireInterval = repeatInterval;
         m_savedRepeatInterval = repeatInterval;
     }
 }
 
-void SuspendableTimer::startOneShot(Seconds interval)
+void SuspendableTimerBase::startOneShot(Seconds interval)
 {
     if (!m_suspended)
         TimerBase::startOneShot(interval);
     else {
         m_savedIsActive = true;
         m_savedNextFireInterval = interval;
         m_savedRepeatInterval = 0_s;
     }
 }
 
-Seconds SuspendableTimer::repeatInterval() const
+Seconds SuspendableTimerBase::repeatInterval() const
 {
     if (!m_suspended)
         return TimerBase::repeatInterval();
     if (m_savedIsActive)
         return m_savedRepeatInterval;
     return 0_s;
 }
 
-void SuspendableTimer::augmentFireInterval(Seconds delta)
+void SuspendableTimerBase::augmentFireInterval(Seconds delta)
 {
     if (!m_suspended)
         TimerBase::augmentFireInterval(delta);
     else if (m_savedIsActive) {
         m_savedNextFireInterval += delta;
@@ -137,11 +132,11 @@
         m_savedNextFireInterval = delta;
         m_savedRepeatInterval = 0_s;
     }
 }
 
-void SuspendableTimer::augmentRepeatInterval(Seconds delta)
+void SuspendableTimerBase::augmentRepeatInterval(Seconds delta)
 {
     if (!m_suspended)
         TimerBase::augmentRepeatInterval(delta);
     else if (m_savedIsActive) {
         m_savedNextFireInterval += delta;
@@ -151,6 +146,11 @@
         m_savedNextFireInterval = delta;
         m_savedRepeatInterval = delta;
     }
 }
 
+const char* SuspendableTimer::activeDOMObjectName() const
+{
+    return "SuspendableTimer";
+}
+
 } // namespace WebCore

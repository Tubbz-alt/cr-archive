<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsContext.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2003-2017 Apple Inc. All rights reserved.
  3  * Copyright (C) 2008-2009 Torch Mobile, Inc.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;DashArray.h&quot;
 30 #include &quot;FloatRect.h&quot;
 31 #include &quot;FontCascade.h&quot;
 32 #include &quot;Gradient.h&quot;
 33 #include &quot;GraphicsTypes.h&quot;
 34 #include &quot;Image.h&quot;
 35 #include &quot;ImageOrientation.h&quot;
 36 #include &quot;ImagePaintingOptions.h&quot;
 37 #include &quot;Pattern.h&quot;
 38 #include &quot;RenderingMode.h&quot;
 39 #include &lt;wtf/Function.h&gt;
 40 #include &lt;wtf/Noncopyable.h&gt;
 41 #include &lt;wtf/OptionSet.h&gt;
 42 
 43 #if USE(CG)
 44 typedef struct CGContext PlatformGraphicsContext;
 45 #elif USE(DIRECT2D)
 46 interface ID2D1DCRenderTarget;
 47 interface ID2D1RenderTarget;
 48 interface ID2D1Factory;
 49 interface ID2D1SolidColorBrush;
 50 namespace WebCore {
 51 class PlatformContextDirect2D;
 52 }
 53 typedef WebCore::PlatformContextDirect2D PlatformGraphicsContext;
 54 #elif USE(CAIRO)
 55 namespace WebCore {
 56 class PlatformContextCairo;
 57 }
 58 typedef WebCore::PlatformContextCairo PlatformGraphicsContext;
 59 #elif USE(WINGDI)
 60 typedef struct HDC__ PlatformGraphicsContext;
 61 #elif PLATFORM(JAVA)
 62 namespace WebCore {
 63 class PlatformContextJava;
 64 }
 65 typedef WebCore::PlatformContextJava PlatformGraphicsContext;
 66 #else
 67 typedef void PlatformGraphicsContext;
 68 #endif
 69 
 70 #if PLATFORM(WIN)
 71 #include &quot;DIBPixelData.h&quot;
 72 typedef struct HDC__* HDC;
 73 #if !USE(CG)
 74 // UInt8 is defined in CoreFoundation/CFBase.h
 75 typedef unsigned char UInt8;
 76 #endif
 77 #endif
 78 
 79 // X11 header defines &quot;None&quot; as constant in macro and breakes the PaintInvalidationReasons enum&#39;s &quot;None&quot;.
 80 // As a workaround, we explicitly undef X11&#39;s None here.
 81 #if defined(None)
 82 #undef None
 83 #endif
 84 
 85 namespace WebCore {
 86 
 87 #if USE(WINGDI)
 88 class SharedBitmap;
 89 class Font;
 90 class GlyphBuffer;
 91 #endif
 92 
 93 class AffineTransform;
 94 class FloatRoundedRect;
 95 class Gradient;
 96 class GraphicsContextImpl;
 97 class GraphicsContextPlatformPrivate;
 98 class ImageBuffer;
 99 class IntRect;
100 class RoundedRect;
101 class GraphicsContextGLOpenGL;
102 class Path;
103 class TextRun;
104 class TransformationMatrix;
105 
106 enum TextDrawingMode {
107     TextModeFill = 1 &lt;&lt; 0,
108     TextModeStroke = 1 &lt;&lt; 1,
109 #if ENABLE(LETTERPRESS)
110     TextModeLetterpress = 1 &lt;&lt; 2,
111 #endif
112 };
113 typedef unsigned TextDrawingModeFlags;
114 
115 enum StrokeStyle {
116     NoStroke,
117     SolidStroke,
118     DottedStroke,
119     DashedStroke,
120     DoubleStroke,
121     WavyStroke,
122 };
123 
124 struct DocumentMarkerLineStyle {
125     enum class Mode : uint8_t {
126         TextCheckingDictationPhraseWithAlternatives,
127         Spelling,
128         Grammar,
129         AutocorrectionReplacement,
130         DictationAlternatives
131     } mode;
132     bool shouldUseDarkAppearance { false };
133 
134     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
135     template&lt;class Decoder&gt; static Optional&lt;DocumentMarkerLineStyle&gt; decode(Decoder&amp;);
136 };
137 
138 template&lt;class Encoder&gt;
139 void DocumentMarkerLineStyle::encode(Encoder&amp; encoder) const
140 {
141     encoder &lt;&lt; mode;
142     encoder &lt;&lt; shouldUseDarkAppearance;
143 }
144 
145 template&lt;class Decoder&gt;
146 Optional&lt;DocumentMarkerLineStyle&gt; DocumentMarkerLineStyle::decode(Decoder&amp; decoder)
147 {
148     Optional&lt;Mode&gt; mode;
149     decoder &gt;&gt; mode;
150     if (!mode)
151         return WTF::nullopt;
152 
153     Optional&lt;bool&gt; shouldUseDarkAppearance;
154     decoder &gt;&gt; shouldUseDarkAppearance;
155     if (!shouldUseDarkAppearance)
156         return WTF::nullopt;
157 
158     return {{ *mode, *shouldUseDarkAppearance }};
159 }
160 
161 namespace DisplayList {
162 class Recorder;
163 }
164 
165 struct GraphicsContextState {
166     GraphicsContextState()
167         : shouldAntialias(true)
168         , shouldSmoothFonts(true)
169         , shouldSubpixelQuantizeFonts(true)
170         , shadowsIgnoreTransforms(false)
171 #if USE(CG)
172         // Core Graphics incorrectly renders shadows with radius &gt; 8px (&lt;rdar://problem/8103442&gt;),
173         // but we need to preserve this buggy behavior for canvas and -webkit-box-shadow.
174         , shadowsUseLegacyRadius(false)
175 #endif
176 #if PLATFORM(JAVA)
177         , clipBounds(FloatRect::infiniteRect())
178 #endif
179         , drawLuminanceMask(false)
180     {
181     }
182 
183     enum Change : uint32_t {
184         StrokeGradientChange                    = 1 &lt;&lt; 1,
185         StrokePatternChange                     = 1 &lt;&lt; 2,
186         FillGradientChange                      = 1 &lt;&lt; 3,
187         FillPatternChange                       = 1 &lt;&lt; 4,
188         StrokeThicknessChange                   = 1 &lt;&lt; 5,
189         StrokeColorChange                       = 1 &lt;&lt; 6,
190         StrokeStyleChange                       = 1 &lt;&lt; 7,
191         FillColorChange                         = 1 &lt;&lt; 8,
192         FillRuleChange                          = 1 &lt;&lt; 9,
193         ShadowChange                            = 1 &lt;&lt; 10,
194         ShadowsIgnoreTransformsChange           = 1 &lt;&lt; 11,
195         AlphaChange                             = 1 &lt;&lt; 12,
196         CompositeOperationChange                = 1 &lt;&lt; 13,
197         BlendModeChange                         = 1 &lt;&lt; 14,
198         TextDrawingModeChange                   = 1 &lt;&lt; 15,
199         ShouldAntialiasChange                   = 1 &lt;&lt; 16,
200         ShouldSmoothFontsChange                 = 1 &lt;&lt; 17,
201         ShouldSubpixelQuantizeFontsChange       = 1 &lt;&lt; 18,
202         DrawLuminanceMaskChange                 = 1 &lt;&lt; 19,
203         ImageInterpolationQualityChange         = 1 &lt;&lt; 20,
204 #if HAVE(OS_DARK_MODE_SUPPORT)
205         UseDarkAppearanceChange                 = 1 &lt;&lt; 21,
206 #endif
207     };
208     typedef OptionSet&lt;Change&gt; StateChangeFlags;
209 
210     RefPtr&lt;Gradient&gt; strokeGradient;
211     RefPtr&lt;Pattern&gt; strokePattern;
212 
213     RefPtr&lt;Gradient&gt; fillGradient;
214     RefPtr&lt;Pattern&gt; fillPattern;
215 
216     FloatSize shadowOffset;
217 
218     float strokeThickness { 0 };
219     float shadowBlur { 0 };
220 
221     TextDrawingModeFlags textDrawingMode { TextModeFill };
222 
223     Color strokeColor { Color::black };
224     Color fillColor { Color::black };
225     Color shadowColor;
226 
227     StrokeStyle strokeStyle { SolidStroke };
228     WindRule fillRule { WindRule::NonZero };
229 
230     float alpha { 1 };
231     CompositeOperator compositeOperator { CompositeOperator::SourceOver };
232     BlendMode blendMode { BlendMode::Normal };
233     InterpolationQuality imageInterpolationQuality { InterpolationQuality::Default };
234 
235     bool shouldAntialias : 1;
236     bool shouldSmoothFonts : 1;
237     bool shouldSubpixelQuantizeFonts : 1;
238     bool shadowsIgnoreTransforms : 1;
239 #if USE(CG)
240     bool shadowsUseLegacyRadius : 1;
241 #endif
242 #if PLATFORM(JAVA)
243     AffineTransform transform;
244     FloatRect clipBounds;
245 #endif
246     bool drawLuminanceMask : 1;
247 #if HAVE(OS_DARK_MODE_SUPPORT)
248     bool useDarkAppearance : 1;
249 #endif
250 };
251 
252 struct GraphicsContextStateChange {
253     GraphicsContextStateChange() = default;
254     GraphicsContextStateChange(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
255         : m_state(state)
256         , m_changeFlags(flags)
257     {
258     }
259 
260     GraphicsContextState::StateChangeFlags changesFromState(const GraphicsContextState&amp;) const;
261 
262     void accumulate(const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);
263     void apply(GraphicsContext&amp;) const;
264 
265     void dump(WTF::TextStream&amp;) const;
266 
267     GraphicsContextState m_state;
268     GraphicsContextState::StateChangeFlags m_changeFlags;
269 };
270 
271 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const GraphicsContextStateChange&amp;);
272 
273 
274 class GraphicsContext {
275     WTF_MAKE_NONCOPYABLE(GraphicsContext); WTF_MAKE_FAST_ALLOCATED;
276 public:
277     WEBCORE_EXPORT GraphicsContext(PlatformGraphicsContext*);
278 
279     using GraphicsContextImplFactory = WTF::Function&lt;std::unique_ptr&lt;GraphicsContextImpl&gt;(GraphicsContext&amp;)&gt;;
280     WEBCORE_EXPORT GraphicsContext(const GraphicsContextImplFactory&amp;);
281 
282     GraphicsContext() = default;
283     WEBCORE_EXPORT ~GraphicsContext();
284 
285     enum class PaintInvalidationReasons : uint8_t {
286         None,
287         InvalidatingControlTints,
288         InvalidatingImagesWithAsyncDecodes
289     };
290     GraphicsContext(PaintInvalidationReasons);
291 
292 #if USE(DIRECT2D)
293     enum class BitmapRenderingContextType : uint8_t {
294         CPUMemory,
295         GPUMemory
296     };
297     WEBCORE_EXPORT GraphicsContext(PlatformGraphicsContext*, BitmapRenderingContextType);
298 #endif
299 
300     WEBCORE_EXPORT bool hasPlatformContext() const;
301     WEBCORE_EXPORT PlatformGraphicsContext* platformContext() const;
302 
303     bool paintingDisabled() const { return !m_data &amp;&amp; !m_impl; }
304     bool performingPaintInvalidation() const { return m_paintInvalidationReasons != PaintInvalidationReasons::None; }
305     bool invalidatingControlTints() const { return m_paintInvalidationReasons == PaintInvalidationReasons::InvalidatingControlTints; }
306     bool invalidatingImagesWithAsyncDecodes() const { return m_paintInvalidationReasons == PaintInvalidationReasons::InvalidatingImagesWithAsyncDecodes; }
307 
308     WEBCORE_EXPORT void setStrokeThickness(float);
309     float strokeThickness() const { return m_state.strokeThickness; }
310 
311     void setStrokeStyle(StrokeStyle);
312     StrokeStyle strokeStyle() const { return m_state.strokeStyle; }
313 
314     WEBCORE_EXPORT void setStrokeColor(const Color&amp;);
315     const Color&amp; strokeColor() const { return m_state.strokeColor; }
316 
317     void setStrokePattern(Ref&lt;Pattern&gt;&amp;&amp;);
318     Pattern* strokePattern() const { return m_state.strokePattern.get(); }
319 
320     void setStrokeGradient(Ref&lt;Gradient&gt;&amp;&amp;);
321     RefPtr&lt;Gradient&gt; strokeGradient() const { return m_state.strokeGradient; }
322 
323     void setFillRule(WindRule);
324     WindRule fillRule() const { return m_state.fillRule; }
325 
326     WEBCORE_EXPORT void setFillColor(const Color&amp;);
327     const Color&amp; fillColor() const { return m_state.fillColor; }
328 
329     void setFillPattern(Ref&lt;Pattern&gt;&amp;&amp;);
330     Pattern* fillPattern() const { return m_state.fillPattern.get(); }
331 
332     WEBCORE_EXPORT void setFillGradient(Ref&lt;Gradient&gt;&amp;&amp;);
333     RefPtr&lt;Gradient&gt; fillGradient() const { return m_state.fillGradient; }
334 
335     void setShadowsIgnoreTransforms(bool);
336     bool shadowsIgnoreTransforms() const { return m_state.shadowsIgnoreTransforms; }
337 
338     WEBCORE_EXPORT void setShouldAntialias(bool);
339     bool shouldAntialias() const { return m_state.shouldAntialias; }
340 
341     WEBCORE_EXPORT void setShouldSmoothFonts(bool);
342     bool shouldSmoothFonts() const { return m_state.shouldSmoothFonts; }
343 
344     // Normally CG enables subpixel-quantization because it improves the performance of aligning glyphs.
345     // In some cases we have to disable to to ensure a high-quality output of the glyphs.
346     void setShouldSubpixelQuantizeFonts(bool);
347     bool shouldSubpixelQuantizeFonts() const { return m_state.shouldSubpixelQuantizeFonts; }
348 
349     const GraphicsContextState&amp; state() const { return m_state; }
350 
351 #if USE(CG) || USE(DIRECT2D) || USE(CAIRO)
352     WEBCORE_EXPORT void drawNativeImage(const NativeImagePtr&amp;, const FloatSize&amp; selfSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; = { });
353 #endif
354 
355 #if USE(CG) || USE(DIRECT2D)
356     void applyStrokePattern();
357     void applyFillPattern();
358     void drawPath(const Path&amp;);
359 
360     WEBCORE_EXPORT void setIsCALayerContext(bool);
361     bool isCALayerContext() const;
362 
363     WEBCORE_EXPORT void setIsAcceleratedContext(bool);
364 #endif
365     bool isAcceleratedContext() const;
366     RenderingMode renderingMode() const { return isAcceleratedContext() ? RenderingMode::Accelerated : RenderingMode::Unaccelerated; }
367 
368     WEBCORE_EXPORT void save();
369     WEBCORE_EXPORT void restore();
370 
371     unsigned stackSize() const { return m_stack.size(); }
372 
373     // These draw methods will do both stroking and filling.
374     // FIXME: ...except drawRect(), which fills properly but always strokes
375     // using a 1-pixel stroke inset from the rect borders (of the correct
376     // stroke color).
377     void drawRect(const FloatRect&amp;, float borderThickness = 1);
378     void drawLine(const FloatPoint&amp;, const FloatPoint&amp;);
379 
380     void drawEllipse(const FloatRect&amp;);
381     void drawRaisedEllipse(const FloatRect&amp;, const Color&amp; ellipseColor, const Color&amp; shadowColor);
382 
383     WEBCORE_EXPORT void fillPath(const Path&amp;);
384     WEBCORE_EXPORT void strokePath(const Path&amp;);
385 
386     void fillEllipse(const FloatRect&amp;);
387     void strokeEllipse(const FloatRect&amp;);
388 
389     WEBCORE_EXPORT void fillRect(const FloatRect&amp;);
390     WEBCORE_EXPORT void fillRect(const FloatRect&amp;, const Color&amp;);
391     void fillRect(const FloatRect&amp;, Gradient&amp;);
392     void fillRect(const FloatRect&amp;, const Color&amp;, CompositeOperator, BlendMode = BlendMode::Normal);
393     void fillRoundedRect(const FloatRoundedRect&amp;, const Color&amp;, BlendMode = BlendMode::Normal);
394     void fillRectWithRoundedHole(const FloatRect&amp;, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp;);
395 
396     WEBCORE_EXPORT void clearRect(const FloatRect&amp;);
397 
398     WEBCORE_EXPORT void strokeRect(const FloatRect&amp;, float lineWidth);
399 
400     WEBCORE_EXPORT ImageDrawResult drawImage(Image&amp;, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; = { ImageOrientation::FromImage });
401     WEBCORE_EXPORT ImageDrawResult drawImage(Image&amp;, const FloatRect&amp; destination, const ImagePaintingOptions&amp; = { ImageOrientation::FromImage });
402     ImageDrawResult drawImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; = { ImageOrientation::FromImage });
403 
404     ImageDrawResult drawTiledImage(Image&amp;, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; = { });
405     ImageDrawResult drawTiledImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule, Image::TileRule, const ImagePaintingOptions&amp; = { });
406 
407     WEBCORE_EXPORT void drawImageBuffer(ImageBuffer&amp;, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; = { });
408     void drawImageBuffer(ImageBuffer&amp;, const FloatRect&amp; destination, const ImagePaintingOptions&amp; = { });
409     void drawImageBuffer(ImageBuffer&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; = { });
410 
411     void drawPattern(Image&amp;, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const AffineTransform&amp;, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; = { });
412 
413     WEBCORE_EXPORT void drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; = { });
414     void drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;, const FloatRect&amp; destination, const ImagePaintingOptions&amp; = { });
415     void drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; = { });
416 
417     WEBCORE_EXPORT void setImageInterpolationQuality(InterpolationQuality);
418     InterpolationQuality imageInterpolationQuality() const { return m_state.imageInterpolationQuality; }
419 
420     WEBCORE_EXPORT void clip(const FloatRect&amp;);
421     void clipRoundedRect(const FloatRoundedRect&amp;);
422 
423     void clipOut(const FloatRect&amp;);
424     void clipOutRoundedRect(const FloatRoundedRect&amp;);
425     void clipPath(const Path&amp;, WindRule = WindRule::EvenOdd);
426     void clipToImageBuffer(ImageBuffer&amp;, const FloatRect&amp;);
427 
428     IntRect clipBounds() const;
429 
430     void setTextDrawingMode(TextDrawingModeFlags);
431     TextDrawingModeFlags textDrawingMode() const { return m_state.textDrawingMode; }
432 
433 #if HAVE(OS_DARK_MODE_SUPPORT)
434     void setUseDarkAppearance(bool);
435     bool useDarkAppearance() const { return m_state.useDarkAppearance; }
436 #endif
437 
438     float drawText(const FontCascade&amp;, const TextRun&amp;, const FloatPoint&amp;, unsigned from = 0, Optional&lt;unsigned&gt; to = WTF::nullopt);
439     void drawGlyphs(const Font&amp;, const GlyphBuffer&amp;, unsigned from, unsigned numGlyphs, const FloatPoint&amp;, FontSmoothingMode);
440     void drawEmphasisMarks(const FontCascade&amp;, const TextRun&amp;, const AtomString&amp; mark, const FloatPoint&amp;, unsigned from = 0, Optional&lt;unsigned&gt; to = WTF::nullopt);
441     void drawBidiText(const FontCascade&amp;, const TextRun&amp;, const FloatPoint&amp;, FontCascade::CustomFontNotReadyAction = FontCascade::DoNotPaintIfFontNotReady);
442 
443     void builderState(const GraphicsContextState&amp;);
444 
445     enum RoundingMode {
446         RoundAllSides,
447         RoundOriginAndDimensions
448     };
449     FloatRect roundToDevicePixels(const FloatRect&amp;, RoundingMode = RoundAllSides);
450 
451     FloatRect computeUnderlineBoundsForText(const FloatRect&amp;, bool printing);
452     WEBCORE_EXPORT void drawLineForText(const FloatRect&amp;, bool printing, bool doubleLines = false, StrokeStyle = SolidStroke);
453     void drawLinesForText(const FloatPoint&amp;, float thickness, const DashArray&amp; widths, bool printing, bool doubleLines = false, StrokeStyle = SolidStroke);
454     void drawDotsForDocumentMarker(const FloatRect&amp;, DocumentMarkerLineStyle);
455 
456     WEBCORE_EXPORT void beginTransparencyLayer(float opacity);
457     WEBCORE_EXPORT void endTransparencyLayer();
458     bool isInTransparencyLayer() const { return (m_transparencyCount &gt; 0) &amp;&amp; supportsTransparencyLayers(); }
459 
460     WEBCORE_EXPORT void setShadow(const FloatSize&amp;, float blur, const Color&amp;);
461     // Legacy shadow blur radius is used for canvas, and -webkit-box-shadow.
462     // It has different treatment of radii &gt; 8px.
463     void setLegacyShadow(const FloatSize&amp;, float blur, const Color&amp;);
464 
465     WEBCORE_EXPORT void clearShadow();
466     bool getShadow(FloatSize&amp;, float&amp;, Color&amp;) const;
467 
468     bool hasVisibleShadow() const { return m_state.shadowColor.isVisible(); }
469     bool hasShadow() const { return hasVisibleShadow() &amp;&amp; (m_state.shadowBlur || m_state.shadowOffset.width() || m_state.shadowOffset.height()); }
470     bool hasBlurredShadow() const { return hasVisibleShadow() &amp;&amp; m_state.shadowBlur; }
471 
472     void drawFocusRing(const Vector&lt;FloatRect&gt;&amp;, float width, float offset, const Color&amp;);
473     void drawFocusRing(const Path&amp;, float width, float offset, const Color&amp;);
474 #if PLATFORM(MAC)
475     void drawFocusRing(const Path&amp;, double timeOffset, bool&amp; needsRedraw, const Color&amp;);
476     void drawFocusRing(const Vector&lt;FloatRect&gt;&amp;, double timeOffset, bool&amp; needsRedraw, const Color&amp;);
477 #endif
478 
479     void setLineCap(LineCap);
480     void setLineDash(const DashArray&amp;, float dashOffset);
481     void setLineJoin(LineJoin);
482     void setMiterLimit(float);
483 
484     void setAlpha(float);
485     float alpha() const { return m_state.alpha; }
486 
487     WEBCORE_EXPORT void setCompositeOperation(CompositeOperator, BlendMode = BlendMode::Normal);
488     CompositeOperator compositeOperation() const { return m_state.compositeOperator; }
489     BlendMode blendModeOperation() const { return m_state.blendMode; }
490 
491     void setDrawLuminanceMask(bool);
492     bool drawLuminanceMask() const { return m_state.drawLuminanceMask; }
493 
494     // This clip function is used only by &lt;canvas&gt; code. It allows
495     // implementations to handle clipping on the canvas differently since
496     // the discipline is different.
497     void canvasClip(const Path&amp;, WindRule = WindRule::EvenOdd);
498     void clipOut(const Path&amp;);
499 
500     void scale(float s)
501     {
502         scale({ s, s });
503     }
504     WEBCORE_EXPORT void scale(const FloatSize&amp;);
505     void rotate(float angleInRadians);
506     void translate(const FloatSize&amp; size) { translate(size.width(), size.height()); }
507     void translate(const FloatPoint&amp; p) { translate(p.x(), p.y()); }
508     WEBCORE_EXPORT void translate(float x, float y);
509 
510     void setURLForRect(const URL&amp;, const FloatRect&amp;);
511 
512     void setDestinationForRect(const String&amp; name, const FloatRect&amp;);
513     void addDestinationAtPoint(const String&amp; name, const FloatPoint&amp;);
514 
515     void concatCTM(const AffineTransform&amp;);
516     void setCTM(const AffineTransform&amp;);
517 
518     enum IncludeDeviceScale { DefinitelyIncludeDeviceScale, PossiblyIncludeDeviceScale };
519     WEBCORE_EXPORT AffineTransform getCTM(IncludeDeviceScale includeScale = PossiblyIncludeDeviceScale) const;
520 
521     // This function applies the device scale factor to the context, making the context capable of
522     // acting as a base-level context for a HiDPI environment.
523     WEBCORE_EXPORT void applyDeviceScaleFactor(float);
524     void platformApplyDeviceScaleFactor(float);
525     FloatSize scaleFactor() const;
526     FloatSize scaleFactorForDrawing(const FloatRect&amp; destRect, const FloatRect&amp; srcRect) const;
527 
528 #if OS(WINDOWS) &amp;&amp; !PLATFORM(JAVA)
529     HDC getWindowsContext(const IntRect&amp;, bool supportAlphaBlend); // The passed in rect is used to create a bitmap for compositing inside transparency layers.
530     void releaseWindowsContext(HDC, const IntRect&amp;, bool supportAlphaBlend); // The passed in HDC should be the one handed back by getWindowsContext.
531     HDC hdc() const;
532 #endif
533 #if PLATFORM(WIN)
534 #if USE(WINGDI)
535     const AffineTransform&amp; affineTransform() const;
536     AffineTransform&amp; affineTransform();
537     void resetAffineTransform();
538     void fillRect(const FloatRect&amp;, const Gradient*);
539     void drawText(const Font&amp;, const GlyphBuffer&amp;, int from, int numGlyphs, const FloatPoint&amp;);
540     void drawFrameControl(const IntRect&amp; rect, unsigned type, unsigned state);
541     void drawFocusRect(const IntRect&amp; rect);
542     void paintTextField(const IntRect&amp; rect, unsigned state);
543     void drawBitmap(SharedBitmap*, const IntRect&amp; dstRect, const IntRect&amp; srcRect, CompositeOperator, BlendMode);
544     void drawBitmapPattern(SharedBitmap*, const FloatRect&amp; tileRectIn, const AffineTransform&amp; patternTransform, const FloatPoint&amp; phase, CompositeOperator, const FloatRect&amp; destRect, const IntSize&amp; origSourceSize);
545     void drawIcon(HICON icon, const IntRect&amp; dstRect, UINT flags);
546     void drawRoundCorner(bool newClip, RECT clipRect, RECT rectWin, HDC dc, int width, int height);
547 #else
548     GraphicsContext(HDC, bool hasAlpha = false); // FIXME: To be removed.
549 
550     // When set to true, child windows should be rendered into this context
551     // rather than allowing them just to render to the screen. Defaults to
552     // false.
553     // FIXME: This is a layering violation. GraphicsContext shouldn&#39;t know
554     // what a &quot;window&quot; is. It would be much more appropriate for this flag
555     // to be passed as a parameter alongside the GraphicsContext, but doing
556     // that would require lots of changes in cross-platform code that we
557     // aren&#39;t sure we want to make.
558     void setShouldIncludeChildWindows(bool);
559     bool shouldIncludeChildWindows() const;
560 
561     class WindowsBitmap {
562         WTF_MAKE_FAST_ALLOCATED;
563         WTF_MAKE_NONCOPYABLE(WindowsBitmap);
564     public:
565         WindowsBitmap(HDC, const IntSize&amp;);
566         ~WindowsBitmap();
567 
568         HDC hdc() const { return m_hdc; }
569         UInt8* buffer() const { return m_pixelData.buffer(); }
570         unsigned bufferLength() const { return m_pixelData.bufferLength(); }
571         const IntSize&amp; size() const { return m_pixelData.size(); }
572         unsigned bytesPerRow() const { return m_pixelData.bytesPerRow(); }
573         unsigned short bitsPerPixel() const { return m_pixelData.bitsPerPixel(); }
574         const DIBPixelData&amp; windowsDIB() const { return m_pixelData; }
575 
576     private:
577         HDC m_hdc;
578         HBITMAP m_bitmap;
579         DIBPixelData m_pixelData;
580     };
581 
582     std::unique_ptr&lt;WindowsBitmap&gt; createWindowsBitmap(const IntSize&amp;);
583     // The bitmap should be non-premultiplied.
584     void drawWindowsBitmap(WindowsBitmap*, const IntPoint&amp;);
585 #endif
586 #if USE(DIRECT2D)
587     GraphicsContext(HDC, ID2D1DCRenderTarget**, RECT, bool hasAlpha = false); // FIXME: To be removed.
588 
589     WEBCORE_EXPORT static ID2D1Factory* systemFactory();
590     WEBCORE_EXPORT static ID2D1RenderTarget* defaultRenderTarget();
591 
592     WEBCORE_EXPORT void beginDraw();
593     D2D1_COLOR_F colorWithGlobalAlpha(const Color&amp;) const;
594     WEBCORE_EXPORT void endDraw();
595     void flush();
596 
597     ID2D1Brush* solidStrokeBrush() const;
598     ID2D1Brush* solidFillBrush() const;
599     ID2D1Brush* patternStrokeBrush() const;
600     ID2D1Brush* patternFillBrush() const;
601     ID2D1StrokeStyle* platformStrokeStyle() const;
602 
603     ID2D1SolidColorBrush* brushWithColor(const Color&amp;);
604 #endif
605 #else // PLATFORM(WIN)
606     bool shouldIncludeChildWindows() const { return false; }
607 #endif // PLATFORM(WIN)
608 
609     static void adjustLineToPixelBoundaries(FloatPoint&amp; p1, FloatPoint&amp; p2, float strokeWidth, StrokeStyle);
610 
611     bool supportsInternalLinks() const;
612 
613 private:
614     void platformInit(PlatformGraphicsContext*);
615     void platformDestroy();
616 
617 #if PLATFORM(WIN) &amp;&amp; !USE(WINGDI)
618     void platformInit(HDC, bool hasAlpha = false);
619 #endif
620 
621 #if USE(DIRECT2D)
622     void platformInit(HDC, ID2D1RenderTarget**, RECT, bool hasAlpha = false);
623     void platformInit(PlatformContextDirect2D*, BitmapRenderingContextType);
624 #endif
625 
626     void savePlatformState();
627     void restorePlatformState();
628 
629     void setPlatformTextDrawingMode(TextDrawingModeFlags);
630 
631     void setPlatformStrokeColor(const Color&amp;);
632     void setPlatformStrokeStyle(StrokeStyle);
633     void setPlatformStrokeThickness(float);
634 
635     void setPlatformFillColor(const Color&amp;);
636 
637     void setPlatformShouldAntialias(bool);
638     void setPlatformShouldSmoothFonts(bool);
639     void setPlatformImageInterpolationQuality(InterpolationQuality);
640 
641     void setPlatformShadow(const FloatSize&amp;, float blur, const Color&amp;);
642     void clearPlatformShadow();
643 
644     void setPlatformAlpha(float);
645     void setPlatformCompositeOperation(CompositeOperator, BlendMode = BlendMode::Normal);
646 
647     void beginPlatformTransparencyLayer(float opacity);
648     void endPlatformTransparencyLayer();
649     static bool supportsTransparencyLayers();
650 
651     void fillEllipseAsPath(const FloatRect&amp;);
652     void strokeEllipseAsPath(const FloatRect&amp;);
653 
654     void platformFillEllipse(const FloatRect&amp;);
655     void platformStrokeEllipse(const FloatRect&amp;);
656 
657     void platformFillRoundedRect(const FloatRoundedRect&amp;, const Color&amp;);
658 
659     FloatRect computeLineBoundsAndAntialiasingModeForText(const FloatRect&amp;, bool printing, Color&amp;);
660 
661     float dashedLineCornerWidthForStrokeWidth(float) const;
662     float dashedLinePatternWidthForStrokeWidth(float) const;
663     float dashedLinePatternOffsetForPatternAndStrokeWidth(float patternWidth, float strokeWidth) const;
664     Vector&lt;FloatPoint&gt; centerLineAndCutOffCorners(bool isVerticalLine, float cornerWidth, FloatPoint point1, FloatPoint point2) const;
665 
666     GraphicsContextPlatformPrivate* m_data { nullptr };
667     std::unique_ptr&lt;GraphicsContextImpl&gt; m_impl;
668 
669     GraphicsContextState m_state;
670     Vector&lt;GraphicsContextState, 1&gt; m_stack;
671 
672     const PaintInvalidationReasons m_paintInvalidationReasons { PaintInvalidationReasons::None };
673     unsigned m_transparencyCount { 0 };
674 };
675 
676 class GraphicsContextStateSaver {
677     WTF_MAKE_FAST_ALLOCATED;
678 public:
679     GraphicsContextStateSaver(GraphicsContext&amp; context, bool saveAndRestore = true)
680     : m_context(context)
681     , m_saveAndRestore(saveAndRestore)
682     {
683         if (m_saveAndRestore)
684             m_context.save();
685     }
686 
687     ~GraphicsContextStateSaver()
688     {
689         if (m_saveAndRestore)
690             m_context.restore();
691     }
692 
693     void save()
694     {
695         ASSERT(!m_saveAndRestore);
696         m_context.save();
697         m_saveAndRestore = true;
698     }
699 
700     void restore()
701     {
702         ASSERT(m_saveAndRestore);
703         m_context.restore();
704         m_saveAndRestore = false;
705     }
706 
707     GraphicsContext* context() const { return &amp;m_context; }
708 
709 private:
710     GraphicsContext&amp; m_context;
711     bool m_saveAndRestore;
712 };
713 
714 
715 class GraphicsContextStateStackChecker {
716 public:
717     GraphicsContextStateStackChecker(GraphicsContext&amp; context)
718         : m_context(context)
719         , m_stackSize(context.stackSize())
720     { }
721 
722     ~GraphicsContextStateStackChecker()
723     {
724         if (m_context.stackSize() != m_stackSize)
725             WTFLogAlways(&quot;GraphicsContext %p stack changed by %d&quot;, &amp;m_context, (int)m_context.stackSize() - (int)m_stackSize);
726     }
727 
728 private:
729     GraphicsContext&amp; m_context;
730     unsigned m_stackSize;
731 };
732 
733 
734 
735 class InterpolationQualityMaintainer {
736 public:
737     explicit InterpolationQualityMaintainer(GraphicsContext&amp; graphicsContext, InterpolationQuality interpolationQualityToUse)
738         : m_graphicsContext(graphicsContext)
739         , m_currentInterpolationQuality(graphicsContext.imageInterpolationQuality())
740         , m_interpolationQualityChanged(interpolationQualityToUse != InterpolationQuality::Default &amp;&amp; m_currentInterpolationQuality != interpolationQualityToUse)
741     {
742         if (m_interpolationQualityChanged)
743             m_graphicsContext.setImageInterpolationQuality(interpolationQualityToUse);
744     }
745 
746     explicit InterpolationQualityMaintainer(GraphicsContext&amp; graphicsContext, Optional&lt;InterpolationQuality&gt; interpolationQuality)
747         : InterpolationQualityMaintainer(graphicsContext, interpolationQuality ? interpolationQuality.value() : graphicsContext.imageInterpolationQuality())
748     {
749     }
750 
751     ~InterpolationQualityMaintainer()
752     {
753         if (m_interpolationQualityChanged)
754             m_graphicsContext.setImageInterpolationQuality(m_currentInterpolationQuality);
755     }
756 
757 private:
758     GraphicsContext&amp; m_graphicsContext;
759     InterpolationQuality m_currentInterpolationQuality;
760     bool m_interpolationQualityChanged;
761 };
762 
763 } // namespace WebCore
764 
765 namespace WTF {
766 
767 template&lt;&gt; struct EnumTraits&lt;WebCore::DocumentMarkerLineStyle::Mode&gt; {
768     using values = EnumValues&lt;
769     WebCore::DocumentMarkerLineStyle::Mode,
770     WebCore::DocumentMarkerLineStyle::Mode::TextCheckingDictationPhraseWithAlternatives,
771     WebCore::DocumentMarkerLineStyle::Mode::Spelling,
772     WebCore::DocumentMarkerLineStyle::Mode::Grammar,
773     WebCore::DocumentMarkerLineStyle::Mode::AutocorrectionReplacement,
774     WebCore::DocumentMarkerLineStyle::Mode::DictationAlternatives
775     &gt;;
776 };
777 
778 } // namespace WTF
    </pre>
  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrJIT.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrJIT.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrJIT.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrJIT.cpp
@@ -52,37 +52,36 @@
     static const RegisterID initialStart = ARMRegisters::r8;
 
     static const RegisterID returnRegister = ARMRegisters::r0;
     static const RegisterID returnRegister2 = ARMRegisters::r1;
 
-#define HAVE_INITIAL_START_REG
 #elif CPU(ARM64)
     // Argument registers
     static const RegisterID input = ARM64Registers::x0;
     static const RegisterID index = ARM64Registers::x1;
     static const RegisterID length = ARM64Registers::x2;
     static const RegisterID output = ARM64Registers::x3;
     static const RegisterID freelistRegister = ARM64Registers::x4;
-    static const RegisterID freelistSizeRegister = ARM64Registers::x5;
+    static const RegisterID freelistSizeRegister = ARM64Registers::x5; // Only used during initialization.
 
     // Scratch registers
     static const RegisterID regT0 = ARM64Registers::x6;
     static const RegisterID regT1 = ARM64Registers::x7;
     static const RegisterID regT2 = ARM64Registers::x8;
     static const RegisterID remainingMatchCount = ARM64Registers::x9;
     static const RegisterID regUnicodeInputAndTrail = ARM64Registers::x10;
+    static const RegisterID unicodeTemp = ARM64Registers::x5;
     static const RegisterID initialStart = ARM64Registers::x11;
     static const RegisterID supplementaryPlanesBase = ARM64Registers::x12;
     static const RegisterID leadingSurrogateTag = ARM64Registers::x13;
     static const RegisterID trailingSurrogateTag = ARM64Registers::x14;
     static const RegisterID endOfStringAddress = ARM64Registers::x15;
 
     static const RegisterID returnRegister = ARM64Registers::x0;
     static const RegisterID returnRegister2 = ARM64Registers::x1;
 
     const TrustedImm32 surrogateTagMask = TrustedImm32(0xfffffc00);
-#define HAVE_INITIAL_START_REG
 #define JIT_UNICODE_EXPRESSIONS
 #elif CPU(MIPS)
     static const RegisterID input = MIPSRegisters::a0;
     static const RegisterID index = MIPSRegisters::a1;
     static const RegisterID length = MIPSRegisters::a2;
@@ -93,22 +92,10 @@
     static const RegisterID initialStart = MIPSRegisters::t6;
 
     static const RegisterID returnRegister = MIPSRegisters::v0;
     static const RegisterID returnRegister2 = MIPSRegisters::v1;
 
-#define HAVE_INITIAL_START_REG
-#elif CPU(X86)
-    static const RegisterID input = X86Registers::eax;
-    static const RegisterID index = X86Registers::edx;
-    static const RegisterID length = X86Registers::ecx;
-    static const RegisterID output = X86Registers::edi;
-
-    static const RegisterID regT0 = X86Registers::ebx;
-    static const RegisterID regT1 = X86Registers::esi;
-
-    static const RegisterID returnRegister = X86Registers::eax;
-    static const RegisterID returnRegister2 = X86Registers::edx;
 #elif CPU(X86_64)
 #if !OS(WINDOWS)
     // Argument registers
     static const RegisterID input = X86Registers::edi;
     static const RegisterID index = X86Registers::esi;
@@ -141,20 +128,20 @@
     static const RegisterID remainingMatchCount = X86Registers::r12;
 #else
     static const RegisterID remainingMatchCount = X86Registers::esi;
 #endif
     static const RegisterID regUnicodeInputAndTrail = X86Registers::r13;
-    static const RegisterID leadingSurrogateTag = X86Registers::r14;
+    static const RegisterID unicodeTemp = X86Registers::r14;
     static const RegisterID endOfStringAddress = X86Registers::r15;
 
     static const RegisterID returnRegister = X86Registers::eax;
     static const RegisterID returnRegister2 = X86Registers::edx;
 
     const TrustedImm32 supplementaryPlanesBase = TrustedImm32(0x10000);
+    const TrustedImm32 leadingSurrogateTag = TrustedImm32(0xd800);
     const TrustedImm32 trailingSurrogateTag = TrustedImm32(0xdc00);
     const TrustedImm32 surrogateTagMask = TrustedImm32(0xfffffc00);
-#define HAVE_INITIAL_START_REG
 #define JIT_UNICODE_EXPRESSIONS
 #endif
 
 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
     struct ParenContextSizes {
@@ -541,22 +528,27 @@
         ASSERT(m_charSize == Char16);
 
         JumpList notUnicode;
 
         load16Unaligned(regUnicodeInputAndTrail, resultReg);
-        and32(surrogateTagMask, resultReg, regT2);
-        notUnicode.append(branch32(NotEqual, regT2, leadingSurrogateTag));
+
+        // Is the character a leading surrogate?
+        and32(surrogateTagMask, resultReg, unicodeTemp);
+        notUnicode.append(branch32(NotEqual, unicodeTemp, leadingSurrogateTag));
+
+        // Is the input long enough to read a trailing surrogate?
         addPtr(TrustedImm32(2), regUnicodeInputAndTrail);
         notUnicode.append(branchPtr(AboveOrEqual, regUnicodeInputAndTrail, endOfStringAddress));
+
+        // Is the character a trailing surrogate?
         load16Unaligned(Address(regUnicodeInputAndTrail), regUnicodeInputAndTrail);
-        and32(surrogateTagMask, regUnicodeInputAndTrail, regT2);
-        notUnicode.append(branch32(NotEqual, regT2, trailingSurrogateTag));
-        sub32(leadingSurrogateTag, resultReg);
-        sub32(trailingSurrogateTag, regUnicodeInputAndTrail);
+        and32(surrogateTagMask, regUnicodeInputAndTrail, unicodeTemp);
+        notUnicode.append(branch32(NotEqual, unicodeTemp, trailingSurrogateTag));
+
+        // Combine leading and trailing surrogates to produce a code point.
         lshift32(TrustedImm32(10), resultReg);
-        or32(regUnicodeInputAndTrail, resultReg);
-        add32(supplementaryPlanesBase, resultReg);
+        getEffectiveAddress(BaseIndex(resultReg, regUnicodeInputAndTrail, TimesOne, -U16_SURROGATE_OFFSET), resultReg);
         notUnicode.link(this);
     }
 
     void tryReadUnicodeChar(BaseIndex address, RegisterID resultReg)
     {
@@ -569,20 +561,10 @@
         else
             tryReadUnicodeCharImpl(resultReg);
     }
 #endif
 
-    void readCharacterDontDecodeSurrogates(Checked<unsigned> negativeCharacterOffset, RegisterID resultReg, RegisterID indexReg = index)
-    {
-        BaseIndex address = negativeOffsetIndexedAddress(negativeCharacterOffset, resultReg, indexReg);
-
-        if (m_charSize == Char8)
-            load8(address, resultReg);
-        else
-            load16Unaligned(address, resultReg);
-    }
-
     void readCharacter(Checked<unsigned> negativeCharacterOffset, RegisterID resultReg, RegisterID indexReg = index)
     {
         BaseIndex address = negativeOffsetIndexedAddress(negativeCharacterOffset, resultReg, indexReg);
 
         if (m_charSize == Char8)
@@ -654,35 +636,12 @@
         return callFrameSize;
     }
     void initCallFrame()
     {
         unsigned callFrameSizeInBytes = alignCallFrameSizeInBytes(m_pattern.m_body->m_callFrameSize);
-        if (callFrameSizeInBytes) {
-#if CPU(X86_64) || CPU(ARM64)
-            if (Options::zeroStackFrame()) {
-                // We need to start from the stack pointer, because we could have spilled callee saves
-                move(stackPointerRegister, regT0);
-                subPtr(Imm32(callFrameSizeInBytes), stackPointerRegister);
-                if (callFrameSizeInBytes <= 128) {
-                    for (unsigned offset = 0; offset < callFrameSizeInBytes; offset += sizeof(intptr_t))
-                        storePtr(TrustedImm32(0), Address(regT0, -8 - offset));
-                } else {
-                    Label zeroLoop = label();
-                    subPtr(TrustedImm32(sizeof(intptr_t) * 2), regT0);
-#if CPU(ARM64)
-                    storePair64(ARM64Registers::zr, ARM64Registers::zr, regT0);
-#else
-                    storePtr(TrustedImm32(0), Address(regT0));
-                    storePtr(TrustedImm32(0), Address(regT0, sizeof(intptr_t)));
-#endif
-                    branchPtr(NotEqual, regT0, stackPointerRegister).linkTo(zeroLoop, this);
-                }
-            } else
-#endif
-                subPtr(Imm32(callFrameSizeInBytes), stackPointerRegister);
-
-        }
+        if (callFrameSizeInBytes)
+            subPtr(Imm32(callFrameSizeInBytes), stackPointerRegister);
     }
     void removeCallFrame()
     {
         unsigned callFrameSizeInBytes = alignCallFrameSizeInBytes(m_pattern.m_body->m_callFrameSize);
         if (callFrameSizeInBytes)
@@ -1148,12 +1107,12 @@
         PatternTerm* term = op.m_term;
         unsigned subpatternId = term->backReferenceSubpatternId;
 
         Label loop(this);
 
-        readCharacterDontDecodeSurrogates(0, patternCharacter, patternIndex);
-        readCharacterDontDecodeSurrogates(m_checkedOffset - term->inputPosition, character);
+        readCharacter(0, patternCharacter, patternIndex);
+        readCharacter(m_checkedOffset - term->inputPosition, character);
 
         if (!m_pattern.ignoreCase())
             characterMatchFails.append(branch32(NotEqual, character, patternCharacter));
         else {
             Jump charactersMatch = branch32(Equal, character, patternCharacter);
@@ -1163,14 +1122,20 @@
             load16(patternTableEntry, patternCharacter);
             characterMatchFails.append(branch32(NotEqual, character, patternCharacter));
             charactersMatch.link(this);
         }
 
-
         add32(TrustedImm32(1), index);
         add32(TrustedImm32(1), patternIndex);
 
+        if (m_decodeSurrogatePairs) {
+            Jump isBMPChar = branch32(LessThan, character, supplementaryPlanesBase);
+            add32(TrustedImm32(1), index);
+            add32(TrustedImm32(1), patternIndex);
+            isBMPChar.link(this);
+        }
+
         branch32(NotEqual, patternIndex, Address(output, ((subpatternId << 1) + 1) * sizeof(int))).linkTo(loop, this);
     }
 
     void generateBackReference(size_t opIndex)
     {
@@ -2029,14 +1994,10 @@
         YarrOp& op = m_ops[opIndex];
         PatternTerm* term = op.m_term;
 
         const RegisterID character = regT0;
         const RegisterID matchPos = regT1;
-#ifndef HAVE_INITIAL_START_REG
-        const RegisterID initialStart = character;
-#endif
-
         JumpList foundBeginningNewLine;
         JumpList saveStartIndex;
         JumpList foundEndingNewLine;
 
         if (m_pattern.dotAll()) {
@@ -2047,25 +2008,19 @@
         }
 
         ASSERT(!m_pattern.m_body->m_hasFixedSize);
         getMatchStart(matchPos);
 
-#ifndef HAVE_INITIAL_START_REG
-        loadFromFrame(m_pattern.m_initialStartValueFrameLocation, initialStart);
-#endif
         saveStartIndex.append(branch32(BelowOrEqual, matchPos, initialStart));
         Label findBOLLoop(this);
         sub32(TrustedImm32(1), matchPos);
         if (m_charSize == Char8)
             load8(BaseIndex(input, matchPos, TimesOne, 0), character);
         else
             load16(BaseIndex(input, matchPos, TimesTwo, 0), character);
         matchCharacterClass(character, foundBeginningNewLine, m_pattern.newlineCharacterClass());
 
-#ifndef HAVE_INITIAL_START_REG
-        loadFromFrame(m_pattern.m_initialStartValueFrameLocation, initialStart);
-#endif
         branch32(Above, matchPos, initialStart).linkTo(findBOLLoop, this);
         saveStartIndex.append(jump());
 
         foundBeginningNewLine.link(this);
         add32(TrustedImm32(1), matchPos); // Advance past newline
@@ -3749,40 +3704,20 @@
 
         if (m_decodeSurrogatePairs) {
             push(X86Registers::r13);
             push(X86Registers::r14);
             push(X86Registers::r15);
-
-            move(TrustedImm32(0xd800), leadingSurrogateTag);
         }
         // The ABI doesn't guarantee the upper bits are zero on unsigned arguments, so clear them ourselves.
         zeroExtend32ToPtr(index, index);
         zeroExtend32ToPtr(length, length);
 #if OS(WINDOWS)
         if (compileMode == IncludeSubpatterns)
             loadPtr(Address(X86Registers::ebp, 6 * sizeof(void*)), output);
         // rcx is the pointer to the allocated space for result in x64 Windows.
         push(X86Registers::ecx);
 #endif
-#elif CPU(X86)
-        push(X86Registers::ebp);
-        move(stackPointerRegister, X86Registers::ebp);
-        // TODO: do we need spill registers to fill the output pointer if there are no sub captures?
-        push(X86Registers::ebx);
-        push(X86Registers::edi);
-        push(X86Registers::esi);
-        // load output into edi (2 = saved ebp + return address).
-    #if COMPILER(MSVC)
-        loadPtr(Address(X86Registers::ebp, 2 * sizeof(void*)), input);
-        loadPtr(Address(X86Registers::ebp, 3 * sizeof(void*)), index);
-        loadPtr(Address(X86Registers::ebp, 4 * sizeof(void*)), length);
-        if (compileMode == IncludeSubpatterns)
-            loadPtr(Address(X86Registers::ebp, 5 * sizeof(void*)), output);
-    #else
-        if (compileMode == IncludeSubpatterns)
-            loadPtr(Address(X86Registers::ebp, 2 * sizeof(void*)), output);
-    #endif
 #elif CPU(ARM64)
         tagReturnAddress();
         if (m_decodeSurrogatePairs) {
             pushPair(framePointerRegister, linkRegister);
             move(TrustedImm32(0x10000), supplementaryPlanesBase);
@@ -3836,15 +3771,10 @@
 #endif
 
         if (m_pattern.m_saveInitialStartValue)
             pop(X86Registers::ebx);
         pop(X86Registers::ebp);
-#elif CPU(X86)
-        pop(X86Registers::esi);
-        pop(X86Registers::edi);
-        pop(X86Registers::ebx);
-        pop(X86Registers::ebp);
 #elif CPU(ARM64)
         if (m_decodeSurrogatePairs)
             popPair(framePointerRegister, linkRegister);
 #elif CPU(ARM_THUMB2)
         pop(ARMRegisters::r8);
@@ -3949,17 +3879,12 @@
                 return;
             }
         }
 #endif
 
-        if (m_pattern.m_saveInitialStartValue) {
-#ifdef HAVE_INITIAL_START_REG
+        if (m_pattern.m_saveInitialStartValue)
             move(index, initialStart);
-#else
-            storeToFrame(index, m_pattern.m_initialStartValueFrameLocation);
-#endif
-        }
 
         generate();
         if (m_disassembler)
             m_disassembler->setEndOfGenerate(label());
         backtrack();
@@ -4293,11 +4218,11 @@
         YarrGenerator<MatchOnly>(vm, pattern, patternString, codeBlock, charSize).compile();
     else
         YarrGenerator<IncludeSubpatterns>(vm, pattern, patternString, codeBlock, charSize).compile();
 
     if (auto failureReason = codeBlock.failureReason()) {
-        if (Options::dumpCompiledRegExpPatterns()) {
+        if (UNLIKELY(Options::dumpCompiledRegExpPatterns())) {
             pattern.dumpPatternString(WTF::dataFile(), patternString);
             dataLog(" : ");
             dumpCompileFailure(*failureReason);
         }
     }

diff a/modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSSelectorParser.cpp b/modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSSelectorParser.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSSelectorParser.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSSelectorParser.cpp
@@ -207,19 +207,22 @@
 {
     switch (pseudo) {
     case CSSSelector::PseudoClassHover:
     case CSSSelector::PseudoClassFocus:
     case CSSSelector::PseudoClassActive:
+    case CSSSelector::PseudoClassFocusWithin:
         return true;
     default:
         return false;
     }
 }
 
 bool isPseudoClassValidAfterPseudoElement(CSSSelector::PseudoClassType pseudoClass, CSSSelector::PseudoElementType compoundPseudoElement)
 {
     switch (compoundPseudoElement) {
+    case CSSSelector::PseudoElementPart:
+        return !isTreeStructuralPseudoClass(pseudoClass);
     case CSSSelector::PseudoElementResizer:
     case CSSSelector::PseudoElementScrollbar:
     case CSSSelector::PseudoElementScrollbarCorner:
     case CSSSelector::PseudoElementScrollbarButton:
     case CSSSelector::PseudoElementScrollbarThumb:
@@ -238,13 +241,14 @@
 
 bool isSimpleSelectorValidAfterPseudoElement(const CSSParserSelector& simpleSelector, CSSSelector::PseudoElementType compoundPseudoElement)
 {
     if (compoundPseudoElement == CSSSelector::PseudoElementUnknown)
         return true;
-    // FIXME-NEWPARSER: This doesn't exist for us.
-    // if (compoundPseudoElement == CSSSelector::PseudoElementContent)
-    //    return simpleSelector.match() != CSSSelector::PseudoElement;
+    if (compoundPseudoElement == CSSSelector::PseudoElementPart) {
+        if (simpleSelector.match() == CSSSelector::PseudoElement && simpleSelector.pseudoElementType() != CSSSelector::PseudoElementPart)
+            return true;
+    }
     if (simpleSelector.match() != CSSSelector::PseudoClass)
         return false;
     CSSSelector::PseudoClassType pseudo = simpleSelector.pseudoClassType();
     if (pseudo == CSSSelector::PseudoClassNot) {
         ASSERT(simpleSelector.selectorList());
@@ -460,10 +464,11 @@
 
 static bool isOnlyPseudoElementFunction(CSSSelector::PseudoElementType pseudoElementType)
 {
     // Note that we omit cue since it can be both an ident or a function.
     switch (pseudoElementType) {
+    case CSSSelector::PseudoElementPart:
     case CSSSelector::PseudoElementSlotted:
         return true;
     default:
         break;
     }
@@ -487,14 +492,20 @@
 
     std::unique_ptr<CSSParserSelector> selector;
 
     if (colons == 1) {
         selector = CSSParserSelector::parsePseudoClassSelector(token.value());
-#if ENABLE(ATTACHMENT_ELEMENT)
-        if (!m_context.attachmentEnabled && selector && selector->match() == CSSSelector::PseudoClass && selector->pseudoClassType() == CSSSelector::PseudoClassHasAttachment)
+        if (!selector)
             return nullptr;
+        if (selector->match() == CSSSelector::PseudoClass) {
+            if (m_context.mode != UASheetMode && selector->pseudoClassType() == CSSSelector::PseudoClassDirectFocus)
+                return nullptr;
+#if ENABLE(ATTACHMENT_ELEMENT)
+            if (!m_context.attachmentEnabled && selector->pseudoClassType() == CSSSelector::PseudoClassHasAttachment)
+                return nullptr;
 #endif
+        }
     } else {
         selector = CSSParserSelector::parsePseudoElementSelector(token.value());
 #if ENABLE(VIDEO_TRACK)
         // Treat the ident version of cue as PseudoElementWebkitCustom.
         if (token.type() == IdentToken && selector && selector->match() == CSSSelector::PseudoElement && selector->pseudoElementType() == CSSSelector::PseudoElementCue)
@@ -565,11 +576,11 @@
         case CSSSelector::PseudoClassLang: {
             // FIXME: CSS Selectors Level 4 allows :lang(*-foo)
             auto argumentList = makeUnique<Vector<AtomString>>();
             if (!consumeLangArgumentList(argumentList, block))
                 return nullptr;
-            selector->setLangArgumentList(WTFMove(argumentList));
+            selector->setArgumentList(WTFMove(argumentList));
             return selector;
         }
         case CSSSelector::PseudoClassMatches: {
             std::unique_ptr<CSSSelectorList> selectorList = std::unique_ptr<CSSSelectorList>(new CSSSelectorList());
             *selectorList = consumeComplexSelectorList(block);
@@ -598,11 +609,10 @@
         }
 #endif
         default:
             break;
         }
-
     }
 
     if (selector->match() == CSSSelector::PseudoElement) {
         switch (selector->pseudoElementType()) {
 #if ENABLE(VIDEO_TRACK)
@@ -614,10 +624,35 @@
                 return nullptr;
             selector->setSelectorList(WTFMove(selectorList));
             return selector;
         }
 #endif
+        case CSSSelector::PseudoElementHighlight: {
+            DisallowPseudoElementsScope scope(this);
+
+            auto& ident = block.consumeIncludingWhitespace();
+            if (ident.type() != IdentToken || !block.atEnd())
+                return nullptr;
+
+            auto argumentList = makeUnique<Vector<AtomString>>();
+            argumentList->append(ident.value().toAtomString());
+            selector->setArgumentList(WTFMove(argumentList));
+
+            return selector;
+        }
+        case CSSSelector::PseudoElementPart: {
+            auto argumentList = makeUnique<Vector<AtomString>>();
+            do {
+                auto& ident = block.consumeIncludingWhitespace();
+                if (ident.type() != IdentToken)
+                    return nullptr;
+                argumentList->append(ident.value().toAtomString());
+            } while (!block.atEnd());
+
+            selector->setArgumentList(WTFMove(argumentList));
+            return selector;
+        }
         case CSSSelector::PseudoElementSlotted: {
             DisallowPseudoElementsScope scope(this);
 
             std::unique_ptr<CSSParserSelector> innerSelector = consumeCompoundSelector(block);
             block.consumeWhitespace();
@@ -849,14 +884,22 @@
         splitAfter = splitAfter->tagHistory();
 
     if (!splitAfter || !splitAfter->tagHistory())
         return compoundSelector;
 
-    // FIXME: https://bugs.webkit.org/show_bug.cgi?id=161747
-    // We have to recur, since we have rules in media controls like video::a::b. This should not be allowed, and
-    // we should remove this recursion once those rules are gone.
-    std::unique_ptr<CSSParserSelector> secondCompound = context.mode != UASheetMode ? splitAfter->releaseTagHistory() : splitCompoundAtImplicitShadowCrossingCombinator(splitAfter->releaseTagHistory(), context);
+    // ::part() combines with other pseudo elements.
+    bool isPart = splitAfter->tagHistory()->match() == CSSSelector::PseudoElement && splitAfter->tagHistory()->pseudoElementType() == CSSSelector::PseudoElementPart;
+
+    std::unique_ptr<CSSParserSelector> secondCompound;
+    if (context.mode == UASheetMode || isPart) {
+        // FIXME: https://bugs.webkit.org/show_bug.cgi?id=161747
+        // We have to recur, since we have rules in media controls like video::a::b. This should not be allowed, and
+        // we should remove this recursion once those rules are gone.
+        secondCompound = splitCompoundAtImplicitShadowCrossingCombinator(splitAfter->releaseTagHistory(), context);
+    } else
+        secondCompound = splitAfter->releaseTagHistory();
+
     secondCompound->appendTagHistory(CSSSelector::ShadowDescendant, WTFMove(compoundSelector));
     return secondCompound;
 }
 
 } // namespace WebCore

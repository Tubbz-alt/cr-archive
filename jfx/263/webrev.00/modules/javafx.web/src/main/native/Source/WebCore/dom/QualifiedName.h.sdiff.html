<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/QualifiedName.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="QualifiedName.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RadioButtonGroups.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/QualifiedName.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #pragma once
 22 
 23 #include &lt;wtf/HashTraits.h&gt;
 24 #include &lt;wtf/NeverDestroyed.h&gt;
 25 #include &lt;wtf/text/AtomString.h&gt;
 26 
 27 namespace WebCore {
 28 
 29 struct QualifiedNameComponents {
 30     StringImpl* m_prefix;
 31     StringImpl* m_localName;
 32     StringImpl* m_namespace;
 33 };
 34 



 35 class QualifiedName {
<span class="line-modified"> 36     WTF_MAKE_FAST_ALLOCATED;</span>
 37 public:
 38     class QualifiedNameImpl : public RefCounted&lt;QualifiedNameImpl&gt; {

 39     public:
 40         static Ref&lt;QualifiedNameImpl&gt; create(const AtomString&amp; prefix, const AtomString&amp; localName, const AtomString&amp; namespaceURI)
 41         {
 42             return adoptRef(*new QualifiedNameImpl(prefix, localName, namespaceURI));
 43         }
 44 
 45         WEBCORE_EXPORT ~QualifiedNameImpl();
 46 
 47         unsigned computeHash() const;
 48 
 49         mutable unsigned m_existingHash { 0 };
 50         const AtomString m_prefix;
 51         const AtomString m_localName;
 52         const AtomString m_namespace;
 53         mutable AtomString m_localNameUpper;
 54 
 55 #if ENABLE(JIT)
 56         static ptrdiff_t localNameMemoryOffset() { return OBJECT_OFFSETOF(QualifiedNameImpl, m_localName); }
 57         static ptrdiff_t namespaceMemoryOffset() { return OBJECT_OFFSETOF(QualifiedNameImpl, m_namespace); }
 58 #endif
</pre>
<hr />
<pre>
 83     void setPrefix(const AtomString&amp; prefix) { *this = QualifiedName(prefix, localName(), namespaceURI()); }
 84 
 85     const AtomString&amp; prefix() const { return m_impl-&gt;m_prefix; }
 86     const AtomString&amp; localName() const { return m_impl-&gt;m_localName; }
 87     const AtomString&amp; namespaceURI() const { return m_impl-&gt;m_namespace; }
 88 
 89     // Uppercased localName, cached for efficiency
 90     const AtomString&amp; localNameUpper() const;
 91 
 92     String toString() const;
 93 
 94     QualifiedNameImpl* impl() const { return m_impl.get(); }
 95 #if ENABLE(JIT)
 96     static ptrdiff_t implMemoryOffset() { return OBJECT_OFFSETOF(QualifiedName, m_impl); }
 97 #endif
 98 
 99     // Init routine for globals
100     WEBCORE_EXPORT static void init();
101 
102 private:
<span class="line-modified">103     static QualifiedNameImpl* hashTableDeletedValue() { return RefPtr&lt;QualifiedNameImpl&gt;::hashTableDeletedValue(); }</span>
104 
105     RefPtr&lt;QualifiedNameImpl&gt; m_impl;
106 };
107 
108 extern LazyNeverDestroyed&lt;const QualifiedName&gt; anyName;
109 inline const QualifiedName&amp; anyQName() { return anyName; }
110 
111 const QualifiedName&amp; nullQName();
112 
113 inline bool operator==(const AtomString&amp; a, const QualifiedName&amp; q) { return a == q.localName(); }
114 inline bool operator!=(const AtomString&amp; a, const QualifiedName&amp; q) { return a != q.localName(); }
115 inline bool operator==(const QualifiedName&amp; q, const AtomString&amp; a) { return a == q.localName(); }
116 inline bool operator!=(const QualifiedName&amp; q, const AtomString&amp; a) { return a != q.localName(); }
117 
118 inline unsigned hashComponents(const QualifiedNameComponents&amp; buf)
119 {
120     return StringHasher::hashMemory&lt;sizeof(QualifiedNameComponents)&gt;(&amp;buf);
121 }
122 
123 struct QualifiedNameHash {
</pre>
</td>
<td>
<hr />
<pre>
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #pragma once
 22 
 23 #include &lt;wtf/HashTraits.h&gt;
 24 #include &lt;wtf/NeverDestroyed.h&gt;
 25 #include &lt;wtf/text/AtomString.h&gt;
 26 
 27 namespace WebCore {
 28 
 29 struct QualifiedNameComponents {
 30     StringImpl* m_prefix;
 31     StringImpl* m_localName;
 32     StringImpl* m_namespace;
 33 };
 34 
<span class="line-added"> 35 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(QualifiedName);</span>
<span class="line-added"> 36 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(QualifiedNameQualifiedNameImpl);</span>
<span class="line-added"> 37 </span>
 38 class QualifiedName {
<span class="line-modified"> 39     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(QualifiedName);</span>
 40 public:
 41     class QualifiedNameImpl : public RefCounted&lt;QualifiedNameImpl&gt; {
<span class="line-added"> 42         WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(QualifiedNameQualifiedNameImpl);</span>
 43     public:
 44         static Ref&lt;QualifiedNameImpl&gt; create(const AtomString&amp; prefix, const AtomString&amp; localName, const AtomString&amp; namespaceURI)
 45         {
 46             return adoptRef(*new QualifiedNameImpl(prefix, localName, namespaceURI));
 47         }
 48 
 49         WEBCORE_EXPORT ~QualifiedNameImpl();
 50 
 51         unsigned computeHash() const;
 52 
 53         mutable unsigned m_existingHash { 0 };
 54         const AtomString m_prefix;
 55         const AtomString m_localName;
 56         const AtomString m_namespace;
 57         mutable AtomString m_localNameUpper;
 58 
 59 #if ENABLE(JIT)
 60         static ptrdiff_t localNameMemoryOffset() { return OBJECT_OFFSETOF(QualifiedNameImpl, m_localName); }
 61         static ptrdiff_t namespaceMemoryOffset() { return OBJECT_OFFSETOF(QualifiedNameImpl, m_namespace); }
 62 #endif
</pre>
<hr />
<pre>
 87     void setPrefix(const AtomString&amp; prefix) { *this = QualifiedName(prefix, localName(), namespaceURI()); }
 88 
 89     const AtomString&amp; prefix() const { return m_impl-&gt;m_prefix; }
 90     const AtomString&amp; localName() const { return m_impl-&gt;m_localName; }
 91     const AtomString&amp; namespaceURI() const { return m_impl-&gt;m_namespace; }
 92 
 93     // Uppercased localName, cached for efficiency
 94     const AtomString&amp; localNameUpper() const;
 95 
 96     String toString() const;
 97 
 98     QualifiedNameImpl* impl() const { return m_impl.get(); }
 99 #if ENABLE(JIT)
100     static ptrdiff_t implMemoryOffset() { return OBJECT_OFFSETOF(QualifiedName, m_impl); }
101 #endif
102 
103     // Init routine for globals
104     WEBCORE_EXPORT static void init();
105 
106 private:
<span class="line-modified">107     static QualifiedNameImpl* hashTableDeletedValue() { return RefPtr&lt;QualifiedNameImpl&gt;::PtrTraits::hashTableDeletedValue(); }</span>
108 
109     RefPtr&lt;QualifiedNameImpl&gt; m_impl;
110 };
111 
112 extern LazyNeverDestroyed&lt;const QualifiedName&gt; anyName;
113 inline const QualifiedName&amp; anyQName() { return anyName; }
114 
115 const QualifiedName&amp; nullQName();
116 
117 inline bool operator==(const AtomString&amp; a, const QualifiedName&amp; q) { return a == q.localName(); }
118 inline bool operator!=(const AtomString&amp; a, const QualifiedName&amp; q) { return a != q.localName(); }
119 inline bool operator==(const QualifiedName&amp; q, const AtomString&amp; a) { return a == q.localName(); }
120 inline bool operator!=(const QualifiedName&amp; q, const AtomString&amp; a) { return a != q.localName(); }
121 
122 inline unsigned hashComponents(const QualifiedNameComponents&amp; buf)
123 {
124     return StringHasher::hashMemory&lt;sizeof(QualifiedNameComponents)&gt;(&amp;buf);
125 }
126 
127 struct QualifiedNameHash {
</pre>
</td>
</tr>
</table>
<center><a href="QualifiedName.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RadioButtonGroups.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
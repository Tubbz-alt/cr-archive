diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGShape.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGShape.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGShape.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGShape.cpp
@@ -77,11 +77,11 @@
 
 RenderSVGShape::~RenderSVGShape() = default;
 
 void RenderSVGShape::updateShapeFromElement()
 {
-    m_path = makeUnique<Path>(pathFromGraphicsElement(&graphicsElement()));
+    m_path = createPath();
     processMarkerPositions();
 
     m_fillBoundingBox = calculateObjectBoundingBox();
     m_strokeBoundingBox = calculateStrokeBoundingBox();
 }
@@ -118,24 +118,24 @@
 
     if (hasNonScalingStroke() && pointCoordinateSpace != LocalCoordinateSpace) {
         AffineTransform nonScalingTransform = nonScalingStrokeTransform();
         Path* usePath = nonScalingStrokePath(m_path.get(), nonScalingTransform);
 
-        return usePath->strokeContains(&applier, nonScalingTransform.mapPoint(point));
+        return usePath->strokeContains(applier, nonScalingTransform.mapPoint(point));
     }
 
-    return m_path->strokeContains(&applier, point);
+    return m_path->strokeContains(applier, point);
 }
 
 bool RenderSVGShape::shapeDependentFillContains(const FloatPoint& point, const WindRule fillRule) const
 {
     return path().contains(point, fillRule);
 }
 
 bool RenderSVGShape::fillContains(const FloatPoint& point, bool requiresFill, const WindRule fillRule)
 {
-    if (!m_fillBoundingBox.contains(point))
+    if (m_fillBoundingBox.isEmpty() || !m_fillBoundingBox.contains(point))
         return false;
 
     Color fallbackColor;
     if (requiresFill && !RenderSVGResource::fillPaintingResource(*this, style(), fallbackColor))
         return false;
@@ -143,11 +143,11 @@
     return shapeDependentFillContains(point, fillRule);
 }
 
 bool RenderSVGShape::strokeContains(const FloatPoint& point, bool requiresStroke)
 {
-    if (!strokeBoundingBox().contains(point))
+    if (strokeBoundingBox().isEmpty() || !strokeBoundingBox().contains(point))
         return false;
 
     Color fallbackColor;
     if (requiresStroke && !RenderSVGResource::strokePaintingResource(*this, style(), fallbackColor))
         return false;
@@ -345,23 +345,16 @@
     return shapeDependentStrokeContains(point, LocalCoordinateSpace);
 }
 
 float RenderSVGShape::getTotalLength() const
 {
-    if (m_path)
-        return m_path->length();
-
-    return 0;
+    return hasPath() ? path().length() : createPath()->length();
 }
 
-void RenderSVGShape::getPointAtLength(FloatPoint& point, float distance) const
+FloatPoint RenderSVGShape::getPointAtLength(float distance) const
 {
-    if (!m_path)
-        return;
-
-    bool isValid;
-    point = m_path->pointAtLength(distance, isValid);
+    return hasPath() ? path().pointAtLength(distance) : createPath()->pointAtLength(distance);
 }
 
 bool RenderSVGShape::nodeAtFloatPoint(const HitTestRequest& request, HitTestResult& result, const FloatPoint& pointInParent, HitTestAction hitTestAction)
 {
     // We only draw in the forground phase, so we only hit-test then.
@@ -379,11 +372,12 @@
         const SVGRenderStyle& svgStyle = style().svgStyle();
         WindRule fillRule = svgStyle.fillRule();
         if (request.svgClipContent())
             fillRule = svgStyle.clipRule();
         if ((hitRules.canHitStroke && (svgStyle.hasStroke() || !hitRules.requireStroke) && strokeContains(localPoint, hitRules.requireStroke))
-            || (hitRules.canHitFill && (svgStyle.hasFill() || !hitRules.requireFill) && fillContains(localPoint, hitRules.requireFill, fillRule))) {
+            || (hitRules.canHitFill && (svgStyle.hasFill() || !hitRules.requireFill) && fillContains(localPoint, hitRules.requireFill, fillRule))
+            || (hitRules.canHitBoundingBox && objectBoundingBox().contains(localPoint))) {
             updateHitTestResult(result, LayoutPoint(localPoint));
             if (result.addNodeToListBasedTestResult(&graphicsElement(), request, localPoint) == HitTestProgress::Stop)
                 return true;
         }
     }
@@ -500,10 +494,15 @@
         if (RenderSVGResourceMarker* marker = markerForType(m_markerPositions[i].type, markerStart, markerMid, markerEnd))
             marker->draw(paintInfo, marker->markerTransformation(m_markerPositions[i].origin, m_markerPositions[i].angle, strokeWidth));
     }
 }
 
+std::unique_ptr<Path> RenderSVGShape::createPath() const
+{
+    return makeUnique<Path>(pathFromGraphicsElement(&graphicsElement()));
+}
+
 void RenderSVGShape::processMarkerPositions()
 {
     m_markerPositions.clear();
 
     if (!shouldGenerateMarkerPositions())

diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CallLinkStatus.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CallLinkStatus.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CallLinkStatus.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CallLinkStatus.cpp
@@ -38,11 +38,11 @@
 #include <wtf/ListDump.h>
 
 namespace JSC {
 
 namespace CallLinkStatusInternal {
-static const bool verbose = false;
+static constexpr bool verbose = false;
 }
 
 CallLinkStatus::CallLinkStatus(JSValue value)
     : m_couldTakeSlowPath(false)
     , m_isProved(false)
@@ -53,11 +53,11 @@
     }
 
     m_variants.append(CallVariant(value.asCell()));
 }
 
-CallLinkStatus CallLinkStatus::computeFromLLInt(const ConcurrentJSLocker&, CodeBlock* profiledBlock, unsigned bytecodeIndex)
+CallLinkStatus CallLinkStatus::computeFromLLInt(const ConcurrentJSLocker&, CodeBlock* profiledBlock, BytecodeIndex bytecodeIndex)
 {
     UNUSED_PARAM(profiledBlock);
     UNUSED_PARAM(bytecodeIndex);
 #if ENABLE(DFG_JIT)
     if (profiledBlock->unlinkedCodeBlock()->hasExitSite(DFG::FrequentExitSite(bytecodeIndex, BadCell))) {
@@ -65,11 +65,11 @@
         // takes slow path.
         return takesSlowPath();
     }
 #endif
 
-    auto instruction = profiledBlock->instructions().at(bytecodeIndex);
+    auto instruction = profiledBlock->instructions().at(bytecodeIndex.offset());
     OpcodeID op = instruction->opcodeID();
 
     LLIntCallLinkInfo* callLinkInfo;
     switch (op) {
     case op_call:
@@ -88,11 +88,11 @@
 
     return CallLinkStatus(callLinkInfo->lastSeenCallee());
 }
 
 CallLinkStatus CallLinkStatus::computeFor(
-    CodeBlock* profiledBlock, unsigned bytecodeIndex, const ICStatusMap& map,
+    CodeBlock* profiledBlock, BytecodeIndex bytecodeIndex, const ICStatusMap& map,
     ExitSiteData exitSiteData)
 {
     ConcurrentJSLocker locker(profiledBlock->m_lock);
 
     UNUSED_PARAM(profiledBlock);
@@ -112,16 +112,16 @@
     return CallLinkStatus();
 #endif
 }
 
 CallLinkStatus CallLinkStatus::computeFor(
-    CodeBlock* profiledBlock, unsigned bytecodeIndex, const ICStatusMap& map)
+    CodeBlock* profiledBlock, BytecodeIndex bytecodeIndex, const ICStatusMap& map)
 {
     return computeFor(profiledBlock, bytecodeIndex, map, computeExitSiteData(profiledBlock, bytecodeIndex));
 }
 
-CallLinkStatus::ExitSiteData CallLinkStatus::computeExitSiteData(CodeBlock* profiledBlock, unsigned bytecodeIndex)
+CallLinkStatus::ExitSiteData CallLinkStatus::computeExitSiteData(CodeBlock* profiledBlock, BytecodeIndex bytecodeIndex)
 {
     ExitSiteData exitSiteData;
 #if ENABLE(DFG_JIT)
     UnlinkedCodeBlock* codeBlock = profiledBlock->unlinkedCodeBlock();
     ConcurrentJSLocker locker(codeBlock->m_lock);
@@ -155,11 +155,11 @@
 {
     // We don't really need this, but anytime we have to debug this code, it becomes indispensable.
     UNUSED_PARAM(profiledBlock);
 
     CallLinkStatus result = computeFromCallLinkInfo(locker, callLinkInfo);
-    result.m_maxNumArguments = callLinkInfo.maxNumArguments();
+    result.m_maxArgumentCountIncludingThis = callLinkInfo.maxArgumentCountIncludingThis();
     return result;
 }
 
 CallLinkStatus CallLinkStatus::computeFromCallLinkInfo(
     const ConcurrentJSLocker&, CallLinkInfo& callLinkInfo)
@@ -472,11 +472,11 @@
         out.print(comma, "Based On Stub");
 
     if (!m_variants.isEmpty())
         out.print(comma, listDump(m_variants));
 
-    if (m_maxNumArguments)
-        out.print(comma, "maxNumArguments = ", m_maxNumArguments);
+    if (m_maxArgumentCountIncludingThis)
+        out.print(comma, "maxArgumentCountIncludingThis = ", m_maxArgumentCountIncludingThis);
 }
 
 } // namespace JSC
 

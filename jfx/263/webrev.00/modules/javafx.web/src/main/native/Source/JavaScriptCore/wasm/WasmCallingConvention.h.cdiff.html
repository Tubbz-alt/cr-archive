<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmCallingConvention.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmCallingConvention.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmCodeBlock.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmCallingConvention.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 37,308 ***</span>
  #include &quot;B3PatchpointValue.h&quot;
  #include &quot;B3Procedure.h&quot;
  #include &quot;B3StackmapGenerationParams.h&quot;
  #include &quot;CallFrame.h&quot;
  #include &quot;LinkBuffer.h&quot;
  #include &quot;RegisterSet.h&quot;
  #include &quot;WasmFormat.h&quot;
  #include &quot;WasmSignature.h&quot;
  
  namespace JSC { namespace Wasm {
  
<span class="line-modified">! typedef unsigned (*NextOffset)(unsigned currentOffset);</span>
  
<span class="line-modified">! template&lt;unsigned headerSize, NextOffset updateOffset&gt;</span>
<span class="line-modified">! class CallingConvention {</span>
<span class="line-modified">! public:</span>
<span class="line-modified">!     CallingConvention(Vector&lt;Reg&gt;&amp;&amp; gprArgs, Vector&lt;Reg&gt;&amp;&amp; fprArgs, RegisterSet&amp;&amp; calleeSaveRegisters)</span>
<span class="line-modified">!         : m_gprArgs(WTFMove(gprArgs))</span>
<span class="line-modified">!         , m_fprArgs(WTFMove(fprArgs))</span>
<span class="line-modified">!         , m_calleeSaveRegisters(WTFMove(calleeSaveRegisters))</span>
      {
      }
  
  private:
<span class="line-modified">!     B3::ValueRep marshallArgumentImpl(const Vector&lt;Reg&gt;&amp; regArgs, size_t&amp; count, size_t&amp; stackOffset) const</span>
      {
          if (count &lt; regArgs.size())
<span class="line-modified">!             return B3::ValueRep::reg(regArgs[count++]);</span>
  
          count++;
<span class="line-modified">!         B3::ValueRep result = B3::ValueRep::stackArgument(stackOffset);</span>
<span class="line-modified">!         stackOffset = updateOffset(stackOffset);</span>
          return result;
      }
  
<span class="line-modified">!     B3::ValueRep marshallArgument(B3::Type type, size_t&amp; gpArgumentCount, size_t&amp; fpArgumentCount, size_t&amp; stackOffset) const</span>
      {
<span class="line-modified">!         switch (type.kind()) {</span>
<span class="line-modified">!         case B3::Int32:</span>
<span class="line-modified">!         case B3::Int64:</span>
<span class="line-modified">!             return marshallArgumentImpl(m_gprArgs, gpArgumentCount, stackOffset);</span>
<span class="line-modified">!         case B3::Float:</span>
<span class="line-modified">!         case B3::Double:</span>
<span class="line-modified">!             return marshallArgumentImpl(m_fprArgs, fpArgumentCount, stackOffset);</span>
<span class="line-modified">!         case B3::Void:</span>
<span class="line-modified">!         case B3::Tuple:</span>
              break;
<span class="line-removed">- </span>
          }
          RELEASE_ASSERT_NOT_REACHED();
      }
  
  public:
<span class="line-modified">!     static unsigned headerSizeInBytes() { return headerSize; }</span>
<span class="line-removed">-     void setupFrameInPrologue(CodeLocationDataLabelPtr&lt;WasmEntryPtrTag&gt;* calleeMoveLocation, B3::Procedure&amp; proc, B3::Origin origin, B3::BasicBlock* block) const</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         static_assert(CallFrameSlot::callee * sizeof(Register) &lt; headerSize, &quot;We rely on this here for now.&quot;);</span>
<span class="line-removed">-         static_assert(CallFrameSlot::codeBlock * sizeof(Register) &lt; headerSize, &quot;We rely on this here for now.&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         B3::PatchpointValue* getCalleePatchpoint = block-&gt;appendNew&lt;B3::PatchpointValue&gt;(proc, B3::Int64, origin);</span>
<span class="line-removed">-         getCalleePatchpoint-&gt;resultConstraints = { B3::ValueRep::SomeRegister };</span>
<span class="line-removed">-         getCalleePatchpoint-&gt;effects = B3::Effects::none();</span>
<span class="line-removed">-         getCalleePatchpoint-&gt;setGenerator(</span>
<span class="line-removed">-             [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {</span>
<span class="line-removed">-                 GPRReg result = params[0].gpr();</span>
<span class="line-removed">-                 MacroAssembler::DataLabelPtr moveLocation = jit.moveWithPatch(MacroAssembler::TrustedImmPtr(nullptr), result);</span>
<span class="line-removed">-                 jit.addLinkTask([calleeMoveLocation, moveLocation] (LinkBuffer&amp; linkBuffer) {</span>
<span class="line-removed">-                     *calleeMoveLocation = linkBuffer.locationOf&lt;WasmEntryPtrTag&gt;(moveLocation);</span>
<span class="line-removed">-                 });</span>
<span class="line-removed">-             });</span>
<span class="line-removed">- </span>
<span class="line-removed">-         B3::Value* framePointer = block-&gt;appendNew&lt;B3::Value&gt;(proc, B3::FramePointer, origin);</span>
<span class="line-removed">-         B3::Value* offsetOfCallee = block-&gt;appendNew&lt;B3::Const64Value&gt;(proc, origin, CallFrameSlot::callee * sizeof(Register));</span>
<span class="line-removed">-         block-&gt;appendNew&lt;B3::MemoryValue&gt;(proc, B3::Store, origin,</span>
<span class="line-removed">-             getCalleePatchpoint,</span>
<span class="line-removed">-             block-&gt;appendNew&lt;B3::Value&gt;(proc, B3::Add, origin, framePointer, offsetOfCallee));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // FIXME: We shouldn&#39;t have to store zero into the CodeBlock* spot in the call frame,</span>
<span class="line-removed">-         // but there are places that interpret non-null CodeBlock slot to mean a valid CodeBlock.</span>
<span class="line-removed">-         // When doing unwinding, we&#39;ll need to verify that the entire runtime is OK with a non-null</span>
<span class="line-removed">-         // CodeBlock not implying that the CodeBlock is valid.</span>
<span class="line-removed">-         // https://bugs.webkit.org/show_bug.cgi?id=165321</span>
<span class="line-removed">-         B3::Value* offsetOfCodeBlock = block-&gt;appendNew&lt;B3::Const64Value&gt;(proc, origin, CallFrameSlot::codeBlock * sizeof(Register));</span>
<span class="line-removed">-         block-&gt;appendNew&lt;B3::MemoryValue&gt;(proc, B3::Store, origin,</span>
<span class="line-removed">-             block-&gt;appendNew&lt;B3::Const64Value&gt;(proc, origin, 0),</span>
<span class="line-removed">-             block-&gt;appendNew&lt;B3::Value&gt;(proc, B3::Add, origin, framePointer, offsetOfCodeBlock));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     template&lt;typename Functor&gt;</span>
<span class="line-removed">-     void loadArguments(const Signature&amp; signature, B3::Procedure&amp; proc, B3::BasicBlock* block, B3::Origin origin, const Functor&amp; functor) const</span>
      {
<span class="line-modified">!         B3::Value* framePointer = block-&gt;appendNew&lt;B3::Value&gt;(proc, B3::FramePointer, origin);</span>
<span class="line-modified">! </span>
          size_t gpArgumentCount = 0;
          size_t fpArgumentCount = 0;
<span class="line-modified">!         size_t stackOffset = headerSize;</span>
  
          for (size_t i = 0; i &lt; signature.argumentCount(); ++i) {
<span class="line-modified">!             B3::Type type = toB3Type(signature.argument(i));</span>
<span class="line-modified">!             B3::Value* argument;</span>
<span class="line-removed">-             B3::ValueRep rep = marshallArgument(type, gpArgumentCount, fpArgumentCount, stackOffset);</span>
<span class="line-removed">-             if (rep.isReg()) {</span>
<span class="line-removed">-                 argument = block-&gt;appendNew&lt;B3::ArgumentRegValue&gt;(proc, origin, rep.reg());</span>
<span class="line-removed">-                 if (type == B3::Int32 || type == B3::Float)</span>
<span class="line-removed">-                     argument = block-&gt;appendNew&lt;B3::Value&gt;(proc, B3::Trunc, origin, argument);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 ASSERT(rep.isStackArgument());</span>
<span class="line-removed">-                 B3::Value* address = block-&gt;appendNew&lt;B3::Value&gt;(proc, B3::Add, origin, framePointer,</span>
<span class="line-removed">-                     block-&gt;appendNew&lt;B3::Const64Value&gt;(proc, origin, rep.offsetFromSP()));</span>
<span class="line-removed">-                 argument = block-&gt;appendNew&lt;B3::MemoryValue&gt;(proc, B3::Load, type, origin, address);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             functor(argument, i);</span>
          }
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // It&#39;s expected that the pachpointFunctor sets the generator for the call operation.</span>
<span class="line-modified">!     template&lt;typename Functor&gt;</span>
<span class="line-modified">!     B3::Value* setupCall(B3::Procedure&amp; proc, B3::BasicBlock* block, B3::Origin origin, const Vector&lt;B3::Value*&gt;&amp; arguments, B3::Type returnType, const Functor&amp; patchpointFunctor) const</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         size_t gpArgumentCount = 0;</span>
<span class="line-modified">!         size_t fpArgumentCount = 0;</span>
<span class="line-modified">!         size_t stackOffset = headerSize - sizeof(CallerFrameAndPC);</span>
<span class="line-modified">! </span>
<span class="line-removed">-         Vector&lt;B3::ConstrainedValue&gt; constrainedArguments;</span>
<span class="line-removed">-         for (B3::Value* argument : arguments) {</span>
<span class="line-removed">-             B3::ValueRep rep = marshallArgument(argument-&gt;type(), gpArgumentCount, fpArgumentCount, stackOffset);</span>
<span class="line-removed">-             constrainedArguments.append(B3::ConstrainedValue(argument, rep));</span>
          }
  
<span class="line-modified">!         proc.requestCallArgAreaSizeInBytes(WTF::roundUpToMultipleOf(stackAlignmentBytes(), stackOffset));</span>
<span class="line-modified">! </span>
<span class="line-modified">!         B3::PatchpointValue* patchpoint = block-&gt;appendNew&lt;B3::PatchpointValue&gt;(proc, returnType, origin);</span>
<span class="line-modified">!         patchpoint-&gt;clobberEarly(RegisterSet::macroScratchRegisters());</span>
<span class="line-removed">-         patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());</span>
<span class="line-removed">-         patchpointFunctor(patchpoint);</span>
<span class="line-removed">-         patchpoint-&gt;appendVector(constrainedArguments);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         switch (returnType.kind()) {</span>
<span class="line-removed">-         case B3::Void:</span>
<span class="line-removed">-             return nullptr;</span>
<span class="line-removed">-         case B3::Float:</span>
<span class="line-removed">-         case B3::Double:</span>
<span class="line-removed">-             patchpoint-&gt;resultConstraints = { B3::ValueRep::reg(FPRInfo::returnValueFPR) };</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case B3::Int32:</span>
<span class="line-removed">-         case B3::Int64:</span>
<span class="line-removed">-             patchpoint-&gt;resultConstraints = { B3::ValueRep::reg(GPRInfo::returnValueGPR) };</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case B3::Tuple:</span>
<span class="line-removed">-             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return patchpoint;</span>
      }
  
<span class="line-modified">!     const Vector&lt;Reg&gt; m_gprArgs;</span>
<span class="line-modified">!     const Vector&lt;Reg&gt; m_fprArgs;</span>
<span class="line-modified">!     const RegisterSet m_calleeSaveRegisters;</span>
<span class="line-modified">!     const RegisterSet m_callerSaveRegisters;</span>
  };
  
<span class="line-modified">! // FIXME: Share more code with CallingConvention above:</span>
<span class="line-removed">- // https://bugs.webkit.org/show_bug.cgi?id=194065</span>
<span class="line-removed">- template&lt;unsigned headerSize, NextOffset updateOffset&gt;</span>
<span class="line-removed">- class CallingConventionAir {</span>
  public:
<span class="line-modified">!     CallingConventionAir(Vector&lt;Reg&gt;&amp;&amp; gprArgs, Vector&lt;Reg&gt;&amp;&amp; fprArgs, RegisterSet&amp;&amp; calleeSaveRegisters)</span>
<span class="line-modified">!         : m_gprArgs(WTFMove(gprArgs))</span>
<span class="line-modified">!         , m_fprArgs(WTFMove(fprArgs))</span>
<span class="line-modified">!         , m_calleeSaveRegisters(WTFMove(calleeSaveRegisters))</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         RegisterSet scratch = RegisterSet::allGPRs();</span>
<span class="line-removed">-         scratch.exclude(RegisterSet::macroScratchRegisters());</span>
<span class="line-removed">-         scratch.exclude(RegisterSet::reservedHardwareRegisters());</span>
<span class="line-removed">-         scratch.exclude(RegisterSet::stackRegisters());</span>
<span class="line-removed">-         for (Reg reg : m_gprArgs)</span>
<span class="line-removed">-             scratch.clear(reg);</span>
<span class="line-removed">-         for (Reg reg : m_calleeSaveRegisters)</span>
<span class="line-removed">-             scratch.clear(reg);</span>
<span class="line-removed">-         for (Reg reg : scratch)</span>
<span class="line-removed">-             m_scratchGPRs.append(reg);</span>
<span class="line-removed">-         RELEASE_ASSERT(m_scratchGPRs.size() &gt;= 2);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     GPRReg prologueScratch(size_t i) const { return m_scratchGPRs[i].gpr(); }</span>
  
  private:
<span class="line-modified">!     template &lt;typename RegFunc, typename StackFunc&gt;</span>
<span class="line-removed">-     void marshallArgumentImpl(const Vector&lt;Reg&gt;&amp; regArgs, size_t&amp; count, size_t&amp; stackOffset, const RegFunc&amp; regFunc, const StackFunc&amp; stackFunc) const</span>
      {
<span class="line-modified">!         if (count &lt; regArgs.size()) {</span>
<span class="line-modified">!             regFunc(regArgs[count++]);</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
  
          count++;
<span class="line-modified">!         stackFunc(stackOffset);</span>
<span class="line-modified">!         stackOffset = updateOffset(stackOffset);</span>
      }
  
<span class="line-modified">!     template &lt;typename RegFunc, typename StackFunc&gt;</span>
<span class="line-removed">-     void marshallArgument(Type type, size_t&amp; gpArgumentCount, size_t&amp; fpArgumentCount, size_t&amp; stackOffset, const RegFunc&amp; regFunc, const StackFunc&amp; stackFunc) const</span>
      {
<span class="line-modified">!         switch (type) {</span>
<span class="line-modified">!         case Type::I32:</span>
<span class="line-modified">!         case Type::I64:</span>
<span class="line-modified">!         case Type::Anyref:</span>
<span class="line-modified">!         case Wasm::Funcref:</span>
<span class="line-modified">!             marshallArgumentImpl(m_gprArgs, gpArgumentCount, stackOffset, regFunc, stackFunc);</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case Type::F32:</span>
<span class="line-modified">!         case Type::F64:</span>
<span class="line-modified">!             marshallArgumentImpl(m_fprArgs, fpArgumentCount, stackOffset, regFunc, stackFunc);</span>
<span class="line-removed">-             break;</span>
          default:
<span class="line-modified">!             RELEASE_ASSERT_NOT_REACHED();</span>
          }
      }
  
  public:
<span class="line-modified">!     static unsigned headerSizeInBytes() { return headerSize; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     template&lt;typename Functor&gt;</span>
<span class="line-removed">-     void loadArguments(const Signature&amp; signature, const Functor&amp; functor) const</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         size_t gpArgumentCount = 0;</span>
<span class="line-removed">-         size_t fpArgumentCount = 0;</span>
<span class="line-removed">-         size_t stackOffset = headerSize;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         for (size_t i = 0; i &lt; signature.argumentCount(); ++i) {</span>
<span class="line-removed">-             marshallArgument(signature.argument(i), gpArgumentCount, fpArgumentCount, stackOffset,</span>
<span class="line-removed">-                 [&amp;] (Reg reg) {</span>
<span class="line-removed">-                     functor(B3::Air::Tmp(reg), i);</span>
<span class="line-removed">-                 },</span>
<span class="line-removed">-                 [&amp;] (size_t stackOffset) {</span>
<span class="line-removed">-                     functor(B3::Air::Arg::addr(B3::Air::Tmp(GPRInfo::callFrameRegister), stackOffset), i);</span>
<span class="line-removed">-                 });</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // It&#39;s expected that the pachpointFunctor sets the generator for the call operation.</span>
<span class="line-removed">-     template&lt;typename Functor&gt;</span>
<span class="line-removed">-     void setupCall(B3::Air::Code&amp; code, Type returnType, B3::PatchpointValue* patchpoint, const Vector&lt;B3::Air::Tmp&gt;&amp; args, const Functor&amp; functor) const</span>
      {
          size_t gpArgumentCount = 0;
          size_t fpArgumentCount = 0;
<span class="line-modified">!         size_t stackOffset = headerSize - sizeof(CallerFrameAndPC);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         for (auto tmp : args) {</span>
<span class="line-removed">-             marshallArgument(tmp.isGP() ? Type::I64 : Type::F64, gpArgumentCount, fpArgumentCount, stackOffset,</span>
<span class="line-removed">-                 [&amp;] (Reg reg) {</span>
<span class="line-removed">-                     functor(tmp, B3::ValueRep::reg(reg));</span>
<span class="line-removed">-                 },</span>
<span class="line-removed">-                 [&amp;] (size_t stackOffset) {</span>
<span class="line-removed">-                     functor(tmp, B3::ValueRep::stackArgument(stackOffset));</span>
<span class="line-removed">-                 });</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         code.requestCallArgAreaSizeInBytes(WTF::roundUpToMultipleOf(stackAlignmentBytes(), stackOffset));</span>
  
<span class="line-modified">!         patchpoint-&gt;clobberEarly(RegisterSet::macroScratchRegisters());</span>
<span class="line-modified">!         patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         switch (returnType) {</span>
<span class="line-removed">-         case Type::Void:</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case Type::F32:</span>
<span class="line-removed">-         case Type::F64:</span>
<span class="line-removed">-             patchpoint-&gt;resultConstraints = { B3::ValueRep::reg(FPRInfo::returnValueFPR) };</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case Type::I32:</span>
<span class="line-removed">-         case Type::I64:</span>
<span class="line-removed">-         case Type::Anyref:</span>
<span class="line-removed">-         case Wasm::Funcref:</span>
<span class="line-removed">-             patchpoint-&gt;resultConstraints = { B3::ValueRep::reg(GPRInfo::returnValueGPR) };</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         default:</span>
<span class="line-removed">-             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">-         }</span>
      }
  
<span class="line-modified">!     const Vector&lt;Reg&gt; m_gprArgs;</span>
<span class="line-modified">!     const Vector&lt;Reg&gt; m_fprArgs;</span>
<span class="line-modified">!     Vector&lt;Reg&gt; m_scratchGPRs;</span>
<span class="line-modified">!     const RegisterSet m_calleeSaveRegisters;</span>
<span class="line-removed">-     const RegisterSet m_callerSaveRegisters;</span>
  };
  
<span class="line-modified">! inline unsigned nextJSCOffset(unsigned currentOffset)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return currentOffset + sizeof(Register);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- constexpr unsigned jscHeaderSize = ExecState::headerSizeInRegisters * sizeof(Register);</span>
<span class="line-removed">- </span>
<span class="line-removed">- using JSCCallingConvention = CallingConvention&lt;jscHeaderSize, nextJSCOffset&gt;;</span>
<span class="line-removed">- using WasmCallingConvention = JSCCallingConvention;</span>
<span class="line-removed">- const JSCCallingConvention&amp; jscCallingConvention();</span>
  const WasmCallingConvention&amp; wasmCallingConvention();
  
<span class="line-removed">- using JSCCallingConventionAir = CallingConventionAir&lt;jscHeaderSize, nextJSCOffset&gt;;</span>
<span class="line-removed">- using WasmCallingConventionAir = JSCCallingConventionAir;</span>
<span class="line-removed">- const JSCCallingConventionAir&amp; jscCallingConventionAir();</span>
<span class="line-removed">- const WasmCallingConventionAir&amp; wasmCallingConventionAir();</span>
<span class="line-removed">- </span>
  } } // namespace JSC::Wasm
  
  #endif // ENABLE(WEBASSEMBLY)
<span class="line-new-header">--- 37,208 ---</span>
  #include &quot;B3PatchpointValue.h&quot;
  #include &quot;B3Procedure.h&quot;
  #include &quot;B3StackmapGenerationParams.h&quot;
  #include &quot;CallFrame.h&quot;
  #include &quot;LinkBuffer.h&quot;
<span class="line-added">+ #include &quot;RegisterAtOffsetList.h&quot;</span>
  #include &quot;RegisterSet.h&quot;
  #include &quot;WasmFormat.h&quot;
  #include &quot;WasmSignature.h&quot;
  
  namespace JSC { namespace Wasm {
  
<span class="line-modified">! constexpr unsigned numberOfLLIntCalleeSaveRegisters = 2;</span>
  
<span class="line-modified">! using ArgumentLocation = B3::ValueRep;</span>
<span class="line-modified">! enum class CallRole : uint8_t {</span>
<span class="line-modified">!     Caller,</span>
<span class="line-modified">!     Callee,</span>
<span class="line-modified">! };</span>
<span class="line-modified">! </span>
<span class="line-modified">! struct CallInformation {</span>
<span class="line-added">+     CallInformation(Vector&lt;ArgumentLocation&gt;&amp;&amp; parameters, Vector&lt;ArgumentLocation, 1&gt;&amp;&amp; returnValues, size_t stackOffset)</span>
<span class="line-added">+         : params(WTFMove(parameters))</span>
<span class="line-added">+         , results(WTFMove(returnValues))</span>
<span class="line-added">+         , headerAndArgumentStackSizeInBytes(stackOffset)</span>
<span class="line-added">+     { }</span>
<span class="line-added">+ </span>
<span class="line-added">+     RegisterAtOffsetList computeResultsOffsetList()</span>
      {
<span class="line-added">+         RegisterSet usedResultRegisters;</span>
<span class="line-added">+         for (B3::ValueRep rep : results) {</span>
<span class="line-added">+             if (rep.isReg())</span>
<span class="line-added">+                 usedResultRegisters.set(rep.reg());</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         RegisterAtOffsetList savedRegs(usedResultRegisters, RegisterAtOffsetList::ZeroBased);</span>
<span class="line-added">+         return savedRegs;</span>
      }
  
<span class="line-added">+     bool argumentsIncludeI64 { false };</span>
<span class="line-added">+     bool resultsIncludeI64 { false };</span>
<span class="line-added">+     Vector&lt;ArgumentLocation&gt; params;</span>
<span class="line-added">+     Vector&lt;ArgumentLocation, 1&gt; results;</span>
<span class="line-added">+     // As a callee this includes CallerFrameAndPC as a caller it does not.</span>
<span class="line-added">+     size_t headerAndArgumentStackSizeInBytes;</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ class WasmCallingConvention {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     static constexpr unsigned headerSizeInBytes = CallFrame::headerSizeInRegisters * sizeof(Register);</span>
<span class="line-added">+ </span>
<span class="line-added">+     WasmCallingConvention(Vector&lt;Reg&gt;&amp;&amp; gprs, Vector&lt;Reg&gt;&amp;&amp; fprs, Vector&lt;GPRReg&gt;&amp;&amp; scratches, RegisterSet&amp;&amp; calleeSaves, RegisterSet&amp;&amp; callerSaves)</span>
<span class="line-added">+         : gprArgs(WTFMove(gprs))</span>
<span class="line-added">+         , fprArgs(WTFMove(fprs))</span>
<span class="line-added">+         , prologueScratchGPRs(WTFMove(scratches))</span>
<span class="line-added">+         , calleeSaveRegisters(WTFMove(calleeSaves))</span>
<span class="line-added">+         , callerSaveRegisters(WTFMove(callerSaves))</span>
<span class="line-added">+     { }</span>
<span class="line-added">+ </span>
<span class="line-added">+     WTF_MAKE_NONCOPYABLE(WasmCallingConvention);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     ArgumentLocation marshallLocationImpl(CallRole role, const Vector&lt;Reg&gt;&amp; regArgs, size_t&amp; count, size_t&amp; stackOffset) const</span>
      {
          if (count &lt; regArgs.size())
<span class="line-modified">!             return ArgumentLocation::reg(regArgs[count++]);</span>
  
          count++;
<span class="line-modified">!         ArgumentLocation result = role == CallRole::Caller ? ArgumentLocation::stackArgument(stackOffset) : ArgumentLocation::stack(stackOffset);</span>
<span class="line-modified">!         stackOffset += sizeof(Register);</span>
          return result;
      }
  
<span class="line-modified">!     ArgumentLocation marshallLocation(CallRole role, Type valueType, size_t&amp; gpArgumentCount, size_t&amp; fpArgumentCount, size_t&amp; stackOffset) const</span>
      {
<span class="line-modified">!         ASSERT(isValueType(valueType));</span>
<span class="line-modified">!         switch (valueType) {</span>
<span class="line-modified">!         case I32:</span>
<span class="line-modified">!         case I64:</span>
<span class="line-modified">!         case Funcref:</span>
<span class="line-modified">!         case Anyref:</span>
<span class="line-modified">!             return marshallLocationImpl(role, gprArgs, gpArgumentCount, stackOffset);</span>
<span class="line-modified">!         case F32:</span>
<span class="line-modified">!         case F64:</span>
<span class="line-added">+             return marshallLocationImpl(role, fprArgs, fpArgumentCount, stackOffset);</span>
<span class="line-added">+         default:</span>
              break;
          }
          RELEASE_ASSERT_NOT_REACHED();
      }
  
  public:
<span class="line-modified">!     CallInformation callInformationFor(const Signature&amp; signature, CallRole role = CallRole::Caller) const</span>
      {
<span class="line-modified">!         bool argumentsIncludeI64 = false;</span>
<span class="line-modified">!         bool resultsIncludeI64 = false;</span>
          size_t gpArgumentCount = 0;
          size_t fpArgumentCount = 0;
<span class="line-modified">!         size_t argStackOffset = headerSizeInBytes;</span>
<span class="line-added">+         if (role == CallRole::Caller)</span>
<span class="line-added">+             argStackOffset -= sizeof(CallerFrameAndPC);</span>
  
<span class="line-added">+         Vector&lt;ArgumentLocation&gt; params(signature.argumentCount());</span>
          for (size_t i = 0; i &lt; signature.argumentCount(); ++i) {
<span class="line-modified">!             argumentsIncludeI64 |= signature.argument(i) == I64;</span>
<span class="line-modified">!             params[i] = marshallLocation(role, signature.argument(i), gpArgumentCount, fpArgumentCount, argStackOffset);</span>
          }
<span class="line-modified">!         gpArgumentCount = 0;</span>
<span class="line-modified">!         fpArgumentCount = 0;</span>
<span class="line-modified">!         size_t resultStackOffset = headerSizeInBytes;</span>
<span class="line-modified">!         if (role == CallRole::Caller)</span>
<span class="line-modified">!             resultStackOffset -= sizeof(CallerFrameAndPC);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         Vector&lt;ArgumentLocation, 1&gt; results(signature.returnCount());</span>
<span class="line-modified">!         for (size_t i = 0; i &lt; signature.returnCount(); ++i) {</span>
<span class="line-modified">!             resultsIncludeI64 |= signature.returnType(i) == I64;</span>
<span class="line-modified">!             results[i] = marshallLocation(role, signature.returnType(i), gpArgumentCount, fpArgumentCount, resultStackOffset);</span>
          }
  
<span class="line-modified">!         CallInformation result(WTFMove(params), WTFMove(results), std::max(argStackOffset, resultStackOffset));</span>
<span class="line-modified">!         result.argumentsIncludeI64 = argumentsIncludeI64;</span>
<span class="line-modified">!         result.resultsIncludeI64 = resultsIncludeI64;</span>
<span class="line-modified">!         return result;</span>
      }
  
<span class="line-modified">!     const Vector&lt;Reg&gt; gprArgs;</span>
<span class="line-modified">!     const Vector&lt;Reg&gt; fprArgs;</span>
<span class="line-modified">!     const Vector&lt;GPRReg&gt; prologueScratchGPRs;</span>
<span class="line-modified">!     const RegisterSet calleeSaveRegisters;</span>
<span class="line-added">+     const RegisterSet callerSaveRegisters;</span>
  };
  
<span class="line-modified">! class JSCallingConvention {</span>
  public:
<span class="line-modified">!     static constexpr unsigned headerSizeInBytes = CallFrame::headerSizeInRegisters * sizeof(Register);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // vmEntryToWasm passes the JSWebAssemblyInstance corresponding to Wasm::Context*&#39;s</span>
<span class="line-modified">!     // instance as the first JS argument when we&#39;re not using fast TLS to hold the</span>
<span class="line-modified">!     // Wasm::Context*&#39;s instance.</span>
<span class="line-modified">!     static constexpr ptrdiff_t instanceStackOffset = CallFrameSlot::thisArgument * sizeof(EncodedJSValue);</span>
  
<span class="line-modified">!     JSCallingConvention(Vector&lt;Reg&gt;&amp;&amp; gprs, Vector&lt;Reg&gt;&amp;&amp; fprs, RegisterSet&amp;&amp; calleeSaves, RegisterSet&amp;&amp; callerSaves)</span>
<span class="line-added">+         : gprArgs(WTFMove(gprs))</span>
<span class="line-added">+         , fprArgs(WTFMove(fprs))</span>
<span class="line-added">+         , calleeSaveRegisters(WTFMove(calleeSaves))</span>
<span class="line-added">+         , callerSaveRegisters(WTFMove(callerSaves))</span>
<span class="line-added">+     { }</span>
  
<span class="line-added">+     WTF_MAKE_NONCOPYABLE(JSCallingConvention);</span>
  private:
<span class="line-modified">!     ArgumentLocation marshallLocationImpl(CallRole role, const Vector&lt;Reg&gt;&amp; regArgs, size_t&amp; count, size_t&amp; stackOffset) const</span>
      {
<span class="line-modified">!         if (count &lt; regArgs.size())</span>
<span class="line-modified">!             return ArgumentLocation::reg(regArgs[count++]);</span>
  
          count++;
<span class="line-modified">!         ArgumentLocation result = role == CallRole::Caller ? ArgumentLocation::stackArgument(stackOffset) : ArgumentLocation::stack(stackOffset);</span>
<span class="line-modified">!         stackOffset += sizeof(Register);</span>
<span class="line-added">+         return result;</span>
      }
  
<span class="line-modified">!     ArgumentLocation marshallLocation(CallRole role, Type valueType, size_t&amp; gpArgumentCount, size_t&amp; fpArgumentCount, size_t&amp; stackOffset) const</span>
      {
<span class="line-modified">!         ASSERT(isValueType(valueType));</span>
<span class="line-modified">!         switch (valueType) {</span>
<span class="line-modified">!         case I32:</span>
<span class="line-modified">!         case I64:</span>
<span class="line-modified">!         case Funcref:</span>
<span class="line-modified">!         case Anyref:</span>
<span class="line-modified">!             return marshallLocationImpl(role, gprArgs, gpArgumentCount, stackOffset);</span>
<span class="line-modified">!         case F32:</span>
<span class="line-modified">!         case F64:</span>
<span class="line-modified">!             return marshallLocationImpl(role, fprArgs, fpArgumentCount, stackOffset);</span>
          default:
<span class="line-modified">!             break;</span>
          }
<span class="line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
      }
  
  public:
<span class="line-modified">!     CallInformation callInformationFor(const Signature&amp; signature, CallRole role = CallRole::Callee) const</span>
      {
          size_t gpArgumentCount = 0;
          size_t fpArgumentCount = 0;
<span class="line-modified">!         size_t stackOffset = headerSizeInBytes + sizeof(Register); // Skip the this value since wasm doesn&#39;t use it and we sometimes put the context there.</span>
<span class="line-modified">!         if (role == CallRole::Caller)</span>
<span class="line-modified">!             stackOffset -= sizeof(CallerFrameAndPC);</span>
  
<span class="line-modified">!         Vector&lt;ArgumentLocation&gt; params;</span>
<span class="line-added">+         for (size_t i = 0; i &lt; signature.argumentCount(); ++i)</span>
<span class="line-added">+             params.append(marshallLocation(role, signature.argument(i), gpArgumentCount, fpArgumentCount, stackOffset));</span>
  
<span class="line-modified">!         Vector&lt;ArgumentLocation, 1&gt; results { ArgumentLocation::reg(GPRInfo::returnValueGPR) };</span>
<span class="line-modified">!         return CallInformation(WTFMove(params), WTFMove(results), stackOffset);</span>
      }
  
<span class="line-modified">!     const Vector&lt;Reg&gt; gprArgs;</span>
<span class="line-modified">!     const Vector&lt;Reg&gt; fprArgs;</span>
<span class="line-modified">!     const RegisterSet calleeSaveRegisters;</span>
<span class="line-modified">!     const RegisterSet callerSaveRegisters;</span>
  };
  
<span class="line-modified">! const JSCallingConvention&amp; jsCallingConvention();</span>
  const WasmCallingConvention&amp; wasmCallingConvention();
  
  } } // namespace JSC::Wasm
  
  #endif // ENABLE(WEBASSEMBLY)
</pre>
<center><a href="WasmCallingConvention.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmCodeBlock.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
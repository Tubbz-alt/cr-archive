<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/platform/vr/VRPlatformDisplay.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018 Igalia, S.L. All right reserved.
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #pragma once
 22 
 23 #include &quot;FloatPoint3D.h&quot;
 24 #include &quot;TransformationMatrix.h&quot;
 25 #include &quot;VRPlatformDisplayClient.h&quot;
 26 
 27 #include &lt;wtf/WeakPtr.h&gt;
 28 #include &lt;wtf/text/WTFString.h&gt;
 29 
 30 namespace WebCore {
 31 
 32 typedef unsigned VRDisplayCapabilityFlags;
 33 
 34 enum VRDisplayCapabilityFlag {
 35     VRDisplayCapabilityFlagNone = 0,
 36     VRDisplayCapabilityFlagPosition = 1 &lt;&lt; 1,
 37     VRDisplayCapabilityFlagOrientation = 1 &lt;&lt; 2,
 38     VRDisplayCapabilityFlagExternalDisplay = 1 &lt;&lt; 3,
 39     VRDisplayCapabilityFlagPresent = 1 &lt;&lt; 4
 40 };
 41 
 42 /* The purpose of this class is to encapsulate all the info about the display in a single class/data
 43  * structure. This way we wouldn&#39;t have to replicate all the API calls of VRDisplay in
 44  * VRPlatformDisplay. Also the client of this API would only have to issue a single call to get all
 45  * the info from the display. Note that it&#39;s fairly unlikely that a VR application would only
 46  * require just a few pieces of information from the device.
 47 */
 48 class VRPlatformDisplayInfo {
 49 public:
 50     const String displayName() const { return m_displayName; }
 51     void setDisplayName(String&amp;&amp; displayName) { m_displayName = WTFMove(displayName); }
 52 
 53     bool isConnected() const { return m_isConnected; }
 54     void setIsConnected(bool isConnected) { m_isConnected = isConnected; }
 55 
 56     bool isMounted() const { return m_isMounted; }
 57     void setIsMounted(bool isMounted) { m_isMounted = isMounted; }
 58 
 59     const VRDisplayCapabilityFlags&amp; capabilityFlags() const { return m_capabilityFlags; }
 60     void setCapabilityFlags(const VRDisplayCapabilityFlags&amp; flags) { m_capabilityFlags = flags; }
 61 
 62     uint32_t displayIdentifier() const { return m_displayIdentifier; }
 63     void setDisplayIdentifier(uint32_t displayIdentifier) { m_displayIdentifier = displayIdentifier; }
 64 
 65     enum Eye { EyeLeft = 0, EyeRight, NumEyes };
 66     const FloatPoint3D&amp; eyeTranslation(Eye eye) const { return m_eyeTranslation[eye]; }
 67     void setEyeTranslation(Eye eye, const FloatPoint3D&amp; translation) { m_eyeTranslation[eye] = translation; }
 68 
 69     struct FieldOfView {
 70         double upDegrees;
 71         double downDegrees;
 72         double leftDegrees;
 73         double rightDegrees;
 74     };
 75     const FieldOfView&amp; eyeFieldOfView(Eye eye) const { return m_eyeFieldOfView[eye]; }
 76     void setEyeFieldOfView(Eye eye, const FieldOfView&amp; fieldOfView) { m_eyeFieldOfView[eye] = fieldOfView; }
 77 
 78     struct RenderSize {
 79         unsigned width;
 80         unsigned height;
 81     };
 82     const RenderSize&amp; renderSize() const { return m_renderSize; }
 83     void setRenderSize(const RenderSize&amp; renderSize) { m_renderSize = renderSize; }
 84 
 85     void setPlayAreaBounds(const FloatSize&amp; playAreaBounds) { m_playAreaBounds = playAreaBounds; }
 86     const Optional&lt;FloatSize&gt;&amp; playAreaBounds() const { return m_playAreaBounds; }
 87 
 88     void setSittingToStandingTransform(const TransformationMatrix&amp; transform) { m_sittingToStandingTransform = transform; }
 89     const Optional&lt;TransformationMatrix&gt;&amp; sittingToStandingTransform() const { return m_sittingToStandingTransform; }
 90 
 91 private:
 92     String m_displayName;
 93     bool m_isConnected;
 94     bool m_isMounted;
 95     VRDisplayCapabilityFlags m_capabilityFlags;
 96     uint32_t m_displayIdentifier;
 97 
 98     FloatPoint3D m_eyeTranslation[Eye::NumEyes];
 99 
100     RenderSize m_renderSize;
101     FieldOfView m_eyeFieldOfView[Eye::NumEyes];
102 
103     Optional&lt;FloatSize&gt; m_playAreaBounds;
104     Optional&lt;TransformationMatrix&gt; m_sittingToStandingTransform;
105 };
106 
107 struct VRPlatformTrackingInfo {
108     struct Quaternion {
109         Quaternion()
110             : x(0), y(0), z(0), w(1) { }
111 
112         Quaternion(float x, float y, float z, float w)
113             : x(x), y(y), z(z), w(w) { }
114 
115         Quaternion&amp; conjugate()
116         {
117             x *= -1;
118             y *= -1;
119             z *= -1;
120             return *this;
121         }
122 
123         Quaternion&amp; operator*(float factor)
124         {
125             x *= factor;
126             y *= factor;
127             z *= factor;
128             w *= factor;
129             return *this;
130         }
131         float x, y, z, w;
132     };
133 
134     struct Float3 {
135         Float3(float a, float b, float c)
136             : data { a, b, c } { }
137 
138         float data[3];
139     };
140 
141     void clear()
142     {
143         timestamp = 0;
144         position = WTF::nullopt;
145         orientation = WTF::nullopt;
146         angularAcceleration = WTF::nullopt;
147         angularVelocity = WTF::nullopt;
148         linearAcceleration = WTF::nullopt;
149         linearVelocity = WTF::nullopt;
150     }
151 
152     Optional&lt;Quaternion&gt; orientation;
153     Optional&lt;FloatPoint3D&gt; position;
154     Optional&lt;Float3&gt; angularAcceleration;
155     Optional&lt;Float3&gt; angularVelocity;
156     Optional&lt;Float3&gt; linearAcceleration;
157     Optional&lt;Float3&gt; linearVelocity;
158     double timestamp { 0 };
159 };
160 
161 class VRPlatformDisplay : public CanMakeWeakPtr&lt;VRPlatformDisplay&gt; {
162 public:
163     virtual VRPlatformDisplayInfo getDisplayInfo() = 0;
164     virtual VRPlatformTrackingInfo getTrackingInfo() = 0;
165     virtual void updateDisplayInfo() = 0;
166     virtual ~VRPlatformDisplay() = default;
167 
168     void setClient(VRPlatformDisplayClient*);
169 
170     enum class Event {
171         Connected,
172         Disconnected,
173         Mounted,
174         Unmounted,
175     };
176 
177     void notifyVRPlatformDisplayEvent(Event);
178 
179 private:
180     VRPlatformDisplayClient* m_client { nullptr };
181 };
182 
183 }; // namespace WebCore
    </pre>
  </body>
</html>
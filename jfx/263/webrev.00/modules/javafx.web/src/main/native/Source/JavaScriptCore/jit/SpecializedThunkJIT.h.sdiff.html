<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/SpecializedThunkJIT.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SnippetSlowPathCalls.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TempRegisterSet.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/SpecializedThunkJIT.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(JIT)
 29 
 30 #include &quot;JIT.h&quot;
 31 #include &quot;JITInlines.h&quot;
 32 #include &quot;JSInterfaceJIT.h&quot;
 33 #include &quot;LinkBuffer.h&quot;
 34 
 35 namespace JSC {
 36 
 37     class SpecializedThunkJIT : public JSInterfaceJIT {
 38     public:
<span class="line-modified"> 39         static const int ThisArgument = -1;</span>
 40         SpecializedThunkJIT(VM&amp; vm, int expectedArgCount)
 41             : JSInterfaceJIT(&amp;vm)
 42         {
 43             emitFunctionPrologue();
 44             emitSaveThenMaterializeTagRegisters();
 45             // Check that we have the expected number of arguments
<span class="line-modified"> 46             m_failures.append(branch32(NotEqual, payloadFor(CallFrameSlot::argumentCount), TrustedImm32(expectedArgCount + 1)));</span>
 47         }
 48 
 49         explicit SpecializedThunkJIT(VM&amp; vm)
 50             : JSInterfaceJIT(&amp;vm)
 51         {
 52             emitFunctionPrologue();
 53             emitSaveThenMaterializeTagRegisters();
 54         }
 55 
 56         void loadDoubleArgument(int argument, FPRegisterID dst, RegisterID scratch)
 57         {
<span class="line-modified"> 58             unsigned src = CallFrame::argumentOffset(argument);</span>
 59             m_failures.append(emitLoadDouble(src, dst, scratch));
 60         }
 61 
 62         void loadCellArgument(int argument, RegisterID dst)
 63         {
<span class="line-modified"> 64             unsigned src = CallFrame::argumentOffset(argument);</span>
 65             m_failures.append(emitLoadJSCell(src, dst));
 66         }
 67 
 68         void loadJSStringArgument(int argument, RegisterID dst)
 69         {
 70             loadCellArgument(argument, dst);
 71             m_failures.append(branchIfNotString(dst));
 72         }
 73 
 74         void loadInt32Argument(int argument, RegisterID dst, Jump&amp; failTarget)
 75         {
<span class="line-modified"> 76             unsigned src = CallFrame::argumentOffset(argument);</span>
 77             failTarget = emitLoadInt32(src, dst);
 78         }
 79 
 80         void loadInt32Argument(int argument, RegisterID dst)
 81         {
 82             Jump conversionFailed;
 83             loadInt32Argument(argument, dst, conversionFailed);
 84             m_failures.append(conversionFailed);
 85         }
 86 
 87         void appendFailure(const Jump&amp; failure)
 88         {
 89             m_failures.append(failure);
 90         }
 91 #if USE(JSVALUE64)
 92         void returnJSValue(RegisterID src)
 93         {
 94             if (src != regT0)
 95                 move(src, regT0);
 96 
 97             emitRestoreSavedTagRegisters();
 98             emitFunctionEpilogue();
 99             ret();
100         }
101 #else
102         void returnJSValue(RegisterID payload, RegisterID tag)
103         {
104             ASSERT_UNUSED(payload, payload == regT0);
105             ASSERT_UNUSED(tag, tag == regT1);
106             emitRestoreSavedTagRegisters();
107             emitFunctionEpilogue();
108             ret();
109         }
110 #endif
111 
112         void returnDouble(FPRegisterID src)
113         {
114 #if USE(JSVALUE64)
115             moveDoubleTo64(src, regT0);
116             Jump zero = branchTest64(Zero, regT0);
<span class="line-modified">117             sub64(tagTypeNumberRegister, regT0);</span>
118             Jump done = jump();
119             zero.link(this);
<span class="line-modified">120             move(tagTypeNumberRegister, regT0);</span>
121             done.link(this);
122 #else
123             moveDoubleToInts(src, regT0, regT1);
124             Jump lowNonZero = branchTestPtr(NonZero, regT1);
125             Jump highNonZero = branchTestPtr(NonZero, regT0);
126             move(TrustedImm32(0), regT0);
127             move(TrustedImm32(JSValue::Int32Tag), regT1);
128             lowNonZero.link(this);
129             highNonZero.link(this);
130 #endif
131             emitRestoreSavedTagRegisters();
132             emitFunctionEpilogue();
133             ret();
134         }
135 
136         void returnInt32(RegisterID src)
137         {
138             if (src != regT0)
139                 move(src, regT0);
140             tagReturnAsInt32();
</pre>
<hr />
<pre>
165         // Assumes that the target function uses fpRegister0 as the first argument
166         // and return value. Like any sensible architecture would.
167         void callDoubleToDouble(FunctionPtr&lt;CFunctionPtrTag&gt; function)
168         {
169             m_calls.append(std::make_pair(call(JITThunkPtrTag), function.retagged&lt;JITThunkPtrTag&gt;()));
170         }
171 
172         void callDoubleToDoublePreservingReturn(FunctionPtr&lt;CFunctionPtrTag&gt; function)
173         {
174             if (!isX86())
175                 preserveReturnAddressAfterCall(regT3);
176             callDoubleToDouble(function);
177             if (!isX86())
178                 restoreReturnAddressBeforeReturn(regT3);
179         }
180 
181     private:
182         void tagReturnAsInt32()
183         {
184 #if USE(JSVALUE64)
<span class="line-modified">185             or64(tagTypeNumberRegister, regT0);</span>
186 #else
187             move(TrustedImm32(JSValue::Int32Tag), regT1);
188 #endif
189         }
190 
191         void tagReturnAsJSCell()
192         {
193 #if USE(JSVALUE32_64)
194             move(TrustedImm32(JSValue::CellTag), regT1);
195 #endif
196         }
197 
198         MacroAssembler::JumpList m_failures;
199         Vector&lt;std::pair&lt;Call, FunctionPtr&lt;JITThunkPtrTag&gt;&gt;&gt; m_calls;
200     };
201 
202 }
203 
204 #endif // ENABLE(JIT)
</pre>
</td>
<td>
<hr />
<pre>
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(JIT)
 29 
 30 #include &quot;JIT.h&quot;
 31 #include &quot;JITInlines.h&quot;
 32 #include &quot;JSInterfaceJIT.h&quot;
 33 #include &quot;LinkBuffer.h&quot;
 34 
 35 namespace JSC {
 36 
 37     class SpecializedThunkJIT : public JSInterfaceJIT {
 38     public:
<span class="line-modified"> 39         static constexpr int ThisArgument = -1;</span>
 40         SpecializedThunkJIT(VM&amp; vm, int expectedArgCount)
 41             : JSInterfaceJIT(&amp;vm)
 42         {
 43             emitFunctionPrologue();
 44             emitSaveThenMaterializeTagRegisters();
 45             // Check that we have the expected number of arguments
<span class="line-modified"> 46             m_failures.append(branch32(NotEqual, payloadFor(CallFrameSlot::argumentCountIncludingThis), TrustedImm32(expectedArgCount + 1)));</span>
 47         }
 48 
 49         explicit SpecializedThunkJIT(VM&amp; vm)
 50             : JSInterfaceJIT(&amp;vm)
 51         {
 52             emitFunctionPrologue();
 53             emitSaveThenMaterializeTagRegisters();
 54         }
 55 
 56         void loadDoubleArgument(int argument, FPRegisterID dst, RegisterID scratch)
 57         {
<span class="line-modified"> 58             VirtualRegister src = virtualRegisterForArgumentIncludingThis(argument + 1);</span>
 59             m_failures.append(emitLoadDouble(src, dst, scratch));
 60         }
 61 
 62         void loadCellArgument(int argument, RegisterID dst)
 63         {
<span class="line-modified"> 64             VirtualRegister src = virtualRegisterForArgumentIncludingThis(argument + 1);</span>
 65             m_failures.append(emitLoadJSCell(src, dst));
 66         }
 67 
 68         void loadJSStringArgument(int argument, RegisterID dst)
 69         {
 70             loadCellArgument(argument, dst);
 71             m_failures.append(branchIfNotString(dst));
 72         }
 73 
 74         void loadInt32Argument(int argument, RegisterID dst, Jump&amp; failTarget)
 75         {
<span class="line-modified"> 76             VirtualRegister src = virtualRegisterForArgumentIncludingThis(argument + 1);</span>
 77             failTarget = emitLoadInt32(src, dst);
 78         }
 79 
 80         void loadInt32Argument(int argument, RegisterID dst)
 81         {
 82             Jump conversionFailed;
 83             loadInt32Argument(argument, dst, conversionFailed);
 84             m_failures.append(conversionFailed);
 85         }
 86 
 87         void appendFailure(const Jump&amp; failure)
 88         {
 89             m_failures.append(failure);
 90         }
 91 #if USE(JSVALUE64)
 92         void returnJSValue(RegisterID src)
 93         {
 94             if (src != regT0)
 95                 move(src, regT0);
 96 
 97             emitRestoreSavedTagRegisters();
 98             emitFunctionEpilogue();
 99             ret();
100         }
101 #else
102         void returnJSValue(RegisterID payload, RegisterID tag)
103         {
104             ASSERT_UNUSED(payload, payload == regT0);
105             ASSERT_UNUSED(tag, tag == regT1);
106             emitRestoreSavedTagRegisters();
107             emitFunctionEpilogue();
108             ret();
109         }
110 #endif
111 
112         void returnDouble(FPRegisterID src)
113         {
114 #if USE(JSVALUE64)
115             moveDoubleTo64(src, regT0);
116             Jump zero = branchTest64(Zero, regT0);
<span class="line-modified">117             sub64(numberTagRegister, regT0);</span>
118             Jump done = jump();
119             zero.link(this);
<span class="line-modified">120             move(numberTagRegister, regT0);</span>
121             done.link(this);
122 #else
123             moveDoubleToInts(src, regT0, regT1);
124             Jump lowNonZero = branchTestPtr(NonZero, regT1);
125             Jump highNonZero = branchTestPtr(NonZero, regT0);
126             move(TrustedImm32(0), regT0);
127             move(TrustedImm32(JSValue::Int32Tag), regT1);
128             lowNonZero.link(this);
129             highNonZero.link(this);
130 #endif
131             emitRestoreSavedTagRegisters();
132             emitFunctionEpilogue();
133             ret();
134         }
135 
136         void returnInt32(RegisterID src)
137         {
138             if (src != regT0)
139                 move(src, regT0);
140             tagReturnAsInt32();
</pre>
<hr />
<pre>
165         // Assumes that the target function uses fpRegister0 as the first argument
166         // and return value. Like any sensible architecture would.
167         void callDoubleToDouble(FunctionPtr&lt;CFunctionPtrTag&gt; function)
168         {
169             m_calls.append(std::make_pair(call(JITThunkPtrTag), function.retagged&lt;JITThunkPtrTag&gt;()));
170         }
171 
172         void callDoubleToDoublePreservingReturn(FunctionPtr&lt;CFunctionPtrTag&gt; function)
173         {
174             if (!isX86())
175                 preserveReturnAddressAfterCall(regT3);
176             callDoubleToDouble(function);
177             if (!isX86())
178                 restoreReturnAddressBeforeReturn(regT3);
179         }
180 
181     private:
182         void tagReturnAsInt32()
183         {
184 #if USE(JSVALUE64)
<span class="line-modified">185             or64(numberTagRegister, regT0);</span>
186 #else
187             move(TrustedImm32(JSValue::Int32Tag), regT1);
188 #endif
189         }
190 
191         void tagReturnAsJSCell()
192         {
193 #if USE(JSVALUE32_64)
194             move(TrustedImm32(JSValue::CellTag), regT1);
195 #endif
196         }
197 
198         MacroAssembler::JumpList m_failures;
199         Vector&lt;std::pair&lt;Call, FunctionPtr&lt;JITThunkPtrTag&gt;&gt;&gt; m_calls;
200     };
201 
202 }
203 
204 #endif // ENABLE(JIT)
</pre>
</td>
</tr>
</table>
<center><a href="SnippetSlowPathCalls.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TempRegisterSet.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
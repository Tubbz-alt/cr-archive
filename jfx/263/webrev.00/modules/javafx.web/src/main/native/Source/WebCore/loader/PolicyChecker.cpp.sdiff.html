<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/PolicyChecker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PingLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PolicyChecker.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/PolicyChecker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 89 PolicyChecker::PolicyChecker(Frame&amp; frame)
 90     : m_frame(frame)
 91     , m_delegateIsDecidingNavigationPolicy(false)
 92     , m_delegateIsHandlingUnimplementablePolicy(false)
 93     , m_loadType(FrameLoadType::Standard)
 94 {
 95 }
 96 
 97 void PolicyChecker::checkNavigationPolicy(ResourceRequest&amp;&amp; newRequest, const ResourceResponse&amp; redirectResponse, NavigationPolicyDecisionFunction&amp;&amp; function)
 98 {
 99     checkNavigationPolicy(WTFMove(newRequest), redirectResponse, m_frame.loader().activeDocumentLoader(), { }, WTFMove(function));
100 }
101 
102 CompletionHandlerCallingScope PolicyChecker::extendBlobURLLifetimeIfNecessary(ResourceRequest&amp; request) const
103 {
104     if (!request.url().protocolIsBlob())
105         return { };
106 
107     // Create a new temporary blobURL in case this one gets revoked during the asynchronous navigation policy decision.
108     URL temporaryBlobURL = BlobURL::createPublicURL(&amp;m_frame.document()-&gt;securityOrigin());
<span class="line-modified">109     auto sessionID = m_frame.document()-&gt;sessionID();</span>
<span class="line-removed">110     blobRegistry().registerBlobURL(sessionID, temporaryBlobURL, request.url());</span>
111     request.setURL(temporaryBlobURL);
<span class="line-modified">112     return CompletionHandler&lt;void()&gt;([sessionID, temporaryBlobURL = WTFMove(temporaryBlobURL)] {</span>
<span class="line-modified">113         blobRegistry().unregisterBlobURL(sessionID, temporaryBlobURL);</span>
114     });
115 }
116 
117 void PolicyChecker::checkNavigationPolicy(ResourceRequest&amp;&amp; request, const ResourceResponse&amp; redirectResponse, DocumentLoader* loader, RefPtr&lt;FormState&gt;&amp;&amp; formState, NavigationPolicyDecisionFunction&amp;&amp; function, PolicyDecisionMode policyDecisionMode)
118 {
119     NavigationAction action = loader-&gt;triggeringAction();
120     if (action.isEmpty()) {
121         action = NavigationAction { *m_frame.document(), request, InitiatedByMainFrame::Unknown, NavigationType::Other, loader-&gt;shouldOpenExternalURLsPolicyToPropagate() };
122         loader-&gt;setTriggeringAction(NavigationAction { action });
123     }
124 
125     if (m_frame.page() &amp;&amp; m_frame.page()-&gt;openedByDOMWithOpener())
126         action.setOpenedByDOMWithOpener();
127     action.setHasOpenedFrames(m_frame.loader().hasOpenedFrames());
128 
129     // Don&#39;t ask more than once for the same request or if we are loading an empty URL.
130     // This avoids confusion on the part of the client.
131     if (equalIgnoringHeaderFields(request, loader-&gt;lastCheckedRequest()) || (!request.isNull() &amp;&amp; request.url().isEmpty())) {
132         function(ResourceRequest(request), { }, NavigationPolicyDecision::ContinueLoad);
133         loader-&gt;setLastCheckedRequest(WTFMove(request));
</pre>
<hr />
<pre>
143         shouldContinue = ContentFilter::continueAfterSubstituteDataRequest(*m_frame.loader().activeDocumentLoader(), substituteData);
144 #endif
145         if (isBackForwardLoadType(m_loadType))
146             m_loadType = FrameLoadType::Reload;
147         function(WTFMove(request), { }, shouldContinue ? NavigationPolicyDecision::ContinueLoad : NavigationPolicyDecision::IgnoreLoad);
148         return;
149     }
150 
151     if (!isAllowedByContentSecurityPolicy(request.url(), m_frame.ownerElement(), !redirectResponse.isNull())) {
152         if (m_frame.ownerElement()) {
153             // Fire a load event (even though we were blocked by CSP) as timing attacks would otherwise
154             // reveal that the frame was blocked. This way, it looks like any other cross-origin page load.
155             m_frame.ownerElement()-&gt;dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));
156         }
157         function(WTFMove(request), { }, NavigationPolicyDecision::IgnoreLoad);
158         return;
159     }
160 
161     loader-&gt;setLastCheckedRequest(ResourceRequest(request));
162 
<span class="line-removed">163     // Initial &#39;about:blank&#39; load needs to happen synchronously so the policy check needs to be synchronous in this case.</span>
<span class="line-removed">164     if (!m_frame.loader().stateMachine().committedFirstRealDocumentLoad() &amp;&amp; request.url().protocolIsAbout() &amp;&amp; !substituteData.isValid())</span>
<span class="line-removed">165         policyDecisionMode = PolicyDecisionMode::Synchronous;</span>
<span class="line-removed">166 </span>
167 #if USE(QUICK_LOOK)
168     // Always allow QuickLook-generated URLs based on the protocol scheme.
169     if (!request.isNull() &amp;&amp; isQuickLookPreviewURL(request.url()))
170         return function(WTFMove(request), makeWeakPtr(formState.get()), NavigationPolicyDecision::ContinueLoad);
171 #endif
172 
173 #if ENABLE(CONTENT_FILTERING)
174     if (m_contentFilterUnblockHandler.canHandleRequest(request)) {
175         RefPtr&lt;Frame&gt; frame { &amp;m_frame };
176         m_contentFilterUnblockHandler.requestUnblockAsync([frame](bool unblocked) {
177             if (unblocked)
178                 frame-&gt;loader().reload();
179         });
180         return function({ }, nullptr, NavigationPolicyDecision::IgnoreLoad);
181     }
182     m_contentFilterUnblockHandler = { };
183 #endif
184 
185     m_frame.loader().clearProvisionalLoadForPolicyCheck();
186 
187     auto blobURLLifetimeExtension = policyDecisionMode == PolicyDecisionMode::Asynchronous ? extendBlobURLLifetimeIfNecessary(request) : CompletionHandlerCallingScope { };
188 

189     auto requestIdentifier = PolicyCheckIdentifier::create();
190     m_delegateIsDecidingNavigationPolicy = true;
191     String suggestedFilename = action.downloadAttribute().isEmpty() ? nullAtom() : action.downloadAttribute();
<span class="line-modified">192     m_frame.loader().client().dispatchDecidePolicyForNavigationAction(action, request, redirectResponse, formState.get(), policyDecisionMode, requestIdentifier,</span>
<span class="line-removed">193         [this, function = WTFMove(function), request = ResourceRequest(request), formState = WTFMove(formState), suggestedFilename = WTFMove(suggestedFilename),</span>
194          blobURLLifetimeExtension = WTFMove(blobURLLifetimeExtension), requestIdentifier] (PolicyAction policyAction, PolicyCheckIdentifier responseIdentifier) mutable {
<span class="line-removed">195 </span>
196         if (!responseIdentifier.isValidFor(requestIdentifier))
197             return function({ }, nullptr, NavigationPolicyDecision::IgnoreLoad);
198 
199         m_delegateIsDecidingNavigationPolicy = false;
200 
201         switch (policyAction) {
202         case PolicyAction::Download:
203             m_frame.loader().setOriginalURLForDownloadRequest(request);
204             m_frame.loader().client().startDownload(request, suggestedFilename);
205             FALLTHROUGH;
206         case PolicyAction::Ignore:
207             return function({ }, nullptr, NavigationPolicyDecision::IgnoreLoad);
208         case PolicyAction::StopAllLoads:
209             function({ }, nullptr, NavigationPolicyDecision::StopAllLoads);
210             return;
211         case PolicyAction::Use:
212             if (!m_frame.loader().client().canHandleRequest(request)) {
213                 handleUnimplementablePolicy(m_frame.loader().client().cannotShowURLError(request));
214                 return function({ }, { }, NavigationPolicyDecision::IgnoreLoad);
215             }
216             return function(WTFMove(request), makeWeakPtr(formState.get()), NavigationPolicyDecision::ContinueLoad);
217         }
218         ASSERT_NOT_REACHED();
<span class="line-modified">219     });</span>







220 }
221 
222 void PolicyChecker::checkNewWindowPolicy(NavigationAction&amp;&amp; navigationAction, ResourceRequest&amp;&amp; request, RefPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, NewWindowPolicyDecisionFunction&amp;&amp; function)
223 {
224     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;isSandboxed(SandboxPopups))
225         return function({ }, nullptr, { }, { }, ShouldContinue::No);
226 
227     if (!DOMWindow::allowPopUp(m_frame))
228         return function({ }, nullptr, { }, { }, ShouldContinue::No);
229 
230     auto blobURLLifetimeExtension = extendBlobURLLifetimeIfNecessary(request);
231 
232     auto requestIdentifier = PolicyCheckIdentifier::create();
233     m_frame.loader().client().dispatchDecidePolicyForNewWindowAction(navigationAction, request, formState.get(), frameName, requestIdentifier, [frame = makeRef(m_frame), request,
234         formState = WTFMove(formState), frameName, navigationAction, function = WTFMove(function), blobURLLifetimeExtension = WTFMove(blobURLLifetimeExtension),
235         requestIdentifier] (PolicyAction policyAction, PolicyCheckIdentifier responseIdentifier) mutable {
236 
237         if (!responseIdentifier.isValidFor(requestIdentifier))
238             return function({ }, nullptr, { }, { }, ShouldContinue::No);
239 
</pre>
</td>
<td>
<hr />
<pre>
 89 PolicyChecker::PolicyChecker(Frame&amp; frame)
 90     : m_frame(frame)
 91     , m_delegateIsDecidingNavigationPolicy(false)
 92     , m_delegateIsHandlingUnimplementablePolicy(false)
 93     , m_loadType(FrameLoadType::Standard)
 94 {
 95 }
 96 
 97 void PolicyChecker::checkNavigationPolicy(ResourceRequest&amp;&amp; newRequest, const ResourceResponse&amp; redirectResponse, NavigationPolicyDecisionFunction&amp;&amp; function)
 98 {
 99     checkNavigationPolicy(WTFMove(newRequest), redirectResponse, m_frame.loader().activeDocumentLoader(), { }, WTFMove(function));
100 }
101 
102 CompletionHandlerCallingScope PolicyChecker::extendBlobURLLifetimeIfNecessary(ResourceRequest&amp; request) const
103 {
104     if (!request.url().protocolIsBlob())
105         return { };
106 
107     // Create a new temporary blobURL in case this one gets revoked during the asynchronous navigation policy decision.
108     URL temporaryBlobURL = BlobURL::createPublicURL(&amp;m_frame.document()-&gt;securityOrigin());
<span class="line-modified">109     blobRegistry().registerBlobURL(temporaryBlobURL, request.url());</span>

110     request.setURL(temporaryBlobURL);
<span class="line-modified">111     return CompletionHandler&lt;void()&gt;([temporaryBlobURL = WTFMove(temporaryBlobURL)] {</span>
<span class="line-modified">112         blobRegistry().unregisterBlobURL(temporaryBlobURL);</span>
113     });
114 }
115 
116 void PolicyChecker::checkNavigationPolicy(ResourceRequest&amp;&amp; request, const ResourceResponse&amp; redirectResponse, DocumentLoader* loader, RefPtr&lt;FormState&gt;&amp;&amp; formState, NavigationPolicyDecisionFunction&amp;&amp; function, PolicyDecisionMode policyDecisionMode)
117 {
118     NavigationAction action = loader-&gt;triggeringAction();
119     if (action.isEmpty()) {
120         action = NavigationAction { *m_frame.document(), request, InitiatedByMainFrame::Unknown, NavigationType::Other, loader-&gt;shouldOpenExternalURLsPolicyToPropagate() };
121         loader-&gt;setTriggeringAction(NavigationAction { action });
122     }
123 
124     if (m_frame.page() &amp;&amp; m_frame.page()-&gt;openedByDOMWithOpener())
125         action.setOpenedByDOMWithOpener();
126     action.setHasOpenedFrames(m_frame.loader().hasOpenedFrames());
127 
128     // Don&#39;t ask more than once for the same request or if we are loading an empty URL.
129     // This avoids confusion on the part of the client.
130     if (equalIgnoringHeaderFields(request, loader-&gt;lastCheckedRequest()) || (!request.isNull() &amp;&amp; request.url().isEmpty())) {
131         function(ResourceRequest(request), { }, NavigationPolicyDecision::ContinueLoad);
132         loader-&gt;setLastCheckedRequest(WTFMove(request));
</pre>
<hr />
<pre>
142         shouldContinue = ContentFilter::continueAfterSubstituteDataRequest(*m_frame.loader().activeDocumentLoader(), substituteData);
143 #endif
144         if (isBackForwardLoadType(m_loadType))
145             m_loadType = FrameLoadType::Reload;
146         function(WTFMove(request), { }, shouldContinue ? NavigationPolicyDecision::ContinueLoad : NavigationPolicyDecision::IgnoreLoad);
147         return;
148     }
149 
150     if (!isAllowedByContentSecurityPolicy(request.url(), m_frame.ownerElement(), !redirectResponse.isNull())) {
151         if (m_frame.ownerElement()) {
152             // Fire a load event (even though we were blocked by CSP) as timing attacks would otherwise
153             // reveal that the frame was blocked. This way, it looks like any other cross-origin page load.
154             m_frame.ownerElement()-&gt;dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));
155         }
156         function(WTFMove(request), { }, NavigationPolicyDecision::IgnoreLoad);
157         return;
158     }
159 
160     loader-&gt;setLastCheckedRequest(ResourceRequest(request));
161 




162 #if USE(QUICK_LOOK)
163     // Always allow QuickLook-generated URLs based on the protocol scheme.
164     if (!request.isNull() &amp;&amp; isQuickLookPreviewURL(request.url()))
165         return function(WTFMove(request), makeWeakPtr(formState.get()), NavigationPolicyDecision::ContinueLoad);
166 #endif
167 
168 #if ENABLE(CONTENT_FILTERING)
169     if (m_contentFilterUnblockHandler.canHandleRequest(request)) {
170         RefPtr&lt;Frame&gt; frame { &amp;m_frame };
171         m_contentFilterUnblockHandler.requestUnblockAsync([frame](bool unblocked) {
172             if (unblocked)
173                 frame-&gt;loader().reload();
174         });
175         return function({ }, nullptr, NavigationPolicyDecision::IgnoreLoad);
176     }
177     m_contentFilterUnblockHandler = { };
178 #endif
179 
180     m_frame.loader().clearProvisionalLoadForPolicyCheck();
181 
182     auto blobURLLifetimeExtension = policyDecisionMode == PolicyDecisionMode::Asynchronous ? extendBlobURLLifetimeIfNecessary(request) : CompletionHandlerCallingScope { };
183 
<span class="line-added">184     bool isInitialEmptyDocumentLoad = !m_frame.loader().stateMachine().committedFirstRealDocumentLoad() &amp;&amp; request.url().protocolIsAbout() &amp;&amp; !substituteData.isValid();</span>
185     auto requestIdentifier = PolicyCheckIdentifier::create();
186     m_delegateIsDecidingNavigationPolicy = true;
187     String suggestedFilename = action.downloadAttribute().isEmpty() ? nullAtom() : action.downloadAttribute();
<span class="line-modified">188     FramePolicyFunction decisionHandler = [this, function = WTFMove(function), request = ResourceRequest(request), formState = WTFMove(formState), suggestedFilename = WTFMove(suggestedFilename),</span>

189          blobURLLifetimeExtension = WTFMove(blobURLLifetimeExtension), requestIdentifier] (PolicyAction policyAction, PolicyCheckIdentifier responseIdentifier) mutable {

190         if (!responseIdentifier.isValidFor(requestIdentifier))
191             return function({ }, nullptr, NavigationPolicyDecision::IgnoreLoad);
192 
193         m_delegateIsDecidingNavigationPolicy = false;
194 
195         switch (policyAction) {
196         case PolicyAction::Download:
197             m_frame.loader().setOriginalURLForDownloadRequest(request);
198             m_frame.loader().client().startDownload(request, suggestedFilename);
199             FALLTHROUGH;
200         case PolicyAction::Ignore:
201             return function({ }, nullptr, NavigationPolicyDecision::IgnoreLoad);
202         case PolicyAction::StopAllLoads:
203             function({ }, nullptr, NavigationPolicyDecision::StopAllLoads);
204             return;
205         case PolicyAction::Use:
206             if (!m_frame.loader().client().canHandleRequest(request)) {
207                 handleUnimplementablePolicy(m_frame.loader().client().cannotShowURLError(request));
208                 return function({ }, { }, NavigationPolicyDecision::IgnoreLoad);
209             }
210             return function(WTFMove(request), makeWeakPtr(formState.get()), NavigationPolicyDecision::ContinueLoad);
211         }
212         ASSERT_NOT_REACHED();
<span class="line-modified">213     };</span>
<span class="line-added">214 </span>
<span class="line-added">215     if (isInitialEmptyDocumentLoad) {</span>
<span class="line-added">216         // We ignore the response from the client for initial empty document loads and proceed with the load synchronously.</span>
<span class="line-added">217         m_frame.loader().client().dispatchDecidePolicyForNavigationAction(action, request, redirectResponse, formState.get(), policyDecisionMode, requestIdentifier, [](PolicyAction, PolicyCheckIdentifier) { });</span>
<span class="line-added">218         decisionHandler(PolicyAction::Use, requestIdentifier);</span>
<span class="line-added">219     } else</span>
<span class="line-added">220         m_frame.loader().client().dispatchDecidePolicyForNavigationAction(action, request, redirectResponse, formState.get(), policyDecisionMode, requestIdentifier, WTFMove(decisionHandler));</span>
221 }
222 
223 void PolicyChecker::checkNewWindowPolicy(NavigationAction&amp;&amp; navigationAction, ResourceRequest&amp;&amp; request, RefPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, NewWindowPolicyDecisionFunction&amp;&amp; function)
224 {
225     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;isSandboxed(SandboxPopups))
226         return function({ }, nullptr, { }, { }, ShouldContinue::No);
227 
228     if (!DOMWindow::allowPopUp(m_frame))
229         return function({ }, nullptr, { }, { }, ShouldContinue::No);
230 
231     auto blobURLLifetimeExtension = extendBlobURLLifetimeIfNecessary(request);
232 
233     auto requestIdentifier = PolicyCheckIdentifier::create();
234     m_frame.loader().client().dispatchDecidePolicyForNewWindowAction(navigationAction, request, formState.get(), frameName, requestIdentifier, [frame = makeRef(m_frame), request,
235         formState = WTFMove(formState), frameName, navigationAction, function = WTFMove(function), blobURLLifetimeExtension = WTFMove(blobURLLifetimeExtension),
236         requestIdentifier] (PolicyAction policyAction, PolicyCheckIdentifier responseIdentifier) mutable {
237 
238         if (!responseIdentifier.isValidFor(requestIdentifier))
239             return function({ }, nullptr, { }, { }, ShouldContinue::No);
240 
</pre>
</td>
</tr>
</table>
<center><a href="PingLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PolicyChecker.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/testing/Internals.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2012 Google Inc. All rights reserved.
   3  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  *
  15  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  17  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  18  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  19  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  20  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  21  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  22  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  24  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;Internals.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;ActivityState.h&quot;
  32 #include &quot;AnimationTimeline.h&quot;
  33 #include &quot;ApplicationCacheStorage.h&quot;
  34 #include &quot;AudioSession.h&quot;
  35 #include &quot;Autofill.h&quot;
  36 #include &quot;BackForwardCache.h&quot;
  37 #include &quot;BackForwardController.h&quot;
  38 #include &quot;BitmapImage.h&quot;
  39 #include &quot;CSSAnimationController.h&quot;
  40 #include &quot;CSSKeyframesRule.h&quot;
  41 #include &quot;CSSMediaRule.h&quot;
  42 #include &quot;CSSPropertyParser.h&quot;
  43 #include &quot;CSSStyleRule.h&quot;
  44 #include &quot;CSSSupportsRule.h&quot;
  45 #include &quot;CacheStorageConnection.h&quot;
  46 #include &quot;CacheStorageProvider.h&quot;
  47 #include &quot;CachedImage.h&quot;
  48 #include &quot;CachedResourceLoader.h&quot;
  49 #include &quot;CertificateInfo.h&quot;
  50 #include &quot;Chrome.h&quot;
  51 #include &quot;ChromeClient.h&quot;
  52 #include &quot;ClientOrigin.h&quot;
  53 #include &quot;ComposedTreeIterator.h&quot;
  54 #include &quot;CookieJar.h&quot;
  55 #include &quot;Cursor.h&quot;
  56 #include &quot;CustomHeaderFields.h&quot;
  57 #include &quot;DOMRect.h&quot;
  58 #include &quot;DOMRectList.h&quot;
  59 #include &quot;DOMStringList.h&quot;
  60 #include &quot;DOMWindow.h&quot;
  61 #include &quot;DeprecatedGlobalSettings.h&quot;
  62 #include &quot;DiagnosticLoggingClient.h&quot;
  63 #include &quot;DisabledAdaptations.h&quot;
  64 #include &quot;DisplayList.h&quot;
  65 #include &quot;Document.h&quot;
  66 #include &quot;DocumentLoader.h&quot;
  67 #include &quot;DocumentMarkerController.h&quot;
  68 #include &quot;DocumentTimeline.h&quot;
  69 #include &quot;Editor.h&quot;
  70 #include &quot;Element.h&quot;
  71 #include &quot;EventHandler.h&quot;
  72 #include &quot;EventListener.h&quot;
  73 #include &quot;EventLoop.h&quot;
  74 #include &quot;EventNames.h&quot;
  75 #include &quot;ExtendableEvent.h&quot;
  76 #include &quot;ExtensionStyleSheets.h&quot;
  77 #include &quot;FetchResponse.h&quot;
  78 #include &quot;File.h&quot;
  79 #include &quot;FontCache.h&quot;
  80 #include &quot;FormController.h&quot;
  81 #include &quot;Frame.h&quot;
  82 #include &quot;FrameLoader.h&quot;
  83 #include &quot;FrameLoaderClient.h&quot;
  84 #include &quot;FrameView.h&quot;
  85 #include &quot;FullscreenManager.h&quot;
  86 #include &quot;GCObservation.h&quot;
  87 #include &quot;GridPosition.h&quot;
  88 #include &quot;HEVCUtilities.h&quot;
  89 #include &quot;HTMLAnchorElement.h&quot;
  90 #include &quot;HTMLCanvasElement.h&quot;
  91 #include &quot;HTMLIFrameElement.h&quot;
  92 #include &quot;HTMLImageElement.h&quot;
  93 #include &quot;HTMLInputElement.h&quot;
  94 #include &quot;HTMLLinkElement.h&quot;
  95 #include &quot;HTMLNames.h&quot;
  96 #include &quot;HTMLPictureElement.h&quot;
  97 #include &quot;HTMLPlugInElement.h&quot;
  98 #include &quot;HTMLPreloadScanner.h&quot;
  99 #include &quot;HTMLSelectElement.h&quot;
 100 #include &quot;HTMLTextAreaElement.h&quot;
 101 #include &quot;HTMLVideoElement.h&quot;
 102 #include &quot;HistoryController.h&quot;
 103 #include &quot;HistoryItem.h&quot;
 104 #include &quot;HitTestResult.h&quot;
 105 #include &quot;InspectorClient.h&quot;
 106 #include &quot;InspectorController.h&quot;
 107 #include &quot;InspectorDebuggableType.h&quot;
 108 #include &quot;InspectorFrontendClientLocal.h&quot;
 109 #include &quot;InspectorOverlay.h&quot;
 110 #include &quot;InstrumentingAgents.h&quot;
 111 #include &quot;IntRect.h&quot;
 112 #include &quot;InternalSettings.h&quot;
 113 #include &quot;InternalsMapLike.h&quot;
 114 #include &quot;InternalsSetLike.h&quot;
 115 #include &quot;JSDOMPromiseDeferred.h&quot;
 116 #include &quot;JSImageData.h&quot;
 117 #include &quot;LegacySchemeRegistry.h&quot;
 118 #include &quot;LibWebRTCProvider.h&quot;
 119 #include &quot;LoaderStrategy.h&quot;
 120 #include &quot;Location.h&quot;
 121 #include &quot;MIMETypeRegistry.h&quot;
 122 #include &quot;MallocStatistics.h&quot;
 123 #include &quot;MediaDevices.h&quot;
 124 #include &quot;MediaEngineConfigurationFactory.h&quot;
 125 #include &quot;MediaPlayer.h&quot;
 126 #include &quot;MediaProducer.h&quot;
 127 #include &quot;MediaRecorderProvider.h&quot;
 128 #include &quot;MediaResourceLoader.h&quot;
 129 #include &quot;MediaStreamTrack.h&quot;
 130 #include &quot;MemoryCache.h&quot;
 131 #include &quot;MemoryInfo.h&quot;
 132 #include &quot;MockAudioDestinationCocoa.h&quot;
 133 #include &quot;MockLibWebRTCPeerConnection.h&quot;
 134 #include &quot;MockPageOverlay.h&quot;
 135 #include &quot;MockPageOverlayClient.h&quot;
 136 #include &quot;NavigatorMediaDevices.h&quot;
 137 #include &quot;NetworkLoadInformation.h&quot;
 138 #include &quot;Page.h&quot;
 139 #include &quot;PageOverlay.h&quot;
 140 #include &quot;PathUtilities.h&quot;
 141 #include &quot;PlatformKeyboardEvent.h&quot;
 142 #include &quot;PlatformMediaSessionManager.h&quot;
 143 #include &quot;PlatformScreen.h&quot;
 144 #include &quot;PlatformStrategies.h&quot;
 145 #include &quot;PluginData.h&quot;
 146 #include &quot;PrintContext.h&quot;
 147 #include &quot;PseudoElement.h&quot;
 148 #include &quot;Range.h&quot;
 149 #include &quot;ReadableStream.h&quot;
 150 #include &quot;RenderEmbeddedObject.h&quot;
 151 #include &quot;RenderLayerBacking.h&quot;
 152 #include &quot;RenderLayerCompositor.h&quot;
 153 #include &quot;RenderMenuList.h&quot;
 154 #include &quot;RenderTheme.h&quot;
 155 #include &quot;RenderTreeAsText.h&quot;
 156 #include &quot;RenderView.h&quot;
 157 #include &quot;RenderedDocumentMarker.h&quot;
 158 #include &quot;ResourceLoadObserver.h&quot;
 159 #include &quot;RuntimeEnabledFeatures.h&quot;
 160 #include &quot;SMILTimeContainer.h&quot;
 161 #include &quot;SVGDocumentExtensions.h&quot;
 162 #include &quot;SVGPathStringBuilder.h&quot;
 163 #include &quot;SVGSVGElement.h&quot;
 164 #include &quot;SWClientConnection.h&quot;
 165 #include &quot;ScriptController.h&quot;
 166 #include &quot;ScriptedAnimationController.h&quot;
 167 #include &quot;ScrollingCoordinator.h&quot;
 168 #include &quot;ScrollingMomentumCalculator.h&quot;
 169 #include &quot;SecurityOrigin.h&quot;
 170 #include &quot;SerializedScriptValue.h&quot;
 171 #include &quot;ServiceWorker.h&quot;
 172 #include &quot;ServiceWorkerProvider.h&quot;
 173 #include &quot;ServiceWorkerRegistrationData.h&quot;
 174 #include &quot;Settings.h&quot;
 175 #include &quot;ShadowRoot.h&quot;
 176 #include &quot;SourceBuffer.h&quot;
 177 #include &quot;SpellChecker.h&quot;
 178 #include &quot;StaticNodeList.h&quot;
 179 #include &quot;StorageNamespace.h&quot;
 180 #include &quot;StorageNamespaceProvider.h&quot;
 181 #include &quot;StringCallback.h&quot;
 182 #include &quot;StyleResolver.h&quot;
 183 #include &quot;StyleRule.h&quot;
 184 #include &quot;StyleScope.h&quot;
 185 #include &quot;StyleSheetContents.h&quot;
 186 #include &quot;TextIterator.h&quot;
 187 #include &quot;TreeScope.h&quot;
 188 #include &quot;TypeConversions.h&quot;
 189 #include &quot;UserGestureIndicator.h&quot;
 190 #include &quot;UserMediaController.h&quot;
 191 #include &quot;ViewportArguments.h&quot;
 192 #include &quot;VoidCallback.h&quot;
 193 #include &quot;WebCoreJSClientData.h&quot;
 194 #include &quot;WindowProxy.h&quot;
 195 #include &quot;WorkerThread.h&quot;
 196 #include &quot;WorkletGlobalScope.h&quot;
 197 #include &quot;WritingDirection.h&quot;
 198 #include &quot;XMLHttpRequest.h&quot;
 199 #include &lt;JavaScriptCore/CodeBlock.h&gt;
 200 #include &lt;JavaScriptCore/InspectorAgentBase.h&gt;
 201 #include &lt;JavaScriptCore/InspectorFrontendChannel.h&gt;
 202 #include &lt;JavaScriptCore/JSCInlines.h&gt;
 203 #include &lt;JavaScriptCore/JSCJSValue.h&gt;
 204 #include &lt;wtf/HexNumber.h&gt;
 205 #include &lt;wtf/JSONValues.h&gt;
 206 #include &lt;wtf/Language.h&gt;
 207 #include &lt;wtf/MemoryPressureHandler.h&gt;
 208 #include &lt;wtf/MonotonicTime.h&gt;
 209 #include &lt;wtf/ProcessID.h&gt;
 210 #include &lt;wtf/URLHelpers.h&gt;
 211 #include &lt;wtf/text/StringBuilder.h&gt;
 212 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 213 
 214 #if USE(CG)
 215 #include &quot;PDFDocumentImage.h&quot;
 216 #endif
 217 
 218 #if ENABLE(INPUT_TYPE_COLOR)
 219 #include &quot;ColorChooser.h&quot;
 220 #endif
 221 
 222 #if ENABLE(MOUSE_CURSOR_SCALE)
 223 #include &lt;wtf/dtoa.h&gt;
 224 #endif
 225 
 226 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 227 #include &quot;LegacyCDM.h&quot;
 228 #include &quot;LegacyMockCDM.h&quot;
 229 #endif
 230 
 231 #if ENABLE(ENCRYPTED_MEDIA)
 232 #include &quot;MockCDMFactory.h&quot;
 233 #endif
 234 
 235 #if ENABLE(VIDEO_TRACK)
 236 #include &quot;CaptionUserPreferences.h&quot;
 237 #include &quot;PageGroup.h&quot;
 238 #include &quot;TextTrackCueGeneric.h&quot;
 239 #endif
 240 
 241 #if ENABLE(VIDEO)
 242 #include &quot;HTMLMediaElement.h&quot;
 243 #include &quot;TimeRanges.h&quot;
 244 #endif
 245 
 246 #if ENABLE(WEBGL)
 247 #include &quot;WebGLRenderingContext.h&quot;
 248 #endif
 249 
 250 #if ENABLE(SPEECH_SYNTHESIS)
 251 #include &quot;DOMWindowSpeechSynthesis.h&quot;
 252 #include &quot;PlatformSpeechSynthesizerMock.h&quot;
 253 #include &quot;SpeechSynthesis.h&quot;
 254 #endif
 255 
 256 #if ENABLE(MEDIA_STREAM)
 257 #include &quot;MediaRecorder.h&quot;
 258 #include &quot;MediaRecorderPrivateMock.h&quot;
 259 #include &quot;MediaStream.h&quot;
 260 #include &quot;MockRealtimeMediaSourceCenter.h&quot;
 261 #endif
 262 
 263 #if ENABLE(WEB_RTC)
 264 #include &quot;RTCPeerConnection.h&quot;
 265 #endif
 266 
 267 #if ENABLE(MEDIA_SOURCE)
 268 #include &quot;MockMediaPlayerMediaSource.h&quot;
 269 #endif
 270 
 271 #if ENABLE(CONTENT_FILTERING)
 272 #include &quot;MockContentFilterSettings.h&quot;
 273 #endif
 274 
 275 #if ENABLE(WEB_AUDIO)
 276 #include &quot;AudioContext.h&quot;
 277 #endif
 278 
 279 #if ENABLE(MEDIA_SESSION)
 280 #include &quot;MediaSession.h&quot;
 281 #include &quot;MediaSessionManager.h&quot;
 282 #endif
 283 
 284 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 285 #include &quot;MediaPlaybackTargetContext.h&quot;
 286 #endif
 287 
 288 #if ENABLE(POINTER_LOCK)
 289 #include &quot;PointerLockController.h&quot;
 290 #endif
 291 
 292 #if ENABLE(INDEXED_DATABASE)
 293 #include &quot;IDBRequest.h&quot;
 294 #include &quot;IDBTransaction.h&quot;
 295 #endif
 296 
 297 #if USE(QUICK_LOOK)
 298 #include &quot;LegacyPreviewLoader.h&quot;
 299 #include &quot;MockPreviewLoaderClient.h&quot;
 300 #endif
 301 
 302 #if ENABLE(APPLE_PAY)
 303 #include &quot;MockPaymentCoordinator.h&quot;
 304 #include &quot;PaymentCoordinator.h&quot;
 305 #endif
 306 
 307 #if PLATFORM(MAC) &amp;&amp; USE(LIBWEBRTC)
 308 #include &lt;webrtc/sdk/WebKit/VideoProcessingSoftLink.h&gt;
 309 #endif
 310 
 311 #if PLATFORM(MAC)
 312 #include &quot;GraphicsContextGLOpenGLManager.h&quot;
 313 #endif
 314 
 315 #if PLATFORM(COCOA)
 316 #include &quot;SystemBattery.h&quot;
 317 #include &lt;wtf/spi/darwin/SandboxSPI.h&gt;
 318 #endif
 319 
 320 using JSC::CallData;
 321 using JSC::CallType;
 322 using JSC::CodeBlock;
 323 using JSC::FunctionExecutable;
 324 using JSC::Identifier;
 325 using JSC::JSFunction;
 326 using JSC::JSGlobalObject;
 327 using JSC::JSObject;
 328 using JSC::JSValue;
 329 using JSC::MarkedArgumentBuffer;
 330 using JSC::PropertySlot;
 331 using JSC::ScriptExecutable;
 332 using JSC::StackVisitor;
 333 
 334 
 335 namespace WebCore {
 336 using namespace Inspector;
 337 
 338 using namespace HTMLNames;
 339 
 340 class InspectorStubFrontend final : public InspectorFrontendClientLocal, public FrontendChannel {
 341 public:
 342     InspectorStubFrontend(Page&amp; inspectedPage, RefPtr&lt;DOMWindow&gt;&amp;&amp; frontendWindow);
 343     virtual ~InspectorStubFrontend();
 344 
 345 private:
 346     void attachWindow(DockSide) final { }
 347     void detachWindow() final { }
 348     void closeWindow() final;
 349     void reopen() final { }
 350     void bringToFront() final { }
 351     String localizedStringsURL() const final { return String(); }
 352     DebuggableType debuggableType() const final { return DebuggableType::Page; }
 353     String targetPlatformName() const { return &quot;Unknown&quot;_s; }
 354     String targetBuildVersion() const { return &quot;Unknown&quot;_s; }
 355     String targetProductVersion() const { return &quot;Unknown&quot;_s; }
 356     bool targetIsSimulator() const { return false; }
 357     void inspectedURLChanged(const String&amp;) final { }
 358     void showCertificate(const CertificateInfo&amp;) final { }
 359     void setAttachedWindowHeight(unsigned) final { }
 360     void setAttachedWindowWidth(unsigned) final { }
 361     void setSheetRect(const FloatRect&amp;) final { }
 362 
 363     void sendMessageToFrontend(const String&amp; message) final;
 364     ConnectionType connectionType() const final { return ConnectionType::Local; }
 365 
 366     RefPtr&lt;DOMWindow&gt; m_frontendWindow;
 367 };
 368 
 369 InspectorStubFrontend::InspectorStubFrontend(Page&amp; inspectedPage, RefPtr&lt;DOMWindow&gt;&amp;&amp; frontendWindow)
 370     : InspectorFrontendClientLocal(&amp;inspectedPage.inspectorController(), frontendWindow-&gt;document()-&gt;page(), makeUnique&lt;InspectorFrontendClientLocal::Settings&gt;())
 371     , m_frontendWindow(frontendWindow.copyRef())
 372 {
 373     ASSERT_ARG(frontendWindow, frontendWindow);
 374 
 375     frontendPage()-&gt;inspectorController().setInspectorFrontendClient(this);
 376     inspectedPage.inspectorController().connectFrontend(*this);
 377 }
 378 
 379 InspectorStubFrontend::~InspectorStubFrontend()
 380 {
 381     closeWindow();
 382 }
 383 
 384 void InspectorStubFrontend::closeWindow()
 385 {
 386     if (!m_frontendWindow)
 387         return;
 388 
 389     frontendPage()-&gt;inspectorController().setInspectorFrontendClient(nullptr);
 390     inspectedPage()-&gt;inspectorController().disconnectFrontend(*this);
 391 
 392     m_frontendWindow-&gt;close();
 393     m_frontendWindow = nullptr;
 394 }
 395 
 396 void InspectorStubFrontend::sendMessageToFrontend(const String&amp; message)
 397 {
 398     dispatchMessageAsync(message);
 399 }
 400 
 401 static bool markerTypeFrom(const String&amp; markerType, DocumentMarker::MarkerType&amp; result)
 402 {
 403     if (equalLettersIgnoringASCIICase(markerType, &quot;spelling&quot;))
 404         result = DocumentMarker::Spelling;
 405     else if (equalLettersIgnoringASCIICase(markerType, &quot;grammar&quot;))
 406         result = DocumentMarker::Grammar;
 407     else if (equalLettersIgnoringASCIICase(markerType, &quot;textmatch&quot;))
 408         result = DocumentMarker::TextMatch;
 409     else if (equalLettersIgnoringASCIICase(markerType, &quot;replacement&quot;))
 410         result = DocumentMarker::Replacement;
 411     else if (equalLettersIgnoringASCIICase(markerType, &quot;correctionindicator&quot;))
 412         result = DocumentMarker::CorrectionIndicator;
 413     else if (equalLettersIgnoringASCIICase(markerType, &quot;rejectedcorrection&quot;))
 414         result = DocumentMarker::RejectedCorrection;
 415     else if (equalLettersIgnoringASCIICase(markerType, &quot;autocorrected&quot;))
 416         result = DocumentMarker::Autocorrected;
 417     else if (equalLettersIgnoringASCIICase(markerType, &quot;spellcheckingexemption&quot;))
 418         result = DocumentMarker::SpellCheckingExemption;
 419     else if (equalLettersIgnoringASCIICase(markerType, &quot;deletedautocorrection&quot;))
 420         result = DocumentMarker::DeletedAutocorrection;
 421     else if (equalLettersIgnoringASCIICase(markerType, &quot;dictationalternatives&quot;))
 422         result = DocumentMarker::DictationAlternatives;
 423 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
 424     else if (equalLettersIgnoringASCIICase(markerType, &quot;telephonenumber&quot;))
 425         result = DocumentMarker::TelephoneNumber;
 426 #endif
 427     else
 428         return false;
 429 
 430     return true;
 431 }
 432 
 433 static bool markerTypesFrom(const String&amp; markerType, OptionSet&lt;DocumentMarker::MarkerType&gt;&amp; result)
 434 {
 435     DocumentMarker::MarkerType singularResult;
 436 
 437     if (markerType.isEmpty() || equalLettersIgnoringASCIICase(markerType, &quot;all&quot;))
 438         result = DocumentMarker::allMarkers();
 439     else if (markerTypeFrom(markerType, singularResult))
 440         result = singularResult;
 441     else
 442         return false;
 443 
 444     return true;
 445 }
 446 
 447 static std::unique_ptr&lt;PrintContext&gt;&amp; printContextForTesting()
 448 {
 449     static NeverDestroyed&lt;std::unique_ptr&lt;PrintContext&gt;&gt; context;
 450     return context;
 451 }
 452 
 453 const char* Internals::internalsId = &quot;internals&quot;;
 454 
 455 Ref&lt;Internals&gt; Internals::create(Document&amp; document)
 456 {
 457     return adoptRef(*new Internals(document));
 458 }
 459 
 460 Internals::~Internals()
 461 {
 462 #if ENABLE(MEDIA_STREAM)
 463     if (m_track)
 464         m_track-&gt;source().removeObserver(*this);
 465 #endif
 466 }
 467 
 468 void Internals::resetToConsistentState(Page&amp; page)
 469 {
 470     page.setPageScaleFactor(1, IntPoint(0, 0));
 471     page.setPagination(Pagination());
 472     page.setPaginationLineGridEnabled(false);
 473 
 474     page.setDefersLoading(false);
 475 
 476     page.mainFrame().setTextZoomFactor(1.0f);
 477 
 478     page.setCompositingPolicyOverride(WebCore::CompositingPolicy::Normal);
 479 
 480     FrameView* mainFrameView = page.mainFrame().view();
 481     if (mainFrameView) {
 482         page.setHeaderHeight(0);
 483         page.setFooterHeight(0);
 484         page.setTopContentInset(0);
 485         mainFrameView-&gt;setUseFixedLayout(false);
 486         mainFrameView-&gt;setFixedLayoutSize(IntSize());
 487         mainFrameView-&gt;enableAutoSizeMode(false, { });
 488 #if USE(COORDINATED_GRAPHICS)
 489         mainFrameView-&gt;setFixedVisibleContentRect(IntRect());
 490 #endif
 491         if (auto* backing = mainFrameView-&gt;tiledBacking())
 492             backing-&gt;setTileSizeUpdateDelayDisabledForTesting(false);
 493     }
 494 
 495     WTF::clearDefaultPortForProtocolMapForTesting();
 496     overrideUserPreferredLanguages(Vector&lt;String&gt;());
 497     WebCore::DeprecatedGlobalSettings::setUsesOverlayScrollbars(false);
 498     WebCore::DeprecatedGlobalSettings::setUsesMockScrollAnimator(false);
 499 #if ENABLE(VIDEO_TRACK)
 500     page.group().captionPreferences().setTestingMode(true);
 501     page.group().captionPreferences().setCaptionsStyleSheetOverride(emptyString());
 502     page.group().captionPreferences().setTestingMode(false);
 503 #endif
 504     if (!page.mainFrame().editor().isContinuousSpellCheckingEnabled())
 505         page.mainFrame().editor().toggleContinuousSpellChecking();
 506     if (page.mainFrame().editor().isOverwriteModeEnabled())
 507         page.mainFrame().editor().toggleOverwriteModeEnabled();
 508     page.mainFrame().loader().clearTestingOverrides();
 509     page.applicationCacheStorage().setDefaultOriginQuota(ApplicationCacheStorage::noQuota());
 510 #if ENABLE(VIDEO)
 511     PlatformMediaSessionManager::sharedManager().resetRestrictions();
 512     PlatformMediaSessionManager::sharedManager().setWillIgnoreSystemInterruptions(true);
 513 #endif
 514 #if ENABLE(VIDEO) || ENABLE(WEB_AUDIO)
 515     PlatformMediaSessionManager::sharedManager().setIsPlayingToAutomotiveHeadUnit(false);
 516 #endif
 517 #if ENABLE(ACCESSIBILITY)
 518     AXObjectCache::setEnhancedUserInterfaceAccessibility(false);
 519     AXObjectCache::disableAccessibility();
 520 #endif
 521 
 522     MockPageOverlayClient::singleton().uninstallAllOverlays();
 523 
 524 #if ENABLE(CONTENT_FILTERING)
 525     MockContentFilterSettings::reset();
 526 #endif
 527 
 528 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 529     page.setMockMediaPlaybackTargetPickerEnabled(true);
 530     page.setMockMediaPlaybackTargetPickerState(emptyString(), MediaPlaybackTargetContext::Unknown);
 531 #endif
 532 
 533     page.setShowAllPlugins(false);
 534     page.setLowPowerModeEnabledOverrideForTesting(WTF::nullopt);
 535 
 536 #if USE(QUICK_LOOK)
 537     MockPreviewLoaderClient::singleton().setPassword(&quot;&quot;);
 538     LegacyPreviewLoader::setClientForTesting(nullptr);
 539 #endif
 540 
 541     printContextForTesting() = nullptr;
 542 
 543 #if USE(LIBWEBRTC)
 544     auto&amp; rtcProvider = page.libWebRTCProvider();
 545     WebCore::useRealRTCPeerConnectionFactory(rtcProvider);
 546     rtcProvider.disableNonLocalhostConnections();
 547     RuntimeEnabledFeatures::sharedFeatures().setWebRTCVP8CodecEnabled(true);
 548     page.settings().setWebRTCEncryptionEnabled(true);
 549     rtcProvider.setUseGPUProcess(false);
 550 #endif
 551 
 552     page.settings().setStorageAccessAPIEnabled(false);
 553     page.setFullscreenAutoHideDuration(0_s);
 554     page.setFullscreenInsets({ });
 555     page.setFullscreenControlsHidden(false);
 556 
 557     MediaEngineConfigurationFactory::disableMock();
 558 
 559 #if ENABLE(MEDIA_STREAM)
 560     RuntimeEnabledFeatures::sharedFeatures().setInterruptAudioOnPageVisibilityChangeEnabled(false);
 561     WebCore::MediaRecorder::setCustomPrivateRecorderCreator(nullptr);
 562     page.mediaRecorderProvider().setUseGPUProcess(true);
 563 #endif
 564 
 565     HTMLCanvasElement::setMaxPixelMemoryForTesting(0); // This means use the default value.
 566     DOMWindow::overrideTransientActivationDurationForTesting(WTF::nullopt);
 567 }
 568 
 569 Internals::Internals(Document&amp; document)
 570     : ContextDestructionObserver(&amp;document)
 571 #if ENABLE(MEDIA_STREAM)
 572     , m_orientationNotifier(0)
 573 #endif
 574 {
 575 #if ENABLE(VIDEO_TRACK)
 576     if (document.page())
 577         document.page()-&gt;group().captionPreferences().setTestingMode(true);
 578 #endif
 579 
 580 #if ENABLE(MEDIA_STREAM)
 581     setMediaCaptureRequiresSecureConnection(false);
 582 #endif
 583 
 584 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 585     if (document.page())
 586         document.page()-&gt;setMockMediaPlaybackTargetPickerEnabled(true);
 587 #endif
 588 
 589     if (contextDocument() &amp;&amp; contextDocument()-&gt;frame()) {
 590         setAutomaticSpellingCorrectionEnabled(true);
 591         setAutomaticQuoteSubstitutionEnabled(false);
 592         setAutomaticDashSubstitutionEnabled(false);
 593         setAutomaticLinkDetectionEnabled(false);
 594         setAutomaticTextReplacementEnabled(true);
 595     }
 596 
 597     setConsoleMessageListener(nullptr);
 598 
 599 #if ENABLE(APPLE_PAY)
 600     auto* frame = document.frame();
 601     if (frame &amp;&amp; frame-&gt;page() &amp;&amp; frame-&gt;isMainFrame()) {
 602         auto mockPaymentCoordinator = new MockPaymentCoordinator(*frame-&gt;page());
 603         frame-&gt;page()-&gt;setPaymentCoordinator(makeUnique&lt;PaymentCoordinator&gt;(*mockPaymentCoordinator));
 604     }
 605 #endif
 606 
 607 #if PLATFORM(COCOA) &amp;&amp;  ENABLE(WEB_AUDIO)
 608     AudioDestinationCocoa::createOverride = nullptr;
 609 #endif
 610 }
 611 
 612 Document* Internals::contextDocument() const
 613 {
 614     return downcast&lt;Document&gt;(scriptExecutionContext());
 615 }
 616 
 617 Frame* Internals::frame() const
 618 {
 619     if (!contextDocument())
 620         return nullptr;
 621     return contextDocument()-&gt;frame();
 622 }
 623 
 624 InternalSettings* Internals::settings() const
 625 {
 626     Document* document = contextDocument();
 627     if (!document)
 628         return nullptr;
 629     Page* page = document-&gt;page();
 630     if (!page)
 631         return nullptr;
 632     return InternalSettings::from(page);
 633 }
 634 
 635 unsigned Internals::workerThreadCount() const
 636 {
 637     return WorkerThread::workerThreadCount();
 638 }
 639 
 640 ExceptionOr&lt;bool&gt; Internals::areSVGAnimationsPaused() const
 641 {
 642     auto* document = contextDocument();
 643     if (!document)
 644         return Exception { InvalidAccessError, &quot;No context document&quot;_s };
 645 
 646     if (!document-&gt;svgExtensions())
 647         return Exception { NotFoundError, &quot;No SVG animations&quot;_s };
 648 
 649     return document-&gt;accessSVGExtensions().areAnimationsPaused();
 650 }
 651 
 652 ExceptionOr&lt;double&gt; Internals::svgAnimationsInterval(SVGSVGElement&amp; element) const
 653 {
 654     auto* document = contextDocument();
 655     if (!document)
 656         return 0;
 657 
 658     if (!document-&gt;svgExtensions())
 659         return 0;
 660 
 661     if (document-&gt;accessSVGExtensions().areAnimationsPaused())
 662         return 0;
 663 
 664     return element.timeContainer().animationFrameDelay().value();
 665 }
 666 
 667 String Internals::address(Node&amp; node)
 668 {
 669     return makeString(&quot;0x&quot;, hex(reinterpret_cast&lt;uintptr_t&gt;(&amp;node)));
 670 }
 671 
 672 bool Internals::nodeNeedsStyleRecalc(Node&amp; node)
 673 {
 674     return node.needsStyleRecalc();
 675 }
 676 
 677 static String styleValidityToToString(Style::Validity validity)
 678 {
 679     switch (validity) {
 680     case Style::Validity::Valid:
 681         return &quot;NoStyleChange&quot;;
 682     case Style::Validity::ElementInvalid:
 683         return &quot;InlineStyleChange&quot;;
 684     case Style::Validity::SubtreeInvalid:
 685         return &quot;FullStyleChange&quot;;
 686     case Style::Validity::SubtreeAndRenderersInvalid:
 687         return &quot;ReconstructRenderTree&quot;;
 688     }
 689     ASSERT_NOT_REACHED();
 690     return &quot;&quot;;
 691 }
 692 
 693 String Internals::styleChangeType(Node&amp; node)
 694 {
 695     node.document().styleScope().flushPendingUpdate();
 696 
 697     return styleValidityToToString(node.styleValidity());
 698 }
 699 
 700 String Internals::description(JSC::JSValue value)
 701 {
 702     return toString(value);
 703 }
 704 
 705 bool Internals::isPreloaded(const String&amp; url)
 706 {
 707     Document* document = contextDocument();
 708     return document-&gt;cachedResourceLoader().isPreloaded(url);
 709 }
 710 
 711 bool Internals::isLoadingFromMemoryCache(const String&amp; url)
 712 {
 713     if (!contextDocument() || !contextDocument()-&gt;page())
 714         return false;
 715 
 716     ResourceRequest request(contextDocument()-&gt;completeURL(url));
 717     request.setDomainForCachePartition(contextDocument()-&gt;domainForCachePartition());
 718 
 719     CachedResource* resource = MemoryCache::singleton().resourceForRequest(request, contextDocument()-&gt;page()-&gt;sessionID());
 720     return resource &amp;&amp; resource-&gt;status() == CachedResource::Cached;
 721 }
 722 
 723 static String responseSourceToString(const ResourceResponse&amp; response)
 724 {
 725     if (response.isNull())
 726         return &quot;Null response&quot;;
 727     switch (response.source()) {
 728     case ResourceResponse::Source::Unknown:
 729         return &quot;Unknown&quot;;
 730     case ResourceResponse::Source::Network:
 731         return &quot;Network&quot;;
 732     case ResourceResponse::Source::ServiceWorker:
 733         return &quot;Service worker&quot;;
 734     case ResourceResponse::Source::DiskCache:
 735         return &quot;Disk cache&quot;;
 736     case ResourceResponse::Source::DiskCacheAfterValidation:
 737         return &quot;Disk cache after validation&quot;;
 738     case ResourceResponse::Source::MemoryCache:
 739         return &quot;Memory cache&quot;;
 740     case ResourceResponse::Source::MemoryCacheAfterValidation:
 741         return &quot;Memory cache after validation&quot;;
 742     case ResourceResponse::Source::ApplicationCache:
 743         return &quot;Application cache&quot;;
 744     case ResourceResponse::Source::DOMCache:
 745         return &quot;DOM cache&quot;;
 746     case ResourceResponse::Source::InspectorOverride:
 747         return &quot;Inspector override&quot;;
 748     }
 749     ASSERT_NOT_REACHED();
 750     return &quot;Error&quot;;
 751 }
 752 
 753 String Internals::xhrResponseSource(XMLHttpRequest&amp; request)
 754 {
 755     return responseSourceToString(request.resourceResponse());
 756 }
 757 
 758 String Internals::fetchResponseSource(FetchResponse&amp; response)
 759 {
 760     return responseSourceToString(response.resourceResponse());
 761 }
 762 
 763 bool Internals::isSharingStyleSheetContents(HTMLLinkElement&amp; a, HTMLLinkElement&amp; b)
 764 {
 765     if (!a.sheet() || !b.sheet())
 766         return false;
 767     return &amp;a.sheet()-&gt;contents() == &amp;b.sheet()-&gt;contents();
 768 }
 769 
 770 bool Internals::isStyleSheetLoadingSubresources(HTMLLinkElement&amp; link)
 771 {
 772     return link.sheet() &amp;&amp; link.sheet()-&gt;contents().isLoadingSubresources();
 773 }
 774 
 775 static ResourceRequestCachePolicy toResourceRequestCachePolicy(Internals::CachePolicy policy)
 776 {
 777     switch (policy) {
 778     case Internals::CachePolicy::UseProtocolCachePolicy:
 779         return ResourceRequestCachePolicy::UseProtocolCachePolicy;
 780     case Internals::CachePolicy::ReloadIgnoringCacheData:
 781         return ResourceRequestCachePolicy::ReloadIgnoringCacheData;
 782     case Internals::CachePolicy::ReturnCacheDataElseLoad:
 783         return ResourceRequestCachePolicy::ReturnCacheDataElseLoad;
 784     case Internals::CachePolicy::ReturnCacheDataDontLoad:
 785         return ResourceRequestCachePolicy::ReturnCacheDataDontLoad;
 786     }
 787     ASSERT_NOT_REACHED();
 788     return ResourceRequestCachePolicy::UseProtocolCachePolicy;
 789 }
 790 
 791 void Internals::setOverrideCachePolicy(CachePolicy policy)
 792 {
 793     frame()-&gt;loader().setOverrideCachePolicyForTesting(toResourceRequestCachePolicy(policy));
 794 }
 795 
 796 ExceptionOr&lt;void&gt; Internals::setCanShowModalDialogOverride(bool allow)
 797 {
 798     if (!contextDocument() || !contextDocument()-&gt;domWindow())
 799         return Exception { InvalidAccessError };
 800 
 801     contextDocument()-&gt;domWindow()-&gt;setCanShowModalDialogOverride(allow);
 802     return { };
 803 }
 804 
 805 static ResourceLoadPriority toResourceLoadPriority(Internals::ResourceLoadPriority priority)
 806 {
 807     switch (priority) {
 808     case Internals::ResourceLoadPriority::ResourceLoadPriorityVeryLow:
 809         return ResourceLoadPriority::VeryLow;
 810     case Internals::ResourceLoadPriority::ResourceLoadPriorityLow:
 811         return ResourceLoadPriority::Low;
 812     case Internals::ResourceLoadPriority::ResourceLoadPriorityMedium:
 813         return ResourceLoadPriority::Medium;
 814     case Internals::ResourceLoadPriority::ResourceLoadPriorityHigh:
 815         return ResourceLoadPriority::High;
 816     case Internals::ResourceLoadPriority::ResourceLoadPriorityVeryHigh:
 817         return ResourceLoadPriority::VeryHigh;
 818     }
 819     ASSERT_NOT_REACHED();
 820     return ResourceLoadPriority::Low;
 821 }
 822 
 823 void Internals::setOverrideResourceLoadPriority(ResourceLoadPriority priority)
 824 {
 825     frame()-&gt;loader().setOverrideResourceLoadPriorityForTesting(toResourceLoadPriority(priority));
 826 }
 827 
 828 void Internals::setStrictRawResourceValidationPolicyDisabled(bool disabled)
 829 {
 830     frame()-&gt;loader().setStrictRawResourceValidationPolicyDisabledForTesting(disabled);
 831 }
 832 
 833 void Internals::clearMemoryCache()
 834 {
 835     MemoryCache::singleton().evictResources();
 836 }
 837 
 838 void Internals::pruneMemoryCacheToSize(unsigned size)
 839 {
 840     MemoryCache::singleton().pruneDeadResourcesToSize(size);
 841     MemoryCache::singleton().pruneLiveResourcesToSize(size, true);
 842 }
 843 
 844 void Internals::destroyDecodedDataForAllImages()
 845 {
 846     MemoryCache::singleton().destroyDecodedDataForAllImages();
 847 }
 848 
 849 unsigned Internals::memoryCacheSize() const
 850 {
 851     return MemoryCache::singleton().size();
 852 }
 853 
 854 static Image* imageFromImageElement(HTMLImageElement&amp; element)
 855 {
 856     auto* cachedImage = element.cachedImage();
 857     return cachedImage ? cachedImage-&gt;image() : nullptr;
 858 }
 859 
 860 static BitmapImage* bitmapImageFromImageElement(HTMLImageElement&amp; element)
 861 {
 862     auto* image = imageFromImageElement(element);
 863     return image &amp;&amp; is&lt;BitmapImage&gt;(image) ? &amp;downcast&lt;BitmapImage&gt;(*image) : nullptr;
 864 }
 865 
 866 #if USE(CG)
 867 static PDFDocumentImage* pdfDocumentImageFromImageElement(HTMLImageElement&amp; element)
 868 {
 869     auto* image = imageFromImageElement(element);
 870     return image &amp;&amp; is&lt;PDFDocumentImage&gt;(image) ? &amp;downcast&lt;PDFDocumentImage&gt;(*image) : nullptr;
 871 }
 872 #endif
 873 
 874 unsigned Internals::imageFrameIndex(HTMLImageElement&amp; element)
 875 {
 876     auto* bitmapImage = bitmapImageFromImageElement(element);
 877     return bitmapImage ? bitmapImage-&gt;currentFrame() : 0;
 878 }
 879 
 880 unsigned Internals::imageFrameCount(HTMLImageElement&amp; element)
 881 {
 882     auto* bitmapImage = bitmapImageFromImageElement(element);
 883     return bitmapImage ? bitmapImage-&gt;frameCount() : 0;
 884 }
 885 
 886 float Internals::imageFrameDurationAtIndex(HTMLImageElement&amp; element, unsigned index)
 887 {
 888     auto* bitmapImage = bitmapImageFromImageElement(element);
 889     return bitmapImage ? bitmapImage-&gt;frameDurationAtIndex(index).value() : 0;
 890 }
 891 
 892 void Internals::setImageFrameDecodingDuration(HTMLImageElement&amp; element, float duration)
 893 {
 894     if (auto* bitmapImage = bitmapImageFromImageElement(element))
 895         bitmapImage-&gt;setFrameDecodingDurationForTesting(Seconds { duration });
 896 }
 897 
 898 void Internals::resetImageAnimation(HTMLImageElement&amp; element)
 899 {
 900     if (auto* image = imageFromImageElement(element))
 901         image-&gt;resetAnimation();
 902 }
 903 
 904 bool Internals::isImageAnimating(HTMLImageElement&amp; element)
 905 {
 906     auto* image = imageFromImageElement(element);
 907     return image &amp;&amp; (image-&gt;isAnimating() || image-&gt;animationPending());
 908 }
 909 
 910 unsigned Internals::imagePendingDecodePromisesCountForTesting(HTMLImageElement&amp; element)
 911 {
 912     return element.pendingDecodePromisesCountForTesting();
 913 }
 914 
 915 void Internals::setClearDecoderAfterAsyncFrameRequestForTesting(HTMLImageElement&amp; element, bool enabled)
 916 {
 917     if (auto* bitmapImage = bitmapImageFromImageElement(element))
 918         bitmapImage-&gt;setClearDecoderAfterAsyncFrameRequestForTesting(enabled);
 919 }
 920 
 921 unsigned Internals::imageDecodeCount(HTMLImageElement&amp; element)
 922 {
 923     auto* bitmapImage = bitmapImageFromImageElement(element);
 924     return bitmapImage ? bitmapImage-&gt;decodeCountForTesting() : 0;
 925 }
 926 
 927 unsigned Internals::pdfDocumentCachingCount(HTMLImageElement&amp; element)
 928 {
 929 #if USE(CG)
 930     auto* pdfDocumentImage = pdfDocumentImageFromImageElement(element);
 931     return pdfDocumentImage ? pdfDocumentImage-&gt;cachingCountForTesting() : 0;
 932 #else
 933     UNUSED_PARAM(element);
 934     return 0;
 935 #endif
 936 }
 937 
 938 void Internals::setLargeImageAsyncDecodingEnabledForTesting(HTMLImageElement&amp; element, bool enabled)
 939 {
 940     if (auto* bitmapImage = bitmapImageFromImageElement(element))
 941         bitmapImage-&gt;setLargeImageAsyncDecodingEnabledForTesting(enabled);
 942 }
 943 
 944 void Internals::setForceUpdateImageDataEnabledForTesting(HTMLImageElement&amp; element, bool enabled)
 945 {
 946     if (auto* cachedImage = element.cachedImage())
 947         cachedImage-&gt;setForceUpdateImageDataEnabledForTesting(enabled);
 948 }
 949 
 950 void Internals::setGridMaxTracksLimit(unsigned maxTrackLimit)
 951 {
 952     GridPosition::setMaxPositionForTesting(maxTrackLimit);
 953 }
 954 
 955 void Internals::clearBackForwardCache()
 956 {
 957     BackForwardCache::singleton().pruneToSizeNow(0, PruningReason::None);
 958 }
 959 
 960 unsigned Internals::backForwardCacheSize() const
 961 {
 962     return BackForwardCache::singleton().pageCount();
 963 }
 964 
 965 void Internals::preventDocumentFromEnteringBackForwardCache()
 966 {
 967     if (auto* document = contextDocument())
 968         document-&gt;preventEnteringBackForwardCacheForTesting();
 969 }
 970 
 971 void Internals::disableTileSizeUpdateDelay()
 972 {
 973     Document* document = contextDocument();
 974     if (!document || !document-&gt;frame())
 975         return;
 976 
 977     auto* view = document-&gt;frame()-&gt;view();
 978     if (!view)
 979         return;
 980 
 981     if (auto* backing = view-&gt;tiledBacking())
 982         backing-&gt;setTileSizeUpdateDelayDisabledForTesting(true);
 983 }
 984 
 985 void Internals::setSpeculativeTilingDelayDisabledForTesting(bool disabled)
 986 {
 987     Document* document = contextDocument();
 988     if (!document || !document-&gt;frame())
 989         return;
 990 
 991     if (auto* frameView = document-&gt;frame()-&gt;view())
 992         frameView-&gt;setSpeculativeTilingDelayDisabledForTesting(disabled);
 993 }
 994 
 995 
 996 Node* Internals::treeScopeRootNode(Node&amp; node)
 997 {
 998     return &amp;node.treeScope().rootNode();
 999 }
1000 
1001 Node* Internals::parentTreeScope(Node&amp; node)
1002 {
1003     const TreeScope* parentTreeScope = node.treeScope().parentTreeScope();
1004     return parentTreeScope ? &amp;parentTreeScope-&gt;rootNode() : nullptr;
1005 }
1006 
1007 ExceptionOr&lt;unsigned&gt; Internals::lastSpatialNavigationCandidateCount() const
1008 {
1009     if (!contextDocument() || !contextDocument()-&gt;page())
1010         return Exception { InvalidAccessError };
1011 
1012     return contextDocument()-&gt;page()-&gt;lastSpatialNavigationCandidateCount();
1013 }
1014 
1015 unsigned Internals::numberOfActiveAnimations() const
1016 {
1017     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
1018         return frame()-&gt;document()-&gt;timeline().numberOfActiveAnimationsForTesting();
1019     return frame()-&gt;animation().numberOfActiveAnimations(frame()-&gt;document());
1020 }
1021 
1022 ExceptionOr&lt;bool&gt; Internals::animationsAreSuspended() const
1023 {
1024     Document* document = contextDocument();
1025     if (!document || !document-&gt;frame())
1026         return Exception { InvalidAccessError };
1027 
1028     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
1029         return document-&gt;timeline().animationsAreSuspended();
1030     return document-&gt;frame()-&gt;animation().animationsAreSuspendedForDocument(document);
1031 }
1032 
1033 double Internals::animationsInterval() const
1034 {
1035     Document* document = contextDocument();
1036     if (!document)
1037         return INFINITY;
1038 
1039     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1040         if (auto timeline = document-&gt;existingTimeline())
1041             return timeline-&gt;animationInterval().seconds();
1042         return INFINITY;
1043     }
1044 
1045     if (!document-&gt;frame())
1046         return INFINITY;
1047     return document-&gt;frame()-&gt;animation().animationInterval().value();
1048 }
1049 
1050 ExceptionOr&lt;void&gt; Internals::suspendAnimations() const
1051 {
1052     Document* document = contextDocument();
1053     if (!document || !document-&gt;frame())
1054         return Exception { InvalidAccessError };
1055 
1056     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1057         document-&gt;timeline().suspendAnimations();
1058         for (Frame* frame = document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
1059             if (Document* document = frame-&gt;document())
1060                 document-&gt;timeline().suspendAnimations();
1061         }
1062     } else {
1063         document-&gt;frame()-&gt;animation().suspendAnimationsForDocument(document);
1064 
1065         for (Frame* frame = document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
1066             if (Document* document = frame-&gt;document())
1067                 frame-&gt;animation().suspendAnimationsForDocument(document);
1068         }
1069     }
1070 
1071     return { };
1072 }
1073 
1074 ExceptionOr&lt;void&gt; Internals::resumeAnimations() const
1075 {
1076     Document* document = contextDocument();
1077     if (!document || !document-&gt;frame())
1078         return Exception { InvalidAccessError };
1079 
1080     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1081         document-&gt;timeline().resumeAnimations();
1082         for (Frame* frame = document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
1083             if (Document* document = frame-&gt;document())
1084                 document-&gt;timeline().resumeAnimations();
1085         }
1086     } else {
1087         document-&gt;frame()-&gt;animation().resumeAnimationsForDocument(document);
1088 
1089         for (Frame* frame = document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
1090             if (Document* document = frame-&gt;document())
1091                 frame-&gt;animation().resumeAnimationsForDocument(document);
1092         }
1093     }
1094 
1095     return { };
1096 }
1097 
1098 ExceptionOr&lt;bool&gt; Internals::pauseAnimationAtTimeOnElement(const String&amp; animationName, double pauseTime, Element&amp; element)
1099 {
1100     if (pauseTime &lt; 0)
1101         return Exception { InvalidAccessError };
1102     return frame()-&gt;animation().pauseAnimationAtTime(element, AtomString(animationName), pauseTime);
1103 }
1104 
1105 ExceptionOr&lt;bool&gt; Internals::pauseAnimationAtTimeOnPseudoElement(const String&amp; animationName, double pauseTime, Element&amp; element, const String&amp; pseudoId)
1106 {
1107     if (pauseTime &lt; 0)
1108         return Exception { InvalidAccessError };
1109 
1110     if (pseudoId != &quot;before&quot; &amp;&amp; pseudoId != &quot;after&quot;)
1111         return Exception { InvalidAccessError };
1112 
1113     PseudoElement* pseudoElement = pseudoId == &quot;before&quot; ? element.beforePseudoElement() : element.afterPseudoElement();
1114     if (!pseudoElement)
1115         return Exception { InvalidAccessError };
1116 
1117     return frame()-&gt;animation().pauseAnimationAtTime(*pseudoElement, AtomString(animationName), pauseTime);
1118 }
1119 
1120 ExceptionOr&lt;bool&gt; Internals::pauseTransitionAtTimeOnElement(const String&amp; propertyName, double pauseTime, Element&amp; element)
1121 {
1122     if (pauseTime &lt; 0)
1123         return Exception { InvalidAccessError };
1124     return frame()-&gt;animation().pauseTransitionAtTime(element, propertyName, pauseTime);
1125 }
1126 
1127 ExceptionOr&lt;bool&gt; Internals::pauseTransitionAtTimeOnPseudoElement(const String&amp; property, double pauseTime, Element&amp; element, const String&amp; pseudoId)
1128 {
1129     if (pauseTime &lt; 0)
1130         return Exception { InvalidAccessError };
1131 
1132     if (pseudoId != &quot;before&quot; &amp;&amp; pseudoId != &quot;after&quot;)
1133         return Exception { InvalidAccessError };
1134 
1135     PseudoElement* pseudoElement = pseudoId == &quot;before&quot; ? element.beforePseudoElement() : element.afterPseudoElement();
1136     if (!pseudoElement)
1137         return Exception { InvalidAccessError };
1138 
1139     return frame()-&gt;animation().pauseTransitionAtTime(*pseudoElement, property, pauseTime);
1140 }
1141 
1142 Vector&lt;Internals::AcceleratedAnimation&gt; Internals::acceleratedAnimationsForElement(Element&amp; element)
1143 {
1144     if (!RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
1145         return { };
1146 
1147     Vector&lt;Internals::AcceleratedAnimation&gt; animations;
1148     for (const auto&amp; animationAsPair : element.document().timeline().acceleratedAnimationsForElement(element))
1149         animations.append({ animationAsPair.first, animationAsPair.second });
1150     return animations;
1151 }
1152 
1153 unsigned Internals::numberOfAnimationTimelineInvalidations() const
1154 {
1155     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
1156         return frame()-&gt;document()-&gt;timeline().numberOfAnimationTimelineInvalidationsForTesting();
1157     return 0;
1158 }
1159 
1160 ExceptionOr&lt;RefPtr&lt;Element&gt;&gt; Internals::pseudoElement(Element&amp; element, const String&amp; pseudoId)
1161 {
1162     if (pseudoId != &quot;before&quot; &amp;&amp; pseudoId != &quot;after&quot;)
1163         return Exception { InvalidAccessError };
1164 
1165     return pseudoId == &quot;before&quot; ? element.beforePseudoElement() : element.afterPseudoElement();
1166 }
1167 
1168 ExceptionOr&lt;String&gt; Internals::elementRenderTreeAsText(Element&amp; element)
1169 {
1170     element.document().updateStyleIfNeeded();
1171 
1172     String representation = externalRepresentation(&amp;element);
1173     if (representation.isEmpty())
1174         return Exception { InvalidAccessError };
1175 
1176     return representation;
1177 }
1178 
1179 bool Internals::hasPausedImageAnimations(Element&amp; element)
1180 {
1181     return element.renderer() &amp;&amp; element.renderer()-&gt;hasPausedImageAnimations();
1182 }
1183 
1184 bool Internals::isPaintingFrequently(Element&amp; element)
1185 {
1186     return element.renderer() &amp;&amp; element.renderer()-&gt;enclosingLayer() &amp;&amp; element.renderer()-&gt;enclosingLayer()-&gt;paintingFrequently();
1187 }
1188 
1189 void Internals::incrementFrequentPaintCounter(Element&amp; element)
1190 {
1191     if (element.renderer() &amp;&amp; element.renderer()-&gt;enclosingLayer())
1192         element.renderer()-&gt;enclosingLayer()-&gt;simulateFrequentPaint();
1193 }
1194 
1195 Ref&lt;CSSComputedStyleDeclaration&gt; Internals::computedStyleIncludingVisitedInfo(Element&amp; element) const
1196 {
1197     bool allowVisitedStyle = true;
1198     return CSSComputedStyleDeclaration::create(element, allowVisitedStyle);
1199 }
1200 
1201 Node* Internals::ensureUserAgentShadowRoot(Element&amp; host)
1202 {
1203     return &amp;host.ensureUserAgentShadowRoot();
1204 }
1205 
1206 Node* Internals::shadowRoot(Element&amp; host)
1207 {
1208     return host.shadowRoot();
1209 }
1210 
1211 ExceptionOr&lt;String&gt; Internals::shadowRootType(const Node&amp; root) const
1212 {
1213     if (!is&lt;ShadowRoot&gt;(root))
1214         return Exception { InvalidAccessError };
1215 
1216     switch (downcast&lt;ShadowRoot&gt;(root).mode()) {
1217     case ShadowRootMode::UserAgent:
1218         return &quot;UserAgentShadowRoot&quot;_str;
1219     case ShadowRootMode::Closed:
1220         return &quot;ClosedShadowRoot&quot;_str;
1221     case ShadowRootMode::Open:
1222         return &quot;OpenShadowRoot&quot;_str;
1223     default:
1224         ASSERT_NOT_REACHED();
1225         return &quot;Unknown&quot;_str;
1226     }
1227 }
1228 
1229 String Internals::shadowPseudoId(Element&amp; element)
1230 {
1231     return element.shadowPseudoId().string();
1232 }
1233 
1234 void Internals::setShadowPseudoId(Element&amp; element, const String&amp; id)
1235 {
1236     return element.setPseudo(id);
1237 }
1238 
1239 static unsigned deferredStyleRulesCountForList(const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; childRules)
1240 {
1241     unsigned count = 0;
1242     for (auto rule : childRules) {
1243         if (is&lt;StyleRule&gt;(rule)) {
1244             auto* cssRule = downcast&lt;StyleRule&gt;(rule.get());
1245             if (!cssRule-&gt;propertiesWithoutDeferredParsing())
1246                 count++;
1247             continue;
1248         }
1249 
1250         StyleRuleGroup* groupRule = nullptr;
1251         if (is&lt;StyleRuleMedia&gt;(rule))
1252             groupRule = downcast&lt;StyleRuleMedia&gt;(rule.get());
1253         else if (is&lt;StyleRuleSupports&gt;(rule))
1254             groupRule = downcast&lt;StyleRuleSupports&gt;(rule.get());
1255         if (!groupRule)
1256             continue;
1257 
1258         auto* groupChildRules = groupRule-&gt;childRulesWithoutDeferredParsing();
1259         if (!groupChildRules)
1260             continue;
1261 
1262         count += deferredStyleRulesCountForList(*groupChildRules);
1263     }
1264 
1265     return count;
1266 }
1267 
1268 unsigned Internals::deferredStyleRulesCount(StyleSheet&amp; styleSheet)
1269 {
1270     return deferredStyleRulesCountForList(downcast&lt;CSSStyleSheet&gt;(styleSheet).contents().childRules());
1271 }
1272 
1273 static unsigned deferredGroupRulesCountForList(const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; childRules)
1274 {
1275     unsigned count = 0;
1276     for (auto rule : childRules) {
1277         StyleRuleGroup* groupRule = nullptr;
1278         if (is&lt;StyleRuleMedia&gt;(rule))
1279             groupRule = downcast&lt;StyleRuleMedia&gt;(rule.get());
1280         else if (is&lt;StyleRuleSupports&gt;(rule))
1281             groupRule = downcast&lt;StyleRuleSupports&gt;(rule.get());
1282         if (!groupRule)
1283             continue;
1284 
1285         auto* groupChildRules = groupRule-&gt;childRulesWithoutDeferredParsing();
1286         if (!groupChildRules)
1287             count++;
1288         else
1289             count += deferredGroupRulesCountForList(*groupChildRules);
1290     }
1291     return count;
1292 }
1293 
1294 unsigned Internals::deferredGroupRulesCount(StyleSheet&amp; styleSheet)
1295 {
1296     return deferredGroupRulesCountForList(downcast&lt;CSSStyleSheet&gt;(styleSheet).contents().childRules());
1297 }
1298 
1299 static unsigned deferredKeyframesRulesCountForList(const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; childRules)
1300 {
1301     unsigned count = 0;
1302     for (auto rule : childRules) {
1303         if (is&lt;StyleRuleKeyframes&gt;(rule)) {
1304             auto* cssRule = downcast&lt;StyleRuleKeyframes&gt;(rule.get());
1305             if (!cssRule-&gt;keyframesWithoutDeferredParsing())
1306                 count++;
1307             continue;
1308         }
1309 
1310         StyleRuleGroup* groupRule = nullptr;
1311         if (is&lt;StyleRuleMedia&gt;(rule))
1312             groupRule = downcast&lt;StyleRuleMedia&gt;(rule.get());
1313         else if (is&lt;StyleRuleSupports&gt;(rule))
1314             groupRule = downcast&lt;StyleRuleSupports&gt;(rule.get());
1315         if (!groupRule)
1316             continue;
1317 
1318         auto* groupChildRules = groupRule-&gt;childRulesWithoutDeferredParsing();
1319         if (!groupChildRules)
1320             continue;
1321 
1322         count += deferredKeyframesRulesCountForList(*groupChildRules);
1323     }
1324 
1325     return count;
1326 }
1327 
1328 unsigned Internals::deferredKeyframesRulesCount(StyleSheet&amp; styleSheet)
1329 {
1330     StyleSheetContents&amp; contents = downcast&lt;CSSStyleSheet&gt;(styleSheet).contents();
1331     return deferredKeyframesRulesCountForList(contents.childRules());
1332 }
1333 
1334 ExceptionOr&lt;bool&gt; Internals::isTimerThrottled(int timeoutId)
1335 {
1336     auto* timer = scriptExecutionContext()-&gt;findTimeout(timeoutId);
1337     if (!timer)
1338         return Exception { NotFoundError };
1339 
1340     if (timer-&gt;intervalClampedToMinimum() &gt; timer-&gt;m_originalInterval)
1341         return true;
1342 
1343     return !!timer-&gt;alignedFireTime(MonotonicTime { });
1344 }
1345 
1346 bool Internals::isRequestAnimationFrameThrottled() const
1347 {
1348     auto* scriptedAnimationController = contextDocument()-&gt;scriptedAnimationController();
1349     if (!scriptedAnimationController)
1350         return false;
1351     return scriptedAnimationController-&gt;isThrottled();
1352 }
1353 
1354 double Internals::requestAnimationFrameInterval() const
1355 {
1356     auto* scriptedAnimationController = contextDocument()-&gt;scriptedAnimationController();
1357     if (!scriptedAnimationController)
1358         return INFINITY;
1359     return scriptedAnimationController-&gt;interval().value();
1360 }
1361 
1362 bool Internals::scriptedAnimationsAreSuspended() const
1363 {
1364     Document* document = contextDocument();
1365     if (!document || !document-&gt;page())
1366         return true;
1367 
1368     return document-&gt;page()-&gt;scriptedAnimationsSuspended();
1369 }
1370 
1371 bool Internals::areTimersThrottled() const
1372 {
1373     return contextDocument()-&gt;isTimerThrottlingEnabled();
1374 }
1375 
1376 void Internals::setEventThrottlingBehaviorOverride(Optional&lt;EventThrottlingBehavior&gt; value)
1377 {
1378     Document* document = contextDocument();
1379     if (!document || !document-&gt;page())
1380         return;
1381 
1382     if (!value) {
1383         document-&gt;page()-&gt;setEventThrottlingBehaviorOverride(WTF::nullopt);
1384         return;
1385     }
1386 
1387     switch (value.value()) {
1388     case Internals::EventThrottlingBehavior::Responsive:
1389         document-&gt;page()-&gt;setEventThrottlingBehaviorOverride(WebCore::EventThrottlingBehavior::Responsive);
1390         break;
1391     case Internals::EventThrottlingBehavior::Unresponsive:
1392         document-&gt;page()-&gt;setEventThrottlingBehaviorOverride(WebCore::EventThrottlingBehavior::Unresponsive);
1393         break;
1394     }
1395 }
1396 
1397 Optional&lt;Internals::EventThrottlingBehavior&gt; Internals::eventThrottlingBehaviorOverride() const
1398 {
1399     Document* document = contextDocument();
1400     if (!document || !document-&gt;page())
1401         return WTF::nullopt;
1402 
1403     auto behavior = document-&gt;page()-&gt;eventThrottlingBehaviorOverride();
1404     if (!behavior)
1405         return WTF::nullopt;
1406 
1407     switch (behavior.value()) {
1408     case WebCore::EventThrottlingBehavior::Responsive:
1409         return Internals::EventThrottlingBehavior::Responsive;
1410     case WebCore::EventThrottlingBehavior::Unresponsive:
1411         return Internals::EventThrottlingBehavior::Unresponsive;
1412     }
1413 
1414     return WTF::nullopt;
1415 }
1416 
1417 String Internals::visiblePlaceholder(Element&amp; element)
1418 {
1419     if (is&lt;HTMLTextFormControlElement&gt;(element)) {
1420         const HTMLTextFormControlElement&amp; textFormControlElement = downcast&lt;HTMLTextFormControlElement&gt;(element);
1421         if (!textFormControlElement.isPlaceholderVisible())
1422             return String();
1423         if (HTMLElement* placeholderElement = textFormControlElement.placeholderElement())
1424             return placeholderElement-&gt;textContent();
1425     }
1426 
1427     return String();
1428 }
1429 
1430 void Internals::setCanShowPlaceholder(Element&amp; element, bool canShowPlaceholder)
1431 {
1432     if (is&lt;HTMLTextFormControlElement&gt;(element))
1433         downcast&lt;HTMLTextFormControlElement&gt;(element).setCanShowPlaceholder(canShowPlaceholder);
1434 }
1435 
1436 void Internals::selectColorInColorChooser(HTMLInputElement&amp; element, const String&amp; colorValue)
1437 {
1438     element.selectColor(colorValue);
1439 }
1440 
1441 ExceptionOr&lt;Vector&lt;String&gt;&gt; Internals::formControlStateOfPreviousHistoryItem()
1442 {
1443     HistoryItem* mainItem = frame()-&gt;loader().history().previousItem();
1444     if (!mainItem)
1445         return Exception { InvalidAccessError };
1446     String uniqueName = frame()-&gt;tree().uniqueName();
1447     if (mainItem-&gt;target() != uniqueName &amp;&amp; !mainItem-&gt;childItemWithTarget(uniqueName))
1448         return Exception { InvalidAccessError };
1449     return Vector&lt;String&gt; { mainItem-&gt;target() == uniqueName ? mainItem-&gt;documentState() : mainItem-&gt;childItemWithTarget(uniqueName)-&gt;documentState() };
1450 }
1451 
1452 ExceptionOr&lt;void&gt; Internals::setFormControlStateOfPreviousHistoryItem(const Vector&lt;String&gt;&amp; state)
1453 {
1454     HistoryItem* mainItem = frame()-&gt;loader().history().previousItem();
1455     if (!mainItem)
1456         return Exception { InvalidAccessError };
1457     String uniqueName = frame()-&gt;tree().uniqueName();
1458     if (mainItem-&gt;target() == uniqueName)
1459         mainItem-&gt;setDocumentState(state);
1460     else if (HistoryItem* subItem = mainItem-&gt;childItemWithTarget(uniqueName))
1461         subItem-&gt;setDocumentState(state);
1462     else
1463         return Exception { InvalidAccessError };
1464     return { };
1465 }
1466 
1467 #if ENABLE(SPEECH_SYNTHESIS)
1468 
1469 void Internals::enableMockSpeechSynthesizer()
1470 {
1471     Document* document = contextDocument();
1472     if (!document || !document-&gt;domWindow())
1473         return;
1474     SpeechSynthesis* synthesis = DOMWindowSpeechSynthesis::speechSynthesis(*document-&gt;domWindow());
1475     if (!synthesis)
1476         return;
1477 
1478     synthesis-&gt;setPlatformSynthesizer(makeUnique&lt;PlatformSpeechSynthesizerMock&gt;(synthesis));
1479 }
1480 
1481 #endif
1482 
1483 #if ENABLE(WEB_RTC)
1484 
1485 void Internals::emulateRTCPeerConnectionPlatformEvent(RTCPeerConnection&amp; connection, const String&amp; action)
1486 {
1487     if (!LibWebRTCProvider::webRTCAvailable())
1488         return;
1489 
1490     connection.emulatePlatformEvent(action);
1491 }
1492 
1493 void Internals::useMockRTCPeerConnectionFactory(const String&amp; testCase)
1494 {
1495     if (!LibWebRTCProvider::webRTCAvailable())
1496         return;
1497 
1498 #if USE(LIBWEBRTC)
1499     Document* document = contextDocument();
1500     LibWebRTCProvider* provider = (document &amp;&amp; document-&gt;page()) ? &amp;document-&gt;page()-&gt;libWebRTCProvider() : nullptr;
1501     WebCore::useMockRTCPeerConnectionFactory(provider, testCase);
1502 #else
1503     UNUSED_PARAM(testCase);
1504 #endif
1505 }
1506 
1507 void Internals::setICECandidateFiltering(bool enabled)
1508 {
1509     auto* page = contextDocument()-&gt;page();
1510     if (!page)
1511         return;
1512 
1513     auto&amp; rtcController = page-&gt;rtcController();
1514     if (enabled)
1515         rtcController.enableICECandidateFiltering();
1516     else
1517         rtcController.disableICECandidateFilteringForAllOrigins();
1518 }
1519 
1520 void Internals::setEnumeratingAllNetworkInterfacesEnabled(bool enabled)
1521 {
1522 #if USE(LIBWEBRTC)
1523     Document* document = contextDocument();
1524     auto* page = document-&gt;page();
1525     if (!page)
1526         return;
1527     auto&amp; rtcProvider = page-&gt;libWebRTCProvider();
1528     if (enabled)
1529         rtcProvider.enableEnumeratingAllNetworkInterfaces();
1530     else
1531         rtcProvider.disableEnumeratingAllNetworkInterfaces();
1532 #else
1533     UNUSED_PARAM(enabled);
1534 #endif
1535 }
1536 
1537 void Internals::stopPeerConnection(RTCPeerConnection&amp; connection)
1538 {
1539     ActiveDOMObject&amp; object = connection;
1540     object.stop();
1541 }
1542 
1543 void Internals::clearPeerConnectionFactory()
1544 {
1545 #if USE(LIBWEBRTC)
1546     if (auto* page = contextDocument()-&gt;page())
1547         page-&gt;libWebRTCProvider().clearFactory();
1548 #endif
1549 }
1550 
1551 void Internals::applyRotationForOutgoingVideoSources(RTCPeerConnection&amp; connection)
1552 {
1553     connection.applyRotationForOutgoingVideoSources();
1554 }
1555 
1556 void Internals::setEnableWebRTCEncryption(bool value)
1557 {
1558 #if USE(LIBWEBRTC)
1559     if (auto* page = contextDocument()-&gt;page())
1560         page-&gt;settings().setWebRTCEncryptionEnabled(value);
1561 #endif
1562 }
1563 
1564 void Internals::setUseDTLS10(bool useDTLS10)
1565 {
1566 #if USE(LIBWEBRTC)
1567     auto* document = contextDocument();
1568     if (!document || !document-&gt;page())
1569         return;
1570     document-&gt;page()-&gt;libWebRTCProvider().setUseDTLS10(useDTLS10);
1571 #endif
1572 }
1573 
1574 void Internals::setUseGPUProcessForWebRTC(bool useGPUProcess)
1575 {
1576 #if USE(LIBWEBRTC)
1577     auto* document = contextDocument();
1578     if (!document || !document-&gt;page())
1579         return;
1580 
1581     document-&gt;page()-&gt;libWebRTCProvider().setUseGPUProcess(useGPUProcess);
1582     document-&gt;page()-&gt;mediaRecorderProvider().setUseGPUProcess(useGPUProcess);
1583 #endif
1584 }
1585 #endif
1586 
1587 #if ENABLE(MEDIA_STREAM)
1588 void Internals::setShouldInterruptAudioOnPageVisibilityChange(bool shouldInterrupt)
1589 {
1590     RuntimeEnabledFeatures::sharedFeatures().setInterruptAudioOnPageVisibilityChangeEnabled(shouldInterrupt);
1591 }
1592 
1593 void Internals::setMediaCaptureRequiresSecureConnection(bool enabled)
1594 {
1595     Document* document = contextDocument();
1596     if (auto* page = document-&gt;page())
1597         page-&gt;settings().setMediaCaptureRequiresSecureConnection(enabled);
1598 }
1599 
1600 static std::unique_ptr&lt;MediaRecorderPrivate&gt; createRecorderMockSource()
1601 {
1602     return std::unique_ptr&lt;MediaRecorderPrivateMock&gt;(new MediaRecorderPrivateMock);
1603 }
1604 
1605 void Internals::setCustomPrivateRecorderCreator()
1606 {
1607     WebCore::MediaRecorder::setCustomPrivateRecorderCreator(createRecorderMockSource);
1608 }
1609 
1610 #endif
1611 
1612 ExceptionOr&lt;Ref&lt;DOMRect&gt;&gt; Internals::absoluteCaretBounds()
1613 {
1614     Document* document = contextDocument();
1615     if (!document || !document-&gt;frame())
1616         return Exception { InvalidAccessError };
1617 
1618     return DOMRect::create(document-&gt;frame()-&gt;selection().absoluteCaretBounds());
1619 }
1620 
1621 ExceptionOr&lt;bool&gt; Internals::isCaretBlinkingSuspended()
1622 {
1623     Document* document = contextDocument();
1624     if (!document || !document-&gt;frame())
1625         return Exception { InvalidAccessError };
1626 
1627     return document-&gt;frame()-&gt;selection().isCaretBlinkingSuspended();
1628 }
1629 
1630 Ref&lt;DOMRect&gt; Internals::boundingBox(Element&amp; element)
1631 {
1632     element.document().updateLayoutIgnorePendingStylesheets();
1633     auto renderer = element.renderer();
1634     if (!renderer)
1635         return DOMRect::create();
1636     return DOMRect::create(renderer-&gt;absoluteBoundingBoxRectIgnoringTransforms());
1637 }
1638 
1639 ExceptionOr&lt;Ref&lt;DOMRectList&gt;&gt; Internals::inspectorHighlightRects()
1640 {
1641     Document* document = contextDocument();
1642     if (!document || !document-&gt;page())
1643         return Exception { InvalidAccessError };
1644 
1645     Highlight highlight;
1646     document-&gt;page()-&gt;inspectorController().getHighlight(highlight, InspectorOverlay::CoordinateSystem::View);
1647     return DOMRectList::create(highlight.quads);
1648 }
1649 
1650 ExceptionOr&lt;unsigned&gt; Internals::markerCountForNode(Node&amp; node, const String&amp; markerType)
1651 {
1652     OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes;
1653     if (!markerTypesFrom(markerType, markerTypes))
1654         return Exception { SyntaxError };
1655 
1656     node.document().frame()-&gt;editor().updateEditorUINowIfScheduled();
1657     return node.document().markers().markersFor(node, markerTypes).size();
1658 }
1659 
1660 ExceptionOr&lt;RenderedDocumentMarker*&gt; Internals::markerAt(Node&amp; node, const String&amp; markerType, unsigned index)
1661 {
1662     node.document().updateLayoutIgnorePendingStylesheets();
1663 
1664     OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes;
1665     if (!markerTypesFrom(markerType, markerTypes))
1666         return Exception { SyntaxError };
1667 
1668     node.document().frame()-&gt;editor().updateEditorUINowIfScheduled();
1669 
1670     Vector&lt;RenderedDocumentMarker*&gt; markers = node.document().markers().markersFor(node, markerTypes);
1671     if (markers.size() &lt;= index)
1672         return nullptr;
1673     return markers[index];
1674 }
1675 
1676 ExceptionOr&lt;RefPtr&lt;Range&gt;&gt; Internals::markerRangeForNode(Node&amp; node, const String&amp; markerType, unsigned index)
1677 {
1678     auto result = markerAt(node, markerType, index);
1679     if (result.hasException())
1680         return result.releaseException();
1681     auto marker = result.releaseReturnValue();
1682     if (!marker)
1683         return nullptr;
1684     return RefPtr&lt;Range&gt; { Range::create(node.document(), &amp;node, marker-&gt;startOffset(), &amp;node, marker-&gt;endOffset()) };
1685 }
1686 
1687 ExceptionOr&lt;String&gt; Internals::markerDescriptionForNode(Node&amp; node, const String&amp; markerType, unsigned index)
1688 {
1689     auto result = markerAt(node, markerType, index);
1690     if (result.hasException())
1691         return result.releaseException();
1692     auto marker = result.releaseReturnValue();
1693     if (!marker)
1694         return String();
1695     return String { marker-&gt;description() };
1696 }
1697 
1698 ExceptionOr&lt;String&gt; Internals::dumpMarkerRects(const String&amp; markerTypeString)
1699 {
1700     DocumentMarker::MarkerType markerType;
1701     if (!markerTypeFrom(markerTypeString, markerType))
1702         return Exception { SyntaxError };
1703 
1704     contextDocument()-&gt;markers().updateRectsForInvalidatedMarkersOfType(markerType);
1705     auto rects = contextDocument()-&gt;markers().renderedRectsForMarkers(markerType);
1706 
1707     // FIXME: Using fixed precision here for width because of test results that contain numbers with specific precision. Would be nice to update the test results and move to default formatting.
1708     StringBuilder rectString;
1709     rectString.appendLiteral(&quot;marker rects: &quot;);
1710     for (const auto&amp; rect : rects)
1711         rectString.append(&#39;(&#39;, rect.x(), &quot;, &quot;, rect.y(), &quot;, &quot;, FormattedNumber::fixedPrecision(rect.width()), &quot;, &quot;, rect.height(), &quot;) &quot;);
1712     return rectString.toString();
1713 }
1714 
1715 void Internals::addTextMatchMarker(const Range&amp; range, bool isActive)
1716 {
1717     range.ownerDocument().updateLayoutIgnorePendingStylesheets();
1718     range.ownerDocument().markers().addTextMatchMarker(range, isActive);
1719 }
1720 
1721 ExceptionOr&lt;void&gt; Internals::setMarkedTextMatchesAreHighlighted(bool flag)
1722 {
1723     Document* document = contextDocument();
1724     if (!document || !document-&gt;frame())
1725         return Exception { InvalidAccessError };
1726     document-&gt;frame()-&gt;editor().setMarkedTextMatchesAreHighlighted(flag);
1727     return { };
1728 }
1729 
1730 void Internals::invalidateFontCache()
1731 {
1732     FontCache::singleton().invalidate();
1733 }
1734 
1735 void Internals::setFontSmoothingEnabled(bool enabled)
1736 {
1737     FontCascade::setShouldUseSmoothing(enabled);
1738 }
1739 
1740 ExceptionOr&lt;void&gt; Internals::setLowPowerModeEnabled(bool isEnabled)
1741 {
1742     auto* document = contextDocument();
1743     if (!document)
1744         return Exception { InvalidAccessError };
1745     auto* page = document-&gt;page();
1746     if (!page)
1747         return Exception { InvalidAccessError };
1748 
1749     page-&gt;setLowPowerModeEnabledOverrideForTesting(isEnabled);
1750     return { };
1751 }
1752 
1753 ExceptionOr&lt;void&gt; Internals::setScrollViewPosition(int x, int y)
1754 {
1755     Document* document = contextDocument();
1756     if (!document || !document-&gt;view())
1757         return Exception { InvalidAccessError };
1758 
1759     auto&amp; frameView = *document-&gt;view();
1760     bool constrainsScrollingToContentEdgeOldValue = frameView.constrainsScrollingToContentEdge();
1761     bool scrollbarsSuppressedOldValue = frameView.scrollbarsSuppressed();
1762 
1763     frameView.setConstrainsScrollingToContentEdge(false);
1764     frameView.setScrollbarsSuppressed(false);
1765     frameView.setScrollOffsetFromInternals({ x, y });
1766     frameView.setScrollbarsSuppressed(scrollbarsSuppressedOldValue);
1767     frameView.setConstrainsScrollingToContentEdge(constrainsScrollingToContentEdgeOldValue);
1768 
1769     return { };
1770 }
1771 
1772 ExceptionOr&lt;void&gt; Internals::unconstrainedScrollTo(Element&amp; element, double x, double y)
1773 {
1774     Document* document = contextDocument();
1775     if (!document || !document-&gt;view())
1776         return Exception { InvalidAccessError };
1777 
1778     element.scrollTo({ x, y }, ScrollClamping::Unclamped);
1779 
1780     auto&amp; frameView = *document-&gt;view();
1781     frameView.setViewportConstrainedObjectsNeedLayout();
1782 
1783     return { };
1784 }
1785 
1786 ExceptionOr&lt;Ref&lt;DOMRect&gt;&gt; Internals::layoutViewportRect()
1787 {
1788     Document* document = contextDocument();
1789     if (!document || !document-&gt;frame())
1790         return Exception { InvalidAccessError };
1791 
1792     document-&gt;updateLayoutIgnorePendingStylesheets();
1793 
1794     auto&amp; frameView = *document-&gt;view();
1795     return DOMRect::create(frameView.layoutViewportRect());
1796 }
1797 
1798 ExceptionOr&lt;Ref&lt;DOMRect&gt;&gt; Internals::visualViewportRect()
1799 {
1800     Document* document = contextDocument();
1801     if (!document || !document-&gt;frame())
1802         return Exception { InvalidAccessError };
1803 
1804     document-&gt;updateLayoutIgnorePendingStylesheets();
1805 
1806     auto&amp; frameView = *document-&gt;view();
1807     return DOMRect::create(frameView.visualViewportRect());
1808 }
1809 
1810 ExceptionOr&lt;void&gt; Internals::setViewIsTransparent(bool transparent)
1811 {
1812     Document* document = contextDocument();
1813     if (!document || !document-&gt;view())
1814         return Exception { InvalidAccessError };
1815     Optional&lt;Color&gt; backgroundColor;
1816     if (transparent)
1817         backgroundColor = Color(Color::transparent);
1818     document-&gt;view()-&gt;updateBackgroundRecursively(backgroundColor);
1819     return { };
1820 }
1821 
1822 ExceptionOr&lt;String&gt; Internals::viewBaseBackgroundColor()
1823 {
1824     Document* document = contextDocument();
1825     if (!document || !document-&gt;view())
1826         return Exception { InvalidAccessError };
1827     return document-&gt;view()-&gt;baseBackgroundColor().cssText();
1828 }
1829 
1830 ExceptionOr&lt;void&gt; Internals::setViewBaseBackgroundColor(const String&amp; colorValue)
1831 {
1832     Document* document = contextDocument();
1833     if (!document || !document-&gt;view())
1834         return Exception { InvalidAccessError };
1835 
1836     if (colorValue == &quot;transparent&quot;) {
1837         document-&gt;view()-&gt;setBaseBackgroundColor(Color::transparent);
1838         return { };
1839     }
1840     if (colorValue == &quot;white&quot;) {
1841         document-&gt;view()-&gt;setBaseBackgroundColor(Color::white);
1842         return { };
1843     }
1844     return Exception { SyntaxError };
1845 }
1846 
1847 ExceptionOr&lt;void&gt; Internals::setPagination(const String&amp; mode, int gap, int pageLength)
1848 {
1849     Document* document = contextDocument();
1850     if (!document || !document-&gt;page())
1851         return Exception { InvalidAccessError };
1852 
1853     Pagination pagination;
1854     if (mode == &quot;Unpaginated&quot;)
1855         pagination.mode = Pagination::Unpaginated;
1856     else if (mode == &quot;LeftToRightPaginated&quot;)
1857         pagination.mode = Pagination::LeftToRightPaginated;
1858     else if (mode == &quot;RightToLeftPaginated&quot;)
1859         pagination.mode = Pagination::RightToLeftPaginated;
1860     else if (mode == &quot;TopToBottomPaginated&quot;)
1861         pagination.mode = Pagination::TopToBottomPaginated;
1862     else if (mode == &quot;BottomToTopPaginated&quot;)
1863         pagination.mode = Pagination::BottomToTopPaginated;
1864     else
1865         return Exception { SyntaxError };
1866 
1867     pagination.gap = gap;
1868     pagination.pageLength = pageLength;
1869     document-&gt;page()-&gt;setPagination(pagination);
1870 
1871     return { };
1872 }
1873 
1874 ExceptionOr&lt;void&gt; Internals::setPaginationLineGridEnabled(bool enabled)
1875 {
1876     Document* document = contextDocument();
1877     if (!document || !document-&gt;page())
1878         return Exception { InvalidAccessError };
1879     document-&gt;page()-&gt;setPaginationLineGridEnabled(enabled);
1880     return { };
1881 }
1882 
1883 ExceptionOr&lt;String&gt; Internals::configurationForViewport(float devicePixelRatio, int deviceWidth, int deviceHeight, int availableWidth, int availableHeight)
1884 {
1885     Document* document = contextDocument();
1886     if (!document || !document-&gt;page())
1887         return Exception { InvalidAccessError };
1888 
1889     const int defaultLayoutWidthForNonMobilePages = 980;
1890 
1891     ViewportArguments arguments = document-&gt;page()-&gt;viewportArguments();
1892     ViewportAttributes attributes = computeViewportAttributes(arguments, defaultLayoutWidthForNonMobilePages, deviceWidth, deviceHeight, devicePixelRatio, IntSize(availableWidth, availableHeight));
1893     restrictMinimumScaleFactorToViewportSize(attributes, IntSize(availableWidth, availableHeight), devicePixelRatio);
1894     restrictScaleFactorToInitialScaleIfNotUserScalable(attributes);
1895 
1896     // FIXME: Using fixed precision here because of test results that contain numbers with specific precision. Would be nice to update the test results and move to default formatting.
1897     return makeString(&quot;viewport size &quot;, FormattedNumber::fixedPrecision(attributes.layoutSize.width()), &#39;x&#39;, FormattedNumber::fixedPrecision(attributes.layoutSize.height()), &quot; scale &quot;, FormattedNumber::fixedPrecision(attributes.initialScale), &quot; with limits [&quot;, FormattedNumber::fixedPrecision(attributes.minimumScale), &quot;, &quot;, FormattedNumber::fixedPrecision(attributes.maximumScale), &quot;] and userScalable &quot;, (attributes.userScalable ? &quot;true&quot; : &quot;false&quot;));
1898 }
1899 
1900 ExceptionOr&lt;bool&gt; Internals::wasLastChangeUserEdit(Element&amp; textField)
1901 {
1902     if (is&lt;HTMLInputElement&gt;(textField))
1903         return downcast&lt;HTMLInputElement&gt;(textField).lastChangeWasUserEdit();
1904 
1905     if (is&lt;HTMLTextAreaElement&gt;(textField))
1906         return downcast&lt;HTMLTextAreaElement&gt;(textField).lastChangeWasUserEdit();
1907 
1908     return Exception { InvalidNodeTypeError };
1909 }
1910 
1911 bool Internals::elementShouldAutoComplete(HTMLInputElement&amp; element)
1912 {
1913     return element.shouldAutocomplete();
1914 }
1915 
1916 void Internals::setAutofilled(HTMLInputElement&amp; element, bool enabled)
1917 {
1918     element.setAutoFilled(enabled);
1919 }
1920 
1921 void Internals::setAutoFilledAndViewable(HTMLInputElement&amp; element, bool enabled)
1922 {
1923     element.setAutoFilledAndViewable(enabled);
1924 }
1925 
1926 static AutoFillButtonType toAutoFillButtonType(Internals::AutoFillButtonType type)
1927 {
1928     switch (type) {
1929     case Internals::AutoFillButtonType::None:
1930         return AutoFillButtonType::None;
1931     case Internals::AutoFillButtonType::Credentials:
1932         return AutoFillButtonType::Credentials;
1933     case Internals::AutoFillButtonType::Contacts:
1934         return AutoFillButtonType::Contacts;
1935     case Internals::AutoFillButtonType::StrongPassword:
1936         return AutoFillButtonType::StrongPassword;
1937     case Internals::AutoFillButtonType::CreditCard:
1938         return AutoFillButtonType::CreditCard;
1939     }
1940     ASSERT_NOT_REACHED();
1941     return AutoFillButtonType::None;
1942 }
1943 
1944 static Internals::AutoFillButtonType toInternalsAutoFillButtonType(AutoFillButtonType type)
1945 {
1946     switch (type) {
1947     case AutoFillButtonType::None:
1948         return Internals::AutoFillButtonType::None;
1949     case AutoFillButtonType::Credentials:
1950         return Internals::AutoFillButtonType::Credentials;
1951     case AutoFillButtonType::Contacts:
1952         return Internals::AutoFillButtonType::Contacts;
1953     case AutoFillButtonType::StrongPassword:
1954         return Internals::AutoFillButtonType::StrongPassword;
1955     case AutoFillButtonType::CreditCard:
1956         return Internals::AutoFillButtonType::CreditCard;
1957     }
1958     ASSERT_NOT_REACHED();
1959     return Internals::AutoFillButtonType::None;
1960 }
1961 
1962 void Internals::setShowAutoFillButton(HTMLInputElement&amp; element, AutoFillButtonType type)
1963 {
1964     element.setShowAutoFillButton(toAutoFillButtonType(type));
1965 }
1966 
1967 auto Internals::autoFillButtonType(const HTMLInputElement&amp; element) -&gt; AutoFillButtonType
1968 {
1969     return toInternalsAutoFillButtonType(element.autoFillButtonType());
1970 }
1971 
1972 auto Internals::lastAutoFillButtonType(const HTMLInputElement&amp; element) -&gt; AutoFillButtonType
1973 {
1974     return toInternalsAutoFillButtonType(element.lastAutoFillButtonType());
1975 }
1976 
1977 ExceptionOr&lt;void&gt; Internals::scrollElementToRect(Element&amp; element, int x, int y, int w, int h)
1978 {
1979     FrameView* frameView = element.document().view();
1980     if (!frameView)
1981         return Exception { InvalidAccessError };
1982     frameView-&gt;scrollElementToRect(element, { x, y, w, h });
1983     return { };
1984 }
1985 
1986 ExceptionOr&lt;String&gt; Internals::autofillFieldName(Element&amp; element)
1987 {
1988     if (!is&lt;HTMLFormControlElement&gt;(element))
1989         return Exception { InvalidNodeTypeError };
1990 
1991     return String { downcast&lt;HTMLFormControlElement&gt;(element).autofillData().fieldName };
1992 }
1993 
1994 ExceptionOr&lt;void&gt; Internals::invalidateControlTints()
1995 {
1996     Document* document = contextDocument();
1997     if (!document || !document-&gt;view())
1998         return Exception { InvalidAccessError };
1999 
2000     document-&gt;view()-&gt;invalidateControlTints();
2001     return { };
2002 }
2003 
2004 RefPtr&lt;Range&gt; Internals::rangeFromLocationAndLength(Element&amp; scope, int rangeLocation, int rangeLength)
2005 {
2006     return TextIterator::rangeFromLocationAndLength(&amp;scope, rangeLocation, rangeLength);
2007 }
2008 
2009 unsigned Internals::locationFromRange(Element&amp; scope, const Range&amp; range)
2010 {
2011     size_t location = 0;
2012     size_t unusedLength = 0;
2013     TextIterator::getLocationAndLengthFromRange(&amp;scope, &amp;range, location, unusedLength);
2014     return location;
2015 }
2016 
2017 unsigned Internals::lengthFromRange(Element&amp; scope, const Range&amp; range)
2018 {
2019     size_t unusedLocation = 0;
2020     size_t length = 0;
2021     TextIterator::getLocationAndLengthFromRange(&amp;scope, &amp;range, unusedLocation, length);
2022     return length;
2023 }
2024 
2025 String Internals::rangeAsText(const Range&amp; range)
2026 {
2027     return range.text();
2028 }
2029 
2030 String Internals::rangeAsTextUsingBackwardsTextIterator(const Range&amp; range)
2031 {
2032     return plainTextUsingBackwardsTextIteratorForTesting(range);
2033 }
2034 
2035 Ref&lt;Range&gt; Internals::subrange(Range&amp; range, int rangeLocation, int rangeLength)
2036 {
2037     return TextIterator::subrange(range, rangeLocation, rangeLength);
2038 }
2039 
2040 RefPtr&lt;Range&gt; Internals::rangeOfStringNearLocation(const Range&amp; searchRange, const String&amp; text, unsigned targetOffset)
2041 {
2042     return findClosestPlainText(searchRange, text, { }, targetOffset);
2043 }
2044 
2045 #if !PLATFORM(MAC)
2046 ExceptionOr&lt;RefPtr&lt;Range&gt;&gt; Internals::rangeForDictionaryLookupAtLocation(int, int)
2047 {
2048     return Exception { InvalidAccessError };
2049 }
2050 #endif
2051 
2052 ExceptionOr&lt;void&gt; Internals::setDelegatesScrolling(bool enabled)
2053 {
2054     Document* document = contextDocument();
2055     // Delegate scrolling is valid only on mainframe&#39;s view.
2056     if (!document || !document-&gt;view() || !document-&gt;page() || &amp;document-&gt;page()-&gt;mainFrame() != document-&gt;frame())
2057         return Exception { InvalidAccessError };
2058 
2059     document-&gt;view()-&gt;setDelegatesScrolling(enabled);
2060     return { };
2061 }
2062 
2063 ExceptionOr&lt;int&gt; Internals::lastSpellCheckRequestSequence()
2064 {
2065     Document* document = contextDocument();
2066     if (!document || !document-&gt;frame())
2067         return Exception { InvalidAccessError };
2068 
2069     return document-&gt;frame()-&gt;editor().spellChecker().lastRequestSequence();
2070 }
2071 
2072 ExceptionOr&lt;int&gt; Internals::lastSpellCheckProcessedSequence()
2073 {
2074     Document* document = contextDocument();
2075     if (!document || !document-&gt;frame())
2076         return Exception { InvalidAccessError };
2077 
2078     return document-&gt;frame()-&gt;editor().spellChecker().lastProcessedSequence();
2079 }
2080 
2081 Vector&lt;String&gt; Internals::userPreferredLanguages() const
2082 {
2083     return WTF::userPreferredLanguages();
2084 }
2085 
2086 void Internals::setUserPreferredLanguages(const Vector&lt;String&gt;&amp; languages)
2087 {
2088     overrideUserPreferredLanguages(languages);
2089 }
2090 
2091 Vector&lt;String&gt; Internals::userPreferredAudioCharacteristics() const
2092 {
2093     Document* document = contextDocument();
2094     if (!document || !document-&gt;page())
2095         return Vector&lt;String&gt;();
2096 #if ENABLE(VIDEO_TRACK)
2097     return document-&gt;page()-&gt;group().captionPreferences().preferredAudioCharacteristics();
2098 #else
2099     return Vector&lt;String&gt;();
2100 #endif
2101 }
2102 
2103 void Internals::setUserPreferredAudioCharacteristic(const String&amp; characteristic)
2104 {
2105     Document* document = contextDocument();
2106     if (!document || !document-&gt;page())
2107         return;
2108 #if ENABLE(VIDEO_TRACK)
2109     document-&gt;page()-&gt;group().captionPreferences().setPreferredAudioCharacteristic(characteristic);
2110 #else
2111     UNUSED_PARAM(characteristic);
2112 #endif
2113 }
2114 
2115 ExceptionOr&lt;unsigned&gt; Internals::wheelEventHandlerCount()
2116 {
2117     Document* document = contextDocument();
2118     if (!document)
2119         return Exception { InvalidAccessError };
2120 
2121     return document-&gt;wheelEventHandlerCount();
2122 }
2123 
2124 ExceptionOr&lt;unsigned&gt; Internals::touchEventHandlerCount()
2125 {
2126     Document* document = contextDocument();
2127     if (!document)
2128         return Exception { InvalidAccessError };
2129 
2130     return document-&gt;touchEventHandlerCount();
2131 }
2132 
2133 ExceptionOr&lt;Ref&lt;DOMRectList&gt;&gt; Internals::touchEventRectsForEvent(const String&amp; eventName)
2134 {
2135     Document* document = contextDocument();
2136     if (!document || !document-&gt;page())
2137         return Exception { InvalidAccessError };
2138 
2139     return document-&gt;page()-&gt;touchEventRectsForEvent(eventName);
2140 }
2141 
2142 ExceptionOr&lt;Ref&lt;DOMRectList&gt;&gt; Internals::passiveTouchEventListenerRects()
2143 {
2144     Document* document = contextDocument();
2145     if (!document || !document-&gt;page())
2146         return Exception { InvalidAccessError };
2147 
2148     return document-&gt;page()-&gt;passiveTouchEventListenerRects();
2149 }
2150 
2151 // FIXME: Remove the document argument. It is almost always the same as
2152 // contextDocument(), with the exception of a few tests that pass a
2153 // different document, and could just make the call through another Internals
2154 // instance instead.
2155 ExceptionOr&lt;RefPtr&lt;NodeList&gt;&gt; Internals::nodesFromRect(Document&amp; document, int centerX, int centerY, unsigned topPadding, unsigned rightPadding, unsigned bottomPadding, unsigned leftPadding, bool ignoreClipping, bool allowUserAgentShadowContent, bool allowChildFrameContent) const
2156 {
2157     if (!document.frame() || !document.frame()-&gt;view())
2158         return Exception { InvalidAccessError };
2159 
2160     Frame* frame = document.frame();
2161     FrameView* frameView = document.view();
2162     RenderView* renderView = document.renderView();
2163     if (!renderView)
2164         return nullptr;
2165 
2166     document.updateLayoutIgnorePendingStylesheets();
2167 
2168     float zoomFactor = frame-&gt;pageZoomFactor();
2169     LayoutPoint point(centerX * zoomFactor + frameView-&gt;scrollX(), centerY * zoomFactor + frameView-&gt;scrollY());
2170 
2171     HitTestRequest::HitTestRequestType hitType = HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::CollectMultipleElements;
2172     if (ignoreClipping)
2173         hitType |= HitTestRequest::IgnoreClipping;
2174     if (!allowUserAgentShadowContent)
2175         hitType |= HitTestRequest::DisallowUserAgentShadowContent;
2176     if (allowChildFrameContent)
2177         hitType |= HitTestRequest::AllowChildFrameContent;
2178 
2179     HitTestRequest request(hitType);
2180 
2181     // When ignoreClipping is false, this method returns null for coordinates outside of the viewport.
2182     if (!request.ignoreClipping() &amp;&amp; !frameView-&gt;visibleContentRect().intersects(HitTestLocation::rectForPoint(point, topPadding, rightPadding, bottomPadding, leftPadding)))
2183         return nullptr;
2184 
2185     HitTestResult result(point, topPadding, rightPadding, bottomPadding, leftPadding);
2186     document.hitTest(request, result);
2187     const HitTestResult::NodeSet&amp; nodeSet = result.listBasedTestResult();
2188     Vector&lt;Ref&lt;Node&gt;&gt; matches;
2189     matches.reserveInitialCapacity(nodeSet.size());
2190     for (auto&amp; node : nodeSet)
2191         matches.uncheckedAppend(*node);
2192 
2193     return RefPtr&lt;NodeList&gt; { StaticNodeList::create(WTFMove(matches)) };
2194 }
2195 
2196 class GetCallerCodeBlockFunctor {
2197 public:
2198     GetCallerCodeBlockFunctor()
2199         : m_iterations(0)
2200         , m_codeBlock(0)
2201     {
2202     }
2203 
2204     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
2205     {
2206         ++m_iterations;
2207         if (m_iterations &lt; 2)
2208             return StackVisitor::Continue;
2209 
2210         m_codeBlock = visitor-&gt;codeBlock();
2211         return StackVisitor::Done;
2212     }
2213 
2214     CodeBlock* codeBlock() const { return m_codeBlock; }
2215 
2216 private:
2217     mutable int m_iterations;
2218     mutable CodeBlock* m_codeBlock;
2219 };
2220 
2221 String Internals::parserMetaData(JSC::JSValue code)
2222 {
2223     JSC::VM&amp; vm = contextDocument()-&gt;vm();
2224     JSC::CallFrame* callFrame = vm.topCallFrame;
2225     JSC::JSGlobalObject* globalObject = callFrame-&gt;lexicalGlobalObject(vm);
2226     ScriptExecutable* executable;
2227 
2228     if (!code || code.isNull() || code.isUndefined()) {
2229         GetCallerCodeBlockFunctor iter;
2230         callFrame-&gt;iterate(vm, iter);
2231         CodeBlock* codeBlock = iter.codeBlock();
2232         executable = codeBlock-&gt;ownerExecutable();
2233     } else if (code.isFunction(vm)) {
2234         JSFunction* funcObj = JSC::jsCast&lt;JSFunction*&gt;(code.toObject(globalObject));
2235         executable = funcObj-&gt;jsExecutable();
2236     } else
2237         return String();
2238 
2239     unsigned startLine = executable-&gt;firstLine();
2240     unsigned startColumn = executable-&gt;startColumn();
2241     unsigned endLine = executable-&gt;lastLine();
2242     unsigned endColumn = executable-&gt;endColumn();
2243 
2244     StringBuilder result;
2245 
2246     if (executable-&gt;isFunctionExecutable()) {
2247         FunctionExecutable* funcExecutable = reinterpret_cast&lt;FunctionExecutable*&gt;(executable);
2248         String inferredName = funcExecutable-&gt;ecmaName().string();
2249         result.appendLiteral(&quot;function \&quot;&quot;);
2250         result.append(inferredName);
2251         result.append(&#39;&quot;&#39;);
2252     } else if (executable-&gt;isEvalExecutable())
2253         result.appendLiteral(&quot;eval&quot;);
2254     else if (executable-&gt;isModuleProgramExecutable())
2255         result.appendLiteral(&quot;module&quot;);
2256     else if (executable-&gt;isProgramExecutable())
2257         result.appendLiteral(&quot;program&quot;);
2258     else
2259         ASSERT_NOT_REACHED();
2260 
2261     result.appendLiteral(&quot; { &quot;);
2262     result.appendNumber(startLine);
2263     result.append(&#39;:&#39;);
2264     result.appendNumber(startColumn);
2265     result.appendLiteral(&quot; - &quot;);
2266     result.appendNumber(endLine);
2267     result.append(&#39;:&#39;);
2268     result.appendNumber(endColumn);
2269     result.appendLiteral(&quot; }&quot;);
2270 
2271     return result.toString();
2272 }
2273 
2274 void Internals::updateEditorUINowIfScheduled()
2275 {
2276     if (Document* document = contextDocument()) {
2277         if (Frame* frame = document-&gt;frame())
2278             frame-&gt;editor().updateEditorUINowIfScheduled();
2279     }
2280 }
2281 
2282 bool Internals::hasSpellingMarker(int from, int length)
2283 {
2284     Document* document = contextDocument();
2285     if (!document || !document-&gt;frame())
2286         return false;
2287 
2288     updateEditorUINowIfScheduled();
2289 
2290     return document-&gt;frame()-&gt;editor().selectionStartHasMarkerFor(DocumentMarker::Spelling, from, length);
2291 }
2292 
2293 bool Internals::hasAutocorrectedMarker(int from, int length)
2294 {
2295     Document* document = contextDocument();
2296     if (!document || !document-&gt;frame())
2297         return false;
2298 
2299     updateEditorUINowIfScheduled();
2300 
2301     return document-&gt;frame()-&gt;editor().selectionStartHasMarkerFor(DocumentMarker::Autocorrected, from, length);
2302 }
2303 
2304 void Internals::setContinuousSpellCheckingEnabled(bool enabled)
2305 {
2306     if (!contextDocument() || !contextDocument()-&gt;frame())
2307         return;
2308 
2309     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isContinuousSpellCheckingEnabled())
2310         contextDocument()-&gt;frame()-&gt;editor().toggleContinuousSpellChecking();
2311 }
2312 
2313 void Internals::setAutomaticQuoteSubstitutionEnabled(bool enabled)
2314 {
2315     if (!contextDocument() || !contextDocument()-&gt;frame())
2316         return;
2317 
2318 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2319     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticQuoteSubstitutionEnabled())
2320         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticQuoteSubstitution();
2321 #else
2322     UNUSED_PARAM(enabled);
2323 #endif
2324 }
2325 
2326 void Internals::setAutomaticLinkDetectionEnabled(bool enabled)
2327 {
2328     if (!contextDocument() || !contextDocument()-&gt;frame())
2329         return;
2330 
2331 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2332     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticLinkDetectionEnabled())
2333         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticLinkDetection();
2334 #else
2335     UNUSED_PARAM(enabled);
2336 #endif
2337 }
2338 
2339 bool Internals::testProcessIncomingSyncMessagesWhenWaitingForSyncReply()
2340 {
2341     ASSERT(contextDocument());
2342     ASSERT(contextDocument()-&gt;page());
2343     return contextDocument()-&gt;page()-&gt;chrome().client().testProcessIncomingSyncMessagesWhenWaitingForSyncReply();
2344 }
2345 
2346 void Internals::setAutomaticDashSubstitutionEnabled(bool enabled)
2347 {
2348     if (!contextDocument() || !contextDocument()-&gt;frame())
2349         return;
2350 
2351 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2352     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticDashSubstitutionEnabled())
2353         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticDashSubstitution();
2354 #else
2355     UNUSED_PARAM(enabled);
2356 #endif
2357 }
2358 
2359 void Internals::setAutomaticTextReplacementEnabled(bool enabled)
2360 {
2361     if (!contextDocument() || !contextDocument()-&gt;frame())
2362         return;
2363 
2364 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2365     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticTextReplacementEnabled())
2366         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticTextReplacement();
2367 #else
2368     UNUSED_PARAM(enabled);
2369 #endif
2370 }
2371 
2372 void Internals::setAutomaticSpellingCorrectionEnabled(bool enabled)
2373 {
2374     if (!contextDocument() || !contextDocument()-&gt;frame())
2375         return;
2376 
2377 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2378     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticSpellingCorrectionEnabled())
2379         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticSpellingCorrection();
2380 #else
2381     UNUSED_PARAM(enabled);
2382 #endif
2383 }
2384 
2385 void Internals::handleAcceptedCandidate(const String&amp; candidate, unsigned location, unsigned length)
2386 {
2387     if (!contextDocument() || !contextDocument()-&gt;frame())
2388         return;
2389 
2390     TextCheckingResult result;
2391     result.type = TextCheckingType::None;
2392     result.location = location;
2393     result.length = length;
2394     result.replacement = candidate;
2395     contextDocument()-&gt;frame()-&gt;editor().handleAcceptedCandidate(result);
2396 }
2397 
2398 void Internals::changeSelectionListType()
2399 {
2400     if (auto frame = makeRefPtr(this-&gt;frame()))
2401         frame-&gt;editor().changeSelectionListType();
2402 }
2403 
2404 bool Internals::isOverwriteModeEnabled()
2405 {
2406     Document* document = contextDocument();
2407     if (!document || !document-&gt;frame())
2408         return false;
2409 
2410     return document-&gt;frame()-&gt;editor().isOverwriteModeEnabled();
2411 }
2412 
2413 void Internals::toggleOverwriteModeEnabled()
2414 {
2415     Document* document = contextDocument();
2416     if (!document || !document-&gt;frame())
2417         return;
2418 
2419     document-&gt;frame()-&gt;editor().toggleOverwriteModeEnabled();
2420 }
2421 
2422 static ExceptionOr&lt;FindOptions&gt; parseFindOptions(const Vector&lt;String&gt;&amp; optionList)
2423 {
2424     const struct {
2425         const char* name;
2426         FindOptionFlag value;
2427     } flagList[] = {
2428         {&quot;CaseInsensitive&quot;, CaseInsensitive},
2429         {&quot;AtWordStarts&quot;, AtWordStarts},
2430         {&quot;TreatMedialCapitalAsWordStart&quot;, TreatMedialCapitalAsWordStart},
2431         {&quot;Backwards&quot;, Backwards},
2432         {&quot;WrapAround&quot;, WrapAround},
2433         {&quot;StartInSelection&quot;, StartInSelection},
2434         {&quot;DoNotRevealSelection&quot;, DoNotRevealSelection},
2435         {&quot;AtWordEnds&quot;, AtWordEnds},
2436         {&quot;DoNotTraverseFlatTree&quot;, DoNotTraverseFlatTree},
2437     };
2438     FindOptions result;
2439     for (auto&amp; option : optionList) {
2440         bool found = false;
2441         for (auto&amp; flag : flagList) {
2442             if (flag.name == option) {
2443                 result.add(flag.value);
2444                 found = true;
2445                 break;
2446             }
2447         }
2448         if (!found)
2449             return Exception { SyntaxError };
2450     }
2451     return result;
2452 }
2453 
2454 ExceptionOr&lt;RefPtr&lt;Range&gt;&gt; Internals::rangeOfString(const String&amp; text, RefPtr&lt;Range&gt;&amp;&amp; referenceRange, const Vector&lt;String&gt;&amp; findOptions)
2455 {
2456     Document* document = contextDocument();
2457     if (!document || !document-&gt;frame())
2458         return Exception { InvalidAccessError };
2459 
2460     auto parsedOptions = parseFindOptions(findOptions);
2461     if (parsedOptions.hasException())
2462         return parsedOptions.releaseException();
2463 
2464     return document-&gt;frame()-&gt;editor().rangeOfString(text, referenceRange.get(), parsedOptions.releaseReturnValue());
2465 }
2466 
2467 ExceptionOr&lt;unsigned&gt; Internals::countMatchesForText(const String&amp; text, const Vector&lt;String&gt;&amp; findOptions, const String&amp; markMatches)
2468 {
2469     Document* document = contextDocument();
2470     if (!document || !document-&gt;frame())
2471         return Exception { InvalidAccessError };
2472 
2473     auto parsedOptions = parseFindOptions(findOptions);
2474     if (parsedOptions.hasException())
2475         return parsedOptions.releaseException();
2476 
2477     bool mark = markMatches == &quot;mark&quot;;
2478     return document-&gt;frame()-&gt;editor().countMatchesForText(text, nullptr, parsedOptions.releaseReturnValue(), 1000, mark, nullptr);
2479 }
2480 
2481 ExceptionOr&lt;unsigned&gt; Internals::countFindMatches(const String&amp; text, const Vector&lt;String&gt;&amp; findOptions)
2482 {
2483     Document* document = contextDocument();
2484     if (!document || !document-&gt;page())
2485         return Exception { InvalidAccessError };
2486 
2487     auto parsedOptions = parseFindOptions(findOptions);
2488     if (parsedOptions.hasException())
2489         return parsedOptions.releaseException();
2490 
2491     return document-&gt;page()-&gt;countFindMatches(text, parsedOptions.releaseReturnValue(), 1000);
2492 }
2493 
2494 #if ENABLE(INDEXED_DATABASE)
2495 unsigned Internals::numberOfIDBTransactions() const
2496 {
2497 #if ENABLE(INDEXED_DATABASE)
2498     return IDBTransaction::numberOfIDBTransactions;
2499 #else
2500     return 0;
2501 #endif
2502 }
2503 #endif
2504 
2505 unsigned Internals::numberOfLiveNodes() const
2506 {
2507     unsigned nodeCount = 0;
2508     for (auto* document : Document::allDocuments())
2509         nodeCount += document-&gt;referencingNodeCount();
2510     return nodeCount;
2511 }
2512 
2513 unsigned Internals::numberOfLiveDocuments() const
2514 {
2515     return Document::allDocuments().size();
2516 }
2517 
2518 unsigned Internals::referencingNodeCount(const Document&amp; document) const
2519 {
2520     return document.referencingNodeCount();
2521 }
2522 
2523 #if ENABLE(INTERSECTION_OBSERVER)
2524 unsigned Internals::numberOfIntersectionObservers(const Document&amp; document) const
2525 {
2526     return document.numberOfIntersectionObservers();
2527 }
2528 #endif
2529 
2530 uint64_t Internals::documentIdentifier(const Document&amp; document) const
2531 {
2532     return document.identifier().toUInt64();
2533 }
2534 
2535 bool Internals::isDocumentAlive(uint64_t documentIdentifier) const
2536 {
2537     return Document::allDocumentsMap().contains(makeObjectIdentifier&lt;DocumentIdentifierType&gt;(documentIdentifier));
2538 }
2539 
2540 uint64_t Internals::storageAreaMapCount() const
2541 {
2542     auto* page = contextDocument() ? contextDocument()-&gt;page() : nullptr;
2543     if (!page)
2544         return 0;
2545 
2546     return page-&gt;storageNamespaceProvider().localStorageNamespace(page-&gt;sessionID()).storageAreaMapCountForTesting();
2547 }
2548 
2549 uint64_t Internals::elementIdentifier(Element&amp; element) const
2550 {
2551     return element.document().identifierForElement(element).toUInt64();
2552 }
2553 
2554 uint64_t Internals::frameIdentifier(const Document&amp; document) const
2555 {
2556     if (auto* page = document.page())
2557         return page-&gt;mainFrame().loader().client().frameID().valueOr(FrameIdentifier { }).toUInt64();
2558     return 0;
2559 }
2560 
2561 uint64_t Internals::pageIdentifier(const Document&amp; document) const
2562 {
2563     return document.pageID().valueOr(PageIdentifier { }).toUInt64();
2564 }
2565 
2566 bool Internals::isAnyWorkletGlobalScopeAlive() const
2567 {
2568 #if ENABLE(CSS_PAINTING_API)
2569     return !WorkletGlobalScope::allWorkletGlobalScopesSet().isEmpty();
2570 #else
2571     return false;
2572 #endif
2573 }
2574 
2575 String Internals::serviceWorkerClientIdentifier(const Document&amp; document) const
2576 {
2577 #if ENABLE(SERVICE_WORKER)
2578     return ServiceWorkerClientIdentifier { ServiceWorkerProvider::singleton().serviceWorkerConnection().serverConnectionIdentifier(), document.identifier() }.toString();
2579 #else
2580     UNUSED_PARAM(document);
2581     return String();
2582 #endif
2583 }
2584 
2585 RefPtr&lt;WindowProxy&gt; Internals::openDummyInspectorFrontend(const String&amp; url)
2586 {
2587     auto* inspectedPage = contextDocument()-&gt;frame()-&gt;page();
2588     auto* window = inspectedPage-&gt;mainFrame().document()-&gt;domWindow();
2589     auto frontendWindowProxy = window-&gt;open(*window, *window, url, &quot;&quot;, &quot;&quot;).releaseReturnValue();
2590     m_inspectorFrontend = makeUnique&lt;InspectorStubFrontend&gt;(*inspectedPage, downcast&lt;DOMWindow&gt;(frontendWindowProxy-&gt;window()));
2591     return frontendWindowProxy;
2592 }
2593 
2594 void Internals::closeDummyInspectorFrontend()
2595 {
2596     m_inspectorFrontend = nullptr;
2597 }
2598 
2599 ExceptionOr&lt;void&gt; Internals::setInspectorIsUnderTest(bool isUnderTest)
2600 {
2601     Page* page = contextDocument()-&gt;frame()-&gt;page();
2602     if (!page)
2603         return Exception { InvalidAccessError };
2604 
2605     page-&gt;inspectorController().setIsUnderTest(isUnderTest);
2606     return { };
2607 }
2608 
2609 bool Internals::hasGrammarMarker(int from, int length)
2610 {
2611     Document* document = contextDocument();
2612     if (!document || !document-&gt;frame())
2613         return false;
2614 
2615     return document-&gt;frame()-&gt;editor().selectionStartHasMarkerFor(DocumentMarker::Grammar, from, length);
2616 }
2617 
2618 unsigned Internals::numberOfScrollableAreas()
2619 {
2620     Document* document = contextDocument();
2621     if (!document || !document-&gt;frame())
2622         return 0;
2623 
2624     unsigned count = 0;
2625     Frame* frame = document-&gt;frame();
2626     if (frame-&gt;view()-&gt;scrollableAreas())
2627         count += frame-&gt;view()-&gt;scrollableAreas()-&gt;size();
2628 
2629     for (Frame* child = frame-&gt;tree().firstChild(); child; child = child-&gt;tree().nextSibling()) {
2630         if (child-&gt;view() &amp;&amp; child-&gt;view()-&gt;scrollableAreas())
2631             count += child-&gt;view()-&gt;scrollableAreas()-&gt;size();
2632     }
2633 
2634     return count;
2635 }
2636 
2637 ExceptionOr&lt;bool&gt; Internals::isPageBoxVisible(int pageNumber)
2638 {
2639     Document* document = contextDocument();
2640     if (!document)
2641         return Exception { InvalidAccessError };
2642 
2643     return document-&gt;isPageBoxVisible(pageNumber);
2644 }
2645 
2646 static LayerTreeFlags toLayerTreeFlags(unsigned short flags)
2647 {
2648     LayerTreeFlags layerTreeFlags = 0;
2649     if (flags &amp; Internals::LAYER_TREE_INCLUDES_VISIBLE_RECTS)
2650         layerTreeFlags |= LayerTreeFlagsIncludeVisibleRects;
2651     if (flags &amp; Internals::LAYER_TREE_INCLUDES_TILE_CACHES)
2652         layerTreeFlags |= LayerTreeFlagsIncludeTileCaches;
2653     if (flags &amp; Internals::LAYER_TREE_INCLUDES_REPAINT_RECTS)
2654         layerTreeFlags |= LayerTreeFlagsIncludeRepaintRects;
2655     if (flags &amp; Internals::LAYER_TREE_INCLUDES_PAINTING_PHASES)
2656         layerTreeFlags |= LayerTreeFlagsIncludePaintingPhases;
2657     if (flags &amp; Internals::LAYER_TREE_INCLUDES_CONTENT_LAYERS)
2658         layerTreeFlags |= LayerTreeFlagsIncludeContentLayers;
2659     if (flags &amp; Internals::LAYER_TREE_INCLUDES_ACCELERATES_DRAWING)
2660         layerTreeFlags |= LayerTreeFlagsIncludeAcceleratesDrawing;
2661     if (flags &amp; Internals::LAYER_TREE_INCLUDES_CLIPPING)
2662         layerTreeFlags |= LayerTreeFlagsIncludeClipping;
2663     if (flags &amp; Internals::LAYER_TREE_INCLUDES_BACKING_STORE_ATTACHED)
2664         layerTreeFlags |= LayerTreeFlagsIncludeBackingStoreAttached;
2665     if (flags &amp; Internals::LAYER_TREE_INCLUDES_ROOT_LAYER_PROPERTIES)
2666         layerTreeFlags |= LayerTreeFlagsIncludeRootLayerProperties;
2667     if (flags &amp; Internals::LAYER_TREE_INCLUDES_EVENT_REGION)
2668         layerTreeFlags |= LayerTreeFlagsIncludeEventRegion;
2669     if (flags &amp; Internals::LAYER_TREE_INCLUDES_DEEP_COLOR)
2670         layerTreeFlags |= LayerTreeFlagsIncludeDeepColor;
2671 
2672     return layerTreeFlags;
2673 }
2674 
2675 // FIXME: Remove the document argument. It is almost always the same as
2676 // contextDocument(), with the exception of a few tests that pass a
2677 // different document, and could just make the call through another Internals
2678 // instance instead.
2679 ExceptionOr&lt;String&gt; Internals::layerTreeAsText(Document&amp; document, unsigned short flags) const
2680 {
2681     if (!document.frame())
2682         return Exception { InvalidAccessError };
2683 
2684     document.updateLayoutIgnorePendingStylesheets();
2685     return document.frame()-&gt;layerTreeAsText(toLayerTreeFlags(flags));
2686 }
2687 
2688 ExceptionOr&lt;uint64_t&gt; Internals::layerIDForElement(Element&amp; element)
2689 {
2690     Document* document = contextDocument();
2691     if (!document || !document-&gt;frame())
2692         return Exception { InvalidAccessError };
2693 
2694     element.document().updateLayoutIgnorePendingStylesheets();
2695 
2696     if (!element.renderer() || !element.renderer()-&gt;hasLayer())
2697         return Exception { NotFoundError };
2698 
2699     auto&amp; layerModelObject = downcast&lt;RenderLayerModelObject&gt;(*element.renderer());
2700     if (!layerModelObject.layer()-&gt;isComposited())
2701         return Exception { NotFoundError };
2702 
2703     auto* backing = layerModelObject.layer()-&gt;backing();
2704     return backing-&gt;graphicsLayer()-&gt;primaryLayerID();
2705 }
2706 
2707 ExceptionOr&lt;String&gt; Internals::repaintRectsAsText() const
2708 {
2709     Document* document = contextDocument();
2710     if (!document || !document-&gt;frame())
2711         return Exception { InvalidAccessError };
2712 
2713     return document-&gt;frame()-&gt;trackedRepaintRectsAsText();
2714 }
2715 
2716 ExceptionOr&lt;String&gt; Internals::scrollbarOverlayStyle(Node* node) const
2717 {
2718     if (!node)
2719         node = contextDocument();
2720 
2721     if (!node)
2722         return Exception { InvalidAccessError };
2723 
2724     node-&gt;document().updateLayoutIgnorePendingStylesheets();
2725 
2726     ScrollableArea* scrollableArea = nullptr;
2727     if (is&lt;Document&gt;(*node)) {
2728         auto* frameView = downcast&lt;Document&gt;(node)-&gt;view();
2729         if (!frameView)
2730             return Exception { InvalidAccessError };
2731 
2732         scrollableArea = frameView;
2733     } else if (is&lt;Element&gt;(*node)) {
2734         auto&amp; element = *downcast&lt;Element&gt;(node);
2735         if (!element.renderBox())
2736             return Exception { InvalidAccessError };
2737 
2738         scrollableArea = element.renderBox()-&gt;layer();
2739     } else
2740         return Exception { InvalidNodeTypeError };
2741 
2742     if (!scrollableArea)
2743         return Exception { InvalidNodeTypeError };
2744 
2745     switch (scrollableArea-&gt;scrollbarOverlayStyle()) {
2746     case ScrollbarOverlayStyleDefault:
2747         return &quot;default&quot;_str;
2748     case ScrollbarOverlayStyleDark:
2749         return &quot;dark&quot;_str;
2750     case ScrollbarOverlayStyleLight:
2751         return &quot;light&quot;_str;
2752     }
2753 
2754     ASSERT_NOT_REACHED();
2755     return &quot;unknown&quot;_str;
2756 }
2757 
2758 ExceptionOr&lt;bool&gt; Internals::scrollbarUsingDarkAppearance(Node* node) const
2759 {
2760     if (!node)
2761         node = contextDocument();
2762 
2763     if (!node)
2764         return Exception { InvalidAccessError };
2765 
2766     node-&gt;document().updateLayoutIgnorePendingStylesheets();
2767 
2768     ScrollableArea* scrollableArea = nullptr;
2769     if (is&lt;Document&gt;(*node)) {
2770         auto* frameView = downcast&lt;Document&gt;(node)-&gt;view();
2771         if (!frameView)
2772             return Exception { InvalidAccessError };
2773 
2774         scrollableArea = frameView;
2775     } else if (is&lt;Element&gt;(*node)) {
2776         auto&amp; element = *downcast&lt;Element&gt;(node);
2777         if (!element.renderBox())
2778             return Exception { InvalidAccessError };
2779 
2780         scrollableArea = element.renderBox()-&gt;layer();
2781     } else
2782         return Exception { InvalidNodeTypeError };
2783 
2784     if (!scrollableArea)
2785         return Exception { InvalidNodeTypeError };
2786 
2787     return scrollableArea-&gt;useDarkAppearance();
2788 }
2789 
2790 ExceptionOr&lt;String&gt; Internals::scrollingStateTreeAsText() const
2791 {
2792     Document* document = contextDocument();
2793     if (!document || !document-&gt;frame())
2794         return Exception { InvalidAccessError };
2795 
2796     document-&gt;updateLayoutIgnorePendingStylesheets();
2797 
2798     Page* page = document-&gt;page();
2799     if (!page)
2800         return String();
2801 
2802     return page-&gt;scrollingStateTreeAsText();
2803 }
2804 
2805 ExceptionOr&lt;String&gt; Internals::mainThreadScrollingReasons() const
2806 {
2807     Document* document = contextDocument();
2808     if (!document || !document-&gt;frame())
2809         return Exception { InvalidAccessError };
2810 
2811     Page* page = document-&gt;page();
2812     if (!page)
2813         return String();
2814 
2815     return page-&gt;synchronousScrollingReasonsAsText();
2816 }
2817 
2818 ExceptionOr&lt;Ref&lt;DOMRectList&gt;&gt; Internals::nonFastScrollableRects() const
2819 {
2820     Document* document = contextDocument();
2821     if (!document || !document-&gt;frame())
2822         return Exception { InvalidAccessError };
2823 
2824     Page* page = document-&gt;page();
2825     if (!page)
2826         return DOMRectList::create();
2827 
2828     return page-&gt;nonFastScrollableRects();
2829 }
2830 
2831 ExceptionOr&lt;void&gt; Internals::setElementUsesDisplayListDrawing(Element&amp; element, bool usesDisplayListDrawing)
2832 {
2833     Document* document = contextDocument();
2834     if (!document || !document-&gt;renderView())
2835         return Exception { InvalidAccessError };
2836 
2837     element.document().updateLayoutIgnorePendingStylesheets();
2838 
2839     if (!element.renderer())
2840         return Exception { InvalidAccessError };
2841 
2842     if (is&lt;HTMLCanvasElement&gt;(element)) {
2843         downcast&lt;HTMLCanvasElement&gt;(element).setUsesDisplayListDrawing(usesDisplayListDrawing);
2844         return { };
2845     }
2846 
2847     if (!element.renderer()-&gt;hasLayer())
2848         return Exception { InvalidAccessError };
2849 
2850     RenderLayer* layer = downcast&lt;RenderLayerModelObject&gt;(element.renderer())-&gt;layer();
2851     if (!layer-&gt;isComposited())
2852         return Exception { InvalidAccessError };
2853 
2854     layer-&gt;backing()-&gt;setUsesDisplayListDrawing(usesDisplayListDrawing);
2855     return { };
2856 }
2857 
2858 ExceptionOr&lt;void&gt; Internals::setElementTracksDisplayListReplay(Element&amp; element, bool isTrackingReplay)
2859 {
2860     Document* document = contextDocument();
2861     if (!document || !document-&gt;renderView())
2862         return Exception { InvalidAccessError };
2863 
2864     element.document().updateLayoutIgnorePendingStylesheets();
2865 
2866     if (!element.renderer())
2867         return Exception { InvalidAccessError };
2868 
2869     if (is&lt;HTMLCanvasElement&gt;(element)) {
2870         downcast&lt;HTMLCanvasElement&gt;(element).setTracksDisplayListReplay(isTrackingReplay);
2871         return { };
2872     }
2873 
2874     if (!element.renderer()-&gt;hasLayer())
2875         return Exception { InvalidAccessError };
2876 
2877     RenderLayer* layer = downcast&lt;RenderLayerModelObject&gt;(element.renderer())-&gt;layer();
2878     if (!layer-&gt;isComposited())
2879         return Exception { InvalidAccessError };
2880 
2881     layer-&gt;backing()-&gt;setIsTrackingDisplayListReplay(isTrackingReplay);
2882     return { };
2883 }
2884 
2885 ExceptionOr&lt;String&gt; Internals::displayListForElement(Element&amp; element, unsigned short flags)
2886 {
2887     Document* document = contextDocument();
2888     if (!document || !document-&gt;renderView())
2889         return Exception { InvalidAccessError };
2890 
2891     element.document().updateLayoutIgnorePendingStylesheets();
2892 
2893     if (!element.renderer())
2894         return Exception { InvalidAccessError };
2895 
2896     DisplayList::AsTextFlags displayListFlags = 0;
2897     if (flags &amp; DISPLAY_LIST_INCLUDES_PLATFORM_OPERATIONS)
2898         displayListFlags |= DisplayList::AsTextFlag::IncludesPlatformOperations;
2899 
2900     if (is&lt;HTMLCanvasElement&gt;(element))
2901         return downcast&lt;HTMLCanvasElement&gt;(element).displayListAsText(displayListFlags);
2902 
2903     if (!element.renderer()-&gt;hasLayer())
2904         return Exception { InvalidAccessError };
2905 
2906     RenderLayer* layer = downcast&lt;RenderLayerModelObject&gt;(element.renderer())-&gt;layer();
2907     if (!layer-&gt;isComposited())
2908         return Exception { InvalidAccessError };
2909 
2910     return layer-&gt;backing()-&gt;displayListAsText(displayListFlags);
2911 }
2912 
2913 ExceptionOr&lt;String&gt; Internals::replayDisplayListForElement(Element&amp; element, unsigned short flags)
2914 {
2915     Document* document = contextDocument();
2916     if (!document || !document-&gt;renderView())
2917         return Exception { InvalidAccessError };
2918 
2919     element.document().updateLayoutIgnorePendingStylesheets();
2920 
2921     if (!element.renderer())
2922         return Exception { InvalidAccessError };
2923 
2924     DisplayList::AsTextFlags displayListFlags = 0;
2925     if (flags &amp; DISPLAY_LIST_INCLUDES_PLATFORM_OPERATIONS)
2926         displayListFlags |= DisplayList::AsTextFlag::IncludesPlatformOperations;
2927 
2928     if (is&lt;HTMLCanvasElement&gt;(element))
2929         return downcast&lt;HTMLCanvasElement&gt;(element).replayDisplayListAsText(displayListFlags);
2930 
2931     if (!element.renderer()-&gt;hasLayer())
2932         return Exception { InvalidAccessError };
2933 
2934     RenderLayer* layer = downcast&lt;RenderLayerModelObject&gt;(element.renderer())-&gt;layer();
2935     if (!layer-&gt;isComposited())
2936         return Exception { InvalidAccessError };
2937 
2938     return layer-&gt;backing()-&gt;replayDisplayListAsText(displayListFlags);
2939 }
2940 
2941 ExceptionOr&lt;void&gt; Internals::garbageCollectDocumentResources() const
2942 {
2943     Document* document = contextDocument();
2944     if (!document)
2945         return Exception { InvalidAccessError };
2946     document-&gt;cachedResourceLoader().garbageCollectDocumentResources();
2947     return { };
2948 }
2949 
2950 bool Internals::isUnderMemoryPressure()
2951 {
2952     return MemoryPressureHandler::singleton().isUnderMemoryPressure();
2953 }
2954 
2955 void Internals::beginSimulatedMemoryPressure()
2956 {
2957     MemoryPressureHandler::singleton().beginSimulatedMemoryPressure();
2958 }
2959 
2960 void Internals::endSimulatedMemoryPressure()
2961 {
2962     MemoryPressureHandler::singleton().endSimulatedMemoryPressure();
2963 }
2964 
2965 ExceptionOr&lt;void&gt; Internals::insertAuthorCSS(const String&amp; css) const
2966 {
2967     Document* document = contextDocument();
2968     if (!document)
2969         return Exception { InvalidAccessError };
2970 
2971     auto parsedSheet = StyleSheetContents::create(*document);
2972     parsedSheet.get().setIsUserStyleSheet(false);
2973     parsedSheet.get().parseString(css);
2974     document-&gt;extensionStyleSheets().addAuthorStyleSheetForTesting(WTFMove(parsedSheet));
2975     return { };
2976 }
2977 
2978 ExceptionOr&lt;void&gt; Internals::insertUserCSS(const String&amp; css) const
2979 {
2980     Document* document = contextDocument();
2981     if (!document)
2982         return Exception { InvalidAccessError };
2983 
2984     auto parsedSheet = StyleSheetContents::create(*document);
2985     parsedSheet.get().setIsUserStyleSheet(true);
2986     parsedSheet.get().parseString(css);
2987     document-&gt;extensionStyleSheets().addUserStyleSheet(WTFMove(parsedSheet));
2988     return { };
2989 }
2990 
2991 String Internals::counterValue(Element&amp; element)
2992 {
2993     return counterValueForElement(&amp;element);
2994 }
2995 
2996 int Internals::pageNumber(Element&amp; element, float pageWidth, float pageHeight)
2997 {
2998     return PrintContext::pageNumberForElement(&amp;element, { pageWidth, pageHeight });
2999 }
3000 
3001 Vector&lt;String&gt; Internals::shortcutIconURLs() const
3002 {
3003     if (!frame())
3004         return { };
3005 
3006     auto* documentLoader = frame()-&gt;loader().documentLoader();
3007     if (!documentLoader)
3008         return { };
3009 
3010     Vector&lt;String&gt; result;
3011     for (auto&amp; linkIcon : documentLoader-&gt;linkIcons())
3012         result.append(linkIcon.url.string());
3013 
3014     return result;
3015 }
3016 
3017 int Internals::numberOfPages(float pageWidth, float pageHeight)
3018 {
3019     if (!frame())
3020         return -1;
3021 
3022     return PrintContext::numberOfPages(*frame(), FloatSize(pageWidth, pageHeight));
3023 }
3024 
3025 ExceptionOr&lt;String&gt; Internals::pageProperty(const String&amp; propertyName, int pageNumber) const
3026 {
3027     if (!frame())
3028         return Exception { InvalidAccessError };
3029 
3030     return PrintContext::pageProperty(frame(), propertyName.utf8().data(), pageNumber);
3031 }
3032 
3033 ExceptionOr&lt;String&gt; Internals::pageSizeAndMarginsInPixels(int pageNumber, int width, int height, int marginTop, int marginRight, int marginBottom, int marginLeft) const
3034 {
3035     if (!frame())
3036         return Exception { InvalidAccessError };
3037 
3038     return PrintContext::pageSizeAndMarginsInPixels(frame(), pageNumber, width, height, marginTop, marginRight, marginBottom, marginLeft);
3039 }
3040 
3041 ExceptionOr&lt;float&gt; Internals::pageScaleFactor() const
3042 {
3043     Document* document = contextDocument();
3044     if (!document || !document-&gt;page())
3045         return Exception { InvalidAccessError };
3046 
3047     return document-&gt;page()-&gt;pageScaleFactor();
3048 }
3049 
3050 ExceptionOr&lt;void&gt; Internals::setPageScaleFactor(float scaleFactor, int x, int y)
3051 {
3052     Document* document = contextDocument();
3053     if (!document || !document-&gt;page())
3054         return Exception { InvalidAccessError };
3055 
3056     document-&gt;page()-&gt;setPageScaleFactor(scaleFactor, IntPoint(x, y));
3057     return { };
3058 }
3059 
3060 ExceptionOr&lt;void&gt; Internals::setPageZoomFactor(float zoomFactor)
3061 {
3062     Document* document = contextDocument();
3063     if (!document || !document-&gt;frame())
3064         return Exception { InvalidAccessError };
3065 
3066     document-&gt;frame()-&gt;setPageZoomFactor(zoomFactor);
3067     return { };
3068 }
3069 
3070 ExceptionOr&lt;void&gt; Internals::setTextZoomFactor(float zoomFactor)
3071 {
3072     Document* document = contextDocument();
3073     if (!document || !document-&gt;frame())
3074         return Exception { InvalidAccessError };
3075 
3076     document-&gt;frame()-&gt;setTextZoomFactor(zoomFactor);
3077     return { };
3078 }
3079 
3080 ExceptionOr&lt;void&gt; Internals::setUseFixedLayout(bool useFixedLayout)
3081 {
3082     Document* document = contextDocument();
3083     if (!document || !document-&gt;view())
3084         return Exception { InvalidAccessError };
3085 
3086     document-&gt;view()-&gt;setUseFixedLayout(useFixedLayout);
3087     return { };
3088 }
3089 
3090 ExceptionOr&lt;void&gt; Internals::setFixedLayoutSize(int width, int height)
3091 {
3092     Document* document = contextDocument();
3093     if (!document || !document-&gt;view())
3094         return Exception { InvalidAccessError };
3095 
3096     document-&gt;view()-&gt;setFixedLayoutSize(IntSize(width, height));
3097     return { };
3098 }
3099 
3100 ExceptionOr&lt;void&gt; Internals::setViewExposedRect(float x, float y, float width, float height)
3101 {
3102     Document* document = contextDocument();
3103     if (!document || !document-&gt;view())
3104         return Exception { InvalidAccessError };
3105 
3106     document-&gt;view()-&gt;setViewExposedRect(FloatRect(x, y, width, height));
3107     return { };
3108 }
3109 
3110 void Internals::setPrinting(int width, int height)
3111 {
3112     printContextForTesting() = makeUnique&lt;PrintContext&gt;(frame());
3113     printContextForTesting()-&gt;begin(width, height);
3114 }
3115 
3116 void Internals::setHeaderHeight(float height)
3117 {
3118     Document* document = contextDocument();
3119     if (!document || !document-&gt;view())
3120         return;
3121 
3122     document-&gt;page()-&gt;setHeaderHeight(height);
3123 }
3124 
3125 void Internals::setFooterHeight(float height)
3126 {
3127     Document* document = contextDocument();
3128     if (!document || !document-&gt;view())
3129         return;
3130 
3131     document-&gt;page()-&gt;setFooterHeight(height);
3132 }
3133 
3134 void Internals::setTopContentInset(float contentInset)
3135 {
3136     Document* document = contextDocument();
3137     if (!document || !document-&gt;page())
3138         return;
3139 
3140     document-&gt;page()-&gt;setTopContentInset(contentInset);
3141 }
3142 
3143 #if ENABLE(FULLSCREEN_API)
3144 
3145 void Internals::webkitWillEnterFullScreenForElement(Element&amp; element)
3146 {
3147     Document* document = contextDocument();
3148     if (!document)
3149         return;
3150     document-&gt;fullscreenManager().willEnterFullscreen(element);
3151 }
3152 
3153 void Internals::webkitDidEnterFullScreenForElement(Element&amp;)
3154 {
3155     Document* document = contextDocument();
3156     if (!document)
3157         return;
3158     document-&gt;fullscreenManager().didEnterFullscreen();
3159 }
3160 
3161 void Internals::webkitWillExitFullScreenForElement(Element&amp;)
3162 {
3163     Document* document = contextDocument();
3164     if (!document)
3165         return;
3166     document-&gt;fullscreenManager().willExitFullscreen();
3167 }
3168 
3169 void Internals::webkitDidExitFullScreenForElement(Element&amp;)
3170 {
3171     Document* document = contextDocument();
3172     if (!document)
3173         return;
3174     document-&gt;fullscreenManager().didExitFullscreen();
3175 }
3176 
3177 bool Internals::isAnimatingFullScreen() const
3178 {
3179     Document* document = contextDocument();
3180     if (!document)
3181         return false;
3182     return document-&gt;fullscreenManager().isAnimatingFullscreen();
3183 }
3184 
3185 #endif
3186 
3187 void Internals::setFullscreenInsets(FullscreenInsets insets)
3188 {
3189     Page* page = contextDocument()-&gt;frame()-&gt;page();
3190     ASSERT(page);
3191 
3192     page-&gt;setFullscreenInsets(FloatBoxExtent(insets.top, insets.right, insets.bottom, insets.left));
3193 }
3194 
3195 void Internals::setFullscreenAutoHideDuration(double duration)
3196 {
3197     Page* page = contextDocument()-&gt;frame()-&gt;page();
3198     ASSERT(page);
3199 
3200     page-&gt;setFullscreenAutoHideDuration(Seconds(duration));
3201 }
3202 
3203 void Internals::setFullscreenControlsHidden(bool hidden)
3204 {
3205     Page* page = contextDocument()-&gt;frame()-&gt;page();
3206     ASSERT(page);
3207 
3208     page-&gt;setFullscreenControlsHidden(hidden);
3209 }
3210 
3211 void Internals::setApplicationCacheOriginQuota(unsigned long long quota)
3212 {
3213     Document* document = contextDocument();
3214     if (!document || !document-&gt;page())
3215         return;
3216     document-&gt;page()-&gt;applicationCacheStorage().storeUpdatedQuotaForOrigin(&amp;document-&gt;securityOrigin(), quota);
3217 }
3218 
3219 void Internals::registerURLSchemeAsBypassingContentSecurityPolicy(const String&amp; scheme)
3220 {
3221     LegacySchemeRegistry::registerURLSchemeAsBypassingContentSecurityPolicy(scheme);
3222 }
3223 
3224 void Internals::removeURLSchemeRegisteredAsBypassingContentSecurityPolicy(const String&amp; scheme)
3225 {
3226     LegacySchemeRegistry::removeURLSchemeRegisteredAsBypassingContentSecurityPolicy(scheme);
3227 }
3228 
3229 void Internals::registerDefaultPortForProtocol(unsigned short port, const String&amp; protocol)
3230 {
3231     registerDefaultPortForProtocolForTesting(port, protocol);
3232 }
3233 
3234 Ref&lt;MallocStatistics&gt; Internals::mallocStatistics() const
3235 {
3236     return MallocStatistics::create();
3237 }
3238 
3239 Ref&lt;TypeConversions&gt; Internals::typeConversions() const
3240 {
3241     return TypeConversions::create();
3242 }
3243 
3244 Ref&lt;MemoryInfo&gt; Internals::memoryInfo() const
3245 {
3246     return MemoryInfo::create();
3247 }
3248 
3249 Vector&lt;String&gt; Internals::getReferencedFilePaths() const
3250 {
3251     frame()-&gt;loader().history().saveDocumentAndScrollState();
3252     return FormController::referencedFilePaths(frame()-&gt;loader().history().currentItem()-&gt;documentState());
3253 }
3254 
3255 ExceptionOr&lt;void&gt; Internals::startTrackingRepaints()
3256 {
3257     Document* document = contextDocument();
3258     if (!document || !document-&gt;view())
3259         return Exception { InvalidAccessError };
3260 
3261     document-&gt;view()-&gt;setTracksRepaints(true);
3262     return { };
3263 }
3264 
3265 ExceptionOr&lt;void&gt; Internals::stopTrackingRepaints()
3266 {
3267     Document* document = contextDocument();
3268     if (!document || !document-&gt;view())
3269         return Exception { InvalidAccessError };
3270 
3271     document-&gt;view()-&gt;setTracksRepaints(false);
3272     return { };
3273 }
3274 
3275 ExceptionOr&lt;void&gt; Internals::startTrackingLayerFlushes()
3276 {
3277     Document* document = contextDocument();
3278     if (!document || !document-&gt;renderView())
3279         return Exception { InvalidAccessError };
3280 
3281     document-&gt;renderView()-&gt;compositor().startTrackingLayerFlushes();
3282     return { };
3283 }
3284 
3285 ExceptionOr&lt;unsigned&gt; Internals::layerFlushCount()
3286 {
3287     Document* document = contextDocument();
3288     if (!document || !document-&gt;renderView())
3289         return Exception { InvalidAccessError };
3290 
3291     return document-&gt;renderView()-&gt;compositor().layerFlushCount();
3292 }
3293 
3294 ExceptionOr&lt;void&gt; Internals::startTrackingStyleRecalcs()
3295 {
3296     Document* document = contextDocument();
3297     if (!document)
3298         return Exception { InvalidAccessError };
3299 
3300     document-&gt;startTrackingStyleRecalcs();
3301     return { };
3302 }
3303 
3304 ExceptionOr&lt;unsigned&gt; Internals::styleRecalcCount()
3305 {
3306     Document* document = contextDocument();
3307     if (!document)
3308         return Exception { InvalidAccessError };
3309 
3310     return document-&gt;styleRecalcCount();
3311 }
3312 
3313 unsigned Internals::lastStyleUpdateSize() const
3314 {
3315     Document* document = contextDocument();
3316     if (!document)
3317         return 0;
3318     return document-&gt;lastStyleUpdateSizeForTesting();
3319 }
3320 
3321 ExceptionOr&lt;void&gt; Internals::startTrackingCompositingUpdates()
3322 {
3323     Document* document = contextDocument();
3324     if (!document || !document-&gt;renderView())
3325         return Exception { InvalidAccessError };
3326 
3327     document-&gt;renderView()-&gt;compositor().startTrackingCompositingUpdates();
3328     return { };
3329 }
3330 
3331 ExceptionOr&lt;unsigned&gt; Internals::compositingUpdateCount()
3332 {
3333     Document* document = contextDocument();
3334     if (!document || !document-&gt;renderView())
3335         return Exception { InvalidAccessError };
3336 
3337     return document-&gt;renderView()-&gt;compositor().compositingUpdateCount();
3338 }
3339 
3340 ExceptionOr&lt;void&gt; Internals::setCompositingPolicyOverride(Optional&lt;CompositingPolicy&gt; policyOverride)
3341 {
3342     Document* document = contextDocument();
3343     if (!document)
3344         return Exception { InvalidAccessError };
3345 
3346     if (!policyOverride) {
3347         document-&gt;page()-&gt;setCompositingPolicyOverride(WTF::nullopt);
3348         return { };
3349     }
3350 
3351     switch (policyOverride.value()) {
3352     case Internals::CompositingPolicy::Normal:
3353         document-&gt;page()-&gt;setCompositingPolicyOverride(WebCore::CompositingPolicy::Normal);
3354         break;
3355     case Internals::CompositingPolicy::Conservative:
3356         document-&gt;page()-&gt;setCompositingPolicyOverride(WebCore::CompositingPolicy::Conservative);
3357         break;
3358     }
3359 
3360     return { };
3361 }
3362 
3363 ExceptionOr&lt;Optional&lt;Internals::CompositingPolicy&gt;&gt; Internals::compositingPolicyOverride() const
3364 {
3365     Document* document = contextDocument();
3366     if (!document)
3367         return Exception { InvalidAccessError };
3368 
3369     auto policyOverride = document-&gt;page()-&gt;compositingPolicyOverride();
3370     if (!policyOverride)
3371         return { WTF::nullopt };
3372 
3373     switch (policyOverride.value()) {
3374     case WebCore::CompositingPolicy::Normal:
3375         return { Internals::CompositingPolicy::Normal };
3376     case WebCore::CompositingPolicy::Conservative:
3377         return { Internals::CompositingPolicy::Conservative };
3378     }
3379 
3380     return { Internals::CompositingPolicy::Normal };
3381 }
3382 
3383 ExceptionOr&lt;void&gt; Internals::updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks(Node* node)
3384 {
3385     Document* document;
3386     if (!node)
3387         document = contextDocument();
3388     else if (is&lt;Document&gt;(*node))
3389         document = downcast&lt;Document&gt;(node);
3390     else if (is&lt;HTMLIFrameElement&gt;(*node))
3391         document = downcast&lt;HTMLIFrameElement&gt;(*node).contentDocument();
3392     else
3393         return Exception { TypeError };
3394 
3395     document-&gt;updateLayoutIgnorePendingStylesheets(Document::RunPostLayoutTasks::Synchronously);
3396     return { };
3397 }
3398 
3399 unsigned Internals::layoutCount() const
3400 {
3401     Document* document = contextDocument();
3402     if (!document || !document-&gt;view())
3403         return 0;
3404     return document-&gt;view()-&gt;layoutContext().layoutCount();
3405 }
3406 
3407 #if !PLATFORM(IOS_FAMILY)
3408 static const char* cursorTypeToString(Cursor::Type cursorType)
3409 {
3410     switch (cursorType) {
3411     case Cursor::Pointer: return &quot;Pointer&quot;;
3412     case Cursor::Cross: return &quot;Cross&quot;;
3413     case Cursor::Hand: return &quot;Hand&quot;;
3414     case Cursor::IBeam: return &quot;IBeam&quot;;
3415     case Cursor::Wait: return &quot;Wait&quot;;
3416     case Cursor::Help: return &quot;Help&quot;;
3417     case Cursor::EastResize: return &quot;EastResize&quot;;
3418     case Cursor::NorthResize: return &quot;NorthResize&quot;;
3419     case Cursor::NorthEastResize: return &quot;NorthEastResize&quot;;
3420     case Cursor::NorthWestResize: return &quot;NorthWestResize&quot;;
3421     case Cursor::SouthResize: return &quot;SouthResize&quot;;
3422     case Cursor::SouthEastResize: return &quot;SouthEastResize&quot;;
3423     case Cursor::SouthWestResize: return &quot;SouthWestResize&quot;;
3424     case Cursor::WestResize: return &quot;WestResize&quot;;
3425     case Cursor::NorthSouthResize: return &quot;NorthSouthResize&quot;;
3426     case Cursor::EastWestResize: return &quot;EastWestResize&quot;;
3427     case Cursor::NorthEastSouthWestResize: return &quot;NorthEastSouthWestResize&quot;;
3428     case Cursor::NorthWestSouthEastResize: return &quot;NorthWestSouthEastResize&quot;;
3429     case Cursor::ColumnResize: return &quot;ColumnResize&quot;;
3430     case Cursor::RowResize: return &quot;RowResize&quot;;
3431     case Cursor::MiddlePanning: return &quot;MiddlePanning&quot;;
3432     case Cursor::EastPanning: return &quot;EastPanning&quot;;
3433     case Cursor::NorthPanning: return &quot;NorthPanning&quot;;
3434     case Cursor::NorthEastPanning: return &quot;NorthEastPanning&quot;;
3435     case Cursor::NorthWestPanning: return &quot;NorthWestPanning&quot;;
3436     case Cursor::SouthPanning: return &quot;SouthPanning&quot;;
3437     case Cursor::SouthEastPanning: return &quot;SouthEastPanning&quot;;
3438     case Cursor::SouthWestPanning: return &quot;SouthWestPanning&quot;;
3439     case Cursor::WestPanning: return &quot;WestPanning&quot;;
3440     case Cursor::Move: return &quot;Move&quot;;
3441     case Cursor::VerticalText: return &quot;VerticalText&quot;;
3442     case Cursor::Cell: return &quot;Cell&quot;;
3443     case Cursor::ContextMenu: return &quot;ContextMenu&quot;;
3444     case Cursor::Alias: return &quot;Alias&quot;;
3445     case Cursor::Progress: return &quot;Progress&quot;;
3446     case Cursor::NoDrop: return &quot;NoDrop&quot;;
3447     case Cursor::Copy: return &quot;Copy&quot;;
3448     case Cursor::None: return &quot;None&quot;;
3449     case Cursor::NotAllowed: return &quot;NotAllowed&quot;;
3450     case Cursor::ZoomIn: return &quot;ZoomIn&quot;;
3451     case Cursor::ZoomOut: return &quot;ZoomOut&quot;;
3452     case Cursor::Grab: return &quot;Grab&quot;;
3453     case Cursor::Grabbing: return &quot;Grabbing&quot;;
3454     case Cursor::Custom: return &quot;Custom&quot;;
3455     }
3456 
3457     ASSERT_NOT_REACHED();
3458     return &quot;UNKNOWN&quot;;
3459 }
3460 #endif
3461 
3462 ExceptionOr&lt;String&gt; Internals::getCurrentCursorInfo()
3463 {
3464     Document* document = contextDocument();
3465     if (!document || !document-&gt;frame())
3466         return Exception { InvalidAccessError };
3467 
3468 #if !PLATFORM(IOS_FAMILY)
3469     Cursor cursor = document-&gt;frame()-&gt;eventHandler().currentMouseCursor();
3470 
3471     StringBuilder result;
3472     result.append(&quot;type=&quot;, cursorTypeToString(cursor.type()), &quot; hotSpot=&quot;, cursor.hotSpot().x(), &#39;,&#39;, cursor.hotSpot().y());
3473     if (cursor.image()) {
3474         FloatSize size = cursor.image()-&gt;size();
3475         result.append(&quot; image=&quot;, size.width(), &#39;x&#39;, size.height());
3476     }
3477 #if ENABLE(MOUSE_CURSOR_SCALE)
3478     if (cursor.imageScaleFactor() != 1)
3479         result.append(&quot; scale=&quot;, cursor.imageScaleFactor());
3480 #endif
3481     return result.toString();
3482 #else
3483     return &quot;FAIL: Cursor details not available on this platform.&quot;_str;
3484 #endif
3485 }
3486 
3487 Ref&lt;ArrayBuffer&gt; Internals::serializeObject(const RefPtr&lt;SerializedScriptValue&gt;&amp; value) const
3488 {
3489     auto&amp; bytes = value-&gt;data();
3490     return ArrayBuffer::create(bytes.data(), bytes.size());
3491 }
3492 
3493 Ref&lt;SerializedScriptValue&gt; Internals::deserializeBuffer(ArrayBuffer&amp; buffer) const
3494 {
3495     Vector&lt;uint8_t&gt; bytes;
3496     bytes.append(static_cast&lt;const uint8_t*&gt;(buffer.data()), buffer.byteLength());
3497     return SerializedScriptValue::adopt(WTFMove(bytes));
3498 }
3499 
3500 bool Internals::isFromCurrentWorld(JSC::JSValue value) const
3501 {
3502     JSC::VM&amp; vm = contextDocument()-&gt;vm();
3503     return isWorldCompatible(*vm.topCallFrame-&gt;lexicalGlobalObject(vm), value);
3504 }
3505 
3506 JSC::JSValue Internals::evaluateInWorldIgnoringException(const String&amp; name, const String&amp; source)
3507 {
3508     auto* document = contextDocument();
3509     auto&amp; scriptController = document-&gt;frame()-&gt;script();
3510     auto world = ScriptController::createWorld(name);
3511     return scriptController.executeScriptInWorldIgnoringException(world, source);
3512 }
3513 
3514 void Internals::setUsesOverlayScrollbars(bool enabled)
3515 {
3516     WebCore::DeprecatedGlobalSettings::setUsesOverlayScrollbars(enabled);
3517 }
3518 
3519 void Internals::setUsesMockScrollAnimator(bool enabled)
3520 {
3521     WebCore::DeprecatedGlobalSettings::setUsesMockScrollAnimator(enabled);
3522 }
3523 
3524 void Internals::forceReload(bool endToEnd)
3525 {
3526     OptionSet&lt;ReloadOption&gt; reloadOptions;
3527     if (endToEnd)
3528         reloadOptions.add(ReloadOption::FromOrigin);
3529 
3530     frame()-&gt;loader().reload(reloadOptions);
3531 }
3532 
3533 void Internals::reloadExpiredOnly()
3534 {
3535     frame()-&gt;loader().reload(ReloadOption::ExpiredOnly);
3536 }
3537 
3538 void Internals::enableAutoSizeMode(bool enabled, int width, int height)
3539 {
3540     auto* document = contextDocument();
3541     if (!document || !document-&gt;view())
3542         return;
3543     document-&gt;view()-&gt;enableAutoSizeMode(enabled, { width, height });
3544 }
3545 
3546 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
3547 
3548 void Internals::initializeMockCDM()
3549 {
3550     LegacyCDM::registerCDMFactory([] (LegacyCDM* cdm) { return makeUnique&lt;LegacyMockCDM&gt;(cdm); },
3551         LegacyMockCDM::supportsKeySystem, LegacyMockCDM::supportsKeySystemAndMimeType);
3552 }
3553 
3554 #endif
3555 
3556 #if ENABLE(ENCRYPTED_MEDIA)
3557 
3558 Ref&lt;MockCDMFactory&gt; Internals::registerMockCDM()
3559 {
3560     return MockCDMFactory::create();
3561 }
3562 
3563 #endif
3564 
3565 String Internals::markerTextForListItem(Element&amp; element)
3566 {
3567     return WebCore::markerTextForListItem(&amp;element);
3568 }
3569 
3570 String Internals::toolTipFromElement(Element&amp; element) const
3571 {
3572     HitTestResult result;
3573     result.setInnerNode(&amp;element);
3574     TextDirection direction;
3575     return result.title(direction);
3576 }
3577 
3578 String Internals::getImageSourceURL(Element&amp; element)
3579 {
3580     return element.imageSourceURL();
3581 }
3582 
3583 #if ENABLE(VIDEO)
3584 
3585 Vector&lt;String&gt; Internals::mediaResponseSources(HTMLMediaElement&amp; media)
3586 {
3587     auto* resourceLoader = media.lastMediaResourceLoaderForTesting();
3588     if (!resourceLoader)
3589         return { };
3590     Vector&lt;String&gt; result;
3591     auto responses = resourceLoader-&gt;responsesForTesting();
3592     for (auto&amp; response : responses)
3593         result.append(responseSourceToString(response));
3594     return result;
3595 }
3596 
3597 Vector&lt;String&gt; Internals::mediaResponseContentRanges(HTMLMediaElement&amp; media)
3598 {
3599     auto* resourceLoader = media.lastMediaResourceLoaderForTesting();
3600     if (!resourceLoader)
3601         return { };
3602     Vector&lt;String&gt; result;
3603     auto responses = resourceLoader-&gt;responsesForTesting();
3604     for (auto&amp; response : responses)
3605         result.append(response.httpHeaderField(HTTPHeaderName::ContentRange));
3606     return result;
3607 }
3608 
3609 void Internals::simulateAudioInterruption(HTMLMediaElement&amp; element)
3610 {
3611 #if USE(GSTREAMER)
3612     element.player()-&gt;simulateAudioInterruption();
3613 #else
3614     UNUSED_PARAM(element);
3615 #endif
3616 }
3617 
3618 ExceptionOr&lt;bool&gt; Internals::mediaElementHasCharacteristic(HTMLMediaElement&amp; element, const String&amp; characteristic)
3619 {
3620     if (equalLettersIgnoringASCIICase(characteristic, &quot;audible&quot;))
3621         return element.hasAudio();
3622     if (equalLettersIgnoringASCIICase(characteristic, &quot;visual&quot;))
3623         return element.hasVideo();
3624     if (equalLettersIgnoringASCIICase(characteristic, &quot;legible&quot;))
3625         return element.hasClosedCaptions();
3626 
3627     return Exception { SyntaxError };
3628 }
3629 
3630 void Internals::beginSimulatedHDCPError(HTMLMediaElement&amp; element)
3631 {
3632     if (auto player = element.player())
3633         player-&gt;beginSimulatedHDCPError();
3634 }
3635 
3636 void Internals::endSimulatedHDCPError(HTMLMediaElement&amp; element)
3637 {
3638     if (auto player = element.player())
3639         player-&gt;endSimulatedHDCPError();
3640 }
3641 
3642 bool Internals::elementShouldBufferData(HTMLMediaElement&amp; element)
3643 {
3644     return element.bufferingPolicy() &lt; MediaPlayer::BufferingPolicy::LimitReadAhead;
3645 }
3646 
3647 String Internals::elementBufferingPolicy(HTMLMediaElement&amp; element)
3648 {
3649     switch (element.bufferingPolicy()) {
3650     case MediaPlayer::BufferingPolicy::Default:
3651         return &quot;Default&quot;;
3652     case MediaPlayer::BufferingPolicy::LimitReadAhead:
3653         return &quot;LimitReadAhead&quot;;
3654     case MediaPlayer::BufferingPolicy::MakeResourcesPurgeable:
3655         return &quot;MakeResourcesPurgeable&quot;;
3656     case MediaPlayer::BufferingPolicy::PurgeResources:
3657         return &quot;PurgeResources&quot;;
3658     }
3659 
3660     ASSERT_NOT_REACHED();
3661     return &quot;UNKNOWN&quot;;
3662 }
3663 #endif
3664 
3665 bool Internals::isSelectPopupVisible(HTMLSelectElement&amp; element)
3666 {
3667     element.document().updateLayoutIgnorePendingStylesheets();
3668 
3669     auto* renderer = element.renderer();
3670     if (!is&lt;RenderMenuList&gt;(renderer))
3671         return false;
3672 
3673 #if !PLATFORM(IOS_FAMILY)
3674     return downcast&lt;RenderMenuList&gt;(*renderer).popupIsVisible();
3675 #else
3676     return false;
3677 #endif
3678 }
3679 
3680 ExceptionOr&lt;String&gt; Internals::captionsStyleSheetOverride()
3681 {
3682     Document* document = contextDocument();
3683     if (!document || !document-&gt;page())
3684         return Exception { InvalidAccessError };
3685 
3686 #if ENABLE(VIDEO_TRACK)
3687     return document-&gt;page()-&gt;group().captionPreferences().captionsStyleSheetOverride();
3688 #else
3689     return String { emptyString() };
3690 #endif
3691 }
3692 
3693 ExceptionOr&lt;void&gt; Internals::setCaptionsStyleSheetOverride(const String&amp; override)
3694 {
3695     Document* document = contextDocument();
3696     if (!document || !document-&gt;page())
3697         return Exception { InvalidAccessError };
3698 
3699 #if ENABLE(VIDEO_TRACK)
3700     document-&gt;page()-&gt;group().captionPreferences().setCaptionsStyleSheetOverride(override);
3701 #else
3702     UNUSED_PARAM(override);
3703 #endif
3704     return { };
3705 }
3706 
3707 ExceptionOr&lt;void&gt; Internals::setPrimaryAudioTrackLanguageOverride(const String&amp; language)
3708 {
3709     Document* document = contextDocument();
3710     if (!document || !document-&gt;page())
3711         return Exception { InvalidAccessError };
3712 
3713 #if ENABLE(VIDEO_TRACK)
3714     document-&gt;page()-&gt;group().captionPreferences().setPrimaryAudioTrackLanguageOverride(language);
3715 #else
3716     UNUSED_PARAM(language);
3717 #endif
3718     return { };
3719 }
3720 
3721 ExceptionOr&lt;void&gt; Internals::setCaptionDisplayMode(const String&amp; mode)
3722 {
3723     Document* document = contextDocument();
3724     if (!document || !document-&gt;page())
3725         return Exception { InvalidAccessError };
3726 
3727 #if ENABLE(VIDEO_TRACK)
3728     auto&amp; captionPreferences = document-&gt;page()-&gt;group().captionPreferences();
3729 
3730     if (equalLettersIgnoringASCIICase(mode, &quot;automatic&quot;))
3731         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::Automatic);
3732     else if (equalLettersIgnoringASCIICase(mode, &quot;forcedonly&quot;))
3733         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::ForcedOnly);
3734     else if (equalLettersIgnoringASCIICase(mode, &quot;alwayson&quot;))
3735         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::AlwaysOn);
3736     else if (equalLettersIgnoringASCIICase(mode, &quot;manual&quot;))
3737         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::Manual);
3738     else
3739         return Exception { SyntaxError };
3740 #else
3741     UNUSED_PARAM(mode);
3742 #endif
3743     return { };
3744 }
3745 
3746 #if ENABLE(VIDEO_TRACK)
3747 RefPtr&lt;TextTrackCueGeneric&gt; Internals::createGenericCue(double startTime, double endTime, String text)
3748 {
3749     Document* document = contextDocument();
3750     if (!document || !document-&gt;page())
3751         return nullptr;
3752     return TextTrackCueGeneric::create(*document, MediaTime::createWithDouble(startTime), MediaTime::createWithDouble(endTime), text);
3753 }
3754 #endif
3755 
3756 #if ENABLE(VIDEO)
3757 
3758 Ref&lt;TimeRanges&gt; Internals::createTimeRanges(Float32Array&amp; startTimes, Float32Array&amp; endTimes)
3759 {
3760     ASSERT(startTimes.length() == endTimes.length());
3761     Ref&lt;TimeRanges&gt; ranges = TimeRanges::create();
3762 
3763     unsigned count = std::min(startTimes.length(), endTimes.length());
3764     for (unsigned i = 0; i &lt; count; ++i)
3765         ranges-&gt;add(startTimes.item(i), endTimes.item(i));
3766     return ranges;
3767 }
3768 
3769 double Internals::closestTimeToTimeRanges(double time, TimeRanges&amp; ranges)
3770 {
3771     return ranges.nearest(time);
3772 }
3773 
3774 #endif
3775 
3776 ExceptionOr&lt;Ref&lt;DOMRect&gt;&gt; Internals::selectionBounds()
3777 {
3778     Document* document = contextDocument();
3779     if (!document || !document-&gt;frame())
3780         return Exception { InvalidAccessError };
3781 
3782     return DOMRect::create(document-&gt;frame()-&gt;selection().selectionBounds());
3783 }
3784 
3785 void Internals::setSelectionWithoutValidation(Ref&lt;Node&gt; baseNode, unsigned baseOffset, RefPtr&lt;Node&gt; extentNode, unsigned extentOffset)
3786 {
3787     contextDocument()-&gt;frame()-&gt;selection().moveTo(
3788         VisiblePosition { createLegacyEditingPosition(baseNode.ptr(), baseOffset) },
3789         VisiblePosition { createLegacyEditingPosition(extentNode.get(), extentOffset) });
3790 }
3791 
3792 ExceptionOr&lt;bool&gt; Internals::isPluginUnavailabilityIndicatorObscured(Element&amp; element)
3793 {
3794     if (!is&lt;HTMLPlugInElement&gt;(element))
3795         return Exception { InvalidAccessError };
3796 
3797     return downcast&lt;HTMLPlugInElement&gt;(element).isReplacementObscured();
3798 }
3799 
3800 ExceptionOr&lt;String&gt; Internals::unavailablePluginReplacementText(Element&amp; element)
3801 {
3802     if (!is&lt;HTMLPlugInElement&gt;(element))
3803         return Exception { InvalidAccessError };
3804 
3805     auto* renderer = element.renderer();
3806     if (!is&lt;RenderEmbeddedObject&gt;(renderer))
3807         return String { };
3808 
3809     return String { downcast&lt;RenderEmbeddedObject&gt;(*renderer).pluginReplacementTextIfUnavailable() };
3810 }
3811 
3812 bool Internals::isPluginSnapshotted(Element&amp; element)
3813 {
3814     return is&lt;HTMLPlugInElement&gt;(element) &amp;&amp; downcast&lt;HTMLPlugInElement&gt;(element).displayState() &lt;= HTMLPlugInElement::DisplayingSnapshot;
3815 }
3816 
3817 bool Internals::pluginIsBelowSizeThreshold(Element&amp; element)
3818 {
3819     return is&lt;HTMLPlugInElement&gt;(element) &amp;&amp; downcast&lt;HTMLPlugInElement&gt;(element).isBelowSizeThreshold();
3820 }
3821 
3822 #if ENABLE(MEDIA_SOURCE)
3823 
3824 void Internals::initializeMockMediaSource()
3825 {
3826 #if USE(AVFOUNDATION)
3827     WebCore::DeprecatedGlobalSettings::setAVFoundationEnabled(false);
3828 #endif
3829 #if USE(GSTREAMER)
3830     WebCore::DeprecatedGlobalSettings::setGStreamerEnabled(false);
3831 #endif
3832     MediaPlayerFactorySupport::callRegisterMediaEngine(MockMediaPlayerMediaSource::registerMediaEngine);
3833 }
3834 
3835 Vector&lt;String&gt; Internals::bufferedSamplesForTrackID(SourceBuffer&amp; buffer, const AtomString&amp; trackID)
3836 {
3837     return buffer.bufferedSamplesForTrackID(trackID);
3838 }
3839 
3840 Vector&lt;String&gt; Internals::enqueuedSamplesForTrackID(SourceBuffer&amp; buffer, const AtomString&amp; trackID)
3841 {
3842     return buffer.enqueuedSamplesForTrackID(trackID);
3843 }
3844 
3845 double Internals::minimumUpcomingPresentationTimeForTrackID(SourceBuffer&amp; buffer, const AtomString&amp; trackID)
3846 {
3847     return buffer.minimumUpcomingPresentationTimeForTrackID(trackID).toDouble();
3848 }
3849 
3850 void Internals::setShouldGenerateTimestamps(SourceBuffer&amp; buffer, bool flag)
3851 {
3852     buffer.setShouldGenerateTimestamps(flag);
3853 }
3854 
3855 void Internals::setMaximumQueueDepthForTrackID(SourceBuffer&amp; buffer, const AtomString&amp; trackID, size_t maxQueueDepth)
3856 {
3857     buffer.setMaximumQueueDepthForTrackID(trackID, maxQueueDepth);
3858 }
3859 
3860 #endif
3861 
3862 void Internals::enableMockMediaCapabilities()
3863 {
3864     MediaEngineConfigurationFactory::enableMock();
3865 }
3866 
3867 #if ENABLE(VIDEO)
3868 
3869 ExceptionOr&lt;void&gt; Internals::beginMediaSessionInterruption(const String&amp; interruptionString)
3870 {
3871     PlatformMediaSession::InterruptionType interruption = PlatformMediaSession::SystemInterruption;
3872 
3873     if (equalLettersIgnoringASCIICase(interruptionString, &quot;system&quot;))
3874         interruption = PlatformMediaSession::SystemInterruption;
3875     else if (equalLettersIgnoringASCIICase(interruptionString, &quot;systemsleep&quot;))
3876         interruption = PlatformMediaSession::SystemSleep;
3877     else if (equalLettersIgnoringASCIICase(interruptionString, &quot;enteringbackground&quot;))
3878         interruption = PlatformMediaSession::EnteringBackground;
3879     else if (equalLettersIgnoringASCIICase(interruptionString, &quot;suspendedunderlock&quot;))
3880         interruption = PlatformMediaSession::SuspendedUnderLock;
3881     else
3882         return Exception { InvalidAccessError };
3883 
3884     PlatformMediaSessionManager::sharedManager().beginInterruption(interruption);
3885     return { };
3886 }
3887 
3888 void Internals::endMediaSessionInterruption(const String&amp; flagsString)
3889 {
3890     PlatformMediaSession::EndInterruptionFlags flags = PlatformMediaSession::NoFlags;
3891 
3892     if (equalLettersIgnoringASCIICase(flagsString, &quot;mayresumeplaying&quot;))
3893         flags = PlatformMediaSession::MayResumePlaying;
3894 
3895     PlatformMediaSessionManager::sharedManager().endInterruption(flags);
3896 }
3897 
3898 void Internals::applicationWillBecomeInactive()
3899 {
3900     PlatformMediaSessionManager::sharedManager().applicationWillBecomeInactive();
3901 }
3902 
3903 void Internals::applicationDidBecomeActive()
3904 {
3905     PlatformMediaSessionManager::sharedManager().applicationDidBecomeActive();
3906 }
3907 
3908 void Internals::applicationWillEnterForeground(bool suspendedUnderLock) const
3909 {
3910     PlatformMediaSessionManager::sharedManager().applicationWillEnterForeground(suspendedUnderLock);
3911 }
3912 
3913 void Internals::applicationDidEnterBackground(bool suspendedUnderLock) const
3914 {
3915     PlatformMediaSessionManager::sharedManager().applicationDidEnterBackground(suspendedUnderLock);
3916 }
3917 
3918 static PlatformMediaSession::MediaType mediaTypeFromString(const String&amp; mediaTypeString)
3919 {
3920     if (equalLettersIgnoringASCIICase(mediaTypeString, &quot;video&quot;))
3921         return PlatformMediaSession::Video;
3922     if (equalLettersIgnoringASCIICase(mediaTypeString, &quot;audio&quot;))
3923         return PlatformMediaSession::Audio;
3924     if (equalLettersIgnoringASCIICase(mediaTypeString, &quot;videoaudio&quot;))
3925         return PlatformMediaSession::VideoAudio;
3926     if (equalLettersIgnoringASCIICase(mediaTypeString, &quot;webaudio&quot;))
3927         return PlatformMediaSession::WebAudio;
3928     if (equalLettersIgnoringASCIICase(mediaTypeString, &quot;mediastreamcapturingaudio&quot;))
3929         return PlatformMediaSession::MediaStreamCapturingAudio;
3930 
3931     return PlatformMediaSession::None;
3932 }
3933 
3934 ExceptionOr&lt;void&gt; Internals::setMediaSessionRestrictions(const String&amp; mediaTypeString, StringView restrictionsString)
3935 {
3936     PlatformMediaSession::MediaType mediaType = mediaTypeFromString(mediaTypeString);
3937     if (mediaType == PlatformMediaSession::None)
3938         return Exception { InvalidAccessError };
3939 
3940     PlatformMediaSessionManager::SessionRestrictions restrictions = PlatformMediaSessionManager::sharedManager().restrictions(mediaType);
3941     PlatformMediaSessionManager::sharedManager().removeRestriction(mediaType, restrictions);
3942 
3943     restrictions = PlatformMediaSessionManager::NoRestrictions;
3944 
3945     for (StringView restrictionString : restrictionsString.split(&#39;,&#39;)) {
3946         if (equalLettersIgnoringASCIICase(restrictionString, &quot;concurrentplaybacknotpermitted&quot;))
3947             restrictions |= PlatformMediaSessionManager::ConcurrentPlaybackNotPermitted;
3948         if (equalLettersIgnoringASCIICase(restrictionString, &quot;backgroundprocessplaybackrestricted&quot;))
3949             restrictions |= PlatformMediaSessionManager::BackgroundProcessPlaybackRestricted;
3950         if (equalLettersIgnoringASCIICase(restrictionString, &quot;backgroundtabplaybackrestricted&quot;))
3951             restrictions |= PlatformMediaSessionManager::BackgroundTabPlaybackRestricted;
3952         if (equalLettersIgnoringASCIICase(restrictionString, &quot;interruptedplaybacknotpermitted&quot;))
3953             restrictions |= PlatformMediaSessionManager::InterruptedPlaybackNotPermitted;
3954         if (equalLettersIgnoringASCIICase(restrictionString, &quot;inactiveprocessplaybackrestricted&quot;))
3955             restrictions |= PlatformMediaSessionManager::InactiveProcessPlaybackRestricted;
3956         if (equalLettersIgnoringASCIICase(restrictionString, &quot;suspendedunderlockplaybackrestricted&quot;))
3957             restrictions |= PlatformMediaSessionManager::SuspendedUnderLockPlaybackRestricted;
3958     }
3959     PlatformMediaSessionManager::sharedManager().addRestriction(mediaType, restrictions);
3960     return { };
3961 }
3962 
3963 ExceptionOr&lt;String&gt; Internals::mediaSessionRestrictions(const String&amp; mediaTypeString) const
3964 {
3965     PlatformMediaSession::MediaType mediaType = mediaTypeFromString(mediaTypeString);
3966     if (mediaType == PlatformMediaSession::None)
3967         return Exception { InvalidAccessError };
3968 
3969     PlatformMediaSessionManager::SessionRestrictions restrictions = PlatformMediaSessionManager::sharedManager().restrictions(mediaType);
3970     if (restrictions == PlatformMediaSessionManager::NoRestrictions)
3971         return String();
3972 
3973     StringBuilder builder;
3974     if (restrictions &amp; PlatformMediaSessionManager::ConcurrentPlaybackNotPermitted)
3975         builder.append(&quot;concurrentplaybacknotpermitted&quot;);
3976     if (restrictions &amp; PlatformMediaSessionManager::BackgroundProcessPlaybackRestricted) {
3977         if (!builder.isEmpty())
3978             builder.append(&#39;,&#39;);
3979         builder.append(&quot;backgroundprocessplaybackrestricted&quot;);
3980     }
3981     if (restrictions &amp; PlatformMediaSessionManager::BackgroundTabPlaybackRestricted) {
3982         if (!builder.isEmpty())
3983             builder.append(&#39;,&#39;);
3984         builder.append(&quot;backgroundtabplaybackrestricted&quot;);
3985     }
3986     if (restrictions &amp; PlatformMediaSessionManager::InterruptedPlaybackNotPermitted) {
3987         if (!builder.isEmpty())
3988             builder.append(&#39;,&#39;);
3989         builder.append(&quot;interruptedplaybacknotpermitted&quot;);
3990     }
3991     return builder.toString();
3992 }
3993 
3994 void Internals::setMediaElementRestrictions(HTMLMediaElement&amp; element, StringView restrictionsString)
3995 {
3996     MediaElementSession::BehaviorRestrictions restrictions = element.mediaSession().behaviorRestrictions();
3997     element.mediaSession().removeBehaviorRestriction(restrictions);
3998 
3999     restrictions = MediaElementSession::NoRestrictions;
4000 
4001     for (StringView restrictionString : restrictionsString.split(&#39;,&#39;)) {
4002         if (equalLettersIgnoringASCIICase(restrictionString, &quot;norestrictions&quot;))
4003             restrictions |= MediaElementSession::NoRestrictions;
4004         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforload&quot;))
4005             restrictions |= MediaElementSession::RequireUserGestureForLoad;
4006         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforvideoratechange&quot;))
4007             restrictions |= MediaElementSession::RequireUserGestureForVideoRateChange;
4008         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforfullscreen&quot;))
4009             restrictions |= MediaElementSession::RequireUserGestureForFullscreen;
4010         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requirepageconsenttoloadmedia&quot;))
4011             restrictions |= MediaElementSession::RequirePageConsentToLoadMedia;
4012         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requirepageconsenttoresumemedia&quot;))
4013             restrictions |= MediaElementSession::RequirePageConsentToResumeMedia;
4014 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
4015         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergesturetoshowplaybacktargetpicker&quot;))
4016             restrictions |= MediaElementSession::RequireUserGestureToShowPlaybackTargetPicker;
4017         if (equalLettersIgnoringASCIICase(restrictionString, &quot;wirelessvideoplaybackdisabled&quot;))
4018             restrictions |= MediaElementSession::WirelessVideoPlaybackDisabled;
4019 #endif
4020         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforaudioratechange&quot;))
4021             restrictions |= MediaElementSession::RequireUserGestureForAudioRateChange;
4022         if (equalLettersIgnoringASCIICase(restrictionString, &quot;autopreloadingnotpermitted&quot;))
4023             restrictions |= MediaElementSession::AutoPreloadingNotPermitted;
4024         if (equalLettersIgnoringASCIICase(restrictionString, &quot;invisibleautoplaynotpermitted&quot;))
4025             restrictions |= MediaElementSession::InvisibleAutoplayNotPermitted;
4026         if (equalLettersIgnoringASCIICase(restrictionString, &quot;overrideusergesturerequirementformaincontent&quot;))
4027             restrictions |= MediaElementSession::OverrideUserGestureRequirementForMainContent;
4028     }
4029     element.mediaSession().addBehaviorRestriction(restrictions);
4030 }
4031 
4032 ExceptionOr&lt;void&gt; Internals::postRemoteControlCommand(const String&amp; commandString, float argument)
4033 {
4034     PlatformMediaSession::RemoteControlCommandType command;
4035     PlatformMediaSession::RemoteCommandArgument parameter { argument };
4036 
4037     if (equalLettersIgnoringASCIICase(commandString, &quot;play&quot;))
4038         command = PlatformMediaSession::PlayCommand;
4039     else if (equalLettersIgnoringASCIICase(commandString, &quot;pause&quot;))
4040         command = PlatformMediaSession::PauseCommand;
4041     else if (equalLettersIgnoringASCIICase(commandString, &quot;stop&quot;))
4042         command = PlatformMediaSession::StopCommand;
4043     else if (equalLettersIgnoringASCIICase(commandString, &quot;toggleplaypause&quot;))
4044         command = PlatformMediaSession::TogglePlayPauseCommand;
4045     else if (equalLettersIgnoringASCIICase(commandString, &quot;beginseekingbackward&quot;))
4046         command = PlatformMediaSession::BeginSeekingBackwardCommand;
4047     else if (equalLettersIgnoringASCIICase(commandString, &quot;endseekingbackward&quot;))
4048         command = PlatformMediaSession::EndSeekingBackwardCommand;
4049     else if (equalLettersIgnoringASCIICase(commandString, &quot;beginseekingforward&quot;))
4050         command = PlatformMediaSession::BeginSeekingForwardCommand;
4051     else if (equalLettersIgnoringASCIICase(commandString, &quot;endseekingforward&quot;))
4052         command = PlatformMediaSession::EndSeekingForwardCommand;
4053     else if (equalLettersIgnoringASCIICase(commandString, &quot;seektoplaybackposition&quot;))
4054         command = PlatformMediaSession::SeekToPlaybackPositionCommand;
4055     else
4056         return Exception { InvalidAccessError };
4057 
4058     PlatformMediaSessionManager::sharedManager().didReceiveRemoteControlCommand(command, &amp;parameter);
4059     return { };
4060 }
4061 
4062 bool Internals::elementIsBlockingDisplaySleep(HTMLMediaElement&amp; element) const
4063 {
4064     return element.isDisablingSleep();
4065 }
4066 
4067 #endif // ENABLE(VIDEO)
4068 
4069 #if ENABLE(MEDIA_SESSION)
4070 
4071 void Internals::sendMediaSessionStartOfInterruptionNotification(MediaSessionInterruptingCategory category)
4072 {
4073     MediaSessionManager::singleton().didReceiveStartOfInterruptionNotification(category);
4074 }
4075 
4076 void Internals::sendMediaSessionEndOfInterruptionNotification(MediaSessionInterruptingCategory category)
4077 {
4078     MediaSessionManager::singleton().didReceiveEndOfInterruptionNotification(category);
4079 }
4080 
4081 String Internals::mediaSessionCurrentState(MediaSession* session) const
4082 {
4083     switch (session-&gt;currentState()) {
4084     case MediaSession::State::Active:
4085         return &quot;active&quot;;
4086     case MediaSession::State::Interrupted:
4087         return &quot;interrupted&quot;;
4088     case MediaSession::State::Idle:
4089         return &quot;idle&quot;;
4090     }
4091 }
4092 
4093 double Internals::mediaElementPlayerVolume(HTMLMediaElement* element) const
4094 {
4095     ASSERT_ARG(element, element);
4096     return element-&gt;playerVolume();
4097 }
4098 
4099 void Internals::sendMediaControlEvent(MediaControlEvent event)
4100 {
4101     // FIXME: No good reason to use a single function with an argument instead of three functions.
4102     switch (event) {
4103     case MediControlEvent::PlayPause:
4104         MediaSessionManager::singleton().togglePlayback();
4105         break;
4106     case MediControlEvent::NextTrack:
4107         MediaSessionManager::singleton().skipToNextTrack();
4108         break;
4109     case MediControlEvent::PreviousTrack:
4110         MediaSessionManager::singleton().skipToPreviousTrack();
4111         break;
4112     }
4113 }
4114 
4115 #endif // ENABLE(MEDIA_SESSION)
4116 
4117 #if ENABLE(WEB_AUDIO)
4118 void Internals::setAudioContextRestrictions(AudioContext&amp; context, StringView restrictionsString)
4119 {
4120     AudioContext::BehaviorRestrictions restrictions = context.behaviorRestrictions();
4121     context.removeBehaviorRestriction(restrictions);
4122 
4123     restrictions = AudioContext::NoRestrictions;
4124 
4125     for (StringView restrictionString : restrictionsString.split(&#39;,&#39;)) {
4126         if (equalLettersIgnoringASCIICase(restrictionString, &quot;norestrictions&quot;))
4127             restrictions |= AudioContext::NoRestrictions;
4128         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforaudiostart&quot;))
4129             restrictions |= AudioContext::RequireUserGestureForAudioStartRestriction;
4130         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requirepageconsentforaudiostart&quot;))
4131             restrictions |= AudioContext::RequirePageConsentForAudioStartRestriction;
4132     }
4133     context.addBehaviorRestriction(restrictions);
4134 }
4135 
4136 void Internals::useMockAudioDestinationCocoa()
4137 {
4138 #if PLATFORM(COCOA)
4139     AudioDestinationCocoa::createOverride = MockAudioDestinationCocoa::create;
4140 #endif
4141 }
4142 #endif
4143 
4144 void Internals::simulateSystemSleep() const
4145 {
4146 #if ENABLE(VIDEO)
4147     PlatformMediaSessionManager::sharedManager().systemWillSleep();
4148 #endif
4149 }
4150 
4151 void Internals::simulateSystemWake() const
4152 {
4153 #if ENABLE(VIDEO)
4154     PlatformMediaSessionManager::sharedManager().systemDidWake();
4155 #endif
4156 }
4157 
4158 ExceptionOr&lt;Internals::NowPlayingState&gt; Internals::nowPlayingState() const
4159 {
4160 #if ENABLE(VIDEO)
4161     return { { PlatformMediaSessionManager::sharedManager().lastUpdatedNowPlayingTitle(),
4162         PlatformMediaSessionManager::sharedManager().lastUpdatedNowPlayingDuration(),
4163         PlatformMediaSessionManager::sharedManager().lastUpdatedNowPlayingElapsedTime(),
4164         PlatformMediaSessionManager::sharedManager().lastUpdatedNowPlayingInfoUniqueIdentifier(),
4165         PlatformMediaSessionManager::sharedManager().hasActiveNowPlayingSession(),
4166         PlatformMediaSessionManager::sharedManager().registeredAsNowPlayingApplication()
4167     } };
4168 #else
4169     return Exception { InvalidAccessError };
4170 #endif
4171 }
4172 
4173 #if ENABLE(VIDEO)
4174 RefPtr&lt;HTMLMediaElement&gt; Internals::bestMediaElementForShowingPlaybackControlsManager(Internals::PlaybackControlsPurpose purpose)
4175 {
4176     return HTMLMediaElement::bestMediaElementForShowingPlaybackControlsManager(purpose);
4177 }
4178 
4179 Internals::MediaSessionState Internals::mediaSessionState(HTMLMediaElement&amp; element)
4180 {
4181     return element.mediaSession().state();
4182 }
4183 #endif
4184 
4185 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
4186 
4187 void Internals::setMockMediaPlaybackTargetPickerEnabled(bool enabled)
4188 {
4189     Page* page = contextDocument()-&gt;frame()-&gt;page();
4190     ASSERT(page);
4191 
4192     page-&gt;setMockMediaPlaybackTargetPickerEnabled(enabled);
4193 }
4194 
4195 ExceptionOr&lt;void&gt; Internals::setMockMediaPlaybackTargetPickerState(const String&amp; deviceName, const String&amp; deviceState)
4196 {
4197     Page* page = contextDocument()-&gt;frame()-&gt;page();
4198     ASSERT(page);
4199 
4200     MediaPlaybackTargetContext::State state = MediaPlaybackTargetContext::Unknown;
4201 
4202     if (equalLettersIgnoringASCIICase(deviceState, &quot;deviceavailable&quot;))
4203         state = MediaPlaybackTargetContext::OutputDeviceAvailable;
4204     else if (equalLettersIgnoringASCIICase(deviceState, &quot;deviceunavailable&quot;))
4205         state = MediaPlaybackTargetContext::OutputDeviceUnavailable;
4206     else if (equalLettersIgnoringASCIICase(deviceState, &quot;unknown&quot;))
4207         state = MediaPlaybackTargetContext::Unknown;
4208     else
4209         return Exception { InvalidAccessError };
4210 
4211     page-&gt;setMockMediaPlaybackTargetPickerState(deviceName, state);
4212     return { };
4213 }
4214 
4215 void Internals::mockMediaPlaybackTargetPickerDismissPopup()
4216 {
4217     auto* page = contextDocument()-&gt;frame()-&gt;page();
4218     ASSERT(page);
4219 
4220     page-&gt;mockMediaPlaybackTargetPickerDismissPopup();
4221 }
4222 
4223 #endif
4224 
4225 ExceptionOr&lt;Ref&lt;MockPageOverlay&gt;&gt; Internals::installMockPageOverlay(PageOverlayType type)
4226 {
4227     Document* document = contextDocument();
4228     if (!document || !document-&gt;page())
4229         return Exception { InvalidAccessError };
4230 
4231     return MockPageOverlayClient::singleton().installOverlay(*document-&gt;page(), type == PageOverlayType::View ? PageOverlay::OverlayType::View : PageOverlay::OverlayType::Document);
4232 }
4233 
4234 ExceptionOr&lt;String&gt; Internals::pageOverlayLayerTreeAsText(unsigned short flags) const
4235 {
4236     Document* document = contextDocument();
4237     if (!document || !document-&gt;page())
4238         return Exception { InvalidAccessError };
4239 
4240     document-&gt;updateLayoutIgnorePendingStylesheets();
4241 
4242     return MockPageOverlayClient::singleton().layerTreeAsText(*document-&gt;page(), toLayerTreeFlags(flags));
4243 }
4244 
4245 void Internals::setPageMuted(StringView statesString)
4246 {
4247     Document* document = contextDocument();
4248     if (!document)
4249         return;
4250 
4251     WebCore::MediaProducer::MutedStateFlags state = MediaProducer::NoneMuted;
4252     for (StringView stateString : statesString.split(&#39;,&#39;)) {
4253         if (equalLettersIgnoringASCIICase(stateString, &quot;audio&quot;))
4254             state |= MediaProducer::AudioIsMuted;
4255         if (equalLettersIgnoringASCIICase(stateString, &quot;capturedevices&quot;))
4256             state |= MediaProducer::AudioAndVideoCaptureIsMuted;
4257         if (equalLettersIgnoringASCIICase(stateString, &quot;screencapture&quot;))
4258             state |= MediaProducer::ScreenCaptureIsMuted;
4259     }
4260 
4261     if (Page* page = document-&gt;page())
4262         page-&gt;setMuted(state);
4263 }
4264 
4265 String Internals::pageMediaState()
4266 {
4267     Document* document = contextDocument();
4268     if (!document || !document-&gt;page())
4269         return emptyString();
4270 
4271     WebCore::MediaProducer::MediaStateFlags state = document-&gt;page()-&gt;mediaState();
4272     StringBuilder string;
4273     if (state &amp; MediaProducer::IsPlayingAudio)
4274         string.append(&quot;IsPlayingAudio,&quot;);
4275     if (state &amp; MediaProducer::IsPlayingVideo)
4276         string.append(&quot;IsPlayingVideo,&quot;);
4277     if (state &amp; MediaProducer::IsPlayingToExternalDevice)
4278         string.append(&quot;IsPlayingToExternalDevice,&quot;);
4279     if (state &amp; MediaProducer::RequiresPlaybackTargetMonitoring)
4280         string.append(&quot;RequiresPlaybackTargetMonitoring,&quot;);
4281     if (state &amp; MediaProducer::ExternalDeviceAutoPlayCandidate)
4282         string.append(&quot;ExternalDeviceAutoPlayCandidate,&quot;);
4283     if (state &amp; MediaProducer::DidPlayToEnd)
4284         string.append(&quot;DidPlayToEnd,&quot;);
4285     if (state &amp; MediaProducer::IsSourceElementPlaying)
4286         string.append(&quot;IsSourceElementPlaying,&quot;);
4287 
4288     if (state &amp; MediaProducer::IsNextTrackControlEnabled)
4289         string.append(&quot;IsNextTrackControlEnabled,&quot;);
4290     if (state &amp; MediaProducer::IsPreviousTrackControlEnabled)
4291         string.append(&quot;IsPreviousTrackControlEnabled,&quot;);
4292 
4293     if (state &amp; MediaProducer::HasPlaybackTargetAvailabilityListener)
4294         string.append(&quot;HasPlaybackTargetAvailabilityListener,&quot;);
4295     if (state &amp; MediaProducer::HasAudioOrVideo)
4296         string.append(&quot;HasAudioOrVideo,&quot;);
4297     if (state &amp; MediaProducer::HasActiveAudioCaptureDevice)
4298         string.append(&quot;HasActiveAudioCaptureDevice,&quot;);
4299     if (state &amp; MediaProducer::HasActiveVideoCaptureDevice)
4300         string.append(&quot;HasActiveVideoCaptureDevice,&quot;);
4301     if (state &amp; MediaProducer::HasMutedAudioCaptureDevice)
4302         string.append(&quot;HasMutedAudioCaptureDevice,&quot;);
4303     if (state &amp; MediaProducer::HasMutedVideoCaptureDevice)
4304         string.append(&quot;HasMutedVideoCaptureDevice,&quot;);
4305     if (state &amp; MediaProducer::HasUserInteractedWithMediaElement)
4306         string.append(&quot;HasUserInteractedWithMediaElement,&quot;);
4307     if (state &amp; MediaProducer::HasActiveDisplayCaptureDevice)
4308         string.append(&quot;HasActiveDisplayCaptureDevice,&quot;);
4309     if (state &amp; MediaProducer::HasMutedDisplayCaptureDevice)
4310         string.append(&quot;HasMutedDisplayCaptureDevice,&quot;);
4311 
4312     if (string.isEmpty())
4313         string.append(&quot;IsNotPlaying&quot;);
4314     else
4315         string.resize(string.length() - 1);
4316 
4317     return string.toString();
4318 }
4319 
4320 void Internals::setPageDefersLoading(bool defersLoading)
4321 {
4322     Document* document = contextDocument();
4323     if (!document)
4324         return;
4325     if (Page* page = document-&gt;page())
4326         page-&gt;setDefersLoading(defersLoading);
4327 }
4328 
4329 ExceptionOr&lt;bool&gt; Internals::pageDefersLoading()
4330 {
4331     Document* document = contextDocument();
4332     if (!document || !document-&gt;page())
4333         return Exception { InvalidAccessError };
4334     return document-&gt;page()-&gt;defersLoading();
4335 }
4336 
4337 RefPtr&lt;File&gt; Internals::createFile(const String&amp; path)
4338 {
4339     Document* document = contextDocument();
4340     if (!document)
4341         return nullptr;
4342 
4343     URL url = document-&gt;completeURL(path);
4344     if (!url.isLocalFile())
4345         return nullptr;
4346 
4347     return File::create(url.fileSystemPath());
4348 }
4349 
4350 void Internals::queueMicroTask(int testNumber)
4351 {
4352     Document* document = contextDocument();
4353     if (!document)
4354         return;
4355 
4356     ScriptExecutionContext* context = document;
4357     auto&amp; eventLoop = context-&gt;eventLoop();
4358     eventLoop.queueMicrotask([document = makeRef(*document), testNumber]() {
4359         document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Debug, makeString(&quot;MicroTask #&quot;, testNumber, &quot; has run.&quot;));
4360     });
4361 }
4362 
4363 #if ENABLE(CONTENT_FILTERING)
4364 
4365 MockContentFilterSettings&amp; Internals::mockContentFilterSettings()
4366 {
4367     return MockContentFilterSettings::singleton();
4368 }
4369 
4370 #endif
4371 
4372 #if ENABLE(CSS_SCROLL_SNAP)
4373 
4374 static void appendOffsets(StringBuilder&amp; builder, const Vector&lt;LayoutUnit&gt;&amp; snapOffsets)
4375 {
4376     bool justStarting = true;
4377 
4378     builder.appendLiteral(&quot;{ &quot;);
4379     for (auto&amp; coordinate : snapOffsets) {
4380         if (!justStarting)
4381             builder.appendLiteral(&quot;, &quot;);
4382         else
4383             justStarting = false;
4384 
4385         builder.appendNumber(coordinate.toUnsigned());
4386     }
4387     builder.appendLiteral(&quot; }&quot;);
4388 }
4389 
4390 void Internals::setPlatformMomentumScrollingPredictionEnabled(bool enabled)
4391 {
4392     ScrollingMomentumCalculator::setPlatformMomentumScrollingPredictionEnabled(enabled);
4393 }
4394 
4395 ExceptionOr&lt;String&gt; Internals::scrollSnapOffsets(Element&amp; element)
4396 {
4397     element.document().updateLayoutIgnorePendingStylesheets();
4398 
4399     if (!element.renderBox())
4400         return String();
4401 
4402     RenderBox&amp; box = *element.renderBox();
4403     ScrollableArea* scrollableArea;
4404 
4405     if (box.isBody()) {
4406         FrameView* frameView = box.frame().mainFrame().view();
4407         if (!frameView || !frameView-&gt;isScrollable())
4408             return Exception { InvalidAccessError };
4409         scrollableArea = frameView;
4410 
4411     } else {
4412         if (!box.canBeScrolledAndHasScrollableArea())
4413             return Exception { InvalidAccessError };
4414         scrollableArea = box.layer();
4415     }
4416 
4417     if (!scrollableArea)
4418         return String();
4419 
4420     StringBuilder result;
4421 
4422     if (auto* offsets = scrollableArea-&gt;horizontalSnapOffsets()) {
4423         if (offsets-&gt;size()) {
4424             result.appendLiteral(&quot;horizontal = &quot;);
4425             appendOffsets(result, *offsets);
4426         }
4427     }
4428 
4429     if (auto* offsets = scrollableArea-&gt;verticalSnapOffsets()) {
4430         if (offsets-&gt;size()) {
4431             if (result.length())
4432                 result.appendLiteral(&quot;, &quot;);
4433 
4434             result.appendLiteral(&quot;vertical = &quot;);
4435             appendOffsets(result, *offsets);
4436         }
4437     }
4438 
4439     return result.toString();
4440 }
4441 
4442 #endif
4443 
4444 bool Internals::testPreloaderSettingViewport()
4445 {
4446     return testPreloadScannerViewportSupport(contextDocument());
4447 }
4448 
4449 ExceptionOr&lt;String&gt; Internals::pathStringWithShrinkWrappedRects(const Vector&lt;double&gt;&amp; rectComponents, double radius)
4450 {
4451     if (rectComponents.size() % 4)
4452         return Exception { InvalidAccessError };
4453 
4454     Vector&lt;FloatRect&gt; rects;
4455     for (unsigned i = 0; i &lt; rectComponents.size(); i += 4)
4456         rects.append(FloatRect(rectComponents[i], rectComponents[i + 1], rectComponents[i + 2], rectComponents[i + 3]));
4457 
4458     SVGPathStringBuilder builder;
4459     PathUtilities::pathWithShrinkWrappedRects(rects, radius).apply([&amp;builder](const PathElement&amp; element) {
4460         switch (element.type) {
4461         case PathElement::Type::MoveToPoint:
4462             builder.moveTo(element.points[0], false, AbsoluteCoordinates);
4463             return;
4464         case PathElement::Type::AddLineToPoint:
4465             builder.lineTo(element.points[0], AbsoluteCoordinates);
4466             return;
4467         case PathElement::Type::AddQuadCurveToPoint:
4468             builder.curveToQuadratic(element.points[0], element.points[1], AbsoluteCoordinates);
4469             return;
4470         case PathElement::Type::AddCurveToPoint:
4471             builder.curveToCubic(element.points[0], element.points[1], element.points[2], AbsoluteCoordinates);
4472             return;
4473         case PathElement::Type::CloseSubpath:
4474             builder.closePath();
4475             return;
4476         }
4477         ASSERT_NOT_REACHED();
4478     });
4479     return builder.result();
4480 }
4481 
4482 
4483 String Internals::getCurrentMediaControlsStatusForElement(HTMLMediaElement&amp; mediaElement)
4484 {
4485 #if !ENABLE(MEDIA_CONTROLS_SCRIPT)
4486     UNUSED_PARAM(mediaElement);
4487     return String();
4488 #else
4489     return mediaElement.getCurrentMediaControlsStatus();
4490 #endif
4491 }
4492 
4493 #if !PLATFORM(COCOA)
4494 
4495 String Internals::userVisibleString(const DOMURL&amp; url)
4496 {
4497     return WTF::URLHelpers::userVisibleURL(url.href().string().utf8());
4498 }
4499 
4500 #endif
4501 
4502 void Internals::setShowAllPlugins(bool show)
4503 {
4504     Document* document = contextDocument();
4505     if (!document)
4506         return;
4507 
4508     Page* page = document-&gt;page();
4509     if (!page)
4510         return;
4511 
4512     page-&gt;setShowAllPlugins(show);
4513 }
4514 
4515 #if ENABLE(STREAMS_API)
4516 
4517 bool Internals::isReadableStreamDisturbed(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSValue stream)
4518 {
4519     return ReadableStream::isDisturbed(lexicalGlobalObject, stream);
4520 }
4521 
4522 JSValue Internals::cloneArrayBuffer(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSValue buffer, JSValue srcByteOffset, JSValue srcLength)
4523 {
4524     JSC::VM&amp; vm = lexicalGlobalObject.vm();
4525     JSVMClientData* clientData = static_cast&lt;JSVMClientData*&gt;(vm.clientData);
4526     const Identifier&amp; privateName = clientData-&gt;builtinNames().cloneArrayBufferPrivateName();
4527     JSValue value;
4528     PropertySlot propertySlot(value, PropertySlot::InternalMethodType::Get);
4529     lexicalGlobalObject.methodTable(vm)-&gt;getOwnPropertySlot(&amp;lexicalGlobalObject, &amp;lexicalGlobalObject, privateName, propertySlot);
4530     value = propertySlot.getValue(&amp;lexicalGlobalObject, privateName);
4531     ASSERT(value.isFunction(vm));
4532 
4533     JSObject* function = value.getObject();
4534     CallData callData;
4535     CallType callType = JSC::getCallData(vm, function, callData);
4536     ASSERT(callType != JSC::CallType::None);
4537     MarkedArgumentBuffer arguments;
4538     arguments.append(buffer);
4539     arguments.append(srcByteOffset);
4540     arguments.append(srcLength);
4541     ASSERT(!arguments.hasOverflowed());
4542 
4543     return JSC::call(&amp;lexicalGlobalObject, function, callType, callData, JSC::jsUndefined(), arguments);
4544 }
4545 
4546 #endif
4547 
4548 String Internals::resourceLoadStatisticsForURL(const DOMURL&amp; url)
4549 {
4550     return ResourceLoadObserver::shared().statisticsForURL(url.href());
4551 }
4552 
4553 void Internals::setResourceLoadStatisticsEnabled(bool enable)
4554 {
4555     DeprecatedGlobalSettings::setResourceLoadStatisticsEnabled(enable);
4556 }
4557 
4558 String Internals::composedTreeAsText(Node&amp; node)
4559 {
4560     if (!is&lt;ContainerNode&gt;(node))
4561         return emptyString();
4562     return WebCore::composedTreeAsText(downcast&lt;ContainerNode&gt;(node));
4563 }
4564 
4565 bool Internals::isProcessingUserGesture()
4566 {
4567     return UserGestureIndicator::processingUserGesture();
4568 }
4569 
4570 void Internals::withUserGesture(RefPtr&lt;VoidCallback&gt;&amp;&amp; callback)
4571 {
4572     UserGestureIndicator gestureIndicator(ProcessingUserGesture, contextDocument());
4573     callback-&gt;handleEvent();
4574 }
4575 
4576 bool Internals::userIsInteracting()
4577 {
4578     if (auto* document = contextDocument()) {
4579         if (auto* page = document-&gt;page())
4580             return page-&gt;chrome().client().userIsInteracting();
4581     }
4582     return false;
4583 }
4584 
4585 double Internals::lastHandledUserGestureTimestamp()
4586 {
4587     Document* document = contextDocument();
4588     if (!document)
4589         return 0;
4590 
4591     return document-&gt;lastHandledUserGestureTimestamp().secondsSinceEpoch().value();
4592 }
4593 
4594 RefPtr&lt;GCObservation&gt; Internals::observeGC(JSC::JSValue value)
4595 {
4596     if (!value.isObject())
4597         return nullptr;
4598     return GCObservation::create(asObject(value));
4599 }
4600 
4601 void Internals::setUserInterfaceLayoutDirection(UserInterfaceLayoutDirection userInterfaceLayoutDirection)
4602 {
4603     Document* document = contextDocument();
4604     if (!document)
4605         return;
4606 
4607     Page* page = document-&gt;page();
4608     if (!page)
4609         return;
4610 
4611     page-&gt;setUserInterfaceLayoutDirection(userInterfaceLayoutDirection == UserInterfaceLayoutDirection::LTR ? WebCore::UserInterfaceLayoutDirection::LTR : WebCore::UserInterfaceLayoutDirection::RTL);
4612 }
4613 
4614 #if !PLATFORM(COCOA)
4615 
4616 bool Internals::userPrefersReducedMotion() const
4617 {
4618     return false;
4619 }
4620 
4621 #if ENABLE(VIDEO)
4622 double Internals::privatePlayerVolume(const HTMLMediaElement&amp;)
4623 {
4624     return 0;
4625 }
4626 #endif
4627 
4628 #endif
4629 
4630 void Internals::reportBacktrace()
4631 {
4632     WTFReportBacktrace();
4633 }
4634 
4635 void Internals::setBaseWritingDirection(BaseWritingDirection direction)
4636 {
4637     if (auto* document = contextDocument()) {
4638         if (auto* frame = document-&gt;frame()) {
4639             switch (direction) {
4640             case BaseWritingDirection::Ltr:
4641                 frame-&gt;editor().setBaseWritingDirection(WritingDirection::LeftToRight);
4642                 break;
4643             case BaseWritingDirection::Rtl:
4644                 frame-&gt;editor().setBaseWritingDirection(WritingDirection::RightToLeft);
4645                 break;
4646             case BaseWritingDirection::Natural:
4647                 frame-&gt;editor().setBaseWritingDirection(WritingDirection::Natural);
4648                 break;
4649             }
4650         }
4651     }
4652 }
4653 
4654 #if ENABLE(POINTER_LOCK)
4655 bool Internals::pageHasPendingPointerLock() const
4656 {
4657     Document* document = contextDocument();
4658     if (!document)
4659         return false;
4660 
4661     Page* page = document-&gt;page();
4662     if (!page)
4663         return false;
4664 
4665     return page-&gt;pointerLockController().lockPending();
4666 }
4667 
4668 bool Internals::pageHasPointerLock() const
4669 {
4670     Document* document = contextDocument();
4671     if (!document)
4672         return false;
4673 
4674     Page* page = document-&gt;page();
4675     if (!page)
4676         return false;
4677 
4678     auto&amp; controller = page-&gt;pointerLockController();
4679     return controller.element() &amp;&amp; !controller.lockPending();
4680 }
4681 #endif
4682 
4683 void Internals::markContextAsInsecure()
4684 {
4685     auto* document = contextDocument();
4686     if (!document)
4687         return;
4688 
4689     document-&gt;securityOrigin().setIsPotentiallyTrustworthy(false);
4690 }
4691 
4692 void Internals::postTask(RefPtr&lt;VoidCallback&gt;&amp;&amp; callback)
4693 {
4694     auto* document = contextDocument();
4695     if (!document) {
4696         callback-&gt;handleEvent();
4697         return;
4698     }
4699 
4700     document-&gt;postTask([callback = WTFMove(callback)](ScriptExecutionContext&amp;) {
4701         callback-&gt;handleEvent();
4702     });
4703 }
4704 
4705 static Optional&lt;TaskSource&gt; taskSourceFromString(const String&amp; taskSourceName)
4706 {
4707     if (taskSourceName == &quot;DOMManipulation&quot;)
4708         return TaskSource::DOMManipulation;
4709     return WTF::nullopt;
4710 }
4711 
4712 ExceptionOr&lt;void&gt; Internals::queueTask(ScriptExecutionContext&amp; context, const String&amp; taskSourceName, RefPtr&lt;VoidCallback&gt;&amp;&amp; callback)
4713 {
4714     auto source = taskSourceFromString(taskSourceName);
4715     if (!source)
4716         return Exception { NotSupportedError };
4717 
4718     context.eventLoop().queueTask(*source, [callback = WTFMove(callback)] {
4719         callback-&gt;handleEvent();
4720     });
4721 
4722     return { };
4723 }
4724 
4725 ExceptionOr&lt;void&gt; Internals::queueTaskToQueueMicrotask(Document&amp; document, const String&amp; taskSourceName, RefPtr&lt;VoidCallback&gt;&amp;&amp; callback)
4726 {
4727     auto source = taskSourceFromString(taskSourceName);
4728     if (!source)
4729         return Exception { NotSupportedError };
4730 
4731     ScriptExecutionContext&amp; context = document; // This avoids unnecessarily exporting Document::eventLoop.
4732     context.eventLoop().queueTask(*source, [movedCallback = WTFMove(callback), protectedDocument = makeRef(document)]() mutable {
4733         ScriptExecutionContext&amp; context = protectedDocument.get();
4734         context.eventLoop().queueMicrotask([callback = WTFMove(movedCallback)] {
4735             callback-&gt;handleEvent();
4736         });
4737     });
4738 
4739     return { };
4740 }
4741 
4742 ExceptionOr&lt;bool&gt; Internals::hasSameEventLoopAs(WindowProxy&amp; proxy)
4743 {
4744     RefPtr&lt;ScriptExecutionContext&gt; context = contextDocument();
4745     if (!context || !proxy.frame())
4746         return Exception { InvalidStateError };
4747 
4748     auto&amp; proxyFrame = *proxy.frame();
4749     if (!is&lt;Frame&gt;(proxyFrame))
4750         return false;
4751     RefPtr&lt;ScriptExecutionContext&gt; proxyContext = downcast&lt;Frame&gt;(proxyFrame).document();
4752     if (!proxyContext)
4753         return Exception { InvalidStateError };
4754 
4755     return context-&gt;eventLoop().hasSameEventLoopAs(proxyContext-&gt;eventLoop());
4756 }
4757 
4758 Vector&lt;String&gt; Internals::accessKeyModifiers() const
4759 {
4760     Vector&lt;String&gt; accessKeyModifierStrings;
4761 
4762     for (auto modifier : EventHandler::accessKeyModifiers()) {
4763         switch (modifier) {
4764         case PlatformEvent::Modifier::AltKey:
4765             accessKeyModifierStrings.append(&quot;altKey&quot;_s);
4766             break;
4767         case PlatformEvent::Modifier::ControlKey:
4768             accessKeyModifierStrings.append(&quot;ctrlKey&quot;_s);
4769             break;
4770         case PlatformEvent::Modifier::MetaKey:
4771             accessKeyModifierStrings.append(&quot;metaKey&quot;_s);
4772             break;
4773         case PlatformEvent::Modifier::ShiftKey:
4774             accessKeyModifierStrings.append(&quot;shiftKey&quot;_s);
4775             break;
4776         case PlatformEvent::Modifier::CapsLockKey:
4777             accessKeyModifierStrings.append(&quot;capsLockKey&quot;_s);
4778             break;
4779         case PlatformEvent::Modifier::AltGraphKey:
4780             ASSERT_NOT_REACHED(); // AltGraph is only for DOM API.
4781             break;
4782         }
4783     }
4784 
4785     return accessKeyModifierStrings;
4786 }
4787 
4788 void Internals::setQuickLookPassword(const String&amp; password)
4789 {
4790 #if PLATFORM(IOS_FAMILY) &amp;&amp; USE(QUICK_LOOK)
4791     auto&amp; quickLookHandleClient = MockPreviewLoaderClient::singleton();
4792     LegacyPreviewLoader::setClientForTesting(&amp;quickLookHandleClient);
4793     quickLookHandleClient.setPassword(password);
4794 #else
4795     UNUSED_PARAM(password);
4796 #endif
4797 }
4798 
4799 void Internals::setAsRunningUserScripts(Document&amp; document)
4800 {
4801     document.setAsRunningUserScripts();
4802 }
4803 
4804 #if ENABLE(APPLE_PAY)
4805 void Internals::setApplePayIsActive(Document&amp; document)
4806 {
4807     document.setApplePayIsActive();
4808 }
4809 #endif
4810 
4811 #if ENABLE(WEBGL)
4812 void Internals::simulateWebGLContextChanged(WebGLRenderingContext&amp; context)
4813 {
4814     context.simulateContextChanged();
4815 }
4816 
4817 void Internals::failNextGPUStatusCheck(WebGLRenderingContext&amp; context)
4818 {
4819     context.setFailNextGPUStatusCheck();
4820 }
4821 
4822 bool Internals::hasLowAndHighPowerGPUs()
4823 {
4824 #if PLATFORM(MAC)
4825     return WebCore::hasLowAndHighPowerGPUs();
4826 #else
4827     return false;
4828 #endif
4829 }
4830 #endif
4831 
4832 void Internals::setPageVisibility(bool isVisible)
4833 {
4834     auto* document = contextDocument();
4835     if (!document || !document-&gt;page())
4836         return;
4837     auto&amp; page = *document-&gt;page();
4838     auto state = page.activityState();
4839 
4840     if (!isVisible)
4841         state.remove(ActivityState::IsVisible);
4842     else
4843         state.add(ActivityState::IsVisible);
4844 
4845     page.setActivityState(state);
4846 }
4847 
4848 void Internals::setPageIsFocusedAndActive(bool isFocusedAndActive)
4849 {
4850     auto* document = contextDocument();
4851     if (!document || !document-&gt;page())
4852         return;
4853     auto&amp; page = *document-&gt;page();
4854     auto state = page.activityState();
4855 
4856     if (!isFocusedAndActive)
4857         state.remove({ ActivityState::IsFocused, ActivityState::WindowIsActive });
4858     else
4859         state.add({ ActivityState::IsFocused, ActivityState::WindowIsActive });
4860 
4861     page.setActivityState(state);
4862 }
4863 
4864 #if ENABLE(WEB_RTC)
4865 void Internals::setH264HardwareEncoderAllowed(bool allowed)
4866 {
4867     auto* document = contextDocument();
4868     if (!document || !document-&gt;page())
4869         return;
4870     document-&gt;page()-&gt;libWebRTCProvider().setH264HardwareEncoderAllowed(allowed);
4871 }
4872 #endif
4873 
4874 #if ENABLE(MEDIA_STREAM)
4875 void Internals::setMockAudioTrackChannelNumber(MediaStreamTrack&amp; track, unsigned short channelNumber)
4876 {
4877     auto&amp; source = track.source();
4878     if (!is&lt;MockRealtimeAudioSource&gt;(source))
4879         return;
4880     downcast&lt;MockRealtimeAudioSource&gt;(source).setChannelCount(channelNumber);
4881 }
4882 
4883 void Internals::setCameraMediaStreamTrackOrientation(MediaStreamTrack&amp; track, int orientation)
4884 {
4885     auto&amp; source = track.source();
4886     if (!source.isCaptureSource())
4887         return;
4888     m_orientationNotifier.orientationChanged(orientation);
4889     source.monitorOrientation(m_orientationNotifier);
4890 }
4891 
4892 void Internals::observeMediaStreamTrack(MediaStreamTrack&amp; track)
4893 {
4894     m_track = &amp;track;
4895     m_track-&gt;source().addObserver(*this);
4896 }
4897 
4898 void Internals::grabNextMediaStreamTrackFrame(TrackFramePromise&amp;&amp; promise)
4899 {
4900     m_nextTrackFramePromise = WTF::makeUnique&lt;TrackFramePromise&gt;(promise);
4901 }
4902 
4903 void Internals::videoSampleAvailable(MediaSample&amp; sample)
4904 {
4905     m_trackVideoSampleCount++;
4906     if (!m_nextTrackFramePromise)
4907         return;
4908 
4909     auto&amp; videoSettings = m_track-&gt;source().settings();
4910     if (!videoSettings.width() || !videoSettings.height())
4911         return;
4912 
4913     auto rgba = sample.getRGBAImageData();
4914     if (!rgba)
4915         return;
4916 
4917     auto imageData = ImageData::create(rgba.releaseNonNull(), videoSettings.width(), videoSettings.height());
4918     if (!imageData.hasException())
4919         m_nextTrackFramePromise-&gt;resolve(imageData.releaseReturnValue().releaseNonNull());
4920     else
4921         m_nextTrackFramePromise-&gt;reject(imageData.exception().code());
4922     m_nextTrackFramePromise = nullptr;
4923 }
4924 
4925 void Internals::delayMediaStreamTrackSamples(MediaStreamTrack&amp; track, float delay)
4926 {
4927     track.source().delaySamples(Seconds { delay });
4928 }
4929 
4930 void Internals::setMediaStreamTrackMuted(MediaStreamTrack&amp; track, bool muted)
4931 {
4932     track.source().setMuted(muted);
4933 }
4934 
4935 void Internals::removeMediaStreamTrack(MediaStream&amp; stream, MediaStreamTrack&amp; track)
4936 {
4937     stream.internalRemoveTrack(track.id(), MediaStream::StreamModifier::Platform);
4938 }
4939 
4940 void Internals::simulateMediaStreamTrackCaptureSourceFailure(MediaStreamTrack&amp; track)
4941 {
4942     track.source().captureFailed();
4943 }
4944 
4945 void Internals::setMediaStreamTrackIdentifier(MediaStreamTrack&amp; track, String&amp;&amp; id)
4946 {
4947     track.setIdForTesting(WTFMove(id));
4948 }
4949 
4950 void Internals::setMediaStreamSourceInterrupted(MediaStreamTrack&amp; track, bool interrupted)
4951 {
4952     track.source().setInterruptedForTesting(interrupted);
4953 }
4954 
4955 bool Internals::isMockRealtimeMediaSourceCenterEnabled()
4956 {
4957     return MockRealtimeMediaSourceCenter::mockRealtimeMediaSourceCenterEnabled();
4958 }
4959 #endif
4960 
4961 bool Internals::supportsAudioSession() const
4962 {
4963 #if USE(AUDIO_SESSION)
4964     return true;
4965 #else
4966     return false;
4967 #endif
4968 }
4969 
4970 String Internals::audioSessionCategory() const
4971 {
4972 #if USE(AUDIO_SESSION)
4973     switch (AudioSession::sharedSession().category()) {
4974     case AudioSession::AmbientSound:
4975         return &quot;AmbientSound&quot;_s;
4976     case AudioSession::SoloAmbientSound:
4977         return &quot;SoloAmbientSound&quot;_s;
4978     case AudioSession::MediaPlayback:
4979         return &quot;MediaPlayback&quot;_s;
4980     case AudioSession::RecordAudio:
4981         return &quot;RecordAudio&quot;_s;
4982     case AudioSession::PlayAndRecord:
4983         return &quot;PlayAndRecord&quot;_s;
4984     case AudioSession::AudioProcessing:
4985         return &quot;AudioProcessing&quot;_s;
4986     case AudioSession::None:
4987         return &quot;None&quot;_s;
4988     }
4989 #endif
4990     return emptyString();
4991 }
4992 
4993 double Internals::preferredAudioBufferSize() const
4994 {
4995 #if USE(AUDIO_SESSION)
4996     return AudioSession::sharedSession().preferredBufferSize();
4997 #endif
4998     return 0;
4999 }
5000 
5001 bool Internals::audioSessionActive() const
5002 {
5003 #if USE(AUDIO_SESSION)
5004     return AudioSession::sharedSession().isActive();
5005 #endif
5006     return false;
5007 }
5008 
5009 void Internals::storeRegistrationsOnDisk(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
5010 {
5011 #if ENABLE(SERVICE_WORKER)
5012     if (!contextDocument())
5013         return;
5014 
5015     auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnection();
5016     connection.storeRegistrationsOnDiskForTesting([promise = WTFMove(promise)]() mutable {
5017         promise.resolve();
5018     });
5019 #else
5020     promise.resolve();
5021 #endif
5022 }
5023 
5024 void Internals::clearCacheStorageMemoryRepresentation(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
5025 {
5026     auto* document = contextDocument();
5027     if (!document)
5028         return;
5029 
5030     if (!m_cacheStorageConnection) {
5031         if (auto* page = contextDocument()-&gt;page())
5032             m_cacheStorageConnection = page-&gt;cacheStorageProvider().createCacheStorageConnection();
5033         if (!m_cacheStorageConnection)
5034             return;
5035     }
5036     m_cacheStorageConnection-&gt;clearMemoryRepresentation(ClientOrigin { document-&gt;topOrigin().data(), document-&gt;securityOrigin().data() }, [promise = WTFMove(promise)] (auto &amp;&amp; result) mutable {
5037         ASSERT_UNUSED(result, !result);
5038         promise.resolve();
5039     });
5040 }
5041 
5042 void Internals::cacheStorageEngineRepresentation(DOMPromiseDeferred&lt;IDLDOMString&gt;&amp;&amp; promise)
5043 {
5044     auto* document = contextDocument();
5045     if (!document)
5046         return;
5047 
5048     if (!m_cacheStorageConnection) {
5049         if (auto* page = contextDocument()-&gt;page())
5050             m_cacheStorageConnection = page-&gt;cacheStorageProvider().createCacheStorageConnection();
5051         if (!m_cacheStorageConnection)
5052             return;
5053     }
5054     m_cacheStorageConnection-&gt;engineRepresentation([promise = WTFMove(promise)](const String&amp; result) mutable {
5055         promise.resolve(result);
5056     });
5057 }
5058 
5059 void Internals::updateQuotaBasedOnSpaceUsage()
5060 {
5061     auto* document = contextDocument();
5062     if (!document)
5063         return;
5064 
5065     if (!m_cacheStorageConnection) {
5066         if (auto* page = contextDocument()-&gt;page())
5067             m_cacheStorageConnection = page-&gt;cacheStorageProvider().createCacheStorageConnection();
5068         if (!m_cacheStorageConnection)
5069             return;
5070     }
5071 
5072     m_cacheStorageConnection-&gt;updateQuotaBasedOnSpaceUsage(ClientOrigin { document-&gt;topOrigin().data(), document-&gt;securityOrigin().data() });
5073 }
5074 
5075 void Internals::setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp; listener)
5076 {
5077     if (!contextDocument())
5078         return;
5079 
5080     contextDocument()-&gt;setConsoleMessageListener(WTFMove(listener));
5081 }
5082 
5083 void Internals::setResponseSizeWithPadding(FetchResponse&amp; response, uint64_t size)
5084 {
5085     response.setBodySizeWithPadding(size);
5086 }
5087 
5088 uint64_t Internals::responseSizeWithPadding(FetchResponse&amp; response) const
5089 {
5090     return response.bodySizeWithPadding();
5091 }
5092 
5093 #if ENABLE(SERVICE_WORKER)
5094 void Internals::hasServiceWorkerRegistration(const String&amp; clientURL, HasRegistrationPromise&amp;&amp; promise)
5095 {
5096     if (!contextDocument())
5097         return;
5098 
5099     URL parsedURL = contextDocument()-&gt;completeURL(clientURL);
5100 
5101     return ServiceWorkerProvider::singleton().serviceWorkerConnection().matchRegistration(SecurityOriginData { contextDocument()-&gt;topOrigin().data() }, parsedURL, [promise = WTFMove(promise)] (auto&amp;&amp; result) mutable {
5102         promise.resolve(!!result);
5103     });
5104 }
5105 
5106 void Internals::terminateServiceWorker(ServiceWorker&amp; worker)
5107 {
5108     if (!contextDocument())
5109         return;
5110 
5111     ServiceWorkerProvider::singleton().serviceWorkerConnection().syncTerminateWorker(worker.identifier());
5112 }
5113 
5114 void Internals::isServiceWorkerRunning(ServiceWorker&amp; worker, DOMPromiseDeferred&lt;IDLBoolean&gt;&amp;&amp; promise)
5115 {
5116     return ServiceWorkerProvider::singleton().serviceWorkerConnection().isServiceWorkerRunning(worker.identifier(), [promise = WTFMove(promise)](bool result) mutable {
5117         promise.resolve(result);
5118     });
5119 }
5120 #endif
5121 
5122 #if ENABLE(APPLE_PAY)
5123 MockPaymentCoordinator&amp; Internals::mockPaymentCoordinator(Document&amp; document)
5124 {
5125     return downcast&lt;MockPaymentCoordinator&gt;(document.frame()-&gt;page()-&gt;paymentCoordinator().client());
5126 }
5127 #endif
5128 
5129 bool Internals::isSystemPreviewLink(Element&amp; element) const
5130 {
5131 #if USE(SYSTEM_PREVIEW)
5132     return is&lt;HTMLAnchorElement&gt;(element) &amp;&amp; downcast&lt;HTMLAnchorElement&gt;(element).isSystemPreviewLink();
5133 #else
5134     UNUSED_PARAM(element);
5135     return false;
5136 #endif
5137 }
5138 
5139 bool Internals::isSystemPreviewImage(Element&amp; element) const
5140 {
5141 #if USE(SYSTEM_PREVIEW)
5142     if (is&lt;HTMLImageElement&gt;(element))
5143         return downcast&lt;HTMLImageElement&gt;(element).isSystemPreviewImage();
5144     if (is&lt;HTMLPictureElement&gt;(element))
5145         return downcast&lt;HTMLPictureElement&gt;(element).isSystemPreviewImage();
5146     return false;
5147 #else
5148     UNUSED_PARAM(element);
5149     return false;
5150 #endif
5151 }
5152 
5153 bool Internals::usingAppleInternalSDK() const
5154 {
5155 #if USE(APPLE_INTERNAL_SDK)
5156     return true;
5157 #else
5158     return false;
5159 #endif
5160 }
5161 
5162 void Internals::setCaptureExtraNetworkLoadMetricsEnabled(bool value)
5163 {
5164     platformStrategies()-&gt;loaderStrategy()-&gt;setCaptureExtraNetworkLoadMetricsEnabled(value);
5165 }
5166 
5167 String Internals::ongoingLoadsDescriptions() const
5168 {
5169     StringBuilder builder;
5170     builder.append(&#39;[&#39;);
5171     bool isStarting = true;
5172     for (auto&amp; identifier : platformStrategies()-&gt;loaderStrategy()-&gt;ongoingLoads()) {
5173         if (isStarting)
5174             isStarting = false;
5175         else
5176             builder.append(&#39;,&#39;);
5177 
5178         builder.append(&#39;[&#39;);
5179 
5180         for (auto&amp; info : platformStrategies()-&gt;loaderStrategy()-&gt;intermediateLoadInformationFromResourceLoadIdentifier(identifier))
5181             builder.append(&#39;[&#39;, (int)info.type, &quot;,\&quot;&quot;, info.request.url().string(), &quot;\&quot;,\&quot;&quot;, info.request.httpMethod(), &quot;\&quot;,&quot;, info.response.httpStatusCode(), &#39;]&#39;);
5182 
5183         builder.append(&#39;]&#39;);
5184     }
5185     builder.append(&#39;]&#39;);
5186     return builder.toString();
5187 }
5188 
5189 void Internals::reloadWithoutContentExtensions()
5190 {
5191     if (auto* frame = this-&gt;frame())
5192         frame-&gt;loader().reload(ReloadOption::DisableContentBlockers);
5193 }
5194 
5195 void Internals::setUseSystemAppearance(bool value)
5196 {
5197     if (!contextDocument() || !contextDocument()-&gt;page())
5198         return;
5199     contextDocument()-&gt;page()-&gt;setUseSystemAppearance(value);
5200 }
5201 
5202 size_t Internals::pluginCount()
5203 {
5204     if (!contextDocument() || !contextDocument()-&gt;page())
5205         return 0;
5206 
5207     return contextDocument()-&gt;page()-&gt;pluginData().webVisiblePlugins().size();
5208 }
5209 
5210 void Internals::notifyResourceLoadObserver()
5211 {
5212     ResourceLoadObserver::shared().updateCentralStatisticsStore();
5213 }
5214 
5215 unsigned Internals::primaryScreenDisplayID()
5216 {
5217 #if PLATFORM(MAC)
5218     return WebCore::primaryScreenDisplayID();
5219 #else
5220     return 0;
5221 #endif
5222 }
5223 
5224 bool Internals::capsLockIsOn()
5225 {
5226     return WebCore::PlatformKeyboardEvent::currentCapsLockState();
5227 }
5228 
5229 bool Internals::supportsVCPEncoder()
5230 {
5231 #if defined(ENABLE_VCP_ENCODER)
5232     return ENABLE_VCP_ENCODER || ENABLE_VCP_VTB_ENCODER;
5233 #else
5234     return false;
5235 #endif
5236 }
5237 
5238 Optional&lt;HEVCParameterSet&gt; Internals::parseHEVCCodecParameters(const String&amp; codecString)
5239 {
5240     return WebCore::parseHEVCCodecParameters(codecString);
5241 }
5242 
5243 Optional&lt;DoViParameterSet&gt; Internals::parseDoViCodecParameters(const String&amp; codecString)
5244 {
5245     return WebCore::parseDoViCodecParameters(codecString);
5246 }
5247 
5248 auto Internals::getCookies() const -&gt; Vector&lt;CookieData&gt;
5249 {
5250     auto* document = contextDocument();
5251     if (!document)
5252         return { };
5253 
5254     auto* page = document-&gt;page();
5255     if (!page)
5256         return { };
5257 
5258     Vector&lt;Cookie&gt; cookies;
5259     page-&gt;cookieJar().getRawCookies(*document, document-&gt;cookieURL(), cookies);
5260     return WTF::map(cookies, [](auto&amp; cookie) {
5261         return CookieData { cookie };
5262     });
5263 }
5264 
5265 void Internals::setAlwaysAllowLocalWebarchive(bool alwaysAllowLocalWebarchive)
5266 {
5267     auto* localFrame = frame();
5268     if (!localFrame)
5269         return;
5270     localFrame-&gt;loader().setAlwaysAllowLocalWebarchive(alwaysAllowLocalWebarchive);
5271 }
5272 
5273 void Internals::processWillSuspend()
5274 {
5275 #if ENABLE(VIDEO) || ENABLE(WEB_AUDIO)
5276     PlatformMediaSessionManager::sharedManager().processWillSuspend();
5277 #endif
5278 }
5279 
5280 void Internals::processDidResume()
5281 {
5282 #if ENABLE(VIDEO) || ENABLE(WEB_AUDIO)
5283     PlatformMediaSessionManager::sharedManager().processDidResume();
5284 #endif
5285 }
5286 
5287 void Internals::testDictionaryLogging()
5288 {
5289     auto* document = contextDocument();
5290     if (!document)
5291         return;
5292 
5293     auto* page = document-&gt;page();
5294     if (!page)
5295         return;
5296 
5297     DiagnosticLoggingClient::ValueDictionary dictionary;
5298     dictionary.set(&quot;stringKey&quot;_s, String(&quot;stringValue&quot;));
5299     dictionary.set(&quot;uint64Key&quot;_s, std::numeric_limits&lt;uint64_t&gt;::max());
5300     dictionary.set(&quot;int64Key&quot;_s, std::numeric_limits&lt;int64_t&gt;::min());
5301     dictionary.set(&quot;boolKey&quot;_s, true);
5302     dictionary.set(&quot;doubleKey&quot;_s, 2.7182818284590452353602874);
5303 
5304     page-&gt;diagnosticLoggingClient().logDiagnosticMessageWithValueDictionary(&quot;testMessage&quot;_s, &quot;testDescription&quot;_s, dictionary, ShouldSample::No);
5305 }
5306 
5307 void Internals::setXHRMaximumIntervalForUserGestureForwarding(XMLHttpRequest&amp; request, double interval)
5308 {
5309     request.setMaximumIntervalForUserGestureForwarding(interval);
5310 }
5311 
5312 void Internals::setTransientActivationDuration(double seconds)
5313 {
5314     DOMWindow::overrideTransientActivationDurationForTesting(Seconds { seconds });
5315 }
5316 
5317 void Internals::setIsPlayingToAutomotiveHeadUnit(bool isPlaying)
5318 {
5319 #if ENABLE(VIDEO) || ENABLE(WEB_AUDIO)
5320     PlatformMediaSessionManager::sharedManager().setIsPlayingToAutomotiveHeadUnit(isPlaying);
5321 #endif
5322 }
5323 
5324 String Internals::highlightPseudoElementColor(const String&amp; highlightName, Element&amp; element)
5325 {
5326     element.document().updateStyleIfNeeded();
5327 
5328     auto&amp; styleResolver = element.document().styleScope().resolver();
5329     auto* parentStyle = element.computedStyle();
5330     if (!parentStyle)
5331         return { };
5332 
5333     auto style = styleResolver.pseudoStyleForElement(element, { PseudoId::Highlight, highlightName }, *parentStyle);
5334     if (!style)
5335         return { };
5336 
5337     return style-&gt;color().cssText();
5338 }
5339 
5340 Internals::TextIndicatorInfo::TextIndicatorInfo()
5341 {
5342 }
5343 
5344 Internals::TextIndicatorInfo::TextIndicatorInfo(const WebCore::TextIndicatorData&amp; data)
5345     : textBoundingRectInRootViewCoordinates(DOMRect::create(data.textBoundingRectInRootViewCoordinates))
5346     , textRectsInBoundingRectCoordinates(DOMRectList::create(data.textRectsInBoundingRectCoordinates))
5347 {
5348 }
5349 
5350 Internals::TextIndicatorInfo::~TextIndicatorInfo() = default;
5351 
5352 Internals::TextIndicatorInfo Internals::textIndicatorForRange(const Range&amp; range, TextIndicatorOptions options)
5353 {
5354     auto indicator = TextIndicator::createWithRange(range, options.core(), TextIndicatorPresentationTransition::None);
5355     return indicator-&gt;data();
5356 }
5357 
5358 void Internals::addPrefetchLoadEventListener(HTMLLinkElement&amp; link, RefPtr&lt;EventListener&gt;&amp;&amp; listener)
5359 {
5360     if (RuntimeEnabledFeatures::sharedFeatures().linkPrefetchEnabled() &amp;&amp; equalLettersIgnoringASCIICase(link.rel(), &quot;prefetch&quot;)) {
5361         link.allowPrefetchLoadAndErrorForTesting();
5362         link.addEventListener(eventNames().loadEvent, listener.releaseNonNull(), false);
5363     }
5364 }
5365 
5366 #if ENABLE(WEB_AUTHN)
5367 void Internals::setMockWebAuthenticationConfiguration(const MockWebAuthenticationConfiguration&amp; configuration)
5368 {
5369     auto* document = contextDocument();
5370     if (!document)
5371         return;
5372     auto* page = document-&gt;page();
5373     if (!page)
5374         return;
5375     page-&gt;chrome().client().setMockWebAuthenticationConfiguration(configuration);
5376 }
5377 #endif
5378 
5379 #if ENABLE(PICTURE_IN_PICTURE_API)
5380 void Internals::setPictureInPictureAPITestEnabled(HTMLVideoElement&amp; videoElement, bool enabled)
5381 {
5382     videoElement.setPictureInPictureAPITestEnabled(enabled);
5383 }
5384 #endif
5385 
5386 void Internals::setMaxCanvasPixelMemory(unsigned size)
5387 {
5388     HTMLCanvasElement::setMaxPixelMemoryForTesting(size);
5389 }
5390 
5391 int Internals::processIdentifier() const
5392 {
5393     return getCurrentProcessID();
5394 }
5395 
5396 Ref&lt;InternalsMapLike&gt; Internals::createInternalsMapLike()
5397 {
5398     return InternalsMapLike::create();
5399 }
5400 
5401 Ref&lt;InternalsSetLike&gt; Internals::createInternalsSetLike()
5402 {
5403     return InternalsSetLike::create();
5404 }
5405 
5406 bool Internals::hasSandboxMachLookupAccessToGlobalName(const String&amp; process, const String&amp; service)
5407 {
5408 #if PLATFORM(COCOA)
5409     pid_t pid;
5410     if (process == &quot;com.apple.WebKit.WebContent&quot;)
5411         pid = getpid();
5412     else
5413         RELEASE_ASSERT_NOT_REACHED();
5414 
5415     return !sandbox_check(pid, &quot;mach-lookup&quot;, static_cast&lt;enum sandbox_filter_type&gt;(SANDBOX_FILTER_GLOBAL_NAME | SANDBOX_CHECK_NO_REPORT), service.utf8().data());
5416 #else
5417     UNUSED_PARAM(process);
5418     UNUSED_PARAM(service);
5419     return false;
5420 #endif
5421 }
5422 
5423 bool Internals::hasSandboxMachLookupAccessToXPCServiceName(const String&amp; process, const String&amp; service)
5424 {
5425 #if PLATFORM(COCOA)
5426     pid_t pid;
5427     if (process == &quot;com.apple.WebKit.WebContent&quot;)
5428         pid = getpid();
5429     else
5430         RELEASE_ASSERT_NOT_REACHED();
5431 
5432     return !sandbox_check(pid, &quot;mach-lookup&quot;, static_cast&lt;enum sandbox_filter_type&gt;(SANDBOX_FILTER_XPC_SERVICE_NAME | SANDBOX_CHECK_NO_REPORT), service.utf8().data());
5433 #else
5434     UNUSED_PARAM(process);
5435     UNUSED_PARAM(service);
5436     return false;
5437 #endif
5438 }
5439 
5440 String Internals::windowLocationHost(DOMWindow&amp; window)
5441 {
5442     return window.location().host();
5443 }
5444 
5445 String Internals::systemColorForCSSValue(const String&amp; cssValue, bool useDarkModeAppearance, bool useElevatedUserInterfaceLevel)
5446 {
5447     CSSValueID id = cssValueKeywordID(cssValue);
5448     RELEASE_ASSERT(StyleColor::isSystemColor(id));
5449 
5450     OptionSet&lt;StyleColor::Options&gt; options;
5451     if (useDarkModeAppearance)
5452         options.add(StyleColor::Options::UseDarkAppearance);
5453     if (useElevatedUserInterfaceLevel)
5454         options.add(StyleColor::Options::UseElevatedUserInterfaceLevel);
5455 
5456     return RenderTheme::singleton().systemColor(id, options).cssText();
5457 }
5458 
5459 bool Internals::systemHasBattery() const
5460 {
5461 #if PLATFORM(COCOA)
5462     return WebCore::systemHasBattery();
5463 #else
5464     return false;
5465 #endif
5466 }
5467 
5468 String Internals::mediaMIMETypeForExtension(const String&amp; extension)
5469 {
5470     return MIMETypeRegistry::getMediaMIMETypeForExtension(extension);
5471 }
5472 
5473 String Internals::focusRingColor()
5474 {
5475     OptionSet&lt;StyleColor::Options&gt; options;
5476     return RenderTheme::singleton().focusRingColor(options).cssText();
5477 }
5478 
5479 } // namespace WebCore
    </pre>
  </body>
</html>
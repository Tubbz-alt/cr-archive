<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/parser/HTMLPreloadScanner.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLParserScheduler.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="HTMLPreloadScanner.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/parser/HTMLPreloadScanner.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;HTMLPreloadScanner.h&quot;
 30 
 31 #include &quot;HTMLNames.h&quot;
 32 #include &quot;HTMLParserIdioms.h&quot;
 33 #include &quot;HTMLSrcsetParser.h&quot;
 34 #include &quot;HTMLTokenizer.h&quot;
 35 #include &quot;InputTypeNames.h&quot;
 36 #include &quot;LinkLoader.h&quot;
 37 #include &quot;LinkRelAttribute.h&quot;
 38 #include &quot;Logging.h&quot;
 39 #include &quot;MIMETypeRegistry.h&quot;
 40 #include &quot;MediaList.h&quot;
 41 #include &quot;MediaQueryEvaluator.h&quot;
 42 #include &quot;MediaQueryParser.h&quot;
 43 #include &quot;RenderView.h&quot;
 44 #include &quot;RuntimeEnabledFeatures.h&quot;


 45 #include &quot;SizesAttributeParser.h&quot;
 46 #include &lt;wtf/MainThread.h&gt;
 47 
 48 namespace WebCore {
 49 
 50 using namespace HTMLNames;
 51 
 52 TokenPreloadScanner::TagId TokenPreloadScanner::tagIdFor(const HTMLToken::DataVector&amp; data)
 53 {
 54     AtomString tagName(data);
 55     if (tagName == imgTag)
 56         return TagId::Img;
 57     if (tagName == inputTag)
 58         return TagId::Input;
 59     if (tagName == linkTag)
 60         return TagId::Link;
 61     if (tagName == scriptTag)
 62         return TagId::Script;
 63     if (tagName == styleTag)
 64         return TagId::Style;
</pre>
<hr />
<pre>
225                 auto documentElement = makeRefPtr(document.documentElement());
226                 LOG(MediaQueries, &quot;HTMLPreloadScanner %p processAttribute evaluating media queries&quot;, this);
227                 m_mediaMatched = MediaQueryEvaluator { document.printing() ? &quot;print&quot; : &quot;screen&quot;, document, documentElement ? documentElement-&gt;computedStyle() : nullptr }.evaluate(mediaSet.get());
228             }
229             if (match(attributeName, typeAttr) &amp;&amp; m_typeAttribute.isNull()) {
230                 // when multiple type attributes present: first value wins, ignore subsequent (to match ImageElement parser and Blink behaviours)
231                 m_typeAttribute = attributeValue;
232                 m_typeMatched &amp;= MIMETypeRegistry::isSupportedImageVideoOrSVGMIMEType(m_typeAttribute);
233             }
234             break;
235         case TagId::Script:
236             if (match(attributeName, typeAttr)) {
237                 m_moduleScript = equalLettersIgnoringASCIICase(attributeValue, &quot;module&quot;) ? PreloadRequest::ModuleScript::Yes : PreloadRequest::ModuleScript::No;
238                 break;
239             } else if (match(attributeName, nonceAttr)) {
240                 m_nonceAttribute = attributeValue;
241                 break;
242             } else if (match(attributeName, referrerpolicyAttr)) {
243                 m_referrerPolicy = parseReferrerPolicy(attributeValue, ReferrerPolicySource::ReferrerPolicyAttribute).valueOr(ReferrerPolicy::EmptyString);
244                 break;



245             }
246             processImageAndScriptAttribute(attributeName, attributeValue);
247             break;
248         case TagId::Link:
249             if (match(attributeName, hrefAttr))
250                 setUrlToLoad(attributeValue);
251             else if (match(attributeName, relAttr)) {
252                 LinkRelAttribute parsedAttribute { document, attributeValue };
253                 m_linkIsStyleSheet = relAttributeIsStyleSheet(parsedAttribute);
254                 m_linkIsPreload = parsedAttribute.isLinkPreload;
255             } else if (match(attributeName, mediaAttr))
256                 m_mediaAttribute = attributeValue;
257             else if (match(attributeName, charsetAttr))
258                 m_charset = attributeValue;
259             else if (match(attributeName, crossoriginAttr))
260                 m_crossOriginMode = stripLeadingAndTrailingHTMLSpaces(attributeValue);
261             else if (match(attributeName, nonceAttr))
262                 m_nonceAttribute = attributeValue;
263             else if (match(attributeName, asAttr))
264                 m_asAttribute = attributeValue;
</pre>
<hr />
<pre>
335             break;
336         }
337         ASSERT_NOT_REACHED();
338         return CachedResource::Type::RawResource;
339     }
340 
341     bool shouldPreload()
342     {
343         if (m_urlToLoad.isEmpty())
344             return false;
345 
346         if (protocolIs(m_urlToLoad, &quot;data&quot;) || protocolIs(m_urlToLoad, &quot;about&quot;))
347             return false;
348 
349         if (m_tagId == TagId::Link &amp;&amp; !m_linkIsStyleSheet &amp;&amp; !m_linkIsPreload)
350             return false;
351 
352         if (m_tagId == TagId::Input &amp;&amp; !m_inputIsImage)
353             return false;
354 



355         return true;
356     }
357 
358     TagId m_tagId;
359     String m_urlToLoad;
360     String m_srcSetAttribute;
361     String m_sizesAttribute;
362     bool m_mediaMatched { true };
363     bool m_typeMatched { true };
364     String m_charset;
365     String m_crossOriginMode;
366     bool m_linkIsStyleSheet;
367     bool m_linkIsPreload;
368     String m_mediaAttribute;
369     String m_nonceAttribute;
370     String m_metaContent;
371     String m_asAttribute;
372     String m_typeAttribute;
373     bool m_metaIsViewport;
374     bool m_metaIsDisabledAdaptations;
375     bool m_inputIsImage;

376     float m_deviceScaleFactor;
377     PreloadRequest::ModuleScript m_moduleScript { PreloadRequest::ModuleScript::No };
378     ReferrerPolicy m_referrerPolicy { ReferrerPolicy::EmptyString };
379 };
380 
381 TokenPreloadScanner::TokenPreloadScanner(const URL&amp; documentURL, float deviceScaleFactor)
382     : m_documentURL(documentURL)
383     , m_deviceScaleFactor(deviceScaleFactor)
384 {
385 }
386 
387 void TokenPreloadScanner::scan(const HTMLToken&amp; token, Vector&lt;std::unique_ptr&lt;PreloadRequest&gt;&gt;&amp; requests, Document&amp; document)
388 {
389     switch (token.type()) {
390     case HTMLToken::Character:
391         if (!m_inStyle)
392             return;
393         m_cssScanner.scan(token.characters(), requests);
394         return;
395 
</pre>
<hr />
<pre>
409 
410         return;
411     }
412 
413     case HTMLToken::StartTag: {
414         if (m_templateCount)
415             return;
416         TagId tagId = tagIdFor(token.name());
417         if (tagId == TagId::Template) {
418             ++m_templateCount;
419             return;
420         }
421         if (tagId == TagId::Style) {
422             m_inStyle = true;
423             return;
424         }
425         if (tagId == TagId::Base) {
426             // The first &lt;base&gt; element is the one that wins.
427             if (!m_predictedBaseElementURL.isEmpty())
428                 return;
<span class="line-modified">429             updatePredictedBaseURL(token);</span>
430             return;
431         }
432         if (tagId == TagId::Picture) {
433             m_pictureSourceState.append(false);
434             return;
435         }
436 
437         StartTagScanner scanner(tagId, m_deviceScaleFactor);
438         scanner.processAttributes(token.attributes(), document, m_pictureSourceState);
439         if (auto request = scanner.createPreloadRequest(m_predictedBaseElementURL))
440             requests.append(WTFMove(request));
441         return;
442     }
443 
444     default:
445         return;
446     }
447 }
448 
<span class="line-modified">449 void TokenPreloadScanner::updatePredictedBaseURL(const HTMLToken&amp; token)</span>
450 {
451     ASSERT(m_predictedBaseElementURL.isEmpty());
<span class="line-modified">452     if (auto* hrefAttribute = findAttribute(token.attributes(), hrefAttr-&gt;localName().string()))</span>
<span class="line-modified">453         m_predictedBaseElementURL = URL(m_documentURL, stripLeadingAndTrailingHTMLSpaces(StringImpl::create8BitIfPossible(hrefAttribute-&gt;value))).isolatedCopy();</span>




454 }
455 
456 HTMLPreloadScanner::HTMLPreloadScanner(const HTMLParserOptions&amp; options, const URL&amp; documentURL, float deviceScaleFactor)
457     : m_scanner(documentURL, deviceScaleFactor)
458     , m_tokenizer(options)
459 {
460 }
461 
462 void HTMLPreloadScanner::appendToEnd(const SegmentedString&amp; source)
463 {
464     m_source.append(source);
465 }
466 
467 void HTMLPreloadScanner::scan(HTMLResourcePreloader&amp; preloader, Document&amp; document)
468 {
469     ASSERT(isMainThread()); // HTMLTokenizer::updateStateFor only works on the main thread.
470 
471     const URL&amp; startingBaseElementURL = document.baseElementURL();
472 
473     // When we start scanning, our best prediction of the baseElementURL is the real one!
</pre>
</td>
<td>
<hr />
<pre>
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;HTMLPreloadScanner.h&quot;
 30 
 31 #include &quot;HTMLNames.h&quot;
 32 #include &quot;HTMLParserIdioms.h&quot;
 33 #include &quot;HTMLSrcsetParser.h&quot;
 34 #include &quot;HTMLTokenizer.h&quot;
 35 #include &quot;InputTypeNames.h&quot;
 36 #include &quot;LinkLoader.h&quot;
 37 #include &quot;LinkRelAttribute.h&quot;
 38 #include &quot;Logging.h&quot;
 39 #include &quot;MIMETypeRegistry.h&quot;
 40 #include &quot;MediaList.h&quot;
 41 #include &quot;MediaQueryEvaluator.h&quot;
 42 #include &quot;MediaQueryParser.h&quot;
 43 #include &quot;RenderView.h&quot;
 44 #include &quot;RuntimeEnabledFeatures.h&quot;
<span class="line-added"> 45 #include &quot;SecurityPolicy.h&quot;</span>
<span class="line-added"> 46 #include &quot;Settings.h&quot;</span>
 47 #include &quot;SizesAttributeParser.h&quot;
 48 #include &lt;wtf/MainThread.h&gt;
 49 
 50 namespace WebCore {
 51 
 52 using namespace HTMLNames;
 53 
 54 TokenPreloadScanner::TagId TokenPreloadScanner::tagIdFor(const HTMLToken::DataVector&amp; data)
 55 {
 56     AtomString tagName(data);
 57     if (tagName == imgTag)
 58         return TagId::Img;
 59     if (tagName == inputTag)
 60         return TagId::Input;
 61     if (tagName == linkTag)
 62         return TagId::Link;
 63     if (tagName == scriptTag)
 64         return TagId::Script;
 65     if (tagName == styleTag)
 66         return TagId::Style;
</pre>
<hr />
<pre>
227                 auto documentElement = makeRefPtr(document.documentElement());
228                 LOG(MediaQueries, &quot;HTMLPreloadScanner %p processAttribute evaluating media queries&quot;, this);
229                 m_mediaMatched = MediaQueryEvaluator { document.printing() ? &quot;print&quot; : &quot;screen&quot;, document, documentElement ? documentElement-&gt;computedStyle() : nullptr }.evaluate(mediaSet.get());
230             }
231             if (match(attributeName, typeAttr) &amp;&amp; m_typeAttribute.isNull()) {
232                 // when multiple type attributes present: first value wins, ignore subsequent (to match ImageElement parser and Blink behaviours)
233                 m_typeAttribute = attributeValue;
234                 m_typeMatched &amp;= MIMETypeRegistry::isSupportedImageVideoOrSVGMIMEType(m_typeAttribute);
235             }
236             break;
237         case TagId::Script:
238             if (match(attributeName, typeAttr)) {
239                 m_moduleScript = equalLettersIgnoringASCIICase(attributeValue, &quot;module&quot;) ? PreloadRequest::ModuleScript::Yes : PreloadRequest::ModuleScript::No;
240                 break;
241             } else if (match(attributeName, nonceAttr)) {
242                 m_nonceAttribute = attributeValue;
243                 break;
244             } else if (match(attributeName, referrerpolicyAttr)) {
245                 m_referrerPolicy = parseReferrerPolicy(attributeValue, ReferrerPolicySource::ReferrerPolicyAttribute).valueOr(ReferrerPolicy::EmptyString);
246                 break;
<span class="line-added">247             } else if (match(attributeName, nomoduleAttr)) {</span>
<span class="line-added">248                 m_scriptIsNomodule = true;</span>
<span class="line-added">249                 break;</span>
250             }
251             processImageAndScriptAttribute(attributeName, attributeValue);
252             break;
253         case TagId::Link:
254             if (match(attributeName, hrefAttr))
255                 setUrlToLoad(attributeValue);
256             else if (match(attributeName, relAttr)) {
257                 LinkRelAttribute parsedAttribute { document, attributeValue };
258                 m_linkIsStyleSheet = relAttributeIsStyleSheet(parsedAttribute);
259                 m_linkIsPreload = parsedAttribute.isLinkPreload;
260             } else if (match(attributeName, mediaAttr))
261                 m_mediaAttribute = attributeValue;
262             else if (match(attributeName, charsetAttr))
263                 m_charset = attributeValue;
264             else if (match(attributeName, crossoriginAttr))
265                 m_crossOriginMode = stripLeadingAndTrailingHTMLSpaces(attributeValue);
266             else if (match(attributeName, nonceAttr))
267                 m_nonceAttribute = attributeValue;
268             else if (match(attributeName, asAttr))
269                 m_asAttribute = attributeValue;
</pre>
<hr />
<pre>
340             break;
341         }
342         ASSERT_NOT_REACHED();
343         return CachedResource::Type::RawResource;
344     }
345 
346     bool shouldPreload()
347     {
348         if (m_urlToLoad.isEmpty())
349             return false;
350 
351         if (protocolIs(m_urlToLoad, &quot;data&quot;) || protocolIs(m_urlToLoad, &quot;about&quot;))
352             return false;
353 
354         if (m_tagId == TagId::Link &amp;&amp; !m_linkIsStyleSheet &amp;&amp; !m_linkIsPreload)
355             return false;
356 
357         if (m_tagId == TagId::Input &amp;&amp; !m_inputIsImage)
358             return false;
359 
<span class="line-added">360         if (m_tagId == TagId::Script &amp;&amp; m_moduleScript == PreloadRequest::ModuleScript::No &amp;&amp; m_scriptIsNomodule)</span>
<span class="line-added">361             return false;</span>
<span class="line-added">362 </span>
363         return true;
364     }
365 
366     TagId m_tagId;
367     String m_urlToLoad;
368     String m_srcSetAttribute;
369     String m_sizesAttribute;
370     bool m_mediaMatched { true };
371     bool m_typeMatched { true };
372     String m_charset;
373     String m_crossOriginMode;
374     bool m_linkIsStyleSheet;
375     bool m_linkIsPreload;
376     String m_mediaAttribute;
377     String m_nonceAttribute;
378     String m_metaContent;
379     String m_asAttribute;
380     String m_typeAttribute;
381     bool m_metaIsViewport;
382     bool m_metaIsDisabledAdaptations;
383     bool m_inputIsImage;
<span class="line-added">384     bool m_scriptIsNomodule { false };</span>
385     float m_deviceScaleFactor;
386     PreloadRequest::ModuleScript m_moduleScript { PreloadRequest::ModuleScript::No };
387     ReferrerPolicy m_referrerPolicy { ReferrerPolicy::EmptyString };
388 };
389 
390 TokenPreloadScanner::TokenPreloadScanner(const URL&amp; documentURL, float deviceScaleFactor)
391     : m_documentURL(documentURL)
392     , m_deviceScaleFactor(deviceScaleFactor)
393 {
394 }
395 
396 void TokenPreloadScanner::scan(const HTMLToken&amp; token, Vector&lt;std::unique_ptr&lt;PreloadRequest&gt;&gt;&amp; requests, Document&amp; document)
397 {
398     switch (token.type()) {
399     case HTMLToken::Character:
400         if (!m_inStyle)
401             return;
402         m_cssScanner.scan(token.characters(), requests);
403         return;
404 
</pre>
<hr />
<pre>
418 
419         return;
420     }
421 
422     case HTMLToken::StartTag: {
423         if (m_templateCount)
424             return;
425         TagId tagId = tagIdFor(token.name());
426         if (tagId == TagId::Template) {
427             ++m_templateCount;
428             return;
429         }
430         if (tagId == TagId::Style) {
431             m_inStyle = true;
432             return;
433         }
434         if (tagId == TagId::Base) {
435             // The first &lt;base&gt; element is the one that wins.
436             if (!m_predictedBaseElementURL.isEmpty())
437                 return;
<span class="line-modified">438             updatePredictedBaseURL(token, document.settings().shouldRestrictBaseURLSchemes());</span>
439             return;
440         }
441         if (tagId == TagId::Picture) {
442             m_pictureSourceState.append(false);
443             return;
444         }
445 
446         StartTagScanner scanner(tagId, m_deviceScaleFactor);
447         scanner.processAttributes(token.attributes(), document, m_pictureSourceState);
448         if (auto request = scanner.createPreloadRequest(m_predictedBaseElementURL))
449             requests.append(WTFMove(request));
450         return;
451     }
452 
453     default:
454         return;
455     }
456 }
457 
<span class="line-modified">458 void TokenPreloadScanner::updatePredictedBaseURL(const HTMLToken&amp; token, bool shouldRestrictBaseURLSchemes)</span>
459 {
460     ASSERT(m_predictedBaseElementURL.isEmpty());
<span class="line-modified">461     auto* hrefAttribute = findAttribute(token.attributes(), hrefAttr-&gt;localName().string());</span>
<span class="line-modified">462     if (!hrefAttribute)</span>
<span class="line-added">463         return;</span>
<span class="line-added">464     URL temp { m_documentURL, stripLeadingAndTrailingHTMLSpaces(StringImpl::create8BitIfPossible(hrefAttribute-&gt;value)) };</span>
<span class="line-added">465     if (!shouldRestrictBaseURLSchemes || SecurityPolicy::isBaseURLSchemeAllowed(temp))</span>
<span class="line-added">466         m_predictedBaseElementURL = temp.isolatedCopy();</span>
467 }
468 
469 HTMLPreloadScanner::HTMLPreloadScanner(const HTMLParserOptions&amp; options, const URL&amp; documentURL, float deviceScaleFactor)
470     : m_scanner(documentURL, deviceScaleFactor)
471     , m_tokenizer(options)
472 {
473 }
474 
475 void HTMLPreloadScanner::appendToEnd(const SegmentedString&amp; source)
476 {
477     m_source.append(source);
478 }
479 
480 void HTMLPreloadScanner::scan(HTMLResourcePreloader&amp; preloader, Document&amp; document)
481 {
482     ASSERT(isMainThread()); // HTMLTokenizer::updateStateFor only works on the main thread.
483 
484     const URL&amp; startingBaseElementURL = document.baseElementURL();
485 
486     // When we start scanning, our best prediction of the baseElementURL is the real one!
</pre>
</td>
</tr>
</table>
<center><a href="HTMLParserScheduler.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="HTMLPreloadScanner.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
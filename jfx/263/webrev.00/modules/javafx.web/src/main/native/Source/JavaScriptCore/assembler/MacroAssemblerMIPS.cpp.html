<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerMIPS.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(ASSEMBLER) &amp;&amp; CPU(MIPS)
 29 #include &quot;MacroAssembler.h&quot;
 30 
 31 #include &quot;ProbeContext.h&quot;
 32 #include &lt;wtf/InlineASM.h&gt;
 33 #include &lt;wtf/MathExtras.h&gt;
 34 
 35 namespace JSC {
 36 
 37 #if ENABLE(MASM_PROBE)
 38 
 39 extern &quot;C&quot; void ctiMasmProbeTrampoline();
 40 
 41 using namespace MIPSRegisters;
 42 
 43 #if COMPILER(GCC_COMPATIBLE)
 44 
 45 // The following are offsets for Probe::State fields accessed
 46 // by the ctiMasmProbeTrampoline stub.
 47 
 48 #define PTR_SIZE 4
 49 #define PROBE_PROBE_FUNCTION_OFFSET (0 * PTR_SIZE)
 50 #define PROBE_ARG_OFFSET (1 * PTR_SIZE)
 51 #define PROBE_INIT_STACK_FUNCTION_OFFSET (2 * PTR_SIZE)
 52 #define PROBE_INIT_STACK_ARG_OFFSET (3 * PTR_SIZE)
 53 
 54 #define PROBE_INSTRUCTIONS_AFTER_CALL 2
 55 
 56 #define PROBE_FIRST_GPREG_OFFSET (4 * PTR_SIZE)
 57 
 58 #define GPREG_SIZE 4
 59 #define PROBE_CPU_ZR_OFFSET (PROBE_FIRST_GPREG_OFFSET + (0 * GPREG_SIZE))
 60 #define PROBE_CPU_AT_OFFSET (PROBE_FIRST_GPREG_OFFSET + (1 * GPREG_SIZE))
 61 #define PROBE_CPU_V0_OFFSET (PROBE_FIRST_GPREG_OFFSET + (2 * GPREG_SIZE))
 62 #define PROBE_CPU_V1_OFFSET (PROBE_FIRST_GPREG_OFFSET + (3 * GPREG_SIZE))
 63 #define PROBE_CPU_A0_OFFSET (PROBE_FIRST_GPREG_OFFSET + (4 * GPREG_SIZE))
 64 #define PROBE_CPU_A1_OFFSET (PROBE_FIRST_GPREG_OFFSET + (5 * GPREG_SIZE))
 65 #define PROBE_CPU_A2_OFFSET (PROBE_FIRST_GPREG_OFFSET + (6 * GPREG_SIZE))
 66 #define PROBE_CPU_A3_OFFSET (PROBE_FIRST_GPREG_OFFSET + (7 * GPREG_SIZE))
 67 #define PROBE_CPU_T0_OFFSET (PROBE_FIRST_GPREG_OFFSET + (8 * GPREG_SIZE))
 68 #define PROBE_CPU_T1_OFFSET (PROBE_FIRST_GPREG_OFFSET + (9 * GPREG_SIZE))
 69 #define PROBE_CPU_T2_OFFSET (PROBE_FIRST_GPREG_OFFSET + (10 * GPREG_SIZE))
 70 #define PROBE_CPU_T3_OFFSET (PROBE_FIRST_GPREG_OFFSET + (11 * GPREG_SIZE))
 71 #define PROBE_CPU_T4_OFFSET (PROBE_FIRST_GPREG_OFFSET + (12 * GPREG_SIZE))
 72 #define PROBE_CPU_T5_OFFSET (PROBE_FIRST_GPREG_OFFSET + (13 * GPREG_SIZE))
 73 #define PROBE_CPU_T6_OFFSET (PROBE_FIRST_GPREG_OFFSET + (14 * GPREG_SIZE))
 74 #define PROBE_CPU_T7_OFFSET (PROBE_FIRST_GPREG_OFFSET + (15 * GPREG_SIZE))
 75 #define PROBE_CPU_S0_OFFSET (PROBE_FIRST_GPREG_OFFSET + (16 * GPREG_SIZE))
 76 #define PROBE_CPU_S1_OFFSET (PROBE_FIRST_GPREG_OFFSET + (17 * GPREG_SIZE))
 77 #define PROBE_CPU_S2_OFFSET (PROBE_FIRST_GPREG_OFFSET + (18 * GPREG_SIZE))
 78 #define PROBE_CPU_S3_OFFSET (PROBE_FIRST_GPREG_OFFSET + (19 * GPREG_SIZE))
 79 #define PROBE_CPU_S4_OFFSET (PROBE_FIRST_GPREG_OFFSET + (20 * GPREG_SIZE))
 80 #define PROBE_CPU_S5_OFFSET (PROBE_FIRST_GPREG_OFFSET + (21 * GPREG_SIZE))
 81 #define PROBE_CPU_S6_OFFSET (PROBE_FIRST_GPREG_OFFSET + (22 * GPREG_SIZE))
 82 #define PROBE_CPU_S7_OFFSET (PROBE_FIRST_GPREG_OFFSET + (23 * GPREG_SIZE))
 83 #define PROBE_CPU_T8_OFFSET (PROBE_FIRST_GPREG_OFFSET + (24 * GPREG_SIZE))
 84 #define PROBE_CPU_T9_OFFSET (PROBE_FIRST_GPREG_OFFSET + (25 * GPREG_SIZE))
 85 #define PROBE_CPU_K0_OFFSET (PROBE_FIRST_GPREG_OFFSET + (26 * GPREG_SIZE))
 86 #define PROBE_CPU_K1_OFFSET (PROBE_FIRST_GPREG_OFFSET + (27 * GPREG_SIZE))
 87 #define PROBE_CPU_GP_OFFSET (PROBE_FIRST_GPREG_OFFSET + (28 * GPREG_SIZE))
 88 #define PROBE_CPU_SP_OFFSET (PROBE_FIRST_GPREG_OFFSET + (29 * GPREG_SIZE))
 89 #define PROBE_CPU_FP_OFFSET (PROBE_FIRST_GPREG_OFFSET + (30 * GPREG_SIZE))
 90 #define PROBE_CPU_RA_OFFSET (PROBE_FIRST_GPREG_OFFSET + (31 * GPREG_SIZE))
 91 
 92 #define PROBE_FIRST_SPREG_OFFSET (PROBE_FIRST_GPREG_OFFSET + (32 * GPREG_SIZE))
 93 
 94 #define PROBE_CPU_FIR_OFFSET (PROBE_FIRST_SPREG_OFFSET + (0 * GPREG_SIZE))
 95 #define PROBE_CPU_FCCR_OFFSET (PROBE_FIRST_SPREG_OFFSET + (25 * GPREG_SIZE))
 96 #define PROBE_CPU_FEXR_OFFSET (PROBE_FIRST_SPREG_OFFSET + (26 * GPREG_SIZE))
 97 #define PROBE_CPU_FENR_OFFSET (PROBE_FIRST_SPREG_OFFSET + (28 * GPREG_SIZE))
 98 #define PROBE_CPU_FCSR_OFFSET (PROBE_FIRST_SPREG_OFFSET + (31 * GPREG_SIZE))
 99 #define PROBE_CPU_PC_OFFSET (PROBE_FIRST_SPREG_OFFSET + (32 * GPREG_SIZE))
100 
101 #define PROBE_FIRST_FPREG_OFFSET (PROBE_FIRST_SPREG_OFFSET + (34 * GPREG_SIZE))
102 
103 #define FPREG_SIZE 8
104 #define PROBE_CPU_F0_OFFSET  (PROBE_FIRST_FPREG_OFFSET + (0 * FPREG_SIZE))
105 #define PROBE_CPU_F1_OFFSET  (PROBE_FIRST_FPREG_OFFSET + (1 * FPREG_SIZE))
106 #define PROBE_CPU_F2_OFFSET  (PROBE_FIRST_FPREG_OFFSET + (2 * FPREG_SIZE))
107 #define PROBE_CPU_F3_OFFSET  (PROBE_FIRST_FPREG_OFFSET + (3 * FPREG_SIZE))
108 #define PROBE_CPU_F4_OFFSET  (PROBE_FIRST_FPREG_OFFSET + (4 * FPREG_SIZE))
109 #define PROBE_CPU_F5_OFFSET  (PROBE_FIRST_FPREG_OFFSET + (5 * FPREG_SIZE))
110 #define PROBE_CPU_F6_OFFSET  (PROBE_FIRST_FPREG_OFFSET + (6 * FPREG_SIZE))
111 #define PROBE_CPU_F7_OFFSET  (PROBE_FIRST_FPREG_OFFSET + (7 * FPREG_SIZE))
112 #define PROBE_CPU_F8_OFFSET  (PROBE_FIRST_FPREG_OFFSET + (8 * FPREG_SIZE))
113 #define PROBE_CPU_F9_OFFSET  (PROBE_FIRST_FPREG_OFFSET + (9 * FPREG_SIZE))
114 #define PROBE_CPU_F10_OFFSET (PROBE_FIRST_FPREG_OFFSET + (10 * FPREG_SIZE))
115 #define PROBE_CPU_F11_OFFSET (PROBE_FIRST_FPREG_OFFSET + (11 * FPREG_SIZE))
116 #define PROBE_CPU_F12_OFFSET (PROBE_FIRST_FPREG_OFFSET + (12 * FPREG_SIZE))
117 #define PROBE_CPU_F13_OFFSET (PROBE_FIRST_FPREG_OFFSET + (13 * FPREG_SIZE))
118 #define PROBE_CPU_F14_OFFSET (PROBE_FIRST_FPREG_OFFSET + (14 * FPREG_SIZE))
119 #define PROBE_CPU_F15_OFFSET (PROBE_FIRST_FPREG_OFFSET + (15 * FPREG_SIZE))
120 #define PROBE_CPU_F16_OFFSET (PROBE_FIRST_FPREG_OFFSET + (16 * FPREG_SIZE))
121 #define PROBE_CPU_F17_OFFSET (PROBE_FIRST_FPREG_OFFSET + (17 * FPREG_SIZE))
122 #define PROBE_CPU_F18_OFFSET (PROBE_FIRST_FPREG_OFFSET + (18 * FPREG_SIZE))
123 #define PROBE_CPU_F19_OFFSET (PROBE_FIRST_FPREG_OFFSET + (19 * FPREG_SIZE))
124 #define PROBE_CPU_F20_OFFSET (PROBE_FIRST_FPREG_OFFSET + (20 * FPREG_SIZE))
125 #define PROBE_CPU_F21_OFFSET (PROBE_FIRST_FPREG_OFFSET + (21 * FPREG_SIZE))
126 #define PROBE_CPU_F22_OFFSET (PROBE_FIRST_FPREG_OFFSET + (22 * FPREG_SIZE))
127 #define PROBE_CPU_F23_OFFSET (PROBE_FIRST_FPREG_OFFSET + (23 * FPREG_SIZE))
128 #define PROBE_CPU_F24_OFFSET (PROBE_FIRST_FPREG_OFFSET + (24 * FPREG_SIZE))
129 #define PROBE_CPU_F25_OFFSET (PROBE_FIRST_FPREG_OFFSET + (25 * FPREG_SIZE))
130 #define PROBE_CPU_F26_OFFSET (PROBE_FIRST_FPREG_OFFSET + (26 * FPREG_SIZE))
131 #define PROBE_CPU_F27_OFFSET (PROBE_FIRST_FPREG_OFFSET + (27 * FPREG_SIZE))
132 #define PROBE_CPU_F28_OFFSET (PROBE_FIRST_FPREG_OFFSET + (28 * FPREG_SIZE))
133 #define PROBE_CPU_F29_OFFSET (PROBE_FIRST_FPREG_OFFSET + (29 * FPREG_SIZE))
134 #define PROBE_CPU_F30_OFFSET (PROBE_FIRST_FPREG_OFFSET + (30 * FPREG_SIZE))
135 #define PROBE_CPU_F31_OFFSET (PROBE_FIRST_FPREG_OFFSET + (31 * FPREG_SIZE))
136 
137 #define PROBE_SIZE (PROBE_FIRST_FPREG_OFFSET + (32 * FPREG_SIZE))
138 
139 #define SAVED_PROBE_RETURN_PC_OFFSET        (PROBE_SIZE + (0 * PTR_SIZE))
140 #define PROBE_SIZE_PLUS_EXTRAS              (PROBE_SIZE + (2 * PTR_SIZE))
141 // PROBE_SIZE_PLUS_EXTRAS = PROBE_SIZE + SAVED_PROBE_RETURN_PC + padding
142 
143 #define FIR    0
144 #define FCCR  25
145 #define FEXR  26
146 #define FENR  28
147 #define FCSR  31
148 
149 // These ASSERTs remind you that if you change the layout of Probe::State,
150 // you need to change ctiMasmProbeTrampoline offsets above to match.
151 #define PROBE_OFFSETOF(x) offsetof(struct Probe::State, x)
152 static_assert(PROBE_OFFSETOF(probeFunction) == PROBE_PROBE_FUNCTION_OFFSET, &quot;Probe::State::probeFunction&#39;s offset matches ctiMasmProbeTrampoline&quot;);
153 static_assert(PROBE_OFFSETOF(arg) == PROBE_ARG_OFFSET, &quot;Probe::State::arg&#39;s offset matches ctiMasmProbeTrampoline&quot;);
154 static_assert(PROBE_OFFSETOF(initializeStackFunction) == PROBE_INIT_STACK_FUNCTION_OFFSET, &quot;Probe::State::initializeStackFunction&#39;s offset matches ctiMasmProbeTrampoline&quot;);
155 static_assert(PROBE_OFFSETOF(initializeStackArg) == PROBE_INIT_STACK_ARG_OFFSET, &quot;Probe::State::initializeStackArg&#39;s offset matches ctiMasmProbeTrampoline&quot;);
156 
157 static_assert(!(PROBE_CPU_ZR_OFFSET &amp; 0x3), &quot;Probe::State::cpu.gprs[zero]&#39;s offset should be 4 byte aligned&quot;);
158 
159 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::zero]) == PROBE_CPU_ZR_OFFSET, &quot;Probe::State::cpu.gprs[zero]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
160 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::at]) == PROBE_CPU_AT_OFFSET, &quot;Probe::State::cpu.gprs[at]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
161 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::v0]) == PROBE_CPU_V0_OFFSET, &quot;Probe::State::cpu.gprs[v0]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
162 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::v1]) == PROBE_CPU_V1_OFFSET, &quot;Probe::State::cpu.gprs[v1]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
163 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::a0]) == PROBE_CPU_A0_OFFSET, &quot;Probe::State::cpu.gprs[a0]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
164 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::a1]) == PROBE_CPU_A1_OFFSET, &quot;Probe::State::cpu.gprs[a1]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
165 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::a2]) == PROBE_CPU_A2_OFFSET, &quot;Probe::State::cpu.gprs[a2]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
166 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::a3]) == PROBE_CPU_A3_OFFSET, &quot;Probe::State::cpu.gprs[a3]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
167 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::t0]) == PROBE_CPU_T0_OFFSET, &quot;Probe::State::cpu.gprs[t0]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
168 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::t1]) == PROBE_CPU_T1_OFFSET, &quot;Probe::State::cpu.gprs[t1]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
169 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::t2]) == PROBE_CPU_T2_OFFSET, &quot;Probe::State::cpu.gprs[t2]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
170 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::t3]) == PROBE_CPU_T3_OFFSET, &quot;Probe::State::cpu.gprs[t3]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
171 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::t4]) == PROBE_CPU_T4_OFFSET, &quot;Probe::State::cpu.gprs[t4]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
172 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::t5]) == PROBE_CPU_T5_OFFSET, &quot;Probe::State::cpu.gprs[t5]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
173 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::t6]) == PROBE_CPU_T6_OFFSET, &quot;Probe::State::cpu.gprs[t6]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
174 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::t7]) == PROBE_CPU_T7_OFFSET, &quot;Probe::State::cpu.gprs[t7]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
175 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::s0]) == PROBE_CPU_S0_OFFSET, &quot;Probe::State::cpu.gprs[s0]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
176 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::s1]) == PROBE_CPU_S1_OFFSET, &quot;Probe::State::cpu.gprs[s1]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
177 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::s2]) == PROBE_CPU_S2_OFFSET, &quot;Probe::State::cpu.gprs[s2]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
178 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::s3]) == PROBE_CPU_S3_OFFSET, &quot;Probe::State::cpu.gprs[s3]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
179 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::s4]) == PROBE_CPU_S4_OFFSET, &quot;Probe::State::cpu.gprs[s4]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
180 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::s5]) == PROBE_CPU_S5_OFFSET, &quot;Probe::State::cpu.gprs[s5]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
181 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::s6]) == PROBE_CPU_S6_OFFSET, &quot;Probe::State::cpu.gprs[s6]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
182 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::s7]) == PROBE_CPU_S7_OFFSET, &quot;Probe::State::cpu.gprs[s7]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
183 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::t8]) == PROBE_CPU_T8_OFFSET, &quot;Probe::State::cpu.gprs[t8]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
184 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::t9]) == PROBE_CPU_T9_OFFSET, &quot;Probe::State::cpu.gprs[t9]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
185 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::k0]) == PROBE_CPU_K0_OFFSET, &quot;Probe::State::cpu.gprs[k0]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
186 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::k1]) == PROBE_CPU_K1_OFFSET, &quot;Probe::State::cpu.gprs[k1]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
187 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::gp]) == PROBE_CPU_GP_OFFSET, &quot;Probe::State::cpu.gprs[gp]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
188 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::sp]) == PROBE_CPU_SP_OFFSET, &quot;Probe::State::cpu.gprs[sp]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
189 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::fp]) == PROBE_CPU_FP_OFFSET, &quot;Probe::State::cpu.gprs[fp]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
190 static_assert(PROBE_OFFSETOF(cpu.gprs[MIPSRegisters::ra]) == PROBE_CPU_RA_OFFSET, &quot;Probe::State::cpu.gprs[ra]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
191 
192 static_assert(PROBE_OFFSETOF(cpu.sprs[MIPSRegisters::fir]) == PROBE_CPU_FIR_OFFSET, &quot;Probe::State::cpu.sprs[fir]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
193 static_assert(PROBE_OFFSETOF(cpu.sprs[MIPSRegisters::fccr]) == PROBE_CPU_FCCR_OFFSET, &quot;Probe::State::cpu.sprs[fccr]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
194 static_assert(PROBE_OFFSETOF(cpu.sprs[MIPSRegisters::fexr]) == PROBE_CPU_FEXR_OFFSET, &quot;Probe::State::cpu.sprs[fexr]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
195 static_assert(PROBE_OFFSETOF(cpu.sprs[MIPSRegisters::fenr]) == PROBE_CPU_FENR_OFFSET, &quot;Probe::State::cpu.sprs[fenr]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
196 static_assert(PROBE_OFFSETOF(cpu.sprs[MIPSRegisters::fcsr]) == PROBE_CPU_FCSR_OFFSET, &quot;Probe::State::cpu.sprs[fcsr]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
197 static_assert(PROBE_OFFSETOF(cpu.sprs[MIPSRegisters::pc]) == PROBE_CPU_PC_OFFSET, &quot;Probe::State::cpu.sprs[pc]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
198 
199 static_assert(!(PROBE_CPU_F0_OFFSET &amp; 0x7), &quot;Probe::State::cpu.fprs[f0]&#39;s offset should be 8 byte aligned&quot;);
200 
201 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f0])  == PROBE_CPU_F0_OFFSET,  &quot;Probe::State::cpu.fprs[f0]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
202 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f1])  == PROBE_CPU_F1_OFFSET,  &quot;Probe::State::cpu.fprs[f1]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
203 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f2])  == PROBE_CPU_F2_OFFSET,  &quot;Probe::State::cpu.fprs[f2]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
204 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f3])  == PROBE_CPU_F3_OFFSET,  &quot;Probe::State::cpu.fprs[f3]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
205 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f4])  == PROBE_CPU_F4_OFFSET,  &quot;Probe::State::cpu.fprs[f4]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
206 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f5])  == PROBE_CPU_F5_OFFSET,  &quot;Probe::State::cpu.fprs[f5]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
207 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f6])  == PROBE_CPU_F6_OFFSET,  &quot;Probe::State::cpu.fprs[f6]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
208 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f7])  == PROBE_CPU_F7_OFFSET,  &quot;Probe::State::cpu.fprs[f7]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
209 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f8])  == PROBE_CPU_F8_OFFSET,  &quot;Probe::State::cpu.fprs[f8]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
210 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f9])  == PROBE_CPU_F9_OFFSET,  &quot;Probe::State::cpu.fprs[f9]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
211 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f10]) == PROBE_CPU_F10_OFFSET, &quot;Probe::State::cpu.fprs[f10]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
212 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f11]) == PROBE_CPU_F11_OFFSET, &quot;Probe::State::cpu.fprs[f11]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
213 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f12]) == PROBE_CPU_F12_OFFSET, &quot;Probe::State::cpu.fprs[f12]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
214 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f13]) == PROBE_CPU_F13_OFFSET, &quot;Probe::State::cpu.fprs[f13]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
215 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f14]) == PROBE_CPU_F14_OFFSET, &quot;Probe::State::cpu.fprs[f14]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
216 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f15]) == PROBE_CPU_F15_OFFSET, &quot;Probe::State::cpu.fprs[f15]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
217 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f16]) == PROBE_CPU_F16_OFFSET, &quot;Probe::State::cpu.fprs[f16]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
218 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f17]) == PROBE_CPU_F17_OFFSET, &quot;Probe::State::cpu.fprs[f17]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
219 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f18]) == PROBE_CPU_F18_OFFSET, &quot;Probe::State::cpu.fprs[f18]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
220 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f19]) == PROBE_CPU_F19_OFFSET, &quot;Probe::State::cpu.fprs[f19]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
221 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f20]) == PROBE_CPU_F20_OFFSET, &quot;Probe::State::cpu.fprs[f20]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
222 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f21]) == PROBE_CPU_F21_OFFSET, &quot;Probe::State::cpu.fprs[f21]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
223 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f22]) == PROBE_CPU_F22_OFFSET, &quot;Probe::State::cpu.fprs[f22]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
224 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f23]) == PROBE_CPU_F23_OFFSET, &quot;Probe::State::cpu.fprs[f23]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
225 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f24]) == PROBE_CPU_F24_OFFSET, &quot;Probe::State::cpu.fprs[f24]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
226 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f25]) == PROBE_CPU_F25_OFFSET, &quot;Probe::State::cpu.fprs[f25]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
227 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f26]) == PROBE_CPU_F26_OFFSET, &quot;Probe::State::cpu.fprs[f26]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
228 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f27]) == PROBE_CPU_F27_OFFSET, &quot;Probe::State::cpu.fprs[f27]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
229 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f28]) == PROBE_CPU_F28_OFFSET, &quot;Probe::State::cpu.fprs[f28]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
230 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f29]) == PROBE_CPU_F29_OFFSET, &quot;Probe::State::cpu.fprs[f29]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
231 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f30]) == PROBE_CPU_F30_OFFSET, &quot;Probe::State::cpu.fprs[f30]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
232 static_assert(PROBE_OFFSETOF(cpu.fprs[MIPSRegisters::f31]) == PROBE_CPU_F31_OFFSET, &quot;Probe::State::cpu.fprs[f31]&#39;s offset matches ctiMasmProbeTrampoline&quot;);
233 
234 static_assert(sizeof(Probe::State) == PROBE_SIZE, &quot;Probe::State&#39;s size matches ctiMasmProbeTrampoline&quot;);
235 #undef PROBE_OFFSETOF
236 
237 static_assert(MIPSRegisters::fir == FIR, &quot;FIR matches MIPSRegisters::fir&quot;);
238 static_assert(MIPSRegisters::fccr == FCCR, &quot;FCCR matches MIPSRegisters::fccr&quot;);
239 static_assert(MIPSRegisters::fexr == FEXR, &quot;FEXR matches MIPSRegisters::fexr&quot;);
240 static_assert(MIPSRegisters::fenr == FENR, &quot;FENR matches MIPSRegisters::fenr&quot;);
241 static_assert(MIPSRegisters::fcsr == FCSR, &quot;FCSR matches MIPSRegisters::fcsr&quot;);
242 
243 struct IncomingRecord {
244     uintptr_t a0;
245     uintptr_t a1;
246     uintptr_t a2;
247     uintptr_t s0;
248     uintptr_t s1;
249     uintptr_t ra;
250 };
251 
252 #define IN_A0_OFFSET (0 * PTR_SIZE)
253 #define IN_A1_OFFSET (1 * PTR_SIZE)
254 #define IN_A2_OFFSET (2 * PTR_SIZE)
255 #define IN_S0_OFFSET (3 * PTR_SIZE)
256 #define IN_S1_OFFSET (4 * PTR_SIZE)
257 #define IN_RA_OFFSET (5 * PTR_SIZE)
258 #define IN_SIZE      (6 * PTR_SIZE)
259 
260 static_assert(IN_A0_OFFSET == offsetof(IncomingRecord, a0), &quot;IN_A0_OFFSET is incorrect&quot;);
261 static_assert(IN_A1_OFFSET == offsetof(IncomingRecord, a1), &quot;IN_A1_OFFSET is incorrect&quot;);
262 static_assert(IN_A2_OFFSET == offsetof(IncomingRecord, a2), &quot;IN_A2_OFFSET is incorrect&quot;);
263 static_assert(IN_S0_OFFSET == offsetof(IncomingRecord, s0), &quot;IN_S0_OFFSET is incorrect&quot;);
264 static_assert(IN_S1_OFFSET == offsetof(IncomingRecord, s1), &quot;IN_S1_OFFSET is incorrect&quot;);
265 static_assert(IN_RA_OFFSET == offsetof(IncomingRecord, ra), &quot;IN_RA_OFFSET is incorrect&quot;);
266 static_assert(IN_SIZE == sizeof(IncomingRecord), &quot;IN_SIZE is incorrect&quot;);
267 
268 struct OutgoingRecord {
269     uintptr_t fp;
270     uintptr_t ra;
271 };
272 
273 #define OUT_FP_OFFSET (0 * PTR_SIZE)
274 #define OUT_RA_OFFSET (1 * PTR_SIZE)
275 #define OUT_SIZE      (2 * PTR_SIZE)
276 
277 static_assert(OUT_FP_OFFSET == offsetof(OutgoingRecord, fp), &quot;OUT_FP_OFFSET is incorrect&quot;);
278 static_assert(OUT_RA_OFFSET == offsetof(OutgoingRecord, ra), &quot;OUT_RA_OFFSET is incorrect&quot;);
279 static_assert(OUT_SIZE == sizeof(OutgoingRecord), &quot;OUT_SIZE is incorrect&quot;);
280 
281 struct RARestorationRecord {
282     uintptr_t ra;
283     uintptr_t padding;
284 };
285 
286 #define RA_RESTORATION_RA_OFFSET (0 * PTR_SIZE)
287 #define RA_RESTORATION_SIZE      (2 * PTR_SIZE)
288 
289 static_assert(RA_RESTORATION_RA_OFFSET == offsetof(RARestorationRecord, ra), &quot;RA_RESTORATION_RA_OFFSET is incorrect&quot;);
290 static_assert(RA_RESTORATION_SIZE == sizeof(RARestorationRecord), &quot;RA_RESTORATION_SIZE is incorrect&quot;);
291 static_assert(!(sizeof(RARestorationRecord) &amp; 0x7), &quot;RARestorationRecord must be 8-byte aligned&quot;);
292 
293 asm (
294     &quot;.text&quot; &quot;\n&quot;
295     &quot;.globl &quot; SYMBOL_STRING(ctiMasmProbeTrampoline) &quot;\n&quot;
296     HIDE_SYMBOL(ctiMasmProbeTrampoline) &quot;\n&quot;
297     SYMBOL_STRING(ctiMasmProbeTrampoline) &quot;:&quot; &quot;\n&quot;
298     &quot;.set push&quot; &quot;\n&quot;
299     &quot;.set noreorder&quot; &quot;\n&quot;
300     &quot;.set noat&quot; &quot;\n&quot;
301 
302     // MacroAssemblerMIPS::probe() has already generated code to store some values in an
303     // IncomingProbeRecord. sp points to the IncomingProbeRecord.
304     //
305     // Incoming register values:
306     //     a0: probe function
307     //     a1: probe arg
308     //     a2: Probe::executeProbe
309     //     s0: scratch, was ctiMasmProbeTrampoline
310     //     s1: scratch
311     //     ra: return address
312 
313     &quot;move      $s0, $sp&quot; &quot;\n&quot;
314     &quot;addiu     $sp, $sp, -&quot; STRINGIZE_VALUE_OF((PROBE_SIZE_PLUS_EXTRAS + OUT_SIZE)) &quot;\n&quot; // Set the sp to protect the Probe::State from interrupts before we initialize it.
315     &quot;move      $s1, $sp&quot; &quot;\n&quot;
316 
317     &quot;sw        $a0, &quot; STRINGIZE_VALUE_OF(PROBE_PROBE_FUNCTION_OFFSET) &quot;($sp)&quot; &quot;\n&quot; // Store the probe handler function (preloaded into a0)
318     &quot;sw        $a1, &quot; STRINGIZE_VALUE_OF(PROBE_ARG_OFFSET) &quot;($sp)&quot; &quot;\n&quot;            // Store the probe handler arg (preloaded into a1)
319 
320     &quot;sw        $at, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_AT_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
321     &quot;sw        $v0, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_V0_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
322     &quot;sw        $v1, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_V1_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
323 
324     &quot;lw        $v0, &quot; STRINGIZE_VALUE_OF(IN_A0_OFFSET) &quot;($s0)&quot; &quot;\n&quot; // Load saved a0
325     &quot;lw        $v1, &quot; STRINGIZE_VALUE_OF(IN_A1_OFFSET) &quot;($s0)&quot; &quot;\n&quot; // Load saved a1
326     &quot;lw        $at, &quot; STRINGIZE_VALUE_OF(IN_A2_OFFSET) &quot;($s0)&quot; &quot;\n&quot; // Load saved a2
327     &quot;sw        $v0, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_A0_OFFSET) &quot;($sp)&quot; &quot;\n&quot; // Store saved a0
328     &quot;sw        $v1, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_A1_OFFSET) &quot;($sp)&quot; &quot;\n&quot; // Store saved a1
329     &quot;sw        $at, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_A2_OFFSET) &quot;($sp)&quot; &quot;\n&quot; // Store saved a2
330 
331     &quot;sw        $a3, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_A3_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
332     &quot;sw        $t0, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T0_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
333     &quot;sw        $t1, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T1_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
334     &quot;sw        $t2, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T2_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
335     &quot;sw        $t3, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T3_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
336     &quot;sw        $t4, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T4_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
337     &quot;sw        $t5, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T5_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
338     &quot;sw        $t6, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T6_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
339     &quot;sw        $t7, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T7_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
340 
341     &quot;lw        $v0, &quot; STRINGIZE_VALUE_OF(IN_S0_OFFSET) &quot;($s0)&quot; &quot;\n&quot; // Load saved s0
342     &quot;lw        $v1, &quot; STRINGIZE_VALUE_OF(IN_S1_OFFSET) &quot;($s0)&quot; &quot;\n&quot; // Load saved s1
343     &quot;sw        $v0, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_S0_OFFSET) &quot;($sp)&quot; &quot;\n&quot; // Store saved s0
344     &quot;sw        $v1, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_S1_OFFSET) &quot;($sp)&quot; &quot;\n&quot; // Store saved s1
345 
346     &quot;sw        $s2, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_S2_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
347     &quot;sw        $s3, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_S3_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
348     &quot;sw        $s4, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_S4_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
349     &quot;sw        $s5, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_S5_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
350     &quot;sw        $s6, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_S6_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
351     &quot;sw        $s7, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_S7_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
352     &quot;sw        $t8, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T8_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
353     &quot;sw        $t9, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T9_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
354     &quot;sw        $k0, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_K0_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
355     &quot;sw        $k1, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_K1_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
356     &quot;sw        $gp, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_GP_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
357     &quot;sw        $fp, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_FP_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
358 
359     &quot;lw        $v0, &quot; STRINGIZE_VALUE_OF(IN_RA_OFFSET) &quot;($s0)&quot; &quot;\n&quot; // Load saved ra
360     &quot;addiu     $s0, $s0, &quot; STRINGIZE_VALUE_OF(IN_SIZE) &quot;\n&quot; // Compute the sp before the probe
361     &quot;sw        $v0, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_RA_OFFSET) &quot;($sp)&quot; &quot;\n&quot; // Store saved ra
362     &quot;sw        $s0, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_SP_OFFSET) &quot;($sp)&quot; &quot;\n&quot; // Store original sp computed into s0
363 
364     &quot;sw        $ra, &quot; STRINGIZE_VALUE_OF(SAVED_PROBE_RETURN_PC_OFFSET) &quot;($sp)&quot; &quot;\n&quot; // Save a duplicate copy of return pc (in ra)
365     &quot;addiu     $ra, $ra, &quot; STRINGIZE_VALUE_OF(PROBE_INSTRUCTIONS_AFTER_CALL * PTR_SIZE) &quot;\n&quot; // The PC after the probe is at 2 instructions past the return point.
366     &quot;sw        $ra, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_PC_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
367 
368     &quot;cfc1      $t0,  $&quot; STRINGIZE_VALUE_OF(FIR) &quot;\n&quot;
369     &quot;sw        $t0,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_FIR_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
370     &quot;cfc1      $t0,  $&quot; STRINGIZE_VALUE_OF(FCCR) &quot;\n&quot;
371     &quot;sw        $t0,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_FCCR_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
372     &quot;cfc1      $t0,  $&quot; STRINGIZE_VALUE_OF(FEXR) &quot;\n&quot;
373     &quot;sw        $t0,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_FEXR_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
374     &quot;cfc1      $t0,  $&quot; STRINGIZE_VALUE_OF(FENR) &quot;\n&quot;
375     &quot;sw        $t0,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_FENR_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
376     &quot;cfc1      $t0,  $&quot; STRINGIZE_VALUE_OF(FCSR) &quot;\n&quot;
377     &quot;sw        $t0,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_FCSR_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
378 
379     &quot;sdc1      $f0,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F0_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
380     &quot;sdc1      $f2,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F2_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
381     &quot;sdc1      $f4,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F4_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
382     &quot;sdc1      $f6,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F6_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
383     &quot;sdc1      $f8,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F8_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
384     &quot;sdc1      $f10, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F10_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
385     &quot;sdc1      $f12, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F12_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
386     &quot;sdc1      $f14, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F14_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
387     &quot;sdc1      $f16, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F16_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
388     &quot;sdc1      $f18, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F18_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
389     &quot;sdc1      $f20, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F20_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
390     &quot;sdc1      $f22, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F22_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
391     &quot;sdc1      $f24, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F24_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
392     &quot;sdc1      $f26, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F26_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
393     &quot;sdc1      $f28, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F28_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
394     &quot;sdc1      $f30, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F30_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
395 
396     &quot;move      $a0, $sp&quot; &quot;\n&quot; // Set the Probe::State* arg.
397     &quot;addiu     $sp, $sp, -16&quot; &quot;\n&quot; // Allocate stack space for (unused) 16 bytes (8-byte aligned) for 4 arguments.
398     &quot;move      $t9, $a2&quot; &quot;\n&quot; // Probe::executeProbe()
399     &quot;jalr      $t9&quot; &quot;\n&quot; // Call the probe handler.
400     &quot;nop&quot; &quot;\n&quot;
401 
402     // Make sure the Probe::State is entirely below the result stack pointer so
403     // that register values are still preserved when we call the initializeStack
404     // function.
405     &quot;lw        $t0, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_SP_OFFSET) &quot;($s1)&quot; &quot;\n&quot; // Result sp.
406     &quot;addiu     $t1, $s1, &quot; STRINGIZE_VALUE_OF((PROBE_SIZE_PLUS_EXTRAS + OUT_SIZE)) &quot;\n&quot; // End of Probe::State + buffer.
407     &quot;sltu      $t2, $t0, $t1&quot; &quot;\n&quot;
408     &quot;beqz      $t2, &quot; LOCAL_LABEL_STRING(ctiMasmProbeTrampolineProbeStateIsSafe) &quot;\n&quot;
409     &quot;nop&quot; &quot;\n&quot;
410 
411     // Allocate a safe place on the stack below the result stack pointer to stash the Probe::State.
412     &quot;addiu     $sp, $t0, -&quot; STRINGIZE_VALUE_OF((PROBE_SIZE_PLUS_EXTRAS + OUT_SIZE)) &quot;\n&quot; // Set the new sp to protect that memory from interrupts before we copy the Probe::State.
413 
414     // Copy the Probe::State to the safe place.
415     // Note: we have to copy from low address to higher address because we&#39;re moving the
416     // Probe::State to a lower address.
417     &quot;move      $t0, $s1&quot; &quot;\n&quot;
418     &quot;move      $t1, $sp&quot; &quot;\n&quot;
419     &quot;addiu     $t2, $s1, &quot; STRINGIZE_VALUE_OF(PROBE_SIZE_PLUS_EXTRAS) &quot;\n&quot;
420 
421     LOCAL_LABEL_STRING(ctiMasmProbeTrampolineCopyLoop) &quot;:&quot; &quot;\n&quot;
422     &quot;lw        $t3, 0($t0)&quot; &quot;\n&quot;
423     &quot;lw        $t4, 4($t0)&quot; &quot;\n&quot;
424     &quot;sw        $t3, 0($t1)&quot; &quot;\n&quot;
425     &quot;sw        $t4, 4($t1)&quot; &quot;\n&quot;
426     &quot;addiu     $t0, $t0, 8&quot; &quot;\n&quot;
427     &quot;addiu     $t1, $t1, 8&quot; &quot;\n&quot;
428     &quot;bne       $t0, $t2, &quot; LOCAL_LABEL_STRING(ctiMasmProbeTrampolineCopyLoop) &quot;\n&quot;
429     &quot;nop&quot; &quot;\n&quot;
430 
431     &quot;move      $s1, $sp&quot; &quot;\n&quot;
432 
433     // Call initializeStackFunction if present.
434     LOCAL_LABEL_STRING(ctiMasmProbeTrampolineProbeStateIsSafe) &quot;:&quot; &quot;\n&quot;
435     &quot;lw        $t9, &quot; STRINGIZE_VALUE_OF(PROBE_INIT_STACK_FUNCTION_OFFSET) &quot;($s1)&quot; &quot;\n&quot;
436     &quot;beqz      $t9, &quot; LOCAL_LABEL_STRING(ctiMasmProbeTrampolineRestoreRegisters) &quot;\n&quot;
437     &quot;nop&quot; &quot;\n&quot;
438 
439     &quot;move      $a0, $s1&quot; &quot;\n&quot; // Set the Probe::State* arg.
440     &quot;jalr      $t9&quot; &quot;\n&quot; // Call the initializeStackFunction (loaded into t9 above).
441     &quot;nop&quot; &quot;\n&quot;
442 
443     LOCAL_LABEL_STRING(ctiMasmProbeTrampolineRestoreRegisters) &quot;:&quot; &quot;\n&quot;
444 
445     &quot;move      $sp, $s1&quot; &quot;\n&quot;
446 
447     // To enable probes to modify register state, we copy all registers
448     // out of the Probe::State before returning, except for zero, k0 and k1.
449 
450     &quot;lw        $t0,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_FIR_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
451     &quot;ctc1      $t0,  $&quot; STRINGIZE_VALUE_OF(FIR) &quot;\n&quot;
452     &quot;lw        $t0,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_FCCR_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
453     &quot;ctc1      $t0,  $&quot; STRINGIZE_VALUE_OF(FCCR) &quot;\n&quot;
454     &quot;lw        $t0,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_FEXR_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
455     &quot;ctc1      $t0,  $&quot; STRINGIZE_VALUE_OF(FEXR) &quot;\n&quot;
456     &quot;lw        $t0,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_FENR_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
457     &quot;ctc1      $t0,  $&quot; STRINGIZE_VALUE_OF(FENR) &quot;\n&quot;
458     &quot;lw        $t0,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_FCSR_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
459     &quot;ctc1      $t0,  $&quot; STRINGIZE_VALUE_OF(FCSR) &quot;\n&quot;
460 
461     &quot;ldc1      $f0,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F0_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
462     &quot;ldc1      $f2,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F2_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
463     &quot;ldc1      $f4,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F4_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
464     &quot;ldc1      $f6,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F6_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
465     &quot;ldc1      $f8,  &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F8_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
466     &quot;ldc1      $f10, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F10_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
467     &quot;ldc1      $f12, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F12_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
468     &quot;ldc1      $f14, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F14_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
469     &quot;ldc1      $f16, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F16_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
470     &quot;ldc1      $f18, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F18_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
471     &quot;ldc1      $f20, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F20_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
472     &quot;ldc1      $f22, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F22_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
473     &quot;ldc1      $f24, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F24_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
474     &quot;ldc1      $f26, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F26_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
475     &quot;ldc1      $f28, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F28_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
476     &quot;ldc1      $f30, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_F30_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
477 
478     &quot;lw        $at, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_AT_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
479     &quot;lw        $v0, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_V0_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
480     &quot;lw        $v1, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_V1_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
481     &quot;lw        $a0, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_A0_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
482     &quot;lw        $a1, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_A1_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
483     &quot;lw        $a2, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_A2_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
484     &quot;lw        $a3, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_A3_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
485     &quot;lw        $t2, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T2_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
486     &quot;lw        $t3, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T3_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
487     &quot;lw        $t4, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T4_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
488     &quot;lw        $t5, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T5_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
489     &quot;lw        $t6, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T6_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
490     &quot;lw        $t7, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T7_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
491     &quot;lw        $s0, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_S0_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
492     &quot;lw        $s1, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_S1_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
493     &quot;lw        $s2, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_S2_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
494     &quot;lw        $s3, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_S3_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
495     &quot;lw        $s4, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_S4_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
496     &quot;lw        $s5, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_S5_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
497     &quot;lw        $s6, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_S6_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
498     &quot;lw        $s7, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_S7_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
499     &quot;lw        $t8, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T8_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
500     &quot;lw        $t9, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T9_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
501     &quot;lw        $gp, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_GP_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
502 
503     // Remaining registers to restore are: t0, t1, fp, ra, sp, and pc.
504 
505     // The only way to set the pc on MIPS (from user space) is via an indirect branch
506     // which means we&#39;ll need a free register to do so. For our purposes, ra
507     // happens to be available in applications of the probe where we may want to
508     // continue executing at a different location (i.e. change the pc) after the probe
509     // returns. So, the MIPS probe implementation will allow the probe handler to
510     // either modify ra or pc, but not both in the same probe invocation. The probe
511     // mechanism ensures that we never try to modify both ra and pc with a RELEASE_ASSERT
512     // in Probe::executeProbe().
513 
514     // Determine if the probe handler changed the pc.
515     &quot;lw        $ra, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_SP_OFFSET) &quot;($sp)&quot; &quot;\n&quot; // preload the target sp.
516     &quot;lw        $t0, &quot; STRINGIZE_VALUE_OF(SAVED_PROBE_RETURN_PC_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
517     &quot;lw        $t1, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_PC_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
518     &quot;addiu     $t0, $t0, &quot; STRINGIZE_VALUE_OF(PROBE_INSTRUCTIONS_AFTER_CALL * PTR_SIZE) &quot;\n&quot;
519     &quot;bne       $t0, $t1, &quot; LOCAL_LABEL_STRING(ctiMasmProbeTrampolineEnd) &quot;\n&quot;
520     &quot;nop&quot; &quot;\n&quot;
521 
522      // We didn&#39;t change the PC. So, let&#39;s prepare for setting a potentially new ra value.
523 
524      // 1. Make room for the RARestorationRecord. The probe site will pop this off later.
525     &quot;addiu     $ra, $ra, -&quot; STRINGIZE_VALUE_OF(RA_RESTORATION_SIZE) &quot;\n&quot;
526      // 2. Store the lp value to restore at the probe return site.
527     &quot;lw        $t0, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_RA_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
528     &quot;sw        $t0, &quot; STRINGIZE_VALUE_OF(RA_RESTORATION_RA_OFFSET) &quot;($ra)&quot; &quot;\n&quot;
529      // 3. Force the return ramp to return to the probe return site.
530     &quot;lw        $t0, &quot; STRINGIZE_VALUE_OF(SAVED_PROBE_RETURN_PC_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
531     &quot;sw        $t0, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_PC_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
532 
533     LOCAL_LABEL_STRING(ctiMasmProbeTrampolineEnd) &quot;:&quot; &quot;\n&quot;
534 
535     // Fill in the OutgoingProbeRecord.
536     &quot;addiu     $ra, $ra, -&quot; STRINGIZE_VALUE_OF(OUT_SIZE) &quot;\n&quot;
537 
538     &quot;lw        $t0, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_FP_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
539     &quot;lw        $t1, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_PC_OFFSET) &quot;($sp)&quot; &quot;\n&quot; // Set up the outgoing record so that we&#39;ll jump to the new PC.
540     &quot;sw        $t0, &quot; STRINGIZE_VALUE_OF(OUT_FP_OFFSET) &quot;($ra)&quot; &quot;\n&quot;
541     &quot;sw        $t1, &quot; STRINGIZE_VALUE_OF(OUT_RA_OFFSET) &quot;($ra)&quot; &quot;\n&quot;
542     &quot;lw        $t0, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T0_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
543     &quot;lw        $t1, &quot; STRINGIZE_VALUE_OF(PROBE_CPU_T1_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
544     &quot;move      $sp, $ra&quot; &quot;\n&quot;
545 
546     // Restore the remaining registers.
547     &quot;lw        $fp, &quot; STRINGIZE_VALUE_OF(OUT_FP_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
548     &quot;lw        $ra, &quot; STRINGIZE_VALUE_OF(OUT_RA_OFFSET) &quot;($sp)&quot; &quot;\n&quot;
549     &quot;addiu     $sp, $sp, &quot; STRINGIZE_VALUE_OF(OUT_SIZE) &quot;\n&quot;
550     &quot;jr        $ra&quot; &quot;\n&quot;
551     &quot;nop&quot; &quot;\n&quot;
552     &quot;.set pop&quot; &quot;\n&quot;
553 );
554 #endif // COMPILER(GCC_COMPATIBLE)
555 
556 void MacroAssembler::probe(Probe::Function function, void* arg)
557 {
558     sub32(TrustedImm32(sizeof(IncomingRecord)), sp);
559     store32(a0, Address(sp, offsetof(IncomingRecord, a0)));
560     store32(a1, Address(sp, offsetof(IncomingRecord, a1)));
561     store32(a2, Address(sp, offsetof(IncomingRecord, a2)));
562     store32(s0, Address(sp, offsetof(IncomingRecord, s0)));
563     store32(s1, Address(sp, offsetof(IncomingRecord, s1)));
564     store32(ra, Address(sp, offsetof(IncomingRecord, ra)));
565     move(TrustedImmPtr(reinterpret_cast&lt;void*&gt;(function)), a0);
566     move(TrustedImmPtr(arg), a1);
567     move(TrustedImmPtr(reinterpret_cast&lt;void*&gt;(Probe::executeProbe)), a2);
568     move(TrustedImmPtr(reinterpret_cast&lt;void*&gt;(ctiMasmProbeTrampoline)), s0);
569     m_assembler.jalr(s0);
570     m_assembler.nop();
571     // If you change the following instructions, be sure to update PROBE_INSTRUCTIONS_AFTER_CALL as well
572     load32(Address(sp, offsetof(RARestorationRecord, ra)), ra);
573     add32(TrustedImm32(sizeof(RARestorationRecord)), sp);
574 }
575 #endif // ENABLE(MASM_PROBE)
576 
577 } // namespace JSC
578 
579 #endif // ENABLE(ASSEMBLER) &amp;&amp; CPU(MIPS)
    </pre>
  </body>
</html>
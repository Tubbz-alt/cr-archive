<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/UniqueIDBDatabase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2015, 2016 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;UniqueIDBDatabase.h&quot;
  28 
  29 #if ENABLE(INDEXED_DATABASE)
  30 
  31 #include &quot;IDBCursorInfo.h&quot;
  32 #include &quot;IDBGetAllRecordsData.h&quot;
  33 #include &quot;IDBGetAllResult.h&quot;
  34 #include &quot;IDBGetRecordData.h&quot;
  35 #include &quot;IDBIterateCursorData.h&quot;
  36 #include &quot;IDBKeyRangeData.h&quot;
  37 #include &quot;IDBResultData.h&quot;
  38 #include &quot;IDBServer.h&quot;
  39 #include &quot;IDBTransactionInfo.h&quot;
  40 #include &quot;IDBValue.h&quot;
  41 #include &quot;Logging.h&quot;
  42 #include &quot;StorageQuotaManager.h&quot;
  43 #include &quot;UniqueIDBDatabaseConnection.h&quot;
  44 #include &lt;wtf/Scope.h&gt;
  45 
  46 namespace WebCore {
  47 using namespace JSC;
  48 namespace IDBServer {
  49 
  50 static const uint64_t defaultWriteOperationCost = 4;
  51 
  52 static inline uint64_t estimateSize(const IDBKeyData&amp; keyData)
  53 {
  54     uint64_t size = 4;
  55     switch (keyData.type()) {
  56     case IndexedDB::KeyType::String:
  57         size += keyData.string().sizeInBytes();
  58         break;
  59     case IndexedDB::KeyType::Binary: {
  60         size += keyData.binary().size();
  61         break;
  62     }
  63     case IndexedDB::KeyType::Array:
  64         for (auto&amp; data : keyData.array())
  65             size += estimateSize(data);
  66         break;
  67     default:
  68         break;
  69     }
  70     return size;
  71 }
  72 
  73 static inline uint64_t estimateSize(const IDBValue&amp; value)
  74 {
  75     uint64_t size = 4;
  76     size += value.data().size();
  77     for (auto&amp; url : value.blobURLs())
  78         size += url.sizeInBytes();
  79     for (auto&amp; path : value.blobFilePaths())
  80         size += path.sizeInBytes();
  81     return size;
  82 }
  83 
  84 static inline uint64_t estimateSize(const IDBKeyPath&amp; keyPath)
  85 {
  86     return WTF::switchOn(keyPath, [](const String&amp; path) {
  87         return static_cast&lt;uint64_t&gt;(path.sizeInBytes());
  88     }, [](const Vector&lt;String&gt;&amp; paths) {
  89         uint64_t size = 0;
  90         for (auto path : paths)
  91             size += path.sizeInBytes();
  92         return size;
  93     });
  94 }
  95 
  96 static inline uint64_t estimateSize(const IDBIndexInfo&amp; info)
  97 {
  98     uint64_t size = 4;
  99     size += info.name().sizeInBytes();
 100     size += estimateSize(info.keyPath());
 101     return size;
 102 }
 103 
 104 static inline uint64_t estimateSize(const IDBObjectStoreInfo&amp; info)
 105 {
 106     uint64_t size = 4;
 107     size += info.name().sizeInBytes();
 108     if (auto keyPath = info.keyPath())
 109         size += estimateSize(*keyPath);
 110     return size;
 111 }
 112 
 113 UniqueIDBDatabase::UniqueIDBDatabase(IDBServer&amp; server, const IDBDatabaseIdentifier&amp; identifier)
 114     : m_server(server)
 115     , m_identifier(identifier)
 116 {
 117     ASSERT(!isMainThread());
 118 
 119     m_server.addDatabase(*this);
 120     LOG(IndexedDB, &quot;UniqueIDBDatabase::UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.loggingString().utf8().data());
 121 }
 122 
 123 UniqueIDBDatabase::~UniqueIDBDatabase()
 124 {
 125     LOG(IndexedDB, &quot;UniqueIDBDatabase::~UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.loggingString().utf8().data());
 126     ASSERT(!isMainThread());
 127     ASSERT(m_pendingOpenDBRequests.isEmpty());
 128     ASSERT(!m_currentOpenDBRequest);
 129     ASSERT(m_inProgressTransactions.isEmpty());
 130     ASSERT(m_pendingTransactions.isEmpty());
 131     ASSERT(!hasAnyOpenConnections());
 132     ASSERT(!m_versionChangeTransaction);
 133     ASSERT(!m_versionChangeDatabaseConnection);
 134     RELEASE_ASSERT(!m_backingStore);
 135 
 136     m_server.removeDatabase(*this);
 137 }
 138 
 139 const IDBDatabaseInfo&amp; UniqueIDBDatabase::info() const
 140 {
 141     RELEASE_ASSERT(m_databaseInfo);
 142     return *m_databaseInfo;
 143 }
 144 
 145 void UniqueIDBDatabase::openDatabaseConnection(IDBConnectionToClient&amp; connection, const IDBRequestData&amp; requestData)
 146 {
 147     LOG(IndexedDB, &quot;UniqueIDBDatabase::openDatabaseConnection&quot;);
 148     ASSERT(!isMainThread());
 149 
 150     m_pendingOpenDBRequests.add(ServerOpenDBRequest::create(connection, requestData));
 151 
 152     handleDatabaseOperations();
 153 }
 154 
 155 static inline String quotaErrorMessageName(const char* taskName)
 156 {
 157     return makeString(&quot;Failed to &quot;, taskName, &quot; in database because not enough space for domain&quot;);
 158 }
 159 
 160 void UniqueIDBDatabase::performCurrentOpenOperation()
 161 {
 162     LOG(IndexedDB, &quot;UniqueIDBDatabase::performCurrentOpenOperation (%p)&quot;, this);
 163 
 164     ASSERT(m_currentOpenDBRequest);
 165     ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
 166 
 167     IDBError backingStoreOpenError;
 168     if (!m_backingStore) {
 169         // Quota check.
 170         auto decision = m_server.requestSpace(m_identifier.origin(), defaultWriteOperationCost);
 171         if (decision == StorageQuotaManager::Decision::Deny)
 172             backingStoreOpenError = IDBError { QuotaExceededError, quotaErrorMessageName(&quot;OpenBackingStore&quot;) };
 173         else {
 174             m_backingStore = m_server.createBackingStore(m_identifier);
 175             IDBDatabaseInfo databaseInfo;
 176             backingStoreOpenError = m_backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);
 177             if (backingStoreOpenError.isNull())
 178                 m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(databaseInfo);
 179             else
 180                 m_backingStore = nullptr;
 181         }
 182     }
 183 
 184     if (!backingStoreOpenError.isNull()) {
 185         auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), backingStoreOpenError);
 186         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);
 187         m_currentOpenDBRequest = nullptr;
 188 
 189         return;
 190     }
 191 
 192     // If we previously started a version change operation but were blocked by having open connections,
 193     // we might now be unblocked.
 194     if (m_versionChangeDatabaseConnection) {
 195         if (!m_versionChangeTransaction &amp;&amp; !hasAnyOpenConnections())
 196             startVersionChangeTransaction();
 197         return;
 198     }
 199 
 200     // 3.3.1 Opening a database
 201     // If requested version is undefined, then let requested version be 1 if db was created in the previous step,
 202     // or the current version of db otherwise.
 203     uint64_t requestedVersion = m_currentOpenDBRequest-&gt;requestData().requestedVersion();
 204     if (!requestedVersion)
 205         requestedVersion = m_databaseInfo-&gt;version() ? m_databaseInfo-&gt;version() : 1;
 206 
 207     // 3.3.1 Opening a database
 208     // If the database version higher than the requested version, abort these steps and return a VersionError.
 209     if (requestedVersion &lt; m_databaseInfo-&gt;version()) {
 210         auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), IDBError(VersionError));
 211         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);
 212         m_currentOpenDBRequest = nullptr;
 213 
 214         return;
 215     }
 216 
 217     Ref&lt;UniqueIDBDatabaseConnection&gt; connection = UniqueIDBDatabaseConnection::create(*this, *m_currentOpenDBRequest);
 218 
 219     if (requestedVersion == m_databaseInfo-&gt;version()) {
 220         auto* rawConnection = &amp;connection.get();
 221         addOpenDatabaseConnection(WTFMove(connection));
 222 
 223         auto result = IDBResultData::openDatabaseSuccess(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), *rawConnection);
 224         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);
 225         m_currentOpenDBRequest = nullptr;
 226 
 227         return;
 228     }
 229 
 230     ASSERT(!m_versionChangeDatabaseConnection);
 231     m_versionChangeDatabaseConnection = WTFMove(connection);
 232 
 233     // 3.3.7 &quot;versionchange&quot; transaction steps
 234     // If there&#39;s no other open connections to this database, the version change process can begin immediately.
 235     if (!hasAnyOpenConnections()) {
 236         startVersionChangeTransaction();
 237         return;
 238     }
 239 
 240     // Otherwise we have to notify all those open connections and wait for them to close.
 241     maybeNotifyConnectionsOfVersionChange();
 242 }
 243 
 244 void UniqueIDBDatabase::performCurrentDeleteOperation()
 245 {
 246     LOG(IndexedDB, &quot;UniqueIDBDatabase::performCurrentDeleteOperation - %s&quot;, m_identifier.loggingString().utf8().data());
 247 
 248     ASSERT(m_currentOpenDBRequest);
 249     ASSERT(m_currentOpenDBRequest-&gt;isDeleteRequest());
 250 
 251     if (hasAnyOpenConnections()) {
 252         maybeNotifyConnectionsOfVersionChange();
 253         return;
 254     }
 255 
 256     ASSERT(m_pendingTransactions.isEmpty());
 257     ASSERT(m_openDatabaseConnections.isEmpty());
 258 
 259     // It&#39;s possible to have multiple delete requests queued up in a row.
 260     // In that scenario only the first request will actually have to delete the database.
 261     // Subsequent requests can immediately notify their completion.
 262 
 263     if (!m_databaseInfo &amp;&amp; m_mostRecentDeletedDatabaseInfo)
 264         didDeleteBackingStore(0);
 265     else
 266         deleteBackingStore();
 267 }
 268 
 269 void UniqueIDBDatabase::deleteBackingStore()
 270 {
 271     ASSERT(!isMainThread());
 272     LOG(IndexedDB, &quot;UniqueIDBDatabase::deleteBackingStore&quot;);
 273 
 274     uint64_t deletedVersion = 0;
 275 
 276     if (m_backingStore) {
 277         m_backingStore-&gt;deleteBackingStore();
 278         m_backingStore = nullptr;
 279     } else {
 280         auto backingStore = m_server.createBackingStore(m_identifier);
 281 
 282         IDBDatabaseInfo databaseInfo;
 283         auto error = backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);
 284         if (!error.isNull())
 285             LOG_ERROR(&quot;Error getting database info from database %s that we are trying to delete&quot;, m_identifier.loggingString().utf8().data());
 286 
 287         deletedVersion = databaseInfo.version();
 288         backingStore-&gt;deleteBackingStore();
 289     }
 290 
 291     didDeleteBackingStore(deletedVersion);
 292 }
 293 
 294 void UniqueIDBDatabase::didDeleteBackingStore(uint64_t deletedVersion)
 295 {
 296     LOG(IndexedDB, &quot;UniqueIDBDatabase::didDeleteBackingStore&quot;);
 297 
 298     ASSERT(m_inProgressTransactions.isEmpty());
 299     ASSERT(m_pendingTransactions.isEmpty());
 300     ASSERT(m_openDatabaseConnections.isEmpty());
 301     ASSERT(!m_backingStore);
 302 
 303     ASSERT(m_currentOpenDBRequest-&gt;isDeleteRequest());
 304 
 305     if (m_databaseInfo)
 306         m_mostRecentDeletedDatabaseInfo = WTFMove(m_databaseInfo);
 307 
 308     // If this UniqueIDBDatabase was brought into existence for the purpose of deleting the file on disk,
 309     // we won&#39;t have a m_mostRecentDeletedDatabaseInfo. In that case, we&#39;ll manufacture one using the
 310     // passed in deletedVersion argument.
 311     if (!m_mostRecentDeletedDatabaseInfo)
 312         m_mostRecentDeletedDatabaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), deletedVersion, 0);
 313 
 314     if (m_currentOpenDBRequest) {
 315         m_currentOpenDBRequest-&gt;notifyDidDeleteDatabase(*m_mostRecentDeletedDatabaseInfo);
 316         m_currentOpenDBRequest = nullptr;
 317     }
 318 }
 319 
 320 void UniqueIDBDatabase::clearStalePendingOpenDBRequests()
 321 {
 322     while (!m_pendingOpenDBRequests.isEmpty() &amp;&amp; m_pendingOpenDBRequests.first()-&gt;connection().isClosed())
 323         m_pendingOpenDBRequests.removeFirst();
 324 }
 325 
 326 void UniqueIDBDatabase::handleDatabaseOperations()
 327 {
 328     ASSERT(!isMainThread());
 329     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleDatabaseOperations - There are %u pending&quot;, m_pendingOpenDBRequests.size());
 330 
 331     if (m_versionChangeDatabaseConnection || m_versionChangeTransaction) {
 332         // We can&#39;t start any new open-database operations right now, but we might be able to start handling a delete operation.
 333         if (!m_currentOpenDBRequest)
 334             m_currentOpenDBRequest = takeNextRunnableRequest(RequestType::Delete);
 335     } else if (!m_currentOpenDBRequest || m_currentOpenDBRequest-&gt;connection().isClosed())
 336         m_currentOpenDBRequest = takeNextRunnableRequest();
 337 
 338     while (m_currentOpenDBRequest) {
 339         handleCurrentOperation();
 340         if (!m_currentOpenDBRequest) {
 341             if (m_versionChangeTransaction)
 342                 m_currentOpenDBRequest = takeNextRunnableRequest(RequestType::Delete);
 343             else
 344                 m_currentOpenDBRequest = takeNextRunnableRequest();
 345         } else // Request need multiple attempts to handle.
 346             break;
 347     }
 348     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleDatabaseOperations - There are %u pending after this round of handling&quot;, m_pendingOpenDBRequests.size());
 349 }
 350 
 351 void UniqueIDBDatabase::handleCurrentOperation()
 352 {
 353     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleCurrentOperation&quot;);
 354     ASSERT(m_currentOpenDBRequest);
 355 
 356     if (m_currentOpenDBRequest-&gt;isOpenRequest())
 357         performCurrentOpenOperation();
 358     else if (m_currentOpenDBRequest-&gt;isDeleteRequest())
 359         performCurrentDeleteOperation();
 360     else
 361         ASSERT_NOT_REACHED();
 362 }
 363 
 364 bool UniqueIDBDatabase::hasAnyOpenConnections() const
 365 {
 366     return !m_openDatabaseConnections.isEmpty();
 367 }
 368 
 369 bool UniqueIDBDatabase::allConnectionsAreClosedOrClosing() const
 370 {
 371     for (auto&amp; connection : m_openDatabaseConnections) {
 372         if (!connection-&gt;connectionIsClosing())
 373             return false;
 374     }
 375 
 376     return true;
 377 }
 378 
 379 void UniqueIDBDatabase::handleDelete(IDBConnectionToClient&amp; connection, const IDBRequestData&amp; requestData)
 380 {
 381     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleDelete&quot;);
 382 
 383     m_pendingOpenDBRequests.add(ServerOpenDBRequest::create(connection, requestData));
 384     handleDatabaseOperations();
 385 }
 386 
 387 void UniqueIDBDatabase::startVersionChangeTransaction()
 388 {
 389     LOG(IndexedDB, &quot;UniqueIDBDatabase::startVersionChangeTransaction&quot;);
 390 
 391     ASSERT(!m_versionChangeTransaction);
 392     ASSERT(m_currentOpenDBRequest);
 393     ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
 394     ASSERT(m_versionChangeDatabaseConnection);
 395 
 396     uint64_t requestedVersion = m_currentOpenDBRequest-&gt;requestData().requestedVersion();
 397     if (!requestedVersion)
 398         requestedVersion = m_databaseInfo-&gt;version() ? m_databaseInfo-&gt;version() : 1;
 399 
 400     m_versionChangeTransaction = &amp;m_versionChangeDatabaseConnection-&gt;createVersionChangeTransaction(requestedVersion);
 401     auto versionChangeTransactionInfo = m_versionChangeTransaction-&gt;info();
 402     m_inProgressTransactions.set(versionChangeTransactionInfo.identifier(), m_versionChangeTransaction);
 403 
 404     auto error = m_backingStore-&gt;beginTransaction(versionChangeTransactionInfo);
 405     auto operation = WTFMove(m_currentOpenDBRequest);
 406     IDBResultData result;
 407     if (error.isNull()) {
 408         addOpenDatabaseConnection(*m_versionChangeDatabaseConnection);
 409         m_databaseInfo-&gt;setVersion(versionChangeTransactionInfo.newVersion());
 410         result = IDBResultData::openDatabaseUpgradeNeeded(operation-&gt;requestData().requestIdentifier(), *m_versionChangeTransaction);
 411         operation-&gt;connection().didOpenDatabase(result);
 412     } else {
 413         m_versionChangeDatabaseConnection-&gt;abortTransactionWithoutCallback(*m_versionChangeTransaction);
 414         m_versionChangeDatabaseConnection = nullptr;
 415         result = IDBResultData::error(operation-&gt;requestData().requestIdentifier(), error);
 416         operation-&gt;connection().didOpenDatabase(result);
 417     }
 418 }
 419 
 420 void UniqueIDBDatabase::maybeNotifyConnectionsOfVersionChange()
 421 {
 422     ASSERT(m_currentOpenDBRequest);
 423 
 424     if (m_currentOpenDBRequest-&gt;hasNotifiedConnectionsOfVersionChange())
 425         return;
 426 
 427     uint64_t newVersion = m_currentOpenDBRequest-&gt;isOpenRequest() ? m_currentOpenDBRequest-&gt;requestData().requestedVersion() : 0;
 428     auto requestIdentifier = m_currentOpenDBRequest-&gt;requestData().requestIdentifier();
 429 
 430     LOG(IndexedDB, &quot;UniqueIDBDatabase::notifyConnectionsOfVersionChange - %&quot; PRIu64, newVersion);
 431 
 432     // 3.3.7 &quot;versionchange&quot; transaction steps
 433     // Fire a versionchange event at each connection in m_openDatabaseConnections that is open.
 434     // The event must not be fired on connections which has the closePending flag set.
 435     HashSet&lt;uint64_t&gt; connectionIdentifiers;
 436     for (const auto&amp; connection : m_openDatabaseConnections) {
 437         if (connection-&gt;closePending())
 438             continue;
 439 
 440         connection-&gt;fireVersionChangeEvent(requestIdentifier, newVersion);
 441         connectionIdentifiers.add(connection-&gt;identifier());
 442     }
 443 
 444     if (!connectionIdentifiers.isEmpty())
 445         m_currentOpenDBRequest-&gt;notifiedConnectionsOfVersionChange(WTFMove(connectionIdentifiers));
 446     else
 447         m_currentOpenDBRequest-&gt;maybeNotifyRequestBlocked(m_databaseInfo-&gt;version());
 448 }
 449 
 450 void UniqueIDBDatabase::notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(uint64_t connectionIdentifier)
 451 {
 452     LOG(IndexedDB, &quot;UniqueIDBDatabase::notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent - %&quot; PRIu64, connectionIdentifier);
 453 
 454     ASSERT(m_currentOpenDBRequest);
 455 
 456     m_currentOpenDBRequest-&gt;connectionClosedOrFiredVersionChangeEvent(connectionIdentifier);
 457 
 458     if (m_currentOpenDBRequest-&gt;hasConnectionsPendingVersionChangeEvent())
 459         return;
 460 
 461     if (!hasAnyOpenConnections() || allConnectionsAreClosedOrClosing()) {
 462         handleDatabaseOperations();
 463         return;
 464     }
 465 
 466     // Since all open connections have fired their version change events but not all of them have closed,
 467     // this request is officially blocked.
 468     m_currentOpenDBRequest-&gt;maybeNotifyRequestBlocked(m_databaseInfo-&gt;version());
 469 }
 470 
 471 void UniqueIDBDatabase::clearTransactionsOnConnection(UniqueIDBDatabaseConnection&amp; connection)
 472 {
 473     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; pendingTransactions;
 474     while (!m_pendingTransactions.isEmpty()) {
 475         auto transaction = m_pendingTransactions.takeFirst();
 476         if (&amp;transaction-&gt;databaseConnection() != &amp;connection)
 477             pendingTransactions.append(WTFMove(transaction));
 478         else
 479             connection.deleteTransaction(*transaction);
 480     }
 481     if (!pendingTransactions.isEmpty())
 482         m_pendingTransactions.swap(pendingTransactions);
 483 
 484     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; transactionsToAbort;
 485     for (auto&amp; transaction : m_inProgressTransactions.values()) {
 486         if (&amp;transaction-&gt;databaseConnection() == &amp;connection)
 487             transactionsToAbort.append(transaction);
 488     }
 489     for (auto&amp; transaction : transactionsToAbort)
 490         transaction-&gt;abortWithoutCallback();
 491 }
 492 
 493 void UniqueIDBDatabase::didFireVersionChangeEvent(UniqueIDBDatabaseConnection&amp; connection, const IDBResourceIdentifier&amp; requestIdentifier, IndexedDB::ConnectionClosedOnBehalfOfServer connectionClosedOnBehalfOfServer)
 494 {
 495     LOG(IndexedDB, &quot;UniqueIDBDatabase::didFireVersionChangeEvent&quot;);
 496 
 497     if (!m_currentOpenDBRequest)
 498         return;
 499 
 500     ASSERT_UNUSED(requestIdentifier, m_currentOpenDBRequest-&gt;requestData().requestIdentifier() == requestIdentifier);
 501 
 502     if (connectionClosedOnBehalfOfServer == IndexedDB::ConnectionClosedOnBehalfOfServer::Yes) {
 503         if (m_openDatabaseConnections.contains(&amp;connection)) {
 504             clearTransactionsOnConnection(connection);
 505             m_openDatabaseConnections.remove(&amp;connection);
 506         }
 507     }
 508 
 509     notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(connection.identifier());
 510 }
 511 
 512 void UniqueIDBDatabase::openDBRequestCancelled(const IDBResourceIdentifier&amp; requestIdentifier)
 513 {
 514     LOG(IndexedDB, &quot;UniqueIDBDatabase::openDBRequestCancelled - %s&quot;, requestIdentifier.loggingString().utf8().data());
 515 
 516     if (m_currentOpenDBRequest &amp;&amp; m_currentOpenDBRequest-&gt;requestData().requestIdentifier() == requestIdentifier)
 517         m_currentOpenDBRequest = nullptr;
 518 
 519     if (m_versionChangeDatabaseConnection &amp;&amp; m_versionChangeDatabaseConnection-&gt;openRequestIdentifier() == requestIdentifier) {
 520         ASSERT(!m_versionChangeTransaction || m_versionChangeTransaction-&gt;databaseConnection().openRequestIdentifier() == requestIdentifier);
 521         ASSERT(!m_versionChangeTransaction || &amp;m_versionChangeTransaction-&gt;databaseConnection() == m_versionChangeDatabaseConnection);
 522 
 523         connectionClosedFromClient(*m_versionChangeDatabaseConnection);
 524     }
 525 
 526     for (auto&amp; request : m_pendingOpenDBRequests) {
 527         if (request-&gt;requestData().requestIdentifier() == requestIdentifier) {
 528             m_pendingOpenDBRequests.remove(request);
 529             return;
 530         }
 531     }
 532 }
 533 
 534 void UniqueIDBDatabase::addOpenDatabaseConnection(Ref&lt;UniqueIDBDatabaseConnection&gt;&amp;&amp; connection)
 535 {
 536     ASSERT(!m_openDatabaseConnections.contains(&amp;connection.get()));
 537     m_openDatabaseConnections.add(adoptRef(connection.leakRef()));
 538 }
 539 
 540 void UniqueIDBDatabase::createObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const IDBObjectStoreInfo&amp; info, ErrorCallback callback)
 541 {
 542     ASSERT(!isMainThread());
 543     LOG(IndexedDB, &quot;UniqueIDBDatabase::createObjectStore&quot;);
 544 
 545     ASSERT(m_backingStore);
 546 
 547     // Quota check.
 548     auto taskSize = defaultWriteOperationCost + estimateSize(info);
 549     if (m_server.requestSpace(m_identifier.origin(), taskSize) == StorageQuotaManager::Decision::Deny) {
 550         callback(IDBError { QuotaExceededError, quotaErrorMessageName(&quot;CreateObjectStore&quot;) });
 551         return;
 552     }
 553 
 554     auto error = m_backingStore-&gt;createObjectStore(transaction.info().identifier(), info);
 555     if (error.isNull())
 556         m_databaseInfo-&gt;addExistingObjectStore(info);
 557 
 558     callback(error);
 559 }
 560 
 561 void UniqueIDBDatabase::deleteObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const String&amp; objectStoreName, ErrorCallback callback)
 562 {
 563     ASSERT(!isMainThread());
 564     LOG(IndexedDB, &quot;UniqueIDBDatabase::deleteObjectStore&quot;);
 565 
 566     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreName);
 567     if (!info) {
 568         callback(IDBError { UnknownError, &quot;Attempt to delete non-existant object store&quot;_s });
 569         return;
 570     }
 571 
 572     ASSERT(m_backingStore);
 573     auto error = m_backingStore-&gt;deleteObjectStore(transaction.info().identifier(), info-&gt;identifier());
 574     if (error.isNull())
 575         m_databaseInfo-&gt;deleteObjectStore(info-&gt;identifier());
 576 
 577     callback(error);
 578 }
 579 
 580 void UniqueIDBDatabase::renameObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; newName, ErrorCallback callback)
 581 {
 582     ASSERT(!isMainThread());
 583     LOG(IndexedDB, &quot;UniqueIDBDatabase::renameObjectStore&quot;);
 584 
 585     // Quota check.
 586     auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();
 587     if (m_server.requestSpace(m_identifier.origin(), taskSize) == StorageQuotaManager::Decision::Deny) {
 588         callback(IDBError(QuotaExceededError, quotaErrorMessageName(&quot;RenameObjectStore&quot;)));
 589         return;
 590     }
 591 
 592     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
 593     if (!info) {
 594         callback(IDBError { UnknownError, &quot;Attempt to rename non-existant object store&quot;_s });
 595         return;
 596     }
 597 
 598     ASSERT(m_backingStore);
 599     auto error = m_backingStore-&gt;renameObjectStore(transaction.info().identifier(), objectStoreIdentifier, newName);
 600     if (error.isNull())
 601         m_databaseInfo-&gt;renameObjectStore(objectStoreIdentifier, newName);
 602 
 603     callback(error);
 604 }
 605 
 606 void UniqueIDBDatabase::clearObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, ErrorCallback callback)
 607 {
 608     ASSERT(!isMainThread());
 609     LOG(IndexedDB, &quot;UniqueIDBDatabase::clearObjectStore&quot;);
 610 
 611     ASSERT(m_backingStore);
 612     auto error = m_backingStore-&gt;clearObjectStore(transaction.info().identifier(), objectStoreIdentifier);
 613 
 614     callback(error);
 615 }
 616 
 617 void UniqueIDBDatabase::createIndex(UniqueIDBDatabaseTransaction&amp; transaction, const IDBIndexInfo&amp; info, ErrorCallback callback)
 618 {
 619     ASSERT(!isMainThread());
 620     LOG(IndexedDB, &quot;UniqueIDBDatabase::createIndex&quot;);
 621 
 622     // Quota check.
 623     auto taskSize = defaultWriteOperationCost + estimateSize(info);
 624     if (m_server.requestSpace(m_identifier.origin(), taskSize) == StorageQuotaManager::Decision::Deny) {
 625         callback(IDBError { QuotaExceededError, quotaErrorMessageName(&quot;CreateIndex&quot;) });
 626         return;
 627     }
 628 
 629     ASSERT(m_backingStore);
 630     auto error = m_backingStore-&gt;createIndex(transaction.info().identifier(), info);
 631     if (error.isNull()) {
 632         ASSERT(m_databaseInfo);
 633         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());
 634         ASSERT(objectStoreInfo);
 635         objectStoreInfo-&gt;addExistingIndex(info);
 636         m_databaseInfo-&gt;setMaxIndexID(info.identifier());
 637     }
 638 
 639     callback(error);
 640 }
 641 
 642 void UniqueIDBDatabase::deleteIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; indexName, ErrorCallback callback)
 643 {
 644     ASSERT(!isMainThread());
 645     LOG(IndexedDB, &quot;UniqueIDBDatabase::deleteIndex&quot;);
 646 
 647     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
 648     if (!objectStoreInfo) {
 649         callback(IDBError { UnknownError, &quot;Attempt to delete index from non-existant object store&quot;_s });
 650         return;
 651     }
 652 
 653     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexName);
 654     if (!indexInfo) {
 655         callback(IDBError { UnknownError, &quot;Attempt to delete non-existant index&quot;_s });
 656         return;
 657     }
 658     auto indexIdentifier = indexInfo-&gt;identifier();
 659 
 660     ASSERT(m_backingStore);
 661     auto error = m_backingStore-&gt;deleteIndex(transaction.info().identifier(), objectStoreIdentifier, indexIdentifier);
 662     if (error.isNull())
 663         objectStoreInfo-&gt;deleteIndex(indexIdentifier);
 664 
 665     callback(error);
 666 }
 667 
 668 void UniqueIDBDatabase::renameIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName, ErrorCallback callback)
 669 {
 670     ASSERT(!isMainThread());
 671     LOG(IndexedDB, &quot;UniqueIDBDatabase::renameIndex&quot;);
 672 
 673     // Quota check.
 674     auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();
 675     if (m_server.requestSpace(m_identifier.origin(), taskSize) == StorageQuotaManager::Decision::Deny) {
 676         callback(IDBError { QuotaExceededError, quotaErrorMessageName(&quot;RenameIndex&quot;) });
 677         return;
 678     }
 679 
 680     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
 681     if (!objectStoreInfo) {
 682         callback(IDBError { UnknownError, &quot;Attempt to rename index in non-existant object store&quot;_s });
 683         return;
 684     }
 685 
 686     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
 687     if (!indexInfo) {
 688         callback(IDBError { UnknownError, &quot;Attempt to rename non-existant index&quot;_s });
 689         return;
 690     }
 691 
 692     ASSERT(m_backingStore);
 693     auto error = m_backingStore-&gt;renameIndex(transaction.info().identifier(), objectStoreIdentifier, indexIdentifier, newName);
 694     if (error.isNull())
 695         indexInfo-&gt;rename(newName);
 696 
 697     callback(error);
 698 }
 699 
 700 void UniqueIDBDatabase::putOrAdd(const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode, KeyDataCallback callback)
 701 {
 702     ASSERT(!isMainThread());
 703     LOG(IndexedDB, &quot;UniqueIDBDatabase::putOrAdd&quot;);
 704 
 705     ASSERT(m_databaseInfo);
 706 
 707     IDBKeyData usedKey;
 708     IDBError error;
 709 
 710     ASSERT(m_backingStore);
 711     auto objectStoreIdentifier = requestData.objectStoreIdentifier();
 712     auto* objectStoreInfo = m_backingStore-&gt;infoForObjectStore(objectStoreIdentifier);
 713     if (!objectStoreInfo) {
 714         callback(IDBError { InvalidStateError, &quot;Object store cannot be found in the backing store&quot;_s }, usedKey);
 715         return;
 716     }
 717 
 718     // Quota check.
 719     auto taskSize = defaultWriteOperationCost + estimateSize(keyData) + estimateSize(value);
 720     auto* objectStore = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
 721     if (objectStore)
 722         taskSize += objectStore-&gt;indexNames().size() * taskSize;
 723     if (m_server.requestSpace(m_identifier.origin(), taskSize) == StorageQuotaManager::Decision::Deny) {
 724         callback(IDBError { QuotaExceededError, quotaErrorMessageName(&quot;PutOrAdd&quot;) }, usedKey);
 725         return;
 726     }
 727 
 728     bool usedKeyIsGenerated = false;
 729     uint64_t keyNumber;
 730     auto transactionIdentifier = requestData.transactionIdentifier();
 731     auto generatedKeyResetter = WTF::makeScopeExit([this, transactionIdentifier, objectStoreIdentifier, &amp;keyNumber, &amp;usedKeyIsGenerated]() {
 732         if (usedKeyIsGenerated)
 733             m_backingStore-&gt;revertGeneratedKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
 734     });
 735 
 736     if (objectStoreInfo-&gt;autoIncrement() &amp;&amp; !keyData.isValid()) {
 737         error = m_backingStore-&gt;generateKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
 738         if (!error.isNull()) {
 739             callback(error, usedKey);
 740             return;
 741         }
 742         usedKey.setNumberValue(keyNumber);
 743         usedKeyIsGenerated = true;
 744     } else
 745         usedKey = keyData;
 746 
 747     if (overwriteMode == IndexedDB::ObjectStoreOverwriteMode::NoOverwrite) {
 748         bool keyExists;
 749         error = m_backingStore-&gt;keyExistsInObjectStore(transactionIdentifier, objectStoreIdentifier, usedKey, keyExists);
 750         if (error.isNull() &amp;&amp; keyExists)
 751             error = IDBError { ConstraintError, &quot;Key already exists in the object store&quot;_s };
 752 
 753         if (!error.isNull()) {
 754             callback(error, usedKey);
 755             return;
 756         }
 757     }
 758     // If a record already exists in store, then remove the record from store using the steps for deleting records from an object store.
 759     // This is important because formally deleting it from from the object store also removes it from the appropriate indexes.
 760     error = m_backingStore-&gt;deleteRange(transactionIdentifier, objectStoreIdentifier, usedKey);
 761     if (!error.isNull()) {
 762         callback(error, usedKey);
 763         return;
 764     }
 765 
 766     error = m_backingStore-&gt;addRecord(transactionIdentifier, *objectStoreInfo, usedKey, value);
 767     if (!error.isNull()) {
 768         callback(error, usedKey);
 769         return;
 770     }
 771 
 772     if (overwriteMode != IndexedDB::ObjectStoreOverwriteMode::OverwriteForCursor &amp;&amp; objectStoreInfo-&gt;autoIncrement() &amp;&amp; keyData.type() == IndexedDB::KeyType::Number)
 773         error = m_backingStore-&gt;maybeUpdateKeyGeneratorNumber(transactionIdentifier, objectStoreIdentifier, keyData.number());
 774 
 775     generatedKeyResetter.release();
 776     callback(error, usedKey);
 777 }
 778 
 779 void UniqueIDBDatabase::getRecord(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData, GetResultCallback callback)
 780 {
 781     ASSERT(!isMainThread());
 782     LOG(IndexedDB, &quot;UniqueIDBDatabase::getRecord&quot;);
 783 
 784     IDBGetResult result;
 785     IDBError error;
 786 
 787     ASSERT(m_backingStore);
 788     if (uint64_t indexIdentifier = requestData.indexIdentifier())
 789         error = m_backingStore-&gt;getIndexRecord(requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), indexIdentifier, requestData.indexRecordType(), getRecordData.keyRangeData, result);
 790     else
 791         error = m_backingStore-&gt;getRecord(requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), getRecordData.keyRangeData, getRecordData.type, result);
 792 
 793     callback(error, result);
 794 }
 795 
 796 void UniqueIDBDatabase::getAllRecords(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData, GetAllResultsCallback callback)
 797 {
 798     ASSERT(!isMainThread());
 799     LOG(IndexedDB, &quot;UniqueIDBDatabase::getAllRecords&quot;);
 800 
 801     ASSERT(m_backingStore);
 802     IDBGetAllResult result;
 803     auto error = m_backingStore-&gt;getAllRecords(requestData.transactionIdentifier(), getAllRecordsData, result);
 804 
 805     callback(error, result);
 806 }
 807 
 808 void UniqueIDBDatabase::getCount(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; range, CountCallback callback)
 809 {
 810     ASSERT(!isMainThread());
 811     LOG(IndexedDB, &quot;UniqueIDBDatabase::getCount&quot;);
 812 
 813     ASSERT(m_backingStore);
 814     uint64_t count = 0;
 815     auto error = m_backingStore-&gt;getCount(requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), requestData.indexIdentifier(), range, count);
 816 
 817     callback(error, count);
 818 }
 819 
 820 void UniqueIDBDatabase::deleteRecord(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData, ErrorCallback callback)
 821 {
 822     ASSERT(!isMainThread());
 823     LOG(IndexedDB, &quot;UniqueIDBDatabase::deleteRecord&quot;);
 824 
 825     ASSERT(m_backingStore);
 826     auto error = m_backingStore-&gt;deleteRange(requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyRangeData);
 827 
 828     callback(error);
 829 }
 830 
 831 void UniqueIDBDatabase::openCursor(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info, GetResultCallback callback)
 832 {
 833     ASSERT(!isMainThread());
 834     LOG(IndexedDB, &quot;UniqueIDBDatabase::openCursor&quot;);
 835 
 836     ASSERT(m_backingStore);
 837 
 838     IDBGetResult result;
 839     auto error = m_backingStore-&gt;openCursor(requestData.transactionIdentifier(), info, result);
 840 
 841     callback(error, result);
 842 }
 843 
 844 void UniqueIDBDatabase::iterateCursor(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data, GetResultCallback callback)
 845 {
 846     ASSERT(!isMainThread());
 847     LOG(IndexedDB, &quot;UniqueIDBDatabase::iterateCursor&quot;);
 848 
 849     ASSERT(m_backingStore);
 850 
 851     IDBGetResult result;
 852     auto transactionIdentifier = requestData.transactionIdentifier();
 853     auto cursorIdentifier = requestData.cursorIdentifier();
 854     auto error = m_backingStore-&gt;iterateCursor(transactionIdentifier, cursorIdentifier, data, result);
 855 
 856     callback(error, result);
 857 }
 858 
 859 void UniqueIDBDatabase::commitTransaction(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)
 860 {
 861     ASSERT(!isMainThread());
 862     LOG(IndexedDB, &quot;UniqueIDBDatabase::commitTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());
 863 
 864     ASSERT(transaction.databaseConnection().database() == this);
 865     ASSERT(m_backingStore);
 866     auto takenTransaction = m_inProgressTransactions.take(transaction.info().identifier());
 867     if (!takenTransaction) {
 868         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection()))
 869             return;
 870 
 871         callback(IDBError { UnknownError, &quot;Attempt to commit transaction that is not running&quot;_s });
 872         return;
 873     }
 874 
 875     auto error = m_backingStore-&gt;commitTransaction(transaction.info().identifier());
 876 
 877     callback(error);
 878     transactionCompleted(WTFMove(takenTransaction));
 879 }
 880 
 881 void UniqueIDBDatabase::abortTransaction(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)
 882 {
 883     ASSERT(!isMainThread());
 884     LOG(IndexedDB, &quot;UniqueIDBDatabase::abortTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());
 885 
 886     ASSERT(transaction.databaseConnection().database() == this);
 887 
 888     auto takenTransaction = m_inProgressTransactions.take(transaction.info().identifier());
 889     if (!takenTransaction) {
 890         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection()))
 891             return;
 892 
 893         callback(IDBError { UnknownError, &quot;Attempt to abort transaction that is not running&quot;_s });
 894         return;
 895     }
 896 
 897     // If transaction is already aborted on the main thread for suspension,
 898     // return the result of that abort.
 899     if (auto existingAbortResult = takenTransaction-&gt;mainThreadAbortResult()) {
 900         callback(*existingAbortResult);
 901         transactionCompleted(WTFMove(takenTransaction));
 902         return;
 903     }
 904 
 905     auto transactionIdentifier = transaction.info().identifier();
 906     if (m_versionChangeTransaction &amp;&amp; m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier) {
 907         ASSERT(m_versionChangeTransaction == &amp;transaction);
 908         ASSERT(!m_versionChangeDatabaseConnection || &amp;m_versionChangeTransaction-&gt;databaseConnection() == m_versionChangeDatabaseConnection);
 909         ASSERT(m_versionChangeTransaction-&gt;originalDatabaseInfo());
 910         m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(*m_versionChangeTransaction-&gt;originalDatabaseInfo());
 911     }
 912 
 913     auto error = m_backingStore-&gt;abortTransaction(transactionIdentifier);
 914 
 915     callback(error);
 916     transactionCompleted(WTFMove(takenTransaction));
 917 }
 918 
 919 void UniqueIDBDatabase::didFinishHandlingVersionChange(UniqueIDBDatabaseConnection&amp; connection, const IDBResourceIdentifier&amp; transactionIdentifier)
 920 {
 921     ASSERT(!isMainThread());
 922     LOG(IndexedDB, &quot;UniqueIDBDatabase::didFinishHandlingVersionChange&quot;);
 923 
 924     ASSERT_UNUSED(transactionIdentifier, !m_versionChangeTransaction || m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier);
 925     ASSERT_UNUSED(connection, !m_versionChangeDatabaseConnection || m_versionChangeDatabaseConnection.get() == &amp;connection);
 926 
 927     m_versionChangeTransaction = nullptr;
 928     m_versionChangeDatabaseConnection = nullptr;
 929 
 930     handleDatabaseOperations();
 931     handleTransactions();
 932 }
 933 
 934 void UniqueIDBDatabase::connectionClosedFromClient(UniqueIDBDatabaseConnection&amp; connection)
 935 {
 936     ASSERT(!isMainThread());
 937     LOG(IndexedDB, &quot;UniqueIDBDatabase::connectionClosedFromClient - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
 938 
 939     Ref&lt;UniqueIDBDatabaseConnection&gt; protectedConnection(connection);
 940     m_openDatabaseConnections.remove(&amp;connection);
 941 
 942     if (m_versionChangeDatabaseConnection == &amp;connection) {
 943         m_versionChangeDatabaseConnection = nullptr;
 944         if (m_versionChangeTransaction) {
 945             connection.abortTransactionWithoutCallback(*m_versionChangeTransaction);
 946             ASSERT(!connection.hasNonFinishedTransactions());
 947 
 948             // Previous blocked operations or transactions may be runnable.
 949             handleDatabaseOperations();
 950             handleTransactions();
 951 
 952             return;
 953         }
 954     }
 955 
 956     // Remove all pending transactions on the connection.
 957     clearTransactionsOnConnection(connection);
 958 
 959     if (m_currentOpenDBRequest)
 960         notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(connection.identifier());
 961 
 962     ASSERT(!connection.hasNonFinishedTransactions());
 963 
 964     // Now that a database connection has closed, previously blocked operations might be runnable.
 965     handleDatabaseOperations();
 966     handleTransactions();
 967 }
 968 
 969 void UniqueIDBDatabase::connectionClosedFromServer(UniqueIDBDatabaseConnection&amp; connection)
 970 {
 971     ASSERT(!isMainThread());
 972     LOG(IndexedDB, &quot;UniqueIDBDatabase::connectionClosedFromServer - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
 973 
 974     connection.connectionToClient().didCloseFromServer(connection, IDBError::userDeleteError());
 975 
 976     m_openDatabaseConnections.remove(&amp;connection);
 977 }
 978 
 979 void UniqueIDBDatabase::enqueueTransaction(Ref&lt;UniqueIDBDatabaseTransaction&gt;&amp;&amp; transaction)
 980 {
 981     LOG(IndexedDB, &quot;UniqueIDBDatabase::enqueueTransaction - %s&quot;, transaction-&gt;info().loggingString().utf8().data());
 982 
 983     ASSERT(transaction-&gt;info().mode() != IDBTransactionMode::Versionchange);
 984 
 985     m_pendingTransactions.append(WTFMove(transaction));
 986 
 987     handleTransactions();
 988 }
 989 
 990 void UniqueIDBDatabase::handleTransactions()
 991 {
 992     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleTransactions - There are %zu pending&quot;, m_pendingTransactions.size());
 993 
 994     bool hadDeferredTransactions = false;
 995     auto transaction = takeNextRunnableTransaction(hadDeferredTransactions);
 996 
 997     while (transaction) {
 998         m_inProgressTransactions.set(transaction-&gt;info().identifier(), transaction);
 999         for (auto objectStore : transaction-&gt;objectStoreIdentifiers()) {
1000             m_objectStoreTransactionCounts.add(objectStore);
1001             if (!transaction-&gt;isReadOnly()) {
1002                 m_objectStoreWriteTransactions.add(objectStore);
1003                 ASSERT(m_objectStoreTransactionCounts.count(objectStore) == 1);
1004             }
1005         }
1006 
1007         activateTransactionInBackingStore(*transaction);
1008         if (hadDeferredTransactions)
1009             break;
1010         transaction = takeNextRunnableTransaction(hadDeferredTransactions);
1011     }
1012     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleTransactions - There are %zu pending after this round of handling&quot;, m_pendingTransactions.size());
1013 }
1014 
1015 void UniqueIDBDatabase::activateTransactionInBackingStore(UniqueIDBDatabaseTransaction&amp; transaction)
1016 {
1017     LOG(IndexedDB, &quot;UniqueIDBDatabase::activateTransactionInBackingStore&quot;);
1018 
1019     ASSERT(m_backingStore);
1020 
1021     auto error = m_backingStore-&gt;beginTransaction(transaction.info());
1022 
1023     transaction.didActivateInBackingStore(error);
1024 }
1025 
1026 template&lt;typename T&gt; bool scopesOverlap(const T&amp; aScopes, const Vector&lt;uint64_t&gt;&amp; bScopes)
1027 {
1028     for (auto scope : bScopes) {
1029         if (aScopes.contains(scope))
1030             return true;
1031     }
1032 
1033     return false;
1034 }
1035 
1036 RefPtr&lt;UniqueIDBDatabaseTransaction&gt; UniqueIDBDatabase::takeNextRunnableTransaction(bool&amp; hadDeferredTransactions)
1037 {
1038     hadDeferredTransactions = false;
1039 
1040     if (m_pendingTransactions.isEmpty())
1041         return nullptr;
1042 
1043     if (!m_backingStore-&gt;supportsSimultaneousTransactions() &amp;&amp; !m_inProgressTransactions.isEmpty()) {
1044         LOG(IndexedDB, &quot;UniqueIDBDatabase::takeNextRunnableTransaction - Backing store only supports 1 transaction, and we already have 1&quot;);
1045         return nullptr;
1046     }
1047 
1048     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; deferredTransactions;
1049     RefPtr&lt;UniqueIDBDatabaseTransaction&gt; currentTransaction;
1050 
1051     HashSet&lt;uint64_t&gt; deferredReadWriteScopes;
1052 
1053     while (!m_pendingTransactions.isEmpty()) {
1054         currentTransaction = m_pendingTransactions.takeFirst();
1055 
1056         switch (currentTransaction-&gt;info().mode()) {
1057         case IDBTransactionMode::Readonly: {
1058             bool hasOverlappingScopes = scopesOverlap(deferredReadWriteScopes, currentTransaction-&gt;objectStoreIdentifiers());
1059             hasOverlappingScopes |= scopesOverlap(m_objectStoreWriteTransactions, currentTransaction-&gt;objectStoreIdentifiers());
1060 
1061             if (hasOverlappingScopes)
1062                 deferredTransactions.append(WTFMove(currentTransaction));
1063 
1064             break;
1065         }
1066         case IDBTransactionMode::Readwrite: {
1067             bool hasOverlappingScopes = scopesOverlap(m_objectStoreTransactionCounts, currentTransaction-&gt;objectStoreIdentifiers());
1068             hasOverlappingScopes |= scopesOverlap(deferredReadWriteScopes, currentTransaction-&gt;objectStoreIdentifiers());
1069 
1070             if (hasOverlappingScopes) {
1071                 for (auto objectStore : currentTransaction-&gt;objectStoreIdentifiers())
1072                     deferredReadWriteScopes.add(objectStore);
1073                 deferredTransactions.append(WTFMove(currentTransaction));
1074             }
1075 
1076             break;
1077         }
1078         case IDBTransactionMode::Versionchange:
1079             // Version change transactions should never be scheduled in the traditional manner.
1080             RELEASE_ASSERT_NOT_REACHED();
1081         }
1082 
1083         // If we didn&#39;t defer the currentTransaction above, it can be run now.
1084         if (currentTransaction)
1085             break;
1086     }
1087 
1088     hadDeferredTransactions = !deferredTransactions.isEmpty();
1089     if (!hadDeferredTransactions)
1090         return currentTransaction;
1091 
1092     // Prepend the deferred transactions back on the beginning of the deque for future scheduling passes.
1093     while (!deferredTransactions.isEmpty())
1094         m_pendingTransactions.prepend(deferredTransactions.takeLast());
1095 
1096     return currentTransaction;
1097 }
1098 
1099 void UniqueIDBDatabase::transactionCompleted(RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&amp;&amp; transaction)
1100 {
1101     ASSERT(transaction);
1102     ASSERT(!m_inProgressTransactions.contains(transaction-&gt;info().identifier()));
1103     ASSERT(!isMainThread());
1104 
1105     for (auto objectStore : transaction-&gt;objectStoreIdentifiers()) {
1106         if (!transaction-&gt;isReadOnly()) {
1107             m_objectStoreWriteTransactions.remove(objectStore);
1108             ASSERT(m_objectStoreTransactionCounts.count(objectStore) == 1);
1109         }
1110         m_objectStoreTransactionCounts.remove(objectStore);
1111     }
1112 
1113     if (m_versionChangeTransaction == transaction)
1114         m_versionChangeTransaction = nullptr;
1115 
1116     // Previously blocked operations might be runnable.
1117     handleDatabaseOperations();
1118     handleTransactions();
1119 }
1120 
1121 static void errorOpenDBRequestForUserDelete(ServerOpenDBRequest&amp; request)
1122 {
1123     auto result = IDBResultData::error(request.requestData().requestIdentifier(), IDBError::userDeleteError());
1124     if (request.isOpenRequest())
1125         request.connection().didOpenDatabase(result);
1126     else
1127         request.connection().didDeleteDatabase(result);
1128 }
1129 
1130 void UniqueIDBDatabase::immediateCloseForUserDelete()
1131 {
1132     LOG(IndexedDB, &quot;UniqueIDBDatabase::immediateCloseForUserDelete&quot;);
1133 
1134     // Error out all transactions.
1135     // Pending transactions must be cleared before in-progress transactions,
1136     // or they may get started right away after aborting in-progress transactions.
1137     for (auto&amp; transaction : m_pendingTransactions)
1138         transaction-&gt;databaseConnection().deleteTransaction(*transaction);
1139     m_pendingTransactions.clear();
1140 
1141     for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys()))
1142         m_inProgressTransactions.get(identifier)-&gt;abortWithoutCallback();
1143 
1144     ASSERT(m_inProgressTransactions.isEmpty());
1145 
1146     m_objectStoreTransactionCounts.clear();
1147     m_objectStoreWriteTransactions.clear();
1148 
1149     // Error out all IDBOpenDBRequests
1150     if (m_currentOpenDBRequest) {
1151         errorOpenDBRequestForUserDelete(*m_currentOpenDBRequest);
1152         m_currentOpenDBRequest = nullptr;
1153     }
1154 
1155     for (auto&amp; request : m_pendingOpenDBRequests)
1156         errorOpenDBRequestForUserDelete(*request);
1157 
1158     m_pendingOpenDBRequests.clear();
1159 
1160     // Close all open connections
1161     auto openDatabaseConnections = m_openDatabaseConnections;
1162     for (auto&amp; connection : openDatabaseConnections)
1163         connectionClosedFromServer(*connection);
1164 
1165     if (m_versionChangeDatabaseConnection) {
1166         connectionClosedFromServer(*m_versionChangeDatabaseConnection);
1167         m_versionChangeDatabaseConnection = nullptr;
1168     }
1169 
1170     ASSERT(!hasAnyOpenConnections());
1171 
1172     close();
1173 }
1174 
1175 void UniqueIDBDatabase::abortActiveTransactions()
1176 {
1177     ASSERT(isMainThread());
1178     ASSERT(m_server.lock().isHeld());
1179 
1180     for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys())) {
1181         auto transaction = m_inProgressTransactions.get(identifier);
1182         transaction-&gt;setMainThreadAbortResult(m_backingStore-&gt;abortTransaction(transaction-&gt;info().identifier()));
1183     }
1184 }
1185 
1186 void UniqueIDBDatabase::close()
1187 {
1188     LOG(IndexedDB, &quot;UniqueIDBDatabase::close&quot;);
1189 
1190     if (m_backingStore) {
1191         m_backingStore-&gt;close();
1192         m_backingStore = nullptr;
1193     }
1194 }
1195 
1196 RefPtr&lt;ServerOpenDBRequest&gt; UniqueIDBDatabase::takeNextRunnableRequest(RequestType requestType)
1197 {
1198     // Connection of request may be closed or lost.
1199     clearStalePendingOpenDBRequests();
1200 
1201     if (!m_pendingOpenDBRequests.isEmpty()) {
1202         if (requestType == RequestType::Delete &amp;&amp; !m_pendingOpenDBRequests.first()-&gt;isDeleteRequest())
1203             return nullptr;
1204         return m_pendingOpenDBRequests.takeFirst();
1205     }
1206 
1207     return nullptr;
1208 }
1209 
1210 } // namespace IDBServer
1211 } // namespace WebCore
1212 
1213 #endif // ENABLE(INDEXED_DATABASE)
    </pre>
  </body>
</html>
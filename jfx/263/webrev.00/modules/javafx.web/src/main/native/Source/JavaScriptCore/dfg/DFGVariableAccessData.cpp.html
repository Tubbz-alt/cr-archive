<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVariableAccessData.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014, 2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGVariableAccessData.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 namespace JSC { namespace DFG {
 32 
 33 VariableAccessData::VariableAccessData()
 34     : m_prediction(SpecNone)
 35     , m_argumentAwarePrediction(SpecNone)
 36     , m_flags(0)
 37     , m_shouldNeverUnbox(false)
 38     , m_structureCheckHoistingFailed(false)
 39     , m_checkArrayHoistingFailed(false)
 40     , m_isProfitableToUnbox(false)
 41     , m_isLoadedFrom(false)
 42     , m_doubleFormatState(EmptyDoubleFormatState)
 43 {
 44     clearVotes();
 45 }
 46 
 47 VariableAccessData::VariableAccessData(Operand operand)
 48     : m_prediction(SpecNone)
 49     , m_argumentAwarePrediction(SpecNone)
 50     , m_operand(operand)
 51     , m_flags(0)
 52     , m_shouldNeverUnbox(false)
 53     , m_structureCheckHoistingFailed(false)
 54     , m_checkArrayHoistingFailed(false)
 55     , m_isProfitableToUnbox(false)
 56     , m_isLoadedFrom(false)
 57     , m_doubleFormatState(EmptyDoubleFormatState)
 58 {
 59     clearVotes();
 60 }
 61 
 62 bool VariableAccessData::mergeShouldNeverUnbox(bool shouldNeverUnbox)
 63 {
 64     bool newShouldNeverUnbox = m_shouldNeverUnbox | shouldNeverUnbox;
 65     if (newShouldNeverUnbox == m_shouldNeverUnbox)
 66         return false;
 67     m_shouldNeverUnbox = newShouldNeverUnbox;
 68     return true;
 69 }
 70 
 71 bool VariableAccessData::predict(SpeculatedType prediction)
 72 {
 73     VariableAccessData* self = find();
 74     bool result = mergeSpeculation(self-&gt;m_prediction, prediction);
 75     if (result)
 76         mergeSpeculation(m_argumentAwarePrediction, m_prediction);
 77     return result;
 78 }
 79 
 80 bool VariableAccessData::mergeArgumentAwarePrediction(SpeculatedType prediction)
 81 {
 82     return mergeSpeculation(find()-&gt;m_argumentAwarePrediction, prediction);
 83 }
 84 
 85 bool VariableAccessData::shouldUseDoubleFormatAccordingToVote()
 86 {
 87     // We don&#39;t support this facility for arguments, yet.
 88     // FIXME: make this work for arguments.
 89     if (operand().isArgument())
 90         return false;
 91 
 92     // If the variable is not a number prediction, then this doesn&#39;t
 93     // make any sense.
 94     if (!isFullNumberSpeculation(prediction())) {
 95         // FIXME: we may end up forcing a local in inlined argument position to be a double even
 96         // if it is sometimes not even numeric, since this never signals the fact that it doesn&#39;t
 97         // want doubles. https://bugs.webkit.org/show_bug.cgi?id=109511
 98         return false;
 99     }
100 
101     // If the variable is predicted to hold only doubles, then it&#39;s a
102     // no-brainer: it should be formatted as a double.
103     if (isDoubleSpeculation(prediction()))
104         return true;
105 
106     // If the variable is known to be used as an integer, then be safe -
107     // don&#39;t force it to be a double.
108     if (flags() &amp; NodeBytecodeUsesAsInt)
109         return false;
110 
111     // If the variable has been voted to become a double, then make it a
112     // double.
113     if (voteRatio() &gt;= Options::doubleVoteRatioForDoubleFormat())
114         return true;
115 
116     return false;
117 }
118 
119 bool VariableAccessData::tallyVotesForShouldUseDoubleFormat()
120 {
121     ASSERT(isRoot());
122 
123     if (operand().isArgument() || shouldNeverUnbox()
124         || (flags() &amp; NodeBytecodeUsesAsArrayIndex))
125         return DFG::mergeDoubleFormatState(m_doubleFormatState, NotUsingDoubleFormat);
126 
127     if (m_doubleFormatState == CantUseDoubleFormat)
128         return false;
129 
130     bool newValueOfShouldUseDoubleFormat = shouldUseDoubleFormatAccordingToVote();
131     if (!newValueOfShouldUseDoubleFormat) {
132         // We monotonically convert to double. Hence, if the fixpoint leads us to conclude that we should
133         // switch back to int, we instead ignore this and stick with double.
134         return false;
135     }
136 
137     if (m_doubleFormatState == UsingDoubleFormat)
138         return false;
139 
140     return DFG::mergeDoubleFormatState(m_doubleFormatState, UsingDoubleFormat);
141 }
142 
143 bool VariableAccessData::mergeDoubleFormatState(DoubleFormatState doubleFormatState)
144 {
145     return DFG::mergeDoubleFormatState(find()-&gt;m_doubleFormatState, doubleFormatState);
146 }
147 
148 bool VariableAccessData::makePredictionForDoubleFormat()
149 {
150     ASSERT(isRoot());
151 
152     if (m_doubleFormatState != UsingDoubleFormat)
153         return false;
154 
155     SpeculatedType type = m_prediction;
156     if (type &amp; ~SpecBytecodeNumber)
157         type |= SpecDoublePureNaN;
158     if (type &amp; (SpecInt32Only | SpecInt52Any))
159         type |= SpecAnyIntAsDouble;
160     return checkAndSet(m_prediction, type);
161 }
162 
163 bool VariableAccessData::couldRepresentInt52()
164 {
165     if (shouldNeverUnbox())
166         return false;
167 
168     return couldRepresentInt52Impl();
169 }
170 
171 bool VariableAccessData::couldRepresentInt52Impl()
172 {
173     // The hardware has to support it.
174     if (!enableInt52())
175         return false;
176 
177     // We punt for machine arguments.
178     if (operand().isArgument())
179         return false;
180 
181     // The argument-aware prediction -- which merges all of an (inlined or machine)
182     // argument&#39;s variable access datas&#39; predictions -- must possibly be Int52Any.
183     return isInt32OrInt52Speculation(argumentAwarePrediction());
184 }
185 
186 FlushFormat VariableAccessData::flushFormat()
187 {
188     ASSERT(find() == this);
189 
190     if (!shouldUnboxIfPossible())
191         return FlushedJSValue;
192 
193     if (shouldUseDoubleFormat())
194         return FlushedDouble;
195 
196     SpeculatedType prediction = argumentAwarePrediction();
197 
198     // This guard is here to protect the call to couldRepresentInt52(), which will return
199     // true for !prediction.
200     if (!prediction)
201         return FlushedJSValue;
202 
203     if (isInt32Speculation(prediction))
204         return FlushedInt32;
205 
206     if (couldRepresentInt52Impl())
207         return FlushedInt52;
208 
209     if (isCellSpeculation(prediction))
210         return FlushedCell;
211 
212     if (isBooleanSpeculation(prediction))
213         return FlushedBoolean;
214 
215     return FlushedJSValue;
216 }
217 
218 } } // namespace JSC::DFG
219 
220 #endif // ENABLE(DFG_JIT)
221 
    </pre>
  </body>
</html>
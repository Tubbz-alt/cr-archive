<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArgumentsEliminationPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGArgumentPosition.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGArgumentsUtilities.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArgumentsEliminationPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -50,11 +50,11 @@</span>
  namespace JSC { namespace DFG {
  
  namespace {
  
  namespace DFGArgumentsEliminationPhaseInternal {
<span class="udiff-line-modified-removed">- static const bool verbose = false;</span>
<span class="udiff-line-modified-added">+ static constexpr bool verbose = false;</span>
  }
  
  class ArgumentsEliminationPhase : public Phase {
  public:
      ArgumentsEliminationPhase(Graph&amp; graph)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -356,13 +356,16 @@</span>
                  }
  
                  case NewArrayBuffer:
                      break;
  
<span class="udiff-line-added">+                 case VarargsLength:</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+ </span>
                  case LoadVarargs:
<span class="udiff-line-modified-removed">-                     if (node-&gt;loadVarargsData()-&gt;offset &amp;&amp; (node-&gt;child1()-&gt;op() == NewArrayWithSpread || node-&gt;child1()-&gt;op() == Spread || node-&gt;child1()-&gt;op() == NewArrayBuffer))</span>
<span class="udiff-line-modified-removed">-                         escape(node-&gt;child1(), node);</span>
<span class="udiff-line-modified-added">+                     if (node-&gt;loadVarargsData()-&gt;offset &amp;&amp; (node-&gt;argumentsChild()-&gt;op() == NewArrayWithSpread || node-&gt;argumentsChild()-&gt;op() == Spread || node-&gt;argumentsChild()-&gt;op() == NewArrayBuffer))</span>
<span class="udiff-line-modified-added">+                         escape(node-&gt;argumentsChild(), node);</span>
                      break;
  
                  case CallVarargs:
                  case ConstructVarargs:
                  case TailCallVarargs:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -398,16 +401,17 @@</span>
                      // that we exempt here also use the candidate directly. If there ever was a
                      // butterfly-using op that we wanted to exempt, then we&#39;d have to look at the
                      // butterfly&#39;s child and check if it&#39;s a candidate.
                      break;
  
<span class="udiff-line-modified-removed">-                 case FilterGetByIdStatus:</span>
<span class="udiff-line-modified-added">+                 case FilterGetByStatus:</span>
                  case FilterPutByIdStatus:
                  case FilterCallLinkStatus:
                  case FilterInByIdStatus:
                      break;
  
<span class="udiff-line-added">+                 case CheckArrayOrEmpty:</span>
                  case CheckArray:
                      escapeBasedOnArrayMode(node-&gt;arrayMode(), node-&gt;child1(), node);
                      break;
  
                  case CheckStructureOrEmpty:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -491,14 +495,14 @@</span>
                          if (heap.kind() != Stack) {
                              ASSERT(!heap.overlaps(Stack));
                              return;
                          }
                          ASSERT(!heap.payload().isTop());
<span class="udiff-line-modified-removed">-                         VirtualRegister reg(heap.payload().value32());</span>
<span class="udiff-line-modified-added">+                         Operand operand = heap.operand();</span>
                          // The register may not point to an argument or local, for example if we are looking at SetArgumentCountIncludingThis.
<span class="udiff-line-modified-removed">-                         if (!reg.isHeader())</span>
<span class="udiff-line-modified-removed">-                             clobberedByThisBlock.operand(reg) = true;</span>
<span class="udiff-line-modified-added">+                         if (!operand.isHeader())</span>
<span class="udiff-line-modified-added">+                             clobberedByThisBlock.operand(operand) = true;</span>
                      },
                      NoOpClobberize());
              }
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -558,20 +562,20 @@</span>
                          Operands&lt;bool&gt;&amp; clobberedByThisBlock = clobberedByBlock[block];
  
                          if (inlineCallFrame) {
                              if (inlineCallFrame-&gt;isVarargs()) {
                                  isClobberedByBlock |= clobberedByThisBlock.operand(
<span class="udiff-line-modified-removed">-                                     inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount);</span>
<span class="udiff-line-modified-added">+                                     VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCountIncludingThis));</span>
                              }
  
                              if (!isClobberedByBlock || inlineCallFrame-&gt;isClosureCall) {
                                  isClobberedByBlock |= clobberedByThisBlock.operand(
<span class="udiff-line-modified-removed">-                                     inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee);</span>
<span class="udiff-line-modified-added">+                                     VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee));</span>
                              }
  
                              if (!isClobberedByBlock) {
<span class="udiff-line-modified-removed">-                                 for (unsigned i = 0; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1; ++i) {</span>
<span class="udiff-line-modified-added">+                                 for (unsigned i = 0; i &lt; static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1); ++i) {</span>
                                      VirtualRegister reg =
                                          VirtualRegister(inlineCallFrame-&gt;stackOffset) +
                                          CallFrame::argumentOffset(i);
                                      if (clobberedByThisBlock.operand(reg)) {
                                          isClobberedByBlock = true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -625,11 +629,11 @@</span>
                              bool found = false;
                              clobberize(
                                  m_graph, node, NoOpClobberize(),
                                  [&amp;] (AbstractHeap heap) {
                                      if (heap.kind() == Stack &amp;&amp; !heap.payload().isTop()) {
<span class="udiff-line-modified-removed">-                                         if (argumentsInvolveStackSlot(inlineCallFrame, VirtualRegister(heap.payload().value32())))</span>
<span class="udiff-line-modified-added">+                                         if (argumentsInvolveStackSlot(inlineCallFrame, heap.operand()))</span>
                                              found = true;
                                          return;
                                      }
                                      if (heap.overlaps(Stack))
                                          found = true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -750,11 +754,11 @@</span>
                          break;
  
                      DFG_ASSERT(
                          m_graph, node, node-&gt;child1()-&gt;op() == PhantomDirectArguments, node-&gt;child1()-&gt;op());
                      VirtualRegister reg =
<span class="udiff-line-modified-removed">-                         virtualRegisterForArgument(node-&gt;capturedArgumentsOffset().offset() + 1) +</span>
<span class="udiff-line-modified-added">+                         virtualRegisterForArgumentIncludingThis(node-&gt;capturedArgumentsOffset().offset() + 1) +</span>
                          node-&gt;origin.semantic.stackOffset();
                      StackAccessData* data = m_graph.m_stackAccessData.add(reg, FlushedJSValue);
                      node-&gt;convertToGetStack(data);
                      break;
                  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -804,18 +808,18 @@</span>
                          InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
                          index += numberOfArgumentsToSkip;
  
                          bool safeToGetStack = index &gt;= numberOfArgumentsToSkip;
                          if (inlineCallFrame)
<span class="udiff-line-modified-removed">-                             safeToGetStack &amp;= index &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1;</span>
<span class="udiff-line-modified-added">+                             safeToGetStack &amp;= index &lt; static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1);</span>
                          else {
                              safeToGetStack &amp;=
                                  index &lt; static_cast&lt;unsigned&gt;(codeBlock()-&gt;numParameters()) - 1;
                          }
                          if (safeToGetStack) {
                              StackAccessData* data;
<span class="udiff-line-modified-removed">-                             VirtualRegister arg = virtualRegisterForArgument(index + 1);</span>
<span class="udiff-line-modified-added">+                             VirtualRegister arg = virtualRegisterForArgumentIncludingThis(index + 1);</span>
                              if (inlineCallFrame)
                                  arg += inlineCallFrame-&gt;stackOffset;
                              data = m_graph.m_stackAccessData.add(arg, FlushedJSValue);
  
                              Node* check = nullptr;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -844,12 +848,26 @@</span>
                      // Need to do this because we may have a data format conversion here.
                      node-&gt;convertToIdentityOn(result);
                      break;
                  }
  
<span class="udiff-line-added">+                 case VarargsLength: {</span>
<span class="udiff-line-added">+                     Node* candidate = node-&gt;argumentsChild().node();</span>
<span class="udiff-line-added">+                     if (!isEliminatedAllocation(candidate))</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     // VarargsLength can exit, so it better be exitOK.</span>
<span class="udiff-line-added">+                     DFG_ASSERT(m_graph, node, node-&gt;origin.exitOK);</span>
<span class="udiff-line-added">+                     NodeOrigin origin = node-&gt;origin.withExitOK(true);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     node-&gt;convertToIdentityOn(emitCodeToGetArgumentsArrayLength(insertionSet, candidate, nodeIndex, origin, /* addThis = */ true));</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
                  case LoadVarargs: {
<span class="udiff-line-modified-removed">-                     Node* candidate = node-&gt;child1().node();</span>
<span class="udiff-line-modified-added">+                     Node* candidate = node-&gt;argumentsChild().node();</span>
                      if (!isEliminatedAllocation(candidate))
                          break;
  
                      // LoadVarargs can exit, so it better be exitOK.
                      DFG_ASSERT(m_graph, node, node-&gt;origin.exitOK);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -860,30 +878,31 @@</span>
                          Node* argumentCountIncludingThisNode = insertionSet.insertConstant(
                              nodeIndex, node-&gt;origin.withExitOK(canExit),
                              jsNumber(argumentCountIncludingThis));
                          insertionSet.insertNode(
                              nodeIndex, SpecNone, KillStack, node-&gt;origin.takeValidExit(canExit),
<span class="udiff-line-modified-removed">-                             OpInfo(varargsData-&gt;count.offset()));</span>
<span class="udiff-line-modified-added">+                             OpInfo(varargsData-&gt;count));</span>
                          insertionSet.insertNode(
                              nodeIndex, SpecNone, MovHint, node-&gt;origin.takeValidExit(canExit),
<span class="udiff-line-modified-removed">-                             OpInfo(varargsData-&gt;count.offset()), Edge(argumentCountIncludingThisNode));</span>
<span class="udiff-line-modified-added">+                             OpInfo(varargsData-&gt;count), Edge(argumentCountIncludingThisNode));</span>
                          insertionSet.insertNode(
                              nodeIndex, SpecNone, PutStack, node-&gt;origin.withExitOK(canExit),
                              OpInfo(m_graph.m_stackAccessData.add(varargsData-&gt;count, FlushedInt32)),
                              Edge(argumentCountIncludingThisNode, KnownInt32Use));
                      };
  
                      auto storeValue = [&amp;] (Node* value, unsigned storeIndex) {
                          VirtualRegister reg = varargsData-&gt;start + storeIndex;
<span class="udiff-line-added">+                         ASSERT(reg.isLocal());</span>
                          StackAccessData* data =
                              m_graph.m_stackAccessData.add(reg, FlushedJSValue);
  
                          insertionSet.insertNode(
<span class="udiff-line-modified-removed">-                             nodeIndex, SpecNone, KillStack, node-&gt;origin.takeValidExit(canExit), OpInfo(reg.offset()));</span>
<span class="udiff-line-modified-added">+                             nodeIndex, SpecNone, KillStack, node-&gt;origin.takeValidExit(canExit), OpInfo(reg));</span>
                          insertionSet.insertNode(
                              nodeIndex, SpecNone, MovHint, node-&gt;origin.takeValidExit(canExit),
<span class="udiff-line-modified-removed">-                             OpInfo(reg.offset()), Edge(value));</span>
<span class="udiff-line-modified-added">+                             OpInfo(reg), Edge(value));</span>
                          insertionSet.insertNode(
                              nodeIndex, SpecNone, PutStack, node-&gt;origin.withExitOK(canExit),
                              OpInfo(data), Edge(value));
                      };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -933,11 +952,11 @@</span>
                                      return candidate-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
  
                                  ASSERT(candidate-&gt;op() == PhantomCreateRest);
                                  unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
                                  InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
<span class="udiff-line-modified-removed">-                                 unsigned frameArgumentCount = inlineCallFrame-&gt;argumentCountIncludingThis - 1;</span>
<span class="udiff-line-modified-added">+                                 unsigned frameArgumentCount = static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1);</span>
                                  if (frameArgumentCount &gt;= numberOfArgumentsToSkip)
                                      return frameArgumentCount - numberOfArgumentsToSkip;
                                  return 0;
                              });
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -981,13 +1000,13 @@</span>
                                      }
  
                                      ASSERT(candidate-&gt;op() == PhantomCreateRest);
                                      unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
                                      InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
<span class="udiff-line-modified-removed">-                                     unsigned frameArgumentCount = inlineCallFrame-&gt;argumentCountIncludingThis - 1;</span>
<span class="udiff-line-modified-added">+                                     unsigned frameArgumentCount = static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1);</span>
                                      for (unsigned loadIndex = numberOfArgumentsToSkip; loadIndex &lt; frameArgumentCount; ++loadIndex) {
<span class="udiff-line-modified-removed">-                                         VirtualRegister reg = virtualRegisterForArgument(loadIndex + 1) + inlineCallFrame-&gt;stackOffset;</span>
<span class="udiff-line-modified-added">+                                         VirtualRegister reg = virtualRegisterForArgumentIncludingThis(loadIndex + 1) + inlineCallFrame-&gt;stackOffset;</span>
                                          StackAccessData* data = m_graph.m_stackAccessData.add(reg, FlushedJSValue);
                                          Node* value = insertionSet.insertNode(
                                              nodeIndex, SpecNone, GetStack, node-&gt;origin.withExitOK(canExit),
                                              OpInfo(data));
                                          storeValue(value, storeIndex++);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1017,22 +1036,19 @@</span>
                              numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
                          varargsData-&gt;offset += numberOfArgumentsToSkip;
  
                          InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
  
<span class="udiff-line-modified-removed">-                         if (inlineCallFrame</span>
<span class="udiff-line-removed">-                             &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+                         if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {</span>
                              unsigned argumentCountIncludingThis = inlineCallFrame-&gt;argumentCountIncludingThis;
                              if (argumentCountIncludingThis &gt; varargsData-&gt;offset)
                                  argumentCountIncludingThis -= varargsData-&gt;offset;
                              else
                                  argumentCountIncludingThis = 1;
                              RELEASE_ASSERT(argumentCountIncludingThis &gt;= 1);
  
                              if (argumentCountIncludingThis &lt;= varargsData-&gt;limit) {
<span class="udiff-line-removed">- </span>
                                  storeArgumentCountIncludingThis(argumentCountIncludingThis);
  
                                  DFG_ASSERT(m_graph, node, varargsData-&gt;limit - 1 &gt;= varargsData-&gt;mandatoryMinimum, varargsData-&gt;limit, varargsData-&gt;mandatoryMinimum);
                                  // Define our limit to exclude &quot;this&quot;, since that&#39;s a bit easier to reason about.
                                  unsigned limit = varargsData-&gt;limit - 1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1043,11 +1059,11 @@</span>
  
                                      Node* value = nullptr;
                                      unsigned loadIndex = storeIndex + varargsData-&gt;offset;
  
                                      if (loadIndex + 1 &lt; inlineCallFrame-&gt;argumentCountIncludingThis) {
<span class="udiff-line-modified-removed">-                                         VirtualRegister reg = virtualRegisterForArgument(loadIndex + 1) + inlineCallFrame-&gt;stackOffset;</span>
<span class="udiff-line-modified-added">+                                         VirtualRegister reg = virtualRegisterForArgumentIncludingThis(loadIndex + 1) + inlineCallFrame-&gt;stackOffset;</span>
                                          StackAccessData* data = m_graph.m_stackAccessData.add(
                                              reg, FlushedJSValue);
  
                                          value = insertionSet.insertNode(
                                              nodeIndex, SpecNone, GetStack, node-&gt;origin.withExitOK(canExit),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1199,11 +1215,11 @@</span>
                                  ASSERT(candidate-&gt;op() == PhantomCreateRest);
                                  InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
                                  unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
                                  for (unsigned i = 1 + numberOfArgumentsToSkip; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
                                      StackAccessData* data = m_graph.m_stackAccessData.add(
<span class="udiff-line-modified-removed">-                                         virtualRegisterForArgument(i) + inlineCallFrame-&gt;stackOffset,</span>
<span class="udiff-line-modified-added">+                                         virtualRegisterForArgumentIncludingThis(i) + inlineCallFrame-&gt;stackOffset,</span>
                                          FlushedJSValue);
  
                                      Node* value = insertionSet.insertNode(
                                          nodeIndex, SpecNone, GetStack, node-&gt;origin, OpInfo(data));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1225,11 +1241,11 @@</span>
                          InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
                          if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
                              Vector&lt;Node*&gt; arguments;
                              for (unsigned i = 1 + varargsData-&gt;firstVarArgOffset; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
                                  StackAccessData* data = m_graph.m_stackAccessData.add(
<span class="udiff-line-modified-removed">-                                     virtualRegisterForArgument(i) + inlineCallFrame-&gt;stackOffset,</span>
<span class="udiff-line-modified-added">+                                     virtualRegisterForArgumentIncludingThis(i) + inlineCallFrame-&gt;stackOffset,</span>
                                      FlushedJSValue);
  
                                  Node* value = insertionSet.insertNode(
                                      nodeIndex, SpecNone, GetStack, node-&gt;origin, OpInfo(data));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1242,13 +1258,14 @@</span>
                      }
  
                      break;
                  }
  
<span class="udiff-line-added">+                 case CheckArrayOrEmpty:</span>
                  case CheckArray:
                  case GetButterfly:
<span class="udiff-line-modified-removed">-                 case FilterGetByIdStatus:</span>
<span class="udiff-line-modified-added">+                 case FilterGetByStatus:</span>
                  case FilterPutByIdStatus:
                  case FilterCallLinkStatus:
                  case FilterInByIdStatus: {
                      if (!isEliminatedAllocation(node-&gt;child1().node()))
                          break;
</pre>
<center><a href="DFGArgumentPosition.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGArgumentsUtilities.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
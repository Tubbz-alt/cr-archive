<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLDrawBuffers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013 Google Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 21  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 23  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(WEBGL)
 29 #include &quot;WebGLDrawBuffers.h&quot;
 30 
 31 #include &quot;ExtensionsGL.h&quot;
 32 
 33 namespace WebCore {
 34 
 35 WebGLDrawBuffers::WebGLDrawBuffers(WebGLRenderingContextBase&amp; context)
 36     : WebGLExtension(context)
 37 {
 38     context.graphicsContextGL()-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_draw_buffers&quot;);
 39 }
 40 
 41 WebGLDrawBuffers::~WebGLDrawBuffers() = default;
 42 
 43 WebGLExtension::ExtensionName WebGLDrawBuffers::getName() const
 44 {
 45     return WebGLExtension::WebGLDrawBuffersName;
 46 }
 47 
 48 bool WebGLDrawBuffers::supported(WebGLRenderingContextBase&amp; context)
 49 {
 50 #if USE(ANGLE)
 51     return context.graphicsContextGL()-&gt;getExtensions().supports(&quot;GL_EXT_draw_buffers&quot;);
 52 #else
 53     return context.graphicsContextGL()-&gt;getExtensions().supports(&quot;GL_EXT_draw_buffers&quot;)
 54         &amp;&amp; satisfiesWebGLRequirements(context);
 55 #endif
 56 }
 57 
 58 void WebGLDrawBuffers::drawBuffersWEBGL(const Vector&lt;GCGLenum&gt;&amp; buffers)
 59 {
 60     if (m_context.isContextLost())
 61         return;
 62     GCGLsizei n = buffers.size();
 63     const GCGLenum* bufs = buffers.data();
 64     if (!m_context.m_framebufferBinding) {
 65         if (n != 1) {
 66             m_context.synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;drawBuffersWEBGL&quot;, &quot;more than one buffer&quot;);
 67             return;
 68         }
 69         if (bufs[0] != GraphicsContextGL::BACK &amp;&amp; bufs[0] != GraphicsContextGL::NONE) {
 70             m_context.synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawBuffersWEBGL&quot;, &quot;BACK or NONE&quot;);
 71             return;
 72         }
 73         // Because the backbuffer is simulated on all current WebKit ports, we need to change BACK to COLOR_ATTACHMENT0.
 74         GCGLenum value = (bufs[0] == GraphicsContextGL::BACK) ? GraphicsContextGL::COLOR_ATTACHMENT0 : GraphicsContextGL::NONE;
 75         m_context.graphicsContextGL()-&gt;getExtensions().drawBuffersEXT(1, &amp;value);
 76         m_context.setBackDrawBuffer(bufs[0]);
 77     } else {
 78         if (n &gt; m_context.getMaxDrawBuffers()) {
 79             m_context.synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;drawBuffersWEBGL&quot;, &quot;more than max draw buffers&quot;);
 80             return;
 81         }
 82         for (GCGLsizei i = 0; i &lt; n; ++i) {
 83             if (bufs[i] != GraphicsContextGL::NONE &amp;&amp; bufs[i] != static_cast&lt;GCGLenum&gt;(ExtensionsGL::COLOR_ATTACHMENT0_EXT + i)) {
 84                 m_context.synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawBuffersWEBGL&quot;, &quot;COLOR_ATTACHMENTi_EXT or NONE&quot;);
 85                 return;
 86             }
 87         }
 88         m_context.m_framebufferBinding-&gt;drawBuffers(buffers);
 89     }
 90 }
 91 
 92 // static
 93 bool WebGLDrawBuffers::satisfiesWebGLRequirements(WebGLRenderingContextBase&amp; webglContext)
 94 {
 95     GraphicsContextGLOpenGL* context = webglContext.graphicsContextGL();
 96 
 97     // This is called after we make sure GL_EXT_draw_buffers is supported.
 98     GCGLint maxDrawBuffers = 0;
 99     GCGLint maxColorAttachments = 0;
100     context-&gt;getIntegerv(ExtensionsGL::MAX_DRAW_BUFFERS_EXT, &amp;maxDrawBuffers);
101     context-&gt;getIntegerv(ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT, &amp;maxColorAttachments);
102     if (maxDrawBuffers &lt; 4 || maxColorAttachments &lt; 4)
103         return false;
104 
105     PlatformGLObject fbo = context-&gt;createFramebuffer();
106     context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, fbo);
107 
108     const unsigned char buffer[4] = { 0, 0, 0, 0 }; // textures are required to be initialized for other ports.
109     bool supportsDepth = context-&gt;getExtensions().supports(&quot;GL_OES_depth_texture&quot;)
110         || context-&gt;getExtensions().supports(&quot;GL_ARB_depth_texture&quot;);
111     bool supportsDepthStencil = (context-&gt;getExtensions().supports(&quot;GL_EXT_packed_depth_stencil&quot;)
112         || context-&gt;getExtensions().supports(&quot;GL_OES_packed_depth_stencil&quot;));
113     PlatformGLObject depthStencil = 0;
114     if (supportsDepthStencil) {
115         depthStencil = context-&gt;createTexture();
116         context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, depthStencil);
117         context-&gt;texImage2D(GraphicsContextGL::TEXTURE_2D, 0, GraphicsContextGL::DEPTH_STENCIL, 1, 1, 0, GraphicsContextGL::DEPTH_STENCIL, GraphicsContextGL::UNSIGNED_INT_24_8, buffer);
118     }
119     PlatformGLObject depth = 0;
120     if (supportsDepth) {
121         depth = context-&gt;createTexture();
122         context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, depth);
123         context-&gt;texImage2D(GraphicsContextGL::TEXTURE_2D, 0, GraphicsContextGL::DEPTH_COMPONENT, 1, 1, 0, GraphicsContextGL::DEPTH_COMPONENT, GraphicsContextGL::UNSIGNED_INT, buffer);
124     }
125 
126     Vector&lt;PlatformGLObject&gt; colors;
127     bool ok = true;
128     GCGLint maxAllowedBuffers = std::min(maxDrawBuffers, maxColorAttachments);
129     for (GCGLint i = 0; i &lt; maxAllowedBuffers; ++i) {
130         PlatformGLObject color = context-&gt;createTexture();
131         colors.append(color);
132         context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, color);
133         context-&gt;texImage2D(GraphicsContextGL::TEXTURE_2D, 0, GraphicsContextGL::RGBA, 1, 1, 0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, buffer);
134         context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::COLOR_ATTACHMENT0 + i, GraphicsContextGL::TEXTURE_2D, color, 0);
135         if (context-&gt;checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER) != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {
136             ok = false;
137             break;
138         }
139         if (supportsDepth) {
140             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, depth, 0);
141             if (context-&gt;checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER) != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {
142                 ok = false;
143                 break;
144             }
145             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, 0, 0);
146         }
147         if (supportsDepthStencil) {
148             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, depthStencil, 0);
149             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::STENCIL_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, depthStencil, 0);
150             if (context-&gt;checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER) != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {
151                 ok = false;
152                 break;
153             }
154             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, 0, 0);
155             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::STENCIL_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, 0, 0);
156         }
157     }
158 
159     webglContext.restoreCurrentFramebuffer();
160     context-&gt;deleteFramebuffer(fbo);
161     webglContext.restoreCurrentTexture2D();
162     if (supportsDepth)
163         context-&gt;deleteTexture(depth);
164     if (supportsDepthStencil)
165         context-&gt;deleteTexture(depthStencil);
166     for (auto&amp; color : colors)
167         context-&gt;deleteTexture(color);
168     return ok;
169 }
170 
171 } // namespace WebCore
172 
173 #endif // ENABLE(WEBGL)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/xml/XPathFunctions.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="XPathExpression.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="XPathGrammar.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/xml/XPathFunctions.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
287 
288     // Functions that use the context node as an implicit argument are context node sensitive when they
289     // have no arguments, but when explicit arguments are added, they are no longer context node sensitive.
290     // As of this writing, the only exception to this is the &quot;lang&quot; function.
291     if (name != &quot;lang&quot; &amp;&amp; !arguments.isEmpty())
292         setIsContextNodeSensitive(false);
293 
294     setSubexpressions(WTFMove(arguments));
295 }
296 
297 Value FunLast::evaluate() const
298 {
299     return Expression::evaluationContext().size;
300 }
301 
302 Value FunPosition::evaluate() const
303 {
304     return Expression::evaluationContext().position;
305 }
306 
<span class="line-modified">307 static AtomString atomicSubstring(StringBuilder&amp; builder, unsigned start, unsigned length)</span>

308 {
<span class="line-removed">309     ASSERT(start &lt;= builder.length());</span>
<span class="line-removed">310     ASSERT(length &lt;= builder.length() - start);</span>
311     if (builder.is8Bit())
<span class="line-modified">312         return AtomString(builder.characters8() + start, length);</span>
<span class="line-modified">313     return AtomString(builder.characters16() + start, length);</span>
314 }
315 
316 Value FunId::evaluate() const
317 {
318     Value a = argument(0).evaluate();
319     StringBuilder idList; // A whitespace-separated list of IDs
320 
321     if (!a.isNodeSet())
322         idList.append(a.toString());
323     else {
324         for (auto&amp; node : a.toNodeSet()) {
325             idList.append(stringValue(node.get()));
326             idList.append(&#39; &#39;);
327         }
328     }
329 
330     TreeScope&amp; contextScope = evaluationContext().node-&gt;treeScope();
331     NodeSet result;
332     HashSet&lt;Node*&gt; resultSet;
333 
334     unsigned startPos = 0;
335     unsigned length = idList.length();
336     while (true) {
337         while (startPos &lt; length &amp;&amp; isWhitespace(idList[startPos]))
338             ++startPos;
339 
340         if (startPos == length)
341             break;
342 
343         size_t endPos = startPos;
344         while (endPos &lt; length &amp;&amp; !isWhitespace(idList[endPos]))
345             ++endPos;
346 
347         // If there are several nodes with the same id, id() should return the first one.
348         // In WebKit, getElementById behaves so, too, although its behavior in this case is formally undefined.
<span class="line-modified">349         Node* node = contextScope.getElementById(atomicSubstring(idList, startPos, endPos - startPos));</span>
350         if (node &amp;&amp; resultSet.add(node).isNewEntry)
351             result.append(node);
352 
353         startPos = endPos;
354     }
355 
356     result.markSorted(false);
357 
358     return Value(WTFMove(result));
359 }
360 
361 static inline String expandedNameLocalPart(Node* node)
362 {
363     if (is&lt;ProcessingInstruction&gt;(*node))
364         return downcast&lt;ProcessingInstruction&gt;(*node).target();
365     return node-&gt;localName().string();
366 }
367 
368 static inline String expandedName(Node* node)
369 {
</pre>
</td>
<td>
<hr />
<pre>
287 
288     // Functions that use the context node as an implicit argument are context node sensitive when they
289     // have no arguments, but when explicit arguments are added, they are no longer context node sensitive.
290     // As of this writing, the only exception to this is the &quot;lang&quot; function.
291     if (name != &quot;lang&quot; &amp;&amp; !arguments.isEmpty())
292         setIsContextNodeSensitive(false);
293 
294     setSubexpressions(WTFMove(arguments));
295 }
296 
297 Value FunLast::evaluate() const
298 {
299     return Expression::evaluationContext().size;
300 }
301 
302 Value FunPosition::evaluate() const
303 {
304     return Expression::evaluationContext().position;
305 }
306 
<span class="line-modified">307 // FIXME: Should StringBuilder offer this as a member function?</span>
<span class="line-added">308 static StringView toStringView(StringBuilder&amp; builder)</span>
309 {


310     if (builder.is8Bit())
<span class="line-modified">311         return { builder.characters8(), builder.length() };</span>
<span class="line-modified">312     return { builder.characters16(), builder.length() };</span>
313 }
314 
315 Value FunId::evaluate() const
316 {
317     Value a = argument(0).evaluate();
318     StringBuilder idList; // A whitespace-separated list of IDs
319 
320     if (!a.isNodeSet())
321         idList.append(a.toString());
322     else {
323         for (auto&amp; node : a.toNodeSet()) {
324             idList.append(stringValue(node.get()));
325             idList.append(&#39; &#39;);
326         }
327     }
328 
329     TreeScope&amp; contextScope = evaluationContext().node-&gt;treeScope();
330     NodeSet result;
331     HashSet&lt;Node*&gt; resultSet;
332 
333     unsigned startPos = 0;
334     unsigned length = idList.length();
335     while (true) {
336         while (startPos &lt; length &amp;&amp; isWhitespace(idList[startPos]))
337             ++startPos;
338 
339         if (startPos == length)
340             break;
341 
342         size_t endPos = startPos;
343         while (endPos &lt; length &amp;&amp; !isWhitespace(idList[endPos]))
344             ++endPos;
345 
346         // If there are several nodes with the same id, id() should return the first one.
347         // In WebKit, getElementById behaves so, too, although its behavior in this case is formally undefined.
<span class="line-modified">348         Node* node = contextScope.getElementById(toStringView(idList).substring(startPos, endPos - startPos));</span>
349         if (node &amp;&amp; resultSet.add(node).isNewEntry)
350             result.append(node);
351 
352         startPos = endPos;
353     }
354 
355     result.markSorted(false);
356 
357     return Value(WTFMove(result));
358 }
359 
360 static inline String expandedNameLocalPart(Node* node)
361 {
362     if (is&lt;ProcessingInstruction&gt;(*node))
363         return downcast&lt;ProcessingInstruction&gt;(*node).target();
364     return node-&gt;localName().string();
365 }
366 
367 static inline String expandedName(Node* node)
368 {
</pre>
</td>
</tr>
</table>
<center><a href="XPathExpression.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="XPathGrammar.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
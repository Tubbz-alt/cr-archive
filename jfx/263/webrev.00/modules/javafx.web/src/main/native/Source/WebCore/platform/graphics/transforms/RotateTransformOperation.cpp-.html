<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/transforms/RotateTransformOperation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Antti Koivisto (koivisto@kde.org)
  3  * Copyright (C) 2004, 2005, 2006, 2007, 2008 Apple Inc. All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;RotateTransformOperation.h&quot;
 24 
 25 #include &quot;AnimationUtilities.h&quot;
 26 #include &lt;algorithm&gt;
 27 #include &lt;wtf/MathExtras.h&gt;
 28 #include &lt;wtf/text/TextStream.h&gt;
 29 
 30 namespace WebCore {
 31 
 32 bool RotateTransformOperation::operator==(const TransformOperation&amp; other) const
 33 {
 34     if (!isSameType(other))
 35         return false;
 36     const RotateTransformOperation&amp; r = downcast&lt;RotateTransformOperation&gt;(other);
 37     return m_x == r.m_x &amp;&amp; m_y == r.m_y &amp;&amp; m_z == r.m_z &amp;&amp; m_angle == r.m_angle;
 38 }
 39 
 40 Ref&lt;TransformOperation&gt; RotateTransformOperation::blend(const TransformOperation* from, double progress, bool blendToIdentity)
 41 {
 42     if (from &amp;&amp; !from-&gt;isSameType(*this))
 43         return *this;
 44 
 45     if (blendToIdentity)
 46         return RotateTransformOperation::create(m_x, m_y, m_z, m_angle - m_angle * progress, type());
 47 
 48     const RotateTransformOperation* fromOp = downcast&lt;RotateTransformOperation&gt;(from);
 49 
 50     // Optimize for single axis rotation
 51     if (!fromOp || (fromOp-&gt;m_x == 0 &amp;&amp; fromOp-&gt;m_y == 0 &amp;&amp; fromOp-&gt;m_z == 1) ||
 52                    (fromOp-&gt;m_x == 0 &amp;&amp; fromOp-&gt;m_y == 1 &amp;&amp; fromOp-&gt;m_z == 0) ||
 53                    (fromOp-&gt;m_x == 1 &amp;&amp; fromOp-&gt;m_y == 0 &amp;&amp; fromOp-&gt;m_z == 0)) {
 54         double fromAngle = fromOp ? fromOp-&gt;m_angle : 0;
 55         return RotateTransformOperation::create(fromOp ? fromOp-&gt;m_x : m_x,
 56                                                 fromOp ? fromOp-&gt;m_y : m_y,
 57                                                 fromOp ? fromOp-&gt;m_z : m_z,
 58                                                 WebCore::blend(fromAngle, m_angle, progress), type());
 59     }
 60 
 61     const RotateTransformOperation* toOp = this;
 62 
 63     // Create the 2 rotation matrices
 64     TransformationMatrix fromT;
 65     TransformationMatrix toT;
 66     fromT.rotate3d((fromOp ? fromOp-&gt;m_x : 0),
 67         (fromOp ? fromOp-&gt;m_y : 0),
 68         (fromOp ? fromOp-&gt;m_z : 1),
 69         (fromOp ? fromOp-&gt;m_angle : 0));
 70 
 71     toT.rotate3d((toOp ? toOp-&gt;m_x : 0),
 72         (toOp ? toOp-&gt;m_y : 0),
 73         (toOp ? toOp-&gt;m_z : 1),
 74         (toOp ? toOp-&gt;m_angle : 0));
 75 
 76     // Blend them
 77     toT.blend(fromT, progress);
 78 
 79     // Extract the result as a quaternion
 80     TransformationMatrix::Decomposed4Type decomp;
 81     toT.decompose4(decomp);
 82 
 83     // Convert that to Axis/Angle form
 84     double x = -decomp.quaternionX;
 85     double y = -decomp.quaternionY;
 86     double z = -decomp.quaternionZ;
 87     double length = sqrt(x * x + y * y + z * z);
 88     double angle = 0;
 89 
 90     if (length &gt; 0.00001) {
 91         x /= length;
 92         y /= length;
 93         z /= length;
 94         angle = rad2deg(acos(decomp.quaternionW) * 2);
 95     } else {
 96         x = 0;
 97         y = 0;
 98         z = 1;
 99     }
100     return RotateTransformOperation::create(x, y, z, angle, ROTATE_3D);
101 }
102 
103 void RotateTransformOperation::dump(TextStream&amp; ts) const
104 {
105     ts &lt;&lt; type() &lt;&lt; &quot;(&quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_x) &lt;&lt; &quot;, &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_y) &lt;&lt; &quot;, &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_z) &lt;&lt; &quot;, &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_angle) &lt;&lt; &quot;deg)&quot;;
106 }
107 
108 } // namespace WebCore
    </pre>
  </body>
</html>
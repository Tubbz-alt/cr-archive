<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderGrid.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderGeometryMap.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderGrid.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderGrid.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 217,11 ***</span>
                  m_trackSizingAlgorithm.cacheBaselineAlignedItem(*child, GridColumnAxis);
              if (isBaselineAlignmentForChild(*child, GridRowAxis))
                  m_trackSizingAlgorithm.cacheBaselineAlignedItem(*child, GridRowAxis);
          }
          m_baselineItemsCached = true;
<span class="line-modified">!         setLogicalHeight(0);</span>
          updateLogicalWidth();
  
          // Fieldsets need to find their legend and position it inside the border of the object.
          // The legend then gets skipped during normal layout. The same is true for ruby text.
          // It doesn&#39;t get included in the normal layout process but is instead skipped.
<span class="line-new-header">--- 217,11 ---</span>
                  m_trackSizingAlgorithm.cacheBaselineAlignedItem(*child, GridColumnAxis);
              if (isBaselineAlignmentForChild(*child, GridRowAxis))
                  m_trackSizingAlgorithm.cacheBaselineAlignedItem(*child, GridRowAxis);
          }
          m_baselineItemsCached = true;
<span class="line-modified">!         resetLogicalHeightBeforeLayoutIfNeeded();</span>
          updateLogicalWidth();
  
          // Fieldsets need to find their legend and position it inside the border of the object.
          // The legend then gets skipped during normal layout. The same is true for ruby text.
          // It doesn&#39;t get included in the normal layout process but is instead skipped.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 631,11 ***</span>
              continue;
          }
          grid.insert(*child, { area.rows, area.columns });
      }
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      if (grid.hasGridItems()) {
          ASSERT(grid.numTracks(ForRows) &gt;= GridPositionsResolver::explicitGridRowCount(style(), grid.autoRepeatTracks(ForRows)));
          ASSERT(grid.numTracks(ForColumns) &gt;= GridPositionsResolver::explicitGridColumnCount(style(), grid.autoRepeatTracks(ForColumns)));
      }
  #endif
<span class="line-new-header">--- 631,11 ---</span>
              continue;
          }
          grid.insert(*child, { area.rows, area.columns });
      }
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      if (grid.hasGridItems()) {
          ASSERT(grid.numTracks(ForRows) &gt;= GridPositionsResolver::explicitGridRowCount(style(), grid.autoRepeatTracks(ForRows)));
          ASSERT(grid.numTracks(ForColumns) &gt;= GridPositionsResolver::explicitGridColumnCount(style(), grid.autoRepeatTracks(ForColumns)));
      }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 647,11 ***</span>
      grid.setAutoRepeatEmptyColumns(computeEmptyTracksForAutoRepeat(grid, ForColumns));
      grid.setAutoRepeatEmptyRows(computeEmptyTracksForAutoRepeat(grid, ForRows));
  
      grid.setNeedsItemsPlacement(false);
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      for (auto* child = grid.orderIterator().first(); child; child = grid.orderIterator().next()) {
          if (grid.orderIterator().shouldSkipChild(*child))
              continue;
  
          GridArea area = grid.gridItemArea(*child);
<span class="line-new-header">--- 647,11 ---</span>
      grid.setAutoRepeatEmptyColumns(computeEmptyTracksForAutoRepeat(grid, ForColumns));
      grid.setAutoRepeatEmptyRows(computeEmptyTracksForAutoRepeat(grid, ForRows));
  
      grid.setNeedsItemsPlacement(false);
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      for (auto* child = grid.orderIterator().first(); child; child = grid.orderIterator().next()) {
          if (grid.orderIterator().shouldSkipChild(*child))
              continue;
  
          GridArea area = grid.gridItemArea(*child);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 864,29 ***</span>
          return tracks;
  
      ASSERT(!m_grid.needsItemsPlacement());
      bool hasCollapsedTracks = m_grid.hasAutoRepeatEmptyTracks(direction);
      LayoutUnit gap = !hasCollapsedTracks ? gridGap(direction) : 0_lu;
<span class="line-modified">!     tracks.reserveCapacity(numPositions - 1);</span>
<span class="line-modified">!     for (size_t i = 0; i &lt; numPositions - 2; ++i)</span>
          tracks.append(positions[i + 1] - positions[i] - offsetBetweenTracks - gap);
<span class="line-modified">!     tracks.append(positions[numPositions - 1] - positions[numPositions - 2]);</span>
  
      if (!hasCollapsedTracks)
          return tracks;
  
      size_t remainingEmptyTracks = m_grid.autoRepeatEmptyTracks(direction)-&gt;size();
      size_t lastLine = tracks.size();
      gap = gridGap(direction);
      for (size_t i = 1; i &lt; lastLine; ++i) {
<span class="line-modified">!         if (m_grid.isEmptyAutoRepeatTrack(direction, i - 1))</span>
              --remainingEmptyTracks;
          else {
              // Remove the gap between consecutive non empty tracks. Remove it also just once for an
              // arbitrary number of empty tracks between two non empty ones.
              bool allRemainingTracksAreEmpty = remainingEmptyTracks == (lastLine - i);
<span class="line-modified">!             if (!allRemainingTracksAreEmpty || !m_grid.isEmptyAutoRepeatTrack(direction, i))</span>
                  tracks[i - 1] -= gap;
          }
      }
  
      return tracks;
<span class="line-new-header">--- 864,35 ---</span>
          return tracks;
  
      ASSERT(!m_grid.needsItemsPlacement());
      bool hasCollapsedTracks = m_grid.hasAutoRepeatEmptyTracks(direction);
      LayoutUnit gap = !hasCollapsedTracks ? gridGap(direction) : 0_lu;
<span class="line-modified">!     size_t explicitStart = -m_grid.smallestTrackStart(direction);</span>
<span class="line-modified">!     size_t explicitEnd = explicitStart + (isRowAxis ? style().gridColumns() : style().gridRows()).size() + autoRepeatCountForDirection(direction);</span>
<span class="line-added">+     // Usually we have `explicitEnd &lt;= numPositions - 1`, but the latter may be smaller when the maximum number of tracks is reached.</span>
<span class="line-added">+     explicitEnd = std::min(explicitEnd, numPositions - 1);</span>
<span class="line-added">+     tracks.reserveCapacity(explicitEnd - explicitStart);</span>
<span class="line-added">+     size_t loopEnd = std::min(explicitEnd, numPositions - 2);</span>
<span class="line-added">+     for (size_t i = explicitStart; i &lt; loopEnd; ++i)</span>
          tracks.append(positions[i + 1] - positions[i] - offsetBetweenTracks - gap);
<span class="line-modified">!     if (loopEnd &lt; explicitEnd)</span>
<span class="line-added">+         tracks.append(positions[explicitEnd] - positions[explicitEnd - 1]);</span>
  
      if (!hasCollapsedTracks)
          return tracks;
  
      size_t remainingEmptyTracks = m_grid.autoRepeatEmptyTracks(direction)-&gt;size();
      size_t lastLine = tracks.size();
      gap = gridGap(direction);
      for (size_t i = 1; i &lt; lastLine; ++i) {
<span class="line-modified">!         if (m_grid.isEmptyAutoRepeatTrack(direction, i - 1 + explicitStart))</span>
              --remainingEmptyTracks;
          else {
              // Remove the gap between consecutive non empty tracks. Remove it also just once for an
              // arbitrary number of empty tracks between two non empty ones.
              bool allRemainingTracksAreEmpty = remainingEmptyTracks == (lastLine - i);
<span class="line-modified">!             if (!allRemainingTracksAreEmpty || !m_grid.isEmptyAutoRepeatTrack(direction, i + explicitStart))</span>
                  tracks[i - 1] -= gap;
          }
      }
  
      return tracks;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1226,15 ***</span>
  }
  
  // FIXME: This logic is shared by RenderFlexibleBox, so it might be refactored somehow.
  int RenderGrid::baselinePosition(FontBaseline, bool, LineDirectionMode direction, LinePositionMode mode) const
  {
<span class="line-modified">! #if !ASSERT_DISABLED</span>
<span class="line-removed">-     ASSERT(mode == PositionOnContainingLine);</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     UNUSED_PARAM(mode);</span>
<span class="line-removed">- #endif</span>
      auto baseline = firstLineBaseline();
      if (!baseline)
          return synthesizedBaselineFromBorderBox(*this, direction) + marginLogicalHeight();
  
      return baseline.value() + (direction == HorizontalLine ? marginTop() : marginRight()).toInt();
<span class="line-new-header">--- 1232,11 ---</span>
  }
  
  // FIXME: This logic is shared by RenderFlexibleBox, so it might be refactored somehow.
  int RenderGrid::baselinePosition(FontBaseline, bool, LineDirectionMode direction, LinePositionMode mode) const
  {
<span class="line-modified">!     ASSERT_UNUSED(mode, mode == PositionOnContainingLine);</span>
      auto baseline = firstLineBaseline();
      if (!baseline)
          return synthesizedBaselineFromBorderBox(*this, direction) + marginLogicalHeight();
  
      return baseline.value() + (direction == HorizontalLine ? marginTop() : marginRight()).toInt();
</pre>
<center><a href="RenderGeometryMap.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderGrid.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
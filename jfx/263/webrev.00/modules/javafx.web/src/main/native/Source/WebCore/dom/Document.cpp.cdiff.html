<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Document.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DeviceOrientationOrMotionEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Document.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Document.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,11 ***</span>
  
  #include &quot;config.h&quot;
  #include &quot;Document.h&quot;
  
  #include &quot;AXObjectCache.h&quot;
<span class="line-removed">- #include &quot;ApplicationStateChangeListener.h&quot;</span>
  #include &quot;Attr.h&quot;
  #include &quot;BeforeUnloadEvent.h&quot;
  #include &quot;CDATASection.h&quot;
  #include &quot;CSSAnimationController.h&quot;
  #include &quot;CSSFontSelector.h&quot;
<span class="line-new-header">--- 27,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 56,15 ***</span>
<span class="line-new-header">--- 55,17 ---</span>
  #include &quot;CustomHeaderFields.h&quot;
  #include &quot;DOMImplementation.h&quot;
  #include &quot;DOMWindow.h&quot;
  #include &quot;DateComponents.h&quot;
  #include &quot;DebugPageOverlays.h&quot;
<span class="line-added">+ #include &quot;DeprecatedGlobalSettings.h&quot;</span>
  #include &quot;DocumentLoader.h&quot;
  #include &quot;DocumentMarkerController.h&quot;
  #include &quot;DocumentSharedObjectPool.h&quot;
  #include &quot;DocumentTimeline.h&quot;
  #include &quot;DocumentType.h&quot;
<span class="line-added">+ #include &quot;DragEvent.h&quot;</span>
  #include &quot;Editing.h&quot;
  #include &quot;Editor.h&quot;
  #include &quot;ElementIterator.h&quot;
  #include &quot;EventHandler.h&quot;
  #include &quot;ExtensionStyleSheets.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 75,10 ***</span>
<span class="line-new-header">--- 76,11 ---</span>
  #include &quot;Frame.h&quot;
  #include &quot;FrameLoader.h&quot;
  #include &quot;FrameLoaderClient.h&quot;
  #include &quot;FrameView.h&quot;
  #include &quot;FullscreenManager.h&quot;
<span class="line-added">+ #include &quot;GCReachableRef.h&quot;</span>
  #include &quot;GenericCachedHTMLCollection.h&quot;
  #include &quot;HTMLAllCollection.h&quot;
  #include &quot;HTMLAnchorElement.h&quot;
  #include &quot;HTMLAttachmentElement.h&quot;
  #include &quot;HTMLBaseElement.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 104,31 ***</span>
  #include &quot;HTMLTitleElement.h&quot;
  #include &quot;HTMLUnknownElement.h&quot;
  #include &quot;HTTPHeaderNames.h&quot;
  #include &quot;HTTPParsers.h&quot;
  #include &quot;HashChangeEvent.h&quot;
  #include &quot;History.h&quot;
  #include &quot;HitTestResult.h&quot;
  #include &quot;ImageBitmapRenderingContext.h&quot;
  #include &quot;ImageLoader.h&quot;
  #include &quot;InspectorInstrumentation.h&quot;
  #include &quot;IntersectionObserver.h&quot;
  #include &quot;JSCustomElementInterface.h&quot;
  #include &quot;JSLazyEventListener.h&quot;
  #include &quot;KeyboardEvent.h&quot;
  #include &quot;KeyframeEffect.h&quot;
  #include &quot;LayoutDisallowedScope.h&quot;
  #include &quot;LibWebRTCProvider.h&quot;
  #include &quot;LoaderStrategy.h&quot;
  #include &quot;Logging.h&quot;
  #include &quot;MediaCanStartListener.h&quot;
  #include &quot;MediaProducer.h&quot;
  #include &quot;MediaQueryList.h&quot;
  #include &quot;MediaQueryMatcher.h&quot;
  #include &quot;MediaStream.h&quot;
  #include &quot;MessageEvent.h&quot;
<span class="line-removed">- #include &quot;Microtasks.h&quot;</span>
  #include &quot;MouseEventWithHitTestResults.h&quot;
  #include &quot;MutationEvent.h&quot;
  #include &quot;NameNodeList.h&quot;
  #include &quot;NavigationDisabler.h&quot;
  #include &quot;NavigationScheduler.h&quot;
<span class="line-new-header">--- 106,33 ---</span>
  #include &quot;HTMLTitleElement.h&quot;
  #include &quot;HTMLUnknownElement.h&quot;
  #include &quot;HTTPHeaderNames.h&quot;
  #include &quot;HTTPParsers.h&quot;
  #include &quot;HashChangeEvent.h&quot;
<span class="line-added">+ #include &quot;HighlightMap.h&quot;</span>
  #include &quot;History.h&quot;
  #include &quot;HitTestResult.h&quot;
<span class="line-added">+ #include &quot;IdleCallbackController.h&quot;</span>
  #include &quot;ImageBitmapRenderingContext.h&quot;
  #include &quot;ImageLoader.h&quot;
  #include &quot;InspectorInstrumentation.h&quot;
  #include &quot;IntersectionObserver.h&quot;
  #include &quot;JSCustomElementInterface.h&quot;
  #include &quot;JSLazyEventListener.h&quot;
  #include &quot;KeyboardEvent.h&quot;
  #include &quot;KeyframeEffect.h&quot;
  #include &quot;LayoutDisallowedScope.h&quot;
<span class="line-added">+ #include &quot;LegacySchemeRegistry.h&quot;</span>
  #include &quot;LibWebRTCProvider.h&quot;
  #include &quot;LoaderStrategy.h&quot;
  #include &quot;Logging.h&quot;
  #include &quot;MediaCanStartListener.h&quot;
  #include &quot;MediaProducer.h&quot;
  #include &quot;MediaQueryList.h&quot;
  #include &quot;MediaQueryMatcher.h&quot;
  #include &quot;MediaStream.h&quot;
  #include &quot;MessageEvent.h&quot;
  #include &quot;MouseEventWithHitTestResults.h&quot;
  #include &quot;MutationEvent.h&quot;
  #include &quot;NameNodeList.h&quot;
  #include &quot;NavigationDisabler.h&quot;
  #include &quot;NavigationScheduler.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 173,11 ***</span>
  #include &quot;SVGSVGElement.h&quot;
  #include &quot;SVGTitleElement.h&quot;
  #include &quot;SVGUseElement.h&quot;
  #include &quot;SVGZoomEvent.h&quot;
  #include &quot;SWClientConnection.h&quot;
<span class="line-removed">- #include &quot;SchemeRegistry.h&quot;</span>
  #include &quot;ScopedEventQueue.h&quot;
  #include &quot;ScriptController.h&quot;
  #include &quot;ScriptDisallowedScope.h&quot;
  #include &quot;ScriptModuleLoader.h&quot;
  #include &quot;ScriptRunner.h&quot;
<span class="line-new-header">--- 177,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 191,10 ***</span>
<span class="line-new-header">--- 194,11 ---</span>
  #include &quot;SecurityOriginPolicy.h&quot;
  #include &quot;SecurityPolicy.h&quot;
  #include &quot;SegmentedString.h&quot;
  #include &quot;SelectorQuery.h&quot;
  #include &quot;ServiceWorkerClientData.h&quot;
<span class="line-added">+ #include &quot;ServiceWorkerContainer.h&quot;</span>
  #include &quot;ServiceWorkerProvider.h&quot;
  #include &quot;Settings.h&quot;
  #include &quot;ShadowRoot.h&quot;
  #include &quot;SocketProvider.h&quot;
  #include &quot;StorageEvent.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 208,21 ***</span>
<span class="line-new-header">--- 212,24 ---</span>
  #include &quot;StyleSheetList.h&quot;
  #include &quot;StyleTreeResolver.h&quot;
  #include &quot;SubresourceLoader.h&quot;
  #include &quot;TextAutoSizing.h&quot;
  #include &quot;TextEvent.h&quot;
<span class="line-added">+ #include &quot;TextManipulationController.h&quot;</span>
  #include &quot;TextNodeTraversal.h&quot;
  #include &quot;TouchAction.h&quot;
  #include &quot;TransformSource.h&quot;
  #include &quot;TreeWalker.h&quot;
  #include &quot;UndoManager.h&quot;
  #include &quot;UserGestureIndicator.h&quot;
  #include &quot;ValidationMessageClient.h&quot;
  #include &quot;VisibilityChangeClient.h&quot;
  #include &quot;VisitedLinkState.h&quot;
<span class="line-added">+ #include &quot;VisualViewport.h&quot;</span>
  #include &quot;WebAnimation.h&quot;
  #include &quot;WheelEvent.h&quot;
<span class="line-added">+ #include &quot;WindowEventLoop.h&quot;</span>
  #include &quot;WindowFeatures.h&quot;
  #include &quot;Worklet.h&quot;
  #include &quot;XMLDocument.h&quot;
  #include &quot;XMLDocumentParser.h&quot;
  #include &quot;XMLNSNames.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 323,10 ***</span>
<span class="line-new-header">--- 330,14 ---</span>
  
  #if ENABLE(POINTER_EVENTS)
  #include &quot;PointerCaptureController.h&quot;
  #endif
  
<span class="line-added">+ #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">+ #include &quot;HTMLVideoElement.h&quot;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(Document);
  
  using namespace HTMLNames;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 355,10 ***</span>
<span class="line-new-header">--- 366,18 ---</span>
  private:
      FrameView&amp; m_frameView;
      bool m_disallowLayout { false };
  };
  
<span class="line-added">+ // Defined here to avoid including GCReachableRef.h in Document.h</span>
<span class="line-added">+ struct Document::PendingScrollEventTargetList {</span>
<span class="line-added">+     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+     Vector&lt;GCReachableRef&lt;ContainerNode&gt;&gt; targets;</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  #if ENABLE(INTERSECTION_OBSERVER)
  static const Seconds intersectionObserversInitialUpdateDelay { 2000_ms };
  #endif
  
  // DOM Level 2 says (letters added):
</pre>
<hr />
<pre>
<span class="line-old-header">*** 524,11 ***</span>
      UNUSED_PARAM(frame);
  #endif
      return 0;
  }
  
<span class="line-modified">! Document::Document(PAL::SessionID sessionID, Frame* frame, const URL&amp; url, unsigned documentClasses, unsigned constructionFlags)</span>
      : ContainerNode(*this, CreateDocument)
      , TreeScope(*this)
      , FrameDestructionObserver(frame)
  #if ENABLE(IOS_TOUCH_EVENTS)
      , m_touchEventsChangedTimer(*this, &amp;Document::touchEventsChangedTimerFired)
<span class="line-new-header">--- 543,11 ---</span>
      UNUSED_PARAM(frame);
  #endif
      return 0;
  }
  
<span class="line-modified">! Document::Document(Frame* frame, const URL&amp; url, unsigned documentClasses, unsigned constructionFlags)</span>
      : ContainerNode(*this, CreateDocument)
      , TreeScope(*this)
      , FrameDestructionObserver(frame)
  #if ENABLE(IOS_TOUCH_EVENTS)
      , m_touchEventsChangedTimer(*this, &amp;Document::touchEventsChangedTimerFired)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 549,23 ***</span>
      , m_applyPendingXSLTransformsTimer(*this, &amp;Document::applyPendingXSLTransformsTimerFired)
  #endif
      , m_xmlVersion(&quot;1.0&quot;_s)
      , m_constantPropertyMap(makeUnique&lt;ConstantPropertyMap&gt;(*this))
      , m_documentClasses(documentClasses)
<span class="line-removed">-     , m_eventQueue(*this)</span>
  #if ENABLE(FULLSCREEN_API)
      , m_fullscreenManager { makeUniqueRef&lt;FullscreenManager&gt;(*this) }
  #endif
  #if ENABLE(INTERSECTION_OBSERVER)
      , m_intersectionObserversNotifyTimer(*this, &amp;Document::notifyIntersectionObserversTimerFired)
      , m_intersectionObserversInitialUpdateTimer(*this, &amp;Document::scheduleTimedRenderingUpdate)
  #endif
      , m_loadEventDelayTimer(*this, &amp;Document::loadEventDelayTimerFired)
  #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(DEVICE_ORIENTATION)
<span class="line-modified">!     , m_deviceMotionClient(makeUnique&lt;DeviceMotionClientIOS&gt;())</span>
      , m_deviceMotionController(makeUnique&lt;DeviceMotionController&gt;(*m_deviceMotionClient))
<span class="line-modified">!     , m_deviceOrientationClient(makeUnique&lt;DeviceOrientationClientIOS&gt;())</span>
      , m_deviceOrientationController(makeUnique&lt;DeviceOrientationController&gt;(*m_deviceOrientationClient))
  #endif
      , m_pendingTasksTimer(*this, &amp;Document::pendingTasksTimerFired)
      , m_visualUpdatesSuppressionTimer(*this, &amp;Document::visualUpdatesSuppressionTimerFired)
      , m_sharedObjectPoolClearTimer(*this, &amp;Document::clearSharedObjectPool)
<span class="line-new-header">--- 568,22 ---</span>
      , m_applyPendingXSLTransformsTimer(*this, &amp;Document::applyPendingXSLTransformsTimerFired)
  #endif
      , m_xmlVersion(&quot;1.0&quot;_s)
      , m_constantPropertyMap(makeUnique&lt;ConstantPropertyMap&gt;(*this))
      , m_documentClasses(documentClasses)
  #if ENABLE(FULLSCREEN_API)
      , m_fullscreenManager { makeUniqueRef&lt;FullscreenManager&gt;(*this) }
  #endif
  #if ENABLE(INTERSECTION_OBSERVER)
      , m_intersectionObserversNotifyTimer(*this, &amp;Document::notifyIntersectionObserversTimerFired)
      , m_intersectionObserversInitialUpdateTimer(*this, &amp;Document::scheduleTimedRenderingUpdate)
  #endif
      , m_loadEventDelayTimer(*this, &amp;Document::loadEventDelayTimerFired)
  #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(DEVICE_ORIENTATION)
<span class="line-modified">!     , m_deviceMotionClient(makeUnique&lt;DeviceMotionClientIOS&gt;(page() ? page()-&gt;deviceOrientationUpdateProvider() : nullptr))</span>
      , m_deviceMotionController(makeUnique&lt;DeviceMotionController&gt;(*m_deviceMotionClient))
<span class="line-modified">!     , m_deviceOrientationClient(makeUnique&lt;DeviceOrientationClientIOS&gt;(page() ? page()-&gt;deviceOrientationUpdateProvider() : nullptr))</span>
      , m_deviceOrientationController(makeUnique&lt;DeviceOrientationController&gt;(*m_deviceOrientationClient))
  #endif
      , m_pendingTasksTimer(*this, &amp;Document::pendingTasksTimerFired)
      , m_visualUpdatesSuppressionTimer(*this, &amp;Document::visualUpdatesSuppressionTimerFired)
      , m_sharedObjectPoolClearTimer(*this, &amp;Document::clearSharedObjectPool)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 574,16 ***</span>
      , m_cookieCacheExpiryTimer(*this, &amp;Document::invalidateDOMCookieCache)
      , m_socketProvider(page() ? &amp;page()-&gt;socketProvider() : nullptr)
      , m_isSynthesized(constructionFlags &amp; Synthesized)
      , m_isNonRenderedPlaceholder(constructionFlags &amp; NonRenderedPlaceholder)
      , m_orientationNotifier(currentOrientation(frame))
<span class="line-removed">-     , m_sessionID(sessionID)</span>
      , m_identifier(DocumentIdentifier::generate())
      , m_undoManager(UndoManager::create(*this))
  {
<span class="line-removed">-     ASSERT(!frame || frame-&gt;sessionID() == m_sessionID);</span>
<span class="line-removed">- </span>
      auto addResult = allDocumentsMap().add(m_identifier, this);
      ASSERT_UNUSED(addResult, addResult.isNewEntry);
  
      // We depend on the url getting immediately set in subframes, but we
      // also depend on the url NOT getting immediately set in opened windows.
<span class="line-new-header">--- 592,13 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 606,37 ***</span>
  
      for (auto&amp; nodeListAndCollectionCount : m_nodeListAndCollectionCounts)
          nodeListAndCollectionCount = 0;
  
      InspectorInstrumentation::addEventListenersToNode(*this);
  }
  
  Ref&lt;Document&gt; Document::create(Document&amp; contextDocument)
  {
<span class="line-modified">!     auto document = adoptRef(*new Document(contextDocument.sessionID(), nullptr, URL()));</span>
      document-&gt;setContextDocument(contextDocument);
      document-&gt;setSecurityOriginPolicy(contextDocument.securityOriginPolicy());
      return document;
  }
  
  Ref&lt;Document&gt; Document::createNonRenderedPlaceholder(Frame&amp; frame, const URL&amp; url)
  {
<span class="line-modified">!     return adoptRef(*new Document(frame.sessionID(), &amp;frame, url, DefaultDocumentClass, NonRenderedPlaceholder));</span>
  }
  
  Document::~Document()
  {
      if (m_logger)
          m_logger-&gt;removeObserver(*this);
  
      ASSERT(allDocumentsMap().contains(m_identifier));
      allDocumentsMap().remove(m_identifier);
      // We need to remove from the contexts map very early in the destructor so that calling postTask() on this Document from another thread is safe.
      removeFromContextsMap();
  
      ASSERT(!renderView());
<span class="line-modified">!     ASSERT(m_pageCacheState != InPageCache);</span>
      ASSERT(m_ranges.isEmpty());
      ASSERT(!m_parentTreeScope);
      ASSERT(!m_disabledFieldsetElementsCount);
      ASSERT(m_inDocumentShadowRoots.isEmpty());
  
<span class="line-new-header">--- 621,42 ---</span>
  
      for (auto&amp; nodeListAndCollectionCount : m_nodeListAndCollectionCounts)
          nodeListAndCollectionCount = 0;
  
      InspectorInstrumentation::addEventListenersToNode(*this);
<span class="line-added">+ #if ENABLE(MEDIA_STREAM)</span>
<span class="line-added">+     m_settings-&gt;setLegacyGetUserMediaEnabled(quirks().shouldEnableLegacyGetUserMedia());</span>
<span class="line-added">+ #endif</span>
  }
  
  Ref&lt;Document&gt; Document::create(Document&amp; contextDocument)
  {
<span class="line-modified">!     auto document = adoptRef(*new Document(nullptr, URL()));</span>
      document-&gt;setContextDocument(contextDocument);
      document-&gt;setSecurityOriginPolicy(contextDocument.securityOriginPolicy());
      return document;
  }
  
  Ref&lt;Document&gt; Document::createNonRenderedPlaceholder(Frame&amp; frame, const URL&amp; url)
  {
<span class="line-modified">!     return adoptRef(*new Document(&amp;frame, url, DefaultDocumentClass, NonRenderedPlaceholder));</span>
  }
  
  Document::~Document()
  {
<span class="line-added">+     ASSERT(activeDOMObjectsAreStopped());</span>
<span class="line-added">+ </span>
      if (m_logger)
          m_logger-&gt;removeObserver(*this);
  
      ASSERT(allDocumentsMap().contains(m_identifier));
      allDocumentsMap().remove(m_identifier);
      // We need to remove from the contexts map very early in the destructor so that calling postTask() on this Document from another thread is safe.
      removeFromContextsMap();
  
      ASSERT(!renderView());
<span class="line-modified">!     ASSERT(m_backForwardCacheState != InBackForwardCache);</span>
      ASSERT(m_ranges.isEmpty());
      ASSERT(!m_parentTreeScope);
      ASSERT(!m_disabledFieldsetElementsCount);
      ASSERT(m_inDocumentShadowRoots.isEmpty());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 752,24 ***</span>
<span class="line-new-header">--- 772,36 ---</span>
          // We need to do this right now since selfOnlyDeref() can delete this.
          m_inRemovedLastRefFunction = false;
  #endif
          decrementReferencingNodeCount();
      } else {
<span class="line-added">+         stopActiveDOMObjects();</span>
  #ifndef NDEBUG
          m_inRemovedLastRefFunction = false;
          m_deletionHasBegun = true;
  #endif
          delete this;
      }
  }
  
  void Document::commonTeardown()
  {
<span class="line-added">+     stopActiveDOMObjects();</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(FULLSCREEN_API)</span>
<span class="line-added">+     m_fullscreenManager-&gt;emptyEventQueue();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      if (svgExtensions())
          accessSVGExtensions().pauseAnimations();
  
      clearScriptedAnimationController();
<span class="line-added">+ </span>
<span class="line-added">+     if (m_highlightMap)</span>
<span class="line-added">+         m_highlightMap-&gt;clear();</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_pendingScrollEventTargetList = nullptr;</span>
  }
  
  Element* Document::elementForAccessKey(const String&amp; key)
  {
      if (key.isEmpty())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1148,20 ***</span>
  struct UnicodeCodePointRange {
      UChar32 minimum;
      UChar32 maximum;
  };
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
  
  static inline bool operator&lt;(const UnicodeCodePointRange&amp; a, const UnicodeCodePointRange&amp; b)
  {
      ASSERT(a.minimum &lt;= a.maximum);
      ASSERT(b.minimum &lt;= b.maximum);
      return a.maximum &lt; b.minimum;
  }
  
<span class="line-modified">! #endif</span>
  
  static inline bool operator&lt;(const UnicodeCodePointRange&amp; a, UChar32 b)
  {
      ASSERT(a.minimum &lt;= a.maximum);
      return a.maximum &lt; b;
<span class="line-new-header">--- 1180,20 ---</span>
  struct UnicodeCodePointRange {
      UChar32 minimum;
      UChar32 maximum;
  };
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
  
  static inline bool operator&lt;(const UnicodeCodePointRange&amp; a, const UnicodeCodePointRange&amp; b)
  {
      ASSERT(a.minimum &lt;= a.maximum);
      ASSERT(b.minimum &lt;= b.maximum);
      return a.maximum &lt; b.minimum;
  }
  
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
  
  static inline bool operator&lt;(const UnicodeCodePointRange&amp; a, UChar32 b)
  {
      ASSERT(a.minimum &lt;= a.maximum);
      return a.maximum &lt; b;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1605,20 ***</span>
      if (is&lt;SVGSVGElement&gt;(element)) {
          if (!m_titleElement) {
              m_titleElement = SVGTitleElement::create(SVGNames::titleTag, *this);
              element-&gt;insertBefore(*m_titleElement, element-&gt;firstChild());
          }
<span class="line-modified">!         m_titleElement-&gt;setTextContent(title);</span>
      } else if (is&lt;HTMLElement&gt;(element)) {
          if (!m_titleElement) {
              auto* headElement = head();
              if (!headElement)
                  return;
              m_titleElement = HTMLTitleElement::create(HTMLNames::titleTag, *this);
              headElement-&gt;appendChild(*m_titleElement);
          }
<span class="line-modified">!         m_titleElement-&gt;setTextContent(title);</span>
      }
  }
  
  template&lt;typename&gt; struct TitleTraits;
  
<span class="line-new-header">--- 1637,24 ---</span>
      if (is&lt;SVGSVGElement&gt;(element)) {
          if (!m_titleElement) {
              m_titleElement = SVGTitleElement::create(SVGNames::titleTag, *this);
              element-&gt;insertBefore(*m_titleElement, element-&gt;firstChild());
          }
<span class="line-modified">!         // insertBefore above may have ran scripts which removed m_titleElement.</span>
<span class="line-added">+         if (m_titleElement)</span>
<span class="line-added">+             m_titleElement-&gt;setTextContent(title);</span>
      } else if (is&lt;HTMLElement&gt;(element)) {
          if (!m_titleElement) {
              auto* headElement = head();
              if (!headElement)
                  return;
              m_titleElement = HTMLTitleElement::create(HTMLNames::titleTag, *this);
              headElement-&gt;appendChild(*m_titleElement);
          }
<span class="line-modified">!         // appendChild above may have ran scripts which removed m_titleElement.</span>
<span class="line-added">+         if (m_titleElement)</span>
<span class="line-added">+             m_titleElement-&gt;setTextContent(title);</span>
      }
  }
  
  template&lt;typename&gt; struct TitleTraits;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1699,15 ***</span>
      m_visibilityStateCallbackClients.remove(&amp;client);
  }
  
  void Document::visibilityStateChanged()
  {
<span class="line-modified">!     enqueueDocumentEvent(Event::create(eventNames().visibilitychangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
      for (auto* client : m_visibilityStateCallbackClients)
          client-&gt;visibilityStateChanged();
  
<span class="line-modified">!     notifyMediaCaptureOfVisibilityChanged();</span>
  }
  
  VisibilityState Document::visibilityState() const
  {
      // The visibility of the document is inherited from the visibility of the
<span class="line-new-header">--- 1735,19 ---</span>
      m_visibilityStateCallbackClients.remove(&amp;client);
  }
  
  void Document::visibilityStateChanged()
  {
<span class="line-modified">!     // // https://w3c.github.io/page-visibility/#reacting-to-visibilitychange-changes</span>
<span class="line-added">+     queueTaskToDispatchEvent(TaskSource::UserInteraction, Event::create(eventNames().visibilitychangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
      for (auto* client : m_visibilityStateCallbackClients)
          client-&gt;visibilityStateChanged();
  
<span class="line-modified">! #if ENABLE(MEDIA_STREAM)</span>
<span class="line-added">+     if (auto* page = this-&gt;page())</span>
<span class="line-added">+         RealtimeMediaSourceCenter::singleton().setCapturePageState(hidden(), page-&gt;isMediaCaptureMuted());</span>
<span class="line-added">+ #endif</span>
  }
  
  VisibilityState Document::visibilityState() const
  {
      // The visibility of the document is inherited from the visibility of the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1724,24 ***</span>
      return visibilityState() != VisibilityState::Visible;
  }
  
  #if ENABLE(VIDEO)
  
<span class="line-modified">! void Document::registerForAllowsMediaDocumentInlinePlaybackChangedCallbacks(HTMLMediaElement&amp; element)</span>
  {
<span class="line-modified">!     m_allowsMediaDocumentInlinePlaybackElements.add(&amp;element);</span>
  }
  
<span class="line-modified">! void Document::unregisterForAllowsMediaDocumentInlinePlaybackChangedCallbacks(HTMLMediaElement&amp; element)</span>
  {
<span class="line-modified">!     m_allowsMediaDocumentInlinePlaybackElements.remove(&amp;element);</span>
  }
  
<span class="line-modified">! void Document::allowsMediaDocumentInlinePlaybackChanged()</span>
  {
<span class="line-modified">!     for (auto* element : m_allowsMediaDocumentInlinePlaybackElements)</span>
<span class="line-modified">!         element-&gt;allowsMediaDocumentInlinePlaybackChanged();</span>
  }
  
  void Document::stopAllMediaPlayback()
  {
      if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
<span class="line-new-header">--- 1764,27 ---</span>
      return visibilityState() != VisibilityState::Visible;
  }
  
  #if ENABLE(VIDEO)
  
<span class="line-modified">! void Document::registerMediaElement(HTMLMediaElement&amp; element)</span>
  {
<span class="line-modified">!     m_mediaElements.add(&amp;element);</span>
  }
  
<span class="line-modified">! void Document::unregisterMediaElement(HTMLMediaElement&amp; element)</span>
  {
<span class="line-modified">!     m_mediaElements.remove(&amp;element);</span>
  }
  
<span class="line-modified">! void Document::forEachMediaElement(const Function&lt;void(HTMLMediaElement&amp;)&gt;&amp; function)</span>
  {
<span class="line-modified">!     Vector&lt;Ref&lt;HTMLMediaElement&gt;&gt; elements;</span>
<span class="line-modified">!     for (auto* element : m_mediaElements)</span>
<span class="line-added">+         elements.append(*element);</span>
<span class="line-added">+     for (auto&amp; element : elements)</span>
<span class="line-added">+         function(element);</span>
  }
  
  void Document::stopAllMediaPlayback()
  {
      if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1769,10 ***</span>
<span class="line-new-header">--- 1812,11 ---</span>
  void Document::resumeAllMediaBuffering()
  {
      if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
          platformMediaSessionManager-&gt;resumeAllMediaBufferingForDocument(*this);
  }
<span class="line-added">+ </span>
  #endif
  
  String Document::nodeName() const
  {
      return &quot;#document&quot;_s;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1837,11 ***</span>
  
  void Document::scheduleStyleRecalc()
  {
      ASSERT(!m_renderView || !inHitTesting());
  
<span class="line-modified">!     if (m_styleRecalcTimer.isActive() || pageCacheState() != NotInPageCache)</span>
          return;
  
      ASSERT(childNeedsStyleRecalc() || m_needsFullStyleRebuild);
      auto shouldThrottleStyleRecalc = [&amp;] {
          if (!view() || !view()-&gt;isVisuallyNonEmpty())
<span class="line-new-header">--- 1881,11 ---</span>
  
  void Document::scheduleStyleRecalc()
  {
      ASSERT(!m_renderView || !inHitTesting());
  
<span class="line-modified">!     if (m_styleRecalcTimer.isActive() || backForwardCacheState() != NotInBackForwardCache)</span>
          return;
  
      ASSERT(childNeedsStyleRecalc() || m_needsFullStyleRebuild);
      auto shouldThrottleStyleRecalc = [&amp;] {
          if (!view() || !view()-&gt;isVisuallyNonEmpty())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1914,11 ***</span>
          ScriptDisallowedScope::InMainThread scriptDisallowedScope;
          styleScope().flushPendingUpdate();
          frameView.willRecalcStyle();
      }
  
<span class="line-modified">!     InspectorInstrumentationCookie cookie = InspectorInstrumentation::willRecalculateStyle(*this);</span>
  
      bool updatedCompositingLayers = false;
      {
          Style::PostResolutionCallbackDisabler disabler(*this);
          WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
<span class="line-new-header">--- 1958,11 ---</span>
          ScriptDisallowedScope::InMainThread scriptDisallowedScope;
          styleScope().flushPendingUpdate();
          frameView.willRecalcStyle();
      }
  
<span class="line-modified">!     InspectorInstrumentation::willRecalculateStyle(*this);</span>
  
      bool updatedCompositingLayers = false;
      {
          Style::PostResolutionCallbackDisabler disabler(*this);
          WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1986,26 ***</span>
  
          ++m_styleRecalcCount;
          // FIXME: Assert ASSERT(!needsStyleRecalc()) here. Do we still have some cases where it&#39;s not true?
      }
  
<span class="line-modified">!     // If we wanted to call implicitClose() during recalcStyle, do so now that we&#39;re finished.</span>
<span class="line-removed">-     if (m_closeAfterStyleRecalc) {</span>
<span class="line-removed">-         m_closeAfterStyleRecalc = false;</span>
<span class="line-removed">-         implicitClose();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     InspectorInstrumentation::didRecalculateStyle(cookie);</span>
  
      // Some animated images may now be inside the viewport due to style recalc,
      // resume them if necessary if there is no layout pending. Otherwise, we&#39;ll
      // check if they need to be resumed after layout.
      if (updatedCompositingLayers &amp;&amp; !frameView.needsLayout())
          frameView.viewportContentsChanged();
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_gotoAnchorNeededAfterStylesheetsLoad &amp;&amp; !styleScope().hasPendingSheets())</span>
<span class="line-removed">-         frameView.scrollToFragment(m_url);</span>
  }
  
  void Document::updateTextRenderer(Text&amp; text, unsigned offsetOfReplacedText, unsigned lengthOfReplacedText)
  {
      ASSERT(!m_inRenderTreeUpdate);
<span class="line-new-header">--- 2030,17 ---</span>
  
          ++m_styleRecalcCount;
          // FIXME: Assert ASSERT(!needsStyleRecalc()) here. Do we still have some cases where it&#39;s not true?
      }
  
<span class="line-modified">!     InspectorInstrumentation::didRecalculateStyle(*this);</span>
  
      // Some animated images may now be inside the viewport due to style recalc,
      // resume them if necessary if there is no layout pending. Otherwise, we&#39;ll
      // check if they need to be resumed after layout.
      if (updatedCompositingLayers &amp;&amp; !frameView.needsLayout())
          frameView.viewportContentsChanged();
  }
  
  void Document::updateTextRenderer(Text&amp; text, unsigned offsetOfReplacedText, unsigned lengthOfReplacedText)
  {
      ASSERT(!m_inRenderTreeUpdate);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2018,11 ***</span>
      renderTreeUpdater.commit(WTFMove(textUpdate));
  }
  
  bool Document::needsStyleRecalc() const
  {
<span class="line-modified">!     if (pageCacheState() != NotInPageCache)</span>
          return false;
  
      if (m_needsFullStyleRebuild)
          return true;
  
<span class="line-new-header">--- 2053,11 ---</span>
      renderTreeUpdater.commit(WTFMove(textUpdate));
  }
  
  bool Document::needsStyleRecalc() const
  {
<span class="line-modified">!     if (backForwardCacheState() != NotInBackForwardCache)</span>
          return false;
  
      if (m_needsFullStyleRebuild)
          return true;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2030,14 ***</span>
          return true;
  
      if (styleScope().hasPendingUpdate())
          return true;
  
<span class="line-removed">-     // Ensure this happens eventually as it is currently in resolveStyle. This can be removed if the code moves.</span>
<span class="line-removed">-     if (m_gotoAnchorNeededAfterStylesheetsLoad &amp;&amp; !styleScope().hasPendingSheets())</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">- </span>
      return false;
  }
  
  static bool isSafeToUpdateStyleOrLayout(const Document&amp; document)
  {
<span class="line-new-header">--- 2065,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2129,11 ***</span>
  
      SetForScope&lt;bool&gt; change(m_ignorePendingStylesheets, true);
      auto&amp; resolver = element.styleResolver();
  
      if (pseudoElementSpecifier != PseudoId::None)
<span class="line-modified">!         return resolver.pseudoStyleForElement(element, PseudoStyleRequest(pseudoElementSpecifier), *parentStyle);</span>
  
      auto elementStyle = resolver.styleForElement(element, parentStyle);
      if (elementStyle.relations) {
          Style::Update emptyUpdate(*this);
          Style::commitRelations(WTFMove(elementStyle.relations), emptyUpdate);
<span class="line-new-header">--- 2160,11 ---</span>
  
      SetForScope&lt;bool&gt; change(m_ignorePendingStylesheets, true);
      auto&amp; resolver = element.styleResolver();
  
      if (pseudoElementSpecifier != PseudoId::None)
<span class="line-modified">!         return resolver.pseudoStyleForElement(element, { pseudoElementSpecifier }, *parentStyle);</span>
  
      auto elementStyle = resolver.styleForElement(element, parentStyle);
      if (elementStyle.relations) {
          Style::Update emptyUpdate(*this);
          Style::commitRelations(WTFMove(elementStyle.relations), emptyUpdate);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2288,27 ***</span>
      marginRight = style-&gt;marginRight().isAuto() ? marginRight : intValueForLength(style-&gt;marginRight(), width);
      marginBottom = style-&gt;marginBottom().isAuto() ? marginBottom : intValueForLength(style-&gt;marginBottom(), width);
      marginLeft = style-&gt;marginLeft().isAuto() ? marginLeft : intValueForLength(style-&gt;marginLeft(), width);
  }
  
<span class="line-modified">! StyleResolver&amp; Document::userAgentShadowTreeStyleResolver()</span>
  {
      if (!m_userAgentShadowTreeStyleResolver)
<span class="line-modified">!         m_userAgentShadowTreeStyleResolver = makeUnique&lt;StyleResolver&gt;(*this);</span>
      return *m_userAgentShadowTreeStyleResolver;
  }
  
  void Document::fontsNeedUpdate(FontSelector&amp;)
  {
      invalidateMatchedPropertiesCacheAndForceStyleRecalc();
  }
  
  void Document::invalidateMatchedPropertiesCacheAndForceStyleRecalc()
  {
<span class="line-modified">!     if (auto* resolver = styleScope().resolverIfExists())</span>
<span class="line-modified">!         resolver-&gt;invalidateMatchedPropertiesCache();</span>
<span class="line-modified">!     if (pageCacheState() != NotInPageCache || !renderView())</span>
          return;
      scheduleFullStyleRebuild();
  }
  
  void Document::didClearStyleResolver()
<span class="line-new-header">--- 2319,27 ---</span>
      marginRight = style-&gt;marginRight().isAuto() ? marginRight : intValueForLength(style-&gt;marginRight(), width);
      marginBottom = style-&gt;marginBottom().isAuto() ? marginBottom : intValueForLength(style-&gt;marginBottom(), width);
      marginLeft = style-&gt;marginLeft().isAuto() ? marginLeft : intValueForLength(style-&gt;marginLeft(), width);
  }
  
<span class="line-modified">! Style::Resolver&amp; Document::userAgentShadowTreeStyleResolver()</span>
  {
      if (!m_userAgentShadowTreeStyleResolver)
<span class="line-modified">!         m_userAgentShadowTreeStyleResolver = makeUnique&lt;Style::Resolver&gt;(*this);</span>
      return *m_userAgentShadowTreeStyleResolver;
  }
  
  void Document::fontsNeedUpdate(FontSelector&amp;)
  {
      invalidateMatchedPropertiesCacheAndForceStyleRecalc();
  }
  
  void Document::invalidateMatchedPropertiesCacheAndForceStyleRecalc()
  {
<span class="line-modified">!     styleScope().invalidateMatchedDeclarationsCache();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (backForwardCacheState() != NotInBackForwardCache || !renderView())</span>
          return;
      scheduleFullStyleRebuild();
  }
  
  void Document::didClearStyleResolver()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2323,11 ***</span>
  }
  
  void Document::createRenderTree()
  {
      ASSERT(!renderView());
<span class="line-modified">!     ASSERT(m_pageCacheState != InPageCache);</span>
      ASSERT(!m_axObjectCache || this != &amp;topDocument());
  
      if (m_isNonRenderedPlaceholder)
          return;
  
<span class="line-new-header">--- 2354,11 ---</span>
  }
  
  void Document::createRenderTree()
  {
      ASSERT(!renderView());
<span class="line-modified">!     ASSERT(m_backForwardCacheState != InBackForwardCache);</span>
      ASSERT(!m_axObjectCache || this != &amp;topDocument());
  
      if (m_isNonRenderedPlaceholder)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2363,11 ***</span>
      if (page() &amp;&amp; m_frame-&gt;isMainFrame())
          wheelEventHandlersChanged();
  
      // Ensure that the scheduled task state of the document matches the DOM suspension state of the frame. It can
      // be out of sync if the DOM suspension state changed while the document was not in the frame (possibly in the
<span class="line-modified">!     // page cache, or simply newly created).</span>
      if (m_frame-&gt;activeDOMObjectsAndAnimationsSuspended()) {
          if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
              if (auto* timeline = existingTimeline())
                  timeline-&gt;suspendAnimations();
          } else
<span class="line-new-header">--- 2394,11 ---</span>
      if (page() &amp;&amp; m_frame-&gt;isMainFrame())
          wheelEventHandlersChanged();
  
      // Ensure that the scheduled task state of the document matches the DOM suspension state of the frame. It can
      // be out of sync if the DOM suspension state changed while the document was not in the frame (possibly in the
<span class="line-modified">!     // back/forward cache, or simply newly created).</span>
      if (m_frame-&gt;activeDOMObjectsAndAnimationsSuspended()) {
          if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
              if (auto* timeline = existingTimeline())
                  timeline-&gt;suspendAnimations();
          } else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2406,20 ***</span>
  
  void Document::attachToCachedFrame(CachedFrameBase&amp; cachedFrame)
  {
      RELEASE_ASSERT(cachedFrame.document() == this);
      ASSERT(cachedFrame.view());
<span class="line-modified">!     ASSERT(m_pageCacheState == Document::InPageCache);</span>
      observeFrame(&amp;cachedFrame.view()-&gt;frame());
  }
  
  void Document::detachFromCachedFrame(CachedFrameBase&amp; cachedFrame)
  {
      ASSERT_UNUSED(cachedFrame, cachedFrame.view());
      RELEASE_ASSERT(cachedFrame.document() == this);
      ASSERT(m_frame == &amp;cachedFrame.view()-&gt;frame());
<span class="line-modified">!     ASSERT(m_pageCacheState == Document::InPageCache);</span>
      detachFromFrame();
  }
  
  void Document::destroyRenderTree()
  {
<span class="line-new-header">--- 2437,20 ---</span>
  
  void Document::attachToCachedFrame(CachedFrameBase&amp; cachedFrame)
  {
      RELEASE_ASSERT(cachedFrame.document() == this);
      ASSERT(cachedFrame.view());
<span class="line-modified">!     ASSERT(m_backForwardCacheState == Document::InBackForwardCache);</span>
      observeFrame(&amp;cachedFrame.view()-&gt;frame());
  }
  
  void Document::detachFromCachedFrame(CachedFrameBase&amp; cachedFrame)
  {
      ASSERT_UNUSED(cachedFrame, cachedFrame.view());
      RELEASE_ASSERT(cachedFrame.document() == this);
      ASSERT(m_frame == &amp;cachedFrame.view()-&gt;frame());
<span class="line-modified">!     ASSERT(m_backForwardCacheState == Document::InBackForwardCache);</span>
      detachFromFrame();
  }
  
  void Document::destroyRenderTree()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2493,10 ***</span>
<span class="line-new-header">--- 2524,12 ---</span>
      clearTouchEventHandlersAndListeners();
  #endif
  
      m_undoManager-&gt;removeAllItems();
  
<span class="line-added">+     m_textManipulationController = nullptr; // Free nodes kept alive by TextManipulationController.</span>
<span class="line-added">+ </span>
  #if ENABLE(ACCESSIBILITY)
      if (this != &amp;topDocument()) {
          // Let the ax cache know that this subframe goes out of scope.
          if (auto* cache = existingAXObjectCache())
              cache-&gt;prepareForDocumentDestruction(*this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2530,16 ***</span>
              validationMessageClient-&gt;documentDetached(*this);
      }
  
      InspectorInstrumentation::documentDetached(*this);
  
<span class="line-removed">-     stopActiveDOMObjects();</span>
<span class="line-removed">-     m_eventQueue.close();</span>
<span class="line-removed">- #if ENABLE(FULLSCREEN_API)</span>
<span class="line-removed">-     m_fullscreenManager-&gt;emptyEventQueue();</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
      commonTeardown();
  
  #if ENABLE(TOUCH_EVENTS)
      if (m_touchEventTargets &amp;&amp; m_touchEventTargets-&gt;size() &amp;&amp; parentDocument())
          parentDocument()-&gt;didRemoveEventTargetNode(*this);
<span class="line-new-header">--- 2563,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2565,27 ***</span>
          page()-&gt;updateIsPlayingMedia(HTMLMediaElementInvalidID);
      }
  
      detachFromFrame();
  
<span class="line-modified">!     if (m_timeline) {</span>
<span class="line-modified">!         m_timeline-&gt;detachFromDocument();</span>
<span class="line-modified">!         m_timeline = nullptr;</span>
<span class="line-removed">-     }</span>
  
  #if ENABLE(CSS_PAINTING_API)
      for (auto&amp; scope : m_paintWorkletGlobalScopes.values())
          scope-&gt;prepareForDestruction();
      m_paintWorkletGlobalScopes.clear();
  #endif
  
      m_hasPreparedForDestruction = true;
  
<span class="line-modified">!     // Note that m_pageCacheState can be Document::AboutToEnterPageCache if our frame</span>
      // was removed in an onpagehide event handler fired when the top-level frame is
<span class="line-modified">!     // about to enter the page cache.</span>
<span class="line-modified">!     RELEASE_ASSERT(m_pageCacheState != Document::InPageCache);</span>
  }
  
  void Document::removeAllEventListeners()
  {
      EventTarget::removeAllEventListeners();
<span class="line-new-header">--- 2592,26 ---</span>
          page()-&gt;updateIsPlayingMedia(HTMLMediaElementInvalidID);
      }
  
      detachFromFrame();
  
<span class="line-modified">!     while (!m_timelines.computesEmpty())</span>
<span class="line-modified">!         m_timelines.begin()-&gt;detachFromDocument();</span>
<span class="line-modified">!     m_timeline = nullptr;</span>
  
  #if ENABLE(CSS_PAINTING_API)
      for (auto&amp; scope : m_paintWorkletGlobalScopes.values())
          scope-&gt;prepareForDestruction();
      m_paintWorkletGlobalScopes.clear();
  #endif
  
      m_hasPreparedForDestruction = true;
  
<span class="line-modified">!     // Note that m_backForwardCacheState can be Document::AboutToEnterBackForwardCache if our frame</span>
      // was removed in an onpagehide event handler fired when the top-level frame is
<span class="line-modified">!     // about to enter the back/forward cache.</span>
<span class="line-modified">!     RELEASE_ASSERT(m_backForwardCacheState != Document::InBackForwardCache);</span>
  }
  
  void Document::removeAllEventListeners()
  {
      EventTarget::removeAllEventListeners();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2632,12 ***</span>
  }
  
  bool Document::shouldBypassMainWorldContentSecurityPolicy() const
  {
      // Bypass this policy when the world is known, and it not the normal world.
<span class="line-modified">!     auto&amp; callFrame = *commonVM().topCallFrame;</span>
<span class="line-modified">!     return &amp;callFrame != JSC::CallFrame::noCaller() &amp;&amp; !currentWorld(callFrame).isNormal();</span>
  }
  
  void Document::platformSuspendOrStopActiveDOMObjects()
  {
  #if PLATFORM(IOS_FAMILY)
<span class="line-new-header">--- 2658,13 ---</span>
  }
  
  bool Document::shouldBypassMainWorldContentSecurityPolicy() const
  {
      // Bypass this policy when the world is known, and it not the normal world.
<span class="line-modified">!     JSC::VM&amp; vm = commonVM();</span>
<span class="line-modified">!     auto&amp; callFrame = *vm.topCallFrame;</span>
<span class="line-added">+     return &amp;callFrame != JSC::CallFrame::noCaller() &amp;&amp; !currentWorld(*callFrame.lexicalGlobalObject(vm)).isNormal();</span>
  }
  
  void Document::platformSuspendOrStopActiveDOMObjects()
  {
  #if PLATFORM(IOS_FAMILY)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2645,24 ***</span>
<span class="line-new-header">--- 2672,30 ---</span>
  #endif
  }
  
  void Document::suspendActiveDOMObjects(ReasonForSuspension why)
  {
<span class="line-added">+     if (m_documentTaskGroup)</span>
<span class="line-added">+         m_documentTaskGroup-&gt;suspend();</span>
      ScriptExecutionContext::suspendActiveDOMObjects(why);
      suspendDeviceMotionAndOrientationUpdates();
      platformSuspendOrStopActiveDOMObjects();
  }
  
  void Document::resumeActiveDOMObjects(ReasonForSuspension why)
  {
<span class="line-added">+     if (m_documentTaskGroup)</span>
<span class="line-added">+         m_documentTaskGroup-&gt;resume();</span>
      ScriptExecutionContext::resumeActiveDOMObjects(why);
      resumeDeviceMotionAndOrientationUpdates();
      // FIXME: For iOS, do we need to add content change observers that were removed in Document::suspendActiveDOMObjects()?
  }
  
  void Document::stopActiveDOMObjects()
  {
<span class="line-added">+     if (m_documentTaskGroup)</span>
<span class="line-added">+         m_documentTaskGroup-&gt;stopAndDiscardAllTasks();</span>
      ScriptExecutionContext::stopActiveDOMObjects();
      platformSuspendOrStopActiveDOMObjects();
  }
  
  void Document::clearAXObjectCache()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2713,10 ***</span>
<span class="line-new-header">--- 2746,50 ---</span>
  {
      // FIXME: this should probably pass the frame instead
      return XMLDocumentParser::create(*this, view());
  }
  
<span class="line-added">+ HighlightMap&amp; Document::highlightMap()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_highlightMap)</span>
<span class="line-added">+         m_highlightMap = HighlightMap::create();</span>
<span class="line-added">+     return *m_highlightMap;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Document::updateHighlightPositions()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Vector&lt;WeakPtr&lt;HighlightRangeData&gt;&gt; rangesData;</span>
<span class="line-added">+     if (m_highlightMap) {</span>
<span class="line-added">+         for (auto&amp; highlight : m_highlightMap-&gt;map()) {</span>
<span class="line-added">+             for (auto&amp; rangeData : highlight.value-&gt;rangesData()) {</span>
<span class="line-added">+                 if (rangeData-&gt;startPosition &amp;&amp; rangeData-&gt;endPosition)</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+                 if (&amp;rangeData-&gt;range-&gt;startContainer()-&gt;treeScope() != &amp;rangeData-&gt;range-&gt;endContainer()-&gt;treeScope())</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+                 rangesData.append(makeWeakPtr(rangeData.ptr()));</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto&amp; weakRangeData : rangesData) {</span>
<span class="line-added">+         if (auto* rangeData = weakRangeData.get()) {</span>
<span class="line-added">+             VisibleSelection visibleSelection(rangeData-&gt;range);</span>
<span class="line-added">+             Position startPosition;</span>
<span class="line-added">+             Position endPosition;</span>
<span class="line-added">+             if (!rangeData-&gt;startPosition.hasValue())</span>
<span class="line-added">+                 startPosition = visibleSelection.visibleStart().deepEquivalent();</span>
<span class="line-added">+             if (!rangeData-&gt;endPosition.hasValue())</span>
<span class="line-added">+                 endPosition = visibleSelection.visibleEnd().deepEquivalent(); // &lt;MMG&gt; switch to END</span>
<span class="line-added">+             if (!weakRangeData.get())</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+             rangeData-&gt;startPosition = startPosition;</span>
<span class="line-added">+             rangeData-&gt;endPosition = endPosition;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  ScriptableDocumentParser* Document::scriptableDocumentParser() const
  {
      return parser() ? parser()-&gt;asScriptableDocumentParser() : nullptr;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2746,10 ***</span>
<span class="line-new-header">--- 2819,13 ---</span>
          return Exception { SecurityError };
  
      if (m_ignoreOpensDuringUnloadCount)
          return { };
  
<span class="line-added">+     if (m_activeParserWasAborted)</span>
<span class="line-added">+         return { };</span>
<span class="line-added">+ </span>
      if (m_frame) {
          if (ScriptableDocumentParser* parser = scriptableDocumentParser()) {
              if (parser-&gt;isParsing()) {
                  // FIXME: HTML5 doesn&#39;t tell us to check this, it might not be correct.
                  if (parser-&gt;isExecutingScript())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2815,10 ***</span>
<span class="line-new-header">--- 2891,13 ---</span>
  void Document::cancelParsing()
  {
      if (!m_parser)
          return;
  
<span class="line-added">+     if (m_parser-&gt;processingData())</span>
<span class="line-added">+         m_activeParserWasAborted = true;</span>
<span class="line-added">+ </span>
      // We have to clear the parser to avoid possibly triggering
      // the onload handler when closing as a side effect of a cancel-style
      // change, such as opening a new document or closing the window while
      // still parsing
      detachParser();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2829,11 ***</span>
  {
      removeChildren();
  
      setCompatibilityMode(DocumentCompatibilityMode::NoQuirksMode);
  
<span class="line-modified">!     cancelParsing();</span>
      m_parser = createParser();
  
      if (hasActiveParserYieldToken())
          m_parser-&gt;didBeginYieldingParser();
  
<span class="line-new-header">--- 2908,11 ---</span>
  {
      removeChildren();
  
      setCompatibilityMode(DocumentCompatibilityMode::NoQuirksMode);
  
<span class="line-modified">!     detachParser();</span>
      m_parser = createParser();
  
      if (hasActiveParserYieldToken())
          m_parser-&gt;didBeginYieldingParser();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2928,16 ***</span>
      checkCompleted();
  }
  
  void Document::implicitClose()
  {
<span class="line-modified">!     // If we&#39;re in the middle of recalcStyle, we need to defer the close until the style information is accurate and all elements are re-attached.</span>
<span class="line-removed">-     if (m_inStyleRecalc) {</span>
<span class="line-removed">-         m_closeAfterStyleRecalc = true;</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      bool wasLocationChangePending = frame() &amp;&amp; frame()-&gt;navigationScheduler().locationChangePending();
      bool doload = !parsing() &amp;&amp; m_parser &amp;&amp; !m_processingLoadEvent &amp;&amp; !wasLocationChangePending;
  
      if (!doload)
          return;
<span class="line-new-header">--- 3007,11 ---</span>
      checkCompleted();
  }
  
  void Document::implicitClose()
  {
<span class="line-modified">!     RELEASE_ASSERT(!m_inStyleRecalc);</span>
      bool wasLocationChangePending = frame() &amp;&amp; frame()-&gt;navigationScheduler().locationChangePending();
      bool doload = !parsing() &amp;&amp; m_parser &amp;&amp; !m_processingLoadEvent &amp;&amp; !wasLocationChangePending;
  
      if (!doload)
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2979,15 ***</span>
          ImageLoader::dispatchPendingLoadEvents();
          ImageLoader::dispatchPendingErrorEvents();
          HTMLLinkElement::dispatchPendingLoadEvents();
          HTMLStyleElement::dispatchPendingLoadEvents();
  
<span class="line-removed">-         // To align the HTML load event and the SVGLoad event for the outermost &lt;svg&gt; element, fire it from</span>
<span class="line-removed">-         // here, instead of doing it from SVGElement::finishedParsingChildren (if externalResourcesRequired=&quot;false&quot;,</span>
<span class="line-removed">-         // which is the default, for =&#39;true&#39; its fired at a later time, once all external resources finished loading).</span>
          if (svgExtensions())
<span class="line-modified">!             accessSVGExtensions().dispatchSVGLoadEventToOutermostSVGElements();</span>
      }
  
      dispatchWindowLoadEvent();
      dispatchPageshowEvent(PageshowEventNotPersisted);
      if (m_pendingStateObject)
<span class="line-new-header">--- 3053,12 ---</span>
          ImageLoader::dispatchPendingLoadEvents();
          ImageLoader::dispatchPendingErrorEvents();
          HTMLLinkElement::dispatchPendingLoadEvents();
          HTMLStyleElement::dispatchPendingLoadEvents();
  
          if (svgExtensions())
<span class="line-modified">!             accessSVGExtensions().dispatchLoadEventToOutermostSVGElements();</span>
      }
  
      dispatchWindowLoadEvent();
      dispatchPageshowEvent(PageshowEventNotPersisted);
      if (m_pendingStateObject)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3028,12 ***</span>
              view()-&gt;layoutContext().layout();
      }
  
      m_processingLoadEvent = false;
  
<span class="line-modified">!     if (auto* fontFaceSet = fontSelector().optionalFontFaceSet())</span>
<span class="line-modified">!         fontFaceSet-&gt;didFirstLayout();</span>
  
  #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
      if (f &amp;&amp; hasLivingRenderTree() &amp;&amp; AXObjectCache::accessibilityEnabled()) {
          // The AX cache may have been cleared at this point, but we need to make sure it contains an
          // AX object to send the notification to. getOrCreate will make sure that an valid AX object
<span class="line-new-header">--- 3099,12 ---</span>
              view()-&gt;layoutContext().layout();
      }
  
      m_processingLoadEvent = false;
  
<span class="line-modified">!     if (auto fontFaceSet = makeRefPtr(fontSelector().fontFaceSetIfExists()))</span>
<span class="line-modified">!         fontFaceSet-&gt;documentDidFinishLoading();</span>
  
  #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
      if (f &amp;&amp; hasLivingRenderTree() &amp;&amp; AXObjectCache::accessibilityEnabled()) {
          // The AX cache may have been cleared at this point, but we need to make sure it contains an
          // AX object to send the notification to. getOrCreate will make sure that an valid AX object
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3107,10 ***</span>
<span class="line-new-header">--- 3178,13 ---</span>
      return MonotonicTime::now() - m_documentCreationTime;
  }
  
  ExceptionOr&lt;void&gt; Document::write(Document* responsibleDocument, SegmentedString&amp;&amp; text)
  {
<span class="line-added">+     if (m_activeParserWasAborted)</span>
<span class="line-added">+         return { };</span>
<span class="line-added">+ </span>
      NestingLevelIncrementer nestingLevelIncrementer(m_writeRecursionDepth);
  
      m_writeRecursionIsTooDeep = (m_writeRecursionDepth &gt; 1) &amp;&amp; m_writeRecursionIsTooDeep;
      m_writeRecursionIsTooDeep = (m_writeRecursionDepth &gt; cMaxWriteRecursionDepth) || m_writeRecursionIsTooDeep;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3208,10 ***</span>
<span class="line-new-header">--- 3282,13 ---</span>
      const URL&amp; newURL = url.isEmpty() ? WTF::blankURL() : url;
      if (newURL == m_url)
          return;
  
      m_url = newURL;
<span class="line-added">+     if (SecurityOrigin::shouldIgnoreHost(m_url))</span>
<span class="line-added">+         m_url.removeHostAndPort();</span>
<span class="line-added">+ </span>
      m_documentURI = m_url.string();
      updateBaseURL();
  }
  
  void Document::updateBaseURL()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3274,12 ***</span>
          String strippedHref = stripLeadingAndTrailingHTMLSpaces(*href);
          if (!strippedHref.isEmpty())
              baseElementURL = URL(url(), strippedHref);
      }
      if (m_baseElementURL != baseElementURL &amp;&amp; contentSecurityPolicy()-&gt;allowBaseURI(baseElementURL)) {
<span class="line-modified">!         m_baseElementURL = baseElementURL;</span>
<span class="line-modified">!         updateBaseURL();</span>
      }
  
      m_baseTarget = target ? *target : nullAtom();
  }
  
<span class="line-new-header">--- 3351,16 ---</span>
          String strippedHref = stripLeadingAndTrailingHTMLSpaces(*href);
          if (!strippedHref.isEmpty())
              baseElementURL = URL(url(), strippedHref);
      }
      if (m_baseElementURL != baseElementURL &amp;&amp; contentSecurityPolicy()-&gt;allowBaseURI(baseElementURL)) {
<span class="line-modified">!         if (settings().shouldRestrictBaseURLSchemes() &amp;&amp; !SecurityPolicy::isBaseURLSchemeAllowed(baseElementURL))</span>
<span class="line-modified">!             addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Blocked setting &quot; + baseElementURL.stringCenterEllipsizedToLength() + &quot; as the base URL because it does not have an allowed scheme.&quot;);</span>
<span class="line-added">+         else {</span>
<span class="line-added">+             m_baseElementURL = baseElementURL;</span>
<span class="line-added">+             updateBaseURL();</span>
<span class="line-added">+         }</span>
      }
  
      m_baseTarget = target ? *target : nullAtom();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3335,11 ***</span>
  
      if (!canNavigateInternal(*targetFrame))
          return false;
  
      if (isNavigationBlockedByThirdPartyIFrameRedirectBlocking(*targetFrame, destinationURL)) {
<span class="line-modified">!         printNavigationErrorMessage(*targetFrame, url(), &quot;The frame attempting navigation of the top-level window is cross-origin and the user has never interacted with the frame.&quot;_s);</span>
          return false;
      }
  
      return true;
  }
<span class="line-new-header">--- 3416,11 ---</span>
  
      if (!canNavigateInternal(*targetFrame))
          return false;
  
      if (isNavigationBlockedByThirdPartyIFrameRedirectBlocking(*targetFrame, destinationURL)) {
<span class="line-modified">!         printNavigationErrorMessage(*targetFrame, url(), &quot;The frame attempting navigation of the top-level window is cross-origin or untrusted and the user has never interacted with the frame.&quot;_s);</span>
          return false;
      }
  
      return true;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3425,10 ***</span>
<span class="line-new-header">--- 3506,20 ---</span>
  
      printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation is neither same-origin with the target, nor is it the target&#39;s parent or opener.&quot;);
      return false;
  }
  
<span class="line-added">+ void Document::willLoadScriptElement(const URL&amp; scriptURL)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_hasLoadedThirdPartyScript = m_hasLoadedThirdPartyScript || !securityOrigin().isSameOriginAs(SecurityOrigin::create(scriptURL));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Document::willLoadFrameElement(const URL&amp; frameURL)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_hasLoadedThirdPartyFrame = m_hasLoadedThirdPartyFrame || !securityOrigin().isSameOriginAs(SecurityOrigin::create(frameURL));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Prevent cross-site top-level redirects from third-party iframes unless the user has ever interacted with the frame.
  bool Document::isNavigationBlockedByThirdPartyIFrameRedirectBlocking(Frame&amp; targetFrame, const URL&amp; destinationURL)
  {
      if (!settings().thirdPartyIframeRedirectBlockingEnabled())
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3444,12 ***</span>
      // Only prevent navigations by unsandboxed iframes. Such navigations by unsandboxed iframes would have already been blocked unless
      // &quot;allow-top-navigation&quot; / &quot;allow-top-navigation-by-user-activation&quot; was explicitly specified.
      if (sandboxFlags() != SandboxNone)
          return false;
  
<span class="line-modified">!     // Only prevent navigations by third-party iframes.</span>
<span class="line-modified">!     if (canAccessAncestor(securityOrigin(), &amp;targetFrame))</span>
          return false;
  
      // Only prevent cross-site navigations.
      auto* targetDocument = targetFrame.document();
      if (targetDocument &amp;&amp; (targetDocument-&gt;securityOrigin().canAccess(SecurityOrigin::create(destinationURL)) || areRegistrableDomainsEqual(targetDocument-&gt;url(), destinationURL)))
<span class="line-new-header">--- 3535,13 ---</span>
      // Only prevent navigations by unsandboxed iframes. Such navigations by unsandboxed iframes would have already been blocked unless
      // &quot;allow-top-navigation&quot; / &quot;allow-top-navigation-by-user-activation&quot; was explicitly specified.
      if (sandboxFlags() != SandboxNone)
          return false;
  
<span class="line-modified">!     // Only prevent navigations by third-party iframes or untrusted first-party iframes.</span>
<span class="line-modified">!     bool isUntrustedIframe = m_hasLoadedThirdPartyScript &amp;&amp; m_hasLoadedThirdPartyFrame;</span>
<span class="line-added">+     if (canAccessAncestor(securityOrigin(), &amp;targetFrame) &amp;&amp; !isUntrustedIframe)</span>
          return false;
  
      // Only prevent cross-site navigations.
      auto* targetDocument = targetFrame.document();
      if (targetDocument &amp;&amp; (targetDocument-&gt;securityOrigin().canAccess(SecurityOrigin::create(destinationURL)) || areRegistrableDomainsEqual(targetDocument-&gt;url(), destinationURL)))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3460,10 ***</span>
<span class="line-new-header">--- 3552,24 ---</span>
  
  void Document::didRemoveAllPendingStylesheet()
  {
      if (auto* parser = scriptableDocumentParser())
          parser-&gt;executeScriptsWaitingForStylesheetsSoon();
<span class="line-added">+ </span>
<span class="line-added">+     if (m_gotoAnchorNeededAfterStylesheetsLoad) {</span>
<span class="line-added">+         // https://html.spec.whatwg.org/multipage/browsing-the-web.html#try-to-scroll-to-the-fragment</span>
<span class="line-added">+         eventLoop().queueTask(TaskSource::Networking, [protectedThis = makeRef(*this), this] {</span>
<span class="line-added">+             auto frameView = makeRefPtr(view());</span>
<span class="line-added">+             if (!frameView)</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             if (!haveStylesheetsLoaded()) {</span>
<span class="line-added">+                 m_gotoAnchorNeededAfterStylesheetsLoad = true;</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             frameView-&gt;scrollToFragment(m_url);</span>
<span class="line-added">+         });</span>
<span class="line-added">+     }</span>
  }
  
  bool Document::usesStyleBasedEditability() const
  {
      if (m_hasElementUsingStyleBasedEditability)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3524,11 ***</span>
          // -dwh
          styleScope().setPreferredStylesheetSetName(content);
          break;
  
      case HTTPHeaderName::Refresh: {
<span class="line-modified">!         double delay;</span>
          String urlString;
          if (frame &amp;&amp; parseMetaHTTPEquivRefresh(content, delay, urlString)) {
              URL completedURL;
              if (urlString.isEmpty())
                  completedURL = m_url;
<span class="line-new-header">--- 3630,11 ---</span>
          // -dwh
          styleScope().setPreferredStylesheetSetName(content);
          break;
  
      case HTTPHeaderName::Refresh: {
<span class="line-modified">!         double delay = 0;</span>
          String urlString;
          if (frame &amp;&amp; parseMetaHTTPEquivRefresh(content, delay, urlString)) {
              URL completedURL;
              if (urlString.isEmpty())
                  completedURL = m_url;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3635,11 ***</span>
  }
  
  void Document::updateViewportArguments()
  {
      if (page() &amp;&amp; frame()-&gt;isMainFrame()) {
<span class="line-modified">! #ifndef NDEBUG</span>
          m_didDispatchViewportPropertiesChanged = true;
  #endif
          page()-&gt;chrome().dispatchViewportPropertiesDidChange(viewportArguments());
          page()-&gt;chrome().didReceiveDocType(*frame());
      }
<span class="line-new-header">--- 3741,11 ---</span>
  }
  
  void Document::updateViewportArguments()
  {
      if (page() &amp;&amp; frame()-&gt;isMainFrame()) {
<span class="line-modified">! #if ASSERT_ENABLED</span>
          m_didDispatchViewportPropertiesChanged = true;
  #endif
          page()-&gt;chrome().dispatchViewportPropertiesDidChange(viewportArguments());
          page()-&gt;chrome().didReceiveDocType(*frame());
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3671,11 ***</span>
  {
      OptionSet&lt;ColorScheme&gt; colorScheme;
      bool allowsTransformations = true;
      bool autoEncountered = false;
  
<span class="line-modified">!     processColorSchemeString(colorSchemeString, [&amp;](StringView key) {</span>
          if (equalLettersIgnoringASCIICase(key, &quot;auto&quot;)) {
              colorScheme = { };
              allowsTransformations = true;
              autoEncountered = true;
              return;
<span class="line-new-header">--- 3777,11 ---</span>
  {
      OptionSet&lt;ColorScheme&gt; colorScheme;
      bool allowsTransformations = true;
      bool autoEncountered = false;
  
<span class="line-modified">!     processColorSchemeString(colorSchemeString, [&amp;] (StringView key) {</span>
          if (equalLettersIgnoringASCIICase(key, &quot;auto&quot;)) {
              colorScheme = { };
              allowsTransformations = true;
              autoEncountered = true;
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3894,14 ***</span>
  
  Ref&lt;Document&gt; Document::cloneDocumentWithoutChildren() const
  {
      if (isXMLDocument()) {
          if (isXHTMLDocument())
<span class="line-modified">!             return XMLDocument::createXHTML(sessionID(), nullptr, url());</span>
<span class="line-modified">!         return XMLDocument::create(sessionID(), nullptr, url());</span>
      }
<span class="line-modified">!     return create(sessionID(), url());</span>
  }
  
  void Document::cloneDataFromDocument(const Document&amp; other)
  {
      ASSERT(m_url == other.url());
<span class="line-new-header">--- 4000,14 ---</span>
  
  Ref&lt;Document&gt; Document::cloneDocumentWithoutChildren() const
  {
      if (isXMLDocument()) {
          if (isXHTMLDocument())
<span class="line-modified">!             return XMLDocument::createXHTML(nullptr, url());</span>
<span class="line-modified">!         return XMLDocument::create(nullptr, url());</span>
      }
<span class="line-modified">!     return create(url());</span>
  }
  
  void Document::cloneDataFromDocument(const Document&amp; other)
  {
      ASSERT(m_url == other.url());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3921,58 ***</span>
      if (!m_styleSheetList)
          m_styleSheetList = StyleSheetList::create(*this);
      return *m_styleSheetList;
  }
  
<span class="line-modified">! void Document::evaluateMediaQueryList()</span>
  {
<span class="line-modified">!     if (m_mediaQueryMatcher)</span>
<span class="line-removed">-         m_mediaQueryMatcher-&gt;styleResolverChanged();</span>
  
<span class="line-modified">!     checkViewportDependentPictures();</span>
<span class="line-modified">!     checkAppearanceDependentPictures();</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void Document::checkViewportDependentPictures()</span>
<span class="line-modified">! {</span>
<span class="line-removed">-     Vector&lt;HTMLPictureElement*, 16&gt; changedPictures;</span>
<span class="line-removed">-     HashSet&lt;HTMLPictureElement*&gt;::iterator end = m_viewportDependentPictures.end();</span>
<span class="line-removed">-     for (HashSet&lt;HTMLPictureElement*&gt;::iterator it = m_viewportDependentPictures.begin(); it != end; ++it) {</span>
<span class="line-removed">-         if ((*it)-&gt;viewportChangeAffectedPicture())</span>
<span class="line-removed">-             changedPictures.append(*it);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     for (auto* picture : changedPictures)</span>
<span class="line-removed">-         picture-&gt;sourcesChanged();</span>
  }
  
<span class="line-modified">! void Document::checkAppearanceDependentPictures()</span>
  {
<span class="line-modified">!     Vector&lt;HTMLPictureElement*, 16&gt; changedPictures;</span>
<span class="line-modified">!     for (auto* picture : m_appearanceDependentPictures) {</span>
<span class="line-removed">-         if (picture-&gt;appearanceChangeAffectedPicture())</span>
<span class="line-removed">-             changedPictures.append(picture);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     for (auto* picture : changedPictures)</span>
<span class="line-removed">-         picture-&gt;sourcesChanged();</span>
  }
  
  void Document::updateViewportUnitsOnResize()
  {
      if (!hasStyleWithViewportUnits())
          return;
  
<span class="line-modified">!     styleScope().resolver().clearCachedPropertiesAffectedByViewportUnits();</span>
  
      // FIXME: Ideally, we should save the list of elements that have viewport units and only iterate over those.
      for (Element* element = ElementTraversal::firstWithin(rootNode()); element; element = ElementTraversal::nextIncludingPseudo(*element)) {
          auto* renderer = element-&gt;renderer();
          if (renderer &amp;&amp; renderer-&gt;style().hasViewportUnits())
              element-&gt;invalidateStyle();
      }
  }
  
  void Document::addAudioProducer(MediaProducer&amp; audioProducer)
  {
      m_audioProducers.add(audioProducer);
      updateIsPlayingMedia();
  }
<span class="line-new-header">--- 4027,118 ---</span>
      if (!m_styleSheetList)
          m_styleSheetList = StyleSheetList::create(*this);
      return *m_styleSheetList;
  }
  
<span class="line-modified">! void Document::updateElementsAffectedByMediaQueries()</span>
  {
<span class="line-modified">!     ScriptDisallowedScope::InMainThread scriptDisallowedScope;</span>
  
<span class="line-modified">!     // FIXME: copyToVector doesn&#39;t work with WeakHashSet</span>
<span class="line-modified">!     Vector&lt;Ref&lt;HTMLImageElement&gt;&gt; images;</span>
<span class="line-modified">!     images.reserveInitialCapacity(m_dynamicMediaQueryDependentImages.computeSize());</span>
<span class="line-added">+     for (auto&amp; image : m_dynamicMediaQueryDependentImages)</span>
<span class="line-added">+         images.append(image);</span>
  
<span class="line-modified">!     for (auto&amp; image : images)</span>
<span class="line-modified">!         image-&gt;evaluateDynamicMediaQueryDependencies();</span>
  }
  
<span class="line-modified">! void Document::evaluateMediaQueriesAndReportChanges()</span>
  {
<span class="line-modified">!     if (!m_mediaQueryMatcher)</span>
<span class="line-modified">!         return;</span>
  
<span class="line-modified">!     m_mediaQueryMatcher-&gt;evaluateAll();</span>
  }
  
  void Document::updateViewportUnitsOnResize()
  {
      if (!hasStyleWithViewportUnits())
          return;
  
<span class="line-modified">!     styleScope().resolver().clearCachedDeclarationsAffectedByViewportUnits();</span>
  
      // FIXME: Ideally, we should save the list of elements that have viewport units and only iterate over those.
      for (Element* element = ElementTraversal::firstWithin(rootNode()); element; element = ElementTraversal::nextIncludingPseudo(*element)) {
          auto* renderer = element-&gt;renderer();
          if (renderer &amp;&amp; renderer-&gt;style().hasViewportUnits())
              element-&gt;invalidateStyle();
      }
  }
  
<span class="line-added">+ void Document::setNeedsDOMWindowResizeEvent()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_needsDOMWindowResizeEvent = true;</span>
<span class="line-added">+     scheduleTimedRenderingUpdate();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Document::setNeedsVisualViewportResize()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_needsVisualViewportResizeEvent = true;</span>
<span class="line-added">+     scheduleTimedRenderingUpdate();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // https://drafts.csswg.org/cssom-view/#run-the-resize-steps</span>
<span class="line-added">+ void Document::runResizeSteps()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // FIXME: The order of dispatching is not specified: https://github.com/WICG/visual-viewport/issues/65.</span>
<span class="line-added">+     if (m_needsDOMWindowResizeEvent) {</span>
<span class="line-added">+         LOG_WITH_STREAM(Events, stream &lt;&lt; &quot;Document&quot; &lt;&lt; this &lt;&lt; &quot;sending resize events to window&quot;);</span>
<span class="line-added">+         m_needsDOMWindowResizeEvent = false;</span>
<span class="line-added">+         dispatchWindowEvent(Event::create(eventNames().resizeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (m_needsVisualViewportResizeEvent) {</span>
<span class="line-added">+         LOG_WITH_STREAM(Events, stream &lt;&lt; &quot;Document&quot; &lt;&lt; this &lt;&lt; &quot;sending resize events to visualViewport&quot;);</span>
<span class="line-added">+         m_needsVisualViewportResizeEvent = false;</span>
<span class="line-added">+         if (auto* window = domWindow())</span>
<span class="line-added">+             window-&gt;visualViewport().dispatchEvent(Event::create(eventNames().resizeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Document::addPendingScrollEventTarget(ContainerNode&amp; target)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_pendingScrollEventTargetList)</span>
<span class="line-added">+         m_pendingScrollEventTargetList = makeUnique&lt;PendingScrollEventTargetList&gt;();</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto&amp; targets = m_pendingScrollEventTargetList-&gt;targets;</span>
<span class="line-added">+     if (targets.findMatching([&amp;] (auto&amp; entry) { return entry.ptr() == &amp;target; }) != notFound)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (targets.isEmpty())</span>
<span class="line-added">+         scheduleTimedRenderingUpdate();</span>
<span class="line-added">+ </span>
<span class="line-added">+     targets.append(target);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Document::setNeedsVisualViewportScrollEvent()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_needsVisualViewportScrollEvent)</span>
<span class="line-added">+         scheduleTimedRenderingUpdate();</span>
<span class="line-added">+     m_needsVisualViewportScrollEvent = true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // https://drafts.csswg.org/cssom-view/#run-the-scroll-steps</span>
<span class="line-added">+ void Document::runScrollSteps()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // FIXME: The order of dispatching is not specified: https://github.com/WICG/visual-viewport/issues/66.</span>
<span class="line-added">+     if (m_pendingScrollEventTargetList &amp;&amp; !m_pendingScrollEventTargetList-&gt;targets.isEmpty()) {</span>
<span class="line-added">+         LOG_WITH_STREAM(Events, stream &lt;&lt; &quot;Document&quot; &lt;&lt; this &lt;&lt; &quot;sending scroll events to pending scroll event targets&quot;);</span>
<span class="line-added">+         auto currentTargets = WTFMove(m_pendingScrollEventTargetList-&gt;targets);</span>
<span class="line-added">+         for (auto&amp; target : currentTargets) {</span>
<span class="line-added">+             auto bubbles = target-&gt;isDocumentNode() ? Event::CanBubble::Yes : Event::CanBubble::No;</span>
<span class="line-added">+             target-&gt;dispatchEvent(Event::create(eventNames().scrollEvent, bubbles, Event::IsCancelable::No));</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (m_needsVisualViewportScrollEvent) {</span>
<span class="line-added">+         LOG_WITH_STREAM(Events, stream &lt;&lt; &quot;Document&quot; &lt;&lt; this &lt;&lt; &quot;sending scroll events to visualViewport&quot;);</span>
<span class="line-added">+         m_needsVisualViewportResizeEvent = false;</span>
<span class="line-added">+         if (auto* window = domWindow())</span>
<span class="line-added">+             window-&gt;visualViewport().dispatchEvent(Event::create(eventNames().scrollEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Document::addAudioProducer(MediaProducer&amp; audioProducer)
  {
      m_audioProducers.add(audioProducer);
      updateIsPlayingMedia();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4001,12 ***</span>
      ASSERT(!m_audioProducers.hasNullReferences());
      MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
      for (auto&amp; audioProducer : m_audioProducers)
          state |= audioProducer.mediaState();
  
<span class="line-modified">! #if ENABLE(MEDIA_STREAM) &amp;&amp; PLATFORM(IOS_FAMILY)</span>
<span class="line-modified">!     state |= MediaStreamTrack::captureState();</span>
  #endif
  
  #if ENABLE(MEDIA_SESSION)
      if (HTMLMediaElement* sourceElement = HTMLMediaElement::elementWithID(sourceElementID)) {
          if (sourceElement-&gt;isPlaying())
<span class="line-new-header">--- 4167,12 ---</span>
      ASSERT(!m_audioProducers.hasNullReferences());
      MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
      for (auto&amp; audioProducer : m_audioProducers)
          state |= audioProducer.mediaState();
  
<span class="line-modified">! #if ENABLE(MEDIA_STREAM)</span>
<span class="line-modified">!     state |= MediaStreamTrack::captureState(*this);</span>
  #endif
  
  #if ENABLE(MEDIA_SESSION)
      if (HTMLMediaElement* sourceElement = HTMLMediaElement::elementWithID(sourceElementID)) {
          if (sourceElement-&gt;isPlaying())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4047,12 ***</span>
  void Document::pageMutedStateDidChange()
  {
      for (auto&amp; audioProducer : m_audioProducers)
          audioProducer.pageMutedStateDidChange();
  
<span class="line-modified">! #if ENABLE(MEDIA_STREAM) &amp;&amp; PLATFORM(IOS_FAMILY)</span>
<span class="line-modified">!     MediaStreamTrack::muteCapture();</span>
  #endif
  }
  
  static bool isNodeInSubtree(Node&amp; node, Node&amp; container, Document::NodeRemoval nodeRemoval)
  {
<span class="line-new-header">--- 4213,12 ---</span>
  void Document::pageMutedStateDidChange()
  {
      for (auto&amp; audioProducer : m_audioProducers)
          audioProducer.pageMutedStateDidChange();
  
<span class="line-modified">! #if ENABLE(MEDIA_STREAM)</span>
<span class="line-modified">!     MediaStreamTrack::updateCaptureAccordingToMutedState(*this);</span>
  #endif
  }
  
  static bool isNodeInSubtree(Node&amp; node, Node&amp; container, Document::NodeRemoval nodeRemoval)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4062,11 ***</span>
      return &amp;node == &amp;container || node.isDescendantOf(container);
  }
  
  void Document::adjustFocusedNodeOnNodeRemoval(Node&amp; node, NodeRemoval nodeRemoval)
  {
<span class="line-modified">!     if (!m_focusedElement || pageCacheState() != NotInPageCache) // If the document is in the page cache, then we don&#39;t need to clear out the focused node.</span>
          return;
  
      Element* focusedElement = node.treeScope().focusedElementInScope();
      if (!focusedElement)
          return;
<span class="line-new-header">--- 4228,11 ---</span>
      return &amp;node == &amp;container || node.isDescendantOf(container);
  }
  
  void Document::adjustFocusedNodeOnNodeRemoval(Node&amp; node, NodeRemoval nodeRemoval)
  {
<span class="line-modified">!     if (!m_focusedElement || backForwardCacheState() != NotInBackForwardCache) // If the document is in the back/forward cache, then we don&#39;t need to clear out the focused node.</span>
          return;
  
      Element* focusedElement = node.treeScope().focusedElementInScope();
      if (!focusedElement)
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4130,11 ***</span>
          return true;
  
      if (m_focusedElement == newFocusedElement)
          return true;
  
<span class="line-modified">!     if (pageCacheState() != NotInPageCache)</span>
          return false;
  
      bool focusChangeBlocked = false;
      RefPtr&lt;Element&gt; oldFocusedElement = WTFMove(m_focusedElement);
  
<span class="line-new-header">--- 4296,11 ---</span>
          return true;
  
      if (m_focusedElement == newFocusedElement)
          return true;
  
<span class="line-modified">!     if (backForwardCacheState() != NotInBackForwardCache)</span>
          return false;
  
      bool focusChangeBlocked = false;
      RefPtr&lt;Element&gt; oldFocusedElement = WTFMove(m_focusedElement);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4198,10 ***</span>
<span class="line-new-header">--- 4364,15 ---</span>
              downcast&lt;HTMLInputElement&gt;(*oldFocusedElement).didBlur();
          }
      }
  
      if (newFocusedElement &amp;&amp; newFocusedElement-&gt;isFocusable()) {
<span class="line-added">+         if (&amp;newFocusedElement-&gt;document() != this) {</span>
<span class="line-added">+             // Bluring oldFocusedElement may have moved newFocusedElement across documents.</span>
<span class="line-added">+             focusChangeBlocked = true;</span>
<span class="line-added">+             goto SetFocusedNodeDone;</span>
<span class="line-added">+         }</span>
          if (newFocusedElement-&gt;isRootEditableElement() &amp;&amp; !acceptsEditingFocus(*newFocusedElement)) {
              // delegate blocks focus change
              focusChangeBlocked = true;
              goto SetFocusedNodeDone;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4570,11 ***</span>
  {
      ASSERT(m_frame);
      ASSERT(!m_domWindow);
      ASSERT(document.m_domWindow);
      // A valid DOMWindow is needed by CachedFrame for its documents.
<span class="line-modified">!     ASSERT(pageCacheState() == NotInPageCache);</span>
  
      m_domWindow = WTFMove(document.m_domWindow);
      m_domWindow-&gt;didSecureTransitionTo(*this);
  
      ASSERT(m_domWindow-&gt;document() == this);
<span class="line-new-header">--- 4741,11 ---</span>
  {
      ASSERT(m_frame);
      ASSERT(!m_domWindow);
      ASSERT(document.m_domWindow);
      // A valid DOMWindow is needed by CachedFrame for its documents.
<span class="line-modified">!     ASSERT(backForwardCacheState() == NotInBackForwardCache);</span>
  
      m_domWindow = WTFMove(document.m_domWindow);
      m_domWindow-&gt;didSecureTransitionTo(*this);
  
      ASSERT(m_domWindow-&gt;document() == this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4609,10 ***</span>
<span class="line-new-header">--- 4780,12 ---</span>
  
  void Document::setWindowAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)
  {
      if (!m_domWindow)
          return;
<span class="line-added">+     if (!m_domWindow-&gt;frame())</span>
<span class="line-added">+         return;</span>
      setWindowAttributeEventListener(eventType, JSLazyEventListener::create(*m_domWindow, attributeName, attributeValue), isolatedWorld);
  }
  
  EventListener* Document::getWindowAttributeEventListener(const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4637,25 ***</span>
      m_domWindow-&gt;dispatchLoadEvent();
      m_loadEventFinished = true;
      m_cachedResourceLoader-&gt;documentDidFinishLoadEvent();
  }
  
<span class="line-modified">! void Document::enqueueWindowEvent(Ref&lt;Event&gt;&amp;&amp; event)</span>
  {
<span class="line-modified">!     event-&gt;setTarget(m_domWindow.get());</span>
<span class="line-modified">!     m_eventQueue.enqueueEvent(WTFMove(event));</span>
  }
  
<span class="line-modified">! void Document::enqueueDocumentEvent(Ref&lt;Event&gt;&amp;&amp; event)</span>
  {
<span class="line-modified">!     event-&gt;setTarget(this);</span>
<span class="line-modified">!     m_eventQueue.enqueueEvent(WTFMove(event));</span>
  }
  
  void Document::enqueueOverflowEvent(Ref&lt;Event&gt;&amp;&amp; event)
  {
<span class="line-modified">!     m_eventQueue.enqueueEvent(WTFMove(event));</span>
  }
  
  ExceptionOr&lt;Ref&lt;Event&gt;&gt; Document::createEvent(const String&amp; type)
  {
      // Please do *not* add new event classes to this function unless they are required
<span class="line-new-header">--- 4810,36 ---</span>
      m_domWindow-&gt;dispatchLoadEvent();
      m_loadEventFinished = true;
      m_cachedResourceLoader-&gt;documentDidFinishLoadEvent();
  }
  
<span class="line-modified">! void Document::queueTaskToDispatchEvent(TaskSource source, Ref&lt;Event&gt;&amp;&amp; event)</span>
  {
<span class="line-modified">!     eventLoop().queueTask(source, [document = makeRef(*this), event = WTFMove(event)] {</span>
<span class="line-modified">!         document-&gt;dispatchEvent(event);</span>
<span class="line-added">+     });</span>
  }
  
<span class="line-modified">! void Document::queueTaskToDispatchEventOnWindow(TaskSource source, Ref&lt;Event&gt;&amp;&amp; event)</span>
  {
<span class="line-modified">!     eventLoop().queueTask(source, [this, protectedThis = makeRef(*this), event = WTFMove(event)] {</span>
<span class="line-modified">!         if (!m_domWindow)</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         m_domWindow-&gt;dispatchEvent(event);</span>
<span class="line-added">+     });</span>
  }
  
  void Document::enqueueOverflowEvent(Ref&lt;Event&gt;&amp;&amp; event)
  {
<span class="line-modified">!     // https://developer.mozilla.org/en-US/docs/Web/API/Element/overflow_event</span>
<span class="line-added">+     // FIXME: This event is totally unspecified.</span>
<span class="line-added">+     auto* target = event-&gt;target();</span>
<span class="line-added">+     RELEASE_ASSERT(target);</span>
<span class="line-added">+     RELEASE_ASSERT(is&lt;Node&gt;(target));</span>
<span class="line-added">+     eventLoop().queueTask(TaskSource::DOMManipulation, [protectedTarget = GCReachableRef&lt;Node&gt;(downcast&lt;Node&gt;(*target)), event = WTFMove(event)] {</span>
<span class="line-added">+         protectedTarget-&gt;dispatchEvent(event);</span>
<span class="line-added">+     });</span>
  }
  
  ExceptionOr&lt;Ref&lt;Event&gt;&gt; Document::createEvent(const String&amp; type)
  {
      // Please do *not* add new event classes to this function unless they are required
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4671,10 ***</span>
<span class="line-new-header">--- 4855,12 ---</span>
          return Ref&lt;Event&gt; { BeforeUnloadEvent::createForBindings() };
      if (equalLettersIgnoringASCIICase(type, &quot;compositionevent&quot;))
          return Ref&lt;Event&gt; { CompositionEvent::createForBindings() };
      if (equalLettersIgnoringASCIICase(type, &quot;customevent&quot;))
          return Ref&lt;Event&gt; { CustomEvent::create() };
<span class="line-added">+     if (equalLettersIgnoringASCIICase(type, &quot;dragevent&quot;))</span>
<span class="line-added">+         return Ref&lt;Event&gt; { DragEvent::createForBindings() };</span>
      if (equalLettersIgnoringASCIICase(type, &quot;event&quot;) || equalLettersIgnoringASCIICase(type, &quot;events&quot;) || equalLettersIgnoringASCIICase(type, &quot;htmlevents&quot;) || equalLettersIgnoringASCIICase(type, &quot;svgevents&quot;))
          return Event::createForBindings();
      if (equalLettersIgnoringASCIICase(type, &quot;focusevent&quot;))
          return Ref&lt;Event&gt; { FocusEvent::createForBindings() };
      if (equalLettersIgnoringASCIICase(type, &quot;hashchangeevent&quot;))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4858,26 ***</span>
      if (page())
          page()-&gt;cookieJar().setCookies(*this, cookieURL, value);
      return { };
  }
  
<span class="line-modified">! String Document::referrer() const</span>
  {
  #if ENABLE(RESOURCE_LOAD_STATISTICS)
      if (!m_referrerOverride.isEmpty())
          return m_referrerOverride;
  #endif
      if (frame())
          return frame()-&gt;loader().referrer();
      return String();
  }
  
<span class="line-removed">- String Document::origin() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return securityOrigin().toString();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  String Document::domain() const
  {
      return securityOrigin().domain();
  }
  
<span class="line-new-header">--- 5044,32 ---</span>
      if (page())
          page()-&gt;cookieJar().setCookies(*this, cookieURL, value);
      return { };
  }
  
<span class="line-modified">! String Document::referrer()</span>
  {
  #if ENABLE(RESOURCE_LOAD_STATISTICS)
      if (!m_referrerOverride.isEmpty())
          return m_referrerOverride;
<span class="line-added">+     if (DeprecatedGlobalSettings::resourceLoadStatisticsEnabled() &amp;&amp; frame()) {</span>
<span class="line-added">+         auto referrerStr = frame()-&gt;loader().referrer();</span>
<span class="line-added">+         if (!referrerStr.isEmpty()) {</span>
<span class="line-added">+             URL referrerURL { URL(), referrerStr };</span>
<span class="line-added">+             RegistrableDomain referrerRegistrableDomain { referrerURL };</span>
<span class="line-added">+             if (!referrerRegistrableDomain.matches(securityOrigin().data())) {</span>
<span class="line-added">+                 m_referrerOverride = referrerURL.protocolHostAndPort();</span>
<span class="line-added">+                 return m_referrerOverride;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  #endif
      if (frame())
          return frame()-&gt;loader().referrer();
      return String();
  }
  
  String Document::domain() const
  {
      return securityOrigin().domain();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4887,11 ***</span>
          return Exception { SecurityError, &quot;A browsing context is required to set a domain.&quot; };
  
      if (isSandboxed(SandboxDocumentDomain))
          return Exception { SecurityError, &quot;Assignment is forbidden for sandboxed iframes.&quot; };
  
<span class="line-modified">!     if (SchemeRegistry::isDomainRelaxationForbiddenForURLScheme(securityOrigin().protocol()))</span>
          return Exception { SecurityError };
  
      // FIXME: We should add logging indicating why a domain was not allowed.
  
      const String&amp; effectiveDomain = domain();
<span class="line-new-header">--- 5079,11 ---</span>
          return Exception { SecurityError, &quot;A browsing context is required to set a domain.&quot; };
  
      if (isSandboxed(SandboxDocumentDomain))
          return Exception { SecurityError, &quot;Assignment is forbidden for sandboxed iframes.&quot; };
  
<span class="line-modified">!     if (LegacySchemeRegistry::isDomainRelaxationForbiddenForURLScheme(securityOrigin().protocol()))</span>
          return Exception { SecurityError };
  
      // FIXME: We should add logging indicating why a domain was not allowed.
  
      const String&amp; effectiveDomain = domain();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5063,48 ***</span>
  void Document::setDecoder(RefPtr&lt;TextResourceDecoder&gt;&amp;&amp; decoder)
  {
      m_decoder = WTFMove(decoder);
  }
  
<span class="line-modified">! URL Document::completeURL(const String&amp; url, const URL&amp; baseURLOverride) const</span>
  {
      // Always return a null URL when passed a null string.
      // FIXME: Should we change the URL constructor to have this behavior?
      // See also [CSS]StyleSheet::completeURL(const String&amp;)
      if (url.isNull())
          return URL();
      const URL&amp; baseURL = ((baseURLOverride.isEmpty() || baseURLOverride == WTF::blankURL()) &amp;&amp; parentDocument()) ? parentDocument()-&gt;baseURL() : baseURLOverride;
<span class="line-modified">!     if (!m_decoder)</span>
          return URL(baseURL, url);
      return URL(baseURL, url, m_decoder-&gt;encodingForURLParsing());
  }
  
<span class="line-modified">! URL Document::completeURL(const String&amp; url) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return completeURL(url, m_baseURL);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- PAL::SessionID Document::sessionID() const</span>
  {
<span class="line-modified">!     return m_sessionID;</span>
  }
  
<span class="line-modified">! void Document::setPageCacheState(PageCacheState state)</span>
  {
<span class="line-modified">!     if (m_pageCacheState == state)</span>
          return;
  
<span class="line-modified">!     m_pageCacheState = state;</span>
  
      FrameView* v = view();
      Page* page = this-&gt;page();
  
      switch (state) {
<span class="line-modified">!     case InPageCache:</span>
          if (v) {
              // FIXME: There is some scrolling related work that needs to happen whenever a page goes into the
<span class="line-modified">!             // page cache and similar work that needs to occur when it comes out. This is where we do the work</span>
              // that needs to happen when we enter, and the work that needs to happen when we exit is in
              // HistoryController::restoreScrollPositionAndViewState(). It can&#39;t be here because this function is
              // called too early on in the process of a page exiting the cache for that work to be possible in this
              // function. It would be nice if there was more symmetry here.
              // https://bugs.webkit.org/show_bug.cgi?id=98698
<span class="line-new-header">--- 5255,43 ---</span>
  void Document::setDecoder(RefPtr&lt;TextResourceDecoder&gt;&amp;&amp; decoder)
  {
      m_decoder = WTFMove(decoder);
  }
  
<span class="line-modified">! URL Document::completeURL(const String&amp; url, const URL&amp; baseURLOverride, ForceUTF8 forceUTF8) const</span>
  {
      // Always return a null URL when passed a null string.
      // FIXME: Should we change the URL constructor to have this behavior?
      // See also [CSS]StyleSheet::completeURL(const String&amp;)
      if (url.isNull())
          return URL();
      const URL&amp; baseURL = ((baseURLOverride.isEmpty() || baseURLOverride == WTF::blankURL()) &amp;&amp; parentDocument()) ? parentDocument()-&gt;baseURL() : baseURLOverride;
<span class="line-modified">!     if (!m_decoder || forceUTF8 == ForceUTF8::Yes)</span>
          return URL(baseURL, url);
      return URL(baseURL, url, m_decoder-&gt;encodingForURLParsing());
  }
  
<span class="line-modified">! URL Document::completeURL(const String&amp; url, ForceUTF8 forceUTF8) const</span>
  {
<span class="line-modified">!     return completeURL(url, m_baseURL, forceUTF8);</span>
  }
  
<span class="line-modified">! void Document::setBackForwardCacheState(BackForwardCacheState state)</span>
  {
<span class="line-modified">!     if (m_backForwardCacheState == state)</span>
          return;
  
<span class="line-modified">!     m_backForwardCacheState = state;</span>
  
      FrameView* v = view();
      Page* page = this-&gt;page();
  
      switch (state) {
<span class="line-modified">!     case InBackForwardCache:</span>
          if (v) {
              // FIXME: There is some scrolling related work that needs to happen whenever a page goes into the
<span class="line-modified">!             // back/forward cache and similar work that needs to occur when it comes out. This is where we do the work</span>
              // that needs to happen when we enter, and the work that needs to happen when we exit is in
              // HistoryController::restoreScrollPositionAndViewState(). It can&#39;t be here because this function is
              // called too early on in the process of a page exiting the cache for that work to be possible in this
              // function. It would be nice if there was more symmetry here.
              // https://bugs.webkit.org/show_bug.cgi?id=98698
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5123,16 ***</span>
          styleScope().clearResolver();
          clearSelectorQueryCache();
          m_styleRecalcTimer.stop();
  
          clearSharedObjectPool();
          break;
<span class="line-modified">!     case NotInPageCache:</span>
          if (childNeedsStyleRecalc())
              scheduleStyleRecalc();
          break;
<span class="line-modified">!     case AboutToEnterPageCache:</span>
          break;
      }
  }
  
  void Document::documentWillBecomeInactive()
<span class="line-new-header">--- 5310,25 ---</span>
          styleScope().clearResolver();
          clearSelectorQueryCache();
          m_styleRecalcTimer.stop();
  
          clearSharedObjectPool();
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(INDEXED_DATABASE)</span>
<span class="line-added">+         if (m_idbConnectionProxy)</span>
<span class="line-added">+             m_idbConnectionProxy-&gt;setContextSuspended(*scriptExecutionContext(), true);</span>
<span class="line-added">+ #endif</span>
          break;
<span class="line-modified">!     case NotInBackForwardCache:</span>
          if (childNeedsStyleRecalc())
              scheduleStyleRecalc();
<span class="line-added">+ #if ENABLE(INDEXED_DATABASE)</span>
<span class="line-added">+         if (m_idbConnectionProxy)</span>
<span class="line-added">+             m_idbConnectionProxy-&gt;setContextSuspended(*scriptExecutionContext(), false);</span>
<span class="line-added">+ #endif</span>
          break;
<span class="line-modified">!     case AboutToEnterBackForwardCache:</span>
          break;
      }
  }
  
  void Document::documentWillBecomeInactive()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5149,13 ***</span>
      documentWillBecomeInactive();
  
      for (auto* element : m_documentSuspensionCallbackElements)
          element-&gt;prepareForDocumentSuspension();
  
<span class="line-modified">! #ifndef NDEBUG</span>
      // Clear the update flag to be able to check if the viewport arguments update
<span class="line-modified">!     // is dispatched, after the document is restored from the page cache.</span>
      m_didDispatchViewportPropertiesChanged = false;
  #endif
  
      ASSERT(page());
      page()-&gt;lockAllOverlayScrollbarsToHidden(true);
<span class="line-new-header">--- 5345,13 ---</span>
      documentWillBecomeInactive();
  
      for (auto* element : m_documentSuspensionCallbackElements)
          element-&gt;prepareForDocumentSuspension();
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      // Clear the update flag to be able to check if the viewport arguments update
<span class="line-modified">!     // is dispatched, after the document is restored from the back/forward cache.</span>
      m_didDispatchViewportPropertiesChanged = false;
  #endif
  
      ASSERT(page());
      page()-&gt;lockAllOverlayScrollbarsToHidden(true);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5172,14 ***</span>
              page-&gt;libWebRTCProvider().unregisterMDNSNames(identifier().toUInt64());
      }
  #endif
  
  #if ENABLE(SERVICE_WORKER)
<span class="line-modified">!     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; reason == ReasonForSuspension::PageCache) {</span>
<span class="line-removed">-         ASSERT_WITH_MESSAGE(!activeServiceWorker(), &quot;Documents with an active service worker should not go into PageCache in the first place&quot;);</span>
          setServiceWorkerConnection(nullptr);
<span class="line-removed">-     }</span>
  #endif
  
      suspendScheduledTasks(reason);
  
      ASSERT(m_frame);
<span class="line-new-header">--- 5368,12 ---</span>
              page-&gt;libWebRTCProvider().unregisterMDNSNames(identifier().toUInt64());
      }
  #endif
  
  #if ENABLE(SERVICE_WORKER)
<span class="line-modified">!     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; reason == ReasonForSuspension::BackForwardCache)</span>
          setServiceWorkerConnection(nullptr);
  #endif
  
      suspendScheduledTasks(reason);
  
      ASSERT(m_frame);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5219,14 ***</span>
      m_visualUpdatesAllowed = true;
  
      m_isSuspended = false;
  
  #if ENABLE(SERVICE_WORKER)
<span class="line-modified">!     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; reason == ReasonForSuspension::PageCache) {</span>
<span class="line-modified">!         ASSERT_WITH_MESSAGE(!activeServiceWorker(), &quot;Documents with an active service worker should not go into PageCache in the first place&quot;);</span>
<span class="line-removed">-         setServiceWorkerConnection(ServiceWorkerProvider::singleton().existingServiceWorkerConnectionForSession(sessionID()));</span>
<span class="line-removed">-     }</span>
  #endif
  }
  
  void Document::registerForDocumentSuspensionCallbacks(Element&amp; element)
  {
<span class="line-new-header">--- 5413,12 ---</span>
      m_visualUpdatesAllowed = true;
  
      m_isSuspended = false;
  
  #if ENABLE(SERVICE_WORKER)
<span class="line-modified">!     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; reason == ReasonForSuspension::BackForwardCache)</span>
<span class="line-modified">!         setServiceWorkerConnection(&amp;ServiceWorkerProvider::singleton().serviceWorkerConnection());</span>
  #endif
  }
  
  void Document::registerForDocumentSuspensionCallbacks(Element&amp; element)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5236,26 ***</span>
  void Document::unregisterForDocumentSuspensionCallbacks(Element&amp; element)
  {
      m_documentSuspensionCallbackElements.remove(&amp;element);
  }
  
<span class="line-removed">- void Document::mediaVolumeDidChange()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     for (auto* element : m_mediaVolumeCallbackElements)</span>
<span class="line-removed">-         element-&gt;mediaVolumeDidChange();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::registerForMediaVolumeCallbacks(Element&amp; element)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_mediaVolumeCallbackElements.add(&amp;element);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::unregisterForMediaVolumeCallbacks(Element&amp; element)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_mediaVolumeCallbackElements.remove(&amp;element);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool Document::audioPlaybackRequiresUserGesture() const
  {
      if (DocumentLoader* loader = this-&gt;loader()) {
          // If an audio playback policy was set during navigation, use it. If not, use the global settings.
          AutoplayPolicy policy = loader-&gt;autoplayPolicy();
<span class="line-new-header">--- 5428,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5276,51 ***</span>
      }
  
      return settings().videoPlaybackRequiresUserGesture();
  }
  
  void Document::storageBlockingStateDidChange()
  {
      securityOrigin().setStorageBlockingPolicy(settings().storageBlockingPolicy());
  }
  
  void Document::privateBrowsingStateDidChange(PAL::SessionID sessionID)
  {
<span class="line-removed">-     m_sessionID = sessionID;</span>
      if (m_logger)
          m_logger-&gt;setEnabled(this, sessionID.isAlwaysOnLoggingAllowed());
  
<span class="line-modified">!     for (auto* element : m_privateBrowsingStateChangedElements)</span>
<span class="line-modified">!         element-&gt;privateBrowsingStateDidChange(sessionID);</span>
<span class="line-modified">! </span>
<span class="line-modified">! #if ENABLE(SERVICE_WORKER)</span>
<span class="line-removed">-     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; m_serviceWorkerConnection)</span>
<span class="line-removed">-         setServiceWorkerConnection(&amp;ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(sessionID));</span>
  #endif
  }
  
<span class="line-removed">- void Document::registerForPrivateBrowsingStateChangedCallbacks(Element&amp; element)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_privateBrowsingStateChangedElements.add(&amp;element);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::unregisterForPrivateBrowsingStateChangedCallbacks(Element&amp; element)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_privateBrowsingStateChangedElements.remove(&amp;element);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  #if ENABLE(VIDEO_TRACK)
  
<span class="line-modified">! void Document::registerForCaptionPreferencesChangedCallbacks(Element&amp; element)</span>
  {
      if (page())
          page()-&gt;group().captionPreferences().setInterestedInCaptionPreferenceChanges();
  
      m_captionPreferencesChangedElements.add(&amp;element);
  }
  
<span class="line-modified">! void Document::unregisterForCaptionPreferencesChangedCallbacks(Element&amp; element)</span>
  {
      m_captionPreferencesChangedElements.remove(&amp;element);
  }
  
  void Document::captionPreferencesChanged()
<span class="line-new-header">--- 5452,50 ---</span>
      }
  
      return settings().videoPlaybackRequiresUserGesture();
  }
  
<span class="line-added">+ bool Document::mediaDataLoadsAutomatically() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (auto* loader = this-&gt;loader()) {</span>
<span class="line-added">+         AutoplayPolicy policy = loader-&gt;autoplayPolicy();</span>
<span class="line-added">+         if (policy != AutoplayPolicy::Default)</span>
<span class="line-added">+             return policy != AutoplayPolicy::Deny;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return settings().mediaDataLoadsAutomatically();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Document::storageBlockingStateDidChange()
  {
      securityOrigin().setStorageBlockingPolicy(settings().storageBlockingPolicy());
  }
  
<span class="line-added">+ // Used only by WebKitLegacy.</span>
  void Document::privateBrowsingStateDidChange(PAL::SessionID sessionID)
  {
      if (m_logger)
          m_logger-&gt;setEnabled(this, sessionID.isAlwaysOnLoggingAllowed());
  
<span class="line-modified">! #if ENABLE(VIDEO)</span>
<span class="line-modified">!     forEachMediaElement([sessionID] (HTMLMediaElement&amp; element) {</span>
<span class="line-modified">!         element.privateBrowsingStateDidChange(sessionID);</span>
<span class="line-modified">!     });</span>
  #endif
  }
  
  #if ENABLE(VIDEO_TRACK)
  
<span class="line-modified">! void Document::registerForCaptionPreferencesChangedCallbacks(HTMLMediaElement&amp; element)</span>
  {
      if (page())
          page()-&gt;group().captionPreferences().setInterestedInCaptionPreferenceChanges();
  
      m_captionPreferencesChangedElements.add(&amp;element);
  }
  
<span class="line-modified">! void Document::unregisterForCaptionPreferencesChangedCallbacks(HTMLMediaElement&amp; element)</span>
  {
      m_captionPreferencesChangedElements.remove(&amp;element);
  }
  
  void Document::captionPreferencesChanged()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5329,46 ***</span>
          element-&gt;captionPreferencesChanged();
  }
  
  #endif
  
<span class="line-removed">- #if ENABLE(MEDIA_CONTROLS_SCRIPT)</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::registerForPageScaleFactorChangedCallbacks(HTMLMediaElement&amp; element)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_pageScaleFactorChangedElements.add(&amp;element);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::unregisterForPageScaleFactorChangedCallbacks(HTMLMediaElement&amp; element)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_pageScaleFactorChangedElements.remove(&amp;element);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::pageScaleFactorChangedAndStable()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     for (HTMLMediaElement* mediaElement : m_pageScaleFactorChangedElements)</span>
<span class="line-removed">-         mediaElement-&gt;pageScaleFactorChanged();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::registerForUserInterfaceLayoutDirectionChangedCallbacks(HTMLMediaElement&amp; element)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_userInterfaceLayoutDirectionChangedElements.add(&amp;element);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::unregisterForUserInterfaceLayoutDirectionChangedCallbacks(HTMLMediaElement&amp; element)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_userInterfaceLayoutDirectionChangedElements.remove(&amp;element);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::userInterfaceLayoutDirectionChanged()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     for (auto* mediaElement : m_userInterfaceLayoutDirectionChangedElements)</span>
<span class="line-removed">-         mediaElement-&gt;userInterfaceLayoutDirectionChanged();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  void Document::setShouldCreateRenderers(bool f)
  {
      m_createRenderers = f;
  }
  
<span class="line-new-header">--- 5504,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5546,11 ***</span>
  
  Document&amp; Document::topDocument() const
  {
      // FIXME: This special-casing avoids incorrectly determined top documents during the process
      // of AXObjectCache teardown or notification posting for cached or being-destroyed documents.
<span class="line-modified">!     if (pageCacheState() == NotInPageCache &amp;&amp; !m_renderTreeBeingDestroyed) {</span>
          if (!m_frame)
              return const_cast&lt;Document&amp;&gt;(*this);
          // This should always be non-null.
          Document* mainFrameDocument = m_frame-&gt;mainFrame().document();
          return mainFrameDocument ? *mainFrameDocument : const_cast&lt;Document&amp;&gt;(*this);
<span class="line-new-header">--- 5685,11 ---</span>
  
  Document&amp; Document::topDocument() const
  {
      // FIXME: This special-casing avoids incorrectly determined top documents during the process
      // of AXObjectCache teardown or notification posting for cached or being-destroyed documents.
<span class="line-modified">!     if (backForwardCacheState() == NotInBackForwardCache &amp;&amp; !m_renderTreeBeingDestroyed) {</span>
          if (!m_frame)
              return const_cast&lt;Document&amp;&gt;(*this);
          // This should always be non-null.
          Document* mainFrameDocument = m_frame-&gt;mainFrame().document();
          return mainFrameDocument ? *mainFrameDocument : const_cast&lt;Document&amp;&gt;(*this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5560,13 ***</span>
      while (HTMLFrameOwnerElement* element = document-&gt;ownerElement())
          document = &amp;element-&gt;document();
      return *document;
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttribute(const String&amp; name)</span>
  {
<span class="line-modified">!     return createAttributeNS({ }, isHTMLDocument() ? name.convertToASCIILowercase() : name, true);</span>
  }
  
  ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttributeNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName, bool shouldIgnoreNamespaceChecks)
  {
      auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
<span class="line-new-header">--- 5699,15 ---</span>
      while (HTMLFrameOwnerElement* element = document-&gt;ownerElement())
          document = &amp;element-&gt;document();
      return *document;
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttribute(const String&amp; localName)</span>
  {
<span class="line-modified">!     if (!isValidName(localName))</span>
<span class="line-added">+         return Exception { InvalidCharacterError };</span>
<span class="line-added">+     return Attr::create(*this, QualifiedName { nullAtom(), isHTMLDocument() ? localName.convertToASCIILowercase() : localName, nullAtom() }, emptyString());</span>
  }
  
  ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttributeNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName, bool shouldIgnoreNamespaceChecks)
  {
      auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5685,15 ***</span>
      scriptRunner().documentFinishedParsing();
  
      if (!m_documentTiming.domContentLoadedEventStart)
          m_documentTiming.domContentLoadedEventStart = MonotonicTime::now();
  
<span class="line-modified">!     if (!page() || !page()-&gt;isForSanitizingWebContent()) {</span>
<span class="line-modified">!         // FIXME: Schedule a task to fire DOMContentLoaded event instead. See webkit.org/b/82931</span>
<span class="line-removed">-         MicrotaskQueue::mainThreadQueue().performMicrotaskCheckpoint();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      dispatchEvent(Event::create(eventNames().DOMContentLoadedEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
  
      if (!m_documentTiming.domContentLoadedEventEnd)
          m_documentTiming.domContentLoadedEventEnd = MonotonicTime::now();
  
<span class="line-new-header">--- 5826,12 ---</span>
      scriptRunner().documentFinishedParsing();
  
      if (!m_documentTiming.domContentLoadedEventStart)
          m_documentTiming.domContentLoadedEventStart = MonotonicTime::now();
  
<span class="line-modified">!     // FIXME: Schedule a task to fire DOMContentLoaded event instead. See webkit.org/b/82931</span>
<span class="line-modified">!     eventLoop().performMicrotaskCheckpoint();</span>
      dispatchEvent(Event::create(eventNames().DOMContentLoadedEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
  
      if (!m_documentTiming.domContentLoadedEventEnd)
          m_documentTiming.domContentLoadedEventEnd = MonotonicTime::now();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5722,10 ***</span>
<span class="line-new-header">--- 5860,18 ---</span>
      static const Seconds timeToKeepSharedObjectPoolAliveAfterParsingFinished { 10_s };
      m_sharedObjectPoolClearTimer.startOneShot(timeToKeepSharedObjectPoolAliveAfterParsingFinished);
  
      // Parser should have picked up all speculative preloads by now
      m_cachedResourceLoader-&gt;clearPreloads(CachedResourceLoader::ClearPreloadsMode::ClearSpeculativePreloads);
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(SERVICE_WORKER)</span>
<span class="line-added">+     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled()) {</span>
<span class="line-added">+         // Stop queuing service worker client messages now that the DOMContentLoaded event has been fired.</span>
<span class="line-added">+         if (auto* serviceWorkerContainer = this-&gt;serviceWorkerContainer())</span>
<span class="line-added">+             serviceWorkerContainer-&gt;startMessages();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
  }
  
  void Document::clearSharedObjectPool()
  {
      m_sharedObjectPool = nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5763,18 ***</span>
      if (!m_xpathEvaluator)
          m_xpathEvaluator = XPathEvaluator::create();
      return m_xpathEvaluator-&gt;createExpression(expression, WTFMove(resolver));
  }
  
<span class="line-modified">! Ref&lt;XPathNSResolver&gt; Document::createNSResolver(Node* nodeResolver)</span>
  {
      if (!m_xpathEvaluator)
          m_xpathEvaluator = XPathEvaluator::create();
      return m_xpathEvaluator-&gt;createNSResolver(nodeResolver);
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;XPathResult&gt;&gt; Document::evaluate(const String&amp; expression, Node* contextNode, RefPtr&lt;XPathNSResolver&gt;&amp;&amp; resolver, unsigned short type, XPathResult* result)</span>
  {
      if (!m_xpathEvaluator)
          m_xpathEvaluator = XPathEvaluator::create();
      return m_xpathEvaluator-&gt;evaluate(expression, contextNode, WTFMove(resolver), type, result);
  }
<span class="line-new-header">--- 5909,18 ---</span>
      if (!m_xpathEvaluator)
          m_xpathEvaluator = XPathEvaluator::create();
      return m_xpathEvaluator-&gt;createExpression(expression, WTFMove(resolver));
  }
  
<span class="line-modified">! Ref&lt;XPathNSResolver&gt; Document::createNSResolver(Node&amp; nodeResolver)</span>
  {
      if (!m_xpathEvaluator)
          m_xpathEvaluator = XPathEvaluator::create();
      return m_xpathEvaluator-&gt;createNSResolver(nodeResolver);
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;XPathResult&gt;&gt; Document::evaluate(const String&amp; expression, Node&amp; contextNode, RefPtr&lt;XPathNSResolver&gt;&amp;&amp; resolver, unsigned short type, XPathResult* result)</span>
  {
      if (!m_xpathEvaluator)
          m_xpathEvaluator = XPathEvaluator::create();
      return m_xpathEvaluator-&gt;evaluate(expression, contextNode, WTFMove(resolver), type, result);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5810,10 ***</span>
<span class="line-new-header">--- 5956,25 ---</span>
          isSecurityOriginUnique = documentLoader &amp;&amp; documentLoader-&gt;response().tainting() == ResourceResponse::Tainting::Opaque;
  
      setSecurityOriginPolicy(SecurityOriginPolicy::create(isSecurityOriginUnique ? SecurityOrigin::createUnique() : SecurityOrigin::create(m_url)));
      setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { m_url }, *this));
  
<span class="line-added">+     if (SecurityPolicy::allowSubstituteDataAccessToLocal()) {</span>
<span class="line-added">+         // If this document was loaded with substituteData, then the document can</span>
<span class="line-added">+         // load local resources.  See https://bugs.webkit.org/show_bug.cgi?id=16756</span>
<span class="line-added">+         // and https://bugs.webkit.org/show_bug.cgi?id=19760 for further</span>
<span class="line-added">+         // discussion.</span>
<span class="line-added">+ </span>
<span class="line-added">+         // RT-17330: Need to use &quot;m_frame-&gt;loader()-&gt;documentLoader()&quot; instead</span>
<span class="line-added">+         // of &quot;loader()&quot; as the latter returns NULL while the document is being</span>
<span class="line-added">+         // constructed</span>
<span class="line-added">+         // DocumentLoader* documentLoader = loader();</span>
<span class="line-added">+         DocumentLoader* documentLoader = m_frame-&gt;loader().documentLoader();</span>
<span class="line-added">+         if (documentLoader &amp;&amp; documentLoader-&gt;substituteData().isValid())</span>
<span class="line-added">+             securityOrigin().grantLoadLocalResources();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      String overrideContentSecurityPolicy = m_frame-&gt;loader().client().overrideContentSecurityPolicy();
      if (!overrideContentSecurityPolicy.isNull())
          contentSecurityPolicy()-&gt;didReceiveHeader(overrideContentSecurityPolicy, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::API, referrer(), documentLoader ? documentLoader-&gt;response().httpStatusCode() : 0);
  
  #if USE(QUICK_LOOK)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5869,16 ***</span>
      if (!ownerFrame) {
          didFailToInitializeSecurityOrigin();
          return;
      }
  
<span class="line-modified">!     Document* openerDocument = openerFrame ? openerFrame-&gt;document() : nullptr;</span>
  
      // Per &lt;http://www.w3.org/TR/upgrade-insecure-requests/&gt;, new browsing contexts must inherit from an
      // ongoing set of upgraded requests. When opening a new browsing context, we need to capture its
      // existing upgrade request. Nested browsing contexts are handled during DocumentWriter::begin.
<span class="line-modified">!     if (openerDocument)</span>
          contentSecurityPolicy()-&gt;inheritInsecureNavigationRequestsToUpgradeFromOpener(*openerDocument-&gt;contentSecurityPolicy());
  
      if (isSandboxed(SandboxOrigin)) {
          // If we&#39;re supposed to inherit our security origin from our owner,
          // but we&#39;re also sandboxed, the only thing we inherit is the ability
<span class="line-new-header">--- 6030,17 ---</span>
      if (!ownerFrame) {
          didFailToInitializeSecurityOrigin();
          return;
      }
  
<span class="line-modified">!     contentSecurityPolicy()-&gt;copyStateFrom(ownerFrame-&gt;document()-&gt;contentSecurityPolicy());</span>
<span class="line-added">+     contentSecurityPolicy()-&gt;updateSourceSelf(ownerFrame-&gt;document()-&gt;securityOrigin());</span>
  
      // Per &lt;http://www.w3.org/TR/upgrade-insecure-requests/&gt;, new browsing contexts must inherit from an
      // ongoing set of upgraded requests. When opening a new browsing context, we need to capture its
      // existing upgrade request. Nested browsing contexts are handled during DocumentWriter::begin.
<span class="line-modified">!     if (auto* openerDocument = openerFrame ? openerFrame-&gt;document() : nullptr)</span>
          contentSecurityPolicy()-&gt;inheritInsecureNavigationRequestsToUpgradeFromOpener(*openerDocument-&gt;contentSecurityPolicy());
  
      if (isSandboxed(SandboxOrigin)) {
          // If we&#39;re supposed to inherit our security origin from our owner,
          // but we&#39;re also sandboxed, the only thing we inherit is the ability
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5893,57 ***</span>
      // We alias the SecurityOrigins to match Firefox, see Bug 15313
      // https://bugs.webkit.org/show_bug.cgi?id=15313
      setSecurityOriginPolicy(ownerFrame-&gt;document()-&gt;securityOriginPolicy());
  }
  
<span class="line-modified">! // FIXME: The current criterion is stricter than &lt;https://www.w3.org/TR/CSP3/#security-inherit-csp&gt; (Editor&#39;s Draft, 28 February 2019).</span>
<span class="line-removed">- bool Document::shouldInheritContentSecurityPolicy() const</span>
  {
<span class="line-modified">!     ASSERT(m_frame);</span>
<span class="line-removed">-     if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(m_url))</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">-     if (m_url.protocolIsData() || m_url.protocolIsBlob())</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">-     if (!isPluginDocument())</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     if (m_frame-&gt;tree().parent())</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">-     Frame* openerFrame = m_frame-&gt;loader().opener();</span>
<span class="line-removed">-     if (!openerFrame)</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     return openerFrame-&gt;document()-&gt;securityOrigin().canAccess(securityOrigin());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::initContentSecurityPolicy(ContentSecurityPolicy* previousPolicy)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // 1. Inherit Upgrade Insecure Requests</span>
<span class="line-removed">-     Frame* parentFrame = m_frame-&gt;tree().parent();</span>
      if (parentFrame)
          contentSecurityPolicy()-&gt;copyUpgradeInsecureRequestStateFrom(*parentFrame-&gt;document()-&gt;contentSecurityPolicy());
  
<span class="line-modified">!     // 2. Inherit Content Security Policy (without copying Upgrade Insecure Requests state).</span>
<span class="line-modified">!     if (!shouldInheritContentSecurityPolicy())</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!     ContentSecurityPolicy* ownerPolicy = nullptr;</span>
<span class="line-modified">!     if (previousPolicy &amp;&amp; (m_url.protocolIsData() || m_url.protocolIsBlob()))</span>
<span class="line-modified">!         ownerPolicy = previousPolicy;</span>
<span class="line-modified">!     if (!ownerPolicy) {</span>
<span class="line-modified">!         Frame* ownerFrame = parentFrame;</span>
<span class="line-modified">!         if (!ownerFrame)</span>
<span class="line-modified">!             ownerFrame = m_frame-&gt;loader().opener();</span>
<span class="line-modified">!         if (ownerFrame)</span>
<span class="line-modified">!             ownerPolicy = ownerFrame-&gt;document()-&gt;contentSecurityPolicy();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (!ownerPolicy)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     // FIXME: We are stricter than the CSP 3 spec. with regards to plugins: we prefer to inherit the full policy unless the plugin</span>
<span class="line-removed">-     // document is opened in a new window. The CSP 3 spec. implies that only plugin documents delivered with a local scheme (e.g. blob,</span>
<span class="line-removed">-     // file, data) should inherit a policy.</span>
<span class="line-removed">-     if (isPluginDocument() &amp;&amp; m_frame-&gt;loader().opener())</span>
<span class="line-removed">-         contentSecurityPolicy()-&gt;createPolicyForPluginDocumentFrom(*ownerPolicy);</span>
      else
<span class="line-modified">!         contentSecurityPolicy()-&gt;copyStateFrom(ownerPolicy);</span>
  }
  
  bool Document::isContextThread() const
  {
      return isMainThread();
<span class="line-new-header">--- 6055,30 ---</span>
      // We alias the SecurityOrigins to match Firefox, see Bug 15313
      // https://bugs.webkit.org/show_bug.cgi?id=15313
      setSecurityOriginPolicy(ownerFrame-&gt;document()-&gt;securityOriginPolicy());
  }
  
<span class="line-modified">! void Document::initContentSecurityPolicy()</span>
  {
<span class="line-modified">!     auto* parentFrame = m_frame-&gt;tree().parent();</span>
      if (parentFrame)
          contentSecurityPolicy()-&gt;copyUpgradeInsecureRequestStateFrom(*parentFrame-&gt;document()-&gt;contentSecurityPolicy());
  
<span class="line-modified">!     // FIXME: Remove this special plugin document logic. We are stricter than the CSP 3 spec. with regards to plugins: we prefer to</span>
<span class="line-modified">!     // inherit the full policy unless the plugin document is opened in a new window. The CSP 3 spec. implies that only plugin documents</span>
<span class="line-modified">!     // delivered with a local scheme (e.g. blob, file, data) should inherit a policy.</span>
<span class="line-modified">!     if (!isPluginDocument())</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!     auto* openerFrame = m_frame-&gt;loader().opener();</span>
<span class="line-modified">!     bool shouldInhert = parentFrame || (openerFrame &amp;&amp; openerFrame-&gt;document()-&gt;securityOrigin().canAccess(securityOrigin()));</span>
<span class="line-modified">!     if (!shouldInhert)</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!     setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { m_url }, *this));</span>
<span class="line-modified">!     if (openerFrame)</span>
<span class="line-modified">!         contentSecurityPolicy()-&gt;createPolicyForPluginDocumentFrom(*openerFrame-&gt;document()-&gt;contentSecurityPolicy());</span>
      else
<span class="line-modified">!         contentSecurityPolicy()-&gt;copyStateFrom(parentFrame-&gt;document()-&gt;contentSecurityPolicy());</span>
  }
  
  bool Document::isContextThread() const
  {
      return isMainThread();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5955,14 ***</span>
          return true;
      if (!RuntimeEnabledFeatures::sharedFeatures().secureContextChecksEnabled())
          return true;
      if (!securityOrigin().isPotentiallyTrustworthy())
          return false;
<span class="line-modified">!     for (Frame* frame = m_frame-&gt;tree().parent(); frame; frame = frame-&gt;tree().parent()) {</span>
          if (!frame-&gt;document()-&gt;securityOrigin().isPotentiallyTrustworthy())
              return false;
      }
      return true;
  }
  
  void Document::updateURLForPushOrReplaceState(const URL&amp; url)
  {
<span class="line-new-header">--- 6090,16 ---</span>
          return true;
      if (!RuntimeEnabledFeatures::sharedFeatures().secureContextChecksEnabled())
          return true;
      if (!securityOrigin().isPotentiallyTrustworthy())
          return false;
<span class="line-modified">!     for (auto* frame = m_frame-&gt;tree().parent(); frame; frame = frame-&gt;tree().parent()) {</span>
          if (!frame-&gt;document()-&gt;securityOrigin().isPotentiallyTrustworthy())
              return false;
      }
<span class="line-added">+     if (topOrigin().isUnique())</span>
<span class="line-added">+         return false;</span>
      return true;
  }
  
  void Document::updateURLForPushOrReplaceState(const URL&amp; url)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6124,11 ***</span>
  
      if (m_consoleMessageListener)
          m_consoleMessageListener-&gt;scheduleCallback(*this, message);
  }
  
<span class="line-modified">! void Document::addMessage(MessageSource source, MessageLevel level, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp; callStack, JSC::ExecState* state, unsigned long requestIdentifier)</span>
  {
      if (!isContextThread()) {
          postTask(AddConsoleMessageTask(source, level, message));
          return;
      }
<span class="line-new-header">--- 6261,11 ---</span>
  
      if (m_consoleMessageListener)
          m_consoleMessageListener-&gt;scheduleCallback(*this, message);
  }
  
<span class="line-modified">! void Document::addMessage(MessageSource source, MessageLevel level, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp; callStack, JSC::JSGlobalObject* state, unsigned long requestIdentifier)</span>
  {
      if (!isContextThread()) {
          postTask(AddConsoleMessageTask(source, level, message));
          return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6159,10 ***</span>
<span class="line-new-header">--- 6296,31 ---</span>
      Vector&lt;Task&gt; pendingTasks = WTFMove(m_pendingTasks);
      for (auto&amp; task : pendingTasks)
          task.performTask(*this);
  }
  
<span class="line-added">+ EventLoopTaskGroup&amp; Document::eventLoop()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(isMainThread());</span>
<span class="line-added">+     if (UNLIKELY(!m_documentTaskGroup)) {</span>
<span class="line-added">+         m_documentTaskGroup = makeUnique&lt;EventLoopTaskGroup&gt;(windowEventLoop());</span>
<span class="line-added">+         if (activeDOMObjectsAreStopped())</span>
<span class="line-added">+             m_documentTaskGroup-&gt;stopAndDiscardAllTasks();</span>
<span class="line-added">+         else if (activeDOMObjectsAreSuspended())</span>
<span class="line-added">+             m_documentTaskGroup-&gt;suspend();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return *m_documentTaskGroup;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ WindowEventLoop&amp; Document::windowEventLoop()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(isMainThread());</span>
<span class="line-added">+     if (UNLIKELY(!m_eventLoop))</span>
<span class="line-added">+         m_eventLoop = WindowEventLoop::eventLoopForSecurityOrigin(securityOrigin());</span>
<span class="line-added">+     return *m_eventLoop;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Document::suspendScheduledTasks(ReasonForSuspension reason)
  {
      if (m_scheduledTasksAreSuspended) {
          // A page may subsequently suspend DOM objects, say as part of handling a scroll or zoom gesture, after the
          // embedding client requested the page be suspended. We ignore such requests so long as the embedding client
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6226,12 ***</span>
          m_scriptedAnimationController-&gt;resume();
  }
  
  void Document::updateAnimationsAndSendEvents(DOMHighResTimeStamp timestamp)
  {
<span class="line-modified">!     if (m_timeline)</span>
<span class="line-modified">!         m_timeline-&gt;updateAnimationsAndSendEvents(timestamp);</span>
  }
  
  void Document::serviceRequestAnimationFrameCallbacks(DOMHighResTimeStamp timestamp)
  {
      if (m_scriptedAnimationController)
<span class="line-new-header">--- 6384,26 ---</span>
          m_scriptedAnimationController-&gt;resume();
  }
  
  void Document::updateAnimationsAndSendEvents(DOMHighResTimeStamp timestamp)
  {
<span class="line-modified">!     ASSERT(!m_timelines.hasNullReferences());</span>
<span class="line-modified">! </span>
<span class="line-added">+     // We need to copy m_timelines before iterating over its members since calling updateAnimationsAndSendEvents() may mutate m_timelines.</span>
<span class="line-added">+     Vector&lt;RefPtr&lt;DocumentTimeline&gt;&gt; timelines;</span>
<span class="line-added">+     bool shouldUpdateAnimations = false;</span>
<span class="line-added">+     for (auto&amp; timeline : m_timelines) {</span>
<span class="line-added">+         if (!shouldUpdateAnimations &amp;&amp; timeline.scheduledUpdate())</span>
<span class="line-added">+             shouldUpdateAnimations = true;</span>
<span class="line-added">+         timelines.append(&amp;timeline);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto&amp; timeline : timelines) {</span>
<span class="line-added">+         timeline-&gt;updateCurrentTime(timestamp);</span>
<span class="line-added">+         if (shouldUpdateAnimations)</span>
<span class="line-added">+             timeline-&gt;updateAnimationsAndSendEvents();</span>
<span class="line-added">+     }</span>
  }
  
  void Document::serviceRequestAnimationFrameCallbacks(DOMHighResTimeStamp timestamp)
  {
      if (m_scriptedAnimationController)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6259,16 ***</span>
      dispatchWindowEvent(PageTransitionEvent::create(eventNames().pageshowEvent, persisted), this);
  }
  
  void Document::enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp; eventInit)
  {
<span class="line-modified">!     enqueueDocumentEvent(SecurityPolicyViolationEvent::create(eventNames().securitypolicyviolationEvent, WTFMove(eventInit), Event::IsTrusted::Yes));</span>
  }
  
  void Document::enqueueHashchangeEvent(const String&amp; oldURL, const String&amp; newURL)
  {
<span class="line-modified">!     enqueueWindowEvent(HashChangeEvent::create(oldURL, newURL));</span>
  }
  
  void Document::dispatchPopstateEvent(RefPtr&lt;SerializedScriptValue&gt;&amp;&amp; stateObject)
  {
      dispatchWindowEvent(PopStateEvent::create(WTFMove(stateObject), m_domWindow ? &amp;m_domWindow-&gt;history() : nullptr));
<span class="line-new-header">--- 6431,17 ---</span>
      dispatchWindowEvent(PageTransitionEvent::create(eventNames().pageshowEvent, persisted), this);
  }
  
  void Document::enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp; eventInit)
  {
<span class="line-modified">!     queueTaskToDispatchEvent(TaskSource::DOMManipulation, SecurityPolicyViolationEvent::create(eventNames().securitypolicyviolationEvent, WTFMove(eventInit), Event::IsTrusted::Yes));</span>
  }
  
  void Document::enqueueHashchangeEvent(const String&amp; oldURL, const String&amp; newURL)
  {
<span class="line-modified">!     // FIXME: popstate event and hashchange event are supposed to fire in a single task.</span>
<span class="line-added">+     queueTaskToDispatchEventOnWindow(TaskSource::DOMManipulation, HashChangeEvent::create(oldURL, newURL));</span>
  }
  
  void Document::dispatchPopstateEvent(RefPtr&lt;SerializedScriptValue&gt;&amp;&amp; stateObject)
  {
      dispatchWindowEvent(PopStateEvent::create(WTFMove(stateObject), m_domWindow ? &amp;m_domWindow-&gt;history() : nullptr));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6397,10 ***</span>
<span class="line-new-header">--- 6570,24 ---</span>
      if (m_scriptedAnimationController)
          m_scriptedAnimationController-&gt;clearDocumentPointer();
      m_scriptedAnimationController = nullptr;
  }
  
<span class="line-added">+ int Document::requestIdleCallback(Ref&lt;IdleRequestCallback&gt;&amp;&amp; callback, Seconds timeout)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_idleCallbackController)</span>
<span class="line-added">+         m_idleCallbackController = makeUnique&lt;IdleCallbackController&gt;(*this);</span>
<span class="line-added">+     return m_idleCallbackController-&gt;queueIdleCallback(WTFMove(callback), timeout);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Document::cancelIdleCallback(int id)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_idleCallbackController)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     m_idleCallbackController-&gt;removeIdleCallback(id);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Document::wheelEventHandlersChanged()
  {
      Page* page = this-&gt;page();
      if (!page)
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6903,13 ***</span>
  {
      if (const Document* document = templateDocument())
          return const_cast&lt;Document&amp;&gt;(*document);
  
      if (isHTMLDocument())
<span class="line-modified">!         m_templateDocument = HTMLDocument::create(sessionID(), nullptr, WTF::blankURL());</span>
      else
<span class="line-modified">!         m_templateDocument = create(sessionID(), WTF::blankURL());</span>
  
      m_templateDocument-&gt;setContextDocument(contextDocument());
      m_templateDocument-&gt;setTemplateDocumentHost(this); // balanced in dtor.
  
      return *m_templateDocument;
<span class="line-new-header">--- 7090,13 ---</span>
  {
      if (const Document* document = templateDocument())
          return const_cast&lt;Document&amp;&gt;(*document);
  
      if (isHTMLDocument())
<span class="line-modified">!         m_templateDocument = HTMLDocument::create(nullptr, WTF::blankURL());</span>
      else
<span class="line-modified">!         m_templateDocument = create(WTF::blankURL());</span>
  
      m_templateDocument-&gt;setContextDocument(contextDocument());
      m_templateDocument-&gt;setTemplateDocumentHost(this); // balanced in dtor.
  
      return *m_templateDocument;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6995,19 ***</span>
  }
  
  CompositeOperator Document::compositeOperatorForBackgroundColor(const Color&amp; color, const RenderObject&amp; renderer) const
  {
      if (LIKELY(!settings().punchOutWhiteBackgroundsInDarkMode() || !Color::isWhiteColor(color) || !renderer.useDarkAppearance()))
<span class="line-modified">!         return CompositeSourceOver;</span>
  
      auto* frameView = view();
      if (!frameView)
<span class="line-modified">!         return CompositeSourceOver;</span>
  
      // Mail on macOS uses a transparent view, and on iOS it is an opaque view. We need to
      // use different composite modes to get the right results in this case.
<span class="line-modified">!     return frameView-&gt;isTransparent() ? CompositeDestinationOut : CompositeDestinationIn;</span>
  }
  
  void Document::didAssociateFormControl(Element&amp; element)
  {
      auto* page = this-&gt;page();
<span class="line-new-header">--- 7182,19 ---</span>
  }
  
  CompositeOperator Document::compositeOperatorForBackgroundColor(const Color&amp; color, const RenderObject&amp; renderer) const
  {
      if (LIKELY(!settings().punchOutWhiteBackgroundsInDarkMode() || !Color::isWhiteColor(color) || !renderer.useDarkAppearance()))
<span class="line-modified">!         return CompositeOperator::SourceOver;</span>
  
      auto* frameView = view();
      if (!frameView)
<span class="line-modified">!         return CompositeOperator::SourceOver;</span>
  
      // Mail on macOS uses a transparent view, and on iOS it is an opaque view. We need to
      // use different composite modes to get the right results in this case.
<span class="line-modified">!     return frameView-&gt;isTransparent() ? CompositeOperator::DestinationOut : CompositeOperator::DestinationIn;</span>
  }
  
  void Document::didAssociateFormControl(Element&amp; element)
  {
      auto* page = this-&gt;page();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7060,11 ***</span>
      String jsString = page()-&gt;chrome().client().plugInExtraScript();
      if (!jsString || !scriptController.shouldAllowUserAgentScripts(*this))
          jsString = String(plugInsJavaScript, sizeof(plugInsJavaScript));
  
      setHasEvaluatedUserAgentScripts();
<span class="line-modified">!     scriptController.evaluateInWorld(ScriptSourceCode(jsString), world);</span>
  
      m_hasInjectedPlugInsScript = true;
  }
  
  #if ENABLE(WEB_CRYPTO)
<span class="line-new-header">--- 7247,11 ---</span>
      String jsString = page()-&gt;chrome().client().plugInExtraScript();
      if (!jsString || !scriptController.shouldAllowUserAgentScripts(*this))
          jsString = String(plugInsJavaScript, sizeof(plugInsJavaScript));
  
      setHasEvaluatedUserAgentScripts();
<span class="line-modified">!     scriptController.evaluateInWorldIgnoringException(ScriptSourceCode(jsString), world);</span>
  
      m_hasInjectedPlugInsScript = true;
  }
  
  #if ENABLE(WEB_CRYPTO)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7197,10 ***</span>
<span class="line-new-header">--- 7384,19 ---</span>
          return;
  
      it-&gt;value-&gt;setShouldPlayToPlaybackTarget(shouldPlay);
  }
  
<span class="line-added">+ void Document::playbackTargetPickerWasDismissed(uint64_t clientId)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto it = m_idToClientMap.find(clientId);</span>
<span class="line-added">+     if (it == m_idToClientMap.end())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     it-&gt;value-&gt;playbackTargetPickerWasDismissed();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #endif // ENABLE(WIRELESS_PLAYBACK_TARGET)
  
  #if ENABLE(MEDIA_SESSION)
  
  MediaSession&amp; Document::defaultMediaSession()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7227,10 ***</span>
<span class="line-new-header">--- 7423,11 ---</span>
      DocumentLoader* documentLoader = m_frame-&gt;loader().activeDocumentLoader();
      return documentLoader &amp;&amp; documentLoader-&gt;response().isHTTP09();
  }
  
  #if USE(QUICK_LOOK)
<span class="line-added">+ </span>
  bool Document::shouldEnforceQuickLookSandbox() const
  {
      if (m_isSynthesized || !m_frame)
          return false;
      DocumentLoader* documentLoader = m_frame-&gt;loader().activeDocumentLoader();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7256,10 ***</span>
<span class="line-new-header">--- 7453,11 ---</span>
  
      disableSandboxFlags(SandboxNavigation);
  
      setReferrerPolicy(ReferrerPolicy::NoReferrer);
  }
<span class="line-added">+ </span>
  #endif
  
  bool Document::shouldEnforceContentDispositionAttachmentSandbox() const
  {
      if (!settings().contentDispositionAttachmentSandboxEnabled())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7282,28 ***</span>
          enforceSandboxFlags(SandboxAll);
      else
          enforceSandboxFlags(SandboxOrigin);
  }
  
<span class="line-modified">! void Document::addViewportDependentPicture(HTMLPictureElement&amp; picture)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_viewportDependentPictures.add(&amp;picture);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::removeViewportDependentPicture(HTMLPictureElement&amp; picture)</span>
  {
<span class="line-modified">!     m_viewportDependentPictures.remove(&amp;picture);</span>
  }
  
<span class="line-modified">! void Document::addAppearanceDependentPicture(HTMLPictureElement&amp; picture)</span>
  {
<span class="line-modified">!     m_appearanceDependentPictures.add(&amp;picture);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::removeAppearanceDependentPicture(HTMLPictureElement&amp; picture)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_appearanceDependentPictures.remove(&amp;picture);</span>
  }
  
  void Document::scheduleTimedRenderingUpdate()
  {
  #if ENABLE(INTERSECTION_OBSERVER)
<span class="line-new-header">--- 7480,18 ---</span>
          enforceSandboxFlags(SandboxAll);
      else
          enforceSandboxFlags(SandboxOrigin);
  }
  
<span class="line-modified">! void Document::addDynamicMediaQueryDependentImage(HTMLImageElement&amp; element)</span>
  {
<span class="line-modified">!     m_dynamicMediaQueryDependentImages.add(element);</span>
  }
  
<span class="line-modified">! void Document::removeDynamicMediaQueryDependentImage(HTMLImageElement&amp; element)</span>
  {
<span class="line-modified">!     m_dynamicMediaQueryDependentImages.remove(element);</span>
  }
  
  void Document::scheduleTimedRenderingUpdate()
  {
  #if ENABLE(INTERSECTION_OBSERVER)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7312,10 ***</span>
<span class="line-new-header">--- 7500,11 ---</span>
      if (auto page = this-&gt;page())
          page-&gt;renderingUpdateScheduler().scheduleTimedRenderingUpdate();
  }
  
  #if ENABLE(INTERSECTION_OBSERVER)
<span class="line-added">+ </span>
  void Document::addIntersectionObserver(IntersectionObserver&amp; observer)
  {
      ASSERT(m_intersectionObservers.find(&amp;observer) == notFound);
      m_intersectionObservers.append(makeWeakPtr(&amp;observer));
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7420,23 ***</span>
  
      FloatRect rootLocalIntersectionRect = localRootBounds;
  
      IntersectionObservationState intersectionState;
      intersectionState.isIntersecting = rootLocalTargetRect &amp;&amp; rootLocalIntersectionRect.edgeInclusiveIntersect(*rootLocalTargetRect);
  
      if (intersectionState.isIntersecting) {
          FloatRect rootAbsoluteIntersectionRect = rootRenderer-&gt;localToAbsoluteQuad(rootLocalIntersectionRect).boundingBox();
          if (&amp;targetRenderer-&gt;frame() == &amp;rootRenderer-&gt;frame())
              intersectionState.absoluteIntersectionRect = rootAbsoluteIntersectionRect;
          else {
              FloatRect rootViewIntersectionRect = frameView.contentsToView(rootAbsoluteIntersectionRect);
              intersectionState.absoluteIntersectionRect = targetRenderer-&gt;view().frameView().rootViewToContents(rootViewIntersectionRect);
          }
      }
  
<span class="line-removed">-     intersectionState.absoluteTargetRect = targetRenderer-&gt;localToAbsoluteQuad(FloatRect(localTargetBounds)).boundingBox();</span>
<span class="line-removed">-     intersectionState.absoluteRootBounds = rootRenderer-&gt;localToAbsoluteQuad(localRootBounds).boundingBox();</span>
      return intersectionState;
  }
  
  void Document::updateIntersectionObservations()
  {
<span class="line-new-header">--- 7609,24 ---</span>
  
      FloatRect rootLocalIntersectionRect = localRootBounds;
  
      IntersectionObservationState intersectionState;
      intersectionState.isIntersecting = rootLocalTargetRect &amp;&amp; rootLocalIntersectionRect.edgeInclusiveIntersect(*rootLocalTargetRect);
<span class="line-added">+     intersectionState.absoluteTargetRect = targetRenderer-&gt;localToAbsoluteQuad(FloatRect(localTargetBounds)).boundingBox();</span>
<span class="line-added">+     intersectionState.absoluteRootBounds = rootRenderer-&gt;localToAbsoluteQuad(localRootBounds).boundingBox();</span>
  
      if (intersectionState.isIntersecting) {
          FloatRect rootAbsoluteIntersectionRect = rootRenderer-&gt;localToAbsoluteQuad(rootLocalIntersectionRect).boundingBox();
          if (&amp;targetRenderer-&gt;frame() == &amp;rootRenderer-&gt;frame())
              intersectionState.absoluteIntersectionRect = rootAbsoluteIntersectionRect;
          else {
              FloatRect rootViewIntersectionRect = frameView.contentsToView(rootAbsoluteIntersectionRect);
              intersectionState.absoluteIntersectionRect = targetRenderer-&gt;view().frameView().rootViewToContents(rootViewIntersectionRect);
          }
<span class="line-added">+         intersectionState.isIntersecting = intersectionState.absoluteIntersectionRect.edgeInclusiveIntersect(intersectionState.absoluteTargetRect);</span>
      }
  
      return intersectionState;
  }
  
  void Document::updateIntersectionObservations()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7540,13 ***</span>
<span class="line-new-header">--- 7730,15 ---</span>
      if (m_readyState == Complete)
          scheduleTimedRenderingUpdate();
      else if (!m_intersectionObserversInitialUpdateTimer.isActive())
          m_intersectionObserversInitialUpdateTimer.startOneShot(intersectionObserversInitialUpdateDelay);
  }
<span class="line-added">+ </span>
  #endif
  
  #if ENABLE(RESIZE_OBSERVER)
<span class="line-added">+ </span>
  void Document::addResizeObserver(ResizeObserver&amp; observer)
  {
      if (!m_resizeObservers.contains(&amp;observer))
          m_resizeObservers.append(makeWeakPtr(&amp;observer));
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7622,10 ***</span>
<span class="line-new-header">--- 7814,11 ---</span>
          reportException(&quot;ResizeObserver loop completed with undelivered notifications.&quot;, line, column, url, nullptr, nullptr);
          // Starting a new schedule the next round of notify.
          scheduleTimedRenderingUpdate();
      }
  }
<span class="line-added">+ </span>
  #endif
  
  const AtomString&amp; Document::dir() const
  {
      auto* documentElement = this-&gt;documentElement();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7664,69 ***</span>
      LOG(Events, &quot;Document %p orientationChanged - orientation %d&quot;, this, orientation);
      dispatchWindowEvent(Event::create(eventNames().orientationchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
      m_orientationNotifier.orientationChanged(orientation);
  }
  
<span class="line-removed">- void Document::notifyMediaCaptureOfVisibilityChanged()</span>
<span class="line-removed">- {</span>
  #if ENABLE(MEDIA_STREAM)
<span class="line-removed">-     if (!page())</span>
<span class="line-removed">-         return;</span>
  
<span class="line-removed">-     RealtimeMediaSourceCenter::singleton().setCapturePageState(hidden(), page()-&gt;isMediaCaptureMuted());</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if ENABLE(MEDIA_STREAM)</span>
  void Document::stopMediaCapture()
  {
      MediaStreamTrack::endCapture(*this);
  }
  
<span class="line-removed">- void Document::registerForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp; element)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_mediaStreamStateChangeElements.add(&amp;element);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::unregisterForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp; element)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_mediaStreamStateChangeElements.remove(&amp;element);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void Document::mediaStreamCaptureStateChanged()
  {
      if (!MediaProducer::isCapturing(m_mediaState))
          return;
  
<span class="line-modified">!     for (auto* mediaElement : m_mediaStreamStateChangeElements)</span>
<span class="line-modified">!         mediaElement-&gt;mediaStreamCaptureStarted();</span>
  }
  
  void Document::setDeviceIDHashSalt(const String&amp; salt)
  {
      ASSERT(m_idHashSalt.isEmpty() || m_idHashSalt == salt);
      m_idHashSalt = salt;
  }
  
  #endif
  
<span class="line-removed">- void Document::addApplicationStateChangeListener(ApplicationStateChangeListener&amp; listener)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_applicationStateChangeListeners.add(&amp;listener);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::removeApplicationStateChangeListener(ApplicationStateChangeListener&amp; listener)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_applicationStateChangeListeners.remove(&amp;listener);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::forEachApplicationStateChangeListener(const Function&lt;void(ApplicationStateChangeListener&amp;)&gt;&amp; functor)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     for (auto* listener : m_applicationStateChangeListeners)</span>
<span class="line-removed">-         functor(*listener);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  const AtomString&amp; Document::bgColor() const
  {
      auto* bodyElement = body();
      if (!bodyElement)
          return emptyAtom();
<span class="line-new-header">--- 7857,35 ---</span>
      LOG(Events, &quot;Document %p orientationChanged - orientation %d&quot;, this, orientation);
      dispatchWindowEvent(Event::create(eventNames().orientationchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
      m_orientationNotifier.orientationChanged(orientation);
  }
  
  #if ENABLE(MEDIA_STREAM)
  
  void Document::stopMediaCapture()
  {
      MediaStreamTrack::endCapture(*this);
  }
  
  void Document::mediaStreamCaptureStateChanged()
  {
      if (!MediaProducer::isCapturing(m_mediaState))
          return;
  
<span class="line-modified">!     forEachMediaElement([] (HTMLMediaElement&amp; element) {</span>
<span class="line-modified">!         element.mediaStreamCaptureStarted();</span>
<span class="line-added">+     });</span>
  }
  
  void Document::setDeviceIDHashSalt(const String&amp; salt)
  {
      ASSERT(m_idHashSalt.isEmpty() || m_idHashSalt == salt);
      m_idHashSalt = salt;
  }
  
  #endif
  
  const AtomString&amp; Document::bgColor() const
  {
      auto* bodyElement = body();
      if (!bodyElement)
          return emptyAtom();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7797,11 ***</span>
  
  Logger&amp; Document::logger()
  {
      if (!m_logger) {
          m_logger = Logger::create(this);
<span class="line-modified">!         m_logger-&gt;setEnabled(this, sessionID().isAlwaysOnLoggingAllowed());</span>
          m_logger-&gt;addObserver(*this);
      }
  
      return *m_logger;
  }
<span class="line-new-header">--- 7956,12 ---</span>
  
  Logger&amp; Document::logger()
  {
      if (!m_logger) {
          m_logger = Logger::create(this);
<span class="line-modified">!         auto* page = this-&gt;page();</span>
<span class="line-added">+         m_logger-&gt;setEnabled(this, page &amp;&amp; page-&gt;sessionID().isAlwaysOnLoggingAllowed());</span>
          m_logger-&gt;addObserver(*this);
      }
  
      return *m_logger;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7923,10 ***</span>
<span class="line-new-header">--- 8083,20 ---</span>
  void Document::setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp; listener)
  {
      m_consoleMessageListener = listener;
  }
  
<span class="line-added">+ void Document::addTimeline(DocumentTimeline&amp; timeline)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_timelines.add(timeline);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Document::removeTimeline(DocumentTimeline&amp; timeline)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_timelines.remove(timeline);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  DocumentTimeline&amp; Document::timeline()
  {
      if (!m_timeline)
          m_timeline = DocumentTimeline::create(*this);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8046,21 ***</span>
          postTask([this, channel, level, logMessages = crossThreadCopy(WTFMove(logMessages))](auto&amp;) mutable {
              didLogMessage(channel, level, WTFMove(logMessages));
          });
          return;
      }
<span class="line-modified">!     if (!page())</span>
          return;
  
<span class="line-modified">!     ASSERT(sessionID().isAlwaysOnLoggingAllowed());</span>
  
      auto messageSource = messageSourceForWTFLogChannel(channel);
      if (messageSource == MessageSource::Other)
          return;
  
      m_logMessageTaskQueue.enqueueTask([this, level, messageSource, logMessages = WTFMove(logMessages)]() mutable {
<span class="line-modified">!         if (!page())</span>
              return;
  
          auto messageLevel = messageLevelFromWTFLogLevel(level);
          auto message = makeUnique&lt;Inspector::ConsoleMessage&gt;(messageSource, MessageType::Log, messageLevel, WTFMove(logMessages), mainWorldExecState(frame()));
  
<span class="line-new-header">--- 8216,22 ---</span>
          postTask([this, channel, level, logMessages = crossThreadCopy(WTFMove(logMessages))](auto&amp;) mutable {
              didLogMessage(channel, level, WTFMove(logMessages));
          });
          return;
      }
<span class="line-modified">!     auto* page = this-&gt;page();</span>
<span class="line-added">+     if (!page)</span>
          return;
  
<span class="line-modified">!     ASSERT(page-&gt;sessionID().isAlwaysOnLoggingAllowed());</span>
  
      auto messageSource = messageSourceForWTFLogChannel(channel);
      if (messageSource == MessageSource::Other)
          return;
  
      m_logMessageTaskQueue.enqueueTask([this, level, messageSource, logMessages = WTFMove(logMessages)]() mutable {
<span class="line-modified">!         if (!this-&gt;page())</span>
              return;
  
          auto messageLevel = messageLevelFromWTFLogLevel(level);
          auto message = makeUnique&lt;Inspector::ConsoleMessage&gt;(messageSource, MessageType::Log, messageLevel, WTFMove(logMessages), mainWorldExecState(frame()));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8130,11 ***</span>
      Ref&lt;Document&gt; protectedThis(*this);
      updateLayout();
      if (!renderView())
          return false;
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      SetForScope&lt;bool&gt; hitTestRestorer { m_inHitTesting, true };
  #endif
  
      auto&amp; frameView = renderView()-&gt;frameView();
      Ref&lt;FrameView&gt; protector(frameView);
<span class="line-new-header">--- 8301,11 ---</span>
      Ref&lt;Document&gt; protectedThis(*this);
      updateLayout();
      if (!renderView())
          return false;
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      SetForScope&lt;bool&gt; hitTestRestorer { m_inHitTesting, true };
  #endif
  
      auto&amp; frameView = renderView()-&gt;frameView();
      Ref&lt;FrameView&gt; protector(frameView);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8264,10 ***</span>
<span class="line-new-header">--- 8435,28 ---</span>
          m_hasEvaluatedUserAgentScripts = true;
      else
          top.setHasEvaluatedUserAgentScripts();
  }
  
<span class="line-added">+ void Document::didRejectSyncXHRDuringPageDismissal()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ++m_numberOfRejectedSyncXHRs;</span>
<span class="line-added">+     if (m_numberOfRejectedSyncXHRs &gt; 1)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     postTask([this, weakThis = makeWeakPtr(*this)](auto&amp;) mutable {</span>
<span class="line-added">+         if (weakThis)</span>
<span class="line-added">+             m_numberOfRejectedSyncXHRs = 0;</span>
<span class="line-added">+     });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Document::shouldIgnoreSyncXHRs() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     const unsigned maxRejectedSyncXHRsPerEventLoopIteration = 5;</span>
<span class="line-added">+     return m_numberOfRejectedSyncXHRs &gt; maxRejectedSyncXHRsPerEventLoopIteration;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #if ENABLE(APPLE_PAY)
  
  bool Document::isApplePayActive() const
  {
      auto&amp; top = topDocument();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8283,6 ***</span>
<span class="line-new-header">--- 8472,46 ---</span>
          top.setApplePayIsActive();
  }
  
  #endif
  
<span class="line-added">+ MessagePortChannelProvider&amp; Document::messagePortChannelProvider()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return MessagePortChannelProvider::singleton();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if USE(SYSTEM_PREVIEW)</span>
<span class="line-added">+ void Document::dispatchSystemPreviewActionEvent(const SystemPreviewInfo&amp; systemPreviewInfo, const String&amp; message)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto* element = searchForElementByIdentifier(systemPreviewInfo.element.elementIdentifier);</span>
<span class="line-added">+     if (!element)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!is&lt;HTMLAnchorElement&gt;(element))</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto event = MessageEvent::create(message, securityOrigin().toString());</span>
<span class="line-added">+     UserGestureIndicator gestureIndicator(ProcessingUserGesture, this);</span>
<span class="line-added">+     element-&gt;dispatchEvent(event);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">+ HTMLVideoElement* Document::pictureInPictureElement() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return m_pictureInPictureElement.get();</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Document::setPictureInPictureElement(HTMLVideoElement* element)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_pictureInPictureElement = makeWeakPtr(element);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ TextManipulationController&amp; Document::textManipulationController()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_textManipulationController)</span>
<span class="line-added">+         m_textManipulationController = makeUnique&lt;TextManipulationController&gt;(*this);</span>
<span class="line-added">+     return *m_textManipulationController;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  } // namespace WebCore
</pre>
<center><a href="DeviceOrientationOrMotionEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Document.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
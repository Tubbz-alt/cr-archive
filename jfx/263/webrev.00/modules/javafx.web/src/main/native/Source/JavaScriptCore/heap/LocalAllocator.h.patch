diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/LocalAllocator.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/LocalAllocator.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/LocalAllocator.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/LocalAllocator.h
@@ -32,19 +32,20 @@
 
 namespace JSC {
 
 class BlockDirectory;
 class GCDeferralContext;
+class Heap;
 
 class LocalAllocator : public BasicRawSentinelNode<LocalAllocator> {
     WTF_MAKE_NONCOPYABLE(LocalAllocator);
 
 public:
     LocalAllocator(BlockDirectory*);
     ~LocalAllocator();
 
-    void* allocate(GCDeferralContext*, AllocationFailureMode);
+    void* allocate(Heap&, GCDeferralContext*, AllocationFailureMode);
 
     unsigned cellSize() const { return m_freeList.cellSize(); }
 
     void stopAllocating();
     void prepareForAllocation();
@@ -58,26 +59,26 @@
 
 private:
     friend class BlockDirectory;
 
     void reset();
-    JS_EXPORT_PRIVATE void* allocateSlowCase(GCDeferralContext*, AllocationFailureMode failureMode);
+    JS_EXPORT_PRIVATE void* allocateSlowCase(Heap&, GCDeferralContext*, AllocationFailureMode);
     void didConsumeFreeList();
     void* tryAllocateWithoutCollecting();
     void* tryAllocateIn(MarkedBlock::Handle*);
     void* allocateIn(MarkedBlock::Handle*);
-    ALWAYS_INLINE void doTestCollectionsIfNeeded(GCDeferralContext*);
+    ALWAYS_INLINE void doTestCollectionsIfNeeded(Heap&, GCDeferralContext*);
 
     BlockDirectory* m_directory;
     FreeList m_freeList;
 
     MarkedBlock::Handle* m_currentBlock { nullptr };
     MarkedBlock::Handle* m_lastActiveBlock { nullptr };
 
     // After you do something to a block based on one of these cursors, you clear the bit in the
     // corresponding bitvector and leave the cursor where it was.
-    size_t m_allocationCursor { 0 }; // Points to the next block that is a candidate for allocation.
+    unsigned m_allocationCursor { 0 }; // Points to the next block that is a candidate for allocation.
 };
 
 inline ptrdiff_t LocalAllocator::offsetOfFreeList()
 {
     return OBJECT_OFFSETOF(LocalAllocator, m_freeList);

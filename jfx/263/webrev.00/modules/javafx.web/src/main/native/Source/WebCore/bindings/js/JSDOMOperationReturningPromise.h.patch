diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMOperationReturningPromise.h b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMOperationReturningPromise.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMOperationReturningPromise.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMOperationReturningPromise.h
@@ -30,68 +30,68 @@
 
 template<typename JSClass>
 class IDLOperationReturningPromise {
 public:
     using ClassParameter = JSClass*;
-    using Operation = JSC::EncodedJSValue(JSC::ExecState*, ClassParameter, Ref<DeferredPromise>&&, JSC::ThrowScope&);
-    using StaticOperation = JSC::EncodedJSValue(JSC::ExecState*, Ref<DeferredPromise>&&, JSC::ThrowScope&);
+    using Operation = JSC::EncodedJSValue(JSC::JSGlobalObject*, JSC::CallFrame*, ClassParameter, Ref<DeferredPromise>&&, JSC::ThrowScope&);
+    using StaticOperation = JSC::EncodedJSValue(JSC::JSGlobalObject*, JSC::CallFrame*, Ref<DeferredPromise>&&, JSC::ThrowScope&);
 
-    template<Operation operation, PromiseExecutionScope executionScope, CastedThisErrorBehavior shouldThrow = CastedThisErrorBehavior::RejectPromise>
-    static JSC::EncodedJSValue call(JSC::ExecState& state, const char* operationName)
+    template<Operation operation, CastedThisErrorBehavior shouldThrow = CastedThisErrorBehavior::RejectPromise>
+    static JSC::EncodedJSValue call(JSC::JSGlobalObject& lexicalGlobalObject, JSC::CallFrame& callFrame, const char* operationName)
     {
-        return JSC::JSValue::encode(callPromiseFunction<executionScope>(state, [&operationName] (JSC::ExecState& state, Ref<DeferredPromise>&& promise) {
-            auto throwScope = DECLARE_THROW_SCOPE(state.vm());
+        return JSC::JSValue::encode(callPromiseFunction(lexicalGlobalObject, callFrame, [&operationName] (JSC::JSGlobalObject& lexicalGlobalObject, JSC::CallFrame& callFrame, Ref<DeferredPromise>&& promise) {
+            auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(&lexicalGlobalObject));
 
-            auto* thisObject = IDLOperation<JSClass>::cast(state);
+            auto* thisObject = IDLOperation<JSClass>::cast(lexicalGlobalObject, callFrame);
             if (shouldThrow != CastedThisErrorBehavior::Assert && UNLIKELY(!thisObject))
                 return rejectPromiseWithThisTypeError(promise.get(), JSClass::info()->className, operationName);
 
             ASSERT(thisObject);
             ASSERT_GC_OBJECT_INHERITS(thisObject, JSClass::info());
 
-            // FIXME: We should refactor the binding generated code to use references for state and thisObject.
-            return operation(&state, thisObject, WTFMove(promise), throwScope);
+            // FIXME: We should refactor the binding generated code to use references for lexicalGlobalObject and thisObject.
+            return operation(&lexicalGlobalObject, &callFrame, thisObject, WTFMove(promise), throwScope);
         }));
     }
 
     // This function is a special case for custom operations want to handle the creation of the promise themselves.
     // It is triggered via the extended attribute [ReturnsOwnPromise].
     template<typename IDLOperation<JSClass>::Operation operation, CastedThisErrorBehavior shouldThrow = CastedThisErrorBehavior::RejectPromise>
-    static JSC::EncodedJSValue callReturningOwnPromise(JSC::ExecState& state, const char* operationName)
+    static JSC::EncodedJSValue callReturningOwnPromise(JSC::JSGlobalObject& lexicalGlobalObject, JSC::CallFrame& callFrame, const char* operationName)
     {
-        auto throwScope = DECLARE_THROW_SCOPE(state.vm());
+        auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(&lexicalGlobalObject));
 
-        auto* thisObject = IDLOperation<JSClass>::cast(state);
+        auto* thisObject = IDLOperation<JSClass>::cast(lexicalGlobalObject, callFrame);
         if (shouldThrow != CastedThisErrorBehavior::Assert && UNLIKELY(!thisObject))
-            return rejectPromiseWithThisTypeError(state, JSClass::info()->className, operationName);
+            return rejectPromiseWithThisTypeError(lexicalGlobalObject, JSClass::info()->className, operationName);
 
         ASSERT(thisObject);
         ASSERT_GC_OBJECT_INHERITS(thisObject, JSClass::info());
 
-        // FIXME: We should refactor the binding generated code to use references for state and thisObject.
-        return operation(&state, thisObject, throwScope);
+        // FIXME: We should refactor the binding generated code to use references for lexicalGlobalObject and thisObject.
+        return operation(&lexicalGlobalObject, &callFrame, thisObject, throwScope);
     }
 
-    template<StaticOperation operation, PromiseExecutionScope executionScope, CastedThisErrorBehavior shouldThrow = CastedThisErrorBehavior::RejectPromise>
-    static JSC::EncodedJSValue callStatic(JSC::ExecState& state, const char*)
+    template<StaticOperation operation, CastedThisErrorBehavior shouldThrow = CastedThisErrorBehavior::RejectPromise>
+    static JSC::EncodedJSValue callStatic(JSC::JSGlobalObject& lexicalGlobalObject, JSC::CallFrame& callFrame, const char*)
     {
-        return JSC::JSValue::encode(callPromiseFunction<executionScope>(state, [] (JSC::ExecState& state, Ref<DeferredPromise>&& promise) {
-            auto throwScope = DECLARE_THROW_SCOPE(state.vm());
+        return JSC::JSValue::encode(callPromiseFunction(lexicalGlobalObject, callFrame, [] (JSC::JSGlobalObject& lexicalGlobalObject, JSC::CallFrame& callFrame, Ref<DeferredPromise>&& promise) {
+            auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(&lexicalGlobalObject));
 
-            // FIXME: We should refactor the binding generated code to use references for state.
-            return operation(&state, WTFMove(promise), throwScope);
+            // FIXME: We should refactor the binding generated code to use references for lexicalGlobalObject.
+            return operation(&lexicalGlobalObject, &callFrame, WTFMove(promise), throwScope);
         }));
     }
 
     // This function is a special case for custom operations want to handle the creation of the promise themselves.
     // It is triggered via the extended attribute [ReturnsOwnPromise].
     template<typename IDLOperation<JSClass>::StaticOperation operation, CastedThisErrorBehavior shouldThrow = CastedThisErrorBehavior::RejectPromise>
-    static JSC::EncodedJSValue callStaticReturningOwnPromise(JSC::ExecState& state, const char*)
+    static JSC::EncodedJSValue callStaticReturningOwnPromise(JSC::JSGlobalObject& lexicalGlobalObject, JSC::CallFrame& callFrame, const char*)
     {
-        auto throwScope = DECLARE_THROW_SCOPE(state.vm());
+        auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(&lexicalGlobalObject));
 
-        // FIXME: We should refactor the binding generated code to use references for state.
-        return operation(&state, throwScope);
+        // FIXME: We should refactor the binding generated code to use references for lexicalGlobalObject.
+        return operation(&lexicalGlobalObject, &callFrame, throwScope);
     }
 };
 
 } // namespace WebCore

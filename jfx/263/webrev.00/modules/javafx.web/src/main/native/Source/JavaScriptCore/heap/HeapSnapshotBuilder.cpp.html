<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/HeapSnapshotBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;HeapSnapshotBuilder.h&quot;
 28 
 29 #include &quot;DeferGC.h&quot;
 30 #include &quot;Heap.h&quot;
 31 #include &quot;HeapProfiler.h&quot;
 32 #include &quot;HeapSnapshot.h&quot;
 33 #include &quot;JSCInlines.h&quot;
 34 #include &quot;JSCast.h&quot;
 35 #include &quot;PreventCollectionScope.h&quot;
 36 #include &quot;VM.h&quot;
 37 #include &lt;wtf/HexNumber.h&gt;
 38 #include &lt;wtf/text/StringBuilder.h&gt;
 39 
 40 namespace JSC {
 41 
 42 static const char* rootTypeToString(SlotVisitor::RootMarkReason);
 43 
 44 NodeIdentifier HeapSnapshotBuilder::nextAvailableObjectIdentifier = 1;
 45 NodeIdentifier HeapSnapshotBuilder::getNextObjectIdentifier() { return nextAvailableObjectIdentifier++; }
 46 void HeapSnapshotBuilder::resetNextAvailableObjectIdentifier() { HeapSnapshotBuilder::nextAvailableObjectIdentifier = 1; }
 47 
 48 HeapSnapshotBuilder::HeapSnapshotBuilder(HeapProfiler&amp; profiler, SnapshotType type)
 49     : HeapAnalyzer()
 50     , m_profiler(profiler)
 51     , m_snapshotType(type)
 52 {
 53 }
 54 
 55 HeapSnapshotBuilder::~HeapSnapshotBuilder()
 56 {
 57     if (m_snapshotType == SnapshotType::GCDebuggingSnapshot)
 58         m_profiler.clearSnapshots();
 59 }
 60 
 61 void HeapSnapshotBuilder::buildSnapshot()
 62 {
 63     // GCDebuggingSnapshot are always full snapshots, so clear any existing snapshots.
 64     if (m_snapshotType == SnapshotType::GCDebuggingSnapshot)
 65         m_profiler.clearSnapshots();
 66 
 67     PreventCollectionScope preventCollectionScope(m_profiler.vm().heap);
 68 
 69     m_snapshot = makeUnique&lt;HeapSnapshot&gt;(m_profiler.mostRecentSnapshot());
 70     {
 71         ASSERT(!m_profiler.activeHeapAnalyzer());
 72         m_profiler.setActiveHeapAnalyzer(this);
 73         m_profiler.vm().heap.collectNow(Sync, CollectionScope::Full);
 74         m_profiler.setActiveHeapAnalyzer(nullptr);
 75     }
 76     m_snapshot-&gt;finalize();
 77 
 78     m_profiler.appendSnapshot(WTFMove(m_snapshot));
 79 }
 80 
 81 void HeapSnapshotBuilder::analyzeNode(JSCell* cell)
 82 {
 83     ASSERT(m_profiler.activeHeapAnalyzer() == this);
 84 
 85     ASSERT(m_profiler.vm().heap.isMarked(cell));
 86 
 87     NodeIdentifier identifier;
 88     if (previousSnapshotHasNodeForCell(cell, identifier))
 89         return;
 90 
 91     std::lock_guard&lt;Lock&gt; lock(m_buildingNodeMutex);
 92     m_snapshot-&gt;appendNode(HeapSnapshotNode(cell, getNextObjectIdentifier()));
 93 }
 94 
 95 void HeapSnapshotBuilder::analyzeEdge(JSCell* from, JSCell* to, SlotVisitor::RootMarkReason rootMarkReason)
 96 {
 97     ASSERT(m_profiler.activeHeapAnalyzer() == this);
 98     ASSERT(to);
 99 
100     // Avoid trivial edges.
101     if (from == to)
102         return;
103 
104     std::lock_guard&lt;Lock&gt; lock(m_buildingEdgeMutex);
105 
106     if (m_snapshotType == SnapshotType::GCDebuggingSnapshot &amp;&amp; !from) {
107         if (rootMarkReason == SlotVisitor::RootMarkReason::None &amp;&amp; m_snapshotType == SnapshotType::GCDebuggingSnapshot)
108             WTFLogAlways(&quot;Cell %p is a root but no root marking reason was supplied&quot;, to);
109 
110         m_rootData.ensure(to, [] () -&gt; RootData {
111             return { };
112         }).iterator-&gt;value.markReason = rootMarkReason;
113     }
114 
115     m_edges.append(HeapSnapshotEdge(from, to));
116 }
117 
118 void HeapSnapshotBuilder::analyzePropertyNameEdge(JSCell* from, JSCell* to, UniquedStringImpl* propertyName)
119 {
120     ASSERT(m_profiler.activeHeapAnalyzer() == this);
121     ASSERT(to);
122 
123     std::lock_guard&lt;Lock&gt; lock(m_buildingEdgeMutex);
124 
125     m_edges.append(HeapSnapshotEdge(from, to, EdgeType::Property, propertyName));
126 }
127 
128 void HeapSnapshotBuilder::analyzeVariableNameEdge(JSCell* from, JSCell* to, UniquedStringImpl* variableName)
129 {
130     ASSERT(m_profiler.activeHeapAnalyzer() == this);
131     ASSERT(to);
132 
133     std::lock_guard&lt;Lock&gt; lock(m_buildingEdgeMutex);
134 
135     m_edges.append(HeapSnapshotEdge(from, to, EdgeType::Variable, variableName));
136 }
137 
138 void HeapSnapshotBuilder::analyzeIndexEdge(JSCell* from, JSCell* to, uint32_t index)
139 {
140     ASSERT(m_profiler.activeHeapAnalyzer() == this);
141     ASSERT(to);
142 
143     std::lock_guard&lt;Lock&gt; lock(m_buildingEdgeMutex);
144 
145     m_edges.append(HeapSnapshotEdge(from, to, index));
146 }
147 
148 void HeapSnapshotBuilder::setOpaqueRootReachabilityReasonForCell(JSCell* cell, const char* reason)
149 {
150     if (!reason || !*reason || m_snapshotType != SnapshotType::GCDebuggingSnapshot)
151         return;
152 
153     std::lock_guard&lt;Lock&gt; lock(m_buildingEdgeMutex);
154 
155     m_rootData.ensure(cell, [] () -&gt; RootData {
156         return { };
157     }).iterator-&gt;value.reachabilityFromOpaqueRootReasons = reason;
158 }
159 
160 void HeapSnapshotBuilder::setWrappedObjectForCell(JSCell* cell, void* wrappedPtr)
161 {
162     m_wrappedObjectPointers.set(cell, wrappedPtr);
163 }
164 
165 bool HeapSnapshotBuilder::previousSnapshotHasNodeForCell(JSCell* cell, NodeIdentifier&amp; identifier)
166 {
167     if (!m_snapshot-&gt;previous())
168         return false;
169 
170     auto existingNode = m_snapshot-&gt;previous()-&gt;nodeForCell(cell);
171     if (existingNode) {
172         identifier = existingNode.value().identifier;
173         return true;
174     }
175 
176     return false;
177 }
178 
179 // Heap Snapshot JSON Format:
180 //
181 //  Inspector snapshots:
182 //
183 //   {
184 //      &quot;version&quot;: 2,
185 //      &quot;type&quot;: &quot;Inspector&quot;,
186 //      // [&lt;address&gt;, &lt;labelIndex&gt;, &lt;wrappedAddress&gt;] only present in GCDebuggingSnapshot-type snapshots
187 //      &quot;nodes&quot;: [
188 //          &lt;nodeId&gt;, &lt;sizeInBytes&gt;, &lt;nodeClassNameIndex&gt;, &lt;flags&gt;
189 //          &lt;nodeId&gt;, &lt;sizeInBytes&gt;, &lt;nodeClassNameIndex&gt;, &lt;flags&gt;
190 //          ...
191 //      ],
192 //      &quot;nodeClassNames&quot;: [
193 //          &quot;string&quot;, &quot;Structure&quot;, &quot;Object&quot;, ...
194 //      ],
195 //      &quot;edges&quot;: [
196 //          &lt;fromNodeId&gt;, &lt;toNodeId&gt;, &lt;edgeTypeIndex&gt;, &lt;edgeExtraData&gt;,
197 //          &lt;fromNodeId&gt;, &lt;toNodeId&gt;, &lt;edgeTypeIndex&gt;, &lt;edgeExtraData&gt;,
198 //          ...
199 //      ],
200 //      &quot;edgeTypes&quot;: [
201 //          &quot;Internal&quot;, &quot;Property&quot;, &quot;Index&quot;, &quot;Variable&quot;
202 //      ],
203 //      &quot;edgeNames&quot;: [
204 //          &quot;propertyName&quot;, &quot;variableName&quot;, ...
205 //      ]
206 //   }
207 //
208 //  GC heap debugger snapshots:
209 //
210 //   {
211 //      &quot;version&quot;: 2,
212 //      &quot;type&quot;: &quot;GCDebugging&quot;,
213 //      &quot;nodes&quot;: [
214 //          &lt;nodeId&gt;, &lt;sizeInBytes&gt;, &lt;nodeClassNameIndex&gt;, &lt;flags&gt;, &lt;labelIndex&gt;, &lt;cellEddress&gt;, &lt;wrappedAddress&gt;,
215 //          &lt;nodeId&gt;, &lt;sizeInBytes&gt;, &lt;nodeClassNameIndex&gt;, &lt;flags&gt;, &lt;labelIndex&gt;, &lt;cellEddress&gt;, &lt;wrappedAddress&gt;,
216 //          ...
217 //      ],
218 //      &quot;nodeClassNames&quot;: [
219 //          &quot;string&quot;, &quot;Structure&quot;, &quot;Object&quot;, ...
220 //      ],
221 //      &quot;edges&quot;: [
222 //          &lt;fromNodeId&gt;, &lt;toNodeId&gt;, &lt;edgeTypeIndex&gt;, &lt;edgeExtraData&gt;,
223 //          &lt;fromNodeId&gt;, &lt;toNodeId&gt;, &lt;edgeTypeIndex&gt;, &lt;edgeExtraData&gt;,
224 //          ...
225 //      ],
226 //      &quot;edgeTypes&quot;: [
227 //          &quot;Internal&quot;, &quot;Property&quot;, &quot;Index&quot;, &quot;Variable&quot;
228 //      ],
229 //      &quot;edgeNames&quot;: [
230 //          &quot;propertyName&quot;, &quot;variableName&quot;, ...
231 //      ],
232 //      &quot;roots&quot; : [
233 //          &lt;nodeId&gt;, &lt;rootReasonIndex&gt;, &lt;reachabilityReasonIndex&gt;,
234 //          &lt;nodeId&gt;, &lt;rootReasonIndex&gt;, &lt;reachabilityReasonIndex&gt;,
235 //          ... // &lt;nodeId&gt; may be repeated
236 //      ],
237 //      &quot;labels&quot; : [
238 //          &quot;foo&quot;, &quot;bar&quot;, ...
239 //      ]
240 //   }
241 //
242 // Notes:
243 //
244 //     &lt;nodeClassNameIndex&gt;
245 //       - index into the &quot;nodeClassNames&quot; list.
246 //
247 //     &lt;flags&gt;
248 //       - 0b0000 - no flags
249 //       - 0b0001 - internal instance
250 //       - 0b0010 - Object subclassification
251 //
252 //     &lt;edgeTypeIndex&gt;
253 //       - index into the &quot;edgeTypes&quot; list.
254 //
255 //     &lt;edgeExtraData&gt;
256 //       - for Internal edges this should be ignored (0).
257 //       - for Index edges this is the index value.
258 //       - for Property or Variable edges this is an index into the &quot;edgeNames&quot; list.
259 //
260 //      &lt;rootReasonIndex&gt;
261 //       - index into the &quot;labels&quot; list.
262 
263 enum class NodeFlags {
264     Internal      = 1 &lt;&lt; 0,
265     ObjectSubtype = 1 &lt;&lt; 1,
266 };
267 
268 static uint8_t edgeTypeToNumber(EdgeType type)
269 {
270     return static_cast&lt;uint8_t&gt;(type);
271 }
272 
273 static const char* edgeTypeToString(EdgeType type)
274 {
275     switch (type) {
276     case EdgeType::Internal:
277         return &quot;Internal&quot;;
278     case EdgeType::Property:
279         return &quot;Property&quot;;
280     case EdgeType::Index:
281         return &quot;Index&quot;;
282     case EdgeType::Variable:
283         return &quot;Variable&quot;;
284     }
285     ASSERT_NOT_REACHED();
286     return &quot;Internal&quot;;
287 }
288 
289 static const char* snapshotTypeToString(HeapSnapshotBuilder::SnapshotType type)
290 {
291     switch (type) {
292     case HeapSnapshotBuilder::SnapshotType::InspectorSnapshot:
293         return &quot;Inspector&quot;;
294     case HeapSnapshotBuilder::SnapshotType::GCDebuggingSnapshot:
295         return &quot;GCDebugging&quot;;
296     }
297     ASSERT_NOT_REACHED();
298     return &quot;Inspector&quot;;
299 }
300 
301 static const char* rootTypeToString(SlotVisitor::RootMarkReason type)
302 {
303     switch (type) {
304     case SlotVisitor::RootMarkReason::None:
305         return &quot;None&quot;;
306     case SlotVisitor::RootMarkReason::ConservativeScan:
307         return &quot;Conservative scan&quot;;
308     case SlotVisitor::RootMarkReason::StrongReferences:
309         return &quot;Strong references&quot;;
310     case SlotVisitor::RootMarkReason::ProtectedValues:
311         return &quot;Protected values&quot;;
312     case SlotVisitor::RootMarkReason::MarkListSet:
313         return &quot;Mark list set&quot;;
314     case SlotVisitor::RootMarkReason::VMExceptions:
315         return &quot;VM exceptions&quot;;
316     case SlotVisitor::RootMarkReason::StrongHandles:
317         return &quot;Strong handles&quot;;
318     case SlotVisitor::RootMarkReason::Debugger:
319         return &quot;Debugger&quot;;
320     case SlotVisitor::RootMarkReason::JITStubRoutines:
321         return &quot;JIT stub routines&quot;;
322     case SlotVisitor::RootMarkReason::WeakSets:
323         return &quot;Weak sets&quot;;
324     case SlotVisitor::RootMarkReason::Output:
325         return &quot;Output&quot;;
326     case SlotVisitor::RootMarkReason::DFGWorkLists:
327         return &quot;DFG work lists&quot;;
328     case SlotVisitor::RootMarkReason::CodeBlocks:
329         return &quot;Code blocks&quot;;
330     case SlotVisitor::RootMarkReason::DOMGCOutput:
331         return &quot;DOM GC output&quot;;
332     }
333     ASSERT_NOT_REACHED();
334     return &quot;None&quot;;
335 }
336 
337 String HeapSnapshotBuilder::json()
338 {
339     return json([] (const HeapSnapshotNode&amp;) { return true; });
340 }
341 
342 void HeapSnapshotBuilder::setLabelForCell(JSCell* cell, const String&amp; label)
343 {
344     m_cellLabels.set(cell, label);
345 }
346 
347 String HeapSnapshotBuilder::descriptionForCell(JSCell *cell) const
348 {
349     if (cell-&gt;isString())
350         return emptyString(); // FIXME: get part of string.
351 
352     VM&amp; vm = m_profiler.vm();
353     Structure* structure = cell-&gt;structure(vm);
354 
355     if (structure-&gt;classInfo()-&gt;isSubClassOf(Structure::info())) {
356         Structure* cellAsStructure = jsCast&lt;Structure*&gt;(cell);
357         return cellAsStructure-&gt;classInfo()-&gt;className;
358     }
359 
360     return emptyString();
361 }
362 
363 String HeapSnapshotBuilder::json(Function&lt;bool (const HeapSnapshotNode&amp;)&gt; allowNodeCallback)
364 {
365     VM&amp; vm = m_profiler.vm();
366     DeferGCForAWhile deferGC(vm.heap);
367 
368     // Build a node to identifier map of allowed nodes to use when serializing edges.
369     HashMap&lt;JSCell*, NodeIdentifier&gt; allowedNodeIdentifiers;
370 
371     // Build a list of used class names.
372     HashMap&lt;String, unsigned&gt; classNameIndexes;
373     classNameIndexes.set(&quot;&lt;root&gt;&quot;_s, 0);
374     unsigned nextClassNameIndex = 1;
375 
376     // Build a list of labels (this is just a string table).
377     HashMap&lt;String, unsigned&gt; labelIndexes;
378     labelIndexes.set(emptyString(), 0);
379     unsigned nextLabelIndex = 1;
380 
381     // Build a list of used edge names.
382     HashMap&lt;UniquedStringImpl*, unsigned&gt; edgeNameIndexes;
383     unsigned nextEdgeNameIndex = 0;
384 
385     StringBuilder json;
386 
387     auto appendNodeJSON = [&amp;] (const HeapSnapshotNode&amp; node) {
388         // Let the client decide if they want to allow or disallow certain nodes.
389         if (!allowNodeCallback(node))
390             return;
391 
392         unsigned flags = 0;
393 
394         allowedNodeIdentifiers.set(node.cell, node.identifier);
395 
396         String className = node.cell-&gt;classInfo(vm)-&gt;className;
397         if (node.cell-&gt;isObject() &amp;&amp; className == JSObject::info()-&gt;className) {
398             flags |= static_cast&lt;unsigned&gt;(NodeFlags::ObjectSubtype);
399 
400             // Skip calculating a class name if this object has a `constructor` own property.
401             // These cases are typically F.prototype objects and we want to treat these as
402             // &quot;Object&quot; in snapshots and not get the name of the prototype&#39;s parent.
403             JSObject* object = asObject(node.cell);
404             if (JSGlobalObject* globalObject = object-&gt;globalObject(vm)) {
405                 PropertySlot slot(object, PropertySlot::InternalMethodType::VMInquiry);
406                 if (!object-&gt;getOwnPropertySlot(object, globalObject, vm.propertyNames-&gt;constructor, slot))
407                     className = JSObject::calculatedClassName(object);
408             }
409         }
410 
411         auto result = classNameIndexes.add(className, nextClassNameIndex);
412         if (result.isNewEntry)
413             nextClassNameIndex++;
414         unsigned classNameIndex = result.iterator-&gt;value;
415 
416         void* wrappedAddress = 0;
417         unsigned labelIndex = 0;
418         if (!node.cell-&gt;isString() &amp;&amp; !node.cell-&gt;isBigInt()) {
419             Structure* structure = node.cell-&gt;structure(vm);
420             if (!structure || !structure-&gt;globalObject())
421                 flags |= static_cast&lt;unsigned&gt;(NodeFlags::Internal);
422 
423             if (m_snapshotType == SnapshotType::GCDebuggingSnapshot) {
424                 String nodeLabel;
425                 auto it = m_cellLabels.find(node.cell);
426                 if (it != m_cellLabels.end())
427                     nodeLabel = it-&gt;value;
428 
429                 if (nodeLabel.isEmpty()) {
430                     if (auto* object = jsDynamicCast&lt;JSObject*&gt;(vm, node.cell)) {
431                         if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(vm, object))
432                             nodeLabel = function-&gt;calculatedDisplayName(vm);
433                     }
434                 }
435 
436                 String description = descriptionForCell(node.cell);
437                 if (description.length()) {
438                     if (nodeLabel.length())
439                         nodeLabel.append(&#39; &#39;);
440                     nodeLabel.append(description);
441                 }
442 
443                 if (!nodeLabel.isEmpty() &amp;&amp; m_snapshotType == SnapshotType::GCDebuggingSnapshot) {
444                     auto result = labelIndexes.add(nodeLabel, nextLabelIndex);
445                     if (result.isNewEntry)
446                         nextLabelIndex++;
447                     labelIndex = result.iterator-&gt;value;
448                 }
449 
450                 wrappedAddress = m_wrappedObjectPointers.get(node.cell);
451             }
452         }
453 
454         // &lt;nodeId&gt;, &lt;sizeInBytes&gt;, &lt;nodeClassNameIndex&gt;, &lt;flags&gt;, [&lt;labelIndex&gt;, &lt;cellEddress&gt;, &lt;wrappedAddress&gt;]
455         json.append(&#39;,&#39;);
456         json.appendNumber(node.identifier);
457         json.append(&#39;,&#39;);
458         json.appendNumber(node.cell-&gt;estimatedSizeInBytes(vm));
459         json.append(&#39;,&#39;);
460         json.appendNumber(classNameIndex);
461         json.append(&#39;,&#39;);
462         json.appendNumber(flags);
463         if (m_snapshotType == SnapshotType::GCDebuggingSnapshot) {
464             json.append(&#39;,&#39;);
465             json.appendNumber(labelIndex);
466             json.appendLiteral(&quot;,\&quot;0x&quot;);
467             json.append(hex(reinterpret_cast&lt;uintptr_t&gt;(node.cell), Lowercase));
468             json.appendLiteral(&quot;\&quot;,\&quot;0x&quot;);
469             json.append(hex(reinterpret_cast&lt;uintptr_t&gt;(wrappedAddress), Lowercase));
470             json.append(&#39;&quot;&#39;);
471         }
472     };
473 
474     bool firstEdge = true;
475     auto appendEdgeJSON = [&amp;] (const HeapSnapshotEdge&amp; edge) {
476         if (!firstEdge)
477             json.append(&#39;,&#39;);
478         firstEdge = false;
479 
480         // &lt;fromNodeId&gt;, &lt;toNodeId&gt;, &lt;edgeTypeIndex&gt;, &lt;edgeExtraData&gt;
481         json.appendNumber(edge.from.identifier);
482         json.append(&#39;,&#39;);
483         json.appendNumber(edge.to.identifier);
484         json.append(&#39;,&#39;);
485         json.appendNumber(edgeTypeToNumber(edge.type));
486         json.append(&#39;,&#39;);
487         switch (edge.type) {
488         case EdgeType::Property:
489         case EdgeType::Variable: {
490             auto result = edgeNameIndexes.add(edge.u.name, nextEdgeNameIndex);
491             if (result.isNewEntry)
492                 nextEdgeNameIndex++;
493             unsigned edgeNameIndex = result.iterator-&gt;value;
494             json.appendNumber(edgeNameIndex);
495             break;
496         }
497         case EdgeType::Index:
498             json.appendNumber(edge.u.index);
499             break;
500         default:
501             // No data for this edge type.
502             json.append(&#39;0&#39;);
503             break;
504         }
505     };
506 
507     json.append(&#39;{&#39;);
508 
509     // version
510     json.appendLiteral(&quot;\&quot;version\&quot;:2&quot;);
511 
512     // type
513     json.append(&#39;,&#39;);
514     json.appendLiteral(&quot;\&quot;type\&quot;:&quot;);
515     json.appendQuotedJSONString(snapshotTypeToString(m_snapshotType));
516 
517     // nodes
518     json.append(&#39;,&#39;);
519     json.appendLiteral(&quot;\&quot;nodes\&quot;:&quot;);
520     json.append(&#39;[&#39;);
521     // &lt;root&gt;
522     if (m_snapshotType == SnapshotType::GCDebuggingSnapshot)
523         json.appendLiteral(&quot;0,0,0,0,0,\&quot;0x0\&quot;,\&quot;0x0\&quot;&quot;);
524     else
525         json.appendLiteral(&quot;0,0,0,0&quot;);
526 
527     for (HeapSnapshot* snapshot = m_profiler.mostRecentSnapshot(); snapshot; snapshot = snapshot-&gt;previous()) {
528         for (auto&amp; node : snapshot-&gt;m_nodes)
529             appendNodeJSON(node);
530     }
531     json.append(&#39;]&#39;);
532 
533     // node class names
534     json.append(&#39;,&#39;);
535     json.appendLiteral(&quot;\&quot;nodeClassNames\&quot;:&quot;);
536     json.append(&#39;[&#39;);
537     Vector&lt;String&gt; orderedClassNames(classNameIndexes.size());
538     for (auto&amp; entry : classNameIndexes)
539         orderedClassNames[entry.value] = entry.key;
540     classNameIndexes.clear();
541     bool firstClassName = true;
542     for (auto&amp; className : orderedClassNames) {
543         if (!firstClassName)
544             json.append(&#39;,&#39;);
545         firstClassName = false;
546         json.appendQuotedJSONString(className);
547     }
548     orderedClassNames.clear();
549     json.append(&#39;]&#39;);
550 
551     // Process edges.
552     // Replace pointers with identifiers.
553     // Remove any edges that we won&#39;t need.
554     m_edges.removeAllMatching([&amp;] (HeapSnapshotEdge&amp; edge) {
555         // If the from cell is null, this means a &lt;root&gt; edge.
556         if (!edge.from.cell)
557             edge.from.identifier = 0;
558         else {
559             auto fromLookup = allowedNodeIdentifiers.find(edge.from.cell);
560             if (fromLookup == allowedNodeIdentifiers.end()) {
561                 if (m_snapshotType == SnapshotType::GCDebuggingSnapshot)
562                     WTFLogAlways(&quot;Failed to find node for from-edge cell %p&quot;, edge.from.cell);
563                 return true;
564             }
565             edge.from.identifier = fromLookup-&gt;value;
566         }
567 
568         if (!edge.to.cell)
569             edge.to.identifier = 0;
570         else {
571             auto toLookup = allowedNodeIdentifiers.find(edge.to.cell);
572             if (toLookup == allowedNodeIdentifiers.end()) {
573                 if (m_snapshotType == SnapshotType::GCDebuggingSnapshot)
574                     WTFLogAlways(&quot;Failed to find node for to-edge cell %p&quot;, edge.to.cell);
575                 return true;
576             }
577             edge.to.identifier = toLookup-&gt;value;
578         }
579 
580         return false;
581     });
582 
583     allowedNodeIdentifiers.clear();
584     m_edges.shrinkToFit();
585 
586     // Sort edges based on from identifier.
587     std::sort(m_edges.begin(), m_edges.end(), [&amp;] (const HeapSnapshotEdge&amp; a, const HeapSnapshotEdge&amp; b) {
588         return a.from.identifier &lt; b.from.identifier;
589     });
590 
591     // edges
592     json.append(&#39;,&#39;);
593     json.appendLiteral(&quot;\&quot;edges\&quot;:&quot;);
594     json.append(&#39;[&#39;);
595     for (auto&amp; edge : m_edges)
596         appendEdgeJSON(edge);
597     json.append(&#39;]&#39;);
598 
599     // edge types
600     json.append(&#39;,&#39;);
601     json.appendLiteral(&quot;\&quot;edgeTypes\&quot;:&quot;);
602     json.append(&#39;[&#39;);
603     json.appendQuotedJSONString(edgeTypeToString(EdgeType::Internal));
604     json.append(&#39;,&#39;);
605     json.appendQuotedJSONString(edgeTypeToString(EdgeType::Property));
606     json.append(&#39;,&#39;);
607     json.appendQuotedJSONString(edgeTypeToString(EdgeType::Index));
608     json.append(&#39;,&#39;);
609     json.appendQuotedJSONString(edgeTypeToString(EdgeType::Variable));
610     json.append(&#39;]&#39;);
611 
612     // edge names
613     json.append(&#39;,&#39;);
614     json.appendLiteral(&quot;\&quot;edgeNames\&quot;:&quot;);
615     json.append(&#39;[&#39;);
616     Vector&lt;UniquedStringImpl*&gt; orderedEdgeNames(edgeNameIndexes.size());
617     for (auto&amp; entry : edgeNameIndexes)
618         orderedEdgeNames[entry.value] = entry.key;
619     edgeNameIndexes.clear();
620     bool firstEdgeName = true;
621     for (auto&amp; edgeName : orderedEdgeNames) {
622         if (!firstEdgeName)
623             json.append(&#39;,&#39;);
624         firstEdgeName = false;
625         json.appendQuotedJSONString(edgeName);
626     }
627     orderedEdgeNames.clear();
628     json.append(&#39;]&#39;);
629 
630     if (m_snapshotType == SnapshotType::GCDebuggingSnapshot) {
631         json.append(&#39;,&#39;);
632         json.appendLiteral(&quot;\&quot;roots\&quot;:&quot;);
633         json.append(&#39;[&#39;);
634 
635         HeapSnapshot* snapshot = m_profiler.mostRecentSnapshot();
636 
637         bool firstNode = true;
638         for (auto it : m_rootData) {
639             auto snapshotNode = snapshot-&gt;nodeForCell(it.key);
640             if (!snapshotNode) {
641                 WTFLogAlways(&quot;Failed to find snapshot node for cell %p&quot;, it.key);
642                 continue;
643             }
644 
645             if (!firstNode)
646                 json.append(&#39;,&#39;);
647 
648             firstNode = false;
649             json.appendNumber(snapshotNode.value().identifier);
650 
651             // Maybe we should just always encode the root names.
652             const char* rootName = rootTypeToString(it.value.markReason);
653             auto result = labelIndexes.add(rootName, nextLabelIndex);
654             if (result.isNewEntry)
655                 nextLabelIndex++;
656             unsigned labelIndex = result.iterator-&gt;value;
657             json.append(&#39;,&#39;);
658             json.appendNumber(labelIndex);
659 
660             unsigned reachabilityReasonIndex = 0;
661             if (it.value.reachabilityFromOpaqueRootReasons) {
662                 auto result = labelIndexes.add(it.value.reachabilityFromOpaqueRootReasons, nextLabelIndex);
663                 if (result.isNewEntry)
664                     nextLabelIndex++;
665                 reachabilityReasonIndex = result.iterator-&gt;value;
666             }
667             json.append(&#39;,&#39;);
668             json.appendNumber(reachabilityReasonIndex);
669         }
670 
671         json.append(&#39;]&#39;);
672     }
673 
674     if (m_snapshotType == SnapshotType::GCDebuggingSnapshot) {
675         // internal node descriptions
676         json.append(&#39;,&#39;);
677         json.appendLiteral(&quot;\&quot;labels\&quot;:&quot;);
678         json.append(&#39;[&#39;);
679 
680         Vector&lt;String&gt; orderedLabels(labelIndexes.size());
681         for (auto&amp; entry : labelIndexes)
682             orderedLabels[entry.value] = entry.key;
683         labelIndexes.clear();
684         bool firstLabel = true;
685         for (auto&amp; label : orderedLabels) {
686             if (!firstLabel)
687                 json.append(&#39;,&#39;);
688 
689             firstLabel = false;
690             json.appendQuotedJSONString(label);
691         }
692         orderedLabels.clear();
693 
694         json.append(&#39;]&#39;);
695     }
696 
697     json.append(&#39;}&#39;);
698     return json.toString();
699 }
700 
701 } // namespace JSC
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/scripts/codegen/generate_js_backend_commands.py</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="generate_cpp_protocol_types_implementation.py.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="generate_objc_backend_dispatcher_implementation.py.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/scripts/codegen/generate_js_backend_commands.py</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 48 
 49     def output_filename(self):
 50         return &quot;InspectorBackendCommands.js&quot;
 51 
 52     def should_generate_domain(self, domain):
 53         type_declarations = self.type_declarations_for_domain(domain)
 54         domain_enum_types = [declaration for declaration in type_declarations if isinstance(declaration.type, EnumType)]
 55         return self.version_for_domain(domain) is not None or len(self.commands_for_domain(domain)) &gt; 0 or len(self.events_for_domain(domain)) &gt; 0 or len(domain_enum_types) &gt; 0
 56 
 57     def domains_to_generate(self):
 58         return list(filter(self.should_generate_domain, Generator.domains_to_generate(self)))
 59 
 60     def generate_output(self):
 61         sections = []
 62         sections.append(self.generate_license())
 63         sections.extend(list(map(self.generate_domain, self.domains_to_generate())))
 64         return &quot;\n\n&quot;.join(sections)
 65 
 66     def generate_domain(self, domain):
 67         lines = []
<span class="line-removed"> 68         args = {</span>
<span class="line-removed"> 69             &#39;domain&#39;: domain.domain_name</span>
<span class="line-removed"> 70         }</span>
 71 
<span class="line-modified"> 72         lines.append(&#39;// %(domain)s.&#39; % args)</span>



 73 
 74         version = self.version_for_domain(domain)
 75         type_declarations = self.type_declarations_for_domain(domain)
 76         commands = self.commands_for_domain(domain)
 77         events = self.events_for_domain(domain)
 78 
<span class="line-modified"> 79         has_async_commands = any([command.is_async for command in commands])</span>
<span class="line-modified"> 80         if len(events) &gt; 0 or has_async_commands:</span>
<span class="line-modified"> 81             lines.append(&#39;InspectorBackend.register%(domain)sDispatcher = InspectorBackend.registerDomainDispatcher.bind(InspectorBackend, &quot;%(domain)s&quot;);&#39; % args)</span>


 82 
 83         if isinstance(version, int):
 84             version_args = {
<span class="line-modified"> 85                 &#39;domain&#39;: domain.domain_name,</span>
 86                 &#39;version&#39;: version
 87             }
<span class="line-modified"> 88             lines.append(&#39;InspectorBackend.registerVersion(&quot;%(domain)s&quot;, %(version)s);&#39; % version_args)</span>
 89 
 90         for declaration in type_declarations:
 91             if declaration.type.is_enum():
 92                 enum_args = {
<span class="line-modified"> 93                     &#39;domain&#39;: domain.domain_name,</span>
 94                     &#39;enumName&#39;: declaration.type_name,
 95                     &#39;enumMap&#39;: &quot;, &quot;.join([&#39;%s: &quot;%s&quot;&#39; % (Generator.stylized_name_for_enum_value(enum_value), enum_value) for enum_value in declaration.type.enum_values()])
 96                 }
<span class="line-modified"> 97                 lines.append(&#39;InspectorBackend.registerEnum(&quot;%(domain)s.%(enumName)s&quot;, {%(enumMap)s});&#39; % enum_args)</span>
 98 
 99             def is_anonymous_enum_member(type_member):
100                 return isinstance(type_member.type, EnumType) and type_member.type.is_anonymous
101 
102             for _member in filter(is_anonymous_enum_member, declaration.type_members):
103                 enum_args = {
<span class="line-modified">104                     &#39;domain&#39;: domain.domain_name,</span>
105                     &#39;enumName&#39;: &#39;%s%s&#39; % (declaration.type_name, ucfirst(_member.member_name)),
106                     &#39;enumMap&#39;: &quot;, &quot;.join([&#39;%s: &quot;%s&quot;&#39; % (Generator.stylized_name_for_enum_value(enum_value), enum_value) for enum_value in _member.type.enum_values()])
107                 }
<span class="line-modified">108                 lines.append(&#39;InspectorBackend.registerEnum(&quot;%(domain)s.%(enumName)s&quot;, {%(enumMap)s});&#39; % enum_args)</span>
109 
110         def is_anonymous_enum_param(param):
111             return isinstance(param.type, EnumType) and param.type.is_anonymous
112 
<span class="line-removed">113         for event in events:</span>
<span class="line-removed">114             for param in filter(is_anonymous_enum_param, event.event_parameters):</span>
<span class="line-removed">115                 enum_args = {</span>
<span class="line-removed">116                     &#39;domain&#39;: domain.domain_name,</span>
<span class="line-removed">117                     &#39;enumName&#39;: &#39;%s%s&#39; % (ucfirst(event.event_name), ucfirst(param.parameter_name)),</span>
<span class="line-removed">118                     &#39;enumMap&#39;: &quot;, &quot;.join([&#39;%s: &quot;%s&quot;&#39; % (Generator.stylized_name_for_enum_value(enum_value), enum_value) for enum_value in param.type.enum_values()])</span>
<span class="line-removed">119                 }</span>
<span class="line-removed">120                 lines.append(&#39;InspectorBackend.registerEnum(&quot;%(domain)s.%(enumName)s&quot;, {%(enumMap)s});&#39; % enum_args)</span>
<span class="line-removed">121 </span>
<span class="line-removed">122             event_args = {</span>
<span class="line-removed">123                 &#39;domain&#39;: domain.domain_name,</span>
<span class="line-removed">124                 &#39;eventName&#39;: event.event_name,</span>
<span class="line-removed">125                 &#39;params&#39;: &quot;, &quot;.join([&#39;&quot;%s&quot;&#39; % parameter.parameter_name for parameter in event.event_parameters])</span>
<span class="line-removed">126             }</span>
<span class="line-removed">127             lines.append(&#39;InspectorBackend.registerEvent(&quot;%(domain)s.%(eventName)s&quot;, [%(params)s]);&#39; % event_args)</span>
<span class="line-removed">128 </span>
129         for command in commands:
130             def generate_parameter_object(parameter):
<span class="line-removed">131                 optional_string = &quot;true&quot; if parameter.is_optional else &quot;false&quot;</span>
132                 pairs = []
133                 pairs.append(&#39;&quot;name&quot;: &quot;%s&quot;&#39; % parameter.parameter_name)
134                 pairs.append(&#39;&quot;type&quot;: &quot;%s&quot;&#39; % Generator.js_name_for_parameter_type(parameter.type))
<span class="line-modified">135                 pairs.append(&#39;&quot;optional&quot;: %s&#39; % optional_string)</span>

136                 return &quot;{%s}&quot; % &quot;, &quot;.join(pairs)
137 
138             command_args = {
<span class="line-modified">139                 &#39;domain&#39;: domain.domain_name,</span>
140                 &#39;commandName&#39;: command.command_name,

141                 &#39;callParams&#39;: &quot;, &quot;.join([generate_parameter_object(parameter) for parameter in command.call_parameters]),
142                 &#39;returnParams&#39;: &quot;, &quot;.join([&#39;&quot;%s&quot;&#39; % parameter.parameter_name for parameter in command.return_parameters]),
143             }
<span class="line-modified">144             lines.append(&#39;InspectorBackend.registerCommand(&quot;%(domain)s.%(commandName)s&quot;, [%(callParams)s], [%(returnParams)s]);&#39; % command_args)</span>
























145 
146         activate_args = {
<span class="line-modified">147             &#39;domain&#39;: domain.domain_name,</span>
<span class="line-modified">148             &#39;availability&#39;: json.dumps(domain.availability) if domain.availability else &#39;&#39;,</span>
149         }
<span class="line-modified">150         if domain.availability:</span>
<span class="line-removed">151             lines.append(&#39;InspectorBackend.activateDomain(&quot;%(domain)s&quot;, %(availability)s);&#39; % activate_args)</span>
<span class="line-removed">152         else:</span>
<span class="line-removed">153             lines.append(&#39;InspectorBackend.activateDomain(&quot;%(domain)s&quot;);&#39; % activate_args)</span>
154 
155         return &quot;\n&quot;.join(lines)
</pre>
</td>
<td>
<hr />
<pre>
 48 
 49     def output_filename(self):
 50         return &quot;InspectorBackendCommands.js&quot;
 51 
 52     def should_generate_domain(self, domain):
 53         type_declarations = self.type_declarations_for_domain(domain)
 54         domain_enum_types = [declaration for declaration in type_declarations if isinstance(declaration.type, EnumType)]
 55         return self.version_for_domain(domain) is not None or len(self.commands_for_domain(domain)) &gt; 0 or len(self.events_for_domain(domain)) &gt; 0 or len(domain_enum_types) &gt; 0
 56 
 57     def domains_to_generate(self):
 58         return list(filter(self.should_generate_domain, Generator.domains_to_generate(self)))
 59 
 60     def generate_output(self):
 61         sections = []
 62         sections.append(self.generate_license())
 63         sections.extend(list(map(self.generate_domain, self.domains_to_generate())))
 64         return &quot;\n\n&quot;.join(sections)
 65 
 66     def generate_domain(self, domain):
 67         lines = []



 68 
<span class="line-modified"> 69         comment_args = {</span>
<span class="line-added"> 70             &#39;domainName&#39;: domain.domain_name,</span>
<span class="line-added"> 71         }</span>
<span class="line-added"> 72         lines.append(&#39;// %(domainName)s&#39; % comment_args)</span>
 73 
 74         version = self.version_for_domain(domain)
 75         type_declarations = self.type_declarations_for_domain(domain)
 76         commands = self.commands_for_domain(domain)
 77         events = self.events_for_domain(domain)
 78 
<span class="line-modified"> 79         domain_args = {</span>
<span class="line-modified"> 80             &#39;domainName&#39;: domain.domain_name,</span>
<span class="line-modified"> 81             &#39;targetTypes&#39;: json.dumps(domain.target_types),</span>
<span class="line-added"> 82         }</span>
<span class="line-added"> 83         lines.append(&#39;InspectorBackend.registerDomain(&quot;%(domainName)s&quot;, %(targetTypes)s);&#39; % domain_args)</span>
 84 
 85         if isinstance(version, int):
 86             version_args = {
<span class="line-modified"> 87                 &#39;domainName&#39;: domain.domain_name,</span>
 88                 &#39;version&#39;: version
 89             }
<span class="line-modified"> 90             lines.append(&#39;InspectorBackend.registerVersion(&quot;%(domainName)s&quot;, %(version)s);&#39; % version_args)</span>
 91 
 92         for declaration in type_declarations:
 93             if declaration.type.is_enum():
 94                 enum_args = {
<span class="line-modified"> 95                     &#39;domainName&#39;: domain.domain_name,</span>
 96                     &#39;enumName&#39;: declaration.type_name,
 97                     &#39;enumMap&#39;: &quot;, &quot;.join([&#39;%s: &quot;%s&quot;&#39; % (Generator.stylized_name_for_enum_value(enum_value), enum_value) for enum_value in declaration.type.enum_values()])
 98                 }
<span class="line-modified"> 99                 lines.append(&#39;InspectorBackend.registerEnum(&quot;%(domainName)s.%(enumName)s&quot;, {%(enumMap)s});&#39; % enum_args)</span>
100 
101             def is_anonymous_enum_member(type_member):
102                 return isinstance(type_member.type, EnumType) and type_member.type.is_anonymous
103 
104             for _member in filter(is_anonymous_enum_member, declaration.type_members):
105                 enum_args = {
<span class="line-modified">106                     &#39;domainName&#39;: domain.domain_name,</span>
107                     &#39;enumName&#39;: &#39;%s%s&#39; % (declaration.type_name, ucfirst(_member.member_name)),
108                     &#39;enumMap&#39;: &quot;, &quot;.join([&#39;%s: &quot;%s&quot;&#39; % (Generator.stylized_name_for_enum_value(enum_value), enum_value) for enum_value in _member.type.enum_values()])
109                 }
<span class="line-modified">110                 lines.append(&#39;InspectorBackend.registerEnum(&quot;%(domainName)s.%(enumName)s&quot;, {%(enumMap)s});&#39; % enum_args)</span>
111 
112         def is_anonymous_enum_param(param):
113             return isinstance(param.type, EnumType) and param.type.is_anonymous
114 
















115         for command in commands:
116             def generate_parameter_object(parameter):

117                 pairs = []
118                 pairs.append(&#39;&quot;name&quot;: &quot;%s&quot;&#39; % parameter.parameter_name)
119                 pairs.append(&#39;&quot;type&quot;: &quot;%s&quot;&#39; % Generator.js_name_for_parameter_type(parameter.type))
<span class="line-modified">120                 if parameter.is_optional:</span>
<span class="line-added">121                     pairs.append(&#39;&quot;optional&quot;: true&#39;)</span>
122                 return &quot;{%s}&quot; % &quot;, &quot;.join(pairs)
123 
124             command_args = {
<span class="line-modified">125                 &#39;domainName&#39;: domain.domain_name,</span>
126                 &#39;commandName&#39;: command.command_name,
<span class="line-added">127                 &#39;targetTypes&#39;: json.dumps(command.target_types),</span>
128                 &#39;callParams&#39;: &quot;, &quot;.join([generate_parameter_object(parameter) for parameter in command.call_parameters]),
129                 &#39;returnParams&#39;: &quot;, &quot;.join([&#39;&quot;%s&quot;&#39; % parameter.parameter_name for parameter in command.return_parameters]),
130             }
<span class="line-modified">131             lines.append(&#39;InspectorBackend.registerCommand(&quot;%(domainName)s.%(commandName)s&quot;, %(targetTypes)s, [%(callParams)s], [%(returnParams)s]);&#39; % command_args)</span>
<span class="line-added">132 </span>
<span class="line-added">133         for event in events:</span>
<span class="line-added">134             for param in filter(is_anonymous_enum_param, event.event_parameters):</span>
<span class="line-added">135                 enum_args = {</span>
<span class="line-added">136                     &#39;domainName&#39;: domain.domain_name,</span>
<span class="line-added">137                     &#39;enumName&#39;: &#39;%s%s&#39; % (ucfirst(event.event_name), ucfirst(param.parameter_name)),</span>
<span class="line-added">138                     &#39;enumMap&#39;: &quot;, &quot;.join([&#39;%s: &quot;%s&quot;&#39; % (Generator.stylized_name_for_enum_value(enum_value), enum_value) for enum_value in param.type.enum_values()]),</span>
<span class="line-added">139                 }</span>
<span class="line-added">140                 lines.append(&#39;InspectorBackend.registerEnum(&quot;%(domainName)s.%(enumName)s&quot;, {%(enumMap)s});&#39; % enum_args)</span>
<span class="line-added">141 </span>
<span class="line-added">142             event_args = {</span>
<span class="line-added">143                 &#39;domainName&#39;: domain.domain_name,</span>
<span class="line-added">144                 &#39;eventName&#39;: event.event_name,</span>
<span class="line-added">145                 &#39;targetTypes&#39;: json.dumps(event.target_types),</span>
<span class="line-added">146                 &#39;params&#39;: &quot;, &quot;.join([&#39;&quot;%s&quot;&#39; % parameter.parameter_name for parameter in event.event_parameters]),</span>
<span class="line-added">147             }</span>
<span class="line-added">148             lines.append(&#39;InspectorBackend.registerEvent(&quot;%(domainName)s.%(eventName)s&quot;, %(targetTypes)s, [%(params)s]);&#39; % event_args)</span>
<span class="line-added">149 </span>
<span class="line-added">150         has_async_commands = any([command.is_async for command in commands])</span>
<span class="line-added">151         if len(events) &gt; 0 or has_async_commands:</span>
<span class="line-added">152             dispatcher_args = {</span>
<span class="line-added">153                 &#39;domainName&#39;: domain.domain_name,</span>
<span class="line-added">154             }</span>
<span class="line-added">155             lines.append(&#39;InspectorBackend.register%(domainName)sDispatcher = InspectorBackend.registerDispatcher.bind(InspectorBackend, &quot;%(domainName)s&quot;);&#39; % dispatcher_args)</span>
156 
157         activate_args = {
<span class="line-modified">158             &#39;domainName&#39;: domain.domain_name,</span>
<span class="line-modified">159             &#39;debuggableTypes&#39;: json.dumps(domain.debuggable_types),</span>
160         }
<span class="line-modified">161         lines.append(&#39;InspectorBackend.activateDomain(&quot;%(domainName)s&quot;, %(debuggableTypes)s);&#39; % activate_args)</span>



162 
163         return &quot;\n&quot;.join(lines)
</pre>
</td>
</tr>
</table>
<center><a href="generate_cpp_protocol_types_implementation.py.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="generate_objc_backend_dispatcher_implementation.py.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
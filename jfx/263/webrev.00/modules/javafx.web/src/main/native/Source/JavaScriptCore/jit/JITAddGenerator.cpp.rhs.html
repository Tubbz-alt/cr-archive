<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITAddGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015-2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JITAddGenerator.h&quot;
 28 
 29 #include &quot;ArithProfile.h&quot;
 30 #include &quot;JITMathIC.h&quot;
 31 #include &quot;LinkBuffer.h&quot;
 32 
 33 #if ENABLE(JIT)
 34 
 35 namespace JSC {
 36 
<a name="1" id="anc1"></a><span class="line-modified"> 37 JITMathICInlineResult JITAddGenerator::generateInline(CCallHelpers&amp; jit, MathICGenerationState&amp; state, const BinaryArithProfile* arithProfile)</span>
 38 {
 39     // We default to speculating int32.
 40     ObservedType lhs = ObservedType().withInt32();
 41     ObservedType rhs = ObservedType().withInt32();
 42     if (arithProfile) {
 43         lhs = arithProfile-&gt;lhsObservedType();
 44         rhs = arithProfile-&gt;rhsObservedType();
 45     }
 46 
 47     if (lhs.isOnlyNonNumber() &amp;&amp; rhs.isOnlyNonNumber())
 48         return JITMathICInlineResult::DontGenerate;
 49 
 50     if ((lhs.isOnlyInt32() || m_leftOperand.isConstInt32()) &amp;&amp; (rhs.isOnlyInt32() || m_rightOperand.isConstInt32())) {
 51         ASSERT(!m_leftOperand.isConstInt32() || !m_rightOperand.isConstInt32());
 52         if (!m_leftOperand.isConstInt32())
 53             state.slowPathJumps.append(jit.branchIfNotInt32(m_left));
 54         if (!m_rightOperand.isConstInt32())
 55             state.slowPathJumps.append(jit.branchIfNotInt32(m_right));
 56 
 57         GPRReg scratch = m_scratchGPR;
 58         if (m_leftOperand.isConstInt32() || m_rightOperand.isConstInt32()) {
 59             JSValueRegs var = m_leftOperand.isConstInt32() ? m_right : m_left;
 60             int32_t constValue = m_leftOperand.isConstInt32() ? m_leftOperand.asConstInt32() : m_rightOperand.asConstInt32();
 61             if (var.payloadGPR() != m_result.payloadGPR())
 62                 scratch = m_result.payloadGPR();
 63             state.slowPathJumps.append(jit.branchAdd32(CCallHelpers::Overflow, var.payloadGPR(), CCallHelpers::Imm32(constValue), scratch));
 64         } else {
 65             if (m_left.payloadGPR() != m_result.payloadGPR() &amp;&amp; m_right.payloadGPR() != m_result.payloadGPR())
 66                 scratch = m_result.payloadGPR();
 67             state.slowPathJumps.append(jit.branchAdd32(CCallHelpers::Overflow, m_right.payloadGPR(), m_left.payloadGPR(), scratch));
 68         }
 69         jit.boxInt32(scratch, m_result);
 70         return JITMathICInlineResult::GeneratedFastPath;
 71     }
 72 
 73     return JITMathICInlineResult::GenerateFullSnippet;
 74 }
 75 
<a name="2" id="anc2"></a><span class="line-modified"> 76 bool JITAddGenerator::generateFastPath(CCallHelpers&amp; jit, CCallHelpers::JumpList&amp; endJumpList, CCallHelpers::JumpList&amp; slowPathJumpList, const BinaryArithProfile* arithProfile, bool shouldEmitProfiling)</span>
 77 {
 78     ASSERT(m_scratchGPR != InvalidGPRReg);
 79     ASSERT(m_scratchGPR != m_left.payloadGPR());
 80     ASSERT(m_scratchGPR != m_right.payloadGPR());
 81 #if USE(JSVALUE32_64)
 82     ASSERT(m_scratchGPR != m_left.tagGPR());
 83     ASSERT(m_scratchGPR != m_right.tagGPR());
 84     ASSERT(m_scratchFPR != InvalidFPRReg);
 85 #endif
 86 
 87     ASSERT(!m_leftOperand.isConstInt32() || !m_rightOperand.isConstInt32());
 88 
 89     if (!m_leftOperand.mightBeNumber() || !m_rightOperand.mightBeNumber())
 90         return false;
 91 
 92     if (m_leftOperand.isConstInt32() || m_rightOperand.isConstInt32()) {
 93         JSValueRegs var = m_leftOperand.isConstInt32() ? m_right : m_left;
 94         SnippetOperand&amp; varOpr = m_leftOperand.isConstInt32() ? m_rightOperand : m_leftOperand;
 95         SnippetOperand&amp; constOpr = m_leftOperand.isConstInt32() ? m_leftOperand : m_rightOperand;
 96 
 97         // Try to do intVar + intConstant.
 98         CCallHelpers::Jump notInt32 = jit.branchIfNotInt32(var);
 99 
100         GPRReg scratch = m_scratchGPR;
101         if (var.payloadGPR() != m_result.payloadGPR())
102             scratch = m_result.payloadGPR();
103         slowPathJumpList.append(jit.branchAdd32(CCallHelpers::Overflow, var.payloadGPR(), CCallHelpers::Imm32(constOpr.asConstInt32()), scratch));
104 
105         jit.boxInt32(scratch, m_result);
106         endJumpList.append(jit.jump());
107 
108         if (!jit.supportsFloatingPoint()) {
109             slowPathJumpList.append(notInt32);
110             return true;
111         }
112 
113         // Try to do doubleVar + double(intConstant).
114         notInt32.link(&amp;jit);
115         if (!varOpr.definitelyIsNumber())
116             slowPathJumpList.append(jit.branchIfNotNumber(var, m_scratchGPR));
117 
118         jit.unboxDoubleNonDestructive(var, m_leftFPR, m_scratchGPR, m_scratchFPR);
119 
120         jit.move(CCallHelpers::Imm32(constOpr.asConstInt32()), m_scratchGPR);
121         jit.convertInt32ToDouble(m_scratchGPR, m_rightFPR);
122 
123         // Fall thru to doubleVar + doubleVar.
124 
125     } else {
126         ASSERT(!m_leftOperand.isConstInt32() &amp;&amp; !m_rightOperand.isConstInt32());
127         CCallHelpers::Jump leftNotInt;
128         CCallHelpers::Jump rightNotInt;
129 
130         // Try to do intVar + intVar.
131         leftNotInt = jit.branchIfNotInt32(m_left);
132         rightNotInt = jit.branchIfNotInt32(m_right);
133 
134         GPRReg scratch = m_scratchGPR;
135         if (m_left.payloadGPR() != m_result.payloadGPR() &amp;&amp; m_right.payloadGPR() != m_result.payloadGPR())
136             scratch = m_result.payloadGPR();
137         slowPathJumpList.append(jit.branchAdd32(CCallHelpers::Overflow, m_right.payloadGPR(), m_left.payloadGPR(), scratch));
138 
139         jit.boxInt32(scratch, m_result);
140         endJumpList.append(jit.jump());
141 
142 
143         if (!jit.supportsFloatingPoint()) {
144             slowPathJumpList.append(leftNotInt);
145             slowPathJumpList.append(rightNotInt);
146             return true;
147         }
148 
149         leftNotInt.link(&amp;jit);
150         if (!m_leftOperand.definitelyIsNumber())
151             slowPathJumpList.append(jit.branchIfNotNumber(m_left, m_scratchGPR));
152         if (!m_rightOperand.definitelyIsNumber())
153             slowPathJumpList.append(jit.branchIfNotNumber(m_right, m_scratchGPR));
154 
155         jit.unboxDoubleNonDestructive(m_left, m_leftFPR, m_scratchGPR, m_scratchFPR);
156         CCallHelpers::Jump rightIsDouble = jit.branchIfNotInt32(m_right);
157 
158         jit.convertInt32ToDouble(m_right.payloadGPR(), m_rightFPR);
159         CCallHelpers::Jump rightWasInteger = jit.jump();
160 
161         rightNotInt.link(&amp;jit);
162         if (!m_rightOperand.definitelyIsNumber())
163             slowPathJumpList.append(jit.branchIfNotNumber(m_right, m_scratchGPR));
164 
165         jit.convertInt32ToDouble(m_left.payloadGPR(), m_leftFPR);
166 
167         rightIsDouble.link(&amp;jit);
168         jit.unboxDoubleNonDestructive(m_right, m_rightFPR, m_scratchGPR, m_scratchFPR);
169 
170         rightWasInteger.link(&amp;jit);
171 
172         // Fall thru to doubleVar + doubleVar.
173     }
174 
175     // Do doubleVar + doubleVar.
176     jit.addDouble(m_rightFPR, m_leftFPR);
177     if (arithProfile &amp;&amp; shouldEmitProfiling)
178         arithProfile-&gt;emitSetDouble(jit);
179 
180     jit.boxDouble(m_leftFPR, m_result);
181 
182     return true;
183 }
184 
185 } // namespace JSC
186 
187 #endif // ENABLE(JIT)
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/displaylists/DisplayList.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;FloatRect.h&quot;
 29 #include &quot;GraphicsContext.h&quot;
 30 #include &lt;wtf/FastMalloc.h&gt;
 31 #include &lt;wtf/Noncopyable.h&gt;
 32 #include &lt;wtf/text/WTFString.h&gt;
 33 
 34 namespace WTF {
 35 class TextStream;
 36 }
 37 
 38 namespace WebCore {
 39 
 40 namespace DisplayList {
 41 
 42 enum class ItemType : uint8_t {
 43     Save,
 44     Restore,
 45     Translate,
 46     Rotate,
 47     Scale,
 48     ConcatenateCTM,
 49     SetCTM,
 50     SetState,
 51     SetLineCap,
 52     SetLineDash,
 53     SetLineJoin,
 54     SetMiterLimit,
 55     ClearShadow,
 56     Clip,
 57     ClipOut,
 58     ClipOutToPath,
 59     ClipPath,
 60     DrawGlyphs,
 61     DrawImage,
 62     DrawTiledImage,
 63     DrawTiledScaledImage,
 64 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)
 65     DrawNativeImage,
 66 #endif
 67     DrawPattern,
 68     DrawRect,
 69     DrawLine,
 70     DrawLinesForText,
 71     DrawDotsForDocumentMarker,
 72     DrawEllipse,
 73     DrawPath,
 74     DrawFocusRingPath,
 75     DrawFocusRingRects,
 76     FillRect,
 77     FillRectWithColor,
 78     FillRectWithGradient,
 79     FillCompositedRect,
 80     FillRoundedRect,
 81     FillRectWithRoundedHole,
 82     FillPath,
 83     FillEllipse,
 84     StrokeRect,
 85     StrokePath,
 86     StrokeEllipse,
 87     ClearRect,
 88     BeginTransparencyLayer,
 89     EndTransparencyLayer,
 90 #if USE(CG)
 91     ApplyStrokePattern, // FIXME: should not be a recorded item.
 92     ApplyFillPattern, // FIXME: should not be a recorded item.
 93 #endif
 94     ApplyDeviceScaleFactor,
 95 };
 96 
 97 class Item : public RefCounted&lt;Item&gt; {
 98 public:
 99     Item() = delete;
100 
101     WEBCORE_EXPORT Item(ItemType);
102     WEBCORE_EXPORT virtual ~Item();
103 
104     ItemType type() const
105     {
106         return m_type;
107     }
108 
109     virtual void apply(GraphicsContext&amp;) const = 0;
110 
111     static constexpr bool isDisplayListItem = true;
112 
113     virtual bool isDrawingItem() const { return false; }
114 
115     // A state item is one preserved by Save/Restore.
116     bool isStateItem() const
117     {
118         return isStateItemType(m_type);
119     }
120 
121     static bool isStateItemType(ItemType itemType)
122     {
123         switch (itemType) {
124         case ItemType::Translate:
125         case ItemType::Rotate:
126         case ItemType::Scale:
127         case ItemType::ConcatenateCTM:
128         case ItemType::SetCTM:
129         case ItemType::SetState:
130         case ItemType::SetLineCap:
131         case ItemType::SetLineDash:
132         case ItemType::SetLineJoin:
133         case ItemType::SetMiterLimit:
134         case ItemType::ClearShadow:
135             return true;
136         default:
137             return false;
138         }
139         return false;
140     }
141 
142 #if !defined(NDEBUG) || !LOG_DISABLED
143     WTF::CString description() const;
144 #endif
145     static size_t sizeInBytes(const Item&amp;);
146 
147     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
148     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Item&gt;&gt; decode(Decoder&amp;);
149 
150 private:
151     ItemType m_type;
152 };
153 
154 enum AsTextFlag {
155     None                            = 0,
156     IncludesPlatformOperations      = 1 &lt;&lt; 0,
157 };
158 
159 typedef unsigned AsTextFlags;
160 
161 class DisplayList {
162     WTF_MAKE_NONCOPYABLE(DisplayList); WTF_MAKE_FAST_ALLOCATED;
163     friend class Recorder;
164     friend class Replayer;
165 public:
166     DisplayList() = default;
167     DisplayList(DisplayList&amp;&amp;) = default;
168 
169     DisplayList&amp; operator=(DisplayList&amp;&amp;) = default;
170 
171     void dump(WTF::TextStream&amp;) const;
172 
173     const Vector&lt;Ref&lt;Item&gt;&gt;&amp; list() const { return m_list; }
174     Item&amp; itemAt(size_t index)
175     {
176         ASSERT(index &lt; m_list.size());
177         return m_list[index].get();
178     }
179 
180     void clear();
181     void removeItemsFromIndex(size_t);
182 
183     size_t itemCount() const { return m_list.size(); }
184     size_t sizeInBytes() const;
185 
186     String asText(AsTextFlags) const;
187 
188 #if !defined(NDEBUG) || !LOG_DISABLED
189     WTF::CString description() const;
190     WEBCORE_EXPORT void dump() const;
191 #endif
192 
193     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
194     template&lt;class Decoder&gt; static Optional&lt;DisplayList&gt; decode(Decoder&amp;);
195 
196 
197 private:
198     Item&amp; append(Ref&lt;Item&gt;&amp;&amp; item)
199     {
200         m_list.append(WTFMove(item));
201         return m_list.last().get();
202     }
203 
204     // Less efficient append, only used for tracking replay.
205     void appendItem(Item&amp; item)
206     {
207         m_list.append(item);
208     }
209 
210     static bool shouldDumpForFlags(AsTextFlags, const Item&amp;);
211 
212     Vector&lt;Ref&lt;Item&gt;&gt;&amp; list() { return m_list; }
213 
214     Vector&lt;Ref&lt;Item&gt;&gt; m_list;
215 };
216 
217 
218 template&lt;class Encoder&gt;
219 void DisplayList::encode(Encoder&amp; encoder) const
220 {
221     encoder &lt;&lt; static_cast&lt;uint64_t&gt;(m_list.size());
222 
223     for (auto&amp; item : m_list)
224         encoder &lt;&lt; item.get();
225 }
226 
227 template&lt;class Decoder&gt;
228 Optional&lt;DisplayList&gt; DisplayList::decode(Decoder&amp; decoder)
229 {
230     Optional&lt;uint64_t&gt; itemCount;
231     decoder &gt;&gt; itemCount;
232     if (!itemCount)
233         return WTF::nullopt;
234 
235     DisplayList displayList;
236 
237     for (uint64_t i = 0; i &lt; *itemCount; i++) {
238         auto item = Item::decode(decoder);
239         // FIXME: Once we can decode all types, failing to decode an item should turn into a decode failure.
240         // For now, we just have to ignore it.
241         if (!item)
242             continue;
243         displayList.append(WTFMove(*item));
244     }
245 
246     return displayList;
247 }
248 
249 } // DisplayList
250 
251 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const DisplayList::DisplayList&amp;);
252 
253 } // WebCore
254 
255 using WebCore::DisplayList::DisplayList;
256 
    </pre>
  </body>
</html>
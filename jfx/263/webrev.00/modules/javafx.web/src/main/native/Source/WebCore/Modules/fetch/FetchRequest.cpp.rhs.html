<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/fetch/FetchRequest.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016 Canon Inc.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted, provided that the following conditions
  6  * are required to be met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Canon Inc. nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY CANON INC. AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL CANON INC. AND ITS CONTRIBUTORS BE LIABLE FOR
 21  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 22  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 23  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 24  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 25  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;FetchRequest.h&quot;
 31 
 32 #include &quot;Document.h&quot;
 33 #include &quot;HTTPParsers.h&quot;
 34 #include &quot;JSAbortSignal.h&quot;
 35 #include &quot;Logging.h&quot;
 36 #include &quot;Quirks.h&quot;
 37 #include &quot;ScriptExecutionContext.h&quot;
 38 #include &quot;SecurityOrigin.h&quot;
 39 #include &quot;Settings.h&quot;
 40 
 41 namespace WebCore {
 42 
 43 static Optional&lt;Exception&gt; setMethod(ResourceRequest&amp; request, const String&amp; initMethod)
 44 {
 45     if (!isValidHTTPToken(initMethod))
 46         return Exception { TypeError, &quot;Method is not a valid HTTP token.&quot;_s };
 47     if (isForbiddenMethod(initMethod))
 48         return Exception { TypeError, &quot;Method is forbidden.&quot;_s };
 49     request.setHTTPMethod(normalizeHTTPMethod(initMethod));
 50     return WTF::nullopt;
 51 }
 52 
 53 static ExceptionOr&lt;String&gt; computeReferrer(ScriptExecutionContext&amp; context, const String&amp; referrer)
 54 {
 55     if (referrer.isEmpty())
 56         return &quot;no-referrer&quot;_str;
 57 
 58     // FIXME: Tighten the URL parsing algorithm according https://url.spec.whatwg.org/#concept-url-parser.
 59     URL referrerURL = context.completeURL(referrer);
 60     if (!referrerURL.isValid())
 61         return Exception { TypeError, &quot;Referrer is not a valid URL.&quot;_s };
 62 
 63     if (referrerURL.protocolIs(&quot;about&quot;) &amp;&amp; referrerURL.path() == &quot;client&quot;)
 64         return &quot;client&quot;_str;
 65 
 66     if (!(context.securityOrigin() &amp;&amp; context.securityOrigin()-&gt;canRequest(referrerURL)))
 67         return &quot;client&quot;_str;
 68 
 69     return String { referrerURL.string() };
 70 }
 71 
 72 static Optional&lt;Exception&gt; buildOptions(FetchOptions&amp; options, ResourceRequest&amp; request, String&amp; referrer, ScriptExecutionContext&amp; context, const FetchRequest::Init&amp; init)
 73 {
 74     if (!init.window.isUndefinedOrNull() &amp;&amp; !init.window.isEmpty())
 75         return Exception { TypeError, &quot;Window can only be null.&quot;_s };
 76 
 77     if (init.hasMembers()) {
 78         if (options.mode == FetchOptions::Mode::Navigate)
 79             options.mode = FetchOptions::Mode::SameOrigin;
 80         referrer = &quot;client&quot;_s;
 81         options.referrerPolicy = { };
 82     }
 83 
 84     if (!init.referrer.isNull()) {
 85         auto result = computeReferrer(context, init.referrer);
 86         if (result.hasException())
 87             return result.releaseException();
 88         referrer = result.releaseReturnValue();
 89     }
 90 
 91     if (init.referrerPolicy)
 92         options.referrerPolicy = init.referrerPolicy.value();
 93 
 94     if (init.mode) {
 95         options.mode = init.mode.value();
 96         if (options.mode == FetchOptions::Mode::Navigate)
 97             return Exception { TypeError, &quot;Request constructor does not accept navigate fetch mode.&quot;_s };
 98     }
 99 
100     if (init.credentials)
101         options.credentials = init.credentials.value();
102 
103     if (init.cache)
104         options.cache = init.cache.value();
105     if (options.cache == FetchOptions::Cache::OnlyIfCached &amp;&amp; options.mode != FetchOptions::Mode::SameOrigin)
106         return Exception { TypeError, &quot;only-if-cached cache option requires fetch mode to be same-origin.&quot;_s  };
107 
108     if (init.redirect)
109         options.redirect = init.redirect.value();
110 
111     if (!init.integrity.isNull())
112         options.integrity = init.integrity;
113 
114     if (init.keepalive &amp;&amp; init.keepalive.value())
115         options.keepAlive = true;
116 
117     if (!init.method.isNull()) {
118         if (auto exception = setMethod(request, init.method))
119             return exception;
120     }
121 
122     return WTF::nullopt;
123 }
124 
125 static bool methodCanHaveBody(const ResourceRequest&amp; request)
126 {
127     return request.httpMethod() != &quot;GET&quot; &amp;&amp; request.httpMethod() != &quot;HEAD&quot;;
128 }
129 
130 ExceptionOr&lt;void&gt; FetchRequest::initializeOptions(const Init&amp; init)
131 {
132     ASSERT(scriptExecutionContext());
133 
134     auto exception = buildOptions(m_options, m_request, m_referrer, *scriptExecutionContext(), init);
135     if (exception)
136         return WTFMove(exception.value());
137 
138     if (m_options.mode == FetchOptions::Mode::NoCors) {
139         const String&amp; method = m_request.httpMethod();
140         if (method != &quot;GET&quot; &amp;&amp; method != &quot;POST&quot; &amp;&amp; method != &quot;HEAD&quot;)
141             return Exception { TypeError, &quot;Method must be GET, POST or HEAD in no-cors mode.&quot;_s };
142         m_headers-&gt;setGuard(FetchHeaders::Guard::RequestNoCors);
143     }
144 
145     return { };
146 }
147 
148 static inline Optional&lt;Exception&gt; processInvalidSignal(ScriptExecutionContext&amp; context)
149 {
150     ASCIILiteral message { &quot;FetchRequestInit.signal should be undefined, null or an AbortSignal object. This will throw in a future release.&quot;_s };
151     context.addConsoleMessage(MessageSource::JS, MessageLevel::Warning, message);
152 
153     if (is&lt;Document&gt;(context) &amp;&amp; downcast&lt;Document&gt;(context).quirks().shouldIgnoreInvalidSignal())
154         return { };
155 
156     RELEASE_LOG_ERROR(ResourceLoading, &quot;FetchRequestInit.signal should be undefined, null or an AbortSignal object.&quot;);
157     return Exception { TypeError, message };
158 }
159 
160 ExceptionOr&lt;void&gt; FetchRequest::initializeWith(const String&amp; url, Init&amp;&amp; init)
161 {
162     ASSERT(scriptExecutionContext());
163     // FIXME: Tighten the URL parsing algorithm according https://url.spec.whatwg.org/#concept-url-parser.
<a name="1" id="anc1"></a><span class="line-modified">164     URL requestURL = scriptExecutionContext()-&gt;completeURL(url, ScriptExecutionContext::ForceUTF8::Yes);</span>
165     if (!requestURL.isValid() || !requestURL.user().isEmpty() || !requestURL.pass().isEmpty())
166         return Exception { TypeError, &quot;URL is not valid or contains user credentials.&quot;_s };
167 
168     m_options.mode = Mode::Cors;
169     m_options.credentials = Credentials::SameOrigin;
170     m_referrer = &quot;client&quot;_s;
171     m_request.setURL(requestURL);
172     m_request.setRequester(ResourceRequest::Requester::Fetch);
173     m_request.setInitiatorIdentifier(scriptExecutionContext()-&gt;resourceRequestIdentifier());
174 
175     auto optionsResult = initializeOptions(init);
176     if (optionsResult.hasException())
177         return optionsResult.releaseException();
178 
179     if (init.signal) {
180         if (auto* signal = JSAbortSignal::toWrapped(scriptExecutionContext()-&gt;vm(), init.signal))
181             m_signal-&gt;follow(*signal);
182         else if (!init.signal.isUndefinedOrNull())  {
183             if (auto exception = processInvalidSignal(*scriptExecutionContext()))
184                 return WTFMove(*exception);
185         }
186     }
187 
188     if (init.headers) {
189         auto fillResult = m_headers-&gt;fill(*init.headers);
190         if (fillResult.hasException())
191             return fillResult.releaseException();
192     }
193 
194     if (init.body) {
195         auto setBodyResult = setBody(WTFMove(*init.body));
196         if (setBodyResult.hasException())
197             return setBodyResult.releaseException();
198     }
199 
200     updateContentType();
201     return { };
202 }
203 
204 ExceptionOr&lt;void&gt; FetchRequest::initializeWith(FetchRequest&amp; input, Init&amp;&amp; init)
205 {
206     m_request = input.m_request;
207     m_options = input.m_options;
208     m_referrer = input.m_referrer;
209 
210     auto optionsResult = initializeOptions(init);
211     if (optionsResult.hasException())
212         return optionsResult.releaseException();
213 
214     if (init.signal &amp;&amp; !init.signal.isUndefined()) {
215         if (auto* signal = JSAbortSignal::toWrapped(scriptExecutionContext()-&gt;vm(), init.signal))
216             m_signal-&gt;follow(*signal);
217         else if (!init.signal.isNull()) {
218             if (auto exception = processInvalidSignal(*scriptExecutionContext()))
219                 return WTFMove(*exception);
220         }
221 
222     } else
223         m_signal-&gt;follow(input.m_signal.get());
224 
<a name="2" id="anc2"></a><span class="line-modified">225     if (init.hasMembers()) {</span>
<span class="line-modified">226         auto fillResult = init.headers ? m_headers-&gt;fill(*init.headers) : m_headers-&gt;fill(input.headers());</span>
<span class="line-modified">227         if (fillResult.hasException())</span>
<span class="line-added">228             return fillResult;</span>
<span class="line-added">229     } else</span>
<span class="line-added">230         m_headers-&gt;setInternalHeaders(HTTPHeaderMap { input.headers().internalHeaders() });</span>
231 
232     auto setBodyResult = init.body ? setBody(WTFMove(*init.body)) : setBody(input);
233     if (setBodyResult.hasException())
234         return setBodyResult;
235 
236     updateContentType();
237     return { };
238 }
239 
240 ExceptionOr&lt;void&gt; FetchRequest::setBody(FetchBody::Init&amp;&amp; body)
241 {
242     if (!methodCanHaveBody(m_request))
243         return Exception { TypeError, makeString(&quot;Request has method &#39;&quot;, m_request.httpMethod(), &quot;&#39; and cannot have a body&quot;) };
244 
245     ASSERT(scriptExecutionContext());
246     auto result = extractBody(WTFMove(body));
247     if (result.hasException())
248         return result;
249 
250     if (m_options.keepAlive &amp;&amp; hasReadableStreamBody())
251         return Exception { TypeError, &quot;Request cannot have a ReadableStream body and keepalive set to true&quot;_s };
252     return { };
253 }
254 
255 ExceptionOr&lt;void&gt; FetchRequest::setBody(FetchRequest&amp; request)
256 {
257     if (request.isDisturbedOrLocked())
258         return Exception { TypeError, &quot;Request input is disturbed or locked.&quot;_s };
259 
260     if (!request.isBodyNull()) {
261         if (!methodCanHaveBody(m_request))
262             return Exception { TypeError, makeString(&quot;Request has method &#39;&quot;, m_request.httpMethod(), &quot;&#39; and cannot have a body&quot;) };
263         // FIXME: If body has a readable stream, we should pipe it to this new body stream.
264         m_body = WTFMove(*request.m_body);
265         request.setDisturbed();
266     }
267 
268     if (m_options.keepAlive &amp;&amp; hasReadableStreamBody())
269         return Exception { TypeError, &quot;Request cannot have a ReadableStream body and keepalive set to true&quot;_s };
270     return { };
271 }
272 
273 ExceptionOr&lt;Ref&lt;FetchRequest&gt;&gt; FetchRequest::create(ScriptExecutionContext&amp; context, Info&amp;&amp; input, Init&amp;&amp; init)
274 {
275     auto request = adoptRef(*new FetchRequest(context, WTF::nullopt, FetchHeaders::create(FetchHeaders::Guard::Request), { }, { }, { }));
276 
277     if (WTF::holds_alternative&lt;String&gt;(input)) {
278         auto result = request-&gt;initializeWith(WTF::get&lt;String&gt;(input), WTFMove(init));
279         if (result.hasException())
280             return result.releaseException();
281     } else {
282         auto result = request-&gt;initializeWith(*WTF::get&lt;RefPtr&lt;FetchRequest&gt;&gt;(input), WTFMove(init));
283         if (result.hasException())
284             return result.releaseException();
285     }
286 
287     return request;
288 }
289 
290 String FetchRequest::referrer() const
291 {
292     if (m_referrer == &quot;no-referrer&quot;)
293         return String();
294     if (m_referrer == &quot;client&quot;)
295         return &quot;about:client&quot;_s;
296     return m_referrer;
297 }
298 
299 const String&amp; FetchRequest::urlString() const
300 {
301     if (m_requestURL.isNull())
302         m_requestURL = m_request.url();
303     return m_requestURL;
304 }
305 
306 ResourceRequest FetchRequest::resourceRequest() const
307 {
308     ASSERT(scriptExecutionContext());
309 
310     ResourceRequest request = m_request;
311     request.setHTTPHeaderFields(m_headers-&gt;internalHeaders());
312 
313     if (!isBodyNull())
<a name="3" id="anc3"></a><span class="line-modified">314         request.setHTTPBody(body().bodyAsFormData());</span>
315 
316     return request;
317 }
318 
319 ExceptionOr&lt;Ref&lt;FetchRequest&gt;&gt; FetchRequest::clone(ScriptExecutionContext&amp; context)
320 {
321     if (isDisturbedOrLocked())
322         return Exception { TypeError, &quot;Body is disturbed or locked&quot;_s };
323 
324     auto clone = adoptRef(*new FetchRequest(context, WTF::nullopt, FetchHeaders::create(m_headers.get()), ResourceRequest { m_request }, FetchOptions { m_options}, String { m_referrer }));
325     clone-&gt;cloneBody(*this);
326     clone-&gt;m_signal-&gt;follow(m_signal);
327     return clone;
328 }
329 
330 const char* FetchRequest::activeDOMObjectName() const
331 {
332     return &quot;Request&quot;;
333 }
334 
<a name="4" id="anc4"></a>





335 } // namespace WebCore
336 
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
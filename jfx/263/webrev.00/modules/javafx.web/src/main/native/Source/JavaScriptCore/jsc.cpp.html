<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/jsc.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   4  *  Copyright (C) 2006 Bjoern Graf (bjoern.graf@gmail.com)
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 
  25 #include &quot;ArrayBuffer.h&quot;
  26 #include &quot;ArrayPrototype.h&quot;
  27 #include &quot;BuiltinNames.h&quot;
  28 #include &quot;ButterflyInlines.h&quot;
  29 #include &quot;BytecodeCacheError.h&quot;
  30 #include &quot;CallFrameInlines.h&quot;
  31 #include &quot;CatchScope.h&quot;
  32 #include &quot;CodeBlock.h&quot;
  33 #include &quot;CodeCache.h&quot;
  34 #include &quot;CompilerTimingScope.h&quot;
  35 #include &quot;Completion.h&quot;
  36 #include &quot;ConfigFile.h&quot;
  37 #include &quot;Disassembler.h&quot;
  38 #include &quot;Exception.h&quot;
  39 #include &quot;ExceptionHelpers.h&quot;
  40 #include &quot;HeapProfiler.h&quot;
  41 #include &quot;HeapSnapshotBuilder.h&quot;
  42 #include &quot;InitializeThreading.h&quot;
  43 #include &quot;Interpreter.h&quot;
  44 #include &quot;JIT.h&quot;
  45 #include &quot;JSArray.h&quot;
  46 #include &quot;JSArrayBuffer.h&quot;
  47 #include &quot;JSBigInt.h&quot;
  48 #include &quot;JSCInlines.h&quot;
  49 #include &quot;JSFunction.h&quot;
  50 #include &quot;JSInternalPromise.h&quot;
  51 #include &quot;JSLock.h&quot;
  52 #include &quot;JSModuleLoader.h&quot;
  53 #include &quot;JSNativeStdFunction.h&quot;
  54 #include &quot;JSONObject.h&quot;
  55 #include &quot;JSObjectInlines.h&quot;
  56 #include &quot;JSSourceCode.h&quot;
  57 #include &quot;JSString.h&quot;
  58 #include &quot;JSTypedArrays.h&quot;
  59 #include &quot;JSWebAssemblyInstance.h&quot;
  60 #include &quot;JSWebAssemblyMemory.h&quot;
  61 #include &quot;LLIntThunks.h&quot;
  62 #include &quot;ObjectConstructor.h&quot;
  63 #include &quot;ParserError.h&quot;
  64 #include &quot;ProfilerDatabase.h&quot;
  65 #include &quot;PromiseTimer.h&quot;
  66 #include &quot;ProtoCallFrame.h&quot;
  67 #include &quot;ReleaseHeapAccessScope.h&quot;
  68 #include &quot;SamplingProfiler.h&quot;
  69 #include &quot;StackVisitor.h&quot;
  70 #include &quot;StructureInlines.h&quot;
  71 #include &quot;StructureRareDataInlines.h&quot;
  72 #include &quot;SuperSampler.h&quot;
  73 #include &quot;TestRunnerUtils.h&quot;
  74 #include &quot;TypedArrayInlines.h&quot;
  75 #include &quot;VMInspector.h&quot;
  76 #include &quot;WasmCapabilities.h&quot;
  77 #include &quot;WasmContext.h&quot;
  78 #include &quot;WasmFaultSignalHandler.h&quot;
  79 #include &quot;WasmMemory.h&quot;
  80 #include &lt;locale.h&gt;
  81 #include &lt;math.h&gt;
  82 #include &lt;stdio.h&gt;
  83 #include &lt;stdlib.h&gt;
  84 #include &lt;string.h&gt;
  85 #include &lt;sys/stat.h&gt;
  86 #include &lt;sys/types.h&gt;
  87 #include &lt;thread&gt;
  88 #include &lt;type_traits&gt;
  89 #include &lt;wtf/Box.h&gt;
  90 #include &lt;wtf/CPUTime.h&gt;
  91 #include &lt;wtf/CommaPrinter.h&gt;
  92 #include &lt;wtf/FileSystem.h&gt;
  93 #include &lt;wtf/MainThread.h&gt;
  94 #include &lt;wtf/MemoryPressureHandler.h&gt;
  95 #include &lt;wtf/MonotonicTime.h&gt;
  96 #include &lt;wtf/NeverDestroyed.h&gt;
  97 #include &lt;wtf/Scope.h&gt;
  98 #include &lt;wtf/StringPrintStream.h&gt;
  99 #include &lt;wtf/URL.h&gt;
 100 #include &lt;wtf/WallTime.h&gt;
 101 #include &lt;wtf/text/StringBuilder.h&gt;
 102 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 103 
 104 #if OS(WINDOWS)
 105 #include &lt;direct.h&gt;
 106 #include &lt;fcntl.h&gt;
 107 #include &lt;io.h&gt;
 108 #else
 109 #include &lt;unistd.h&gt;
 110 #endif
 111 
 112 #if PLATFORM(COCOA)
 113 #include &lt;crt_externs.h&gt;
 114 #endif
 115 
 116 #if HAVE(READLINE)
 117 // readline/history.h has a Function typedef which conflicts with the WTF::Function template from WTF/Forward.h
 118 // We #define it to something else to avoid this conflict.
 119 #define Function ReadlineFunction
 120 #include &lt;readline/history.h&gt;
 121 #include &lt;readline/readline.h&gt;
 122 #undef Function
 123 #endif
 124 
 125 #if HAVE(SYS_TIME_H)
 126 #include &lt;sys/time.h&gt;
 127 #endif
 128 
 129 #if HAVE(SIGNAL_H)
 130 #include &lt;signal.h&gt;
 131 #endif
 132 
 133 #if COMPILER(MSVC)
 134 #include &lt;crtdbg.h&gt;
 135 #include &lt;mmsystem.h&gt;
 136 #include &lt;windows.h&gt;
 137 #endif
 138 
 139 #if OS(DARWIN) &amp;&amp; CPU(ARM_THUMB2)
 140 #include &lt;fenv.h&gt;
 141 #include &lt;arm/arch.h&gt;
 142 #endif
 143 
 144 #if OS(DARWIN)
 145 #include &lt;wtf/spi/darwin/ProcessMemoryFootprint.h&gt;
 146 #elif OS(LINUX)
 147 #include &lt;wtf/linux/ProcessMemoryFootprint.h&gt;
 148 #endif
 149 
 150 #if OS(DARWIN) || OS(LINUX)
 151 struct MemoryFootprint : ProcessMemoryFootprint {
 152     MemoryFootprint(const ProcessMemoryFootprint&amp; src)
 153         : ProcessMemoryFootprint(src)
 154     {
 155     }
 156 };
 157 #else
 158 struct MemoryFootprint {
 159     uint64_t current;
 160     uint64_t peak;
 161 
 162     static MemoryFootprint now()
 163     {
 164         return { 0L, 0L };
 165     }
 166 
 167     static void resetPeak()
 168     {
 169     }
 170 };
 171 #endif
 172 
 173 #if !defined(PATH_MAX)
 174 #define PATH_MAX 4096
 175 #endif
 176 
 177 using namespace JSC;
 178 
 179 namespace {
 180 
 181 NO_RETURN_WITH_VALUE static void jscExit(int status)
 182 {
 183     waitForAsynchronousDisassembly();
 184 
 185 #if ENABLE(DFG_JIT)
 186     if (DFG::isCrashing()) {
 187         for (;;) {
 188 #if OS(WINDOWS)
 189             Sleep(1000);
 190 #else
 191             pause();
 192 #endif
 193         }
 194     }
 195 #endif // ENABLE(DFG_JIT)
 196     exit(status);
 197 }
 198 
 199 class Masquerader : public JSNonFinalObject {
 200 public:
 201     Masquerader(VM&amp; vm, Structure* structure)
 202         : Base(vm, structure)
 203     {
 204     }
 205 
 206     typedef JSNonFinalObject Base;
 207     static constexpr unsigned StructureFlags = Base::StructureFlags | JSC::MasqueradesAsUndefined;
 208 
 209     static Masquerader* create(VM&amp; vm, JSGlobalObject* globalObject)
 210     {
 211         globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(vm, &quot;Masquerading object allocated&quot;);
 212         Structure* structure = createStructure(vm, globalObject, jsNull());
 213         Masquerader* result = new (NotNull, allocateCell&lt;Masquerader&gt;(vm.heap)) Masquerader(vm, structure);
 214         result-&gt;finishCreation(vm);
 215         return result;
 216     }
 217 
 218     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 219     {
 220         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 221     }
 222 
 223     DECLARE_INFO;
 224 };
 225 
 226 const ClassInfo Masquerader::s_info = { &quot;Masquerader&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Masquerader) };
 227 static unsigned asyncTestPasses { 0 };
 228 static unsigned asyncTestExpectedPasses { 0 };
 229 
 230 }
 231 
 232 template&lt;typename Vector&gt;
 233 static bool fillBufferWithContentsOfFile(const String&amp; fileName, Vector&amp; buffer);
 234 static RefPtr&lt;Uint8Array&gt; fillBufferWithContentsOfFile(const String&amp; fileName);
 235 
 236 class CommandLine;
 237 class GlobalObject;
 238 class Workers;
 239 
 240 template&lt;typename Func&gt;
 241 int runJSC(const CommandLine&amp;, bool isWorker, const Func&amp;);
 242 static void checkException(GlobalObject*, bool isLastFile, bool hasException, JSValue, CommandLine&amp;, bool&amp; success);
 243 
 244 class Message : public ThreadSafeRefCounted&lt;Message&gt; {
 245 public:
 246     Message(ArrayBufferContents&amp;&amp;, int32_t);
 247     ~Message();
 248 
 249     ArrayBufferContents&amp;&amp; releaseContents() { return WTFMove(m_contents); }
 250     int32_t index() const { return m_index; }
 251 
 252 private:
 253     ArrayBufferContents m_contents;
 254     int32_t m_index { 0 };
 255 };
 256 
 257 class Worker : public BasicRawSentinelNode&lt;Worker&gt; {
 258 public:
 259     Worker(Workers&amp;);
 260     ~Worker();
 261 
 262     void enqueue(const AbstractLocker&amp;, RefPtr&lt;Message&gt;);
 263     RefPtr&lt;Message&gt; dequeue();
 264 
 265     static Worker&amp; current();
 266 
 267 private:
 268     static ThreadSpecific&lt;Worker*&gt;&amp; currentWorker();
 269 
 270     Workers&amp; m_workers;
 271     Deque&lt;RefPtr&lt;Message&gt;&gt; m_messages;
 272 };
 273 
 274 class Workers {
 275     WTF_MAKE_FAST_ALLOCATED;
 276     WTF_MAKE_NONCOPYABLE(Workers);
 277 public:
 278     Workers();
 279     ~Workers();
 280 
 281     template&lt;typename Func&gt;
 282     void broadcast(const Func&amp;);
 283 
 284     void report(const String&amp;);
 285     String tryGetReport();
 286     String getReport();
 287 
 288     static Workers&amp; singleton();
 289 
 290 private:
 291     friend class Worker;
 292 
 293     Lock m_lock;
 294     Condition m_condition;
 295     SentinelLinkedList&lt;Worker, BasicRawSentinelNode&lt;Worker&gt;&gt; m_workers;
 296     Deque&lt;String&gt; m_reports;
 297 };
 298 
 299 
 300 static EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(JSGlobalObject*, CallFrame*);
 301 
 302 static EncodedJSValue JSC_HOST_CALL functionPrintStdOut(JSGlobalObject*, CallFrame*);
 303 static EncodedJSValue JSC_HOST_CALL functionPrintStdErr(JSGlobalObject*, CallFrame*);
 304 static EncodedJSValue JSC_HOST_CALL functionDebug(JSGlobalObject*, CallFrame*);
 305 static EncodedJSValue JSC_HOST_CALL functionDescribe(JSGlobalObject*, CallFrame*);
 306 static EncodedJSValue JSC_HOST_CALL functionDescribeArray(JSGlobalObject*, CallFrame*);
 307 static EncodedJSValue JSC_HOST_CALL functionSleepSeconds(JSGlobalObject*, CallFrame*);
 308 static EncodedJSValue JSC_HOST_CALL functionJSCStack(JSGlobalObject*, CallFrame*);
 309 static EncodedJSValue JSC_HOST_CALL functionGCAndSweep(JSGlobalObject*, CallFrame*);
 310 static EncodedJSValue JSC_HOST_CALL functionFullGC(JSGlobalObject*, CallFrame*);
 311 static EncodedJSValue JSC_HOST_CALL functionEdenGC(JSGlobalObject*, CallFrame*);
 312 static EncodedJSValue JSC_HOST_CALL functionHeapSize(JSGlobalObject*, CallFrame*);
 313 static EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(JSGlobalObject*, CallFrame*);
 314 static EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(JSGlobalObject*, CallFrame*);
 315 static EncodedJSValue JSC_HOST_CALL functionAddressOf(JSGlobalObject*, CallFrame*);
 316 static EncodedJSValue JSC_HOST_CALL functionVersion(JSGlobalObject*, CallFrame*);
 317 static EncodedJSValue JSC_HOST_CALL functionRun(JSGlobalObject*, CallFrame*);
 318 static EncodedJSValue JSC_HOST_CALL functionRunString(JSGlobalObject*, CallFrame*);
 319 static EncodedJSValue JSC_HOST_CALL functionLoad(JSGlobalObject*, CallFrame*);
 320 static EncodedJSValue JSC_HOST_CALL functionLoadString(JSGlobalObject*, CallFrame*);
 321 static EncodedJSValue JSC_HOST_CALL functionReadFile(JSGlobalObject*, CallFrame*);
 322 static EncodedJSValue JSC_HOST_CALL functionCheckSyntax(JSGlobalObject*, CallFrame*);
 323 static EncodedJSValue JSC_HOST_CALL functionReadline(JSGlobalObject*, CallFrame*);
 324 static EncodedJSValue JSC_HOST_CALL functionPreciseTime(JSGlobalObject*, CallFrame*);
 325 static EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(JSGlobalObject*, CallFrame*);
 326 static EncodedJSValue JSC_HOST_CALL functionNoDFG(JSGlobalObject*, CallFrame*);
 327 static EncodedJSValue JSC_HOST_CALL functionNoFTL(JSGlobalObject*, CallFrame*);
 328 static EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(JSGlobalObject*, CallFrame*);
 329 static EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(JSGlobalObject*, CallFrame*);
 330 static EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(JSGlobalObject*, CallFrame*);
 331 static EncodedJSValue JSC_HOST_CALL functionCallerIsOMGCompiled(JSGlobalObject*, CallFrame*);
 332 static EncodedJSValue JSC_HOST_CALL functionJSCOptions(JSGlobalObject*, CallFrame*);
 333 static EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(JSGlobalObject*, CallFrame*);
 334 static EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(JSGlobalObject*, CallFrame*);
 335 static EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(JSGlobalObject*, CallFrame*);
 336 static NO_RETURN_WITH_VALUE EncodedJSValue JSC_HOST_CALL functionQuit(JSGlobalObject*, CallFrame*);
 337 static EncodedJSValue JSC_HOST_CALL functionFalse(JSGlobalObject*, CallFrame*);
 338 static EncodedJSValue JSC_HOST_CALL functionUndefined1(JSGlobalObject*, CallFrame*);
 339 static EncodedJSValue JSC_HOST_CALL functionUndefined2(JSGlobalObject*, CallFrame*);
 340 static EncodedJSValue JSC_HOST_CALL functionIsInt32(JSGlobalObject*, CallFrame*);
 341 static EncodedJSValue JSC_HOST_CALL functionIsPureNaN(JSGlobalObject*, CallFrame*);
 342 static EncodedJSValue JSC_HOST_CALL functionEffectful42(JSGlobalObject*, CallFrame*);
 343 static EncodedJSValue JSC_HOST_CALL functionIdentity(JSGlobalObject*, CallFrame*);
 344 static EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(JSGlobalObject*, CallFrame*);
 345 static EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(JSGlobalObject*, CallFrame*);
 346 static EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(JSGlobalObject*, CallFrame*);
 347 static EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(JSGlobalObject*, CallFrame*);
 348 static EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(JSGlobalObject*, CallFrame*);
 349 static EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(JSGlobalObject*, CallFrame*);
 350 static EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(JSGlobalObject*, CallFrame*);
 351 static EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(JSGlobalObject*, CallFrame*);
 352 static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(JSGlobalObject*, CallFrame*);
 353 static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(JSGlobalObject*, CallFrame*);
 354 static EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(JSGlobalObject*, CallFrame*);
 355 static EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(JSGlobalObject*, CallFrame*);
 356 #if ENABLE(SAMPLING_PROFILER)
 357 static EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(JSGlobalObject*, CallFrame*);
 358 static EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(JSGlobalObject*, CallFrame*);
 359 #endif
 360 
 361 static EncodedJSValue JSC_HOST_CALL functionMaxArguments(JSGlobalObject*, CallFrame*);
 362 static EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(JSGlobalObject*, CallFrame*);
 363 static EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(JSGlobalObject*, CallFrame*);
 364 
 365 #if ENABLE(WEBASSEMBLY)
 366 static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(JSGlobalObject*, CallFrame*);
 367 #endif
 368 
 369 #if ENABLE(SAMPLING_FLAGS)
 370 static EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(JSGlobalObject*, CallFrame*);
 371 static EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(JSGlobalObject*, CallFrame*);
 372 #endif
 373 
 374 static EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(JSGlobalObject*, CallFrame*);
 375 static EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(JSGlobalObject*, CallFrame*);
 376 static EncodedJSValue JSC_HOST_CALL functionIsRope(JSGlobalObject*, CallFrame*);
 377 static EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(JSGlobalObject*, CallFrame*);
 378 static EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(JSGlobalObject*, CallFrame*);
 379 static EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(JSGlobalObject*, CallFrame*);
 380 static EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(JSGlobalObject*, CallFrame*);
 381 static EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(JSGlobalObject*, CallFrame*);
 382 static EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(JSGlobalObject*, CallFrame*);
 383 static EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(JSGlobalObject*, CallFrame*);
 384 static EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(JSGlobalObject*, CallFrame*);
 385 static EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(JSGlobalObject*, CallFrame*);
 386 static EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(JSGlobalObject*, CallFrame*);
 387 static EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(JSGlobalObject*, CallFrame*);
 388 static EncodedJSValue JSC_HOST_CALL functionWaitForReport(JSGlobalObject*, CallFrame*);
 389 static EncodedJSValue JSC_HOST_CALL functionHeapCapacity(JSGlobalObject*, CallFrame*);
 390 static EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(JSGlobalObject*, CallFrame*);
 391 static EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(JSGlobalObject*, CallFrame*);
 392 static EncodedJSValue JSC_HOST_CALL functionMallocInALoop(JSGlobalObject*, CallFrame*);
 393 static EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(JSGlobalObject*, CallFrame*);
 394 
 395 static EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(JSGlobalObject*, CallFrame*);
 396 
 397 struct Script {
 398     enum class StrictMode {
 399         Strict,
 400         Sloppy
 401     };
 402 
 403     enum class ScriptType {
 404         Script,
 405         Module
 406     };
 407 
 408     enum class CodeSource {
 409         File,
 410         CommandLine
 411     };
 412 
 413     StrictMode strictMode;
 414     CodeSource codeSource;
 415     ScriptType scriptType;
 416     char* argument;
 417 
 418     Script(StrictMode strictMode, CodeSource codeSource, ScriptType scriptType, char *argument)
 419         : strictMode(strictMode)
 420         , codeSource(codeSource)
 421         , scriptType(scriptType)
 422         , argument(argument)
 423     {
 424         if (strictMode == StrictMode::Strict)
 425             ASSERT(codeSource == CodeSource::File);
 426     }
 427 };
 428 
 429 class CommandLine {
 430 public:
 431     CommandLine(int argc, char** argv)
 432     {
 433         parseArguments(argc, argv);
 434     }
 435 
 436     Vector&lt;Script&gt; m_scripts;
 437     Vector&lt;String&gt; m_arguments;
 438     String m_profilerOutput;
 439     String m_uncaughtExceptionName;
 440     bool m_interactive { false };
 441     bool m_dump { false };
 442     bool m_module { false };
 443     bool m_exitCode { false };
 444     bool m_destroyVM { false };
 445     bool m_profile { false };
 446     bool m_treatWatchdogExceptionAsSuccess { false };
 447     bool m_alwaysDumpUncaughtException { false };
 448     bool m_dumpMemoryFootprint { false };
 449     bool m_dumpSamplingProfilerData { false };
 450     bool m_enableRemoteDebugging { false };
 451 
 452     void parseArguments(int, char**);
 453 };
 454 
 455 static const char interactivePrompt[] = &quot;&gt;&gt;&gt; &quot;;
 456 
 457 class StopWatch {
 458 public:
 459     void start();
 460     void stop();
 461     long getElapsedMS(); // call stop() first
 462 
 463 private:
 464     MonotonicTime m_startTime;
 465     MonotonicTime m_stopTime;
 466 };
 467 
 468 void StopWatch::start()
 469 {
 470     m_startTime = MonotonicTime::now();
 471 }
 472 
 473 void StopWatch::stop()
 474 {
 475     m_stopTime = MonotonicTime::now();
 476 }
 477 
 478 long StopWatch::getElapsedMS()
 479 {
 480     return (m_stopTime - m_startTime).millisecondsAs&lt;long&gt;();
 481 }
 482 
 483 template&lt;typename Vector&gt;
 484 static inline String stringFromUTF(const Vector&amp; utf8)
 485 {
 486     return String::fromUTF8WithLatin1Fallback(utf8.data(), utf8.size());
 487 }
 488 
 489 class GlobalObject final : public JSGlobalObject {
 490 private:
 491     GlobalObject(VM&amp;, Structure*);
 492 
 493 public:
 494     typedef JSGlobalObject Base;
 495 
 496     static GlobalObject* create(VM&amp; vm, Structure* structure, const Vector&lt;String&gt;&amp; arguments)
 497     {
 498         GlobalObject* object = new (NotNull, allocateCell&lt;GlobalObject&gt;(vm.heap)) GlobalObject(vm, structure);
 499         object-&gt;finishCreation(vm, arguments);
 500         return object;
 501     }
 502 
 503     DECLARE_INFO;
 504     static const GlobalObjectMethodTable s_globalObjectMethodTable;
 505 
 506     static Structure* createStructure(VM&amp; vm, JSValue prototype)
 507     {
 508         return Structure::create(vm, 0, prototype, TypeInfo(GlobalObjectType, StructureFlags), info());
 509     }
 510 
 511     static RuntimeFlags javaScriptRuntimeFlags(const JSGlobalObject*) { return RuntimeFlags::createAllEnabled(); }
 512 
 513 protected:
 514     void finishCreation(VM&amp; vm, const Vector&lt;String&gt;&amp; arguments)
 515     {
 516         Base::finishCreation(vm);
 517 
 518         addFunction(vm, &quot;debug&quot;, functionDebug, 1);
 519         addFunction(vm, &quot;describe&quot;, functionDescribe, 1);
 520         addFunction(vm, &quot;describeArray&quot;, functionDescribeArray, 1);
 521         addFunction(vm, &quot;print&quot;, functionPrintStdOut, 1);
 522         addFunction(vm, &quot;printErr&quot;, functionPrintStdErr, 1);
 523         addFunction(vm, &quot;quit&quot;, functionQuit, 0);
 524         addFunction(vm, &quot;gc&quot;, functionGCAndSweep, 0);
 525         addFunction(vm, &quot;fullGC&quot;, functionFullGC, 0);
 526         addFunction(vm, &quot;edenGC&quot;, functionEdenGC, 0);
 527         addFunction(vm, &quot;gcHeapSize&quot;, functionHeapSize, 0);
 528         addFunction(vm, &quot;MemoryFootprint&quot;, functionCreateMemoryFootprint, 0);
 529         addFunction(vm, &quot;resetMemoryPeak&quot;, functionResetMemoryPeak, 0);
 530         addFunction(vm, &quot;addressOf&quot;, functionAddressOf, 1);
 531         addFunction(vm, &quot;version&quot;, functionVersion, 1);
 532         addFunction(vm, &quot;run&quot;, functionRun, 1);
 533         addFunction(vm, &quot;runString&quot;, functionRunString, 1);
 534         addFunction(vm, &quot;load&quot;, functionLoad, 1);
 535         addFunction(vm, &quot;loadString&quot;, functionLoadString, 1);
 536         addFunction(vm, &quot;readFile&quot;, functionReadFile, 2);
 537         addFunction(vm, &quot;read&quot;, functionReadFile, 2);
 538         addFunction(vm, &quot;checkSyntax&quot;, functionCheckSyntax, 1);
 539         addFunction(vm, &quot;sleepSeconds&quot;, functionSleepSeconds, 1);
 540         addFunction(vm, &quot;jscStack&quot;, functionJSCStack, 1);
 541         addFunction(vm, &quot;readline&quot;, functionReadline, 0);
 542         addFunction(vm, &quot;preciseTime&quot;, functionPreciseTime, 0);
 543         addFunction(vm, &quot;neverInlineFunction&quot;, functionNeverInlineFunction, 1);
 544         addFunction(vm, &quot;noInline&quot;, functionNeverInlineFunction, 1);
 545         addFunction(vm, &quot;noDFG&quot;, functionNoDFG, 1);
 546         addFunction(vm, &quot;noFTL&quot;, functionNoFTL, 1);
 547         addFunction(vm, &quot;noOSRExitFuzzing&quot;, functionNoOSRExitFuzzing, 1);
 548         addFunction(vm, &quot;numberOfDFGCompiles&quot;, functionNumberOfDFGCompiles, 1);
 549         addFunction(vm, &quot;callerIsOMGCompiled&quot;, functionCallerIsOMGCompiled, 0);
 550         addFunction(vm, &quot;jscOptions&quot;, functionJSCOptions, 0);
 551         addFunction(vm, &quot;optimizeNextInvocation&quot;, functionOptimizeNextInvocation, 1);
 552         addFunction(vm, &quot;reoptimizationRetryCount&quot;, functionReoptimizationRetryCount, 1);
 553         addFunction(vm, &quot;transferArrayBuffer&quot;, functionTransferArrayBuffer, 1);
 554         addFunction(vm, &quot;failNextNewCodeBlock&quot;, functionFailNextNewCodeBlock, 1);
 555 #if ENABLE(SAMPLING_FLAGS)
 556         addFunction(vm, &quot;setSamplingFlags&quot;, functionSetSamplingFlags, 1);
 557         addFunction(vm, &quot;clearSamplingFlags&quot;, functionClearSamplingFlags, 1);
 558 #endif
 559 
 560         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;OSRExit&quot;), 0, functionUndefined1, OSRExitIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 561         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isFinalTier&quot;), 0, functionFalse, IsFinalTierIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 562         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;predictInt32&quot;), 0, functionUndefined2, SetInt32HeapPredictionIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 563         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isInt32&quot;), 0, functionIsInt32, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 564         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isPureNaN&quot;), 0, functionIsPureNaN, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 565         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;fiatInt52&quot;), 0, functionIdentity, FiatInt52Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 566 
 567         addFunction(vm, &quot;effectful42&quot;, functionEffectful42, 0);
 568         addFunction(vm, &quot;makeMasquerader&quot;, functionMakeMasquerader, 0);
 569         addFunction(vm, &quot;hasCustomProperties&quot;, functionHasCustomProperties, 0);
 570 
 571         addFunction(vm, &quot;createGlobalObject&quot;, functionCreateGlobalObject, 0);
 572 
 573         addFunction(vm, &quot;dumpTypesForAllVariables&quot;, functionDumpTypesForAllVariables , 0);
 574 
 575         addFunction(vm, &quot;drainMicrotasks&quot;, functionDrainMicrotasks, 0);
 576         addFunction(vm, &quot;releaseWeakRefs&quot;, functionReleaseWeakRefs, 0);
 577 
 578         addFunction(vm, &quot;getRandomSeed&quot;, functionGetRandomSeed, 0);
 579         addFunction(vm, &quot;setRandomSeed&quot;, functionSetRandomSeed, 1);
 580         addFunction(vm, &quot;isRope&quot;, functionIsRope, 1);
 581         addFunction(vm, &quot;callerSourceOrigin&quot;, functionCallerSourceOrigin, 0);
 582 
 583         addFunction(vm, &quot;is32BitPlatform&quot;, functionIs32BitPlatform, 0);
 584 
 585         addFunction(vm, &quot;checkModuleSyntax&quot;, functionCheckModuleSyntax, 1);
 586 
 587         addFunction(vm, &quot;platformSupportsSamplingProfiler&quot;, functionPlatformSupportsSamplingProfiler, 0);
 588         addFunction(vm, &quot;generateHeapSnapshot&quot;, functionGenerateHeapSnapshot, 0);
 589         addFunction(vm, &quot;generateHeapSnapshotForGCDebugging&quot;, functionGenerateHeapSnapshotForGCDebugging, 0);
 590         addFunction(vm, &quot;resetSuperSamplerState&quot;, functionResetSuperSamplerState, 0);
 591         addFunction(vm, &quot;ensureArrayStorage&quot;, functionEnsureArrayStorage, 0);
 592 #if ENABLE(SAMPLING_PROFILER)
 593         addFunction(vm, &quot;startSamplingProfiler&quot;, functionStartSamplingProfiler, 0);
 594         addFunction(vm, &quot;samplingProfilerStackTraces&quot;, functionSamplingProfilerStackTraces, 0);
 595 #endif
 596 
 597         addFunction(vm, &quot;maxArguments&quot;, functionMaxArguments, 0);
 598 
 599         addFunction(vm, &quot;asyncTestStart&quot;, functionAsyncTestStart, 1);
 600         addFunction(vm, &quot;asyncTestPassed&quot;, functionAsyncTestPassed, 1);
 601 
 602 #if ENABLE(WEBASSEMBLY)
 603         addFunction(vm, &quot;WebAssemblyMemoryMode&quot;, functionWebAssemblyMemoryMode, 1);
 604 #endif
 605 
 606         if (!arguments.isEmpty()) {
 607             JSArray* array = constructEmptyArray(this, 0);
 608             for (size_t i = 0; i &lt; arguments.size(); ++i)
 609                 array-&gt;putDirectIndex(this, i, jsString(vm, arguments[i]));
 610             putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);
 611         }
 612 
 613         putDirect(vm, Identifier::fromString(vm, &quot;console&quot;), jsUndefined());
 614 
 615         Structure* plainObjectStructure = JSFinalObject::createStructure(vm, this, objectPrototype(), 0);
 616 
 617         JSObject* dollar = JSFinalObject::create(vm, plainObjectStructure);
 618         putDirect(vm, Identifier::fromString(vm, &quot;$&quot;), dollar);
 619         putDirect(vm, Identifier::fromString(vm, &quot;$262&quot;), dollar);
 620 
 621         addFunction(vm, dollar, &quot;createRealm&quot;, functionDollarCreateRealm, 0);
 622         addFunction(vm, dollar, &quot;detachArrayBuffer&quot;, functionTransferArrayBuffer, 1);
 623         addFunction(vm, dollar, &quot;evalScript&quot;, functionDollarEvalScript, 1);
 624 
 625         dollar-&gt;putDirect(vm, Identifier::fromString(vm, &quot;global&quot;), this);
 626 
 627         JSObject* agent = JSFinalObject::create(vm, plainObjectStructure);
 628         dollar-&gt;putDirect(vm, Identifier::fromString(vm, &quot;agent&quot;), agent);
 629 
 630         // The test262 INTERPRETING.md document says that some of these functions are just in the main
 631         // thread and some are in the other threads. We just put them in all threads.
 632         addFunction(vm, agent, &quot;start&quot;, functionDollarAgentStart, 1);
 633         addFunction(vm, agent, &quot;receiveBroadcast&quot;, functionDollarAgentReceiveBroadcast, 1);
 634         addFunction(vm, agent, &quot;report&quot;, functionDollarAgentReport, 1);
 635         addFunction(vm, agent, &quot;sleep&quot;, functionDollarAgentSleep, 1);
 636         addFunction(vm, agent, &quot;broadcast&quot;, functionDollarAgentBroadcast, 1);
 637         addFunction(vm, agent, &quot;getReport&quot;, functionDollarAgentGetReport, 0);
 638         addFunction(vm, agent, &quot;leaving&quot;, functionDollarAgentLeaving, 0);
 639         addFunction(vm, agent, &quot;monotonicNow&quot;, functionDollarAgentMonotonicNow, 0);
 640 
 641         addFunction(vm, &quot;waitForReport&quot;, functionWaitForReport, 0);
 642 
 643         addFunction(vm, &quot;heapCapacity&quot;, functionHeapCapacity, 0);
 644         addFunction(vm, &quot;flashHeapAccess&quot;, functionFlashHeapAccess, 0);
 645 
 646         addFunction(vm, &quot;disableRichSourceInfo&quot;, functionDisableRichSourceInfo, 0);
 647         addFunction(vm, &quot;mallocInALoop&quot;, functionMallocInALoop, 0);
 648         addFunction(vm, &quot;totalCompileTime&quot;, functionTotalCompileTime, 0);
 649 
 650         addFunction(vm, &quot;setUnhandledRejectionCallback&quot;, functionSetUnhandledRejectionCallback, 1);
 651     }
 652 
 653     void addFunction(VM&amp; vm, JSObject* object, const char* name, NativeFunction function, unsigned arguments)
 654     {
 655         Identifier identifier = Identifier::fromString(vm, name);
 656         object-&gt;putDirect(vm, identifier, JSFunction::create(vm, this, arguments, identifier.string(), function));
 657     }
 658 
 659     void addFunction(VM&amp; vm, const char* name, NativeFunction function, unsigned arguments)
 660     {
 661         addFunction(vm, this, name, function, arguments);
 662     }
 663 
 664     static JSInternalPromise* moduleLoaderImportModule(JSGlobalObject*, JSModuleLoader*, JSString*, JSValue, const SourceOrigin&amp;);
 665     static Identifier moduleLoaderResolve(JSGlobalObject*, JSModuleLoader*, JSValue, JSValue, JSValue);
 666     static JSInternalPromise* moduleLoaderFetch(JSGlobalObject*, JSModuleLoader*, JSValue, JSValue, JSValue);
 667     static JSObject* moduleLoaderCreateImportMetaProperties(JSGlobalObject*, JSModuleLoader*, JSValue, JSModuleRecord*, JSValue);
 668 };
 669 STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(GlobalObject, JSGlobalObject);
 670 
 671 static bool supportsRichSourceInfo = true;
 672 static bool shellSupportsRichSourceInfo(const JSGlobalObject*)
 673 {
 674     return supportsRichSourceInfo;
 675 }
 676 
 677 const ClassInfo GlobalObject::s_info = { &quot;global&quot;, &amp;JSGlobalObject::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(GlobalObject) };
 678 const GlobalObjectMethodTable GlobalObject::s_globalObjectMethodTable = {
 679     &amp;shellSupportsRichSourceInfo,
 680     &amp;shouldInterruptScript,
 681     &amp;javaScriptRuntimeFlags,
 682     nullptr, // queueTaskToEventLoop
 683     &amp;shouldInterruptScriptBeforeTimeout,
 684     &amp;moduleLoaderImportModule,
 685     &amp;moduleLoaderResolve,
 686     &amp;moduleLoaderFetch,
 687     &amp;moduleLoaderCreateImportMetaProperties,
 688     nullptr, // moduleLoaderEvaluate
 689     nullptr, // promiseRejectionTracker
 690     nullptr, // defaultLanguage
 691     nullptr, // compileStreaming
 692     nullptr, // instantinateStreaming
 693 };
 694 
 695 GlobalObject::GlobalObject(VM&amp; vm, Structure* structure)
 696     : JSGlobalObject(vm, structure, &amp;s_globalObjectMethodTable)
 697 {
 698 }
 699 
 700 static UChar pathSeparator()
 701 {
 702 #if OS(WINDOWS)
 703     return &#39;\\&#39;;
 704 #else
 705     return &#39;/&#39;;
 706 #endif
 707 }
 708 
 709 struct DirectoryName {
 710     // In unix, it is &quot;/&quot;. In Windows, it becomes a drive letter like &quot;C:\&quot;
 711     String rootName;
 712 
 713     // If the directory name is &quot;/home/WebKit&quot;, this becomes &quot;home/WebKit&quot;. If the directory name is &quot;/&quot;, this becomes &quot;&quot;.
 714     String queryName;
 715 };
 716 
 717 struct ModuleName {
 718     ModuleName(const String&amp; moduleName);
 719 
 720     bool startsWithRoot() const
 721     {
 722         return !queries.isEmpty() &amp;&amp; queries[0].isEmpty();
 723     }
 724 
 725     Vector&lt;String&gt; queries;
 726 };
 727 
 728 ModuleName::ModuleName(const String&amp; moduleName)
 729 {
 730     // A module name given from code is represented as the UNIX style path. Like, `./A/B.js`.
 731     queries = moduleName.splitAllowingEmptyEntries(&#39;/&#39;);
 732 }
 733 
 734 static Optional&lt;DirectoryName&gt; extractDirectoryName(const String&amp; absolutePathToFile)
 735 {
 736     size_t firstSeparatorPosition = absolutePathToFile.find(pathSeparator());
 737     if (firstSeparatorPosition == notFound)
 738         return WTF::nullopt;
 739     DirectoryName directoryName;
 740     directoryName.rootName = absolutePathToFile.substring(0, firstSeparatorPosition + 1); // Include the separator.
 741     size_t lastSeparatorPosition = absolutePathToFile.reverseFind(pathSeparator());
 742     ASSERT_WITH_MESSAGE(lastSeparatorPosition != notFound, &quot;If the separator is not found, this function already returns when performing the forward search.&quot;);
 743     if (firstSeparatorPosition == lastSeparatorPosition)
 744         directoryName.queryName = StringImpl::empty();
 745     else {
 746         size_t queryStartPosition = firstSeparatorPosition + 1;
 747         size_t queryLength = lastSeparatorPosition - queryStartPosition; // Not include the last separator.
 748         directoryName.queryName = absolutePathToFile.substring(queryStartPosition, queryLength);
 749     }
 750     return directoryName;
 751 }
 752 
 753 static Optional&lt;DirectoryName&gt; currentWorkingDirectory()
 754 {
 755 #if OS(WINDOWS)
 756     // https://msdn.microsoft.com/en-us/library/windows/desktop/aa364934.aspx
 757     // https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx#maxpath
 758     // The _MAX_PATH in Windows is 260. If the path of the current working directory is longer than that, _getcwd truncates the result.
 759     // And other I/O functions taking a path name also truncate it. To avoid this situation,
 760     //
 761     // (1). When opening the file in Windows for modules, we always use the abosolute path and add &quot;\\?\&quot; prefix to the path name.
 762     // (2). When retrieving the current working directory, use GetCurrentDirectory instead of _getcwd.
 763     //
 764     // In the path utility functions inside the JSC shell, we does not handle the UNC and UNCW including the network host name.
 765     DWORD bufferLength = ::GetCurrentDirectoryW(0, nullptr);
 766     if (!bufferLength)
 767         return WTF::nullopt;
 768     // In Windows, wchar_t is the UTF-16LE.
 769     // https://msdn.microsoft.com/en-us/library/dd374081.aspx
 770     // https://msdn.microsoft.com/en-us/library/windows/desktop/ff381407.aspx
 771     Vector&lt;wchar_t&gt; buffer(bufferLength);
 772     DWORD lengthNotIncludingNull = ::GetCurrentDirectoryW(bufferLength, buffer.data());
 773     String directoryString(buffer.data(), lengthNotIncludingNull);
 774     // We don&#39;t support network path like \\host\share\&lt;path name&gt;.
 775     if (directoryString.startsWith(&quot;\\\\&quot;))
 776         return WTF::nullopt;
 777 #else
 778     Vector&lt;char&gt; buffer(PATH_MAX);
 779     if (!getcwd(buffer.data(), PATH_MAX))
 780         return WTF::nullopt;
 781     String directoryString = String::fromUTF8(buffer.data());
 782 #endif
 783     if (directoryString.isEmpty())
 784         return WTF::nullopt;
 785 
 786     if (directoryString[directoryString.length() - 1] == pathSeparator())
 787         return extractDirectoryName(directoryString);
 788     // Append the seperator to represents the file name. extractDirectoryName only accepts the absolute file name.
 789     return extractDirectoryName(makeString(directoryString, pathSeparator()));
 790 }
 791 
 792 static String resolvePath(const DirectoryName&amp; directoryName, const ModuleName&amp; moduleName)
 793 {
 794     Vector&lt;String&gt; directoryPieces = directoryName.queryName.split(pathSeparator());
 795 
 796     // Only first &#39;/&#39; is recognized as the path from the root.
 797     if (moduleName.startsWithRoot())
 798         directoryPieces.clear();
 799 
 800     for (const auto&amp; query : moduleName.queries) {
 801         if (query == String(&quot;..&quot;_s)) {
 802             if (!directoryPieces.isEmpty())
 803                 directoryPieces.removeLast();
 804         } else if (!query.isEmpty() &amp;&amp; query != String(&quot;.&quot;_s))
 805             directoryPieces.append(query);
 806     }
 807 
 808     StringBuilder builder;
 809     builder.append(directoryName.rootName);
 810     for (size_t i = 0; i &lt; directoryPieces.size(); ++i) {
 811         builder.append(directoryPieces[i]);
 812         if (i + 1 != directoryPieces.size())
 813             builder.append(pathSeparator());
 814     }
 815     return builder.toString();
 816 }
 817 
 818 static String absolutePath(const String&amp; fileName)
 819 {
 820     auto directoryName = currentWorkingDirectory();
 821     if (!directoryName)
 822         return fileName;
 823     return resolvePath(directoryName.value(), ModuleName(fileName.impl()));
 824 }
 825 
 826 JSInternalPromise* GlobalObject::moduleLoaderImportModule(JSGlobalObject* globalObject, JSModuleLoader*, JSString* moduleNameValue, JSValue parameters, const SourceOrigin&amp; sourceOrigin)
 827 {
 828     VM&amp; vm = globalObject-&gt;vm();
 829     auto throwScope = DECLARE_THROW_SCOPE(vm);
 830 
 831     auto* promise = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());
 832 
 833     auto catchScope = DECLARE_CATCH_SCOPE(vm);
 834     auto reject = [&amp;] (JSValue rejectionReason) {
 835         catchScope.clearException();
 836         promise-&gt;reject(globalObject, rejectionReason);
 837         catchScope.clearException();
 838         return promise;
 839     };
 840 
 841     if (sourceOrigin.isNull())
 842         return reject(createError(globalObject, &quot;Could not resolve the module specifier.&quot;_s));
 843 
 844     auto referrer = sourceOrigin.string();
 845     auto moduleName = moduleNameValue-&gt;value(globalObject);
 846     RETURN_IF_EXCEPTION(throwScope, nullptr);
 847     if (UNLIKELY(catchScope.exception()))
 848         return reject(catchScope.exception());
 849 
 850     auto directoryName = extractDirectoryName(referrer.impl());
 851     if (!directoryName)
 852         return reject(createError(globalObject, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));
 853 
 854     auto result = JSC::importModule(globalObject, Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(moduleName))), parameters, jsUndefined());
 855     if (UNLIKELY(catchScope.exception()))
 856         return reject(catchScope.exception());
 857     return result;
 858 }
 859 
 860 Identifier GlobalObject::moduleLoaderResolve(JSGlobalObject* globalObject, JSModuleLoader*, JSValue keyValue, JSValue referrerValue, JSValue)
 861 {
 862     VM&amp; vm = globalObject-&gt;vm();
 863     auto scope = DECLARE_THROW_SCOPE(vm);
 864 
 865     scope.releaseAssertNoException();
 866     const Identifier key = keyValue.toPropertyKey(globalObject);
 867     RETURN_IF_EXCEPTION(scope, { });
 868 
 869     if (key.isSymbol())
 870         return key;
 871 
 872     if (referrerValue.isUndefined()) {
 873         auto directoryName = currentWorkingDirectory();
 874         if (!directoryName) {
 875             throwException(globalObject, scope, createError(globalObject, &quot;Could not resolve the current working directory.&quot;_s));
 876             return { };
 877         }
 878         return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
 879     }
 880 
 881     const Identifier referrer = referrerValue.toPropertyKey(globalObject);
 882     RETURN_IF_EXCEPTION(scope, { });
 883 
 884     if (referrer.isSymbol()) {
 885         auto directoryName = currentWorkingDirectory();
 886         if (!directoryName) {
 887             throwException(globalObject, scope, createError(globalObject, &quot;Could not resolve the current working directory.&quot;_s));
 888             return { };
 889         }
 890         return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
 891     }
 892 
 893     // If the referrer exists, we assume that the referrer is the correct absolute path.
 894     auto directoryName = extractDirectoryName(referrer.impl());
 895     if (!directoryName) {
 896         throwException(globalObject, scope, createError(globalObject, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));
 897         return { };
 898     }
 899     return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
 900 }
 901 
 902 template&lt;typename Vector&gt;
 903 static void convertShebangToJSComment(Vector&amp; buffer)
 904 {
 905     if (buffer.size() &gt;= 2) {
 906         if (buffer[0] == &#39;#&#39; &amp;&amp; buffer[1] == &#39;!&#39;)
 907             buffer[0] = buffer[1] = &#39;/&#39;;
 908     }
 909 }
 910 
 911 static RefPtr&lt;Uint8Array&gt; fillBufferWithContentsOfFile(FILE* file)
 912 {
 913     if (fseek(file, 0, SEEK_END) == -1)
 914         return nullptr;
 915     long bufferCapacity = ftell(file);
 916     if (bufferCapacity == -1)
 917         return nullptr;
 918     if (fseek(file, 0, SEEK_SET) == -1)
 919         return nullptr;
 920     auto result = Uint8Array::tryCreate(bufferCapacity);
 921     if (!result)
 922         return nullptr;
 923     size_t readSize = fread(result-&gt;data(), 1, bufferCapacity, file);
 924     if (readSize != static_cast&lt;size_t&gt;(bufferCapacity))
 925         return nullptr;
 926     return result;
 927 }
 928 
 929 static RefPtr&lt;Uint8Array&gt; fillBufferWithContentsOfFile(const String&amp; fileName)
 930 {
 931     FILE* f = fopen(fileName.utf8().data(), &quot;rb&quot;);
 932     if (!f) {
 933         fprintf(stderr, &quot;Could not open file: %s\n&quot;, fileName.utf8().data());
 934         return nullptr;
 935     }
 936 
 937     RefPtr&lt;Uint8Array&gt; result = fillBufferWithContentsOfFile(f);
 938     fclose(f);
 939 
 940     return result;
 941 }
 942 
 943 template&lt;typename Vector&gt;
 944 static bool fillBufferWithContentsOfFile(FILE* file, Vector&amp; buffer)
 945 {
 946     // We might have injected &quot;use strict&quot;; at the top.
 947     size_t initialSize = buffer.size();
 948     if (fseek(file, 0, SEEK_END) == -1)
 949         return false;
 950     long bufferCapacity = ftell(file);
 951     if (bufferCapacity == -1)
 952         return false;
 953     if (fseek(file, 0, SEEK_SET) == -1)
 954         return false;
 955     buffer.resize(bufferCapacity + initialSize);
 956     size_t readSize = fread(buffer.data() + initialSize, 1, buffer.size(), file);
 957     return readSize == buffer.size() - initialSize;
 958 }
 959 
 960 static bool fillBufferWithContentsOfFile(const String&amp; fileName, Vector&lt;char&gt;&amp; buffer)
 961 {
 962     FILE* f = fopen(fileName.utf8().data(), &quot;rb&quot;);
 963     if (!f) {
 964         fprintf(stderr, &quot;Could not open file: %s\n&quot;, fileName.utf8().data());
 965         return false;
 966     }
 967 
 968     bool result = fillBufferWithContentsOfFile(f, buffer);
 969     fclose(f);
 970 
 971     return result;
 972 }
 973 
 974 static bool fetchScriptFromLocalFileSystem(const String&amp; fileName, Vector&lt;char&gt;&amp; buffer)
 975 {
 976     if (!fillBufferWithContentsOfFile(fileName, buffer))
 977         return false;
 978     convertShebangToJSComment(buffer);
 979     return true;
 980 }
 981 
 982 class ShellSourceProvider : public StringSourceProvider {
 983 public:
 984     static Ref&lt;ShellSourceProvider&gt; create(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url, const TextPosition&amp; startPosition, SourceProviderSourceType sourceType)
 985     {
 986         return adoptRef(*new ShellSourceProvider(source, sourceOrigin, WTFMove(url), startPosition, sourceType));
 987     }
 988 
 989     ~ShellSourceProvider()
 990     {
 991         commitCachedBytecode();
 992     }
 993 
 994     RefPtr&lt;CachedBytecode&gt; cachedBytecode() const override
 995     {
 996         if (!m_cachedBytecode)
 997             loadBytecode();
 998         return m_cachedBytecode.copyRef();
 999     }
1000 
1001     void updateCache(const UnlinkedFunctionExecutable* executable, const SourceCode&amp;, CodeSpecializationKind kind, const UnlinkedFunctionCodeBlock* codeBlock) const override
1002     {
1003         if (!cacheEnabled() || !m_cachedBytecode)
1004             return;
1005         BytecodeCacheError error;
1006         RefPtr&lt;CachedBytecode&gt; cachedBytecode = encodeFunctionCodeBlock(executable-&gt;vm(), codeBlock, error);
1007         if (cachedBytecode &amp;&amp; !error.isValid())
1008             m_cachedBytecode-&gt;addFunctionUpdate(executable, kind, *cachedBytecode);
1009     }
1010 
1011     void cacheBytecode(const BytecodeCacheGenerator&amp; generator) const override
1012     {
1013         if (!cacheEnabled())
1014             return;
1015         if (!m_cachedBytecode)
1016             m_cachedBytecode = CachedBytecode::create();
1017         auto update = generator();
1018         if (update)
1019             m_cachedBytecode-&gt;addGlobalUpdate(*update);
1020     }
1021 
1022     void commitCachedBytecode() const override
1023     {
1024         if (!cacheEnabled() || !m_cachedBytecode || !m_cachedBytecode-&gt;hasUpdates())
1025             return;
1026 
1027         auto clearBytecode = makeScopeExit([&amp;] {
1028             m_cachedBytecode = nullptr;
1029         });
1030 
1031         String filename = cachePath();
1032         auto fd = FileSystem::openAndLockFile(filename, FileSystem::FileOpenMode::Write, {FileSystem::FileLockMode::Exclusive, FileSystem::FileLockMode::Nonblocking});
1033         if (!FileSystem::isHandleValid(fd))
1034             return;
1035 
1036         auto closeFD = makeScopeExit([&amp;] {
1037             FileSystem::unlockAndCloseFile(fd);
1038         });
1039 
1040         long long fileSize;
1041         if (!FileSystem::getFileSize(fd, fileSize))
1042             return;
1043 
1044         size_t cacheFileSize;
1045         if (!WTF::convertSafely(fileSize, cacheFileSize) || cacheFileSize != m_cachedBytecode-&gt;size()) {
1046             // The bytecode cache has already been updated
1047             return;
1048         }
1049 
1050         if (!FileSystem::truncateFile(fd, m_cachedBytecode-&gt;sizeForUpdate()))
1051             return;
1052 
1053         m_cachedBytecode-&gt;commitUpdates([&amp;] (off_t offset, const void* data, size_t size) {
1054             long long result = FileSystem::seekFile(fd, offset, FileSystem::FileSeekOrigin::Beginning);
1055             ASSERT_UNUSED(result, result != -1);
1056             size_t bytesWritten = static_cast&lt;size_t&gt;(FileSystem::writeToFile(fd, static_cast&lt;const char*&gt;(data), size));
1057             ASSERT_UNUSED(bytesWritten, bytesWritten == size);
1058         });
1059     }
1060 
1061 private:
1062     String cachePath() const
1063     {
1064         if (!cacheEnabled())
1065             return static_cast&lt;const char*&gt;(nullptr);
1066         const char* cachePath = Options::diskCachePath();
1067         String filename = FileSystem::encodeForFileName(FileSystem::lastComponentOfPathIgnoringTrailingSlash(sourceOrigin().string()));
1068         return FileSystem::pathByAppendingComponent(cachePath, makeString(source().toString().hash(), &#39;-&#39;, filename, &quot;.bytecode-cache&quot;));
1069     }
1070 
1071     void loadBytecode() const
1072     {
1073         if (!cacheEnabled())
1074             return;
1075 
1076         String filename = cachePath();
1077         if (filename.isNull())
1078             return;
1079 
1080         auto fd = FileSystem::openAndLockFile(filename, FileSystem::FileOpenMode::Read, {FileSystem::FileLockMode::Shared, FileSystem::FileLockMode::Nonblocking});
1081         if (!FileSystem::isHandleValid(fd))
1082             return;
1083 
1084         auto closeFD = makeScopeExit([&amp;] {
1085             FileSystem::unlockAndCloseFile(fd);
1086         });
1087 
1088         bool success;
1089         FileSystem::MappedFileData mappedFileData(fd, FileSystem::MappedFileMode::Private, success);
1090 
1091         if (!success)
1092             return;
1093 
1094         m_cachedBytecode = CachedBytecode::create(WTFMove(mappedFileData));
1095     }
1096 
1097     ShellSourceProvider(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url, const TextPosition&amp; startPosition, SourceProviderSourceType sourceType)
1098         : StringSourceProvider(source, sourceOrigin, WTFMove(url), startPosition, sourceType)
1099     {
1100     }
1101 
1102     static bool cacheEnabled()
1103     {
1104         static bool enabled = !!Options::diskCachePath();
1105         return enabled;
1106     }
1107 
1108     mutable RefPtr&lt;CachedBytecode&gt; m_cachedBytecode;
1109 };
1110 
1111 static inline SourceCode jscSource(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url = URL(), const TextPosition&amp; startPosition = TextPosition(), SourceProviderSourceType sourceType = SourceProviderSourceType::Program)
1112 {
1113     return SourceCode(ShellSourceProvider::create(source, sourceOrigin, WTFMove(url), startPosition, sourceType), startPosition.m_line.oneBasedInt(), startPosition.m_column.oneBasedInt());
1114 }
1115 
1116 template&lt;typename Vector&gt;
1117 static inline SourceCode jscSource(const Vector&amp; utf8, const SourceOrigin&amp; sourceOrigin, const String&amp; filename)
1118 {
1119     // FIXME: This should use an absolute file URL https://bugs.webkit.org/show_bug.cgi?id=193077
1120     String str = stringFromUTF(utf8);
1121     return jscSource(str, sourceOrigin, URL({ }, filename));
1122 }
1123 
1124 template&lt;typename Vector&gt;
1125 static bool fetchModuleFromLocalFileSystem(const String&amp; fileName, Vector&amp; buffer)
1126 {
1127     // We assume that fileName is always an absolute path.
1128 #if OS(WINDOWS)
1129     // https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx#maxpath
1130     // Use long UNC to pass the long path name to the Windows APIs.
1131     auto pathName = makeString(&quot;\\\\?\\&quot;, fileName).wideCharacters();
1132     struct _stat status { };
1133     if (_wstat(pathName.data(), &amp;status))
1134         return false;
1135     if ((status.st_mode &amp; S_IFMT) != S_IFREG)
1136         return false;
1137 
1138     FILE* f = _wfopen(pathName.data(), L&quot;rb&quot;);
1139 #else
1140     auto pathName = fileName.utf8();
1141     struct stat status { };
1142     if (stat(pathName.data(), &amp;status))
1143         return false;
1144     if ((status.st_mode &amp; S_IFMT) != S_IFREG)
1145         return false;
1146 
1147     FILE* f = fopen(pathName.data(), &quot;r&quot;);
1148 #endif
1149     if (!f) {
1150         fprintf(stderr, &quot;Could not open file: %s\n&quot;, fileName.utf8().data());
1151         return false;
1152     }
1153 
1154     bool result = fillBufferWithContentsOfFile(f, buffer);
1155     if (result)
1156         convertShebangToJSComment(buffer);
1157     fclose(f);
1158 
1159     return result;
1160 }
1161 
1162 JSInternalPromise* GlobalObject::moduleLoaderFetch(JSGlobalObject* globalObject, JSModuleLoader*, JSValue key, JSValue, JSValue)
1163 {
1164     VM&amp; vm = globalObject-&gt;vm();
1165     JSInternalPromise* promise = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());
1166 
1167     auto catchScope = DECLARE_CATCH_SCOPE(vm);
1168     auto reject = [&amp;] (JSValue rejectionReason) {
1169         catchScope.clearException();
1170         promise-&gt;reject(globalObject, rejectionReason);
1171         catchScope.clearException();
1172         return promise;
1173     };
1174 
1175     String moduleKey = key.toWTFString(globalObject);
1176     if (UNLIKELY(catchScope.exception()))
1177         return reject(catchScope.exception());
1178 
1179     // Here, now we consider moduleKey as the fileName.
1180     Vector&lt;uint8_t&gt; buffer;
1181     if (!fetchModuleFromLocalFileSystem(moduleKey, buffer))
1182         return reject(createError(globalObject, makeString(&quot;Could not open file &#39;&quot;, moduleKey, &quot;&#39;.&quot;)));
1183 
1184 
1185     URL moduleURL = URL({ }, moduleKey);
1186 #if ENABLE(WEBASSEMBLY)
1187     // FileSystem does not have mime-type header. The JSC shell recognizes WebAssembly&#39;s magic header.
1188     if (buffer.size() &gt;= 4) {
1189         if (buffer[0] == &#39;\0&#39; &amp;&amp; buffer[1] == &#39;a&#39; &amp;&amp; buffer[2] == &#39;s&#39; &amp;&amp; buffer[3] == &#39;m&#39;) {
1190             auto source = SourceCode(WebAssemblySourceProvider::create(WTFMove(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL)));
1191             catchScope.releaseAssertNoException();
1192             auto sourceCode = JSSourceCode::create(vm, WTFMove(source));
1193             catchScope.releaseAssertNoException();
1194             promise-&gt;resolve(globalObject, sourceCode);
1195             catchScope.clearException();
1196             return promise;
1197         }
1198     }
1199 #endif
1200 
1201     auto sourceCode = JSSourceCode::create(vm, jscSource(stringFromUTF(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL), TextPosition(), SourceProviderSourceType::Module));
1202     catchScope.releaseAssertNoException();
1203     promise-&gt;resolve(globalObject, sourceCode);
1204     catchScope.clearException();
1205     return promise;
1206 }
1207 
1208 JSObject* GlobalObject::moduleLoaderCreateImportMetaProperties(JSGlobalObject* globalObject, JSModuleLoader*, JSValue key, JSModuleRecord*, JSValue)
1209 {
1210     VM&amp; vm = globalObject-&gt;vm();
1211     auto scope = DECLARE_THROW_SCOPE(vm);
1212 
1213     JSObject* metaProperties = constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure());
1214     RETURN_IF_EXCEPTION(scope, nullptr);
1215 
1216     metaProperties-&gt;putDirect(vm, Identifier::fromString(vm, &quot;filename&quot;), key);
1217     RETURN_IF_EXCEPTION(scope, nullptr);
1218 
1219     return metaProperties;
1220 }
1221 
1222 static CString cStringFromViewWithString(JSGlobalObject* globalObject, ThrowScope&amp; scope, StringViewWithUnderlyingString&amp; viewWithString)
1223 {
1224     Expected&lt;CString, UTF8ConversionError&gt; expectedString = viewWithString.view.tryGetUtf8();
1225     if (expectedString)
1226         return expectedString.value();
1227     switch (expectedString.error()) {
1228     case UTF8ConversionError::OutOfMemory:
1229         throwOutOfMemoryError(globalObject, scope);
1230         break;
1231     case UTF8ConversionError::IllegalSource:
1232         scope.throwException(globalObject, createError(globalObject, &quot;Illegal source encountered during UTF8 conversion&quot;));
1233         break;
1234     case UTF8ConversionError::SourceExhausted:
1235         scope.throwException(globalObject, createError(globalObject, &quot;Source exhausted during UTF8 conversion&quot;));
1236         break;
1237     default:
1238         RELEASE_ASSERT_NOT_REACHED();
1239     }
1240     return { };
1241 }
1242 
1243 static EncodedJSValue printInternal(JSGlobalObject* globalObject, CallFrame* callFrame, FILE* out)
1244 {
1245     VM&amp; vm = globalObject-&gt;vm();
1246     auto scope = DECLARE_THROW_SCOPE(vm);
1247 
1248     if (asyncTestExpectedPasses) {
1249         JSValue value = callFrame-&gt;argument(0);
1250         if (value.isString() &amp;&amp; WTF::equal(asString(value)-&gt;value(globalObject).impl(), &quot;Test262:AsyncTestComplete&quot;)) {
1251             asyncTestPasses++;
1252             return JSValue::encode(jsUndefined());
1253         }
1254     }
1255 
1256     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {
1257         if (i)
1258             if (EOF == fputc(&#39; &#39;, out))
1259                 goto fail;
1260 
1261         auto viewWithString = callFrame-&gt;uncheckedArgument(i).toString(globalObject)-&gt;viewWithUnderlyingString(globalObject);
1262         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1263         auto string = cStringFromViewWithString(globalObject, scope, viewWithString);
1264         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1265         if (fprintf(out, &quot;%s&quot;, string.data()) &lt; 0)
1266             goto fail;
1267     }
1268 
1269     fputc(&#39;\n&#39;, out);
1270 fail:
1271     fflush(out);
1272     return JSValue::encode(jsUndefined());
1273 }
1274 
1275 EncodedJSValue JSC_HOST_CALL functionPrintStdOut(JSGlobalObject* globalObject, CallFrame* callFrame) { return printInternal(globalObject, callFrame, stdout); }
1276 EncodedJSValue JSC_HOST_CALL functionPrintStdErr(JSGlobalObject* globalObject, CallFrame* callFrame) { return printInternal(globalObject, callFrame, stderr); }
1277 
1278 EncodedJSValue JSC_HOST_CALL functionDebug(JSGlobalObject* globalObject, CallFrame* callFrame)
1279 {
1280     VM&amp; vm = globalObject-&gt;vm();
1281     auto scope = DECLARE_THROW_SCOPE(vm);
1282     auto viewWithString = callFrame-&gt;argument(0).toString(globalObject)-&gt;viewWithUnderlyingString(globalObject);
1283     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1284     auto string = cStringFromViewWithString(globalObject, scope, viewWithString);
1285     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1286     fprintf(stderr, &quot;--&gt; %s\n&quot;, string.data());
1287     return JSValue::encode(jsUndefined());
1288 }
1289 
1290 EncodedJSValue JSC_HOST_CALL functionDescribe(JSGlobalObject* globalObject, CallFrame* callFrame)
1291 {
1292     VM&amp; vm = globalObject-&gt;vm();
1293     if (callFrame-&gt;argumentCount() &lt; 1)
1294         return JSValue::encode(jsUndefined());
1295     return JSValue::encode(jsString(vm, toString(callFrame-&gt;argument(0))));
1296 }
1297 
1298 EncodedJSValue JSC_HOST_CALL functionDescribeArray(JSGlobalObject* globalObject, CallFrame* callFrame)
1299 {
1300     if (callFrame-&gt;argumentCount() &lt; 1)
1301         return JSValue::encode(jsUndefined());
1302     VM&amp; vm = globalObject-&gt;vm();
1303     JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;argument(0));
1304     if (!object)
1305         return JSValue::encode(jsNontrivialString(vm, &quot;&lt;not object&gt;&quot;_s));
1306     return JSValue::encode(jsNontrivialString(vm, toString(&quot;&lt;Butterfly: &quot;, RawPointer(object-&gt;butterfly()), &quot;; public length: &quot;, object-&gt;getArrayLength(), &quot;; vector length: &quot;, object-&gt;getVectorLength(), &quot;&gt;&quot;)));
1307 }
1308 
1309 EncodedJSValue JSC_HOST_CALL functionSleepSeconds(JSGlobalObject* globalObject, CallFrame* callFrame)
1310 {
1311     VM&amp; vm = globalObject-&gt;vm();
1312     auto scope = DECLARE_THROW_SCOPE(vm);
1313 
1314     if (callFrame-&gt;argumentCount() &gt;= 1) {
1315         Seconds seconds = Seconds(callFrame-&gt;argument(0).toNumber(globalObject));
1316         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1317         sleep(seconds);
1318     }
1319 
1320     return JSValue::encode(jsUndefined());
1321 }
1322 
1323 class FunctionJSCStackFunctor {
1324 public:
1325     FunctionJSCStackFunctor(StringBuilder&amp; trace)
1326         : m_trace(trace)
1327     {
1328     }
1329 
1330     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
1331     {
1332         m_trace.append(makeString(&quot;    &quot;, visitor-&gt;index(), &quot;   &quot;, visitor-&gt;toString(), &#39;\n&#39;));
1333         return StackVisitor::Continue;
1334     }
1335 
1336 private:
1337     StringBuilder&amp; m_trace;
1338 };
1339 
1340 EncodedJSValue JSC_HOST_CALL functionJSCStack(JSGlobalObject* globalObject, CallFrame* callFrame)
1341 {
1342     VM&amp; vm = globalObject-&gt;vm();
1343     StringBuilder trace;
1344     trace.appendLiteral(&quot;--&gt; Stack trace:\n&quot;);
1345 
1346     FunctionJSCStackFunctor functor(trace);
1347     callFrame-&gt;iterate(vm, functor);
1348     fprintf(stderr, &quot;%s&quot;, trace.toString().utf8().data());
1349     return JSValue::encode(jsUndefined());
1350 }
1351 
1352 EncodedJSValue JSC_HOST_CALL functionGCAndSweep(JSGlobalObject* globalObject, CallFrame*)
1353 {
1354     VM&amp; vm = globalObject-&gt;vm();
1355     JSLockHolder lock(vm);
1356     vm.heap.collectNow(Sync, CollectionScope::Full);
1357     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastFullCollection()));
1358 }
1359 
1360 EncodedJSValue JSC_HOST_CALL functionFullGC(JSGlobalObject* globalObject, CallFrame*)
1361 {
1362     VM&amp; vm = globalObject-&gt;vm();
1363     JSLockHolder lock(vm);
1364     vm.heap.collectSync(CollectionScope::Full);
1365     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastFullCollection()));
1366 }
1367 
1368 EncodedJSValue JSC_HOST_CALL functionEdenGC(JSGlobalObject* globalObject, CallFrame*)
1369 {
1370     VM&amp; vm = globalObject-&gt;vm();
1371     JSLockHolder lock(vm);
1372     vm.heap.collectSync(CollectionScope::Eden);
1373     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastEdenCollection()));
1374 }
1375 
1376 EncodedJSValue JSC_HOST_CALL functionHeapSize(JSGlobalObject* globalObject, CallFrame*)
1377 {
1378     VM&amp; vm = globalObject-&gt;vm();
1379     JSLockHolder lock(vm);
1380     return JSValue::encode(jsNumber(vm.heap.size()));
1381 }
1382 
1383 class JSCMemoryFootprint : public JSDestructibleObject {
1384     using Base = JSDestructibleObject;
1385 public:
1386     JSCMemoryFootprint(VM&amp; vm, Structure* structure)
1387         : Base(vm, structure)
1388     { }
1389 
1390     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1391     {
1392         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
1393     }
1394 
1395     static JSCMemoryFootprint* create(VM&amp; vm, JSGlobalObject* globalObject)
1396     {
1397         Structure* structure = createStructure(vm, globalObject, jsNull());
1398         JSCMemoryFootprint* footprint = new (NotNull, allocateCell&lt;JSCMemoryFootprint&gt;(vm.heap)) JSCMemoryFootprint(vm, structure);
1399         footprint-&gt;finishCreation(vm);
1400         return footprint;
1401     }
1402 
1403     void finishCreation(VM&amp; vm)
1404     {
1405         Base::finishCreation(vm);
1406 
1407         auto addProperty = [&amp;] (VM&amp; vm, const char* name, JSValue value) {
1408             JSCMemoryFootprint::addProperty(vm, name, value);
1409         };
1410 
1411         MemoryFootprint footprint = MemoryFootprint::now();
1412 
1413         addProperty(vm, &quot;current&quot;, jsNumber(footprint.current));
1414         addProperty(vm, &quot;peak&quot;, jsNumber(footprint.peak));
1415     }
1416 
1417     DECLARE_INFO;
1418 
1419 private:
1420     void addProperty(VM&amp; vm, const char* name, JSValue value)
1421     {
1422         Identifier identifier = Identifier::fromString(vm, name);
1423         putDirect(vm, identifier, value);
1424     }
1425 };
1426 
1427 const ClassInfo JSCMemoryFootprint::s_info = { &quot;MemoryFootprint&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSCMemoryFootprint) };
1428 
1429 EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(JSGlobalObject* globalObject, CallFrame*)
1430 {
1431     VM&amp; vm = globalObject-&gt;vm();
1432     JSLockHolder lock(vm);
1433     return JSValue::encode(JSCMemoryFootprint::create(vm, globalObject));
1434 }
1435 
1436 EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(JSGlobalObject*, CallFrame*)
1437 {
1438     MemoryFootprint::resetPeak();
1439     return JSValue::encode(jsUndefined());
1440 }
1441 
1442 // This function is not generally very helpful in 64-bit code as the tag and payload
1443 // share a register. But in 32-bit JITed code the tag may not be checked if an
1444 // optimization removes type checking requirements, such as in ===.
1445 EncodedJSValue JSC_HOST_CALL functionAddressOf(JSGlobalObject*, CallFrame* callFrame)
1446 {
1447     JSValue value = callFrame-&gt;argument(0);
1448     if (!value.isCell())
1449         return JSValue::encode(jsUndefined());
1450     // Need to cast to uint64_t so bitwise_cast will play along.
1451     uint64_t asNumber = reinterpret_cast&lt;uint64_t&gt;(value.asCell());
1452     EncodedJSValue returnValue = JSValue::encode(jsNumber(bitwise_cast&lt;double&gt;(asNumber)));
1453     return returnValue;
1454 }
1455 
1456 EncodedJSValue JSC_HOST_CALL functionVersion(JSGlobalObject*, CallFrame*)
1457 {
1458     // We need this function for compatibility with the Mozilla JS tests but for now
1459     // we don&#39;t actually do any version-specific handling
1460     return JSValue::encode(jsUndefined());
1461 }
1462 
1463 EncodedJSValue JSC_HOST_CALL functionRun(JSGlobalObject* globalObject, CallFrame* callFrame)
1464 {
1465     VM&amp; vm = globalObject-&gt;vm();
1466     auto scope = DECLARE_THROW_SCOPE(vm);
1467 
1468     String fileName = callFrame-&gt;argument(0).toWTFString(globalObject);
1469     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1470     Vector&lt;char&gt; script;
1471     if (!fetchScriptFromLocalFileSystem(fileName, script))
1472         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Could not open file.&quot;_s)));
1473 
1474     GlobalObject* realm = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
1475 
1476     JSArray* array = constructEmptyArray(realm, 0);
1477     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1478     for (unsigned i = 1; i &lt; callFrame-&gt;argumentCount(); ++i) {
1479         array-&gt;putDirectIndex(realm, i - 1, callFrame-&gt;uncheckedArgument(i));
1480         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1481     }
1482     realm-&gt;putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);
1483 
1484     NakedPtr&lt;Exception&gt; exception;
1485     StopWatch stopWatch;
1486     stopWatch.start();
1487     evaluate(realm, jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), exception);
1488     stopWatch.stop();
1489 
1490     if (exception) {
1491         throwException(realm, scope, exception);
1492         return JSValue::encode(jsUndefined());
1493     }
1494 
1495     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
1496 }
1497 
1498 EncodedJSValue JSC_HOST_CALL functionRunString(JSGlobalObject* globalObject, CallFrame* callFrame)
1499 {
1500     VM&amp; vm = globalObject-&gt;vm();
1501     auto scope = DECLARE_THROW_SCOPE(vm);
1502 
1503     String source = callFrame-&gt;argument(0).toWTFString(globalObject);
1504     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1505 
1506     GlobalObject* realm = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
1507 
1508     JSArray* array = constructEmptyArray(realm, 0);
1509     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1510     for (unsigned i = 1; i &lt; callFrame-&gt;argumentCount(); ++i) {
1511         array-&gt;putDirectIndex(realm, i - 1, callFrame-&gt;uncheckedArgument(i));
1512         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1513     }
1514     realm-&gt;putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);
1515 
1516     NakedPtr&lt;Exception&gt; exception;
1517     evaluate(realm, jscSource(source, callFrame-&gt;callerSourceOrigin(vm)), JSValue(), exception);
1518 
1519     if (exception) {
1520         scope.throwException(realm, exception);
1521         return JSValue::encode(jsUndefined());
1522     }
1523 
1524     return JSValue::encode(realm);
1525 }
1526 
1527 EncodedJSValue JSC_HOST_CALL functionLoad(JSGlobalObject* globalObject, CallFrame* callFrame)
1528 {
1529     VM&amp; vm = globalObject-&gt;vm();
1530     auto scope = DECLARE_THROW_SCOPE(vm);
1531 
1532     String fileName = callFrame-&gt;argument(0).toWTFString(globalObject);
1533     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1534     Vector&lt;char&gt; script;
1535     if (!fetchScriptFromLocalFileSystem(fileName, script))
1536         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Could not open file.&quot;_s)));
1537 
1538     NakedPtr&lt;Exception&gt; evaluationException;
1539     JSValue result = evaluate(globalObject, jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);
1540     if (evaluationException)
1541         throwException(globalObject, scope, evaluationException);
1542     return JSValue::encode(result);
1543 }
1544 
1545 EncodedJSValue JSC_HOST_CALL functionLoadString(JSGlobalObject* globalObject, CallFrame* callFrame)
1546 {
1547     VM&amp; vm = globalObject-&gt;vm();
1548     auto scope = DECLARE_THROW_SCOPE(vm);
1549 
1550     String sourceCode = callFrame-&gt;argument(0).toWTFString(globalObject);
1551     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1552 
1553     NakedPtr&lt;Exception&gt; evaluationException;
1554     JSValue result = evaluate(globalObject, jscSource(sourceCode, callFrame-&gt;callerSourceOrigin(vm)), JSValue(), evaluationException);
1555     if (evaluationException)
1556         throwException(globalObject, scope, evaluationException);
1557     return JSValue::encode(result);
1558 }
1559 
1560 EncodedJSValue JSC_HOST_CALL functionReadFile(JSGlobalObject* globalObject, CallFrame* callFrame)
1561 {
1562     VM&amp; vm = globalObject-&gt;vm();
1563     auto scope = DECLARE_THROW_SCOPE(vm);
1564 
1565     String fileName = callFrame-&gt;argument(0).toWTFString(globalObject);
1566     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1567 
1568     bool isBinary = false;
1569     if (callFrame-&gt;argumentCount() &gt; 1) {
1570         String type = callFrame-&gt;argument(1).toWTFString(globalObject);
1571         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1572         if (type != &quot;binary&quot;)
1573             return throwVMError(globalObject, scope, &quot;Expected &#39;binary&#39; as second argument.&quot;);
1574         isBinary = true;
1575     }
1576 
1577     RefPtr&lt;Uint8Array&gt; content = fillBufferWithContentsOfFile(fileName);
1578     if (!content)
1579         return throwVMError(globalObject, scope, &quot;Could not open file.&quot;);
1580 
1581     if (!isBinary)
1582         return JSValue::encode(jsString(vm, String::fromUTF8WithLatin1Fallback(content-&gt;data(), content-&gt;length())));
1583 
1584     Structure* structure = globalObject-&gt;typedArrayStructure(TypeUint8);
1585     JSObject* result = JSUint8Array::create(vm, structure, WTFMove(content));
1586     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1587 
1588     return JSValue::encode(result);
1589 }
1590 
1591 EncodedJSValue JSC_HOST_CALL functionCheckSyntax(JSGlobalObject* globalObject, CallFrame* callFrame)
1592 {
1593     VM&amp; vm = globalObject-&gt;vm();
1594     auto scope = DECLARE_THROW_SCOPE(vm);
1595 
1596     String fileName = callFrame-&gt;argument(0).toWTFString(globalObject);
1597     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1598     Vector&lt;char&gt; script;
1599     if (!fetchScriptFromLocalFileSystem(fileName, script))
1600         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Could not open file.&quot;_s)));
1601 
1602     StopWatch stopWatch;
1603     stopWatch.start();
1604 
1605     JSValue syntaxException;
1606     bool validSyntax = checkSyntax(globalObject, jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), &amp;syntaxException);
1607     stopWatch.stop();
1608 
1609     if (!validSyntax)
1610         throwException(globalObject, scope, syntaxException);
1611     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
1612 }
1613 
1614 #if ENABLE(SAMPLING_FLAGS)
1615 EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(JSGlobalObject*, CallFrame* callFrame)
1616 {
1617     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {
1618         unsigned flag = static_cast&lt;unsigned&gt;(callFrame-&gt;uncheckedArgument(i).toNumber(globalObject));
1619         if ((flag &gt;= 1) &amp;&amp; (flag &lt;= 32))
1620             SamplingFlags::setFlag(flag);
1621     }
1622     return JSValue::encode(jsNull());
1623 }
1624 
1625 EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(JSGlobalObject*, CallFrame* callFrame)
1626 {
1627     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {
1628         unsigned flag = static_cast&lt;unsigned&gt;(callFrame-&gt;uncheckedArgument(i).toNumber(globalObject));
1629         if ((flag &gt;= 1) &amp;&amp; (flag &lt;= 32))
1630             SamplingFlags::clearFlag(flag);
1631     }
1632     return JSValue::encode(jsNull());
1633 }
1634 #endif
1635 
1636 EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(JSGlobalObject* globalObject, CallFrame*)
1637 {
1638     return JSValue::encode(jsNumber(globalObject-&gt;weakRandom().seed()));
1639 }
1640 
1641 EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(JSGlobalObject* globalObject, CallFrame* callFrame)
1642 {
1643     VM&amp; vm = globalObject-&gt;vm();
1644     auto scope = DECLARE_THROW_SCOPE(vm);
1645 
1646     unsigned seed = callFrame-&gt;argument(0).toUInt32(globalObject);
1647     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1648     globalObject-&gt;weakRandom().setSeed(seed);
1649     return JSValue::encode(jsUndefined());
1650 }
1651 
1652 EncodedJSValue JSC_HOST_CALL functionIsRope(JSGlobalObject*, CallFrame* callFrame)
1653 {
1654     JSValue argument = callFrame-&gt;argument(0);
1655     if (!argument.isString())
1656         return JSValue::encode(jsBoolean(false));
1657     const StringImpl* impl = asString(argument)-&gt;tryGetValueImpl();
1658     return JSValue::encode(jsBoolean(!impl));
1659 }
1660 
1661 EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(JSGlobalObject* globalObject, CallFrame* callFrame)
1662 {
1663     VM&amp; vm = globalObject-&gt;vm();
1664     SourceOrigin sourceOrigin = callFrame-&gt;callerSourceOrigin(vm);
1665     if (sourceOrigin.isNull())
1666         return JSValue::encode(jsNull());
1667     return JSValue::encode(jsString(vm, sourceOrigin.string()));
1668 }
1669 
1670 EncodedJSValue JSC_HOST_CALL functionReadline(JSGlobalObject* globalObject, CallFrame*)
1671 {
1672     Vector&lt;char, 256&gt; line;
1673     int c;
1674     while ((c = getchar()) != EOF) {
1675         // FIXME: Should we also break on \r?
1676         if (c == &#39;\n&#39;)
1677             break;
1678         line.append(c);
1679     }
1680     line.append(&#39;\0&#39;);
1681     return JSValue::encode(jsString(globalObject-&gt;vm(), line.data()));
1682 }
1683 
1684 EncodedJSValue JSC_HOST_CALL functionPreciseTime(JSGlobalObject*, CallFrame*)
1685 {
1686     return JSValue::encode(jsNumber(WallTime::now().secondsSinceEpoch().value()));
1687 }
1688 
1689 EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(JSGlobalObject* globalObject, CallFrame* callFrame)
1690 {
1691     return JSValue::encode(setNeverInline(globalObject, callFrame));
1692 }
1693 
1694 EncodedJSValue JSC_HOST_CALL functionNoDFG(JSGlobalObject* globalObject, CallFrame* callFrame)
1695 {
1696     return JSValue::encode(setNeverOptimize(globalObject, callFrame));
1697 }
1698 
1699 EncodedJSValue JSC_HOST_CALL functionNoFTL(JSGlobalObject*, CallFrame* callFrame)
1700 {
1701     if (callFrame-&gt;argumentCount()) {
1702         FunctionExecutable* executable = getExecutableForFunction(callFrame-&gt;argument(0));
1703         if (executable)
1704             executable-&gt;setNeverFTLOptimize(true);
1705     }
1706     return JSValue::encode(jsUndefined());
1707 }
1708 
1709 EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(JSGlobalObject* globalObject, CallFrame* callFrame)
1710 {
1711     return JSValue::encode(setCannotUseOSRExitFuzzing(globalObject, callFrame));
1712 }
1713 
1714 EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(JSGlobalObject* globalObject, CallFrame* callFrame)
1715 {
1716     return JSValue::encode(optimizeNextInvocation(globalObject, callFrame));
1717 }
1718 
1719 EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(JSGlobalObject* globalObject, CallFrame* callFrame)
1720 {
1721     return JSValue::encode(numberOfDFGCompiles(globalObject, callFrame));
1722 }
1723 
1724 EncodedJSValue JSC_HOST_CALL functionCallerIsOMGCompiled(JSGlobalObject* globalObject, CallFrame* callFrame)
1725 {
1726     VM&amp; vm = globalObject-&gt;vm();
1727     auto scope = DECLARE_THROW_SCOPE(vm);
1728 
1729     if (!Options::useBBQTierUpChecks())
1730         return JSValue::encode(jsBoolean(true));
1731 
1732     CallerFunctor wasmToJSFrame;
1733     StackVisitor::visit(callFrame, vm, wasmToJSFrame);
1734     if (!wasmToJSFrame.callerFrame()-&gt;isAnyWasmCallee())
1735         return throwVMError(globalObject, scope, &quot;caller is not a wasm-&gt;js import function&quot;);
1736 
1737     // We have a wrapper frame that we generate for imports. If we ever can direct call from wasm we would need to change this.
1738     ASSERT(!wasmToJSFrame.callerFrame()-&gt;callee().isWasm());
1739     CallerFunctor wasmFrame;
1740     StackVisitor::visit(wasmToJSFrame.callerFrame(), vm, wasmFrame);
1741     ASSERT(wasmFrame.callerFrame()-&gt;callee().isWasm());
1742 #if ENABLE(WEBASSEMBLY)
1743     auto mode = wasmFrame.callerFrame()-&gt;callee().asWasmCallee()-&gt;compilationMode();
1744     return JSValue::encode(jsBoolean(mode == Wasm::CompilationMode::OMGMode || mode == Wasm::CompilationMode::OMGForOSREntryMode));
1745 #endif
1746     RELEASE_ASSERT_NOT_REACHED();
1747 }
1748 
1749 Message::Message(ArrayBufferContents&amp;&amp; contents, int32_t index)
1750     : m_contents(WTFMove(contents))
1751     , m_index(index)
1752 {
1753 }
1754 
1755 Message::~Message()
1756 {
1757 }
1758 
1759 Worker::Worker(Workers&amp; workers)
1760     : m_workers(workers)
1761 {
1762     auto locker = holdLock(m_workers.m_lock);
1763     m_workers.m_workers.append(this);
1764 
1765     *currentWorker() = this;
1766 }
1767 
1768 Worker::~Worker()
1769 {
1770     auto locker = holdLock(m_workers.m_lock);
1771     RELEASE_ASSERT(isOnList());
1772     remove();
1773 }
1774 
1775 void Worker::enqueue(const AbstractLocker&amp;, RefPtr&lt;Message&gt; message)
1776 {
1777     m_messages.append(message);
1778 }
1779 
1780 RefPtr&lt;Message&gt; Worker::dequeue()
1781 {
1782     auto locker = holdLock(m_workers.m_lock);
1783     while (m_messages.isEmpty())
1784         m_workers.m_condition.wait(m_workers.m_lock);
1785     return m_messages.takeFirst();
1786 }
1787 
1788 Worker&amp; Worker::current()
1789 {
1790     return **currentWorker();
1791 }
1792 
1793 ThreadSpecific&lt;Worker*&gt;&amp; Worker::currentWorker()
1794 {
1795     static ThreadSpecific&lt;Worker*&gt;* result;
1796     static std::once_flag flag;
1797     std::call_once(
1798         flag,
1799         [] () {
1800             result = new ThreadSpecific&lt;Worker*&gt;();
1801         });
1802     return *result;
1803 }
1804 
1805 Workers::Workers()
1806 {
1807 }
1808 
1809 Workers::~Workers()
1810 {
1811     UNREACHABLE_FOR_PLATFORM();
1812 }
1813 
1814 template&lt;typename Func&gt;
1815 void Workers::broadcast(const Func&amp; func)
1816 {
1817     auto locker = holdLock(m_lock);
1818     for (Worker* worker = m_workers.begin(); worker != m_workers.end(); worker = worker-&gt;next()) {
1819         if (worker != &amp;Worker::current())
1820             func(locker, *worker);
1821     }
1822     m_condition.notifyAll();
1823 }
1824 
1825 void Workers::report(const String&amp; string)
1826 {
1827     auto locker = holdLock(m_lock);
1828     m_reports.append(string.isolatedCopy());
1829     m_condition.notifyAll();
1830 }
1831 
1832 String Workers::tryGetReport()
1833 {
1834     auto locker = holdLock(m_lock);
1835     if (m_reports.isEmpty())
1836         return String();
1837     return m_reports.takeFirst();
1838 }
1839 
1840 String Workers::getReport()
1841 {
1842     auto locker = holdLock(m_lock);
1843     while (m_reports.isEmpty())
1844         m_condition.wait(m_lock);
1845     return m_reports.takeFirst();
1846 }
1847 
1848 Workers&amp; Workers::singleton()
1849 {
1850     static Workers* result;
1851     static std::once_flag flag;
1852     std::call_once(
1853         flag,
1854         [] {
1855             result = new Workers();
1856         });
1857     return *result;
1858 }
1859 
1860 EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(JSGlobalObject* globalObject, CallFrame*)
1861 {
1862     VM&amp; vm = globalObject-&gt;vm();
1863     GlobalObject* result = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
1864     return JSValue::encode(result-&gt;getDirect(vm, Identifier::fromString(vm, &quot;$&quot;)));
1865 }
1866 
1867 EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(JSGlobalObject* globalObject, CallFrame* callFrame)
1868 {
1869     VM&amp; vm = globalObject-&gt;vm();
1870     auto scope = DECLARE_THROW_SCOPE(vm);
1871 
1872     String sourceCode = callFrame-&gt;argument(0).toWTFString(globalObject);
1873     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1874 
1875     GlobalObject* realm = jsDynamicCast&lt;GlobalObject*&gt;(vm,
1876         callFrame-&gt;thisValue().get(globalObject, Identifier::fromString(vm, &quot;global&quot;)));
1877     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1878     if (!realm)
1879         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Expected global to point to a global object&quot;_s)));
1880 
1881     NakedPtr&lt;Exception&gt; evaluationException;
1882     JSValue result = evaluate(realm, jscSource(sourceCode, callFrame-&gt;callerSourceOrigin(vm)), JSValue(), evaluationException);
1883     if (evaluationException)
1884         throwException(globalObject, scope, evaluationException);
1885     return JSValue::encode(result);
1886 }
1887 
1888 EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(JSGlobalObject* globalObject, CallFrame* callFrame)
1889 {
1890     VM&amp; vm = globalObject-&gt;vm();
1891     auto scope = DECLARE_THROW_SCOPE(vm);
1892 
1893     String sourceCode = callFrame-&gt;argument(0).toWTFString(globalObject).isolatedCopy();
1894     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1895 
1896     Lock didStartLock;
1897     Condition didStartCondition;
1898     bool didStart = false;
1899 
1900     Thread::create(
1901         &quot;JSC Agent&quot;,
1902         [sourceCode, &amp;didStartLock, &amp;didStartCondition, &amp;didStart] () {
1903             CommandLine commandLine(0, nullptr);
1904             commandLine.m_interactive = false;
1905             runJSC(
1906                 commandLine, true,
1907                 [&amp;] (VM&amp;, GlobalObject* globalObject, bool&amp; success) {
1908                     // Notify the thread that started us that we have registered a worker.
1909                     {
1910                         auto locker = holdLock(didStartLock);
1911                         didStart = true;
1912                         didStartCondition.notifyOne();
1913                     }
1914 
1915                     NakedPtr&lt;Exception&gt; evaluationException;
1916                     JSValue result;
1917                     result = evaluate(globalObject, jscSource(sourceCode, SourceOrigin(&quot;worker&quot;_s)), JSValue(), evaluationException);
1918                     if (evaluationException)
1919                         result = evaluationException-&gt;value();
1920                     checkException(globalObject, true, evaluationException, result, commandLine, success);
1921                     if (!success)
1922                         exit(1);
1923                 });
1924         })-&gt;detach();
1925 
1926     {
1927         auto locker = holdLock(didStartLock);
1928         while (!didStart)
1929             didStartCondition.wait(didStartLock);
1930     }
1931 
1932     return JSValue::encode(jsUndefined());
1933 }
1934 
1935 EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(JSGlobalObject* globalObject, CallFrame* callFrame)
1936 {
1937     VM&amp; vm = globalObject-&gt;vm();
1938     auto scope = DECLARE_THROW_SCOPE(vm);
1939 
1940     JSValue callback = callFrame-&gt;argument(0);
1941     CallData callData;
1942     CallType callType = getCallData(vm, callback, callData);
1943     if (callType == CallType::None)
1944         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Expected callback&quot;_s)));
1945 
1946     RefPtr&lt;Message&gt; message;
1947     {
1948         ReleaseHeapAccessScope releaseAccess(vm.heap);
1949         message = Worker::current().dequeue();
1950     }
1951 
1952     auto nativeBuffer = ArrayBuffer::create(message-&gt;releaseContents());
1953     ArrayBufferSharingMode sharingMode = nativeBuffer-&gt;sharingMode();
1954     JSArrayBuffer* jsBuffer = JSArrayBuffer::create(vm, globalObject-&gt;arrayBufferStructure(sharingMode), WTFMove(nativeBuffer));
1955 
1956     MarkedArgumentBuffer args;
1957     args.append(jsBuffer);
1958     args.append(jsNumber(message-&gt;index()));
1959     if (UNLIKELY(args.hasOverflowed()))
1960         return JSValue::encode(throwOutOfMemoryError(globalObject, scope));
1961     RELEASE_AND_RETURN(scope, JSValue::encode(call(globalObject, callback, callType, callData, jsNull(), args)));
1962 }
1963 
1964 EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(JSGlobalObject* globalObject, CallFrame* callFrame)
1965 {
1966     VM&amp; vm = globalObject-&gt;vm();
1967     auto scope = DECLARE_THROW_SCOPE(vm);
1968 
1969     String report = callFrame-&gt;argument(0).toWTFString(globalObject);
1970     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1971 
1972     Workers::singleton().report(report);
1973 
1974     return JSValue::encode(jsUndefined());
1975 }
1976 
1977 EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(JSGlobalObject* globalObject, CallFrame* callFrame)
1978 {
1979     VM&amp; vm = globalObject-&gt;vm();
1980     auto scope = DECLARE_THROW_SCOPE(vm);
1981 
1982     if (callFrame-&gt;argumentCount() &gt;= 1) {
1983         Seconds seconds = Seconds::fromMilliseconds(callFrame-&gt;argument(0).toNumber(globalObject));
1984         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1985         sleep(seconds);
1986     }
1987     return JSValue::encode(jsUndefined());
1988 }
1989 
1990 EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(JSGlobalObject* globalObject, CallFrame* callFrame)
1991 {
1992     VM&amp; vm = globalObject-&gt;vm();
1993     auto scope = DECLARE_THROW_SCOPE(vm);
1994 
1995     JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, callFrame-&gt;argument(0));
1996     if (!jsBuffer || !jsBuffer-&gt;isShared())
1997         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Expected SharedArrayBuffer&quot;_s)));
1998 
1999     int32_t index = callFrame-&gt;argument(1).toInt32(globalObject);
2000     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2001 
2002     Workers::singleton().broadcast(
2003         [&amp;] (const AbstractLocker&amp; locker, Worker&amp; worker) {
2004             ArrayBuffer* nativeBuffer = jsBuffer-&gt;impl();
2005             ArrayBufferContents contents;
2006             nativeBuffer-&gt;transferTo(vm, contents); // &quot;transferTo&quot; means &quot;share&quot; if the buffer is shared.
2007             RefPtr&lt;Message&gt; message = adoptRef(new Message(WTFMove(contents), index));
2008             worker.enqueue(locker, message);
2009         });
2010 
2011     return JSValue::encode(jsUndefined());
2012 }
2013 
2014 EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(JSGlobalObject* globalObject, CallFrame*)
2015 {
2016     VM&amp; vm = globalObject-&gt;vm();
2017 
2018     String string = Workers::singleton().tryGetReport();
2019     if (!string)
2020         return JSValue::encode(jsNull());
2021 
2022     return JSValue::encode(jsString(vm, string));
2023 }
2024 
2025 EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(JSGlobalObject*, CallFrame*)
2026 {
2027     return JSValue::encode(jsUndefined());
2028 }
2029 
2030 EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(JSGlobalObject*, CallFrame*)
2031 {
2032     return JSValue::encode(jsNumber(MonotonicTime::now().secondsSinceEpoch().milliseconds()));
2033 }
2034 
2035 EncodedJSValue JSC_HOST_CALL functionWaitForReport(JSGlobalObject* globalObject, CallFrame*)
2036 {
2037     VM&amp; vm = globalObject-&gt;vm();
2038 
2039     String string;
2040     {
2041         ReleaseHeapAccessScope releaseAccess(vm.heap);
2042         string = Workers::singleton().getReport();
2043     }
2044     if (!string)
2045         return JSValue::encode(jsNull());
2046 
2047     return JSValue::encode(jsString(vm, string));
2048 }
2049 
2050 EncodedJSValue JSC_HOST_CALL functionHeapCapacity(JSGlobalObject* globalObject, CallFrame*)
2051 {
2052     VM&amp; vm = globalObject-&gt;vm();
2053     return JSValue::encode(jsNumber(vm.heap.capacity()));
2054 }
2055 
2056 EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(JSGlobalObject* globalObject, CallFrame* callFrame)
2057 {
2058     VM&amp; vm = globalObject-&gt;vm();
2059     auto scope = DECLARE_THROW_SCOPE(vm);
2060 
2061     double sleepTimeMs = 0;
2062     if (callFrame-&gt;argumentCount() &gt;= 1) {
2063         sleepTimeMs = callFrame-&gt;argument(0).toNumber(globalObject);
2064         RETURN_IF_EXCEPTION(scope, encodedJSValue());
2065     }
2066 
2067     vm.heap.releaseAccess();
2068     if (sleepTimeMs)
2069         sleep(Seconds::fromMilliseconds(sleepTimeMs));
2070     vm.heap.acquireAccess();
2071     return JSValue::encode(jsUndefined());
2072 }
2073 
2074 EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(JSGlobalObject*, CallFrame*)
2075 {
2076     supportsRichSourceInfo = false;
2077     return JSValue::encode(jsUndefined());
2078 }
2079 
2080 EncodedJSValue JSC_HOST_CALL functionMallocInALoop(JSGlobalObject*, CallFrame*)
2081 {
2082     Vector&lt;void*&gt; ptrs;
2083     for (unsigned i = 0; i &lt; 5000; ++i)
2084         ptrs.append(fastMalloc(1024 * 2));
2085     for (void* ptr : ptrs)
2086         fastFree(ptr);
2087     return JSValue::encode(jsUndefined());
2088 }
2089 
2090 EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(JSGlobalObject*, CallFrame*)
2091 {
2092 #if ENABLE(JIT)
2093     return JSValue::encode(jsNumber(JIT::totalCompileTime().milliseconds()));
2094 #else
2095     return JSValue::encode(jsNumber(0));
2096 #endif
2097 }
2098 
2099 template&lt;typename ValueType&gt;
2100 typename std::enable_if&lt;!std::is_fundamental&lt;ValueType&gt;::value&gt;::type addOption(VM&amp;, JSObject*, const Identifier&amp;, ValueType) { }
2101 
2102 template&lt;typename ValueType&gt;
2103 typename std::enable_if&lt;std::is_fundamental&lt;ValueType&gt;::value&gt;::type addOption(VM&amp; vm, JSObject* optionsObject, const Identifier&amp; identifier, ValueType value)
2104 {
2105     optionsObject-&gt;putDirect(vm, identifier, JSValue(value));
2106 }
2107 
2108 EncodedJSValue JSC_HOST_CALL functionJSCOptions(JSGlobalObject* globalObject, CallFrame*)
2109 {
2110     VM&amp; vm = globalObject-&gt;vm();
2111     JSObject* optionsObject = constructEmptyObject(globalObject);
2112 #define READ_OPTION(type_, name_, defaultValue_, availability_, description_) \
2113     addOption(vm, optionsObject, Identifier::fromString(vm, #name_), Options::name_());
2114     FOR_EACH_JSC_OPTION(READ_OPTION)
2115 #undef READ_OPTION
2116     return JSValue::encode(optionsObject);
2117 }
2118 
2119 EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(JSGlobalObject*, CallFrame* callFrame)
2120 {
2121     if (callFrame-&gt;argumentCount() &lt; 1)
2122         return JSValue::encode(jsUndefined());
2123 
2124     CodeBlock* block = getSomeBaselineCodeBlockForFunction(callFrame-&gt;argument(0));
2125     if (!block)
2126         return JSValue::encode(jsNumber(0));
2127 
2128     return JSValue::encode(jsNumber(block-&gt;reoptimizationRetryCounter()));
2129 }
2130 
2131 EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(JSGlobalObject* globalObject, CallFrame* callFrame)
2132 {
2133     VM&amp; vm = globalObject-&gt;vm();
2134     auto scope = DECLARE_THROW_SCOPE(vm);
2135 
2136     if (callFrame-&gt;argumentCount() &lt; 1)
2137         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Not enough arguments&quot;_s)));
2138 
2139     JSArrayBuffer* buffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, callFrame-&gt;argument(0));
2140     if (!buffer)
2141         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Expected an array buffer&quot;_s)));
2142 
2143     ArrayBufferContents dummyContents;
2144     buffer-&gt;impl()-&gt;transferTo(vm, dummyContents);
2145 
2146     return JSValue::encode(jsUndefined());
2147 }
2148 
2149 EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(JSGlobalObject* globalObject, CallFrame*)
2150 {
2151     VM&amp; vm = globalObject-&gt;vm();
2152     vm.setFailNextNewCodeBlock();
2153     return JSValue::encode(jsUndefined());
2154 }
2155 
2156 EncodedJSValue JSC_HOST_CALL functionQuit(JSGlobalObject* globalObject, CallFrame*)
2157 {
2158     VM&amp; vm = globalObject-&gt;vm();
2159     vm.codeCache()-&gt;write(vm);
2160 
2161     jscExit(EXIT_SUCCESS);
2162 
2163 #if COMPILER(MSVC)
2164     // Without this, Visual Studio will complain that this method does not return a value.
2165     return JSValue::encode(jsUndefined());
2166 #endif
2167 }
2168 
2169 EncodedJSValue JSC_HOST_CALL functionFalse(JSGlobalObject*, CallFrame*) { return JSValue::encode(jsBoolean(false)); }
2170 
2171 EncodedJSValue JSC_HOST_CALL functionUndefined1(JSGlobalObject*, CallFrame*) { return JSValue::encode(jsUndefined()); }
2172 EncodedJSValue JSC_HOST_CALL functionUndefined2(JSGlobalObject*, CallFrame*) { return JSValue::encode(jsUndefined()); }
2173 EncodedJSValue JSC_HOST_CALL functionIsInt32(JSGlobalObject*, CallFrame* callFrame)
2174 {
2175     for (size_t i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {
2176         if (!callFrame-&gt;argument(i).isInt32())
2177             return JSValue::encode(jsBoolean(false));
2178     }
2179     return JSValue::encode(jsBoolean(true));
2180 }
2181 
2182 EncodedJSValue JSC_HOST_CALL functionIsPureNaN(JSGlobalObject*, CallFrame* callFrame)
2183 {
2184     for (size_t i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {
2185         JSValue value = callFrame-&gt;argument(i);
2186         if (!value.isNumber())
2187             return JSValue::encode(jsBoolean(false));
2188         double number = value.asNumber();
2189         if (!std::isnan(number))
2190             return JSValue::encode(jsBoolean(false));
2191         if (isImpureNaN(number))
2192             return JSValue::encode(jsBoolean(false));
2193     }
2194     return JSValue::encode(jsBoolean(true));
2195 }
2196 
2197 EncodedJSValue JSC_HOST_CALL functionIdentity(JSGlobalObject*, CallFrame* callFrame) { return JSValue::encode(callFrame-&gt;argument(0)); }
2198 
2199 EncodedJSValue JSC_HOST_CALL functionEffectful42(JSGlobalObject*, CallFrame*)
2200 {
2201     return JSValue::encode(jsNumber(42));
2202 }
2203 
2204 EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(JSGlobalObject* globalObject, CallFrame*)
2205 {
2206     VM&amp; vm = globalObject-&gt;vm();
2207     return JSValue::encode(Masquerader::create(vm, globalObject));
2208 }
2209 
2210 EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(JSGlobalObject* globalObject, CallFrame* callFrame)
2211 {
2212     JSValue value = callFrame-&gt;argument(0);
2213     if (value.isObject())
2214         return JSValue::encode(jsBoolean(asObject(value)-&gt;hasCustomProperties(globalObject-&gt;vm())));
2215     return JSValue::encode(jsBoolean(false));
2216 }
2217 
2218 EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(JSGlobalObject* globalObject, CallFrame*)
2219 {
2220     VM&amp; vm = globalObject-&gt;vm();
2221     vm.dumpTypeProfilerData();
2222     return JSValue::encode(jsUndefined());
2223 }
2224 
2225 EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(JSGlobalObject* globalObject, CallFrame*)
2226 {
2227     VM&amp; vm = globalObject-&gt;vm();
2228     vm.drainMicrotasks();
2229     return JSValue::encode(jsUndefined());
2230 }
2231 
2232 EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(JSGlobalObject* globalObject, CallFrame*)
2233 {
2234     VM&amp; vm = globalObject-&gt;vm();
2235     vm.finalizeSynchronousJSExecution();
2236     return JSValue::encode(jsUndefined());
2237 }
2238 
2239 EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(JSGlobalObject*, CallFrame*)
2240 {
2241 #if USE(JSVALUE64)
2242     return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
2243 #else
2244     return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
2245 #endif
2246 }
2247 
2248 EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(JSGlobalObject* globalObject, CallFrame*)
2249 {
2250     VM&amp; vm = globalObject-&gt;vm();
2251     return JSValue::encode(GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;()));
2252 }
2253 
2254 EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(JSGlobalObject* globalObject, CallFrame* callFrame)
2255 {
2256     VM&amp; vm = globalObject-&gt;vm();
2257     auto scope = DECLARE_THROW_SCOPE(vm);
2258 
2259     String source = callFrame-&gt;argument(0).toWTFString(globalObject);
2260     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2261 
2262     StopWatch stopWatch;
2263     stopWatch.start();
2264 
2265     ParserError error;
2266     bool validSyntax = checkModuleSyntax(globalObject, jscSource(source, { }, URL(), TextPosition(), SourceProviderSourceType::Module), error);
2267     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2268     stopWatch.stop();
2269 
2270     if (!validSyntax)
2271         throwException(globalObject, scope, jsNontrivialString(vm, toString(&quot;SyntaxError: &quot;, error.message(), &quot;:&quot;, error.line())));
2272     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
2273 }
2274 
2275 EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(JSGlobalObject*, CallFrame*)
2276 {
2277 #if ENABLE(SAMPLING_PROFILER)
2278     return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
2279 #else
2280     return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
2281 #endif
2282 }
2283 
2284 EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(JSGlobalObject* globalObject, CallFrame*)
2285 {
2286     VM&amp; vm = globalObject-&gt;vm();
2287     JSLockHolder lock(vm);
2288     auto scope = DECLARE_THROW_SCOPE(vm);
2289 
2290     HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler());
2291     snapshotBuilder.buildSnapshot();
2292 
2293     String jsonString = snapshotBuilder.json();
2294     EncodedJSValue result = JSValue::encode(JSONParse(globalObject, jsonString));
2295     scope.releaseAssertNoException();
2296     return result;
2297 }
2298 
2299 EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(JSGlobalObject* globalObject, CallFrame*)
2300 {
2301     VM&amp; vm = globalObject-&gt;vm();
2302     JSLockHolder lock(vm);
2303     auto scope = DECLARE_THROW_SCOPE(vm);
2304     String jsonString;
2305     {
2306         DeferGCForAWhile deferGC(vm.heap); // Prevent concurrent GC from interfering with the full GC that the snapshot does.
2307 
2308         HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler(), HeapSnapshotBuilder::SnapshotType::GCDebuggingSnapshot);
2309         snapshotBuilder.buildSnapshot();
2310 
2311         jsonString = snapshotBuilder.json();
2312     }
2313     scope.releaseAssertNoException();
2314     return JSValue::encode(jsString(vm, jsonString));
2315 }
2316 
2317 EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(JSGlobalObject*, CallFrame*)
2318 {
2319     resetSuperSamplerState();
2320     return JSValue::encode(jsUndefined());
2321 }
2322 
2323 EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(JSGlobalObject* globalObject, CallFrame* callFrame)
2324 {
2325     VM&amp; vm = globalObject-&gt;vm();
2326     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {
2327         if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;argument(i)))
2328             object-&gt;ensureArrayStorage(vm);
2329     }
2330     return JSValue::encode(jsUndefined());
2331 }
2332 
2333 #if ENABLE(SAMPLING_PROFILER)
2334 EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(JSGlobalObject* globalObject, CallFrame*)
2335 {
2336     VM&amp; vm = globalObject-&gt;vm();
2337     SamplingProfiler&amp; samplingProfiler = vm.ensureSamplingProfiler(WTF::Stopwatch::create());
2338     samplingProfiler.noticeCurrentThreadAsJSCExecutionThread();
2339     samplingProfiler.start();
2340     return JSValue::encode(jsUndefined());
2341 }
2342 
2343 EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(JSGlobalObject* globalObject, CallFrame*)
2344 {
2345     VM&amp; vm = globalObject-&gt;vm();
2346     auto scope = DECLARE_THROW_SCOPE(vm);
2347 
2348     if (!vm.samplingProfiler())
2349         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Sampling profiler was never started&quot;_s)));
2350 
2351     String jsonString = vm.samplingProfiler()-&gt;stackTracesAsJSON();
2352     EncodedJSValue result = JSValue::encode(JSONParse(globalObject, jsonString));
2353     scope.releaseAssertNoException();
2354     return result;
2355 }
2356 #endif // ENABLE(SAMPLING_PROFILER)
2357 
2358 EncodedJSValue JSC_HOST_CALL functionMaxArguments(JSGlobalObject*, CallFrame*)
2359 {
2360     return JSValue::encode(jsNumber(JSC::maxArguments));
2361 }
2362 
2363 EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(JSGlobalObject* globalObject, CallFrame* callFrame)
2364 {
2365     VM&amp; vm = globalObject-&gt;vm();
2366     auto scope = DECLARE_THROW_SCOPE(vm);
2367 
2368     JSValue numberOfAsyncPasses = callFrame-&gt;argument(0);
2369     if (!numberOfAsyncPasses.isUInt32())
2370         return throwVMError(globalObject, scope, &quot;Expected first argument to be a uint32&quot;_s);
2371 
2372     asyncTestExpectedPasses += numberOfAsyncPasses.asUInt32();
2373     return encodedJSUndefined();
2374 }
2375 
2376 EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(JSGlobalObject*, CallFrame*)
2377 {
2378     asyncTestPasses++;
2379     return encodedJSUndefined();
2380 }
2381 
2382 #if ENABLE(WEBASSEMBLY)
2383 
2384 static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(JSGlobalObject* globalObject, CallFrame* callFrame)
2385 {
2386     VM&amp; vm = globalObject-&gt;vm();
2387     auto scope = DECLARE_THROW_SCOPE(vm);
2388 
2389     if (!Wasm::isSupported())
2390         return throwVMTypeError(globalObject, scope, &quot;WebAssemblyMemoryMode should only be called if the useWebAssembly option is set&quot;_s);
2391 
2392     if (JSObject* object = callFrame-&gt;argument(0).getObject()) {
2393         if (auto* memory = jsDynamicCast&lt;JSWebAssemblyMemory*&gt;(vm, object))
2394             return JSValue::encode(jsString(vm, makeString(memory-&gt;memory().mode())));
2395         if (auto* instance = jsDynamicCast&lt;JSWebAssemblyInstance*&gt;(vm, object))
2396             return JSValue::encode(jsString(vm, makeString(instance-&gt;memoryMode())));
2397     }
2398 
2399     return throwVMTypeError(globalObject, scope, &quot;WebAssemblyMemoryMode expects either a WebAssembly.Memory or WebAssembly.Instance&quot;_s);
2400 }
2401 
2402 #endif // ENABLE(WEBASSEMBLY)
2403 
2404 EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(JSGlobalObject* globalObject, CallFrame* callFrame)
2405 {
2406     VM&amp; vm = globalObject-&gt;vm();
2407     JSObject* object = callFrame-&gt;argument(0).getObject();
2408     auto scope = DECLARE_THROW_SCOPE(vm);
2409 
2410     if (!object || !object-&gt;isFunction(vm))
2411         return throwVMTypeError(globalObject, scope);
2412 
2413     globalObject-&gt;setUnhandledRejectionCallback(vm, object);
2414     return JSValue::encode(jsUndefined());
2415 }
2416 
2417 // Use SEH for Release builds only to get rid of the crash report dialog
2418 // (luckily the same tests fail in Release and Debug builds so far). Need to
2419 // be in a separate main function because the jscmain function requires object
2420 // unwinding.
2421 
2422 #if COMPILER(MSVC) &amp;&amp; !defined(_DEBUG)
2423 #define TRY       __try {
2424 #define EXCEPT(x) } __except (EXCEPTION_EXECUTE_HANDLER) { x; }
2425 #else
2426 #define TRY
2427 #define EXCEPT(x)
2428 #endif
2429 
2430 int jscmain(int argc, char** argv);
2431 
2432 static double s_desiredTimeout;
2433 static double s_timeoutMultiplier = 1.0;
2434 static Seconds s_timeoutDuration;
2435 static Seconds s_maxAllowedCPUTime;
2436 static VM* s_vm;
2437 
2438 static void startTimeoutTimer(Seconds duration)
2439 {
2440     Thread::create(&quot;jsc Timeout Thread&quot;, [=] () {
2441         sleep(duration);
2442         VMInspector::forEachVM([&amp;] (VM&amp; vm) -&gt; VMInspector::FunctorStatus {
2443             if (&amp;vm != s_vm)
2444                 return VMInspector::FunctorStatus::Continue;
2445             vm.notifyNeedShellTimeoutCheck();
2446             return VMInspector::FunctorStatus::Done;
2447         });
2448     });
2449 }
2450 
2451 static void timeoutCheckCallback(VM&amp; vm)
2452 {
2453     RELEASE_ASSERT(&amp;vm == s_vm);
2454     auto cpuTime = CPUTime::forCurrentThread();
2455     if (cpuTime &gt;= s_maxAllowedCPUTime) {
2456         dataLog(&quot;Timed out after &quot;, s_timeoutDuration, &quot; seconds!\n&quot;);
2457         CRASH();
2458     }
2459     auto remainingTime = s_maxAllowedCPUTime - cpuTime;
2460     startTimeoutTimer(remainingTime);
2461 }
2462 
2463 static void initializeTimeoutIfNeeded()
2464 {
2465     if (char* timeoutString = getenv(&quot;JSCTEST_timeout&quot;)) {
2466         if (sscanf(timeoutString, &quot;%lf&quot;, &amp;s_desiredTimeout) != 1) {
2467             dataLog(&quot;WARNING: timeout string is malformed, got &quot;, timeoutString,
2468                 &quot; but expected a number. Not using a timeout.\n&quot;);
2469         } else
2470             g_jscConfig.shellTimeoutCheckCallback = timeoutCheckCallback;
2471     }
2472 }
2473 
2474 static void startTimeoutThreadIfNeeded(VM&amp; vm)
2475 {
2476     if (!g_jscConfig.shellTimeoutCheckCallback)
2477         return;
2478 
2479     s_vm = &amp;vm;
2480     s_timeoutDuration = Seconds(s_desiredTimeout * s_timeoutMultiplier);
2481     s_maxAllowedCPUTime = CPUTime::forCurrentThread() + s_timeoutDuration;
2482     Seconds timeoutDuration(s_desiredTimeout * s_timeoutMultiplier);
2483     startTimeoutTimer(timeoutDuration);
2484 }
2485 
2486 int main(int argc, char** argv)
2487 {
2488 #if OS(DARWIN) &amp;&amp; CPU(ARM_THUMB2)
2489     // Enabled IEEE754 denormal support.
2490     fenv_t env;
2491     fegetenv( &amp;env );
2492     env.__fpscr &amp;= ~0x01000000u;
2493     fesetenv( &amp;env );
2494 #endif
2495 
2496 #if OS(WINDOWS)
2497     // Cygwin calls ::SetErrorMode(SEM_FAILCRITICALERRORS), which we will inherit. This is bad for
2498     // testing/debugging, as it causes the post-mortem debugger not to be invoked. We reset the
2499     // error mode here to work around Cygwin&#39;s behavior. See &lt;http://webkit.org/b/55222&gt;.
2500     ::SetErrorMode(0);
2501 
2502     _setmode(_fileno(stdout), _O_BINARY);
2503     _setmode(_fileno(stderr), _O_BINARY);
2504 
2505 #if defined(_DEBUG)
2506     _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
2507     _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
2508     _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);
2509     _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);
2510     _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);
2511     _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);
2512 #endif
2513 
2514     timeBeginPeriod(1);
2515 #endif
2516 
2517 #if PLATFORM(GTK)
2518     if (!setlocale(LC_ALL, &quot;&quot;))
2519         WTFLogAlways(&quot;Locale not supported by C library.\n\tUsing the fallback &#39;C&#39; locale.&quot;);
2520 #endif
2521 
2522     // Need to initialize WTF threading before we start any threads. Cannot initialize JSC
2523     // threading yet, since that would do somethings that we&#39;d like to defer until after we
2524     // have a chance to parse options.
2525     WTF::initializeThreading();
2526 
2527 #if PLATFORM(IOS_FAMILY)
2528     Options::crashIfCantAllocateJITMemory() = true;
2529 #endif
2530 
2531     // We can&#39;t use destructors in the following code because it uses Windows
2532     // Structured Exception Handling
2533     int res = 0;
2534     TRY
2535         res = jscmain(argc, argv);
2536     EXCEPT(res = 3)
2537     finalizeStatsAtEndOfTesting();
2538 
2539     jscExit(res);
2540 }
2541 
2542 static void dumpException(GlobalObject* globalObject, JSValue exception)
2543 {
2544     VM&amp; vm = globalObject-&gt;vm();
2545     auto scope = DECLARE_CATCH_SCOPE(vm);
2546 
2547 #define CHECK_EXCEPTION() do { \
2548         if (scope.exception()) { \
2549             scope.clearException(); \
2550             return; \
2551         } \
2552     } while (false)
2553 
2554     auto exceptionString = exception.toWTFString(globalObject);
2555     CHECK_EXCEPTION();
2556     Expected&lt;CString, UTF8ConversionError&gt; expectedCString = exceptionString.tryGetUtf8();
2557     if (expectedCString)
2558         printf(&quot;Exception: %s\n&quot;, expectedCString.value().data());
2559     else
2560         printf(&quot;Exception: &lt;out of memory while extracting exception string&gt;\n&quot;);
2561 
2562     Identifier nameID = Identifier::fromString(vm, &quot;name&quot;);
2563     CHECK_EXCEPTION();
2564     Identifier fileNameID = Identifier::fromString(vm, &quot;sourceURL&quot;);
2565     CHECK_EXCEPTION();
2566     Identifier lineNumberID = Identifier::fromString(vm, &quot;line&quot;);
2567     CHECK_EXCEPTION();
2568     Identifier stackID = Identifier::fromString(vm, &quot;stack&quot;);
2569     CHECK_EXCEPTION();
2570 
2571     JSValue nameValue = exception.get(globalObject, nameID);
2572     CHECK_EXCEPTION();
2573     JSValue fileNameValue = exception.get(globalObject, fileNameID);
2574     CHECK_EXCEPTION();
2575     JSValue lineNumberValue = exception.get(globalObject, lineNumberID);
2576     CHECK_EXCEPTION();
2577     JSValue stackValue = exception.get(globalObject, stackID);
2578     CHECK_EXCEPTION();
2579 
2580     auto nameString = nameValue.toWTFString(globalObject);
2581     CHECK_EXCEPTION();
2582 
2583     if (nameString == &quot;SyntaxError&quot; &amp;&amp; (!fileNameValue.isUndefinedOrNull() || !lineNumberValue.isUndefinedOrNull())) {
2584         auto fileNameString = fileNameValue.toWTFString(globalObject);
2585         CHECK_EXCEPTION();
2586         auto lineNumberString = lineNumberValue.toWTFString(globalObject);
2587         CHECK_EXCEPTION();
2588         printf(&quot;at %s:%s\n&quot;, fileNameString.utf8().data(), lineNumberString.utf8().data());
2589     }
2590 
2591     if (!stackValue.isUndefinedOrNull()) {
2592         auto stackString = stackValue.toWTFString(globalObject);
2593         CHECK_EXCEPTION();
2594         if (stackString.length())
2595             printf(&quot;%s\n&quot;, stackString.utf8().data());
2596     }
2597 
2598 #undef CHECK_EXCEPTION
2599 }
2600 
2601 static bool checkUncaughtException(VM&amp; vm, GlobalObject* globalObject, JSValue exception, CommandLine&amp; options)
2602 {
2603     const String&amp; expectedExceptionName = options.m_uncaughtExceptionName;
2604     auto scope = DECLARE_CATCH_SCOPE(vm);
2605     scope.clearException();
2606     if (!exception) {
2607         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but none was thrown\n&quot;, expectedExceptionName.utf8().data());
2608         return false;
2609     }
2610 
2611     JSValue exceptionClass = globalObject-&gt;get(globalObject, Identifier::fromString(vm, expectedExceptionName));
2612     if (!exceptionClass.isObject() || scope.exception()) {
2613         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class is not defined\n&quot;, expectedExceptionName.utf8().data());
2614         return false;
2615     }
2616 
2617     bool isInstanceOfExpectedException = jsCast&lt;JSObject*&gt;(exceptionClass)-&gt;hasInstance(globalObject, exception);
2618     if (scope.exception()) {
2619         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class fails performing hasInstance\n&quot;, expectedExceptionName.utf8().data());
2620         return false;
2621     }
2622     if (isInstanceOfExpectedException) {
2623         if (options.m_alwaysDumpUncaughtException)
2624             dumpException(globalObject, exception);
2625         return true;
2626     }
2627 
2628     printf(&quot;Expected uncaught exception with name &#39;%s&#39; but exception value is not instance of this exception class\n&quot;, expectedExceptionName.utf8().data());
2629     dumpException(globalObject, exception);
2630     return false;
2631 }
2632 
2633 static void checkException(GlobalObject* globalObject, bool isLastFile, bool hasException, JSValue value, CommandLine&amp; options, bool&amp; success)
2634 {
2635     VM&amp; vm = globalObject-&gt;vm();
2636 
2637     if (options.m_treatWatchdogExceptionAsSuccess &amp;&amp; value.inherits&lt;TerminatedExecutionError&gt;(vm)) {
2638         ASSERT(hasException);
2639         return;
2640     }
2641 
2642     if (!options.m_uncaughtExceptionName || !isLastFile) {
2643         success = success &amp;&amp; !hasException;
2644         if (options.m_dump &amp;&amp; !hasException)
2645             printf(&quot;End: %s\n&quot;, value.toWTFString(globalObject).utf8().data());
2646         if (hasException)
2647             dumpException(globalObject, value);
2648     } else
2649         success = success &amp;&amp; checkUncaughtException(vm, globalObject, (hasException) ? value : JSValue(), options);
2650 }
2651 
2652 static void runWithOptions(GlobalObject* globalObject, CommandLine&amp; options, bool&amp; success)
2653 {
2654     Vector&lt;Script&gt;&amp; scripts = options.m_scripts;
2655     String fileName;
2656     Vector&lt;char&gt; scriptBuffer;
2657 
2658     VM&amp; vm = globalObject-&gt;vm();
2659     auto scope = DECLARE_CATCH_SCOPE(vm);
2660 
2661 #if ENABLE(SAMPLING_FLAGS)
2662     SamplingFlags::start();
2663 #endif
2664 
2665     for (size_t i = 0; i &lt; scripts.size(); i++) {
2666         JSInternalPromise* promise = nullptr;
2667         bool isModule = options.m_module || scripts[i].scriptType == Script::ScriptType::Module;
2668         if (scripts[i].codeSource == Script::CodeSource::File) {
2669             fileName = scripts[i].argument;
2670             if (scripts[i].strictMode == Script::StrictMode::Strict)
2671                 scriptBuffer.append(&quot;\&quot;use strict\&quot;;\n&quot;, strlen(&quot;\&quot;use strict\&quot;;\n&quot;));
2672 
2673             if (isModule) {
2674                 promise = loadAndEvaluateModule(globalObject, fileName, jsUndefined(), jsUndefined());
2675                 scope.releaseAssertNoException();
2676             } else {
2677                 if (!fetchScriptFromLocalFileSystem(fileName, scriptBuffer)) {
2678                     success = false; // fail early so we can catch missing files
2679                     return;
2680                 }
2681             }
2682         } else {
2683             size_t commandLineLength = strlen(scripts[i].argument);
2684             scriptBuffer.resize(commandLineLength);
2685             std::copy(scripts[i].argument, scripts[i].argument + commandLineLength, scriptBuffer.begin());
2686             fileName = &quot;[Command Line]&quot;_s;
2687         }
2688 
2689         bool isLastFile = i == scripts.size() - 1;
2690         if (isModule) {
2691             if (!promise) {
2692                 // FIXME: This should use an absolute file URL https://bugs.webkit.org/show_bug.cgi?id=193077
2693                 promise = loadAndEvaluateModule(globalObject, jscSource(stringFromUTF(scriptBuffer), SourceOrigin { absolutePath(fileName) }, URL({ }, fileName), TextPosition(), SourceProviderSourceType::Module), jsUndefined());
2694             }
2695             scope.clearException();
2696 
2697             JSFunction* fulfillHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&amp;success, &amp;options, isLastFile](JSGlobalObject* globalObject, CallFrame* callFrame) {
2698                 checkException(jsCast&lt;GlobalObject*&gt;(globalObject), isLastFile, false, callFrame-&gt;argument(0), options, success);
2699                 return JSValue::encode(jsUndefined());
2700             });
2701 
2702             JSFunction* rejectHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&amp;success, &amp;options, isLastFile](JSGlobalObject* globalObject, CallFrame* callFrame) {
2703                 checkException(jsCast&lt;GlobalObject*&gt;(globalObject), isLastFile, true, callFrame-&gt;argument(0), options, success);
2704                 return JSValue::encode(jsUndefined());
2705             });
2706 
2707             promise-&gt;then(globalObject, fulfillHandler, rejectHandler);
2708             scope.releaseAssertNoException();
2709             vm.drainMicrotasks();
2710         } else {
2711             NakedPtr&lt;Exception&gt; evaluationException;
2712             JSValue returnValue = evaluate(globalObject, jscSource(scriptBuffer, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);
2713             scope.assertNoException();
2714             if (evaluationException)
2715                 returnValue = evaluationException-&gt;value();
2716             checkException(globalObject, isLastFile, evaluationException, returnValue, options, success);
2717         }
2718 
2719         scriptBuffer.clear();
2720         scope.clearException();
2721     }
2722 
2723 #if ENABLE(REGEXP_TRACING)
2724     vm.dumpRegExpTrace();
2725 #endif
2726 }
2727 
2728 #define RUNNING_FROM_XCODE 0
2729 
2730 static void runInteractive(GlobalObject* globalObject)
2731 {
2732     VM&amp; vm = globalObject-&gt;vm();
2733     auto scope = DECLARE_CATCH_SCOPE(vm);
2734 
2735     Optional&lt;DirectoryName&gt; directoryName = currentWorkingDirectory();
2736     if (!directoryName)
2737         return;
2738     SourceOrigin sourceOrigin(resolvePath(directoryName.value(), ModuleName(&quot;interpreter&quot;)));
2739 
2740     bool shouldQuit = false;
2741     while (!shouldQuit) {
2742 #if HAVE(READLINE) &amp;&amp; !RUNNING_FROM_XCODE
2743         ParserError error;
2744         String source;
2745         do {
2746             error = ParserError();
2747             char* line = readline(source.isEmpty() ? interactivePrompt : &quot;... &quot;);
2748             shouldQuit = !line;
2749             if (!line)
2750                 break;
2751             source = source + String::fromUTF8(line);
2752             source = source + &#39;\n&#39;;
2753             checkSyntax(vm, jscSource(source, sourceOrigin), error);
2754             if (!line[0]) {
2755                 free(line);
2756                 break;
2757             }
2758             add_history(line);
2759             free(line);
2760         } while (error.syntaxErrorType() == ParserError::SyntaxErrorRecoverable);
2761 
2762         if (error.isValid()) {
2763             printf(&quot;%s:%d\n&quot;, error.message().utf8().data(), error.line());
2764             continue;
2765         }
2766 
2767 
2768         NakedPtr&lt;Exception&gt; evaluationException;
2769         JSValue returnValue = evaluate(globalObject, jscSource(source, sourceOrigin), JSValue(), evaluationException);
2770 #else
2771         printf(&quot;%s&quot;, interactivePrompt);
2772         Vector&lt;char, 256&gt; line;
2773         int c;
2774         while ((c = getchar()) != EOF) {
2775             // FIXME: Should we also break on \r?
2776             if (c == &#39;\n&#39;)
2777                 break;
2778             line.append(c);
2779         }
2780         if (line.isEmpty())
2781             break;
2782 
2783         NakedPtr&lt;Exception&gt; evaluationException;
2784         JSValue returnValue = evaluate(globalObject, jscSource(line, sourceOrigin, sourceOrigin.string()), JSValue(), evaluationException);
2785 #endif
2786         if (evaluationException)
2787             printf(&quot;Exception: %s\n&quot;, evaluationException-&gt;value().toWTFString(globalObject).utf8().data());
2788         else
2789             printf(&quot;%s\n&quot;, returnValue.toWTFString(globalObject).utf8().data());
2790 
2791         scope.clearException();
2792         vm.drainMicrotasks();
2793     }
2794     printf(&quot;\n&quot;);
2795 }
2796 
2797 static NO_RETURN void printUsageStatement(bool help = false)
2798 {
2799     fprintf(stderr, &quot;Usage: jsc [options] [files] [-- arguments]\n&quot;);
2800     fprintf(stderr, &quot;  -d         Dumps bytecode (debug builds only)\n&quot;);
2801     fprintf(stderr, &quot;  -e         Evaluate argument as script code\n&quot;);
2802     fprintf(stderr, &quot;  -f         Specifies a source file (deprecated)\n&quot;);
2803     fprintf(stderr, &quot;  -h|--help  Prints this help message\n&quot;);
2804     fprintf(stderr, &quot;  -i         Enables interactive mode (default if no files are specified)\n&quot;);
2805     fprintf(stderr, &quot;  -m         Execute as a module\n&quot;);
2806 #if HAVE(SIGNAL_H)
2807     fprintf(stderr, &quot;  -s         Installs signal handlers that exit on a crash (Unix platforms only)\n&quot;);
2808 #endif
2809     fprintf(stderr, &quot;  -p &lt;file&gt;  Outputs profiling data to a file\n&quot;);
2810     fprintf(stderr, &quot;  -x         Output exit code before terminating\n&quot;);
2811     fprintf(stderr, &quot;\n&quot;);
2812     fprintf(stderr, &quot;  --sample                   Collects and outputs sampling profiler data\n&quot;);
2813     fprintf(stderr, &quot;  --test262-async            Check that some script calls the print function with the string &#39;Test262:AsyncTestComplete&#39;\n&quot;);
2814     fprintf(stderr, &quot;  --strict-file=&lt;file&gt;       Parse the given file as if it were in strict mode (this option may be passed more than once)\n&quot;);
2815     fprintf(stderr, &quot;  --module-file=&lt;file&gt;       Parse and evaluate the given file as module (this option may be passed more than once)\n&quot;);
2816     fprintf(stderr, &quot;  --exception=&lt;name&gt;         Check the last script exits with an uncaught exception with the specified name\n&quot;);
2817     fprintf(stderr, &quot;  --watchdog-exception-ok    Uncaught watchdog exceptions exit with success\n&quot;);
2818     fprintf(stderr, &quot;  --dumpException            Dump uncaught exception text\n&quot;);
2819     fprintf(stderr, &quot;  --footprint                Dump memory footprint after done executing\n&quot;);
2820     fprintf(stderr, &quot;  --options                  Dumps all JSC VM options and exits\n&quot;);
2821     fprintf(stderr, &quot;  --dumpOptions              Dumps all non-default JSC VM options before continuing\n&quot;);
2822     fprintf(stderr, &quot;  --&lt;jsc VM option&gt;=&lt;value&gt;  Sets the specified JSC VM option\n&quot;);
2823     fprintf(stderr, &quot;  --destroy-vm               Destroy VM before exiting\n&quot;);
2824     fprintf(stderr, &quot;\n&quot;);
2825     fprintf(stderr, &quot;Files with a .mjs extension will always be evaluated as modules.\n&quot;);
2826     fprintf(stderr, &quot;\n&quot;);
2827 
2828     jscExit(help ? EXIT_SUCCESS : EXIT_FAILURE);
2829 }
2830 
2831 static bool isMJSFile(char *filename)
2832 {
2833     filename = strrchr(filename, &#39;.&#39;);
2834 
2835     if (filename)
2836         return !strcmp(filename, &quot;.mjs&quot;);
2837 
2838     return false;
2839 }
2840 
2841 void CommandLine::parseArguments(int argc, char** argv)
2842 {
2843     Options::initialize();
2844 
2845     if (Options::dumpOptions()) {
2846         printf(&quot;Command line:&quot;);
2847 #if PLATFORM(COCOA)
2848         for (char** envp = *_NSGetEnviron(); *envp; envp++) {
2849             const char* env = *envp;
2850             if (!strncmp(&quot;JSC_&quot;, env, 4))
2851                 printf(&quot; %s&quot;, env);
2852         }
2853 #endif // PLATFORM(COCOA)
2854         for (int i = 0; i &lt; argc; ++i)
2855             printf(&quot; %s&quot;, argv[i]);
2856         printf(&quot;\n&quot;);
2857     }
2858 
2859     int i = 1;
2860     JSC::Options::DumpLevel dumpOptionsLevel = JSC::Options::DumpLevel::None;
2861     bool needToExit = false;
2862 
2863     bool hasBadJSCOptions = false;
2864     for (; i &lt; argc; ++i) {
2865         const char* arg = argv[i];
2866         if (!strcmp(arg, &quot;-f&quot;)) {
2867             if (++i == argc)
2868                 printUsageStatement();
2869             m_scripts.append(Script(Script::StrictMode::Sloppy, Script::CodeSource::File, Script::ScriptType::Script, argv[i]));
2870             continue;
2871         }
2872         if (!strcmp(arg, &quot;-e&quot;)) {
2873             if (++i == argc)
2874                 printUsageStatement();
2875             m_scripts.append(Script(Script::StrictMode::Sloppy, Script::CodeSource::CommandLine, Script::ScriptType::Script, argv[i]));
2876             continue;
2877         }
2878         if (!strcmp(arg, &quot;-i&quot;)) {
2879             m_interactive = true;
2880             continue;
2881         }
2882         if (!strcmp(arg, &quot;-d&quot;)) {
2883             m_dump = true;
2884             continue;
2885         }
2886         if (!strcmp(arg, &quot;-p&quot;)) {
2887             if (++i == argc)
2888                 printUsageStatement();
2889             m_profile = true;
2890             m_profilerOutput = argv[i];
2891             continue;
2892         }
2893         if (!strcmp(arg, &quot;-m&quot;)) {
2894             m_module = true;
2895             continue;
2896         }
2897         if (!strcmp(arg, &quot;-s&quot;)) {
2898 #if HAVE(SIGNAL_H)
2899             signal(SIGILL, _exit);
2900             signal(SIGFPE, _exit);
2901             signal(SIGBUS, _exit);
2902             signal(SIGSEGV, _exit);
2903 #endif
2904             continue;
2905         }
2906         if (!strcmp(arg, &quot;-x&quot;)) {
2907             m_exitCode = true;
2908             continue;
2909         }
2910         if (!strcmp(arg, &quot;--&quot;)) {
2911             ++i;
2912             break;
2913         }
2914         if (!strcmp(arg, &quot;-h&quot;) || !strcmp(arg, &quot;--help&quot;))
2915             printUsageStatement(true);
2916 
2917         if (!strcmp(arg, &quot;--options&quot;)) {
2918             dumpOptionsLevel = JSC::Options::DumpLevel::Verbose;
2919             needToExit = true;
2920             continue;
2921         }
2922         if (!strcmp(arg, &quot;--dumpOptions&quot;)) {
2923             dumpOptionsLevel = JSC::Options::DumpLevel::Overridden;
2924             continue;
2925         }
2926         if (!strcmp(arg, &quot;--sample&quot;)) {
2927             JSC::Options::useSamplingProfiler() = true;
2928             JSC::Options::collectSamplingProfilerDataForJSCShell() = true;
2929             m_dumpSamplingProfilerData = true;
2930             continue;
2931         }
2932         if (!strcmp(arg, &quot;--destroy-vm&quot;)) {
2933             m_destroyVM = true;
2934             continue;
2935         }
2936         if (!strcmp(arg, &quot;--disableOptionsFreezingForTesting&quot;)) {
2937             Config::disableFreezingForTesting();
2938             continue;
2939         }
2940 
2941         static const char* timeoutMultiplierOptStr = &quot;--timeoutMultiplier=&quot;;
2942         static const unsigned timeoutMultiplierOptStrLength = strlen(timeoutMultiplierOptStr);
2943         if (!strncmp(arg, timeoutMultiplierOptStr, timeoutMultiplierOptStrLength)) {
2944             const char* valueStr = &amp;arg[timeoutMultiplierOptStrLength];
2945             if (sscanf(valueStr, &quot;%lf&quot;, &amp;s_timeoutMultiplier) != 1)
2946                 dataLog(&quot;WARNING: --timeoutMultiplier=&quot;, valueStr, &quot; is invalid. Expects a numeric ratio.\n&quot;);
2947             continue;
2948         }
2949 
2950         if (!strcmp(arg, &quot;--test262-async&quot;)) {
2951             asyncTestExpectedPasses++;
2952             continue;
2953         }
2954 
2955         if (!strcmp(arg, &quot;--remote-debug&quot;)) {
2956             m_enableRemoteDebugging = true;
2957             continue;
2958         }
2959 
2960         static const unsigned strictFileStrLength = strlen(&quot;--strict-file=&quot;);
2961         if (!strncmp(arg, &quot;--strict-file=&quot;, strictFileStrLength)) {
2962             m_scripts.append(Script(Script::StrictMode::Strict, Script::CodeSource::File, Script::ScriptType::Script, argv[i] + strictFileStrLength));
2963             continue;
2964         }
2965 
2966         static const unsigned moduleFileStrLength = strlen(&quot;--module-file=&quot;);
2967         if (!strncmp(arg, &quot;--module-file=&quot;, moduleFileStrLength)) {
2968             m_scripts.append(Script(Script::StrictMode::Sloppy, Script::CodeSource::File, Script::ScriptType::Module, argv[i] + moduleFileStrLength));
2969             continue;
2970         }
2971 
2972         if (!strcmp(arg, &quot;--dumpException&quot;)) {
2973             m_alwaysDumpUncaughtException = true;
2974             continue;
2975         }
2976 
2977         if (!strcmp(arg, &quot;--footprint&quot;)) {
2978             m_dumpMemoryFootprint = true;
2979             continue;
2980         }
2981 
2982         static const unsigned exceptionStrLength = strlen(&quot;--exception=&quot;);
2983         if (!strncmp(arg, &quot;--exception=&quot;, exceptionStrLength)) {
2984             m_uncaughtExceptionName = String(arg + exceptionStrLength);
2985             continue;
2986         }
2987 
2988         if (!strcmp(arg, &quot;--watchdog-exception-ok&quot;)) {
2989             m_treatWatchdogExceptionAsSuccess = true;
2990             continue;
2991         }
2992 
2993         // See if the -- option is a JSC VM option.
2994         if (strstr(arg, &quot;--&quot;) == arg) {
2995             if (!JSC::Options::setOption(&amp;arg[2])) {
2996                 hasBadJSCOptions = true;
2997                 dataLog(&quot;ERROR: invalid option: &quot;, arg, &quot;\n&quot;);
2998             }
2999             continue;
3000         }
3001 
3002         // This arg is not recognized by the VM nor by jsc. Pass it on to the
3003         // script.
3004         Script::ScriptType scriptType = isMJSFile(argv[i]) ? Script::ScriptType::Module : Script::ScriptType::Script;
3005         m_scripts.append(Script(Script::StrictMode::Sloppy, Script::CodeSource::File, scriptType, argv[i]));
3006     }
3007 
3008     if (hasBadJSCOptions &amp;&amp; JSC::Options::validateOptions())
3009         CRASH();
3010 
3011     if (m_scripts.isEmpty())
3012         m_interactive = true;
3013 
3014     for (; i &lt; argc; ++i)
3015         m_arguments.append(argv[i]);
3016 
3017     if (dumpOptionsLevel != JSC::Options::DumpLevel::None) {
3018         const char* optionsTitle = (dumpOptionsLevel == JSC::Options::DumpLevel::Overridden)
3019             ? &quot;Modified JSC runtime options:&quot;
3020             : &quot;All JSC runtime options:&quot;;
3021         JSC::Options::dumpAllOptions(stderr, dumpOptionsLevel, optionsTitle);
3022     }
3023     JSC::Options::ensureOptionsAreCoherent();
3024     if (needToExit)
3025         jscExit(EXIT_SUCCESS);
3026 }
3027 
3028 template&lt;typename Func&gt;
3029 int runJSC(const CommandLine&amp; options, bool isWorker, const Func&amp; func)
3030 {
3031     Worker worker(Workers::singleton());
3032 
3033     VM&amp; vm = VM::create(LargeHeap).leakRef();
3034     int result;
3035     bool success = true;
3036     GlobalObject* globalObject = nullptr;
3037     {
3038         JSLockHolder locker(vm);
3039 
3040         startTimeoutThreadIfNeeded(vm);
3041         if (options.m_profile &amp;&amp; !vm.m_perBytecodeProfiler)
3042             vm.m_perBytecodeProfiler = makeUnique&lt;Profiler::Database&gt;(vm);
3043 
3044         globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), options.m_arguments);
3045         globalObject-&gt;setRemoteDebuggingEnabled(options.m_enableRemoteDebugging);
3046         func(vm, globalObject, success);
3047         vm.drainMicrotasks();
3048     }
3049     vm.promiseTimer-&gt;runRunLoop();
3050     {
3051         JSLockHolder locker(vm);
3052         if (options.m_interactive &amp;&amp; success)
3053             runInteractive(globalObject);
3054     }
3055 
3056     result = success &amp;&amp; (asyncTestExpectedPasses == asyncTestPasses) ? 0 : 3;
3057 
3058     if (options.m_exitCode) {
3059         printf(&quot;jsc exiting %d&quot;, result);
3060         if (asyncTestExpectedPasses != asyncTestPasses)
3061             printf(&quot; because expected: %d async test passes but got: %d async test passes&quot;, asyncTestExpectedPasses, asyncTestPasses);
3062         printf(&quot;\n&quot;);
3063     }
3064 
3065     if (options.m_profile) {
3066         JSLockHolder locker(vm);
3067         if (!vm.m_perBytecodeProfiler-&gt;save(options.m_profilerOutput.utf8().data()))
3068             fprintf(stderr, &quot;could not save profiler output.\n&quot;);
3069     }
3070 
3071 #if ENABLE(JIT)
3072     {
3073         JSLockHolder locker(vm);
3074         if (Options::useExceptionFuzz())
3075             printf(&quot;JSC EXCEPTION FUZZ: encountered %u checks.\n&quot;, numberOfExceptionFuzzChecks());
3076         bool fireAtEnabled =
3077         Options::fireExecutableAllocationFuzzAt() || Options::fireExecutableAllocationFuzzAtOrAfter();
3078         if (Options::useExecutableAllocationFuzz() &amp;&amp; (!fireAtEnabled || Options::verboseExecutableAllocationFuzz()))
3079             printf(&quot;JSC EXECUTABLE ALLOCATION FUZZ: encountered %u checks.\n&quot;, numberOfExecutableAllocationFuzzChecks());
3080         if (Options::useOSRExitFuzz()) {
3081             printf(&quot;JSC OSR EXIT FUZZ: encountered %u static checks.\n&quot;, numberOfStaticOSRExitFuzzChecks());
3082             printf(&quot;JSC OSR EXIT FUZZ: encountered %u dynamic checks.\n&quot;, numberOfOSRExitFuzzChecks());
3083         }
3084 
3085 
3086         auto compileTimeStats = JIT::compileTimeStats();
3087         Vector&lt;CString&gt; compileTimeKeys;
3088         for (auto&amp; entry : compileTimeStats)
3089             compileTimeKeys.append(entry.key);
3090         std::sort(compileTimeKeys.begin(), compileTimeKeys.end());
3091         for (const CString&amp; key : compileTimeKeys)
3092             printf(&quot;%40s: %.3lf ms\n&quot;, key.data(), compileTimeStats.get(key).milliseconds());
3093 
3094         if (Options::reportTotalPhaseTimes())
3095             logTotalPhaseTimes();
3096     }
3097 #endif
3098 
3099     if (Options::gcAtEnd()) {
3100         // We need to hold the API lock to do a GC.
3101         JSLockHolder locker(&amp;vm);
3102         vm.heap.collectNow(Sync, CollectionScope::Full);
3103     }
3104 
3105     if (options.m_dumpSamplingProfilerData) {
3106 #if ENABLE(SAMPLING_PROFILER)
3107         JSLockHolder locker(&amp;vm);
3108         vm.samplingProfiler()-&gt;reportTopFunctions();
3109         vm.samplingProfiler()-&gt;reportTopBytecodes();
3110 #else
3111         dataLog(&quot;Sampling profiler is not enabled on this platform\n&quot;);
3112 #endif
3113     }
3114 
3115     vm.codeCache()-&gt;write(vm);
3116 
3117     if (options.m_destroyVM || isWorker) {
3118         JSLockHolder locker(vm);
3119         // This is needed because we don&#39;t want the worker&#39;s main
3120         // thread to die before its compilation threads finish.
3121         vm.deref();
3122     }
3123 
3124     return result;
3125 }
3126 
3127 int jscmain(int argc, char** argv)
3128 {
3129     // Need to override and enable restricted options before we start parsing options below.
3130     Config::enableRestrictedOptions();
3131 
3132     WTF::initializeMainThread();
3133 
3134     // Note that the options parsing can affect VM creation, and thus
3135     // comes first.
3136     CommandLine options(argc, argv);
3137 
3138     processConfigFile(Options::configFile(), &quot;jsc&quot;);
3139     if (options.m_dump)
3140         JSC::Options::dumpGeneratedBytecodes() = true;
3141 
3142     // Initialize JSC before getting VM.
3143     JSC::initializeThreading();
3144     initializeTimeoutIfNeeded();
3145 #if ENABLE(WEBASSEMBLY)
3146     JSC::Wasm::enableFastMemory();
3147 #endif
3148 
3149     bool gigacageDisableRequested = false;
3150 #if GIGACAGE_ENABLED &amp;&amp; !COMPILER(MSVC)
3151     if (char* gigacageEnabled = getenv(&quot;GIGACAGE_ENABLED&quot;)) {
3152         if (!strcasecmp(gigacageEnabled, &quot;no&quot;) || !strcasecmp(gigacageEnabled, &quot;false&quot;) || !strcasecmp(gigacageEnabled, &quot;0&quot;))
3153             gigacageDisableRequested = true;
3154     }
3155 #endif
3156     if (!gigacageDisableRequested)
3157         Gigacage::forbidDisablingPrimitiveGigacage();
3158 
3159 #if PLATFORM(COCOA)
3160     auto&amp; memoryPressureHandler = MemoryPressureHandler::singleton();
3161     {
3162         dispatch_queue_t queue = dispatch_queue_create(&quot;jsc shell memory pressure handler&quot;, DISPATCH_QUEUE_SERIAL);
3163         memoryPressureHandler.setDispatchQueue(queue);
3164         dispatch_release(queue);
3165     }
3166     Box&lt;Critical&gt; memoryPressureCriticalState = Box&lt;Critical&gt;::create(Critical::No);
3167     Box&lt;Synchronous&gt; memoryPressureSynchronousState = Box&lt;Synchronous&gt;::create(Synchronous::No);
3168     memoryPressureHandler.setLowMemoryHandler([=] (Critical critical, Synchronous synchronous) {
3169         // We set these racily with respect to reading them from the JS execution thread.
3170         *memoryPressureCriticalState = critical;
3171         *memoryPressureSynchronousState = synchronous;
3172     });
3173     memoryPressureHandler.setShouldLogMemoryMemoryPressureEvents(false);
3174     memoryPressureHandler.install();
3175 
3176     auto onEachMicrotaskTick = [&amp;] (VM&amp; vm) {
3177         if (*memoryPressureCriticalState == Critical::No)
3178             return;
3179 
3180         *memoryPressureCriticalState = Critical::No;
3181         bool isSynchronous = *memoryPressureSynchronousState == Synchronous::Yes;
3182 
3183         WTF::releaseFastMallocFreeMemory();
3184         vm.deleteAllCode(DeleteAllCodeIfNotCollecting);
3185 
3186         if (!vm.heap.isCurrentThreadBusy()) {
3187             if (isSynchronous) {
3188                 vm.heap.collectNow(Sync, CollectionScope::Full);
3189                 WTF::releaseFastMallocFreeMemory();
3190             } else
3191                 vm.heap.collectNowFullIfNotDoneRecently(Async);
3192         }
3193     };
3194 #endif
3195 
3196     int result = runJSC(
3197         options, false,
3198         [&amp;] (VM&amp; vm, GlobalObject* globalObject, bool&amp; success) {
3199             UNUSED_PARAM(vm);
3200 #if PLATFORM(COCOA)
3201             vm.setOnEachMicrotaskTick(WTFMove(onEachMicrotaskTick));
3202 #endif
3203             runWithOptions(globalObject, options, success);
3204         });
3205 
3206     printSuperSamplerState();
3207 
3208     if (options.m_dumpMemoryFootprint) {
3209         MemoryFootprint footprint = MemoryFootprint::now();
3210 
3211         printf(&quot;Memory Footprint:\n    Current Footprint: %&quot; PRIu64 &quot;\n    Peak Footprint: %&quot; PRIu64 &quot;\n&quot;, footprint.current, footprint.peak);
3212     }
3213 
3214     return result;
3215 }
3216 
3217 #if OS(WINDOWS)
3218 extern &quot;C&quot; __declspec(dllexport) int WINAPI dllLauncherEntryPoint(int argc, const char* argv[])
3219 {
3220     return main(argc, const_cast&lt;char**&gt;(argv));
3221 }
3222 #endif
    </pre>
  </body>
</html>
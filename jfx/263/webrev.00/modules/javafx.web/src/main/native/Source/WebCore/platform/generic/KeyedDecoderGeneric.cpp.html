<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/generic/KeyedDecoderGeneric.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018 Sony Interactive Entertainment Inc.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;KeyedDecoderGeneric.h&quot;
 28 
 29 #include &quot;KeyedEncoderGeneric.h&quot;
 30 #include &lt;wtf/HashMap.h&gt;
 31 #include &lt;wtf/Variant.h&gt;
 32 #include &lt;wtf/Vector.h&gt;
 33 #include &lt;wtf/persistence/PersistentDecoder.h&gt;
 34 #include &lt;wtf/text/StringHash.h&gt;
 35 
 36 namespace WebCore {
 37 
 38 class KeyedDecoderGeneric::Dictionary {
 39     WTF_MAKE_FAST_ALLOCATED;
 40 public:
 41     using Node = Variant&lt;Vector&lt;uint8_t&gt;, bool, uint32_t, uint64_t, int32_t, int64_t, float, double, String, std::unique_ptr&lt;Dictionary&gt;, std::unique_ptr&lt;Array&gt;&gt;;
 42 
 43     template &lt;typename T&gt;
 44     void add(const String&amp; key, T&amp;&amp; value) { m_map.add(key, makeUnique&lt;Node&gt;(std::forward&lt;T&gt;(value))); }
 45     Node* get(const String&amp; key) { return m_map.get(key); }
 46 
 47 private:
 48     HashMap&lt;String, std::unique_ptr&lt;Node&gt;&gt; m_map;
 49 };
 50 
 51 static bool readString(WTF::Persistence::Decoder&amp; decoder, String&amp; result)
 52 {
 53     size_t size;
 54     if (!decoder.decode(size))
 55         return false;
 56     if (!size) {
 57         result = emptyString();
 58         return true;
 59     }
 60 
 61     Vector&lt;uint8_t&gt; buffer(size);
 62     if (!decoder.decodeFixedLengthData(buffer.data(), size))
 63         return false;
 64     result = String::fromUTF8(buffer.data(), size);
 65     if (result.isNull())
 66         return false;
 67 
 68     return true;
 69 }
 70 
 71 template&lt;typename T&gt;
 72 static bool readSimpleValue(WTF::Persistence::Decoder&amp; decoder, KeyedDecoderGeneric::Dictionary&amp; dictionary)
 73 {
 74     String key;
 75     bool ok = readString(decoder, key);
 76     if (!ok)
 77         return false;
 78     T value;
 79     ok = decoder.decode(value);
 80     if (!ok)
 81         return false;
 82     dictionary.add(key, WTFMove(value));
 83     return true;
 84 }
 85 
 86 std::unique_ptr&lt;KeyedDecoder&gt; KeyedDecoder::decoder(const uint8_t* data, size_t size)
 87 {
 88     return makeUnique&lt;KeyedDecoderGeneric&gt;(data, size);
 89 }
 90 
 91 KeyedDecoderGeneric::KeyedDecoderGeneric(const uint8_t* data, size_t size)
 92 {
 93     WTF::Persistence::Decoder decoder(data, size);
 94     KeyedEncoderGeneric::Type type;
 95     String key;
 96 
 97     m_rootDictionary = makeUnique&lt;Dictionary&gt;();
 98     m_dictionaryStack.append(m_rootDictionary.get());
 99 
100     bool ok = true;
101     while (ok &amp;&amp; decoder.decodeEnum(type)) {
102         switch (type) {
103         case KeyedEncoderGeneric::Type::Bytes: {
104             ok = readString(decoder, key);
105             if (!ok)
106                 break;
107             size_t size;
108             ok = decoder.decode(size);
109             if (!ok)
110                 break;
111             Vector&lt;uint8_t&gt; buffer(size);
112             ok = decoder.decodeFixedLengthData(buffer.data(), size);
113             if (!ok)
114                 break;
115             m_dictionaryStack.last()-&gt;add(key, WTFMove(buffer));
116             break;
117         }
118         case KeyedEncoderGeneric::Type::Bool:
119             ok = readSimpleValue&lt;bool&gt;(decoder, *m_dictionaryStack.last());
120             break;
121         case KeyedEncoderGeneric::Type::UInt32:
122             ok = readSimpleValue&lt;uint32_t&gt;(decoder, *m_dictionaryStack.last());
123             break;
124         case KeyedEncoderGeneric::Type::UInt64:
125             ok = readSimpleValue&lt;uint64_t&gt;(decoder, *m_dictionaryStack.last());
126             break;
127         case KeyedEncoderGeneric::Type::Int32:
128             ok = readSimpleValue&lt;int32_t&gt;(decoder, *m_dictionaryStack.last());
129             break;
130         case KeyedEncoderGeneric::Type::Int64:
131             ok = readSimpleValue&lt;int64_t&gt;(decoder, *m_dictionaryStack.last());
132             break;
133         case KeyedEncoderGeneric::Type::Float:
134             ok = readSimpleValue&lt;float&gt;(decoder, *m_dictionaryStack.last());
135             break;
136         case KeyedEncoderGeneric::Type::Double:
137             ok = readSimpleValue&lt;double&gt;(decoder, *m_dictionaryStack.last());
138             break;
139         case KeyedEncoderGeneric::Type::String: {
140             ok = readString(decoder, key);
141             if (!ok)
142                 break;
143             String value;
144             ok = readString(decoder, value);
145             if (!ok)
146                 break;
147             m_dictionaryStack.last()-&gt;add(key, WTFMove(value));
148             break;
149         }
150         case KeyedEncoderGeneric::Type::BeginObject: {
151             ok = readString(decoder, key);
152             if (!ok)
153                 break;
154             auto* currentDictinary = m_dictionaryStack.last();
155             auto newDictionary = makeUnique&lt;Dictionary&gt;();
156             m_dictionaryStack.append(newDictionary.get());
157             currentDictinary-&gt;add(key, WTFMove(newDictionary));
158             break;
159         }
160         case KeyedEncoderGeneric::Type::EndObject:
161             m_dictionaryStack.removeLast();
162             break;
163         case KeyedEncoderGeneric::Type::BeginArray: {
164             ok = readString(decoder, key);
165             if (!ok)
166                 break;
167             auto newArray = makeUnique&lt;Array&gt;();
168             m_arrayStack.append(newArray.get());
169             m_dictionaryStack.last()-&gt;add(key, WTFMove(newArray));
170             break;
171         }
172         case KeyedEncoderGeneric::Type::BeginArrayElement: {
173             auto newDictionary = makeUnique&lt;Dictionary&gt;();
174             m_dictionaryStack.append(newDictionary.get());
175             m_arrayStack.last()-&gt;append(WTFMove(newDictionary));
176             break;
177         }
178         case KeyedEncoderGeneric::Type::EndArrayElement:
179             m_dictionaryStack.removeLast();
180             break;
181         case KeyedEncoderGeneric::Type::EndArray:
182             m_arrayStack.removeLast();
183             break;
184         }
185     }
186     while (m_dictionaryStack.size() &gt; 1)
187         m_dictionaryStack.removeLast();
188     while (!m_arrayStack.isEmpty())
189         m_arrayStack.removeLast();
190 }
191 
192 template&lt;typename T&gt;
193 const T* KeyedDecoderGeneric::getPointerFromDictionaryStack(const String&amp; key)
194 {
195     auto&amp; dictionary = m_dictionaryStack.last();
196 
197     auto node = dictionary-&gt;get(key);
198     if (!node)
199         return nullptr;
200 
201     return WTF::get_if&lt;T&gt;(*node);
202 }
203 
204 template&lt;typename T&gt;
205 bool KeyedDecoderGeneric::decodeSimpleValue(const String&amp; key, T&amp; result)
206 {
207     auto value = getPointerFromDictionaryStack&lt;T&gt;(key);
208     if (!value)
209         return false;
210 
211     result = *value;
212     return true;
213 }
214 
215 bool KeyedDecoderGeneric::decodeBytes(const String&amp; key, const uint8_t*&amp; data, size_t&amp; size)
216 {
217     auto value = getPointerFromDictionaryStack&lt;Vector&lt;uint8_t&gt;&gt;(key);
218     if (!value)
219         return false;
220 
221     data = value-&gt;data();
222     size = value-&gt;size();
223     return true;
224 }
225 
226 bool KeyedDecoderGeneric::decodeBool(const String&amp; key, bool&amp; result)
227 {
228     return decodeSimpleValue(key, result);
229 }
230 
231 bool KeyedDecoderGeneric::decodeUInt32(const String&amp; key, uint32_t&amp; result)
232 {
233     return decodeSimpleValue(key, result);
234 }
235 
236 bool KeyedDecoderGeneric::decodeUInt64(const String&amp; key, uint64_t&amp; result)
237 {
238     return decodeSimpleValue(key, result);
239 }
240 
241 bool KeyedDecoderGeneric::decodeInt32(const String&amp; key, int32_t&amp; result)
242 {
243     return decodeSimpleValue(key, result);
244 }
245 
246 bool KeyedDecoderGeneric::decodeInt64(const String&amp; key, int64_t&amp; result)
247 {
248     return decodeSimpleValue(key, result);
249 }
250 
251 bool KeyedDecoderGeneric::decodeFloat(const String&amp; key, float&amp; result)
252 {
253     return decodeSimpleValue(key, result);
254 }
255 
256 bool KeyedDecoderGeneric::decodeDouble(const String&amp; key, double&amp; result)
257 {
258     return decodeSimpleValue(key, result);
259 }
260 
261 bool KeyedDecoderGeneric::decodeString(const String&amp; key, String&amp; result)
262 {
263     return decodeSimpleValue(key, result);
264 }
265 
266 bool KeyedDecoderGeneric::beginObject(const String&amp; key)
267 {
268     auto value = getPointerFromDictionaryStack&lt;std::unique_ptr&lt;Dictionary&gt;&gt;(key);
269     if (!value)
270         return false;
271 
272     m_dictionaryStack.append(value-&gt;get());
273     return true;
274 }
275 
276 void KeyedDecoderGeneric::endObject()
277 {
278     m_dictionaryStack.removeLast();
279 }
280 
281 bool KeyedDecoderGeneric::beginArray(const String&amp; key)
282 {
283     auto value = getPointerFromDictionaryStack&lt;std::unique_ptr&lt;Array&gt;&gt;(key);
284     if (!value)
285         return false;
286 
287     m_arrayStack.append(value-&gt;get());
288     m_arrayIndexStack.append(0);
289     return true;
290 }
291 
292 bool KeyedDecoderGeneric::beginArrayElement()
293 {
294     if (m_arrayIndexStack.last() &gt;= m_arrayStack.last()-&gt;size())
295         return false;
296 
297     auto dictionary = m_arrayStack.last()-&gt;at(m_arrayIndexStack.last()++).get();
298     m_dictionaryStack.append(dictionary);
299     return true;
300 }
301 
302 void KeyedDecoderGeneric::endArrayElement()
303 {
304     m_dictionaryStack.removeLast();
305 }
306 
307 void KeyedDecoderGeneric::endArray()
308 {
309     m_arrayStack.removeLast();
310     m_arrayIndexStack.removeLast();
311 }
312 
313 } // namespace WebCore
    </pre>
  </body>
</html>
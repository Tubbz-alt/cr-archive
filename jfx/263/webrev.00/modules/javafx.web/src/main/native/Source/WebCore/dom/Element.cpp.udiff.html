<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/dom/Element.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DocumentStorageAccess.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Element.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Element.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -2,11 +2,11 @@</span>
   * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   *           (C) 2001 Peter Kelly (pmk@post.com)
   *           (C) 2001 Dirk Mueller (mueller@kde.org)
   *           (C) 2007 David Smith (catfish.man@gmail.com)
<span class="udiff-line-modified-removed">-  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.</span>
   *           (C) 2007 Eric Seidel (eric@webkit.org)
   *
   * This library is free software; you can redistribute it and/or
   * modify it under the terms of the GNU Library General Public
   * License as published by the Free Software Foundation; either
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -33,10 +33,11 @@</span>
  #include &quot;CSSParser.h&quot;
  #include &quot;Chrome.h&quot;
  #include &quot;ChromeClient.h&quot;
  #include &quot;ClassChangeInvalidation.h&quot;
  #include &quot;ComposedTreeAncestorIterator.h&quot;
<span class="udiff-line-added">+ #include &quot;ComposedTreeIterator.h&quot;</span>
  #include &quot;ContainerNodeAlgorithms.h&quot;
  #include &quot;CustomElementReactionQueue.h&quot;
  #include &quot;CustomElementRegistry.h&quot;
  #include &quot;DOMRect.h&quot;
  #include &quot;DOMRectList.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -54,10 +55,11 @@</span>
  #include &quot;FocusEvent.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;FrameSelection.h&quot;
  #include &quot;FrameView.h&quot;
  #include &quot;FullscreenManager.h&quot;
<span class="udiff-line-added">+ #include &quot;GetAnimationsOptions.h&quot;</span>
  #include &quot;HTMLBodyElement.h&quot;
  #include &quot;HTMLCanvasElement.h&quot;
  #include &quot;HTMLCollection.h&quot;
  #include &quot;HTMLDocument.h&quot;
  #include &quot;HTMLHtmlElement.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -72,19 +74,21 @@</span>
  #include &quot;IdChangeInvalidation.h&quot;
  #include &quot;IdTargetObserverRegistry.h&quot;
  #include &quot;InspectorInstrumentation.h&quot;
  #include &quot;JSLazyEventListener.h&quot;
  #include &quot;KeyboardEvent.h&quot;
<span class="udiff-line-added">+ #include &quot;KeyframeAnimationOptions.h&quot;</span>
  #include &quot;KeyframeEffect.h&quot;
  #include &quot;MutationObserverInterestGroup.h&quot;
  #include &quot;MutationRecord.h&quot;
  #include &quot;NodeRenderStyle.h&quot;
<span class="udiff-line-added">+ #include &quot;PlatformMouseEvent.h&quot;</span>
  #include &quot;PlatformWheelEvent.h&quot;
  #include &quot;PointerCaptureController.h&quot;
  #include &quot;PointerEvent.h&quot;
  #include &quot;PointerLockController.h&quot;
<span class="udiff-line-modified-removed">- #include &quot;RenderFragmentContainer.h&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;RenderFragmentedFlow.h&quot;</span>
  #include &quot;RenderLayer.h&quot;
  #include &quot;RenderLayerBacking.h&quot;
  #include &quot;RenderLayerCompositor.h&quot;
  #include &quot;RenderListBox.h&quot;
  #include &quot;RenderTheme.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -101,10 +105,11 @@</span>
  #include &quot;ScrollLatchingState.h&quot;
  #include &quot;SelectorQuery.h&quot;
  #include &quot;Settings.h&quot;
  #include &quot;SimulatedClick.h&quot;
  #include &quot;SlotAssignment.h&quot;
<span class="udiff-line-added">+ #include &quot;StyleInvalidator.h&quot;</span>
  #include &quot;StyleProperties.h&quot;
  #include &quot;StyleResolver.h&quot;
  #include &quot;StyleScope.h&quot;
  #include &quot;StyleTreeResolver.h&quot;
  #include &quot;TextIterator.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -265,26 +270,27 @@</span>
      return this;
  }
  
  int Element::tabIndexForBindings() const
  {
<span class="udiff-line-modified-removed">-     auto defaultIndex = defaultTabIndex();</span>
<span class="udiff-line-removed">-     ASSERT(!defaultIndex || defaultIndex == -1);</span>
<span class="udiff-line-removed">-     // FIXME: supportsFocus() check shouldn&#39;t be here.</span>
<span class="udiff-line-removed">-     if (!defaultIndex || supportsFocus())</span>
<span class="udiff-line-removed">-         return tabIndexSetExplicitly().valueOr(0);</span>
<span class="udiff-line-removed">-     return defaultIndex;</span>
<span class="udiff-line-modified-added">+     return valueOrCompute(tabIndexSetExplicitly(), [&amp;] { return defaultTabIndex(); });</span>
  }
  
  void Element::setTabIndexForBindings(int value)
  {
      setIntegralAttribute(tabindexAttr, value);
  }
  
  bool Element::isKeyboardFocusable(KeyboardEvent*) const
  {
<span class="udiff-line-modified-removed">-     return isFocusable() &amp;&amp; !shouldBeIgnoredInSequentialFocusNavigation() &amp;&amp; tabIndexSetExplicitly().valueOr(0) &gt;= 0;</span>
<span class="udiff-line-modified-added">+     if (!(isFocusable() &amp;&amp; !shouldBeIgnoredInSequentialFocusNavigation() &amp;&amp; tabIndexSetExplicitly().valueOr(0) &gt;= 0))</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+     if (auto* root = shadowRoot()) {</span>
<span class="udiff-line-added">+         if (root-&gt;delegatesFocus())</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return true;</span>
  }
  
  bool Element::isMouseFocusable() const
  {
      return isFocusable();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -298,57 +304,77 @@</span>
  static bool isForceEvent(const PlatformMouseEvent&amp; platformEvent)
  {
      return platformEvent.type() == PlatformEvent::MouseForceChanged || platformEvent.type() == PlatformEvent::MouseForceDown || platformEvent.type() == PlatformEvent::MouseForceUp;
  }
  
<span class="udiff-line-modified-removed">- #if ENABLE(POINTER_EVENTS) &amp;&amp; !ENABLE(TOUCH_EVENTS)</span>
<span class="udiff-line-modified-added">+ #if ENABLE(POINTER_EVENTS)</span>
<span class="udiff-line-added">+ </span>
  static bool isCompatibilityMouseEvent(const MouseEvent&amp; mouseEvent)
  {
      // https://www.w3.org/TR/pointerevents/#compatibility-mapping-with-mouse-events
      const auto&amp; type = mouseEvent.type();
      return type != eventNames().clickEvent &amp;&amp; type != eventNames().mouseoverEvent &amp;&amp; type != eventNames().mouseoutEvent &amp;&amp; type != eventNames().mouseenterEvent &amp;&amp; type != eventNames().mouseleaveEvent;
  }
<span class="udiff-line-added">+ </span>
  #endif
  
<span class="udiff-line-modified-removed">- bool Element::dispatchMouseEvent(const PlatformMouseEvent&amp; platformEvent, const AtomString&amp; eventType, int detail, Element* relatedTarget)</span>
<span class="udiff-line-modified-added">+ enum class ShouldIgnoreMouseEvent : bool { No, Yes };</span>
<span class="udiff-line-added">+ static ShouldIgnoreMouseEvent dispatchPointerEventIfNeeded(Element&amp; element, const MouseEvent&amp; mouseEvent, const PlatformMouseEvent&amp; platformEvent, bool&amp; didNotSwallowEvent)</span>
  {
<span class="udiff-line-removed">-     if (isDisabledFormControl())</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (isForceEvent(platformEvent) &amp;&amp; !document().hasListenerTypeForEventType(platformEvent.type()))</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Ref&lt;MouseEvent&gt; mouseEvent = MouseEvent::create(eventType, document().windowProxy(), platformEvent, detail, relatedTarget);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (mouseEvent-&gt;type().isEmpty())</span>
<span class="udiff-line-removed">-         return true; // Shouldn&#39;t happen.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bool didNotSwallowEvent = true;</span>
<span class="udiff-line-removed">- </span>
  #if ENABLE(POINTER_EVENTS)
      if (RuntimeEnabledFeatures::sharedFeatures().pointerEventsEnabled()) {
<span class="udiff-line-modified-removed">-         if (auto* page = document().page()) {</span>
<span class="udiff-line-modified-added">+         if (auto* page = element.document().page()) {</span>
              auto&amp; pointerCaptureController = page-&gt;pointerCaptureController();
  #if ENABLE(TOUCH_EVENTS)
<span class="udiff-line-modified-removed">-             if (mouseEvent-&gt;type() != eventNames().clickEvent &amp;&amp; pointerCaptureController.preventsCompatibilityMouseEventsForIdentifier(platformEvent.pointerId()))</span>
<span class="udiff-line-modified-removed">-                 return false;</span>
<span class="udiff-line-modified-added">+             if (platformEvent.pointerId() != mousePointerID &amp;&amp; mouseEvent.type() != eventNames().clickEvent &amp;&amp; pointerCaptureController.preventsCompatibilityMouseEventsForIdentifier(platformEvent.pointerId()))</span>
<span class="udiff-line-modified-added">+                 return ShouldIgnoreMouseEvent::Yes;</span>
  #else
<span class="udiff-line-added">+             UNUSED_PARAM(platformEvent);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+             if (platformEvent.syntheticClickType() != NoTap)</span>
<span class="udiff-line-added">+                 return ShouldIgnoreMouseEvent::No;</span>
<span class="udiff-line-added">+ </span>
              if (auto pointerEvent = pointerCaptureController.pointerEventForMouseEvent(mouseEvent)) {
<span class="udiff-line-modified-removed">-                 pointerCaptureController.dispatchEvent(*pointerEvent, this);</span>
<span class="udiff-line-modified-added">+                 pointerCaptureController.dispatchEvent(*pointerEvent, &amp;element);</span>
                  if (isCompatibilityMouseEvent(mouseEvent) &amp;&amp; pointerCaptureController.preventsCompatibilityMouseEventsForIdentifier(pointerEvent-&gt;pointerId()))
<span class="udiff-line-modified-removed">-                     return false;</span>
<span class="udiff-line-modified-added">+                     return ShouldIgnoreMouseEvent::Yes;</span>
                  if (pointerEvent-&gt;defaultPrevented() || pointerEvent-&gt;defaultHandled()) {
                      didNotSwallowEvent = false;
                      if (pointerEvent-&gt;type() == eventNames().pointerdownEvent)
<span class="udiff-line-modified-removed">-                         return false;</span>
<span class="udiff-line-modified-added">+                         return ShouldIgnoreMouseEvent::Yes;</span>
                  }
              }
<span class="udiff-line-removed">- #endif</span>
          }
      }
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     UNUSED_PARAM(element);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(mouseEvent);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(platformEvent);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(didNotSwallowEvent);</span>
  #endif
  
<span class="udiff-line-added">+     return ShouldIgnoreMouseEvent::No;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool Element::dispatchMouseEvent(const PlatformMouseEvent&amp; platformEvent, const AtomString&amp; eventType, int detail, Element* relatedTarget)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (isDisabledFormControl())</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (isForceEvent(platformEvent) &amp;&amp; !document().hasListenerTypeForEventType(platformEvent.type()))</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Ref&lt;MouseEvent&gt; mouseEvent = MouseEvent::create(eventType, document().windowProxy(), platformEvent, detail, relatedTarget);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (mouseEvent-&gt;type().isEmpty())</span>
<span class="udiff-line-added">+         return true; // Shouldn&#39;t happen.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bool didNotSwallowEvent = true;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (dispatchPointerEventIfNeeded(*this, mouseEvent.get(), platformEvent, didNotSwallowEvent) == ShouldIgnoreMouseEvent::Yes)</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
      ASSERT(!mouseEvent-&gt;target() || mouseEvent-&gt;target() != relatedTarget);
      dispatchEvent(mouseEvent);
      if (mouseEvent-&gt;defaultPrevented() || mouseEvent-&gt;defaultHandled())
          didNotSwallowEvent = false;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -680,10 +706,16 @@</span>
          return;
  
      document().userActionElements().setFocused(*this, flag);
      invalidateStyleForSubtree();
  
<span class="udiff-line-added">+     // Shadow host with a slot that contain focused element is not considered focused.</span>
<span class="udiff-line-added">+     for (auto* root = containingShadowRoot(); root; root = root-&gt;host()-&gt;containingShadowRoot()) {</span>
<span class="udiff-line-added">+         root-&gt;setContainsFocusedElement(flag);</span>
<span class="udiff-line-added">+         root-&gt;host()-&gt;invalidateStyle();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      for (Element* element = this; element; element = element-&gt;parentElementInComposedTree())
          element-&gt;setHasFocusWithin(flag);
  }
  
  void Element::setHovered(bool flag)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -909,11 +941,11 @@</span>
          // FIXME: Scrolling an independently scrollable body is broken: webkit.org/b/161612.
          auto window = makeRefPtr(document().domWindow());
          if (!window)
              return;
  
<span class="udiff-line-modified-removed">-         window-&gt;scrollTo(options);</span>
<span class="udiff-line-modified-added">+         window-&gt;scrollTo(options, clamping);</span>
          return;
      }
  
      // If the element does not have any associated CSS layout box, the element has no associated scrolling box,
      // or the element has no overflow, terminate these steps.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1172,10 +1204,22 @@</span>
      if ((!inQuirksMode &amp;&amp; document().documentElement() == this) || (inQuirksMode &amp;&amp; isHTMLElement() &amp;&amp; document().bodyOrFrameset() == this))
          return adjustForAbsoluteZoom(renderView.frameView().layoutWidth(), renderView);
  
      if (RenderBox* renderer = renderBox()) {
          LayoutUnit clientWidth = subpixelMetricsEnabled(renderer-&gt;document()) ? renderer-&gt;clientWidth() : LayoutUnit(roundToInt(renderer-&gt;clientWidth()));
<span class="udiff-line-added">+         // clientWidth/Height is the visual portion of the box content, not including</span>
<span class="udiff-line-added">+         // borders or scroll bars, but includes padding. And per</span>
<span class="udiff-line-added">+         // https://www.w3.org/TR/CSS2/tables.html#model,</span>
<span class="udiff-line-added">+         // table wrapper box is a principal block box that contains the table box</span>
<span class="udiff-line-added">+         // itself and any caption boxes, and table grid box is a block-level box that</span>
<span class="udiff-line-added">+         // contains the table&#39;s internal table boxes. When table&#39;s border is specified</span>
<span class="udiff-line-added">+         // in CSS, the border is added to table grid box, not table wrapper box.</span>
<span class="udiff-line-added">+         // Currently, WebKit doesn&#39;t have table wrapper box, and we are supposed to</span>
<span class="udiff-line-added">+         // retrieve clientWidth/Height from table wrapper box, not table grid box. So</span>
<span class="udiff-line-added">+         // when we retrieve clientWidth/Height, it includes table&#39;s border size.</span>
<span class="udiff-line-added">+         if (renderer-&gt;isTable())</span>
<span class="udiff-line-added">+             clientWidth += renderer-&gt;borderLeft() + renderer-&gt;borderRight();</span>
          return convertToNonSubpixelValueIfNeeded(adjustLayoutUnitForAbsoluteZoom(clientWidth, *renderer).toDouble(), renderer-&gt;document());
      }
      return 0;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1193,10 +1237,22 @@</span>
      if ((!inQuirksMode &amp;&amp; document().documentElement() == this) || (inQuirksMode &amp;&amp; isHTMLElement() &amp;&amp; document().bodyOrFrameset() == this))
          return adjustForAbsoluteZoom(renderView.frameView().layoutHeight(), renderView);
  
      if (RenderBox* renderer = renderBox()) {
          LayoutUnit clientHeight = subpixelMetricsEnabled(renderer-&gt;document()) ? renderer-&gt;clientHeight() : LayoutUnit(roundToInt(renderer-&gt;clientHeight()));
<span class="udiff-line-added">+         // clientWidth/Height is the visual portion of the box content, not including</span>
<span class="udiff-line-added">+         // borders or scroll bars, but includes padding. And per</span>
<span class="udiff-line-added">+         // https://www.w3.org/TR/CSS2/tables.html#model,</span>
<span class="udiff-line-added">+         // table wrapper box is a principal block box that contains the table box</span>
<span class="udiff-line-added">+         // itself and any caption boxes, and table grid box is a block-level box that</span>
<span class="udiff-line-added">+         // contains the table&#39;s internal table boxes. When table&#39;s border is specified</span>
<span class="udiff-line-added">+         // in CSS, the border is added to table grid box, not table wrapper box.</span>
<span class="udiff-line-added">+         // Currently, WebKit doesn&#39;t have table wrapper box, and we are supposed to</span>
<span class="udiff-line-added">+         // retrieve clientWidth/Height from table wrapper box, not table grid box. So</span>
<span class="udiff-line-added">+         // when we retrieve clientWidth/Height, it includes table&#39;s border size.</span>
<span class="udiff-line-added">+         if (renderer-&gt;isTable())</span>
<span class="udiff-line-added">+             clientHeight += renderer-&gt;borderTop() + renderer-&gt;borderBottom();</span>
          return convertToNonSubpixelValueIfNeeded(adjustLayoutUnitForAbsoluteZoom(clientHeight, *renderer).toDouble(), renderer-&gt;document());
      }
      return 0;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1720,10 +1776,17 @@</span>
          } else if (name == HTMLNames::slotAttr) {
              if (auto* parent = parentElement()) {
                  if (auto* shadowRoot = parent-&gt;shadowRoot())
                      shadowRoot-&gt;hostChildElementDidChangeSlotAttribute(*this, oldValue, newValue);
              }
<span class="udiff-line-added">+         } else if (name == HTMLNames::partAttr)</span>
<span class="udiff-line-added">+             partAttributeChanged(newValue);</span>
<span class="udiff-line-added">+         else if (name == HTMLNames::exportpartsAttr) {</span>
<span class="udiff-line-added">+             if (auto* shadowRoot = this-&gt;shadowRoot()) {</span>
<span class="udiff-line-added">+                 shadowRoot-&gt;invalidatePartMappings();</span>
<span class="udiff-line-added">+                 Style::Invalidator::invalidateShadowParts(*shadowRoot);</span>
<span class="udiff-line-added">+             }</span>
          }
      }
  
      parseAttribute(name, newValue);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1740,11 +1803,11 @@</span>
      if (AXObjectCache* cache = document().existingAXObjectCache())
          cache-&gt;deferAttributeChangeIfNeeded(name, this);
  }
  
  template &lt;typename CharacterType&gt;
<span class="udiff-line-modified-removed">- static inline bool classStringHasClassName(const CharacterType* characters, unsigned length)</span>
<span class="udiff-line-modified-added">+ static inline bool isNonEmptyTokenList(const CharacterType* characters, unsigned length)</span>
  {
      ASSERT(length &gt; 0);
  
      unsigned i = 0;
      do {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1754,30 +1817,30 @@</span>
      } while (i &lt; length);
  
      return i &lt; length;
  }
  
<span class="udiff-line-modified-removed">- static inline bool classStringHasClassName(const AtomString&amp; newClassString)</span>
<span class="udiff-line-modified-added">+ static inline bool isNonEmptyTokenList(const AtomString&amp; stringValue)</span>
  {
<span class="udiff-line-modified-removed">-     unsigned length = newClassString.length();</span>
<span class="udiff-line-modified-added">+     unsigned length = stringValue.length();</span>
  
      if (!length)
          return false;
  
<span class="udiff-line-modified-removed">-     if (newClassString.is8Bit())</span>
<span class="udiff-line-modified-removed">-         return classStringHasClassName(newClassString.characters8(), length);</span>
<span class="udiff-line-modified-removed">-     return classStringHasClassName(newClassString.characters16(), length);</span>
<span class="udiff-line-modified-added">+     if (stringValue.is8Bit())</span>
<span class="udiff-line-modified-added">+         return isNonEmptyTokenList(stringValue.characters8(), length);</span>
<span class="udiff-line-modified-added">+     return isNonEmptyTokenList(stringValue.characters16(), length);</span>
  }
  
  void Element::classAttributeChanged(const AtomString&amp; newClassString)
  {
      // Note: We&#39;ll need ElementData, but it doesn&#39;t have to be UniqueElementData.
      if (!elementData())
          ensureUniqueElementData();
  
      bool shouldFoldCase = document().inQuirksMode();
<span class="udiff-line-modified-removed">-     bool newStringHasClasses = classStringHasClassName(newClassString);</span>
<span class="udiff-line-modified-added">+     bool newStringHasClasses = isNonEmptyTokenList(newClassString);</span>
  
      auto oldClassNames = elementData()-&gt;classNames();
      auto newClassNames = newStringHasClasses ? SpaceSplitString(newClassString, shouldFoldCase) : SpaceSplitString();
      {
          Style::ClassChangeInvalidation styleInvalidation(*this, oldClassNames, newClassNames);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1788,10 +1851,30 @@</span>
          if (auto* classList = elementRareData()-&gt;classList())
              classList-&gt;associatedAttributeValueChanged(newClassString);
      }
  }
  
<span class="udiff-line-added">+ void Element::partAttributeChanged(const AtomString&amp; newValue)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (!RuntimeEnabledFeatures::sharedFeatures().cssShadowPartsEnabled())</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bool hasParts = isNonEmptyTokenList(newValue);</span>
<span class="udiff-line-added">+     if (hasParts || !partNames().isEmpty()) {</span>
<span class="udiff-line-added">+         auto newParts = hasParts ? SpaceSplitString(newValue, false) : SpaceSplitString();</span>
<span class="udiff-line-added">+         ensureElementRareData().setPartNames(WTFMove(newParts));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (hasRareData()) {</span>
<span class="udiff-line-added">+         if (auto* partList = elementRareData()-&gt;partList())</span>
<span class="udiff-line-added">+             partList-&gt;associatedAttributeValueChanged(newValue);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (needsStyleInvalidation() &amp;&amp; isInShadowTree())</span>
<span class="udiff-line-added">+         invalidateStyleInternal();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  URL Element::absoluteLinkURL() const
  {
      if (!isLink())
          return URL();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1806,31 +1889,33 @@</span>
  
      return document().completeURL(stripLeadingAndTrailingHTMLSpaces(linkAttribute));
  }
  
  #if ENABLE(TOUCH_EVENTS)
<span class="udiff-line-added">+ </span>
  bool Element::allowsDoubleTapGesture() const
  {
  #if ENABLE(POINTER_EVENTS)
      if (renderStyle() &amp;&amp; renderStyle()-&gt;touchActions() != TouchAction::Auto)
          return false;
  #endif
  
      Element* parent = parentElement();
      return !parent || parent-&gt;allowsDoubleTapGesture();
  }
<span class="udiff-line-added">+ </span>
  #endif
  
<span class="udiff-line-modified-removed">- StyleResolver&amp; Element::styleResolver()</span>
<span class="udiff-line-modified-added">+ Style::Resolver&amp; Element::styleResolver()</span>
  {
      if (auto* shadowRoot = containingShadowRoot())
          return shadowRoot-&gt;styleScope().resolver();
  
      return document().styleScope().resolver();
  }
  
<span class="udiff-line-modified-removed">- ElementStyle Element::resolveStyle(const RenderStyle* parentStyle)</span>
<span class="udiff-line-modified-added">+ Style::ElementStyle Element::resolveStyle(const RenderStyle* parentStyle)</span>
  {
      return styleResolver().styleForElement(*this, parentStyle);
  }
  
  static void invalidateForSiblingCombinators(Element* sibling)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2028,11 +2113,11 @@</span>
      return attributeWithoutSynchronization(srcAttr);
  }
  
  bool Element::rendererIsNeeded(const RenderStyle&amp; style)
  {
<span class="udiff-line-modified-removed">-     return style.display() != DisplayType::None &amp;&amp; style.display() != DisplayType::Contents;</span>
<span class="udiff-line-modified-added">+     return rendererIsEverNeeded() &amp;&amp; style.display() != DisplayType::None &amp;&amp; style.display() != DisplayType::Contents;</span>
  }
  
  RenderPtr&lt;RenderElement&gt; Element::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
  {
      return RenderElement::createFor(*this, WTFMove(style));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2167,10 +2252,11 @@</span>
          document().accessSVGExtensions().removeElementFromPendingResources(*this);
  
      RefPtr&lt;Frame&gt; frame = document().frame();
      if (auto* timeline = document().existingTimeline())
          timeline-&gt;elementWasRemoved(*this);
<span class="udiff-line-added">+ </span>
      if (frame)
          frame-&gt;animation().cancelAnimations(*this);
  
  #if PLATFORM(MAC)
      if (frame &amp;&amp; frame-&gt;page())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2193,20 +2279,21 @@</span>
      ASSERT(!newShadowRoot-&gt;hasChildNodes());
      ASSERT(!shadowRoot());
  
      ShadowRoot&amp; shadowRoot = newShadowRoot;
      {
<span class="udiff-line-added">+         WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;</span>
          ScriptDisallowedScope::InMainThread scriptDisallowedScope;
          if (renderer())
              RenderTreeUpdater::tearDownRenderers(*this);
  
          ensureElementRareData().setShadowRoot(WTFMove(newShadowRoot));
  
          shadowRoot.setHost(this);
          shadowRoot.setParentTreeScope(treeScope());
  
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
          ASSERT(notifyChildNodeInserted(*this, shadowRoot).isEmpty());
  #else
          notifyChildNodeInserted(*this, shadowRoot);
  #endif
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2251,10 +2338,11 @@</span>
              &amp;h3Tag.get(),
              &amp;h4Tag.get(),
              &amp;h5Tag.get(),
              &amp;h6Tag.get(),
              &amp;headerTag.get(),
<span class="udiff-line-added">+             &amp;mainTag.get(),</span>
              &amp;navTag.get(),
              &amp;pTag.get(),
              &amp;sectionTag.get(),
              &amp;spanTag.get()
          };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2274,27 +2362,27 @@</span>
  ExceptionOr&lt;ShadowRoot&amp;&gt; Element::attachShadow(const ShadowRootInit&amp; init)
  {
      if (!canAttachAuthorShadowRoot(*this))
          return Exception { NotSupportedError };
      if (shadowRoot())
<span class="udiff-line-modified-removed">-         return Exception { InvalidStateError };</span>
<span class="udiff-line-modified-added">+         return Exception { NotSupportedError };</span>
      if (init.mode == ShadowRootMode::UserAgent)
          return Exception { TypeError };
<span class="udiff-line-modified-removed">-     auto shadow = ShadowRoot::create(document(), init.mode);</span>
<span class="udiff-line-modified-added">+     auto shadow = ShadowRoot::create(document(), init.mode, init.delegatesFocus ? ShadowRoot::DelegatesFocus::Yes : ShadowRoot::DelegatesFocus::No);</span>
      auto&amp; result = shadow.get();
      addShadowRoot(WTFMove(shadow));
      return result;
  }
  
<span class="udiff-line-modified-removed">- ShadowRoot* Element::shadowRootForBindings(JSC::ExecState&amp; state) const</span>
<span class="udiff-line-modified-added">+ ShadowRoot* Element::shadowRootForBindings(JSC::JSGlobalObject&amp; lexicalGlobalObject) const</span>
  {
      auto* shadow = shadowRoot();
      if (!shadow)
          return nullptr;
      if (shadow-&gt;mode() == ShadowRootMode::Open)
          return shadow;
<span class="udiff-line-modified-removed">-     if (JSC::jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject())-&gt;world().shadowRootIsAlwaysOpen())</span>
<span class="udiff-line-modified-added">+     if (JSC::jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject)-&gt;world().shadowRootIsAlwaysOpen())</span>
          return shadow;
      return nullptr;
  }
  
  RefPtr&lt;ShadowRoot&gt; Element::userAgentShadowRoot() const
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2549,10 +2637,11 @@</span>
      setIsParsingChildrenFinished();
      checkForSiblingStyleChanges(*this, FinishedParsingChildren, ElementTraversal::lastChild(*this), nullptr);
  }
  
  #if ENABLE(TREE_DEBUGGING)
<span class="udiff-line-added">+ </span>
  void Element::formatForDebugger(char* buffer, unsigned length) const
  {
      StringBuilder result;
      String s;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2574,10 +2663,11 @@</span>
          result.append(s);
      }
  
      strncpy(buffer, result.toString().utf8().data(), length - 1);
  }
<span class="udiff-line-added">+ </span>
  #endif
  
  const Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; Element::attrNodeList()
  {
      ASSERT(hasSyntheticAttrChildNodes());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2825,65 +2915,111 @@</span>
      QualifiedName qName(nullAtom(), localName, namespaceURI);
      synchronizeAttribute(qName);
      return elementData()-&gt;findAttributeByName(qName);
  }
  
<span class="udiff-line-added">+ static RefPtr&lt;ShadowRoot&gt; shadowRootWithDelegatesFocus(const Element&amp; element)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (auto* root = element.shadowRoot()) {</span>
<span class="udiff-line-added">+         if (root-&gt;delegatesFocus())</span>
<span class="udiff-line-added">+             return root;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return nullptr;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static bool isProgramaticallyFocusable(Element&amp; element)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ScriptDisallowedScope::InMainThread scriptDisallowedScope;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (shadowRootWithDelegatesFocus(element))</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // If the stylesheets have already been loaded we can reliably check isFocusable.</span>
<span class="udiff-line-added">+     // If not, we continue and set the focused node on the focus controller below so that it can be updated soon after attach.</span>
<span class="udiff-line-added">+     if (element.document().haveStylesheetsLoaded()) {</span>
<span class="udiff-line-added">+         if (!element.isFocusable())</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return element.supportsFocus();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static RefPtr&lt;Element&gt; findFirstProgramaticallyFocusableElementInComposedTree(Element&amp; host)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(host.shadowRoot());</span>
<span class="udiff-line-added">+     for (auto&amp; node : composedTreeDescendants(host)) {</span>
<span class="udiff-line-added">+         if (!is&lt;Element&gt;(node))</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+         auto&amp; element = downcast&lt;Element&gt;(node);</span>
<span class="udiff-line-added">+         if (isProgramaticallyFocusable(element))</span>
<span class="udiff-line-added">+             return &amp;element;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return nullptr;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void Element::focus(bool restorePreviousSelection, FocusDirection direction)
  {
      if (!isConnected())
          return;
  
<span class="udiff-line-modified-removed">-     if (document().focusedElement() == this) {</span>
<span class="udiff-line-modified-removed">-         if (document().page())</span>
<span class="udiff-line-modified-removed">-             document().page()-&gt;chrome().client().elementDidRefocus(*this);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+     auto document = makeRef(this-&gt;document());</span>
<span class="udiff-line-modified-added">+     if (document-&gt;focusedElement() == this) {</span>
<span class="udiff-line-modified-added">+         if (document-&gt;page())</span>
<span class="udiff-line-modified-added">+             document-&gt;page()-&gt;chrome().client().elementDidRefocus(*this);</span>
          return;
      }
  
<span class="udiff-line-modified-removed">-     // If the stylesheets have already been loaded we can reliably check isFocusable.</span>
<span class="udiff-line-modified-removed">-     // If not, we continue and set the focused node on the focus controller below so</span>
<span class="udiff-line-modified-removed">-     // that it can be updated soon after attach.</span>
<span class="udiff-line-modified-removed">-     if (document().haveStylesheetsLoaded()) {</span>
<span class="udiff-line-modified-removed">-         document().updateStyleIfNeeded();</span>
<span class="udiff-line-modified-removed">-         if (!isFocusable())</span>
<span class="udiff-line-modified-added">+     RefPtr&lt;Element&gt; newTarget = this;</span>
<span class="udiff-line-modified-added">+     if (document-&gt;haveStylesheetsLoaded())</span>
<span class="udiff-line-modified-added">+         document-&gt;updateStyleIfNeeded();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     if (&amp;newTarget-&gt;document() != document.ptr())</span>
<span class="udiff-line-modified-added">+         return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (auto root = shadowRootWithDelegatesFocus(*this)) {</span>
<span class="udiff-line-added">+         auto currentlyFocusedElement = makeRefPtr(document-&gt;focusedElement());</span>
<span class="udiff-line-added">+         if (root-&gt;containsIncludingShadowDOM(currentlyFocusedElement.get())) {</span>
<span class="udiff-line-added">+             if (document-&gt;page())</span>
<span class="udiff-line-added">+                 document-&gt;page()-&gt;chrome().client().elementDidRefocus(*currentlyFocusedElement);</span>
              return;
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+         }</span>
  
<span class="udiff-line-modified-removed">-     if (!supportsFocus())</span>
<span class="udiff-line-modified-added">+         newTarget = findFirstProgramaticallyFocusableElementInComposedTree(*this);</span>
<span class="udiff-line-added">+         if (!newTarget)</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+     } else if (!isProgramaticallyFocusable(*newTarget))</span>
          return;
  
<span class="udiff-line-modified-removed">-     RefPtr&lt;Node&gt; protect;</span>
<span class="udiff-line-modified-removed">-     if (Page* page = document().page()) {</span>
<span class="udiff-line-modified-removed">-         auto&amp; frame = *document().frame();</span>
<span class="udiff-line-removed">-         if (!frame.hasHadUserInteraction() &amp;&amp; !frame.isMainFrame() &amp;&amp; !document().topDocument().securityOrigin().canAccess(document().securityOrigin()))</span>
<span class="udiff-line-modified-added">+     if (Page* page = document-&gt;page()) {</span>
<span class="udiff-line-modified-added">+         auto&amp; frame = *document-&gt;frame();</span>
<span class="udiff-line-modified-added">+         if (!frame.hasHadUserInteraction() &amp;&amp; !frame.isMainFrame() &amp;&amp; !document-&gt;topDocument().securityOrigin().canAccess(document-&gt;securityOrigin()))</span>
              return;
  
          // Focus and change event handlers can cause us to lose our last ref.
          // If a focus event handler changes the focus to a different node it
          // does not make sense to continue and update appearence.
<span class="udiff-line-modified-removed">-         protect = this;</span>
<span class="udiff-line-removed">-         if (!page-&gt;focusController().setFocusedElement(this, *document().frame(), direction))</span>
<span class="udiff-line-modified-added">+         if (!page-&gt;focusController().setFocusedElement(newTarget.get(), *document-&gt;frame(), direction))</span>
              return;
      }
  
      SelectionRevealMode revealMode = SelectionRevealMode::Reveal;
<span class="udiff-line-added">+ </span>
  #if PLATFORM(IOS_FAMILY)
      // Focusing a form element triggers animation in UIKit to scroll to the right position.
      // Calling updateFocusAppearance() would generate an unnecessary call to ScrollView::setScrollPosition(),
      // which would jump us around during this animation. See &lt;rdar://problem/6699741&gt;.
<span class="udiff-line-modified-removed">-     bool isFormControl = is&lt;HTMLFormControlElement&gt;(*this);</span>
<span class="udiff-line-removed">-     if (isFormControl)</span>
<span class="udiff-line-modified-added">+     if (is&lt;HTMLFormControlElement&gt;(newTarget))</span>
          revealMode = SelectionRevealMode::RevealUpToMainFrame;
  #endif
  
      auto target = focusAppearanceUpdateTarget();
      if (!target)
          return;
  
      target-&gt;updateFocusAppearance(restorePreviousSelection ? SelectionRestorationMode::Restore : SelectionRestorationMode::SetDefault, revealMode);
  }
  
<span class="udiff-line-added">+ // https://html.spec.whatwg.org/#focus-processing-model</span>
  RefPtr&lt;Element&gt; Element::focusAppearanceUpdateTarget()
  {
      return this;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3393,32 +3529,45 @@</span>
      if (!data.classList())
          data.setClassList(makeUnique&lt;DOMTokenList&gt;(*this, HTMLNames::classAttr));
      return *data.classList();
  }
  
<span class="udiff-line-added">+ SpaceSplitString Element::partNames() const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return hasRareData() ? elementRareData()-&gt;partNames() : SpaceSplitString();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ DOMTokenList&amp; Element::part()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto&amp; data = ensureElementRareData();</span>
<span class="udiff-line-added">+     if (!data.partList())</span>
<span class="udiff-line-added">+         data.setPartList(makeUnique&lt;DOMTokenList&gt;(*this, HTMLNames::partAttr));</span>
<span class="udiff-line-added">+     return *data.partList();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  DatasetDOMStringMap&amp; Element::dataset()
  {
      ElementRareData&amp; data = ensureElementRareData();
      if (!data.dataset())
          data.setDataset(makeUnique&lt;DatasetDOMStringMap&gt;(*this));
      return *data.dataset();
  }
  
  URL Element::getURLAttribute(const QualifiedName&amp; name) const
  {
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
      if (elementData()) {
          if (const Attribute* attribute = findAttributeByName(name))
              ASSERT(isURLAttribute(*attribute));
      }
  #endif
      return document().completeURL(stripLeadingAndTrailingHTMLSpaces(getAttribute(name)));
  }
  
  URL Element::getNonEmptyURLAttribute(const QualifiedName&amp; name) const
  {
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
      if (elementData()) {
          if (const Attribute* attribute = findAttributeByName(name))
              ASSERT(isURLAttribute(*attribute));
      }
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3458,10 +3607,11 @@</span>
      }
      return true;
  }
  
  #if ENABLE(FULLSCREEN_API)
<span class="udiff-line-added">+ </span>
  static Element* parentCrossingFrameBoundaries(const Element* element)
  {
      ASSERT(element);
      if (auto* parent = element-&gt;parentElementInComposedTree())
          return parent;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3488,13 +3638,15 @@</span>
  {
      Element* element = this;
      while ((element = parentCrossingFrameBoundaries(element)))
          element-&gt;setContainsFullScreenElement(flag);
  }
<span class="udiff-line-added">+ </span>
  #endif
  
  #if ENABLE(POINTER_EVENTS)
<span class="udiff-line-added">+ </span>
  ExceptionOr&lt;void&gt; Element::setPointerCapture(int32_t pointerId)
  {
      if (document().page())
          return document().page()-&gt;pointerCaptureController().setPointerCapture(this, pointerId);
      return { };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3511,21 +3663,25 @@</span>
  {
      if (document().page())
          return document().page()-&gt;pointerCaptureController().hasPointerCapture(this, pointerId);
      return false;
  }
<span class="udiff-line-added">+ </span>
  #endif
  
  #if ENABLE(POINTER_LOCK)
<span class="udiff-line-added">+ </span>
  void Element::requestPointerLock()
  {
      if (document().page())
          document().page()-&gt;pointerLockController().requestPointerLock(this);
  }
<span class="udiff-line-added">+ </span>
  #endif
  
  #if ENABLE(INTERSECTION_OBSERVER)
<span class="udiff-line-added">+ </span>
  void Element::disconnectFromIntersectionObservers()
  {
      auto* observerData = intersectionObserverData();
      if (!observerData)
          return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3549,13 +3705,55 @@</span>
  
  IntersectionObserverData* Element::intersectionObserverData()
  {
      return hasRareData() ? elementRareData()-&gt;intersectionObserverData() : nullptr;
  }
<span class="udiff-line-added">+ </span>
  #endif
  
<span class="udiff-line-added">+ KeyframeEffectStack* Element::keyframeEffectStack() const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return hasRareData() ? elementRareData()-&gt;keyframeEffectStack() : nullptr;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ KeyframeEffectStack&amp; Element::ensureKeyframeEffectStack()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto&amp; rareData = ensureElementRareData();</span>
<span class="udiff-line-added">+     if (!rareData.keyframeEffectStack())</span>
<span class="udiff-line-added">+         rareData.setKeyframeEffectStack(makeUnique&lt;KeyframeEffectStack&gt;());</span>
<span class="udiff-line-added">+     return *rareData.keyframeEffectStack();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool Element::hasKeyframeEffects() const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (!hasRareData())</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto* keyframeEffectStack = elementRareData()-&gt;keyframeEffectStack();</span>
<span class="udiff-line-added">+     return keyframeEffectStack &amp;&amp; keyframeEffectStack-&gt;hasEffects();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ OptionSet&lt;AnimationImpact&gt; Element::applyKeyframeEffects(RenderStyle&amp; targetStyle)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     OptionSet&lt;AnimationImpact&gt; impact;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     for (const auto&amp; effect : ensureKeyframeEffectStack().sortedEffects()) {</span>
<span class="udiff-line-added">+         ASSERT(effect-&gt;animation());</span>
<span class="udiff-line-added">+         effect-&gt;animation()-&gt;resolve(targetStyle);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (effect-&gt;isRunningAccelerated() || effect-&gt;isAboutToRunAccelerated())</span>
<span class="udiff-line-added">+             impact.add(AnimationImpact::RequiresRecomposite);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (effect-&gt;triggersStackingContext())</span>
<span class="udiff-line-added">+             impact.add(AnimationImpact::ForcesStackingContext);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return impact;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  #if ENABLE(RESIZE_OBSERVER)
<span class="udiff-line-added">+ </span>
  void Element::disconnectFromResizeObservers()
  {
      auto* observerData = resizeObserverData();
      if (!observerData)
          return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3575,41 +3773,28 @@</span>
  
  ResizeObserverData* Element::resizeObserverData()
  {
      return hasRareData() ? elementRareData()-&gt;resizeObserverData() : nullptr;
  }
<span class="udiff-line-removed">- #endif</span>
  
<span class="udiff-line-modified-removed">- SpellcheckAttributeState Element::spellcheckAttributeState() const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     const AtomString&amp; value = attributeWithoutSynchronization(HTMLNames::spellcheckAttr);</span>
<span class="udiff-line-removed">-     if (value.isNull())</span>
<span class="udiff-line-removed">-         return SpellcheckAttributeDefault;</span>
<span class="udiff-line-removed">-     if (value.isEmpty() || equalLettersIgnoringASCIICase(value, &quot;true&quot;))</span>
<span class="udiff-line-removed">-         return SpellcheckAttributeTrue;</span>
<span class="udiff-line-removed">-     if (equalLettersIgnoringASCIICase(value, &quot;false&quot;))</span>
<span class="udiff-line-removed">-         return SpellcheckAttributeFalse;</span>
<span class="udiff-line-removed">-     return SpellcheckAttributeDefault;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-modified-added">+ #endif</span>
  
  bool Element::isSpellCheckingEnabled() const
  {
<span class="udiff-line-modified-removed">-     for (const Element* element = this; element; element = element-&gt;parentOrShadowHostElement()) {</span>
<span class="udiff-line-modified-removed">-         switch (element-&gt;spellcheckAttributeState()) {</span>
<span class="udiff-line-modified-removed">-         case SpellcheckAttributeTrue:</span>
<span class="udiff-line-modified-added">+     for (auto* ancestor = this; ancestor; ancestor = ancestor-&gt;parentOrShadowHostElement()) {</span>
<span class="udiff-line-modified-added">+         auto&amp; value = ancestor-&gt;attributeWithoutSynchronization(HTMLNames::spellcheckAttr);</span>
<span class="udiff-line-modified-added">+         if (value.isNull())</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+         if (value.isEmpty() || equalLettersIgnoringASCIICase(value, &quot;true&quot;))</span>
              return true;
<span class="udiff-line-modified-removed">-         case SpellcheckAttributeFalse:</span>
<span class="udiff-line-modified-added">+         if (equalLettersIgnoringASCIICase(value, &quot;false&quot;))</span>
              return false;
<span class="udiff-line-removed">-         case SpellcheckAttributeDefault:</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-         }</span>
      }
<span class="udiff-line-removed">- </span>
      return true;
  }
  
<span class="udiff-line-modified-removed">- #ifndef NDEBUG</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
  bool Element::fastAttributeLookupAllowed(const QualifiedName&amp; name) const
  {
      if (name == HTMLNames::styleAttr)
          return false;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3921,11 +4106,11 @@</span>
  void Element::didDetachRenderers()
  {
      ASSERT(hasCustomStyleResolveCallbacks());
  }
  
<span class="udiff-line-modified-removed">- Optional&lt;ElementStyle&gt; Element::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle*)</span>
<span class="udiff-line-modified-added">+ Optional&lt;Style::ElementStyle&gt; Element::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle*)</span>
  {
      ASSERT(hasCustomStyleResolveCallbacks());
      return WTF::nullopt;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4168,11 +4353,11 @@</span>
      }
  
      return nullptr;
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;WebAnimation&gt;&gt; Element::animate(JSC::ExecState&amp; state, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp; keyframes, Optional&lt;Variant&lt;double, KeyframeAnimationOptions&gt;&gt;&amp;&amp; options)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;WebAnimation&gt;&gt; Element::animate(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp; keyframes, Optional&lt;Variant&lt;double, KeyframeAnimationOptions&gt;&gt;&amp;&amp; options)</span>
  {
      String id = &quot;&quot;;
      Optional&lt;Variant&lt;double, KeyframeEffectOptions&gt;&gt; keyframeEffectOptions;
      if (options) {
          auto optionsValue = options.value();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4185,11 +4370,11 @@</span>
              keyframeEffectOptionsVariant = WTFMove(keyframeEffectOptions);
          }
          keyframeEffectOptions = keyframeEffectOptionsVariant;
      }
  
<span class="udiff-line-modified-removed">-     auto keyframeEffectResult = KeyframeEffect::create(state, this, WTFMove(keyframes), WTFMove(keyframeEffectOptions));</span>
<span class="udiff-line-modified-added">+     auto keyframeEffectResult = KeyframeEffect::create(lexicalGlobalObject, this, WTFMove(keyframes), WTFMove(keyframeEffectOptions));</span>
      if (keyframeEffectResult.hasException())
          return keyframeEffectResult.releaseException();
  
      auto animation = WebAnimation::create(document(), &amp;keyframeEffectResult.returnValue().get());
      animation-&gt;setId(id);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4199,13 +4384,30 @@</span>
          return animationPlayResult.releaseException();
  
      return animation;
  }
  
<span class="udiff-line-modified-removed">- Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; Element::getAnimations()</span>
<span class="udiff-line-modified-removed">- {</span>
<span class="udiff-line-modified-removed">-     // FIXME: Filter and order the list as specified (webkit.org/b/179535).</span>
<span class="udiff-line-modified-added">+ Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; Element::getAnimations(Optional&lt;GetAnimationsOptions&gt; options)</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+     // If we are to return animations in the subtree, we can get all of the document&#39;s animations and filter</span>
<span class="udiff-line-added">+     // animations targeting that are not registered on this element, one of its pseudo elements or a child&#39;s</span>
<span class="udiff-line-added">+     // pseudo element.</span>
<span class="udiff-line-added">+     if (options &amp;&amp; options-&gt;subtree) {</span>
<span class="udiff-line-added">+         Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;</span>
<span class="udiff-line-added">+         for (auto&amp; animation : document().getAnimations()) {</span>
<span class="udiff-line-added">+             auto* effect = animation-&gt;effect();</span>
<span class="udiff-line-added">+             ASSERT(is&lt;KeyframeEffect&gt;(animation-&gt;effect()));</span>
<span class="udiff-line-added">+             auto* target = downcast&lt;KeyframeEffect&gt;(*effect).target();</span>
<span class="udiff-line-added">+             ASSERT(target);</span>
<span class="udiff-line-added">+             if (is&lt;PseudoElement&gt;(target)) {</span>
<span class="udiff-line-added">+                 if (contains(downcast&lt;PseudoElement&gt;(*target).hostElement()))</span>
<span class="udiff-line-added">+                     animations.append(animation);</span>
<span class="udiff-line-added">+             } else if (contains(target))</span>
<span class="udiff-line-added">+                 animations.append(animation);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return animations;</span>
<span class="udiff-line-added">+     }</span>
  
      // For the list of animations to be current, we need to account for any pending CSS changes,
      // such as updates to CSS Animations and CSS Transitions.
      // FIXME: We might be able to use ComputedStyleExtractor which is more optimized.
      document().updateStyleIfNeeded();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4228,10 +4430,11 @@</span>
      rareData.setHasElementIdentifier(true);
      return ElementIdentifier::generate();
  }
  
  #if ENABLE(CSS_TYPED_OM)
<span class="udiff-line-added">+ </span>
  StylePropertyMap* Element::attributeStyleMap()
  {
      if (!hasRareData())
          return nullptr;
      return elementRareData()-&gt;attributeStyleMap();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4239,8 +4442,9 @@</span>
  
  void Element::setAttributeStyleMap(Ref&lt;StylePropertyMap&gt;&amp;&amp; map)
  {
      ensureElementRareData().setAttributeStyleMap(WTFMove(map));
  }
<span class="udiff-line-added">+ </span>
  #endif
  
  } // namespace WebCore
</pre>
<center><a href="DocumentStorageAccess.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Element.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
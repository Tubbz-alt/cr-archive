<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLCanvasElement.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLCanvasElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLCanvasElement.idl.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLCanvasElement.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #pragma once
 29 
 30 #include &quot;CanvasBase.h&quot;
 31 #include &quot;FloatRect.h&quot;
 32 #include &quot;HTMLElement.h&quot;
 33 #include &quot;ImageBitmapRenderingContextSettings.h&quot;
<span class="line-removed"> 34 #include &quot;IntSize.h&quot;</span>
 35 #include &lt;memory&gt;
 36 #include &lt;wtf/Forward.h&gt;
 37 
 38 #if ENABLE(WEBGL)
 39 #include &quot;WebGLContextAttributes.h&quot;
 40 #endif
 41 
 42 namespace WebCore {
 43 
 44 class BlobCallback;

 45 class CanvasRenderingContext2D;
 46 class GraphicsContext;
<span class="line-removed"> 47 class GraphicsContextStateSaver;</span>
 48 class Image;
 49 class ImageBuffer;
 50 class ImageData;
 51 class MediaSample;
 52 class MediaStream;
 53 class WebGLRenderingContextBase;
 54 class GPUCanvasContext;
 55 struct UncachedString;
 56 
 57 namespace DisplayList {
 58 using AsTextFlags = unsigned;
 59 }
 60 
 61 class HTMLCanvasElement final : public HTMLElement, public CanvasBase {
 62     WTF_MAKE_ISO_ALLOCATED(HTMLCanvasElement);
 63 public:
 64     static Ref&lt;HTMLCanvasElement&gt; create(Document&amp;);
 65     static Ref&lt;HTMLCanvasElement&gt; create(const QualifiedName&amp;, Document&amp;);
 66     virtual ~HTMLCanvasElement();
 67 
<span class="line-removed"> 68     unsigned width() const final { return size().width(); }</span>
<span class="line-removed"> 69     unsigned height() const final { return size().height(); }</span>
<span class="line-removed"> 70 </span>
 71     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setWidth(unsigned);
 72     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setHeight(unsigned);
 73 
<span class="line-modified"> 74     const IntSize&amp; size() const final { return m_size; }</span>
<span class="line-removed"> 75 </span>
<span class="line-removed"> 76     void setSize(const IntSize&amp; newSize) override</span>
<span class="line-removed"> 77     {</span>
<span class="line-removed"> 78         if (newSize == size())</span>
<span class="line-removed"> 79             return;</span>
<span class="line-removed"> 80         m_ignoreReset = true;</span>
<span class="line-removed"> 81         setWidth(newSize.width());</span>
<span class="line-removed"> 82         setHeight(newSize.height());</span>
<span class="line-removed"> 83         m_ignoreReset = false;</span>
<span class="line-removed"> 84         reset();</span>
<span class="line-removed"> 85     }</span>
 86 
<span class="line-modified"> 87     ExceptionOr&lt;Optional&lt;RenderingContext&gt;&gt; getContext(JSC::ExecState&amp;, const String&amp; contextId, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments);</span>

 88 
 89     CanvasRenderingContext* getContext(const String&amp;);
 90 
 91     static bool is2dType(const String&amp;);
 92     CanvasRenderingContext2D* createContext2d(const String&amp; type);
 93     CanvasRenderingContext2D* getContext2d(const String&amp;);
 94 
 95 #if ENABLE(WEBGL)
 96     static bool isWebGLType(const String&amp;);
 97     WebGLRenderingContextBase* createContextWebGL(const String&amp;, WebGLContextAttributes&amp;&amp; = { });
 98     WebGLRenderingContextBase* getContextWebGL(const String&amp;, WebGLContextAttributes&amp;&amp; = { });
 99 #endif
100 #if ENABLE(WEBGPU)
101     static bool isWebGPUType(const String&amp;);
102     GPUCanvasContext* createContextWebGPU(const String&amp;);
103     GPUCanvasContext* getContextWebGPU(const String&amp;);
104 #endif
105 
106     static bool isBitmapRendererType(const String&amp;);
107     ImageBitmapRenderingContext* createContextBitmapRenderer(const String&amp;, ImageBitmapRenderingContextSettings&amp;&amp; = { });
108     ImageBitmapRenderingContext* getContextBitmapRenderer(const String&amp;, ImageBitmapRenderingContextSettings&amp;&amp; = { });
109 
110     WEBCORE_EXPORT ExceptionOr&lt;UncachedString&gt; toDataURL(const String&amp; mimeType, JSC::JSValue quality);
111     WEBCORE_EXPORT ExceptionOr&lt;UncachedString&gt; toDataURL(const String&amp; mimeType);
112     ExceptionOr&lt;void&gt; toBlob(ScriptExecutionContext&amp;, Ref&lt;BlobCallback&gt;&amp;&amp;, const String&amp; mimeType, JSC::JSValue quality);
113 
114     // Used for rendering
115     void didDraw(const FloatRect&amp;) final;
116 
117     void paint(GraphicsContext&amp;, const LayoutRect&amp;);
118 
<span class="line-removed">119     GraphicsContext* drawingContext() const final;</span>
<span class="line-removed">120     GraphicsContext* existingDrawingContext() const final;</span>
<span class="line-removed">121 </span>
122 #if ENABLE(MEDIA_STREAM)
123     RefPtr&lt;MediaSample&gt; toMediaSample();
124     ExceptionOr&lt;Ref&lt;MediaStream&gt;&gt; captureStream(Document&amp;, Optional&lt;double&gt;&amp;&amp; frameRequestRate);
125 #endif
126 
<span class="line-removed">127     ImageBuffer* buffer() const;</span>
128     Image* copiedImage() const final;
129     void clearCopiedImage();
130     RefPtr&lt;ImageData&gt; getImageData();
131     void makePresentationCopy();
132     void clearPresentationCopy();
133 
134     SecurityOrigin* securityOrigin() const final;
135 
<span class="line-removed">136     AffineTransform baseTransform() const final;</span>
<span class="line-removed">137 </span>
<span class="line-removed">138     void makeRenderingResultsAvailable() final;</span>
<span class="line-removed">139     bool hasCreatedImageBuffer() const { return m_hasCreatedImageBuffer; }</span>
<span class="line-removed">140 </span>
141     bool shouldAccelerate(const IntSize&amp;) const;
142 
143     WEBCORE_EXPORT void setUsesDisplayListDrawing(bool);
144     WEBCORE_EXPORT void setTracksDisplayListReplay(bool);
145     WEBCORE_EXPORT String displayListAsText(DisplayList::AsTextFlags) const;
146     WEBCORE_EXPORT String replayDisplayListAsText(DisplayList::AsTextFlags) const;
147 
<span class="line-removed">148     size_t memoryCost() const;</span>
<span class="line-removed">149     size_t externalMemoryCost() const;</span>
<span class="line-removed">150 </span>
151     // FIXME: Only some canvas rendering contexts need an ImageBuffer.
152     // It would be better to have the contexts own the buffers.
153     void setImageBufferAndMarkDirty(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp;);
154 


155 private:
156     HTMLCanvasElement(const QualifiedName&amp;, Document&amp;);
157 
158     bool isHTMLCanvasElement() const final { return true; }
159 
160     void parseAttribute(const QualifiedName&amp;, const AtomString&amp;) final;
161     RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;) final;
162 
163     bool canContainRangeEndPoint() const final;
164     bool canStartSelection() const final;
165 
166     void reset();
167 
<span class="line-modified">168     void createImageBuffer() const;</span>
169     void clearImageBuffer() const;
170 


171     void setSurfaceSize(const IntSize&amp;);
<span class="line-removed">172     void setImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp;) const;</span>
<span class="line-removed">173     void releaseImageBufferAndContext();</span>
174 
175     bool paintsIntoCanvasBuffer() const;
176 
177     bool isGPUBased() const;
178 
179     void refCanvasBase() final { HTMLElement::ref(); }
180     void derefCanvasBase() final { HTMLElement::deref(); }
181 
182     ScriptExecutionContext* canvasBaseScriptExecutionContext() const final { return HTMLElement::scriptExecutionContext(); }
183 
184     FloatRect m_dirtyRect;
<span class="line-removed">185     mutable IntSize m_size;</span>
186 
187     bool m_ignoreReset { false };
188 
189     bool m_usesDisplayListDrawing { false };
190     bool m_tracksDisplayListReplay { false };
191 
<span class="line-modified">192     mutable Lock m_imageBufferAssignmentLock;</span>
193 
<span class="line-modified">194     // m_createdImageBuffer means we tried to malloc the buffer.  We didn&#39;t necessarily get it.</span>
195     mutable bool m_hasCreatedImageBuffer { false };
196     mutable bool m_didClearImageBuffer { false };
<span class="line-removed">197     mutable std::unique_ptr&lt;ImageBuffer&gt; m_imageBuffer;</span>
<span class="line-removed">198     mutable std::unique_ptr&lt;GraphicsContextStateSaver&gt; m_contextStateSaver;</span>
199 
200     mutable RefPtr&lt;Image&gt; m_presentedImage;
201     mutable RefPtr&lt;Image&gt; m_copiedImage; // FIXME: This is temporary for platforms that have to copy the image buffer to render (and for CSSCanvasValue).
202 };
203 
204 } // namespace WebCore
205 
206 namespace WTF {
207 template&lt;typename ArgType&gt; class TypeCastTraits&lt;const WebCore::HTMLCanvasElement, ArgType, false /* isBaseType */&gt; {
208 public:
209     static bool isOfType(ArgType&amp; node) { return checkTagName(node); }
210 private:
211     static bool checkTagName(const WebCore::CanvasBase&amp; base) { return base.isHTMLCanvasElement(); }
212     static bool checkTagName(const WebCore::HTMLElement&amp; element) { return element.hasTagName(WebCore::HTMLNames::canvasTag); }
213     static bool checkTagName(const WebCore::Node&amp; node) { return node.hasTagName(WebCore::HTMLNames::canvasTag); }
214     static bool checkTagName(const WebCore::EventTarget&amp; target) { return is&lt;WebCore::Node&gt;(target) &amp;&amp; checkTagName(downcast&lt;WebCore::Node&gt;(target)); }
215 };
216 }
217 
</pre>
</td>
<td>
<hr />
<pre>
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #pragma once
 29 
 30 #include &quot;CanvasBase.h&quot;
 31 #include &quot;FloatRect.h&quot;
 32 #include &quot;HTMLElement.h&quot;
 33 #include &quot;ImageBitmapRenderingContextSettings.h&quot;

 34 #include &lt;memory&gt;
 35 #include &lt;wtf/Forward.h&gt;
 36 
 37 #if ENABLE(WEBGL)
 38 #include &quot;WebGLContextAttributes.h&quot;
 39 #endif
 40 
 41 namespace WebCore {
 42 
 43 class BlobCallback;
<span class="line-added"> 44 class CanvasRenderingContext;</span>
 45 class CanvasRenderingContext2D;
 46 class GraphicsContext;

 47 class Image;
 48 class ImageBuffer;
 49 class ImageData;
 50 class MediaSample;
 51 class MediaStream;
 52 class WebGLRenderingContextBase;
 53 class GPUCanvasContext;
 54 struct UncachedString;
 55 
 56 namespace DisplayList {
 57 using AsTextFlags = unsigned;
 58 }
 59 
 60 class HTMLCanvasElement final : public HTMLElement, public CanvasBase {
 61     WTF_MAKE_ISO_ALLOCATED(HTMLCanvasElement);
 62 public:
 63     static Ref&lt;HTMLCanvasElement&gt; create(Document&amp;);
 64     static Ref&lt;HTMLCanvasElement&gt; create(const QualifiedName&amp;, Document&amp;);
 65     virtual ~HTMLCanvasElement();
 66 



 67     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setWidth(unsigned);
 68     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setHeight(unsigned);
 69 
<span class="line-modified"> 70     void setSize(const IntSize&amp; newSize) override;</span>











 71 
<span class="line-modified"> 72     CanvasRenderingContext* renderingContext() const final { return m_context.get(); }</span>
<span class="line-added"> 73     ExceptionOr&lt;Optional&lt;RenderingContext&gt;&gt; getContext(JSC::JSGlobalObject&amp;, const String&amp; contextId, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments);</span>
 74 
 75     CanvasRenderingContext* getContext(const String&amp;);
 76 
 77     static bool is2dType(const String&amp;);
 78     CanvasRenderingContext2D* createContext2d(const String&amp; type);
 79     CanvasRenderingContext2D* getContext2d(const String&amp;);
 80 
 81 #if ENABLE(WEBGL)
 82     static bool isWebGLType(const String&amp;);
 83     WebGLRenderingContextBase* createContextWebGL(const String&amp;, WebGLContextAttributes&amp;&amp; = { });
 84     WebGLRenderingContextBase* getContextWebGL(const String&amp;, WebGLContextAttributes&amp;&amp; = { });
 85 #endif
 86 #if ENABLE(WEBGPU)
 87     static bool isWebGPUType(const String&amp;);
 88     GPUCanvasContext* createContextWebGPU(const String&amp;);
 89     GPUCanvasContext* getContextWebGPU(const String&amp;);
 90 #endif
 91 
 92     static bool isBitmapRendererType(const String&amp;);
 93     ImageBitmapRenderingContext* createContextBitmapRenderer(const String&amp;, ImageBitmapRenderingContextSettings&amp;&amp; = { });
 94     ImageBitmapRenderingContext* getContextBitmapRenderer(const String&amp;, ImageBitmapRenderingContextSettings&amp;&amp; = { });
 95 
 96     WEBCORE_EXPORT ExceptionOr&lt;UncachedString&gt; toDataURL(const String&amp; mimeType, JSC::JSValue quality);
 97     WEBCORE_EXPORT ExceptionOr&lt;UncachedString&gt; toDataURL(const String&amp; mimeType);
 98     ExceptionOr&lt;void&gt; toBlob(ScriptExecutionContext&amp;, Ref&lt;BlobCallback&gt;&amp;&amp;, const String&amp; mimeType, JSC::JSValue quality);
 99 
100     // Used for rendering
101     void didDraw(const FloatRect&amp;) final;
102 
103     void paint(GraphicsContext&amp;, const LayoutRect&amp;);
104 



105 #if ENABLE(MEDIA_STREAM)
106     RefPtr&lt;MediaSample&gt; toMediaSample();
107     ExceptionOr&lt;Ref&lt;MediaStream&gt;&gt; captureStream(Document&amp;, Optional&lt;double&gt;&amp;&amp; frameRequestRate);
108 #endif
109 

110     Image* copiedImage() const final;
111     void clearCopiedImage();
112     RefPtr&lt;ImageData&gt; getImageData();
113     void makePresentationCopy();
114     void clearPresentationCopy();
115 
116     SecurityOrigin* securityOrigin() const final;
117 





118     bool shouldAccelerate(const IntSize&amp;) const;
119 
120     WEBCORE_EXPORT void setUsesDisplayListDrawing(bool);
121     WEBCORE_EXPORT void setTracksDisplayListReplay(bool);
122     WEBCORE_EXPORT String displayListAsText(DisplayList::AsTextFlags) const;
123     WEBCORE_EXPORT String replayDisplayListAsText(DisplayList::AsTextFlags) const;
124 



125     // FIXME: Only some canvas rendering contexts need an ImageBuffer.
126     // It would be better to have the contexts own the buffers.
127     void setImageBufferAndMarkDirty(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp;);
128 
<span class="line-added">129     WEBCORE_EXPORT static void setMaxPixelMemoryForTesting(size_t);</span>
<span class="line-added">130 </span>
131 private:
132     HTMLCanvasElement(const QualifiedName&amp;, Document&amp;);
133 
134     bool isHTMLCanvasElement() const final { return true; }
135 
136     void parseAttribute(const QualifiedName&amp;, const AtomString&amp;) final;
137     RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;) final;
138 
139     bool canContainRangeEndPoint() const final;
140     bool canStartSelection() const final;
141 
142     void reset();
143 
<span class="line-modified">144     void createImageBuffer() const final;</span>
145     void clearImageBuffer() const;
146 
<span class="line-added">147     bool hasCreatedImageBuffer() const final { return m_hasCreatedImageBuffer; }</span>
<span class="line-added">148 </span>
149     void setSurfaceSize(const IntSize&amp;);


150 
151     bool paintsIntoCanvasBuffer() const;
152 
153     bool isGPUBased() const;
154 
155     void refCanvasBase() final { HTMLElement::ref(); }
156     void derefCanvasBase() final { HTMLElement::deref(); }
157 
158     ScriptExecutionContext* canvasBaseScriptExecutionContext() const final { return HTMLElement::scriptExecutionContext(); }
159 
160     FloatRect m_dirtyRect;

161 
162     bool m_ignoreReset { false };
163 
164     bool m_usesDisplayListDrawing { false };
165     bool m_tracksDisplayListReplay { false };
166 
<span class="line-modified">167     std::unique_ptr&lt;CanvasRenderingContext&gt; m_context;</span>
168 
<span class="line-modified">169     // m_hasCreatedImageBuffer means we tried to malloc the buffer. We didn&#39;t necessarily get it.</span>
170     mutable bool m_hasCreatedImageBuffer { false };
171     mutable bool m_didClearImageBuffer { false };


172 
173     mutable RefPtr&lt;Image&gt; m_presentedImage;
174     mutable RefPtr&lt;Image&gt; m_copiedImage; // FIXME: This is temporary for platforms that have to copy the image buffer to render (and for CSSCanvasValue).
175 };
176 
177 } // namespace WebCore
178 
179 namespace WTF {
180 template&lt;typename ArgType&gt; class TypeCastTraits&lt;const WebCore::HTMLCanvasElement, ArgType, false /* isBaseType */&gt; {
181 public:
182     static bool isOfType(ArgType&amp; node) { return checkTagName(node); }
183 private:
184     static bool checkTagName(const WebCore::CanvasBase&amp; base) { return base.isHTMLCanvasElement(); }
185     static bool checkTagName(const WebCore::HTMLElement&amp; element) { return element.hasTagName(WebCore::HTMLNames::canvasTag); }
186     static bool checkTagName(const WebCore::Node&amp; node) { return node.hasTagName(WebCore::HTMLNames::canvasTag); }
187     static bool checkTagName(const WebCore::EventTarget&amp; target) { return is&lt;WebCore::Node&gt;(target) &amp;&amp; checkTagName(downcast&lt;WebCore::Node&gt;(target)); }
188 };
189 }
190 
</pre>
</td>
</tr>
</table>
<center><a href="HTMLCanvasElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLCanvasElement.idl.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/xml/XMLHttpRequest.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="XMLHttpRequest.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="XMLHttpRequestProgressEvent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/xml/XMLHttpRequest.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
120 
121     XMLHttpRequestUpload&amp; upload();
122     XMLHttpRequestUpload* optionalUpload() const { return m_upload.get(); }
123 
124     const ResourceResponse&amp; resourceResponse() const { return m_response; }
125 
126     using RefCounted&lt;XMLHttpRequest&gt;::ref;
127     using RefCounted&lt;XMLHttpRequest&gt;::deref;
128 
129     size_t memoryCost() const;
130 
131     WEBCORE_EXPORT void setMaximumIntervalForUserGestureForwarding(double);
132 
133 private:
134     explicit XMLHttpRequest(ScriptExecutionContext&amp;);
135 
136     TextEncoding finalResponseCharset() const;
137 
138     // ActiveDOMObject
139     void contextDestroyed() override;
<span class="line-removed">140     bool canSuspendForDocumentSuspension() const override;</span>
141     void suspend(ReasonForSuspension) override;
142     void resume() override;
143     void stop() override;
144     const char* activeDOMObjectName() const override;
145 
146     void refEventTarget() override { ref(); }
147     void derefEventTarget() override { deref(); }
148 
149     Document* document() const;
150     SecurityOrigin* securityOrigin() const;
151 
152     // ThreadableLoaderClient
153     void didSendData(unsigned long long bytesSent, unsigned long long totalBytesToBeSent) override;
154     void didReceiveResponse(unsigned long identifier, const ResourceResponse&amp;) override;
155     void didReceiveData(const char* data, int dataLength) override;
156     void didFinishLoading(unsigned long identifier) override;
157     void didFail(const ResourceError&amp;) override;
158 
159     bool responseIsXML() const;
160 
</pre>
<hr />
<pre>
172 
173     // Returns false when cancelling the loader within internalAbort() triggers an event whose callback creates a new loader.
174     // In that case, the function calling internalAbort should exit.
175     bool internalAbort();
176 
177     void clearResponse();
178     void clearResponseBuffers();
179     void clearRequest();
180 
181     ExceptionOr&lt;void&gt; createRequest();
182 
183     void genericError();
184     void networkError();
185     void abortError();
186 
187     void dispatchErrorEvents(const AtomString&amp;);
188 
189     using EventTarget::dispatchEvent;
190     void dispatchEvent(Event&amp;) override;
191 
<span class="line-removed">192     void resumeTimerFired();</span>
193     Ref&lt;TextResourceDecoder&gt; createDecoder() const;
194 
195     void networkErrorTimerFired();
196 
197     unsigned m_async : 1;
198     unsigned m_includeCredentials : 1;
199     unsigned m_sendFlag : 1;
200     unsigned m_createdDocument : 1;
201     unsigned m_error : 1;
202     unsigned m_uploadListenerFlag : 1;
203     unsigned m_uploadComplete : 1;
204     unsigned m_wasAbortedByClient : 1;
205     unsigned m_responseCacheIsValid : 1;
<span class="line-removed">206     unsigned m_dispatchErrorOnResuming : 1;</span>
207     unsigned m_readyState : 3; // State
208     unsigned m_responseType : 3; // ResponseType
209 
210     unsigned m_timeoutMilliseconds { 0 };
211 
212     std::unique_ptr&lt;XMLHttpRequestUpload&gt; m_upload;
213 
214     URL m_url;
215     String m_method;
216     HTTPHeaderMap m_requestHeaders;
217     RefPtr&lt;FormData&gt; m_requestEntityBody;
218     String m_mimeTypeOverride;
219 
220     RefPtr&lt;ThreadableLoader&gt; m_loader;
221 
222     String m_responseEncoding;
223 
224     ResourceResponse m_response;
225 
226     RefPtr&lt;TextResourceDecoder&gt; m_decoder;
227 
228     RefPtr&lt;Document&gt; m_responseDocument;
229 
230     RefPtr&lt;SharedBuffer&gt; m_binaryResponseBuilder;
231 
232     StringBuilder m_responseBuilder;
233 
234     // Used for progress event tracking.
235     long long m_receivedLength { 0 };
236 
237     XMLHttpRequestProgressEventThrottle m_progressEventThrottle;
238 
239     mutable String m_allResponseHeaders;
240 
<span class="line-removed">241     Timer m_resumeTimer;</span>
242     Timer m_networkErrorTimer;
243     Timer m_timeoutTimer;
244 
245     MonotonicTime m_sendingTime;
246 
247     Optional&lt;ExceptionCode&gt; m_exceptionCode;
248     RefPtr&lt;UserGestureToken&gt; m_userGestureToken;
249     Seconds m_maximumIntervalForUserGestureForwarding;
250 };
251 
252 inline auto XMLHttpRequest::responseType() const -&gt; ResponseType
253 {
254     return static_cast&lt;ResponseType&gt;(m_responseType);
255 }
256 
257 inline auto XMLHttpRequest::readyState() const -&gt; State
258 {
259     return static_cast&lt;State&gt;(m_readyState);
260 }
261 
</pre>
</td>
<td>
<hr />
<pre>
120 
121     XMLHttpRequestUpload&amp; upload();
122     XMLHttpRequestUpload* optionalUpload() const { return m_upload.get(); }
123 
124     const ResourceResponse&amp; resourceResponse() const { return m_response; }
125 
126     using RefCounted&lt;XMLHttpRequest&gt;::ref;
127     using RefCounted&lt;XMLHttpRequest&gt;::deref;
128 
129     size_t memoryCost() const;
130 
131     WEBCORE_EXPORT void setMaximumIntervalForUserGestureForwarding(double);
132 
133 private:
134     explicit XMLHttpRequest(ScriptExecutionContext&amp;);
135 
136     TextEncoding finalResponseCharset() const;
137 
138     // ActiveDOMObject
139     void contextDestroyed() override;

140     void suspend(ReasonForSuspension) override;
141     void resume() override;
142     void stop() override;
143     const char* activeDOMObjectName() const override;
144 
145     void refEventTarget() override { ref(); }
146     void derefEventTarget() override { deref(); }
147 
148     Document* document() const;
149     SecurityOrigin* securityOrigin() const;
150 
151     // ThreadableLoaderClient
152     void didSendData(unsigned long long bytesSent, unsigned long long totalBytesToBeSent) override;
153     void didReceiveResponse(unsigned long identifier, const ResourceResponse&amp;) override;
154     void didReceiveData(const char* data, int dataLength) override;
155     void didFinishLoading(unsigned long identifier) override;
156     void didFail(const ResourceError&amp;) override;
157 
158     bool responseIsXML() const;
159 
</pre>
<hr />
<pre>
171 
172     // Returns false when cancelling the loader within internalAbort() triggers an event whose callback creates a new loader.
173     // In that case, the function calling internalAbort should exit.
174     bool internalAbort();
175 
176     void clearResponse();
177     void clearResponseBuffers();
178     void clearRequest();
179 
180     ExceptionOr&lt;void&gt; createRequest();
181 
182     void genericError();
183     void networkError();
184     void abortError();
185 
186     void dispatchErrorEvents(const AtomString&amp;);
187 
188     using EventTarget::dispatchEvent;
189     void dispatchEvent(Event&amp;) override;
190 

191     Ref&lt;TextResourceDecoder&gt; createDecoder() const;
192 
193     void networkErrorTimerFired();
194 
195     unsigned m_async : 1;
196     unsigned m_includeCredentials : 1;
197     unsigned m_sendFlag : 1;
198     unsigned m_createdDocument : 1;
199     unsigned m_error : 1;
200     unsigned m_uploadListenerFlag : 1;
201     unsigned m_uploadComplete : 1;
202     unsigned m_wasAbortedByClient : 1;
203     unsigned m_responseCacheIsValid : 1;

204     unsigned m_readyState : 3; // State
205     unsigned m_responseType : 3; // ResponseType
206 
207     unsigned m_timeoutMilliseconds { 0 };
208 
209     std::unique_ptr&lt;XMLHttpRequestUpload&gt; m_upload;
210 
211     URL m_url;
212     String m_method;
213     HTTPHeaderMap m_requestHeaders;
214     RefPtr&lt;FormData&gt; m_requestEntityBody;
215     String m_mimeTypeOverride;
216 
217     RefPtr&lt;ThreadableLoader&gt; m_loader;
218 
219     String m_responseEncoding;
220 
221     ResourceResponse m_response;
222 
223     RefPtr&lt;TextResourceDecoder&gt; m_decoder;
224 
225     RefPtr&lt;Document&gt; m_responseDocument;
226 
227     RefPtr&lt;SharedBuffer&gt; m_binaryResponseBuilder;
228 
229     StringBuilder m_responseBuilder;
230 
231     // Used for progress event tracking.
232     long long m_receivedLength { 0 };
233 
234     XMLHttpRequestProgressEventThrottle m_progressEventThrottle;
235 
236     mutable String m_allResponseHeaders;
237 

238     Timer m_networkErrorTimer;
239     Timer m_timeoutTimer;
240 
241     MonotonicTime m_sendingTime;
242 
243     Optional&lt;ExceptionCode&gt; m_exceptionCode;
244     RefPtr&lt;UserGestureToken&gt; m_userGestureToken;
245     Seconds m_maximumIntervalForUserGestureForwarding;
246 };
247 
248 inline auto XMLHttpRequest::responseType() const -&gt; ResponseType
249 {
250     return static_cast&lt;ResponseType&gt;(m_responseType);
251 }
252 
253 inline auto XMLHttpRequest::readyState() const -&gt; State
254 {
255     return static_cast&lt;State&gt;(m_readyState);
256 }
257 
</pre>
</td>
</tr>
</table>
<center><a href="XMLHttpRequest.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="XMLHttpRequestProgressEvent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
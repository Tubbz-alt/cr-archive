<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/WeakMapImpl.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.
  3  * Copyright (C) 2017 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;ExceptionHelpers.h&quot;
 30 #include &quot;HashMapImpl.h&quot;
 31 #include &quot;JSObject.h&quot;
 32 #include &lt;wtf/JSValueMalloc.h&gt;
 33 #include &lt;wtf/MallocPtr.h&gt;
 34 
 35 namespace JSC {
 36 
 37 struct WeakMapBucketDataKey {
 38     static const HashTableType Type = HashTableType::Key;
 39     WriteBarrier&lt;JSObject&gt; key;
 40 };
 41 static_assert(sizeof(WeakMapBucketDataKey) == sizeof(void*), &quot;&quot;);
 42 
 43 struct WeakMapBucketDataKeyValue {
 44     static const HashTableType Type = HashTableType::KeyValue;
 45     WriteBarrier&lt;JSObject&gt; key;
 46 #if USE(JSVALUE32_64)
 47     uint32_t padding;
 48 #endif
 49     WriteBarrier&lt;Unknown&gt; value;
 50 };
 51 static_assert(sizeof(WeakMapBucketDataKeyValue) == 16, &quot;&quot;);
 52 
 53 ALWAYS_INLINE uint32_t jsWeakMapHash(JSObject* key)
 54 {
 55     return wangsInt64Hash(JSValue::encode(key));
 56 }
 57 
 58 ALWAYS_INLINE uint32_t nextCapacityAfterBatchRemoval(uint32_t capacity, uint32_t keyCount)
 59 {
 60     while (shouldShrink(capacity, keyCount))
 61         capacity = nextCapacity(capacity, keyCount);
 62     return capacity;
 63 }
 64 
 65 template &lt;typename Data&gt;
 66 class WeakMapBucket {
 67 public:
 68     ALWAYS_INLINE void setKey(VM&amp; vm, JSCell* owner, JSObject* key)
 69     {
 70         m_data.key.set(vm, owner, key);
 71     }
 72 
 73     template &lt;typename T = Data&gt;
 74     ALWAYS_INLINE typename std::enable_if&lt;std::is_same&lt;T, WeakMapBucketDataKeyValue&gt;::value&gt;::type setValue(VM&amp; vm, JSCell* owner, JSValue value)
 75     {
 76         m_data.value.set(vm, owner, value);
 77     }
 78     template &lt;typename T = Data&gt;
 79     ALWAYS_INLINE typename std::enable_if&lt;std::is_same&lt;T, WeakMapBucketDataKey&gt;::value&gt;::type setValue(VM&amp;, JSCell*, JSValue) { }
 80 
 81     ALWAYS_INLINE JSObject* key() const { return m_data.key.get(); }
 82 
 83     template &lt;typename T = Data&gt;
 84     ALWAYS_INLINE typename std::enable_if&lt;std::is_same&lt;T, WeakMapBucketDataKeyValue&gt;::value, JSValue&gt;::type value() const
 85     {
 86         return m_data.value.get();
 87     }
 88     template &lt;typename T = Data&gt;
 89     ALWAYS_INLINE typename std::enable_if&lt;std::is_same&lt;T, WeakMapBucketDataKey&gt;::value, JSValue&gt;::type value() const { return JSValue(); }
 90 
 91     template &lt;typename T = Data&gt;
 92     ALWAYS_INLINE typename std::enable_if&lt;std::is_same&lt;T, WeakMapBucketDataKeyValue&gt;::value&gt;::type copyFrom(const WeakMapBucket&amp; from)
 93     {
 94         m_data.key.copyFrom(from.m_data.key);
 95         m_data.value.setWithoutWriteBarrier(from.m_data.value.get());
 96     }
 97     template &lt;typename T = Data&gt;
 98     ALWAYS_INLINE typename std::enable_if&lt;std::is_same&lt;T, WeakMapBucketDataKey&gt;::value&gt;::type copyFrom(const WeakMapBucket&amp; from)
 99     {
100         m_data.key.copyFrom(from.m_data.key);
101     }
102 
103     static ptrdiff_t offsetOfKey()
104     {
105         return OBJECT_OFFSETOF(WeakMapBucket, m_data) + OBJECT_OFFSETOF(Data, key);
106     }
107 
108     template &lt;typename T = Data&gt;
109     static typename std::enable_if&lt;std::is_same&lt;T, WeakMapBucketDataKeyValue&gt;::value, ptrdiff_t&gt;::type offsetOfValue()
110     {
111         return OBJECT_OFFSETOF(WeakMapBucket, m_data) + OBJECT_OFFSETOF(Data, value);
112     }
113 
114     template &lt;typename T = Data&gt;
115     ALWAYS_INLINE static typename std::enable_if&lt;std::is_same&lt;T, WeakMapBucketDataKeyValue&gt;::value, JSValue&gt;::type extractValue(const WeakMapBucket&amp; bucket)
116     {
117         return bucket.value();
118     }
119 
120     template &lt;typename T = Data&gt;
121     ALWAYS_INLINE static typename std::enable_if&lt;std::is_same&lt;T, WeakMapBucketDataKey&gt;::value, JSValue&gt;::type extractValue(const WeakMapBucket&amp;)
122     {
123         return JSValue();
124     }
125 
126     bool isEmpty()
127     {
128         return !m_data.key.unvalidatedGet();
129     }
130 
131     static JSObject* deletedKey()
132     {
133         return bitwise_cast&lt;JSObject*&gt;(static_cast&lt;uintptr_t&gt;(-3));
134     }
135 
136     bool isDeleted()
137     {
138         return m_data.key.unvalidatedGet() == deletedKey();
139     }
140 
141     void makeDeleted()
142     {
143         m_data.key.setWithoutWriteBarrier(deletedKey());
144         clearValue();
145     }
146 
147     template &lt;typename T = Data&gt;
148     ALWAYS_INLINE typename std::enable_if&lt;std::is_same&lt;T, WeakMapBucketDataKeyValue&gt;::value&gt;::type visitAggregate(SlotVisitor&amp; visitor)
149     {
150         visitor.append(m_data.value);
151     }
152 
153 private:
154     template &lt;typename T = Data&gt;
155     ALWAYS_INLINE typename std::enable_if&lt;std::is_same&lt;T, WeakMapBucketDataKeyValue&gt;::value&gt;::type clearValue()
156     {
157         m_data.value.clear();
158     }
159     template &lt;typename T = Data&gt;
160     ALWAYS_INLINE typename std::enable_if&lt;std::is_same&lt;T, WeakMapBucketDataKey&gt;::value&gt;::type clearValue() { }
161 
162     Data m_data;
163 };
164 
165 template &lt;typename BucketType&gt;
166 class WeakMapBuffer {
167 public:
168     WeakMapBuffer() = delete;
169 
170     static size_t allocationSize(Checked&lt;size_t&gt; capacity)
171     {
172         return (capacity * sizeof(BucketType)).unsafeGet();
173     }
174 
175     ALWAYS_INLINE BucketType* buffer() const
176     {
177         return bitwise_cast&lt;BucketType*&gt;(this);
178     }
179 
180     static MallocPtr&lt;WeakMapBuffer, JSValueMalloc&gt; create(uint32_t capacity)
181     {
182         size_t allocationSize = WeakMapBuffer::allocationSize(capacity);
183         auto buffer = MallocPtr&lt;WeakMapBuffer, JSValueMalloc&gt;::malloc(allocationSize);
184         buffer-&gt;reset(capacity);
185         return buffer;
186     }
187 
188     ALWAYS_INLINE void reset(uint32_t capacity)
189     {
190         memset(this, 0, allocationSize(capacity));
191     }
192 };
193 
194 template &lt;typename WeakMapBucketType&gt;
<a name="1" id="anc1"></a><span class="line-modified">195 class WeakMapImpl : public JSNonFinalObject {</span>
<span class="line-modified">196     using Base = JSNonFinalObject;</span>
197     using WeakMapBufferType = WeakMapBuffer&lt;WeakMapBucketType&gt;;
198 
199 public:
200     using BucketType = WeakMapBucketType;
201 
<a name="2" id="anc2"></a><span class="line-added">202     static constexpr bool needsDestruction = true;</span>
203     static void destroy(JSCell*);
204 
205     static void visitChildren(JSCell*, SlotVisitor&amp;);
206 
207     static size_t estimatedSize(JSCell*, VM&amp;);
208 
209     WeakMapImpl(VM&amp; vm, Structure* structure)
210         : Base(vm, structure)
211     {
212     }
213 
214     static constexpr uint32_t initialCapacity = 4;
215 
216     void finishCreation(VM&amp; vm)
217     {
218         ASSERT_WITH_MESSAGE(WeakMapBucket&lt;WeakMapBucketDataKey&gt;::offsetOfKey() == WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;::offsetOfKey(), &quot;We assume this to be true in the DFG and FTL JIT.&quot;);
219 
220         Base::finishCreation(vm);
221 
222         auto locker = holdLock(cellLock());
223         makeAndSetNewBuffer(locker, initialCapacity);
224     }
225 
226     // WeakMap operations must not cause GC. We model operations in DFG based on this guarantee.
227     // This guarantee is ensured by DisallowGC.
228 
229     template &lt;typename T = WeakMapBucketType&gt;
230     ALWAYS_INLINE typename std::enable_if&lt;std::is_same&lt;T, WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;&gt;::value, JSValue&gt;::type get(JSObject* key)
231     {
232         DisallowGC disallowGC;
233         if (WeakMapBucketType* bucket = findBucket(key))
234             return bucket-&gt;value();
235         return jsUndefined();
236     }
237 
238     ALWAYS_INLINE bool has(JSObject* key)
239     {
240         DisallowGC disallowGC;
241         return !!findBucket(key);
242     }
243 
244     ALWAYS_INLINE void add(VM&amp; vm, JSObject* key, JSValue value = JSValue())
245     {
246         DisallowGC disallowGC;
247         add(vm, key, value, jsWeakMapHash(key));
248     }
249 
250     ALWAYS_INLINE void add(VM&amp; vm, JSObject* key, JSValue value, uint32_t hash)
251     {
252         DisallowGC disallowGC;
253         ASSERT_WITH_MESSAGE(jsWeakMapHash(key) == hash, &quot;We expect hash value is what we expect.&quot;);
254 
255         addInternal(vm, key, value, hash);
256         if (shouldRehashAfterAdd())
257             rehash();
258     }
259 
260     ALWAYS_INLINE bool remove(JSObject* key)
261     {
262         DisallowGC disallowGC;
263         WeakMapBucketType* bucket = findBucket(key);
264         if (!bucket)
265             return false;
266 
267         bucket-&gt;makeDeleted();
268 
269         ++m_deleteCount;
270         RELEASE_ASSERT(m_keyCount &gt; 0);
271         --m_keyCount;
272 
273         if (shouldShrink())
274             rehash();
275 
276         return true;
277     }
278 
279     ALWAYS_INLINE uint32_t size() const
280     {
281         return m_keyCount;
282     }
283 
284     void takeSnapshot(MarkedArgumentBuffer&amp;, unsigned limit = 0);
285 
286     static ptrdiff_t offsetOfBuffer()
287     {
288         return OBJECT_OFFSETOF(WeakMapImpl&lt;WeakMapBucketType&gt;, m_buffer);
289     }
290 
291     static ptrdiff_t offsetOfCapacity()
292     {
293         return OBJECT_OFFSETOF(WeakMapImpl&lt;WeakMapBucketType&gt;, m_capacity);
294     }
295 
296     static constexpr bool isWeakMap()
297     {
298         return std::is_same&lt;WeakMapBucketType, JSC::WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;&gt;::value;
299     }
300 
301     static constexpr bool isWeakSet()
302     {
303         return std::is_same&lt;WeakMapBucketType, JSC::WeakMapBucket&lt;WeakMapBucketDataKey&gt;&gt;::value;
304     }
305 
306     template&lt;typename CellType, SubspaceAccess mode&gt;
307     static IsoSubspace* subspaceFor(VM&amp; vm)
308     {
<a name="3" id="anc3"></a><span class="line-modified">309         if constexpr (isWeakMap())</span>
310             return vm.weakMapSpace&lt;mode&gt;();
311         return vm.weakSetSpace&lt;mode&gt;();
312     }
313 
314     static void visitOutputConstraints(JSCell*, SlotVisitor&amp;);
315     void finalizeUnconditionally(VM&amp;);
316 
317 private:
318     ALWAYS_INLINE WeakMapBucketType* findBucket(JSObject* key)
319     {
320         return findBucket(key, jsWeakMapHash(key));
321     }
322 
323     ALWAYS_INLINE WeakMapBucketType* findBucket(JSObject* key, uint32_t hash)
324     {
325         return findBucketAlreadyHashed(key, hash);
326     }
327 
328     ALWAYS_INLINE WeakMapBucketType* buffer() const
329     {
330         return m_buffer-&gt;buffer();
331     }
332 
333     enum class IterationState { Continue, Stop };
334     template&lt;typename Functor&gt;
335     void forEach(Functor functor)
336     {
337         auto* buffer = this-&gt;buffer();
338         for (uint32_t index = 0; index &lt; m_capacity; ++index) {
339             auto* bucket = buffer + index;
340             if (bucket-&gt;isEmpty() || bucket-&gt;isDeleted())
341                 continue;
342             if (functor(bucket-&gt;key(), bucket-&gt;value()) == IterationState::Stop)
343                 return;
344         }
345     }
346 
347     ALWAYS_INLINE uint32_t shouldRehashAfterAdd() const
348     {
349         return JSC::shouldRehashAfterAdd(m_capacity, m_keyCount, m_deleteCount);
350     }
351 
352     ALWAYS_INLINE uint32_t shouldShrink() const
353     {
354         return JSC::shouldShrink(m_capacity, m_keyCount);
355     }
356 
357     ALWAYS_INLINE static bool canUseBucket(WeakMapBucketType* bucket, JSObject* key)
358     {
359         return !bucket-&gt;isDeleted() &amp;&amp; key == bucket-&gt;key();
360     }
361 
362     ALWAYS_INLINE void addInternal(VM&amp; vm, JSObject* key, JSValue value, uint32_t hash)
363     {
364         const uint32_t mask = m_capacity - 1;
365         uint32_t index = hash &amp; mask;
366         WeakMapBucketType* buffer = this-&gt;buffer();
367         WeakMapBucketType* bucket = buffer + index;
368         while (!bucket-&gt;isEmpty()) {
369             if (canUseBucket(bucket, key)) {
370                 ASSERT(!bucket-&gt;isDeleted());
371                 bucket-&gt;setValue(vm, this, value);
372                 return;
373             }
374             index = (index + 1) &amp; mask;
375             bucket = buffer + index;
376         }
377 
378         auto* newEntry = buffer + index;
379         newEntry-&gt;setKey(vm, this, key);
380         newEntry-&gt;setValue(vm, this, value);
381         ++m_keyCount;
382     }
383 
384     ALWAYS_INLINE WeakMapBucketType* findBucketAlreadyHashed(JSObject* key, uint32_t hash)
385     {
386         const uint32_t mask = m_capacity - 1;
387         uint32_t index = hash &amp; mask;
388         WeakMapBucketType* buffer = this-&gt;buffer();
389         WeakMapBucketType* bucket = buffer + index;
390 
391         while (!bucket-&gt;isEmpty()) {
392             if (canUseBucket(bucket, key)) {
393                 ASSERT(!bucket-&gt;isDeleted());
394                 return buffer + index;
395             }
396             index = (index + 1) &amp; mask;
397             bucket = buffer + index;
398         }
399         return nullptr;
400     }
401 
402     enum class RehashMode { Normal, RemoveBatching };
403     void rehash(RehashMode mode = RehashMode::Normal)
404     {
405         // Since shrinking is done just after GC runs (finalizeUnconditionally), WeakMapImpl::rehash()
406         // function must not touch any GC related features. This is why we do not allocate WeakMapBuffer
407         // in auxiliary buffer.
408 
409         // This rehash modifies m_buffer which is not GC-managed buffer. But m_buffer can be touched in
410         // visitOutputConstraints. Thus, we should guard it with cellLock.
411         auto locker = holdLock(cellLock());
412 
413         uint32_t oldCapacity = m_capacity;
414         MallocPtr&lt;WeakMapBufferType, JSValueMalloc&gt; oldBuffer = WTFMove(m_buffer);
415 
416         uint32_t capacity = m_capacity;
417         if (mode == RehashMode::RemoveBatching) {
418             ASSERT(shouldShrink());
419             capacity = nextCapacityAfterBatchRemoval(capacity, m_keyCount);
420         } else
421             capacity = nextCapacity(capacity, m_keyCount);
422         makeAndSetNewBuffer(locker, capacity);
423 
424         auto* buffer = this-&gt;buffer();
425         const uint32_t mask = m_capacity - 1;
426         for (uint32_t oldIndex = 0; oldIndex &lt; oldCapacity; ++oldIndex) {
427             auto* entry = oldBuffer-&gt;buffer() + oldIndex;
428             if (entry-&gt;isEmpty() || entry-&gt;isDeleted())
429                 continue;
430 
431             uint32_t index = jsWeakMapHash(entry-&gt;key()) &amp; mask;
432             WeakMapBucketType* bucket = buffer + index;
433             while (!bucket-&gt;isEmpty()) {
434                 index = (index + 1) &amp; mask;
435                 bucket = buffer + index;
436             }
437             bucket-&gt;copyFrom(*entry);
438         }
439 
440         m_deleteCount = 0;
441 
442         checkConsistency();
443     }
444 
445     ALWAYS_INLINE void checkConsistency() const
446     {
<a name="4" id="anc4"></a><span class="line-modified">447         if (ASSERT_ENABLED) {</span>
448             uint32_t size = 0;
449             auto* buffer = this-&gt;buffer();
450             for (uint32_t index = 0; index &lt; m_capacity; ++index) {
451                 auto* bucket = buffer + index;
452                 if (bucket-&gt;isEmpty() || bucket-&gt;isDeleted())
453                     continue;
454                 ++size;
455             }
456             ASSERT(size == m_keyCount);
457         }
458     }
459 
460     void makeAndSetNewBuffer(const AbstractLocker&amp;, uint32_t capacity)
461     {
462         ASSERT(!(capacity &amp; (capacity - 1)));
463 
464         m_buffer = WeakMapBufferType::create(capacity);
465         m_capacity = capacity;
466         ASSERT(m_buffer);
467         assertBufferIsEmpty();
468     }
469 
470     ALWAYS_INLINE void assertBufferIsEmpty() const
471     {
<a name="5" id="anc5"></a><span class="line-modified">472         if (ASSERT_ENABLED) {</span>
473             for (unsigned i = 0; i &lt; m_capacity; i++)
474                 ASSERT((buffer() + i)-&gt;isEmpty());
475         }
476     }
477 
478     template&lt;typename Appender&gt;
479     void takeSnapshotInternal(unsigned limit, Appender);
480 
481     MallocPtr&lt;WeakMapBufferType, JSValueMalloc&gt; m_buffer;
482     uint32_t m_capacity { 0 };
483     uint32_t m_keyCount { 0 };
484     uint32_t m_deleteCount { 0 };
485 };
486 
487 } // namespace JSC
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
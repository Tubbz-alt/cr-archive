<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/ScriptExecutionContext.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2008-2017 Apple Inc. All Rights Reserved.
  3  * Copyright (C) 2012 Google Inc. All Rights Reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  *
 26  */
 27 
 28 #pragma once
 29 
 30 #include &quot;ActiveDOMObject.h&quot;
 31 #include &quot;DOMTimer.h&quot;
 32 #include &quot;SecurityContext.h&quot;
 33 #include &quot;ServiceWorkerTypes.h&quot;
 34 #include &lt;JavaScriptCore/ConsoleTypes.h&gt;
 35 #include &lt;JavaScriptCore/HandleTypes.h&gt;
 36 #include &lt;wtf/CrossThreadTask.h&gt;
 37 #include &lt;wtf/Function.h&gt;
 38 #include &lt;wtf/HashSet.h&gt;
 39 #include &lt;wtf/ObjectIdentifier.h&gt;
 40 #include &lt;wtf/text/WTFString.h&gt;
 41 
 42 namespace JSC {
<a name="1" id="anc1"></a><span class="line-added"> 43 class CallFrame;</span>
 44 class Exception;
<a name="2" id="anc2"></a>
 45 class JSPromise;
 46 class VM;
<a name="3" id="anc3"></a>
 47 }
 48 
 49 namespace Inspector {
 50 class ConsoleMessage;
 51 class ScriptCallStack;
 52 }
 53 
<a name="4" id="anc4"></a>



 54 namespace WebCore {
 55 
<a name="5" id="anc5"></a><span class="line-added"> 56 class EventLoop;</span>
 57 class CachedScript;
 58 class DatabaseContext;
 59 class EventQueue;
<a name="6" id="anc6"></a><span class="line-added"> 60 class EventLoopTaskGroup;</span>
 61 class EventTarget;
 62 class MessagePort;
 63 class PublicURLManager;
 64 class RejectedPromiseTracker;
 65 class ResourceRequest;
 66 class SecurityOrigin;
 67 class SocketProvider;
<a name="7" id="anc7"></a><span class="line-added"> 68 enum class ReferrerPolicy : uint8_t;</span>
<span class="line-added"> 69 enum class TaskSource : uint8_t;</span>
 70 
 71 #if ENABLE(SERVICE_WORKER)
 72 class ServiceWorker;
 73 class ServiceWorkerContainer;
 74 #endif
 75 
 76 namespace IDBClient {
 77 class IDBConnectionProxy;
 78 }
 79 
 80 enum ScriptExecutionContextIdentifierType { };
 81 using ScriptExecutionContextIdentifier = ObjectIdentifier&lt;ScriptExecutionContextIdentifierType&gt;;
 82 
 83 class ScriptExecutionContext : public SecurityContext {
 84 public:
 85     ScriptExecutionContext();
 86     virtual ~ScriptExecutionContext();
 87 
 88     virtual bool isDocument() const { return false; }
 89     virtual bool isWorkerGlobalScope() const { return false; }
 90     virtual bool isWorkletGlobalScope() const { return false; }
 91 
 92     virtual bool isContextThread() const { return true; }
 93     virtual bool isJSExecutionForbidden() const = 0;
 94 
<a name="8" id="anc8"></a><span class="line-added"> 95     virtual EventLoopTaskGroup&amp; eventLoop() = 0;</span>
<span class="line-added"> 96 </span>
 97     virtual const URL&amp; url() const = 0;
<a name="9" id="anc9"></a><span class="line-modified"> 98     enum class ForceUTF8 { No, Yes };</span>
<span class="line-modified"> 99     virtual URL completeURL(const String&amp; url, ForceUTF8 = ForceUTF8::No) const = 0;</span>
100 
101     virtual String userAgent(const URL&amp;) const = 0;
102 
<a name="10" id="anc10"></a><span class="line-added">103     virtual ReferrerPolicy referrerPolicy() const = 0;</span>
<span class="line-added">104 </span>
105     virtual void disableEval(const String&amp; errorMessage) = 0;
106     virtual void disableWebAssembly(const String&amp; errorMessage) = 0;
107 
108 #if ENABLE(INDEXED_DATABASE)
109     virtual IDBClient::IDBConnectionProxy* idbConnectionProxy() = 0;
110 #endif
111     virtual SocketProvider* socketProvider() = 0;
112 
113     virtual String resourceRequestIdentifier() const { return String(); };
114 
115     bool canIncludeErrorDetails(CachedScript*, const String&amp; sourceURL);
116     void reportException(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL, JSC::Exception*, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, CachedScript* = nullptr);
<a name="11" id="anc11"></a><span class="line-modified">117     void reportUnhandledPromiseRejection(JSC::JSGlobalObject&amp;, JSC::JSPromise&amp;, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;);</span>
118 
119     virtual void addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp;) = 0;
120 
121     // The following addConsoleMessage functions are deprecated.
122     // Callers should try to create the ConsoleMessage themselves.
<a name="12" id="anc12"></a><span class="line-modified">123     void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, JSC::JSGlobalObject* = nullptr, unsigned long requestIdentifier = 0);</span>
124     virtual void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, unsigned long requestIdentifier = 0) = 0;
125 
126     virtual SecurityOrigin&amp; topOrigin() const = 0;
<a name="13" id="anc13"></a>
127 
128     virtual bool shouldBypassMainWorldContentSecurityPolicy() const { return false; }
129 
130     PublicURLManager&amp; publicURLManager();
131 
<a name="14" id="anc14"></a>




132     virtual void suspendActiveDOMObjects(ReasonForSuspension);
133     virtual void resumeActiveDOMObjects(ReasonForSuspension);
134     virtual void stopActiveDOMObjects();
135 
136     bool activeDOMObjectsAreSuspended() const { return m_activeDOMObjectsAreSuspended; }
137     bool activeDOMObjectsAreStopped() const { return m_activeDOMObjectsAreStopped; }
138 
139     // Called from the constructor and destructors of ActiveDOMObject.
140     void didCreateActiveDOMObject(ActiveDOMObject&amp;);
141     void willDestroyActiveDOMObject(ActiveDOMObject&amp;);
142 
143     // Called after the construction of an ActiveDOMObject to synchronize suspend state.
144     void suspendActiveDOMObjectIfNeeded(ActiveDOMObject&amp;);
145 
146     void didCreateDestructionObserver(ContextDestructionObserver&amp;);
147     void willDestroyDestructionObserver(ContextDestructionObserver&amp;);
148 
149     // MessagePort is conceptually a kind of ActiveDOMObject, but it needs to be tracked separately for message dispatch.
150     void processMessageWithMessagePortsSoon();
151     void dispatchMessagePortEvents();
152     void createdMessagePort(MessagePort&amp;);
153     void destroyedMessagePort(MessagePort&amp;);
154 
155     virtual void didLoadResourceSynchronously();
156 
157     void ref() { refScriptExecutionContext(); }
158     void deref() { derefScriptExecutionContext(); }
159 
160     class Task {
161         WTF_MAKE_FAST_ALLOCATED;
162     public:
163         enum CleanupTaskTag { CleanupTask };
164 
165         template&lt;typename T, typename = typename std::enable_if&lt;!std::is_base_of&lt;Task, T&gt;::value &amp;&amp; std::is_convertible&lt;T, WTF::Function&lt;void (ScriptExecutionContext&amp;)&gt;&gt;::value&gt;::type&gt;
166         Task(T task)
167             : m_task(WTFMove(task))
168             , m_isCleanupTask(false)
169         {
170         }
171 
172         Task(WTF::Function&lt;void ()&gt;&amp;&amp; task)
173             : m_task([task = WTFMove(task)](ScriptExecutionContext&amp;) { task(); })
174             , m_isCleanupTask(false)
175         {
176         }
177 
178         template&lt;typename T, typename = typename std::enable_if&lt;std::is_convertible&lt;T, WTF::Function&lt;void (ScriptExecutionContext&amp;)&gt;&gt;::value&gt;::type&gt;
179         Task(CleanupTaskTag, T task)
180             : m_task(WTFMove(task))
181             , m_isCleanupTask(true)
182         {
183         }
184 
185         void performTask(ScriptExecutionContext&amp; context) { m_task(context); }
186         bool isCleanupTask() const { return m_isCleanupTask; }
187 
188     protected:
189         WTF::Function&lt;void (ScriptExecutionContext&amp;)&gt; m_task;
190         bool m_isCleanupTask;
191     };
192 
<a name="15" id="anc15"></a><span class="line-added">193     void enqueueTaskForDispatcher(Function&lt;void()&gt;&amp;&amp; function) { postTask(WTFMove(function)); }</span>
194     virtual void postTask(Task&amp;&amp;) = 0; // Executes the task on context&#39;s thread asynchronously.
195 
196     template&lt;typename... Arguments&gt;
197     void postCrossThreadTask(Arguments&amp;&amp;... arguments)
198     {
199         postTask([crossThreadTask = createCrossThreadTask(arguments...)](ScriptExecutionContext&amp;) mutable {
200             crossThreadTask.performTask();
201         });
202     }
203 
204     // Gets the next id in a circular sequence from 1 to 2^31-1.
205     int circularSequentialID();
206 
<a name="16" id="anc16"></a><span class="line-modified">207     bool addTimeout(int timeoutId, DOMTimer&amp; timer) { return m_timeouts.add(timeoutId, timer).isNewEntry; }</span>
208     void removeTimeout(int timeoutId) { m_timeouts.remove(timeoutId); }
209     DOMTimer* findTimeout(int timeoutId) { return m_timeouts.get(timeoutId); }
210 
211     WEBCORE_EXPORT JSC::VM&amp; vm();
212 
213     void adjustMinimumDOMTimerInterval(Seconds oldMinimumTimerInterval);
214     virtual Seconds minimumDOMTimerInterval() const;
215 
216     void didChangeTimerAlignmentInterval();
217     virtual Seconds domTimerAlignmentInterval(bool hasReachedMaxNestingLevel) const;
218 
<a name="17" id="anc17"></a>
219     virtual EventTarget* errorEventTarget() = 0;
220 
221     DatabaseContext* databaseContext() { return m_databaseContext.get(); }
222     void setDatabaseContext(DatabaseContext*);
223 
224 #if ENABLE(WEB_CRYPTO)
<a name="18" id="anc18"></a><span class="line-added">225     // These two methods are used when CryptoKeys are serialized into IndexedDB. As a side effect, it is also</span>
<span class="line-added">226     // used for things that utilize the same structure clone algorithm, for example, message passing between</span>
<span class="line-added">227     // worker and document.</span>
228     virtual bool wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey) = 0;
229     virtual bool unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key) = 0;
230 #endif
231 
232     int timerNestingLevel() const { return m_timerNestingLevel; }
233     void setTimerNestingLevel(int timerNestingLevel) { m_timerNestingLevel = timerNestingLevel; }
234 
235     RejectedPromiseTracker&amp; ensureRejectedPromiseTracker()
236     {
237         if (m_rejectedPromiseTracker)
238             return *m_rejectedPromiseTracker.get();
239         return ensureRejectedPromiseTrackerSlow();
240     }
241 
<a name="19" id="anc19"></a><span class="line-modified">242     WEBCORE_EXPORT JSC::JSGlobalObject* execState();</span>
243 
244     WEBCORE_EXPORT String domainForCachePartition() const;
245     void setDomainForCachePartition(String&amp;&amp; domain) { m_domainForCachePartition = WTFMove(domain); }
246 
247     bool allowsMediaDevices() const;
248     bool hasServiceWorkerScheme() const;
249 #if ENABLE(SERVICE_WORKER)
250     ServiceWorker* activeServiceWorker() const;
251     void setActiveServiceWorker(RefPtr&lt;ServiceWorker&gt;&amp;&amp;);
252 
253     void registerServiceWorker(ServiceWorker&amp;);
254     void unregisterServiceWorker(ServiceWorker&amp;);
255     ServiceWorker* serviceWorker(ServiceWorkerIdentifier identifier) { return m_serviceWorkers.get(identifier); }
256 
257     ServiceWorkerContainer* serviceWorkerContainer();
<a name="20" id="anc20"></a><span class="line-modified">258     ServiceWorkerContainer* ensureServiceWorkerContainer();</span>

259 #endif
260     WEBCORE_EXPORT static bool postTaskTo(ScriptExecutionContextIdentifier, Task&amp;&amp;);
261 
262     ScriptExecutionContextIdentifier contextIdentifier() const;
263 
264 protected:
265     class AddConsoleMessageTask : public Task {
266     public:
267         AddConsoleMessageTask(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp; consoleMessage)
268             : Task([&amp;consoleMessage](ScriptExecutionContext&amp; context) {
269                 context.addConsoleMessage(WTFMove(consoleMessage));
270             })
271         {
272         }
273 
274         AddConsoleMessageTask(MessageSource source, MessageLevel level, const String&amp; message)
275             : Task([source, level, message = message.isolatedCopy()](ScriptExecutionContext&amp; context) {
276                 context.addConsoleMessage(source, level, message);
277             })
278         {
279         }
280     };
281 
282     ReasonForSuspension reasonForSuspendingActiveDOMObjects() const { return m_reasonForSuspendingActiveDOMObjects; }
283 
284     bool hasPendingActivity() const;
285     void removeFromContextsMap();
286     void removeRejectedPromiseTracker();
287 
288 private:
289     // The following addMessage function is deprecated.
290     // Callers should try to create the ConsoleMessage themselves.
<a name="21" id="anc21"></a><span class="line-modified">291     virtual void addMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, JSC::JSGlobalObject* = nullptr, unsigned long requestIdentifier = 0) = 0;</span>
292     virtual void logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;) = 0;
293     bool dispatchErrorEvent(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL, JSC::Exception*, CachedScript*);
294 
295     virtual void refScriptExecutionContext() = 0;
296     virtual void derefScriptExecutionContext() = 0;
297 
298     enum class ShouldContinue { No, Yes };
299     void forEachActiveDOMObject(const Function&lt;ShouldContinue(ActiveDOMObject&amp;)&gt;&amp;) const;
300 
301     RejectedPromiseTracker&amp; ensureRejectedPromiseTrackerSlow();
302 
303     void checkConsistency() const;
304 
305     HashSet&lt;MessagePort*&gt; m_messagePorts;
306     HashSet&lt;ContextDestructionObserver*&gt; m_destructionObservers;
307     HashSet&lt;ActiveDOMObject*&gt; m_activeDOMObjects;
308 
<a name="22" id="anc22"></a><span class="line-modified">309     HashMap&lt;int, Ref&lt;DOMTimer&gt;&gt; m_timeouts;</span>
310 
311     struct PendingException;
312     std::unique_ptr&lt;Vector&lt;std::unique_ptr&lt;PendingException&gt;&gt;&gt; m_pendingExceptions;
313     std::unique_ptr&lt;RejectedPromiseTracker&gt; m_rejectedPromiseTracker;
314 
315     ReasonForSuspension m_reasonForSuspendingActiveDOMObjects { static_cast&lt;ReasonForSuspension&gt;(-1) };
316 
317     std::unique_ptr&lt;PublicURLManager&gt; m_publicURLManager;
318 
319     RefPtr&lt;DatabaseContext&gt; m_databaseContext;
320 
321     int m_circularSequentialID { 0 };
322     int m_timerNestingLevel { 0 };
323 
324     bool m_activeDOMObjectsAreSuspended { false };
325     bool m_activeDOMObjectsAreStopped { false };
326     bool m_inDispatchErrorEvent { false };
327     mutable bool m_activeDOMObjectAdditionForbidden { false };
328     bool m_willprocessMessageWithMessagePortsSoon { false };
329 
<a name="23" id="anc23"></a><span class="line-modified">330 #if ASSERT_ENABLED</span>
331     bool m_inScriptExecutionContextDestructor { false };
332 #endif
333 
334 #if ENABLE(SERVICE_WORKER)
335     RefPtr&lt;ServiceWorker&gt; m_activeServiceWorker;
336     HashMap&lt;ServiceWorkerIdentifier, ServiceWorker*&gt; m_serviceWorkers;
337 #endif
338 
339     String m_domainForCachePartition;
340     mutable ScriptExecutionContextIdentifier m_contextIdentifier;
341 };
342 
343 } // namespace WebCore
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
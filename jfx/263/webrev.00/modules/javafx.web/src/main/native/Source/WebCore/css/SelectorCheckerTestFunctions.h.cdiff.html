<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/css/SelectorCheckerTestFunctions.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SelectorChecker.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorPseudoClassAndCompatibilityElementMap.in.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/SelectorCheckerTestFunctions.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,23 ***</span>
  #include &quot;FullscreenManager.h&quot;
  #include &quot;HTMLFrameElement.h&quot;
  #include &quot;HTMLIFrameElement.h&quot;
  #include &quot;HTMLInputElement.h&quot;
  #include &quot;HTMLOptionElement.h&quot;
<span class="line-modified">! #include &quot;RenderScrollbar.h&quot;</span>
<span class="line-removed">- #include &quot;ScrollableArea.h&quot;</span>
<span class="line-removed">- #include &quot;ScrollbarTheme.h&quot;</span>
  #include &lt;wtf/Compiler.h&gt;
  
  #if ENABLE(ATTACHMENT_ELEMENT)
  #include &quot;HTMLAttachmentElement.h&quot;
  #endif
  
  #if ENABLE(VIDEO_TRACK)
  #include &quot;WebVTTElement.h&quot;
  #endif
  
  namespace WebCore {
  
  ALWAYS_INLINE bool isAutofilled(const Element&amp; element)
  {
      return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(element).isAutoFilled();
<span class="line-new-header">--- 30,25 ---</span>
  #include &quot;FullscreenManager.h&quot;
  #include &quot;HTMLFrameElement.h&quot;
  #include &quot;HTMLIFrameElement.h&quot;
  #include &quot;HTMLInputElement.h&quot;
  #include &quot;HTMLOptionElement.h&quot;
<span class="line-modified">! #include &quot;SelectorChecker.h&quot;</span>
  #include &lt;wtf/Compiler.h&gt;
  
  #if ENABLE(ATTACHMENT_ELEMENT)
  #include &quot;HTMLAttachmentElement.h&quot;
  #endif
  
  #if ENABLE(VIDEO_TRACK)
  #include &quot;WebVTTElement.h&quot;
  #endif
  
<span class="line-added">+ #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">+ #include &quot;HTMLVideoElement.h&quot;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  namespace WebCore {
  
  ALWAYS_INLINE bool isAutofilled(const Element&amp; element)
  {
      return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(element).isAutoFilled();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 247,109 ***</span>
      return element.matchesIndeterminatePseudoClass();
  }
  
  ALWAYS_INLINE bool scrollbarMatchesEnabledPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     return context.scrollbar &amp;&amp; context.scrollbar-&gt;enabled();</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesDisabledPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     return context.scrollbar &amp;&amp; !context.scrollbar-&gt;enabled();</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesHoverPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     if (!context.scrollbar)</span>
          return false;
<span class="line-modified">!     ScrollbarPart hoveredPart = context.scrollbar-&gt;hoveredPart();</span>
<span class="line-modified">!     if (context.scrollbarPart == ScrollbarBGPart)</span>
          return hoveredPart != NoPart;
<span class="line-modified">!     if (context.scrollbarPart == TrackBGPart)</span>
          return hoveredPart == BackTrackPart || hoveredPart == ForwardTrackPart || hoveredPart == ThumbPart;
<span class="line-modified">!     return context.scrollbarPart == hoveredPart;</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesActivePseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     if (!context.scrollbar)</span>
          return false;
<span class="line-modified">!     ScrollbarPart pressedPart = context.scrollbar-&gt;pressedPart();</span>
<span class="line-modified">!     if (context.scrollbarPart == ScrollbarBGPart)</span>
          return pressedPart != NoPart;
<span class="line-modified">!     if (context.scrollbarPart == TrackBGPart)</span>
          return pressedPart == BackTrackPart || pressedPart == ForwardTrackPart || pressedPart == ThumbPart;
<span class="line-modified">!     return context.scrollbarPart == pressedPart;</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesHorizontalPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     return context.scrollbar &amp;&amp; context.scrollbar-&gt;orientation() == HorizontalScrollbar;</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesVerticalPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     return context.scrollbar &amp;&amp; context.scrollbar-&gt;orientation() == VerticalScrollbar;</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesDecrementPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     return context.scrollbarPart == BackButtonStartPart || context.scrollbarPart == BackButtonEndPart || context.scrollbarPart == BackTrackPart;</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesIncrementPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     return context.scrollbarPart == ForwardButtonStartPart || context.scrollbarPart == ForwardButtonEndPart || context.scrollbarPart == ForwardTrackPart;</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesStartPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     return context.scrollbarPart == BackButtonStartPart || context.scrollbarPart == ForwardButtonStartPart || context.scrollbarPart == BackTrackPart;</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesEndPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     return context.scrollbarPart == BackButtonEndPart || context.scrollbarPart == ForwardButtonEndPart || context.scrollbarPart == ForwardTrackPart;</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesDoubleButtonPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     if (!context.scrollbar)</span>
          return false;
<span class="line-modified">!     ScrollbarButtonsPlacement buttonsPlacement = context.scrollbar-&gt;theme().buttonsPlacement();</span>
<span class="line-modified">!     if (context.scrollbarPart == BackButtonStartPart || context.scrollbarPart == ForwardButtonStartPart || context.scrollbarPart == BackTrackPart)</span>
          return buttonsPlacement == ScrollbarButtonsDoubleStart || buttonsPlacement == ScrollbarButtonsDoubleBoth;
<span class="line-modified">!     if (context.scrollbarPart == BackButtonEndPart || context.scrollbarPart == ForwardButtonEndPart || context.scrollbarPart == ForwardTrackPart)</span>
          return buttonsPlacement == ScrollbarButtonsDoubleEnd || buttonsPlacement == ScrollbarButtonsDoubleBoth;
      return false;
  }
  
  ALWAYS_INLINE bool scrollbarMatchesSingleButtonPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     if (!context.scrollbar)</span>
          return false;
<span class="line-modified">!     ScrollbarButtonsPlacement buttonsPlacement = context.scrollbar-&gt;theme().buttonsPlacement();</span>
<span class="line-modified">!     if (context.scrollbarPart == BackButtonStartPart || context.scrollbarPart == ForwardButtonEndPart || context.scrollbarPart == BackTrackPart || context.scrollbarPart == ForwardTrackPart)</span>
          return buttonsPlacement == ScrollbarButtonsSingle;
      return false;
  }
  
  ALWAYS_INLINE bool scrollbarMatchesNoButtonPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     if (!context.scrollbar)</span>
          return false;
<span class="line-modified">!     ScrollbarButtonsPlacement buttonsPlacement = context.scrollbar-&gt;theme().buttonsPlacement();</span>
<span class="line-modified">!     if (context.scrollbarPart == BackTrackPart)</span>
          return buttonsPlacement == ScrollbarButtonsNone || buttonsPlacement == ScrollbarButtonsDoubleEnd;
<span class="line-modified">!     if (context.scrollbarPart == ForwardTrackPart)</span>
          return buttonsPlacement == ScrollbarButtonsNone || buttonsPlacement == ScrollbarButtonsDoubleStart;
      return false;
  }
  
  ALWAYS_INLINE bool scrollbarMatchesCornerPresentPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     return context.scrollbar &amp;&amp; context.scrollbar-&gt;scrollableArea().isScrollCornerVisible();</span>
  }
  
  #if ENABLE(FULLSCREEN_API)
  
  ALWAYS_INLINE bool matchesFullScreenPseudoClass(const Element&amp; element)
<span class="line-new-header">--- 249,126 ---</span>
      return element.matchesIndeterminatePseudoClass();
  }
  
  ALWAYS_INLINE bool scrollbarMatchesEnabledPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     return context.scrollbarState &amp;&amp; context.scrollbarState-&gt;enabled;</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesDisabledPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     return context.scrollbarState &amp;&amp; !context.scrollbarState-&gt;enabled;</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesHoverPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     if (!context.scrollbarState)</span>
          return false;
<span class="line-modified">!     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;</span>
<span class="line-modified">!     auto hoveredPart = context.scrollbarState-&gt;hoveredPart;</span>
<span class="line-added">+     if (scrollbarPart == ScrollbarBGPart)</span>
          return hoveredPart != NoPart;
<span class="line-modified">!     if (scrollbarPart == TrackBGPart)</span>
          return hoveredPart == BackTrackPart || hoveredPart == ForwardTrackPart || hoveredPart == ThumbPart;
<span class="line-modified">!     return scrollbarPart == hoveredPart;</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesActivePseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     if (!context.scrollbarState)</span>
          return false;
<span class="line-modified">!     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;</span>
<span class="line-modified">!     auto pressedPart = context.scrollbarState-&gt;pressedPart;</span>
<span class="line-added">+     if (scrollbarPart == ScrollbarBGPart)</span>
          return pressedPart != NoPart;
<span class="line-modified">!     if (scrollbarPart == TrackBGPart)</span>
          return pressedPart == BackTrackPart || pressedPart == ForwardTrackPart || pressedPart == ThumbPart;
<span class="line-modified">!     return scrollbarPart == pressedPart;</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesHorizontalPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     return context.scrollbarState &amp;&amp; context.scrollbarState-&gt;orientation == HorizontalScrollbar;</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesVerticalPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     return context.scrollbarState &amp;&amp; context.scrollbarState-&gt;orientation == VerticalScrollbar;</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesDecrementPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     if (!context.scrollbarState)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;</span>
<span class="line-added">+     return scrollbarPart == BackButtonStartPart || scrollbarPart == BackButtonEndPart || scrollbarPart == BackTrackPart;</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesIncrementPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     if (!context.scrollbarState)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;</span>
<span class="line-added">+     return scrollbarPart == ForwardButtonStartPart || scrollbarPart == ForwardButtonEndPart || scrollbarPart == ForwardTrackPart;</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesStartPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     if (!context.scrollbarState)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;</span>
<span class="line-added">+     return scrollbarPart == BackButtonStartPart || scrollbarPart == ForwardButtonStartPart || scrollbarPart == BackTrackPart;</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesEndPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     if (!context.scrollbarState)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;</span>
<span class="line-added">+     return scrollbarPart == BackButtonEndPart || scrollbarPart == ForwardButtonEndPart || scrollbarPart == ForwardTrackPart;</span>
  }
  
  ALWAYS_INLINE bool scrollbarMatchesDoubleButtonPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     if (!context.scrollbarState)</span>
          return false;
<span class="line-modified">!     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;</span>
<span class="line-modified">!     auto buttonsPlacement = context.scrollbarState-&gt;buttonsPlacement;</span>
<span class="line-added">+     if (scrollbarPart == BackButtonStartPart || scrollbarPart == ForwardButtonStartPart || scrollbarPart == BackTrackPart)</span>
          return buttonsPlacement == ScrollbarButtonsDoubleStart || buttonsPlacement == ScrollbarButtonsDoubleBoth;
<span class="line-modified">!     if (scrollbarPart == BackButtonEndPart || scrollbarPart == ForwardButtonEndPart || scrollbarPart == ForwardTrackPart)</span>
          return buttonsPlacement == ScrollbarButtonsDoubleEnd || buttonsPlacement == ScrollbarButtonsDoubleBoth;
      return false;
  }
  
  ALWAYS_INLINE bool scrollbarMatchesSingleButtonPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     if (!context.scrollbarState)</span>
          return false;
<span class="line-modified">!     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;</span>
<span class="line-modified">!     auto buttonsPlacement = context.scrollbarState-&gt;buttonsPlacement;</span>
<span class="line-added">+     if (scrollbarPart == BackButtonStartPart || scrollbarPart == ForwardButtonEndPart || scrollbarPart == BackTrackPart || scrollbarPart == ForwardTrackPart)</span>
          return buttonsPlacement == ScrollbarButtonsSingle;
      return false;
  }
  
  ALWAYS_INLINE bool scrollbarMatchesNoButtonPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     if (!context.scrollbarState)</span>
          return false;
<span class="line-modified">!     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;</span>
<span class="line-modified">!     auto buttonsPlacement = context.scrollbarState-&gt;buttonsPlacement;</span>
<span class="line-added">+     if (scrollbarPart == BackTrackPart)</span>
          return buttonsPlacement == ScrollbarButtonsNone || buttonsPlacement == ScrollbarButtonsDoubleEnd;
<span class="line-modified">!     if (scrollbarPart == ForwardTrackPart)</span>
          return buttonsPlacement == ScrollbarButtonsNone || buttonsPlacement == ScrollbarButtonsDoubleStart;
      return false;
  }
  
  ALWAYS_INLINE bool scrollbarMatchesCornerPresentPseudoClass(const SelectorChecker::CheckingContext&amp; context)
  {
<span class="line-modified">!     return context.scrollbarState &amp;&amp; context.scrollbarState-&gt;scrollCornerIsVisible;</span>
  }
  
  #if ENABLE(FULLSCREEN_API)
  
  ALWAYS_INLINE bool matchesFullScreenPseudoClass(const Element&amp; element)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 393,10 ***</span>
<span class="line-new-header">--- 412,19 ---</span>
      return element.document().fullscreenManager().areFullscreenControlsHidden();
  }
  
  #endif
  
<span class="line-added">+ #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">+ </span>
<span class="line-added">+ ALWAYS_INLINE bool matchesPictureInPicturePseudoClass(const Element&amp; element)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return is&lt;HTMLVideoElement&gt;(element) &amp;&amp; element.document().pictureInPictureElement() == &amp;element;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  #if ENABLE(VIDEO_TRACK)
  
  ALWAYS_INLINE bool matchesFutureCuePseudoClass(const Element&amp; element)
  {
      return is&lt;WebVTTElement&gt;(element) &amp;&amp; !downcast&lt;WebVTTElement&gt;(element).isPastNode();
</pre>
<center><a href="SelectorChecker.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorPseudoClassAndCompatibilityElementMap.in.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringImpl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Dirk Mueller ( mueller@kde.org )
<a name="1" id="anc1"></a><span class="line-modified">   5  * Copyright (C) 2003-2020 Apple Inc. All rights reserved.</span>
   6  * Copyright (C) 2006 Andrew Wellington (proton@wiretapped.net)
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &lt;wtf/text/StringImpl.h&gt;
  27 
  28 #include &lt;wtf/ProcessID.h&gt;
  29 #include &lt;wtf/StdLibExtras.h&gt;
  30 #include &lt;wtf/text/AtomString.h&gt;
  31 #include &lt;wtf/text/CString.h&gt;
  32 #include &lt;wtf/text/ExternalStringImpl.h&gt;
  33 #include &lt;wtf/text/StringBuffer.h&gt;
  34 #include &lt;wtf/text/StringHash.h&gt;
  35 #include &lt;wtf/text/StringView.h&gt;
  36 #include &lt;wtf/text/SymbolImpl.h&gt;
  37 #include &lt;wtf/text/SymbolRegistry.h&gt;
  38 #include &lt;wtf/unicode/CharacterNames.h&gt;
  39 #include &lt;wtf/unicode/UTF8Conversion.h&gt;
  40 
  41 #if STRING_STATS
  42 #include &lt;unistd.h&gt;
  43 #include &lt;wtf/DataLog.h&gt;
  44 #endif
  45 
  46 namespace WTF {
  47 
  48 using namespace Unicode;
  49 
  50 static_assert(sizeof(StringImpl) == 2 * sizeof(int) + 2 * sizeof(void*), &quot;StringImpl should stay small&quot;);
  51 
  52 #if STRING_STATS
  53 StringStats StringImpl::m_stringStats;
  54 
  55 std::atomic&lt;unsigned&gt; StringStats::s_stringRemovesTillPrintStats(s_printStringStatsFrequency);
  56 
  57 void StringStats::removeString(StringImpl&amp; string)
  58 {
  59     unsigned length = string.length();
  60     bool isSubString = string.isSubString();
  61 
  62     --m_totalNumberStrings;
  63 
  64     if (string.is8Bit()) {
  65         --m_number8BitStrings;
  66         if (!isSubString)
  67             m_total8BitData -= length;
  68     } else {
  69         --m_number16BitStrings;
  70         if (!isSubString)
  71             m_total16BitData -= length;
  72     }
  73 
  74     if (!--s_stringRemovesTillPrintStats) {
  75         s_stringRemovesTillPrintStats = s_printStringStatsFrequency;
  76         printStats();
  77     }
  78 }
  79 
  80 void StringStats::printStats()
  81 {
  82     dataLogF(&quot;String stats for process id %d:\n&quot;, getCurrentProcessID());
  83 
  84     unsigned long long totalNumberCharacters = m_total8BitData + m_total16BitData;
  85     double percent8Bit = m_totalNumberStrings ? ((double)m_number8BitStrings * 100) / (double)m_totalNumberStrings : 0.0;
  86     double average8bitLength = m_number8BitStrings ? (double)m_total8BitData / (double)m_number8BitStrings : 0.0;
  87     dataLogF(&quot;%8u (%5.2f%%) 8 bit        %12llu chars  %12llu bytes  avg length %6.1f\n&quot;, m_number8BitStrings.load(), percent8Bit, m_total8BitData.load(), m_total8BitData.load(), average8bitLength);
  88 
  89     double percent16Bit = m_totalNumberStrings ? ((double)m_number16BitStrings * 100) / (double)m_totalNumberStrings : 0.0;
  90     double average16bitLength = m_number16BitStrings ? (double)m_total16BitData / (double)m_number16BitStrings : 0.0;
  91     dataLogF(&quot;%8u (%5.2f%%) 16 bit       %12llu chars  %12llu bytes  avg length %6.1f\n&quot;, m_number16BitStrings.load(), percent16Bit, m_total16BitData.load(), m_total16BitData * 2, average16bitLength);
  92 
  93     double averageLength = m_totalNumberStrings ? (double)totalNumberCharacters / (double)m_totalNumberStrings : 0.0;
  94     unsigned long long totalDataBytes = m_total8BitData + m_total16BitData * 2;
  95     dataLogF(&quot;%8u Total                 %12llu chars  %12llu bytes  avg length %6.1f\n&quot;, m_totalNumberStrings.load(), totalNumberCharacters, totalDataBytes, averageLength);
  96     unsigned long long totalSavedBytes = m_total8BitData;
  97     double percentSavings = totalSavedBytes ? ((double)totalSavedBytes * 100) / (double)(totalDataBytes + totalSavedBytes) : 0.0;
  98     dataLogF(&quot;         Total savings %12llu bytes (%5.2f%%)\n&quot;, totalSavedBytes, percentSavings);
  99 
 100     dataLogF(&quot;%8u StringImpl::ref calls\n&quot;, m_refCalls.load());
 101     dataLogF(&quot;%8u StringImpl::deref calls\n&quot;, m_derefCalls.load());
 102 }
 103 #endif
 104 
<a name="2" id="anc2"></a><span class="line-added"> 105 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StringImpl);</span>
<span class="line-added"> 106 </span>
 107 StringImpl::StaticStringImpl StringImpl::s_emptyAtomString(&quot;&quot;, StringImpl::StringAtom);
 108 
 109 StringImpl::~StringImpl()
 110 {
 111     ASSERT(!isStatic());
 112 
 113     StringView::invalidate(*this);
 114 
 115     STRING_STATS_REMOVE_STRING(*this);
 116 
 117     if (isAtom()) {
 118         ASSERT(!isSymbol());
 119         if (length())
 120             AtomStringImpl::remove(static_cast&lt;AtomStringImpl*&gt;(this));
 121     } else if (isSymbol()) {
 122         auto&amp; symbol = static_cast&lt;SymbolImpl&amp;&gt;(*this);
 123         auto* symbolRegistry = symbol.symbolRegistry();
 124         if (symbolRegistry)
 125             symbolRegistry-&gt;remove(*symbol.asRegisteredSymbolImpl());
 126     }
 127 
 128     BufferOwnership ownership = bufferOwnership();
 129 
 130     if (ownership == BufferInternal)
 131         return;
 132     if (ownership == BufferOwned) {
 133         // We use m_data8, but since it is a union with m_data16 this works either way.
 134         ASSERT(m_data8);
<a name="3" id="anc3"></a><span class="line-modified"> 135         StringImplMalloc::free(const_cast&lt;LChar*&gt;(m_data8));</span>
 136         return;
 137     }
 138     if (ownership == BufferExternal) {
 139         auto* external = static_cast&lt;ExternalStringImpl*&gt;(this);
 140         external-&gt;freeExternalBuffer(const_cast&lt;LChar*&gt;(m_data8), sizeInBytes());
 141         external-&gt;m_free.~ExternalStringImplFreeFunction();
 142         return;
 143     }
 144 
 145     ASSERT(ownership == BufferSubstring);
 146     ASSERT(substringBuffer());
 147     substringBuffer()-&gt;deref();
 148 }
 149 
 150 void StringImpl::destroy(StringImpl* stringImpl)
 151 {
 152     stringImpl-&gt;~StringImpl();
<a name="4" id="anc4"></a><span class="line-modified"> 153     StringImplMalloc::free(stringImpl);</span>
 154 }
 155 
 156 Ref&lt;StringImpl&gt; StringImpl::createFromLiteral(const char* characters, unsigned length)
 157 {
 158     ASSERT_WITH_MESSAGE(length, &quot;Use StringImpl::empty() to create an empty string&quot;);
<a name="5" id="anc5"></a><span class="line-modified"> 159     ASSERT(charactersAreAllASCII(reinterpret_cast&lt;const LChar*&gt;(characters), length));</span>
 160     return adoptRef(*new StringImpl(reinterpret_cast&lt;const LChar*&gt;(characters), length, ConstructWithoutCopying));
 161 }
 162 
 163 Ref&lt;StringImpl&gt; StringImpl::createFromLiteral(const char* characters)
 164 {
 165     return createFromLiteral(characters, strlen(characters));
 166 }
 167 
 168 Ref&lt;StringImpl&gt; StringImpl::createWithoutCopying(const UChar* characters, unsigned length)
 169 {
 170     if (!length)
 171         return *empty();
 172     return adoptRef(*new StringImpl(characters, length, ConstructWithoutCopying));
 173 }
 174 
 175 Ref&lt;StringImpl&gt; StringImpl::createWithoutCopying(const LChar* characters, unsigned length)
 176 {
 177     if (!length)
 178         return *empty();
 179     return adoptRef(*new StringImpl(characters, length, ConstructWithoutCopying));
 180 }
 181 
 182 template&lt;typename CharacterType&gt; inline Ref&lt;StringImpl&gt; StringImpl::createUninitializedInternal(unsigned length, CharacterType*&amp; data)
 183 {
 184     if (!length) {
 185         data = 0;
 186         return *empty();
 187     }
 188     return createUninitializedInternalNonEmpty(length, data);
 189 }
 190 
 191 template&lt;typename CharacterType&gt; inline Ref&lt;StringImpl&gt; StringImpl::createUninitializedInternalNonEmpty(unsigned length, CharacterType*&amp; data)
 192 {
 193     ASSERT(length);
 194 
 195     // Allocate a single buffer large enough to contain the StringImpl
 196     // struct as well as the data which it contains. This removes one
 197     // heap allocation from this call.
 198     if (length &gt; maxInternalLength&lt;CharacterType&gt;())
 199         CRASH();
<a name="6" id="anc6"></a><span class="line-modified"> 200     StringImpl* string = static_cast&lt;StringImpl*&gt;(StringImplMalloc::malloc(allocationSize&lt;CharacterType&gt;(length)));</span>

 201     data = string-&gt;tailPointer&lt;CharacterType&gt;();
 202     return constructInternal&lt;CharacterType&gt;(*string, length);
 203 }
 204 
 205 Ref&lt;StringImpl&gt; StringImpl::createUninitialized(unsigned length, LChar*&amp; data)
 206 {
 207     return createUninitializedInternal(length, data);
 208 }
 209 
 210 Ref&lt;StringImpl&gt; StringImpl::createUninitialized(unsigned length, UChar*&amp; data)
 211 {
 212     return createUninitializedInternal(length, data);
 213 }
 214 
 215 template&lt;typename CharacterType&gt; inline Expected&lt;Ref&lt;StringImpl&gt;, UTF8ConversionError&gt; StringImpl::reallocateInternal(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, CharacterType*&amp; data)
 216 {
 217     ASSERT(originalString-&gt;hasOneRef());
 218     ASSERT(originalString-&gt;bufferOwnership() == BufferInternal);
 219 
 220     if (!length) {
 221         data = 0;
 222         return Ref&lt;StringImpl&gt;(*empty());
 223     }
 224 
 225     // Same as createUninitialized() except here we use fastRealloc.
 226     if (length &gt; maxInternalLength&lt;CharacterType&gt;())
 227         return makeUnexpected(UTF8ConversionError::OutOfMemory);
 228 
 229     originalString-&gt;~StringImpl();
<a name="7" id="anc7"></a><span class="line-modified"> 230     auto* string = static_cast&lt;StringImpl*&gt;(StringImplMalloc::tryRealloc(&amp;originalString.leakRef(), allocationSize&lt;CharacterType&gt;(length)));</span>
<span class="line-modified"> 231     if (!string)</span>
 232         return makeUnexpected(UTF8ConversionError::OutOfMemory);
 233 
 234     data = string-&gt;tailPointer&lt;CharacterType&gt;();
 235     return constructInternal&lt;CharacterType&gt;(*string, length);
 236 }
 237 
 238 Ref&lt;StringImpl&gt; StringImpl::reallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, LChar*&amp; data)
 239 {
 240     auto expectedStringImpl = tryReallocate(WTFMove(originalString), length, data);
 241     RELEASE_ASSERT(expectedStringImpl);
 242     return WTFMove(expectedStringImpl.value());
 243 }
 244 
 245 Ref&lt;StringImpl&gt; StringImpl::reallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, UChar*&amp; data)
 246 {
 247     auto expectedStringImpl = tryReallocate(WTFMove(originalString), length, data);
 248     RELEASE_ASSERT(expectedStringImpl);
 249     return WTFMove(expectedStringImpl.value());
 250 }
 251 
 252 Expected&lt;Ref&lt;StringImpl&gt;, UTF8ConversionError&gt; StringImpl::tryReallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, LChar*&amp; data)
 253 {
 254     ASSERT(originalString-&gt;is8Bit());
 255     return reallocateInternal(WTFMove(originalString), length, data);
 256 }
 257 
 258 Expected&lt;Ref&lt;StringImpl&gt;, UTF8ConversionError&gt; StringImpl::tryReallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, UChar*&amp; data)
 259 {
 260     ASSERT(!originalString-&gt;is8Bit());
 261     return reallocateInternal(WTFMove(originalString), length, data);
 262 }
 263 
 264 template&lt;typename CharacterType&gt; inline Ref&lt;StringImpl&gt; StringImpl::createInternal(const CharacterType* characters, unsigned length)
 265 {
 266     if (!characters || !length)
 267         return *empty();
 268     CharacterType* data;
 269     auto string = createUninitializedInternalNonEmpty(length, data);
 270     copyCharacters(data, characters, length);
 271     return string;
 272 }
 273 
 274 Ref&lt;StringImpl&gt; StringImpl::create(const UChar* characters, unsigned length)
 275 {
 276     return createInternal(characters, length);
 277 }
 278 
 279 Ref&lt;StringImpl&gt; StringImpl::create(const LChar* characters, unsigned length)
 280 {
 281     return createInternal(characters, length);
 282 }
 283 
<a name="8" id="anc8"></a><span class="line-added"> 284 Ref&lt;StringImpl&gt; StringImpl::createStaticStringImpl(const char* characters, unsigned length)</span>
<span class="line-added"> 285 {</span>
<span class="line-added"> 286     const LChar* lcharCharacters = reinterpret_cast&lt;const LChar*&gt;(characters);</span>
<span class="line-added"> 287     ASSERT(charactersAreAllASCII(lcharCharacters, length));</span>
<span class="line-added"> 288     Ref&lt;StringImpl&gt; result = createInternal(lcharCharacters, length);</span>
<span class="line-added"> 289     result-&gt;setHash(StringHasher::computeHashAndMaskTop8Bits(lcharCharacters, length));</span>
<span class="line-added"> 290     result-&gt;m_refCount |= s_refCountFlagIsStaticString;</span>
<span class="line-added"> 291     return result;</span>
<span class="line-added"> 292 }</span>
<span class="line-added"> 293 </span>
 294 Ref&lt;StringImpl&gt; StringImpl::create8BitIfPossible(const UChar* characters, unsigned length)
 295 {
 296     if (!characters || !length)
 297         return *empty();
 298 
 299     LChar* data;
 300     auto string = createUninitializedInternalNonEmpty(length, data);
 301 
 302     for (size_t i = 0; i &lt; length; ++i) {
 303         if (!isLatin1(characters[i]))
 304             return create(characters, length);
 305         data[i] = static_cast&lt;LChar&gt;(characters[i]);
 306     }
 307 
 308     return string;
 309 }
 310 
 311 Ref&lt;StringImpl&gt; StringImpl::create8BitIfPossible(const UChar* string)
 312 {
 313     return StringImpl::create8BitIfPossible(string, lengthOfNullTerminatedString(string));
 314 }
 315 
 316 Ref&lt;StringImpl&gt; StringImpl::create(const LChar* string)
 317 {
 318     if (!string)
 319         return *empty();
 320     size_t length = strlen(reinterpret_cast&lt;const char*&gt;(string));
 321     if (length &gt; MaxLength)
 322         CRASH();
 323     return create(string, length);
 324 }
 325 
 326 Ref&lt;StringImpl&gt; StringImpl::substring(unsigned start, unsigned length)
 327 {
 328     if (start &gt;= m_length)
 329         return *empty();
 330     unsigned maxLength = m_length - start;
 331     if (length &gt;= maxLength) {
 332         if (!start)
 333             return *this;
 334         length = maxLength;
 335     }
 336     if (is8Bit())
 337         return create(m_data8 + start, length);
 338 
 339     return create(m_data16 + start, length);
 340 }
 341 
 342 UChar32 StringImpl::characterStartingAt(unsigned i)
 343 {
 344     if (is8Bit())
 345         return m_data8[i];
 346     if (U16_IS_SINGLE(m_data16[i]))
 347         return m_data16[i];
 348     if (i + 1 &lt; m_length &amp;&amp; U16_IS_LEAD(m_data16[i]) &amp;&amp; U16_IS_TRAIL(m_data16[i + 1]))
 349         return U16_GET_SUPPLEMENTARY(m_data16[i], m_data16[i + 1]);
 350     return 0;
 351 }
 352 
 353 Ref&lt;StringImpl&gt; StringImpl::convertToLowercaseWithoutLocale()
 354 {
 355     // Note: At one time this was a hot function in the Dromaeo benchmark, specifically the
 356     // no-op code path that may return ourself if we find no upper case letters and no invalid
 357     // ASCII letters.
 358 
 359     // First scan the string for uppercase and non-ASCII characters:
 360     if (is8Bit()) {
 361         for (unsigned i = 0; i &lt; m_length; ++i) {
 362             LChar character = m_data8[i];
<a name="9" id="anc9"></a><span class="line-modified"> 363             if (UNLIKELY(!isASCII(character) || isASCIIUpper(character)))</span>
 364                 return convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(i);
 365         }
 366 
 367         return *this;
 368     }
 369 
 370     bool noUpper = true;
 371     unsigned ored = 0;
 372 
 373     for (unsigned i = 0; i &lt; m_length; ++i) {
 374         UChar character = m_data16[i];
 375         if (UNLIKELY(isASCIIUpper(character)))
 376             noUpper = false;
 377         ored |= character;
 378     }
 379     // Nothing to do if the string is all ASCII with no uppercase.
 380     if (noUpper &amp;&amp; !(ored &amp; ~0x7F))
 381         return *this;
 382 
 383     if (!(ored &amp; ~0x7F)) {
 384         UChar* data16;
 385         auto newImpl = createUninitializedInternalNonEmpty(m_length, data16);
 386         for (unsigned i = 0; i &lt; m_length; ++i)
 387             data16[i] = toASCIILower(m_data16[i]);
 388         return newImpl;
 389     }
 390 
 391     if (m_length &gt; MaxLength)
 392         CRASH();
 393     int32_t length = m_length;
 394 
 395     // Do a slower implementation for cases that include non-ASCII characters.
 396     UChar* data16;
 397     auto newImpl = createUninitializedInternalNonEmpty(m_length, data16);
 398 
 399     UErrorCode status = U_ZERO_ERROR;
 400     int32_t realLength = u_strToLower(data16, length, m_data16, m_length, &quot;&quot;, &amp;status);
 401     if (U_SUCCESS(status) &amp;&amp; realLength == length)
 402         return newImpl;
 403 
 404     newImpl = createUninitialized(realLength, data16);
 405     status = U_ZERO_ERROR;
 406     u_strToLower(data16, realLength, m_data16, m_length, &quot;&quot;, &amp;status);
 407     if (U_FAILURE(status))
 408         return *this;
 409     return newImpl;
 410 }
 411 
 412 Ref&lt;StringImpl&gt; StringImpl::convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(unsigned failingIndex)
 413 {
 414     ASSERT(is8Bit());
 415     LChar* data8;
 416     auto newImpl = createUninitializedInternalNonEmpty(m_length, data8);
 417 
 418     for (unsigned i = 0; i &lt; failingIndex; ++i) {
<a name="10" id="anc10"></a><span class="line-modified"> 419         ASSERT(isASCII(m_data8[i]));</span>
<span class="line-added"> 420         ASSERT(!isASCIIUpper(m_data8[i]));</span>
 421         data8[i] = m_data8[i];
 422     }
 423 
 424     for (unsigned i = failingIndex; i &lt; m_length; ++i) {
 425         LChar character = m_data8[i];
<a name="11" id="anc11"></a><span class="line-modified"> 426         if (isASCII(character))</span>
 427             data8[i] = toASCIILower(character);
 428         else {
 429             ASSERT(isLatin1(u_tolower(character)));
 430             data8[i] = static_cast&lt;LChar&gt;(u_tolower(character));
 431         }
 432     }
 433 
 434     return newImpl;
 435 }
 436 
 437 Ref&lt;StringImpl&gt; StringImpl::convertToUppercaseWithoutLocale()
 438 {
 439     // This function could be optimized for no-op cases the way
 440     // convertToLowercaseWithoutLocale() is, but in empirical testing,
 441     // few actual calls to upper() are no-ops, so it wouldn&#39;t be worth
 442     // the extra time for pre-scanning.
 443 
 444     if (m_length &gt; MaxLength)
 445         CRASH();
 446     int32_t length = m_length;
 447 
 448     if (is8Bit()) {
 449         LChar* data8;
 450         auto newImpl = createUninitialized(m_length, data8);
 451 
 452         // Do a faster loop for the case where all the characters are ASCII.
 453         unsigned ored = 0;
 454         for (int i = 0; i &lt; length; ++i) {
 455             LChar character = m_data8[i];
 456             ored |= character;
 457             data8[i] = toASCIIUpper(character);
 458         }
 459         if (!(ored &amp; ~0x7F))
 460             return newImpl;
 461 
 462         // Do a slower implementation for cases that include non-ASCII Latin-1 characters.
 463         int numberSharpSCharacters = 0;
 464 
 465         // There are two special cases.
 466         //  1. Some Latin-1 characters when converted to upper case are 16 bit characters.
 467         //  2. Lower case sharp-S converts to &quot;SS&quot; (two characters)
 468         for (int32_t i = 0; i &lt; length; ++i) {
 469             LChar character = m_data8[i];
 470             if (UNLIKELY(character == smallLetterSharpS))
 471                 ++numberSharpSCharacters;
 472             ASSERT(u_toupper(character) &lt;= 0xFFFF);
 473             UChar upper = u_toupper(character);
 474             if (UNLIKELY(!isLatin1(upper))) {
 475                 // Since this upper-cased character does not fit in an 8-bit string, we need to take the 16-bit path.
 476                 goto upconvert;
 477             }
 478             data8[i] = static_cast&lt;LChar&gt;(upper);
 479         }
 480 
 481         if (!numberSharpSCharacters)
 482             return newImpl;
 483 
 484         // We have numberSSCharacters sharp-s characters, but none of the other special characters.
 485         newImpl = createUninitialized(m_length + numberSharpSCharacters, data8);
 486 
 487         LChar* dest = data8;
 488 
 489         for (int32_t i = 0; i &lt; length; ++i) {
 490             LChar character = m_data8[i];
 491             if (character == smallLetterSharpS) {
 492                 *dest++ = &#39;S&#39;;
 493                 *dest++ = &#39;S&#39;;
 494             } else {
 495                 ASSERT(isLatin1(u_toupper(character)));
 496                 *dest++ = static_cast&lt;LChar&gt;(u_toupper(character));
 497             }
 498         }
 499 
 500         return newImpl;
 501     }
 502 
 503 upconvert:
 504     auto upconvertedCharacters = StringView(*this).upconvertedCharacters();
 505     const UChar* source16 = upconvertedCharacters;
 506 
 507     UChar* data16;
 508     auto newImpl = createUninitialized(m_length, data16);
 509 
 510     // Do a faster loop for the case where all the characters are ASCII.
 511     unsigned ored = 0;
 512     for (int i = 0; i &lt; length; ++i) {
 513         UChar character = source16[i];
 514         ored |= character;
 515         data16[i] = toASCIIUpper(character);
 516     }
 517     if (!(ored &amp; ~0x7F))
 518         return newImpl;
 519 
 520     // Do a slower implementation for cases that include non-ASCII characters.
 521     UErrorCode status = U_ZERO_ERROR;
 522     int32_t realLength = u_strToUpper(data16, length, source16, m_length, &quot;&quot;, &amp;status);
 523     if (U_SUCCESS(status) &amp;&amp; realLength == length)
 524         return newImpl;
 525     newImpl = createUninitialized(realLength, data16);
 526     status = U_ZERO_ERROR;
 527     u_strToUpper(data16, realLength, source16, m_length, &quot;&quot;, &amp;status);
 528     if (U_FAILURE(status))
 529         return *this;
 530     return newImpl;
 531 }
 532 
 533 static inline bool needsTurkishCasingRules(const AtomString&amp; localeIdentifier)
 534 {
 535     // Either &quot;tr&quot; or &quot;az&quot; locale, with case sensitive comparison and allowing for an ignored subtag.
 536     UChar first = localeIdentifier[0];
 537     UChar second = localeIdentifier[1];
 538     return ((isASCIIAlphaCaselessEqual(first, &#39;t&#39;) &amp;&amp; isASCIIAlphaCaselessEqual(second, &#39;r&#39;))
 539         || (isASCIIAlphaCaselessEqual(first, &#39;a&#39;) &amp;&amp; isASCIIAlphaCaselessEqual(second, &#39;z&#39;)))
 540         &amp;&amp; (localeIdentifier.length() == 2 || localeIdentifier[2] == &#39;-&#39;);
 541 }
 542 
 543 Ref&lt;StringImpl&gt; StringImpl::convertToLowercaseWithLocale(const AtomString&amp; localeIdentifier)
 544 {
 545     // Use the more-optimized code path most of the time.
 546     // Assuming here that the only locale-specific lowercasing is the Turkish casing rules.
 547     // FIXME: Could possibly optimize further by looking for the specific sequences
 548     // that have locale-specific lowercasing. There are only three of them.
 549     if (!needsTurkishCasingRules(localeIdentifier))
 550         return convertToLowercaseWithoutLocale();
 551 
 552     // FIXME: Could share more code with the main StringImpl::lower by factoring out
 553     // this last part into a shared function that takes a locale string, since this is
 554     // just like the end of that function.
 555 
 556     if (m_length &gt; MaxLength)
 557         CRASH();
 558     int length = m_length;
 559 
 560     // Below, we pass in the hardcoded locale &quot;tr&quot;. Passing that is more efficient than
 561     // allocating memory just to turn localeIdentifier into a C string, and we assume
 562     // there is no difference between the uppercasing for &quot;tr&quot; and &quot;az&quot; locales.
 563     auto upconvertedCharacters = StringView(*this).upconvertedCharacters();
 564     const UChar* source16 = upconvertedCharacters;
 565     UChar* data16;
 566     auto newString = createUninitialized(length, data16);
 567     UErrorCode status = U_ZERO_ERROR;
 568     int realLength = u_strToLower(data16, length, source16, length, &quot;tr&quot;, &amp;status);
 569     if (U_SUCCESS(status) &amp;&amp; realLength == length)
 570         return newString;
 571     newString = createUninitialized(realLength, data16);
 572     status = U_ZERO_ERROR;
 573     u_strToLower(data16, realLength, source16, length, &quot;tr&quot;, &amp;status);
 574     if (U_FAILURE(status))
 575         return *this;
 576     return newString;
 577 }
 578 
 579 Ref&lt;StringImpl&gt; StringImpl::convertToUppercaseWithLocale(const AtomString&amp; localeIdentifier)
 580 {
 581     // Use the more-optimized code path most of the time.
 582     // Assuming here that the only locale-specific lowercasing is the Turkish casing rules,
 583     // and that the only affected character is lowercase &quot;i&quot;.
 584     if (!needsTurkishCasingRules(localeIdentifier) || find(&#39;i&#39;) == notFound)
 585         return convertToUppercaseWithoutLocale();
 586 
 587     if (m_length &gt; MaxLength)
 588         CRASH();
 589     int length = m_length;
 590 
 591     // Below, we pass in the hardcoded locale &quot;tr&quot;. Passing that is more efficient than
 592     // allocating memory just to turn localeIdentifier into a C string, and we assume
 593     // there is no difference between the uppercasing for &quot;tr&quot; and &quot;az&quot; locales.
 594     auto upconvertedCharacters = StringView(*this).upconvertedCharacters();
 595     const UChar* source16 = upconvertedCharacters;
 596     UChar* data16;
 597     auto newString = createUninitialized(length, data16);
 598     UErrorCode status = U_ZERO_ERROR;
 599     int realLength = u_strToUpper(data16, length, source16, length, &quot;tr&quot;, &amp;status);
 600     if (U_SUCCESS(status) &amp;&amp; realLength == length)
 601         return newString;
 602     newString = createUninitialized(realLength, data16);
 603     status = U_ZERO_ERROR;
 604     u_strToUpper(data16, realLength, source16, length, &quot;tr&quot;, &amp;status);
 605     if (U_FAILURE(status))
 606         return *this;
 607     return newString;
 608 }
 609 
 610 Ref&lt;StringImpl&gt; StringImpl::foldCase()
 611 {
 612     if (is8Bit()) {
 613         unsigned failingIndex;
 614         for (unsigned i = 0; i &lt; m_length; ++i) {
 615             auto character = m_data8[i];
 616             if (UNLIKELY(!isASCII(character) || isASCIIUpper(character))) {
 617                 failingIndex = i;
 618                 goto SlowPath;
 619             }
 620         }
 621         // String was all ASCII and no uppercase, so just return as-is.
 622         return *this;
 623 
 624 SlowPath:
 625         bool need16BitCharacters = false;
 626         for (unsigned i = failingIndex; i &lt; m_length; ++i) {
 627             auto character = m_data8[i];
 628             if (character == 0xB5 || character == 0xDF) {
 629                 need16BitCharacters = true;
 630                 break;
 631             }
 632         }
 633 
 634         if (!need16BitCharacters) {
 635             LChar* data8;
 636             auto folded = createUninitializedInternalNonEmpty(m_length, data8);
 637             copyCharacters(data8, m_data8, failingIndex);
 638             for (unsigned i = failingIndex; i &lt; m_length; ++i) {
 639                 auto character = m_data8[i];
 640                 if (isASCII(character))
 641                     data8[i] = toASCIILower(character);
 642                 else {
 643                     ASSERT(isLatin1(u_foldCase(character, U_FOLD_CASE_DEFAULT)));
 644                     data8[i] = static_cast&lt;LChar&gt;(u_foldCase(character, U_FOLD_CASE_DEFAULT));
 645                 }
 646             }
 647             return folded;
 648         }
 649     } else {
 650         // FIXME: Unclear why we use goto in the 8-bit case, and a different approach in the 16-bit case.
 651         bool noUpper = true;
 652         unsigned ored = 0;
 653         for (unsigned i = 0; i &lt; m_length; ++i) {
 654             UChar character = m_data16[i];
 655             if (UNLIKELY(isASCIIUpper(character)))
 656                 noUpper = false;
 657             ored |= character;
 658         }
 659         if (!(ored &amp; ~0x7F)) {
 660             if (noUpper) {
 661                 // String was all ASCII and no uppercase, so just return as-is.
 662                 return *this;
 663             }
 664             UChar* data16;
 665             auto folded = createUninitializedInternalNonEmpty(m_length, data16);
 666             for (unsigned i = 0; i &lt; m_length; ++i)
 667                 data16[i] = toASCIILower(m_data16[i]);
 668             return folded;
 669         }
 670     }
 671 
 672     if (m_length &gt; MaxLength)
 673         CRASH();
 674 
 675     auto upconvertedCharacters = StringView(*this).upconvertedCharacters();
 676 
 677     UChar* data;
 678     auto folded = createUninitializedInternalNonEmpty(m_length, data);
 679     int32_t length = m_length;
 680     UErrorCode status = U_ZERO_ERROR;
 681     int32_t realLength = u_strFoldCase(data, length, upconvertedCharacters, length, U_FOLD_CASE_DEFAULT, &amp;status);
 682     if (U_SUCCESS(status) &amp;&amp; realLength == length)
 683         return folded;
 684     ASSERT(realLength &gt; length);
 685     folded = createUninitializedInternalNonEmpty(realLength, data);
 686     status = U_ZERO_ERROR;
 687     u_strFoldCase(data, realLength, upconvertedCharacters, length, U_FOLD_CASE_DEFAULT, &amp;status);
 688     if (U_FAILURE(status))
 689         return *this;
 690     return folded;
 691 }
 692 
 693 template&lt;StringImpl::CaseConvertType type, typename CharacterType&gt;
 694 ALWAYS_INLINE Ref&lt;StringImpl&gt; StringImpl::convertASCIICase(StringImpl&amp; impl, const CharacterType* data, unsigned length)
 695 {
 696     unsigned failingIndex;
 697     for (unsigned i = 0; i &lt; length; ++i) {
 698         CharacterType character = data[i];
 699         if (type == CaseConvertType::Lower ? UNLIKELY(isASCIIUpper(character)) : LIKELY(isASCIILower(character))) {
 700             failingIndex = i;
 701             goto SlowPath;
 702         }
 703     }
 704     return impl;
 705 
 706 SlowPath:
 707     CharacterType* newData;
 708     auto newImpl = createUninitializedInternalNonEmpty(length, newData);
 709     copyCharacters(newData, data, failingIndex);
 710     for (unsigned i = failingIndex; i &lt; length; ++i)
 711         newData[i] = type == CaseConvertType::Lower ? toASCIILower(data[i]) : toASCIIUpper(data[i]);
 712     return newImpl;
 713 }
 714 
 715 Ref&lt;StringImpl&gt; StringImpl::convertToASCIILowercase()
 716 {
 717     if (is8Bit())
 718         return convertASCIICase&lt;CaseConvertType::Lower&gt;(*this, m_data8, m_length);
 719     return convertASCIICase&lt;CaseConvertType::Lower&gt;(*this, m_data16, m_length);
 720 }
 721 
 722 Ref&lt;StringImpl&gt; StringImpl::convertToASCIIUppercase()
 723 {
 724     if (is8Bit())
 725         return convertASCIICase&lt;CaseConvertType::Upper&gt;(*this, m_data8, m_length);
 726     return convertASCIICase&lt;CaseConvertType::Upper&gt;(*this, m_data16, m_length);
 727 }
 728 
 729 template&lt;typename CodeUnitPredicate&gt; inline Ref&lt;StringImpl&gt; StringImpl::stripMatchedCharacters(CodeUnitPredicate predicate)
 730 {
 731     if (!m_length)
 732         return *this;
 733 
 734     unsigned start = 0;
 735     unsigned end = m_length - 1;
 736 
 737     // skip white space from start
 738     while (start &lt;= end &amp;&amp; predicate(is8Bit() ? m_data8[start] : m_data16[start]))
 739         ++start;
 740 
 741     // only white space
 742     if (start &gt; end)
 743         return *empty();
 744 
 745     // skip white space from end
 746     while (end &amp;&amp; predicate(is8Bit() ? m_data8[end] : m_data16[end]))
 747         --end;
 748 
 749     if (!start &amp;&amp; end == m_length - 1)
 750         return *this;
 751     if (is8Bit())
 752         return create(m_data8 + start, end + 1 - start);
 753     return create(m_data16 + start, end + 1 - start);
 754 }
 755 
 756 Ref&lt;StringImpl&gt; StringImpl::stripWhiteSpace()
 757 {
 758     return stripMatchedCharacters(isSpaceOrNewline);
 759 }
 760 
 761 Ref&lt;StringImpl&gt; StringImpl::stripLeadingAndTrailingCharacters(CodeUnitMatchFunction predicate)
 762 {
 763     return stripMatchedCharacters(predicate);
 764 }
 765 
 766 template&lt;typename CharacterType&gt; ALWAYS_INLINE Ref&lt;StringImpl&gt; StringImpl::removeCharacters(const CharacterType* characters, CodeUnitMatchFunction findMatch)
 767 {
 768     auto* from = characters;
 769     auto* fromEnd = from + m_length;
 770 
 771     // Assume the common case will not remove any characters
 772     while (from != fromEnd &amp;&amp; !findMatch(*from))
 773         ++from;
 774     if (from == fromEnd)
 775         return *this;
 776 
 777     StringBuffer&lt;CharacterType&gt; data(m_length);
 778     auto* to = data.characters();
 779     unsigned outc = from - characters;
 780 
 781     if (outc)
 782         copyCharacters(to, characters, outc);
 783 
 784     do {
 785         while (from != fromEnd &amp;&amp; findMatch(*from))
 786             ++from;
 787         while (from != fromEnd &amp;&amp; !findMatch(*from))
 788             to[outc++] = *from++;
 789     } while (from != fromEnd);
 790 
 791     data.shrink(outc);
 792 
 793     return adopt(WTFMove(data));
 794 }
 795 
 796 Ref&lt;StringImpl&gt; StringImpl::removeCharacters(CodeUnitMatchFunction findMatch)
 797 {
 798     if (is8Bit())
 799         return removeCharacters(characters8(), findMatch);
 800     return removeCharacters(characters16(), findMatch);
 801 }
 802 
 803 template&lt;typename CharacterType, class UCharPredicate&gt; inline Ref&lt;StringImpl&gt; StringImpl::simplifyMatchedCharactersToSpace(UCharPredicate predicate)
 804 {
 805     StringBuffer&lt;CharacterType&gt; data(m_length);
 806 
 807     auto* from = characters&lt;CharacterType&gt;();
 808     auto* fromEnd = from + m_length;
 809     unsigned outc = 0;
 810     bool changedToSpace = false;
 811 
 812     auto* to = data.characters();
 813 
 814     while (true) {
 815         while (from != fromEnd &amp;&amp; predicate(*from)) {
 816             if (*from != &#39; &#39;)
 817                 changedToSpace = true;
 818             ++from;
 819         }
 820         while (from != fromEnd &amp;&amp; !predicate(*from))
 821             to[outc++] = *from++;
 822         if (from != fromEnd)
 823             to[outc++] = &#39; &#39;;
 824         else
 825             break;
 826     }
 827 
 828     if (outc &amp;&amp; to[outc - 1] == &#39; &#39;)
 829         --outc;
 830 
 831     if (outc == m_length &amp;&amp; !changedToSpace)
 832         return *this;
 833 
 834     data.shrink(outc);
 835 
 836     return adopt(WTFMove(data));
 837 }
 838 
 839 Ref&lt;StringImpl&gt; StringImpl::simplifyWhiteSpace()
 840 {
 841     if (is8Bit())
 842         return StringImpl::simplifyMatchedCharactersToSpace&lt;LChar&gt;(isSpaceOrNewline);
 843     return StringImpl::simplifyMatchedCharactersToSpace&lt;UChar&gt;(isSpaceOrNewline);
 844 }
 845 
 846 Ref&lt;StringImpl&gt; StringImpl::simplifyWhiteSpace(CodeUnitMatchFunction isWhiteSpace)
 847 {
 848     if (is8Bit())
 849         return StringImpl::simplifyMatchedCharactersToSpace&lt;LChar&gt;(isWhiteSpace);
 850     return StringImpl::simplifyMatchedCharactersToSpace&lt;UChar&gt;(isWhiteSpace);
 851 }
 852 
 853 int StringImpl::toIntStrict(bool* ok, int base)
 854 {
 855     if (is8Bit())
 856         return charactersToIntStrict(characters8(), m_length, ok, base);
 857     return charactersToIntStrict(characters16(), m_length, ok, base);
 858 }
 859 
 860 unsigned StringImpl::toUIntStrict(bool* ok, int base)
 861 {
 862     if (is8Bit())
 863         return charactersToUIntStrict(characters8(), m_length, ok, base);
 864     return charactersToUIntStrict(characters16(), m_length, ok, base);
 865 }
 866 
 867 int64_t StringImpl::toInt64Strict(bool* ok, int base)
 868 {
 869     if (is8Bit())
 870         return charactersToInt64Strict(characters8(), m_length, ok, base);
 871     return charactersToInt64Strict(characters16(), m_length, ok, base);
 872 }
 873 
 874 uint64_t StringImpl::toUInt64Strict(bool* ok, int base)
 875 {
 876     if (is8Bit())
 877         return charactersToUInt64Strict(characters8(), m_length, ok, base);
 878     return charactersToUInt64Strict(characters16(), m_length, ok, base);
 879 }
 880 
 881 intptr_t StringImpl::toIntPtrStrict(bool* ok, int base)
 882 {
 883     if (is8Bit())
 884         return charactersToIntPtrStrict(characters8(), m_length, ok, base);
 885     return charactersToIntPtrStrict(characters16(), m_length, ok, base);
 886 }
 887 
 888 int StringImpl::toInt(bool* ok)
 889 {
 890     if (is8Bit())
 891         return charactersToInt(characters8(), m_length, ok);
 892     return charactersToInt(characters16(), m_length, ok);
 893 }
 894 
 895 unsigned StringImpl::toUInt(bool* ok)
 896 {
 897     if (is8Bit())
 898         return charactersToUInt(characters8(), m_length, ok);
 899     return charactersToUInt(characters16(), m_length, ok);
 900 }
 901 
 902 int64_t StringImpl::toInt64(bool* ok)
 903 {
 904     if (is8Bit())
 905         return charactersToInt64(characters8(), m_length, ok);
 906     return charactersToInt64(characters16(), m_length, ok);
 907 }
 908 
 909 uint64_t StringImpl::toUInt64(bool* ok)
 910 {
 911     if (is8Bit())
 912         return charactersToUInt64(characters8(), m_length, ok);
 913     return charactersToUInt64(characters16(), m_length, ok);
 914 }
 915 
 916 intptr_t StringImpl::toIntPtr(bool* ok)
 917 {
 918     if (is8Bit())
 919         return charactersToIntPtr(characters8(), m_length, ok);
 920     return charactersToIntPtr(characters16(), m_length, ok);
 921 }
 922 
 923 double StringImpl::toDouble(bool* ok)
 924 {
 925     if (is8Bit())
 926         return charactersToDouble(characters8(), m_length, ok);
 927     return charactersToDouble(characters16(), m_length, ok);
 928 }
 929 
 930 float StringImpl::toFloat(bool* ok)
 931 {
 932     if (is8Bit())
 933         return charactersToFloat(characters8(), m_length, ok);
 934     return charactersToFloat(characters16(), m_length, ok);
 935 }
 936 
 937 size_t StringImpl::find(CodeUnitMatchFunction matchFunction, unsigned start)
 938 {
 939     if (is8Bit())
 940         return WTF::find(characters8(), m_length, matchFunction, start);
 941     return WTF::find(characters16(), m_length, matchFunction, start);
 942 }
 943 
 944 size_t StringImpl::find(const LChar* matchString, unsigned index)
 945 {
 946     // Check for null or empty string to match against
 947     if (!matchString)
 948         return notFound;
 949     size_t matchStringLength = strlen(reinterpret_cast&lt;const char*&gt;(matchString));
 950     if (matchStringLength &gt; MaxLength)
 951         CRASH();
 952     unsigned matchLength = matchStringLength;
 953     if (!matchLength)
 954         return std::min(index, length());
 955 
 956     // Optimization 1: fast case for strings of length 1.
 957     if (matchLength == 1) {
 958         if (is8Bit())
 959             return WTF::find(characters8(), length(), matchString[0], index);
 960         return WTF::find(characters16(), length(), *matchString, index);
 961     }
 962 
 963     // Check index &amp; matchLength are in range.
 964     if (index &gt; length())
 965         return notFound;
 966     unsigned searchLength = length() - index;
 967     if (matchLength &gt; searchLength)
 968         return notFound;
 969     // delta is the number of additional times to test; delta == 0 means test only once.
 970     unsigned delta = searchLength - matchLength;
 971 
 972     // Optimization 2: keep a running hash of the strings,
 973     // only call equal if the hashes match.
 974 
 975     if (is8Bit()) {
 976         const LChar* searchCharacters = characters8() + index;
 977 
 978         unsigned searchHash = 0;
 979         unsigned matchHash = 0;
 980         for (unsigned i = 0; i &lt; matchLength; ++i) {
 981             searchHash += searchCharacters[i];
 982             matchHash += matchString[i];
 983         }
 984 
 985         unsigned i = 0;
 986         while (searchHash != matchHash || !equal(searchCharacters + i, matchString, matchLength)) {
 987             if (i == delta)
 988                 return notFound;
 989             searchHash += searchCharacters[i + matchLength];
 990             searchHash -= searchCharacters[i];
 991             ++i;
 992         }
 993         return index + i;
 994     }
 995 
 996     const UChar* searchCharacters = characters16() + index;
 997 
 998     unsigned searchHash = 0;
 999     unsigned matchHash = 0;
1000     for (unsigned i = 0; i &lt; matchLength; ++i) {
1001         searchHash += searchCharacters[i];
1002         matchHash += matchString[i];
1003     }
1004 
1005     unsigned i = 0;
1006     while (searchHash != matchHash || !equal(searchCharacters + i, matchString, matchLength)) {
1007         if (i == delta)
1008             return notFound;
1009         searchHash += searchCharacters[i + matchLength];
1010         searchHash -= searchCharacters[i];
1011         ++i;
1012     }
1013     return index + i;
1014 }
1015 
1016 size_t StringImpl::find(StringImpl* matchString)
1017 {
1018     // Check for null string to match against
1019     if (UNLIKELY(!matchString))
1020         return notFound;
1021     unsigned matchLength = matchString-&gt;length();
1022 
1023     // Optimization 1: fast case for strings of length 1.
1024     if (matchLength == 1) {
1025         if (is8Bit()) {
1026             if (matchString-&gt;is8Bit())
1027                 return WTF::find(characters8(), length(), matchString-&gt;characters8()[0]);
1028             return WTF::find(characters8(), length(), matchString-&gt;characters16()[0]);
1029         }
1030         if (matchString-&gt;is8Bit())
1031             return WTF::find(characters16(), length(), matchString-&gt;characters8()[0]);
1032         return WTF::find(characters16(), length(), matchString-&gt;characters16()[0]);
1033     }
1034 
1035     // Check matchLength is in range.
1036     if (matchLength &gt; length())
1037         return notFound;
1038 
1039     // Check for empty string to match against
1040     if (UNLIKELY(!matchLength))
1041         return 0;
1042 
1043     if (is8Bit()) {
1044         if (matchString-&gt;is8Bit())
1045             return findInner(characters8(), matchString-&gt;characters8(), 0, length(), matchLength);
1046         return findInner(characters8(), matchString-&gt;characters16(), 0, length(), matchLength);
1047     }
1048 
1049     if (matchString-&gt;is8Bit())
1050         return findInner(characters16(), matchString-&gt;characters8(), 0, length(), matchLength);
1051 
1052     return findInner(characters16(), matchString-&gt;characters16(), 0, length(), matchLength);
1053 }
1054 
1055 size_t StringImpl::find(StringImpl* matchString, unsigned index)
1056 {
1057     // Check for null or empty string to match against
1058     if (UNLIKELY(!matchString))
1059         return notFound;
1060 
1061     return findCommon(*this, *matchString, index);
1062 }
1063 
1064 size_t StringImpl::findIgnoringASCIICase(const StringImpl&amp; matchString) const
1065 {
1066     return ::WTF::findIgnoringASCIICase(*this, matchString, 0);
1067 }
1068 
1069 size_t StringImpl::findIgnoringASCIICase(const StringImpl&amp; matchString, unsigned startOffset) const
1070 {
1071     return ::WTF::findIgnoringASCIICase(*this, matchString, startOffset);
1072 }
1073 
1074 size_t StringImpl::findIgnoringASCIICase(const StringImpl* matchString) const
1075 {
1076     if (!matchString)
1077         return notFound;
1078     return ::WTF::findIgnoringASCIICase(*this, *matchString, 0);
1079 }
1080 
1081 size_t StringImpl::findIgnoringASCIICase(const StringImpl* matchString, unsigned startOffset) const
1082 {
1083     if (!matchString)
1084         return notFound;
1085     return ::WTF::findIgnoringASCIICase(*this, *matchString, startOffset);
1086 }
1087 
1088 size_t StringImpl::reverseFind(UChar character, unsigned index)
1089 {
1090     if (is8Bit())
1091         return WTF::reverseFind(characters8(), m_length, character, index);
1092     return WTF::reverseFind(characters16(), m_length, character, index);
1093 }
1094 
1095 template &lt;typename SearchCharacterType, typename MatchCharacterType&gt;
1096 ALWAYS_INLINE static size_t reverseFindInner(const SearchCharacterType* searchCharacters, const MatchCharacterType* matchCharacters, unsigned index, unsigned length, unsigned matchLength)
1097 {
1098     // Optimization: keep a running hash of the strings,
1099     // only call equal if the hashes match.
1100 
1101     // delta is the number of additional times to test; delta == 0 means test only once.
1102     unsigned delta = std::min(index, length - matchLength);
1103 
1104     unsigned searchHash = 0;
1105     unsigned matchHash = 0;
1106     for (unsigned i = 0; i &lt; matchLength; ++i) {
1107         searchHash += searchCharacters[delta + i];
1108         matchHash += matchCharacters[i];
1109     }
1110 
1111     // keep looping until we match
1112     while (searchHash != matchHash || !equal(searchCharacters + delta, matchCharacters, matchLength)) {
1113         if (!delta)
1114             return notFound;
1115         --delta;
1116         searchHash -= searchCharacters[delta + matchLength];
1117         searchHash += searchCharacters[delta];
1118     }
1119     return delta;
1120 }
1121 
1122 size_t StringImpl::reverseFind(StringImpl* matchString, unsigned index)
1123 {
1124     // Check for null or empty string to match against
1125     if (!matchString)
1126         return notFound;
1127     unsigned matchLength = matchString-&gt;length();
1128     unsigned ourLength = length();
1129     if (!matchLength)
1130         return std::min(index, ourLength);
1131 
1132     // Optimization 1: fast case for strings of length 1.
1133     if (matchLength == 1) {
1134         if (is8Bit())
1135             return WTF::reverseFind(characters8(), ourLength, (*matchString)[0], index);
1136         return WTF::reverseFind(characters16(), ourLength, (*matchString)[0], index);
1137     }
1138 
1139     // Check index &amp; matchLength are in range.
1140     if (matchLength &gt; ourLength)
1141         return notFound;
1142 
1143     if (is8Bit()) {
1144         if (matchString-&gt;is8Bit())
1145             return reverseFindInner(characters8(), matchString-&gt;characters8(), index, ourLength, matchLength);
1146         return reverseFindInner(characters8(), matchString-&gt;characters16(), index, ourLength, matchLength);
1147     }
1148 
1149     if (matchString-&gt;is8Bit())
1150         return reverseFindInner(characters16(), matchString-&gt;characters8(), index, ourLength, matchLength);
1151 
1152     return reverseFindInner(characters16(), matchString-&gt;characters16(), index, ourLength, matchLength);
1153 }
1154 
1155 ALWAYS_INLINE static bool equalInner(const StringImpl&amp; string, unsigned startOffset, const char* matchString, unsigned matchLength)
1156 {
1157     ASSERT(matchLength &lt;= string.length());
1158     ASSERT(startOffset + matchLength &lt;= string.length());
1159 
1160     if (string.is8Bit())
1161         return equal(string.characters8() + startOffset, reinterpret_cast&lt;const LChar*&gt;(matchString), matchLength);
1162     return equal(string.characters16() + startOffset, reinterpret_cast&lt;const LChar*&gt;(matchString), matchLength);
1163 }
1164 
1165 ALWAYS_INLINE static bool equalInner(const StringImpl&amp; string, unsigned startOffset, const StringImpl&amp; matchString)
1166 {
1167     if (startOffset &gt; string.length())
1168         return false;
1169     if (matchString.length() &gt; string.length())
1170         return false;
1171     if (matchString.length() + startOffset &gt; string.length())
1172         return false;
1173 
1174     if (string.is8Bit()) {
1175         if (matchString.is8Bit())
1176             return equal(string.characters8() + startOffset, matchString.characters8(), matchString.length());
1177         return equal(string.characters8() + startOffset, matchString.characters16(), matchString.length());
1178     }
1179     if (matchString.is8Bit())
1180         return equal(string.characters16() + startOffset, matchString.characters8(), matchString.length());
1181     return equal(string.characters16() + startOffset, matchString.characters16(), matchString.length());
1182 }
1183 
1184 bool StringImpl::startsWith(const StringImpl* string) const
1185 {
1186     return string &amp;&amp; ::WTF::startsWith(*this, *string);
1187 }
1188 
1189 bool StringImpl::startsWith(const StringImpl&amp; string) const
1190 {
1191     return ::WTF::startsWith(*this, string);
1192 }
1193 
1194 bool StringImpl::startsWithIgnoringASCIICase(const StringImpl* prefix) const
1195 {
1196     return prefix &amp;&amp; ::WTF::startsWithIgnoringASCIICase(*this, *prefix);
1197 }
1198 
1199 bool StringImpl::startsWithIgnoringASCIICase(const StringImpl&amp; prefix) const
1200 {
1201     return ::WTF::startsWithIgnoringASCIICase(*this, prefix);
1202 }
1203 
1204 bool StringImpl::startsWith(UChar character) const
1205 {
1206     return m_length &amp;&amp; (*this)[0] == character;
1207 }
1208 
1209 bool StringImpl::startsWith(const char* matchString, unsigned matchLength) const
1210 {
1211     return matchLength &lt;= length() &amp;&amp; equalInner(*this, 0, matchString, matchLength);
1212 }
1213 
1214 bool StringImpl::hasInfixStartingAt(const StringImpl&amp; matchString, unsigned startOffset) const
1215 {
1216     return equalInner(*this, startOffset, matchString);
1217 }
1218 
1219 bool StringImpl::endsWith(StringImpl* suffix)
1220 {
1221     return suffix &amp;&amp; ::WTF::endsWith(*this, *suffix);
1222 }
1223 
1224 bool StringImpl::endsWith(StringImpl&amp; suffix)
1225 {
1226     return ::WTF::endsWith(*this, suffix);
1227 }
1228 
1229 bool StringImpl::endsWithIgnoringASCIICase(const StringImpl* suffix) const
1230 {
1231     return suffix &amp;&amp; ::WTF::endsWithIgnoringASCIICase(*this, *suffix);
1232 }
1233 
1234 bool StringImpl::endsWithIgnoringASCIICase(const StringImpl&amp; suffix) const
1235 {
1236     return ::WTF::endsWithIgnoringASCIICase(*this, suffix);
1237 }
1238 
1239 bool StringImpl::endsWith(UChar character) const
1240 {
1241     return m_length &amp;&amp; (*this)[m_length - 1] == character;
1242 }
1243 
1244 bool StringImpl::endsWith(const char* matchString, unsigned matchLength) const
1245 {
1246     return matchLength &lt;= length() &amp;&amp; equalInner(*this, length() - matchLength, matchString, matchLength);
1247 }
1248 
1249 bool StringImpl::hasInfixEndingAt(const StringImpl&amp; matchString, unsigned endOffset) const
1250 {
1251     return endOffset &gt;= matchString.length() &amp;&amp; equalInner(*this, endOffset - matchString.length(), matchString);
1252 }
1253 
1254 Ref&lt;StringImpl&gt; StringImpl::replace(UChar target, UChar replacement)
1255 {
1256     if (target == replacement)
1257         return *this;
1258     unsigned i;
1259     for (i = 0; i != m_length; ++i) {
1260         UChar character = is8Bit() ? m_data8[i] : m_data16[i];
1261         if (character == target)
1262             break;
1263     }
1264     if (i == m_length)
1265         return *this;
1266 
1267     if (is8Bit()) {
1268         if (!isLatin1(target)) {
1269             // Looking for a 16-bit character in an 8-bit string, so we&#39;re done.
1270             return *this;
1271         }
1272 
1273         if (isLatin1(replacement)) {
1274             LChar* data;
1275             LChar oldChar = static_cast&lt;LChar&gt;(target);
1276             LChar newChar = static_cast&lt;LChar&gt;(replacement);
1277 
1278             auto newImpl = createUninitializedInternalNonEmpty(m_length, data);
1279 
1280             for (i = 0; i != m_length; ++i) {
1281                 LChar character = m_data8[i];
1282                 if (character == oldChar)
1283                     character = newChar;
1284                 data[i] = character;
1285             }
1286             return newImpl;
1287         }
1288 
1289         UChar* data;
1290         auto newImpl = createUninitializedInternalNonEmpty(m_length, data);
1291 
1292         for (i = 0; i != m_length; ++i) {
1293             UChar character = m_data8[i];
1294             if (character == target)
1295                 character = replacement;
1296             data[i] = character;
1297         }
1298 
1299         return newImpl;
1300     }
1301 
1302     UChar* data;
1303     auto newImpl = createUninitializedInternalNonEmpty(m_length, data);
1304 
1305     for (i = 0; i != m_length; ++i) {
1306         UChar character = m_data16[i];
1307         if (character == target)
1308             character = replacement;
1309         data[i] = character;
1310     }
1311     return newImpl;
1312 }
1313 
1314 Ref&lt;StringImpl&gt; StringImpl::replace(unsigned position, unsigned lengthToReplace, StringImpl* string)
1315 {
1316     position = std::min(position, length());
1317     lengthToReplace = std::min(lengthToReplace, length() - position);
1318     unsigned lengthToInsert = string ? string-&gt;length() : 0;
1319     if (!lengthToReplace &amp;&amp; !lengthToInsert)
1320         return *this;
1321 
1322     if ((length() - lengthToReplace) &gt;= (MaxLength - lengthToInsert))
1323         CRASH();
1324 
1325     if (is8Bit() &amp;&amp; (!string || string-&gt;is8Bit())) {
1326         LChar* data;
1327         auto newImpl = createUninitialized(length() - lengthToReplace + lengthToInsert, data);
1328         copyCharacters(data, m_data8, position);
1329         if (string)
1330             copyCharacters(data + position, string-&gt;m_data8, lengthToInsert);
1331         copyCharacters(data + position + lengthToInsert, m_data8 + position + lengthToReplace, length() - position - lengthToReplace);
1332         return newImpl;
1333     }
1334     UChar* data;
1335     auto newImpl = createUninitialized(length() - lengthToReplace + lengthToInsert, data);
1336     if (is8Bit())
1337         copyCharacters(data, m_data8, position);
1338     else
1339         copyCharacters(data, m_data16, position);
1340     if (string) {
1341         if (string-&gt;is8Bit())
1342             copyCharacters(data + position, string-&gt;m_data8, lengthToInsert);
1343         else
1344             copyCharacters(data + position, string-&gt;m_data16, lengthToInsert);
1345     }
1346     if (is8Bit())
1347         copyCharacters(data + position + lengthToInsert, m_data8 + position + lengthToReplace, length() - position - lengthToReplace);
1348     else
1349         copyCharacters(data + position + lengthToInsert, m_data16 + position + lengthToReplace, length() - position - lengthToReplace);
1350     return newImpl;
1351 }
1352 
1353 Ref&lt;StringImpl&gt; StringImpl::replace(UChar pattern, StringImpl* replacement)
1354 {
1355     if (!replacement)
1356         return *this;
1357     if (replacement-&gt;is8Bit())
1358         return replace(pattern, replacement-&gt;m_data8, replacement-&gt;length());
1359     return replace(pattern, replacement-&gt;m_data16, replacement-&gt;length());
1360 }
1361 
1362 Ref&lt;StringImpl&gt; StringImpl::replace(UChar pattern, const LChar* replacement, unsigned repStrLength)
1363 {
1364     ASSERT(replacement);
1365 
1366     size_t srcSegmentStart = 0;
1367     unsigned matchCount = 0;
1368 
1369     // Count the matches.
1370     while ((srcSegmentStart = find(pattern, srcSegmentStart)) != notFound) {
1371         ++matchCount;
1372         ++srcSegmentStart;
1373     }
1374 
1375     // If we have 0 matches then we don&#39;t have to do any more work.
1376     if (!matchCount)
1377         return *this;
1378 
1379     if (repStrLength &amp;&amp; matchCount &gt; MaxLength / repStrLength)
1380         CRASH();
1381 
1382     unsigned replaceSize = matchCount * repStrLength;
1383     unsigned newSize = m_length - matchCount;
1384     if (newSize &gt;= (MaxLength - replaceSize))
1385         CRASH();
1386 
1387     newSize += replaceSize;
1388 
1389     // Construct the new data.
1390     size_t srcSegmentEnd;
1391     unsigned srcSegmentLength;
1392     srcSegmentStart = 0;
1393     unsigned dstOffset = 0;
1394 
1395     if (is8Bit()) {
1396         LChar* data;
1397         auto newImpl = createUninitialized(newSize, data);
1398 
1399         while ((srcSegmentEnd = find(pattern, srcSegmentStart)) != notFound) {
1400             srcSegmentLength = srcSegmentEnd - srcSegmentStart;
1401             copyCharacters(data + dstOffset, m_data8 + srcSegmentStart, srcSegmentLength);
1402             dstOffset += srcSegmentLength;
1403             copyCharacters(data + dstOffset, replacement, repStrLength);
1404             dstOffset += repStrLength;
1405             srcSegmentStart = srcSegmentEnd + 1;
1406         }
1407 
1408         srcSegmentLength = m_length - srcSegmentStart;
1409         copyCharacters(data + dstOffset, m_data8 + srcSegmentStart, srcSegmentLength);
1410 
1411         ASSERT(dstOffset + srcSegmentLength == newImpl.get().length());
1412 
1413         return newImpl;
1414     }
1415 
1416     UChar* data;
1417     auto newImpl = createUninitialized(newSize, data);
1418 
1419     while ((srcSegmentEnd = find(pattern, srcSegmentStart)) != notFound) {
1420         srcSegmentLength = srcSegmentEnd - srcSegmentStart;
1421         copyCharacters(data + dstOffset, m_data16 + srcSegmentStart, srcSegmentLength);
1422 
1423         dstOffset += srcSegmentLength;
1424         copyCharacters(data + dstOffset, replacement, repStrLength);
1425 
1426         dstOffset += repStrLength;
1427         srcSegmentStart = srcSegmentEnd + 1;
1428     }
1429 
1430     srcSegmentLength = m_length - srcSegmentStart;
1431     copyCharacters(data + dstOffset, m_data16 + srcSegmentStart, srcSegmentLength);
1432 
1433     ASSERT(dstOffset + srcSegmentLength == newImpl.get().length());
1434 
1435     return newImpl;
1436 }
1437 
1438 Ref&lt;StringImpl&gt; StringImpl::replace(UChar pattern, const UChar* replacement, unsigned repStrLength)
1439 {
1440     ASSERT(replacement);
1441 
1442     size_t srcSegmentStart = 0;
1443     unsigned matchCount = 0;
1444 
1445     // Count the matches.
1446     while ((srcSegmentStart = find(pattern, srcSegmentStart)) != notFound) {
1447         ++matchCount;
1448         ++srcSegmentStart;
1449     }
1450 
1451     // If we have 0 matches then we don&#39;t have to do any more work.
1452     if (!matchCount)
1453         return *this;
1454 
1455     if (repStrLength &amp;&amp; matchCount &gt; MaxLength / repStrLength)
1456         CRASH();
1457 
1458     unsigned replaceSize = matchCount * repStrLength;
1459     unsigned newSize = m_length - matchCount;
1460     if (newSize &gt;= (MaxLength - replaceSize))
1461         CRASH();
1462 
1463     newSize += replaceSize;
1464 
1465     // Construct the new data.
1466     size_t srcSegmentEnd;
1467     unsigned srcSegmentLength;
1468     srcSegmentStart = 0;
1469     unsigned dstOffset = 0;
1470 
1471     if (is8Bit()) {
1472         UChar* data;
1473         auto newImpl = createUninitialized(newSize, data);
1474 
1475         while ((srcSegmentEnd = find(pattern, srcSegmentStart)) != notFound) {
1476             srcSegmentLength = srcSegmentEnd - srcSegmentStart;
1477             copyCharacters(data + dstOffset, m_data8 + srcSegmentStart, srcSegmentLength);
1478 
1479             dstOffset += srcSegmentLength;
1480             copyCharacters(data + dstOffset, replacement, repStrLength);
1481 
1482             dstOffset += repStrLength;
1483             srcSegmentStart = srcSegmentEnd + 1;
1484         }
1485 
1486         srcSegmentLength = m_length - srcSegmentStart;
1487         copyCharacters(data + dstOffset, m_data8 + srcSegmentStart, srcSegmentLength);
1488 
1489         ASSERT(dstOffset + srcSegmentLength == newImpl.get().length());
1490 
1491         return newImpl;
1492     }
1493 
1494     UChar* data;
1495     auto newImpl = createUninitialized(newSize, data);
1496 
1497     while ((srcSegmentEnd = find(pattern, srcSegmentStart)) != notFound) {
1498         srcSegmentLength = srcSegmentEnd - srcSegmentStart;
1499         copyCharacters(data + dstOffset, m_data16 + srcSegmentStart, srcSegmentLength);
1500 
1501         dstOffset += srcSegmentLength;
1502         copyCharacters(data + dstOffset, replacement, repStrLength);
1503 
1504         dstOffset += repStrLength;
1505         srcSegmentStart = srcSegmentEnd + 1;
1506     }
1507 
1508     srcSegmentLength = m_length - srcSegmentStart;
1509     copyCharacters(data + dstOffset, m_data16 + srcSegmentStart, srcSegmentLength);
1510 
1511     ASSERT(dstOffset + srcSegmentLength == newImpl.get().length());
1512 
1513     return newImpl;
1514 }
1515 
1516 Ref&lt;StringImpl&gt; StringImpl::replace(StringImpl* pattern, StringImpl* replacement)
1517 {
1518     if (!pattern || !replacement)
1519         return *this;
1520 
1521     unsigned patternLength = pattern-&gt;length();
1522     if (!patternLength)
1523         return *this;
1524 
1525     unsigned repStrLength = replacement-&gt;length();
1526     size_t srcSegmentStart = 0;
1527     unsigned matchCount = 0;
1528 
1529     // Count the matches.
1530     while ((srcSegmentStart = find(pattern, srcSegmentStart)) != notFound) {
1531         ++matchCount;
1532         srcSegmentStart += patternLength;
1533     }
1534 
1535     // If we have 0 matches, we don&#39;t have to do any more work
1536     if (!matchCount)
1537         return *this;
1538 
1539     unsigned newSize = m_length - matchCount * patternLength;
1540     if (repStrLength &amp;&amp; matchCount &gt; MaxLength / repStrLength)
1541         CRASH();
1542 
1543     if (newSize &gt; (MaxLength - matchCount * repStrLength))
1544         CRASH();
1545 
1546     newSize += matchCount * repStrLength;
1547 
1548 
1549     // Construct the new data
1550     size_t srcSegmentEnd;
1551     unsigned srcSegmentLength;
1552     srcSegmentStart = 0;
1553     unsigned dstOffset = 0;
1554     bool srcIs8Bit = is8Bit();
1555     bool replacementIs8Bit = replacement-&gt;is8Bit();
1556 
1557     // There are 4 cases:
1558     // 1. This and replacement are both 8 bit.
1559     // 2. This and replacement are both 16 bit.
1560     // 3. This is 8 bit and replacement is 16 bit.
1561     // 4. This is 16 bit and replacement is 8 bit.
1562     if (srcIs8Bit &amp;&amp; replacementIs8Bit) {
1563         // Case 1
1564         LChar* data;
1565         auto newImpl = createUninitialized(newSize, data);
1566         while ((srcSegmentEnd = find(pattern, srcSegmentStart)) != notFound) {
1567             srcSegmentLength = srcSegmentEnd - srcSegmentStart;
1568             copyCharacters(data + dstOffset, m_data8 + srcSegmentStart, srcSegmentLength);
1569             dstOffset += srcSegmentLength;
1570             copyCharacters(data + dstOffset, replacement-&gt;m_data8, repStrLength);
1571             dstOffset += repStrLength;
1572             srcSegmentStart = srcSegmentEnd + patternLength;
1573         }
1574 
1575         srcSegmentLength = m_length - srcSegmentStart;
1576         copyCharacters(data + dstOffset, m_data8 + srcSegmentStart, srcSegmentLength);
1577 
1578         ASSERT(dstOffset + srcSegmentLength == newImpl.get().length());
1579 
1580         return newImpl;
1581     }
1582 
1583     UChar* data;
1584     auto newImpl = createUninitialized(newSize, data);
1585     while ((srcSegmentEnd = find(pattern, srcSegmentStart)) != notFound) {
1586         srcSegmentLength = srcSegmentEnd - srcSegmentStart;
1587         if (srcIs8Bit) {
1588             // Case 3.
1589             copyCharacters(data + dstOffset, m_data8 + srcSegmentStart, srcSegmentLength);
1590         } else {
1591             // Case 2 &amp; 4.
1592             copyCharacters(data + dstOffset, m_data16 + srcSegmentStart, srcSegmentLength);
1593         }
1594         dstOffset += srcSegmentLength;
1595         if (replacementIs8Bit) {
1596             // Cases 2 &amp; 3.
1597             copyCharacters(data + dstOffset, replacement-&gt;m_data8, repStrLength);
1598         } else {
1599             // Case 4
1600             copyCharacters(data + dstOffset, replacement-&gt;m_data16, repStrLength);
1601         }
1602         dstOffset += repStrLength;
1603         srcSegmentStart = srcSegmentEnd + patternLength;
1604     }
1605 
1606     srcSegmentLength = m_length - srcSegmentStart;
1607     if (srcIs8Bit) {
1608         // Case 3.
1609         copyCharacters(data + dstOffset, m_data8 + srcSegmentStart, srcSegmentLength);
1610     } else {
1611         // Cases 2 &amp; 4.
1612         copyCharacters(data + dstOffset, m_data16 + srcSegmentStart, srcSegmentLength);
1613     }
1614 
1615     ASSERT(dstOffset + srcSegmentLength == newImpl.get().length());
1616 
1617     return newImpl;
1618 }
1619 
1620 bool equal(const StringImpl* a, const StringImpl* b)
1621 {
1622     return equalCommon(a, b);
1623 }
1624 
1625 template&lt;typename CharacterType&gt; inline bool equalInternal(const StringImpl* a, const CharacterType* b, unsigned length)
1626 {
1627     if (!a)
1628         return !b;
1629     if (!b)
1630         return false;
1631 
1632     if (a-&gt;length() != length)
1633         return false;
1634     if (a-&gt;is8Bit())
1635         return equal(a-&gt;characters8(), b, length);
1636     return equal(a-&gt;characters16(), b, length);
1637 }
1638 
1639 bool equal(const StringImpl* a, const LChar* b, unsigned length)
1640 {
1641     return equalInternal(a, b, length);
1642 }
1643 
1644 bool equal(const StringImpl* a, const UChar* b, unsigned length)
1645 {
1646     return equalInternal(a, b, length);
1647 }
1648 
1649 bool equal(const StringImpl* a, const LChar* b)
1650 {
1651     if (!a)
1652         return !b;
1653     if (!b)
1654         return !a;
1655 
1656     unsigned length = a-&gt;length();
1657 
1658     if (a-&gt;is8Bit()) {
1659         const LChar* aPtr = a-&gt;characters8();
1660         for (unsigned i = 0; i != length; ++i) {
1661             LChar bc = b[i];
1662             LChar ac = aPtr[i];
1663             if (!bc)
1664                 return false;
1665             if (ac != bc)
1666                 return false;
1667         }
1668 
1669         return !b[length];
1670     }
1671 
1672     const UChar* aPtr = a-&gt;characters16();
1673     for (unsigned i = 0; i != length; ++i) {
1674         LChar bc = b[i];
1675         if (!bc)
1676             return false;
1677         if (aPtr[i] != bc)
1678             return false;
1679     }
1680 
1681     return !b[length];
1682 }
1683 
1684 bool equal(const StringImpl&amp; a, const StringImpl&amp; b)
1685 {
1686     return equalCommon(a, b);
1687 }
1688 
1689 bool equalIgnoringNullity(StringImpl* a, StringImpl* b)
1690 {
1691     if (!a &amp;&amp; b &amp;&amp; !b-&gt;length())
1692         return true;
1693     if (!b &amp;&amp; a &amp;&amp; !a-&gt;length())
1694         return true;
1695     return equal(a, b);
1696 }
1697 
1698 bool equalIgnoringASCIICase(const StringImpl* a, const StringImpl* b)
1699 {
1700     return a == b || (a &amp;&amp; b &amp;&amp; equalIgnoringASCIICase(*a, *b));
1701 }
1702 
1703 bool equalIgnoringASCIICaseNonNull(const StringImpl* a, const StringImpl* b)
1704 {
1705     ASSERT(a);
1706     ASSERT(b);
1707     return equalIgnoringASCIICase(*a, *b);
1708 }
1709 
1710 UCharDirection StringImpl::defaultWritingDirection(bool* hasStrongDirectionality)
1711 {
1712     for (unsigned i = 0; i &lt; m_length; ++i) {
1713         auto charDirection = u_charDirection(is8Bit() ? m_data8[i] : m_data16[i]);
1714         if (charDirection == U_LEFT_TO_RIGHT) {
1715             if (hasStrongDirectionality)
1716                 *hasStrongDirectionality = true;
1717             return U_LEFT_TO_RIGHT;
1718         }
1719         if (charDirection == U_RIGHT_TO_LEFT || charDirection == U_RIGHT_TO_LEFT_ARABIC) {
1720             if (hasStrongDirectionality)
1721                 *hasStrongDirectionality = true;
1722             return U_RIGHT_TO_LEFT;
1723         }
1724     }
1725     if (hasStrongDirectionality)
1726         *hasStrongDirectionality = false;
1727     return U_LEFT_TO_RIGHT;
1728 }
1729 
1730 Ref&lt;StringImpl&gt; StringImpl::adopt(StringBuffer&lt;LChar&gt;&amp;&amp; buffer)
1731 {
1732     unsigned length = buffer.length();
1733     if (!length)
1734         return *empty();
1735     return adoptRef(*new StringImpl(buffer.release(), length));
1736 }
1737 
1738 Ref&lt;StringImpl&gt; StringImpl::adopt(StringBuffer&lt;UChar&gt;&amp;&amp; buffer)
1739 {
1740     unsigned length = buffer.length();
1741     if (!length)
1742         return *empty();
1743     return adoptRef(*new StringImpl(buffer.release(), length));
1744 }
1745 
1746 size_t StringImpl::sizeInBytes() const
1747 {
1748     // FIXME: support substrings
1749     size_t size = length();
1750     if (!is8Bit())
1751         size *= 2;
1752     return size + sizeof(*this);
1753 }
1754 
1755 // Helper to write a three-byte UTF-8 code point into the buffer; caller must ensure room is available.
1756 static inline void putUTF8Triple(char*&amp; buffer, UChar character)
1757 {
1758     ASSERT(character &gt;= 0x0800);
1759     *buffer++ = static_cast&lt;char&gt;(((character &gt;&gt; 12) &amp; 0x0F) | 0xE0);
1760     *buffer++ = static_cast&lt;char&gt;(((character &gt;&gt; 6) &amp; 0x3F) | 0x80);
1761     *buffer++ = static_cast&lt;char&gt;((character &amp; 0x3F) | 0x80);
1762 }
1763 
1764 UTF8ConversionError StringImpl::utf8Impl(const UChar* characters, unsigned length, char*&amp; buffer, size_t bufferSize, ConversionMode mode)
1765 {
1766     if (mode == StrictConversionReplacingUnpairedSurrogatesWithFFFD) {
1767         const UChar* charactersEnd = characters + length;
1768         char* bufferEnd = buffer + bufferSize;
1769         while (characters &lt; charactersEnd) {
1770             // Use strict conversion to detect unpaired surrogates.
1771             auto result = convertUTF16ToUTF8(&amp;characters, charactersEnd, &amp;buffer, bufferEnd);
1772             ASSERT(result != TargetExhausted);
1773             // Conversion fails when there is an unpaired surrogate.
1774             // Put replacement character (U+FFFD) instead of the unpaired surrogate.
1775             if (result != ConversionOK) {
1776                 ASSERT((0xD800 &lt;= *characters &amp;&amp; *characters &lt;= 0xDFFF));
1777                 // There should be room left, since one UChar hasn&#39;t been converted.
1778                 ASSERT((buffer + 3) &lt;= bufferEnd);
1779                 putUTF8Triple(buffer, replacementCharacter);
1780                 ++characters;
1781             }
1782         }
1783     } else {
1784         bool strict = mode == StrictConversion;
1785         const UChar* originalCharacters = characters;
1786         auto result = convertUTF16ToUTF8(&amp;characters, characters + length, &amp;buffer, buffer + bufferSize, strict);
1787         ASSERT(result != TargetExhausted); // (length * 3) should be sufficient for any conversion
1788 
1789         // Only produced from strict conversion.
1790         if (result == SourceIllegal) {
1791             ASSERT(strict);
1792             return UTF8ConversionError::IllegalSource;
1793         }
1794 
1795         // Check for an unconverted high surrogate.
1796         if (result == SourceExhausted) {
1797             if (strict)
1798                 return UTF8ConversionError::SourceExhausted;
1799             // This should be one unpaired high surrogate. Treat it the same
1800             // was as an unpaired high surrogate would have been handled in
1801             // the middle of a string with non-strict conversion - which is
1802             // to say, simply encode it to UTF-8.
1803             ASSERT_UNUSED(
1804                 originalCharacters, (characters + 1) == (originalCharacters + length));
1805             ASSERT((*characters &gt;= 0xD800) &amp;&amp; (*characters &lt;= 0xDBFF));
1806             // There should be room left, since one UChar hasn&#39;t been converted.
1807             ASSERT((buffer + 3) &lt;= (buffer + bufferSize));
1808             putUTF8Triple(buffer, *characters);
1809         }
1810     }
1811 
1812     return UTF8ConversionError::None;
1813 }
1814 
1815 Expected&lt;CString, UTF8ConversionError&gt; StringImpl::utf8ForCharacters(const LChar* characters, unsigned length)
1816 {
1817     if (!length)
1818         return CString(&quot;&quot;, 0);
1819     if (length &gt; MaxLength / 3)
1820         return makeUnexpected(UTF8ConversionError::OutOfMemory);
1821     Vector&lt;char, 1024&gt; bufferVector(length * 3);
1822     char* buffer = bufferVector.data();
1823     const LChar* source = characters;
1824     bool success = convertLatin1ToUTF8(&amp;source, source + length, &amp;buffer, buffer + bufferVector.size());
1825     ASSERT_UNUSED(success, success); // (length * 3) should be sufficient for any conversion
1826     return CString(bufferVector.data(), buffer - bufferVector.data());
1827 }
1828 
1829 Expected&lt;CString, UTF8ConversionError&gt; StringImpl::utf8ForCharacters(const UChar* characters, unsigned length, ConversionMode mode)
1830 {
1831     if (!length)
1832         return CString(&quot;&quot;, 0);
1833     if (length &gt; MaxLength / 3)
1834         return makeUnexpected(UTF8ConversionError::OutOfMemory);
1835     Vector&lt;char, 1024&gt; bufferVector(length * 3);
1836     char* buffer = bufferVector.data();
1837     UTF8ConversionError error = utf8Impl(characters, length, buffer, bufferVector.size(), mode);
1838     if (error != UTF8ConversionError::None)
1839         return makeUnexpected(error);
1840     return CString(bufferVector.data(), buffer - bufferVector.data());
1841 }
1842 
1843 Expected&lt;CString, UTF8ConversionError&gt; StringImpl::tryGetUtf8ForRange(unsigned offset, unsigned length, ConversionMode mode) const
1844 {
1845     ASSERT(offset &lt;= this-&gt;length());
1846     ASSERT(offset + length &lt;= this-&gt;length());
1847 
1848     if (!length)
1849         return CString(&quot;&quot;, 0);
1850 
1851     // Allocate a buffer big enough to hold all the characters
1852     // (an individual UTF-16 UChar can only expand to 3 UTF-8 bytes).
1853     // Optimization ideas, if we find this function is hot:
1854     //  * We could speculatively create a CStringBuffer to contain &#39;length&#39;
1855     //    characters, and resize if necessary (i.e. if the buffer contains
1856     //    non-ascii characters). (Alternatively, scan the buffer first for
1857     //    ascii characters, so we know this will be sufficient).
1858     //  * We could allocate a CStringBuffer with an appropriate size to
1859     //    have a good chance of being able to write the string into the
1860     //    buffer without reallocing (say, 1.5 x length).
1861     if (length &gt; MaxLength / 3)
1862         return makeUnexpected(UTF8ConversionError::OutOfMemory);
1863     Vector&lt;char, 1024&gt; bufferVector(length * 3);
1864 
1865     char* buffer = bufferVector.data();
1866 
1867     if (is8Bit()) {
1868         const LChar* characters = this-&gt;characters8() + offset;
1869         auto success = convertLatin1ToUTF8(&amp;characters, characters + length, &amp;buffer, buffer + bufferVector.size());
1870         ASSERT_UNUSED(success, success); // (length * 3) should be sufficient for any conversion
1871     } else {
1872         UTF8ConversionError error = utf8Impl(this-&gt;characters16() + offset, length, buffer, bufferVector.size(), mode);
1873         if (error != UTF8ConversionError::None)
1874             return makeUnexpected(error);
1875     }
1876 
1877     return CString(bufferVector.data(), buffer - bufferVector.data());
1878 }
1879 
1880 Expected&lt;CString, UTF8ConversionError&gt; StringImpl::tryGetUtf8(ConversionMode mode) const
1881 {
1882     return tryGetUtf8ForRange(0, length(), mode);
1883 }
1884 
1885 CString StringImpl::utf8(ConversionMode mode) const
1886 {
1887     auto expectedString = tryGetUtf8ForRange(0, length(), mode);
1888     RELEASE_ASSERT(expectedString);
1889     return expectedString.value();
1890 }
1891 
1892 NEVER_INLINE unsigned StringImpl::hashSlowCase() const
1893 {
1894     if (is8Bit())
1895         setHash(StringHasher::computeHashAndMaskTop8Bits(m_data8, m_length));
1896     else
1897         setHash(StringHasher::computeHashAndMaskTop8Bits(m_data16, m_length));
1898     return existingHash();
1899 }
1900 
1901 unsigned StringImpl::concurrentHash() const
1902 {
1903     unsigned hash;
1904     if (is8Bit())
1905         hash = StringHasher::computeHashAndMaskTop8Bits(m_data8, m_length);
1906     else
1907         hash = StringHasher::computeHashAndMaskTop8Bits(m_data16, m_length);
1908     ASSERT(((hash &lt;&lt; s_flagCount) &gt;&gt; s_flagCount) == hash);
1909     return hash;
1910 }
1911 
1912 bool equalIgnoringNullity(const UChar* a, size_t aLength, StringImpl* b)
1913 {
1914     if (!b)
1915         return !aLength;
1916     if (aLength != b-&gt;length())
1917         return false;
1918     if (b-&gt;is8Bit()) {
1919         const LChar* bCharacters = b-&gt;characters8();
1920         for (unsigned i = 0; i &lt; aLength; ++i) {
1921             if (a[i] != bCharacters[i])
1922                 return false;
1923         }
1924         return true;
1925     }
1926     return !memcmp(a, b-&gt;characters16(), b-&gt;length() * sizeof(UChar));
1927 }
1928 
1929 } // namespace WTF
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
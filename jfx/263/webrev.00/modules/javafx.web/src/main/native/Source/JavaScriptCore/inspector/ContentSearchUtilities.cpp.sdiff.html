<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/ContentSearchUtilities.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ConsoleMessage.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ContentSearchUtilities.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/ContentSearchUtilities.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;ContentSearchUtilities.h&quot;
 31 
 32 #include &quot;RegularExpression.h&quot;
 33 #include &quot;Yarr.h&quot;
 34 #include &quot;YarrFlags.h&quot;
 35 #include &quot;YarrInterpreter.h&quot;
 36 #include &lt;wtf/BumpPointerAllocator.h&gt;
 37 #include &lt;wtf/StdLibExtras.h&gt;
 38 #include &lt;wtf/text/StringBuilder.h&gt;
 39 #include &lt;wtf/text/TextPosition.h&gt;
 40 
 41 using namespace JSC::Yarr;
 42 
 43 namespace Inspector {
 44 namespace ContentSearchUtilities {
 45 
 46 static const char regexSpecialCharacters[] = &quot;[](){}+-*.,?\\^$|&quot;;
 47 
<span class="line-modified"> 48 static String createSearchRegexSource(const String&amp; text)</span>
 49 {
 50     StringBuilder result;
 51 
 52     for (unsigned i = 0; i &lt; text.length(); i++) {
 53         UChar character = text[i];
 54         if (isASCII(character) &amp;&amp; strchr(regexSpecialCharacters, character))
 55             result.append(&#39;\\&#39;);
 56         result.append(character);
 57     }
 58 
 59     return result.toString();
 60 }
 61 
 62 static inline size_t sizetExtractor(const size_t* value)
 63 {
 64     return *value;
 65 }
 66 
 67 TextPosition textPositionFromOffset(size_t offset, const Vector&lt;size_t&gt;&amp; lineEndings)
 68 {
</pre>
<hr />
<pre>
112         }
113 
114         nextStart += 1;
115         result.append(nextStart);
116         start = nextStart;
117     }
118 
119     result.append(text.length());
120 
121     return result;
122 }
123 
124 static Ref&lt;Protocol::GenericTypes::SearchMatch&gt; buildObjectForSearchMatch(size_t lineNumber, const String&amp; lineContent)
125 {
126     return Protocol::GenericTypes::SearchMatch::create()
127         .setLineNumber(lineNumber)
128         .setLineContent(lineContent)
129         .release();
130 }
131 
<span class="line-modified">132 RegularExpression createSearchRegex(const String&amp; query, bool caseSensitive, bool isRegex)</span>
133 {
<span class="line-modified">134     return RegularExpression { isRegex ? query : createSearchRegexSource(query), caseSensitive ? TextCaseSensitive : TextCaseInsensitive };</span>












135 }
136 
137 int countRegularExpressionMatches(const RegularExpression&amp; regex, const String&amp; content)
138 {
139     if (content.isEmpty())
140         return 0;
141 
142     int result = 0;
143     int position;
144     unsigned start = 0;
145     int matchLength;
146     while ((position = regex.match(content, start, &amp;matchLength)) != -1) {
147         if (start &gt;= content.length())
148             break;
149         if (matchLength &gt; 0)
150             ++result;
151         start = position + 1;
152     }
153     return result;
154 }
155 
156 Ref&lt;JSON::ArrayOf&lt;Protocol::GenericTypes::SearchMatch&gt;&gt; searchInTextByLines(const String&amp; text, const String&amp; query, const bool caseSensitive, const bool isRegex)
157 {
158     auto result = JSON::ArrayOf&lt;Protocol::GenericTypes::SearchMatch&gt;::create();
<span class="line-modified">159     auto regex = ContentSearchUtilities::createSearchRegex(query, caseSensitive, isRegex);</span>

160     for (const auto&amp; match : getRegularExpressionMatchesByLines(regex, text))
161         result-&gt;addItem(buildObjectForSearchMatch(match.first, match.second));
162     return result;
163 }
164 
165 static String findMagicComment(const String&amp; content, const String&amp; patternString)
166 {
167     if (content.isEmpty())
168         return String();
169 
170     JSC::Yarr::ErrorCode error { JSC::Yarr::ErrorCode::NoError };
171     YarrPattern pattern(patternString, JSC::Yarr::Flags::Multiline, error);
172     ASSERT(!hasError(error));
173     BumpPointerAllocator regexAllocator;
174     JSC::Yarr::ErrorCode ignoredErrorCode = JSC::Yarr::ErrorCode::NoError;
175     auto bytecodePattern = byteCompile(pattern, &amp;regexAllocator, ignoredErrorCode);
176     RELEASE_ASSERT(bytecodePattern);
177 
178     ASSERT(pattern.m_numSubpatterns == 1);
179     std::array&lt;unsigned, 4&gt; matches;
</pre>
</td>
<td>
<hr />
<pre>
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;ContentSearchUtilities.h&quot;
 31 
 32 #include &quot;RegularExpression.h&quot;
 33 #include &quot;Yarr.h&quot;
 34 #include &quot;YarrFlags.h&quot;
 35 #include &quot;YarrInterpreter.h&quot;
 36 #include &lt;wtf/BumpPointerAllocator.h&gt;
 37 #include &lt;wtf/StdLibExtras.h&gt;
 38 #include &lt;wtf/text/StringBuilder.h&gt;
 39 #include &lt;wtf/text/TextPosition.h&gt;
 40 
 41 using namespace JSC::Yarr;
 42 
 43 namespace Inspector {
 44 namespace ContentSearchUtilities {
 45 
 46 static const char regexSpecialCharacters[] = &quot;[](){}+-*.,?\\^$|&quot;;
 47 
<span class="line-modified"> 48 static String escapeStringForRegularExpressionSource(const String&amp; text)</span>
 49 {
 50     StringBuilder result;
 51 
 52     for (unsigned i = 0; i &lt; text.length(); i++) {
 53         UChar character = text[i];
 54         if (isASCII(character) &amp;&amp; strchr(regexSpecialCharacters, character))
 55             result.append(&#39;\\&#39;);
 56         result.append(character);
 57     }
 58 
 59     return result.toString();
 60 }
 61 
 62 static inline size_t sizetExtractor(const size_t* value)
 63 {
 64     return *value;
 65 }
 66 
 67 TextPosition textPositionFromOffset(size_t offset, const Vector&lt;size_t&gt;&amp; lineEndings)
 68 {
</pre>
<hr />
<pre>
112         }
113 
114         nextStart += 1;
115         result.append(nextStart);
116         start = nextStart;
117     }
118 
119     result.append(text.length());
120 
121     return result;
122 }
123 
124 static Ref&lt;Protocol::GenericTypes::SearchMatch&gt; buildObjectForSearchMatch(size_t lineNumber, const String&amp; lineContent)
125 {
126     return Protocol::GenericTypes::SearchMatch::create()
127         .setLineNumber(lineNumber)
128         .setLineContent(lineContent)
129         .release();
130 }
131 
<span class="line-modified">132 RegularExpression createRegularExpressionForSearchString(const String&amp; searchString, bool caseSensitive, SearchStringType type)</span>
133 {
<span class="line-modified">134     String pattern;</span>
<span class="line-added">135     switch (type) {</span>
<span class="line-added">136     case SearchStringType::Regex:</span>
<span class="line-added">137         pattern = searchString;</span>
<span class="line-added">138         break;</span>
<span class="line-added">139     case SearchStringType::ExactString:</span>
<span class="line-added">140         pattern = makeString(&#39;^&#39;, escapeStringForRegularExpressionSource(searchString), &#39;$&#39;);</span>
<span class="line-added">141         break;</span>
<span class="line-added">142     case SearchStringType::ContainsString:</span>
<span class="line-added">143         pattern = escapeStringForRegularExpressionSource(searchString);</span>
<span class="line-added">144         break;</span>
<span class="line-added">145     }</span>
<span class="line-added">146     return RegularExpression(pattern, caseSensitive ? TextCaseSensitive : TextCaseInsensitive);</span>
147 }
148 
149 int countRegularExpressionMatches(const RegularExpression&amp; regex, const String&amp; content)
150 {
151     if (content.isEmpty())
152         return 0;
153 
154     int result = 0;
155     int position;
156     unsigned start = 0;
157     int matchLength;
158     while ((position = regex.match(content, start, &amp;matchLength)) != -1) {
159         if (start &gt;= content.length())
160             break;
161         if (matchLength &gt; 0)
162             ++result;
163         start = position + 1;
164     }
165     return result;
166 }
167 
168 Ref&lt;JSON::ArrayOf&lt;Protocol::GenericTypes::SearchMatch&gt;&gt; searchInTextByLines(const String&amp; text, const String&amp; query, const bool caseSensitive, const bool isRegex)
169 {
170     auto result = JSON::ArrayOf&lt;Protocol::GenericTypes::SearchMatch&gt;::create();
<span class="line-modified">171     auto searchStringType = isRegex ? ContentSearchUtilities::SearchStringType::Regex : ContentSearchUtilities::SearchStringType::ContainsString;</span>
<span class="line-added">172     auto regex = ContentSearchUtilities::createRegularExpressionForSearchString(query, caseSensitive, searchStringType);</span>
173     for (const auto&amp; match : getRegularExpressionMatchesByLines(regex, text))
174         result-&gt;addItem(buildObjectForSearchMatch(match.first, match.second));
175     return result;
176 }
177 
178 static String findMagicComment(const String&amp; content, const String&amp; patternString)
179 {
180     if (content.isEmpty())
181         return String();
182 
183     JSC::Yarr::ErrorCode error { JSC::Yarr::ErrorCode::NoError };
184     YarrPattern pattern(patternString, JSC::Yarr::Flags::Multiline, error);
185     ASSERT(!hasError(error));
186     BumpPointerAllocator regexAllocator;
187     JSC::Yarr::ErrorCode ignoredErrorCode = JSC::Yarr::ErrorCode::NoError;
188     auto bytecodePattern = byteCompile(pattern, &amp;regexAllocator, ignoredErrorCode);
189     RELEASE_ASSERT(bytecodePattern);
190 
191     ASSERT(pattern.m_numSubpatterns == 1);
192     std::array&lt;unsigned, 4&gt; matches;
</pre>
</td>
</tr>
</table>
<center><a href="ConsoleMessage.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ContentSearchUtilities.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
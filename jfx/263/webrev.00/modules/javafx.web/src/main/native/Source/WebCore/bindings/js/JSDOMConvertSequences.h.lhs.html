<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertSequences.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;IDLTypes.h&quot;
 29 #include &quot;JSDOMConvertBase.h&quot;
 30 #include &quot;JSDOMConvertNumbers.h&quot;
 31 #include &quot;JSDOMGlobalObject.h&quot;
 32 #include &lt;JavaScriptCore/IteratorOperations.h&gt;
 33 #include &lt;JavaScriptCore/JSArray.h&gt;
 34 #include &lt;JavaScriptCore/JSGlobalObjectInlines.h&gt;
 35 #include &lt;JavaScriptCore/ObjectConstructor.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 namespace Detail {
 40 
 41 template&lt;typename IDLType&gt;
 42 struct GenericSequenceConverter {
 43     using ReturnType = Vector&lt;typename IDLType::ImplementationType&gt;;
 44 
<a name="1" id="anc1"></a><span class="line-modified"> 45     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object)</span>
 46     {
<a name="2" id="anc2"></a><span class="line-modified"> 47         return convert(state, object, ReturnType());</span>
 48     }
 49 
<a name="3" id="anc3"></a><span class="line-modified"> 50     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, ReturnType&amp;&amp; result)</span>
 51     {
<a name="4" id="anc4"></a><span class="line-modified"> 52         forEachInIterable(&amp;state, object, [&amp;result](JSC::VM&amp; vm, JSC::ExecState* state, JSC::JSValue nextValue) {</span>
 53             auto scope = DECLARE_THROW_SCOPE(vm);
 54 
<a name="5" id="anc5"></a><span class="line-modified"> 55             auto convertedValue = Converter&lt;IDLType&gt;::convert(*state, nextValue);</span>
 56             if (UNLIKELY(scope.exception()))
 57                 return;
 58             result.append(WTFMove(convertedValue));
 59         });
 60         return WTFMove(result);
 61     }
 62 
<a name="6" id="anc6"></a><span class="line-modified"> 63     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
 64     {
<a name="7" id="anc7"></a><span class="line-modified"> 65         return convert(state, object, method, ReturnType());</span>
 66     }
 67 
<a name="8" id="anc8"></a><span class="line-modified"> 68     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method, ReturnType&amp;&amp; result)</span>
 69     {
<a name="9" id="anc9"></a><span class="line-modified"> 70         forEachInIterable(state, object, method, [&amp;result](JSC::VM&amp; vm, JSC::ExecState&amp; state, JSC::JSValue nextValue) {</span>
 71             auto scope = DECLARE_THROW_SCOPE(vm);
 72 
<a name="10" id="anc10"></a><span class="line-modified"> 73             auto convertedValue = Converter&lt;IDLType&gt;::convert(state, nextValue);</span>
 74             if (UNLIKELY(scope.exception()))
 75                 return;
 76             result.append(WTFMove(convertedValue));
 77         });
 78         return WTFMove(result);
 79     }
 80 };
 81 
 82 // Specialization for numeric types
 83 // FIXME: This is only implemented for the IDLFloatingPointTypes and IDLLong. To add
 84 // support for more numeric types, add an overload of Converter&lt;IDLType&gt;::convert that
 85 // takes an ExecState, ThrowScope, double as its arguments.
 86 template&lt;typename IDLType&gt;
 87 struct NumericSequenceConverter {
 88     using GenericConverter = GenericSequenceConverter&lt;IDLType&gt;;
 89     using ReturnType = typename GenericConverter::ReturnType;
 90 
<a name="11" id="anc11"></a><span class="line-modified"> 91     static ReturnType convertArray(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, JSC::JSArray* array, unsigned length, JSC::IndexingType indexingType, ReturnType&amp;&amp; result)</span>
 92     {
 93         if (indexingType == JSC::Int32Shape) {
 94             for (unsigned i = 0; i &lt; length; i++) {
 95                 auto indexValue = array-&gt;butterfly()-&gt;contiguousInt32().at(array, i).get();
 96                 ASSERT(!indexValue || indexValue.isInt32());
 97                 if (!indexValue)
 98                     result.uncheckedAppend(0);
 99                 else
100                     result.uncheckedAppend(indexValue.asInt32());
101             }
102             return WTFMove(result);
103         }
104 
105         ASSERT(indexingType == JSC::DoubleShape);
106         for (unsigned i = 0; i &lt; length; i++) {
107             double doubleValue = array-&gt;butterfly()-&gt;contiguousDouble().at(array, i);
108             if (std::isnan(doubleValue))
109                 result.uncheckedAppend(0);
110             else {
<a name="12" id="anc12"></a><span class="line-modified">111                 auto convertedValue = Converter&lt;IDLType&gt;::convert(state, scope, doubleValue);</span>
112                 RETURN_IF_EXCEPTION(scope, { });
113 
114                 result.uncheckedAppend(convertedValue);
115             }
116         }
117         return WTFMove(result);
118     }
119 
<a name="13" id="anc13"></a><span class="line-modified">120     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
121     {
<a name="14" id="anc14"></a><span class="line-modified">122         auto&amp; vm = state.vm();</span>
123         auto scope = DECLARE_THROW_SCOPE(vm);
124 
125         if (!value.isObject()) {
<a name="15" id="anc15"></a><span class="line-modified">126             throwSequenceTypeError(state, scope);</span>
127             return { };
128         }
129 
130         JSC::JSObject* object = JSC::asObject(value);
131         if (!JSC::isJSArray(object))
<a name="16" id="anc16"></a><span class="line-modified">132             return GenericConverter::convert(state, object);</span>
133 
134         JSC::JSArray* array = JSC::asArray(object);
135         if (!array-&gt;isIteratorProtocolFastAndNonObservable())
<a name="17" id="anc17"></a><span class="line-modified">136             return GenericConverter::convert(state, object);</span>
137 
138         unsigned length = array-&gt;length();
139         ReturnType result;
140         // If we&#39;re not an int32/double array, it&#39;s possible that converting a
141         // JSValue to a number could cause the iterator protocol to change, hence,
142         // we may need more capacity, or less. In such cases, we use the length
143         // as a proxy for the capacity we will most likely need (it&#39;s unlikely that
144         // a program is written with a valueOf that will augment the iterator protocol).
145         // If we are an int32/double array, then length is precisely the capacity we need.
146         if (!result.tryReserveCapacity(length)) {
147             // FIXME: Is the right exception to throw?
<a name="18" id="anc18"></a><span class="line-modified">148             throwTypeError(&amp;state, scope);</span>
149             return { };
150         }
151 
152         JSC::IndexingType indexingType = array-&gt;indexingType() &amp; JSC::IndexingShapeMask;
153         if (indexingType != JSC::Int32Shape &amp;&amp; indexingType != JSC::DoubleShape)
<a name="19" id="anc19"></a><span class="line-modified">154             return GenericConverter::convert(state, object, WTFMove(result));</span>
155 
<a name="20" id="anc20"></a><span class="line-modified">156         return convertArray(state, scope, array, length, indexingType, WTFMove(result));</span>
157     }
158 
<a name="21" id="anc21"></a><span class="line-modified">159     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
160     {
<a name="22" id="anc22"></a><span class="line-modified">161         auto&amp; vm = state.vm();</span>
162         auto scope = DECLARE_THROW_SCOPE(vm);
163 
164         if (!JSC::isJSArray(object))
<a name="23" id="anc23"></a><span class="line-modified">165             return GenericConverter::convert(state, object, method);</span>
166 
167         JSC::JSArray* array = JSC::asArray(object);
168         if (!array-&gt;isIteratorProtocolFastAndNonObservable())
<a name="24" id="anc24"></a><span class="line-modified">169             return GenericConverter::convert(state, object, method);</span>
170 
171         unsigned length = array-&gt;length();
172         ReturnType result;
173         // If we&#39;re not an int32/double array, it&#39;s possible that converting a
174         // JSValue to a number could cause the iterator protocol to change, hence,
175         // we may need more capacity, or less. In such cases, we use the length
176         // as a proxy for the capacity we will most likely need (it&#39;s unlikely that
177         // a program is written with a valueOf that will augment the iterator protocol).
178         // If we are an int32/double array, then length is precisely the capacity we need.
179         if (!result.tryReserveCapacity(length)) {
180             // FIXME: Is the right exception to throw?
<a name="25" id="anc25"></a><span class="line-modified">181             throwTypeError(&amp;state, scope);</span>
182             return { };
183         }
184 
185         JSC::IndexingType indexingType = array-&gt;indexingType() &amp; JSC::IndexingShapeMask;
186         if (indexingType != JSC::Int32Shape &amp;&amp; indexingType != JSC::DoubleShape)
<a name="26" id="anc26"></a><span class="line-modified">187             return GenericConverter::convert(state, object, method, WTFMove(result));</span>
188 
<a name="27" id="anc27"></a><span class="line-modified">189         return convertArray(state, scope, array, length, indexingType, WTFMove(result));</span>
190     }
191 };
192 
193 template&lt;typename IDLType&gt;
194 struct SequenceConverter {
195     using GenericConverter = GenericSequenceConverter&lt;IDLType&gt;;
196     using ReturnType = typename GenericConverter::ReturnType;
197 
<a name="28" id="anc28"></a><span class="line-modified">198     static ReturnType convertArray(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, JSC::JSArray* array)</span>
199     {
200         unsigned length = array-&gt;length();
201 
202         ReturnType result;
203         if (!result.tryReserveCapacity(length)) {
204             // FIXME: Is the right exception to throw?
<a name="29" id="anc29"></a><span class="line-modified">205             throwTypeError(&amp;state, scope);</span>
206             return { };
207         }
208 
209         JSC::IndexingType indexingType = array-&gt;indexingType() &amp; JSC::IndexingShapeMask;
210 
211         if (indexingType == JSC::ContiguousShape) {
212             for (unsigned i = 0; i &lt; length; i++) {
213                 auto indexValue = array-&gt;butterfly()-&gt;contiguous().at(array, i).get();
214                 if (!indexValue)
215                     indexValue = JSC::jsUndefined();
216 
<a name="30" id="anc30"></a><span class="line-modified">217                 auto convertedValue = Converter&lt;IDLType&gt;::convert(state, indexValue);</span>
218                 RETURN_IF_EXCEPTION(scope, { });
219 
220                 result.uncheckedAppend(convertedValue);
221             }
222             return result;
223         }
224 
225         for (unsigned i = 0; i &lt; length; i++) {
<a name="31" id="anc31"></a><span class="line-modified">226             auto indexValue = array-&gt;getDirectIndex(&amp;state, i);</span>
227             RETURN_IF_EXCEPTION(scope, { });
228 
229             if (!indexValue)
230                 indexValue = JSC::jsUndefined();
231 
<a name="32" id="anc32"></a><span class="line-modified">232             auto convertedValue = Converter&lt;IDLType&gt;::convert(state, indexValue);</span>
233             RETURN_IF_EXCEPTION(scope, { });
234 
235             result.uncheckedAppend(convertedValue);
236         }
237         return result;
238     }
239 
<a name="33" id="anc33"></a><span class="line-modified">240     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
241     {
<a name="34" id="anc34"></a><span class="line-modified">242         auto&amp; vm = state.vm();</span>
243         auto scope = DECLARE_THROW_SCOPE(vm);
244 
245         if (!value.isObject()) {
<a name="35" id="anc35"></a><span class="line-modified">246             throwSequenceTypeError(state, scope);</span>
247             return { };
248         }
249 
250         JSC::JSObject* object = JSC::asObject(value);
251         if (Converter&lt;IDLType&gt;::conversionHasSideEffects)
<a name="36" id="anc36"></a><span class="line-modified">252             return GenericConverter::convert(state, object);</span>
253 
254         if (!JSC::isJSArray(object))
<a name="37" id="anc37"></a><span class="line-modified">255             return GenericConverter::convert(state, object);</span>
256 
257         JSC::JSArray* array = JSC::asArray(object);
258         if (!array-&gt;isIteratorProtocolFastAndNonObservable())
<a name="38" id="anc38"></a><span class="line-modified">259             return GenericConverter::convert(state, object);</span>
260 
<a name="39" id="anc39"></a><span class="line-modified">261         return convertArray(state, scope, array);</span>
262     }
263 
<a name="40" id="anc40"></a><span class="line-modified">264     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
265     {
<a name="41" id="anc41"></a><span class="line-modified">266         auto&amp; vm = state.vm();</span>
267         auto scope = DECLARE_THROW_SCOPE(vm);
268 
269         if (Converter&lt;IDLType&gt;::conversionHasSideEffects)
<a name="42" id="anc42"></a><span class="line-modified">270             return GenericConverter::convert(state, object, method);</span>
271 
272         if (!JSC::isJSArray(object))
<a name="43" id="anc43"></a><span class="line-modified">273             return GenericConverter::convert(state, object, method);</span>
274 
275         JSC::JSArray* array = JSC::asArray(object);
276         if (!array-&gt;isIteratorProtocolFastAndNonObservable())
<a name="44" id="anc44"></a><span class="line-modified">277             return GenericConverter::convert(state, object, method);</span>
278 
<a name="45" id="anc45"></a><span class="line-modified">279         return convertArray(state, scope, array);</span>
280     }
281 };
282 
283 template&lt;&gt;
284 struct SequenceConverter&lt;IDLLong&gt; {
285     using ReturnType = typename GenericSequenceConverter&lt;IDLLong&gt;::ReturnType;
286 
<a name="46" id="anc46"></a><span class="line-modified">287     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
288     {
<a name="47" id="anc47"></a><span class="line-modified">289         return NumericSequenceConverter&lt;IDLLong&gt;::convert(state, value);</span>
290     }
291 
<a name="48" id="anc48"></a><span class="line-modified">292     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
293     {
<a name="49" id="anc49"></a><span class="line-modified">294         return NumericSequenceConverter&lt;IDLLong&gt;::convert(state, object, method);</span>
295     }
296 };
297 
298 template&lt;&gt;
299 struct SequenceConverter&lt;IDLFloat&gt; {
300     using ReturnType = typename GenericSequenceConverter&lt;IDLFloat&gt;::ReturnType;
301 
<a name="50" id="anc50"></a><span class="line-modified">302     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
303     {
<a name="51" id="anc51"></a><span class="line-modified">304         return NumericSequenceConverter&lt;IDLFloat&gt;::convert(state, value);</span>
305     }
306 
<a name="52" id="anc52"></a><span class="line-modified">307     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
308     {
<a name="53" id="anc53"></a><span class="line-modified">309         return NumericSequenceConverter&lt;IDLFloat&gt;::convert(state, object, method);</span>
310     }
311 };
312 
313 template&lt;&gt;
314 struct SequenceConverter&lt;IDLUnrestrictedFloat&gt; {
315     using ReturnType = typename GenericSequenceConverter&lt;IDLUnrestrictedFloat&gt;::ReturnType;
316 
<a name="54" id="anc54"></a><span class="line-modified">317     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
318     {
<a name="55" id="anc55"></a><span class="line-modified">319         return NumericSequenceConverter&lt;IDLUnrestrictedFloat&gt;::convert(state, value);</span>
320     }
321 
<a name="56" id="anc56"></a><span class="line-modified">322     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
323     {
<a name="57" id="anc57"></a><span class="line-modified">324         return NumericSequenceConverter&lt;IDLUnrestrictedFloat&gt;::convert(state, object, method);</span>
325     }
326 };
327 
328 template&lt;&gt;
329 struct SequenceConverter&lt;IDLDouble&gt; {
330     using ReturnType = typename GenericSequenceConverter&lt;IDLDouble&gt;::ReturnType;
331 
<a name="58" id="anc58"></a><span class="line-modified">332     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
333     {
<a name="59" id="anc59"></a><span class="line-modified">334         return NumericSequenceConverter&lt;IDLDouble&gt;::convert(state, value);</span>
335     }
336 
<a name="60" id="anc60"></a><span class="line-modified">337     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
338     {
<a name="61" id="anc61"></a><span class="line-modified">339         return NumericSequenceConverter&lt;IDLDouble&gt;::convert(state, object, method);</span>
340     }
341 };
342 
343 template&lt;&gt;
344 struct SequenceConverter&lt;IDLUnrestrictedDouble&gt; {
345     using ReturnType = typename GenericSequenceConverter&lt;IDLUnrestrictedDouble&gt;::ReturnType;
346 
<a name="62" id="anc62"></a><span class="line-modified">347     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
348     {
<a name="63" id="anc63"></a><span class="line-modified">349         return NumericSequenceConverter&lt;IDLUnrestrictedDouble&gt;::convert(state, value);</span>
350     }
351 
<a name="64" id="anc64"></a><span class="line-modified">352     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
353     {
<a name="65" id="anc65"></a><span class="line-modified">354         return NumericSequenceConverter&lt;IDLUnrestrictedDouble&gt;::convert(state, object, method);</span>
355     }
356 };
357 
358 }
359 
360 template&lt;typename T&gt; struct Converter&lt;IDLSequence&lt;T&gt;&gt; : DefaultConverter&lt;IDLSequence&lt;T&gt;&gt; {
361     using ReturnType = typename Detail::SequenceConverter&lt;T&gt;::ReturnType;
362 
<a name="66" id="anc66"></a><span class="line-modified">363     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
364     {
<a name="67" id="anc67"></a><span class="line-modified">365         return Detail::SequenceConverter&lt;T&gt;::convert(state, value);</span>
366     }
367 
<a name="68" id="anc68"></a><span class="line-modified">368     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
369     {
<a name="69" id="anc69"></a><span class="line-modified">370         return Detail::SequenceConverter&lt;T&gt;::convert(state, object, method);</span>
371     }
372 };
373 
374 template&lt;typename T&gt; struct JSConverter&lt;IDLSequence&lt;T&gt;&gt; {
375     static constexpr bool needsState = true;
376     static constexpr bool needsGlobalObject = true;
377 
378     template&lt;typename U, size_t inlineCapacity&gt;
<a name="70" id="anc70"></a><span class="line-modified">379     static JSC::JSValue convert(JSC::ExecState&amp; exec, JSDOMGlobalObject&amp; globalObject, const Vector&lt;U, inlineCapacity&gt;&amp; vector)</span>
380     {
<a name="71" id="anc71"></a><span class="line-modified">381         JSC::VM&amp; vm = exec.vm();</span>
382         auto scope = DECLARE_THROW_SCOPE(vm);
383         JSC::MarkedArgumentBuffer list;
384         for (auto&amp; element : vector)
<a name="72" id="anc72"></a><span class="line-modified">385             list.append(toJS&lt;T&gt;(exec, globalObject, element));</span>
386         if (UNLIKELY(list.hasOverflowed())) {
<a name="73" id="anc73"></a><span class="line-modified">387             throwOutOfMemoryError(&amp;exec, scope);</span>
388             return { };
389         }
<a name="74" id="anc74"></a><span class="line-modified">390         return JSC::constructArray(&amp;exec, nullptr, &amp;globalObject, list);</span>
391     }
392 };
393 
394 template&lt;typename T&gt; struct Converter&lt;IDLFrozenArray&lt;T&gt;&gt; : DefaultConverter&lt;IDLFrozenArray&lt;T&gt;&gt; {
395     using ReturnType = typename Detail::SequenceConverter&lt;T&gt;::ReturnType;
396 
<a name="75" id="anc75"></a><span class="line-modified">397     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
398     {
<a name="76" id="anc76"></a><span class="line-modified">399         return Detail::SequenceConverter&lt;T&gt;::convert(state, value);</span>
400     }
401 
<a name="77" id="anc77"></a><span class="line-modified">402     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
403     {
<a name="78" id="anc78"></a><span class="line-modified">404         return Detail::SequenceConverter&lt;T&gt;::convert(state, object, method);</span>
405     }
406 };
407 
408 template&lt;typename T&gt; struct JSConverter&lt;IDLFrozenArray&lt;T&gt;&gt; {
409     static constexpr bool needsState = true;
410     static constexpr bool needsGlobalObject = true;
411 
412     template&lt;typename U, size_t inlineCapacity&gt;
<a name="79" id="anc79"></a><span class="line-modified">413     static JSC::JSValue convert(JSC::ExecState&amp; exec, JSDOMGlobalObject&amp; globalObject, const Vector&lt;U, inlineCapacity&gt;&amp; vector)</span>
414     {
<a name="80" id="anc80"></a><span class="line-modified">415         JSC::VM&amp; vm = exec.vm();</span>
416         auto scope = DECLARE_THROW_SCOPE(vm);
417         JSC::MarkedArgumentBuffer list;
418         for (auto&amp; element : vector)
<a name="81" id="anc81"></a><span class="line-modified">419             list.append(toJS&lt;T&gt;(exec, globalObject, element));</span>
420         if (UNLIKELY(list.hasOverflowed())) {
<a name="82" id="anc82"></a><span class="line-modified">421             throwOutOfMemoryError(&amp;exec, scope);</span>
422             return { };
423         }
<a name="83" id="anc83"></a><span class="line-modified">424         auto* array = JSC::constructArray(&amp;exec, nullptr, &amp;globalObject, list);</span>
<span class="line-modified">425         return JSC::objectConstructorFreeze(&amp;exec, array);</span>
426     }
427 };
428 
429 } // namespace WebCore
430 
<a name="84" id="anc84"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="84" type="hidden" />
</body>
</html>
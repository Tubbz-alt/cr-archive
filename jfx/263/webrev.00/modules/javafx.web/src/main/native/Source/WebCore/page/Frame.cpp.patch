diff a/modules/javafx.web/src/main/native/Source/WebCore/page/Frame.cpp b/modules/javafx.web/src/main/native/Source/WebCore/page/Frame.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/page/Frame.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/page/Frame.cpp
@@ -29,10 +29,11 @@
 
 #include "config.h"
 #include "Frame.h"
 
 #include "ApplyStyleCommand.h"
+#include "BackForwardCache.h"
 #include "BackForwardController.h"
 #include "CSSAnimationController.h"
 #include "CSSComputedStyleDeclaration.h"
 #include "CSSPropertyNames.h"
 #include "CachedCSSStyleSheet.h"
@@ -71,11 +72,10 @@
 #include "NavigationScheduler.h"
 #include "Navigator.h"
 #include "NodeList.h"
 #include "NodeTraversal.h"
 #include "Page.h"
-#include "PageCache.h"
 #include "ProcessWarming.h"
 #include "RenderLayerCompositor.h"
 #include "RenderTableCell.h"
 #include "RenderText.h"
 #include "RenderTextControl.h"
@@ -228,11 +228,11 @@
         m_view->prepareForDetach();
 
     // Prepare for destruction now, so any unload event handlers get run and the DOMWindow is
     // notified. If we wait until the view is destroyed, then things won't be hooked up enough for
     // these calls to work.
-    if (!view && m_doc && m_doc->pageCacheState() != Document::InPageCache)
+    if (!view && m_doc && m_doc->backForwardCacheState() != Document::InBackForwardCache)
         m_doc->prepareForDestruction();
 
     if (m_view)
         m_view->layoutContext().unscheduleLayout();
 
@@ -273,11 +273,11 @@
         for (auto& attachment : m_doc->attachmentElementsByIdentifier().values())
             editor().didRemoveAttachmentElement(attachment);
     }
 #endif
 
-    if (m_doc && m_doc->pageCacheState() != Document::InPageCache)
+    if (m_doc && m_doc->backForwardCacheState() != Document::InBackForwardCache)
         m_doc->prepareForDestruction();
 
     m_doc = newDocument.copyRef();
     ASSERT(!m_doc || m_doc->domWindow());
     ASSERT(!m_doc || m_doc->domWindow()->frame() == this);
@@ -555,14 +555,19 @@
     // In setting printing, we should not validate resources already cached for the document.
     // See https://bugs.webkit.org/show_bug.cgi?id=43704
     ResourceCacheValidationSuppressor validationSuppressor(m_doc->cachedResourceLoader());
 
     m_doc->setPrinting(printing);
-    auto& frameView = *view();
-    frameView.adjustMediaTypeForPrinting(printing);
+    view()->adjustMediaTypeForPrinting(printing);
 
+    // FIXME: Consider invoking Page::updateRendering or an equivalent.
     m_doc->styleScope().didChangeStyleSheetEnvironment();
+    m_doc->evaluateMediaQueriesAndReportChanges();
+    if (!view())
+        return;
+
+    auto& frameView = *view();
     if (shouldUsePrintingLayout())
         frameView.forceLayoutForPagination(pageSize, originalPageSize, maximumShrinkRatio, shouldAdjustViewSize);
     else {
         frameView.forceLayout();
         if (shouldAdjustViewSize == AdjustViewSize)
@@ -627,11 +632,11 @@
     if (!m_script->shouldAllowUserAgentScripts(*document))
         return;
 
     document->setAsRunningUserScripts();
     loader().client().willInjectUserScript(world);
-    m_script->evaluateInWorld(ScriptSourceCode(script.source(), URL(script.url())), world);
+    m_script->evaluateInWorldIgnoringException(ScriptSourceCode(script.source(), URL(script.url())), world);
 }
 
 RenderView* Frame::contentRenderer() const
 {
     return document() ? document()->renderView() : nullptr;
@@ -704,11 +709,11 @@
     // The render tree can be torn down in a few different ways, but the two important ones are:
     //
     // - When calling Frame::setView() with a null FrameView*. This is always done before calling
     //   Frame::willDetachPage (this function.) Hence the assertion below.
     //
-    // - When adding a document to the page cache, the tree is torn down before instantiating
+    // - When adding a document to the back/forward cache, the tree is torn down before instantiating
     //   the CachedPage+CachedFrame object tree.
     ASSERT(!document() || !document()->renderView());
 }
 
 void Frame::disconnectOwnerElement()
@@ -912,11 +917,14 @@
 float Frame::frameScaleFactor() const
 {
     Page* page = this->page();
 
     // Main frame is scaled with respect to he container but inner frames are not scaled with respect to the main frame.
-    if (!page || &page->mainFrame() != this || settings().delegatesPageScaling())
+    if (!page || !isMainFrame())
+        return 1;
+
+    if (page->delegatesScaling())
         return 1;
 
     return page->pageScaleFactor();
 }
 
@@ -950,11 +958,16 @@
 
     // FIXME: Suspend/resume calls will not match if the frame is navigated, and gets a new document.
     m_doc->resumeScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
 
     // Frame::clearTimers() suspended animations and pending relayouts.
-    animation().resumeAnimationsForDocument(m_doc.get());
+
+    if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
+        if (auto* timeline = m_doc->existingTimeline())
+            timeline->resumeAnimations();
+    } else
+        animation().resumeAnimationsForDocument(m_doc.get());
     if (m_view)
         m_view->layoutContext().scheduleLayout();
 }
 
 void Frame::deviceOrPageScaleFactorChanged()
@@ -1011,11 +1024,6 @@
         dropChildren();
 
     deref();
 }
 
-PAL::SessionID Frame::sessionID() const
-{
-    return m_loader->client().sessionID();
-}
-
 } // namespace WebCore

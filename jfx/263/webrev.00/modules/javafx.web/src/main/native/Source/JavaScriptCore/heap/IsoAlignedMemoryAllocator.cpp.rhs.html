<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoAlignedMemoryAllocator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;IsoAlignedMemoryAllocator.h&quot;
 28 #include &quot;MarkedBlock.h&quot;
 29 
 30 namespace JSC {
 31 
<a name="1" id="anc1"></a><span class="line-modified"> 32 IsoAlignedMemoryAllocator::IsoAlignedMemoryAllocator(CString name)</span>
<span class="line-added"> 33 #if ENABLE(MALLOC_HEAP_BREAKDOWN)</span>
<span class="line-added"> 34     : m_debugHeap(name.data())</span>
<span class="line-added"> 35 #endif</span>
 36 {
<a name="2" id="anc2"></a><span class="line-added"> 37     UNUSED_PARAM(name);</span>
 38 }
 39 
 40 IsoAlignedMemoryAllocator::~IsoAlignedMemoryAllocator()
 41 {
<a name="3" id="anc3"></a><span class="line-added"> 42 #if !ENABLE(MALLOC_HEAP_BREAKDOWN)</span>
 43     for (unsigned i = 0; i &lt; m_blocks.size(); ++i) {
 44         void* block = m_blocks[i];
 45         if (!m_committed[i])
 46             WTF::fastCommitAlignedMemory(block, MarkedBlock::blockSize);
 47         fastAlignedFree(block);
 48     }
<a name="4" id="anc4"></a><span class="line-added"> 49 #endif</span>
 50 }
 51 
 52 void* IsoAlignedMemoryAllocator::tryAllocateAlignedMemory(size_t alignment, size_t size)
 53 {
 54     // Since this is designed specially for IsoSubspace, we know that we will only be asked to
 55     // allocate MarkedBlocks.
 56     RELEASE_ASSERT(alignment == MarkedBlock::blockSize);
 57     RELEASE_ASSERT(size == MarkedBlock::blockSize);
 58 
<a name="5" id="anc5"></a><span class="line-added"> 59 #if ENABLE(MALLOC_HEAP_BREAKDOWN)</span>
<span class="line-added"> 60     return m_debugHeap.memalign(MarkedBlock::blockSize, MarkedBlock::blockSize, true);</span>
<span class="line-added"> 61 #else</span>
 62     auto locker = holdLock(m_lock);
 63 
 64     m_firstUncommitted = m_committed.findBit(m_firstUncommitted, false);
 65     if (m_firstUncommitted &lt; m_blocks.size()) {
 66         m_committed[m_firstUncommitted] = true;
 67         void* result = m_blocks[m_firstUncommitted];
 68         WTF::fastCommitAlignedMemory(result, MarkedBlock::blockSize);
 69         return result;
 70     }
 71 
 72     void* result = tryFastAlignedMalloc(MarkedBlock::blockSize, MarkedBlock::blockSize);
 73     if (!result)
 74         return nullptr;
 75     unsigned index = m_blocks.size();
 76     m_blocks.append(result);
 77     m_blockIndices.add(result, index);
 78     if (m_blocks.capacity() != m_committed.size())
 79         m_committed.resize(m_blocks.capacity());
 80     m_committed[index] = true;
 81     return result;
<a name="6" id="anc6"></a><span class="line-added"> 82 #endif</span>
 83 }
 84 
 85 void IsoAlignedMemoryAllocator::freeAlignedMemory(void* basePtr)
 86 {
<a name="7" id="anc7"></a><span class="line-added"> 87 #if ENABLE(MALLOC_HEAP_BREAKDOWN)</span>
<span class="line-added"> 88     m_debugHeap.free(basePtr);</span>
<span class="line-added"> 89 #else</span>
 90     auto locker = holdLock(m_lock);
 91 
 92     auto iter = m_blockIndices.find(basePtr);
 93     RELEASE_ASSERT(iter != m_blockIndices.end());
 94     unsigned index = iter-&gt;value;
 95     m_committed[index] = false;
 96     m_firstUncommitted = std::min(index, m_firstUncommitted);
 97     WTF::fastDecommitAlignedMemory(basePtr, MarkedBlock::blockSize);
<a name="8" id="anc8"></a><span class="line-added"> 98 #endif</span>
 99 }
100 
101 void IsoAlignedMemoryAllocator::dump(PrintStream&amp; out) const
102 {
103     out.print(&quot;Iso(&quot;, RawPointer(this), &quot;)&quot;);
104 }
105 
<a name="9" id="anc9"></a><span class="line-modified">106 void* IsoAlignedMemoryAllocator::tryAllocateMemory(size_t size)</span>
107 {
<a name="10" id="anc10"></a><span class="line-modified">108 #if ENABLE(MALLOC_HEAP_BREAKDOWN)</span>
<span class="line-added">109     return m_debugHeap.malloc(size);</span>
<span class="line-added">110 #else</span>
<span class="line-added">111     return FastMalloc::tryMalloc(size);</span>
<span class="line-added">112 #endif</span>
113 }
114 
<a name="11" id="anc11"></a><span class="line-modified">115 void IsoAlignedMemoryAllocator::freeMemory(void* pointer)</span>
116 {
<a name="12" id="anc12"></a><span class="line-modified">117 #if ENABLE(MALLOC_HEAP_BREAKDOWN)</span>
<span class="line-added">118     m_debugHeap.free(pointer);</span>
<span class="line-added">119 #else</span>
<span class="line-added">120     FastMalloc::free(pointer);</span>
<span class="line-added">121 #endif</span>
122 }
123 
124 void* IsoAlignedMemoryAllocator::tryReallocateMemory(void*, size_t)
125 {
<a name="13" id="anc13"></a><span class="line-added">126     // In IsoSubspace-managed PreciseAllocation, we must not perform realloc.</span>
127     RELEASE_ASSERT_NOT_REACHED();
128 }
129 
130 } // namespace JSC
131 
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/TextIterator.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 // FIXME: Move each iterator class into a separate header file.
 29 
 30 #include &quot;FindOptions.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 31 #include &quot;LineLayoutTraversal.h&quot;</span>
 32 #include &quot;Range.h&quot;
 33 #include &quot;TextIteratorBehavior.h&quot;
 34 #include &lt;wtf/Vector.h&gt;
 35 #include &lt;wtf/text/StringView.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 class InlineTextBox;
 40 class RenderText;
 41 class RenderTextFragment;
 42 
 43 namespace SimpleLineLayout {
 44 class RunResolver;
 45 }
 46 
 47 WEBCORE_EXPORT String plainText(Position start, Position end, TextIteratorBehavior = TextIteratorDefaultBehavior, bool isDisplayString = false);
 48 WEBCORE_EXPORT String plainTextReplacingNoBreakSpace(Position start, Position end, TextIteratorBehavior = TextIteratorDefaultBehavior, bool isDisplayString = false);
 49 
 50 WEBCORE_EXPORT String plainText(const Range*, TextIteratorBehavior = TextIteratorDefaultBehavior, bool isDisplayString = false);
 51 WEBCORE_EXPORT String plainTextReplacingNoBreakSpace(const Range*, TextIteratorBehavior = TextIteratorDefaultBehavior, bool isDisplayString = false);
 52 WEBCORE_EXPORT String plainTextUsingBackwardsTextIteratorForTesting(const Range&amp;);
 53 
 54 Ref&lt;Range&gt; findPlainText(const Range&amp;, const String&amp;, FindOptions);
 55 WEBCORE_EXPORT Ref&lt;Range&gt; findClosestPlainText(const Range&amp;, const String&amp;, FindOptions, unsigned);
 56 WEBCORE_EXPORT bool hasAnyPlainText(const Range&amp;, TextIteratorBehavior = TextIteratorDefaultBehavior);
 57 bool findPlainText(const String&amp; document, const String&amp;, FindOptions); // Lets us use the search algorithm on a string.
 58 WEBCORE_EXPORT String foldQuoteMarks(const String&amp;);
 59 
 60 // FIXME: Move this somewhere else in the editing directory. It doesn&#39;t belong here.
 61 bool isRendererReplacedElement(RenderObject*);
 62 
 63 class BitStack {
 64 public:
 65     BitStack();
 66     ~BitStack();
 67 
 68     void push(bool);
 69     void pop();
 70 
 71     bool top() const;
 72     unsigned size() const;
 73 
 74 private:
 75     unsigned m_size;
 76     Vector&lt;unsigned, 1&gt; m_words;
 77 };
 78 
 79 class TextIteratorCopyableText {
 80 public:
 81     TextIteratorCopyableText()
 82         : m_singleCharacter(0)
 83         , m_offset(0)
 84         , m_length(0)
 85     {
 86     }
 87 
 88     StringView text() const { return m_singleCharacter ? StringView(&amp;m_singleCharacter, 1) : StringView(m_string).substring(m_offset, m_length); }
 89     void appendToStringBuilder(StringBuilder&amp;) const;
 90 
 91     void reset();
 92     void set(String&amp;&amp;);
 93     void set(String&amp;&amp;, unsigned offset, unsigned length);
 94     void set(UChar);
 95 
 96 private:
 97     UChar m_singleCharacter;
 98     String m_string;
 99     unsigned m_offset;
100     unsigned m_length;
101 };
102 
103 // Iterates through the DOM range, returning all the text, and 0-length boundaries
104 // at points where replaced elements break up the text flow. The text is delivered in
105 // the chunks it&#39;s already stored in, to avoid copying any text.
106 
107 class TextIterator {
108     WTF_MAKE_FAST_ALLOCATED;
109 public:
110     WEBCORE_EXPORT explicit TextIterator(Position start, Position end, TextIteratorBehavior = TextIteratorDefaultBehavior);
111     WEBCORE_EXPORT explicit TextIterator(const Range*, TextIteratorBehavior = TextIteratorDefaultBehavior);
112     WEBCORE_EXPORT ~TextIterator();
113 
114     bool atEnd() const { return !m_positionNode; }
115     WEBCORE_EXPORT void advance();
116 
117     StringView text() const { ASSERT(!atEnd()); return m_text; }
118     WEBCORE_EXPORT Ref&lt;Range&gt; range() const;
119     WEBCORE_EXPORT Node* node() const;
120 
121     const TextIteratorCopyableText&amp; copyableText() const { ASSERT(!atEnd()); return m_copyableText; }
122     void appendTextToStringBuilder(StringBuilder&amp; builder) const { copyableText().appendToStringBuilder(builder); }
123 
124     WEBCORE_EXPORT static int rangeLength(const Range*, bool spacesForReplacedElements = false);
125     WEBCORE_EXPORT static RefPtr&lt;Range&gt; rangeFromLocationAndLength(ContainerNode* scope, int rangeLocation, int rangeLength, bool spacesForReplacedElements = false);
126     WEBCORE_EXPORT static bool getLocationAndLengthFromRange(Node* scope, const Range*, size_t&amp; location, size_t&amp; length);
127     WEBCORE_EXPORT static Ref&lt;Range&gt; subrange(Range&amp; entireRange, int characterOffset, int characterCount);
128 
129 private:
130     void init();
131     void exitNode(Node*);
132     bool shouldRepresentNodeOffsetZero();
133     bool shouldEmitSpaceBeforeAndAfterNode(Node&amp;);
134     void representNodeOffsetZero();
135     bool handleTextNode();
136     bool handleReplacedElement();
137     bool handleNonTextNode();
138     void handleTextBox();
139     void handleTextNodeFirstLetter(RenderTextFragment&amp;);
140     void emitCharacter(UChar, Node&amp; characterNode, Node* offsetBaseNode, int textStartOffset, int textEndOffset);
141     void emitText(Text&amp; textNode, RenderText&amp;, int textStartOffset, int textEndOffset);
142 
143     Node* baseNodeForEmittingNewLine() const;
144 
145     const TextIteratorBehavior m_behavior { TextIteratorDefaultBehavior };
146 
147     // Current position, not necessarily of the text being returned, but position as we walk through the DOM tree.
148     Node* m_node { nullptr };
149     int m_offset { 0 };
150     bool m_handledNode { false };
151     bool m_handledChildren { false };
152     BitStack m_fullyClippedStack;
153 
154     // The range.
155     Node* m_startContainer { nullptr };
156     int m_startOffset { 0 };
157     Node* m_endContainer { nullptr };
158     int m_endOffset { 0 };
159     Node* m_pastEndNode { nullptr };
160 
161     // The current text and its position, in the form to be returned from the iterator.
162     Node* m_positionNode { nullptr };
163     mutable Node* m_positionOffsetBaseNode { nullptr };
164     mutable int m_positionStartOffset { 0 };
165     mutable int m_positionEndOffset { 0 };
166     TextIteratorCopyableText m_copyableText;
167     StringView m_text;
168 
169     // Used when there is still some pending text from the current node; when these are false and null, we go back to normal iterating.
170     Node* m_nodeForAdditionalNewline { nullptr };
<a name="2" id="anc2"></a><span class="line-modified">171     LineLayoutTraversal::TextBoxIterator m_textBox;</span>
172 
173     // Used when iterating over :first-letter text to save pointer to remaining text box.
<a name="3" id="anc3"></a><span class="line-modified">174     LineLayoutTraversal::TextBoxIterator m_remainingTextBox;</span>
175 
176     // Used to point to RenderText object for :first-letter.
177     RenderText* m_firstLetterText { nullptr };
178 
179     // Used to do the whitespace collapsing logic.
180     Text* m_lastTextNode { nullptr };
181     bool m_lastTextNodeEndedWithCollapsedSpace { false };
182     UChar m_lastCharacter { 0 };
183 
<a name="4" id="anc4"></a>









184     // Used when deciding whether to emit a &quot;positioning&quot; (e.g. newline) before any other content
185     bool m_hasEmitted { false };
186 
187     // Used when deciding text fragment created by :first-letter should be looked into.
188     bool m_handledFirstLetter { false };
189 };
190 
191 // Iterates through the DOM range, returning all the text, and 0-length boundaries
192 // at points where replaced elements break up the text flow. The text comes back in
193 // chunks so as to optimize for performance of the iteration.
194 class SimplifiedBackwardsTextIterator {
195 public:
196     explicit SimplifiedBackwardsTextIterator(const Range&amp;);
197 
198     bool atEnd() const { return !m_positionNode; }
199     void advance();
200 
201     StringView text() const { ASSERT(!atEnd()); return m_text; }
202     WEBCORE_EXPORT Ref&lt;Range&gt; range() const;
203     Node* node() const { ASSERT(!atEnd()); return m_node; }
204 
205 private:
206     void exitNode();
207     bool handleTextNode();
208     RenderText* handleFirstLetter(int&amp; startOffset, int&amp; offsetInNode);
209     bool handleReplacedElement();
210     bool handleNonTextNode();
211     void emitCharacter(UChar, Node&amp;, int startOffset, int endOffset);
212     bool advanceRespectingRange(Node*);
213 
214     const TextIteratorBehavior m_behavior { TextIteratorDefaultBehavior };
215 
216     // Current position, not necessarily of the text being returned, but position as we walk through the DOM tree.
217     Node* m_node { nullptr };
218     int m_offset { 0 };
219     bool m_handledNode { false };
220     bool m_handledChildren { false };
221     BitStack m_fullyClippedStack;
222 
223     // The range.
224     Node* m_startContainer { nullptr };
225     int m_startOffset { 0 };
226     Node* m_endContainer { nullptr };
227     int m_endOffset { 0 };
228 
229     // The current text and its position, in the form to be returned from the iterator.
230     Node* m_positionNode { nullptr };
231     int m_positionStartOffset { 0 };
232     int m_positionEndOffset { 0 };
233     TextIteratorCopyableText m_copyableText;
234     StringView m_text;
235 
236     // Used to do the whitespace logic.
237     Text* m_lastTextNode { nullptr };
238     UChar m_lastCharacter { 0 };
239 
240     // Whether m_node has advanced beyond the iteration range (i.e. m_startContainer).
241     bool m_havePassedStartContainer { false };
242 
243     // Should handle first-letter renderer in the next call to handleTextNode.
244     bool m_shouldHandleFirstLetter { false };
245 };
246 
247 // Builds on the text iterator, adding a character position so we can walk one
248 // character at a time, or faster, as needed. Useful for searching.
249 class CharacterIterator {
250 public:
<a name="5" id="anc5"></a><span class="line-modified">251     WEBCORE_EXPORT explicit CharacterIterator(const Range&amp;, TextIteratorBehavior = TextIteratorDefaultBehavior);</span>
252     WEBCORE_EXPORT explicit CharacterIterator(Position start, Position end, TextIteratorBehavior = TextIteratorDefaultBehavior);
253 
254     bool atEnd() const { return m_underlyingIterator.atEnd(); }
255     WEBCORE_EXPORT void advance(int numCharacters);
256 
257     StringView text() const { return m_underlyingIterator.text().substring(m_runOffset); }
258     WEBCORE_EXPORT Ref&lt;Range&gt; range() const;
259 
260     bool atBreak() const { return m_atBreak; }
261     int characterOffset() const { return m_offset; }
262 
263 private:
264     TextIterator m_underlyingIterator;
265 
266     int m_offset { 0 };
267     int m_runOffset { 0 };
268     bool m_atBreak { true };
269 };
270 
271 class BackwardsCharacterIterator {
272 public:
273     explicit BackwardsCharacterIterator(const Range&amp;);
274 
275     bool atEnd() const { return m_underlyingIterator.atEnd(); }
276     void advance(int numCharacters);
277 
278     Ref&lt;Range&gt; range() const;
279 
280 private:
281     SimplifiedBackwardsTextIterator m_underlyingIterator;
282 
283     int m_offset;
284     int m_runOffset;
285     bool m_atBreak;
286 };
287 
288 // Similar to the TextIterator, except that the chunks of text returned are &quot;well behaved&quot;, meaning
289 // they never split up a word. This is useful for spell checking and perhaps one day for searching as well.
290 class WordAwareIterator {
291 public:
292     explicit WordAwareIterator(const Range&amp;);
293 
294     bool atEnd() const { return !m_didLookAhead &amp;&amp; m_underlyingIterator.atEnd(); }
295     void advance();
296 
297     StringView text() const;
298 
299 private:
300     TextIterator m_underlyingIterator;
301 
302     // Text from the previous chunk from the text iterator.
303     TextIteratorCopyableText m_previousText;
304 
305     // Many chunks from text iterator concatenated.
306     Vector&lt;UChar&gt; m_buffer;
307 
308     // Did we have to look ahead in the text iterator to confirm the current chunk?
309     bool m_didLookAhead;
310 };
311 
312 } // namespace WebCore
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
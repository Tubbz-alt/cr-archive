<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/Element.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2001 Peter Kelly (pmk@post.com)
  5  *           (C) 2001 Dirk Mueller (mueller@kde.org)
  6  * Copyright (C) 2003-2017 Apple Inc. All rights reserved.
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  *
 23  */
 24 
 25 #pragma once
 26 
 27 #include &quot;AXTextStateChangeIntent.h&quot;
 28 #include &quot;Document.h&quot;
 29 #include &quot;ElementData.h&quot;
 30 #include &quot;HTMLNames.h&quot;
<a name="1" id="anc1"></a>

 31 #include &quot;ScrollTypes.h&quot;
 32 #include &quot;ShadowRootMode.h&quot;
 33 #include &quot;SimulatedClickOptions.h&quot;
 34 #include &quot;StyleChange.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 35 #include &lt;JavaScriptCore/Strong.h&gt;</span>
 36 
 37 namespace WebCore {
 38 
 39 class CustomElementReactionQueue;
 40 class DatasetDOMStringMap;
 41 class DOMRect;
 42 class DOMRectList;
 43 class DOMTokenList;
 44 class ElementRareData;
 45 class Frame;
 46 class HTMLDocument;
 47 class IntSize;
 48 class JSCustomElementInterface;
<a name="3" id="anc3"></a><span class="line-added"> 49 class KeyframeEffectStack;</span>
 50 class KeyboardEvent;
 51 class Locale;
 52 class PlatformKeyboardEvent;
 53 class PlatformMouseEvent;
 54 class PlatformWheelEvent;
 55 class PseudoElement;
 56 class RenderTreePosition;
 57 class StylePropertyMap;
 58 class WebAnimation;
<a name="4" id="anc4"></a><span class="line-modified"> 59 </span>
<span class="line-added"> 60 struct GetAnimationsOptions;</span>
<span class="line-added"> 61 struct KeyframeAnimationOptions;</span>
 62 struct ScrollIntoViewOptions;
<a name="5" id="anc5"></a><span class="line-added"> 63 struct ScrollToOptions;</span>
 64 
 65 #if ENABLE(INTERSECTION_OBSERVER)
 66 struct IntersectionObserverData;
 67 #endif
 68 
 69 #if ENABLE(RESIZE_OBSERVER)
 70 struct ResizeObserverData;
 71 #endif
 72 
<a name="6" id="anc6"></a><span class="line-modified"> 73 namespace Style {</span>
<span class="line-modified"> 74 struct ElementStyle;</span>
<span class="line-modified"> 75 }</span>
<span class="line-modified"> 76 </span>
<span class="line-modified"> 77 enum class AnimationImpact;</span>
 78 
 79 class Element : public ContainerNode {
 80     WTF_MAKE_ISO_ALLOCATED(Element);
 81 public:
 82     static Ref&lt;Element&gt; create(const QualifiedName&amp;, Document&amp;);
 83     virtual ~Element();
 84 
 85     WEBCORE_EXPORT bool hasAttribute(const QualifiedName&amp;) const;
 86     WEBCORE_EXPORT const AtomString&amp; getAttribute(const QualifiedName&amp;) const;
 87     template&lt;typename... QualifiedNames&gt;
 88     const AtomString&amp; getAttribute(const QualifiedName&amp;, const QualifiedNames&amp;...) const;
 89     WEBCORE_EXPORT void setAttribute(const QualifiedName&amp;, const AtomString&amp; value);
 90     WEBCORE_EXPORT void setAttributeWithoutSynchronization(const QualifiedName&amp;, const AtomString&amp; value);
 91     void setSynchronizedLazyAttribute(const QualifiedName&amp;, const AtomString&amp; value);
 92     bool removeAttribute(const QualifiedName&amp;);
 93     Vector&lt;String&gt; getAttributeNames() const;
 94 
 95     // Typed getters and setters for language bindings.
 96     WEBCORE_EXPORT int getIntegralAttribute(const QualifiedName&amp; attributeName) const;
 97     WEBCORE_EXPORT void setIntegralAttribute(const QualifiedName&amp; attributeName, int value);
 98     WEBCORE_EXPORT unsigned getUnsignedIntegralAttribute(const QualifiedName&amp; attributeName) const;
 99     WEBCORE_EXPORT void setUnsignedIntegralAttribute(const QualifiedName&amp; attributeName, unsigned value);
100 
101     // Call this to get the value of an attribute that is known not to be the style
102     // attribute or one of the SVG animatable attributes.
103     bool hasAttributeWithoutSynchronization(const QualifiedName&amp;) const;
104     const AtomString&amp; attributeWithoutSynchronization(const QualifiedName&amp;) const;
<a name="7" id="anc7"></a>


105 
106 #if DUMP_NODE_STATISTICS
107     bool hasNamedNodeMap() const;
108 #endif
<a name="8" id="anc8"></a><span class="line-added">109 </span>
110     WEBCORE_EXPORT bool hasAttributes() const;
<a name="9" id="anc9"></a><span class="line-added">111 </span>
112     // This variant will not update the potentially invalid attributes. To be used when not interested
113     // in style attribute or one of the SVG animation attributes.
114     bool hasAttributesWithoutUpdate() const;
115 
116     WEBCORE_EXPORT bool hasAttribute(const AtomString&amp; qualifiedName) const;
117     WEBCORE_EXPORT bool hasAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName) const;
118 
119     WEBCORE_EXPORT const AtomString&amp; getAttribute(const AtomString&amp; qualifiedName) const;
120     WEBCORE_EXPORT const AtomString&amp; getAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName) const;
121 
122     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setAttribute(const AtomString&amp; qualifiedName, const AtomString&amp; value);
123     static ExceptionOr&lt;QualifiedName&gt; parseAttributeName(const AtomString&amp; namespaceURI, const AtomString&amp; qualifiedName);
124     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; qualifiedName, const AtomString&amp; value);
125 
126     ExceptionOr&lt;bool&gt; toggleAttribute(const AtomString&amp; qualifiedName, Optional&lt;bool&gt; force);
127 
128     const AtomString&amp; getIdAttribute() const;
129     void setIdAttribute(const AtomString&amp;);
130 
131     const AtomString&amp; getNameAttribute() const;
132 
133     // Call this to get the value of the id attribute for style resolution purposes.
134     // The value will already be lowercased if the document is in compatibility mode,
135     // so this function is not suitable for non-style uses.
136     const AtomString&amp; idForStyleResolution() const;
137 
138     // Internal methods that assume the existence of attribute storage, one should use hasAttributes()
139     // before calling them.
140     AttributeIteratorAccessor attributesIterator() const { return elementData()-&gt;attributesIterator(); }
141     unsigned attributeCount() const;
142     const Attribute&amp; attributeAt(unsigned index) const;
143     const Attribute* findAttributeByName(const QualifiedName&amp;) const;
144     unsigned findAttributeIndexByName(const QualifiedName&amp; name) const { return elementData()-&gt;findAttributeIndexByName(name); }
145     unsigned findAttributeIndexByName(const AtomString&amp; name, bool shouldIgnoreAttributeCase) const { return elementData()-&gt;findAttributeIndexByName(name, shouldIgnoreAttributeCase); }
146 
147     WEBCORE_EXPORT void scrollIntoView(Optional&lt;Variant&lt;bool, ScrollIntoViewOptions&gt;&gt;&amp;&amp; arg);
148     WEBCORE_EXPORT void scrollIntoView(bool alignToTop = true);
149     WEBCORE_EXPORT void scrollIntoViewIfNeeded(bool centerIfNeeded = true);
150     WEBCORE_EXPORT void scrollIntoViewIfNotVisible(bool centerIfNotVisible = true);
151 
152     void scrollBy(const ScrollToOptions&amp;);
153     void scrollBy(double x, double y);
154     virtual void scrollTo(const ScrollToOptions&amp;, ScrollClamping = ScrollClamping::Clamped);
155     void scrollTo(double x, double y);
156 
157     WEBCORE_EXPORT void scrollByLines(int lines);
158     WEBCORE_EXPORT void scrollByPages(int pages);
159 
160     WEBCORE_EXPORT double offsetLeftForBindings();
161     WEBCORE_EXPORT double offsetLeft();
162     WEBCORE_EXPORT double offsetTopForBindings();
163     WEBCORE_EXPORT double offsetTop();
164     WEBCORE_EXPORT double offsetWidth();
165     WEBCORE_EXPORT double offsetHeight();
166 
167     bool mayCauseRepaintInsideViewport(const IntRect* visibleRect = nullptr) const;
168 
169     // FIXME: Replace uses of offsetParent in the platform with calls
170     // to the render layer and merge bindingsOffsetParent and offsetParent.
171     WEBCORE_EXPORT Element* offsetParentForBindings();
172 
173     const Element* rootElement() const;
174 
175     Element* offsetParent();
176     WEBCORE_EXPORT double clientLeft();
177     WEBCORE_EXPORT double clientTop();
178     WEBCORE_EXPORT double clientWidth();
179     WEBCORE_EXPORT double clientHeight();
180 
181     virtual int scrollLeft();
182     virtual int scrollTop();
183     virtual void setScrollLeft(int);
184     virtual void setScrollTop(int);
185     virtual int scrollWidth();
186     virtual int scrollHeight();
187 
188     WEBCORE_EXPORT IntRect boundsInRootViewSpace();
189 
190     Optional&lt;std::pair&lt;RenderObject*, FloatRect&gt;&gt; boundingAbsoluteRectWithoutLayout();
191 
192     WEBCORE_EXPORT FloatRect boundingClientRect();
193 
194     WEBCORE_EXPORT Ref&lt;DOMRectList&gt; getClientRects();
195     Ref&lt;DOMRect&gt; getBoundingClientRect();
196 
197     // Returns the absolute bounding box translated into client coordinates.
198     WEBCORE_EXPORT IntRect clientRect() const;
<a name="10" id="anc10"></a><span class="line-added">199 </span>
200     // Returns the absolute bounding box translated into screen coordinates.
201     WEBCORE_EXPORT IntRect screenRect() const;
202 
203     WEBCORE_EXPORT bool removeAttribute(const AtomString&amp; qualifiedName);
204     WEBCORE_EXPORT bool removeAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName);
205 
206     Ref&lt;Attr&gt; detachAttribute(unsigned index);
207 
208     WEBCORE_EXPORT RefPtr&lt;Attr&gt; getAttributeNode(const AtomString&amp; qualifiedName);
209     WEBCORE_EXPORT RefPtr&lt;Attr&gt; getAttributeNodeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName);
210     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; setAttributeNode(Attr&amp;);
211     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; setAttributeNodeNS(Attr&amp;);
212     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Attr&gt;&gt; removeAttributeNode(Attr&amp;);
213 
214     RefPtr&lt;Attr&gt; attrIfExists(const QualifiedName&amp;);
215     RefPtr&lt;Attr&gt; attrIfExists(const AtomString&amp; localName, bool shouldIgnoreAttributeCase);
216     Ref&lt;Attr&gt; ensureAttr(const QualifiedName&amp;);
217 
218     const Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; attrNodeList();
219 
220     const QualifiedName&amp; tagQName() const { return m_tagName; }
221 #if ENABLE(JIT)
222     static ptrdiff_t tagQNameMemoryOffset() { return OBJECT_OFFSETOF(Element, m_tagName); }
<a name="11" id="anc11"></a><span class="line-modified">223 #endif</span>
224     String tagName() const { return nodeName(); }
225     bool hasTagName(const QualifiedName&amp; tagName) const { return m_tagName.matches(tagName); }
226     bool hasTagName(const HTMLQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
227     bool hasTagName(const MathMLQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
228     bool hasTagName(const SVGQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
229 
<a name="12" id="anc12"></a>
230     bool hasLocalName(const AtomString&amp; other) const { return m_tagName.localName() == other; }
231 
232     const AtomString&amp; localName() const final { return m_tagName.localName(); }
233     const AtomString&amp; prefix() const final { return m_tagName.prefix(); }
234     const AtomString&amp; namespaceURI() const final { return m_tagName.namespaceURI(); }
235 
236     ExceptionOr&lt;void&gt; setPrefix(const AtomString&amp;) final;
237 
238     String nodeName() const override;
239 
240     Ref&lt;Element&gt; cloneElementWithChildren(Document&amp;);
241     Ref&lt;Element&gt; cloneElementWithoutChildren(Document&amp;);
242 
243     void normalizeAttributes();
244     String nodeNamePreservingCase() const;
245 
246     WEBCORE_EXPORT void setBooleanAttribute(const QualifiedName&amp; name, bool);
247 
248     // For exposing to DOM only.
249     WEBCORE_EXPORT NamedNodeMap&amp; attributes() const;
250 
251     enum AttributeModificationReason {
252         ModifiedDirectly,
253         ModifiedByCloning
254     };
255 
<a name="13" id="anc13"></a><span class="line-modified">256     // These functions are called whenever an attribute is added, changed or removed.</span>
257     virtual void attributeChanged(const QualifiedName&amp;, const AtomString&amp; oldValue, const AtomString&amp; newValue, AttributeModificationReason = ModifiedDirectly);
258     virtual void parseAttribute(const QualifiedName&amp;, const AtomString&amp;) { }
259 
260     // Only called by the parser immediately after element construction.
261     void parserSetAttributes(const Vector&lt;Attribute&gt;&amp;);
262 
263     bool isEventHandlerAttribute(const Attribute&amp;) const;
264     bool isJavaScriptURLAttribute(const Attribute&amp;) const;
265 
266     // Remove attributes that might introduce scripting from the vector leaving the element unchanged.
267     void stripScriptingAttributes(Vector&lt;Attribute&gt;&amp;) const;
268 
269     const ElementData* elementData() const { return m_elementData.get(); }
270     static ptrdiff_t elementDataMemoryOffset() { return OBJECT_OFFSETOF(Element, m_elementData); }
271     UniqueElementData&amp; ensureUniqueElementData();
272 
273     void synchronizeAllAttributes() const;
274 
275     // Clones attributes only.
276     void cloneAttributesFromElement(const Element&amp;);
277 
278     // Clones all attribute-derived data, including subclass specifics (through copyNonAttributeProperties.)
279     void cloneDataFromElement(const Element&amp;);
280 
281     virtual void didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument);
282 
283     bool hasEquivalentAttributes(const Element&amp; other) const;
284 
285     virtual void copyNonAttributePropertiesFromElement(const Element&amp;) { }
286 
287     virtual RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;);
288     virtual bool rendererIsNeeded(const RenderStyle&amp;);
<a name="14" id="anc14"></a><span class="line-added">289     virtual bool rendererIsEverNeeded() { return true; }</span>
290 
291     WEBCORE_EXPORT ShadowRoot* shadowRoot() const;
<a name="15" id="anc15"></a><span class="line-modified">292     ShadowRoot* shadowRootForBindings(JSC::JSGlobalObject&amp;) const;</span>
293 
294     struct ShadowRootInit {
295         ShadowRootMode mode;
<a name="16" id="anc16"></a><span class="line-added">296         bool delegatesFocus { false };</span>
297     };
298     ExceptionOr&lt;ShadowRoot&amp;&gt; attachShadow(const ShadowRootInit&amp;);
299 
300     RefPtr&lt;ShadowRoot&gt; userAgentShadowRoot() const;
301     WEBCORE_EXPORT ShadowRoot&amp; ensureUserAgentShadowRoot();
302 
303     void setIsDefinedCustomElement(JSCustomElementInterface&amp;);
304     void setIsFailedCustomElement(JSCustomElementInterface&amp;);
305     void setIsCustomElementUpgradeCandidate();
306     void enqueueToUpgrade(JSCustomElementInterface&amp;);
307     CustomElementReactionQueue* reactionQueue() const;
308 
<a name="17" id="anc17"></a><span class="line-modified">309     // FIXME: This should not be virtual. Please do not add additional overrides of this function.</span>
310     virtual const AtomString&amp; shadowPseudoId() const;
311 
312     bool isInActiveChain() const { return isUserActionElement() &amp;&amp; isUserActionElementInActiveChain(); }
313     bool active() const { return isUserActionElement() &amp;&amp; isUserActionElementActive(); }
314     bool hovered() const { return isUserActionElement() &amp;&amp; isUserActionElementHovered(); }
315     bool focused() const { return isUserActionElement() &amp;&amp; isUserActionElementFocused(); }
316     bool hasFocusWithin() const { return getFlag(HasFocusWithin); };
317 
318     virtual void setActive(bool flag = true, bool pause = false);
319     virtual void setHovered(bool flag = true);
320     virtual void setFocus(bool flag);
321     void setHasFocusWithin(bool flag);
322 
323     Optional&lt;int&gt; tabIndexSetExplicitly() const;
324     bool shouldBeIgnoredInSequentialFocusNavigation() const { return defaultTabIndex() &lt; 0 &amp;&amp; !supportsFocus(); }
325     virtual bool supportsFocus() const;
326     virtual bool isFocusable() const;
327     virtual bool isKeyboardFocusable(KeyboardEvent*) const;
328     virtual bool isMouseFocusable() const;
329 
330     virtual bool shouldUseInputMethod();
331 
332     virtual int tabIndexForBindings() const;
333     WEBCORE_EXPORT void setTabIndexForBindings(int);
334     virtual RefPtr&lt;Element&gt; focusDelegate();
335 
336     ExceptionOr&lt;void&gt; insertAdjacentHTML(const String&amp; where, const String&amp; html, NodeVector* addedNodes);
337 
338     WEBCORE_EXPORT ExceptionOr&lt;Element*&gt; insertAdjacentElement(const String&amp; where, Element&amp; newChild);
339     WEBCORE_EXPORT ExceptionOr&lt;void&gt; insertAdjacentHTML(const String&amp; where, const String&amp; html);
340     WEBCORE_EXPORT ExceptionOr&lt;void&gt; insertAdjacentText(const String&amp; where, const String&amp; text);
341 
342     const RenderStyle* computedStyle(PseudoId = PseudoId::None) override;
343 
344     bool needsStyleInvalidation() const;
345 
346     // Methods for indicating the style is affected by dynamic updates (e.g., children changing, our position changing in our sibling list, etc.)
347     bool styleAffectedByActive() const { return hasStyleFlag(ElementStyleFlag::StyleAffectedByActive); }
348     bool styleAffectedByEmpty() const { return hasStyleFlag(ElementStyleFlag::StyleAffectedByEmpty); }
349     bool styleAffectedByFocusWithin() const { return getFlag(StyleAffectedByFocusWithinFlag); }
350     bool descendantsAffectedByPreviousSibling() const { return getFlag(DescendantsAffectedByPreviousSiblingFlag); }
351     bool childrenAffectedByHover() const { return getFlag(ChildrenAffectedByHoverRulesFlag); }
352     bool childrenAffectedByDrag() const { return hasStyleFlag(ElementStyleFlag::ChildrenAffectedByDrag); }
353     bool childrenAffectedByFirstChildRules() const { return getFlag(ChildrenAffectedByFirstChildRulesFlag); }
354     bool childrenAffectedByLastChildRules() const { return getFlag(ChildrenAffectedByLastChildRulesFlag); }
355     bool childrenAffectedByForwardPositionalRules() const { return hasStyleFlag(ElementStyleFlag::ChildrenAffectedByForwardPositionalRules); }
356     bool descendantsAffectedByForwardPositionalRules() const { return hasStyleFlag(ElementStyleFlag::DescendantsAffectedByForwardPositionalRules); }
357     bool childrenAffectedByBackwardPositionalRules() const { return hasStyleFlag(ElementStyleFlag::ChildrenAffectedByBackwardPositionalRules); }
358     bool descendantsAffectedByBackwardPositionalRules() const { return hasStyleFlag(ElementStyleFlag::DescendantsAffectedByBackwardPositionalRules); }
359     bool childrenAffectedByPropertyBasedBackwardPositionalRules() const { return hasStyleFlag(ElementStyleFlag::ChildrenAffectedByPropertyBasedBackwardPositionalRules); }
360     bool affectsNextSiblingElementStyle() const { return getFlag(AffectsNextSiblingElementStyle); }
361     unsigned childIndex() const { return hasRareData() ? rareDataChildIndex() : 0; }
362 
363     bool hasFlagsSetDuringStylingOfChildren() const;
364 
365     void setStyleAffectedByEmpty() { setStyleFlag(ElementStyleFlag::StyleAffectedByEmpty); }
366     void setStyleAffectedByFocusWithin() { setFlag(StyleAffectedByFocusWithinFlag); }
367     void setDescendantsAffectedByPreviousSibling() { setFlag(DescendantsAffectedByPreviousSiblingFlag); }
368     void setChildrenAffectedByHover() { setFlag(ChildrenAffectedByHoverRulesFlag); }
369     void setStyleAffectedByActive() { setStyleFlag(ElementStyleFlag::StyleAffectedByActive); }
370     void setChildrenAffectedByDrag() { setStyleFlag(ElementStyleFlag::ChildrenAffectedByDrag); }
371     void setChildrenAffectedByFirstChildRules() { setFlag(ChildrenAffectedByFirstChildRulesFlag); }
372     void setChildrenAffectedByLastChildRules() { setFlag(ChildrenAffectedByLastChildRulesFlag); }
373     void setChildrenAffectedByForwardPositionalRules() { setStyleFlag(ElementStyleFlag::ChildrenAffectedByForwardPositionalRules); }
374     void setDescendantsAffectedByForwardPositionalRules() { setStyleFlag(ElementStyleFlag::DescendantsAffectedByForwardPositionalRules); }
375     void setChildrenAffectedByBackwardPositionalRules() { setStyleFlag(ElementStyleFlag::ChildrenAffectedByBackwardPositionalRules); }
376     void setDescendantsAffectedByBackwardPositionalRules() { setStyleFlag(ElementStyleFlag::DescendantsAffectedByBackwardPositionalRules); }
377     void setChildrenAffectedByPropertyBasedBackwardPositionalRules() { setStyleFlag(ElementStyleFlag::ChildrenAffectedByPropertyBasedBackwardPositionalRules); }
378     void setAffectsNextSiblingElementStyle() { setFlag(AffectsNextSiblingElementStyle); }
379     void setStyleIsAffectedByPreviousSibling() { setFlag(StyleIsAffectedByPreviousSibling); }
380     void setChildIndex(unsigned);
381 
382     WEBCORE_EXPORT AtomString computeInheritedLanguage() const;
383     Locale&amp; locale() const;
384 
385     virtual void accessKeyAction(bool /*sendToAnyEvent*/) { }
386 
387     virtual bool isURLAttribute(const Attribute&amp;) const { return false; }
388     virtual bool attributeContainsURL(const Attribute&amp; attribute) const { return isURLAttribute(attribute); }
389     virtual String completeURLsInAttributeValue(const URL&amp; base, const Attribute&amp;) const;
390     virtual bool isHTMLContentAttribute(const Attribute&amp;) const { return false; }
391 
392     WEBCORE_EXPORT URL getURLAttribute(const QualifiedName&amp;) const;
393     URL getNonEmptyURLAttribute(const QualifiedName&amp;) const;
394 
395     virtual const AtomString&amp; imageSourceURL() const;
396     virtual String target() const { return String(); }
397 
398     static AXTextStateChangeIntent defaultFocusTextStateChangeIntent() { return AXTextStateChangeIntent(AXTextStateChangeTypeSelectionMove, AXTextSelection { AXTextSelectionDirectionDiscontiguous, AXTextSelectionGranularityUnknown, true }); }
399     virtual void focus(bool restorePreviousSelection = true, FocusDirection = FocusDirectionNone);
400     virtual RefPtr&lt;Element&gt; focusAppearanceUpdateTarget();
401     virtual void updateFocusAppearance(SelectionRestorationMode, SelectionRevealMode = SelectionRevealMode::Reveal);
402     virtual void blur();
403 
404     WEBCORE_EXPORT String innerHTML() const;
405     WEBCORE_EXPORT String outerHTML() const;
406     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setInnerHTML(const String&amp;);
407     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setOuterHTML(const String&amp;);
408     WEBCORE_EXPORT String innerText();
409     WEBCORE_EXPORT String outerText();
410 
411     virtual String title() const;
412 
413     const AtomString&amp; pseudo() const;
414     WEBCORE_EXPORT void setPseudo(const AtomString&amp;);
415 
416     LayoutSize minimumSizeForResizing() const;
417     void setMinimumSizeForResizing(const LayoutSize&amp;);
418 
419     // Use Document::registerForDocumentActivationCallbacks() to subscribe to these
420     virtual void prepareForDocumentSuspension() { }
421     virtual void resumeFromDocumentSuspension() { }
422 
<a name="18" id="anc18"></a>





423     virtual void willBecomeFullscreenElement();
424     virtual void ancestorWillEnterFullscreen() { }
425     virtual void didBecomeFullscreenElement() { }
426     virtual void willStopBeingFullscreenElement() { }
427 
<a name="19" id="anc19"></a>



428     bool isFinishedParsingChildren() const { return isParsingChildrenFinished(); }
429     void finishParsingChildren() override;
430     void beginParsingChildren() final;
431 
432     WEBCORE_EXPORT PseudoElement* beforePseudoElement() const;
433     WEBCORE_EXPORT PseudoElement* afterPseudoElement() const;
434     bool childNeedsShadowWalker() const;
435     void didShadowTreeAwareChildrenChange();
436 
437     virtual bool matchesValidPseudoClass() const;
438     virtual bool matchesInvalidPseudoClass() const;
439     virtual bool matchesReadWritePseudoClass() const;
440     virtual bool matchesIndeterminatePseudoClass() const;
441     virtual bool matchesDefaultPseudoClass() const;
442     WEBCORE_EXPORT ExceptionOr&lt;bool&gt; matches(const String&amp; selectors);
443     WEBCORE_EXPORT ExceptionOr&lt;Element*&gt; closest(const String&amp; selectors);
444     virtual bool shouldAppearIndeterminate() const;
445 
446     WEBCORE_EXPORT DOMTokenList&amp; classList();
447 
<a name="20" id="anc20"></a><span class="line-added">448     SpaceSplitString partNames() const;</span>
<span class="line-added">449     DOMTokenList&amp; part();</span>
<span class="line-added">450 </span>
451     DatasetDOMStringMap&amp; dataset();
452 
453 #if ENABLE(VIDEO)
454     virtual bool isMediaElement() const { return false; }
455 #endif
456 
457     virtual bool isFormControlElement() const { return false; }
458     virtual bool isSpinButtonElement() const { return false; }
459     virtual bool isTextFormControlElement() const { return false; }
460     virtual bool isTextField() const { return false; }
461     virtual bool isOptionalFormControl() const { return false; }
462     virtual bool isRequiredFormControl() const { return false; }
463     virtual bool isInRange() const { return false; }
464     virtual bool isOutOfRange() const { return false; }
465     virtual bool isUploadButton() const { return false; }
466     virtual bool isSliderContainerElement() const { return false; }
467 
468     bool canContainRangeEndPoint() const override;
469 
470     // Used for disabled form elements; if true, prevents mouse events from being dispatched
471     // to event listeners, and prevents DOMActivate events from being sent at all.
472     virtual bool isDisabledFormControl() const { return false; }
473 
474     virtual bool childShouldCreateRenderer(const Node&amp;) const;
475 
476     bool hasPendingResources() const;
477     void setHasPendingResources();
478     void clearHasPendingResources();
479     virtual void buildPendingResource() { };
480 
481     bool hasCSSAnimation() const;
482     void setHasCSSAnimation();
483     void clearHasCSSAnimation();
484 
<a name="21" id="anc21"></a><span class="line-added">485     KeyframeEffectStack* keyframeEffectStack() const;</span>
<span class="line-added">486     KeyframeEffectStack&amp; ensureKeyframeEffectStack();</span>
<span class="line-added">487     bool hasKeyframeEffects() const;</span>
<span class="line-added">488     OptionSet&lt;AnimationImpact&gt; applyKeyframeEffects(RenderStyle&amp;);</span>
<span class="line-added">489 </span>
490 #if ENABLE(FULLSCREEN_API)
491     WEBCORE_EXPORT bool containsFullScreenElement() const;
492     void setContainsFullScreenElement(bool);
493     void setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(bool);
494     WEBCORE_EXPORT virtual void webkitRequestFullscreen();
495 #endif
496 
497 #if ENABLE(POINTER_EVENTS)
498     ExceptionOr&lt;void&gt; setPointerCapture(int32_t);
499     ExceptionOr&lt;void&gt; releasePointerCapture(int32_t);
500     bool hasPointerCapture(int32_t);
501 #endif
502 
503 #if ENABLE(POINTER_LOCK)
504     WEBCORE_EXPORT void requestPointerLock();
505 #endif
506 
507     bool isSpellCheckingEnabled() const;
508 
509     bool hasID() const;
510     bool hasClass() const;
511     bool hasName() const;
512     const SpaceSplitString&amp; classNames() const;
513 
514     IntPoint savedLayerScrollPosition() const;
515     void setSavedLayerScrollPosition(const IntPoint&amp;);
516 
517     bool dispatchMouseEvent(const PlatformMouseEvent&amp;, const AtomString&amp; eventType, int clickCount = 0, Element* relatedTarget = nullptr);
518     bool dispatchWheelEvent(const PlatformWheelEvent&amp;);
519     bool dispatchKeyEvent(const PlatformKeyboardEvent&amp;);
520     void dispatchSimulatedClick(Event* underlyingEvent, SimulatedClickMouseEventOptions = SendNoEvents, SimulatedClickVisualOptions = ShowPressedLook);
521     void dispatchFocusInEvent(const AtomString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement);
522     void dispatchFocusOutEvent(const AtomString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement);
523     virtual void dispatchFocusEvent(RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement, FocusDirection);
524     virtual void dispatchBlurEvent(RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement);
525     void dispatchWebKitImageReadyEventForTesting();
526 
527     WEBCORE_EXPORT bool dispatchMouseForceWillBegin();
528 
529     virtual void willRecalcStyle(Style::Change);
530     virtual void didRecalcStyle(Style::Change);
531     virtual void willResetComputedStyle();
532     virtual void willAttachRenderers();
533     virtual void didAttachRenderers();
534     virtual void willDetachRenderers();
535     virtual void didDetachRenderers();
<a name="22" id="anc22"></a><span class="line-modified">536     virtual Optional&lt;Style::ElementStyle&gt; resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle* shadowHostStyle);</span>
537 
538     LayoutRect absoluteEventHandlerBounds(bool&amp; includesFixedPositionElements) override;
539 
540     const RenderStyle* existingComputedStyle() const;
541     WEBCORE_EXPORT const RenderStyle* renderOrDisplayContentsStyle() const;
542 
543     void setBeforePseudoElement(Ref&lt;PseudoElement&gt;&amp;&amp;);
544     void setAfterPseudoElement(Ref&lt;PseudoElement&gt;&amp;&amp;);
545     void clearBeforePseudoElement();
546     void clearAfterPseudoElement();
547     void resetComputedStyle();
548     void resetStyleRelations();
549     void clearHoverAndActiveStatusBeforeDetachingRenderer();
550 
551     WEBCORE_EXPORT URL absoluteLinkURL() const;
552 
553 #if ENABLE(TOUCH_EVENTS)
554     bool allowsDoubleTapGesture() const override;
555 #endif
556 
<a name="23" id="anc23"></a><span class="line-modified">557     Style::Resolver&amp; styleResolver();</span>
<span class="line-modified">558     Style::ElementStyle resolveStyle(const RenderStyle* parentStyle);</span>
559 
560     // Invalidates the style of a single element. Style is resolved lazily.
561     // Descendant elements are resolved as needed, for example if an inherited property changes.
562     // This should be called whenever an element changes in a manner that can affect its style.
563     void invalidateStyle();
564 
565     // As above but also call RenderElement::setStyle with StyleDifference::RecompositeLayer flag for
566     // the element even when the style doesn&#39;t change. This is mostly needed by the animation code.
567     WEBCORE_EXPORT void invalidateStyleAndLayerComposition();
568 
569     // Invalidate the element and all its descendants. This is used when there is some sort of change
570     // in the tree that may affect the style of any of the descendants and we don&#39;t know how to optimize
571     // the case to limit the scope. This is expensive and should be avoided.
572     void invalidateStyleForSubtree();
573 
574     // Invalidates renderers for the element and all its descendants causing them to be torn down
575     // and rebuild during style resolution. Style is also recomputed. This is used in code dealing with
576     // custom (not style based) renderers. This is expensive and should be avoided.
577     // Elements newly added to the tree are also in this state.
578     void invalidateStyleAndRenderersForSubtree();
579 
580     void invalidateStyleInternal();
581     void invalidateStyleForSubtreeInternal();
582 
583     bool hasDisplayContents() const;
584     void storeDisplayContentsStyle(std::unique_ptr&lt;RenderStyle&gt;);
585 
586     using ContainerNode::setAttributeEventListener;
587     void setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; value);
588 
589 #if ENABLE(INTERSECTION_OBSERVER)
590     IntersectionObserverData&amp; ensureIntersectionObserverData();
591     IntersectionObserverData* intersectionObserverData();
592 #endif
593 
594 #if ENABLE(RESIZE_OBSERVER)
595     ResizeObserverData&amp; ensureResizeObserverData();
596     ResizeObserverData* resizeObserverData();
597 #endif
598 
599     Element* findAnchorElementForLink(String&amp; outAnchorName);
600 
<a name="24" id="anc24"></a><span class="line-modified">601     ExceptionOr&lt;Ref&lt;WebAnimation&gt;&gt; animate(JSC::JSGlobalObject&amp;, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp;, Optional&lt;Variant&lt;double, KeyframeAnimationOptions&gt;&gt;&amp;&amp;);</span>
<span class="line-modified">602     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; getAnimations(Optional&lt;GetAnimationsOptions&gt;);</span>
603 
604     ElementIdentifier createElementIdentifier();
605 
606 protected:
607     Element(const QualifiedName&amp;, Document&amp;, ConstructionType);
608 
609     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
610     void removedFromAncestor(RemovalType, ContainerNode&amp;) override;
611     void childrenChanged(const ChildChange&amp;) override;
612     void removeAllEventListeners() final;
613     virtual void parserDidSetAttributes();
614 
615     void clearTabIndexExplicitlyIfNeeded();
616     void setTabIndexExplicitly(int);
617 
<a name="25" id="anc25"></a>


618     void classAttributeChanged(const AtomString&amp; newClassString);
<a name="26" id="anc26"></a><span class="line-added">619     void partAttributeChanged(const AtomString&amp; newValue);</span>
620 
621     void addShadowRoot(Ref&lt;ShadowRoot&gt;&amp;&amp;);
622 
623     static ExceptionOr&lt;void&gt; mergeWithNextTextNode(Text&amp;);
624 
625 #if ENABLE(CSS_TYPED_OM)
626     StylePropertyMap* attributeStyleMap();
627     void setAttributeStyleMap(Ref&lt;StylePropertyMap&gt;&amp;&amp;);
628 #endif
629 
630 private:
631     Frame* documentFrameWithNonNullView() const;
632 
633     bool isTextNode() const;
634 
635     bool isUserActionElementInActiveChain() const;
636     bool isUserActionElementActive() const;
637     bool isUserActionElementFocused() const;
638     bool isUserActionElementHovered() const;
639 
640     virtual void didAddUserAgentShadowRoot(ShadowRoot&amp;) { }
641 
642     void didAddAttribute(const QualifiedName&amp;, const AtomString&amp;);
643     void willModifyAttribute(const QualifiedName&amp;, const AtomString&amp; oldValue, const AtomString&amp; newValue);
644     void didModifyAttribute(const QualifiedName&amp;, const AtomString&amp; oldValue, const AtomString&amp; newValue);
645     void didRemoveAttribute(const QualifiedName&amp;, const AtomString&amp; oldValue);
646 
647     void synchronizeAttribute(const QualifiedName&amp;) const;
648     void synchronizeAttribute(const AtomString&amp; localName) const;
649 
650     void updateName(const AtomString&amp; oldName, const AtomString&amp; newName);
651     void updateNameForTreeScope(TreeScope&amp;, const AtomString&amp; oldName, const AtomString&amp; newName);
652     void updateNameForDocument(HTMLDocument&amp;, const AtomString&amp; oldName, const AtomString&amp; newName);
653 
654     enum class NotifyObservers { No, Yes };
655     void updateId(const AtomString&amp; oldId, const AtomString&amp; newId, NotifyObservers = NotifyObservers::Yes);
656     void updateIdForTreeScope(TreeScope&amp;, const AtomString&amp; oldId, const AtomString&amp; newId, NotifyObservers = NotifyObservers::Yes);
657 
658     enum HTMLDocumentNamedItemMapsUpdatingCondition { AlwaysUpdateHTMLDocumentNamedItemMaps, UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute };
659     void updateIdForDocument(HTMLDocument&amp;, const AtomString&amp; oldId, const AtomString&amp; newId, HTMLDocumentNamedItemMapsUpdatingCondition);
660     void updateLabel(TreeScope&amp;, const AtomString&amp; oldForAttributeValue, const AtomString&amp; newForAttributeValue);
661 
662     ExceptionOr&lt;Node*&gt; insertAdjacent(const String&amp; where, Ref&lt;Node&gt;&amp;&amp; newChild);
663 
664     void scrollByUnits(int units, ScrollGranularity);
665 
666     NodeType nodeType() const final;
667     bool childTypeAllowed(NodeType) const final;
668 
669     enum SynchronizationOfLazyAttribute { NotInSynchronizationOfLazyAttribute, InSynchronizationOfLazyAttribute };
670     void setAttributeInternal(unsigned index, const QualifiedName&amp;, const AtomString&amp; value, SynchronizationOfLazyAttribute);
671     void addAttributeInternal(const QualifiedName&amp;, const AtomString&amp; value, SynchronizationOfLazyAttribute);
672     void removeAttributeInternal(unsigned index, SynchronizationOfLazyAttribute);
673 
674     LayoutRect absoluteEventBounds(bool&amp; boundsIncludeAllDescendantElements, bool&amp; includesFixedPositionElements);
675     LayoutRect absoluteEventBoundsOfElementAndDescendants(bool&amp; includesFixedPositionElements);
676 
677 #if ENABLE(TREE_DEBUGGING)
678     void formatForDebugger(char* buffer, unsigned length) const override;
679 #endif
680 
681 #if ENABLE(INTERSECTION_OBSERVER)
682     void disconnectFromIntersectionObservers();
683 #endif
684 
685 #if ENABLE(RESIZE_OBSERVER)
686     void disconnectFromResizeObservers();
687 #endif
688 
689     // The cloneNode function is private so that non-virtual cloneElementWith/WithoutChildren are used instead.
690     Ref&lt;Node&gt; cloneNodeInternal(Document&amp;, CloningOperation) override;
691     virtual Ref&lt;Element&gt; cloneElementWithoutAttributesAndChildren(Document&amp;);
692 
693     void removeShadowRoot();
694 
695     const RenderStyle&amp; resolveComputedStyle();
696     const RenderStyle&amp; resolvePseudoElementStyle(PseudoId);
697 
698     unsigned rareDataChildIndex() const;
699 
<a name="27" id="anc27"></a>

700     void createUniqueElementData();
701 
702     ElementRareData* elementRareData() const;
703     ElementRareData&amp; ensureElementRareData();
704 
705     virtual int defaultTabIndex() const;
706 
707     void detachAllAttrNodesFromElement();
708     void detachAttrNodeFromElementWithValue(Attr*, const AtomString&amp; value);
709 
710     // Anyone thinking of using this should call document instead of ownerDocument.
711     void ownerDocument() const = delete;
712 
713     void attachAttributeNodeIfNeeded(Attr&amp;);
714 
<a name="28" id="anc28"></a><span class="line-added">715 #if ASSERT_ENABLED</span>
<span class="line-added">716     WEBCORE_EXPORT bool fastAttributeLookupAllowed(const QualifiedName&amp;) const;</span>
<span class="line-added">717 #endif</span>
<span class="line-added">718 </span>
719     QualifiedName m_tagName;
720     RefPtr&lt;ElementData&gt; m_elementData;
721 };
722 
723 inline bool Node::hasAttributes() const
724 {
725     return is&lt;Element&gt;(*this) &amp;&amp; downcast&lt;Element&gt;(*this).hasAttributes();
726 }
727 
728 inline NamedNodeMap* Node::attributes() const
729 {
730     return is&lt;Element&gt;(*this) ? &amp;downcast&lt;Element&gt;(*this).attributes() : nullptr;
731 }
732 
733 inline Element* Node::parentElement() const
734 {
735     ContainerNode* parent = parentNode();
736     return is&lt;Element&gt;(parent) ? downcast&lt;Element&gt;(parent) : nullptr;
737 }
738 
739 inline const Element* Element::rootElement() const
740 {
741     if (isConnected())
742         return document().documentElement();
743 
744     const Element* highest = this;
745     while (highest-&gt;parentElement())
746         highest = highest-&gt;parentElement();
747     return highest;
748 }
749 
750 inline bool Element::hasAttributeWithoutSynchronization(const QualifiedName&amp; name) const
751 {
752     ASSERT(fastAttributeLookupAllowed(name));
753     return elementData() &amp;&amp; findAttributeByName(name);
754 }
755 
756 inline const AtomString&amp; Element::attributeWithoutSynchronization(const QualifiedName&amp; name) const
757 {
758     if (elementData()) {
759         if (const Attribute* attribute = findAttributeByName(name))
760             return attribute-&gt;value();
761     }
762     return nullAtom();
763 }
764 
765 inline bool Element::hasAttributesWithoutUpdate() const
766 {
767     return elementData() &amp;&amp; !elementData()-&gt;isEmpty();
768 }
769 
770 inline const AtomString&amp; Element::idForStyleResolution() const
771 {
772     return hasID() ? elementData()-&gt;idForStyleResolution() : nullAtom();
773 }
774 
775 inline const AtomString&amp; Element::getIdAttribute() const
776 {
777     if (hasID())
778         return elementData()-&gt;findAttributeByName(HTMLNames::idAttr)-&gt;value();
779     return nullAtom();
780 }
781 
782 inline const AtomString&amp; Element::getNameAttribute() const
783 {
784     if (hasName())
785         return elementData()-&gt;findAttributeByName(HTMLNames::nameAttr)-&gt;value();
786     return nullAtom();
787 }
788 
789 inline void Element::setIdAttribute(const AtomString&amp; value)
790 {
791     setAttributeWithoutSynchronization(HTMLNames::idAttr, value);
792 }
793 
794 inline const SpaceSplitString&amp; Element::classNames() const
795 {
796     ASSERT(hasClass());
797     ASSERT(elementData());
798     return elementData()-&gt;classNames();
799 }
800 
801 inline unsigned Element::attributeCount() const
802 {
803     ASSERT(elementData());
804     return elementData()-&gt;length();
805 }
806 
807 inline const Attribute&amp; Element::attributeAt(unsigned index) const
808 {
809     ASSERT(elementData());
810     return elementData()-&gt;attributeAt(index);
811 }
812 
813 inline const Attribute* Element::findAttributeByName(const QualifiedName&amp; name) const
814 {
815     ASSERT(elementData());
816     return elementData()-&gt;findAttributeByName(name);
817 }
818 
819 inline bool Element::hasID() const
820 {
821     return elementData() &amp;&amp; elementData()-&gt;hasID();
822 }
823 
824 inline bool Element::hasClass() const
825 {
826     return elementData() &amp;&amp; elementData()-&gt;hasClass();
827 }
828 
829 inline bool Element::hasName() const
830 {
831     return elementData() &amp;&amp; elementData()-&gt;hasName();
832 }
833 
834 inline UniqueElementData&amp; Element::ensureUniqueElementData()
835 {
836     if (!elementData() || !elementData()-&gt;isUnique())
837         createUniqueElementData();
838     return static_cast&lt;UniqueElementData&amp;&gt;(*m_elementData);
839 }
840 
841 inline bool shouldIgnoreAttributeCase(const Element&amp; element)
842 {
843     return element.isHTMLElement() &amp;&amp; element.document().isHTMLDocument();
844 }
845 
846 inline void Element::setHasFocusWithin(bool flag)
847 {
848     if (hasFocusWithin() == flag)
849         return;
850     setFlag(flag, HasFocusWithin);
851     if (styleAffectedByFocusWithin())
852         invalidateStyleForSubtree();
853 }
854 
855 template&lt;typename... QualifiedNames&gt;
856 inline const AtomString&amp; Element::getAttribute(const QualifiedName&amp; name, const QualifiedNames&amp;... names) const
857 {
858     const AtomString&amp; value = getAttribute(name);
859     if (!value.isNull())
860         return value;
861     return getAttribute(names...);
862 }
863 
864 } // namespace WebCore
865 
866 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::Element)
867     static bool isType(const WebCore::Node&amp; node) { return node.isElementNode(); }
868     static bool isType(const WebCore::EventTarget&amp; target) { return is&lt;WebCore::Node&gt;(target) &amp;&amp; isType(downcast&lt;WebCore::Node&gt;(target)); }
869 SPECIALIZE_TYPE_TRAITS_END()
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>
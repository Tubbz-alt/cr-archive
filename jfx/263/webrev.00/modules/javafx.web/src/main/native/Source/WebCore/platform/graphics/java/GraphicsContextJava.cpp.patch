diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/java/GraphicsContextJava.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/java/GraphicsContextJava.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/java/GraphicsContextJava.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/java/GraphicsContextJava.cpp
@@ -108,11 +108,11 @@
     << (jint)0 //is not proportional
     << (jint)gradient.spreadMethod()
     << (jint)nStops;
 
     for (const auto& cs : stops) {
-        int rgba = (int)cs.color.rgb();
+        int rgba = (int)cs.color.rgb().value();
         context->rq()
         << (jint)rgba << (jfloat)cs.offset;
     }
 }
 
@@ -204,11 +204,11 @@
 
     platformContext()->rq().freeSpace(24)
     << (jint)com_sun_webkit_graphics_GraphicsDecoder_FILLRECT_FFFFI
     << rect.x() << rect.y()
     << rect.width() << rect.height()
-    << (jint)color.rgb();
+    << (jint)color.rgb().value();
 }
 
 void GraphicsContext::fillRect(const FloatRect& rect)
 {
     if (paintingDisabled())
@@ -226,11 +226,11 @@
             destRect,
             FloatRect(0., 0., img.width(), img.height()),
             m_state.fillPattern->getPatternSpaceTransform(),
             FloatPoint(),
             FloatSize(),
-            CompositeCopy);
+            CompositeOperator::Copy);
     } else {
         if (m_state.fillGradient) {
             setGradient(
                 *m_state.fillGradient,
                 platformContext(),
@@ -314,11 +314,11 @@
     for (size_t i = 0; i < toDraw.size(); i++) {
         IntRect focusRect = toDraw[i];
         platformContext()->rq() << (jint)com_sun_webkit_graphics_GraphicsDecoder_DRAWFOCUSRING
         << (jint)focusRect.x() << (jint)focusRect.y()
         << (jint)focusRect.width() << (jint)focusRect.height()
-        << (jint)color.rgb();
+        << (jint)color.rgb().value();
     }
 }
 
 void GraphicsContext::drawLinesForText(const FloatPoint& origin, float thickness, const DashArray& widths, bool, bool, StrokeStyle stroke) {
 
@@ -472,11 +472,11 @@
     if (paintingDisabled())
         return;
 
     platformContext()->rq().freeSpace(8)
     << (jint)com_sun_webkit_graphics_GraphicsDecoder_SETFILLCOLOR
-    << (jint)col.rgb();
+    << (jint)col.rgb().value();
 }
 
 void GraphicsContext::setPlatformTextDrawingMode(TextDrawingModeFlags mode)
 {
     if (paintingDisabled())
@@ -506,11 +506,11 @@
     if (paintingDisabled())
         return;
 
     platformContext()->rq().freeSpace(8)
     << (jint)com_sun_webkit_graphics_GraphicsDecoder_SETSTROKECOLOR
-    << (jint)col.rgb();
+    << (jint)col.rgb().value();
 }
 
 void GraphicsContext::setPlatformStrokeThickness(float strokeThickness)
 {
     if (paintingDisabled())
@@ -573,11 +573,11 @@
         height = -height;
     }
 
     platformContext()->rq().freeSpace(20)
     << (jint)com_sun_webkit_graphics_GraphicsDecoder_SETSHADOW
-    << width << height << blur << (jint)color.rgb();
+    << width << height << blur << (jint)color.rgb().value();
 }
 
 void GraphicsContext::clearPlatformShadow()
 {
     setPlatformShadow(FloatSize(0, 0), 0, Color());
@@ -831,11 +831,11 @@
             destRect,
             FloatRect(0., 0., img.width(), img.height()),
             m_state.fillPattern->getPatternSpaceTransform(),
             FloatPoint(),
             FloatSize(),
-            CompositeCopy);
+            CompositeOperator::Copy);
         restorePlatformState();
     } else {
         if (m_state.fillGradient) {
             setGradient(
                 *m_state.fillGradient,
@@ -884,11 +884,11 @@
     << (jfloat)rect.rect().width() << (jfloat)rect.rect().height()
     << (jfloat)rect.radii().topLeft().width() << (jfloat)rect.radii().topLeft().height()
     << (jfloat)rect.radii().topRight().width() << (jfloat)rect.radii().topRight().height()
     << (jfloat)rect.radii().bottomLeft().width() << (jfloat)rect.radii().bottomLeft().height()
     << (jfloat)rect.radii().bottomRight().width() << (jfloat)rect.radii().bottomRight().height()
-    << (jint)color.rgb();
+    << (jint)color.rgb().value();
 }
 
 void GraphicsContext::fillRectWithRoundedHole(const FloatRect& frect, const FloatRoundedRect& roundedHoleRect, const Color& color)
 {
     if (paintingDisabled())

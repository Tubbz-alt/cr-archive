<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBOpenDBRequest.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IDBObjectStore.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBOpenDBRequest.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBOpenDBRequest.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 49 Ref&lt;IDBOpenDBRequest&gt; IDBOpenDBRequest::createDeleteRequest(ScriptExecutionContext&amp; context, IDBClient::IDBConnectionProxy&amp; connectionProxy, const IDBDatabaseIdentifier&amp; databaseIdentifier)
 50 {
 51     return adoptRef(*new IDBOpenDBRequest(context, connectionProxy, databaseIdentifier, 0, IndexedDB::RequestType::Delete));
 52 }
 53 
 54 Ref&lt;IDBOpenDBRequest&gt; IDBOpenDBRequest::createOpenRequest(ScriptExecutionContext&amp; context, IDBClient::IDBConnectionProxy&amp; connectionProxy, const IDBDatabaseIdentifier&amp; databaseIdentifier, uint64_t version)
 55 {
 56     return adoptRef(*new IDBOpenDBRequest(context, connectionProxy, databaseIdentifier, version, IndexedDB::RequestType::Open));
 57 }
 58 
 59 IDBOpenDBRequest::IDBOpenDBRequest(ScriptExecutionContext&amp; context, IDBClient::IDBConnectionProxy&amp; connectionProxy, const IDBDatabaseIdentifier&amp; databaseIdentifier, uint64_t version, IndexedDB::RequestType requestType)
 60     : IDBRequest(context, connectionProxy)
 61     , m_databaseIdentifier(databaseIdentifier)
 62     , m_version(version)
 63 {
 64     m_requestType = requestType;
 65 }
 66 
 67 IDBOpenDBRequest::~IDBOpenDBRequest()
 68 {
<span class="line-modified"> 69     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
 70 }
 71 
 72 void IDBOpenDBRequest::onError(const IDBResultData&amp; data)
 73 {
<span class="line-modified"> 74     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
 75 
 76     m_domError = data.error().toDOMException();
 77     enqueueEvent(IDBRequestCompletionEvent::create(eventNames().errorEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes, *this));
 78 }
 79 
 80 void IDBOpenDBRequest::versionChangeTransactionDidFinish()
 81 {
<span class="line-modified"> 82     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
 83 
 84     // 3.3.7 &quot;versionchange&quot; transaction steps
 85     // When the transaction is finished, after firing complete/abort on the transaction, immediately set request&#39;s transaction property to null.
 86     m_shouldExposeTransactionToDOM = false;
 87 }
 88 
 89 void IDBOpenDBRequest::fireSuccessAfterVersionChangeCommit()
 90 {
 91     LOG(IndexedDB, &quot;IDBOpenDBRequest::fireSuccessAfterVersionChangeCommit() - %s&quot;, resourceIdentifier().loggingString().utf8().data());
 92 
<span class="line-modified"> 93     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
 94     ASSERT(hasPendingActivity());
 95     m_transaction-&gt;addRequest(*this);
 96 
 97     auto event = IDBRequestCompletionEvent::create(eventNames().successEvent, Event::CanBubble::No, Event::IsCancelable::No, *this);
 98     m_openDatabaseSuccessEvent = &amp;event.get();
 99 
100     enqueueEvent(WTFMove(event));
101 }
102 
103 void IDBOpenDBRequest::fireErrorAfterVersionChangeCompletion()
104 {
105     LOG(IndexedDB, &quot;IDBOpenDBRequest::fireErrorAfterVersionChangeCompletion() - %s&quot;, resourceIdentifier().loggingString().utf8().data());
106 
<span class="line-modified">107     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
108     ASSERT(hasPendingActivity());
109 
110     IDBError idbError(AbortError);
111     m_domError = DOMException::create(AbortError);
112     setResultToUndefined();
113 
114     m_transaction-&gt;addRequest(*this);
115     enqueueEvent(IDBRequestCompletionEvent::create(eventNames().errorEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes, *this));
116 }
117 
118 void IDBOpenDBRequest::cancelForStop()
119 {
120     connectionProxy().openDBRequestCancelled({ connectionProxy(), *this });
<span class="line-removed">121 </span>
<span class="line-removed">122     if (m_transaction &amp;&amp; m_transaction-&gt;isVersionChange())</span>
<span class="line-removed">123         m_transaction-&gt;removeRequest(*this);</span>
124 }
125 
126 void IDBOpenDBRequest::dispatchEvent(Event&amp; event)
127 {
<span class="line-modified">128     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
129 
130     auto protectedThis = makeRef(*this);
131 
132     IDBRequest::dispatchEvent(event);
133 
134     if (m_transaction &amp;&amp; m_transaction-&gt;isVersionChange() &amp;&amp; (event.type() == eventNames().errorEvent || event.type() == eventNames().successEvent))
135         m_transaction-&gt;database().connectionProxy().didFinishHandlingVersionChangeTransaction(m_transaction-&gt;database().databaseConnectionIdentifier(), *m_transaction);
136 }
137 
138 void IDBOpenDBRequest::onSuccess(const IDBResultData&amp; resultData)
139 {
140     LOG(IndexedDB, &quot;IDBOpenDBRequest::onSuccess()&quot;);
141 
<span class="line-modified">142     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
143 
144     setResult(IDBDatabase::create(*scriptExecutionContext(), connectionProxy(), resultData));
145     m_readyState = ReadyState::Done;
146 
147     enqueueEvent(IDBRequestCompletionEvent::create(eventNames().successEvent, Event::CanBubble::No, Event::IsCancelable::No, *this));
148 }
149 
150 void IDBOpenDBRequest::onUpgradeNeeded(const IDBResultData&amp; resultData)
151 {
<span class="line-modified">152     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
153 
154     Ref&lt;IDBDatabase&gt; database = IDBDatabase::create(*scriptExecutionContext(), connectionProxy(), resultData);
155     Ref&lt;IDBTransaction&gt; transaction = database-&gt;startVersionChangeTransaction(resultData.transactionInfo(), *this);
156 
157     ASSERT(transaction-&gt;info().mode() == IDBTransactionMode::Versionchange);
158     ASSERT(transaction-&gt;originalDatabaseInfo());
159 
160     uint64_t oldVersion = transaction-&gt;originalDatabaseInfo()-&gt;version();
161     uint64_t newVersion = transaction-&gt;info().newVersion();
162 
163     LOG(IndexedDB, &quot;IDBOpenDBRequest::onUpgradeNeeded() - current version is %&quot; PRIu64 &quot;, new is %&quot; PRIu64, oldVersion, newVersion);
164 
165     setResult(WTFMove(database));
166     m_readyState = ReadyState::Done;
167     m_transaction = WTFMove(transaction);
168     m_transaction-&gt;addRequest(*this);
169 
170     enqueueEvent(IDBVersionChangeEvent::create(oldVersion, newVersion, eventNames().upgradeneededEvent));
171 }
172 
173 void IDBOpenDBRequest::onDeleteDatabaseSuccess(const IDBResultData&amp; resultData)
174 {
<span class="line-modified">175     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
176 
177     uint64_t oldVersion = resultData.databaseInfo().version();
178 
179     LOG(IndexedDB, &quot;IDBOpenDBRequest::onDeleteDatabaseSuccess() - current version is %&quot; PRIu64, oldVersion);
180 
181     m_readyState = ReadyState::Done;
182     setResultToUndefined();
183 
184     enqueueEvent(IDBVersionChangeEvent::create(oldVersion, 0, eventNames().successEvent));
185 }
186 
187 void IDBOpenDBRequest::requestCompleted(const IDBResultData&amp; data)
188 {
189     LOG(IndexedDB, &quot;IDBOpenDBRequest::requestCompleted&quot;);
190 
<span class="line-modified">191     ASSERT(&amp;originThread() == &amp;Thread::current());</span>


192 
193     // If an Open request was completed after the page has navigated, leaving this request
194     // with a stopped script execution context, we need to message back to the server so it
195     // doesn&#39;t hang waiting on a database connection or transaction that will never exist.
196     if (m_contextStopped) {
197         switch (data.type()) {
198         case IDBResultType::OpenDatabaseSuccess:
199             connectionProxy().abortOpenAndUpgradeNeeded(data.databaseConnectionIdentifier(), IDBResourceIdentifier::emptyValue());
200             break;
201         case IDBResultType::OpenDatabaseUpgradeNeeded:
202             connectionProxy().abortOpenAndUpgradeNeeded(data.databaseConnectionIdentifier(), data.transactionInfo().identifier());
203             break;
204         default:
205             break;
206         }
207 
208         return;
209     }
210 
211     switch (data.type()) {
212     case IDBResultType::Error:
213         onError(data);
214         break;
215     case IDBResultType::OpenDatabaseSuccess:
216         onSuccess(data);
217         break;
218     case IDBResultType::OpenDatabaseUpgradeNeeded:
219         onUpgradeNeeded(data);
220         break;
221     case IDBResultType::DeleteDatabaseSuccess:
222         onDeleteDatabaseSuccess(data);
223         break;
224     default:
225         RELEASE_ASSERT_NOT_REACHED();
226     }
227 }
228 
229 void IDBOpenDBRequest::requestBlocked(uint64_t oldVersion, uint64_t newVersion)
230 {
<span class="line-modified">231     ASSERT(&amp;originThread() == &amp;Thread::current());</span>



232 
233     LOG(IndexedDB, &quot;IDBOpenDBRequest::requestBlocked&quot;);
234     enqueueEvent(IDBVersionChangeEvent::create(oldVersion, newVersion, eventNames().blockedEvent));
235 }
236 














237 } // namespace WebCore
238 
239 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
<td>
<hr />
<pre>
 49 Ref&lt;IDBOpenDBRequest&gt; IDBOpenDBRequest::createDeleteRequest(ScriptExecutionContext&amp; context, IDBClient::IDBConnectionProxy&amp; connectionProxy, const IDBDatabaseIdentifier&amp; databaseIdentifier)
 50 {
 51     return adoptRef(*new IDBOpenDBRequest(context, connectionProxy, databaseIdentifier, 0, IndexedDB::RequestType::Delete));
 52 }
 53 
 54 Ref&lt;IDBOpenDBRequest&gt; IDBOpenDBRequest::createOpenRequest(ScriptExecutionContext&amp; context, IDBClient::IDBConnectionProxy&amp; connectionProxy, const IDBDatabaseIdentifier&amp; databaseIdentifier, uint64_t version)
 55 {
 56     return adoptRef(*new IDBOpenDBRequest(context, connectionProxy, databaseIdentifier, version, IndexedDB::RequestType::Open));
 57 }
 58 
 59 IDBOpenDBRequest::IDBOpenDBRequest(ScriptExecutionContext&amp; context, IDBClient::IDBConnectionProxy&amp; connectionProxy, const IDBDatabaseIdentifier&amp; databaseIdentifier, uint64_t version, IndexedDB::RequestType requestType)
 60     : IDBRequest(context, connectionProxy)
 61     , m_databaseIdentifier(databaseIdentifier)
 62     , m_version(version)
 63 {
 64     m_requestType = requestType;
 65 }
 66 
 67 IDBOpenDBRequest::~IDBOpenDBRequest()
 68 {
<span class="line-modified"> 69     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
 70 }
 71 
 72 void IDBOpenDBRequest::onError(const IDBResultData&amp; data)
 73 {
<span class="line-modified"> 74     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
 75 
 76     m_domError = data.error().toDOMException();
 77     enqueueEvent(IDBRequestCompletionEvent::create(eventNames().errorEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes, *this));
 78 }
 79 
 80 void IDBOpenDBRequest::versionChangeTransactionDidFinish()
 81 {
<span class="line-modified"> 82     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
 83 
 84     // 3.3.7 &quot;versionchange&quot; transaction steps
 85     // When the transaction is finished, after firing complete/abort on the transaction, immediately set request&#39;s transaction property to null.
 86     m_shouldExposeTransactionToDOM = false;
 87 }
 88 
 89 void IDBOpenDBRequest::fireSuccessAfterVersionChangeCommit()
 90 {
 91     LOG(IndexedDB, &quot;IDBOpenDBRequest::fireSuccessAfterVersionChangeCommit() - %s&quot;, resourceIdentifier().loggingString().utf8().data());
 92 
<span class="line-modified"> 93     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
 94     ASSERT(hasPendingActivity());
 95     m_transaction-&gt;addRequest(*this);
 96 
 97     auto event = IDBRequestCompletionEvent::create(eventNames().successEvent, Event::CanBubble::No, Event::IsCancelable::No, *this);
 98     m_openDatabaseSuccessEvent = &amp;event.get();
 99 
100     enqueueEvent(WTFMove(event));
101 }
102 
103 void IDBOpenDBRequest::fireErrorAfterVersionChangeCompletion()
104 {
105     LOG(IndexedDB, &quot;IDBOpenDBRequest::fireErrorAfterVersionChangeCompletion() - %s&quot;, resourceIdentifier().loggingString().utf8().data());
106 
<span class="line-modified">107     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
108     ASSERT(hasPendingActivity());
109 
110     IDBError idbError(AbortError);
111     m_domError = DOMException::create(AbortError);
112     setResultToUndefined();
113 
114     m_transaction-&gt;addRequest(*this);
115     enqueueEvent(IDBRequestCompletionEvent::create(eventNames().errorEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes, *this));
116 }
117 
118 void IDBOpenDBRequest::cancelForStop()
119 {
120     connectionProxy().openDBRequestCancelled({ connectionProxy(), *this });



121 }
122 
123 void IDBOpenDBRequest::dispatchEvent(Event&amp; event)
124 {
<span class="line-modified">125     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
126 
127     auto protectedThis = makeRef(*this);
128 
129     IDBRequest::dispatchEvent(event);
130 
131     if (m_transaction &amp;&amp; m_transaction-&gt;isVersionChange() &amp;&amp; (event.type() == eventNames().errorEvent || event.type() == eventNames().successEvent))
132         m_transaction-&gt;database().connectionProxy().didFinishHandlingVersionChangeTransaction(m_transaction-&gt;database().databaseConnectionIdentifier(), *m_transaction);
133 }
134 
135 void IDBOpenDBRequest::onSuccess(const IDBResultData&amp; resultData)
136 {
137     LOG(IndexedDB, &quot;IDBOpenDBRequest::onSuccess()&quot;);
138 
<span class="line-modified">139     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
140 
141     setResult(IDBDatabase::create(*scriptExecutionContext(), connectionProxy(), resultData));
142     m_readyState = ReadyState::Done;
143 
144     enqueueEvent(IDBRequestCompletionEvent::create(eventNames().successEvent, Event::CanBubble::No, Event::IsCancelable::No, *this));
145 }
146 
147 void IDBOpenDBRequest::onUpgradeNeeded(const IDBResultData&amp; resultData)
148 {
<span class="line-modified">149     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
150 
151     Ref&lt;IDBDatabase&gt; database = IDBDatabase::create(*scriptExecutionContext(), connectionProxy(), resultData);
152     Ref&lt;IDBTransaction&gt; transaction = database-&gt;startVersionChangeTransaction(resultData.transactionInfo(), *this);
153 
154     ASSERT(transaction-&gt;info().mode() == IDBTransactionMode::Versionchange);
155     ASSERT(transaction-&gt;originalDatabaseInfo());
156 
157     uint64_t oldVersion = transaction-&gt;originalDatabaseInfo()-&gt;version();
158     uint64_t newVersion = transaction-&gt;info().newVersion();
159 
160     LOG(IndexedDB, &quot;IDBOpenDBRequest::onUpgradeNeeded() - current version is %&quot; PRIu64 &quot;, new is %&quot; PRIu64, oldVersion, newVersion);
161 
162     setResult(WTFMove(database));
163     m_readyState = ReadyState::Done;
164     m_transaction = WTFMove(transaction);
165     m_transaction-&gt;addRequest(*this);
166 
167     enqueueEvent(IDBVersionChangeEvent::create(oldVersion, newVersion, eventNames().upgradeneededEvent));
168 }
169 
170 void IDBOpenDBRequest::onDeleteDatabaseSuccess(const IDBResultData&amp; resultData)
171 {
<span class="line-modified">172     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
173 
174     uint64_t oldVersion = resultData.databaseInfo().version();
175 
176     LOG(IndexedDB, &quot;IDBOpenDBRequest::onDeleteDatabaseSuccess() - current version is %&quot; PRIu64, oldVersion);
177 
178     m_readyState = ReadyState::Done;
179     setResultToUndefined();
180 
181     enqueueEvent(IDBVersionChangeEvent::create(oldVersion, 0, eventNames().successEvent));
182 }
183 
184 void IDBOpenDBRequest::requestCompleted(const IDBResultData&amp; data)
185 {
186     LOG(IndexedDB, &quot;IDBOpenDBRequest::requestCompleted&quot;);
187 
<span class="line-modified">188     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
<span class="line-added">189 </span>
<span class="line-added">190     m_isBlocked = false;</span>
191 
192     // If an Open request was completed after the page has navigated, leaving this request
193     // with a stopped script execution context, we need to message back to the server so it
194     // doesn&#39;t hang waiting on a database connection or transaction that will never exist.
195     if (m_contextStopped) {
196         switch (data.type()) {
197         case IDBResultType::OpenDatabaseSuccess:
198             connectionProxy().abortOpenAndUpgradeNeeded(data.databaseConnectionIdentifier(), IDBResourceIdentifier::emptyValue());
199             break;
200         case IDBResultType::OpenDatabaseUpgradeNeeded:
201             connectionProxy().abortOpenAndUpgradeNeeded(data.databaseConnectionIdentifier(), data.transactionInfo().identifier());
202             break;
203         default:
204             break;
205         }
206 
207         return;
208     }
209 
210     switch (data.type()) {
211     case IDBResultType::Error:
212         onError(data);
213         break;
214     case IDBResultType::OpenDatabaseSuccess:
215         onSuccess(data);
216         break;
217     case IDBResultType::OpenDatabaseUpgradeNeeded:
218         onUpgradeNeeded(data);
219         break;
220     case IDBResultType::DeleteDatabaseSuccess:
221         onDeleteDatabaseSuccess(data);
222         break;
223     default:
224         RELEASE_ASSERT_NOT_REACHED();
225     }
226 }
227 
228 void IDBOpenDBRequest::requestBlocked(uint64_t oldVersion, uint64_t newVersion)
229 {
<span class="line-modified">230     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
<span class="line-added">231     ASSERT(!m_isBlocked);</span>
<span class="line-added">232 </span>
<span class="line-added">233     m_isBlocked = true;</span>
234 
235     LOG(IndexedDB, &quot;IDBOpenDBRequest::requestBlocked&quot;);
236     enqueueEvent(IDBVersionChangeEvent::create(oldVersion, newVersion, eventNames().blockedEvent));
237 }
238 
<span class="line-added">239 void IDBOpenDBRequest::setIsContextSuspended(bool isContextSuspended)</span>
<span class="line-added">240 {</span>
<span class="line-added">241     m_isContextSuspended = isContextSuspended;</span>
<span class="line-added">242 </span>
<span class="line-added">243     // If this request is blocked, it means this request is being processed on the server.</span>
<span class="line-added">244     // The client needs to actively stop the request so it doesn&#39;t blocks the processing of subsequent requests.</span>
<span class="line-added">245     if (m_isBlocked) {</span>
<span class="line-added">246         IDBRequestData requestData(connectionProxy(), *this);</span>
<span class="line-added">247         connectionProxy().openDBRequestCancelled(requestData);</span>
<span class="line-added">248         auto result = IDBResultData::error(requestData.requestIdentifier(), IDBError { UnknownError, &quot;Blocked open request on cached page is aborted to unblock other requests&quot;_s });</span>
<span class="line-added">249         requestCompleted(result);</span>
<span class="line-added">250     }</span>
<span class="line-added">251 }</span>
<span class="line-added">252 </span>
253 } // namespace WebCore
254 
255 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
</tr>
</table>
<center><a href="IDBObjectStore.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBOpenDBRequest.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
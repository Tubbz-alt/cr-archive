<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasource/SourceBuffer.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SourceBuffer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SourceBufferList.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasource/SourceBuffer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 62     , private SourceBufferPrivateClient
 63     , private AudioTrackClient
 64     , private VideoTrackClient
 65     , private TextTrackClient
 66 #if !RELEASE_LOG_DISABLED
 67     , private LoggerHelper
 68 #endif
 69 {
 70     WTF_MAKE_ISO_ALLOCATED(SourceBuffer);
 71 public:
 72     static Ref&lt;SourceBuffer&gt; create(Ref&lt;SourceBufferPrivate&gt;&amp;&amp;, MediaSource*);
 73     virtual ~SourceBuffer();
 74 
 75     bool updating() const { return m_updating; }
 76     ExceptionOr&lt;Ref&lt;TimeRanges&gt;&gt; buffered() const;
 77     double timestampOffset() const;
 78     ExceptionOr&lt;void&gt; setTimestampOffset(double);
 79 
 80 #if ENABLE(VIDEO_TRACK)
 81     VideoTrackList&amp; videoTracks();

 82     AudioTrackList&amp; audioTracks();

 83     TextTrackList&amp; textTracks();

 84 #endif
 85 
 86     double appendWindowStart() const;
 87     ExceptionOr&lt;void&gt; setAppendWindowStart(double);
 88     double appendWindowEnd() const;
 89     ExceptionOr&lt;void&gt; setAppendWindowEnd(double);
 90 
 91     ExceptionOr&lt;void&gt; appendBuffer(const BufferSource&amp;);
 92     ExceptionOr&lt;void&gt; abort();
 93     ExceptionOr&lt;void&gt; remove(double start, double end);
 94     ExceptionOr&lt;void&gt; remove(const MediaTime&amp;, const MediaTime&amp;);
 95     ExceptionOr&lt;void&gt; changeType(const String&amp;);
 96 
 97     const TimeRanges&amp; bufferedInternal() const { ASSERT(m_buffered); return *m_buffered; }
 98 
 99     void abortIfUpdating();
100     void removedFromMediaSource();
101     void seekToTime(const MediaTime&amp;);
102 
103     bool canPlayThroughRange(PlatformTimeRanges&amp;);
</pre>
<hr />
<pre>
127     MediaTime highestPresentationTimestamp() const;
128     void readyStateChanged();
129 
130     bool hasPendingActivity() const final;
131 
132     void trySignalAllSamplesEnqueued();
133 
134 #if !RELEASE_LOG_DISABLED
135     const Logger&amp; logger() const final { return m_logger.get(); }
136     const void* logIdentifier() const final { return m_logIdentifier; }
137     const char* logClassName() const final { return &quot;SourceBuffer&quot;; }
138     WTFLogChannel&amp; logChannel() const final;
139 #endif
140 
141 private:
142     SourceBuffer(Ref&lt;SourceBufferPrivate&gt;&amp;&amp;, MediaSource*);
143 
144     void refEventTarget() final { ref(); }
145     void derefEventTarget() final { deref(); }
146 
<span class="line-removed">147     void suspend(ReasonForSuspension) final;</span>
<span class="line-removed">148     void resume() final;</span>
149     void stop() final;
150     const char* activeDOMObjectName() const final;
<span class="line-removed">151     bool canSuspendForDocumentSuspension() const final;</span>
152 
153     void sourceBufferPrivateDidReceiveInitializationSegment(const InitializationSegment&amp;) final;
154     void sourceBufferPrivateDidReceiveSample(MediaSample&amp;) final;
155     bool sourceBufferPrivateHasAudio() const final;
156     bool sourceBufferPrivateHasVideo() const final;
157     void sourceBufferPrivateReenqueSamples(const AtomString&amp; trackID) final;
158     void sourceBufferPrivateDidBecomeReadyForMoreSamples(const AtomString&amp; trackID) final;
159     MediaTime sourceBufferPrivateFastSeekTimeForMediaTime(const MediaTime&amp;, const MediaTime&amp; negativeThreshold, const MediaTime&amp; positiveThreshold) final;
160     void sourceBufferPrivateAppendComplete(AppendResult) final;
161     void sourceBufferPrivateDidReceiveRenderingError(int errorCode) final;
162 
163     void audioTrackEnabledChanged(AudioTrack&amp;) final;
164     void videoTrackSelectedChanged(VideoTrack&amp;) final;
165 
166     void textTrackKindChanged(TextTrack&amp;) final;
167     void textTrackModeChanged(TextTrack&amp;) final;
168     void textTrackAddCues(TextTrack&amp;, const TextTrackCueList&amp;) final;
169     void textTrackRemoveCues(TextTrack&amp;, const TextTrackCueList&amp;) final;
170     void textTrackAddCue(TextTrack&amp;, TextTrackCue&amp;) final;
171     void textTrackRemoveCue(TextTrack&amp;, TextTrackCue&amp;) final;
</pre>
<hr />
<pre>
200     void updateBufferedFromTrackBuffers();
201     void updateMinimumUpcomingPresentationTime(TrackBuffer&amp;, const AtomString&amp; trackID);
202     void resetMinimumUpcomingPresentationTime(TrackBuffer&amp;, const AtomString&amp; trackID);
203 
204     void appendError(bool);
205 
206     bool hasAudio() const;
207 
208     void rangeRemoval(const MediaTime&amp;, const MediaTime&amp;);
209 
210     void trySignalAllSamplesInTrackEnqueued(const AtomString&amp;);
211 
212     friend class Internals;
213     WEBCORE_EXPORT Vector&lt;String&gt; bufferedSamplesForTrackID(const AtomString&amp;);
214     WEBCORE_EXPORT Vector&lt;String&gt; enqueuedSamplesForTrackID(const AtomString&amp;);
215     WEBCORE_EXPORT MediaTime minimumUpcomingPresentationTimeForTrackID(const AtomString&amp;);
216     WEBCORE_EXPORT void setMaximumQueueDepthForTrackID(const AtomString&amp;, size_t);
217 
218     Ref&lt;SourceBufferPrivate&gt; m_private;
219     MediaSource* m_source;
<span class="line-modified">220     GenericEventQueue m_asyncEventQueue;</span>
221     AppendMode m_mode { AppendMode::Segments };
222 
223     Vector&lt;unsigned char&gt; m_pendingAppendData;
224     Timer m_appendBufferTimer;
225 
226     RefPtr&lt;VideoTrackList&gt; m_videoTracks;
227     RefPtr&lt;AudioTrackList&gt; m_audioTracks;
228     RefPtr&lt;TextTrackList&gt; m_textTracks;
229 
230     Vector&lt;AtomString&gt; m_videoCodecs;
231     Vector&lt;AtomString&gt; m_audioCodecs;
232     Vector&lt;AtomString&gt; m_textCodecs;
233 
234     MediaTime m_timestampOffset;
235     MediaTime m_appendWindowStart;
236     MediaTime m_appendWindowEnd;
237 
238     MediaTime m_groupStartTimestamp;
239     MediaTime m_groupEndTimestamp;
240 
</pre>
</td>
<td>
<hr />
<pre>
 62     , private SourceBufferPrivateClient
 63     , private AudioTrackClient
 64     , private VideoTrackClient
 65     , private TextTrackClient
 66 #if !RELEASE_LOG_DISABLED
 67     , private LoggerHelper
 68 #endif
 69 {
 70     WTF_MAKE_ISO_ALLOCATED(SourceBuffer);
 71 public:
 72     static Ref&lt;SourceBuffer&gt; create(Ref&lt;SourceBufferPrivate&gt;&amp;&amp;, MediaSource*);
 73     virtual ~SourceBuffer();
 74 
 75     bool updating() const { return m_updating; }
 76     ExceptionOr&lt;Ref&lt;TimeRanges&gt;&gt; buffered() const;
 77     double timestampOffset() const;
 78     ExceptionOr&lt;void&gt; setTimestampOffset(double);
 79 
 80 #if ENABLE(VIDEO_TRACK)
 81     VideoTrackList&amp; videoTracks();
<span class="line-added"> 82     VideoTrackList* videoTracksIfExists() const { return m_videoTracks.get(); }</span>
 83     AudioTrackList&amp; audioTracks();
<span class="line-added"> 84     AudioTrackList* audioTracksIfExists() const { return m_audioTracks.get(); }</span>
 85     TextTrackList&amp; textTracks();
<span class="line-added"> 86     TextTrackList* textTracksIfExists() const { return m_textTracks.get(); }</span>
 87 #endif
 88 
 89     double appendWindowStart() const;
 90     ExceptionOr&lt;void&gt; setAppendWindowStart(double);
 91     double appendWindowEnd() const;
 92     ExceptionOr&lt;void&gt; setAppendWindowEnd(double);
 93 
 94     ExceptionOr&lt;void&gt; appendBuffer(const BufferSource&amp;);
 95     ExceptionOr&lt;void&gt; abort();
 96     ExceptionOr&lt;void&gt; remove(double start, double end);
 97     ExceptionOr&lt;void&gt; remove(const MediaTime&amp;, const MediaTime&amp;);
 98     ExceptionOr&lt;void&gt; changeType(const String&amp;);
 99 
100     const TimeRanges&amp; bufferedInternal() const { ASSERT(m_buffered); return *m_buffered; }
101 
102     void abortIfUpdating();
103     void removedFromMediaSource();
104     void seekToTime(const MediaTime&amp;);
105 
106     bool canPlayThroughRange(PlatformTimeRanges&amp;);
</pre>
<hr />
<pre>
130     MediaTime highestPresentationTimestamp() const;
131     void readyStateChanged();
132 
133     bool hasPendingActivity() const final;
134 
135     void trySignalAllSamplesEnqueued();
136 
137 #if !RELEASE_LOG_DISABLED
138     const Logger&amp; logger() const final { return m_logger.get(); }
139     const void* logIdentifier() const final { return m_logIdentifier; }
140     const char* logClassName() const final { return &quot;SourceBuffer&quot;; }
141     WTFLogChannel&amp; logChannel() const final;
142 #endif
143 
144 private:
145     SourceBuffer(Ref&lt;SourceBufferPrivate&gt;&amp;&amp;, MediaSource*);
146 
147     void refEventTarget() final { ref(); }
148     void derefEventTarget() final { deref(); }
149 


150     void stop() final;
151     const char* activeDOMObjectName() const final;

152 
153     void sourceBufferPrivateDidReceiveInitializationSegment(const InitializationSegment&amp;) final;
154     void sourceBufferPrivateDidReceiveSample(MediaSample&amp;) final;
155     bool sourceBufferPrivateHasAudio() const final;
156     bool sourceBufferPrivateHasVideo() const final;
157     void sourceBufferPrivateReenqueSamples(const AtomString&amp; trackID) final;
158     void sourceBufferPrivateDidBecomeReadyForMoreSamples(const AtomString&amp; trackID) final;
159     MediaTime sourceBufferPrivateFastSeekTimeForMediaTime(const MediaTime&amp;, const MediaTime&amp; negativeThreshold, const MediaTime&amp; positiveThreshold) final;
160     void sourceBufferPrivateAppendComplete(AppendResult) final;
161     void sourceBufferPrivateDidReceiveRenderingError(int errorCode) final;
162 
163     void audioTrackEnabledChanged(AudioTrack&amp;) final;
164     void videoTrackSelectedChanged(VideoTrack&amp;) final;
165 
166     void textTrackKindChanged(TextTrack&amp;) final;
167     void textTrackModeChanged(TextTrack&amp;) final;
168     void textTrackAddCues(TextTrack&amp;, const TextTrackCueList&amp;) final;
169     void textTrackRemoveCues(TextTrack&amp;, const TextTrackCueList&amp;) final;
170     void textTrackAddCue(TextTrack&amp;, TextTrackCue&amp;) final;
171     void textTrackRemoveCue(TextTrack&amp;, TextTrackCue&amp;) final;
</pre>
<hr />
<pre>
200     void updateBufferedFromTrackBuffers();
201     void updateMinimumUpcomingPresentationTime(TrackBuffer&amp;, const AtomString&amp; trackID);
202     void resetMinimumUpcomingPresentationTime(TrackBuffer&amp;, const AtomString&amp; trackID);
203 
204     void appendError(bool);
205 
206     bool hasAudio() const;
207 
208     void rangeRemoval(const MediaTime&amp;, const MediaTime&amp;);
209 
210     void trySignalAllSamplesInTrackEnqueued(const AtomString&amp;);
211 
212     friend class Internals;
213     WEBCORE_EXPORT Vector&lt;String&gt; bufferedSamplesForTrackID(const AtomString&amp;);
214     WEBCORE_EXPORT Vector&lt;String&gt; enqueuedSamplesForTrackID(const AtomString&amp;);
215     WEBCORE_EXPORT MediaTime minimumUpcomingPresentationTimeForTrackID(const AtomString&amp;);
216     WEBCORE_EXPORT void setMaximumQueueDepthForTrackID(const AtomString&amp;, size_t);
217 
218     Ref&lt;SourceBufferPrivate&gt; m_private;
219     MediaSource* m_source;
<span class="line-modified">220     UniqueRef&lt;MainThreadGenericEventQueue&gt; m_asyncEventQueue;</span>
221     AppendMode m_mode { AppendMode::Segments };
222 
223     Vector&lt;unsigned char&gt; m_pendingAppendData;
224     Timer m_appendBufferTimer;
225 
226     RefPtr&lt;VideoTrackList&gt; m_videoTracks;
227     RefPtr&lt;AudioTrackList&gt; m_audioTracks;
228     RefPtr&lt;TextTrackList&gt; m_textTracks;
229 
230     Vector&lt;AtomString&gt; m_videoCodecs;
231     Vector&lt;AtomString&gt; m_audioCodecs;
232     Vector&lt;AtomString&gt; m_textCodecs;
233 
234     MediaTime m_timestampOffset;
235     MediaTime m_appendWindowStart;
236     MediaTime m_appendWindowEnd;
237 
238     MediaTime m_groupStartTimestamp;
239     MediaTime m_groupEndTimestamp;
240 
</pre>
</td>
</tr>
</table>
<center><a href="SourceBuffer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SourceBufferList.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
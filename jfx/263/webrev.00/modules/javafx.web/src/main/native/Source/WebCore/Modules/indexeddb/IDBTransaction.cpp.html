<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBTransaction.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;IDBTransaction.h&quot;
  28 
  29 #if ENABLE(INDEXED_DATABASE)
  30 
  31 #include &quot;DOMException.h&quot;
  32 #include &quot;DOMStringList.h&quot;
  33 #include &quot;DOMWindow.h&quot;
  34 #include &quot;Event.h&quot;
  35 #include &quot;EventDispatcher.h&quot;
  36 #include &quot;EventNames.h&quot;
  37 #include &quot;EventQueue.h&quot;
  38 #include &quot;IDBCursorWithValue.h&quot;
  39 #include &quot;IDBDatabase.h&quot;
  40 #include &quot;IDBError.h&quot;
  41 #include &quot;IDBGetRecordData.h&quot;
  42 #include &quot;IDBIndex.h&quot;
  43 #include &quot;IDBIterateCursorData.h&quot;
  44 #include &quot;IDBKeyData.h&quot;
  45 #include &quot;IDBKeyRangeData.h&quot;
  46 #include &quot;IDBObjectStore.h&quot;
  47 #include &quot;IDBOpenDBRequest.h&quot;
  48 #include &quot;IDBRequest.h&quot;
  49 #include &quot;IDBResultData.h&quot;
  50 #include &quot;IDBValue.h&quot;
  51 #include &quot;JSDOMWindowBase.h&quot;
  52 #include &quot;Logging.h&quot;
  53 #include &quot;ScriptExecutionContext.h&quot;
  54 #include &quot;ScriptState.h&quot;
  55 #include &quot;SerializedScriptValue.h&quot;
  56 #include &quot;TransactionOperation.h&quot;
  57 #include &lt;wtf/CompletionHandler.h&gt;
  58 #include &lt;wtf/IsoMallocInlines.h&gt;
  59 
  60 namespace WebCore {
  61 using namespace JSC;
  62 
  63 WTF_MAKE_ISO_ALLOCATED_IMPL(IDBTransaction);
  64 
  65 std::atomic&lt;unsigned&gt; IDBTransaction::numberOfIDBTransactions { 0 };
  66 
  67 Ref&lt;IDBTransaction&gt; IDBTransaction::create(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info)
  68 {
  69     return adoptRef(*new IDBTransaction(database, info, nullptr));
  70 }
  71 
  72 Ref&lt;IDBTransaction&gt; IDBTransaction::create(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info, IDBOpenDBRequest&amp; request)
  73 {
  74     return adoptRef(*new IDBTransaction(database, info, &amp;request));
  75 }
  76 
  77 IDBTransaction::IDBTransaction(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info, IDBOpenDBRequest* request)
  78     : IDBActiveDOMObject(database.scriptExecutionContext())
  79     , m_database(database)
  80     , m_info(info)
  81     , m_openDBRequest(request)
  82     , m_currentlyCompletingRequest(request)
  83 
  84 {
  85     LOG(IndexedDB, &quot;IDBTransaction::IDBTransaction - %s&quot;, m_info.loggingString().utf8().data());
  86     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
  87 
  88     ++numberOfIDBTransactions;
  89 
  90     if (m_info.mode() == IDBTransactionMode::Versionchange) {
  91         ASSERT(m_openDBRequest);
  92         m_openDBRequest-&gt;setVersionChangeTransaction(*this);
  93         m_startedOnServer = true;
  94     } else {
  95         activate();
  96 
  97         auto* context = scriptExecutionContext();
  98         ASSERT(context);
  99 
 100         JSC::VM&amp; vm = context-&gt;vm();
 101         vm.whenIdle([protectedThis = makeRef(*this)]() {
 102             protectedThis-&gt;deactivate();
 103         });
 104 
 105         establishOnServer();
 106     }
 107 
 108     suspendIfNeeded();
 109 }
 110 
 111 IDBTransaction::~IDBTransaction()
 112 {
 113     --numberOfIDBTransactions;
 114     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 115 }
 116 
 117 IDBClient::IDBConnectionProxy&amp; IDBTransaction::connectionProxy()
 118 {
 119     return m_database-&gt;connectionProxy();
 120 }
 121 
 122 Ref&lt;DOMStringList&gt; IDBTransaction::objectStoreNames() const
 123 {
 124     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 125 
 126     const Vector&lt;String&gt; names = isVersionChange() ? m_database-&gt;info().objectStoreNames() : m_info.objectStores();
 127 
 128     Ref&lt;DOMStringList&gt; objectStoreNames = DOMStringList::create();
 129     for (auto&amp; name : names)
 130         objectStoreNames-&gt;append(name);
 131 
 132     objectStoreNames-&gt;sort();
 133     return objectStoreNames;
 134 }
 135 
 136 IDBDatabase* IDBTransaction::db()
 137 {
 138     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 139     return m_database.ptr();
 140 }
 141 
 142 DOMException* IDBTransaction::error() const
 143 {
 144     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 145     return m_domError.get();
 146 }
 147 
 148 ExceptionOr&lt;Ref&lt;IDBObjectStore&gt;&gt; IDBTransaction::objectStore(const String&amp; objectStoreName)
 149 {
 150     LOG(IndexedDB, &quot;IDBTransaction::objectStore&quot;);
 151     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 152 
 153     if (!scriptExecutionContext())
 154         return Exception { InvalidStateError };
 155 
 156     if (isFinishedOrFinishing())
 157         return Exception { InvalidStateError, &quot;Failed to execute &#39;objectStore&#39; on &#39;IDBTransaction&#39;: The transaction finished.&quot;_s };
 158 
 159     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 160 
 161     if (auto* store = m_referencedObjectStores.get(objectStoreName))
 162         return makeRef(*store);
 163 
 164     bool found = false;
 165     for (auto&amp; objectStore : m_info.objectStores()) {
 166         if (objectStore == objectStoreName) {
 167             found = true;
 168             break;
 169         }
 170     }
 171 
 172     auto* info = m_database-&gt;info().infoForExistingObjectStore(objectStoreName);
 173     if (!info)
 174         return Exception { NotFoundError, &quot;Failed to execute &#39;objectStore&#39; on &#39;IDBTransaction&#39;: The specified object store was not found.&quot;_s };
 175 
 176     // Version change transactions are scoped to every object store in the database.
 177     if (!info || (!found &amp;&amp; !isVersionChange()))
 178         return Exception { NotFoundError, &quot;Failed to execute &#39;objectStore&#39; on &#39;IDBTransaction&#39;: The specified object store was not found.&quot;_s };
 179 
 180     auto objectStore = makeUnique&lt;IDBObjectStore&gt;(*scriptExecutionContext(), *info, *this);
 181     auto* rawObjectStore = objectStore.get();
 182     m_referencedObjectStores.set(objectStoreName, WTFMove(objectStore));
 183 
 184     return Ref&lt;IDBObjectStore&gt;(*rawObjectStore);
 185 }
 186 
 187 
 188 void IDBTransaction::abortDueToFailedRequest(DOMException&amp; error)
 189 {
 190     LOG(IndexedDB, &quot;IDBTransaction::abortDueToFailedRequest&quot;);
 191     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 192 
 193     if (isFinishedOrFinishing())
 194         return;
 195 
 196     m_domError = &amp;error;
 197     internalAbort();
 198 }
 199 
 200 void IDBTransaction::transitionedToFinishing(IndexedDB::TransactionState state)
 201 {
 202     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 203 
 204     ASSERT(!isFinishedOrFinishing());
 205     m_state = state;
 206     ASSERT(isFinishedOrFinishing());
 207 }
 208 
 209 ExceptionOr&lt;void&gt; IDBTransaction::abort()
 210 {
 211     LOG(IndexedDB, &quot;IDBTransaction::abort&quot;);
 212     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 213 
 214     if (isFinishedOrFinishing())
 215         return Exception { InvalidStateError, &quot;Failed to execute &#39;abort&#39; on &#39;IDBTransaction&#39;: The transaction is inactive or finished.&quot;_s };
 216 
 217     internalAbort();
 218 
 219     return { };
 220 }
 221 
 222 void IDBTransaction::internalAbort()
 223 {
 224     LOG(IndexedDB, &quot;IDBTransaction::internalAbort&quot;);
 225     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 226     ASSERT(!isFinishedOrFinishing());
 227 
 228     m_database-&gt;willAbortTransaction(*this);
 229 
 230     if (isVersionChange()) {
 231         Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 232 
 233         auto&amp; info = m_database-&gt;info();
 234         Vector&lt;uint64_t&gt; identifiersToRemove;
 235         for (auto&amp; iterator : m_deletedObjectStores) {
 236             if (info.infoForExistingObjectStore(iterator.key)) {
 237                 auto name = iterator.value-&gt;info().name();
 238                 m_referencedObjectStores.set(name, WTFMove(iterator.value));
 239                 identifiersToRemove.append(iterator.key);
 240             }
 241         }
 242 
 243         for (auto identifier : identifiersToRemove)
 244             m_deletedObjectStores.remove(identifier);
 245 
 246         for (auto&amp; objectStore : m_referencedObjectStores.values())
 247             objectStore-&gt;rollbackForVersionChangeAbort();
 248     }
 249 
 250     transitionedToFinishing(IndexedDB::TransactionState::Aborting);
 251 
 252     m_abortQueue.swap(m_pendingTransactionOperationQueue);
 253 
 254     LOG(IndexedDBOperations, &quot;IDB abort-on-server operation: Transaction %s&quot;, info().identifier().loggingString().utf8().data());
 255     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, nullptr, [protectedThis = makeRef(*this)] (auto&amp; operation) {
 256         protectedThis-&gt;abortOnServerAndCancelRequests(operation);
 257     }));
 258 }
 259 
 260 void IDBTransaction::abortInProgressOperations(const IDBError&amp; error)
 261 {
 262     LOG(IndexedDB, &quot;IDBTransaction::abortInProgressOperations&quot;);
 263 
 264     Vector&lt;RefPtr&lt;IDBClient::TransactionOperation&gt;&gt; inProgressAbortVector;
 265     inProgressAbortVector.reserveInitialCapacity(m_transactionOperationsInProgressQueue.size());
 266     while (!m_transactionOperationsInProgressQueue.isEmpty())
 267         inProgressAbortVector.uncheckedAppend(m_transactionOperationsInProgressQueue.takeFirst());
 268 
 269     for (auto&amp; operation : inProgressAbortVector) {
 270         m_transactionOperationsInProgressQueue.append(operation.get());
 271         m_currentlyCompletingRequest = nullptr;
 272         operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));
 273     }
 274 
 275     m_transactionOperationResultMap.clear();
 276 
 277     m_currentlyCompletingRequest = nullptr;
 278     connectionProxy().forgetActiveOperations(inProgressAbortVector);
 279 }
 280 
 281 void IDBTransaction::abortOnServerAndCancelRequests(IDBClient::TransactionOperation&amp; operation)
 282 {
 283     LOG(IndexedDB, &quot;IDBTransaction::abortOnServerAndCancelRequests&quot;);
 284     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 285     ASSERT(m_pendingTransactionOperationQueue.isEmpty());
 286 
 287     m_database-&gt;connectionProxy().abortTransaction(*this);
 288 
 289     ASSERT(m_transactionOperationMap.contains(operation.identifier()));
 290     ASSERT(m_transactionOperationsInProgressQueue.last() == &amp;operation);
 291     m_transactionOperationMap.remove(operation.identifier());
 292     m_transactionOperationsInProgressQueue.removeLast();
 293 
 294     m_currentlyCompletingRequest = nullptr;
 295 
 296     IDBError error(AbortError);
 297 
 298     abortInProgressOperations(error);
 299 
 300     for (auto&amp; operation : m_abortQueue) {
 301         m_transactionOperationsInProgressQueue.append(operation.get());
 302         operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));
 303         m_currentlyCompletingRequest = nullptr;
 304     }
 305 
 306     m_abortQueue.clear();
 307     m_openRequests.clear();
 308     // Since we&#39;re aborting, it should be impossible to have queued any further operations.
 309     ASSERT(m_pendingTransactionOperationQueue.isEmpty());
 310 }
 311 
 312 const char* IDBTransaction::activeDOMObjectName() const
 313 {
 314     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 315     return &quot;IDBTransaction&quot;;
 316 }
 317 
 318 bool IDBTransaction::hasPendingActivity() const
 319 {
 320     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()) || Thread::mayBeGCThread());
 321     return !m_contextStopped &amp;&amp; m_state != IndexedDB::TransactionState::Finished;
 322 }
 323 
 324 void IDBTransaction::stop()
 325 {
 326     LOG(IndexedDB, &quot;IDBTransaction::stop - %s&quot;, m_info.loggingString().utf8().data());
 327     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 328 
 329     // IDBDatabase::stop() calls IDBTransaction::stop() for each of its active transactions.
 330     // Since the order of calling ActiveDOMObject::stop() is random, we might already have been stopped.
 331     if (m_contextStopped)
 332         return;
 333 
 334     removeAllEventListeners();
 335 
 336     m_contextStopped = true;
 337 
 338     if (isVersionChange())
 339         m_openDBRequest = nullptr;
 340 
 341     if (isFinishedOrFinishing())
 342         return;
 343 
 344     internalAbort();
 345 }
 346 
 347 bool IDBTransaction::isActive() const
 348 {
 349     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 350     return m_state == IndexedDB::TransactionState::Active;
 351 }
 352 
 353 bool IDBTransaction::isFinishedOrFinishing() const
 354 {
 355     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 356 
 357     return m_state == IndexedDB::TransactionState::Committing
 358         || m_state == IndexedDB::TransactionState::Aborting
 359         || m_state == IndexedDB::TransactionState::Finished;
 360 }
 361 
 362 void IDBTransaction::addRequest(IDBRequest&amp; request)
 363 {
 364     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 365     m_openRequests.add(&amp;request);
 366 }
 367 
 368 void IDBTransaction::removeRequest(IDBRequest&amp; request)
 369 {
 370     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 371     if (m_currentlyCompletingRequest == &amp;request)
 372         return;
 373 
 374     m_openRequests.remove(&amp;request);
 375 
 376     autoCommit();
 377 }
 378 
 379 void IDBTransaction::scheduleOperation(Ref&lt;IDBClient::TransactionOperation&gt;&amp;&amp; operation, IsWriteOperation isWriteOperation)
 380 {
 381     ASSERT(!m_transactionOperationMap.contains(operation-&gt;identifier()));
 382     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 383 
 384     if (isWriteOperation == IsWriteOperation::Yes)
 385         m_lastWriteOperationID = operation-&gt;operationID();
 386 
 387     auto identifier = operation-&gt;identifier();
 388     m_pendingTransactionOperationQueue.append(operation.copyRef());
 389     m_transactionOperationMap.set(identifier, WTFMove(operation));
 390 
 391     handlePendingOperations();
 392 }
 393 
 394 void IDBTransaction::operationCompletedOnServer(const IDBResultData&amp; data, IDBClient::TransactionOperation&amp; operation)
 395 {
 396     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 397     ASSERT(canCurrentThreadAccessThreadLocalData(operation.originThread()));
 398 
 399     if (!m_transactionOperationMap.contains(operation.identifier()))
 400         return;
 401 
 402     m_transactionOperationResultMap.set(&amp;operation, IDBResultData(data));
 403 
 404     if (!m_currentlyCompletingRequest)
 405         handleOperationsCompletedOnServer();
 406 }
 407 
 408 void IDBTransaction::handleOperationsCompletedOnServer()
 409 {
 410     LOG(IndexedDB, &quot;IDBTransaction::handleOperationsCompletedOnServer&quot;);
 411     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 412 
 413     while (!m_transactionOperationsInProgressQueue.isEmpty() &amp;&amp; !m_currentlyCompletingRequest) {
 414         RefPtr&lt;IDBClient::TransactionOperation&gt; currentOperation = m_transactionOperationsInProgressQueue.first();
 415         if (!m_transactionOperationResultMap.contains(currentOperation))
 416             return;
 417 
 418         currentOperation-&gt;doComplete(m_transactionOperationResultMap.take(currentOperation));
 419     }
 420 }
 421 
 422 void IDBTransaction::completeNoncursorRequest(IDBRequest&amp; request, const IDBResultData&amp; result)
 423 {
 424     ASSERT(!m_currentlyCompletingRequest);
 425 
 426     request.completeRequestAndDispatchEvent(result);
 427 
 428     m_currentlyCompletingRequest = &amp;request;
 429 }
 430 
 431 void IDBTransaction::completeCursorRequest(IDBRequest&amp; request, const IDBResultData&amp; result)
 432 {
 433     ASSERT(!m_currentlyCompletingRequest);
 434 
 435     request.didOpenOrIterateCursor(result);
 436 
 437     m_currentlyCompletingRequest = &amp;request;
 438 }
 439 
 440 void IDBTransaction::finishedDispatchEventForRequest(IDBRequest&amp; request)
 441 {
 442     if (isFinished())
 443         return;
 444 
 445     ASSERT_UNUSED(request, !m_currentlyCompletingRequest || m_currentlyCompletingRequest == &amp;request);
 446 
 447     m_currentlyCompletingRequest = nullptr;
 448     handleOperationsCompletedOnServer();
 449 }
 450 
 451 void IDBTransaction::commit()
 452 {
 453     LOG(IndexedDB, &quot;IDBTransaction::commit&quot;);
 454     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 455     ASSERT(!isFinishedOrFinishing());
 456 
 457     transitionedToFinishing(IndexedDB::TransactionState::Committing);
 458     m_database-&gt;willCommitTransaction(*this);
 459 
 460     LOG(IndexedDBOperations, &quot;IDB commit operation: Transaction %s&quot;, info().identifier().loggingString().utf8().data());
 461     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, nullptr, [protectedThis = makeRef(*this)] (auto&amp; operation) {
 462         protectedThis-&gt;commitOnServer(operation);
 463     }));
 464 }
 465 
 466 void IDBTransaction::commitOnServer(IDBClient::TransactionOperation&amp; operation)
 467 {
 468     LOG(IndexedDB, &quot;IDBTransaction::commitOnServer&quot;);
 469     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 470 
 471     m_database-&gt;connectionProxy().commitTransaction(*this);
 472 
 473     ASSERT(!m_transactionOperationsInProgressQueue.isEmpty());
 474     ASSERT(m_transactionOperationsInProgressQueue.last() == &amp;operation);
 475     m_transactionOperationsInProgressQueue.removeLast();
 476 
 477     ASSERT(m_transactionOperationMap.contains(operation.identifier()));
 478     m_transactionOperationMap.remove(operation.identifier());
 479 }
 480 
 481 void IDBTransaction::finishAbortOrCommit()
 482 {
 483     ASSERT(m_state != IndexedDB::TransactionState::Finished);
 484     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 485 
 486     m_state = IndexedDB::TransactionState::Finished;
 487 }
 488 
 489 void IDBTransaction::didStart(const IDBError&amp; error)
 490 {
 491     LOG(IndexedDB, &quot;IDBTransaction::didStart&quot;);
 492     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 493 
 494     m_database-&gt;didStartTransaction(*this);
 495 
 496     m_startedOnServer = true;
 497 
 498     // It&#39;s possible the transaction failed to start on the server.
 499     // That equates to an abort.
 500     if (!error.isNull()) {
 501         didAbort(error);
 502         return;
 503     }
 504 
 505     handlePendingOperations();
 506 
 507     // It&#39;s possible transaction does not create requests (or creates but finishes them early
 508     // because of error) during intialization. In this case, since the transaction will
 509     // not be active any more, we can end it.
 510     autoCommit();
 511 }
 512 
 513 void IDBTransaction::notifyDidAbort(const IDBError&amp; error)
 514 {
 515     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 516 
 517     m_database-&gt;didAbortTransaction(*this);
 518     m_idbError = error;
 519     fireOnAbort();
 520 
 521     if (isVersionChange() &amp;&amp; !m_contextStopped) {
 522         ASSERT(m_openDBRequest);
 523         m_openDBRequest-&gt;fireErrorAfterVersionChangeCompletion();
 524     }
 525 }
 526 
 527 void IDBTransaction::didAbort(const IDBError&amp; error)
 528 {
 529     LOG(IndexedDB, &quot;IDBTransaction::didAbort&quot;);
 530     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 531 
 532     if (m_state == IndexedDB::TransactionState::Finished)
 533         return;
 534 
 535     notifyDidAbort(error);
 536 
 537     finishAbortOrCommit();
 538 }
 539 
 540 void IDBTransaction::didCommit(const IDBError&amp; error)
 541 {
 542     LOG(IndexedDB, &quot;IDBTransaction::didCommit&quot;);
 543     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 544     ASSERT(m_state == IndexedDB::TransactionState::Committing);
 545 
 546     if (error.isNull()) {
 547         m_database-&gt;didCommitTransaction(*this);
 548         fireOnComplete();
 549     } else {
 550         m_database-&gt;willAbortTransaction(*this);
 551         notifyDidAbort(error);
 552     }
 553 
 554     finishAbortOrCommit();
 555 }
 556 
 557 void IDBTransaction::fireOnComplete()
 558 {
 559     LOG(IndexedDB, &quot;IDBTransaction::fireOnComplete&quot;);
 560     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 561     enqueueEvent(Event::create(eventNames().completeEvent, Event::CanBubble::No, Event::IsCancelable::No));
 562 }
 563 
 564 void IDBTransaction::fireOnAbort()
 565 {
 566     LOG(IndexedDB, &quot;IDBTransaction::fireOnAbort&quot;);
 567     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 568     enqueueEvent(Event::create(eventNames().abortEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
 569 }
 570 
 571 void IDBTransaction::enqueueEvent(Ref&lt;Event&gt;&amp;&amp; event)
 572 {
 573     ASSERT(m_state != IndexedDB::TransactionState::Finished);
 574     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 575 
 576     if (!scriptExecutionContext() || m_contextStopped)
 577         return;
 578 
 579     queueTaskToDispatchEvent(*this, TaskSource::DatabaseAccess, WTFMove(event));
 580 }
 581 
 582 void IDBTransaction::dispatchEvent(Event&amp; event)
 583 {
 584     LOG(IndexedDB, &quot;IDBTransaction::dispatchEvent&quot;);
 585 
 586     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 587     ASSERT(scriptExecutionContext());
 588     ASSERT(!m_contextStopped);
 589     ASSERT(event.type() == eventNames().completeEvent || event.type() == eventNames().abortEvent);
 590 
 591     auto protectedThis = makeRef(*this);
 592 
 593     EventDispatcher::dispatchEvent({ this, m_database.ptr() }, event);
 594     m_didDispatchAbortOrCommit = true;
 595 
 596     if (isVersionChange()) {
 597         ASSERT(m_openDBRequest);
 598         m_openDBRequest-&gt;versionChangeTransactionDidFinish();
 599 
 600         if (event.type() == eventNames().completeEvent) {
 601             if (m_database-&gt;isClosingOrClosed())
 602                 m_openDBRequest-&gt;fireErrorAfterVersionChangeCompletion();
 603             else
 604                 m_openDBRequest-&gt;fireSuccessAfterVersionChangeCommit();
 605         }
 606 
 607         m_openDBRequest = nullptr;
 608     }
 609 }
 610 
 611 Ref&lt;IDBObjectStore&gt; IDBTransaction::createObjectStore(const IDBObjectStoreInfo&amp; info)
 612 {
 613     LOG(IndexedDB, &quot;IDBTransaction::createObjectStore&quot;);
 614     ASSERT(isVersionChange());
 615     ASSERT(scriptExecutionContext());
 616     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 617 
 618     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 619 
 620     auto objectStore = makeUnique&lt;IDBObjectStore&gt;(*scriptExecutionContext(), info, *this);
 621     auto* rawObjectStore = objectStore.get();
 622     m_referencedObjectStores.set(info.name(), WTFMove(objectStore));
 623 
 624     LOG(IndexedDBOperations, &quot;IDB create object store operation: %s&quot;, info.condensedLoggingString().utf8().data());
 625     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 626         protectedThis-&gt;didCreateObjectStoreOnServer(result);
 627     }, [protectedThis = makeRef(*this), info = info.isolatedCopy()] (auto&amp; operation) {
 628         protectedThis-&gt;createObjectStoreOnServer(operation, info);
 629     }), IsWriteOperation::Yes);
 630 
 631     return *rawObjectStore;
 632 }
 633 
 634 void IDBTransaction::createObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const IDBObjectStoreInfo&amp; info)
 635 {
 636     LOG(IndexedDB, &quot;IDBTransaction::createObjectStoreOnServer&quot;);
 637     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 638     ASSERT(isVersionChange());
 639 
 640     m_database-&gt;connectionProxy().createObjectStore(operation, info);
 641 }
 642 
 643 void IDBTransaction::didCreateObjectStoreOnServer(const IDBResultData&amp; resultData)
 644 {
 645     LOG(IndexedDB, &quot;IDBTransaction::didCreateObjectStoreOnServer&quot;);
 646     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 647     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::CreateObjectStoreSuccess || resultData.type() == IDBResultType::Error);
 648 }
 649 
 650 void IDBTransaction::renameObjectStore(IDBObjectStore&amp; objectStore, const String&amp; newName)
 651 {
 652     LOG(IndexedDB, &quot;IDBTransaction::renameObjectStore&quot;);
 653 
 654     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 655 
 656     ASSERT(isVersionChange());
 657     ASSERT(scriptExecutionContext());
 658     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 659 
 660     ASSERT(m_referencedObjectStores.contains(objectStore.info().name()));
 661     ASSERT(!m_referencedObjectStores.contains(newName));
 662     ASSERT(m_referencedObjectStores.get(objectStore.info().name()) == &amp;objectStore);
 663 
 664     uint64_t objectStoreIdentifier = objectStore.info().identifier();
 665 
 666     LOG(IndexedDBOperations, &quot;IDB rename object store operation: %s to %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), newName.utf8().data());
 667     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 668         protectedThis-&gt;didRenameObjectStoreOnServer(result);
 669     }, [protectedThis = makeRef(*this), objectStoreIdentifier, newName = newName.isolatedCopy()] (auto&amp; operation) {
 670         protectedThis-&gt;renameObjectStoreOnServer(operation, objectStoreIdentifier, newName);
 671     }), IsWriteOperation::Yes);
 672 
 673     m_referencedObjectStores.set(newName, m_referencedObjectStores.take(objectStore.info().name()));
 674 }
 675 
 676 void IDBTransaction::renameObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier, const String&amp; newName)
 677 {
 678     LOG(IndexedDB, &quot;IDBTransaction::renameObjectStoreOnServer&quot;);
 679     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 680     ASSERT(isVersionChange());
 681 
 682     m_database-&gt;connectionProxy().renameObjectStore(operation, objectStoreIdentifier, newName);
 683 }
 684 
 685 void IDBTransaction::didRenameObjectStoreOnServer(const IDBResultData&amp; resultData)
 686 {
 687     LOG(IndexedDB, &quot;IDBTransaction::didRenameObjectStoreOnServer&quot;);
 688     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 689     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::RenameObjectStoreSuccess || resultData.type() == IDBResultType::Error);
 690 }
 691 
 692 std::unique_ptr&lt;IDBIndex&gt; IDBTransaction::createIndex(IDBObjectStore&amp; objectStore, const IDBIndexInfo&amp; info)
 693 {
 694     LOG(IndexedDB, &quot;IDBTransaction::createIndex&quot;);
 695     ASSERT(isVersionChange());
 696     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 697 
 698     if (!scriptExecutionContext())
 699         return nullptr;
 700 
 701     LOG(IndexedDBOperations, &quot;IDB create index operation: %s under object store %s&quot;, info.condensedLoggingString().utf8().data(), objectStore.info().condensedLoggingString().utf8().data());
 702     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 703         protectedThis-&gt;didCreateIndexOnServer(result);
 704     }, [protectedThis = makeRef(*this), info = info.isolatedCopy()] (auto&amp; operation) {
 705         protectedThis-&gt;createIndexOnServer(operation, info);
 706     }), IsWriteOperation::Yes);
 707 
 708     return makeUnique&lt;IDBIndex&gt;(*scriptExecutionContext(), info, objectStore);
 709 }
 710 
 711 void IDBTransaction::createIndexOnServer(IDBClient::TransactionOperation&amp; operation, const IDBIndexInfo&amp; info)
 712 {
 713     LOG(IndexedDB, &quot;IDBTransaction::createIndexOnServer&quot;);
 714     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 715     ASSERT(isVersionChange());
 716 
 717     m_database-&gt;connectionProxy().createIndex(operation, info);
 718 }
 719 
 720 void IDBTransaction::didCreateIndexOnServer(const IDBResultData&amp; resultData)
 721 {
 722     LOG(IndexedDB, &quot;IDBTransaction::didCreateIndexOnServer&quot;);
 723     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 724 
 725     if (resultData.type() == IDBResultType::CreateIndexSuccess)
 726         return;
 727 
 728     ASSERT(resultData.type() == IDBResultType::Error);
 729 
 730     // This operation might have failed because the transaction is already aborting.
 731     if (m_state == IndexedDB::TransactionState::Aborting)
 732         return;
 733 
 734     // Otherwise, failure to create an index forced abortion of the transaction.
 735     abortDueToFailedRequest(DOMException::create(resultData.error().message(), resultData.error().name()));
 736 }
 737 
 738 void IDBTransaction::renameIndex(IDBIndex&amp; index, const String&amp; newName)
 739 {
 740     LOG(IndexedDB, &quot;IDBTransaction::renameIndex&quot;);
 741     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 742 
 743     ASSERT(isVersionChange());
 744     ASSERT(scriptExecutionContext());
 745     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 746 
 747     ASSERT(m_referencedObjectStores.contains(index.objectStore().info().name()));
 748     ASSERT(m_referencedObjectStores.get(index.objectStore().info().name()) == &amp;index.objectStore());
 749 
 750     index.objectStore().renameReferencedIndex(index, newName);
 751 
 752     uint64_t objectStoreIdentifier = index.objectStore().info().identifier();
 753     uint64_t indexIdentifier = index.info().identifier();
 754 
 755     LOG(IndexedDBOperations, &quot;IDB rename index operation: %s to %s under object store %&quot; PRIu64, index.info().condensedLoggingString().utf8().data(), newName.utf8().data(), index.info().objectStoreIdentifier());
 756     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 757         protectedThis-&gt;didRenameIndexOnServer(result);
 758     }, [protectedThis = makeRef(*this), objectStoreIdentifier, indexIdentifier, newName = newName.isolatedCopy()] (auto&amp; operation) {
 759         protectedThis-&gt;renameIndexOnServer(operation, objectStoreIdentifier, indexIdentifier, newName);
 760     }), IsWriteOperation::Yes);
 761 }
 762 
 763 void IDBTransaction::renameIndexOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier, const uint64_t&amp; indexIdentifier, const String&amp; newName)
 764 {
 765     LOG(IndexedDB, &quot;IDBTransaction::renameIndexOnServer&quot;);
 766     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 767     ASSERT(isVersionChange());
 768 
 769     m_database-&gt;connectionProxy().renameIndex(operation, objectStoreIdentifier, indexIdentifier, newName);
 770 }
 771 
 772 void IDBTransaction::didRenameIndexOnServer(const IDBResultData&amp; resultData)
 773 {
 774     LOG(IndexedDB, &quot;IDBTransaction::didRenameIndexOnServer&quot;);
 775     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 776     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::RenameIndexSuccess || resultData.type() == IDBResultType::Error);
 777 }
 778 
 779 Ref&lt;IDBRequest&gt; IDBTransaction::requestOpenCursor(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBCursorInfo&amp; info)
 780 {
 781     LOG(IndexedDB, &quot;IDBTransaction::requestOpenCursor&quot;);
 782     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 783 
 784     if (info.cursorType() == IndexedDB::CursorType::KeyOnly)
 785         return doRequestOpenCursor(state, IDBCursor::create(objectStore, info));
 786 
 787     return doRequestOpenCursor(state, IDBCursorWithValue::create(objectStore, info));
 788 }
 789 
 790 Ref&lt;IDBRequest&gt; IDBTransaction::requestOpenCursor(JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBCursorInfo&amp; info)
 791 {
 792     LOG(IndexedDB, &quot;IDBTransaction::requestOpenCursor&quot;);
 793     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 794 
 795     if (info.cursorType() == IndexedDB::CursorType::KeyOnly)
 796         return doRequestOpenCursor(state, IDBCursor::create(index, info));
 797 
 798     return doRequestOpenCursor(state, IDBCursorWithValue::create(index, info));
 799 }
 800 
 801 Ref&lt;IDBRequest&gt; IDBTransaction::doRequestOpenCursor(JSGlobalObject&amp; state, Ref&lt;IDBCursor&gt;&amp;&amp; cursor)
 802 {
 803     ASSERT(isActive());
 804     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 805 
 806     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
 807 
 808     auto request = IDBRequest::create(*scriptExecutionContext(), cursor.get(), *this);
 809     addRequest(request.get());
 810 
 811     LOG(IndexedDBOperations, &quot;IDB open cursor operation: %s&quot;, cursor-&gt;info().loggingString().utf8().data());
 812     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
 813         protectedThis-&gt;didOpenCursorOnServer(request.get(), result);
 814     }, [protectedThis = makeRef(*this), info = cursor-&gt;info().isolatedCopy()] (auto&amp; operation) {
 815         protectedThis-&gt;openCursorOnServer(operation, info);
 816     }));
 817 
 818     return request;
 819 }
 820 
 821 void IDBTransaction::openCursorOnServer(IDBClient::TransactionOperation&amp; operation, const IDBCursorInfo&amp; info)
 822 {
 823     LOG(IndexedDB, &quot;IDBTransaction::openCursorOnServer&quot;);
 824     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 825 
 826     m_database-&gt;connectionProxy().openCursor(operation, info);
 827 }
 828 
 829 void IDBTransaction::didOpenCursorOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
 830 {
 831     LOG(IndexedDB, &quot;IDBTransaction::didOpenCursorOnServer&quot;);
 832     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 833 
 834     completeCursorRequest(request, resultData);
 835 }
 836 
 837 void IDBTransaction::iterateCursor(IDBCursor&amp; cursor, const IDBIterateCursorData&amp; data)
 838 {
 839     LOG(IndexedDB, &quot;IDBTransaction::iterateCursor&quot;);
 840     ASSERT(isActive());
 841     ASSERT(cursor.request());
 842     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 843 
 844     addRequest(*cursor.request());
 845 
 846     LOG(IndexedDBOperations, &quot;IDB iterate cursor operation: %s %s&quot;, cursor.info().loggingString().utf8().data(), data.loggingString().utf8().data());
 847     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, *cursor.request(), [protectedThis = makeRef(*this), request = makeRef(*cursor.request())] (const auto&amp; result) {
 848         protectedThis-&gt;didIterateCursorOnServer(request.get(), result);
 849     }, [protectedThis = makeRef(*this), data = data.isolatedCopy()] (auto&amp; operation) {
 850         protectedThis-&gt;iterateCursorOnServer(operation, data);
 851     }));
 852 }
 853 
 854 // FIXME: changes here
 855 void IDBTransaction::iterateCursorOnServer(IDBClient::TransactionOperation&amp; operation, const IDBIterateCursorData&amp; data)
 856 {
 857     LOG(IndexedDB, &quot;IDBTransaction::iterateCursorOnServer&quot;);
 858     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 859     ASSERT(operation.idbRequest());
 860 
 861     auto* cursor = operation.idbRequest()-&gt;pendingCursor();
 862     ASSERT(cursor);
 863 
 864     if (data.keyData.isNull() &amp;&amp; data.primaryKeyData.isNull()) {
 865         if (auto getResult = cursor-&gt;iterateWithPrefetchedRecords(data.count, m_lastWriteOperationID)) {
 866             auto result = IDBResultData::iterateCursorSuccess(operation.identifier(), getResult.value());
 867             m_database-&gt;connectionProxy().iterateCursor(operation, { data.keyData, data.primaryKeyData, data.count, IndexedDB::CursorIterateOption::DoNotReply });
 868             operationCompletedOnServer(result, operation);
 869             return;
 870         }
 871     }
 872 
 873     cursor-&gt;clearPrefetchedRecords();
 874 
 875     ASSERT(data.option == IndexedDB::CursorIterateOption::Reply);
 876     m_database-&gt;connectionProxy().iterateCursor(operation, data);
 877 }
 878 
 879 void IDBTransaction::didIterateCursorOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
 880 {
 881     LOG(IndexedDB, &quot;IDBTransaction::didIterateCursorOnServer&quot;);
 882     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 883 
 884     completeCursorRequest(request, resultData);
 885 }
 886 
 887 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetAllObjectStoreRecords(JSC::JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; keyRangeData, IndexedDB::GetAllType getAllType, Optional&lt;uint32_t&gt; count)
 888 {
 889     LOG(IndexedDB, &quot;IDBTransaction::requestGetAllObjectStoreRecords&quot;);
 890     ASSERT(isActive());
 891     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 892 
 893     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
 894 
 895     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
 896     addRequest(request.get());
 897 
 898     IDBGetAllRecordsData getAllRecordsData { keyRangeData, getAllType, count, objectStore.info().identifier(), 0 };
 899 
 900     LOG(IndexedDBOperations, &quot;IDB get all object store records operation: %s&quot;, getAllRecordsData.loggingString().utf8().data());
 901     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
 902         protectedThis-&gt;didGetAllRecordsOnServer(request.get(), result);
 903     }, [protectedThis = makeRef(*this), getAllRecordsData = getAllRecordsData.isolatedCopy()] (auto&amp; operation) {
 904         protectedThis-&gt;getAllRecordsOnServer(operation, getAllRecordsData);
 905     }));
 906 
 907     return request;
 908 }
 909 
 910 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetAllIndexRecords(JSC::JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; keyRangeData, IndexedDB::GetAllType getAllType, Optional&lt;uint32_t&gt; count)
 911 {
 912     LOG(IndexedDB, &quot;IDBTransaction::requestGetAllIndexRecords&quot;);
 913     ASSERT(isActive());
 914     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 915 
 916     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
 917 
 918     auto request = IDBRequest::create(*scriptExecutionContext(), index, *this);
 919     addRequest(request.get());
 920 
 921     IDBGetAllRecordsData getAllRecordsData { keyRangeData, getAllType, count, index.objectStore().info().identifier(), index.info().identifier() };
 922 
 923     LOG(IndexedDBOperations, &quot;IDB get all index records operation: %s&quot;, getAllRecordsData.loggingString().utf8().data());
 924     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
 925         protectedThis-&gt;didGetAllRecordsOnServer(request.get(), result);
 926     }, [protectedThis = makeRef(*this), getAllRecordsData = getAllRecordsData.isolatedCopy()] (auto&amp; operation) {
 927         protectedThis-&gt;getAllRecordsOnServer(operation, getAllRecordsData);
 928     }));
 929 
 930     return request;
 931 }
 932 
 933 void IDBTransaction::getAllRecordsOnServer(IDBClient::TransactionOperation&amp; operation, const IDBGetAllRecordsData&amp; getAllRecordsData)
 934 {
 935     LOG(IndexedDB, &quot;IDBTransaction::getAllRecordsOnServer&quot;);
 936     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 937 
 938     m_database-&gt;connectionProxy().getAllRecords(operation, getAllRecordsData);
 939 }
 940 
 941 void IDBTransaction::didGetAllRecordsOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
 942 {
 943     LOG(IndexedDB, &quot;IDBTransaction::didGetAllRecordsOnServer&quot;);
 944     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 945 
 946     if (resultData.type() == IDBResultType::Error) {
 947         completeNoncursorRequest(request, resultData);
 948         return;
 949     }
 950 
 951     ASSERT(resultData.type() == IDBResultType::GetAllRecordsSuccess);
 952 
 953     auto&amp; getAllResult = resultData.getAllResult();
 954     switch (getAllResult.type()) {
 955     case IndexedDB::GetAllType::Keys:
 956         request.setResult(getAllResult.keys());
 957         break;
 958     case IndexedDB::GetAllType::Values:
 959         request.setResult(getAllResult);
 960         break;
 961     }
 962 
 963     completeNoncursorRequest(request, resultData);
 964 }
 965 
 966 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetRecord(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBGetRecordData&amp; getRecordData)
 967 {
 968     LOG(IndexedDB, &quot;IDBTransaction::requestGetRecord&quot;);
 969     ASSERT(isActive());
 970     ASSERT(!getRecordData.keyRangeData.isNull);
 971     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 972 
 973     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
 974 
 975     IndexedDB::ObjectStoreRecordType type = getRecordData.type == IDBGetRecordDataType::KeyAndValue ? IndexedDB::ObjectStoreRecordType::ValueOnly : IndexedDB::ObjectStoreRecordType::KeyOnly;
 976 
 977     auto request = IDBRequest::createObjectStoreGet(*scriptExecutionContext(), objectStore, type, *this);
 978     addRequest(request.get());
 979 
 980     LOG(IndexedDBOperations, &quot;IDB get record operation: %s %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), getRecordData.loggingString().utf8().data());
 981     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
 982         protectedThis-&gt;didGetRecordOnServer(request.get(), result);
 983     }, [protectedThis = makeRef(*this), getRecordData = getRecordData.isolatedCopy()] (auto&amp; operation) {
 984         protectedThis-&gt;getRecordOnServer(operation, getRecordData);
 985     }));
 986 
 987     return request;
 988 }
 989 
 990 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetValue(JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)
 991 {
 992     LOG(IndexedDB, &quot;IDBTransaction::requestGetValue&quot;);
 993     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
 994 
 995     return requestIndexRecord(state, index, IndexedDB::IndexRecordType::Value, range);
 996 }
 997 
 998 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetKey(JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)
 999 {
1000     LOG(IndexedDB, &quot;IDBTransaction::requestGetValue&quot;);
1001     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1002 
1003     return requestIndexRecord(state, index, IndexedDB::IndexRecordType::Key, range);
1004 }
1005 
1006 Ref&lt;IDBRequest&gt; IDBTransaction::requestIndexRecord(JSGlobalObject&amp; state, IDBIndex&amp; index, IndexedDB::IndexRecordType type, const IDBKeyRangeData&amp; range)
1007 {
1008     LOG(IndexedDB, &quot;IDBTransaction::requestGetValue&quot;);
1009     ASSERT(isActive());
1010     ASSERT(!range.isNull);
1011     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1012 
1013     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1014 
1015     auto request = IDBRequest::createIndexGet(*scriptExecutionContext(), index, type, *this);
1016     addRequest(request.get());
1017 
1018     IDBGetRecordData getRecordData = { range, IDBGetRecordDataType::KeyAndValue };
1019 
1020     LOG(IndexedDBOperations, &quot;IDB get index record operation: %s %s&quot;, index.info().condensedLoggingString().utf8().data(), getRecordData.loggingString().utf8().data());
1021     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1022         protectedThis-&gt;didGetRecordOnServer(request.get(), result);
1023     }, [protectedThis = makeRef(*this), getRecordData = getRecordData.isolatedCopy()] (auto&amp; operation) {
1024         protectedThis-&gt;getRecordOnServer(operation, getRecordData);
1025     }));
1026 
1027     return request;
1028 }
1029 
1030 void IDBTransaction::getRecordOnServer(IDBClient::TransactionOperation&amp; operation, const IDBGetRecordData&amp; getRecordData)
1031 {
1032     LOG(IndexedDB, &quot;IDBTransaction::getRecordOnServer&quot;);
1033     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1034 
1035     m_database-&gt;connectionProxy().getRecord(operation, getRecordData);
1036 }
1037 
1038 void IDBTransaction::didGetRecordOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1039 {
1040     LOG(IndexedDB, &quot;IDBTransaction::didGetRecordOnServer&quot;);
1041     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1042 
1043     if (resultData.type() == IDBResultType::Error) {
1044         completeNoncursorRequest(request, resultData);
1045         return;
1046     }
1047 
1048     ASSERT(resultData.type() == IDBResultType::GetRecordSuccess);
1049 
1050     bool useResultKey = request.sourceIndexIdentifier() &amp;&amp; request.requestedIndexRecordType() == IndexedDB::IndexRecordType::Key;
1051     if (!useResultKey)
1052         useResultKey = request.requestedObjectStoreRecordType() == IndexedDB::ObjectStoreRecordType::KeyOnly;
1053 
1054     const IDBGetResult&amp; result = resultData.getResult();
1055 
1056     if (useResultKey) {
1057         if (!result.keyData().isNull())
1058             request.setResult(result.keyData());
1059         else
1060             request.setResultToUndefined();
1061     } else {
1062         if (resultData.getResult().value().data().data())
1063             request.setResultToStructuredClone(resultData.getResult());
1064         else
1065             request.setResultToUndefined();
1066     }
1067 
1068     completeNoncursorRequest(request, resultData);
1069 }
1070 
1071 Ref&lt;IDBRequest&gt; IDBTransaction::requestCount(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; range)
1072 {
1073     LOG(IndexedDB, &quot;IDBTransaction::requestCount (IDBObjectStore)&quot;);
1074     ASSERT(isActive());
1075     ASSERT(!range.isNull);
1076     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1077 
1078     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1079 
1080     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1081     addRequest(request.get());
1082 
1083     LOG(IndexedDBOperations, &quot;IDB object store count operation: %s, range %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), range.loggingString().utf8().data());
1084     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1085         protectedThis-&gt;didGetCountOnServer(request.get(), result);
1086     }, [protectedThis = makeRef(*this), range = range.isolatedCopy()] (auto&amp; operation) {
1087         protectedThis-&gt;getCountOnServer(operation, range);
1088     }));
1089 
1090     return request;
1091 }
1092 
1093 Ref&lt;IDBRequest&gt; IDBTransaction::requestCount(JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)
1094 {
1095     LOG(IndexedDB, &quot;IDBTransaction::requestCount (IDBIndex)&quot;);
1096     ASSERT(isActive());
1097     ASSERT(!range.isNull);
1098     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1099 
1100     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1101 
1102     auto request = IDBRequest::create(*scriptExecutionContext(), index, *this);
1103     addRequest(request.get());
1104 
1105     LOG(IndexedDBOperations, &quot;IDB index count operation: %s, range %s&quot;, index.info().condensedLoggingString().utf8().data(), range.loggingString().utf8().data());
1106     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1107         protectedThis-&gt;didGetCountOnServer(request.get(), result);
1108     }, [protectedThis = makeRef(*this), range = range.isolatedCopy()] (auto&amp; operation) {
1109         protectedThis-&gt;getCountOnServer(operation, range);
1110     }));
1111 
1112     return request;
1113 }
1114 
1115 void IDBTransaction::getCountOnServer(IDBClient::TransactionOperation&amp; operation, const IDBKeyRangeData&amp; keyRange)
1116 {
1117     LOG(IndexedDB, &quot;IDBTransaction::getCountOnServer&quot;);
1118     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1119 
1120     m_database-&gt;connectionProxy().getCount(operation, keyRange);
1121 }
1122 
1123 void IDBTransaction::didGetCountOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1124 {
1125     LOG(IndexedDB, &quot;IDBTransaction::didGetCountOnServer&quot;);
1126     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1127 
1128     request.setResult(resultData.resultInteger());
1129     completeNoncursorRequest(request, resultData);
1130 }
1131 
1132 Ref&lt;IDBRequest&gt; IDBTransaction::requestDeleteRecord(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; range)
1133 {
1134     LOG(IndexedDB, &quot;IDBTransaction::requestDeleteRecord&quot;);
1135     ASSERT(isActive());
1136     ASSERT(!range.isNull);
1137     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1138 
1139     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1140 
1141     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1142     addRequest(request.get());
1143 
1144     LOG(IndexedDBOperations, &quot;IDB delete record operation: %s, range %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), range.loggingString().utf8().data());
1145     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1146         protectedThis-&gt;didDeleteRecordOnServer(request.get(), result);
1147     }, [protectedThis = makeRef(*this), range = range.isolatedCopy()] (auto&amp; operation) {
1148         protectedThis-&gt;deleteRecordOnServer(operation, range);
1149     }), IsWriteOperation::Yes);
1150     return request;
1151 }
1152 
1153 void IDBTransaction::deleteRecordOnServer(IDBClient::TransactionOperation&amp; operation, const IDBKeyRangeData&amp; keyRange)
1154 {
1155     LOG(IndexedDB, &quot;IDBTransaction::deleteRecordOnServer&quot;);
1156     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1157 
1158     m_database-&gt;connectionProxy().deleteRecord(operation, keyRange);
1159 }
1160 
1161 void IDBTransaction::didDeleteRecordOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1162 {
1163     LOG(IndexedDB, &quot;IDBTransaction::didDeleteRecordOnServer&quot;);
1164     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1165 
1166     request.setResultToUndefined();
1167     completeNoncursorRequest(request, resultData);
1168 }
1169 
1170 Ref&lt;IDBRequest&gt; IDBTransaction::requestClearObjectStore(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore)
1171 {
1172     LOG(IndexedDB, &quot;IDBTransaction::requestClearObjectStore&quot;);
1173     ASSERT(isActive());
1174     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1175 
1176     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1177 
1178     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1179     addRequest(request.get());
1180 
1181     uint64_t objectStoreIdentifier = objectStore.info().identifier();
1182 
1183     LOG(IndexedDBOperations, &quot;IDB clear object store operation: %s&quot;, objectStore.info().condensedLoggingString().utf8().data());
1184     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1185         protectedThis-&gt;didClearObjectStoreOnServer(request.get(), result);
1186     }, [protectedThis = makeRef(*this), objectStoreIdentifier] (auto&amp; operation) {
1187         protectedThis-&gt;clearObjectStoreOnServer(operation, objectStoreIdentifier);
1188     }), IsWriteOperation::Yes);
1189 
1190     return request;
1191 }
1192 
1193 void IDBTransaction::clearObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier)
1194 {
1195     LOG(IndexedDB, &quot;IDBTransaction::clearObjectStoreOnServer&quot;);
1196     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1197 
1198     m_database-&gt;connectionProxy().clearObjectStore(operation, objectStoreIdentifier);
1199 }
1200 
1201 void IDBTransaction::didClearObjectStoreOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1202 {
1203     LOG(IndexedDB, &quot;IDBTransaction::didClearObjectStoreOnServer&quot;);
1204     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1205 
1206     request.setResultToUndefined();
1207     completeNoncursorRequest(request, resultData);
1208 }
1209 
1210 Ref&lt;IDBRequest&gt; IDBTransaction::requestPutOrAdd(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, RefPtr&lt;IDBKey&gt;&amp;&amp; key, SerializedScriptValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode)
1211 {
1212     LOG(IndexedDB, &quot;IDBTransaction::requestPutOrAdd&quot;);
1213     ASSERT(isActive());
1214     ASSERT(!isReadOnly());
1215     ASSERT(objectStore.info().autoIncrement() || key);
1216     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1217 
1218     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1219 
1220     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1221     addRequest(request.get());
1222 
1223     LOG(IndexedDBOperations, &quot;IDB putOrAdd operation: %s key: %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), key ? key-&gt;loggingString().utf8().data() : &quot;&lt;null key&gt;&quot;);
1224     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
1225         protectedThis-&gt;didPutOrAddOnServer(request.get(), result);
1226     }, [protectedThis = makeRef(*this), key, value = makeRef(value), overwriteMode] (auto&amp; operation) {
1227         protectedThis-&gt;putOrAddOnServer(operation, key.get(), value.ptr(), overwriteMode);
1228     }), IsWriteOperation::Yes);
1229 
1230     return request;
1231 }
1232 
1233 void IDBTransaction::putOrAddOnServer(IDBClient::TransactionOperation&amp; operation, RefPtr&lt;IDBKey&gt; key, RefPtr&lt;SerializedScriptValue&gt; value, const IndexedDB::ObjectStoreOverwriteMode&amp; overwriteMode)
1234 {
1235     LOG(IndexedDB, &quot;IDBTransaction::putOrAddOnServer&quot;);
1236     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
1237     ASSERT(!isReadOnly());
1238     ASSERT(value);
1239 
1240     if (!value-&gt;hasBlobURLs()) {
1241         m_database-&gt;connectionProxy().putOrAdd(operation, key.get(), *value, overwriteMode);
1242         return;
1243     }
1244 
1245     // Due to current limitations on our ability to post tasks back to a worker thread,
1246     // workers currently write blobs to disk synchronously.
1247     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=157958 - Make this asynchronous after refactoring allows it.
1248     if (!isMainThread()) {
1249         auto idbValue = value-&gt;writeBlobsToDiskForIndexedDBSynchronously();
1250         if (idbValue.data().data())
1251             m_database-&gt;connectionProxy().putOrAdd(operation, key.get(), idbValue, overwriteMode);
1252         else {
1253             // If the IDBValue doesn&#39;t have any data, then something went wrong writing the blobs to disk.
1254             // In that case, we cannot successfully store this record, so we callback with an error.
1255             RefPtr&lt;IDBClient::TransactionOperation&gt; protectedOperation(&amp;operation);
1256             auto result = IDBResultData::error(operation.identifier(), IDBError { UnknownError, &quot;Error preparing Blob/File data to be stored in object store&quot;_s });
1257             scriptExecutionContext()-&gt;postTask([protectedOperation = WTFMove(protectedOperation), result = WTFMove(result)](ScriptExecutionContext&amp;) {
1258                 protectedOperation-&gt;doComplete(result);
1259             });
1260         }
1261         return;
1262     }
1263 
1264     // Since this request won&#39;t actually go to the server until the blob writes are complete,
1265     // stop future requests from going to the server ahead of it.
1266     operation.setNextRequestCanGoToServer(false);
1267 
1268     value-&gt;writeBlobsToDiskForIndexedDB([protectedThis = makeRef(*this), this, protectedOperation = Ref&lt;IDBClient::TransactionOperation&gt;(operation), keyData = IDBKeyData(key.get()).isolatedCopy(), overwriteMode](IDBValue&amp;&amp; idbValue) mutable {
1269         ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
1270         ASSERT(isMainThread());
1271         if (idbValue.data().data()) {
1272             m_database-&gt;connectionProxy().putOrAdd(protectedOperation.get(), WTFMove(keyData), idbValue, overwriteMode);
1273             return;
1274         }
1275 
1276         // If the IDBValue doesn&#39;t have any data, then something went wrong writing the blobs to disk.
1277         // In that case, we cannot successfully store this record, so we callback with an error.
1278         auto result = IDBResultData::error(protectedOperation-&gt;identifier(), IDBError { UnknownError, &quot;Error preparing Blob/File data to be stored in object store&quot;_s });
1279         callOnMainThread([protectedThis = WTFMove(protectedThis), protectedOperation = WTFMove(protectedOperation), result = WTFMove(result)]() mutable {
1280             protectedOperation-&gt;doComplete(result);
1281         });
1282     });
1283 }
1284 
1285 void IDBTransaction::didPutOrAddOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1286 {
1287     LOG(IndexedDB, &quot;IDBTransaction::didPutOrAddOnServer&quot;);
1288     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1289 
1290     if (auto* result = resultData.resultKey())
1291         request.setResult(*result);
1292     else
1293         request.setResultToUndefined();
1294     completeNoncursorRequest(request, resultData);
1295 }
1296 
1297 void IDBTransaction::deleteObjectStore(const String&amp; objectStoreName)
1298 {
1299     LOG(IndexedDB, &quot;IDBTransaction::deleteObjectStore&quot;);
1300     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1301     ASSERT(isVersionChange());
1302 
1303     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
1304 
1305     if (auto objectStore = m_referencedObjectStores.take(objectStoreName)) {
1306         objectStore-&gt;markAsDeleted();
1307         auto identifier = objectStore-&gt;info().identifier();
1308         m_deletedObjectStores.set(identifier, WTFMove(objectStore));
1309     }
1310 
1311     LOG(IndexedDBOperations, &quot;IDB delete object store operation: %s&quot;, objectStoreName.utf8().data());
1312     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
1313         protectedThis-&gt;didDeleteObjectStoreOnServer(result);
1314     }, [protectedThis = makeRef(*this), objectStoreName = objectStoreName.isolatedCopy()] (auto&amp; operation) {
1315         protectedThis-&gt;deleteObjectStoreOnServer(operation, objectStoreName);
1316     }), IsWriteOperation::Yes);
1317 }
1318 
1319 void IDBTransaction::deleteObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const String&amp; objectStoreName)
1320 {
1321     LOG(IndexedDB, &quot;IDBTransaction::deleteObjectStoreOnServer&quot;);
1322     ASSERT(isVersionChange());
1323     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1324 
1325     m_database-&gt;connectionProxy().deleteObjectStore(operation, objectStoreName);
1326 }
1327 
1328 void IDBTransaction::didDeleteObjectStoreOnServer(const IDBResultData&amp; resultData)
1329 {
1330     LOG(IndexedDB, &quot;IDBTransaction::didDeleteObjectStoreOnServer&quot;);
1331     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1332     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::DeleteObjectStoreSuccess || resultData.type() == IDBResultType::Error);
1333 }
1334 
1335 void IDBTransaction::deleteIndex(uint64_t objectStoreIdentifier, const String&amp; indexName)
1336 {
1337     LOG(IndexedDB, &quot;IDBTransaction::deleteIndex&quot;);
1338     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1339     ASSERT(isVersionChange());
1340 
1341     LOG(IndexedDBOperations, &quot;IDB delete index operation: %s (%&quot; PRIu64 &quot;)&quot;, indexName.utf8().data(), objectStoreIdentifier);
1342     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
1343         protectedThis-&gt;didDeleteIndexOnServer(result);
1344     }, [protectedThis = makeRef(*this), objectStoreIdentifier, indexName = indexName.isolatedCopy()] (auto&amp; operation) {
1345         protectedThis-&gt;deleteIndexOnServer(operation, objectStoreIdentifier, indexName);
1346     }), IsWriteOperation::Yes);
1347 }
1348 
1349 void IDBTransaction::deleteIndexOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier, const String&amp; indexName)
1350 {
1351     LOG(IndexedDB, &quot;IDBTransaction::deleteIndexOnServer&quot;);
1352     ASSERT(isVersionChange());
1353     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1354 
1355     m_database-&gt;connectionProxy().deleteIndex(operation, objectStoreIdentifier, indexName);
1356 }
1357 
1358 void IDBTransaction::didDeleteIndexOnServer(const IDBResultData&amp; resultData)
1359 {
1360     LOG(IndexedDB, &quot;IDBTransaction::didDeleteIndexOnServer&quot;);
1361     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1362     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::DeleteIndexSuccess || resultData.type() == IDBResultType::Error);
1363 }
1364 
1365 void IDBTransaction::operationCompletedOnClient(IDBClient::TransactionOperation&amp; operation)
1366 {
1367     LOG(IndexedDB, &quot;IDBTransaction::operationCompletedOnClient&quot;);
1368 
1369     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1370     ASSERT(canCurrentThreadAccessThreadLocalData(operation.originThread()));
1371     ASSERT(m_transactionOperationMap.get(operation.identifier()) == &amp;operation);
1372     ASSERT(m_transactionOperationsInProgressQueue.first() == &amp;operation);
1373 
1374     m_transactionOperationMap.remove(operation.identifier());
1375     m_transactionOperationsInProgressQueue.removeFirst();
1376 
1377     if (m_transactionOperationsInProgressQueue.isEmpty())
1378         handlePendingOperations();
1379 
1380     autoCommit();
1381 }
1382 
1383 void IDBTransaction::establishOnServer()
1384 {
1385     LOG(IndexedDB, &quot;IDBTransaction::establishOnServer&quot;);
1386     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1387 
1388     m_database-&gt;connectionProxy().establishTransaction(*this);
1389 }
1390 
1391 void IDBTransaction::activate()
1392 {
1393     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1394 
1395     if (isFinishedOrFinishing())
1396         return;
1397 
1398     m_state = IndexedDB::TransactionState::Active;
1399 }
1400 
1401 void IDBTransaction::deactivate()
1402 {
1403     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1404 
1405     if (m_state == IndexedDB::TransactionState::Active)
1406         m_state = IndexedDB::TransactionState::Inactive;
1407 
1408     autoCommit();
1409 }
1410 
1411 void IDBTransaction::connectionClosedFromServer(const IDBError&amp; error)
1412 {
1413     LOG(IndexedDB, &quot;IDBTransaction::connectionClosedFromServer - %s&quot;, error.message().utf8().data());
1414 
1415     m_database-&gt;willAbortTransaction(*this);
1416     m_state = IndexedDB::TransactionState::Aborting;
1417 
1418     // Move operations out of m_pendingTransactionOperationQueue, otherwise we may start handling
1419     // them after we forcibly complete in-progress transactions.
1420     Deque&lt;RefPtr&lt;IDBClient::TransactionOperation&gt;&gt; pendingTransactionOperationQueue;
1421     pendingTransactionOperationQueue.swap(m_pendingTransactionOperationQueue);
1422 
1423     abortInProgressOperations(error);
1424 
1425     auto operations = copyToVector(m_transactionOperationMap.values());
1426     for (auto&amp; operation : operations) {
1427         m_currentlyCompletingRequest = nullptr;
1428         m_transactionOperationsInProgressQueue.append(operation.get());
1429         ASSERT(m_transactionOperationsInProgressQueue.first() == operation.get());
1430         operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));
1431     }
1432     m_currentlyCompletingRequest = nullptr;
1433     m_openRequests.clear();
1434     pendingTransactionOperationQueue.clear();
1435 
1436     connectionProxy().forgetActiveOperations(operations);
1437     connectionProxy().forgetTransaction(*this);
1438 
1439     m_abortQueue.clear();
1440     m_transactionOperationMap.clear();
1441 
1442     m_idbError = error;
1443     m_domError = error.toDOMException();
1444     m_database-&gt;didAbortTransaction(*this);
1445     fireOnAbort();
1446 }
1447 
1448 void IDBTransaction::visitReferencedObjectStores(JSC::SlotVisitor&amp; visitor) const
1449 {
1450     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
1451     for (auto&amp; objectStore : m_referencedObjectStores.values())
1452         visitor.addOpaqueRoot(objectStore.get());
1453     for (auto&amp; objectStore : m_deletedObjectStores.values())
1454         visitor.addOpaqueRoot(objectStore.get());
1455 }
1456 
1457 void IDBTransaction::handlePendingOperations()
1458 {
1459     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));
1460 
1461     if (!m_startedOnServer)
1462         return;
1463 
1464     if (!m_transactionOperationsInProgressQueue.isEmpty() &amp;&amp; !m_transactionOperationsInProgressQueue.last()-&gt;nextRequestCanGoToServer())
1465         return;
1466 
1467     while (!m_pendingTransactionOperationQueue.isEmpty()) {
1468         auto operation = m_pendingTransactionOperationQueue.takeFirst();
1469         m_transactionOperationsInProgressQueue.append(operation.get());
1470         operation-&gt;perform();
1471 
1472         if (!operation-&gt;nextRequestCanGoToServer())
1473             break;
1474     }
1475 }
1476 
1477 void IDBTransaction::autoCommit()
1478 {
1479     // If transaction is not inactive, it&#39;s active, finished or finishing.
1480     // If it&#39;s active, it may create new requests, so we cannot commit it.
1481     if (m_state != IndexedDB::TransactionState::Inactive)
1482         return;
1483 
1484     if (!m_startedOnServer)
1485         return;
1486 
1487     if (!m_transactionOperationMap.isEmpty())
1488         return;
1489 
1490     if (!m_openRequests.isEmpty())
1491         return;
1492     ASSERT(!m_currentlyCompletingRequest);
1493 
1494     commit();
1495 }
1496 
1497 uint64_t IDBTransaction::generateOperationID()
1498 {
1499     static std::atomic&lt;uint64_t&gt; currentOperationID(1);
1500     return currentOperationID += 1;
1501 }
1502 
1503 } // namespace WebCore
1504 
1505 #endif // ENABLE(INDEXED_DATABASE)
    </pre>
  </body>
</html>
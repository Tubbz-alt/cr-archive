<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGStrengthReductionPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGStrengthReductionPhase.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;DFGAbstractHeap.h&quot;
  32 #include &quot;DFGClobberize.h&quot;
  33 #include &quot;DFGGraph.h&quot;
  34 #include &quot;DFGInsertionSet.h&quot;
  35 #include &quot;DFGPhase.h&quot;
  36 #include &quot;DFGPredictionPropagationPhase.h&quot;
  37 #include &quot;DFGVariableAccessDataDump.h&quot;
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;MathCommon.h&quot;
  40 #include &quot;RegExpObject.h&quot;
  41 #include &quot;StringPrototype.h&quot;
  42 #include &lt;cstdlib&gt;
  43 #include &lt;wtf/text/StringBuilder.h&gt;
  44 
  45 namespace JSC { namespace DFG {
  46 
  47 class StrengthReductionPhase : public Phase {
<a name="2" id="anc2"></a><span class="line-modified">  48     static constexpr bool verbose = false;</span>
  49 
  50 public:
  51     StrengthReductionPhase(Graph&amp; graph)
  52         : Phase(graph, &quot;strength reduction&quot;)
  53         , m_insertionSet(graph)
  54     {
  55     }
  56 
  57     bool run()
  58     {
  59         ASSERT(m_graph.m_fixpointState == FixpointNotConverged);
  60 
  61         m_changed = false;
  62 
  63         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
  64             m_block = m_graph.block(blockIndex);
  65             if (!m_block)
  66                 continue;
  67             for (m_nodeIndex = 0; m_nodeIndex &lt; m_block-&gt;size(); ++m_nodeIndex) {
  68                 m_node = m_block-&gt;at(m_nodeIndex);
  69                 handleNode();
  70             }
  71             m_insertionSet.execute(m_block);
  72         }
  73 
  74         return m_changed;
  75     }
  76 
  77 private:
  78     void handleNode()
  79     {
  80         switch (m_node-&gt;op()) {
  81         case ArithBitOr:
  82             handleCommutativity();
  83 
  84             if (m_node-&gt;child1().useKind() != UntypedUse &amp;&amp; m_node-&gt;child2()-&gt;isInt32Constant() &amp;&amp; !m_node-&gt;child2()-&gt;asInt32()) {
  85                 convertToIdentityOverChild1();
  86                 break;
  87             }
  88             break;
  89 
  90         case ArithBitXor:
  91         case ArithBitAnd:
  92             handleCommutativity();
  93             break;
  94 
  95         case ArithBitLShift:
<a name="3" id="anc3"></a><span class="line-modified">  96         case ArithBitRShift:</span>
  97         case BitURShift:
  98             if (m_node-&gt;child1().useKind() != UntypedUse &amp;&amp; m_node-&gt;child2()-&gt;isInt32Constant() &amp;&amp; !(m_node-&gt;child2()-&gt;asInt32() &amp; 0x1f)) {
  99                 convertToIdentityOverChild1();
 100                 break;
 101             }
 102             break;
 103 
 104         case UInt32ToNumber:
 105             if (m_node-&gt;child1()-&gt;op() == BitURShift
 106                 &amp;&amp; m_node-&gt;child1()-&gt;child2()-&gt;isInt32Constant()
 107                 &amp;&amp; (m_node-&gt;child1()-&gt;child2()-&gt;asInt32() &amp; 0x1f)
 108                 &amp;&amp; m_node-&gt;arithMode() != Arith::DoOverflow) {
 109                 m_node-&gt;convertToIdentity();
 110                 m_changed = true;
 111                 break;
 112             }
 113             break;
 114 
 115         case ArithAdd:
 116             handleCommutativity();
 117 
 118             if (m_node-&gt;child2()-&gt;isInt32Constant() &amp;&amp; !m_node-&gt;child2()-&gt;asInt32()) {
 119                 convertToIdentityOverChild1();
 120                 break;
 121             }
 122             break;
 123 
 124         case ValueMul:
 125         case ValueBitOr:
 126         case ValueBitAnd:
 127         case ValueBitXor: {
 128             if (m_node-&gt;binaryUseKind() == BigIntUse)
 129                 handleCommutativity();
 130             break;
 131         }
 132 
 133         case ArithMul: {
 134             handleCommutativity();
 135             Edge&amp; child2 = m_node-&gt;child2();
 136             if (child2-&gt;isNumberConstant() &amp;&amp; child2-&gt;asNumber() == 2) {
 137                 switch (m_node-&gt;binaryUseKind()) {
 138                 case DoubleRepUse:
 139                     // It is always valuable to get rid of a double multiplication by 2.
 140                     // We won&#39;t have half-register dependencies issues on x86 and we won&#39;t have to load the constants.
 141                     m_node-&gt;setOp(ArithAdd);
 142                     child2.setNode(m_node-&gt;child1().node());
 143                     m_changed = true;
 144                     break;
 145 #if USE(JSVALUE64)
 146                 case Int52RepUse:
 147 #endif
 148                 case Int32Use:
 149                     // For integers, we can only convert compatible modes.
 150                     // ArithAdd does handle do negative zero check for example.
 151                     if (m_node-&gt;arithMode() == Arith::CheckOverflow || m_node-&gt;arithMode() == Arith::Unchecked) {
 152                         m_node-&gt;setOp(ArithAdd);
 153                         child2.setNode(m_node-&gt;child1().node());
 154                         m_changed = true;
 155                     }
 156                     break;
 157                 default:
 158                     break;
 159                 }
 160             }
 161             break;
 162         }
 163         case ArithSub:
 164             if (m_node-&gt;child2()-&gt;isInt32Constant()
 165                 &amp;&amp; m_node-&gt;isBinaryUseKind(Int32Use)) {
 166                 int32_t value = m_node-&gt;child2()-&gt;asInt32();
 167                 if (value != INT32_MIN) {
 168                     m_node-&gt;setOp(ArithAdd);
 169                     m_node-&gt;child2().setNode(
 170                         m_insertionSet.insertConstant(
 171                             m_nodeIndex, m_node-&gt;origin, jsNumber(-value)));
 172                     m_changed = true;
 173                     break;
 174                 }
 175             }
 176             break;
 177 
 178         case ArithPow:
 179             if (m_node-&gt;child2()-&gt;isNumberConstant()) {
 180                 double yOperandValue = m_node-&gt;child2()-&gt;asNumber();
 181                 if (yOperandValue == 1) {
 182                     convertToIdentityOverChild1();
 183                     m_changed = true;
 184                 } else if (yOperandValue == 2) {
 185                     m_node-&gt;setOp(ArithMul);
 186                     m_node-&gt;child2() = m_node-&gt;child1();
 187                     m_changed = true;
 188                 }
 189             }
 190             break;
 191 
 192         case ArithMod:
 193             // On Integers
 194             // In: ArithMod(ArithMod(x, const1), const2)
 195             // Out: Identity(ArithMod(x, const1))
 196             //     if const1 &lt;= const2.
 197             if (m_node-&gt;binaryUseKind() == Int32Use
 198                 &amp;&amp; m_node-&gt;child2()-&gt;isInt32Constant()
 199                 &amp;&amp; m_node-&gt;child1()-&gt;op() == ArithMod
 200                 &amp;&amp; m_node-&gt;child1()-&gt;binaryUseKind() == Int32Use
 201                 &amp;&amp; m_node-&gt;child1()-&gt;child2()-&gt;isInt32Constant()
 202                 &amp;&amp; std::abs(m_node-&gt;child1()-&gt;child2()-&gt;asInt32()) &lt;= std::abs(m_node-&gt;child2()-&gt;asInt32())) {
 203                     convertToIdentityOverChild1();
 204             }
 205             break;
 206 
 207         case ArithDiv:
 208             // Transform
 209             //    ArithDiv(x, constant)
 210             // Into
 211             //    ArithMul(x, 1 / constant)
 212             // if the operation has the same result.
 213             if (m_node-&gt;isBinaryUseKind(DoubleRepUse)
 214                 &amp;&amp; m_node-&gt;child2()-&gt;isNumberConstant()) {
 215 
 216                 if (Optional&lt;double&gt; reciprocal = safeReciprocalForDivByConst(m_node-&gt;child2()-&gt;asNumber())) {
 217                     Node* reciprocalNode = m_insertionSet.insertConstant(m_nodeIndex, m_node-&gt;origin, jsDoubleNumber(*reciprocal), DoubleConstant);
 218                     m_node-&gt;setOp(ArithMul);
 219                     m_node-&gt;child2() = Edge(reciprocalNode, DoubleRepUse);
 220                     m_changed = true;
 221                     break;
 222                 }
 223             }
 224             break;
 225 
 226         case ValueRep:
 227         case Int52Rep: {
 228             // This short-circuits circuitous conversions, like ValueRep(Int52Rep(value)).
 229 
 230             // The only speculation that we would do beyond validating that we have a type that
 231             // can be represented a certain way is an Int32 check that would appear on Int52Rep
 232             // nodes. For now, if we see this and the final type we want is an Int52, we use it
 233             // as an excuse not to fold. The only thing we would need is a Int52RepInt32Use kind.
 234             bool hadInt32Check = false;
 235             if (m_node-&gt;op() == Int52Rep) {
 236                 if (m_node-&gt;child1().useKind() != Int32Use)
 237                     break;
 238                 hadInt32Check = true;
 239             }
 240             for (Node* node = m_node-&gt;child1().node(); ; node = node-&gt;child1().node()) {
 241                 if (canonicalResultRepresentation(node-&gt;result()) ==
 242                     canonicalResultRepresentation(m_node-&gt;result())) {
 243                     m_insertionSet.insertCheck(m_graph, m_nodeIndex, m_node);
 244                     if (hadInt32Check) {
 245                         // FIXME: Consider adding Int52RepInt32Use or even DoubleRepInt32Use,
 246                         // which would be super weird. The latter would only arise in some
 247                         // seriously circuitous conversions.
 248                         if (canonicalResultRepresentation(node-&gt;result()) != NodeResultJS)
 249                             break;
 250 
 251                         m_insertionSet.insertCheck(
 252                             m_nodeIndex, m_node-&gt;origin, Edge(node, Int32Use));
 253                     }
 254                     m_node-&gt;child1() = node-&gt;defaultEdge();
 255                     m_node-&gt;convertToIdentity();
 256                     m_changed = true;
 257                     break;
 258                 }
 259 
 260                 switch (node-&gt;op()) {
 261                 case Int52Rep:
 262                     if (node-&gt;child1().useKind() != Int32Use)
 263                         break;
 264                     hadInt32Check = true;
 265                     continue;
 266 
 267                 case ValueRep:
 268                     continue;
 269 
 270                 default:
 271                     break;
 272                 }
 273                 break;
 274             }
 275             break;
 276         }
 277 
 278         case Flush: {
 279             ASSERT(m_graph.m_form != SSA);
 280 
 281             if (m_graph.willCatchExceptionInMachineFrame(m_node-&gt;origin.semantic)) {
 282                 // FIXME: We should be able to relax this:
 283                 // https://bugs.webkit.org/show_bug.cgi?id=150824
 284                 break;
 285             }
 286 
 287             Node* setLocal = nullptr;
<a name="4" id="anc4"></a><span class="line-modified"> 288             Operand operand = m_node-&gt;operand();</span>
 289 
 290             for (unsigned i = m_nodeIndex; i--;) {
 291                 Node* node = m_block-&gt;at(i);
 292 
<a name="5" id="anc5"></a><span class="line-modified"> 293                 if (node-&gt;op() == SetLocal &amp;&amp; node-&gt;operand() == operand) {</span>
 294                     setLocal = node;
 295                     break;
 296                 }
 297 
<a name="6" id="anc6"></a><span class="line-modified"> 298                 if (accessesOverlap(m_graph, node, AbstractHeap(Stack, operand)))</span>
 299                     break;
 300 
 301             }
 302 
 303             if (!setLocal)
 304                 break;
 305 
 306             // The Flush should become a PhantomLocal at this point. This means that we want the
 307             // local&#39;s value during OSR, but we don&#39;t care if the value is stored to the stack. CPS
 308             // rethreading can canonicalize PhantomLocals for us.
 309             m_node-&gt;convertFlushToPhantomLocal();
 310             m_graph.dethread();
 311             m_changed = true;
 312             break;
 313         }
 314 
 315         // FIXME: we should probably do this in constant folding but this currently relies on OSR exit history:
 316         // https://bugs.webkit.org/show_bug.cgi?id=154832
 317         case OverridesHasInstance: {
 318             if (!m_node-&gt;child2().node()-&gt;isCellConstant())
 319                 break;
 320 
 321             if (m_node-&gt;child2().node()-&gt;asCell() != m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;functionProtoHasInstanceSymbolFunction()) {
 322                 m_graph.convertToConstant(m_node, jsBoolean(true));
 323                 m_changed = true;
 324 
 325             } else if (!m_graph.hasExitSite(m_node-&gt;origin.semantic, BadTypeInfoFlags)) {
 326                 // We optimistically assume that we will not see a function that has a custom instanceof operation as they should be rare.
 327                 m_insertionSet.insertNode(m_nodeIndex, SpecNone, CheckTypeInfoFlags, m_node-&gt;origin, OpInfo(ImplementsDefaultHasInstance), Edge(m_node-&gt;child1().node(), CellUse));
 328                 m_graph.convertToConstant(m_node, jsBoolean(false));
 329                 m_changed = true;
 330             }
 331 
 332             break;
 333         }
 334 
 335         // FIXME: We have a lot of string constant-folding rules here. It would be great to
 336         // move these to the abstract interpreter once AbstractValue can support LazyJSValue.
 337         // https://bugs.webkit.org/show_bug.cgi?id=155204
 338 
 339         case ValueAdd: {
 340             if (m_node-&gt;child1()-&gt;isConstant()
 341                 &amp;&amp; m_node-&gt;child2()-&gt;isConstant()
 342                 &amp;&amp; (!!m_node-&gt;child1()-&gt;tryGetString(m_graph) || !!m_node-&gt;child2()-&gt;tryGetString(m_graph))) {
 343                 auto tryGetConstantString = [&amp;] (Node* node) -&gt; String {
 344                     String string = node-&gt;tryGetString(m_graph);
 345                     if (!string.isEmpty())
 346                         return string;
 347                     JSValue value = node-&gt;constant()-&gt;value();
 348                     if (!value)
 349                         return String();
 350                     if (value.isInt32())
 351                         return String::number(value.asInt32());
 352                     if (value.isNumber())
 353                         return String::number(value.asNumber());
 354                     if (value.isBoolean())
 355                         return value.asBoolean() ? &quot;true&quot;_s : &quot;false&quot;_s;
 356                     if (value.isNull())
 357                         return &quot;null&quot;_s;
 358                     if (value.isUndefined())
 359                         return &quot;undefined&quot;_s;
 360                     return String();
 361                 };
 362 
 363                 String leftString = tryGetConstantString(m_node-&gt;child1().node());
 364                 if (!leftString)
 365                     break;
 366                 String rightString = tryGetConstantString(m_node-&gt;child2().node());
 367                 if (!rightString)
 368                     break;
 369 
 370                 StringBuilder builder;
 371                 builder.append(leftString);
 372                 builder.append(rightString);
 373                 convertToLazyJSValue(m_node, LazyJSValue::newString(m_graph, builder.toString()));
 374                 m_changed = true;
 375                 break;
 376             }
 377 
 378             if (m_node-&gt;binaryUseKind() == BigIntUse)
 379                 handleCommutativity();
 380 
 381             break;
 382         }
 383 
 384         case MakeRope:
 385         case StrCat: {
 386             String leftString = m_node-&gt;child1()-&gt;tryGetString(m_graph);
 387             if (!leftString)
 388                 break;
 389             String rightString = m_node-&gt;child2()-&gt;tryGetString(m_graph);
 390             if (!rightString)
 391                 break;
 392             String extraString;
 393             if (m_node-&gt;child3()) {
 394                 extraString = m_node-&gt;child3()-&gt;tryGetString(m_graph);
 395                 if (!extraString)
 396                     break;
 397             }
 398 
 399             StringBuilder builder;
 400             builder.append(leftString);
 401             builder.append(rightString);
 402             if (!!extraString)
 403                 builder.append(extraString);
 404 
 405             convertToLazyJSValue(m_node, LazyJSValue::newString(m_graph, builder.toString()));
 406             m_changed = true;
 407             break;
 408         }
 409 
 410         case ToString:
 411         case CallStringConstructor: {
 412             Edge&amp; child1 = m_node-&gt;child1();
 413             switch (child1.useKind()) {
 414             case Int32Use:
 415             case Int52RepUse:
 416             case DoubleRepUse: {
 417                 if (child1-&gt;hasConstant()) {
 418                     JSValue value = child1-&gt;constant()-&gt;value();
 419                     if (value) {
 420                         String result;
 421                         if (value.isInt32())
 422                             result = String::number(value.asInt32());
 423                         else if (value.isNumber())
 424                             result = String::number(value.asNumber());
 425 
 426                         if (!result.isNull()) {
 427                             convertToLazyJSValue(m_node, LazyJSValue::newString(m_graph, result));
 428                             m_changed = true;
 429                         }
 430                     }
 431                 }
 432                 break;
 433             }
 434 
 435             default:
 436                 break;
 437             }
 438             break;
 439         }
 440 
 441         case NumberToStringWithValidRadixConstant: {
 442             Edge&amp; child1 = m_node-&gt;child1();
 443             if (child1-&gt;hasConstant()) {
 444                 JSValue value = child1-&gt;constant()-&gt;value();
 445                 if (value &amp;&amp; value.isNumber()) {
 446                     String result = toStringWithRadix(value.asNumber(), m_node-&gt;validRadixConstant());
 447                     convertToLazyJSValue(m_node, LazyJSValue::newString(m_graph, result));
 448                     m_changed = true;
 449                 }
 450             }
 451             break;
 452         }
 453 
 454         case GetArrayLength: {
 455             if (m_node-&gt;arrayMode().type() == Array::Generic
 456                 || m_node-&gt;arrayMode().type() == Array::String) {
 457                 String string = m_node-&gt;child1()-&gt;tryGetString(m_graph);
 458                 if (!!string) {
 459                     m_graph.convertToConstant(m_node, jsNumber(string.length()));
 460                     m_changed = true;
 461                     break;
 462                 }
 463             }
 464             break;
 465         }
 466 
 467         case GetGlobalObject: {
 468             if (JSObject* object = m_node-&gt;child1()-&gt;dynamicCastConstant&lt;JSObject*&gt;(vm())) {
 469                 m_graph.convertToConstant(m_node, object-&gt;globalObject(vm()));
 470                 m_changed = true;
 471                 break;
 472             }
 473             break;
 474         }
 475 
 476         case RegExpExec:
 477         case RegExpTest:
 478         case RegExpMatchFast:
 479         case RegExpExecNonGlobalOrSticky: {
 480             JSGlobalObject* globalObject = m_node-&gt;child1()-&gt;dynamicCastConstant&lt;JSGlobalObject*&gt;(vm());
 481             if (!globalObject) {
 482                 if (verbose)
 483                     dataLog(&quot;Giving up because no global object.\n&quot;);
 484                 break;
 485             }
 486 
 487             if (globalObject-&gt;isHavingABadTime()) {
 488                 if (verbose)
 489                     dataLog(&quot;Giving up because bad time.\n&quot;);
 490                 break;
 491             }
 492 
 493             Node* regExpObjectNode = nullptr;
 494             RegExp* regExp = nullptr;
 495             if (m_node-&gt;op() == RegExpExec || m_node-&gt;op() == RegExpTest || m_node-&gt;op() == RegExpMatchFast) {
 496                 regExpObjectNode = m_node-&gt;child2().node();
 497                 if (RegExpObject* regExpObject = regExpObjectNode-&gt;dynamicCastConstant&lt;RegExpObject*&gt;(vm()))
 498                     regExp = regExpObject-&gt;regExp();
 499                 else if (regExpObjectNode-&gt;op() == NewRegexp)
 500                     regExp = regExpObjectNode-&gt;castOperand&lt;RegExp*&gt;();
 501                 else {
 502                     if (verbose)
 503                         dataLog(&quot;Giving up because the regexp is unknown.\n&quot;);
 504                     break;
 505                 }
 506             } else
 507                 regExp = m_node-&gt;castOperand&lt;RegExp*&gt;();
 508 
 509             if (m_node-&gt;op() == RegExpMatchFast) {
 510                 if (regExp-&gt;global()) {
 511                     if (regExp-&gt;sticky())
 512                         break;
 513                     if (m_node-&gt;child3().useKind() != StringUse)
 514                         break;
 515                     NodeOrigin origin = m_node-&gt;origin;
 516                     m_insertionSet.insertNode(
 517                         m_nodeIndex, SpecNone, Check, origin, m_node-&gt;children.justChecks());
 518                     m_insertionSet.insertNode(
 519                         m_nodeIndex, SpecNone, SetRegExpObjectLastIndex, origin,
 520                         OpInfo(false),
 521                         Edge(regExpObjectNode, RegExpObjectUse),
 522                         m_insertionSet.insertConstantForUse(
 523                             m_nodeIndex, origin, jsNumber(0), UntypedUse));
 524                     origin = origin.withInvalidExit();
 525                     m_node-&gt;convertToRegExpMatchFastGlobalWithoutChecks(m_graph.freeze(regExp));
 526                     m_node-&gt;origin = origin;
 527                     m_changed = true;
 528                     break;
 529                 }
 530 
 531                 m_node-&gt;setOp(RegExpExec);
 532                 m_changed = true;
 533                 // Continue performing strength reduction onto RegExpExec node.
 534             }
 535 
 536             ASSERT(m_node-&gt;op() != RegExpMatchFast);
 537 
 538             auto foldToConstant = [&amp;] {
 539                 Node* stringNode = nullptr;
 540                 if (m_node-&gt;op() == RegExpExecNonGlobalOrSticky)
 541                     stringNode = m_node-&gt;child2().node();
 542                 else
 543                     stringNode = m_node-&gt;child3().node();
 544 
 545                 // NOTE: This mostly already protects us from having the compiler execute a regexp
 546                 // operation on a ginormous string by preventing us from getting our hands on ginormous
 547                 // strings in the first place.
 548                 String string = stringNode-&gt;tryGetString(m_graph);
 549                 if (!string) {
 550                     if (verbose)
 551                         dataLog(&quot;Giving up because the string is unknown.\n&quot;);
 552                     return false;
 553                 }
 554 
 555                 FrozenValue* regExpFrozenValue = m_graph.freeze(regExp);
 556 
 557                 // Refuse to do things with regular expressions that have a ginormous number of
 558                 // subpatterns.
 559                 unsigned ginormousNumberOfSubPatterns = 1000;
 560                 if (regExp-&gt;numSubpatterns() &gt; ginormousNumberOfSubPatterns) {
 561                     if (verbose)
 562                         dataLog(&quot;Giving up because of pattern limit.\n&quot;);
 563                     return false;
 564                 }
 565 
 566                 if ((m_node-&gt;op() == RegExpExec || m_node-&gt;op() == RegExpExecNonGlobalOrSticky) &amp;&amp; regExp-&gt;hasNamedCaptures()) {
 567                     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=176464
 568                     // Implement strength reduction optimization for named capture groups.
 569                     if (verbose)
 570                         dataLog(&quot;Giving up because of named capture groups.\n&quot;);
 571                     return false;
 572                 }
 573 
 574                 unsigned lastIndex;
 575                 if (regExp-&gt;globalOrSticky()) {
 576                     // This will only work if we can prove what the value of lastIndex is. To do this
 577                     // safely, we need to execute the insertion set so that we see any previous strength
 578                     // reductions. This is needed for soundness since otherwise the effectfulness of any
 579                     // previous strength reductions would be invisible to us.
 580                     ASSERT(regExpObjectNode);
 581                     executeInsertionSet();
 582                     lastIndex = UINT_MAX;
 583                     for (unsigned otherNodeIndex = m_nodeIndex; otherNodeIndex--;) {
 584                         Node* otherNode = m_block-&gt;at(otherNodeIndex);
 585                         if (otherNode == regExpObjectNode) {
 586                             lastIndex = 0;
 587                             break;
 588                         }
 589                         if (otherNode-&gt;op() == SetRegExpObjectLastIndex
 590                             &amp;&amp; otherNode-&gt;child1() == regExpObjectNode
 591                             &amp;&amp; otherNode-&gt;child2()-&gt;isInt32Constant()
 592                             &amp;&amp; otherNode-&gt;child2()-&gt;asInt32() &gt;= 0) {
 593                             lastIndex = static_cast&lt;unsigned&gt;(otherNode-&gt;child2()-&gt;asInt32());
 594                             break;
 595                         }
 596                         if (writesOverlap(m_graph, otherNode, RegExpObject_lastIndex))
 597                             break;
 598                     }
 599                     if (lastIndex == UINT_MAX) {
 600                         if (verbose)
 601                             dataLog(&quot;Giving up because the last index is not known.\n&quot;);
 602                         return false;
 603                     }
 604                 } else
 605                     lastIndex = 0;
 606 
 607                 m_graph.watchpoints().addLazily(globalObject-&gt;havingABadTimeWatchpoint());
 608 
<a name="7" id="anc7"></a><span class="line-modified"> 609                 Structure* structure = globalObject-&gt;regExpMatchesArrayStructure();</span>





 610                 if (structure-&gt;indexingType() != ArrayWithContiguous) {
 611                     // This is further protection against a race with haveABadTime.
 612                     if (verbose)
 613                         dataLog(&quot;Giving up because the structure has the wrong indexing type.\n&quot;);
 614                     return false;
 615                 }
 616                 m_graph.registerStructure(structure);
 617 
 618                 FrozenValue* globalObjectFrozenValue = m_graph.freeze(globalObject);
 619 
 620                 MatchResult result;
 621                 Vector&lt;int&gt; ovector;
 622                 // We have to call the kind of match function that the main thread would have called.
 623                 // Otherwise, we might not have the desired Yarr code compiled, and the match will fail.
 624                 if (m_node-&gt;op() == RegExpExec || m_node-&gt;op() == RegExpExecNonGlobalOrSticky) {
 625                     int position;
 626                     if (!regExp-&gt;matchConcurrently(vm(), string, lastIndex, position, ovector)) {
 627                         if (verbose)
 628                             dataLog(&quot;Giving up because match failed.\n&quot;);
 629                         return false;
 630                     }
 631                     result.start = position;
 632                     result.end = ovector[1];
 633                 } else {
 634                     if (!regExp-&gt;matchConcurrently(vm(), string, lastIndex, result)) {
 635                         if (verbose)
 636                             dataLog(&quot;Giving up because match failed.\n&quot;);
 637                         return false;
 638                     }
 639                 }
 640 
 641                 // We&#39;ve constant-folded the regexp. Now we&#39;re committed to replacing RegExpExec/Test.
 642 
 643                 m_changed = true;
 644 
 645                 NodeOrigin origin = m_node-&gt;origin;
 646 
 647                 m_insertionSet.insertNode(
 648                     m_nodeIndex, SpecNone, Check, origin, m_node-&gt;children.justChecks());
 649 
 650                 if (m_node-&gt;op() == RegExpExec || m_node-&gt;op() == RegExpExecNonGlobalOrSticky) {
 651                     if (result) {
 652                         RegisteredStructureSet* structureSet = m_graph.addStructureSet(structure);
 653 
 654                         // Create an array modeling the JS array that we will try to allocate. This is
 655                         // basically createRegExpMatchesArray but over C++ strings instead of JSStrings.
 656                         Vector&lt;String&gt; resultArray;
 657                         resultArray.append(string.substring(result.start, result.end - result.start));
 658                         for (unsigned i = 1; i &lt;= regExp-&gt;numSubpatterns(); ++i) {
 659                             int start = ovector[2 * i];
 660                             if (start &gt;= 0)
 661                                 resultArray.append(string.substring(start, ovector[2 * i + 1] - start));
 662                             else
 663                                 resultArray.append(String());
 664                         }
 665 
 666                         unsigned publicLength = resultArray.size();
 667                         unsigned vectorLength =
 668                             Butterfly::optimalContiguousVectorLength(structure, publicLength);
 669 
 670                         UniquedStringImpl* indexUID = vm().propertyNames-&gt;index.impl();
 671                         UniquedStringImpl* inputUID = vm().propertyNames-&gt;input.impl();
<a name="8" id="anc8"></a><span class="line-added"> 672                         UniquedStringImpl* groupsUID = vm().propertyNames-&gt;groups.impl();</span>
 673                         unsigned indexIndex = m_graph.identifiers().ensure(indexUID);
 674                         unsigned inputIndex = m_graph.identifiers().ensure(inputUID);
<a name="9" id="anc9"></a><span class="line-added"> 675                         unsigned groupsIndex = m_graph.identifiers().ensure(groupsUID);</span>
 676 
 677                         unsigned firstChild = m_graph.m_varArgChildren.size();
 678                         m_graph.m_varArgChildren.append(
 679                             m_insertionSet.insertConstantForUse(
 680                                 m_nodeIndex, origin, structure, KnownCellUse));
 681                         ObjectMaterializationData* data = m_graph.m_objectMaterializationData.add();
 682 
 683                         m_graph.m_varArgChildren.append(
 684                             m_insertionSet.insertConstantForUse(
 685                                 m_nodeIndex, origin, jsNumber(publicLength), KnownInt32Use));
 686                         data-&gt;m_properties.append(PublicLengthPLoc);
 687 
 688                         m_graph.m_varArgChildren.append(
 689                             m_insertionSet.insertConstantForUse(
 690                                 m_nodeIndex, origin, jsNumber(vectorLength), KnownInt32Use));
 691                         data-&gt;m_properties.append(VectorLengthPLoc);
 692 
 693                         m_graph.m_varArgChildren.append(
 694                             m_insertionSet.insertConstantForUse(
 695                                 m_nodeIndex, origin, jsNumber(result.start), UntypedUse));
 696                         data-&gt;m_properties.append(
 697                             PromotedLocationDescriptor(NamedPropertyPLoc, indexIndex));
 698 
 699                         m_graph.m_varArgChildren.append(Edge(stringNode, UntypedUse));
 700                         data-&gt;m_properties.append(
 701                             PromotedLocationDescriptor(NamedPropertyPLoc, inputIndex));
 702 
<a name="10" id="anc10"></a><span class="line-added"> 703                         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=176464</span>
<span class="line-added"> 704                         // Implement strength reduction optimization for named capture groups.</span>
<span class="line-added"> 705                         m_graph.m_varArgChildren.append(</span>
<span class="line-added"> 706                             m_insertionSet.insertConstantForUse(</span>
<span class="line-added"> 707                                 m_nodeIndex, origin, jsUndefined(), UntypedUse));</span>
<span class="line-added"> 708                         data-&gt;m_properties.append(</span>
<span class="line-added"> 709                             PromotedLocationDescriptor(NamedPropertyPLoc, groupsIndex));</span>
<span class="line-added"> 710 </span>
 711                         auto materializeString = [&amp;] (const String&amp; string) -&gt; Node* {
 712                             if (string.isNull())
 713                                 return nullptr;
 714                             if (string.isEmpty()) {
 715                                 return m_insertionSet.insertConstant(
 716                                     m_nodeIndex, origin, vm().smallStrings.emptyString());
 717                             }
 718                             LazyJSValue value = LazyJSValue::newString(m_graph, string);
 719                             return m_insertionSet.insertNode(
 720                                 m_nodeIndex, SpecNone, LazyJSConstant, origin,
 721                                 OpInfo(m_graph.m_lazyJSValues.add(value)));
 722                         };
 723 
 724                         for (unsigned i = 0; i &lt; resultArray.size(); ++i) {
 725                             if (Node* node = materializeString(resultArray[i])) {
 726                                 m_graph.m_varArgChildren.append(Edge(node, UntypedUse));
 727                                 data-&gt;m_properties.append(
 728                                     PromotedLocationDescriptor(IndexedPropertyPLoc, i));
 729                             }
 730                         }
 731 
 732                         Node* resultNode = m_insertionSet.insertNode(
 733                             m_nodeIndex, SpecArray, Node::VarArg, MaterializeNewObject, origin,
 734                             OpInfo(structureSet), OpInfo(data), firstChild,
 735                             m_graph.m_varArgChildren.size() - firstChild);
 736 
 737                         m_node-&gt;convertToIdentityOn(resultNode);
 738                     } else
 739                         m_graph.convertToConstant(m_node, jsNull());
 740                 } else
 741                     m_graph.convertToConstant(m_node, jsBoolean(!!result));
 742 
 743                 // Whether it&#39;s Exec or Test, we need to tell the globalObject and RegExpObject what&#39;s up.
 744                 // Because SetRegExpObjectLastIndex may exit and it clobbers exit state, we do that
 745                 // first.
 746 
 747                 if (regExp-&gt;globalOrSticky()) {
 748                     ASSERT(regExpObjectNode);
 749                     m_insertionSet.insertNode(
 750                         m_nodeIndex, SpecNone, SetRegExpObjectLastIndex, origin,
 751                         OpInfo(false),
 752                         Edge(regExpObjectNode, RegExpObjectUse),
 753                         m_insertionSet.insertConstantForUse(
 754                             m_nodeIndex, origin, jsNumber(result ? result.end : 0), UntypedUse));
 755 
 756                     origin = origin.withInvalidExit();
 757                 }
 758 
 759                 if (result) {
 760                     unsigned firstChild = m_graph.m_varArgChildren.size();
 761                     m_graph.m_varArgChildren.append(
 762                         m_insertionSet.insertConstantForUse(
 763                             m_nodeIndex, origin, globalObjectFrozenValue, KnownCellUse));
 764                     m_graph.m_varArgChildren.append(
 765                         m_insertionSet.insertConstantForUse(
 766                             m_nodeIndex, origin, regExpFrozenValue, KnownCellUse));
 767                     m_graph.m_varArgChildren.append(Edge(stringNode, KnownCellUse));
 768                     m_graph.m_varArgChildren.append(
 769                         m_insertionSet.insertConstantForUse(
 770                             m_nodeIndex, origin, jsNumber(result.start), KnownInt32Use));
 771                     m_graph.m_varArgChildren.append(
 772                         m_insertionSet.insertConstantForUse(
 773                             m_nodeIndex, origin, jsNumber(result.end), KnownInt32Use));
 774                     m_insertionSet.insertNode(
 775                         m_nodeIndex, SpecNone, Node::VarArg, RecordRegExpCachedResult, origin,
 776                         OpInfo(), OpInfo(), firstChild, m_graph.m_varArgChildren.size() - firstChild);
 777 
 778                     origin = origin.withInvalidExit();
 779                 }
 780 
 781                 m_node-&gt;origin = origin;
 782                 return true;
 783             };
 784 
 785             auto convertToStatic = [&amp;] {
 786                 if (m_node-&gt;op() != RegExpExec)
 787                     return false;
 788                 if (regExp-&gt;globalOrSticky())
 789                     return false;
 790                 if (m_node-&gt;child3().useKind() != StringUse)
 791                     return false;
 792                 NodeOrigin origin = m_node-&gt;origin;
 793                 m_insertionSet.insertNode(
 794                     m_nodeIndex, SpecNone, Check, origin, m_node-&gt;children.justChecks());
 795                 m_node-&gt;convertToRegExpExecNonGlobalOrStickyWithoutChecks(m_graph.freeze(regExp));
 796                 m_changed = true;
 797                 return true;
 798             };
 799 
 800             if (foldToConstant())
 801                 break;
 802 
 803             if (convertToStatic())
 804                 break;
 805 
 806             break;
 807         }
 808 
 809         case StringReplace:
 810         case StringReplaceRegExp: {
 811             Node* stringNode = m_node-&gt;child1().node();
 812             String string = stringNode-&gt;tryGetString(m_graph);
 813             if (!string)
 814                 break;
 815 
 816             Node* regExpObjectNode = m_node-&gt;child2().node();
 817             RegExp* regExp;
 818             if (RegExpObject* regExpObject = regExpObjectNode-&gt;dynamicCastConstant&lt;RegExpObject*&gt;(vm()))
 819                 regExp = regExpObject-&gt;regExp();
 820             else if (regExpObjectNode-&gt;op() == NewRegexp)
 821                 regExp = regExpObjectNode-&gt;castOperand&lt;RegExp*&gt;();
 822             else {
 823                 if (verbose)
 824                     dataLog(&quot;Giving up because the regexp is unknown.\n&quot;);
 825                 break;
 826             }
 827 
 828             String replace = m_node-&gt;child3()-&gt;tryGetString(m_graph);
 829             if (!replace)
 830                 break;
 831 
 832             StringBuilder builder;
 833 
 834             unsigned lastIndex = 0;
 835             unsigned startPosition = 0;
 836             bool ok = true;
 837             do {
 838                 MatchResult result;
 839                 Vector&lt;int&gt; ovector;
 840                 // Model which version of match() is called by the main thread.
 841                 if (replace.isEmpty() &amp;&amp; regExp-&gt;global()) {
 842                     if (!regExp-&gt;matchConcurrently(vm(), string, startPosition, result)) {
 843                         ok = false;
 844                         break;
 845                     }
 846                 } else {
 847                     int position;
 848                     if (!regExp-&gt;matchConcurrently(vm(), string, startPosition, position, ovector)) {
 849                         ok = false;
 850                         break;
 851                     }
 852 
 853                     result.start = position;
 854                     result.end = ovector[1];
 855                 }
 856 
 857                 if (!result)
 858                     break;
 859 
 860                 unsigned replLen = replace.length();
 861                 if (lastIndex &lt; result.start || replLen) {
 862                     builder.appendSubstring(string, lastIndex, result.start - lastIndex);
 863                     if (replLen) {
 864                         StringBuilder replacement;
 865                         substituteBackreferences(replacement, replace, string, ovector.data(), regExp);
 866                         builder.append(replacement);
 867                     }
 868                 }
 869 
 870                 lastIndex = result.end;
 871                 startPosition = lastIndex;
 872 
 873                 // special case of empty match
 874                 if (result.empty()) {
 875                     startPosition++;
 876                     if (startPosition &gt; string.length())
 877                         break;
 878                 }
 879             } while (regExp-&gt;global());
 880             if (!ok)
 881                 break;
 882 
 883             // We are committed at this point.
 884             m_changed = true;
 885 
 886             NodeOrigin origin = m_node-&gt;origin;
 887 
 888             // Preserve any checks we have.
 889             m_insertionSet.insertNode(
 890                 m_nodeIndex, SpecNone, Check, origin, m_node-&gt;children.justChecks());
 891 
 892             if (regExp-&gt;global()) {
 893                 m_insertionSet.insertNode(
 894                     m_nodeIndex, SpecNone, SetRegExpObjectLastIndex, origin,
 895                     OpInfo(false),
 896                     Edge(regExpObjectNode, RegExpObjectUse),
 897                     m_insertionSet.insertConstantForUse(
 898                         m_nodeIndex, origin, jsNumber(0), UntypedUse));
 899 
 900                 origin = origin.withInvalidExit();
 901             }
 902 
 903             if (!lastIndex &amp;&amp; builder.isEmpty())
 904                 m_node-&gt;convertToIdentityOn(stringNode);
 905             else {
<a name="11" id="anc11"></a><span class="line-modified"> 906                 builder.appendSubstring(string, lastIndex);</span>


 907                 m_node-&gt;convertToLazyJSConstant(m_graph, LazyJSValue::newString(m_graph, builder.toString()));
 908             }
 909 
 910             m_node-&gt;origin = origin;
 911             break;
 912         }
 913 
 914         case Call:
 915         case Construct:
 916         case TailCallInlinedCaller:
 917         case TailCall: {
 918             ExecutableBase* executable = nullptr;
 919             Edge callee = m_graph.varArgChild(m_node, 0);
 920             CallVariant callVariant;
 921             if (JSFunction* function = callee-&gt;dynamicCastConstant&lt;JSFunction*&gt;(vm())) {
 922                 executable = function-&gt;executable();
 923                 callVariant = CallVariant(function);
 924             } else if (callee-&gt;isFunctionAllocation()) {
 925                 executable = callee-&gt;castOperand&lt;FunctionExecutable*&gt;();
 926                 callVariant = CallVariant(executable);
 927             }
 928 
 929             if (!executable)
 930                 break;
 931 
 932             if (FunctionExecutable* functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm(), executable)) {
 933                 if (m_node-&gt;op() == Construct &amp;&amp; functionExecutable-&gt;constructAbility() == ConstructAbility::CannotConstruct)
 934                     break;
 935 
 936                 // We need to update m_parameterSlots before we get to the backend, but we don&#39;t
 937                 // want to do too much of this.
 938                 unsigned numAllocatedArgs =
 939                     static_cast&lt;unsigned&gt;(functionExecutable-&gt;parameterCount()) + 1;
 940 
 941                 if (numAllocatedArgs &lt;= Options::maximumDirectCallStackSize()) {
 942                     m_graph.m_parameterSlots = std::max(
 943                         m_graph.m_parameterSlots,
 944                         Graph::parameterSlotsForArgCount(numAllocatedArgs));
 945                 }
 946             }
 947 
 948             m_graph.m_plan.recordedStatuses().addCallLinkStatus(m_node-&gt;origin.semantic, CallLinkStatus(callVariant));
 949 
 950             m_node-&gt;convertToDirectCall(m_graph.freeze(executable));
 951             m_changed = true;
 952             break;
 953         }
 954 
 955         default:
 956             break;
 957         }
 958     }
 959 
 960     void convertToIdentityOverChild(unsigned childIndex)
 961     {
 962         ASSERT(!(m_node-&gt;flags() &amp; NodeHasVarArgs));
 963         m_insertionSet.insertCheck(m_graph, m_nodeIndex, m_node);
 964         m_node-&gt;children.removeEdge(childIndex ^ 1);
 965         m_node-&gt;convertToIdentity();
 966         m_changed = true;
 967     }
 968 
 969     void convertToIdentityOverChild1()
 970     {
 971         convertToIdentityOverChild(0);
 972     }
 973 
 974     void convertToIdentityOverChild2()
 975     {
 976         convertToIdentityOverChild(1);
 977     }
 978 
 979     void convertToLazyJSValue(Node* node, LazyJSValue value)
 980     {
 981         m_insertionSet.insertCheck(m_graph, m_nodeIndex, node);
 982         node-&gt;convertToLazyJSConstant(m_graph, value);
 983     }
 984 
 985     void handleCommutativity()
 986     {
 987         // It&#39;s definitely not sound to swap the lhs and rhs when we may be performing effectful
 988         // calls on the lhs/rhs for valueOf.
 989         if (m_node-&gt;child1().useKind() == UntypedUse || m_node-&gt;child2().useKind() == UntypedUse)
 990             return;
 991 
 992         // If the right side is a constant then there is nothing left to do.
 993         if (m_node-&gt;child2()-&gt;hasConstant())
 994             return;
 995 
 996         // This case ensures that optimizations that look for x + const don&#39;t also have
 997         // to look for const + x.
 998         if (m_node-&gt;child1()-&gt;hasConstant() &amp;&amp; !m_node-&gt;child1()-&gt;asJSValue().isCell()) {
 999             std::swap(m_node-&gt;child1(), m_node-&gt;child2());
1000             m_changed = true;
1001             return;
1002         }
1003 
1004         // This case ensures that CSE is commutativity-aware.
1005         if (m_node-&gt;child1().node() &gt; m_node-&gt;child2().node()) {
1006             std::swap(m_node-&gt;child1(), m_node-&gt;child2());
1007             m_changed = true;
1008             return;
1009         }
1010     }
1011 
1012     void executeInsertionSet()
1013     {
1014         m_nodeIndex += m_insertionSet.execute(m_block);
1015     }
1016 
1017     InsertionSet m_insertionSet;
1018     BasicBlock* m_block;
1019     unsigned m_nodeIndex;
1020     Node* m_node;
1021     bool m_changed;
1022 };
1023 
1024 bool performStrengthReduction(Graph&amp; graph)
1025 {
1026     return runPhase&lt;StrengthReductionPhase&gt;(graph);
1027 }
1028 
1029 } } // namespace JSC::DFG
1030 
1031 #endif // ENABLE(DFG_JIT)
1032 
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/HTMLElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  * Copyright (C) 2004-2018 Apple Inc. All rights reserved.
   5  * Copyright (C) 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   6  * Copyright (C) 2011 Motorola Mobility. All rights reserved.
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;HTMLElement.h&quot;
  27 
  28 #include &quot;CSSMarkup.h&quot;
  29 #include &quot;CSSPropertyNames.h&quot;
  30 #include &quot;CSSValueKeywords.h&quot;
  31 #include &quot;CSSValuePool.h&quot;
  32 #include &quot;Chrome.h&quot;
  33 #include &quot;ChromeClient.h&quot;
  34 #include &quot;DOMTokenList.h&quot;
  35 #include &quot;DocumentFragment.h&quot;
  36 #include &quot;ElementAncestorIterator.h&quot;
  37 #include &quot;EnterKeyHint.h&quot;
  38 #include &quot;Event.h&quot;
  39 #include &quot;EventListener.h&quot;
  40 #include &quot;EventNames.h&quot;
  41 #include &quot;Frame.h&quot;
  42 #include &quot;FrameLoader.h&quot;
  43 #include &quot;FrameView.h&quot;
  44 #include &quot;HTMLBDIElement.h&quot;
  45 #include &quot;HTMLBRElement.h&quot;
  46 #include &quot;HTMLButtonElement.h&quot;
  47 #include &quot;HTMLCollection.h&quot;
  48 #include &quot;HTMLDocument.h&quot;
  49 #include &quot;HTMLElementFactory.h&quot;
  50 #include &quot;HTMLFieldSetElement.h&quot;
  51 #include &quot;HTMLFormElement.h&quot;
  52 #include &quot;HTMLInputElement.h&quot;
  53 #include &quot;HTMLNames.h&quot;
  54 #include &quot;HTMLOptGroupElement.h&quot;
  55 #include &quot;HTMLOptionElement.h&quot;
  56 #include &quot;HTMLParserIdioms.h&quot;
  57 #include &quot;HTMLSelectElement.h&quot;
  58 #include &quot;HTMLTextAreaElement.h&quot;
  59 #include &quot;HTMLTextFormControlElement.h&quot;
  60 #include &quot;NodeTraversal.h&quot;
  61 #include &quot;RenderElement.h&quot;
  62 #include &quot;ScriptController.h&quot;
  63 #include &quot;ShadowRoot.h&quot;
  64 #include &quot;SimulatedClick.h&quot;
  65 #include &quot;StyleProperties.h&quot;
  66 #include &quot;SubframeLoader.h&quot;
  67 #include &quot;Text.h&quot;
  68 #include &quot;XMLNames.h&quot;
  69 #include &quot;markup.h&quot;
  70 #include &lt;wtf/IsoMallocInlines.h&gt;
  71 #include &lt;wtf/NeverDestroyed.h&gt;
  72 #include &lt;wtf/StdLibExtras.h&gt;
  73 #include &lt;wtf/text/CString.h&gt;
  74 
  75 namespace WebCore {
  76 
  77 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLElement);
  78 
  79 using namespace HTMLNames;
  80 
  81 Ref&lt;HTMLElement&gt; HTMLElement::create(const QualifiedName&amp; tagName, Document&amp; document)
  82 {
  83     return adoptRef(*new HTMLElement(tagName, document));
  84 }
  85 
  86 String HTMLElement::nodeName() const
  87 {
  88     // FIXME: Would be nice to have an AtomString lookup based off uppercase
  89     // ASCII characters that does not have to copy the string on a hit in the hash.
  90     if (document().isHTMLDocument()) {
  91         if (LIKELY(!tagQName().hasPrefix()))
  92             return tagQName().localNameUpper();
  93         return Element::nodeName().convertToASCIIUppercase();
  94     }
  95     return Element::nodeName();
  96 }
  97 
  98 static inline CSSValueID unicodeBidiAttributeForDirAuto(HTMLElement&amp; element)
  99 {
 100     if (element.hasTagName(preTag) || element.hasTagName(textareaTag))
 101         return CSSValuePlaintext;
 102     // FIXME: For bdo element, dir=&quot;auto&quot; should result in &quot;bidi-override isolate&quot; but we don&#39;t support having multiple values in unicode-bidi yet.
 103     // See https://bugs.webkit.org/show_bug.cgi?id=73164.
 104     return CSSValueIsolate;
 105 }
 106 
 107 unsigned HTMLElement::parseBorderWidthAttribute(const AtomString&amp; value) const
 108 {
 109     if (auto optionalBorderWidth = parseHTMLNonNegativeInteger(value))
 110         return optionalBorderWidth.value();
 111 
 112     return hasTagName(tableTag) ? 1 : 0;
 113 }
 114 
 115 void HTMLElement::applyBorderAttributeToStyle(const AtomString&amp; value, MutableStyleProperties&amp; style)
 116 {
 117     addPropertyToPresentationAttributeStyle(style, CSSPropertyBorderWidth, parseBorderWidthAttribute(value), CSSUnitType::CSS_PX);
 118     addPropertyToPresentationAttributeStyle(style, CSSPropertyBorderStyle, CSSValueSolid);
 119 }
 120 
 121 void HTMLElement::mapLanguageAttributeToLocale(const AtomString&amp; value, MutableStyleProperties&amp; style)
 122 {
 123     if (!value.isEmpty()) {
 124         // Have to quote so the locale id is treated as a string instead of as a CSS keyword.
 125         addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitLocale, serializeString(value));
 126     } else {
 127         // The empty string means the language is explicitly unknown.
 128         addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitLocale, CSSValueAuto);
 129     }
 130 }
 131 
 132 bool HTMLElement::isPresentationAttribute(const QualifiedName&amp; name) const
 133 {
 134     if (name == alignAttr || name == contenteditableAttr || name == hiddenAttr || name == langAttr || name.matches(XMLNames::langAttr) || name == draggableAttr || name == dirAttr)
 135         return true;
 136     return StyledElement::isPresentationAttribute(name);
 137 }
 138 
 139 static bool isLTROrRTLIgnoringCase(const AtomString&amp; dirAttributeValue)
 140 {
 141     return equalLettersIgnoringASCIICase(dirAttributeValue, &quot;rtl&quot;) || equalLettersIgnoringASCIICase(dirAttributeValue, &quot;ltr&quot;);
 142 }
 143 
 144 enum class ContentEditableType {
 145     Inherit,
 146     True,
 147     False,
 148     PlaintextOnly
 149 };
 150 
 151 static inline ContentEditableType contentEditableType(const AtomString&amp; value)
 152 {
 153     if (value.isNull())
 154         return ContentEditableType::Inherit;
 155     if (value.isEmpty() || equalLettersIgnoringASCIICase(value, &quot;true&quot;))
 156         return ContentEditableType::True;
 157     if (equalLettersIgnoringASCIICase(value, &quot;false&quot;))
 158         return ContentEditableType::False;
 159     if (equalLettersIgnoringASCIICase(value, &quot;plaintext-only&quot;))
 160         return ContentEditableType::PlaintextOnly;
 161 
 162     return ContentEditableType::Inherit;
 163 }
 164 
 165 static ContentEditableType contentEditableType(const HTMLElement&amp; element)
 166 {
 167     return contentEditableType(element.attributeWithoutSynchronization(contenteditableAttr));
 168 }
 169 
 170 void HTMLElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)
 171 {
 172     if (name == alignAttr) {
 173         if (equalLettersIgnoringASCIICase(value, &quot;middle&quot;))
 174             addPropertyToPresentationAttributeStyle(style, CSSPropertyTextAlign, CSSValueCenter);
 175         else
 176             addPropertyToPresentationAttributeStyle(style, CSSPropertyTextAlign, value);
 177     } else if (name == contenteditableAttr) {
 178         CSSValueID userModifyValue = CSSValueReadWrite;
 179         switch (contentEditableType(value)) {
 180         case ContentEditableType::Inherit:
 181             return;
 182         case ContentEditableType::False:
 183             userModifyValue = CSSValueReadOnly;
 184             break;
 185         case ContentEditableType::PlaintextOnly:
 186             userModifyValue = CSSValueReadWritePlaintextOnly;
 187             FALLTHROUGH;
 188         case ContentEditableType::True:
 189             addPropertyToPresentationAttributeStyle(style, CSSPropertyWordWrap, CSSValueBreakWord);
 190             addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitNbspMode, CSSValueSpace);
 191             addPropertyToPresentationAttributeStyle(style, CSSPropertyLineBreak, CSSValueAfterWhiteSpace);
 192 #if PLATFORM(IOS_FAMILY)
 193             addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitTextSizeAdjust, CSSValueNone);
 194 #endif
 195             break;
 196         }
 197         addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitUserModify, userModifyValue);
 198     } else if (name == hiddenAttr) {
 199         addPropertyToPresentationAttributeStyle(style, CSSPropertyDisplay, CSSValueNone);
 200     } else if (name == draggableAttr) {
 201         if (equalLettersIgnoringASCIICase(value, &quot;true&quot;)) {
 202             addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitUserDrag, CSSValueElement);
 203             addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitUserSelect, CSSValueNone);
 204         } else if (equalLettersIgnoringASCIICase(value, &quot;false&quot;))
 205             addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitUserDrag, CSSValueNone);
 206     } else if (name == dirAttr) {
 207         if (equalLettersIgnoringASCIICase(value, &quot;auto&quot;))
 208             addPropertyToPresentationAttributeStyle(style, CSSPropertyUnicodeBidi, unicodeBidiAttributeForDirAuto(*this));
 209         else {
 210             if (isLTROrRTLIgnoringCase(value))
 211                 addPropertyToPresentationAttributeStyle(style, CSSPropertyDirection, value);
 212             if (!hasTagName(bdiTag) &amp;&amp; !hasTagName(bdoTag) &amp;&amp; !hasTagName(outputTag))
 213                 addPropertyToPresentationAttributeStyle(style, CSSPropertyUnicodeBidi, CSSValueEmbed);
 214         }
 215     } else if (name.matches(XMLNames::langAttr))
 216         mapLanguageAttributeToLocale(value, style);
 217     else if (name == langAttr) {
 218         // xml:lang has a higher priority than lang.
 219         if (!hasAttributeWithoutSynchronization(XMLNames::langAttr))
 220             mapLanguageAttributeToLocale(value, style);
 221     } else
 222         StyledElement::collectStyleForPresentationAttribute(name, value, style);
 223 }
 224 
 225 HTMLElement::EventHandlerNameMap HTMLElement::createEventHandlerNameMap()
 226 {
 227     EventHandlerNameMap map;
 228 
 229     static const QualifiedName* const table[] = {
 230         &amp;onabortAttr.get(),
 231         &amp;onanimationendAttr.get(),
 232         &amp;onanimationiterationAttr.get(),
 233         &amp;onanimationstartAttr.get(),
 234         &amp;onanimationcancelAttr.get(),
 235         &amp;onautocompleteAttr.get(),
 236         &amp;onautocompleteerrorAttr.get(),
 237         &amp;onbeforecopyAttr.get(),
 238         &amp;onbeforecutAttr.get(),
 239         &amp;onbeforeinputAttr.get(),
 240         &amp;onbeforeloadAttr.get(),
 241         &amp;onbeforepasteAttr.get(),
 242         &amp;onblurAttr.get(),
 243         &amp;oncanplayAttr.get(),
 244         &amp;oncanplaythroughAttr.get(),
 245         &amp;onchangeAttr.get(),
 246         &amp;onclickAttr.get(),
 247         &amp;oncontextmenuAttr.get(),
 248         &amp;oncopyAttr.get(),
 249         &amp;oncutAttr.get(),
 250         &amp;ondblclickAttr.get(),
 251         &amp;ondragAttr.get(),
 252         &amp;ondragendAttr.get(),
 253         &amp;ondragenterAttr.get(),
 254         &amp;ondragleaveAttr.get(),
 255         &amp;ondragoverAttr.get(),
 256         &amp;ondragstartAttr.get(),
 257         &amp;ondropAttr.get(),
 258         &amp;ondurationchangeAttr.get(),
 259         &amp;onemptiedAttr.get(),
 260         &amp;onendedAttr.get(),
 261         &amp;onerrorAttr.get(),
 262         &amp;onfocusAttr.get(),
 263         &amp;onfocusinAttr.get(),
 264         &amp;onfocusoutAttr.get(),
 265         &amp;ongesturechangeAttr.get(),
 266         &amp;ongestureendAttr.get(),
 267         &amp;ongesturestartAttr.get(),
 268         &amp;ongotpointercaptureAttr.get(),
 269         &amp;oninputAttr.get(),
 270         &amp;oninvalidAttr.get(),
 271         &amp;onkeydownAttr.get(),
 272         &amp;onkeypressAttr.get(),
 273         &amp;onkeyupAttr.get(),
 274         &amp;onloadAttr.get(),
 275         &amp;onloadeddataAttr.get(),
 276         &amp;onloadedmetadataAttr.get(),
 277         &amp;onloadstartAttr.get(),
 278         &amp;onlostpointercaptureAttr.get(),
 279         &amp;onmousedownAttr.get(),
 280         &amp;onmouseenterAttr.get(),
 281         &amp;onmouseleaveAttr.get(),
 282         &amp;onmousemoveAttr.get(),
 283         &amp;onmouseoutAttr.get(),
 284         &amp;onmouseoverAttr.get(),
 285         &amp;onmouseupAttr.get(),
 286         &amp;onmousewheelAttr.get(),
 287         &amp;onpasteAttr.get(),
 288         &amp;onpauseAttr.get(),
 289         &amp;onplayAttr.get(),
 290         &amp;onplayingAttr.get(),
 291         &amp;onpointerdownAttr.get(),
 292         &amp;onpointermoveAttr.get(),
 293         &amp;onpointerupAttr.get(),
 294         &amp;onpointercancelAttr.get(),
 295         &amp;onpointeroverAttr.get(),
 296         &amp;onpointeroutAttr.get(),
 297         &amp;onpointerenterAttr.get(),
 298         &amp;onpointerleaveAttr.get(),
 299         &amp;onprogressAttr.get(),
 300         &amp;onratechangeAttr.get(),
 301         &amp;onresetAttr.get(),
 302         &amp;onresizeAttr.get(),
 303         &amp;onscrollAttr.get(),
 304         &amp;onsearchAttr.get(),
 305         &amp;onseekedAttr.get(),
 306         &amp;onseekingAttr.get(),
 307         &amp;onselectAttr.get(),
 308         &amp;onselectstartAttr.get(),
 309         &amp;onstalledAttr.get(),
 310         &amp;onsubmitAttr.get(),
 311         &amp;onsuspendAttr.get(),
 312         &amp;ontimeupdateAttr.get(),
 313         &amp;ontoggleAttr.get(),
 314         &amp;ontouchcancelAttr.get(),
 315         &amp;ontouchendAttr.get(),
 316         &amp;ontouchforcechangeAttr.get(),
 317         &amp;ontouchmoveAttr.get(),
 318         &amp;ontouchstartAttr.get(),
 319         &amp;ontransitioncancelAttr.get(),
 320         &amp;ontransitionendAttr.get(),
 321         &amp;ontransitionrunAttr.get(),
 322         &amp;ontransitionstartAttr.get(),
 323         &amp;onvolumechangeAttr.get(),
 324         &amp;onwaitingAttr.get(),
 325         &amp;onwebkitbeginfullscreenAttr.get(),
 326         &amp;onwebkitcurrentplaybacktargetiswirelesschangedAttr.get(),
 327         &amp;onwebkitendfullscreenAttr.get(),
 328         &amp;onwebkitfullscreenchangeAttr.get(),
 329         &amp;onwebkitfullscreenerrorAttr.get(),
 330         &amp;onwebkitkeyaddedAttr.get(),
 331         &amp;onwebkitkeyerrorAttr.get(),
 332         &amp;onwebkitkeymessageAttr.get(),
 333         &amp;onwebkitmouseforcechangedAttr.get(),
 334         &amp;onwebkitmouseforcedownAttr.get(),
 335         &amp;onwebkitmouseforcewillbeginAttr.get(),
 336         &amp;onwebkitmouseforceupAttr.get(),
 337         &amp;onwebkitneedkeyAttr.get(),
 338         &amp;onwebkitplaybacktargetavailabilitychangedAttr.get(),
 339         &amp;onwebkitpresentationmodechangedAttr.get(),
 340         &amp;onwebkitwillrevealbottomAttr.get(),
 341         &amp;onwebkitwillrevealleftAttr.get(),
 342         &amp;onwebkitwillrevealrightAttr.get(),
 343         &amp;onwebkitwillrevealtopAttr.get(),
 344         &amp;onwheelAttr.get(),
 345     };
 346 
 347     populateEventHandlerNameMap(map, table);
 348 
 349     struct UnusualMapping {
 350         const QualifiedName&amp; attributeName;
 351         const AtomString&amp; eventName;
 352     };
 353 
 354     const UnusualMapping unusualPairsTable[] = {
 355         { onwebkitanimationendAttr, eventNames().webkitAnimationEndEvent },
 356         { onwebkitanimationiterationAttr, eventNames().webkitAnimationIterationEvent },
 357         { onwebkitanimationstartAttr, eventNames().webkitAnimationStartEvent },
 358         { onwebkittransitionendAttr, eventNames().webkitTransitionEndEvent },
 359     };
 360 
 361     for (auto&amp; entry : unusualPairsTable)
 362         map.add(entry.attributeName.localName().impl(), entry.eventName);
 363 
 364     return map;
 365 }
 366 
 367 void HTMLElement::populateEventHandlerNameMap(EventHandlerNameMap&amp; map, const QualifiedName* const table[], size_t tableSize)
 368 {
 369     for (size_t i = 0; i &lt; tableSize; ++i) {
 370         auto* entry = table[i];
 371 
 372         // FIXME: Would be nice to check these against the actual event names in eventNames().
 373         // Not obvious how to do that simply, though.
 374         auto&amp; attributeName = entry-&gt;localName();
 375 
 376         // Remove the &quot;on&quot; prefix. Requires some memory allocation and computing a hash, but by not
 377         // using pointers from eventNames(), the passed-in table can be initialized at compile time.
 378         AtomString eventName = attributeName.string().substring(2);
 379 
 380         map.add(attributeName.impl(), WTFMove(eventName));
 381     }
 382 }
 383 
 384 const AtomString&amp; HTMLElement::eventNameForEventHandlerAttribute(const QualifiedName&amp; attributeName, const EventHandlerNameMap&amp; map)
 385 {
 386     ASSERT(!attributeName.localName().isNull());
 387 
 388     // Event handler attributes have no namespace.
 389     if (!attributeName.namespaceURI().isNull())
 390         return nullAtom();
 391 
 392     // Fast early return for names that don&#39;t start with &quot;on&quot;.
 393     AtomStringImpl&amp; localName = *attributeName.localName().impl();
 394     if (localName.length() &lt; 3 || localName[0] != &#39;o&#39; || localName[1] != &#39;n&#39;)
 395         return nullAtom();
 396 
 397     auto it = map.find(&amp;localName);
 398     return it == map.end() ? nullAtom() : it-&gt;value;
 399 }
 400 
 401 const AtomString&amp; HTMLElement::eventNameForEventHandlerAttribute(const QualifiedName&amp; attributeName)
 402 {
 403     static NeverDestroyed&lt;EventHandlerNameMap&gt; map = createEventHandlerNameMap();
 404     return eventNameForEventHandlerAttribute(attributeName, map.get());
 405 }
 406 
 407 Node::Editability HTMLElement::editabilityFromContentEditableAttr(const Node&amp; node)
 408 {
 409     if (auto* startElement = is&lt;Element&gt;(node) ? &amp;downcast&lt;Element&gt;(node) : node.parentElement()) {
 410         for (auto&amp; element : lineageOfType&lt;HTMLElement&gt;(*startElement)) {
 411             switch (contentEditableType(element)) {
 412             case ContentEditableType::True:
 413                 return Editability::CanEditRichly;
 414             case ContentEditableType::PlaintextOnly:
 415                 return Editability::CanEditPlainText;
 416             case ContentEditableType::False:
 417                 return Editability::ReadOnly;
 418             case ContentEditableType::Inherit:
 419                 break;
 420             }
 421         }
 422     }
 423 
 424     auto containingShadowRoot = makeRefPtr(node.containingShadowRoot());
 425     if (containingShadowRoot &amp;&amp; containingShadowRoot-&gt;mode() == ShadowRootMode::UserAgent)
 426         return Editability::ReadOnly;
 427 
 428     auto&amp; document = node.document();
 429     if (is&lt;HTMLDocument&gt;(document))
 430         return downcast&lt;HTMLDocument&gt;(document).inDesignMode() ? Editability::CanEditRichly : Editability::ReadOnly;
 431 
 432     return Editability::ReadOnly;
 433 }
 434 
 435 bool HTMLElement::matchesReadWritePseudoClass() const
 436 {
 437     return editabilityFromContentEditableAttr(*this) != Editability::ReadOnly;
 438 }
 439 
 440 void HTMLElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 441 {
 442     if (name == dirAttr) {
 443         dirAttributeChanged(value);
 444         return;
 445     }
 446 
 447     if (name == tabindexAttr) {
 448         if (value.isEmpty())
 449             clearTabIndexExplicitlyIfNeeded();
 450         else if (auto optionalTabIndex = parseHTMLInteger(value))
 451             setTabIndexExplicitly(optionalTabIndex.value());
 452         return;
 453     }
 454 
 455     if (name == inputmodeAttr) {
 456         auto&amp; document = this-&gt;document();
 457         if (this == document.focusedElement()) {
 458             if (auto* page = document.page())
 459                 page-&gt;chrome().client().focusedElementDidChangeInputMode(*this, canonicalInputMode());
 460         }
 461     }
 462 
 463     auto&amp; eventName = eventNameForEventHandlerAttribute(name);
 464     if (!eventName.isNull())
 465         setAttributeEventListener(eventName, name, value);
 466 }
 467 
 468 static Ref&lt;DocumentFragment&gt; textToFragment(Document&amp; document, const String&amp; text)
 469 {
 470     auto fragment = DocumentFragment::create(document);
 471 
 472     // It&#39;s safe to dispatch events on the new fragment since author scripts have no access to it yet.
 473     ScriptDisallowedScope::EventAllowedScope allowedScope(fragment);
 474 
 475     for (unsigned start = 0, length = text.length(); start &lt; length; ) {
 476         // Find next line break.
 477         UChar c = 0;
 478         unsigned i;
 479         for (i = start; i &lt; length; i++) {
 480             c = text[i];
 481             if (c == &#39;\r&#39; || c == &#39;\n&#39;)
 482                 break;
 483         }
 484 
 485         // If text is not the empty string, then append a new Text node whose data is text and node document is document to fragment.
 486         if (i &gt; start)
 487             fragment-&gt;appendChild(Text::create(document, text.substring(start, i - start)));
 488 
 489         if (i == length)
 490             break;
 491 
 492         fragment-&gt;appendChild(HTMLBRElement::create(document));
 493         // Make sure \r\n doesn&#39;t result in two line breaks.
 494         if (c == &#39;\r&#39; &amp;&amp; i + 1 &lt; length &amp;&amp; text[i + 1] == &#39;\n&#39;)
 495             ++i;
 496 
 497         start = i + 1; // Character after line break.
 498     }
 499 
 500     return fragment;
 501 }
 502 
 503 // Returns the conforming &#39;dir&#39; value associated with the state the attribute is in (in its canonical case), if any,
 504 // or the empty string if the attribute is in a state that has no associated keyword value or if the attribute is
 505 // not in a defined state (e.g. the attribute is missing and there is no missing value default).
 506 // http://www.whatwg.org/specs/web-apps/current-work/multipage/common-dom-interfaces.html#limited-to-only-known-values
 507 static inline const AtomString&amp; toValidDirValue(const AtomString&amp; value)
 508 {
 509     static NeverDestroyed&lt;AtomString&gt; ltrValue(&quot;ltr&quot;, AtomString::ConstructFromLiteral);
 510     static NeverDestroyed&lt;AtomString&gt; rtlValue(&quot;rtl&quot;, AtomString::ConstructFromLiteral);
 511     static NeverDestroyed&lt;AtomString&gt; autoValue(&quot;auto&quot;, AtomString::ConstructFromLiteral);
 512     if (equalLettersIgnoringASCIICase(value, &quot;ltr&quot;))
 513         return ltrValue;
 514     if (equalLettersIgnoringASCIICase(value, &quot;rtl&quot;))
 515         return rtlValue;
 516     if (equalLettersIgnoringASCIICase(value, &quot;auto&quot;))
 517         return autoValue;
 518     return nullAtom();
 519 }
 520 
 521 const AtomString&amp; HTMLElement::dir() const
 522 {
 523     return toValidDirValue(attributeWithoutSynchronization(dirAttr));
 524 }
 525 
 526 void HTMLElement::setDir(const AtomString&amp; value)
 527 {
 528     setAttributeWithoutSynchronization(dirAttr, value);
 529 }
 530 
 531 ExceptionOr&lt;void&gt; HTMLElement::setInnerText(const String&amp; text)
 532 {
 533     // FIXME: This doesn&#39;t take whitespace collapsing into account at all.
 534 
 535     if (!text.contains(&#39;\n&#39;) &amp;&amp; !text.contains(&#39;\r&#39;)) {
 536         if (text.isEmpty())
 537             replaceAllChildren(nullptr);
 538         else
 539             replaceAllChildren(document().createTextNode(text));
 540         return { };
 541     }
 542 
 543     // FIXME: Do we need to be able to detect preserveNewline style even when there&#39;s no renderer?
 544     // FIXME: Can the renderer be out of date here? Do we need to call updateStyleIfNeeded?
 545     // For example, for the contents of textarea elements that are display:none?
 546     auto* r = renderer();
 547     if ((r &amp;&amp; r-&gt;style().preserveNewline()) || (isConnected() &amp;&amp; isTextControlInnerTextElement())) {
 548         if (!text.contains(&#39;\r&#39;)) {
 549             replaceAllChildren(document().createTextNode(text));
 550             return { };
 551         }
 552         String textWithConsistentLineBreaks = text;
 553         textWithConsistentLineBreaks.replace(&quot;\r\n&quot;, &quot;\n&quot;);
 554         textWithConsistentLineBreaks.replace(&#39;\r&#39;, &#39;\n&#39;);
 555         replaceAllChildren(document().createTextNode(textWithConsistentLineBreaks));
 556         return { };
 557     }
 558 
 559     // Add text nodes and &lt;br&gt; elements.
 560     auto fragment = textToFragment(document(), text);
 561     // FIXME: This should use replaceAllChildren() once it accepts DocumentFragments as input.
 562     // It&#39;s safe to dispatch events on the new fragment since author scripts have no access to it yet.
 563     ScriptDisallowedScope::EventAllowedScope allowedScope(fragment.get());
 564     return replaceChildrenWithFragment(*this, WTFMove(fragment));
 565 }
 566 
 567 ExceptionOr&lt;void&gt; HTMLElement::setOuterText(const String&amp; text)
 568 {
 569     RefPtr&lt;ContainerNode&gt; parent = parentNode();
 570     if (!parent)
 571         return Exception { NoModificationAllowedError };
 572 
 573     RefPtr&lt;Node&gt; prev = previousSibling();
 574     RefPtr&lt;Node&gt; next = nextSibling();
 575     RefPtr&lt;Node&gt; newChild;
 576 
 577     // Convert text to fragment with &lt;br&gt; tags instead of linebreaks if needed.
 578     if (text.contains(&#39;\r&#39;) || text.contains(&#39;\n&#39;))
 579         newChild = textToFragment(document(), text);
 580     else
 581         newChild = Text::create(document(), text);
 582 
 583     if (!parentNode())
 584         return Exception { HierarchyRequestError };
 585 
 586     auto replaceResult = parent-&gt;replaceChild(*newChild, *this);
 587     if (replaceResult.hasException())
 588         return replaceResult.releaseException();
 589 
 590     RefPtr&lt;Node&gt; node = next ? next-&gt;previousSibling() : nullptr;
 591     if (is&lt;Text&gt;(node)) {
 592         auto result = mergeWithNextTextNode(downcast&lt;Text&gt;(*node));
 593         if (result.hasException())
 594             return result.releaseException();
 595     }
 596     if (is&lt;Text&gt;(prev)) {
 597         auto result = mergeWithNextTextNode(downcast&lt;Text&gt;(*prev));
 598         if (result.hasException())
 599             return result.releaseException();
 600     }
 601     return { };
 602 }
 603 
 604 void HTMLElement::applyAlignmentAttributeToStyle(const AtomString&amp; alignment, MutableStyleProperties&amp; style)
 605 {
 606     // Vertical alignment with respect to the current baseline of the text
 607     // right or left means floating images.
 608     CSSValueID floatValue = CSSValueInvalid;
 609     CSSValueID verticalAlignValue = CSSValueInvalid;
 610 
 611     if (equalLettersIgnoringASCIICase(alignment, &quot;absmiddle&quot;))
 612         verticalAlignValue = CSSValueMiddle;
 613     else if (equalLettersIgnoringASCIICase(alignment, &quot;absbottom&quot;))
 614         verticalAlignValue = CSSValueBottom;
 615     else if (equalLettersIgnoringASCIICase(alignment, &quot;left&quot;)) {
 616         floatValue = CSSValueLeft;
 617         verticalAlignValue = CSSValueTop;
 618     } else if (equalLettersIgnoringASCIICase(alignment, &quot;right&quot;)) {
 619         floatValue = CSSValueRight;
 620         verticalAlignValue = CSSValueTop;
 621     } else if (equalLettersIgnoringASCIICase(alignment, &quot;top&quot;))
 622         verticalAlignValue = CSSValueTop;
 623     else if (equalLettersIgnoringASCIICase(alignment, &quot;middle&quot;))
 624         verticalAlignValue = CSSValueWebkitBaselineMiddle;
 625     else if (equalLettersIgnoringASCIICase(alignment, &quot;center&quot;))
 626         verticalAlignValue = CSSValueMiddle;
 627     else if (equalLettersIgnoringASCIICase(alignment, &quot;bottom&quot;))
 628         verticalAlignValue = CSSValueBaseline;
 629     else if (equalLettersIgnoringASCIICase(alignment, &quot;texttop&quot;))
 630         verticalAlignValue = CSSValueTextTop;
 631 
 632     if (floatValue != CSSValueInvalid)
 633         addPropertyToPresentationAttributeStyle(style, CSSPropertyFloat, floatValue);
 634 
 635     if (verticalAlignValue != CSSValueInvalid)
 636         addPropertyToPresentationAttributeStyle(style, CSSPropertyVerticalAlign, verticalAlignValue);
 637 }
 638 
 639 bool HTMLElement::hasCustomFocusLogic() const
 640 {
 641     return false;
 642 }
 643 
 644 bool HTMLElement::supportsFocus() const
 645 {
 646     return Element::supportsFocus() || (hasEditableStyle() &amp;&amp; parentNode() &amp;&amp; !parentNode()-&gt;hasEditableStyle());
 647 }
 648 
 649 String HTMLElement::contentEditable() const
 650 {
 651     switch (contentEditableType(*this)) {
 652     case ContentEditableType::Inherit:
 653         return &quot;inherit&quot;_s;
 654     case ContentEditableType::True:
 655         return &quot;true&quot;_s;
 656     case ContentEditableType::False:
 657         return &quot;false&quot;_s;
 658     case ContentEditableType::PlaintextOnly:
 659         return &quot;plaintext-only&quot;_s;
 660     }
 661     return &quot;inherit&quot;_s;
 662 }
 663 
 664 ExceptionOr&lt;void&gt; HTMLElement::setContentEditable(const String&amp; enabled)
 665 {
 666     if (equalLettersIgnoringASCIICase(enabled, &quot;true&quot;))
 667         setAttributeWithoutSynchronization(contenteditableAttr, AtomString(&quot;true&quot;, AtomString::ConstructFromLiteral));
 668     else if (equalLettersIgnoringASCIICase(enabled, &quot;false&quot;))
 669         setAttributeWithoutSynchronization(contenteditableAttr, AtomString(&quot;false&quot;, AtomString::ConstructFromLiteral));
 670     else if (equalLettersIgnoringASCIICase(enabled, &quot;plaintext-only&quot;))
 671         setAttributeWithoutSynchronization(contenteditableAttr, AtomString(&quot;plaintext-only&quot;, AtomString::ConstructFromLiteral));
 672     else if (equalLettersIgnoringASCIICase(enabled, &quot;inherit&quot;))
 673         removeAttribute(contenteditableAttr);
 674     else
 675         return Exception { SyntaxError };
 676     return { };
 677 }
 678 
 679 bool HTMLElement::draggable() const
 680 {
 681     return equalLettersIgnoringASCIICase(attributeWithoutSynchronization(draggableAttr), &quot;true&quot;);
 682 }
 683 
 684 void HTMLElement::setDraggable(bool value)
 685 {
 686     setAttributeWithoutSynchronization(draggableAttr, value
 687         ? AtomString(&quot;true&quot;, AtomString::ConstructFromLiteral)
 688         : AtomString(&quot;false&quot;, AtomString::ConstructFromLiteral));
 689 }
 690 
 691 bool HTMLElement::spellcheck() const
 692 {
 693     return isSpellCheckingEnabled();
 694 }
 695 
 696 void HTMLElement::setSpellcheck(bool enable)
 697 {
 698     setAttributeWithoutSynchronization(spellcheckAttr, enable
 699         ? AtomString(&quot;true&quot;, AtomString::ConstructFromLiteral)
 700         : AtomString(&quot;false&quot;, AtomString::ConstructFromLiteral));
 701 }
 702 
 703 void HTMLElement::click()
 704 {
 705     simulateClick(*this, nullptr, SendNoEvents, DoNotShowPressedLook, SimulatedClickSource::Bindings);
 706 }
 707 
 708 void HTMLElement::accessKeyAction(bool sendMouseEvents)
 709 {
 710     dispatchSimulatedClick(nullptr, sendMouseEvents ? SendMouseUpDownEvents : SendNoEvents);
 711 }
 712 
 713 String HTMLElement::title() const
 714 {
 715     return attributeWithoutSynchronization(titleAttr);
 716 }
 717 
 718 bool HTMLElement::translate() const
 719 {
 720     for (auto&amp; element : lineageOfType&lt;HTMLElement&gt;(*this)) {
 721         const AtomString&amp; value = element.attributeWithoutSynchronization(translateAttr);
 722         if (equalLettersIgnoringASCIICase(value, &quot;yes&quot;) || (value.isEmpty() &amp;&amp; !value.isNull()))
 723             return true;
 724         if (equalLettersIgnoringASCIICase(value, &quot;no&quot;))
 725             return false;
 726     }
 727     // Default on the root element is translate=yes.
 728     return true;
 729 }
 730 
 731 void HTMLElement::setTranslate(bool enable)
 732 {
 733     setAttributeWithoutSynchronization(translateAttr, enable ? &quot;yes&quot; : &quot;no&quot;);
 734 }
 735 
 736 bool HTMLElement::rendererIsEverNeeded()
 737 {
 738     if (hasTagName(noscriptTag)) {
 739         RefPtr&lt;Frame&gt; frame = document().frame();
 740         if (frame &amp;&amp; frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
 741             return false;
 742     } else if (hasTagName(noembedTag)) {
 743         RefPtr&lt;Frame&gt; frame = document().frame();
 744         if (frame &amp;&amp; frame-&gt;loader().subframeLoader().allowPlugins())
 745             return false;
 746     }
 747     return StyledElement::rendererIsEverNeeded();
 748 }
 749 
 750 RenderPtr&lt;RenderElement&gt; HTMLElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 751 {
 752     return RenderElement::createFor(*this, WTFMove(style));
 753 }
 754 
 755 HTMLFormElement* HTMLElement::form() const
 756 {
 757     return HTMLFormElement::findClosestFormAncestor(*this);
 758 }
 759 
 760 FormNamedItem* HTMLElement::asFormNamedItem()
 761 {
 762     return nullptr;
 763 }
 764 
 765 FormAssociatedElement* HTMLElement::asFormAssociatedElement()
 766 {
 767     return nullptr;
 768 }
 769 
 770 static inline bool elementAffectsDirectionality(const Node&amp; node)
 771 {
 772     if (!is&lt;HTMLElement&gt;(node))
 773         return false;
 774     const HTMLElement&amp; element = downcast&lt;HTMLElement&gt;(node);
 775     return is&lt;HTMLBDIElement&gt;(element) || element.hasAttributeWithoutSynchronization(dirAttr);
 776 }
 777 
 778 static void setHasDirAutoFlagRecursively(Node* firstNode, bool flag, Node* lastNode = nullptr)
 779 {
 780     firstNode-&gt;setSelfOrAncestorHasDirAutoAttribute(flag);
 781 
 782     RefPtr&lt;Node&gt; node = firstNode-&gt;firstChild();
 783 
 784     while (node) {
 785         if (node-&gt;selfOrAncestorHasDirAutoAttribute() == flag)
 786             return;
 787 
 788         if (elementAffectsDirectionality(*node)) {
 789             if (node == lastNode)
 790                 return;
 791             node = NodeTraversal::nextSkippingChildren(*node, firstNode);
 792             continue;
 793         }
 794         node-&gt;setSelfOrAncestorHasDirAutoAttribute(flag);
 795         if (node == lastNode)
 796             return;
 797         node = NodeTraversal::next(*node, firstNode);
 798     }
 799 }
 800 
 801 void HTMLElement::childrenChanged(const ChildChange&amp; change)
 802 {
 803     StyledElement::childrenChanged(change);
 804     adjustDirectionalityIfNeededAfterChildrenChanged(change.previousSiblingElement, change.type);
 805 }
 806 
 807 bool HTMLElement::hasDirectionAuto() const
 808 {
 809     const AtomString&amp; direction = attributeWithoutSynchronization(dirAttr);
 810     return (hasTagName(bdiTag) &amp;&amp; direction.isNull()) || equalLettersIgnoringASCIICase(direction, &quot;auto&quot;);
 811 }
 812 
 813 TextDirection HTMLElement::directionalityIfhasDirAutoAttribute(bool&amp; isAuto) const
 814 {
 815     if (!(selfOrAncestorHasDirAutoAttribute() &amp;&amp; hasDirectionAuto())) {
 816         isAuto = false;
 817         return TextDirection::LTR;
 818     }
 819 
 820     isAuto = true;
 821     return directionality();
 822 }
 823 
 824 TextDirection HTMLElement::directionality(Node** strongDirectionalityTextNode) const
 825 {
 826     if (isTextField()) {
 827         HTMLTextFormControlElement&amp; textElement = downcast&lt;HTMLTextFormControlElement&gt;(const_cast&lt;HTMLElement&amp;&gt;(*this));
 828         bool hasStrongDirectionality;
 829         UCharDirection textDirection = textElement.value().defaultWritingDirection(&amp;hasStrongDirectionality);
 830         if (strongDirectionalityTextNode)
 831             *strongDirectionalityTextNode = hasStrongDirectionality ? &amp;textElement : nullptr;
 832         return (textDirection == U_LEFT_TO_RIGHT) ? TextDirection::LTR : TextDirection::RTL;
 833     }
 834 
 835     RefPtr&lt;Node&gt; node = firstChild();
 836     while (node) {
 837         // Skip bdi, script, style and text form controls.
 838         if (equalLettersIgnoringASCIICase(node-&gt;nodeName(), &quot;bdi&quot;) || node-&gt;hasTagName(scriptTag) || node-&gt;hasTagName(styleTag)
 839             || (is&lt;Element&gt;(*node) &amp;&amp; downcast&lt;Element&gt;(*node).isTextField())) {
 840             node = NodeTraversal::nextSkippingChildren(*node, this);
 841             continue;
 842         }
 843 
 844         // Skip elements with valid dir attribute
 845         if (is&lt;Element&gt;(*node)) {
 846             auto&amp; dirAttributeValue = downcast&lt;Element&gt;(*node).attributeWithoutSynchronization(dirAttr);
 847             if (isLTROrRTLIgnoringCase(dirAttributeValue) || equalLettersIgnoringASCIICase(dirAttributeValue, &quot;auto&quot;)) {
 848                 node = NodeTraversal::nextSkippingChildren(*node, this);
 849                 continue;
 850             }
 851         }
 852 
 853         if (node-&gt;isTextNode()) {
 854             bool hasStrongDirectionality;
 855             UCharDirection textDirection = node-&gt;textContent(true).defaultWritingDirection(&amp;hasStrongDirectionality);
 856             if (hasStrongDirectionality) {
 857                 if (strongDirectionalityTextNode)
 858                     *strongDirectionalityTextNode = node.get();
 859                 return (textDirection == U_LEFT_TO_RIGHT) ? TextDirection::LTR : TextDirection::RTL;
 860             }
 861         }
 862         node = NodeTraversal::next(*node, this);
 863     }
 864     if (strongDirectionalityTextNode)
 865         *strongDirectionalityTextNode = nullptr;
 866     return TextDirection::LTR;
 867 }
 868 
 869 void HTMLElement::dirAttributeChanged(const AtomString&amp; value)
 870 {
 871     RefPtr&lt;Element&gt; parent = parentElement();
 872 
 873     if (is&lt;HTMLElement&gt;(parent) &amp;&amp; parent-&gt;selfOrAncestorHasDirAutoAttribute())
 874         downcast&lt;HTMLElement&gt;(*parent).adjustDirectionalityIfNeededAfterChildAttributeChanged(this);
 875 
 876     if (equalLettersIgnoringASCIICase(value, &quot;auto&quot;))
 877         calculateAndAdjustDirectionality();
 878 }
 879 
 880 void HTMLElement::adjustDirectionalityIfNeededAfterChildAttributeChanged(Element* child)
 881 {
 882     ASSERT(selfOrAncestorHasDirAutoAttribute());
 883     Node* strongDirectionalityTextNode;
 884     TextDirection textDirection = directionality(&amp;strongDirectionalityTextNode);
 885     setHasDirAutoFlagRecursively(child, false);
 886     if (!renderer() || renderer()-&gt;style().direction() == textDirection)
 887         return;
 888     for (auto&amp; elementToAdjust : elementLineage(this)) {
 889         if (elementAffectsDirectionality(elementToAdjust)) {
 890             elementToAdjust.invalidateStyleForSubtree();
 891             return;
 892         }
 893     }
 894 }
 895 
 896 void HTMLElement::calculateAndAdjustDirectionality()
 897 {
 898     Node* strongDirectionalityTextNode;
 899     TextDirection textDirection = directionality(&amp;strongDirectionalityTextNode);
 900     setHasDirAutoFlagRecursively(this, true, strongDirectionalityTextNode);
 901     if (renderer() &amp;&amp; renderer()-&gt;style().direction() != textDirection)
 902         invalidateStyleForSubtree();
 903 }
 904 
 905 void HTMLElement::adjustDirectionalityIfNeededAfterChildrenChanged(Element* beforeChange, ChildChangeType changeType)
 906 {
 907     // FIXME: This function looks suspicious.
 908 
 909     if (!selfOrAncestorHasDirAutoAttribute())
 910         return;
 911 
 912     RefPtr&lt;Node&gt; oldMarkedNode;
 913     if (beforeChange)
 914         oldMarkedNode = changeType == ElementInserted ? ElementTraversal::nextSibling(*beforeChange) : beforeChange-&gt;nextSibling();
 915 
 916     while (oldMarkedNode &amp;&amp; elementAffectsDirectionality(*oldMarkedNode))
 917         oldMarkedNode = oldMarkedNode-&gt;nextSibling();
 918     if (oldMarkedNode)
 919         setHasDirAutoFlagRecursively(oldMarkedNode.get(), false);
 920 
 921     for (auto&amp; elementToAdjust : lineageOfType&lt;HTMLElement&gt;(*this)) {
 922         if (elementAffectsDirectionality(elementToAdjust)) {
 923             elementToAdjust.calculateAndAdjustDirectionality();
 924             return;
 925         }
 926     }
 927 }
 928 
 929 void HTMLElement::addHTMLLengthToStyle(MutableStyleProperties&amp; style, CSSPropertyID propertyID, const String&amp; value)
 930 {
 931     // FIXME: This function should not spin up the CSS parser, but should instead just figure out the correct
 932     // length unit and make the appropriate parsed value.
 933 
 934     if (StringImpl* string = value.impl()) {
 935         unsigned parsedLength = 0;
 936 
 937         while (parsedLength &lt; string-&gt;length() &amp;&amp; (*string)[parsedLength] &lt;= &#39; &#39;)
 938             ++parsedLength;
 939 
 940         for (; parsedLength &lt; string-&gt;length(); ++parsedLength) {
 941             UChar cc = (*string)[parsedLength];
 942             if (cc &gt; &#39;9&#39;)
 943                 break;
 944             if (cc &lt; &#39;0&#39;) {
 945                 if (cc == &#39;%&#39; || cc == &#39;*&#39;)
 946                     ++parsedLength;
 947                 if (cc != &#39;.&#39;)
 948                     break;
 949             }
 950         }
 951 
 952         if (parsedLength != string-&gt;length()) {
 953             addPropertyToPresentationAttributeStyle(style, propertyID, string-&gt;substring(0, parsedLength));
 954             return;
 955         }
 956     }
 957 
 958     addPropertyToPresentationAttributeStyle(style, propertyID, value);
 959 }
 960 
 961 static RGBA32 parseColorStringWithCrazyLegacyRules(const String&amp; colorString)
 962 {
 963     // Per spec, only look at the first 128 digits of the string.
 964     const size_t maxColorLength = 128;
 965     // We&#39;ll pad the buffer with two extra 0s later, so reserve two more than the max.
 966     Vector&lt;char, maxColorLength+2&gt; digitBuffer;
 967 
 968     size_t i = 0;
 969     // Skip a leading #.
 970     if (colorString[0] == &#39;#&#39;)
 971         i = 1;
 972 
 973     // Grab the first 128 characters, replacing non-hex characters with 0.
 974     // Non-BMP characters are replaced with &quot;00&quot; due to them appearing as two &quot;characters&quot; in the String.
 975     for (; i &lt; colorString.length() &amp;&amp; digitBuffer.size() &lt; maxColorLength; i++) {
 976         if (!isASCIIHexDigit(colorString[i]))
 977             digitBuffer.append(&#39;0&#39;);
 978         else
 979             digitBuffer.append(colorString[i]);
 980     }
 981 
 982     if (!digitBuffer.size())
 983         return Color::black;
 984 
 985     // Pad the buffer out to at least the next multiple of three in size.
 986     digitBuffer.append(&#39;0&#39;);
 987     digitBuffer.append(&#39;0&#39;);
 988 
 989     if (digitBuffer.size() &lt; 6)
 990         return makeRGB(toASCIIHexValue(digitBuffer[0]), toASCIIHexValue(digitBuffer[1]), toASCIIHexValue(digitBuffer[2]));
 991 
 992     // Split the digits into three components, then search the last 8 digits of each component.
 993     ASSERT(digitBuffer.size() &gt;= 6);
 994     size_t componentLength = digitBuffer.size() / 3;
 995     size_t componentSearchWindowLength = std::min&lt;size_t&gt;(componentLength, 8);
 996     size_t redIndex = componentLength - componentSearchWindowLength;
 997     size_t greenIndex = componentLength * 2 - componentSearchWindowLength;
 998     size_t blueIndex = componentLength * 3 - componentSearchWindowLength;
 999     // Skip digits until one of them is non-zero, or we&#39;ve only got two digits left in the component.
1000     while (digitBuffer[redIndex] == &#39;0&#39; &amp;&amp; digitBuffer[greenIndex] == &#39;0&#39; &amp;&amp; digitBuffer[blueIndex] == &#39;0&#39; &amp;&amp; (componentLength - redIndex) &gt; 2) {
1001         redIndex++;
1002         greenIndex++;
1003         blueIndex++;
1004     }
1005     ASSERT(redIndex + 1 &lt; componentLength);
1006     ASSERT(greenIndex &gt;= componentLength);
1007     ASSERT(greenIndex + 1 &lt; componentLength * 2);
1008     ASSERT(blueIndex &gt;= componentLength * 2);
1009     ASSERT_WITH_SECURITY_IMPLICATION(blueIndex + 1 &lt; digitBuffer.size());
1010 
1011     int redValue = toASCIIHexValue(digitBuffer[redIndex], digitBuffer[redIndex + 1]);
1012     int greenValue = toASCIIHexValue(digitBuffer[greenIndex], digitBuffer[greenIndex + 1]);
1013     int blueValue = toASCIIHexValue(digitBuffer[blueIndex], digitBuffer[blueIndex + 1]);
1014     return makeRGB(redValue, greenValue, blueValue);
1015 }
1016 
1017 // Color parsing that matches HTML&#39;s &quot;rules for parsing a legacy color value&quot;
1018 void HTMLElement::addHTMLColorToStyle(MutableStyleProperties&amp; style, CSSPropertyID propertyID, const String&amp; attributeValue)
1019 {
1020     // An empty string doesn&#39;t apply a color. (One containing only whitespace does, which is why this check occurs before stripping.)
1021     if (attributeValue.isEmpty())
1022         return;
1023 
1024     String colorString = attributeValue.stripWhiteSpace();
1025 
1026     // &quot;transparent&quot; doesn&#39;t apply a color either.
1027     if (equalLettersIgnoringASCIICase(colorString, &quot;transparent&quot;))
1028         return;
1029 
1030     Color color;
1031     // We can&#39;t always use the default Color constructor because it accepts
1032     // 4/8-digit hex, which conflict with some legacy HTML content using attributes.
1033     if ((colorString.length() != 5 &amp;&amp; colorString.length() != 9) || colorString[0] != &#39;#&#39;)
1034         color = Color(colorString);
1035     if (!color.isValid())
1036         color = Color(parseColorStringWithCrazyLegacyRules(colorString));
1037 
1038     style.setProperty(propertyID, CSSValuePool::singleton().createColorValue(color.rgb()));
1039 }
1040 
1041 bool HTMLElement::willRespondToMouseMoveEvents()
1042 {
1043     return !isDisabledFormControl() &amp;&amp; Element::willRespondToMouseMoveEvents();
1044 }
1045 
1046 bool HTMLElement::willRespondToMouseWheelEvents()
1047 {
1048     return !isDisabledFormControl() &amp;&amp; Element::willRespondToMouseWheelEvents();
1049 }
1050 
1051 bool HTMLElement::willRespondToMouseClickEvents()
1052 {
1053     return !isDisabledFormControl() &amp;&amp; Element::willRespondToMouseClickEvents();
1054 }
1055 
1056 bool HTMLElement::canBeActuallyDisabled() const
1057 {
1058     return is&lt;HTMLButtonElement&gt;(*this)
1059         || is&lt;HTMLInputElement&gt;(*this)
1060         || is&lt;HTMLSelectElement&gt;(*this)
1061         || is&lt;HTMLTextAreaElement&gt;(*this)
1062         || is&lt;HTMLOptGroupElement&gt;(*this)
1063         || is&lt;HTMLOptionElement&gt;(*this)
1064         || is&lt;HTMLFieldSetElement&gt;(*this);
1065 }
1066 
1067 bool HTMLElement::isActuallyDisabled() const
1068 {
1069     return canBeActuallyDisabled() &amp;&amp; isDisabledFormControl();
1070 }
1071 
1072 #if ENABLE(AUTOCAPITALIZE)
1073 
1074 const AtomString&amp; HTMLElement::autocapitalize() const
1075 {
1076     return stringForAutocapitalizeType(autocapitalizeType());
1077 }
1078 
1079 AutocapitalizeType HTMLElement::autocapitalizeType() const
1080 {
1081     return autocapitalizeTypeForAttributeValue(attributeWithoutSynchronization(HTMLNames::autocapitalizeAttr));
1082 }
1083 
1084 void HTMLElement::setAutocapitalize(const AtomString&amp; value)
1085 {
1086     setAttributeWithoutSynchronization(autocapitalizeAttr, value);
1087 }
1088 
1089 #endif
1090 
1091 #if ENABLE(AUTOCORRECT)
1092 
1093 bool HTMLElement::shouldAutocorrect() const
1094 {
1095     auto&amp; autocorrectValue = attributeWithoutSynchronization(HTMLNames::autocorrectAttr);
1096     // Unrecognized values fall back to &quot;on&quot;.
1097     return !equalLettersIgnoringASCIICase(autocorrectValue, &quot;off&quot;);
1098 }
1099 
1100 void HTMLElement::setAutocorrect(bool autocorrect)
1101 {
1102     setAttributeWithoutSynchronization(autocorrectAttr, autocorrect ? AtomString(&quot;on&quot;, AtomString::ConstructFromLiteral) : AtomString(&quot;off&quot;, AtomString::ConstructFromLiteral));
1103 }
1104 
1105 #endif
1106 
1107 InputMode HTMLElement::canonicalInputMode() const
1108 {
1109     auto mode = inputModeForAttributeValue(attributeWithoutSynchronization(inputmodeAttr));
1110     if (mode == InputMode::Unspecified) {
1111         if (document().quirks().needsInputModeNoneImplicitly(*this))
1112             return InputMode::None;
1113     }
1114     return mode;
1115 }
1116 
1117 const AtomString&amp; HTMLElement::inputMode() const
1118 {
1119     return stringForInputMode(canonicalInputMode());
1120 }
1121 
1122 void HTMLElement::setInputMode(const AtomString&amp; value)
1123 {
1124     setAttributeWithoutSynchronization(inputmodeAttr, value);
1125 }
1126 
1127 EnterKeyHint HTMLElement::canonicalEnterKeyHint() const
1128 {
1129     return enterKeyHintForAttributeValue(attributeWithoutSynchronization(enterkeyhintAttr));
1130 }
1131 
1132 String HTMLElement::enterKeyHint() const
1133 {
1134     return attributeValueForEnterKeyHint(canonicalEnterKeyHint());
1135 }
1136 
1137 void HTMLElement::setEnterKeyHint(const String&amp; value)
1138 {
1139     setAttributeWithoutSynchronization(enterkeyhintAttr, value);
1140 }
1141 
1142 } // namespace WebCore
1143 
1144 #ifndef NDEBUG
1145 
1146 // For use in the debugger
1147 void dumpInnerHTML(WebCore::HTMLElement*);
1148 
1149 void dumpInnerHTML(WebCore::HTMLElement* element)
1150 {
1151     printf(&quot;%s\n&quot;, element-&gt;innerHTML().ascii().data());
1152 }
1153 
1154 #endif
    </pre>
  </body>
</html>
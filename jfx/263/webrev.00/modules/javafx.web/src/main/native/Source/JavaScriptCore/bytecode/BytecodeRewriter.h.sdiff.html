<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeRewriter.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BytecodeLivenessAnalysisInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeUseDef.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeRewriter.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
156                 Op::emit(&amp;m_bytecodeGenerator, std::forward&lt;Args&gt;(args)...);
157             });
158         }
159 
160         void align()
161         {
162 #if CPU(NEEDS_ALIGNED_ACCESS)
163             m_bytecodeGenerator.withWriter(m_writer, [&amp;] {
164                 while (m_bytecodeGenerator.instructions().size() % OpcodeSize::Wide32)
165                     OpNop::emit&lt;OpcodeSize::Narrow&gt;(&amp;m_bytecodeGenerator);
166             });
167 #endif
168         }
169 
170     private:
171         BytecodeGenerator&amp; m_bytecodeGenerator;
172         InstructionStreamWriter&amp; m_writer;
173         IncludeBranch&amp; m_includeBranch;
174     };
175 
<span class="line-modified">176     BytecodeRewriter(BytecodeGenerator&amp; bytecodeGenerator, BytecodeGraph&amp; graph, UnlinkedCodeBlock* codeBlock, InstructionStreamWriter&amp; writer)</span>
177         : m_bytecodeGenerator(bytecodeGenerator)
178         , m_graph(graph)
179         , m_codeBlock(codeBlock)
180         , m_writer(writer)
181     {
182     }
183 
184     template&lt;class Function&gt;
185     void insertFragmentBefore(const InstructionStream::Ref&amp; instruction, Function function)
186     {
187         IncludeBranch includeBranch = IncludeBranch::No;
188         InstructionStreamWriter writer;
189         Fragment fragment(m_bytecodeGenerator, writer, includeBranch);
190         function(fragment);
191         fragment.align();
192         insertImpl(InsertionPoint(instruction.offset(), Position::Before), includeBranch, WTFMove(writer));
193     }
194 
195     template&lt;class Function&gt;
196     void insertFragmentAfter(const InstructionStream::Ref&amp; instruction, Function function)
</pre>
<hr />
<pre>
210 
211     void execute();
212 
213     BytecodeGraph&amp; graph() { return m_graph; }
214 
215     int32_t adjustAbsoluteOffset(InstructionStream::Offset absoluteOffset)
216     {
217         return adjustJumpTarget(InsertionPoint(0, Position::EntryPoint), InsertionPoint(absoluteOffset, Position::LabelPoint));
218     }
219 
220     int32_t adjustJumpTarget(InstructionStream::Offset originalBytecodeOffset, int32_t originalJumpTarget)
221     {
222         return adjustJumpTarget(InsertionPoint(originalBytecodeOffset, Position::LabelPoint), InsertionPoint(originalJumpTarget, Position::LabelPoint));
223     }
224 
225     void adjustJumpTargets();
226 
227 private:
228     void insertImpl(InsertionPoint, IncludeBranch, InstructionStreamWriter&amp;&amp; fragment);
229 
<span class="line-modified">230     friend class UnlinkedCodeBlock;</span>
231     void applyModification();
232     void adjustJumpTargetsInFragment(unsigned finalOffset, Insertion&amp;);
233 
234     int adjustJumpTarget(InsertionPoint startPoint, InsertionPoint jumpTargetPoint);
235     template&lt;typename Iterator&gt; int calculateDifference(Iterator begin, Iterator end);
236 
237     BytecodeGenerator&amp; m_bytecodeGenerator;
238     BytecodeGraph&amp; m_graph;
<span class="line-modified">239     UnlinkedCodeBlock* m_codeBlock;</span>
240     InstructionStreamWriter&amp; m_writer;
241     Vector&lt;Insertion, 8&gt; m_insertions;
242 };
243 
244 template&lt;typename Iterator&gt;
245 inline int BytecodeRewriter::calculateDifference(Iterator begin, Iterator end)
246 {
247     int result = 0;
248     for (; begin != end; ++begin) {
249         if (begin-&gt;type == Insertion::Type::Remove)
250             result -= begin-&gt;length();
251         else
252             result += begin-&gt;length();
253     }
254     return result;
255 }
256 
257 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
156                 Op::emit(&amp;m_bytecodeGenerator, std::forward&lt;Args&gt;(args)...);
157             });
158         }
159 
160         void align()
161         {
162 #if CPU(NEEDS_ALIGNED_ACCESS)
163             m_bytecodeGenerator.withWriter(m_writer, [&amp;] {
164                 while (m_bytecodeGenerator.instructions().size() % OpcodeSize::Wide32)
165                     OpNop::emit&lt;OpcodeSize::Narrow&gt;(&amp;m_bytecodeGenerator);
166             });
167 #endif
168         }
169 
170     private:
171         BytecodeGenerator&amp; m_bytecodeGenerator;
172         InstructionStreamWriter&amp; m_writer;
173         IncludeBranch&amp; m_includeBranch;
174     };
175 
<span class="line-modified">176     BytecodeRewriter(BytecodeGenerator&amp; bytecodeGenerator, BytecodeGraph&amp; graph, UnlinkedCodeBlockGenerator* codeBlock, InstructionStreamWriter&amp; writer)</span>
177         : m_bytecodeGenerator(bytecodeGenerator)
178         , m_graph(graph)
179         , m_codeBlock(codeBlock)
180         , m_writer(writer)
181     {
182     }
183 
184     template&lt;class Function&gt;
185     void insertFragmentBefore(const InstructionStream::Ref&amp; instruction, Function function)
186     {
187         IncludeBranch includeBranch = IncludeBranch::No;
188         InstructionStreamWriter writer;
189         Fragment fragment(m_bytecodeGenerator, writer, includeBranch);
190         function(fragment);
191         fragment.align();
192         insertImpl(InsertionPoint(instruction.offset(), Position::Before), includeBranch, WTFMove(writer));
193     }
194 
195     template&lt;class Function&gt;
196     void insertFragmentAfter(const InstructionStream::Ref&amp; instruction, Function function)
</pre>
<hr />
<pre>
210 
211     void execute();
212 
213     BytecodeGraph&amp; graph() { return m_graph; }
214 
215     int32_t adjustAbsoluteOffset(InstructionStream::Offset absoluteOffset)
216     {
217         return adjustJumpTarget(InsertionPoint(0, Position::EntryPoint), InsertionPoint(absoluteOffset, Position::LabelPoint));
218     }
219 
220     int32_t adjustJumpTarget(InstructionStream::Offset originalBytecodeOffset, int32_t originalJumpTarget)
221     {
222         return adjustJumpTarget(InsertionPoint(originalBytecodeOffset, Position::LabelPoint), InsertionPoint(originalJumpTarget, Position::LabelPoint));
223     }
224 
225     void adjustJumpTargets();
226 
227 private:
228     void insertImpl(InsertionPoint, IncludeBranch, InstructionStreamWriter&amp;&amp; fragment);
229 
<span class="line-modified">230     friend class UnlinkedCodeBlockGenerator;</span>
231     void applyModification();
232     void adjustJumpTargetsInFragment(unsigned finalOffset, Insertion&amp;);
233 
234     int adjustJumpTarget(InsertionPoint startPoint, InsertionPoint jumpTargetPoint);
235     template&lt;typename Iterator&gt; int calculateDifference(Iterator begin, Iterator end);
236 
237     BytecodeGenerator&amp; m_bytecodeGenerator;
238     BytecodeGraph&amp; m_graph;
<span class="line-modified">239     UnlinkedCodeBlockGenerator* m_codeBlock;</span>
240     InstructionStreamWriter&amp; m_writer;
241     Vector&lt;Insertion, 8&gt; m_insertions;
242 };
243 
244 template&lt;typename Iterator&gt;
245 inline int BytecodeRewriter::calculateDifference(Iterator begin, Iterator end)
246 {
247     int result = 0;
248     for (; begin != end; ++begin) {
249         if (begin-&gt;type == Insertion::Type::Remove)
250             result -= begin-&gt;length();
251         else
252             result += begin-&gt;length();
253     }
254     return result;
255 }
256 
257 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="BytecodeLivenessAnalysisInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeUseDef.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
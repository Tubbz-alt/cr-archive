<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderInline.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayer.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
<span class="line-new-header">--- 1,8 ---</span>
  /*
   * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
<span class="line-added">+  * Copyright (C) 2019 Adobe. All rights reserved.</span>
   *
   * Portions are Copyright (C) 1998 Netscape Communications Corporation.
   *
   * Other contributors:
   *   Robert O&#39;Callahan &lt;roc+@cs.cmu.edu&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 50,13 ***</span>
  #include &quot;CSSPropertyNames.h&quot;
  #include &quot;Chrome.h&quot;
  #include &quot;DebugPageOverlays.h&quot;
  #include &quot;DeprecatedGlobalSettings.h&quot;
  #include &quot;Document.h&quot;
<span class="line-removed">- #include &quot;DocumentEventQueue.h&quot;</span>
  #include &quot;DocumentMarkerController.h&quot;
  #include &quot;DocumentTimeline.h&quot;
  #include &quot;Element.h&quot;
  #include &quot;EventHandler.h&quot;
  #include &quot;FEColorMatrix.h&quot;
  #include &quot;FEMerge.h&quot;
  #include &quot;FloatConversion.h&quot;
<span class="line-new-header">--- 51,13 ---</span>
  #include &quot;CSSPropertyNames.h&quot;
  #include &quot;Chrome.h&quot;
  #include &quot;DebugPageOverlays.h&quot;
  #include &quot;DeprecatedGlobalSettings.h&quot;
  #include &quot;Document.h&quot;
  #include &quot;DocumentMarkerController.h&quot;
  #include &quot;DocumentTimeline.h&quot;
<span class="line-added">+ #include &quot;Editor.h&quot;</span>
  #include &quot;Element.h&quot;
  #include &quot;EventHandler.h&quot;
  #include &quot;FEColorMatrix.h&quot;
  #include &quot;FEMerge.h&quot;
  #include &quot;FloatConversion.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 122,11 ***</span>
  #include &quot;SourceGraphic.h&quot;
  #include &quot;StyleProperties.h&quot;
  #include &quot;StyleResolver.h&quot;
  #include &quot;TransformationMatrix.h&quot;
  #include &quot;TranslateTransformOperation.h&quot;
<span class="line-modified">! #include &quot;WheelEventTestTrigger.h&quot;</span>
  #include &lt;stdio.h&gt;
  #include &lt;wtf/MonotonicTime.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/text/CString.h&gt;
  #include &lt;wtf/text/TextStream.h&gt;
<span class="line-new-header">--- 123,11 ---</span>
  #include &quot;SourceGraphic.h&quot;
  #include &quot;StyleProperties.h&quot;
  #include &quot;StyleResolver.h&quot;
  #include &quot;TransformationMatrix.h&quot;
  #include &quot;TranslateTransformOperation.h&quot;
<span class="line-modified">! #include &quot;WheelEventTestMonitor.h&quot;</span>
  #include &lt;stdio.h&gt;
  #include &lt;wtf/MonotonicTime.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/text/CString.h&gt;
  #include &lt;wtf/text/TextStream.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 219,11 ***</span>
  class ClipRectsCache {
      WTF_MAKE_FAST_ALLOCATED;
  public:
      ClipRectsCache()
      {
<span class="line-modified">! #ifndef NDEBUG</span>
          for (int i = 0; i &lt; NumCachedClipRectsTypes; ++i) {
              m_clipRectsRoot[i] = 0;
              m_scrollbarRelevancy[i] = IgnoreOverlayScrollbarSize;
          }
  #endif
<span class="line-new-header">--- 220,11 ---</span>
  class ClipRectsCache {
      WTF_MAKE_FAST_ALLOCATED;
  public:
      ClipRectsCache()
      {
<span class="line-modified">! #if ASSERT_ENABLED</span>
          for (int i = 0; i &lt; NumCachedClipRectsTypes; ++i) {
              m_clipRectsRoot[i] = 0;
              m_scrollbarRelevancy[i] = IgnoreOverlayScrollbarSize;
          }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 237,11 ***</span>
      void setClipRects(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow, RefPtr&lt;ClipRects&gt;&amp;&amp; clipRects)
      {
          m_clipRects[getIndex(clipRectsType, respectOverflow)] = WTFMove(clipRects);
      }
  
<span class="line-modified">! #ifndef NDEBUG</span>
      const RenderLayer* m_clipRectsRoot[NumCachedClipRectsTypes];
      OverlayScrollbarSizeRelevancy m_scrollbarRelevancy[NumCachedClipRectsTypes];
  #endif
  
  private:
<span class="line-new-header">--- 238,11 ---</span>
      void setClipRects(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow, RefPtr&lt;ClipRects&gt;&amp;&amp; clipRects)
      {
          m_clipRects[getIndex(clipRectsType, respectOverflow)] = WTFMove(clipRects);
      }
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      const RenderLayer* m_clipRectsRoot[NumCachedClipRectsTypes];
      OverlayScrollbarSizeRelevancy m_scrollbarRelevancy[NumCachedClipRectsTypes];
  #endif
  
  private:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 280,13 ***</span>
<span class="line-new-header">--- 281,17 ---</span>
      return ts;
  }
  
  #endif
  
<span class="line-added">+ DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(RenderLayer);</span>
<span class="line-added">+ </span>
  RenderLayer::RenderLayer(RenderLayerModelObject&amp; rendererLayerModelObject)
      : m_isRenderViewLayer(rendererLayerModelObject.isRenderView())
      , m_forcedStackingContext(rendererLayerModelObject.isMedia())
<span class="line-added">+     , m_isNormalFlowOnly(false)</span>
<span class="line-added">+     , m_isCSSStackingContext(false)</span>
      , m_isOpportunisticStackingContext(false)
      , m_zOrderListsDirty(false)
      , m_normalFlowListDirty(true)
      , m_hadNegativeZOrderList(false)
      , m_inResizeMode(false)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 320,11 ***</span>
      , m_adjustForIOSCaretWhenScrolling(false)
  #endif
      , m_requiresScrollPositionReconciliation(false)
      , m_containsDirtyOverlayScrollbars(false)
      , m_updatingMarqueePosition(false)
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      , m_layerListMutationAllowed(true)
  #endif
  #if ENABLE(CSS_COMPOSITING)
      , m_blendMode(static_cast&lt;unsigned&gt;(BlendMode::Normal))
      , m_hasNotIsolatedCompositedBlendingDescendants(false)
<span class="line-new-header">--- 325,11 ---</span>
      , m_adjustForIOSCaretWhenScrolling(false)
  #endif
      , m_requiresScrollPositionReconciliation(false)
      , m_containsDirtyOverlayScrollbars(false)
      , m_updatingMarqueePosition(false)
<span class="line-modified">! #if ASSERT_ENABLED</span>
      , m_layerListMutationAllowed(true)
  #endif
  #if ENABLE(CSS_COMPOSITING)
      , m_blendMode(static_cast&lt;unsigned&gt;(BlendMode::Normal))
      , m_hasNotIsolatedCompositedBlendingDescendants(false)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 492,11 ***</span>
          // off dirty in that case anyway.
          child.dirtyStackingContextZOrderLists();
      }
  }
  
<span class="line-modified">! void RenderLayer::insertOnlyThisLayer()</span>
  {
      if (!m_parent &amp;&amp; renderer().parent()) {
          // We need to connect ourselves when our renderer() has a parent.
          // Find our enclosingLayer and add ourselves.
          RenderLayer* parentLayer = renderer().parent()-&gt;enclosingLayer();
<span class="line-new-header">--- 497,11 ---</span>
          // off dirty in that case anyway.
          child.dirtyStackingContextZOrderLists();
      }
  }
  
<span class="line-modified">! void RenderLayer::insertOnlyThisLayer(LayerChangeTiming timing)</span>
  {
      if (!m_parent &amp;&amp; renderer().parent()) {
          // We need to connect ourselves when our renderer() has a parent.
          // Find our enclosingLayer and add ourselves.
          RenderLayer* parentLayer = renderer().parent()-&gt;enclosingLayer();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 507,19 ***</span>
  
      // Remove all descendant layers from the hierarchy and add them to the new position.
      for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(renderer()))
          child.moveLayers(m_parent, this);
  
      // Clear out all the clip rects.
      clearClipRectsIncludingDescendants();
  }
  
<span class="line-modified">! void RenderLayer::removeOnlyThisLayer()</span>
  {
      if (!m_parent)
          return;
  
      // Mark that we are about to lose our layer. This makes render tree
      // walks ignore this layer while we&#39;re removing it.
      renderer().setHasLayer(false);
  
      compositor().layerWillBeRemoved(*m_parent, *this);
<span class="line-new-header">--- 512,27 ---</span>
  
      // Remove all descendant layers from the hierarchy and add them to the new position.
      for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(renderer()))
          child.moveLayers(m_parent, this);
  
<span class="line-added">+     if (parent()) {</span>
<span class="line-added">+         if (timing == LayerChangeTiming::StyleChange)</span>
<span class="line-added">+             renderer().view().layerChildrenChangedDuringStyleChange(*parent());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      // Clear out all the clip rects.
      clearClipRectsIncludingDescendants();
  }
  
<span class="line-modified">! void RenderLayer::removeOnlyThisLayer(LayerChangeTiming timing)</span>
  {
      if (!m_parent)
          return;
  
<span class="line-added">+     if (timing == LayerChangeTiming::StyleChange)</span>
<span class="line-added">+         renderer().view().layerChildrenChangedDuringStyleChange(*parent());</span>
<span class="line-added">+ </span>
      // Mark that we are about to lose our layer. This makes render tree
      // walks ignore this layer while we&#39;re removing it.
      renderer().setHasLayer(false);
  
      compositor().layerWillBeRemoved(*m_parent, *this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 562,11 ***</span>
  #endif
          || renderer.isTransparent()
          || renderer.isPositioned() // Note that this only creates stacking context in conjunction with explicit z-index.
          || renderer.hasReflection()
          || renderer.style().hasIsolation()
<span class="line-modified">!         || !renderer.style().hasAutoZIndex()</span>
          || (renderer.style().willChange() &amp;&amp; renderer.style().willChange()-&gt;canCreateStackingContext());
  }
  
  bool RenderLayer::shouldBeNormalFlowOnly() const
  {
<span class="line-new-header">--- 575,11 ---</span>
  #endif
          || renderer.isTransparent()
          || renderer.isPositioned() // Note that this only creates stacking context in conjunction with explicit z-index.
          || renderer.hasReflection()
          || renderer.style().hasIsolation()
<span class="line-modified">!         || !renderer.style().hasAutoUsedZIndex()</span>
          || (renderer.style().willChange() &amp;&amp; renderer.style().willChange()-&gt;canCreateStackingContext());
  }
  
  bool RenderLayer::shouldBeNormalFlowOnly() const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 583,11 ***</span>
          || renderer().isInFlowRenderFragmentedFlow();
  }
  
  bool RenderLayer::shouldBeCSSStackingContext() const
  {
<span class="line-modified">!     return !renderer().style().hasAutoZIndex() || isRenderViewLayer();</span>
  }
  
  bool RenderLayer::setIsNormalFlowOnly(bool isNormalFlowOnly)
  {
      if (isNormalFlowOnly == m_isNormalFlowOnly)
<span class="line-new-header">--- 596,11 ---</span>
          || renderer().isInFlowRenderFragmentedFlow();
  }
  
  bool RenderLayer::shouldBeCSSStackingContext() const
  {
<span class="line-modified">!     return !renderer().style().hasAutoUsedZIndex() || isRenderViewLayer();</span>
  }
  
  bool RenderLayer::setIsNormalFlowOnly(bool isNormalFlowOnly)
  {
      if (isNormalFlowOnly == m_isNormalFlowOnly)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 711,11 ***</span>
  
  void RenderLayer::rebuildZOrderLists()
  {
      ASSERT(layerListMutationAllowed());
      ASSERT(isDirtyStackingContext());
<span class="line-modified">!     rebuildZOrderLists(m_posZOrderList, m_negZOrderList);</span>
      m_zOrderListsDirty = false;
  
      bool hasNegativeZOrderList = m_negZOrderList &amp;&amp; m_negZOrderList-&gt;size();
      // Having negative z-order lists affect whether a compositing layer needs a foreground layer.
      // Ideally we&#39;d only trigger this when having z-order children changes, but we blow away the old z-order
<span class="line-new-header">--- 724,13 ---</span>
  
  void RenderLayer::rebuildZOrderLists()
  {
      ASSERT(layerListMutationAllowed());
      ASSERT(isDirtyStackingContext());
<span class="line-modified">! </span>
<span class="line-added">+     OptionSet&lt;Compositing&gt; childDirtyFlags;</span>
<span class="line-added">+     rebuildZOrderLists(m_posZOrderList, m_negZOrderList, childDirtyFlags);</span>
      m_zOrderListsDirty = false;
  
      bool hasNegativeZOrderList = m_negZOrderList &amp;&amp; m_negZOrderList-&gt;size();
      // Having negative z-order lists affect whether a compositing layer needs a foreground layer.
      // Ideally we&#39;d only trigger this when having z-order children changes, but we blow away the old z-order
</pre>
<hr />
<pre>
<span class="line-old-header">*** 723,18 ***</span>
      if (hasNegativeZOrderList != m_hadNegativeZOrderList) {
          m_hadNegativeZOrderList = hasNegativeZOrderList;
          if (isComposited())
              setNeedsCompositingConfigurationUpdate();
      }
  }
  
<span class="line-modified">! void RenderLayer::rebuildZOrderLists(std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; posZOrderList, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; negZOrderList)</span>
  {
      bool includeHiddenLayers = compositor().usesCompositing();
      for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
          if (!isReflectionLayer(*child))
<span class="line-modified">!             child-&gt;collectLayers(includeHiddenLayers, posZOrderList, negZOrderList);</span>
      }
  
      auto compareZIndex = [] (const RenderLayer* first, const RenderLayer* second) -&gt; bool {
          return first-&gt;zIndex() &lt; second-&gt;zIndex();
      };
<span class="line-new-header">--- 738,28 ---</span>
      if (hasNegativeZOrderList != m_hadNegativeZOrderList) {
          m_hadNegativeZOrderList = hasNegativeZOrderList;
          if (isComposited())
              setNeedsCompositingConfigurationUpdate();
      }
<span class="line-added">+ </span>
<span class="line-added">+     // Building lists may have added layers with dirty flags, so make sure we propagate dirty bits up the tree.</span>
<span class="line-added">+     if (m_compositingDirtyBits.containsAll({ Compositing::DescendantsNeedRequirementsTraversal, Compositing::DescendantsNeedBackingAndHierarchyTraversal }))</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (childDirtyFlags.containsAny(computeCompositingRequirementsFlags()))</span>
<span class="line-added">+         setDescendantsNeedCompositingRequirementsTraversal();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (childDirtyFlags.containsAny(updateBackingOrHierarchyFlags()))</span>
<span class="line-added">+         setDescendantsNeedUpdateBackingAndHierarchyTraversal();</span>
  }
  
<span class="line-modified">! void RenderLayer::rebuildZOrderLists(std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; posZOrderList, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; negZOrderList, OptionSet&lt;Compositing&gt;&amp; accumulatedDirtyFlags)</span>
  {
      bool includeHiddenLayers = compositor().usesCompositing();
      for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
          if (!isReflectionLayer(*child))
<span class="line-modified">!             child-&gt;collectLayers(includeHiddenLayers, posZOrderList, negZOrderList, accumulatedDirtyFlags);</span>
      }
  
      auto compareZIndex = [] (const RenderLayer* first, const RenderLayer* second) -&gt; bool {
          return first-&gt;zIndex() &lt; second-&gt;zIndex();
      };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 745,11 ***</span>
  
      if (negZOrderList)
          std::stable_sort(negZOrderList-&gt;begin(), negZOrderList-&gt;end(), compareZIndex);
  }
  
<span class="line-modified">! void RenderLayer::collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; positiveZOrderList, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; negativeZOrderList)</span>
  {
      updateDescendantDependentFlags();
  
      bool isStacking = isStackingContext();
      // Overflow layers are just painted by their enclosing layers, so they don&#39;t get put in zorder lists.
<span class="line-new-header">--- 770,11 ---</span>
  
      if (negZOrderList)
          std::stable_sort(negZOrderList-&gt;begin(), negZOrderList-&gt;end(), compareZIndex);
  }
  
<span class="line-modified">! void RenderLayer::collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; positiveZOrderList, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; negativeZOrderList, OptionSet&lt;Compositing&gt;&amp; accumulatedDirtyFlags)</span>
  {
      updateDescendantDependentFlags();
  
      bool isStacking = isStackingContext();
      // Overflow layers are just painted by their enclosing layers, so they don&#39;t get put in zorder lists.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 757,19 ***</span>
      if (includeHiddenLayer &amp;&amp; !isNormalFlowOnly()) {
          auto&amp; layerList = (zIndex() &gt;= 0) ? positiveZOrderList : negativeZOrderList;
          if (!layerList)
              layerList = makeUnique&lt;Vector&lt;RenderLayer*&gt;&gt;();
          layerList-&gt;append(this);
      }
  
      // Recur into our children to collect more layers, but only if we don&#39;t establish
      // a stacking context/container.
      if ((includeHiddenLayers || m_hasVisibleDescendant) &amp;&amp; !isStacking) {
          for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
              // Ignore reflections.
              if (!isReflectionLayer(*child))
<span class="line-modified">!                 child-&gt;collectLayers(includeHiddenLayers, positiveZOrderList, negativeZOrderList);</span>
          }
      }
  }
  
  void RenderLayer::setAncestorsHaveCompositingDirtyFlag(Compositing flag)
<span class="line-new-header">--- 782,20 ---</span>
      if (includeHiddenLayer &amp;&amp; !isNormalFlowOnly()) {
          auto&amp; layerList = (zIndex() &gt;= 0) ? positiveZOrderList : negativeZOrderList;
          if (!layerList)
              layerList = makeUnique&lt;Vector&lt;RenderLayer*&gt;&gt;();
          layerList-&gt;append(this);
<span class="line-added">+         accumulatedDirtyFlags.add(m_compositingDirtyBits);</span>
      }
  
      // Recur into our children to collect more layers, but only if we don&#39;t establish
      // a stacking context/container.
      if ((includeHiddenLayers || m_hasVisibleDescendant) &amp;&amp; !isStacking) {
          for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
              // Ignore reflections.
              if (!isReflectionLayer(*child))
<span class="line-modified">!                 child-&gt;collectLayers(includeHiddenLayers, positiveZOrderList, negativeZOrderList, accumulatedDirtyFlags);</span>
          }
      }
  }
  
  void RenderLayer::setAncestorsHaveCompositingDirtyFlag(Compositing flag)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1240,10 ***</span>
<span class="line-new-header">--- 1266,69 ---</span>
              break;
      }
  }
  #endif
  
<span class="line-added">+ static inline LayoutRect computeReferenceRectFromBox(const RenderBox&amp; box, const CSSBoxType&amp; boxType, const LayoutSize&amp; offsetFromRoot)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     LayoutRect referenceBox;</span>
<span class="line-added">+     switch (boxType) {</span>
<span class="line-added">+     case CSSBoxType::ContentBox:</span>
<span class="line-added">+     case CSSBoxType::FillBox:</span>
<span class="line-added">+         referenceBox = box.contentBoxRect();</span>
<span class="line-added">+         referenceBox.move(offsetFromRoot);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case CSSBoxType::PaddingBox:</span>
<span class="line-added">+         referenceBox = box.paddingBoxRect();</span>
<span class="line-added">+         referenceBox.move(offsetFromRoot);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case CSSBoxType::MarginBox:</span>
<span class="line-added">+         referenceBox = box.marginBoxRect();</span>
<span class="line-added">+         referenceBox.move(offsetFromRoot);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     // stroke-box, view-box compute to border-box for HTML elements.</span>
<span class="line-added">+     case CSSBoxType::StrokeBox:</span>
<span class="line-added">+     case CSSBoxType::ViewBox:</span>
<span class="line-added">+     case CSSBoxType::BorderBox:</span>
<span class="line-added">+     case CSSBoxType::BoxMissing:</span>
<span class="line-added">+         referenceBox = box.borderBoxRect();</span>
<span class="line-added">+         referenceBox.move(offsetFromRoot);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return referenceBox;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static inline LayoutRect computeReferenceBox(const RenderObject&amp; renderer, const CSSBoxType&amp; boxType, const LayoutSize&amp; offsetFromRoot, const LayoutRect&amp; rootRelativeBounds)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // FIXME: Support different reference boxes for inline content.</span>
<span class="line-added">+     // https://bugs.webkit.org/show_bug.cgi?id=129047</span>
<span class="line-added">+     if (!renderer.isBox())</span>
<span class="line-added">+         return rootRelativeBounds;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return computeReferenceRectFromBox(downcast&lt;RenderBox&gt;(renderer), boxType, offsetFromRoot);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static inline CSSBoxType transformBoxToCSSBoxType(TransformBox transformBox)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (transformBox) {</span>
<span class="line-added">+     case TransformBox::StrokeBox:</span>
<span class="line-added">+         return CSSBoxType::StrokeBox;</span>
<span class="line-added">+     case TransformBox::ContentBox:</span>
<span class="line-added">+         return CSSBoxType::ContentBox;</span>
<span class="line-added">+     case TransformBox::BorderBox:</span>
<span class="line-added">+         return CSSBoxType::BorderBox;</span>
<span class="line-added">+     case TransformBox::FillBox:</span>
<span class="line-added">+         return CSSBoxType::FillBox;</span>
<span class="line-added">+     case TransformBox::ViewBox:</span>
<span class="line-added">+         return CSSBoxType::ViewBox;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+         return CSSBoxType::BorderBox;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void RenderLayer::updateTransform()
  {
      bool hasTransform = renderer().hasTransform();
      bool had3DTransform = has3DTransform();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1260,11 ***</span>
  
      if (hasTransform) {
          RenderBox* box = renderBox();
          ASSERT(box);
          m_transform-&gt;makeIdentity();
<span class="line-modified">!         box-&gt;style().applyTransform(*m_transform, snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor()), RenderStyle::IncludeTransformOrigin);</span>
          makeMatrixRenderable(*m_transform, canRender3DTransforms());
      }
  
      if (had3DTransform != has3DTransform()) {
          dirty3DTransformedDescendantStatus();
<span class="line-new-header">--- 1345,13 ---</span>
  
      if (hasTransform) {
          RenderBox* box = renderBox();
          ASSERT(box);
          m_transform-&gt;makeIdentity();
<span class="line-modified">!         LayoutSize offsetFromRoot;</span>
<span class="line-added">+         auto computedReferenceBox = computeReferenceRectFromBox(*box, transformBoxToCSSBoxType(box-&gt;style().transformBox()), offsetFromRoot);</span>
<span class="line-added">+         box-&gt;style().applyTransform(*m_transform, snapRectToDevicePixels(computedReferenceBox, box-&gt;document().deviceScaleFactor()), RenderStyle::IncludeTransformOrigin);</span>
          makeMatrixRenderable(*m_transform, canRender3DTransforms());
      }
  
      if (had3DTransform != has3DTransform()) {
          dirty3DTransformedDescendantStatus();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1282,33 ***</span>
  
      if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
          if (auto* timeline = renderer().documentTimeline()) {
              if (timeline-&gt;isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform)) {
                  TransformationMatrix currTransform;
<span class="line-modified">!                 FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor());</span>
                  std::unique_ptr&lt;RenderStyle&gt; style = timeline-&gt;animatedStyleForRenderer(renderer());
                  style-&gt;applyTransform(currTransform, pixelSnappedBorderRect, applyOrigin);
                  makeMatrixRenderable(currTransform, canRender3DTransforms());
                  return currTransform;
              }
          }
      } else {
          if (renderer().animation().isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform)) {
              TransformationMatrix currTransform;
<span class="line-removed">-             FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor());</span>
              std::unique_ptr&lt;RenderStyle&gt; style = renderer().animation().animatedStyleForRenderer(renderer());
              style-&gt;applyTransform(currTransform, pixelSnappedBorderRect, applyOrigin);
              makeMatrixRenderable(currTransform, canRender3DTransforms());
              return currTransform;
          }
      }
  
  
      // m_transform includes transform-origin, so we need to recompute the transform here.
      if (applyOrigin == RenderStyle::ExcludeTransformOrigin) {
          TransformationMatrix currTransform;
<span class="line-modified">!         FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor());</span>
          box-&gt;style().applyTransform(currTransform, pixelSnappedBorderRect, RenderStyle::ExcludeTransformOrigin);
          makeMatrixRenderable(currTransform, canRender3DTransforms());
          return currTransform;
      }
  
<span class="line-new-header">--- 1369,40 ---</span>
  
      if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
          if (auto* timeline = renderer().documentTimeline()) {
              if (timeline-&gt;isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform)) {
                  TransformationMatrix currTransform;
<span class="line-modified">!                 LayoutSize offsetFromRoot;</span>
                  std::unique_ptr&lt;RenderStyle&gt; style = timeline-&gt;animatedStyleForRenderer(renderer());
<span class="line-added">+                 auto computedReferenceBox = computeReferenceBox(renderer(), transformBoxToCSSBoxType(style-&gt;transformBox()), offsetFromRoot, box-&gt;borderBoxRect());</span>
<span class="line-added">+                 FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(computedReferenceBox, box-&gt;document().deviceScaleFactor());</span>
                  style-&gt;applyTransform(currTransform, pixelSnappedBorderRect, applyOrigin);
                  makeMatrixRenderable(currTransform, canRender3DTransforms());
                  return currTransform;
              }
          }
      } else {
          if (renderer().animation().isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform)) {
              TransformationMatrix currTransform;
              std::unique_ptr&lt;RenderStyle&gt; style = renderer().animation().animatedStyleForRenderer(renderer());
<span class="line-added">+             LayoutSize offsetFromRoot;</span>
<span class="line-added">+             auto computedReferenceBox = computeReferenceBox(renderer(), transformBoxToCSSBoxType(style-&gt;transformBox()), offsetFromRoot, box-&gt;borderBoxRect());</span>
<span class="line-added">+             FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(computedReferenceBox, box-&gt;document().deviceScaleFactor());</span>
              style-&gt;applyTransform(currTransform, pixelSnappedBorderRect, applyOrigin);
              makeMatrixRenderable(currTransform, canRender3DTransforms());
              return currTransform;
          }
      }
  
  
      // m_transform includes transform-origin, so we need to recompute the transform here.
      if (applyOrigin == RenderStyle::ExcludeTransformOrigin) {
          TransformationMatrix currTransform;
<span class="line-modified">!         LayoutSize offsetFromRoot;</span>
<span class="line-added">+         std::unique_ptr&lt;RenderStyle&gt; style = renderer().animation().animatedStyleForRenderer(renderer());</span>
<span class="line-added">+         auto computedReferenceBox = computeReferenceBox(renderer(), transformBoxToCSSBoxType(style-&gt;transformBox()), offsetFromRoot, box-&gt;borderBoxRect());</span>
<span class="line-added">+         FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(computedReferenceBox, box-&gt;document().deviceScaleFactor());</span>
          box-&gt;style().applyTransform(currTransform, pixelSnappedBorderRect, RenderStyle::ExcludeTransformOrigin);
          makeMatrixRenderable(currTransform, canRender3DTransforms());
          return currTransform;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1926,11 ***</span>
  
      if (rect.isEmpty())
          return;
  
      LayoutRect rectForRepaint = rect;
<span class="line-modified">!     renderer().style().filterOutsets().expandRect(rectForRepaint);</span>
  
      m_filters-&gt;expandDirtySourceRect(rectForRepaint);
  
      RenderLayer* parentLayer = enclosingFilterRepaintLayer();
      ASSERT(parentLayer);
<span class="line-new-header">--- 2020,11 ---</span>
  
      if (rect.isEmpty())
          return;
  
      LayoutRect rectForRepaint = rect;
<span class="line-modified">!     rectForRepaint += filterOutsets();</span>
  
      m_filters-&gt;expandDirtySourceRect(rectForRepaint);
  
      RenderLayer* parentLayer = enclosingFilterRepaintLayer();
      ASSERT(parentLayer);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1961,11 ***</span>
  }
  
  bool RenderLayer::hasAncestorWithFilterOutsets() const
  {
      for (const RenderLayer* curr = this; curr; curr = curr-&gt;parent()) {
<span class="line-modified">!         if (curr-&gt;renderer().style().hasFilterOutsets())</span>
              return true;
      }
      return false;
  }
  
<span class="line-new-header">--- 2055,11 ---</span>
  }
  
  bool RenderLayer::hasAncestorWithFilterOutsets() const
  {
      for (const RenderLayer* curr = this; curr; curr = curr-&gt;parent()) {
<span class="line-modified">!         if (curr-&gt;hasFilterOutsets())</span>
              return true;
      }
      return false;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2084,11 ***</span>
  
          // We don&#39;t use fragment boxes when collecting a transformed layer&#39;s bounding box, since it always
          // paints unfragmented.
          LayoutRect clipRect = layer.boundingBox(&amp;layer);
          expandClipRectForDescendantsAndReflection(clipRect, layer, &amp;layer, transparencyBehavior, paintBehavior);
<span class="line-modified">!         layer.renderer().style().filterOutsets().expandRect(clipRect);</span>
          LayoutRect result = transform.mapRect(clipRect);
          if (!paginationLayer)
              return result;
  
          // We have to break up the transformed extent across our columns.
<span class="line-new-header">--- 2178,11 ---</span>
  
          // We don&#39;t use fragment boxes when collecting a transformed layer&#39;s bounding box, since it always
          // paints unfragmented.
          LayoutRect clipRect = layer.boundingBox(&amp;layer);
          expandClipRectForDescendantsAndReflection(clipRect, layer, &amp;layer, transparencyBehavior, paintBehavior);
<span class="line-modified">!         clipRect += layer.filterOutsets();</span>
          LayoutRect result = transform.mapRect(clipRect);
          if (!paginationLayer)
              return result;
  
          // We have to break up the transformed extent across our columns.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2100,11 ***</span>
          return result;
      }
  
      LayoutRect clipRect = layer.boundingBox(rootLayer, layer.offsetFromAncestor(rootLayer), transparencyBehavior == HitTestingTransparencyClipBox ? RenderLayer::UseFragmentBoxesIncludingCompositing : RenderLayer::UseFragmentBoxesExcludingCompositing);
      expandClipRectForDescendantsAndReflection(clipRect, layer, rootLayer, transparencyBehavior, paintBehavior);
<span class="line-modified">!     layer.renderer().style().filterOutsets().expandRect(clipRect);</span>
  
      return clipRect;
  }
  
  static LayoutRect paintingExtent(const RenderLayer&amp; currentLayer, const RenderLayer* rootLayer, const LayoutRect&amp; paintDirtyRect, OptionSet&lt;PaintBehavior&gt; paintBehavior)
<span class="line-new-header">--- 2194,11 ---</span>
          return result;
      }
  
      LayoutRect clipRect = layer.boundingBox(rootLayer, layer.offsetFromAncestor(rootLayer), transparencyBehavior == HitTestingTransparencyClipBox ? RenderLayer::UseFragmentBoxesIncludingCompositing : RenderLayer::UseFragmentBoxesExcludingCompositing);
      expandClipRectForDescendantsAndReflection(clipRect, layer, rootLayer, transparencyBehavior, paintBehavior);
<span class="line-modified">!     clipRect += layer.filterOutsets();</span>
  
      return clipRect;
  }
  
  static LayoutRect paintingExtent(const RenderLayer&amp; currentLayer, const RenderLayer* rootLayer, const LayoutRect&amp; paintDirtyRect, OptionSet&lt;PaintBehavior&gt; paintBehavior)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2165,10 ***</span>
<span class="line-new-header">--- 2259,31 ---</span>
              return true;
      }
      return false;
  }
  
<span class="line-added">+ static RenderLayer* findCommonAncestor(const RenderLayer&amp; firstLayer, const RenderLayer&amp; secondLayer)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (&amp;firstLayer == &amp;secondLayer)</span>
<span class="line-added">+         return const_cast&lt;RenderLayer*&gt;(&amp;firstLayer);</span>
<span class="line-added">+ </span>
<span class="line-added">+     HashSet&lt;const RenderLayer*&gt; ancestorChain;</span>
<span class="line-added">+     for (auto* currLayer = &amp;firstLayer; currLayer; currLayer = currLayer-&gt;parent())</span>
<span class="line-added">+         ancestorChain.add(currLayer);</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto* currLayer = &amp;secondLayer; currLayer; currLayer = currLayer-&gt;parent()) {</span>
<span class="line-added">+         if (ancestorChain.contains(currLayer))</span>
<span class="line-added">+             return const_cast&lt;RenderLayer*&gt;(currLayer);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RenderLayer* RenderLayer::commonAncestorWithLayer(const RenderLayer&amp; layer) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return findCommonAncestor(*this, layer);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void RenderLayer::convertToPixelSnappedLayerCoords(const RenderLayer* ancestorLayer, IntPoint&amp; roundedLocation, ColumnOffsetAdjustment adjustForColumns) const
  {
      LayoutPoint location = convertToLayerCoords(ancestorLayer, roundedLocation, adjustForColumns);
      roundedLocation = roundedIntPoint(location);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2479,26 ***</span>
  ScrollOffset RenderLayer::clampScrollOffset(const ScrollOffset&amp; scrollOffset) const
  {
      return scrollOffset.constrainedBetween(IntPoint(), maximumScrollOffset());
  }
  
  void RenderLayer::scrollToOffset(const ScrollOffset&amp; scrollOffset, ScrollType scrollType, ScrollClamping clamping)
  {
      ScrollOffset clampedScrollOffset = clamping == ScrollClamping::Clamped ? clampScrollOffset(scrollOffset) : scrollOffset;
      if (clampedScrollOffset == this-&gt;scrollOffset())
          return;
  
      auto previousScrollType = currentScrollType();
      setCurrentScrollType(scrollType);
  
<span class="line-modified">!     bool handled = false;</span>
<span class="line-removed">- #if ENABLE(ASYNC_SCROLLING)</span>
<span class="line-removed">-     if (ScrollingCoordinator* scrollingCoordinator = page().scrollingCoordinator())</span>
<span class="line-removed">-         handled = scrollingCoordinator-&gt;requestScrollPositionUpdate(*this, scrollPositionFromOffset(clampedScrollOffset));</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!handled)</span>
          scrollToOffsetWithoutAnimation(clampedScrollOffset, clamping);
  
      setCurrentScrollType(previousScrollType);
  }
  
<span class="line-new-header">--- 2594,29 ---</span>
  ScrollOffset RenderLayer::clampScrollOffset(const ScrollOffset&amp; scrollOffset) const
  {
      return scrollOffset.constrainedBetween(IntPoint(), maximumScrollOffset());
  }
  
<span class="line-added">+ bool RenderLayer::requestScrollPositionUpdate(const ScrollPosition&amp; position, ScrollType scrollType, ScrollClamping clamping)</span>
<span class="line-added">+ {</span>
<span class="line-added">+ #if ENABLE(ASYNC_SCROLLING)</span>
<span class="line-added">+     if (ScrollingCoordinator* scrollingCoordinator = page().scrollingCoordinator())</span>
<span class="line-added">+         return scrollingCoordinator-&gt;requestScrollPositionUpdate(*this, position, scrollType, clamping);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void RenderLayer::scrollToOffset(const ScrollOffset&amp; scrollOffset, ScrollType scrollType, ScrollClamping clamping)
  {
      ScrollOffset clampedScrollOffset = clamping == ScrollClamping::Clamped ? clampScrollOffset(scrollOffset) : scrollOffset;
      if (clampedScrollOffset == this-&gt;scrollOffset())
          return;
  
      auto previousScrollType = currentScrollType();
      setCurrentScrollType(scrollType);
  
<span class="line-modified">!     if (!requestScrollPositionUpdate(scrollPositionFromOffset(clampedScrollOffset), scrollType, clamping))</span>
          scrollToOffsetWithoutAnimation(clampedScrollOffset, clamping);
  
      setCurrentScrollType(previousScrollType);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2601,16 ***</span>
      if (requiresRepaint)
          renderer().repaintUsingContainer(repaintContainer, rectForRepaint);
  
      // Schedule the scroll and scroll-related DOM events.
      if (Element* element = renderer().element())
<span class="line-modified">!         element-&gt;document().eventQueue().enqueueOrDispatchScrollEvent(*element);</span>
  
      if (scrollsOverflow())
          view.frameView().didChangeScrollOffset();
  
      view.frameView().viewportContentsChanged();
  }
  
  static inline bool frameElementAndViewPermitScroll(HTMLFrameElementBase* frameElementBase, FrameView&amp; frameView)
  {
      // If scrollbars aren&#39;t explicitly forbidden, permit scrolling.
<span class="line-new-header">--- 2719,17 ---</span>
      if (requiresRepaint)
          renderer().repaintUsingContainer(repaintContainer, rectForRepaint);
  
      // Schedule the scroll and scroll-related DOM events.
      if (Element* element = renderer().element())
<span class="line-modified">!         element-&gt;document().addPendingScrollEventTarget(*element);</span>
  
      if (scrollsOverflow())
          view.frameView().didChangeScrollOffset();
  
      view.frameView().viewportContentsChanged();
<span class="line-added">+     frame.editor().renderLayerDidScroll(*this);</span>
  }
  
  static inline bool frameElementAndViewPermitScroll(HTMLFrameElementBase* frameElementBase, FrameView&amp; frameView)
  {
      // If scrollbars aren&#39;t explicitly forbidden, permit scrolling.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2931,27 ***</span>
  
      Resize resize = renderer-&gt;style().resize();
      if (resize != Resize::Vertical &amp;&amp; difference.width()) {
          if (is&lt;HTMLFormControlElement&gt;(*element)) {
              // Make implicit margins from the theme explicit (see &lt;http://bugs.webkit.org/show_bug.cgi?id=9547&gt;).
<span class="line-modified">!             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginLeft, renderer-&gt;marginLeft() / zoomFactor, CSSPrimitiveValue::CSS_PX);</span>
<span class="line-modified">!             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginRight, renderer-&gt;marginRight() / zoomFactor, CSSPrimitiveValue::CSS_PX);</span>
          }
          LayoutUnit baseWidth = renderer-&gt;width() - (isBoxSizingBorder ? 0_lu : renderer-&gt;horizontalBorderAndPaddingExtent());
          baseWidth = baseWidth / zoomFactor;
<span class="line-modified">!         styledElement-&gt;setInlineStyleProperty(CSSPropertyWidth, roundToInt(baseWidth + difference.width()), CSSPrimitiveValue::CSS_PX);</span>
      }
  
      if (resize != Resize::Horizontal &amp;&amp; difference.height()) {
          if (is&lt;HTMLFormControlElement&gt;(*element)) {
              // Make implicit margins from the theme explicit (see &lt;http://bugs.webkit.org/show_bug.cgi?id=9547&gt;).
<span class="line-modified">!             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginTop, renderer-&gt;marginTop() / zoomFactor, CSSPrimitiveValue::CSS_PX);</span>
<span class="line-modified">!             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginBottom, renderer-&gt;marginBottom() / zoomFactor, CSSPrimitiveValue::CSS_PX);</span>
          }
          LayoutUnit baseHeight = renderer-&gt;height() - (isBoxSizingBorder ? 0_lu : renderer-&gt;verticalBorderAndPaddingExtent());
          baseHeight = baseHeight / zoomFactor;
<span class="line-modified">!         styledElement-&gt;setInlineStyleProperty(CSSPropertyHeight, roundToInt(baseHeight + difference.height()), CSSPrimitiveValue::CSS_PX);</span>
      }
  
      document.updateLayout();
  
      // FIXME (Radar 4118564): We should also autoscroll the window as necessary to keep the point under the cursor in view.
<span class="line-new-header">--- 3050,27 ---</span>
  
      Resize resize = renderer-&gt;style().resize();
      if (resize != Resize::Vertical &amp;&amp; difference.width()) {
          if (is&lt;HTMLFormControlElement&gt;(*element)) {
              // Make implicit margins from the theme explicit (see &lt;http://bugs.webkit.org/show_bug.cgi?id=9547&gt;).
<span class="line-modified">!             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginLeft, renderer-&gt;marginLeft() / zoomFactor, CSSUnitType::CSS_PX);</span>
<span class="line-modified">!             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginRight, renderer-&gt;marginRight() / zoomFactor, CSSUnitType::CSS_PX);</span>
          }
          LayoutUnit baseWidth = renderer-&gt;width() - (isBoxSizingBorder ? 0_lu : renderer-&gt;horizontalBorderAndPaddingExtent());
          baseWidth = baseWidth / zoomFactor;
<span class="line-modified">!         styledElement-&gt;setInlineStyleProperty(CSSPropertyWidth, roundToInt(baseWidth + difference.width()), CSSUnitType::CSS_PX);</span>
      }
  
      if (resize != Resize::Horizontal &amp;&amp; difference.height()) {
          if (is&lt;HTMLFormControlElement&gt;(*element)) {
              // Make implicit margins from the theme explicit (see &lt;http://bugs.webkit.org/show_bug.cgi?id=9547&gt;).
<span class="line-modified">!             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginTop, renderer-&gt;marginTop() / zoomFactor, CSSUnitType::CSS_PX);</span>
<span class="line-modified">!             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginBottom, renderer-&gt;marginBottom() / zoomFactor, CSSUnitType::CSS_PX);</span>
          }
          LayoutUnit baseHeight = renderer-&gt;height() - (isBoxSizingBorder ? 0_lu : renderer-&gt;verticalBorderAndPaddingExtent());
          baseHeight = baseHeight / zoomFactor;
<span class="line-modified">!         styledElement-&gt;setInlineStyleProperty(CSSPropertyHeight, roundToInt(baseHeight + difference.height()), CSSUnitType::CSS_PX);</span>
      }
  
      document.updateLayout();
  
      // FIXME (Radar 4118564): We should also autoscroll the window as necessary to keep the point under the cursor in view.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3291,16 ***</span>
          m_resizer-&gt;repaintRectangle(rect);
  }
  
  static bool scrollbarHiddenByStyle(Scrollbar* scrollbar)
  {
<span class="line-modified">!     if (!scrollbar || !scrollbar-&gt;isCustomScrollbar())</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     std::unique_ptr&lt;RenderStyle&gt; scrollbarStyle = static_cast&lt;RenderScrollbar*&gt;(scrollbar)-&gt;getScrollbarPseudoStyle(ScrollbarBGPart, PseudoId::Scrollbar);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return scrollbarStyle &amp;&amp; scrollbarStyle-&gt;display() == DisplayType::None;</span>
  }
  
  bool RenderLayer::horizontalScrollbarHiddenByStyle() const
  {
      return scrollbarHiddenByStyle(horizontalScrollbar());
<span class="line-new-header">--- 3410,11 ---</span>
          m_resizer-&gt;repaintRectangle(rect);
  }
  
  static bool scrollbarHiddenByStyle(Scrollbar* scrollbar)
  {
<span class="line-modified">!     return scrollbar &amp;&amp; scrollbar-&gt;isHiddenByStyle();</span>
  }
  
  bool RenderLayer::horizontalScrollbarHiddenByStyle() const
  {
      return scrollbarHiddenByStyle(horizontalScrollbar());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3332,12 ***</span>
      if (hasCustomScrollbarStyle)
          widget = RenderScrollbar::createCustomScrollbar(*this, orientation, downcast&lt;RenderBox&gt;(actualRenderer).element());
      else {
          widget = Scrollbar::createNativeScrollbar(*this, orientation, RegularScrollbar);
          didAddScrollbar(widget.get(), orientation);
<span class="line-modified">!         if (page().expectsWheelEventTriggers())</span>
<span class="line-modified">!             scrollAnimator().setWheelEventTestTrigger(page().testTrigger());</span>
      }
      renderer().view().frameView().addChild(*widget);
      return widget.releaseNonNull();
  }
  
<span class="line-new-header">--- 3446,12 ---</span>
      if (hasCustomScrollbarStyle)
          widget = RenderScrollbar::createCustomScrollbar(*this, orientation, downcast&lt;RenderBox&gt;(actualRenderer).element());
      else {
          widget = Scrollbar::createNativeScrollbar(*this, orientation, RegularScrollbar);
          didAddScrollbar(widget.get(), orientation);
<span class="line-modified">!         if (page().isMonitoringWheelEvents())</span>
<span class="line-modified">!             scrollAnimator().setWheelEventTestMonitor(page().wheelEventTestMonitor());</span>
      }
      renderer().view().frameView().addChild(*widget);
      return widget.releaseNonNull();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4269,46 ***</span>
          return true;
      }
      return false;
  }
  
<span class="line-removed">- static inline LayoutRect computeReferenceBox(const RenderObject&amp; renderer, const CSSBoxType&amp; boxType, const LayoutSize&amp; offsetFromRoot, const LayoutRect&amp; rootRelativeBounds)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // FIXME: Support different reference boxes for inline content.</span>
<span class="line-removed">-     // https://bugs.webkit.org/show_bug.cgi?id=129047</span>
<span class="line-removed">-     if (!renderer.isBox())</span>
<span class="line-removed">-         return rootRelativeBounds;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     LayoutRect referenceBox;</span>
<span class="line-removed">-     const auto&amp; box = downcast&lt;RenderBox&gt;(renderer);</span>
<span class="line-removed">-     switch (boxType) {</span>
<span class="line-removed">-     case CSSBoxType::ContentBox:</span>
<span class="line-removed">-     case CSSBoxType::FillBox:</span>
<span class="line-removed">-         referenceBox = box.contentBoxRect();</span>
<span class="line-removed">-         referenceBox.move(offsetFromRoot);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case CSSBoxType::PaddingBox:</span>
<span class="line-removed">-         referenceBox = box.paddingBoxRect();</span>
<span class="line-removed">-         referenceBox.move(offsetFromRoot);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case CSSBoxType::MarginBox:</span>
<span class="line-removed">-         referenceBox = box.marginBoxRect();</span>
<span class="line-removed">-         referenceBox.move(offsetFromRoot);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     // stroke-box, view-box compute to border-box for HTML elements.</span>
<span class="line-removed">-     case CSSBoxType::StrokeBox:</span>
<span class="line-removed">-     case CSSBoxType::ViewBox:</span>
<span class="line-removed">-     case CSSBoxType::BorderBox:</span>
<span class="line-removed">-     case CSSBoxType::BoxMissing:</span>
<span class="line-removed">-         referenceBox = box.borderBoxRect();</span>
<span class="line-removed">-         referenceBox.move(offsetFromRoot);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return referenceBox;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  Path RenderLayer::computeClipPath(const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, WindRule&amp; windRule) const
  {
      const RenderStyle&amp; style = renderer().style();
      float deviceSaleFactor = renderer().document().deviceScaleFactor();
  
<span class="line-new-header">--- 4383,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4457,12 ***</span>
          &amp;&amp; (renderer().view().printing() || renderer().view().hasRenderersWithOutline())
          &amp;&amp; ((isPaintingScrollingContent &amp;&amp; isPaintingCompositedBackground)
          || (!isPaintingScrollingContent &amp;&amp; isPaintingCompositedForeground));
      bool shouldPaintContent = m_hasVisibleContent &amp;&amp; isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars &amp;&amp; !isCollectingEventRegion;
  
<span class="line-modified">!     if (localPaintFlags &amp; PaintLayerPaintingRootBackgroundOnly &amp;&amp; !renderer().isRenderView() &amp;&amp; !renderer().isDocumentElementRenderer())</span>
          return;
  
      updateLayerListsIfNeeded();
  
      LayoutSize offsetFromRoot = offsetFromAncestor(paintingInfo.rootLayer);
      LayoutRect rootRelativeBounds;
<span class="line-new-header">--- 4535,20 ---</span>
          &amp;&amp; (renderer().view().printing() || renderer().view().hasRenderersWithOutline())
          &amp;&amp; ((isPaintingScrollingContent &amp;&amp; isPaintingCompositedBackground)
          || (!isPaintingScrollingContent &amp;&amp; isPaintingCompositedForeground));
      bool shouldPaintContent = m_hasVisibleContent &amp;&amp; isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars &amp;&amp; !isCollectingEventRegion;
  
<span class="line-modified">!     if (localPaintFlags &amp; PaintLayerPaintingRootBackgroundOnly &amp;&amp; !renderer().isRenderView() &amp;&amp; !renderer().isDocumentElementRenderer()) {</span>
<span class="line-added">+         // If beginTransparencyLayers was called prior to this, ensure the transparency state is cleaned up before returning.</span>
<span class="line-added">+         if (haveTransparency &amp;&amp; m_usedTransparency &amp;&amp; !m_paintingInsideReflection) {</span>
<span class="line-added">+             context.endTransparencyLayer();</span>
<span class="line-added">+             context.restore();</span>
<span class="line-added">+             m_usedTransparency = false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          return;
<span class="line-added">+     }</span>
  
      updateLayerListsIfNeeded();
  
      LayoutSize offsetFromRoot = offsetFromAncestor(paintingInfo.rootLayer);
      LayoutRect rootRelativeBounds;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4678,11 ***</span>
          return;
  
      if (!hasSelfPaintingLayerDescendant())
          return;
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      LayerListMutationDetector mutationChecker(*this);
  #endif
  
      for (auto* childLayer : layerIterator)
          childLayer-&gt;paintLayer(context, paintingInfo, paintFlags);
<span class="line-new-header">--- 4764,11 ---</span>
          return;
  
      if (!hasSelfPaintingLayerDescendant())
          return;
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      LayerListMutationDetector mutationChecker(*this);
  #endif
  
      for (auto* childLayer : layerIterator)
          childLayer-&gt;paintLayer(context, paintingInfo, paintFlags);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5293,11 ***</span>
          zOffsetForContentsPtr = zOffset;
      }
  
      // This variable tracks which layer the mouse ends up being inside.
      RenderLayer* candidateLayer = nullptr;
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      LayerListMutationDetector mutationChecker(*this);
  #endif
  
      // Begin by walking our list of positive layers from highest z-index down to the lowest z-index.
      auto* hitLayer = hitTestList(positiveZOrderLayers(), rootLayer, request, result, hitTestRect, hitTestLocation,
<span class="line-new-header">--- 5379,11 ---</span>
          zOffsetForContentsPtr = zOffset;
      }
  
      // This variable tracks which layer the mouse ends up being inside.
      RenderLayer* candidateLayer = nullptr;
<span class="line-modified">! #if ASSERT_ENABLED</span>
      LayerListMutationDetector mutationChecker(*this);
  #endif
  
      // Begin by walking our list of positive layers from highest z-index down to the lowest z-index.
      auto* hitLayer = hitTestList(positiveZOrderLayers(), rootLayer, request, result, hitTestRect, hitTestLocation,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5574,11 ***</span>
          }
      }
  
      if (!m_clipRectsCache)
          m_clipRectsCache = makeUnique&lt;ClipRectsCache&gt;();
<span class="line-modified">! #ifndef NDEBUG</span>
      m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType] = clipRectsContext.rootLayer;
      m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] = clipRectsContext.overlayScrollbarSizeRelevancy;
  #endif
  
      RefPtr&lt;ClipRects&gt; parentClipRects;
<span class="line-new-header">--- 5660,11 ---</span>
          }
      }
  
      if (!m_clipRectsCache)
          m_clipRectsCache = makeUnique&lt;ClipRectsCache&gt;();
<span class="line-modified">! #if ASSERT_ENABLED</span>
      m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType] = clipRectsContext.rootLayer;
      m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] = clipRectsContext.overlayScrollbarSizeRelevancy;
  #endif
  
      RefPtr&lt;ClipRects&gt; parentClipRects;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6087,11 ***</span>
          }
      }
  
      ASSERT(isStackingContext() || !positiveZOrderLayers().size());
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(*this));
  #endif
  
      auto computeLayersUnion = [this, &amp;unionBounds, flags, descendantFlags] (const RenderLayer&amp; childLayer) {
          if (!(flags &amp; IncludeCompositedDescendants) &amp;&amp; (childLayer.isComposited() || childLayer.paintsIntoProvidedBacking()))
<span class="line-new-header">--- 6173,11 ---</span>
          }
      }
  
      ASSERT(isStackingContext() || !positiveZOrderLayers().size());
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(*this));
  #endif
  
      auto computeLayersUnion = [this, &amp;unionBounds, flags, descendantFlags] (const RenderLayer&amp; childLayer) {
          if (!(flags &amp; IncludeCompositedDescendants) &amp;&amp; (childLayer.isComposited() || childLayer.paintsIntoProvidedBacking()))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6110,11 ***</span>
  
      for (auto* childLayer : normalFlowLayers())
          computeLayersUnion(*childLayer);
  
      if (flags.contains(IncludeFilterOutsets) || (flags.contains(IncludePaintedFilterOutsets) &amp;&amp; paintsWithFilters()))
<span class="line-modified">!         renderer().style().filterOutsets().expandRect(unionBounds);</span>
  
      if ((flags &amp; IncludeSelfTransform) &amp;&amp; paintsWithTransform(PaintBehavior::Normal)) {
          TransformationMatrix* affineTrans = transform();
          boundingBoxRect = affineTrans-&gt;mapRect(boundingBoxRect);
          unionBounds = affineTrans-&gt;mapRect(unionBounds);
<span class="line-new-header">--- 6196,11 ---</span>
  
      for (auto* childLayer : normalFlowLayers())
          computeLayersUnion(*childLayer);
  
      if (flags.contains(IncludeFilterOutsets) || (flags.contains(IncludePaintedFilterOutsets) &amp;&amp; paintsWithFilters()))
<span class="line-modified">!         unionBounds += filterOutsets();</span>
  
      if ((flags &amp; IncludeSelfTransform) &amp;&amp; paintsWithTransform(PaintBehavior::Normal)) {
          TransformationMatrix* affineTrans = transform();
          boundingBoxRect = affineTrans-&gt;mapRect(boundingBoxRect);
          unionBounds = affineTrans-&gt;mapRect(unionBounds);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6553,14 ***</span>
              }
          }
  #endif
      }
  
<span class="line-modified">!     // FIXME: RenderLayer already handles visibility changes through our visiblity dirty bits. This logic could</span>
      // likely be folded along with the rest.
      if (oldStyle) {
<span class="line-modified">!         if (oldStyle-&gt;zIndex() != renderer().style().zIndex() || oldStyle-&gt;visibility() != renderer().style().visibility()) {</span>
              dirtyStackingContextZOrderLists();
              if (isStackingContext())
                  dirtyZOrderLists();
          }
      }
<span class="line-new-header">--- 6639,14 ---</span>
              }
          }
  #endif
      }
  
<span class="line-modified">!     // FIXME: RenderLayer already handles visibility changes through our visibility dirty bits. This logic could</span>
      // likely be folded along with the rest.
      if (oldStyle) {
<span class="line-modified">!         if (oldStyle-&gt;usedZIndex() != renderer().style().usedZIndex() || oldStyle-&gt;visibility() != renderer().style().visibility()) {</span>
              dirtyStackingContextZOrderLists();
              if (isStackingContext())
                  dirtyZOrderLists();
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6653,11 ***</span>
  }
  
  void RenderLayer::updateScrollCornerStyle()
  {
      RenderElement* actualRenderer = rendererForScrollbar(renderer());
<span class="line-modified">!     auto corner = renderer().hasOverflowClip() ? actualRenderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::ScrollbarCorner), &amp;actualRenderer-&gt;style()) : nullptr;</span>
  
      if (!corner) {
          clearScrollCorner();
          return;
      }
<span class="line-new-header">--- 6739,11 ---</span>
  }
  
  void RenderLayer::updateScrollCornerStyle()
  {
      RenderElement* actualRenderer = rendererForScrollbar(renderer());
<span class="line-modified">!     auto corner = renderer().hasOverflowClip() ? actualRenderer-&gt;getUncachedPseudoStyle({ PseudoId::ScrollbarCorner }, &amp;actualRenderer-&gt;style()) : nullptr;</span>
  
      if (!corner) {
          clearScrollCorner();
          return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6680,11 ***</span>
  }
  
  void RenderLayer::updateResizerStyle()
  {
      RenderElement* actualRenderer = rendererForScrollbar(renderer());
<span class="line-modified">!     auto resizer = renderer().hasOverflowClip() ? actualRenderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::Resizer), &amp;actualRenderer-&gt;style()) : nullptr;</span>
  
      if (!resizer) {
          clearResizer();
          return;
      }
<span class="line-new-header">--- 6766,11 ---</span>
  }
  
  void RenderLayer::updateResizerStyle()
  {
      RenderElement* actualRenderer = rendererForScrollbar(renderer());
<span class="line-modified">!     auto resizer = renderer().hasOverflowClip() ? actualRenderer-&gt;getUncachedPseudoStyle({ PseudoId::Resizer }, &amp;actualRenderer-&gt;style()) : nullptr;</span>
  
      if (!resizer) {
          clearResizer();
          return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6740,38 ***</span>
      newStyle.inheritFrom(renderer().style());
  
      // Map in our transform.
      TransformOperations transform;
      switch (renderer().style().boxReflect()-&gt;direction()) {
<span class="line-modified">!         case ReflectionBelow:</span>
<span class="line-modified">!             transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), Length(100., Percent), TransformOperation::TRANSLATE));</span>
<span class="line-modified">!             transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), renderer().style().boxReflect()-&gt;offset(), TransformOperation::TRANSLATE));</span>
<span class="line-modified">!             transform.operations().append(ScaleTransformOperation::create(1.0, -1.0, ScaleTransformOperation::SCALE));</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case ReflectionAbove:</span>
<span class="line-modified">!             transform.operations().append(ScaleTransformOperation::create(1.0, -1.0, ScaleTransformOperation::SCALE));</span>
<span class="line-modified">!             transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), Length(100., Percent), TransformOperation::TRANSLATE));</span>
<span class="line-modified">!             transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), renderer().style().boxReflect()-&gt;offset(), TransformOperation::TRANSLATE));</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case ReflectionRight:</span>
<span class="line-modified">!             transform.operations().append(TranslateTransformOperation::create(Length(100., Percent), Length(0, Fixed), TransformOperation::TRANSLATE));</span>
<span class="line-modified">!             transform.operations().append(TranslateTransformOperation::create(renderer().style().boxReflect()-&gt;offset(), Length(0, Fixed), TransformOperation::TRANSLATE));</span>
<span class="line-modified">!             transform.operations().append(ScaleTransformOperation::create(-1.0, 1.0, ScaleTransformOperation::SCALE));</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case ReflectionLeft:</span>
<span class="line-modified">!             transform.operations().append(ScaleTransformOperation::create(-1.0, 1.0, ScaleTransformOperation::SCALE));</span>
<span class="line-modified">!             transform.operations().append(TranslateTransformOperation::create(Length(100., Percent), Length(0, Fixed), TransformOperation::TRANSLATE));</span>
<span class="line-modified">!             transform.operations().append(TranslateTransformOperation::create(renderer().style().boxReflect()-&gt;offset(), Length(0, Fixed), TransformOperation::TRANSLATE));</span>
<span class="line-modified">!             break;</span>
      }
      newStyle.setTransform(transform);
  
      // Map in our mask.
      newStyle.setMaskBoxImage(renderer().style().boxReflect()-&gt;mask());
  
      // Style has transform and mask, so needs to be stacking context.
<span class="line-modified">!     newStyle.setZIndex(0);</span>
  
      return newStyle;
  }
  
  void RenderLayer::ensureLayerFilters()
<span class="line-new-header">--- 6826,38 ---</span>
      newStyle.inheritFrom(renderer().style());
  
      // Map in our transform.
      TransformOperations transform;
      switch (renderer().style().boxReflect()-&gt;direction()) {
<span class="line-modified">!     case ReflectionDirection::Below:</span>
<span class="line-modified">!         transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), Length(100., Percent), TransformOperation::TRANSLATE));</span>
<span class="line-modified">!         transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), renderer().style().boxReflect()-&gt;offset(), TransformOperation::TRANSLATE));</span>
<span class="line-modified">!         transform.operations().append(ScaleTransformOperation::create(1.0, -1.0, ScaleTransformOperation::SCALE));</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!     case ReflectionDirection::Above:</span>
<span class="line-modified">!         transform.operations().append(ScaleTransformOperation::create(1.0, -1.0, ScaleTransformOperation::SCALE));</span>
<span class="line-modified">!         transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), Length(100., Percent), TransformOperation::TRANSLATE));</span>
<span class="line-modified">!         transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), renderer().style().boxReflect()-&gt;offset(), TransformOperation::TRANSLATE));</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!     case ReflectionDirection::Right:</span>
<span class="line-modified">!         transform.operations().append(TranslateTransformOperation::create(Length(100., Percent), Length(0, Fixed), TransformOperation::TRANSLATE));</span>
<span class="line-modified">!         transform.operations().append(TranslateTransformOperation::create(renderer().style().boxReflect()-&gt;offset(), Length(0, Fixed), TransformOperation::TRANSLATE));</span>
<span class="line-modified">!         transform.operations().append(ScaleTransformOperation::create(-1.0, 1.0, ScaleTransformOperation::SCALE));</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!     case ReflectionDirection::Left:</span>
<span class="line-modified">!         transform.operations().append(ScaleTransformOperation::create(-1.0, 1.0, ScaleTransformOperation::SCALE));</span>
<span class="line-modified">!         transform.operations().append(TranslateTransformOperation::create(Length(100., Percent), Length(0, Fixed), TransformOperation::TRANSLATE));</span>
<span class="line-modified">!         transform.operations().append(TranslateTransformOperation::create(renderer().style().boxReflect()-&gt;offset(), Length(0, Fixed), TransformOperation::TRANSLATE));</span>
<span class="line-modified">!         break;</span>
      }
      newStyle.setTransform(transform);
  
      // Map in our mask.
      newStyle.setMaskBoxImage(renderer().style().boxReflect()-&gt;mask());
  
      // Style has transform and mask, so needs to be stacking context.
<span class="line-modified">!     newStyle.setUsedZIndex(0);</span>
  
      return newStyle;
  }
  
  void RenderLayer::ensureLayerFilters()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6820,11 ***</span>
          if (!renderer().style().filter().hasReferenceFilter())
              return;
      }
  
      ensureLayerFilters();
<span class="line-modified">!     m_filters-&gt;buildFilter(renderer(), page().deviceScaleFactor(), renderer().settings().acceleratedFiltersEnabled() ? Accelerated : Unaccelerated);</span>
  }
  
  void RenderLayer::filterNeedsRepaint()
  {
      // We use the enclosing element so that we recalculate style for the ancestor of an anonymous object.
<span class="line-new-header">--- 6906,11 ---</span>
          if (!renderer().style().filter().hasReferenceFilter())
              return;
      }
  
      ensureLayerFilters();
<span class="line-modified">!     m_filters-&gt;buildFilter(renderer(), page().deviceScaleFactor(), renderer().settings().acceleratedFiltersEnabled() ? RenderingMode::Accelerated : RenderingMode::Unaccelerated);</span>
  }
  
  void RenderLayer::filterNeedsRepaint()
  {
      // We use the enclosing element so that we recalculate style for the ancestor of an anonymous object.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6833,49 ***</span>
          element-&gt;invalidateStyleAndLayerComposition();
      }
      renderer().repaint();
  }
  
<span class="line-modified">! bool RenderLayer::isTransparentOrFullyClippedRespectingParentFrames() const</span>
  {
      static const double minimumVisibleOpacity = 0.01;
  
      float currentOpacity = 1;
      for (auto* layer = this; layer; layer = parentLayerCrossFrame(*layer)) {
          currentOpacity *= layer-&gt;renderer().style().opacity();
          if (currentOpacity &lt; minimumVisibleOpacity)
              return true;
      }
  
<span class="line-removed">-     auto hasEmptyClipRect = [] (const RenderLayer&amp; layer) -&gt; bool {</span>
<span class="line-removed">-         auto* frameView = layer.renderer().document().view();</span>
<span class="line-removed">-         if (!frameView)</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto* renderView = frameView-&gt;renderView();</span>
<span class="line-removed">-         if (!renderView)</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto* renderViewLayer = renderView-&gt;layer();</span>
<span class="line-removed">-         if (!renderViewLayer)</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (is&lt;HTMLFrameOwnerElement&gt;(layer.renderer().element()) &amp;&amp; layer.visibleSize().isEmpty())</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         LayoutRect layerBounds;</span>
<span class="line-removed">-         ClipRect backgroundRect;</span>
<span class="line-removed">-         ClipRect foregroundRect;</span>
<span class="line-removed">-         layer.calculateRects({ renderViewLayer, TemporaryClipRects }, LayoutRect::infiniteRect(), layerBounds, backgroundRect, foregroundRect, layer.offsetFromAncestor(renderViewLayer));</span>
<span class="line-removed">-         return backgroundRect.isEmpty();</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (auto* layer = this; layer; layer = enclosingFrameRenderLayer(*layer)) {</span>
<span class="line-removed">-         if (hasEmptyClipRect(*layer))</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      return false;
  }
  
  void RenderLayer::invalidateEventRegion()
  {
<span class="line-new-header">--- 6919,28 ---</span>
          element-&gt;invalidateStyleAndLayerComposition();
      }
      renderer().repaint();
  }
  
<span class="line-modified">! IntOutsets RenderLayer::filterOutsets() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_filters)</span>
<span class="line-added">+         return m_filters-&gt;filter() ? m_filters-&gt;filter()-&gt;outsets() : IntOutsets();</span>
<span class="line-added">+     return renderer().style().filterOutsets();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool RenderLayer::isTransparentRespectingParentFrames() const</span>
  {
      static const double minimumVisibleOpacity = 0.01;
  
      float currentOpacity = 1;
      for (auto* layer = this; layer; layer = parentLayerCrossFrame(*layer)) {
          currentOpacity *= layer-&gt;renderer().style().opacity();
          if (currentOpacity &lt; minimumVisibleOpacity)
              return true;
      }
  
      return false;
  }
  
  void RenderLayer::invalidateEventRegion()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6947,10 ***</span>
<span class="line-new-header">--- 7012,11 ---</span>
  
  TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, IndirectCompositingReason reason)
  {
      switch (reason) {
      case IndirectCompositingReason::None: ts &lt;&lt; &quot;none&quot;; break;
<span class="line-added">+     case IndirectCompositingReason::Clipping: ts &lt;&lt; &quot;clipping&quot;; break;</span>
      case IndirectCompositingReason::Stacking: ts &lt;&lt; &quot;stacking&quot;; break;
      case IndirectCompositingReason::OverflowScrollPositioning: ts &lt;&lt; &quot;overflow positioning&quot;; break;
      case IndirectCompositingReason::Overlap: ts &lt;&lt; &quot;overlap&quot;; break;
      case IndirectCompositingReason::BackgroundLayer: ts &lt;&lt; &quot;background layer&quot;; break;
      case IndirectCompositingReason::GraphicalEffect: ts &lt;&lt; &quot;graphical effect&quot;; break;
</pre>
<center><a href="RenderInline.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayer.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
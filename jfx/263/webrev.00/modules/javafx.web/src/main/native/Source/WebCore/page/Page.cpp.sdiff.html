<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/Page.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NavigatorBase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Page.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/Page.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2008 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Library General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2 of the License, or (at your option) any later version.
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Library General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Library General Public License
  15  * along with this library; see the file COPYING.LIB.  If not, write to
  16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  17  * Boston, MA 02110-1301, USA.
  18  */
  19 
  20 #include &quot;config.h&quot;
  21 #include &quot;Page.h&quot;
  22 
  23 #include &quot;ActivityStateChangeObserver.h&quot;
  24 #include &quot;AlternativeTextClient.h&quot;
  25 #include &quot;ApplicationCacheStorage.h&quot;
<span class="line-removed">  26 #include &quot;ApplicationStateChangeListener.h&quot;</span>
  27 #include &quot;AuthenticatorCoordinator.h&quot;

  28 #include &quot;BackForwardClient.h&quot;
  29 #include &quot;BackForwardController.h&quot;
  30 #include &quot;CSSAnimationController.h&quot;
  31 #include &quot;CacheStorageProvider.h&quot;
  32 #include &quot;Chrome.h&quot;
  33 #include &quot;ChromeClient.h&quot;
  34 #include &quot;ConstantPropertyMap.h&quot;
  35 #include &quot;ContextMenuClient.h&quot;
  36 #include &quot;ContextMenuController.h&quot;
  37 #include &quot;CookieJar.h&quot;
  38 #include &quot;CustomHeaderFields.h&quot;
  39 #include &quot;DOMRect.h&quot;
  40 #include &quot;DOMRectList.h&quot;
  41 #include &quot;DatabaseProvider.h&quot;
  42 #include &quot;DiagnosticLoggingClient.h&quot;
  43 #include &quot;DiagnosticLoggingKeys.h&quot;
  44 #include &quot;DocumentLoader.h&quot;
  45 #include &quot;DocumentMarkerController.h&quot;
  46 #include &quot;DocumentTimeline.h&quot;
  47 #include &quot;DragController.h&quot;
  48 #include &quot;Editing.h&quot;
  49 #include &quot;Editor.h&quot;
  50 #include &quot;EditorClient.h&quot;
  51 #include &quot;EmptyClients.h&quot;
  52 #include &quot;Event.h&quot;
  53 #include &quot;EventNames.h&quot;
  54 #include &quot;ExtensionStyleSheets.h&quot;
  55 #include &quot;FocusController.h&quot;
  56 #include &quot;FrameLoader.h&quot;
  57 #include &quot;FrameLoaderClient.h&quot;
  58 #include &quot;FrameSelection.h&quot;
  59 #include &quot;FrameTree.h&quot;
  60 #include &quot;FrameView.h&quot;
  61 #include &quot;FullscreenManager.h&quot;
  62 #include &quot;HTMLElement.h&quot;
  63 #include &quot;HTMLMediaElement.h&quot;


  64 #include &quot;HistoryController.h&quot;
  65 #include &quot;HistoryItem.h&quot;
  66 #include &quot;InspectorClient.h&quot;
  67 #include &quot;InspectorController.h&quot;
  68 #include &quot;InspectorInstrumentation.h&quot;

  69 #include &quot;LibWebRTCProvider.h&quot;
  70 #include &quot;LoaderStrategy.h&quot;
  71 #include &quot;Logging.h&quot;
  72 #include &quot;LowPowerModeNotifier.h&quot;
  73 #include &quot;MediaCanStartListener.h&quot;

  74 #include &quot;Navigator.h&quot;
<span class="line-removed">  75 #include &quot;PageCache.h&quot;</span>
  76 #include &quot;PageConfiguration.h&quot;
  77 #include &quot;PageConsoleClient.h&quot;
  78 #include &quot;PageDebuggable.h&quot;
  79 #include &quot;PageGroup.h&quot;
  80 #include &quot;PageOverlayController.h&quot;
  81 #include &quot;PaymentCoordinator.h&quot;
  82 #include &quot;PerformanceLogging.h&quot;
  83 #include &quot;PerformanceLoggingClient.h&quot;
  84 #include &quot;PerformanceMonitor.h&quot;
  85 #include &quot;PlatformMediaSessionManager.h&quot;
  86 #include &quot;PlatformStrategies.h&quot;
  87 #include &quot;PlugInClient.h&quot;
  88 #include &quot;PluginData.h&quot;
  89 #include &quot;PluginInfoProvider.h&quot;
  90 #include &quot;PluginViewBase.h&quot;
  91 #include &quot;PointerCaptureController.h&quot;
  92 #include &quot;PointerLockController.h&quot;
  93 #include &quot;ProgressTracker.h&quot;
  94 #include &quot;RenderDescendantIterator.h&quot;
  95 #include &quot;RenderLayerCompositor.h&quot;
  96 #include &quot;RenderTheme.h&quot;
  97 #include &quot;RenderView.h&quot;
  98 #include &quot;RenderWidget.h&quot;
  99 #include &quot;ResizeObserver.h&quot;
 100 #include &quot;ResourceUsageOverlay.h&quot;
 101 #include &quot;RuntimeEnabledFeatures.h&quot;
 102 #include &quot;SVGDocumentExtensions.h&quot;
<span class="line-removed"> 103 #include &quot;SchemeRegistry.h&quot;</span>
 104 #include &quot;ScriptController.h&quot;
 105 #include &quot;ScriptedAnimationController.h&quot;
 106 #include &quot;ScrollLatchingState.h&quot;
 107 #include &quot;ScrollingCoordinator.h&quot;
 108 #include &quot;Settings.h&quot;
 109 #include &quot;SharedBuffer.h&quot;
 110 #include &quot;SocketProvider.h&quot;
 111 #include &quot;StorageArea.h&quot;
 112 #include &quot;StorageNamespace.h&quot;
 113 #include &quot;StorageNamespaceProvider.h&quot;

 114 #include &quot;StyleResolver.h&quot;
 115 #include &quot;StyleScope.h&quot;
 116 #include &quot;SubframeLoader.h&quot;
 117 #include &quot;TextIterator.h&quot;
 118 #include &quot;TextResourceDecoder.h&quot;
 119 #include &quot;UserContentProvider.h&quot;

 120 #include &quot;UserInputBridge.h&quot;
 121 #include &quot;ValidationMessageClient.h&quot;
 122 #include &quot;VisitedLinkState.h&quot;
 123 #include &quot;VisitedLinkStore.h&quot;
 124 #include &quot;VoidCallback.h&quot;
 125 #include &quot;WheelEventDeltaFilter.h&quot;
 126 #include &quot;Widget.h&quot;

 127 #include &lt;wtf/FileSystem.h&gt;
 128 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 129 #include &lt;wtf/StdLibExtras.h&gt;
 130 #include &lt;wtf/SystemTracing.h&gt;
 131 #include &lt;wtf/text/Base64.h&gt;
 132 #include &lt;wtf/text/StringHash.h&gt;
 133 
 134 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 135 #include &quot;HTMLVideoElement.h&quot;
 136 #include &quot;MediaPlaybackTarget.h&quot;
 137 #endif
 138 
 139 #if PLATFORM(MAC)
 140 #include &quot;ServicesOverlayController.h&quot;
 141 #endif
 142 
 143 #if ENABLE(MEDIA_SESSION)
 144 #include &quot;MediaSessionManager.h&quot;
 145 #endif
 146 
 147 #if ENABLE(INDEXED_DATABASE)
 148 #include &quot;IDBConnectionToServer.h&quot;
<span class="line-removed"> 149 #include &quot;InProcessIDBServer.h&quot;</span>
<span class="line-removed"> 150 #endif</span>
<span class="line-removed"> 151 </span>
<span class="line-removed"> 152 #if ENABLE(DATA_INTERACTION)</span>
<span class="line-removed"> 153 #include &quot;SelectionRect.h&quot;</span>
 154 #endif
 155 
 156 #if ENABLE(WEBGL)
 157 #include &quot;WebGLStateTracker.h&quot;
 158 #endif
 159 
 160 namespace WebCore {
 161 
 162 static HashSet&lt;Page*&gt;&amp; allPages()
 163 {
 164     static NeverDestroyed&lt;HashSet&lt;Page*&gt;&gt; set;
 165     return set;
 166 }
 167 
 168 static unsigned nonUtilityPageCount { 0 };
 169 
 170 static inline bool isUtilityPageChromeClient(ChromeClient&amp; chromeClient)
 171 {
 172     return chromeClient.isEmptyChromeClient() || chromeClient.isSVGImageChromeClient();
 173 }
</pre>
<hr />
<pre>
 197         InspectorInstrumentation::networkStateChanged(*page);
 198     }
 199 
 200     auto&amp; eventName = isOnLine ? eventNames().onlineEvent : eventNames().offlineEvent;
 201     for (auto&amp; frame : frames) {
 202         if (!frame-&gt;document())
 203             continue;
 204         frame-&gt;document()-&gt;dispatchWindowEvent(Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::No));
 205     }
 206 }
 207 
 208 static constexpr OptionSet&lt;ActivityState::Flag&gt; pageInitialActivityState()
 209 {
 210     return { ActivityState::IsVisible, ActivityState::IsInWindow };
 211 }
 212 
 213 Page::Page(PageConfiguration&amp;&amp; pageConfiguration)
 214     : m_chrome(makeUnique&lt;Chrome&gt;(*this, *pageConfiguration.chromeClient))
 215     , m_dragCaretController(makeUnique&lt;DragCaretController&gt;())
 216 #if ENABLE(DRAG_SUPPORT)
<span class="line-modified"> 217     , m_dragController(makeUnique&lt;DragController&gt;(*this, *pageConfiguration.dragClient))</span>
 218 #endif
 219     , m_focusController(makeUnique&lt;FocusController&gt;(*this, pageInitialActivityState()))
 220 #if ENABLE(CONTEXT_MENUS)
 221     , m_contextMenuController(makeUnique&lt;ContextMenuController&gt;(*this, *pageConfiguration.contextMenuClient))
 222 #endif
 223     , m_userInputBridge(makeUnique&lt;UserInputBridge&gt;(*this))
 224     , m_inspectorController(makeUnique&lt;InspectorController&gt;(*this, pageConfiguration.inspectorClient))
 225 #if ENABLE(POINTER_EVENTS)
 226     , m_pointerCaptureController(makeUnique&lt;PointerCaptureController&gt;(*this))
 227 #endif
 228 #if ENABLE(POINTER_LOCK)
 229     , m_pointerLockController(makeUnique&lt;PointerLockController&gt;(*this))
 230 #endif
 231     , m_settings(Settings::create(this))
<span class="line-modified"> 232     , m_progress(makeUnique&lt;ProgressTracker&gt;(*pageConfiguration.progressTrackerClient))</span>
 233     , m_backForwardController(makeUnique&lt;BackForwardController&gt;(*this, WTFMove(pageConfiguration.backForwardClient)))
 234     , m_mainFrame(Frame::create(this, nullptr, pageConfiguration.loaderClientForMainFrame))
 235     , m_editorClient(WTFMove(pageConfiguration.editorClient))
<span class="line-modified"> 236     , m_plugInClient(pageConfiguration.plugInClient)</span>
 237     , m_validationMessageClient(WTFMove(pageConfiguration.validationMessageClient))
 238     , m_diagnosticLoggingClient(WTFMove(pageConfiguration.diagnosticLoggingClient))
 239     , m_performanceLoggingClient(WTFMove(pageConfiguration.performanceLoggingClient))
 240 #if ENABLE(WEBGL)
 241     , m_webGLStateTracker(WTFMove(pageConfiguration.webGLStateTracker))
 242 #endif
 243 #if ENABLE(SPEECH_SYNTHESIS)
 244     , m_speechSynthesisClient(WTFMove(pageConfiguration.speechSynthesisClient))
 245 #endif

 246     , m_libWebRTCProvider(WTFMove(pageConfiguration.libWebRTCProvider))
 247     , m_verticalScrollElasticity(ScrollElasticityAllowed)
 248     , m_horizontalScrollElasticity(ScrollElasticityAllowed)
 249     , m_domTimerAlignmentInterval(DOMTimer::defaultAlignmentInterval())
 250     , m_domTimerAlignmentIntervalIncreaseTimer(*this, &amp;Page::domTimerAlignmentIntervalIncreaseTimerFired)
 251     , m_activityState(pageInitialActivityState())
<span class="line-modified"> 252     , m_alternativeTextClient(pageConfiguration.alternativeTextClient)</span>
 253     , m_consoleClient(makeUnique&lt;PageConsoleClient&gt;(*this))
 254 #if ENABLE(REMOTE_INSPECTOR)
 255     , m_inspectorDebuggable(makeUnique&lt;PageDebuggable&gt;(*this))
 256 #endif
 257     , m_socketProvider(WTFMove(pageConfiguration.socketProvider))
 258     , m_cookieJar(WTFMove(pageConfiguration.cookieJar))
 259     , m_applicationCacheStorage(*WTFMove(pageConfiguration.applicationCacheStorage))
 260     , m_cacheStorageProvider(WTFMove(pageConfiguration.cacheStorageProvider))
 261     , m_databaseProvider(*WTFMove(pageConfiguration.databaseProvider))
 262     , m_pluginInfoProvider(*WTFMove(pageConfiguration.pluginInfoProvider))
 263     , m_storageNamespaceProvider(*WTFMove(pageConfiguration.storageNamespaceProvider))
 264     , m_userContentProvider(*WTFMove(pageConfiguration.userContentProvider))
 265     , m_visitedLinkStore(*WTFMove(pageConfiguration.visitedLinkStore))
<span class="line-modified"> 266     , m_sessionID(PAL::SessionID::defaultSessionID())</span>
 267 #if ENABLE(VIDEO)
 268     , m_playbackControlsManagerUpdateTimer(*this, &amp;Page::playbackControlsManagerUpdateTimerFired)
 269 #endif
 270     , m_isUtilityPage(isUtilityPageChromeClient(chrome().client()))
 271     , m_performanceMonitor(isUtilityPage() ? nullptr : makeUnique&lt;PerformanceMonitor&gt;(*this))
 272     , m_lowPowerModeNotifier(makeUnique&lt;LowPowerModeNotifier&gt;([this](bool isLowPowerModeEnabled) { handleLowModePowerChange(isLowPowerModeEnabled); }))
 273     , m_performanceLogging(makeUnique&lt;PerformanceLogging&gt;(*this))
 274 #if PLATFORM(MAC) &amp;&amp; (ENABLE(SERVICE_CONTROLS) || ENABLE(TELEPHONE_NUMBER_DETECTION))
 275     , m_servicesOverlayController(makeUnique&lt;ServicesOverlayController&gt;(*this))
 276 #endif
 277     , m_recentWheelEventDeltaFilter(WheelEventDeltaFilter::create())
 278     , m_pageOverlayController(makeUnique&lt;PageOverlayController&gt;(*this))
 279 #if ENABLE(APPLE_PAY)
 280     , m_paymentCoordinator(makeUnique&lt;PaymentCoordinator&gt;(*pageConfiguration.paymentCoordinatorClient))
 281 #endif
 282 #if ENABLE(WEB_AUTHN)
 283     , m_authenticatorCoordinator(makeUniqueRef&lt;AuthenticatorCoordinator&gt;(WTFMove(pageConfiguration.authenticatorCoordinatorClient)))
 284 #endif
 285 #if ENABLE(APPLICATION_MANIFEST)
 286     , m_applicationManifest(pageConfiguration.applicationManifest)
 287 #endif



 288 {
 289     updateTimerThrottlingState();
 290 
 291     m_pluginInfoProvider-&gt;addPage(*this);
 292     m_userContentProvider-&gt;addPage(*this);
 293     m_visitedLinkStore-&gt;addPage(*this);
 294 
 295     static bool addedListener;
 296     if (!addedListener) {
 297         platformStrategies()-&gt;loaderStrategy()-&gt;addOnlineStateChangeListener(&amp;networkStateChanged);
 298         addedListener = true;
 299     }
 300 
 301     ASSERT(!allPages().contains(this));
 302     allPages().add(this);
 303 
 304     if (!isUtilityPage()) {
 305         ++nonUtilityPageCount;
 306         MemoryPressureHandler::setPageCount(nonUtilityPageCount);
 307     }
 308 
 309 #ifndef NDEBUG
 310     pageCounter.increment();
 311 #endif
 312 
 313 #if ENABLE(REMOTE_INSPECTOR)
 314     if (m_inspectorController-&gt;inspectorClient() &amp;&amp; m_inspectorController-&gt;inspectorClient()-&gt;allowRemoteInspectionToPageDirectly())
 315         m_inspectorDebuggable-&gt;init();
 316 #endif
 317 
 318 #if PLATFORM(COCOA)
 319     platformInitialize();
 320 #endif
 321 
 322 #if USE(LIBWEBRTC)
 323     m_libWebRTCProvider-&gt;supportsVP8(RuntimeEnabledFeatures::sharedFeatures().webRTCVP8CodecEnabled());
 324 #endif








 325 }
 326 
 327 Page::~Page()
 328 {
 329     ASSERT(!m_nestedRunLoopCount);
 330     ASSERT(!m_unnestCallback);
 331 
 332     m_validationMessageClient = nullptr;
 333     m_diagnosticLoggingClient = nullptr;
 334     m_performanceLoggingClient = nullptr;
 335     m_mainFrame-&gt;setView(nullptr);
 336     setGroupName(String());
 337     allPages().remove(this);
 338     if (!isUtilityPage()) {
 339         --nonUtilityPageCount;
 340         MemoryPressureHandler::setPageCount(nonUtilityPageCount);
 341     }
 342 
 343     m_settings-&gt;pageDestroyed();
 344 
 345     m_inspectorController-&gt;inspectedPageDestroyed();
 346 
 347     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
 348         frame-&gt;willDetachPage();
 349         frame-&gt;detachFromPage();
 350     }
 351 
<span class="line-removed"> 352     if (m_plugInClient)</span>
<span class="line-removed"> 353         m_plugInClient-&gt;pageDestroyed();</span>
<span class="line-removed"> 354     if (m_alternativeTextClient)</span>
<span class="line-removed"> 355         m_alternativeTextClient-&gt;pageDestroyed();</span>
<span class="line-removed"> 356 </span>
 357     if (m_scrollingCoordinator)
 358         m_scrollingCoordinator-&gt;pageDestroyed();
 359 
 360     backForward().close();
 361     if (!isUtilityPage())
<span class="line-modified"> 362         PageCache::singleton().removeAllItemsForPage(*this);</span>
 363 
 364 #ifndef NDEBUG
 365     pageCounter.decrement();
 366 #endif
 367 
 368     m_pluginInfoProvider-&gt;removePage(*this);
 369     m_userContentProvider-&gt;removePage(*this);
 370     m_visitedLinkStore-&gt;removePage(*this);
 371 }
 372 
 373 void Page::clearPreviousItemFromAllPages(HistoryItem* item)
 374 {
 375     for (auto* page : allPages()) {
 376         auto&amp; controller = page-&gt;mainFrame().loader().history();
 377         if (item == controller.previousItem()) {
 378             controller.clearPreviousItem();
 379             return;
 380         }
 381     }
 382 }
 383 
 384 uint64_t Page::renderTreeSize() const
 385 {
 386     uint64_t total = 0;
<span class="line-modified"> 387     for (const Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified"> 388         if (!frame-&gt;document() || !frame-&gt;document()-&gt;renderView())</span>
<span class="line-modified"> 389             continue;</span>
<span class="line-modified"> 390         total += frame-&gt;document()-&gt;renderView()-&gt;rendererCount();</span>
<span class="line-removed"> 391     }</span>
 392     return total;
 393 }
 394 
 395 OptionSet&lt;DisabledAdaptations&gt; Page::disabledAdaptations() const
 396 {
 397     if (mainFrame().document())
 398         return mainFrame().document()-&gt;disabledAdaptations();
 399 
 400     return { };
 401 }
 402 
 403 ViewportArguments Page::viewportArguments() const
 404 {
 405     return mainFrame().document() ? mainFrame().document()-&gt;viewportArguments() : ViewportArguments();
 406 }
 407 
 408 void Page::setOverrideViewportArguments(const Optional&lt;ViewportArguments&gt;&amp; viewportArguments)
 409 {
 410     if (viewportArguments == m_overrideViewportArguments)
 411         return;
</pre>
<hr />
<pre>
 548         m_group = PageGroup::pageGroup(name);
 549         m_group-&gt;addPage(*this);
 550     }
 551 }
 552 
 553 const String&amp; Page::groupName() const
 554 {
 555     return m_group ? m_group-&gt;name() : nullAtom().string();
 556 }
 557 
 558 void Page::initGroup()
 559 {
 560     ASSERT(!m_singlePageGroup);
 561     ASSERT(!m_group);
 562     m_singlePageGroup = makeUnique&lt;PageGroup&gt;(*this);
 563     m_group = m_singlePageGroup.get();
 564 }
 565 
 566 void Page::updateStyleAfterChangeInEnvironment()
 567 {
<span class="line-modified"> 568     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified"> 569         // If a change in the global environment has occurred, we need to</span>
<span class="line-modified"> 570         // make sure all the properties a recomputed, therefore we invalidate</span>
<span class="line-modified"> 571         // the properties cache.</span>
<span class="line-modified"> 572         auto* document = frame-&gt;document();</span>
<span class="line-modified"> 573         if (!document)</span>
<span class="line-modified"> 574             continue;</span>
<span class="line-removed"> 575 </span>
<span class="line-removed"> 576         if (StyleResolver* styleResolver = document-&gt;styleScope().resolverIfExists())</span>
<span class="line-removed"> 577             styleResolver-&gt;invalidateMatchedPropertiesCache();</span>
<span class="line-removed"> 578         document-&gt;scheduleFullStyleRebuild();</span>
<span class="line-removed"> 579         document-&gt;styleScope().didChangeStyleSheetEnvironment();</span>
<span class="line-removed"> 580     }</span>
 581 }
 582 
 583 void Page::updateStyleForAllPagesAfterGlobalChangeInEnvironment()
 584 {
 585     for (auto* page : allPages())
 586         page-&gt;updateStyleAfterChangeInEnvironment();
 587 }
 588 
 589 void Page::setNeedsRecalcStyleInAllFrames()
 590 {
 591     // FIXME: Figure out what this function is actually trying to add in different call sites.
<span class="line-modified"> 592     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified"> 593         if (Document* document = frame-&gt;document())</span>
<span class="line-modified"> 594             document-&gt;styleScope().didChangeStyleSheetEnvironment();</span>
<span class="line-removed"> 595     }</span>
 596 }
 597 
 598 void Page::refreshPlugins(bool reload)
 599 {
 600     HashSet&lt;PluginInfoProvider*&gt; pluginInfoProviders;
 601 
 602     for (auto* page : allPages())
 603         pluginInfoProviders.add(&amp;page-&gt;pluginInfoProvider());
 604 
 605     for (auto&amp; pluginInfoProvider : pluginInfoProviders)
 606         pluginInfoProvider-&gt;refresh(reload);
 607 }
 608 
 609 PluginData&amp; Page::pluginData()
 610 {
 611     if (!m_pluginData)
 612         m_pluginData = PluginData::create(*this);
 613     return *m_pluginData;
 614 }
 615 
</pre>
<hr />
<pre>
 894     }
 895 
 896     replaceRanges(*this, replacementRanges, replacementText);
 897     return rangesToReplace.size();
 898 }
 899 
 900 uint32_t Page::replaceSelectionWithText(const String&amp; replacementText)
 901 {
 902     auto frame = makeRef(focusController().focusedOrMainFrame());
 903     auto selection = frame-&gt;selection().selection();
 904     if (!selection.isContentEditable())
 905         return 0;
 906 
 907     auto editAction = selection.isRange() ? EditAction::InsertReplacement : EditAction::Insert;
 908     frame-&gt;editor().replaceSelectionWithText(replacementText, Editor::SelectReplacement::Yes, Editor::SmartReplace::No, editAction);
 909     return 1;
 910 }
 911 
 912 void Page::unmarkAllTextMatches()
 913 {
<span class="line-modified"> 914     Frame* frame = &amp;mainFrame();</span>
<span class="line-modified"> 915     do {</span>
<span class="line-modified"> 916         frame-&gt;document()-&gt;markers().removeMarkers(DocumentMarker::TextMatch);</span>
<span class="line-modified"> 917         frame = incrementFrame(frame, true, CanWrap::No);</span>
<span class="line-modified"> 918     } while (frame);</span>

































 919 }
 920 
 921 const VisibleSelection&amp; Page::selection() const
 922 {
 923     return focusController().focusedOrMainFrame().selection().selection();
 924 }
 925 
 926 void Page::setDefersLoading(bool defers)
 927 {
 928     if (!m_settings-&gt;loadDeferringEnabled())
 929         return;
 930 
 931     if (m_settings-&gt;wantsBalancedSetDefersLoadingBehavior()) {
 932         ASSERT(defers || m_defersLoadingCallCount);
 933         if (defers &amp;&amp; ++m_defersLoadingCallCount &gt; 1)
 934             return;
 935         if (!defers &amp;&amp; --m_defersLoadingCallCount)
 936             return;
 937     } else {
 938         ASSERT(!m_defersLoadingCallCount);
</pre>
<hr />
<pre>
 952 
 953 bool Page::inLowQualityImageInterpolationMode() const
 954 {
 955     return m_inLowQualityInterpolationMode;
 956 }
 957 
 958 void Page::setInLowQualityImageInterpolationMode(bool mode)
 959 {
 960     m_inLowQualityInterpolationMode = mode;
 961 }
 962 
 963 DiagnosticLoggingClient&amp; Page::diagnosticLoggingClient() const
 964 {
 965     if (!settings().diagnosticLoggingEnabled() || !m_diagnosticLoggingClient)
 966         return emptyDiagnosticLoggingClient();
 967     return *m_diagnosticLoggingClient;
 968 }
 969 
 970 void Page::setMediaVolume(float volume)
 971 {
<span class="line-modified"> 972     if (volume &lt; 0 || volume &gt; 1)</span>
 973         return;
 974 
 975     if (m_mediaVolume == volume)
 976         return;
 977 
 978     m_mediaVolume = volume;
<span class="line-modified"> 979     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified"> 980         if (!frame-&gt;document())</span>
<span class="line-modified"> 981             continue;</span>
<span class="line-modified"> 982         frame-&gt;document()-&gt;mediaVolumeDidChange();</span>
<span class="line-modified"> 983     }</span>

 984 }
 985 
 986 void Page::setZoomedOutPageScaleFactor(float scale)
 987 {
 988     if (m_zoomedOutPageScaleFactor == scale)
 989         return;
 990     m_zoomedOutPageScaleFactor = scale;
 991 
 992     mainFrame().deviceOrPageScaleFactorChanged();
 993 }
 994 
 995 void Page::setPageScaleFactor(float scale, const IntPoint&amp; origin, bool inStableState)
 996 {
 997     LOG(Viewports, &quot;Page::setPageScaleFactor %.2f - inStableState %d&quot;, scale, inStableState);
 998 
 999     Document* document = mainFrame().document();
<span class="line-modified">1000     FrameView* view = document-&gt;view();</span>
1001 
1002     if (scale == m_pageScaleFactor) {
<span class="line-modified">1003         if (view &amp;&amp; view-&gt;scrollPosition() != origin) {</span>
<span class="line-modified">1004             if (!m_settings-&gt;delegatesPageScaling())</span>
<span class="line-modified">1005                 document-&gt;updateLayoutIgnorePendingStylesheets();</span>
<span class="line-modified">1006 </span>
<span class="line-removed">1007             if (!view-&gt;delegatesScrolling())</span>
<span class="line-removed">1008                 view-&gt;setScrollPosition(origin);</span>
<span class="line-removed">1009 #if USE(COORDINATED_GRAPHICS)</span>
<span class="line-removed">1010             else</span>
<span class="line-removed">1011                 view-&gt;requestScrollPositionUpdate(origin);</span>
<span class="line-removed">1012 #endif</span>
<span class="line-removed">1013         }</span>
<span class="line-removed">1014 #if ENABLE(MEDIA_CONTROLS_SCRIPT)</span>
<span class="line-removed">1015         if (inStableState) {</span>
<span class="line-removed">1016             for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-removed">1017                 if (!frame-&gt;document())</span>
<span class="line-removed">1018                     continue;</span>
<span class="line-removed">1019                 frame-&gt;document()-&gt;pageScaleFactorChangedAndStable();</span>
<span class="line-removed">1020             }</span>
<span class="line-removed">1021         }</span>
<span class="line-removed">1022 #endif</span>
<span class="line-removed">1023         return;</span>
<span class="line-removed">1024     }</span>
<span class="line-removed">1025 </span>
<span class="line-removed">1026     m_pageScaleFactor = scale;</span>
1027 
<span class="line-modified">1028     if (!m_settings-&gt;delegatesPageScaling()) {</span>
<span class="line-modified">1029         view-&gt;setNeedsLayoutAfterViewConfigurationChange();</span>
<span class="line-modified">1030         view-&gt;setNeedsCompositingGeometryUpdate();</span>
1031 
<span class="line-modified">1032         document-&gt;resolveStyle(Document::ResolveStyleType::Rebuild);</span>
1033 
<span class="line-modified">1034         // Transform change on RenderView doesn&#39;t trigger repaint on non-composited contents.</span>
<span class="line-modified">1035         mainFrame().view()-&gt;invalidateRect(IntRect(LayoutRect::infiniteRect()));</span>
<span class="line-modified">1036     }</span>
1037 
<span class="line-modified">1038     mainFrame().deviceOrPageScaleFactorChanged();</span>
1039 
<span class="line-modified">1040     if (view &amp;&amp; view-&gt;fixedElementsLayoutRelativeToFrame())</span>
<span class="line-modified">1041         view-&gt;setViewportConstrainedObjectsNeedLayout();</span>
1042 
<span class="line-modified">1043     if (view &amp;&amp; view-&gt;scrollPosition() != origin) {</span>
<span class="line-removed">1044         if (!m_settings-&gt;delegatesPageScaling() &amp;&amp; document-&gt;renderView() &amp;&amp; document-&gt;renderView()-&gt;needsLayout() &amp;&amp; view-&gt;didFirstLayout())</span>
1045             view-&gt;layoutContext().layout();

1046 

1047         if (!view-&gt;delegatesScrolling())
1048             view-&gt;setScrollPosition(origin);
1049 #if USE(COORDINATED_GRAPHICS)
1050         else
1051             view-&gt;requestScrollPositionUpdate(origin);
1052 #endif
1053     }
1054 
1055 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1056     if (inStableState) {
<span class="line-modified">1057         for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1058             if (!frame-&gt;document())</span>
<span class="line-modified">1059                 continue;</span>
<span class="line-removed">1060             frame-&gt;document()-&gt;pageScaleFactorChangedAndStable();</span>
<span class="line-removed">1061         }</span>
1062     }
1063 #else
1064     UNUSED_PARAM(inStableState);
1065 #endif
1066 }
1067 





1068 void Page::setViewScaleFactor(float scale)
1069 {
1070     if (m_viewScaleFactor == scale)
1071         return;
1072 
1073     m_viewScaleFactor = scale;
<span class="line-modified">1074     PageCache::singleton().markPagesForDeviceOrPageScaleChanged(*this);</span>
1075 }
1076 
1077 void Page::setDeviceScaleFactor(float scaleFactor)
1078 {
1079     ASSERT(scaleFactor &gt; 0);
1080     if (scaleFactor &lt;= 0)
1081         return;
1082 
1083     if (m_deviceScaleFactor == scaleFactor)
1084         return;
1085 
1086     m_deviceScaleFactor = scaleFactor;
1087     setNeedsRecalcStyleInAllFrames();
1088 
1089     mainFrame().deviceOrPageScaleFactorChanged();
<span class="line-modified">1090     PageCache::singleton().markPagesForDeviceOrPageScaleChanged(*this);</span>
1091 
1092     pageOverlayController().didChangeDeviceScaleFactor();
1093 }
1094 
1095 void Page::setInitialScale(float initialScale)
1096 {
1097     m_initialScale = initialScale;
1098 }
1099 
1100 void Page::setUserInterfaceLayoutDirection(UserInterfaceLayoutDirection userInterfaceLayoutDirection)
1101 {
1102     if (m_userInterfaceLayoutDirection == userInterfaceLayoutDirection)
1103         return;
1104 
1105     m_userInterfaceLayoutDirection = userInterfaceLayoutDirection;

1106 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
<span class="line-modified">1107     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1108         if (!frame-&gt;document())</span>
<span class="line-modified">1109             continue;</span>
<span class="line-removed">1110         frame-&gt;document()-&gt;userInterfaceLayoutDirectionChanged();</span>
<span class="line-removed">1111     }</span>
1112 #endif
1113 }
1114 
1115 #if ENABLE(VIDEO)

1116 void Page::updateMediaElementRateChangeRestrictions()
1117 {
<span class="line-modified">1118     for (auto* mediaElement : HTMLMediaElement::allMediaElements())</span>
<span class="line-modified">1119         mediaElement-&gt;updateRateChangeRestrictions();</span>


1120 }

1121 #endif
1122 
1123 void Page::didStartProvisionalLoad()
1124 {
1125     if (m_performanceMonitor)
1126         m_performanceMonitor-&gt;didStartProvisionalLoad();
1127 }
1128 
1129 void Page::didFinishLoad()
1130 {
1131     resetRelevantPaintedObjectCounter();
1132 
1133     if (m_performanceMonitor)
1134         m_performanceMonitor-&gt;didFinishLoad();
1135 }
1136 
1137 bool Page::isOnlyNonUtilityPage() const
1138 {
1139     return !isUtilityPage() &amp;&amp; nonUtilityPageCount == 1;
1140 }
</pre>
<hr />
<pre>
1264     if (isInWindow)
1265         resumeAnimatingImages();
1266 }
1267 
1268 void Page::addActivityStateChangeObserver(ActivityStateChangeObserver&amp; observer)
1269 {
1270     m_activityStateChangeObservers.add(&amp;observer);
1271 }
1272 
1273 void Page::removeActivityStateChangeObserver(ActivityStateChangeObserver&amp; observer)
1274 {
1275     m_activityStateChangeObservers.remove(&amp;observer);
1276 }
1277 
1278 void Page::layoutIfNeeded()
1279 {
1280     if (FrameView* view = m_mainFrame-&gt;view())
1281         view-&gt;updateLayoutAndStyleIfNeededRecursive();
1282 }
1283 

1284 void Page::updateRendering()
1285 {
1286     // This function is not reentrant, e.g. a rAF callback may force repaint.
1287     if (m_inUpdateRendering) {
1288         layoutIfNeeded();
1289         return;
1290     }
1291 
1292     TraceScope traceScope(RenderingUpdateStart, RenderingUpdateEnd);
1293 
1294     SetForScope&lt;bool&gt; change(m_inUpdateRendering, true);
1295 
<span class="line-modified">1296     Vector&lt;RefPtr&lt;Document&gt;&gt; documents;</span>


1297 
<span class="line-modified">1298     // The requestAnimationFrame callbacks may change the frame hierarchy of the page</span>
<span class="line-modified">1299     forEachDocument([&amp;documents] (Document&amp; document) {</span>
<span class="line-removed">1300         documents.append(&amp;document);</span>
1301     });
1302 
<span class="line-modified">1303     for (auto&amp; document : documents) {</span>
<span class="line-modified">1304         DOMHighResTimeStamp timestamp = document-&gt;domWindow()-&gt;nowTimestamp();</span>
<span class="line-modified">1305         document-&gt;updateAnimationsAndSendEvents(timestamp);</span>
<span class="line-modified">1306         document-&gt;serviceRequestAnimationFrameCallbacks(timestamp);</span>
<span class="line-modified">1307     }</span>











1308 
1309     layoutIfNeeded();
1310 
1311 #if ENABLE(INTERSECTION_OBSERVER)
<span class="line-modified">1312     for (auto&amp; document : documents)</span>
<span class="line-modified">1313         document-&gt;updateIntersectionObservations();</span>

1314 #endif

1315 #if ENABLE(RESIZE_OBSERVER)
<span class="line-modified">1316     for (auto&amp; document : documents)</span>
<span class="line-modified">1317         document-&gt;updateResizeObservations(*this);</span>

1318 #endif
1319 
1320     layoutIfNeeded();




1321 }
1322 
1323 void Page::suspendScriptedAnimations()
1324 {
1325     m_scriptedAnimationsSuspended = true;
<span class="line-modified">1326     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1327         if (frame-&gt;document())</span>
<span class="line-modified">1328             frame-&gt;document()-&gt;suspendScriptedAnimationControllerCallbacks();</span>
<span class="line-modified">1329     }</span>
1330 }
1331 
1332 void Page::resumeScriptedAnimations()
1333 {
1334     m_scriptedAnimationsSuspended = false;
<span class="line-modified">1335     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1336         if (frame-&gt;document())</span>
<span class="line-modified">1337             frame-&gt;document()-&gt;resumeScriptedAnimationControllerCallbacks();</span>
<span class="line-modified">1338     }</span>
1339 }
1340 
1341 enum class ThrottlingReasonOperation { Add, Remove };
1342 static void updateScriptedAnimationsThrottlingReason(Page&amp; page, ThrottlingReasonOperation operation, ScriptedAnimationController::ThrottlingReason reason)
1343 {
<span class="line-modified">1344     for (Frame* frame = &amp;page.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1345         auto* document = frame-&gt;document();</span>
<span class="line-modified">1346         if (!document)</span>
<span class="line-modified">1347             continue;</span>
<span class="line-modified">1348         auto* scriptedAnimationController = document-&gt;scriptedAnimationController();</span>
<span class="line-modified">1349         if (!scriptedAnimationController)</span>
<span class="line-modified">1350             continue;</span>
<span class="line-modified">1351 </span>
<span class="line-removed">1352         if (operation == ThrottlingReasonOperation::Add)</span>
<span class="line-removed">1353             scriptedAnimationController-&gt;addThrottlingReason(reason);</span>
<span class="line-removed">1354         else</span>
<span class="line-removed">1355             scriptedAnimationController-&gt;removeThrottlingReason(reason);</span>
<span class="line-removed">1356     }</span>
1357 }
1358 
1359 void Page::setIsVisuallyIdleInternal(bool isVisuallyIdle)
1360 {
1361     updateScriptedAnimationsThrottlingReason(*this, isVisuallyIdle ? ThrottlingReasonOperation::Add : ThrottlingReasonOperation::Remove, ScriptedAnimationController::ThrottlingReason::VisuallyIdle);
1362 }
1363 
1364 void Page::handleLowModePowerChange(bool isLowPowerModeEnabled)
1365 {
1366     updateScriptedAnimationsThrottlingReason(*this, isLowPowerModeEnabled ? ThrottlingReasonOperation::Add : ThrottlingReasonOperation::Remove, ScriptedAnimationController::ThrottlingReason::LowPowerMode);
1367     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
<span class="line-modified">1368         forEachDocument([&amp;] (Document&amp; document) {</span>
1369             if (auto timeline = document.existingTimeline())
1370                 timeline-&gt;updateThrottlingState();
1371         });
1372     } else
1373         mainFrame().animation().updateThrottlingState();
1374     updateDOMTimerAlignmentInterval();
1375 }
1376 
1377 void Page::userStyleSheetLocationChanged()
1378 {
1379     // FIXME: Eventually we will move to a model of just being handed the sheet
1380     // text instead of loading the URL ourselves.
1381     URL url = m_settings-&gt;userStyleSheetLocation();
1382 
1383     // Allow any local file URL scheme to be loaded.
<span class="line-modified">1384     if (SchemeRegistry::shouldTreatURLSchemeAsLocal(url.protocol().toStringWithoutCopying()))</span>
1385         m_userStyleSheetPath = url.fileSystemPath();
1386     else
1387         m_userStyleSheetPath = String();
1388 
1389     m_didLoadUserStyleSheet = false;
1390     m_userStyleSheet = String();
1391     m_userStyleSheetModificationTime = WTF::nullopt;
1392 
1393     // Data URLs with base64-encoded UTF-8 style sheets are common. We can process them
1394     // synchronously and avoid using a loader.
1395     if (url.protocolIsData() &amp;&amp; url.string().startsWith(&quot;data:text/css;charset=utf-8;base64,&quot;)) {
1396         m_didLoadUserStyleSheet = true;
1397 
1398         Vector&lt;char&gt; styleSheetAsUTF8;
1399         if (base64Decode(decodeURLEscapeSequences(url.string().substring(35)), styleSheetAsUTF8, Base64IgnoreSpacesAndNewLines))
1400             m_userStyleSheet = String::fromUTF8(styleSheetAsUTF8.data(), styleSheetAsUTF8.size());
1401     }
1402 
<span class="line-modified">1403     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1404         if (frame-&gt;document())</span>
<span class="line-modified">1405             frame-&gt;document()-&gt;extensionStyleSheets().updatePageUserSheet();</span>
<span class="line-removed">1406     }</span>
1407 }
1408 
1409 const String&amp; Page::userStyleSheet() const
1410 {
1411     if (m_userStyleSheetPath.isEmpty())
1412         return m_userStyleSheet;
1413 
1414     auto modificationTime = FileSystem::getFileModificationTime(m_userStyleSheetPath);
1415     if (!modificationTime) {
1416         // The stylesheet either doesn&#39;t exist, was just deleted, or is
1417         // otherwise unreadable. If we&#39;ve read the stylesheet before, we should
1418         // throw away that data now as it no longer represents what&#39;s on disk.
1419         m_userStyleSheet = String();
1420         return m_userStyleSheet;
1421     }
1422 
1423     // If the stylesheet hasn&#39;t changed since the last time we read it, we can
1424     // just return the old data.
1425     if (m_didLoadUserStyleSheet &amp;&amp; (m_userStyleSheetModificationTime &amp;&amp; modificationTime.value() &lt;= m_userStyleSheetModificationTime.value()))
1426         return m_userStyleSheet;
</pre>
<hr />
<pre>
1441         return m_userStyleSheet;
1442 
1443     m_userStyleSheet = TextResourceDecoder::create(&quot;text/css&quot;)-&gt;decodeAndFlush(data-&gt;data(), data-&gt;size());
1444 
1445     return m_userStyleSheet;
1446 }
1447 
1448 void Page::userAgentChanged()
1449 {
1450     for (auto* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext()) {
1451         auto* window = frame-&gt;window();
1452         if (!window)
1453             continue;
1454         if (auto* navigator = window-&gt;optionalNavigator())
1455             navigator-&gt;userAgentChanged();
1456     }
1457 }
1458 
1459 void Page::invalidateStylesForAllLinks()
1460 {
<span class="line-modified">1461     for (Frame* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1462         if (!frame-&gt;document())</span>
<span class="line-modified">1463             continue;</span>
<span class="line-removed">1464         frame-&gt;document()-&gt;visitedLinkState().invalidateStyleForAllLinks();</span>
<span class="line-removed">1465     }</span>
1466 }
1467 
1468 void Page::invalidateStylesForLink(SharedStringHash linkHash)
1469 {
<span class="line-modified">1470     for (Frame* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1471         if (!frame-&gt;document())</span>
<span class="line-modified">1472             continue;</span>
<span class="line-removed">1473         frame-&gt;document()-&gt;visitedLinkState().invalidateStyleForLink(linkHash);</span>
<span class="line-removed">1474     }</span>
1475 }
1476 
1477 void Page::invalidateInjectedStyleSheetCacheInAllFrames()
1478 {
<span class="line-modified">1479     for (Frame* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1480         Document* document = frame-&gt;document();</span>
<span class="line-modified">1481         if (!document)</span>
<span class="line-removed">1482             continue;</span>
<span class="line-removed">1483         document-&gt;extensionStyleSheets().invalidateInjectedStyleSheetCache();</span>
<span class="line-removed">1484     }</span>
1485 }
1486 
1487 void Page::setDebugger(JSC::Debugger* debugger)
1488 {
1489     if (m_debugger == debugger)
1490         return;
1491 
1492     m_debugger = debugger;
1493 
1494     for (Frame* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext())
1495         frame-&gt;windowProxy().attachDebugger(m_debugger);
1496 }
1497 
1498 StorageNamespace* Page::sessionStorage(bool optionalCreate)
1499 {
1500     if (!m_sessionStorage &amp;&amp; optionalCreate)
1501         m_sessionStorage = m_storageNamespaceProvider-&gt;createSessionStorageNamespace(*this, m_settings-&gt;sessionStorageQuota());
1502 
1503     return m_sessionStorage.get();
1504 }
</pre>
<hr />
<pre>
1554         setTimerThrottlingState(TimerThrottlingState::Enabled);
1555         return;
1556     }
1557 
1558     // If we get here increasing timer throttling is enabled.
1559     setTimerThrottlingState(TimerThrottlingState::EnabledIncreasing);
1560 }
1561 
1562 void Page::setTimerThrottlingState(TimerThrottlingState state)
1563 {
1564     if (state == m_timerThrottlingState)
1565         return;
1566 
1567     m_timerThrottlingState = state;
1568     m_timerThrottlingStateLastChangedTime = MonotonicTime::now();
1569 
1570     updateDOMTimerAlignmentInterval();
1571 
1572     // When throttling is disabled, release all throttled timers.
1573     if (state == TimerThrottlingState::Disabled) {
<span class="line-modified">1574         for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1575             if (auto* document = frame-&gt;document())</span>
<span class="line-modified">1576                 document-&gt;didChangeTimerAlignmentInterval();</span>
<span class="line-removed">1577         }</span>
1578     }
1579 }
1580 
1581 void Page::setDOMTimerAlignmentIntervalIncreaseLimit(Seconds limit)
1582 {
1583     m_domTimerAlignmentIntervalIncreaseLimit = limit;
1584 
1585     // If (m_domTimerAlignmentIntervalIncreaseLimit &lt; m_domTimerAlignmentInterval) then we need
1586     // to update m_domTimerAlignmentInterval, if greater then need to restart the increase timer.
1587     if (m_timerThrottlingState == TimerThrottlingState::EnabledIncreasing)
1588         updateDOMTimerAlignmentInterval();
1589 }
1590 
1591 void Page::updateDOMTimerAlignmentInterval()
1592 {
1593     bool needsIncreaseTimer = false;
1594 
1595     switch (m_timerThrottlingState) {
1596     case TimerThrottlingState::Disabled:
1597         m_domTimerAlignmentInterval = isLowPowerModeEnabled() ? DOMTimer::defaultAlignmentIntervalInLowPowerMode() : DOMTimer::defaultAlignmentInterval();
</pre>
<hr />
<pre>
1623     // between increases is equal to the current throttle time. Since alinment interval increases
1624     // exponentially, time between steps is exponential too.
1625     if (!needsIncreaseTimer)
1626         m_domTimerAlignmentIntervalIncreaseTimer.stop();
1627     else if (!m_domTimerAlignmentIntervalIncreaseTimer.isActive())
1628         m_domTimerAlignmentIntervalIncreaseTimer.startOneShot(m_domTimerAlignmentInterval);
1629 }
1630 
1631 void Page::domTimerAlignmentIntervalIncreaseTimerFired()
1632 {
1633     ASSERT(m_settings-&gt;hiddenPageDOMTimerThrottlingAutoIncreases());
1634     ASSERT(m_timerThrottlingState == TimerThrottlingState::EnabledIncreasing);
1635     ASSERT(m_domTimerAlignmentInterval &lt; m_domTimerAlignmentIntervalIncreaseLimit);
1636 
1637     // Alignment interval is increased to equal the time the page has been throttled, to a limit.
1638     updateDOMTimerAlignmentInterval();
1639 }
1640 
1641 void Page::dnsPrefetchingStateChanged()
1642 {
<span class="line-modified">1643     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1644         if (!frame-&gt;document())</span>
<span class="line-modified">1645             continue;</span>
<span class="line-removed">1646         frame-&gt;document()-&gt;initDNSPrefetch();</span>
<span class="line-removed">1647     }</span>
1648 }
1649 
1650 Vector&lt;Ref&lt;PluginViewBase&gt;&gt; Page::pluginViews()
1651 {
1652     Vector&lt;Ref&lt;PluginViewBase&gt;&gt; views;
1653     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1654         auto* view = frame-&gt;view();
1655         if (!view)
1656             break;
1657         for (auto&amp; widget : view-&gt;children()) {
1658             if (is&lt;PluginViewBase&gt;(widget))
1659                 views.append(downcast&lt;PluginViewBase&gt;(widget.get()));
1660         }
1661     }
1662     return views;
1663 }
1664 
1665 void Page::storageBlockingStateChanged()
1666 {
<span class="line-modified">1667     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1668         if (!frame-&gt;document())</span>
<span class="line-modified">1669             continue;</span>
<span class="line-removed">1670         frame-&gt;document()-&gt;storageBlockingStateDidChange();</span>
<span class="line-removed">1671     }</span>
1672 
1673     // Collect the PluginViews in to a vector to ensure that action the plug-in takes
1674     // from below storageBlockingStateChanged does not affect their lifetime.
1675     for (auto&amp; view : pluginViews())
1676         view-&gt;storageBlockingStateChanged();
1677 }
1678 
<span class="line-removed">1679 void Page::enableLegacyPrivateBrowsing(bool privateBrowsingEnabled)</span>
<span class="line-removed">1680 {</span>
<span class="line-removed">1681     // Don&#39;t allow changing the legacy private browsing state if we have set a session ID.</span>
<span class="line-removed">1682     ASSERT(m_sessionID == PAL::SessionID::defaultSessionID() || m_sessionID == PAL::SessionID::legacyPrivateSessionID());</span>
<span class="line-removed">1683 </span>
<span class="line-removed">1684     setSessionID(privateBrowsingEnabled ? PAL::SessionID::legacyPrivateSessionID() : PAL::SessionID::defaultSessionID());</span>
<span class="line-removed">1685 }</span>
<span class="line-removed">1686 </span>
1687 void Page::updateIsPlayingMedia(uint64_t sourceElementID)
1688 {
1689     MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
<span class="line-modified">1690     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1691         if (Document* document = frame-&gt;document())</span>
<span class="line-modified">1692             state |= document-&gt;mediaState();</span>
<span class="line-removed">1693     }</span>
1694 
1695     if (state == m_mediaState)
1696         return;
1697 
1698     m_mediaState = state;
1699 
1700     chrome().client().isPlayingMediaDidChange(state, sourceElementID);
1701 }
1702 
1703 void Page::schedulePlaybackControlsManagerUpdate()
1704 {
1705 #if ENABLE(VIDEO)
1706     if (!m_playbackControlsManagerUpdateTimer.isActive())
1707         m_playbackControlsManagerUpdateTimer.startOneShot(0_s);
1708 #endif
1709 }
1710 
1711 #if ENABLE(VIDEO)

1712 void Page::playbackControlsManagerUpdateTimerFired()
1713 {
1714     if (auto bestMediaElement = HTMLMediaElement::bestMediaElementForShowingPlaybackControlsManager(MediaElementSession::PlaybackControlsPurpose::ControlsManager))
1715         chrome().client().setUpPlaybackControlsManager(*bestMediaElement);
1716     else
1717         chrome().client().clearPlaybackControlsManager();
1718 }

1719 #endif
1720 
1721 void Page::setMuted(MediaProducer::MutedStateFlags muted)
1722 {
1723     if (m_mutedState == muted)
1724         return;
1725 
1726     m_mutedState = muted;
1727 
<span class="line-modified">1728     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1729         if (!frame-&gt;document())</span>
<span class="line-modified">1730             continue;</span>
<span class="line-removed">1731         frame-&gt;document()-&gt;pageMutedStateDidChange();</span>
<span class="line-removed">1732     }</span>
1733 }
1734 
1735 void Page::stopMediaCapture()
1736 {
1737 #if ENABLE(MEDIA_STREAM)
<span class="line-modified">1738     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1739         if (!frame-&gt;document())</span>
<span class="line-modified">1740             continue;</span>
<span class="line-removed">1741 </span>
<span class="line-removed">1742         frame-&gt;document()-&gt;stopMediaCapture();</span>
<span class="line-removed">1743     }</span>
1744 #endif
1745 }
1746 
1747 void Page::stopAllMediaPlayback()
1748 {
1749 #if ENABLE(VIDEO)
<span class="line-modified">1750     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1751         if (auto* document = frame-&gt;document())</span>
<span class="line-modified">1752             document-&gt;stopAllMediaPlayback();</span>
<span class="line-removed">1753     }</span>
1754 #endif
1755 }
1756 
1757 void Page::suspendAllMediaPlayback()
1758 {
1759 #if ENABLE(VIDEO)
1760     ASSERT(!m_mediaPlaybackIsSuspended);
1761     if (m_mediaPlaybackIsSuspended)
1762         return;
1763 
<span class="line-modified">1764     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1765         if (auto* document = frame-&gt;document())</span>
<span class="line-modified">1766             document-&gt;suspendAllMediaPlayback();</span>
<span class="line-removed">1767     }</span>
1768 
1769     m_mediaPlaybackIsSuspended = true;
1770 #endif
1771 }
1772 
1773 void Page::resumeAllMediaPlayback()
1774 {
1775 #if ENABLE(VIDEO)
1776     ASSERT(m_mediaPlaybackIsSuspended);
1777     if (!m_mediaPlaybackIsSuspended)
1778         return;
1779     m_mediaPlaybackIsSuspended = false;
1780 
<span class="line-modified">1781     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1782         if (auto* document = frame-&gt;document())</span>
<span class="line-modified">1783             document-&gt;resumeAllMediaPlayback();</span>
<span class="line-removed">1784     }</span>
1785 #endif
1786 }
1787 
1788 void Page::suspendAllMediaBuffering()
1789 {
1790 #if ENABLE(VIDEO)
1791     ASSERT(!m_mediaBufferingIsSuspended);
1792     if (m_mediaBufferingIsSuspended)
1793         return;
1794     m_mediaBufferingIsSuspended = true;
1795 
<span class="line-modified">1796     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1797         if (auto* document = frame-&gt;document())</span>
<span class="line-modified">1798             document-&gt;suspendAllMediaBuffering();</span>
<span class="line-removed">1799     }</span>
1800 #endif
1801 }
1802 
1803 void Page::resumeAllMediaBuffering()
1804 {
1805 #if ENABLE(VIDEO)
1806     if (!m_mediaBufferingIsSuspended)
1807         return;
1808     m_mediaBufferingIsSuspended = false;
1809 
<span class="line-modified">1810     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">1811         if (auto* document = frame-&gt;document())</span>
<span class="line-modified">1812             document-&gt;resumeAllMediaBuffering();</span>
<span class="line-removed">1813     }</span>
1814 #endif
1815 }
1816 
1817 #if ENABLE(MEDIA_SESSION)

1818 void Page::handleMediaEvent(MediaEventType eventType)
1819 {
1820     switch (eventType) {
1821     case MediaEventType::PlayPause:
1822         MediaSessionManager::singleton().togglePlayback();
1823         break;
1824     case MediaEventType::TrackNext:
1825         MediaSessionManager::singleton().skipToNextTrack();
1826         break;
1827     case MediaEventType::TrackPrevious:
1828         MediaSessionManager::singleton().skipToPreviousTrack();
1829         break;
1830     }
1831 }
1832 
1833 void Page::setVolumeOfMediaElement(double volume, uint64_t elementID)
1834 {
1835     if (HTMLMediaElement* element = HTMLMediaElement::elementWithID(elementID))
1836         element-&gt;setVolume(volume, ASSERT_NO_EXCEPTION);
1837 }

1838 #endif
1839 
<span class="line-modified">1840 #if !ASSERT_DISABLED</span>

1841 void Page::checkSubframeCountConsistency() const
1842 {
1843     ASSERT(m_subframeCount &gt;= 0);
1844 
1845     int subframeCount = 0;
1846     for (const Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
1847         ++subframeCount;
1848 
1849     ASSERT(m_subframeCount + 1 == subframeCount);
1850 }
<span class="line-modified">1851 #endif</span>

1852 
1853 void Page::resumeAnimatingImages()
1854 {
1855     // Drawing models which cache painted content while out-of-window (WebKit2&#39;s composited drawing areas, etc.)
1856     // require that we repaint animated images to kickstart the animation loop.
1857     if (FrameView* view = mainFrame().view())
1858         view-&gt;resumeVisibleImageAnimationsIncludingSubframes();
1859 }
1860 
1861 void Page::setActivityState(OptionSet&lt;ActivityState::Flag&gt; activityState)
1862 {
1863     auto changed = m_activityState ^ activityState;
1864     if (!changed)
1865         return;
1866 
1867     auto oldActivityState = m_activityState;
1868 
1869     bool wasVisibleAndActive = isVisibleAndActive();
1870     m_activityState = activityState;
1871 
</pre>
<hr />
<pre>
1902 
1903 bool Page::isWindowActive() const
1904 {
1905     return m_activityState.contains(ActivityState::WindowIsActive);
1906 }
1907 
1908 void Page::setIsVisible(bool isVisible)
1909 {
1910     auto state = m_activityState;
1911 
1912     if (isVisible) {
1913         state.remove(ActivityState::IsVisuallyIdle);
1914         state.add({ ActivityState::IsVisible, ActivityState::IsVisibleOrOccluded });
1915     } else {
1916         state.add(ActivityState::IsVisuallyIdle);
1917         state.remove({ ActivityState::IsVisible, ActivityState::IsVisibleOrOccluded });
1918     }
1919     setActivityState(state);
1920 }
1921 
<span class="line-removed">1922 enum class SVGAnimationsState { Paused, Resumed };</span>
<span class="line-removed">1923 static inline void setSVGAnimationsState(Page&amp; page, SVGAnimationsState state)</span>
<span class="line-removed">1924 {</span>
<span class="line-removed">1925     for (Frame* frame = &amp;page.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-removed">1926         auto* document = frame-&gt;document();</span>
<span class="line-removed">1927         if (!document)</span>
<span class="line-removed">1928             continue;</span>
<span class="line-removed">1929 </span>
<span class="line-removed">1930         if (!document-&gt;svgExtensions())</span>
<span class="line-removed">1931             continue;</span>
<span class="line-removed">1932 </span>
<span class="line-removed">1933         if (state == SVGAnimationsState::Paused)</span>
<span class="line-removed">1934             document-&gt;accessSVGExtensions().pauseAnimations();</span>
<span class="line-removed">1935         else</span>
<span class="line-removed">1936             document-&gt;accessSVGExtensions().unpauseAnimations();</span>
<span class="line-removed">1937     }</span>
<span class="line-removed">1938 }</span>
<span class="line-removed">1939 </span>
1940 void Page::setIsVisibleInternal(bool isVisible)
1941 {
1942     // FIXME: The visibility state should be stored on the top-level document.
1943     // https://bugs.webkit.org/show_bug.cgi?id=116769
1944 
1945     if (isVisible) {
1946         m_isPrerender = false;
1947 
1948         resumeScriptedAnimations();

1949 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">1950         resumeDeviceMotionAndOrientationUpdates();</span>


1951 #endif
1952 
1953         if (FrameView* view = mainFrame().view())
1954             view-&gt;show();
1955 
1956         if (m_settings-&gt;hiddenPageCSSAnimationSuspensionEnabled()) {
1957             if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
<span class="line-modified">1958                 forEachDocument([&amp;] (Document&amp; document) {</span>
1959                     if (auto* timeline = document.existingTimeline())
1960                         timeline-&gt;resumeAnimations();
1961                 });
1962             } else
1963                 mainFrame().animation().resumeAnimations();
1964         }
1965 
<span class="line-modified">1966         setSVGAnimationsState(*this, SVGAnimationsState::Resumed);</span>



1967 
1968         resumeAnimatingImages();
1969 
1970         if (m_navigationToLogWhenVisible) {
1971             logNavigation(m_navigationToLogWhenVisible.value());
1972             m_navigationToLogWhenVisible = WTF::nullopt;
1973         }
1974     }
1975 
1976     if (!isVisible) {
1977         if (m_settings-&gt;hiddenPageCSSAnimationSuspensionEnabled()) {
1978             if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
<span class="line-modified">1979                 forEachDocument([&amp;] (Document&amp; document) {</span>
1980                     if (auto* timeline = document.existingTimeline())
1981                         timeline-&gt;suspendAnimations();
1982                 });
1983             } else
1984                 mainFrame().animation().suspendAnimations();
1985         }
1986 
<span class="line-modified">1987         setSVGAnimationsState(*this, SVGAnimationsState::Paused);</span>



1988 
1989 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">1990         suspendDeviceMotionAndOrientationUpdates();</span>


1991 #endif
1992 
1993         suspendScriptedAnimations();
1994 
1995         if (FrameView* view = mainFrame().view())
1996             view-&gt;hide();
1997     }
1998 
<span class="line-modified">1999     Vector&lt;Ref&lt;Document&gt;&gt; documents;</span>
<span class="line-modified">2000     for (Frame* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext())</span>
<span class="line-modified">2001         documents.append(*frame-&gt;document());</span>
<span class="line-removed">2002 </span>
<span class="line-removed">2003     for (auto&amp; document : documents)</span>
<span class="line-removed">2004         document-&gt;visibilityStateChanged();</span>
2005 }
2006 
2007 void Page::setIsPrerender()
2008 {
2009     m_isPrerender = true;
2010     updateDOMTimerAlignmentInterval();
2011 }
2012 
2013 VisibilityState Page::visibilityState() const
2014 {
2015     if (isVisible())
2016         return VisibilityState::Visible;
2017     if (m_isPrerender)
2018         return VisibilityState::Prerender;
2019     return VisibilityState::Hidden;
2020 }
2021 
2022 void Page::setHeaderHeight(int headerHeight)
2023 {
2024     if (headerHeight == m_headerHeight)
</pre>
<hr />
<pre>
2075             if (insideNestedRunLoop())
2076                 return;
2077 
2078             // This callback may destruct the Page.
2079             if (m_unnestCallback) {
2080                 auto callback = WTFMove(m_unnestCallback);
2081                 callback();
2082             }
2083         });
2084     }
2085 }
2086 
2087 void Page::whenUnnested(WTF::Function&lt;void()&gt;&amp;&amp; callback)
2088 {
2089     ASSERT(!m_unnestCallback);
2090 
2091     m_unnestCallback = WTFMove(callback);
2092 }
2093 
2094 #if ENABLE(REMOTE_INSPECTOR)

2095 bool Page::remoteInspectionAllowed() const
2096 {
2097     return m_inspectorDebuggable-&gt;remoteDebuggingAllowed();
2098 }
2099 
2100 void Page::setRemoteInspectionAllowed(bool allowed)
2101 {
2102     m_inspectorDebuggable-&gt;setRemoteDebuggingAllowed(allowed);
2103 }
2104 
2105 String Page::remoteInspectionNameOverride() const
2106 {
2107     return m_inspectorDebuggable-&gt;nameOverride();
2108 }
2109 
2110 void Page::setRemoteInspectionNameOverride(const String&amp; name)
2111 {
2112     m_inspectorDebuggable-&gt;setNameOverride(name);
2113 }
2114 
2115 void Page::remoteInspectorInformationDidChange() const
2116 {
2117     m_inspectorDebuggable-&gt;update();
2118 }

2119 #endif
2120 
2121 void Page::addLayoutMilestones(OptionSet&lt;LayoutMilestone&gt; milestones)
2122 {
2123     // In the future, we may want a function that replaces m_layoutMilestones instead of just adding to it.
2124     m_requestedLayoutMilestones.add(milestones);
2125 }
2126 
2127 void Page::removeLayoutMilestones(OptionSet&lt;LayoutMilestone&gt; milestones)
2128 {
2129     m_requestedLayoutMilestones.remove(milestones);
2130 }
2131 
2132 Color Page::pageExtendedBackgroundColor() const
2133 {
2134     FrameView* frameView = mainFrame().view();
2135     if (!frameView)
2136         return Color();
2137 
2138     RenderView* renderView = frameView-&gt;renderView();
</pre>
<hr />
<pre>
2248         m_isCountingRelevantRepaintedObjects = false;
2249         resetRelevantPaintedObjectCounter();
2250         if (Frame* frame = &amp;mainFrame())
2251             frame-&gt;loader().didReachLayoutMilestone(DidHitRelevantRepaintedObjectsAreaThreshold);
2252     }
2253 }
2254 
2255 void Page::addRelevantUnpaintedObject(RenderObject* object, const LayoutRect&amp; objectPaintRect)
2256 {
2257     if (!isCountingRelevantRepaintedObjects())
2258         return;
2259 
2260     // The objects are only relevant if they are being painted within the relevantViewRect().
2261     if (!objectPaintRect.intersects(snappedIntRect(relevantViewRect(&amp;object-&gt;view()))))
2262         return;
2263 
2264     m_relevantUnpaintedRenderObjects.add(object);
2265     m_relevantUnpaintedRegion.unite(snappedIntRect(objectPaintRect));
2266 }
2267 
<span class="line-removed">2268 void Page::suspendDeviceMotionAndOrientationUpdates()</span>
<span class="line-removed">2269 {</span>
<span class="line-removed">2270     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-removed">2271         if (Document* document = frame-&gt;document())</span>
<span class="line-removed">2272             document-&gt;suspendDeviceMotionAndOrientationUpdates();</span>
<span class="line-removed">2273     }</span>
<span class="line-removed">2274 }</span>
<span class="line-removed">2275 </span>
<span class="line-removed">2276 void Page::resumeDeviceMotionAndOrientationUpdates()</span>
<span class="line-removed">2277 {</span>
<span class="line-removed">2278     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-removed">2279         if (Document* document = frame-&gt;document())</span>
<span class="line-removed">2280             document-&gt;resumeDeviceMotionAndOrientationUpdates();</span>
<span class="line-removed">2281     }</span>
<span class="line-removed">2282 }</span>
<span class="line-removed">2283 </span>
2284 void Page::suspendActiveDOMObjectsAndAnimations()
2285 {
2286     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
2287         frame-&gt;suspendActiveDOMObjectsAndAnimations();
2288 }
2289 
2290 void Page::resumeActiveDOMObjectsAndAnimations()
2291 {
2292     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
2293         frame-&gt;resumeActiveDOMObjectsAndAnimations();
2294 
2295     resumeAnimatingImages();
2296 }
2297 
2298 bool Page::hasSeenAnyPlugin() const
2299 {
2300     return !m_seenPlugins.isEmpty();
2301 }
2302 
2303 bool Page::hasSeenPlugin(const String&amp; serviceType) const
</pre>
<hr />
<pre>
2340     if (!isVisible()) {
2341         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
2342             forEachDocument([&amp;] (Document&amp; document) {
2343                 if (auto* timeline = document.existingTimeline()) {
2344                     if (m_settings-&gt;hiddenPageCSSAnimationSuspensionEnabled())
2345                         timeline-&gt;suspendAnimations();
2346                     else
2347                         timeline-&gt;resumeAnimations();
2348                 }
2349             });
2350         } else {
2351             if (m_settings-&gt;hiddenPageCSSAnimationSuspensionEnabled())
2352                 mainFrame().animation().suspendAnimations();
2353             else
2354                 mainFrame().animation().resumeAnimations();
2355         }
2356     }
2357 }
2358 
2359 #if ENABLE(VIDEO_TRACK)

2360 void Page::captionPreferencesChanged()
2361 {
<span class="line-modified">2362     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">2363         if (!frame-&gt;document())</span>
<span class="line-modified">2364             continue;</span>
<span class="line-removed">2365         frame-&gt;document()-&gt;captionPreferencesChanged();</span>
<span class="line-removed">2366     }</span>
2367 }

2368 #endif
2369 
2370 void Page::forbidPrompts()
2371 {
2372     ++m_forbidPromptsDepth;
2373 }
2374 
2375 void Page::allowPrompts()
2376 {
2377     ASSERT(m_forbidPromptsDepth);
2378     --m_forbidPromptsDepth;
2379 }
2380 
2381 bool Page::arePromptsAllowed()
2382 {
2383     return !m_forbidPromptsDepth;
2384 }
2385 
















2386 void Page::logNavigation(const Navigation&amp; navigation)
2387 {
2388     String navigationDescription;
2389     switch (navigation.type) {
2390     case FrameLoadType::Standard:
2391         navigationDescription = &quot;standard&quot;_s;
2392         break;
2393     case FrameLoadType::Back:
2394         navigationDescription = &quot;back&quot;_s;
2395         break;
2396     case FrameLoadType::Forward:
2397         navigationDescription = &quot;forward&quot;_s;
2398         break;
2399     case FrameLoadType::IndexedBackForward:
2400         navigationDescription = &quot;indexedBackForward&quot;_s;
2401         break;
2402     case FrameLoadType::Reload:
2403         navigationDescription = &quot;reload&quot;_s;
2404         break;
2405     case FrameLoadType::Same:
</pre>
<hr />
<pre>
2457 
2458 VisitedLinkStore&amp; Page::visitedLinkStore()
2459 {
2460     return m_visitedLinkStore;
2461 }
2462 
2463 void Page::setVisitedLinkStore(Ref&lt;VisitedLinkStore&gt;&amp;&amp; visitedLinkStore)
2464 {
2465     m_visitedLinkStore-&gt;removePage(*this);
2466     m_visitedLinkStore = WTFMove(visitedLinkStore);
2467     m_visitedLinkStore-&gt;addPage(*this);
2468 
2469     invalidateStylesForAllLinks();
2470 }
2471 
2472 PAL::SessionID Page::sessionID() const
2473 {
2474     return m_sessionID;
2475 }
2476 

2477 void Page::setSessionID(PAL::SessionID sessionID)
2478 {
2479     ASSERT(sessionID.isValid());


2480 
2481 #if ENABLE(INDEXED_DATABASE)
2482     if (sessionID != m_sessionID)
2483         m_idbConnectionToServer = nullptr;
2484 #endif
2485 
2486     if (sessionID != m_sessionID &amp;&amp; m_sessionStorage)
2487         m_sessionStorage-&gt;setSessionIDForTesting(sessionID);
2488 
2489     bool privateBrowsingStateChanged = (sessionID.isEphemeral() != m_sessionID.isEphemeral());
2490 
2491     m_sessionID = sessionID;
2492 
2493     if (!privateBrowsingStateChanged)
2494         return;
2495 
<span class="line-modified">2496     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">2497         if (!frame-&gt;document())</span>
<span class="line-modified">2498             continue;</span>
<span class="line-removed">2499         frame-&gt;document()-&gt;privateBrowsingStateDidChange(m_sessionID);</span>
<span class="line-removed">2500     }</span>
2501 
2502     // Collect the PluginViews in to a vector to ensure that action the plug-in takes
2503     // from below privateBrowsingStateChanged does not affect their lifetime.
2504 
2505     for (auto&amp; view : pluginViews())
2506         view-&gt;privateBrowsingStateChanged(sessionID.isEphemeral());
2507 }
2508 
2509 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2510 void Page::addPlaybackTargetPickerClient(uint64_t contextId)
2511 {
2512     chrome().client().addPlaybackTargetPickerClient(contextId);
2513 }
2514 
2515 void Page::removePlaybackTargetPickerClient(uint64_t contextId)
2516 {
2517     chrome().client().removePlaybackTargetPickerClient(contextId);
2518 }
2519 
2520 void Page::showPlaybackTargetPicker(uint64_t contextId, const WebCore::IntPoint&amp; location, bool isVideo, RouteSharingPolicy routeSharingPolicy, const String&amp; routingContextUID)
</pre>
<hr />
<pre>
2529     UNUSED_PARAM(routingContextUID);
2530     chrome().client().showPlaybackTargetPicker(contextId, location, isVideo);
2531 #endif
2532 }
2533 
2534 void Page::playbackTargetPickerClientStateDidChange(uint64_t contextId, MediaProducer::MediaStateFlags state)
2535 {
2536     chrome().client().playbackTargetPickerClientStateDidChange(contextId, state);
2537 }
2538 
2539 void Page::setMockMediaPlaybackTargetPickerEnabled(bool enabled)
2540 {
2541     chrome().client().setMockMediaPlaybackTargetPickerEnabled(enabled);
2542 }
2543 
2544 void Page::setMockMediaPlaybackTargetPickerState(const String&amp; name, MediaPlaybackTargetContext::State state)
2545 {
2546     chrome().client().setMockMediaPlaybackTargetPickerState(name, state);
2547 }
2548 





2549 void Page::setPlaybackTarget(uint64_t contextId, Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; target)
2550 {
<span class="line-modified">2551     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">2552         if (!frame-&gt;document())</span>
<span class="line-modified">2553             continue;</span>
<span class="line-removed">2554         frame-&gt;document()-&gt;setPlaybackTarget(contextId, target.copyRef());</span>
<span class="line-removed">2555     }</span>
2556 }
2557 
2558 void Page::playbackTargetAvailabilityDidChange(uint64_t contextId, bool available)
2559 {
<span class="line-modified">2560     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">2561         if (!frame-&gt;document())</span>
<span class="line-modified">2562             continue;</span>
<span class="line-removed">2563         frame-&gt;document()-&gt;playbackTargetAvailabilityDidChange(contextId, available);</span>
<span class="line-removed">2564     }</span>
2565 }
2566 
2567 void Page::setShouldPlayToPlaybackTarget(uint64_t clientId, bool shouldPlay)
2568 {
<span class="line-modified">2569     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">2570         if (!frame-&gt;document())</span>
<span class="line-modified">2571             continue;</span>
<span class="line-removed">2572         frame-&gt;document()-&gt;setShouldPlayToPlaybackTarget(clientId, shouldPlay);</span>
<span class="line-removed">2573     }</span>
2574 }








2575 #endif
2576 
<span class="line-modified">2577 WheelEventTestTrigger&amp; Page::ensureTestTrigger()</span>
2578 {
<span class="line-modified">2579     if (!m_testTrigger) {</span>
<span class="line-modified">2580         m_testTrigger = adoptRef(new WheelEventTestTrigger());</span>
2581         // We need to update the scrolling coordinator so that the mainframe scrolling node can expect wheel event test triggers.
2582         if (auto* frameView = mainFrame().view()) {
2583             if (m_scrollingCoordinator)
<span class="line-modified">2584                 m_scrollingCoordinator-&gt;updateExpectsWheelEventTestTriggerWithFrameView(*frameView);</span>
2585         }
2586     }
2587 
<span class="line-modified">2588     return *m_testTrigger;</span>
2589 }
2590 
2591 #if ENABLE(VIDEO)

2592 void Page::setAllowsMediaDocumentInlinePlayback(bool flag)
2593 {
2594     if (m_allowsMediaDocumentInlinePlayback == flag)
2595         return;
2596     m_allowsMediaDocumentInlinePlayback = flag;
2597 
<span class="line-modified">2598     Vector&lt;Ref&lt;Document&gt;&gt; documents;</span>
<span class="line-modified">2599     for (Frame* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext())</span>
<span class="line-modified">2600         documents.append(*frame-&gt;document());</span>
<span class="line-removed">2601 </span>
<span class="line-removed">2602     for (auto&amp; document : documents)</span>
<span class="line-removed">2603         document-&gt;allowsMediaDocumentInlinePlaybackChanged();</span>
2604 }

2605 #endif
2606 
2607 #if ENABLE(INDEXED_DATABASE)
2608 IDBClient::IDBConnectionToServer&amp; Page::idbConnection()
2609 {
2610     if (!m_idbConnectionToServer)
2611         m_idbConnectionToServer = &amp;databaseProvider().idbConnectionToServerForSession(m_sessionID);
2612 
2613     return *m_idbConnectionToServer;
2614 }
2615 
2616 IDBClient::IDBConnectionToServer* Page::optionalIDBConnection()
2617 {
2618     return m_idbConnectionToServer.get();
2619 }
2620 
2621 void Page::clearIDBConnection()
2622 {
2623     m_idbConnectionToServer = nullptr;
2624 }
</pre>
<hr />
<pre>
2640 bool Page::isAlwaysOnLoggingAllowed() const
2641 {
2642     return m_sessionID.isAlwaysOnLoggingAllowed();
2643 }
2644 
2645 String Page::captionUserPreferencesStyleSheet()
2646 {
2647     return m_captionUserPreferencesStyleSheet;
2648 }
2649 
2650 void Page::setCaptionUserPreferencesStyleSheet(const String&amp; styleSheet)
2651 {
2652     if (m_captionUserPreferencesStyleSheet == styleSheet)
2653         return;
2654 
2655     m_captionUserPreferencesStyleSheet = styleSheet;
2656 }
2657 
2658 void Page::accessibilitySettingsDidChange()
2659 {
<span class="line-modified">2660     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">2661         if (auto* document = frame-&gt;document()) {</span>
<span class="line-modified">2662             document-&gt;styleScope().evaluateMediaQueriesForAccessibilitySettingsChange();</span>
<span class="line-modified">2663             document-&gt;evaluateMediaQueryList();</span>
<span class="line-modified">2664         }</span>
<span class="line-removed">2665     }</span>
2666 }
2667 
2668 void Page::appearanceDidChange()
2669 {
<span class="line-modified">2670     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">2671         auto* document = frame-&gt;document();</span>
<span class="line-modified">2672         if (!document)</span>
<span class="line-modified">2673             continue;</span>
<span class="line-modified">2674 </span>
<span class="line-modified">2675         document-&gt;styleScope().didChangeStyleSheetEnvironment();</span>
<span class="line-removed">2676         document-&gt;styleScope().evaluateMediaQueriesForAppearanceChange();</span>
<span class="line-removed">2677         document-&gt;evaluateMediaQueryList();</span>
<span class="line-removed">2678     }</span>
2679 }
2680 
2681 void Page::setUnobscuredSafeAreaInsets(const FloatBoxExtent&amp; insets)
2682 {
2683     if (m_unobscuredSafeAreaInsets == insets)
2684         return;
2685 
2686     m_unobscuredSafeAreaInsets = insets;
2687 
<span class="line-modified">2688     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">2689         if (!frame-&gt;document())</span>
<span class="line-modified">2690             continue;</span>
<span class="line-removed">2691         frame-&gt;document()-&gt;constantProperties().didChangeSafeAreaInsets();</span>
<span class="line-removed">2692     }</span>
2693 }
2694 
2695 void Page::setUseSystemAppearance(bool value)
2696 {
2697     if (m_useSystemAppearance == value)
2698         return;
2699 
2700     m_useSystemAppearance = value;
2701 
2702     appearanceDidChange();
2703 
<span class="line-modified">2704     for (auto* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-removed">2705         auto* document = frame-&gt;document();</span>
<span class="line-removed">2706         if (!document)</span>
<span class="line-removed">2707             continue;</span>
<span class="line-removed">2708 </span>
2709         // System apperance change may affect stylesheet parsing. We need to reparse.
<span class="line-modified">2710         document-&gt;extensionStyleSheets().clearPageUserSheet();</span>
<span class="line-modified">2711         document-&gt;extensionStyleSheets().invalidateInjectedStyleSheetCache();</span>
<span class="line-modified">2712     }</span>
2713 }
2714 
2715 void Page::effectiveAppearanceDidChange(bool useDarkAppearance, bool useElevatedUserInterfaceLevel)
2716 {
2717 #if ENABLE(DARK_MODE_CSS)
2718     if (m_useDarkAppearance == useDarkAppearance &amp;&amp; m_useElevatedUserInterfaceLevel == useElevatedUserInterfaceLevel)
2719         return;
2720 
2721     m_useDarkAppearance = useDarkAppearance;
2722     m_useElevatedUserInterfaceLevel = useElevatedUserInterfaceLevel;
2723 
2724     InspectorInstrumentation::defaultAppearanceDidChange(*this, useDarkAppearance);
2725 
2726     appearanceDidChange();
2727 #else
2728     UNUSED_PARAM(useDarkAppearance);
2729 
2730     if (m_useElevatedUserInterfaceLevel == useElevatedUserInterfaceLevel)
2731         return;
2732 
</pre>
<hr />
<pre>
2751 }
2752 
2753 void Page::setUseDarkAppearanceOverride(Optional&lt;bool&gt; valueOverride)
2754 {
2755 #if HAVE(OS_DARK_MODE_SUPPORT)
2756     if (valueOverride == m_useDarkAppearanceOverride)
2757         return;
2758 
2759     m_useDarkAppearanceOverride = valueOverride;
2760 
2761     appearanceDidChange();
2762 #else
2763     UNUSED_PARAM(valueOverride);
2764 #endif
2765 }
2766 
2767 void Page::setFullscreenInsets(const FloatBoxExtent&amp; insets)
2768 {
2769     if (insets == m_fullscreenInsets)
2770         return;

2771     m_fullscreenInsets = insets;
2772 
<span class="line-modified">2773     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">2774         if (!frame-&gt;document())</span>
<span class="line-modified">2775             continue;</span>
<span class="line-removed">2776         frame-&gt;document()-&gt;constantProperties().didChangeFullscreenInsets();</span>
<span class="line-removed">2777     }</span>
2778 }
2779 
2780 void Page::setFullscreenAutoHideDuration(Seconds duration)
2781 {
2782     if (duration == m_fullscreenAutoHideDuration)
2783         return;

2784     m_fullscreenAutoHideDuration = duration;
<span class="line-modified">2785     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">2786         if (!frame-&gt;document())</span>
<span class="line-modified">2787             continue;</span>
<span class="line-modified">2788         frame-&gt;document()-&gt;constantProperties().setFullscreenAutoHideDuration(duration);</span>
<span class="line-removed">2789     }</span>
2790 }
2791 
2792 void Page::setFullscreenControlsHidden(bool hidden)
2793 {
2794 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">2795     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">2796         if (!frame-&gt;document())</span>
<span class="line-modified">2797             continue;</span>
<span class="line-removed">2798         frame-&gt;document()-&gt;fullscreenManager().setFullscreenControlsHidden(hidden);</span>
<span class="line-removed">2799     }</span>
2800 #else
2801     UNUSED_PARAM(hidden);
2802 #endif
2803 }
2804 
<span class="line-removed">2805 #if ENABLE(DATA_INTERACTION)</span>
<span class="line-removed">2806 </span>
<span class="line-removed">2807 bool Page::hasSelectionAtPosition(const FloatPoint&amp; position) const</span>
<span class="line-removed">2808 {</span>
<span class="line-removed">2809     auto currentSelection = m_mainFrame-&gt;selection().selection();</span>
<span class="line-removed">2810     if (!currentSelection.isRange())</span>
<span class="line-removed">2811         return false;</span>
<span class="line-removed">2812 </span>
<span class="line-removed">2813     if (auto selectedRange = currentSelection.toNormalizedRange()) {</span>
<span class="line-removed">2814         Vector&lt;SelectionRect&gt; selectionRects;</span>
<span class="line-removed">2815         selectedRange-&gt;collectSelectionRects(selectionRects);</span>
<span class="line-removed">2816         for (auto selectionRect : selectionRects) {</span>
<span class="line-removed">2817             if (FloatRect(selectionRect.rect()).contains(position))</span>
<span class="line-removed">2818                 return true;</span>
<span class="line-removed">2819         }</span>
<span class="line-removed">2820     }</span>
<span class="line-removed">2821 </span>
<span class="line-removed">2822     return false;</span>
<span class="line-removed">2823 }</span>
<span class="line-removed">2824 </span>
<span class="line-removed">2825 #endif</span>
<span class="line-removed">2826 </span>
2827 void Page::disableICECandidateFiltering()
2828 {
2829     m_shouldEnableICECandidateFilteringByDefault = false;
2830 #if ENABLE(WEB_RTC)
2831     m_rtcController.disableICECandidateFilteringForAllOrigins();
2832 #endif
2833 }
2834 
2835 void Page::enableICECandidateFiltering()
2836 {
2837     m_shouldEnableICECandidateFilteringByDefault = true;
2838 #if ENABLE(WEB_RTC)
2839     m_rtcController.enableICECandidateFiltering();
2840 #endif
2841 }
2842 
2843 void Page::didChangeMainDocument()
2844 {
2845 #if ENABLE(WEB_RTC)
2846     m_rtcController.reset(m_shouldEnableICECandidateFilteringByDefault);
2847 #endif
2848 #if ENABLE(POINTER_EVENTS)
2849     m_pointerCaptureController-&gt;reset();
2850 #endif
2851 }
2852 
2853 RenderingUpdateScheduler&amp; Page::renderingUpdateScheduler()
2854 {
2855     if (!m_renderingUpdateScheduler)
2856         m_renderingUpdateScheduler = RenderingUpdateScheduler::create(*this);
2857     return *m_renderingUpdateScheduler;
2858 }
2859 
<span class="line-modified">2860 void Page::forEachDocument(const Function&lt;void(Document&amp;)&gt;&amp; functor)</span>
2861 {
<span class="line-modified">2862     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">2863         if (!frame-&gt;document())</span>


2864             continue;
<span class="line-modified">2865 </span>
<span class="line-removed">2866         functor(*frame-&gt;document());</span>
2867     }


2868 }
2869 
<span class="line-modified">2870 void Page::applicationWillResignActive()</span>
2871 {

2872     forEachDocument([&amp;] (Document&amp; document) {
<span class="line-modified">2873         document.forEachApplicationStateChangeListener([&amp;] (ApplicationStateChangeListener&amp; listener) {</span>
<span class="line-modified">2874             listener.applicationWillResignActive();</span>
<span class="line-modified">2875         });</span>







2876     });

2877 }
2878 
2879 void Page::applicationDidEnterBackground()
2880 {
2881     m_libWebRTCProvider-&gt;setActive(false);
2882 }
2883 
2884 void Page::applicationWillEnterForeground()
2885 {
2886     m_libWebRTCProvider-&gt;setActive(true);
2887 }
2888 
2889 void Page::applicationDidBecomeActive()
2890 {
<span class="line-modified">2891     forEachDocument([&amp;] (Document&amp; document) {</span>
<span class="line-modified">2892         document.forEachApplicationStateChangeListener([&amp;] (ApplicationStateChangeListener&amp; listener) {</span>
<span class="line-modified">2893             listener.applicationDidBecomeActive();</span>
<span class="line-removed">2894         });</span>
2895     });

2896 }
2897 
2898 #if PLATFORM(MAC)
2899 ScrollLatchingState* Page::latchingState()
2900 {
2901     if (m_latchingState.isEmpty())
2902         return nullptr;
2903 
2904     return &amp;m_latchingState.last();
2905 }
2906 
2907 void Page::pushNewLatchingState()
2908 {
2909     m_latchingState.append(ScrollLatchingState());
2910 }
2911 
2912 void Page::resetLatchingState()
2913 {
2914     m_latchingState.clear();
2915 }
</pre>
<hr />
<pre>
2955 {
2956     dispatchPrintEvent(m_mainFrame, eventNames().afterprintEvent);
2957 }
2958 
2959 #if ENABLE(APPLE_PAY)
2960 void Page::setPaymentCoordinator(std::unique_ptr&lt;PaymentCoordinator&gt;&amp;&amp; paymentCoordinator)
2961 {
2962     m_paymentCoordinator = WTFMove(paymentCoordinator);
2963 }
2964 #endif
2965 
2966 void Page::configureLoggingChannel(const String&amp; channelName, WTFLogChannelState state, WTFLogLevel level)
2967 {
2968 #if !RELEASE_LOG_DISABLED
2969     if (auto* channel = getLogChannel(channelName)) {
2970         channel-&gt;state = state;
2971         channel-&gt;level = level;
2972 
2973 #if USE(LIBWEBRTC)
2974         if (channel == &amp;LogWebRTC &amp;&amp; m_mainFrame-&gt;document())
<span class="line-modified">2975             libWebRTCProvider().setEnableLogging(!m_mainFrame-&gt;document()-&gt;sessionID().isEphemeral());</span>
2976 #endif
2977     }
2978 
2979     chrome().client().configureLoggingChannel(channelName, state, level);
2980 #else
2981     UNUSED_PARAM(channelName);
2982     UNUSED_PARAM(state);
2983     UNUSED_PARAM(level);
2984 #endif
2985 }
2986 
2987 void Page::didFinishLoadingImageForElement(HTMLImageElement&amp; element)
2988 {



2989     chrome().client().didFinishLoadingImageForElement(element);
2990 }
2991 
2992 #if ENABLE(TEXT_AUTOSIZING)

2993 void Page::recomputeTextAutoSizingInAllFrames()
2994 {
2995     ASSERT(settings().textAutosizingEnabled() &amp;&amp; settings().textAutosizingUsesIdempotentMode());
<span class="line-modified">2996     for (auto* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-modified">2997         if (!frame-&gt;document())</span>
<span class="line-modified">2998             continue;</span>
<span class="line-modified">2999         auto&amp; document = *frame-&gt;document();</span>
<span class="line-modified">3000         if (!document.renderView() || !document.styleScope().resolverIfExists())</span>
<span class="line-modified">3001             continue;</span>
<span class="line-modified">3002 </span>
<span class="line-removed">3003         auto&amp; styleResolver = document.styleScope().resolver();</span>
<span class="line-removed">3004         for (auto&amp; renderer : descendantsOfType&lt;RenderElement&gt;(*document.renderView())) {</span>
<span class="line-removed">3005             if (auto* element = renderer.element()) {</span>
<span class="line-removed">3006                 auto needsLayout = styleResolver.adjustRenderStyleForTextAutosizing(renderer.mutableStyle(), *element);</span>
<span class="line-removed">3007                 if (needsLayout)</span>
<span class="line-removed">3008                     renderer.setNeedsLayout();</span>
3009             }
3010         }
<span class="line-modified">3011     }</span>
3012 }

3013 #endif
3014 







3015 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2006-2019 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2008 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Library General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2 of the License, or (at your option) any later version.
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Library General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Library General Public License
  15  * along with this library; see the file COPYING.LIB.  If not, write to
  16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  17  * Boston, MA 02110-1301, USA.
  18  */
  19 
  20 #include &quot;config.h&quot;
  21 #include &quot;Page.h&quot;
  22 
  23 #include &quot;ActivityStateChangeObserver.h&quot;
  24 #include &quot;AlternativeTextClient.h&quot;
  25 #include &quot;ApplicationCacheStorage.h&quot;

  26 #include &quot;AuthenticatorCoordinator.h&quot;
<span class="line-added">  27 #include &quot;BackForwardCache.h&quot;</span>
  28 #include &quot;BackForwardClient.h&quot;
  29 #include &quot;BackForwardController.h&quot;
  30 #include &quot;CSSAnimationController.h&quot;
  31 #include &quot;CacheStorageProvider.h&quot;
  32 #include &quot;Chrome.h&quot;
  33 #include &quot;ChromeClient.h&quot;
  34 #include &quot;ConstantPropertyMap.h&quot;
  35 #include &quot;ContextMenuClient.h&quot;
  36 #include &quot;ContextMenuController.h&quot;
  37 #include &quot;CookieJar.h&quot;
  38 #include &quot;CustomHeaderFields.h&quot;
  39 #include &quot;DOMRect.h&quot;
  40 #include &quot;DOMRectList.h&quot;
  41 #include &quot;DatabaseProvider.h&quot;
  42 #include &quot;DiagnosticLoggingClient.h&quot;
  43 #include &quot;DiagnosticLoggingKeys.h&quot;
  44 #include &quot;DocumentLoader.h&quot;
  45 #include &quot;DocumentMarkerController.h&quot;
  46 #include &quot;DocumentTimeline.h&quot;
  47 #include &quot;DragController.h&quot;
  48 #include &quot;Editing.h&quot;
  49 #include &quot;Editor.h&quot;
  50 #include &quot;EditorClient.h&quot;
  51 #include &quot;EmptyClients.h&quot;
  52 #include &quot;Event.h&quot;
  53 #include &quot;EventNames.h&quot;
  54 #include &quot;ExtensionStyleSheets.h&quot;
  55 #include &quot;FocusController.h&quot;
  56 #include &quot;FrameLoader.h&quot;
  57 #include &quot;FrameLoaderClient.h&quot;
  58 #include &quot;FrameSelection.h&quot;
  59 #include &quot;FrameTree.h&quot;
  60 #include &quot;FrameView.h&quot;
  61 #include &quot;FullscreenManager.h&quot;
  62 #include &quot;HTMLElement.h&quot;
  63 #include &quot;HTMLMediaElement.h&quot;
<span class="line-added">  64 #include &quot;HTMLTextAreaElement.h&quot;</span>
<span class="line-added">  65 #include &quot;HTMLTextFormControlElement.h&quot;</span>
  66 #include &quot;HistoryController.h&quot;
  67 #include &quot;HistoryItem.h&quot;
  68 #include &quot;InspectorClient.h&quot;
  69 #include &quot;InspectorController.h&quot;
  70 #include &quot;InspectorInstrumentation.h&quot;
<span class="line-added">  71 #include &quot;LegacySchemeRegistry.h&quot;</span>
  72 #include &quot;LibWebRTCProvider.h&quot;
  73 #include &quot;LoaderStrategy.h&quot;
  74 #include &quot;Logging.h&quot;
  75 #include &quot;LowPowerModeNotifier.h&quot;
  76 #include &quot;MediaCanStartListener.h&quot;
<span class="line-added">  77 #include &quot;MediaRecorderProvider.h&quot;</span>
  78 #include &quot;Navigator.h&quot;

  79 #include &quot;PageConfiguration.h&quot;
  80 #include &quot;PageConsoleClient.h&quot;
  81 #include &quot;PageDebuggable.h&quot;
  82 #include &quot;PageGroup.h&quot;
  83 #include &quot;PageOverlayController.h&quot;
  84 #include &quot;PaymentCoordinator.h&quot;
  85 #include &quot;PerformanceLogging.h&quot;
  86 #include &quot;PerformanceLoggingClient.h&quot;
  87 #include &quot;PerformanceMonitor.h&quot;
  88 #include &quot;PlatformMediaSessionManager.h&quot;
  89 #include &quot;PlatformStrategies.h&quot;
  90 #include &quot;PlugInClient.h&quot;
  91 #include &quot;PluginData.h&quot;
  92 #include &quot;PluginInfoProvider.h&quot;
  93 #include &quot;PluginViewBase.h&quot;
  94 #include &quot;PointerCaptureController.h&quot;
  95 #include &quot;PointerLockController.h&quot;
  96 #include &quot;ProgressTracker.h&quot;
  97 #include &quot;RenderDescendantIterator.h&quot;
  98 #include &quot;RenderLayerCompositor.h&quot;
  99 #include &quot;RenderTheme.h&quot;
 100 #include &quot;RenderView.h&quot;
 101 #include &quot;RenderWidget.h&quot;
 102 #include &quot;ResizeObserver.h&quot;
 103 #include &quot;ResourceUsageOverlay.h&quot;
 104 #include &quot;RuntimeEnabledFeatures.h&quot;
 105 #include &quot;SVGDocumentExtensions.h&quot;

 106 #include &quot;ScriptController.h&quot;
 107 #include &quot;ScriptedAnimationController.h&quot;
 108 #include &quot;ScrollLatchingState.h&quot;
 109 #include &quot;ScrollingCoordinator.h&quot;
 110 #include &quot;Settings.h&quot;
 111 #include &quot;SharedBuffer.h&quot;
 112 #include &quot;SocketProvider.h&quot;
 113 #include &quot;StorageArea.h&quot;
 114 #include &quot;StorageNamespace.h&quot;
 115 #include &quot;StorageNamespaceProvider.h&quot;
<span class="line-added"> 116 #include &quot;StyleAdjuster.h&quot;</span>
 117 #include &quot;StyleResolver.h&quot;
 118 #include &quot;StyleScope.h&quot;
 119 #include &quot;SubframeLoader.h&quot;
 120 #include &quot;TextIterator.h&quot;
 121 #include &quot;TextResourceDecoder.h&quot;
 122 #include &quot;UserContentProvider.h&quot;
<span class="line-added"> 123 #include &quot;UserContentURLPattern.h&quot;</span>
 124 #include &quot;UserInputBridge.h&quot;
 125 #include &quot;ValidationMessageClient.h&quot;
 126 #include &quot;VisitedLinkState.h&quot;
 127 #include &quot;VisitedLinkStore.h&quot;
 128 #include &quot;VoidCallback.h&quot;
 129 #include &quot;WheelEventDeltaFilter.h&quot;
 130 #include &quot;Widget.h&quot;
<span class="line-added"> 131 #include &lt;wtf/Deque.h&gt;</span>
 132 #include &lt;wtf/FileSystem.h&gt;
 133 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 134 #include &lt;wtf/StdLibExtras.h&gt;
 135 #include &lt;wtf/SystemTracing.h&gt;
 136 #include &lt;wtf/text/Base64.h&gt;
 137 #include &lt;wtf/text/StringHash.h&gt;
 138 
 139 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 140 #include &quot;HTMLVideoElement.h&quot;
 141 #include &quot;MediaPlaybackTarget.h&quot;
 142 #endif
 143 
 144 #if PLATFORM(MAC)
 145 #include &quot;ServicesOverlayController.h&quot;
 146 #endif
 147 
 148 #if ENABLE(MEDIA_SESSION)
 149 #include &quot;MediaSessionManager.h&quot;
 150 #endif
 151 
 152 #if ENABLE(INDEXED_DATABASE)
 153 #include &quot;IDBConnectionToServer.h&quot;





 154 #endif
 155 
 156 #if ENABLE(WEBGL)
 157 #include &quot;WebGLStateTracker.h&quot;
 158 #endif
 159 
 160 namespace WebCore {
 161 
 162 static HashSet&lt;Page*&gt;&amp; allPages()
 163 {
 164     static NeverDestroyed&lt;HashSet&lt;Page*&gt;&gt; set;
 165     return set;
 166 }
 167 
 168 static unsigned nonUtilityPageCount { 0 };
 169 
 170 static inline bool isUtilityPageChromeClient(ChromeClient&amp; chromeClient)
 171 {
 172     return chromeClient.isEmptyChromeClient() || chromeClient.isSVGImageChromeClient();
 173 }
</pre>
<hr />
<pre>
 197         InspectorInstrumentation::networkStateChanged(*page);
 198     }
 199 
 200     auto&amp; eventName = isOnLine ? eventNames().onlineEvent : eventNames().offlineEvent;
 201     for (auto&amp; frame : frames) {
 202         if (!frame-&gt;document())
 203             continue;
 204         frame-&gt;document()-&gt;dispatchWindowEvent(Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::No));
 205     }
 206 }
 207 
 208 static constexpr OptionSet&lt;ActivityState::Flag&gt; pageInitialActivityState()
 209 {
 210     return { ActivityState::IsVisible, ActivityState::IsInWindow };
 211 }
 212 
 213 Page::Page(PageConfiguration&amp;&amp; pageConfiguration)
 214     : m_chrome(makeUnique&lt;Chrome&gt;(*this, *pageConfiguration.chromeClient))
 215     , m_dragCaretController(makeUnique&lt;DragCaretController&gt;())
 216 #if ENABLE(DRAG_SUPPORT)
<span class="line-modified"> 217     , m_dragController(makeUnique&lt;DragController&gt;(*this, WTFMove(pageConfiguration.dragClient)))</span>
 218 #endif
 219     , m_focusController(makeUnique&lt;FocusController&gt;(*this, pageInitialActivityState()))
 220 #if ENABLE(CONTEXT_MENUS)
 221     , m_contextMenuController(makeUnique&lt;ContextMenuController&gt;(*this, *pageConfiguration.contextMenuClient))
 222 #endif
 223     , m_userInputBridge(makeUnique&lt;UserInputBridge&gt;(*this))
 224     , m_inspectorController(makeUnique&lt;InspectorController&gt;(*this, pageConfiguration.inspectorClient))
 225 #if ENABLE(POINTER_EVENTS)
 226     , m_pointerCaptureController(makeUnique&lt;PointerCaptureController&gt;(*this))
 227 #endif
 228 #if ENABLE(POINTER_LOCK)
 229     , m_pointerLockController(makeUnique&lt;PointerLockController&gt;(*this))
 230 #endif
 231     , m_settings(Settings::create(this))
<span class="line-modified"> 232     , m_progress(makeUnique&lt;ProgressTracker&gt;(WTFMove(pageConfiguration.progressTrackerClient)))</span>
 233     , m_backForwardController(makeUnique&lt;BackForwardController&gt;(*this, WTFMove(pageConfiguration.backForwardClient)))
 234     , m_mainFrame(Frame::create(this, nullptr, pageConfiguration.loaderClientForMainFrame))
 235     , m_editorClient(WTFMove(pageConfiguration.editorClient))
<span class="line-modified"> 236     , m_plugInClient(WTFMove(pageConfiguration.plugInClient))</span>
 237     , m_validationMessageClient(WTFMove(pageConfiguration.validationMessageClient))
 238     , m_diagnosticLoggingClient(WTFMove(pageConfiguration.diagnosticLoggingClient))
 239     , m_performanceLoggingClient(WTFMove(pageConfiguration.performanceLoggingClient))
 240 #if ENABLE(WEBGL)
 241     , m_webGLStateTracker(WTFMove(pageConfiguration.webGLStateTracker))
 242 #endif
 243 #if ENABLE(SPEECH_SYNTHESIS)
 244     , m_speechSynthesisClient(WTFMove(pageConfiguration.speechSynthesisClient))
 245 #endif
<span class="line-added"> 246     , m_mediaRecorderProvider((WTFMove(pageConfiguration.mediaRecorderProvider)))</span>
 247     , m_libWebRTCProvider(WTFMove(pageConfiguration.libWebRTCProvider))
 248     , m_verticalScrollElasticity(ScrollElasticityAllowed)
 249     , m_horizontalScrollElasticity(ScrollElasticityAllowed)
 250     , m_domTimerAlignmentInterval(DOMTimer::defaultAlignmentInterval())
 251     , m_domTimerAlignmentIntervalIncreaseTimer(*this, &amp;Page::domTimerAlignmentIntervalIncreaseTimerFired)
 252     , m_activityState(pageInitialActivityState())
<span class="line-modified"> 253     , m_alternativeTextClient(WTFMove(pageConfiguration.alternativeTextClient))</span>
 254     , m_consoleClient(makeUnique&lt;PageConsoleClient&gt;(*this))
 255 #if ENABLE(REMOTE_INSPECTOR)
 256     , m_inspectorDebuggable(makeUnique&lt;PageDebuggable&gt;(*this))
 257 #endif
 258     , m_socketProvider(WTFMove(pageConfiguration.socketProvider))
 259     , m_cookieJar(WTFMove(pageConfiguration.cookieJar))
 260     , m_applicationCacheStorage(*WTFMove(pageConfiguration.applicationCacheStorage))
 261     , m_cacheStorageProvider(WTFMove(pageConfiguration.cacheStorageProvider))
 262     , m_databaseProvider(*WTFMove(pageConfiguration.databaseProvider))
 263     , m_pluginInfoProvider(*WTFMove(pageConfiguration.pluginInfoProvider))
 264     , m_storageNamespaceProvider(*WTFMove(pageConfiguration.storageNamespaceProvider))
 265     , m_userContentProvider(*WTFMove(pageConfiguration.userContentProvider))
 266     , m_visitedLinkStore(*WTFMove(pageConfiguration.visitedLinkStore))
<span class="line-modified"> 267     , m_sessionID(pageConfiguration.sessionID)</span>
 268 #if ENABLE(VIDEO)
 269     , m_playbackControlsManagerUpdateTimer(*this, &amp;Page::playbackControlsManagerUpdateTimerFired)
 270 #endif
 271     , m_isUtilityPage(isUtilityPageChromeClient(chrome().client()))
 272     , m_performanceMonitor(isUtilityPage() ? nullptr : makeUnique&lt;PerformanceMonitor&gt;(*this))
 273     , m_lowPowerModeNotifier(makeUnique&lt;LowPowerModeNotifier&gt;([this](bool isLowPowerModeEnabled) { handleLowModePowerChange(isLowPowerModeEnabled); }))
 274     , m_performanceLogging(makeUnique&lt;PerformanceLogging&gt;(*this))
 275 #if PLATFORM(MAC) &amp;&amp; (ENABLE(SERVICE_CONTROLS) || ENABLE(TELEPHONE_NUMBER_DETECTION))
 276     , m_servicesOverlayController(makeUnique&lt;ServicesOverlayController&gt;(*this))
 277 #endif
 278     , m_recentWheelEventDeltaFilter(WheelEventDeltaFilter::create())
 279     , m_pageOverlayController(makeUnique&lt;PageOverlayController&gt;(*this))
 280 #if ENABLE(APPLE_PAY)
 281     , m_paymentCoordinator(makeUnique&lt;PaymentCoordinator&gt;(*pageConfiguration.paymentCoordinatorClient))
 282 #endif
 283 #if ENABLE(WEB_AUTHN)
 284     , m_authenticatorCoordinator(makeUniqueRef&lt;AuthenticatorCoordinator&gt;(WTFMove(pageConfiguration.authenticatorCoordinatorClient)))
 285 #endif
 286 #if ENABLE(APPLICATION_MANIFEST)
 287     , m_applicationManifest(pageConfiguration.applicationManifest)
 288 #endif
<span class="line-added"> 289 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)</span>
<span class="line-added"> 290     , m_deviceOrientationUpdateProvider(WTFMove(pageConfiguration.deviceOrientationUpdateProvider))</span>
<span class="line-added"> 291 #endif</span>
 292 {
 293     updateTimerThrottlingState();
 294 
 295     m_pluginInfoProvider-&gt;addPage(*this);
 296     m_userContentProvider-&gt;addPage(*this);
 297     m_visitedLinkStore-&gt;addPage(*this);
 298 
 299     static bool addedListener;
 300     if (!addedListener) {
 301         platformStrategies()-&gt;loaderStrategy()-&gt;addOnlineStateChangeListener(&amp;networkStateChanged);
 302         addedListener = true;
 303     }
 304 
 305     ASSERT(!allPages().contains(this));
 306     allPages().add(this);
 307 
 308     if (!isUtilityPage()) {
 309         ++nonUtilityPageCount;
 310         MemoryPressureHandler::setPageCount(nonUtilityPageCount);
 311     }
 312 
 313 #ifndef NDEBUG
 314     pageCounter.increment();
 315 #endif
 316 
 317 #if ENABLE(REMOTE_INSPECTOR)
 318     if (m_inspectorController-&gt;inspectorClient() &amp;&amp; m_inspectorController-&gt;inspectorClient()-&gt;allowRemoteInspectionToPageDirectly())
 319         m_inspectorDebuggable-&gt;init();
 320 #endif
 321 
 322 #if PLATFORM(COCOA)
 323     platformInitialize();
 324 #endif
 325 
 326 #if USE(LIBWEBRTC)
 327     m_libWebRTCProvider-&gt;supportsVP8(RuntimeEnabledFeatures::sharedFeatures().webRTCVP8CodecEnabled());
 328 #endif
<span class="line-added"> 329 </span>
<span class="line-added"> 330     m_corsDisablingPatterns.reserveInitialCapacity(pageConfiguration.corsDisablingPatterns.size());</span>
<span class="line-added"> 331     for (auto&amp;&amp; pattern : WTFMove(pageConfiguration.corsDisablingPatterns)) {</span>
<span class="line-added"> 332         UserContentURLPattern parsedPattern(WTFMove(pattern));</span>
<span class="line-added"> 333         if (parsedPattern.isValid())</span>
<span class="line-added"> 334             m_corsDisablingPatterns.uncheckedAppend(WTFMove(parsedPattern));</span>
<span class="line-added"> 335     }</span>
<span class="line-added"> 336     m_corsDisablingPatterns.shrinkToFit();</span>
 337 }
 338 
 339 Page::~Page()
 340 {
 341     ASSERT(!m_nestedRunLoopCount);
 342     ASSERT(!m_unnestCallback);
 343 
 344     m_validationMessageClient = nullptr;
 345     m_diagnosticLoggingClient = nullptr;
 346     m_performanceLoggingClient = nullptr;
 347     m_mainFrame-&gt;setView(nullptr);
 348     setGroupName(String());
 349     allPages().remove(this);
 350     if (!isUtilityPage()) {
 351         --nonUtilityPageCount;
 352         MemoryPressureHandler::setPageCount(nonUtilityPageCount);
 353     }
 354 
 355     m_settings-&gt;pageDestroyed();
 356 
 357     m_inspectorController-&gt;inspectedPageDestroyed();
 358 
 359     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
 360         frame-&gt;willDetachPage();
 361         frame-&gt;detachFromPage();
 362     }
 363 





 364     if (m_scrollingCoordinator)
 365         m_scrollingCoordinator-&gt;pageDestroyed();
 366 
 367     backForward().close();
 368     if (!isUtilityPage())
<span class="line-modified"> 369         BackForwardCache::singleton().removeAllItemsForPage(*this);</span>
 370 
 371 #ifndef NDEBUG
 372     pageCounter.decrement();
 373 #endif
 374 
 375     m_pluginInfoProvider-&gt;removePage(*this);
 376     m_userContentProvider-&gt;removePage(*this);
 377     m_visitedLinkStore-&gt;removePage(*this);
 378 }
 379 
 380 void Page::clearPreviousItemFromAllPages(HistoryItem* item)
 381 {
 382     for (auto* page : allPages()) {
 383         auto&amp; controller = page-&gt;mainFrame().loader().history();
 384         if (item == controller.previousItem()) {
 385             controller.clearPreviousItem();
 386             return;
 387         }
 388     }
 389 }
 390 
 391 uint64_t Page::renderTreeSize() const
 392 {
 393     uint64_t total = 0;
<span class="line-modified"> 394     forEachDocument([&amp;] (Document&amp; document) {</span>
<span class="line-modified"> 395         if (auto* renderView = document.renderView())</span>
<span class="line-modified"> 396             total += renderView-&gt;rendererCount();</span>
<span class="line-modified"> 397     });</span>

 398     return total;
 399 }
 400 
 401 OptionSet&lt;DisabledAdaptations&gt; Page::disabledAdaptations() const
 402 {
 403     if (mainFrame().document())
 404         return mainFrame().document()-&gt;disabledAdaptations();
 405 
 406     return { };
 407 }
 408 
 409 ViewportArguments Page::viewportArguments() const
 410 {
 411     return mainFrame().document() ? mainFrame().document()-&gt;viewportArguments() : ViewportArguments();
 412 }
 413 
 414 void Page::setOverrideViewportArguments(const Optional&lt;ViewportArguments&gt;&amp; viewportArguments)
 415 {
 416     if (viewportArguments == m_overrideViewportArguments)
 417         return;
</pre>
<hr />
<pre>
 554         m_group = PageGroup::pageGroup(name);
 555         m_group-&gt;addPage(*this);
 556     }
 557 }
 558 
 559 const String&amp; Page::groupName() const
 560 {
 561     return m_group ? m_group-&gt;name() : nullAtom().string();
 562 }
 563 
 564 void Page::initGroup()
 565 {
 566     ASSERT(!m_singlePageGroup);
 567     ASSERT(!m_group);
 568     m_singlePageGroup = makeUnique&lt;PageGroup&gt;(*this);
 569     m_group = m_singlePageGroup.get();
 570 }
 571 
 572 void Page::updateStyleAfterChangeInEnvironment()
 573 {
<span class="line-modified"> 574     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified"> 575         if (auto* styleResolver = document.styleScope().resolverIfExists())</span>
<span class="line-modified"> 576             styleResolver-&gt;invalidateMatchedDeclarationsCache();</span>
<span class="line-modified"> 577         document.scheduleFullStyleRebuild();</span>
<span class="line-modified"> 578         document.styleScope().didChangeStyleSheetEnvironment();</span>
<span class="line-modified"> 579         document.scheduleTimedRenderingUpdate();</span>
<span class="line-modified"> 580     });</span>






 581 }
 582 
 583 void Page::updateStyleForAllPagesAfterGlobalChangeInEnvironment()
 584 {
 585     for (auto* page : allPages())
 586         page-&gt;updateStyleAfterChangeInEnvironment();
 587 }
 588 
 589 void Page::setNeedsRecalcStyleInAllFrames()
 590 {
 591     // FIXME: Figure out what this function is actually trying to add in different call sites.
<span class="line-modified"> 592     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified"> 593         document.styleScope().didChangeStyleSheetEnvironment();</span>
<span class="line-modified"> 594     });</span>

 595 }
 596 
 597 void Page::refreshPlugins(bool reload)
 598 {
 599     HashSet&lt;PluginInfoProvider*&gt; pluginInfoProviders;
 600 
 601     for (auto* page : allPages())
 602         pluginInfoProviders.add(&amp;page-&gt;pluginInfoProvider());
 603 
 604     for (auto&amp; pluginInfoProvider : pluginInfoProviders)
 605         pluginInfoProvider-&gt;refresh(reload);
 606 }
 607 
 608 PluginData&amp; Page::pluginData()
 609 {
 610     if (!m_pluginData)
 611         m_pluginData = PluginData::create(*this);
 612     return *m_pluginData;
 613 }
 614 
</pre>
<hr />
<pre>
 893     }
 894 
 895     replaceRanges(*this, replacementRanges, replacementText);
 896     return rangesToReplace.size();
 897 }
 898 
 899 uint32_t Page::replaceSelectionWithText(const String&amp; replacementText)
 900 {
 901     auto frame = makeRef(focusController().focusedOrMainFrame());
 902     auto selection = frame-&gt;selection().selection();
 903     if (!selection.isContentEditable())
 904         return 0;
 905 
 906     auto editAction = selection.isRange() ? EditAction::InsertReplacement : EditAction::Insert;
 907     frame-&gt;editor().replaceSelectionWithText(replacementText, Editor::SelectReplacement::Yes, Editor::SmartReplace::No, editAction);
 908     return 1;
 909 }
 910 
 911 void Page::unmarkAllTextMatches()
 912 {
<span class="line-modified"> 913     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified"> 914         document.markers().removeMarkers(DocumentMarker::TextMatch);</span>
<span class="line-modified"> 915     });</span>
<span class="line-modified"> 916 }</span>
<span class="line-modified"> 917 </span>
<span class="line-added"> 918 static bool isEditableTextInputElement(const Element&amp; element)</span>
<span class="line-added"> 919 {</span>
<span class="line-added"> 920     if (is&lt;HTMLTextFormControlElement&gt;(element)) {</span>
<span class="line-added"> 921         if (!element.isTextField() &amp;&amp; !is&lt;HTMLTextAreaElement&gt;(element))</span>
<span class="line-added"> 922             return false;</span>
<span class="line-added"> 923         return downcast&lt;HTMLTextFormControlElement&gt;(element).isInnerTextElementEditable();</span>
<span class="line-added"> 924     }</span>
<span class="line-added"> 925     return element.isRootEditableElement();</span>
<span class="line-added"> 926 }</span>
<span class="line-added"> 927 </span>
<span class="line-added"> 928 Vector&lt;Ref&lt;Element&gt;&gt; Page::editableElementsInRect(const FloatRect&amp; searchRectInRootViewCoordinates) const</span>
<span class="line-added"> 929 {</span>
<span class="line-added"> 930     Vector&lt;Ref&lt;Element&gt;&gt; result;</span>
<span class="line-added"> 931     forEachDocument([&amp;] (Document&amp; document) {</span>
<span class="line-added"> 932         Deque&lt;Node*&gt; nodesToSearch;</span>
<span class="line-added"> 933         nodesToSearch.append(&amp;document);</span>
<span class="line-added"> 934         while (!nodesToSearch.isEmpty()) {</span>
<span class="line-added"> 935             auto* node = nodesToSearch.takeFirst();</span>
<span class="line-added"> 936 </span>
<span class="line-added"> 937             // It is possible to have nested text input contexts (e.g. &lt;input type=&#39;text&#39;&gt; inside contenteditable) but</span>
<span class="line-added"> 938             // in this case we just take the outermost context and skip the rest.</span>
<span class="line-added"> 939             if (!is&lt;Element&gt;(node) || !isEditableTextInputElement(downcast&lt;Element&gt;(*node))) {</span>
<span class="line-added"> 940                 for (auto* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling())</span>
<span class="line-added"> 941                     nodesToSearch.append(child);</span>
<span class="line-added"> 942                 continue;</span>
<span class="line-added"> 943             }</span>
<span class="line-added"> 944 </span>
<span class="line-added"> 945             auto&amp; element = downcast&lt;Element&gt;(*node);</span>
<span class="line-added"> 946             if (searchRectInRootViewCoordinates.intersects(element.clientRect()))</span>
<span class="line-added"> 947                 result.append(element);</span>
<span class="line-added"> 948         }</span>
<span class="line-added"> 949     });</span>
<span class="line-added"> 950     return result;</span>
 951 }
 952 
 953 const VisibleSelection&amp; Page::selection() const
 954 {
 955     return focusController().focusedOrMainFrame().selection().selection();
 956 }
 957 
 958 void Page::setDefersLoading(bool defers)
 959 {
 960     if (!m_settings-&gt;loadDeferringEnabled())
 961         return;
 962 
 963     if (m_settings-&gt;wantsBalancedSetDefersLoadingBehavior()) {
 964         ASSERT(defers || m_defersLoadingCallCount);
 965         if (defers &amp;&amp; ++m_defersLoadingCallCount &gt; 1)
 966             return;
 967         if (!defers &amp;&amp; --m_defersLoadingCallCount)
 968             return;
 969     } else {
 970         ASSERT(!m_defersLoadingCallCount);
</pre>
<hr />
<pre>
 984 
 985 bool Page::inLowQualityImageInterpolationMode() const
 986 {
 987     return m_inLowQualityInterpolationMode;
 988 }
 989 
 990 void Page::setInLowQualityImageInterpolationMode(bool mode)
 991 {
 992     m_inLowQualityInterpolationMode = mode;
 993 }
 994 
 995 DiagnosticLoggingClient&amp; Page::diagnosticLoggingClient() const
 996 {
 997     if (!settings().diagnosticLoggingEnabled() || !m_diagnosticLoggingClient)
 998         return emptyDiagnosticLoggingClient();
 999     return *m_diagnosticLoggingClient;
1000 }
1001 
1002 void Page::setMediaVolume(float volume)
1003 {
<span class="line-modified">1004     if (!(volume &gt;= 0 &amp;&amp; volume &lt;= 1))</span>
1005         return;
1006 
1007     if (m_mediaVolume == volume)
1008         return;
1009 
1010     m_mediaVolume = volume;
<span class="line-modified">1011 </span>
<span class="line-modified">1012 #if ENABLE(VIDEO)</span>
<span class="line-modified">1013     forEachMediaElement([] (HTMLMediaElement&amp; element) {</span>
<span class="line-modified">1014         element.mediaVolumeDidChange();</span>
<span class="line-modified">1015     });</span>
<span class="line-added">1016 #endif</span>
1017 }
1018 
1019 void Page::setZoomedOutPageScaleFactor(float scale)
1020 {
1021     if (m_zoomedOutPageScaleFactor == scale)
1022         return;
1023     m_zoomedOutPageScaleFactor = scale;
1024 
1025     mainFrame().deviceOrPageScaleFactorChanged();
1026 }
1027 
1028 void Page::setPageScaleFactor(float scale, const IntPoint&amp; origin, bool inStableState)
1029 {
1030     LOG(Viewports, &quot;Page::setPageScaleFactor %.2f - inStableState %d&quot;, scale, inStableState);
1031 
1032     Document* document = mainFrame().document();
<span class="line-modified">1033     RefPtr&lt;FrameView&gt; view = document-&gt;view();</span>
1034 
1035     if (scale == m_pageScaleFactor) {
<span class="line-modified">1036         if (view &amp;&amp; view-&gt;scrollPosition() != origin &amp;&amp; !delegatesScaling())</span>
<span class="line-modified">1037             document-&gt;updateLayoutIgnorePendingStylesheets();</span>
<span class="line-modified">1038     } else {</span>
<span class="line-modified">1039         m_pageScaleFactor = scale;</span>




















1040 
<span class="line-modified">1041         if (view &amp;&amp; !delegatesScaling()) {</span>
<span class="line-modified">1042             view-&gt;setNeedsLayoutAfterViewConfigurationChange();</span>
<span class="line-modified">1043             view-&gt;setNeedsCompositingGeometryUpdate();</span>
1044 
<span class="line-modified">1045             document-&gt;resolveStyle(Document::ResolveStyleType::Rebuild);</span>
1046 
<span class="line-modified">1047             // Transform change on RenderView doesn&#39;t trigger repaint on non-composited contents.</span>
<span class="line-modified">1048             mainFrame().view()-&gt;invalidateRect(IntRect(LayoutRect::infiniteRect()));</span>
<span class="line-modified">1049         }</span>
1050 
<span class="line-modified">1051         mainFrame().deviceOrPageScaleFactorChanged();</span>
1052 
<span class="line-modified">1053         if (view &amp;&amp; view-&gt;fixedElementsLayoutRelativeToFrame())</span>
<span class="line-modified">1054             view-&gt;setViewportConstrainedObjectsNeedLayout();</span>
1055 
<span class="line-modified">1056         if (view &amp;&amp; view-&gt;scrollPosition() != origin &amp;&amp; !delegatesScaling() &amp;&amp; document-&gt;renderView() &amp;&amp; document-&gt;renderView()-&gt;needsLayout() &amp;&amp; view-&gt;didFirstLayout())</span>

1057             view-&gt;layoutContext().layout();
<span class="line-added">1058     }</span>
1059 
<span class="line-added">1060     if (view &amp;&amp; view-&gt;scrollPosition() != origin) {</span>
1061         if (!view-&gt;delegatesScrolling())
1062             view-&gt;setScrollPosition(origin);
1063 #if USE(COORDINATED_GRAPHICS)
1064         else
1065             view-&gt;requestScrollPositionUpdate(origin);
1066 #endif
1067     }
1068 
1069 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1070     if (inStableState) {
<span class="line-modified">1071         forEachMediaElement([] (HTMLMediaElement&amp; element) {</span>
<span class="line-modified">1072             element.pageScaleFactorChanged();</span>
<span class="line-modified">1073         });</span>


1074     }
1075 #else
1076     UNUSED_PARAM(inStableState);
1077 #endif
1078 }
1079 
<span class="line-added">1080 void Page::setDelegatesScaling(bool delegatesScaling)</span>
<span class="line-added">1081 {</span>
<span class="line-added">1082     m_delegatesScaling = delegatesScaling;</span>
<span class="line-added">1083 }</span>
<span class="line-added">1084 </span>
1085 void Page::setViewScaleFactor(float scale)
1086 {
1087     if (m_viewScaleFactor == scale)
1088         return;
1089 
1090     m_viewScaleFactor = scale;
<span class="line-modified">1091     BackForwardCache::singleton().markPagesForDeviceOrPageScaleChanged(*this);</span>
1092 }
1093 
1094 void Page::setDeviceScaleFactor(float scaleFactor)
1095 {
1096     ASSERT(scaleFactor &gt; 0);
1097     if (scaleFactor &lt;= 0)
1098         return;
1099 
1100     if (m_deviceScaleFactor == scaleFactor)
1101         return;
1102 
1103     m_deviceScaleFactor = scaleFactor;
1104     setNeedsRecalcStyleInAllFrames();
1105 
1106     mainFrame().deviceOrPageScaleFactorChanged();
<span class="line-modified">1107     BackForwardCache::singleton().markPagesForDeviceOrPageScaleChanged(*this);</span>
1108 
1109     pageOverlayController().didChangeDeviceScaleFactor();
1110 }
1111 
1112 void Page::setInitialScale(float initialScale)
1113 {
1114     m_initialScale = initialScale;
1115 }
1116 
1117 void Page::setUserInterfaceLayoutDirection(UserInterfaceLayoutDirection userInterfaceLayoutDirection)
1118 {
1119     if (m_userInterfaceLayoutDirection == userInterfaceLayoutDirection)
1120         return;
1121 
1122     m_userInterfaceLayoutDirection = userInterfaceLayoutDirection;
<span class="line-added">1123 </span>
1124 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
<span class="line-modified">1125     forEachMediaElement([] (HTMLMediaElement&amp; element) {</span>
<span class="line-modified">1126         element.userInterfaceLayoutDirectionChanged();</span>
<span class="line-modified">1127     });</span>


1128 #endif
1129 }
1130 
1131 #if ENABLE(VIDEO)
<span class="line-added">1132 </span>
1133 void Page::updateMediaElementRateChangeRestrictions()
1134 {
<span class="line-modified">1135     // FIXME: This used to call this on all media elements, seemingly by accident. But was there some advantage to that for elements in the back/forward cache?</span>
<span class="line-modified">1136     forEachMediaElement([] (HTMLMediaElement&amp; element) {</span>
<span class="line-added">1137         element.updateRateChangeRestrictions();</span>
<span class="line-added">1138     });</span>
1139 }
<span class="line-added">1140 </span>
1141 #endif
1142 
1143 void Page::didStartProvisionalLoad()
1144 {
1145     if (m_performanceMonitor)
1146         m_performanceMonitor-&gt;didStartProvisionalLoad();
1147 }
1148 
1149 void Page::didFinishLoad()
1150 {
1151     resetRelevantPaintedObjectCounter();
1152 
1153     if (m_performanceMonitor)
1154         m_performanceMonitor-&gt;didFinishLoad();
1155 }
1156 
1157 bool Page::isOnlyNonUtilityPage() const
1158 {
1159     return !isUtilityPage() &amp;&amp; nonUtilityPageCount == 1;
1160 }
</pre>
<hr />
<pre>
1284     if (isInWindow)
1285         resumeAnimatingImages();
1286 }
1287 
1288 void Page::addActivityStateChangeObserver(ActivityStateChangeObserver&amp; observer)
1289 {
1290     m_activityStateChangeObservers.add(&amp;observer);
1291 }
1292 
1293 void Page::removeActivityStateChangeObserver(ActivityStateChangeObserver&amp; observer)
1294 {
1295     m_activityStateChangeObservers.remove(&amp;observer);
1296 }
1297 
1298 void Page::layoutIfNeeded()
1299 {
1300     if (FrameView* view = m_mainFrame-&gt;view())
1301         view-&gt;updateLayoutAndStyleIfNeededRecursive();
1302 }
1303 
<span class="line-added">1304 // https://html.spec.whatwg.org/multipage/webappapis.html#update-the-rendering</span>
1305 void Page::updateRendering()
1306 {
1307     // This function is not reentrant, e.g. a rAF callback may force repaint.
1308     if (m_inUpdateRendering) {
1309         layoutIfNeeded();
1310         return;
1311     }
1312 
1313     TraceScope traceScope(RenderingUpdateStart, RenderingUpdateEnd);
1314 
1315     SetForScope&lt;bool&gt; change(m_inUpdateRendering, true);
1316 
<span class="line-modified">1317     layoutIfNeeded();</span>
<span class="line-added">1318 </span>
<span class="line-added">1319     // Flush autofocus candidates</span>
1320 
<span class="line-modified">1321     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">1322         document.runResizeSteps();</span>

1323     });
1324 
<span class="line-modified">1325     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">1326         document.runScrollSteps();</span>
<span class="line-modified">1327     });</span>
<span class="line-modified">1328 </span>
<span class="line-modified">1329     forEachDocument([] (Document&amp; document) {</span>
<span class="line-added">1330         document.evaluateMediaQueriesAndReportChanges();</span>
<span class="line-added">1331     });</span>
<span class="line-added">1332 </span>
<span class="line-added">1333     forEachDocument([] (Document&amp; document) {</span>
<span class="line-added">1334         if (!document.domWindow())</span>
<span class="line-added">1335             return;</span>
<span class="line-added">1336         DOMHighResTimeStamp timestamp = document.domWindow()-&gt;nowTimestamp();</span>
<span class="line-added">1337         document.updateAnimationsAndSendEvents(timestamp);</span>
<span class="line-added">1338         // FIXME: Run the fullscreen steps.</span>
<span class="line-added">1339         document.serviceRequestAnimationFrameCallbacks(timestamp);</span>
<span class="line-added">1340     });</span>
1341 
1342     layoutIfNeeded();
1343 
1344 #if ENABLE(INTERSECTION_OBSERVER)
<span class="line-modified">1345     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">1346         document.updateIntersectionObservations();</span>
<span class="line-added">1347     });</span>
1348 #endif
<span class="line-added">1349 </span>
1350 #if ENABLE(RESIZE_OBSERVER)
<span class="line-modified">1351     forEachDocument([&amp;] (Document&amp; document) {</span>
<span class="line-modified">1352         document.updateResizeObservations(*this);</span>
<span class="line-added">1353     });</span>
1354 #endif
1355 
1356     layoutIfNeeded();
<span class="line-added">1357 </span>
<span class="line-added">1358     forEachDocument([] (Document&amp; document) {</span>
<span class="line-added">1359         document.updateHighlightPositions();</span>
<span class="line-added">1360     });</span>
1361 }
1362 
1363 void Page::suspendScriptedAnimations()
1364 {
1365     m_scriptedAnimationsSuspended = true;
<span class="line-modified">1366 </span>
<span class="line-modified">1367     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">1368         document.suspendScriptedAnimationControllerCallbacks();</span>
<span class="line-modified">1369     });</span>
1370 }
1371 
1372 void Page::resumeScriptedAnimations()
1373 {
1374     m_scriptedAnimationsSuspended = false;
<span class="line-modified">1375 </span>
<span class="line-modified">1376     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">1377         document.resumeScriptedAnimationControllerCallbacks();</span>
<span class="line-modified">1378     });</span>
1379 }
1380 
1381 enum class ThrottlingReasonOperation { Add, Remove };
1382 static void updateScriptedAnimationsThrottlingReason(Page&amp; page, ThrottlingReasonOperation operation, ScriptedAnimationController::ThrottlingReason reason)
1383 {
<span class="line-modified">1384     page.forEachDocument([&amp;] (Document&amp; document) {</span>
<span class="line-modified">1385         if (auto* controller = document.scriptedAnimationController()) {</span>
<span class="line-modified">1386             if (operation == ThrottlingReasonOperation::Add)</span>
<span class="line-modified">1387                 controller-&gt;addThrottlingReason(reason);</span>
<span class="line-modified">1388             else</span>
<span class="line-modified">1389                 controller-&gt;removeThrottlingReason(reason);</span>
<span class="line-modified">1390         }</span>
<span class="line-modified">1391     });</span>





1392 }
1393 
1394 void Page::setIsVisuallyIdleInternal(bool isVisuallyIdle)
1395 {
1396     updateScriptedAnimationsThrottlingReason(*this, isVisuallyIdle ? ThrottlingReasonOperation::Add : ThrottlingReasonOperation::Remove, ScriptedAnimationController::ThrottlingReason::VisuallyIdle);
1397 }
1398 
1399 void Page::handleLowModePowerChange(bool isLowPowerModeEnabled)
1400 {
1401     updateScriptedAnimationsThrottlingReason(*this, isLowPowerModeEnabled ? ThrottlingReasonOperation::Add : ThrottlingReasonOperation::Remove, ScriptedAnimationController::ThrottlingReason::LowPowerMode);
1402     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
<span class="line-modified">1403         forEachDocument([] (Document&amp; document) {</span>
1404             if (auto timeline = document.existingTimeline())
1405                 timeline-&gt;updateThrottlingState();
1406         });
1407     } else
1408         mainFrame().animation().updateThrottlingState();
1409     updateDOMTimerAlignmentInterval();
1410 }
1411 
1412 void Page::userStyleSheetLocationChanged()
1413 {
1414     // FIXME: Eventually we will move to a model of just being handed the sheet
1415     // text instead of loading the URL ourselves.
1416     URL url = m_settings-&gt;userStyleSheetLocation();
1417 
1418     // Allow any local file URL scheme to be loaded.
<span class="line-modified">1419     if (LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(url.protocol().toStringWithoutCopying()))</span>
1420         m_userStyleSheetPath = url.fileSystemPath();
1421     else
1422         m_userStyleSheetPath = String();
1423 
1424     m_didLoadUserStyleSheet = false;
1425     m_userStyleSheet = String();
1426     m_userStyleSheetModificationTime = WTF::nullopt;
1427 
1428     // Data URLs with base64-encoded UTF-8 style sheets are common. We can process them
1429     // synchronously and avoid using a loader.
1430     if (url.protocolIsData() &amp;&amp; url.string().startsWith(&quot;data:text/css;charset=utf-8;base64,&quot;)) {
1431         m_didLoadUserStyleSheet = true;
1432 
1433         Vector&lt;char&gt; styleSheetAsUTF8;
1434         if (base64Decode(decodeURLEscapeSequences(url.string().substring(35)), styleSheetAsUTF8, Base64IgnoreSpacesAndNewLines))
1435             m_userStyleSheet = String::fromUTF8(styleSheetAsUTF8.data(), styleSheetAsUTF8.size());
1436     }
1437 
<span class="line-modified">1438     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">1439         document.extensionStyleSheets().updatePageUserSheet();</span>
<span class="line-modified">1440     });</span>

1441 }
1442 
1443 const String&amp; Page::userStyleSheet() const
1444 {
1445     if (m_userStyleSheetPath.isEmpty())
1446         return m_userStyleSheet;
1447 
1448     auto modificationTime = FileSystem::getFileModificationTime(m_userStyleSheetPath);
1449     if (!modificationTime) {
1450         // The stylesheet either doesn&#39;t exist, was just deleted, or is
1451         // otherwise unreadable. If we&#39;ve read the stylesheet before, we should
1452         // throw away that data now as it no longer represents what&#39;s on disk.
1453         m_userStyleSheet = String();
1454         return m_userStyleSheet;
1455     }
1456 
1457     // If the stylesheet hasn&#39;t changed since the last time we read it, we can
1458     // just return the old data.
1459     if (m_didLoadUserStyleSheet &amp;&amp; (m_userStyleSheetModificationTime &amp;&amp; modificationTime.value() &lt;= m_userStyleSheetModificationTime.value()))
1460         return m_userStyleSheet;
</pre>
<hr />
<pre>
1475         return m_userStyleSheet;
1476 
1477     m_userStyleSheet = TextResourceDecoder::create(&quot;text/css&quot;)-&gt;decodeAndFlush(data-&gt;data(), data-&gt;size());
1478 
1479     return m_userStyleSheet;
1480 }
1481 
1482 void Page::userAgentChanged()
1483 {
1484     for (auto* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext()) {
1485         auto* window = frame-&gt;window();
1486         if (!window)
1487             continue;
1488         if (auto* navigator = window-&gt;optionalNavigator())
1489             navigator-&gt;userAgentChanged();
1490     }
1491 }
1492 
1493 void Page::invalidateStylesForAllLinks()
1494 {
<span class="line-modified">1495     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">1496         document.visitedLinkState().invalidateStyleForAllLinks();</span>
<span class="line-modified">1497     });</span>


1498 }
1499 
1500 void Page::invalidateStylesForLink(SharedStringHash linkHash)
1501 {
<span class="line-modified">1502     forEachDocument([&amp;] (Document&amp; document) {</span>
<span class="line-modified">1503         document.visitedLinkState().invalidateStyleForLink(linkHash);</span>
<span class="line-modified">1504     });</span>


1505 }
1506 
1507 void Page::invalidateInjectedStyleSheetCacheInAllFrames()
1508 {
<span class="line-modified">1509     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">1510         document.extensionStyleSheets().invalidateInjectedStyleSheetCache();</span>
<span class="line-modified">1511     });</span>



1512 }
1513 
1514 void Page::setDebugger(JSC::Debugger* debugger)
1515 {
1516     if (m_debugger == debugger)
1517         return;
1518 
1519     m_debugger = debugger;
1520 
1521     for (Frame* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext())
1522         frame-&gt;windowProxy().attachDebugger(m_debugger);
1523 }
1524 
1525 StorageNamespace* Page::sessionStorage(bool optionalCreate)
1526 {
1527     if (!m_sessionStorage &amp;&amp; optionalCreate)
1528         m_sessionStorage = m_storageNamespaceProvider-&gt;createSessionStorageNamespace(*this, m_settings-&gt;sessionStorageQuota());
1529 
1530     return m_sessionStorage.get();
1531 }
</pre>
<hr />
<pre>
1581         setTimerThrottlingState(TimerThrottlingState::Enabled);
1582         return;
1583     }
1584 
1585     // If we get here increasing timer throttling is enabled.
1586     setTimerThrottlingState(TimerThrottlingState::EnabledIncreasing);
1587 }
1588 
1589 void Page::setTimerThrottlingState(TimerThrottlingState state)
1590 {
1591     if (state == m_timerThrottlingState)
1592         return;
1593 
1594     m_timerThrottlingState = state;
1595     m_timerThrottlingStateLastChangedTime = MonotonicTime::now();
1596 
1597     updateDOMTimerAlignmentInterval();
1598 
1599     // When throttling is disabled, release all throttled timers.
1600     if (state == TimerThrottlingState::Disabled) {
<span class="line-modified">1601         forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">1602             document.didChangeTimerAlignmentInterval();</span>
<span class="line-modified">1603         });</span>

1604     }
1605 }
1606 
1607 void Page::setDOMTimerAlignmentIntervalIncreaseLimit(Seconds limit)
1608 {
1609     m_domTimerAlignmentIntervalIncreaseLimit = limit;
1610 
1611     // If (m_domTimerAlignmentIntervalIncreaseLimit &lt; m_domTimerAlignmentInterval) then we need
1612     // to update m_domTimerAlignmentInterval, if greater then need to restart the increase timer.
1613     if (m_timerThrottlingState == TimerThrottlingState::EnabledIncreasing)
1614         updateDOMTimerAlignmentInterval();
1615 }
1616 
1617 void Page::updateDOMTimerAlignmentInterval()
1618 {
1619     bool needsIncreaseTimer = false;
1620 
1621     switch (m_timerThrottlingState) {
1622     case TimerThrottlingState::Disabled:
1623         m_domTimerAlignmentInterval = isLowPowerModeEnabled() ? DOMTimer::defaultAlignmentIntervalInLowPowerMode() : DOMTimer::defaultAlignmentInterval();
</pre>
<hr />
<pre>
1649     // between increases is equal to the current throttle time. Since alinment interval increases
1650     // exponentially, time between steps is exponential too.
1651     if (!needsIncreaseTimer)
1652         m_domTimerAlignmentIntervalIncreaseTimer.stop();
1653     else if (!m_domTimerAlignmentIntervalIncreaseTimer.isActive())
1654         m_domTimerAlignmentIntervalIncreaseTimer.startOneShot(m_domTimerAlignmentInterval);
1655 }
1656 
1657 void Page::domTimerAlignmentIntervalIncreaseTimerFired()
1658 {
1659     ASSERT(m_settings-&gt;hiddenPageDOMTimerThrottlingAutoIncreases());
1660     ASSERT(m_timerThrottlingState == TimerThrottlingState::EnabledIncreasing);
1661     ASSERT(m_domTimerAlignmentInterval &lt; m_domTimerAlignmentIntervalIncreaseLimit);
1662 
1663     // Alignment interval is increased to equal the time the page has been throttled, to a limit.
1664     updateDOMTimerAlignmentInterval();
1665 }
1666 
1667 void Page::dnsPrefetchingStateChanged()
1668 {
<span class="line-modified">1669     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">1670         document.initDNSPrefetch();</span>
<span class="line-modified">1671     });</span>


1672 }
1673 
1674 Vector&lt;Ref&lt;PluginViewBase&gt;&gt; Page::pluginViews()
1675 {
1676     Vector&lt;Ref&lt;PluginViewBase&gt;&gt; views;
1677     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1678         auto* view = frame-&gt;view();
1679         if (!view)
1680             break;
1681         for (auto&amp; widget : view-&gt;children()) {
1682             if (is&lt;PluginViewBase&gt;(widget))
1683                 views.append(downcast&lt;PluginViewBase&gt;(widget.get()));
1684         }
1685     }
1686     return views;
1687 }
1688 
1689 void Page::storageBlockingStateChanged()
1690 {
<span class="line-modified">1691     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">1692         document.storageBlockingStateDidChange();</span>
<span class="line-modified">1693     });</span>


1694 
1695     // Collect the PluginViews in to a vector to ensure that action the plug-in takes
1696     // from below storageBlockingStateChanged does not affect their lifetime.
1697     for (auto&amp; view : pluginViews())
1698         view-&gt;storageBlockingStateChanged();
1699 }
1700 








1701 void Page::updateIsPlayingMedia(uint64_t sourceElementID)
1702 {
1703     MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
<span class="line-modified">1704     forEachDocument([&amp;] (Document&amp; document) {</span>
<span class="line-modified">1705         state |= document.mediaState();</span>
<span class="line-modified">1706     });</span>

1707 
1708     if (state == m_mediaState)
1709         return;
1710 
1711     m_mediaState = state;
1712 
1713     chrome().client().isPlayingMediaDidChange(state, sourceElementID);
1714 }
1715 
1716 void Page::schedulePlaybackControlsManagerUpdate()
1717 {
1718 #if ENABLE(VIDEO)
1719     if (!m_playbackControlsManagerUpdateTimer.isActive())
1720         m_playbackControlsManagerUpdateTimer.startOneShot(0_s);
1721 #endif
1722 }
1723 
1724 #if ENABLE(VIDEO)
<span class="line-added">1725 </span>
1726 void Page::playbackControlsManagerUpdateTimerFired()
1727 {
1728     if (auto bestMediaElement = HTMLMediaElement::bestMediaElementForShowingPlaybackControlsManager(MediaElementSession::PlaybackControlsPurpose::ControlsManager))
1729         chrome().client().setUpPlaybackControlsManager(*bestMediaElement);
1730     else
1731         chrome().client().clearPlaybackControlsManager();
1732 }
<span class="line-added">1733 </span>
1734 #endif
1735 
1736 void Page::setMuted(MediaProducer::MutedStateFlags muted)
1737 {
1738     if (m_mutedState == muted)
1739         return;
1740 
1741     m_mutedState = muted;
1742 
<span class="line-modified">1743     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">1744         document.pageMutedStateDidChange();</span>
<span class="line-modified">1745     });</span>


1746 }
1747 
1748 void Page::stopMediaCapture()
1749 {
1750 #if ENABLE(MEDIA_STREAM)
<span class="line-modified">1751     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">1752         document.stopMediaCapture();</span>
<span class="line-modified">1753     });</span>



1754 #endif
1755 }
1756 
1757 void Page::stopAllMediaPlayback()
1758 {
1759 #if ENABLE(VIDEO)
<span class="line-modified">1760     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">1761         document.stopAllMediaPlayback();</span>
<span class="line-modified">1762     });</span>

1763 #endif
1764 }
1765 
1766 void Page::suspendAllMediaPlayback()
1767 {
1768 #if ENABLE(VIDEO)
1769     ASSERT(!m_mediaPlaybackIsSuspended);
1770     if (m_mediaPlaybackIsSuspended)
1771         return;
1772 
<span class="line-modified">1773     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">1774         document.suspendAllMediaPlayback();</span>
<span class="line-modified">1775     });</span>

1776 
1777     m_mediaPlaybackIsSuspended = true;
1778 #endif
1779 }
1780 
1781 void Page::resumeAllMediaPlayback()
1782 {
1783 #if ENABLE(VIDEO)
1784     ASSERT(m_mediaPlaybackIsSuspended);
1785     if (!m_mediaPlaybackIsSuspended)
1786         return;
1787     m_mediaPlaybackIsSuspended = false;
1788 
<span class="line-modified">1789     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">1790         document.resumeAllMediaPlayback();</span>
<span class="line-modified">1791     });</span>

1792 #endif
1793 }
1794 
1795 void Page::suspendAllMediaBuffering()
1796 {
1797 #if ENABLE(VIDEO)
1798     ASSERT(!m_mediaBufferingIsSuspended);
1799     if (m_mediaBufferingIsSuspended)
1800         return;
1801     m_mediaBufferingIsSuspended = true;
1802 
<span class="line-modified">1803     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">1804         document.suspendAllMediaBuffering();</span>
<span class="line-modified">1805     });</span>

1806 #endif
1807 }
1808 
1809 void Page::resumeAllMediaBuffering()
1810 {
1811 #if ENABLE(VIDEO)
1812     if (!m_mediaBufferingIsSuspended)
1813         return;
1814     m_mediaBufferingIsSuspended = false;
1815 
<span class="line-modified">1816     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">1817         document.resumeAllMediaBuffering();</span>
<span class="line-modified">1818     });</span>

1819 #endif
1820 }
1821 
1822 #if ENABLE(MEDIA_SESSION)
<span class="line-added">1823 </span>
1824 void Page::handleMediaEvent(MediaEventType eventType)
1825 {
1826     switch (eventType) {
1827     case MediaEventType::PlayPause:
1828         MediaSessionManager::singleton().togglePlayback();
1829         break;
1830     case MediaEventType::TrackNext:
1831         MediaSessionManager::singleton().skipToNextTrack();
1832         break;
1833     case MediaEventType::TrackPrevious:
1834         MediaSessionManager::singleton().skipToPreviousTrack();
1835         break;
1836     }
1837 }
1838 
1839 void Page::setVolumeOfMediaElement(double volume, uint64_t elementID)
1840 {
1841     if (HTMLMediaElement* element = HTMLMediaElement::elementWithID(elementID))
1842         element-&gt;setVolume(volume, ASSERT_NO_EXCEPTION);
1843 }
<span class="line-added">1844 </span>
1845 #endif
1846 
<span class="line-modified">1847 #if ASSERT_ENABLED</span>
<span class="line-added">1848 </span>
1849 void Page::checkSubframeCountConsistency() const
1850 {
1851     ASSERT(m_subframeCount &gt;= 0);
1852 
1853     int subframeCount = 0;
1854     for (const Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
1855         ++subframeCount;
1856 
1857     ASSERT(m_subframeCount + 1 == subframeCount);
1858 }
<span class="line-modified">1859 </span>
<span class="line-added">1860 #endif // ASSERT_ENABLED</span>
1861 
1862 void Page::resumeAnimatingImages()
1863 {
1864     // Drawing models which cache painted content while out-of-window (WebKit2&#39;s composited drawing areas, etc.)
1865     // require that we repaint animated images to kickstart the animation loop.
1866     if (FrameView* view = mainFrame().view())
1867         view-&gt;resumeVisibleImageAnimationsIncludingSubframes();
1868 }
1869 
1870 void Page::setActivityState(OptionSet&lt;ActivityState::Flag&gt; activityState)
1871 {
1872     auto changed = m_activityState ^ activityState;
1873     if (!changed)
1874         return;
1875 
1876     auto oldActivityState = m_activityState;
1877 
1878     bool wasVisibleAndActive = isVisibleAndActive();
1879     m_activityState = activityState;
1880 
</pre>
<hr />
<pre>
1911 
1912 bool Page::isWindowActive() const
1913 {
1914     return m_activityState.contains(ActivityState::WindowIsActive);
1915 }
1916 
1917 void Page::setIsVisible(bool isVisible)
1918 {
1919     auto state = m_activityState;
1920 
1921     if (isVisible) {
1922         state.remove(ActivityState::IsVisuallyIdle);
1923         state.add({ ActivityState::IsVisible, ActivityState::IsVisibleOrOccluded });
1924     } else {
1925         state.add(ActivityState::IsVisuallyIdle);
1926         state.remove({ ActivityState::IsVisible, ActivityState::IsVisibleOrOccluded });
1927     }
1928     setActivityState(state);
1929 }
1930 


















1931 void Page::setIsVisibleInternal(bool isVisible)
1932 {
1933     // FIXME: The visibility state should be stored on the top-level document.
1934     // https://bugs.webkit.org/show_bug.cgi?id=116769
1935 
1936     if (isVisible) {
1937         m_isPrerender = false;
1938 
1939         resumeScriptedAnimations();
<span class="line-added">1940 </span>
1941 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">1942         forEachDocument([] (Document&amp; document) {</span>
<span class="line-added">1943             document.resumeDeviceMotionAndOrientationUpdates();</span>
<span class="line-added">1944         });</span>
1945 #endif
1946 
1947         if (FrameView* view = mainFrame().view())
1948             view-&gt;show();
1949 
1950         if (m_settings-&gt;hiddenPageCSSAnimationSuspensionEnabled()) {
1951             if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
<span class="line-modified">1952                 forEachDocument([] (Document&amp; document) {</span>
1953                     if (auto* timeline = document.existingTimeline())
1954                         timeline-&gt;resumeAnimations();
1955                 });
1956             } else
1957                 mainFrame().animation().resumeAnimations();
1958         }
1959 
<span class="line-modified">1960         forEachDocument([] (Document&amp; document) {</span>
<span class="line-added">1961             if (document.svgExtensions())</span>
<span class="line-added">1962                 document.accessSVGExtensions().unpauseAnimations();</span>
<span class="line-added">1963         });</span>
1964 
1965         resumeAnimatingImages();
1966 
1967         if (m_navigationToLogWhenVisible) {
1968             logNavigation(m_navigationToLogWhenVisible.value());
1969             m_navigationToLogWhenVisible = WTF::nullopt;
1970         }
1971     }
1972 
1973     if (!isVisible) {
1974         if (m_settings-&gt;hiddenPageCSSAnimationSuspensionEnabled()) {
1975             if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
<span class="line-modified">1976                 forEachDocument([] (Document&amp; document) {</span>
1977                     if (auto* timeline = document.existingTimeline())
1978                         timeline-&gt;suspendAnimations();
1979                 });
1980             } else
1981                 mainFrame().animation().suspendAnimations();
1982         }
1983 
<span class="line-modified">1984         forEachDocument([] (Document&amp; document) {</span>
<span class="line-added">1985             if (document.svgExtensions())</span>
<span class="line-added">1986                 document.accessSVGExtensions().pauseAnimations();</span>
<span class="line-added">1987         });</span>
1988 
1989 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">1990         forEachDocument([] (Document&amp; document) {</span>
<span class="line-added">1991             document.suspendDeviceMotionAndOrientationUpdates();</span>
<span class="line-added">1992         });</span>
1993 #endif
1994 
1995         suspendScriptedAnimations();
1996 
1997         if (FrameView* view = mainFrame().view())
1998             view-&gt;hide();
1999     }
2000 
<span class="line-modified">2001     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">2002         document.visibilityStateChanged();</span>
<span class="line-modified">2003     });</span>



2004 }
2005 
2006 void Page::setIsPrerender()
2007 {
2008     m_isPrerender = true;
2009     updateDOMTimerAlignmentInterval();
2010 }
2011 
2012 VisibilityState Page::visibilityState() const
2013 {
2014     if (isVisible())
2015         return VisibilityState::Visible;
2016     if (m_isPrerender)
2017         return VisibilityState::Prerender;
2018     return VisibilityState::Hidden;
2019 }
2020 
2021 void Page::setHeaderHeight(int headerHeight)
2022 {
2023     if (headerHeight == m_headerHeight)
</pre>
<hr />
<pre>
2074             if (insideNestedRunLoop())
2075                 return;
2076 
2077             // This callback may destruct the Page.
2078             if (m_unnestCallback) {
2079                 auto callback = WTFMove(m_unnestCallback);
2080                 callback();
2081             }
2082         });
2083     }
2084 }
2085 
2086 void Page::whenUnnested(WTF::Function&lt;void()&gt;&amp;&amp; callback)
2087 {
2088     ASSERT(!m_unnestCallback);
2089 
2090     m_unnestCallback = WTFMove(callback);
2091 }
2092 
2093 #if ENABLE(REMOTE_INSPECTOR)
<span class="line-added">2094 </span>
2095 bool Page::remoteInspectionAllowed() const
2096 {
2097     return m_inspectorDebuggable-&gt;remoteDebuggingAllowed();
2098 }
2099 
2100 void Page::setRemoteInspectionAllowed(bool allowed)
2101 {
2102     m_inspectorDebuggable-&gt;setRemoteDebuggingAllowed(allowed);
2103 }
2104 
2105 String Page::remoteInspectionNameOverride() const
2106 {
2107     return m_inspectorDebuggable-&gt;nameOverride();
2108 }
2109 
2110 void Page::setRemoteInspectionNameOverride(const String&amp; name)
2111 {
2112     m_inspectorDebuggable-&gt;setNameOverride(name);
2113 }
2114 
2115 void Page::remoteInspectorInformationDidChange() const
2116 {
2117     m_inspectorDebuggable-&gt;update();
2118 }
<span class="line-added">2119 </span>
2120 #endif
2121 
2122 void Page::addLayoutMilestones(OptionSet&lt;LayoutMilestone&gt; milestones)
2123 {
2124     // In the future, we may want a function that replaces m_layoutMilestones instead of just adding to it.
2125     m_requestedLayoutMilestones.add(milestones);
2126 }
2127 
2128 void Page::removeLayoutMilestones(OptionSet&lt;LayoutMilestone&gt; milestones)
2129 {
2130     m_requestedLayoutMilestones.remove(milestones);
2131 }
2132 
2133 Color Page::pageExtendedBackgroundColor() const
2134 {
2135     FrameView* frameView = mainFrame().view();
2136     if (!frameView)
2137         return Color();
2138 
2139     RenderView* renderView = frameView-&gt;renderView();
</pre>
<hr />
<pre>
2249         m_isCountingRelevantRepaintedObjects = false;
2250         resetRelevantPaintedObjectCounter();
2251         if (Frame* frame = &amp;mainFrame())
2252             frame-&gt;loader().didReachLayoutMilestone(DidHitRelevantRepaintedObjectsAreaThreshold);
2253     }
2254 }
2255 
2256 void Page::addRelevantUnpaintedObject(RenderObject* object, const LayoutRect&amp; objectPaintRect)
2257 {
2258     if (!isCountingRelevantRepaintedObjects())
2259         return;
2260 
2261     // The objects are only relevant if they are being painted within the relevantViewRect().
2262     if (!objectPaintRect.intersects(snappedIntRect(relevantViewRect(&amp;object-&gt;view()))))
2263         return;
2264 
2265     m_relevantUnpaintedRenderObjects.add(object);
2266     m_relevantUnpaintedRegion.unite(snappedIntRect(objectPaintRect));
2267 }
2268 
















2269 void Page::suspendActiveDOMObjectsAndAnimations()
2270 {
2271     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
2272         frame-&gt;suspendActiveDOMObjectsAndAnimations();
2273 }
2274 
2275 void Page::resumeActiveDOMObjectsAndAnimations()
2276 {
2277     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
2278         frame-&gt;resumeActiveDOMObjectsAndAnimations();
2279 
2280     resumeAnimatingImages();
2281 }
2282 
2283 bool Page::hasSeenAnyPlugin() const
2284 {
2285     return !m_seenPlugins.isEmpty();
2286 }
2287 
2288 bool Page::hasSeenPlugin(const String&amp; serviceType) const
</pre>
<hr />
<pre>
2325     if (!isVisible()) {
2326         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
2327             forEachDocument([&amp;] (Document&amp; document) {
2328                 if (auto* timeline = document.existingTimeline()) {
2329                     if (m_settings-&gt;hiddenPageCSSAnimationSuspensionEnabled())
2330                         timeline-&gt;suspendAnimations();
2331                     else
2332                         timeline-&gt;resumeAnimations();
2333                 }
2334             });
2335         } else {
2336             if (m_settings-&gt;hiddenPageCSSAnimationSuspensionEnabled())
2337                 mainFrame().animation().suspendAnimations();
2338             else
2339                 mainFrame().animation().resumeAnimations();
2340         }
2341     }
2342 }
2343 
2344 #if ENABLE(VIDEO_TRACK)
<span class="line-added">2345 </span>
2346 void Page::captionPreferencesChanged()
2347 {
<span class="line-modified">2348     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">2349         document.captionPreferencesChanged();</span>
<span class="line-modified">2350     });</span>


2351 }
<span class="line-added">2352 </span>
2353 #endif
2354 
2355 void Page::forbidPrompts()
2356 {
2357     ++m_forbidPromptsDepth;
2358 }
2359 
2360 void Page::allowPrompts()
2361 {
2362     ASSERT(m_forbidPromptsDepth);
2363     --m_forbidPromptsDepth;
2364 }
2365 
2366 bool Page::arePromptsAllowed()
2367 {
2368     return !m_forbidPromptsDepth;
2369 }
2370 
<span class="line-added">2371 void Page::forbidSynchronousLoads()</span>
<span class="line-added">2372 {</span>
<span class="line-added">2373     ++m_forbidSynchronousLoadsDepth;</span>
<span class="line-added">2374 }</span>
<span class="line-added">2375 </span>
<span class="line-added">2376 void Page::allowSynchronousLoads()</span>
<span class="line-added">2377 {</span>
<span class="line-added">2378     ASSERT(m_forbidSynchronousLoadsDepth);</span>
<span class="line-added">2379     --m_forbidSynchronousLoadsDepth;</span>
<span class="line-added">2380 }</span>
<span class="line-added">2381 </span>
<span class="line-added">2382 bool Page::areSynchronousLoadsAllowed()</span>
<span class="line-added">2383 {</span>
<span class="line-added">2384     return !m_forbidSynchronousLoadsDepth;</span>
<span class="line-added">2385 }</span>
<span class="line-added">2386 </span>
2387 void Page::logNavigation(const Navigation&amp; navigation)
2388 {
2389     String navigationDescription;
2390     switch (navigation.type) {
2391     case FrameLoadType::Standard:
2392         navigationDescription = &quot;standard&quot;_s;
2393         break;
2394     case FrameLoadType::Back:
2395         navigationDescription = &quot;back&quot;_s;
2396         break;
2397     case FrameLoadType::Forward:
2398         navigationDescription = &quot;forward&quot;_s;
2399         break;
2400     case FrameLoadType::IndexedBackForward:
2401         navigationDescription = &quot;indexedBackForward&quot;_s;
2402         break;
2403     case FrameLoadType::Reload:
2404         navigationDescription = &quot;reload&quot;_s;
2405         break;
2406     case FrameLoadType::Same:
</pre>
<hr />
<pre>
2458 
2459 VisitedLinkStore&amp; Page::visitedLinkStore()
2460 {
2461     return m_visitedLinkStore;
2462 }
2463 
2464 void Page::setVisitedLinkStore(Ref&lt;VisitedLinkStore&gt;&amp;&amp; visitedLinkStore)
2465 {
2466     m_visitedLinkStore-&gt;removePage(*this);
2467     m_visitedLinkStore = WTFMove(visitedLinkStore);
2468     m_visitedLinkStore-&gt;addPage(*this);
2469 
2470     invalidateStylesForAllLinks();
2471 }
2472 
2473 PAL::SessionID Page::sessionID() const
2474 {
2475     return m_sessionID;
2476 }
2477 
<span class="line-added">2478 // This is only called by WebKitLegacy.</span>
2479 void Page::setSessionID(PAL::SessionID sessionID)
2480 {
2481     ASSERT(sessionID.isValid());
<span class="line-added">2482     ASSERT(m_sessionID == PAL::SessionID::legacyPrivateSessionID() || m_sessionID == PAL::SessionID::defaultSessionID());</span>
<span class="line-added">2483     ASSERT(sessionID == PAL::SessionID::legacyPrivateSessionID() || sessionID == PAL::SessionID::defaultSessionID());</span>
2484 
2485 #if ENABLE(INDEXED_DATABASE)
2486     if (sessionID != m_sessionID)
2487         m_idbConnectionToServer = nullptr;
2488 #endif
2489 
2490     if (sessionID != m_sessionID &amp;&amp; m_sessionStorage)
2491         m_sessionStorage-&gt;setSessionIDForTesting(sessionID);
2492 
2493     bool privateBrowsingStateChanged = (sessionID.isEphemeral() != m_sessionID.isEphemeral());
2494 
2495     m_sessionID = sessionID;
2496 
2497     if (!privateBrowsingStateChanged)
2498         return;
2499 
<span class="line-modified">2500     forEachDocument([&amp;] (Document&amp; document) {</span>
<span class="line-modified">2501         document.privateBrowsingStateDidChange(m_sessionID);</span>
<span class="line-modified">2502     });</span>


2503 
2504     // Collect the PluginViews in to a vector to ensure that action the plug-in takes
2505     // from below privateBrowsingStateChanged does not affect their lifetime.
2506 
2507     for (auto&amp; view : pluginViews())
2508         view-&gt;privateBrowsingStateChanged(sessionID.isEphemeral());
2509 }
2510 
2511 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2512 void Page::addPlaybackTargetPickerClient(uint64_t contextId)
2513 {
2514     chrome().client().addPlaybackTargetPickerClient(contextId);
2515 }
2516 
2517 void Page::removePlaybackTargetPickerClient(uint64_t contextId)
2518 {
2519     chrome().client().removePlaybackTargetPickerClient(contextId);
2520 }
2521 
2522 void Page::showPlaybackTargetPicker(uint64_t contextId, const WebCore::IntPoint&amp; location, bool isVideo, RouteSharingPolicy routeSharingPolicy, const String&amp; routingContextUID)
</pre>
<hr />
<pre>
2531     UNUSED_PARAM(routingContextUID);
2532     chrome().client().showPlaybackTargetPicker(contextId, location, isVideo);
2533 #endif
2534 }
2535 
2536 void Page::playbackTargetPickerClientStateDidChange(uint64_t contextId, MediaProducer::MediaStateFlags state)
2537 {
2538     chrome().client().playbackTargetPickerClientStateDidChange(contextId, state);
2539 }
2540 
2541 void Page::setMockMediaPlaybackTargetPickerEnabled(bool enabled)
2542 {
2543     chrome().client().setMockMediaPlaybackTargetPickerEnabled(enabled);
2544 }
2545 
2546 void Page::setMockMediaPlaybackTargetPickerState(const String&amp; name, MediaPlaybackTargetContext::State state)
2547 {
2548     chrome().client().setMockMediaPlaybackTargetPickerState(name, state);
2549 }
2550 
<span class="line-added">2551 void Page::mockMediaPlaybackTargetPickerDismissPopup()</span>
<span class="line-added">2552 {</span>
<span class="line-added">2553     chrome().client().mockMediaPlaybackTargetPickerDismissPopup();</span>
<span class="line-added">2554 }</span>
<span class="line-added">2555 </span>
2556 void Page::setPlaybackTarget(uint64_t contextId, Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; target)
2557 {
<span class="line-modified">2558     forEachDocument([&amp;] (Document&amp; document) {</span>
<span class="line-modified">2559         document.setPlaybackTarget(contextId, target.copyRef());</span>
<span class="line-modified">2560     });</span>


2561 }
2562 
2563 void Page::playbackTargetAvailabilityDidChange(uint64_t contextId, bool available)
2564 {
<span class="line-modified">2565     forEachDocument([&amp;] (Document&amp; document) {</span>
<span class="line-modified">2566         document.playbackTargetAvailabilityDidChange(contextId, available);</span>
<span class="line-modified">2567     });</span>


2568 }
2569 
2570 void Page::setShouldPlayToPlaybackTarget(uint64_t clientId, bool shouldPlay)
2571 {
<span class="line-modified">2572     forEachDocument([&amp;] (Document&amp; document) {</span>
<span class="line-modified">2573         document.setShouldPlayToPlaybackTarget(clientId, shouldPlay);</span>
<span class="line-modified">2574     });</span>


2575 }
<span class="line-added">2576 </span>
<span class="line-added">2577 void Page::playbackTargetPickerWasDismissed(uint64_t clientId)</span>
<span class="line-added">2578 {</span>
<span class="line-added">2579     forEachDocument([&amp;] (Document&amp; document) {</span>
<span class="line-added">2580         document.playbackTargetPickerWasDismissed(clientId);</span>
<span class="line-added">2581     });</span>
<span class="line-added">2582 }</span>
<span class="line-added">2583 </span>
2584 #endif
2585 
<span class="line-modified">2586 WheelEventTestMonitor&amp; Page::ensureWheelEventTestMonitor()</span>
2587 {
<span class="line-modified">2588     if (!m_wheelEventTestMonitor) {</span>
<span class="line-modified">2589         m_wheelEventTestMonitor = adoptRef(new WheelEventTestMonitor());</span>
2590         // We need to update the scrolling coordinator so that the mainframe scrolling node can expect wheel event test triggers.
2591         if (auto* frameView = mainFrame().view()) {
2592             if (m_scrollingCoordinator)
<span class="line-modified">2593                 m_scrollingCoordinator-&gt;updateIsMonitoringWheelEventsForFrameView(*frameView);</span>
2594         }
2595     }
2596 
<span class="line-modified">2597     return *m_wheelEventTestMonitor;</span>
2598 }
2599 
2600 #if ENABLE(VIDEO)
<span class="line-added">2601 </span>
2602 void Page::setAllowsMediaDocumentInlinePlayback(bool flag)
2603 {
2604     if (m_allowsMediaDocumentInlinePlayback == flag)
2605         return;
2606     m_allowsMediaDocumentInlinePlayback = flag;
2607 
<span class="line-modified">2608     forEachMediaElement([] (HTMLMediaElement&amp; element) {</span>
<span class="line-modified">2609         element.allowsMediaDocumentInlinePlaybackChanged();</span>
<span class="line-modified">2610     });</span>



2611 }
<span class="line-added">2612 </span>
2613 #endif
2614 
2615 #if ENABLE(INDEXED_DATABASE)
2616 IDBClient::IDBConnectionToServer&amp; Page::idbConnection()
2617 {
2618     if (!m_idbConnectionToServer)
2619         m_idbConnectionToServer = &amp;databaseProvider().idbConnectionToServerForSession(m_sessionID);
2620 
2621     return *m_idbConnectionToServer;
2622 }
2623 
2624 IDBClient::IDBConnectionToServer* Page::optionalIDBConnection()
2625 {
2626     return m_idbConnectionToServer.get();
2627 }
2628 
2629 void Page::clearIDBConnection()
2630 {
2631     m_idbConnectionToServer = nullptr;
2632 }
</pre>
<hr />
<pre>
2648 bool Page::isAlwaysOnLoggingAllowed() const
2649 {
2650     return m_sessionID.isAlwaysOnLoggingAllowed();
2651 }
2652 
2653 String Page::captionUserPreferencesStyleSheet()
2654 {
2655     return m_captionUserPreferencesStyleSheet;
2656 }
2657 
2658 void Page::setCaptionUserPreferencesStyleSheet(const String&amp; styleSheet)
2659 {
2660     if (m_captionUserPreferencesStyleSheet == styleSheet)
2661         return;
2662 
2663     m_captionUserPreferencesStyleSheet = styleSheet;
2664 }
2665 
2666 void Page::accessibilitySettingsDidChange()
2667 {
<span class="line-modified">2668     forEachDocument([] (auto&amp; document) {</span>
<span class="line-modified">2669         document.styleScope().evaluateMediaQueriesForAccessibilitySettingsChange();</span>
<span class="line-modified">2670         document.updateElementsAffectedByMediaQueries();</span>
<span class="line-modified">2671         document.scheduleTimedRenderingUpdate();</span>
<span class="line-modified">2672     });</span>

2673 }
2674 
2675 void Page::appearanceDidChange()
2676 {
<span class="line-modified">2677     forEachDocument([] (auto&amp; document) {</span>
<span class="line-modified">2678         document.styleScope().didChangeStyleSheetEnvironment();</span>
<span class="line-modified">2679         document.styleScope().evaluateMediaQueriesForAppearanceChange();</span>
<span class="line-modified">2680         document.updateElementsAffectedByMediaQueries();</span>
<span class="line-modified">2681         document.scheduleTimedRenderingUpdate();</span>
<span class="line-modified">2682     });</span>



2683 }
2684 
2685 void Page::setUnobscuredSafeAreaInsets(const FloatBoxExtent&amp; insets)
2686 {
2687     if (m_unobscuredSafeAreaInsets == insets)
2688         return;
2689 
2690     m_unobscuredSafeAreaInsets = insets;
2691 
<span class="line-modified">2692     forEachDocument([&amp;] (Document&amp; document) {</span>
<span class="line-modified">2693         document.constantProperties().didChangeSafeAreaInsets();</span>
<span class="line-modified">2694     });</span>


2695 }
2696 
2697 void Page::setUseSystemAppearance(bool value)
2698 {
2699     if (m_useSystemAppearance == value)
2700         return;
2701 
2702     m_useSystemAppearance = value;
2703 
2704     appearanceDidChange();
2705 
<span class="line-modified">2706     forEachDocument([&amp;] (Document&amp; document) {</span>




2707         // System apperance change may affect stylesheet parsing. We need to reparse.
<span class="line-modified">2708         document.extensionStyleSheets().clearPageUserSheet();</span>
<span class="line-modified">2709         document.extensionStyleSheets().invalidateInjectedStyleSheetCache();</span>
<span class="line-modified">2710     });</span>
2711 }
2712 
2713 void Page::effectiveAppearanceDidChange(bool useDarkAppearance, bool useElevatedUserInterfaceLevel)
2714 {
2715 #if ENABLE(DARK_MODE_CSS)
2716     if (m_useDarkAppearance == useDarkAppearance &amp;&amp; m_useElevatedUserInterfaceLevel == useElevatedUserInterfaceLevel)
2717         return;
2718 
2719     m_useDarkAppearance = useDarkAppearance;
2720     m_useElevatedUserInterfaceLevel = useElevatedUserInterfaceLevel;
2721 
2722     InspectorInstrumentation::defaultAppearanceDidChange(*this, useDarkAppearance);
2723 
2724     appearanceDidChange();
2725 #else
2726     UNUSED_PARAM(useDarkAppearance);
2727 
2728     if (m_useElevatedUserInterfaceLevel == useElevatedUserInterfaceLevel)
2729         return;
2730 
</pre>
<hr />
<pre>
2749 }
2750 
2751 void Page::setUseDarkAppearanceOverride(Optional&lt;bool&gt; valueOverride)
2752 {
2753 #if HAVE(OS_DARK_MODE_SUPPORT)
2754     if (valueOverride == m_useDarkAppearanceOverride)
2755         return;
2756 
2757     m_useDarkAppearanceOverride = valueOverride;
2758 
2759     appearanceDidChange();
2760 #else
2761     UNUSED_PARAM(valueOverride);
2762 #endif
2763 }
2764 
2765 void Page::setFullscreenInsets(const FloatBoxExtent&amp; insets)
2766 {
2767     if (insets == m_fullscreenInsets)
2768         return;
<span class="line-added">2769 </span>
2770     m_fullscreenInsets = insets;
2771 
<span class="line-modified">2772     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">2773         document.constantProperties().didChangeFullscreenInsets();</span>
<span class="line-modified">2774     });</span>


2775 }
2776 
2777 void Page::setFullscreenAutoHideDuration(Seconds duration)
2778 {
2779     if (duration == m_fullscreenAutoHideDuration)
2780         return;
<span class="line-added">2781 </span>
2782     m_fullscreenAutoHideDuration = duration;
<span class="line-modified">2783 </span>
<span class="line-modified">2784     forEachDocument([&amp;] (Document&amp; document) {</span>
<span class="line-modified">2785         document.constantProperties().setFullscreenAutoHideDuration(duration);</span>
<span class="line-modified">2786     });</span>

2787 }
2788 
2789 void Page::setFullscreenControlsHidden(bool hidden)
2790 {
2791 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">2792     forEachDocument([&amp;] (Document&amp; document) {</span>
<span class="line-modified">2793         document.fullscreenManager().setFullscreenControlsHidden(hidden);</span>
<span class="line-modified">2794     });</span>


2795 #else
2796     UNUSED_PARAM(hidden);
2797 #endif
2798 }
2799 






















2800 void Page::disableICECandidateFiltering()
2801 {
2802     m_shouldEnableICECandidateFilteringByDefault = false;
2803 #if ENABLE(WEB_RTC)
2804     m_rtcController.disableICECandidateFilteringForAllOrigins();
2805 #endif
2806 }
2807 
2808 void Page::enableICECandidateFiltering()
2809 {
2810     m_shouldEnableICECandidateFilteringByDefault = true;
2811 #if ENABLE(WEB_RTC)
2812     m_rtcController.enableICECandidateFiltering();
2813 #endif
2814 }
2815 
2816 void Page::didChangeMainDocument()
2817 {
2818 #if ENABLE(WEB_RTC)
2819     m_rtcController.reset(m_shouldEnableICECandidateFilteringByDefault);
2820 #endif
2821 #if ENABLE(POINTER_EVENTS)
2822     m_pointerCaptureController-&gt;reset();
2823 #endif
2824 }
2825 
2826 RenderingUpdateScheduler&amp; Page::renderingUpdateScheduler()
2827 {
2828     if (!m_renderingUpdateScheduler)
2829         m_renderingUpdateScheduler = RenderingUpdateScheduler::create(*this);
2830     return *m_renderingUpdateScheduler;
2831 }
2832 
<span class="line-modified">2833 void Page::forEachDocument(const Function&lt;void(Document&amp;)&gt;&amp; functor) const</span>
2834 {
<span class="line-modified">2835     Vector&lt;Ref&lt;Document&gt;&gt; documents;</span>
<span class="line-modified">2836     for (auto* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-added">2837         auto* document = frame-&gt;document();</span>
<span class="line-added">2838         if (!document)</span>
2839             continue;
<span class="line-modified">2840         documents.append(*document);</span>

2841     }
<span class="line-added">2842     for (auto&amp; document : documents)</span>
<span class="line-added">2843         functor(document);</span>
2844 }
2845 
<span class="line-modified">2846 void Page::forEachMediaElement(const Function&lt;void(HTMLMediaElement&amp;)&gt;&amp; functor)</span>
2847 {
<span class="line-added">2848 #if ENABLE(VIDEO)</span>
2849     forEachDocument([&amp;] (Document&amp; document) {
<span class="line-modified">2850         document.forEachMediaElement(functor);</span>
<span class="line-modified">2851     });</span>
<span class="line-modified">2852 #endif</span>
<span class="line-added">2853 }</span>
<span class="line-added">2854 </span>
<span class="line-added">2855 void Page::applicationWillResignActive()</span>
<span class="line-added">2856 {</span>
<span class="line-added">2857 #if ENABLE(VIDEO)</span>
<span class="line-added">2858     forEachMediaElement([] (HTMLMediaElement&amp; element) {</span>
<span class="line-added">2859         element.applicationWillResignActive();</span>
2860     });
<span class="line-added">2861 #endif</span>
2862 }
2863 
2864 void Page::applicationDidEnterBackground()
2865 {
2866     m_libWebRTCProvider-&gt;setActive(false);
2867 }
2868 
2869 void Page::applicationWillEnterForeground()
2870 {
2871     m_libWebRTCProvider-&gt;setActive(true);
2872 }
2873 
2874 void Page::applicationDidBecomeActive()
2875 {
<span class="line-modified">2876 #if ENABLE(VIDEO)</span>
<span class="line-modified">2877     forEachMediaElement([] (HTMLMediaElement&amp; element) {</span>
<span class="line-modified">2878         element.applicationDidBecomeActive();</span>

2879     });
<span class="line-added">2880 #endif</span>
2881 }
2882 
2883 #if PLATFORM(MAC)
2884 ScrollLatchingState* Page::latchingState()
2885 {
2886     if (m_latchingState.isEmpty())
2887         return nullptr;
2888 
2889     return &amp;m_latchingState.last();
2890 }
2891 
2892 void Page::pushNewLatchingState()
2893 {
2894     m_latchingState.append(ScrollLatchingState());
2895 }
2896 
2897 void Page::resetLatchingState()
2898 {
2899     m_latchingState.clear();
2900 }
</pre>
<hr />
<pre>
2940 {
2941     dispatchPrintEvent(m_mainFrame, eventNames().afterprintEvent);
2942 }
2943 
2944 #if ENABLE(APPLE_PAY)
2945 void Page::setPaymentCoordinator(std::unique_ptr&lt;PaymentCoordinator&gt;&amp;&amp; paymentCoordinator)
2946 {
2947     m_paymentCoordinator = WTFMove(paymentCoordinator);
2948 }
2949 #endif
2950 
2951 void Page::configureLoggingChannel(const String&amp; channelName, WTFLogChannelState state, WTFLogLevel level)
2952 {
2953 #if !RELEASE_LOG_DISABLED
2954     if (auto* channel = getLogChannel(channelName)) {
2955         channel-&gt;state = state;
2956         channel-&gt;level = level;
2957 
2958 #if USE(LIBWEBRTC)
2959         if (channel == &amp;LogWebRTC &amp;&amp; m_mainFrame-&gt;document())
<span class="line-modified">2960             libWebRTCProvider().setEnableLogging(!sessionID().isEphemeral());</span>
2961 #endif
2962     }
2963 
2964     chrome().client().configureLoggingChannel(channelName, state, level);
2965 #else
2966     UNUSED_PARAM(channelName);
2967     UNUSED_PARAM(state);
2968     UNUSED_PARAM(level);
2969 #endif
2970 }
2971 
2972 void Page::didFinishLoadingImageForElement(HTMLImageElement&amp; element)
2973 {
<span class="line-added">2974     auto protectedElement = makeRef(element);</span>
<span class="line-added">2975     if (auto frame = makeRefPtr(element.document().frame()))</span>
<span class="line-added">2976         frame-&gt;editor().revealSelectionIfNeededAfterLoadingImageForElement(element);</span>
2977     chrome().client().didFinishLoadingImageForElement(element);
2978 }
2979 
2980 #if ENABLE(TEXT_AUTOSIZING)
<span class="line-added">2981 </span>
2982 void Page::recomputeTextAutoSizingInAllFrames()
2983 {
2984     ASSERT(settings().textAutosizingEnabled() &amp;&amp; settings().textAutosizingUsesIdempotentMode());
<span class="line-modified">2985     forEachDocument([] (Document&amp; document) {</span>
<span class="line-modified">2986         if (auto* renderView = document.renderView()) {</span>
<span class="line-modified">2987             for (auto&amp; renderer : descendantsOfType&lt;RenderElement&gt;(*renderView)) {</span>
<span class="line-modified">2988                 if (auto* element = renderer.element()) {</span>
<span class="line-modified">2989                     if (Style::Adjuster::adjustForTextAutosizing(renderer.mutableStyle(), *element))</span>
<span class="line-modified">2990                         renderer.setNeedsLayout();</span>
<span class="line-modified">2991                 }</span>






2992             }
2993         }
<span class="line-modified">2994     });</span>
2995 }
<span class="line-added">2996 </span>
2997 #endif
2998 
<span class="line-added">2999 bool Page::shouldDisableCorsForRequestTo(const URL&amp; url) const</span>
<span class="line-added">3000 {</span>
<span class="line-added">3001     return WTF::anyOf(m_corsDisablingPatterns, [&amp;] (const auto&amp; pattern) {</span>
<span class="line-added">3002         return pattern.matches(url);</span>
<span class="line-added">3003     });</span>
<span class="line-added">3004 }</span>
<span class="line-added">3005 </span>
3006 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="NavigatorBase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Page.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
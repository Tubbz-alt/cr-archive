diff a/modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerContainer.h b/modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerContainer.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerContainer.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerContainer.h
@@ -26,19 +26,18 @@
 #pragma once
 
 #if ENABLE(SERVICE_WORKER)
 
 #include "ActiveDOMObject.h"
-#include "DOMPromiseProxy.h"
 #include "EventTarget.h"
+#include "IDLTypes.h"
 #include "SWClientConnection.h"
 #include "SWServer.h"
 #include "ServiceWorkerJobClient.h"
 #include "ServiceWorkerRegistration.h"
 #include "ServiceWorkerRegistrationOptions.h"
 #include "WorkerType.h"
-#include <pal/SessionID.h>
 #include <wtf/Threading.h>
 
 namespace WebCore {
 
 class DeferredPromise;
@@ -46,10 +45,12 @@
 class ServiceWorker;
 
 enum class ServiceWorkerUpdateViaCache : uint8_t;
 enum class WorkerType;
 
+template<typename IDLType> class DOMPromiseProxy;
+
 class ServiceWorkerContainer final : public EventTargetWithInlineData, public ActiveDOMObject, public ServiceWorkerJobClient {
     WTF_MAKE_NONCOPYABLE(ServiceWorkerContainer);
     WTF_MAKE_ISO_ALLOCATED(ServiceWorkerContainer);
 public:
     ServiceWorkerContainer(ScriptExecutionContext*, NavigatorBase&);
@@ -65,12 +66,13 @@
     void removeRegistration(const URL& scopeURL, Ref<DeferredPromise>&&);
     void updateRegistration(const URL& scopeURL, const URL& scriptURL, WorkerType, RefPtr<DeferredPromise>&&);
 
     void getRegistration(const String& clientURL, Ref<DeferredPromise>&&);
     void updateRegistrationState(ServiceWorkerRegistrationIdentifier, ServiceWorkerRegistrationState, const Optional<ServiceWorkerData>&);
-    void fireUpdateFoundEvent(ServiceWorkerRegistrationIdentifier);
-    void fireControllerChangeEvent();
+    void updateWorkerState(ServiceWorkerIdentifier, ServiceWorkerState);
+    void queueTaskToFireUpdateFoundEvent(ServiceWorkerRegistrationIdentifier);
+    void queueTaskToDispatchControllerChangeEvent();
 
     void postMessage(MessageWithMessagePorts&&, ServiceWorkerData&& sourceData, String&& sourceOrigin);
 
     void getRegistrations(Ref<DeferredPromise>&&);
 
@@ -88,10 +90,12 @@
     bool isAlwaysOnLoggingAllowed() const;
 
     NavigatorBase* navigator() { return &m_navigator; }
 
 private:
+    bool addEventListener(const AtomString& eventType, Ref<EventListener>&&, const AddEventListenerOptions& = { }) final;
+
     void scheduleJob(std::unique_ptr<ServiceWorkerJob>&&);
 
     void jobFailedWithException(ServiceWorkerJob&, const Exception&) final;
     void jobResolvedWithRegistration(ServiceWorkerJob&, ServiceWorkerRegistrationData&&, ShouldNotifyWhenResolved) final;
     void jobResolvedWithUnregistrationResult(ServiceWorkerJob&, bool unregistrationResult) final;
@@ -100,19 +104,17 @@
     void jobFailedLoadingScript(ServiceWorkerJob&, const ResourceError&, Exception&&) final;
 
     void notifyFailedFetchingScript(ServiceWorkerJob&, const ResourceError&);
     void destroyJob(ServiceWorkerJob&);
 
-    void didFinishGetRegistrationRequest(uint64_t requestIdentifier, Optional<ServiceWorkerRegistrationData>&&);
-    void didFinishGetRegistrationsRequest(uint64_t requestIdentifier, Vector<ServiceWorkerRegistrationData>&&);
-
     DocumentOrWorkerIdentifier contextIdentifier() final;
 
     SWClientConnection& ensureSWClientConnection();
 
+    // ActiveDOMObject.
     const char* activeDOMObjectName() const final;
-    bool canSuspendForDocumentSuspension() const final;
+
     ScriptExecutionContext* scriptExecutionContext() const final { return ActiveDOMObject::scriptExecutionContext(); }
     EventTargetInterface eventTargetInterface() const final { return ServiceWorkerContainerEventTargetInterfaceType; }
     void refEventTarget() final;
     void derefEventTarget() final;
     void stop() final;
@@ -136,27 +138,14 @@
 
 #ifndef NDEBUG
     Ref<Thread> m_creationThread { Thread::current() };
 #endif
 
-    struct PendingPromise {
-        WTF_MAKE_STRUCT_FAST_ALLOCATED;
-        PendingPromise(Ref<DeferredPromise>&& promise, Ref<PendingActivity<ServiceWorkerContainer>>&& pendingActivity)
-            : promise(WTFMove(promise))
-            , pendingActivity(WTFMove(pendingActivity))
-        { }
-
-        Ref<DeferredPromise> promise;
-        Ref<PendingActivity<ServiceWorkerContainer>> pendingActivity;
-    };
-
-    uint64_t m_lastPendingPromiseIdentifier { 0 };
-    HashMap<uint64_t, std::unique_ptr<PendingPromise>> m_pendingPromises;
-
     uint64_t m_lastOngoingSettledRegistrationIdentifier { 0 };
     HashMap<uint64_t, ServiceWorkerRegistrationKey> m_ongoingSettledRegistrations;
-
+    bool m_shouldDeferMessageEvents { false };
+    Vector<Ref<Event>> m_deferredMessageEvents;
 };
 
 } // namespace WebCore
 
 #endif // ENABLE(SERVICE_WORKER)

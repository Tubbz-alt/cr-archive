<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/RTCStatsReport.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2012 Google Inc. All rights reserved.
  3  * Copyright (C) 2017 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 21  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 23  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;LibWebRTCStatsCollector.h&quot;
 29 
 30 namespace WebCore {
 31 
 32 class DOMMapAdapter;
 33 
 34 class RTCStatsReport : public RefCounted&lt;RTCStatsReport&gt; {
 35 public:
 36     using MapInitializer = Function&lt;void(DOMMapAdapter&amp;)&gt;;
 37     static Ref&lt;RTCStatsReport&gt; create(MapInitializer&amp;&amp; mapInitializer) { return adoptRef(*new RTCStatsReport(WTFMove(mapInitializer))); }
 38 
 39     void initializeMapLike(DOMMapAdapter&amp; adapter) { m_mapInitializer(adapter); }
 40 
 41     enum class Type {
 42         Codec,
 43         InboundRtp,
 44         OutboundRtp,
 45         PeerConnection,
 46         DataChannel,
 47         Track,
 48         Transport,
 49         CandidatePair,
 50         LocalCandidate,
 51         RemoteCandidate,
 52         Certificate
 53     };
 54     struct Stats {
 55         double timestamp;
 56         Type type;
 57         String id;
 58     };
 59 
 60     struct RTCRTPStreamStats : Stats {
 61         Optional&lt;uint32_t&gt; ssrc;
 62         String associateStatsId;
 63         bool isRemote { false };
 64         String mediaType;
 65 
 66         String trackId;
 67         String transportId;
 68         String codecId;
 69         Optional&lt;uint32_t&gt; firCount;
 70         Optional&lt;uint32_t&gt; pliCount;
 71         Optional&lt;uint32_t&gt; nackCount;
 72         Optional&lt;uint32_t&gt; sliCount;
 73         Optional&lt;uint64_t&gt; qpSum;
 74     };
 75 
 76     struct InboundRTPStreamStats : RTCRTPStreamStats {
 77         InboundRTPStreamStats() { type = RTCStatsReport::Type::InboundRtp; }
 78 
 79         Optional&lt;uint32_t&gt; packetsReceived;
 80         Optional&lt;uint64_t&gt; bytesReceived;
 81         Optional&lt;uint32_t&gt; packetsLost;
 82         Optional&lt;double&gt; jitter;
 83         Optional&lt;double&gt; fractionLost;
 84         Optional&lt;uint32_t&gt; packetsDiscarded;
 85         Optional&lt;uint32_t&gt; packetsRepaired;
 86         Optional&lt;uint32_t&gt; burstPacketsLost;
 87         Optional&lt;uint32_t&gt; burstPacketsDiscarded;
 88         Optional&lt;uint32_t&gt; burstLossCount;
 89         Optional&lt;uint32_t&gt; burstDiscardCount;
 90         Optional&lt;double&gt; burstLossRate;
 91         Optional&lt;double&gt; burstDiscardRate;
 92         Optional&lt;double&gt; gapLossRate;
 93         Optional&lt;double&gt; gapDiscardRate;
 94         Optional&lt;uint32_t&gt; framesDecoded;
 95     };
 96 
 97     struct OutboundRTPStreamStats : RTCRTPStreamStats {
 98         OutboundRTPStreamStats() { type = RTCStatsReport::Type::OutboundRtp; }
 99 
100         Optional&lt;uint32_t&gt; packetsSent;
101         Optional&lt;uint64_t&gt; bytesSent;
102         Optional&lt;double&gt; targetBitrate;
103         Optional&lt;uint32_t&gt; framesEncoded;
104     };
105 
106     struct MediaStreamTrackStats : Stats {
107         MediaStreamTrackStats() { type = RTCStatsReport::Type::Track; }
108 
109         String trackIdentifier;
110         Optional&lt;bool&gt; remoteSource;
111         Optional&lt;bool&gt; ended;
112         Optional&lt;bool&gt; detached;
113         Optional&lt;uint32_t&gt; frameWidth;
114         Optional&lt;uint32_t&gt; frameHeight;
115         Optional&lt;double&gt; framesPerSecond;
116         Optional&lt;uint32_t&gt; framesSent;
117         Optional&lt;uint32_t&gt; framesReceived;
118         Optional&lt;uint32_t&gt; framesDecoded;
119         Optional&lt;uint32_t&gt; framesDropped;
120         Optional&lt;uint32_t&gt; framesCorrupted;
121         Optional&lt;uint32_t&gt; partialFramesLost;
122         Optional&lt;uint32_t&gt; fullFramesLost;
123         Optional&lt;double&gt; audioLevel;
124         Optional&lt;double&gt; echoReturnLoss;
125         Optional&lt;double&gt; echoReturnLossEnhancement;
126     };
127 
128     struct DataChannelStats : Stats {
129         DataChannelStats() { type = RTCStatsReport::Type::DataChannel; }
130 
131         String label;
132         String protocol;
133         Optional&lt;int&gt; datachannelid;
134         String state;
135         Optional&lt;uint32_t&gt; messagesSent;
136         Optional&lt;uint64_t&gt; bytesSent;
137         Optional&lt;uint32_t&gt; messagesReceived;
138         Optional&lt;uint64_t&gt; bytesReceived;
139     };
140 
141     enum class IceCandidatePairState {
142         Frozen,
143         Waiting,
144         Inprogress,
145         Failed,
146         Succeeded,
147         Cancelled
148     };
149 
150     struct IceCandidatePairStats : Stats {
151         IceCandidatePairStats() { type = RTCStatsReport::Type::CandidatePair; }
152 
153         String transportId;
154         String localCandidateId;
155         String remoteCandidateId;
156         IceCandidatePairState state;
157         Optional&lt;uint64_t&gt; priority;
158         Optional&lt;bool&gt; nominated;
159         Optional&lt;bool&gt; writable;
160         Optional&lt;bool&gt; readable;
161         Optional&lt;uint64_t&gt; bytesSent;
162         Optional&lt;uint64_t&gt; bytesReceived;
163         Optional&lt;double&gt; totalRoundTripTime;
164         Optional&lt;double&gt; currentRoundTripTime;
165         Optional&lt;double&gt; availableOutgoingBitrate;
166         Optional&lt;double&gt; availableIncomingBitrate;
167         Optional&lt;uint64_t&gt; requestsReceived;
168         Optional&lt;uint64_t&gt; requestsSent;
169         Optional&lt;uint64_t&gt; responsesReceived;
170         Optional&lt;uint64_t&gt; responsesSent;
171         Optional&lt;uint64_t&gt; retransmissionsReceived;
172         Optional&lt;uint64_t&gt; retransmissionsSent;
173         Optional&lt;uint64_t&gt; consentRequestsReceived;
174         Optional&lt;uint64_t&gt; consentRequestsSent;
175         Optional&lt;uint64_t&gt; consentResponsesReceived;
176         Optional&lt;uint64_t&gt; consentResponsesSent;
177     };
178 
179     enum class IceCandidateType { Host, Srflx, Prflx, Relay };
180 
181     struct IceCandidateStats : Stats {
182         String transportId;
183         String address;
184         Optional&lt;int32_t&gt; port;
185         String protocol;
186         Optional&lt;IceCandidateType&gt; candidateType;
187         Optional&lt;int32_t&gt; priority;
188         String url;
189         bool deleted { false };
190     };
191 
192     struct CertificateStats : Stats {
193         CertificateStats() { type = RTCStatsReport::Type::Certificate; }
194 
195         String fingerprint;
196         String fingerprintAlgorithm;
197         String base64Certificate;
198         String issuerCertificateId;
199     };
200 
201     enum class CodecType {
202         Encode,
203         Decode
204     };
205 
206     struct CodecStats : Stats {
207         CodecStats() { type = RTCStatsReport::Type::Codec; }
208 
209         Optional&lt;uint32_t&gt; payloadType;
210         Optional&lt;CodecType&gt; codecType;
211         String transportId;
212         String mimeType;
213         Optional&lt;uint32_t&gt; clockRate;
214         Optional&lt;uint32_t&gt; channels;
215         String sdpFmtpLine;
216         String implementation;
217     };
218 
219     struct TransportStats : Stats {
220         TransportStats() { type = RTCStatsReport::Type::Transport; }
221 
222         Optional&lt;uint64_t&gt; bytesSent;
223         Optional&lt;uint64_t&gt; bytesReceived;
224         String rtcpTransportStatsId;
225         String selectedCandidatePairId;
226         String localCertificateId;
227         String remoteCertificateId;
228     };
229 
230     struct PeerConnectionStats : Stats {
231         PeerConnectionStats() { type = RTCStatsReport::Type::PeerConnection; }
232 
233         Optional&lt;uint32_t&gt; dataChannelsOpened;
234         Optional&lt;uint32_t&gt; dataChannelsClosed;
235     };
236 
237 private:
238     explicit RTCStatsReport(MapInitializer&amp;&amp;);
239 
240     MapInitializer m_mapInitializer;
241 };
242 
243 inline RTCStatsReport::RTCStatsReport(MapInitializer&amp;&amp; mapInitializer)
244     : m_mapInitializer(WTFMove(mapInitializer))
245 {
246 }
247 
248 } // namespace WebCore
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/DOMWindow.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DOMTimer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DOMWindow.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/DOMWindow.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  51 #include &quot;DeviceMotionEvent.h&quot;
  52 #include &quot;DeviceOrientationAndMotionAccessController.h&quot;
  53 #include &quot;DeviceOrientationController.h&quot;
  54 #include &quot;Document.h&quot;
  55 #include &quot;DocumentLoader.h&quot;
  56 #include &quot;Editor.h&quot;
  57 #include &quot;Element.h&quot;
  58 #include &quot;EventHandler.h&quot;
  59 #include &quot;EventListener.h&quot;
  60 #include &quot;EventNames.h&quot;
  61 #include &quot;FloatRect.h&quot;
  62 #include &quot;FocusController.h&quot;
  63 #include &quot;Frame.h&quot;
  64 #include &quot;FrameLoadRequest.h&quot;
  65 #include &quot;FrameLoader.h&quot;
  66 #include &quot;FrameLoaderClient.h&quot;
  67 #include &quot;FrameTree.h&quot;
  68 #include &quot;FrameView.h&quot;
  69 #include &quot;HTTPParsers.h&quot;
  70 #include &quot;History.h&quot;

  71 #include &quot;InspectorInstrumentation.h&quot;

  72 #include &quot;JSDOMWindowBase.h&quot;
  73 #include &quot;JSExecState.h&quot;
  74 #include &quot;Location.h&quot;
  75 #include &quot;MediaQueryList.h&quot;
  76 #include &quot;MediaQueryMatcher.h&quot;
  77 #include &quot;MessageEvent.h&quot;
  78 #include &quot;MessageWithMessagePorts.h&quot;
  79 #include &quot;NavigationScheduler.h&quot;
  80 #include &quot;Navigator.h&quot;
  81 #include &quot;Page.h&quot;
  82 #include &quot;PageConsoleClient.h&quot;
  83 #include &quot;PageTransitionEvent.h&quot;
  84 #include &quot;Performance.h&quot;
  85 #include &quot;RequestAnimationFrameCallback.h&quot;
  86 #include &quot;ResourceLoadInfo.h&quot;
  87 #include &quot;ResourceLoadObserver.h&quot;
  88 #include &quot;RuntimeApplicationChecks.h&quot;
<span class="line-removed">  89 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
  90 #include &quot;ScheduledAction.h&quot;
  91 #include &quot;Screen.h&quot;
  92 #include &quot;SecurityOrigin.h&quot;
  93 #include &quot;SecurityOriginData.h&quot;
  94 #include &quot;SecurityPolicy.h&quot;
  95 #include &quot;SelectorQuery.h&quot;
  96 #include &quot;SerializedScriptValue.h&quot;
  97 #include &quot;Settings.h&quot;
  98 #include &quot;StaticNodeList.h&quot;
  99 #include &quot;Storage.h&quot;
 100 #include &quot;StorageArea.h&quot;
 101 #include &quot;StorageNamespace.h&quot;
 102 #include &quot;StorageNamespaceProvider.h&quot;
 103 #include &quot;StyleMedia.h&quot;
 104 #include &quot;StyleResolver.h&quot;
 105 #include &quot;StyleScope.h&quot;
 106 #include &quot;SuddenTermination.h&quot;
 107 #include &lt;wtf/URL.h&gt;
 108 #include &quot;UserGestureIndicator.h&quot;
 109 #include &quot;VisualViewport.h&quot;
</pre>
<hr />
<pre>
 129 #include &quot;UserContentController.h&quot;
 130 #include &quot;UserMessageHandlerDescriptor.h&quot;
 131 #include &quot;WebKitNamespace.h&quot;
 132 #endif
 133 
 134 #if ENABLE(GAMEPAD)
 135 #include &quot;GamepadManager.h&quot;
 136 #endif
 137 
 138 #if ENABLE(GEOLOCATION)
 139 #include &quot;NavigatorGeolocation.h&quot;
 140 #endif
 141 
 142 #if ENABLE(POINTER_LOCK)
 143 #include &quot;PointerLockController.h&quot;
 144 #endif
 145 
 146 namespace WebCore {
 147 using namespace Inspector;
 148 















 149 WTF_MAKE_ISO_ALLOCATED_IMPL(DOMWindow);
 150 
 151 class PostMessageTimer : public TimerBase {
 152 public:
 153     PostMessageTimer(DOMWindow&amp; window, MessageWithMessagePorts&amp;&amp; message, const String&amp; sourceOrigin, RefPtr&lt;WindowProxy&gt;&amp;&amp; source, RefPtr&lt;SecurityOrigin&gt;&amp;&amp; targetOrigin, RefPtr&lt;ScriptCallStack&gt;&amp;&amp; stackTrace)
 154         : m_window(window)
 155         , m_message(WTFMove(message))
 156         , m_origin(sourceOrigin)
 157         , m_source(source)
 158         , m_targetOrigin(WTFMove(targetOrigin))
 159         , m_stackTrace(stackTrace)
 160         , m_userGestureToForward(UserGestureIndicator::currentUserGesture())
 161     {
 162     }
 163 
 164     Ref&lt;MessageEvent&gt; event(ScriptExecutionContext&amp; context)
 165     {
 166         return MessageEvent::create(MessagePort::entanglePorts(context, WTFMove(m_message.transferredPorts)), m_message.message.releaseNonNull(), m_origin, { }, m_source ? makeOptional(MessageEventSource(WTFMove(m_source))) : WTF::nullopt);
 167     }
 168 
</pre>
<hr />
<pre>
 417     observeContext(&amp;document);
 418 
 419     // The Window is being transferred from one document to another so we need to reset data
 420     // members that store the window&#39;s document (rather than the window itself).
 421     m_crypto = nullptr;
 422     m_navigator = nullptr;
 423     m_performance = nullptr;
 424 }
 425 
 426 void DOMWindow::prewarmLocalStorageIfNecessary()
 427 {
 428     auto* page = this-&gt;page();
 429 
 430     // No need to prewarm for ephemeral sessions since the data is in memory only.
 431     if (!page || page-&gt;usesEphemeralSession())
 432         return;
 433 
 434     if (!page-&gt;mainFrame().mayPrewarmLocalStorage())
 435         return;
 436 

 437     auto localStorageResult = this-&gt;localStorage();
 438     if (localStorageResult.hasException())
 439         return;
 440 
 441     auto* localStorage = localStorageResult.returnValue();
 442     if (!localStorage)
 443         return;
 444 
 445     page-&gt;mainFrame().didPrewarmLocalStorage();
 446 }
 447 
 448 DOMWindow::~DOMWindow()
 449 {
 450     if (m_suspendedForDocumentSuspension)
 451         willDestroyCachedFrame();
 452     else
 453         willDestroyDocumentInFrame();
 454 
 455     removeAllUnloadEventListeners(this);
 456     removeAllBeforeUnloadEventListeners(this);
</pre>
<hr />
<pre>
 540 
 541 #endif
 542 
 543 void DOMWindow::registerObserver(Observer&amp; observer)
 544 {
 545     m_observers.add(&amp;observer);
 546 }
 547 
 548 void DOMWindow::unregisterObserver(Observer&amp; observer)
 549 {
 550     m_observers.remove(&amp;observer);
 551 }
 552 
 553 void DOMWindow::resetUnlessSuspendedForDocumentSuspension()
 554 {
 555     if (m_suspendedForDocumentSuspension)
 556         return;
 557     willDestroyDocumentInFrame();
 558 }
 559 
<span class="line-modified"> 560 void DOMWindow::suspendForPageCache()</span>
 561 {
 562     SetForScope&lt;bool&gt; isSuspendingObservers(m_isSuspendingObservers, true);
 563     RELEASE_ASSERT(frame());
 564 
 565     for (auto* observer : copyToVector(m_observers)) {
 566         if (m_observers.contains(observer))
<span class="line-modified"> 567             observer-&gt;suspendForPageCache();</span>
 568     }
 569     RELEASE_ASSERT(frame());
 570 
 571     m_suspendedForDocumentSuspension = true;
 572 }
 573 
<span class="line-modified"> 574 void DOMWindow::resumeFromPageCache()</span>
 575 {
 576     for (auto* observer : copyToVector(m_observers)) {
 577         if (m_observers.contains(observer))
<span class="line-modified"> 578             observer-&gt;resumeFromPageCache();</span>
 579     }
 580 
 581     m_suspendedForDocumentSuspension = false;
 582 }
 583 
 584 bool DOMWindow::isCurrentlyDisplayedInFrame() const
 585 {
 586     auto* frame = this-&gt;frame();
 587     return frame &amp;&amp; frame-&gt;document()-&gt;domWindow() == this;
 588 }
 589 
 590 CustomElementRegistry&amp; DOMWindow::ensureCustomElementRegistry()
 591 {
 592     if (!m_customElementRegistry)
 593         m_customElementRegistry = CustomElementRegistry::create(*this, scriptExecutionContext());
 594     return *m_customElementRegistry;
 595 }
 596 
 597 static ExceptionOr&lt;SelectorQuery&amp;&gt; selectorQueryInFrame(Frame* frame, const String&amp; selectors)
 598 {
</pre>
<hr />
<pre>
 854     // after calling window.close(). See &lt;https://bugs.webkit.org/show_bug.cgi?id=135330&gt;.
 855     if (!page || !page-&gt;isClosing()) {
 856         if (m_localStorage)
 857             return m_localStorage.get();
 858     }
 859 
 860     if (!page)
 861         return nullptr;
 862 
 863     if (page-&gt;isClosing())
 864         return nullptr;
 865 
 866     if (!page-&gt;settings().localStorageEnabled())
 867         return nullptr;
 868 
 869     auto storageArea = page-&gt;storageNamespaceProvider().localStorageArea(*document);
 870     m_localStorage = Storage::create(*this, WTFMove(storageArea));
 871     return m_localStorage.get();
 872 }
 873 
<span class="line-modified"> 874 ExceptionOr&lt;void&gt; DOMWindow::postMessage(JSC::ExecState&amp; state, DOMWindow&amp; incumbentWindow, JSC::JSValue messageValue, const String&amp; targetOrigin, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp; transfer)</span>
 875 {
 876     if (!isCurrentlyDisplayedInFrame())
 877         return { };
 878 
 879     Document* sourceDocument = incumbentWindow.document();
 880 
 881     // Compute the target origin.  We need to do this synchronously in order
 882     // to generate the SyntaxError exception correctly.
 883     RefPtr&lt;SecurityOrigin&gt; target;
<span class="line-modified"> 884     if (targetOrigin == &quot;/&quot;) {</span>
 885         if (!sourceDocument)
 886             return { };
 887         target = &amp;sourceDocument-&gt;securityOrigin();
<span class="line-modified"> 888     } else if (targetOrigin != &quot;*&quot;) {</span>
<span class="line-modified"> 889         target = SecurityOrigin::createFromString(targetOrigin);</span>
 890         // It doesn&#39;t make sense target a postMessage at a unique origin
 891         // because there&#39;s no way to represent a unique origin in a string.
 892         if (target-&gt;isUnique())
 893             return Exception { SyntaxError };
 894     }
 895 
 896     Vector&lt;RefPtr&lt;MessagePort&gt;&gt; ports;
<span class="line-modified"> 897     auto messageData = SerializedScriptValue::create(state, messageValue, WTFMove(transfer), ports, SerializationContext::WindowPostMessage);</span>
 898     if (messageData.hasException())
 899         return messageData.releaseException();
 900 
 901     auto disentangledPorts = MessagePort::disentanglePorts(WTFMove(ports));
 902     if (disentangledPorts.hasException())
 903         return disentangledPorts.releaseException();
 904 
 905     // Capture the source of the message.  We need to do this synchronously
 906     // in order to capture the source of the message correctly.
 907     if (!sourceDocument)
 908         return { };
 909     auto sourceOrigin = sourceDocument-&gt;securityOrigin().toString();
 910 
 911     // Capture stack trace only when inspector front-end is loaded as it may be time consuming.
 912     RefPtr&lt;ScriptCallStack&gt; stackTrace;
 913     if (InspectorInstrumentation::consoleAgentEnabled(sourceDocument))
 914         stackTrace = createScriptCallStack(JSExecState::currentState());
 915 
 916     MessageWithMessagePorts message { messageData.releaseReturnValue(), disentangledPorts.releaseReturnValue() };
 917 
 918     // Schedule the message.
 919     RefPtr&lt;WindowProxy&gt; incumbentWindowProxy = incumbentWindow.frame() ? &amp;incumbentWindow.frame()-&gt;windowProxy() : nullptr;
 920     auto* timer = new PostMessageTimer(*this, WTFMove(message), sourceOrigin, WTFMove(incumbentWindowProxy), WTFMove(target), WTFMove(stackTrace));
 921     timer-&gt;startOneShot(0_s);
 922 
<span class="line-modified"> 923     InspectorInstrumentation::didPostMessage(*frame(), *timer, state);</span>
 924 
 925     return { };
 926 }
 927 
 928 void DOMWindow::postMessageTimerFired(PostMessageTimer&amp; timer)
 929 {
 930     if (!document() || !isCurrentlyDisplayedInFrame())
 931         return;
 932 
 933     Ref&lt;Frame&gt; frame = *this-&gt;frame();
 934     if (auto* intendedTargetOrigin = timer.targetOrigin()) {
 935         // Check target origin now since the target document may have changed since the timer was scheduled.
 936         if (!intendedTargetOrigin-&gt;isSameSchemeHostPort(document()-&gt;securityOrigin())) {
 937             if (auto* pageConsole = console()) {
 938                 String message = makeString(&quot;Unable to post message to &quot;, intendedTargetOrigin-&gt;toString(), &quot;. Recipient has origin &quot;, document()-&gt;securityOrigin().toString(), &quot;.\n&quot;);
 939                 if (timer.stackTrace())
 940                     pageConsole-&gt;addMessage(MessageSource::Security, MessageLevel::Error, message, *timer.stackTrace());
 941                 else
 942                     pageConsole-&gt;addMessage(MessageSource::Security, MessageLevel::Error, message);
 943             }
</pre>
<hr />
<pre>
 967 {
 968     auto* frame = this-&gt;frame();
 969     if (!frame)
 970         return nullptr;
 971 
 972     return frame-&gt;ownerElement();
 973 }
 974 
 975 void DOMWindow::focus(DOMWindow&amp; incumbentWindow)
 976 {
 977     auto* frame = this-&gt;frame();
 978     auto* openerFrame = frame ? frame-&gt;loader().opener() : nullptr;
 979     focus(openerFrame &amp;&amp; openerFrame != frame &amp;&amp; incumbentWindow.frame() == openerFrame);
 980 }
 981 
 982 void DOMWindow::focus(bool allowFocus)
 983 {
 984     if (!frame())
 985         return;
 986 
<span class="line-modified"> 987     Page* page = frame()-&gt;page();</span>


 988     if (!page)
 989         return;
 990 
<span class="line-modified"> 991     allowFocus = allowFocus || WindowFocusAllowedIndicator::windowFocusAllowed() || !frame()-&gt;settings().windowFocusRestricted();</span>
 992 
 993     // If we&#39;re a top level window, bring the window to the front.
<span class="line-modified"> 994     if (frame()-&gt;isMainFrame() &amp;&amp; allowFocus)</span>
 995         page-&gt;chrome().focus();
 996 
<span class="line-modified"> 997     if (!frame())</span>
<span class="line-removed"> 998         return;</span>
<span class="line-removed"> 999 </span>
<span class="line-removed">1000     if (!frame()-&gt;hasHadUserInteraction() &amp;&amp; !isSameSecurityOriginAsMainFrame())</span>
1001         return;
1002 
1003     // Clear the current frame&#39;s focused node if a new frame is about to be focused.
<span class="line-modified">1004     Frame* focusedFrame = page-&gt;focusController().focusedFrame();</span>
<span class="line-modified">1005     if (focusedFrame &amp;&amp; focusedFrame != frame())</span>
1006         focusedFrame-&gt;document()-&gt;setFocusedElement(nullptr);
1007 
<span class="line-modified">1008     // setFocusedElement may clear frame(), so recheck before using it.</span>
<span class="line-removed">1009     if (auto* frame = this-&gt;frame())</span>
<span class="line-removed">1010         frame-&gt;eventHandler().focusDocumentView();</span>
1011 }
1012 
1013 void DOMWindow::blur()
1014 {
1015     auto* frame = this-&gt;frame();
1016     if (!frame)
1017         return;
1018 
1019     Page* page = frame-&gt;page();
1020     if (!page)
1021         return;
1022 
1023     if (frame-&gt;settings().windowFocusRestricted())
1024         return;
1025 
1026     if (!frame-&gt;isMainFrame())
1027         return;
1028 
1029     page-&gt;chrome().unfocus();
1030 }
</pre>
<hr />
<pre>
1040 {
1041     auto* frame = this-&gt;frame();
1042     if (!frame)
1043         return;
1044 
1045     Page* page = frame-&gt;page();
1046     if (!page)
1047         return;
1048 
1049     if (!frame-&gt;isMainFrame())
1050         return;
1051 
1052     if (!(page-&gt;openedByDOM() || page-&gt;backForward().count() &lt;= 1)) {
1053         console()-&gt;addMessage(MessageSource::JS, MessageLevel::Warning, &quot;Can&#39;t close the window since it was not opened by JavaScript&quot;_s);
1054         return;
1055     }
1056 
1057     if (!frame-&gt;loader().shouldClose())
1058         return;
1059 


1060     page-&gt;setIsClosing();
1061     page-&gt;chrome().closeWindowSoon();
1062 }
1063 
1064 void DOMWindow::print()
1065 {
1066     auto* frame = this-&gt;frame();
1067     if (!frame)
1068         return;
1069 
1070     auto* page = frame-&gt;page();
1071     if (!page)
1072         return;
1073 
1074     if (!page-&gt;arePromptsAllowed()) {
1075         printErrorMessage(&quot;Use of window.print is not allowed while unloading a page.&quot;);
1076         return;
1077     }
1078 
1079     if (frame-&gt;loader().activeDocumentLoader()-&gt;isLoading()) {
</pre>
<hr />
<pre>
1106         return;
1107     }
1108 
1109     auto* page = frame-&gt;page();
1110     if (!page)
1111         return;
1112 
1113     if (!page-&gt;arePromptsAllowed()) {
1114         printErrorMessage(&quot;Use of window.alert is not allowed while unloading a page.&quot;);
1115         return;
1116     }
1117 
1118     frame-&gt;document()-&gt;updateStyleIfNeeded();
1119 #if ENABLE(POINTER_LOCK)
1120     page-&gt;pointerLockController().requestPointerUnlock();
1121 #endif
1122 
1123     page-&gt;chrome().runJavaScriptAlert(*frame, message);
1124 }
1125 
<span class="line-modified">1126 bool DOMWindow::confirm(const String&amp; message)</span>
1127 {
1128     auto* frame = this-&gt;frame();
1129     if (!frame)
1130         return false;
1131 
1132     if (document()-&gt;isSandboxed(SandboxModals)) {
1133         printErrorMessage(&quot;Use of window.confirm is not allowed in a sandboxed frame when the allow-modals flag is not set.&quot;);
1134         return false;
1135     }
1136 
1137     auto* page = frame-&gt;page();
1138     if (!page)
1139         return false;
1140 
1141     if (!page-&gt;arePromptsAllowed()) {
1142         printErrorMessage(&quot;Use of window.confirm is not allowed while unloading a page.&quot;);
1143         return false;
1144     }
1145 
1146     frame-&gt;document()-&gt;updateStyleIfNeeded();
</pre>
<hr />
<pre>
1471     if (parentFrame)
1472         return &amp;parentFrame-&gt;windowProxy();
1473 
1474     return &amp;frame-&gt;windowProxy();
1475 }
1476 
1477 WindowProxy* DOMWindow::top() const
1478 {
1479     auto* frame = this-&gt;frame();
1480     if (!frame)
1481         return nullptr;
1482 
1483     if (!frame-&gt;page())
1484         return nullptr;
1485 
1486     return &amp;frame-&gt;tree().top().windowProxy();
1487 }
1488 
1489 String DOMWindow::origin() const
1490 {
<span class="line-modified">1491     auto document = this-&gt;document();</span>
1492     return document ? document-&gt;securityOrigin().toString() : emptyString();
1493 }
1494 






1495 Document* DOMWindow::document() const
1496 {
1497     return downcast&lt;Document&gt;(ContextDestructionObserver::scriptExecutionContext());
1498 }
1499 



























































1500 StyleMedia&amp; DOMWindow::styleMedia()
1501 {
1502     if (!m_media)
1503         m_media = StyleMedia::create(*this);
1504     return *m_media;
1505 }
1506 
1507 Ref&lt;CSSStyleDeclaration&gt; DOMWindow::getComputedStyle(Element&amp; element, const String&amp; pseudoElt) const
1508 {
1509     return CSSComputedStyleDeclaration::create(element, false, pseudoElt);
1510 }
1511 
1512 RefPtr&lt;CSSRuleList&gt; DOMWindow::getMatchedCSSRules(Element* element, const String&amp; pseudoElement, bool authorOnly) const
1513 {
1514     if (!isCurrentlyDisplayedInFrame())
1515         return nullptr;
1516 
1517     unsigned colonStart = pseudoElement[0] == &#39;:&#39; ? (pseudoElement[1] == &#39;:&#39; ? 2 : 1) : 0;
1518     auto pseudoType = CSSSelector::parsePseudoElementType(StringView { pseudoElement }.substring(colonStart));
1519     if (pseudoType == CSSSelector::PseudoElementUnknown &amp;&amp; !pseudoElement.isEmpty())
1520         return nullptr;
1521 
1522     auto* frame = this-&gt;frame();
1523     frame-&gt;document()-&gt;styleScope().flushPendingUpdate();
1524 
<span class="line-modified">1525     unsigned rulesToInclude = StyleResolver::AuthorCSSRules;</span>
1526     if (!authorOnly)
<span class="line-modified">1527         rulesToInclude |= StyleResolver::UAAndUserCSSRules;</span>
1528 
1529     PseudoId pseudoId = CSSSelector::pseudoId(pseudoType);
1530 
1531     auto matchedRules = frame-&gt;document()-&gt;styleScope().resolver().pseudoStyleRulesForElement(element, pseudoId, rulesToInclude);
1532     if (matchedRules.isEmpty())
1533         return nullptr;
1534 
1535     bool allowCrossOrigin = frame-&gt;settings().crossOriginCheckInGetMatchedCSSRulesDisabled();
1536 
1537     auto ruleList = StaticCSSRuleList::create();
1538     for (auto&amp; rule : matchedRules) {
1539         if (!allowCrossOrigin &amp;&amp; !rule-&gt;hasDocumentSecurityOrigin())
1540             continue;
1541         ruleList-&gt;rules().append(rule-&gt;createCSSOMWrapper());
1542     }
1543 
1544     if (ruleList-&gt;rules().isEmpty())
1545         return nullptr;
1546 
1547     return ruleList;
</pre>
<hr />
<pre>
1585 
1586     Page* page = frame-&gt;page();
1587     if (!page)
1588         return 0.0;
1589 
1590     return page-&gt;deviceScaleFactor();
1591 }
1592 
1593 void DOMWindow::scrollBy(double x, double y) const
1594 {
1595     scrollBy({ x, y });
1596 }
1597 
1598 void DOMWindow::scrollBy(const ScrollToOptions&amp; options) const
1599 {
1600     if (!isCurrentlyDisplayedInFrame())
1601         return;
1602 
1603     document()-&gt;updateLayoutIgnorePendingStylesheets();
1604 
<span class="line-modified">1605     FrameView* view = frame()-&gt;view();</span>




1606     if (!view)
1607         return;
1608 
1609     ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options, 0, 0);
1610     scrollToOptions.left.value() += view-&gt;mapFromLayoutToCSSUnits(view-&gt;contentsScrollPosition().x());
1611     scrollToOptions.top.value() += view-&gt;mapFromLayoutToCSSUnits(view-&gt;contentsScrollPosition().y());
1612     scrollTo(scrollToOptions);
1613 }
1614 
1615 void DOMWindow::scrollTo(double x, double y, ScrollClamping clamping) const
1616 {
1617     scrollTo({ x, y }, clamping);
1618 }
1619 
<span class="line-modified">1620 void DOMWindow::scrollTo(const ScrollToOptions&amp; options, ScrollClamping) const</span>
1621 {
1622     if (!isCurrentlyDisplayedInFrame())
1623         return;
1624 
1625     RefPtr&lt;FrameView&gt; view = frame()-&gt;view();
1626     if (!view)
1627         return;
1628 
1629     ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options,
1630         view-&gt;contentsScrollPosition().x(), view-&gt;contentsScrollPosition().y()
1631     );
1632 
1633     if (!scrollToOptions.left.value() &amp;&amp; !scrollToOptions.top.value() &amp;&amp; view-&gt;contentsScrollPosition() == IntPoint(0, 0))
1634         return;
1635 
1636     document()-&gt;updateLayoutIgnorePendingStylesheets();
1637 
1638     IntPoint layoutPos(view-&gt;mapFromCSSToLayoutUnits(scrollToOptions.left.value()), view-&gt;mapFromCSSToLayoutUnits(scrollToOptions.top.value()));
<span class="line-modified">1639     view-&gt;setContentsScrollPosition(layoutPos);</span>
1640 }
1641 
1642 bool DOMWindow::allowedToChangeWindowGeometry() const
1643 {
1644     auto* frame = this-&gt;frame();
1645     if (!frame)
1646         return false;
1647     if (!frame-&gt;page())
1648         return false;
1649     if (!frame-&gt;isMainFrame())
1650         return false;
1651     // Prevent web content from tricking the user into initiating a drag.
1652     if (frame-&gt;eventHandler().mousePressed())
1653         return false;
1654     return true;
1655 }
1656 
1657 void DOMWindow::moveBy(float x, float y) const
1658 {
1659     if (!allowedToChangeWindowGeometry())
</pre>
<hr />
<pre>
1687 
1688     auto* page = frame()-&gt;page();
1689     FloatRect fr = page-&gt;chrome().windowRect();
1690     FloatSize dest = fr.size() + FloatSize(x, y);
1691     FloatRect update(fr.location(), dest);
1692     page-&gt;chrome().setWindowRect(adjustWindowRect(*page, update));
1693 }
1694 
1695 void DOMWindow::resizeTo(float width, float height) const
1696 {
1697     if (!allowedToChangeWindowGeometry())
1698         return;
1699 
1700     auto* page = frame()-&gt;page();
1701     FloatRect fr = page-&gt;chrome().windowRect();
1702     FloatSize dest = FloatSize(width, height);
1703     FloatRect update(fr.location(), dest);
1704     page-&gt;chrome().setWindowRect(adjustWindowRect(*page, update));
1705 }
1706 
<span class="line-modified">1707 ExceptionOr&lt;int&gt; DOMWindow::setTimeout(JSC::ExecState&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
1708 {
1709     auto* context = scriptExecutionContext();
1710     if (!context)
1711         return Exception { InvalidAccessError };
1712 
1713     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
1714     if (action-&gt;type() == ScheduledAction::Type::Code) {
1715         if (!context-&gt;contentSecurityPolicy()-&gt;allowEval(&amp;state))
1716             return 0;
1717     }
1718 
1719     action-&gt;addArguments(WTFMove(arguments));
1720 
1721     return DOMTimer::install(*context, WTFMove(action), Seconds::fromMilliseconds(timeout), true);
1722 }
1723 
1724 void DOMWindow::clearTimeout(int timeoutId)
1725 {
1726     ScriptExecutionContext* context = scriptExecutionContext();
1727     if (!context)
1728         return;
1729     DOMTimer::removeById(*context, timeoutId);
1730 }
1731 
<span class="line-modified">1732 ExceptionOr&lt;int&gt; DOMWindow::setInterval(JSC::ExecState&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
1733 {
1734     auto* context = scriptExecutionContext();
1735     if (!context)
1736         return Exception { InvalidAccessError };
1737 
1738     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
1739     if (action-&gt;type() == ScheduledAction::Type::Code) {
1740         if (!context-&gt;contentSecurityPolicy()-&gt;allowEval(&amp;state))
1741             return 0;
1742     }
1743 
1744     action-&gt;addArguments(WTFMove(arguments));
1745 
1746     return DOMTimer::install(*context, WTFMove(action), Seconds::fromMilliseconds(timeout), false);
1747 }
1748 
1749 void DOMWindow::clearInterval(int timeoutId)
1750 {
1751     ScriptExecutionContext* context = scriptExecutionContext();
1752     if (!context)
</pre>
<hr />
<pre>
1763 }
1764 
1765 int DOMWindow::webkitRequestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)
1766 {
1767     static bool firstTime = true;
1768     if (firstTime &amp;&amp; document()) {
1769         document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, &quot;webkitRequestAnimationFrame() is deprecated and will be removed. Please use requestAnimationFrame() instead.&quot;_s);
1770         firstTime = false;
1771     }
1772     return requestAnimationFrame(WTFMove(callback));
1773 }
1774 
1775 void DOMWindow::cancelAnimationFrame(int id)
1776 {
1777     auto* document = this-&gt;document();
1778     if (!document)
1779         return;
1780     document-&gt;cancelAnimationFrame(id);
1781 }
1782 
















1783 void DOMWindow::createImageBitmap(ImageBitmap::Source&amp;&amp; source, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
1784 {
1785     auto* document = this-&gt;document();
1786     if (!document) {
1787         promise.reject(InvalidStateError);
1788         return;
1789     }
1790     ImageBitmap::createPromise(*document, WTFMove(source), WTFMove(options), WTFMove(promise));
1791 }
1792 
1793 void DOMWindow::createImageBitmap(ImageBitmap::Source&amp;&amp; source, int sx, int sy, int sw, int sh, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
1794 {
1795     auto* document = this-&gt;document();
1796     if (!document) {
1797         promise.reject(InvalidStateError);
1798         return;
1799     }
1800     ImageBitmap::createPromise(*document, WTFMove(source), WTFMove(options), sx, sy, sw, sh, WTFMove(promise));
1801 }
1802 
</pre>
<hr />
<pre>
2023 
2024 #endif // ENABLE(DEVICE_ORIENTATION)
2025 
2026 #if PLATFORM(IOS_FAMILY)
2027 
2028 void DOMWindow::incrementScrollEventListenersCount()
2029 {
2030     Document* document = this-&gt;document();
2031     if (++m_scrollEventListenerCount == 1 &amp;&amp; document == &amp;document-&gt;topDocument()) {
2032         Frame* frame = this-&gt;frame();
2033         if (frame &amp;&amp; frame-&gt;page())
2034             frame-&gt;page()-&gt;chrome().client().setNeedsScrollNotifications(*frame, true);
2035     }
2036 }
2037 
2038 void DOMWindow::decrementScrollEventListenersCount()
2039 {
2040     Document* document = this-&gt;document();
2041     if (!--m_scrollEventListenerCount &amp;&amp; document == &amp;document-&gt;topDocument()) {
2042         Frame* frame = this-&gt;frame();
<span class="line-modified">2043         if (frame &amp;&amp; frame-&gt;page() &amp;&amp; document-&gt;pageCacheState() == Document::NotInPageCache)</span>
2044             frame-&gt;page()-&gt;chrome().client().setNeedsScrollNotifications(*frame, false);
2045     }
2046 }
2047 
2048 #endif
2049 
2050 void DOMWindow::resetAllGeolocationPermission()
2051 {
2052     // FIXME: Can we remove the PLATFORM(IOS_FAMILY)-guard?
2053 #if ENABLE(GEOLOCATION) &amp;&amp; PLATFORM(IOS_FAMILY)
2054     if (m_navigator)
2055         NavigatorGeolocation::from(*m_navigator)-&gt;resetAllGeolocationPermission();
2056 #endif
2057 }
2058 
2059 bool DOMWindow::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)
2060 {
2061     if (!EventTarget::removeEventListener(eventType, listener, options.capture))
2062         return false;
2063 
</pre>
<hr />
<pre>
2088         ASSERT(m_touchAndGestureEventListenerCount &gt; 0);
2089         --m_touchAndGestureEventListenerCount;
2090     }
2091 #endif
2092 #if ENABLE(GAMEPAD)
2093     else if (eventNames().isGamepadEventType(eventType))
2094         decrementGamepadEventListenerCount();
2095 #endif
2096 #if ENABLE(DEVICE_ORIENTATION)
2097     else if (eventType == eventNames().deviceorientationEvent)
2098         stopListeningForDeviceOrientationIfNecessary();
2099     else if (eventType == eventNames().devicemotionEvent)
2100         stopListeningForDeviceMotionIfNecessary();
2101 #endif
2102 
2103     return true;
2104 }
2105 
2106 void DOMWindow::languagesChanged()
2107 {
<span class="line-modified">2108     if (auto* document = this-&gt;document())</span>
<span class="line-modified">2109         document-&gt;enqueueWindowEvent(Event::create(eventNames().languagechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>

2110 }
2111 
2112 void DOMWindow::dispatchLoadEvent()
2113 {
2114     // If we did not protect it, the document loader and its timing subobject might get destroyed
2115     // as a side effect of what event handling code does.
2116     auto protectedThis = makeRef(*this);
2117     auto protectedLoader = makeRefPtr(frame() ? frame()-&gt;loader().documentLoader() : nullptr);
2118     bool shouldMarkLoadEventTimes = protectedLoader &amp;&amp; !protectedLoader-&gt;timing().loadEventStart();
2119 
2120     if (shouldMarkLoadEventTimes)
2121         protectedLoader-&gt;timing().markLoadEventStart();
2122 
2123     dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No), document());
2124 
2125     if (shouldMarkLoadEventTimes)
2126         protectedLoader-&gt;timing().markLoadEventEnd();
2127 
2128     // Send a separate load event to the element that owns this frame.
2129     if (frame()) {
</pre>
<hr />
<pre>
2151     // generated, not here inside the event dispatching process.
2152     if (event.eventInterface() == PageTransitionEventInterfaceType) {
2153         if (event.type() == eventNames().pageshowEvent) {
2154             if (m_lastPageStatus == PageStatus::Shown)
2155                 return; // Event was previously dispatched; do not fire a duplicate event.
2156             m_lastPageStatus = PageStatus::Shown;
2157         } else if (event.type() == eventNames().pagehideEvent) {
2158             if (m_lastPageStatus == PageStatus::Hidden)
2159                 return; // Event was previously dispatched; do not fire a duplicate event.
2160             m_lastPageStatus = PageStatus::Hidden;
2161         }
2162     }
2163 
2164     // FIXME: It doesn&#39;t seem right to have the inspector instrumentation here since not all
2165     // events dispatched to the window object are guaranteed to flow through this function.
2166     // But the instrumentation prevents us from calling EventDispatcher::dispatchEvent here.
2167     event.setTarget(target ? target : this);
2168     event.setCurrentTarget(this);
2169     event.setEventPhase(Event::AT_TARGET);
2170     event.resetBeforeDispatch();
<span class="line-modified">2171     auto cookie = InspectorInstrumentation::willDispatchEventOnWindow(frame(), event, *this);</span>









2172     // FIXME: We should use EventDispatcher everywhere.
2173     fireEventListeners(event, EventInvokePhase::Capturing);
2174     fireEventListeners(event, EventInvokePhase::Bubbling);
<span class="line-modified">2175     InspectorInstrumentation::didDispatchEventOnWindow(cookie, event.defaultPrevented());</span>



2176     event.resetAfterDispatch();
2177 }
2178 
2179 void DOMWindow::removeAllEventListeners()
2180 {
2181     EventTarget::removeAllEventListeners();
2182 
2183 #if ENABLE(DEVICE_ORIENTATION)
2184         stopListeningForDeviceOrientationIfNecessary();
2185         stopListeningForDeviceMotionIfNecessary();
2186 #endif
2187 
2188 #if PLATFORM(IOS_FAMILY)
2189     if (m_scrollEventListenerCount) {
2190         m_scrollEventListenerCount = 1;
2191         decrementScrollEventListenersCount();
2192     }
2193 #endif
2194 
2195 #if ENABLE(IOS_TOUCH_EVENTS) || ENABLE(IOS_GESTURE_EVENTS)
</pre>
<hr />
<pre>
2237     Document* activeDocument = activeWindow.document();
2238     if (!activeDocument)
2239         return;
2240 
2241     auto* frame = this-&gt;frame();
2242     if (!activeDocument-&gt;canNavigate(frame, completedURL))
2243         return;
2244 
2245     if (isInsecureScriptAccess(activeWindow, completedURL))
2246         return;
2247 
2248     // We want a new history item if we are processing a user gesture.
2249     LockHistory lockHistory = (locking != LockHistoryBasedOnGestureState || !UserGestureIndicator::processingUserGesture()) ? LockHistory::Yes : LockHistory::No;
2250     LockBackForwardList lockBackForwardList = (locking != LockHistoryBasedOnGestureState) ? LockBackForwardList::Yes : LockBackForwardList::No;
2251     frame-&gt;navigationScheduler().scheduleLocationChange(*activeDocument, activeDocument-&gt;securityOrigin(),
2252         // FIXME: What if activeDocument()-&gt;frame() is 0?
2253         completedURL, activeDocument-&gt;frame()-&gt;loader().outgoingReferrer(),
2254         lockHistory, lockBackForwardList);
2255 }
2256 
<span class="line-modified">2257 void DOMWindow::printErrorMessage(const String&amp; message)</span>
2258 {
2259     if (message.isEmpty())
2260         return;
2261 
2262     if (PageConsoleClient* pageConsole = console())
2263         pageConsole-&gt;addMessage(MessageSource::JS, MessageLevel::Error, message);
2264 }
2265 
2266 String DOMWindow::crossDomainAccessErrorMessage(const DOMWindow&amp; activeWindow, IncludeTargetOrigin includeTargetOrigin)
2267 {
2268     const URL&amp; activeWindowURL = activeWindow.document()-&gt;url();
2269     if (activeWindowURL.isNull())
2270         return String();
2271 
2272     ASSERT(!activeWindow.document()-&gt;securityOrigin().canAccess(document()-&gt;securityOrigin()));
2273 
2274     // FIXME: This message, and other console messages, have extra newlines. Should remove them.
2275     SecurityOrigin&amp; activeOrigin = activeWindow.document()-&gt;securityOrigin();
2276     SecurityOrigin&amp; targetOrigin = document()-&gt;securityOrigin();
2277     String message;
</pre>
<hr />
<pre>
2340 
2341 ExceptionOr&lt;RefPtr&lt;Frame&gt;&gt; DOMWindow::createWindow(const String&amp; urlString, const AtomString&amp; frameName, const WindowFeatures&amp; windowFeatures, DOMWindow&amp; activeWindow, Frame&amp; firstFrame, Frame&amp; openerFrame, const WTF::Function&lt;void(DOMWindow&amp;)&gt;&amp; prepareDialogFunction)
2342 {
2343     Frame* activeFrame = activeWindow.frame();
2344     if (!activeFrame)
2345         return RefPtr&lt;Frame&gt; { nullptr };
2346 
2347     Document* activeDocument = activeWindow.document();
2348     if (!activeDocument)
2349         return RefPtr&lt;Frame&gt; { nullptr };
2350 
2351     URL completedURL = urlString.isEmpty() ? URL({ }, emptyString()) : firstFrame.document()-&gt;completeURL(urlString);
2352     if (!completedURL.isEmpty() &amp;&amp; !completedURL.isValid())
2353         return Exception { SyntaxError };
2354 
2355     // For whatever reason, Firefox uses the first frame to determine the outgoingReferrer. We replicate that behavior here.
2356     String referrer = windowFeatures.noreferrer ? String() : SecurityPolicy::generateReferrerHeader(firstFrame.document()-&gt;referrerPolicy(), completedURL, firstFrame.loader().outgoingReferrer());
2357     auto initiatedByMainFrame = activeFrame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
2358 
2359     ResourceRequest resourceRequest { completedURL, referrer };
<span class="line-removed">2360     FrameLoader::addHTTPOriginIfNeeded(resourceRequest, firstFrame.loader().outgoingOrigin());</span>
2361     FrameLoadRequest frameLoadRequest { *activeDocument, activeDocument-&gt;securityOrigin(), resourceRequest, frameName, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Allow, activeDocument-&gt;shouldOpenExternalURLsPolicyToPropagate(), initiatedByMainFrame };
2362 
2363     // We pass the opener frame for the lookupFrame in case the active frame is different from
2364     // the opener frame, and the name references a frame relative to the opener frame.
2365     bool created;
2366     auto newFrame = WebCore::createWindow(*activeFrame, openerFrame, WTFMove(frameLoadRequest), windowFeatures, created);
2367     if (!newFrame)
2368         return RefPtr&lt;Frame&gt; { nullptr };
2369 
2370     bool noopener = windowFeatures.noopener || windowFeatures.noreferrer;
2371     if (!noopener)
2372         newFrame-&gt;loader().setOpener(&amp;openerFrame);
2373 
2374     if (created)
2375         newFrame-&gt;page()-&gt;setOpenedByDOM();
2376 
2377     if (newFrame-&gt;document()-&gt;domWindow()-&gt;isInsecureScriptAccess(activeWindow, completedURL))
2378         return noopener ? RefPtr&lt;Frame&gt; { nullptr } : newFrame;
2379 
2380     if (prepareDialogFunction)
</pre>
</td>
<td>
<hr />
<pre>
  51 #include &quot;DeviceMotionEvent.h&quot;
  52 #include &quot;DeviceOrientationAndMotionAccessController.h&quot;
  53 #include &quot;DeviceOrientationController.h&quot;
  54 #include &quot;Document.h&quot;
  55 #include &quot;DocumentLoader.h&quot;
  56 #include &quot;Editor.h&quot;
  57 #include &quot;Element.h&quot;
  58 #include &quot;EventHandler.h&quot;
  59 #include &quot;EventListener.h&quot;
  60 #include &quot;EventNames.h&quot;
  61 #include &quot;FloatRect.h&quot;
  62 #include &quot;FocusController.h&quot;
  63 #include &quot;Frame.h&quot;
  64 #include &quot;FrameLoadRequest.h&quot;
  65 #include &quot;FrameLoader.h&quot;
  66 #include &quot;FrameLoaderClient.h&quot;
  67 #include &quot;FrameTree.h&quot;
  68 #include &quot;FrameView.h&quot;
  69 #include &quot;HTTPParsers.h&quot;
  70 #include &quot;History.h&quot;
<span class="line-added">  71 #include &quot;IdleRequestOptions.h&quot;</span>
  72 #include &quot;InspectorInstrumentation.h&quot;
<span class="line-added">  73 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
  74 #include &quot;JSDOMWindowBase.h&quot;
  75 #include &quot;JSExecState.h&quot;
  76 #include &quot;Location.h&quot;
  77 #include &quot;MediaQueryList.h&quot;
  78 #include &quot;MediaQueryMatcher.h&quot;
  79 #include &quot;MessageEvent.h&quot;
  80 #include &quot;MessageWithMessagePorts.h&quot;
  81 #include &quot;NavigationScheduler.h&quot;
  82 #include &quot;Navigator.h&quot;
  83 #include &quot;Page.h&quot;
  84 #include &quot;PageConsoleClient.h&quot;
  85 #include &quot;PageTransitionEvent.h&quot;
  86 #include &quot;Performance.h&quot;
  87 #include &quot;RequestAnimationFrameCallback.h&quot;
  88 #include &quot;ResourceLoadInfo.h&quot;
  89 #include &quot;ResourceLoadObserver.h&quot;
  90 #include &quot;RuntimeApplicationChecks.h&quot;

  91 #include &quot;ScheduledAction.h&quot;
  92 #include &quot;Screen.h&quot;
  93 #include &quot;SecurityOrigin.h&quot;
  94 #include &quot;SecurityOriginData.h&quot;
  95 #include &quot;SecurityPolicy.h&quot;
  96 #include &quot;SelectorQuery.h&quot;
  97 #include &quot;SerializedScriptValue.h&quot;
  98 #include &quot;Settings.h&quot;
  99 #include &quot;StaticNodeList.h&quot;
 100 #include &quot;Storage.h&quot;
 101 #include &quot;StorageArea.h&quot;
 102 #include &quot;StorageNamespace.h&quot;
 103 #include &quot;StorageNamespaceProvider.h&quot;
 104 #include &quot;StyleMedia.h&quot;
 105 #include &quot;StyleResolver.h&quot;
 106 #include &quot;StyleScope.h&quot;
 107 #include &quot;SuddenTermination.h&quot;
 108 #include &lt;wtf/URL.h&gt;
 109 #include &quot;UserGestureIndicator.h&quot;
 110 #include &quot;VisualViewport.h&quot;
</pre>
<hr />
<pre>
 130 #include &quot;UserContentController.h&quot;
 131 #include &quot;UserMessageHandlerDescriptor.h&quot;
 132 #include &quot;WebKitNamespace.h&quot;
 133 #endif
 134 
 135 #if ENABLE(GAMEPAD)
 136 #include &quot;GamepadManager.h&quot;
 137 #endif
 138 
 139 #if ENABLE(GEOLOCATION)
 140 #include &quot;NavigatorGeolocation.h&quot;
 141 #endif
 142 
 143 #if ENABLE(POINTER_LOCK)
 144 #include &quot;PointerLockController.h&quot;
 145 #endif
 146 
 147 namespace WebCore {
 148 using namespace Inspector;
 149 
<span class="line-added"> 150 static const Seconds defaultTransientActivationDuration { 2_s };</span>
<span class="line-added"> 151 </span>
<span class="line-added"> 152 static Optional&lt;Seconds&gt;&amp; transientActivationDurationOverrideForTesting()</span>
<span class="line-added"> 153 {</span>
<span class="line-added"> 154     static NeverDestroyed&lt;Optional&lt;Seconds&gt;&gt; overrideForTesting;</span>
<span class="line-added"> 155     return overrideForTesting;</span>
<span class="line-added"> 156 }</span>
<span class="line-added"> 157 </span>
<span class="line-added"> 158 static Seconds transientActivationDuration()</span>
<span class="line-added"> 159 {</span>
<span class="line-added"> 160     if (auto override = transientActivationDurationOverrideForTesting())</span>
<span class="line-added"> 161         return *override;</span>
<span class="line-added"> 162     return defaultTransientActivationDuration;</span>
<span class="line-added"> 163 }</span>
<span class="line-added"> 164 </span>
 165 WTF_MAKE_ISO_ALLOCATED_IMPL(DOMWindow);
 166 
 167 class PostMessageTimer : public TimerBase {
 168 public:
 169     PostMessageTimer(DOMWindow&amp; window, MessageWithMessagePorts&amp;&amp; message, const String&amp; sourceOrigin, RefPtr&lt;WindowProxy&gt;&amp;&amp; source, RefPtr&lt;SecurityOrigin&gt;&amp;&amp; targetOrigin, RefPtr&lt;ScriptCallStack&gt;&amp;&amp; stackTrace)
 170         : m_window(window)
 171         , m_message(WTFMove(message))
 172         , m_origin(sourceOrigin)
 173         , m_source(source)
 174         , m_targetOrigin(WTFMove(targetOrigin))
 175         , m_stackTrace(stackTrace)
 176         , m_userGestureToForward(UserGestureIndicator::currentUserGesture())
 177     {
 178     }
 179 
 180     Ref&lt;MessageEvent&gt; event(ScriptExecutionContext&amp; context)
 181     {
 182         return MessageEvent::create(MessagePort::entanglePorts(context, WTFMove(m_message.transferredPorts)), m_message.message.releaseNonNull(), m_origin, { }, m_source ? makeOptional(MessageEventSource(WTFMove(m_source))) : WTF::nullopt);
 183     }
 184 
</pre>
<hr />
<pre>
 433     observeContext(&amp;document);
 434 
 435     // The Window is being transferred from one document to another so we need to reset data
 436     // members that store the window&#39;s document (rather than the window itself).
 437     m_crypto = nullptr;
 438     m_navigator = nullptr;
 439     m_performance = nullptr;
 440 }
 441 
 442 void DOMWindow::prewarmLocalStorageIfNecessary()
 443 {
 444     auto* page = this-&gt;page();
 445 
 446     // No need to prewarm for ephemeral sessions since the data is in memory only.
 447     if (!page || page-&gt;usesEphemeralSession())
 448         return;
 449 
 450     if (!page-&gt;mainFrame().mayPrewarmLocalStorage())
 451         return;
 452 
<span class="line-added"> 453     // This eagerly constructs the StorageArea, which will load items from disk.</span>
 454     auto localStorageResult = this-&gt;localStorage();
 455     if (localStorageResult.hasException())
 456         return;
 457 
 458     auto* localStorage = localStorageResult.returnValue();
 459     if (!localStorage)
 460         return;
 461 
 462     page-&gt;mainFrame().didPrewarmLocalStorage();
 463 }
 464 
 465 DOMWindow::~DOMWindow()
 466 {
 467     if (m_suspendedForDocumentSuspension)
 468         willDestroyCachedFrame();
 469     else
 470         willDestroyDocumentInFrame();
 471 
 472     removeAllUnloadEventListeners(this);
 473     removeAllBeforeUnloadEventListeners(this);
</pre>
<hr />
<pre>
 557 
 558 #endif
 559 
 560 void DOMWindow::registerObserver(Observer&amp; observer)
 561 {
 562     m_observers.add(&amp;observer);
 563 }
 564 
 565 void DOMWindow::unregisterObserver(Observer&amp; observer)
 566 {
 567     m_observers.remove(&amp;observer);
 568 }
 569 
 570 void DOMWindow::resetUnlessSuspendedForDocumentSuspension()
 571 {
 572     if (m_suspendedForDocumentSuspension)
 573         return;
 574     willDestroyDocumentInFrame();
 575 }
 576 
<span class="line-modified"> 577 void DOMWindow::suspendForBackForwardCache()</span>
 578 {
 579     SetForScope&lt;bool&gt; isSuspendingObservers(m_isSuspendingObservers, true);
 580     RELEASE_ASSERT(frame());
 581 
 582     for (auto* observer : copyToVector(m_observers)) {
 583         if (m_observers.contains(observer))
<span class="line-modified"> 584             observer-&gt;suspendForBackForwardCache();</span>
 585     }
 586     RELEASE_ASSERT(frame());
 587 
 588     m_suspendedForDocumentSuspension = true;
 589 }
 590 
<span class="line-modified"> 591 void DOMWindow::resumeFromBackForwardCache()</span>
 592 {
 593     for (auto* observer : copyToVector(m_observers)) {
 594         if (m_observers.contains(observer))
<span class="line-modified"> 595             observer-&gt;resumeFromBackForwardCache();</span>
 596     }
 597 
 598     m_suspendedForDocumentSuspension = false;
 599 }
 600 
 601 bool DOMWindow::isCurrentlyDisplayedInFrame() const
 602 {
 603     auto* frame = this-&gt;frame();
 604     return frame &amp;&amp; frame-&gt;document()-&gt;domWindow() == this;
 605 }
 606 
 607 CustomElementRegistry&amp; DOMWindow::ensureCustomElementRegistry()
 608 {
 609     if (!m_customElementRegistry)
 610         m_customElementRegistry = CustomElementRegistry::create(*this, scriptExecutionContext());
 611     return *m_customElementRegistry;
 612 }
 613 
 614 static ExceptionOr&lt;SelectorQuery&amp;&gt; selectorQueryInFrame(Frame* frame, const String&amp; selectors)
 615 {
</pre>
<hr />
<pre>
 871     // after calling window.close(). See &lt;https://bugs.webkit.org/show_bug.cgi?id=135330&gt;.
 872     if (!page || !page-&gt;isClosing()) {
 873         if (m_localStorage)
 874             return m_localStorage.get();
 875     }
 876 
 877     if (!page)
 878         return nullptr;
 879 
 880     if (page-&gt;isClosing())
 881         return nullptr;
 882 
 883     if (!page-&gt;settings().localStorageEnabled())
 884         return nullptr;
 885 
 886     auto storageArea = page-&gt;storageNamespaceProvider().localStorageArea(*document);
 887     m_localStorage = Storage::create(*this, WTFMove(storageArea));
 888     return m_localStorage.get();
 889 }
 890 
<span class="line-modified"> 891 ExceptionOr&lt;void&gt; DOMWindow::postMessage(JSC::JSGlobalObject&amp; lexicalGlobalObject, DOMWindow&amp; incumbentWindow, JSC::JSValue messageValue, WindowPostMessageOptions&amp;&amp; options)</span>
 892 {
 893     if (!isCurrentlyDisplayedInFrame())
 894         return { };
 895 
 896     Document* sourceDocument = incumbentWindow.document();
 897 
 898     // Compute the target origin.  We need to do this synchronously in order
 899     // to generate the SyntaxError exception correctly.
 900     RefPtr&lt;SecurityOrigin&gt; target;
<span class="line-modified"> 901     if (options.targetOrigin == &quot;/&quot;) {</span>
 902         if (!sourceDocument)
 903             return { };
 904         target = &amp;sourceDocument-&gt;securityOrigin();
<span class="line-modified"> 905     } else if (options.targetOrigin != &quot;*&quot;) {</span>
<span class="line-modified"> 906         target = SecurityOrigin::createFromString(options.targetOrigin);</span>
 907         // It doesn&#39;t make sense target a postMessage at a unique origin
 908         // because there&#39;s no way to represent a unique origin in a string.
 909         if (target-&gt;isUnique())
 910             return Exception { SyntaxError };
 911     }
 912 
 913     Vector&lt;RefPtr&lt;MessagePort&gt;&gt; ports;
<span class="line-modified"> 914     auto messageData = SerializedScriptValue::create(lexicalGlobalObject, messageValue, WTFMove(options.transfer), ports, SerializationContext::WindowPostMessage);</span>
 915     if (messageData.hasException())
 916         return messageData.releaseException();
 917 
 918     auto disentangledPorts = MessagePort::disentanglePorts(WTFMove(ports));
 919     if (disentangledPorts.hasException())
 920         return disentangledPorts.releaseException();
 921 
 922     // Capture the source of the message.  We need to do this synchronously
 923     // in order to capture the source of the message correctly.
 924     if (!sourceDocument)
 925         return { };
 926     auto sourceOrigin = sourceDocument-&gt;securityOrigin().toString();
 927 
 928     // Capture stack trace only when inspector front-end is loaded as it may be time consuming.
 929     RefPtr&lt;ScriptCallStack&gt; stackTrace;
 930     if (InspectorInstrumentation::consoleAgentEnabled(sourceDocument))
 931         stackTrace = createScriptCallStack(JSExecState::currentState());
 932 
 933     MessageWithMessagePorts message { messageData.releaseReturnValue(), disentangledPorts.releaseReturnValue() };
 934 
 935     // Schedule the message.
 936     RefPtr&lt;WindowProxy&gt; incumbentWindowProxy = incumbentWindow.frame() ? &amp;incumbentWindow.frame()-&gt;windowProxy() : nullptr;
 937     auto* timer = new PostMessageTimer(*this, WTFMove(message), sourceOrigin, WTFMove(incumbentWindowProxy), WTFMove(target), WTFMove(stackTrace));
 938     timer-&gt;startOneShot(0_s);
 939 
<span class="line-modified"> 940     InspectorInstrumentation::didPostMessage(*frame(), *timer, lexicalGlobalObject);</span>
 941 
 942     return { };
 943 }
 944 
 945 void DOMWindow::postMessageTimerFired(PostMessageTimer&amp; timer)
 946 {
 947     if (!document() || !isCurrentlyDisplayedInFrame())
 948         return;
 949 
 950     Ref&lt;Frame&gt; frame = *this-&gt;frame();
 951     if (auto* intendedTargetOrigin = timer.targetOrigin()) {
 952         // Check target origin now since the target document may have changed since the timer was scheduled.
 953         if (!intendedTargetOrigin-&gt;isSameSchemeHostPort(document()-&gt;securityOrigin())) {
 954             if (auto* pageConsole = console()) {
 955                 String message = makeString(&quot;Unable to post message to &quot;, intendedTargetOrigin-&gt;toString(), &quot;. Recipient has origin &quot;, document()-&gt;securityOrigin().toString(), &quot;.\n&quot;);
 956                 if (timer.stackTrace())
 957                     pageConsole-&gt;addMessage(MessageSource::Security, MessageLevel::Error, message, *timer.stackTrace());
 958                 else
 959                     pageConsole-&gt;addMessage(MessageSource::Security, MessageLevel::Error, message);
 960             }
</pre>
<hr />
<pre>
 984 {
 985     auto* frame = this-&gt;frame();
 986     if (!frame)
 987         return nullptr;
 988 
 989     return frame-&gt;ownerElement();
 990 }
 991 
 992 void DOMWindow::focus(DOMWindow&amp; incumbentWindow)
 993 {
 994     auto* frame = this-&gt;frame();
 995     auto* openerFrame = frame ? frame-&gt;loader().opener() : nullptr;
 996     focus(openerFrame &amp;&amp; openerFrame != frame &amp;&amp; incumbentWindow.frame() == openerFrame);
 997 }
 998 
 999 void DOMWindow::focus(bool allowFocus)
1000 {
1001     if (!frame())
1002         return;
1003 
<span class="line-modified">1004     auto protectedFrame = makeRefPtr(frame());</span>
<span class="line-added">1005 </span>
<span class="line-added">1006     Page* page = protectedFrame-&gt;page();</span>
1007     if (!page)
1008         return;
1009 
<span class="line-modified">1010     allowFocus = allowFocus || WindowFocusAllowedIndicator::windowFocusAllowed() || !protectedFrame-&gt;settings().windowFocusRestricted();</span>
1011 
1012     // If we&#39;re a top level window, bring the window to the front.
<span class="line-modified">1013     if (protectedFrame-&gt;isMainFrame() &amp;&amp; allowFocus)</span>
1014         page-&gt;chrome().focus();
1015 
<span class="line-modified">1016     if (!protectedFrame-&gt;hasHadUserInteraction() &amp;&amp; !isSameSecurityOriginAsMainFrame())</span>



1017         return;
1018 
1019     // Clear the current frame&#39;s focused node if a new frame is about to be focused.
<span class="line-modified">1020     auto focusedFrame = makeRefPtr(page-&gt;focusController().focusedFrame());</span>
<span class="line-modified">1021     if (focusedFrame &amp;&amp; focusedFrame != protectedFrame)</span>
1022         focusedFrame-&gt;document()-&gt;setFocusedElement(nullptr);
1023 
<span class="line-modified">1024     protectedFrame-&gt;eventHandler().focusDocumentView();</span>


1025 }
1026 
1027 void DOMWindow::blur()
1028 {
1029     auto* frame = this-&gt;frame();
1030     if (!frame)
1031         return;
1032 
1033     Page* page = frame-&gt;page();
1034     if (!page)
1035         return;
1036 
1037     if (frame-&gt;settings().windowFocusRestricted())
1038         return;
1039 
1040     if (!frame-&gt;isMainFrame())
1041         return;
1042 
1043     page-&gt;chrome().unfocus();
1044 }
</pre>
<hr />
<pre>
1054 {
1055     auto* frame = this-&gt;frame();
1056     if (!frame)
1057         return;
1058 
1059     Page* page = frame-&gt;page();
1060     if (!page)
1061         return;
1062 
1063     if (!frame-&gt;isMainFrame())
1064         return;
1065 
1066     if (!(page-&gt;openedByDOM() || page-&gt;backForward().count() &lt;= 1)) {
1067         console()-&gt;addMessage(MessageSource::JS, MessageLevel::Warning, &quot;Can&#39;t close the window since it was not opened by JavaScript&quot;_s);
1068         return;
1069     }
1070 
1071     if (!frame-&gt;loader().shouldClose())
1072         return;
1073 
<span class="line-added">1074     ResourceLoadObserver::shared().updateCentralStatisticsStore();</span>
<span class="line-added">1075 </span>
1076     page-&gt;setIsClosing();
1077     page-&gt;chrome().closeWindowSoon();
1078 }
1079 
1080 void DOMWindow::print()
1081 {
1082     auto* frame = this-&gt;frame();
1083     if (!frame)
1084         return;
1085 
1086     auto* page = frame-&gt;page();
1087     if (!page)
1088         return;
1089 
1090     if (!page-&gt;arePromptsAllowed()) {
1091         printErrorMessage(&quot;Use of window.print is not allowed while unloading a page.&quot;);
1092         return;
1093     }
1094 
1095     if (frame-&gt;loader().activeDocumentLoader()-&gt;isLoading()) {
</pre>
<hr />
<pre>
1122         return;
1123     }
1124 
1125     auto* page = frame-&gt;page();
1126     if (!page)
1127         return;
1128 
1129     if (!page-&gt;arePromptsAllowed()) {
1130         printErrorMessage(&quot;Use of window.alert is not allowed while unloading a page.&quot;);
1131         return;
1132     }
1133 
1134     frame-&gt;document()-&gt;updateStyleIfNeeded();
1135 #if ENABLE(POINTER_LOCK)
1136     page-&gt;pointerLockController().requestPointerUnlock();
1137 #endif
1138 
1139     page-&gt;chrome().runJavaScriptAlert(*frame, message);
1140 }
1141 
<span class="line-modified">1142 bool DOMWindow::confirmForBindings(const String&amp; message)</span>
1143 {
1144     auto* frame = this-&gt;frame();
1145     if (!frame)
1146         return false;
1147 
1148     if (document()-&gt;isSandboxed(SandboxModals)) {
1149         printErrorMessage(&quot;Use of window.confirm is not allowed in a sandboxed frame when the allow-modals flag is not set.&quot;);
1150         return false;
1151     }
1152 
1153     auto* page = frame-&gt;page();
1154     if (!page)
1155         return false;
1156 
1157     if (!page-&gt;arePromptsAllowed()) {
1158         printErrorMessage(&quot;Use of window.confirm is not allowed while unloading a page.&quot;);
1159         return false;
1160     }
1161 
1162     frame-&gt;document()-&gt;updateStyleIfNeeded();
</pre>
<hr />
<pre>
1487     if (parentFrame)
1488         return &amp;parentFrame-&gt;windowProxy();
1489 
1490     return &amp;frame-&gt;windowProxy();
1491 }
1492 
1493 WindowProxy* DOMWindow::top() const
1494 {
1495     auto* frame = this-&gt;frame();
1496     if (!frame)
1497         return nullptr;
1498 
1499     if (!frame-&gt;page())
1500         return nullptr;
1501 
1502     return &amp;frame-&gt;tree().top().windowProxy();
1503 }
1504 
1505 String DOMWindow::origin() const
1506 {
<span class="line-modified">1507     auto* document = this-&gt;document();</span>
1508     return document ? document-&gt;securityOrigin().toString() : emptyString();
1509 }
1510 
<span class="line-added">1511 SecurityOrigin* DOMWindow::securityOrigin() const</span>
<span class="line-added">1512 {</span>
<span class="line-added">1513     auto* document = this-&gt;document();</span>
<span class="line-added">1514     return document ? &amp;document-&gt;securityOrigin() : nullptr;</span>
<span class="line-added">1515 }</span>
<span class="line-added">1516 </span>
1517 Document* DOMWindow::document() const
1518 {
1519     return downcast&lt;Document&gt;(ContextDestructionObserver::scriptExecutionContext());
1520 }
1521 
<span class="line-added">1522 void DOMWindow::overrideTransientActivationDurationForTesting(Optional&lt;Seconds&gt;&amp;&amp; override)</span>
<span class="line-added">1523 {</span>
<span class="line-added">1524     transientActivationDurationOverrideForTesting() = WTFMove(override);</span>
<span class="line-added">1525 }</span>
<span class="line-added">1526 </span>
<span class="line-added">1527 // When the current high resolution time is greater than or equal to the last activation timestamp in W, and</span>
<span class="line-added">1528 // less than the last activation timestamp in W plus the transient activation duration, then W is said to</span>
<span class="line-added">1529 // have transient activation. (https://html.spec.whatwg.org/multipage/interaction.html#transient-activation)</span>
<span class="line-added">1530 bool DOMWindow::hasTransientActivation() const</span>
<span class="line-added">1531 {</span>
<span class="line-added">1532     auto now = MonotonicTime::now();</span>
<span class="line-added">1533     return now &gt;= m_lastActivationTimestamp &amp;&amp; now &lt; (m_lastActivationTimestamp + transientActivationDuration());</span>
<span class="line-added">1534 }</span>
<span class="line-added">1535 </span>
<span class="line-added">1536 // https://html.spec.whatwg.org/multipage/interaction.html#consume-user-activation</span>
<span class="line-added">1537 bool DOMWindow::consumeTransientActivation()</span>
<span class="line-added">1538 {</span>
<span class="line-added">1539     if (!hasTransientActivation())</span>
<span class="line-added">1540         return false;</span>
<span class="line-added">1541 </span>
<span class="line-added">1542     for (Frame* frame = this-&gt;frame() ? &amp;this-&gt;frame()-&gt;tree().top() : nullptr; frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-added">1543         auto* window = frame-&gt;window();</span>
<span class="line-added">1544         if (!window || window-&gt;lastActivationTimestamp() != MonotonicTime::infinity())</span>
<span class="line-added">1545             window-&gt;setLastActivationTimestamp(-MonotonicTime::infinity());</span>
<span class="line-added">1546     }</span>
<span class="line-added">1547 </span>
<span class="line-added">1548     return true;</span>
<span class="line-added">1549 }</span>
<span class="line-added">1550 </span>
<span class="line-added">1551 // https://html.spec.whatwg.org/multipage/interaction.html#activation-notification</span>
<span class="line-added">1552 void DOMWindow::notifyActivated(MonotonicTime activationTime)</span>
<span class="line-added">1553 {</span>
<span class="line-added">1554     setLastActivationTimestamp(activationTime);</span>
<span class="line-added">1555     if (!frame())</span>
<span class="line-added">1556         return;</span>
<span class="line-added">1557 </span>
<span class="line-added">1558     for (Frame* ancestor = frame() ? frame()-&gt;tree().parent() : nullptr; ancestor; ancestor = ancestor-&gt;tree().parent()) {</span>
<span class="line-added">1559         if (auto* window = ancestor-&gt;window())</span>
<span class="line-added">1560             window-&gt;setLastActivationTimestamp(activationTime);</span>
<span class="line-added">1561     }</span>
<span class="line-added">1562 </span>
<span class="line-added">1563     auto* securityOrigin = this-&gt;securityOrigin();</span>
<span class="line-added">1564     if (!securityOrigin)</span>
<span class="line-added">1565         return;</span>
<span class="line-added">1566 </span>
<span class="line-added">1567     auto* descendant = frame();</span>
<span class="line-added">1568     while ((descendant = descendant-&gt;tree().traverseNext(frame()))) {</span>
<span class="line-added">1569         auto* descendantWindow = descendant-&gt;window();</span>
<span class="line-added">1570         if (!descendantWindow)</span>
<span class="line-added">1571             continue;</span>
<span class="line-added">1572 </span>
<span class="line-added">1573         auto* descendantSecurityOrigin = descendantWindow-&gt;securityOrigin();</span>
<span class="line-added">1574         if (!descendantSecurityOrigin || !descendantSecurityOrigin-&gt;isSameOriginAs(*securityOrigin))</span>
<span class="line-added">1575             continue;</span>
<span class="line-added">1576 </span>
<span class="line-added">1577         descendantWindow-&gt;setLastActivationTimestamp(activationTime);</span>
<span class="line-added">1578     }</span>
<span class="line-added">1579 }</span>
<span class="line-added">1580 </span>
1581 StyleMedia&amp; DOMWindow::styleMedia()
1582 {
1583     if (!m_media)
1584         m_media = StyleMedia::create(*this);
1585     return *m_media;
1586 }
1587 
1588 Ref&lt;CSSStyleDeclaration&gt; DOMWindow::getComputedStyle(Element&amp; element, const String&amp; pseudoElt) const
1589 {
1590     return CSSComputedStyleDeclaration::create(element, false, pseudoElt);
1591 }
1592 
1593 RefPtr&lt;CSSRuleList&gt; DOMWindow::getMatchedCSSRules(Element* element, const String&amp; pseudoElement, bool authorOnly) const
1594 {
1595     if (!isCurrentlyDisplayedInFrame())
1596         return nullptr;
1597 
1598     unsigned colonStart = pseudoElement[0] == &#39;:&#39; ? (pseudoElement[1] == &#39;:&#39; ? 2 : 1) : 0;
1599     auto pseudoType = CSSSelector::parsePseudoElementType(StringView { pseudoElement }.substring(colonStart));
1600     if (pseudoType == CSSSelector::PseudoElementUnknown &amp;&amp; !pseudoElement.isEmpty())
1601         return nullptr;
1602 
1603     auto* frame = this-&gt;frame();
1604     frame-&gt;document()-&gt;styleScope().flushPendingUpdate();
1605 
<span class="line-modified">1606     unsigned rulesToInclude = Style::Resolver::AuthorCSSRules;</span>
1607     if (!authorOnly)
<span class="line-modified">1608         rulesToInclude |= Style::Resolver::UAAndUserCSSRules;</span>
1609 
1610     PseudoId pseudoId = CSSSelector::pseudoId(pseudoType);
1611 
1612     auto matchedRules = frame-&gt;document()-&gt;styleScope().resolver().pseudoStyleRulesForElement(element, pseudoId, rulesToInclude);
1613     if (matchedRules.isEmpty())
1614         return nullptr;
1615 
1616     bool allowCrossOrigin = frame-&gt;settings().crossOriginCheckInGetMatchedCSSRulesDisabled();
1617 
1618     auto ruleList = StaticCSSRuleList::create();
1619     for (auto&amp; rule : matchedRules) {
1620         if (!allowCrossOrigin &amp;&amp; !rule-&gt;hasDocumentSecurityOrigin())
1621             continue;
1622         ruleList-&gt;rules().append(rule-&gt;createCSSOMWrapper());
1623     }
1624 
1625     if (ruleList-&gt;rules().isEmpty())
1626         return nullptr;
1627 
1628     return ruleList;
</pre>
<hr />
<pre>
1666 
1667     Page* page = frame-&gt;page();
1668     if (!page)
1669         return 0.0;
1670 
1671     return page-&gt;deviceScaleFactor();
1672 }
1673 
1674 void DOMWindow::scrollBy(double x, double y) const
1675 {
1676     scrollBy({ x, y });
1677 }
1678 
1679 void DOMWindow::scrollBy(const ScrollToOptions&amp; options) const
1680 {
1681     if (!isCurrentlyDisplayedInFrame())
1682         return;
1683 
1684     document()-&gt;updateLayoutIgnorePendingStylesheets();
1685 
<span class="line-modified">1686     auto* frame = this-&gt;frame();</span>
<span class="line-added">1687     if (!frame)</span>
<span class="line-added">1688         return;</span>
<span class="line-added">1689 </span>
<span class="line-added">1690     auto view = makeRefPtr(frame-&gt;view());</span>
1691     if (!view)
1692         return;
1693 
1694     ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options, 0, 0);
1695     scrollToOptions.left.value() += view-&gt;mapFromLayoutToCSSUnits(view-&gt;contentsScrollPosition().x());
1696     scrollToOptions.top.value() += view-&gt;mapFromLayoutToCSSUnits(view-&gt;contentsScrollPosition().y());
1697     scrollTo(scrollToOptions);
1698 }
1699 
1700 void DOMWindow::scrollTo(double x, double y, ScrollClamping clamping) const
1701 {
1702     scrollTo({ x, y }, clamping);
1703 }
1704 
<span class="line-modified">1705 void DOMWindow::scrollTo(const ScrollToOptions&amp; options, ScrollClamping clamping) const</span>
1706 {
1707     if (!isCurrentlyDisplayedInFrame())
1708         return;
1709 
1710     RefPtr&lt;FrameView&gt; view = frame()-&gt;view();
1711     if (!view)
1712         return;
1713 
1714     ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options,
1715         view-&gt;contentsScrollPosition().x(), view-&gt;contentsScrollPosition().y()
1716     );
1717 
1718     if (!scrollToOptions.left.value() &amp;&amp; !scrollToOptions.top.value() &amp;&amp; view-&gt;contentsScrollPosition() == IntPoint(0, 0))
1719         return;
1720 
1721     document()-&gt;updateLayoutIgnorePendingStylesheets();
1722 
1723     IntPoint layoutPos(view-&gt;mapFromCSSToLayoutUnits(scrollToOptions.left.value()), view-&gt;mapFromCSSToLayoutUnits(scrollToOptions.top.value()));
<span class="line-modified">1724     view-&gt;setContentsScrollPosition(layoutPos, clamping);</span>
1725 }
1726 
1727 bool DOMWindow::allowedToChangeWindowGeometry() const
1728 {
1729     auto* frame = this-&gt;frame();
1730     if (!frame)
1731         return false;
1732     if (!frame-&gt;page())
1733         return false;
1734     if (!frame-&gt;isMainFrame())
1735         return false;
1736     // Prevent web content from tricking the user into initiating a drag.
1737     if (frame-&gt;eventHandler().mousePressed())
1738         return false;
1739     return true;
1740 }
1741 
1742 void DOMWindow::moveBy(float x, float y) const
1743 {
1744     if (!allowedToChangeWindowGeometry())
</pre>
<hr />
<pre>
1772 
1773     auto* page = frame()-&gt;page();
1774     FloatRect fr = page-&gt;chrome().windowRect();
1775     FloatSize dest = fr.size() + FloatSize(x, y);
1776     FloatRect update(fr.location(), dest);
1777     page-&gt;chrome().setWindowRect(adjustWindowRect(*page, update));
1778 }
1779 
1780 void DOMWindow::resizeTo(float width, float height) const
1781 {
1782     if (!allowedToChangeWindowGeometry())
1783         return;
1784 
1785     auto* page = frame()-&gt;page();
1786     FloatRect fr = page-&gt;chrome().windowRect();
1787     FloatSize dest = FloatSize(width, height);
1788     FloatRect update(fr.location(), dest);
1789     page-&gt;chrome().setWindowRect(adjustWindowRect(*page, update));
1790 }
1791 
<span class="line-modified">1792 ExceptionOr&lt;int&gt; DOMWindow::setTimeout(JSC::JSGlobalObject&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
1793 {
1794     auto* context = scriptExecutionContext();
1795     if (!context)
1796         return Exception { InvalidAccessError };
1797 
1798     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
1799     if (action-&gt;type() == ScheduledAction::Type::Code) {
1800         if (!context-&gt;contentSecurityPolicy()-&gt;allowEval(&amp;state))
1801             return 0;
1802     }
1803 
1804     action-&gt;addArguments(WTFMove(arguments));
1805 
1806     return DOMTimer::install(*context, WTFMove(action), Seconds::fromMilliseconds(timeout), true);
1807 }
1808 
1809 void DOMWindow::clearTimeout(int timeoutId)
1810 {
1811     ScriptExecutionContext* context = scriptExecutionContext();
1812     if (!context)
1813         return;
1814     DOMTimer::removeById(*context, timeoutId);
1815 }
1816 
<span class="line-modified">1817 ExceptionOr&lt;int&gt; DOMWindow::setInterval(JSC::JSGlobalObject&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
1818 {
1819     auto* context = scriptExecutionContext();
1820     if (!context)
1821         return Exception { InvalidAccessError };
1822 
1823     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
1824     if (action-&gt;type() == ScheduledAction::Type::Code) {
1825         if (!context-&gt;contentSecurityPolicy()-&gt;allowEval(&amp;state))
1826             return 0;
1827     }
1828 
1829     action-&gt;addArguments(WTFMove(arguments));
1830 
1831     return DOMTimer::install(*context, WTFMove(action), Seconds::fromMilliseconds(timeout), false);
1832 }
1833 
1834 void DOMWindow::clearInterval(int timeoutId)
1835 {
1836     ScriptExecutionContext* context = scriptExecutionContext();
1837     if (!context)
</pre>
<hr />
<pre>
1848 }
1849 
1850 int DOMWindow::webkitRequestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)
1851 {
1852     static bool firstTime = true;
1853     if (firstTime &amp;&amp; document()) {
1854         document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, &quot;webkitRequestAnimationFrame() is deprecated and will be removed. Please use requestAnimationFrame() instead.&quot;_s);
1855         firstTime = false;
1856     }
1857     return requestAnimationFrame(WTFMove(callback));
1858 }
1859 
1860 void DOMWindow::cancelAnimationFrame(int id)
1861 {
1862     auto* document = this-&gt;document();
1863     if (!document)
1864         return;
1865     document-&gt;cancelAnimationFrame(id);
1866 }
1867 
<span class="line-added">1868 int DOMWindow::requestIdleCallback(Ref&lt;IdleRequestCallback&gt;&amp;&amp; callback, const IdleRequestOptions&amp; options)</span>
<span class="line-added">1869 {</span>
<span class="line-added">1870     auto document = makeRefPtr(this-&gt;document());</span>
<span class="line-added">1871     if (!document)</span>
<span class="line-added">1872         return 0;</span>
<span class="line-added">1873     return document-&gt;requestIdleCallback(WTFMove(callback), Seconds::fromMilliseconds(options.timeout));</span>
<span class="line-added">1874 }</span>
<span class="line-added">1875 </span>
<span class="line-added">1876 void DOMWindow::cancelIdleCallback(int id)</span>
<span class="line-added">1877 {</span>
<span class="line-added">1878     auto document = makeRefPtr(this-&gt;document());</span>
<span class="line-added">1879     if (!document)</span>
<span class="line-added">1880         return;</span>
<span class="line-added">1881     return document-&gt;cancelIdleCallback(id);</span>
<span class="line-added">1882 }</span>
<span class="line-added">1883 </span>
1884 void DOMWindow::createImageBitmap(ImageBitmap::Source&amp;&amp; source, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
1885 {
1886     auto* document = this-&gt;document();
1887     if (!document) {
1888         promise.reject(InvalidStateError);
1889         return;
1890     }
1891     ImageBitmap::createPromise(*document, WTFMove(source), WTFMove(options), WTFMove(promise));
1892 }
1893 
1894 void DOMWindow::createImageBitmap(ImageBitmap::Source&amp;&amp; source, int sx, int sy, int sw, int sh, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
1895 {
1896     auto* document = this-&gt;document();
1897     if (!document) {
1898         promise.reject(InvalidStateError);
1899         return;
1900     }
1901     ImageBitmap::createPromise(*document, WTFMove(source), WTFMove(options), sx, sy, sw, sh, WTFMove(promise));
1902 }
1903 
</pre>
<hr />
<pre>
2124 
2125 #endif // ENABLE(DEVICE_ORIENTATION)
2126 
2127 #if PLATFORM(IOS_FAMILY)
2128 
2129 void DOMWindow::incrementScrollEventListenersCount()
2130 {
2131     Document* document = this-&gt;document();
2132     if (++m_scrollEventListenerCount == 1 &amp;&amp; document == &amp;document-&gt;topDocument()) {
2133         Frame* frame = this-&gt;frame();
2134         if (frame &amp;&amp; frame-&gt;page())
2135             frame-&gt;page()-&gt;chrome().client().setNeedsScrollNotifications(*frame, true);
2136     }
2137 }
2138 
2139 void DOMWindow::decrementScrollEventListenersCount()
2140 {
2141     Document* document = this-&gt;document();
2142     if (!--m_scrollEventListenerCount &amp;&amp; document == &amp;document-&gt;topDocument()) {
2143         Frame* frame = this-&gt;frame();
<span class="line-modified">2144         if (frame &amp;&amp; frame-&gt;page() &amp;&amp; document-&gt;backForwardCacheState() == Document::NotInBackForwardCache)</span>
2145             frame-&gt;page()-&gt;chrome().client().setNeedsScrollNotifications(*frame, false);
2146     }
2147 }
2148 
2149 #endif
2150 
2151 void DOMWindow::resetAllGeolocationPermission()
2152 {
2153     // FIXME: Can we remove the PLATFORM(IOS_FAMILY)-guard?
2154 #if ENABLE(GEOLOCATION) &amp;&amp; PLATFORM(IOS_FAMILY)
2155     if (m_navigator)
2156         NavigatorGeolocation::from(*m_navigator)-&gt;resetAllGeolocationPermission();
2157 #endif
2158 }
2159 
2160 bool DOMWindow::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)
2161 {
2162     if (!EventTarget::removeEventListener(eventType, listener, options.capture))
2163         return false;
2164 
</pre>
<hr />
<pre>
2189         ASSERT(m_touchAndGestureEventListenerCount &gt; 0);
2190         --m_touchAndGestureEventListenerCount;
2191     }
2192 #endif
2193 #if ENABLE(GAMEPAD)
2194     else if (eventNames().isGamepadEventType(eventType))
2195         decrementGamepadEventListenerCount();
2196 #endif
2197 #if ENABLE(DEVICE_ORIENTATION)
2198     else if (eventType == eventNames().deviceorientationEvent)
2199         stopListeningForDeviceOrientationIfNecessary();
2200     else if (eventType == eventNames().devicemotionEvent)
2201         stopListeningForDeviceMotionIfNecessary();
2202 #endif
2203 
2204     return true;
2205 }
2206 
2207 void DOMWindow::languagesChanged()
2208 {
<span class="line-modified">2209     // https://html.spec.whatwg.org/multipage/system-state.html#dom-navigator-languages</span>
<span class="line-modified">2210     if (auto document = makeRefPtr(this-&gt;document()))</span>
<span class="line-added">2211         document-&gt;queueTaskToDispatchEventOnWindow(TaskSource::DOMManipulation, Event::create(eventNames().languagechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
2212 }
2213 
2214 void DOMWindow::dispatchLoadEvent()
2215 {
2216     // If we did not protect it, the document loader and its timing subobject might get destroyed
2217     // as a side effect of what event handling code does.
2218     auto protectedThis = makeRef(*this);
2219     auto protectedLoader = makeRefPtr(frame() ? frame()-&gt;loader().documentLoader() : nullptr);
2220     bool shouldMarkLoadEventTimes = protectedLoader &amp;&amp; !protectedLoader-&gt;timing().loadEventStart();
2221 
2222     if (shouldMarkLoadEventTimes)
2223         protectedLoader-&gt;timing().markLoadEventStart();
2224 
2225     dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No), document());
2226 
2227     if (shouldMarkLoadEventTimes)
2228         protectedLoader-&gt;timing().markLoadEventEnd();
2229 
2230     // Send a separate load event to the element that owns this frame.
2231     if (frame()) {
</pre>
<hr />
<pre>
2253     // generated, not here inside the event dispatching process.
2254     if (event.eventInterface() == PageTransitionEventInterfaceType) {
2255         if (event.type() == eventNames().pageshowEvent) {
2256             if (m_lastPageStatus == PageStatus::Shown)
2257                 return; // Event was previously dispatched; do not fire a duplicate event.
2258             m_lastPageStatus = PageStatus::Shown;
2259         } else if (event.type() == eventNames().pagehideEvent) {
2260             if (m_lastPageStatus == PageStatus::Hidden)
2261                 return; // Event was previously dispatched; do not fire a duplicate event.
2262             m_lastPageStatus = PageStatus::Hidden;
2263         }
2264     }
2265 
2266     // FIXME: It doesn&#39;t seem right to have the inspector instrumentation here since not all
2267     // events dispatched to the window object are guaranteed to flow through this function.
2268     // But the instrumentation prevents us from calling EventDispatcher::dispatchEvent here.
2269     event.setTarget(target ? target : this);
2270     event.setCurrentTarget(this);
2271     event.setEventPhase(Event::AT_TARGET);
2272     event.resetBeforeDispatch();
<span class="line-modified">2273 </span>
<span class="line-added">2274     Frame* protectedFrame = nullptr;</span>
<span class="line-added">2275     bool hasListenersForEvent = false;</span>
<span class="line-added">2276     if (UNLIKELY(InspectorInstrumentation::hasFrontends())) {</span>
<span class="line-added">2277         protectedFrame = frame();</span>
<span class="line-added">2278         hasListenersForEvent = hasEventListeners(event.type());</span>
<span class="line-added">2279         if (hasListenersForEvent)</span>
<span class="line-added">2280             InspectorInstrumentation::willDispatchEventOnWindow(protectedFrame, event, *this);</span>
<span class="line-added">2281     }</span>
<span class="line-added">2282 </span>
2283     // FIXME: We should use EventDispatcher everywhere.
2284     fireEventListeners(event, EventInvokePhase::Capturing);
2285     fireEventListeners(event, EventInvokePhase::Bubbling);
<span class="line-modified">2286 </span>
<span class="line-added">2287     if (hasListenersForEvent)</span>
<span class="line-added">2288         InspectorInstrumentation::didDispatchEventOnWindow(protectedFrame, event);</span>
<span class="line-added">2289 </span>
2290     event.resetAfterDispatch();
2291 }
2292 
2293 void DOMWindow::removeAllEventListeners()
2294 {
2295     EventTarget::removeAllEventListeners();
2296 
2297 #if ENABLE(DEVICE_ORIENTATION)
2298         stopListeningForDeviceOrientationIfNecessary();
2299         stopListeningForDeviceMotionIfNecessary();
2300 #endif
2301 
2302 #if PLATFORM(IOS_FAMILY)
2303     if (m_scrollEventListenerCount) {
2304         m_scrollEventListenerCount = 1;
2305         decrementScrollEventListenersCount();
2306     }
2307 #endif
2308 
2309 #if ENABLE(IOS_TOUCH_EVENTS) || ENABLE(IOS_GESTURE_EVENTS)
</pre>
<hr />
<pre>
2351     Document* activeDocument = activeWindow.document();
2352     if (!activeDocument)
2353         return;
2354 
2355     auto* frame = this-&gt;frame();
2356     if (!activeDocument-&gt;canNavigate(frame, completedURL))
2357         return;
2358 
2359     if (isInsecureScriptAccess(activeWindow, completedURL))
2360         return;
2361 
2362     // We want a new history item if we are processing a user gesture.
2363     LockHistory lockHistory = (locking != LockHistoryBasedOnGestureState || !UserGestureIndicator::processingUserGesture()) ? LockHistory::Yes : LockHistory::No;
2364     LockBackForwardList lockBackForwardList = (locking != LockHistoryBasedOnGestureState) ? LockBackForwardList::Yes : LockBackForwardList::No;
2365     frame-&gt;navigationScheduler().scheduleLocationChange(*activeDocument, activeDocument-&gt;securityOrigin(),
2366         // FIXME: What if activeDocument()-&gt;frame() is 0?
2367         completedURL, activeDocument-&gt;frame()-&gt;loader().outgoingReferrer(),
2368         lockHistory, lockBackForwardList);
2369 }
2370 
<span class="line-modified">2371 void DOMWindow::printErrorMessage(const String&amp; message) const</span>
2372 {
2373     if (message.isEmpty())
2374         return;
2375 
2376     if (PageConsoleClient* pageConsole = console())
2377         pageConsole-&gt;addMessage(MessageSource::JS, MessageLevel::Error, message);
2378 }
2379 
2380 String DOMWindow::crossDomainAccessErrorMessage(const DOMWindow&amp; activeWindow, IncludeTargetOrigin includeTargetOrigin)
2381 {
2382     const URL&amp; activeWindowURL = activeWindow.document()-&gt;url();
2383     if (activeWindowURL.isNull())
2384         return String();
2385 
2386     ASSERT(!activeWindow.document()-&gt;securityOrigin().canAccess(document()-&gt;securityOrigin()));
2387 
2388     // FIXME: This message, and other console messages, have extra newlines. Should remove them.
2389     SecurityOrigin&amp; activeOrigin = activeWindow.document()-&gt;securityOrigin();
2390     SecurityOrigin&amp; targetOrigin = document()-&gt;securityOrigin();
2391     String message;
</pre>
<hr />
<pre>
2454 
2455 ExceptionOr&lt;RefPtr&lt;Frame&gt;&gt; DOMWindow::createWindow(const String&amp; urlString, const AtomString&amp; frameName, const WindowFeatures&amp; windowFeatures, DOMWindow&amp; activeWindow, Frame&amp; firstFrame, Frame&amp; openerFrame, const WTF::Function&lt;void(DOMWindow&amp;)&gt;&amp; prepareDialogFunction)
2456 {
2457     Frame* activeFrame = activeWindow.frame();
2458     if (!activeFrame)
2459         return RefPtr&lt;Frame&gt; { nullptr };
2460 
2461     Document* activeDocument = activeWindow.document();
2462     if (!activeDocument)
2463         return RefPtr&lt;Frame&gt; { nullptr };
2464 
2465     URL completedURL = urlString.isEmpty() ? URL({ }, emptyString()) : firstFrame.document()-&gt;completeURL(urlString);
2466     if (!completedURL.isEmpty() &amp;&amp; !completedURL.isValid())
2467         return Exception { SyntaxError };
2468 
2469     // For whatever reason, Firefox uses the first frame to determine the outgoingReferrer. We replicate that behavior here.
2470     String referrer = windowFeatures.noreferrer ? String() : SecurityPolicy::generateReferrerHeader(firstFrame.document()-&gt;referrerPolicy(), completedURL, firstFrame.loader().outgoingReferrer());
2471     auto initiatedByMainFrame = activeFrame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
2472 
2473     ResourceRequest resourceRequest { completedURL, referrer };

2474     FrameLoadRequest frameLoadRequest { *activeDocument, activeDocument-&gt;securityOrigin(), resourceRequest, frameName, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Allow, activeDocument-&gt;shouldOpenExternalURLsPolicyToPropagate(), initiatedByMainFrame };
2475 
2476     // We pass the opener frame for the lookupFrame in case the active frame is different from
2477     // the opener frame, and the name references a frame relative to the opener frame.
2478     bool created;
2479     auto newFrame = WebCore::createWindow(*activeFrame, openerFrame, WTFMove(frameLoadRequest), windowFeatures, created);
2480     if (!newFrame)
2481         return RefPtr&lt;Frame&gt; { nullptr };
2482 
2483     bool noopener = windowFeatures.noopener || windowFeatures.noreferrer;
2484     if (!noopener)
2485         newFrame-&gt;loader().setOpener(&amp;openerFrame);
2486 
2487     if (created)
2488         newFrame-&gt;page()-&gt;setOpenedByDOM();
2489 
2490     if (newFrame-&gt;document()-&gt;domWindow()-&gt;isInsecureScriptAccess(activeWindow, completedURL))
2491         return noopener ? RefPtr&lt;Frame&gt; { nullptr } : newFrame;
2492 
2493     if (prepareDialogFunction)
</pre>
</td>
</tr>
</table>
<center><a href="DOMTimer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DOMWindow.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
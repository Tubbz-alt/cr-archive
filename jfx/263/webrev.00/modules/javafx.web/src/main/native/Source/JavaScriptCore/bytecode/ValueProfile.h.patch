diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/ValueProfile.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/ValueProfile.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/ValueProfile.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/ValueProfile.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2011-2013, 2016 Apple Inc. All rights reserved.
+ * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
@@ -36,14 +36,14 @@
 
 namespace JSC {
 
 template<unsigned numberOfBucketsArgument>
 struct ValueProfileBase {
-    static const unsigned numberOfBuckets = numberOfBucketsArgument;
-    static const unsigned numberOfSpecFailBuckets = 1;
-    static const unsigned bucketIndexMask = numberOfBuckets - 1;
-    static const unsigned totalNumberOfBuckets = numberOfBuckets + numberOfSpecFailBuckets;
+    static constexpr unsigned numberOfBuckets = numberOfBucketsArgument;
+    static constexpr unsigned numberOfSpecFailBuckets = 1;
+    static constexpr unsigned bucketIndexMask = numberOfBuckets - 1;
+    static constexpr unsigned totalNumberOfBuckets = numberOfBuckets + numberOfSpecFailBuckets;
 
     ValueProfileBase()
     {
         for (unsigned i = 0; i < totalNumberOfBuckets; ++i)
             m_buckets[i] = JSValue::encode(JSValue());
@@ -144,11 +144,11 @@
     MinimalValueProfile(): ValueProfileBase<0>() { }
 };
 
 template<unsigned logNumberOfBucketsArgument>
 struct ValueProfileWithLogNumberOfBuckets : public ValueProfileBase<1 << logNumberOfBucketsArgument> {
-    static const unsigned logNumberOfBuckets = logNumberOfBucketsArgument;
+    static constexpr unsigned logNumberOfBuckets = logNumberOfBucketsArgument;
 
     ValueProfileWithLogNumberOfBuckets()
         : ValueProfileBase<1 << logNumberOfBucketsArgument>()
     {
     }
@@ -159,56 +159,56 @@
 };
 
 // This is a mini value profile to catch pathologies. It is a counter that gets
 // incremented when we take the slow path on any instruction.
 struct RareCaseProfile {
-    RareCaseProfile(int bytecodeOffset)
-        : m_bytecodeOffset(bytecodeOffset)
-        , m_counter(0)
+    RareCaseProfile(BytecodeIndex bytecodeIndex)
+        : m_bytecodeIndex(bytecodeIndex)
     {
     }
+    RareCaseProfile() = default;
 
-    int m_bytecodeOffset;
-    uint32_t m_counter;
+    BytecodeIndex m_bytecodeIndex { };
+    uint32_t m_counter { 0 };
 };
 
-inline int getRareCaseProfileBytecodeOffset(RareCaseProfile* rareCaseProfile)
+inline BytecodeIndex getRareCaseProfileBytecodeIndex(RareCaseProfile* rareCaseProfile)
 {
-    return rareCaseProfile->m_bytecodeOffset;
+    return rareCaseProfile->m_bytecodeIndex;
 }
 
-struct ValueProfileAndOperand : public ValueProfile {
-    int m_operand;
+struct ValueProfileAndVirtualRegister : public ValueProfile {
+    VirtualRegister m_operand;
 };
 
-struct ValueProfileAndOperandBuffer {
+struct ValueProfileAndVirtualRegisterBuffer {
     WTF_MAKE_STRUCT_FAST_ALLOCATED;
 
-    ValueProfileAndOperandBuffer(unsigned size)
+    ValueProfileAndVirtualRegisterBuffer(unsigned size)
         : m_size(size)
     {
         // FIXME: ValueProfile has more stuff than we need. We could optimize these value profiles
         // to be more space efficient.
         // https://bugs.webkit.org/show_bug.cgi?id=175413
-        m_buffer = MallocPtr<ValueProfileAndOperand>::malloc(m_size * sizeof(ValueProfileAndOperand));
+        m_buffer = MallocPtr<ValueProfileAndVirtualRegister, VMMalloc>::malloc(m_size * sizeof(ValueProfileAndVirtualRegister));
         for (unsigned i = 0; i < m_size; ++i)
-            new (&m_buffer.get()[i]) ValueProfileAndOperand();
+            new (&m_buffer.get()[i]) ValueProfileAndVirtualRegister();
     }
 
-    ~ValueProfileAndOperandBuffer()
+    ~ValueProfileAndVirtualRegisterBuffer()
     {
         for (unsigned i = 0; i < m_size; ++i)
-            m_buffer.get()[i].~ValueProfileAndOperand();
+            m_buffer.get()[i].~ValueProfileAndVirtualRegister();
     }
 
     template <typename Function>
     void forEach(Function function)
     {
         for (unsigned i = 0; i < m_size; ++i)
             function(m_buffer.get()[i]);
     }
 
     unsigned m_size;
-    MallocPtr<ValueProfileAndOperand> m_buffer;
+    MallocPtr<ValueProfileAndVirtualRegister, VMMalloc> m_buffer;
 };
 
 } // namespace JSC

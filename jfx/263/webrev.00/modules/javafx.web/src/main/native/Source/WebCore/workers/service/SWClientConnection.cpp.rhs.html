<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/workers/service/SWClientConnection.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SWClientConnection.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;Document.h&quot;
 32 #include &quot;ExceptionData.h&quot;
 33 #include &quot;MessageEvent.h&quot;
<a name="1" id="anc1"></a>
 34 #include &quot;SWContextManager.h&quot;
 35 #include &quot;ServiceWorkerContainer.h&quot;
 36 #include &quot;ServiceWorkerFetchResult.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 37 #include &quot;ServiceWorkerGlobalScope.h&quot;</span>
 38 #include &quot;ServiceWorkerJobData.h&quot;
 39 #include &quot;ServiceWorkerRegistration.h&quot;
 40 #include &lt;wtf/CrossThreadCopier.h&gt;
 41 
 42 namespace WebCore {
 43 
<a name="3" id="anc3"></a><span class="line-added"> 44 static bool dispatchToContextThreadIfNecessary(const DocumentOrWorkerIdentifier&amp; contextIdentifier, WTF::Function&lt;void(ScriptExecutionContext&amp;)&gt;&amp;&amp; task)</span>
<span class="line-added"> 45 {</span>
<span class="line-added"> 46     RELEASE_ASSERT(isMainThread());</span>
<span class="line-added"> 47     bool wasPosted = false;</span>
<span class="line-added"> 48     switchOn(contextIdentifier, [&amp;] (DocumentIdentifier identifier) {</span>
<span class="line-added"> 49         auto* document = Document::allDocumentsMap().get(identifier);</span>
<span class="line-added"> 50         if (!document)</span>
<span class="line-added"> 51             return;</span>
<span class="line-added"> 52         task(*document);</span>
<span class="line-added"> 53         wasPosted = true;</span>
<span class="line-added"> 54     }, [&amp;](ServiceWorkerIdentifier identifier) {</span>
<span class="line-added"> 55         wasPosted = SWContextManager::singleton().postTaskToServiceWorker(identifier, [task = WTFMove(task)](auto&amp; scope) mutable {</span>
<span class="line-added"> 56             task(scope);</span>
<span class="line-added"> 57         });</span>
<span class="line-added"> 58     });</span>
<span class="line-added"> 59     return wasPosted;</span>
<span class="line-added"> 60 }</span>
<span class="line-added"> 61 </span>
 62 SWClientConnection::SWClientConnection() = default;
 63 
 64 SWClientConnection::~SWClientConnection() = default;
 65 
 66 void SWClientConnection::scheduleJob(DocumentOrWorkerIdentifier contextIdentifier, const ServiceWorkerJobData&amp; jobData)
 67 {
<a name="4" id="anc4"></a>

 68     auto addResult = m_scheduledJobSources.add(jobData.identifier().jobIdentifier, contextIdentifier);
 69     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 70 
 71     scheduleJobInServer(jobData);
 72 }
 73 
<a name="5" id="anc5"></a><span class="line-modified"> 74 bool SWClientConnection::postTaskForJob(ServiceWorkerJobIdentifier jobIdentifier, IsJobComplete isJobComplete, Function&lt;void(ServiceWorkerJob&amp;)&gt;&amp;&amp; task)</span>







 75 {
 76     ASSERT(isMainThread());
 77 
 78     auto iterator = m_scheduledJobSources.find(jobIdentifier);
 79     if (iterator == m_scheduledJobSources.end()) {
 80         LOG_ERROR(&quot;Job %s was not found&quot;, jobIdentifier.loggingString().utf8().data());
 81         return false;
 82     }
<a name="6" id="anc6"></a><span class="line-modified"> 83     auto isPosted = dispatchToContextThreadIfNecessary(iterator-&gt;value, [jobIdentifier, task = WTFMove(task)] (ScriptExecutionContext&amp; context) mutable {</span>
 84         if (auto* container = context.serviceWorkerContainer()) {
 85             if (auto* job = container-&gt;job(jobIdentifier))
 86                 task(*job);
 87         }
 88     });
 89     if (isJobComplete == IsJobComplete::Yes)
 90         m_scheduledJobSources.remove(iterator);
 91     return isPosted;
 92 }
 93 
 94 void SWClientConnection::jobRejectedInServer(ServiceWorkerJobIdentifier jobIdentifier, const ExceptionData&amp; exceptionData)
 95 {
 96     postTaskForJob(jobIdentifier, IsJobComplete::Yes, [exceptionData = exceptionData.isolatedCopy()] (auto&amp; job) {
 97         job.failedWithException(exceptionData.toException());
 98     });
 99 }
100 
101 void SWClientConnection::registrationJobResolvedInServer(ServiceWorkerJobIdentifier jobIdentifier, ServiceWorkerRegistrationData&amp;&amp; registrationData, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
102 {
103     bool isPosted = postTaskForJob(jobIdentifier, IsJobComplete::Yes, [registrationData = registrationData.isolatedCopy(), shouldNotifyWhenResolved] (auto&amp; job) mutable {
104         job.resolvedWithRegistration(WTFMove(registrationData), shouldNotifyWhenResolved);
105     });
106 
107     if (!isPosted &amp;&amp; shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes)
108         didResolveRegistrationPromise(registrationData.key);
109 }
110 
111 void SWClientConnection::unregistrationJobResolvedInServer(ServiceWorkerJobIdentifier jobIdentifier, bool unregistrationResult)
112 {
113     postTaskForJob(jobIdentifier, IsJobComplete::Yes, [unregistrationResult] (auto&amp; job) {
114         job.resolvedWithUnregistrationResult(unregistrationResult);
115     });
116 }
117 
118 void SWClientConnection::startScriptFetchForServer(ServiceWorkerJobIdentifier jobIdentifier, const ServiceWorkerRegistrationKey&amp; registrationKey, FetchOptions::Cache cachePolicy)
119 {
120     bool isPosted = postTaskForJob(jobIdentifier, IsJobComplete::No, [cachePolicy] (auto&amp; job) {
121         job.startScriptFetch(cachePolicy);
122     });
123     if (!isPosted)
<a name="7" id="anc7"></a><span class="line-modified">124         finishFetchingScriptInServer(serviceWorkerFetchError({ serverConnectionIdentifier(), jobIdentifier }, ServiceWorkerRegistrationKey { registrationKey}, ResourceError { errorDomainWebKitInternal, 0, { }, makeString(&quot;Failed to fetch script for service worker with scope &quot;, registrationKey.scope().string()) }));</span>
125 }
126 
127 
128 void SWClientConnection::postMessageToServiceWorkerClient(DocumentIdentifier destinationContextIdentifier, MessageWithMessagePorts&amp;&amp; message, ServiceWorkerData&amp;&amp; sourceData, String&amp;&amp; sourceOrigin)
129 {
130     ASSERT(isMainThread());
131 
132     // FIXME: destinationContextIdentifier can only identify a Document at the moment.
133     auto* destinationDocument = Document::allDocumentsMap().get(destinationContextIdentifier);
134     if (!destinationDocument)
135         return;
136 
<a name="8" id="anc8"></a><span class="line-modified">137     if (auto* container = destinationDocument-&gt;ensureServiceWorkerContainer())</span>
<span class="line-modified">138         container-&gt;postMessage(WTFMove(message), WTFMove(sourceData), WTFMove(sourceOrigin));</span>


139 }
140 
141 void SWClientConnection::updateRegistrationState(ServiceWorkerRegistrationIdentifier identifier, ServiceWorkerRegistrationState state, const Optional&lt;ServiceWorkerData&gt;&amp; serviceWorkerData)
142 {
143     ASSERT(isMainThread());
144 
145     SWContextManager::singleton().forEachServiceWorkerThread([identifier, state, &amp;serviceWorkerData] (auto&amp; workerThread) {
146         workerThread.thread().runLoop().postTask([identifier, state, serviceWorkerData = crossThreadCopy(serviceWorkerData)](ScriptExecutionContext&amp; context) mutable {
147             if (auto* container = context.serviceWorkerContainer())
148                 container-&gt;updateRegistrationState(identifier, state, WTFMove(serviceWorkerData));
149         });
150     });
151 
152     for (auto* document : Document::allDocuments()) {
<a name="9" id="anc9"></a><span class="line-modified">153         if (auto* container = document-&gt;serviceWorkerContainer())</span>
<span class="line-modified">154             container-&gt;updateRegistrationState(identifier, state, serviceWorkerData);</span>


155     }
156 }
157 
158 void SWClientConnection::updateWorkerState(ServiceWorkerIdentifier identifier, ServiceWorkerState state)
159 {
160     ASSERT(isMainThread());
161 
162     SWContextManager::singleton().forEachServiceWorkerThread([identifier, state] (auto&amp; workerThread) {
163         workerThread.thread().runLoop().postTask([identifier, state](ScriptExecutionContext&amp; context) {
<a name="10" id="anc10"></a><span class="line-modified">164             if (auto* container = context.serviceWorkerContainer())</span>
<span class="line-modified">165                 container-&gt;updateWorkerState(identifier, state);</span>
166         });
167     });
168 
169     for (auto* document : Document::allDocuments()) {
<a name="11" id="anc11"></a><span class="line-modified">170         if (auto* container = document-&gt;serviceWorkerContainer())</span>
<span class="line-modified">171             container-&gt;updateWorkerState(identifier, state);</span>


172     }
173 }
174 
175 void SWClientConnection::fireUpdateFoundEvent(ServiceWorkerRegistrationIdentifier identifier)
176 {
177     ASSERT(isMainThread());
178 
179     SWContextManager::singleton().forEachServiceWorkerThread([identifier] (auto&amp; workerThread) {
180         workerThread.thread().runLoop().postTask([identifier](ScriptExecutionContext&amp; context) {
181             if (auto* container = context.serviceWorkerContainer())
<a name="12" id="anc12"></a><span class="line-modified">182                 container-&gt;queueTaskToFireUpdateFoundEvent(identifier);</span>
183         });
184     });
185 
186     for (auto* document : Document::allDocuments()) {
<a name="13" id="anc13"></a><span class="line-modified">187         if (auto* container = document-&gt;serviceWorkerContainer())</span>
<span class="line-modified">188             container-&gt;queueTaskToFireUpdateFoundEvent(identifier);</span>


189     }
190 }
191 
192 void SWClientConnection::setRegistrationLastUpdateTime(ServiceWorkerRegistrationIdentifier identifier, WallTime lastUpdateTime)
193 {
194     ASSERT(isMainThread());
195 
196     SWContextManager::singleton().forEachServiceWorkerThread([identifier, lastUpdateTime] (auto&amp; workerThread) {
197         workerThread.thread().runLoop().postTask([identifier, lastUpdateTime](ScriptExecutionContext&amp; context) {
198             if (auto* container = context.serviceWorkerContainer()) {
199                 if (auto* registration = container-&gt;registration(identifier))
200                     registration-&gt;setLastUpdateTime(lastUpdateTime);
201             }
202         });
203     });
204 
205     for (auto* document : Document::allDocuments()) {
206         if (auto* container = document-&gt;serviceWorkerContainer()) {
207             if (auto* registration = container-&gt;registration(identifier))
208                 registration-&gt;setLastUpdateTime(lastUpdateTime);
209         }
210     }
211 }
212 
213 void SWClientConnection::setRegistrationUpdateViaCache(ServiceWorkerRegistrationIdentifier identifier, ServiceWorkerUpdateViaCache updateViaCache)
214 {
215     ASSERT(isMainThread());
216 
217     SWContextManager::singleton().forEachServiceWorkerThread([identifier, updateViaCache] (auto&amp; workerThread) {
218         workerThread.thread().runLoop().postTask([identifier, updateViaCache](ScriptExecutionContext&amp; context) {
219             if (auto* container = context.serviceWorkerContainer()) {
220                 if (auto* registration = container-&gt;registration(identifier))
221                     registration-&gt;setUpdateViaCache(updateViaCache);
222             }
223         });
224     });
225 
226     for (auto* document : Document::allDocuments()) {
227         if (auto* container = document-&gt;serviceWorkerContainer()) {
228             if (auto* registration = container-&gt;registration(identifier))
229                 registration-&gt;setUpdateViaCache(updateViaCache);
230         }
231     }
232 }
233 
234 void SWClientConnection::notifyClientsOfControllerChange(const HashSet&lt;DocumentIdentifier&gt;&amp; contextIdentifiers, ServiceWorkerData&amp;&amp; newController)
235 {
236     ASSERT(isMainThread());
237     ASSERT(!contextIdentifiers.isEmpty());
238 
239     for (auto&amp; clientIdentifier : contextIdentifiers) {
240         // FIXME: Support worker contexts.
241         auto* client = Document::allDocumentsMap().get(clientIdentifier);
242         if (!client)
243             continue;
244 
<a name="14" id="anc14"></a><span class="line-modified">245         client-&gt;setActiveServiceWorker(ServiceWorker::getOrCreate(*client, WTFMove(newController)));</span>
<span class="line-modified">246         if (auto* container = client-&gt;serviceWorkerContainer())</span>
<span class="line-modified">247             container-&gt;queueTaskToDispatchControllerChangeEvent();</span>



248     }
249 }
250 
251 void SWClientConnection::clearPendingJobs()
252 {
253     ASSERT(isMainThread());
254 
255     auto jobSources = WTFMove(m_scheduledJobSources);
256     for (auto&amp; keyValue : jobSources) {
<a name="15" id="anc15"></a><span class="line-modified">257         dispatchToContextThreadIfNecessary(keyValue.value, [identifier = keyValue.key] (auto&amp; context) {</span>
258             if (auto* container = context.serviceWorkerContainer()) {
259                 if (auto* job = container-&gt;job(identifier))
260                     job-&gt;failedWithException(Exception { TypeError, &quot;Internal error&quot;_s });
261             }
262         });
263     }
264 }
265 
<a name="16" id="anc16"></a><span class="line-added">266 void SWClientConnection::registerServiceWorkerClients()</span>
<span class="line-added">267 {</span>
<span class="line-added">268     for (auto* document : Document::allDocuments()) {</span>
<span class="line-added">269         auto controllingServiceWorkerRegistrationIdentifier = document-&gt;activeServiceWorker() ? makeOptional&lt;ServiceWorkerRegistrationIdentifier&gt;(document-&gt;activeServiceWorker()-&gt;registrationIdentifier()) : WTF::nullopt;</span>
<span class="line-added">270         registerServiceWorkerClient(document-&gt;topOrigin(), ServiceWorkerClientData::from(*document, *this), controllingServiceWorkerRegistrationIdentifier, document-&gt;userAgent(document-&gt;url()));</span>
<span class="line-added">271     }</span>
<span class="line-added">272 }</span>
<span class="line-added">273 </span>
274 } // namespace WebCore
275 
276 #endif // ENABLE(SERVICE_WORKER)
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCellInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSCell.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSCustomGetterSetterFunction.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCellInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,11 ***</span>
  
  #include &quot;AllocatorForMode.h&quot;
  #include &quot;AllocatorInlines.h&quot;
  #include &quot;CompleteSubspaceInlines.h&quot;
  #include &quot;CPU.h&quot;
<span class="line-modified">! #include &quot;CallFrame.h&quot;</span>
  #include &quot;DeferGC.h&quot;
  #include &quot;FreeListInlines.h&quot;
  #include &quot;Handle.h&quot;
  #include &quot;HeapInlines.h&quot;
  #include &quot;IsoSubspaceInlines.h&quot;
<span class="line-new-header">--- 27,11 ---</span>
  
  #include &quot;AllocatorForMode.h&quot;
  #include &quot;AllocatorInlines.h&quot;
  #include &quot;CompleteSubspaceInlines.h&quot;
  #include &quot;CPU.h&quot;
<span class="line-modified">! #include &quot;CallFrameInlines.h&quot;</span>
  #include &quot;DeferGC.h&quot;
  #include &quot;FreeListInlines.h&quot;
  #include &quot;Handle.h&quot;
  #include &quot;HeapInlines.h&quot;
  #include &quot;IsoSubspaceInlines.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 136,26 ***</span>
  
  inline void JSCell::visitOutputConstraints(JSCell*, SlotVisitor&amp;)
  {
  }
  
<span class="line-modified">! ALWAYS_INLINE VM&amp; ExecState::vm() const</span>
  {
      JSCell* callee = this-&gt;callee().asCell();
      ASSERT(callee);
      ASSERT(&amp;callee-&gt;vm());
<span class="line-modified">!     ASSERT(!callee-&gt;isLargeAllocation());</span>
<span class="line-removed">-     // This is an important optimization since we access this so often.</span>
<span class="line-removed">-     return callee-&gt;markedBlock().vm();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- template&lt;typename CellType, SubspaceAccess&gt;</span>
<span class="line-removed">- CompleteSubspace* JSCell::subspaceFor(VM&amp; vm)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (CellType::needsDestruction)</span>
<span class="line-removed">-         return &amp;vm.destructibleCellSpace;</span>
<span class="line-removed">-     return &amp;vm.cellSpace;</span>
  }
  
  template&lt;typename Type&gt;
  inline Allocator allocatorForNonVirtualConcurrently(VM&amp; vm, size_t allocationSize, AllocatorForMode mode)
  {
<span class="line-new-header">--- 136,16 ---</span>
  
  inline void JSCell::visitOutputConstraints(JSCell*, SlotVisitor&amp;)
  {
  }
  
<span class="line-modified">! ALWAYS_INLINE VM&amp; CallFrame::deprecatedVM() const</span>
  {
      JSCell* callee = this-&gt;callee().asCell();
      ASSERT(callee);
      ASSERT(&amp;callee-&gt;vm());
<span class="line-modified">!     return callee-&gt;vm();</span>
  }
  
  template&lt;typename Type&gt;
  inline Allocator allocatorForNonVirtualConcurrently(VM&amp; vm, size_t allocationSize, AllocatorForMode mode)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 300,11 ***</span>
  }
  
  inline const MethodTable* JSCell::methodTable(VM&amp; vm) const
  {
      Structure* structure = this-&gt;structure(vm);
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      if (Structure* rootStructure = structure-&gt;structure(vm))
          ASSERT(rootStructure == rootStructure-&gt;structure(vm));
  #endif
      return &amp;structure-&gt;classInfo()-&gt;methodTable;
  }
<span class="line-new-header">--- 290,11 ---</span>
  }
  
  inline const MethodTable* JSCell::methodTable(VM&amp; vm) const
  {
      Structure* structure = this-&gt;structure(vm);
<span class="line-modified">! #if ASSERT_ENABLED</span>
      if (Structure* rootStructure = structure-&gt;structure(vm))
          ASSERT(rootStructure == rootStructure-&gt;structure(vm));
  #endif
      return &amp;structure-&gt;classInfo()-&gt;methodTable;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 345,17 ***</span>
      // to allow the GC thread or JIT threads to pass this assertion.
      ASSERT(vm.heap.mutatorState() != MutatorState::Sweeping || !vm.currentThreadIsHoldingAPILock());
      return structure(vm)-&gt;classInfo();
  }
  
<span class="line-modified">! inline bool JSCell::toBoolean(ExecState* exec) const</span>
  {
      if (isString())
          return static_cast&lt;const JSString*&gt;(this)-&gt;toBoolean();
      if (isBigInt())
          return static_cast&lt;const JSBigInt*&gt;(this)-&gt;toBoolean();
<span class="line-modified">!     return !structure(exec-&gt;vm())-&gt;masqueradesAsUndefined(exec-&gt;lexicalGlobalObject());</span>
  }
  
  inline TriState JSCell::pureToBoolean() const
  {
      if (isString())
<span class="line-new-header">--- 335,17 ---</span>
      // to allow the GC thread or JIT threads to pass this assertion.
      ASSERT(vm.heap.mutatorState() != MutatorState::Sweeping || !vm.currentThreadIsHoldingAPILock());
      return structure(vm)-&gt;classInfo();
  }
  
<span class="line-modified">! inline bool JSCell::toBoolean(JSGlobalObject* globalObject) const</span>
  {
      if (isString())
          return static_cast&lt;const JSString*&gt;(this)-&gt;toBoolean();
      if (isBigInt())
          return static_cast&lt;const JSBigInt*&gt;(this)-&gt;toBoolean();
<span class="line-modified">!     return !structure(getVM(globalObject))-&gt;masqueradesAsUndefined(globalObject);</span>
  }
  
  inline TriState JSCell::pureToBoolean() const
  {
      if (isString())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 407,26 ***</span>
          m_flags |= static_cast&lt;TypeInfo::InlineTypeFlags&gt;(TypeInfoPerCellBit);
      else
          m_flags &amp;= ~static_cast&lt;TypeInfo::InlineTypeFlags&gt;(TypeInfoPerCellBit);
  }
  
<span class="line-modified">! inline JSObject* JSCell::toObject(ExecState* exec, JSGlobalObject* globalObject) const</span>
  {
      if (isObject())
          return jsCast&lt;JSObject*&gt;(const_cast&lt;JSCell*&gt;(this));
<span class="line-modified">!     return toObjectSlow(exec, globalObject);</span>
  }
  
<span class="line-modified">! ALWAYS_INLINE bool JSCell::putInline(ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     auto putMethod = methodTable(exec-&gt;vm())-&gt;put;</span>
      if (LIKELY(putMethod == JSObject::put))
<span class="line-modified">!         return JSObject::putInlineForJSObject(asObject(this), exec, propertyName, value, slot);</span>
<span class="line-modified">!     return putMethod(this, exec, propertyName, value, slot);</span>
  }
  
<span class="line-modified">! inline bool isWebAssemblyToJSCallee(const JSCell* cell)</span>
  {
<span class="line-modified">!     return cell-&gt;type() == WebAssemblyToJSCalleeType;</span>
  }
  
  } // namespace JSC
<span class="line-new-header">--- 397,26 ---</span>
          m_flags |= static_cast&lt;TypeInfo::InlineTypeFlags&gt;(TypeInfoPerCellBit);
      else
          m_flags &amp;= ~static_cast&lt;TypeInfo::InlineTypeFlags&gt;(TypeInfoPerCellBit);
  }
  
<span class="line-modified">! inline JSObject* JSCell::toObject(JSGlobalObject* globalObject) const</span>
  {
      if (isObject())
          return jsCast&lt;JSObject*&gt;(const_cast&lt;JSCell*&gt;(this));
<span class="line-modified">!     return toObjectSlow(globalObject);</span>
  }
  
<span class="line-modified">! ALWAYS_INLINE bool JSCell::putInline(JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     auto putMethod = methodTable(getVM(globalObject))-&gt;put;</span>
      if (LIKELY(putMethod == JSObject::put))
<span class="line-modified">!         return JSObject::putInlineForJSObject(asObject(this), globalObject, propertyName, value, slot);</span>
<span class="line-modified">!     return putMethod(this, globalObject, propertyName, value, slot);</span>
  }
  
<span class="line-modified">! inline bool isWebAssemblyModule(const JSCell* cell)</span>
  {
<span class="line-modified">!     return cell-&gt;type() == WebAssemblyModuleType;</span>
  }
  
  } // namespace JSC
</pre>
<center><a href="JSCell.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSCustomGetterSetterFunction.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
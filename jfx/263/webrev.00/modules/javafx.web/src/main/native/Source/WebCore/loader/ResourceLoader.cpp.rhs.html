<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/loader/ResourceLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2006-2018 Apple Inc. All rights reserved.
  3  *           (C) 2007 Graham Dennis (graham.dennis@gmail.com)
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 15  *     its contributors may be used to endorse or promote products derived
 16  *     from this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;ResourceLoader.h&quot;
 32 
 33 #include &quot;ApplicationCacheHost.h&quot;
 34 #include &quot;AuthenticationChallenge.h&quot;
 35 #include &quot;ContentRuleListResults.h&quot;
 36 #include &quot;CustomHeaderFields.h&quot;
 37 #include &quot;DataURLDecoder.h&quot;
 38 #include &quot;DiagnosticLoggingClient.h&quot;
 39 #include &quot;DiagnosticLoggingKeys.h&quot;
 40 #include &quot;DocumentLoader.h&quot;
 41 #include &quot;Frame.h&quot;
 42 #include &quot;FrameLoader.h&quot;
 43 #include &quot;FrameLoaderClient.h&quot;
 44 #include &quot;InspectorInstrumentation.h&quot;
 45 #include &quot;LoaderStrategy.h&quot;
 46 #include &quot;Logging.h&quot;
 47 #include &quot;Page.h&quot;
 48 #include &quot;PlatformStrategies.h&quot;
 49 #include &quot;ProgressTracker.h&quot;
 50 #include &quot;ResourceError.h&quot;
 51 #include &quot;ResourceHandle.h&quot;
 52 #include &quot;SecurityOrigin.h&quot;
 53 #include &quot;SharedBuffer.h&quot;
 54 #include &lt;wtf/CompletionHandler.h&gt;
 55 #include &lt;wtf/Ref.h&gt;
 56 
 57 #if ENABLE(CONTENT_EXTENSIONS)
 58 #include &quot;UserContentController.h&quot;
 59 #endif
 60 
 61 #if USE(QUICK_LOOK)
<a name="1" id="anc1"></a><span class="line-added"> 62 #include &quot;LegacyPreviewLoader.h&quot;</span>
 63 #include &quot;PreviewConverter.h&quot;
<a name="2" id="anc2"></a>
 64 #endif
 65 
 66 #undef RELEASE_LOG_IF_ALLOWED
 67 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), Network, &quot;%p - ResourceLoader::&quot; fmt, this, ##__VA_ARGS__)
 68 
 69 namespace WebCore {
 70 
<a name="3" id="anc3"></a><span class="line-added"> 71 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ResourceLoader);</span>
<span class="line-added"> 72 </span>
 73 ResourceLoader::ResourceLoader(Frame&amp; frame, ResourceLoaderOptions options)
 74     : m_frame { &amp;frame }
 75     , m_documentLoader { frame.loader().activeDocumentLoader() }
 76     , m_defersLoading { options.defersLoadingPolicy == DefersLoadingPolicy::AllowDefersLoading &amp;&amp; frame.page()-&gt;defersLoading() }
 77     , m_options { options }
 78 {
 79 }
 80 
 81 ResourceLoader::~ResourceLoader()
 82 {
 83     ASSERT(m_reachedTerminalState);
 84 }
 85 
 86 void ResourceLoader::finishNetworkLoad()
 87 {
 88     platformStrategies()-&gt;loaderStrategy()-&gt;remove(this);
 89 
 90     if (m_handle) {
 91         ASSERT(m_handle-&gt;client() == this);
 92         m_handle-&gt;clearClient();
 93         m_handle = nullptr;
 94     }
 95 }
 96 
 97 void ResourceLoader::releaseResources()
 98 {
 99     ASSERT(!m_reachedTerminalState);
100 
101     // It&#39;s possible that when we release the handle, it will be
102     // deallocated and release the last reference to this object.
103     // We need to retain to avoid accessing the object after it
104     // has been deallocated and also to avoid reentering this method.
105     Ref&lt;ResourceLoader&gt; protectedThis(*this);
106 
107     m_frame = nullptr;
108     m_documentLoader = nullptr;
109 
110     // We need to set reachedTerminalState to true before we release
111     // the resources to prevent a double dealloc of WebView &lt;rdar://problem/4372628&gt;
112     m_reachedTerminalState = true;
113 
114     finishNetworkLoad();
115 
116     m_identifier = 0;
117 
118     m_resourceData = nullptr;
119     m_deferredRequest = ResourceRequest();
120 }
121 
122 void ResourceLoader::init(ResourceRequest&amp;&amp; clientRequest, CompletionHandler&lt;void(bool)&gt;&amp;&amp; completionHandler)
123 {
124 #if PLATFORM(IOS_FAMILY)
125     if (!m_documentLoader) {
126         // We should always have a DocumentLoader at this point, but crash reports indicate that it is sometimes null.
127         // See https://bugs.webkit.org/show_bug.cgi?id=187360
128         ASSERT_NOT_REACHED();
129         return completionHandler(false);
130     }
131 #endif
132     ASSERT(!m_handle);
133     ASSERT(m_request.isNull());
134     ASSERT(m_deferredRequest.isNull());
135     ASSERT(!m_documentLoader-&gt;isSubstituteLoadPending(this));
136 
137     m_loadTiming.markStartTimeAndFetchStart();
138 
139 #if PLATFORM(IOS_FAMILY)
140     // If the documentLoader was detached while this ResourceLoader was waiting its turn
141     // in ResourceLoadScheduler queue, don&#39;t continue.
142     if (!m_documentLoader-&gt;frame()) {
143         cancel();
144         return completionHandler(false);
145     }
146 #endif
147 
148     m_defersLoading = m_options.defersLoadingPolicy == DefersLoadingPolicy::AllowDefersLoading &amp;&amp; m_frame-&gt;page()-&gt;defersLoading();
149 
150     if (m_options.securityCheck == SecurityCheckPolicy::DoSecurityCheck &amp;&amp; !m_frame-&gt;document()-&gt;securityOrigin().canDisplay(clientRequest.url())) {
151         FrameLoader::reportLocalLoadFailed(m_frame.get(), clientRequest.url().string());
152         releaseResources();
153         return completionHandler(false);
154     }
155 
156     // The various plug-in implementations call directly to ResourceLoader::load() instead of piping requests
157     // through FrameLoader. As a result, they miss the FrameLoader::addExtraFieldsToRequest() step which sets
158     // up the 1st party for cookies URL and Same-Site info. Until plug-in implementations can be reigned in
159     // to pipe through that method, we need to make sure there is always both a 1st party for cookies set and
160     // Same-Site info. See &lt;https://bugs.webkit.org/show_bug.cgi?id=26391&gt;.
161     if (clientRequest.firstPartyForCookies().isNull()) {
162         if (Document* document = m_frame-&gt;document())
163             clientRequest.setFirstPartyForCookies(document-&gt;firstPartyForCookies());
164     }
165     FrameLoader::addSameSiteInfoToRequestIfNeeded(clientRequest, m_frame-&gt;document());
166 
167     willSendRequestInternal(WTFMove(clientRequest), ResourceResponse(), [this, protectedThis = makeRef(*this), completionHandler = WTFMove(completionHandler)](ResourceRequest&amp;&amp; request) mutable {
168 
169 #if PLATFORM(IOS_FAMILY)
170         // If this ResourceLoader was stopped as a result of willSendRequest, bail out.
171         if (m_reachedTerminalState)
172             return completionHandler(false);
173 #endif
174 
175         if (request.isNull()) {
176             cancel();
177             return completionHandler(false);
178         }
179 
180         m_request = WTFMove(request);
181         m_originalRequest = m_request;
182         completionHandler(true);
183     });
184 }
185 
186 void ResourceLoader::deliverResponseAndData(const ResourceResponse&amp; response, RefPtr&lt;SharedBuffer&gt;&amp;&amp; buffer)
187 {
188     didReceiveResponse(response, [this, protectedThis = makeRef(*this), buffer = WTFMove(buffer)]() mutable {
189         if (reachedTerminalState())
190             return;
191 
192         if (buffer) {
193             unsigned size = buffer-&gt;size();
194             didReceiveBuffer(buffer.releaseNonNull(), size, DataPayloadWholeResource);
195             if (reachedTerminalState())
196                 return;
197         }
198 
199         NetworkLoadMetrics emptyMetrics;
200         didFinishLoading(emptyMetrics);
201     });
202 }
203 
204 void ResourceLoader::start()
205 {
206     ASSERT(!m_handle);
207     ASSERT(!m_request.isNull());
208     ASSERT(m_deferredRequest.isNull());
209     ASSERT(frameLoader());
210 
211 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
212     if (m_documentLoader-&gt;scheduleArchiveLoad(*this, m_request))
213         return;
214 #endif
215 
216     if (m_documentLoader-&gt;applicationCacheHost().maybeLoadResource(*this, m_request, m_request.url()))
217         return;
218 
219     if (m_defersLoading) {
220         m_deferredRequest = m_request;
221         return;
222     }
223 
224     if (m_reachedTerminalState)
225         return;
226 
227     if (m_request.url().protocolIsData()) {
228         loadDataURL();
229         return;
230     }
231 
232 #if USE(SOUP)
233     if (m_request.url().protocolIs(&quot;resource&quot;)) {
234         loadGResource();
235         return;
236     }
237 #endif
238 
239     m_handle = ResourceHandle::create(frameLoader()-&gt;networkingContext(), m_request, this, m_defersLoading, m_options.sniffContent == ContentSniffingPolicy::SniffContent, m_options.sniffContentEncoding == ContentEncodingSniffingPolicy::Sniff);
240 }
241 
242 void ResourceLoader::setDefersLoading(bool defers)
243 {
244     if (m_options.defersLoadingPolicy == DefersLoadingPolicy::DisallowDefersLoading)
245         return;
246 
247     m_defersLoading = defers;
248     if (m_handle)
249         m_handle-&gt;setDefersLoading(defers);
250 
251     platformStrategies()-&gt;loaderStrategy()-&gt;setDefersLoading(*this, defers);
252 }
253 
254 FrameLoader* ResourceLoader::frameLoader() const
255 {
256     if (!m_frame)
257         return nullptr;
258     return &amp;m_frame-&gt;loader();
259 }
260 
261 void ResourceLoader::loadDataURL()
262 {
263     auto url = m_request.url();
264     ASSERT(url.protocolIsData());
265 
266     DataURLDecoder::ScheduleContext scheduleContext;
267 #if HAVE(RUNLOOP_TIMER)
268     if (auto* scheduledPairs = m_frame-&gt;page()-&gt;scheduledRunLoopPairs())
269         scheduleContext.scheduledPairs = *scheduledPairs;
270 #endif
271     DataURLDecoder::decode(url, scheduleContext, [this, protectedThis = makeRef(*this), url](auto decodeResult) mutable {
272         if (this-&gt;reachedTerminalState())
273             return;
274         if (!decodeResult) {
275             RELEASE_LOG_IF_ALLOWED(&quot;loadDataURL: decoding of data failed (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
276             protectedThis-&gt;didFail(ResourceError(errorDomainWebKitInternal, 0, url, &quot;Data URL decoding failed&quot;));
277             return;
278         }
279         if (this-&gt;wasCancelled())
280             return;
281         auto&amp; result = decodeResult.value();
282         auto dataSize = result.data ? result.data-&gt;size() : 0;
283 
284         ResourceResponse dataResponse { url, result.mimeType, static_cast&lt;long long&gt;(dataSize), result.charset };
285         dataResponse.setHTTPStatusCode(200);
286         dataResponse.setHTTPStatusText(&quot;OK&quot;_s);
287         dataResponse.setHTTPHeaderField(HTTPHeaderName::ContentType, result.contentType);
288         dataResponse.setSource(ResourceResponse::Source::Network);
289         this-&gt;didReceiveResponse(dataResponse, [this, protectedThis = WTFMove(protectedThis), dataSize, data = result.data.releaseNonNull()]() mutable {
<a name="4" id="anc4"></a><span class="line-modified">290             if (!this-&gt;reachedTerminalState() &amp;&amp; dataSize &amp;&amp; m_request.httpMethod() != &quot;HEAD&quot;)</span>
291                 this-&gt;didReceiveBuffer(WTFMove(data), dataSize, DataPayloadWholeResource);
292 
293             if (!this-&gt;reachedTerminalState()) {
294                 NetworkLoadMetrics emptyMetrics;
295                 this-&gt;didFinishLoading(emptyMetrics);
296             }
297         });
298     });
299 }
300 
301 void ResourceLoader::setDataBufferingPolicy(DataBufferingPolicy dataBufferingPolicy)
302 {
303     m_options.dataBufferingPolicy = dataBufferingPolicy;
304 
305     // Reset any already buffered data
306     if (dataBufferingPolicy == DataBufferingPolicy::DoNotBufferData)
307         m_resourceData = nullptr;
308 }
309 
310 void ResourceLoader::willSwitchToSubstituteResource()
311 {
312     ASSERT(!m_documentLoader-&gt;isSubstituteLoadPending(this));
313     platformStrategies()-&gt;loaderStrategy()-&gt;remove(this);
314     if (m_handle)
315         m_handle-&gt;cancel();
316 }
317 
318 void ResourceLoader::addDataOrBuffer(const char* data, unsigned length, SharedBuffer* buffer, DataPayloadType dataPayloadType)
319 {
320     if (m_options.dataBufferingPolicy == DataBufferingPolicy::DoNotBufferData)
321         return;
322 
323     if (!m_resourceData || dataPayloadType == DataPayloadWholeResource) {
324         if (buffer)
325             m_resourceData = buffer;
326         else
327             m_resourceData = SharedBuffer::create(data, length);
328         return;
329     }
330 
331     if (buffer)
332         m_resourceData-&gt;append(*buffer);
333     else
334         m_resourceData-&gt;append(data, length);
335 }
336 
337 void ResourceLoader::clearResourceData()
338 {
339     if (m_resourceData)
340         m_resourceData-&gt;clear();
341 }
342 
343 bool ResourceLoader::isSubresourceLoader() const
344 {
345     return false;
346 }
347 
348 void ResourceLoader::willSendRequestInternal(ResourceRequest&amp;&amp; request, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
349 {
350     // Protect this in this delegate method since the additional processing can do
351     // anything including possibly derefing this; one example of this is Radar 3266216.
352     Ref&lt;ResourceLoader&gt; protectedThis(*this);
353 
354     ASSERT(!m_reachedTerminalState);
355 #if ENABLE(CONTENT_EXTENSIONS)
356     ASSERT(m_resourceType != ContentExtensions::ResourceType::Invalid);
357 #endif
358 
359     // We need a resource identifier for all requests, even if FrameLoader is never going to see it (such as with CORS preflight requests).
360     bool createdResourceIdentifier = false;
361     if (!m_identifier) {
362         m_identifier = m_frame-&gt;page()-&gt;progress().createUniqueIdentifier();
363         createdResourceIdentifier = true;
364     }
365 
366 #if ENABLE(CONTENT_EXTENSIONS)
367     if (!redirectResponse.isNull() &amp;&amp; frameLoader()) {
368         Page* page = frameLoader()-&gt;frame().page();
369         if (page &amp;&amp; m_documentLoader) {
370             auto results = page-&gt;userContentProvider().processContentRuleListsForLoad(request.url(), m_resourceType, *m_documentLoader);
371             bool blockedLoad = results.summary.blockedLoad;
372             ContentExtensions::applyResultsToRequest(WTFMove(results), page, request);
373             if (blockedLoad) {
374                 RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because of content blocker (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
375                 didFail(blockedByContentBlockerError());
376                 completionHandler({ });
377                 return;
378             }
379         }
380     }
381 #endif
382 
383     if (request.isNull()) {
384         RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestinternal: resource load canceled because of empty request (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
385         didFail(cannotShowURLError());
386         completionHandler({ });
387         return;
388     }
389 
390     if (m_options.sendLoadCallbacks == SendCallbackPolicy::SendCallbacks) {
391         if (createdResourceIdentifier)
392             frameLoader()-&gt;notifier().assignIdentifierToInitialRequest(m_identifier, documentLoader(), request);
393 
394 #if PLATFORM(IOS_FAMILY)
395         // If this ResourceLoader was stopped as a result of assignIdentifierToInitialRequest, bail out
396         if (m_reachedTerminalState) {
397             completionHandler(WTFMove(request));
398             return;
399         }
400 #endif
401 
402         frameLoader()-&gt;notifier().willSendRequest(this, request, redirectResponse);
403     }
404     else
405         InspectorInstrumentation::willSendRequest(m_frame.get(), m_identifier, m_frame-&gt;loader().documentLoader(), request, redirectResponse);
406 
407 #if USE(QUICK_LOOK)
408     if (auto previewConverter = m_documentLoader-&gt;previewConverter())
409         request = previewConverter-&gt;safeRequest(request);
410 #endif
411 
412     bool isRedirect = !redirectResponse.isNull();
413     if (isRedirect)
414         platformStrategies()-&gt;loaderStrategy()-&gt;crossOriginRedirectReceived(this, request.url());
415 
416     m_request = request;
417 
418     if (isRedirect) {
419         auto&amp; redirectURL = request.url();
420         if (!m_documentLoader-&gt;isCommitted())
421             frameLoader()-&gt;client().dispatchDidReceiveServerRedirectForProvisionalLoad();
422 
423         if (redirectURL.protocolIsData()) {
424             // Handle data URL decoding locally.
425             finishNetworkLoad();
426             loadDataURL();
427         }
428     }
429     completionHandler(WTFMove(request));
430 }
431 
432 void ResourceLoader::willSendRequest(ResourceRequest&amp;&amp; request, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
433 {
434     willSendRequestInternal(WTFMove(request), redirectResponse, WTFMove(completionHandler));
435 }
436 
437 void ResourceLoader::didSendData(unsigned long long, unsigned long long)
438 {
439 }
440 
441 static void logResourceResponseSource(Frame* frame, ResourceResponse::Source source)
442 {
443     if (!frame || !frame-&gt;page())
444         return;
445 
446     String sourceKey;
447     switch (source) {
448     case ResourceResponse::Source::Network:
449         sourceKey = DiagnosticLoggingKeys::networkKey();
450         break;
451     case ResourceResponse::Source::DiskCache:
452         sourceKey = DiagnosticLoggingKeys::diskCacheKey();
453         break;
454     case ResourceResponse::Source::DiskCacheAfterValidation:
455         sourceKey = DiagnosticLoggingKeys::diskCacheAfterValidationKey();
456         break;
457     case ResourceResponse::Source::ServiceWorker:
458         sourceKey = DiagnosticLoggingKeys::serviceWorkerKey();
459         break;
460     case ResourceResponse::Source::MemoryCache:
461     case ResourceResponse::Source::MemoryCacheAfterValidation:
<a name="5" id="anc5"></a><span class="line-added">462     case ResourceResponse::Source::DOMCache:</span>
463     case ResourceResponse::Source::ApplicationCache:
<a name="6" id="anc6"></a><span class="line-added">464     case ResourceResponse::Source::InspectorOverride:</span>
465     case ResourceResponse::Source::Unknown:
466         return;
467     }
468 
469     frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessage(DiagnosticLoggingKeys::resourceResponseSourceKey(), sourceKey, ShouldSample::Yes);
470 }
471 
472 bool ResourceLoader::shouldAllowResourceToAskForCredentials() const
473 {
474     return m_canCrossOriginRequestsAskUserForCredentials || m_frame-&gt;tree().top().document()-&gt;securityOrigin().canRequest(m_request.url());
475 }
476 
477 void ResourceLoader::didBlockAuthenticationChallenge()
478 {
479     m_wasAuthenticationChallengeBlocked = true;
480     if (m_options.clientCredentialPolicy == ClientCredentialPolicy::CannotAskClientForCredentials)
481         return;
482     ASSERT(!shouldAllowResourceToAskForCredentials());
483     FrameLoader::reportAuthenticationChallengeBlocked(m_frame.get(), m_request.url(), &quot;it is a cross-origin request&quot;_s);
484 }
485 
486 void ResourceLoader::didReceiveResponse(const ResourceResponse&amp; r, CompletionHandler&lt;void()&gt;&amp;&amp; policyCompletionHandler)
487 {
488     ASSERT(!m_reachedTerminalState);
489     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(policyCompletionHandler));
490 
491     // Protect this in this delegate method since the additional processing can do
492     // anything including possibly derefing this; one example of this is Radar 3266216.
493     Ref&lt;ResourceLoader&gt; protectedThis(*this);
494 
495     logResourceResponseSource(m_frame.get(), r.source());
496 
497     m_response = r;
498 
499     if (m_options.sendLoadCallbacks == SendCallbackPolicy::SendCallbacks)
500         frameLoader()-&gt;notifier().didReceiveResponse(this, m_response);
501 }
502 
503 void ResourceLoader::didReceiveData(const char* data, unsigned length, long long encodedDataLength, DataPayloadType dataPayloadType)
504 {
505     // The following assertions are not quite valid here, since a subclass
506     // might override didReceiveData in a way that invalidates them. This
507     // happens with the steps listed in 3266216
508     // ASSERT(con == connection);
509     // ASSERT(!m_reachedTerminalState);
510 
511     didReceiveDataOrBuffer(data, length, nullptr, encodedDataLength, dataPayloadType);
512 }
513 
514 void ResourceLoader::didReceiveBuffer(Ref&lt;SharedBuffer&gt;&amp;&amp; buffer, long long encodedDataLength, DataPayloadType dataPayloadType)
515 {
516     didReceiveDataOrBuffer(nullptr, 0, WTFMove(buffer), encodedDataLength, dataPayloadType);
517 }
518 
519 void ResourceLoader::didReceiveDataOrBuffer(const char* data, unsigned length, RefPtr&lt;SharedBuffer&gt;&amp;&amp; buffer, long long encodedDataLength, DataPayloadType dataPayloadType)
520 {
521     // This method should only get data+length *OR* a SharedBuffer.
522     ASSERT(!buffer || (!data &amp;&amp; !length));
523 
524     // Protect this in this delegate method since the additional processing can do
525     // anything including possibly derefing this; one example of this is Radar 3266216.
526     Ref&lt;ResourceLoader&gt; protectedThis(*this);
527 
528     addDataOrBuffer(data, length, buffer.get(), dataPayloadType);
529 
530     // FIXME: If we get a resource with more than 2B bytes, this code won&#39;t do the right thing.
531     // However, with today&#39;s computers and networking speeds, this won&#39;t happen in practice.
532     // Could be an issue with a giant local file.
533     if (m_options.sendLoadCallbacks == SendCallbackPolicy::SendCallbacks &amp;&amp; m_frame)
534         frameLoader()-&gt;notifier().didReceiveData(this, buffer ? buffer-&gt;data() : data, buffer ? buffer-&gt;size() : length, static_cast&lt;int&gt;(encodedDataLength));
535 }
536 
537 void ResourceLoader::didFinishLoading(const NetworkLoadMetrics&amp; networkLoadMetrics)
538 {
539     RELEASE_LOG_IF_ALLOWED(&quot;didFinishLoading: (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
540 
541     didFinishLoadingOnePart(networkLoadMetrics);
542 
543     // If the load has been cancelled by a delegate in response to didFinishLoad(), do not release
544     // the resources a second time, they have been released by cancel.
545     if (wasCancelled())
546         return;
547     releaseResources();
548 }
549 
550 void ResourceLoader::didFinishLoadingOnePart(const NetworkLoadMetrics&amp; networkLoadMetrics)
551 {
552     // If load has been cancelled after finishing (which could happen with a
553     // JavaScript that changes the window location), do nothing.
554     if (wasCancelled())
555         return;
556     ASSERT(!m_reachedTerminalState);
557 
558     if (m_notifiedLoadComplete)
559         return;
560     m_notifiedLoadComplete = true;
561     if (m_options.sendLoadCallbacks == SendCallbackPolicy::SendCallbacks)
562         frameLoader()-&gt;notifier().didFinishLoad(this, networkLoadMetrics);
563 }
564 
565 void ResourceLoader::didFail(const ResourceError&amp; error)
566 {
567     RELEASE_LOG_IF_ALLOWED(&quot;didFail: (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
568 
569     if (wasCancelled())
570         return;
571     ASSERT(!m_reachedTerminalState);
572 
573     // Protect this in this delegate method since the additional processing can do
574     // anything including possibly derefing this; one example of this is Radar 3266216.
575     Ref&lt;ResourceLoader&gt; protectedThis(*this);
576 
577     cleanupForError(error);
578     releaseResources();
579 }
580 
581 void ResourceLoader::cleanupForError(const ResourceError&amp; error)
582 {
583     if (m_notifiedLoadComplete)
584         return;
585     m_notifiedLoadComplete = true;
586     if (m_options.sendLoadCallbacks == SendCallbackPolicy::SendCallbacks &amp;&amp; m_identifier)
587         frameLoader()-&gt;notifier().didFailToLoad(this, error);
588 }
589 
590 void ResourceLoader::cancel()
591 {
592     cancel(ResourceError());
593 }
594 
595 void ResourceLoader::cancel(const ResourceError&amp; error)
596 {
597     // If the load has already completed - succeeded, failed, or previously cancelled - do nothing.
598     if (m_reachedTerminalState)
599         return;
600 
601     ResourceError nonNullError = error.isNull() ? cancelledError() : error;
602 
603     // willCancel() and didFailToLoad() both call out to clients that might do
604     // something causing the last reference to this object to go away.
605     Ref&lt;ResourceLoader&gt; protectedThis(*this);
606 
607     // If we re-enter cancel() from inside willCancel(), we want to pick up from where we left
608     // off without re-running willCancel()
609     if (m_cancellationStatus == NotCancelled) {
610         m_cancellationStatus = CalledWillCancel;
611 
612         willCancel(nonNullError);
613     }
614 
615     // If we re-enter cancel() from inside didFailToLoad(), we want to pick up from where we
616     // left off without redoing any of this work.
617     if (m_cancellationStatus == CalledWillCancel) {
618         m_cancellationStatus = Cancelled;
619 
620         if (m_handle)
621             m_handle-&gt;clearAuthentication();
622 
623         m_documentLoader-&gt;cancelPendingSubstituteLoad(this);
624         if (m_handle) {
625             m_handle-&gt;cancel();
626             m_handle = nullptr;
627         }
628         cleanupForError(nonNullError);
629     }
630 
631     // If cancel() completed from within the call to willCancel() or didFailToLoad(),
632     // we don&#39;t want to redo didCancel() or releasesResources().
633     if (m_reachedTerminalState)
634         return;
635 
636     didCancel(nonNullError);
637 
638     if (m_cancellationStatus == FinishedCancel)
639         return;
640     m_cancellationStatus = FinishedCancel;
641 
642     releaseResources();
643 }
644 
645 ResourceError ResourceLoader::cancelledError()
646 {
647     return frameLoader()-&gt;cancelledError(m_request);
648 }
649 
650 ResourceError ResourceLoader::blockedError()
651 {
652     return frameLoader()-&gt;client().blockedError(m_request);
653 }
654 
655 ResourceError ResourceLoader::blockedByContentBlockerError()
656 {
657     return frameLoader()-&gt;client().blockedByContentBlockerError(m_request);
658 }
659 
660 ResourceError ResourceLoader::cannotShowURLError()
661 {
662     return frameLoader()-&gt;client().cannotShowURLError(m_request);
663 }
664 
665 void ResourceLoader::willSendRequestAsync(ResourceHandle* handle, ResourceRequest&amp;&amp; request, ResourceResponse&amp;&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
666 {
667     RefPtr&lt;ResourceHandle&gt; protectedHandle(handle);
668     if (documentLoader()-&gt;applicationCacheHost().maybeLoadFallbackForRedirect(this, request, redirectResponse)) {
669         RELEASE_LOG_IF_ALLOWED(&quot;willSendRequestAsync: exiting early because maybeLoadFallbackForRedirect returned false (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
670         completionHandler(WTFMove(request));
671         return;
672     }
673     willSendRequestInternal(WTFMove(request), redirectResponse, WTFMove(completionHandler));
674 }
675 
676 void ResourceLoader::didSendData(ResourceHandle*, unsigned long long bytesSent, unsigned long long totalBytesToBeSent)
677 {
678     didSendData(bytesSent, totalBytesToBeSent);
679 }
680 
681 void ResourceLoader::didReceiveResponseAsync(ResourceHandle*, ResourceResponse&amp;&amp; response, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
682 {
683     if (documentLoader()-&gt;applicationCacheHost().maybeLoadFallbackForResponse(this, response)) {
684         completionHandler();
685         return;
686     }
687     didReceiveResponse(response, WTFMove(completionHandler));
688 }
689 
690 void ResourceLoader::didReceiveData(ResourceHandle*, const char* data, unsigned length, int encodedDataLength)
691 {
692     didReceiveData(data, length, encodedDataLength, DataPayloadBytes);
693 }
694 
695 void ResourceLoader::didReceiveBuffer(ResourceHandle*, Ref&lt;SharedBuffer&gt;&amp;&amp; buffer, int encodedDataLength)
696 {
697     didReceiveBuffer(WTFMove(buffer), encodedDataLength, DataPayloadBytes);
698 }
699 
700 void ResourceLoader::didFinishLoading(ResourceHandle*)
701 {
702     NetworkLoadMetrics emptyMetrics;
703     didFinishLoading(emptyMetrics);
704 }
705 
706 void ResourceLoader::didFail(ResourceHandle*, const ResourceError&amp; error)
707 {
708     if (documentLoader()-&gt;applicationCacheHost().maybeLoadFallbackForError(this, error))
709         return;
710     didFail(error);
711 }
712 
713 void ResourceLoader::wasBlocked(ResourceHandle*)
714 {
715     RELEASE_LOG_IF_ALLOWED(&quot;wasBlocked: resource load canceled because of content blocker (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
716     didFail(blockedError());
717 }
718 
719 void ResourceLoader::cannotShowURL(ResourceHandle*)
720 {
721     RELEASE_LOG_IF_ALLOWED(&quot;wasBlocked: resource load canceled because of invalid URL (frame = %p, frameLoader = %p, resourceID = %lu)&quot;, frame(), frameLoader(), identifier());
722     didFail(cannotShowURLError());
723 }
724 
725 bool ResourceLoader::shouldUseCredentialStorage()
726 {
727     if (m_options.storedCredentialsPolicy != StoredCredentialsPolicy::Use)
728         return false;
729 
730     Ref&lt;ResourceLoader&gt; protectedThis(*this);
731     return frameLoader()-&gt;client().shouldUseCredentialStorage(documentLoader(), identifier());
732 }
733 
734 bool ResourceLoader::isAllowedToAskUserForCredentials() const
735 {
736     if (m_options.clientCredentialPolicy == ClientCredentialPolicy::CannotAskClientForCredentials)
737         return false;
738     if (!shouldAllowResourceToAskForCredentials())
739         return false;
740     return m_options.credentials == FetchOptions::Credentials::Include || (m_options.credentials == FetchOptions::Credentials::SameOrigin &amp;&amp; m_frame-&gt;document()-&gt;securityOrigin().canRequest(originalRequest().url()));
741 }
742 
743 bool ResourceLoader::shouldIncludeCertificateInfo() const
744 {
745     if (m_options.certificateInfoPolicy == CertificateInfoPolicy::IncludeCertificateInfo)
746         return true;
747     if (UNLIKELY(InspectorInstrumentation::hasFrontends()))
748         return true;
749     return false;
750 }
751 
752 void ResourceLoader::didReceiveAuthenticationChallenge(ResourceHandle* handle, const AuthenticationChallenge&amp; challenge)
753 {
754     ASSERT_UNUSED(handle, handle == m_handle);
755     ASSERT(m_handle-&gt;hasAuthenticationChallenge());
756 
757     // Protect this in this delegate method since the additional processing can do
758     // anything including possibly derefing this; one example of this is Radar 3266216.
759     Ref&lt;ResourceLoader&gt; protectedThis(*this);
760 
761     if (m_options.storedCredentialsPolicy == StoredCredentialsPolicy::Use) {
762         if (isAllowedToAskUserForCredentials()) {
763             frameLoader()-&gt;notifier().didReceiveAuthenticationChallenge(this, challenge);
764             return;
765         }
766         didBlockAuthenticationChallenge();
767     }
768     challenge.authenticationClient()-&gt;receivedRequestToContinueWithoutCredential(challenge);
769     ASSERT(!m_handle || !m_handle-&gt;hasAuthenticationChallenge());
770 }
771 
772 #if USE(PROTECTION_SPACE_AUTH_CALLBACK)
773 void ResourceLoader::canAuthenticateAgainstProtectionSpaceAsync(ResourceHandle*, const ProtectionSpace&amp; protectionSpace, CompletionHandler&lt;void(bool)&gt;&amp;&amp; completionHandler)
774 {
775     completionHandler(canAuthenticateAgainstProtectionSpace(protectionSpace));
776 }
777 
778 bool ResourceLoader::canAuthenticateAgainstProtectionSpace(const ProtectionSpace&amp; protectionSpace)
779 {
780     Ref&lt;ResourceLoader&gt; protectedThis(*this);
781     return frameLoader()-&gt;client().canAuthenticateAgainstProtectionSpace(documentLoader(), identifier(), protectionSpace);
782 }
783 
784 #endif
785 
786 #if PLATFORM(IOS_FAMILY)
787 
788 RetainPtr&lt;CFDictionaryRef&gt; ResourceLoader::connectionProperties(ResourceHandle*)
789 {
790     return frameLoader()-&gt;connectionProperties(this);
791 }
792 
793 #endif
794 
795 void ResourceLoader::receivedCancellation(const AuthenticationChallenge&amp;)
796 {
797     cancel();
798 }
799 
800 #if PLATFORM(COCOA)
801 
802 void ResourceLoader::schedule(SchedulePair&amp; pair)
803 {
804     if (m_handle)
805         m_handle-&gt;schedule(pair);
806 }
807 
808 void ResourceLoader::unschedule(SchedulePair&amp; pair)
809 {
810     if (m_handle)
811         m_handle-&gt;unschedule(pair);
812 }
813 
814 #endif
815 
816 #if USE(QUICK_LOOK)
817 bool ResourceLoader::isQuickLookResource() const
818 {
819     return !!m_previewLoader;
820 }
821 #endif
822 
823 bool ResourceLoader::isAlwaysOnLoggingAllowed() const
824 {
825     return frameLoader() &amp;&amp; frameLoader()-&gt;isAlwaysOnLoggingAllowed();
826 }
827 
828 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
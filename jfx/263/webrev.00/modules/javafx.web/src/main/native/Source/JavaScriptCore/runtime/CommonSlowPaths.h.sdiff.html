<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CommonSlowPaths.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CommonSlowPaths.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Completion.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CommonSlowPaths.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
<span class="line-removed"> 28 #include &quot;BytecodeStructs.h&quot;</span>
 29 #include &quot;CodeBlock.h&quot;
 30 #include &quot;CodeSpecializationKind.h&quot;
 31 #include &quot;DirectArguments.h&quot;
 32 #include &quot;ExceptionHelpers.h&quot;
 33 #include &quot;FunctionCodeBlock.h&quot;
 34 #include &quot;JSImmutableButterfly.h&quot;
 35 #include &quot;ScopedArguments.h&quot;
 36 #include &quot;SlowPathReturnType.h&quot;
 37 #include &quot;StackAlignment.h&quot;
 38 #include &quot;VMInlines.h&quot;
 39 #include &lt;wtf/StdLibExtras.h&gt;
 40 
 41 namespace JSC {
 42 
 43 // The purpose of this namespace is to include slow paths that are shared
 44 // between the interpreter and baseline JIT. They are written to be agnostic
 45 // with respect to the slow-path calling convention, but they do rely on the
 46 // JS code being executed more-or-less directly from bytecode (so the call
 47 // frame layout is unmodified, making it potentially awkward to use these
 48 // from any optimizing JIT, like the DFG).
</pre>
<hr />
<pre>
 55     int alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), frameSize);
 56     return alignedFrameSize - frameSize;
 57 }
 58 
 59 ALWAYS_INLINE int numberOfStackPaddingSlots(CodeBlock* codeBlock, int argumentCountIncludingThis)
 60 {
 61     if (argumentCountIncludingThis &gt;= codeBlock-&gt;numParameters())
 62         return 0;
 63     int alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), argumentCountIncludingThis + CallFrame::headerSizeInRegisters);
 64     int alignedFrameSizeForParameters = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), codeBlock-&gt;numParameters() + CallFrame::headerSizeInRegisters);
 65     return alignedFrameSizeForParameters - alignedFrameSize;
 66 }
 67 
 68 ALWAYS_INLINE int numberOfStackPaddingSlotsWithExtraSlots(CodeBlock* codeBlock, int argumentCountIncludingThis)
 69 {
 70     if (argumentCountIncludingThis &gt;= codeBlock-&gt;numParameters())
 71         return 0;
 72     return numberOfStackPaddingSlots(codeBlock, argumentCountIncludingThis) + numberOfExtraSlots(argumentCountIncludingThis);
 73 }
 74 
<span class="line-modified"> 75 ALWAYS_INLINE CodeBlock* codeBlockFromCallFrameCallee(ExecState* exec, CodeSpecializationKind kind)</span>
 76 {
<span class="line-modified"> 77     JSFunction* callee = jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee());</span>
 78     ASSERT(!callee-&gt;isHostFunction());
 79     return callee-&gt;jsExecutable()-&gt;codeBlockFor(kind);
 80 }
 81 
<span class="line-modified"> 82 ALWAYS_INLINE int arityCheckFor(ExecState* exec, VM&amp; vm, CodeSpecializationKind kind)</span>
 83 {
<span class="line-modified"> 84     CodeBlock* newCodeBlock = codeBlockFromCallFrameCallee(exec, kind);</span>
<span class="line-modified"> 85     ASSERT(exec-&gt;argumentCountIncludingThis() &lt; static_cast&lt;unsigned&gt;(newCodeBlock-&gt;numParameters()));</span>
<span class="line-modified"> 86     int padding = numberOfStackPaddingSlotsWithExtraSlots(newCodeBlock, exec-&gt;argumentCountIncludingThis());</span>
 87 
<span class="line-modified"> 88     Register* newStack = exec-&gt;registers() - WTF::roundUpToMultipleOf(stackAlignmentRegisters(), padding);</span>
 89 
 90     if (UNLIKELY(!vm.ensureStackCapacityFor(newStack)))
 91         return -1;
 92     return padding;
 93 }
 94 
<span class="line-modified"> 95 inline bool opInByVal(ExecState* exec, JSValue baseVal, JSValue propName, ArrayProfile* arrayProfile = nullptr)</span>
 96 {
<span class="line-modified"> 97     VM&amp; vm = exec-&gt;vm();</span>
 98     auto scope = DECLARE_THROW_SCOPE(vm);
 99     if (!baseVal.isObject()) {
<span class="line-modified">100         throwException(exec, scope, createInvalidInParameterError(exec, baseVal));</span>
101         return false;
102     }
103 
104     JSObject* baseObj = asObject(baseVal);
105     if (arrayProfile)
106         arrayProfile-&gt;observeStructure(baseObj-&gt;structure(vm));
107 
108     uint32_t i;
109     if (propName.getUInt32(i)) {
110         if (arrayProfile)
111             arrayProfile-&gt;observeIndexedRead(vm, baseObj, i);
<span class="line-modified">112         RELEASE_AND_RETURN(scope, baseObj-&gt;hasProperty(exec, i));</span>
113     }
114 
<span class="line-modified">115     auto property = propName.toPropertyKey(exec);</span>
116     RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">117     RELEASE_AND_RETURN(scope, baseObj-&gt;hasProperty(exec, property));</span>
<span class="line-removed">118 }</span>
<span class="line-removed">119 </span>
<span class="line-removed">120 inline void tryCachePutToScopeGlobal(</span>
<span class="line-removed">121     ExecState* exec, CodeBlock* codeBlock, OpPutToScope&amp; bytecode, JSObject* scope,</span>
<span class="line-removed">122     PutPropertySlot&amp; slot, const Identifier&amp; ident)</span>
<span class="line-removed">123 {</span>
<span class="line-removed">124     // Covers implicit globals. Since they don&#39;t exist until they first execute, we didn&#39;t know how to cache them at compile time.</span>
<span class="line-removed">125     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-removed">126     ResolveType resolveType = metadata.m_getPutInfo.resolveType();</span>
<span class="line-removed">127 </span>
<span class="line-removed">128     switch (resolveType) {</span>
<span class="line-removed">129     case UnresolvedProperty:</span>
<span class="line-removed">130     case UnresolvedPropertyWithVarInjectionChecks: {</span>
<span class="line-removed">131         if (scope-&gt;isGlobalObject()) {</span>
<span class="line-removed">132             ResolveType newResolveType = needsVarInjectionChecks(resolveType) ? GlobalPropertyWithVarInjectionChecks : GlobalProperty;</span>
<span class="line-removed">133             resolveType = newResolveType; // Allow below caching mechanism to kick in.</span>
<span class="line-removed">134             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-removed">135             metadata.m_getPutInfo = GetPutInfo(metadata.m_getPutInfo.resolveMode(), newResolveType, metadata.m_getPutInfo.initializationMode());</span>
<span class="line-removed">136             break;</span>
<span class="line-removed">137         }</span>
<span class="line-removed">138         FALLTHROUGH;</span>
<span class="line-removed">139     }</span>
<span class="line-removed">140     case GlobalProperty:</span>
<span class="line-removed">141     case GlobalPropertyWithVarInjectionChecks: {</span>
<span class="line-removed">142          // Global Lexical Binding Epoch is changed. Update op_get_from_scope from GlobalProperty to GlobalLexicalVar.</span>
<span class="line-removed">143         if (scope-&gt;isGlobalLexicalEnvironment()) {</span>
<span class="line-removed">144             JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(scope);</span>
<span class="line-removed">145             ResolveType newResolveType = needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar;</span>
<span class="line-removed">146             metadata.m_getPutInfo = GetPutInfo(metadata.m_getPutInfo.resolveMode(), newResolveType, metadata.m_getPutInfo.initializationMode());</span>
<span class="line-removed">147             SymbolTableEntry entry = globalLexicalEnvironment-&gt;symbolTable()-&gt;get(ident.impl());</span>
<span class="line-removed">148             ASSERT(!entry.isNull());</span>
<span class="line-removed">149             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-removed">150             metadata.m_watchpointSet = entry.watchpointSet();</span>
<span class="line-removed">151             metadata.m_operand = reinterpret_cast&lt;uintptr_t&gt;(globalLexicalEnvironment-&gt;variableAt(entry.scopeOffset()).slot());</span>
<span class="line-removed">152             return;</span>
<span class="line-removed">153         }</span>
<span class="line-removed">154         break;</span>
<span class="line-removed">155     }</span>
<span class="line-removed">156     default:</span>
<span class="line-removed">157         return;</span>
<span class="line-removed">158     }</span>
<span class="line-removed">159 </span>
<span class="line-removed">160     if (resolveType == GlobalProperty || resolveType == GlobalPropertyWithVarInjectionChecks) {</span>
<span class="line-removed">161         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">162         JSGlobalObject* globalObject = codeBlock-&gt;globalObject();</span>
<span class="line-removed">163         ASSERT(globalObject == scope || globalObject-&gt;varInjectionWatchpoint()-&gt;hasBeenInvalidated());</span>
<span class="line-removed">164         if (!slot.isCacheablePut()</span>
<span class="line-removed">165             || slot.base() != scope</span>
<span class="line-removed">166             || scope != globalObject</span>
<span class="line-removed">167             || !scope-&gt;structure(vm)-&gt;propertyAccessesAreCacheable())</span>
<span class="line-removed">168             return;</span>
<span class="line-removed">169 </span>
<span class="line-removed">170         if (slot.type() == PutPropertySlot::NewProperty) {</span>
<span class="line-removed">171             // Don&#39;t cache if we&#39;ve done a transition. We want to detect the first replace so that we</span>
<span class="line-removed">172             // can invalidate the watchpoint.</span>
<span class="line-removed">173             return;</span>
<span class="line-removed">174         }</span>
<span class="line-removed">175 </span>
<span class="line-removed">176         scope-&gt;structure(vm)-&gt;didCachePropertyReplacement(vm, slot.cachedOffset());</span>
<span class="line-removed">177 </span>
<span class="line-removed">178         ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-removed">179         metadata.m_structure.set(vm, codeBlock, scope-&gt;structure(vm));</span>
<span class="line-removed">180         metadata.m_operand = slot.cachedOffset();</span>
<span class="line-removed">181     }</span>
<span class="line-removed">182 }</span>
<span class="line-removed">183 </span>
<span class="line-removed">184 inline void tryCacheGetFromScopeGlobal(</span>
<span class="line-removed">185     ExecState* exec, VM&amp; vm, OpGetFromScope&amp; bytecode, JSObject* scope, PropertySlot&amp; slot, const Identifier&amp; ident)</span>
<span class="line-removed">186 {</span>
<span class="line-removed">187     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-removed">188     ResolveType resolveType = metadata.m_getPutInfo.resolveType();</span>
<span class="line-removed">189 </span>
<span class="line-removed">190     switch (resolveType) {</span>
<span class="line-removed">191     case UnresolvedProperty:</span>
<span class="line-removed">192     case UnresolvedPropertyWithVarInjectionChecks: {</span>
<span class="line-removed">193         if (scope-&gt;isGlobalObject()) {</span>
<span class="line-removed">194             ResolveType newResolveType = needsVarInjectionChecks(resolveType) ? GlobalPropertyWithVarInjectionChecks : GlobalProperty;</span>
<span class="line-removed">195             resolveType = newResolveType; // Allow below caching mechanism to kick in.</span>
<span class="line-removed">196             ConcurrentJSLocker locker(exec-&gt;codeBlock()-&gt;m_lock);</span>
<span class="line-removed">197             metadata.m_getPutInfo = GetPutInfo(metadata.m_getPutInfo.resolveMode(), newResolveType, metadata.m_getPutInfo.initializationMode());</span>
<span class="line-removed">198             break;</span>
<span class="line-removed">199         }</span>
<span class="line-removed">200         FALLTHROUGH;</span>
<span class="line-removed">201     }</span>
<span class="line-removed">202     case GlobalProperty:</span>
<span class="line-removed">203     case GlobalPropertyWithVarInjectionChecks: {</span>
<span class="line-removed">204          // Global Lexical Binding Epoch is changed. Update op_get_from_scope from GlobalProperty to GlobalLexicalVar.</span>
<span class="line-removed">205         if (scope-&gt;isGlobalLexicalEnvironment()) {</span>
<span class="line-removed">206             JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(scope);</span>
<span class="line-removed">207             ResolveType newResolveType = needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar;</span>
<span class="line-removed">208             SymbolTableEntry entry = globalLexicalEnvironment-&gt;symbolTable()-&gt;get(ident.impl());</span>
<span class="line-removed">209             ASSERT(!entry.isNull());</span>
<span class="line-removed">210             ConcurrentJSLocker locker(exec-&gt;codeBlock()-&gt;m_lock);</span>
<span class="line-removed">211             metadata.m_getPutInfo = GetPutInfo(metadata.m_getPutInfo.resolveMode(), newResolveType, metadata.m_getPutInfo.initializationMode());</span>
<span class="line-removed">212             metadata.m_watchpointSet = entry.watchpointSet();</span>
<span class="line-removed">213             metadata.m_operand = reinterpret_cast&lt;uintptr_t&gt;(globalLexicalEnvironment-&gt;variableAt(entry.scopeOffset()).slot());</span>
<span class="line-removed">214             return;</span>
<span class="line-removed">215         }</span>
<span class="line-removed">216         break;</span>
<span class="line-removed">217     }</span>
<span class="line-removed">218     default:</span>
<span class="line-removed">219         return;</span>
<span class="line-removed">220     }</span>
<span class="line-removed">221 </span>
<span class="line-removed">222     // Covers implicit globals. Since they don&#39;t exist until they first execute, we didn&#39;t know how to cache them at compile time.</span>
<span class="line-removed">223     if (resolveType == GlobalProperty || resolveType == GlobalPropertyWithVarInjectionChecks) {</span>
<span class="line-removed">224         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">225         JSGlobalObject* globalObject = codeBlock-&gt;globalObject();</span>
<span class="line-removed">226         ASSERT(scope == globalObject || globalObject-&gt;varInjectionWatchpoint()-&gt;hasBeenInvalidated());</span>
<span class="line-removed">227         if (slot.isCacheableValue() &amp;&amp; slot.slotBase() == scope &amp;&amp; scope == globalObject &amp;&amp; scope-&gt;structure(vm)-&gt;propertyAccessesAreCacheable()) {</span>
<span class="line-removed">228             Structure* structure = scope-&gt;structure(vm);</span>
<span class="line-removed">229             {</span>
<span class="line-removed">230                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-removed">231                 metadata.m_structure.set(vm, codeBlock, structure);</span>
<span class="line-removed">232                 metadata.m_operand = slot.cachedOffset();</span>
<span class="line-removed">233             }</span>
<span class="line-removed">234             structure-&gt;startWatchingPropertyForReplacements(vm, slot.cachedOffset());</span>
<span class="line-removed">235         }</span>
<span class="line-removed">236     }</span>
237 }
238 
239 inline bool canAccessArgumentIndexQuickly(JSObject&amp; object, uint32_t index)
240 {
241     switch (object.type()) {
242     case DirectArgumentsType: {
243         DirectArguments* directArguments = jsCast&lt;DirectArguments*&gt;(&amp;object);
244         if (directArguments-&gt;isMappedArgumentInDFG(index))
245             return true;
246         break;
247     }
248     case ScopedArgumentsType: {
249         ScopedArguments* scopedArguments = jsCast&lt;ScopedArguments*&gt;(&amp;object);
250         if (scopedArguments-&gt;isMappedArgumentInDFG(index))
251             return true;
252         break;
253     }
254     default:
255         break;
256     }
257     return false;
258 }
259 
<span class="line-modified">260 static ALWAYS_INLINE void putDirectWithReify(VM&amp; vm, ExecState* exec, JSObject* baseObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot, Structure** result = nullptr)</span>
261 {
262     auto scope = DECLARE_THROW_SCOPE(vm);
263     if (baseObject-&gt;inherits&lt;JSFunction&gt;(vm)) {
<span class="line-modified">264         jsCast&lt;JSFunction*&gt;(baseObject)-&gt;reifyLazyPropertyIfNeeded(vm, exec, propertyName);</span>
265         RETURN_IF_EXCEPTION(scope, void());
266     }
267     if (result)
268         *result = baseObject-&gt;structure(vm);
269     scope.release();
270     baseObject-&gt;putDirect(vm, propertyName, value, slot);
271 }
272 
<span class="line-modified">273 static ALWAYS_INLINE void putDirectAccessorWithReify(VM&amp; vm, ExecState* exec, JSObject* baseObject, PropertyName propertyName, GetterSetter* accessor, unsigned attribute)</span>
274 {
275     auto scope = DECLARE_THROW_SCOPE(vm);
276     if (baseObject-&gt;inherits&lt;JSFunction&gt;(vm)) {
<span class="line-modified">277         jsCast&lt;JSFunction*&gt;(baseObject)-&gt;reifyLazyPropertyIfNeeded(vm, exec, propertyName);</span>
278         RETURN_IF_EXCEPTION(scope, void());
279     }
280     scope.release();
<span class="line-modified">281     baseObject-&gt;putDirectAccessor(exec, propertyName, accessor, attribute);</span>
282 }
283 
284 inline JSArray* allocateNewArrayBuffer(VM&amp; vm, Structure* structure, JSImmutableButterfly* immutableButterfly)
285 {
286     JSGlobalObject* globalObject = structure-&gt;globalObject();
287     Structure* originalStructure = globalObject-&gt;originalArrayStructureForIndexingType(immutableButterfly-&gt;indexingMode());
288     ASSERT(originalStructure-&gt;indexingMode() == immutableButterfly-&gt;indexingMode());
289     ASSERT(isCopyOnWrite(immutableButterfly-&gt;indexingMode()));
290     ASSERT(!structure-&gt;outOfLineCapacity());
291 
292     JSArray* result = JSArray::createWithButterfly(vm, nullptr, originalStructure, immutableButterfly-&gt;toButterfly());
293     // FIXME: This works but it&#39;s slow. If we cared enough about the perf when having a bad time then we could fix it.
294     if (UNLIKELY(originalStructure != structure)) {
295         ASSERT(hasSlowPutArrayStorage(structure-&gt;indexingMode()));
296         ASSERT(globalObject-&gt;isHavingABadTime());
297 
298         result-&gt;switchToSlowPutArrayStorage(vm);
299         ASSERT(result-&gt;butterfly() != immutableButterfly-&gt;toButterfly());
300         ASSERT(!result-&gt;butterfly()-&gt;arrayStorage()-&gt;m_sparseMap.get());
301         ASSERT(result-&gt;structureID() == structure-&gt;id());
302     }
303 
304     return result;
305 }
306 
307 } // namespace CommonSlowPaths
308 
<span class="line-modified">309 class ExecState;</span>
310 struct Instruction;
311 
312 #define SLOW_PATH
313 
314 #define SLOW_PATH_DECL(name) \
<span class="line-modified">315 extern &quot;C&quot; SlowPathReturnType SLOW_PATH name(ExecState* exec, const Instruction* pc)</span>
316 
317 #define SLOW_PATH_HIDDEN_DECL(name) \
318 SLOW_PATH_DECL(name) WTF_INTERNAL
319 
320 SLOW_PATH_HIDDEN_DECL(slow_path_call_arityCheck);
321 SLOW_PATH_HIDDEN_DECL(slow_path_construct_arityCheck);
322 SLOW_PATH_HIDDEN_DECL(slow_path_create_direct_arguments);
323 SLOW_PATH_HIDDEN_DECL(slow_path_create_scoped_arguments);
324 SLOW_PATH_HIDDEN_DECL(slow_path_create_cloned_arguments);

325 SLOW_PATH_HIDDEN_DECL(slow_path_create_this);

326 SLOW_PATH_HIDDEN_DECL(slow_path_get_callee);
327 SLOW_PATH_HIDDEN_DECL(slow_path_to_this);
328 SLOW_PATH_HIDDEN_DECL(slow_path_throw_tdz_error);
329 SLOW_PATH_HIDDEN_DECL(slow_path_check_tdz);
330 SLOW_PATH_HIDDEN_DECL(slow_path_throw_strict_mode_readonly_property_write_error);
331 SLOW_PATH_HIDDEN_DECL(slow_path_not);
332 SLOW_PATH_HIDDEN_DECL(slow_path_eq);
333 SLOW_PATH_HIDDEN_DECL(slow_path_neq);
334 SLOW_PATH_HIDDEN_DECL(slow_path_stricteq);
335 SLOW_PATH_HIDDEN_DECL(slow_path_nstricteq);
336 SLOW_PATH_HIDDEN_DECL(slow_path_less);
337 SLOW_PATH_HIDDEN_DECL(slow_path_lesseq);
338 SLOW_PATH_HIDDEN_DECL(slow_path_greater);
339 SLOW_PATH_HIDDEN_DECL(slow_path_greatereq);
340 SLOW_PATH_HIDDEN_DECL(slow_path_inc);
341 SLOW_PATH_HIDDEN_DECL(slow_path_dec);
342 SLOW_PATH_HIDDEN_DECL(slow_path_to_number);

343 SLOW_PATH_HIDDEN_DECL(slow_path_to_string);
344 SLOW_PATH_HIDDEN_DECL(slow_path_to_object);
345 SLOW_PATH_HIDDEN_DECL(slow_path_negate);
346 SLOW_PATH_HIDDEN_DECL(slow_path_add);
347 SLOW_PATH_HIDDEN_DECL(slow_path_mul);
348 SLOW_PATH_HIDDEN_DECL(slow_path_sub);
349 SLOW_PATH_HIDDEN_DECL(slow_path_div);
350 SLOW_PATH_HIDDEN_DECL(slow_path_mod);
351 SLOW_PATH_HIDDEN_DECL(slow_path_pow);
352 SLOW_PATH_HIDDEN_DECL(slow_path_lshift);
353 SLOW_PATH_HIDDEN_DECL(slow_path_rshift);
354 SLOW_PATH_HIDDEN_DECL(slow_path_urshift);
355 SLOW_PATH_HIDDEN_DECL(slow_path_unsigned);
356 SLOW_PATH_HIDDEN_DECL(slow_path_bitnot);
357 SLOW_PATH_HIDDEN_DECL(slow_path_bitand);
358 SLOW_PATH_HIDDEN_DECL(slow_path_bitor);
359 SLOW_PATH_HIDDEN_DECL(slow_path_bitxor);
360 SLOW_PATH_HIDDEN_DECL(slow_path_typeof);
361 SLOW_PATH_HIDDEN_DECL(slow_path_is_object);
362 SLOW_PATH_HIDDEN_DECL(slow_path_is_object_or_null);
363 SLOW_PATH_HIDDEN_DECL(slow_path_is_function);
364 SLOW_PATH_HIDDEN_DECL(slow_path_in_by_id);
365 SLOW_PATH_HIDDEN_DECL(slow_path_in_by_val);
366 SLOW_PATH_HIDDEN_DECL(slow_path_del_by_val);
367 SLOW_PATH_HIDDEN_DECL(slow_path_strcat);
368 SLOW_PATH_HIDDEN_DECL(slow_path_to_primitive);

369 SLOW_PATH_HIDDEN_DECL(slow_path_get_enumerable_length);
370 SLOW_PATH_HIDDEN_DECL(slow_path_has_generic_property);
371 SLOW_PATH_HIDDEN_DECL(slow_path_has_structure_property);
372 SLOW_PATH_HIDDEN_DECL(slow_path_has_indexed_property);
373 SLOW_PATH_HIDDEN_DECL(slow_path_get_direct_pname);
374 SLOW_PATH_HIDDEN_DECL(slow_path_get_property_enumerator);
375 SLOW_PATH_HIDDEN_DECL(slow_path_enumerator_structure_pname);
376 SLOW_PATH_HIDDEN_DECL(slow_path_enumerator_generic_pname);
377 SLOW_PATH_HIDDEN_DECL(slow_path_to_index_string);
378 SLOW_PATH_HIDDEN_DECL(slow_path_profile_type_clear_log);
379 SLOW_PATH_HIDDEN_DECL(slow_path_unreachable);
380 SLOW_PATH_HIDDEN_DECL(slow_path_create_lexical_environment);
381 SLOW_PATH_HIDDEN_DECL(slow_path_push_with_scope);
382 SLOW_PATH_HIDDEN_DECL(slow_path_resolve_scope);
383 SLOW_PATH_HIDDEN_DECL(slow_path_is_var_scope);
384 SLOW_PATH_HIDDEN_DECL(slow_path_resolve_scope_for_hoisting_func_decl_in_eval);



385 SLOW_PATH_HIDDEN_DECL(slow_path_create_rest);
386 SLOW_PATH_HIDDEN_DECL(slow_path_get_by_id_with_this);
387 SLOW_PATH_HIDDEN_DECL(slow_path_get_by_val_with_this);
388 SLOW_PATH_HIDDEN_DECL(slow_path_put_by_id_with_this);
389 SLOW_PATH_HIDDEN_DECL(slow_path_put_by_val_with_this);
390 SLOW_PATH_HIDDEN_DECL(slow_path_define_data_property);
391 SLOW_PATH_HIDDEN_DECL(slow_path_define_accessor_property);
392 SLOW_PATH_HIDDEN_DECL(slow_path_throw_static_error);


393 SLOW_PATH_HIDDEN_DECL(slow_path_new_array_with_spread);
394 SLOW_PATH_HIDDEN_DECL(slow_path_new_array_buffer);
395 SLOW_PATH_HIDDEN_DECL(slow_path_spread);
396 
<span class="line-modified">397 using SlowPathFunction = SlowPathReturnType(SLOW_PATH *)(ExecState*, const Instruction*);</span>
398 
399 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 

 28 #include &quot;CodeBlock.h&quot;
 29 #include &quot;CodeSpecializationKind.h&quot;
 30 #include &quot;DirectArguments.h&quot;
 31 #include &quot;ExceptionHelpers.h&quot;
 32 #include &quot;FunctionCodeBlock.h&quot;
 33 #include &quot;JSImmutableButterfly.h&quot;
 34 #include &quot;ScopedArguments.h&quot;
 35 #include &quot;SlowPathReturnType.h&quot;
 36 #include &quot;StackAlignment.h&quot;
 37 #include &quot;VMInlines.h&quot;
 38 #include &lt;wtf/StdLibExtras.h&gt;
 39 
 40 namespace JSC {
 41 
 42 // The purpose of this namespace is to include slow paths that are shared
 43 // between the interpreter and baseline JIT. They are written to be agnostic
 44 // with respect to the slow-path calling convention, but they do rely on the
 45 // JS code being executed more-or-less directly from bytecode (so the call
 46 // frame layout is unmodified, making it potentially awkward to use these
 47 // from any optimizing JIT, like the DFG).
</pre>
<hr />
<pre>
 54     int alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), frameSize);
 55     return alignedFrameSize - frameSize;
 56 }
 57 
 58 ALWAYS_INLINE int numberOfStackPaddingSlots(CodeBlock* codeBlock, int argumentCountIncludingThis)
 59 {
 60     if (argumentCountIncludingThis &gt;= codeBlock-&gt;numParameters())
 61         return 0;
 62     int alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), argumentCountIncludingThis + CallFrame::headerSizeInRegisters);
 63     int alignedFrameSizeForParameters = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), codeBlock-&gt;numParameters() + CallFrame::headerSizeInRegisters);
 64     return alignedFrameSizeForParameters - alignedFrameSize;
 65 }
 66 
 67 ALWAYS_INLINE int numberOfStackPaddingSlotsWithExtraSlots(CodeBlock* codeBlock, int argumentCountIncludingThis)
 68 {
 69     if (argumentCountIncludingThis &gt;= codeBlock-&gt;numParameters())
 70         return 0;
 71     return numberOfStackPaddingSlots(codeBlock, argumentCountIncludingThis) + numberOfExtraSlots(argumentCountIncludingThis);
 72 }
 73 
<span class="line-modified"> 74 ALWAYS_INLINE CodeBlock* codeBlockFromCallFrameCallee(CallFrame* callFrame, CodeSpecializationKind kind)</span>
 75 {
<span class="line-modified"> 76     JSFunction* callee = jsCast&lt;JSFunction*&gt;(callFrame-&gt;jsCallee());</span>
 77     ASSERT(!callee-&gt;isHostFunction());
 78     return callee-&gt;jsExecutable()-&gt;codeBlockFor(kind);
 79 }
 80 
<span class="line-modified"> 81 ALWAYS_INLINE int arityCheckFor(VM&amp; vm, CallFrame* callFrame, CodeSpecializationKind kind)</span>
 82 {
<span class="line-modified"> 83     CodeBlock* newCodeBlock = codeBlockFromCallFrameCallee(callFrame, kind);</span>
<span class="line-modified"> 84     ASSERT(callFrame-&gt;argumentCountIncludingThis() &lt; static_cast&lt;unsigned&gt;(newCodeBlock-&gt;numParameters()));</span>
<span class="line-modified"> 85     int padding = numberOfStackPaddingSlotsWithExtraSlots(newCodeBlock, callFrame-&gt;argumentCountIncludingThis());</span>
 86 
<span class="line-modified"> 87     Register* newStack = callFrame-&gt;registers() - WTF::roundUpToMultipleOf(stackAlignmentRegisters(), padding);</span>
 88 
 89     if (UNLIKELY(!vm.ensureStackCapacityFor(newStack)))
 90         return -1;
 91     return padding;
 92 }
 93 
<span class="line-modified"> 94 inline bool opInByVal(JSGlobalObject* globalObject, JSValue baseVal, JSValue propName, ArrayProfile* arrayProfile = nullptr)</span>
 95 {
<span class="line-modified"> 96     VM&amp; vm = getVM(globalObject);</span>
 97     auto scope = DECLARE_THROW_SCOPE(vm);
 98     if (!baseVal.isObject()) {
<span class="line-modified"> 99         throwException(globalObject, scope, createInvalidInParameterError(globalObject, baseVal));</span>
100         return false;
101     }
102 
103     JSObject* baseObj = asObject(baseVal);
104     if (arrayProfile)
105         arrayProfile-&gt;observeStructure(baseObj-&gt;structure(vm));
106 
107     uint32_t i;
108     if (propName.getUInt32(i)) {
109         if (arrayProfile)
110             arrayProfile-&gt;observeIndexedRead(vm, baseObj, i);
<span class="line-modified">111         RELEASE_AND_RETURN(scope, baseObj-&gt;hasProperty(globalObject, i));</span>
112     }
113 
<span class="line-modified">114     auto property = propName.toPropertyKey(globalObject);</span>
115     RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">116     RELEASE_AND_RETURN(scope, baseObj-&gt;hasProperty(globalObject, property));</span>























































































































117 }
118 
119 inline bool canAccessArgumentIndexQuickly(JSObject&amp; object, uint32_t index)
120 {
121     switch (object.type()) {
122     case DirectArgumentsType: {
123         DirectArguments* directArguments = jsCast&lt;DirectArguments*&gt;(&amp;object);
124         if (directArguments-&gt;isMappedArgumentInDFG(index))
125             return true;
126         break;
127     }
128     case ScopedArgumentsType: {
129         ScopedArguments* scopedArguments = jsCast&lt;ScopedArguments*&gt;(&amp;object);
130         if (scopedArguments-&gt;isMappedArgumentInDFG(index))
131             return true;
132         break;
133     }
134     default:
135         break;
136     }
137     return false;
138 }
139 
<span class="line-modified">140 static ALWAYS_INLINE void putDirectWithReify(VM&amp; vm, JSGlobalObject* globalObject, JSObject* baseObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot, Structure** result = nullptr)</span>
141 {
142     auto scope = DECLARE_THROW_SCOPE(vm);
143     if (baseObject-&gt;inherits&lt;JSFunction&gt;(vm)) {
<span class="line-modified">144         jsCast&lt;JSFunction*&gt;(baseObject)-&gt;reifyLazyPropertyIfNeeded(vm, globalObject, propertyName);</span>
145         RETURN_IF_EXCEPTION(scope, void());
146     }
147     if (result)
148         *result = baseObject-&gt;structure(vm);
149     scope.release();
150     baseObject-&gt;putDirect(vm, propertyName, value, slot);
151 }
152 
<span class="line-modified">153 static ALWAYS_INLINE void putDirectAccessorWithReify(VM&amp; vm, JSGlobalObject* globalObject, JSObject* baseObject, PropertyName propertyName, GetterSetter* accessor, unsigned attribute)</span>
154 {
155     auto scope = DECLARE_THROW_SCOPE(vm);
156     if (baseObject-&gt;inherits&lt;JSFunction&gt;(vm)) {
<span class="line-modified">157         jsCast&lt;JSFunction*&gt;(baseObject)-&gt;reifyLazyPropertyIfNeeded(vm, globalObject, propertyName);</span>
158         RETURN_IF_EXCEPTION(scope, void());
159     }
160     scope.release();
<span class="line-modified">161     baseObject-&gt;putDirectAccessor(globalObject, propertyName, accessor, attribute);</span>
162 }
163 
164 inline JSArray* allocateNewArrayBuffer(VM&amp; vm, Structure* structure, JSImmutableButterfly* immutableButterfly)
165 {
166     JSGlobalObject* globalObject = structure-&gt;globalObject();
167     Structure* originalStructure = globalObject-&gt;originalArrayStructureForIndexingType(immutableButterfly-&gt;indexingMode());
168     ASSERT(originalStructure-&gt;indexingMode() == immutableButterfly-&gt;indexingMode());
169     ASSERT(isCopyOnWrite(immutableButterfly-&gt;indexingMode()));
170     ASSERT(!structure-&gt;outOfLineCapacity());
171 
172     JSArray* result = JSArray::createWithButterfly(vm, nullptr, originalStructure, immutableButterfly-&gt;toButterfly());
173     // FIXME: This works but it&#39;s slow. If we cared enough about the perf when having a bad time then we could fix it.
174     if (UNLIKELY(originalStructure != structure)) {
175         ASSERT(hasSlowPutArrayStorage(structure-&gt;indexingMode()));
176         ASSERT(globalObject-&gt;isHavingABadTime());
177 
178         result-&gt;switchToSlowPutArrayStorage(vm);
179         ASSERT(result-&gt;butterfly() != immutableButterfly-&gt;toButterfly());
180         ASSERT(!result-&gt;butterfly()-&gt;arrayStorage()-&gt;m_sparseMap.get());
181         ASSERT(result-&gt;structureID() == structure-&gt;id());
182     }
183 
184     return result;
185 }
186 
187 } // namespace CommonSlowPaths
188 
<span class="line-modified">189 class CallFrame;</span>
190 struct Instruction;
191 
192 #define SLOW_PATH
193 
194 #define SLOW_PATH_DECL(name) \
<span class="line-modified">195 extern &quot;C&quot; SlowPathReturnType SLOW_PATH name(CallFrame* callFrame, const Instruction* pc)</span>
196 
197 #define SLOW_PATH_HIDDEN_DECL(name) \
198 SLOW_PATH_DECL(name) WTF_INTERNAL
199 
200 SLOW_PATH_HIDDEN_DECL(slow_path_call_arityCheck);
201 SLOW_PATH_HIDDEN_DECL(slow_path_construct_arityCheck);
202 SLOW_PATH_HIDDEN_DECL(slow_path_create_direct_arguments);
203 SLOW_PATH_HIDDEN_DECL(slow_path_create_scoped_arguments);
204 SLOW_PATH_HIDDEN_DECL(slow_path_create_cloned_arguments);
<span class="line-added">205 SLOW_PATH_HIDDEN_DECL(slow_path_create_arguments_butterfly);</span>
206 SLOW_PATH_HIDDEN_DECL(slow_path_create_this);
<span class="line-added">207 SLOW_PATH_HIDDEN_DECL(slow_path_enter);</span>
208 SLOW_PATH_HIDDEN_DECL(slow_path_get_callee);
209 SLOW_PATH_HIDDEN_DECL(slow_path_to_this);
210 SLOW_PATH_HIDDEN_DECL(slow_path_throw_tdz_error);
211 SLOW_PATH_HIDDEN_DECL(slow_path_check_tdz);
212 SLOW_PATH_HIDDEN_DECL(slow_path_throw_strict_mode_readonly_property_write_error);
213 SLOW_PATH_HIDDEN_DECL(slow_path_not);
214 SLOW_PATH_HIDDEN_DECL(slow_path_eq);
215 SLOW_PATH_HIDDEN_DECL(slow_path_neq);
216 SLOW_PATH_HIDDEN_DECL(slow_path_stricteq);
217 SLOW_PATH_HIDDEN_DECL(slow_path_nstricteq);
218 SLOW_PATH_HIDDEN_DECL(slow_path_less);
219 SLOW_PATH_HIDDEN_DECL(slow_path_lesseq);
220 SLOW_PATH_HIDDEN_DECL(slow_path_greater);
221 SLOW_PATH_HIDDEN_DECL(slow_path_greatereq);
222 SLOW_PATH_HIDDEN_DECL(slow_path_inc);
223 SLOW_PATH_HIDDEN_DECL(slow_path_dec);
224 SLOW_PATH_HIDDEN_DECL(slow_path_to_number);
<span class="line-added">225 SLOW_PATH_HIDDEN_DECL(slow_path_to_numeric);</span>
226 SLOW_PATH_HIDDEN_DECL(slow_path_to_string);
227 SLOW_PATH_HIDDEN_DECL(slow_path_to_object);
228 SLOW_PATH_HIDDEN_DECL(slow_path_negate);
229 SLOW_PATH_HIDDEN_DECL(slow_path_add);
230 SLOW_PATH_HIDDEN_DECL(slow_path_mul);
231 SLOW_PATH_HIDDEN_DECL(slow_path_sub);
232 SLOW_PATH_HIDDEN_DECL(slow_path_div);
233 SLOW_PATH_HIDDEN_DECL(slow_path_mod);
234 SLOW_PATH_HIDDEN_DECL(slow_path_pow);
235 SLOW_PATH_HIDDEN_DECL(slow_path_lshift);
236 SLOW_PATH_HIDDEN_DECL(slow_path_rshift);
237 SLOW_PATH_HIDDEN_DECL(slow_path_urshift);
238 SLOW_PATH_HIDDEN_DECL(slow_path_unsigned);
239 SLOW_PATH_HIDDEN_DECL(slow_path_bitnot);
240 SLOW_PATH_HIDDEN_DECL(slow_path_bitand);
241 SLOW_PATH_HIDDEN_DECL(slow_path_bitor);
242 SLOW_PATH_HIDDEN_DECL(slow_path_bitxor);
243 SLOW_PATH_HIDDEN_DECL(slow_path_typeof);
244 SLOW_PATH_HIDDEN_DECL(slow_path_is_object);
245 SLOW_PATH_HIDDEN_DECL(slow_path_is_object_or_null);
246 SLOW_PATH_HIDDEN_DECL(slow_path_is_function);
247 SLOW_PATH_HIDDEN_DECL(slow_path_in_by_id);
248 SLOW_PATH_HIDDEN_DECL(slow_path_in_by_val);
249 SLOW_PATH_HIDDEN_DECL(slow_path_del_by_val);
250 SLOW_PATH_HIDDEN_DECL(slow_path_strcat);
251 SLOW_PATH_HIDDEN_DECL(slow_path_to_primitive);
<span class="line-added">252 SLOW_PATH_HIDDEN_DECL(slow_path_to_property_key);</span>
253 SLOW_PATH_HIDDEN_DECL(slow_path_get_enumerable_length);
254 SLOW_PATH_HIDDEN_DECL(slow_path_has_generic_property);
255 SLOW_PATH_HIDDEN_DECL(slow_path_has_structure_property);
256 SLOW_PATH_HIDDEN_DECL(slow_path_has_indexed_property);
257 SLOW_PATH_HIDDEN_DECL(slow_path_get_direct_pname);
258 SLOW_PATH_HIDDEN_DECL(slow_path_get_property_enumerator);
259 SLOW_PATH_HIDDEN_DECL(slow_path_enumerator_structure_pname);
260 SLOW_PATH_HIDDEN_DECL(slow_path_enumerator_generic_pname);
261 SLOW_PATH_HIDDEN_DECL(slow_path_to_index_string);
262 SLOW_PATH_HIDDEN_DECL(slow_path_profile_type_clear_log);
263 SLOW_PATH_HIDDEN_DECL(slow_path_unreachable);
264 SLOW_PATH_HIDDEN_DECL(slow_path_create_lexical_environment);
265 SLOW_PATH_HIDDEN_DECL(slow_path_push_with_scope);
266 SLOW_PATH_HIDDEN_DECL(slow_path_resolve_scope);
267 SLOW_PATH_HIDDEN_DECL(slow_path_is_var_scope);
268 SLOW_PATH_HIDDEN_DECL(slow_path_resolve_scope_for_hoisting_func_decl_in_eval);
<span class="line-added">269 SLOW_PATH_HIDDEN_DECL(slow_path_create_promise);</span>
<span class="line-added">270 SLOW_PATH_HIDDEN_DECL(slow_path_create_generator);</span>
<span class="line-added">271 SLOW_PATH_HIDDEN_DECL(slow_path_create_async_generator);</span>
272 SLOW_PATH_HIDDEN_DECL(slow_path_create_rest);
273 SLOW_PATH_HIDDEN_DECL(slow_path_get_by_id_with_this);
274 SLOW_PATH_HIDDEN_DECL(slow_path_get_by_val_with_this);
275 SLOW_PATH_HIDDEN_DECL(slow_path_put_by_id_with_this);
276 SLOW_PATH_HIDDEN_DECL(slow_path_put_by_val_with_this);
277 SLOW_PATH_HIDDEN_DECL(slow_path_define_data_property);
278 SLOW_PATH_HIDDEN_DECL(slow_path_define_accessor_property);
279 SLOW_PATH_HIDDEN_DECL(slow_path_throw_static_error);
<span class="line-added">280 SLOW_PATH_HIDDEN_DECL(slow_path_new_promise);</span>
<span class="line-added">281 SLOW_PATH_HIDDEN_DECL(slow_path_new_generator);</span>
282 SLOW_PATH_HIDDEN_DECL(slow_path_new_array_with_spread);
283 SLOW_PATH_HIDDEN_DECL(slow_path_new_array_buffer);
284 SLOW_PATH_HIDDEN_DECL(slow_path_spread);
285 
<span class="line-modified">286 using SlowPathFunction = SlowPathReturnType(SLOW_PATH *)(CallFrame*, const Instruction*);</span>
287 
288 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="CommonSlowPaths.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Completion.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/DebuggerScope.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DebuggerPrimitives.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DebuggerScope.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/DebuggerScope.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 60 {
 61     DebuggerScope* thisObject = jsCast&lt;DebuggerScope*&gt;(cell);
 62     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 63     Base::visitChildren(cell, visitor);
 64 
 65     visitor.append(thisObject-&gt;m_scope);
 66     visitor.append(thisObject-&gt;m_next);
 67 }
 68 
 69 String DebuggerScope::className(const JSObject* object, VM&amp; vm)
 70 {
 71     const DebuggerScope* scope = jsCast&lt;const DebuggerScope*&gt;(object);
 72     // We cannot assert that scope-&gt;isValid() because the TypeProfiler may encounter an invalidated
 73     // DebuggerScope in its log entries. We just need to handle it appropriately as below.
 74     if (!scope-&gt;isValid())
 75         return String();
 76     JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
 77     return thisObject-&gt;methodTable(vm)-&gt;className(thisObject, vm);
 78 }
 79 
<span class="line-modified"> 80 String DebuggerScope::toStringName(const JSObject* object, ExecState* exec)</span>
 81 {
 82     const DebuggerScope* scope = jsCast&lt;const DebuggerScope*&gt;(object);
 83     // We cannot assert that scope-&gt;isValid() because the TypeProfiler may encounter an invalidated
 84     // DebuggerScope in its log entries. We just need to handle it appropriately as below.
 85     if (!scope-&gt;isValid())
 86         return String();
 87     JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
<span class="line-modified"> 88     return thisObject-&gt;methodTable(exec-&gt;vm())-&gt;toStringName(thisObject, exec);</span>
 89 }
 90 
<span class="line-modified"> 91 bool DebuggerScope::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
 92 {
 93     DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(object);
 94     if (!scope-&gt;isValid())
 95         return false;
 96     JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
 97     slot.setThisValue(JSValue(thisObject));
 98 
 99     // By default, JSObject::getPropertySlot() will look in the DebuggerScope&#39;s prototype
100     // chain and not the wrapped scope, and JSObject::getPropertySlot() cannot be overridden
101     // to behave differently for the DebuggerScope.
102     //
103     // Instead, we&#39;ll treat all properties in the wrapped scope and its prototype chain as
104     // the own properties of the DebuggerScope. This is fine because the WebInspector
105     // does not presently need to distinguish between what&#39;s owned at each level in the
106     // prototype chain. Hence, we&#39;ll invoke getPropertySlot() on the wrapped scope here
107     // instead of getOwnPropertySlot().
<span class="line-modified">108     bool result = thisObject-&gt;getPropertySlot(exec, propertyName, slot);</span>
<span class="line-modified">109     if (result &amp;&amp; slot.isValue() &amp;&amp; slot.getValue(exec, propertyName) == jsTDZValue()) {</span>
110         // FIXME:
111         // We hit a scope property that has the TDZ empty value.
112         // Currently, we just lie to the inspector and claim that this property is undefined.
113         // This is not ideal and we should fix it.
114         // https://bugs.webkit.org/show_bug.cgi?id=144977
115         slot.setValue(slot.slotBase(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), jsUndefined());
116         return true;
117     }
118     return result;
119 }
120 
<span class="line-modified">121 bool DebuggerScope::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
122 {
123     DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(cell);
124     ASSERT(scope-&gt;isValid());
125     if (!scope-&gt;isValid())
126         return false;
127     JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
128     slot.setThisValue(JSValue(thisObject));
<span class="line-modified">129     return thisObject-&gt;methodTable(exec-&gt;vm())-&gt;put(thisObject, exec, propertyName, value, slot);</span>
130 }
131 
<span class="line-modified">132 bool DebuggerScope::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
133 {
134     DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(cell);
135     ASSERT(scope-&gt;isValid());
136     if (!scope-&gt;isValid())
137         return false;
138     JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
<span class="line-modified">139     return thisObject-&gt;methodTable(exec-&gt;vm())-&gt;deleteProperty(thisObject, exec, propertyName);</span>
140 }
141 
<span class="line-modified">142 void DebuggerScope::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
143 {
144     DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(object);
145     ASSERT(scope-&gt;isValid());
146     if (!scope-&gt;isValid())
147         return;
148     JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
<span class="line-modified">149     thisObject-&gt;methodTable(exec-&gt;vm())-&gt;getPropertyNames(thisObject, exec, propertyNames, mode);</span>
150 }
151 
<span class="line-modified">152 bool DebuggerScope::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
153 {
154     DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(object);
155     ASSERT(scope-&gt;isValid());
156     if (!scope-&gt;isValid())
157         return false;
158     JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
<span class="line-modified">159     return thisObject-&gt;methodTable(exec-&gt;vm())-&gt;defineOwnProperty(thisObject, exec, propertyName, descriptor, shouldThrow);</span>
160 }
161 
162 DebuggerScope* DebuggerScope::next()
163 {
164     ASSERT(isValid());
165     if (!m_next &amp;&amp; m_scope-&gt;next()) {
166         VM&amp; vm = m_scope-&gt;vm();
167         DebuggerScope* nextScope = create(vm, m_scope-&gt;next());
168         m_next.set(vm, this, nextScope);
169     }
170     return m_next.get();
171 }
172 
173 void DebuggerScope::invalidateChain()
174 {
175     if (!isValid())
176         return;
177 
178     DebuggerScope* scope = this;
179     while (scope) {
</pre>
<hr />
<pre>
232     if (!codeBlock)
233         return String();
234 
235     return String::fromUTF8(codeBlock-&gt;inferredName());
236 }
237 
238 DebuggerLocation DebuggerScope::location() const
239 {
240     SymbolTable* symbolTable = m_scope-&gt;symbolTable(vm());
241     if (!symbolTable)
242         return DebuggerLocation();
243 
244     CodeBlock* codeBlock = symbolTable-&gt;rareDataCodeBlock();
245     if (!codeBlock)
246         return DebuggerLocation();
247 
248     ScriptExecutable* executable = codeBlock-&gt;ownerExecutable();
249     return DebuggerLocation(executable);
250 }
251 
<span class="line-modified">252 JSValue DebuggerScope::caughtValue(ExecState* exec) const</span>
253 {
254     ASSERT(isCatchScope());
255     JSLexicalEnvironment* catchEnvironment = jsCast&lt;JSLexicalEnvironment*&gt;(m_scope.get());
256     SymbolTable* catchSymbolTable = catchEnvironment-&gt;symbolTable();
257     RELEASE_ASSERT(catchSymbolTable-&gt;size() == 1);
258     PropertyName errorName(catchSymbolTable-&gt;begin(catchSymbolTable-&gt;m_lock)-&gt;key.get());
259     PropertySlot slot(m_scope.get(), PropertySlot::InternalMethodType::Get);
<span class="line-modified">260     bool success = catchEnvironment-&gt;getOwnPropertySlot(catchEnvironment, exec, errorName, slot);</span>
261     RELEASE_ASSERT(success &amp;&amp; slot.isValue());
<span class="line-modified">262     return slot.getValue(exec, errorName);</span>
263 }
264 
265 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 60 {
 61     DebuggerScope* thisObject = jsCast&lt;DebuggerScope*&gt;(cell);
 62     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 63     Base::visitChildren(cell, visitor);
 64 
 65     visitor.append(thisObject-&gt;m_scope);
 66     visitor.append(thisObject-&gt;m_next);
 67 }
 68 
 69 String DebuggerScope::className(const JSObject* object, VM&amp; vm)
 70 {
 71     const DebuggerScope* scope = jsCast&lt;const DebuggerScope*&gt;(object);
 72     // We cannot assert that scope-&gt;isValid() because the TypeProfiler may encounter an invalidated
 73     // DebuggerScope in its log entries. We just need to handle it appropriately as below.
 74     if (!scope-&gt;isValid())
 75         return String();
 76     JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
 77     return thisObject-&gt;methodTable(vm)-&gt;className(thisObject, vm);
 78 }
 79 
<span class="line-modified"> 80 String DebuggerScope::toStringName(const JSObject* object, JSGlobalObject* globalObject)</span>
 81 {
 82     const DebuggerScope* scope = jsCast&lt;const DebuggerScope*&gt;(object);
 83     // We cannot assert that scope-&gt;isValid() because the TypeProfiler may encounter an invalidated
 84     // DebuggerScope in its log entries. We just need to handle it appropriately as below.
 85     if (!scope-&gt;isValid())
 86         return String();
 87     JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
<span class="line-modified"> 88     return thisObject-&gt;methodTable(globalObject-&gt;vm())-&gt;toStringName(thisObject, globalObject);</span>
 89 }
 90 
<span class="line-modified"> 91 bool DebuggerScope::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
 92 {
 93     DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(object);
 94     if (!scope-&gt;isValid())
 95         return false;
 96     JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
 97     slot.setThisValue(JSValue(thisObject));
 98 
 99     // By default, JSObject::getPropertySlot() will look in the DebuggerScope&#39;s prototype
100     // chain and not the wrapped scope, and JSObject::getPropertySlot() cannot be overridden
101     // to behave differently for the DebuggerScope.
102     //
103     // Instead, we&#39;ll treat all properties in the wrapped scope and its prototype chain as
104     // the own properties of the DebuggerScope. This is fine because the WebInspector
105     // does not presently need to distinguish between what&#39;s owned at each level in the
106     // prototype chain. Hence, we&#39;ll invoke getPropertySlot() on the wrapped scope here
107     // instead of getOwnPropertySlot().
<span class="line-modified">108     bool result = thisObject-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
<span class="line-modified">109     if (result &amp;&amp; slot.isValue() &amp;&amp; slot.getValue(globalObject, propertyName) == jsTDZValue()) {</span>
110         // FIXME:
111         // We hit a scope property that has the TDZ empty value.
112         // Currently, we just lie to the inspector and claim that this property is undefined.
113         // This is not ideal and we should fix it.
114         // https://bugs.webkit.org/show_bug.cgi?id=144977
115         slot.setValue(slot.slotBase(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), jsUndefined());
116         return true;
117     }
118     return result;
119 }
120 
<span class="line-modified">121 bool DebuggerScope::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
122 {
123     DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(cell);
124     ASSERT(scope-&gt;isValid());
125     if (!scope-&gt;isValid())
126         return false;
127     JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
128     slot.setThisValue(JSValue(thisObject));
<span class="line-modified">129     return thisObject-&gt;methodTable(globalObject-&gt;vm())-&gt;put(thisObject, globalObject, propertyName, value, slot);</span>
130 }
131 
<span class="line-modified">132 bool DebuggerScope::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)</span>
133 {
134     DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(cell);
135     ASSERT(scope-&gt;isValid());
136     if (!scope-&gt;isValid())
137         return false;
138     JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
<span class="line-modified">139     return thisObject-&gt;methodTable(globalObject-&gt;vm())-&gt;deleteProperty(thisObject, globalObject, propertyName);</span>
140 }
141 
<span class="line-modified">142 void DebuggerScope::getOwnPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
143 {
144     DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(object);
145     ASSERT(scope-&gt;isValid());
146     if (!scope-&gt;isValid())
147         return;
148     JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
<span class="line-modified">149     thisObject-&gt;methodTable(globalObject-&gt;vm())-&gt;getPropertyNames(thisObject, globalObject, propertyNames, mode);</span>
150 }
151 
<span class="line-modified">152 bool DebuggerScope::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
153 {
154     DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(object);
155     ASSERT(scope-&gt;isValid());
156     if (!scope-&gt;isValid())
157         return false;
158     JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
<span class="line-modified">159     return thisObject-&gt;methodTable(globalObject-&gt;vm())-&gt;defineOwnProperty(thisObject, globalObject, propertyName, descriptor, shouldThrow);</span>
160 }
161 
162 DebuggerScope* DebuggerScope::next()
163 {
164     ASSERT(isValid());
165     if (!m_next &amp;&amp; m_scope-&gt;next()) {
166         VM&amp; vm = m_scope-&gt;vm();
167         DebuggerScope* nextScope = create(vm, m_scope-&gt;next());
168         m_next.set(vm, this, nextScope);
169     }
170     return m_next.get();
171 }
172 
173 void DebuggerScope::invalidateChain()
174 {
175     if (!isValid())
176         return;
177 
178     DebuggerScope* scope = this;
179     while (scope) {
</pre>
<hr />
<pre>
232     if (!codeBlock)
233         return String();
234 
235     return String::fromUTF8(codeBlock-&gt;inferredName());
236 }
237 
238 DebuggerLocation DebuggerScope::location() const
239 {
240     SymbolTable* symbolTable = m_scope-&gt;symbolTable(vm());
241     if (!symbolTable)
242         return DebuggerLocation();
243 
244     CodeBlock* codeBlock = symbolTable-&gt;rareDataCodeBlock();
245     if (!codeBlock)
246         return DebuggerLocation();
247 
248     ScriptExecutable* executable = codeBlock-&gt;ownerExecutable();
249     return DebuggerLocation(executable);
250 }
251 
<span class="line-modified">252 JSValue DebuggerScope::caughtValue(JSGlobalObject* globalObject) const</span>
253 {
254     ASSERT(isCatchScope());
255     JSLexicalEnvironment* catchEnvironment = jsCast&lt;JSLexicalEnvironment*&gt;(m_scope.get());
256     SymbolTable* catchSymbolTable = catchEnvironment-&gt;symbolTable();
257     RELEASE_ASSERT(catchSymbolTable-&gt;size() == 1);
258     PropertyName errorName(catchSymbolTable-&gt;begin(catchSymbolTable-&gt;m_lock)-&gt;key.get());
259     PropertySlot slot(m_scope.get(), PropertySlot::InternalMethodType::Get);
<span class="line-modified">260     bool success = catchEnvironment-&gt;getOwnPropertySlot(catchEnvironment, globalObject, errorName, slot);</span>
261     RELEASE_ASSERT(success &amp;&amp; slot.isValue());
<span class="line-modified">262     return slot.getValue(globalObject, errorName);</span>
263 }
264 
265 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="DebuggerPrimitives.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DebuggerScope.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
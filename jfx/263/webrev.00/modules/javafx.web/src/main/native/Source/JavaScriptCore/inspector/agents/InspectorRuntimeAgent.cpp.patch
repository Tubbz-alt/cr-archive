diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorRuntimeAgent.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorRuntimeAgent.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorRuntimeAgent.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorRuntimeAgent.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2013-2015 Apple Inc. All rights reserved.
+ * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
  * Copyright (C) 2011 Google Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are
  * met:
@@ -54,10 +54,17 @@
 static bool asBool(const bool* b)
 {
     return b && *b;
 }
 
+static int asInt(const int* i)
+{
+    if (i)
+        return *i;
+    return 0;
+}
+
 InspectorRuntimeAgent::InspectorRuntimeAgent(AgentContext& context)
     : InspectorAgentBase("Runtime"_s)
     , m_injectedScriptManager(context.injectedScriptManager)
     , m_scriptDebugServer(context.environment.scriptDebugServer())
     , m_vm(context.environment.vm())
@@ -146,11 +153,11 @@
         else
             callback->sendSuccess(WTFMove(result), wasThrown, savedResultIndex);
     });
 }
 
-void InspectorRuntimeAgent::callFunctionOn(ErrorString& errorString, const String& objectId, const String& expression, const JSON::Array* optionalArguments, const bool* doNotPauseOnExceptionsAndMuteConsole, const bool* returnByValue, const bool* generatePreview, RefPtr<Protocol::Runtime::RemoteObject>& result, Optional<bool>& wasThrown)
+void InspectorRuntimeAgent::callFunctionOn(ErrorString& errorString, const String& objectId, const String& expression, const JSON::Array* optionalArguments, const bool* doNotPauseOnExceptionsAndMuteConsole, const bool* returnByValue, const bool* generatePreview, const bool* /* emulateUserGesture */, RefPtr<Protocol::Runtime::RemoteObject>& result, Optional<bool>& wasThrown)
 {
     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
     if (injectedScript.hasNoValue()) {
         errorString = "Missing injected script for given objectId"_s;
         return;
@@ -189,58 +196,97 @@
 
     unmuteConsole();
     setPauseOnExceptionsState(m_scriptDebugServer, previousPauseOnExceptionsState);
 }
 
-void InspectorRuntimeAgent::getProperties(ErrorString& errorString, const String& objectId, const bool* ownProperties, const bool* generatePreview, RefPtr<JSON::ArrayOf<Protocol::Runtime::PropertyDescriptor>>& result, RefPtr<JSON::ArrayOf<Protocol::Runtime::InternalPropertyDescriptor>>& internalProperties)
+void InspectorRuntimeAgent::getProperties(ErrorString& errorString, const String& objectId, const bool* ownProperties, const int* fetchStart, const int* fetchCount, const bool* generatePreview, RefPtr<JSON::ArrayOf<Protocol::Runtime::PropertyDescriptor>>& properties, RefPtr<JSON::ArrayOf<Protocol::Runtime::InternalPropertyDescriptor>>& internalProperties)
 {
     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
     if (injectedScript.hasNoValue()) {
         errorString = "Missing injected script for given objectId"_s;
         return;
     }
 
+    int start = asInt(fetchStart);
+    if (start < 0) {
+        errorString = "fetchStart cannot be negative"_s;
+        return;
+    }
+
+    int count = asInt(fetchCount);
+    if (count < 0) {
+        errorString = "fetchCount cannot be negative"_s;
+        return;
+    }
+
     ScriptDebugServer::PauseOnExceptionsState previousPauseOnExceptionsState = setPauseOnExceptionsState(m_scriptDebugServer, ScriptDebugServer::DontPauseOnExceptions);
     muteConsole();
 
-    injectedScript.getProperties(errorString, objectId, asBool(ownProperties), asBool(generatePreview), result);
-    injectedScript.getInternalProperties(errorString, objectId, asBool(generatePreview), internalProperties);
+    injectedScript.getProperties(errorString, objectId, asBool(ownProperties), start, count, asBool(generatePreview), properties);
+
+    // Only include internal properties for the first fetch.
+    if (!start)
+        injectedScript.getInternalProperties(errorString, objectId, asBool(generatePreview), internalProperties);
 
     unmuteConsole();
     setPauseOnExceptionsState(m_scriptDebugServer, previousPauseOnExceptionsState);
 }
 
-void InspectorRuntimeAgent::getDisplayableProperties(ErrorString& errorString, const String& objectId, const bool* generatePreview, RefPtr<JSON::ArrayOf<Protocol::Runtime::PropertyDescriptor>>& result, RefPtr<JSON::ArrayOf<Protocol::Runtime::InternalPropertyDescriptor>>& internalProperties)
+void InspectorRuntimeAgent::getDisplayableProperties(ErrorString& errorString, const String& objectId, const int* fetchStart, const int* fetchCount, const bool* generatePreview, RefPtr<JSON::ArrayOf<Protocol::Runtime::PropertyDescriptor>>& properties, RefPtr<JSON::ArrayOf<Protocol::Runtime::InternalPropertyDescriptor>>& internalProperties)
 {
     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
     if (injectedScript.hasNoValue()) {
         errorString = "Missing injected script for given objectId"_s;
         return;
     }
 
+    int start = asInt(fetchStart);
+    if (start < 0) {
+        errorString = "fetchStart cannot be negative"_s;
+        return;
+    }
+
+    int count = asInt(fetchCount);
+    if (count < 0) {
+        errorString = "fetchCount cannot be negative"_s;
+        return;
+    }
+
     ScriptDebugServer::PauseOnExceptionsState previousPauseOnExceptionsState = setPauseOnExceptionsState(m_scriptDebugServer, ScriptDebugServer::DontPauseOnExceptions);
     muteConsole();
 
-    injectedScript.getDisplayableProperties(errorString, objectId, asBool(generatePreview), result);
-    injectedScript.getInternalProperties(errorString, objectId, asBool(generatePreview), internalProperties);
+    injectedScript.getDisplayableProperties(errorString, objectId, start, count, asBool(generatePreview), properties);
+
+    // Only include internal properties for the first fetch.
+    if (!start)
+        injectedScript.getInternalProperties(errorString, objectId, asBool(generatePreview), internalProperties);
 
     unmuteConsole();
     setPauseOnExceptionsState(m_scriptDebugServer, previousPauseOnExceptionsState);
 }
 
-void InspectorRuntimeAgent::getCollectionEntries(ErrorString& errorString, const String& objectId, const String* objectGroup, const int* startIndex, const int* numberToFetch, RefPtr<JSON::ArrayOf<Protocol::Runtime::CollectionEntry>>& entries)
+void InspectorRuntimeAgent::getCollectionEntries(ErrorString& errorString, const String& objectId, const String* objectGroup, const int* fetchStart, const int* fetchCount, RefPtr<JSON::ArrayOf<Protocol::Runtime::CollectionEntry>>& entries)
 {
     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
     if (injectedScript.hasNoValue()) {
         errorString = "Missing injected script for given objectId"_s;
         return;
     }
 
-    int start = startIndex && *startIndex >= 0 ? *startIndex : 0;
-    int fetch = numberToFetch && *numberToFetch >= 0 ? *numberToFetch : 0;
+    int start = asInt(fetchStart);
+    if (start < 0) {
+        errorString = "fetchStart cannot be negative"_s;
+        return;
+    }
+
+    int count = asInt(fetchCount);
+    if (count < 0) {
+        errorString = "fetchCount cannot be negative"_s;
+        return;
+    }
 
-    injectedScript.getCollectionEntries(errorString, objectId, objectGroup ? *objectGroup : String(), start, fetch, entries);
+    injectedScript.getCollectionEntries(errorString, objectId, objectGroup ? *objectGroup : String(), start, count, entries);
 }
 
 void InspectorRuntimeAgent::saveResult(ErrorString& errorString, const JSON::Object& callArgument, const int* executionContextId, Optional<int>& savedResultIndex)
 {
     InjectedScript injectedScript;
@@ -281,11 +327,11 @@
     m_injectedScriptManager.releaseObjectGroup(objectGroup);
 }
 
 void InspectorRuntimeAgent::getRuntimeTypesForVariablesAtOffsets(ErrorString& errorString, const JSON::Array& locations, RefPtr<JSON::ArrayOf<Protocol::Runtime::TypeDescription>>& typeDescriptions)
 {
-    static const bool verbose = false;
+    static constexpr bool verbose = false;
 
     typeDescriptions = JSON::ArrayOf<Protocol::Runtime::TypeDescription>::create();
     if (!m_vm.typeProfiler()) {
         errorString = "VM has no type information"_s;
         return;
